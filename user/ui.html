<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <meta content="width=device-width, initial-scale=1" name="viewport">
    <title>Nvim documentation: ui</title>
    <link href="https://fonts.googleapis.com/css?family=Lato:400,700,900" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.0/normalize.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
    <link href="/css/main.css" rel="stylesheet">
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    
  </head>
  <body>
    <header class="navbar">
      <div class="container">
        <nav class="navbar">
          <div class="container-fluid">
            <div class="navbar-header">

              <a href="/" class="navbar-brand">
                <img src="/images/logo@2x.png" id="navbar-logo" alt="Neovim">
              </a>
            </div>
          </div>
        </nav>
      </div>
    </header>

    <div class="container">
      <h1>Nvim documentation: ui</h1>
<A NAME="top"></A>
<A HREF="index.html">main help file</A>

<HR>
<PRE>

*<A NAME="ui.txt"></A><B>ui.txt</B>*	Nvim


			    NVIM REFERENCE MANUAL



Nvim <A HREF="#UI">UI</A> protocol					*<A NAME="UI"></A><B>UI</B>* *<A NAME="ui"></A><B>ui</B>*

                                      Type |<A HREF="various.html#gO">gO</A>| to see the table of contents.

==============================================================================

<A HREF="#UI">UI</A> Events						*<A NAME="ui-events"></A><B>ui-events</B>*

UIs can be implemented <A HREF="motion.html#as">as</A> external client processes communicating with Nvim
over the <A HREF="api.html#RPC">RPC</A> <A HREF="api.html#API">API</A>. The default <A HREF="#UI">UI</A> model is a terminal-like grid with a single,
monospace font. The <A HREF="#UI">UI</A> can opt-in to have <A HREF="windows.html#windows">windows</A> drawn on separate grids, and
have some elements (&quot;widgets&quot;) presented by the <A HREF="#UI">UI</A> itself rather than by Nvim
(&quot;externalized&quot;).


							*<A NAME="ui-option"></A><B>ui-option</B>*
Call |<A HREF="api.html#nvim_ui_attach()">nvim_ui_attach()</A>| to tell Nvim that your program wants to draw the Nvim
screen grid with a size of width × height cells. This is typically done by an
embedder at startup (see |<A HREF="#ui-startup">ui-startup</A>|), but UIs can also connect to a running
Nvim instance and invoke <A HREF="api.html#nvim_ui_attach()">nvim_ui_attach()</A>. The `options` parameter is a map
with these (optional) keys:

							*<A NAME="ui-rgb"></A><B>ui-rgb</B>*
	`rgb`			Decides the color format.
				true:	(default) 24-bit RGB colors
				false:	Terminal colors (8-bit, max 256)

							*<A NAME="ui-override"></A><B>ui-override</B>*
	`override`		Decides how <A HREF="#UI">UI</A> capabilities are resolved.
				true:	Enable requested <A HREF="#UI">UI</A> capabilities, even
					if not supported by all connected UIs
					(including |<A HREF="term.html#TUI">TUI</A>|).
				false:	(default) Disable <A HREF="#UI">UI</A> capabilities not
					supported by all connected UIs
					(including <A HREF="term.html#TUI">TUI</A>).

							*<A NAME="ui-ext-options"></A><B>ui-ext-options</B>*
	`ext_cmdline`		Externalize the cmdline. |<A HREF="#ui-cmdline">ui-cmdline</A>|
	`ext_hlstate`		Detailed highlight state. |<A HREF="#ui-hlstate">ui-hlstate</A>|
				Sets `ext_linegrid` implicitly.
	`ext_linegrid`		Line-based grid <A HREF="autocmd.html#events">events</A>. |<A HREF="#ui-linegrid">ui-linegrid</A>|
				Deactivates |<A HREF="#ui-grid-old">ui-grid-old</A>| implicitly.
	`ext_messages`		Externalize messages. |<A HREF="#ui-messages">ui-messages</A>|
				Sets `ext_linegrid` and `ext_cmdline` implicitly.
	`ext_multigrid`		Per-window grid <A HREF="autocmd.html#events">events</A>. |<A HREF="#ui-multigrid">ui-multigrid</A>|
				Sets `ext_linegrid` implicitly.
	`ext_popupmenu`		Externalize |<A HREF="insert.html#popupmenu-completion">popupmenu-completion</A>| and
				<A HREF="options.html#'wildmenu'">'wildmenu'</A>. |<A HREF="#ui-popupmenu">ui-popupmenu</A>|
	`ext_tabline`		Externalize the tabline. |<A HREF="#ui-tabline">ui-tabline</A>|
	`ext_termcolors`	Use external default colors.

Specifying an unknown option is an error; UIs can check the |<A HREF="api.html#api-metadata">api-metadata</A>|
`ui_options` key for supported <A HREF="options.html#options">options</A>.

By default Nvim requires all connected UIs to support the same capabilities,
thus the active capabilities are the intersection of those requested. UIs may
specify |<A HREF="#ui-override">ui-override</A>| to invert this behavior (useful for debugging). The
&quot;option_set&quot; event announces which capabilities are active.

Nvim sends <A HREF="api.html#RPC">RPC</A> notifications to all attached UIs, with method name &quot;redraw&quot;
and a single argument: an array (batch) of screen &quot;update events&quot;. Each update
event is itself an array whose first element is the event name and remaining
elements are event-parameter tuples. Thus multiple <A HREF="autocmd.html#events">events</A> of the same kind can
be sent contiguously without <A HREF="repeat.html#repeating">repeating</A> the event name.

Example of a typical &quot;redraw&quot; batch in a single <A HREF="api.html#RPC">RPC</A> notification:

<B>    ['notification', 'redraw',</B>
<B>      [</B>
<B>	['grid_resize', [2, 77, 36]],</B>
<B>	['grid_line',</B>
<B>	  [2, 0, 0, [[' ' , 0, 77]]],</B>
<B>	  [2, 1, 0, [['~', 7], [' ', 7, 76]]],</B>
<B>	  [2, 9, 0, [['~', 7], [' ', 7, 76]]], </B>
<B>	  ...</B>
<B>	  [2, 35, 0, [['~', 7], [' ', 7, 76]]],</B>
<B>	  [1, 36, 0, [['[', 9], ['N'], ['o'], [' '], ['N'], ['a'], ['m'], ['e'], [']']]],</B>
<B>	  [1, 36, 9, [[' ', 9, 50]]],</B>
<B>	  [1, 36, 59, [['0', 9], [','], ['0'], ['-' ], ['1'], [' ', 9, 10], ['A'], ['l', 9, 2]]]</B>
<B>	],</B>
<B>	['msg_showmode', [[]]],</B>
<B>	['win_pos', [2, 1000, 0, 0, 77, 36]],</B>
<B>	['grid_cursor_goto', [2, 0, 0]],</B>
<B>	['flush', []]</B>
<B>      ]</B>
<B>    ]</B>

Events must be handled in-order. Nvim sends a &quot;flush&quot; event when <A HREF="motion.html#it">it</A> has
completed a redraw of the entire screen (so all <A HREF="windows.html#windows">windows</A> have a consistent view
of buffer state, <A HREF="options.html#options">options</A>, etc.). Multiple &quot;redraw&quot; batches may be sent before
the entire screen has been redrawn, with &quot;flush&quot; following only the last
batch. The user should only see the final state (when &quot;flush&quot; is sent), not
any intermediate state while processing part of the batch array, nor after
a batch not ending with &quot;flush&quot;.

By default, Nvim sends |<A HREF="#ui-global">ui-global</A>| and |<A HREF="#ui-grid-old">ui-grid-old</A>| <A HREF="autocmd.html#events">events</A> (for backwards
compatibility); these suffice to implement a terminal-like interface. However
the new |<A HREF="#ui-linegrid">ui-linegrid</A>| represents text more efficiently (especially highlighted
text), and allows <A HREF="#UI">UI</A> capabilities requiring multiple grids. New UIs should
implement |<A HREF="#ui-linegrid">ui-linegrid</A>| instead of |<A HREF="#ui-grid-old">ui-grid-old</A>|.

Nvim optionally sends various screen elements &quot;semantically&quot; <A HREF="motion.html#as">as</A> structured
<A HREF="autocmd.html#events">events</A> instead of raw grid-lines, <A HREF="motion.html#as">as</A> specified by |<A HREF="#ui-ext-options">ui-ext-options</A>|. The <A HREF="#UI">UI</A>
must present such elements itself, Nvim will not draw them on the grid.

Future versions of Nvim may add new update kinds and may append new parameters
to existing update kinds. Clients must be prepared to ignore such extensions,
for forward-compatibility. |<A HREF="api.html#api-contract">api-contract</A>|

==============================================================================

<A HREF="#UI">UI</A> <A HREF="starting.html#startup">startup</A>							   *<A NAME="ui-startup"></A><B>ui-startup</B>*

<A HREF="#UI">UI</A> embedders (clients that start Nvim with |<A HREF="starting.html#--embed">--embed</A>| and later call
|<A HREF="api.html#nvim_ui_attach()">nvim_ui_attach()</A>|) must start Nvim without |<A HREF="starting.html#--headless">--headless</A>|:
<B>    nvim --embed</B>
Nvim will pause before loading <A HREF="starting.html#startup">startup</A> files and reading <A HREF="windows.html#buffers">buffers</A>, so the <A HREF="#UI">UI</A>
has a chance to invoke requests and <A HREF="diff.html#do">do</A> early <A HREF="starting.html#initialization">initialization</A>. Startup will
continue <A HREF="motion.html#as">as</A> soon <A HREF="motion.html#as">as</A> the <A HREF="#UI">UI</A> invokes |<A HREF="api.html#nvim_ui_attach()">nvim_ui_attach()</A>|.

A simple <A HREF="#UI">UI</A> only needs to <A HREF="diff.html#do">do</A> a single |<A HREF="api.html#nvim_ui_attach()">nvim_ui_attach()</A>| request and then
prepare to handle any <A HREF="#UI">UI</A> event. A more featureful <A HREF="#UI">UI</A>, which might need
additional configuration of the Nvim process, should use the following <A HREF="starting.html#startup">startup</A>
procedure:

1. Invoke |<A HREF="api.html#nvim_get_api_info()">nvim_get_api_info()</A>|, if needed to setup the client library and/or
   to get the <A HREF="eval.html#list">list</A> of supported <A HREF="#UI">UI</A> extensions.
2. Do any configuration that should be happen before user <A HREF="starting.html#config">config</A> is loaded.
   Buffers and <A HREF="windows.html#windows">windows</A> are not available at this point, but this could be used
   to set |<A HREF="eval.html#g:">g:</A>| <A HREF="eval.html#variables">variables</A> visible to <A HREF="starting.html#init.vim">init.vim</A>
3. If the <A HREF="#UI">UI</A> wants to <A HREF="diff.html#do">do</A> additional setup after user <A HREF="starting.html#config">config</A> is loaded,
   <A HREF="intro.html#register">register</A> a <A HREF="autocmd.html#VimEnter">VimEnter</A> <A HREF="autocmd.html#autocmd">autocmd</A>:
<B>      nvim_command("autocmd VimEnter * call rpcrequest(1, 'vimenter')")</B>
 4. Now invoke |<A HREF="api.html#nvim_ui_attach()">nvim_ui_attach()</A>|. The <A HREF="#UI">UI</A> must handle user input by now:
   sourcing <A HREF="starting.html#init.vim">init.vim</A> and loading <A HREF="windows.html#buffers">buffers</A> might lead to blocking prompts.
5. If step 3 was used, Nvim will send a blocking &quot;vimenter&quot; request to the <A HREF="#UI">UI</A>.
   Inside this request handler, the <A HREF="#UI">UI</A> can safely <A HREF="diff.html#do">do</A> any <A HREF="starting.html#initialization">initialization</A> before
   entering normal mode, for example reading <A HREF="eval.html#variables">variables</A> set by <A HREF="starting.html#init.vim">init.vim</A>.

==============================================================================

Global Events							    *<A NAME="ui-global"></A><B>ui-global</B>*

The following <A HREF="#UI">UI</A> <A HREF="autocmd.html#events">events</A> are always emitted, and describe global state of
the editor.

[&quot;set_title&quot;, title]
[&quot;set_icon&quot;, icon]
	Set the <A HREF="windows.html#window">window</A> title, and icon (minimized) <A HREF="windows.html#window">window</A> title, respectively.
	In windowing systems not distinguishing between the two, &quot;set_icon&quot;
	can be ignored.

[&quot;mode_info_set&quot;, cursor_style_enabled, mode_info]
	`cursor_style_enabled` is a <A HREF="options.html#boolean">boolean</A> indicating if the <A HREF="#UI">UI</A> should set
	the cursor style. `mode_info` is a <A HREF="eval.html#list">list</A> of mode property maps. The
	current mode is given by the `mode_idx` field of the `mode_change`
	event.

	Each mode property map may contain these keys:

<B><FONT color="#54A23D">	KEY		DESCRIPTION </FONT></B>
	`cursor_shape`:	&quot;block&quot;, &quot;horizontal&quot;, &quot;vertical&quot;
	`cell_percentage`: Cell <A HREF="motion.html#&#37;">&#37;</A> occupied by the cursor.
	`blinkwait`, `blinkon`, `blinkoff`: See |<A HREF="options.html#cursor-blinking">cursor-blinking</A>|.
	`attr_id`:	Cursor attribute id (defined by `hl_attr_define`).
			When attr_id is 0, the background and foreground
			colors should be swapped.
	`attr_id_lm`:	Cursor attribute id for when <A HREF="options.html#'langmap'">'langmap'</A> is active.
	`short_name`:	Mode code name, see <A HREF="options.html#'guicursor'">'guicursor'</A>.
	`name`:		Mode descriptive name.
	`mouse_shape`:	(To be implemented.)

	Some keys are missing in some modes.

	The following keys are <A HREF="deprecated.html#deprecated">deprecated</A>:

	`hl_id`:	Use `attr_id` instead.
	`hl_lm`:	Use `attr_id_lm` instead.

[&quot;option_set&quot;, name, value]
	UI-related option changed, where `name` is one of:

	<A HREF="options.html#'arabicshape'">'arabicshape'</A>
	<A HREF="options.html#'ambiwidth'">'ambiwidth'</A>
	<A HREF="options.html#'emoji'">'emoji'</A>
	<A HREF="options.html#'guifont'">'guifont'</A>
	<A HREF="options.html#'guifontwide'">'guifontwide'</A>
	<A HREF="options.html#'linespace'">'linespace'</A>
	<A HREF="options.html#'mousefocus'">'mousefocus'</A>
	<A HREF="options.html#'pumblend'">'pumblend'</A>
	<A HREF="options.html#'showtabline'">'showtabline'</A>
	<A HREF="options.html#'termguicolors'">'termguicolors'</A>
	&quot;ext_*&quot; (all |<A HREF="#ui-ext-options">ui-ext-options</A>|)

	Triggered when the <A HREF="#UI">UI</A> first connects to Nvim, and whenever an option
	is changed by the user or a <A HREF="usr_05.html#plugin">plugin</A>.

	Options are not represented here if their effects are communicated in
	other <A HREF="#UI">UI</A> <A HREF="autocmd.html#events">events</A>. For example, instead of forwarding the <A HREF="options.html#'mouse'">'mouse'</A> option
	value, the &quot;mouse_on&quot; and &quot;mouse_off&quot; <A HREF="#UI">UI</A> <A HREF="autocmd.html#events">events</A> directly indicate if
	mouse support is active. Some <A HREF="options.html#options">options</A> like <A HREF="options.html#'ambiwidth'">'ambiwidth'</A> have already
	taken effect on the grid, where appropriate empty cells are added,
	however a <A HREF="#UI">UI</A> might still use such <A HREF="options.html#options">options</A> when rendering raw text
	sent from Nvim, like for |<A HREF="#ui-cmdline">ui-cmdline</A>|.

[&quot;mode_change&quot;, mode, mode_idx]
	Editor mode changed.  The `mode` parameter is a <A HREF="eval.html#string">string</A> representing
	the current mode. `mode_idx` is an index into the array emitted in
	the `mode_info_set` event. UIs should change the cursor style
	according to the properties specified in the corresponding item. The
	set of modes reported will change in new versions of Nvim, for
	instance more submodes and temporary states might be represented <A HREF="motion.html#as">as</A>
	separate modes.

[&quot;mouse_on&quot;]
[&quot;mouse_off&quot;]
	<A HREF="options.html#'mouse'">'mouse'</A> was enabled/disabled in the current editor mode. Useful for
	a <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> <A HREF="#UI">UI</A>, or embedding into an application where Nvim mouse would
	conflict with other usages of the mouse. Other UI:s may ignore this event.

[&quot;busy_start&quot;]
[&quot;busy_stop&quot;]
	Nvim started or stopped being busy, and possibly not responsive to
	user input. This could be indicated to the user by hiding the cursor.

[&quot;suspend&quot;]
	|<A HREF="starting.html#:suspend">:suspend</A>| command or |<A HREF="starting.html#CTRL-Z">CTRL-Z</A>| <A HREF="map.html#mapping">mapping</A> is used. A <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> client (or
	another client where <A HREF="motion.html#it">it</A> makes sense) could <A HREF="starting.html#suspend">suspend</A> itself.  Other
	clients can safely ignore <A HREF="motion.html#it">it</A>.

[&quot;update_menu&quot;]
	The menu mappings changed.

[&quot;bell&quot;]
[&quot;visual_bell&quot;]
	Notify the user with an audible or visual bell, respectively.

[&quot;flush&quot;]
	Nvim is done redrawing the screen. For an implementation that renders
	to an internal buffer, this is the time to display the redrawn parts
	to the user.

==============================================================================

Grid Events (line-based)					  *<A NAME="ui-linegrid"></A><B>ui-linegrid</B>*

Activated by the `ext_linegrid` |<A HREF="#ui-option">ui-option</A>|. Recommended for all new UIs.
Deactivates |<A HREF="#ui-grid-old">ui-grid-old</A>| implicitly.

The biggest change compared to |<A HREF="#ui-grid-old">ui-grid-old</A>| is to use a single `grid_line`
event to update the contents of a screen line (whereas the old protocol used
a combination of cursor, highlight and text <A HREF="autocmd.html#events">events</A>)

Most of these <A HREF="autocmd.html#events">events</A> take a `grid` index <A HREF="motion.html#as">as</A> first parameter.  Grid 1 is the
global grid used by default for the entire editor screen state. The
`ext_linegrid` capability by itself will never cause any additional grids to
be created; to enable per-window grids, activate |<A HREF="#ui-multigrid">ui-multigrid</A>|.

Highlight attribute groups are predefined. UIs should maintain a table to map
numerical highlight ids to the actual attributes.

[&quot;grid_resize&quot;, grid, width, height]
	Resize a `grid`. If `grid` wasn't seen by the client before, a new grid is
	being created with this size.

[&quot;default_colors_set&quot;, rgb_fg, rgb_bg, rgb_sp, cterm_fg, cterm_bg]
	The first three arguments set the default foreground, background and
	special colors respectively. `cterm_fg` and `cterm_bg` specifies the
	default color codes to use in a 256-color <A HREF="nvim_terminal_emulator.html#terminal">terminal</A>.

	The RGB values will always be valid colors, by default. If no
	colors have been set, they will default to black and white, depending
	on <A HREF="options.html#'background'">'background'</A>. By setting the `ext_termcolors` option, instead
	-1 will be used for unset colors. This is mostly useful for a <A HREF="term.html#TUI">TUI</A>
	implementation, where using the <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> builtin (&quot;ANSI&quot;) defaults
	are expected.

	Note: Unlike the corresponding |<A HREF="#ui-grid-old">ui-grid-old</A>| <A HREF="autocmd.html#events">events</A>, the screen is not
	always cleared after sending this event. The <A HREF="#UI">UI</A> must repaint the
	screen with changed background color itself.


							*<A NAME="ui-event-hl_attr_define"></A><B>ui-event-hl_attr_define</B>*
[&quot;hl_attr_define&quot;, id, rgb_attr, cterm_attr, info]
	Add a highlight with `id`  to the highlight table, with the
	attributes specified by the `rgb_attr` and `cterm_attr` dicts, with the
	following (all optional) keys.

	`foreground`:	foreground color.
	`background`:	background color.
	`special`:	color to use for <A HREF="syntax.html#underline">underline</A> and <A HREF="syntax.html#undercurl">undercurl</A>, when present.
	`reverse`:	reverse video. Foreground and background colors are
			switched.
	`italic`:	<A HREF="syntax.html#italic">italic</A> text.
	`bold`:		<A HREF="syntax.html#bold">bold</A> text.
	`strikethrough`:  struckthrough text.
	`underline`:	underlined text. The line has `special` color.
	`undercurl`:	undercurled text. The curl has `special` color.
	`blend`:	Blend level (0-100). Could be used by UIs to support
			blending floating <A HREF="windows.html#windows">windows</A> to the background or to
			signal a transparent cursor.

	For absent color keys the default color should be used. Don't store
	the default value in the table, rather a sentinel value, so that
	a changed default color will take effect.
	All <A HREF="options.html#boolean">boolean</A> keys default to false, and will only be sent when they
	are true.

	Highlights are always transmitted both for both the RGB format and <A HREF="motion.html#as">as</A>
	<A HREF="nvim_terminal_emulator.html#terminal">terminal</A> 256-color codes, <A HREF="motion.html#as">as</A> the `rgb_attr` and `cterm_attr` parameters
	respectively. The |<A HREF="#ui-rgb">ui-rgb</A>| option has no effect effect anymore.
	Most external UIs will only need to store and use the `rgb_attr`
	attributes.

	`id` 0 will always be used for the default highlight with colors defined
	by `default_colors_set` and no styles applied.

	Note: Nvim may reuse `id` values if its internal highlight table is full.
	In that <A HREF="change.html#case">case</A> Nvim will always issue redraws of screen cells that are
	affected by redefined ids, so UIs <A HREF="diff.html#do">do</A> not need to keep track of this
	themselves.

	`info` is an empty array by default, and will be used by the
	|<A HREF="#ui-hlstate">ui-hlstate</A>| extension explained below.

[&quot;hl_group_set&quot;, name, hl_id]
	The bulitin highlight group `name` was set to use the attributes `hl_id`
	defined by a previous `hl_attr_define` call. This event is not needed
	to render the grids which use attribute ids directly, but is useful
	for an <A HREF="#UI">UI</A> who want to render its own elements with consistent
	highlighting. For instance an <A HREF="#UI">UI</A> using |<A HREF="#ui-popupmenu">ui-popupmenu</A>| <A HREF="autocmd.html#events">events</A>, might
	use the |<A HREF="syntax.html#hl-Pmenu">hl-Pmenu</A>| family of builtin highlights.


							    *<A NAME="ui-event-grid_line"></A><B>ui-event-grid_line</B>*
[&quot;grid_line&quot;, grid, row, col_start, cells]
	Redraw a continuous part of a `row` on a `grid`, starting at the column
	`col_start`. `cells` is an array of arrays each with 1 to 3 items:
	`[text(, hl_id, repeat)]` . `text` is the <A HREF="mbyte.html#UTF-8">UTF-8</A> text that should be put in
	a cell, with the highlight `hl_id` defined by a previous `hl_attr_define`
	call.  If `hl_id` is not present the most recently seen `hl_id` in
	the same call should be used (it is always sent for the first
	cell in the event). If `repeat` is present, the cell should be
	repeated `repeat` times (including the first time), otherwise just
	once.

	The right cell of a double-width char will be represented <A HREF="motion.html#as">as</A> the empty
	<A HREF="eval.html#string">string</A>. Double-width chars never use `repeat`.

	If the array of cell changes doesn't reach to the end of the line, the
	rest should remain unchanged. A <A HREF="pattern.html#whitespace">whitespace</A> char, repeated
	enough to cover the remaining line, will be sent when the rest of the
	line should be cleared.

[&quot;grid_clear&quot;, grid]
	Clear a `grid`.

[&quot;grid_destroy&quot;, grid]
	`grid` will not be used anymore and the <A HREF="#UI">UI</A> can free any data associated
	with <A HREF="motion.html#it">it</A>.

[&quot;grid_cursor_goto&quot;, grid, row, column]
	Makes `grid` the current grid and `row, column` the cursor position on this
	grid.  This event will be sent at most once in a `redraw` batch and
	indicates the visible cursor position.

[&quot;grid_scroll&quot;, grid, top, bot, left, right, rows, cols]
	Scroll a region of `grid`. This is semantically unrelated to editor
	|<A HREF="scroll.html#scrolling">scrolling</A>|, rather this is an optimized way to say &quot;copy these screen
	cells&quot;.

	The following diagrams show what happens per scroll direction.
	&quot;===&quot; represents the SR (scroll region) boundaries.
	&quot;<A HREF="starting.html#---">---</A>&quot; represents the moved rectangles.
	Note that dst and src share a common region.

	If `rows` is bigger than 0, move a rectangle in the SR up, this can
	happen while <A HREF="scroll.html#scrolling">scrolling</A> down.

<B>		+-------------------------+</B>
<B>		| (clipped above SR)      |            ^</B>
<B>		|=========================| dst_top    |</B>
<B>		| dst (still in SR)       |            |</B>
<B>		+-------------------------+ src_top    |</B>
<B>		| src (moved up) and dst  |            |</B>
<B>		|-------------------------| dst_bot    |</B>
<B>		| src (invalid)           |            |</B>
<B>		+=========================+ src_bot</B>
 
	If `rows` is <A HREF="various.html#less">less</A> than zero, move a rectangle in the SR down, this can
	happen while <A HREF="scroll.html#scrolling">scrolling</A> up.

<B>		+=========================+ src_top</B>
<B>		| src (invalid)           |            |</B>
<B>		|------------------------ | dst_top    |</B>
<B>		| src (moved down) and dst|            |</B>
<B>		+-------------------------+ src_bot    |</B>
<B>		| dst (still in SR)       |            |</B>
<B>		|=========================| dst_bot    |</B>
<B>		| (clipped below SR)      |            v</B>
<B>		+-------------------------+</B>
 
	`cols` is always zero in this version of Nvim, and reserved for future
	use. 

	Note when updating code from |<A HREF="#ui-grid-old">ui-grid-old</A>| <A HREF="autocmd.html#events">events</A>: ranges are
	end-exclusive, which is consistent with <A HREF="api.html#API">API</A> conventions, but different
	from `set_scroll_region` which was end-inclusive.

	The scrolled-in area will be filled using |<A HREF="#ui-event-grid_line">ui-event-grid_line</A>| directly
	after the scroll event. The <A HREF="#UI">UI</A> thus doesn't need to clear this area <A HREF="motion.html#as">as</A>
	part of handling the scroll event.

==============================================================================

Grid Events (cell-based)					   *<A NAME="ui-grid-old"></A><B>ui-grid-old</B>*

This is the legacy representation of the screen grid, emitted if |<A HREF="#ui-linegrid">ui-linegrid</A>|
is not active. New UIs should implement |<A HREF="#ui-linegrid">ui-linegrid</A>| instead.

[&quot;resize&quot;, width, height]
	The grid is resized to `width` and `height` cells.

[&quot;clear&quot;]
	Clear the grid.

[&quot;eol_clear&quot;]
	Clear from the cursor position to the end of the current line.

[&quot;cursor_goto&quot;, row, col]
	Move the cursor to position (row, col). Currently, the same cursor is
	used to define the position for text insertion and the visible cursor.
	However, only the last cursor position, after processing the entire
	array in the &quot;redraw&quot; event, is intended to be a visible cursor
	position.

[&quot;update_fg&quot;, color]
[&quot;update_bg&quot;, color]
[&quot;update_sp&quot;, color]
	Set the default foreground, background and special colors
	respectively.


							*<A NAME="ui-event-highlight_set"></A><B>ui-event-highlight_set</B>*
[&quot;highlight_set&quot;, attrs]
	Set the attributes that the next text put on the grid will have.
	`attrs` is a <A HREF="eval.html#dict">dict</A> with the keys below. Any absent key is reset
	to its default value. Color defaults are set by the `update_fg` etc
	updates. All <A HREF="options.html#boolean">boolean</A> keys default to false.

	`foreground`:	foreground color.
	`background`:	background color.
	`special`:	color to use for <A HREF="syntax.html#underline">underline</A> and <A HREF="syntax.html#undercurl">undercurl</A>, when present.
	`reverse`:	reverse video. Foreground and background colors are
			switched.
	`italic`:	<A HREF="syntax.html#italic">italic</A> text.
	`bold`:		<A HREF="syntax.html#bold">bold</A> text.
	`strikethrough`:  struckthrough text.
	`underline`:	underlined text. The line has `special` color.
	`undercurl`:	undercurled text. The curl has `special` color.

[&quot;put&quot;, text]
	The (utf-8 encoded) <A HREF="eval.html#string">string</A> `text` is put at the cursor position
	(and the cursor is advanced), with the highlights <A HREF="motion.html#as">as</A> set by the
	last `highlight_set` update.

[&quot;set_scroll_region&quot;, top, bot, left, right]
	Define the scroll region used by `scroll` below.

	Note: ranges are end-inclusive, which is inconsistent with <A HREF="api.html#API">API</A>
	conventions.

[&quot;scroll&quot;, count]
	Scroll the text in the scroll region. The diagrams below illustrate
	what will happen, depending on the scroll direction. &quot;<A HREF="change.html#=">=</A>&quot; is used to
	represent the SR(scroll region) boundaries and &quot;<A HREF="motion.html#-">-</A>&quot; the moved rectangles.
	Note that dst and src share a common region.

	If <A HREF="intro.html#count">count</A> is bigger than 0, move a rectangle in the SR up, this can
	happen while <A HREF="scroll.html#scrolling">scrolling</A> down.

<B>		+-------------------------+</B>
<B>		| (clipped above SR)      |            ^</B>
<B>		|=========================| dst_top    |</B>
<B>		| dst (still in SR)       |            |</B>
<B>		+-------------------------+ src_top    |</B>
<B>		| src (moved up) and dst  |            |</B>
<B>		|-------------------------| dst_bot    |</B>
<B>		| src (cleared)           |            |</B>
<B>		+=========================+ src_bot</B>
 
	If <A HREF="intro.html#count">count</A> is <A HREF="various.html#less">less</A> than zero, move a rectangle in the SR down, this can
	happen while <A HREF="scroll.html#scrolling">scrolling</A> up.

<B>		+=========================+ src_top</B>
<B>		| src (cleared)           |            |</B>
<B>		|------------------------ | dst_top    |</B>
<B>		| src (moved down) and dst|            |</B>
<B>		+-------------------------+ src_bot    |</B>
<B>		| dst (still in SR)       |            |</B>
<B>		|=========================| dst_bot    |</B>
<B>		| (clipped below SR)      |            v</B>
<B>		+-------------------------+</B>
 
==============================================================================

Detailed highlight state Extension 				  *<A NAME="ui-hlstate"></A><B>ui-hlstate</B>*

Activated by the `ext_hlstate` |<A HREF="#ui-option">ui-option</A>|.
Activates |<A HREF="#ui-linegrid">ui-linegrid</A>| implicitly.

By default Nvim will only describe grid cells using the final calculated
highlight attributes, <A HREF="motion.html#as">as</A> described by the <A HREF="eval.html#dict">dict</A> keys in |<A HREF="#ui-event-highlight_set">ui-event-highlight_set</A>|.
The `ext_hlstate` extension allows to the <A HREF="#UI">UI</A> to also receive a semantic
description of the highlights active in a cell. In this mode highlights will be
predefined in a table, see |<A HREF="#ui-event-hl_attr_define">ui-event-hl_attr_define</A>| and |<A HREF="#ui-event-grid_line">ui-event-grid_line</A>|.
The `info` parameter in `hl_attr_define` will contain a semantic description
of the highlights. As highlight groups can be combined, this will be an array
of items, with the item with highest priority last. Each item is a dictionary
with the following possible keys:

    `kind`:	always present. One of the following values:
	&quot;<A HREF="#ui">ui</A>&quot;:       Builtin <A HREF="#UI">UI</A> highlight. |<A HREF="syntax.html#highlight-groups">highlight-groups</A>|
	&quot;<A HREF="syntax.html#syntax">syntax</A>&quot;:   Highlight applied to a buffer by a <A HREF="syntax.html#syntax">syntax</A> declaration or
	            other runtime/plugin functionality such <A HREF="motion.html#as">as</A>
		    |<A HREF="api.html#nvim_buf_add_highlight()">nvim_buf_add_highlight()</A>|
	&quot;terminal&quot;: highlight from a process running in a |<A HREF="nvim_terminal_emulator.html#terminal-emulator">terminal-emulator</A>|.
		    Contains no further semantic information.
    `ui_name`:	Highlight name from |<A HREF="syntax.html#highlight-groups">highlight-groups</A>|. Only for &quot;<A HREF="#ui">ui</A>&quot; kind.
    `hi_name`:	Name of the final |<A HREF="syntax.html#:highlight">:highlight</A>| group where the used
		attributes are defined.
    `id`:	Unique numeric id representing this item.

Note: &quot;<A HREF="#ui">ui</A>&quot; items will have both `ui_name` and `hi_name` present. These can
differ, because the builtin group was linked to another group |<A HREF="syntax.html#:hi-link">:hi-link</A>| , or
because <A HREF="options.html#'winhighlight'">'winhighlight'</A> was used. <A HREF="#UI">UI</A> items will be transmitted, even if the
highlight group is cleared, so `ui_name` can always be used to reliably identify
screen elements, even if no attributes have been applied.

==============================================================================

Multigrid Events 	  					 *<A NAME="ui-multigrid"></A><B>ui-multigrid</B>*

Activated by the `ext_multigrid` |<A HREF="#ui-option">ui-option</A>|.
Activates |<A HREF="#ui-linegrid">ui-linegrid</A>| implicitly.

See |<A HREF="#ui-linegrid">ui-linegrid</A>| for grid <A HREF="autocmd.html#events">events</A>.
See |<A HREF="api.html#nvim_ui_try_resize_grid()">nvim_ui_try_resize_grid()</A>| to request <A HREF="change.html#changing">changing</A> the grid size.
See |<A HREF="api.html#nvim_input_mouse()">nvim_input_mouse()</A>| for sending mouse <A HREF="autocmd.html#events">events</A> to Nvim.

The multigrid extension gives UIs more <A HREF="intro.html#control">control</A> over how <A HREF="windows.html#windows">windows</A> are displayed:
- UIs receive updates on a separate grid for each <A HREF="windows.html#window">window</A>.
- UIs can set the grid size independently of how much space the <A HREF="windows.html#window">window</A>
  occupies on the global layout. So the <A HREF="#UI">UI</A> could use a different font size
  per-window. Or reserve space around the border of the <A HREF="windows.html#window">window</A> for its own
  elements, such <A HREF="motion.html#as">as</A> scrollbars from the <A HREF="#UI">UI</A> toolkit.
- A dedicated grid is used for <A HREF="message.html#messages">messages</A>, which may scroll over the <A HREF="windows.html#window">window</A>
  area. (Alternatively |<A HREF="intro.html#ext_messages">ext_messages</A>| can be used).

By default, the grid size is handled by Nvim and set to the outer grid size
(i.e. the size of the <A HREF="windows.html#window">window</A> frame in Nvim) whenever the split is created.
Once a <A HREF="#UI">UI</A> sets a grid size, Nvim does not handle the size for that grid and
the <A HREF="#UI">UI</A> must change the grid size whenever the outer size is changed. To
delegate grid-size handling back to Nvim, request the size (0, 0).

A <A HREF="windows.html#window">window</A> can be hidden and redisplayed without its grid being deallocated.
This can happen multiple times for the same <A HREF="windows.html#window">window</A>, for instance when switching
tabs.

[&quot;win_pos&quot;, grid, win, start_row, start_col, width, height]
	Set the position and size of the grid in Nvim (i.e. the outer grid
	size). If the <A HREF="windows.html#window">window</A> was previously hidden, <A HREF="motion.html#it">it</A> should now be shown
	again.

[&quot;win_float_pos&quot;, grid, win, anchor, anchor_grid, anchor_row, anchor_col, focusable]
	Display or reconfigure floating <A HREF="windows.html#window">window</A> `win`. The <A HREF="windows.html#window">window</A> should be
	displayed above another grid `anchor_grid` at the specified position
	`anchor_row` and `anchor_col`. For the meaning of `anchor` and more
	details of positioning, see |<A HREF="api.html#nvim_open_win()">nvim_open_win()</A>|.

[&quot;win_external_pos&quot;, grid, win]
	Display or reconfigure external <A HREF="windows.html#window">window</A> `win`. The <A HREF="windows.html#window">window</A> should be
	displayed <A HREF="motion.html#as">as</A> a separate top-level <A HREF="windows.html#window">window</A> in the desktop environment,
	or something similar.

[&quot;win_hide&quot;, grid]
	Stop displaying the <A HREF="windows.html#window">window</A>. The <A HREF="windows.html#window">window</A> can be shown again later.

[&quot;win_close&quot;, grid]
	Close the <A HREF="windows.html#window">window</A>.

[&quot;msg_set_pos&quot;, grid, row, scrolled, sep_char]
	Display <A HREF="message.html#messages">messages</A> on `grid`.  The grid will be displayed at `row` on the
	default grid (grid=1), covering the full column width. `scrolled`
	indicates whether the message area has been scrolled to cover other
	grids. It can be useful to draw a separator then ('display' msgsep
	flag). The Builtin <A HREF="term.html#TUI">TUI</A> draws a full line filled with `sep_char` and
	|<A HREF="syntax.html#hl-MsgSeparator">hl-MsgSeparator</A>| highlight.

	When |<A HREF="intro.html#ext_messages">ext_messages</A>| is active, no message grid is used, and this event
	will not be sent.

[&quot;win_viewport&quot;, grid, win, topline, botline, curline, curcol]
	Indicates the range of buffer text displayed in the <A HREF="windows.html#window">window</A>, <A HREF="motion.html#as">as</A> well
	<A HREF="motion.html#as">as</A> the cursor position in the buffer. All positions are zero-based.
	`botline` is set to one more than the line <A HREF="intro.html#count">count</A> of the buffer, if
	there are filler lines past the end.

==============================================================================

Popupmenu Events						 *<A NAME="ui-popupmenu"></A><B>ui-popupmenu</B>*

Activated by the `ext_popupmenu` |<A HREF="#ui-option">ui-option</A>|.

This <A HREF="#UI">UI</A> extension delegates presentation of the |<A HREF="insert.html#popupmenu-completion">popupmenu-completion</A>| and
command-line <A HREF="options.html#'wildmenu'">'wildmenu'</A>.

[&quot;popupmenu_show&quot;, items, selected, row, col, grid]
	Show |<A HREF="insert.html#popupmenu-completion">popupmenu-completion</A>|. `items` is an array of completion items
	to show; each item is an array of the form [word, kind, menu, info] <A HREF="motion.html#as">as</A>
	defined at |<A HREF="insert.html#complete-items">complete-items</A>|, except that `word` is replaced by `abbr`
	if present.  `selected` is the initially-selected item, a zero-based
	index into the array of items (-1 if no item is selected). `row` and
	`col` give the anchor position, where the first character of the
	completed <A HREF="motion.html#word">word</A> will be. When |<A HREF="#ui-multigrid">ui-multigrid</A>| is used, `grid` is the
	grid for the anchor position. When `ext_cmdline` is active, `grid` is
	set to -1 to indicate the popupmenu should be anchored to the external
	<A HREF="cmdline.html#cmdline">cmdline</A>. Then `col` will be a byte position in the <A HREF="cmdline.html#cmdline">cmdline</A> text.

[&quot;popupmenu_select&quot;, selected]
	<A HREF="visual.html#Select">Select</A> an item in the current popupmenu. `selected` is a zero-based
	index into the array of items from the last popupmenu_show event, or
	-1 if no item is selected.

[&quot;popupmenu_hide&quot;]
	Hide the popupmenu.

==============================================================================

Tabline Events							   *<A NAME="ui-tabline"></A><B>ui-tabline</B>*

Activated by the `ext_tabline` |<A HREF="#ui-option">ui-option</A>|.

[&quot;tabline_update&quot;, curtab, tabs]
	Tabline was updated. UIs should present this data in a custom tabline
	widget.
	curtab:	  Current Tabpage
	tabs:	  <A HREF="eval.html#List">List</A> of Dicts <A HREF="motion.html#[{">[{</A> &quot;<A HREF="intro.html#tab">tab</A>&quot;: Tabpage, &quot;name&quot;: <A HREF="eval.html#String">String</A> }, ...]

==============================================================================

<A HREF="cmdline.html#Cmdline">Cmdline</A> Events							   *<A NAME="ui-cmdline"></A><B>ui-cmdline</B>*

Activated by the `ext_cmdline` |<A HREF="#ui-option">ui-option</A>|.

This <A HREF="#UI">UI</A> extension delegates presentation of the |<A HREF="cmdline.html#cmdline">cmdline</A>| (except <A HREF="options.html#'wildmenu'">'wildmenu'</A>).
For command-line <A HREF="options.html#'wildmenu'">'wildmenu'</A> <A HREF="#UI">UI</A> <A HREF="autocmd.html#events">events</A>, activate |<A HREF="#ui-popupmenu">ui-popupmenu</A>|.

[&quot;cmdline_show&quot;, content, pos, firstc, prompt, indent, level]
        content: <A HREF="eval.html#List">List</A> of [attrs, string]
	         [[{}, &quot;t&quot;], [attrs, &quot;est&quot;], ...]

	Triggered when the <A HREF="cmdline.html#cmdline">cmdline</A> is displayed or changed.
	The `content` is the full content that should be displayed in the
	<A HREF="cmdline.html#cmdline">cmdline</A>, and the `pos` is the position of the cursor that in the
	<A HREF="cmdline.html#cmdline">cmdline</A>. The content is divided into chunks with different highlight
	attributes represented <A HREF="motion.html#as">as</A> a <A HREF="eval.html#dict">dict</A> (see |<A HREF="#ui-event-highlight_set">ui-event-highlight_set</A>|).

	`firstc` and `prompt` are text, that if non-empty should be
	displayed in front of the command line. `firstc` always indicates
	built-in command lines such <A HREF="motion.html#as">as</A> `:` (ex command) and `/` `?` (search),
	while `prompt` is an |<A HREF="eval.html#input()">input()</A>| prompt. `indent` tells how many spaces
	the content should be indented.

	The Nvim command line can be invoked recursively, for instance by
	typing `&lt;c-r&gt;=` at the command line prompt. The `level` field is used
	to distinguish different command lines active at the same time. The
	first invoked command line has level 1, the next recursively-invoked
	prompt has level 2. A command line invoked from the |<A HREF="cmdline.html#cmdline-window">cmdline-window</A>|
	has a higher level than than the edited command line.

[&quot;cmdline_pos&quot;, pos, level]
	Change the cursor position in the <A HREF="cmdline.html#cmdline">cmdline</A>.

[&quot;cmdline_special_char&quot;, <A HREF="change.html#c">c</A>, <A HREF="intro.html#shift">shift</A>, level]
	Display a special char in the <A HREF="cmdline.html#cmdline">cmdline</A> at the cursor position. This is
	typically used to indicate a pending state, e.g. after |<A HREF="cmdline.html#c_CTRL-V">c_CTRL-V</A>|. If
	`shift` is true the text after the cursor should be shifted, otherwise
	<A HREF="motion.html#it">it</A> should overwrite the char at the cursor.

	Should be hidden at next cmdline_show.

[&quot;cmdline_hide&quot;]
	Hide the <A HREF="cmdline.html#cmdline">cmdline</A>.

[&quot;cmdline_block_show&quot;, lines]
	Show a block of <A HREF="repeat.html#context">context</A> to the current command line. For example if
	the user defines a |<A HREF="eval.html#:function">:function</A>| interactively:
<B>	    :function Foo()</B>
<B>	    :  echo "foo"</B>
<B>	    :</B>
 
	`lines` is a <A HREF="eval.html#list">list</A> of lines of highlighted chunks, in the same form <A HREF="motion.html#as">as</A>
	the &quot;cmdline_show&quot; `contents` parameter.

[&quot;cmdline_block_append&quot;, line]
	Append a line at the end of the currently shown block.

[&quot;cmdline_block_hide&quot;]
	Hide the block.

==============================================================================

Message/Dialog Events					   *<A NAME="ui-messages"></A><B>ui-messages</B>*

Activated by the `ext_messages` |<A HREF="#ui-option">ui-option</A>|.
Activates |<A HREF="#ui-linegrid">ui-linegrid</A>| and |<A HREF="#ui-cmdline">ui-cmdline</A>| implicitly.

This <A HREF="#UI">UI</A> extension delegates presentation of <A HREF="message.html#messages">messages</A> and dialogs. Messages
that would otherwise render in the message/cmdline screen space, are emitted
<A HREF="motion.html#as">as</A> <A HREF="#UI">UI</A> <A HREF="autocmd.html#events">events</A>.

Nvim will not allocate screen space for the <A HREF="cmdline.html#cmdline">cmdline</A> or <A HREF="message.html#messages">messages</A>, and
<A HREF="options.html#'cmdheight'">'cmdheight'</A> will be forced zero. <A HREF="cmdline.html#Cmdline">Cmdline</A> state is emitted <A HREF="motion.html#as">as</A> |<A HREF="#ui-cmdline">ui-cmdline</A>|
<A HREF="autocmd.html#events">events</A>, which the <A HREF="#UI">UI</A> must handle.

[&quot;msg_show&quot;, kind, content, replace_last]
	Display a message to the user.

	kind
	    Name indicating the message kind:
		&quot;&quot; (empty)	Unknown (consider a feature-request: |<A HREF="intro.html#bugs">bugs</A>|)
		&quot;confirm&quot;	|<A HREF="eval.html#confirm()">confirm()</A>| or |<A HREF="editing.html#:confirm">:confirm</A>| dialog
		&quot;confirm_sub&quot;	|<A HREF="change.html#:substitute">:substitute</A>| confirm dialog |<A HREF="change.html#:s_c">:s_c</A>|
		&quot;emsg&quot;		Error (|<A HREF="message.html#errors">errors</A>|, internal error, |<A HREF="eval.html#:throw">:throw</A>|, …)
		&quot;echo&quot;		|<A HREF="eval.html#:echo">:echo</A>| message
		&quot;echomsg&quot;	|<A HREF="eval.html#:echomsg">:echomsg</A>| message
		&quot;echoerr&quot;	|<A HREF="eval.html#:echoerr">:echoerr</A>| message
		&quot;lua_error&quot;	Error in |<A HREF="lua.html#:lua">:lua</A>| code
		&quot;rpc_error&quot;	Error response from |<A HREF="eval.html#rpcrequest()">rpcrequest()</A>|
		&quot;return_prompt&quot;	|<A HREF="message.html#press-enter">press-enter</A>| prompt after a multiple <A HREF="message.html#messages">messages</A>
		&quot;<A HREF="quickfix.html#quickfix">quickfix</A>&quot;	<A HREF="quickfix.html#Quickfix">Quickfix</A> <A HREF="motion.html#navigation">navigation</A> message
		&quot;search_count&quot;	Search <A HREF="intro.html#count">count</A> message (&quot;S&quot; flag of <A HREF="options.html#'shortmess'">'shortmess'</A>)
		&quot;wmsg&quot;		Warning (&quot;search hit BOTTOM&quot;, |<A HREF="message.html#W10">W10</A>|, …)
	    New kinds may be added in the future; clients should treat unknown
	    kinds <A HREF="motion.html#as">as</A> the empty kind.

	content
	    Array of `[attr_id, text_chunk]` tuples, building up the message
	    text of chunks of different highlights. No extra spacing should be
	    added between chunks, the `text_chunk` by itself contains any
	    necessary <A HREF="pattern.html#whitespace">whitespace</A>. Messages can contain line breaks &quot;\n&quot;.

	replace_last
	    Decides how multiple <A HREF="message.html#messages">messages</A> should be displayed:
	    false: Display the message together with all previous <A HREF="message.html#messages">messages</A>
		   that are still visible.
	    true:  <A HREF="insert.html#Replace">Replace</A> the message in the most-recent `msg_show` call,
		   but any other visible message should still remain.

[&quot;msg_clear&quot;]
	Clear all <A HREF="message.html#messages">messages</A> currently displayed by &quot;msg_show&quot;. (Messages sent
	by other &quot;msg_&quot; <A HREF="autocmd.html#events">events</A> below will not be affected).

[&quot;msg_showmode&quot;, content]
	Shows <A HREF="options.html#'showmode'">'showmode'</A> and |<A HREF="repeat.html#recording">recording</A>| <A HREF="message.html#messages">messages</A>. `content` has the same
	format <A HREF="motion.html#as">as</A> in &quot;msg_show&quot;. This event is sent with empty `content` to
	hide the last message.

[&quot;msg_showcmd&quot;, content]
	Shows <A HREF="options.html#'showcmd'">'showcmd'</A> <A HREF="message.html#messages">messages</A>. `content` has the same format <A HREF="motion.html#as">as</A> in &quot;msg_show&quot;.
	This event is sent with empty `content` to hide the last message.

[&quot;msg_ruler&quot;, content]
	Used to display <A HREF="options.html#'ruler'">'ruler'</A> when there is no space for the ruler in a
	statusline. `content` has the same format <A HREF="motion.html#as">as</A> in &quot;msg_show&quot;. This event is
	sent with empty `content` to hide the last message.

[&quot;msg_history_show&quot;, entries]
	Sent when |<A HREF="message.html#:messages">:messages</A>| command is invoked. History is sent <A HREF="motion.html#as">as</A> a <A HREF="eval.html#list">list</A> of
	entries, where each entry is a `[kind, content]` tuple.

==============================================================================
<A HREF="#top">top</A> - <A HREF="index.html">main help file</A>
</PRE>
    </div>

    <footer>
      <div class="container">
        Generated Sun May  2 05:42:02 UTC 2021 from <a href="https://github.com/neovim/neovim/commit/b227cedf82341813514da55baa48511eca4014b0"><code>b227ced</code></a>.
      </div>
    </footer>
  </body>
</html>
