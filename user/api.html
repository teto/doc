<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <meta content="width=device-width, initial-scale=1" name="viewport">
    <title>Nvim documentation: api</title>
    <link href="https://fonts.googleapis.com/css?family=Lato:400,700,900" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.0/normalize.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
    <link href="/css/main.css" rel="stylesheet">
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    
  </head>
  <body>
    <header class="navbar">
      <div class="container">
        <nav class="navbar">
          <div class="container-fluid">
            <div class="navbar-header">

              <a href="/" class="navbar-brand">
                <img src="/images/logo@2x.png" id="navbar-logo" alt="Neovim">
              </a>
            </div>
          </div>
        </nav>
      </div>
    </header>

    <div class="container">
      <h1>Nvim documentation: api</h1>
<A NAME="top"></A>
<A HREF="index.html">main help file</A>

<HR>
<PRE>

*<A NAME="api.txt"></A><B>api.txt</B>*		Nvim


		 NVIM REFERENCE MANUAL    by Thiago de Arruda



Nvim <A HREF="#API">API</A>							   *<A NAME="API"></A><B>API</B>* *<A NAME="api"></A><B>api</B>*

Nvim exposes a powerful <A HREF="#API">API</A> that can be used by plugins and external processes
via |<A HREF="#RPC">RPC</A>|, |<A HREF="lua.html#Lua">Lua</A>| and VimL (|<A HREF="eval.html#eval-api">eval-api</A>|).

Applications can also embed libnvim to work with the C <A HREF="#API">API</A> directly.

                                      Type |<A HREF="various.html#gO">gO</A>| to see the table of contents.

==============================================================================

<A HREF="#API">API</A> Usage						*<A NAME="api-rpc"></A><B>api-rpc</B>* *<A NAME="RPC"></A><B>RPC</B>* *<A NAME="rpc"></A><B>rpc</B>*


							*<A NAME="msgpack-rpc"></A><B>msgpack-rpc</B>*
<A HREF="#RPC">RPC</A> is the typical way to <A HREF="intro.html#control">control</A> Nvim programmatically.  Nvim implements the
MessagePack-RPC protocol:
  https://github.com/msgpack-rpc/msgpack-rpc/blob/master/spec.md
  https://github.com/msgpack/msgpack/blob/0b8f5ac/spec.md

Many clients use the <A HREF="#API">API</A>: user interfaces (GUIs), remote plugins, scripts like
&quot;nvr&quot; (https://github.com/mhinz/neovim-remote).  Even Nvim itself can <A HREF="intro.html#control">control</A>
other Nvim instances.  <A HREF="#API">API</A> clients can:

  - Call any <A HREF="#API">API</A> function
  - Listen for <A HREF="autocmd.html#events">events</A>
  - Receive remote calls from Nvim

The <A HREF="#RPC">RPC</A> <A HREF="#API">API</A> is like a more powerful version of Vim's &quot;<A HREF="remote.html#clientserver">clientserver</A>&quot; feature.


CONNECTING						*<A NAME="rpc-connecting"></A><B>rpc-connecting</B>*

See |<A HREF="channel.html#channel-intro">channel-intro</A>| for various ways to open a channel. Channel-opening
<A HREF="eval.html#functions">functions</A> take an `rpc` key in the <A HREF="options.html#options">options</A> dictionary. <A HREF="#RPC">RPC</A> channels can also
be opened by other processes connecting to TCP/IP sockets or named pipes
listened to by Nvim.

Nvim creates a default <A HREF="#RPC">RPC</A> socket at |<A HREF="starting.html#startup">startup</A>|, given by |<A HREF="eval.html#v:servername">v:servername</A>|. To
start with a TCP/IP socket instead, use |<A HREF="starting.html#--listen">--listen</A>| with a TCP-style address:
<B>    nvim --listen 127.0.0.1:6666</B>
More endpoints can be started with |<A HREF="eval.html#serverstart()">serverstart()</A>|.

Note that localhost TCP sockets are generally <A HREF="various.html#less">less</A> secure than named pipes,
and can lead to vunerabilities like remote code execution.

Connecting to the socket is the easiest way a programmer can test the <A HREF="#API">API</A>,
which can be done through any <A HREF="#msgpack-rpc">msgpack-rpc</A> client library or full-featured
|<A HREF="develop.html#api-client">api-client</A>|. Here's a <A HREF="if_ruby.html#Ruby">Ruby</A> <A HREF="usr_41.html#script">script</A> that prints &quot;hello world!&quot; in the current
Nvim instance:

<B>    #!/usr/bin/env ruby</B>
<B>    # Requires msgpack-rpc: gem install msgpack-rpc</B>
<B>    #</B>
<B>    # To run this script, execute it from a running Nvim instance (notice the</B>
<B>    # trailing '&amp;' which is required since Nvim won't process events while</B>
<B>    # running a blocking command):</B>
<B>    #</B>
<B>    #	:!./hello.rb &amp;</B>
<B>    #</B>
<B>    # Or from another shell by setting NVIM_LISTEN_ADDRESS:</B>
<B>    # $ NVIM_LISTEN_ADDRESS=[address] ./hello.rb</B>

<B>    require 'msgpack/rpc'</B>
<B>    require 'msgpack/rpc/transport/unix'</B>

<B>    nvim = MessagePack::RPC::Client.new(MessagePack::RPC::UNIXTransport.new, ENV['NVIM_LISTEN_ADDRESS'])</B>
<B>    result = nvim.call(:nvim_command, 'echo "hello world!"')</B>
 
A better way is to use the <A HREF="if_pyth.html#Python">Python</A> REPL with the &quot;<A HREF="develop.html#pynvim">pynvim</A>&quot; package, where <A HREF="#API">API</A>
<A HREF="eval.html#functions">functions</A> can be called interactively:

<B>    &gt;&gt;&gt; from pynvim import attach</B>
<B>    &gt;&gt;&gt; nvim = attach('socket', path='[address]')</B>
<B>    &gt;&gt;&gt; nvim.command('echo "hello world!"')</B>
 
You can also embed Nvim via |<A HREF="eval.html#jobstart()">jobstart()</A>|, and communicate using |<A HREF="eval.html#rpcrequest()">rpcrequest()</A>|
and YXXYrpcnotify()|:

<B>    let nvim = jobstart(['nvim', '--embed'], {'rpc': v:true})</B>
<B>    echo rpcrequest(nvim, 'nvim_eval', '"Hello " . "world!"')</B>
<B>    call jobstop(nvim)</B>

==============================================================================

<A HREF="#API">API</A> Definitions						*<A NAME="api-definitions"></A><B>api-definitions</B>*


							*<A NAME="api-types"></A><B>api-types</B>*
The Nvim C <A HREF="#API">API</A> defines custom types for all function parameters. Some are just
typedefs around C99 standard types, others are Nvim-defined data structures.

<B><FONT color="#54A23D">Basic types </FONT></B>

  <A HREF="#API">API</A> Type				C type
  ------------------------------------------------------------------------
  Nil
  <A HREF="eval.html#Boolean">Boolean</A>				bool
  Integer (signed 64-bit integer)	int64_t
  <A HREF="eval.html#Float">Float</A> (IEEE 754 double precision)	double
  <A HREF="eval.html#String">String</A>				{char* data, size_t size} struct
  Array
  <A HREF="eval.html#Dictionary">Dictionary</A> (msgpack: map)
  Object

  Note: empty Array is accepted <A HREF="motion.html#as">as</A> a valid argument for <A HREF="eval.html#Dictionary">Dictionary</A> parameter.

<B><FONT color="#54A23D">Special types (msgpack EXT) </FONT></B>

  These are integer typedefs discriminated <A HREF="motion.html#as">as</A> separate Object subtypes. They
  can be treated <A HREF="motion.html#as">as</A> opaque integers, but are mutually incompatible: Buffer may
  be passed <A HREF="motion.html#as">as</A> an integer but not <A HREF="motion.html#as">as</A> Window or Tabpage.

  The EXT object data is the (integer) object handle. The EXT type codes given
  in the |<A HREF="#api-metadata">api-metadata</A>| `types` key are stable: they will not change and are
  thus forward-compatible.

  EXT Type	C type					Data
  ------------------------------------------------------------------------
  Buffer	enum value kObjectTypeBuffer		|<A HREF="eval.html#bufnr()">bufnr()</A>|
  Window	enum value kObjectTypeWindow		|<A HREF="windows.html#window-ID">window-ID</A>|
  Tabpage	enum value kObjectTypeTabpage		internal handle



							*<A NAME="api-indexing"></A><B>api-indexing</B>*
Most of the <A HREF="#API">API</A> uses 0-based indices, and ranges are end-exclusive. For the
end of a range, -1 denotes the last line/column.

Exception: the following <A HREF="#API">API</A> <A HREF="eval.html#functions">functions</A> use &quot;mark-like&quot; indexing (1-based
lines, 0-based columns):

    |<A HREF="#nvim_buf_get_mark()">nvim_buf_get_mark()</A>|
    |<A HREF="#nvim_win_get_cursor()">nvim_win_get_cursor()</A>|
    |<A HREF="#nvim_win_set_cursor()">nvim_win_set_cursor()</A>|


							*<A NAME="api-fast"></A><B>api-fast</B>*
Most <A HREF="#API">API</A> <A HREF="eval.html#functions">functions</A> are &quot;deferred&quot;: they are queued on the main loop and
processed sequentially with normal input.  So if the editor is waiting for
user input in a &quot;modal&quot; fashion (e.g. the |<A HREF="message.html#hit-enter-prompt">hit-enter-prompt</A>|), the request
will block.  Non-deferred ({fast}) <A HREF="eval.html#functions">functions</A> such <A HREF="motion.html#as">as</A> |<A HREF="#nvim_get_mode()">nvim_get_mode()</A>| and
|<A HREF="#nvim_input()">nvim_input()</A>| are served immediately (i.e. without waiting in the input
queue).  <A HREF="lua.html#Lua">Lua</A> code can use |<A HREF="vim.html">vim.in_fast_event()</A>| to detect a {fast} <A HREF="repeat.html#context">context</A>.

==============================================================================

<A HREF="#API">API</A> metadata						*<A NAME="api-metadata"></A><B>api-metadata</B>*

The Nvim C <A HREF="#API">API</A> is automatically exposed to <A HREF="#RPC">RPC</A> by the build system, which
parses headers in src/nvim/api/* and generates dispatch-functions <A HREF="map.html#mapping">mapping</A> <A HREF="#RPC">RPC</A>
<A HREF="#API">API</A> method names to public C <A HREF="#API">API</A> <A HREF="eval.html#functions">functions</A>, converting/validating arguments
and return values.

Nvim exposes its <A HREF="#API">API</A> metadata <A HREF="motion.html#as">as</A> a <A HREF="eval.html#Dictionary">Dictionary</A> with these items:

version			Nvim version, <A HREF="#API">API</A> level/compatibility

version.api_level	<A HREF="#API">API</A> version integer *<A NAME="api-level"></A><B>api-level</B>*
version.api_compatible	<A HREF="#API">API</A> is backwards-compatible with this level
version.api_prerelease	Declares the <A HREF="#API">API</A> <A HREF="motion.html#as">as</A> unstable/unreleased
<B>			(version.api_prerelease &amp;&amp; fn.since == version.api_level)</B>
<A HREF="eval.html#functions">functions</A>		<A HREF="#API">API</A> function signatures, containing |<A HREF="#api-types">api-types</A>| info
                        describing the return value and parameters.
ui_events		|<A HREF="ui.html#UI">UI</A>| event signatures
ui_options		Supported |<A HREF="ui.html#ui-option">ui-option</A>|<A HREF="change.html#s">s</A>
{fn}.since		<A HREF="#API">API</A> level where function {fn} was introduced
{fn}.deprecated_since	<A HREF="#API">API</A> level where function {fn} was <A HREF="deprecated.html#deprecated">deprecated</A>
types			Custom handle types defined by Nvim
error_types		Possible error types returned by <A HREF="#API">API</A> <A HREF="eval.html#functions">functions</A>

About the `functions` map:

  - Container types may be decorated with type/size constraints, e.g.
    ArrayOf(Buffer) or ArrayOf(Integer, 2).
  - Functions considered to be methods that operate on instances of Nvim
    special types (msgpack EXT) have the &quot;method=true&quot; flag. The receiver type
    is that of the first argument. Method names are prefixed with `nvim_` plus
    a type name, e.g. `nvim_buf_get_lines` is the `get_lines` method of
    a Buffer instance. |<A HREF="develop.html#dev-api">dev-api</A>|
  - Global <A HREF="eval.html#functions">functions</A> have the &quot;method=false&quot; flag and are prefixed with just
    `nvim_`, e.g. `nvim_get_buffers`.


							*<A NAME="api-mapping"></A><B>api-mapping</B>*
External programs (clients) can use the metadata to discover the <A HREF="#API">API</A>, using
any of these approaches:

  1. Connect to a running Nvim instance and call |<A HREF="#nvim_get_api_info()">nvim_get_api_info()</A>| via
     msgpack-RPC. This is best for clients written in dynamic languages which
     can define <A HREF="eval.html#functions">functions</A> at runtime.

  2. Start Nvim with |<A HREF="starting.html#--api-info">--api-info</A>|. Useful for statically-compiled clients.
     Example (requires <A HREF="if_pyth.html#Python">Python</A> &quot;pyyaml&quot; and &quot;msgpack-python&quot; modules):
<B>     nvim --api-info | python -c 'import msgpack, sys, yaml; print yaml.dump(msgpack.unpackb(sys.stdin.read()))'</B>
 
  3. Use the |<A HREF="eval.html#api_info()">api_info()</A>| Vimscript function.
<B>     :lua print(vim.inspect(vim.fn.api_info()))</B>
      Example using |<A HREF="eval.html#filter()">filter()</A>| to exclude non-deprecated <A HREF="#API">API</A> <A HREF="eval.html#functions">functions</A>:
<B>     :new|put =map(filter(api_info().functions, '!has_key(v:val,''deprecated_since'')'), 'v:val.name')</B>

==============================================================================

<A HREF="#API">API</A> contract                                                     *<A NAME="api-contract"></A><B>api-contract</B>*

The Nvim <A HREF="#API">API</A> is composed of <A HREF="eval.html#functions">functions</A> and <A HREF="autocmd.html#events">events</A>.

- Clients call <A HREF="eval.html#functions">functions</A> like those described at |<A HREF="#api-global">api-global</A>|.
- Clients can subscribe to |<A HREF="ui.html#ui-events">ui-events</A>|, |<A HREF="#api-buffer-updates">api-buffer-updates</A>|, etc.
- <A HREF="#API">API</A> function names are prefixed with &quot;nvim_&quot;.
- <A HREF="#API">API</A> event names are prefixed with &quot;nvim_&quot; and suffixed with &quot;_event&quot;.

As Nvim evolves the <A HREF="#API">API</A> may change in compliance with this CONTRACT:

- New <A HREF="eval.html#functions">functions</A> and <A HREF="autocmd.html#events">events</A> may be added.
  - Any such extensions are OPTIONAL: old clients may ignore them.
- Function signatures will <A HREF="lua.html#NOT">NOT</A> CHANGE (after release).
  - Functions introduced in the <A HREF="develop.html#development">development</A> (unreleased) version MAY CHANGE.
    (Clients can dynamically check `api_prerelease`, etc. |<A HREF="#api-metadata">api-metadata</A>|)
- Event parameters will not be removed or reordered (after release).
- Events may be EXTENDED: new parameters may be added.
- New items may be ADDED to map/list parameters/results of <A HREF="eval.html#functions">functions</A> and
  <A HREF="autocmd.html#events">events</A>.
  - Any such new items are OPTIONAL: old clients may ignore them.
  - Existing items will not be removed (after release).
- Deprecated <A HREF="eval.html#functions">functions</A> will not be removed until Nvim version 2.0

==============================================================================

Global <A HREF="autocmd.html#events">events</A>						    *<A NAME="api-global-events"></A><B>api-global-events</B>*

When a client invokes an <A HREF="#API">API</A> request <A HREF="motion.html#as">as</A> an async notification, <A HREF="motion.html#it">it</A> is not
possible for Nvim to send an error response. Instead, in <A HREF="change.html#case">case</A> of error, the
following notification will be sent to the client:


                                                             *<A NAME="nvim_error_event"></A><B>nvim_error_event</B>*
nvim_error_event[{type}, {message}]

{type} is a numeric id <A HREF="motion.html#as">as</A> defined by `api_info().error_types`, and {message} is
a <A HREF="eval.html#string">string</A> with the error message.

==============================================================================

Buffer update <A HREF="autocmd.html#events">events</A>					*<A NAME="api-buffer-updates"></A><B>api-buffer-updates</B>*

<A HREF="#API">API</A> clients can &quot;attach&quot; to Nvim <A HREF="windows.html#buffers">buffers</A> to subscribe to buffer update <A HREF="autocmd.html#events">events</A>.
This is similar to |<A HREF="autocmd.html#TextChanged">TextChanged</A>| but more powerful and granular.

Call |<A HREF="#nvim_buf_attach()">nvim_buf_attach()</A>| to receive these <A HREF="autocmd.html#events">events</A> on the <A HREF="channel.html#channel">channel</A>:


                                                        *<A NAME="nvim_buf_lines_event"></A><B>nvim_buf_lines_event</B>*
nvim_buf_lines_event[{buf}, {changedtick}, {firstline}, {lastline}, {linedata}, {more}]

  When the buffer text between {firstline} and {lastline} (end-exclusive,
  zero-indexed) were changed to the new text in the {linedata} <A HREF="eval.html#list">list</A>. The
  granularity is a line, i.e. if a single character is changed in the editor,
  the entire line is sent.

  When {changedtick} is |<A HREF="eval.html#v:null">v:null</A>| this means the screen lines (display) changed
  but not the buffer contents. {linedata} contains the changed screen lines.
  This happens when <A HREF="options.html#'inccommand'">'inccommand'</A> shows a buffer preview.

<B><FONT color="#54A23D">  Properties:</FONT></B>
    {buf} <A HREF="#API">API</A> buffer handle (buffer number)

    {changedtick} value of |<A HREF="eval.html#b:changedtick">b:changedtick</A>| for the buffer. If you send an <A HREF="#API">API</A>
    command back to <A HREF="nvim.html#nvim">nvim</A> you can check the value of |<A HREF="eval.html#b:changedtick">b:changedtick</A>| <A HREF="motion.html#as">as</A> part of
    your request to ensure that no other changes have been made.

    {firstline} integer line number of the first line that was replaced.
    Zero-indexed: if line 1 was replaced then {firstline} will be 0, not 1.
    {firstline} is always <A HREF="various.html#less">less</A> than or equal to the number of lines that were
    in the buffer before the lines were replaced.

    {lastline} integer line number of the first line that was not replaced
    (i.e. the range {firstline}, {lastline} is end-exclusive).
    Zero-indexed: if line numbers 2 to 5 were replaced, this will be 5 instead
    of 6. {lastline} is always be <A HREF="various.html#less">less</A> than or equal to the number of lines
    that were in the buffer before the lines were replaced. {lastline} will be
    -1 if the event is part of the initial update after attaching.

    {linedata} <A HREF="eval.html#list">list</A> of strings containing the contents of the new buffer
    lines. Newline characters are omitted; empty lines are sent <A HREF="motion.html#as">as</A> empty
    strings.

    {more} <A HREF="options.html#boolean">boolean</A>, true for a &quot;multipart&quot; change notification: the current
    change was chunked into multiple |<A HREF="#nvim_buf_lines_event">nvim_buf_lines_event</A>| notifications
    (e.g. because <A HREF="motion.html#it">it</A> was too big).


nvim_buf_changedtick_event[{buf}, {changedtick}]  *<A NAME="nvim_buf_changedtick_event"></A><B>nvim_buf_changedtick_event</B>*

  When |<A HREF="eval.html#b:changedtick">b:changedtick</A>| was incremented but no text was changed. Relevant for
  undo/redo.

<B><FONT color="#54A23D">  Properties:</FONT></B>
    {buf} <A HREF="#API">API</A> buffer handle (buffer number)
    {changedtick} new value of |<A HREF="eval.html#b:changedtick">b:changedtick</A>| for the buffer


nvim_buf_detach_event[{buf}]                           *<A NAME="nvim_buf_detach_event"></A><B>nvim_buf_detach_event</B>*

  When buffer is detached (i.e. updates are disabled). Triggered explicitly by
  |<A HREF="#nvim_buf_detach()">nvim_buf_detach()</A>| or implicitly in these cases:
  - Buffer was |abandon|ed and <A HREF="options.html#'hidden'">'hidden'</A> is not set.
  - Buffer was reloaded, e.g. with |<A HREF="editing.html#:edit">:edit</A>| or an external change triggered
    |<A HREF="editing.html#:checktime">:checktime</A>| or <A HREF="options.html#'autoread'">'autoread'</A>.
  - Generally: whenever the buffer contents are unloaded from memory.

<B><FONT color="#54A23D">  Properties:</FONT></B>
    {buf} <A HREF="#API">API</A> buffer handle (buffer number)


<B><FONT color="#54A23D">EXAMPLE </FONT></B>

Calling |<A HREF="#nvim_buf_attach()">nvim_buf_attach()</A>| with send_buffer=true on an empty buffer, emits:
<B>  nvim_buf_lines_event[{buf}, {changedtick}, 0, -1, [""], v:false]</B>

<A HREF="autocmd.html#User">User</A> adds two lines to the buffer, emits:
<B>  nvim_buf_lines_event[{buf}, {changedtick}, 0, 0, ["line1", "line2"], v:false]</B>

<A HREF="autocmd.html#User">User</A> moves to a line containing the text &quot;Hello world&quot; and inserts &quot;<A HREF="change.html#!">!</A>&quot;, emits:
<B>  nvim_buf_lines_event[{buf}, {changedtick}, {linenr}, {linenr} + 1,</B>
<B>                       ["Hello world!"], v:false]</B>

<A HREF="autocmd.html#User">User</A> moves to line 3 and deletes 20 lines using &quot;20dd&quot;, emits:
<B>  nvim_buf_lines_event[{buf}, {changedtick}, 2, 22, [], v:false]</B>

<A HREF="autocmd.html#User">User</A> selects lines 3-5 using |<A HREF="visual.html#linewise-visual">linewise-visual</A>| mode and then types &quot;<A HREF="change.html#p">p</A>&quot; to
<A HREF="provider.html#paste">paste</A> a block of 6 lines, emits:
<B>  nvim_buf_lines_event[{buf}, {changedtick}, 2, 5,</B>
<B>    ['pasted line 1', 'pasted line 2', 'pasted line 3', 'pasted line 4',</B>
<B>     'pasted line 5', 'pasted line 6'],</B>
<B>    v:false</B>
<B>  ]</B>

<A HREF="autocmd.html#User">User</A> reloads the buffer with &quot;<A HREF="editing.html#:edit">:edit</A>&quot;, emits:
<B>  nvim_buf_detach_event[{buf}]</B>
 

<B><FONT color="#54A23D">LUA </FONT></B>

                                                        *<A NAME="api-buffer-updates-lua"></A><B>api-buffer-updates-lua</B>*
In-process <A HREF="lua.html#Lua">Lua</A> plugins can receive buffer updates in the form of <A HREF="lua.html#Lua">Lua</A>
callbacks. These callbacks are called frequently in various contexts;
|<A HREF="eval.html#textlock">textlock</A>| prevents <A HREF="change.html#changing">changing</A> buffer contents and <A HREF="windows.html#window">window</A> layout (use
|<A HREF="vim.html">vim.schedule</A>| to defer such operations to the main loop instead).

|<A HREF="#nvim_buf_attach()">nvim_buf_attach()</A>| will take keyword args for the callbacks. &quot;on_lines&quot; will
receive parameters (&quot;lines&quot;, {buf}, {changedtick}, {firstline}, {lastline},
{new_lastline}, {old_byte_size}[, {old_utf32_size}, {old_utf16_size}]).
Unlike remote <A HREF="channel.html#channel">channel</A> <A HREF="autocmd.html#events">events</A> the text contents are not passed. The new text can
be accessed inside the callback <A HREF="motion.html#as">as</A>

    `vim.api.nvim_buf_get_lines(buf, firstline, new_lastline, true)`

{old_byte_size} is the total size of the replaced region {firstline} to
{lastline} in bytes, including the final newline after {lastline}. if
`utf_sizes` is set to true in |<A HREF="#nvim_buf_attach()">nvim_buf_attach()</A>| keyword args, then the
UTF-32 and UTF-16 sizes of the deleted region is also passed <A HREF="motion.html#as">as</A> additional
arguments {old_utf32_size} and {old_utf16_size}.

&quot;on_changedtick&quot; is invoked when |<A HREF="eval.html#b:changedtick">b:changedtick</A>| was incremented but no text
was changed. The parameters recieved are (&quot;changedtick&quot;, {buf}, {changedtick}).


                                                        *<A NAME="api-lua-detach"></A><B>api-lua-detach</B>*
In-process <A HREF="lua.html#Lua">Lua</A> callbacks can detach by returning `true`. This will detach all
callbacks attached with the same |<A HREF="#nvim_buf_attach()">nvim_buf_attach()</A>| call.


==============================================================================

Buffer highlighting					       *<A NAME="api-highlights"></A><B>api-highlights</B>*

Nvim allows plugins to add position-based highlights to <A HREF="windows.html#buffers">buffers</A>. This is
similar to |<A HREF="eval.html#matchaddpos()">matchaddpos()</A>| but with some key differences. The added highlights
are associated with a buffer and adapts to line insertions and deletions,
similar to <A HREF="sign.html#signs">signs</A>. It is also possible to manage a set of highlights <A HREF="motion.html#as">as</A> a group
and delete or replace all at once.

The intended use <A HREF="change.html#case">case</A> are linter or semantic highlighter plugins that monitor
a buffer for changes, and in the background compute highlights to the buffer.
Another use <A HREF="change.html#case">case</A> are plugins that show output in an append-only buffer, and
want to add highlights to the outputs. Highlight data cannot be preserved
on <A HREF="editing.html#writing">writing</A> and loading a buffer to file, nor in undo/redo cycles.

Highlights are registered using the |<A HREF="#nvim_buf_add_highlight()">nvim_buf_add_highlight()</A>| function. If an
external highlighter <A HREF="usr_05.html#plugin">plugin</A> wants to add many highlights in a batch,
performance can be improved by calling |<A HREF="#nvim_buf_add_highlight()">nvim_buf_add_highlight()</A>| <A HREF="motion.html#as">as</A> an
asynchronous notification, after first (synchronously) requesting a source id.

Example using the <A HREF="if_pyth.html#Python">Python</A> <A HREF="#API">API</A> client (|<A HREF="develop.html#pynvim">pynvim</A>|):

<B>    src = vim.new_highlight_source()</B>
<B>    buf = vim.current.buffer</B>
<B>    for i in range(5):</B>
<B>        buf.add_highlight("String",i,0,-1,src_id=src)</B>
<B>    # some time later ...</B>
<B>    buf.clear_namespace(src)</B>
 
If the highlights don't need to be deleted or updated, just pass -1 <A HREF="motion.html#as">as</A>
src_id (this is the default in <A HREF="if_pyth.html#python">python</A>). Use |<A HREF="#nvim_buf_clear_namespace()">nvim_buf_clear_namespace()</A>| to
clear highlights from a specific source, in a specific line range or the
entire buffer by passing in the line range 0, -1 (the latter is the default in
<A HREF="if_pyth.html#python">python</A> <A HREF="motion.html#as">as</A> used above).

Example using the <A HREF="#API">API</A> from Vimscript:

<B>    call nvim_buf_set_lines(0, 0, 0, v:true, ["test text"])</B>
<B>    let src = nvim_buf_add_highlight(0, 0, "String", 1, 0, 4)</B>
<B>    call nvim_buf_add_highlight(0, src, "Identifier", 0, 5, -1)</B>
<B>    " some time later ...</B>
<B>    call nvim_buf_clear_namespace(0, src, 0, -1)</B>


==============================================================================

Floating <A HREF="windows.html#windows">windows</A>						 *<A NAME="api-floatwin"></A><B>api-floatwin</B>*

Floating <A HREF="windows.html#windows">windows</A> (&quot;floats&quot;) are displayed on top of normal <A HREF="windows.html#windows">windows</A>.  This is
useful to implement simple widgets, such <A HREF="motion.html#as">as</A> tooltips displayed next to the
cursor. Floats are fully functional <A HREF="windows.html#windows">windows</A> supporting user editing, common
|<A HREF="#api-window">api-window</A>| calls, and most window <A HREF="options.html#options">options</A> (except <A HREF="options.html#'statusline'">'statusline'</A>).

Two ways to create a floating <A HREF="windows.html#window">window</A>:
- |<A HREF="#nvim_open_win()">nvim_open_win()</A>| creates a new <A HREF="windows.html#window">window</A> (needs a buffer, see |<A HREF="#nvim_create_buf()">nvim_create_buf()</A>|)
- |<A HREF="#nvim_win_set_config()">nvim_win_set_config()</A>| reconfigures a normal <A HREF="windows.html#window">window</A> into a float

To close <A HREF="motion.html#it">it</A> use |<A HREF="#nvim_win_close()">nvim_win_close()</A>| or a command such <A HREF="motion.html#as">as</A> |<A HREF="windows.html#:close">:close</A>|.

Buffer text can be highlighted by typical mechanisms (syntax highlighting,
|<A HREF="#api-highlights">api-highlights</A>|). The |<A HREF="syntax.html#hl-NormalFloat">hl-NormalFloat</A>| group highlights normal text;
<A HREF="options.html#'winhighlight'">'winhighlight'</A> can be used <A HREF="motion.html#as">as</A> usual to override groups locally. Floats inherit
<A HREF="options.html#options">options</A> from the current <A HREF="windows.html#window">window</A>; specify `style=minimal` in |<A HREF="#nvim_open_win()">nvim_open_win()</A>|
to disable various visual features such <A HREF="motion.html#as">as</A> the <A HREF="options.html#'number'">'number'</A> column.

Currently, floating <A HREF="windows.html#windows">windows</A> don't support widgets like border or scrollbar.

Example: create a float with scratch buffer:

<B>    let buf = nvim_create_buf(v:false, v:true)</B>
<B>    call nvim_buf_set_lines(buf, 0, -1, v:true, ["test", "text"])</B>
<B>    let opts = {'relative': 'cursor', 'width': 10, 'height': 2, 'col': 0,</B>
<B>        \ 'row': 1, 'anchor': 'NW', 'style': 'minimal'}</B>
<B>    let win = nvim_open_win(buf, 0, opts)</B>
<B>    " optional: change highlight, otherwise Pmenu is used</B>
<B>    call nvim_win_set_option(win, 'winhl', 'Normal:MyHighlight')</B>


==============================================================================

Extended marks						   *<A NAME="api-extended-marks"></A><B>api-extended-marks</B>*

Extended marks (extmarks) represent buffer annotations that track text changes
in the buffer. They could be used to represent cursors, <A HREF="fold.html#folds">folds</A>, misspelled
words, and anything else that needs to track a logical location in the buffer
over time.

Example:

We will set an extmark at the first row and third column. |<A HREF="#api-indexing">api-indexing</A>| is
zero-indexed, so we use row=0 and column=2. Passing id=0 creates a new <A HREF="motion.html#mark">mark</A>
and returns the id:

<B>    let g:mark_ns = nvim_create_namespace('myplugin')</B>
<B>    let g:mark_id = nvim_buf_set_extmark(0, g:mark_ns, 0, 0, 2, {})</B>

We can get a <A HREF="motion.html#mark">mark</A> by its id:

<B>    echo nvim_buf_get_extmark_by_id(0, g:mark_ns, g:mark_id)</B>
<B>    =&gt; [0, 2]</B>

We can get all marks in a buffer for our namespace (or by a range):

<B>    echo nvim_buf_get_extmarks(0, g:mark_ns, 0, -1, {})</B>
<B>    =&gt; [[1, 0, 2]]</B>

Deleting all text surrounding an extmark does not remove the extmark. To
remove an extmark use |<A HREF="#nvim_buf_del_extmark()">nvim_buf_del_extmark()</A>|.

Namespaces allow your <A HREF="usr_05.html#plugin">plugin</A> to manage only its own extmarks, ignoring those
created by another <A HREF="usr_05.html#plugin">plugin</A>.

Extmark positions changed by an edit will be restored on undo/redo. Creating
and <A HREF="change.html#deleting">deleting</A> extmarks is not a buffer change, thus new <A HREF="undo.html#undo">undo</A> states are not
created for extmark changes.

==============================================================================

Global Functions                                                  *<A NAME="api-global"></A><B>api-global</B>*


nvim__get_hl_defs({ns_id})                               *<A NAME="nvim__get_hl_defs()"></A><B>nvim__get_hl_defs()</B>*
                TODO: Documentation


<A HREF="#nvim__get_lib_dir()">nvim__get_lib_dir()</A>                                      *<A NAME="nvim__get_lib_dir()"></A><B>nvim__get_lib_dir()</B>*
                TODO: Documentation


nvim__id({obj})                                                   *<A NAME="nvim__id()"></A><B>nvim__id()</B>*
                Returns object given <A HREF="motion.html#as">as</A> argument.

                This <A HREF="#API">API</A> function is used for testing. One should not rely on
                its presence in plugins.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {obj}  Object to return.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    its argument.


nvim__id_array({arr})                                       *<A NAME="nvim__id_array()"></A><B>nvim__id_array()</B>*
                Returns array given <A HREF="motion.html#as">as</A> argument.

                This <A HREF="#API">API</A> function is used for testing. One should not rely on
                its presence in plugins.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {arr}  Array to return.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    its argument.


nvim__id_dictionary({dct})                             *<A NAME="nvim__id_dictionary()"></A><B>nvim__id_dictionary()</B>*
                Returns dictionary given <A HREF="motion.html#as">as</A> argument.

                This <A HREF="#API">API</A> function is used for testing. One should not rely on
                its presence in plugins.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {dct}  <A HREF="eval.html#Dictionary">Dictionary</A> to return.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    its argument.


nvim__id_float({flt})                                       *<A NAME="nvim__id_float()"></A><B>nvim__id_float()</B>*
                Returns floating-point value given <A HREF="motion.html#as">as</A> argument.

                This <A HREF="#API">API</A> function is used for testing. One should not rely on
                its presence in plugins.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {flt}  Value to return.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    its argument.


nvim__inspect_cell({grid}, {row}, {col})                *<A NAME="nvim__inspect_cell()"></A><B>nvim__inspect_cell()</B>*
                TODO: Documentation


nvim__screenshot({path})                                  *<A NAME="nvim__screenshot()"></A><B>nvim__screenshot()</B>*
                TODO: Documentation

<B><FONT color="#54A23D">                Attributes: </FONT></B>
                    {fast}


nvim__set_hl_ns({ns_id})                                   *<A NAME="nvim__set_hl_ns()"></A><B>nvim__set_hl_ns()</B>*
                Set active namespace for highlights.

                NB: this function can be called from async contexts, but the
                semantics are not yet well-defined. To start with
                |<A HREF="intro.html#nvim_set_decoration_provider">nvim_set_decoration_provider</A>| on_win and on_line callbacks
                are explicitly allowed to change the namespace during a redraw
                cycle.

<B><FONT color="#54A23D">                Attributes: </FONT></B>
                    {fast}

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {ns_id}  the namespace to activate


<A HREF="#nvim__stats()">nvim__stats()</A>                                                  *<A NAME="nvim__stats()"></A><B>nvim__stats()</B>*
                Gets internal stats.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Map of various internal stats.


nvim_call_atomic({calls})                                 *<A NAME="nvim_call_atomic()"></A><B>nvim_call_atomic()</B>*
                Calls many <A HREF="#API">API</A> methods atomically.

                This has two main usages:
                1. To perform several requests from an async <A HREF="repeat.html#context">context</A>
                   atomically, i.e. without interleaving redraws, <A HREF="#RPC">RPC</A> requests
                   from other clients, or user interactions (however <A HREF="#API">API</A>
                   methods may trigger autocommands or event processing which
                   have such side-effects, e.g. |<A HREF="various.html#:sleep">:sleep</A>| may wake <A HREF="eval.html#timers">timers</A>).
                2. To minimize <A HREF="#RPC">RPC</A> overhead (roundtrips) of a sequence of many
                   requests.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {calls}  an array of calls, where each call is described
                             by an array with two elements: the request name,
                             and an array of arguments.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Array of two elements. The first is an array of return
                    values. The second is NIL if all calls succeeded. If a
                    call resulted in an error, <A HREF="motion.html#it">it</A> is a three-element array
                    with the zero-based index of the call which resulted in an
                    error, the error type and the error message. If an error
                    occurred, the values from all preceding calls will still
                    be returned.


                                                   *<A NAME="nvim_call_dict_function()"></A><B>nvim_call_dict_function()</B>*
nvim_call_dict_function({dict}, {fn}, {args})
                Calls a VimL |<A HREF="eval.html#Dictionary-function">Dictionary-function</A>| with the given arguments.

                On execution error: fails with VimL error, does not update
                <A HREF="eval.html#v:errmsg">v:errmsg</A>.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {dict}  <A HREF="eval.html#Dictionary">Dictionary</A>, or <A HREF="eval.html#String">String</A> evaluating to a VimL |<A HREF="eval.html#self">self</A>|
                            <A HREF="eval.html#dict">dict</A>
                    {fn}    Name of the function defined on the VimL <A HREF="eval.html#dict">dict</A>
                    {args}  Function arguments packed in an Array

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Result of the function call


nvim_call_function({fn}, {args})                        *<A NAME="nvim_call_function()"></A><B>nvim_call_function()</B>*
                Calls a VimL function with the given arguments.

                On execution error: fails with VimL error, does not update
                <A HREF="eval.html#v:errmsg">v:errmsg</A>.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {fn}    Function to call
                    {args}  Function arguments packed in an Array

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Result of the function call


nvim_chan_send({chan}, {data})                              *<A NAME="nvim_chan_send()"></A><B>nvim_chan_send()</B>*
                Send data to <A HREF="channel.html#channel">channel</A> `id` . For a <A HREF="job_control.html#job">job</A>, <A HREF="motion.html#it">it</A> writes <A HREF="motion.html#it">it</A> to the
                stdin of the process. For the stdio channel |<A HREF="channel.html#channel-stdio">channel-stdio</A>|,
                <A HREF="motion.html#it">it</A> writes to Nvim's stdout. For an internal <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> instance
                (|<A HREF="#nvim_open_term()">nvim_open_term()</A>|) <A HREF="motion.html#it">it</A> writes directly to terimal output. See
                |<A HREF="channel.html#channel-bytes">channel-bytes</A>| for more information.

                This function writes raw data, not <A HREF="#RPC">RPC</A> <A HREF="message.html#messages">messages</A>. If the
                <A HREF="channel.html#channel">channel</A> was created with `rpc=true` then the <A HREF="channel.html#channel">channel</A> expects
                <A HREF="#RPC">RPC</A> <A HREF="message.html#messages">messages</A>, use |<A HREF="vim.html">vim.rpcnotify()</A>| and |<A HREF="vim.html">vim.rpcrequest()</A>|
                instead.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {chan}  id of the <A HREF="channel.html#channel">channel</A>
                    {data}  data to write. 8-bit clean: can contain NUL bytes.


nvim_command({command})                                       *<A NAME="nvim_command()"></A><B>nvim_command()</B>*
                Executes an ex-command.

                On execution error: fails with VimL error, does not update
                <A HREF="eval.html#v:errmsg">v:errmsg</A>.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {command}  Ex-command <A HREF="eval.html#string">string</A>

<B><FONT color="#54A23D">                See also: </FONT></B>
                    |<A HREF="#nvim_exec()">nvim_exec()</A>|


nvim_create_buf({listed}, {scratch})                       *<A NAME="nvim_create_buf()"></A><B>nvim_create_buf()</B>*
                Creates a new, empty, unnamed buffer.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {listed}   Sets <A HREF="options.html#'buflisted'">'buflisted'</A>
                    {scratch}  Creates a &quot;throwaway&quot; |<A HREF="windows.html#scratch-buffer">scratch-buffer</A>| for
                               temporary work (always <A HREF="options.html#'nomodified'">'nomodified'</A>). Also sets
                               <A HREF="options.html#'nomodeline'">'nomodeline'</A> on the buffer.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Buffer handle, or 0 on error

<B><FONT color="#54A23D">                See also: </FONT></B>
                    buf_open_scratch


nvim_create_namespace({name})                        *<A NAME="nvim_create_namespace()"></A><B>nvim_create_namespace()</B>*
                Creates a new namespace, or gets an existing one.

                Namespaces are used for buffer highlights and virtual text,
                see |<A HREF="#nvim_buf_add_highlight()">nvim_buf_add_highlight()</A>| and
                |<A HREF="#nvim_buf_set_virtual_text()">nvim_buf_set_virtual_text()</A>|.

                Namespaces can be named or anonymous. If `name` matches an
                existing namespace, the associated id is returned. If `name`
                is an empty <A HREF="eval.html#string">string</A> a new, anonymous namespace is created.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {name}  Namespace name or empty <A HREF="eval.html#string">string</A>

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Namespace id


<A HREF="#nvim_del_current_line()">nvim_del_current_line()</A>                              *<A NAME="nvim_del_current_line()"></A><B>nvim_del_current_line()</B>*
                Deletes the current line.

<B><FONT color="#54A23D">                Attributes: </FONT></B>
                    not allowed when |<A HREF="eval.html#textlock">textlock</A>| is active


nvim_del_keymap({mode}, <A HREF="map.html#{lhs}">{lhs}</A>)                             *<A NAME="nvim_del_keymap()"></A><B>nvim_del_keymap()</B>*
                Unmaps a global |<A HREF="map.html#mapping">mapping</A>| for the given mode.

                To unmap a buffer-local <A HREF="map.html#mapping">mapping</A>, use |<A HREF="#nvim_buf_del_keymap()">nvim_buf_del_keymap()</A>|.

<B><FONT color="#54A23D">                See also: </FONT></B>
                    |<A HREF="#nvim_set_keymap()">nvim_set_keymap()</A>|


nvim_del_var({name})                                          *<A NAME="nvim_del_var()"></A><B>nvim_del_var()</B>*
                Removes a global (g:) variable.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {name}  Variable name


nvim_echo({chunks}, {history}, {opts})                           *<A NAME="nvim_echo()"></A><B>nvim_echo()</B>*
                Echo a message.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {chunks}   A <A HREF="eval.html#list">list</A> of [text, hl_group] arrays, each
                               representing a text chunk with specified
                               highlight. `hl_group` element can be omitted
                               for no highlight.
                    {history}  if true, add to |<A HREF="message.html#message-history">message-history</A>|.
                    {opts}     Optional parameters. Reserved for future use.


nvim_err_write({str})                                       *<A NAME="nvim_err_write()"></A><B>nvim_err_write()</B>*
                Writes a message to the Vim error buffer. Does not append
                &quot;\n&quot;, the message is buffered (won't display) until a <A HREF="intro.html#linefeed">linefeed</A>
                is written.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {str}  Message


nvim_err_writeln({str})                                   *<A NAME="nvim_err_writeln()"></A><B>nvim_err_writeln()</B>*
                Writes a message to the Vim error buffer. Appends &quot;\n&quot;, so the
                buffer is flushed (and displayed).

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {str}  Message

<B><FONT color="#54A23D">                See also: </FONT></B>
                    <A HREF="#nvim_err_write()">nvim_err_write()</A>


nvim_eval({expr})                                                *<A NAME="nvim_eval()"></A><B>nvim_eval()</B>*
                Evaluates a VimL |<A HREF="eval.html#expression">expression</A>|. <A HREF="eval.html#Dictionaries">Dictionaries</A> and <A HREF="eval.html#Lists">Lists</A> are
                recursively expanded.

                On execution error: fails with VimL error, does not update
                <A HREF="eval.html#v:errmsg">v:errmsg</A>.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {expr}  VimL <A HREF="eval.html#expression">expression</A> <A HREF="eval.html#string">string</A>

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Evaluation result or expanded object


nvim_exec({src}, {output})                                       *<A NAME="nvim_exec()"></A><B>nvim_exec()</B>*
                Executes Vimscript (multiline block of Ex-commands), like
                anonymous |<A HREF="repeat.html#:source">:source</A>|.

                Unlike |<A HREF="#nvim_command()">nvim_command()</A>| this function supports heredocs,
                script-scope (s:), etc.

                On execution error: fails with VimL error, does not update
                <A HREF="eval.html#v:errmsg">v:errmsg</A>.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {src}     Vimscript code
                    {output}  Capture and return all (non-error, non-shell
                              |<A HREF="various.html#:!">:!</A>|) output

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Output (non-error, non-shell |<A HREF="various.html#:!">:!</A>|) if `output` is true,
                    else empty <A HREF="eval.html#string">string</A>.

<B><FONT color="#54A23D">                See also: </FONT></B>
                    |<A HREF="eval.html#execute()">execute()</A>|
                    |<A HREF="#nvim_command()">nvim_command()</A>|


nvim_exec_lua({code}, {args})                                *<A NAME="nvim_exec_lua()"></A><B>nvim_exec_lua()</B>*
                Execute <A HREF="lua.html#Lua">Lua</A> code. Parameters (if any) are available <A HREF="motion.html#as">as</A> `...`
                inside the chunk. The chunk can return a value.

                Only statements are executed. To evaluate an <A HREF="eval.html#expression">expression</A>,
                prefix <A HREF="motion.html#it">it</A> with `return` : return my_function(...)

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {code}  <A HREF="lua.html#Lua">Lua</A> code to execute
                    {args}  Arguments to the code

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Return value of <A HREF="lua.html#Lua">Lua</A> code if present or NIL.


nvim_feedkeys({keys}, {mode}, {escape_csi})                  *<A NAME="nvim_feedkeys()"></A><B>nvim_feedkeys()</B>*
                Sends input-keys to Nvim, subject to various quirks controlled
                by `mode` flags. This is a blocking call, unlike
                |<A HREF="#nvim_input()">nvim_input()</A>|.

                On execution error: does not fail, but updates <A HREF="eval.html#v:errmsg">v:errmsg</A>.

                If you need to input sequences like &lt;C-o&gt; use
                |<A HREF="intro.html#nvim_replace_termcodes">nvim_replace_termcodes</A>| to replace the termcodes and then
                pass the resulting <A HREF="eval.html#string">string</A> to nvim_feedkeys. You'll also want
                to enable escape_csi.

                Example:
<B>                    :let key = nvim_replace_termcodes("&lt;C-o&gt;", v:true, v:false, v:true)</B>
<B>                    :call nvim_feedkeys(key, 'n', v:true)</B>
 

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {keys}        to be typed
                    {mode}        behavior flags, see |<A HREF="eval.html#feedkeys()">feedkeys()</A>|
                    {escape_csi}  If true, <A HREF="intro.html#escape">escape</A> K_SPECIAL/CSI bytes in
                                  `keys`

<B><FONT color="#54A23D">                See also: </FONT></B>
                    <A HREF="eval.html#feedkeys()">feedkeys()</A>
                    vim_strsave_escape_csi


<A HREF="#nvim_get_all_options_info()">nvim_get_all_options_info()</A>                      *<A NAME="nvim_get_all_options_info()"></A><B>nvim_get_all_options_info()</B>*
                Gets the option information for all <A HREF="options.html#options">options</A>.

                The dictionary has the full option names <A HREF="motion.html#as">as</A> keys and option
                metadata dictionaries <A HREF="motion.html#as">as</A> detailed at |<A HREF="intro.html#nvim_get_option_info">nvim_get_option_info</A>|.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    dictionary of all <A HREF="options.html#options">options</A>


<A HREF="#nvim_get_api_info()">nvim_get_api_info()</A>                                      *<A NAME="nvim_get_api_info()"></A><B>nvim_get_api_info()</B>*
                Returns a 2-tuple (Array), where item 0 is the current <A HREF="channel.html#channel">channel</A>
                id and item 1 is the |<A HREF="#api-metadata">api-metadata</A>| map (Dictionary).

<B><FONT color="#54A23D">                Return: </FONT></B>
                    2-tuple [{channel-id}, {api-metadata}]

<B><FONT color="#54A23D">                Attributes: </FONT></B>
                    {fast}


nvim_get_chan_info({chan})                              *<A NAME="nvim_get_chan_info()"></A><B>nvim_get_chan_info()</B>*
                Get information about a <A HREF="channel.html#channel">channel</A>.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    <A HREF="eval.html#Dictionary">Dictionary</A> describing a <A HREF="channel.html#channel">channel</A>, with these keys:
                    • &quot;stream&quot; the stream underlying the <A HREF="channel.html#channel">channel</A>
                      • &quot;stdio&quot; stdin and stdout of this Nvim instance
                      • &quot;stderr&quot; stderr of this Nvim instance
                      • &quot;socket&quot; TCP/IP socket or named pipe
                      • &quot;<A HREF="job_control.html#job">job</A>&quot; <A HREF="job_control.html#job">job</A> with communication over its stdio

                    • &quot;mode&quot; how data received on the <A HREF="channel.html#channel">channel</A> is interpreted
                      • &quot;bytes&quot; send and receive raw bytes
                      • &quot;terminal&quot; a |<A HREF="nvim_terminal_emulator.html#terminal">terminal</A>| instance interprets ASCII
                        sequences
                      • &quot;<A HREF="#rpc">rpc</A>&quot; |<A HREF="#RPC">RPC</A>| communication on the <A HREF="channel.html#channel">channel</A> is active

                    • &quot;pty&quot; Name of pseudoterminal, if one is used (optional).
                      On a POSIX system, this will be a device path like
                      /dev/pts/1. Even if the name is unknown, the key will
                      still be present to indicate a pty is used. This is
                      currently the <A HREF="change.html#case">case</A> when using winpty on <A HREF="windows.html#windows">windows</A>.
                    • &quot;buffer&quot; buffer with connected |<A HREF="nvim_terminal_emulator.html#terminal">terminal</A>| instance
                      (optional)
                    • &quot;client&quot; information about the client on the other end
                      of the <A HREF="#RPC">RPC</A> <A HREF="channel.html#channel">channel</A>, if <A HREF="motion.html#it">it</A> has added <A HREF="motion.html#it">it</A> using
                      |<A HREF="#nvim_set_client_info()">nvim_set_client_info()</A>|. (optional)


nvim_get_color_by_name({name})                      *<A NAME="nvim_get_color_by_name()"></A><B>nvim_get_color_by_name()</B>*
                Returns the 24-bit RGB value of a |<A HREF="#nvim_get_color_map()">nvim_get_color_map()</A>| color
                name or &quot;#rrggbb&quot; hexadecimal <A HREF="eval.html#string">string</A>.

                Example:
<B>                    :echo nvim_get_color_by_name("Pink")</B>
<B>                    :echo nvim_get_color_by_name("#cbcbcb")</B>
 

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {name}  Color name or &quot;#rrggbb&quot; <A HREF="eval.html#string">string</A>

<B><FONT color="#54A23D">                Return: </FONT></B>
                    24-bit RGB value, or -1 for invalid argument.


<A HREF="#nvim_get_color_map()">nvim_get_color_map()</A>                                    *<A NAME="nvim_get_color_map()"></A><B>nvim_get_color_map()</B>*
                Returns a map of color names and RGB values.

                Keys are color names (e.g. &quot;Aqua&quot;) and values are 24-bit RGB
                color values (e.g. 65535).

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Map of color names and RGB values.


nvim_get_commands({opts})                                *<A NAME="nvim_get_commands()"></A><B>nvim_get_commands()</B>*
                Gets a map of global (non-buffer-local) <A HREF="intro.html#Ex">Ex</A> commands.

                Currently only |<A HREF="map.html#user-commands">user-commands</A>| are supported, not builtin <A HREF="intro.html#Ex">Ex</A>
                commands.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {opts}  Optional parameters. Currently only supports
                            {&quot;builtin&quot;:false}

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Map of maps describing commands.


nvim_get_context({opts})                                  *<A NAME="nvim_get_context()"></A><B>nvim_get_context()</B>*
                Gets a map of the current editor state.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {opts}  Optional parameters.
                            • types: <A HREF="eval.html#List">List</A> of |<A HREF="repeat.html#context-types">context-types</A>| (&quot;regs&quot;, &quot;jumps&quot;,
                              &quot;bufs&quot;, &quot;gvars&quot;, …) to gather, or empty for
                              &quot;all&quot;.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    map of global |<A HREF="repeat.html#context">context</A>|.


<A HREF="#nvim_get_current_buf()">nvim_get_current_buf()</A>                                *<A NAME="nvim_get_current_buf()"></A><B>nvim_get_current_buf()</B>*
                Gets the current buffer.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Buffer handle


<A HREF="#nvim_get_current_line()">nvim_get_current_line()</A>                              *<A NAME="nvim_get_current_line()"></A><B>nvim_get_current_line()</B>*
                Gets the current line.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Current line <A HREF="eval.html#string">string</A>


<A HREF="#nvim_get_current_tabpage()">nvim_get_current_tabpage()</A>                        *<A NAME="nvim_get_current_tabpage()"></A><B>nvim_get_current_tabpage()</B>*
                Gets the current <A HREF="tabpage.html#tabpage">tabpage</A>.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Tabpage handle


<A HREF="#nvim_get_current_win()">nvim_get_current_win()</A>                                *<A NAME="nvim_get_current_win()"></A><B>nvim_get_current_win()</B>*
                Gets the current <A HREF="windows.html#window">window</A>.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Window handle


nvim_get_hl_by_id({hl_id}, {rgb})                        *<A NAME="nvim_get_hl_by_id()"></A><B>nvim_get_hl_by_id()</B>*
                Gets a highlight definition by id. |<A HREF="eval.html#hlID()">hlID()</A>|

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {hl_id}  Highlight id <A HREF="motion.html#as">as</A> returned by |<A HREF="eval.html#hlID()">hlID()</A>|
                    {rgb}    Export RGB colors

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Highlight definition map

<B><FONT color="#54A23D">                See also: </FONT></B>
                    nvim_get_hl_by_name


nvim_get_hl_by_name({name}, {rgb})                     *<A NAME="nvim_get_hl_by_name()"></A><B>nvim_get_hl_by_name()</B>*
                Gets a highlight definition by name.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {name}  Highlight group name
                    {rgb}   Export RGB colors

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Highlight definition map

<B><FONT color="#54A23D">                See also: </FONT></B>
                    nvim_get_hl_by_id


nvim_get_hl_id_by_name({name})                      *<A NAME="nvim_get_hl_id_by_name()"></A><B>nvim_get_hl_id_by_name()</B>*
                Gets a highlight group by name

                similar to |<A HREF="eval.html#hlID()">hlID()</A>|, but allocates a new ID if not present.


nvim_get_keymap({mode})                                    *<A NAME="nvim_get_keymap()"></A><B>nvim_get_keymap()</B>*
                Gets a <A HREF="eval.html#list">list</A> of global (non-buffer-local) |<A HREF="map.html#mapping">mapping</A>|
                <A HREF="intro.html#definitions">definitions</A>.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {mode}  Mode short-name (&quot;n&quot;, &quot;<A HREF="insert.html#i">i</A>&quot;, &quot;<A HREF="visual.html#v">v</A>&quot;, <A HREF="eval.html#...">...</A>)

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Array of maparg()-like dictionaries describing mappings.
                    The &quot;buffer&quot; key is always zero.


<A HREF="#nvim_get_mode()">nvim_get_mode()</A>                                              *<A NAME="nvim_get_mode()"></A><B>nvim_get_mode()</B>*
                Gets the current mode. |<A HREF="eval.html#mode()">mode()</A>| &quot;blocking&quot; is true if Nvim is
                waiting for input.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    <A HREF="eval.html#Dictionary">Dictionary</A> { &quot;mode&quot;: <A HREF="eval.html#String">String</A>, &quot;blocking&quot;: <A HREF="eval.html#Boolean">Boolean</A> }

<B><FONT color="#54A23D">                Attributes: </FONT></B>
                    {fast}


<A HREF="#nvim_get_namespaces()">nvim_get_namespaces()</A>                                  *<A NAME="nvim_get_namespaces()"></A><B>nvim_get_namespaces()</B>*
                Gets existing, non-anonymous namespaces.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    <A HREF="eval.html#dict">dict</A> that maps from names to namespace ids.


nvim_get_option({name})                                    *<A NAME="nvim_get_option()"></A><B>nvim_get_option()</B>*
                Gets an option value <A HREF="eval.html#string">string</A>.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {name}  Option name

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Option value (global)


nvim_get_option_info({name})                          *<A NAME="nvim_get_option_info()"></A><B>nvim_get_option_info()</B>*
                Gets the option information for one option

                Resulting dictionary has keys:
                • name: Name of the option (like <A HREF="options.html#'filetype'">'filetype'</A>)
                • shortname: Shortened name of the option (like <A HREF="options.html#'ft'">'ft'</A>)
                • type: type of option (&quot;string&quot;, &quot;integer&quot; or &quot;<A HREF="options.html#boolean">boolean</A>&quot;)
                • default: The default value for the option
                • was_set: Whether the option was set.
                • last_set_sid: Last set <A HREF="usr_41.html#script">script</A> id (if any)
                • last_set_linenr: line number where option was set
                • last_set_chan: Channel where option was set (0 for local)
                • scope: one of &quot;global&quot;, &quot;win&quot;, or &quot;buf&quot;
                • global_local: whether win or buf option has a global value
                • commalist: <A HREF="eval.html#List">List</A> of comma separated values
                • flaglist: <A HREF="eval.html#List">List</A> of single char flags

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {name}  Option name

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Option Information


nvim_get_proc({pid})                                         *<A NAME="nvim_get_proc()"></A><B>nvim_get_proc()</B>*
                Gets info describing process `pid` .

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Map of process properties, or NIL if process not found.


nvim_get_proc_children({pid})                       *<A NAME="nvim_get_proc_children()"></A><B>nvim_get_proc_children()</B>*
                Gets the immediate children of process `pid` .

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Array of child process ids, empty if process not found.


nvim_get_runtime_file({name}, {all})                 *<A NAME="nvim_get_runtime_file()"></A><B>nvim_get_runtime_file()</B>*
                Find files in runtime directories

                'name' can contain <A HREF="editing.html#wildcards">wildcards</A>. For example
                nvim_get_runtime_file(&quot;colors/*.vim&quot;, true) will return all
                color scheme files. Always use forward slashes (/) in the
                search <A HREF="pattern.html#pattern">pattern</A> for subdirectories regardless of platform.

                It is not an error to not find any files. An empty array is
                returned then.

                To find a directory, `name` must end with a forward slash,
                like &quot;rplugin/python/&quot;. Without the slash <A HREF="motion.html#it">it</A> would instead
                look for an ordinary file called &quot;rplugin/python&quot;.

<B><FONT color="#54A23D">                Attributes: </FONT></B>
                    {fast}

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {name}  <A HREF="pattern.html#pattern">pattern</A> of files to search for
                    {all}   whether to return all matches or only the first

<B><FONT color="#54A23D">                Return: </FONT></B>
                    <A HREF="eval.html#list">list</A> of absolute paths to the found files


nvim_get_var({name})                                          *<A NAME="nvim_get_var()"></A><B>nvim_get_var()</B>*
                Gets a global (g:) variable.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {name}  Variable name

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Variable value


nvim_get_vvar({name})                                        *<A NAME="nvim_get_vvar()"></A><B>nvim_get_vvar()</B>*
                Gets a <A HREF="eval.html#v:">v:</A> variable.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {name}  Variable name

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Variable value


nvim_input({keys})                                              *<A NAME="nvim_input()"></A><B>nvim_input()</B>*
                Queues raw user-input. Unlike |<A HREF="#nvim_feedkeys()">nvim_feedkeys()</A>|, this uses a
                low-level input buffer and the call is non-blocking (input is
                processed asynchronously by the eventloop).

                On execution error: does not fail, but updates <A HREF="eval.html#v:errmsg">v:errmsg</A>.

                Note:
                    |<A HREF="intro.html#keycodes">keycodes</A>| like <A HREF="motion.html#&lt;CR&gt;">&lt;CR&gt;</A> are translated, so &quot;<A HREF="change.html#&lt;">&lt;</A>&quot; is special. To
                    input a literal &quot;<A HREF="change.html#&lt;">&lt;</A>&quot;, send &lt;LT&gt;.

                Note:
                    For mouse <A HREF="autocmd.html#events">events</A> use |<A HREF="#nvim_input_mouse()">nvim_input_mouse()</A>|. The pseudokey
                    form &quot;&lt;LeftMouse&gt;&lt;col,row&gt;&quot; is <A HREF="deprecated.html#deprecated">deprecated</A> since
                    |<A HREF="#api-level">api-level</A>| 6.

<B><FONT color="#54A23D">                Attributes: </FONT></B>
                    {fast}

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {keys}  to be typed

<B><FONT color="#54A23D">                Return: </FONT></B>
                    <A HREF="eval.html#Number">Number</A> of bytes actually written (can be fewer than
                    requested if the buffer becomes full).


                                                          *<A NAME="nvim_input_mouse()"></A><B>nvim_input_mouse()</B>*
nvim_input_mouse({button}, {action}, {modifier}, {grid}, {row}, {col})
                Send mouse event from <A HREF="gui.html#GUI">GUI</A>.

                Non-blocking: does not wait on any result, but queues the
                event to be processed soon by the event loop.

                Note:
                    Currently this doesn't support &quot;scripting&quot; multiple mouse
                    <A HREF="autocmd.html#events">events</A> by calling <A HREF="motion.html#it">it</A> multiple times in a loop: the
                    intermediate mouse positions will be ignored. It should be
                    used to implement real-time mouse input in a <A HREF="gui.html#GUI">GUI</A>. The
                    <A HREF="deprecated.html#deprecated">deprecated</A> pseudokey form (&quot;&lt;LeftMouse&gt;&lt;col,row&gt;&quot;) of
                    |<A HREF="#nvim_input()">nvim_input()</A>| has the same limitiation.

<B><FONT color="#54A23D">                Attributes: </FONT></B>
                    {fast}

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {button}    Mouse button: one of &quot;left&quot;, &quot;right&quot;,
                                &quot;middle&quot;, &quot;wheel&quot;.
                    {action}    For ordinary buttons, one of &quot;press&quot;, &quot;drag&quot;,
                                &quot;release&quot;. For the wheel, one of &quot;up&quot;, &quot;down&quot;,
                                &quot;left&quot;, &quot;right&quot;.
                    {modifier}  <A HREF="eval.html#String">String</A> of modifiers each represented by a
                                single char. The same specifiers are used <A HREF="motion.html#as">as</A>
                                for a key press, except that the &quot;<A HREF="motion.html#-">-</A>&quot; separator
                                is optional, so &quot;C-A-&quot;, &quot;c-a&quot; and &quot;CA&quot; can all
                                be used to specify Ctrl+Alt+click.
                    {grid}      Grid number if the client uses |<A HREF="ui.html#ui-multigrid">ui-multigrid</A>|,
                                else 0.
                    {row}       Mouse row-position (zero-based, like redraw
                                <A HREF="autocmd.html#events">events</A>)
                    {col}       Mouse column-position (zero-based, like redraw
                                <A HREF="autocmd.html#events">events</A>)


<A HREF="#nvim_list_bufs()">nvim_list_bufs()</A>                                            *<A NAME="nvim_list_bufs()"></A><B>nvim_list_bufs()</B>*
                Gets the current <A HREF="eval.html#list">list</A> of buffer handles

                Includes unlisted (unloaded/deleted) <A HREF="windows.html#buffers">buffers</A>, like `:ls!` .
                Use |<A HREF="#nvim_buf_is_loaded()">nvim_buf_is_loaded()</A>| to check if a buffer is loaded.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    <A HREF="eval.html#List">List</A> of buffer handles


<A HREF="#nvim_list_chans()">nvim_list_chans()</A>                                          *<A NAME="nvim_list_chans()"></A><B>nvim_list_chans()</B>*
                Get information about all open channels.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Array of <A HREF="eval.html#Dictionaries">Dictionaries</A>, each describing a <A HREF="channel.html#channel">channel</A> with the
                    format specified at |<A HREF="#nvim_get_chan_info()">nvim_get_chan_info()</A>|.


<A HREF="#nvim_list_runtime_paths()">nvim_list_runtime_paths()</A>                          *<A NAME="nvim_list_runtime_paths()"></A><B>nvim_list_runtime_paths()</B>*
                Gets the paths contained in <A HREF="options.html#'runtimepath'">'runtimepath'</A>.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    <A HREF="eval.html#List">List</A> of paths


<A HREF="#nvim_list_tabpages()">nvim_list_tabpages()</A>                                    *<A NAME="nvim_list_tabpages()"></A><B>nvim_list_tabpages()</B>*
                Gets the current <A HREF="eval.html#list">list</A> of <A HREF="tabpage.html#tabpage">tabpage</A> handles.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    <A HREF="eval.html#List">List</A> of <A HREF="tabpage.html#tabpage">tabpage</A> handles


<A HREF="#nvim_list_uis()">nvim_list_uis()</A>                                              *<A NAME="nvim_list_uis()"></A><B>nvim_list_uis()</B>*
                Gets a <A HREF="eval.html#list">list</A> of dictionaries representing attached UIs.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Array of <A HREF="ui.html#UI">UI</A> dictionaries, each with these keys:
                    • &quot;height&quot; Requested height of the <A HREF="ui.html#UI">UI</A>
                    • &quot;width&quot; Requested width of the <A HREF="ui.html#UI">UI</A>
                    • &quot;rgb&quot; true if the <A HREF="ui.html#UI">UI</A> uses RGB colors (false implies
                      |<A HREF="syntax.html#cterm-colors">cterm-colors</A>|)
                    • &quot;ext_...&quot; Requested <A HREF="ui.html#UI">UI</A> extensions, see |<A HREF="ui.html#ui-option">ui-option</A>|
                    • &quot;chan&quot; Channel id of remote <A HREF="ui.html#UI">UI</A> (not present for <A HREF="term.html#TUI">TUI</A>)


<A HREF="#nvim_list_wins()">nvim_list_wins()</A>                                            *<A NAME="nvim_list_wins()"></A><B>nvim_list_wins()</B>*
                Gets the current <A HREF="eval.html#list">list</A> of <A HREF="windows.html#window">window</A> handles.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    <A HREF="eval.html#List">List</A> of <A HREF="windows.html#window">window</A> handles


nvim_load_context({dict})                                *<A NAME="nvim_load_context()"></A><B>nvim_load_context()</B>*
                Sets the current editor state from the given |<A HREF="repeat.html#context">context</A>| map.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {dict}  |<A HREF="repeat.html#Context">Context</A>| map.


nvim_notify({msg}, {log_level}, {opts})                        *<A NAME="nvim_notify()"></A><B>nvim_notify()</B>*
                Notify the user with a message

                Relays the call to vim.notify . By default forwards your
                message in the echo area but can be overriden to trigger
                desktop notifications.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {msg}        Message to display to the user
                    {log_level}  The log level
                    {opts}       Reserved for future use.


nvim_open_term({buffer}, {opts})                            *<A NAME="nvim_open_term()"></A><B>nvim_open_term()</B>*
                Open a <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> instance in a buffer

                By default (and currently the only option) the <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> will
                not be connected to an external process. Instead, input send
                on the <A HREF="channel.html#channel">channel</A> will be echoed directly by the <A HREF="nvim_terminal_emulator.html#terminal">terminal</A>. This
                is useful to disply ANSI <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> sequences returned <A HREF="motion.html#as">as</A> part
                of a <A HREF="#rpc">rpc</A> message, or similar.

                Note: to directly initiate the <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> using the right size,
                display the buffer in a configured <A HREF="windows.html#window">window</A> before calling this.
                For instance, for a floating display, first create an empty
                buffer using |<A HREF="#nvim_create_buf()">nvim_create_buf()</A>|, then display <A HREF="motion.html#it">it</A> using
                |<A HREF="#nvim_open_win()">nvim_open_win()</A>|, and then call this function. Then
                |<A HREF="#nvim_chan_send()">nvim_chan_send()</A>| cal be called immediately to process
                sequences in a virtual <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> having the intended size.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}  the buffer to use (expected to be empty)
                    {opts}    Optional parameters. Reserved for future use.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Channel id, or 0 on error


nvim_open_win({buffer}, {enter}, {config})                   *<A NAME="nvim_open_win()"></A><B>nvim_open_win()</B>*
                Open a new <A HREF="windows.html#window">window</A>.

                Currently this is used to open floating and external <A HREF="windows.html#windows">windows</A>.
                Floats are <A HREF="windows.html#windows">windows</A> that are drawn above the split layout, at
                some anchor position in some other <A HREF="windows.html#window">window</A>. Floats can be drawn
                internally or by external <A HREF="gui.html#GUI">GUI</A> with the |<A HREF="ui.html#ui-multigrid">ui-multigrid</A>|
                extension. External <A HREF="windows.html#windows">windows</A> are only supported with multigrid
                GUIs, and are displayed <A HREF="motion.html#as">as</A> separate top-level <A HREF="windows.html#windows">windows</A>.

                For a general overview of floats, see |<A HREF="#api-floatwin">api-floatwin</A>|.

                Exactly one of `external` and `relative` must be specified.
                The `width` and `height` of the new <A HREF="windows.html#window">window</A> must be specified.

                With relative=editor (row=0,col=0) refers to the top-left
                corner of the screen-grid and (row=Lines-1,col=Columns-1)
                refers to the bottom-right corner. Fractional values are
                allowed, but the builtin implementation (used by non-multigrid
                UIs) will always round down to nearest integer.

                Out-of-bounds values, and configurations that make the float
                not fit inside the main editor, are allowed. The builtin
                implementation truncates values so floats are fully within the
                main screen grid. External GUIs could let floats hover outside
                of the main <A HREF="windows.html#window">window</A> like a tooltip, but this should not be used
                to specify arbitrary WM screen positions.

                Example (Lua): window-relative float
<B>                    vim.api.nvim_open_win(0, false,</B>
<B>                      {relative='win', row=3, col=3, width=12, height=3})</B>
 

                Example (Lua): buffer-relative float (travels <A HREF="motion.html#as">as</A> buffer is
                scrolled)
<B>                    vim.api.nvim_open_win(0, false,</B>
<B>                      {relative='win', width=12, height=3, bufpos={100,10}})</B>
 

<B><FONT color="#54A23D">                Attributes: </FONT></B>
                    not allowed when |<A HREF="eval.html#textlock">textlock</A>| is active

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}  Buffer to display, or 0 for current buffer
                    {enter}   Enter the <A HREF="windows.html#window">window</A> (make <A HREF="motion.html#it">it</A> the current <A HREF="windows.html#window">window</A>)
                    {config}  Map defining the <A HREF="windows.html#window">window</A> configuration. Keys:
                              • `relative`: Sets the <A HREF="windows.html#window">window</A> layout to &quot;floating&quot;, placed
                                at (row,col) coordinates relative to:
                                • &quot;editor&quot; The global editor grid
                                • &quot;win&quot; Window given by the `win` field, or
                                  current <A HREF="windows.html#window">window</A>.
                                • &quot;cursor&quot; Cursor position in current <A HREF="windows.html#window">window</A>.

                              • `win` : |<A HREF="windows.html#window-ID">window-ID</A>| for relative=&quot;win&quot;.
                              • `anchor`: Decides which corner of the float to place
                                at (row,col):
                                • &quot;NW&quot; northwest (default)
                                • &quot;NE&quot; northeast
                                • &quot;SW&quot; southwest
                                • &quot;SE&quot; southeast

                              • `width` : Window width (in character cells).
                                Minimum of 1.
                              • `height` : Window height (in character cells).
                                Minimum of 1.
                              • `bufpos` : Places float relative to buffer
                                text (only when relative=&quot;win&quot;). Takes a tuple
                                of zero-indexed [line, column]. `row` and
                                `col` if given are applied relative to this
                                position, else they default to `row=1` and
                                `col=0` (thus like a tooltip near the buffer
                                text).
                              • `row` : Row position in units of &quot;screen cell
                                height&quot;, may be fractional.
                              • `col` : Column position in units of &quot;screen
                                cell width&quot;, may be fractional.
                              • `focusable` : Enable focus by user actions
                                (wincmds, mouse <A HREF="autocmd.html#events">events</A>). Defaults to true.
                                Non-focusable <A HREF="windows.html#windows">windows</A> can be entered by
                                |<A HREF="#nvim_set_current_win()">nvim_set_current_win()</A>|.
                              • `external` : <A HREF="gui.html#GUI">GUI</A> should display the <A HREF="windows.html#window">window</A> <A HREF="motion.html#as">as</A>
                                an external top-level <A HREF="windows.html#window">window</A>. Currently
                                accepts no other positioning configuration
                                together with this.
                              • `style`: Configure the appearance of the <A HREF="windows.html#window">window</A>.
                                Currently only takes one non-empty value:
                                • &quot;minimal&quot; Nvim will display the <A HREF="windows.html#window">window</A> with
                                  many <A HREF="ui.html#UI">UI</A> <A HREF="options.html#options">options</A> disabled. This is useful
                                  when displaying a temporary float where the
                                  text should not be edited. Disables
                                  <A HREF="options.html#'number'">'number'</A>, <A HREF="options.html#'relativenumber'">'relativenumber'</A>, <A HREF="options.html#'cursorline'">'cursorline'</A>,
                                  <A HREF="options.html#'cursorcolumn'">'cursorcolumn'</A>, <A HREF="options.html#'foldcolumn'">'foldcolumn'</A>, <A HREF="options.html#'spell'">'spell'</A> and
                                  <A HREF="options.html#'list'">'list'</A> <A HREF="options.html#options">options</A>. <A HREF="options.html#'signcolumn'">'signcolumn'</A> is changed to
                                  `auto` and <A HREF="options.html#'colorcolumn'">'colorcolumn'</A> is cleared. The
                                  end-of-buffer region is hidden by setting
                                  `eob` flag of <A HREF="options.html#'fillchars'">'fillchars'</A> to a space char,
                                  and clearing the |<A HREF="intro.html#EndOfBuffer">EndOfBuffer</A>| region in
                                  <A HREF="options.html#'winhighlight'">'winhighlight'</A>.

                              • `border`: style of (optional) <A HREF="windows.html#window">window</A> border. This can
                                either be a <A HREF="eval.html#string">string</A> or an array. the <A HREF="eval.html#string">string</A>
                                values are:
                                • &quot;none&quot; No border. This is the default
                                • &quot;single&quot; a single line box
                                • &quot;double&quot; a double line box
                                • &quot;shadow&quot; a drop shadow effect by blending
                                  with the background. If <A HREF="motion.html#it">it</A> is an array <A HREF="motion.html#it">it</A>
                                  should be an array of eight items or any
                                  divisor of eight. The array will specifify
                                  the eight chars building up the border in a
                                  clockwise fashion starting with the top-left
                                  corner. As, an example, the double box style
                                  could be specified <A HREF="motion.html#as">as</A>: [ &quot;╔&quot;, &quot;═&quot; ,&quot;╗&quot;, &quot;║&quot;,
                                  &quot;╝&quot;, &quot;═&quot;, &quot;╚&quot;, &quot;║&quot; ] if the number of chars
                                  are <A HREF="various.html#less">less</A> than eight, they will be repeated.
                                  Thus an ASCII border could be specified <A HREF="motion.html#as">as</A>:
                                  [ &quot;<A HREF="pattern.html#/">/</A>&quot;, &quot;<A HREF="motion.html#-">-</A>&quot;, &quot;\\&quot;, &quot;|&quot; ] or all chars the
                                  same <A HREF="motion.html#as">as</A>: [ &quot;<A HREF="change.html#x">x</A>&quot; ] An empty <A HREF="eval.html#string">string</A> can be used
                                  to turn off a specific border, for instance:
                                  [ &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;<A HREF="change.html#&gt;">&gt;</A>&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;<A HREF="change.html#&lt;">&lt;</A>&quot; ] will
                                  only make vertical borders but not
                                  horizontal ones. By default `FloatBorder`
                                  highlight is used which links to `VertSplit`
                                  when not defined. It could also be specified
                                  by character: [ {&quot;+&quot;, &quot;MyCorner&quot;}, {&quot;x&quot;,
                                  &quot;MyBorder&quot;} ]

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Window handle, or 0 on error


nvim_out_write({str})                                       *<A NAME="nvim_out_write()"></A><B>nvim_out_write()</B>*
                Writes a message to the Vim output buffer. Does not append
                &quot;\n&quot;, the message is buffered (won't display) until a <A HREF="intro.html#linefeed">linefeed</A>
                is written.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {str}  Message


                                                     *<A NAME="nvim_parse_expression()"></A><B>nvim_parse_expression()</B>*
nvim_parse_expression({expr}, {flags}, {highlight})
                Parse a VimL <A HREF="eval.html#expression">expression</A>.

<B><FONT color="#54A23D">                Attributes: </FONT></B>
                    {fast}

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {expr}       Expression to parse. Always treated <A HREF="motion.html#as">as</A> a
                                 single line.
                    {flags}      Flags:
                                 • &quot;<A HREF="motion.html#m">m</A>&quot; if multiple expressions in a row are
                                   allowed (only the first one will be
                                   parsed),
                                 • &quot;<A HREF="motion.html#E">E</A>&quot; if EOC tokens are not allowed
                                   (determines whether they will stop parsing
                                   process or be recognized <A HREF="motion.html#as">as</A> an
                                   operator/space, though also yielding an
                                   error).
                                 • &quot;<A HREF="motion.html#l">l</A>&quot; when needing to start parsing with
                                   lvalues for &quot;<A HREF="eval.html#:let">:let</A>&quot; or &quot;<A HREF="eval.html#:for">:for</A>&quot;. Common flag
                                   sets:
                                 • &quot;<A HREF="motion.html#m">m</A>&quot; to parse like for &quot;<A HREF="eval.html#:echo">:echo</A>&quot;.
                                 • &quot;<A HREF="motion.html#E">E</A>&quot; to parse like for &quot;&lt;C-r&gt;=&quot;.
                                 • empty <A HREF="eval.html#string">string</A> for &quot;<A HREF="eval.html#:call">:call</A>&quot;.
                                 • &quot;lm&quot; to parse for &quot;<A HREF="eval.html#:let">:let</A>&quot;.
                    {highlight}  If true, return value will also include
                                 &quot;highlight&quot; key containing array of 4-tuples
                                 (arrays) (Integer, Integer, Integer, String),
                                 where first three numbers define the
                                 highlighted region and represent line,
                                 starting column and ending column (latter
                                 <A HREF="motion.html#exclusive">exclusive</A>: one should highlight region
                                 [start_col, end_col)).

<B><FONT color="#54A23D">                Return: </FONT></B>

                    • AST: top-level dictionary with these keys:
                      • &quot;error&quot;: <A HREF="eval.html#Dictionary">Dictionary</A> with error, present only if parser
                        saw some error. Contains the following keys:
                        • &quot;message&quot;: <A HREF="eval.html#String">String</A>, error message in printf format,
                          translated. Must contain exactly one &quot;&#37;.*s&quot;.
                        • &quot;arg&quot;: <A HREF="eval.html#String">String</A>, error message argument.

                      • &quot;len&quot;: Amount of bytes successfully parsed. With flags
                        equal to &quot;&quot; that should be equal to the length of <A HREF="eval.html#expr">expr</A>
                        <A HREF="eval.html#string">string</A>. (“Sucessfully parsed” here means “participated
                        in AST creation”, not “till the first error”.)
                      • &quot;ast&quot;: AST, either nil or a dictionary with these
                        keys:
                        • &quot;type&quot;: node type, one of the value names from
                          ExprASTNodeType stringified without &quot;kExprNode&quot;
                          prefix.
                        • &quot;start&quot;: a pair [line, column] describing where node
                          is &quot;started&quot; where &quot;line&quot; is always 0 (will not be 0
                          if you will be using nvim_parse_viml() on e.g.
                          &quot;<A HREF="eval.html#:let">:let</A>&quot;, but that is not present yet). Both elements
                          are Integers.
                        • &quot;len&quot;: “length” of the node. This and &quot;start&quot; are
                          there for debugging purposes primary (debugging
                          parser and providing debug information).
                        • &quot;children&quot;: a <A HREF="eval.html#list">list</A> of nodes described in top/&quot;ast&quot;.
                          There always is zero, one or two children, key will
                          not be present if node has no children. Maximum
                          number of children may be found in node_maxchildren
                          array.

                    • Local values (present only for certain nodes):
                      • &quot;scope&quot;: a single Integer, specifies scope for
                        &quot;Option&quot; and &quot;PlainIdentifier&quot; nodes. For &quot;Option&quot; <A HREF="motion.html#it">it</A>
                        is one of ExprOptScope values, for &quot;PlainIdentifier&quot;
                        <A HREF="motion.html#it">it</A> is one of ExprVarScope values.
                      • &quot;ident&quot;: identifier (without scope, if any), present
                        for &quot;Option&quot;, &quot;PlainIdentifier&quot;, &quot;PlainKey&quot; and
                        &quot;Environment&quot; nodes.
                      • &quot;name&quot;: Integer, <A HREF="intro.html#register">register</A> name (one character) or -1.
                        Only present for &quot;Register&quot; nodes.
                      • &quot;cmp_type&quot;: <A HREF="eval.html#String">String</A>, comparison type, one of the value
                        names from ExprComparisonType, stringified without
                        &quot;kExprCmp&quot; prefix. Only present for &quot;Comparison&quot;
                        nodes.
                      • &quot;ccs_strategy&quot;: <A HREF="eval.html#String">String</A>, <A HREF="change.html#case">case</A> comparison strategy, one
                        of the value names from ExprCaseCompareStrategy,
                        stringified without &quot;kCCStrategy&quot; prefix. Only present
                        for &quot;Comparison&quot; nodes.
                      • &quot;augmentation&quot;: <A HREF="eval.html#String">String</A>, augmentation type for
                        &quot;Assignment&quot; nodes. Is either an empty <A HREF="eval.html#string">string</A>, &quot;Add&quot;,
                        &quot;Subtract&quot; or &quot;Concat&quot; for &quot;<A HREF="change.html#=">=</A>&quot;, &quot;+=&quot;, &quot;-=&quot; or &quot;.=&quot;
                        respectively.
                      • &quot;invert&quot;: <A HREF="eval.html#Boolean">Boolean</A>, true if result of comparison needs
                        to be inverted. Only present for &quot;Comparison&quot; nodes.
                      • &quot;ivalue&quot;: Integer, integer value for &quot;Integer&quot; nodes.
                      • &quot;fvalue&quot;: <A HREF="eval.html#Float">Float</A>, floating-point value for &quot;<A HREF="eval.html#Float">Float</A>&quot;
                        nodes.
                      • &quot;svalue&quot;: <A HREF="eval.html#String">String</A>, value for &quot;SingleQuotedString&quot; and
                        &quot;DoubleQuotedString&quot; nodes.


nvim_paste({data}, {crlf}, {phase})                             *<A NAME="nvim_paste()"></A><B>nvim_paste()</B>*
                Pastes at cursor, in any mode.

                Invokes the `vim.paste` handler, which handles each mode
                appropriately. Sets redo/undo. Faster than |<A HREF="#nvim_input()">nvim_input()</A>|.
                Lines break at LF (&quot;\n&quot;).

                Errors ('nomodifiable', `vim.paste()` failure, …) are
                reflected in `err` but <A HREF="diff.html#do">do</A> not affect the return value (which
                is strictly decided by `vim.paste()` ). On error, subsequent
                calls are ignored (&quot;drained&quot;) until the next <A HREF="provider.html#paste">paste</A> is
                initiated (phase 1 or -1).

<B><FONT color="#54A23D">                Attributes: </FONT></B>
                    not allowed when |<A HREF="eval.html#textlock">textlock</A>| is active

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {data}   Multiline input. May be binary (containing NUL
                             bytes).
                    {crlf}   Also break lines at CR and CRLF.
                    {phase}  -1: <A HREF="provider.html#paste">paste</A> in a single call (i.e. without
                             streaming). To &quot;stream&quot; a <A HREF="provider.html#paste">paste</A>, call `nvim_paste` sequentially with these `phase` values:
                             • 1: starts the <A HREF="provider.html#paste">paste</A> (exactly once)
                             • 2: continues the <A HREF="provider.html#paste">paste</A> (zero or more times)
                             • 3: ends the <A HREF="provider.html#paste">paste</A> (exactly once)

<B><FONT color="#54A23D">                Return: </FONT></B>

                    • true: Client may continue pasting.
                    • false: Client must cancel the <A HREF="provider.html#paste">paste</A>.


nvim_put({lines}, {type}, {after}, {follow})                      *<A NAME="nvim_put()"></A><B>nvim_put()</B>*
                Puts text at cursor, in any mode.

                Compare |<A HREF="change.html#:put">:put</A>| and |<A HREF="change.html#p">p</A>| which are always <A HREF="motion.html#linewise">linewise</A>.

<B><FONT color="#54A23D">                Attributes: </FONT></B>
                    not allowed when |<A HREF="eval.html#textlock">textlock</A>| is active

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {lines}   |readfile()|-style <A HREF="eval.html#list">list</A> of lines.
                              |<A HREF="channel.html#channel-lines">channel-lines</A>|
                    {type}    Edit behavior: any |<A HREF="eval.html#getregtype()">getregtype()</A>| result, or:
                              • &quot;b&quot; |<A HREF="visual.html#blockwise-visual">blockwise-visual</A>| mode (may include
                                width, e.g. &quot;b3&quot;)
                              • &quot;c&quot; |<A HREF="motion.html#charwise">charwise</A>| mode
                              • &quot;l&quot; |<A HREF="motion.html#linewise">linewise</A>| mode
                              • &quot;&quot; guess by contents, see |<A HREF="eval.html#setreg()">setreg()</A>|
                    {after}   If true insert after cursor (like |<A HREF="change.html#p">p</A>|), or
                              before (like |<A HREF="change.html#P">P</A>|).
                    {follow}  If true place cursor at end of inserted text.


                                                    *<A NAME="nvim_replace_termcodes()"></A><B>nvim_replace_termcodes()</B>*
nvim_replace_termcodes({str}, {from_part}, {do_lt}, {special})
                Replaces <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> codes and |<A HREF="intro.html#keycodes">keycodes</A>| (&lt;CR&gt;, <A HREF="intro.html#&lt;Esc&gt;">&lt;Esc&gt;</A>, <A HREF="eval.html#...">...</A>) in a
                <A HREF="eval.html#string">string</A> with the internal representation.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {str}        <A HREF="eval.html#String">String</A> to be converted.
                    {from_part}  Legacy Vim parameter. Usually true.
                    {do_lt}      Also translate <A HREF="intro.html#&lt;lt&gt;">&lt;lt&gt;</A>. Ignored if `special` is
                                 false.
                    {special}    <A HREF="insert.html#Replace">Replace</A> |<A HREF="intro.html#keycodes">keycodes</A>|, e.g. <A HREF="motion.html#&lt;CR&gt;">&lt;CR&gt;</A> becomes a &quot;\n&quot;
                                 char.

<B><FONT color="#54A23D">                See also: </FONT></B>
                    replace_termcodes
                    cpoptions


                                                *<A NAME="nvim_select_popupmenu_item()"></A><B>nvim_select_popupmenu_item()</B>*
nvim_select_popupmenu_item({item}, {insert}, {finish}, {opts})
                Selects an item in the completion popupmenu.

                If |<A HREF="insert.html#ins-completion">ins-completion</A>| is not active this <A HREF="#API">API</A> call is silently
                ignored. Useful for an external <A HREF="ui.html#UI">UI</A> using |<A HREF="ui.html#ui-popupmenu">ui-popupmenu</A>| to
                <A HREF="intro.html#control">control</A> the popupmenu with the mouse. Can also be used in a
                <A HREF="map.html#mapping">mapping</A>; use &lt;cmd&gt; |<A HREF="map.html#:map-cmd">:map-cmd</A>| to ensure the <A HREF="map.html#mapping">mapping</A> doesn't
                end completion mode.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {item}    Index (zero-based) of the item to select. Value
                              of -1 selects nothing and restores the original
                              text.
                    {insert}  Whether the selection should be inserted in the
                              buffer.
                    {finish}  Finish the completion and dismiss the popupmenu.
                              Implies `insert` .
                    {opts}    Optional parameters. Reserved for future use.


                                                      *<A NAME="nvim_set_client_info()"></A><B>nvim_set_client_info()</B>*
nvim_set_client_info({name}, {version}, {type}, {methods}, {attributes})
                Self-identifies the client.

                The client/plugin/application should call this after
                connecting, to provide hints about its identity and purpose,
                for debugging and orchestration.

                Can be called more than once; the caller should <A HREF="diff.html#merge">merge</A> old info
                if appropriate. Example: library first identifies the <A HREF="channel.html#channel">channel</A>,
                then a <A HREF="usr_05.html#plugin">plugin</A> using that library later identifies itself.

                Note:
                    &quot;Something is better than nothing&quot;. You don't need to
                    include all the fields.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {name}        Short name for the connected client
                    {version}     <A HREF="eval.html#Dictionary">Dictionary</A> describing the version, with
                                  these (optional) keys:
                                  • &quot;major&quot; major version (defaults to 0 if
                                    not set, for no release yet)
                                  • &quot;minor&quot; minor version
                                  • &quot;patch&quot; patch number
                                  • &quot;prerelease&quot; <A HREF="eval.html#string">string</A> describing a
                                    prerelease, like &quot;<A HREF="develop.html#dev">dev</A>&quot; or &quot;beta1&quot;
                                  • &quot;commit&quot; hash or similar identifier of
                                    commit
                    {type}        Must be one of the following values. Client
                                  libraries should default to &quot;remote&quot; unless
                                  overridden by the user.
                                  • &quot;remote&quot; remote client connected to Nvim.
                                  • &quot;<A HREF="ui.html#ui">ui</A>&quot; <A HREF="gui.html#gui">gui</A> frontend
                                  • &quot;embedder&quot; application using Nvim <A HREF="motion.html#as">as</A> a
                                    component (for example, IDE/editor
                                    implementing a vim mode).
                                  • &quot;host&quot; <A HREF="usr_05.html#plugin">plugin</A> host, typically started by
                                    <A HREF="nvim.html#nvim">nvim</A>
                                  • &quot;<A HREF="usr_05.html#plugin">plugin</A>&quot; single <A HREF="usr_05.html#plugin">plugin</A>, started by <A HREF="nvim.html#nvim">nvim</A>
                    {methods}     Builtin methods in the client. For a host,
                                  this does not include <A HREF="usr_05.html#plugin">plugin</A> methods which
                                  will be discovered later. The key should be
                                  the method name, the values are dicts with
                                  these (optional) keys (more keys may be
                                  added in future versions of Nvim, thus
                                  unknown keys are ignored. Clients must only
                                  use keys defined in this or later versions
                                  of Nvim):
                                  • &quot;async&quot; if true, send <A HREF="motion.html#as">as</A> a notification.
                                    If false or unspecified, use a blocking
                                    request
                                  • &quot;nargs&quot; <A HREF="eval.html#Number">Number</A> of arguments. Could be a
                                    single integer or an array of two
                                    integers, minimum and maximum <A HREF="motion.html#inclusive">inclusive</A>.
                    {attributes}  Arbitrary string:string map of informal
                                  client properties. Suggested keys:
                                  • &quot;website&quot;: Client homepage URL (e.g.
                                    GitHub repository)
                                  • &quot;<A HREF="uganda.html#license">license</A>&quot;: License description (&quot;Apache
                                    2&quot;, &quot;GPLv3&quot;, &quot;MIT&quot;, …)
                                  • &quot;logo&quot;: URI or path to image, preferably
                                    small logo or icon. .png or .svg format is
                                    preferred.


nvim_set_current_buf({buffer})                        *<A NAME="nvim_set_current_buf()"></A><B>nvim_set_current_buf()</B>*
                Sets the current buffer.

<B><FONT color="#54A23D">                Attributes: </FONT></B>
                    not allowed when |<A HREF="eval.html#textlock">textlock</A>| is active

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}  Buffer handle


nvim_set_current_dir({dir})                           *<A NAME="nvim_set_current_dir()"></A><B>nvim_set_current_dir()</B>*
                Changes the global working directory.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {dir}  Directory path


nvim_set_current_line({line})                        *<A NAME="nvim_set_current_line()"></A><B>nvim_set_current_line()</B>*
                Sets the current line.

<B><FONT color="#54A23D">                Attributes: </FONT></B>
                    not allowed when |<A HREF="eval.html#textlock">textlock</A>| is active

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {line}  Line contents


nvim_set_current_tabpage({tabpage})               *<A NAME="nvim_set_current_tabpage()"></A><B>nvim_set_current_tabpage()</B>*
                Sets the current <A HREF="tabpage.html#tabpage">tabpage</A>.

<B><FONT color="#54A23D">                Attributes: </FONT></B>
                    not allowed when |<A HREF="eval.html#textlock">textlock</A>| is active

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {tabpage}  Tabpage handle


nvim_set_current_win({window})                        *<A NAME="nvim_set_current_win()"></A><B>nvim_set_current_win()</B>*
                Sets the current <A HREF="windows.html#window">window</A>.

<B><FONT color="#54A23D">                Attributes: </FONT></B>
                    not allowed when |<A HREF="eval.html#textlock">textlock</A>| is active

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {window}  Window handle


                                              *<A NAME="nvim_set_decoration_provider()"></A><B>nvim_set_decoration_provider()</B>*
nvim_set_decoration_provider({ns_id}, {opts})
                Set or change decoration <A HREF="provider.html#provider">provider</A> for a namespace

                This is a very general purpose interface for having <A HREF="lua.html#lua">lua</A>
                callbacks being triggered during the redraw code.

                The expected usage is to set extmarks for the currently
                redrawn buffer. |<A HREF="intro.html#nvim_buf_set_extmark">nvim_buf_set_extmark</A>| can be called to add
                marks on a per-window or per-lines basis. Use the `ephemeral`
                key to only use the <A HREF="motion.html#mark">mark</A> for the current screen redraw (the
                callback will be called again for the next redraw ).

                Note: this function should not be called often. Rather, the
                callbacks themselves can be used to throttle unneeded
                callbacks. the `on_start` callback can return `false` to
                disable the <A HREF="provider.html#provider">provider</A> until the next redraw. Similarily, return
                `false` in `on_win` will skip the `on_lines` calls for that
                <A HREF="windows.html#window">window</A> (but any extmarks set in `on_win` will still be used).
                A <A HREF="usr_05.html#plugin">plugin</A> managing multiple sources of decoration should
                ideally only set one <A HREF="provider.html#provider">provider</A>, and <A HREF="diff.html#merge">merge</A> the sources
                internally. You can use multiple `ns_id` for the extmarks
                set/modified inside the callback anyway.

                Note: doing anything other than setting extmarks is considered
                experimental. Doing things like <A HREF="change.html#changing">changing</A> <A HREF="options.html#options">options</A> are not
                expliticly forbidden, but is likely to have unexpected
                consequences (such <A HREF="motion.html#as">as</A> 100&#37; CPU consumption). doing
                `vim.rpcnotify` should be OK, but `vim.rpcrequest` is quite
                dubious for the moment.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {ns_id}  Namespace id from |<A HREF="#nvim_create_namespace()">nvim_create_namespace()</A>|
                    {opts}   Callbacks invoked during redraw:
                             • on_start: called first on each screen redraw
                               [&quot;start&quot;, tick]
                             • on_buf: called for each buffer being redrawn
                               (before <A HREF="windows.html#window">window</A> callbacks) [&quot;buf&quot;, bufnr, tick]
                             • on_win: called when starting to redraw a
                               specific <A HREF="windows.html#window">window</A>. [&quot;win&quot;, <A HREF="windows.html#winid">winid</A>, bufnr, topline,
                               botline_guess]
                             • on_line: called for each buffer line being
                               redrawn. (The interation with fold lines is
                               subject to change) [&quot;win&quot;, <A HREF="windows.html#winid">winid</A>, bufnr, row]
                             • on_end: called at the end of a redraw cycle
                               [&quot;end&quot;, tick]


nvim_set_hl({ns_id}, {name}, {val})                            *<A NAME="nvim_set_hl()"></A><B>nvim_set_hl()</B>*
                Set a highlight group.

                TODO: ns_id = 0, should modify <A HREF="syntax.html#:highlight">:highlight</A> namespace TODO val
                should take update vs reset flag

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {ns_id}  number of namespace for this highlight
                    {name}   highlight group name, like ErrorMsg
                    {val}    highlight definiton map, like
                             |<A HREF="intro.html#nvim_get_hl_by_name">nvim_get_hl_by_name</A>|. in addition the following
                             keys are also recognized: `default` : don't
                             override existing definition, like `hi default`


nvim_set_keymap({mode}, <A HREF="map.html#{lhs}">{lhs}</A>, <A HREF="map.html#{rhs}">{rhs}</A>, {opts})              *<A NAME="nvim_set_keymap()"></A><B>nvim_set_keymap()</B>*
                Sets a global |<A HREF="map.html#mapping">mapping</A>| for the given mode.

                To set a buffer-local <A HREF="map.html#mapping">mapping</A>, use |<A HREF="#nvim_buf_set_keymap()">nvim_buf_set_keymap()</A>|.

                Unlike |<A HREF="map.html#:map">:map</A>|, leading/trailing <A HREF="pattern.html#whitespace">whitespace</A> is accepted <A HREF="motion.html#as">as</A> part
                of the <A HREF="map.html#{lhs}">{lhs}</A> or <A HREF="map.html#{rhs}">{rhs}</A>. Empty <A HREF="map.html#{rhs}">{rhs}</A> is |<A HREF="intro.html#&lt;Nop&gt;">&lt;Nop&gt;</A>|. |<A HREF="intro.html#keycodes">keycodes</A>| are
                replaced <A HREF="motion.html#as">as</A> usual.

                Example:
<B>                    call nvim_set_keymap('n', ' &lt;NL&gt;', '', {'nowait': v:true})</B>
 

                is equivalent to:
<B>                    nmap &lt;nowait&gt; &lt;Space&gt;&lt;NL&gt; &lt;Nop&gt;</B>
 

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {mode}  Mode short-name (map command prefix: &quot;<A HREF="pattern.html#n">n</A>&quot;, &quot;<A HREF="insert.html#i">i</A>&quot;,
                            &quot;<A HREF="visual.html#v">v</A>&quot;, &quot;<A HREF="change.html#x">x</A>&quot;, …) or &quot;!&quot; for |<A HREF="map.html#:map!">:map!</A>|, or empty <A HREF="eval.html#string">string</A>
                            for |<A HREF="map.html#:map">:map</A>|.
                    {lhs}   Left-hand-side |<A HREF="map.html#{lhs}">{lhs}</A>| of the <A HREF="map.html#mapping">mapping</A>.
                    {rhs}   Right-hand-side |<A HREF="map.html#{rhs}">{rhs}</A>| of the <A HREF="map.html#mapping">mapping</A>.
                    {opts}  Optional parameters map. Accepts all
                            |<A HREF="map.html#:map-arguments">:map-arguments</A>| <A HREF="motion.html#as">as</A> keys excluding |<A HREF="intro.html#&lt;buffer&gt;">&lt;buffer&gt;</A>| but
                            including |<A HREF="intro.html#noremap">noremap</A>|. Values are Booleans. Unknown
                            key is an error.


nvim_set_option({name}, {value})                           *<A NAME="nvim_set_option()"></A><B>nvim_set_option()</B>*
                Sets an option value.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {name}   Option name
                    {value}  New option value


nvim_set_var({name}, {value})                                 *<A NAME="nvim_set_var()"></A><B>nvim_set_var()</B>*
                Sets a global (g:) variable.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {name}   Variable name
                    {value}  Variable value


nvim_set_vvar({name}, {value})                               *<A NAME="nvim_set_vvar()"></A><B>nvim_set_vvar()</B>*
                Sets a <A HREF="eval.html#v:">v:</A> variable, if <A HREF="motion.html#it">it</A> is not readonly.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {name}   Variable name
                    {value}  Variable value


nvim_strwidth({text})                                        *<A NAME="nvim_strwidth()"></A><B>nvim_strwidth()</B>*
                Calculates the number of display cells occupied by `text` .
                <A HREF="motion.html#&lt;Tab&gt;">&lt;Tab&gt;</A> counts <A HREF="motion.html#as">as</A> one cell.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {text}  Some text

<B><FONT color="#54A23D">                Return: </FONT></B>
                    <A HREF="eval.html#Number">Number</A> of cells


nvim_subscribe({event})                                     *<A NAME="nvim_subscribe()"></A><B>nvim_subscribe()</B>*
                Subscribes to event broadcasts.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    <A HREF="autocmd.html#{event}">{event}</A>  Event type <A HREF="eval.html#string">string</A>


nvim_unsubscribe({event})                                 *<A NAME="nvim_unsubscribe()"></A><B>nvim_unsubscribe()</B>*
                Unsubscribes to event broadcasts.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    <A HREF="autocmd.html#{event}">{event}</A>  Event type <A HREF="eval.html#string">string</A>


==============================================================================

Buffer Functions                                                  *<A NAME="api-buffer"></A><B>api-buffer</B>*


For more information on buffers, see |<A HREF="windows.html#buffers">buffers</A>|.

<B><FONT color="#54A23D">Unloaded Buffers:</FONT></B>

Buffers may be unloaded by the |<A HREF="windows.html#:bunload">:bunload</A>| command or the
buffer's |<A HREF="options.html#'bufhidden'">'bufhidden'</A>| option. When a buffer is unloaded its
file contents are freed from memory and vim cannot operate on
the buffer lines until <A HREF="motion.html#it">it</A> is reloaded (usually by opening the
buffer again in a new <A HREF="windows.html#window">window</A>). <A HREF="#API">API</A> methods such <A HREF="motion.html#as">as</A>
|<A HREF="#nvim_buf_get_lines()">nvim_buf_get_lines()</A>| and |<A HREF="#nvim_buf_line_count()">nvim_buf_line_count()</A>| will be
affected.

You can use |<A HREF="#nvim_buf_is_loaded()">nvim_buf_is_loaded()</A>| or |<A HREF="#nvim_buf_line_count()">nvim_buf_line_count()</A>|
to check whether a buffer is loaded.


                                                    *<A NAME="nvim__buf_redraw_range()"></A><B>nvim__buf_redraw_range()</B>*
nvim__buf_redraw_range({buffer}, {first}, {last})
                TODO: Documentation


nvim__buf_stats({buffer})                                  *<A NAME="nvim__buf_stats()"></A><B>nvim__buf_stats()</B>*
                TODO: Documentation


                                                    *<A NAME="nvim_buf_add_highlight()"></A><B>nvim_buf_add_highlight()</B>*
nvim_buf_add_highlight({buffer}, {ns_id}, {hl_group}, {line}, {col_start},
                       {col_end})
                Adds a highlight to buffer.

                Useful for plugins that dynamically generate highlights to a
                buffer (like a semantic highlighter or linter). The function
                adds a single highlight to a buffer. Unlike |<A HREF="eval.html#matchaddpos()">matchaddpos()</A>|
                highlights follow changes to line numbering (as lines are
                inserted/removed above the highlighted line), like <A HREF="sign.html#signs">signs</A> and
                marks <A HREF="diff.html#do">do</A>.

                Namespaces are used for batch deletion/updating of a set of
                highlights. To create a namespace, use
                |<A HREF="#nvim_create_namespace()">nvim_create_namespace()</A>| which returns a namespace id. Pass
                <A HREF="motion.html#it">it</A> in to this function <A HREF="motion.html#as">as</A> `ns_id` to add highlights to the
                namespace. All highlights in the same namespace can then be
                cleared with single call to |<A HREF="#nvim_buf_clear_namespace()">nvim_buf_clear_namespace()</A>|. If
                the highlight never will be deleted by an <A HREF="#API">API</A> call, pass
                `ns_id = -1` .

                As a shorthand, `ns_id = 0` can be used to create a new
                namespace for the highlight, the allocated id is then
                returned. If `hl_group` is the empty <A HREF="eval.html#string">string</A> no highlight is
                added, but a new `ns_id` is still returned. This is supported
                for backwards compatibility, new code should use
                |<A HREF="#nvim_create_namespace()">nvim_create_namespace()</A>| to create a new empty namespace.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}     Buffer handle, or 0 for current buffer
                    {ns_id}      namespace to use or -1 for ungrouped
                                 highlight
                    {hl_group}   Name of the highlight group to use
                    {line}       Line to highlight (zero-indexed)
                    {col_start}  Start of (byte-indexed) column range to
                                 highlight
                    {col_end}    End of (byte-indexed) column range to
                                 highlight, or -1 to highlight to end of line

<B><FONT color="#54A23D">                Return: </FONT></B>
                    The ns_id that was used


nvim_buf_attach({buffer}, {send_buffer}, {opts})           *<A NAME="nvim_buf_attach()"></A><B>nvim_buf_attach()</B>*
                Activates buffer-update <A HREF="autocmd.html#events">events</A> on a <A HREF="channel.html#channel">channel</A>, or <A HREF="motion.html#as">as</A> <A HREF="lua.html#Lua">Lua</A>
                callbacks.

                Example (Lua): capture buffer updates in a global `events` variable (use &quot;print(vim.inspect(events))&quot; to see its
                contents):
<B>                  events = {}</B>
<B>                  vim.api.nvim_buf_attach(0, false, {</B>
<B>                    on_lines=function(...) table.insert(events, {...}) end})</B>
 

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}       Buffer handle, or 0 for current buffer
                    {send_buffer}  True if the initial notification should
                                   contain the whole buffer: first
                                   notification will be `nvim_buf_lines_event`
                                   . Else the first notification will be
                                   `nvim_buf_changedtick_event` . Not for <A HREF="lua.html#Lua">Lua</A>
                                   callbacks.
                    {opts}         Optional parameters.
                                   • on_lines: <A HREF="lua.html#Lua">Lua</A> callback invoked on change.
                                     Return`true`to detach. Args:
                                     • the <A HREF="eval.html#string">string</A> &quot;lines&quot;
                                     • buffer handle
                                     • <A HREF="eval.html#b:changedtick">b:changedtick</A>
                                     • first line that changed (zero-indexed)
                                     • last line that was changed
                                     • last line in the updated range
                                     • byte <A HREF="intro.html#count">count</A> of previous contents
                                     • deleted_codepoints (if `utf_sizes` is
                                       true)
                                     • deleted_codeunits (if `utf_sizes` is
                                       true)

                                   • on_bytes: <A HREF="lua.html#lua">lua</A> callback invoked on change.
                                     This callback receives more granular
                                     information about the change compared to
                                     on_lines. Return`true`to detach. Args:
                                     • the <A HREF="eval.html#string">string</A> &quot;bytes&quot;
                                     • buffer handle
                                     • <A HREF="eval.html#b:changedtick">b:changedtick</A>
                                     • start row of the changed text
                                       (zero-indexed)
                                     • start column of the changed text
                                     • byte offset of the changed text (from
                                       the start of the buffer)
                                     • old end row of the changed text
                                     • old end column of the changed text
                                     • old end byte length of the changed text
                                     • new end row of the changed text
                                     • new end column of the changed text
                                     • new end byte length of the changed text

                                   • on_changedtick: <A HREF="lua.html#Lua">Lua</A> callback invoked on
                                     changedtick increment without text
                                     change. Args:
                                     • the <A HREF="eval.html#string">string</A> &quot;changedtick&quot;
                                     • buffer handle
                                     • <A HREF="eval.html#b:changedtick">b:changedtick</A>

                                   • on_detach: <A HREF="lua.html#Lua">Lua</A> callback invoked on
                                     detach. Args:
                                     • the <A HREF="eval.html#string">string</A> &quot;detach&quot;
                                     • buffer handle

                                   • on_reload: <A HREF="lua.html#Lua">Lua</A> callback invoked on
                                     <A HREF="editing.html#reload">reload</A>. The entire buffer content should
                                     be considered changed. Args:
                                     • the <A HREF="eval.html#string">string</A> &quot;detach&quot;
                                     • buffer handle

                                   • utf_sizes: include UTF-32 and UTF-16 size
                                     of the replaced region, <A HREF="motion.html#as">as</A> args to
                                     `on_lines` .
                                   • preview: also attach to command preview
                                     (i.e. <A HREF="options.html#'inccommand'">'inccommand'</A>) <A HREF="autocmd.html#events">events</A>.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    False if attach failed (invalid parameter, or buffer isn't
                    loaded); otherwise True. TODO: LUA_API_NO_EVAL

<B><FONT color="#54A23D">                See also: </FONT></B>
                    |<A HREF="#nvim_buf_detach()">nvim_buf_detach()</A>|
                    |<A HREF="#api-buffer-updates-lua">api-buffer-updates-lua</A>|


nvim_buf_call({buffer}, {fun})                               *<A NAME="nvim_buf_call()"></A><B>nvim_buf_call()</B>*
                call a function with buffer <A HREF="motion.html#as">as</A> temporary current buffer

                This temporarily switches current buffer to &quot;buffer&quot;. If the
                current <A HREF="windows.html#window">window</A> already shows &quot;buffer&quot;, the <A HREF="windows.html#window">window</A> is not
                switched If a <A HREF="windows.html#window">window</A> inside the current <A HREF="tabpage.html#tabpage">tabpage</A> (including a
                float) already shows the buffer One of these <A HREF="windows.html#windows">windows</A> will be
                set <A HREF="motion.html#as">as</A> current <A HREF="windows.html#window">window</A> temporarily. Otherwise a temporary
                scratch <A HREF="windows.html#window">window</A> (calleed the &quot;<A HREF="autocmd.html#autocmd">autocmd</A> window&quot; for historical
                reasons) will be used.

                This is useful e.g. to call vimL <A HREF="eval.html#functions">functions</A> that only work with
                the current buffer/window currently, like |<A HREF="eval.html#termopen()">termopen()</A>|.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}  Buffer handle, or 0 for current buffer
                    {fun}     Function to call inside the buffer (currently
                              <A HREF="lua.html#lua">lua</A> callable only)

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Return value of function. NB: will deepcopy <A HREF="lua.html#lua">lua</A> values
                    currently, use upvalues to send <A HREF="lua.html#lua">lua</A> references in and out.


                                                  *<A NAME="nvim_buf_clear_namespace()"></A><B>nvim_buf_clear_namespace()</B>*
nvim_buf_clear_namespace({buffer}, {ns_id}, {line_start}, {line_end})
                Clears namespaced <A HREF="vimindex.html#objects">objects</A> (highlights, extmarks, virtual text)
                from a region.

                Lines are 0-indexed. |<A HREF="#api-indexing">api-indexing</A>| To clear the namespace in
                the entire buffer, specify line_start=0 and line_end=-1.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}      Buffer handle, or 0 for current buffer
                    {ns_id}       Namespace to clear, or -1 to clear all
                                  namespaces.
                    {line_start}  Start of range of lines to clear
                    {line_end}    End of range of lines to clear (exclusive)
                                  or -1 to clear to end of buffer.


nvim_buf_del_extmark({buffer}, {ns_id}, {id})         *<A NAME="nvim_buf_del_extmark()"></A><B>nvim_buf_del_extmark()</B>*
                Removes an extmark.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}  Buffer handle, or 0 for current buffer
                    {ns_id}   Namespace id from |<A HREF="#nvim_create_namespace()">nvim_create_namespace()</A>|
                    {id}      Extmark id

<B><FONT color="#54A23D">                Return: </FONT></B>
                    true if the extmark was found, else false


nvim_buf_del_keymap({buffer}, {mode}, <A HREF="map.html#{lhs}">{lhs}</A>)           *<A NAME="nvim_buf_del_keymap()"></A><B>nvim_buf_del_keymap()</B>*
                Unmaps a buffer-local |<A HREF="map.html#mapping">mapping</A>| for the given mode.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}  Buffer handle, or 0 for current buffer

<B><FONT color="#54A23D">                See also: </FONT></B>
                    |<A HREF="#nvim_del_keymap()">nvim_del_keymap()</A>|


nvim_buf_del_var({buffer}, {name})                        *<A NAME="nvim_buf_del_var()"></A><B>nvim_buf_del_var()</B>*
                Removes a buffer-scoped (b:) variable

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}  Buffer handle, or 0 for current buffer
                    {name}    Variable name


nvim_buf_delete({buffer}, {opts})                          *<A NAME="nvim_buf_delete()"></A><B>nvim_buf_delete()</B>*
                Deletes the buffer. See |<A HREF="windows.html#:bwipeout">:bwipeout</A>|

<B><FONT color="#54A23D">                Attributes: </FONT></B>
                    not allowed when |<A HREF="eval.html#textlock">textlock</A>| is active

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}  Buffer handle, or 0 for current buffer
                    {opts}    Optional parameters. Keys:
                              • force: Force deletion and ignore unsaved
                                changes.
                              • unload: Unloaded only, <A HREF="diff.html#do">do</A> not delete. See
                                |<A HREF="windows.html#:bunload">:bunload</A>|


nvim_buf_detach({buffer})                                  *<A NAME="nvim_buf_detach()"></A><B>nvim_buf_detach()</B>*
                Deactivates buffer-update <A HREF="autocmd.html#events">events</A> on the <A HREF="channel.html#channel">channel</A>.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}  Buffer handle, or 0 for current buffer

<B><FONT color="#54A23D">                Return: </FONT></B>
                    False if detach failed (because the buffer isn't loaded);
                    otherwise True.

<B><FONT color="#54A23D">                See also: </FONT></B>
                    |<A HREF="#nvim_buf_attach()">nvim_buf_attach()</A>|
                    |<A HREF="#api-lua-detach">api-lua-detach</A>| for detaching <A HREF="lua.html#Lua">Lua</A> callbacks


nvim_buf_get_changedtick({buffer})                *<A NAME="nvim_buf_get_changedtick()"></A><B>nvim_buf_get_changedtick()</B>*
                Gets a changed tick of a buffer

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}  Buffer handle, or 0 for current buffer

<B><FONT color="#54A23D">                Return: </FONT></B>
                    `b:changedtick` value.


nvim_buf_get_commands({buffer}, {opts})              *<A NAME="nvim_buf_get_commands()"></A><B>nvim_buf_get_commands()</B>*
                Gets a map of buffer-local |<A HREF="map.html#user-commands">user-commands</A>|.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}  Buffer handle, or 0 for current buffer
                    {opts}    Optional parameters. Currently not used.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Map of maps describing commands.


                                                *<A NAME="nvim_buf_get_extmark_by_id()"></A><B>nvim_buf_get_extmark_by_id()</B>*
nvim_buf_get_extmark_by_id({buffer}, {ns_id}, {id}, {opts})
                Returns position for a given extmark id

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}  Buffer handle, or 0 for current buffer
                    {ns_id}   Namespace id from |<A HREF="#nvim_create_namespace()">nvim_create_namespace()</A>|
                    {id}      Extmark id
                    {opts}    Optional parameters. Keys:
                              • details: Whether to include the details <A HREF="eval.html#dict">dict</A>

<B><FONT color="#54A23D">                Return: </FONT></B>
                    (row, col) tuple or empty <A HREF="eval.html#list">list</A> () if extmark id was absent


                                                     *<A NAME="nvim_buf_get_extmarks()"></A><B>nvim_buf_get_extmarks()</B>*
nvim_buf_get_extmarks({buffer}, {ns_id}, {start}, {end}, {opts})
                Gets extmarks in &quot;traversal order&quot; from a |<A HREF="motion.html#charwise">charwise</A>| region
                defined by buffer positions (inclusive, 0-indexed
                |<A HREF="#api-indexing">api-indexing</A>|).

                Region can be given <A HREF="motion.html#as">as</A> (row,col) tuples, or valid extmark ids
                (whose positions define the bounds). 0 and -1 are understood
                <A HREF="motion.html#as">as</A> (0,0) and (-1,-1) respectively, thus the following are
                equivalent:

<B>    nvim_buf_get_extmarks(0, my_ns, 0, -1, {})</B>
<B>    nvim_buf_get_extmarks(0, my_ns, [0,0], [-1,-1], {})</B>
 

                If `end` is <A HREF="various.html#less">less</A> than `start` , traversal works backwards.
                (Useful with `limit` , to get the first marks prior to a given
                position.)

                Example:

<B>    local a   = vim.api</B>
<B>    local pos = a.nvim_win_get_cursor(0)</B>
<B>    local ns  = a.nvim_create_namespace('my-plugin')</B>
<B>    -- Create new extmark at line 1, column 1.</B>
<B>    local m1  = a.nvim_buf_set_extmark(0, ns, 0, 0, 0, {})</B>
<B>    -- Create new extmark at line 3, column 1.</B>
<B>    local m2  = a.nvim_buf_set_extmark(0, ns, 0, 2, 0, {})</B>
<B>    -- Get extmarks only from line 3.</B>
<B>    local ms  = a.nvim_buf_get_extmarks(0, ns, {2,0}, {2,0}, {})</B>
<B>    -- Get all marks in this buffer + namespace.</B>
<B>    local all = a.nvim_buf_get_extmarks(0, ns, 0, -1, {})</B>
<B>    print(vim.inspect(ms))</B>
 

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}  Buffer handle, or 0 for current buffer
                    {ns_id}   Namespace id from |<A HREF="#nvim_create_namespace()">nvim_create_namespace()</A>|
                    {start}   Start of range, given <A HREF="motion.html#as">as</A> (row, col) or valid
                              extmark id (whose position defines the bound)
                    {end}     End of range, given <A HREF="motion.html#as">as</A> (row, col) or valid
                              extmark id (whose position defines the bound)
                    {opts}    Optional parameters. Keys:
                              • limit: Maximum number of marks to return
                              • details Whether to include the details <A HREF="eval.html#dict">dict</A>

<B><FONT color="#54A23D">                Return: </FONT></B>
                    <A HREF="eval.html#List">List</A> of [extmark_id, row, col] tuples in &quot;traversal
                    order&quot;.


nvim_buf_get_keymap({buffer}, {mode})                  *<A NAME="nvim_buf_get_keymap()"></A><B>nvim_buf_get_keymap()</B>*
                Gets a <A HREF="eval.html#list">list</A> of buffer-local |<A HREF="map.html#mapping">mapping</A>| <A HREF="intro.html#definitions">definitions</A>.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {mode}    Mode short-name (&quot;n&quot;, &quot;<A HREF="insert.html#i">i</A>&quot;, &quot;<A HREF="visual.html#v">v</A>&quot;, <A HREF="eval.html#...">...</A>)
                    {buffer}  Buffer handle, or 0 for current buffer

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Array of maparg()-like dictionaries describing mappings.
                    The &quot;buffer&quot; key holds the associated buffer handle.


                                                        *<A NAME="nvim_buf_get_lines()"></A><B>nvim_buf_get_lines()</B>*
nvim_buf_get_lines({buffer}, {start}, {end}, {strict_indexing})
                Gets a line-range from the buffer.

                Indexing is zero-based, end-exclusive. Negative indices are
                interpreted <A HREF="motion.html#as">as</A> length+1+index: -1 refers to the index past the
                end. So to get the last element use start=-2 and end=-1.

                Out-of-bounds indices are clamped to the nearest valid value,
                unless `strict_indexing` is set.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}           Buffer handle, or 0 for current buffer
                    {start}            First line index
                    {end}              Last line index (exclusive)
                    {strict_indexing}  Whether out-of-bounds should be an
                                       error.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Array of lines, or empty array for unloaded buffer.


nvim_buf_get_mark({buffer}, {name})                      *<A NAME="nvim_buf_get_mark()"></A><B>nvim_buf_get_mark()</B>*
                Return a tuple (row,col) representing the position of the
                named <A HREF="motion.html#mark">mark</A>.

                Marks are (1,0)-indexed. |<A HREF="#api-indexing">api-indexing</A>|

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}  Buffer handle, or 0 for current buffer
                    {name}    <A HREF="motion.html#Mark">Mark</A> name

<B><FONT color="#54A23D">                Return: </FONT></B>
                    (row, col) tuple


nvim_buf_get_name({buffer})                              *<A NAME="nvim_buf_get_name()"></A><B>nvim_buf_get_name()</B>*
                Gets the full file name for the buffer

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}  Buffer handle, or 0 for current buffer

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Buffer name


nvim_buf_get_offset({buffer}, {index})                 *<A NAME="nvim_buf_get_offset()"></A><B>nvim_buf_get_offset()</B>*
                Returns the byte offset of a line (0-indexed). |<A HREF="#api-indexing">api-indexing</A>|

                Line 1 (index=0) has offset 0. <A HREF="mbyte.html#UTF-8">UTF-8</A> bytes are counted. EOL is
                one byte. <A HREF="options.html#'fileformat'">'fileformat'</A> and <A HREF="options.html#'fileencoding'">'fileencoding'</A> are ignored. The
                line index just after the last line gives the total <A HREF="editing.html#byte-count">byte-count</A>
                of the buffer. A final EOL byte is counted if <A HREF="motion.html#it">it</A> would be
                written, see <A HREF="options.html#'eol'">'eol'</A>.

                Unlike |<A HREF="eval.html#line2byte()">line2byte()</A>|, throws error for out-of-bounds indexing.
                Returns -1 for unloaded buffer.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}  Buffer handle, or 0 for current buffer
                    {index}   Line index

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Integer byte offset, or -1 for unloaded buffer.


nvim_buf_get_option({buffer}, {name})                  *<A NAME="nvim_buf_get_option()"></A><B>nvim_buf_get_option()</B>*
                Gets a buffer option value

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}  Buffer handle, or 0 for current buffer
                    {name}    Option name

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Option value


nvim_buf_get_var({buffer}, {name})                        *<A NAME="nvim_buf_get_var()"></A><B>nvim_buf_get_var()</B>*
                Gets a buffer-scoped (b:) variable.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}  Buffer handle, or 0 for current buffer
                    {name}    Variable name

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Variable value


nvim_buf_is_loaded({buffer})                            *<A NAME="nvim_buf_is_loaded()"></A><B>nvim_buf_is_loaded()</B>*
                Checks if a buffer is valid and loaded. See |<A HREF="#api-buffer">api-buffer</A>| for
                more info about unloaded <A HREF="windows.html#buffers">buffers</A>.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}  Buffer handle, or 0 for current buffer

<B><FONT color="#54A23D">                Return: </FONT></B>
                    true if the buffer is valid and loaded, false otherwise.


nvim_buf_is_valid({buffer})                              *<A NAME="nvim_buf_is_valid()"></A><B>nvim_buf_is_valid()</B>*
                Checks if a buffer is valid.

                Note:
                    Even if a buffer is valid <A HREF="motion.html#it">it</A> may have been unloaded. See
                    |<A HREF="#api-buffer">api-buffer</A>| for more info about unloaded <A HREF="windows.html#buffers">buffers</A>.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}  Buffer handle, or 0 for current buffer

<B><FONT color="#54A23D">                Return: </FONT></B>
                    true if the buffer is valid, false otherwise.


nvim_buf_line_count({buffer})                          *<A NAME="nvim_buf_line_count()"></A><B>nvim_buf_line_count()</B>*
                Gets the buffer line <A HREF="intro.html#count">count</A>

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}  Buffer handle, or 0 for current buffer

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Line <A HREF="intro.html#count">count</A>, or 0 for unloaded buffer. |<A HREF="#api-buffer">api-buffer</A>|


                                                      *<A NAME="nvim_buf_set_extmark()"></A><B>nvim_buf_set_extmark()</B>*
nvim_buf_set_extmark({buffer}, {ns_id}, {line}, {col}, {opts})
                Creates or updates an extmark.

                To create a new extmark, pass id=0. The extmark id will be
                returned. To move an existing <A HREF="motion.html#mark">mark</A>, pass its id.

                It is also allowed to create a new <A HREF="motion.html#mark">mark</A> by passing in a
                previously unused id, but the caller must then keep track of
                existing and unused ids itself. (Useful over <A HREF="#RPC">RPC</A>, to avoid
                waiting for the return value.)

                Using the optional arguments, <A HREF="motion.html#it">it</A> is possible to use this to
                highlight a range of text, and also to associate virtual text
                to the <A HREF="motion.html#mark">mark</A>.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}  Buffer handle, or 0 for current buffer
                    {ns_id}   Namespace id from |<A HREF="#nvim_create_namespace()">nvim_create_namespace()</A>|
                    {line}    Line number where to place the <A HREF="motion.html#mark">mark</A>
                    {col}     Column where to place the <A HREF="motion.html#mark">mark</A>
                    {opts}    Optional parameters.
                              • id : id of the extmark to edit.
                              • end_line : ending line of the <A HREF="motion.html#mark">mark</A>, 0-based
                                <A HREF="motion.html#inclusive">inclusive</A>.
                              • end_col : ending col of the <A HREF="motion.html#mark">mark</A>, 0-based
                                <A HREF="motion.html#inclusive">inclusive</A>.
                              • hl_group : name of the highlight group used to
                                highlight this <A HREF="motion.html#mark">mark</A>.
                              • virt_text : virtual text to link to this <A HREF="motion.html#mark">mark</A>.
                              • virt_text_pos : positioning of virtual text.
                                Possible values:
                                • &quot;eol&quot;: right after eol character (default)
                                • &quot;overlay&quot;: display over the specified
                                  column, without shifting the underlying
                                  text.

                              • virt_text_hide : hide the virtual text when
                                the background text is selected or hidden due
                                to horizontal scroll <A HREF="options.html#'nowrap'">'nowrap'</A>
                              • hl_mode : <A HREF="intro.html#control">control</A> how highlights are combined
                                with the highlights of the text. Currently
                                only affects virt_text highlights, but might
                                affect`hl_group`in later versions.
                                • &quot;replace&quot;: only show the virt_text color.
                                  This is the default
                                • &quot;combine&quot;: combine with background text
                                  color
                                • &quot;blend&quot;: blend with background text color.

                              • hl_eol : when true, for a multiline highlight
                                covering the EOL of a line, continue the
                                highlight for the rest of the screen line
                                (just like for <A HREF="diff.html#diff">diff</A> and cursorline highlight).
                              • ephemeral : for use with
                                |<A HREF="intro.html#nvim_set_decoration_provider">nvim_set_decoration_provider</A>| callbacks. The
                                <A HREF="motion.html#mark">mark</A> will only be used for the current redraw
                                cycle, and not be permantently stored in the
                                buffer.
                              • right_gravity : <A HREF="options.html#boolean">boolean</A> that indicates the
                                direction the extmark will be shifted in when
                                new text is inserted (true for right, false
                                for left). defaults to true.
                              • end_right_gravity : <A HREF="options.html#boolean">boolean</A> that indicates the
                                direction the extmark end position (if <A HREF="motion.html#it">it</A>
                                exists) will be shifted in when new text is
                                inserted (true for right, false for left).
                                Defaults to false.
                              • priority: a priority value for the highlight
                                group. For example <A HREF="treesitter.html#treesitter">treesitter</A> highlighting
                                uses a value of 100.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Id of the created/updated extmark


                                                       *<A NAME="nvim_buf_set_keymap()"></A><B>nvim_buf_set_keymap()</B>*
nvim_buf_set_keymap({buffer}, {mode}, <A HREF="map.html#{lhs}">{lhs}</A>, <A HREF="map.html#{rhs}">{rhs}</A>, {opts})
                Sets a buffer-local |<A HREF="map.html#mapping">mapping</A>| for the given mode.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}  Buffer handle, or 0 for current buffer

<B><FONT color="#54A23D">                See also: </FONT></B>
                    |<A HREF="#nvim_set_keymap()">nvim_set_keymap()</A>|


                                                        *<A NAME="nvim_buf_set_lines()"></A><B>nvim_buf_set_lines()</B>*
nvim_buf_set_lines({buffer}, {start}, {end}, {strict_indexing}, {replacement})
                Sets (replaces) a line-range in the buffer.

                Indexing is zero-based, end-exclusive. Negative indices are
                interpreted <A HREF="motion.html#as">as</A> length+1+index: -1 refers to the index past the
                end. So to change or delete the last element use start=-2 and
                end=-1.

                To insert lines at a given index, set `start` and `end` to the
                same index. To delete a range of lines, set `replacement` to
                an empty array.

                Out-of-bounds indices are clamped to the nearest valid value,
                unless `strict_indexing` is set.

<B><FONT color="#54A23D">                Attributes: </FONT></B>
                    not allowed when |<A HREF="eval.html#textlock">textlock</A>| is active

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}           Buffer handle, or 0 for current buffer
                    {start}            First line index
                    {end}              Last line index (exclusive)
                    {strict_indexing}  Whether out-of-bounds should be an
                                       error.
                    {replacement}      Array of lines to use <A HREF="motion.html#as">as</A> replacement


nvim_buf_set_name({buffer}, {name})                      *<A NAME="nvim_buf_set_name()"></A><B>nvim_buf_set_name()</B>*
                Sets the full file name for a buffer

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}  Buffer handle, or 0 for current buffer
                    {name}    Buffer name


nvim_buf_set_option({buffer}, {name}, {value})         *<A NAME="nvim_buf_set_option()"></A><B>nvim_buf_set_option()</B>*
                Sets a buffer option value. Passing 'nil' <A HREF="motion.html#as">as</A> value deletes the
                option (only works if there's a global fallback)

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}  Buffer handle, or 0 for current buffer
                    {name}    Option name
                    {value}   Option value


                                                         *<A NAME="nvim_buf_set_text()"></A><B>nvim_buf_set_text()</B>*
nvim_buf_set_text({buffer}, {start_row}, {start_col}, {end_row}, {end_col},
                  {replacement})
                Sets (replaces) a range in the buffer

                This is recommended over nvim_buf_set_lines when only
                modifying parts of a line, <A HREF="motion.html#as">as</A> extmarks will be preserved on
                non-modified parts of the touched lines.

                Indexing is zero-based and end-exclusive.

                To insert text at a given index, set `start` and `end` ranges
                to the same index. To delete a range, set `replacement` to an
                array containing an empty <A HREF="eval.html#string">string</A>, or simply an empty array.

                Prefer nvim_buf_set_lines when adding or <A HREF="change.html#deleting">deleting</A> entire lines
                only.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}        Buffer handle, or 0 for current buffer
                    {start_row}     First line index
                    {start_column}  Last column
                    {end_row}       Last line index
                    {end_column}    Last column
                    {replacement}   Array of lines to use <A HREF="motion.html#as">as</A> replacement


nvim_buf_set_var({buffer}, {name}, {value})               *<A NAME="nvim_buf_set_var()"></A><B>nvim_buf_set_var()</B>*
                Sets a buffer-scoped (b:) variable

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}  Buffer handle, or 0 for current buffer
                    {name}    Variable name
                    {value}   Variable value


                                                 *<A NAME="nvim_buf_set_virtual_text()"></A><B>nvim_buf_set_virtual_text()</B>*
nvim_buf_set_virtual_text({buffer}, {src_id}, {line}, {chunks}, {opts})
                Set the virtual text (annotation) for a buffer line.

                By default (and currently the only option) the text will be
                placed after the buffer text. Virtual text will never cause
                reflow, rather virtual text will be truncated at the end of
                the screen line. The virtual text will begin one cell
                (|<A HREF="options.html#lcs-eol">lcs-eol</A>| or space) after the ordinary text.

                Namespaces are used to support batch deletion/updating of
                virtual text. To create a namespace, use
                |<A HREF="#nvim_create_namespace()">nvim_create_namespace()</A>|. Virtual text is cleared using
                |<A HREF="#nvim_buf_clear_namespace()">nvim_buf_clear_namespace()</A>|. The same `ns_id` can be used for
                both virtual text and highlights added by
                |<A HREF="#nvim_buf_add_highlight()">nvim_buf_add_highlight()</A>|, both can then be cleared with a
                single call to |<A HREF="#nvim_buf_clear_namespace()">nvim_buf_clear_namespace()</A>|. If the virtual
                text never will be cleared by an <A HREF="#API">API</A> call, pass `ns_id = -1` .

                As a shorthand, `ns_id = 0` can be used to create a new
                namespace for the virtual text, the allocated id is then
                returned.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buffer}  Buffer handle, or 0 for current buffer
                    {ns_id}   Namespace to use or 0 to create a namespace, or
                              -1 for a ungrouped annotation
                    {line}    Line to annotate with virtual text
                              (zero-indexed)
                    {chunks}  A <A HREF="eval.html#list">list</A> of [text, hl_group] arrays, each
                              representing a text chunk with specified
                              highlight. `hl_group` element can be omitted for
                              no highlight.
                    {opts}    Optional parameters. Currently not used.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    The ns_id that was used


==============================================================================

Window Functions                                                  *<A NAME="api-window"></A><B>api-window</B>*


nvim_win_close({window}, {force})                           *<A NAME="nvim_win_close()"></A><B>nvim_win_close()</B>*
                Closes the window (like |<A HREF="windows.html#:close">:close</A>| with a |<A HREF="windows.html#window-ID">window-ID</A>|).

<B><FONT color="#54A23D">                Attributes: </FONT></B>
                    not allowed when |<A HREF="eval.html#textlock">textlock</A>| is active

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>
                    {force}   Behave like `:close!` The last <A HREF="windows.html#window">window</A> of a
                              buffer with unwritten changes can be closed. The
                              buffer will become hidden, even if <A HREF="options.html#'hidden'">'hidden'</A> is
                              not set.


nvim_win_del_var({window}, {name})                        *<A NAME="nvim_win_del_var()"></A><B>nvim_win_del_var()</B>*
                Removes a window-scoped (w:) variable

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>
                    {name}    Variable name


nvim_win_get_buf({window})                                *<A NAME="nvim_win_get_buf()"></A><B>nvim_win_get_buf()</B>*
                Gets the current buffer in a <A HREF="windows.html#window">window</A>

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Buffer handle


nvim_win_get_config({window})                          *<A NAME="nvim_win_get_config()"></A><B>nvim_win_get_config()</B>*
                Gets <A HREF="windows.html#window">window</A> configuration.

                The returned value may be given to |<A HREF="#nvim_open_win()">nvim_open_win()</A>|.

                `relative` is empty for normal <A HREF="windows.html#windows">windows</A>.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Map defining the <A HREF="windows.html#window">window</A> configuration, see
                    |<A HREF="#nvim_open_win()">nvim_open_win()</A>|


nvim_win_get_cursor({window})                          *<A NAME="nvim_win_get_cursor()"></A><B>nvim_win_get_cursor()</B>*
                Gets the (1,0)-indexed cursor position in the <A HREF="windows.html#window">window</A>.
                |<A HREF="#api-indexing">api-indexing</A>|

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>

<B><FONT color="#54A23D">                Return: </FONT></B>
                    (row, col) tuple


nvim_win_get_height({window})                          *<A NAME="nvim_win_get_height()"></A><B>nvim_win_get_height()</B>*
                Gets the <A HREF="windows.html#window">window</A> height

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Height <A HREF="motion.html#as">as</A> a <A HREF="intro.html#count">count</A> of rows


nvim_win_get_number({window})                          *<A NAME="nvim_win_get_number()"></A><B>nvim_win_get_number()</B>*
                Gets the <A HREF="windows.html#window">window</A> number

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Window number


nvim_win_get_option({window}, {name})                  *<A NAME="nvim_win_get_option()"></A><B>nvim_win_get_option()</B>*
                Gets a <A HREF="windows.html#window">window</A> option value

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>
                    {name}    Option name

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Option value


nvim_win_get_position({window})                      *<A NAME="nvim_win_get_position()"></A><B>nvim_win_get_position()</B>*
                Gets the <A HREF="windows.html#window">window</A> position in display cells. First position is
                zero.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>

<B><FONT color="#54A23D">                Return: </FONT></B>
                    (row, col) tuple with the <A HREF="windows.html#window">window</A> position


nvim_win_get_tabpage({window})                        *<A NAME="nvim_win_get_tabpage()"></A><B>nvim_win_get_tabpage()</B>*
                Gets the <A HREF="windows.html#window">window</A> <A HREF="tabpage.html#tabpage">tabpage</A>

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Tabpage that contains the <A HREF="windows.html#window">window</A>


nvim_win_get_var({window}, {name})                        *<A NAME="nvim_win_get_var()"></A><B>nvim_win_get_var()</B>*
                Gets a window-scoped (w:) variable

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>
                    {name}    Variable name

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Variable value


nvim_win_get_width({window})                            *<A NAME="nvim_win_get_width()"></A><B>nvim_win_get_width()</B>*
                Gets the <A HREF="windows.html#window">window</A> width

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Width <A HREF="motion.html#as">as</A> a <A HREF="intro.html#count">count</A> of columns


nvim_win_hide({window})                                      *<A NAME="nvim_win_hide()"></A><B>nvim_win_hide()</B>*
                Closes the <A HREF="windows.html#window">window</A> and hide the buffer <A HREF="motion.html#it">it</A> contains (like
                |<A HREF="windows.html#:hide">:hide</A>| with a |<A HREF="windows.html#window-ID">window-ID</A>|).

                Like |<A HREF="windows.html#:hide">:hide</A>| the buffer becomes hidden unless another <A HREF="windows.html#window">window</A>
                is editing <A HREF="motion.html#it">it</A>, or <A HREF="options.html#'bufhidden'">'bufhidden'</A> is `unload` , `delete` or `wipe`
                <A HREF="motion.html#as">as</A> opposed to |<A HREF="windows.html#:close">:close</A>| or |<A HREF="intro.html#nvim_win_close">nvim_win_close</A>|, which will close
                the buffer.

<B><FONT color="#54A23D">                Attributes: </FONT></B>
                    not allowed when |<A HREF="eval.html#textlock">textlock</A>| is active

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>


nvim_win_is_valid({window})                              *<A NAME="nvim_win_is_valid()"></A><B>nvim_win_is_valid()</B>*
                Checks if a <A HREF="windows.html#window">window</A> is valid

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>

<B><FONT color="#54A23D">                Return: </FONT></B>
                    true if the <A HREF="windows.html#window">window</A> is valid, false otherwise


nvim_win_set_buf({window}, {buffer})                      *<A NAME="nvim_win_set_buf()"></A><B>nvim_win_set_buf()</B>*
                Sets the current buffer in a <A HREF="windows.html#window">window</A>, without side-effects

<B><FONT color="#54A23D">                Attributes: </FONT></B>
                    not allowed when |<A HREF="eval.html#textlock">textlock</A>| is active

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>
                    {buffer}  Buffer handle


nvim_win_set_config({window}, {config})                *<A NAME="nvim_win_set_config()"></A><B>nvim_win_set_config()</B>*
                Configures <A HREF="windows.html#window">window</A> layout. Currently only for floating and
                external <A HREF="windows.html#windows">windows</A> (including <A HREF="change.html#changing">changing</A> a split <A HREF="windows.html#window">window</A> to those
                layouts).

                When reconfiguring a floating <A HREF="windows.html#window">window</A>, absent option keys will
                not be changed. `row` / `col` and `relative` must be
                reconfigured together.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>
                    {config}  Map defining the <A HREF="windows.html#window">window</A> configuration, see
                              |<A HREF="#nvim_open_win()">nvim_open_win()</A>|

<B><FONT color="#54A23D">                See also: </FONT></B>
                    |<A HREF="#nvim_open_win()">nvim_open_win()</A>|


nvim_win_set_cursor({window}, {pos})                   *<A NAME="nvim_win_set_cursor()"></A><B>nvim_win_set_cursor()</B>*
                Sets the (1,0)-indexed cursor position in the <A HREF="windows.html#window">window</A>.
                |<A HREF="#api-indexing">api-indexing</A>|

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>
                    {pos}     (row, col) tuple representing the new position


nvim_win_set_height({window}, {height})                *<A NAME="nvim_win_set_height()"></A><B>nvim_win_set_height()</B>*
                Sets the <A HREF="windows.html#window">window</A> height. This will only succeed if the screen
                is split horizontally.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>
                    {height}  Height <A HREF="motion.html#as">as</A> a <A HREF="intro.html#count">count</A> of rows


nvim_win_set_option({window}, {name}, {value})         *<A NAME="nvim_win_set_option()"></A><B>nvim_win_set_option()</B>*
                Sets a <A HREF="windows.html#window">window</A> option value. Passing 'nil' <A HREF="motion.html#as">as</A> value deletes the
                option(only works if there's a global fallback)

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>
                    {name}    Option name
                    {value}   Option value


nvim_win_set_var({window}, {name}, {value})               *<A NAME="nvim_win_set_var()"></A><B>nvim_win_set_var()</B>*
                Sets a window-scoped (w:) variable

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>
                    {name}    Variable name
                    {value}   Variable value


nvim_win_set_width({window}, {width})                   *<A NAME="nvim_win_set_width()"></A><B>nvim_win_set_width()</B>*
                Sets the <A HREF="windows.html#window">window</A> width. This will only succeed if the screen is
                split vertically.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>
                    {width}   Width <A HREF="motion.html#as">as</A> a <A HREF="intro.html#count">count</A> of columns


==============================================================================

Tabpage Functions                                                *<A NAME="api-tabpage"></A><B>api-tabpage</B>*


nvim_tabpage_del_var({tabpage}, {name})               *<A NAME="nvim_tabpage_del_var()"></A><B>nvim_tabpage_del_var()</B>*
                Removes a tab-scoped (t:) variable

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {tabpage}  Tabpage handle, or 0 for current <A HREF="tabpage.html#tabpage">tabpage</A>
                    {name}     Variable name


nvim_tabpage_get_number({tabpage})                 *<A NAME="nvim_tabpage_get_number()"></A><B>nvim_tabpage_get_number()</B>*
                Gets the <A HREF="tabpage.html#tabpage">tabpage</A> number

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {tabpage}  Tabpage handle, or 0 for current <A HREF="tabpage.html#tabpage">tabpage</A>

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Tabpage number


nvim_tabpage_get_var({tabpage}, {name})               *<A NAME="nvim_tabpage_get_var()"></A><B>nvim_tabpage_get_var()</B>*
                Gets a tab-scoped (t:) variable

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {tabpage}  Tabpage handle, or 0 for current <A HREF="tabpage.html#tabpage">tabpage</A>
                    {name}     Variable name

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Variable value


nvim_tabpage_get_win({tabpage})                       *<A NAME="nvim_tabpage_get_win()"></A><B>nvim_tabpage_get_win()</B>*
                Gets the current <A HREF="windows.html#window">window</A> in a <A HREF="tabpage.html#tabpage">tabpage</A>

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {tabpage}  Tabpage handle, or 0 for current <A HREF="tabpage.html#tabpage">tabpage</A>

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Window handle


nvim_tabpage_is_valid({tabpage})                     *<A NAME="nvim_tabpage_is_valid()"></A><B>nvim_tabpage_is_valid()</B>*
                Checks if a <A HREF="tabpage.html#tabpage">tabpage</A> is valid

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {tabpage}  Tabpage handle, or 0 for current <A HREF="tabpage.html#tabpage">tabpage</A>

<B><FONT color="#54A23D">                Return: </FONT></B>
                    true if the <A HREF="tabpage.html#tabpage">tabpage</A> is valid, false otherwise


nvim_tabpage_list_wins({tabpage})                   *<A NAME="nvim_tabpage_list_wins()"></A><B>nvim_tabpage_list_wins()</B>*
                Gets the <A HREF="windows.html#windows">windows</A> in a <A HREF="tabpage.html#tabpage">tabpage</A>

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {tabpage}  Tabpage handle, or 0 for current <A HREF="tabpage.html#tabpage">tabpage</A>

<B><FONT color="#54A23D">                Return: </FONT></B>
                    <A HREF="eval.html#List">List</A> of <A HREF="windows.html#windows">windows</A> in `tabpage`


                                                      *<A NAME="nvim_tabpage_set_var()"></A><B>nvim_tabpage_set_var()</B>*
nvim_tabpage_set_var({tabpage}, {name}, {value})
                Sets a tab-scoped (t:) variable

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {tabpage}  Tabpage handle, or 0 for current <A HREF="tabpage.html#tabpage">tabpage</A>
                    {name}     Variable name
                    {value}    Variable value


==============================================================================

<A HREF="ui.html#UI">UI</A> Functions                                                          *<A NAME="api-ui"></A><B>api-ui</B>*


nvim_ui_attach({width}, {height}, {options})                *<A NAME="nvim_ui_attach()"></A><B>nvim_ui_attach()</B>*
                Activates <A HREF="ui.html#UI">UI</A> <A HREF="autocmd.html#events">events</A> on the <A HREF="channel.html#channel">channel</A>.

                Entry point of all <A HREF="ui.html#UI">UI</A> clients. Allows |<A HREF="starting.html#--embed">--embed</A>| to continue
                <A HREF="starting.html#startup">startup</A>. Implies that the client is ready to show the <A HREF="ui.html#UI">UI</A>. Adds
                the client to the list of UIs. |<A HREF="#nvim_list_uis()">nvim_list_uis()</A>|

                Note:
                    If multiple <A HREF="ui.html#UI">UI</A> clients are attached, the global screen
                    dimensions degrade to the smallest client. E.g. if client
                    A requests 80x40 but client <A HREF="motion.html#B">B</A> requests 200x100, the global
                    screen has size 80x40.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {width}    Requested screen columns
                    {height}   Requested screen rows
                    {options}  |<A HREF="ui.html#ui-option">ui-option</A>| map


<A HREF="#nvim_ui_detach()">nvim_ui_detach()</A>                                            *<A NAME="nvim_ui_detach()"></A><B>nvim_ui_detach()</B>*
                Deactivates <A HREF="ui.html#UI">UI</A> <A HREF="autocmd.html#events">events</A> on the <A HREF="channel.html#channel">channel</A>.

                Removes the client from the list of UIs. |<A HREF="#nvim_list_uis()">nvim_list_uis()</A>|


                                                    *<A NAME="nvim_ui_pum_set_bounds()"></A><B>nvim_ui_pum_set_bounds()</B>*
nvim_ui_pum_set_bounds({width}, {height}, {row}, {col})
                Tells Nvim the geometry of the popumenu, to align floating
                <A HREF="windows.html#windows">windows</A> with an external popup menu.

                Note that this method is not to be confused with
                |<A HREF="#nvim_ui_pum_set_height()">nvim_ui_pum_set_height()</A>|, which sets the number of visible
                items in the popup menu, while this function sets the bounding
                box of the popup menu, including visual elements such <A HREF="motion.html#as">as</A>
                borders and sliders. Floats need not use the same font size,
                nor be anchored to exact grid corners, so one can set
                floating-point numbers to the popup menu geometry.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {width}   Popupmenu width.
                    {height}  Popupmenu height.
                    {row}     Popupmenu row.
                    {col}     Popupmenu height.


nvim_ui_pum_set_height({height})                    *<A NAME="nvim_ui_pum_set_height()"></A><B>nvim_ui_pum_set_height()</B>*
                Tells Nvim the number of elements displaying in the popumenu,
                to decide <A HREF="scroll.html#&lt;PageUp&gt;">&lt;PageUp&gt;</A> and <A HREF="scroll.html#&lt;PageDown&gt;">&lt;PageDown&gt;</A> <A HREF="intro.html#movement">movement</A>.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {height}  Popupmenu height, must be greater than zero.


nvim_ui_set_option({name}, {value})                     *<A NAME="nvim_ui_set_option()"></A><B>nvim_ui_set_option()</B>*
                TODO: Documentation


nvim_ui_try_resize({width}, {height})                   *<A NAME="nvim_ui_try_resize()"></A><B>nvim_ui_try_resize()</B>*
                TODO: Documentation


                                                   *<A NAME="nvim_ui_try_resize_grid()"></A><B>nvim_ui_try_resize_grid()</B>*
nvim_ui_try_resize_grid({grid}, {width}, {height})
                Tell Nvim to resize a grid. Triggers a grid_resize event with
                the requested grid size or the maximum size if <A HREF="motion.html#it">it</A> exceeds size
                <A HREF="vi_diff.html#limits">limits</A>.

                On invalid grid handle, fails with error.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {grid}    The handle of the grid to be changed.
                    {width}   The new requested width.
                    {height}  The new requested height.

<A HREF="#top">top</A> - <A HREF="index.html">main help file</A>
</PRE>
    </div>

    <footer>
      <div class="container">
        Generated Sun May  2 05:42:01 UTC 2021 from <a href="https://github.com/neovim/neovim/commit/b227cedf82341813514da55baa48511eca4014b0"><code>b227ced</code></a>.
      </div>
    </footer>
  </body>
</html>
