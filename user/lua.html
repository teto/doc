<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <meta content="width=device-width, initial-scale=1" name="viewport">
    <title>Nvim documentation: lua</title>
    <link href="https://fonts.googleapis.com/css?family=Lato:400,700,900" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.0/normalize.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
    <link href="/css/main.css" rel="stylesheet">
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    
  </head>
  <body>
    <header class="navbar">
      <div class="container">
        <nav class="navbar">
          <div class="container-fluid">
            <div class="navbar-header">

              <a href="/" class="navbar-brand">
                <img src="/images/logo@2x.png" id="navbar-logo" alt="Neovim">
              </a>
            </div>
          </div>
        </nav>
      </div>
    </header>

    <div class="container">
      <h1>Nvim documentation: lua</h1>
<A NAME="top"></A>
<A HREF="index.html">main help file</A>

<HR>
<PRE>

*<A NAME="lua.txt"></A><B>lua.txt</B>*    Nvim


			    NVIM REFERENCE MANUAL



<A HREF="#Lua">Lua</A> engine						*<A NAME="lua"></A><B>lua</B>* *<A NAME="Lua"></A><B>Lua</B>*

                                      Type |<A HREF="various.html#gO">gO</A>| to see the table of contents.

==============================================================================

INTRODUCTION						*<A NAME="lua-intro"></A><B>lua-intro</B>*

The <A HREF="#Lua">Lua</A> 5.1 language is builtin and always available.  Try this command to get
an idea of what lurks beneath:

<B>    :lua print(vim.inspect(package.loaded))</B>

Nvim includes a &quot;standard library&quot; |<A HREF="#lua-stdlib">lua-stdlib</A>| for <A HREF="#Lua">Lua</A>.  It complements the
&quot;editor stdlib&quot; (|<A HREF="eval.html#functions">functions</A>| and <A HREF="intro.html#Ex">Ex</A> commands) and the |<A HREF="api.html#API">API</A>|, all of which can
be used from <A HREF="#Lua">Lua</A> code. A good overview of using <A HREF="#Lua">Lua</A> in neovim is given by
https://github.com/nanotee/nvim-lua-guide.

Module conflicts are resolved by &quot;last wins&quot;.  For example if both of these
are on <A HREF="options.html#'runtimepath'">'runtimepath'</A>:
    runtime/lua/foo.lua
    ~/.config/nvim/lua/foo.lua
then `require('foo')` loads &quot;~/.config/nvim/lua/foo.lua&quot;, and
&quot;runtime/lua/foo.lua&quot; is not used.  See |<A HREF="#lua-require">lua-require</A>| to understand how Nvim
finds and loads <A HREF="#Lua">Lua</A> modules.  The conventions are similar to VimL plugins,
with some extra features.  See |<A HREF="#lua-require-example">lua-require-example</A>| for a walkthrough.

==============================================================================

IMPORTING LUA MODULES					*<A NAME="lua-require"></A><B>lua-require</B>*


                                                        *<A NAME="lua-package-path"></A><B>lua-package-path</B>*
Nvim automatically adjusts `package.path` and `package.cpath` according to
effective <A HREF="options.html#'runtimepath'">'runtimepath'</A> value.  Adjustment happens whenever <A HREF="options.html#'runtimepath'">'runtimepath'</A> is
changed.  `package.path` is adjusted by simply appending `/lua/?.lua` and
`/lua/?/init.lua` to each directory from <A HREF="options.html#'runtimepath'">'runtimepath'</A> (`/` is actually the
first character of `package.config`).

Similarly to `package.path`, modified directories from <A HREF="options.html#'runtimepath'">'runtimepath'</A> are also
added to `package.cpath`.  In this <A HREF="change.html#case">case</A>, instead of appending `/lua/?.lua` and
`/lua/?/init.lua` to each runtimepath, all unique `?`-containing <A HREF="cmdline.html#suffixes">suffixes</A> of
the existing `package.cpath` are used.  Example:

1. Given that
   - <A HREF="options.html#'runtimepath'">'runtimepath'</A> contains `/foo/bar,/xxx;yyy/baz,/abc`;
   - initial (defined at compile-time or derived from 
     `$LUA_CPATH`/`$LUA_INIT`) `package.cpath` contains 
     `./?.so;/def/ghi/a?d/j/g.elf;/def/?.so`.
2. It finds `?`-containing <A HREF="cmdline.html#suffixes">suffixes</A> `/?.so`, `/a?d/j/g.elf` and `/?.so`, in 
   order: parts of the path starting from the first path component containing 
   question <A HREF="motion.html#mark">mark</A> and preceding path separator.
3. The suffix of `/def/?.so`, namely `/?.so` is not unique, <A HREF="motion.html#as">as</A> it’s the same 
   <A HREF="motion.html#as">as</A> the suffix of the first path from `package.path` (i.e. `./?.so`).  Which 
   leaves `/?.so` and `/a?d/j/g.elf`, in this order.
4. <A HREF="options.html#'runtimepath'">'runtimepath'</A> has three paths: `/foo/bar`, `/xxx;yyy/baz` and `/abc`.  The 
   second one contains semicolon which is a paths separator so <A HREF="motion.html#it">it</A> is out, 
   leaving only `/foo/bar` and `/abc`, in order.
5. The cartesian product of paths from 4. and <A HREF="cmdline.html#suffixes">suffixes</A> from 3. is taken, 
   giving four variants. In each variant `/lua` path segment is inserted 
   between path and suffix, leaving

   - `/foo/bar/lua/?.so`
   - `/foo/bar/lua/a?d/j/g.elf`
   - `/abc/lua/?.so`
   - `/abc/lua/a?d/j/g.elf`

6. New paths are prepended to the original `package.cpath`.

The result will look like this:

    `/foo/bar,/xxx;yyy/baz,/abc` ('runtimepath')
    × `./?.so;/def/ghi/a?d/j/g.elf;/def/?.so` (`package.cpath`)

    = `/foo/bar/lua/?.so;/foo/bar/lua/a?d/j/g.elf;/abc/lua/?.so;/abc/lua/a?d/j/g.elf;./?.so;/def/ghi/a?d/j/g.elf;/def/?.so`

Note:

- To track <A HREF="options.html#'runtimepath'">'runtimepath'</A> updates, paths added at previous update are
  remembered and removed at the next update, while all paths derived from the
  new <A HREF="options.html#'runtimepath'">'runtimepath'</A> are prepended <A HREF="motion.html#as">as</A> described above.  This allows removing
  paths when path is removed from <A HREF="options.html#'runtimepath'">'runtimepath'</A>, adding paths when they are
  added and reordering `package.path`/`package.cpath` content if <A HREF="options.html#'runtimepath'">'runtimepath'</A>
  was reordered.

- Although adjustments happen automatically, Nvim does not track current
  values of `package.path` or `package.cpath`.  If you happen to delete some
  paths from there you can set <A HREF="options.html#'runtimepath'">'runtimepath'</A> to trigger an update:
<B>      let &amp;runtimepath = &amp;runtimepath</B>

- Skipping paths from <A HREF="options.html#'runtimepath'">'runtimepath'</A> which contain semicolons applies both to
  `package.path` and `package.cpath`.  Given that there are some badly written
  plugins using shell which will not work with paths containing semicolons <A HREF="motion.html#it">it</A>
  is better to not have them in <A HREF="options.html#'runtimepath'">'runtimepath'</A> at all.

==============================================================================

<A HREF="#Lua">Lua</A> <A HREF="autocmd.html#Syntax">Syntax</A> Information                                         *<A NAME="lua-syntax-help"></A><B>lua-syntax-help</B>*

While <A HREF="#Lua">Lua</A> has a simple <A HREF="syntax.html#syntax">syntax</A>, there are a few things to understand,
particularly when looking at the documentation above.


                                                      *<A NAME="lua-syntax-call-function"></A><B>lua-syntax-call-function</B>*

<A HREF="#Lua">Lua</A> <A HREF="eval.html#functions">functions</A> can be called in multiple ways. Consider the function:

<B>    local example_func = function(a, b)</B>
<B>        print("A is: ", a)</B>
<B>        print("B is: ", b)</B>
<B>    end</B>


The first way to call a function is:
<B>    </B>
<B>    example_func(1, 2)</B>
<B>    -- ==== Result ====</B>
<B>    -- A is: 1</B>
<B>    -- B is: 2</B>
 
    This way of calling a function is familiar to most scripting languages.
    In <A HREF="#Lua">Lua</A>, it's important to understand that any function arguments that are
    not supplied are automatically set to `nil`. For example:

<B>    example_func(1)</B>
<B>    -- ==== Result ====</B>
<B>    -- A is: 1</B>
<B>    -- B is: nil</B>
 

    Additionally, if any extra parameters are passed, they are discarded
    completely.

In <A HREF="#Lua">Lua</A>, <A HREF="motion.html#it">it</A> is also possible (when only one argument is passed) to call the
function without any parentheses. This is most often used to approximate
&quot;keyword&quot;-style arguments with a single dictionary. For example:

<B>    local func_with_opts = function(opts)</B>
<B>        local will_do_foo = opts.foo</B>
<B>        local filename = opts.filename</B>

<B>        ...</B>
<B>    end</B>

<B>    func_with_opts { foo = true, filename = "hello.world" }</B>
 

    In this style, each &quot;parameter&quot; is passed via keyword. It is still valid
    to call the function in this style:

<B>    func_with_opts({ foo = true, filename = "hello.world" })</B>
 

    But often in the documentation, you will see the former rather than the
    latter style, due to its brevity (this is vim after all!).


------------------------------------------------------------------------------

LUA PLUGIN EXAMPLE					*<A NAME="lua-require-example"></A><B>lua-require-example</B>*

The following example <A HREF="usr_05.html#plugin">plugin</A> adds a command `:MakeCharBlob` which transforms 
current buffer into a long `unsigned char` array.  <A HREF="#Lua">Lua</A> contains transformation 
function in a module `lua/charblob.lua` which is imported in 
`autoload/charblob.vim` (`require(&quot;charblob&quot;)`).  Example <A HREF="usr_05.html#plugin">plugin</A> is supposed 
to be put into any directory from <A HREF="options.html#'runtimepath'">'runtimepath'</A>, e.g. `~/.config/nvim` (in 
this <A HREF="change.html#case">case</A> `lua/charblob.lua` means `~/.config/nvim/lua/charblob.lua`).

autoload/charblob.vim:

<B>    function charblob#encode_buffer()</B>
<B>      call setline(1, luaeval(</B>
<B>      \    'require("charblob").encode(unpack(_A))',</B>
<B>      \    [getline(1, '$'), &amp;textwidth, '  ']))</B>
<B>    endfunction</B>

plugin/charblob.vim:

<B>    if exists('g:charblob_loaded')</B>
<B>      finish</B>
<B>    endif</B>
<B>    let g:charblob_loaded = 1</B>

<B>    command MakeCharBlob :call charblob#encode_buffer()</B>

lua/charblob.lua:

<B>    local function charblob_bytes_iter(lines)</B>
<B>      local init_s = {</B>
<B>        next_line_idx = 1,</B>
<B>        next_byte_idx = 1,</B>
<B>        lines = lines,</B>
<B>      }</B>
<B>      local function next(s, _)</B>
<B>        if lines[s.next_line_idx] == nil then</B>
<B>          return nil</B>
<B>        end</B>
<B>        if s.next_byte_idx &gt; #(lines[s.next_line_idx]) then</B>
<B>          s.next_line_idx = s.next_line_idx + 1</B>
<B>          s.next_byte_idx = 1</B>
<B>          return ('\n'):byte()</B>
<B>        end</B>
<B>        local ret = lines[s.next_line_idx]:byte(s.next_byte_idx)</B>
<B>        if ret == ('\n'):byte() then</B>
<B>          ret = 0  -- See :h NL-used-for-NUL.</B>
<B>        end</B>
<B>        s.next_byte_idx = s.next_byte_idx + 1</B>
<B>        return ret</B>
<B>      end</B>
<B>      return next, init_s, nil</B>
<B>    end</B>

<B>    local function charblob_encode(lines, textwidth, indent)</B>
<B>      local ret = {</B>
<B>        'const unsigned char blob[] = {',</B>
<B>        indent,</B>
<B>      }</B>
<B>      for byte in charblob_bytes_iter(lines) do</B>
<B>        --                .- space + number (width 3) + comma</B>
<B>        if #(ret[#ret]) + 5 &gt; textwidth then</B>
<B>          ret[#ret + 1] = indent</B>
<B>        else</B>
<B>          ret[#ret] = ret[#ret] .. ' '</B>
<B>        end</B>
<B>        ret[#ret] = ret[#ret] .. (('%3u,'):format(byte))</B>
<B>      end</B>
<B>      ret[#ret + 1] = '};'</B>
<B>      return ret</B>
<B>    end</B>

<B>    return {</B>
<B>      bytes_iter = charblob_bytes_iter,</B>
<B>      encode = charblob_encode,</B>
<B>    }</B>

==============================================================================

COMMANDS						*<A NAME="lua-commands"></A><B>lua-commands</B>*

These commands execute a <A HREF="#Lua">Lua</A> chunk from either the command line (:lua, <A HREF="#:luado">:luado</A>)
or a file (:luafile) on the given line <A HREF="cmdline.html#[range]">[range]</A>. As always in <A HREF="#Lua">Lua</A>, each chunk
has its own scope (closure), so only global <A HREF="eval.html#variables">variables</A> are shared between
command calls. The |<A HREF="#lua-stdlib">lua-stdlib</A>| modules, user modules, and anything else on
|<A HREF="#lua-package-path">lua-package-path</A>| are available.

The <A HREF="#Lua">Lua</A> print() function redirects its output to the Nvim message area, with
arguments separated by &quot; &quot; (space) instead of &quot;\t&quot; (tab).


                                                        *<A NAME=":lua"></A><B>:lua</B>*
:[range]lua {chunk}
                        Executes <A HREF="#Lua">Lua</A> chunk {chunk}.

                        Examples:
<B>                            :lua vim.api.nvim_command('echo "Hello, Nvim!"')</B>
                         To see the <A HREF="#Lua">Lua</A> version:
<B>                            :lua print(_VERSION)</B>
                         To see the LuaJIT version:
<B>                            :lua print(jit.version)</B>
 

                                                        *<A NAME=":lua-heredoc"></A><B>:lua-heredoc</B>*
:[range]lua <A HREF="change.html#&lt;&lt;">&lt;&lt;</A> [endmarker]
{script}
{endmarker}
                        Executes <A HREF="#Lua">Lua</A> <A HREF="usr_41.html#script">script</A> {script} from within Vimscript.
                        {endmarker} must <A HREF="#NOT">NOT</A> be preceded by <A HREF="pattern.html#whitespace">whitespace</A>. You
                        can omit [endmarker] after the &quot;<A HREF="change.html#&lt;&lt;">&lt;&lt;</A>&quot; and use a dot &quot;<A HREF="repeat.html#.">.</A>&quot;
                        after {script} (similar to |<A HREF="insert.html#:append">:append</A>|, |<A HREF="insert.html#:insert">:insert</A>|).

                        Example:
                       
<B>                            function! CurrentLineInfo()</B>
<B>                            lua &lt;&lt; EOF</B>
<B>                            local linenr = vim.api.nvim_win_get_cursor(0)[1]</B>
<B>                            local curline = vim.api.nvim_buf_get_lines(</B>
<B>                                    0, linenr, linenr + 1, false)[1]</B>
<B>                            print(string.format("Current line [%d] has %d bytes",</B>
<B>                                    linenr, #curline))</B>
<B>                            EOF</B>
<B>                            endfunction</B>

                         Note that the `local` <A HREF="eval.html#variables">variables</A> will disappear when
                        the block finishes. But not globals.


                                                        *<A NAME=":luado"></A><B>:luado</B>*
:[range]luado {body}    Executes <A HREF="#Lua">Lua</A> chunk &quot;function(line, linenr) {body} end&quot;
                        for each buffer line in <A HREF="cmdline.html#[range]">[range]</A>, where `line` is the
                        current line text (without &lt;EOL&gt;), and `linenr` is the
                        current line number. If the function returns a <A HREF="eval.html#string">string</A>
                        that becomes the text of the corresponding buffer
                        line. Default <A HREF="cmdline.html#[range]">[range]</A> is the whole file: &quot;1,$&quot;.

                        Examples:
                       
<B>                            :luado return string.format("%s\t%d", line:reverse(), #line)</B>

<B>                            :lua require"lpeg"</B>
<B>                            :lua -- balanced parenthesis grammar:</B>
<B>                            :lua bp = lpeg.P{ "(" * ((1 - lpeg.S"()") + lpeg.V(1))^0 * ")" }</B>
<B>                            :luado if bp:match(line) then return "--&gt;\t" .. line end</B>
 


							*<A NAME=":luafile"></A><B>:luafile</B>*
:[range]luafile <A HREF="editing.html#{file}">{file}</A>
			Execute <A HREF="#Lua">Lua</A> <A HREF="usr_41.html#script">script</A> in <A HREF="editing.html#{file}">{file}</A>.
			The whole argument is used <A HREF="motion.html#as">as</A> a single file name.

                        Examples:
                       
<B>                            :luafile script.lua</B>
<B>                            :luafile %</B>
 

==============================================================================

<A HREF="#luaeval()">luaeval()</A>						*<A NAME="lua-eval"></A><B>lua-eval</B>* *<A NAME="luaeval()"></A><B>luaeval()</B>*

The (dual) equivalent of &quot;vim.eval&quot; for passing <A HREF="#Lua">Lua</A> values to Nvim is
&quot;luaeval&quot;. &quot;luaeval&quot; takes an <A HREF="eval.html#expression">expression</A> <A HREF="eval.html#string">string</A> and an optional argument used 
for _A inside <A HREF="eval.html#expression">expression</A> and returns the result of the <A HREF="eval.html#expression">expression</A>. It is 
semantically equivalent in <A HREF="#Lua">Lua</A> to:

<B>    local chunkheader = "local _A = select(1, ...) return "</B>
<B>    function luaeval (expstr, arg)</B>
<B>        local chunk = assert(loadstring(chunkheader .. expstr, "luaeval"))</B>
<B>        return chunk(arg) -- return typval</B>
<B>    end</B>

<A HREF="#Lua">Lua</A> nils, numbers, strings, tables and booleans are converted to their
respective VimL types. An error is thrown if conversion of any other <A HREF="#Lua">Lua</A> types
is attempted.

The magic global &quot;_A&quot; contains the second argument to <A HREF="#luaeval()">luaeval()</A>.

Example:
<B>    :echo luaeval('_A[1] + _A[2]', [40, 2])</B>
<B>    42</B>
<B>    :echo luaeval('string.match(_A, "[a-z]+")', 'XYXfoo123')</B>
<B>    foo</B>

<A HREF="#Lua">Lua</A> tables are used <A HREF="motion.html#as">as</A> both dictionaries and lists, so <A HREF="motion.html#it">it</A> is impossible to
determine whether empty table is meant to be empty <A HREF="eval.html#list">list</A> or empty dictionary.
Additionally <A HREF="#Lua">Lua</A> does not have integer numbers. To distinguish between these
cases there is the following agreement:

0. Empty table is empty <A HREF="eval.html#list">list</A>.
1. Table with N incrementally growing integral numbers, starting from 1 and 
   ending with N is considered to be a <A HREF="eval.html#list">list</A>.
2. Table with <A HREF="eval.html#string">string</A> keys, none of which contains NUL byte, is considered to 
   be a dictionary.
3. Table with <A HREF="eval.html#string">string</A> keys, at least one of which contains NUL byte, is also 
   considered to be a dictionary, but this time <A HREF="motion.html#it">it</A> is converted to 
   a |<A HREF="eval.html#msgpack-special-map">msgpack-special-map</A>|.

							*<A NAME="lua-special-tbl"></A><B>lua-special-tbl</B>*
4. Table with `vim.type_idx` key may be a dictionary, a <A HREF="eval.html#list">list</A> or floating-point 
   value:
   - `{[vim.type_idx]=vim.types.float, [vim.val_idx]=1}` is converted to 
     a floating-point 1.0. Note that by default integral <A HREF="#Lua">Lua</A> numbers are 
     converted to |<A HREF="eval.html#Number">Number</A>|<A HREF="change.html#s">s</A>, non-integral are converted to |<A HREF="eval.html#Float">Float</A>|<A HREF="change.html#s">s</A>. This 
     variant allows integral |<A HREF="eval.html#Float">Float</A>|<A HREF="change.html#s">s</A>.
   - `{[vim.type_idx]=vim.types.dictionary}` is converted to an empty 
     dictionary, `{[vim.type_idx]=vim.types.dictionary, [42]=1, a=2}` is 
     converted to a dictionary `{'a': 42}`: non-string keys are ignored. 
     Without `vim.type_idx` key tables with keys not fitting in 1., 2. or 3. 
     are <A HREF="message.html#errors">errors</A>.
   - `{[vim.type_idx]=vim.types.list}` is converted to an empty <A HREF="eval.html#list">list</A>. As well 
     <A HREF="motion.html#as">as</A> `{[vim.type_idx]=vim.types.list, [42]=1}`: integral keys that <A HREF="diff.html#do">do</A> not 
     form a 1-step sequence from 1 to N are ignored, <A HREF="motion.html#as">as</A> well <A HREF="motion.html#as">as</A> all 
     non-integral keys.

Examples:

<B>    :echo luaeval('math.pi')</B>
<B>    :function Rand(x,y) " random uniform between x and y</B>
<B>    :  return luaeval('(_A.y-_A.x)*math.random()+_A.x', {'x':a:x,'y':a:y})</B>
<B>    :  endfunction</B>
<B>    :echo Rand(1,10)</B>

Note: second argument to `luaeval` undergoes VimL to <A HREF="#Lua">Lua</A> conversion
(&quot;marshalled&quot;), so changes to <A HREF="#Lua">Lua</A> containers <A HREF="diff.html#do">do</A> not affect values in VimL.
Return value is also always converted. When converting,
|<A HREF="eval.html#msgpack-special-dict">msgpack-special-dict</A>|s are treated specially.

==============================================================================

Vimscript <A HREF="eval.html#v:lua">v:lua</A> interface				*<A NAME="v:lua-call"></A><B>v:lua-call</B>*

From Vimscript the special `v:lua` prefix can be used to call <A HREF="#Lua">Lua</A> <A HREF="eval.html#functions">functions</A>
which are global or accessible from global tables. The <A HREF="eval.html#expression">expression</A>
<B>    v:lua.func(arg1, arg2)</B>
is equivalent to the <A HREF="#Lua">Lua</A> chunk
<B>    return func(...)</B>
where the args are converted to <A HREF="#Lua">Lua</A> values. The <A HREF="eval.html#expression">expression</A>
<B>    v:lua.somemod.func(args)</B>
is equivalent to the <A HREF="#Lua">Lua</A> chunk
<B>    return somemod.func(...)</B>

You can use `v:lua` in &quot;func&quot; <A HREF="options.html#options">options</A> like <A HREF="options.html#'tagfunc'">'tagfunc'</A>, <A HREF="options.html#'omnifunc'">'omnifunc'</A>, etc.
For example consider the following <A HREF="#Lua">Lua</A> omnifunc handler:

<B>    function mymod.omnifunc(findstart, base)</B>
<B>      if findstart == 1 then</B>
<B>        return 0</B>
<B>      else</B>
<B>        return {'stuff', 'steam', 'strange things'}</B>
<B>      end</B>
<B>    end</B>
<B>    vim.api.nvim_buf_set_option(0, 'omnifunc', 'v:lua.mymod.omnifunc')</B>

Note: the module (&quot;mymod&quot; in the above example) must be a <A HREF="#Lua">Lua</A> global.

Note: `v:lua` without a call is not allowed in a Vimscript <A HREF="eval.html#expression">expression</A>:
|<A HREF="eval.html#Funcref">Funcref</A>|<A HREF="change.html#s">s</A> cannot represent <A HREF="#Lua">Lua</A> <A HREF="eval.html#functions">functions</A>. The following are <A HREF="message.html#errors">errors</A>:

<B>    let g:Myvar = v:lua.myfunc        " Error</B>
<B>    call SomeFunc(v:lua.mycallback)   " Error</B>
<B>    let g:foo = v:lua                 " Error</B>
<B>    let g:foo = v:['lua']             " Error</B>


==============================================================================

<A HREF="#Lua">Lua</A> standard modules					*<A NAME="lua-stdlib"></A><B>lua-stdlib</B>*

The Nvim <A HREF="#Lua">Lua</A> &quot;standard library&quot; (stdlib) is the `vim` module, which exposes
various <A HREF="eval.html#functions">functions</A> and sub-modules.  It is always loaded, thus require(&quot;vim&quot;)
is unnecessary.

You can peek at the module properties:

<B>    :lua print(vim.inspect(vim))</B>

Result is something like this:

<B>    {</B>
<B>      _os_proc_children = &lt;function 1&gt;,</B>
<B>      _os_proc_info = &lt;function 2&gt;,</B>
<B>      ...</B>
<B>      api = {</B>
<B>        nvim__id = &lt;function 5&gt;,</B>
<B>        nvim__id_array = &lt;function 6&gt;,</B>
<B>        ...</B>
<B>      },</B>
<B>      deepcopy = &lt;function 106&gt;,</B>
<B>      gsplit = &lt;function 107&gt;,</B>
<B>      ...</B>
<B>    }</B>

To find documentation on e.g. the &quot;deepcopy&quot; function:

<B>    :help vim.deepcopy()</B>

Note that underscore-prefixed <A HREF="eval.html#functions">functions</A> (e.g. &quot;_os_proc_children&quot;) are
internal/private and must not be used by plugins.

------------------------------------------------------------------------------

VIM.LOOP						*<A NAME="lua-loop"></A><B>lua-loop</B>* *<A NAME="vim.loop"></A><B>vim.loop</B>*

`vim.loop` exposes all features of the Nvim event-loop.  This is a low-level
<A HREF="api.html#API">API</A> that provides functionality for networking, filesystem, and process
management.  Try this command to see available <A HREF="eval.html#functions">functions</A>:

<B>    :lua print(vim.inspect(vim.loop))</B>

Reference: https://github.com/luvit/luv/blob/master/docs.md
Examples:  https://github.com/luvit/luv/tree/master/examples


						*<A NAME="E5560"></A><B>E5560</B>* *<A NAME="lua-loop-callbacks"></A><B>lua-loop-callbacks</B>*
It is an error to directly invoke `vim.api` <A HREF="eval.html#functions">functions</A> (except |<A HREF="api.html#api-fast">api-fast</A>|) in
`vim.loop` callbacks.  For example, this is an error:

<B>    local timer = vim.loop.new_timer()</B>
<B>    timer:start(1000, 0, function()</B>
<B>      vim.api.nvim_command('echomsg "test"')</B>
<B>    end)</B>

To avoid the error use |<A HREF="vim.html">vim.schedule_wrap()</A>| to defer the callback:

<B>    local timer = vim.loop.new_timer()</B>
<B>    timer:start(1000, 0, vim.schedule_wrap(function()</B>
<B>      vim.api.nvim_command('echomsg "test"')</B>
<B>    end))</B>

(For one-shot <A HREF="eval.html#timers">timers</A>, see |<A HREF="vim.html">vim.defer_fn()</A>|, which automatically adds the wrapping.)

Example: <A HREF="repeat.html#repeating">repeating</A> <A HREF="eval.html#timer">timer</A>
    1. Save this code to a file.
    2. Execute <A HREF="motion.html#it">it</A> with &quot;<A HREF="#:luafile">:luafile</A> &#37;&quot;.

<B>    -- Create a timer handle (implementation detail: uv_timer_t).</B>
<B>    local timer = vim.loop.new_timer()</B>
<B>    local i = 0</B>
<B>    -- Waits 1000ms, then repeats every 750ms until timer:close().</B>
<B>    timer:start(1000, 750, function()</B>
<B>      print('timer invoked! i='..tostring(i))</B>
<B>      if i &gt; 4 then</B>
<B>        timer:close()  -- Always close handles to avoid leaks.</B>
<B>      end</B>
<B>      i = i + 1</B>
<B>    end)</B>
<B>    print('sleeping');</B>



Example: File-change detection				*<A NAME="watch-file"></A><B>watch-file</B>*
    1. Save this code to a file.
    2. Execute <A HREF="motion.html#it">it</A> with &quot;<A HREF="#:luafile">:luafile</A> &#37;&quot;.
    3. Use &quot;:Watch &#37;&quot; to watch any file.
    4. Try editing the file from another text editor.
    5. Observe that the file reloads in Nvim (because on_change() calls
       |<A HREF="editing.html#:checktime">:checktime</A>|).

<B>    local w = vim.loop.new_fs_event()</B>
<B>    local function on_change(err, fname, status)</B>
<B>      -- Do work...</B>
<B>      vim.api.nvim_command('checktime')</B>
<B>      -- Debounce: stop/start.</B>
<B>      w:stop()</B>
<B>      watch_file(fname)</B>
<B>    end</B>
<B>    function watch_file(fname)</B>
<B>      local fullpath = vim.api.nvim_call_function(</B>
<B>        'fnamemodify', {fname, ':p'})</B>
<B>      w:start(fullpath, {}, vim.schedule_wrap(function(...)</B>
<B>        on_change(...) end))</B>
<B>    end</B>
<B>    vim.api.nvim_command(</B>
<B>      "command! -nargs=1 Watch call luaeval('watch_file(_A)', expand('&lt;args&gt;'))")</B>



Example: TCP echo-server				*<A NAME="tcp-server"></A><B>tcp-server</B>*
    1. Save this code to a file.
    2. Execute <A HREF="motion.html#it">it</A> with &quot;<A HREF="#:luafile">:luafile</A> &#37;&quot;.
    3. Note the port number.
    4. Connect from any TCP client (e.g. &quot;nc 0.0.0.0 36795&quot;):

<B>    local function create_server(host, port, on_connect)</B>
<B>      local server = vim.loop.new_tcp()</B>
<B>      server:bind(host, port)</B>
<B>      server:listen(128, function(err)</B>
<B>        assert(not err, err)  -- Check for errors.</B>
<B>        local sock = vim.loop.new_tcp()</B>
<B>        server:accept(sock)  -- Accept client connection.</B>
<B>        on_connect(sock)  -- Start reading messages.</B>
<B>      end)</B>
<B>      return server</B>
<B>    end</B>
<B>    local server = create_server('0.0.0.0', 0, function(sock)</B>
<B>      sock:read_start(function(err, chunk)</B>
<B>        assert(not err, err)  -- Check for errors.</B>
<B>        if chunk then</B>
<B>          sock:write(chunk)  -- Echo received messages to the channel.</B>
<B>        else  -- EOF (stream closed).</B>
<B>          sock:close()  -- Always close handles to avoid leaks.</B>
<B>        end</B>
<B>      end)</B>
<B>    end)</B>
<B>    print('TCP echo-server listening on port: '..server:getsockname().port)</B>

------------------------------------------------------------------------------

VIM.HIGHLIGHT                  				*<A NAME="lua-highlight"></A><B>lua-highlight</B>*

Nvim includes a function for highlighting a selection on <A HREF="change.html#yank">yank</A> (see for example
https://github.com/machakann/vim-highlightedyank). To enable <A HREF="motion.html#it">it</A>, add

<B> au TextYankPost * silent! lua vim.highlight.on_yank()</B>
 
to your `init.vim`. You can customize the highlight group and the duration of
the highlight via

<B> au TextYankPost * silent! lua vim.highlight.on_yank {higroup="IncSearch", timeout=150}</B>
 
If you want to exclude visual selections from highlighting on <A HREF="change.html#yank">yank</A>, use

<B> au TextYankPost * silent! lua vim.highlight.on_yank {on_visual=false}</B>
 


vim.highlight.on_yank({opts})                         *<A NAME="vim.highlight.on_yank()"></A><B>vim.highlight.on_yank()</B>*
        Highlights the yanked text. The fields of the optional <A HREF="eval.html#dict">dict</A> {opts}
        <A HREF="intro.html#control">control</A> the highlight:
          - {higroup} highlight group for yanked region (default `&quot;IncSearch&quot;`)
          - {timeout} time in ms before highlight is cleared (default `150`)
          - {on_macro} highlight when executing <A HREF="map.html#macro">macro</A> (default `false`)
          - {on_visual} highlight when yanking visual selection (default `true`)
          - <A HREF="autocmd.html#{event}">{event}</A> event structure (default `vim.v.event`)

vim.highlight.range({bufnr}, {ns}, {higroup}, {start}, {finish}, {rtype}, {inclusive})

                                                       *<A NAME="vim.highlight.range()"></A><B>vim.highlight.range()</B>*
        Highlights the range between {start} and {finish} (tuples of {line,col})
        in buffer {bufnr} with the highlight group {higroup} using the namespace
        {ns}. Optional arguments are the type of range (characterwise, <A HREF="motion.html#linewise">linewise</A>,
        or blockwise, see |<A HREF="intro.html#setreg">setreg</A>|; default to <A HREF="motion.html#characterwise">characterwise</A>) and whether the
        range is <A HREF="motion.html#inclusive">inclusive</A> (default false).

------------------------------------------------------------------------------

VIM.REGEX							*<A NAME="lua-regex"></A><B>lua-regex</B>*

Vim regexes can be used directly from <A HREF="#lua">lua</A>. Currently they only allow
matching within a single line.


vim.regex({re})						*<A NAME="vim.regex()"></A><B>vim.regex()</B>*

        Parse the regex {re} and return a regex object. <A HREF="options.html#'magic'">'magic'</A> and
        <A HREF="options.html#'ignorecase'">'ignorecase'</A> <A HREF="options.html#options">options</A> are ignored, <A HREF="#lua">lua</A> regexes always defaults to magic
        and ignoring <A HREF="change.html#case">case</A>.  The behavior can be changed with flags in
        the beginning of the <A HREF="eval.html#string">string</A> |<A HREF="pattern.html#/magic">/magic</A>|.

Regex <A HREF="vimindex.html#objects">objects</A> support the following methods:


regex:match_str({str})					*<A NAME="regex:match_str()"></A><B>regex:match_str()</B>*
        Match the <A HREF="eval.html#string">string</A> against the regex. If the <A HREF="eval.html#string">string</A> should match the
        regex precisely, surround the regex with `^` and `$`.
        If the was a match, the byte indices for the beginning and end of
        the match is returned. When there is no match, `nil` is returned.
        As any integer is truth-y, `regex:match()` can be directly used
        <A HREF="motion.html#as">as</A> a condition in an if-statement.


regex:match_line({bufnr}, {line_idx}[, {start}, {end}])	*<A NAME="regex:match_line()"></A><B>regex:match_line()</B>*
        Match line {line_idx} (zero-based) in buffer {bufnr}. If {start} and
        {end} are supplied, match only this byte index range. Otherwise see
        |<A HREF="#regex:match_str()">regex:match_str()</A>|. If {start} is used, then the returned byte
        indices will be relative {start}.

------------------------------------------------------------------------------

VIM							*<A NAME="lua-builtin"></A><B>lua-builtin</B>*


vim.api.{func}({...})					*<A NAME="vim.api"></A><B>vim.api</B>*
        Invokes Nvim |<A HREF="api.html#API">API</A>| function {func} with arguments {...}.
        Example: call the &quot;<A HREF="api.html#nvim_get_current_line()">nvim_get_current_line()</A>&quot; <A HREF="api.html#API">API</A> function:
<B>            print(tostring(vim.api.nvim_get_current_line()))</B>


vim.version()    					*<A NAME="vim.version"></A><B>vim.version</B>*
        Returns the version of the current neovim build.


<A HREF="#vim.in_fast_event()">vim.in_fast_event()</A>					*<A NAME="vim.in_fast_event()"></A><B>vim.in_fast_event()</B>*
        Returns true if the code is executing <A HREF="motion.html#as">as</A> part of a &quot;fast&quot; event
        handler, where most of the <A HREF="api.html#API">API</A> is disabled. These are low-level <A HREF="autocmd.html#events">events</A>
        (e.g. |<A HREF="#lua-loop-callbacks">lua-loop-callbacks</A>|) which can be invoked whenever Nvim polls
        for input.  When this is `false` most <A HREF="api.html#API">API</A> <A HREF="eval.html#functions">functions</A> are callable (but
        may be subject to other restrictions such <A HREF="motion.html#as">as</A> |<A HREF="eval.html#textlock">textlock</A>|).


<A HREF="#vim.NIL">vim.NIL</A>								    *<A NAME="vim.NIL"></A><B>vim.NIL</B>*
	Special value used to represent NIL in <A HREF="api.html#msgpack-rpc">msgpack-rpc</A> and |<A HREF="eval.html#v:null">v:null</A>| in
	vimL interaction, and similar cases. <A HREF="#Lua">Lua</A> `nil` cannot be used <A HREF="motion.html#as">as</A>
	part of a <A HREF="#lua">lua</A> table representing a <A HREF="eval.html#Dictionary">Dictionary</A> or Array, <A HREF="motion.html#as">as</A> <A HREF="motion.html#it">it</A>
	is equivalent to a missing value: `{&quot;foo&quot;, nil}` is the same <A HREF="motion.html#as">as</A> 
	`{&quot;foo&quot;}`


<A HREF="#vim.empty_dict()">vim.empty_dict()</A>					    *<A NAME="vim.empty_dict()"></A><B>vim.empty_dict()</B>*
	Creates a special table which will be converted to an empty
	dictionary when converting <A HREF="#lua">lua</A> values to vimL or <A HREF="api.html#API">API</A> types. The
	table is empty, and this property is marked using a metatable. An
	empty table `{}` without this metatable will default to convert to
	an array/list.

	Note: if numeric keys are added to the table, the metatable will be
	ignored and the <A HREF="eval.html#dict">dict</A> converted to a list/array anyway.


vim.region({bufnr}, {pos1}, {pos2}, {type}, {inclusive})       *<A NAME="vim.region()"></A><B>vim.region()</B>*
        Converts a selection specified by the buffer ({bufnr}), starting
        position ({pos1}, a zero-indexed pair `{line1,column1}`), ending
        position ({pos2}, same format <A HREF="motion.html#as">as</A> {pos1}), the type of the <A HREF="intro.html#register">register</A>
        for the selection ({type}, see |<A HREF="intro.html#regtype">regtype</A>|), and a <A HREF="options.html#boolean">boolean</A> indicating
        whether the selection is <A HREF="motion.html#inclusive">inclusive</A> or not, into a zero-indexed table 
        of <A HREF="motion.html#linewise">linewise</A> selections of the form `{linenr = {startcol, endcol}}` .


                                             *<A NAME="vim.register_keystroke_callback()"></A><B>vim.register_keystroke_callback()</B>*
vim.register_keystroke_callback({fn}, {ns_id})
        Register a <A HREF="#lua">lua</A> {fn} with an {ns_id} to be run after every keystroke.

<B><FONT color="#54A23D">        Parameters: </FONT></B>
            {fn}: (function): Function to call on keystroke.
                    It should take one argument, which is a <A HREF="eval.html#string">string</A>.
                    The <A HREF="eval.html#string">string</A> will contain the literal keys typed.
                    See |<A HREF="insert.html#i_CTRL-V">i_CTRL-V</A>|

                    If {fn} is `nil`, <A HREF="motion.html#it">it</A> removes the callback for the
                    associated {ns_id}.

            {ns_id}: (number)  Namespace ID. If not passed or 0, will generate
                     and return a new namespace ID from |<A HREF="api.html#nvim_create_namespace()">nvim_create_namespace()</A>|

<B><FONT color="#54A23D">        Return: </FONT></B>
            (number) Namespace ID associated with {fn}

        NOTE: {fn} will be automatically removed if an error occurs while
        calling. This is to prevent the annoying situation of every keystroke
        erroring while trying to remove a broken callback.

        NOTE: {fn} will receive the keystrokes after mappings have been
        evaluated


        NOTE: {fn} will *<A NAME="NOT"></A><B>NOT</B>* be cleared from |<A HREF="api.html#nvim_buf_clear_namespace()">nvim_buf_clear_namespace()</A>|


vim.rpcnotify({channel}, {method}[, {args}...])		    *<A NAME="vim.rpcnotify()"></A><B>vim.rpcnotify()</B>*
	Sends <A HREF="autocmd.html#{event}">{event}</A> to {channel} via |<A HREF="api.html#RPC">RPC</A>| and returns immediately.
	If {channel} is 0, the event is broadcast to all channels.

	This function also works in a fast callback |<A HREF="#lua-loop-callbacks">lua-loop-callbacks</A>|.


vim.rpcrequest({channel}, {method}[, {args}...])	    *<A NAME="vim.rpcrequest()"></A><B>vim.rpcrequest()</B>*
	Sends a request to {channel} to invoke {method} via
	|<A HREF="api.html#RPC">RPC</A>| and blocks until a response is received.

	Note: NIL values <A HREF="motion.html#as">as</A> part of the return value is represented <A HREF="motion.html#as">as</A>
	|<A HREF="vim.html">vim.NIL</A>| special value


vim.stricmp({a}, {b})					*<A NAME="vim.stricmp()"></A><B>vim.stricmp()</B>*
        Compares strings case-insensitively.  Returns 0, 1 or -1 if strings
        are equal, {a} is greater than {b} or {a} is lesser than {b},
        respectively.


vim.str_utfindex({str}[, {index}])			*<A NAME="vim.str_utfindex()"></A><B>vim.str_utfindex()</B>*
        Convert byte index to UTF-32 and UTF-16 indicies. If {index} is not
        supplied, the length of the <A HREF="eval.html#string">string</A> is used. All indicies are zero-based.
        Returns two values: the UTF-32 and UTF-16 indicies respectively.

        Embedded NUL bytes are treated <A HREF="motion.html#as">as</A> terminating the <A HREF="eval.html#string">string</A>. Invalid
        <A HREF="mbyte.html#UTF-8">UTF-8</A> bytes, and embedded surrogates are counted <A HREF="motion.html#as">as</A> one code
        point each. An {index} in the middle of a <A HREF="mbyte.html#UTF-8">UTF-8</A> sequence is rounded
        upwards to the end of that sequence.


vim.str_byteindex({str}, {index}[, {use_utf16}])	*<A NAME="vim.str_byteindex()"></A><B>vim.str_byteindex()</B>*
        Convert UTF-32 or UTF-16 {index} to byte index. If {use_utf16} is not
        supplied, <A HREF="motion.html#it">it</A> defaults to false (use UTF-32). Returns the byte index.

        Invalid <A HREF="mbyte.html#UTF-8">UTF-8</A> and NUL is treated like by |<A HREF="vim.html">vim.str_byteindex()</A>|. An {index}
        in the middle of a UTF-16 sequence is rounded upwards to the end of that
        sequence.


vim.schedule({callback})				*<A NAME="vim.schedule()"></A><B>vim.schedule()</B>*
        Schedules {callback} to be invoked soon by the main event-loop. Useful
        to avoid |<A HREF="eval.html#textlock">textlock</A>| or other temporary restrictions.



vim.defer_fn({fn}, {timeout})                                    *<A NAME="vim.defer_fn"></A><B>vim.defer_fn</B>*
    Defers calling {fn} until {timeout} ms passes.  Use to <A HREF="diff.html#do">do</A> a one-shot <A HREF="eval.html#timer">timer</A>
    that calls {fn}.

    Note: The {fn} is |schedule_wrap|ped automatically, so <A HREF="api.html#API">API</A> <A HREF="eval.html#functions">functions</A> are
    safe to call.

<B><FONT color="#54A23D">    Parameters: </FONT></B>
        {fn}        Callback to call once {timeout} expires
        {timeout}   Time in ms to wait before calling {fn}

<B><FONT color="#54A23D">    Returns: </FONT></B>
        |<A HREF="vim.html">vim.loop</A>|.new_timer() object


vim.wait({time} [, {callback}, {interval}, {fast_only}])          *<A NAME="vim.wait()"></A><B>vim.wait()</B>*
        Wait for {time} in milliseconds until {callback} returns `true`.

        Executes {callback} immediately and at approximately {interval}
        milliseconds (default 200). Nvim still processes other <A HREF="autocmd.html#events">events</A> during
        this time.

<B><FONT color="#54A23D">    Parameters: </FONT></B>
        {time}      <A HREF="eval.html#Number">Number</A> of milliseconds to wait
        {callback}  Optional callback. Waits until {callback} returns true
        {interval}  (Approximate) number of milliseconds to wait between polls
        {fast_only} If true, only |<A HREF="api.html#api-fast">api-fast</A>| <A HREF="autocmd.html#events">events</A> will be processed.
                        If called from while in an |<A HREF="api.html#api-fast">api-fast</A>| event, will
                        automatically be set to `true`.

<B><FONT color="#54A23D">    Returns: </FONT></B>
        If {callback} returns `true` during the {time}:
            `true, nil`

        If {callback} never returns `true` during the {time}:
            `false, -1`

        If {callback} is interrupted during the {time}:
            `false, -2`

        If {callback} <A HREF="message.html#errors">errors</A>, the error is raised.

        Examples:

<B>    ---</B>
<B>    -- Wait for 100 ms, allowing other events to process</B>
<B>    vim.wait(100, function() end)</B>

<B>    ---</B>
<B>    -- Wait for 100 ms or until global variable set.</B>
<B>    vim.wait(100, function() return vim.g.waiting_for_var end)</B>

<B>    ---</B>
<B>    -- Wait for 1 second or until global variable set, checking every ~500 ms</B>
<B>    vim.wait(1000, function() return vim.g.waiting_for_var end, 500)</B>

<B>    ---</B>
<B>    -- Schedule a function to set a value in 100ms</B>
<B>    vim.defer_fn(function() vim.g.timer_result = true end, 100)</B>

<B>    -- Would wait ten seconds if results blocked. Actually only waits  100 ms</B>
<B>    if vim.wait(10000, function() return vim.g.timer_result end) then</B>
<B>      print('Only waiting a little bit of time!')</B>
<B>    end</B>
 


<A HREF="#vim.type_idx">vim.type_idx</A>						*<A NAME="vim.type_idx"></A><B>vim.type_idx</B>*
	Type index for use in |<A HREF="#lua-special-tbl">lua-special-tbl</A>|.  Specifying one of the 
	values from |<A HREF="vim.html">vim.types</A>| allows typing the empty table (it is 
	unclear whether empty <A HREF="#Lua">Lua</A> table represents empty <A HREF="eval.html#list">list</A> or empty array) 
	and forcing integral numbers to be |<A HREF="eval.html#Float">Float</A>|.  See |<A HREF="#lua-special-tbl">lua-special-tbl</A>| for 
	more details.


<A HREF="#vim.val_idx">vim.val_idx</A>						*<A NAME="vim.val_idx"></A><B>vim.val_idx</B>*
	Value index for tables representing |<A HREF="eval.html#Float">Float</A>|<A HREF="change.html#s">s</A>.  A table representing 
	floating-point value 1.0 looks like this:
<B>            {</B>
<B>              [vim.type_idx] = vim.types.float,</B>
<B>              [vim.val_idx] = 1.0,</B>
<B>            }</B>
 	See also |<A HREF="vim.html">vim.type_idx</A>| and |<A HREF="#lua-special-tbl">lua-special-tbl</A>|.


<A HREF="#vim.types">vim.types</A>						*<A NAME="vim.types"></A><B>vim.types</B>*
	Table with possible values for |<A HREF="vim.html">vim.type_idx</A>|.  Contains two sets 
	of key-value pairs: first maps possible values for |<A HREF="vim.html">vim.type_idx</A>| 
	to human-readable strings, second maps human-readable type names to 
	values for |<A HREF="vim.html">vim.type_idx</A>|.  Currently contains pairs for `float`, 
	`array` and `dictionary` types.

	Note: one must expect that values corresponding to `vim.types.float`, 
	`vim.types.array` and `vim.types.dictionary` fall under only two 
	following assumptions:
	1. Value may serve both <A HREF="motion.html#as">as</A> a key and <A HREF="motion.html#as">as</A> a value in a table.  Given the 
	   properties of <A HREF="#Lua">Lua</A> tables this basically means “value is not `nil`”.
	2. For each value in `vim.types` table `vim.types[vim.types[value]]` 
	   is the same <A HREF="motion.html#as">as</A> `value`.
	No other restrictions are put on types, and <A HREF="motion.html#it">it</A> is not guaranteed that 
	values corresponding to `vim.types.float`, `vim.types.array` and 
	`vim.types.dictionary` will not change or that `vim.types` table will 
	only contain values for these three types.

------------------------------------------------------------------------------

LUA-VIMSCRIPT BRIDGE                                    *<A NAME="lua-vimscript"></A><B>lua-vimscript</B>*

Nvim <A HREF="#Lua">Lua</A> provides an interface to Vimscript <A HREF="eval.html#variables">variables</A> and <A HREF="eval.html#functions">functions</A>, and
editor commands and <A HREF="options.html#options">options</A>.
See also https://github.com/nanotee/nvim-lua-guide.


vim.call({func}, {...})					*<A NAME="vim.call()"></A><B>vim.call()</B>*
        Invokes |<A HREF="eval.html#vim-function">vim-function</A>| or |<A HREF="eval.html#user-function">user-function</A>| {func} with arguments {...}.
        See also |<A HREF="#vim.fn">vim.fn</A>|.
        Equivalent to:
<B>            vim.fn[func]({...})</B>


vim.cmd({cmd})                                          *<A NAME="vim.cmd()"></A><B>vim.cmd()</B>*
        Invokes an <A HREF="intro.html#Ex">Ex</A> command (the &quot;<A HREF="cmdline.html#:">:</A>&quot; commands, Vimscript statements).
        See also |<A HREF="vimindex.html#ex-cmd-index">ex-cmd-index</A>|.
        Example:
<B>            vim.cmd('echo 42')</B>


vim.fn.{func}({...})					*<A NAME="vim.fn"></A><B>vim.fn</B>*
        Invokes |<A HREF="eval.html#vim-function">vim-function</A>| or |<A HREF="eval.html#user-function">user-function</A>| {func} with arguments {...}.
        To call <A HREF="eval.html#autoload">autoload</A> <A HREF="eval.html#functions">functions</A>, use the <A HREF="syntax.html#syntax">syntax</A>:
<B>            vim.fn['some#function']({...})</B>
 
        Unlike <A HREF="#vim.api">vim.api</A>.|<A HREF="intro.html#nvim_call_function">nvim_call_function</A>| this converts directly between Vim
        <A HREF="vimindex.html#objects">objects</A> and <A HREF="#Lua">Lua</A> <A HREF="vimindex.html#objects">objects</A>. If the Vim function returns a float, <A HREF="motion.html#it">it</A> will
        be represented directly <A HREF="motion.html#as">as</A> a <A HREF="#Lua">Lua</A> number. Empty lists and dictionaries
        both are represented by an empty table.

        Note: |<A HREF="eval.html#v:null">v:null</A>| values <A HREF="motion.html#as">as</A> part of the return value is represented <A HREF="motion.html#as">as</A>
        |<A HREF="vim.html">vim.NIL</A>| special value

        Note: <A HREF="#vim.fn">vim.fn</A> keys are generated lazily, thus `pairs(vim.fn)` only
        enumerates <A HREF="eval.html#functions">functions</A> that were called at least once.



                                                        *<A NAME="lua-vim-variables"></A><B>lua-vim-variables</B>*
The Vim editor global dictionaries |<A HREF="eval.html#g:">g:</A>| |<A HREF="eval.html#w:">w:</A>| |<A HREF="eval.html#b:">b:</A>| |<A HREF="eval.html#t:">t:</A>| |<A HREF="eval.html#v:">v:</A>| can be accessed
from <A HREF="#Lua">Lua</A> conveniently and idiomatically by referencing the `vim.*` <A HREF="#Lua">Lua</A> tables
described below. In this way you can easily read and modify global Vimscript
<A HREF="eval.html#variables">variables</A> from <A HREF="#Lua">Lua</A>.

Example:

<B>    vim.g.foo = 5     -- Set the g:foo Vimscript variable.</B>
<B>    print(vim.g.foo)  -- Get and print the g:foo Vimscript variable.</B>
<B>    vim.g.foo = nil   -- Delete (:unlet) the Vimscript variable.</B>


<A HREF="#vim.g">vim.g</A>                                                   *<A NAME="vim.g"></A><B>vim.g</B>*
        Global (|<A HREF="eval.html#g:">g:</A>|) editor <A HREF="eval.html#variables">variables</A>.
        Key with no value returns `nil`.


<A HREF="#vim.b">vim.b</A>                                                   *<A NAME="vim.b"></A><B>vim.b</B>*
        Buffer-scoped (|<A HREF="eval.html#b:">b:</A>|) <A HREF="eval.html#variables">variables</A> for the current buffer.
        Invalid or unset key returns `nil`.


<A HREF="#vim.w">vim.w</A>                                                   *<A NAME="vim.w"></A><B>vim.w</B>*
        Window-scoped (|<A HREF="eval.html#w:">w:</A>|) <A HREF="eval.html#variables">variables</A> for the current <A HREF="windows.html#window">window</A>.
        Invalid or unset key returns `nil`.


<A HREF="#vim.t">vim.t</A>                                                   *<A NAME="vim.t"></A><B>vim.t</B>*
        Tabpage-scoped (|<A HREF="eval.html#t:">t:</A>|) <A HREF="eval.html#variables">variables</A> for the current <A HREF="tabpage.html#tabpage">tabpage</A>.
        Invalid or unset key returns `nil`.


<A HREF="#vim.v">vim.v</A>                                                   *<A NAME="vim.v"></A><B>vim.v</B>*
        |<A HREF="eval.html#v:">v:</A>| <A HREF="eval.html#variables">variables</A>.
        Invalid or unset key returns `nil`.


<A HREF="#vim.env">vim.env</A>                                                 *<A NAME="vim.env"></A><B>vim.env</B>*
        Environment <A HREF="eval.html#variables">variables</A> defined in the editor session.
        See |<A HREF="options.html#expand-env">expand-env</A>| and |<A HREF="eval.html#:let-environment">:let-environment</A>| for the Vimscript behavior.
        Invalid or unset key returns `nil`.
        Example:
<B>            vim.env.FOO = 'bar'</B>
<B>            print(vim.env.TERM)</B>
 


                                                        *<A NAME="lua-vim-options"></A><B>lua-vim-options</B>*
From <A HREF="#Lua">Lua</A> you can work with editor |<A HREF="options.html#options">options</A>| by reading and setting items in
these <A HREF="#Lua">Lua</A> tables:


<A HREF="#vim.o">vim.o</A>                                                   *<A NAME="vim.o"></A><B>vim.o</B>*
        Get or set editor <A HREF="options.html#options">options</A>, like |<A HREF="options.html#:set">:set</A>|. Invalid key is an error.
        Example:
<B>            vim.o.cmdheight = 4</B>
<B>            print(vim.o.columns)</B>


<A HREF="#vim.bo">vim.bo</A>                                                  *<A NAME="vim.bo"></A><B>vim.bo</B>*
        Get or set buffer-scoped |<A HREF="options.html#local-options">local-options</A>|. Invalid key is an error.
        Example:
<B>            vim.bo.buflisted = true</B>
<B>            print(vim.bo.comments)</B>


<A HREF="#vim.wo">vim.wo</A>                                                  *<A NAME="vim.wo"></A><B>vim.wo</B>*
        Get or set window-scoped |<A HREF="options.html#local-options">local-options</A>|. Invalid key is an error.
        Example:
<B>            vim.wo.cursorcolumn = true</B>
<B>            print(vim.wo.foldmarker)</B>


==============================================================================

<A HREF="#Lua">Lua</A> module: vim                                                      *<A NAME="lua-vim"></A><B>lua-vim</B>*


inspect({object}, {options})                                   *<A NAME="vim.inspect()"></A><B>vim.inspect()</B>*
                Return a human-readable representation of the given object.

<B><FONT color="#54A23D">                See also: </FONT></B>
                    https://github.com/kikito/inspect.lua
                    https://github.com/mpeterv/vinspect


make_meta_accessor({get}, {set}, {del})             *<A NAME="vim.make_meta_accessor()"></A><B>vim.make_meta_accessor()</B>*
                TODO: Documentation


paste({lines}, {phase})                                          *<A NAME="vim.paste()"></A><B>vim.paste()</B>*
                Paste handler, invoked by |<A HREF="api.html#nvim_paste()">nvim_paste()</A>| when a conforming <A HREF="ui.html#UI">UI</A>
                (such <A HREF="motion.html#as">as</A> the |<A HREF="term.html#TUI">TUI</A>|) pastes text into the editor.

                Example: To remove ANSI color codes when pasting:

<B>                 vim.paste = (function(overridden)</B>
<B>                   return function(lines, phase)</B>
<B>                     for i,line in ipairs(lines) do</B>
<B>                       -- Scrub ANSI color codes from paste input.</B>
<B>                       lines[i] = line:gsub('\27%[[0-9;mK]+', '')</B>
<B>                     end</B>
<B>                     overridden(lines, phase)</B>
<B>                   end</B>
<B>                 end)(vim.paste)</B>
 

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {lines}  |readfile()|-style <A HREF="eval.html#list">list</A> of lines to <A HREF="provider.html#paste">paste</A>.
                             |<A HREF="channel.html#channel-lines">channel-lines</A>|
                    {phase}  -1: &quot;non-streaming&quot; <A HREF="provider.html#paste">paste</A>: the call contains all
                             lines. If <A HREF="provider.html#paste">paste</A> is &quot;streamed&quot;, `phase` indicates the stream state:
                             • 1: starts the <A HREF="provider.html#paste">paste</A> (exactly once)
                             • 2: continues the <A HREF="provider.html#paste">paste</A> (zero or more times)
                             • 3: ends the <A HREF="provider.html#paste">paste</A> (exactly once)

<B><FONT color="#54A23D">                Return: </FONT></B>
                    false if client should cancel the <A HREF="provider.html#paste">paste</A>.

<B><FONT color="#54A23D">                See also: </FONT></B>
                    |<A HREF="provider.html#paste">paste</A>|


schedule_wrap({cb})                                      *<A NAME="vim.schedule_wrap()"></A><B>vim.schedule_wrap()</B>*
                Defers callback `cb` until the Nvim <A HREF="api.html#API">API</A> is safe to call.

<B><FONT color="#54A23D">                See also: </FONT></B>
                    |<A HREF="#lua-loop-callbacks">lua-loop-callbacks</A>|
                    |<A HREF="vim.html">vim.schedule()</A>|
                    |<A HREF="vim.html">vim.in_fast_event()</A>|





deep_equal({a}, {b})                                        *<A NAME="vim.deep_equal()"></A><B>vim.deep_equal()</B>*
                TODO: Documentation


deepcopy({orig})                                              *<A NAME="vim.deepcopy()"></A><B>vim.deepcopy()</B>*
                Returns a deep copy of the given object. Non-table <A HREF="vimindex.html#objects">objects</A> are
                copied <A HREF="motion.html#as">as</A> in a typical <A HREF="#Lua">Lua</A> assignment, whereas table <A HREF="vimindex.html#objects">objects</A>
                are copied recursively. Functions are naively copied, so
                <A HREF="eval.html#functions">functions</A> in the copied table point to the same <A HREF="eval.html#functions">functions</A> <A HREF="motion.html#as">as</A>
                those in the input table. Userdata and threads are not copied
                and will throw an error.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {orig}  Table to copy

<B><FONT color="#54A23D">                Return: </FONT></B>
                    New table of copied keys and (nested) values.


endswith({s}, {suffix})                                       *<A NAME="vim.endswith()"></A><B>vim.endswith()</B>*
                Tests if `s` ends with `suffix` .

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {s}       (string) a <A HREF="eval.html#string">string</A>
                    {suffix}  (string) a suffix

<B><FONT color="#54A23D">                Return: </FONT></B>
                    (boolean) true if `suffix` is a suffix of <A HREF="change.html#s">s</A>


gsplit({s}, {sep}, {plain})                                     *<A NAME="vim.gsplit()"></A><B>vim.gsplit()</B>*
                Splits a <A HREF="eval.html#string">string</A> at each instance of a separator.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {s}      <A HREF="eval.html#String">String</A> to split
                    {sep}    Separator <A HREF="eval.html#string">string</A> or <A HREF="pattern.html#pattern">pattern</A>
                    {plain}  If `true` use `sep` literally (passed to
                             String.find)

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Iterator over the split components

<B><FONT color="#54A23D">                See also: </FONT></B>
                    |<A HREF="vim.html">vim.split()</A>|
                    https://www.lua.org/pil/20.2.html
	<A HREF="http://lua-users.org/wiki/StringLibraryTutorial">http://lua-users.org/wiki/StringLibraryTutorial</A>


is_callable({f})                                           *<A NAME="vim.is_callable()"></A><B>vim.is_callable()</B>*
                Returns true if object `f` can be called <A HREF="motion.html#as">as</A> a function.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {f}  Any object

<B><FONT color="#54A23D">                Return: </FONT></B>
                    true if `f` is callable, else false


is_valid({opt})                                               *<A NAME="vim.is_valid()"></A><B>vim.is_valid()</B>*
                TODO: Documentation


list_extend({dst}, {src}, {start}, {finish})               *<A NAME="vim.list_extend()"></A><B>vim.list_extend()</B>*
                Extends a list-like table with the values of another list-like
                table.

                NOTE: This mutates dst!

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {dst}     <A HREF="eval.html#list">list</A> which will be modified and appended to.
                    {src}     <A HREF="eval.html#list">list</A> from which values will be inserted.
                    {start}   Start index on src. defaults to 1
                    {finish}  Final index on src. defaults to #src

<B><FONT color="#54A23D">                Return: </FONT></B>
                    dst

<B><FONT color="#54A23D">                See also: </FONT></B>
                    |<A HREF="vim.html">vim.tbl_extend()</A>|


list_slice({list}, {start}, {finish})                       *<A NAME="vim.list_slice()"></A><B>vim.list_slice()</B>*
                Creates a copy of a table containing only elements from start
                to end (inclusive)

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {list}    table table
                    {start}   integer Start range of <A HREF="eval.html#slice">slice</A>
                    {finish}  integer End range of <A HREF="eval.html#slice">slice</A>

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Copy of table sliced from start to finish (inclusive)


pesc({s})                                                         *<A NAME="vim.pesc()"></A><B>vim.pesc()</B>*
                Escapes magic chars in a <A HREF="#Lua">Lua</A> <A HREF="pattern.html#pattern">pattern</A>.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {s}  <A HREF="eval.html#String">String</A> to <A HREF="intro.html#escape">escape</A>

<B><FONT color="#54A23D">                Return: </FONT></B>
                    &#37;-escaped <A HREF="pattern.html#pattern">pattern</A> <A HREF="eval.html#string">string</A>

<B><FONT color="#54A23D">                See also: </FONT></B>
                    https://github.com/rxi/lume


split({s}, {sep}, {plain})                                       *<A NAME="vim.split()"></A><B>vim.split()</B>*
                Splits a <A HREF="eval.html#string">string</A> at each instance of a separator.

                Examples:
<B>                 split(":aa::b:", ":")     --&gt; {'','aa','','b',''}</B>
<B>                 split("axaby", "ab?")     --&gt; {'','x','y'}</B>
<B>                 split(x*yz*o, "*", true)  --&gt; {'x','yz','o'}</B>
 

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {s}      <A HREF="eval.html#String">String</A> to split
                    {sep}    Separator <A HREF="eval.html#string">string</A> or <A HREF="pattern.html#pattern">pattern</A>
                    {plain}  If `true` use `sep` literally (passed to
                             String.find)

<B><FONT color="#54A23D">                Return: </FONT></B>
                    List-like table of the split components.

<B><FONT color="#54A23D">                See also: </FONT></B>
                    |<A HREF="vim.html">vim.gsplit()</A>|


startswith({s}, {prefix})                                   *<A NAME="vim.startswith()"></A><B>vim.startswith()</B>*
                Tests if `s` starts with `prefix` .

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {s}       (string) a <A HREF="eval.html#string">string</A>
                    {prefix}  (string) a prefix

<B><FONT color="#54A23D">                Return: </FONT></B>
                    (boolean) true if `prefix` is a prefix of <A HREF="change.html#s">s</A>


tbl_add_reverse_lookup({o})                     *<A NAME="vim.tbl_add_reverse_lookup()"></A><B>vim.tbl_add_reverse_lookup()</B>*
                Add the reverse lookup values to an existing table. For
                example: tbl_add_reverse_lookup { A = 1 } <A HREF="change.html#==">==</A> { [1] = <A HREF="motion.html#'A">'A</A> , A = 1 }`

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {o}  table The table to add the reverse to.


tbl_contains({t}, {value})                                *<A NAME="vim.tbl_contains()"></A><B>vim.tbl_contains()</B>*
                Checks if a list-like (vector) table contains `value` .

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {t}      Table to check
                    {value}  Value to compare

<B><FONT color="#54A23D">                Return: </FONT></B>
                    true if `t` contains `value`


tbl_count({t})                                               *<A NAME="vim.tbl_count()"></A><B>vim.tbl_count()</B>*
                Counts the number of non-nil values in table `t` .


<B>    vim.tbl_count({ a=1, b=2 }) =&gt; 2</B>
<B>    vim.tbl_count({ 1, 2 }) =&gt; 2</B>
 

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {t}  Table

<B><FONT color="#54A23D">                Return: </FONT></B>
                    <A HREF="eval.html#Number">Number</A> that is the number of the value in table

<B><FONT color="#54A23D">                See also: </FONT></B>
                    https://github.com/Tieske/Penlight/blob/master/lua/pl/tablex.lua


tbl_deep_extend({behavior}, {...})                     *<A NAME="vim.tbl_deep_extend()"></A><B>vim.tbl_deep_extend()</B>*
                Merges recursively two or more map-like tables.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {behavior}  Decides what to <A HREF="diff.html#do">do</A> if a key is found in more
                                than one map:
                                • &quot;error&quot;: raise an error
                                • &quot;keep&quot;: use value from the leftmost map
                                • &quot;force&quot;: use value from the rightmost map
                    {...}       Two or more map-like tables.

<B><FONT color="#54A23D">                See also: </FONT></B>
                    |<A HREF="intro.html#tbl_extend()">tbl_extend()</A>|


tbl_extend({behavior}, {...})                               *<A NAME="vim.tbl_extend()"></A><B>vim.tbl_extend()</B>*
                Merges two or more map-like tables.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {behavior}  Decides what to <A HREF="diff.html#do">do</A> if a key is found in more
                                than one map:
                                • &quot;error&quot;: raise an error
                                • &quot;keep&quot;: use value from the leftmost map
                                • &quot;force&quot;: use value from the rightmost map
                    {...}       Two or more map-like tables.

<B><FONT color="#54A23D">                See also: </FONT></B>
                    |<A HREF="eval.html#extend()">extend()</A>|


tbl_filter({func}, {t})                                     *<A NAME="vim.tbl_filter()"></A><B>vim.tbl_filter()</B>*
                Filter a table using a predicate function

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {func}  function or callable table
                    {t}     table


tbl_flatten({t})                                           *<A NAME="vim.tbl_flatten()"></A><B>vim.tbl_flatten()</B>*
                Creates a copy of a list-like table such that any nested
                tables are &quot;unrolled&quot; and appended to the result.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {t}  List-like table

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Flattened copy of the given list-like table.

<B><FONT color="#54A23D">                See also: </FONT></B>
                    Fromhttps://github.com/premake/premake-core/blob/master/src/base/table.lua


tbl_isempty({t})                                           *<A NAME="vim.tbl_isempty()"></A><B>vim.tbl_isempty()</B>*
                Checks if a table is empty.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {t}  Table to check

<B><FONT color="#54A23D">                See also: </FONT></B>
                    https://github.com/premake/premake-core/blob/master/src/base/table.lua


tbl_islist({t})                                             *<A NAME="vim.tbl_islist()"></A><B>vim.tbl_islist()</B>*
                Tests if a <A HREF="#Lua">Lua</A> table can be treated <A HREF="motion.html#as">as</A> an array.

                Empty table `{}` is assumed to be an array, unless <A HREF="motion.html#it">it</A> was
                created by |<A HREF="vim.html">vim.empty_dict()</A>| or returned <A HREF="motion.html#as">as</A> a dict-like |<A HREF="api.html#API">API</A>|
                or Vimscript result, for example from |<A HREF="eval.html#rpcrequest()">rpcrequest()</A>| or
                |<A HREF="#vim.fn">vim.fn</A>|.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {t}  Table

<B><FONT color="#54A23D">                Return: </FONT></B>
                    `true` if array-like table, else `false` .


tbl_keys({t})                                                 *<A NAME="vim.tbl_keys()"></A><B>vim.tbl_keys()</B>*
                Return a <A HREF="eval.html#list">list</A> of all keys used in a table. However, the order
                of the return table of keys is not guaranteed.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {t}  Table

<B><FONT color="#54A23D">                Return: </FONT></B>
                    <A HREF="eval.html#list">list</A> of keys

<B><FONT color="#54A23D">                See also: </FONT></B>
                    Fromhttps://github.com/premake/premake-core/blob/master/src/base/table.lua


tbl_map({func}, {t})                                           *<A NAME="vim.tbl_map()"></A><B>vim.tbl_map()</B>*
                Apply a function to all values of a table.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {func}  function or callable table
                    {t}     table


tbl_values({t})                                             *<A NAME="vim.tbl_values()"></A><B>vim.tbl_values()</B>*
                Return a <A HREF="eval.html#list">list</A> of all values used in a table. However, the
                order of the return table of values is not guaranteed.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {t}  Table

<B><FONT color="#54A23D">                Return: </FONT></B>
                    <A HREF="eval.html#list">list</A> of values


trim({s})                                                         *<A NAME="vim.trim()"></A><B>vim.trim()</B>*
                Trim <A HREF="pattern.html#whitespace">whitespace</A> (Lua <A HREF="pattern.html#pattern">pattern</A> &quot;&#37;s&quot;) from both sides of a
                <A HREF="eval.html#string">string</A>.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {s}  <A HREF="eval.html#String">String</A> to trim

<B><FONT color="#54A23D">                Return: </FONT></B>
                    <A HREF="eval.html#String">String</A> with <A HREF="pattern.html#whitespace">whitespace</A> removed from its beginning and end

<B><FONT color="#54A23D">                See also: </FONT></B>
                    https://www.lua.org/pil/20.2.html


validate({opt})                                               *<A NAME="vim.validate()"></A><B>vim.validate()</B>*
                Validates a parameter specification (types and values).

                Usage example:

<B>                  function user.new(name, age, hobbies)</B>
<B>                    vim.validate{</B>
<B>                      name={name, 'string'},</B>
<B>                      age={age, 'number'},</B>
<B>                      hobbies={hobbies, 'table'},</B>
<B>                    }</B>
<B>                    ...</B>
<B>                  end</B>
 

                Examples with explicit argument values (can be run directly):

<B>                  vim.validate{arg1={{'foo'}, 'table'}, arg2={'foo', 'string'}}</B>
<B>                     =&gt; NOP (success)</B>

<B>                  vim.validate{arg1={1, 'table'}}</B>
<B>                     =&gt; error('arg1: expected table, got number')</B>

<B>                  vim.validate{arg1={3, function(a) return (a % 2) == 0 end, 'even number'}}</B>
<B>                     =&gt; error('arg1: expected even number, got 3')</B>
 

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {opt}  Map of parameter names to validations. Each key is
                           a parameter name; each value is a tuple in one of
                           these forms:
                           1. (arg_value, type_name, optional)
                              • arg_value: argument value
                              • type_name: <A HREF="eval.html#string">string</A> type name, one of: (&quot;table&quot;,
                                &quot;<A HREF="motion.html#t">t</A>&quot;, &quot;<A HREF="eval.html#string">string</A>&quot;, &quot;<A HREF="change.html#s">s</A>&quot;, &quot;number&quot;, &quot;<A HREF="pattern.html#n">n</A>&quot;, &quot;<A HREF="options.html#boolean">boolean</A>&quot;,
                                &quot;<A HREF="motion.html#b">b</A>&quot;, &quot;function&quot;, &quot;<A HREF="motion.html#f">f</A>&quot;, &quot;nil&quot;, &quot;thread&quot;,
                                &quot;userdata&quot;)
                              • optional: (optional) <A HREF="options.html#boolean">boolean</A>, if true, `nil`
                                is valid

                           2. (arg_value, fn, msg)
                              • arg_value: argument value
                              • fn: any function accepting one argument,
                                returns true if and only if the argument is
                                valid. Can optionally return an additional
                                informative error message <A HREF="motion.html#as">as</A> the second
                                returned value.
                              • msg: (optional) error <A HREF="eval.html#string">string</A> if validation
                                fails


==============================================================================

<A HREF="#Lua">Lua</A> module: uri                                                      *<A NAME="lua-uri"></A><B>lua-uri</B>*


uri_from_bufnr({bufnr})                                 *<A NAME="vim.uri_from_bufnr()"></A><B>vim.uri_from_bufnr()</B>*
                Get a URI from a bufnr

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {bufnr}  (number): Buffer number

<B><FONT color="#54A23D">                Return: </FONT></B>
                    URI


uri_from_fname({path})                                  *<A NAME="vim.uri_from_fname()"></A><B>vim.uri_from_fname()</B>*
                Get a URI from a file path.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {path}  (string): Path to file

<B><FONT color="#54A23D">                Return: </FONT></B>
                    URI


uri_to_bufnr({uri})                                       *<A NAME="vim.uri_to_bufnr()"></A><B>vim.uri_to_bufnr()</B>*
                Return or create a buffer for a uri.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {uri}  (string): The URI

<B><FONT color="#54A23D">                Return: </FONT></B>
                    bufnr.

                Note:
                    Creates buffer but does not load <A HREF="motion.html#it">it</A>


uri_to_fname({uri})                                       *<A NAME="vim.uri_to_fname()"></A><B>vim.uri_to_fname()</B>*
                Get a filename from a URI

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {uri}  (string): The URI

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Filename

<A HREF="#top">top</A> - <A HREF="index.html">main help file</A>
</PRE>
    </div>

    <footer>
      <div class="container">
        Generated Sat May  1 05:45:08 UTC 2021 from <a href="https://github.com/neovim/neovim/commit/0150cc41604ebb1b5b5f6920cf4673e541684e75"><code>0150cc4</code></a>.
      </div>
    </footer>
  </body>
</html>
