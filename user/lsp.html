<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <meta content="width=device-width, initial-scale=1" name="viewport">
    <title>Nvim documentation: lsp</title>
    <link href="https://fonts.googleapis.com/css?family=Lato:400,700,900" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.0/normalize.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
    <link href="/css/main.css" rel="stylesheet">
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    
  </head>
  <body>
    <header class="navbar">
      <div class="container">
        <nav class="navbar">
          <div class="container-fluid">
            <div class="navbar-header">

              <a href="/" class="navbar-brand">
                <img src="/images/logo@2x.png" id="navbar-logo" alt="Neovim">
              </a>
            </div>
          </div>
        </nav>
      </div>
    </header>

    <div class="container">
      <h1>Nvim documentation: lsp</h1>
<A NAME="top"></A>
<A HREF="index.html">main help file</A>

<HR>
<PRE>

*<A NAME="lsp.txt"></A><B>lsp.txt</B>*   <A HREF="#LSP">LSP</A>


                            NVIM REFERENCE MANUAL



<A HREF="#LSP">LSP</A> client/framework                                     *<A NAME="lsp"></A><B>lsp</B>* *<A NAME="LSP"></A><B>LSP</B>*

Nvim supports the Language Server Protocol (LSP), which means <A HREF="motion.html#it">it</A> acts <A HREF="motion.html#as">as</A>
a client to <A HREF="#LSP">LSP</A> servers and includes a <A HREF="lua.html#Lua">Lua</A> framework `vim.lsp` for building
enhanced <A HREF="#LSP">LSP</A> tools.

  https://microsoft.github.io/language-server-protocol/

<A HREF="#LSP">LSP</A> facilitates features like go-to-definition, find-references, hover,
completion, rename, format, refactor, etc., using semantic whole-project
analysis (unlike |<A HREF="tagsrch.html#ctags">ctags</A>|).

                                      Type |<A HREF="various.html#gO">gO</A>| to see the table of contents.

==============================================================================

QUICKSTART                                              *<A NAME="lsp-quickstart"></A><B>lsp-quickstart</B>*

Nvim provides an <A HREF="#LSP">LSP</A> client, but the servers are provided by third parties.
Follow these steps to get <A HREF="#LSP">LSP</A> features:

  1. Install the nvim-lspconfig <A HREF="usr_05.html#plugin">plugin</A>.  It provides common configuration for
     various servers so you can get started quickly.
     https://github.com/neovim/nvim-lspconfig
  2. Install a language server. A <A HREF="eval.html#list">list</A> of language servers can be found here:
     https://microsoft.github.io/language-server-protocol/implementors/servers/
     See individual server documentation for installation instructions.
  3. Add `lua require('lspconfig').xx.setup{…}` to your <A HREF="starting.html#init.vim">init.vim</A>, where &quot;xx&quot; is
     the name of the relevant <A HREF="starting.html#config">config</A>. See the nvim-lspconfig README for details.
     NOTE: Make sure to restart <A HREF="nvim.html#nvim">nvim</A> after installing and configuring.
  4. Check that an <A HREF="#LSP">LSP</A> client has attached to the current buffer: 

<B>      :lua print(vim.inspect(vim.lsp.buf_get_clients()))</B>
 

                                                        *<A NAME="lsp-config"></A><B>lsp-config</B>*
Inline diagnostics are enabled automatically, e.g. <A HREF="syntax.html#syntax">syntax</A> <A HREF="message.html#errors">errors</A> will be
annotated in the buffer.  But you probably also want to use other features
like go-to-definition, hover, etc.

While Nvim does not provide an &quot;auto-completion&quot; framework by default, <A HREF="motion.html#it">it</A> is
still possible to get completions from the <A HREF="#LSP">LSP</A> server. To incorporate these
completions, <A HREF="motion.html#it">it</A> is recommended to use |<A HREF="vim.html">vim.lsp.omnifunc</A>|, which is an <A HREF="options.html#'omnifunc'">'omnifunc'</A>
handler. When <A HREF="options.html#'omnifunc'">'omnifunc'</A> is set to `v:lua.vim.lsp.omnifunc`, |<A HREF="insert.html#i_CTRL-X_CTRL-O">i_CTRL-X_CTRL-O</A>|
will provide completions from the language server.

Example <A HREF="starting.html#config">config</A> (in init.vim):

<B>  lua &lt;&lt; EOF</B>
<B>    local custom_lsp_attach = function(client)</B>
<B>      -- See `:help nvim_buf_set_keymap()` for more information</B>
<B>      vim.api.nvim_buf_set_keymap(0, 'n', 'K', '&lt;cmd&gt;lua vim.lsp.buf.hover()&lt;CR&gt;', {noremap = true})</B>
<B>      vim.api.nvim_buf_set_keymap(0, 'n', '&lt;c-]&gt;', '&lt;cmd&gt;lua vim.lsp.buf.definition()&lt;CR&gt;', {noremap = true})</B>
<B>      -- ... and other keymappings for LSP</B>

<B>      -- Use LSP as the handler for omnifunc.</B>
<B>      --    See `:help omnifunc` and `:help ins-completion` for more information.</B>
<B>      vim.api.nvim_buf_set_option(0, 'omnifunc', 'v:lua.vim.lsp.omnifunc')</B>

<B>      -- For plugins with an `on_attach` callback, call them here. For example:</B>
<B>      -- require('completion').on_attach()</B>
<B>    end</B>

<B>    -- An example of configuring for `sumneko_lua`,</B>
<B>    --  a language server for Lua.</B>

<B>    -- set the path to the sumneko installation</B>
<B>    local system_name = "Linux" -- (Linux, macOS, or Windows)</B>
<B>    local sumneko_root_path = '/path/to/lua-language-server'</B>
<B>    local sumneko_binary = sumneko_root_path.."/bin/"..system_name.."/lua-language-server"</B>

<B>    require('lspconfig').sumneko_lua.setup({</B>
<B>      cmd = {sumneko_binary, "-E", sumneko_root_path .. "/main.lua"};</B>
<B>      -- An example of settings for an LSP server.</B>
<B>      --    For more options, see nvim-lspconfig</B>
<B>      settings = {</B>
<B>        Lua = {</B>
<B>          runtime = {</B>
<B>            -- Tell the language server which version of Lua you're using (most likely LuaJIT in the case of Neovim)</B>
<B>            version = 'LuaJIT',</B>
<B>            -- Setup your lua path</B>
<B>            path = vim.split(package.path, ';'),</B>
<B>          },</B>
<B>          diagnostics = {</B>
<B>            -- Get the language server to recognize the `vim` global</B>
<B>            globals = {'vim'},</B>
<B>          },</B>
<B>          workspace = {</B>
<B>            -- Make the server aware of Neovim runtime files</B>
<B>            library = {</B>
<B>              [vim.fn.expand('$VIMRUNTIME/lua')] = true,</B>
<B>              [vim.fn.expand('$VIMRUNTIME/lua/vim/lsp')] = true,</B>
<B>            },</B>
<B>          },</B>
<B>        }</B>
<B>      },</B>

<B>      on_attach = custom_lsp_attach</B>
<B>    })</B>
<B>  EOF</B>
 

Full <A HREF="eval.html#list">list</A> of features provided by default can be found in |<A HREF="#lsp-buf">lsp-buf</A>|.

================================================================================

FAQ                                                     *<A NAME="lsp-faq"></A><B>lsp-faq</B>*

- <A HREF="intro.html#Q">Q</A>: How to force-reload <A HREF="#LSP">LSP</A>?
  A: Stop all clients, then <A HREF="editing.html#reload">reload</A> the buffer.

<B>     :lua vim.lsp.stop_client(vim.lsp.get_active_clients())</B>
<B>     :edit</B>

- <A HREF="intro.html#Q">Q</A>: Why isn't completion working?
  A: In the buffer where you want to use <A HREF="#LSP">LSP</A>, check that <A HREF="options.html#'omnifunc'">'omnifunc'</A> is set to
     &quot;v:lua.vim.lsp.omnifunc&quot;:

<B>     :verbose set omnifunc?</B>

      Some other <A HREF="usr_05.html#plugin">plugin</A> may be overriding the option. To avoid that, you could
     set the option in an |<A HREF="options.html#after-directory">after-directory</A>| <A HREF="usr_41.html#ftplugin">ftplugin</A>, e.g.
     &quot;after/ftplugin/python.vim&quot;.

- <A HREF="intro.html#Q">Q</A>: How <A HREF="diff.html#do">do</A> I run a request synchronously (e.g. for <A HREF="change.html#formatting">formatting</A> on file save)?
  A: Use the `_sync` variant of the function provided by |<A HREF="#lsp-buf">lsp-buf</A>|, if <A HREF="motion.html#it">it</A>
     exists.

     E.g. code <A HREF="change.html#formatting">formatting</A>:

<B>     " Auto-format *.rs (rust) files prior to saving them</B>
<B>     autocmd BufWritePre *.rs lua vim.lsp.buf.formatting_sync(nil, 1000)</B>

 

                                                           *<A NAME="vim.lsp.callbacks"></A><B>vim.lsp.callbacks</B>*
- <A HREF="intro.html#Q">Q</A>: What happened to `vim.lsp.callbacks`?
  A: After better defining the interface of |<A HREF="#lsp-handler">lsp-handler</A>|s, we thought <A HREF="motion.html#it">it</A> best
     to remove the generic usage of `callbacks` and transform to `handlers`.
     Due to this, `vim.lsp.callbacks` was renamed to |<A HREF="vim.html">vim.lsp.handlers</A>|.


                                                           *<A NAME="lsp-vs-treesitter"></A><B>lsp-vs-treesitter</B>*
- <A HREF="intro.html#Q">Q</A>: How <A HREF="diff.html#do">do</A> <A HREF="#LSP">LSP</A> and Treesitter compare?
  A: <A HREF="#LSP">LSP</A> requires a client and language server. The language server uses
     semantic analysis to understand code at a project level. This provides
     language servers with the ability to rename across files, find
     <A HREF="intro.html#definitions">definitions</A> in external libraries and more.

     Treesitter is a language parsing library that provides excellent tools
     for incrementally parsing text and handling <A HREF="message.html#errors">errors</A>. This makes <A HREF="motion.html#it">it</A> a great
     fit for editors to understand the contents of the current file for things
     like <A HREF="syntax.html#syntax">syntax</A> highlighting, simple goto-definitions, scope analysis and
     more.

     <A HREF="#LSP">LSP</A> and Treesitter are both great tools for editing and inspecting code.

================================================================================

<A HREF="#LSP">LSP</A> <A HREF="api.html#API">API</A>                                                 *<A NAME="lsp-api"></A><B>lsp-api</B>*

<A HREF="#LSP">LSP</A> core <A HREF="api.html#API">API</A> is described at |<A HREF="#lsp-core">lsp-core</A>|.  Those are the core <A HREF="eval.html#functions">functions</A> for
creating and managing clients.

The `vim.lsp.buf_…` <A HREF="eval.html#functions">functions</A> perform operations for all <A HREF="#LSP">LSP</A> clients attached
to the given buffer. |<A HREF="#lsp-buf">lsp-buf</A>|

<A HREF="#LSP">LSP</A> request/response handlers are implemented <A HREF="motion.html#as">as</A> <A HREF="lua.html#Lua">Lua</A> <A HREF="eval.html#functions">functions</A> (see
|<A HREF="#lsp-handler">lsp-handler</A>|). The |<A HREF="vim.html">vim.lsp.handlers</A>| table defines default handlers used
when creating a new client. Keys are <A HREF="#LSP">LSP</A> method names:

<B>  :lua print(vim.inspect(vim.tbl_keys(vim.lsp.handlers)))</B>
 

                                                                  *<A NAME="lsp-method"></A><B>lsp-method</B>*

Methods are the names of requests and notifications <A HREF="motion.html#as">as</A> defined by the <A HREF="#LSP">LSP</A>
specification. These <A HREF="#LSP">LSP</A> requests/notifications are defined by default:

    callHierarchy/incomingCalls
    callHierarchy/outgoingCalls
    textDocument/codeAction
    textDocument/completion
    textDocument/declaration*
    textDocument/definition
    textDocument/documentHighlight
    textDocument/documentSymbol
    textDocument/formatting
    textDocument/hover
    textDocument/implementation*
    textDocument/publishDiagnostics
    textDocument/rangeFormatting
    textDocument/references
    textDocument/rename
    textDocument/signatureHelp
    textDocument/typeDefinition*
    window/logMessage
    window/showMessage
    window/showMessageRequest
    workspace/applyEdit
    workspace/symbol

* NOTE: These are sometimes not implemented by servers.


                                                                 *<A NAME="lsp-handler"></A><B>lsp-handler</B>*

<A HREF="#lsp-handlers">lsp-handlers</A> are <A HREF="eval.html#functions">functions</A> with special signatures that are designed to handle
responses and notifications from <A HREF="#LSP">LSP</A> servers.

For |<A HREF="intro.html#lsp-request">lsp-request</A>|, each |<A HREF="#lsp-handler">lsp-handler</A>| has this signature:

<B>  function(err, method, result, client_id, bufnr, config)</B>
 
<B><FONT color="#54A23D">        Parameters: </FONT></B>
            {err}       (table|nil)
                            When the language server is unable to complete a
                            request, a table with information about the error
                            is sent. Otherwise, <A HREF="motion.html#it">it</A> is `nil`. See |<A HREF="#lsp-response">lsp-response</A>|.
            {method}    (string)
                            The |<A HREF="#lsp-method">lsp-method</A>| name.
            {result}    (Result &#124; Params &#124; nil)
                            When the language server is able to succesfully
                            complete a request, this contains the `result` key
                            of the response. See |<A HREF="#lsp-response">lsp-response</A>|.
            {client_id} (number)
                            The ID of the |<A HREF="vim.html">vim.lsp.client</A>|.
            {bufnr}     (Buffer)
                            Buffer handle, or 0 for current.
            {config}    (table)
                            Configuration for the handler.

                            Each handler can define it's own configuration
                            table that allows users to customize the behavior
                            of a particular handler.

                            To configure a particular |<A HREF="#lsp-handler">lsp-handler</A>|, see:
                                |<A HREF="#lsp-handler-configuration">lsp-handler-configuration</A>|

<B><FONT color="#54A23D">        Returns: </FONT></B>
            The |<A HREF="#lsp-handler">lsp-handler</A>| can respond by returning two values: `result, err`
              Where `err` must be shaped like an <A HREF="api.html#RPC">RPC</A> error:
                <A HREF="motion.html#`{">`{</A> code, message, data? }`

            You can use |<A HREF="vim.html">vim.lsp.rpc_response_error()</A>| to create this object.

For |<A HREF="#lsp-notification">lsp-notification</A>|, each |<A HREF="#lsp-handler">lsp-handler</A>| has this signature:

<B>  function(err, method, params, client_id, bufnr, config)</B>
 
<B><FONT color="#54A23D">        Parameters: </FONT></B>
            {err}       (nil)
                            This is always `nil`.
                            See |<A HREF="#lsp-notification">lsp-notification</A>|
            {method}    (string)
                            The |<A HREF="#lsp-method">lsp-method</A>| name.
            {params}    (Params)
                            This contains the `params` key of the notification.
                            See |<A HREF="#lsp-notification">lsp-notification</A>|
            {client_id} (number)
                            The ID of the |<A HREF="vim.html">vim.lsp.client</A>|
            {bufnr}     (nil)
                            `nil`, <A HREF="motion.html#as">as</A> the server doesn't have an associated buffer.
            {config}    (table)
                            Configuration for the handler.

                            Each handler can define it's own configuration
                            table that allows users to customize the behavior
                            of a particular handler.

                            For an example, see:
                                |<A HREF="vim.html">vim.lsp.diagnostic.on_publish_diagnostics()</A>|

                            To configure a particular |<A HREF="#lsp-handler">lsp-handler</A>|, see:
                                |<A HREF="#lsp-handler-configuration">lsp-handler-configuration</A>|

<B><FONT color="#54A23D">        Returns: </FONT></B>
            The |lsp-handler|'s return value will be ignored.


                                                   *<A NAME="lsp-handler-configuration"></A><B>lsp-handler-configuration</B>*

To configure the behavior of a builtin |<A HREF="#lsp-handler">lsp-handler</A>|, the convenient method
|<A HREF="vim.html">vim.lsp.with()</A>| is provided for users.

  To configure the behavior of |<A HREF="vim.html">vim.lsp.diagnostic.on_publish_diagnostics()</A>|,
  consider the following example, where a new |<A HREF="#lsp-handler">lsp-handler</A>| is created using
  |<A HREF="vim.html">vim.lsp.with()</A>| that no longer generates <A HREF="sign.html#signs">signs</A> for the diagnostics:

<B>  vim.lsp.handlers["textDocument/publishDiagnostics"] = vim.lsp.with(</B>
<B>    vim.lsp.diagnostic.on_publish_diagnostics, {</B>
<B>      -- Disable signs</B>
<B>      signs = false,</B>
<B>    }</B>
<B>  )</B>
 
  To enable <A HREF="sign.html#signs">signs</A>, use |<A HREF="vim.html">vim.lsp.with()</A>| again to create and assign a new
  |<A HREF="#lsp-handler">lsp-handler</A>| to |<A HREF="vim.html">vim.lsp.handlers</A>| for the associated method:

<B>   vim.lsp.handlers["textDocument/publishDiagnostics"] = vim.lsp.with(</B>
<B>     vim.lsp.diagnostic.on_publish_diagnostics, {</B>
<B>       -- Enable signs</B>
<B>       signs = true,</B>
<B>     }</B>
<B>   )</B>
 
  To configure a handler on a per-server basis, you can use the {handlers} key
  for |<A HREF="vim.html">vim.lsp.start_client()</A>|

<B>   vim.lsp.start_client {</B>
<B>     ..., -- Other configuration omitted.</B>
<B>     handlers = {</B>
<B>       ["textDocument/publishDiagnostics"] = vim.lsp.with(</B>
<B>         vim.lsp.diagnostic.on_publish_diagnostics, {</B>
<B>           -- Disable virtual_text</B>
<B>           virtual_text = false,</B>
<B>         }</B>
<B>       },</B>
<B>     }</B>
 
  or if using 'nvim-lspconfig', you can use the {handlers} key of `setup()`:

<B>   require('lspconfig').rust_analyzer.setup {</B>
<B>     handlers = {</B>
<B>       ["textDocument/publishDiagnostics"] = vim.lsp.with(</B>
<B>         vim.lsp.diagnostic.on_publish_diagnostics, {</B>
<B>           -- Disable virtual_text</B>
<B>           virtual_text = false</B>
<B>         }</B>
<B>       ),</B>
<B>     }</B>
<B>   }</B>
 

                                                      *<A NAME="lsp-handler-resolution"></A><B>lsp-handler-resolution</B>*
Handlers can be set by:


- Setting a field in |<A HREF="#vim.lsp.handlers">vim.lsp.handlers</A>|.                      *<A NAME="vim.lsp.handlers"></A><B>vim.lsp.handlers</B>*
    |<A HREF="vim.html">vim.lsp.handlers</A>| is a global table that contains the default <A HREF="map.html#mapping">mapping</A> of
    |<A HREF="#lsp-method">lsp-method</A>| names to |<A HREF="#lsp-handlers">lsp-handlers</A>|.

    To override the handler for the `&quot;textDocument/definition&quot;` method:

<B>  vim.lsp.handlers["textDocument/definition"] = my_custom_default_definition</B>
 
- The {handlers} parameter for |<A HREF="vim.html">vim.lsp.start_client</A>|.
    This will set the |<A HREF="#lsp-handler">lsp-handler</A>| <A HREF="motion.html#as">as</A> the default handler for this server.

    For example:

<B>  vim.lsp.start_client {</B>
<B>    ..., -- Other configuration ommitted.</B>
<B>    handlers = {</B>
<B>        ["textDocument/definition"] = my_custom_server_definition</B>
<B>    },</B>
<B>  }</B>

- The {handler} parameter for |<A HREF="vim.html">vim.lsp.buf_request()</A>|.
    This will set the |<A HREF="#lsp-handler">lsp-handler</A>| ONLY for the current request.

    For example:

<B>  vim.lsp.buf_request(</B>
<B>    0,</B>
<B>    "textDocument/definition",</B>
<B>    definition_params,</B>
<B>    my_request_custom_definition</B>
<B>  )</B>
 
In summary, the |<A HREF="#lsp-handler">lsp-handler</A>| will be chosen based on the current |<A HREF="#lsp-method">lsp-method</A>|
in the following order:

1. Handler passed to |<A HREF="vim.html">vim.lsp.buf_request()</A>|, if any.
2. Handler defined in |<A HREF="vim.html">vim.lsp.start_client()</A>|, if any.
3. Handler defined in |<A HREF="vim.html">vim.lsp.handlers</A>|, if any.



VIM.LSP.PROTOCOL                                              *<A NAME="vim.lsp.protocol"></A><B>vim.lsp.protocol</B>*

Module `vim.lsp.protocol` defines constants dictated by the <A HREF="#LSP">LSP</A> specification,
and helper <A HREF="eval.html#functions">functions</A> for creating protocol-related <A HREF="vimindex.html#objects">objects</A>.
https://github.com/microsoft/language-server-protocol/raw/gh-pages/_specifications/specification-3-14.md

For example `vim.lsp.protocol.ErrorCodes` allows reverse lookup by number or
name:

<B>  vim.lsp.protocol.TextDocumentSyncKind.Full == 1</B>
<B>  vim.lsp.protocol.TextDocumentSyncKind[1] == "Full"</B>
 


                                                                *<A NAME="lsp-response"></A><B>lsp-response</B>*
For the format of the response message, see:
    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#responseMessage


                                                                *<A NAME="lsp-notification"></A><B>lsp-notification</B>*
For the format of the notification message, see:
    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#notificationMessage

================================================================================

<A HREF="#LSP">LSP</A> HIGHLIGHT                                                    *<A NAME="lsp-highlight"></A><B>lsp-highlight</B>*

Reference Highlights:

Highlight groups that are meant to be used by |<A HREF="vim.html">vim.lsp.buf.document_highlight()</A>|.

You can see more about the differences in types here:
https://microsoft.github.io/language-server-protocol/specification#textDocument_documentHighlight


                                                           *<A NAME="hl-LspReferenceText"></A><B>hl-LspReferenceText</B>*
LspReferenceText          used for highlighting &quot;text&quot; references

                                                           *<A NAME="hl-LspReferenceRead"></A><B>hl-LspReferenceRead</B>*
LspReferenceRead          used for highlighting &quot;read&quot; references

                                                          *<A NAME="hl-LspReferenceWrite"></A><B>hl-LspReferenceWrite</B>*
LspReferenceWrite         used for highlighting &quot;write&quot; references



                                                   *<A NAME="lsp-highlight-diagnostics"></A><B>lsp-highlight-diagnostics</B>*
All highlights defined for diagnostics begin with `LspDiagnostics` followed by
the type of highlight (e.g., `Sign`, `Underline`, etc.) and then the Severity
of the highlight (e.g. `Error`, `Warning`, etc.)

Sign, <A HREF="syntax.html#underline">underline</A> and virtual text highlights (by default) are linked to their
corresponding LspDiagnosticsDefault highlight.

For example, the default highlighting for |<A HREF="#hl-LspDiagnosticsSignError">hl-LspDiagnosticsSignError</A>| is
linked to |<A HREF="#hl-LspDiagnosticsDefaultError">hl-LspDiagnosticsDefaultError</A>|. To change the default (and
therefore the linked highlights), use the |<A HREF="syntax.html#:highlight">:highlight</A>| command:

<B>    highlight LspDiagnosticsDefaultError guifg="BrightRed"</B>
 


                                               *<A NAME="hl-LspDiagnosticsDefaultError"></A><B>hl-LspDiagnosticsDefaultError</B>*
LspDiagnosticsDefaultError
  Used <A HREF="motion.html#as">as</A> the base highlight group.
  Other LspDiagnostic highlights link to this by default (except Underline)


                                             *<A NAME="hl-LspDiagnosticsDefaultWarning"></A><B>hl-LspDiagnosticsDefaultWarning</B>*
LspDiagnosticsDefaultWarning
  Used <A HREF="motion.html#as">as</A> the base highlight group.
  Other LspDiagnostic highlights link to this by default (except Underline)


                                         *<A NAME="hl-LspDiagnosticsDefaultInformation"></A><B>hl-LspDiagnosticsDefaultInformation</B>*
LspDiagnosticsDefaultInformation
  Used <A HREF="motion.html#as">as</A> the base highlight group.
  Other LspDiagnostic highlights link to this by default (except Underline)


                                                *<A NAME="hl-LspDiagnosticsDefaultHint"></A><B>hl-LspDiagnosticsDefaultHint</B>*
LspDiagnosticsDefaultHint
  Used <A HREF="motion.html#as">as</A> the base highlight group.
  Other LspDiagnostic highlights link to this by default (except Underline)


                                           *<A NAME="hl-LspDiagnosticsVirtualTextError"></A><B>hl-LspDiagnosticsVirtualTextError</B>*
LspDiagnosticsVirtualTextError
  Used for &quot;Error&quot; diagnostic virtual text.
  See |<A HREF="vim.html">vim.lsp.diagnostic.set_virtual_text()</A>|


                                         *<A NAME="hl-LspDiagnosticsVirtualTextWarning"></A><B>hl-LspDiagnosticsVirtualTextWarning</B>*
LspDiagnosticsVirtualTextWarning
  Used for &quot;Warning&quot; diagnostic virtual text.
  See |<A HREF="vim.html">vim.lsp.diagnostic.set_virtual_text()</A>|


                                     *<A NAME="hl-LspDiagnosticsVirtualTextInformation"></A><B>hl-LspDiagnosticsVirtualTextInformation</B>*
LspDiagnosticsVirtualTextInformation
  Used for &quot;Information&quot; diagnostic virtual text.
  See |<A HREF="vim.html">vim.lsp.diagnostic.set_virtual_text()</A>|


                                            *<A NAME="hl-LspDiagnosticsVirtualTextHint"></A><B>hl-LspDiagnosticsVirtualTextHint</B>*
LspDiagnosticsVirtualTextHint
  Used for &quot;Hint&quot; diagnostic virtual text.
  See |<A HREF="vim.html">vim.lsp.diagnostic.set_virtual_text()</A>|


                                             *<A NAME="hl-LspDiagnosticsUnderlineError"></A><B>hl-LspDiagnosticsUnderlineError</B>*
LspDiagnosticsUnderlineError
  Used to <A HREF="syntax.html#underline">underline</A> &quot;Error&quot; diagnostics.
  See |<A HREF="vim.html">vim.lsp.diagnostic.set_underline()</A>|


                                           *<A NAME="hl-LspDiagnosticsUnderlineWarning"></A><B>hl-LspDiagnosticsUnderlineWarning</B>*
LspDiagnosticsUnderlineWarning
  Used to <A HREF="syntax.html#underline">underline</A> &quot;Warning&quot; diagnostics.
  See |<A HREF="vim.html">vim.lsp.diagnostic.set_underline()</A>|


                                       *<A NAME="hl-LspDiagnosticsUnderlineInformation"></A><B>hl-LspDiagnosticsUnderlineInformation</B>*
LspDiagnosticsUnderlineInformation
  Used to <A HREF="syntax.html#underline">underline</A> &quot;Information&quot; diagnostics.
  See |<A HREF="vim.html">vim.lsp.diagnostic.set_underline()</A>|


                                              *<A NAME="hl-LspDiagnosticsUnderlineHint"></A><B>hl-LspDiagnosticsUnderlineHint</B>*
LspDiagnosticsUnderlineHint
  Used to <A HREF="syntax.html#underline">underline</A> &quot;Hint&quot; diagnostics.
  See |<A HREF="vim.html">vim.lsp.diagnostic.set_underline()</A>|


                                              *<A NAME="hl-LspDiagnosticsFloatingError"></A><B>hl-LspDiagnosticsFloatingError</B>*
LspDiagnosticsFloatingError
  Used to color &quot;Error&quot; diagnostic <A HREF="message.html#messages">messages</A> in diagnostics float.
  See |<A HREF="vim.html">vim.lsp.diagnostic.show_line_diagnostics()</A>|


                                            *<A NAME="hl-LspDiagnosticsFloatingWarning"></A><B>hl-LspDiagnosticsFloatingWarning</B>*
LspDiagnosticsFloatingWarning
  Used to color &quot;Warning&quot; diagnostic <A HREF="message.html#messages">messages</A> in diagnostics float.
  See |<A HREF="vim.html">vim.lsp.diagnostic.show_line_diagnostics()</A>|


                                        *<A NAME="hl-LspDiagnosticsFloatingInformation"></A><B>hl-LspDiagnosticsFloatingInformation</B>*
LspDiagnosticsFloatingInformation
  Used to color &quot;Information&quot; diagnostic <A HREF="message.html#messages">messages</A> in diagnostics float.
  See |<A HREF="vim.html">vim.lsp.diagnostic.show_line_diagnostics()</A>|


                                               *<A NAME="hl-LspDiagnosticsFloatingHint"></A><B>hl-LspDiagnosticsFloatingHint</B>*
LspDiagnosticsFloatingHint
  Used to color &quot;Hint&quot; diagnostic <A HREF="message.html#messages">messages</A> in diagnostics float.
  See |<A HREF="vim.html">vim.lsp.diagnostic.show_line_diagnostics()</A>|


                                                  *<A NAME="hl-LspDiagnosticsSignError"></A><B>hl-LspDiagnosticsSignError</B>*
LspDiagnosticsSignError
  Used for &quot;Error&quot; <A HREF="sign.html#signs">signs</A> in sign column.
  See |<A HREF="vim.html">vim.lsp.diagnostic.set_signs()</A>|


                                                *<A NAME="hl-LspDiagnosticsSignWarning"></A><B>hl-LspDiagnosticsSignWarning</B>*
LspDiagnosticsSignWarning
  Used for &quot;Warning&quot; <A HREF="sign.html#signs">signs</A> in sign column.
  See |<A HREF="vim.html">vim.lsp.diagnostic.set_signs()</A>|


                                            *<A NAME="hl-LspDiagnosticsSignInformation"></A><B>hl-LspDiagnosticsSignInformation</B>*
LspDiagnosticsSignInformation
  Used for &quot;Information&quot; <A HREF="sign.html#signs">signs</A> in sign column.
  See |<A HREF="vim.html">vim.lsp.diagnostic.set_signs()</A>|


                                                   *<A NAME="hl-LspDiagnosticsSignHint"></A><B>hl-LspDiagnosticsSignHint</B>*
LspDiagnosticsSignHint
  Used for &quot;Hint&quot; <A HREF="sign.html#signs">signs</A> in sign column.
  See |<A HREF="vim.html">vim.lsp.diagnostic.set_signs()</A>|

==============================================================================

AUTOCOMMANDS                                                *<A NAME="lsp-autocommands"></A><B>lsp-autocommands</B>*


                                                       *<A NAME="LspDiagnosticsChanged"></A><B>LspDiagnosticsChanged</B>*
<A HREF="#LspDiagnosticsChanged">LspDiagnosticsChanged</A>           After receiving publishDiagnostics server response


==============================================================================

<A HREF="lua.html#Lua">Lua</A> module: vim.lsp                                                 *<A NAME="lsp-core"></A><B>lsp-core</B>*


buf_attach_client({bufnr}, {client_id})          *<A NAME="vim.lsp.buf_attach_client()"></A><B>vim.lsp.buf_attach_client()</B>*
                Implements the `textDocument/did…` notifications required to
                track a buffer for any language server.

                Without calling this, the server won't be notified of changes
                to a buffer.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {bufnr}      (number) Buffer handle, or 0 for current
                    {client_id}  (number) Client id


buf_get_clients({bufnr})                           *<A NAME="vim.lsp.buf_get_clients()"></A><B>vim.lsp.buf_get_clients()</B>*
                Gets a map of client_id:client pairs for the given buffer,
                where each value is a |<A HREF="vim.html">vim.lsp.client</A>| object.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {bufnr}  (optional, number): Buffer handle, or 0 for
                             current


buf_is_attached({bufnr}, {client_id})              *<A NAME="vim.lsp.buf_is_attached()"></A><B>vim.lsp.buf_is_attached()</B>*
                Checks if a buffer is attached for a particular client.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {bufnr}      (number) Buffer handle, or 0 for current
                    {client_id}  (number) the client id


buf_notify({bufnr}, {method}, {params})                 *<A NAME="vim.lsp.buf_notify()"></A><B>vim.lsp.buf_notify()</B>*
                Send a notification to a server

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {bufnr}   [number] (optional): The number of the buffer
                    {method}  [string]: Name of the request method
                    {params}  [string]: Arguments to send to the server

<B><FONT color="#54A23D">                Return: </FONT></B>
                    true if any client returns true; false otherwise


                                                       *<A NAME="vim.lsp.buf_request()"></A><B>vim.lsp.buf_request()</B>*
buf_request({bufnr}, {method}, {params}, {handler})
                Sends an async request for all active clients attached to the
                buffer.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {bufnr}    (number) Buffer handle, or 0 for current.
                    {method}   (string) <A HREF="#LSP">LSP</A> method name
                    {params}   (optional, table) Parameters to send to the
                               server
                    {handler}  (optional, function) See |<A HREF="#lsp-handler">lsp-handler</A>|

<B><FONT color="#54A23D">                Return: </FONT></B>
                    2-tuple:
                    • Map of client-id:request-id pairs for all successful
                      requests.
                    • Function which can be used to cancel all the requests.
                      You could instead iterate all clients and call their
                      `cancel_request()` methods.


                                                   *<A NAME="vim.lsp.buf_request_all()"></A><B>vim.lsp.buf_request_all()</B>*
buf_request_all({bufnr}, {method}, {params}, {callback})
                Sends an async request for all active clients attached to the
                buffer. Executes the callback on the combined result.
                Parameters are the same <A HREF="motion.html#as">as</A> |<A HREF="vim.html">vim.lsp.buf_request()</A>| but the
                return result and callback are different.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {bufnr}     (number) Buffer handle, or 0 for current.
                    {method}    (string) <A HREF="#LSP">LSP</A> method name
                    {params}    (optional, table) Parameters to send to the
                                server
                    {callback}  (function) The callback to call when all
                                requests are finished.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    (function) A function that will cancel all requests which
                    is the same <A HREF="motion.html#as">as</A> the one returned from `buf_request` .


                                                  *<A NAME="vim.lsp.buf_request_sync()"></A><B>vim.lsp.buf_request_sync()</B>*
buf_request_sync({bufnr}, {method}, {params}, {timeout_ms})
                Sends a request to all server and waits for the response of
                all of them.

                Calls |<A HREF="vim.html">vim.lsp.buf_request_all()</A>| but blocks Nvim while
                awaiting the result. Parameters are the same <A HREF="motion.html#as">as</A>
                |<A HREF="vim.html">vim.lsp.buf_request()</A>| but the return result is different.
                Wait maximum of {timeout_ms} (default 100) ms.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {bufnr}       (number) Buffer handle, or 0 for current.
                    {method}      (string) <A HREF="#LSP">LSP</A> method name
                    {params}      (optional, table) Parameters to send to the
                                  server
                    {timeout_ms}  (optional, number, default=100) Maximum time
                                  in milliseconds to wait for a result.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Map of client_id:request_result. On timeout, cancel or
                    error, returns `(nil, err)` where `err` is a <A HREF="eval.html#string">string</A>
                    describing the failure reason.


client()                                                      *<A NAME="vim.lsp.client"></A><B>vim.lsp.client</B>*
                <A HREF="#LSP">LSP</A> client object. You can get an active client object via
                |<A HREF="vim.html">vim.lsp.get_client_by_id()</A>| or
                |<A HREF="vim.html">vim.lsp.get_active_clients()</A>|.

                • Methods:
                  • request(method, params, [handler], bufnr) Sends a request
                    to the server. This is a thin wrapper around
                    {client.rpc.request} with some additional checking. If
                    {handler} is not specified, If one is not found there,
                    then an error will occur. Returns: {status},
                    {[client_id]}. {status} is a <A HREF="options.html#boolean">boolean</A> indicating if the
                    notification was successful. If <A HREF="motion.html#it">it</A> is `false` , then <A HREF="motion.html#it">it</A>
                    will always be `false` (the client has shutdown). If
                    {status} is `true` , the function returns {request_id} <A HREF="motion.html#as">as</A>
                    the second result. You can use this with
                    `client.cancel_request(request_id)` to cancel the request.
                  • notify(method, params) Sends a notification to an <A HREF="#LSP">LSP</A>
                    server. Returns: a <A HREF="options.html#boolean">boolean</A> to indicate if the notification
                    was successful. If <A HREF="motion.html#it">it</A> is false, then <A HREF="motion.html#it">it</A> will always be
                    false (the client has shutdown).
                  • cancel_request(id) Cancels a request with a given request
                    id. Returns: same <A HREF="motion.html#as">as</A> `notify()` .
                  • stop([force]) Stops a client, optionally with force. By
                    default, <A HREF="motion.html#it">it</A> will just ask the server to shutdown without
                    force. If you request to stop a client which has
                    previously been requested to shutdown, <A HREF="motion.html#it">it</A> will
                    automatically escalate and force shutdown.
                  • is_stopped() Checks whether a client is stopped. Returns:
                    true if the client is fully stopped.
                  • on_attach(client, bufnr) Runs the on_attach function from
                    the client's <A HREF="starting.html#config">config</A> if <A HREF="motion.html#it">it</A> was defined. Useful for
                    buffer-local setup.

                • Members
                  • {id} (number): The id allocated to the client.
                  • {name} (string): If a name is specified on creation, that
                    will be used. Otherwise <A HREF="motion.html#it">it</A> is just the client id. This is
                    used for logs and <A HREF="message.html#messages">messages</A>.
                  • {rpc} (table): <A HREF="api.html#RPC">RPC</A> client object, for low level
                    interaction with the client. See |<A HREF="vim.html">vim.lsp.rpc.start()</A>|.
                  • {offset_encoding} (string): The encoding used for
                    communicating with the server. You can modify this in the
                    `config` 's `on_init` method before text is sent to the
                    server.
                  • {handlers} (table): The handlers used by the client <A HREF="motion.html#as">as</A>
                    described in |<A HREF="#lsp-handler">lsp-handler</A>|.
                  • {config} (table): copy of the table that was passed by the
                    user to |<A HREF="vim.html">vim.lsp.start_client()</A>|.
                  • {server_capabilities} (table): Response from the server
                    sent on `initialize` describing the server's capabilities.
                  • {resolved_capabilities} (table): Normalized table of
                    capabilities that we have detected based on the initialize
                    response from the server in `server_capabilities` .


client_is_stopped({client_id})                   *<A NAME="vim.lsp.client_is_stopped()"></A><B>vim.lsp.client_is_stopped()</B>*
                Checks whether a client is stopped.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {client_id}  (Number)

<B><FONT color="#54A23D">                Return: </FONT></B>
                    true if client is stopped, false otherwise.


flush({client})                                              *<A NAME="vim.lsp.flush()"></A><B>vim.lsp.flush()</B>*
                TODO: Documentation


get_active_clients()                            *<A NAME="vim.lsp.get_active_clients()"></A><B>vim.lsp.get_active_clients()</B>*
                Gets all active clients.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Table of |<A HREF="vim.html">vim.lsp.client</A>| <A HREF="vimindex.html#objects">objects</A>


                                          *<A NAME="vim.lsp.get_buffers_by_client_id()"></A><B>vim.lsp.get_buffers_by_client_id()</B>*
get_buffers_by_client_id({client_id})
<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {client_id}  client id

<B><FONT color="#54A23D">                Return: </FONT></B>
                    <A HREF="eval.html#list">list</A> of buffer ids


get_client_by_id({client_id})                     *<A NAME="vim.lsp.get_client_by_id()"></A><B>vim.lsp.get_client_by_id()</B>*
                Gets a client by id, or nil if the id is invalid. The returned
                client may not yet be fully initialized.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {client_id}  client id number

<B><FONT color="#54A23D">                Return: </FONT></B>
                    |<A HREF="vim.html">vim.lsp.client</A>| object, or nil


get_log_path()                                        *<A NAME="vim.lsp.get_log_path()"></A><B>vim.lsp.get_log_path()</B>*
                Gets the path of the logfile used by the <A HREF="#LSP">LSP</A> client.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    (String) Path to logfile.


init({client}, {bufnr})                                       *<A NAME="vim.lsp.init()"></A><B>vim.lsp.init()</B>*
                client_id → state

                state pending_change?: function that the <A HREF="eval.html#timer">timer</A> starts to
                trigger didChange pending_changes: <A HREF="eval.html#list">list</A> of tables with the
                pending changesets; for incremental_sync only
                use_incremental_sync: bool buffers?: table (bufnr → lines);
                for incremental sync only timer?: uv_timer


omnifunc({findstart}, {base})                             *<A NAME="vim.lsp.omnifunc()"></A><B>vim.lsp.omnifunc()</B>*
                Implements <A HREF="options.html#'omnifunc'">'omnifunc'</A> compatible <A HREF="#LSP">LSP</A> completion.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {findstart}  0 or 1, decides behavior
                    {base}       If findstart=0, text to match against

<B><FONT color="#54A23D">                Return: </FONT></B>
                    (number) Decided by`findstart`:
                    • findstart=0: column where the completion starts, or -2
                      or -3
                    • findstart=1: <A HREF="eval.html#list">list</A> of matches (actually just calls
                      |<A HREF="eval.html#complete()">complete()</A>|)

<B><FONT color="#54A23D">                See also: </FONT></B>
                    |<A HREF="insert.html#complete-functions">complete-functions</A>|
                    |<A HREF="insert.html#complete-items">complete-items</A>|
                    |<A HREF="autocmd.html#CompleteDone">CompleteDone</A>|


                                                           *<A NAME="vim.lsp.prepare()"></A><B>vim.lsp.prepare()</B>*
prepare({bufnr}, {firstline}, {new_lastline}, {changedtick})
                TODO: Documentation


reset({client_id})                                           *<A NAME="vim.lsp.reset()"></A><B>vim.lsp.reset()</B>*
                TODO: Documentation


reset_buf({client}, {bufnr})                             *<A NAME="vim.lsp.reset_buf()"></A><B>vim.lsp.reset_buf()</B>*
                TODO: Documentation


set_log_level({level})                               *<A NAME="vim.lsp.set_log_level()"></A><B>vim.lsp.set_log_level()</B>*
                Sets the global log level for <A HREF="#LSP">LSP</A> logging.

                Levels by name: &quot;trace&quot;, &quot;debug&quot;, &quot;info&quot;, &quot;warn&quot;, &quot;error&quot;
                Level numbers begin with &quot;trace&quot; at 0

                Use `lsp.log_levels` for reverse lookup.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {level}  [number|string] the <A HREF="change.html#case">case</A> insensitive level name
                             or number

<B><FONT color="#54A23D">                See also: </FONT></B>
                    |<A HREF="vim.html">vim.lsp.log_levels</A>|


start_client({config})                                *<A NAME="vim.lsp.start_client()"></A><B>vim.lsp.start_client()</B>*
                Starts and initializes a client with the given configuration.

                Parameters `cmd` and `root_dir` are required.

                The following parameters describe fields in the {config}
                table.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {root_dir}         (required, <A HREF="eval.html#string">string</A>) Directory where the
                                       <A HREF="#LSP">LSP</A> server will base its rootUri on
                                       <A HREF="starting.html#initialization">initialization</A>.
                    {cmd}              (required, <A HREF="eval.html#string">string</A> or <A HREF="eval.html#list">list</A> treated like
                                       |<A HREF="eval.html#jobstart()">jobstart()</A>|) Base command that
                                       initiates the <A HREF="#LSP">LSP</A> client.
                    {cmd_cwd}          (string, default=|<A HREF="eval.html#getcwd()">getcwd()</A>|) Directory
                                       to launch the `cmd` process. Not
                                       related to `root_dir` .
                    {cmd_env}          (table) Environment flags to pass to
                                       the <A HREF="#LSP">LSP</A> on spawn. Can be specified
                                       using keys like a map or <A HREF="motion.html#as">as</A> a <A HREF="eval.html#list">list</A> with `k=v` pairs or both. Non-string values are
                                       coerced to <A HREF="eval.html#string">string</A>. Example:

<B>                 { "PRODUCTION=true"; "TEST=123"; PORT = 8080; HOST = "0.0.0.0"; }</B>
 
                    {capabilities}     Map overriding the default capabilities
                                       defined by
                                       |<A HREF="vim.html">vim.lsp.protocol.make_client_capabilities()</A>|,
                                       passed to the language server on
                                       <A HREF="starting.html#initialization">initialization</A>. Hint: use
                                       make_client_capabilities() and modify
                                       its result.
                                       • Note: To send an empty dictionary use
                                         `{[vim.type_idx]=vim.types.dictionary}`
                                         , else <A HREF="motion.html#it">it</A> will be encoded <A HREF="motion.html#as">as</A> an
                                         array.
                    {handlers}         Map of language server method names to
                                       |<A HREF="#lsp-handler">lsp-handler</A>|
                    {settings}         Map with language server specific
                                       settings. These are returned to the
                                       language server if requested via
                                       `workspace/configuration` . Keys are
                                       case-sensitive.
                    {init_options}     Values to pass in the <A HREF="starting.html#initialization">initialization</A>
                                       request <A HREF="motion.html#as">as</A> `initializationOptions` .
                                       See `initialize` in the <A HREF="#LSP">LSP</A> spec.
                    {name}             (string, default=client-id) Name in log
                                       <A HREF="message.html#messages">messages</A>.
                    {get_language_id}  function(bufnr, <A HREF="filetype.html#filetype">filetype</A>) -&gt; language
                                       ID <A HREF="motion.html#as">as</A> <A HREF="eval.html#string">string</A>. Defaults to the <A HREF="filetype.html#filetype">filetype</A>.
                    {offset_encoding}  (default=&quot;utf-16&quot;) One of &quot;<A HREF="mbyte.html#utf-8">utf-8</A>&quot;,
                                       &quot;utf-16&quot;, or &quot;utf-32&quot; which is the
                                       encoding that the <A HREF="#LSP">LSP</A> server expects.
                                       Client does not verify this is correct.
                    {on_error}         Callback with parameters (code, ...),
                                       invoked when the client operation
                                       throws an error. `code` is a number
                                       describing the error. Other arguments
                                       may be passed depending on the error
                                       kind. See |<A HREF="vim.html">vim.lsp.client_errors</A>| for
                                       possible <A HREF="message.html#errors">errors</A>. Use
                                       `vim.lsp.client_errors[code]` to get
                                       human-friendly name.
                    {before_init}      Callback with parameters
                                       (initialize_params, <A HREF="starting.html#config">config</A>) invoked
                                       before the <A HREF="#LSP">LSP</A> &quot;initialize&quot; phase,
                                       where `params` contains the parameters
                                       being sent to the server and `config`
                                       is the <A HREF="starting.html#config">config</A> that was passed to
                                       |<A HREF="vim.html">vim.lsp.start_client()</A>|. You can use
                                       this to modify parameters before they
                                       are sent.
                    {on_init}          Callback (client, initialize_result)
                                       invoked after <A HREF="#LSP">LSP</A> &quot;initialize&quot;, where
                                       `result` is a table of `capabilities`
                                       and anything else the server may send.
                                       For example, clangd sends
                                       `initialize_result.offsetEncoding` if
                                       `capabilities.offsetEncoding` was sent
                                       to <A HREF="motion.html#it">it</A>. You can only modify the
                                       `client.offset_encoding` here before
                                       any notifications are sent. Most
                                       language servers expect to be sent
                                       client specified settings after
                                       <A HREF="starting.html#initialization">initialization</A>. Neovim does not make
                                       this assumption. A
                                       `workspace/didChangeConfiguration`
                                       notification should be sent to the
                                       server during on_init.
                    {on_exit}          Callback (code, signal, client_id)
                                       invoked on client exit.
                                       • code: exit code of the process
                                       • signal: number describing the signal
                                         used to terminate (if any)
                                       • client_id: client handle
                    {on_attach}        Callback (client, bufnr) invoked when
                                       client attaches to a buffer.
                    {trace}            &quot;off&quot; &#124; &quot;<A HREF="message.html#messages">messages</A>&quot; &#124; &quot;<A HREF="starting.html#verbose">verbose</A>&quot; &#124; nil
                                       passed directly to the language server
                                       in the initialize request.
                                       Invalid/empty values will default to
                                       &quot;off&quot;
                    {flags}            A table with flags for the client. The
                                       current (experimental) flags are:
                                       • allow_incremental_sync (bool, default
                                         true): Allow using incremental sync
                                         for buffer edits
                                       • debounce_text_changes (number,
                                         default nil): Debounce didChange
                                         notifications to the server by the
                                         given number in milliseconds. No
                                         debounce occurs if nil

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Client id. |<A HREF="vim.html">vim.lsp.get_client_by_id()</A>| Note: client may
                    not be fully initialized. Use `on_init` to <A HREF="diff.html#do">do</A> any actions
                    once the client has been initialized.


stop_client({client_id}, {force})                      *<A NAME="vim.lsp.stop_client()"></A><B>vim.lsp.stop_client()</B>*
                Stops a client(s).

                You can also use the `stop()` function on a |<A HREF="vim.html">vim.lsp.client</A>|
                object. To stop all clients:


<B>    vim.lsp.stop_client(vim.lsp.get_active_clients())</B>
 

                By default asks the server to shutdown, unless stop was
                requested already for this client, then force-shutdown is
                attempted.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {client_id}  client id or |<A HREF="vim.html">vim.lsp.client</A>| object, or <A HREF="eval.html#list">list</A>
                                 thereof
                    {force}      <A HREF="options.html#boolean">boolean</A> (optional) shutdown forcefully


with({handler}, {override_config})                            *<A NAME="vim.lsp.with()"></A><B>vim.lsp.with()</B>*
                Function to manage overriding defaults for <A HREF="#LSP">LSP</A> handlers.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {handler}          (function) See |<A HREF="#lsp-handler">lsp-handler</A>|
                    {override_config}  (table) Table containing the keys to
                                       override behavior of the {handler}


==============================================================================

<A HREF="lua.html#Lua">Lua</A> module: vim.lsp.buf                                              *<A NAME="lsp-buf"></A><B>lsp-buf</B>*


                                          *<A NAME="vim.lsp.buf.add_workspace_folder()"></A><B>vim.lsp.buf.add_workspace_folder()</B>*
add_workspace_folder({workspace_folder})
                Add the folder at path to the workspace folders. If {path} is
                not provided, the user will be prompted for a path using
                |<A HREF="eval.html#input()">input()</A>|.


clear_references()                            *<A NAME="vim.lsp.buf.clear_references()"></A><B>vim.lsp.buf.clear_references()</B>*
                Removes document highlights from current buffer.


code_action({context})                             *<A NAME="vim.lsp.buf.code_action()"></A><B>vim.lsp.buf.code_action()</B>*
                Selects a code action from the input <A HREF="eval.html#list">list</A> that is available at
                the current cursor position.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {context}  (table, optional) Valid `CodeActionContext`
                               object

<B><FONT color="#54A23D">                See also: </FONT></B>
                    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_codeAction


completion({context})                               *<A NAME="vim.lsp.buf.completion()"></A><B>vim.lsp.buf.completion()</B>*
                Retrieves the completion items at the current cursor position.
                Can only be called in <A HREF="insert.html#Insert">Insert</A> mode.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {context}  (context support not yet implemented)
                               Additional information about the <A HREF="repeat.html#context">context</A> in
                               which a completion was triggered (how <A HREF="motion.html#it">it</A> was
                               triggered, and by which trigger character, if
                               applicable)

<B><FONT color="#54A23D">                See also: </FONT></B>
                    |<A HREF="vim.html">vim.lsp.protocol.constants.CompletionTriggerKind</A>|


declaration()                                      *<A NAME="vim.lsp.buf.declaration()"></A><B>vim.lsp.buf.declaration()</B>*
                Jumps to the declaration of the symbol under the cursor.
                Note:
                    Many servers <A HREF="diff.html#do">do</A> not implement this method. Generally, see
                    |<A HREF="vim.html">vim.lsp.buf.definition()</A>| instead.


definition()                                        *<A NAME="vim.lsp.buf.definition()"></A><B>vim.lsp.buf.definition()</B>*
                Jumps to the definition of the symbol under the cursor.


document_highlight()                        *<A NAME="vim.lsp.buf.document_highlight()"></A><B>vim.lsp.buf.document_highlight()</B>*
                Send request to the server to resolve document highlights for
                the current text document position. This request can be
                triggered by a key <A HREF="map.html#mapping">mapping</A> or by <A HREF="autocmd.html#events">events</A> such <A HREF="motion.html#as">as</A> `CursorHold` ,
                eg:

<B>    vim.api.nvim_command [[autocmd CursorHold  &lt;buffer&gt; lua vim.lsp.buf.document_highlight()]]</B>
<B>    vim.api.nvim_command [[autocmd CursorHoldI &lt;buffer&gt; lua vim.lsp.buf.document_highlight()]]</B>
<B>    vim.api.nvim_command [[autocmd CursorMoved &lt;buffer&gt; lua vim.lsp.buf.clear_references()]]</B>
 

                Note: Usage of |<A HREF="vim.html">vim.lsp.buf.document_highlight()</A>| requires the
                following highlight groups to be defined or you won't be able
                to see the actual highlights. |<A HREF="intro.html#LspReferenceText">LspReferenceText</A>|
                |<A HREF="intro.html#LspReferenceRead">LspReferenceRead</A>| |<A HREF="intro.html#LspReferenceWrite">LspReferenceWrite</A>|


document_symbol()                              *<A NAME="vim.lsp.buf.document_symbol()"></A><B>vim.lsp.buf.document_symbol()</B>*
                <A HREF="eval.html#Lists">Lists</A> all symbols in the current buffer in the <A HREF="quickfix.html#quickfix">quickfix</A>
                <A HREF="windows.html#window">window</A>.


execute_command({command})                     *<A NAME="vim.lsp.buf.execute_command()"></A><B>vim.lsp.buf.execute_command()</B>*
                Executes an <A HREF="#LSP">LSP</A> server command.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {command}  A valid `ExecuteCommandParams` object

<B><FONT color="#54A23D">                See also: </FONT></B>
                    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#workspace_executeCommand


formatting({options})                               *<A NAME="vim.lsp.buf.formatting()"></A><B>vim.lsp.buf.formatting()</B>*
                Formats the current buffer.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {options}  (optional, table) Can be used to specify
                               FormattingOptions. Some unspecified <A HREF="options.html#options">options</A>
                               will be automatically derived from the current
                               Neovim <A HREF="options.html#options">options</A>.

<B><FONT color="#54A23D">                See also: </FONT></B>
                    https://microsoft.github.io/language-server-protocol/specification#textDocument_formatting


                                               *<A NAME="vim.lsp.buf.formatting_sync()"></A><B>vim.lsp.buf.formatting_sync()</B>*
formatting_sync({options}, {timeout_ms})
                Performs |<A HREF="vim.html">vim.lsp.buf.formatting()</A>| synchronously.

                Useful for running on save, to make sure buffer is formatted
                prior to being saved. {timeout_ms} is passed on to
                |<A HREF="vim.html">vim.lsp.buf_request_sync()</A>|. Example:


<B>    vim.api.nvim_command[[autocmd BufWritePre &lt;buffer&gt; lua vim.lsp.buf.formatting_sync()]]</B>
 

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {options}     Table with valid `FormattingOptions` entries
                    {timeout_ms}  (number) Request timeout


hover()                                                  *<A NAME="vim.lsp.buf.hover()"></A><B>vim.lsp.buf.hover()</B>*
                Displays hover information about the symbol under the cursor
                in a floating <A HREF="windows.html#window">window</A>. Calling the function <A HREF="if_cscop.html#twice">twice</A> will jump
                into the floating <A HREF="windows.html#window">window</A>.


implementation()                                *<A NAME="vim.lsp.buf.implementation()"></A><B>vim.lsp.buf.implementation()</B>*
                <A HREF="eval.html#Lists">Lists</A> all the implementations for the symbol under the cursor
                in the <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="windows.html#window">window</A>.


incoming_calls()                                *<A NAME="vim.lsp.buf.incoming_calls()"></A><B>vim.lsp.buf.incoming_calls()</B>*
                <A HREF="eval.html#Lists">Lists</A> all the call sites of the symbol under the cursor in the
                |<A HREF="quickfix.html#quickfix">quickfix</A>| <A HREF="windows.html#window">window</A>. If the symbol can resolve to multiple
                items, the user can pick one in the |<A HREF="intro.html#inputlist">inputlist</A>|.


list_workspace_folders()                *<A NAME="vim.lsp.buf.list_workspace_folders()"></A><B>vim.lsp.buf.list_workspace_folders()</B>*
                <A HREF="eval.html#List">List</A> workspace folders.


outgoing_calls()                                *<A NAME="vim.lsp.buf.outgoing_calls()"></A><B>vim.lsp.buf.outgoing_calls()</B>*
                <A HREF="eval.html#Lists">Lists</A> all the items that are called by the symbol under the
                cursor in the |<A HREF="quickfix.html#quickfix">quickfix</A>| <A HREF="windows.html#window">window</A>. If the symbol can resolve to
                multiple items, the user can pick one in the |<A HREF="intro.html#inputlist">inputlist</A>|.


                                             *<A NAME="vim.lsp.buf.range_code_action()"></A><B>vim.lsp.buf.range_code_action()</B>*
range_code_action({context}, {start_pos}, {end_pos})
                Performs |<A HREF="vim.html">vim.lsp.buf.code_action()</A>| for a given range.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {context}    (table, optional) Valid `CodeActionContext`
                                 object
                    {start_pos}  ({number, number}, optional) mark-indexed
                                 position. Defaults to the start of the last
                                 visual selection.
                    {end_pos}    ({number, number}, optional) mark-indexed
                                 position. Defaults to the end of the last
                                 visual selection.


                                              *<A NAME="vim.lsp.buf.range_formatting()"></A><B>vim.lsp.buf.range_formatting()</B>*
range_formatting({options}, {start_pos}, {end_pos})
                Formats a given range.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {options}    Table with valid `FormattingOptions` entries.
                    {start_pos}  ({number, number}, optional) mark-indexed
                                 position. Defaults to the start of the last
                                 visual selection.
                    {end_pos}    ({number, number}, optional) mark-indexed
                                 position. Defaults to the end of the last
                                 visual selection.


references({context})                               *<A NAME="vim.lsp.buf.references()"></A><B>vim.lsp.buf.references()</B>*
                <A HREF="eval.html#Lists">Lists</A> all the references to the symbol under the cursor in the
                <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="windows.html#window">window</A>.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {context}  (table) <A HREF="repeat.html#Context">Context</A> for the request

<B><FONT color="#54A23D">                See also: </FONT></B>
                    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_references


                                       *<A NAME="vim.lsp.buf.remove_workspace_folder()"></A><B>vim.lsp.buf.remove_workspace_folder()</B>*
remove_workspace_folder({workspace_folder})
                Remove the folder at path from the workspace folders. If
                {path} is not provided, the user will be prompted for a path
                using |<A HREF="eval.html#input()">input()</A>|.


rename({new_name})                                      *<A NAME="vim.lsp.buf.rename()"></A><B>vim.lsp.buf.rename()</B>*
                Renames all references to the symbol under the cursor.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {new_name}  (string) If not provided, the user will be
                                prompted for a new name using |<A HREF="eval.html#input()">input()</A>|.


server_ready()                                    *<A NAME="vim.lsp.buf.server_ready()"></A><B>vim.lsp.buf.server_ready()</B>*
                Checks whether the language servers attached to the current
                buffer are ready.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    `true` if server responds.


signature_help()                                *<A NAME="vim.lsp.buf.signature_help()"></A><B>vim.lsp.buf.signature_help()</B>*
                Displays signature information about the symbol under the
                cursor in a floating <A HREF="windows.html#window">window</A>.


type_definition()                              *<A NAME="vim.lsp.buf.type_definition()"></A><B>vim.lsp.buf.type_definition()</B>*
                Jumps to the definition of the type of the symbol under the
                cursor.


workspace_symbol({query})                     *<A NAME="vim.lsp.buf.workspace_symbol()"></A><B>vim.lsp.buf.workspace_symbol()</B>*
                <A HREF="eval.html#Lists">Lists</A> all symbols in the current workspace in the <A HREF="quickfix.html#quickfix">quickfix</A>
                <A HREF="windows.html#window">window</A>.

                The <A HREF="eval.html#list">list</A> is filtered against {query}; if the argument is
                omitted from the call, the user is prompted to enter a <A HREF="eval.html#string">string</A>
                on the command line. An empty <A HREF="eval.html#string">string</A> means no filtering is
                done.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {query}  (string, optional)


==============================================================================

<A HREF="lua.html#Lua">Lua</A> module: vim.lsp.diagnostic                                *<A NAME="lsp-diagnostic"></A><B>lsp-diagnostic</B>*


                                                  *<A NAME="vim.lsp.diagnostic.clear()"></A><B>vim.lsp.diagnostic.clear()</B>*
clear({bufnr}, {client_id}, {diagnostic_ns}, {sign_ns})
                Clears the currently displayed diagnostics

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {bufnr}          number The buffer number
                    {client_id}      number the client id
                    {diagnostic_ns}  number|nil Associated diagnostic
                                     namespace
                    {sign_ns}        number|nil Associated sign namespace


get({bufnr}, {client_id})                           *<A NAME="vim.lsp.diagnostic.get()"></A><B>vim.lsp.diagnostic.get()</B>*
                Return associated diagnostics for bufnr

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {bufnr}      number
                    {client_id}  number|nil If nil, then return all of the
                                 diagnostics. Else, return just the
                                 diagnostics associated with the client_id.


get_all()                                       *<A NAME="vim.lsp.diagnostic.get_all()"></A><B>vim.lsp.diagnostic.get_all()</B>*
                Get all diagnostics for all clients

<B><FONT color="#54A23D">                Return: </FONT></B>
                    {bufnr:Diagnostic[]}


                                              *<A NAME="vim.lsp.diagnostic.get_count()"></A><B>vim.lsp.diagnostic.get_count()</B>*
get_count({bufnr}, {severity}, {client_id})
                Get the counts for a particular severity

                Useful for showing diagnostic counts in statusline. eg:


<B>    function! LspStatus() abort</B>
<B>      let sl = ''</B>
<B>      if luaeval('not vim.tbl_isempty(vim.lsp.buf_get_clients(0))')</B>
<B>        let sl.='%#MyStatuslineLSP#E:'</B>
<B>        let sl.='%#MyStatuslineLSPErrors#%{luaeval("vim.lsp.diagnostic.get_count(0, [[Error]])")}'</B>
<B>        let sl.='%#MyStatuslineLSP# W:'</B>
<B>        let sl.='%#MyStatuslineLSPWarnings#%{luaeval("vim.lsp.diagnostic.get_count(0, [[Warning]])")}'</B>
<B>      else</B>
<B>          let sl.='%#MyStatuslineLSPErrors#off'</B>
<B>      endif</B>
<B>      return sl</B>
<B>    endfunction</B>
<B>    let &amp;l:statusline = '%#MyStatuslineLSP#LSP '.LspStatus()</B>
 

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {bufnr}      number The buffer number
                    {severity}   DiagnosticSeverity
                    {client_id}  number the client id


                                   *<A NAME="vim.lsp.diagnostic.get_line_diagnostics()"></A><B>vim.lsp.diagnostic.get_line_diagnostics()</B>*
get_line_diagnostics({bufnr}, {line_nr}, {opts}, {client_id})
                Get the diagnostics by line

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {bufnr}      number The buffer number
                    {line_nr}    number The line number
                    {opts}       table|nil Configuration keys
                                 • severity: (DiagnosticSeverity, default nil)
                                   • Only return diagnostics with this
                                     severity. Overrides severity_limit

                                 • severity_limit: (DiagnosticSeverity, default nil)
                                   • Limit severity of diagnostics found. E.g.
                                     &quot;Warning&quot; means { &quot;Error&quot;, &quot;Warning&quot; }
                                     will be valid.
                    {client_id}  number the client id

<B><FONT color="#54A23D">                Return: </FONT></B>
                    table Table with map of line number to <A HREF="eval.html#list">list</A> of
                    diagnostics.


get_next({opts})                               *<A NAME="vim.lsp.diagnostic.get_next()"></A><B>vim.lsp.diagnostic.get_next()</B>*
                Get the next diagnostic closest to the cursor_position

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {opts}  table See |<A HREF="vim.html">vim.lsp.diagnostic.goto_next()</A>|

<B><FONT color="#54A23D">                Return: </FONT></B>
                    table Next diagnostic


get_next_pos({opts})                       *<A NAME="vim.lsp.diagnostic.get_next_pos()"></A><B>vim.lsp.diagnostic.get_next_pos()</B>*
                Return the pos, {row, col}, for the next diagnostic in the
                current buffer.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {opts}  table See |<A HREF="vim.html">vim.lsp.diagnostic.goto_next()</A>|

<B><FONT color="#54A23D">                Return: </FONT></B>
                    table Next diagnostic position


get_prev({opts})                               *<A NAME="vim.lsp.diagnostic.get_prev()"></A><B>vim.lsp.diagnostic.get_prev()</B>*
                Get the previous diagnostic closest to the cursor_position

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {opts}  table See |<A HREF="vim.html">vim.lsp.diagnostic.goto_next()</A>|

<B><FONT color="#54A23D">                Return: </FONT></B>
                    table Previous diagnostic


get_prev_pos({opts})                       *<A NAME="vim.lsp.diagnostic.get_prev_pos()"></A><B>vim.lsp.diagnostic.get_prev_pos()</B>*
                Return the pos, {row, col}, for the prev diagnostic in the
                current buffer.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {opts}  table See |<A HREF="vim.html">vim.lsp.diagnostic.goto_next()</A>|

<B><FONT color="#54A23D">                Return: </FONT></B>
                    table Previous diagnostic position


                       *<A NAME="vim.lsp.diagnostic.get_virtual_text_chunks_for_line()"></A><B>vim.lsp.diagnostic.get_virtual_text_chunks_for_line()</B>*
get_virtual_text_chunks_for_line({bufnr}, {line}, {line_diags}, {opts})
                Default function to get text chunks to display using `nvim_buf_set_virtual_text` .

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {bufnr}       number The buffer to display the virtual
                                  text in
                    {line}        number The line number to display the
                                  virtual text on
                    {line_diags}  Diagnostic <A HREF="motion.html#[]">[]</A> The diagnostics associated with the line
                    {opts}        table See {opts} from
                                  |<A HREF="vim.html">vim.lsp.diagnostic.set_virtual_text()</A>|

<B><FONT color="#54A23D">                Return: </FONT></B>
                    table chunks, <A HREF="motion.html#as">as</A> defined by |<A HREF="api.html#nvim_buf_set_virtual_text()">nvim_buf_set_virtual_text()</A>|


goto_next({opts})                             *<A NAME="vim.lsp.diagnostic.goto_next()"></A><B>vim.lsp.diagnostic.goto_next()</B>*
                Move to the next diagnostic

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {opts}  table|nil Configuration table. Keys:
                            • {client_id}: (number)
                              • If nil, will consider all clients attached to
                                buffer.

                            • {cursor_position}: (Position, default current
                              position)
                              • See |<A HREF="api.html#nvim_win_get_cursor()">nvim_win_get_cursor()</A>|

                            • {wrap}: (boolean, default true)
                              • Whether to loop around file or not. Similar to
                                <A HREF="options.html#'wrapscan'">'wrapscan'</A>

                            • {severity}: (DiagnosticSeverity)
                              • Exclusive severity to consider. Overrides
                                {severity_limit}

                            • {severity_limit}: (DiagnosticSeverity)
                              • Limit severity of diagnostics found. E.g.
                                &quot;Warning&quot; means { &quot;Error&quot;, &quot;Warning&quot; } will be
                                valid.

                            • {enable_popup}: (boolean, default true)
                              • Call
                                |<A HREF="vim.html">vim.lsp.diagnostic.show_line_diagnostics()</A>|
                                on jump

                            • {popup_opts}: (table)
                              • Table to pass <A HREF="motion.html#as">as</A> {opts} parameter to
                                |<A HREF="vim.html">vim.lsp.diagnostic.show_line_diagnostics()</A>|

                            • {win_id}: (number, default 0)
                              • Window ID


goto_prev({opts})                             *<A NAME="vim.lsp.diagnostic.goto_prev()"></A><B>vim.lsp.diagnostic.goto_prev()</B>*
                Move to the previous diagnostic

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {opts}  table See |<A HREF="vim.html">vim.lsp.diagnostic.goto_next()</A>|


                                 *<A NAME="vim.lsp.diagnostic.on_publish_diagnostics()"></A><B>vim.lsp.diagnostic.on_publish_diagnostics()</B>*
on_publish_diagnostics({_}, {_}, {params}, {client_id}, {_}, {config})
                |<A HREF="#lsp-handler">lsp-handler</A>| for the method &quot;textDocument/publishDiagnostics&quot;

                Note:
                    Each of the configuration <A HREF="options.html#options">options</A> accepts:
                    • `false` : Disable this feature
                    • `true` : Enable this feature, use default settings.
                    • `table` : Enable this feature, use overrides.
                    • `function`: Function with signature (bufnr, client_id) that
                      returns any of the above.&gt;

                 vim.lsp.handlers[&quot;textDocument/publishDiagnostics&quot;] = vim.lsp.with(
                   vim.lsp.diagnostic.on_publish_diagnostics, {
                     <A HREF="starting.html#--">--</A> Enable <A HREF="syntax.html#underline">underline</A>, use default values
                     <A HREF="syntax.html#underline">underline</A> = true,
                     <A HREF="starting.html#--">--</A> Enable virtual text, override spacing to 4
                     virtual_text = {
                       spacing = 4,
                     },
                     <A HREF="starting.html#--">--</A> Use a function to dynamically turn <A HREF="sign.html#signs">signs</A> off
                     <A HREF="starting.html#--">--</A> and on, using buffer local <A HREF="eval.html#variables">variables</A>
                     <A HREF="sign.html#signs">signs</A> = function(bufnr, client_id)
                       return vim.bo[bufnr].show_signs <A HREF="change.html#==">==</A> false
                     end,
                     <A HREF="starting.html#--">--</A> Disable a feature
                     update_in_insert = false,
                   }
                 )
<A HREF="change.html#&lt;">&lt;</A>

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {config}  table Configuration table.
                              • <A HREF="syntax.html#underline">underline</A>: (default=true)
                                • Apply underlines to diagnostics.
                                • See |<A HREF="vim.html">vim.lsp.diagnostic.set_underline()</A>|

                              • virtual_text: (default=true)
                                • Apply virtual text to line endings.
                                • See |<A HREF="vim.html">vim.lsp.diagnostic.set_virtual_text()</A>|

                              • <A HREF="sign.html#signs">signs</A>: (default=true)
                                • Apply <A HREF="sign.html#signs">signs</A> for diagnostics.
                                • See |<A HREF="vim.html">vim.lsp.diagnostic.set_signs()</A>|

                              • update_in_insert: (default=false)
                                • Update diagnostics in InsertMode or wait
                                  until <A HREF="autocmd.html#InsertLeave">InsertLeave</A>

                              • severity_sort: (default=false)
                                • Sort diagnostics (and thus <A HREF="sign.html#signs">signs</A> and virtual
                                  text)


reset({client_id}, {buffer_client_map})           *<A NAME="vim.lsp.diagnostic.reset()"></A><B>vim.lsp.diagnostic.reset()</B>*
                Clear diagnotics and diagnostic cache

                Handles saving diagnostics from multiple clients in the same
                buffer.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {client_id}          number
                    {buffer_client_map}  table map of <A HREF="windows.html#buffers">buffers</A> to active
                                         clients


save({diagnostics}, {bufnr}, {client_id})          *<A NAME="vim.lsp.diagnostic.save()"></A><B>vim.lsp.diagnostic.save()</B>*
                Save diagnostics to the current buffer.

                Handles saving diagnostics from multiple clients in the same
                buffer.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {diagnostics}  Diagnostic <A HREF="motion.html#[]">[]</A>
                    {bufnr}        number
                    {client_id}    number


set_loclist({opts})                         *<A NAME="vim.lsp.diagnostic.set_loclist()"></A><B>vim.lsp.diagnostic.set_loclist()</B>*
                Sets the location <A HREF="eval.html#list">list</A>

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {opts}  table|nil Configuration table. Keys:
                            • {open_loclist}: (boolean, default true)
                              • Open loclist after set

                            • {client_id}: (number)
                              • If nil, will consider all clients attached to
                                buffer.

                            • {severity}: (DiagnosticSeverity)
                              • Exclusive severity to consider. Overrides
                                {severity_limit}

                            • {severity_limit}: (DiagnosticSeverity)
                              • Limit severity of diagnostics found. E.g.
                                &quot;Warning&quot; means { &quot;Error&quot;, &quot;Warning&quot; } will be
                                valid.


                                              *<A NAME="vim.lsp.diagnostic.set_signs()"></A><B>vim.lsp.diagnostic.set_signs()</B>*
set_signs({diagnostics}, {bufnr}, {client_id}, {sign_ns}, {opts})
                Set <A HREF="sign.html#signs">signs</A> for given diagnostics

                Sign characters can be customized with the following commands:


<B>    sign define LspDiagnosticsSignError text=E texthl=LspDiagnosticsSignError linehl= numhl=</B>
<B>    sign define LspDiagnosticsSignWarning text=W texthl=LspDiagnosticsSignWarning linehl= numhl=</B>
<B>    sign define LspDiagnosticsSignInformation text=I texthl=LspDiagnosticsSignInformation linehl= numhl=</B>
<B>    sign define LspDiagnosticsSignHint text=H texthl=LspDiagnosticsSignHint linehl= numhl=</B>
 

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {diagnostics}  Diagnostic <A HREF="motion.html#[]">[]</A>
                    {bufnr}        number The buffer number
                    {client_id}    number the client id
                    {sign_ns}      number|nil
                    {opts}         table Configuration for <A HREF="sign.html#signs">signs</A>. Keys:
                                   • priority: Set the priority of the <A HREF="sign.html#signs">signs</A>.
                                   • severity_limit (DiagnosticSeverity):
                                     • Limit severity of diagnostics found.
                                       E.g. &quot;Warning&quot; means { &quot;Error&quot;,
                                       &quot;Warning&quot; } will be valid.


                                          *<A NAME="vim.lsp.diagnostic.set_underline()"></A><B>vim.lsp.diagnostic.set_underline()</B>*
set_underline({diagnostics}, {bufnr}, {client_id}, {diagnostic_ns}, {opts})
                Set <A HREF="syntax.html#underline">underline</A> for given diagnostics

                Underline highlights can be customized by <A HREF="change.html#changing">changing</A> the
                following |<A HREF="syntax.html#:highlight">:highlight</A>| groups.


<B>    LspDiagnosticsUnderlineError</B>
<B>    LspDiagnosticsUnderlineWarning</B>
<B>    LspDiagnosticsUnderlineInformation</B>
<B>    LspDiagnosticsUnderlineHint</B>
 

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {diagnostics}    Diagnostic <A HREF="motion.html#[]">[]</A>
                    {bufnr}          number: The buffer number
                    {client_id}      number: The client id
                    {diagnostic_ns}  number|nil: The namespace
                    {opts}           table: Configuration table:
                                     • severity_limit (DiagnosticSeverity):
                                       • Limit severity of diagnostics found.
                                         E.g. &quot;Warning&quot; means { &quot;Error&quot;,
                                         &quot;Warning&quot; } will be valid.


                                       *<A NAME="vim.lsp.diagnostic.set_virtual_text()"></A><B>vim.lsp.diagnostic.set_virtual_text()</B>*
set_virtual_text({diagnostics}, {bufnr}, {client_id}, {diagnostic_ns}, {opts})
                Set virtual text given diagnostics

                Virtual text highlights can be customized by <A HREF="change.html#changing">changing</A> the
                following |<A HREF="syntax.html#:highlight">:highlight</A>| groups.


<B>    LspDiagnosticsVirtualTextError</B>
<B>    LspDiagnosticsVirtualTextWarning</B>
<B>    LspDiagnosticsVirtualTextInformation</B>
<B>    LspDiagnosticsVirtualTextHint</B>
 

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {diagnostics}    Diagnostic <A HREF="motion.html#[]">[]</A>
                    {bufnr}          number
                    {client_id}      number
                    {diagnostic_ns}  number
                    {opts}           table Options on how to display virtual
                                     text. Keys:
                                     • prefix (string): Prefix to display
                                       before virtual text on line
                                     • spacing (number): <A HREF="eval.html#Number">Number</A> of spaces to
                                       insert before virtual text
                                     • severity_limit (DiagnosticSeverity):
                                       • Limit severity of diagnostics found.
                                         E.g. &quot;Warning&quot; means { &quot;Error&quot;,
                                         &quot;Warning&quot; } will be valid.


                                  *<A NAME="vim.lsp.diagnostic.show_line_diagnostics()"></A><B>vim.lsp.diagnostic.show_line_diagnostics()</B>*
show_line_diagnostics({opts}, {bufnr}, {line_nr}, {client_id})
                Open a floating <A HREF="windows.html#window">window</A> with the diagnostics from {line_nr}

                The floating <A HREF="windows.html#window">window</A> can be customized with the following
                highlight groups:

<B>                 LspDiagnosticsFloatingError</B>
<B>                 LspDiagnosticsFloatingWarning</B>
<B>                 LspDiagnosticsFloatingInformation</B>
<B>                 LspDiagnosticsFloatingHint</B>
 

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {opts}       table Configuration table
                                 • show_header (boolean, default true): Show
                                   &quot;Diagnostics:&quot; header.
                    {bufnr}      number The buffer number
                    {line_nr}    number The line number
                    {client_id}  number|nil the client id

<B><FONT color="#54A23D">                Return: </FONT></B>
                    table {popup_bufnr, win_id}


==============================================================================

<A HREF="lua.html#Lua">Lua</A> module: <A HREF="#vim.lsp.handlers">vim.lsp.handlers</A>                                    *<A NAME="lsp-handlers"></A><B>lsp-handlers</B>*


                                         *<A NAME="vim.lsp.handlers.progress_handler()"></A><B>vim.lsp.handlers.progress_handler()</B>*
progress_handler({_}, {_}, {params}, {client_id})
<B><FONT color="#54A23D">                See also: </FONT></B>
                    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#workspace_executeCommand


                                           *<A NAME="vim.lsp.handlers.signature_help()"></A><B>vim.lsp.handlers.signature_help()</B>*
signature_help({_}, {method}, {result}, {_}, {bufnr}, {config})
<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {config}  table Configuration table.
                              • border: (default=nil)
                                • Add borders to the floating <A HREF="windows.html#window">window</A>
                                • See |<A HREF="vim.html">vim.api.nvim_open_win()</A>|

<B><FONT color="#54A23D">                See also: </FONT></B>
                    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_declaration@seehttps://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_definition@seehttps://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_typeDefinition@seehttps://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_implementation|<A HREF="#lsp-handler">lsp-handler</A>| for the method &quot;textDocument/signatureHelp&quot;&gt;

                 vim.lsp.handlers[&quot;textDocument/signatureHelp&quot;] = vim.lsp.with(
                   vim.lsp.handlers.signature_help, {
                     <A HREF="starting.html#--">--</A> Use a sharp border with `FloatBorder` highlights
                     border = &quot;single&quot;
                   }
                 )
<A HREF="change.html#&lt;">&lt;</A>


==============================================================================

<A HREF="lua.html#Lua">Lua</A> module: vim.lsp.util                                            *<A NAME="lsp-util"></A><B>lsp-util</B>*


                                     *<A NAME="vim.lsp.util.apply_text_document_edit()"></A><B>vim.lsp.util.apply_text_document_edit()</B>*
apply_text_document_edit({text_document_edit}, {index})
                Applies a `TextDocumentEdit` , which is a <A HREF="eval.html#list">list</A> of changes to a
                single document.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {text_document_edit}  table: a `TextDocumentEdit` object
                    {index}               number: Optional index of the edit,
                                          if from a <A HREF="eval.html#list">list</A> of edits (or nil, if
                                          not from a <A HREF="eval.html#list">list</A>)

<B><FONT color="#54A23D">                See also: </FONT></B>
                    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocumentEdit


                                             *<A NAME="vim.lsp.util.apply_text_edits()"></A><B>vim.lsp.util.apply_text_edits()</B>*
apply_text_edits({text_edits}, {bufnr})
                Applies a <A HREF="eval.html#list">list</A> of text edits to a buffer.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {text_edits}  (table) <A HREF="eval.html#list">list</A> of `TextEdit` <A HREF="vimindex.html#objects">objects</A>
                    {buf_nr}      (number) Buffer id


                                         *<A NAME="vim.lsp.util.apply_workspace_edit()"></A><B>vim.lsp.util.apply_workspace_edit()</B>*
apply_workspace_edit({workspace_edit})
                Applies a `WorkspaceEdit` .

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {workspace_edit}  (table) `WorkspaceEdit`


buf_clear_references({bufnr})            *<A NAME="vim.lsp.util.buf_clear_references()"></A><B>vim.lsp.util.buf_clear_references()</B>*
                Removes document highlights from a buffer.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {bufnr}  buffer id


                                     *<A NAME="vim.lsp.util.buf_highlight_references()"></A><B>vim.lsp.util.buf_highlight_references()</B>*
buf_highlight_references({bufnr}, {references})
                Shows a <A HREF="eval.html#list">list</A> of document highlights for a certain buffer.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {bufnr}       buffer id
                    {references}  <A HREF="eval.html#List">List</A> of `DocumentHighlight` <A HREF="vimindex.html#objects">objects</A> to
                                  highlight


character_offset({buf}, {row}, {col})        *<A NAME="vim.lsp.util.character_offset()"></A><B>vim.lsp.util.character_offset()</B>*
                Returns the UTF-32 and UTF-16 offsets for a position in a
                certain buffer.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {buf}  buffer id (0 for current)
                    {row}  0-indexed line
                    {col}  0-indexed byte offset in line

<B><FONT color="#54A23D">                Return: </FONT></B>
                    (number, number) UTF-32 and UTF-16 index of the character
                    in line {row} column {col} in buffer {buf}


                                        *<A NAME="vim.lsp.util.close_preview_autocmd()"></A><B>vim.lsp.util.close_preview_autocmd()</B>*
close_preview_autocmd({events}, {winnr})
                Creates autocommands to close a preview <A HREF="windows.html#window">window</A> when <A HREF="autocmd.html#events">events</A>
                happen.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {events}  (table) <A HREF="eval.html#list">list</A> of <A HREF="autocmd.html#events">events</A>
                    {winnr}   (number) <A HREF="windows.html#window">window</A> id of preview <A HREF="windows.html#window">window</A>

<B><FONT color="#54A23D">                See also: </FONT></B>
                    |<A HREF="autocmd.html#autocmd-events">autocmd-events</A>|


                                                 *<A NAME="vim.lsp.util.compute_diff()"></A><B>vim.lsp.util.compute_diff()</B>*
compute_diff({old_lines}, {new_lines}, {start_line_idx}, {end_line_idx},
             {offset_encoding})
                Returns the range table for the difference between old and new
                lines

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {old_lines}        table <A HREF="eval.html#list">list</A> of lines
                    {new_lines}        table <A HREF="eval.html#list">list</A> of lines
                    {start_line_idx}   int line to begin search for first
                                       difference
                    {end_line_idx}     int line to begin search for last
                                       difference
                    {offset_encoding}  <A HREF="eval.html#string">string</A> encoding requested by language
                                       server

<B><FONT color="#54A23D">                Return: </FONT></B>
                    table start_line_idx and start_col_idx of range


                              *<A NAME="vim.lsp.util.convert_input_to_markdown_lines()"></A><B>vim.lsp.util.convert_input_to_markdown_lines()</B>*
convert_input_to_markdown_lines({input}, {contents})
                Converts any of `MarkedString` &#124; `MarkedString[]` |
                `MarkupContent` into a <A HREF="eval.html#list">list</A> of lines containing valid
                markdown. Useful to populate the hover <A HREF="windows.html#window">window</A> for
                `textDocument/hover` , for parsing the result of
                `textDocument/signatureHelp` , and potentially others.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {input}     ( `MarkedString` &#124; `MarkedString[]` |
                                `MarkupContent` )
                    {contents}  (table, optional, default `{}` ) <A HREF="eval.html#List">List</A> of
                                strings to extend with converted lines

<B><FONT color="#54A23D">                Return: </FONT></B>
                    {contents}, extended with lines of converted markdown.

<B><FONT color="#54A23D">                See also: </FONT></B>
                    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_hover


                     *<A NAME="vim.lsp.util.convert_signature_help_to_markdown_lines()"></A><B>vim.lsp.util.convert_signature_help_to_markdown_lines()</B>*
convert_signature_help_to_markdown_lines({signature_help})
                Converts `textDocument/SignatureHelp` response to markdown
                lines.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {signature_help}  Response of `textDocument/SignatureHelp`

<B><FONT color="#54A23D">                Return: </FONT></B>
                    <A HREF="eval.html#list">list</A> of lines of converted markdown.

<B><FONT color="#54A23D">                See also: </FONT></B>
                    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_signatureHelp


create_file({change})                             *<A NAME="vim.lsp.util.create_file()"></A><B>vim.lsp.util.create_file()</B>*
                TODO: Documentation


delete_file({change})                             *<A NAME="vim.lsp.util.delete_file()"></A><B>vim.lsp.util.delete_file()</B>*
                TODO: Documentation


                                     *<A NAME="vim.lsp.util.extract_completion_items()"></A><B>vim.lsp.util.extract_completion_items()</B>*
extract_completion_items({result})
                Can be used to extract the completion items from a `textDocument/completion` request, which may return one of `CompletionItem[]` , `CompletionList` or null.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {result}  (table) The result of a
                              `textDocument/completion` request

<B><FONT color="#54A23D">                Return: </FONT></B>
                    (table) <A HREF="eval.html#List">List</A> of completion items

<B><FONT color="#54A23D">                See also: </FONT></B>
                    https://microsoft.github.io/language-server-protocol/specification#textDocument_completion


                                      *<A NAME="vim.lsp.util.fancy_floating_markdown()"></A><B>vim.lsp.util.fancy_floating_markdown()</B>*
fancy_floating_markdown({contents}, {opts})
                Converts markdown into <A HREF="syntax.html#syntax">syntax</A> highlighted regions by stripping
                the code blocks and converting them into highlighted code.
                This will by default insert a blank line separator after those
                code block regions to improve readability. The result is shown
                in a floating preview.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {contents}  table of lines to show in <A HREF="windows.html#window">window</A>
                    {opts}      dictionary with optional fields
                                • height of floating <A HREF="windows.html#window">window</A>
                                • width of floating <A HREF="windows.html#window">window</A>
                                • wrap_at character to wrap at for computing
                                  height
                                • max_width maximal width of floating <A HREF="windows.html#window">window</A>
                                • max_height maximal height of floating <A HREF="windows.html#window">window</A>
                                • pad_left number of columns to pad contents
                                  at left
                                • pad_right number of columns to pad contents
                                  at right
                                • pad_top number of lines to pad contents at
                                  top
                                • pad_bottom number of lines to pad contents
                                  at bottom
                                • separator insert separator after code block

<B><FONT color="#54A23D">                Return: </FONT></B>
                    width,height size of float


focusable_float({unique_name}, {fn})          *<A NAME="vim.lsp.util.focusable_float()"></A><B>vim.lsp.util.focusable_float()</B>*
<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {unique_name}  (string) Window variable
                    {fn}           (function) should return create a new
                                   <A HREF="windows.html#window">window</A> and return a tuple of
                                   ({focusable_buffer_id}, {window_id}). if
                                   {focusable_buffer_id} is a valid buffer id,
                                   the newly created <A HREF="windows.html#window">window</A> will be the new
                                   focus associated with the current buffer
                                   via the <A HREF="tagsrch.html#tag">tag</A> `unique_name` .

<B><FONT color="#54A23D">                Return: </FONT></B>
                    (pbufnr, pwinnr) if `fn()` has created a new <A HREF="windows.html#window">window</A>; nil
                    otherwise


                                            *<A NAME="vim.lsp.util.focusable_preview()"></A><B>vim.lsp.util.focusable_preview()</B>*
focusable_preview({unique_name}, {fn})
                Focuses/unfocuses the floating preview <A HREF="windows.html#window">window</A> associated with
                the current buffer via the <A HREF="windows.html#window">window</A> variable `unique_name` . If
                no such preview <A HREF="windows.html#window">window</A> exists, makes a new one.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {unique_name}  (string) Window variable
                    {fn}           (function) The return values of this
                                   function will be passed directly to
                                   |<A HREF="vim.html">vim.lsp.util.open_floating_preview()</A>|, in
                                   the <A HREF="change.html#case">case</A> that a new floating <A HREF="windows.html#window">window</A> should
                                   be created


get_effective_tabstop({bufnr})          *<A NAME="vim.lsp.util.get_effective_tabstop()"></A><B>vim.lsp.util.get_effective_tabstop()</B>*
                Returns visual width of tabstop.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {bufnr}  (optional, number): Buffer handle, defaults to
                             current

<B><FONT color="#54A23D">                Return: </FONT></B>
                    (number) tabstop visual width

<B><FONT color="#54A23D">                See also: </FONT></B>
                    |<A HREF="intro.html#softtabstop">softtabstop</A>|


get_progress_messages()                 *<A NAME="vim.lsp.util.get_progress_messages()"></A><B>vim.lsp.util.get_progress_messages()</B>*
                TODO: Documentation


jump_to_location({location})                 *<A NAME="vim.lsp.util.jump_to_location()"></A><B>vim.lsp.util.jump_to_location()</B>*
                Jumps to a location.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {location}  ( `Location` &#124; `LocationLink` )

<B><FONT color="#54A23D">                Return: </FONT></B>
                    `true` if the jump succeeded


locations_to_items({locations})            *<A NAME="vim.lsp.util.locations_to_items()"></A><B>vim.lsp.util.locations_to_items()</B>*
                Returns the items with the byte position calculated correctly
                and in sorted order, for display in <A HREF="quickfix.html#quickfix">quickfix</A> and location
                lists.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {locations}  (table) <A HREF="eval.html#list">list</A> of `Location` <A HREF="change.html#s">s</A> or
                                 `LocationLink` <A HREF="change.html#s">s</A>

<B><FONT color="#54A23D">                Return: </FONT></B>
                    (table) <A HREF="eval.html#list">list</A> of items


lookup_section({settings}, {section})          *<A NAME="vim.lsp.util.lookup_section()"></A><B>vim.lsp.util.lookup_section()</B>*
                Helper function to return nested values in language server
                settings

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {settings}  a table of language server settings
                    {section}   a <A HREF="eval.html#string">string</A> indicating the field of the settings
                                table

<B><FONT color="#54A23D">                Return: </FONT></B>
                    (table or <A HREF="eval.html#string">string</A>) The value of settings accessed via
                    section


                                  *<A NAME="vim.lsp.util.make_floating_popup_options()"></A><B>vim.lsp.util.make_floating_popup_options()</B>*
make_floating_popup_options({width}, {height}, {opts})
                Creates a table with sensible default <A HREF="options.html#options">options</A> for a floating
                <A HREF="windows.html#window">window</A>. The table can be passed to |<A HREF="api.html#nvim_open_win()">nvim_open_win()</A>|.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {width}   (number) <A HREF="windows.html#window">window</A> width (in character cells)
                    {height}  (number) <A HREF="windows.html#window">window</A> height (in character cells)
                    {opts}    (table, optional)

<B><FONT color="#54A23D">                Return: </FONT></B>
                    (table) Options


                                       *<A NAME="vim.lsp.util.make_formatting_params()"></A><B>vim.lsp.util.make_formatting_params()</B>*
make_formatting_params({options})
                Creates a `FormattingOptions` object for the current buffer
                and cursor position.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {options}  Table with valid `FormattingOptions` entries

<B><FONT color="#54A23D">                Return: </FONT></B>
                    `FormattingOptions object

<B><FONT color="#54A23D">                See also: </FONT></B>
                    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_formatting


                                      *<A NAME="vim.lsp.util.make_given_range_params()"></A><B>vim.lsp.util.make_given_range_params()</B>*
make_given_range_params({start_pos}, {end_pos})
                Using the given range in the current buffer, creates an object
                that is similar to |<A HREF="vim.html">vim.lsp.util.make_range_params()</A>|.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {start_pos}  ({number, number}, optional) mark-indexed
                                 position. Defaults to the start of the last
                                 visual selection.
                    {end_pos}    ({number, number}, optional) mark-indexed
                                 position. Defaults to the end of the last
                                 visual selection.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    { textDocument = { uri = `current_file_uri` }, range = {
                    start = `start_position` , end = `end_position` } }


make_position_params()                   *<A NAME="vim.lsp.util.make_position_params()"></A><B>vim.lsp.util.make_position_params()</B>*
                Creates a `TextDocumentPositionParams` object for the current
                buffer and cursor position.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    `TextDocumentPositionParams` object

<B><FONT color="#54A23D">                See also: </FONT></B>
                    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocumentPositionParams


make_range_params()                         *<A NAME="vim.lsp.util.make_range_params()"></A><B>vim.lsp.util.make_range_params()</B>*
                Using the current position in the current buffer, creates an
                object that can be used <A HREF="motion.html#as">as</A> a building block for several <A HREF="#LSP">LSP</A>
                requests, such <A HREF="motion.html#as">as</A> `textDocument/codeAction` ,
                `textDocument/colorPresentation` ,
                `textDocument/rangeFormatting` .

<B><FONT color="#54A23D">                Return: </FONT></B>
                    { textDocument = { uri = `current_file_uri` }, range = {
                    start = `current_position` , end = `current_position` } }


make_text_document_params()         *<A NAME="vim.lsp.util.make_text_document_params()"></A><B>vim.lsp.util.make_text_document_params()</B>*
                Creates a `TextDocumentIdentifier` object for the current
                buffer.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    `TextDocumentIdentifier`

<B><FONT color="#54A23D">                See also: </FONT></B>
                    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocumentIdentifier


                                        *<A NAME="vim.lsp.util.make_workspace_params()"></A><B>vim.lsp.util.make_workspace_params()</B>*
make_workspace_params({added}, {removed})
                Create the workspace params

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {added}    
                    {removed}


                                        *<A NAME="vim.lsp.util.open_floating_preview()"></A><B>vim.lsp.util.open_floating_preview()</B>*
open_floating_preview({contents}, {syntax}, {opts})
                Shows contents in a floating <A HREF="windows.html#window">window</A>.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {contents}  table of lines to show in <A HREF="windows.html#window">window</A>
                    {syntax}    <A HREF="eval.html#string">string</A> of <A HREF="syntax.html#syntax">syntax</A> to set for opened buffer
                    {opts}      dictionary with optional fields

<B><FONT color="#54A23D">                Return: </FONT></B>
                    bufnr,winnr buffer and <A HREF="windows.html#window">window</A> number of the newly created
                    floating preview <A HREF="windows.html#window">window</A>


parse_snippet({input})                          *<A NAME="vim.lsp.util.parse_snippet()"></A><B>vim.lsp.util.parse_snippet()</B>*
                Parses snippets in a completion entry.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {input}  (string) unparsed snippet

<B><FONT color="#54A23D">                Return: </FONT></B>
                    (string) parsed snippet


preview_location({location})                 *<A NAME="vim.lsp.util.preview_location()"></A><B>vim.lsp.util.preview_location()</B>*
                Previews a location in a floating <A HREF="windows.html#window">window</A>

                behavior depends on type of location:
                • for Location, range is shown (e.g., function definition)
                • for LocationLink, targetRange is shown (e.g., body of
                  function definition)

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {location}  a single `Location` or `LocationLink`

<B><FONT color="#54A23D">                Return: </FONT></B>
                    (bufnr,winnr) buffer and <A HREF="windows.html#window">window</A> number of floating <A HREF="windows.html#window">window</A>
                    or nil


rename({old_fname}, {new_fname}, {opts})               *<A NAME="vim.lsp.util.rename()"></A><B>vim.lsp.util.rename()</B>*
<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {opts}  (table)


set_lines({lines}, {A}, {B}, {new_lines})           *<A NAME="vim.lsp.util.set_lines()"></A><B>vim.lsp.util.set_lines()</B>*
                Replaces text in a range with new text.

                CAUTION: Changes in-place!

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {lines}      (table) Original <A HREF="eval.html#list">list</A> of strings
                    {A}          (table) Start position; a 2-tuple of {line,
                                 col} numbers
                    {B}          (table) End position; a 2-tuple of {line,
                                 col} numbers
                    {new_lines}  A <A HREF="eval.html#list">list</A> of strings to replace the original

<B><FONT color="#54A23D">                Return: </FONT></B>
                    (table) The modified {lines} object


set_loclist({items})                              *<A NAME="vim.lsp.util.set_loclist()"></A><B>vim.lsp.util.set_loclist()</B>*
                Fills current window's location <A HREF="eval.html#list">list</A> with given <A HREF="eval.html#list">list</A> of items.
                Can be obtained with e.g. |<A HREF="vim.html">vim.lsp.util.locations_to_items()</A>|.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {items}  (table) <A HREF="eval.html#list">list</A> of items


set_qflist({items})                                *<A NAME="vim.lsp.util.set_qflist()"></A><B>vim.lsp.util.set_qflist()</B>*
                Fills <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A> with given <A HREF="eval.html#list">list</A> of items. Can be obtained
                with e.g. |<A HREF="vim.html">vim.lsp.util.locations_to_items()</A>|.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {items}  (table) <A HREF="eval.html#list">list</A> of items


symbols_to_items({symbols}, {bufnr})         *<A NAME="vim.lsp.util.symbols_to_items()"></A><B>vim.lsp.util.symbols_to_items()</B>*
                Converts symbols to <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A> items.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {symbols}  DocumentSymbol[] or SymbolInformation[]


              *<A NAME="vim.lsp.util.text_document_completion_list_to_complete_items()"></A><B>vim.lsp.util.text_document_completion_list_to_complete_items()</B>*
text_document_completion_list_to_complete_items({result}, {prefix})
                Turns the result of a `textDocument/completion` request into
                vim-compatible |<A HREF="insert.html#complete-items">complete-items</A>|.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {result}  The result of a `textDocument/completion` call,
                              e.g. from |<A HREF="vim.html">vim.lsp.buf.completion()</A>|, which may
                              be one of `CompletionItem[]` , `CompletionList`
                              or `null`
                    {prefix}  (string) the prefix to <A HREF="change.html#filter">filter</A> the completion
                              items

<B><FONT color="#54A23D">                Return: </FONT></B>
                    { matches = <A HREF="insert.html#complete-items">complete-items</A> table, incomplete = bool }

<B><FONT color="#54A23D">                See also: </FONT></B>
                    |<A HREF="insert.html#complete-items">complete-items</A>|


trim_empty_lines({lines})                    *<A NAME="vim.lsp.util.trim_empty_lines()"></A><B>vim.lsp.util.trim_empty_lines()</B>*
                Removes empty lines from the beginning and end.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {lines}  (table) <A HREF="eval.html#list">list</A> of lines to trim

<B><FONT color="#54A23D">                Return: </FONT></B>
                    (table) trimmed <A HREF="eval.html#list">list</A> of lines


                                *<A NAME="vim.lsp.util.try_trim_markdown_code_blocks()"></A><B>vim.lsp.util.try_trim_markdown_code_blocks()</B>*
try_trim_markdown_code_blocks({lines})
                Accepts markdown lines and tries to reduce them to a <A HREF="filetype.html#filetype">filetype</A>
                if they comprise just a single code block.

                CAUTION: Modifies the input in-place!

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {lines}  (table) <A HREF="eval.html#list">list</A> of lines

<B><FONT color="#54A23D">                Return: </FONT></B>
                    (string) <A HREF="filetype.html#filetype">filetype</A> or 'markdown' if <A HREF="motion.html#it">it</A> was unchanged.


==============================================================================

<A HREF="lua.html#Lua">Lua</A> module: vim.lsp.log                                              *<A NAME="lsp-log"></A><B>lsp-log</B>*


get_filename()                                    *<A NAME="vim.lsp.log.get_filename()"></A><B>vim.lsp.log.get_filename()</B>*
                Returns the log filename.

<B><FONT color="#54A23D">                Return: </FONT></B>
                    (string) log filename


set_level({level})                                   *<A NAME="vim.lsp.log.set_level()"></A><B>vim.lsp.log.set_level()</B>*
                Sets the current log level.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {level}  (string or number) One of `vim.lsp.log.levels`


should_log({level})                                 *<A NAME="vim.lsp.log.should_log()"></A><B>vim.lsp.log.should_log()</B>*
                Checks whether the level is sufficient for logging.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {level}  number log level

<B><FONT color="#54A23D">                Return: </FONT></B>
                    (bool) true if would log, false if not


==============================================================================

<A HREF="lua.html#Lua">Lua</A> module: vim.lsp.rpc                                              *<A NAME="lsp-rpc"></A><B>lsp-rpc</B>*


format_rpc_error({err})                       *<A NAME="vim.lsp.rpc.format_rpc_error()"></A><B>vim.lsp.rpc.format_rpc_error()</B>*
                Constructs an error message from an <A HREF="#LSP">LSP</A> error object.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {err}  (table) The error object

<B><FONT color="#54A23D">                Return: </FONT></B>
                    (string) The formatted error message


notify({method}, {params})                              *<A NAME="vim.lsp.rpc.notify()"></A><B>vim.lsp.rpc.notify()</B>*
                Sends a notification to the <A HREF="#LSP">LSP</A> server.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {method}  (string) The invoked <A HREF="#LSP">LSP</A> method
                    {params}  (table): Parameters for the invoked <A HREF="#LSP">LSP</A> method

<B><FONT color="#54A23D">                Return: </FONT></B>
                    (bool) `true` if notification could be sent, `false` if
                    not


request({method}, {params}, {callback})                *<A NAME="vim.lsp.rpc.request()"></A><B>vim.lsp.rpc.request()</B>*
                Sends a request to the <A HREF="#LSP">LSP</A> server and runs {callback} upon
                response.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {method}    (string) The invoked <A HREF="#LSP">LSP</A> method
                    {params}    (table) Parameters for the invoked <A HREF="#LSP">LSP</A> method
                    {callback}  (function) Callback to invoke

<B><FONT color="#54A23D">                Return: </FONT></B>
                    (bool, number) `(true, message_id)` if request could be
                    sent, `false` if not


                                            *<A NAME="vim.lsp.rpc.rpc_response_error()"></A><B>vim.lsp.rpc.rpc_response_error()</B>*
rpc_response_error({code}, {message}, {data})
                Creates an <A HREF="api.html#RPC">RPC</A> response object/table.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {code}     <A HREF="api.html#RPC">RPC</A> error code defined in
                               `vim.lsp.protocol.ErrorCodes`
                    {message}  (optional) arbitrary message to send to server
                    {data}     (optional) arbitrary data to send to server


                                                         *<A NAME="vim.lsp.rpc.start()"></A><B>vim.lsp.rpc.start()</B>*
start({cmd}, {cmd_args}, {dispatchers}, {extra_spawn_params})
                Starts an <A HREF="#LSP">LSP</A> server process and create an <A HREF="#LSP">LSP</A> <A HREF="api.html#RPC">RPC</A> client
                object to interact with <A HREF="motion.html#it">it</A>.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {cmd}                 (string) Command to start the <A HREF="#LSP">LSP</A>
                                          server.
                    {cmd_args}            (table) <A HREF="eval.html#List">List</A> of additional <A HREF="eval.html#string">string</A>
                                          arguments to pass to {cmd}.
                    {dispatchers}         (table, optional) Dispatchers for
                                          <A HREF="#LSP">LSP</A> message types. Valid dispatcher
                                          names are:
                                          • `&quot;notification&quot;`
                                          • `&quot;server_request&quot;`
                                          • `&quot;on_error&quot;`
                                          • `&quot;on_exit&quot;`
                    {extra_spawn_params}  (table, optional) Additional <A HREF="repeat.html#context">context</A>
                                          for the <A HREF="#LSP">LSP</A> server process. May
                                          contain:
                                          • {cwd} (string) Working directory
                                            for the <A HREF="#LSP">LSP</A> server process
                                          • {env} (table) Additional
                                            environment <A HREF="eval.html#variables">variables</A> for <A HREF="#LSP">LSP</A>
                                            server process

<B><FONT color="#54A23D">                Return: </FONT></B>
                    Client <A HREF="api.html#RPC">RPC</A> object.
                    Methods:
                    • `notify()` |<A HREF="vim.html">vim.lsp.rpc.notify()</A>|
                    • `request()` |<A HREF="vim.html">vim.lsp.rpc.request()</A>|

                    Members:
                    • {pid} (number) The <A HREF="#LSP">LSP</A> server's PID.
                    • {handle} A handle for low-level interaction with the <A HREF="#LSP">LSP</A>
                      server process |<A HREF="vim.html">vim.loop</A>|.


==============================================================================

<A HREF="lua.html#Lua">Lua</A> module: <A HREF="#vim.lsp.protocol">vim.lsp.protocol</A>                                    *<A NAME="lsp-protocol"></A><B>lsp-protocol</B>*


                                 *<A NAME="vim.lsp.protocol.make_client_capabilities()"></A><B>vim.lsp.protocol.make_client_capabilities()</B>*
make_client_capabilities()
                Gets a new ClientCapabilities object describing the <A HREF="#LSP">LSP</A> client
                capabilities.


                                     *<A NAME="vim.lsp.protocol.resolve_capabilities()"></A><B>vim.lsp.protocol.resolve_capabilities()</B>*
resolve_capabilities({server_capabilities})
                `*` to match one or more characters in a path segment `?` to
                match on one character in a path segment `**` to match any
                number of path segments, including none `{}` to group
                conditions (e.g. `**​/*.{ts,js}` matches all TypeScript and
                JavaScript files) `[]` to declare a range of characters to
                match in a path segment (e.g., `example.[0-9]` to match on
                `example.0` , `example.1` , …) `[!...]` to negate a range of
                characters to match in a path segment (e.g., `example.[!0-9]`
                to match on `example.a` , `example.b` , but not `example.0` )

<A HREF="#top">top</A> - <A HREF="index.html">main help file</A>
</PRE>
    </div>

    <footer>
      <div class="container">
        Generated Fri Apr 30 05:44:47 UTC 2021 from <a href="https://github.com/neovim/neovim/commit/59eae3b38fc98ba8c14e681b6d231e9821a11d52"><code>59eae3b</code></a>.
      </div>
    </footer>
  </body>
</html>
