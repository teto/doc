<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <meta content="width=device-width, initial-scale=1" name="viewport">
    <title>Nvim documentation: if_pyth</title>
    <link href="https://fonts.googleapis.com/css?family=Lato:400,700,900" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.0/normalize.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
    <link href="/css/main.css" rel="stylesheet">
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    
  </head>
  <body>
    <header class="navbar">
      <div class="container">
        <nav class="navbar">
          <div class="container-fluid">
            <div class="navbar-header">

              <a href="/" class="navbar-brand">
                <img src="/images/logo@2x.png" id="navbar-logo" alt="Neovim">
              </a>
            </div>
          </div>
        </nav>
      </div>
    </header>

    <div class="container">
      <h1>Nvim documentation: if_pyth</h1>
<A NAME="top"></A>
<A HREF="index.html">main help file</A>

<HR>
<PRE>

*<A NAME="if_pyth.txt"></A><B>if_pyth.txt</B>*   Nvim


		  VIM REFERENCE MANUAL    by Paul Moore



The <A HREF="#Python">Python</A> Interface to Vim				*<A NAME="if_pyth"></A><B>if_pyth</B>* *<A NAME="python"></A><B>python</B>* *<A NAME="Python"></A><B>Python</B>*

See |<A HREF="provider.html#provider-python">provider-python</A>| for more information.

                                      Type |<A HREF="various.html#gO">gO</A>| to see the table of contents.

==============================================================================

Commands						*<A NAME="python-commands"></A><B>python-commands</B>*


					*<A NAME=":python"></A><B>:python</B>* *<A NAME=":py"></A><B>:py</B>* *<A NAME="E263"></A><B>E263</B>* *<A NAME="E264"></A><B>E264</B>* *<A NAME="E887"></A><B>E887</B>*
:[range]py[thon] {stmt}
			Execute <A HREF="#Python">Python</A> statement {stmt}.  A simple check if
			the `:python` command is working:
<B>				:python print "Hello"</B>

:[range]py[thon] <A HREF="change.html#&lt;&lt;">&lt;&lt;</A> [endmarker]
{script}
{endmarker}
			Execute <A HREF="#Python">Python</A> <A HREF="usr_41.html#script">script</A> {script}.  Useful for including
			<A HREF="#python">python</A> code in Vim scripts.  Requires <A HREF="#Python">Python</A>, see
			|<A HREF="#script-here">script-here</A>|.

The {endmarker} below the {script} must <A HREF="lua.html#NOT">NOT</A> be preceded by any white space.

If [endmarker] is omitted from after the &quot;<A HREF="change.html#&lt;&lt;">&lt;&lt;</A>&quot;, a dot '<A HREF="repeat.html#.">.</A>' must be used after
{script}, like for the |<A HREF="insert.html#:append">:append</A>| and |<A HREF="insert.html#:insert">:insert</A>| commands.

Example:
<B>	function! IcecreamInitialize()</B>
<B>	python &lt;&lt; EOF</B>
<B>	class StrawberryIcecream:</B>
<B>		def __call__(self):</B>
<B>			print 'EAT ME'</B>
<B>	EOF</B>
<B>	endfunction</B>

To see what version of <A HREF="#Python">Python</A> you have:
<B>	:python print(sys.version)</B>

There is no need to &quot;import sys&quot;, it's done by default.

Note: <A HREF="#Python">Python</A> is very sensitive to indenting.  Make sure the &quot;class&quot; line and
&quot;EOF&quot; <A HREF="diff.html#do">do</A> not have any indent.


							*<A NAME=":pydo"></A><B>:pydo</B>*
:[range]pydo {body}	Execute <A HREF="#Python">Python</A> function &quot;def _vim_pydo(line, linenr):
			{body}&quot; for each line in the <A HREF="cmdline.html#[range]">[range]</A>, with the
			function arguments being set to the text of each line
			in turn, without a trailing <A HREF="intro.html#&lt;EOL&gt;">&lt;EOL&gt;</A>, and the current
			line number. The function should return a <A HREF="eval.html#string">string</A> or
			None. If a <A HREF="eval.html#string">string</A> is returned, <A HREF="motion.html#it">it</A> becomes the text of
			the line in the current turn. The default for <A HREF="cmdline.html#[range]">[range]</A>
			is the whole file: &quot;1,$&quot;.

Examples:

<B>	:pydo return "%s\t%d" % (line[::-1], len(line))</B>
<B>	:pydo if line: return "%4d: %s" % (linenr, line)</B>
 
One can use `:pydo` in possible conjunction with `:py` to <A HREF="change.html#filter">filter</A> a range using
<A HREF="#python">python</A>. For example:

<B>	:py3 &lt;&lt; EOF</B>
<B>	needle = vim.eval('@a')</B>
<B>	replacement = vim.eval('@b')</B>

<B>	def py_vim_string_replace(str):</B>
<B>		return str.replace(needle, replacement)</B>
<B>	EOF</B>
<B>	:'&lt;,'&gt;py3do return py_vim_string_replace(line)</B>
 

							*<A NAME=":pyfile"></A><B>:pyfile</B>* *<A NAME=":pyf"></A><B>:pyf</B>*
:[range]pyf[ile] <A HREF="editing.html#{file}">{file}</A>
			Execute the <A HREF="#Python">Python</A> <A HREF="usr_41.html#script">script</A> in <A HREF="editing.html#{file}">{file}</A>.  The whole
			argument is used <A HREF="motion.html#as">as</A> a single file name.

Both of these commands <A HREF="diff.html#do">do</A> essentially the same thing - they execute a piece of
<A HREF="#Python">Python</A> code, with the &quot;current range&quot; |<A HREF="#python-range">python-range</A>| set to the given line
range.

In the <A HREF="change.html#case">case</A> of <A HREF="#:python">:python</A>, the code to execute is in the command-line.
In the <A HREF="change.html#case">case</A> of <A HREF="#:pyfile">:pyfile</A>, the code to execute is the contents of the given file.

<A HREF="#Python">Python</A> commands cannot be used in the |<A HREF="eval.html#sandbox">sandbox</A>|.

To pass arguments you need to set sys.argv[] explicitly.  Example:

<B>	:python sys.argv = ["foo", "bar"]</B>
<B>	:pyfile myscript.py</B>


Here are some examples					*<A NAME="python-examples"></A><B>python-examples</B>* 

<B>	:python from vim import *</B>
<B>	:python from string import upper</B>
<B>	:python current.line = upper(current.line)</B>
<B>	:python print "Hello"</B>
<B>	:python str = current.buffer[42]</B>

Note that changes (such <A HREF="motion.html#as">as</A> the &quot;import&quot; statements) persist from one command
to the next, just like the <A HREF="#Python">Python</A> REPL.


							*<A NAME="script-here"></A><B>script-here</B>*
When using a <A HREF="usr_41.html#script">script</A> language in-line, you might want to skip this when the
language isn't supported.  Note that this mechanism doesn't work:

<B>   if has('python')</B>
<B>     python &lt;&lt; EOF</B>
<B>       this will NOT work!</B>
<B>   EOF</B>
<B>   endif</B>

Instead, put the <A HREF="#Python">Python</A> command in a function and call that function:

<B>    if has('python')</B>
<B>      function DefPython()</B>
<B>        python &lt;&lt; EOF</B>
<B>          this works</B>
<B>    EOF</B>
<B>      endfunction</B>
<B>      call DefPython()</B>
<B>    endif</B>

Note that &quot;EOF&quot; must be at the start of the line.

==============================================================================

The vim module						*<A NAME="python-vim"></A><B>python-vim</B>* *<A NAME="python2"></A><B>python2</B>*

<A HREF="#Python">Python</A> code gets all of its access to vim (with one exception - see
|<A HREF="#python-output">python-output</A>| below) via the &quot;vim&quot; module.  The vim module implements two
methods, three constants, and one error object.  You need to import the vim
module before using <A HREF="motion.html#it">it</A>:
<B>	:python import vim</B>

Overview
<B>	:py print "Hello"		# displays a message</B>
<B>	:py vim.command(cmd)		# execute an Ex command</B>
<B>	:py w = vim.windows[n]		# gets window "n"</B>
<B>	:py cw = vim.current.window	# gets the current window</B>
<B>	:py b = vim.buffers[n]		# gets buffer "n"</B>
<B>	:py cb = vim.current.buffer	# gets the current buffer</B>
<B>	:py w.height = lines		# sets the window height</B>
<B>	:py w.cursor = (row, col)	# sets the window cursor position</B>
<B>	:py pos = w.cursor		# gets a tuple (row, col)</B>
<B>	:py name = b.name		# gets the buffer file name</B>
<B>	:py line = b[n]			# gets a line from the buffer</B>
<B>	:py lines = b[n:m]		# gets a list of lines</B>
<B>	:py num = len(b)		# gets the number of lines</B>
<B>	:py b[n] = str			# sets a line in the buffer</B>
<B>	:py b[n:m] = [str1, str2, str3]	# sets a number of lines at once</B>
<B>	:py del b[n]			# deletes a line</B>
<B>	:py del b[n:m]			# deletes a number of lines</B>


Methods of the &quot;vim&quot; module


vim.command(str)					*<A NAME="python-command"></A><B>python-command</B>*
	Executes the vim (ex-mode) command str.  Returns None.
	Examples:
<B>	    :py vim.command("set tw=72")</B>
<B>	    :py vim.command("%s/aaa/bbb/g")</B>
 	The following definition executes <A HREF="intro.html#Normal">Normal</A> mode commands:
<B>		def normal(str):</B>
<B>			vim.command("normal "+str)</B>
<B>		# Note the use of single quotes to delimit a string containing</B>
<B>		# double quotes</B>
<B>		normal('"a2dd"aP')</B>

 								*<A NAME="E659"></A><B>E659</B>*
	The &quot;<A HREF="#:python">:python</A>&quot; command cannot be used recursively with <A HREF="#Python">Python</A> 2.2 and
	older.  This only works with <A HREF="#Python">Python</A> 2.3 and later:
<B>	    :py vim.command("python print 'Hello again Python'")</B>


vim.eval(str)						*<A NAME="python-eval"></A><B>python-eval</B>*
	Evaluates the <A HREF="eval.html#expression">expression</A> str using the vim internal <A HREF="eval.html#expression">expression</A>
	evaluator (see |<A HREF="eval.html#expression">expression</A>|).  Returns the expression result <A HREF="motion.html#as">as</A>:
	- a <A HREF="eval.html#string">string</A> if the Vim <A HREF="eval.html#expression">expression</A> evaluates to a <A HREF="eval.html#string">string</A> or number
	- a <A HREF="eval.html#list">list</A> if the Vim <A HREF="eval.html#expression">expression</A> evaluates to a Vim <A HREF="eval.html#list">list</A>
	- a dictionary if the Vim <A HREF="eval.html#expression">expression</A> evaluates to a Vim dictionary
	<A HREF="eval.html#Dictionaries">Dictionaries</A> and lists are recursively expanded.
	Examples:
<B>	    :py text_width = vim.eval("&amp;tw")</B>
<B>	    :py str = vim.eval("12+12")		# NB result is a string! Use</B>
<B>						# string.atoi() to convert to</B>
<B>						# a number.</B>


vim.strwidth(str)					*<A NAME="python-strwidth"></A><B>python-strwidth</B>*
	Like |strwidth()|: returns number of display cells str occupies, <A HREF="intro.html#tab">tab</A> 
	is counted <A HREF="motion.html#as">as</A> one cell.


vim.foreach_rtp(callable)				*<A NAME="python-foreach_rtp"></A><B>python-foreach_rtp</B>*
	Call the given callable for each path in <A HREF="options.html#'runtimepath'">'runtimepath'</A> until either 
	callable returns something but None, the exception is raised or there 
	are no longer paths. If stopped in <A HREF="change.html#case">case</A> callable returned non-None, 
	vim.foreach_rtp function returns the value returned by callable.

vim.chdir(*args, **kwargs)				*python-chdir*
vim.fchdir(*args, **kwargs)				*python-fchdir*
	Run os.chdir or os.fchdir, then all appropriate vim stuff.
	Note: you should not use these <A HREF="eval.html#functions">functions</A> directly, use os.chdir and 
	      os.fchdir instead. Behavior of vim.fchdir is undefined in <A HREF="change.html#case">case</A> 
	      os.fchdir does not exist.

Error object of the &quot;vim&quot; module


vim.error						*<A NAME="python-error"></A><B>python-error</B>*
	Upon encountering a Vim error, <A HREF="#Python">Python</A> raises an exception of type
	vim.error.
	Example:
<B>		try:</B>
<B>			vim.command("put a")</B>
<B>		except vim.error:</B>
<B>			# nothing in register a</B>

Constants of the &quot;vim&quot; module

	Note that these are not actually constants - you could reassign them.
	But this is silly, <A HREF="motion.html#as">as</A> you would then lose access to the vim <A HREF="vimindex.html#objects">objects</A>
	to which the <A HREF="eval.html#variables">variables</A> referred.


vim.buffers						*<A NAME="python-buffers"></A><B>python-buffers</B>*
	A <A HREF="map.html#mapping">mapping</A> object providing access to the <A HREF="eval.html#list">list</A> of vim <A HREF="windows.html#buffers">buffers</A>.  The
	object supports the following operations:
<B>	    :py b = vim.buffers[i]	# Indexing (read-only)</B>
<B>	    :py b in vim.buffers	# Membership test</B>
<B>	    :py n = len(vim.buffers)	# Number of elements</B>
<B>	    :py for b in vim.buffers:	# Iterating over buffer list</B>
 

vim.windows						*<A NAME="python-windows"></A><B>python-windows</B>*
	A sequence object providing access to the <A HREF="eval.html#list">list</A> of vim <A HREF="windows.html#windows">windows</A>.  The
	object supports the following operations:
<B>	    :py w = vim.windows[i]	# Indexing (read-only)</B>
<B>	    :py w in vim.windows	# Membership test</B>
<B>	    :py n = len(vim.windows)	# Number of elements</B>
<B>	    :py for w in vim.windows:	# Sequential access</B>
 	Note: vim.windows object always accesses current <A HREF="intro.html#tab">tab</A> page. 
	|<A HREF="#python-tabpage">python-tabpage</A>|.windows <A HREF="vimindex.html#objects">objects</A> are bound to parent |<A HREF="#python-tabpage">python-tabpage</A>| 
	object and always use <A HREF="windows.html#windows">windows</A> from that <A HREF="intro.html#tab">tab</A> page (or throw vim.error 
	in <A HREF="change.html#case">case</A> <A HREF="intro.html#tab">tab</A> page was deleted). You can keep a reference to both 
	without keeping a reference to vim module object or |<A HREF="#python-tabpage">python-tabpage</A>|, 
	they will not lose their properties in this <A HREF="change.html#case">case</A>.


vim.tabpages						*<A NAME="python-tabpages"></A><B>python-tabpages</B>*
	A sequence object providing access to the <A HREF="eval.html#list">list</A> of vim <A HREF="intro.html#tab">tab</A> pages. The 
	object supports the following operations:
<B>	    :py t = vim.tabpages[i]	# Indexing (read-only)</B>
<B>	    :py t in vim.tabpages	# Membership test</B>
<B>	    :py n = len(vim.tabpages)	# Number of elements</B>
<B>	    :py for t in vim.tabpages:	# Sequential access</B>
 

vim.current						*<A NAME="python-current"></A><B>python-current</B>*
	An object providing access (via specific attributes) to various
	&quot;current&quot; <A HREF="vimindex.html#objects">objects</A> available in <A HREF="options.html#vim:">vim:</A>
		vim.current.line	The current line (RW)		<A HREF="eval.html#String">String</A>
		vim.current.buffer	The current buffer (RW)		Buffer
		vim.current.window	The current <A HREF="windows.html#window">window</A> (RW)		Window
		vim.current.tabpage	The current <A HREF="intro.html#tab">tab</A> page (RW)	TabPage
		vim.current.range	The current line range (RO)	Range

	The last <A HREF="change.html#case">case</A> deserves a little explanation.  When the <A HREF="#:python">:python</A> or
	<A HREF="#:pyfile">:pyfile</A> command specifies a range, this range of lines becomes the
	&quot;current range&quot;.  A range is a bit like a buffer, but with all access
	restricted to a subset of lines.  See |<A HREF="#python-range">python-range</A>| for more details.

	Note: When assigning to vim.current.{buffer,window,tabpage} <A HREF="motion.html#it">it</A> expects 
	valid |<A HREF="#python-buffer">python-buffer</A>|, |<A HREF="#python-window">python-window</A>| or |<A HREF="#python-tabpage">python-tabpage</A>| <A HREF="vimindex.html#objects">objects</A> 
	respectively. Assigning triggers normal (with |<A HREF="autocmd.html#autocommand">autocommand</A>|<A HREF="change.html#s">s</A>) 
	switching to given buffer, <A HREF="windows.html#window">window</A> or <A HREF="intro.html#tab">tab</A> page. It is the only way to 
	switch <A HREF="ui.html#UI">UI</A> <A HREF="vimindex.html#objects">objects</A> in <A HREF="#python">python</A>: you can't assign to 
	|<A HREF="#python-tabpage">python-tabpage</A>|.window attribute. To switch without triggering 
	autocommands use
<B>	    py &lt;&lt; EOF</B>
<B>	    saved_eventignore = vim.options['eventignore']</B>
<B>	    vim.options['eventignore'] = 'all'</B>
<B>	    try:</B>
<B>	        vim.current.buffer = vim.buffers[2] # Switch to buffer 2</B>
<B>	    finally:</B>
<B>	        vim.options['eventignore'] = saved_eventignore</B>
<B>	    EOF</B>
 

vim.vars						*<A NAME="python-vars"></A><B>python-vars</B>*

vim.vvars						*<A NAME="python-vvars"></A><B>python-vvars</B>*
	Dictionary-like <A HREF="vimindex.html#objects">objects</A> holding dictionaries with global (|<A HREF="eval.html#g:">g:</A>|) and 
	vim (|<A HREF="eval.html#v:">v:</A>|) <A HREF="eval.html#variables">variables</A> respectively.


vim.options						*<A NAME="python-options"></A><B>python-options</B>*
	Object partly supporting <A HREF="map.html#mapping">mapping</A> protocol (supports setting and 
	getting items) providing a read-write access to global <A HREF="options.html#options">options</A>.
	Note: unlike |<A HREF="options.html#:set">:set</A>| this provides access only to global <A HREF="options.html#options">options</A>. You
	cannot use this object to obtain or set local options' values or
	access local-only <A HREF="options.html#options">options</A> in any fashion. Raises KeyError if no global
	option with such name exists (i.e. does not raise KeyError for
	|<A HREF="options.html#global-local">global-local</A>| <A HREF="options.html#options">options</A> and global only <A HREF="options.html#options">options</A>, but does for window-
	and buffer-local ones).  Use |<A HREF="#python-buffer">python-buffer</A>| <A HREF="vimindex.html#objects">objects</A> to access to
	buffer-local <A HREF="options.html#options">options</A> and |<A HREF="#python-window">python-window</A>| <A HREF="vimindex.html#objects">objects</A> to access to
	window-local <A HREF="options.html#options">options</A>.

	Type of this object is available via &quot;Options&quot; attribute of vim 
	module.


Output from <A HREF="#Python">Python</A>					*<A NAME="python-output"></A><B>python-output</B>*
	Vim displays all <A HREF="#Python">Python</A> code output in the Vim message area.  <A HREF="intro.html#Normal">Normal</A>
	output appears <A HREF="motion.html#as">as</A> information <A HREF="message.html#messages">messages</A>, and error output appears <A HREF="motion.html#as">as</A>
	error <A HREF="message.html#messages">messages</A>.

	In implementation terms, this means that all output to sys.stdout
	(including the output from print statements) appears <A HREF="motion.html#as">as</A> information
	<A HREF="message.html#messages">messages</A>, and all output to sys.stderr (including error tracebacks)
	appears <A HREF="motion.html#as">as</A> error <A HREF="message.html#messages">messages</A>.


							*<A NAME="python-input"></A><B>python-input</B>*
	Input (via sys.stdin, including <A HREF="eval.html#input()">input()</A> and raw_input()) is not
	supported, and may cause the program to crash.  This should probably be
	fixed.


		    *<A NAME="python2-directory"></A><B>python2-directory</B>* *<A NAME="python3-directory"></A><B>python3-directory</B>* *<A NAME="pythonx-directory"></A><B>pythonx-directory</B>*

<A HREF="#Python">Python</A> <A HREF="options.html#'runtimepath'">'runtimepath'</A> handling				*<A NAME="python-special-path"></A><B>python-special-path</B>*

In <A HREF="#python">python</A> vim.VIM_SPECIAL_PATH special directory is used <A HREF="motion.html#as">as</A> a replacement for 
the <A HREF="eval.html#list">list</A> of paths found in <A HREF="options.html#'runtimepath'">'runtimepath'</A>: with this directory in sys.path and 
vim.path_hooks in sys.path_hooks <A HREF="#python">python</A> will try to load module from 
{rtp}/python2 (or <A HREF="#python3">python3</A>) and {rtp}/pythonx (for both <A HREF="#python">python</A> versions) for 
each {rtp} found in <A HREF="options.html#'runtimepath'">'runtimepath'</A>.

Implementation is similar to the following, but written in C:

<B>    from imp import find_module, load_module</B>
<B>    import vim</B>
<B>    import sys</B>

<B>    class VimModuleLoader(object):</B>
<B>        def __init__(self, module):</B>
<B>            self.module = module</B>

<B>        def load_module(self, fullname, path=None):</B>
<B>            return self.module</B>

<B>    def _find_module(fullname, oldtail, path):</B>
<B>        idx = oldtail.find('.')</B>
<B>        if idx &gt; 0:</B>
<B>            name = oldtail[:idx]</B>
<B>            tail = oldtail[idx+1:]</B>
<B>            fmr = find_module(name, path)</B>
<B>            module = load_module(fullname[:-len(oldtail)] + name, *fmr)</B>
<B>            return _find_module(fullname, tail, module.__path__)</B>
<B>        else:</B>
<B>            fmr = find_module(fullname, path)</B>
<B>            return load_module(fullname, *fmr)</B>

<B>    # It uses vim module itself in place of VimPathFinder class: it does not </B>
<B>    # matter for python which object has find_module function attached to as </B>
<B>    # an attribute.</B>
<B>    class VimPathFinder(object):</B>
<B>        @classmethod</B>
<B>        def find_module(cls, fullname, path=None):</B>
<B>            try:</B>
<B>                return VimModuleLoader(_find_module(fullname, fullname, path or vim._get_paths()))</B>
<B>            except ImportError:</B>
<B>                return None</B>

<B>        @classmethod</B>
<B>        def load_module(cls, fullname, path=None):</B>
<B>            return _find_module(fullname, fullname, path or vim._get_paths())</B>

<B>    def hook(path):</B>
<B>        if path == vim.VIM_SPECIAL_PATH:</B>
<B>            return VimPathFinder</B>
<B>        else:</B>
<B>            raise ImportError</B>

<B>    sys.path_hooks.append(hook)</B>


vim.VIM_SPECIAL_PATH					*<A NAME="python-VIM_SPECIAL_PATH"></A><B>python-VIM_SPECIAL_PATH</B>*
	<A HREF="eval.html#String">String</A> constant used in conjunction with vim path hook. If path hook 
	installed by vim is requested to handle anything but path equal to 
	vim.VIM_SPECIAL_PATH constant <A HREF="motion.html#it">it</A> raises ImportError. In the only other 
	<A HREF="change.html#case">case</A> <A HREF="motion.html#it">it</A> uses special loader.

	Note: you must not use value of this constant directly, always use 
	      vim.VIM_SPECIAL_PATH object.


vim.find_module(...)					*<A NAME="python-find_module"></A><B>python-find_module</B>*

vim.path_hook(path)					*<A NAME="python-path_hook"></A><B>python-path_hook</B>*
	Methods or <A HREF="vimindex.html#objects">objects</A> used to implement path loading <A HREF="motion.html#as">as</A> described above. 
	You should not be using any of these directly except for vim.path_hook 
	in <A HREF="change.html#case">case</A> you need to <A HREF="diff.html#do">do</A> something with sys.meta_path. It is not 
	guaranteed that any of the <A HREF="vimindex.html#objects">objects</A> will exist in the future vim 
	versions.


vim._get_paths						*<A NAME="python-_get_paths"></A><B>python-_get_paths</B>*
	Methods returning a <A HREF="eval.html#list">list</A> of paths which will be searched for by path 
	hook. You should not rely on this method being present in future 
	versions, but can use <A HREF="motion.html#it">it</A> for debugging.

	It returns a <A HREF="eval.html#list">list</A> of {rtp}/python2 (or {rtp}/python3) and 
	{rtp}/pythonx directories for each {rtp} in <A HREF="options.html#'runtimepath'">'runtimepath'</A>.

==============================================================================

Buffer <A HREF="vimindex.html#objects">objects</A>						*<A NAME="python-buffer"></A><B>python-buffer</B>*

Buffer <A HREF="vimindex.html#objects">objects</A> represent vim <A HREF="windows.html#buffers">buffers</A>.  You can obtain them in a number of ways:
	- via vim.current.buffer (|<A HREF="#python-current">python-current</A>|)
	- from indexing vim.buffers (|<A HREF="#python-buffers">python-buffers</A>|)
	- from the &quot;buffer&quot; attribute of a window (|<A HREF="#python-window">python-window</A>|)

Buffer <A HREF="vimindex.html#objects">objects</A> have two read-only attributes - name - the full file name for
the buffer, and number - the buffer number.  They also have three methods
(append, <A HREF="motion.html#mark">mark</A>, and range; see below).

You can also treat buffer <A HREF="vimindex.html#objects">objects</A> <A HREF="motion.html#as">as</A> sequence <A HREF="vimindex.html#objects">objects</A>.  In this <A HREF="repeat.html#context">context</A>, they
act <A HREF="motion.html#as">as</A> if they were lists (yes, they are mutable) of strings, with each
element being a line of the buffer.  All of the usual sequence operations,
including indexing, index assignment, slicing and <A HREF="eval.html#slice">slice</A> assignment, work <A HREF="motion.html#as">as</A>
you would expect.  Note that the result of indexing (slicing) a buffer is a
<A HREF="eval.html#string">string</A> (list of strings).  This has one unusual consequence - b[:] is different
from <A HREF="motion.html#b">b</A>.  In particular, &quot;b[:] = None&quot; deletes the whole of the buffer, whereas
&quot;<A HREF="motion.html#b">b</A> = None&quot; merely updates the variable <A HREF="motion.html#b">b</A>, with no effect on the buffer.

Buffer indexes start at zero, <A HREF="motion.html#as">as</A> is normal in <A HREF="#Python">Python</A>.  This differs from vim
line numbers, which start from 1.  This is particularly relevant when dealing
with marks (see below) which use vim line numbers.

The buffer object attributes are:
	b.vars		Dictionary-like object used to access 
			|<A HREF="eval.html#buffer-variable">buffer-variable</A>|<A HREF="change.html#s">s</A>.
	b.options	Mapping object (supports item getting, setting and 
			<A HREF="change.html#deleting">deleting</A>) that provides access to buffer-local <A HREF="options.html#options">options</A> 
			and buffer-local values of |<A HREF="options.html#global-local">global-local</A>| <A HREF="options.html#options">options</A>. Use 
			|<A HREF="#python-window">python-window</A>|.options if option is window-local, 
			this object will raise KeyError. If option is 
			|<A HREF="options.html#global-local">global-local</A>| and local value is missing getting <A HREF="motion.html#it">it</A> 
			will return None.
	b.name		<A HREF="eval.html#String">String</A>, RW. Contains buffer name (full path).
			Note: when assigning to b.name |<A HREF="autocmd.html#BufFilePre">BufFilePre</A>| and 
			|<A HREF="autocmd.html#BufFilePost">BufFilePost</A>| autocommands are launched.
	b.number	Buffer number. Can be used <A HREF="motion.html#as">as</A> |<A HREF="#python-buffers">python-buffers</A>| key.
			Read-only.
	b.valid		True or False. Buffer object becomes invalid when 
			corresponding buffer is wiped out.

The buffer object methods are:
	b.append(str)	Append a line to the buffer
	b.append(str, nr)  Idem, below line &quot;nr&quot;
	b.append(list)	Append a <A HREF="eval.html#list">list</A> of lines to the buffer
			Note that the option of supplying a <A HREF="eval.html#list">list</A> of strings to
			the append method differs from the equivalent method
			for Python's built-in <A HREF="eval.html#list">list</A> <A HREF="vimindex.html#objects">objects</A>.
	b.append(list, nr)  Idem, below line &quot;nr&quot;
	b.mark(name)	Return a tuple (row,col) representing the position
			of the named <A HREF="motion.html#mark">mark</A> (can also get the []&quot;&lt;&gt; marks)
	b.range(s,e)	Return a range object (see |<A HREF="#python-range">python-range</A>|) which
			represents the part of the given buffer between line
			numbers s and e |<A HREF="motion.html#inclusive">inclusive</A>|.

Note that when adding a line <A HREF="motion.html#it">it</A> must not contain a line break character '\n'.
A trailing '\n' is allowed and ignored, so that you can <A HREF="diff.html#do">do</A>:
<B>	:py b.append(f.readlines())</B>

Buffer object type is available using &quot;Buffer&quot; attribute of vim module.

Examples (assume <A HREF="motion.html#b">b</A> is the current buffer)
<B>	:py print b.name		# write the buffer file name</B>
<B>	:py b[0] = "hello!!!"		# replace the top line</B>
<B>	:py b[:] = None			# delete the whole buffer</B>
<B>	:py del b[:]			# delete the whole buffer</B>
<B>	:py b[0:0] = [ "a line" ]	# add a line at the top</B>
<B>	:py del b[2]			# delete a line (the third)</B>
<B>	:py b.append("bottom")		# add a line at the bottom</B>
<B>	:py n = len(b)			# number of lines</B>
<B>	:py (row,col) = b.mark('a')	# named mark</B>
<B>	:py r = b.range(1,5)		# a sub-range of the buffer</B>
<B>	:py b.vars["foo"] = "bar"	# assign b:foo variable</B>
<B>	:py b.options["ff"] = "dos"	# set fileformat</B>
<B>	:py del b.options["ar"]		# same as :set autoread&lt;</B>

==============================================================================

Range <A HREF="vimindex.html#objects">objects</A>						*<A NAME="python-range"></A><B>python-range</B>*

Range <A HREF="vimindex.html#objects">objects</A> represent a part of a vim buffer.  You can obtain them in a
number of ways:
	- via vim.current.range (|<A HREF="#python-current">python-current</A>|)
	- from a buffer's <A HREF="eval.html#range()">range()</A> method (|<A HREF="#python-buffer">python-buffer</A>|)

A range object is almost identical in operation to a buffer object.  However,
all operations are restricted to the lines within the range (this line range
can, of course, change <A HREF="motion.html#as">as</A> a result of <A HREF="eval.html#slice">slice</A> assignments, line deletions, or
the range.append() method).

The range object attributes are:
	r.start		Index of first line into the buffer
	r.end		Index of last line into the buffer

The range object methods are:
	r.append(str)	Append a line to the range
	r.append(str, nr)  Idem, after line &quot;nr&quot;
	r.append(list)	Append a <A HREF="eval.html#list">list</A> of lines to the range
			Note that the option of supplying a <A HREF="eval.html#list">list</A> of strings to
			the append method differs from the equivalent method
			for Python's built-in <A HREF="eval.html#list">list</A> <A HREF="vimindex.html#objects">objects</A>.
	r.append(list, nr)  Idem, after line &quot;nr&quot;

Range object type is available using &quot;Range&quot; attribute of vim module.

Example (assume <A HREF="change.html#r">r</A> is the current range):
	# Send all lines in a range to the default printer
	vim.command(&quot;&#37;d,&#37;dhardcopy!&quot; <A HREF="motion.html#&#37;">&#37;</A> (r.start+1,r.end+1))

==============================================================================

Window <A HREF="vimindex.html#objects">objects</A>						*<A NAME="python-window"></A><B>python-window</B>*

Window <A HREF="vimindex.html#objects">objects</A> represent vim <A HREF="windows.html#windows">windows</A>.  You can obtain them in a number of ways:
	- via vim.current.window (|<A HREF="#python-current">python-current</A>|)
	- from indexing vim.windows (|<A HREF="#python-windows">python-windows</A>|)
	- from indexing &quot;<A HREF="windows.html#windows">windows</A>&quot; attribute of a tab page (|<A HREF="#python-tabpage">python-tabpage</A>|)
	- from the &quot;<A HREF="windows.html#window">window</A>&quot; attribute of a tab page (|<A HREF="#python-tabpage">python-tabpage</A>|)

You can manipulate <A HREF="windows.html#window">window</A> <A HREF="vimindex.html#objects">objects</A> only through their attributes.  They have no
methods, and no sequence or other interface.

Window attributes are:
	buffer (read-only)	The buffer displayed in this <A HREF="windows.html#window">window</A>
	cursor (read-write)	The current cursor position in the <A HREF="windows.html#window">window</A>
				This is a tuple, (row,col).
	height (read-write)	The <A HREF="windows.html#window">window</A> height, in rows
	width (read-write)	The <A HREF="windows.html#window">window</A> width, in columns
	vars (read-only)	The <A HREF="windows.html#window">window</A> |<A HREF="eval.html#w:">w:</A>| <A HREF="eval.html#variables">variables</A>. Attribute is 
				unassignable, but you can change <A HREF="windows.html#window">window</A> 
				<A HREF="eval.html#variables">variables</A> this way
	<A HREF="options.html#options">options</A> (read-only)	The window-local <A HREF="options.html#options">options</A>. Attribute is 
				unassignable, but you can change <A HREF="windows.html#window">window</A> 
				<A HREF="options.html#options">options</A> this way. Provides access only to 
				window-local <A HREF="options.html#options">options</A>, for buffer-local use 
				|<A HREF="#python-buffer">python-buffer</A>| and for global ones use 
				|<A HREF="#python-options">python-options</A>|. If option is |<A HREF="options.html#global-local">global-local</A>| 
				and local value is missing getting <A HREF="motion.html#it">it</A> will 
				return None.
	number (read-only)	Window number.  The first <A HREF="windows.html#window">window</A> has number 1.
				This is zero in <A HREF="change.html#case">case</A> <A HREF="motion.html#it">it</A> cannot be determined
				(e.g. when the <A HREF="windows.html#window">window</A> object belongs to other
				<A HREF="intro.html#tab">tab</A> page).
	row, col (read-only)	On-screen <A HREF="windows.html#window">window</A> position in display cells.
				First position is zero.
	<A HREF="tabpage.html#tabpage">tabpage</A> (read-only)	Window <A HREF="intro.html#tab">tab</A> page.
	valid (read-write)	True or False. Window object becomes invalid 
				when corresponding <A HREF="windows.html#window">window</A> is closed.

The height attribute is writable only if the screen is split horizontally.
The width attribute is writable only if the screen is split vertically.

Window object type is available using &quot;Window&quot; attribute of vim module.

==============================================================================

<A HREF="intro.html#Tab">Tab</A> page <A HREF="vimindex.html#objects">objects</A>					*<A NAME="python-tabpage"></A><B>python-tabpage</B>*

<A HREF="intro.html#Tab">Tab</A> page <A HREF="vimindex.html#objects">objects</A> represent vim <A HREF="intro.html#tab">tab</A> pages. You can obtain them in a number of 
ways:
	- via vim.current.tabpage (|<A HREF="#python-current">python-current</A>|)
	- from indexing vim.tabpages (|<A HREF="#python-tabpages">python-tabpages</A>|)

You can use this object to access <A HREF="intro.html#tab">tab</A> page <A HREF="windows.html#windows">windows</A>. They have no methods and 
no sequence or other interfaces.

<A HREF="intro.html#Tab">Tab</A> page attributes are:
	number		The <A HREF="intro.html#tab">tab</A> page number like the one returned by 
			|<A HREF="eval.html#tabpagenr()">tabpagenr()</A>|.
	windows		Like |<A HREF="#python-windows">python-windows</A>|, but for current <A HREF="intro.html#tab">tab</A> page.
	vars		The <A HREF="intro.html#tab">tab</A> page |<A HREF="eval.html#t:">t:</A>| <A HREF="eval.html#variables">variables</A>.
	<A HREF="windows.html#window">window</A>		Current <A HREF="tabpage.html#tabpage">tabpage</A> <A HREF="windows.html#window">window</A>.
	valid		True or False. <A HREF="intro.html#Tab">Tab</A> page object becomes invalid when 
			corresponding <A HREF="intro.html#tab">tab</A> page is closed.

TabPage object type is available using &quot;TabPage&quot; attribute of vim module.

==============================================================================

<A HREF="eval.html#pyeval()">pyeval()</A> and <A HREF="eval.html#py3eval()">py3eval()</A> Vim <A HREF="eval.html#functions">functions</A>			*<A NAME="python-pyeval"></A><B>python-pyeval</B>*

To facilitate bi-directional interface, you can use |<A HREF="eval.html#pyeval()">pyeval()</A>| and |<A HREF="eval.html#py3eval()">py3eval()</A>| 
<A HREF="eval.html#functions">functions</A> to evaluate <A HREF="#Python">Python</A> expressions and pass their values to Vim <A HREF="usr_41.html#script">script</A>.
|<A HREF="eval.html#pyxeval()">pyxeval()</A>| is also available.

==============================================================================

<A HREF="#Python">Python</A> 3						*<A NAME="python3"></A><B>python3</B>*


							*<A NAME=":py3"></A><B>:py3</B>* *<A NAME=":python3"></A><B>:python3</B>*
The `:py3` and `:python3` commands work similar to `:python`.  A simple check
if the `:py3` command is working:
<B>	:py3 print("Hello")</B>

To see what version of <A HREF="#Python">Python</A> you have:
<B>	:py3 import sys</B>
<B>	:py3 print(sys.version)</B>

 							*<A NAME=":py3file"></A><B>:py3file</B>*
The `:py3file` command works similar to `:pyfile`.

							*<A NAME=":py3do"></A><B>:py3do</B>*
The `:py3do` command works similar to `:pydo`.


							*<A NAME="E880"></A><B>E880</B>*
Raising SystemExit exception in <A HREF="#python">python</A> isn't endorsed way to quit vim, use:
<B>	:py vim.command("qall!")</B>
 

							*<A NAME="has-python"></A><B>has-python</B>*
You can test what <A HREF="#Python">Python</A> version is available with:
<B>	if has('python')</B>
<B>	  echo 'there is Python 2.x'</B>
<B>	endif</B>
<B>  	if has('python3')</B>
<B>	  echo 'there is Python 3.x'</B>
<B>	endif</B>

==============================================================================

<A HREF="#Python">Python</A> X						*<A NAME="python_x"></A><B>python_x</B>* *<A NAME="pythonx"></A><B>pythonx</B>*

Because most <A HREF="#python">python</A> code can be written so that <A HREF="motion.html#it">it</A> works with <A HREF="#Python">Python</A> 2.6+ and
<A HREF="#Python">Python</A> 3, the pyx* <A HREF="eval.html#functions">functions</A> and commands have been written.  They work the
same <A HREF="motion.html#as">as</A> the <A HREF="#Python">Python</A> 2 and 3 variants, but select the <A HREF="#Python">Python</A> version using the
<A HREF="options.html#'pyxversion'">'pyxversion'</A> setting.

Set <A HREF="options.html#'pyxversion'">'pyxversion'</A> in your |<A HREF="starting.html#vimrc">vimrc</A>| to prefer <A HREF="#Python">Python</A> 2 or <A HREF="#Python">Python</A> 3 for <A HREF="#Python">Python</A>
commands. Changing this setting at runtime risks losing the state of plugins
(such <A HREF="motion.html#as">as</A> <A HREF="starting.html#initialization">initialization</A>).

If you want to use a module, you can put <A HREF="motion.html#it">it</A> in the {rtp}/pythonx directory.
See |<A HREF="#pythonx-directory">pythonx-directory</A>|.


							*<A NAME=":pyx"></A><B>:pyx</B>* *<A NAME=":pythonx"></A><B>:pythonx</B>*
`:pyx` and `:pythonx` work similar to `:python`.  To check if `:pyx` works:
<B>	:pyx print("Hello")</B>

To see what version of <A HREF="#Python">Python</A> is being used:
<B>	:pyx import sys</B>
<B>	:pyx print(sys.version)</B>
 

					*<A NAME=":pyxfile"></A><B>:pyxfile</B>* *<A NAME="python_x-special-comments"></A><B>python_x-special-comments</B>*
`:pyxfile` works similar to `:pyfile`.  But you can add a &quot;shebang&quot; comment to
force Vim to use `:pyfile` or `:py3file`:
<B>  #!/any string/python2		" Shebang. Must be the first line of the file.</B>
<B>  #!/any string/python3		" Shebang. Must be the first line of the file.</B>
<B>  # requires python 2.x		" Maximum lines depend on 'modelines'.</B>
<B>  # requires python 3.x		" Maximum lines depend on 'modelines'.</B>
Unlike normal modelines, the bottom of the file is not checked.
If none of them are found, the <A HREF="options.html#'pyxversion'">'pyxversion'</A> option is used.

							*<A NAME="W20"></A><B>W20</B>* *<A NAME="W21"></A><B>W21</B>*
If Vim does not support the selected <A HREF="#Python">Python</A> version a silent message will be
printed.  Use `:messages` to read them.


							*<A NAME=":pyxdo"></A><B>:pyxdo</B>*
`:pyxdo` works similar to `:pydo`.


							*<A NAME="has-pythonx"></A><B>has-pythonx</B>*
To check if pyx* <A HREF="eval.html#functions">functions</A> and commands are available:
<B>	if has('pythonx')</B>
<B>	  echo 'pyx* commands are available. (Python ' . &amp;pyx . ')'</B>
<B>	endif</B>

If you prefer <A HREF="#Python">Python</A> 2 and want to fallback to <A HREF="#Python">Python</A> 3, set <A HREF="options.html#'pyxversion'">'pyxversion'</A>
explicitly in your |<A HREF="intro.html#.vimrc">.vimrc</A>|.  Example:
<B>	if has('python')</B>
<B>	  set pyx=2</B>
<B>	elseif has('python3')</B>
<B>	  set pyx=3</B>
<B>	endif</B>

==============================================================================
<A HREF="#top">top</A> - <A HREF="index.html">main help file</A>
</PRE>
    </div>

    <footer>
      <div class="container">
        Generated Fri Apr 30 05:44:46 UTC 2021 from <a href="https://github.com/neovim/neovim/commit/59eae3b38fc98ba8c14e681b6d231e9821a11d52"><code>59eae3b</code></a>.
      </div>
    </footer>
  </body>
</html>
