<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>Neovim: src/nvim/api/buffer.c File Reference</title>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
<link href="http://fonts.googleapis.com/css?family=Lato:400,700,900" rel="stylesheet">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="navbar">
  <div class="container">
    <nav class="site-nav">
      <ul>
        <li><a href="http://neovim.io/">Neovim Home</a></li>
      </ul>
    </nav>
    <a href="index.html">
      <img src="logo-devdoc.png" class="logo" alt="Neovim Dev-Doc">
    </a>
  </div>
</header>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_bc030da22f6f77ebb27ffd39b609bafa.html">nvim</a></li><li class="navelem"><a class="el" href="dir_5031ba7ba6e88ee94a8e02befd8c46c8.html">api</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">buffer.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;limits.h&gt;</code><br />
<code>#include &lt;lauxlib.h&gt;</code><br />
<code>#include &quot;<a class="el" href="api_2buffer_8h_source.html">nvim/api/buffer.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="api_2private_2helpers_8h_source.html">nvim/api/private/helpers.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="api_2private_2defs_8h_source.html">nvim/api/private/defs.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lua_2executor_8h_source.html">nvim/lua/executor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="vim_8h_source.html">nvim/vim.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buffer_8h_source.html">nvim/buffer.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="change_8h_source.html">nvim/change.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="charset_8h_source.html">nvim/charset.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cursor_8h_source.html">nvim/cursor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="getchar_8h_source.html">nvim/getchar.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="memline_8h_source.html">nvim/memline.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="memory_8h_source.html">nvim/memory.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="misc1_8h_source.html">nvim/misc1.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ex__cmds_8h_source.html">nvim/ex_cmds.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="map__defs_8h_source.html">nvim/map_defs.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="map_8h_source.html">nvim/map.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mark_8h_source.html">nvim/mark.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="extmark_8h_source.html">nvim/extmark.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="decoration_8h_source.html">nvim/decoration.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fileio_8h_source.html">nvim/fileio.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="move_8h_source.html">nvim/move.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="syntax_8h_source.html">nvim/syntax.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="window_8h_source.html">nvim/window.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="undo_8h_source.html">nvim/undo.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ex__docmd_8h_source.html">nvim/ex_docmd.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buffer__updates_8h_source.html">nvim/buffer_updates.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a09e58ac4ac75dc5d6434a663ec91ca62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#a09e58ac4ac75dc5d6434a663ec91ca62">nvim_buf_line_count</a> (Buffer buffer, <a class="el" href="structError.html">Error</a> *err) FUNC_API_SINCE(1)</td></tr>
<tr class="separator:a09e58ac4ac75dc5d6434a663ec91ca62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e0eaf29e0df4640ff77349368d6f87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="api_2private_2defs_8h.html#a3790b6de8c45ebee9af548380c3fb8d2">Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#a51e0eaf29e0df4640ff77349368d6f87">nvim_buf_attach</a> (uint64_t channel_id, Buffer buffer, <a class="el" href="api_2private_2defs_8h.html#a3790b6de8c45ebee9af548380c3fb8d2">Boolean</a> send_buffer, DictionaryOf(<a class="el" href="types_8h.html#a88fc3de9276c6cd5a57765fbb4005ee3">LuaRef</a>) opts, <a class="el" href="structError.html">Error</a> *err) FUNC_API_SINCE(4)</td></tr>
<tr class="separator:a51e0eaf29e0df4640ff77349368d6f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ceaf3e2b47623c4ceb86733cced5a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="api_2private_2defs_8h.html#a3790b6de8c45ebee9af548380c3fb8d2">Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#ad1ceaf3e2b47623c4ceb86733cced5a4">nvim_buf_detach</a> (uint64_t channel_id, Buffer buffer, <a class="el" href="structError.html">Error</a> *err) FUNC_API_SINCE(4) FUNC_API_REMOTE_ONLY</td></tr>
<tr class="separator:ad1ceaf3e2b47623c4ceb86733cced5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed217c5ca4d3be967b08e9fff37705c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pty__conpty__win_8h.html#a690727517acf82fb8c93ad801e3ca4e3">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#a9ed217c5ca4d3be967b08e9fff37705c">nvim__buf_redraw_range</a> (Buffer buffer, <a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> first, <a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> last, <a class="el" href="structError.html">Error</a> *err) FUNC_API_LUA_ONLY</td></tr>
<tr class="separator:a9ed217c5ca4d3be967b08e9fff37705c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910f20ac8647adbd7087107157eff91d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#a910f20ac8647adbd7087107157eff91d">ArrayOf</a> (<a class="el" href="structString.html">String</a>)</td></tr>
<tr class="separator:a910f20ac8647adbd7087107157eff91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54f580408d8de25ec2bea97f2ef1a37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pty__conpty__win_8h.html#a690727517acf82fb8c93ad801e3ca4e3">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#aa54f580408d8de25ec2bea97f2ef1a37">nvim_buf_set_lines</a> (uint64_t channel_id, Buffer buffer, <a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> start, <a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> end, <a class="el" href="api_2private_2defs_8h.html#a3790b6de8c45ebee9af548380c3fb8d2">Boolean</a> strict_indexing, <a class="el" href="api_2window_8c.html#a2a0cecba9d1a9c6a0975001e304b4d37">ArrayOf</a>(<a class="el" href="structString.html">String</a>) replacement, <a class="el" href="structError.html">Error</a> *err) FUNC_API_CHECK_TEXTLOCK</td></tr>
<tr class="separator:aa54f580408d8de25ec2bea97f2ef1a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005b99e1f0e31030a51785091af9e44d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pty__conpty__win_8h.html#a690727517acf82fb8c93ad801e3ca4e3">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#a005b99e1f0e31030a51785091af9e44d">nvim_buf_set_text</a> (uint64_t channel_id, Buffer buffer, <a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> start_row, <a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> start_col, <a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> end_row, <a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> end_col, <a class="el" href="api_2window_8c.html#a2a0cecba9d1a9c6a0975001e304b4d37">ArrayOf</a>(<a class="el" href="structString.html">String</a>) replacement, <a class="el" href="structError.html">Error</a> *err) FUNC_API_SINCE(7)</td></tr>
<tr class="separator:a005b99e1f0e31030a51785091af9e44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296934998d3a64a0902e93ae2a59ec36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#a296934998d3a64a0902e93ae2a59ec36">nvim_buf_get_offset</a> (Buffer buffer, <a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> index, <a class="el" href="structError.html">Error</a> *err) FUNC_API_SINCE(5)</td></tr>
<tr class="separator:a296934998d3a64a0902e93ae2a59ec36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dd4d4b63b617cede33b38547870175"><td class="memItemLeft" align="right" valign="top"><a class="el" href="api_2private_2defs_8h.html#ac1d573b78381906e7299e87cab9152bc">Object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#a48dd4d4b63b617cede33b38547870175">nvim_buf_get_var</a> (Buffer buffer, <a class="el" href="structString.html">String</a> <a class="el" href="ops_8c.html#a42a51826900fc3d2c5ad0213bffc9e5d">name</a>, <a class="el" href="structError.html">Error</a> *err) FUNC_API_SINCE(1)</td></tr>
<tr class="separator:a48dd4d4b63b617cede33b38547870175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9acdcf1d8bc62642a275987ad1ae918"><td class="memItemLeft" align="right" valign="top"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#ae9acdcf1d8bc62642a275987ad1ae918">nvim_buf_get_changedtick</a> (Buffer buffer, <a class="el" href="structError.html">Error</a> *err) FUNC_API_SINCE(2)</td></tr>
<tr class="separator:ae9acdcf1d8bc62642a275987ad1ae918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35d58558d9fa1e2523451b662cd01ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#af35d58558d9fa1e2523451b662cd01ce">ArrayOf</a> (<a class="el" href="structDictionary.html">Dictionary</a>)</td></tr>
<tr class="separator:af35d58558d9fa1e2523451b662cd01ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d610ef8128347a35ee061de43ae2de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pty__conpty__win_8h.html#a690727517acf82fb8c93ad801e3ca4e3">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#aa6d610ef8128347a35ee061de43ae2de">nvim_buf_set_keymap</a> (Buffer buffer, <a class="el" href="structString.html">String</a> mode, <a class="el" href="structString.html">String</a> lhs, <a class="el" href="structString.html">String</a> rhs, <a class="el" href="structDictionary.html">Dictionary</a> opts, <a class="el" href="structError.html">Error</a> *err) FUNC_API_SINCE(6)</td></tr>
<tr class="separator:aa6d610ef8128347a35ee061de43ae2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1331d52d36f62c542bc9645333fbc027"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pty__conpty__win_8h.html#a690727517acf82fb8c93ad801e3ca4e3">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#a1331d52d36f62c542bc9645333fbc027">nvim_buf_del_keymap</a> (Buffer buffer, <a class="el" href="structString.html">String</a> mode, <a class="el" href="structString.html">String</a> lhs, <a class="el" href="structError.html">Error</a> *err) FUNC_API_SINCE(6)</td></tr>
<tr class="separator:a1331d52d36f62c542bc9645333fbc027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc81a63ea25885db52d5df236d25a15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDictionary.html">Dictionary</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#a9bc81a63ea25885db52d5df236d25a15">nvim_buf_get_commands</a> (Buffer buffer, <a class="el" href="structDictionary.html">Dictionary</a> opts, <a class="el" href="structError.html">Error</a> *err) FUNC_API_SINCE(4)</td></tr>
<tr class="separator:a9bc81a63ea25885db52d5df236d25a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f13a02500dd233dd0c4a314686d518d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pty__conpty__win_8h.html#a690727517acf82fb8c93ad801e3ca4e3">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#a2f13a02500dd233dd0c4a314686d518d">nvim_buf_set_var</a> (Buffer buffer, <a class="el" href="structString.html">String</a> <a class="el" href="ops_8c.html#a42a51826900fc3d2c5ad0213bffc9e5d">name</a>, <a class="el" href="api_2private_2defs_8h.html#ac1d573b78381906e7299e87cab9152bc">Object</a> value, <a class="el" href="structError.html">Error</a> *err) FUNC_API_SINCE(1)</td></tr>
<tr class="separator:a2f13a02500dd233dd0c4a314686d518d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1590b78591312d66b333a102da8f3bc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pty__conpty__win_8h.html#a690727517acf82fb8c93ad801e3ca4e3">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#a1590b78591312d66b333a102da8f3bc2">nvim_buf_del_var</a> (Buffer buffer, <a class="el" href="structString.html">String</a> <a class="el" href="ops_8c.html#a42a51826900fc3d2c5ad0213bffc9e5d">name</a>, <a class="el" href="structError.html">Error</a> *err) FUNC_API_SINCE(1)</td></tr>
<tr class="separator:a1590b78591312d66b333a102da8f3bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6bd4918fa8c3a540ebb20b8fd4d03e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="api_2private_2defs_8h.html#ac1d573b78381906e7299e87cab9152bc">Object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#a1a6bd4918fa8c3a540ebb20b8fd4d03e">nvim_buf_get_option</a> (Buffer buffer, <a class="el" href="structString.html">String</a> <a class="el" href="ops_8c.html#a42a51826900fc3d2c5ad0213bffc9e5d">name</a>, <a class="el" href="structError.html">Error</a> *err) FUNC_API_SINCE(1)</td></tr>
<tr class="separator:a1a6bd4918fa8c3a540ebb20b8fd4d03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ebba3d00cf0c40379454c1a52e8b08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pty__conpty__win_8h.html#a690727517acf82fb8c93ad801e3ca4e3">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#ae0ebba3d00cf0c40379454c1a52e8b08">nvim_buf_set_option</a> (uint64_t channel_id, Buffer buffer, <a class="el" href="structString.html">String</a> <a class="el" href="ops_8c.html#a42a51826900fc3d2c5ad0213bffc9e5d">name</a>, <a class="el" href="api_2private_2defs_8h.html#ac1d573b78381906e7299e87cab9152bc">Object</a> value, <a class="el" href="structError.html">Error</a> *err) FUNC_API_SINCE(1)</td></tr>
<tr class="separator:ae0ebba3d00cf0c40379454c1a52e8b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac278a74b984d3b19bf925281c5d8bbd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structString.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#ac278a74b984d3b19bf925281c5d8bbd8">nvim_buf_get_name</a> (Buffer buffer, <a class="el" href="structError.html">Error</a> *err) FUNC_API_SINCE(1)</td></tr>
<tr class="separator:ac278a74b984d3b19bf925281c5d8bbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e8755796885aa5e7555db96322d2d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pty__conpty__win_8h.html#a690727517acf82fb8c93ad801e3ca4e3">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#a09e8755796885aa5e7555db96322d2d9">nvim_buf_set_name</a> (Buffer buffer, <a class="el" href="structString.html">String</a> <a class="el" href="ops_8c.html#a42a51826900fc3d2c5ad0213bffc9e5d">name</a>, <a class="el" href="structError.html">Error</a> *err) FUNC_API_SINCE(1)</td></tr>
<tr class="separator:a09e8755796885aa5e7555db96322d2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a80a71cd86e55ed4041ebbda9812a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="api_2private_2defs_8h.html#a3790b6de8c45ebee9af548380c3fb8d2">Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#a12a80a71cd86e55ed4041ebbda9812a4">nvim_buf_is_loaded</a> (Buffer buffer) FUNC_API_SINCE(5)</td></tr>
<tr class="separator:a12a80a71cd86e55ed4041ebbda9812a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab675618bfabd9fafacc6f35d0b577e89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pty__conpty__win_8h.html#a690727517acf82fb8c93ad801e3ca4e3">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#ab675618bfabd9fafacc6f35d0b577e89">nvim_buf_delete</a> (Buffer buffer, <a class="el" href="structDictionary.html">Dictionary</a> opts, <a class="el" href="structError.html">Error</a> *err) FUNC_API_CHECK_TEXTLOCK</td></tr>
<tr class="separator:ab675618bfabd9fafacc6f35d0b577e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9193c4fd297ff692d5b2364e80db1e9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="api_2private_2defs_8h.html#a3790b6de8c45ebee9af548380c3fb8d2">Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#a9193c4fd297ff692d5b2364e80db1e9e">nvim_buf_is_valid</a> (Buffer buffer) FUNC_API_SINCE(1)</td></tr>
<tr class="separator:a9193c4fd297ff692d5b2364e80db1e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0cecba9d1a9c6a0975001e304b4d37"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#a2a0cecba9d1a9c6a0975001e304b4d37">ArrayOf</a> (<a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>, 2)</td></tr>
<tr class="separator:a2a0cecba9d1a9c6a0975001e304b4d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2eaab20df89681b62d7b1d8eeac594a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#ab2eaab20df89681b62d7b1d8eeac594a">ArrayOf</a> (<a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>)</td></tr>
<tr class="separator:ab2eaab20df89681b62d7b1d8eeac594a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3927ebe490dd9f46b55ced9b72685b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structArray.html">Array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#a2d3927ebe490dd9f46b55ced9b72685b">nvim_buf_get_extmarks</a> (Buffer buffer, <a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> ns_id, <a class="el" href="api_2private_2defs_8h.html#ac1d573b78381906e7299e87cab9152bc">Object</a> start, <a class="el" href="api_2private_2defs_8h.html#ac1d573b78381906e7299e87cab9152bc">Object</a> end, <a class="el" href="structDictionary.html">Dictionary</a> opts, <a class="el" href="structError.html">Error</a> *err) FUNC_API_SINCE(7)</td></tr>
<tr class="separator:a2d3927ebe490dd9f46b55ced9b72685b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031aa59511e003b668b13d8debd1c616"><td class="memItemLeft" align="right" valign="top"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#a031aa59511e003b668b13d8debd1c616">nvim_buf_set_extmark</a> (Buffer buffer, <a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> ns_id, <a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> <a class="el" href="eval_8c.html#a3b6c24d86bb96f4d182ba6be35ecbcad">line</a>, <a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> <a class="el" href="normal_8c.html#a80db10ba8808399dd69164a092cf2920">col</a>, <a class="el" href="structDictionary.html">Dictionary</a> opts, <a class="el" href="structError.html">Error</a> *err) FUNC_API_SINCE(7)</td></tr>
<tr class="separator:a031aa59511e003b668b13d8debd1c616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacad9cf072c071a149d869b0eb9ec223"><td class="memItemLeft" align="right" valign="top"><a class="el" href="api_2private_2defs_8h.html#a3790b6de8c45ebee9af548380c3fb8d2">Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#aacad9cf072c071a149d869b0eb9ec223">nvim_buf_del_extmark</a> (Buffer buffer, <a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> ns_id, <a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> <a class="el" href="window_8c.html#acb190ae960c07e14f7973296b23f1eda">id</a>, <a class="el" href="structError.html">Error</a> *err) FUNC_API_SINCE(7)</td></tr>
<tr class="separator:aacad9cf072c071a149d869b0eb9ec223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be4d568bf934a95ca605fb8d503208a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#a7be4d568bf934a95ca605fb8d503208a">nvim_buf_add_highlight</a> (Buffer buffer, <a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> ns_id, <a class="el" href="structString.html">String</a> <a class="el" href="structhl__group.html">hl_group</a>, <a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> <a class="el" href="eval_8c.html#a3b6c24d86bb96f4d182ba6be35ecbcad">line</a>, <a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> col_start, <a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> col_end, <a class="el" href="structError.html">Error</a> *err) FUNC_API_SINCE(1)</td></tr>
<tr class="separator:a7be4d568bf934a95ca605fb8d503208a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de935e401c101ee02fdb845cfec06b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pty__conpty__win_8h.html#a690727517acf82fb8c93ad801e3ca4e3">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#a8de935e401c101ee02fdb845cfec06b7">nvim_buf_clear_namespace</a> (Buffer buffer, <a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> ns_id, <a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> line_start, <a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> line_end, <a class="el" href="structError.html">Error</a> *err) FUNC_API_SINCE(5)</td></tr>
<tr class="separator:a8de935e401c101ee02fdb845cfec06b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6996868ab00bbcc33054060202e7a2f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#a6996868ab00bbcc33054060202e7a2f2">nvim_buf_set_virtual_text</a> (Buffer buffer, <a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> src_id, <a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> <a class="el" href="eval_8c.html#a3b6c24d86bb96f4d182ba6be35ecbcad">line</a>, <a class="el" href="structArray.html">Array</a> chunks, <a class="el" href="structDictionary.html">Dictionary</a> opts, <a class="el" href="structError.html">Error</a> *err) FUNC_API_SINCE(5)</td></tr>
<tr class="separator:a6996868ab00bbcc33054060202e7a2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899b2738d3bee9471e65455bfa225fa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="api_2private_2defs_8h.html#ac1d573b78381906e7299e87cab9152bc">Object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#a899b2738d3bee9471e65455bfa225fa8">nvim_buf_call</a> (Buffer buffer, <a class="el" href="types_8h.html#a88fc3de9276c6cd5a57765fbb4005ee3">LuaRef</a> fun, <a class="el" href="structError.html">Error</a> *err) FUNC_API_LUA_ONLY</td></tr>
<tr class="separator:a899b2738d3bee9471e65455bfa225fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca60ce75b136eba19b9867b3295e9d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDictionary.html">Dictionary</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2buffer_8c.html#aaca60ce75b136eba19b9867b3295e9d7">nvim__buf_stats</a> (Buffer buffer, <a class="el" href="structError.html">Error</a> *err)</td></tr>
<tr class="separator:aaca60ce75b136eba19b9867b3295e9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="af35d58558d9fa1e2523451b662cd01ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35d58558d9fa1e2523451b662cd01ce">&#9670;&nbsp;</a></span>ArrayOf() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArrayOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDictionary.html">Dictionary</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a list of buffer-local |mapping| definitions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mode</td><td>Mode short-name ("n", "i", "v", ...) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td><a class="el" href="structError.html">Error</a> details, if any </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structArray.html">Array</a> of maparg()-like dictionaries describing mappings. The "buffer" key holds the associated buffer handle. </dd></dl>

</div>
</div>
<a id="ab2eaab20df89681b62d7b1d8eeac594a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2eaab20df89681b62d7b1d8eeac594a">&#9670;&nbsp;</a></span>ArrayOf() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArrayOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns position for a given extmark id</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ns_id</td><td>Namespace id from |nvim_create_namespace()| </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">id</td><td>Extmark id </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">opts</td><td>Optional parameters. Keys:<ul>
<li>details: Whether to include the details dict </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td><a class="el" href="structError.html">Error</a> details, if any </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(row, col) tuple or empty list () if extmark id was absent </dd></dl>

</div>
</div>
<a id="a2a0cecba9d1a9c6a0975001e304b4d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0cecba9d1a9c6a0975001e304b4d37">&#9670;&nbsp;</a></span>ArrayOf() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArrayOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">2&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a tuple (row,col) representing the position of the named mark.</p>
<p>Marks are (1,0)-indexed. |api-indexing|</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>Mark name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td><a class="el" href="structError.html">Error</a> details, if any </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(row, col) tuple</dd></dl>
<p>Gets the window position in display cells. First position is zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">window</td><td>Window handle, or 0 for current window </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td><a class="el" href="structError.html">Error</a> details, if any </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(row, col) tuple with the window position </dd></dl>

</div>
</div>
<a id="a910f20ac8647adbd7087107157eff91d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910f20ac8647adbd7087107157eff91d">&#9670;&nbsp;</a></span>ArrayOf() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArrayOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structString.html">String</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a line-range from the buffer.</p>
<p>Indexing is zero-based, end-exclusive. Negative indices are interpreted as length+1+index: -1 refers to the index past the end. So to get the last element use start=-2 and end=-1.</p>
<p>Out-of-bounds indices are clamped to the nearest valid value, unless <code>strict_indexing</code> is set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">channel_id</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">start</td><td>First line index </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">end</td><td>Last line index (exclusive) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">strict_indexing</td><td>Whether out-of-bounds should be an error. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td><a class="el" href="structError.html">Error</a> details, if any </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structArray.html">Array</a> of lines, or empty array for unloaded buffer.</dd></dl>
<p>Find files in runtime directories</p>
<p>'name' can contain wildcards. For example nvim_get_runtime_file("colors/*.vim", true) will return all color scheme files. Always use forward slashes (/) in the search pattern for subdirectories regardless of platform.</p>
<p>It is not an error to not find any files. An empty array is returned then.</p>
<p>To find a directory, <code>name</code> must end with a forward slash, like "rplugin/python/". Without the slash it would instead look for an ordinary file called "rplugin/python".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>pattern of files to search for </td></tr>
    <tr><td class="paramname">all</td><td>whether to return all matches or only the first </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of absolute paths to the found files </dd></dl>

</div>
</div>
<a id="a9ed217c5ca4d3be967b08e9fff37705c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed217c5ca4d3be967b08e9fff37705c">&#9670;&nbsp;</a></span>nvim__buf_redraw_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pty__conpty__win_8h.html#a690727517acf82fb8c93ad801e3ca4e3">void</a> nvim__buf_redraw_range </td>
          <td>(</td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaca60ce75b136eba19b9867b3295e9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaca60ce75b136eba19b9867b3295e9d7">&#9670;&nbsp;</a></span>nvim__buf_stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDictionary.html">Dictionary</a> nvim__buf_stats </td>
          <td>(</td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7be4d568bf934a95ca605fb8d503208a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be4d568bf934a95ca605fb8d503208a">&#9670;&nbsp;</a></span>nvim_buf_add_highlight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> nvim_buf_add_highlight </td>
          <td>(</td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td>
          <td class="paramname"><em>ns_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structString.html">String</a>&#160;</td>
          <td class="paramname"><em>hl_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td>
          <td class="paramname"><em>col_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td>
          <td class="paramname"><em>col_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a highlight to buffer.</p>
<p>Useful for plugins that dynamically generate highlights to a buffer (like a semantic highlighter or linter). The function adds a single highlight to a buffer. Unlike |matchaddpos()| highlights follow changes to line numbering (as lines are inserted/removed above the highlighted line), like signs and marks do.</p>
<p>Namespaces are used for batch deletion/updating of a set of highlights. To create a namespace, use |nvim_create_namespace()| which returns a namespace id. Pass it in to this function as <code>ns_id</code> to add highlights to the namespace. All highlights in the same namespace can then be cleared with single call to |nvim_buf_clear_namespace()|. If the highlight never will be deleted by an API call, pass <code>ns_id = -1</code>.</p>
<p>As a shorthand, <code>ns_id = 0</code> can be used to create a new namespace for the highlight, the allocated id is then returned. If <code><a class="el" href="structhl__group.html">hl_group</a></code> is the empty string no highlight is added, but a new <code>ns_id</code> is still returned. This is supported for backwards compatibility, new code should use |nvim_create_namespace()| to create a new empty namespace.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ns_id</td><td>namespace to use or -1 for ungrouped highlight </td></tr>
    <tr><td class="paramdir"></td><td class="paramname"><a class="el" href="structhl__group.html">hl_group</a></td><td>Name of the highlight group to use </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">line</td><td>Line to highlight (zero-indexed) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">col_start</td><td>Start of (byte-indexed) column range to highlight </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">col_end</td><td>End of (byte-indexed) column range to highlight, or -1 to highlight to end of line </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td><a class="el" href="structError.html">Error</a> details, if any </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ns_id that was used </dd></dl>

</div>
</div>
<a id="a51e0eaf29e0df4640ff77349368d6f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e0eaf29e0df4640ff77349368d6f87">&#9670;&nbsp;</a></span>nvim_buf_attach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="api_2private_2defs_8h.html#a3790b6de8c45ebee9af548380c3fb8d2">Boolean</a> nvim_buf_attach </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a3790b6de8c45ebee9af548380c3fb8d2">Boolean</a>&#160;</td>
          <td class="paramname"><em>send_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DictionaryOf(<a class="el" href="types_8h.html#a88fc3de9276c6cd5a57765fbb4005ee3">LuaRef</a>)&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Activates buffer-update events on a channel, or as Lua callbacks.</p>
<p>Example (Lua): capture buffer updates in a global <code>events</code> variable (use "print(vim.inspect(events))" to see its contents): </p><pre>
  events = {}
  vim.api.nvim_buf_attach(0, false, {
    on_lines=function(...) table.insert(events, {...}) end})
</pre><dl class="section see"><dt>See also</dt><dd>|nvim_buf_detach()| </dd>
<dd>
|api-buffer-updates-lua|</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">channel_id</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">send_buffer</td><td>True if the initial notification should contain the whole buffer: first notification will be <code>nvim_buf_lines_event</code>. Else the first notification will be <code>nvim_buf_changedtick_event</code>. Not for Lua callbacks. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">opts</td><td>Optional parameters.<ul>
<li>on_lines: Lua callback invoked on change. Return <code>true</code> to detach. Args:<ul>
<li>the string "lines"</li>
<li>buffer handle</li>
<li>b:changedtick</li>
<li>first line that changed (zero-indexed)</li>
<li>last line that was changed</li>
<li>last line in the updated range</li>
<li>byte count of previous contents</li>
<li>deleted_codepoints (if <code>utf_sizes</code> is true)</li>
<li>deleted_codeunits (if <code>utf_sizes</code> is true)</li>
</ul>
</li>
<li>on_bytes: lua callback invoked on change. This callback receives more granular information about the change compared to on_lines. Return <code>true</code> to detach. Args:<ul>
<li>the string "bytes"</li>
<li>buffer handle</li>
<li>b:changedtick</li>
<li>start row of the changed text (zero-indexed)</li>
<li>start column of the changed text</li>
<li>byte offset of the changed text (from the start of the buffer)</li>
<li>old end row of the changed text</li>
<li>old end column of the changed text</li>
<li>old end byte length of the changed text</li>
<li>new end row of the changed text</li>
<li>new end column of the changed text</li>
<li>new end byte length of the changed text</li>
</ul>
</li>
<li>on_changedtick: Lua callback invoked on changedtick increment without text change. Args:<ul>
<li>the string "changedtick"</li>
<li>buffer handle</li>
<li>b:changedtick</li>
</ul>
</li>
<li>on_detach: Lua callback invoked on detach. Args:<ul>
<li>the string "detach"</li>
<li>buffer handle</li>
</ul>
</li>
<li>on_reload: Lua callback invoked on reload. The entire buffer content should be considered changed. Args:<ul>
<li>the string "detach"</li>
<li>buffer handle</li>
</ul>
</li>
<li>utf_sizes: include UTF-32 and UTF-16 size of the replaced region, as args to <code>on_lines</code>.</li>
<li>preview: also attach to command preview (i.e. 'inccommand') events. </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td><a class="el" href="structError.html">Error</a> details, if any </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if attach failed (invalid parameter, or buffer isn't loaded); otherwise True. TODO: LUA_API_NO_EVAL </dd></dl>

</div>
</div>
<a id="a899b2738d3bee9471e65455bfa225fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a899b2738d3bee9471e65455bfa225fa8">&#9670;&nbsp;</a></span>nvim_buf_call()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="api_2private_2defs_8h.html#ac1d573b78381906e7299e87cab9152bc">Object</a> nvim_buf_call </td>
          <td>(</td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a88fc3de9276c6cd5a57765fbb4005ee3">LuaRef</a>&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>call a function with buffer as temporary current buffer</p>
<p>This temporarily switches current buffer to "buffer". If the current window already shows "buffer", the window is not switched If a window inside the current tabpage (including a float) already shows the buffer One of these windows will be set as current window temporarily. Otherwise a temporary scratch window (calleed the "autocmd window" for historical reasons) will be used.</p>
<p>This is useful e.g. to call vimL functions that only work with the current buffer/window currently, like |termopen()|.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fun</td><td>Function to call inside the buffer (currently lua callable only) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td><a class="el" href="structError.html">Error</a> details, if any </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return value of function. NB: will deepcopy lua values currently, use upvalues to send lua references in and out. </dd></dl>

</div>
</div>
<a id="a8de935e401c101ee02fdb845cfec06b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de935e401c101ee02fdb845cfec06b7">&#9670;&nbsp;</a></span>nvim_buf_clear_namespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pty__conpty__win_8h.html#a690727517acf82fb8c93ad801e3ca4e3">void</a> nvim_buf_clear_namespace </td>
          <td>(</td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td>
          <td class="paramname"><em>ns_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td>
          <td class="paramname"><em>line_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td>
          <td class="paramname"><em>line_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears namespaced objects (highlights, extmarks, virtual text) from a region.</p>
<p>Lines are 0-indexed. |api-indexing| To clear the namespace in the entire buffer, specify line_start=0 and line_end=-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ns_id</td><td>Namespace to clear, or -1 to clear all namespaces. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">line_start</td><td>Start of range of lines to clear </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">line_end</td><td>End of range of lines to clear (exclusive) or -1 to clear to end of buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td><a class="el" href="structError.html">Error</a> details, if any </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacad9cf072c071a149d869b0eb9ec223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacad9cf072c071a149d869b0eb9ec223">&#9670;&nbsp;</a></span>nvim_buf_del_extmark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="api_2private_2defs_8h.html#a3790b6de8c45ebee9af548380c3fb8d2">Boolean</a> nvim_buf_del_extmark </td>
          <td>(</td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td>
          <td class="paramname"><em>ns_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes an extmark.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ns_id</td><td>Namespace id from |nvim_create_namespace()| </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">id</td><td>Extmark id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td><a class="el" href="structError.html">Error</a> details, if any </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the extmark was found, else false </dd></dl>

</div>
</div>
<a id="a1331d52d36f62c542bc9645333fbc027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1331d52d36f62c542bc9645333fbc027">&#9670;&nbsp;</a></span>nvim_buf_del_keymap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pty__conpty__win_8h.html#a690727517acf82fb8c93ad801e3ca4e3">void</a> nvim_buf_del_keymap </td>
          <td>(</td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structString.html">String</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structString.html">String</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unmaps a buffer-local |mapping| for the given mode.</p>
<dl class="section see"><dt>See also</dt><dd>|nvim_del_keymap()|</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1590b78591312d66b333a102da8f3bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1590b78591312d66b333a102da8f3bc2">&#9670;&nbsp;</a></span>nvim_buf_del_var()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pty__conpty__win_8h.html#a690727517acf82fb8c93ad801e3ca4e3">void</a> nvim_buf_del_var </td>
          <td>(</td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structString.html">String</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a buffer-scoped (b:) variable</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>Variable name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td><a class="el" href="structError.html">Error</a> details, if any </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab675618bfabd9fafacc6f35d0b577e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab675618bfabd9fafacc6f35d0b577e89">&#9670;&nbsp;</a></span>nvim_buf_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pty__conpty__win_8h.html#a690727517acf82fb8c93ad801e3ca4e3">void</a> nvim_buf_delete </td>
          <td>(</td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDictionary.html">Dictionary</a>&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the buffer. See |:bwipeout|</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
    <tr><td class="paramname">opts</td><td>Optional parameters. Keys:<ul>
<li>force: Force deletion and ignore unsaved changes.</li>
<li>unload: Unloaded only, do not delete. See |:bunload| </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1ceaf3e2b47623c4ceb86733cced5a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ceaf3e2b47623c4ceb86733cced5a4">&#9670;&nbsp;</a></span>nvim_buf_detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="api_2private_2defs_8h.html#a3790b6de8c45ebee9af548380c3fb8d2">Boolean</a> nvim_buf_detach </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deactivates buffer-update events on the channel.</p>
<dl class="section see"><dt>See also</dt><dd>|nvim_buf_attach()| </dd>
<dd>
|api-lua-detach| <a class="el" href="search_8c.html#a8b9eb702eb3f9bcba3923532d1e801db">for</a> detaching Lua callbacks</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">channel_id</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td><a class="el" href="structError.html">Error</a> details, if any </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if detach failed (because the buffer isn't loaded); otherwise True. </dd></dl>

</div>
</div>
<a id="ae9acdcf1d8bc62642a275987ad1ae918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9acdcf1d8bc62642a275987ad1ae918">&#9670;&nbsp;</a></span>nvim_buf_get_changedtick()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> nvim_buf_get_changedtick </td>
          <td>(</td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a changed tick of a buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td><a class="el" href="structError.html">Error</a> details, if any</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>b:changedtick</code> value. </dd></dl>

</div>
</div>
<a id="a9bc81a63ea25885db52d5df236d25a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc81a63ea25885db52d5df236d25a15">&#9670;&nbsp;</a></span>nvim_buf_get_commands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDictionary.html">Dictionary</a> nvim_buf_get_commands </td>
          <td>(</td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDictionary.html">Dictionary</a>&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a map of buffer-local |user-commands|.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">opts</td><td>Optional parameters. Currently not used. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td><a class="el" href="structError.html">Error</a> details, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Map of maps describing commands. </dd></dl>

</div>
</div>
<a id="a2d3927ebe490dd9f46b55ced9b72685b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3927ebe490dd9f46b55ced9b72685b">&#9670;&nbsp;</a></span>nvim_buf_get_extmarks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structArray.html">Array</a> nvim_buf_get_extmarks </td>
          <td>(</td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td>
          <td class="paramname"><em>ns_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#ac1d573b78381906e7299e87cab9152bc">Object</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#ac1d573b78381906e7299e87cab9152bc">Object</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDictionary.html">Dictionary</a>&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets extmarks in "traversal order" from a |charwise| region defined by buffer positions (inclusive, 0-indexed |api-indexing|).</p>
<p>Region can be given as (row,col) tuples, or valid extmark ids (whose positions define the bounds). 0 and -1 are understood as (0,0) and (-1,-1) respectively, thus the following are equivalent:</p>
<pre>
  nvim_buf_get_extmarks(0, my_ns, 0, -1, {})
  nvim_buf_get_extmarks(0, my_ns, [0,0], [-1,-1], {})
</pre><p>If <code>end</code> is less than <code>start</code>, traversal works backwards. (Useful with <code>limit</code>, to get the first marks prior to a given position.)</p>
<p>Example:</p>
<pre>
  local a   = vim.api
  local pos = a.nvim_win_get_cursor(0)
  local ns  = a.nvim_create_namespace('my-plugin')
  -- Create new extmark at line 1, column 1.
  local m1  = a.nvim_buf_set_extmark(0, ns, 0, 0, 0, {})
  -- Create new extmark at line 3, column 1.
  local m2  = a.nvim_buf_set_extmark(0, ns, 0, 2, 0, {})
  -- Get extmarks only from line 3.
  local ms  = a.nvim_buf_get_extmarks(0, ns, {2,0}, {2,0}, {})
  -- Get all marks in this buffer + namespace.
  local all = a.nvim_buf_get_extmarks(0, ns, 0, -1, {})
  print(vim.inspect(ms))
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ns_id</td><td>Namespace id from |nvim_create_namespace()| </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">start</td><td>Start of range, given as (row, col) or valid extmark id (whose position defines the bound) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">end</td><td>End of range, given as (row, col) or valid extmark id (whose position defines the bound) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">opts</td><td>Optional parameters. Keys:<ul>
<li>limit: Maximum number of marks to return</li>
<li>details Whether to include the details dict </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td><a class="el" href="structError.html">Error</a> details, if any </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of [extmark_id, row, col] tuples in "traversal order". </dd></dl>

</div>
</div>
<a id="ac278a74b984d3b19bf925281c5d8bbd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac278a74b984d3b19bf925281c5d8bbd8">&#9670;&nbsp;</a></span>nvim_buf_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structString.html">String</a> nvim_buf_get_name </td>
          <td>(</td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the full file name for the buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td><a class="el" href="structError.html">Error</a> details, if any </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Buffer name </dd></dl>

</div>
</div>
<a id="a296934998d3a64a0902e93ae2a59ec36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296934998d3a64a0902e93ae2a59ec36">&#9670;&nbsp;</a></span>nvim_buf_get_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> nvim_buf_get_offset </td>
          <td>(</td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the byte offset of a line (0-indexed). |api-indexing|</p>
<p>Line 1 (index=0) has offset 0. UTF-8 bytes are counted. EOL is one byte. 'fileformat' and 'fileencoding' are ignored. The line index just after the last line gives the total byte-count of the buffer. A final EOL byte is counted if it would be written, see 'eol'.</p>
<p>Unlike |line2byte()|, throws error for out-of-bounds indexing. Returns -1 for unloaded buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">index</td><td>Line index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td><a class="el" href="structError.html">Error</a> details, if any </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer byte offset, or -1 for unloaded buffer. </dd></dl>

</div>
</div>
<a id="a1a6bd4918fa8c3a540ebb20b8fd4d03e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6bd4918fa8c3a540ebb20b8fd4d03e">&#9670;&nbsp;</a></span>nvim_buf_get_option()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="api_2private_2defs_8h.html#ac1d573b78381906e7299e87cab9152bc">Object</a> nvim_buf_get_option </td>
          <td>(</td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structString.html">String</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a buffer option value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>Option name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td><a class="el" href="structError.html">Error</a> details, if any </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Option value </dd></dl>

</div>
</div>
<a id="a48dd4d4b63b617cede33b38547870175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48dd4d4b63b617cede33b38547870175">&#9670;&nbsp;</a></span>nvim_buf_get_var()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="api_2private_2defs_8h.html#ac1d573b78381906e7299e87cab9152bc">Object</a> nvim_buf_get_var </td>
          <td>(</td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structString.html">String</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a buffer-scoped (b:) variable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>Variable name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td><a class="el" href="structError.html">Error</a> details, if any </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Variable value </dd></dl>

</div>
</div>
<a id="a12a80a71cd86e55ed4041ebbda9812a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a80a71cd86e55ed4041ebbda9812a4">&#9670;&nbsp;</a></span>nvim_buf_is_loaded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="api_2private_2defs_8h.html#a3790b6de8c45ebee9af548380c3fb8d2">Boolean</a> nvim_buf_is_loaded </td>
          <td>(</td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a buffer is valid and loaded. See |api-buffer| for more info about unloaded buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the buffer is valid and loaded, false otherwise. </dd></dl>

</div>
</div>
<a id="a9193c4fd297ff692d5b2364e80db1e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9193c4fd297ff692d5b2364e80db1e9e">&#9670;&nbsp;</a></span>nvim_buf_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="api_2private_2defs_8h.html#a3790b6de8c45ebee9af548380c3fb8d2">Boolean</a> nvim_buf_is_valid </td>
          <td>(</td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a buffer is valid.</p>
<dl class="section note"><dt>Note</dt><dd>Even if a buffer is valid it may have been unloaded. See |api-buffer| for more info about unloaded buffers.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the buffer is valid, false otherwise. </dd></dl>

</div>
</div>
<a id="a09e58ac4ac75dc5d6434a663ec91ca62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e58ac4ac75dc5d6434a663ec91ca62">&#9670;&nbsp;</a></span>nvim_buf_line_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> nvim_buf_line_count </td>
          <td>(</td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the buffer line count</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td><a class="el" href="structError.html">Error</a> details, if any </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Line count, or 0 for unloaded buffer. |api-buffer| </dd></dl>

</div>
</div>
<a id="a031aa59511e003b668b13d8debd1c616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031aa59511e003b668b13d8debd1c616">&#9670;&nbsp;</a></span>nvim_buf_set_extmark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> nvim_buf_set_extmark </td>
          <td>(</td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td>
          <td class="paramname"><em>ns_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDictionary.html">Dictionary</a>&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates or updates an extmark.</p>
<p>To create a new extmark, pass id=0. The extmark id will be returned. To move an existing mark, pass its id.</p>
<p>It is also allowed to create a new mark by passing in a previously unused id, but the caller must then keep track of existing and unused ids itself. (Useful over RPC, to avoid waiting for the return value.)</p>
<p>Using the optional arguments, it is possible to use this to highlight a range of text, and also to associate virtual text to the mark.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ns_id</td><td>Namespace id from |nvim_create_namespace()| </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">line</td><td>Line number where to place the mark </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">col</td><td>Column where to place the mark </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">opts</td><td>Optional parameters.<ul>
<li>id : id of the extmark to edit.</li>
<li>end_line : ending line of the mark, 0-based inclusive.</li>
<li>end_col : ending col of the mark, 0-based inclusive.</li>
<li><a class="el" href="structhl__group.html">hl_group</a> : name of the highlight group used to highlight this mark.</li>
<li>virt_text : virtual text to link to this mark.</li>
<li>virt_text_pos : positioning of virtual text. Possible values:<ul>
<li>"eol": right after eol character (default)</li>
<li>"overlay": display over the specified column, without shifting the underlying text.</li>
</ul>
</li>
<li>virt_text_hide : hide the virtual text when the background text is selected or hidden due to horizontal scroll 'nowrap'</li>
<li>hl_mode : control how highlights are combined with the highlights of the text. Currently only affects virt_text highlights, but might affect <code><a class="el" href="structhl__group.html">hl_group</a></code> in later versions.<ul>
<li>"replace": only show the virt_text color. This is the default</li>
<li>"combine": combine with background text color</li>
<li>"blend": blend with background text color.</li>
</ul>
</li>
<li>hl_eol : when true, for a multiline highlight covering the EOL of a line, continue the highlight for the rest of the screen line (just like for diff and cursorline highlight).</li>
<li>ephemeral : for use with |nvim_set_decoration_provider| callbacks. The mark will only be used for the current redraw cycle, and not be permantently stored in the buffer.</li>
<li>right_gravity : boolean that indicates the direction the extmark will be shifted in when new text is inserted (true for right, false for left). defaults to true.</li>
<li>end_right_gravity : boolean that indicates the direction the extmark end position (if it exists) will be shifted in when new text is inserted (true for right, false for left). Defaults to false.</li>
<li>priority: a priority value for the highlight group. For example treesitter highlighting uses a value of 100. </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td><a class="el" href="structError.html">Error</a> details, if any </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id of the created/updated extmark </dd></dl>

</div>
</div>
<a id="aa6d610ef8128347a35ee061de43ae2de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d610ef8128347a35ee061de43ae2de">&#9670;&nbsp;</a></span>nvim_buf_set_keymap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pty__conpty__win_8h.html#a690727517acf82fb8c93ad801e3ca4e3">void</a> nvim_buf_set_keymap </td>
          <td>(</td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structString.html">String</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structString.html">String</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structString.html">String</a>&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDictionary.html">Dictionary</a>&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a buffer-local |mapping| for the given mode.</p>
<dl class="section see"><dt>See also</dt><dd>|nvim_set_keymap()|</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa54f580408d8de25ec2bea97f2ef1a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54f580408d8de25ec2bea97f2ef1a37">&#9670;&nbsp;</a></span>nvim_buf_set_lines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pty__conpty__win_8h.html#a690727517acf82fb8c93ad801e3ca4e3">void</a> nvim_buf_set_lines </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a3790b6de8c45ebee9af548380c3fb8d2">Boolean</a>&#160;</td>
          <td class="paramname"><em>strict_indexing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2window_8c.html#a2a0cecba9d1a9c6a0975001e304b4d37">ArrayOf</a>(<a class="el" href="structString.html">String</a>)&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets (replaces) a line-range in the buffer.</p>
<p>Indexing is zero-based, end-exclusive. Negative indices are interpreted as length+1+index: -1 refers to the index past the end. So to change or delete the last element use start=-2 and end=-1.</p>
<p>To insert lines at a given index, set <code>start</code> and <code>end</code> to the same index. To delete a range of lines, set <code>replacement</code> to an empty array.</p>
<p>Out-of-bounds indices are clamped to the nearest valid value, unless <code>strict_indexing</code> is set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">channel_id</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">start</td><td>First line index </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">end</td><td>Last line index (exclusive) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">strict_indexing</td><td>Whether out-of-bounds should be an error. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">replacement</td><td><a class="el" href="structArray.html">Array</a> of lines to use as replacement </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td><a class="el" href="structError.html">Error</a> details, if any </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09e8755796885aa5e7555db96322d2d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e8755796885aa5e7555db96322d2d9">&#9670;&nbsp;</a></span>nvim_buf_set_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pty__conpty__win_8h.html#a690727517acf82fb8c93ad801e3ca4e3">void</a> nvim_buf_set_name </td>
          <td>(</td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structString.html">String</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the full file name for a buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>Buffer name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td><a class="el" href="structError.html">Error</a> details, if any </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0ebba3d00cf0c40379454c1a52e8b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ebba3d00cf0c40379454c1a52e8b08">&#9670;&nbsp;</a></span>nvim_buf_set_option()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pty__conpty__win_8h.html#a690727517acf82fb8c93ad801e3ca4e3">void</a> nvim_buf_set_option </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structString.html">String</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#ac1d573b78381906e7299e87cab9152bc">Object</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a buffer option value. Passing 'nil' as value deletes the option (only works if there's a global fallback)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">channel_id</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>Option name </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">value</td><td>Option value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td><a class="el" href="structError.html">Error</a> details, if any </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a005b99e1f0e31030a51785091af9e44d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005b99e1f0e31030a51785091af9e44d">&#9670;&nbsp;</a></span>nvim_buf_set_text()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pty__conpty__win_8h.html#a690727517acf82fb8c93ad801e3ca4e3">void</a> nvim_buf_set_text </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td>
          <td class="paramname"><em>start_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td>
          <td class="paramname"><em>start_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td>
          <td class="paramname"><em>end_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td>
          <td class="paramname"><em>end_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2window_8c.html#a2a0cecba9d1a9c6a0975001e304b4d37">ArrayOf</a>(<a class="el" href="structString.html">String</a>)&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets (replaces) a range in the buffer</p>
<p>This is recommended over nvim_buf_set_lines when only modifying parts of a line, as extmarks will be preserved on non-modified parts of the touched lines.</p>
<p>Indexing is zero-based and end-exclusive.</p>
<p>To insert text at a given index, set <code>start</code> and <code>end</code> ranges to the same index. To delete a range, set <code>replacement</code> to an array containing an empty string, or simply an empty array.</p>
<p>Prefer nvim_buf_set_lines when adding or deleting entire lines only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">channel_id</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">start_row</td><td>First line index </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">start_column</td><td>Last column </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">end_row</td><td>Last line index </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">end_column</td><td>Last column </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">replacement</td><td><a class="el" href="structArray.html">Array</a> of lines to use as replacement </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td><a class="el" href="structError.html">Error</a> details, if any </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f13a02500dd233dd0c4a314686d518d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f13a02500dd233dd0c4a314686d518d">&#9670;&nbsp;</a></span>nvim_buf_set_var()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pty__conpty__win_8h.html#a690727517acf82fb8c93ad801e3ca4e3">void</a> nvim_buf_set_var </td>
          <td>(</td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structString.html">String</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#ac1d573b78381906e7299e87cab9152bc">Object</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a buffer-scoped (b:) variable</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>Variable name </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">value</td><td>Variable value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td><a class="el" href="structError.html">Error</a> details, if any </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6996868ab00bbcc33054060202e7a2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6996868ab00bbcc33054060202e7a2f2">&#9670;&nbsp;</a></span>nvim_buf_set_virtual_text()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a> nvim_buf_set_virtual_text </td>
          <td>(</td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td>
          <td class="paramname"><em>src_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2private_2defs_8h.html#a23abc5a95167751b01dabc5eb2396241">Integer</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structArray.html">Array</a>&#160;</td>
          <td class="paramname"><em>chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDictionary.html">Dictionary</a>&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the virtual text (annotation) for a buffer line.</p>
<p>By default (and currently the only option) the text will be placed after the buffer text. Virtual text will never cause reflow, rather virtual text will be truncated at the end of the screen line. The virtual text will begin one cell (|lcs-eol| or space) after the ordinary text.</p>
<p>Namespaces are used to support batch deletion/updating of virtual text. To create a namespace, use |nvim_create_namespace()|. Virtual text is cleared using |nvim_buf_clear_namespace()|. The same <code>ns_id</code> can be used for both virtual text and highlights added by |nvim_buf_add_highlight()|, both can then be cleared with a single call to |nvim_buf_clear_namespace()|. If the virtual text never will be cleared by an API call, pass <code>ns_id = -1</code>.</p>
<p>As a shorthand, <code>ns_id = 0</code> can be used to create a new namespace for the virtual text, the allocated id is then returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer handle, or 0 for current buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ns_id</td><td>Namespace to use or 0 to create a namespace, or -1 for a ungrouped annotation </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">line</td><td>Line to annotate with virtual text (zero-indexed) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">chunks</td><td>A list of [text, <a class="el" href="structhl__group.html">hl_group</a>] arrays, each representing a text chunk with specified highlight. <code><a class="el" href="structhl__group.html">hl_group</a></code> element can be omitted for no highlight. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">opts</td><td>Optional parameters. Currently not used. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td><a class="el" href="structError.html">Error</a> details, if any </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ns_id that was used </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<footer>
  <div class="container">
    Generated on Fri Apr 30 2021 05:44:51 for Neovim by
    <a href="http://www.doxygen.org/index.html">Doxygen</a>
    1.8.17
  </div>
</footer>
</body>
</html>
