["src/nvim/buffer.c", ["", "  /*", "   * The 'readonly' flag is only set when BF_NEVERLOADED is being reset."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["   */", "  if (readonlymode && curbuf->b_ffname != NULL", "      && (curbuf->b_flags & BF_NEVERLOADED))"], "readability/braces"]
["src/nvim/buffer.c", ["  if (ml_open(curbuf) == FAIL) {", "    /*", "     * There MUST be a memfile, otherwise we can't do anything"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "    /*", "     * First read the text in binary mode into the buffer."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["    retval = readfile(NULL, NULL, (linenr_T)0,", "        (linenr_T)0, (linenr_T)MAXLNUM, NULL,", "        flags | (READ_NEW + READ_STDIN));"], "whitespace/alignment"]
["src/nvim/buffer.c", ["        (linenr_T)0, (linenr_T)MAXLNUM, NULL,", "        flags | (READ_NEW + READ_STDIN));", "    curbuf->b_p_bin = save_bin;"], "whitespace/alignment"]
["src/nvim/buffer.c", ["", "  /* Need to update automatic folding.  Do this before the autocommands,", "   * they may use the fold info. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /*", "   * The autocommands may have changed the current buffer.  Apply the"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["      wipe_buf = true;", "    } else if (buf->b_p_bh[0] == 'u')    // 'bufhidden' == \"unload\"", "      unload_buf = true;"], "readability/braces"]
["src/nvim/buffer.c", ["", "  /* Return when a window is displaying the buffer or when it's not", "   * unloaded. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /*", "   * Free all things allocated for this buffer."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["   */", "  /* Remember if we are closing the current buffer.  Restore the number of", "   * windows, so that autocommands in buf_freeall() don't get confused. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /*", "   * It's possible that autocommands change curbuf to the one being deleted."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /*", "   * Remove the buffer from the list."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /*", "   * It's possible that autocommands change curbuf to the one being deleted."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Free a buffer structure and the things it contains related to the buffer"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Free the b_wininfo list for buffer \"buf\"."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Go to another buffer.  Handles the result of the ATTENTION dialog."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "    /* Restore the error/interrupt/exception state if not discarded by a", "     * new aborting error, interrupt, or uncaught exception. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "    /* Restore the error/interrupt/exception state if not discarded by a", "     * new aborting error, interrupt, or uncaught exception. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "    /* Restore the error/interrupt/exception state if not discarded by a", "     * new aborting error, interrupt, or uncaught exception. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * do_bufdel() - delete or unload buffer(s)"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["    for (; !got_int; os_breakcheck()) {", "      /*", "       * delete the current buffer last, otherwise when the"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "      /*", "       * find next buffer number to delete/unload"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Make the current buffer empty."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["  retval = do_ecmd(0, NULL, NULL, NULL, ECMD_ONE,", "      forceit ? ECMD_FORCEIT : 0, curwin);", ""], "whitespace/alignment"]
["src/nvim/buffer.c", ["}", "/*", " * Implementation of the commands for the buffer list."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["    while (count > 0 || (!unload && !buf->b_p_bl && bp != buf)) {", "      /* remember the buffer where we start, we come back there when all", "       * buffers are unlisted. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /*", "   * delete buffer buf from memory and/or the list"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "    /* When unloading or deleting a buffer that's already unloaded and", "     * unlisted: fail silently. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "    /*", "     * If deleting the last (listed) buffer, make it empty."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "    /*", "     * If the deleted buffer is the current one, close the current window"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "    /*", "     * If the buffer to be deleted is not the current one, delete it here."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["  if (buf == NULL) {", "    /* Autocommands must have wiped out all other buffers.  Only option", "     * now is to make the current buffer empty. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /*", "   * make buf current buffer"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /*", "   * Check if the current buffer may be abandoned."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Set current buffer to \"buf\".  Executes autocommands and closes current"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["  }", "  /* An autocommand may have deleted \"buf\", already entered it (e.g., when", "   * it did \":bunload\") or aborted the script processing!"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["       && !aborting()", "       ) || curwin->w_buffer == NULL", "      ) {"], "whitespace/parens"]
["src/nvim/buffer.c", ["", "/*", " * Enter a new current buffer."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /* If autocommands did not change the cursor position, restore cursor lnum", "   * and possibly cursor col. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /*", "   * If file name already exists in the list, update the entry."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["   */", "  /* We can use inode numbers when the file exists.  Works better", "   * for hard links. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /*", "   * If the current buffer has no name and no contents, use the current"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["    buf = curbuf;", "    /* It's like this buffer is deleted.  Watch out for autocommands that", "     * change curbuf!  If that happens, allocate a new buffer anyway. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["  } else {", "    /*", "     * put new buffer at the end of the buffer list"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "    /*", "     * Always copy the options from the current buffer."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Free the memory for the options of a buffer."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["    col = fpos->col;", "  } else", "    col = 0;"], "readability/braces"]
["src/nvim/buffer.c", ["", "/*", " * Find file in buffer list by name (it has to be for the current window)."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["#endif", "      );", "  if (ffname != NULL) {"], "whitespace/alignment"]
["src/nvim/buffer.c", ["#endif", "      );", "  if (ffname != NULL) {"], "whitespace/parens"]
["src/nvim/buffer.c", ["", "/*", " * Find file in buffer list by name (it has to be for the current window)."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Same as buflist_findname(), but pass the FileID structure to avoid"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["            if (curtab_only) {", "              /* Ignore the match if the buffer is not open in", "               * the current tab. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "      /* Only search for unlisted buffers if there was no match with", "       * a listed buffer. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Find all buffer names that match."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["    STRCPY(patc + 11, pat + 1);", "  } else", "    patc = pat;"], "readability/braces"]
["src/nvim/buffer.c", ["", "  /*", "   * attempt == 0: try match with    '\\<', match at start of word"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "    /*", "     * round == 1: Count the matches."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Get name of file 'n' in the buffer list."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["  return home_replace_save(helptail ? buf : NULL,", "      fullname ? buf->b_ffname : buf->b_fname);", "}"], "whitespace/alignment"]
["src/nvim/buffer.c", ["", "/*", " * Reset the local window options to the values last used in this window."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["    cloneFoldGrowArray(&wip->wi_folds, &curwin->w_folds);", "  } else", "    copy_winopt(&curwin->w_allbuf_opt, &curwin->w_onebuf_opt);"], "readability/braces"]
["src/nvim/buffer.c", ["", "/*", " * Find the position (lnum and col) for the buffer 'buf' for the current"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Find the lnum for the buffer 'buf' for the current window."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Get file name and line number for file 'fnum'."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "    /*", "     * if the file name is already used in another buffer:"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Crude way of changing the name of a buffer.  Use with care!"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["    buf->b_sfname = NULL;", "    /* Allocate ffname and expand into full path.  Also resolves .lnk", "     * files on Win32. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Take care of what needs to be done when the name of buffer \"buf\" has"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["{", "  /*", "   * If the file name changed, also change the name of the swapfile"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * set alternate file name for current window"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Get alternate file name for current window."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Add a file name to the buflist and return its number."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["#if defined(BACKSLASH_IN_FILENAME)", "/*", " * Adjust slashes in file names.  Called after 'shellslash' was set."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Set alternate cursor position for the current buffer and window \"win\"."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Print info about the current buffer."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["    p = buffer + STRLEN(buffer);", "  } else", "    p = buffer;"], "readability/braces"]
["src/nvim/buffer.c", ["    vim_snprintf_add((char *)buffer, IOSIZE,", "        _(\"line %\" PRId64 \" of %\" PRId64 \" --%d%%-- col \"),", "        (int64_t)curwin->w_cursor.lnum,"], "whitespace/alignment"]
["src/nvim/buffer.c", ["        _(\"line %\" PRId64 \" of %\" PRId64 \" --%d%%-- col \"),", "        (int64_t)curwin->w_cursor.lnum,", "        (int64_t)curbuf->b_ml.ml_line_count,"], "whitespace/alignment"]
["src/nvim/buffer.c", ["        (int64_t)curwin->w_cursor.lnum,", "        (int64_t)curbuf->b_ml.ml_line_count,", "        n);"], "whitespace/alignment"]
["src/nvim/buffer.c", ["        (int64_t)curbuf->b_ml.ml_line_count,", "        n);", "    validate_virtcol();"], "whitespace/alignment"]
["src/nvim/buffer.c", ["    col_print(buffer + len, IOSIZE - len,", "        (int)curwin->w_cursor.col + 1, (int)curwin->w_virtcol + 1);", "  }"], "whitespace/alignment"]
["src/nvim/buffer.c", ["  if (dont_truncate) {", "    /* Temporarily set msg_scroll to avoid the message being truncated.", "     * First call msg_start() to get the message in the right place. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["    // or run out of room in our output buffer.", "    while (*fmt_p != NUL && *fmt_p != '%' && out_p < out_end_p)", "      *out_p++ = *fmt_p++;"], "readability/braces"]
["src/nvim/buffer.c", ["          min_group_width = 0 - min_group_width;", "          while (group_len++ < min_group_width && out_p < out_end_p)", "            *out_p++ = fillchar;"], "readability/braces"]
["src/nvim/buffer.c", ["      fmt_p++;", "      char *t = (char *) fmt_p;", "      while (*fmt_p != STL_CLICK_FUNC && *fmt_p) {"], "whitespace/cast"]
["src/nvim/buffer.c", ["      char_u *t = out_p;", "      while (*fmt_p != '}' && *fmt_p != NUL && out_p < out_end_p)", "        *out_p++ = *fmt_p++;"], "readability/braces"]
["src/nvim/buffer.c", ["      // Don't display %V if it's the same as %c.", "      if (opt == STL_VIRTCOL_ALT", "          && (virtcol == (colnr_T)(!(State & INSERT) && empty_line"], "readability/braces"]
["src/nvim/buffer.c", ["      itemisflag = true;", "      if (wp->w_buffer->b_help)", "        str = (char_u *)((opt == STL_HELPFLAG_ALT) ? \",HLP\""], "readability/braces"]
["src/nvim/buffer.c", ["      itemisflag = true;", "      if (wp->w_p_pvw)", "        str = (char_u *)((opt == STL_PREVIEWFLAG_ALT) ? \",PRV\""], "readability/braces"]
["src/nvim/buffer.c", ["    case STL_QUICKFIX:", "      if (bt_quickfix(wp->w_buffer))", "        str = (char_u *)(wp->w_llist_ref"], "readability/braces"]
["src/nvim/buffer.c", ["      if (itemisflag) {", "        if ((t[0] && t[1])", "            && ((!prevchar_isitem && *t == ',')"], "readability/braces"]
["src/nvim/buffer.c", ["        // digit follows.", "        if (fillable && out_p[-1] == ' '", "            && (!ascii_isdigit(*t) || fillchar != '-'))"], "readability/braces"]
["src/nvim/buffer.c", ["      long num_chars = 1;", "      for (long n = num; n >= (int) base; n /= (int) base) {", "        num_chars++;"], "whitespace/cast"]
["src/nvim/buffer.c", ["        vim_snprintf((char *)out_p, remaining_buf_len, (char *)nstr,", "            0, num, n);", "      } else {"], "whitespace/alignment"]
["src/nvim/buffer.c", ["        vim_snprintf((char *)out_p, remaining_buf_len, (char *)nstr,", "            minwid, num);", "      }"], "whitespace/alignment"]
["src/nvim/buffer.c", ["  return width;", "}", ""], "readability/fn_size"]
["src/nvim/buffer.c", ["", "/*", " * Get relative cursor position in window into \"buf[buflen]\", in the form 99%,"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Get the file name for an argument list entry."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * do_arg_all(): Open up to 'count' windows, one for each argument."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["  if (ARGCOUNT <= 0) {", "    /* Don't give an error message.  We don't want it when the \":all\"", "     * command is in the .vimrc. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /* Autocommands may do anything to the argument list.  Make sure it's not", "   * freed while we are working here by \"locking\" it.  We still have to"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /*", "   * Try closing all windows that are not in the argument list."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["            if (wp->w_alist != alist) {", "              /* Use the current argument list for all windows", "               * containing a file from it. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["            || !bufIsChanged(buf)) {", "          /* If the buffer was changed, and we would like to hide it,", "           * try autowriting. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /*", "   * Open a window for files in the argument list that don't have one."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "      /*", "       * edit file \"i\""], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Open a window for a number of buffers."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /*", "   * Close superfluous windows (two windows for the same buffer)."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "        /* Restore the error/interrupt/exception state if not", "         * discarded by a new aborting error, interrupt, or uncaught"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["        leave_cleanup(&cs);", "      } else", "        handle_swap_exists(NULL);"], "readability/braces"]
["src/nvim/buffer.c", ["", "  /*", "   * Close superfluous windows."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * do_modelines() - process mode lines for the current file"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /* Disallow recursive entry here.  Can happen when executing a modeline", "   * triggers an autocommand, which reloads modelines with a \":do\". */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * chk_modeline() - check a single line for a mode string"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["    if (prev == -1 || ascii_isspace(prev)) {", "      if ((prev != -1 && STRNCMP(s, \"ex:\", (size_t)3) == 0)", "          || STRNCMP(s, \"vi:\", (size_t)3) == 0)"], "readability/braces"]
["src/nvim/buffer.c", ["", "    /*", "     * Find end of set command: ':' or end of line."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "    /*", "     * If there is a \"set\" command, require a terminating ':' and"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Return special buffer name."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Set 'buflisted' for curbuf to \"on\" and trigger autocommands if it changed."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Wipe out a buffer and decrement the last buffer number if it was used for"], "readability/old_style_comment"]
