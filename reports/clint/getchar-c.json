["src/nvim/getchar.c", ["", "/*", " * getchar.c"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * These buffers are used for storing:"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * when block_redo is TRUE redo buffer will not be changed"], "readability/old_style_comment"]
["src/nvim/getchar.c", [" */", "static int block_redo = FALSE;", ""], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * List used for abbreviations."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Variables used by vgetorpeek() and flush_buffers()"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/* typebuf.tb_buf has three parts: room in front (for result of mappings), the", " * middle for typeahead and room for new characters (which needs to be 3 *"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Free and clear a buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Return the contents of a buffer as a single string."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Return the contents of the record buffer as a single string"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  p = get_buffcont(&recordbuff, TRUE);", "  free_buff(&recordbuff);"], "readability/bool"]
["src/nvim/getchar.c", ["", "  /*", "   * Remove the characters that were added the last time, these must be the"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * When stopping recording from Insert mode with CTRL-O q, also remove the"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   */", "  if (len > 0 && restart_edit != 0 && p[len - 1] == Ctrl_O)", "    p[len - 1] = NUL;"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Return the contents of the redo buffer as a single string."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["{", "  return get_buffcont(&redobuff, FALSE);", "}"], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * Add number \"n\" to buffer \"buf\"."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Add character 'c' to buffer \"buf\"."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Get one byte from the read buffers.  Use readbuf1 one first, use readbuf2"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  c = read_readbuf(&readbuf1, advance);", "  if (c == NUL)", "    c = read_readbuf(&readbuf2, advance);"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Prepare the read buffers for reading (if they contain something)."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Return TRUE if the stuff buffer is empty."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Return TRUE if readbuf1 is empty.  There may still be redo characters in"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Set a typeahead character that won't be flushed."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Remove the contents of the stuff buffer and the mapped characters in the"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  start_stuff();", "  while (read_readbuffers(TRUE) != NUL) {", "  }"], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * The previous contents of the redo buffer is kept in old_redobuffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Discard the contents of the redo buffer and restore the previous redo"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    start_stuff();", "    while (read_readbuffers(TRUE) != NUL) {", "    }"], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * Append \"s\" to the redo buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Append a character to the redo buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["{", "  if (!block_redo)", "    add_char_buff(&redobuff, c);"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Append a number to the redo buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["{", "  if (!block_redo)", "    add_num_buff(&redobuff, n);"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Append string \"s\" to the stuff buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Stuff \"s\" into the stuff buffer, leaving special key codes unmodified and"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Append a character to the stuff buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Append a number to the stuff buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Repeat the last insert (R, o, O, a, A, i or I command) by stuffing"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["{", "  block_redo = FALSE;", "}"], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * Initialize typebuf.tb_buf to point to typebuf_init."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  init_typebuf();", "  if (++typebuf.tb_change_cnt == 0)", "    typebuf.tb_change_cnt = 1;"], "readability/braces"]
["src/nvim/getchar.c", ["    memmove(s2 + newoff, typebuf.tb_noremap + typebuf.tb_off,", "        (size_t)offset);", "    memmove(s2 + newoff + offset + addlen,"], "whitespace/alignment"]
["src/nvim/getchar.c", ["    memmove(s2 + newoff + offset + addlen,", "        typebuf.tb_noremap + typebuf.tb_off + offset,", "        (size_t)(typebuf.tb_len - offset));"], "whitespace/alignment"]
["src/nvim/getchar.c", ["        typebuf.tb_noremap + typebuf.tb_off + offset,", "        (size_t)(typebuf.tb_len - offset));", "    if (typebuf.tb_noremap != noremapbuf_init)"], "whitespace/alignment"]
["src/nvim/getchar.c", ["        (size_t)(typebuf.tb_len - offset));", "    if (typebuf.tb_noremap != noremapbuf_init)", "      xfree(typebuf.tb_noremap);"], "readability/braces"]
["src/nvim/getchar.c", ["", "  /*", "   * Adjust typebuf.tb_noremap[] for the new characters:"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   */", "  if (noremap == REMAP_SKIP)", "    nrm = 1;"], "readability/braces"]
["src/nvim/getchar.c", ["    nrm = 1;", "  else if (noremap < 0)", "    nrm = addlen;"], "readability/braces"]
["src/nvim/getchar.c", ["    nrm = addlen;", "  else", "    nrm = noremap;"], "readability/braces"]
["src/nvim/getchar.c", ["    nrm = noremap;", "  for (i = 0; i < addlen; ++i)", "    typebuf.tb_noremap[typebuf.tb_off + i + offset] ="], "readability/braces"]
["src/nvim/getchar.c", ["    nrm = noremap;", "  for (i = 0; i < addlen; ++i)", "    typebuf.tb_noremap[typebuf.tb_off + i + offset] ="], "readability/increment"]
["src/nvim/getchar.c", ["", "  /* tb_maplen and tb_silent only remember the length of mapped and/or", "   * silent mappings at the start of the buffer, assuming that a mapped"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   * sequence doesn't result in typed characters. */", "  if (nottyped || typebuf.tb_maplen > offset)", "    typebuf.tb_maplen += addlen;"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Put character \"c\" back into the typeahead buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Return TRUE if the typeahead buffer was changed (while waiting for a"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["                                || typebuf_was_filled", "                                );", "}"], "whitespace/parens"]
["src/nvim/getchar.c", ["", "/*", " * Return TRUE if there are no characters in the typeahead buffer that have"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Return the number of characters that are mapped (or not typed)."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * remove \"len\" characters from typebuf.tb_buf[typebuf.tb_off + offset]"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * Easy case: Just increase typebuf.tb_off."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   */", "  if (offset == 0 && typebuf.tb_buflen - (typebuf.tb_off + len)", "      >= 3 * MAXMAPLEN + 3)"], "readability/braces"]
["src/nvim/getchar.c", ["    typebuf.tb_off += len;", "  /*", "   * Have to move the characters in typebuf.tb_buf[] and typebuf.tb_noremap[]"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   */", "  else {", "    i = typebuf.tb_off + offset;"], "readability/braces"]
["src/nvim/getchar.c", ["   */", "  else {", "    i = typebuf.tb_off + offset;"], "readability/braces"]
["src/nvim/getchar.c", ["    i = typebuf.tb_off + offset;", "    /*", "     * Leave some extra room at the end to avoid reallocation."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      memmove(typebuf.tb_buf + MAXMAPLEN,", "          typebuf.tb_buf + typebuf.tb_off, (size_t)offset);", "      memmove(typebuf.tb_noremap + MAXMAPLEN,"], "whitespace/alignment"]
["src/nvim/getchar.c", ["      memmove(typebuf.tb_noremap + MAXMAPLEN,", "          typebuf.tb_noremap + typebuf.tb_off, (size_t)offset);", "      typebuf.tb_off = MAXMAPLEN;"], "whitespace/alignment"]
["src/nvim/getchar.c", ["    memmove(typebuf.tb_noremap + typebuf.tb_off + offset,", "        typebuf.tb_noremap + i + len,", "        (size_t)(typebuf.tb_len - offset));"], "whitespace/alignment"]
["src/nvim/getchar.c", ["        typebuf.tb_noremap + i + len,", "        (size_t)(typebuf.tb_len - offset));", "  }"], "whitespace/alignment"]
["src/nvim/getchar.c", ["", "  /* Reset the flag that text received from a client or from feedkeys()", "   * was inserted in the typeahead buffer. */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Write typed characters to script file."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /* Since characters have been typed, consider the following to be in", "   * another mapping.  Search string will be kept in history. */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   * another mapping.  Search string will be kept in history. */", "  ++maptick;", "}"], "readability/increment"]
["src/nvim/getchar.c", ["", "/*", " * Sync undo.  Called when typed characters are obtained from the typeahead"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["{", "  if ((!(State & (INSERT + CMDLINE)) || arrow_used)", "      && scriptin[curscript] == NULL)"], "readability/braces"]
["src/nvim/getchar.c", ["      && scriptin[curscript] == NULL)", "    u_sync(FALSE);", "}"], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * Make \"typebuf\" empty and allocate new buffers."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  typebuf.tb_no_abbr_cnt = 0;", "  if (++typebuf.tb_change_cnt == 0)", "    typebuf.tb_change_cnt = 1;"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Free the buffers of \"typebuf\"."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * When doing \":so! file\", the current typeahead needs to be saved, and"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Save all three kinds of typeahead, so that the user must type at a prompt."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Restore the typeahead to what it was before calling save_typeahead()."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Open a new script file for the \":source!\" command."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * Execute the commands from the file right now when using \":source!\""], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Close the currently active input script."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  scriptin[curscript] = NULL;", "  if (curscript > 0)", "    --curscript;"], "readability/braces"]
["src/nvim/getchar.c", ["  if (curscript > 0)", "    --curscript;", "}"], "readability/increment"]
["src/nvim/getchar.c", ["{", "  while (scriptin[0] != NULL)", "    closescript();"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Return TRUE when reading keys from a script file."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Get the next input character."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * If a character was put back with vungetc, it was already processed."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["        c = TO_SPECIAL(c2, c);", "", "      }"], "whitespace/blank_line"]
["src/nvim/getchar.c", ["", "  /*", "   * In the main loop \"may_garbage_collect\" can be set to do garbage"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Like vgetc(), but never return a NUL when called recursively, get a key"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Like safe_vgetc(), but loop to handle K_IGNORE."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Check if a character is available, such that vgetc() will not block."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["{", "  if (old_char != -1)", "    return old_char;"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Check if any character is available, also half an escape sequence."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  c = vpeekc();", "  if (c == NUL && typebuf.tb_len > 0)", "    c = ESC;"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Call vpeekc() without causing anything to be mapped."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * This function doesn't work very well when called recursively.  This may"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   */", "  if (vgetc_busy > 0", "      && ex_normal_busy == 0"], "readability/braces"]
["src/nvim/getchar.c", ["", "  ++vgetc_busy;", ""], "readability/increment"]
["src/nvim/getchar.c", ["", "  if (advance)", "    KeyStuffed = FALSE;"], "readability/braces"]
["src/nvim/getchar.c", ["  if (advance)", "    KeyStuffed = FALSE;", ""], "readability/bool"]
["src/nvim/getchar.c", ["  do {", "    /*", "     * get a character: 1. from the stuffbuffer"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      c = typeahead_char;", "      if (advance)", "        typeahead_char = 0;"], "readability/braces"]
["src/nvim/getchar.c", ["    } else {", "      /*", "       * Loop until we either find a matching mapped key, or we"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      for (;; ) {", "        /*", "         * os_breakcheck() is slow, don't use it too often when"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["          if (advance) {", "            /* Also record this character, it might be needed to", "             * get out of Insert mode. */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["        } else if (typebuf.tb_len > 0) {", "          /*", "           * Check for a mappable key sequence."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["            }", "            /*", "             * Loop until a partly matching mapping is found or"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["                 (mp = mp->m_next)) {", "              /*", "               * Only consider an entry if the first character"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["                  c2 = typebuf.tb_buf[typebuf.tb_off + mlen];", "                  if (nomap > 0)", "                    --nomap;"], "readability/braces"]
["src/nvim/getchar.c", ["                  if (nomap > 0)", "                    --nomap;", "                  else if (c2 == K_SPECIAL)"], "readability/increment"]
["src/nvim/getchar.c", ["                    --nomap;", "                  else if (c2 == K_SPECIAL)", "                    nomap = 2;"], "readability/braces"]
["src/nvim/getchar.c", ["                    nomap = 2;", "                  else", "                    LANGMAP_ADJUST(c2, TRUE);"], "readability/braces"]
["src/nvim/getchar.c", ["                  else", "                    LANGMAP_ADJUST(c2, TRUE);", "                  if (mp->m_keys[mlen] != c2)"], "readability/bool"]
["src/nvim/getchar.c", ["                    LANGMAP_ADJUST(c2, TRUE);", "                  if (mp->m_keys[mlen] != c2)", "                    break;"], "readability/braces"]
["src/nvim/getchar.c", ["", "                /* Don't allow mapping the first byte(s) of a", "                 * multi-byte char.  Happens when mapping"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["                        && typebuf.tb_len < keylen)) {", "                  /*", "                   * If only script-local mappings are"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["                  s = typebuf.tb_noremap + typebuf.tb_off;", "                  if (*s == RM_SCRIPT", "                      && (mp->m_keys[0] != K_SPECIAL"], "readability/braces"]
["src/nvim/getchar.c", ["                    continue;", "                  /*", "                   * If one of the typed keys cannot be"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["                   */", "                  for (n = mlen; --n >= 0; )", "                    if (*s++ & (RM_NONE|RM_ABBR))"], "readability/braces"]
["src/nvim/getchar.c", ["                  for (n = mlen; --n >= 0; )", "                    if (*s++ & (RM_NONE|RM_ABBR))", "                      break;"], "readability/braces"]
["src/nvim/getchar.c", ["                      break;", "                  if (n >= 0)", "                    continue;"], "readability/braces"]
["src/nvim/getchar.c", ["", "            /* If no partly match found, use the longest full", "             * match. */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "            /*", "             * Put the replacement string in front of mapstr."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["              EMSG(_(\"E223: recursive mapping\"));", "              if (State & CMDLINE)", "                redrawcmdline();"], "readability/braces"]
["src/nvim/getchar.c", ["                redrawcmdline();", "              else", "                setcursor();"], "readability/braces"]
["src/nvim/getchar.c", ["", "            /*", "             * In Select mode and a Visual mode mapping is used:"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "            /* Copy the values from *mp that are used, because", "             * evaluating the expression may invoke a function"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "            /*", "             * Handle \":map <expr>\": evaluate the {rhs} as an"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "            /*", "             * Insert the 'to' part in the typebuf.tb_buf."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["             */", "            if (s == NULL)", "              i = FAIL;"], "readability/braces"]
["src/nvim/getchar.c", ["              i = FAIL;", "            else {", "              int noremap;"], "readability/braces"]
["src/nvim/getchar.c", ["              i = FAIL;", "            else {", "              int noremap;"], "readability/braces"]
["src/nvim/getchar.c", ["", "              if (save_m_noremap != REMAP_YES)", "                noremap = save_m_noremap;"], "readability/braces"]
["src/nvim/getchar.c", ["                noremap = save_m_noremap;", "              else if (", "                STRNCMP(s, save_m_keys != NULL"], "readability/braces"]
["src/nvim/getchar.c", ["              else if (", "                STRNCMP(s, save_m_keys != NULL", "                    ? save_m_keys : mp->m_keys,"], "whitespace/indent"]
["src/nvim/getchar.c", ["                STRNCMP(s, save_m_keys != NULL", "                    ? save_m_keys : mp->m_keys,", "                    (size_t)keylen)"], "whitespace/alignment"]
["src/nvim/getchar.c", ["                    ? save_m_keys : mp->m_keys,", "                    (size_t)keylen)", "                != 0)"], "whitespace/alignment"]
["src/nvim/getchar.c", ["                    (size_t)keylen)", "                != 0)", "                noremap = REMAP_YES;"], "whitespace/indent"]
["src/nvim/getchar.c", ["                STRNCMP(s, save_m_keys != NULL", "                    ? save_m_keys : mp->m_keys,", "                    (size_t)keylen)"], "whitespace/alignment"]
["src/nvim/getchar.c", ["                    ? save_m_keys : mp->m_keys,", "                    (size_t)keylen)", "                != 0)"], "whitespace/alignment"]
["src/nvim/getchar.c", ["                noremap = REMAP_YES;", "              else", "                noremap = REMAP_SKIP;"], "readability/braces"]
["src/nvim/getchar.c", ["              i = ins_typebuf(s, noremap,", "                  0, TRUE, cmd_silent || save_m_silent);", "              if (save_m_expr)"], "whitespace/alignment"]
["src/nvim/getchar.c", ["              i = ins_typebuf(s, noremap,", "                  0, TRUE, cmd_silent || save_m_silent);", "              if (save_m_expr)"], "readability/bool"]
["src/nvim/getchar.c", ["                  0, TRUE, cmd_silent || save_m_silent);", "              if (save_m_expr)", "                xfree(s);"], "readability/braces"]
["src/nvim/getchar.c", ["", "        /*", "         * get a character: 3. from the user - handle <Esc> in Insert mode"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["         */", "        /*", "         * special case: if we get an <ESC> in insert mode and there"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["              if (did_ai) {", "                /*", "                 * We are expecting to truncate the trailing"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["              } else {", "                --curwin->w_wcol;", "                col = curwin->w_cursor.col - 1;"], "readability/increment"]
["src/nvim/getchar.c", ["          }", "          /* When 'insertmode' is set, ESC just beeps in Insert", "           * mode.  Use CTRL-L to make edit() return."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["           * cmdline window. */", "          if (p_im && (State & INSERT))", "            c = Ctrl_L;"], "readability/braces"]
["src/nvim/getchar.c", ["            c = Ctrl_L;", "          else if ((State & CMDLINE)", "                   || (cmdwin_type > 0 && tc == ESC)"], "readability/braces"]
["src/nvim/getchar.c", ["            c = Ctrl_C;", "          else", "            c = ESC;"], "readability/braces"]
["src/nvim/getchar.c", ["", "        /*", "         * get a character: 3. from the user - update display"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["         */", "        /* In insert mode a screen update is skipped when characters", "         * are still available.  But when those available characters"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "        /*", "         * If we have a partial match (and are going to wait for more"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["            push_showcmd();", "            if (typebuf.tb_len > SHOWCMD_COLS)", "              i = typebuf.tb_len - SHOWCMD_COLS;"], "readability/braces"]
["src/nvim/getchar.c", ["              i = typebuf.tb_len - SHOWCMD_COLS;", "            while (i < typebuf.tb_len)", "              (void)add_to_showcmd(typebuf.tb_buf[typebuf.tb_off"], "readability/braces"]
["src/nvim/getchar.c", ["", "        /*", "         * get a character: 3. from the user - get it"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "        if (i != 0)", "          pop_showcmd();"], "readability/braces"]
["src/nvim/getchar.c", ["", "  /*", "   * The \"INSERT\" message is taken care of here:"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  --vgetc_busy;", ""], "readability/increment"]
["src/nvim/getchar.c", ["", "/*", " * inchar() - get one character from"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * Don't reset these when at the hit-return prompt, otherwise an endless"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  // Two characters are special: NUL and K_SPECIAL.", "  // Replace\t     NUL by K_SPECIAL KS_ZERO\t KE_FILLER", "  // Replace K_SPECIAL by K_SPECIAL KS_SPECIAL KE_FILLER"], "whitespace/tab"]
["src/nvim/getchar.c", ["", "/*", " * Delete one entry from the abbrlist or maphash[]."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Initialize maphash[] for first use."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    memset(maphash, 0, sizeof(maphash));", "    maphash_valid = TRUE;", "  }"], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * Get the mapping mode from the command name."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Clear all mappings or abbreviations."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  map_clear_int(curbuf, mode,", "      local,", "      abbr);"], "whitespace/alignment"]
["src/nvim/getchar.c", ["      local,", "      abbr);", "}"], "whitespace/alignment"]
["src/nvim/getchar.c", ["", "/*", " * Clear all mappings in \"mode\"."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  for (hash = 0; hash < 256; ++hash) {", "    if (abbr) {"], "readability/increment"]
["src/nvim/getchar.c", ["    } else {", "      if (local)", "        mpp = &buf->b_maphash[hash];"], "readability/braces"]
["src/nvim/getchar.c", ["        mpp = &buf->b_maphash[hash];", "      else", "        mpp = &maphash[hash];"], "readability/braces"]
["src/nvim/getchar.c", ["        }", "        /*", "         * May need to put this entry into another hash list."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  while (++len <= 3)", "    msg_putchar(' ');"], "readability/braces"]
["src/nvim/getchar.c", ["", "  if (local)", "    msg_putchar('@');"], "readability/braces"]
["src/nvim/getchar.c", ["    msg_putchar('@');", "  else", "    msg_putchar(' ');"], "readability/braces"]
["src/nvim/getchar.c", ["", "  /* Use FALSE below if we only want things like <Up> to show up as such on", "   * the rhs, and not M-x etc, TRUE gets both -- webb */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Used below when expanding mapping/abbreviation names."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Work out what to complete when doing command line completion of mapping"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["{", "  if (forceit && cmdidx != CMD_map && cmdidx != CMD_unmap)", "    xp->xp_context = EXPAND_NOTHING;"], "readability/braces"]
["src/nvim/getchar.c", ["    xp->xp_context = EXPAND_NOTHING;", "  else {", "    if (isunmap)"], "readability/braces"]
["src/nvim/getchar.c", ["    xp->xp_context = EXPAND_NOTHING;", "  else {", "    if (isunmap)"], "readability/braces"]
["src/nvim/getchar.c", ["  else {", "    if (isunmap)", "      expand_mapmodes = get_map_mode(&cmd, forceit || isabbrev);"], "readability/braces"]
["src/nvim/getchar.c", ["      expand_mapmodes = get_map_mode(&cmd, forceit || isabbrev);", "    else {", "      expand_mapmodes = INSERT + CMDLINE;"], "readability/braces"]
["src/nvim/getchar.c", ["      expand_mapmodes = get_map_mode(&cmd, forceit || isabbrev);", "    else {", "      expand_mapmodes = INSERT + CMDLINE;"], "readability/braces"]
["src/nvim/getchar.c", ["      expand_mapmodes = INSERT + CMDLINE;", "      if (!isabbrev)", "        expand_mapmodes += VISUAL + SELECTMODE + NORMAL + OP_PENDING;"], "readability/braces"]
["src/nvim/getchar.c", ["", "  /*", "   * round == 1: Count the matches."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   */", "  for (round = 1; round <= 2; ++round) {", "    count = 0;"], "readability/increment"]
["src/nvim/getchar.c", ["      if (vim_regexec(regmatch, p, (colnr_T)0)) {", "        if (round == 1)", "          ++count;"], "readability/braces"]
["src/nvim/getchar.c", ["        if (round == 1)", "          ++count;", "        else"], "readability/increment"]
["src/nvim/getchar.c", ["          ++count;", "        else", "          (*file)[count++] = vim_strsave(p);"], "readability/braces"]
["src/nvim/getchar.c", ["", "    for (hash = 0; hash < 256; ++hash) {", "      if (expand_isabbrev) {"], "readability/increment"]
["src/nvim/getchar.c", ["        mp = first_abbr;", "      } else if (expand_buffer)", "        mp = curbuf->b_maphash[hash];"], "readability/braces"]
["src/nvim/getchar.c", ["        mp = curbuf->b_maphash[hash];", "      else", "        mp = maphash[hash];"], "readability/braces"]
["src/nvim/getchar.c", ["          if (p != NULL && vim_regexec(regmatch, p, (colnr_T)0)) {", "            if (round == 1)", "              ++count;"], "readability/braces"]
["src/nvim/getchar.c", ["            if (round == 1)", "              ++count;", "            else {"], "readability/increment"]
["src/nvim/getchar.c", ["              ++count;", "            else {", "              (*file)[count++] = p;"], "readability/braces"]
["src/nvim/getchar.c", ["              ++count;", "            else {", "              (*file)[count++] = p;"], "readability/braces"]
["src/nvim/getchar.c", ["    while (ptr2 < ptr3) {", "      if (STRCMP(*ptr1, *ptr2))", "        *++ptr1 = *ptr2++;"], "readability/braces"]
["src/nvim/getchar.c", ["        *++ptr1 = *ptr2++;", "      else {", "        xfree(*ptr2++);"], "readability/braces"]
["src/nvim/getchar.c", ["        *++ptr1 = *ptr2++;", "      else {", "        xfree(*ptr2++);"], "readability/braces"]
["src/nvim/getchar.c", ["      }", "      ++clen;", "    }"], "readability/increment"]
["src/nvim/getchar.c", ["", "  if (scol < mincol)", "    scol = mincol;"], "readability/braces"]
["src/nvim/getchar.c", ["    if (mp != NULL) {", "      /*", "       * Found a match:"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      }", "      if (mp->m_expr)", "        s = eval_map_expr(mp->m_str, c);"], "readability/braces"]
["src/nvim/getchar.c", ["        s = eval_map_expr(mp->m_str, c);", "      else", "        s = mp->m_str;"], "readability/braces"]
["src/nvim/getchar.c", ["        typebuf.tb_no_abbr_cnt += (int)STRLEN(s) + j + 1;", "        if (mp->m_expr)", "          xfree(s);"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Evaluate the RHS of a mapping or abbreviations and take care of escaping"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["static char_u *", "eval_map_expr (", "    char_u *str,"], "whitespace/parens"]
["src/nvim/getchar.c", ["", "  /* Remove escaping of CSI, because \"str\" is in a format to be used as", "   * typeahead. */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  save_msg_row = msg_row;", "  p = eval_to_string(expr, NULL, FALSE);", "  --textlock;"], "readability/bool"]
["src/nvim/getchar.c", ["  p = eval_to_string(expr, NULL, FALSE);", "  --textlock;", "  --ex_normal_lock;"], "readability/increment"]
["src/nvim/getchar.c", ["  --textlock;", "  --ex_normal_lock;", "  curwin->w_cursor = save_cursor;"], "readability/increment"]
["src/nvim/getchar.c", ["", "  if (p == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Copy \"p\" to allocated memory, escaping K_SPECIAL and CSI so that the result"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Remove escaping from CSI and K_SPECIAL characters.  Reverse of"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      s += 3;", "    } else", "      *d++ = *s++;"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Write map commands for the current mappings to an .exrc file."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  if (*str == NUL && what == 1) {", "    if (fprintf(fd, \"<Nop>\") < 0)", "      return FAIL;"], "readability/braces"]
["src/nvim/getchar.c", ["    if (p != NULL) {", "      while (*p != NUL)", "        if (fputc(*p++, fd) < 0)"], "readability/braces"]
["src/nvim/getchar.c", ["      while (*p != NUL)", "        if (fputc(*p++, fd) < 0)", "          return FAIL;"], "readability/braces"]
["src/nvim/getchar.c", ["          return FAIL;", "      --str;", "      continue;"], "readability/increment"]
["src/nvim/getchar.c", ["    c = *str;", "    /*", "     * Special key codes have to be translated to be able to make sense"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "    /*", "     * A '\\n' in a map command should be written as <NL>."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      if (what == 2) {", "        if (fprintf(fd, \"\\\\\\026\\n\") < 0)", "          return FAIL;"], "readability/braces"]
["src/nvim/getchar.c", ["      } else {", "        if (fprintf(fd, \"<NL>\") < 0)", "          return FAIL;"], "readability/braces"]
["src/nvim/getchar.c", ["", "    /*", "     * Some characters have to be escaped with CTRL-V to"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    if (what == 2 && (ascii_iswhite(c) || c == '\"' || c == '\\\\')) {", "      if (putc('\\\\', fd) < 0)", "        return FAIL;"], "readability/braces"]
["src/nvim/getchar.c", ["               || (what != 2 && c == '<')) {", "      if (putc(Ctrl_V, fd) < 0)", "        return FAIL;"], "readability/braces"]
["src/nvim/getchar.c", ["    }", "    if (putc(c, fd) < 0)", "      return FAIL;"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Check the string \"keys\" against the lhs of all mappings."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["char_u *", "check_map (", "    char_u *keys,"], "whitespace/parens"]
["src/nvim/getchar.c", ["      for (; mp != NULL; mp = mp->m_next) {", "        /* skip entries with wrong mode, wrong length and not matching", "         * ones */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["          if (STRNCMP(s, keys, minlen) == 0) {", "            if (mp_ptr != NULL)", "              *mp_ptr = mp;"], "readability/braces"]
["src/nvim/getchar.c", ["              *mp_ptr = mp;", "            if (local_ptr != NULL)", "              *local_ptr = local;"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Add a mapping \"map\" for mode \"mode\"."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  s = vim_strsave(map);", "  (void)do_map(0, s, mode, FALSE);", "  xfree(s);"], "readability/bool"]
["src/nvim/getchar.c", ["// Returns NULL when there is a problem.", "static char_u * translate_mapping (", "    char_u *str,"], "whitespace/parens"]
["src/nvim/getchar.c", ["", "  for (; *str; ++str) {", "    int c = *str;"], "readability/increment"]
["src/nvim/getchar.c", ["  for (i = 0; i < typebuf.tb_len && str[i]; i++) {", "    if (str[i] != typebuf.tb_buf[typebuf.tb_off + i])", "      break;"], "readability/braces"]
