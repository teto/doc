["src/nvim/if_cscope.c", ["", "/*", " * CSCOPE support for Vim added by Andy Kahn <kahn@zk3.dec.com>"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["", "#include <sys/types.h>", "#include <sys/stat.h>"], "build/include_order"]
["src/nvim/if_cscope.c", ["#include <sys/types.h>", "#include <sys/stat.h>", "#if defined(UNIX)"], "build/include_order"]
["src/nvim/if_cscope.c", ["#if defined(UNIX)", "# include <sys/wait.h>", "#endif"], "build/include_order"]
["src/nvim/if_cscope.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the cscope command"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["    int i;", "    for (i = 0, current_idx = 0; cs_cmds[i].name != NULL; i++)", "      if (cs_cmds[i].cansplit)"], "readability/braces"]
["src/nvim/if_cscope.c", ["    for (i = 0, current_idx = 0; cs_cmds[i].name != NULL; i++)", "      if (cs_cmds[i].cansplit)", "        if (current_idx++ == idx)"], "readability/braces"]
["src/nvim/if_cscope.c", ["      if (cs_cmds[i].cansplit)", "        if (current_idx++ == idx)", "          break;"], "readability/braces"]
["src/nvim/if_cscope.c", ["    const char *query_type[] =", "    {", "      \"a\", \"c\", \"d\", \"e\", \"f\", \"g\", \"i\", \"s\", \"t\", NULL"], "whitespace/braces"]
["src/nvim/if_cscope.c", ["    for (i = 0, current_idx = 0; i < csinfo_size; i++) {", "      if (csinfo[i].fname == NULL)", "        continue;"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "/*", " * Handle command line completion for :cscope command."], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["      (void)MSG_PUTS(_(", "              \"This cscope command does not support splitting the window.\\n\"));", "      return;"], "whitespace/indent"]
["src/nvim/if_cscope.c", ["{", "  do_cscope_general(eap, FALSE);", "}"], "readability/bool"]
["src/nvim/if_cscope.c", ["{", "  do_cscope_general(eap, TRUE);", "}"], "readability/bool"]
["src/nvim/if_cscope.c", ["{", "  int ret = FALSE;", ""], "readability/bool"]
["src/nvim/if_cscope.c", ["      ret = cs_find_common(\"g\", (char *)(eap->arg), eap->forceit, FALSE,", "          FALSE, *eap->cmdlinep);", "      if (ret == FALSE) {"], "whitespace/alignment"]
["src/nvim/if_cscope.c", ["    if (cs_check_for_connections()) {", "      ret = cs_find_common(\"g\", (char *)(eap->arg), eap->forceit, FALSE,", "          FALSE, *eap->cmdlinep);"], "readability/bool"]
["src/nvim/if_cscope.c", ["      ret = cs_find_common(\"g\", (char *)(eap->arg), eap->forceit, FALSE,", "          FALSE, *eap->cmdlinep);", "      if (ret == FALSE) {"], "readability/bool"]
["src/nvim/if_cscope.c", ["          FALSE, *eap->cmdlinep);", "      if (ret == FALSE) {", "        cs_free_tags();"], "readability/bool"]
["src/nvim/if_cscope.c", ["        cs_free_tags();", "        if (msg_col)", "          msg_putchar('\\n');"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "        if (cs_check_for_tags())", "          ret = do_tag(eap->arg, DT_JUMP, 0, eap->forceit, FALSE);"], "readability/braces"]
["src/nvim/if_cscope.c", ["        if (cs_check_for_tags())", "          ret = do_tag(eap->arg, DT_JUMP, 0, eap->forceit, FALSE);", "      }"], "readability/bool"]
["src/nvim/if_cscope.c", ["    } else if (cs_check_for_tags()) {", "      ret = do_tag(eap->arg, DT_JUMP, 0, eap->forceit, FALSE);", "    }"], "readability/bool"]
["src/nvim/if_cscope.c", ["    if (cs_check_for_tags()) {", "      ret = do_tag(eap->arg, DT_JUMP, 0, eap->forceit, FALSE);", "      if (ret == FALSE) {"], "readability/bool"]
["src/nvim/if_cscope.c", ["      ret = do_tag(eap->arg, DT_JUMP, 0, eap->forceit, FALSE);", "      if (ret == FALSE) {", "        if (msg_col)"], "readability/bool"]
["src/nvim/if_cscope.c", ["      if (ret == FALSE) {", "        if (msg_col)", "          msg_putchar('\\n');"], "readability/braces"]
["src/nvim/if_cscope.c", ["          ret = cs_find_common(\"g\", (char *)(eap->arg), eap->forceit,", "              FALSE, FALSE, *eap->cmdlinep);", "          if (ret == FALSE)"], "whitespace/alignment"]
["src/nvim/if_cscope.c", ["          ret = cs_find_common(\"g\", (char *)(eap->arg), eap->forceit,", "              FALSE, FALSE, *eap->cmdlinep);", "          if (ret == FALSE)"], "readability/bool"]
["src/nvim/if_cscope.c", ["              FALSE, FALSE, *eap->cmdlinep);", "          if (ret == FALSE)", "            cs_free_tags();"], "readability/braces"]
["src/nvim/if_cscope.c", ["              FALSE, FALSE, *eap->cmdlinep);", "          if (ret == FALSE)", "            cs_free_tags();"], "readability/bool"]
["src/nvim/if_cscope.c", ["      ret = cs_find_common(\"g\", (char *)(eap->arg), eap->forceit, FALSE,", "          FALSE, *eap->cmdlinep);", "      if (ret == FALSE)"], "whitespace/alignment"]
["src/nvim/if_cscope.c", ["    } else if (cs_check_for_connections()) {", "      ret = cs_find_common(\"g\", (char *)(eap->arg), eap->forceit, FALSE,", "          FALSE, *eap->cmdlinep);"], "readability/bool"]
["src/nvim/if_cscope.c", ["      ret = cs_find_common(\"g\", (char *)(eap->arg), eap->forceit, FALSE,", "          FALSE, *eap->cmdlinep);", "      if (ret == FALSE)"], "readability/bool"]
["src/nvim/if_cscope.c", ["          FALSE, *eap->cmdlinep);", "      if (ret == FALSE)", "        cs_free_tags();"], "readability/braces"]
["src/nvim/if_cscope.c", ["          FALSE, *eap->cmdlinep);", "      if (ret == FALSE)", "        cs_free_tags();"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "/*", " * \"cscope_connection([{num} , {dbpath} [, {prepend}]])\" function"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["", "/*", " * PRIVATE functions"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["", "  if ((fname = strtok((char *)NULL, (const char *)\" \")) == NULL) {", "    cs_usage_msg(Add);"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["  }", "  if ((ppath = strtok((char *)NULL, (const char *)\" \")) != NULL)", "    flags = strtok((char *)NULL, (const char *)\" \");"], "readability/braces"]
["src/nvim/if_cscope.c", ["  }", "  if ((ppath = strtok((char *)NULL, (const char *)\" \")) != NULL)", "    flags = strtok((char *)NULL, (const char *)\" \");"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["  if ((ppath = strtok((char *)NULL, (const char *)\" \")) != NULL)", "    flags = strtok((char *)NULL, (const char *)\" \");", ""], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["", "  (void)sprintf(buf, stat_emsg, fname, errno);", "  (void)EMSG(buf);"], "runtime/printf"]
["src/nvim/if_cscope.c", ["staterr:", "    if (p_csverbose)", "      cs_stat_emsg(fname);"], "readability/braces"]
["src/nvim/if_cscope.c", ["      fname[strlen(fname)-1] = '\\0';", "      if (fname[0] == '\\0')", "        break;"], "readability/braces"]
["src/nvim/if_cscope.c", ["    }", "    if (fname[0] == '\\0')", "      (void)sprintf(fname2, \"/%s\", CSCOPE_DBFILE);"], "readability/braces"]
["src/nvim/if_cscope.c", ["    if (fname[0] == '\\0')", "      (void)sprintf(fname2, \"/%s\", CSCOPE_DBFILE);", "    else"], "runtime/printf"]
["src/nvim/if_cscope.c", ["      (void)sprintf(fname2, \"/%s\", CSCOPE_DBFILE);", "    else", "      (void)sprintf(fname2, \"%s/%s\", fname, CSCOPE_DBFILE);"], "readability/braces"]
["src/nvim/if_cscope.c", ["    else", "      (void)sprintf(fname2, \"%s/%s\", fname, CSCOPE_DBFILE);", ""], "runtime/printf"]
["src/nvim/if_cscope.c", ["    if (!file_info_ok) {", "      if (p_csverbose)", "        cs_stat_emsg(fname2);"], "readability/braces"]
["src/nvim/if_cscope.c", ["  }", "  else if (S_ISREG(file_info.stat.st_mode) || S_ISLNK(file_info.stat.st_mode))", "  {"], "whitespace/newline"]
["src/nvim/if_cscope.c", ["  else if (S_ISREG(file_info.stat.st_mode) || S_ISLNK(file_info.stat.st_mode))", "  {", "    i = cs_insert_filelist(fname, ppath, flags, &file_info);"], "whitespace/braces"]
["src/nvim/if_cscope.c", ["  } else {", "    if (p_csverbose)", "      (void)EMSG2("], "readability/braces"]
["src/nvim/if_cscope.c", ["  for (size_t i = 0; i < csinfo_size; i++) {", "    if (csinfo[i].fname != NULL)", "      cnt++;"], "readability/braces"]
["src/nvim/if_cscope.c", ["    }", "    if ((stok = strtok(buf, (const char *)\" \")) == NULL) {", "      continue;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["", "    if ((stok = strtok(NULL, (const char *)\" \")) == NULL)", "      continue;"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "    if ((stok = strtok(NULL, (const char *)\" \")) == NULL)", "      continue;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["", "    if ((stok = strtok(NULL, (const char *)\" \")) == NULL)", "      continue;"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "    if ((stok = strtok(NULL, (const char *)\" \")) == NULL)", "      continue;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["      continue;", "    if (strncmp((const char *)stok, \"lines\", 5))", "      continue;"], "readability/braces"]
["src/nvim/if_cscope.c", ["  char *cmd;", "  short search;", "  char *pat;"], "runtime/int"]
["src/nvim/if_cscope.c", ["  pat = pattern;", "  if (search != 4 && search != 6)", "    while (ascii_iswhite(*pat))"], "readability/braces"]
["src/nvim/if_cscope.c", ["  if (search != 4 && search != 6)", "    while (ascii_iswhite(*pat))", "      ++pat;"], "readability/braces"]
["src/nvim/if_cscope.c", ["    while (ascii_iswhite(*pat))", "      ++pat;", ""], "readability/increment"]
["src/nvim/if_cscope.c", ["", "  (void)sprintf(cmd, \"%d%s\", search, pat);", ""], "runtime/printf"]
["src/nvim/if_cscope.c", ["#if defined(UNIX)", "  /*", "   * Cscope reads from to_cs[0] and writes to from_cs[1]; vi reads from"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["err_closing:", "    if (to_cs[0] != -1)", "      (void)close(to_cs[0]);"], "readability/braces"]
["src/nvim/if_cscope.c", ["      (void)close(to_cs[0]);", "    if (to_cs[1] != -1)", "      (void)close(to_cs[1]);"], "readability/braces"]
["src/nvim/if_cscope.c", ["      (void)close(to_cs[1]);", "    if (from_cs[0] != -1)", "      (void)close(from_cs[0]);"], "readability/braces"]
["src/nvim/if_cscope.c", ["      (void)close(from_cs[0]);", "    if (from_cs[1] != -1)", "      (void)close(from_cs[1]);"], "readability/braces"]
["src/nvim/if_cscope.c", ["  sa.nLength = sizeof(SECURITY_ATTRIBUTES);", "  sa.bInheritHandle = TRUE;", "  sa.lpSecurityDescriptor = NULL;"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "    if (csinfo[i].flags)", "      len += strlen(csinfo[i].flags);"], "readability/braces"]
["src/nvim/if_cscope.c", ["    if (csinfo[i].ppath != NULL) {", "      (void)strcat(cmd, \" -P\");", "      (void)strcat(cmd, csinfo[i].ppath);"], "runtime/printf"]
["src/nvim/if_cscope.c", ["      (void)strcat(cmd, \" -P\");", "      (void)strcat(cmd, csinfo[i].ppath);", "    }"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    if (csinfo[i].flags != NULL) {", "      (void)strcat(cmd, \" \");", "      (void)strcat(cmd, csinfo[i].flags);"], "runtime/printf"]
["src/nvim/if_cscope.c", ["      (void)strcat(cmd, \" \");", "      (void)strcat(cmd, csinfo[i].flags);", "    }"], "runtime/printf"]
["src/nvim/if_cscope.c", ["#  else", "    if (setpgid(0, 0) == -1)", "      PERROR(_(\"cs_create_connection setpgid failed\"));"], "readability/braces"]
["src/nvim/if_cscope.c", ["# endif", "    if (execl(\"/bin/sh\", \"sh\", \"-c\", cmd, (char *)NULL) == -1)", "      PERROR(_(\"cs_create_connection exec failed\"));"], "readability/braces"]
["src/nvim/if_cscope.c", ["    created = CreateProcess(NULL, cmd, NULL, NULL, TRUE, CREATE_NEW_CONSOLE,", "        NULL, NULL, &si, &pi);", "    xfree(prog);"], "whitespace/alignment"]
["src/nvim/if_cscope.c", ["    si.hStdInput  = stdin_rd;", "    created = CreateProcess(NULL, cmd, NULL, NULL, TRUE, CREATE_NEW_CONSOLE,", "        NULL, NULL, &si, &pi);"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "  if (cs_check_for_connections() == FALSE) {", "    (void)EMSG(_(\"E567: no cscope connections\"));"], "readability/bool"]
["src/nvim/if_cscope.c", ["    (void)EMSG(_(\"E567: no cscope connections\"));", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "  if ((opt = strtok((char *)NULL, (const char *)\" \")) == NULL) {", "    cs_usage_msg(Find);"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["    cs_usage_msg(Find);", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/if_cscope.c", ["    cs_usage_msg(Find);", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "  /*", "   * Let's replace the NULs written by strtok() with spaces - we need the"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["   */", "  for (int i = 0; i < eap_arg_len; ++i)", "    if (NUL == eap->arg[i])"], "readability/braces"]
["src/nvim/if_cscope.c", ["   */", "  for (int i = 0; i < eap_arg_len; ++i)", "    if (NUL == eap->arg[i])"], "readability/increment"]
["src/nvim/if_cscope.c", ["  for (int i = 0; i < eap_arg_len; ++i)", "    if (NUL == eap->arg[i])", "      eap->arg[i] = ' ';"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "      sprintf(buf, nf, *qfpos, *(qfpos-1));", "      (void)EMSG(buf);"], "runtime/printf"]
["src/nvim/if_cscope.c", ["      xfree(buf);", "      return FALSE;", "    }"], "readability/bool"]
["src/nvim/if_cscope.c", ["  cmd = cs_create_cmd(opt, pat);", "  if (cmd == NULL)", "    return FALSE;"], "readability/braces"]
["src/nvim/if_cscope.c", ["  if (cmd == NULL)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/if_cscope.c", ["  for (size_t i = 0; i < csinfo_size; i++) {", "    if (csinfo[i].fname == NULL || csinfo[i].to_fp == NULL)", "      continue;"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "    if (nummatches[i] > -1)", "      totmatches += (size_t)nummatches[i];"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "    if (nummatches[i] == 0)", "      (void)cs_read_prompt(i);"], "readability/braces"]
["src/nvim/if_cscope.c", ["      xfree(nummatches);", "      return FALSE;", "    }"], "readability/bool"]
["src/nvim/if_cscope.c", ["    buf = xmalloc(strlen(opt) + strlen(pat) + strlen(nf));", "    sprintf(buf, nf, opt, pat);", "    (void)EMSG(buf);"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    xfree(nummatches);", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/if_cscope.c", ["        apply_autocmds(EVENT_QUICKFIXCMDPOST, (char_u *)\"cscope\",", "            curbuf->b_fname, TRUE, curbuf);", "        if (use_ll)"], "whitespace/alignment"]
["src/nvim/if_cscope.c", ["        apply_autocmds(EVENT_QUICKFIXCMDPOST, (char_u *)\"cscope\",", "            curbuf->b_fname, TRUE, curbuf);", "        if (use_ll)"], "readability/bool"]
["src/nvim/if_cscope.c", ["            curbuf->b_fname, TRUE, curbuf);", "        if (use_ll)", "          /*"], "readability/braces"]
["src/nvim/if_cscope.c", ["        if (use_ll)", "          /*", "           * In the location list window, use the displayed location"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["    xfree(nummatches);", "    return TRUE;", "  } else {"], "readability/bool"]
["src/nvim/if_cscope.c", ["    cs_fill_results((char *)pat, totmatches, nummatches, &matches,", "        &contexts, &matched);", "    xfree(nummatches);"], "whitespace/alignment"]
["src/nvim/if_cscope.c", ["    xfree(nummatches);", "    if (matches == NULL)", "      return FALSE;"], "readability/braces"]
["src/nvim/if_cscope.c", ["    if (matches == NULL)", "      return FALSE;", ""], "readability/bool"]
["src/nvim/if_cscope.c", ["    (void)smsg(_(\"%-5s: %s%*s (Usage: %s)\"),", "        cmdp->name,", "        help, space_cnt, \" \","], "whitespace/alignment"]
["src/nvim/if_cscope.c", ["        cmdp->name,", "        help, space_cnt, \" \",", "        cmdp->usage);"], "whitespace/alignment"]
["src/nvim/if_cscope.c", ["        help, space_cnt, \" \",", "        cmdp->usage);", "    if (strcmp(cmdp->name, \"find\") == 0)"], "whitespace/alignment"]
["src/nvim/if_cscope.c", ["        cmdp->usage);", "    if (strcmp(cmdp->name, \"find\") == 0)", "      MSG_PUTS(_(\"\\n\""], "readability/braces"]
["src/nvim/if_cscope.c", ["", "  wait_return(TRUE);", "  return CSCOPE_SUCCESS;"], "readability/bool"]
["src/nvim/if_cscope.c", ["        && os_fileid_equal_fileinfo(&(csinfo[j].file_id), file_info)) {", "      if (p_csverbose)", "        (void)EMSG(_(\"E568: duplicate cscope database not added\"));"], "readability/braces"]
["src/nvim/if_cscope.c", ["      csinfo_size *= 2;", "      csinfo = xrealloc(csinfo, sizeof(csinfo_T)*csinfo_size);", "    }"], "whitespace/operators"]
["src/nvim/if_cscope.c", ["    }", "    for (size_t j = csinfo_size/2; j < csinfo_size; j++)", "      clear_csinfo(j);"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "  (void)strcpy(csinfo[i].fname, (const char *)fname);", ""], "runtime/printf"]
["src/nvim/if_cscope.c", ["    csinfo[i].ppath = xmalloc(strlen(ppath) + 1);", "    (void)strcpy(csinfo[i].ppath, (const char *)ppath);", "  } else"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    (void)strcpy(csinfo[i].ppath, (const char *)ppath);", "  } else", "    csinfo[i].ppath = NULL;"], "readability/braces"]
["src/nvim/if_cscope.c", ["    csinfo[i].flags = xmalloc(strlen(flags) + 1);", "    (void)strcpy(csinfo[i].flags, (const char *)flags);", "  } else"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    (void)strcpy(csinfo[i].flags, (const char *)flags);", "  } else", "    csinfo[i].flags = NULL;"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "  if (eap->arg == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "  if ((stok = strtok((char *)(eap->arg), (const char *)\" \")) == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "  if ((stok = strtok((char *)(eap->arg), (const char *)\" \")) == NULL)", "    return NULL;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["  len = strlen(stok);", "  for (cmdp = cs_cmds; cmdp->name != NULL; ++cmdp) {", "    if (strncmp((const char *)(stok), cmdp->name, len) == 0)"], "readability/increment"]
["src/nvim/if_cscope.c", ["  for (cmdp = cs_cmds; cmdp->name != NULL; ++cmdp) {", "    if (strncmp((const char *)(stok), cmdp->name, len) == 0)", "      return cmdp;"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "  if ((stok = strtok((char *)NULL, (const char *)\" \")) == NULL) {", "    cs_usage_msg(Kill);"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["    num = atoi(stok);", "    if (num == -1)", "      killall = true;"], "readability/braces"]
["src/nvim/if_cscope.c", ["      killall = true;", "    else if (num >= 0) {", "      i = (size_t)num;"], "readability/braces"]
["src/nvim/if_cscope.c", ["    } else {      // All negative values besides -1 are invalid.", "      if (p_csverbose)", "        (void)EMSG2(_(\"E261: cscope connection %s not found\"), stok);"], "readability/braces"]
["src/nvim/if_cscope.c", ["    for (i = 0; i < csinfo_size; i++) {", "      if (csinfo[i].fname != NULL && strstr(csinfo[i].fname, stok))", "        break;"], "readability/braces"]
["src/nvim/if_cscope.c", ["      for (i = 0; i < csinfo_size; i++) {", "        if (csinfo[i].fname)", "          cs_kill_execute(i, csinfo[i].fname);"], "readability/braces"]
["src/nvim/if_cscope.c", ["  }", "  cs_release_csp(i, TRUE);", "}"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "    (void)sprintf(buf, \"%s\\t%s\\t%s;\\\"\\t%s\", tagstr, fname, slno, search);", "  } else {"], "runtime/printf"]
["src/nvim/if_cscope.c", ["", "    (void)sprintf(buf, \"%s\\t%s\\t%s;\\\"\", tagstr, fname, slno);", "  }"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    assert(totmatches > 0);", "    if (mp != NULL || cp != NULL)", "      (void)cs_manage_matches(NULL, NULL, 0, Free);"], "readability/braces"]
["src/nvim/if_cscope.c", ["  case Get:", "    if (next >= cnt)", "      return NULL;"], "readability/braces"]
["src/nvim/if_cscope.c", ["        xfree(mp[cnt]);", "        if (cp != NULL)", "          xfree(cp[cnt]);"], "readability/braces"]
["src/nvim/if_cscope.c", ["  if ((p = strchr(buf, '\\n')) == NULL) {", "    while ((ch = getc(csinfo[cnumber].fr_fp)) != EOF && ch != '\\n')", "      ;"], "readability/braces"]
["src/nvim/if_cscope.c", ["    while ((ch = getc(csinfo[cnumber].fr_fp)) != EOF && ch != '\\n')", "      ;", "    return NULL;"], "whitespace/semicolon"]
["src/nvim/if_cscope.c", ["", "  /*", "   * cscope output is in the following format:"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["   */", "  if ((name = strtok((char *)buf, (const char *)\" \")) == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/if_cscope.c", ["   */", "  if ((name = strtok((char *)buf, (const char *)\" \")) == NULL)", "    return NULL;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["    return NULL;", "  if ((*context = strtok(NULL, (const char *)\" \")) == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/if_cscope.c", ["    return NULL;", "  if ((*context = strtok(NULL, (const char *)\" \")) == NULL)", "    return NULL;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["    return NULL;", "  if ((*linenumber = strtok(NULL, (const char *)\" \")) == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/if_cscope.c", ["    return NULL;", "  if ((*linenumber = strtok(NULL, (const char *)\" \")) == NULL)", "    return NULL;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["  for (size_t i = 0; i < csinfo_size; i++) {", "    if (nummatches_a[i] < 1)", "      continue;"], "readability/braces"]
["src/nvim/if_cscope.c", ["    for (int j = 0; j < nummatches_a[i]; j++) {", "      if ((fullname = cs_parse_results(i, buf, CSREAD_BUFSIZE, &cntx,", "               &slno, &search)) == NULL)"], "readability/braces"]
["src/nvim/if_cscope.c", ["      if ((fullname = cs_parse_results(i, buf, CSREAD_BUFSIZE, &cntx,", "               &slno, &search)) == NULL)", "        continue;"], "whitespace/alignment"]
["src/nvim/if_cscope.c", ["", "      if (strcmp(cntx, \"<global>\")==0)", "        strcpy(context, \"<<global>>\");"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "      if (strcmp(cntx, \"<global>\")==0)", "        strcpy(context, \"<<global>>\");"], "whitespace/operators"]
["src/nvim/if_cscope.c", ["      if (strcmp(cntx, \"<global>\")==0)", "        strcpy(context, \"<<global>>\");", "      else"], "runtime/printf"]
["src/nvim/if_cscope.c", ["        strcpy(context, \"<<global>>\");", "      else", "        sprintf(context, \"<<%s>>\", cntx);"], "readability/braces"]
["src/nvim/if_cscope.c", ["      else", "        sprintf(context, \"<<%s>>\", cntx);", ""], "runtime/printf"]
["src/nvim/if_cscope.c", ["", "      if (search == NULL)", "        fprintf(f, \"%s\\t%s\\t%s\\n\", fullname, slno, context);"], "readability/braces"]
["src/nvim/if_cscope.c", ["        fprintf(f, \"%s\\t%s\\t%s\\n\", fullname, slno, context);", "      else", "        fprintf(f, \"%s\\t%s\\t%s %s\\n\", fullname, slno, context, search);"], "readability/braces"]
["src/nvim/if_cscope.c", ["  for (size_t i = 0; i < csinfo_size; i++) {", "    if (nummatches_a[i] < 1)", "      continue;"], "readability/braces"]
["src/nvim/if_cscope.c", ["    for (int j = 0; j < nummatches_a[i]; j++) {", "      if ((fullname = cs_parse_results(i, buf, CSREAD_BUFSIZE, &cntx,", "               &slno, &search)) == NULL)"], "readability/braces"]
["src/nvim/if_cscope.c", ["      if ((fullname = cs_parse_results(i, buf, CSREAD_BUFSIZE, &cntx,", "               &slno, &search)) == NULL)", "        continue;"], "whitespace/alignment"]
["src/nvim/if_cscope.c", ["", "      if (strcmp(cntx, \"<global>\") == 0)", "        cntxts[totsofar] = NULL;"], "readability/braces"]
["src/nvim/if_cscope.c", ["        cntxts[totsofar] = NULL;", "      else {", "        cntxts[totsofar] = xstrdup(cntx);"], "readability/braces"]
["src/nvim/if_cscope.c", ["        cntxts[totsofar] = NULL;", "      else {", "        cntxts[totsofar] = xstrdup(cntx);"], "readability/braces"]
["src/nvim/if_cscope.c", ["#if defined(UNIX) && defined(SIGALRM)", "/*", " * Used to catch and ignore SIGALRM below."], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["    sleep(0);", "    for (waited = 0; waited < 40; ++waited) {", "      pid = waitpid(csinfo[i].pid, &pstat, WNOHANG);"], "readability/increment"]
["src/nvim/if_cscope.c", ["# endif", "    /*", "     * If the cscope process is still running: kill it."], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["      if (waitpid_errno == ECHILD) {", "        /*", "         * When using 'vim -g', vim is forked and cscope process is"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["      }", "      if (alive)", "# endif"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "  if (csinfo[i].fr_fp != NULL)", "    (void)fclose(csinfo[i].fr_fp);"], "readability/braces"]
["src/nvim/if_cscope.c", ["    (void)fclose(csinfo[i].fr_fp);", "  if (csinfo[i].to_fp != NULL)", "    (void)fclose(csinfo[i].to_fp);"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "  if (csinfo_size == 0)", "    return CSCOPE_SUCCESS;"], "readability/braces"]
["src/nvim/if_cscope.c", ["    fllist[i] = csinfo[i].flags;", "    if (csinfo[i].fname != NULL)", "      cs_release_csp(i, FALSE);"], "readability/braces"]
["src/nvim/if_cscope.c", ["    if (csinfo[i].fname != NULL)", "      cs_release_csp(i, FALSE);", "  }"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "  /*", "   * Ppath is freed when we destroy the cscope connection."], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["    STRLCPY(csdir, csinfo[i].fname,", "        path_tail((char_u *)csinfo[i].fname)", "        - (char_u *)csinfo[i].fname + 1);"], "whitespace/alignment"]
["src/nvim/if_cscope.c", ["        path_tail((char_u *)csinfo[i].fname)", "        - (char_u *)csinfo[i].fname + 1);", "    len += STRLEN(csdir);"], "whitespace/alignment"]
["src/nvim/if_cscope.c", ["    fullname = xmalloc(len);", "    (void)sprintf(fullname, \"%s/%s\", csinfo[i].ppath, name);", "  } else if (csdir != NULL && csinfo[i].fname != NULL && *csdir != NUL) {"], "runtime/printf"]
["src/nvim/if_cscope.c", ["{", "  if (cs_cnt_connections() == 0)", "    MSG_PUTS(_(\"no cscope connections\\n\"));"], "readability/braces"]
["src/nvim/if_cscope.c", ["    MSG_PUTS(_(\"no cscope connections\\n\"));", "  else {", "    MSG_PUTS_ATTR("], "readability/braces"]
["src/nvim/if_cscope.c", ["    MSG_PUTS(_(\"no cscope connections\\n\"));", "  else {", "    MSG_PUTS_ATTR("], "readability/braces"]
["src/nvim/if_cscope.c", ["    for (size_t i = 0; i < csinfo_size; i++) {", "      if (csinfo[i].fname == NULL)", "        continue;"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "  wait_return(TRUE);", "  return CSCOPE_SUCCESS;"], "readability/bool"]
["src/nvim/if_cscope.c", ["{", "  for (size_t i = 0; i < csinfo_size; i++)", "    cs_release_csp(i, true);"], "readability/braces"]
