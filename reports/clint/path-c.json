["src/nvim/path.c", ["", "#define URL_SLASH       1               /* path_is_url() has found \"://\" */", "#define URL_BACKSLASH   2               /* path_is_url() has found \":\\\\\" */"], "readability/old_style_comment"]
["src/nvim/path.c", ["#define URL_SLASH       1               /* path_is_url() has found \"://\" */", "#define URL_BACKSLASH   2               /* path_is_url() has found \":\\\\\" */", ""], "readability/old_style_comment"]
["src/nvim/path.c", ["    if (checkname) {", "      vim_FullName((char *)exp1, (char *)full1, MAXPATHL, FALSE);", "      vim_FullName((char *)s2, (char *)full2, MAXPATHL, FALSE);"], "readability/bool"]
["src/nvim/path.c", ["      vim_FullName((char *)exp1, (char *)full1, MAXPATHL, FALSE);", "      vim_FullName((char *)s2, (char *)full2, MAXPATHL, FALSE);", "      if (fnamecmp(full1, full2) == 0) {"], "readability/bool"]
["src/nvim/path.c", ["///", "/// Takes care of \"c:/\" and \"//\". That means `path_tail_with_sep(\"dir///file.txt\")`", "/// will return a pointer to `\"///file.txt\"`."], "whitespace/line_length"]
["src/nvim/path.c", ["{", "  const char_u *tail = get_past_head((char_u *) invocation);", "  const char_u *p = tail;"], "whitespace/cast"]
["src/nvim/path.c", ["  while (vim_ispathsep(*retval)) {", "    ++retval;", "  }"], "readability/increment"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if 'c' is a path separator."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Like vim_ispathsep(c), but exclude the colon for MS-Windows."], "readability/old_style_comment"]
["src/nvim/path.c", ["#endif", "  ;", "}"], "whitespace/semicolon"]
["src/nvim/path.c", ["", "/*", " * return TRUE if 'c' is a path list separator."], "readability/old_style_comment"]
["src/nvim/path.c", ["#else", "  return c == ';';      /* might not be right for every system... */", "#endif"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Shorten the path of a file from \"~/foo/../.bar/fname\" to \"~/f/../.b/fname\""], "readability/old_style_comment"]
["src/nvim/path.c", ["  bool skip = false;", "  for (char_u *s = str;; ++s) {", "    if (s >= tail) {                /* copy the whole tail */"], "readability/increment"]
["src/nvim/path.c", ["  for (char_u *s = str;; ++s) {", "    if (s >= tail) {                /* copy the whole tail */", "      *d++ = *s;"], "readability/old_style_comment"]
["src/nvim/path.c", ["      *d++ = *s;", "      if (*s == NUL)", "        break;"], "readability/braces"]
["src/nvim/path.c", ["        break;", "    } else if (vim_ispathsep(*s)) {       /* copy '/' and next char */", "      *d++ = *s;"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if the directory of \"fname\" exists, FALSE otherwise."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Unix style wildcard expansion code."], "readability/old_style_comment"]
["src/nvim/path.c", ["#endif", "    if (vim_strchr((char_u *) wildcards, *p) != NULL) {", "      return true;"], "whitespace/cast"]
["src/nvim/path.c", ["", "  /* Expanding \"**\" may take a long time, check for CTRL-C. */", "  if (stardepth > 0) {"], "readability/old_style_comment"]
["src/nvim/path.c", ["    os_breakcheck();", "    if (got_int)", "      return 0;"], "readability/braces"]
["src/nvim/path.c", ["  while (*path_end != NUL) {", "    /* May ignore a wildcard that has a backslash before it; it will", "     * be removed by rem_backslash() or file_pat_to_reg_pat() below. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["#endif", "    )) {", "      e = p;"], "whitespace/alignment"]
["src/nvim/path.c", ["#endif", "    )) {", "      e = p;"], "whitespace/alignment"]
["src/nvim/path.c", ["#endif", "    )) {", "      e = p;"], "whitespace/parens"]
["src/nvim/path.c", ["", "  /* Now we have one wildcard component between \"s\" and \"e\". */", "  /* Remove backslashes between \"wildoff\" and the start of the wildcard"], "readability/old_style_comment"]
["src/nvim/path.c", ["  /* Now we have one wildcard component between \"s\" and \"e\". */", "  /* Remove backslashes between \"wildoff\" and the start of the wildcard", "   * component. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["   * component. */", "  for (p = buf + wildoff; p < s; ++p)", "    if (rem_backslash(p)) {"], "readability/braces"]
["src/nvim/path.c", ["   * component. */", "  for (p = buf + wildoff; p < s; ++p)", "    if (rem_backslash(p)) {"], "readability/increment"]
["src/nvim/path.c", ["      STRMOVE(p, p + 1);", "      --e;", "      --s;"], "readability/increment"]
["src/nvim/path.c", ["      --e;", "      --s;", "    }"], "readability/increment"]
["src/nvim/path.c", ["", "  /* Check for \"**\" between \"s\" and \"e\". */", "  for (p = s; p < e; ++p)"], "readability/old_style_comment"]
["src/nvim/path.c", ["  /* Check for \"**\" between \"s\" and \"e\". */", "  for (p = s; p < e; ++p)", "    if (p[0] == '*' && p[1] == '*')"], "readability/braces"]
["src/nvim/path.c", ["  /* Check for \"**\" between \"s\" and \"e\". */", "  for (p = s; p < e; ++p)", "    if (p[0] == '*' && p[1] == '*')"], "readability/increment"]
["src/nvim/path.c", ["  for (p = s; p < e; ++p)", "    if (p[0] == '*' && p[1] == '*')", "      starstar = true;"], "readability/braces"]
["src/nvim/path.c", ["#endif", "  if (flags & (EW_NOERROR | EW_NOTWILD))", "    ++emsg_silent;"], "readability/braces"]
["src/nvim/path.c", ["  if (flags & (EW_NOERROR | EW_NOTWILD))", "    ++emsg_silent;", "  regmatch.regprog = vim_regcomp(pat, RE_MAGIC);"], "readability/increment"]
["src/nvim/path.c", ["  regmatch.regprog = vim_regcomp(pat, RE_MAGIC);", "  if (flags & (EW_NOERROR | EW_NOTWILD))", "    --emsg_silent;"], "readability/braces"]
["src/nvim/path.c", ["  if (flags & (EW_NOERROR | EW_NOTWILD))", "    --emsg_silent;", "  xfree(pat);"], "readability/increment"]
["src/nvim/path.c", ["", "  /* If \"**\" is by itself, this is the first time we encounter it and more", "   * is following then find matches without any directory. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["        if (starstar && stardepth < 100) {", "          /* For \"**\" in the pattern first go deeper in the tree to", "           * find matches. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["           * find matches. */", "          STRCPY(buf + len, \"/**\");", "          STRCPY(buf + len + 3, path_end);"], "readability/old_style_comment"]
["src/nvim/path.c", ["          STRCPY(buf + len + 3, path_end);", "          ++stardepth;", "          (void)do_path_expand(gap, buf, len + 1, flags, true);"], "readability/increment"]
["src/nvim/path.c", ["          (void)do_path_expand(gap, buf, len + 1, flags, true);", "          --stardepth;", "        }"], "readability/increment"]
["src/nvim/path.c", ["        STRCPY(buf + len, path_end);", "        if (path_has_exp_wildcard(path_end)) {      /* handle more wildcards */", "          /* need to expand another component of the path */"], "readability/old_style_comment"]
["src/nvim/path.c", ["        if (path_has_exp_wildcard(path_end)) {      /* handle more wildcards */", "          /* need to expand another component of the path */", "          /* remove backslashes for the remaining components only */"], "readability/old_style_comment"]
["src/nvim/path.c", ["          /* need to expand another component of the path */", "          /* remove backslashes for the remaining components only */", "          (void)do_path_expand(gap, buf, len + 1, flags, false);"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Moves \"*psep\" back to the previous path separator in \"path\"."], "readability/old_style_comment"]
["src/nvim/path.c", ["{", "  /* skip the current separator */", "  if (*psep > path && vim_ispathsep(**psep))"], "readability/old_style_comment"]
["src/nvim/path.c", ["  /* skip the current separator */", "  if (*psep > path && vim_ispathsep(**psep))", "    --*psep;"], "readability/braces"]
["src/nvim/path.c", ["  if (*psep > path && vim_ispathsep(**psep))", "    --*psep;", ""], "readability/increment"]
["src/nvim/path.c", ["", "  /* find the previous separator */", "  while (*psep > path) {"], "readability/old_style_comment"]
["src/nvim/path.c", ["  while (*psep > path) {", "    if (vim_ispathsep(**psep))", "      return OK;"], "readability/braces"]
["src/nvim/path.c", ["", "/*", " * Returns TRUE if \"maybe_unique\" is unique wrt other_paths in \"gap\"."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Split the 'path' option into an array of strings in garray_T.  Relative"], "readability/old_style_comment"]
["src/nvim/path.c", ["    if (buf[0] == '.' && (buf[1] == NUL || vim_ispathsep(buf[1]))) {", "      /* Relative to current buffer:", "       * \"/path/file\" + \".\" -> \"/path/\""], "readability/old_style_comment"]
["src/nvim/path.c", ["       * \"/path/file\"  + \"./subdir\" -> \"/path/subdir\" */", "      if (curbuf->b_ffname == NULL)", "        continue;"], "readability/braces"]
["src/nvim/path.c", ["", "/*", " * Returns a pointer to the file or directory name in \"fname\" that matches the"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Sorts, removes duplicates and modifies all the fullpath names in \"gap\" so"], "readability/old_style_comment"]
["src/nvim/path.c", ["  xfree(file_pattern);", "  if (pat == NULL)", "    return;"], "readability/braces"]
["src/nvim/path.c", ["", "  regmatch.rm_ic = TRUE;                /* always ignore case */", "  regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "  regmatch.rm_ic = TRUE;                /* always ignore case */", "  regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);"], "readability/bool"]
["src/nvim/path.c", ["  xfree(pat);", "  if (regmatch.regprog == NULL)", "    return;"], "readability/braces"]
["src/nvim/path.c", ["                   && curdir[dir_end - path] == NUL;", "    if (is_in_curdir)", "      in_curdir[i] = vim_strsave(path);"], "readability/braces"]
["src/nvim/path.c", ["", "    /* Shorten the filename while maintaining its uniqueness */", "    path_cutoff = get_path_cutoff(path, &path_ga);"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "  /* Shorten filenames in /in/current/directory/{filename} */", "  for (int i = 0; i < gap->ga_len && !got_int; i++) {"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "    if (path == NULL)", "      continue;"], "readability/braces"]
["src/nvim/path.c", ["", "    /* If the {filename} is not unique, change it to ./{filename}.", "     * Else reduce it to {filename} */"], "readability/old_style_comment"]
["src/nvim/path.c", ["    short_name = path_shorten_fname(path, curdir);", "    if (short_name == NULL)", "      short_name = path;"], "readability/braces"]
["src/nvim/path.c", ["  xfree(curdir);", "  for (int i = 0; i < gap->ga_len; i++)", "    xfree(in_curdir[i]);"], "readability/braces"]
["src/nvim/path.c", ["", "  if (sort_again)", "    ga_remove_duplicate_strings(gap);"], "readability/braces"]
["src/nvim/path.c", ["    } else {", "      if (!look_for_sep)", "        dir_end = next_dir_end;"], "readability/braces"]
["src/nvim/path.c", ["", "/*", " * Calls globpath() with 'path' values for the given pattern and stores the"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if \"p\" contains what looks like an environment variable."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "  /*", "   * expand_env() is called to expand things like \"~user\".  If this fails,"], "readability/old_style_comment"]
["src/nvim/path.c", ["   */", "  if (recursive)", "#ifdef SPECIAL_WILDCHAR"], "readability/braces"]
["src/nvim/path.c", ["#ifdef SPECIAL_WILDCHAR", "  /*", "   * If there are any special wildcard characters which we cannot handle"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "  /*", "   * The matching file names are stored in a growarray.  Init it empty."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "  for (int i = 0; i < num_pat; ++i) {", "    add_pat = -1;"], "readability/increment"]
["src/nvim/path.c", ["        p = expand_env_save_opt(p, true);", "        if (p == NULL)", "          p = pat[i];"], "readability/braces"]
["src/nvim/path.c", ["#ifdef UNIX", "        /*", "         * On Unix, if expand_env() can't expand an environment"], "readability/old_style_comment"]
["src/nvim/path.c", ["         */", "        else if (has_env_var(p) || *p == '~') {", "          xfree(p);"], "readability/braces"]
["src/nvim/path.c", ["", "      /*", "       * If there are wildcards: Expand file names and add each match to"], "readability/old_style_comment"]
["src/nvim/path.c", ["            ) {", "          /* :find completion where 'path' is used.", "           * Recursiveness is OK here. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "      /* When EW_NOTFOUND is used, always add files and dirs.  Makes", "       * \"vim c:/\" work. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "    if (did_expand_in_path && !GA_EMPTY(&ga) && (flags & EW_PATH))", "      uniquefy_paths(&ga, p);"], "readability/braces"]
["src/nvim/path.c", ["      uniquefy_paths(&ga, p);", "    if (p != pat[i])", "      xfree(p);"], "readability/braces"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if we can expand this backtick thing here."], "readability/old_style_comment"]
["src/nvim/path.c", ["    char_u *pat,", "    int flags              /* EW_* flags */", ")"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "  if (*cmd == '=')          /* `={expr}`: Expand expression */", "    buffer = eval_to_string(cmd + 1, &p, TRUE);"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "  if (*cmd == '=')          /* `={expr}`: Expand expression */", "    buffer = eval_to_string(cmd + 1, &p, TRUE);"], "readability/braces"]
["src/nvim/path.c", ["  if (*cmd == '=')          /* `={expr}`: Expand expression */", "    buffer = eval_to_string(cmd + 1, &p, TRUE);", "  else"], "readability/bool"]
["src/nvim/path.c", ["    buffer = eval_to_string(cmd + 1, &p, TRUE);", "  else", "    buffer = get_cmd_output(cmd, NULL,"], "readability/braces"]
["src/nvim/path.c", ["    buffer = get_cmd_output(cmd, NULL,", "        (flags & EW_SILENT) ? kShellOptSilent : 0, NULL);", "  xfree(cmd);"], "whitespace/alignment"]
["src/nvim/path.c", ["  while (*cmd != NUL) {", "    cmd = skipwhite(cmd);               /* skip over white space */", "    p = cmd;"], "readability/old_style_comment"]
["src/nvim/path.c", ["    p = cmd;", "    while (*p != NUL && *p != '\\r' && *p != '\\n')     /* skip over entry */", "      ++p;"], "readability/old_style_comment"]
["src/nvim/path.c", ["    p = cmd;", "    while (*p != NUL && *p != '\\r' && *p != '\\n')     /* skip over entry */", "      ++p;"], "readability/braces"]
["src/nvim/path.c", ["    while (*p != NUL && *p != '\\r' && *p != '\\n')     /* skip over entry */", "      ++p;", "    /* add an entry if it is not empty */"], "readability/increment"]
["src/nvim/path.c", ["      ++p;", "    /* add an entry if it is not empty */", "    if (p > cmd) {"], "readability/old_style_comment"]
["src/nvim/path.c", ["      *p = i;", "      ++cnt;", "    }"], "readability/increment"]
["src/nvim/path.c", ["    cmd = p;", "    while (*cmd != NUL && (*cmd == '\\r' || *cmd == '\\n'))", "      ++cmd;"], "readability/braces"]
["src/nvim/path.c", ["    while (*cmd != NUL && (*cmd == '\\r' || *cmd == '\\n'))", "      ++cmd;", "  }"], "readability/increment"]
["src/nvim/path.c", ["    garray_T *gap,", "    char_u *f,         /* filename */", "    int flags"], "readability/old_style_comment"]
["src/nvim/path.c", ["#ifdef FNAME_ILLEGAL", "  /* if the file/dir contains illegal characters, don't add it */", "  if (vim_strpbrk(f, (char_u *)FNAME_ILLEGAL) != NULL)"], "readability/old_style_comment"]
["src/nvim/path.c", ["  /* if the file/dir contains illegal characters, don't add it */", "  if (vim_strpbrk(f, (char_u *)FNAME_ILLEGAL) != NULL)", "    return;"], "readability/braces"]
["src/nvim/path.c", ["  isdir = os_isdir(f);", "  if ((isdir && !(flags & EW_DIR)) || (!isdir && !(flags & EW_FILE)))", "    return;"], "readability/braces"]
["src/nvim/path.c", ["#endif", "  /*", "   * Append a slash or backslash after directory names if none is present."], "readability/old_style_comment"]
["src/nvim/path.c", ["   */", "  if (isdir && (flags & EW_ADDSLASH))", "    add_pathsep((char *)p);"], "readability/braces"]
["src/nvim/path.c", ["", "/*", " * Converts a file name into a canonical form. It simplifies a file name into"], "readability/old_style_comment"]
["src/nvim/path.c", ["#ifdef BACKSLASH_IN_FILENAME", "  if (p[1] == ':')          /* skip \"x:\" */", "    p += 2;"], "readability/old_style_comment"]
["src/nvim/path.c", ["#ifdef BACKSLASH_IN_FILENAME", "  if (p[1] == ':')          /* skip \"x:\" */", "    p += 2;"], "readability/braces"]
["src/nvim/path.c", ["    do", "      ++p;", "    while (vim_ispathsep(*p));"], "readability/increment"]
["src/nvim/path.c", ["      ++p;", "    while (vim_ispathsep(*p));", "  }"], "readability/braces"]
["src/nvim/path.c", ["      ++p;", "    while (vim_ispathsep(*p));", "  }"], "whitespace/empty_loop_body"]
["src/nvim/path.c", ["  }", "  start = p;        /* remember start after \"c:/\" or \"/\" or \"///\" */", ""], "readability/old_style_comment"]
["src/nvim/path.c", ["  do {", "    /* At this point \"p\" is pointing to the char following a single \"/\"", "     * or \"p\" is at the \"start\" of the (absolute or relative) path name. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["     * or \"p\" is at the \"start\" of the (absolute or relative) path name. */", "    if (vim_ispathsep(*p))", "      STRMOVE(p, p + 1);                /* remove duplicate \"/\" */"], "readability/braces"]
["src/nvim/path.c", ["    if (vim_ispathsep(*p))", "      STRMOVE(p, p + 1);                /* remove duplicate \"/\" */", "    else if (p[0] == '.' && (vim_ispathsep(p[1]) || p[1] == NUL)) {"], "readability/old_style_comment"]
["src/nvim/path.c", ["      STRMOVE(p, p + 1);                /* remove duplicate \"/\" */", "    else if (p[0] == '.' && (vim_ispathsep(p[1]) || p[1] == NUL)) {", "      if (p == start && relative)"], "readability/braces"]
["src/nvim/path.c", ["    else if (p[0] == '.' && (vim_ispathsep(p[1]) || p[1] == NUL)) {", "      if (p == start && relative)", "        p += 1 + (p[1] != NUL);         /* keep single \".\" or leading \"./\" */"], "readability/braces"]
["src/nvim/path.c", ["      if (p == start && relative)", "        p += 1 + (p[1] != NUL);         /* keep single \".\" or leading \"./\" */", "      else {"], "readability/old_style_comment"]
["src/nvim/path.c", ["        p += 1 + (p[1] != NUL);         /* keep single \".\" or leading \"./\" */", "      else {", "        /* Strip \"./\" or \".///\".  If we are at the end of the file name"], "readability/braces"]
["src/nvim/path.c", ["        p += 1 + (p[1] != NUL);         /* keep single \".\" or leading \"./\" */", "      else {", "        /* Strip \"./\" or \".///\".  If we are at the end of the file name"], "readability/braces"]
["src/nvim/path.c", ["      else {", "        /* Strip \"./\" or \".///\".  If we are at the end of the file name", "         * and there is no trailing path separator, either strip \"/.\" if"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "      if (components > 0) {             /* strip one preceding component */", "        bool do_strip = false;"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "        /* Don't strip for an erroneous file name. */", "        if (!stripping_disabled) {"], "readability/old_style_comment"]
["src/nvim/path.c", ["        if (!stripping_disabled) {", "          /* If the preceding component does not exist in the file", "           * system, we strip it.  On Unix, we don't accept a symbolic"], "readability/old_style_comment"]
["src/nvim/path.c", ["          if (!do_strip) {", "            /* If the component exists in the file system, check", "             * that stripping it won't change the meaning of the"], "readability/old_style_comment"]
["src/nvim/path.c", ["            if (do_strip) {", "              /* The check for the unstripped file name", "               * above works also for a symbolic link pointing to"], "readability/old_style_comment"]
["src/nvim/path.c", ["                do_strip = false;", "                /* We don't disable stripping of later", "                 * components since the unstripped path name is"], "readability/old_style_comment"]
["src/nvim/path.c", ["        if (!do_strip) {", "          /* Skip the \"..\" or \"../\" and reset the counter for the", "           * components that might be stripped later on. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["        } else {", "          /* Strip previous component.  If the result would get empty", "           * and there is no trailing path separator, leave a single"], "readability/old_style_comment"]
["src/nvim/path.c", ["          } else {", "            if (p > start && tail[-1] == '.')", "              --p;"], "readability/braces"]
["src/nvim/path.c", ["            if (p > start && tail[-1] == '.')", "              --p;", "            STRMOVE(p, tail);                   /* strip previous component */"], "readability/increment"]
["src/nvim/path.c", ["              --p;", "            STRMOVE(p, tail);                   /* strip previous component */", "          }"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "          --components;", "        }"], "readability/increment"]
["src/nvim/path.c", ["        }", "      } else if (p == start && !relative)       /* leading \"/..\" or \"/../\" */", "        STRMOVE(p, tail);                       /* strip \"..\" or \"../\" */"], "readability/old_style_comment"]
["src/nvim/path.c", ["        }", "      } else if (p == start && !relative)       /* leading \"/..\" or \"/../\" */", "        STRMOVE(p, tail);                       /* strip \"..\" or \"../\" */"], "readability/braces"]
["src/nvim/path.c", ["      } else if (p == start && !relative)       /* leading \"/..\" or \"/../\" */", "        STRMOVE(p, tail);                       /* strip \"..\" or \"../\" */", "      else {"], "readability/old_style_comment"]
["src/nvim/path.c", ["        STRMOVE(p, tail);                       /* strip \"..\" or \"../\" */", "      else {", "        if (p == start + 2 && p[-2] == '.') {           /* leading \"./../\" */"], "readability/braces"]
["src/nvim/path.c", ["        STRMOVE(p, tail);                       /* strip \"..\" or \"../\" */", "      else {", "        if (p == start + 2 && p[-2] == '.') {           /* leading \"./../\" */"], "readability/braces"]
["src/nvim/path.c", ["      else {", "        if (p == start + 2 && p[-2] == '.') {           /* leading \"./../\" */", "          STRMOVE(p - 2, p);                            /* strip leading \"./\" */"], "readability/old_style_comment"]
["src/nvim/path.c", ["        if (p == start + 2 && p[-2] == '.') {           /* leading \"./../\" */", "          STRMOVE(p - 2, p);                            /* strip leading \"./\" */", "          tail -= 2;"], "readability/old_style_comment"]
["src/nvim/path.c", ["        }", "        p = tail;                       /* skip to char after \"..\" or \"../\" */", "      }"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Return the name of the file ptr[len] in 'path'."], "readability/old_style_comment"]
["src/nvim/path.c", ["char_u *", "find_file_name_in_path (", "    char_u *ptr,"], "whitespace/parens"]
["src/nvim/path.c", ["    long count,", "    char_u *rel_fname         /* file we are searching relative to */", ")"], "readability/old_style_comment"]
["src/nvim/path.c", ["  if ((options & FNAME_INCL) && *curbuf->b_p_inex != NUL) {", "    tofree = (char_u *) eval_includeexpr((char *) ptr, len);", "    if (tofree != NULL) {"], "whitespace/cast"]
["src/nvim/path.c", ["", "    /*", "     * If the file could not be found in a normal way, try applying"], "readability/old_style_comment"]
["src/nvim/path.c", ["        && !(options & FNAME_INCL) && *curbuf->b_p_inex != NUL) {", "      tofree = (char_u *) eval_includeexpr((char *) ptr, len);", "      if (tofree != NULL) {"], "whitespace/cast"]
["src/nvim/path.c", ["        file_name = find_file_in_path(ptr, len, options & ~FNAME_MESS,", "                                      TRUE, rel_fname);", "      }"], "readability/bool"]
["src/nvim/path.c", ["", "    /* Repeat finding the file \"count\" times.  This matters when it", "     * appears several times in the path. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["      xfree(file_name);", "      file_name = find_file_in_path(ptr, len, options, FALSE, rel_fname);", "    }"], "readability/bool"]
["src/nvim/path.c", ["    }", "  } else", "    file_name = vim_strnsave(ptr, len);"], "readability/braces"]
["src/nvim/path.c", ["{", "  if (strncmp(p, \"://\", 3) == 0)", "    return URL_SLASH;"], "readability/braces"]
["src/nvim/path.c", ["    return URL_SLASH;", "  else if (strncmp(p, \":\\\\\\\\\", 3) == 0)", "    return URL_BACKSLASH;"], "readability/braces"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if \"name\" is a full (absolute) path name or URL."], "readability/old_style_comment"]
["src/nvim/path.c", ["#else", "  if (!vim_isAbsName((char_u *)fname)", "      || strstr(fname, \"..\") != NULL"], "readability/braces"]
["src/nvim/path.c", ["    *slash = NUL;", "    ok = os_scandir(&dir, (char *) name);", "    *slash = '/';"], "whitespace/cast"]
["src/nvim/path.c", ["  char_u *entry;", "  while ((entry = (char_u *) os_scandir_next(&dir))) {", "    // Only accept names that differ in case and are the same byte"], "whitespace/cast"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if \"p\" points to just after a path separator."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if file names \"f1\" and \"f2\" are in the same directory."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "  /* safety check */", "  if (f1 == NULL || f2 == NULL)"], "readability/old_style_comment"]
["src/nvim/path.c", ["  /* safety check */", "  if (f1 == NULL || f2 == NULL)", "    return false;"], "readability/braces"]
["src/nvim/path.c", ["", "  (void)vim_FullName((char *)f1, (char *)ffname, MAXPATHL, FALSE);", "  t1 = path_tail_with_sep(ffname);"], "readability/bool"]
["src/nvim/path.c", ["", "/*", " * Compare path \"p[]\" to \"q[]\"."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "    /* End of \"p\": check if \"q\" also ends or just has a slash. */", "    if (c1 == NUL) {"], "readability/old_style_comment"]
["src/nvim/path.c", ["    if (c1 == NUL) {", "      if (c2 == NUL)        /* full match */", "        return 0;"], "readability/old_style_comment"]
["src/nvim/path.c", ["    if (c1 == NUL) {", "      if (c2 == NUL)        /* full match */", "        return 0;"], "readability/braces"]
["src/nvim/path.c", ["", "    /* End of \"q\": check if \"p\" just has a slash. */", "    if (c2 == NUL) {"], "readability/old_style_comment"]
["src/nvim/path.c", ["#ifdef BACKSLASH_IN_FILENAME", "        /* consider '/' and '\\\\' to be equal */", "        && !((c1 == '/' && c2 == '\\\\')"], "readability/old_style_comment"]
["src/nvim/path.c", ["        ) {", "      if (vim_ispathsep(c1))", "        return -1;"], "readability/braces"]
["src/nvim/path.c", ["        return -1;", "      if (vim_ispathsep(c2))", "        return 1;"], "readability/braces"]
["src/nvim/path.c", ["  if (*exp_pat == '%' || *exp_pat == '#' || *exp_pat == '<') {", "    ++emsg_off;", "    eval_pat = eval_vars(exp_pat, exp_pat, &usedlen,"], "readability/increment"]
["src/nvim/path.c", ["    eval_pat = eval_vars(exp_pat, exp_pat, &usedlen,", "        NULL, &ignored_msg, NULL);", "    --emsg_off;"], "whitespace/alignment"]
["src/nvim/path.c", ["        NULL, &ignored_msg, NULL);", "    --emsg_off;", "    if (eval_pat != NULL)"], "readability/increment"]
["src/nvim/path.c", ["    --emsg_off;", "    if (eval_pat != NULL)", "      exp_pat = concat_str(eval_pat, exp_pat + usedlen);"], "readability/braces"]
["src/nvim/path.c", ["", "  if (exp_pat != NULL)", "    ret = expand_wildcards(1, &exp_pat, num_file, file, flags);"], "readability/braces"]
["src/nvim/path.c", ["  char_u      *p;", "  int non_suf_match;            /* number without matching suffix */", ""], "readability/old_style_comment"]
["src/nvim/path.c", ["", "  /* When keeping all matches, return here */", "  if ((flags & EW_KEEPALL) || retval == FAIL)"], "readability/old_style_comment"]
["src/nvim/path.c", ["  /* When keeping all matches, return here */", "  if ((flags & EW_KEEPALL) || retval == FAIL)", "    return retval;"], "readability/braces"]
["src/nvim/path.c", ["", "  /*", "   * Remove names that match 'wildignore'."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if \"fname\" matches with an entry in 'suffixes'."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "      /* empty entry: match name without a '.' */", "      if (vim_strchr(tail, '.') == NULL) {"], "readability/old_style_comment"]
["src/nvim/path.c", ["  if (STRLEN(directory) == 0) {", "    return os_dirname((char_u *) buffer, len);", "  }"], "whitespace/cast"]
["src/nvim/path.c", ["  // Get current directory name.", "  if (os_dirname((char_u *) old_dir, MAXPATHL) == FAIL) {", "    return FAIL;"], "whitespace/cast"]
["src/nvim/path.c", ["", "  if (retval == FAIL || os_dirname((char_u *) buffer, len) == FAIL) {", "    // Do not return immediately since we are in the wrong directory."], "whitespace/cast"]
["src/nvim/path.c", ["  char *relative_directory = xmalloc(len);", "  char *end_of_path = (char *) fname;", ""], "whitespace/cast"]
["src/nvim/path.c", ["      }", "      end_of_path = (char *) (p + 1);", "    } else {"], "whitespace/cast"]
["src/nvim/path.c", ["      relative_directory[0] = NUL;", "      end_of_path = (char *) fname;", "    }"], "whitespace/cast"]
["src/nvim/path.c", ["", "    if (FAIL == path_full_dir_name(relative_directory, (char *) buf, len)) {", "      xfree(relative_directory);"], "whitespace/cast"]
