["src/nvim/indent_c.c", ["#endif", "/*", " * Find the start of a comment, not knowing if we are in a comment right now."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    pos = findmatchlimit(NULL, '*', FM_BACKWARD, cur_maxcomment);", "    if (pos == NULL)", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * Check if the comment start we found is inside a string."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    line = ml_get(pos->lnum);", "    for (p = line; *p && (colnr_T)(p - line) < pos->col; ++p)", "      p = skip_string(p);"], "readability/braces"]
["src/nvim/indent_c.c", ["    line = ml_get(pos->lnum);", "    for (p = line; *p && (colnr_T)(p - line) < pos->col; ++p)", "      p = skip_string(p);"], "readability/increment"]
["src/nvim/indent_c.c", ["      p = skip_string(p);", "    if ((colnr_T)(p - line) <= pos->col)", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Find the start of a raw string, not knowing if we are in one right now."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    for (;;)", "    {"], "readability/braces"]
["src/nvim/indent_c.c", ["    for (;;)", "    {", "        pos = findmatchlimit(NULL, 'R', FM_BACKWARD, cur_maxcomment);"], "whitespace/braces"]
["src/nvim/indent_c.c", ["        pos = findmatchlimit(NULL, 'R', FM_BACKWARD, cur_maxcomment);", "        if (pos == NULL)", "            break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "        /*", "         * Check if the raw string start we found is inside a string."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        line = ml_get(pos->lnum);", "        for (p = line; *p && (colnr_T)(p - line) < pos->col; ++p)", "            p = skip_string(p);"], "readability/braces"]
["src/nvim/indent_c.c", ["        line = ml_get(pos->lnum);", "        for (p = line; *p && (colnr_T)(p - line) < pos->col; ++p)", "            p = skip_string(p);"], "readability/increment"]
["src/nvim/indent_c.c", ["            p = skip_string(p);", "        if ((colnr_T)(p - line) <= pos->col)", "            break;"], "readability/braces"]
["src/nvim/indent_c.c", ["        cur_maxcomment = curwin->w_cursor.lnum - pos->lnum - 1;", "        if (cur_maxcomment <= 0)", "        {"], "readability/braces"]
["src/nvim/indent_c.c", ["        if (cur_maxcomment <= 0)", "        {", "            pos = NULL;"], "whitespace/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Skip to the end of a \"string\" and a 'c' character."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /*", "   * We loop, because strings may be concatenated: \"date\"\"time\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            for (p += 3; *p; ++p)", "                if (p[0] == ')' && STRNCMP(p + 1, delim, delim_len) == 0"], "readability/braces"]
["src/nvim/indent_c.c", ["", "            for (p += 3; *p; ++p)", "                if (p[0] == ')' && STRNCMP(p + 1, delim, delim_len) == 0"], "readability/increment"]
["src/nvim/indent_c.c", ["            for (p += 3; *p; ++p)", "                if (p[0] == ')' && STRNCMP(p + 1, delim, delim_len) == 0", "                        && p[delim_len + 1] == '\"')"], "readability/braces"]
["src/nvim/indent_c.c", ["                if (p[0] == ')' && STRNCMP(p + 1, delim, delim_len) == 0", "                        && p[delim_len + 1] == '\"')", "                {"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["                        && p[delim_len + 1] == '\"')", "                {", "                    p += delim_len + 1;"], "whitespace/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Functions for C-indenting."], "readability/old_style_comment"]
["src/nvim/indent_c.c", [" */", "/*", " * Below \"XXX\" means that this function may unlock the current line."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Return true if the string \"line\" starts with a word from 'cinwords'."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Skip over white space and C comments within the line."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /* Perl/shell # comment comment continues until eol.  Require a space", "     * before # to avoid recognizing $#array. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    }", "    if (*s != '*')", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Return TRUE if there is no code at *s.  White space and comments are"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Check previous lines for a \"//\" line comment, skipping over blank lines."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    }", "    if (*p != NUL)", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["    quote = *s;", "    ++s;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["  }", "  if (!vim_isIDc(*s))\t{   // need at least one ID character", "    return FALSE;"], "whitespace/tab"]
["src/nvim/indent_c.c", ["  }", "  if (!vim_isIDc(*s))\t{   // need at least one ID character", "    return FALSE;"], "whitespace/braces"]
["src/nvim/indent_c.c", ["  if (!vim_isIDc(*s))\t{   // need at least one ID character", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/indent_c.c", ["  while (vim_isIDc(*s)) {", "    ++s;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["  if (*s && *s == quote) {", "    ++s;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["", "  while (vim_isIDc(**s))", "    (*s)++;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "  /*", "   * Only accept a label if the previous line is terminated or is a case"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  while (curwin->w_cursor.lnum > 1) {", "    --curwin->w_cursor.lnum;", ""], "readability/increment"]
["src/nvim/indent_c.c", ["", "    /*", "     * If we're in a comment or raw string now, skip to the start of"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    curwin->w_cursor = cursor_save;", "    if (cin_isterminated(line, TRUE, FALSE)", "        || cin_isscopedecl(line)"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize structure initialization and enumerations:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  char_u      *s;", "  static char *skip[] = {\"static\", \"public\", \"protected\", \"private\"};", ""], "whitespace/braces"]
["src/nvim/indent_c.c", ["  char_u      *s;", "  static char *skip[] = {\"static\", \"public\", \"protected\", \"private\"};", ""], "whitespace/braces"]
["src/nvim/indent_c.c", ["", "  if (cin_starts_with(s, \"typedef\"))", "    s = cin_skipcomment(s + 7);"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    for (i = 0; i < (int)ARRAY_SIZE(skip); ++i) {", "      l = (int)strlen(skip[i]);"], "readability/increment"]
["src/nvim/indent_c.c", ["    }", "    if (l != 0)", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "  if (cin_starts_with(s, \"enum\"))", "    return TRUE;"], "readability/braces"]
["src/nvim/indent_c.c", ["  if (cin_starts_with(s, \"enum\"))", "    return TRUE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "  if (cin_ends_in(s, (char_u *)\"=\", (char_u *)\"{\"))", "    return TRUE;"], "readability/braces"]
["src/nvim/indent_c.c", ["  if (cin_ends_in(s, (char_u *)\"=\", (char_u *)\"{\"))", "    return TRUE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize a switch label: \"case .*:\" or \"default:\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  if (cin_starts_with(s, \"case\")) {", "    for (s += 4; *s; ++s) {", "      s = cin_skipcomment(s);"], "readability/increment"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize a \"default\" switch label."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize a \"public/private/protected\" scope declaration label."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Return a pointer to the first non-empty non-comment character after a ':'."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["{", "  for (; *l; ++l) {", "    if (*l == ':') {"], "readability/increment"]
["src/nvim/indent_c.c", ["  }", "  if (*l == NUL)", "    return NULL;"], "readability/braces"]
["src/nvim/indent_c.c", ["  l = cin_skipcomment(l + 1);", "  if (*l == NUL)", "    return NULL;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Get indent of line \"lnum\", skipping a label."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  p = after_label(l);", "  if (p == NULL)", "    return 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Find indent for line \"lnum\", ignoring any case or jump label."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Return the indent of the first variable name after a type in a declaration."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  }", "  if (len == 6 && STRNCMP(p, \"struct\", 6) == 0)", "    p = skipwhite(p + 6);"], "readability/braces"]
["src/nvim/indent_c.c", ["    p = skipwhite(p + 6);", "  else if (len == 4 && STRNCMP(p, \"enum\", 4) == 0)", "    p = skipwhite(p + 4);"], "readability/braces"]
["src/nvim/indent_c.c", ["    p = skipwhite(p + 4);", "  else if ((len == 8 && STRNCMP(p, \"unsigned\", 8) == 0)", "           || (len == 6 && STRNCMP(p, \"signed\", 6) == 0)) {"], "readability/braces"]
["src/nvim/indent_c.c", ["    s = skipwhite(p + len);", "    if ((STRNCMP(s, \"int\", 3) == 0 && ascii_iswhite(s[3]))", "        || (STRNCMP(s, \"long\", 4) == 0 && ascii_iswhite(s[4]))"], "readability/braces"]
["src/nvim/indent_c.c", ["  }", "  for (len = 0; vim_isIDc(p[len]); ++len)", "    ;"], "readability/braces"]
["src/nvim/indent_c.c", ["  }", "  for (len = 0; vim_isIDc(p[len]); ++len)", "    ;"], "readability/increment"]
["src/nvim/indent_c.c", ["  for (len = 0; vim_isIDc(p[len]); ++len)", "    ;", "  if (len == 0 || !ascii_iswhite(p[len]) || cin_nocode(p))"], "whitespace/semicolon"]
["src/nvim/indent_c.c", ["    ;", "  if (len == 0 || !ascii_iswhite(p[len]) || cin_nocode(p))", "    return 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Return the indent of the first non-blank after an equal sign."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    line = ml_get(lnum - 1);", "    if (*line != NUL && line[STRLEN(line) - 1] == '\\\\')", "      return -1;"], "readability/braces"]
["src/nvim/indent_c.c", ["  }", "  if (*s != '=')", "    return 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["  s = skipwhite(s + 1);", "  if (cin_nocode(s))", "    return 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize a preprocessor statement: Any line that starts with '#'."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["{", "  if (*skipwhite(s) == '#')", "    return TRUE;"], "readability/braces"]
["src/nvim/indent_c.c", ["  if (*skipwhite(s) == '#')", "    return TRUE;", "  return FALSE;"], "readability/bool"]
["src/nvim/indent_c.c", ["    return TRUE;", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/indent_c.c", ["    if (cin_ispreproc(line)) {", "      retval = TRUE;", "      *lnump = lnum;"], "readability/bool"]
["src/nvim/indent_c.c", ["    }", "    if (lnum == 1)", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["    line = ml_get(--lnum);", "    if (*line == NUL || line[STRLEN(line) - 1] != '\\\\')", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize the start of a C or C++ comment."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize the start of a \"//\" comment."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize a line that starts with '{' or '}', or ends with ';', ',', '{' or"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["static char_u", "cin_isterminated (", "    char_u *s,"], "whitespace/parens"]
["src/nvim/indent_c.c", ["  unsigned n_open = 0;", "  int is_else = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "  if (*s == '{' || (*s == '}' && !cin_iselse(s)))", "    found_start = *s;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "  if (!found_start)", "    is_else = cin_iselse(s);"], "readability/braces"]
["src/nvim/indent_c.c", ["    s = skip_string(cin_skipcomment(s));", "    if (*s == '}' && n_open > 0)", "      --n_open;"], "readability/braces"]
["src/nvim/indent_c.c", ["    if (*s == '}' && n_open > 0)", "      --n_open;", "    if ((!is_else || n_open == 0)"], "readability/increment"]
["src/nvim/indent_c.c", ["      --n_open;", "    if ((!is_else || n_open == 0)", "        && (*s == ';' || *s == '}' || (incl_comma && *s == ','))"], "readability/braces"]
["src/nvim/indent_c.c", ["      return *s;", "    else if (*s == '{') {", "      if (incl_open && cin_nocode(s + 1))"], "readability/braces"]
["src/nvim/indent_c.c", ["    else if (*s == '{') {", "      if (incl_open && cin_nocode(s + 1))", "        return *s;"], "readability/braces"]
["src/nvim/indent_c.c", ["        return *s;", "      else", "        ++n_open;"], "readability/braces"]
["src/nvim/indent_c.c", ["      else", "        ++n_open;", "    }"], "readability/increment"]
["src/nvim/indent_c.c", ["", "    if (*s)", "      s++;"], "readability/braces"]
["src/nvim/indent_c.c", ["  pos_T       *trypos;", "  int just_started = TRUE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "  if (sp == NULL)", "    s = ml_get(lnum);"], "readability/braces"]
["src/nvim/indent_c.c", ["    s = ml_get(lnum);", "  else", "    s = *sp;"], "readability/braces"]
["src/nvim/indent_c.c", ["    if (*s == ')' && cin_nocode(s + 1)) {", "      /* ')' at the end: may have found a match", "       * Check for he previous line not to end in a backslash:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      s = ml_get(lnum);", "      if (*s == NUL || s[STRLEN(s) - 1] != '\\\\')", "        retval = TRUE;"], "readability/braces"]
["src/nvim/indent_c.c", ["      if (*s == NUL || s[STRLEN(s) - 1] != '\\\\')", "        retval = TRUE;", "      goto done;"], "readability/bool"]
["src/nvim/indent_c.c", ["", "      /* ',' at the end: continue looking in the next line.", "       * At the end: check for ',' in the next line, for this style:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      for (;; ) {", "        if (lnum >= curbuf->b_ml.ml_line_count)", "          break;"], "readability/braces"]
["src/nvim/indent_c.c", ["        s = ml_get(++lnum);", "        if (!cin_ispreproc(s))", "          break;"], "readability/braces"]
["src/nvim/indent_c.c", ["      }", "      if (lnum >= curbuf->b_ml.ml_line_count)", "        break;"], "readability/braces"]
["src/nvim/indent_c.c", ["        break;", "      /* Require a comma at end of the line or a comma or ')' at the", "       * start of next line. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      s = skipwhite(s);", "      if (!just_started && (!comma && *s != ',' && *s != ')'))", "        break;"], "readability/braces"]
["src/nvim/indent_c.c", ["done:", "  if (lnum != first_lnum && sp != NULL)", "    *sp = ml_get(first_lnum);"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Check if this is a \"while\" that should have a matching \"do\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  pos_T       *trypos;", "  int retval = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["    }", "    if ((trypos = findmatchlimit(NULL, 0, 0,", "             curbuf->b_ind_maxparen)) != NULL"], "readability/braces"]
["src/nvim/indent_c.c", ["    if ((trypos = findmatchlimit(NULL, 0, 0,", "             curbuf->b_ind_maxparen)) != NULL", "        && *cin_skipcomment(ml_get_pos(trypos) + 1) == ';')"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["        && *cin_skipcomment(ml_get_pos(trypos) + 1) == ';')", "      retval = TRUE;", "    curwin->w_cursor = cursor_save;"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Check whether in \"p\" there is an \"if\", \"for\" or \"while\" before \"*poffset\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  if (offset-- < 2)", "    return 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["    return 0;", "  while (offset > 2 && ascii_iswhite(line[offset]))", "    --offset;"], "readability/braces"]
["src/nvim/indent_c.c", ["  while (offset > 2 && ascii_iswhite(line[offset]))", "    --offset;", ""], "readability/increment"]
["src/nvim/indent_c.c", ["  offset -= 1;", "  if (!STRNCMP(line + offset, \"if\", 2))", "    goto probablyFound;"], "readability/braces"]
["src/nvim/indent_c.c", ["    offset -= 1;", "    if (!STRNCMP(line + offset, \"for\", 3))", "      goto probablyFound;"], "readability/braces"]
["src/nvim/indent_c.c", ["      offset -= 2;", "      if (!STRNCMP(line + offset, \"while\", 5))", "        goto probablyFound;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Return TRUE if we are at the end of a do-while."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      if (*s == ';' && cin_nocode(s + 1)) {", "        /* Found \");\" at end of the line, now check there is \"while\"", "         * before the matching '('.  XXX */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            curwin->w_cursor.lnum = trypos->lnum;", "            return TRUE;", "          }"], "readability/bool"]
["src/nvim/indent_c.c", ["    }", "    if (*p != NUL)", "      ++p;"], "readability/braces"]
["src/nvim/indent_c.c", ["    if (*p != NUL)", "      ++p;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Find the position of a C++ base-class declaration or"], "readability/old_style_comment"]
["src/nvim/indent_c.c", [" */", "static int cin_is_cpp_baseclass(cpp_baseclass_cache_T *cached) {", "  lpos_T *pos = &cached->lpos;  // find position"], "readability/braces"]
["src/nvim/indent_c.c", ["  s = cin_skipcomment(s);", "  if (*s == NUL)", "    return FALSE;"], "readability/braces"]
["src/nvim/indent_c.c", ["  if (*s == NUL)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "  cpp_base_class = lookfor_ctor_init = class_or_struct = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "  /* Search for a line starting with '#', empty, ending in ';' or containing", "   * '{' or '}' and start below it.  This handles the following situations:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    s = skipwhite(line);", "    if (*s == '#' || *s == NUL)", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["      s = cin_skipcomment(s);", "      if (*s == '{' || *s == '}'", "          || (*s == ';' && cin_nocode(s + 1)))"], "readability/braces"]
["src/nvim/indent_c.c", ["        break;", "      if (*s != NUL)", "        ++s;"], "readability/braces"]
["src/nvim/indent_c.c", ["      if (*s != NUL)", "        ++s;", "    }"], "readability/increment"]
["src/nvim/indent_c.c", ["    }", "    if (*s != NUL)", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["      break;", "    --lnum;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["      s = cin_skipcomment(line);", "      if (*s == NUL)", "        continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    if (s[0] == '\"' || (s[0] == 'R' && s[1] == '\"'))", "      s = skip_string(s) + 1;"], "readability/braces"]
["src/nvim/indent_c.c", ["      s = skip_string(s) + 1;", "    else if (s[0] == ':') {", "      if (s[1] == ':') {"], "readability/braces"]
["src/nvim/indent_c.c", ["      if (s[1] == ':') {", "        /* skip double colon. It can't be a constructor", "         * initialization any more */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["         * initialization any more */", "        lookfor_ctor_init = FALSE;", "        s = cin_skipcomment(s + 2);"], "readability/bool"]
["src/nvim/indent_c.c", ["      } else if (lookfor_ctor_init || class_or_struct) {", "        /* we have something found, that looks like the start of", "         * cpp-base-class-declaration or constructor-initialization */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        s = cin_skipcomment(s + 1);", "      } else", "        s = cin_skipcomment(s + 1);"], "readability/braces"]
["src/nvim/indent_c.c", ["               || (STRNCMP(s, \"struct\", 6) == 0 && !vim_isIDc(s[6]))) {", "      class_or_struct = TRUE;", "      lookfor_ctor_init = FALSE;"], "readability/bool"]
["src/nvim/indent_c.c", ["      class_or_struct = TRUE;", "      lookfor_ctor_init = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "      if (*s == 'c')", "        s = cin_skipcomment(s + 5);"], "readability/braces"]
["src/nvim/indent_c.c", ["        s = cin_skipcomment(s + 5);", "      else", "        s = cin_skipcomment(s + 6);"], "readability/braces"]
["src/nvim/indent_c.c", ["      if (s[0] == '{' || s[0] == '}' || s[0] == ';') {", "        cpp_base_class = lookfor_ctor_init = class_or_struct = FALSE;", "      } else if (s[0] == ')') {"], "readability/bool"]
["src/nvim/indent_c.c", ["      } else if (s[0] == ')') {", "        /* Constructor-initialization is assumed if we come across", "         * something like \"):\" */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["         * something like \"):\" */", "        class_or_struct = FALSE;", "        lookfor_ctor_init = TRUE;"], "readability/bool"]
["src/nvim/indent_c.c", ["        class_or_struct = FALSE;", "        lookfor_ctor_init = TRUE;", "      } else if (s[0] == '?') {"], "readability/bool"]
["src/nvim/indent_c.c", ["  }", "  if (amount < curbuf->b_ind_cpp_baseclass)", "    amount = curbuf->b_ind_cpp_baseclass;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Return TRUE if string \"s\" ends with the string \"find\", possibly followed by"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      r = skipwhite(p + len);", "      if (ignore != NULL && STRNCMP(r, ignore, STRLEN(ignore)) == 0)", "        r = skipwhite(r + STRLEN(ignore));"], "readability/braces"]
["src/nvim/indent_c.c", ["        r = skipwhite(r + STRLEN(ignore));", "      if (cin_nocode(r))", "        return TRUE;"], "readability/braces"]
["src/nvim/indent_c.c", ["      if (cin_nocode(r))", "        return TRUE;", "    }"], "readability/bool"]
["src/nvim/indent_c.c", ["    }", "    if (*p != NUL)", "      ++p;"], "readability/braces"]
["src/nvim/indent_c.c", ["    if (*p != NUL)", "      ++p;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Return TRUE when \"s\" starts with \"word\" and then a non-ID character."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Skip strings, chars and comments until at or past \"trypos\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Find the '{' at the start of the block we are in."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        ind_maxp_wk = ind_maxparen - (int)(cursor_save.lnum", "            - trypos_wk->lnum);", "        if (ind_maxp_wk > 0) {"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["", "/*", " * Return ind_maxparen corrected for the difference in line number between the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  if (n > 0 && n < curbuf->b_ind_maxparen / 2)", "    return curbuf->b_ind_maxparen - (int)n;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Set w_cursor.col to the column number of the last unmatched ')' or '{' in"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  int i;", "  int retval = FALSE;", "  int open_count = 0;"], "readability/bool"]
["src/nvim/indent_c.c", ["        curwin->w_cursor.col = i;", "        retval = TRUE;", "      }"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Parse 'cinoptions' and set the values in \"curbuf\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /*", "   * Set the default values."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["   */", "  /* Spaces from a block's opening brace the prevailing indent for that", "   * block should be. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the edge of the line an open brace that's at the end of a", "   * line is imagined to be. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the prevailing indent for a line that is not preceded by", "   * an opening brace. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the prevailing indent a leftmost open brace should be", "   * located. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the matching open brace (real location for one at the left", "   * edge; imaginary location from one that ends a line) the matching close"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the edge of the line an open brace sitting in the leftmost", "   * column is imagined to be. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces jump labels should be shifted to the left if N is non-negative,", "   * otherwise the jump label will be put to column 1. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the class declaration indent a scope declaration label", "   * should be located. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Amount a cpp base class declaration or constructor initialization", "   * should be indented. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* additional spaces beyond the prevailing indent a continuation line", "   * should be located. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the indent of the line with an unclosed parentheses, which", "   * itself is also unclosed. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Suppress ignoring spaces from the indent of a line starting with an", "   * unclosed parentheses. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* If the opening paren is the last nonwhite character on the line, and", "   * b_ind_unclosed_wrapped is nonzero, use this indent relative to the outer"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Suppress ignoring white space when lining up with the character after", "   * an unclosed parentheses. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Indent a closing parentheses under the line start of the matching", "   * opening parentheses. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Boolean: if non-zero, use b_ind_in_comment even if there is something", "   * after the comment opener. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Handle continuation lines containing conditions of if(), for() and", "   * while(). */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        n *= sw;", "        if (divider)", "          n += (sw * fraction + divider / 2) / divider;"], "readability/braces"]
["src/nvim/indent_c.c", ["      }", "      ++p;", "    }"], "readability/increment"]
["src/nvim/indent_c.c", ["    }", "    if (l[1] == '-')", "      n = -n;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /* When adding an entry here, also update the default 'cinoptions' in", "     * doc/indent.txt, and add explanation for it! */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    }", "    if (*p == ',')", "      ++p;"], "readability/braces"]
["src/nvim/indent_c.c", ["    if (*p == ',')", "      ++p;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["", "/*", " * Return the desired indent for C code."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Get a copy of the current contents of the line.", "   * This is required, because only the most recent line obtained with"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /*", "   * In insert mode and the cursor is on a ')' truncate the line at the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["   */", "  if ((State & INSERT)", "      && curwin->w_cursor.col < (colnr_T)STRLEN(linecopy)"], "readability/braces"]
["src/nvim/indent_c.c", ["", "  /*", "   * If we are inside a raw string don't change the indent."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /*", "   * Is it a non-case label?\tThen that goes at the left margin too unless:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  if (original_line_islabel && !curbuf->b_ind_js", "           && curbuf->b_ind_jump_label < 0) {", "    amount = 0;"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["  }", "  /*", "   * If we're inside a \"//\" comment and there is a \"//\" comment in a"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  }", "  /*", "   * If we're inside a comment and not looking at the start of the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    int start_off = 0;", "    int done = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "      if (*p == ':')", "        ++p;"], "readability/braces"]
["src/nvim/indent_c.c", ["      if (*p == ':')", "        ++p;", "      (void)copy_option_part(&p, lead_end, COM_MAX_LEN, \",\");"], "readability/increment"]
["src/nvim/indent_c.c", ["      } else if (what == COM_END) {", "        /* If our line starts with the middle comment string, line it", "         * up with the comment opener per the 'comments' option. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            && STRNCMP(theline, lead_end, STRLEN(lead_end)) != 0) {", "          done = TRUE;", "          if (curwin->w_cursor.lnum > 1) {"], "readability/bool"]
["src/nvim/indent_c.c", ["          if (curwin->w_cursor.lnum > 1) {", "            /* If the start comment string matches in the previous", "             * line, use the indent of that line plus offset.  If"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            look = skipwhite(ml_get(curwin->w_cursor.lnum - 1));", "            if (STRNCMP(look, lead_start, lead_start_len) == 0)", "              amount = get_indent_lnum(curwin->w_cursor.lnum - 1);"], "readability/braces"]
["src/nvim/indent_c.c", ["              amount = get_indent_lnum(curwin->w_cursor.lnum - 1);", "            else if (STRNCMP(look, lead_middle,", "                         lead_middle_len) == 0) {"], "readability/braces"]
["src/nvim/indent_c.c", ["            else if (STRNCMP(look, lead_middle,", "                         lead_middle_len) == 0) {", "              amount = get_indent_lnum(curwin->w_cursor.lnum - 1);"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["            } else if (STRNCMP(ml_get(comment_pos->lnum) + comment_pos->col,", "                        lead_start, lead_start_len) != 0) {", "              /* If the start comment string doesn't match with the"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["                        lead_start, lead_start_len) != 0) {", "              /* If the start comment string doesn't match with the", "               * start of the comment, skip this entry. XXX */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          }", "          if (start_off != 0)", "            amount += start_off;"], "readability/braces"]
["src/nvim/indent_c.c", ["            amount += start_off;", "          else if (start_align == COM_RIGHT)", "            amount += vim_strsize(lead_start)"], "readability/braces"]
["src/nvim/indent_c.c", ["", "        /* If our line starts with the end comment string, line it up", "         * with the middle comment */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /* If our line starts with an asterisk, line up with the", "     * asterisk in the comment opener; otherwise, line up"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["     */", "    if (done)", "      ;"], "readability/braces"]
["src/nvim/indent_c.c", ["    if (done)", "      ;", "    else if (theline[0] == '*')"], "whitespace/semicolon"]
["src/nvim/indent_c.c", ["      ;", "    else if (theline[0] == '*')", "      amount += 1;"], "readability/braces"]
["src/nvim/indent_c.c", ["      amount += 1;", "    else {", "      /*"], "readability/braces"]
["src/nvim/indent_c.c", ["      amount += 1;", "    else {", "      /*"], "readability/braces"]
["src/nvim/indent_c.c", ["    else {", "      /*", "       * If we are more than one line away from the comment opener, take"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        amount = col;", "        if (curbuf->b_ind_in_comment2 || *look == NUL)", "          amount += curbuf->b_ind_in_comment;"], "readability/braces"]
["src/nvim/indent_c.c", ["  if (*skipwhite(theline) == ']'", "           && (trypos = find_match_char('[', curbuf->b_ind_maxparen)) != NULL) {", "    // align with the line containing the '['."], "whitespace/alignment"]
["src/nvim/indent_c.c", ["  if (((trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL", "            && curbuf->b_ind_java == 0)", "           || (tryposBrace = find_start_brace()) != NULL"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["            && curbuf->b_ind_java == 0)", "           || (tryposBrace = find_start_brace()) != NULL", "           || trypos != NULL) {"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["           || (tryposBrace = find_start_brace()) != NULL", "           || trypos != NULL) {", "    if (trypos != NULL && tryposBrace != NULL) {"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["    if (trypos != NULL && tryposBrace != NULL) {", "      /* Both an unmatched '(' and '{' is found.  Use the one which is", "       * closer to the current cursor position, set the other to NULL. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["       * closer to the current cursor position, set the other to NULL. */", "      if (trypos->lnum != tryposBrace->lnum", "          ? trypos->lnum < tryposBrace->lnum"], "readability/braces"]
["src/nvim/indent_c.c", ["        trypos = NULL;", "      else", "        tryposBrace = NULL;"], "readability/braces"]
["src/nvim/indent_c.c", ["      our_paren_pos = *trypos;", "      /*", "       * If the matching paren is more than one line away, use the indent of"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        amount = -1;", "        for (lnum = cur_curpos.lnum - 1; lnum > our_paren_pos.lnum; --lnum) {", "          l = skipwhite(ml_get(lnum));"], "readability/increment"]
["src/nvim/indent_c.c", ["          if ((trypos = find_match_paren(", "                   corr_ind_maxparen(&cur_curpos))) != NULL", "              && trypos->lnum == our_paren_pos.lnum"], "whitespace/indent"]
["src/nvim/indent_c.c", ["            if (theline[0] == ')') {", "              if (our_paren_pos.lnum != lnum", "                  && cur_amount > amount)"], "readability/braces"]
["src/nvim/indent_c.c", ["", "      /*", "       * Line up with line where the matching paren is. XXX"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        if (curbuf->b_ind_if_for_while) {", "          /* Look for the outermost opening parenthesis on this line", "           * and check whether it belongs to an \"if\", \"for\" or \"while\". */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "          /* Ignore a '(' in front of the line that has a match before", "           * our matching '('. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          curwin->w_cursor.col = look_col + 1;", "          if ((trypos = findmatchlimit(NULL, ')', 0,", "                   curbuf->b_ind_maxparen))"], "readability/braces"]
["src/nvim/indent_c.c", ["          if ((trypos = findmatchlimit(NULL, ')', 0,", "                   curbuf->b_ind_maxparen))", "              != NULL"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["                && ignore_paren_col == 0)) {", "          /*", "           * If we're looking at a close paren, line up right there;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                && cin_ends_in(l, (char_u *)\"(\", NULL)) {", "              /* look for opening unmatched paren, indent one level", "               * for each additional level */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              n = 1;", "              for (col = 0; col < our_paren_pos.col; ++col) {", "                switch (l[col]) {"], "readability/increment"]
["src/nvim/indent_c.c", ["                case '}': if (n > 1)", "                    --n;", "                  break;"], "readability/increment"]
["src/nvim/indent_c.c", ["              amount += n * curbuf->b_ind_unclosed_wrapped;", "            } else if (curbuf->b_ind_unclosed_whiteok)", "              our_paren_pos.col++;"], "readability/braces"]
["src/nvim/indent_c.c", ["              our_paren_pos.col++;", "            else {", "              col = our_paren_pos.col + 1;"], "readability/braces"]
["src/nvim/indent_c.c", ["              our_paren_pos.col++;", "            else {", "              col = our_paren_pos.col + 1;"], "readability/braces"]
["src/nvim/indent_c.c", ["              col = our_paren_pos.col + 1;", "              while (ascii_iswhite(l[col]))", "                col++;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "          /*", "           * Find how indented the paren is, or the character after it"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            getvcol(curwin, &our_paren_pos, &col, NULL, NULL);", "            if (cur_amount > (int)col)", "              cur_amount = col;"], "readability/braces"]
["src/nvim/indent_c.c", ["                       && *look == '(' && ignore_paren_col == 0)) {", "          if (cur_amount != MAXCOL)", "            amount = cur_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["        } else {", "          /* Add b_ind_unclosed2 for each '(' before our matching one,", "           * but ignore (void) before the line (ignore_paren_col). */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          while ((int)our_paren_pos.col > ignore_paren_col) {", "            --our_paren_pos.col;", "            switch (*ml_get_pos(&our_paren_pos)) {"], "readability/increment"]
["src/nvim/indent_c.c", ["", "          /* Use b_ind_unclosed once, when the first '(' is not inside", "           * braces */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["           * braces */", "          if (col == MAXCOL)", "            amount += curbuf->b_ind_unclosed;"], "readability/braces"]
["src/nvim/indent_c.c", ["            amount += curbuf->b_ind_unclosed;", "          else {", "            curwin->w_cursor.lnum = our_paren_pos.lnum;"], "readability/braces"]
["src/nvim/indent_c.c", ["            amount += curbuf->b_ind_unclosed;", "          else {", "            curwin->w_cursor.lnum = our_paren_pos.lnum;"], "readability/braces"]
["src/nvim/indent_c.c", ["          }", "          /*", "           * For a line starting with ')' use the minimum of the two"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["           */", "          if (cur_amount < amount)", "            amount = cur_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "      /*", "       * Now figure out how indented the line is in general."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        amount = col;", "        if (*start == '{')", "          start_brace = BRACE_IN_COL0;"], "readability/braces"]
["src/nvim/indent_c.c", ["          start_brace = BRACE_IN_COL0;", "        else", "          start_brace = BRACE_AT_START;"], "readability/braces"]
["src/nvim/indent_c.c", ["        // It could have been something like", "        //\t   case 1: if (asdf &&", "        //\t\t\tldfd) {"], "whitespace/tab"]
["src/nvim/indent_c.c", ["        // It could have been something like", "        //\t   case 1: if (asdf &&", "        //\t\t\tldfd) {"], "whitespace/comments"]
["src/nvim/indent_c.c", ["        //\t   case 1: if (asdf &&", "        //\t\t\tldfd) {", "        //\t\t    }"], "whitespace/tab"]
["src/nvim/indent_c.c", ["        //\t   case 1: if (asdf &&", "        //\t\t\tldfd) {", "        //\t\t    }"], "whitespace/comments"]
["src/nvim/indent_c.c", ["        //\t\t\tldfd) {", "        //\t\t    }", "        if ((curbuf->b_ind_js || curbuf->b_ind_keep_case_label)"], "whitespace/tab"]
["src/nvim/indent_c.c", ["        //\t\t\tldfd) {", "        //\t\t    }", "        if ((curbuf->b_ind_js || curbuf->b_ind_keep_case_label)"], "whitespace/comments"]
["src/nvim/indent_c.c", ["      if (theline[0] == '}') {", "        /*", "         * they may want closing braces to line up with something"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      } else {", "        /*", "         * If we're looking at an \"else\", try to find an \"if\""], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "        /*", "         * We get here if we are not on an \"while-of-do\" or \"else\" (or"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "        /*", "         * if the '{' is  _really_ at the left margin, use the imaginary"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            amount -= curbuf->b_ind_open_extra;", "            if (amount < 0)", "              amount = 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "        lookfor_break = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "          /*", "           * If we went all the way back to the start of our scope, line"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                  < ourscope - curbuf->b_ind_maxparen) {", "                /* nothing found (abuse curbuf->b_ind_maxparen as", "                 * limit) assume terminated line (i.e. a variable"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                 * initialization) */", "                if (cont_amount > 0)", "                  amount = cont_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["                  amount = cont_amount;", "                else if (!curbuf->b_ind_js)", "                  amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "              /*", "               * If we're in a comment or raw string now, skip to"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              if (cin_nocode(l))", "                continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "              terminated = cin_isterminated(l, FALSE, TRUE);", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "              /*", "               * If we are at top level and the line looks like a"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                  || !cin_isfuncdecl(&l, curwin->w_cursor.lnum, 0)) {", "                /* if the line is terminated with another ','", "                 * it is a continued variable initialization."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                 */", "                if (terminated == ',')", "                  break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "                /* if it is an enum declaration or an assignment,", "                 * we are done."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                 */", "                if (terminated != ';' && cin_isinit())", "                  break;"], "readability/braces"]
["src/nvim/indent_c.c", ["                trypos = NULL;", "                if (find_last_paren(l, '(', ')'))", "                  trypos = find_match_paren("], "readability/braces"]
["src/nvim/indent_c.c", ["", "                if (trypos == NULL && find_last_paren(l, '{', '}'))", "                  trypos = find_start_brace();"], "readability/braces"]
["src/nvim/indent_c.c", ["", "              /* it's a variable declaration, add indentation", "               * like in"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["               */", "              if (cont_amount > 0)", "                amount = cont_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["                amount = cont_amount;", "              else", "                amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["            } else if (lookfor == LOOKFOR_UNTERM) {", "              if (cont_amount > 0)", "                amount = cont_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["                amount = cont_amount;", "              else", "                amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["              if (lookfor_cpp_namespace) {", "                /*", "                 * Looking for C++ namespace, need to look further"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                 */", "                if (curwin->w_cursor.lnum == ourscope)", "                  continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "                if (curwin->w_cursor.lnum == 0", "                    || curwin->w_cursor.lnum"], "readability/braces"]
["src/nvim/indent_c.c", ["", "                /* If we're in a comment or raw string now, skip", "                 * to the start of it. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "                if (cin_nocode(l))", "                  continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "          /*", "           * If this is a switch() label, may line up relative to that."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          if (iscase || cin_isscopedecl(l)) {", "            /* we are only looking for cpp base class", "             * declaration/initialization any longer */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["             * declaration/initialization any longer */", "            if (lookfor == LOOKFOR_CPP_BASECLASS)", "              break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "            /* When looking for a \"do\" we are not interested in", "             * labels. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["             * labels. */", "            if (whilelevel > 0)", "              continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "            /*", "             *\tcase xx:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                || lookfor == LOOKFOR_ENUM_OR_INIT) {", "              if (cont_amount > 0)", "                amount = cont_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["                amount = cont_amount;", "              else", "                amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "            /*", "             *\t case xx: if (cond)\t    <- line up with this if"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            if (lookfor == LOOKFOR_TERM) {", "              if (n)", "                amount = n;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "              if (!lookfor_break)", "                break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "            /*", "             *\t case xx: x = x + 1;\t    <- line up with this x"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              if (l != NULL && cin_is_cinword(l)) {", "                if (theline[0] == '{')", "                  amount += curbuf->b_ind_open_extra;"], "readability/braces"]
["src/nvim/indent_c.c", ["                  amount += curbuf->b_ind_open_extra;", "                else", "                  amount += curbuf->b_ind_level"], "readability/braces"]
["src/nvim/indent_c.c", ["", "            /*", "             * Try to get the indent of a statement before the switch"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "          /*", "           * Looking for a switch() label or C++ scope declaration,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "          /*", "           * Ignore jump labels with nothing after them."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            l = after_label(get_cursor_line_ptr());", "            if (l == NULL || cin_nocode(l))", "              continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "          /*", "           * Ignore #defines, #if, etc."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            if (lookfor == LOOKFOR_UNTERM) {", "              if (cont_amount > 0)", "                amount = cont_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["                amount = cont_amount;", "              else", "                amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["          } else if (lookfor == LOOKFOR_CPP_BASECLASS) {", "            /* only look, whether there is a cpp base class", "             * declaration or initialization before the opening brace."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["             */", "            if (cin_isterminated(l, TRUE, FALSE))", "              break;"], "readability/braces"]
["src/nvim/indent_c.c", ["             */", "            if (cin_isterminated(l, TRUE, FALSE))", "              break;"], "readability/bool"]
["src/nvim/indent_c.c", ["              break;", "            else", "              continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "          /*", "           * What happens next depends on the line being terminated."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["           */", "          terminated = cin_isterminated(l, FALSE, TRUE);", ""], "readability/bool"]
["src/nvim/indent_c.c", ["          if (js_cur_has_key) {", "            js_cur_has_key = false; // only check the first line", "            if (curbuf->b_ind_js && terminated == ',') {"], "whitespace/comments"]
["src/nvim/indent_c.c", ["            // that starts it so we can get the right prevailing indent", "            //\t   if ( foo &&", "            //\t\t    bar )"], "whitespace/tab"]
["src/nvim/indent_c.c", ["            // that starts it so we can get the right prevailing indent", "            //\t   if ( foo &&", "            //\t\t    bar )"], "whitespace/comments"]
["src/nvim/indent_c.c", ["            //\t   if ( foo &&", "            //\t\t    bar )", ""], "whitespace/tab"]
["src/nvim/indent_c.c", ["            //\t   if ( foo &&", "            //\t\t    bar )", ""], "whitespace/comments"]
["src/nvim/indent_c.c", ["            // braces.", "            if (trypos == NULL && terminated == ','", "                && find_last_paren(l, '{', '}'))"], "readability/braces"]
["src/nvim/indent_c.c", ["            if (trypos != NULL) {", "              /*", "               * Check if we are on a case label now.  This is"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Skip over continuation lines to find the one to get the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                l = ml_get(curwin->w_cursor.lnum - 1);", "                if (*l == NUL || l[STRLEN(l) - 1] != '\\\\')", "                  break;"], "readability/braces"]
["src/nvim/indent_c.c", ["                  break;", "                --curwin->w_cursor.lnum;", "                curwin->w_cursor.col = 0;"], "readability/increment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Get indent and pointer to text for current line,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            }", "            /*", "             * If this is just above the line we are indenting, and it"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              amount = cur_amount;", "              /*", "               * Only add b_ind_open_extra when the current line"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["               */", "              if (*skipwhite(l) != '{')", "                amount += curbuf->b_ind_open_extra;"], "readability/braces"]
["src/nvim/indent_c.c", ["              if (curbuf->b_ind_cpp_baseclass && !curbuf->b_ind_js) {", "                /* have to look back, whether it is a cpp base", "                 * class declaration or initialization */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Check if we are after an \"if\", \"while\", etc."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            if (cin_is_cinword(l) || cin_iselse(skipwhite(l))) {", "              /*", "               * Found an unterminated line after an if (), line up"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                  || lookfor == LOOKFOR_ENUM_OR_INIT) {", "                if (cont_amount > 0)", "                  amount = cont_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["                  amount = cont_amount;", "                else", "                  amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "              /*", "               * If this is just above the line we are indenting, we"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              amount = cur_amount;", "              if (theline[0] == '{')", "                amount += curbuf->b_ind_open_extra;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "              /*", "               * Special trick: when expecting the while () after a"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              if (cin_isdo(l)) {", "                if (whilelevel == 0)", "                  break;"], "readability/braces"]
["src/nvim/indent_c.c", ["                  break;", "                --whilelevel;", "              }"], "readability/increment"]
["src/nvim/indent_c.c", ["", "              /*", "               * When searching for a terminated line, don't use the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              if (cin_iselse(l) && whilelevel == 0) {", "                /* If we're looking at \"} else\", let's make sure we", "                 * find the opening brace of the enclosing scope,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                 * not the one from \"if () {\". */", "                if (*l == '}')", "                  curwin->w_cursor.col ="], "readability/braces"]
["src/nvim/indent_c.c", ["", "                if ((trypos = find_start_brace()) == NULL", "                    || find_match(LOOKFOR_IF, trypos->lnum)"], "readability/braces"]
["src/nvim/indent_c.c", ["            }", "            /*", "             * If we're below an unterminated line that is not an"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["             */", "            else {", "              /*"], "whitespace/newline"]
["src/nvim/indent_c.c", ["             */", "            else {", "              /*"], "readability/braces"]
["src/nvim/indent_c.c", ["            else {", "              /*", "               * Found two unterminated lines on a row, line up with"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              if (lookfor == LOOKFOR_ENUM_OR_INIT) {", "                /* Found two lines ending in ',', lineup with the", "                 * lowest one, but check for cpp base class"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                if (terminated == ',') {", "                  if (curbuf->b_ind_cpp_baseclass == 0)", "                    break;"], "readability/braces"]
["src/nvim/indent_c.c", ["                    // XXX", "                    cont_amount = cin_get_equal_amount( curwin->w_cursor.lnum);", "                  }"], "whitespace/parens"]
["src/nvim/indent_c.c", ["          }", "          /*", "           * Check if we are after a while (cond);"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["           */", "          else if (cin_iswhileofdo_end(terminated)) {  // XXX", "            /*"], "whitespace/newline"]
["src/nvim/indent_c.c", ["          else if (cin_iswhileofdo_end(terminated)) {  // XXX", "            /*", "             * Found an unterminated line after a while ();, line up"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                || lookfor == LOOKFOR_ENUM_OR_INIT) {", "              if (cont_amount > 0)", "                amount = cont_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["                amount = cont_amount;", "              else", "                amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["            }", "            ++whilelevel;", "          }"], "readability/increment"]
["src/nvim/indent_c.c", ["          }", "          /*", "           * We are after a \"normal\" statement."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["           */", "          else {", "            /*"], "whitespace/newline"]
["src/nvim/indent_c.c", ["           */", "          else {", "            /*"], "readability/braces"]
["src/nvim/indent_c.c", ["          else {", "            /*", "             * Skip single break line, if before a switch label. It"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Handle \"do {\" line."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Found a terminated line above an unterminated line. Add"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                || lookfor == LOOKFOR_ENUM_OR_INIT) {", "              if (cont_amount > 0)", "                amount = cont_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["                amount = cont_amount;", "              else", "                amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "            /*", "             * Found a terminated line above a terminated line or \"if\""], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            if (lookfor == LOOKFOR_TERM) {", "              if (!lookfor_break && whilelevel == 0)", "                break;"], "readability/braces"]
["src/nvim/indent_c.c", ["            }", "            /*", "             * First line above the one we're indenting is terminated."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["             */", "            else {", "              /*"], "whitespace/newline"]
["src/nvim/indent_c.c", ["             */", "            else {", "              /*"], "readability/braces"]
["src/nvim/indent_c.c", ["            else {", "              /*", "               * position the cursor over the rightmost paren, so"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                  && (trypos = find_match_paren(", "                          curbuf->b_ind_maxparen)) != NULL) {", "                /*"], "whitespace/indent"]
["src/nvim/indent_c.c", ["                  && (trypos = find_match_paren(", "                          curbuf->b_ind_maxparen)) != NULL) {", "                /*"], "whitespace/indent"]
["src/nvim/indent_c.c", ["                          curbuf->b_ind_maxparen)) != NULL) {", "                /*", "                 * Check if we are on a case label now.  This is"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              /* When aligning with the case statement, don't align", "               * with a statement after it."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              /*", "               * Get indent and pointer to text for current line,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              if (theline[0] == '{')", "                amount += curbuf->b_ind_open_extra;"], "readability/braces"]
["src/nvim/indent_c.c", ["              l = skipwhite(l);", "              if (*l == '{')", "                amount -= curbuf->b_ind_open_extra;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "              /*", "               * When a terminated line starts with \"else\" skip to"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                  && whilelevel == 0) {", "                if ((trypos = find_start_brace()) == NULL", "                    || find_match(LOOKFOR_IF, trypos->lnum)"], "readability/braces"]
["src/nvim/indent_c.c", ["", "              /*", "               * If we're at the end of a block, skip to the start of"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                l = cin_skipcomment(get_cursor_line_ptr());", "                if (*l == '}' || !cin_iselse(l))", "                  goto term_again;"], "readability/braces"]
["src/nvim/indent_c.c", ["                  goto term_again;", "                ++curwin->w_cursor.lnum;", "                curwin->w_cursor.col = 0;"], "readability/increment"]
["src/nvim/indent_c.c", ["  }", "  /*", "   * If the NEXT line is a function declaration, the current"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  if (cur_curpos.lnum < curbuf->b_ml.ml_line_count", "          && !cin_nocode(theline)", "          && vim_strchr(theline, '{') == NULL"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["          && !cin_nocode(theline)", "          && vim_strchr(theline, '{') == NULL", "          && vim_strchr(theline, '}') == NULL"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["          && vim_strchr(theline, '{') == NULL", "          && vim_strchr(theline, '}') == NULL", "          && !cin_ends_in(theline, (char_u *)\":\", NULL)"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["          && vim_strchr(theline, '}') == NULL", "          && !cin_ends_in(theline, (char_u *)\":\", NULL)", "          && !cin_ends_in(theline, (char_u *)\",\", NULL)"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["          && !cin_ends_in(theline, (char_u *)\":\", NULL)", "          && !cin_ends_in(theline, (char_u *)\",\", NULL)", "          && cin_isfuncdecl(NULL, cur_curpos.lnum + 1,"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["          && !cin_ends_in(theline, (char_u *)\",\", NULL)", "          && cin_isfuncdecl(NULL, cur_curpos.lnum + 1,", "              cur_curpos.lnum + 1)"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["          && cin_isfuncdecl(NULL, cur_curpos.lnum + 1,", "              cur_curpos.lnum + 1)", "          && !cin_isterminated(theline, false, true)) {"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["              cur_curpos.lnum + 1)", "          && !cin_isterminated(theline, false, true)) {", "    amount = curbuf->b_ind_func_type;"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["          && cin_isfuncdecl(NULL, cur_curpos.lnum + 1,", "              cur_curpos.lnum + 1)", "          && !cin_isterminated(theline, false, true)) {"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["", "    if (cin_nocode(l))", "      continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * If the previous line ends in ',', use one level of"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "      /* For a line ending in ',' that is a continuation line go", "       * back to the first line with a backslash:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        l = ml_get(curwin->w_cursor.lnum - 1);", "        if (*l == NUL || l[STRLEN(l) - 1] != '\\\\')", "          break;"], "readability/braces"]
["src/nvim/indent_c.c", ["          break;", "        --curwin->w_cursor.lnum;", "        curwin->w_cursor.col = 0;"], "readability/increment"]
["src/nvim/indent_c.c", ["", "      if (amount == 0)", "        amount = cin_first_id_amount();"], "readability/braces"]
["src/nvim/indent_c.c", ["        amount = cin_first_id_amount();", "      if (amount == 0)", "        amount = ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * If the line looks like a function declaration, and we're"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * Finding the closing '}' of a previous function.  Put"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["     */", "    if (*skipwhite(l) == '}')", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*\t\t\t    (matching {)", "     * If the previous line ends on '};' (maybe followed by"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["     */", "    if (cin_ends_in(l, (char_u *)\"};\", NULL))", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * Find a line only has a semicolon that belongs to a previous"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      }", "      if (curwin->w_cursor.lnum > 0", "          && cin_ends_in(look, (char_u *)\"}\", NULL))"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * If the PREVIOUS line is a function declaration, the current"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * If the previous line ends in ';' and the line before the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      l = ml_get(curwin->w_cursor.lnum - 1);", "      if (cin_ends_in(l, (char_u *)\",\", NULL)", "          || (*l != NUL && l[STRLEN(l) - 1] == '\\\\'))"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * Doesn't look like anything interesting -- so just"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    if ((trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL)", "      curwin->w_cursor = *trypos;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "  /* add extra indent if the previous line ended in a backslash:", "   *\t      \"asdfasdf\\"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      cur_amount = cin_get_equal_amount(cur_curpos.lnum - 1);", "      if (cur_amount > 0)", "        amount = cur_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["        amount = cur_amount;", "      else if (cur_amount == 0)", "        amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["theend:", "  if (amount < 0)", "    amount = 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["  return amount;", "}", ""], "readability/fn_size"]
["src/nvim/indent_c.c", ["  if (lookfor == LOOKFOR_IF) {", "    elselevel = 1;", "    whilelevel = 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["  } else {", "    elselevel = 0;", "    whilelevel = 1;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * if we've gone outside the braces entirely,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * and if the brace enclosing this is further"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["     */", "    if (theirscope->lnum < ourscope)", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * and if they're enclosed in a *deeper* brace,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["     */", "    if (theirscope->lnum > ourscope)", "      continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * if it was an \"else\" (that's not an \"else if\")"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      mightbeif = cin_skipcomment(look + 4);", "      if (!cin_isif(mightbeif))", "        ++elselevel;"], "readability/braces"]
["src/nvim/indent_c.c", ["      if (!cin_isif(mightbeif))", "        ++elselevel;", "      continue;"], "readability/increment"]
["src/nvim/indent_c.c", ["", "    /*", "     * if it was a \"while\" then we need to go back to"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    if (cin_iswhileofdo(look, curwin->w_cursor.lnum)) {", "      ++whilelevel;", "      continue;"], "readability/increment"]
["src/nvim/indent_c.c", ["    if (cin_isif(look)) {", "      elselevel--;", "      /*"], "readability/braces"]
["src/nvim/indent_c.c", ["      elselevel--;", "      /*", "       * When looking for an \"if\" ignore \"while\"s that"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["       */", "      if (elselevel == 0 && lookfor == LOOKFOR_IF)", "        whilelevel = 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * if we've used up all the elses, then"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Do C or expression indenting on the current line."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["{", "  if (*curbuf->b_p_inde != NUL)", "    fixthisline(get_expr_indent);"], "readability/braces"]
["src/nvim/indent_c.c", ["    fixthisline(get_expr_indent);", "  else", "    fixthisline(get_c_indent);"], "readability/braces"]
