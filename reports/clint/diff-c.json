["src/nvim/diff.c", ["{", "", "  if (!win->w_p_diff) {"], "whitespace/blank_line"]
["src/nvim/diff.c", ["  int i;", "  for (i = 0; i < DB_COUNT; ++i) {", "    if (curtab->tp_diffbuf[i] == NULL) {"], "readability/increment"]
["src/nvim/diff.c", ["  int idx;", "  for (idx = 0; idx < DB_COUNT; ++idx) {", "    if (curtab->tp_diffbuf[idx] == buf) {"], "readability/increment"]
["src/nvim/diff.c", ["  int idx;", "  for (idx = 0; idx < DB_COUNT; ++idx) {", "    if (tp->tp_diffbuf[idx] == buf) {"], "readability/increment"]
["src/nvim/diff.c", ["  linenr_T last;", "  linenr_T lnum_deleted = line1; // lnum of remaining deletion", "  int n;"], "whitespace/comments"]
["src/nvim/diff.c", ["      int i;", "      for (i = 0; i < DB_COUNT; ++i) {", "        if ((tp->tp_diffbuf[i] != NULL) && (i != idx)) {"], "readability/increment"]
["src/nvim/diff.c", ["          int i;", "          for (i = 0; i < DB_COUNT; ++i) {", "            if ((tp->tp_diffbuf[i] != NULL) && (i != idx)) {"], "readability/increment"]
["src/nvim/diff.c", ["          //", "          // TODO: also check for equal lines in the middle and perhaps split", "          // the block."], "readability/todo"]
["src/nvim/diff.c", ["      int i;", "      for (i = 0; i < DB_COUNT; ++i) {", "        if (tp->tp_diffbuf[i] != NULL) {"], "readability/increment"]
["src/nvim/diff.c", ["    int i;", "    for (i = 0; i < DB_COUNT; ++i) {", "      if ((tp->tp_diffbuf[i] != NULL) && (dp->df_count[i] != 0)) {"], "readability/increment"]
["src/nvim/diff.c", ["/// @return The new diff block.", "static diff_T* diff_alloc_new(tabpage_T *tp, diff_T *dprev, diff_T *dp)", "{"], "whitespace/operators"]
["src/nvim/diff.c", ["  int i_org;", "  for (i_org = 0; i_org < DB_COUNT; ++i_org) {", "    if (tp->tp_diffbuf[i_org] != NULL) {"], "readability/increment"]
["src/nvim/diff.c", ["      int i_new;", "      for (i_new = i_org + 1; i_new < DB_COUNT; ++i_new) {", "        if (tp->tp_diffbuf[i_new] == NULL) {"], "readability/increment"]
["src/nvim/diff.c", ["      // Line matched in all buffers, remove it from the diff.", "      for (i_new = i_org; i_new < DB_COUNT; ++i_new) {", "        if (tp->tp_diffbuf[i_new] != NULL) {"], "readability/increment"]
["src/nvim/diff.c", ["  int i;", "  for (i = 0; i < DB_COUNT; ++i) {", "    if (tp->tp_diffbuf[i] != NULL) {"], "readability/increment"]
["src/nvim/diff.c", ["  int idx_orig;", "  for (idx_orig = 0; idx_orig < DB_COUNT; ++idx_orig) {", "    if (curtab->tp_diffbuf[idx_orig] != NULL) {"], "readability/increment"]
["src/nvim/diff.c", ["  int idx_new;", "  for (idx_new = idx_orig + 1; idx_new < DB_COUNT; ++idx_new) {", "    if (curtab->tp_diffbuf[idx_new] != NULL) {"], "readability/increment"]
["src/nvim/diff.c", ["                 tmp_orig, tmp_new);", "    append_redir(cmd, len, (char *) p_srr, tmp_diff);", "    block_autocmds();  // Avoid ShellCmdPost stuff"], "whitespace/cast"]
["src/nvim/diff.c", ["    block_autocmds();  // Avoid ShellCmdPost stuff", "    (void)call_shell((char_u *) cmd,", "                     kShellOptFilter | kShellOptSilent | kShellOptDoOut,"], "whitespace/cast"]
["src/nvim/diff.c", ["      if (off > 0) {", "        for (i = idx_orig; i < idx_new; ++i) {", "          if (curtab->tp_diffbuf[i] != NULL) {"], "readability/increment"]
["src/nvim/diff.c", ["", "      for (i = idx_orig; i < idx_new; ++i) {", "        if (curtab->tp_diffbuf[i] != NULL) {"], "readability/increment"]
["src/nvim/diff.c", ["      // already.", "      for (i = idx_orig + 1; i < idx_new; ++i) {", "        if (curtab->tp_diffbuf[i] != NULL) {"], "readability/increment"]
["src/nvim/diff.c", ["{", "  int idx; // index in tp_diffbuf[] for this buffer", "  diff_T *dp;"], "whitespace/comments"]
["src/nvim/diff.c", ["", "    for (i = 0; i < DB_COUNT; ++i) {", "      if ((i != idx) && (curtab->tp_diffbuf[i] != NULL)) {"], "readability/increment"]
["src/nvim/diff.c", ["      // in some buffers, deleted in others, but not changed.", "      for (i = 0; i < DB_COUNT; ++i) {", "        if ((i != idx)"], "readability/increment"]
["src/nvim/diff.c", ["  maxcount = 0;", "  for (i = 0; i < DB_COUNT; ++i) {", "    if ((curtab->tp_diffbuf[i] != NULL) && (dp->df_count[i] > maxcount)) {"], "readability/increment"]
["src/nvim/diff.c", ["", "      for (i = 0; i < DB_COUNT; ++i) {", "        if ((curtab->tp_diffbuf[i] != NULL) && (max_count < dp->df_count[i])) {"], "readability/increment"]
["src/nvim/diff.c", ["    if (*p == ',') {", "      ++p;", "    }"], "readability/increment"]
["src/nvim/diff.c", ["  int i;", "  for (i = 0; i < DB_COUNT; ++i) {", "    if ((curtab->tp_diffbuf[i] != NULL) && (i != idx)) {"], "readability/increment"]
["src/nvim/diff.c", ["  int i;", "  for (i = 0; i < DB_COUNT; ++i) {", "    if (curtab->tp_diffbuf[i] == wp->w_buffer) {"], "readability/increment"]
["src/nvim/diff.c", ["  } else {", "    vim_snprintf(buf, 30, \"%zu\", count);", "    ea.arg = (char_u *)buf;"], "runtime/printf"]
["src/nvim/diff.c", ["    // No argument: Find the other buffer in the list of diff buffers.", "    for (idx_other = 0; idx_other < DB_COUNT; ++idx_other) {", "      if ((curtab->tp_diffbuf[idx_other] != curbuf)"], "readability/increment"]
["src/nvim/diff.c", ["    // Check that there isn't a third buffer in the list", "    for (i = idx_other + 1; i < DB_COUNT; ++i) {", "      if ((curtab->tp_diffbuf[i] != curbuf)"], "readability/increment"]
["src/nvim/diff.c", ["          && ((eap->cmdidx != CMD_diffput)", "            || MODIFIABLE(curtab->tp_diffbuf[i]))) {", "        EMSG(_(\"E101: More than two buffers in diff mode, don't know \""], "whitespace/alignment"]
["src/nvim/diff.c", ["          && ((eap->cmdidx != CMD_diffput)", "            || MODIFIABLE(curtab->tp_diffbuf[i]))) {", "        EMSG(_(\"E101: More than two buffers in diff mode, don't know \""], "whitespace/alignment"]
["src/nvim/diff.c", ["", "    for (i = 0; ascii_isdigit(eap->arg[i]) && eap->arg + i < p; ++i) {", "    }"], "readability/increment"]
["src/nvim/diff.c", ["        && ((eap->line1 == 1) || (diff_check(curwin, eap->line1 - 1) == 0))) {", "      ++eap->line2;", "    } else if (eap->line1 > 0) {"], "readability/increment"]
["src/nvim/diff.c", ["    } else if (eap->line1 > 0) {", "      --eap->line1;", "    }"], "readability/increment"]
["src/nvim/diff.c", ["", "      for (i = 0; i < count; ++i) {", "        // remember deleting the last line of the buffer"], "readability/increment"]
["src/nvim/diff.c", ["", "      for (i = 0; i < dp->df_count[idx_from] - start_skip - end_skip; ++i) {", "        linenr_T nr = dp->df_lnum[idx_from] + start_skip + i;"], "readability/increment"]
["src/nvim/diff.c", ["        // equal in them.", "        for (i = 0; i < DB_COUNT; ++i) {", "          if ((curtab->tp_diffbuf[i] != NULL)"], "readability/increment"]
["src/nvim/diff.c", ["  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {", "    for (int i = 0; i < DB_COUNT; ++i) {", "      if ((curtab->tp_diffbuf[i] == wp->w_buffer) && (i != skip_idx)) {"], "readability/increment"]
