["src/nvim/ex_docmd.c", ["", "#define UC_BUFFER       1       /* -buffer: local to current buffer */", ""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "static garray_T ucmds = {0, 0, sizeof(ucmd_T), 4, NULL};", ""], "whitespace/braces"]
["src/nvim/ex_docmd.c", ["", "static garray_T ucmds = {0, 0, sizeof(ucmd_T), 4, NULL};", ""], "whitespace/braces"]
["src/nvim/ex_docmd.c", ["", "/* Wether a command index indicates a user command. */", "# define IS_USER_CMDIDX(idx) ((int)(idx) < 0)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/* Struct for storing a line inside a while/for loop */", "typedef struct {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["typedef struct {", "  char_u      *line;            /* command line */", "  linenr_T lnum;                /* sourcing_lnum of the line */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  char_u      *line;            /* command line */", "  linenr_T lnum;                /* sourcing_lnum of the line */", "} wcmd_T;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Structure used to store info for line position in a while or for loop."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/* Struct to save a few things while debugging.  Used in do_cmdline() only. */", "struct dbg_stuff {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Declare cmdnames[]."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "static char_u dollar_command[2] = {'$', 0};", ""], "whitespace/braces"]
["src/nvim/ex_docmd.c", ["", "static char_u dollar_command[2] = {'$', 0};", ""], "whitespace/braces"]
["src/nvim/ex_docmd.c", ["{", "  dsp->trylevel       = trylevel;             trylevel = 0;", "  dsp->force_abort    = force_abort;          force_abort = FALSE;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  dsp->trylevel       = trylevel;             trylevel = 0;", "  dsp->force_abort    = force_abort;          force_abort = FALSE;", "  dsp->caught_stack   = caught_stack;         caught_stack = NULL;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  dsp->force_abort    = force_abort;          force_abort = FALSE;", "  dsp->caught_stack   = caught_stack;         caught_stack = NULL;", "  dsp->vv_exception   = v_exception(NULL);"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  // Necessary for debugging an inactive \":catch\", \":finally\", \":endtry\".", "  dsp->did_emsg       = did_emsg;             did_emsg     = false;", "  dsp->got_int        = got_int;              got_int      = false;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  dsp->did_emsg       = did_emsg;             did_emsg     = false;", "  dsp->got_int        = got_int;              got_int      = false;", "  dsp->need_rethrow   = need_rethrow;         need_rethrow = false;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  dsp->got_int        = got_int;              got_int      = false;", "  dsp->need_rethrow   = need_rethrow;         need_rethrow = false;", "  dsp->check_cstack   = check_cstack;         check_cstack = false;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  dsp->need_rethrow   = need_rethrow;         need_rethrow = false;", "  dsp->check_cstack   = check_cstack;         check_cstack = false;", "  dsp->current_exception = current_exception; current_exception = NULL;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  dsp->check_cstack   = check_cstack;         check_cstack = false;", "  dsp->current_exception = current_exception; current_exception = NULL;", "}"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["", "  if (improved)", "    exmode_active = EXMODE_VIM;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    exmode_active = EXMODE_VIM;", "  else", "    exmode_active = EXMODE_NORMAL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /* When using \":global /pat/ visual\" and then \"Q\" we return to continue", "   * the :global command. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["   * the :global command. */", "  if (global_busy)", "    return;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  while (exmode_active) {", "    /* Check for a \":normal\" command and no more characters left. */", "    if (ex_normal_busy > 0 && typebuf.tb_len == 0) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (ex_normal_busy > 0 && typebuf.tb_len == 0) {", "      exmode_active = FALSE;", "      break;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        if (ex_pressedreturn) {", "          /* go up one line, to overwrite the \":<CR>\" line, so the", "           * output doesn't contain empty lines. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["          msg_row = prev_msg_row;", "          if (prev_msg_row == Rows - 1)", "            msg_row--;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        msg_col = 0;", "        print_line_no_prefix(curwin->w_cursor.lnum, FALSE, FALSE);", "        msg_clr_eos();"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      }", "    } else if (ex_pressedreturn && !ex_no_reprint) {  /* must be at EOF */", "      if (curbuf->b_ml.ml_flags & ML_EMPTY)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    } else if (ex_pressedreturn && !ex_no_reprint) {  /* must be at EOF */", "      if (curbuf->b_ml.ml_flags & ML_EMPTY)", "        EMSG(_(e_emptybuf));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        EMSG(_(e_emptybuf));", "      else", "        EMSG(_(\"E501: At end-of-file\"));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Execute a simple command line.  Used for translated commands like \"*\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["int do_cmdline(char_u *cmdline, LineGetter fgetline,", "               void *cookie, /* argument for fgetline() */", "               int flags)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  char_u      *next_cmdline;            /* next cmd to execute */", "  char_u      *cmdline_copy = NULL;     /* copy of cmd line */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  char_u      *next_cmdline;            /* next cmd to execute */", "  char_u      *cmdline_copy = NULL;     /* copy of cmd line */", "  int used_getline = FALSE;             /* used \"fgetline\" to obtain command */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  char_u      *cmdline_copy = NULL;     /* copy of cmd line */", "  int used_getline = FALSE;             /* used \"fgetline\" to obtain command */", "  static int recursive = 0;             /* recursive depth */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  char_u      *cmdline_copy = NULL;     /* copy of cmd line */", "  int used_getline = FALSE;             /* used \"fgetline\" to obtain command */", "  static int recursive = 0;             /* recursive depth */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  int used_getline = FALSE;             /* used \"fgetline\" to obtain command */", "  static int recursive = 0;             /* recursive depth */", "  int msg_didout_before_start = 0;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  int msg_didout_before_start = 0;", "  int count = 0;                        /* line number count */", "  int did_inc = FALSE;                  /* incremented RedrawingDisabled */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  int count = 0;                        /* line number count */", "  int did_inc = FALSE;                  /* incremented RedrawingDisabled */", "  int retval = OK;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  int count = 0;                        /* line number count */", "  int did_inc = FALSE;                  /* incremented RedrawingDisabled */", "  int retval = OK;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  int getline_is_func;", "  static int call_depth = 0;            /* recursiveness */", ""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* For every pair of do_cmdline()/do_one_cmd() calls, use an extra memory", "   * location for storing error messages to be converted to an exception."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* Inside a function use a higher nesting level. */", "  getline_is_func = getline_equal(fgetline, cookie, get_func_line);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  getline_is_func = getline_equal(fgetline, cookie, get_func_line);", "  if (getline_is_func && ex_nesting_level == func_level(real_cookie))", "    ++ex_nesting_level;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  if (getline_is_func && ex_nesting_level == func_level(real_cookie))", "    ++ex_nesting_level;", ""], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  /* Get the function or script name and the address where the next breakpoint", "   * line and the debug tick for a function or script are stored. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Initialize \"force_abort\"  and \"suppress_errthrow\" at the top level."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Continue executing command lines:"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /* stop skipping cmds for an error msg after all endif/while/for */", "    if (next_cmdline == NULL"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    /* stop skipping cmds for an error msg after all endif/while/for */", "    if (next_cmdline == NULL", "        && !force_abort"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        )", "      did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * 1. If repeating a line in a loop, get a line from lines_ga."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /* 1. If repeating, get a previous line from lines_ga. */", "    if (cstack.cs_looplevel > 0 && current_line < lines_ga.ga_len) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (cstack.cs_looplevel > 0 && current_line < lines_ga.ga_len) {", "      /* Each '|' separated command is stored separately in lines_ga, to", "       * be able to jump to it.  Don't use next_cmdline now. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "      /* Check if a function has returned or, unless it has an unclosed", "       * try conditional, aborted. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      if (getline_is_func) {", "        if (do_profiling == PROF_YES)", "          func_line_end(real_cookie);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        }", "      } else if (do_profiling == PROF_YES", "                 && getline_equal(fgetline, cookie, getsourceline))"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "      /* Check if a sourced file hit a \":finish\" command. */", "      if (source_finished(fgetline, cookie)) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "      /* If breakpoints have been added/deleted need to check for it. */", "      if (breakpoint != NULL && dbg_tick != NULL"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "      /* Did we encounter a breakpoint? */", "      if (breakpoint != NULL && *breakpoint != 0"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        dbg_breakpoint(fname, sourcing_lnum);", "        /* Find next breakpoint. */", "        *breakpoint = dbg_find_breakpoint("], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      if (do_profiling == PROF_YES) {", "        if (getline_is_func)", "          func_line_start(real_cookie);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          func_line_start(real_cookie);", "        else if (getline_equal(fgetline, cookie, getsourceline))", "          script_line_start();"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (cstack.cs_looplevel > 0) {", "      /* Inside a while/for loop we need to store the lines and use them", "       * again.  Pass a different \"fgetline\" function to do_one_cmd()"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /* 2. If no line given, get an allocated line with fgetline(). */", "    if (next_cmdline == NULL) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (next_cmdline == NULL) {", "      /*", "       * Need to set msg_didout for the first line after an \":if\","], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      }", "      used_getline = TRUE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "      /*", "       * Keep the first typed line.  Clear it when more lines are typed."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        xfree(repeat_cmdline);", "        if (count == 0)", "          repeat_cmdline = vim_strsave(next_cmdline);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          repeat_cmdline = vim_strsave(next_cmdline);", "        else", "          repeat_cmdline = NULL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    }", "    /* 3. Make a copy of the command so we can mess with it. */", "    else if (cmdline_copy == NULL) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    /* 3. Make a copy of the command so we can mess with it. */", "    else if (cmdline_copy == NULL) {", "      next_cmdline = vim_strsave(next_cmdline);"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * Save the current line when inside a \":while\" or \":for\", and when"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    }", "    did_endif = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["    if (count++ == 0) {", "      /*", "       * All output from the commands is put below each other, without"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        msg_didout_before_start = msg_didout;", "        msg_didany = FALSE;         /* no output yet */", "        msg_start();"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        msg_didout_before_start = msg_didout;", "        msg_didany = FALSE;         /* no output yet */", "        msg_start();"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        msg_start();", "        msg_scroll = TRUE;          /* put messages below each other */", "        ++no_wait_return;           /* don't wait for return until finished */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        msg_start();", "        msg_scroll = TRUE;          /* put messages below each other */", "        ++no_wait_return;           /* don't wait for return until finished */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        msg_scroll = TRUE;          /* put messages below each other */", "        ++no_wait_return;           /* don't wait for return until finished */", "        ++RedrawingDisabled;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        msg_scroll = TRUE;          /* put messages below each other */", "        ++no_wait_return;           /* don't wait for return until finished */", "        ++RedrawingDisabled;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        ++no_wait_return;           /* don't wait for return until finished */", "        ++RedrawingDisabled;", "        did_inc = TRUE;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        ++RedrawingDisabled;", "        did_inc = TRUE;", "      }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * 2. Execute one '|' separated command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    if (cmd_cookie == (void *)&cmd_loop_cookie)", "      /* Use \"current_line\" from \"cmd_loop_cookie\", it may have been"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (cmd_cookie == (void *)&cmd_loop_cookie)", "      /* Use \"current_line\" from \"cmd_loop_cookie\", it may have been", "       * incremented when defining a function. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    } else {", "      /* need to copy the command after the '|' to cmdline_copy, for the", "       * next do_one_cmd() */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /* reset did_emsg for a function that is not aborted by an error */", "    if (did_emsg && !force_abort"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    /* reset did_emsg for a function that is not aborted by an error */", "    if (did_emsg && !force_abort", "        && getline_equal(fgetline, cookie, get_func_line)"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        && !func_has_abort(real_cookie))", "      did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["    if (cstack.cs_looplevel > 0) {", "      ++current_line;", ""], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "      /*", "       * An \":endwhile\", \":endfor\" and \":continue\" is handled here."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "        /* Jump back to the matching \":while\" or \":for\".  Be careful", "         * not to use a cs_line[] from an entry that isn't a \":while\""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["          current_line = cstack.cs_line[cstack.cs_idx];", "          /* remember we jumped there */", "          cstack.cs_lflags |= CSL_HAD_LOOP;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["          cstack.cs_lflags |= CSL_HAD_LOOP;", "          line_breakcheck();                    /* check if CTRL-C typed */", ""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "          /* Check for the next breakpoint at or after the \":while\"", "           * or \":for\". */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        } else {", "          /* can only get here with \":endwhile\" or \":endfor\" */", "          if (cstack.cs_idx >= 0)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["          /* can only get here with \":endwhile\" or \":endfor\" */", "          if (cstack.cs_idx >= 0)", "            rewind_conditionals(&cstack, cstack.cs_idx - 1,"], "readability/braces"]
["src/nvim/ex_docmd.c", ["            rewind_conditionals(&cstack, cstack.cs_idx - 1,", "                CSF_WHILE | CSF_FOR, &cstack.cs_looplevel);", "        }"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["      }", "      /*", "       * For a \":while\" or \":for\" we need to remember the line number."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["       */", "      else if (cstack.cs_lflags & CSL_HAD_LOOP) {", "        cstack.cs_lflags &= ~CSL_HAD_LOOP;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * When not inside any \":while\" loop, clear remembered lines."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * A \":finally\" makes did_emsg, got_int and current_exception pending for"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /* Update global \"trylevel\" for recursive calls to do_cmdline() from", "     * within this loop. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /* Convert an interrupt to an exception if appropriate. */", "    (void)do_intthrow(&cstack);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    (void)do_intthrow(&cstack);", "", "  }"], "whitespace/blank_line"]
["src/nvim/ex_docmd.c", ["  }", "  /*", "   * Continue executing command lines when:"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["   */", "  while (!((got_int || (did_emsg && force_abort) || current_exception)", "           && cstack.cs_trylevel == 0)"], "readability/braces"]
["src/nvim/ex_docmd.c", ["             || cstack.cs_idx >= 0", "             || (flags & DOCMD_REPEAT)));", ""], "whitespace/empty_loop_body"]
["src/nvim/ex_docmd.c", ["         && !(did_emsg", "              /* Keep going when inside try/catch, so that the error can be", "               * deal with, except when it is a syntax error, it may cause"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  xfree(cmdline_copy);", "  did_emsg_syntax = FALSE;", "  GA_DEEP_CLEAR(&lines_ga, wcmd_T, FREE_WCMD);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  if (cstack.cs_idx >= 0) {", "    /*", "     * If a sourced file or executed function ran to its end, report the"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["                && !func_has_ended(real_cookie)))) {", "      if (cstack.cs_flags[cstack.cs_idx] & CSF_TRY)", "        EMSG(_(e_endtry));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        EMSG(_(e_endtry));", "      else if (cstack.cs_flags[cstack.cs_idx] & CSF_WHILE)", "        EMSG(_(e_endwhile));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        EMSG(_(e_endwhile));", "      else if (cstack.cs_flags[cstack.cs_idx] & CSF_FOR)", "        EMSG(_(e_endfor));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        EMSG(_(e_endfor));", "      else", "        EMSG(_(e_endif));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * Reset \"trylevel\" in case of a \":finish\" or \":return\" or a missing"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    do {", "      int idx = cleanup_conditionals(&cstack, 0, TRUE);", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "      if (idx >= 0)", "        --idx;              /* remove try block not in its finally clause */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      if (idx >= 0)", "        --idx;              /* remove try block not in its finally clause */", "      rewind_conditionals(&cstack, idx, CSF_WHILE | CSF_FOR,"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      if (idx >= 0)", "        --idx;              /* remove try block not in its finally clause */", "      rewind_conditionals(&cstack, idx, CSF_WHILE | CSF_FOR,"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      rewind_conditionals(&cstack, idx, CSF_WHILE | CSF_FOR,", "          &cstack.cs_looplevel);", "    } while (cstack.cs_idx >= 0);"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["", "  /* If a missing \":endtry\", \":endwhile\", \":endfor\", or \":endif\" or a memory", "   * lack was reported above and the error message is to be converted to an"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  do_errthrow(&cstack, getline_equal(fgetline, cookie, get_func_line)", "      ? (char_u *)\"endfunction\" : (char_u *)NULL);", ""], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["", "      /*", "       * If the uncaught exception is a user exception, report it as an"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        vim_snprintf((char *)IObuff, IOSIZE,", "            _(\"E605: Exception not caught: %s\"),", "            current_exception->value);"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["            _(\"E605: Exception not caught: %s\"),", "            current_exception->value);", "        p = vim_strsave(IObuff);"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["  } else {", "    /* When leaving a function, reduce nesting level. */", "    if (getline_equal(fgetline, cookie, get_func_line))"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    /* When leaving a function, reduce nesting level. */", "    if (getline_equal(fgetline, cookie, get_func_line))", "      --ex_nesting_level;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (getline_equal(fgetline, cookie, get_func_line))", "      --ex_nesting_level;", "    /*"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      --ex_nesting_level;", "    /*", "     * Go to debug mode when returning from a function in which we are"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["     */", "    if ((getline_equal(fgetline, cookie, getsourceline)", "         || getline_equal(fgetline, cookie, get_func_line))"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      do_debug(getline_equal(fgetline, cookie, getsourceline)", "          ? (char_u *)_(\"End of sourced file\")", "          : (char_u *)_(\"End of function\"));"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["          ? (char_u *)_(\"End of sourced file\")", "          : (char_u *)_(\"End of function\"));", "  }"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Restore the exception environment (done after returning from the"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["   */", "  if (flags & DOCMD_EXCRESET)", "    restore_dbg_stuff(&debug_saved);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * If there was too much output to fit on the command line, ask the user to"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (did_inc) {", "    --RedrawingDisabled;", "    --no_wait_return;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    --RedrawingDisabled;", "    --no_wait_return;", "    msg_scroll = FALSE;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    --no_wait_return;", "    msg_scroll = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * When just finished an \":if\"-\":else\" which was typed, no need to"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        ) {", "      need_wait_return = FALSE;", "      msg_didany = FALSE;               /* don't wait when restarting edit */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      need_wait_return = FALSE;", "      msg_didany = FALSE;               /* don't wait when restarting edit */", "    } else if (need_wait_return) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      need_wait_return = FALSE;", "      msg_didany = FALSE;               /* don't wait when restarting edit */", "    } else if (need_wait_return) {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    } else if (need_wait_return) {", "      /*", "       * The msg_start() above clears msg_didout. The wait_return we do"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      msg_didout |= msg_didout_before_start;", "      wait_return(FALSE);", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  did_endif = FALSE;    /* in case do_cmdline used recursively */", ""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  did_endif = FALSE;    /* in case do_cmdline used recursively */", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * Obtain a line when inside a \":while\" or \":for\" loop."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (cp->current_line + 1 >= cp->lines_gap->ga_len) {", "    if (cp->repeating)", "      return NULL;              /* trying to read past \":endwhile\"/\":endfor\" */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (cp->repeating)", "      return NULL;              /* trying to read past \":endwhile\"/\":endfor\" */", ""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      store_loop_line(cp->lines_gap, line);", "      ++cp->current_line;", "    }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Store a line in \"gap\" so that a \":while\" loop can execute it again."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * If \"fgetline\" is get_loop_line(), return TRUE if the getline it uses equals"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["int getline_equal(LineGetter fgetline,", "                  void *cookie, /* argument for fgetline() */", "                  LineGetter func)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* When \"fgetline\" is \"get_loop_line()\" use the \"cookie\" to find the", "   * function that's originally used to obtain the lines.  This may be"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * If \"fgetline\" is get_loop_line(), return the cookie used by the original"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["void * getline_cookie(LineGetter fgetline,", "                      void *cookie /* argument for fgetline() */", "                      )"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* When \"fgetline\" is \"get_loop_line()\" use the \"cookie\" to find the", "   * cookie that's originally used to obtain the lines.  This may be nested"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Helper function to apply an offset for buffer commands, i.e. \":bdelete\","], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  buf = firstbuf;", "  while (buf->b_next != NULL && buf->b_fnum < lnum)", "    buf = buf->b_next;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    nextbuf = (offset < 0) ? buf->b_prev : buf->b_next;", "    if (nextbuf == NULL)", "      break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    buf = nextbuf;", "    if (addr_type == ADDR_LOADED_BUFFERS)", "      /* skip over unloaded buffers */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (addr_type == ADDR_LOADED_BUFFERS)", "      /* skip over unloaded buffers */", "      while (buf->b_ml.ml_mfp == NULL) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      nextbuf = (offset >= 0) ? buf->b_prev : buf->b_next;", "      if (nextbuf == NULL)", "        break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {", "    ++nr;", "    if (wp == win)"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    ++nr;", "    if (wp == win)", "      break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  FOR_ALL_TABS(tp) {", "    ++nr;", "    if (tp == tab)"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    ++nr;", "    if (tp == tab)", "      break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Execute one Ex command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["                           LineGetter fgetline,", "                           void *cookie /* argument for fgetline() */", "                           )"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* When the last file has not been edited :q has to be typed twice. */", "  if (quitmore"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  /* When the last file has not been edited :q has to be typed twice. */", "  if (quitmore", "      /* avoid that a function call in 'statusline' does this */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  if (quitmore", "      /* avoid that a function call in 'statusline' does this */", "      && !getline_equal(fgetline, cookie, get_func_line)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      && !getline_equal(fgetline, cookie, get_func_line)", "      /* avoid that an autocommand, e.g. QuitPre, does this */", "      && !getline_equal(fgetline, cookie, getnextac)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      )", "    --quitmore;", ""], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Reset browse, confirm, etc..  They are restored when returning, for"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (!ea.skip && got_int) {", "    ea.skip = TRUE;", "    (void)do_intthrow(cstack);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * 5. Parse the command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Skip ':' and any white space"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * If we got a line, but no command, then go to the line."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "      if (ea.line2 < 0)", "        errormsg = (char_u *)_(e_invrange);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        errormsg = (char_u *)_(e_invrange);", "      else {", "        if (ea.line2 == 0)"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        errormsg = (char_u *)_(e_invrange);", "      else {", "        if (ea.line2 == 0)"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      else {", "        if (ea.line2 == 0)", "          curwin->w_cursor.lnum = 1;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          curwin->w_cursor.lnum = 1;", "        else", "          curwin->w_cursor.lnum = ea.line2;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    while (ASCII_ISALNUM(*p)) {", "      ++p;", "    }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    p = vim_strnsave(ea.cmd, p - ea.cmd);", "    int ret = apply_autocmds(EVENT_CMDUNDEFINED, p, p, TRUE, NULL);", "    xfree(p);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  if (p == NULL) {", "    if (!ea.skip)", "      errormsg = (char_u *)_(\"E464: Ambiguous use of user-defined command\");"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      errormsg = IObuff;", "      did_emsg_syntax = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        && (!curbuf->terminal || ea.cmdidx != CMD_put)) {", "      /* Command not allowed in non-'modifiable' buffer */", "      errormsg = (char_u *)_(e_modifiable);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Don't complain about the range if it is not used"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    }", "    if ((errormsg = invalid_range(&ea)) != NULL)", "      goto doend;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * For the \":make\" and \":grep\" commands we insert the 'makeprg'/'grepprg'"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  p = replace_makeprg(&ea, p, cmdlinep);", "  if (p == NULL)", "    goto doend;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Skip to start of argument."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["   */", "  if (ea.cmdidx == CMD_bang)", "    ea.arg = p;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    ea.arg = p;", "  else", "    ea.arg = skipwhite(p);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Check for \"++opt=val\" argument."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (ea.cmdidx == CMD_write || ea.cmdidx == CMD_update) {", "    if (*ea.arg == '>') {                       /* append */", "      if (*++ea.arg != '>') {                   /* typed wrong */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (*ea.arg == '>') {                       /* append */", "      if (*++ea.arg != '>') {                   /* typed wrong */", "        errormsg = (char_u *)_(\"E494: Use w or w>>\");"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      ea.arg = skipwhite(ea.arg + 1);", "      ea.append = TRUE;", "    } else if (*ea.arg == '!' && ea.cmdidx == CMD_write) { /* :w !filter */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      ea.append = TRUE;", "    } else if (*ea.arg == '!' && ea.cmdidx == CMD_write) { /* :w !filter */", "      ++ea.arg;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    } else if (*ea.arg == '!' && ea.cmdidx == CMD_write) { /* :w !filter */", "      ++ea.arg;", "      ea.usefilter = TRUE;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      ++ea.arg;", "      ea.usefilter = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    if (ea.forceit) {", "      ea.usefilter = TRUE;                      /* :r! filter if ea.forceit */", "      ea.forceit = FALSE;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (ea.forceit) {", "      ea.usefilter = TRUE;                      /* :r! filter if ea.forceit */", "      ea.forceit = FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      ea.usefilter = TRUE;                      /* :r! filter if ea.forceit */", "      ea.forceit = FALSE;", "    } else if (*ea.arg == '!') {              /* :r !filter */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      ea.forceit = FALSE;", "    } else if (*ea.arg == '!') {              /* :r !filter */", "      ++ea.arg;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    } else if (*ea.arg == '!') {              /* :r !filter */", "      ++ea.arg;", "      ea.usefilter = TRUE;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      ++ea.arg;", "      ea.usefilter = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    ea.amount = 1;", "    while (*ea.arg == *ea.cmd) {                /* count number of '>' or '<' */", "      ++ea.arg;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    while (*ea.arg == *ea.cmd) {                /* count number of '>' or '<' */", "      ++ea.arg;", "      ++ea.amount;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      ++ea.arg;", "      ++ea.amount;", "    }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Check for \"+command\" argument, before checking for next command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Check for '|' to separate commands and '\"' to start comments."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      && *ea.arg != NUL", "      /* Do not allow register = for user commands */", "      && (!IS_USER_CMDIDX(ea.cmdidx) || *ea.arg != '=')"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      ea.regname = *ea.arg++;", "      /* for '=' register: accept the rest of the line as an expression */", "      if (ea.arg[-1] == '=' && ea.arg[0] != NUL) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      ea.line2 = n;", "      if (ea.addr_count == 0)", "        ea.addr_count = 1;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      ea.line2 += n - 1;", "      ++ea.addr_count;", "      // Be vi compatible: no error message for out of range."], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Check for flags: 'l', 'p' and '#'."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Skip the command when it's not going to be executed."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    switch (ea.cmdidx) {", "    /* commands that need evaluation */", "    case CMD_while:"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Accept buffer name.  Cannot be used at the same time with a buffer"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      ) {", "    /*", "     * :bdelete, :bwipeout and :bunload take several arguments, separated"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["     */", "    if (ea.cmdidx == CMD_bdelete || ea.cmdidx == CMD_bwipeout", "        || ea.cmdidx == CMD_bunload)"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      p = skiptowhite_esc(ea.arg);", "    else {", "      p = ea.arg + STRLEN(ea.arg);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      p = skiptowhite_esc(ea.arg);", "    else {", "      p = ea.arg + STRLEN(ea.arg);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      p = ea.arg + STRLEN(ea.arg);", "      while (p > ea.arg && ascii_iswhite(p[-1]))", "        --p;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      while (p > ea.arg && ascii_iswhite(p[-1]))", "        --p;", "    }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  if (IS_USER_CMDIDX(ea.cmdidx)) {", "    /*", "     * Execute a user-defined command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  } else {", "    /*", "     * Call the function to execute the command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    (cmdnames[ea.cmdidx].cmd_func)(&ea);", "    if (ea.errmsg != NULL)", "      errormsg = (char_u *)_(ea.errmsg);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * If the command just executed called do_cmdline(), any throw or \":return\""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["   */", "  if (need_rethrow)", "    do_throw(cstack);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    do_throw(cstack);", "  else if (check_cstack) {", "    if (source_finished(fgetline, cookie))"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  else if (check_cstack) {", "    if (source_finished(fgetline, cookie))", "      do_finish(&ea, TRUE);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (source_finished(fgetline, cookie))", "      do_finish(&ea, TRUE);", "    else if (getline_equal(fgetline, cookie, get_func_line)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      do_finish(&ea, TRUE);", "    else if (getline_equal(fgetline, cookie, get_func_line)", "             && current_func_returned())"], "readability/braces"]
["src/nvim/ex_docmd.c", ["             && current_func_returned())", "      do_return(&ea, TRUE, FALSE, NULL);", "  }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  }", "  need_rethrow = check_cstack = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["  do_errthrow(cstack,", "      (ea.cmdidx != CMD_SIZE && !IS_USER_CMDIDX(ea.cmdidx))", "      ? cmdnames[(int)ea.cmdidx].cmd_name"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["      (ea.cmdidx != CMD_SIZE && !IS_USER_CMDIDX(ea.cmdidx))", "      ? cmdnames[(int)ea.cmdidx].cmd_name", "      : (char_u *)NULL);"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["      ? cmdnames[(int)ea.cmdidx].cmd_name", "      : (char_u *)NULL);", ""], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["", "  if (ea.nextcmd && *ea.nextcmd == NUL)         /* not really a next command */", "    ea.nextcmd = NULL;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  if (ea.nextcmd && *ea.nextcmd == NUL)         /* not really a next command */", "    ea.nextcmd = NULL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  --ex_nesting_level;", ""], "readability/increment"]
["src/nvim/ex_docmd.c", ["  return ea.nextcmd;", "}", ""], "readability/fn_size"]
["src/nvim/ex_docmd.c", ["    }", "      if (!checkforcmd(&p, \"verbose\", 4))", "        break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Check for an Ex command with optional tail."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  for (i = 0; cmd[i] != NUL; ++i)", "    if (((char_u *)cmd)[i] != (*pp)[i])"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  for (i = 0; cmd[i] != NUL; ++i)", "    if (((char_u *)cmd)[i] != (*pp)[i])"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  for (i = 0; cmd[i] != NUL; ++i)", "    if (((char_u *)cmd)[i] != (*pp)[i])", "      break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    *pp = skipwhite(*pp + i);", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * Append \"cmd\" to the error message in IObuff."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      d += 4;", "    } else", "      MB_COPY_CHAR(s, d);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Isolate the command and search for it in the command table."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    eap->cmdidx = CMD_k;", "    ++p;", "  } else if (p[0] == 's'"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    eap->cmdidx = CMD_substitute;", "    ++p;", "  } else {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  } else {", "    while (ASCII_ISALPHA(*p))", "      ++p;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    while (ASCII_ISALPHA(*p))", "      ++p;", "    /* for python 3.x support \":py3\", \":python3\", \":py3file\", etc. */"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      ++p;", "    /* for python 3.x support \":py3\", \":python3\", \":py3file\", etc. */", "    if (eap->cmd[0] == 'p' && eap->cmd[1] == 'y')"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    /* for python 3.x support \":py3\", \":python3\", \":py3file\", etc. */", "    if (eap->cmd[0] == 'p' && eap->cmd[1] == 'y')", "      while (ASCII_ISALNUM(*p))"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (eap->cmd[0] == 'p' && eap->cmd[1] == 'y')", "      while (ASCII_ISALNUM(*p))", "        ++p;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      while (ASCII_ISALNUM(*p))", "        ++p;", ""], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "    /* check for non-alpha command */", "    if (p == eap->cmd && vim_strchr((char_u *)\"@!=><&~#\", *p) != NULL)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    /* check for non-alpha command */", "    if (p == eap->cmd && vim_strchr((char_u *)\"@!=><&~#\", *p) != NULL)", "      ++p;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (p == eap->cmd && vim_strchr((char_u *)\"@!=><&~#\", *p) != NULL)", "      ++p;", "    len = (int)(p - eap->cmd);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    if (*eap->cmd == 'd' && (p[-1] == 'l' || p[-1] == 'p')) {", "      /* Check for \":dl\", \":dell\", etc. to \":deletel\": that's", "       * :delete with the 'l' flag.  Same for 'p'. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["       * :delete with the 'l' flag.  Same for 'p'. */", "      for (i = 0; i < len; ++i)", "        if (eap->cmd[i] != ((char_u *)\"delete\")[i])"], "readability/braces"]
["src/nvim/ex_docmd.c", ["       * :delete with the 'l' flag.  Same for 'p'. */", "      for (i = 0; i < len; ++i)", "        if (eap->cmd[i] != ((char_u *)\"delete\")[i])"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      for (i = 0; i < len; ++i)", "        if (eap->cmd[i] != ((char_u *)\"delete\")[i])", "          break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      if (i == len - 1) {", "        --len;", "        if (p[-1] == 'l')"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        --len;", "        if (p[-1] == 'l')", "          eap->flags |= EXFLAG_LIST;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          eap->flags |= EXFLAG_LIST;", "        else", "          eap->flags |= EXFLAG_PRINT;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "    for (; (int)eap->cmdidx < (int)CMD_SIZE;", "         eap->cmdidx = (cmdidx_T)((int)eap->cmdidx + 1))"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      if (STRNCMP(cmdnames[(int)eap->cmdidx].cmd_name, (char *)eap->cmd,", "              (size_t)len) == 0) {", "        if (full != NULL"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["              (size_t)len) == 0) {", "        if (full != NULL", "            && cmdnames[(int)eap->cmdidx].cmd_name[len] == NUL)"], "readability/braces"]
["src/nvim/ex_docmd.c", ["            && cmdnames[(int)eap->cmdidx].cmd_name[len] == NUL)", "          *full = TRUE;", "        break;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        && *eap->cmd >= 'A' && *eap->cmd <= 'Z') {", "      /* User defined commands may contain digits. */", "      while (ASCII_ISALNUM(*p))"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      /* User defined commands may contain digits. */", "      while (ASCII_ISALNUM(*p))", "        ++p;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      while (ASCII_ISALNUM(*p))", "        ++p;", "      p = find_ucmd(eap, p, full, NULL, NULL);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    }", "    if (p == eap->cmd)", "      eap->cmdidx = CMD_SIZE;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Search for a user command that matches \"eap->cmd\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["static char_u *", "find_ucmd (", "    exarg_T *eap,"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["  ucmd_T      *uc;", "  int found = FALSE;", "  int possible = FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  int found = FALSE;", "  int possible = FALSE;", "  char_u      *cp, *np;             /* Point into typed cmd and test name */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  int possible = FALSE;", "  char_u      *cp, *np;             /* Point into typed cmd and test name */", "  garray_T    *gap;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  garray_T    *gap;", "  int amb_local = FALSE;            /* Found ambiguous buffer-local command,", "                                       only full match global is accepted. */"], "readability/multiline_comment"]
["src/nvim/ex_docmd.c", ["  garray_T    *gap;", "  int amb_local = FALSE;            /* Found ambiguous buffer-local command,", "                                       only full match global is accepted. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  garray_T    *gap;", "  int amb_local = FALSE;            /* Found ambiguous buffer-local command,", "                                       only full match global is accepted. */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Look for buffer-local user commands first, then global ones."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  for (;; ) {", "    for (j = 0; j < gap->ga_len; ++j) {", "      uc = USER_CMD_GA(gap, j);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      k = 0;", "      while (k < len && *np != NUL && *cp++ == *np++)", "        k++;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      if (k == len || (*np == NUL && ascii_isdigit(eap->cmd[k]))) {", "        /* If finding a second match, the command is ambiguous.  But", "         * not if a buffer-local command wasn't a full match and a"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        if (k == len && found && *np != NUL) {", "          if (gap == &ucmds)", "            return NULL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["            return NULL;", "          amb_local = TRUE;", "        }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        if (!found || (k == len && *np == NUL)) {", "          /* If we matched up to a digit, then there could", "           * be another command including the digit that we"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["           */", "          if (k == len)", "            found = TRUE;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          if (k == len)", "            found = TRUE;", "          else"], "readability/bool"]
["src/nvim/ex_docmd.c", ["            found = TRUE;", "          else", "            possible = TRUE;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          else", "            possible = TRUE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "          if (gap == &ucmds)", "            eap->cmdidx = CMD_USER;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["            eap->cmdidx = CMD_USER;", "          else", "            eap->cmdidx = CMD_USER_BUF;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          }", "          /* Do not search for further abbreviations", "           * if this is an exact match. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["          if (k == len && *np == NUL) {", "            if (full != NULL)", "              *full = TRUE;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["            if (full != NULL)", "              *full = TRUE;", "            amb_local = FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["              *full = TRUE;", "            amb_local = FALSE;", "            break;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "    /* Stop if we found a full match or searched all. */", "    if (j < gap->ga_len || gap == &ucmds)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    /* Stop if we found a full match or searched all. */", "    if (j < gap->ga_len || gap == &ucmds)", "      break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /* Only found ambiguous matches. */", "  if (amb_local) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (amb_local) {", "    if (xp != NULL)", "      xp->xp_context = EXPAND_UNSUCCESSFUL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /* The match we found may be followed immediately by a number.  Move \"p\"", "   * back to point to it. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["   * back to point to it. */", "  if (found || possible)", "    return p + (matchlen - len);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  int minlen;", "  int has_count;            /* :123verbose  :3tab */", "} cmdmods[] = {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Return length of a command modifier (including optional count)."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  if (ascii_isdigit(*cmd))", "    p = skipwhite(skipdigits(cmd));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    p = skipwhite(skipdigits(cmd));", "  for (i = 0; i < (int)ARRAY_SIZE(cmdmods); ++i) {", "    for (j = 0; p[j] != NUL; ++j)"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  for (i = 0; i < (int)ARRAY_SIZE(cmdmods); ++i) {", "    for (j = 0; p[j] != NUL; ++j)", "      if (p[j] != cmdmods[i].name[j])"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  for (i = 0; i < (int)ARRAY_SIZE(cmdmods); ++i) {", "    for (j = 0; p[j] != NUL; ++j)", "      if (p[j] != cmdmods[i].name[j])"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    for (j = 0; p[j] != NUL; ++j)", "      if (p[j] != cmdmods[i].name[j])", "        break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Return > 0 if an Ex command \"name\" exists."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* Check built-in commands and user defined commands.", "   * For \":2match\" and \":3match\" we need to skip the number. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  p = find_command(&ea, &full);", "  if (p == NULL)", "    return 3;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    return 3;", "  if (ascii_isdigit(*name) && ea.cmdidx != CMD_match)", "    return 0;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    return 0;", "  if (*skipwhite(p) != NUL)", "    return 0;           /* trailing garbage */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  if (*skipwhite(p) != NUL)", "    return 0;           /* trailing garbage */", "  return ea.cmdidx == CMD_SIZE ? 0 : (full ? 2 : 1);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * This is all pretty much copied from do_one_cmd(), with all the extra stuff"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  if (*cmd == NUL)", "    return NULL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    return NULL;", "  if (*cmd == '\"') {        /* ignore comment lines */", "    xp->xp_context = EXPAND_NOTHING;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * 3. parse a range specifier of the form: addr [,addr] [;addr] .."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * 4. parse command"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  if (*cmd == '|' || *cmd == '\\n')", "    return cmd + 1;                     /* There's another command */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  if (*cmd == '|' || *cmd == '\\n')", "    return cmd + 1;                     /* There's another command */", ""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Isolate the command and search for it in the command table."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * If the cursor is touching the command, and it ends in an alpha-numeric"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["   */", "  if (*p == NUL && ASCII_ISALNUM(p[-1]))", "    return NULL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  if (ea.cmdidx == CMD_SIZE) {", "    /* Not still touching the command and it was an illegal one */", "    xp->xp_context = EXPAND_UNSUCCESSFUL;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  xp->xp_context = EXPAND_NOTHING;   /* Default now that we're past command */", ""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * 5. parse arguments"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Check for '|' to separate commands and '\"' to start comments."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    p = arg;", "    /* \":redir @\" is not the start of a comment */", "    if (ea.cmdidx == CMD_redir && p[0] == '@' && p[1] == '\"')"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    /* \":redir @\" is not the start of a comment */", "    if (ea.cmdidx == CMD_redir && p[0] == '@' && p[1] == '\"')", "      p += 2;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        if (*(p - 1) != '\\\\') {", "          if (*p == '|' || *p == '\\n')", "            return p + 1;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["            return p + 1;", "          return NULL;              /* It's a comment */", "        }"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* Find start of last argument (argument just before cursor): */", "  p = buff;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * Allow spaces within back-quotes to count as part of the argument"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      }", "      /* An argument can contain just about everything, except", "       * characters that end the command and white space. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["       * characters that end the command and white space. */", "      else if (c == '|'", "            || c == '\\n'"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["      else if (c == '|'", "            || c == '\\n'", "            || c == '\"'"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["            || c == '\\n'", "            || c == '\"'", "            || ascii_iswhite(c)) {"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["            || c == '\"'", "            || ascii_iswhite(c)) {", "        len = 0;          /* avoid getting stuck when space is in 'isfname' */"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["            || ascii_iswhite(c)) {", "        len = 0;          /* avoid getting stuck when space is in 'isfname' */", "        while (*p != NUL) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * If we are still inside the quotes, and we passed a space, just"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /* For a shell command more chars need to be escaped. */", "    if (usefilter || ea.cmdidx == CMD_bang || ea.cmdidx == CMD_terminal) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["#ifndef BACKSLASH_IN_FILENAME", "      xp->xp_shell = TRUE;", "#endif"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    }", "    /* Check for user names */", "    if (*xp->xp_pattern == '~') {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        xp->xp_context = EXPAND_USER;", "        ++xp->xp_pattern;", "      }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * 6. switch on command name"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  case CMD_tabfind:", "    if (xp->xp_context == EXPAND_FILES)", "      xp->xp_context = EXPAND_FILES_IN_PATH;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /* Command modifiers: return the argument.", "   * Also for commands with an argument that is a command. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (*arg == NUL || !ends_excmd(*arg)) {", "      /* also complete \"None\" */", "      set_context_in_echohl_cmd(xp, arg);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * All completion for the +cmdline_compl feature goes here."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  case CMD_command:", "    /* Check for attributes */", "    while (*arg == '-') {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    }", "    if (arg[0] != NUL)", "      return arg + 1;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  return NULL;", "}", ""], "readability/fn_size"]
["src/nvim/ex_docmd.c", ["      delim = *cmd++;", "      while (*cmd != NUL && *cmd != delim)", "        if (*cmd++ == '\\\\' && *cmd != NUL)"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      while (*cmd != NUL && *cmd != delim)", "        if (*cmd++ == '\\\\' && *cmd != NUL)", "          ++cmd;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        if (*cmd++ == '\\\\' && *cmd != NUL)", "          ++cmd;", "      if (*cmd == NUL && ctx != NULL)"], "readability/increment"]
["src/nvim/ex_docmd.c", ["          ++cmd;", "      if (*cmd == NUL && ctx != NULL)", "        *ctx = EXPAND_NOTHING;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    }", "    if (*cmd != NUL)", "      ++cmd;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (*cmd != NUL)", "      ++cmd;", "  }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    switch (*cmd) {", "    case '.':                               /* '.' - Cursor position */", "      ++cmd;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    case '.':                               /* '.' - Cursor position */", "      ++cmd;", "      switch (addr_type) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "    case '$':                               /* '$' - last line */", "      ++cmd;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    case '$':                               /* '$' - last line */", "      ++cmd;", "      switch (addr_type) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "    case '\\'':                              /* ''' - mark */", "      if (*++cmd == NUL) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      }", "      if (skip)", "        ++cmd;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      if (skip)", "        ++cmd;", "      else {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        ++cmd;", "      else {", "        /* Only accept a mark in another file when it is"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        ++cmd;", "      else {", "        /* Only accept a mark in another file when it is"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      else {", "        /* Only accept a mark in another file when it is", "         * used by itself: \":'M\". */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        fp = getmark(*cmd, to_other_file && cmd[1] == NUL);", "        ++cmd;", "        if (fp == (pos_T *)-1)"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        ++cmd;", "        if (fp == (pos_T *)-1)", "          /* Jumped to another file. */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        if (fp == (pos_T *)-1)", "          /* Jumped to another file. */", "          lnum = curwin->w_cursor.lnum;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["          lnum = curwin->w_cursor.lnum;", "        else {", "          if (check_mark(fp) == FAIL) {"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          lnum = curwin->w_cursor.lnum;", "        else {", "          if (check_mark(fp) == FAIL) {"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    case '/':", "    case '?':                           /* '/' or '?' - search */", "      c = *cmd++;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      }", "      if (skip) {                       /* skip \"/pat/\" */", "        cmd = skip_regexp(cmd, c, p_magic, NULL);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        cmd = skip_regexp(cmd, c, p_magic, NULL);", "        if (*cmd == c)", "          ++cmd;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        if (*cmd == c)", "          ++cmd;", "      } else {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        curwin->w_cursor = pos;", "        /* adjust command string pointer */", "        cmd += searchcmdlen;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    case '\\\\':                      /* \"\\?\", \"\\/\" or \"\\&\", repeat search */", "      ++cmd;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    case '\\\\':                      /* \"\\?\", \"\\/\" or \"\\&\", repeat search */", "      ++cmd;", "      if (addr_type != ADDR_LINES) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      }", "      if (*cmd == '&')", "        i = RE_SUBST;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        i = RE_SUBST;", "      else if (*cmd == '?' || *cmd == '/')", "        i = RE_SEARCH;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        i = RE_SEARCH;", "      else {", "        EMSG(_(e_backslash));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        i = RE_SEARCH;", "      else {", "        EMSG(_(e_backslash));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      }", "      ++cmd;", "      break;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        goto error;", "      } else if (addr_type == ADDR_LOADED_BUFFERS || addr_type == ADDR_BUFFERS) {", "        lnum = compute_buffer_local_count("], "whitespace/line_length"]
["src/nvim/ex_docmd.c", ["", "/*", " * Get flags from an Ex command argument."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  while (vim_strchr((char_u *)\"lp#\", *eap->arg) != NULL) {", "    if (*eap->arg == 'l')", "      eap->flags |= EXFLAG_LIST;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      eap->flags |= EXFLAG_LIST;", "    else if (*eap->arg == 'p')", "      eap->flags |= EXFLAG_PRINT;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      eap->flags |= EXFLAG_PRINT;", "    else", "      eap->flags |= EXFLAG_NR;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["{", "  if (!eap->skip)", "    eap->errmsg = (char_u *)N_("], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Check range in Ex command for validity."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Correct the range for zero line number, if required."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * For a \":vimgrep\" or \":vimgrepadd\" command return a pointer past the"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    p = skip_vimgrep_pat(p, NULL, NULL);", "    if (p == NULL)", "      p = eap->arg;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * For the \":make\" and \":grep\" commands insert the 'makeprg'/'grepprg' option"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Don't do it when \":vimgrep\" is used for \":grep\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        || eap->cmdidx == CMD_grepadd || eap->cmdidx == CMD_lgrepadd) {", "      if (*curbuf->b_p_gp == NUL)", "        program = p_gp;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        program = p_gp;", "      else", "        program = curbuf->b_p_gp;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    } else {", "      if (*curbuf->b_p_mp == NUL)", "        program = p_mp;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        program = p_mp;", "      else", "        program = curbuf->b_p_mp;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if ((pos = (char_u *)strstr((char *)program, \"$*\")) != NULL) {", "      /* replace $* by given arguments */", "      i = 1;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      i = 1;", "      while ((pos = (char_u *)strstr((char *)pos + 2, \"$*\")) != NULL)", "        ++i;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      while ((pos = (char_u *)strstr((char *)pos + 2, \"$*\")) != NULL)", "        ++i;", "      len = (int)STRLEN(p);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "    /* 'eap->cmd' is not set here, because it is not used at CMD_make */", "    xfree(*cmdlinep);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  int has_wildcards;            /* need to expand wildcards */", "  char_u      *repl;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* Skip a regexp pattern for \":vimgrep[add] pat file...\" */", "  p = skip_grep_pat(eap);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Decide to expand wildcards *before* replacing '%', '#', etc.  If"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  while (*p != NUL) {", "    /* Skip over `=expr`, wildcards in it are not expanded. */", "    if (p[0] == '`' && p[1] == '=') {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      (void)skip_expr(&p);", "      if (*p == '`')", "        ++p;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      if (*p == '`')", "        ++p;", "      continue;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    }", "    /*", "     * Quick check if this cannot be the start of a special string."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (vim_strchr((char_u *)\"%#<\", *p) == NULL) {", "      ++p;", "      continue;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * Try to find a match at this position."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    repl = eval_vars(p, eap->arg, &srclen, &(eap->do_ecmd_lnum),", "        errormsgp, &escaped);", "    if (*errormsgp != NULL)             /* error detected */"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["        errormsgp, &escaped);", "    if (*errormsgp != NULL)             /* error detected */", "      return FAIL;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        errormsgp, &escaped);", "    if (*errormsgp != NULL)             /* error detected */", "      return FAIL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      return FAIL;", "    if (repl == NULL) {                 /* no match found */", "      p += srclen;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /* Wildcards won't be expanded below, the replacement is taken", "     * literally.  But do expand \"~/file\", \"~user/file\" and \"$HOME/file\". */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /* Need to escape white space et al. with a backslash.", "     * Don't do this for:"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["#ifdef BACKSLASH_IN_FILENAME", "      /* Don't escape a backslash here, because rem_backslash() doesn't", "       * remove it later. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "      for (l = repl; *l; ++l)", "        if (vim_strchr(ESCAPE_CHARS, *l) != NULL) {"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "      for (l = repl; *l; ++l)", "        if (vim_strchr(ESCAPE_CHARS, *l) != NULL) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * One file argument: Expand wildcards."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (has_wildcards) {", "      /*", "       * May expand environment variables.  This"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        expand_env_esc(eap->arg, NameBuff, MAXPATHL,", "            TRUE, TRUE, NULL);", "        has_wildcards = path_has_wildcard(NameBuff);"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["        expand_env_esc(eap->arg, NameBuff, MAXPATHL,", "            TRUE, TRUE, NULL);", "        has_wildcards = path_has_wildcard(NameBuff);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        p = NameBuff;", "      } else", "        p = NULL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * Halve the number of backslashes (this is Vi compatible)."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["#ifdef UNIX", "    if (!has_wildcards)", "#endif"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      xpc.xp_context = EXPAND_FILES;", "      if (p_wic)", "        options += WILD_ICASE;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Replace part of the command line, keeping eap->cmd, eap->arg and"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  /*", "   * The new command line is build in new_cmdline[]."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  size_t i = (size_t)(src - *cmdlinep) + STRLEN(src + srclen) + len + 3;", "  if (eap->nextcmd != NULL)", "    i += STRLEN(eap->nextcmd);    /* add space for next command */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  if (eap->nextcmd != NULL)", "    i += STRLEN(eap->nextcmd);    /* add space for next command */", "  char_u *new_cmdline = xmalloc(i);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Copy the stuff before the expanded part."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["   */", "  i = (size_t)(src - *cmdlinep);   /* length of part before match */", "  memmove(new_cmdline, *cmdlinep, i);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  memmove(new_cmdline + i, repl, len);", "  i += len;                             /* remember the end of the string */", "  STRCPY(new_cmdline + i, src + srclen);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  STRCPY(new_cmdline + i, src + srclen);", "  src = new_cmdline + i;                /* remember where to continue */", ""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  if (eap->nextcmd != NULL) {           /* append next command */", "    i = STRLEN(new_cmdline) + 1;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  eap->arg = new_cmdline + (eap->arg - *cmdlinep);", "  if (eap->do_ecmd_cmd != NULL && eap->do_ecmd_cmd != dollar_command)", "    eap->do_ecmd_cmd = new_cmdline + (eap->do_ecmd_cmd - *cmdlinep);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Check for '|' to separate commands and '\"' to start comments."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * get + command from ex argument"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  if (*arg == '+') {        /* +[command] */", "    ++arg;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (*arg == '+') {        /* +[command] */", "    ++arg;", "    if (ascii_isspace(*arg) || *arg == '\\0')"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    ++arg;", "    if (ascii_isspace(*arg) || *arg == '\\0')", "      command = dollar_command;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      command = dollar_command;", "    else {", "      command = arg;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      command = dollar_command;", "    else {", "      command = arg;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      command = arg;", "      arg = skip_cmd_arg(command, TRUE);", "      if (*arg != NUL)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      arg = skip_cmd_arg(command, TRUE);", "      if (*arg != NUL)", "        *arg++ = NUL;                   /* terminate command with NUL */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      if (*arg != NUL)", "        *arg++ = NUL;                   /* terminate command with NUL */", "    }"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    arg = skipwhite(arg);       /* skip over spaces */", "    *argp = arg;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Find end of \"+command\" argument.  Skip over \"\\ \" and \"\\\\\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["static char_u *", "skip_cmd_arg (", "    char_u *p,"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["    char_u *p,", "    int rembs              /* TRUE to halve the number of backslashes */", ")"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (*p == '\\\\' && p[1] != NUL) {", "      if (rembs)", "        STRMOVE(p, p + 1);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        STRMOVE(p, p + 1);", "      else", "        ++p;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      else", "        ++p;", "    }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Get \"++opt=arg\" argument."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* \":edit ++[no]bin[ary] file\" */", "  if (STRNCMP(arg, \"bin\", 3) == 0 || STRNCMP(arg, \"nobin\", 5) == 0) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      eap->force_bin = FORCE_NOBIN;", "    } else", "      eap->force_bin = FORCE_BIN;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      eap->force_bin = FORCE_BIN;", "    if (!checkforcmd(&arg, \"binary\", 3))", "      return FAIL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /* \":read ++edit file\" */", "  if (STRNCMP(arg, \"edit\", 4) == 0) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (STRNCMP(arg, \"edit\", 4) == 0) {", "    eap->read_edit = TRUE;", "    eap->arg = skipwhite(arg + 4);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  } else if (STRNCMP(arg, \"enc\", 3) == 0) {", "    if (STRNCMP(arg, \"encoding\", 8) == 0)", "      arg += 8;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      arg += 8;", "    else", "      arg += 3;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  if (pp == NULL || *arg != '=')", "    return FAIL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  ++arg;", "  *pp = (int)(arg - eap->cmd);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  *pp = (int)(arg - eap->cmd);", "  arg = skip_cmd_arg(arg, FALSE);", "  eap->arg = skipwhite(arg);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  } else if (pp == &eap->force_enc) {", "    /* Make 'fileencoding' lower case. */", "    for (p = eap->cmd + eap->force_enc; *p != NUL; ++p)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    /* Make 'fileencoding' lower case. */", "    for (p = eap->cmd + eap->force_enc; *p != NUL; ++p)", "      *p = TOLOWER_ASC(*p);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    /* Make 'fileencoding' lower case. */", "    for (p = eap->cmd + eap->force_enc; *p != NUL; ++p)", "      *p = TOLOWER_ASC(*p);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  } else {", "    /* Check ++bad= argument.  Must be a single-byte character, \"keep\" or", "     * \"drop\". */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    char_u *p_save;", "    int relative = 0; // argument +N/-N means: go to N places to the", "                      // right/left relative to the current position."], "whitespace/comments"]
["src/nvim/ex_docmd.c", ["      }", "      else if (p == p_save || *p_save == '-' || *p != NUL || tab_number == 0) {", "        // No numbers as argument."], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["      if (!unaccept_arg0 && relative == -1) {", "        --tab_number;", "      }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      tab_number = tabpage_index(curtab) + 1;", "      if (tab_number > LAST_TAB_NR)", "        tab_number = 1;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":abbreviate\" and friends."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  do_exmap(eap, TRUE);          /* almost the same as mapping */", "}"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  do_exmap(eap, TRUE);          /* almost the same as mapping */", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":map\" and friends."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  /*", "   * If we are sourcing .exrc or .vimrc in current directory we"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  }", "  do_exmap(eap, FALSE);", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":unmap\" and friends."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  do_exmap(eap, FALSE);", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":mapclear\" and friends."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":abclear\" and friends."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    eap->errmsg = e_curdir;", "  } else if (eap->cmdidx == CMD_autocmd)", "    do_autocmd(eap->arg, eap->forceit);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    do_autocmd(eap->arg, eap->forceit);", "  else", "    do_augroup(eap->arg, eap->forceit);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":doautocmd\": Apply the automatic commands to the current buffer."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * :[N]bunload[!] [N] [bufname] unload buffer"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * :[N]buffer [N]\tto buffer N"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * :[N]bmodified [N]\tto next mod. buffer"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * :[N]bnext [N]\tto next buffer"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * :[N]bNext [N]\tto previous buffer"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * :brewind\t\tto first buffer"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * :blast\t\tto last buffer"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Return the next command, after the first '|' or '\\n'."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * - if there are more files to edit"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "        if (n == 1)", "          STRLCPY(buff, _(\"1 more file to edit.  Quit anyway?\"),"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          STRLCPY(buff, _(\"1 more file to edit.  Quit anyway?\"),", "              DIALOG_MSG_SIZE);", "        else"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["              DIALOG_MSG_SIZE);", "        else", "          vim_snprintf((char *)buff, DIALOG_MSG_SIZE,"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          vim_snprintf((char *)buff, DIALOG_MSG_SIZE,", "              _(\"%d more files to edit.  Quit anyway?\"), n);", "        if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 1) == VIM_YES)"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["              _(\"%d more files to edit.  Quit anyway?\"), n);", "        if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 1) == VIM_YES)", "          return OK;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      }", "      if (n == 1)", "        EMSG(_(\"E173: 1 more file to edit\"));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        EMSG(_(\"E173: 1 more file to edit\"));", "      else", "        EMSGN(_(\"E173: %\" PRId64 \" more files to edit\"), n);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        EMSGN(_(\"E173: %\" PRId64 \" more files to edit\"), n);", "      quitmore = 2;                 /* next try to quit is allowed */", "    }"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the list of command names."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  if (idx >= (int)CMD_SIZE)", "    return get_user_command_name(idx);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  if (rep_buf == NULL) {", "    /* Can't replace termcodes - try using the string as is */", "    rep_buf = vim_strsave(rep);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* get address of growarray: global or in curbuf */", "  if (flags & UC_BUFFER) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    gap = &curbuf->b_ucmds;", "    if (gap->ga_itemsize == 0)", "      ga_init(gap, (int)sizeof(ucmd_T), 4);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      ga_init(gap, (int)sizeof(ucmd_T), 4);", "  } else", "    gap = &ucmds;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /* Search for the command in the already defined commands. */", "  for (i = 0; i < gap->ga_len; ++i) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  /* Search for the command in the already defined commands. */", "  for (i = 0; i < gap->ga_len; ++i) {", "    size_t len;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    if (cmp == 0) {", "      if (name_len < len)", "        cmp = -1;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        cmp = -1;", "      else if (name_len > len)", "        cmp = 1;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "    /* Stop as soon as we pass the name to add */", "    if (cmp < 0)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    /* Stop as soon as we pass the name to add */", "    if (cmp < 0)", "      break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /* Extend the array unless we're replacing an existing command */", "  if (cmp != 0) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    ++gap->ga_len;", ""], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "/*", " * List of names for completion for \":command\" with the EXPAND_ flag."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  for (;; ) {", "    for (i = 0; i < gap->ga_len; ++i) {", "      cmd = USER_CMD_GA(gap, i);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      msg_putchar('\\n');", "      if (got_int)", "        break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    }", "    if (gap == &ucmds || i < gap->ga_len)", "      break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  if (!found)", "    MSG(_(\"No user-defined commands found\"));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        p = val;", "        if (*def >= 0)", "          goto two_count;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "        if (p != val + vallen)", "          goto invalid_count;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "      if (*def < 0)", "        *def = 0;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":command ...\""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* Check for attributes */", "  while (*p == '-') {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  while (*p == '-') {", "    ++p;", "    end = skiptowhite(p);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":comclear\""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "static void free_ucmd(ucmd_T* cmd) {", "  xfree(cmd->uc_name);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "static void free_ucmd(ucmd_T* cmd) {", "  xfree(cmd->uc_name);"], "whitespace/operators"]
["src/nvim/ex_docmd.c", ["", "/*", " * Clear all user commands for \"gap\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  for (;; ) {", "    for (i = 0; i < gap->ga_len; ++i) {", "      cmd = USER_CMD_GA(gap, i);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      cmp = STRCMP(eap->arg, cmd->uc_name);", "      if (cmp <= 0)", "        break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    }", "    if (gap == &ucmds || cmp == 0)", "      break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  --gap->ga_len;", ""], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  if (i < gap->ga_len)", "    memmove(cmd, cmd + 1, (gap->ga_len - i) * sizeof(ucmd_T));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * split and quote args for <f-args>"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* Precalculate length */", "  p = arg;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  p = arg;", "  len = 2;   /* Initial and final quotes */", ""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      p = skipwhite(p);", "      if (*p == NUL)", "        break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        break;", "      len += 3;       /* \",\" */", "    } else {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      p = skipwhite(p);", "      if (*p == NUL)", "        break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Check for a <> code in a user command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    char_u *buf,", "    ucmd_T *cmd,               /* the user command we're expanding */", "    exarg_T *eap,               /* ex arguments */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    ucmd_T *cmd,               /* the user command we're expanding */", "    exarg_T *eap,               /* ex arguments */", "    char_u **split_buf,"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  case ct_ARGS:", "    /* Simple case first */", "    if (*eap->arg == NUL) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        result = 2;", "        if (buf != NULL)", "          STRCPY(buf, \"''\");"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          STRCPY(buf, \"''\");", "      } else", "        result = 0;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "    /* When specified there is a single argument don't split it.", "     * Works for \":Cmd %\" when % is \"a b c\". */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    switch (quote) {", "    case 0:     /* No quoting, no splitting */", "      result = STRLEN(eap->arg);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      result = STRLEN(eap->arg);", "      if (buf != NULL)", "        STRCPY(buf, eap->arg);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      break;", "    case 1:     /* Quote, but don't split */", "      result = STRLEN(eap->arg) + 2;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      break;", "    case 2:     /* Quote and split (<f-args>) */", "      /* This is hard, so only do it once, and cache the result */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    case 2:     /* Quote and split (<f-args>) */", "      /* This is hard, so only do it once, and cache the result */", "      if (*split_buf == NULL)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      /* This is hard, so only do it once, and cache the result */", "      if (*split_buf == NULL)", "        *split_buf = uc_split_args(eap->arg, split_len);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      result = *split_len;", "      if (buf != NULL && result != 0)", "        STRCPY(buf, *split_buf);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    result = eap->forceit ? 1 : 0;", "    if (quote)", "      result += 2;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (buf != NULL) {", "      if (quote)", "        *buf++ = '\"';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        *buf++ = '\"';", "      if (eap->forceit)", "        *buf++ = '!';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        *buf++ = '!';", "      if (quote)", "        *buf = '\"';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "    sprintf(num_buf, \"%\" PRId64, (int64_t)num);", "    num_len = STRLEN(num_buf);"], "runtime/printf"]
["src/nvim/ex_docmd.c", ["", "    if (quote)", "      result += 2;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (buf != NULL) {", "      if (quote)", "        *buf++ = '\"';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      buf += num_len;", "      if (quote)", "        *buf = '\"';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    result = eap->regname ? 1 : 0;", "    if (quote)", "      result += 2;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (buf != NULL) {", "      if (quote)", "        *buf++ = '\\'';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        *buf++ = '\\'';", "      if (eap->regname)", "        *buf++ = eap->regname;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        *buf++ = eap->regname;", "      if (quote)", "        *buf = '\\'';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    result = 1;", "    if (buf != NULL)", "      *buf = '<';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  default:", "    /* Not recognized: just copy the '<' and return -1. */", "    result = (size_t)-1;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    result = (size_t)-1;", "    if (buf != NULL)", "      *buf = '<';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  if (eap->cmdidx == CMD_USER)", "    cmd = USER_CMD(eap->useridx);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    cmd = USER_CMD(eap->useridx);", "  else", "    cmd = USER_CMD_GA(&curbuf->b_ucmds, eap->useridx);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Replace <> in the command by the arguments."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  for (;; ) {", "    p = cmd->uc_rep;        /* source */", "    q = buf;                /* destination */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    p = cmd->uc_rep;        /* source */", "    q = buf;                /* destination */", "    totlen = 0;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      start = vim_strchr(p, '<');", "      if (start != NULL)", "        end = vim_strchr(start + 1, '>');"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "      /* break if there no <item> is found */", "      if (start == NULL || end == NULL)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      /* break if there no <item> is found */", "      if (start == NULL || end == NULL)", "        break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "      /* Include the '>' */", "      ++end;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      /* Include the '>' */", "      ++end;", ""], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "      /* Take everything up to the '<' */", "      len = start - p;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      len = start - p;", "      if (buf == NULL)", "        totlen += len;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        totlen += len;", "      else {", "        memmove(q, p, len);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        totlen += len;", "      else {", "        memmove(q, p, len);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      len = uc_check_code(start, end - start, q, cmd, eap,", "          &split_buf, &split_len);", "      if (len == (size_t)-1) {"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["      if (len == (size_t)-1) {", "        /* no match, continue after '<' */", "        p = start + 1;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        len = 1;", "      } else", "        p = end;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        p = end;", "      if (buf == NULL)", "        totlen += len;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        totlen += len;", "      else", "        q += len;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    }", "    if (buf != NULL) {              /* second time here, finished */", "      STRCPY(q, p);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    totlen += STRLEN(p);            /* Add on the trailing characters */", "    buf = xmalloc(totlen + 1);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["}", "/*", " * Function given to ExpandGeneric() to obtain the list of user address type names."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the list of user command names."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the list of user command"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  static char *user_cmd_flags[] = {\"addr\",   \"bang\",     \"bar\",", "                                   \"buffer\", \"complete\", \"count\","], "whitespace/braces"]
["src/nvim/ex_docmd.c", ["                                   \"buffer\", \"complete\", \"count\",", "                                   \"nargs\",  \"range\",    \"register\"};", ""], "whitespace/braces"]
["src/nvim/ex_docmd.c", ["", "  if (idx >= (int)ARRAY_SIZE(user_cmd_flags))", "    return NULL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the list of values for -nargs."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  static char *user_cmd_nargs[] = {\"0\", \"1\", \"*\", \"?\", \"+\"};", ""], "whitespace/braces"]
["src/nvim/ex_docmd.c", ["{", "  static char *user_cmd_nargs[] = {\"0\", \"1\", \"*\", \"?\", \"+\"};", ""], "whitespace/braces"]
["src/nvim/ex_docmd.c", ["", "  if (idx >= (int)ARRAY_SIZE(user_cmd_nargs))", "    return NULL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the list of values for -complete."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Parse address type argument"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Parse a completion argument \"value[vallen]\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* Look for any argument part - which is the part after any ',' */", "  for (i = 0; i < vallen; ++i) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  /* Look for any argument part - which is the part after any ',' */", "  for (i = 0; i < vallen; ++i) {", "    if (value[i] == ',') {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "    ++emsg_off;", "    p = eval_to_string(expr, NULL, FALSE);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    ++emsg_off;", "    p = eval_to_string(expr, NULL, FALSE);", "    --emsg_off;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    p = eval_to_string(expr, NULL, FALSE);", "    --emsg_off;", "    xfree(expr);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      xfree(p);", "    } else", "      MSG(\"default\");"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      MSG(\"default\");", "  } else if (load_colors(eap->arg) == FAIL)", "    EMSG2(_(\"E185: Cannot find color scheme '%s'\"), eap->arg);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Call this function if we thought we were going to exit, but we won't"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  }", "  /* Don't quit while editing the command line. */", "  if (text_locked()) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    for (wp = firstwin; wp->w_next != NULL; wp = wp->w_next) {", "      if (--wnr <= 0)", "        break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /* Don't quit while editing the command line. */", "  if (text_locked()) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":close\": close current window, unless it is the last one"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      }", "      if (win == NULL)", "        win = lastwin;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":pclose\": Close any preview window."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Close window \"win\" and take care of handling closing the last window for a"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    win_T *win,", "    tabpage_T *tp                /* NULL or the tab page \"win\" is in */", ")"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":tabclose\": close current tab page, unless it is the last one."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  if (cmdwin_type != 0)", "    cmdwin_result = K_IGNORE;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    cmdwin_result = K_IGNORE;", "  else if (first_tabpage->tp_next == NULL)", "    EMSG(_(\"E784: Cannot close last tab page\"));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    EMSG(_(\"E784: Cannot close last tab page\"));", "  else {", "    int tab_number = get_tabpage_arg(eap);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    EMSG(_(\"E784: Cannot close last tab page\"));", "  else {", "    int tab_number = get_tabpage_arg(eap);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Close the current tab page."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Close tab page \"tp\", which is not the current tab page."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* Limit to 1000 windows, autocommands may add a window while we close", "   * one.  OK, so I'm paranoid... */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /* Autocommands may delete the tab page under our fingers and we may", "     * fail to close a window with a modified buffer. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["     * fail to close a window with a modified buffer. */", "    if (!valid_tabpage(tp) || tp->tp_firstwin == wp)", "      break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  redraw_tabline = TRUE;", "  if (h != tabline_height())"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  redraw_tabline = TRUE;", "  if (h != tabline_height())", "    shell_new_rows();"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":only\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    for (wp = firstwin; --wnr > 0;) {", "      if (wp->w_next == NULL)", "        break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        break;", "      else", "        wp = wp->w_next;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  }", "  close_others(TRUE, eap->forceit);", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":all\" and \":sall\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  if (eap->addr_count == 0)", "    eap->line2 = 9999;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  }", "  /* Don't quit while editing the command line. */", "  if (text_locked()) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":print\", \":list\", \":number\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  if (curbuf->b_ml.ml_flags & ML_EMPTY)", "    EMSG(_(e_emptybuf));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    EMSG(_(e_emptybuf));", "  else {", "    for (; !got_int; os_breakcheck()) {"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    EMSG(_(e_emptybuf));", "  else {", "    for (; !got_int; os_breakcheck()) {"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      print_line(eap->line1,", "          (eap->cmdidx == CMD_number || eap->cmdidx == CMD_pound", "           || (eap->flags & EXFLAG_NR)),"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["           || (eap->flags & EXFLAG_NR)),", "          eap->cmdidx == CMD_list || (eap->flags & EXFLAG_LIST));", "      if (++eap->line1 > eap->line2)"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["          eap->cmdidx == CMD_list || (eap->flags & EXFLAG_LIST));", "      if (++eap->line1 > eap->line2)", "        break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        break;", "      ui_flush();                  /* show one line at a time */", "    }"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    setpcmark();", "    /* put cursor at last line */", "    curwin->w_cursor.lnum = eap->line2;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  ex_no_reprint = TRUE;", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * Clear an argument list: free all file names and reset it to zero entries."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Init an argument list."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Remove a reference from an argument list."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Create a new argument list and use it for the current window."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["#if !defined(UNIX)", "/*", " * Expand the file names in the global argument list."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* Don't use 'suffixes' here.  This should work like the shell did the", "   * expansion.  Also, the vimrc file isn't read yet, thus the user"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  old_arg_files = xmalloc(sizeof(*old_arg_files) * GARGCOUNT);", "  for (i = 0; i < GARGCOUNT; ++i)", "    old_arg_files[i] = vim_strsave(GARGLIST[i].ae_fname);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  old_arg_files = xmalloc(sizeof(*old_arg_files) * GARGCOUNT);", "  for (i = 0; i < GARGCOUNT; ++i)", "    old_arg_files[i] = vim_strsave(GARGLIST[i].ae_fname);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  if (expand_wildcards(old_arg_count, old_arg_files,", "          &new_arg_file_count, &new_arg_files,", "          EW_FILE|EW_NOTFOUND|EW_ADDSLASH|EW_NOERROR) == OK"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["          &new_arg_file_count, &new_arg_files,", "          EW_FILE|EW_NOTFOUND|EW_ADDSLASH|EW_NOERROR) == OK", "      && new_arg_file_count > 0) {"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["    alist_set(&global_alist, new_arg_file_count, new_arg_files,", "        TRUE, fnum_list, fnum_len);", "    FreeWild(old_arg_count, old_arg_files);"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["    alist_set(&global_alist, new_arg_file_count, new_arg_files,", "        TRUE, fnum_list, fnum_len);", "    FreeWild(old_arg_count, old_arg_files);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * Set the argument list for the current window."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", [" */", "void alist_set(alist_T *al, int count, char_u **files, int use_curbuf, int *fnum_list, int fnum_len)", "{"], "whitespace/line_length"]
["src/nvim/ex_docmd.c", ["  {", "    for (i = 0; i < count; ++i) {", "      if (got_int) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      if (got_int) {", "        /* When adding many buffers this can take a long time.  Allow", "         * interrupting here. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["         * interrupting here. */", "        while (i < count)", "          xfree(files[i++]);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "      /* May set buffer name of a buffer previously used for the", "       * argument list, so that it's re-used by alist_add. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["       * argument list, so that it's re-used by alist_add. */", "      if (fnum_list != NULL && i < fnum_len)", "        buf_set_name(fnum_list[i], files[i]);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Add file \"fname\" to argument list \"al\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    char_u *fname,", "    int set_fnum                   /* 1: set buffer number; 2: re-use curbuf */", ")"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  if (fname == NULL)            /* don't add NULL file names */", "    return;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  if (fname == NULL)            /* don't add NULL file names */", "    return;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  AARGLIST(al)[al->al_ga.ga_len].ae_fname = fname;", "  if (set_fnum > 0)", "    AARGLIST(al)[al->al_ga.ga_len].ae_fnum ="], "readability/braces"]
["src/nvim/ex_docmd.c", ["      buflist_add(fname, BLN_LISTED | (set_fnum == 2 ? BLN_CURBUF : 0));", "  ++al->al_ga.ga_len;", "}"], "readability/increment"]
["src/nvim/ex_docmd.c", ["#if defined(BACKSLASH_IN_FILENAME)", "/*", " * Adjust slashes in file names.  Called after 'shellslash' was set."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  for (int i = 0; i < GARGCOUNT; ++i) {", "    if (GARGLIST[i].ae_fname != NULL) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    if (wp->w_alist != &global_alist) {", "      for (int i = 0; i < WARGCOUNT(wp); ++i) {", "        if (WARGLIST(wp)[i].ae_fname != NULL) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  if (!check_changed(curbuf, (p_awa ? CCGD_AW : 0)", "          | CCGD_MULTWIN", "          | (eap->forceit ? CCGD_FORCEIT : 0)"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["          | CCGD_MULTWIN", "          | (eap->forceit ? CCGD_FORCEIT : 0)", "          | CCGD_EXCMD)"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["          | (eap->forceit ? CCGD_FORCEIT : 0)", "          | CCGD_EXCMD)", ""], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Command modifier used in a wrong way."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * :sview [+command] file\tsplit window with new file, read-only"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* A \":split\" in the quickfix window works like \":new\".  Don't want two", "   * quickfix windows.  But it's OK when doing \":tab split\". */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (bt_quickfix(curbuf) && cmdmod.tab == 0) {", "    if (eap->cmdidx == CMD_split)", "      eap->cmdidx = CMD_new;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      eap->cmdidx = CMD_new;", "    if (eap->cmdidx == CMD_vsplit)", "      eap->cmdidx = CMD_vnew;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    fname = find_file_in_path(eap->arg, STRLEN(eap->arg),", "                              FNAME_MESS, TRUE, curbuf->b_ffname);", "    if (fname == NULL)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["                              FNAME_MESS, TRUE, curbuf->b_ffname);", "    if (fname == NULL)", "      goto theend;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Either open new tab page or split the window."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      do_exedit(eap, old_curwin);", "      apply_autocmds(EVENT_TABNEWENTERED, NULL, NULL, FALSE, curbuf);", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "      /* set the alternate buffer for the window we came from */", "      if (curwin != old_curwin"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      /* set the alternate buffer for the window we came from */", "      if (curwin != old_curwin", "          && win_valid(old_curwin)"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  } else if (win_split(eap->addr_count > 0 ? (int)eap->line2 : 0,", "                 *eap->cmd == 'v' ? WSP_VERT : 0) != FAIL) {", "    /* Reset 'scrollbind' when editing another file, but keep it when"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["                 *eap->cmd == 'v' ? WSP_VERT : 0) != FAIL) {", "    /* Reset 'scrollbind' when editing another file, but keep it when", "     * doing \":split\" without arguments. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Open a new tab page."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * :tabnext command"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * :tabmove command"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * :tabs command: List tabs and their contents."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  msg_start();", "  msg_scroll = TRUE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["      msg_putchar(' ');", "      if (buf_spname(wp->w_buffer) != NULL)", "        STRLCPY(IObuff, buf_spname(wp->w_buffer), IOSIZE);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        STRLCPY(IObuff, buf_spname(wp->w_buffer), IOSIZE);", "      else", "        home_replace(wp->w_buffer, wp->w_buffer->b_fname,"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        home_replace(wp->w_buffer, wp->w_buffer->b_fname,", "            IObuff, IOSIZE, TRUE);", "      msg_outtrans(IObuff);"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["        home_replace(wp->w_buffer, wp->w_buffer->b_fname,", "            IObuff, IOSIZE, TRUE);", "      msg_outtrans(IObuff);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      msg_outtrans(IObuff);", "      ui_flush();                  /* output one line at a time */", "      os_breakcheck();"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":mode\":"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":resize\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    n = eap->line2;", "    for (wp = firstwin; wp->w_next != NULL && --n > 0; wp = wp->w_next)", "      ;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    for (wp = firstwin; wp->w_next != NULL && --n > 0; wp = wp->w_next)", "      ;", "  }"], "whitespace/semicolon"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":find [+command] <file>\" command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  fname = find_file_in_path(eap->arg, STRLEN(eap->arg),", "                            FNAME_MESS, TRUE, curbuf->b_ffname);", "  if (eap->addr_count > 0) {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  if (eap->addr_count > 0) {", "    /* Repeat finding the file \"count\" times.  This matters when it", "     * appears several times in the path. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      xfree(fname);", "      fname = find_file_in_path(NULL, 0, FNAME_MESS, FALSE, curbuf->b_ffname);", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":edit <file>\" command and alikes."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    exarg_T *eap,", "    win_T *old_curwin            /* curwin before doing a split or NULL */", ")"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * \":vi\" command ends Ex mode."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["                        || eap->cmdidx == CMD_view)) {", "    exmode_active = FALSE;", "    if (*eap->arg == NUL) {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    if (*eap->arg == NUL) {", "      /* Special case:  \":global/pat/visual\\NLvi-commands\" */", "      if (global_busy) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        no_wait_return = 0;", "        need_wait_return = FALSE;", "        msg_scroll = 0;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["       || eap->cmdidx == CMD_vnew", "       ) && *eap->arg == NUL) {", "    /* \":new\" or \":tabnew\" without argument: edit an new empty buffer */"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["       ) && *eap->arg == NUL) {", "    /* \":new\" or \":tabnew\" without argument: edit an new empty buffer */", "    setpcmark();"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    (void)do_ecmd(0, NULL, NULL, eap, ECMD_ONE,", "        ECMD_HIDE + (eap->forceit ? ECMD_FORCEIT : 0),", "        old_curwin == NULL ? curwin : NULL);"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["        ECMD_HIDE + (eap->forceit ? ECMD_FORCEIT : 0),", "        old_curwin == NULL ? curwin : NULL);", "  } else if ((eap->cmdidx != CMD_split && eap->cmdidx != CMD_vsplit)"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["             || *eap->arg != NUL) {", "    /* Can't edit another file when \"curbuf_lock\" is set.  Only \":edit\"", "     * can bring us here, others are stopped earlier. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["     * can bring us here, others are stopped earlier. */", "    if (*eap->arg != NUL && curbuf_locked())", "      return;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    n = readonlymode;", "    if (eap->cmdidx == CMD_view || eap->cmdidx == CMD_sview)", "      readonlymode = TRUE;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (eap->cmdidx == CMD_view || eap->cmdidx == CMD_sview)", "      readonlymode = TRUE;", "    else if (eap->cmdidx == CMD_enew)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      readonlymode = TRUE;", "    else if (eap->cmdidx == CMD_enew)", "      readonlymode = FALSE;         /* 'readonly' doesn't make sense in an"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    else if (eap->cmdidx == CMD_enew)", "      readonlymode = FALSE;         /* 'readonly' doesn't make sense in an", "                                       empty buffer */"], "readability/multiline_comment"]
["src/nvim/ex_docmd.c", ["    else if (eap->cmdidx == CMD_enew)", "      readonlymode = FALSE;         /* 'readonly' doesn't make sense in an", "                                       empty buffer */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    else if (eap->cmdidx == CMD_enew)", "      readonlymode = FALSE;         /* 'readonly' doesn't make sense in an", "                                       empty buffer */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "          /* Reset the error/interrupt/exception state here so that", "           * aborting() returns FALSE when closing a window. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "          /* Restore the error/interrupt/exception state if not", "           * discarded by a new aborting error, interrupt, or"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    } else if (readonlymode && curbuf->b_nwindows == 1) {", "      /* When editing an already visited buffer, 'readonly' won't be set", "       * but the previous value is kept.  With \":view\" and \":sview\" we"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["       * editing the same buffer. */", "      curbuf->b_p_ro = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  } else {", "    if (eap->do_ecmd_cmd != NULL)", "      do_cmdline_cmd((char *)eap->do_ecmd_cmd);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    check_arg_idx(curwin);", "    if (n != curwin->w_arg_idx_invalid)", "      maketitle();"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * if \":split file\" worked, set alternate file name in old window to new"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["   */", "  if (old_curwin != NULL", "      && *eap->arg != NUL"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  ex_no_reprint = TRUE;", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["{", "  if (curbuf->b_ml.ml_mfp == NULL || curbuf->b_ml.ml_mfp->mf_fname == NULL)", "    MSG(_(\"No swap file\"));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    MSG(_(\"No swap file\"));", "  else", "    msg(curbuf->b_ml.ml_mfp->mf_fname);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":syncbind\" forces all 'scrollbind' windows to have the same relative"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * determine max topline"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Set all scrollbind windows to the same topline."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      y = topline - curwin->w_topline;", "      if (y > 0)", "        scrollup(y, TRUE);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      if (y > 0)", "        scrollup(y, TRUE);", "      else"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        scrollup(y, TRUE);", "      else", "        scrolldown(-y, TRUE);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      else", "        scrolldown(-y, TRUE);", "      curwin->w_scbind_pos = topline;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      cursor_correct();", "      curwin->w_redr_status = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  if (curwin->w_p_scb) {", "    did_syncbind = TRUE;", "    checkpcmark();"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      i = readfile(curbuf->b_ffname, curbuf->b_fname,", "          eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);", "    } else {"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["    } else {", "      if (vim_strchr(p_cpo, CPO_ALTREAD) != NULL)", "        (void)setaltfname(eap->arg, eap->arg, (linenr_T)1);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      i = readfile(eap->arg, NULL,", "          eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);", ""], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["          eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);", "", "    }"], "whitespace/blank_line"]
["src/nvim/ex_docmd.c", ["      if (empty && exmode_active) {", "        /* Delete the empty line that remains.  Historically ex does", "         * this but vi doesn't. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["         * this but vi doesn't. */", "        if (eap->line2 == 0)", "          lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          lnum = curbuf->b_ml.ml_line_count;", "        else", "          lnum = 1;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["#if !defined(UNIX)", "  /* for non-UNIX \":cd\" means: print current directory */", "  if (*new_dir == NUL)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  /* for non-UNIX \":cd\" means: print current directory */", "  if (*new_dir == NUL)", "    ex_pwd(NULL);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    ex_pwd(NULL);", "  else", "#endif"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  {", "    if (allbuf_locked())", "      return;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "    /* \":cd -\": Change to previous directory */", "    if (STRCMP(new_dir, \"-\") == 0) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /* Save current directory for next \":cd -\" */", "    tofree = prev_dir;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    tofree = prev_dir;", "    if (os_dirname(NameBuff, MAXPATHL) == OK)", "      prev_dir = vim_strsave(NameBuff);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      prev_dir = vim_strsave(NameBuff);", "    else", "      prev_dir = NULL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":pwd\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    msg(NameBuff);", "  } else", "    EMSG(_(\"E187: Unknown\"));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":=\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    n = curwin->w_winrow + curwin->w_wrow - msg_scrolled;", "    if (n >= 0)", "      ui_cursor_goto(n, curwin->w_wincol + curwin->w_wcol);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  case NUL: len *= 1000L; break;", "  default: EMSG2(_(e_invarg2), eap->arg); return;", "  }"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["", "/*", " * Sleep for \"msec\" milliseconds, but keep checking for a CTRL-C every second."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  switch (do_map((*cmdp == 'n') ? 2 : (*cmdp == 'u'),", "              eap->arg, mode, isabbrev)) {", "  case 1: EMSG(_(e_invarg));"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":winsize\" command (obsolete)."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (*eap->arg == 'g' || *eap->arg == Ctrl_G) {", "    /* CTRL-W g and CTRL-W CTRL-G  have an extra command character */", "    if (eap->arg[1] == NUL) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    p = eap->arg + 2;", "  } else", "    p = eap->arg + 1;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  p = skipwhite(p);", "  if (*p != NUL && *p != '\"' && eap->nextcmd == NULL)", "    EMSG(_(e_invarg));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    EMSG(_(e_invarg));", "  else if (!eap->skip) {", "    /* Pass flags on for \":vertical wincmd ]\". */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  else if (!eap->skip) {", "    /* Pass flags on for \":vertical wincmd ]\". */", "    postponed_split_flags = cmdmod.split;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Handle command that work like operators: \":delete\", \":yank\", \":>\" and \":<\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  if (VIsual_active)", "    end_visual_mode();"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  default:          /* CMD_rshift or CMD_lshift */", "    if ("], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  default:          /* CMD_rshift or CMD_lshift */", "    if (", "      (eap->cmdidx == CMD_rshift) ^ curwin->w_p_rl"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (", "      (eap->cmdidx == CMD_rshift) ^ curwin->w_p_rl", "      )"], "whitespace/indent"]
["src/nvim/ex_docmd.c", ["      (eap->cmdidx == CMD_rshift) ^ curwin->w_p_rl", "      )", "      oa.op_type = OP_RSHIFT;"], "whitespace/indent"]
["src/nvim/ex_docmd.c", ["      oa.op_type = OP_RSHIFT;", "    else", "      oa.op_type = OP_LSHIFT;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      oa.op_type = OP_LSHIFT;", "    op_shift(&oa, FALSE, eap->amount);", "    break;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":put\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  /* \":0put\" works like \":1put!\". */", "  if (eap->line2 == 0) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    eap->line2 = 1;", "    eap->forceit = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * Handle \":copy\" and \":move\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * move or copy lines from 'eap->line1'-'eap->line2' to below line 'n'"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (eap->cmdidx == CMD_move) {", "    if (do_move(eap->line1, eap->line2, n) == FAIL)", "      return;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      return;", "  } else", "    ex_copy(eap->line1, eap->line2, n);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Print the current line if flags were given to the Ex command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    print_line(curwin->w_cursor.lnum, (eap->flags & EXFLAG_NR),", "        (eap->flags & EXFLAG_LIST));", "    ex_no_reprint = TRUE;"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["        (eap->flags & EXFLAG_LIST));", "    ex_no_reprint = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":join\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (eap->line1 == eap->line2) {", "    if (eap->addr_count >= 2)       /* :2,2join does nothing */", "      return;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (eap->line1 == eap->line2) {", "    if (eap->addr_count >= 2)       /* :2,2join does nothing */", "      return;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    }", "    ++eap->line2;", "  }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  }", "  do_join(eap->line2 - eap->line1 + 1, !eap->forceit, TRUE, TRUE, true);", "  beginline(BL_WHITE | BL_FIX);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":[addr]@r\": execute register"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* Put the register in the typeahead buffer with the \"silent\" flag. */", "  if (do_execreg(c, TRUE, vim_strchr(p_cpo, CPO_EXECBUF) != NULL, TRUE)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  /* Put the register in the typeahead buffer with the \"silent\" flag. */", "  if (do_execreg(c, TRUE, vim_strchr(p_cpo, CPO_EXECBUF) != NULL, TRUE)", "      == FAIL) {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "    exec_from_reg = TRUE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * Execute from the typeahead buffer."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["     */", "    while (!stuff_empty() || typebuf.tb_len > prev_len)", "      (void)do_cmdline(NULL, getexline, NULL, DOCMD_NOWAIT|DOCMD_VERBOSE);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":!\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":undo\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  u_compute_hash(hash);", "  u_write_undo((char *) eap->arg, eap->forceit, curbuf, hash);", "}"], "whitespace/cast"]
["src/nvim/ex_docmd.c", ["  u_compute_hash(hash);", "  u_read_undo((char *) eap->arg, hash, NULL);", "}"], "whitespace/cast"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":redir\": start/stop redirection."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  if (STRICMP(eap->arg, \"END\") == 0)", "    close_redir();"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    close_redir();", "  else {", "    if (*arg == '>') {"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    close_redir();", "  else {", "    if (*arg == '>') {"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (*arg == '>') {", "      ++arg;", "      if (*arg == '>') {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      if (*arg == '>') {", "        ++arg;", "        mode = \"a\";"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        mode = \"a\";", "      } else", "        mode = \"w\";"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "      /* Expand environment variables and \"~/\". */", "      fname = expand_env_save(arg);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      fname = expand_env_save(arg);", "      if (fname == NULL)", "        return;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    } else if (*arg == '@') {", "      /* redirect to a register a-z (resp. A-Z for appending) */", "      close_redir();"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      close_redir();", "      ++arg;", "      if (valid_yank_reg(*arg, true) && *arg != '_') {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        redir_reg = *arg++;", "        if (*arg == '>' && arg[1] == '>')          /* append */", "          arg += 2;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        redir_reg = *arg++;", "        if (*arg == '>' && arg[1] == '>')          /* append */", "          arg += 2;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          arg += 2;", "        else {", "          /* Can use both \"@a\" and \"@a>\". */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          arg += 2;", "        else {", "          /* Can use both \"@a\" and \"@a>\". */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        else {", "          /* Can use both \"@a\" and \"@a>\". */", "          if (*arg == '>')"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["          /* Can use both \"@a\" and \"@a>\". */", "          if (*arg == '>')", "            arg++;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "      /* redirect to a variable */", "      close_redir();"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      if (*arg == '>') {", "        ++arg;", "        append = TRUE;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        ++arg;", "        append = TRUE;", "      } else"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        append = TRUE;", "      } else", "        append = FALSE;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      } else", "        append = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "      if (var_redir_start(skipwhite(arg), append) == OK)", "        redir_vname = 1;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    }", "    /* TODO: redirect to a buffer */", "    else"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    /* TODO: redirect to a buffer */", "    else", "      EMSG2(_(e_invarg2), eap->arg);"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["", "  /* Make sure redirection is not off.  Can happen for cmdline completion", "   * that indirectly invokes a command to catch its output. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["   * that indirectly invokes a command to catch its output. */", "  if (redir_fd != NULL", "      || redir_reg || redir_vname"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      )", "    redir_off = FALSE;", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  RedrawingDisabled = 0;", "  p_lz = FALSE;", "  validate_cursor();"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /* Reset msg_didout, so that a message that's there is overwritten. */", "  msg_didout = FALSE;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  /* Reset msg_didout, so that a message that's there is overwritten. */", "  msg_didout = FALSE;", "  msg_col = 0;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /* No need to wait after an intentional redraw. */", "  need_wait_return = FALSE;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  /* No need to wait after an intentional redraw. */", "  need_wait_return = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["  RedrawingDisabled = 0;", "  p_lz = FALSE;", "  if (eap->forceit)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  p_lz = FALSE;", "  if (eap->forceit)", "    status_redraw_all();"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    status_redraw_all();", "  else", "    status_redraw_curbuf();"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Open a file for writing for an Ex command, with some checks."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["FILE *", "open_exfile (", "    char_u *fname,"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["    int forceit,", "    char *mode          /* \"w\" for create new file or \"a\" for append */", ")"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["#ifdef UNIX", "  /* with Unix it is possible to open a directory */", "  if (os_isdir(fname)) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":mark\" and \":k\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  if (*eap->arg == NUL)                 /* No argument? */", "    EMSG(_(e_argreq));"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  if (*eap->arg == NUL)                 /* No argument? */", "    EMSG(_(e_argreq));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    EMSG(_(e_argreq));", "  else if (eap->arg[1] != NUL)          /* more than one character? */", "    EMSG(_(e_trailing));"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    EMSG(_(e_argreq));", "  else if (eap->arg[1] != NUL)          /* more than one character? */", "    EMSG(_(e_trailing));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    EMSG(_(e_trailing));", "  else {", "    pos = curwin->w_cursor;             /* save curwin->w_cursor */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    EMSG(_(e_trailing));", "  else {", "    pos = curwin->w_cursor;             /* save curwin->w_cursor */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  else {", "    pos = curwin->w_cursor;             /* save curwin->w_cursor */", "    curwin->w_cursor.lnum = eap->line2;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    beginline(BL_WHITE | BL_FIX);", "    if (setmark(*eap->arg) == FAIL)     /* set mark */", "      EMSG(_(\"E191: Argument must be a letter or forward/backward quote\"));"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    beginline(BL_WHITE | BL_FIX);", "    if (setmark(*eap->arg) == FAIL)     /* set mark */", "      EMSG(_(\"E191: Argument must be a letter or forward/backward quote\"));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      EMSG(_(\"E191: Argument must be a letter or forward/backward quote\"));", "    curwin->w_cursor = pos;             /* restore curwin->w_cursor */", "  }"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Update w_topline, w_leftcol and the cursor position."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":normal[!] {commands}\": Execute normal mode commands."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /* Count the number of characters to be escaped. */", "    for (p = eap->arg; *p != NUL; ++p) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    /* Count the number of characters to be escaped. */", "    for (p = eap->arg; *p != NUL; ++p) {", "      for (l = (*mb_ptr2len)(p) - 1; l > 0; --l)"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    for (p = eap->arg; *p != NUL; ++p) {", "      for (l = (*mb_ptr2len)(p) - 1; l > 0; --l)", "        if (*++p == K_SPECIAL             /* trailbyte K_SPECIAL or CSI */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    for (p = eap->arg; *p != NUL; ++p) {", "      for (l = (*mb_ptr2len)(p) - 1; l > 0; --l)", "        if (*++p == K_SPECIAL             /* trailbyte K_SPECIAL or CSI */"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      for (l = (*mb_ptr2len)(p) - 1; l > 0; --l)", "        if (*++p == K_SPECIAL             /* trailbyte K_SPECIAL or CSI */", "            )"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      for (l = (*mb_ptr2len)(p) - 1; l > 0; --l)", "        if (*++p == K_SPECIAL             /* trailbyte K_SPECIAL or CSI */", "            )"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      len = 0;", "      for (p = eap->arg; *p != NUL; ++p) {", "        arg[len++] = *p;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        arg[len++] = *p;", "        for (l = (*mb_ptr2len)(p) - 1; l > 0; --l) {", "          arg[len++] = *++p;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  /* Might not return to the main loop when in an event handler. */", "  update_topline_cursor();"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":startinsert\", \":startreplace\" and \":startgreplace\""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  if (eap->cmdidx == CMD_startinsert)", "    restart_edit = 'a';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    restart_edit = 'a';", "  else if (eap->cmdidx == CMD_startreplace)", "    restart_edit = 'R';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    restart_edit = 'R';", "  else", "    restart_edit = 'V';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  if (!eap->forceit) {", "    if (eap->cmdidx == CMD_startinsert)", "      restart_edit = 'i';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":stopinsert\""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Execute normal mode command \"cmd\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  find_pattern_in_path(NULL, 0, 0, FALSE, FALSE, CHECK_PATH, 1L,", "                       eap->forceit ? ACTION_SHOW_ALL : ACTION_SHOW,"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":psearch\""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  int whole = TRUE;", "  long n;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  switch (cmdnames[eap->cmdidx].cmd_name[2]) {", "  case 'e':             /* \":psearch\", \":isearch\" and \":dsearch\" */", "    if (cmdnames[eap->cmdidx].cmd_name[0] == 'p')"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  case 'e':             /* \":psearch\", \":isearch\" and \":dsearch\" */", "    if (cmdnames[eap->cmdidx].cmd_name[0] == 'p')", "      action = ACTION_GOTO;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      action = ACTION_GOTO;", "    else", "      action = ACTION_SHOW;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    break;", "  case 'i':             /* \":ilist\" and \":dlist\" */", "    action = ACTION_SHOW_ALL;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    break;", "  case 'u':             /* \":ijump\" and \":djump\" */", "    action = ACTION_GOTO;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    break;", "  default:              /* \":isplit\" and \":dsplit\" */", "    action = ACTION_SPLIT;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  }", "  if (!eap->skip)", "    find_pattern_in_path(eap->arg, 0, STRLEN(eap->arg), whole, !eap->forceit,"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":ptag\", \":ptselect\", \":ptjump\", \":ptnext\", etc."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  g_do_tagpreview = p_pvh;    /* will be reset to 0 in ex_tag_cmd() */", "  ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name + 1);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":pedit\""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":stag\", \":stselect\" and \":stjump\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":tag\", \":tselect\", \":tjump\", \":tnext\", etc."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  do_tag(eap->arg, cmd, eap->addr_count > 0 ? (int)eap->line2 : 1,", "      eap->forceit, TRUE);", "}"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["  do_tag(eap->arg, cmd, eap->addr_count > 0 ? (int)eap->line2 : 1,", "      eap->forceit, TRUE);", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * Check \"str\" for starting with a special cmdline variable."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  for (size_t i = 0; i < ARRAY_SIZE(spec_str); ++i) {", "    len = STRLEN(spec_str[i]);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Evaluate cmdline variables."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["char_u *", "eval_vars (", "    char_u *src,               /* pointer into commandline */"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["    int *escaped           /* return value has escaped white space (can", "                                 * be NULL) */", ")"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["eval_vars (", "    char_u *src,               /* pointer into commandline */", "    char_u *srcstart,          /* beginning of valid memory for src */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    char_u *src,               /* pointer into commandline */", "    char_u *srcstart,          /* beginning of valid memory for src */", "    size_t *usedlen,           /* characters after src that are used */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    char_u *srcstart,          /* beginning of valid memory for src */", "    size_t *usedlen,           /* characters after src that are used */", "    linenr_T *lnump,             /* line number for :e command, or NULL */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    size_t *usedlen,           /* characters after src that are used */", "    linenr_T *lnump,             /* line number for :e command, or NULL */", "    char_u **errormsg,         /* pointer to error message */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    linenr_T *lnump,             /* line number for :e command, or NULL */", "    char_u **errormsg,         /* pointer to error message */", "    int *escaped           /* return value has escaped white space (can"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    char_u **errormsg,         /* pointer to error message */", "    int *escaped           /* return value has escaped white space (can", "                                 * be NULL) */"], "readability/multiline_comment"]
["src/nvim/ex_docmd.c", ["    char_u **errormsg,         /* pointer to error message */", "    int *escaped           /* return value has escaped white space (can", "                                 * be NULL) */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    int *escaped           /* return value has escaped white space (can", "                                 * be NULL) */", ")"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["  *errormsg = NULL;", "  if (escaped != NULL)", "    *escaped = FALSE;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  if (escaped != NULL)", "    *escaped = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Check if there is something to do."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  ssize_t spec_idx = find_cmdline_var(src, usedlen);", "  if (spec_idx < 0) {   /* no match */", "    *usedlen = 1;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Skip when preceded with a backslash \"\\%\" and \"\\#\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    *usedlen = 0;", "    STRMOVE(src - 1, src);      /* remove backslash */", "    return NULL;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * word or WORD under cursor"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    case SPEC_HASH:             /* '#' or \"#99\": alternate file */", "      if (src[1] == '#') {          /* \"##\": the argument list */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    case SPEC_HASH:             /* '#' or \"#99\": alternate file */", "      if (src[1] == '#') {          /* \"##\": the argument list */", "        result = arg_all();"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        *usedlen = 2;", "        if (escaped != NULL)", "          *escaped = TRUE;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        if (escaped != NULL)", "          *escaped = TRUE;", "        skip_mod = TRUE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["          *escaped = TRUE;", "        skip_mod = TRUE;", "        break;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        if (*usedlen < 2) {", "          /* Should we give an error message for #<text? */", "          *usedlen = 1;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        }", "        if (lnump != NULL)", "          *lnump = ECMD_LAST;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "    case SPEC_CFILE:            /* file name under cursor */", "      result = file_name_at_cursor(FNAME_MESS|FNAME_HYP, 1L, NULL);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      }", "      resultbuf = result;                   /* remember allocated string */", "      break;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    case SPEC_ABUF:             /* buffer number for autocommand */", "      if (autocmd_bufnr <= 0) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    case SPEC_AMATCH:           /* match name for autocommand */", "      result = autocmd_match;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    case SPEC_SFILE:            /* file name for \":so\" command */", "      result = sourcing_name;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (resultlen == 0 || valid != VALID_HEAD + VALID_PATH) {", "    if (valid != VALID_HEAD + VALID_PATH)", "      /* xgettext:no-c-format */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (valid != VALID_HEAD + VALID_PATH)", "      /* xgettext:no-c-format */", "      *errormsg = (char_u *)_("], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["          \"E499: Empty file name for '%' or '#', only works with \\\":p:h\\\"\");", "    else", "      *errormsg = (char_u *)_(\"E500: Evaluates to an empty string\");"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    result = NULL;", "  } else", "    result = vim_strnsave(result, resultlen);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Concatenate all files in the argument list, separated by spaces, and return"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Do this loop two times:"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    len = 0;", "    for (idx = 0; idx < ARGCOUNT; ++idx) {", "      p = alist_name(&ARGLIST[idx]);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      if (len > 0) {", "        /* insert a space in between names */", "        if (retval != NULL)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        /* insert a space in between names */", "        if (retval != NULL)", "          retval[len] = ' ';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          retval[len] = ' ';", "        ++len;", "      }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "    /* second time: break here */", "    if (retval != NULL) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /* allocate memory */", "    retval = xmalloc(len + 1);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Expand the <sfile> string in \"arg\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  for (p = result; *p; ) {", "    if (STRNCMP(p, \"<sfile>\", 7) != 0)", "      ++p;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (STRNCMP(p, \"<sfile>\", 7) != 0)", "      ++p;", "    else {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      ++p;", "    else {", "      /* replace \"<sfile>\" with the sourced file name, and do \":\" stuff */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      ++p;", "    else {", "      /* replace \"<sfile>\" with the sourced file name, and do \":\" stuff */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    else {", "      /* replace \"<sfile>\" with the sourced file name, and do \":\" stuff */", "      repl = eval_vars(p, result, &srclen, NULL, &errormsg, NULL);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      if (errormsg != NULL) {", "        if (*errormsg)", "          emsg(errormsg);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      }", "      if (repl == NULL) {               /* no match (cannot happen) */", "        p += srclen;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      result = newres;", "      p = newres + len;                 /* continue after the match */", "    }"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":rshada\" and \":wshada\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  save_shada = p_shada;", "  if (*p_shada == NUL)", "    p_shada = (char_u *)\"'100\";"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  if (eap->cmdidx == CMD_rviminfo || eap->cmdidx == CMD_rshada) {", "    (void) shada_read_everything((char *) eap->arg, eap->forceit, false);", "  } else {"], "whitespace/cast"]
["src/nvim/ex_docmd.c", ["  } else {", "    shada_write_file((char *) eap->arg, eap->forceit);", "  }"], "whitespace/cast"]
["src/nvim/ex_docmd.c", ["", "/*", " * Make a dialog message in \"buff[DIALOG_MSG_SIZE]\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  if (fname == NULL)", "    fname = (char_u *)_(\"Untitled\");"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":behave {mswin,xterm}\""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the possible arguments of the"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  if (idx == 0)", "    return (char_u *)\"mswin\";"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    return (char_u *)\"mswin\";", "  if (idx == 1)", "    return (char_u *)\"xterm\";"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":filetype [plugin] [indent] {on,off,detect}\""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (*eap->arg == NUL) {", "    /* Print current status. */", "    smsg(\"filetype detection:%s  plugin:%s  indent:%s\","], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* Accept \"plugin\" and \"indent\" in any order. */", "  for (;; ) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    }", "  } else", "    EMSG2(_(e_invarg2), arg);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  if (eap->cmdidx == CMD_setlocal)", "    flags = OPT_LOCAL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    flags = OPT_LOCAL;", "  else if (eap->cmdidx == CMD_setglobal)", "    flags = OPT_GLOBAL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":nohlsearch\""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  // First set the marks for all lines closed/open.", "  for (linenr_T lnum = eap->line1; lnum <= eap->line2; ++lnum) {", "    if (hasFolding(lnum, NULL, NULL) == (eap->cmdidx == CMD_folddoclosed)) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      case 0:                                 arg[0] = '0'; break;", "      case(EX_EXTRA):                         arg[0] = '*'; break;", "      case(EX_EXTRA | EX_NOSPC):              arg[0] = '?'; break;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["      case(EX_EXTRA):                         arg[0] = '*'; break;", "      case(EX_EXTRA | EX_NOSPC):              arg[0] = '?'; break;", "      case(EX_EXTRA | EX_NEEDARG):            arg[0] = '+'; break;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["      case(EX_EXTRA | EX_NOSPC):              arg[0] = '?'; break;", "      case(EX_EXTRA | EX_NEEDARG):            arg[0] = '+'; break;", "      case(EX_EXTRA | EX_NOSPC | EX_NEEDARG): arg[0] = '1'; break;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["      case(EX_EXTRA | EX_NEEDARG):            arg[0] = '+'; break;", "      case(EX_EXTRA | EX_NOSPC | EX_NEEDARG): arg[0] = '1'; break;", "    }"], "whitespace/newline"]
