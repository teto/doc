["src/nvim/edit.c", ["", "/*", " * edit.c: functions for Insert mode"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Structure used to store one match for insert completion."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * All the current matches are stored in a list."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/* After using a cursor key <Enter> selects a match in the popup menu,", " * otherwise it inserts a line break. */"], "readability/old_style_comment"]
["src/nvim/edit.c", [" * otherwise it inserts a line break. */", "static int compl_enter_selects = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["", "/* When \"compl_leader\" is not NULL only matches that start with this string", " * are used. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "static int compl_get_longest = FALSE;           /* put longest common string", "                                                   in compl_leader */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["", "static int compl_get_longest = FALSE;           /* put longest common string", "                                                   in compl_leader */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "static int compl_get_longest = FALSE;           /* put longest common string", "                                                   in compl_leader */"], "readability/bool"]
["src/nvim/edit.c", ["", "static int compl_no_insert = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noinsert */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["", "static int compl_no_insert = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noinsert */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "static int compl_no_insert = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noinsert */"], "readability/bool"]
["src/nvim/edit.c", ["static int compl_no_insert = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noinsert */", "static int compl_no_select = FALSE;             /* FALSE: select & insert"], "readability/bool"]
["src/nvim/edit.c", ["                                                   TRUE: noinsert */", "static int compl_no_select = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noselect */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["                                                   TRUE: noinsert */", "static int compl_no_select = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noselect */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["                                                   TRUE: noinsert */", "static int compl_no_select = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noselect */"], "readability/bool"]
["src/nvim/edit.c", ["static int compl_no_select = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noselect */", ""], "readability/bool"]
["src/nvim/edit.c", ["", "static int compl_was_interrupted = FALSE;         /* didn't finish finding", "                                                     completions. */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["", "static int compl_was_interrupted = FALSE;         /* didn't finish finding", "                                                     completions. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "static int compl_was_interrupted = FALSE;         /* didn't finish finding", "                                                     completions. */"], "readability/bool"]
["src/nvim/edit.c", ["static pos_T compl_startpos;", "static colnr_T compl_col = 0;               /* column where the text starts", "                                             * that is being completed */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["static pos_T compl_startpos;", "static colnr_T compl_col = 0;               /* column where the text starts", "                                             * that is being completed */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["                                             * that is being completed */", "static char_u     *compl_orig_text = NULL;  /* text as it was before", "                                             * completion started */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["                                             * that is being completed */", "static char_u     *compl_orig_text = NULL;  /* text as it was before", "                                             * completion started */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "static int compl_opt_refresh_always = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["", "    set_vim_var_string(VV_INSERTMODE, (char *) s->ptr, 1);", "    set_vim_var_string(VV_CHAR, NULL, -1);"], "whitespace/cast"]
["src/nvim/edit.c", ["      if (curwin->w_topfill > 0) {", "        --curwin->w_topfill;", "      } else if (hasFolding(curwin->w_topline, NULL, &s->old_topline)) {"], "readability/increment"]
["src/nvim/edit.c", ["", "  if (curwin->w_p_rl)", "    switch (s->c) {"], "readability/braces"]
["src/nvim/edit.c", ["      // then don't insert any character.", "      if (s->c == NUL)", "        break;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Redraw for Insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  if (char_avail())", "    return;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Handle a CTRL-V or CTRL-Q typed in Insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Put a character directly onto the screen.  It's not stored in a buffer."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Undo the previous edit_putchar()."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Called when p_dollar is set: display a '$' at the end of the changed text"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  if (!redrawing())", "    return;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Call this function before moving the cursor from the normal insert position"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Insert an indent (for <Tab> or CTRL-T) or delete an indent (for CTRL-D)."], "readability/old_style_comment"]
["src/nvim/edit.c", ["void", "change_indent (", "    int type,"], "whitespace/parens"]
["src/nvim/edit.c", ["  save_p_list = curwin->w_p_list;", "  curwin->w_p_list = FALSE;", "  vc = getvcol_nolist(&curwin->w_cursor);"], "readability/bool"]
["src/nvim/edit.c", ["", "  /*", "   * For Replace mode we need to fix the replace stack later, which is only"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * If the cursor is in the indent, compute how many screen columns the"], "readability/old_style_comment"]
["src/nvim/edit.c", ["   */", "  if (new_cursor_col < 0)", "    vcol = get_indent() - vcol;"], "readability/braces"]
["src/nvim/edit.c", ["", "  /*", "   * Set the new indent.  The cursor will be put on the first non-blank."], "readability/old_style_comment"]
["src/nvim/edit.c", ["   */", "  if (type == INDENT_SET)", "    (void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);"], "readability/braces"]
["src/nvim/edit.c", ["    (void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);", "  else {", "    int save_State = State;"], "readability/braces"]
["src/nvim/edit.c", ["    (void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);", "  else {", "    int save_State = State;"], "readability/braces"]
["src/nvim/edit.c", ["", "  /*", "   * Try to put cursor on same character."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (new_cursor_col >= 0) {", "    /*", "     * When changing the indent while the cursor is touching it, reset"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     */", "    if (new_cursor_col == 0)", "      insstart_less = MAXCOL;"], "readability/braces"]
["src/nvim/edit.c", ["    new_cursor_col += curwin->w_cursor.col;", "  } else if (!(State & INSERT))", "    new_cursor_col = curwin->w_cursor.col;"], "readability/braces"]
["src/nvim/edit.c", ["    new_cursor_col = curwin->w_cursor.col;", "  else {", "    /*"], "readability/braces"]
["src/nvim/edit.c", ["    new_cursor_col = curwin->w_cursor.col;", "  else {", "    /*"], "readability/braces"]
["src/nvim/edit.c", ["  else {", "    /*", "     * Compute the screen column where the cursor should be."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * Advance the cursor until we reach the right screen column."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * May need to insert spaces to be able to position the cursor on"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * When changing the indent while the cursor is in it, reset"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  if (new_cursor_col <= 0)", "    curwin->w_cursor.col = 0;"], "readability/braces"]
["src/nvim/edit.c", ["    curwin->w_cursor.col = 0;", "  else", "    curwin->w_cursor.col = (colnr_T)new_cursor_col;"], "readability/braces"]
["src/nvim/edit.c", ["    curwin->w_cursor.col = (colnr_T)new_cursor_col;", "  curwin->w_set_curswant = TRUE;", "  changed_cline_bef_curs();"], "readability/bool"]
["src/nvim/edit.c", ["", "  /*", "   * May have to adjust the start of the insert."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    if (curwin->w_cursor.lnum == Insstart.lnum && Insstart.col != 0) {", "      if ((int)Insstart.col <= insstart_less)", "        Insstart.col = 0;"], "readability/braces"]
["src/nvim/edit.c", ["        Insstart.col = 0;", "      else", "        Insstart.col -= insstart_less;"], "readability/braces"]
["src/nvim/edit.c", ["    }", "    if ((int)ai_col <= insstart_less)", "      ai_col = 0;"], "readability/braces"]
["src/nvim/edit.c", ["      ai_col = 0;", "    else", "      ai_col -= insstart_less;"], "readability/braces"]
["src/nvim/edit.c", ["", "  /*", "   * For REPLACE mode, may have to fix the replace stack, if it's possible."], "readability/old_style_comment"]
["src/nvim/edit.c", ["      }", "      ++start_col;", "    }"], "readability/increment"]
["src/nvim/edit.c", ["", "  /*", "   * For VREPLACE mode, we also have to fix the replace stack.  In this case"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Truncate the space at the end of a line.  This is to be used only in an"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Backspace the cursor until the given column.  Handles REPLACE and VREPLACE"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    curwin->w_cursor.col--;", "    if (State & REPLACE_FLAG)", "      replace_do_bs(col);"], "readability/braces"]
["src/nvim/edit.c", ["      replace_do_bs(col);", "    else if (!del_char_after_col(col))", "      break;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * CTRL-X pressed in Insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["{", "  /* CTRL-X after CTRL-X CTRL-V doesn't do anything, so that CTRL-X", "   * CTRL-V works like CTRL-N */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (ctrl_x_mode != CTRL_X_CMDLINE) {", "    /* if the next ^X<> won't ADD nothing, then reset", "     * compl_cont_status */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     * compl_cont_status */", "    if (compl_cont_status & CONT_N_ADDS)", "      compl_cont_status |= CONT_INTRPT;"], "readability/braces"]
["src/nvim/edit.c", ["      compl_cont_status |= CONT_INTRPT;", "    else", "      compl_cont_status = 0;"], "readability/braces"]
["src/nvim/edit.c", ["", "    /* \"actual_len\" may be smaller than \"actual_compl_length\" when using", "     * thesaurus, only use the minimum when comparing. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * Rule 2: No lower case, 2nd consecutive letter converted to"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * If the same match is already present, don't add it."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Allocate a new match structure."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Link the new match structure in the list of matches."], "readability/old_style_comment"]
["src/nvim/edit.c", ["   */", "  if (compl_first_match == NULL)", "    match->cp_next = match->cp_prev = NULL;"], "readability/braces"]
["src/nvim/edit.c", ["    match->cp_next = match->cp_prev = NULL;", "  else if (dir == FORWARD) {", "    match->cp_next = compl_curr_match->cp_next;"], "readability/braces"]
["src/nvim/edit.c", ["", "  /*", "   * Find the longest common string if still doing that."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Reduce the longest common string for match \"match\"."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    ins_bytes(compl_leader + ins_compl_len());", "    ins_redraw(FALSE);", ""], "readability/bool"]
["src/nvim/edit.c", ["", "    /* When the match isn't there (to avoid matching itself) remove it", "     * again after redrawing. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     * again after redrawing. */", "    if (!had_match)", "      ins_compl_delete();"], "readability/braces"]
["src/nvim/edit.c", ["      ins_bytes(compl_leader + ins_compl_len());", "      ins_redraw(FALSE);", ""], "readability/bool"]
["src/nvim/edit.c", ["", "      /* When the match isn't there (to avoid matching itself) remove it", "       * again after redrawing. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["       * again after redrawing. */", "      if (!had_match)", "        ins_compl_delete();"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Add an array of matches to the list of matches."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/* Make the completion list cyclic.", " * Return the number of matches (excluding the original)."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (compl_first_match != NULL) {", "    /*", "     * Find the end of the list."], "readability/old_style_comment"]
["src/nvim/edit.c", ["      match = match->cp_next;", "      ++count;", "    }"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * Start completion for the complete() function."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  compl_direction = FORWARD;", "  if (startcol > curwin->w_cursor.col)", "    startcol = curwin->w_cursor.col;"], "readability/braces"]
["src/nvim/edit.c", ["", "/* \"compl_match_array\" points the currently displayed list of entries in the", " * popup menu.  It is NULL when there is no popup menu. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Remove any popup menu."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  if (!pum_wanted() || !pum_enough_matches())", "    return;"], "readability/braces"]
["src/nvim/edit.c", ["    } while (compl != NULL && compl != compl_first_match);", "    if (compl_match_arraysize == 0)", "      return;"], "readability/braces"]
["src/nvim/edit.c", ["    compl_match_array = xcalloc(compl_match_arraysize, sizeof(pumitem_T));", "    /* If the current match is the original text don't find the first", "     * match after it, don't highlight anything. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["          if (compl == compl_shown_match || did_find_shown_match) {", "            /* This item is the shown match or this is the", "             * first displayed item after the shown match. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "        if (compl->cp_text[CPT_ABBR] != NULL)", "          compl_match_array[i].pum_text ="], "readability/braces"]
["src/nvim/edit.c", ["            compl->cp_text[CPT_ABBR];", "        else", "          compl_match_array[i].pum_text = compl->cp_str;"], "readability/braces"]
["src/nvim/edit.c", ["        compl_match_array[i].pum_info = compl->cp_text[CPT_INFO];", "        if (compl->cp_text[CPT_MENU] != NULL)", "          compl_match_array[i++].pum_extra ="], "readability/braces"]
["src/nvim/edit.c", ["            compl->cp_text[CPT_MENU];", "        else", "          compl_match_array[i++].pum_extra = compl->cp_fname;"], "readability/braces"]
["src/nvim/edit.c", ["", "        /* When the original text is the shown match don't set", "         * compl_shown_match. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        if (!shown_match_ok && shown_compl != NULL) {", "          /* The shown match isn't displayed, set it to the", "           * previously displayed match. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Add any identifiers that match the given pattern in the list of dictionary"], "readability/old_style_comment"]
["src/nvim/edit.c", ["static void", "ins_compl_dictionaries (", "    char_u *dict_start,"], "whitespace/parens"]
["src/nvim/edit.c", ["  if (*dict == NUL) {", "    /* When 'dictionary' is empty and spell checking is enabled use", "     * \"spell\". */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     * \"spell\". */", "    if (!thesaurus && curwin->w_p_spell)", "      dict = (char_u *)\"spell\";"], "readability/braces"]
["src/nvim/edit.c", ["      dict = (char_u *)\"spell\";", "    else", "      return;"], "readability/braces"]
["src/nvim/edit.c", ["  save_p_scs = p_scs;", "  if (curbuf->b_p_inf)", "    p_scs = FALSE;"], "readability/braces"]
["src/nvim/edit.c", ["  if (curbuf->b_p_inf)", "    p_scs = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["", "  /* When invoked to match whole lines for CTRL-X CTRL-L adjust the pattern", "   * to only match at the start of a line.  Otherwise just match the"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    regmatch.regprog = vim_regcomp(pat, p_magic ? RE_MAGIC : 0);", "    if (regmatch.regprog == NULL)", "      goto theend;"], "readability/braces"]
["src/nvim/edit.c", ["    } else {", "      /* Expand wildcards in the dictionary name, but do not allow", "       * backticks (for security, the 'dict' option may have been set in"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      copy_option_part(&dict, buf, LSIZE, \",\");", "      if (!thesaurus && STRCMP(buf, \"spell\") == 0)", "        count = -1;"], "readability/braces"]
["src/nvim/edit.c", ["        count = -1;", "      else if (vim_strchr(buf, '`') != NULL", "               || expand_wildcards(1, &buf, &count, &files,"], "readability/braces"]
["src/nvim/edit.c", ["               || expand_wildcards(1, &buf, &count, &files,", "                   EW_FILE|EW_SILENT) != OK)", "        count = 0;"], "whitespace/alignment"]
["src/nvim/edit.c", ["               || expand_wildcards(1, &buf, &count, &files,", "                   EW_FILE|EW_SILENT) != OK)", "        count = 0;"], "whitespace/alignment"]
["src/nvim/edit.c", ["    if (count == -1) {", "      /* Complete from active spelling.  Skip \"\\<\" in the pattern, we", "       * don't use it as a RE. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["       * don't use it as a RE. */", "      if (pat[0] == '\\\\' && pat[1] == '<')", "        ptr = pat + 2;"], "readability/braces"]
["src/nvim/edit.c", ["        ptr = pat + 2;", "      else", "        ptr = pat;"], "readability/braces"]
["src/nvim/edit.c", ["      ins_compl_files(count, files, thesaurus, flags,", "          &regmatch, buf, &dir);", "      if (flags != DICT_EXACT)"], "whitespace/alignment"]
["src/nvim/edit.c", ["          &regmatch, buf, &dir);", "      if (flags != DICT_EXACT)", "        FreeWild(count, files);"], "readability/braces"]
["src/nvim/edit.c", ["    }", "    if (flags != 0)", "      break;"], "readability/braces"]
["src/nvim/edit.c", ["    }", "    /*", "     * Read dictionary file line by line."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "          /*", "           * Add the other matches on the line"], "readability/old_style_comment"]
["src/nvim/edit.c", ["          while (!got_int) {", "            /* Find start of the next word.  Skip white", "             * space and punctuation. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["            ptr = find_word_start(ptr);", "            if (*ptr == NUL || *ptr == NL)", "              break;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Find the start of the next word."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Find the end of the word.  Assumes it starts inside a word."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Find the end of the line, omitting CR and NL at the end."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  s = ptr + STRLEN(ptr);", "  while (s > ptr && (s[-1] == CAR || s[-1] == NL))", "    --s;"], "readability/braces"]
["src/nvim/edit.c", ["  while (s > ptr && (s[-1] == CAR || s[-1] == NL))", "    --s;", "  return s;"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * Free the list of completions"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  if (compl_first_match == NULL)", "    return;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Delete one character before the cursor and show the subset of the matches"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /* Deleted more than what was used to find matches or didn't finish", "   * finding all matches: need to look for matches all over again. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["   * finding all matches: need to look for matches all over again. */", "  if (curwin->w_cursor.col <= compl_col + compl_length", "      || ins_compl_need_restart())"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Called after changing \"compl_leader\"."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /* Don't let Enter select the original text when there is no popup menu.", "   * Don't let Enter select when use user function and refresh_always is set */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["   * Don't let Enter select when use user function and refresh_always is set */", "  if (compl_match_array == NULL || ins_compl_need_restart())", "    compl_enter_selects = FALSE;"], "readability/braces"]
["src/nvim/edit.c", ["  if (compl_match_array == NULL || ins_compl_need_restart())", "    compl_enter_selects = FALSE;", "}"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * Return the length of the completion, from the completion start column to"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  if (off < 0)", "    return 0;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Append one character to the match leader.  May reduce the number of"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Setup for finding completions again without leaving CTRL-X mode.  Used when"], "readability/old_style_comment"]
["src/nvim/edit.c", ["{", "  /* update screen before restart.", "   * so if complete is blocked,"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Set the first match, the original text."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Append one character to the match leader.  May reduce the number of"], "readability/old_style_comment"]
["src/nvim/edit.c", ["            || ins_compl_equal(cp, compl_leader,", "                (int)STRLEN(compl_leader))) {", "          p = cp->cp_str;"], "whitespace/alignment"]
["src/nvim/edit.c", ["            || ins_compl_equal(cp, compl_leader,", "                (int)STRLEN(compl_leader))) {", "          p = cp->cp_str;"], "whitespace/alignment"]
["src/nvim/edit.c", ["      }", "      if (p == NULL || (int)STRLEN(p) <= len)", "        return;"], "readability/braces"]
["src/nvim/edit.c", ["        return;", "    } else", "      return;"], "readability/braces"]
["src/nvim/edit.c", ["", "  /* Forget any previous 'special' messages if this is actually", "   * a ^X mode key - bar ^R, in which case we wait to see what it gives us."], "readability/old_style_comment"]
["src/nvim/edit.c", ["   */", "  if (c != Ctrl_R && vim_is_ctrl_x_key(c))", "    edit_submode_extra = NULL;"], "readability/braces"]
["src/nvim/edit.c", ["  if (ctrl_x_mode == CTRL_X_NOT_DEFINED_YET) {", "    /*", "     * We have just typed CTRL-X and aren't quite sure which CTRL-X mode"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      ctrl_x_mode = CTRL_X_SCROLL;", "      if (!(State & REPLACE_FLAG))", "        edit_submode = (char_u *)_(\" (insert) Scroll (^E/^Y)\");"], "readability/braces"]
["src/nvim/edit.c", ["        edit_submode = (char_u *)_(\" (insert) Scroll (^E/^Y)\");", "      else", "        edit_submode = (char_u *)_(\" (replace) Scroll (^E/^Y)\");"], "readability/braces"]
["src/nvim/edit.c", ["    case Ctrl_N:", "      /* ^X^P means LOCAL expansion if nothing interrupted (eg we", "       * just started ^X mode, or there were enough ^X's to cancel"], "readability/old_style_comment"]
["src/nvim/edit.c", ["       * doesn't change when going to ADDING mode  -- Acevedo */", "      if (!(compl_cont_status & CONT_INTRPT))", "        compl_cont_status |= CONT_LOCAL;"], "readability/braces"]
["src/nvim/edit.c", ["        compl_cont_status |= CONT_LOCAL;", "      else if (compl_cont_mode != 0)", "        compl_cont_status &= ~CONT_LOCAL;"], "readability/braces"]
["src/nvim/edit.c", ["    default:", "      /* If we have typed at least 2 ^X's... for modes != 0, we set", "       * compl_cont_status = 0 (eg, as if we had just started ^X"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      if (c == Ctrl_X) {", "        if (compl_cont_mode != 0)", "          compl_cont_status = 0;"], "readability/braces"]
["src/nvim/edit.c", ["          compl_cont_status = 0;", "        else", "          compl_cont_mode = CTRL_X_NOT_DEFINED_YET;"], "readability/braces"]
["src/nvim/edit.c", ["  if (compl_started || ctrl_x_mode == CTRL_X_FINISHED) {", "    /* Show error message from attempted keyword completion (probably", "     * 'Pattern not found') until another key is hit, then go back to"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        || ctrl_x_mode == CTRL_X_FINISHED) {", "      /* Get here when we have finished typing a sequence of ^N and", "       * ^P or other completion characters in CTRL-X mode.  Free up"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      if (compl_curr_match != NULL || compl_leader != NULL || c == Ctrl_E) {", "        /*", "         * If any of the original typed text has been changed, eg when"], "readability/old_style_comment"]
["src/nvim/edit.c", ["         */", "        if (compl_curr_match != NULL && compl_used_match && c != Ctrl_E)", "          ptr = compl_curr_match->cp_str;"], "readability/braces"]
["src/nvim/edit.c", ["          ptr = compl_curr_match->cp_str;", "        else", "          ptr = NULL;"], "readability/braces"]
["src/nvim/edit.c", ["", "      /*", "       * Indent now if a key was typed that is in 'cinkeys'."], "readability/old_style_comment"]
["src/nvim/edit.c", ["       */", "      if (want_cindent && in_cinkeys(KEY_COMPLETE, ' ', inindent(0)))", "        do_c_expr_indent();"], "readability/braces"]
["src/nvim/edit.c", ["    }", "  } else if (ctrl_x_mode == CTRL_X_LOCAL_MSG)", "    /* Trigger the CompleteDone event to give scripts a chance to act"], "readability/braces"]
["src/nvim/edit.c", ["  } else if (ctrl_x_mode == CTRL_X_LOCAL_MSG)", "    /* Trigger the CompleteDone event to give scripts a chance to act", "     * upon the (possibly failed) completion. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /* reset continue_* if we left expansion-mode, if we stay they'll be", "   * (re)set properly in ins_complete() */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Fix the redo buffer for the completion leader replacing some of the typed"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Loops through the list of windows, loaded-buffers or non-loaded-buffers"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    assert(wp);", "    while ((wp = (wp->w_next != NULL ? wp->w_next : firstwin)) != curwin", "           && wp->w_buffer->b_scanned)"], "readability/braces"]
["src/nvim/edit.c", ["           && wp->w_buffer->b_scanned)", "      ;", "    buf = wp->w_buffer;"], "whitespace/semicolon"]
["src/nvim/edit.c", ["    buf = wp->w_buffer;", "  } else", "    /* 'b' (just loaded buffers), 'u' (just non-loaded buffers) or 'U'"], "readability/braces"]
["src/nvim/edit.c", ["  } else", "    /* 'b' (just loaded buffers), 'u' (just non-loaded buffers) or 'U'", "     * (unlisted buffers)"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     * When completing whole lines skip unloaded buffers. */", "    while ((buf = (buf->b_next != NULL ? buf->b_next : firstbuf)) != curbuf", "           && ((flag == 'U'"], "readability/braces"]
["src/nvim/edit.c", ["               || buf->b_scanned))", "      ;", "  return buf;"], "whitespace/semicolon"]
["src/nvim/edit.c", ["", "  if (matchlist != NULL)", "    ins_compl_add_list(matchlist);"], "readability/braces"]
["src/nvim/edit.c", ["    ins_compl_add_list(matchlist);", "  else if (matchdict != NULL)", "    ins_compl_add_dict(matchdict);"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Add completions from a list."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Add completions from a dict."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    }", "    found_all = FALSE;", "    ins_buf = curbuf;"], "readability/bool"]
["src/nvim/edit.c", ["    found_new_match = FAIL;", "    set_match_pos = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["        && (!compl_started || found_all)) {", "      found_all = FALSE;", "      while (*e_cpt == ',' || *e_cpt == ' ')"], "readability/bool"]
["src/nvim/edit.c", ["      found_all = FALSE;", "      while (*e_cpt == ',' || *e_cpt == ' ')", "        e_cpt++;"], "readability/braces"]
["src/nvim/edit.c", ["        } else if (*e_cpt == 'k' || *e_cpt == 's') {", "          if (*e_cpt == 'k')", "            type = CTRL_X_DICTIONARY;"], "readability/braces"]
["src/nvim/edit.c", ["            type = CTRL_X_DICTIONARY;", "          else", "            type = CTRL_X_THESAURUS;"], "readability/braces"]
["src/nvim/edit.c", ["", "        found_all = TRUE;", "        if (type == -1)"], "readability/bool"]
["src/nvim/edit.c", ["        found_all = TRUE;", "        if (type == -1)", "          continue;"], "readability/braces"]
["src/nvim/edit.c", ["      find_pattern_in_path(compl_pattern, compl_direction,", "                           STRLEN(compl_pattern), FALSE, FALSE,", "                           ((type == CTRL_X_PATH_DEFINES"], "readability/bool"]
["src/nvim/edit.c", ["    case CTRL_X_CMDLINE:", "      if (expand_cmdline(&compl_xp, compl_pattern,", "              (int)STRLEN(compl_pattern),"], "readability/braces"]
["src/nvim/edit.c", ["      if (expand_cmdline(&compl_xp, compl_pattern,", "              (int)STRLEN(compl_pattern),", "              &num_matches, &matches) == EXPAND_OK)"], "whitespace/alignment"]
["src/nvim/edit.c", ["              (int)STRLEN(compl_pattern),", "              &num_matches, &matches) == EXPAND_OK)", "        ins_compl_add_matches(num_matches, matches, FALSE);"], "whitespace/alignment"]
["src/nvim/edit.c", ["              &num_matches, &matches) == EXPAND_OK)", "        ins_compl_add_matches(num_matches, matches, FALSE);", "      break;"], "readability/bool"]
["src/nvim/edit.c", ["      num_matches = expand_spelling(first_match_pos.lnum,", "          compl_pattern, &matches);", "      if (num_matches > 0)"], "whitespace/alignment"]
["src/nvim/edit.c", ["          compl_pattern, &matches);", "      if (num_matches > 0)", "        ins_compl_add_matches(num_matches, matches, p_ic);"], "readability/braces"]
["src/nvim/edit.c", ["      assert(ins_buf);", "      if (ins_buf->b_p_inf)", "        p_scs = FALSE;"], "readability/braces"]
["src/nvim/edit.c", ["      if (ins_buf->b_p_inf)", "        p_scs = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["      save_p_ws = p_ws;", "      if (ins_buf != curbuf)", "        p_ws = false;"], "readability/braces"]
["src/nvim/edit.c", ["        p_ws = false;", "      else if (*e_cpt == '.')", "        p_ws = true;"], "readability/braces"]
["src/nvim/edit.c", ["        if (found_new_match == FAIL) {", "          if (ins_buf == curbuf)", "            found_all = TRUE;"], "readability/braces"]
["src/nvim/edit.c", ["          if (ins_buf == curbuf)", "            found_all = TRUE;", "          break;"], "readability/bool"]
["src/nvim/edit.c", ["              // compl_length, so the next STRNCPY always works -- Acevedo", "              STRNCPY(IObuff, ptr, len);", "              ptr = ml_get_buf(ins_buf, pos->lnum + 1, false);"], "runtime/printf"]
["src/nvim/edit.c", ["            }", "            if (len == compl_length)", "              continue;"], "readability/braces"]
["src/nvim/edit.c", ["        || found_new_match != FAIL) {", "      if (got_int)", "        break;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Fill in the next completion in the current direction."], "readability/old_style_comment"]
["src/nvim/edit.c", ["static int", "ins_compl_next (", "    int allow_get_expansion,"], "whitespace/parens"]
["src/nvim/edit.c", ["", "  /* When user complete function return -1 for findstart which is next", "   * time of 'always', compl_shown_match become NULL. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["   * time of 'always', compl_shown_match become NULL. */", "  if (compl_shown_match == NULL)", "    return -1;"], "readability/braces"]
["src/nvim/edit.c", ["", "    /* If we didn't find it searching forward, and compl_shows_dir is", "     * backward, find the last match. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        && !ins_compl_equal(compl_shown_match,", "            compl_leader, (int)STRLEN(compl_leader))", "        && (compl_shown_match->cp_next == NULL"], "whitespace/alignment"]
["src/nvim/edit.c", ["        && !ins_compl_equal(compl_shown_match,", "            compl_leader, (int)STRLEN(compl_leader))", "        && (compl_shown_match->cp_next == NULL"], "whitespace/alignment"]
["src/nvim/edit.c", ["            || compl_shown_match->cp_next == compl_first_match)) {", "      while (!ins_compl_equal(compl_shown_match,", "                 compl_leader, (int)STRLEN(compl_leader))"], "readability/braces"]
["src/nvim/edit.c", ["      while (!ins_compl_equal(compl_shown_match,", "                 compl_leader, (int)STRLEN(compl_leader))", "             && compl_shown_match->cp_prev != NULL"], "whitespace/alignment"]
["src/nvim/edit.c", ["", "  if (allow_get_expansion && insert_match", "      && (!(compl_get_longest || compl_restarting) || compl_used_match))"], "readability/braces"]
["src/nvim/edit.c", ["", "  /* Repeat this for when <PageUp> or <PageDown> is typed.  But don't wrap", "   * around. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        if (advance) {", "          if (compl_shows_dir == BACKWARD)", "            compl_pending -= todo + 1;"], "readability/braces"]
["src/nvim/edit.c", ["            compl_pending -= todo + 1;", "          else", "            compl_pending += todo + 1;"], "readability/braces"]
["src/nvim/edit.c", ["      if (!compl_no_select && advance) {", "        if (compl_shows_dir == BACKWARD)", "          --compl_pending;"], "readability/braces"]
["src/nvim/edit.c", ["        if (compl_shows_dir == BACKWARD)", "          --compl_pending;", "        else"], "readability/increment"]
["src/nvim/edit.c", ["          --compl_pending;", "        else", "          ++compl_pending;"], "readability/braces"]
["src/nvim/edit.c", ["        else", "          ++compl_pending;", "      }"], "readability/increment"]
["src/nvim/edit.c", ["          compl_shown_match = compl_shown_match->cp_next;", "          --compl_pending;", "        }"], "readability/increment"]
["src/nvim/edit.c", ["          compl_shown_match = compl_shown_match->cp_prev;", "          ++compl_pending;", "        } else"], "readability/increment"]
["src/nvim/edit.c", ["          ++compl_pending;", "        } else", "          break;"], "readability/braces"]
["src/nvim/edit.c", ["", "  /* Enter will select a match when the match wasn't inserted and the popup", "   * menu is visible. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (compl_no_insert && !started) {", "    compl_enter_selects = TRUE;", "  } else {"], "readability/bool"]
["src/nvim/edit.c", ["", "  /*", "   * Show the file name for the match (if any)"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /* Check for a typed key.  Do use mappings, otherwise vim_is_ctrl_x_key()", "   * can't do its work correctly. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      (void)ins_compl_next(false, ins_compl_key2count(c),", "          c != K_UP && c != K_DOWN, in_compl_func);", "    } else {"], "whitespace/alignment"]
["src/nvim/edit.c", ["    } else {", "      /* Need to get the character to have KeyTyped set.  We'll put it", "       * back with vungetc() below.  But skip K_IGNORE. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      if (c != K_IGNORE) {", "        /* Don't interrupt completion when the character wasn't typed,", "         * e.g., when doing @q to replay keys. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["         * e.g., when doing @q to replay keys. */", "        if (c != Ctrl_R && KeyTyped)", "          compl_interrupted = TRUE;"], "readability/braces"]
["src/nvim/edit.c", ["        if (c != Ctrl_R && KeyTyped)", "          compl_interrupted = TRUE;", ""], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * Decide the direction of Insert mode complete from the key typed."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Decide the number of completions to move forward."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Do Insert mode completion."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /* If this same ctrl_x_mode has been interrupted use the text from", "     * \"compl_startpos\" to the cursor as a pattern to add a new word"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        && compl_cont_mode == ctrl_x_mode) {", "      /*", "       * it is a continued search"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        if (compl_startpos.lnum != curwin->w_cursor.lnum) {", "          /* line (probably) wrapped, set compl_startpos to the", "           * first non_blank in the line, if it is not a wordchar"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        } else {", "          /* S_IPOS was set when we inserted a word that was at the", "           * beginning of the line, which means that we'll go to SOL"], "readability/old_style_comment"]
["src/nvim/edit.c", ["            compl_startpos.col = (colnr_T)(skipwhite(", "                                               line + compl_length", "                                               + compl_startpos.col) - line);"], "whitespace/indent"]
["src/nvim/edit.c", ["                                               line + compl_length", "                                               + compl_startpos.col) - line);", "          }"], "whitespace/indent"]
["src/nvim/edit.c", ["        compl_length = curwin->w_cursor.col - (int)compl_col;", "        /* IObuff is used to add a \"word from the next line\" would we", "         * have enough space?  just being paranoid */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        compl_cont_status |= CONT_ADDING | CONT_N_ADDS;", "        if (compl_length < 1)", "          compl_cont_status &= CONT_LOCAL;"], "readability/braces"]
["src/nvim/edit.c", ["        compl_cont_status = CONT_ADDING | CONT_N_ADDS;", "      } else", "        compl_cont_status = 0;"], "readability/braces"]
["src/nvim/edit.c", ["        compl_cont_status = 0;", "    } else", "      compl_cont_status &= CONT_LOCAL;"], "readability/braces"]
["src/nvim/edit.c", ["        if (!(compl_cont_status & CONT_ADDING)) {", "          while (--startcol >= 0 && vim_isIDc(line[startcol]))", "            ;"], "readability/braces"]
["src/nvim/edit.c", ["          while (--startcol >= 0 && vim_isIDc(line[startcol]))", "            ;", "          compl_col += ++startcol;"], "whitespace/semicolon"]
["src/nvim/edit.c", ["        }", "        if (p_ic)", "          compl_pattern = str_foldcase(line + compl_col, compl_length, NULL, 0);"], "readability/braces"]
["src/nvim/edit.c", ["          compl_pattern = str_foldcase(line + compl_col, compl_length, NULL, 0);", "        else", "          compl_pattern = vim_strnsave(line + compl_col, compl_length);"], "readability/braces"]
["src/nvim/edit.c", ["        compl_pattern = xmalloc(quote_meta(NULL, line + compl_col,", "                compl_length) + 2);", "        if (!vim_iswordp(line + compl_col)"], "whitespace/alignment"]
["src/nvim/edit.c", ["                compl_length) + 2);", "        if (!vim_iswordp(line + compl_col)", "            || (compl_col > 0"], "readability/braces"]
["src/nvim/edit.c", ["                && (", "                  vim_iswordp(mb_prevptr(line, line + compl_col))", "                  )))"], "whitespace/indent"]
["src/nvim/edit.c", ["                  vim_iswordp(mb_prevptr(line, line + compl_col))", "                  )))", "          prefix = (char_u *)\"\";"], "whitespace/indent"]
["src/nvim/edit.c", ["                && (", "                  vim_iswordp(mb_prevptr(line, line + compl_col))", "                  )))"], "whitespace/indent"]
["src/nvim/edit.c", ["                  vim_iswordp(mb_prevptr(line, line + compl_col))", "                  )))", "          prefix = (char_u *)\"\";"], "whitespace/indent"]
["src/nvim/edit.c", ["                && (", "                  vim_iswordp(mb_prevptr(line, line + compl_col))", "                  )))"], "whitespace/indent"]
["src/nvim/edit.c", ["                  vim_iswordp(mb_prevptr(line, line + compl_col))", "                  )))", "          prefix = (char_u *)\"\";"], "whitespace/indent"]
["src/nvim/edit.c", ["                  vim_iswordp(mb_prevptr(line, line + compl_col))", "                  )))", "          prefix = (char_u *)\"\";"], "whitespace/parens"]
["src/nvim/edit.c", ["        if (compl_length == 1) {", "          /* Only match word with at least two chars -- webb", "           * there's no need to call quote_meta,"], "readability/old_style_comment"]
["src/nvim/edit.c", ["          compl_pattern = xmalloc(quote_meta(NULL, line + compl_col,", "                  compl_length) + 2);", "          STRCPY((char *)compl_pattern, \"\\\\<\");"], "whitespace/alignment"]
["src/nvim/edit.c", ["          (void)quote_meta(compl_pattern + 2, line + compl_col,", "              compl_length);", "        }"], "whitespace/alignment"]
["src/nvim/edit.c", ["               CTRL_X_OMNI) {", "      /*", "       * Call user defined function 'completefunc' with \"a:findstart\""], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "      /* Call 'completefunc' or 'omnifunc' and get pattern length as a", "       * string */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        EMSG2(_(e_notset), ctrl_x_mode == CTRL_X_FUNCTION", "            ? \"completefunc\" : \"omnifunc\");", "        // restore did_ai, so that adding comment leader works"], "whitespace/alignment"]
["src/nvim/edit.c", ["", "      /* Return value -2 means the user complete function wants to", "       * cancel the complete without an error."], "readability/old_style_comment"]
["src/nvim/edit.c", ["       * Return value -3 does the same as -2 and leaves CTRL-X mode.*/", "      if (col == -2)", "        return FAIL;"], "readability/braces"]
["src/nvim/edit.c", ["", "      /*", "       * Reset extended parameters of completion, when start new"], "readability/old_style_comment"]
["src/nvim/edit.c", ["       */", "      compl_opt_refresh_always = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["", "      if (col < 0)", "        col = curs_col;"], "readability/braces"]
["src/nvim/edit.c", ["      compl_col = col;", "      if (compl_col > curs_col)", "        compl_col = curs_col;"], "readability/braces"]
["src/nvim/edit.c", ["", "      /* Setup variables for completion.  Need to obtain \"line\" again,", "       * it may have become invalid. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      }", "      else", "        compl_col = spell_word_start(startcol);"], "whitespace/newline"]
["src/nvim/edit.c", ["", "    if (compl_cont_status & CONT_LOCAL)", "      edit_submode = (char_u *)_(ctrl_x_msgs[CTRL_X_LOCAL_MSG]);"], "readability/braces"]
["src/nvim/edit.c", ["      edit_submode = (char_u *)_(ctrl_x_msgs[CTRL_X_LOCAL_MSG]);", "    else", "      edit_submode = (char_u *)_(CTRL_X_MSG(ctrl_x_mode));"], "readability/braces"]
["src/nvim/edit.c", ["", "    /* If any of the original typed text has been changed we need to fix", "     * the redo buffer. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /* showmode might reset the internal line pointers, so it must", "     * be called before line = ml_get(), or when this address is no"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Find next match (and following matches)."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /* Eat the ESC that vgetc() returns after a CTRL-C to avoid leaving Insert", "   * mode. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    (void)vgetc();", "    got_int = FALSE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["    edit_submode_highl = HLF_E;", "    /* remove N_ADDS flag, so next ^X<> won't try to go to ADDING mode,", "     * because we couldn't expand anything at first place, but if we used"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "      /* The match should always have a sequence number now, this is", "       * just a safety check. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      if (compl_curr_match->cp_number != -1) {", "        /* Space for 10 text chars. + 2x10-digit no.s = 31.", "         * Translations may need more than twice that. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "        if (compl_matches > 0)", "          vim_snprintf((char *)match_ref, sizeof(match_ref),"], "readability/braces"]
["src/nvim/edit.c", ["          vim_snprintf((char *)match_ref, sizeof(match_ref),", "              _(\"match %d of %d\"),", "              compl_curr_match->cp_number, compl_matches);"], "whitespace/alignment"]
["src/nvim/edit.c", ["              _(\"match %d of %d\"),", "              compl_curr_match->cp_number, compl_matches);", "        else"], "whitespace/alignment"]
["src/nvim/edit.c", ["              compl_curr_match->cp_number, compl_matches);", "        else", "          vim_snprintf((char *)match_ref, sizeof(match_ref),"], "readability/braces"]
["src/nvim/edit.c", ["          vim_snprintf((char *)match_ref, sizeof(match_ref),", "              _(\"match %d\"),", "              compl_curr_match->cp_number);"], "whitespace/alignment"]
["src/nvim/edit.c", ["              _(\"match %d\"),", "              compl_curr_match->cp_number);", "        edit_submode_extra = match_ref;"], "whitespace/alignment"]
["src/nvim/edit.c", ["  compl_was_interrupted = compl_interrupted;", "  compl_interrupted = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * Looks in the first \"len\" chars. of \"src\" for search-metachars."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    case '[':", "      if (ctrl_x_mode == CTRL_X_DICTIONARY", "          || ctrl_x_mode == CTRL_X_THESAURUS)"], "readability/braces"]
["src/nvim/edit.c", ["    case '\\\\':", "      if (ctrl_x_mode == CTRL_X_DICTIONARY", "          || ctrl_x_mode == CTRL_X_THESAURUS)"], "readability/braces"]
["src/nvim/edit.c", ["  }", "  if (dest != NULL)", "    *dest = NUL;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Next character is interpreted literally."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  int i;", "  int hex = FALSE;", "  int octal = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["  int hex = FALSE;", "  int octal = FALSE;", "  int unicode = 0;"], "readability/bool"]
["src/nvim/edit.c", ["", "  if (got_int)", "    return Ctrl_C;"], "readability/braces"]
["src/nvim/edit.c", ["    nc = plain_vgetc();", "    if (!(State & CMDLINE)", "        && MB_BYTE2LEN_CHECK(nc) == 1"], "readability/braces"]
["src/nvim/edit.c", ["      add_to_showcmd(nc);", "    if (nc == 'x' || nc == 'X')", "      hex = TRUE;"], "readability/braces"]
["src/nvim/edit.c", ["    if (nc == 'x' || nc == 'X')", "      hex = TRUE;", "    else if (nc == 'o' || nc == 'O')"], "readability/bool"]
["src/nvim/edit.c", ["      hex = TRUE;", "    else if (nc == 'o' || nc == 'O')", "      octal = TRUE;"], "readability/braces"]
["src/nvim/edit.c", ["    else if (nc == 'o' || nc == 'O')", "      octal = TRUE;", "    else if (nc == 'u' || nc == 'U')"], "readability/bool"]
["src/nvim/edit.c", ["      octal = TRUE;", "    else if (nc == 'u' || nc == 'U')", "      unicode = nc;"], "readability/braces"]
["src/nvim/edit.c", ["      unicode = nc;", "    else {", "      if (hex"], "readability/braces"]
["src/nvim/edit.c", ["      unicode = nc;", "    else {", "      if (hex"], "readability/braces"]
["src/nvim/edit.c", ["          ) {", "        if (!ascii_isxdigit(nc))", "          break;"], "readability/braces"]
["src/nvim/edit.c", ["      } else if (octal) {", "        if (nc < '0' || nc > '7')", "          break;"], "readability/braces"]
["src/nvim/edit.c", ["      } else {", "        if (!ascii_isdigit(nc))", "          break;"], "readability/braces"]
["src/nvim/edit.c", ["", "      ++i;", "    }"], "readability/increment"]
["src/nvim/edit.c", ["", "    if (cc > 255", "        && unicode == 0"], "readability/braces"]
["src/nvim/edit.c", ["", "  --no_mapping;", "  if (nc)"], "readability/increment"]
["src/nvim/edit.c", ["  --no_mapping;", "  if (nc)", "    vungetc(nc);"], "readability/braces"]
["src/nvim/edit.c", ["    if (len > 2) {", "      if (stop_arrow() == FAIL)", "        return;"], "readability/braces"]
["src/nvim/edit.c", ["      AppendToRedobuffLit(p, -1);", "      ctrlv = FALSE;", "    }"], "readability/bool"]
["src/nvim/edit.c", ["  }", "  if (stop_arrow() == OK)", "    insertchar(c, ctrlv ? INSCHAR_CTRLV : 0, -1);"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Special characters in this context are those that need processing other"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * \"flags\": INSCHAR_FORMAT - force formatting"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Try to break the line in two or more pieces when:"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    }", "    if (do_internal)", "      internal_format(textwidth, second_indent, flags, c == NUL, c);"], "readability/braces"]
["src/nvim/edit.c", ["", "    /*", "     * Need to remove existing (middle) comment leader and insert end"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      i = curwin->w_cursor.col;", "      while (--i >= 0 && ascii_iswhite(line[i]))", "        ;"], "readability/braces"]
["src/nvim/edit.c", ["      while (--i >= 0 && ascii_iswhite(line[i]))", "        ;", "      i++;"], "whitespace/semicolon"]
["src/nvim/edit.c", ["      i = 1;", "    } else", "      i = 0;"], "readability/braces"]
["src/nvim/edit.c", ["      i = 0;", "    if (buf[i] != NUL)", "      AppendToRedobuffLit(buf + i, -1);"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Format text at the current insert position."], "readability/old_style_comment"]
["src/nvim/edit.c", ["static void", "internal_format (", "    int textwidth,"], "whitespace/parens"]
["src/nvim/edit.c", ["", "  /*", "   * When 'ai' is off we don't want a space under the cursor to be"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Repeat breaking lines, until the current line is not too long."], "readability/old_style_comment"]
["src/nvim/edit.c", ["              + char2cells(c != NUL ? c : gchar_cursor());", "    if (virtcol <= (colnr_T)textwidth)", "      break;"], "readability/braces"]
["src/nvim/edit.c", ["", "    /*", "     * Find position to break at."], "readability/old_style_comment"]
["src/nvim/edit.c", ["           || curwin->w_cursor.col >= Insstart.col) {", "      if (curwin->w_cursor.col == startcol && c != NUL)", "        cc = c;"], "readability/braces"]
["src/nvim/edit.c", ["        cc = c;", "      else", "        cc = gchar_cursor();"], "readability/braces"]
["src/nvim/edit.c", ["        foundcol = curwin->w_cursor.col;", "        if (curwin->w_cursor.col <= (colnr_T)wantcol)", "          break;"], "readability/braces"]
["src/nvim/edit.c", ["            end_foundcol = foundcol;", "            if (curwin->w_cursor.col <= (colnr_T)wantcol)", "              break;"], "readability/braces"]
["src/nvim/edit.c", ["", "        if (curwin->w_cursor.col == 0)", "          break;"], "readability/braces"]
["src/nvim/edit.c", ["      }", "      if (curwin->w_cursor.col == 0)", "        break;"], "readability/braces"]
["src/nvim/edit.c", ["", "    /*", "     * Offset between cursor position and line break is used by replace"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * adjust startcol for spaces that will be deleted and"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    curwin->w_cursor.col = foundcol;", "    while ((cc = gchar_cursor(), WHITECHAR(cc))", "           && (!fo_white_par || curwin->w_cursor.col < startcol))"], "readability/braces"]
["src/nvim/edit.c", ["    startcol -= curwin->w_cursor.col;", "    if (startcol < 0)", "      startcol = 0;"], "readability/braces"]
["src/nvim/edit.c", ["    if (State & VREPLACE_FLAG) {", "      /*", "       * In VREPLACE mode, we will backspace over the text to be"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * Split the line just before the margin."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    open_line(FORWARD, OPENLINE_DELSPACES + OPENLINE_MARKFIX", "        + (fo_white_par ? OPENLINE_KEEPTRAIL : 0)", "        + (do_comments ? OPENLINE_DO_COM : 0)"], "whitespace/alignment"]
["src/nvim/edit.c", ["        + (fo_white_par ? OPENLINE_KEEPTRAIL : 0)", "        + (do_comments ? OPENLINE_DO_COM : 0)", "        + ((flags & INSCHAR_COM_LIST) ? OPENLINE_COM_LIST : 0)"], "whitespace/alignment"]
["src/nvim/edit.c", ["        + (do_comments ? OPENLINE_DO_COM : 0)", "        + ((flags & INSCHAR_COM_LIST) ? OPENLINE_COM_LIST : 0)", "        , ((flags & INSCHAR_COM_LIST) ? second_indent : old_indent));"], "whitespace/alignment"]
["src/nvim/edit.c", ["        + ((flags & INSCHAR_COM_LIST) ? OPENLINE_COM_LIST : 0)", "        , ((flags & INSCHAR_COM_LIST) ? second_indent : old_indent));", "    if (!(flags & INSCHAR_COM_LIST))"], "whitespace/alignment"]
["src/nvim/edit.c", ["        , ((flags & INSCHAR_COM_LIST) ? second_indent : old_indent));", "    if (!(flags & INSCHAR_COM_LIST))", "      old_indent = 0;"], "readability/braces"]
["src/nvim/edit.c", ["    if (State & VREPLACE_FLAG) {", "      /*", "       * In VREPLACE mode we have backspaced over the text to be"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    } else {", "      /*", "       * Check if cursor is not past the NUL off the line, cindent"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      len = (colnr_T)STRLEN(get_cursor_line_ptr());", "      if (curwin->w_cursor.col > len)", "        curwin->w_cursor.col = len;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Called after inserting or deleting text: When 'formatoptions' includes the"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  if (!has_format_option(FO_AUTO))", "    return;"], "readability/braces"]
["src/nvim/edit.c", ["    cc = gchar_cursor();", "    if (!WHITECHAR(cc) && curwin->w_cursor.col > 0", "        && has_format_option(FO_ONE_LETTER))"], "readability/braces"]
["src/nvim/edit.c", ["", "  /* With the 'c' flag in 'formatoptions' and 't' missing: only format", "   * comments. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["   * comments. */", "  if (has_format_option(FO_WRAP_COMS) && !has_format_option(FO_WRAP)", "      && get_leader_len(old, NULL, FALSE, TRUE) == 0)"], "readability/braces"]
["src/nvim/edit.c", ["  if (has_format_option(FO_WRAP_COMS) && !has_format_option(FO_WRAP)", "      && get_leader_len(old, NULL, FALSE, TRUE) == 0)", "    return;"], "readability/bool"]
["src/nvim/edit.c", ["", "  /*", "   * May start formatting in a previous line, so that after \"x\" a word is"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (prev_line && !paragraph_start(curwin->w_cursor.lnum)) {", "    --curwin->w_cursor.lnum;", "    if (u_save_cursor() == FAIL)"], "readability/increment"]
["src/nvim/edit.c", ["    --curwin->w_cursor.lnum;", "    if (u_save_cursor() == FAIL)", "      return;"], "readability/braces"]
["src/nvim/edit.c", ["", "  /*", "   * Do the formatting and restore the cursor position.  \"saved_cursor\" will"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  saved_cursor = pos;", "  format_lines((linenr_T)-1, FALSE);", "  curwin->w_cursor = saved_cursor;"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * When an extra space was added to continue a paragraph for auto-formatting,"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Find out textwidth to be used for formatting:"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    if (curwin->w_p_nu || curwin->w_p_rnu)", "      textwidth -= 8;"], "readability/braces"]
["src/nvim/edit.c", ["  }", "  if (textwidth < 0)", "    textwidth = 0;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Put a character in the redo buffer, for when just after a CTRL-V."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * If we skipped highlighting word at cursor, do it now."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Called when starting CTRL_X_SPELL mode: Move backwards to a previous badly"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  pos_T tpos = curwin->w_cursor;", "  spell_bad_len = spell_move_to(curwin, BACKWARD, TRUE, TRUE, NULL);", "  if (curwin->w_cursor.col != tpos.col)"], "readability/bool"]
["src/nvim/edit.c", ["  spell_bad_len = spell_move_to(curwin, BACKWARD, TRUE, TRUE, NULL);", "  if (curwin->w_cursor.col != tpos.col)", "    start_arrow(&tpos);"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * stop_arrow() is called before a change is made in insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (arrow_used) {", "    Insstart = curwin->w_cursor;  //new insertion starts here", "    if (Insstart.col > Insstart_orig.col && !ins_need_undo) {"], "whitespace/comments"]
["src/nvim/edit.c", ["      // right, except when nothing was inserted yet.", "      update_Insstart_orig = FALSE;", "    }"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * Do a few things to stop inserting."], "readability/old_style_comment"]
["src/nvim/edit.c", ["static void", "stop_insert (", "    pos_T *end_insert_pos,"], "whitespace/parens"]
["src/nvim/edit.c", ["", "  /*", "   * Save the inserted text for later redo with ^@ and CTRL-A."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    last_insert_skip = new_insert_skip;", "  } else", "    xfree(ptr);"], "readability/braces"]
["src/nvim/edit.c", ["        cc = gchar_cursor();", "        if (!ascii_iswhite(cc))", "          curwin->w_cursor = tpos;"], "readability/braces"]
["src/nvim/edit.c", ["      if (ascii_iswhite(cc)) {", "        if (gchar_cursor() != NUL)", "          inc_cursor();"], "readability/braces"]
["src/nvim/edit.c", ["          inc_cursor();", "        /* If the cursor is still at the same character, also keep", "         * the \"coladd\". */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["         * the \"coladd\". */", "        if (gchar_cursor() == NUL", "            && curwin->w_cursor.lnum == tpos.lnum"], "readability/braces"]
["src/nvim/edit.c", ["      for (;; ) {", "        if (gchar_cursor() == NUL && curwin->w_cursor.col > 0)", "          --curwin->w_cursor.col;"], "readability/braces"]
["src/nvim/edit.c", ["        if (gchar_cursor() == NUL && curwin->w_cursor.col > 0)", "          --curwin->w_cursor.col;", "        cc = gchar_cursor();"], "readability/increment"]
["src/nvim/edit.c", ["        if (cc != NUL && gchar_pos(&tpos) == NUL) {", "          ++curwin->w_cursor.col;         // put cursor back on the NUL", "        }"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * Set the last inserted text to a single character."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * move cursor to start of line"], "readability/old_style_comment"]
["src/nvim/edit.c", ["{", "  if ((flags & BL_SOL) && !p_sol)", "    coladvance(curwin->w_curswant);"], "readability/braces"]
["src/nvim/edit.c", ["    coladvance(curwin->w_curswant);", "  else {", "    curwin->w_cursor.col = 0;"], "readability/braces"]
["src/nvim/edit.c", ["    coladvance(curwin->w_curswant);", "  else {", "    curwin->w_cursor.col = 0;"], "readability/braces"]
["src/nvim/edit.c", ["", "      for (ptr = get_cursor_line_ptr(); ascii_iswhite(*ptr)", "           && !((flags & BL_FIX) && ptr[1] == NUL); ++ptr)"], "readability/braces"]
["src/nvim/edit.c", ["      for (ptr = get_cursor_line_ptr(); ascii_iswhite(*ptr)", "           && !((flags & BL_FIX) && ptr[1] == NUL); ++ptr)", "        ++curwin->w_cursor.col;"], "readability/increment"]
["src/nvim/edit.c", ["           && !((flags & BL_FIX) && ptr[1] == NUL); ++ptr)", "        ++curwin->w_cursor.col;", "    }"], "readability/increment"]
["src/nvim/edit.c", ["    }", "    curwin->w_set_curswant = TRUE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * oneright oneleft cursor_down cursor_up"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  curwin->w_set_curswant = TRUE;", "  return OK;"], "readability/bool"]
["src/nvim/edit.c", ["", "    if (v == 0)", "      return FAIL;"], "readability/braces"]
["src/nvim/edit.c", ["", "    curwin->w_set_curswant = TRUE;", "    return OK;"], "readability/bool"]
["src/nvim/edit.c", ["", "  if (curwin->w_cursor.col == 0)", "    return FAIL;"], "readability/braces"]
["src/nvim/edit.c", ["", "  curwin->w_set_curswant = TRUE;", "  --curwin->w_cursor.col;"], "readability/bool"]
["src/nvim/edit.c", ["  curwin->w_set_curswant = TRUE;", "  --curwin->w_cursor.col;", ""], "readability/increment"]
["src/nvim/edit.c", ["int", "cursor_up (", "    long n,"], "whitespace/parens"]
["src/nvim/edit.c", ["    }", "    if (n >= lnum)", "      lnum = 1;"], "readability/braces"]
["src/nvim/edit.c", ["      lnum = 1;", "    else if (hasAnyFolding(curwin)) {", "      /*"], "readability/braces"]
["src/nvim/edit.c", ["    else if (hasAnyFolding(curwin)) {", "      /*", "       * Count each sequence of folded lines as one logical line."], "readability/old_style_comment"]
["src/nvim/edit.c", ["      }", "      if (lnum < 1)", "        lnum = 1;"], "readability/braces"]
["src/nvim/edit.c", ["        lnum = 1;", "    } else", "      lnum -= n;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Cursor down a number of logical lines."], "readability/old_style_comment"]
["src/nvim/edit.c", ["int", "cursor_down (", "    long n,"], "whitespace/parens"]
["src/nvim/edit.c", ["    }", "    if (lnum + n >= curbuf->b_ml.ml_line_count)", "      lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/edit.c", ["      lnum = curbuf->b_ml.ml_line_count;", "    else if (hasAnyFolding(curwin)) {", "      linenr_T last;"], "readability/braces"]
["src/nvim/edit.c", ["      while (n--) {", "        if (hasFolding(lnum, NULL, &last))", "          lnum = last + 1;"], "readability/braces"]
["src/nvim/edit.c", ["          lnum = last + 1;", "        else", "          ++lnum;"], "readability/braces"]
["src/nvim/edit.c", ["        else", "          ++lnum;", "        if (lnum >= curbuf->b_ml.ml_line_count)"], "readability/increment"]
["src/nvim/edit.c", ["          ++lnum;", "        if (lnum >= curbuf->b_ml.ml_line_count)", "          break;"], "readability/braces"]
["src/nvim/edit.c", ["      }", "      if (lnum > curbuf->b_ml.ml_line_count)", "        lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/edit.c", ["        lnum = curbuf->b_ml.ml_line_count;", "    } else", "      lnum += n;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Stuff the last inserted text in the read buffer."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  if (last)", "    *last_ptr = last;"], "readability/braces"]
["src/nvim/edit.c", ["{", "  if (last_insert == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Get last inserted string, and remove trailing <Esc>."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  if (last_insert == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/edit.c", ["  return check_abbr(c, get_cursor_line_ptr(), curwin->w_cursor.col,", "      curwin->w_cursor.lnum == Insstart.lnum ? Insstart.col : 0);", "}"], "whitespace/alignment"]
["src/nvim/edit.c", ["", "/*", " * replace-stack functions"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  *p = (char_u)c;", "  ++replace_stack_nr;", "}"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * Push a character onto the replace stack.  Handles a multi-byte character in"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  for (j = l - 1; j >= 0; --j)", "    replace_push(p[j]);"], "readability/braces"]
["src/nvim/edit.c", ["", "  for (j = l - 1; j >= 0; --j)", "    replace_push(p[j]);"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * Join the top two items on the replace stack.  This removes to \"off\"'th NUL"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  for (i = replace_stack_nr; --i >= 0; )", "    if (replace_stack[i] == NUL && off-- <= 0) {"], "readability/braces"]
["src/nvim/edit.c", ["    if (replace_stack[i] == NUL && off-- <= 0) {", "      --replace_stack_nr;", "      memmove(replace_stack + i, replace_stack + i + 1,"], "readability/increment"]
["src/nvim/edit.c", ["      memmove(replace_stack + i, replace_stack + i + 1,", "          (size_t)(replace_stack_nr - i));", "      return;"], "whitespace/alignment"]
["src/nvim/edit.c", ["", "/*", " * Pop bytes from the replace stack until a NUL is found, and insert them"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Insert bytes popped from the replace stack. \"cc\" is the first byte.  If it"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    buf[0] = cc;", "    for (i = 1; i < n; ++i)", "      buf[i] = replace_pop();"], "readability/braces"]
["src/nvim/edit.c", ["    buf[0] = cc;", "    for (i = 1; i < n; ++i)", "      buf[i] = replace_pop();"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * make the replace stack empty"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Handle doing a BS for one character."], "readability/old_style_comment"]
["src/nvim/edit.c", ["      vcol = start_vcol;", "      for (i = 0; i < ins_len; ++i) {", "        vcol += chartabsize(p + i, vcol);"], "readability/increment"]
["src/nvim/edit.c", ["    changed_bytes(curwin->w_cursor.lnum, curwin->w_cursor.col);", "  } else if (cc == 0)", "    (void)del_char_after_col(limit_col);"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Re-indent the current line, based on the current contents of it and the"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "void fix_indent(void) {", "  if (p_paste)"], "readability/braces"]
["src/nvim/edit.c", ["void fix_indent(void) {", "  if (p_paste)", "    return;"], "readability/braces"]
["src/nvim/edit.c", ["    return;", "  if (curbuf->b_p_lisp && curbuf->b_p_ai)", "    fixthisline(get_lisp_indent);"], "readability/braces"]
["src/nvim/edit.c", ["    fixthisline(get_lisp_indent);", "  else if (cindent_on())", "    do_c_expr_indent();"], "readability/braces"]
["src/nvim/edit.c", ["  while (*look) {", "    /*", "     * Find out if we want to try a match with this key, depending on"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      }", "      while (*look && *look != '>')", "        look++;"], "readability/braces"]
["src/nvim/edit.c", ["        look++;", "      while (*look == '>')", "        look++;"], "readability/braces"]
["src/nvim/edit.c", ["    }", "    /*", "     * Is it a word: \"=word\"?"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     */", "    else if (*look == '=' && look[1] != ',' && look[1] != NUL) {", "      ++look;"], "whitespace/newline"]
["src/nvim/edit.c", ["    else if (*look == '=' && look[1] != ',' && look[1] != NUL) {", "      ++look;", "      if (*look == '~') {"], "readability/increment"]
["src/nvim/edit.c", ["      if (*look == '~') {", "        icase = TRUE;", "        ++look;"], "readability/bool"]
["src/nvim/edit.c", ["        icase = TRUE;", "        ++look;", "      } else"], "readability/increment"]
["src/nvim/edit.c", ["        ++look;", "      } else", "        icase = FALSE;"], "readability/braces"]
["src/nvim/edit.c", ["      } else", "        icase = FALSE;", "      p = vim_strchr(look, ',');"], "readability/bool"]
["src/nvim/edit.c", ["      p = vim_strchr(look, ',');", "      if (p == NULL)", "        p = look + STRLEN(look);"], "readability/braces"]
["src/nvim/edit.c", ["", "          /* Just completed a word, check if it starts with \"look\".", "           * search back for the start of a word. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["          assert(p >= look && (uintmax_t)(p - look) <= SIZE_MAX);", "          if (s + (p - look) <= line + curwin->w_cursor.col", "              && (icase"], "readability/braces"]
["src/nvim/edit.c", ["        if (match && try_match_word && !try_match) {", "          /* \"0=word\": Check if there are only blanks before the", "           * word. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * Skip over \", \"."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Map Hebrew keyboard when in hkmap mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    static char_u map[26] =", "    {(char_u)hALEF /*a*/, (char_u)BET /*b*/, (char_u)hKAF /*c*/,", "     (char_u)DALET /*d*/, (char_u)-1 /*e*/, (char_u)PEIsofit /*f*/,"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    static char_u map[26] =", "    {(char_u)hALEF /*a*/, (char_u)BET /*b*/, (char_u)hKAF /*c*/,", "     (char_u)DALET /*d*/, (char_u)-1 /*e*/, (char_u)PEIsofit /*f*/,"], "whitespace/braces"]
["src/nvim/edit.c", ["    {(char_u)hALEF /*a*/, (char_u)BET /*b*/, (char_u)hKAF /*c*/,", "     (char_u)DALET /*d*/, (char_u)-1 /*e*/, (char_u)PEIsofit /*f*/,", "     (char_u)GIMEL /*g*/, (char_u)HEI /*h*/, (char_u)IUD /*i*/,"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     (char_u)DALET /*d*/, (char_u)-1 /*e*/, (char_u)PEIsofit /*f*/,", "     (char_u)GIMEL /*g*/, (char_u)HEI /*h*/, (char_u)IUD /*i*/,", "     (char_u)HET /*j*/, (char_u)KOF /*k*/, (char_u)LAMED /*l*/,"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     (char_u)GIMEL /*g*/, (char_u)HEI /*h*/, (char_u)IUD /*i*/,", "     (char_u)HET /*j*/, (char_u)KOF /*k*/, (char_u)LAMED /*l*/,", "     (char_u)MEM /*m*/, (char_u)NUN /*n*/, (char_u)SAMEH /*o*/,"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     (char_u)HET /*j*/, (char_u)KOF /*k*/, (char_u)LAMED /*l*/,", "     (char_u)MEM /*m*/, (char_u)NUN /*n*/, (char_u)SAMEH /*o*/,", "     (char_u)PEI /*p*/, (char_u)-1 /*q*/, (char_u)RESH /*r*/,"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     (char_u)MEM /*m*/, (char_u)NUN /*n*/, (char_u)SAMEH /*o*/,", "     (char_u)PEI /*p*/, (char_u)-1 /*q*/, (char_u)RESH /*r*/,", "     (char_u)ZAIN /*s*/, (char_u)TAV /*t*/, (char_u)TET /*u*/,"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     (char_u)PEI /*p*/, (char_u)-1 /*q*/, (char_u)RESH /*r*/,", "     (char_u)ZAIN /*s*/, (char_u)TAV /*t*/, (char_u)TET /*u*/,", "     (char_u)VAV /*v*/, (char_u)hSHIN /*w*/, (char_u)-1 /*x*/,"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     (char_u)ZAIN /*s*/, (char_u)TAV /*t*/, (char_u)TET /*u*/,", "     (char_u)VAV /*v*/, (char_u)hSHIN /*w*/, (char_u)-1 /*x*/,", "     (char_u)AIN /*y*/, (char_u)ZADI /*z*/};"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     (char_u)VAV /*v*/, (char_u)hSHIN /*w*/, (char_u)-1 /*x*/,", "     (char_u)AIN /*y*/, (char_u)ZADI /*z*/};", ""], "readability/old_style_comment"]
["src/nvim/edit.c", ["     (char_u)VAV /*v*/, (char_u)hSHIN /*w*/, (char_u)-1 /*x*/,", "     (char_u)AIN /*y*/, (char_u)ZADI /*z*/};", ""], "whitespace/braces"]
["src/nvim/edit.c", ["", "      if (c < 'a' || c > 'z')", "        return c;"], "readability/braces"]
["src/nvim/edit.c", ["{", "  int need_redraw = FALSE;", "  int regname;"], "readability/bool"]
["src/nvim/edit.c", ["", "  /*", "   * If we are going to wait for a character, show a '\"'."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Don't map the register name. This also prevents the mode message to be"], "readability/old_style_comment"]
["src/nvim/edit.c", ["   */", "  ++no_mapping;", "  regname = plain_vgetc();"], "readability/increment"]
["src/nvim/edit.c", ["  regname = plain_vgetc();", "  LANGMAP_ADJUST(regname, TRUE);", "  if (regname == Ctrl_R || regname == Ctrl_O || regname == Ctrl_P) {"], "readability/bool"]
["src/nvim/edit.c", ["    regname = plain_vgetc();", "    LANGMAP_ADJUST(regname, TRUE);", "  }"], "readability/bool"]
["src/nvim/edit.c", ["  }", "  --no_mapping;", ""], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * CTRL-G commands in Insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Don't map the second key. This also prevents the mode message to be"], "readability/old_style_comment"]
["src/nvim/edit.c", ["   */", "  ++no_mapping;", "  c = plain_vgetc();"], "readability/increment"]
["src/nvim/edit.c", ["  c = plain_vgetc();", "  --no_mapping;", "  switch (c) {"], "readability/increment"]
["src/nvim/edit.c", ["  case Ctrl_K:", "  case 'k': ins_up(TRUE);", "    break;"], "readability/bool"]
["src/nvim/edit.c", ["  case Ctrl_J:", "  case 'j': ins_down(TRUE);", "    break;"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * CTRL-^ in Insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * Repeating insert may take a long time.  Check for"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      line_breakcheck();", "      if (got_int)", "        *count = 0;"], "readability/braces"]
["src/nvim/edit.c", ["    }", "    stop_insert(&curwin->w_cursor, TRUE, nomove);", "    undisplay_dollar();"], "readability/bool"]
["src/nvim/edit.c", ["", "  /*", "   * The cursor should end up on the last inserted character."], "readability/old_style_comment"]
["src/nvim/edit.c", ["              && !VIsual_active", "              ))", "      && !revins_on"], "whitespace/parens"]
["src/nvim/edit.c", ["", "/*", " * Toggle language: hkmap and revins_on."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (revins_on && revins_chars && revins_scol >= 0) {", "    while (gchar_cursor() != NUL && revins_chars--)", "      ++curwin->w_cursor.col;"], "readability/braces"]
["src/nvim/edit.c", ["    while (gchar_cursor() != NUL && revins_chars--)", "      ++curwin->w_cursor.col;", "  }"], "readability/increment"]
["src/nvim/edit.c", ["    undisplay_dollar();", "  } else", "    revins_scol = -1;"], "readability/braces"]
["src/nvim/edit.c", ["  case K_KPAGEDOWN:", "    if (!(mod_mask & MOD_MASK_SHIFT))", "      break;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * <Insert> key in Insert mode: toggle insert/replace mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Pressed CTRL-O in Insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["{", "  if (State & VREPLACE_FLAG)", "    restart_edit = 'V';"], "readability/braces"]
["src/nvim/edit.c", ["    restart_edit = 'V';", "  else if (State & REPLACE_FLAG)", "    restart_edit = 'R';"], "readability/braces"]
["src/nvim/edit.c", ["    restart_edit = 'R';", "  else", "    restart_edit = 'I';"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * If the cursor is on an indent, ^T/^D insert/delete one"], "readability/old_style_comment"]
["src/nvim/edit.c", ["{", "  if (stop_arrow() == FAIL)", "    return;"], "readability/braces"]
["src/nvim/edit.c", ["", "  /*", "   * 0^D and ^^D: remove all indent."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    }", "    change_indent(INDENT_SET, 0, TRUE, 0, TRUE);", "  } else"], "readability/bool"]
["src/nvim/edit.c", ["    change_indent(INDENT_SET, 0, TRUE, 0, TRUE);", "  } else", "    change_indent(c == Ctrl_D ? INDENT_DEC : INDENT_INC, 0, TRUE, 0, TRUE);"], "readability/braces"]
["src/nvim/edit.c", ["  } else", "    change_indent(c == Ctrl_D ? INDENT_DEC : INDENT_INC, 0, TRUE, 0, TRUE);", ""], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * Delete one character for ins_bs()."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    }", "    /*", "     * In replace mode:"], "readability/old_style_comment"]
["src/nvim/edit.c", ["          char_u  *ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum,", "              TRUE);", "          int len;"], "whitespace/alignment"]
["src/nvim/edit.c", ["          char_u  *ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum,", "              TRUE);", "          int len;"], "readability/bool"]
["src/nvim/edit.c", ["          len = (int)STRLEN(ptr);", "          if (len > 0 && ptr[len - 1] == ' ')", "            ptr[len - 1] = NUL;"], "readability/braces"]
["src/nvim/edit.c", ["", "        do_join(2, FALSE, FALSE, FALSE, false);", "        if (temp == NUL && gchar_cursor() != NUL)"], "readability/bool"]
["src/nvim/edit.c", ["        do_join(2, FALSE, FALSE, FALSE, false);", "        if (temp == NUL && gchar_cursor() != NUL)", "          inc_cursor();"], "readability/braces"]
["src/nvim/edit.c", ["          inc_cursor();", "      } else", "        dec_cursor();"], "readability/braces"]
["src/nvim/edit.c", ["", "      /*", "       * In REPLACE mode we have to put back the text that was replaced"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      if (State & REPLACE_FLAG) {", "        /*", "         * Do the next ins_char() in NORMAL state, to"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        State = NORMAL;", "        /*", "         * restore characters (blanks) deleted after cursor"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      beginline(BL_WHITE);", "      if (curwin->w_cursor.col < save_col)", "        mincol = curwin->w_cursor.col;"], "readability/braces"]
["src/nvim/edit.c", ["", "    /*", "     * Handle deleting one 'shiftwidth' or 'softtabstop'."], "readability/old_style_comment"]
["src/nvim/edit.c", ["          ins_str((char_u *)\" \");", "          if ((State & REPLACE_FLAG))", "            replace_push(NUL);"], "readability/braces"]
["src/nvim/edit.c", ["          }", "          if (revins_on && gchar_cursor() == NUL)", "            break;"], "readability/braces"]
["src/nvim/edit.c", ["  }", "  if (curwin == old_curwin)", "    undisplay_dollar();"], "readability/braces"]
["src/nvim/edit.c", ["    if (dir == MSCR_DOWN || dir == MSCR_UP) {", "      if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))", "        scroll_redraw(dir,"], "readability/braces"]
["src/nvim/edit.c", ["        scroll_redraw(dir,", "            (long)(curwin->w_botline - curwin->w_topline));", "      else"], "whitespace/alignment"]
["src/nvim/edit.c", ["            (long)(curwin->w_botline - curwin->w_topline));", "      else", "        scroll_redraw(dir, 3L);"], "readability/braces"]
["src/nvim/edit.c", ["", "  curwin->w_redr_status = TRUE;", ""], "readability/bool"]
["src/nvim/edit.c", ["", "  if ((fdo_flags & FDO_HOR) && KeyTyped)", "    foldOpenCursor();"], "readability/braces"]
["src/nvim/edit.c", ["", "  if ((fdo_flags & FDO_HOR) && KeyTyped)", "    foldOpenCursor();"], "readability/braces"]
["src/nvim/edit.c", ["  tpos = curwin->w_cursor;", "  if (c == K_C_HOME)", "    curwin->w_cursor.lnum = 1;"], "readability/braces"]
["src/nvim/edit.c", ["", "  if ((fdo_flags & FDO_HOR) && KeyTyped)", "    foldOpenCursor();"], "readability/braces"]
["src/nvim/edit.c", ["  tpos = curwin->w_cursor;", "  if (c == K_C_END)", "    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/edit.c", ["    revins_legal++;", "    if (revins_chars)", "      revins_chars--;"], "readability/braces"]
["src/nvim/edit.c", ["  tpos = curwin->w_cursor;", "  if (cursor_up(1L, TRUE) == OK) {", "    if (startcol)"], "readability/bool"]
["src/nvim/edit.c", ["  if (cursor_up(1L, TRUE) == OK) {", "    if (startcol)", "      coladvance(getvcol_nolist(&Insstart));"], "readability/braces"]
["src/nvim/edit.c", ["      coladvance(getvcol_nolist(&Insstart));", "    if (old_topline != curwin->w_topline", "        || old_topfill != curwin->w_topfill"], "readability/braces"]
["src/nvim/edit.c", ["  tpos = curwin->w_cursor;", "  if (cursor_down(1L, TRUE) == OK) {", "    if (startcol)"], "readability/bool"]
["src/nvim/edit.c", ["  if (cursor_down(1L, TRUE) == OK) {", "    if (startcol)", "      coladvance(getvcol_nolist(&Insstart));"], "readability/braces"]
["src/nvim/edit.c", ["      coladvance(getvcol_nolist(&Insstart));", "    if (old_topline != curwin->w_topline", "        || old_topfill != curwin->w_topfill"], "readability/braces"]
["src/nvim/edit.c", ["", "  /*", "   * Insert the first space with ins_char().\tIt will delete one char in"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * When 'expandtab' not set: Replace spaces by TABs where possible."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * Get the current line.  For VREPLACE mode, don't make real changes"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    while (fpos.col > 0 && ascii_iswhite(ptr[-1])) {", "      --fpos.col;", "      --ptr;"], "readability/increment"]
["src/nvim/edit.c", ["      --fpos.col;", "      --ptr;", "    }"], "readability/increment"]
["src/nvim/edit.c", ["      i = lbr_chartabsize(NULL, (char_u *)\"\\t\", vcol);", "      if (vcol + i > want_vcol)", "        break;"], "readability/braces"]
["src/nvim/edit.c", ["      }", "      ++fpos.col;", "      ++ptr;"], "readability/increment"]
["src/nvim/edit.c", ["      ++fpos.col;", "      ++ptr;", "      vcol += i;"], "readability/increment"]
["src/nvim/edit.c", ["        vcol += lbr_chartabsize(line, ptr, vcol);", "        ++ptr;", "        ++repl_off;"], "readability/increment"]
["src/nvim/edit.c", ["        ++ptr;", "        ++repl_off;", "      }"], "readability/increment"]
["src/nvim/edit.c", ["", "      /*", "       * In VREPLACE mode, we haven't changed anything yet.  Do it now by"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        ins_bytes_len(saved_line + change_col,", "            cursor->col - change_col);", "      }"], "whitespace/alignment"]
["src/nvim/edit.c", ["", "    if (State & VREPLACE_FLAG)", "      xfree(saved_line);"], "readability/braces"]
["src/nvim/edit.c", ["", "  /*", "   * Strange Vi behaviour: In Replace mode, typing a NL will not delete the"], "readability/old_style_comment"]
["src/nvim/edit.c", ["   */", "  if ((State & REPLACE_FLAG)", "      && !(State & VREPLACE_FLAG)"], "readability/braces"]
["src/nvim/edit.c", ["", "  /*", "   * In VREPLACE mode, a NL replaces the rest of the line, and starts"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Handle digraph in insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    clear_showcmd();", "    insert_special(c, TRUE, FALSE);", "    return NUL;"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * Handle CTRL-E and CTRL-Y in Insert mode: copy char from other line."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  }", "  if ((colnr_T)temp > curwin->w_virtcol)", "    ptr = prev_ptr;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * CTRL-Y or CTRL-E typed in Insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (ctrl_x_mode == CTRL_X_SCROLL) {", "    if (c == Ctrl_Y)", "      scrolldown_clamp();"], "readability/braces"]
["src/nvim/edit.c", ["      scrolldown_clamp();", "    else", "      scrollup_clamp();"], "readability/braces"]
["src/nvim/edit.c", ["      curbuf->b_p_tw = -1;", "      insert_special(c, TRUE, FALSE);", "      curbuf->b_p_tw = tw_save;"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * Try to do some very smart auto-indenting."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * do some very smart indenting when entering '{' or '}'"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (((did_si || can_si_back) && c == '{') || (can_si && c == '}')) {", "    /*", "     * for '}' set indent equal to indent of line containing matching '{'"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      old_pos = curwin->w_cursor;", "      /*", "       * If the matching '{' has a ')' immediately before it (ignoring"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      curwin->w_cursor.col = i;", "      if (ptr[i] == ')' && (pos = findmatch(NULL, '(')) != NULL)", "        curwin->w_cursor = *pos;"], "readability/braces"]
["src/nvim/edit.c", ["      curwin->w_cursor = old_pos;", "      if (State & VREPLACE_FLAG)", "        change_indent(INDENT_SET, i, FALSE, NUL, TRUE);"], "readability/braces"]
["src/nvim/edit.c", ["      if (State & VREPLACE_FLAG)", "        change_indent(INDENT_SET, i, FALSE, NUL, TRUE);", "      else"], "readability/bool"]
["src/nvim/edit.c", ["        change_indent(INDENT_SET, i, FALSE, NUL, TRUE);", "      else", "        (void)set_indent(i, SIN_CHANGED);"], "readability/braces"]
["src/nvim/edit.c", ["    } else if (curwin->w_cursor.col > 0) {", "      /*", "       * when inserting '{' after \"O\" reduce indent, but not"], "readability/old_style_comment"]
["src/nvim/edit.c", ["       */", "      temp = TRUE;", "      if (c == '{' && can_si_back && curwin->w_cursor.lnum > 1) {"], "readability/bool"]
["src/nvim/edit.c", ["        }", "        if (get_indent() >= i)", "          temp = FALSE;"], "readability/braces"]
["src/nvim/edit.c", ["        if (get_indent() >= i)", "          temp = FALSE;", "        curwin->w_cursor = old_pos;"], "readability/bool"]
["src/nvim/edit.c", ["      }", "      if (temp)", "        shift_line(TRUE, FALSE, 1, TRUE);"], "readability/braces"]
["src/nvim/edit.c", ["      if (temp)", "        shift_line(TRUE, FALSE, 1, TRUE);", "    }"], "readability/bool"]
["src/nvim/edit.c", ["", "  /*", "   * set indent of '#' always to 0"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Get the value that w_virtcol would have when 'list' is off."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Handle the InsertCharPre autocommand."], "readability/old_style_comment"]
