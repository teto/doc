["src/nvim/spellfile.c", ["#ifndef UNIX            // it's in os/unix_defs.h for Unix", "# include <time.h>      // for time_t", "#endif"], "build/include_order"]
["src/nvim/spellfile.c", ["  uint16_t wn_flags;            // WF_ flags", "  short wn_region;              // region mask", ""], "runtime/int"]
["src/nvim/spellfile.c", ["  char buf[VIMSPELLMAGICL];", "  SPELL_READ_BYTES(buf, VIMSPELLMAGICL, fd, ;);", "  if (memcmp(buf, VIMSPELLMAGIC, VIMSPELLMAGICL) != 0) {"], "whitespace/newline"]
["src/nvim/spellfile.c", ["slang_T *", "spell_load_file (", "    char_u *fname,"], "whitespace/parens"]
["src/nvim/spellfile.c", ["  if (fd == NULL) {", "    if (!silent)", "      EMSG2(_(e_notopen), fname);"], "readability/braces"]
["src/nvim/spellfile.c", ["      EMSG2(_(e_notopen), fname);", "    else if (p_verbose > 2) {", "      verbose_enter();"], "readability/braces"]
["src/nvim/spellfile.c", ["    lp->sl_add = strstr((char *)path_tail(fname), SPL_FNAME_ADD) != NULL;", "  } else", "    lp = old_lp;"], "readability/braces"]
["src/nvim/spellfile.c", ["    n = getc(fd);                           // <sectionID> or <sectionend>", "    if (n == SN_END)", "      break;"], "readability/braces"]
["src/nvim/spellfile.c", ["    len = get4c(fd);                                    // <sectionlen>", "    if (len < 0)", "      goto truncerr;"], "readability/braces"]
["src/nvim/spellfile.c", ["      lp->sl_info = READ_STRING(fd, len);               // <infotext>", "      if (lp->sl_info == NULL)", "        goto endFAIL;"], "readability/braces"]
["src/nvim/spellfile.c", ["      lp->sl_midword = READ_STRING(fd, len);            // <midword>", "      if (lp->sl_midword == NULL)", "        goto endFAIL;"], "readability/braces"]
["src/nvim/spellfile.c", ["      p = READ_STRING(fd, len);                         // <mapstr>", "      if (p == NULL)", "        goto endFAIL;"], "readability/braces"]
["src/nvim/spellfile.c", ["      lp->sl_syllable = READ_STRING(fd, len);           // <syllable>", "      if (lp->sl_syllable == NULL)", "        goto endFAIL;"], "readability/braces"]
["src/nvim/spellfile.c", ["        goto endFAIL;", "      if (init_syl_tab(lp) == FAIL)", "        goto endFAIL;"], "readability/braces"]
["src/nvim/spellfile.c", ["      }", "      while (--len >= 0)", "        if (getc(fd) < 0)"], "readability/braces"]
["src/nvim/spellfile.c", ["      while (--len >= 0)", "        if (getc(fd) < 0)", "          goto truncerr;"], "readability/braces"]
["src/nvim/spellfile.c", ["    }", "    if (res == SP_OTHERERROR)", "      goto endFAIL;"], "readability/braces"]
["src/nvim/spellfile.c", ["endFAIL:", "  if (lang != NULL)", "    // truncating the name signals the error to spell_load_lang()"], "readability/braces"]
["src/nvim/spellfile.c", ["    *lang = NUL;", "  if (lp != NULL && old_lp == NULL)", "    slang_free(lp);"], "readability/braces"]
["src/nvim/spellfile.c", ["endOK:", "  if (fd != NULL)", "    fclose(fd);"], "readability/braces"]
["src/nvim/spellfile.c", ["      idxs[arridx[depth]] = wordcount[depth];", "      if (depth > 0)", "        wordcount[depth - 1] += wordcount[depth];"], "readability/braces"]
["src/nvim/spellfile.c", ["", "      --depth;", "      fast_breakcheck();"], "readability/increment"]
["src/nvim/spellfile.c", ["      n = arridx[depth] + curi[depth];", "      ++curi[depth];", ""], "readability/increment"]
["src/nvim/spellfile.c", ["        // End of word, count it.", "        ++wordcount[depth];", ""], "readability/increment"]
["src/nvim/spellfile.c", ["        while (byts[n + 1] == 0) {", "          ++n;", "          ++curi[depth];"], "readability/increment"]
["src/nvim/spellfile.c", ["          ++n;", "          ++curi[depth];", "        }"], "readability/increment"]
["src/nvim/spellfile.c", ["        // Normal char, go one level deeper to count the words.", "        ++depth;", "        arridx[depth] = idxs[n];"], "readability/increment"]
["src/nvim/spellfile.c", ["  // Do this for all languages that support sound folding.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spellfile.c", ["      // <SUGHEADER>: <fileID> <versionnr> <timestamp>", "      for (i = 0; i < VIMSUGMAGICL; ++i)", "        buf[i] = getc(fd);                              // <fileID>"], "readability/braces"]
["src/nvim/spellfile.c", ["      // <SUGHEADER>: <fileID> <versionnr> <timestamp>", "      for (i = 0; i < VIMSUGMAGICL; ++i)", "        buf[i] = getc(fd);                              // <fileID>"], "readability/increment"]
["src/nvim/spellfile.c", ["        EMSG2(_(\"E778: This does not look like a .sug file: %s\"),", "            slang->sl_fname);", "        goto nextone;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["        EMSG2(_(\"E779: Old .sug file, needs to be updated: %s\"),", "            slang->sl_fname);", "        goto nextone;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["        EMSG2(_(\"E780: .sug file is for newer version of Vim: %s\"),", "            slang->sl_fname);", "        goto nextone;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["        EMSG2(_(\"E781: .sug file doesn't match .spl file: %s\"),", "            slang->sl_fname);", "        goto nextone;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["        EMSG2(_(\"E782: error while reading .sug file: %s\"),", "            slang->sl_fname);", "        slang_clear_sug(slang);"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["      wcount = get4c(fd);", "      if (wcount < 0)", "        goto someerror;"], "readability/braces"]
["src/nvim/spellfile.c", ["      ga_init(&ga, 1, 100);", "      for (wordnr = 0; wordnr < wcount; ++wordnr) {", "        ga.ga_len = 0;"], "readability/increment"]
["src/nvim/spellfile.c", ["          GA_APPEND(char_u, &ga, c);", "          if (c == NUL)", "            break;"], "readability/braces"]
["src/nvim/spellfile.c", ["nextone:", "      if (fd != NULL)", "        fclose(fd);"], "readability/braces"]
["src/nvim/spellfile.c", ["  *cntp = cnt;", "  if (cnt == 0)", "    return NULL;            // nothing to read, return NULL"], "readability/braces"]
["src/nvim/spellfile.c", ["  str = READ_STRING(fd, cnt);", "  if (str == NULL)", "    *cntp = SP_OTHERERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["  }", "  SPELL_READ_NONNUL_BYTES((char *)lp->sl_regions, (size_t)len, fd, ;);", "  lp->sl_regions[len] = NUL;"], "whitespace/newline"]
["src/nvim/spellfile.c", ["  flags = read_cnt_string(fd, 1, &flagslen);", "  if (flagslen < 0)", "    return flagslen;"], "readability/braces"]
["src/nvim/spellfile.c", ["  // Set the word-char flags and fill SPELL_ISUPPER() table.", "  if (flags != NULL && fol != NULL)", "    set_spell_charflags(flags, flagslen, fol);"], "readability/braces"]
["src/nvim/spellfile.c", ["  // When <charflagslen> is zero then <fcharlen> must also be zero.", "  if ((flags == NULL) != (fol == NULL))", "    return SP_FORMERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["      buf[0] = '^';  // always match at one position only", "      SPELL_READ_NONNUL_BYTES(buf + 1, (size_t)n, fd, ;);", "      buf[n + 1] = NUL;"], "whitespace/newline"]
["src/nvim/spellfile.c", ["  cnt = get2c(fd);                                      // <repcount>", "  if (cnt < 0)", "    return SP_TRUNCERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["  // <rep> : <repfromlen> <repfrom> <reptolen> <repto>", "  for (; gap->ga_len < cnt; ++gap->ga_len) {", "    int c;"], "readability/increment"]
["src/nvim/spellfile.c", ["    ftp->ft_from = read_cnt_string(fd, 1, &c);", "    if (c < 0)", "      return c;"], "readability/braces"]
["src/nvim/spellfile.c", ["      return c;", "    if (c == 0)", "      return SP_FORMERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["      xfree(ftp->ft_from);", "      if (c < 0)", "        return c;"], "readability/braces"]
["src/nvim/spellfile.c", ["  // Fill the first-index table.", "  for (int i = 0; i < 256; ++i) {", "    first[i] = -1;"], "readability/increment"]
["src/nvim/spellfile.c", ["  }", "  for (int i = 0; i < gap->ga_len; ++i) {", "    ftp = &((fromto_T *)gap->ga_data)[i];"], "readability/increment"]
["src/nvim/spellfile.c", ["    ftp = &((fromto_T *)gap->ga_data)[i];", "    if (first[*ftp->ft_from] == -1)", "      first[*ftp->ft_from] = i;"], "readability/braces"]
["src/nvim/spellfile.c", ["  cnt = get2c(fd);                              // <salcount>", "  if (cnt < 0)", "    return SP_TRUNCERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["    ccnt = getc(fd);                            // <salfromlen>", "    if (ccnt < 0)", "      return SP_TRUNCERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["    int i = 0;", "    for (; i < ccnt; ++i) {", "      c = getc(fd);                             // <salfrom>"], "readability/increment"]
["src/nvim/spellfile.c", ["      c = getc(fd);                             // <salfrom>", "      if (vim_strchr((char_u *)\"0123456789(-<^$\", c) != NULL)", "        break;"], "readability/braces"]
["src/nvim/spellfile.c", ["      smp->sm_oneof = p;", "      for (++i; i < ccnt; ++i) {", "        c = getc(fd);                           // <salfrom>"], "readability/increment"]
["src/nvim/spellfile.c", ["        c = getc(fd);                           // <salfrom>", "        if (c == ')')", "          break;"], "readability/braces"]
["src/nvim/spellfile.c", ["      *p++ = NUL;", "      if (++i < ccnt)", "        c = getc(fd);"], "readability/braces"]
["src/nvim/spellfile.c", ["        c = getc(fd);", "    } else", "      smp->sm_oneof = NULL;"], "readability/braces"]
["src/nvim/spellfile.c", ["    // Read one word at a time.", "    for (i = 0;; ++i) {", "      c = getc(fd);"], "readability/increment"]
["src/nvim/spellfile.c", ["      c = getc(fd);", "      if (c == EOF)", "        return SP_TRUNCERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["      word[i] = c;", "      if (word[i] == NUL)", "        break;"], "readability/braces"]
["src/nvim/spellfile.c", ["        break;", "      if (i == MAXWLEN - 1)", "        return SP_FORMERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["  from = read_cnt_string(fd, 2, &cnt);", "  if (cnt < 0)", "    return cnt;"], "readability/braces"]
["src/nvim/spellfile.c", ["  // Store the info in slang->sl_sal and/or slang->sl_sal_first.", "  if (from != NULL && to != NULL)", "    res = set_sofo(slang, from, to);"], "readability/braces"]
["src/nvim/spellfile.c", ["    res = set_sofo(slang, from, to);", "  else if (from != NULL || to != NULL)", "    res = SP_FORMERROR;        // only one of two strings is an error"], "readability/braces"]
["src/nvim/spellfile.c", ["    res = SP_FORMERROR;        // only one of two strings is an error", "  else", "    res = 0;"], "readability/braces"]
["src/nvim/spellfile.c", ["", "  if (todo < 2)", "    return SP_FORMERROR;        // need at least two bytes"], "readability/braces"]
["src/nvim/spellfile.c", ["", "  --todo;", "  c = getc(fd);                                         // <compmax>"], "readability/increment"]
["src/nvim/spellfile.c", ["  c = getc(fd);                                         // <compmax>", "  if (c < 2)", "    c = MAXWLEN;"], "readability/braces"]
["src/nvim/spellfile.c", ["", "  --todo;", "  c = getc(fd);                                         // <compminlen>"], "readability/increment"]
["src/nvim/spellfile.c", ["  c = getc(fd);                                         // <compminlen>", "  if (c < 1)", "    c = 0;"], "readability/braces"]
["src/nvim/spellfile.c", ["", "  --todo;", "  c = getc(fd);                                         // <compsylmax>"], "readability/increment"]
["src/nvim/spellfile.c", ["  c = getc(fd);                                         // <compsylmax>", "  if (c < 1)", "    c = MAXWLEN;"], "readability/braces"]
["src/nvim/spellfile.c", ["  c = getc(fd);                                         // <compoptions>", "  if (c != 0)", "    ungetc(c, fd);          // be backwards compatible with Vim 7.0b"], "readability/braces"]
["src/nvim/spellfile.c", ["    ungetc(c, fd);          // be backwards compatible with Vim 7.0b", "  else {", "    --todo;"], "readability/braces"]
["src/nvim/spellfile.c", ["    ungetc(c, fd);          // be backwards compatible with Vim 7.0b", "  else {", "    --todo;"], "readability/braces"]
["src/nvim/spellfile.c", ["  else {", "    --todo;", "    c = getc(fd);           // only use the lower byte for now"], "readability/increment"]
["src/nvim/spellfile.c", ["    c = getc(fd);           // only use the lower byte for now", "    --todo;", "    slang->sl_compoptions = c;"], "readability/increment"]
["src/nvim/spellfile.c", ["      // <comppatlen> <comppattext>", "      if (cnt < 0)", "        return cnt;"], "readability/braces"]
["src/nvim/spellfile.c", ["  }", "  if (todo < 0)", "    return SP_FORMERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["      // [abc] item set \"atstart\" to 2 and copy up to the ']'.", "      if (c == '[')", "        atstart = 2;"], "readability/braces"]
["src/nvim/spellfile.c", ["        atstart = 2;", "      else if (c == ']')", "        atstart = 0;"], "readability/braces"]
["src/nvim/spellfile.c", ["        atstart = 0;", "      else {", "        if (!byte_in_str(slang->sl_compstartflags, c)) {"], "readability/braces"]
["src/nvim/spellfile.c", ["        atstart = 0;", "      else {", "        if (!byte_in_str(slang->sl_compstartflags, c)) {"], "readability/braces"]
["src/nvim/spellfile.c", ["        }", "        if (atstart == 1)", "          atstart = 0;"], "readability/braces"]
["src/nvim/spellfile.c", ["        crp = NULL;", "      } else", "        *crp++ = c;"], "readability/braces"]
["src/nvim/spellfile.c", ["", "  if (crp != NULL)", "    *crp = NUL;"], "readability/braces"]
["src/nvim/spellfile.c", ["  xfree(pat);", "  if (slang->sl_compprog == NULL)", "    return SP_FORMERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["  sfirst = lp->sl_sal_first;", "  for (int i = 0; i < 256; ++i) {", "    sfirst[i] = -1;"], "readability/increment"]
["src/nvim/spellfile.c", ["static int", "spell_read_tree (", "    FILE *fd,"], "whitespace/parens"]
["src/nvim/spellfile.c", ["    idx = read_tree_node(fd, bp, ip, len, 0, prefixtree, prefixcnt);", "    if (idx < 0)", "      return idx;"], "readability/braces"]
["src/nvim/spellfile.c", ["static idx_T", "read_tree_node (", "    FILE *fd,"], "whitespace/parens"]
["src/nvim/spellfile.c", ["  len = getc(fd);                                       // <siblingcount>", "  if (len <= 0)", "    return SP_TRUNCERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["", "  if (startidx + len >= maxidx)", "    return SP_FORMERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["  // Read the byte values, flag/region bytes and shared indexes.", "  for (i = 1; i <= len; ++i) {", "    c = getc(fd);                                       // <byte>"], "readability/increment"]
["src/nvim/spellfile.c", ["    c = getc(fd);                                       // <byte>", "    if (c < 0)", "      return SP_TRUNCERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["          // shifted up 24 bits.", "          if (c == BY_FLAGS)", "            c = getc(fd) << 24;                         // <pflags>"], "readability/braces"]
["src/nvim/spellfile.c", ["            c = getc(fd) << 24;                         // <pflags>", "          else", "            c = 0;"], "readability/braces"]
["src/nvim/spellfile.c", ["          n = get2c(fd);                                // <prefcondnr>", "          if (n >= maxprefcondnr)", "            return SP_FORMERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["          c = getc(fd);                                 // <flags>", "          if (c2 == BY_FLAGS2)", "            c = (getc(fd) << 8) + c;                    // <flags2>"], "readability/braces"]
["src/nvim/spellfile.c", ["            c = (getc(fd) << 8) + c;                    // <flags2>", "          if (c & WF_REGION)", "            c = (getc(fd) << 16) + c;                   // <region>"], "readability/braces"]
["src/nvim/spellfile.c", ["            c = (getc(fd) << 16) + c;                   // <region>", "          if (c & WF_AFX)", "            c = (getc(fd) << 24) + c;                   // <affixID>"], "readability/braces"]
["src/nvim/spellfile.c", ["        c = 0;", "      } else { // c == BY_INDEX", "        // <nodeidx>"], "whitespace/comments"]
["src/nvim/spellfile.c", ["        n = get3c(fd);", "        if (n < 0 || n >= maxidx)", "          return SP_FORMERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["  // remove SHARED_MASK)", "  for (i = 1; i <= len; ++i)", "    if (byts[startidx + i] != 0) {"], "readability/braces"]
["src/nvim/spellfile.c", ["  // remove SHARED_MASK)", "  for (i = 1; i <= len; ++i)", "    if (byts[startidx + i] != 0) {"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (byts[startidx + i] != 0) {", "      if (idxs[startidx + i] & SHARED_MASK)", "        idxs[startidx + i] &= ~SHARED_MASK;"], "readability/braces"]
["src/nvim/spellfile.c", ["        idxs[startidx + i] &= ~SHARED_MASK;", "      else {", "        idxs[startidx + i] = idx;"], "readability/braces"]
["src/nvim/spellfile.c", ["        idxs[startidx + i] &= ~SHARED_MASK;", "      else {", "        idxs[startidx + i] = idx;"], "readability/braces"]
["src/nvim/spellfile.c", ["        idx = read_tree_node(fd, byts, idxs, maxidx, idx,", "            prefixtree, maxprefcondnr);", "        if (idx < 0)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["            prefixtree, maxprefcondnr);", "        if (idx < 0)", "          break;"], "readability/braces"]
["src/nvim/spellfile.c", ["static void", "spell_reload_one (", "    char_u *fname,"], "whitespace/parens"]
["src/nvim/spellfile.c", ["      slang_clear(slang);", "      if (spell_load_file(fname, NULL, slang, false) == NULL)", "        // reloading failed, clear the language"], "readability/braces"]
["src/nvim/spellfile.c", ["  // 'spelllang' to load it now.", "  if (added_word && !didit)", "    did_set_spelllang(curwin);"], "readability/braces"]
["src/nvim/spellfile.c", ["", "  if (!ascii_isdigit(*p))", "    return FAIL;"], "readability/braces"]
["src/nvim/spellfile.c", ["#define PRINTSOME(l, depth, fmt, a1, a2) vim_snprintf(l + depth * PRINTWIDTH, \\", "    PRINTLINESIZE - PRINTWIDTH * depth, fmt, a1, a2)", ""], "whitespace/alignment"]
["src/nvim/spellfile.c", ["  for (np = node; np != NULL; np = np->wn_sibling) {", "    np->wn_u1.index = FALSE;", "    spell_clear_flags(np->wn_child);"], "readability/bool"]
["src/nvim/spellfile.c", ["  } else {", "    node->wn_u1.index = TRUE;", ""], "readability/bool"]
["src/nvim/spellfile.c", ["    if (node->wn_byte != NUL) {", "      if (node->wn_child != NULL)", "        PRINTSOME(line1, depth, \" %c -> \", node->wn_byte, 0);"], "readability/braces"]
["src/nvim/spellfile.c", ["        PRINTSOME(line1, depth, \" %c -> \", node->wn_byte, 0);", "      else", "        // Cannot happen?"], "readability/braces"]
["src/nvim/spellfile.c", ["        PRINTSOME(line1, depth, \" %c ???\", node->wn_byte, 0);", "    } else", "      PRINTSOME(line1, depth, \" $    \", 0, 0);"], "readability/braces"]
["src/nvim/spellfile.c", ["", "    if (node->wn_sibling != NULL)", "      PRINTSOME(line3, depth, \" |    \", 0, 0);"], "readability/braces"]
["src/nvim/spellfile.c", ["      PRINTSOME(line3, depth, \" |    \", 0, 0);", "    else", "      PRINTSOME(line3, depth, \"      \", 0, 0);"], "readability/braces"]
["src/nvim/spellfile.c", ["    // do the children", "    if (node->wn_byte != NUL && node->wn_child != NULL)", "      spell_print_node(node->wn_child, depth + 1);"], "readability/braces"]
["src/nvim/spellfile.c", ["", "#endif // SPELL_PRINTTREE", ""], "whitespace/comments"]
["src/nvim/spellfile.c", ["    line_breakcheck();", "    ++lnum;", ""], "readability/increment"]
["src/nvim/spellfile.c", ["    // Skip comment lines.", "    if (*rline == '#')", "      continue;"], "readability/braces"]
["src/nvim/spellfile.c", ["    for (p = line;; ) {", "      while (*p != NUL && *p <= ' ')        // skip white space and CR/NL", "        ++p;"], "readability/braces"]
["src/nvim/spellfile.c", ["      while (*p != NUL && *p <= ' ')        // skip white space and CR/NL", "        ++p;", "      if (*p == NUL)"], "readability/increment"]
["src/nvim/spellfile.c", ["        ++p;", "      if (*p == NUL)", "        break;"], "readability/braces"]
["src/nvim/spellfile.c", ["        break;", "      if (itemcnt == MAXITEMCNT)            // too many items", "        break;"], "readability/braces"]
["src/nvim/spellfile.c", ["      // A few items have arbitrary text argument, don't split them.", "      if (itemcnt == 2 && spell_info_item(items[0]))", "        while (*p >= ' ' || *p == TAB)            // skip until CR/NL"], "readability/braces"]
["src/nvim/spellfile.c", ["      if (itemcnt == 2 && spell_info_item(items[0]))", "        while (*p >= ' ' || *p == TAB)            // skip until CR/NL", "          ++p;"], "readability/braces"]
["src/nvim/spellfile.c", ["        while (*p >= ' ' || *p == TAB)            // skip until CR/NL", "          ++p;", "      else"], "readability/increment"]
["src/nvim/spellfile.c", ["          ++p;", "      else", "        while (*p > ' ')            // skip until white space or CR/NL"], "readability/braces"]
["src/nvim/spellfile.c", ["      else", "        while (*p > ' ')            // skip until white space or CR/NL", "          ++p;"], "readability/braces"]
["src/nvim/spellfile.c", ["        while (*p > ' ')            // skip until white space or CR/NL", "          ++p;", "      if (*p == NUL)"], "readability/increment"]
["src/nvim/spellfile.c", ["          ++p;", "      if (*p == NUL)", "        break;"], "readability/braces"]
["src/nvim/spellfile.c", ["        aff->af_enc = enc_canonize(items[1]);", "        if (!spin->si_ascii", "            && convert_setup(&spin->si_conv, aff->af_enc,"], "readability/braces"]
["src/nvim/spellfile.c", ["            && convert_setup(&spin->si_conv, aff->af_enc,", "                p_enc) == FAIL)", "          smsg(_(\"Conversion in %s not supported: from %s to %s\"),"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["            && convert_setup(&spin->si_conv, aff->af_enc,", "                p_enc) == FAIL)", "          smsg(_(\"Conversion in %s not supported: from %s to %s\"),"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                 && aff->af_flagtype == AFT_CHAR) {", "        if (STRCMP(items[1], \"long\") == 0)", "          aff->af_flagtype = AFT_LONG;"], "readability/braces"]
["src/nvim/spellfile.c", ["          aff->af_flagtype = AFT_LONG;", "        else if (STRCMP(items[1], \"num\") == 0)", "          aff->af_flagtype = AFT_NUM;"], "readability/braces"]
["src/nvim/spellfile.c", ["          aff->af_flagtype = AFT_NUM;", "        else if (STRCMP(items[1], \"caplong\") == 0)", "          aff->af_flagtype = AFT_CAPLONG;"], "readability/braces"]
["src/nvim/spellfile.c", ["          aff->af_flagtype = AFT_CAPLONG;", "        else", "          smsg(_(\"Invalid value for FLAG in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["               fname, lnum, items[1]);", "        if (aff->af_rare != 0", "            || aff->af_keepcase != 0"], "readability/braces"]
["src/nvim/spellfile.c", ["      }", "      // TODO: remove \"RAR\" later", "      else if ((is_aff_rule(items, itemcnt, \"RAR\", 2)"], "readability/todo"]
["src/nvim/spellfile.c", ["      // TODO: remove \"RAR\" later", "      else if ((is_aff_rule(items, itemcnt, \"RAR\", 2)", "                || is_aff_rule(items, itemcnt, \"RARE\", 2))"], "whitespace/newline"]
["src/nvim/spellfile.c", ["        aff->af_rare = affitem2flag(aff->af_flagtype, items[1],", "            fname, lnum);", "      }"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["      }", "      // TODO: remove \"KEP\" later", "      else if ((is_aff_rule(items, itemcnt, \"KEP\", 2)"], "readability/todo"]
["src/nvim/spellfile.c", ["      // TODO: remove \"KEP\" later", "      else if ((is_aff_rule(items, itemcnt, \"KEP\", 2)", "                || is_aff_rule(items, itemcnt, \"KEEPCASE\", 2))"], "whitespace/newline"]
["src/nvim/spellfile.c", ["        aff->af_keepcase = affitem2flag(aff->af_flagtype, items[1],", "            fname, lnum);", "      } else if ((is_aff_rule(items, itemcnt, \"BAD\", 2)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["        aff->af_bad = affitem2flag(aff->af_flagtype, items[1],", "            fname, lnum);", "      } else if (is_aff_rule(items, itemcnt, \"NEEDAFFIX\", 2)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["        aff->af_needaffix = affitem2flag(aff->af_flagtype, items[1],", "            fname, lnum);", "      } else if (is_aff_rule(items, itemcnt, \"CIRCUMFIX\", 2)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["        aff->af_circumfix = affitem2flag(aff->af_flagtype, items[1],", "            fname, lnum);", "      } else if (is_aff_rule(items, itemcnt, \"NOSUGGEST\", 2)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["        aff->af_nosuggest = affitem2flag(aff->af_flagtype, items[1],", "            fname, lnum);", "      } else if ((is_aff_rule(items, itemcnt, \"NEEDCOMPOUND\", 2)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["        aff->af_needcomp = affitem2flag(aff->af_flagtype, items[1],", "            fname, lnum);", "      } else if (is_aff_rule(items, itemcnt, \"COMPOUNDROOT\", 2)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["        aff->af_comproot = affitem2flag(aff->af_flagtype, items[1],", "            fname, lnum);", "      } else if (is_aff_rule(items, itemcnt, \"COMPOUNDFORBIDFLAG\", 2)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["        aff->af_compforbid = affitem2flag(aff->af_flagtype, items[1],", "            fname, lnum);", "        if (aff->af_pref.ht_used > 0)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["            fname, lnum);", "        if (aff->af_pref.ht_used > 0)", "          smsg(_(\"Defining COMPOUNDFORBIDFLAG after PFX item may give wrong results in %s line %d\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["        if (aff->af_pref.ht_used > 0)", "          smsg(_(\"Defining COMPOUNDFORBIDFLAG after PFX item may give wrong results in %s line %d\"),", "               fname, lnum);"], "whitespace/line_length"]
["src/nvim/spellfile.c", ["        aff->af_comppermit = affitem2flag(aff->af_flagtype, items[1],", "            fname, lnum);", "        if (aff->af_pref.ht_used > 0)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["            fname, lnum);", "        if (aff->af_pref.ht_used > 0)", "          smsg(_(\"Defining COMPOUNDPERMITFLAG after PFX item may give wrong results in %s line %d\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["        if (aff->af_pref.ht_used > 0)", "          smsg(_(\"Defining COMPOUNDPERMITFLAG after PFX item may give wrong results in %s line %d\"),", "               fname, lnum);"], "whitespace/line_length"]
["src/nvim/spellfile.c", ["        // not COMPOUNDRULE mistyped.", "        if (atoi((char *)items[1]) == 0)", "          smsg(_(\"Wrong COMPOUNDRULES value in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["          l = (int)STRLEN(items[1]) + 1;", "          if (compflags != NULL)", "            l += (int)STRLEN(compflags) + 1;"], "readability/braces"]
["src/nvim/spellfile.c", ["        compmax = atoi((char *)items[1]);", "        if (compmax == 0)", "          smsg(_(\"Wrong COMPOUNDWORDMAX value in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["        compminlen = atoi((char *)items[1]);", "        if (compminlen == 0)", "          smsg(_(\"Wrong COMPOUNDMIN value in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["        compsylmax = atoi((char *)items[1]);", "        if (compsylmax == 0)", "          smsg(_(\"Wrong COMPOUNDSYLMAX value in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["      } else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDPATTERN\", 2))   {", "        if (atoi((char *)items[1]) == 0)", "          smsg(_(\"Wrong CHECKCOMPOUNDPATTERN value in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["        // Only add the couple if it isn't already there.", "        for (i = 0; i < gap->ga_len - 1; i += 2)", "          if (STRCMP(((char_u **)(gap->ga_data))[i], items[1]) == 0"], "readability/braces"]
["src/nvim/spellfile.c", ["        for (i = 0; i < gap->ga_len - 1; i += 2)", "          if (STRCMP(((char_u **)(gap->ga_data))[i], items[1]) == 0", "              && STRCMP(((char_u **)(gap->ga_data))[i + 1],"], "readability/braces"]
["src/nvim/spellfile.c", ["              && STRCMP(((char_u **)(gap->ga_data))[i + 1],", "                  items[2]) == 0)", "            break;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["              && STRCMP(((char_u **)(gap->ga_data))[i + 1],", "                  items[2]) == 0)", "            break;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["", "        if (*items[0] == 'P')", "          tp = &aff->af_pref;"], "readability/braces"]
["src/nvim/spellfile.c", ["          tp = &aff->af_pref;", "        else", "          tp = &aff->af_suff;"], "readability/braces"]
["src/nvim/spellfile.c", ["          cur_aff = HI2AH(hi);", "          if (cur_aff->ah_combine != (*items[2] == 'Y'))", "            smsg(_(\"Different combining flag in continued affix block in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["          if (cur_aff->ah_combine != (*items[2] == 'Y'))", "            smsg(_(\"Different combining flag in continued affix block in %s line %d: %s\"),", "                 fname, lnum, items[1]);"], "whitespace/line_length"]
["src/nvim/spellfile.c", ["                 fname, lnum, items[1]);", "          if (!cur_aff->ah_follows)", "            smsg(_(\"Duplicate affix in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["        if (itemcnt > lasti && STRCMP(items[lasti], \"S\") == 0) {", "          ++lasti;", "          cur_aff->ah_follows = true;"], "readability/increment"]
["src/nvim/spellfile.c", ["          cur_aff->ah_follows = true;", "        } else", "          cur_aff->ah_follows = false;"], "readability/braces"]
["src/nvim/spellfile.c", ["        // unless IGNOREEXTRA is used.  Hunspell uses a \"-\" item.", "        if (itemcnt > lasti", "            && !aff->af_ignoreextra"], "readability/braces"]
["src/nvim/spellfile.c", ["", "        if (STRCMP(items[2], \"Y\") != 0 && STRCMP(items[2], \"N\") != 0)", "          smsg(_(\"Expected Y or N in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["          smsg(_(\"Expected Y or N in %s line %d: %s\"),", "              fname, lnum, items[2]);", ""], "whitespace/alignment"]
["src/nvim/spellfile.c", ["            did_postpone_prefix = false;", "          } else", "            // Did use the ID in a previous block."], "readability/braces"]
["src/nvim/spellfile.c", ["        // Hunspell uses a \"-\" item.", "        if (itemcnt > lasti && *items[lasti] != '#'", "            && (STRCMP(items[lasti], \"-\") != 0"], "readability/braces"]
["src/nvim/spellfile.c", ["", "        if (STRCMP(items[2], \"0\") != 0)", "          aff_entry->ae_chop = getroom_save(spin, items[2]);"], "readability/braces"]
["src/nvim/spellfile.c", ["            aff_entry->ae_cond = getroom_save(spin, items[4]);", "            if (*items[0] == 'P')", "              sprintf((char *)buf, \"^%s\", items[4]);"], "readability/braces"]
["src/nvim/spellfile.c", ["            if (*items[0] == 'P')", "              sprintf((char *)buf, \"^%s\", items[4]);", "            else"], "runtime/printf"]
["src/nvim/spellfile.c", ["              sprintf((char *)buf, \"^%s\", items[4]);", "            else", "              sprintf((char *)buf, \"%s$\", items[4]);"], "readability/braces"]
["src/nvim/spellfile.c", ["            else", "              sprintf((char *)buf, \"%s$\", items[4]);", "            aff_entry->ae_prog = vim_regcomp(buf,"], "runtime/printf"]
["src/nvim/spellfile.c", ["            aff_entry->ae_prog = vim_regcomp(buf,", "                RE_MAGIC + RE_STRING + RE_STRICT);", "            if (aff_entry->ae_prog == NULL)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                RE_MAGIC + RE_STRING + RE_STRICT);", "            if (aff_entry->ae_prog == NULL)", "              smsg(_(\"Broken condition in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["                && aff_entry->ae_chop[(*mb_ptr2len)(", "                                        aff_entry->ae_chop)] == NUL", "                ) {"], "whitespace/indent"]
["src/nvim/spellfile.c", ["                && aff_entry->ae_chop[(*mb_ptr2len)(", "                                        aff_entry->ae_chop)] == NUL", "                ) {"], "whitespace/indent"]
["src/nvim/spellfile.c", ["                      sprintf((char *)buf, \"^%s\",", "                          aff_entry->ae_cond);", "                      vim_regfree(aff_entry->ae_prog);"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                    if (aff_entry->ae_cond != NULL) {", "                      sprintf((char *)buf, \"^%s\",", "                          aff_entry->ae_cond);"], "runtime/printf"]
["src/nvim/spellfile.c", ["              for (idx = spin->si_prefcond.ga_len - 1; idx >= 0;", "                   --idx) {", "                p = ((char_u **)spin->si_prefcond.ga_data)[idx];"], "readability/increment"]
["src/nvim/spellfile.c", ["                p = ((char_u **)spin->si_prefcond.ga_data)[idx];", "                if (str_equal(p, aff_entry->ae_cond))", "                  break;"], "readability/braces"]
["src/nvim/spellfile.c", ["              // Add the prefix to the prefix tree.", "              if (aff_entry->ae_add == NULL)", "                p = (char_u *)\"\";"], "readability/braces"]
["src/nvim/spellfile.c", ["                p = (char_u *)\"\";", "              else", "                p = aff_entry->ae_add;"], "readability/braces"]
["src/nvim/spellfile.c", ["              n = PFX_FLAGS;", "              if (!cur_aff->ah_combine)", "                n |= WFP_NC;"], "readability/braces"]
["src/nvim/spellfile.c", ["                n |= WFP_NC;", "              if (upper)", "                n |= WFP_UP;"], "readability/braces"]
["src/nvim/spellfile.c", ["                n |= WFP_UP;", "              if (aff_entry->ae_comppermit)", "                n |= WFP_COMPPERMIT;"], "readability/braces"]
["src/nvim/spellfile.c", ["                n |= WFP_COMPPERMIT;", "              if (aff_entry->ae_compforbid)", "                n |= WFP_COMPFORBID;"], "readability/braces"]
["src/nvim/spellfile.c", ["              tree_add_word(spin, p, spin->si_prefroot, n,", "                  idx, cur_aff->ah_newID);", "              did_postpone_prefix = true;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["            if (aff_todo == 0 && !did_postpone_prefix) {", "              --spin->si_newprefID;", "              cur_aff->ah_newID = 0;"], "readability/increment"]
["src/nvim/spellfile.c", ["                 || is_aff_rule(items, itemcnt, \"REPSAL\", 2)) {", "        /* Ignore REP/REPSAL count */;", "        if (!isdigit(*items[1]))"], "readability/old_style_comment"]
["src/nvim/spellfile.c", ["                 || is_aff_rule(items, itemcnt, \"REPSAL\", 2)) {", "        /* Ignore REP/REPSAL count */;", "        if (!isdigit(*items[1]))"], "whitespace/semicolon"]
["src/nvim/spellfile.c", ["        /* Ignore REP/REPSAL count */;", "        if (!isdigit(*items[1]))", "          smsg(_(\"Expected REP(SAL) count in %s line %d\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["        // # to detect mistakes.", "        if (itemcnt > 3 && items[3][0] != '#')", "          smsg(_(e_afftrailing), fname, lnum, items[3]);"], "readability/braces"]
["src/nvim/spellfile.c", ["          add_fromto(spin, items[0][3] == 'S'", "              ? &spin->si_repsal", "              : &spin->si_rep, items[1], items[2]);"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["              ? &spin->si_repsal", "              : &spin->si_rep, items[1], items[2]);", "        }"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["          found_map = true;", "          if (!isdigit(*items[1]))", "            smsg(_(\"Expected MAP count in %s line %d\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["      // Accept \"SAL from to\" and \"SAL from to  #comment\".", "      else if (is_aff_rule(items, itemcnt, \"SAL\", 3)) {", "        if (do_sal) {"], "whitespace/newline"]
["src/nvim/spellfile.c", ["          // Either one of the known keys or a from-to pair.", "          if (STRCMP(items[1], \"followup\") == 0)", "            spin->si_followup = sal_to_bool(items[2]);"], "readability/braces"]
["src/nvim/spellfile.c", ["            spin->si_followup = sal_to_bool(items[2]);", "          else if (STRCMP(items[1], \"collapse_result\") == 0)", "            spin->si_collapse = sal_to_bool(items[2]);"], "readability/braces"]
["src/nvim/spellfile.c", ["            spin->si_collapse = sal_to_bool(items[2]);", "          else if (STRCMP(items[1], \"remove_accents\") == 0)", "            spin->si_rem_accents = sal_to_bool(items[2]);"], "readability/braces"]
["src/nvim/spellfile.c", ["            spin->si_rem_accents = sal_to_bool(items[2]);", "          else", "            // when \"to\" is \"_\" it means empty"], "readability/braces"]
["src/nvim/spellfile.c", ["            add_fromto(spin, &spin->si_sal, items[1],", "                STRCMP(items[2], \"_\") == 0 ? (char_u *)\"\"", "                : items[2]);"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                STRCMP(items[2], \"_\") == 0 ? (char_u *)\"\"", "                : items[2]);", "        }"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["", "        for (i = 1; i < itemcnt; ++i) {", "          if (HASHITEM_EMPTY(hash_find(&spin->si_commonwords,"], "readability/increment"]
["src/nvim/spellfile.c", ["          if (HASHITEM_EMPTY(hash_find(&spin->si_commonwords,", "                      items[i]))) {", "            p = vim_strsave(items[i]);"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["        }", "      } else", "        smsg(_(\"Unrecognized or duplicate item in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["", "  if (compflags != NULL)", "    process_compflags(spin, aff, compflags);"], "readability/braces"]
["src/nvim/spellfile.c", ["  if (spin->si_newcompID < spin->si_newprefID) {", "    if (spin->si_newcompID == 127 || spin->si_newcompID == 255)", "      MSG(_(\"Too many postponed prefixes\"));"], "readability/braces"]
["src/nvim/spellfile.c", ["      MSG(_(\"Too many postponed prefixes\"));", "    else if (spin->si_newprefID == 0 || spin->si_newprefID == 127)", "      MSG(_(\"Too many compound flags\"));"], "readability/braces"]
["src/nvim/spellfile.c", ["      MSG(_(\"Too many compound flags\"));", "    else", "      MSG(_(\"Too many postponed prefixes and/or compound flags\"));"], "readability/braces"]
["src/nvim/spellfile.c", ["  if (sofofrom != NULL || sofoto != NULL) {", "    if (sofofrom == NULL || sofoto == NULL)", "      smsg(_(\"Missing SOFO%s line in %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["           sofofrom == NULL ? \"FROM\" : \"TO\", fname);", "    else if (!GA_EMPTY(&spin->si_sal))", "      smsg(_(\"Both SAL and SOFO lines in %s\"), fname);"], "readability/braces"]
["src/nvim/spellfile.c", ["      smsg(_(\"Both SAL and SOFO lines in %s\"), fname);", "    else {", "      aff_check_string(spin->si_sofofr, sofofrom, \"SOFOFROM\");"], "readability/braces"]
["src/nvim/spellfile.c", ["      smsg(_(\"Both SAL and SOFO lines in %s\"), fname);", "    else {", "      aff_check_string(spin->si_sofofr, sofofrom, \"SOFOFROM\");"], "readability/braces"]
["src/nvim/spellfile.c", ["  return aff;", "}", ""], "readability/fn_size"]
["src/nvim/spellfile.c", ["// a comment is following after item \"mincount\".", "static bool is_aff_rule(char_u **items, int itemcnt, char *rulename, int mincount)", "{"], "whitespace/line_length"]
["src/nvim/spellfile.c", ["        p = prevp;", "        if (flag == affile->af_comppermit)", "          entry->ae_comppermit = true;"], "readability/braces"]
["src/nvim/spellfile.c", ["          entry->ae_comppermit = true;", "        else", "          entry->ae_compforbid = true;"], "readability/braces"]
["src/nvim/spellfile.c", ["      }", "      if (affile->af_flagtype == AFT_NUM && *p == ',')", "        ++p;"], "readability/braces"]
["src/nvim/spellfile.c", ["      if (affile->af_flagtype == AFT_NUM && *p == ',')", "        ++p;", "    }"], "readability/increment"]
["src/nvim/spellfile.c", ["    }", "    if (*entry->ae_flags == NUL)", "      entry->ae_flags = NULL;           // nothing left"], "readability/braces"]
["src/nvim/spellfile.c", ["// returns zero for failure.", "static unsigned affitem2flag(int flagtype, char_u *item, char_u *fname, int lnum)", "{"], "whitespace/line_length"]
["src/nvim/spellfile.c", ["  if (res == 0) {", "    if (flagtype == AFT_NUM)", "      smsg(_(\"Flag is not a number in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["           fname, lnum, item);", "    else", "      smsg(_(\"Illegal flag in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["    if (!ascii_isdigit(**pp)) {", "      ++*pp;            // always advance, avoid getting stuck", "      return 0;"], "readability/increment"]
["src/nvim/spellfile.c", ["                                 && res >= 'A' && res <= 'Z')) {", "      if (**pp == NUL)", "        return 0;"], "readability/braces"]
["src/nvim/spellfile.c", ["// they fit in one byte.", "static void process_compflags(spellinfo_T *spin, afffile_T *aff, char_u *compflags)", "{"], "whitespace/line_length"]
["src/nvim/spellfile.c", ["  len = (int)STRLEN(compflags) + 1;", "  if (spin->si_compflags != NULL)", "    len += (int)STRLEN(spin->si_compflags) + 1;"], "readability/braces"]
["src/nvim/spellfile.c", ["  for (p = compflags; *p != NUL; ) {", "    if (vim_strchr((char_u *)\"/?*+[]\", *p) != NULL)", "      // Copy non-flag characters directly."], "readability/braces"]
["src/nvim/spellfile.c", ["      *tp++ = *p++;", "    else {", "      // First get the flag number, also checks validity."], "readability/braces"]
["src/nvim/spellfile.c", ["      *tp++ = *p++;", "    else {", "      // First get the flag number, also checks validity."], "readability/braces"]
["src/nvim/spellfile.c", ["      }", "      if (aff->af_flagtype == AFT_NUM && *p == ',')", "        ++p;"], "readability/braces"]
["src/nvim/spellfile.c", ["      if (aff->af_flagtype == AFT_NUM && *p == ',')", "        ++p;", "    }"], "readability/increment"]
["src/nvim/spellfile.c", ["{", "  if (spinval != 0 && spinval != affval)", "    smsg(_(\"%s value differs from what is used in another .aff file\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["{", "  if (spinval != NULL && STRCMP(spinval, affval) != 0)", "    smsg(_(\"%s value differs from what is used in another .aff file\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["{", "  if (s1 == NULL || s2 == NULL)", "    return s1 == s2;"], "readability/braces"]
["src/nvim/spellfile.c", ["// They are stored case-folded.", "static void add_fromto(spellinfo_T *spin, garray_T *gap, char_u *from, char_u *to)", "{"], "whitespace/line_length"]
["src/nvim/spellfile.c", ["    todo = (int)ht->ht_used;", "    for (hi = ht->ht_array; todo > 0; ++hi) {", "      if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/spellfile.c", ["      if (!HASHITEM_EMPTY(hi)) {", "        --todo;", "        ah = HI2AH(hi);"], "readability/increment"]
["src/nvim/spellfile.c", ["        ah = HI2AH(hi);", "        for (ae = ah->ah_first; ae != NULL; ae = ae->ae_next)", "          vim_regfree(ae->ae_prog);"], "readability/braces"]
["src/nvim/spellfile.c", ["    }", "    if (ht == &aff->af_suff)", "      break;"], "readability/braces"]
["src/nvim/spellfile.c", ["    line_breakcheck();", "    ++lnum;", "    if (line[0] == '#' || line[0] == '/')"], "readability/increment"]
["src/nvim/spellfile.c", ["    ++lnum;", "    if (line[0] == '#' || line[0] == '/')", "      continue;         // comment line"], "readability/braces"]
["src/nvim/spellfile.c", ["    l = (int)STRLEN(line);", "    while (l > 0 && line[l - 1] <= ' ')", "      --l;"], "readability/braces"]
["src/nvim/spellfile.c", ["    while (l > 0 && line[l - 1] <= ' ')", "      --l;", "    if (l == 0)"], "readability/increment"]
["src/nvim/spellfile.c", ["      --l;", "    if (l == 0)", "      continue;         // empty line"], "readability/braces"]
["src/nvim/spellfile.c", ["    if (spin->si_ascii && has_non_ascii(w)) {", "      ++non_ascii;", "      xfree(pc);"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (!HASHITEM_EMPTY(hi)) {", "      if (p_verbose > 0)", "        smsg(_(\"Duplicate word in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["             fname, lnum, dw);", "      else if (duplicate == 0)", "        smsg(_(\"First duplicate word in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["             fname, lnum, dw);", "      ++duplicate;", "    } else"], "readability/increment"]
["src/nvim/spellfile.c", ["      ++duplicate;", "    } else", "      hash_add_item(&ht, hi, dw, hash);"], "readability/braces"]
["src/nvim/spellfile.c", ["", "      if (affile->af_needaffix != 0 && flag_in_afflist(", "              affile->af_flagtype, afflist, affile->af_needaffix))"], "readability/braces"]
["src/nvim/spellfile.c", ["      if (affile->af_needaffix != 0 && flag_in_afflist(", "              affile->af_flagtype, afflist, affile->af_needaffix))", "        need_affix = true;"], "whitespace/indent"]
["src/nvim/spellfile.c", ["", "      if (affile->af_pfxpostpone)", "        // Need to store the list of prefix IDs with the word."], "readability/braces"]
["src/nvim/spellfile.c", ["", "      if (spin->si_compflags != NULL)", "        // Need to store the list of compound flags with the word."], "readability/braces"]
["src/nvim/spellfile.c", ["    // Add the word to the word tree(s).", "    if (store_word(spin, dw, flags, spin->si_region,", "            store_afflist, need_affix) == FAIL)"], "readability/braces"]
["src/nvim/spellfile.c", ["    if (store_word(spin, dw, flags, spin->si_region,", "            store_afflist, need_affix) == FAIL)", "      retval = FAIL;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["      // Additionally do matching prefixes that combine.", "      if (store_aff_word(spin, dw, afflist, affile,", "              &affile->af_suff, &affile->af_pref,"], "readability/braces"]
["src/nvim/spellfile.c", ["      if (store_aff_word(spin, dw, afflist, affile,", "              &affile->af_suff, &affile->af_pref,", "              CONDIT_SUF, flags, store_afflist, pfxlen) == FAIL)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["              &affile->af_suff, &affile->af_pref,", "              CONDIT_SUF, flags, store_afflist, pfxlen) == FAIL)", "        retval = FAIL;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["      // Find all matching prefixes and add the resulting words.", "      if (store_aff_word(spin, dw, afflist, affile,", "              &affile->af_pref, NULL,"], "readability/braces"]
["src/nvim/spellfile.c", ["      if (store_aff_word(spin, dw, afflist, affile,", "              &affile->af_pref, NULL,", "              CONDIT_SUF, flags, store_afflist, pfxlen) == FAIL)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["              &affile->af_pref, NULL,", "              CONDIT_SUF, flags, store_afflist, pfxlen) == FAIL)", "        retval = FAIL;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["", "  if (duplicate > 0)", "    smsg(_(\"%d duplicate word(s) in %s\"), duplicate, fname);"], "readability/braces"]
["src/nvim/spellfile.c", ["    smsg(_(\"%d duplicate word(s) in %s\"), duplicate, fname);", "  if (spin->si_ascii && non_ascii > 0)", "    smsg(_(\"Ignored %d word(s) with non-ASCII characters in %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["", "  if (affile->af_keepcase != 0 && flag_in_afflist(", "          affile->af_flagtype, afflist, affile->af_keepcase))"], "readability/braces"]
["src/nvim/spellfile.c", ["  if (affile->af_keepcase != 0 && flag_in_afflist(", "          affile->af_flagtype, afflist, affile->af_keepcase))", "    flags |= WF_KEEPCAP | WF_FIXCAP;"], "whitespace/indent"]
["src/nvim/spellfile.c", ["    flags |= WF_KEEPCAP | WF_FIXCAP;", "  if (affile->af_rare != 0 && flag_in_afflist(", "          affile->af_flagtype, afflist, affile->af_rare))"], "readability/braces"]
["src/nvim/spellfile.c", ["  if (affile->af_rare != 0 && flag_in_afflist(", "          affile->af_flagtype, afflist, affile->af_rare))", "    flags |= WF_RARE;"], "whitespace/indent"]
["src/nvim/spellfile.c", ["    flags |= WF_RARE;", "  if (affile->af_bad != 0 && flag_in_afflist(", "          affile->af_flagtype, afflist, affile->af_bad))"], "readability/braces"]
["src/nvim/spellfile.c", ["  if (affile->af_bad != 0 && flag_in_afflist(", "          affile->af_flagtype, afflist, affile->af_bad))", "    flags |= WF_BANNED;"], "whitespace/indent"]
["src/nvim/spellfile.c", ["    flags |= WF_BANNED;", "  if (affile->af_needcomp != 0 && flag_in_afflist(", "          affile->af_flagtype, afflist, affile->af_needcomp))"], "readability/braces"]
["src/nvim/spellfile.c", ["  if (affile->af_needcomp != 0 && flag_in_afflist(", "          affile->af_flagtype, afflist, affile->af_needcomp))", "    flags |= WF_NEEDCOMP;"], "whitespace/indent"]
["src/nvim/spellfile.c", ["    flags |= WF_NEEDCOMP;", "  if (affile->af_comproot != 0 && flag_in_afflist(", "          affile->af_flagtype, afflist, affile->af_comproot))"], "readability/braces"]
["src/nvim/spellfile.c", ["  if (affile->af_comproot != 0 && flag_in_afflist(", "          affile->af_flagtype, afflist, affile->af_comproot))", "    flags |= WF_COMPROOT;"], "whitespace/indent"]
["src/nvim/spellfile.c", ["    flags |= WF_COMPROOT;", "  if (affile->af_nosuggest != 0 && flag_in_afflist(", "          affile->af_flagtype, afflist, affile->af_nosuggest))"], "readability/braces"]
["src/nvim/spellfile.c", ["  if (affile->af_nosuggest != 0 && flag_in_afflist(", "          affile->af_flagtype, afflist, affile->af_nosuggest))", "    flags |= WF_NOSUGGEST;"], "whitespace/indent"]
["src/nvim/spellfile.c", ["// and return the number of affixes.", "static int get_pfxlist(afffile_T *affile, char_u *afflist, char_u *store_afflist)", "{"], "whitespace/line_length"]
["src/nvim/spellfile.c", ["        id = HI2AH(hi)->ah_newID;", "        if (id != 0)", "          store_afflist[cnt++] = id;"], "readability/braces"]
["src/nvim/spellfile.c", ["    }", "    if (affile->af_flagtype == AFT_NUM && *p == ',')", "      ++p;"], "readability/braces"]
["src/nvim/spellfile.c", ["    if (affile->af_flagtype == AFT_NUM && *p == ',')", "      ++p;", "  }"], "readability/increment"]
["src/nvim/spellfile.c", ["// Puts the flags in \"store_afflist[]\".", "static void get_compflags(afffile_T *affile, char_u *afflist, char_u *store_afflist)", "{"], "whitespace/line_length"]
["src/nvim/spellfile.c", ["      hi = hash_find(&affile->af_comp, key);", "      if (!HASHITEM_EMPTY(hi))", "        store_afflist[cnt++] = HI2CI(hi)->ci_newID;"], "readability/braces"]
["src/nvim/spellfile.c", ["    }", "    if (affile->af_flagtype == AFT_NUM && *p == ',')", "      ++p;"], "readability/braces"]
["src/nvim/spellfile.c", ["    if (affile->af_flagtype == AFT_NUM && *p == ',')", "      ++p;", "  }"], "readability/increment"]
["src/nvim/spellfile.c", ["static int", "store_aff_word (", "    spellinfo_T *spin,         // spell info"], "whitespace/parens"]
["src/nvim/spellfile.c", ["  todo = (int)ht->ht_used;", "  for (hi = ht->ht_array; todo > 0 && retval == OK; ++hi) {", "    if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (!HASHITEM_EMPTY(hi)) {", "      --todo;", "      ah = HI2AH(hi);"], "readability/increment"]
["src/nvim/spellfile.c", ["          && flag_in_afflist(affile->af_flagtype, afflist,", "              ah->ah_flag)) {", "        // Loop over all affix entries with this name."], "whitespace/alignment"]
["src/nvim/spellfile.c", ["          && flag_in_afflist(affile->af_flagtype, afflist,", "              ah->ah_flag)) {", "        // Loop over all affix entries with this name."], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                      || !flag_in_afflist(affile->af_flagtype,", "                          ae->ae_flags, affile->af_circumfix)))) {", "            // Match.  Remove the chop and add the affix."], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                      || !flag_in_afflist(affile->af_flagtype,", "                          ae->ae_flags, affile->af_circumfix)))) {", "            // Match.  Remove the chop and add the affix."], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                      || !flag_in_afflist(affile->af_flagtype,", "                          ae->ae_flags, affile->af_circumfix)))) {", "            // Match.  Remove the chop and add the affix."], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                      || !flag_in_afflist(affile->af_flagtype,", "                          ae->ae_flags, affile->af_circumfix)))) {", "            // Match.  Remove the chop and add the affix."], "whitespace/alignment"]
["src/nvim/spellfile.c", ["              }", "              if (ae->ae_add != NULL)", "                STRCAT(newword, ae->ae_add);"], "readability/braces"]
["src/nvim/spellfile.c", ["", "              if (affile->af_needaffix != 0 && flag_in_afflist(", "                      affile->af_flagtype, ae->ae_flags,"], "readability/braces"]
["src/nvim/spellfile.c", ["              if (affile->af_needaffix != 0 && flag_in_afflist(", "                      affile->af_flagtype, ae->ae_flags,", "                      affile->af_needaffix))"], "whitespace/indent"]
["src/nvim/spellfile.c", ["                      affile->af_flagtype, ae->ae_flags,", "                      affile->af_needaffix))", "                need_affix = true;"], "whitespace/indent"]
["src/nvim/spellfile.c", ["              if (affile->af_circumfix != 0 && flag_in_afflist(", "                      affile->af_flagtype, ae->ae_flags,", "                      affile->af_circumfix)) {"], "whitespace/indent"]
["src/nvim/spellfile.c", ["                      affile->af_flagtype, ae->ae_flags,", "                      affile->af_circumfix)) {", "                use_condit |= CONDIT_CFIX;"], "whitespace/indent"]
["src/nvim/spellfile.c", ["                use_condit |= CONDIT_CFIX;", "                if ((condit & CONDIT_CFIX) == 0)", "                  need_affix = true;"], "readability/braces"]
["src/nvim/spellfile.c", ["                  || spin->si_compflags != NULL) {", "                if (affile->af_pfxpostpone)", "                  // Get prefix IDS from the affix list."], "readability/braces"]
["src/nvim/spellfile.c", ["                  use_pfxlen = get_pfxlist(affile,", "                      ae->ae_flags, store_afflist);", "                else"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                      ae->ae_flags, store_afflist);", "                else", "                  use_pfxlen = 0;"], "readability/braces"]
["src/nvim/spellfile.c", ["                // same ID twice.", "                for (i = 0; i < pfxlen; ++i) {", "                  for (j = 0; j < use_pfxlen; ++j)"], "readability/increment"]
["src/nvim/spellfile.c", ["                for (i = 0; i < pfxlen; ++i) {", "                  for (j = 0; j < use_pfxlen; ++j)", "                    if (pfxlist[i] == use_pfxlist[j])"], "readability/braces"]
["src/nvim/spellfile.c", ["                for (i = 0; i < pfxlen; ++i) {", "                  for (j = 0; j < use_pfxlen; ++j)", "                    if (pfxlist[i] == use_pfxlist[j])"], "readability/increment"]
["src/nvim/spellfile.c", ["                  for (j = 0; j < use_pfxlen; ++j)", "                    if (pfxlist[i] == use_pfxlist[j])", "                      break;"], "readability/braces"]
["src/nvim/spellfile.c", ["                      break;", "                  if (j == use_pfxlen)", "                    use_pfxlist[use_pfxlen++] = pfxlist[i];"], "readability/braces"]
["src/nvim/spellfile.c", ["", "                if (spin->si_compflags != NULL)", "                  // Get compound IDS from the affix list."], "readability/braces"]
["src/nvim/spellfile.c", ["                  get_compflags(affile, ae->ae_flags,", "                      use_pfxlist + use_pfxlen);", "                else"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                      use_pfxlist + use_pfxlen);", "                else", "                  use_pfxlist[use_pfxlen] = NUL;"], "readability/braces"]
["src/nvim/spellfile.c", ["                // Avoid adding the same ID twice.", "                for (i = pfxlen; pfxlist[i] != NUL; ++i) {", "                  for (j = use_pfxlen;"], "readability/increment"]
["src/nvim/spellfile.c", ["                for (i = pfxlen; pfxlist[i] != NUL; ++i) {", "                  for (j = use_pfxlen;", "                       use_pfxlist[j] != NUL; ++j)"], "readability/braces"]
["src/nvim/spellfile.c", ["                  for (j = use_pfxlen;", "                       use_pfxlist[j] != NUL; ++j)", "                    if (pfxlist[i] == use_pfxlist[j])"], "readability/increment"]
["src/nvim/spellfile.c", ["                       use_pfxlist[j] != NUL; ++j)", "                    if (pfxlist[i] == use_pfxlist[j])", "                      break;"], "readability/braces"]
["src/nvim/spellfile.c", ["              // compound flags after them.", "              if (!ah->ah_combine && use_pfxlist != NULL)", "                use_pfxlist += use_pfxlen;"], "readability/braces"]
["src/nvim/spellfile.c", ["            if (spin->si_compflags != NULL && !ae->ae_comppermit) {", "              if (xht != NULL)", "                use_flags |= WF_NOCOMPAFT;"], "readability/braces"]
["src/nvim/spellfile.c", ["                use_flags |= WF_NOCOMPAFT;", "              else", "                use_flags |= WF_NOCOMPBEF;"], "readability/braces"]
["src/nvim/spellfile.c", ["            // Store the modified word.", "            if (store_word(spin, newword, use_flags,", "                    spin->si_region, use_pfxlist,"], "readability/braces"]
["src/nvim/spellfile.c", ["            if (store_word(spin, newword, use_flags,", "                    spin->si_region, use_pfxlist,", "                    need_affix) == FAIL)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                    spin->si_region, use_pfxlist,", "                    need_affix) == FAIL)", "              retval = FAIL;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["            // has flags may add a(nother) suffix.  RECURSIVE!", "            if ((condit & CONDIT_SUF) && ae->ae_flags != NULL)", "              if (store_aff_word(spin, newword, ae->ae_flags,"], "readability/braces"]
["src/nvim/spellfile.c", ["            if ((condit & CONDIT_SUF) && ae->ae_flags != NULL)", "              if (store_aff_word(spin, newword, ae->ae_flags,", "                      affile, &affile->af_suff, xht,"], "readability/braces"]
["src/nvim/spellfile.c", ["              if (store_aff_word(spin, newword, ae->ae_flags,", "                      affile, &affile->af_suff, xht,", "                      use_condit & (xht == NULL"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                      affile, &affile->af_suff, xht,", "                      use_condit & (xht == NULL", "                                    ? ~0 :  ~CONDIT_SUF),"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                                    ? ~0 :  ~CONDIT_SUF),", "                      use_flags, use_pfxlist, pfxlen) == FAIL)", "                retval = FAIL;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["            if (xht != NULL && ah->ah_combine) {", "              if (store_aff_word(spin, newword,", "                      afflist, affile,"], "readability/braces"]
["src/nvim/spellfile.c", ["              if (store_aff_word(spin, newword,", "                      afflist, affile,", "                      xht, NULL, use_condit,"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                      afflist, affile,", "                      xht, NULL, use_condit,", "                      use_flags, use_pfxlist,"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                      xht, NULL, use_condit,", "                      use_flags, use_pfxlist,", "                      pfxlen) == FAIL"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                      use_flags, use_pfxlist,", "                      pfxlen) == FAIL", "                  || (ae->ae_flags != NULL"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                      && store_aff_word(spin, newword,", "                          ae->ae_flags, affile,", "                          xht, NULL, use_condit,"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                          ae->ae_flags, affile,", "                          xht, NULL, use_condit,", "                          use_flags, use_pfxlist,"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                          xht, NULL, use_condit,", "                          use_flags, use_pfxlist,", "                          pfxlen) == FAIL))"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                          use_flags, use_pfxlist,", "                          pfxlen) == FAIL))", "                retval = FAIL;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                      && store_aff_word(spin, newword,", "                          ae->ae_flags, affile,", "                          xht, NULL, use_condit,"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                          ae->ae_flags, affile,", "                          xht, NULL, use_condit,", "                          use_flags, use_pfxlist,"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                          xht, NULL, use_condit,", "                          use_flags, use_pfxlist,", "                          pfxlen) == FAIL))"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                          use_flags, use_pfxlist,", "                          pfxlen) == FAIL))", "                retval = FAIL;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                      && store_aff_word(spin, newword,", "                          ae->ae_flags, affile,", "                          xht, NULL, use_condit,"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                          ae->ae_flags, affile,", "                          xht, NULL, use_condit,", "                          use_flags, use_pfxlist,"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                          xht, NULL, use_condit,", "                          use_flags, use_pfxlist,", "                          pfxlen) == FAIL))"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                          use_flags, use_pfxlist,", "                          pfxlen) == FAIL))", "                retval = FAIL;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["    line_breakcheck();", "    ++lnum;", ""], "readability/increment"]
["src/nvim/spellfile.c", ["    // Skip comment lines.", "    if (*rline == '#')", "      continue;"], "readability/braces"]
["src/nvim/spellfile.c", ["    l = (int)STRLEN(rline);", "    while (l > 0 && rline[l - 1] <= ' ')", "      --l;"], "readability/braces"]
["src/nvim/spellfile.c", ["    while (l > 0 && rline[l - 1] <= ' ')", "      --l;", "    if (l == 0)"], "readability/increment"]
["src/nvim/spellfile.c", ["      --l;", "    if (l == 0)", "      continue;         // empty or blank line"], "readability/braces"]
["src/nvim/spellfile.c", ["    if (*line == '/') {", "      ++line;", "      if (STRNCMP(line, \"encoding=\", 9) == 0) {"], "readability/increment"]
["src/nvim/spellfile.c", ["          enc = enc_canonize(line);", "          if (!spin->si_ascii", "              && convert_setup(&spin->si_conv, enc,"], "readability/braces"]
["src/nvim/spellfile.c", ["              && convert_setup(&spin->si_conv, enc,", "                  p_enc) == FAIL)", "            smsg(_(\"Conversion in %s not supported: from %s to %s\"),"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["              && convert_setup(&spin->si_conv, enc,", "                  p_enc) == FAIL)", "            smsg(_(\"Conversion in %s not supported: from %s to %s\"),"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["      while (*p != NUL) {", "        if (*p == '=')                  // keep-case word", "          flags |= WF_KEEPCAP | WF_FIXCAP;"], "readability/braces"]
["src/nvim/spellfile.c", ["          flags |= WF_KEEPCAP | WF_FIXCAP;", "        else if (*p == '!')             // Bad, bad, wicked word.", "          flags |= WF_BANNED;"], "readability/braces"]
["src/nvim/spellfile.c", ["          flags |= WF_BANNED;", "        else if (*p == '?')             // Rare word.", "          flags |= WF_RARE;"], "readability/braces"]
["src/nvim/spellfile.c", ["          flags |= WF_RARE;", "        else if (ascii_isdigit(*p)) {       // region number(s)", "          if ((flags & WF_REGION) == 0)             // first one"], "readability/braces"]
["src/nvim/spellfile.c", ["        else if (ascii_isdigit(*p)) {       // region number(s)", "          if ((flags & WF_REGION) == 0)             // first one", "            regionmask = 0;"], "readability/braces"]
["src/nvim/spellfile.c", ["        }", "        ++p;", "      }"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (spin->si_ascii && has_non_ascii(line)) {", "      ++non_ascii;", "      continue;"], "readability/increment"]
["src/nvim/spellfile.c", ["    vim_snprintf((char *)IObuff, IOSIZE,", "        _(\"Ignored %d words with non-ASCII characters\"), non_ascii);", "    spell_message(spin, IObuff);"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["  assert(len <= SBLOCKSIZE);", "  ", "  if (align && bl != NULL)"], "whitespace/end_of_line"]
["src/nvim/spellfile.c", ["  ", "  if (align && bl != NULL)", "    // Round size up for alignment.  On some systems structures need to be"], "readability/braces"]
["src/nvim/spellfile.c", ["    bl->sb_used = 0;", "    ++spin->si_blocks_cnt;", "  }"], "readability/increment"]
["src/nvim/spellfile.c", ["static int", "store_word (", "    spellinfo_T *spin,"], "whitespace/parens"]
["src/nvim/spellfile.c", ["  (void)spell_casefold(word, len, foldword, MAXWLEN);", "  for (p = pfxlist; res == OK; ++p) {", "    if (!need_affix || (p != NULL && *p != NUL))"], "readability/increment"]
["src/nvim/spellfile.c", ["  for (p = pfxlist; res == OK; ++p) {", "    if (!need_affix || (p != NULL && *p != NUL))", "      res = tree_add_word(spin, foldword, spin->si_foldroot, ct | flags,"], "readability/braces"]
["src/nvim/spellfile.c", ["      res = tree_add_word(spin, foldword, spin->si_foldroot, ct | flags,", "          region, p == NULL ? 0 : *p);", "    if (p == NULL || *p == NUL)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["          region, p == NULL ? 0 : *p);", "    if (p == NULL || *p == NUL)", "      break;"], "readability/braces"]
["src/nvim/spellfile.c", ["  }", "  ++spin->si_foldwcount;", ""], "readability/increment"]
["src/nvim/spellfile.c", ["  if (res == OK && (ct == WF_KEEPCAP || (flags & WF_KEEPCAP))) {", "    for (p = pfxlist; res == OK; ++p) {", "      if (!need_affix || (p != NULL && *p != NUL))"], "readability/increment"]
["src/nvim/spellfile.c", ["    for (p = pfxlist; res == OK; ++p) {", "      if (!need_affix || (p != NULL && *p != NUL))", "        res = tree_add_word(spin, word, spin->si_keeproot, flags,"], "readability/braces"]
["src/nvim/spellfile.c", ["        res = tree_add_word(spin, word, spin->si_keeproot, flags,", "            region, p == NULL ? 0 : *p);", "      if (p == NULL || *p == NUL)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["            region, p == NULL ? 0 : *p);", "      if (p == NULL || *p == NUL)", "        break;"], "readability/braces"]
["src/nvim/spellfile.c", ["    }", "    ++spin->si_keepwcount;", "  }"], "readability/increment"]
["src/nvim/spellfile.c", ["// Returns FAIL when out of memory.", "static int tree_add_word(spellinfo_T *spin, char_u *word, wordnode_T *root, int flags, int region, int affixID)", "{"], "whitespace/line_length"]
["src/nvim/spellfile.c", ["  // Add each byte of the word to the tree, including the NUL at the end.", "  for (i = 0;; ++i) {", "    // When there is more than one reference to this node we need to make"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (node != NULL && node->wn_refs > 1) {", "      --node->wn_refs;", "      copyprev = prev;"], "readability/increment"]
["src/nvim/spellfile.c", ["        np = get_wordnode(spin);", "        if (np == NULL)", "          return FAIL;"], "readability/braces"]
["src/nvim/spellfile.c", ["        np->wn_child = copyp->wn_child;", "        if (np->wn_child != NULL)", "          ++np->wn_child->wn_refs;              // child gets extra ref"], "readability/braces"]
["src/nvim/spellfile.c", ["        if (np->wn_child != NULL)", "          ++np->wn_child->wn_refs;              // child gets extra ref", "        np->wn_byte = copyp->wn_byte;"], "readability/increment"]
["src/nvim/spellfile.c", ["        np->wn_refs = 1;", "        if (copyprev != NULL)", "          *copyprev = np;"], "readability/braces"]
["src/nvim/spellfile.c", ["        // Let \"node\" point to the head of the copied list.", "        if (copyp == node)", "          node = np;"], "readability/braces"]
["src/nvim/spellfile.c", ["      np = get_wordnode(spin);", "      if (np == NULL)", "        return FAIL;"], "readability/braces"]
["src/nvim/spellfile.c", ["      // of the list of siblings).", "      if (node == NULL)", "        np->wn_refs = 1;"], "readability/braces"]
["src/nvim/spellfile.c", ["        np->wn_refs = 1;", "      else {", "        np->wn_refs = node->wn_refs;"], "readability/braces"]
["src/nvim/spellfile.c", ["        np->wn_refs = 1;", "      else {", "        np->wn_refs = node->wn_refs;"], "readability/braces"]
["src/nvim/spellfile.c", ["      }", "      if (prev != NULL)", "        *prev = np;"], "readability/braces"]
["src/nvim/spellfile.c", ["  // count nr of words added since last message", "  ++spin->si_msg_count;", ""], "readability/increment"]
["src/nvim/spellfile.c", ["      ? spin->si_free_count < MAXWLEN", "                              : spin->si_blocks_cnt >= compress_start)", "#endif"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["      msg_clr_eos();", "      msg_didout = FALSE;", "      msg_col = 0;"], "readability/bool"]
["src/nvim/spellfile.c", ["", "  if (spin->si_first_free == NULL)", "    n = (wordnode_T *)getroom(spin, sizeof(wordnode_T), true);"], "readability/braces"]
["src/nvim/spellfile.c", ["    n = (wordnode_T *)getroom(spin, sizeof(wordnode_T), true);", "  else {", "    n = spin->si_first_free;"], "readability/braces"]
["src/nvim/spellfile.c", ["    n = (wordnode_T *)getroom(spin, sizeof(wordnode_T), true);", "  else {", "    n = spin->si_first_free;"], "readability/braces"]
["src/nvim/spellfile.c", ["    memset(n, 0, sizeof(wordnode_T));", "    --spin->si_free_count;", "  }"], "readability/increment"]
["src/nvim/spellfile.c", ["#ifdef SPELL_PRINTTREE", "  if (n != NULL)", "    n->wn_nr = ++spin->si_wordnode_nr;"], "readability/braces"]
["src/nvim/spellfile.c", ["    for (np = node; np != NULL; np = np->wn_sibling) {", "      if (np->wn_child != NULL)", "        cnt += deref_wordnode(spin, np->wn_child);"], "readability/braces"]
["src/nvim/spellfile.c", ["      free_wordnode(spin, np);", "      ++cnt;", "    }"], "readability/increment"]
["src/nvim/spellfile.c", ["    }", "    ++cnt;          // length field", "  }"], "readability/increment"]
["src/nvim/spellfile.c", ["  spin->si_first_free = n;", "  ++spin->si_free_count;", "}"], "readability/increment"]
["src/nvim/spellfile.c", ["#ifndef SPELL_PRINTTREE", "    if (spin->si_verbose || p_verbose > 2)", "#endif"], "readability/braces"]
["src/nvim/spellfile.c", ["    {", "      if (tot > 1000000)", "        perc = (tot - n) / (tot / 100);"], "readability/braces"]
["src/nvim/spellfile.c", ["        perc = (tot - n) / (tot / 100);", "      else if (tot == 0)", "        perc = 0;"], "readability/braces"]
["src/nvim/spellfile.c", ["        perc = 0;", "      else", "        perc = (tot - n) * 100 / tot;"], "readability/braces"]
["src/nvim/spellfile.c", ["  for (np = node; np != NULL && !got_int; np = np->wn_sibling) {", "    ++len;", "    if ((child = np->wn_child) != NULL) {"], "readability/increment"]
["src/nvim/spellfile.c", ["        // that is really identical.", "        for (tp = HI2WN(hi); tp != NULL; tp = tp->wn_u2.next)", "          if (node_equal(child, tp)) {"], "readability/braces"]
["src/nvim/spellfile.c", ["            // its siblings is unlinked from the tree.", "            ++tp->wn_refs;", "            compressed += deref_wordnode(spin, child);"], "readability/increment"]
["src/nvim/spellfile.c", ["        }", "      } else", "        // No other child has this hash value, add it to the"], "readability/braces"]
["src/nvim/spellfile.c", ["  for (np = node; np != NULL; np = np->wn_sibling) {", "    if (np->wn_byte == NUL)", "      // end node: use wn_flags, wn_region and wn_affixID"], "readability/braces"]
["src/nvim/spellfile.c", ["      n = np->wn_flags + (np->wn_region << 8) + (np->wn_affixID << 16);", "    else", "      // byte node: use the byte value and the child pointer"], "readability/braces"]
["src/nvim/spellfile.c", ["", "  for (p1 = n1, p2 = n2; p1 != NULL && p2 != NULL;", "       p1 = p1->wn_sibling, p2 = p2->wn_sibling)"], "readability/braces"]
["src/nvim/spellfile.c", ["       p1 = p1->wn_sibling, p2 = p2->wn_sibling)", "    if (p1->wn_byte != p2->wn_byte", "        || (p1->wn_byte == NUL"], "readability/braces"]
["src/nvim/spellfile.c", ["  size_t fwv = fwrite(VIMSPELLMAGIC, VIMSPELLMAGICL, 1, fd);", "  if (fwv != (size_t)1)", "    // Catch first write error, don't try writing more."], "readability/braces"]
["src/nvim/spellfile.c", ["    regionmask = (1 << spin->si_region_count) - 1;", "  } else", "    regionmask = 0;"], "readability/braces"]
["src/nvim/spellfile.c", ["    fputc(128, fd);                                     // <charflagslen>", "    for (size_t i = 128; i < 256; ++i) {", "      flags = 0;"], "readability/increment"]
["src/nvim/spellfile.c", ["      flags = 0;", "      if (spelltab.st_isw[i])", "        flags |= CF_WORD;"], "readability/braces"]
["src/nvim/spellfile.c", ["        flags |= CF_WORD;", "      if (spelltab.st_isu[i])", "        flags |= CF_UPPER;"], "readability/braces"]
["src/nvim/spellfile.c", ["  // round 3: SN_REPSAL section", "  for (unsigned int round = 1; round <= 3; ++round) {", "    garray_T *gap;"], "readability/increment"]
["src/nvim/spellfile.c", ["    garray_T *gap;", "    if (round == 1)", "      gap = &spin->si_rep;"], "readability/braces"]
["src/nvim/spellfile.c", ["      gap = &spin->si_rep;", "    else if (round == 2) {", "      // Don't write SN_SAL when using a SN_SOFO section"], "readability/braces"]
["src/nvim/spellfile.c", ["      // Don't write SN_SAL when using a SN_SOFO section", "      if (spin->si_sofofr != NULL && spin->si_sofoto != NULL)", "        continue;"], "readability/braces"]
["src/nvim/spellfile.c", ["      gap = &spin->si_sal;", "    } else", "      gap = &spin->si_repsal;"], "readability/braces"]
["src/nvim/spellfile.c", ["    // Don't write the section if there are no items.", "    if (GA_EMPTY(gap))", "      continue;"], "readability/braces"]
["src/nvim/spellfile.c", ["    // Sort the REP/REPSAL items.", "    if (round != 2)", "      qsort(gap->ga_data, (size_t)gap->ga_len,"], "readability/braces"]
["src/nvim/spellfile.c", ["      qsort(gap->ga_data, (size_t)gap->ga_len,", "          sizeof(fromto_T), rep_compare);", ""], "whitespace/alignment"]
["src/nvim/spellfile.c", ["    assert(gap->ga_len >= 0);", "    for (size_t i = 0; i < (size_t)gap->ga_len; ++i) {", "      fromto_T *ftp = &((fromto_T *)gap->ga_data)[i];"], "readability/increment"]
["src/nvim/spellfile.c", ["    }", "    if (round == 2)", "      ++l;                            // count <salflags>"], "readability/braces"]
["src/nvim/spellfile.c", ["    if (round == 2)", "      ++l;                            // count <salflags>", "    put_bytes(fd, l, 4);                                // <sectionlen>"], "readability/increment"]
["src/nvim/spellfile.c", ["      int i = 0;", "      if (spin->si_followup)", "        i |= SAL_F0LLOWUP;"], "readability/braces"]
["src/nvim/spellfile.c", ["        i |= SAL_F0LLOWUP;", "      if (spin->si_collapse)", "        i |= SAL_COLLAPSE;"], "readability/braces"]
["src/nvim/spellfile.c", ["        i |= SAL_COLLAPSE;", "      if (spin->si_rem_accents)", "        i |= SAL_REM_ACCENTS;"], "readability/braces"]
["src/nvim/spellfile.c", ["    put_bytes(fd, (uintmax_t)gap->ga_len, 2);    // <repcount> or <salcount>", "    for (size_t i = 0; i < (size_t)gap->ga_len; ++i) {", "      // <rep> : <repfromlen> <repfrom> <reptolen> <repto>"], "readability/increment"]
["src/nvim/spellfile.c", ["      fromto_T *ftp = &((fromto_T *)gap->ga_data)[i];", "      for (unsigned int rr = 1; rr <= 2; ++rr) {", "        char_u *p = rr == 1 ? ftp->ft_from : ftp->ft_to;"], "readability/increment"]
["src/nvim/spellfile.c", ["        putc((int)l, fd);", "        if (l > 0)", "          fwv &= fwrite(p, l, 1, fd);"], "readability/braces"]
["src/nvim/spellfile.c", ["    }", "", "  }"], "whitespace/blank_line"]
["src/nvim/spellfile.c", ["    // round 2: write the bytes", "    for (unsigned int round = 1; round <= 2; ++round) {", "      size_t todo;"], "readability/increment"]
["src/nvim/spellfile.c", ["      todo = spin->si_commonwords.ht_used;", "      for (hi = spin->si_commonwords.ht_array; todo > 0; ++hi)", "        if (!HASHITEM_EMPTY(hi)) {"], "readability/braces"]
["src/nvim/spellfile.c", ["      todo = spin->si_commonwords.ht_used;", "      for (hi = spin->si_commonwords.ht_array; todo > 0; ++hi)", "        if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/spellfile.c", ["          len += l;", "          if (round == 2)                               // <word>", "            fwv &= fwrite(hi->hi_key, l, 1, fd);"], "readability/braces"]
["src/nvim/spellfile.c", ["            fwv &= fwrite(hi->hi_key, l, 1, fd);", "          --todo;", "        }"], "readability/increment"]
["src/nvim/spellfile.c", ["        }", "      if (round == 1)", "        put_bytes(fd, len, 4);                          // <sectionlen>"], "readability/braces"]
["src/nvim/spellfile.c", ["    assert(spin->si_comppat.ga_len >= 0);", "    for (size_t i = 0; i < (size_t)spin->si_comppat.ga_len; ++i) {", "      l += STRLEN(((char_u **)(spin->si_comppat.ga_data))[i]) + 1;"], "readability/increment"]
["src/nvim/spellfile.c", ["    put_bytes(fd, (uintmax_t)spin->si_comppat.ga_len, 2);  // <comppatcount>", "    for (size_t i = 0; i < (size_t)spin->si_comppat.ga_len; ++i) {", "      char_u *p = ((char_u **)(spin->si_comppat.ga_data))[i];"], "readability/increment"]
["src/nvim/spellfile.c", ["  spin->si_memtot = 0;", "  for (unsigned int round = 1; round <= 3; ++round) {", "    wordnode_T *tree;"], "readability/increment"]
["src/nvim/spellfile.c", ["    wordnode_T *tree;", "    if (round == 1)", "      tree = spin->si_foldroot->wn_sibling;"], "readability/braces"]
["src/nvim/spellfile.c", ["      tree = spin->si_foldroot->wn_sibling;", "    else if (round == 2)", "      tree = spin->si_keeproot->wn_sibling;"], "readability/braces"]
["src/nvim/spellfile.c", ["      tree = spin->si_keeproot->wn_sibling;", "    else", "      tree = spin->si_prefroot->wn_sibling;"], "readability/braces"]
["src/nvim/spellfile.c", ["  // Write another byte to check for errors (file system full).", "  if (putc(0, fd) == EOF)", "    retval = FAIL;"], "readability/braces"]
["src/nvim/spellfile.c", ["theend:", "  if (fclose(fd) == EOF)", "    retval = FAIL;"], "readability/braces"]
["src/nvim/spellfile.c", ["", "  if (fwv != (size_t)1)", "    retval = FAIL;"], "readability/braces"]
["src/nvim/spellfile.c", ["    retval = FAIL;", "  if (retval == FAIL)", "    EMSG(_(e_write));"], "readability/braces"]
["src/nvim/spellfile.c", ["", "  if (node != NULL)", "    for (np = node; np != NULL; np = np->wn_sibling) {"], "readability/braces"]
["src/nvim/spellfile.c", ["", "      if (np->wn_byte != NUL)", "        clear_node(np->wn_child);"], "readability/braces"]
["src/nvim/spellfile.c", ["static int", "put_node (", "    FILE *fd,                // NULL when only counting"], "whitespace/parens"]
["src/nvim/spellfile.c", ["  // If \"node\" is zero the tree is empty.", "  if (node == NULL)", "    return 0;"], "readability/braces"]
["src/nvim/spellfile.c", ["  int siblingcount = 0;", "  for (wordnode_T *np = node; np != NULL; np = np->wn_sibling)", "    ++siblingcount;"], "readability/braces"]
["src/nvim/spellfile.c", ["  for (wordnode_T *np = node; np != NULL; np = np->wn_sibling)", "    ++siblingcount;", ""], "readability/increment"]
["src/nvim/spellfile.c", ["  // Write the sibling count.", "  if (fd != NULL)", "    putc(siblingcount, fd);                             // <siblingcount>"], "readability/braces"]
["src/nvim/spellfile.c", ["          // combining\" flags", "          if (np->wn_flags == (uint16_t)PFX_FLAGS)", "            putc(BY_NOFLAGS, fd);                       // <byte>"], "readability/braces"]
["src/nvim/spellfile.c", ["            putc(BY_NOFLAGS, fd);                       // <byte>", "          else {", "            putc(BY_FLAGS, fd);                         // <byte>"], "readability/braces"]
["src/nvim/spellfile.c", ["            putc(BY_NOFLAGS, fd);                       // <byte>", "          else {", "            putc(BY_FLAGS, fd);                         // <byte>"], "readability/braces"]
["src/nvim/spellfile.c", ["          int flags = np->wn_flags;", "          if (regionmask != 0 && np->wn_region != regionmask)", "            flags |= WF_REGION;"], "readability/braces"]
["src/nvim/spellfile.c", ["            flags |= WF_REGION;", "          if (np->wn_affixID != 0)", "            flags |= WF_AFX;"], "readability/braces"]
["src/nvim/spellfile.c", ["            }", "            if (flags & WF_REGION)", "              putc(np->wn_region, fd);                          // <region>"], "readability/braces"]
["src/nvim/spellfile.c", ["              putc(np->wn_region, fd);                          // <region>", "            if (flags & WF_AFX)", "              putc(np->wn_affixID, fd);                         // <affixID>"], "readability/braces"]
["src/nvim/spellfile.c", ["        }", "      } else if (np->wn_child->wn_u2.wnode == NULL)", "        // We will write the child below and give it an index."], "readability/braces"]
["src/nvim/spellfile.c", ["", "      if (fd != NULL)", "        if (putc(np->wn_byte, fd) == EOF) {       // <byte> or <xbyte>"], "readability/braces"]
["src/nvim/spellfile.c", ["  // Recursively dump the children of each sibling.", "  for (wordnode_T *np = node; np != NULL; np = np->wn_sibling)", "    if (np->wn_byte != 0 && np->wn_child->wn_u2.wnode == node)"], "readability/braces"]
["src/nvim/spellfile.c", ["  for (wordnode_T *np = node; np != NULL; np = np->wn_sibling)", "    if (np->wn_byte != 0 && np->wn_child->wn_u2.wnode == node)", "      newindex = put_node(fd, np->wn_child, newindex, regionmask,"], "readability/braces"]
["src/nvim/spellfile.c", ["      newindex = put_node(fd, np->wn_child, newindex, regionmask,", "          prefixtree);", ""], "whitespace/alignment"]
["src/nvim/spellfile.c", ["    slang = spell_load_file(wfname, NULL, NULL, false);", "    if (slang == NULL)", "      return;"], "readability/braces"]
["src/nvim/spellfile.c", ["  spell_message(spin, (char_u *)_(\"Performing soundfolding...\"));", "  if (sug_filltree(spin, slang) == FAIL)", "    goto theend;"], "readability/braces"]
["src/nvim/spellfile.c", ["  // compression possible.", "  if (sug_maketable(spin) == FAIL)", "    goto theend;"], "readability/braces"]
["src/nvim/spellfile.c", ["  xfree(fname);", "  if (free_slang)", "    slang_free(slang);"], "readability/braces"]
["src/nvim/spellfile.c", ["      idxs[arridx[depth]] = wordcount[depth];", "      if (depth > 0)", "        wordcount[depth - 1] += wordcount[depth];"], "readability/braces"]
["src/nvim/spellfile.c", ["", "      --depth;", "      line_breakcheck();"], "readability/increment"]
["src/nvim/spellfile.c", ["    } else {", "", "      // Do one more byte at this node."], "whitespace/blank_line"]
["src/nvim/spellfile.c", ["      n = arridx[depth] + curi[depth];", "      ++curi[depth];", ""], "readability/increment"]
["src/nvim/spellfile.c", ["        // \"region\" for the LSB of the wordnr.", "        if (tree_add_word(spin, tsalword, spin->si_foldroot,", "                words_done >> 16, words_done & 0xffff,"], "readability/braces"]
["src/nvim/spellfile.c", ["        if (tree_add_word(spin, tsalword, spin->si_foldroot,", "                words_done >> 16, words_done & 0xffff,", "                0) == FAIL)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                words_done >> 16, words_done & 0xffff,", "                0) == FAIL)", "          return FAIL;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["", "        ++words_done;", "        ++wordcount[depth];"], "readability/increment"]
["src/nvim/spellfile.c", ["        ++words_done;", "        ++wordcount[depth];", ""], "readability/increment"]
["src/nvim/spellfile.c", ["  // recursively go through the tree", "  if (sug_filltable(spin, spin->si_foldroot->wn_sibling, 0, &ga) == -1)", "    res = FAIL;"], "readability/braces"]
["src/nvim/spellfile.c", ["static int", "sug_filltable (", "    spellinfo_T *spin,"], "whitespace/parens"]
["src/nvim/spellfile.c", ["        gap->ga_len += offset2bytes(nr,", "            (char_u *)gap->ga_data + gap->ga_len);", "      }"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["      // bother freeing the nodes, the won't be reused anyway.", "      while (p->wn_sibling != NULL && p->wn_sibling->wn_byte == NUL)", "        p->wn_sibling = p->wn_sibling->wn_sibling;"], "readability/braces"]
["src/nvim/spellfile.c", ["      wordnr = sug_filltable(spin, p->wn_child, wordnr, gap);", "      if (wordnr == -1)", "        return -1;"], "readability/braces"]
["src/nvim/spellfile.c", ["  }", "  if (b3 > 1 || b2 > 0x3f ) {   // 3 bytes", "    buf[0] = 0xc0 + b3;"], "whitespace/parens"]
["src/nvim/spellfile.c", ["  }", "  if (b2 > 1 || b1 > 0x7f ) {   // 2 bytes", "    buf[0] = 0x80 + b2;"], "whitespace/parens"]
["src/nvim/spellfile.c", ["  // <SUGHEADER>: <fileID> <versionnr> <timestamp>", "  if (fwrite(VIMSUGMAGIC, VIMSUGMAGICL, (size_t)1, fd) != 1) { // <fileID>", "    EMSG(_(e_write));"], "whitespace/comments"]
["src/nvim/spellfile.c", ["", "  for (linenr_T lnum = 1; lnum <= wcount; ++lnum) {", "    // <sugline>: <sugnr> ... NUL"], "readability/increment"]
["src/nvim/spellfile.c", ["    // <sugline>: <sugnr> ... NUL", "    char_u *line = ml_get_buf(spin->si_spellbuf, lnum, FALSE);", "    size_t len = STRLEN(line) + 1;"], "readability/bool"]
["src/nvim/spellfile.c", ["  // Write another byte to check for errors.", "  if (putc(0, fd) == EOF)", "    EMSG(_(e_write));"], "readability/braces"]
["src/nvim/spellfile.c", ["  vim_snprintf((char *)IObuff, IOSIZE,", "      _(\"Estimated runtime memory use: %d bytes\"), spin->si_memtot);", "  spell_message(spin, IObuff);"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["static void", "mkspell (", "    int fcount,"], "whitespace/parens"]
["src/nvim/spellfile.c", ["      vim_snprintf((char *)wfname, MAXPATHL, SPL_FNAME_TMPL,", "          fnames[0], spin.si_ascii ? (char_u *)\"ascii\" : spell_enc());", "    } else if (len > 4 && STRCMP(fnames[0] + len - 4, \".spl\") == 0)   {"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["      STRLCPY(wfname, fnames[0], MAXPATHL);", "    } else", "      // Name should be language, make the file name from it."], "readability/braces"]
["src/nvim/spellfile.c", ["      vim_snprintf((char *)wfname, MAXPATHL, SPL_FNAME_TMPL,", "          fnames[0], spin.si_ascii ? (char_u *)\"ascii\" : spell_enc());", ""], "whitespace/alignment"]
["src/nvim/spellfile.c", ["    // Check for .ascii.spl.", "    if (strstr((char *)path_tail(wfname), SPL_FNAME_ASCII) != NULL)", "      spin.si_ascii = true;"], "readability/braces"]
["src/nvim/spellfile.c", ["    // Check for .add.spl.", "    if (strstr((char *)path_tail(wfname), SPL_FNAME_ADD) != NULL)", "      spin.si_add = true;"], "readability/braces"]
["src/nvim/spellfile.c", ["    // Get the region names if there are more than 2 arguments.", "    for (i = 0; i < incount; ++i) {", "      afile[i] = NULL;"], "readability/increment"]
["src/nvim/spellfile.c", ["    // previously loaded spell file.", "    if (!spin.si_add)", "      spin.si_clear_chartab = true;"], "readability/braces"]
["src/nvim/spellfile.c", ["    // Words are stored in the case-folded and keep-case trees.", "    for (i = 0; i < incount && !error; ++i) {", "      spin.si_conv.vc_type = CONV_NONE;"], "readability/increment"]
["src/nvim/spellfile.c", ["        afile[i] = spell_read_aff(&spin, fname);", "        if (afile[i] == NULL)", "          error = true;"], "readability/braces"]
["src/nvim/spellfile.c", ["          error = true;", "        else {", "          // Read the .dic file and store the words in the trees."], "readability/braces"]
["src/nvim/spellfile.c", ["          error = true;", "        else {", "          // Read the .dic file and store the words in the trees."], "readability/braces"]
["src/nvim/spellfile.c", ["          vim_snprintf((char *)fname, MAXPATHL, \"%s.dic\",", "              innames[i]);", "          if (spell_read_dic(&spin, fname, afile[i]) == FAIL)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["              innames[i]);", "          if (spell_read_dic(&spin, fname, afile[i]) == FAIL)", "            error = true;"], "readability/braces"]
["src/nvim/spellfile.c", ["        // the words in the trees.", "        if (spell_read_wordfile(&spin, innames[i]) == FAIL)", "          error = true;"], "readability/braces"]
["src/nvim/spellfile.c", ["", "    if (spin.si_compflags != NULL && spin.si_nobreak)", "      MSG(_(\"Warning: both compounding and NOBREAK specified\"));"], "readability/braces"]
["src/nvim/spellfile.c", ["      vim_snprintf((char *)IObuff, IOSIZE,", "          _(\"Estimated runtime memory use: %d bytes\"), spin.si_memtot);", "      spell_message(&spin, IObuff);"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["      // If the file is loaded need to reload it.", "      if (!error)", "        spell_reload_one(wfname, added_word);"], "readability/braces"]
["src/nvim/spellfile.c", ["    // Free the .aff file structures.", "    for (i = 0; i < incount; ++i)", "      if (afile[i] != NULL)"], "readability/braces"]
["src/nvim/spellfile.c", ["    // Free the .aff file structures.", "    for (i = 0; i < incount; ++i)", "      if (afile[i] != NULL)"], "readability/increment"]
["src/nvim/spellfile.c", ["    for (i = 0; i < incount; ++i)", "      if (afile[i] != NULL)", "        spell_free_aff(afile[i]);"], "readability/braces"]
["src/nvim/spellfile.c", ["    // .sug file with the soundfolded word trie.", "    if (spin.si_sugtime != 0 && !error && !got_int)", "      spell_make_sugfile(&spin, wfname);"], "readability/braces"]
["src/nvim/spellfile.c", ["      spell_make_sugfile(&spin, wfname);", "", "  }"], "whitespace/blank_line"]
["src/nvim/spellfile.c", ["  if (spin->si_verbose || p_verbose > 2) {", "    if (!spin->si_verbose)", "      verbose_enter();"], "readability/braces"]
["src/nvim/spellfile.c", ["    ui_flush();", "    if (!spin->si_verbose)", "      verbose_leave();"], "readability/braces"]
["src/nvim/spellfile.c", ["  spell_add_word(eap->arg, (int)STRLEN(eap->arg), eap->cmdidx == CMD_spellwrong,", "      eap->forceit ? 0 : (int)eap->line2,", "      eap->cmdidx == CMD_spellundo);"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["      eap->forceit ? 0 : (int)eap->line2,", "      eap->cmdidx == CMD_spellundo);", "}"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["void", "spell_add_word (", "    char_u *word,"], "whitespace/parens"]
["src/nvim/spellfile.c", ["      int_wordlist = vim_tempname();", "      if (int_wordlist == NULL)", "        return;"], "readability/braces"]
["src/nvim/spellfile.c", ["", "    for (spf = curwin->w_s->b_p_spf, i = 1; *spf != NUL; ++i) {", "      copy_option_part(&spf, fnamebuf, MAXPATHL, \",\");"], "readability/increment"]
["src/nvim/spellfile.c", ["      copy_option_part(&spf, fnamebuf, MAXPATHL, \",\");", "      if (i == idx)", "        break;"], "readability/braces"]
["src/nvim/spellfile.c", ["    buf = buflist_findname_exp(fnamebuf);", "    if (buf != NULL && buf->b_ml.ml_mfp == NULL)", "      buf = NULL;"], "readability/braces"]
["src/nvim/spellfile.c", ["            if (undo) {", "              home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);", "              smsg(_(\"Word '%.*s' removed from %s\"),"], "readability/bool"]
["src/nvim/spellfile.c", ["      }", "      if (fd != NULL)", "        fclose(fd);"], "readability/braces"]
["src/nvim/spellfile.c", ["      // init_spellfile().", "      if (!dir_of_file_exists(fname) && (p = path_tail_with_sep(fname)) != fname) {", "        int c = *p;"], "whitespace/line_length"]
["src/nvim/spellfile.c", ["", "    if (fd == NULL)", "      EMSG2(_(e_notopen), fname);"], "readability/braces"]
["src/nvim/spellfile.c", ["      EMSG2(_(e_notopen), fname);", "    else {", "      if (bad)"], "readability/braces"]
["src/nvim/spellfile.c", ["      EMSG2(_(e_notopen), fname);", "    else {", "      if (bad)"], "readability/braces"]
["src/nvim/spellfile.c", ["    else {", "      if (bad)", "        fprintf(fd, \"%.*s/!\\n\", len, word);"], "readability/braces"]
["src/nvim/spellfile.c", ["        fprintf(fd, \"%.*s/!\\n\", len, word);", "      else", "        fprintf(fd, \"%.*s\\n\", len, word);"], "readability/braces"]
["src/nvim/spellfile.c", ["", "      home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);", "      smsg(_(\"Word '%.*s' added to %s\"), len, word, NameBuff);"], "readability/bool"]
["src/nvim/spellfile.c", ["    // If the .add file is edited somewhere, reload it.", "    if (buf != NULL)", "      buf_reload(buf, buf->b_orig_mode);"], "readability/braces"]
["src/nvim/spellfile.c", ["    // is a path separator remember the start of the tail.", "    for (lend = curwin->w_s->b_p_spl; *lend != NUL", "         && vim_strchr((char_u *)\",._\", *lend) == NULL; ++lend)"], "readability/braces"]
["src/nvim/spellfile.c", ["    for (lend = curwin->w_s->b_p_spl; *lend != NUL", "         && vim_strchr((char_u *)\",._\", *lend) == NULL; ++lend)", "      if (vim_ispathsep(*lend)) {"], "readability/increment"]
["src/nvim/spellfile.c", ["    while (*rtp != NUL) {", "      if (aspath)", "        // Use directory of an entry with path, e.g., for"], "readability/braces"]
["src/nvim/spellfile.c", ["        STRLCPY(buf, curbuf->b_s.b_p_spl,", "            lstart - curbuf->b_s.b_p_spl);", "      else"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["            lstart - curbuf->b_s.b_p_spl);", "      else", "        // Copy the path from 'runtimepath' to buf[]."], "readability/braces"]
["src/nvim/spellfile.c", ["        // encoding used in the first loaded .spl file.", "        if (aspath)", "          STRLCPY(buf, curbuf->b_s.b_p_spl,"], "readability/braces"]
["src/nvim/spellfile.c", ["          STRLCPY(buf, curbuf->b_s.b_p_spl,", "              lend - curbuf->b_s.b_p_spl + 1);", "        else {"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["              lend - curbuf->b_s.b_p_spl + 1);", "        else {", "          // Create the \"spell\" directory if it doesn't exist yet."], "readability/braces"]
["src/nvim/spellfile.c", ["              lend - curbuf->b_s.b_p_spl + 1);", "        else {", "          // Create the \"spell\" directory if it doesn't exist yet."], "readability/braces"]
["src/nvim/spellfile.c", ["          vim_snprintf((char *)buf + l, MAXPATHL - l,", "              \"/%.*s\", (int)(lend - lstart), lstart);", "        }"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["static void", "set_spell_charflags (", "    char_u *flags,"], "whitespace/parens"]
["src/nvim/spellfile.c", ["", "  for (i = 0; i < 128; ++i) {", "    if (i < cnt) {"], "readability/increment"]
["src/nvim/spellfile.c", ["      new_st.st_fold[i + 128] = c;", "      if (i + 128 != c && new_st.st_isu[i + 128] && c < 256)", "        new_st.st_upper[c] = i + 128;"], "readability/braces"]
["src/nvim/spellfile.c", ["    // check that it's the same table", "    for (i = 0; i < 256; ++i) {", "      if (spelltab.st_isw[i] != new_st->st_isw[i]"], "readability/increment"]
["src/nvim/spellfile.c", ["", "  if (fd != NULL)", "    put_bytes(fd, (uintmax_t)gap->ga_len, 2);           // <prefcondcnt>"], "readability/braces"]
["src/nvim/spellfile.c", ["  size_t x = 1;  // collect return value of fwrite()", "  for (int i = 0; i < gap->ga_len; ++i) {", "    // <prefcond> : <condlen> <condstr>"], "readability/increment"]
["src/nvim/spellfile.c", ["      totlen += len;", "    } else if (fd != NULL)", "      fputc(0, fd);"], "readability/braces"]
["src/nvim/spellfile.c", ["  // Init the array and hash tables empty.", "  for (i = 0; i < 256; ++i)", "    lp->sl_map_array[i] = 0;"], "readability/braces"]
["src/nvim/spellfile.c", ["  // Init the array and hash tables empty.", "  for (i = 0; i < 256; ++i)", "    lp->sl_map_array[i] = 0;"], "readability/increment"]
["src/nvim/spellfile.c", ["        }", "      } else", "        lp->sl_map_array[c] = headc;"], "readability/braces"]
