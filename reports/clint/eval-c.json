["src/nvim/eval.c", ["", "/*", " * eval.c: Expression evaluation."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Old Vim variables such as \"v:version\" are also available without the \"v:\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Array to hold the hashtab with variables local to each sourced script."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "static garray_T ga_scripts = {0, 0, sizeof(scriptvar_T *), 4, NULL};", "#define SCRIPT_SV(id) (((scriptvar_T **)ga_scripts.ga_data)[(id) - 1])"], "whitespace/braces"]
["src/nvim/eval.c", ["", "static garray_T ga_scripts = {0, 0, sizeof(scriptvar_T *), 4, NULL};", "#define SCRIPT_SV(id) (((scriptvar_T **)ga_scripts.ga_data)[(id) - 1])"], "whitespace/braces"]
["src/nvim/eval.c", ["", "/*", " * Info used by a \":for\" loop."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Initialize the global and v: variables."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    STRCPY(p->vv_di.di_key, p->vv_name);", "    if (p->vv_flags & VV_RO)", "      p->vv_di.di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;"], "readability/braces"]
["src/nvim/eval.c", ["      p->vv_di.di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;", "    else if (p->vv_flags & VV_RO_SBX)", "      p->vv_di.di_flags = DI_FLAGS_RO_SBX | DI_FLAGS_FIX;"], "readability/braces"]
["src/nvim/eval.c", ["      p->vv_di.di_flags = DI_FLAGS_RO_SBX | DI_FLAGS_FIX;", "    else", "      p->vv_di.di_flags = DI_FLAGS_FIX;"], "readability/braces"]
["src/nvim/eval.c", ["", "  /* Script-local variables. First clear all the variables and in a second", "   * loop free the scriptvar_T, because a variable in one script might hold"], "readability/old_style_comment"]
["src/nvim/eval.c", ["   * a reference to the whole scope of another script. */", "  for (int i = 1; i <= ga_scripts.ga_len; ++i)", "    vars_clear(&SCRIPT_VARS(i));"], "readability/braces"]
["src/nvim/eval.c", ["   * a reference to the whole scope of another script. */", "  for (int i = 1; i <= ga_scripts.ga_len; ++i)", "    vars_clear(&SCRIPT_VARS(i));"], "readability/increment"]
["src/nvim/eval.c", ["    vars_clear(&SCRIPT_VARS(i));", "  for (int i = 1; i <= ga_scripts.ga_len; ++i)", "    xfree(SCRIPT_SV(i));"], "readability/braces"]
["src/nvim/eval.c", ["    vars_clear(&SCRIPT_VARS(i));", "  for (int i = 1; i <= ga_scripts.ga_len; ++i)", "    xfree(SCRIPT_SV(i));"], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * Set an internal variable to a string value. Creates the variable if it does"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Start recording command output to a variable"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /* check if we can write to the variable: set it to or append an empty", "   * string */"], "readability/old_style_comment"]
["src/nvim/eval.c", ["  save_emsg = did_emsg;", "  did_emsg = FALSE;", "  tv.v_type = VAR_STRING;"], "readability/bool"]
["src/nvim/eval.c", ["", "/*", " * Append \"value[value_len]\" to the variable set by var_redir_start()."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  if (redir_lval == NULL)", "    return;"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Stop redirecting command output to a variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  set_vim_var_string(VV_FNAME_OUT, outfile, -1);", "  (void)eval_to_bool(p_dex, &err, NULL, FALSE);", "  set_vim_var_string(VV_FNAME_IN, NULL, -1);"], "readability/bool"]
["src/nvim/eval.c", ["  set_vim_var_string(VV_FNAME_OUT, outfile, -1);", "  (void)eval_to_bool(p_pex, &err, NULL, FALSE);", "  set_vim_var_string(VV_FNAME_IN, NULL, -1);"], "readability/bool"]
["src/nvim/eval.c", ["", "/*", " * Top level evaluation function, returning a boolean."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Skip over an expression at \"*pp\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  *pp = skipwhite(*pp);", "  return eval1(pp, &rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval.c", ["", "/*", " * Top level evaluation function, returning a string."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Call eval_to_string() without using current local variables and using"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Top level evaluation function, returning a number."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  ++emsg_off;", ""], "readability/increment"]
["src/nvim/eval.c", ["  }", "  --emsg_off;", ""], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * Prepare v: variable \"idx\" to be used."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  *save_tv = vimvars[idx].vv_tv;", "  if (vimvars[idx].vv_type == VAR_UNKNOWN)", "    hash_add(&vimvarht, vimvars[idx].vv_di.di_key);"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Restore v: variable \"idx\" to typeval \"save_tv\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Evaluate an expression to a list with suggestions."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  vimvars[VV_VAL].vv_str = badword;", "  if (p_verbose == 0)", "    ++emsg_off;"], "readability/braces"]
["src/nvim/eval.c", ["  if (p_verbose == 0)", "    ++emsg_off;", ""], "readability/increment"]
["src/nvim/eval.c", ["", "  if (p_verbose == 0)", "    --emsg_off;"], "readability/braces"]
["src/nvim/eval.c", ["  if (p_verbose == 0)", "    --emsg_off;", "  restore_vimvar(VV_VAL, &save_val);"], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * Prepare profiling for entering a child or something else that is not"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Take care of time spent in a child."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Evaluate 'foldexpr'.  Returns the foldlevel, and any character preceding"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  ++emsg_off;", "  if (use_sandbox)"], "readability/increment"]
["src/nvim/eval.c", ["  ++emsg_off;", "  if (use_sandbox)", "    ++sandbox;"], "readability/braces"]
["src/nvim/eval.c", ["  if (use_sandbox)", "    ++sandbox;", "  ++textlock;"], "readability/increment"]
["src/nvim/eval.c", ["    ++sandbox;", "  ++textlock;", "  *cp = NUL;"], "readability/increment"]
["src/nvim/eval.c", ["  }", "  --emsg_off;", "  if (use_sandbox)"], "readability/increment"]
["src/nvim/eval.c", ["  --emsg_off;", "  if (use_sandbox)", "    --sandbox;"], "readability/braces"]
["src/nvim/eval.c", ["  if (use_sandbox)", "    --sandbox;", "  --textlock;"], "readability/increment"]
["src/nvim/eval.c", ["    --sandbox;", "  --textlock;", ""], "readability/increment"]
["src/nvim/eval.c", ["  char_u      *argend;", "  int first = TRUE;", ""], "readability/bool"]
["src/nvim/eval.c", ["", "    if (eap->skip)", "      ++emsg_skip;"], "readability/braces"]
["src/nvim/eval.c", ["    if (eap->skip)", "      ++emsg_skip;", "    i = eval0(expr, &rettv, &eap->nextcmd, !eap->skip);"], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * Assign the typevalue \"tv\" to the variable or variables at \"arg_start\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  if (*arg != '[') {", "    /*", "     * \":let var = expr\" or \":for var in list\""], "readability/old_style_comment"]
["src/nvim/eval.c", ["    if (*arg == ';') {", "      /* Put the rest of the list (may be empty) in the var after ';'.", "       * Create a new list for this. */"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Skip over assignable variable \"var\" or list of variables \"[var, var]\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["      }", "      ++*var_count;", ""], "readability/increment"]
["src/nvim/eval.c", ["      p = skipwhite(s);", "      if (*p == ']')", "        break;"], "readability/braces"]
["src/nvim/eval.c", ["        break;", "      else if (*p == ';') {", "        if (*semicolon == 1) {"], "readability/braces"]
["src/nvim/eval.c", ["    return p + 1;", "  } else", "    return skip_var_one(arg);"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Skip one (assignable) variable name, including @r, $VAR, &option, d.key,"], "readability/old_style_comment"]
["src/nvim/eval.c", ["{", "  if (*arg == '@' && arg[1] != NUL)", "    return arg + 2;"], "readability/braces"]
["src/nvim/eval.c", ["  return find_name_end(*arg == '$' || *arg == '&' ? arg + 1 : arg,", "      NULL, NULL, FNE_INCL_BR | FNE_CHECK_START);", "}"], "whitespace/alignment"]
["src/nvim/eval.c", ["", "/*", " * List variables for hashtab \"ht\" with prefix \"prefix\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  todo = (int)ht->ht_used;", "  for (hi = ht->ht_array; todo > 0 && !got_int; ++hi) {", "    if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * List global variables."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * List buffer variables."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * List window variables."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * List tab page variables."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * List Vim variables."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * List variables in \"arg\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["{", "  int error = FALSE;", "  int len;"], "readability/bool"]
["src/nvim/eval.c", ["      if (len <= 0) {", "        /* This is mainly to keep test 49 working: when expanding", "         * curly braces fails overrule the exception error message. */"], "readability/old_style_comment"]
["src/nvim/eval.c", ["        }", "        error = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/eval.c", ["", "  /*", "   * \":let $VAR = expr\": Set environment variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  }", "  /*", "   * \":let var = expr\": Set internal variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["   */", "  else if (eval_isnamec1(*arg) || *arg == '{') {", "    lval_T lv;"], "whitespace/newline"]
["src/nvim/eval.c", ["    clear_lval(&lv);", "  } else", "    EMSG2(_(e_invarg2), arg);"], "readability/braces"]
["src/nvim/eval.c", ["  typval_T var2;", "  int empty1 = FALSE;", "  listitem_T  *ni;"], "readability/bool"]
["src/nvim/eval.c", ["    if (lp->ll_exp_name == NULL) {", "      /* Report an invalid expression in braces, unless the", "       * expression evaluation has been cancelled due to an"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Loop until no more [idx] or .key is following."], "readability/old_style_comment"]
["src/nvim/eval.c", ["             && lp->ll_tv->vval.v_dict != NULL)) {", "      if (!quiet)", "        EMSG(_(\"E689: Can only index a List or Dictionary\"));"], "readability/braces"]
["src/nvim/eval.c", ["    if (lp->ll_range) {", "      if (!quiet)", "        EMSG(_(\"E708: [:] must come last\"));"], "readability/braces"]
["src/nvim/eval.c", ["", "      /* When assigning to a scope dictionary check that a function and", "       * variable name is valid (only variable name unless it is l: or"], "readability/old_style_comment"]
["src/nvim/eval.c", ["          if (ni == NULL) {", "            if (!quiet)", "              EMSGN(_(e_listidx), lp->ll_n2);"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Clear lval \"lp\" that was filled by get_lval()."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Set a variable that was parsed by get_lval() to \"rettv\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    /*", "     * Assign the List values to the list items."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Evaluate the expression used in a \":for var in expr\" command."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  expr = skip_var_list(arg, &fi->fi_varcount, &fi->fi_semicolon);", "  if (expr == NULL)", "    return fi;"], "readability/braces"]
["src/nvim/eval.c", ["", "  if (skip)", "    ++emsg_skip;"], "readability/braces"]
["src/nvim/eval.c", ["  if (skip)", "    ++emsg_skip;", "  if (eval0(skipwhite(expr + 2), &tv, nextcmdp, !skip) == OK) {"], "readability/increment"]
["src/nvim/eval.c", ["      } else {", "        /* No need to increment the refcount, it's already set for the", "         * list being used in \"tv\". */"], "readability/old_style_comment"]
["src/nvim/eval.c", ["  }", "  if (skip)", "    --emsg_skip;"], "readability/braces"]
["src/nvim/eval.c", ["  if (skip)", "    --emsg_skip;", ""], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * Use the first item in a \":for\" list.  Advance to the next."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Free the structure used to store info used by \":for\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["{", "  int got_eq = FALSE;", "  int c;"], "readability/bool"]
["src/nvim/eval.c", ["    }", "  } else", "    xp->xp_context = cmdidx == CMD_call ? EXPAND_FUNCTIONS"], "readability/braces"]
["src/nvim/eval.c", ["  while ((xp->xp_pattern = vim_strpbrk(arg,", "              (char_u *)\"\\\"'+-*/%.=!?~|&$([<>,#\")) != NULL) {", "    c = *xp->xp_pattern;"], "whitespace/alignment"]
["src/nvim/eval.c", ["      if (c == '&') {", "        ++xp->xp_pattern;", "        xp->xp_context = cmdidx != CMD_let || got_eq"], "readability/increment"]
["src/nvim/eval.c", ["        xp->xp_context = EXPAND_SETTINGS;", "        if ((c == 'l' || c == 'g') && xp->xp_pattern[2] == ':')", "          xp->xp_pattern += 2;"], "readability/braces"]
["src/nvim/eval.c", ["          xp->xp_pattern += 2;", "", "      }"], "whitespace/blank_line"]
["src/nvim/eval.c", ["    } else if (c == '=') {", "      got_eq = TRUE;", "      xp->xp_context = EXPAND_EXPRESSION;"], "readability/bool"]
["src/nvim/eval.c", ["        if (xp->xp_pattern[1] == '|') {", "          ++xp->xp_pattern;", "          xp->xp_context = EXPAND_EXPRESSION;"], "readability/increment"]
["src/nvim/eval.c", ["          xp->xp_context = EXPAND_EXPRESSION;", "        } else", "          xp->xp_context = EXPAND_COMMANDS;"], "readability/braces"]
["src/nvim/eval.c", ["          xp->xp_context = EXPAND_COMMANDS;", "      } else", "        xp->xp_context = EXPAND_EXPRESSION;"], "readability/braces"]
["src/nvim/eval.c", ["        xp->xp_context = EXPAND_EXPRESSION;", "    } else", "      /* Doesn't look like something valid, expand as an expression"], "readability/braces"]
["src/nvim/eval.c", ["    } else", "      /* Doesn't look like something valid, expand as an expression", "       * anyway. */"], "readability/old_style_comment"]
["src/nvim/eval.c", ["  }", "  if (forceit)", "    return OK;"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Delete all \"menutrans_\" variables."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Local string buffer for the next two functions to store a variable name"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Function to concatenate a prefix and a variable name."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the list of user defined"], "readability/old_style_comment"]
["src/nvim/eval.c", ["  if (gdone < globvarht.ht_used) {", "    if (gdone++ == 0)", "      hi = globvarht.ht_array;"], "readability/braces"]
["src/nvim/eval.c", ["      hi = globvarht.ht_array;", "    else", "      ++hi;"], "readability/braces"]
["src/nvim/eval.c", ["    else", "      ++hi;", "    while (HASHITEM_EMPTY(hi))"], "readability/increment"]
["src/nvim/eval.c", ["      ++hi;", "    while (HASHITEM_EMPTY(hi))", "      ++hi;"], "readability/braces"]
["src/nvim/eval.c", ["    while (HASHITEM_EMPTY(hi))", "      ++hi;", "    if (STRNCMP(\"g:\", xp->xp_pattern, 2) == 0)"], "readability/increment"]
["src/nvim/eval.c", ["      ++hi;", "    if (STRNCMP(\"g:\", xp->xp_pattern, 2) == 0)", "      return cat_prefix_varname('g', hi->hi_key);"], "readability/braces"]
["src/nvim/eval.c", ["  if (bdone < ht->ht_used) {", "    if (bdone++ == 0)", "      hi = ht->ht_array;"], "readability/braces"]
["src/nvim/eval.c", ["      hi = ht->ht_array;", "    else", "      ++hi;"], "readability/braces"]
["src/nvim/eval.c", ["    else", "      ++hi;", "    while (HASHITEM_EMPTY(hi))"], "readability/increment"]
["src/nvim/eval.c", ["      ++hi;", "    while (HASHITEM_EMPTY(hi))", "      ++hi;"], "readability/braces"]
["src/nvim/eval.c", ["    while (HASHITEM_EMPTY(hi))", "      ++hi;", "    return cat_prefix_varname('b', hi->hi_key);"], "readability/increment"]
["src/nvim/eval.c", ["  if (wdone < ht->ht_used) {", "    if (wdone++ == 0)", "      hi = ht->ht_array;"], "readability/braces"]
["src/nvim/eval.c", ["      hi = ht->ht_array;", "    else", "      ++hi;"], "readability/braces"]
["src/nvim/eval.c", ["    else", "      ++hi;", "    while (HASHITEM_EMPTY(hi))"], "readability/increment"]
["src/nvim/eval.c", ["      ++hi;", "    while (HASHITEM_EMPTY(hi))", "      ++hi;"], "readability/braces"]
["src/nvim/eval.c", ["    while (HASHITEM_EMPTY(hi))", "      ++hi;", "    return cat_prefix_varname('w', hi->hi_key);"], "readability/increment"]
["src/nvim/eval.c", ["  if (tdone < ht->ht_used) {", "    if (tdone++ == 0)", "      hi = ht->ht_array;"], "readability/braces"]
["src/nvim/eval.c", ["      hi = ht->ht_array;", "    else", "      ++hi;"], "readability/braces"]
["src/nvim/eval.c", ["    else", "      ++hi;", "    while (HASHITEM_EMPTY(hi))"], "readability/increment"]
["src/nvim/eval.c", ["      ++hi;", "    while (HASHITEM_EMPTY(hi))", "      ++hi;"], "readability/braces"]
["src/nvim/eval.c", ["    while (HASHITEM_EMPTY(hi))", "      ++hi;", "    return cat_prefix_varname('t', hi->hi_key);"], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * The \"evaluate\" argument: When FALSE, the argument is only parsed but not"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Handle zero level expression."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  }", "  if (nextcmd != NULL)", "    *nextcmd = check_nextcmd(p);"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Handle top level expression:"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Get the first variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["   */", "  if (eval2(arg, rettv, evaluate) == FAIL)", "    return FAIL;"], "readability/braces"]
["src/nvim/eval.c", ["  if ((*arg)[0] == '?') {", "    result = FALSE;", "    if (evaluate) {"], "readability/bool"]
["src/nvim/eval.c", ["", "    /*", "     * Get the second variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    /*", "     * Check for the \":\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    /*", "     * Get the third variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    }", "    if (evaluate && !result)", "      *rettv = var2;"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Handle first level expression:"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Get the first variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["   */", "  if (eval3(arg, rettv, evaluate) == FAIL)", "    return FAIL;"], "readability/braces"]
["src/nvim/eval.c", ["", "  /*", "   * Repeat until there is no following \"||\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["   */", "  first = TRUE;", "  result = FALSE;"], "readability/bool"]
["src/nvim/eval.c", ["  first = TRUE;", "  result = FALSE;", "  while ((*arg)[0] == '|' && (*arg)[1] == '|') {"], "readability/bool"]
["src/nvim/eval.c", ["", "    /*", "     * Get the second variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    *arg = skipwhite(*arg + 2);", "    if (eval3(arg, &var2, evaluate && !result) == FAIL)", "      return FAIL;"], "readability/braces"]
["src/nvim/eval.c", ["", "    /*", "     * Compute the result."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Handle second level expression:"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Get the first variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["   */", "  if (eval4(arg, rettv, evaluate) == FAIL)", "    return FAIL;"], "readability/braces"]
["src/nvim/eval.c", ["", "  /*", "   * Repeat until there is no following \"&&\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["   */", "  first = TRUE;", "  result = TRUE;"], "readability/bool"]
["src/nvim/eval.c", ["  first = TRUE;", "  result = TRUE;", "  while ((*arg)[0] == '&' && (*arg)[1] == '&') {"], "readability/bool"]
["src/nvim/eval.c", ["", "    /*", "     * Get the second variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    *arg = skipwhite(*arg + 2);", "    if (eval4(arg, &var2, evaluate && result) == FAIL)", "      return FAIL;"], "readability/braces"]
["src/nvim/eval.c", ["", "    /*", "     * Compute the result."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Handle third level expression:"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Get the first variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["   */", "  if (eval5(arg, rettv, evaluate) == FAIL)", "    return FAIL;"], "readability/braces"]
["src/nvim/eval.c", ["", "  /*", "   * If there is a comparative operator, use it."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Handle fourth level expression:"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Get the first variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["   */", "  if (eval6(arg, rettv, evaluate, FALSE) == FAIL)", "    return FAIL;"], "readability/braces"]
["src/nvim/eval.c", ["   */", "  if (eval6(arg, rettv, evaluate, FALSE) == FAIL)", "    return FAIL;"], "readability/bool"]
["src/nvim/eval.c", ["", "  /*", "   * Repeat computing, until no '+', '-' or '.' is following."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    op = **arg;", "    if (op != '+' && op != '-' && op != '.')", "      break;"], "readability/braces"]
["src/nvim/eval.c", ["", "    /*", "     * Get the second variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    if (evaluate) {", "      /*", "       * Compute the result."], "readability/old_style_comment"]
["src/nvim/eval.c", ["          if (error) {", "            /* This can only happen for \"list + non-list\".  For", "             * \"non-list + ...\" or \"something - ...\", we returned"], "readability/old_style_comment"]
["src/nvim/eval.c", ["          }", "          if (var2.v_type == VAR_FLOAT)", "            f1 = n1;"], "readability/braces"]
["src/nvim/eval.c", ["          }", "          if (rettv->v_type == VAR_FLOAT)", "            f2 = n2;"], "readability/braces"]
["src/nvim/eval.c", ["        if (rettv->v_type == VAR_FLOAT || var2.v_type == VAR_FLOAT) {", "          if (op == '+')", "            f1 = f1 + f2;"], "readability/braces"]
["src/nvim/eval.c", ["            f1 = f1 + f2;", "          else", "            f1 = f1 - f2;"], "readability/braces"]
["src/nvim/eval.c", ["        } else {", "          if (op == '+')", "            n1 = n1 + n2;"], "readability/braces"]
["src/nvim/eval.c", ["            n1 = n1 + n2;", "          else", "            n1 = n1 - n2;"], "readability/braces"]
["src/nvim/eval.c", ["", "  /*", "   * Get the first variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["   */", "  if (eval7(arg, rettv, evaluate, want_string) == FAIL)", "    return FAIL;"], "readability/braces"]
["src/nvim/eval.c", ["", "  /*", "   * Repeat computing, until no '*', '/' or '%' is following."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    /*", "     * Get the second variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    *arg = skipwhite(*arg + 1);", "    if (eval7(arg, &var2, evaluate, FALSE) == FAIL)", "      return FAIL;"], "readability/braces"]
["src/nvim/eval.c", ["    *arg = skipwhite(*arg + 1);", "    if (eval7(arg, &var2, evaluate, FALSE) == FAIL)", "      return FAIL;"], "readability/bool"]
["src/nvim/eval.c", ["", "      /*", "       * Compute the result."], "readability/old_style_comment"]
["src/nvim/eval.c", ["      if (*p == 'e' || *p == 'E') {", "        ++p;", "        if (*p == '-' || *p == '+') {"], "readability/increment"]
["src/nvim/eval.c", ["        if (*p == '-' || *p == '+') {", "          ++p;", "        }"], "readability/increment"]
["src/nvim/eval.c", ["", "      *arg += string2float((char *) *arg, &f);", "      if (evaluate) {"], "whitespace/cast"]
["src/nvim/eval.c", ["    if (**arg != NUL) {", "      ++*arg;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["    if (**arg == ')') {", "      ++*arg;", "    } else if (ret == OK) {"], "readability/increment"]
["src/nvim/eval.c", ["      while (end_leader > start_leader) {", "        --end_leader;", "        if (*end_leader == '!') {"], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * Evaluate an \"[expr]\" or \"[expr:expr]\" index.  Also \"dict.key\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  if (**arg == '.') {", "    /*", "     * dict.name"], "readability/old_style_comment"]
["src/nvim/eval.c", ["    key = *arg + 1;", "    for (len = 0; ASCII_ISALNUM(key[len]) || key[len] == '_'; ++len)", "      ;"], "readability/braces"]
["src/nvim/eval.c", ["    key = *arg + 1;", "    for (len = 0; ASCII_ISALNUM(key[len]) || key[len] == '_'; ++len)", "      ;"], "readability/increment"]
["src/nvim/eval.c", ["    for (len = 0; ASCII_ISALNUM(key[len]) || key[len] == '_'; ++len)", "      ;", "    if (len == 0)"], "whitespace/semicolon"]
["src/nvim/eval.c", ["      ;", "    if (len == 0)", "      return FAIL;"], "readability/braces"]
["src/nvim/eval.c", ["  } else {", "    /*", "     * something[idx]"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    /*", "     * Get the second variable from inside the [:]."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    if (**arg == ':') {", "      range = TRUE;", "      *arg = skipwhite(*arg + 1);"], "readability/bool"]
["src/nvim/eval.c", ["    }", "  } else if (working && (opt_type == -2 || opt_type == -1))", "    ret = FAIL;"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Allocate a variable for a string constant."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Find the end of the string, skipping backslashed characters."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Copy the string into allocated memory, handling backslashed"], "readability/old_style_comment"]
["src/nvim/eval.c", ["          while (--n >= 0 && ascii_isxdigit(p[1])) {", "            ++p;", "            nr = (nr << 4) + hex2nr(*p);"], "readability/increment"]
["src/nvim/eval.c", ["          }", "          ++p;", "          /* For \"\\u\" store the number according to"], "readability/increment"]
["src/nvim/eval.c", ["          ++p;", "          /* For \"\\u\" store the number according to", "           * 'encoding'. */"], "readability/old_style_comment"]
["src/nvim/eval.c", ["          *name = (*name << 3) + *p++ - '0';", "          if (*p >= '0' && *p <= '7')", "            *name = (*name << 3) + *p++ - '0';"], "readability/braces"]
["src/nvim/eval.c", ["        }", "        ++name;", "        break;"], "readability/increment"]
["src/nvim/eval.c", ["      }", "    } else", "      MB_COPY_CHAR(p, name);"], "readability/braces"]
["src/nvim/eval.c", ["      MB_COPY_CHAR(p, name);", "", "  }"], "whitespace/blank_line"]
["src/nvim/eval.c", ["", "/*", " * Allocate a variable for a 'str''ing' constant."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Find the end of the string, skipping ''."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    if (*p == '\\'') {", "      if (p[1] != '\\'')", "        break;"], "readability/braces"]
["src/nvim/eval.c", ["        break;", "      ++reduce;", "      ++p;"], "readability/increment"]
["src/nvim/eval.c", ["      ++reduce;", "      ++p;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["", "  /*", "   * Copy the string into allocated memory, handling '' to ' reduction."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    if (*p == '\\'') {", "      if (p[1] != '\\'')", "        break;"], "readability/braces"]
["src/nvim/eval.c", ["        break;", "      ++p;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["    bool ic         // ignore case", ") {", "  char_u *s1, *s2;"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Garbage collection for lists and dictionaries."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  // script-local variables", "  for (int i = 1; i <= ga_scripts.ga_len; ++i) {", "    ABORTING(set_ref_in_ht)(&SCRIPT_VARS(i), copyID, NULL);"], "readability/increment"]
["src/nvim/eval.c", ["", "  /*", "   * First check if it's not a curly-braces thing: {expr}."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    if (**arg == '}')", "      break;"], "readability/braces"]
["src/nvim/eval.c", ["  *ret_value = strtod(text, &s);", "  return (size_t) (s - text);", "}"], "whitespace/cast"]
["src/nvim/eval.c", ["", "  ++*arg;", "  name = *arg;"], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * Implementation of map() and filter()."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    save_did_emsg = did_emsg;", "    did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["      todo = (int)ht->ht_used;", "      for (hi = ht->ht_array; todo > 0; ++hi) {", "        if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval.c", ["        if (!HASHITEM_EMPTY(hi)) {", "          --todo;", ""], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * getwinvar() and gettabwinvar()"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * This function is used by f_input() and f_inputdialog() functions. The third"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * \"setwinvar()\" and \"settabwinvar()\" functions"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  set_vim_var_nr(VV_SHELL_ERROR, (long) status);", ""], "whitespace/cast"]
["src/nvim/eval.c", ["    } else {", "      rettv->vval.v_string = (char_u *) xstrdup(\"\");", "    }"], "whitespace/cast"]
["src/nvim/eval.c", ["    char *d = res;", "    for (char *s = res; *s; ++s) {", "      if (s[0] == CAR && s[1] == NL) {"], "readability/increment"]
["src/nvim/eval.c", ["      if (s[0] == CAR && s[1] == NL) {", "        ++s;", "      }"], "readability/increment"]
["src/nvim/eval.c", ["#endif", "    rettv->vval.v_string = (char_u *) res;", "  }"], "whitespace/cast"]
["src/nvim/eval.c", ["", "/*", " * Convert list in \"arg\" into a position and optional file number."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Get the length of an environment variable name."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Get the length of the name of a variable or function."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    /*", "     * Include any <SID> etc in the expanded string:"], "readability/old_style_comment"]
["src/nvim/eval.c", ["        if (*p == '\\\\' && p[1] != NUL) {", "          ++p;", "        }"], "readability/increment"]
["src/nvim/eval.c", ["      if (*p == '[') {", "        ++br_nest;", "      } else if (*p == ']') {"], "readability/increment"]
["src/nvim/eval.c", ["      } else if (*p == ']') {", "        --br_nest;", "      }"], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * Expands out the 'magic' {}'s in a variable/function name."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  if (expr_end == NULL || in_end == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/eval.c", ["", "  temp_result = eval_to_string(expr_start + 1, &nextcmd, FALSE);", "  if (temp_result != NULL && nextcmd == NULL) {"], "readability/bool"]
["src/nvim/eval.c", ["      temp_result = make_expanded_name(retval, expr_start,", "          expr_end, temp_result);", "      xfree(retval);"], "whitespace/alignment"]
["src/nvim/eval.c", ["", "/*", " * Return TRUE if character \"c\" can be used in a variable or function name."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Return TRUE if character \"c\" can be used as the first character in a"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Get number v: variable value."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Get List v: variable value.  Caller must take care of reference count when"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Set v:char to character \"c\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Set v:count to \"count\" and v:count1 to \"count1\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["{", "  if (set_prevcount)", "    vimvars[VV_PREVCOUNT].vv_nr = vimvars[VV_COUNT].vv_nr;"], "readability/braces"]
["src/nvim/eval.c", ["  } else if (len == -1) {", "    vimvars[idx].vv_str = (char_u *) xstrdup(val);", "  } else {"], "whitespace/cast"]
["src/nvim/eval.c", ["  } else {", "    vimvars[idx].vv_str = (char_u *) xstrndup(val, (size_t) len);", "  }"], "whitespace/cast"]
["src/nvim/eval.c", ["", "/*", " * Set v:register if needed."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Get or set v:exception.  If \"oldval\" == NULL, return the current value."], "readability/old_style_comment"]
["src/nvim/eval.c", ["{", "  if (oldval == NULL)", "    return vimvars[VV_EXCEPTION].vv_str;"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Get or set v:throwpoint.  If \"oldval\" == NULL, return the current value."], "readability/old_style_comment"]
["src/nvim/eval.c", ["{", "  if (oldval == NULL)", "    return vimvars[VV_THROWPOINT].vv_str;"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Set v:cmdarg."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  size_t len = 0;", "  if (eap->force_bin == FORCE_BIN)", "    len = 6;"], "readability/braces"]
["src/nvim/eval.c", ["    len = 6;", "  else if (eap->force_bin == FORCE_NOBIN)", "    len = 8;"], "readability/braces"]
["src/nvim/eval.c", ["", "  if (eap->read_edit)", "    len += 7;"], "readability/braces"]
["src/nvim/eval.c", ["", "  if (eap->force_bin == FORCE_BIN)", "    sprintf((char *)newval, \" ++bin\");"], "readability/braces"]
["src/nvim/eval.c", ["  if (eap->force_bin == FORCE_BIN)", "    sprintf((char *)newval, \" ++bin\");", "  else if (eap->force_bin == FORCE_NOBIN)"], "runtime/printf"]
["src/nvim/eval.c", ["    sprintf((char *)newval, \" ++bin\");", "  else if (eap->force_bin == FORCE_NOBIN)", "    sprintf((char *)newval, \" ++nobin\");"], "readability/braces"]
["src/nvim/eval.c", ["  else if (eap->force_bin == FORCE_NOBIN)", "    sprintf((char *)newval, \" ++nobin\");", "  else"], "runtime/printf"]
["src/nvim/eval.c", ["    sprintf((char *)newval, \" ++nobin\");", "  else", "    *newval = NUL;"], "readability/braces"]
["src/nvim/eval.c", ["", "  if (eap->read_edit)", "    STRCAT(newval, \" ++edit\");"], "readability/braces"]
["src/nvim/eval.c", ["", "      /* Stop the expression evaluation when immediately aborting on", "       * error, or when an interrupt occurred or an exception was thrown"], "readability/old_style_comment"]
["src/nvim/eval.c", ["        selfdict = rettv->vval.v_dict;", "        if (selfdict != NULL)", "          ++selfdict->dv_refcount;"], "readability/braces"]
["src/nvim/eval.c", ["        if (selfdict != NULL)", "          ++selfdict->dv_refcount;", "      } else"], "readability/increment"]
["src/nvim/eval.c", ["          ++selfdict->dv_refcount;", "      } else", "        selfdict = NULL;"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Get the string value of a (global/local) variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Allocate a new hashtab for a sourced script.  It will be used while"], "readability/old_style_comment"]
["src/nvim/eval.c", ["  {", "    /* Re-allocating ga_data means that an ht_array pointing to", "     * ht_smallarray becomes invalid.  We can recognize this: ht_mask is"], "readability/old_style_comment"]
["src/nvim/eval.c", ["     * at its init value.  Also reset \"v_dict\", it's always the same. */", "    for (int i = 1; i <= ga_scripts.ga_len; ++i) {", "      ht = &SCRIPT_VARS(i);"], "readability/increment"]
["src/nvim/eval.c", ["      ht = &SCRIPT_VARS(i);", "      if (ht->ht_mask == HT_INIT_SIZE - 1)", "        ht->ht_array = ht->ht_smallarray;"], "readability/braces"]
["src/nvim/eval.c", ["      init_var_dict(&sv->sv_dict, &sv->sv_var, VAR_SCOPE);", "      ++ga_scripts.ga_len;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * Initialize dictionary \"dict\" as a scope and set variable \"dict_var\" to"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Unreference a dictionary initialized by init_var_dict()."], "readability/old_style_comment"]
["src/nvim/eval.c", ["{", "  /* Now the dict needs to be freed if no one else is using it, go back to", "   * normal reference counting. */"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Clean up a list of internal variables."], "readability/old_style_comment"]
["src/nvim/eval.c", ["{", "  vars_clear_ext(ht, TRUE);", "}"], "readability/bool"]
["src/nvim/eval.c", ["", "/*", " * Like vars_clear(), but only free the value if \"free_val\" is TRUE."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  todo = (int)ht->ht_used;", "  for (hi = ht->ht_array; todo > 0; ++hi) {", "    if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval.c", ["    if (!HASHITEM_EMPTY(hi)) {", "      --todo;", ""], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * Delete a variable from hashtab \"ht\" at item \"hi\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * List the value of one internal variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    msg_putchar('[');", "    if (*string == '[')", "      ++string;"], "readability/braces"]
["src/nvim/eval.c", ["    if (*string == '[')", "      ++string;", "  } else if (type == VAR_DICT) {"], "readability/increment"]
["src/nvim/eval.c", ["    msg_putchar('{');", "    if (*string == '{')", "      ++string;"], "readability/braces"]
["src/nvim/eval.c", ["    if (*string == '{')", "      ++string;", "  } else"], "readability/increment"]
["src/nvim/eval.c", ["      ++string;", "  } else", "    msg_putchar(' ');"], "readability/braces"]
["src/nvim/eval.c", ["    msg_clr_eos();", "    *first = FALSE;", "  }"], "readability/bool"]
["src/nvim/eval.c", ["      && !ASCII_ISUPPER((name[0] != NUL && name[1] == ':') ? name[2]", "                                                           : name[0])) {", "    EMSG2(_(\"E704: Funcref variable name must start with a capital: %s\"), name);"], "whitespace/alignment"]
["src/nvim/eval.c", ["      && !ASCII_ISUPPER((name[0] != NUL && name[1] == ':') ? name[2]", "                                                           : name[0])) {", "    EMSG2(_(\"E704: Funcref variable name must start with a capital: %s\"), name);"], "whitespace/alignment"]
["src/nvim/eval.c", ["  }", "  ++recurse;", ""], "readability/increment"]
["src/nvim/eval.c", ["          == NULL) {", "        to->vval.v_string = (char_u *) xstrdup((char *) from->vval.v_string);", "      }"], "whitespace/cast"]
["src/nvim/eval.c", ["      to->vval.v_dict = from->vval.v_dict->dv_copydict;", "      ++to->vval.v_dict->dv_refcount;", "    } else {"], "readability/increment"]
["src/nvim/eval.c", ["  }", "  --recurse;", "  return ret;"], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * \":echo expr1 ...\"\tprint each argument separated with a space, add a"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  if (eap->skip)", "    ++emsg_skip;"], "readability/braces"]
["src/nvim/eval.c", ["  if (eap->skip)", "    ++emsg_skip;", "  while (*arg != NUL && *arg != '|' && *arg != '\\n' && !got_int) {"], "readability/increment"]
["src/nvim/eval.c", ["        atstart = false;", "        /* Call msg_start() after eval1(), evaluating the expression", "         * may cause a message to appear. */"], "readability/old_style_comment"]
["src/nvim/eval.c", ["        if (eap->cmdidx == CMD_echo) {", "          /* Mark the saved text as finishing the line, so that what", "           * follows is displayed on a new line when scrolling back"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * \":echohl {name}\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * \":execute expr1 ...\"\texecute the result of an expression."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  if (eap->skip)", "    ++emsg_skip;"], "readability/braces"]
["src/nvim/eval.c", ["  if (eap->skip)", "    ++emsg_skip;", "  while (*arg != NUL && *arg != '|' && *arg != '\\n') {"], "readability/increment"]
["src/nvim/eval.c", ["      EMSG((char_u *)ga.ga_data);", "      if (!force_abort)", "        did_emsg = save_did_emsg;"], "readability/braces"]
["src/nvim/eval.c", ["        did_emsg = save_did_emsg;", "    } else if (eap->cmdidx == CMD_execute)", "      do_cmdline((char_u *)ga.ga_data,"], "readability/braces"]
["src/nvim/eval.c", ["      do_cmdline((char_u *)ga.ga_data,", "          eap->getline, eap->cookie, DOCMD_NOWAIT|DOCMD_VERBOSE);", "  }"], "whitespace/alignment"]
["src/nvim/eval.c", ["", "  if (eap->skip)", "    --emsg_skip;"], "readability/braces"]
["src/nvim/eval.c", ["  if (eap->skip)", "    --emsg_skip;", ""], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * Skip over the name of an option: \"&option\", \"&g:option\" or \"&l:option\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  ++p;", "  if (*p == 'g' && p[1] == ':') {"], "readability/increment"]
["src/nvim/eval.c", ["", "  fp->uf_profiling = TRUE;", "}"], "readability/bool"]
["src/nvim/eval.c", ["", "/*", " * Dump the profiling results for all functions in file \"fd\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  for (hi = func_hashtab.ht_array; todo > 0; ++hi) {", "    if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval.c", ["    if (!HASHITEM_EMPTY(hi)) {", "      --todo;", "      fp = HI2UF(hi);"], "readability/increment"]
["src/nvim/eval.c", ["", "        for (int i = 0; i < fp->uf_lines.ga_len; ++i) {", "          if (FUNCLINE(fp, i) == NULL)"], "readability/increment"]
["src/nvim/eval.c", ["        for (int i = 0; i < fp->uf_lines.ga_len; ++i) {", "          if (FUNCLINE(fp, i) == NULL)", "            continue;"], "readability/braces"]
["src/nvim/eval.c", ["          prof_func_line(fd, fp->uf_tml_count[i],", "              &fp->uf_tml_total[i], &fp->uf_tml_self[i], TRUE);", "          fprintf(fd, \"%s\\n\", FUNCLINE(fp, i));"], "whitespace/alignment"]
["src/nvim/eval.c", ["          prof_func_line(fd, fp->uf_tml_count[i],", "              &fp->uf_tml_total[i], &fp->uf_tml_self[i], TRUE);", "          fprintf(fd, \"%s\\n\", FUNCLINE(fp, i));"], "readability/bool"]
["src/nvim/eval.c", ["    qsort((void *)sorttab, (size_t)st_len, sizeof(ufunc_T *),", "        prof_total_cmp);", "    prof_sort_list(fd, sorttab, st_len, \"TOTAL\", FALSE);"], "whitespace/alignment"]
["src/nvim/eval.c", ["        prof_total_cmp);", "    prof_sort_list(fd, sorttab, st_len, \"TOTAL\", FALSE);", "    qsort((void *)sorttab, (size_t)st_len, sizeof(ufunc_T *),"], "readability/bool"]
["src/nvim/eval.c", ["    qsort((void *)sorttab, (size_t)st_len, sizeof(ufunc_T *),", "        prof_self_cmp);", "    prof_sort_list(fd, sorttab, st_len, \"SELF\", TRUE);"], "whitespace/alignment"]
["src/nvim/eval.c", ["        prof_self_cmp);", "    prof_sort_list(fd, sorttab, st_len, \"SELF\", TRUE);", "  }"], "readability/bool"]
["src/nvim/eval.c", ["  fprintf(fd, \"count  total (s)   self (s)  function\\n\");", "  for (i = 0; i < 20 && i < st_len; ++i) {", "    fp = sorttab[i];"], "readability/increment"]
["src/nvim/eval.c", ["    prof_func_line(fd, fp->uf_tm_count, &fp->uf_tm_total, &fp->uf_tm_self,", "        prefer_self);", "    if (fp->uf_name[0] == K_SPECIAL)"], "whitespace/alignment"]
["src/nvim/eval.c", ["        prefer_self);", "    if (fp->uf_name[0] == K_SPECIAL)", "      fprintf(fd, \" <SNR>%s()\\n\", fp->uf_name + 3);"], "readability/braces"]
["src/nvim/eval.c", ["      fprintf(fd, \" <SNR>%s()\\n\", fp->uf_name + 3);", "    else", "      fprintf(fd, \" %s()\\n\", fp->uf_name);"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Print the count and times for one function or function line."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    fprintf(fd, \"%5d \", count);", "    if (prefer_self && profile_equal(*total, *self))", "      fprintf(fd, \"           \");"], "readability/braces"]
["src/nvim/eval.c", ["      fprintf(fd, \"           \");", "    else", "      fprintf(fd, \"%s \", profile_msg(*total));"], "readability/braces"]
["src/nvim/eval.c", ["      fprintf(fd, \"%s \", profile_msg(*total));", "    if (!prefer_self && profile_equal(*total, *self))", "      fprintf(fd, \"           \");"], "readability/braces"]
["src/nvim/eval.c", ["      fprintf(fd, \"           \");", "    else", "      fprintf(fd, \"%s \", profile_msg(*self));"], "readability/braces"]
["src/nvim/eval.c", ["      fprintf(fd, \"%s \", profile_msg(*self));", "  } else", "    fprintf(fd, \"                            \");"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Compare function for total time sorting."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Compare function for self time sorting."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Called when starting to read a function line."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Called when actually executing a function line."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  if (fp->uf_profiling && fp->uf_tml_idx >= 0)", "    fp->uf_tml_execed = TRUE;"], "readability/braces"]
["src/nvim/eval.c", ["  if (fp->uf_profiling && fp->uf_tml_idx >= 0)", "    fp->uf_tml_execed = TRUE;", "}"], "readability/bool"]
["src/nvim/eval.c", ["", "/*", " * Called when done with a function line."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    if (fp->uf_tml_execed) {", "      ++fp->uf_tml_count[fp->uf_tml_idx];", "      fp->uf_tml_start = profile_end(fp->uf_tml_start);"], "readability/increment"]
["src/nvim/eval.c", ["        profile_self(fp->uf_tml_self[fp->uf_tml_idx], fp->uf_tml_start,", "          fp->uf_tml_children);", "    }"], "whitespace/alignment"]
["src/nvim/eval.c", ["  if (ASCII_ISUPPER(*p)) {", "    while (*(++p))", "      if (ASCII_ISLOWER(*p)) {"], "readability/braces"]
["src/nvim/eval.c", ["  const hashitem_T *hifirst = globvarht.ht_array;", "  const size_t hinum = (size_t) globvarht.ht_mask + 1;", "  *name = NULL;"], "whitespace/cast"]
["src/nvim/eval.c", ["    hi = globvarht.ht_array;", "    while ((size_t) (hi - hifirst) < hinum", "           && (HASHITEM_EMPTY(hi)"], "whitespace/cast"]
["src/nvim/eval.c", ["    }", "    if ((size_t) (hi - hifirst) == hinum) {", "      return NULL;"], "whitespace/cast"]
["src/nvim/eval.c", ["  } else {", "    hi = (const hashitem_T *) iter;", "  }"], "whitespace/cast"]
["src/nvim/eval.c", ["", "/*", " * Display script name where an item was last set."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Adjust a filename, according to a string of modifiers."], "readability/old_style_comment"]
["src/nvim/eval.c", ["      *bufp = *fnamep;", "      if (*fnamep == NULL)", "        return -1;"], "readability/braces"]
["src/nvim/eval.c", ["      *bufp = *fnamep;", "      if (*fnamep == NULL)", "        return -1;"], "readability/braces"]
["src/nvim/eval.c", ["      *bufp = *fnamep;", "      if (*fnamep == NULL)", "        return -1;"], "readability/braces"]
["src/nvim/eval.c", ["        return -1;", "      add_pathsep((char *)*fnamep);", "    }"], "whitespace/operators"]
["src/nvim/eval.c", ["    if (!has_fullname) {", "      if (c == '.' && **fnamep == '~')", "        p = pbuf = expand_env_save(*fnamep);"], "readability/braces"]
["src/nvim/eval.c", ["        p = pbuf = expand_env_save(*fnamep);", "      else", "        p = pbuf = (char_u *)FullName_save((char *)*fnamep, FALSE);"], "readability/braces"]
["src/nvim/eval.c", ["      else", "        p = pbuf = (char_u *)FullName_save((char *)*fnamep, FALSE);", "    } else"], "whitespace/operators"]
["src/nvim/eval.c", ["      else", "        p = pbuf = (char_u *)FullName_save((char *)*fnamep, FALSE);", "    } else"], "readability/bool"]
["src/nvim/eval.c", ["        p = pbuf = (char_u *)FullName_save((char *)*fnamep, FALSE);", "    } else", "      p = *fnamep;"], "readability/braces"]
["src/nvim/eval.c", ["         && (src[*usedlen + 1] == 'e' || src[*usedlen + 1] == 'r')) {", "    /* find a '.' in the tail:", "     * - for second :e: before the current fname"], "readability/old_style_comment"]
["src/nvim/eval.c", ["    char_u      *flags;", "    int didit = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["      flags = (char_u *)\"g\";", "      ++s;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["          *bufp = s;", "          didit = TRUE;", "          xfree(sub);"], "readability/bool"]
["src/nvim/eval.c", ["      ga_grow(&ga, (int)((end - tail) + sublen -", "                     (regmatch.endp[0] - regmatch.startp[0])));", ""], "whitespace/alignment"]
["src/nvim/eval.c", ["      tail = regmatch.endp[0];", "      if (*tail == NUL)", "        break;"], "readability/braces"]
["src/nvim/eval.c", ["        break;", "      if (!do_all)", "        break;"], "readability/braces"]
["src/nvim/eval.c", ["", "    if (ga.ga_data != NULL)", "      STRCPY((char *)ga.ga_data + ga.ga_len, tail);"], "readability/braces"]
