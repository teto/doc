["src/nvim/os/input.c", ["    // copy the character, escaping CSI and K_SPECIAL", "    if ((uint8_t)*ptr == CSI) {", "      rbuffer_write(input_buffer, (char *)&(uint8_t){K_SPECIAL}, 1);"], "whitespace/operators"]
["src/nvim/os/input.c", ["    if ((uint8_t)*ptr == CSI) {", "      rbuffer_write(input_buffer, (char *)&(uint8_t){K_SPECIAL}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KS_EXTRA}, 1);"], "whitespace/braces"]
["src/nvim/os/input.c", ["    if ((uint8_t)*ptr == CSI) {", "      rbuffer_write(input_buffer, (char *)&(uint8_t){K_SPECIAL}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KS_EXTRA}, 1);"], "whitespace/braces"]
["src/nvim/os/input.c", ["      rbuffer_write(input_buffer, (char *)&(uint8_t){K_SPECIAL}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KS_EXTRA}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KE_CSI}, 1);"], "whitespace/braces"]
["src/nvim/os/input.c", ["      rbuffer_write(input_buffer, (char *)&(uint8_t){K_SPECIAL}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KS_EXTRA}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KE_CSI}, 1);"], "whitespace/braces"]
["src/nvim/os/input.c", ["      rbuffer_write(input_buffer, (char *)&(uint8_t){KS_EXTRA}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KE_CSI}, 1);", "    } else if ((uint8_t)*ptr == K_SPECIAL) {"], "whitespace/braces"]
["src/nvim/os/input.c", ["      rbuffer_write(input_buffer, (char *)&(uint8_t){KS_EXTRA}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KE_CSI}, 1);", "    } else if ((uint8_t)*ptr == K_SPECIAL) {"], "whitespace/braces"]
["src/nvim/os/input.c", ["      rbuffer_write(input_buffer, (char *)&(uint8_t){KE_CSI}, 1);", "    } else if ((uint8_t)*ptr == K_SPECIAL) {", "      rbuffer_write(input_buffer, (char *)&(uint8_t){K_SPECIAL}, 1);"], "whitespace/operators"]
["src/nvim/os/input.c", ["    } else if ((uint8_t)*ptr == K_SPECIAL) {", "      rbuffer_write(input_buffer, (char *)&(uint8_t){K_SPECIAL}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KS_SPECIAL}, 1);"], "whitespace/braces"]
["src/nvim/os/input.c", ["    } else if ((uint8_t)*ptr == K_SPECIAL) {", "      rbuffer_write(input_buffer, (char *)&(uint8_t){K_SPECIAL}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KS_SPECIAL}, 1);"], "whitespace/braces"]
["src/nvim/os/input.c", ["      rbuffer_write(input_buffer, (char *)&(uint8_t){K_SPECIAL}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KS_SPECIAL}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KE_FILLER}, 1);"], "whitespace/braces"]
["src/nvim/os/input.c", ["      rbuffer_write(input_buffer, (char *)&(uint8_t){K_SPECIAL}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KS_SPECIAL}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KE_FILLER}, 1);"], "whitespace/braces"]
["src/nvim/os/input.c", ["      rbuffer_write(input_buffer, (char *)&(uint8_t){KS_SPECIAL}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KE_FILLER}, 1);", "    } else {"], "whitespace/braces"]
["src/nvim/os/input.c", ["      rbuffer_write(input_buffer, (char *)&(uint8_t){KS_SPECIAL}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KE_FILLER}, 1);", "    } else {"], "whitespace/braces"]
["src/nvim/os/input.c", ["      || !((mouse_code >= KE_LEFTMOUSE && mouse_code <= KE_RIGHTRELEASE)", "        || (mouse_code >= KE_MOUSEDOWN && mouse_code <= KE_MOUSERIGHT))) {", "    return bufsize;"], "whitespace/alignment"]
["src/nvim/os/input.c", ["      || !((mouse_code >= KE_LEFTMOUSE && mouse_code <= KE_RIGHTRELEASE)", "        || (mouse_code >= KE_MOUSEDOWN && mouse_code <= KE_MOUSERIGHT))) {", "    return bufsize;"], "whitespace/alignment"]
