["src/nvim/eval/decode.c", ["      // vval.v_list and vval.v_dict should have the same size and offset", "      && ((void *) obj.val.vval.v_list", "          == (void *) last_container.container.vval.v_list)) {"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["      && ((void *) obj.val.vval.v_list", "          == (void *) last_container.container.vval.v_list)) {", "    (void) kv_pop(*container_stack);"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["          == (void *) last_container.container.vval.v_list)) {", "    (void) kv_pop(*container_stack);", "    val_location = last_container.s;"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["      // Restart", "      (void) kv_pop(*container_stack);", "      ValuesStackItem last_container_val ="], "whitespace/cast"]
["src/nvim/eval/decode.c", ["#define LENP(p, e) \\", "    ((int) ((e) - (p))), (p)", "#define OBJ(obj_tv, is_sp_string, didcomma_, didcolon_) \\"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["        emsgf(_(\"E474: Unfinished escape sequence: %.*s\"),", "              (int) buf_len, buf);", "        goto parse_json_string_fail;"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["            emsgf(_(\"E474: Unfinished unicode escape sequence: %.*s\"),", "                  (int) buf_len, buf);", "            goto parse_json_string_fail;"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["    } else {", "      uint8_t p_byte = (uint8_t) *p;", "      // unescaped = %x20-21 / %x23-5B / %x5D-10FFFF"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["      }", "      const int ch = utf_ptr2char((char_u *) p);", "      // All characters above U+007F are encoded using two or more bytes"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["      if (ch >= 0x80 && p_byte == ch", "          && !(ch == 0xC3 && p + 1 < e && (uint8_t) p[1] == 0x83)) {", "        emsgf(_(\"E474: Only UTF-8 strings allowed: %.*s\"), LENP(p, e));"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["      }", "      const size_t ch_len = (size_t) utf_char2len(ch);", "      assert(ch_len == (size_t) (ch ? utf_ptr2len((char_u *) p) : 1));"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["      const size_t ch_len = (size_t) utf_char2len(ch);", "      assert(ch_len == (size_t) (ch ? utf_ptr2len((char_u *) p) : 1));", "      len += ch_len;"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["  if (p == e || *p != '\"') {", "    emsgf(_(\"E474: Expected string end: %.*s\"), (int) buf_len, buf);", "    goto parse_json_string_fail;"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["    if (fst_in_pair != 0) { \\", "      str_end += utf_char2bytes(fst_in_pair, (char_u *) str_end); \\", "      fst_in_pair = 0; \\"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["            PUT_FST_IN_PAIR(fst_in_pair, str_end);", "            fst_in_pair = (int) ch;", "          } else if (SURROGATE_LO_START <= ch && ch <= SURROGATE_LO_END"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["            const int full_char = (", "                (int) (ch - SURROGATE_LO_START)", "                + ((fst_in_pair - SURROGATE_HI_START) << 10)"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["                + SURROGATE_FIRST_CHAR);", "            str_end += utf_char2bytes(full_char, (char_u *) str_end);", "            fst_in_pair = 0;"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["            PUT_FST_IN_PAIR(fst_in_pair, str_end);", "            str_end += utf_char2bytes((int) ch, (char_u *) str_end);", "          }"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["          };", "          *str_end++ = escapes[(int) *t];", "          break;"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["  };", "  const size_t exp_num_len = (size_t) (p - s);", "  if (fracs || exps) {"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["              \"to float string2float consumed %zu bytes in place of %zu\"),", "            (int) exp_num_len, s, num_len, exp_num_len);", "    }"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["    int num_len;", "    vim_str2nr((char_u *) s, NULL, &num_len, 0, &nr, NULL, (int) (p - s));", "    if ((int) exp_num_len != num_len) {"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["    vim_str2nr((char_u *) s, NULL, &num_len, 0, &nr, NULL, (int) (p - s));", "    if ((int) exp_num_len != num_len) {", "      emsgf(_(\"E685: internal error: while converting number \\\"%.*s\\\" \""], "whitespace/cast"]
["src/nvim/eval/decode.c", ["              \"to integer vim_str2nr consumed %i bytes in place of %zu\"),", "            (int) exp_num_len, s, num_len, exp_num_len);", "    }"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["          p++;", "          (void) kv_pop(container_stack);", "          goto json_decode_string_after_cycle;"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["  }", "  emsgf(_(\"E474: Unexpected end of input: %.*s\"), (int) buf_len, buf);", "json_decode_string_fail:"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["          .v_lock = VAR_UNLOCKED,", "          .vval = { .v_number = (varnumber_T) mobj.via.u64 },", "        };"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["          .v_lock = VAR_UNLOCKED,", "          .vval = { .v_number = (varnumber_T) mobj.via.i64 },", "        };"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["      }));", "      if (encode_list_write((void *) ext_val_list, mobj.via.ext.ptr,", "                            mobj.via.ext.size) == -1) {"], "whitespace/cast"]
