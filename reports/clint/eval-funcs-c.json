["src/nvim/eval/funcs.c", ["", "  if (idx == 0)", "    intidx = -1;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "  if (idx == 0)", "    intidx = -1;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["    name = get_function_name(xp, idx);", "    if (name != NULL)", "      return name;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * Return TRUE for a non-zero Number and a non-empty String."], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"abs(expr)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"add(list, item)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"and(expr, expr)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"argidx()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"argv(nr)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"atan2()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"browse(save, title, initdir, default)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"browsedir(title, initdir)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * Find a buffer by number or exact name."], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "  if (avar->v_type == VAR_NUMBER)", "    buf = buflist_findnr((int)avar->vval.v_number);"], "readability/braces"]
["src/nvim/eval/funcs.c", ["    buf = buflist_findnr((int)avar->vval.v_number);", "  else if (avar->v_type == VAR_STRING && avar->vval.v_string != NULL) {", "    buf = buflist_findname_exp(avar->vval.v_string);"], "readability/braces"]
["src/nvim/eval/funcs.c", ["    if (buf == NULL) {", "      /* No full path name match, try a match with a URL or a \"nofile\"", "       * buffer, these don't use the full path. */"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"bufexists(expr)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"buflisted(expr)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"bufloaded(expr)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"bufname(expr)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"bufnr(expr)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["/// \"bufwinid(nr)\" function", "static void f_bufwinid(typval_T *argvars, typval_T *rettv, FunPtr fptr) {", "  buf_win_common(argvars, rettv, false);"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * Get buffer by number or pattern."], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "  if (tv->v_type == VAR_NUMBER)", "    return buflist_findnr((int)tv->vval.v_number);"], "readability/braces"]
["src/nvim/eval/funcs.c", ["    return buflist_findnr((int)tv->vval.v_number);", "  if (tv->v_type != VAR_STRING)", "    return NULL;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["    return NULL;", "  if (name == NULL || *name == NUL)", "    return curbuf;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["    return curbuf;", "  if (name[0] == '$' && name[1] == NUL)", "    return lastbuf;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["  save_magic = p_magic;", "  p_magic = TRUE;", "  save_cpo = p_cpo;"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"byte2line(byte)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"byteidx()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  byteidx(argvars, rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"byteidxcomp()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  byteidx(argvars, rettv, TRUE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"changenr()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["  if (argvars[0].v_type != VAR_NUMBER || (argvars[1].v_type != VAR_STRING", "        && argvars[1].v_type != VAR_UNKNOWN)) {", "    EMSG(_(e_invarg));"], "whitespace/alignment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"char2nr(string)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"cindent(lnum)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["    curwin->w_cursor = pos;", "  } else", "    rettv->vval.v_number = -1;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"clearmatches()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"col(string)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "  fp = var2fpos(&argvars[0], FALSE, &fnum);", "  if (fp != NULL && fnum == curbuf->b_fnum) {"], "readability/bool"]
["src/nvim/eval/funcs.c", ["        if (curwin->w_cursor.coladd >= (colnr_T)chartabsize(p,", "                curwin->w_virtcol - curwin->w_cursor.coladd)) {", "          int l;"], "whitespace/alignment"]
["src/nvim/eval/funcs.c", ["", "          if (*p != NUL && p[(l = (*mb_ptr2len)(p))] == NUL)", "            col += l;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"complete()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "  /* Check for undo allowed here, because if something was already inserted", "   * the line was already saved for undo and this check isn't done. */"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["   * the line was already saved for undo and this check isn't done. */", "  if (!undo_allowed())", "    return;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"complete_add()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"complete_check()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"confirm(message, buttons[, default [, type]])\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"copy()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"count()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["        }", "        if (error)", "          li = NULL;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["      todo = error ? 0 : (int)d->dv_hashtab.ht_used;", "      for (hi = d->dv_hashtab.ht_array; todo > 0; ++hi) {", "        if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"cscope_connection([{num} , {dbpath} [, {prepend}]])\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"did_filetype()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"diff_filler()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"diff_hlID()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"empty({expr})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"escape({string}, {chars})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"eval()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["    }", "    need_clr_eos = FALSE;", "    rettv->v_type = VAR_NUMBER;"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"eventhandler()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"executable()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"exists()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"expand()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"extend(list, list [, idx])\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"feedkeys()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * Return 0 for not writable, 1 for writable file, 2 for a dir which we have"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["    do {", "      if (rettv->v_type == VAR_STRING || rettv->v_type == VAR_LIST)", "        xfree(fresult);"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "  if (rettv->v_type == VAR_STRING)", "    rettv->vval.v_string = fresult;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"filter()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  filter_map(argvars, rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"finddir({fname}[, {path}[, {count}]])\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"findfile({fname}[, {path}[, {count}]])\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"float2nr({float})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"fmod()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"fnameescape({string})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"fnamemodify({fname}, {mods})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"foldclosed()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"foldclosed()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  foldclosed_both(argvars, rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"foldclosedend()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  foldclosed_both(argvars, rettv, TRUE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"foldlevel()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"foldtext()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["        s = skipwhite(ml_get(lnum + 1));", "        if (*s == '*')", "          s = skipwhite(s + 1);"], "readability/braces"]
["src/nvim/eval/funcs.c", ["                + STRLEN(s));     // concatenated", "    sprintf((char *)r, txt, dashes, count);", "    len = (int)STRLEN(r);"], "runtime/printf"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"foldtextresult(lnum)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"foreground()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"get()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * Get line or list of lines from buffer \"buf\" into \"rettv\"."], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getbufline()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getbufvar()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getchar()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["      if (row >= 0 && col >= 0) {", "        /* Find the window at the mouse coordinates and compute the", "         * text position. */"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["        (void)mouse_comp_pos(win, &row, &col, &lnum);", "        for (wp = firstwin; wp != win; wp = wp->w_next)", "          ++winnr;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["        for (wp = firstwin; wp != win; wp = wp->w_next)", "          ++winnr;", "        set_vim_var_nr(VV_MOUSE_WIN, winnr);"], "readability/increment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getcharmod()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getcharsearch()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getcmdline()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getcmdpos()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getcmdtype()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getcmdwintype()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getfontname()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getfperm({fname})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getfsize({fname})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getftime({fname})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getftype({fname})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getline(lnum, [end])\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getmatches()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getpid()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getcurpos(string)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getpos(string)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getregtype()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"gettabvar()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"gettabwinvar()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getwinposx()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getwinposy()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"glob()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "  /* When the optional second argument is non-zero, don't remove matches", "  * for 'wildignore' and don't put matches for 'suffixes' at the end. */"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["    xpc.xp_context = EXPAND_FILES;", "    if (p_wic)", "      options += WILD_ICASE;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["    }", "  } else", "    rettv->vval.v_string = NULL;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"has_key()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["  }", "  if (argvars[0].vval.v_dict == NULL)", "    return;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"hasmapto()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"histadd()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"histdel()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"histget()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"histnr()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"highlightID(name)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"highlight_exists()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"hostname()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * iconv() function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"indent()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"index()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"input()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  get_user_input(argvars, rettv, FALSE, inputsecret_flag);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"inputdialog()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  get_user_input(argvars, rettv, TRUE, inputsecret_flag);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"inputlist()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"insert()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"invert(expr)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"isdirectory()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"islocked()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"items(dict)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["  if (argvars[0].v_type != VAR_LIST || (argvars[1].v_type != VAR_NUMBER", "        && argvars[1].v_type != VAR_UNKNOWN)) {", "    EMSG(_(e_invarg));"], "whitespace/alignment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"join()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"keys()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"last_buffer_nr()\" function."], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"len()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"libcall()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"libcallnr()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"line(string)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "  fp = var2fpos(&argvars[0], TRUE, &fnum);", "  if (fp != NULL)"], "readability/bool"]
["src/nvim/eval/funcs.c", ["  fp = var2fpos(&argvars[0], TRUE, &fnum);", "  if (fp != NULL)", "    lnum = fp->lnum;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"line2byte(lnum)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"lispindent(lnum)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"localtime()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["  int mode;", "  int abbr = FALSE;", "  int get_dict = FALSE;"], "readability/bool"]
["src/nvim/eval/funcs.c", ["  int abbr = FALSE;", "  int get_dict = FALSE;", "  mapblock_T  *mp;"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"map()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  filter_map(argvars, rettv, TRUE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"maparg()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  get_maparg(argvars, rettv, TRUE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"mapcheck()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  get_maparg(argvars, rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["    } else {", "      if (start < 0)", "        start = 0;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["        start = 0;", "      if (start > len)", "        goto theend;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "      if (match && --nth <= 0)", "        break;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["        break;", "      if (l == NULL && !match)", "        break;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"match()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"matchadd()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"matcharg()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"matchdelete()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"matchend()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"matchlist()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"matchstr()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"max()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  max_min(argvars, rettv, TRUE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"min()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  max_min(argvars, rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"mkdir()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"nextnonblank()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"nr2char()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"or(expr, expr)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"pathshorten()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"pow()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"prevnonblank()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"printf()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"pumvisible()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  if (pum_visible())", "    rettv->vval.v_number = 1;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"pyeval()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"py3eval()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"range()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"readfile()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["        } else {", "          /* Change \"prev\" buffer to be the right size.  This way", "           * the bytes are only copied once, and very long lines are"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["            }", "            if (readlen > p - buf + 1)", "              memmove(dest, p + 1, readlen - (p - buf) - 1);"], "readability/braces"]
["src/nvim/eval/funcs.c", ["      if (p - start + prevlen >= prevsize) {", "        /* A common use case is ordinary text files and \"prev\" gets a", "         * fragment of a line, so the first allocation is made"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["         * 'reallocing' small. */", "        if (prevsize == 0)", "          prevsize = (long)(p - start);"], "readability/braces"]
["src/nvim/eval/funcs.c", ["          prevsize = (long)(p - start);", "        else {", "          long grow50pc = (prevsize * 3) / 2;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["          prevsize = (long)(p - start);", "        else {", "          long grow50pc = (prevsize * 3) / 2;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["  union {", "    struct { int32_t low, high; } split;", "    proftime_T prof;"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["  union {", "    struct { int32_t low, high; } split;", "    proftime_T prof;"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["  STATIC_ASSERT(sizeof(u.prof) == sizeof(u) && sizeof(u.split) == sizeof(u),", "      \"type punning will produce incorrect results on this platform\");", ""], "whitespace/alignment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"remove()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"rename({from}, {to})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"repeat()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"resolve()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"reverse({list})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * Get flags for a search function."], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "  /*", "   * This function does not accept SP_REPEAT and SP_RETCOUNT flags."], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["  if (subpatnum != FAIL) {", "    if (flags & SP_SUBPAT)", "      retval = subpatnum;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["      retval = subpatnum;", "    else", "      retval = pos.lnum;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["      retval = pos.lnum;", "    if (flags & SP_SETPCMARK)", "      setpcmark();"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"screenattr()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"screenchar()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"screencol()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"screenrow()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"search()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"searchdecl()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * Used by searchpair() and searchpairpos()"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"searchpair()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"searchpairpos()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * Search for a start/middle/end thing."], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "    if (firstpos.lnum == 0)", "      firstpos = pos;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["      }", "      if (r)", "        continue;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["      curwin->w_cursor = pos;", "      if (!(flags & SP_REPEAT))", "        break;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"searchpos()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"setbufvar()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"setcmdpos()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"setline()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"setloclist()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"setmatches()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"setpos()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"setqflist()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"setreg()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"settabvar()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"settabwinvar()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"setwinvar()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"shellescape({string})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * shiftwidth() function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"simplify()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * Compare functions for f_sort() and f_uniq() below."], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"sort({list})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"soundfold({word})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"spellbadword()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"spellsuggest()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"str2float()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"strftime({format}[, {time}])\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"stridx()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"string()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"strlen()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"strchars()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"strdisplaywidth()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"strwidth()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"strpart()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"strridx()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"strtrans()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"submatch()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"substitute()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"synIDattr(id, what [, mode])\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"synIDtrans(id)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"synconcealed(lnum, col)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"synstack(lnum, col)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"tabpagebuflist()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"tabpagenr()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * Common code for tabpagewinnr() and winnr()."], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "  if (nr > 0)", "    for (wp = (tp == curtab) ? firstwin : tp->tp_firstwin;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["      }", "      ++nr;", "    }"], "readability/increment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"tabpagewinnr()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"tagfiles()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"taglist()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"tempname()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"tolower(string)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"toupper(string)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"tr(string, fromstr, tostr)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"type(expr)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"undofile(name)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"undotree()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"values(dict)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"virtcol(string)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "  fp = var2fpos(&argvars[0], FALSE, &fnum);", "  if (fp != NULL && fp->lnum <= curbuf->b_ml.ml_line_count"], "readability/bool"]
["src/nvim/eval/funcs.c", ["    getvvcol(curwin, fp, NULL, NULL, &vcol);", "    ++vcol;", "  }"], "readability/increment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"visualmode()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"wildmenumode()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"wincol()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"winline()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"winnr()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"winrestcmd()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"winrestview()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "    if (curwin->w_topline <= 0)", "      curwin->w_topline = 1;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["      curwin->w_topline = 1;", "    if (curwin->w_topline > curbuf->b_ml.ml_line_count)", "      curwin->w_topline = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"winsaveview()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["}", "/*", " * \"xor(expr, expr)\" function"], "readability/old_style_comment"]
