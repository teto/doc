["src/nvim/mbyte.c", ["", "/*", " * Canonical encoding names and their properties."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["static struct", "{   const char *name;   int prop;              int codepage; }", "enc_canon_table[] ="], "whitespace/newline"]
["src/nvim/mbyte.c", ["#define IDX_LATIN_1     0", "  {\"latin1\",          ENC_8BIT + ENC_LATIN1,  1252},", "#define IDX_ISO_2       1"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_LATIN_1     0", "  {\"latin1\",          ENC_8BIT + ENC_LATIN1,  1252},", "#define IDX_ISO_2       1"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_2       1", "  {\"iso-8859-2\",      ENC_8BIT,               0},", "#define IDX_ISO_3       2"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_2       1", "  {\"iso-8859-2\",      ENC_8BIT,               0},", "#define IDX_ISO_3       2"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_3       2", "  {\"iso-8859-3\",      ENC_8BIT,               0},", "#define IDX_ISO_4       3"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_3       2", "  {\"iso-8859-3\",      ENC_8BIT,               0},", "#define IDX_ISO_4       3"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_4       3", "  {\"iso-8859-4\",      ENC_8BIT,               0},", "#define IDX_ISO_5       4"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_4       3", "  {\"iso-8859-4\",      ENC_8BIT,               0},", "#define IDX_ISO_5       4"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_5       4", "  {\"iso-8859-5\",      ENC_8BIT,               0},", "#define IDX_ISO_6       5"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_5       4", "  {\"iso-8859-5\",      ENC_8BIT,               0},", "#define IDX_ISO_6       5"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_6       5", "  {\"iso-8859-6\",      ENC_8BIT,               0},", "#define IDX_ISO_7       6"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_6       5", "  {\"iso-8859-6\",      ENC_8BIT,               0},", "#define IDX_ISO_7       6"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_7       6", "  {\"iso-8859-7\",      ENC_8BIT,               0},", "#define IDX_ISO_8       7"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_7       6", "  {\"iso-8859-7\",      ENC_8BIT,               0},", "#define IDX_ISO_8       7"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_8       7", "  {\"iso-8859-8\",      ENC_8BIT,               0},", "#define IDX_ISO_9       8"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_8       7", "  {\"iso-8859-8\",      ENC_8BIT,               0},", "#define IDX_ISO_9       8"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_9       8", "  {\"iso-8859-9\",      ENC_8BIT,               0},", "#define IDX_ISO_10      9"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_9       8", "  {\"iso-8859-9\",      ENC_8BIT,               0},", "#define IDX_ISO_10      9"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_10      9", "  {\"iso-8859-10\",     ENC_8BIT,               0},", "#define IDX_ISO_11      10"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_10      9", "  {\"iso-8859-10\",     ENC_8BIT,               0},", "#define IDX_ISO_11      10"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_11      10", "  {\"iso-8859-11\",     ENC_8BIT,               0},", "#define IDX_ISO_13      11"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_11      10", "  {\"iso-8859-11\",     ENC_8BIT,               0},", "#define IDX_ISO_13      11"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_13      11", "  {\"iso-8859-13\",     ENC_8BIT,               0},", "#define IDX_ISO_14      12"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_13      11", "  {\"iso-8859-13\",     ENC_8BIT,               0},", "#define IDX_ISO_14      12"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_14      12", "  {\"iso-8859-14\",     ENC_8BIT,               0},", "#define IDX_ISO_15      13"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_14      12", "  {\"iso-8859-14\",     ENC_8BIT,               0},", "#define IDX_ISO_15      13"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_15      13", "  {\"iso-8859-15\",     ENC_8BIT + ENC_LATIN9,  0},", "#define IDX_KOI8_R      14"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_15      13", "  {\"iso-8859-15\",     ENC_8BIT + ENC_LATIN9,  0},", "#define IDX_KOI8_R      14"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_KOI8_R      14", "  {\"koi8-r\",          ENC_8BIT,               0},", "#define IDX_KOI8_U      15"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_KOI8_R      14", "  {\"koi8-r\",          ENC_8BIT,               0},", "#define IDX_KOI8_U      15"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_KOI8_U      15", "  {\"koi8-u\",          ENC_8BIT,               0},", "#define IDX_UTF8        16"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_KOI8_U      15", "  {\"koi8-u\",          ENC_8BIT,               0},", "#define IDX_UTF8        16"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UTF8        16", "  {\"utf-8\",           ENC_UNICODE,            0},", "#define IDX_UCS2        17"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UTF8        16", "  {\"utf-8\",           ENC_UNICODE,            0},", "#define IDX_UCS2        17"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UCS2        17", "  {\"ucs-2\",           ENC_UNICODE + ENC_ENDIAN_B + ENC_2BYTE, 0},", "#define IDX_UCS2LE      18"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UCS2        17", "  {\"ucs-2\",           ENC_UNICODE + ENC_ENDIAN_B + ENC_2BYTE, 0},", "#define IDX_UCS2LE      18"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UCS2LE      18", "  {\"ucs-2le\",         ENC_UNICODE + ENC_ENDIAN_L + ENC_2BYTE, 0},", "#define IDX_UTF16       19"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UCS2LE      18", "  {\"ucs-2le\",         ENC_UNICODE + ENC_ENDIAN_L + ENC_2BYTE, 0},", "#define IDX_UTF16       19"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UTF16       19", "  {\"utf-16\",          ENC_UNICODE + ENC_ENDIAN_B + ENC_2WORD, 0},", "#define IDX_UTF16LE     20"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UTF16       19", "  {\"utf-16\",          ENC_UNICODE + ENC_ENDIAN_B + ENC_2WORD, 0},", "#define IDX_UTF16LE     20"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UTF16LE     20", "  {\"utf-16le\",        ENC_UNICODE + ENC_ENDIAN_L + ENC_2WORD, 0},", "#define IDX_UCS4        21"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UTF16LE     20", "  {\"utf-16le\",        ENC_UNICODE + ENC_ENDIAN_L + ENC_2WORD, 0},", "#define IDX_UCS4        21"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UCS4        21", "  {\"ucs-4\",           ENC_UNICODE + ENC_ENDIAN_B + ENC_4BYTE, 0},", "#define IDX_UCS4LE      22"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UCS4        21", "  {\"ucs-4\",           ENC_UNICODE + ENC_ENDIAN_B + ENC_4BYTE, 0},", "#define IDX_UCS4LE      22"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UCS4LE      22", "  {\"ucs-4le\",         ENC_UNICODE + ENC_ENDIAN_L + ENC_4BYTE, 0},", ""], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UCS4LE      22", "  {\"ucs-4le\",         ENC_UNICODE + ENC_ENDIAN_L + ENC_4BYTE, 0},", ""], "whitespace/braces"]
["src/nvim/mbyte.c", ["", "  /* For debugging DBCS encoding on Unix. */", "#define IDX_DEBUG       23"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_DEBUG       23", "  {\"debug\",           ENC_DBCS,               DBCS_DEBUG},", "#define IDX_EUC_JP      24"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_DEBUG       23", "  {\"debug\",           ENC_DBCS,               DBCS_DEBUG},", "#define IDX_EUC_JP      24"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_EUC_JP      24", "  {\"euc-jp\",          ENC_DBCS,               DBCS_JPNU},", "#define IDX_SJIS        25"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_EUC_JP      24", "  {\"euc-jp\",          ENC_DBCS,               DBCS_JPNU},", "#define IDX_SJIS        25"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_SJIS        25", "  {\"sjis\",            ENC_DBCS,               DBCS_JPN},", "#define IDX_EUC_KR      26"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_SJIS        25", "  {\"sjis\",            ENC_DBCS,               DBCS_JPN},", "#define IDX_EUC_KR      26"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_EUC_KR      26", "  {\"euc-kr\",          ENC_DBCS,               DBCS_KORU},", "#define IDX_EUC_CN      27"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_EUC_KR      26", "  {\"euc-kr\",          ENC_DBCS,               DBCS_KORU},", "#define IDX_EUC_CN      27"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_EUC_CN      27", "  {\"euc-cn\",          ENC_DBCS,               DBCS_CHSU},", "#define IDX_EUC_TW      28"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_EUC_CN      27", "  {\"euc-cn\",          ENC_DBCS,               DBCS_CHSU},", "#define IDX_EUC_TW      28"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_EUC_TW      28", "  {\"euc-tw\",          ENC_DBCS,               DBCS_CHTU},", "#define IDX_BIG5        29"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_EUC_TW      28", "  {\"euc-tw\",          ENC_DBCS,               DBCS_CHTU},", "#define IDX_BIG5        29"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_BIG5        29", "  {\"big5\",            ENC_DBCS,               DBCS_CHT},", ""], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_BIG5        29", "  {\"big5\",            ENC_DBCS,               DBCS_CHT},", ""], "whitespace/braces"]
["src/nvim/mbyte.c", ["", "  /* MS-DOS and MS-Windows codepages are included here, so that they can be", "   * used on Unix too.  Most of them are similar to ISO-8859 encodings, but"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP437       30", "  {\"cp437\",           ENC_8BIT,               437},   /* like iso-8859-1 */", "#define IDX_CP737       31"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP437       30", "  {\"cp437\",           ENC_8BIT,               437},   /* like iso-8859-1 */", "#define IDX_CP737       31"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP437       30", "  {\"cp437\",           ENC_8BIT,               437},   /* like iso-8859-1 */", "#define IDX_CP737       31"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP737       31", "  {\"cp737\",           ENC_8BIT,               737},   /* like iso-8859-7 */", "#define IDX_CP775       32"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP737       31", "  {\"cp737\",           ENC_8BIT,               737},   /* like iso-8859-7 */", "#define IDX_CP775       32"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP737       31", "  {\"cp737\",           ENC_8BIT,               737},   /* like iso-8859-7 */", "#define IDX_CP775       32"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP775       32", "  {\"cp775\",           ENC_8BIT,               775},   /* Baltic */", "#define IDX_CP850       33"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP775       32", "  {\"cp775\",           ENC_8BIT,               775},   /* Baltic */", "#define IDX_CP850       33"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP775       32", "  {\"cp775\",           ENC_8BIT,               775},   /* Baltic */", "#define IDX_CP850       33"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP850       33", "  {\"cp850\",           ENC_8BIT,               850},   /* like iso-8859-4 */", "#define IDX_CP852       34"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP850       33", "  {\"cp850\",           ENC_8BIT,               850},   /* like iso-8859-4 */", "#define IDX_CP852       34"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP850       33", "  {\"cp850\",           ENC_8BIT,               850},   /* like iso-8859-4 */", "#define IDX_CP852       34"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP852       34", "  {\"cp852\",           ENC_8BIT,               852},   /* like iso-8859-1 */", "#define IDX_CP855       35"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP852       34", "  {\"cp852\",           ENC_8BIT,               852},   /* like iso-8859-1 */", "#define IDX_CP855       35"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP852       34", "  {\"cp852\",           ENC_8BIT,               852},   /* like iso-8859-1 */", "#define IDX_CP855       35"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP855       35", "  {\"cp855\",           ENC_8BIT,               855},   /* like iso-8859-2 */", "#define IDX_CP857       36"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP855       35", "  {\"cp855\",           ENC_8BIT,               855},   /* like iso-8859-2 */", "#define IDX_CP857       36"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP855       35", "  {\"cp855\",           ENC_8BIT,               855},   /* like iso-8859-2 */", "#define IDX_CP857       36"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP857       36", "  {\"cp857\",           ENC_8BIT,               857},   /* like iso-8859-5 */", "#define IDX_CP860       37"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP857       36", "  {\"cp857\",           ENC_8BIT,               857},   /* like iso-8859-5 */", "#define IDX_CP860       37"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP857       36", "  {\"cp857\",           ENC_8BIT,               857},   /* like iso-8859-5 */", "#define IDX_CP860       37"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP860       37", "  {\"cp860\",           ENC_8BIT,               860},   /* like iso-8859-9 */", "#define IDX_CP861       38"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP860       37", "  {\"cp860\",           ENC_8BIT,               860},   /* like iso-8859-9 */", "#define IDX_CP861       38"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP860       37", "  {\"cp860\",           ENC_8BIT,               860},   /* like iso-8859-9 */", "#define IDX_CP861       38"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP861       38", "  {\"cp861\",           ENC_8BIT,               861},   /* like iso-8859-1 */", "#define IDX_CP862       39"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP861       38", "  {\"cp861\",           ENC_8BIT,               861},   /* like iso-8859-1 */", "#define IDX_CP862       39"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP861       38", "  {\"cp861\",           ENC_8BIT,               861},   /* like iso-8859-1 */", "#define IDX_CP862       39"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP862       39", "  {\"cp862\",           ENC_8BIT,               862},   /* like iso-8859-1 */", "#define IDX_CP863       40"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP862       39", "  {\"cp862\",           ENC_8BIT,               862},   /* like iso-8859-1 */", "#define IDX_CP863       40"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP862       39", "  {\"cp862\",           ENC_8BIT,               862},   /* like iso-8859-1 */", "#define IDX_CP863       40"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP863       40", "  {\"cp863\",           ENC_8BIT,               863},   /* like iso-8859-8 */", "#define IDX_CP865       41"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP863       40", "  {\"cp863\",           ENC_8BIT,               863},   /* like iso-8859-8 */", "#define IDX_CP865       41"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP863       40", "  {\"cp863\",           ENC_8BIT,               863},   /* like iso-8859-8 */", "#define IDX_CP865       41"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP865       41", "  {\"cp865\",           ENC_8BIT,               865},   /* like iso-8859-1 */", "#define IDX_CP866       42"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP865       41", "  {\"cp865\",           ENC_8BIT,               865},   /* like iso-8859-1 */", "#define IDX_CP866       42"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP865       41", "  {\"cp865\",           ENC_8BIT,               865},   /* like iso-8859-1 */", "#define IDX_CP866       42"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP866       42", "  {\"cp866\",           ENC_8BIT,               866},   /* like iso-8859-5 */", "#define IDX_CP869       43"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP866       42", "  {\"cp866\",           ENC_8BIT,               866},   /* like iso-8859-5 */", "#define IDX_CP869       43"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP866       42", "  {\"cp866\",           ENC_8BIT,               866},   /* like iso-8859-5 */", "#define IDX_CP869       43"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP869       43", "  {\"cp869\",           ENC_8BIT,               869},   /* like iso-8859-7 */", "#define IDX_CP874       44"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP869       43", "  {\"cp869\",           ENC_8BIT,               869},   /* like iso-8859-7 */", "#define IDX_CP874       44"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP869       43", "  {\"cp869\",           ENC_8BIT,               869},   /* like iso-8859-7 */", "#define IDX_CP874       44"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP874       44", "  {\"cp874\",           ENC_8BIT,               874},   /* Thai */", "#define IDX_CP932       45"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP874       44", "  {\"cp874\",           ENC_8BIT,               874},   /* Thai */", "#define IDX_CP932       45"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP874       44", "  {\"cp874\",           ENC_8BIT,               874},   /* Thai */", "#define IDX_CP932       45"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP932       45", "  {\"cp932\",           ENC_DBCS,               DBCS_JPN},", "#define IDX_CP936       46"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP932       45", "  {\"cp932\",           ENC_DBCS,               DBCS_JPN},", "#define IDX_CP936       46"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP936       46", "  {\"cp936\",           ENC_DBCS,               DBCS_CHS},", "#define IDX_CP949       47"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP936       46", "  {\"cp936\",           ENC_DBCS,               DBCS_CHS},", "#define IDX_CP949       47"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP949       47", "  {\"cp949\",           ENC_DBCS,               DBCS_KOR},", "#define IDX_CP950       48"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP949       47", "  {\"cp949\",           ENC_DBCS,               DBCS_KOR},", "#define IDX_CP950       48"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP950       48", "  {\"cp950\",           ENC_DBCS,               DBCS_CHT},", "#define IDX_CP1250      49"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP950       48", "  {\"cp950\",           ENC_DBCS,               DBCS_CHT},", "#define IDX_CP1250      49"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1250      49", "  {\"cp1250\",          ENC_8BIT,               1250},   /* Czech, Polish, etc. */", "#define IDX_CP1251      50"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP1250      49", "  {\"cp1250\",          ENC_8BIT,               1250},   /* Czech, Polish, etc. */", "#define IDX_CP1251      50"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1250      49", "  {\"cp1250\",          ENC_8BIT,               1250},   /* Czech, Polish, etc. */", "#define IDX_CP1251      50"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1251      50", "  {\"cp1251\",          ENC_8BIT,               1251},   /* Cyrillic */", "  /* cp1252 is considered to be equal to latin1 */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP1251      50", "  {\"cp1251\",          ENC_8BIT,               1251},   /* Cyrillic */", "  /* cp1252 is considered to be equal to latin1 */"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1251      50", "  {\"cp1251\",          ENC_8BIT,               1251},   /* Cyrillic */", "  /* cp1252 is considered to be equal to latin1 */"], "whitespace/braces"]
["src/nvim/mbyte.c", ["  {\"cp1251\",          ENC_8BIT,               1251},   /* Cyrillic */", "  /* cp1252 is considered to be equal to latin1 */", "#define IDX_CP1253      51"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP1253      51", "  {\"cp1253\",          ENC_8BIT,               1253},   /* Greek */", "#define IDX_CP1254      52"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP1253      51", "  {\"cp1253\",          ENC_8BIT,               1253},   /* Greek */", "#define IDX_CP1254      52"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1253      51", "  {\"cp1253\",          ENC_8BIT,               1253},   /* Greek */", "#define IDX_CP1254      52"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1254      52", "  {\"cp1254\",          ENC_8BIT,               1254},   /* Turkish */", "#define IDX_CP1255      53"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP1254      52", "  {\"cp1254\",          ENC_8BIT,               1254},   /* Turkish */", "#define IDX_CP1255      53"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1254      52", "  {\"cp1254\",          ENC_8BIT,               1254},   /* Turkish */", "#define IDX_CP1255      53"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1255      53", "  {\"cp1255\",          ENC_8BIT,               1255},   /* Hebrew */", "#define IDX_CP1256      54"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP1255      53", "  {\"cp1255\",          ENC_8BIT,               1255},   /* Hebrew */", "#define IDX_CP1256      54"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1255      53", "  {\"cp1255\",          ENC_8BIT,               1255},   /* Hebrew */", "#define IDX_CP1256      54"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1256      54", "  {\"cp1256\",          ENC_8BIT,               1256},   /* Arabic */", "#define IDX_CP1257      55"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP1256      54", "  {\"cp1256\",          ENC_8BIT,               1256},   /* Arabic */", "#define IDX_CP1257      55"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1256      54", "  {\"cp1256\",          ENC_8BIT,               1256},   /* Arabic */", "#define IDX_CP1257      55"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1257      55", "  {\"cp1257\",          ENC_8BIT,               1257},   /* Baltic */", "#define IDX_CP1258      56"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP1257      55", "  {\"cp1257\",          ENC_8BIT,               1257},   /* Baltic */", "#define IDX_CP1258      56"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1257      55", "  {\"cp1257\",          ENC_8BIT,               1257},   /* Baltic */", "#define IDX_CP1258      56"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1258      56", "  {\"cp1258\",          ENC_8BIT,               1258},   /* Vietnamese */", ""], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP1258      56", "  {\"cp1258\",          ENC_8BIT,               1258},   /* Vietnamese */", ""], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1258      56", "  {\"cp1258\",          ENC_8BIT,               1258},   /* Vietnamese */", ""], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_MACROMAN    57", "  {\"macroman\",        ENC_8BIT + ENC_MACROMAN, 0},      /* Mac OS */", "#define IDX_HPROMAN8    58"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_MACROMAN    57", "  {\"macroman\",        ENC_8BIT + ENC_MACROMAN, 0},      /* Mac OS */", "#define IDX_HPROMAN8    58"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_MACROMAN    57", "  {\"macroman\",        ENC_8BIT + ENC_MACROMAN, 0},      /* Mac OS */", "#define IDX_HPROMAN8    58"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_HPROMAN8    58", "  {\"hp-roman8\",       ENC_8BIT,               0},       /* HP Roman8 */", "#define IDX_COUNT       59"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_HPROMAN8    58", "  {\"hp-roman8\",       ENC_8BIT,               0},       /* HP Roman8 */", "#define IDX_COUNT       59"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_HPROMAN8    58", "  {\"hp-roman8\",       ENC_8BIT,               0},       /* HP Roman8 */", "#define IDX_COUNT       59"], "whitespace/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Aliases for encoding names."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["static struct", "{   const char *name; int canon; }", "enc_alias_table[] ="], "whitespace/newline"]
["src/nvim/mbyte.c", ["", "/*", " * Find encoding \"name\" in the list of canonical encoding names."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  for (i = 0; i < IDX_COUNT; ++i)", "    if (STRCMP(name, enc_canon_table[i].name) == 0)"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  for (i = 0; i < IDX_COUNT; ++i)", "    if (STRCMP(name, enc_canon_table[i].name) == 0)"], "readability/increment"]
["src/nvim/mbyte.c", ["  for (i = 0; i < IDX_COUNT; ++i)", "    if (STRCMP(name, enc_canon_table[i].name) == 0)", "      return i;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Find canonical encoding \"name\" in the list and return its properties."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  i = enc_canon_search(name);", "  if (i >= 0)", "    return enc_canon_table[i].prop;"], "readability/braces"]
["src/nvim/mbyte.c", ["    return enc_canon_table[i].prop;", "  if (STRNCMP(name, \"2byte-\", 6) == 0)", "    return ENC_DBCS;"], "readability/braces"]
["src/nvim/mbyte.c", ["    return ENC_DBCS;", "  if (STRNCMP(name, \"8bit-\", 5) == 0 || STRNCMP(name, \"iso-8859-\", 9) == 0)", "    return ENC_8BIT;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Return the size of the BOM for the current buffer:"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Remove all BOM from \"s\" by moving remaining text."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Get class of pointer:"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Return true if \"c\" is in \"table\"."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  /* first quick check for Latin1 etc. characters */", "  if (c < table[0].first)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  /* first quick check for Latin1 etc. characters */", "  if (c < table[0].first)", "    return false;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* binary search in table */", "  bot = 0;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    mid = (bot + top) / 2;", "    if (table[mid].last < c)", "      bot = mid + 1;"], "readability/braces"]
["src/nvim/mbyte.c", ["      bot = mid + 1;", "    else if (table[mid].first > c)", "      top = mid - 1;"], "readability/braces"]
["src/nvim/mbyte.c", ["      top = mid - 1;", "    else", "      return true;"], "readability/braces"]
["src/nvim/mbyte.c", ["    c = utf_ptr2char(p);", "    /* An illegal byte is displayed as <xx>. */", "    if (utf_ptr2len(p) == 1 || c == NUL)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    /* An illegal byte is displayed as <xx>. */", "    if (utf_ptr2len(p) == 1 || c == NUL)", "      return 4;"], "readability/braces"]
["src/nvim/mbyte.c", ["      return 4;", "    /* If the char is ASCII it must be an overlong sequence. */", "    if (c < 0x80)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    /* If the char is ASCII it must be an overlong sequence. */", "    if (c < 0x80)", "      return char2cells(c);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* Need to convert to a wide character. */", "  if (size > 0 && *p >= 0x80) {"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  if (size > 0 && *p >= 0x80) {", "    if (utf_ptr2len_len(p, size) < utf8len_tab[*p])", "      return 1;        /* truncated */"], "readability/braces"]
["src/nvim/mbyte.c", ["    if (utf_ptr2len_len(p, size) < utf8len_tab[*p])", "      return 1;        /* truncated */", "    c = utf_ptr2char(p);"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    c = utf_ptr2char(p);", "    /* An illegal byte is displayed as <xx>. */", "    if (utf_ptr2len(p) == 1 || c == NUL)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    /* An illegal byte is displayed as <xx>. */", "    if (utf_ptr2len(p) == 1 || c == NUL)", "      return 4;"], "readability/braces"]
["src/nvim/mbyte.c", ["      return 4;", "    /* If the char is ASCII it must be an overlong sequence. */", "    if (c < 0x80)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    /* If the char is ASCII it must be an overlong sequence. */", "    if (c < 0x80)", "      return char2cells(c);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Convert a UTF-8 byte sequence to a wide character."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  if (*n == 0)   /* end of buffer */", "    return 0;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  if (*n == 0)   /* end of buffer */", "    return 0;"], "readability/braces"]
["src/nvim/mbyte.c", ["  if (k == 1) {", "    /* ASCII character or NUL */", "    (*n)--;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  if (k <= *n) {", "    /* We have a multibyte sequence and it isn't truncated by buffer", "     * limits so utf_ptr2char() is safe to use. Or the first byte is"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "    /* On failure, utf_ptr2char() returns the first byte, so here we", "     * check equality with the first byte. The only non-ASCII character"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    if (c != (int)(**s) || (c == 0xC3 && (*s)[1] == 0x83)) {", "      /* byte sequence was successfully decoded */", "      *s += k;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  /* byte sequence is incomplete or illegal */", "  return -1;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Get character at **pp and advance *pp to the next character."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Get character at **pp and advance *pp to the next character."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Check if the character pointed to by \"p2\" is a composing character when it"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  c2 = utf_ptr2char(p2);", "  if (utf_iscomposing(c2))", "    return true;"], "readability/braces"]
["src/nvim/mbyte.c", ["    return true;", "  if (!arabic_maycombine(c2))", "    return false;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* Only accept a composing char when the first char isn't illegal. */", "  if ((len > 1 || *p < 0x80)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["      pcc[i++] = cc;", "      if (i == MAX_MCO)", "        break;"], "readability/braces"]
["src/nvim/mbyte.c", ["      len += utf_ptr2len(p + len);", "      if (p[len] < 0x80 || !utf_iscomposing(cc = utf_ptr2char(p + len)))", "        break;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  if (i < MAX_MCO)      /* last composing char must be 0 */", "    pcc[i] = 0;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  if (i < MAX_MCO)      /* last composing char must be 0 */", "    pcc[i] = 0;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Convert a UTF-8 byte string to a wide character.  Also get up to MAX_MCO"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Return length of UTF-8 character, obtained from the first byte."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Get the length of UTF-8 byte sequence \"p[size]\".  Does not include any"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  len = utf8len_tab[*p];", "  if (len == 1)", "    return 1;           /* NUL, ascii or illegal lead byte */"], "readability/braces"]
["src/nvim/mbyte.c", ["  if (len == 1)", "    return 1;           /* NUL, ascii or illegal lead byte */", "  if (len > size)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    return 1;           /* NUL, ascii or illegal lead byte */", "  if (len > size)", "    m = size;           /* incomplete byte sequence. */"], "readability/braces"]
["src/nvim/mbyte.c", ["  if (len > size)", "    m = size;           /* incomplete byte sequence. */", "  else"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    m = size;           /* incomplete byte sequence. */", "  else", "    m = len;"], "readability/braces"]
["src/nvim/mbyte.c", ["    m = len;", "  for (i = 1; i < m; ++i)", "    if ((p[i] & 0xc0) != 0x80)"], "readability/braces"]
["src/nvim/mbyte.c", ["    m = len;", "  for (i = 1; i < m; ++i)", "    if ((p[i] & 0xc0) != 0x80)"], "readability/increment"]
["src/nvim/mbyte.c", ["  for (i = 1; i < m; ++i)", "    if ((p[i] & 0xc0) != 0x80)", "      return 1;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Return the number of bytes the UTF-8 encoding of the character at \"p[size]\""], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  if (size < 1 || *p == NUL)", "    return 0;"], "readability/braces"]
["src/nvim/mbyte.c", ["    return 0;", "  if (p[0] < 0x80 && (size == 1 || p[1] < 0x80))   /* be quick for ASCII */", "    return 1;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    return 0;", "  if (p[0] < 0x80 && (size == 1 || p[1] < 0x80))   /* be quick for ASCII */", "    return 1;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* Skip over first UTF-8 char, stopping at a NUL byte. */", "  len = utf_ptr2len_len(p, size);"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  /* Check for illegal byte and incomplete byte sequence. */", "  if ((len == 1 && p[0] >= 0x80) || len > size)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  /* Check for illegal byte and incomplete byte sequence. */", "  if ((len == 1 && p[0] >= 0x80) || len > size)", "    return 1;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /*", "   * Check for composing characters.  We can handle only the first six, but"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "    if (p[len] < 0x80)", "      break;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "    /*", "     * Next character length should not go beyond size to ensure that"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    len_next_char = utf_ptr2len_len(p + len, size - len);", "    if (len_next_char > size - len)", "      break;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "    if (!UTF_COMPOSINGLIKE(p + prevlen, p + len))", "      break;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "    /* Skip over composing char */", "    prevlen = len;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Return true if \"c\" is a composing UTF-8 character.  This means it will be"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Return true for characters that can be displayed in a normal way."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#ifdef USE_WCHAR_FUNCTIONS", "  /*", "   * Assume the iswprint() library function works better than our own stuff."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#else", "  /* Sorted list of non-overlapping intervals.", "   * 0xd800-0xdfff is reserved for UTF-16, actually illegal. */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  static struct interval nonprint[] =", "  {", "    {0x070f, 0x070f}, {0x180b, 0x180e}, {0x200b, 0x200f}, {0x202a, 0x202e},"], "whitespace/braces"]
["src/nvim/mbyte.c", ["  {", "    {0x070f, 0x070f}, {0x180b, 0x180e}, {0x200b, 0x200f}, {0x202a, 0x202e},", "    {0x206a, 0x206f}, {0xd800, 0xdfff}, {0xfeff, 0xfeff}, {0xfff9, 0xfffb},"], "whitespace/braces"]
["src/nvim/mbyte.c", ["  {", "    {0x070f, 0x070f}, {0x180b, 0x180e}, {0x200b, 0x200f}, {0x202a, 0x202e},", "    {0x206a, 0x206f}, {0xd800, 0xdfff}, {0xfeff, 0xfeff}, {0xfff9, 0xfffb},"], "whitespace/braces"]
["src/nvim/mbyte.c", ["    {0x070f, 0x070f}, {0x180b, 0x180e}, {0x200b, 0x200f}, {0x202a, 0x202e},", "    {0x206a, 0x206f}, {0xd800, 0xdfff}, {0xfeff, 0xfeff}, {0xfff9, 0xfffb},", "    {0xfffe, 0xffff}"], "whitespace/braces"]
["src/nvim/mbyte.c", ["    {0x070f, 0x070f}, {0x180b, 0x180e}, {0x200b, 0x200f}, {0x202a, 0x202e},", "    {0x206a, 0x206f}, {0xd800, 0xdfff}, {0xfeff, 0xfeff}, {0xfff9, 0xfffb},", "    {0xfffe, 0xffff}"], "whitespace/braces"]
["src/nvim/mbyte.c", ["    {0x206a, 0x206f}, {0xd800, 0xdfff}, {0xfeff, 0xfeff}, {0xfff9, 0xfffb},", "    {0xfffe, 0xffff}", "  };"], "whitespace/braces"]
["src/nvim/mbyte.c", ["    {0x206a, 0x206f}, {0xd800, 0xdfff}, {0xfeff, 0xfeff}, {0xfff9, 0xfffb},", "    {0xfffe, 0xffff}", "  };"], "whitespace/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Get class of a Unicode character."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["{", "  /* sorted list of non-overlapping intervals */", "  static struct clinterval {"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  /* First quick check for Latin1 characters, use 'iskeyword'. */", "  if (c < 0x100) {"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  /* binary search in table */", "  while (top >= bot) {"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    mid = (bot + top) / 2;", "    if (classes[mid].last < (unsigned int)c)", "      bot = mid + 1;"], "readability/braces"]
["src/nvim/mbyte.c", ["      bot = mid + 1;", "    else if (classes[mid].first > (unsigned int)c)", "      top = mid - 1;"], "readability/braces"]
["src/nvim/mbyte.c", ["      top = mid - 1;", "    else", "      return (int)classes[mid].class;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* most other characters are \"word\" characters */", "  return 2;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Generic conversion function for case operations."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["{", "  size_t start, mid, end;   /* indices into table */", ""], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  while (start < end) {", "    /* need to search further */", "    mid = (end + start) / 2;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    mid = (end + start) / 2;", "    if (table[mid].rangeEnd < a)", "      start = mid + 1;"], "readability/braces"]
["src/nvim/mbyte.c", ["      start = mid + 1;", "    else", "      end = mid;"], "readability/braces"]
["src/nvim/mbyte.c", ["  }", "  if (start < n_items", "      && table[start].rangeStart <= a"], "readability/braces"]
["src/nvim/mbyte.c", ["    return a + table[start].offset;", "  else", "    return a;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Return the folded-case equivalent of \"a\", which is a UCS-4 character.  Uses"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["{", "  /* If 'casemap' contains \"keepascii\" use ASCII style toupper(). */", "  if (a < 128 && (cmp_flags & CMP_KEEPASCII))"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  /* If 'casemap' contains \"keepascii\" use ASCII style toupper(). */", "  if (a < 128 && (cmp_flags & CMP_KEEPASCII))", "    return TOUPPER_ASC(a);"], "readability/braces"]
["src/nvim/mbyte.c", ["#if defined(__STDC_ISO_10646__)", "  /* If towupper() is available and handles Unicode, use it. */", "  if (!(cmp_flags & CMP_INTERNAL))"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  /* If towupper() is available and handles Unicode, use it. */", "  if (!(cmp_flags & CMP_INTERNAL))", "    return towupper(a);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* For characters below 128 use locale sensitive toupper(). */", "  if (a < 128)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  /* For characters below 128 use locale sensitive toupper(). */", "  if (a < 128)", "    return TOUPPER_LOC(a);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* For any other characters use the above mapping table. */", "  return utf_convert(a, toUpper, ARRAY_SIZE(toUpper));"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["{", "  /* If 'casemap' contains \"keepascii\" use ASCII style tolower(). */", "  if (a < 128 && (cmp_flags & CMP_KEEPASCII))"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  /* If 'casemap' contains \"keepascii\" use ASCII style tolower(). */", "  if (a < 128 && (cmp_flags & CMP_KEEPASCII))", "    return TOLOWER_ASC(a);"], "readability/braces"]
["src/nvim/mbyte.c", ["#if defined(__STDC_ISO_10646__)", "  /* If towlower() is available and handles Unicode, use it. */", "  if (!(cmp_flags & CMP_INTERNAL))"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  /* If towlower() is available and handles Unicode, use it. */", "  if (!(cmp_flags & CMP_INTERNAL))", "    return towlower(a);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* For characters below 128 use locale sensitive tolower(). */", "  if (a < 128)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  /* For characters below 128 use locale sensitive tolower(). */", "  if (a < 128)", "    return TOLOWER_LOC(a);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* For any other characters use the above mapping table. */", "  return utf_convert(a, toLower, ARRAY_SIZE(toLower));"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "    if (c1 <= 0 || c2 <= 0)", "      break;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "    if (c1 == c2)", "      continue;"], "readability/braces"]
["src/nvim/mbyte.c", ["    cdiff = utf_fold(c1) - utf_fold(c2);", "    if (cdiff != 0)", "      return cdiff;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* some string ended or has an incomplete/illegal character sequence */", ""], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  if (c1 == 0 || c2 == 0) {", "    /* some string ended. shorter string is smaller */", "    if (c1 == 0 && c2 == 0)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    /* some string ended. shorter string is smaller */", "    if (c1 == 0 && c2 == 0)", "      return 0;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* Continue with bytewise comparison to produce some result that", "   * would make comparison operations involving this function transitive."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    cdiff = (int)(*s1) - (int)(*s2);", "    if (cdiff != 0)", "      return cdiff;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  if (n1 > 0 && *s1 == NUL)", "    n1 = 0;"], "readability/braces"]
["src/nvim/mbyte.c", ["    n1 = 0;", "  if (n2 > 0 && *s2 == NUL)", "    n2 = 0;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  if (n1 == 0 && n2 == 0)", "    return 0;"], "readability/braces"]
["src/nvim/mbyte.c", ["#ifndef CP_UTF8", "# define CP_UTF8 65001  /* magic number from winnls.h */", "#endif"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Version of strnicmp() that handles multi-byte characters."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * \"g8\": show bytes of the UTF-8 char under the cursor.  Doesn't matter what"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  /* Get the byte length of the char under the cursor, including composing", "   * characters. */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  clen = 0;", "  for (i = 0; i < len; ++i) {", "    if (clen == 0) {"], "readability/increment"]
["src/nvim/mbyte.c", ["    if (clen == 0) {", "      /* start of (composing) character, get its length */", "      if (i > 0) {"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    sprintf((char *)IObuff + rlen, \"%02x \",", "        (line[i] == NL) ? NUL : line[i]);          /* NUL is stored as NL */", "    --clen;"], "whitespace/alignment"]
["src/nvim/mbyte.c", ["    }", "    sprintf((char *)IObuff + rlen, \"%02x \",", "        (line[i] == NL) ? NUL : line[i]);          /* NUL is stored as NL */"], "runtime/printf"]
["src/nvim/mbyte.c", ["    sprintf((char *)IObuff + rlen, \"%02x \",", "        (line[i] == NL) ? NUL : line[i]);          /* NUL is stored as NL */", "    --clen;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["        (line[i] == NL) ? NUL : line[i]);          /* NUL is stored as NL */", "    --clen;", "    rlen += (int)STRLEN(IObuff + rlen);"], "readability/increment"]
["src/nvim/mbyte.c", ["    rlen += (int)STRLEN(IObuff + rlen);", "    if (rlen > IOSIZE - 20)", "      break;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  if (*p < 0x80)                /* be quick for ASCII */", "    return 0;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  if (*p < 0x80)                /* be quick for ASCII */", "    return 0;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* Skip backwards over trailing bytes: 10xx.xxxx", "   * Skip backwards again if on a composing char. */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  const char_u *q;", "  for (q = p;; --q) {", "    /* Move s to the last byte of this char. */"], "readability/increment"]
["src/nvim/mbyte.c", ["  for (q = p;; --q) {", "    /* Move s to the last byte of this char. */", "    const char_u *s;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    const char_u *s;", "    for (s = q; (s[1] & 0xc0) == 0x80; ++s) {}", ""], "readability/increment"]
["src/nvim/mbyte.c", ["", "    /* Move q to the first byte of this char. */", "    while (q > base && (*q & 0xc0) == 0x80)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    /* Move q to the first byte of this char. */", "    while (q > base && (*q & 0xc0) == 0x80)", "      --q;"], "readability/braces"]
["src/nvim/mbyte.c", ["    while (q > base && (*q & 0xc0) == 0x80)", "      --q;", "    /* Check for illegal sequence. Do allow an illegal byte after where we"], "readability/increment"]
["src/nvim/mbyte.c", ["      --q;", "    /* Check for illegal sequence. Do allow an illegal byte after where we", "     * started. */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    len = utf8len_tab[*q];", "    if (len != (int)(s - q + 1) && len != (int)(p - q + 1))", "      return 0;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "    if (q <= base)", "      break;"], "readability/braces"]
["src/nvim/mbyte.c", ["    c = utf_ptr2char(q);", "    if (utf_iscomposing(c))", "      continue;"], "readability/braces"]
["src/nvim/mbyte.c", ["    if (arabic_maycombine(c)) {", "      /* Advance to get a sneak-peak at the next char */", "      const char_u *j = q;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["      const char_u *j = q;", "      --j;", "      /* Move j to the first byte of this char. */"], "readability/increment"]
["src/nvim/mbyte.c", ["      --j;", "      /* Move j to the first byte of this char. */", "      while (j > base && (*j & 0xc0) == 0x80)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["      /* Move j to the first byte of this char. */", "      while (j > base && (*j & 0xc0) == 0x80)", "        --j;"], "readability/braces"]
["src/nvim/mbyte.c", ["      while (j > base && (*j & 0xc0) == 0x80)", "        --j;", "      if (arabic_combine(utf_ptr2char(j), c))"], "readability/increment"]
["src/nvim/mbyte.c", ["        --j;", "      if (arabic_combine(utf_ptr2char(j), c))", "        continue;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Return the offset from \"p\" to the first byte of a character.  When \"p\" is"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Return the offset from \"p\" to the last byte of the character it points"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  if (*p == NUL)", "    return 0;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Find the next illegal byte sequence."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["      tofree = string_convert(&vimconv, p, NULL);", "      if (tofree == NULL)", "        break;"], "readability/braces"]
["src/nvim/mbyte.c", ["    while (*p != NUL) {", "      /* Illegal means that there are not enough trail bytes (checked by", "       * utf_ptr2len()) or too many of them (overlong sequence). */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["      if (*p >= 0x80 && (len == 1", "            || utf_char2len(utf_ptr2char(p)) != len)) {", "        if (vimconv.vc_type == CONV_NONE)"], "whitespace/alignment"]
["src/nvim/mbyte.c", ["            || utf_char2len(utf_ptr2char(p)) != len)) {", "        if (vimconv.vc_type == CONV_NONE)", "          curwin->w_cursor.col += (colnr_T)(p - get_cursor_pos_ptr());"], "readability/braces"]
["src/nvim/mbyte.c", ["          curwin->w_cursor.col += (colnr_T)(p - get_cursor_pos_ptr());", "        else {", "          int l;"], "readability/braces"]
["src/nvim/mbyte.c", ["          curwin->w_cursor.col += (colnr_T)(p - get_cursor_pos_ptr());", "        else {", "          int l;"], "readability/braces"]
["src/nvim/mbyte.c", ["    }", "    if (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)", "      break;"], "readability/braces"]
["src/nvim/mbyte.c", ["      break;", "    ++curwin->w_cursor.lnum;", "    curwin->w_cursor.col = 0;"], "readability/increment"]
["src/nvim/mbyte.c", ["", "  /* didn't find it: don't move and beep */", "  curwin->w_cursor = pos;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * If the cursor moves on an trail byte, set the cursor on the lead byte."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Return a pointer to the character before \"*p\", if there is one."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    char_u *p", "    )", "{"], "whitespace/indent"]
["src/nvim/mbyte.c", ["char_u * mb_prevptr(", "    char_u *line,           /* start of the string */", "    char_u *p"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Return the character length of \"str\".  Each multi-byte character (with"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  if (p == NULL)", "    return 0;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  for (count = 0; *p != NUL; count++)", "    p += (*mb_ptr2len)(p);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Like mb_charlen() but for a string with specified length."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  for (count = 0; *p != NUL && p < str + len; count++)", "    p += (*mb_ptr2len)(p);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Skip the Vim specific head of a 'encoding' name."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["{", "  if (STRNCMP(p, \"2byte-\", 6) == 0)", "    return p + 6;"], "readability/braces"]
["src/nvim/mbyte.c", ["    return p + 6;", "  if (STRNCMP(p, \"8bit-\", 5) == 0)", "    return p + 5;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Find the canonical name for encoding \"enc\"."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  /* copy \"enc\" to allocated memory, with room for two '-' */", "  char_u *r = xmalloc(STRLEN(enc) + 3);"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  char_u *r = xmalloc(STRLEN(enc) + 3);", "  /* Make it all lower case and replace '_' with '-'. */", "  p = r;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  p = r;", "  for (s = enc; *s != NUL; ++s) {", "    if (*s == '_')"], "readability/increment"]
["src/nvim/mbyte.c", ["  for (s = enc; *s != NUL; ++s) {", "    if (*s == '_')", "      *p++ = '-';"], "readability/braces"]
["src/nvim/mbyte.c", ["      *p++ = '-';", "    else", "      *p++ = TOLOWER_ASC(*s);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* Skip \"2byte-\" and \"8bit-\". */", "  p = enc_skip(r);"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  /* Change \"microsoft-cp\" to \"cp\".  Used in some spell files. */", "  if (STRNCMP(p, \"microsoft-cp\", 12) == 0)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  /* Change \"microsoft-cp\" to \"cp\".  Used in some spell files. */", "  if (STRNCMP(p, \"microsoft-cp\", 12) == 0)", "    STRMOVE(p, p + 10);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* \"iso8859\" -> \"iso-8859\" */", "  if (STRNCMP(p, \"iso8859\", 7) == 0) {"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  /* \"iso-8859n\" -> \"iso-8859-n\" */", "  if (STRNCMP(p, \"iso-8859\", 8) == 0 && p[8] != '-') {"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  /* \"latin-N\" -> \"latinN\" */", "  if (STRNCMP(p, \"latin-\", 6) == 0)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  /* \"latin-N\" -> \"latinN\" */", "  if (STRNCMP(p, \"latin-\", 6) == 0)", "    STRMOVE(p + 5, p + 6);"], "readability/braces"]
["src/nvim/mbyte.c", ["  if (enc_canon_search(p) >= 0) {", "    /* canonical name can be used unmodified */", "    if (p != r)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    /* canonical name can be used unmodified */", "    if (p != r)", "      STRMOVE(r, p);"], "readability/braces"]
["src/nvim/mbyte.c", ["  } else if ((i = enc_alias_search(p)) >= 0) {", "    /* alias recognized, get canonical name */", "    xfree(r);"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Search for an encoding alias of \"name\"."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  for (i = 0; enc_alias_table[i].name != NULL; ++i)", "    if (STRCMP(name, enc_alias_table[i].name) == 0)"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  for (i = 0; enc_alias_table[i].name != NULL; ++i)", "    if (STRCMP(name, enc_alias_table[i].name) == 0)"], "readability/increment"]
["src/nvim/mbyte.c", ["  for (i = 0; enc_alias_table[i].name != NULL; ++i)", "    if (STRCMP(name, enc_alias_table[i].name) == 0)", "      return enc_alias_table[i].canon;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Get the canonicalized encoding of the current locale."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["# ifdef HAVE_NL_LANGINFO_CODESET", "  if (!(s = nl_langinfo(CODESET)) || *s == NUL)", "# endif"], "readability/braces"]
["src/nvim/mbyte.c", ["#  if defined(HAVE_LOCALE_H)", "    if (!(s = setlocale(LC_CTYPE, NULL)) || *s == NUL)", "#  endif"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Call iconv_open() with a check if iconv() works properly (there are broken"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  if (iconv_working == kBroken)", "    return (void *)-1;          /* detected a broken iconv() previously */"], "readability/braces"]
["src/nvim/mbyte.c", ["  if (iconv_working == kBroken)", "    return (void *)-1;          /* detected a broken iconv() previously */", ""], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  if (fd != (iconv_t)-1 && iconv_working == kUnknown) {", "    /*", "     * Do a dummy iconv() call to check if it actually works.  There is a"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["      fd = (iconv_t)-1;", "    } else", "      iconv_working = kWorking;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Convert the string \"str[slen]\" with iconv()."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    if (len == 0 || ICONV_ERRNO == ICONV_E2BIG) {", "      /* Allocate enough room for most conversions.  When re-allocating", "       * increase the buffer size. */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["      p = xmalloc(len);", "      if (done > 0)", "        memmove(p, result, done);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  if (resultlenp != NULL && result != NULL)", "    *resultlenp = (size_t)(to - (char *)result);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Setup \"vcp\" for conversion from \"from\" to \"to\"."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * As convert_setup(), but only when from_unicode_is_utf8 is TRUE will all"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  /* No conversion when one of the names is empty or they are equal. */", "  if (from == NULL || *from == NUL || to == NULL || *to == NUL"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  /* No conversion when one of the names is empty or they are equal. */", "  if (from == NULL || *from == NUL || to == NULL || *to == NUL", "      || STRCMP(from, to) == 0)"], "readability/braces"]
["src/nvim/mbyte.c", ["  to_prop = enc_canon_props(to);", "  if (from_unicode_is_utf8)", "    from_is_utf8 = from_prop & ENC_UNICODE;"], "readability/braces"]
["src/nvim/mbyte.c", ["    from_is_utf8 = from_prop & ENC_UNICODE;", "  else", "    from_is_utf8 = from_prop == ENC_UNICODE;"], "readability/braces"]
["src/nvim/mbyte.c", ["    from_is_utf8 = from_prop == ENC_UNICODE;", "  if (to_unicode_is_utf8)", "    to_is_utf8 = to_prop & ENC_UNICODE;"], "readability/braces"]
["src/nvim/mbyte.c", ["    to_is_utf8 = to_prop & ENC_UNICODE;", "  else", "    to_is_utf8 = to_prop == ENC_UNICODE;"], "readability/braces"]
["src/nvim/mbyte.c", ["  if ((from_prop & ENC_LATIN1) && to_is_utf8) {", "    /* Internal latin1 -> utf-8 conversion. */", "    vcp->vc_type = CONV_TO_UTF8;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    vcp->vc_type = CONV_TO_UTF8;", "    vcp->vc_factor = 2;         /* up to twice as long */", "  } else if ((from_prop & ENC_LATIN9) && to_is_utf8) {"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  } else if ((from_prop & ENC_LATIN9) && to_is_utf8) {", "    /* Internal latin9 -> utf-8 conversion. */", "    vcp->vc_type = CONV_9_TO_UTF8;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    vcp->vc_type = CONV_9_TO_UTF8;", "    vcp->vc_factor = 3;         /* up to three as long (euro sign) */", "  } else if (from_is_utf8 && (to_prop & ENC_LATIN1)) {"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  } else if (from_is_utf8 && (to_prop & ENC_LATIN1)) {", "    /* Internal utf-8 -> latin1 conversion. */", "    vcp->vc_type = CONV_TO_LATIN1;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  } else if (from_is_utf8 && (to_prop & ENC_LATIN9)) {", "    /* Internal utf-8 -> latin9 conversion. */", "    vcp->vc_type = CONV_TO_LATIN9;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["      vcp->vc_type = CONV_ICONV;", "      vcp->vc_factor = 4;       /* could be longer too... */", "    }"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["# endif", "  if (vcp->vc_type == CONV_NONE)", "    return FAIL;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Convert text \"ptr[*lenp]\" according to \"vcp\"."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Like string_convert(), but when \"unconvlenp\" is not NULL and there are is"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  size_t len;", "  if (lenp == NULL)", "    len = STRLEN(ptr);"], "readability/braces"]
["src/nvim/mbyte.c", ["    len = STRLEN(ptr);", "  else", "    len = *lenp;"], "readability/braces"]
["src/nvim/mbyte.c", ["    len = *lenp;", "  if (len == 0)", "    return vim_strsave((char_u *)\"\");"], "readability/braces"]
["src/nvim/mbyte.c", ["  switch (vcp->vc_type) {", "    case CONV_TO_UTF8:            /* latin1 to utf-8 conversion */", "      retval = xmalloc(len * 2 + 1);"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["      d = retval;", "      for (size_t i = 0; i < len; ++i) {", "        c = ptr[i];"], "readability/increment"]
["src/nvim/mbyte.c", ["        c = ptr[i];", "        if (c < 0x80)", "          *d++ = c;"], "readability/braces"]
["src/nvim/mbyte.c", ["          *d++ = c;", "        else {", "          *d++ = 0xc0 + ((unsigned)c >> 6);"], "readability/braces"]
["src/nvim/mbyte.c", ["          *d++ = c;", "        else {", "          *d++ = 0xc0 + ((unsigned)c >> 6);"], "readability/braces"]
["src/nvim/mbyte.c", ["      *d = NUL;", "      if (lenp != NULL)", "        *lenp = (size_t)(d - retval);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "    case CONV_9_TO_UTF8:          /* latin9 to utf-8 conversion */", "      retval = xmalloc(len * 3 + 1);"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["      d = retval;", "      for (size_t i = 0; i < len; ++i) {", "        c = ptr[i];"], "readability/increment"]
["src/nvim/mbyte.c", ["        switch (c) {", "          case 0xa4: c = 0x20ac; break;                 /* euro */", "          case 0xa6: c = 0x0160; break;                 /* S hat */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["          case 0xa4: c = 0x20ac; break;                 /* euro */", "          case 0xa6: c = 0x0160; break;                 /* S hat */", "          case 0xa8: c = 0x0161; break;                 /* S -hat */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["          case 0xa6: c = 0x0160; break;                 /* S hat */", "          case 0xa8: c = 0x0161; break;                 /* S -hat */", "          case 0xb4: c = 0x017d; break;                 /* Z hat */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["          case 0xa8: c = 0x0161; break;                 /* S -hat */", "          case 0xb4: c = 0x017d; break;                 /* Z hat */", "          case 0xb8: c = 0x017e; break;                 /* Z -hat */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["          case 0xb4: c = 0x017d; break;                 /* Z hat */", "          case 0xb8: c = 0x017e; break;                 /* Z -hat */", "          case 0xbc: c = 0x0152; break;                 /* OE */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["          case 0xb8: c = 0x017e; break;                 /* Z -hat */", "          case 0xbc: c = 0x0152; break;                 /* OE */", "          case 0xbd: c = 0x0153; break;                 /* oe */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["          case 0xbc: c = 0x0152; break;                 /* OE */", "          case 0xbd: c = 0x0153; break;                 /* oe */", "          case 0xbe: c = 0x0178; break;                 /* Y */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["          case 0xbd: c = 0x0153; break;                 /* oe */", "          case 0xbe: c = 0x0178; break;                 /* Y */", "        }"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["      *d = NUL;", "      if (lenp != NULL)", "        *lenp = (size_t)(d - retval);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "    case CONV_TO_LATIN1:          /* utf-8 to latin1 conversion */", "    case CONV_TO_LATIN9:          /* utf-8 to latin9 conversion */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    case CONV_TO_LATIN1:          /* utf-8 to latin1 conversion */", "    case CONV_TO_LATIN9:          /* utf-8 to latin9 conversion */", "      retval = xmalloc(len + 1);"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["      d = retval;", "      for (size_t i = 0; i < len; ++i) {", "        l = utf_ptr2len_len(ptr + i, len - i);"], "readability/increment"]
["src/nvim/mbyte.c", ["        l = utf_ptr2len_len(ptr + i, len - i);", "        if (l == 0)", "          *d++ = NUL;"], "readability/braces"]
["src/nvim/mbyte.c", ["          *d++ = NUL;", "        else if (l == 1) {", "          uint8_t l_w = utf8len_tab_zero[ptr[i]];"], "readability/braces"]
["src/nvim/mbyte.c", ["          if (l_w == 0) {", "            /* Illegal utf-8 byte cannot be converted */", "            xfree(retval);"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["          if (unconvlenp != NULL && l_w > len - i) {", "            /* Incomplete sequence at the end. */", "            *unconvlenp = len - i;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["          c = utf_ptr2char(ptr + i);", "          if (vcp->vc_type == CONV_TO_LATIN9)", "            switch (c) {"], "readability/braces"]
["src/nvim/mbyte.c", ["            switch (c) {", "              case 0x20ac: c = 0xa4; break;                     /* euro */", "              case 0x0160: c = 0xa6; break;                     /* S hat */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["              case 0x20ac: c = 0xa4; break;                     /* euro */", "              case 0x0160: c = 0xa6; break;                     /* S hat */", "              case 0x0161: c = 0xa8; break;                     /* S -hat */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["              case 0x0160: c = 0xa6; break;                     /* S hat */", "              case 0x0161: c = 0xa8; break;                     /* S -hat */", "              case 0x017d: c = 0xb4; break;                     /* Z hat */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["              case 0x0161: c = 0xa8; break;                     /* S -hat */", "              case 0x017d: c = 0xb4; break;                     /* Z hat */", "              case 0x017e: c = 0xb8; break;                     /* Z -hat */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["              case 0x017d: c = 0xb4; break;                     /* Z hat */", "              case 0x017e: c = 0xb8; break;                     /* Z -hat */", "              case 0x0152: c = 0xbc; break;                     /* OE */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["              case 0x017e: c = 0xb8; break;                     /* Z -hat */", "              case 0x0152: c = 0xbc; break;                     /* OE */", "              case 0x0153: c = 0xbd; break;                     /* oe */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["              case 0x0152: c = 0xbc; break;                     /* OE */", "              case 0x0153: c = 0xbd; break;                     /* oe */", "              case 0x0178: c = 0xbe; break;                     /* Y */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["              case 0x0153: c = 0xbd; break;                     /* oe */", "              case 0x0178: c = 0xbe; break;                     /* Y */", "              case 0xa4:"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["              case 0xbd:", "              case 0xbe: c = 0x100; break;                   /* not in latin9 */", "            }"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["            }", "          if (!utf_iscomposing(c)) {              /* skip composing chars */", "            if (c < 0x100)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["          if (!utf_iscomposing(c)) {              /* skip composing chars */", "            if (c < 0x100)", "              *d++ = c;"], "readability/braces"]
["src/nvim/mbyte.c", ["              *d++ = c;", "            else if (vcp->vc_fail) {", "              xfree(retval);"], "readability/braces"]
["src/nvim/mbyte.c", ["              *d++ = 0xbf;", "              if (utf_char2cells(c) > 1)", "                *d++ = '?';"], "readability/braces"]
["src/nvim/mbyte.c", ["      *d = NUL;", "      if (lenp != NULL)", "        *lenp = (size_t)(d - retval);"], "readability/braces"]
