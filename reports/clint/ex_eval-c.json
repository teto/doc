["src/nvim/ex_eval.c", ["  (did_emsg \\", "   || got_int \\", "   || current_exception \\"], "whitespace/indent"]
["src/nvim/ex_eval.c", ["   || got_int \\", "   || current_exception \\", "   || (cstack->cs_idx > 0 \\"], "whitespace/indent"]
["src/nvim/ex_eval.c", ["   || current_exception \\", "   || (cstack->cs_idx > 0 \\", "       && !(cstack->cs_flags[cstack->cs_idx - 1] & CSF_ACTIVE)))"], "whitespace/indent"]
["src/nvim/ex_eval.c", ["", "/*", " * When several errors appear in a row, setting \"force_abort\" is delayed until"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", [" */", "static int cause_abort = FALSE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["", "/*", " * The value of \"force_abort\" is temporarily reset by the first emsg() call"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["{", "  if (cause_abort)", "    force_abort = TRUE;"], "readability/braces"]
["src/nvim/ex_eval.c", ["  if (cause_abort)", "    force_abort = TRUE;", "}"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "/*", " * Return TRUE if a command with a subcommand resulting in \"retcode\" should"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * Return TRUE if a function with the \"abort\" flag should not be considered"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["{", "  /* This function is only called after an error.  In this case, \"force_abort\"", "   * determines whether searching for finally clauses is necessary. */"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  /*", "   * Do nothing when displaying the interrupt message or reporting an"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  /*", "   * If emsg() has not been called previously, temporarily reset"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    cause_abort = force_abort;", "    force_abort = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  /*", "   * If no try conditional is active and no exception is being thrown and"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  /*", "   * Ignore an interrupt message when inside a try conditional or when an"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  /*", "   * Ensure that all commands in nested function calls and sourced files"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["   */", "  cause_abort = TRUE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  /*", "   * When an exception is being thrown, some commands (like conditionals) are"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  if (!THROW_ON_ERROR) {", "    /*", "     * Print error message immediately without searching for a matching"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  {", "    /*", "     * Prepare the throw of an error exception, so that everything will"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      plist = msg_list;", "      while (*plist != NULL)", "        plist = &(*plist)->next;"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "        /* Skip the extra \"Vim \" prefix for message \"E458\". */", "        tmsg = elem->msg;"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["        tmsg = elem->msg;", "        if (STRNCMP(tmsg, \"Vim E\", 5) == 0", "            && ascii_isdigit(tmsg[5])"], "readability/braces"]
["src/nvim/ex_eval.c", ["          (*msg_list)->throw_msg = &tmsg[4];", "        else", "          (*msg_list)->throw_msg = tmsg;"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "/*", " * Free a \"msg_list\" and the messages it contains."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * Free global \"*msg_list\" and the messages it contains, then set \"*msg_list\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * Throw the message specified in the call to cause_errthrow() above as an"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["{", "  /*", "   * Ensure that all commands in nested function calls and sourced files"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  if (cause_abort) {", "    cause_abort = FALSE;", "    force_abort = TRUE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    cause_abort = FALSE;", "    force_abort = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  /* If no exception is to be thrown or the conversion should be done after", "   * returning to a previous invocation of do_one_cmd(), do nothing. */"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["   * returning to a previous invocation of do_one_cmd(), do nothing. */", "  if (msg_list == NULL || *msg_list == NULL)", "    return;"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "  if (throw_exception(*msg_list, ET_ERROR, cmdname) == FAIL)", "    free_msglist(*msg_list);"], "readability/braces"]
["src/nvim/ex_eval.c", ["    free_msglist(*msg_list);", "  else {", "    if (cstack != NULL)"], "readability/braces"]
["src/nvim/ex_eval.c", ["    free_msglist(*msg_list);", "  else {", "    if (cstack != NULL)"], "readability/braces"]
["src/nvim/ex_eval.c", ["  else {", "    if (cstack != NULL)", "      do_throw(cstack);"], "readability/braces"]
["src/nvim/ex_eval.c", ["      do_throw(cstack);", "    else", "      need_rethrow = TRUE;"], "readability/braces"]
["src/nvim/ex_eval.c", ["    else", "      need_rethrow = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "/*", " * do_intthrow(): Replace the current exception by an interrupt or interrupt"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "    /* msg_add_fname may have been used to prefix the message with a file", "     * name in quotes.  In the exception value, put the file name in"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["          p[-2] = NUL;", "          sprintf((char *)(val + STRLEN(p)), \" (%s)\", &mesg[1]);", "          p[-2] = '\"';"], "runtime/printf"]
["src/nvim/ex_eval.c", ["  } else {", "    *should_free = FALSE;", "    ret = (char_u *) value;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    *should_free = FALSE;", "    ret = (char_u *) value;", "  }"], "whitespace/cast"]
["src/nvim/ex_eval.c", ["", "  /*", "   * Disallow faking Interrupt or error exceptions as user exceptions.  They"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  if (type == ET_ERROR)", "    /* Store the original message and prefix the exception value with"], "readability/braces"]
["src/nvim/ex_eval.c", ["  if (type == ET_ERROR)", "    /* Store the original message and prefix the exception value with", "     * \"Vim:\" or, if a command name is given, \"Vim(cmdname):\". */"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  excp->value = get_exception_string(value, type, cmdname, &should_free);", "  if (excp->value == NULL && should_free)", "    goto nomem;"], "readability/braces"]
["src/nvim/ex_eval.c", ["  excp->throw_name = vim_strsave(sourcing_name == NULL", "      ? (char_u *)\"\" : sourcing_name);", "  excp->throw_lnum = sourcing_lnum;"], "whitespace/alignment"]
["src/nvim/ex_eval.c", ["", "    if (debug_break_level > 0)", "      msg_silent = FALSE;               /* display messages */"], "readability/braces"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0)", "      msg_silent = FALSE;               /* display messages */", "    else"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0)", "      msg_silent = FALSE;               /* display messages */", "    else"], "readability/bool"]
["src/nvim/ex_eval.c", ["      msg_silent = FALSE;               /* display messages */", "    else", "      verbose_enter();"], "readability/braces"]
["src/nvim/ex_eval.c", ["      verbose_enter();", "    ++no_wait_return;", "    if (debug_break_level > 0 || *p_vfile == NUL)"], "readability/increment"]
["src/nvim/ex_eval.c", ["    ++no_wait_return;", "    if (debug_break_level > 0 || *p_vfile == NUL)", "      msg_scroll = TRUE;            /* always scroll up, don't overwrite */"], "readability/braces"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0 || *p_vfile == NUL)", "      msg_scroll = TRUE;            /* always scroll up, don't overwrite */", ""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0 || *p_vfile == NUL)", "      msg_scroll = TRUE;            /* always scroll up, don't overwrite */", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["", "    if (debug_break_level > 0 || *p_vfile == NUL)", "      cmdline_row = msg_row;"], "readability/braces"]
["src/nvim/ex_eval.c", ["      cmdline_row = msg_row;", "    --no_wait_return;", "    if (debug_break_level > 0)"], "readability/increment"]
["src/nvim/ex_eval.c", ["    --no_wait_return;", "    if (debug_break_level > 0)", "      msg_silent = save_msg_silent;"], "readability/braces"]
["src/nvim/ex_eval.c", ["      msg_silent = save_msg_silent;", "    else", "      verbose_leave();"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "/*", " * Discard an exception.  \"was_finished\" is set when the exception has been"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    saved_IObuff = vim_strsave(IObuff);", "    if (debug_break_level > 0)", "      msg_silent = FALSE;               /* display messages */"], "readability/braces"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0)", "      msg_silent = FALSE;               /* display messages */", "    else"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0)", "      msg_silent = FALSE;               /* display messages */", "    else"], "readability/bool"]
["src/nvim/ex_eval.c", ["      msg_silent = FALSE;               /* display messages */", "    else", "      verbose_enter();"], "readability/braces"]
["src/nvim/ex_eval.c", ["      verbose_enter();", "    ++no_wait_return;", "    if (debug_break_level > 0 || *p_vfile == NUL)"], "readability/increment"]
["src/nvim/ex_eval.c", ["    ++no_wait_return;", "    if (debug_break_level > 0 || *p_vfile == NUL)", "      msg_scroll = TRUE;            /* always scroll up, don't overwrite */"], "readability/braces"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0 || *p_vfile == NUL)", "      msg_scroll = TRUE;            /* always scroll up, don't overwrite */", "    smsg(was_finished ? _(\"Exception finished: %s\")"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0 || *p_vfile == NUL)", "      msg_scroll = TRUE;            /* always scroll up, don't overwrite */", "    smsg(was_finished ? _(\"Exception finished: %s\")"], "readability/bool"]
["src/nvim/ex_eval.c", ["    smsg(was_finished ? _(\"Exception finished: %s\")", "                      : _(\"Exception discarded: %s\"),", "         excp->value);"], "whitespace/alignment"]
["src/nvim/ex_eval.c", ["  }", "  if (excp->type != ET_INTERRUPT)", "    xfree(excp->value);"], "readability/braces"]
["src/nvim/ex_eval.c", ["    xfree(excp->value);", "  if (excp->type == ET_ERROR)", "    free_msglist(excp->messages);"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "/*", " * Discard the exception currently being thrown."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * Put an exception on the caught stack."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  caught_stack = excp;", "  set_vim_var_string(VV_EXCEPTION, (char *) excp->value, -1);", "  if (*excp->throw_name != NUL) {"], "whitespace/cast"]
["src/nvim/ex_eval.c", ["    }", "    set_vim_var_string(VV_THROWPOINT, (char *) IObuff, -1);", "  } else {"], "whitespace/cast"]
["src/nvim/ex_eval.c", ["", "    if (debug_break_level > 0)", "      msg_silent = FALSE;               /* display messages */"], "readability/braces"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0)", "      msg_silent = FALSE;               /* display messages */", "    else"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0)", "      msg_silent = FALSE;               /* display messages */", "    else"], "readability/bool"]
["src/nvim/ex_eval.c", ["      msg_silent = FALSE;               /* display messages */", "    else", "      verbose_enter();"], "readability/braces"]
["src/nvim/ex_eval.c", ["      verbose_enter();", "    ++no_wait_return;", "    if (debug_break_level > 0 || *p_vfile == NUL)"], "readability/increment"]
["src/nvim/ex_eval.c", ["    ++no_wait_return;", "    if (debug_break_level > 0 || *p_vfile == NUL)", "      msg_scroll = TRUE;            /* always scroll up, don't overwrite */"], "readability/braces"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0 || *p_vfile == NUL)", "      msg_scroll = TRUE;            /* always scroll up, don't overwrite */", ""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0 || *p_vfile == NUL)", "      msg_scroll = TRUE;            /* always scroll up, don't overwrite */", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["", "    if (debug_break_level > 0 || *p_vfile == NUL)", "      cmdline_row = msg_row;"], "readability/braces"]
["src/nvim/ex_eval.c", ["      cmdline_row = msg_row;", "    --no_wait_return;", "    if (debug_break_level > 0)"], "readability/increment"]
["src/nvim/ex_eval.c", ["    --no_wait_return;", "    if (debug_break_level > 0)", "      msg_silent = save_msg_silent;"], "readability/braces"]
["src/nvim/ex_eval.c", ["      msg_silent = save_msg_silent;", "    else", "      verbose_leave();"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "/*", " * Remove an exception from the caught stack."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  if (caught_stack != NULL) {", "    set_vim_var_string(VV_EXCEPTION, (char *) caught_stack->value, -1);", "    if (*caught_stack->throw_name != NUL) {"], "whitespace/cast"]
["src/nvim/ex_eval.c", ["      }", "      set_vim_var_string(VV_THROWPOINT, (char *) IObuff, -1);", "    } else {"], "whitespace/cast"]
["src/nvim/ex_eval.c", ["", "/*", " * Flags specifying the message displayed by report_pending."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * Report information about something pending in a finally clause if required by"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    break;", "  /* case RP_DISCARD: */", "  default:"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  case CSTP_RETURN:", "    /* \":return\" command producing value, allocated */", "    s = (char *)get_return_cmd(value);"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      s = (char *)((except_T *)value)->value;", "    } else if ((pending & CSTP_ERROR) && (pending & CSTP_INTERRUPT))", "      s = _(\"Error and interrupt\");"], "readability/braces"]
["src/nvim/ex_eval.c", ["      s = _(\"Error and interrupt\");", "    else if (pending & CSTP_ERROR)", "      s = _(\"Error\");"], "readability/braces"]
["src/nvim/ex_eval.c", ["      s = _(\"Error\");", "    else         /* if (pending & CSTP_INTERRUPT) */", "      s = _(\"Interrupt\");"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      s = _(\"Error\");", "    else         /* if (pending & CSTP_INTERRUPT) */", "      s = _(\"Interrupt\");"], "readability/braces"]
["src/nvim/ex_eval.c", ["  save_msg_silent = msg_silent;", "  if (debug_break_level > 0)", "    msg_silent = FALSE;         /* display messages */"], "readability/braces"]
["src/nvim/ex_eval.c", ["  if (debug_break_level > 0)", "    msg_silent = FALSE;         /* display messages */", "  ++no_wait_return;"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  if (debug_break_level > 0)", "    msg_silent = FALSE;         /* display messages */", "  ++no_wait_return;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    msg_silent = FALSE;         /* display messages */", "  ++no_wait_return;", "  msg_scroll = TRUE;            /* always scroll up, don't overwrite */"], "readability/increment"]
["src/nvim/ex_eval.c", ["  ++no_wait_return;", "  msg_scroll = TRUE;            /* always scroll up, don't overwrite */", "  smsg(mesg, s);"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  ++no_wait_return;", "  msg_scroll = TRUE;            /* always scroll up, don't overwrite */", "  smsg(mesg, s);"], "readability/bool"]
["src/nvim/ex_eval.c", ["  cmdline_row = msg_row;", "  --no_wait_return;", "  if (debug_break_level > 0)"], "readability/increment"]
["src/nvim/ex_eval.c", ["  --no_wait_return;", "  if (debug_break_level > 0)", "    msg_silent = save_msg_silent;"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "  if (pending == CSTP_RETURN)", "    xfree(s);"], "readability/braces"]
["src/nvim/ex_eval.c", ["    xfree(s);", "  else if (pending & CSTP_THROW)", "    xfree(mesg);"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "/*", " * If something is made pending in a finally clause, report it if required by"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  if (p_verbose >= 14 || debug_break_level > 0) {", "    if (debug_break_level <= 0)", "      verbose_enter();"], "readability/braces"]
["src/nvim/ex_eval.c", ["    report_pending(RP_MAKE, pending, value);", "    if (debug_break_level <= 0)", "      verbose_leave();"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "/*", " * If something pending in a finally clause is resumed at the \":endtry\", report"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  if (p_verbose >= 14 || debug_break_level > 0) {", "    if (debug_break_level <= 0)", "      verbose_enter();"], "readability/braces"]
["src/nvim/ex_eval.c", ["    report_pending(RP_RESUME, pending, value);", "    if (debug_break_level <= 0)", "      verbose_leave();"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "/*", " * If something pending in a finally clause is discarded, report it if required"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  if (p_verbose >= 14 || debug_break_level > 0) {", "    if (debug_break_level <= 0)", "      verbose_enter();"], "readability/braces"]
["src/nvim/ex_eval.c", ["    report_pending(RP_DISCARD, pending, value);", "    if (debug_break_level <= 0)", "      verbose_leave();"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "/*", " * \":if\"."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  if (cstack->cs_idx == CSTACK_LEN - 1)", "    eap->errmsg = (char_u *)N_(\"E579: :if nesting too deep\");"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E579: :if nesting too deep\");", "  else {", "    ++cstack->cs_idx;"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E579: :if nesting too deep\");", "  else {", "    ++cstack->cs_idx;"], "readability/braces"]
["src/nvim/ex_eval.c", ["  else {", "    ++cstack->cs_idx;", "    cstack->cs_flags[cstack->cs_idx] = 0;"], "readability/increment"]
["src/nvim/ex_eval.c", ["    if (!skip && !error) {", "      if (result)", "        cstack->cs_flags[cstack->cs_idx] = CSF_ACTIVE | CSF_TRUE;"], "readability/braces"]
["src/nvim/ex_eval.c", ["        cstack->cs_flags[cstack->cs_idx] = CSF_ACTIVE | CSF_TRUE;", "    } else", "      /* set TRUE, so this conditional will never get active */"], "readability/braces"]
["src/nvim/ex_eval.c", ["    } else", "      /* set TRUE, so this conditional will never get active */", "      cstack->cs_flags[cstack->cs_idx] = CSF_TRUE;"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * \":endif\"."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["{", "  did_endif = TRUE;", "  if (eap->cstack->cs_idx < 0"], "readability/bool"]
["src/nvim/ex_eval.c", ["  did_endif = TRUE;", "  if (eap->cstack->cs_idx < 0", "      || (eap->cstack->cs_flags[eap->cstack->cs_idx]"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E580: :endif without :if\");", "  else {", "    /*"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E580: :endif without :if\");", "  else {", "    /*"], "readability/braces"]
["src/nvim/ex_eval.c", ["  else {", "    /*", "     * When debugging or a breakpoint was encountered, display the debug"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["     */", "    if (!(eap->cstack->cs_flags[eap->cstack->cs_idx] & CSF_TRUE)", "        && dbg_check_skipped(eap))"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "    --eap->cstack->cs_idx;", "  }"], "readability/increment"]
["src/nvim/ex_eval.c", ["", "/*", " * \":else\" and \":elseif\"."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E582: :elseif without :if\");", "    skip = TRUE;", "  } else if (cstack->cs_flags[cstack->cs_idx] & CSF_ELSE) {"], "readability/bool"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E584: :elseif after :else\");", "    skip = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  /* if skipping or the \":if\" was TRUE, reset ACTIVE, otherwise set it */", "  if (skip || cstack->cs_flags[cstack->cs_idx] & CSF_TRUE) {"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  if (skip || cstack->cs_flags[cstack->cs_idx] & CSF_TRUE) {", "    if (eap->errmsg == NULL)", "      cstack->cs_flags[cstack->cs_idx] = CSF_TRUE;"], "readability/braces"]
["src/nvim/ex_eval.c", ["      cstack->cs_flags[cstack->cs_idx] = CSF_TRUE;", "    skip = TRUE;        /* don't evaluate an \":elseif\" */", "  } else"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      cstack->cs_flags[cstack->cs_idx] = CSF_TRUE;", "    skip = TRUE;        /* don't evaluate an \":elseif\" */", "  } else"], "readability/bool"]
["src/nvim/ex_eval.c", ["    skip = TRUE;        /* don't evaluate an \":elseif\" */", "  } else", "    cstack->cs_flags[cstack->cs_idx] = CSF_ACTIVE;"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "  /*", "   * When debugging or a breakpoint was encountered, display the debug prompt"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    (void)do_intthrow(cstack);", "    skip = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["    result = eval_to_bool(eap->arg, &error, &eap->nextcmd, skip);", "    /* When throwing error exceptions, we want to throw always the first", "     * of several errors in a row.  This is what actually happens when"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if (!skip && !error) {", "      if (result)", "        cstack->cs_flags[cstack->cs_idx] = CSF_ACTIVE | CSF_TRUE;"], "readability/braces"]
["src/nvim/ex_eval.c", ["        cstack->cs_flags[cstack->cs_idx] = CSF_ACTIVE | CSF_TRUE;", "      else", "        cstack->cs_flags[cstack->cs_idx] = 0;"], "readability/braces"]
["src/nvim/ex_eval.c", ["        cstack->cs_flags[cstack->cs_idx] = 0;", "    } else if (eap->errmsg == NULL)", "      /* set TRUE, so this conditional will never get active */"], "readability/braces"]
["src/nvim/ex_eval.c", ["    } else if (eap->errmsg == NULL)", "      /* set TRUE, so this conditional will never get active */", "      cstack->cs_flags[cstack->cs_idx] = CSF_TRUE;"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      cstack->cs_flags[cstack->cs_idx] = CSF_TRUE;", "  } else", "    cstack->cs_flags[cstack->cs_idx] |= CSF_ELSE;"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "/*", " * Handle \":while\" and \":for\"."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  if (cstack->cs_idx == CSTACK_LEN - 1)", "    eap->errmsg = (char_u *)N_(\"E585: :while/:for nesting too deep\");"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E585: :while/:for nesting too deep\");", "  else {", "    /*"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E585: :while/:for nesting too deep\");", "  else {", "    /*"], "readability/braces"]
["src/nvim/ex_eval.c", ["  else {", "    /*", "     * The loop flag is set when we have jumped back from the matching"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if ((cstack->cs_lflags & CSL_HAD_LOOP) == 0) {", "      ++cstack->cs_idx;", "      ++cstack->cs_looplevel;"], "readability/increment"]
["src/nvim/ex_eval.c", ["      ++cstack->cs_idx;", "      ++cstack->cs_looplevel;", "      cstack->cs_line[cstack->cs_idx] = -1;"], "readability/increment"]
["src/nvim/ex_eval.c", ["    if (eap->cmdidx == CMD_while) {", "      /*", "       * \":while bool-expr\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * \":for var in list-expr\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      if ((cstack->cs_lflags & CSL_HAD_LOOP) != 0) {", "        /* Jumping here from a \":continue\" or \":endfor\": use the", "         * previously evaluated list. */"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["        fi = cstack->cs_forinfo[cstack->cs_idx];", "        error = FALSE;", "      } else {"], "readability/bool"]
["src/nvim/ex_eval.c", ["      } else {", "        /* Evaluate the argument and get the info in a structure. */", "        fi = eval_for_line(eap->arg, &error, &eap->nextcmd, skip);"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /* use the element at the start of the list and advance */", "      if (!error && fi != NULL && !skip)"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      /* use the element at the start of the list and advance */", "      if (!error && fi != NULL && !skip)", "        result = next_for_item(fi, eap->arg);"], "readability/braces"]
["src/nvim/ex_eval.c", ["        result = next_for_item(fi, eap->arg);", "      else", "        result = FALSE;"], "readability/braces"]
["src/nvim/ex_eval.c", ["      else", "        result = FALSE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["", "    /*", "     * If this cstack entry was just initialised and is active, set the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      cstack->cs_lflags &= ~CSL_HAD_LOOP;", "      /* If the \":while\" evaluates to FALSE or \":for\" is past the end of", "       * the list, show the debug prompt at the \":endwhile\"/\":endfor\" as"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["       * TRUE. */", "      if (!skip && !error)", "        cstack->cs_flags[cstack->cs_idx] |= CSF_TRUE;"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "/*", " * \":continue\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  if (cstack->cs_looplevel <= 0 || cstack->cs_idx < 0)", "    eap->errmsg = (char_u *)N_(\"E586: :continue without :while or :for\");"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E586: :continue without :while or :for\");", "  else {", "    /* Try to find the matching \":while\".  This might stop at a try"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E586: :continue without :while or :for\");", "  else {", "    /* Try to find the matching \":while\".  This might stop at a try"], "readability/braces"]
["src/nvim/ex_eval.c", ["  else {", "    /* Try to find the matching \":while\".  This might stop at a try", "     * conditional not in its finally clause (which is then to be executed"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["     * itself (if reached). */", "    idx = cleanup_conditionals(cstack, CSF_WHILE | CSF_FOR, FALSE);", "    assert(idx >= 0);"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "      /*", "       * Set CSL_HAD_CONT, so do_cmdline() will jump back to the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["       */", "      cstack->cs_lflags |= CSL_HAD_CONT;        /* let do_cmdline() handle it */", "    } else {"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    } else {", "      /* If a try conditional not in its finally clause is reached first,", "       * make the \":continue\" pending for execution at the \":endtry\". */"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * \":break\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  if (cstack->cs_looplevel <= 0 || cstack->cs_idx < 0)", "    eap->errmsg = (char_u *)N_(\"E587: :break without :while or :for\");"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E587: :break without :while or :for\");", "  else {", "    /* Inactivate conditionals until the matching \":while\" or a try"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E587: :break without :while or :for\");", "  else {", "    /* Inactivate conditionals until the matching \":while\" or a try"], "readability/braces"]
["src/nvim/ex_eval.c", ["  else {", "    /* Inactivate conditionals until the matching \":while\" or a try", "     * conditional not in its finally clause (which is then to be"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["     * pending for execution at the \":endtry\". */", "    idx = cleanup_conditionals(cstack, CSF_WHILE | CSF_FOR, TRUE);", "    if (idx >= 0 && !(cstack->cs_flags[idx] & (CSF_WHILE | CSF_FOR))) {"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "/*", " * \":endwhile\" and \":endfor\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  if (cstack->cs_looplevel <= 0 || cstack->cs_idx < 0)", "    eap->errmsg = err;"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = err;", "  else {", "    fl =  cstack->cs_flags[cstack->cs_idx];"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = err;", "  else {", "    fl =  cstack->cs_flags[cstack->cs_idx];"], "readability/braces"]
["src/nvim/ex_eval.c", ["    if (!(fl & csf)) {", "      /* If we are in a \":while\" or \":for\" but used the wrong endloop", "       * command, do not rewind to the next enclosing \":for\"/\":while\". */"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["       * command, do not rewind to the next enclosing \":for\"/\":while\". */", "      if (fl & CSF_WHILE)", "        eap->errmsg = (char_u *)_(\"E732: Using :endfor with :while\");"], "readability/braces"]
["src/nvim/ex_eval.c", ["        eap->errmsg = (char_u *)_(\"E732: Using :endfor with :while\");", "      else if (fl & CSF_FOR)", "        eap->errmsg = (char_u *)_(\"E733: Using :endwhile with :for\");"], "readability/braces"]
["src/nvim/ex_eval.c", ["    if (!(fl & (CSF_WHILE | CSF_FOR))) {", "      if (!(fl & CSF_TRY))", "        eap->errmsg = e_endif;"], "readability/braces"]
["src/nvim/ex_eval.c", ["        eap->errmsg = e_endif;", "      else if (fl & CSF_FINALLY)", "        eap->errmsg = e_endtry;"], "readability/braces"]
["src/nvim/ex_eval.c", ["        eap->errmsg = e_endtry;", "      /* Try to find the matching \":while\" and report what's missing. */", "      for (idx = cstack->cs_idx; idx > 0; --idx) {"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      /* Try to find the matching \":while\" and report what's missing. */", "      for (idx = cstack->cs_idx; idx > 0; --idx) {", "        fl =  cstack->cs_flags[idx];"], "readability/increment"]
["src/nvim/ex_eval.c", ["        if ((fl & CSF_TRY) && !(fl & CSF_FINALLY)) {", "          /* Give up at a try conditional not in its finally clause.", "           * Ignore the \":endwhile\"/\":endfor\". */"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["        }", "        if (fl & csf)", "          break;"], "readability/braces"]
["src/nvim/ex_eval.c", ["      }", "      /* Cleanup and rewind all contained (and unclosed) conditionals. */", "      (void)cleanup_conditionals(cstack, CSF_WHILE | CSF_FOR, FALSE);"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      /* Cleanup and rewind all contained (and unclosed) conditionals. */", "      (void)cleanup_conditionals(cstack, CSF_WHILE | CSF_FOR, FALSE);", "      rewind_conditionals(cstack, idx, CSF_TRY, &cstack->cs_trylevel);"], "readability/bool"]
["src/nvim/ex_eval.c", ["    }", "    /*", "     * When debugging or a breakpoint was encountered, display the debug"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["     */", "    else if (cstack->cs_flags[cstack->cs_idx] & CSF_TRUE", "             && !(cstack->cs_flags[cstack->cs_idx] & CSF_ACTIVE)"], "whitespace/newline"]
["src/nvim/ex_eval.c", ["", "    /*", "     * Set loop flag, so do_cmdline() will jump back to the matching"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * \":throw expr\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * Throw the current exception through the specified cstack.  Common routine"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  int idx;", "  int inactivate_try = FALSE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  /*", "   * Cleanup and inactivate up to the next surrounding try conditional that"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  if (did_emsg && !THROW_ON_ERROR) {", "    inactivate_try = TRUE;", "    did_emsg = FALSE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    inactivate_try = TRUE;", "    did_emsg = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["  if (got_int && !THROW_ON_INTERRUPT) {", "    inactivate_try = TRUE;", "    got_int = FALSE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    inactivate_try = TRUE;", "    got_int = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["  if (idx >= 0) {", "    /*", "     * If this try conditional is active and we are before its first"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if (!(cstack->cs_flags[idx] & CSF_CAUGHT)) {", "      if (cstack->cs_flags[idx] & CSF_ACTIVE)", "        cstack->cs_flags[idx] |= CSF_THROWN;"], "readability/braces"]
["src/nvim/ex_eval.c", ["        cstack->cs_flags[idx] |= CSF_THROWN;", "      else", "        /* THROWN may have already been set for a catchable exception"], "readability/braces"]
["src/nvim/ex_eval.c", ["      else", "        /* THROWN may have already been set for a catchable exception", "         * that has been discarded.  Ensure it is reset for the new"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * \":try\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  if (cstack->cs_idx == CSTACK_LEN - 1)", "    eap->errmsg = (char_u *)N_(\"E601: :try nesting too deep\");"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E601: :try nesting too deep\");", "  else {", "    ++cstack->cs_idx;"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E601: :try nesting too deep\");", "  else {", "    ++cstack->cs_idx;"], "readability/braces"]
["src/nvim/ex_eval.c", ["  else {", "    ++cstack->cs_idx;", "    ++cstack->cs_trylevel;"], "readability/increment"]
["src/nvim/ex_eval.c", ["    ++cstack->cs_idx;", "    ++cstack->cs_trylevel;", "    cstack->cs_flags[cstack->cs_idx] = CSF_TRY;"], "readability/increment"]
["src/nvim/ex_eval.c", ["    if (!skip) {", "      /* Set ACTIVE and TRUE.  TRUE means that the corresponding \":catch\"", "       * commands should check for a match if an exception is thrown and"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * \":silent!\", even when used in a try conditional, disables"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    }", "", "  }"], "whitespace/blank_line"]
["src/nvim/ex_eval.c", ["", "/*", " * \":catch /{pattern}/\" and \":catch\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  int idx = 0;", "  int give_up = FALSE;", "  int skip = FALSE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["  int give_up = FALSE;", "  int skip = FALSE;", "  int caught = FALSE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["  int skip = FALSE;", "  int caught = FALSE;", "  char_u      *end;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E603: :catch without :try\");", "    give_up = TRUE;", "  } else {"], "readability/bool"]
["src/nvim/ex_eval.c", ["    if (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY)) {", "      /* Report what's missing if the matching \":try\" is not in its", "       * finally clause. */"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      eap->errmsg = get_end_emsg(cstack);", "      skip = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_eval.c", ["    }", "    for (idx = cstack->cs_idx; idx > 0; --idx)", "      if (cstack->cs_flags[idx] & CSF_TRY)"], "readability/braces"]
["src/nvim/ex_eval.c", ["    }", "    for (idx = cstack->cs_idx; idx > 0; --idx)", "      if (cstack->cs_flags[idx] & CSF_TRY)"], "readability/increment"]
["src/nvim/ex_eval.c", ["    for (idx = cstack->cs_idx; idx > 0; --idx)", "      if (cstack->cs_flags[idx] & CSF_TRY)", "        break;"], "readability/braces"]
["src/nvim/ex_eval.c", ["    if (cstack->cs_flags[idx] & CSF_FINALLY) {", "      /* Give up for a \":catch\" after \":finally\" and ignore it.", "       * Just parse. */"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      eap->errmsg = (char_u *)N_(\"E604: :catch after :finally\");", "      give_up = TRUE;", "    } else"], "readability/bool"]
["src/nvim/ex_eval.c", ["      give_up = TRUE;", "    } else", "      rewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,"], "readability/braces"]
["src/nvim/ex_eval.c", ["      rewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,", "          &cstack->cs_looplevel);", "  }"], "whitespace/alignment"]
["src/nvim/ex_eval.c", ["", "  if (ends_excmd(*eap->arg)) {  /* no argument, catch all errors */", "    pat = (char_u *)\".*\";"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    pat = eap->arg + 1;", "    end = skip_regexp(pat, *eap->arg, TRUE, NULL);", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["  if (!give_up) {", "    /*", "     * Don't do something when no exception has been thrown or when the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "    /*", "     * Check for a match only if an exception is thrown but not caught by"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /* When debugging or a breakpoint was encountered, display the", "       * debug prompt (if not already done) before checking for a match."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      if (!dbg_check_skipped(eap) || !do_intthrow(cstack)) {", "        /* Terminate the pattern and avoid the 'l' flag in 'cpoptions'", "         * while compiling it. */"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["          prev_got_int = got_int;", "          got_int = FALSE;", "          caught = vim_regexec_nl(&regmatch, current_exception->value,"], "readability/bool"]
["src/nvim/ex_eval.c", ["          caught = vim_regexec_nl(&regmatch, current_exception->value,", "              (colnr_T)0);", "          got_int |= prev_got_int;"], "whitespace/alignment"]
["src/nvim/ex_eval.c", ["    if (caught) {", "      /* Make this \":catch\" clause active and reset did_emsg and got_int.", "       * Put the exception on the caught stack. */"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      catch_exception((except_T *)cstack->cs_exception[idx]);", "      /* It's mandatory that the current exception is stored in the cstack", "       * so that it can be discarded at the next \":catch\", \":finally\", or"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    } else {", "      /*", "       * If there is a preceding catch clause and it caught the exception,"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["       */", "      cleanup_conditionals(cstack, CSF_TRY, TRUE);", "    }"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  if (end != NULL)", "    eap->nextcmd = find_nextcmd(end);"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "/*", " * \":finally\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  int idx;", "  int skip = FALSE;", "  int pending = CSTP_NONE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  if (cstack->cs_trylevel <= 0 || cstack->cs_idx < 0)", "    eap->errmsg = (char_u *)N_(\"E606: :finally without :try\");"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E606: :finally without :try\");", "  else {", "    if (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY)) {"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E606: :finally without :try\");", "  else {", "    if (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY)) {"], "readability/braces"]
["src/nvim/ex_eval.c", ["      eap->errmsg = get_end_emsg(cstack);", "      for (idx = cstack->cs_idx - 1; idx > 0; --idx)", "        if (cstack->cs_flags[idx] & CSF_TRY)"], "readability/braces"]
["src/nvim/ex_eval.c", ["      eap->errmsg = get_end_emsg(cstack);", "      for (idx = cstack->cs_idx - 1; idx > 0; --idx)", "        if (cstack->cs_flags[idx] & CSF_TRY)"], "readability/increment"]
["src/nvim/ex_eval.c", ["      for (idx = cstack->cs_idx - 1; idx > 0; --idx)", "        if (cstack->cs_flags[idx] & CSF_TRY)", "          break;"], "readability/braces"]
["src/nvim/ex_eval.c", ["          break;", "      /* Make this error pending, so that the commands in the following", "       * finally clause can be executed.  This overrules also a pending"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      pending = CSTP_ERROR;", "    } else", "      idx = cstack->cs_idx;"], "readability/braces"]
["src/nvim/ex_eval.c", ["    if (cstack->cs_flags[idx] & CSF_FINALLY) {", "      /* Give up for a multiple \":finally\" and ignore it. */", "      eap->errmsg = (char_u *)N_(\"E607: multiple :finally\");"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    rewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,", "        &cstack->cs_looplevel);", ""], "whitespace/alignment"]
["src/nvim/ex_eval.c", ["", "    /*", "     * Don't do something when the corresponding try block never got active"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if (!skip) {", "      /* When debugging or a breakpoint was encountered, display the", "       * debug prompt (if not already done).  The user then knows that the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      if (dbg_check_skipped(eap)) {", "        /* Handle a \">quit\" debug command as if an interrupt had", "         * occurred before the \":finally\".  That is, discard the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * If there is a preceding catch clause and it caught the exception,"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["       */", "      cleanup_conditionals(cstack, CSF_TRY, FALSE);", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["", "      /*", "       * Make did_emsg, got_int, current_exception pending.  If set, they"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["          report_discard_pending(CSTP_RETURN,", "              cstack->cs_rettv[cstack->cs_idx]);", "          discard_pending_return(cstack->cs_rettv[cstack->cs_idx]);"], "whitespace/alignment"]
["src/nvim/ex_eval.c", ["", "        /* It's mandatory that the current exception is stored in the", "         * cstack so that it can be rethrown at the \":endtry\" or be"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * Set CSL_HAD_FINA, so do_cmdline() will reset did_emsg,"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * \":endtry\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  int skip;", "  int rethrow = FALSE;", "  int pending = CSTP_NONE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["      eap->errmsg = get_end_emsg(cstack);", "      /* Find the matching \":try\" and report what's missing. */", "      idx = cstack->cs_idx;"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      do", "        --idx;", "      while (idx > 0 && !(cstack->cs_flags[idx] & CSF_TRY));"], "readability/increment"]
["src/nvim/ex_eval.c", ["        --idx;", "      while (idx > 0 && !(cstack->cs_flags[idx] & CSF_TRY));", "      rewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,"], "readability/braces"]
["src/nvim/ex_eval.c", ["        --idx;", "      while (idx > 0 && !(cstack->cs_flags[idx] & CSF_TRY));", "      rewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,"], "whitespace/empty_loop_body"]
["src/nvim/ex_eval.c", ["      rewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,", "          &cstack->cs_looplevel);", "      skip = TRUE;"], "whitespace/alignment"]
["src/nvim/ex_eval.c", ["          &cstack->cs_looplevel);", "      skip = TRUE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["", "      /*", "       * If an exception is being thrown, discard it to prevent it from"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * If we stopped with the exception currently being thrown at this"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "    /* If there was no finally clause, show the user when debugging or", "     * a breakpoint was encountered that the end of the try conditional has"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["        && dbg_check_skipped(eap)) {", "      /* Handle a \">quit\" debug command as if an interrupt had occurred", "       * before the \":endtry\".  That is, throw an interrupt exception and"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      if (got_int) {", "        skip = TRUE;", "        (void)do_intthrow(cstack);"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "    /*", "     * If a \":return\" is pending, we need to resume it after closing the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      cstack->cs_pending[idx] = CSTP_NONE;", "      if (pending == CSTP_RETURN)", "        rettv = cstack->cs_rettv[idx];"], "readability/braces"]
["src/nvim/ex_eval.c", ["        rettv = cstack->cs_rettv[idx];", "      else if (pending & CSTP_THROW)", "        current_exception = cstack->cs_exception[idx];"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "    /*", "     * Discard anything pending on an error, interrupt, or throw in the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["     */", "    (void)cleanup_conditionals(cstack, CSF_TRY | CSF_SILENT, TRUE);", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["", "    --cstack->cs_idx;", "    --cstack->cs_trylevel;"], "readability/increment"]
["src/nvim/ex_eval.c", ["    --cstack->cs_idx;", "    --cstack->cs_trylevel;", ""], "readability/increment"]
["src/nvim/ex_eval.c", ["      report_resume_pending(pending,", "          (pending == CSTP_RETURN) ? rettv :", "          (pending & CSTP_THROW) ? (void *)current_exception : NULL);"], "whitespace/alignment"]
["src/nvim/ex_eval.c", ["          (pending == CSTP_RETURN) ? rettv :", "          (pending & CSTP_THROW) ? (void *)current_exception : NULL);", "      switch (pending) {"], "whitespace/alignment"]
["src/nvim/ex_eval.c", ["", "      /* Reactivate a pending \":continue\", \":break\", \":return\",", "       * \":finish\" from the try block or a catch clause of this try"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      case CSTP_RETURN:", "        do_return(eap, FALSE, FALSE, rettv);", "        break;"], "readability/bool"]
["src/nvim/ex_eval.c", ["      case CSTP_FINISH:", "        do_finish(eap, FALSE);", "        break;"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "/*", " * enter_cleanup() and leave_cleanup()"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * This function works a bit like ex_finally() except that there was not"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  /*", "   * Postpone did_emsg, got_int, current_exception.  The pending values will be"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "    /* If we are currently throwing an exception, save it as well.  On an error", "     * not yet converted to an exception, update \"force_abort\" and reset"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["        force_abort |= cause_abort;", "        cause_abort = FALSE;", "      }"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "    /* Report if required by the 'verbose' option or when debugging.  */", "    report_make_pending(pending, csp->exception);"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * See comment above enter_cleanup() for how this function is used."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  if (pending == CSTP_NONE)     /* nothing to do */", "    return;"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  if (pending == CSTP_NONE)     /* nothing to do */", "    return;"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "  /* If there was an aborting error, an interrupt, or an uncaught exception", "   * after the corresponding call to enter_cleanup(), discard what has been"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "    /* If an error was about to be converted to an exception when", "     * enter_cleanup() was called, free the message list. */"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["     * enter_cleanup() was called, free the message list. */", "    if (msg_list != NULL)", "      free_global_msglist();"], "readability/braces"]
["src/nvim/ex_eval.c", ["  }", "  /*", "   * If there was no new error, interrupt, or throw between the calls"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["   */", "  else {", "    /*"], "whitespace/newline"]
["src/nvim/ex_eval.c", ["   */", "  else {", "    /*"], "readability/braces"]
["src/nvim/ex_eval.c", ["  else {", "    /*", "     * If there was an exception being thrown when enter_cleanup() was"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["     */", "    if (pending & CSTP_THROW)", "      current_exception = csp->exception;"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "    /*", "     * If an error was about to be converted to an exception when"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["     */", "    else if (pending & CSTP_ERROR) {", "      cause_abort = force_abort;"], "readability/braces"]
["src/nvim/ex_eval.c", ["      cause_abort = force_abort;", "      force_abort = FALSE;", "    }"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "/*", " * Make conditionals inactive and discard what's pending in finally clauses"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  int idx;", "  int stop = FALSE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  for (idx = cstack->cs_idx; idx >= 0; --idx) {", "    if (cstack->cs_flags[idx] & CSF_TRY) {"], "readability/increment"]
["src/nvim/ex_eval.c", ["    if (cstack->cs_flags[idx] & CSF_TRY) {", "      /*", "       * Discard anything pending in a finally clause and continue the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["          report_discard_pending(CSTP_RETURN,", "              cstack->cs_rettv[idx]);", "          discard_pending_return(cstack->cs_rettv[idx]);"], "whitespace/alignment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * Stop at a try conditional not in its finally clause.  If this try"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      if (!(cstack->cs_flags[idx] & CSF_FINALLY)) {", "        if ((cstack->cs_flags[idx] & CSF_ACTIVE)", "            && (cstack->cs_flags[idx] & CSF_CAUGHT))"], "readability/braces"]
["src/nvim/ex_eval.c", ["          finish_exception((except_T *)cstack->cs_exception[idx]);", "        /* Stop at this try conditional - except the try block never", "         * got active (because of an inactive surrounding conditional"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["        if (cstack->cs_flags[idx] & CSF_TRUE) {", "          if (searched_cond == 0 && !inclusive)", "            break;"], "readability/braces"]
["src/nvim/ex_eval.c", ["            break;", "          stop = TRUE;", "        }"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "    /* Stop on the searched conditional type (even when the surrounding", "     * conditional is not active or something has been made pending)."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if (cstack->cs_flags[idx] & searched_cond) {", "      if (!inclusive)", "        break;"], "readability/braces"]
["src/nvim/ex_eval.c", ["        break;", "      stop = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_eval.c", ["    cstack->cs_flags[idx] &= ~CSF_ACTIVE;", "    if (stop && searched_cond != (CSF_TRY | CSF_SILENT))", "      break;"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "    /*", "     * When leaving a try conditional that reset \"emsg_silent\" on its"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    }", "    if (stop)", "      break;"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "/*", " * Return an appropriate error message for a missing endwhile/endfor/endif."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["{", "  if (cstack->cs_flags[cstack->cs_idx] & CSF_WHILE)", "    return e_endwhile;"], "readability/braces"]
["src/nvim/ex_eval.c", ["    return e_endwhile;", "  if (cstack->cs_flags[cstack->cs_idx] & CSF_FOR)", "    return e_endfor;"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "/*", " * Rewind conditionals until index \"idx\" is reached.  \"cond_type\" and"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  while (cstack->cs_idx > idx) {", "    if (cstack->cs_flags[cstack->cs_idx] & cond_type)", "      --*cond_level;"], "readability/braces"]
["src/nvim/ex_eval.c", ["    if (cstack->cs_flags[cstack->cs_idx] & cond_type)", "      --*cond_level;", "    if (cstack->cs_flags[cstack->cs_idx] & CSF_FOR)"], "readability/increment"]
["src/nvim/ex_eval.c", ["      --*cond_level;", "    if (cstack->cs_flags[cstack->cs_idx] & CSF_FOR)", "      free_for_info(cstack->cs_forinfo[cstack->cs_idx]);"], "readability/braces"]
["src/nvim/ex_eval.c", ["      free_for_info(cstack->cs_forinfo[cstack->cs_idx]);", "    --cstack->cs_idx;", "  }"], "readability/increment"]
["src/nvim/ex_eval.c", ["", "/*", " * \":endfunction\" when not after a \":function\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * Return TRUE if the string \"p\" looks like a \":while\" or \":for\" command."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  /* skip modifiers, white space and ':' */", "  for (;; ) {"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  for (;; ) {", "    while (*p == ' ' || *p == '\\t' || *p == ':')", "      ++p;"], "readability/braces"]
["src/nvim/ex_eval.c", ["    while (*p == ' ' || *p == '\\t' || *p == ':')", "      ++p;", "    len = modifier_len(p);"], "readability/increment"]
["src/nvim/ex_eval.c", ["    len = modifier_len(p);", "    if (len == 0)", "      break;"], "readability/braces"]
["src/nvim/ex_eval.c", ["  }", "  if ((p[0] == 'w' && p[1] == 'h')", "      || (p[0] == 'f' && p[1] == 'o' && p[2] == 'r'))"], "readability/braces"]
["src/nvim/ex_eval.c", ["      || (p[0] == 'f' && p[1] == 'o' && p[2] == 'r'))", "    return TRUE;", "  return FALSE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    return TRUE;", "  return FALSE;", "}"], "readability/bool"]
