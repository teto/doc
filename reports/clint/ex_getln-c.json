["src/nvim/ex_getln.c", ["", "/*", " * ex_getln.c: Functions for entering and editing an Ex command line."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Variables shared between getcmdline(), redrawcmdline() and others."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/* The current cmdline_info.  It is initialized in getcmdline() and after that", " * used by other functions.  When invoking getcmdline() recursively it needs"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "static int cmd_showtail;                /* Only show path tail in lists ? */", ""], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "static int new_cmdpos;          /* position set by set_cmdline_pos() */", ""], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Type used by call_user_expand_func"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "static histentry_T *(history[HIST_COUNT]) = {NULL, NULL, NULL, NULL, NULL};", "static int hisidx[HIST_COUNT] = {-1, -1, -1, -1, -1};       /* lastused entry */"], "whitespace/braces"]
["src/nvim/ex_getln.c", ["", "static histentry_T *(history[HIST_COUNT]) = {NULL, NULL, NULL, NULL, NULL};", "static int hisidx[HIST_COUNT] = {-1, -1, -1, -1, -1};       /* lastused entry */"], "whitespace/braces"]
["src/nvim/ex_getln.c", ["static histentry_T *(history[HIST_COUNT]) = {NULL, NULL, NULL, NULL, NULL};", "static int hisidx[HIST_COUNT] = {-1, -1, -1, -1, -1};       /* lastused entry */", "static int hisnum[HIST_COUNT] = {0, 0, 0, 0, 0};"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["static histentry_T *(history[HIST_COUNT]) = {NULL, NULL, NULL, NULL, NULL};", "static int hisidx[HIST_COUNT] = {-1, -1, -1, -1, -1};       /* lastused entry */", "static int hisnum[HIST_COUNT] = {0, 0, 0, 0, 0};"], "whitespace/braces"]
["src/nvim/ex_getln.c", ["static histentry_T *(history[HIST_COUNT]) = {NULL, NULL, NULL, NULL, NULL};", "static int hisidx[HIST_COUNT] = {-1, -1, -1, -1, -1};       /* lastused entry */", "static int hisnum[HIST_COUNT] = {0, 0, 0, 0, 0};"], "whitespace/braces"]
["src/nvim/ex_getln.c", ["static int hisidx[HIST_COUNT] = {-1, -1, -1, -1, -1};       /* lastused entry */", "static int hisnum[HIST_COUNT] = {0, 0, 0, 0, 0};", "/* identifying (unique) number of newest history entry */"], "whitespace/braces"]
["src/nvim/ex_getln.c", ["static int hisidx[HIST_COUNT] = {-1, -1, -1, -1, -1};       /* lastused entry */", "static int hisnum[HIST_COUNT] = {0, 0, 0, 0, 0};", "/* identifying (unique) number of newest history entry */"], "whitespace/braces"]
["src/nvim/ex_getln.c", ["static int hisnum[HIST_COUNT] = {0, 0, 0, 0, 0};", "/* identifying (unique) number of newest history entry */", "static int hislen = 0;                  /* actual length of history tables */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["/* identifying (unique) number of newest history entry */", "static int hislen = 0;                  /* actual length of history tables */", ""], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      add_to_history(s->histype, ccline.cmdbuff, true,", "          s->histype == HIST_SEARCH ? s->firstc : NUL);", "      if (s->firstc == ':') {"], "whitespace/alignment"]
["src/nvim/ex_getln.c", ["    } else if (STRNCMP(s->xpc.xp_pattern, upseg + 1, 3) == 0", "        && s->c == K_DOWN) {", "      // If in a direct ancestor, strip off one ../ to go down"], "whitespace/alignment"]
["src/nvim/ex_getln.c", ["      || (s->c == ESC", "        && (!KeyTyped || vim_strchr(p_cpo, CPO_ESC) != NULL))) {", "    // In Ex mode a backslash escapes a newline."], "whitespace/alignment"]
["src/nvim/ex_getln.c", ["      || (s->c == ESC", "        && (!KeyTyped || vim_strchr(p_cpo, CPO_ESC) != NULL))) {", "    // In Ex mode a backslash escapes a newline."], "whitespace/alignment"]
["src/nvim/ex_getln.c", ["          (void)showmatches(&s->xpc, p_wmnu", "              && ((wim_flags[s->wim_index] & WIM_LIST) == 0));", "          redrawcmd();"], "whitespace/alignment"]
["src/nvim/ex_getln.c", ["    if (s->wim_index < 3) {", "      ++s->wim_index;", "    }"], "readability/increment"]
["src/nvim/ex_getln.c", ["    if (s->c == K_DEL && ccline.cmdpos != ccline.cmdlen) {", "      ++ccline.cmdpos;", "    }"], "readability/increment"]
["src/nvim/ex_getln.c", ["      ccline.cmdpos += mb_off_next(ccline.cmdbuff,", "          ccline.cmdbuff + ccline.cmdpos);", "    }"], "whitespace/alignment"]
["src/nvim/ex_getln.c", ["    }", "    --no_mapping;", "    // Insert the result of an expression."], "readability/increment"]
["src/nvim/ex_getln.c", ["  case Ctrl_A:            // all matches", "    if (nextwild(&s->xpc, WILD_ALL, 0, s->firstc != '@') == FAIL)", "      break;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      if (nextwild(&s->xpc, (s->c == Ctrl_P) ? WILD_PREV : WILD_NEXT,", "              0, s->firstc != '@') == FAIL) {", "        break;"], "whitespace/alignment"]
["src/nvim/ex_getln.c", ["                }", "                ++len;", "              }"], "readability/increment"]
["src/nvim/ex_getln.c", ["            }", "            ++len;", "          }"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "/*", " * getcmdline() - accept a command line starting with firstc."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["char_u *", "getcmdline (", "    int firstc,"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["", "/*", " * Return TRUE when the text must not be changed and we can't switch to"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", [" */", "int text_locked(void) {", "  if (cmdwin_type != 0)"], "readability/braces"]
["src/nvim/ex_getln.c", ["int text_locked(void) {", "  if (cmdwin_type != 0)", "    return TRUE;"], "readability/braces"]
["src/nvim/ex_getln.c", ["  if (cmdwin_type != 0)", "    return TRUE;", "  return textlock != 0;"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * Give an error message for a command that isn't allowed while the cmdline"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "char_u * get_text_locked_msg(void) {", "  if (cmdwin_type != 0) {"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Check if \"curbuf_lock\" or \"allbuf_lock\" is set and return TRUE when it is"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    EMSG(_(\"E788: Not allowed to edit another buffer now\"));", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * Check if \"allbuf_lock\" is set and return TRUE when it is and give an error"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    EMSG(_(\"E811: Not allowed to change buffer information now\"));", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_getln.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ex_getln.c", ["{", "  if (cmdline_star > 0)             /* showing '*', always 1 position */", "    return 1;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["{", "  if (cmdline_star > 0)             /* showing '*', always 1 position */", "    return 1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    m = Columns * Rows;", "    if (m < 0)          /* overflow, Columns or Rows at weird value */", "      m = MAXCOL;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    m = Columns * Rows;", "    if (m < 0)          /* overflow, Columns or Rows at weird value */", "      m = MAXCOL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Get an Ex command line for the \":\" command."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["{", "  /* When executing a register, remove ':' that's in front of each line. */", "  if (exec_from_reg && vpeekc() == ':')"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  /* When executing a register, remove ':' that's in front of each line. */", "  if (exec_from_reg && vpeekc() == ':')", "    (void)vgetc();"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Get an Ex command line for Ex mode."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  int c1 = 0;", "  int escaped = FALSE;                  /* CTRL-V typed */", "  int vcol = 0;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  int c1 = 0;", "  int escaped = FALSE;                  /* CTRL-V typed */", "  int vcol = 0;"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "  /* always start in column 0; write a newline if necessary */", "  compute_cmdrow();"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  compute_cmdrow();", "  if ((msg_col || msg_didout) && promptc != '?')", "    msg_putchar('\\n');"], "readability/braces"]
["src/nvim/ex_getln.c", ["  if (promptc == ':') {", "    /* indent that is only displayed, not in the line itself */", "    if (p_prompt)"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    /* indent that is only displayed, not in the line itself */", "    if (p_prompt)", "      msg_putchar(':');"], "readability/braces"]
["src/nvim/ex_getln.c", ["      msg_putchar(':');", "    while (indent-- > 0)", "      msg_putchar(' ');"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* autoindent for :insert and :append is in the line itself */", "  if (promptc <= 0) {"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  /*", "   * Get the line, one character at a time."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["   */", "  got_int = FALSE;", "  while (!got_int) {"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "    /* Get one character at a time.  Don't use inchar(), it can't handle", "     * special characters. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "    /*", "     * Handle line editing."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    if (!escaped) {", "      /* CR typed means \"enter\", which is NL */", "      if (c1 == '\\r')"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      /* CR typed means \"enter\", which is NL */", "      if (c1 == '\\r')", "        c1 = '\\n';"], "readability/braces"]
["src/nvim/ex_getln.c", ["        p[line_ga.ga_len] = NUL;", "        indent = get_indent_str(p, 8, FALSE);", "        num_spaces = sw - indent % sw;"], "readability/bool"]
["src/nvim/ex_getln.c", ["redraw:", "        /* redraw the line */", "        msg_col = startcol;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      if (c1 == Ctrl_D) {", "        /* Delete one shiftwidth. */", "        p = (char_u *)line_ga.ga_data;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["        if (prev_char == '0' || prev_char == '^') {", "          if (prev_char == '^')", "            ex_keep_indent = TRUE;"], "readability/braces"]
["src/nvim/ex_getln.c", ["          if (prev_char == '^')", "            ex_keep_indent = TRUE;", "          indent = 0;"], "readability/bool"]
["src/nvim/ex_getln.c", ["          p[line_ga.ga_len] = NUL;", "          indent = get_indent_str(p, 8, FALSE);", "          if (indent == 0) {"], "readability/bool"]
["src/nvim/ex_getln.c", ["          }", "          --indent;", "          indent -= indent % get_sw_value(curbuf);"], "readability/increment"]
["src/nvim/ex_getln.c", ["        int old_indent;", "        while ((old_indent = get_indent_str(p, 8, FALSE)) > indent) {", "          *--to = NUL;"], "readability/bool"]
["src/nvim/ex_getln.c", ["      if (c1 == Ctrl_V || c1 == Ctrl_Q) {", "        escaped = TRUE;", "        continue;"], "readability/bool"]
["src/nvim/ex_getln.c", ["    line_ga.ga_len += len;", "    escaped = FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["", "    /* We are done when a NL is entered, but not when it comes after an", "     * odd number of backslashes, that results in a NUL. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "      while (line_ga.ga_len - 2 >= bcount && pend[-2 - bcount] == '\\\\')", "        ++bcount;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      while (line_ga.ga_len - 2 >= bcount && pend[-2 - bcount] == '\\\\')", "        ++bcount;", ""], "readability/increment"]
["src/nvim/ex_getln.c", ["      if (bcount > 0) {", "        /* Halve the number of backslashes: \"\\NL\" -> \"NUL\", \"\\\\NL\" ->", "         * \"\\NL\", etc. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      if ((bcount & 1) == 0) {", "        --line_ga.ga_len;", "        --pend;"], "readability/increment"]
["src/nvim/ex_getln.c", ["        --line_ga.ga_len;", "        --pend;", "        *pend = NUL;"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "  /* make following messages go to the next line */", "  msg_didout = FALSE;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  /* make following messages go to the next line */", "  msg_didout = FALSE;", "  msg_col = 0;"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "  if (got_int)", "    ga_clear(&line_ga);"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Allocate a new command line buffer."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["{", "  /*", "   * give some extra space to avoid having to allocate all the time"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["   */", "  if (len < 80)", "    len = 100;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    len = 100;", "  else", "    len += 20;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Re-allocate the command line to length len + something extra."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  char_u *p = ccline.cmdbuff;", "  alloc_cmdbuff(len);                   /* will get some more */", "  /* There isn't always a NUL after the command, but it may need to be"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  alloc_cmdbuff(len);                   /* will get some more */", "  /* There isn't always a NUL after the command, but it may need to be", "   * there, thus copy up to the NUL and add a NUL. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "    /* If xp_pattern points inside the old cmdbuff it needs to be adjusted", "     * to point into the newly allocated memory. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["     * to point into the newly allocated memory. */", "    if (i >= 0 && i <= ccline.cmdlen)", "      ccline.xpc->xp_pattern = ccline.cmdbuff + i;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Draw part of the cmdline at the current cursor position.  But draw stars"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Put a character on the command line.  Shifts the following text to the"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Put the given string, of the given length, onto the command line."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (len < 0)", "    len = (int)STRLEN(str);"], "readability/braces"]
["src/nvim/ex_getln.c", ["    memmove(ccline.cmdbuff + ccline.cmdpos + len,", "        ccline.cmdbuff + ccline.cmdpos,", "        (size_t)(ccline.cmdlen - ccline.cmdpos));"], "whitespace/alignment"]
["src/nvim/ex_getln.c", ["        ccline.cmdbuff + ccline.cmdpos,", "        (size_t)(ccline.cmdlen - ccline.cmdpos));", "    ccline.cmdlen += len;"], "whitespace/alignment"]
["src/nvim/ex_getln.c", ["        len += i;", "      } else", "        i = 0;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    if (i != 0) {", "      /* Also backup the cursor position. */", "      i = ptr2cells(ccline.cmdbuff + ccline.cmdpos);"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["        msg_col += Columns;", "        --msg_row;", "      }"], "readability/increment"]
["src/nvim/ex_getln.c", ["  if (redraw && !cmd_silent) {", "    msg_no_more = TRUE;", "    i = cmdline_row;"], "readability/bool"]
["src/nvim/ex_getln.c", ["    draw_cmdline(ccline.cmdpos, ccline.cmdlen - ccline.cmdpos);", "    /* Avoid clearing the rest of the line too often. */", "    if (cmdline_row != i || ccline.overstrike)"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    /* Avoid clearing the rest of the line too often. */", "    if (cmdline_row != i || ccline.overstrike)", "      msg_clr_eos();"], "readability/braces"]
["src/nvim/ex_getln.c", ["      msg_clr_eos();", "    msg_no_more = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * Save ccline, because obtaining the \"=\" register may execute \"normal :cmd\""], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Restore ccline after it has been saved with save_cmdline()."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Save the command line into allocated memory.  Returns a pointer to be"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Restore the command line from the return value of save_cmdline_alloc()."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  /* check for valid regname; also accept special characters for CTRL-R in", "   * the command line */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  /* A register containing CTRL-R can cause an endless loop.  Allow using", "   * CTRL-C to break the loop. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  line_breakcheck();", "  if (got_int)", "    return FAIL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* Need to save and restore ccline.  And set \"textlock\" to avoid nasty", "   * things like going to another buffer when evaluating an expression. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  if (i) {", "    /* Got the value of a special register in \"arg\". */", "    if (arg == NULL)"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    /* Got the value of a special register in \"arg\". */", "    if (arg == NULL)", "      return FAIL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "    /* When 'incsearch' is set and CTRL-R CTRL-W used: skip the duplicate", "     * part of the word. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "      /* Locate start of last word in the cmd buffer. */", "      for (w = ccline.cmdbuff + ccline.cmdpos; w > ccline.cmdbuff; ) {"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      len = (int)((ccline.cmdbuff + ccline.cmdpos) - w);", "      if (p_ic ? STRNICMP(w, arg, len) == 0 : STRNCMP(w, arg, len) == 0)", "        p += len;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    cmdline_paste_str(p, literally);", "    if (allocated)", "      xfree(arg);"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Put a string on the command line."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (literally)", "    put_on_cmdline(s, -1, TRUE);"], "readability/braces"]
["src/nvim/ex_getln.c", ["  if (literally)", "    put_on_cmdline(s, -1, TRUE);", "  else"], "readability/bool"]
["src/nvim/ex_getln.c", ["    put_on_cmdline(s, -1, TRUE);", "  else", "    while (*s != NUL) {"], "readability/braces"]
["src/nvim/ex_getln.c", ["{", "  if (cmd_silent)", "    return;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    return;", "  need_wait_return = FALSE;", "  compute_cmdrow();"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "  if (cmd_silent)", "    return;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Redraw what is currently on the command line."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["{", "  if (cmd_silent)", "    return;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* when 'incsearch' is set there may be no command line while redrawing */", "  if (ccline.cmdbuff == NULL) {"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  /* Don't use more prompt, truncate the cmdline if it doesn't fit. */", "  msg_no_more = TRUE;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  /* Don't use more prompt, truncate the cmdline if it doesn't fit. */", "  msg_no_more = TRUE;", "  draw_cmdline(0, ccline.cmdlen);"], "readability/bool"]
["src/nvim/ex_getln.c", ["  msg_clr_eos();", "  msg_no_more = FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["", "  /*", "   * An emsg() before may have set msg_scroll. This is used in normal mode,"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["   */", "  msg_scroll = FALSE;           /* next message overwrites cmdline */", ""], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["   */", "  msg_scroll = FALSE;           /* next message overwrites cmdline */", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["{", "  if (cmd_silent)", "    return;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Check the word in front of the cursor for an abbreviation."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (*p1 != '<' && *p2 == '<') return -1;", "  if (*p1 == '<' && *p2 != '<') return 1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["  if (*p1 != '<' && *p2 == '<') return -1;", "  if (*p1 == '<' && *p2 != '<') return 1;", "  return STRCMP(p1, p2);"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Return FAIL if this is not an appropriate context in which to do"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", [" */", "static int ", "nextwild ("], "whitespace/end_of_line"]
["src/nvim/ex_getln.c", ["static int ", "nextwild (", "    expand_T *xp,"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["    int type,", "    int options,                    /* extra options for ExpandOne() */", "    int escape                     /* if TRUE, escape the returned matches */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    int options,                    /* extra options for ExpandOne() */", "    int escape                     /* if TRUE, escape the returned matches */", ")"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    beep_flush();", "    return OK;      /* Something illegal on command line */", "  }"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  if (xp->xp_context == EXPAND_NOTHING) {", "    /* Caller can use the character as a normal char instead */", "    return FAIL;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  /* When expanding a \":map\" command and no matches are found, assume that", "   * the key is supposed to be inserted literally */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["   * the key is supposed to be inserted literally */", "  if (xp->xp_context == EXPAND_MAPPINGS && p2 == NULL)", "    return FAIL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  if (xp->xp_numfiles <= 0 && p2 == NULL)", "    beep_flush();"], "readability/braces"]
["src/nvim/ex_getln.c", ["    beep_flush();", "  else if (xp->xp_numfiles == 1)", "    /* free expanded pattern */"], "readability/braces"]
["src/nvim/ex_getln.c", ["  else if (xp->xp_numfiles == 1)", "    /* free expanded pattern */", "    (void)ExpandOne(xp, NULL, NULL, 0, WILD_FREE);"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Do wildcard expansion on the string 'str'."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["char_u *", "ExpandOne (", "    expand_T *xp,"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["    char_u *str,", "    char_u *orig,          /* allocated copy of original of expanded string */", "    int options,"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  static int findex;", "  static char_u *orig_save = NULL;      /* kept value of orig */", "  int orig_saved = FALSE;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  static char_u *orig_save = NULL;      /* kept value of orig */", "  int orig_saved = FALSE;", "  int i;"], "readability/bool"]
["src/nvim/ex_getln.c", ["  int i;", "  int non_suf_match;                    /* number without matching suffix */", ""], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  /*", "   * first handle the case of using an old match"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      if (mode == WILD_PREV) {", "        if (findex == -1)", "          findex = xp->xp_numfiles;"], "readability/braces"]
["src/nvim/ex_getln.c", ["          findex = xp->xp_numfiles;", "        --findex;", "      } else        /* mode == WILD_NEXT */"], "readability/increment"]
["src/nvim/ex_getln.c", ["        --findex;", "      } else        /* mode == WILD_NEXT */", "        ++findex;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["        --findex;", "      } else        /* mode == WILD_NEXT */", "        ++findex;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      } else        /* mode == WILD_NEXT */", "        ++findex;", ""], "readability/increment"]
["src/nvim/ex_getln.c", ["", "      /*", "       * When wrapping around, return the original string, set findex to"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      if (findex < 0) {", "        if (orig_save == NULL)", "          findex = xp->xp_numfiles - 1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["          findex = xp->xp_numfiles - 1;", "        else", "          findex = -1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      if (findex >= xp->xp_numfiles) {", "        if (orig_save == NULL)", "          findex = 0;"], "readability/braces"]
["src/nvim/ex_getln.c", ["          findex = 0;", "        else", "          findex = -1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      return vim_strsave(xp->xp_files[findex]);", "    } else", "      return NULL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* free old names */", "  if (xp->xp_numfiles != -1 && mode != WILD_ALL && mode != WILD_LONGEST) {"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (mode == WILD_FREE)        /* only release file name */", "    return NULL;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (mode == WILD_FREE)        /* only release file name */", "    return NULL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    orig_save = orig;", "    orig_saved = TRUE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["", "    /*", "     * Do the expansion."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    if (ExpandFromContext(xp, str, &xp->xp_numfiles, &xp->xp_files,", "            options) == FAIL) {", "#ifdef FNAME_ILLEGAL"], "whitespace/alignment"]
["src/nvim/ex_getln.c", ["#ifdef FNAME_ILLEGAL", "      /* Illegal file name has been silently skipped.  But when there", "       * are wildcards, the real problem is that there was no match,"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["       */", "      if (!(options & WILD_SILENT) && (options & WILD_LIST_NOTFOUND))", "        EMSG2(_(e_nomatch2), str);"], "readability/braces"]
["src/nvim/ex_getln.c", ["    } else if (xp->xp_numfiles == 0) {", "      if (!(options & WILD_SILENT))", "        EMSG2(_(e_nomatch2), str);"], "readability/braces"]
["src/nvim/ex_getln.c", ["    } else {", "      /* Escape the matches for use on the command line. */", "      ExpandEscape(xp, str, xp->xp_numfiles, xp->xp_files, options);"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "      /*", "       * Check for matching suffixes in file names."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["          && mode != WILD_LONGEST) {", "        if (xp->xp_numfiles)", "          non_suf_match = xp->xp_numfiles;"], "readability/braces"]
["src/nvim/ex_getln.c", ["          non_suf_match = xp->xp_numfiles;", "        else", "          non_suf_match = 1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["            && xp->xp_numfiles > 1) {", "          /*", "           * More than one match; check suffix."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["          non_suf_match = 0;", "          for (i = 0; i < 2; ++i)", "            if (match_suffix(xp->xp_files[i]))"], "readability/braces"]
["src/nvim/ex_getln.c", ["          non_suf_match = 0;", "          for (i = 0; i < 2; ++i)", "            if (match_suffix(xp->xp_files[i]))"], "readability/increment"]
["src/nvim/ex_getln.c", ["          for (i = 0; i < 2; ++i)", "            if (match_suffix(xp->xp_files[i]))", "              ++non_suf_match;"], "readability/braces"]
["src/nvim/ex_getln.c", ["            if (match_suffix(xp->xp_files[i]))", "              ++non_suf_match;", "        }"], "readability/increment"]
["src/nvim/ex_getln.c", ["        if (non_suf_match != 1) {", "          /* Can we ever get here unless it's while expanding", "           * interactively?  If not, we can get rid of this all"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["           */", "          if (!(options & WILD_SILENT))", "            EMSG(_(e_toomany));"], "readability/braces"]
["src/nvim/ex_getln.c", ["            EMSG(_(e_toomany));", "          else if (!(options & WILD_NO_BEEP))", "            beep_flush();"], "readability/braces"]
["src/nvim/ex_getln.c", ["        }", "        if (!(non_suf_match != 1 && mode == WILD_EXPAND_FREE))", "          ss = vim_strsave(xp->xp_files[0]);"], "readability/braces"]
["src/nvim/ex_getln.c", ["    size_t len = 0;", "    for (i = 0; i < xp->xp_numfiles; ++i)", "      len += STRLEN(xp->xp_files[i]) + 1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    size_t len = 0;", "    for (i = 0; i < xp->xp_numfiles; ++i)", "      len += STRLEN(xp->xp_files[i]) + 1;"], "readability/increment"]
["src/nvim/ex_getln.c", ["    *ss = NUL;", "    for (i = 0; i < xp->xp_numfiles; ++i) {", "      STRCAT(ss, xp->xp_files[i]);"], "readability/increment"]
["src/nvim/ex_getln.c", ["      STRCAT(ss, xp->xp_files[i]);", "      if (i != xp->xp_numfiles - 1)", "        STRCAT(ss, (options & WILD_USE_NL) ? \"\\n\" : \" \");"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  if (mode == WILD_EXPAND_FREE || mode == WILD_ALL)", "    ExpandCleanup(xp);"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* Free \"orig\" if it wasn't stored in \"orig_save\". */", "  if (!orig_saved)"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  /* Free \"orig\" if it wasn't stored in \"orig_save\". */", "  if (!orig_saved)", "    xfree(orig);"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Prepare an expand structure for use."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Cleanup an expand structure after use."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "void ExpandEscape(expand_T *xp, char_u *str, int numfiles, char_u **files, int options)", "{"], "whitespace/line_length"]
["src/nvim/ex_getln.c", ["", "  /*", "   * May change home directory back to \"~\""], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["   */", "  if (options & WILD_HOME_REPLACE)", "    tilde_replace(str, numfiles, files);"], "readability/braces"]
["src/nvim/ex_getln.c", ["        || xp->xp_context == EXPAND_DIRECTORIES) {", "      /*", "       * Insert a backslash into a file name before a space, \\, %, #"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["       */", "      for (i = 0; i < numfiles; ++i) {", "        /* for \":set path=\" we need to escape spaces twice */"], "readability/increment"]
["src/nvim/ex_getln.c", ["      for (i = 0; i < numfiles; ++i) {", "        /* for \":set path=\" we need to escape spaces twice */", "        if (xp->xp_backslash == XP_BS_THREE) {"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "        /* If 'str' starts with \"\\~\", replace \"~\" at start of", "         * files[i] with \"\\~\". */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["         * files[i] with \"\\~\". */", "        if (str[0] == '\\\\' && str[1] == '~' && files[i][0] == '~')", "          escape_fname(&files[i]);"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "      /* If the first file starts with a '+' escape it.  Otherwise it", "       * could be seen as \"+cmd\". */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["       * could be seen as \"+cmd\". */", "      if (*files[0] == '+')", "        escape_fname(&files[0]);"], "readability/braces"]
["src/nvim/ex_getln.c", ["    } else if (xp->xp_context == EXPAND_TAGS) {", "      /*", "       * Insert a backslash before characters in a tag name that"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["       */", "      for (i = 0; i < numfiles; ++i) {", "        p = vim_strsave_escaped(files[i], (char_u *)\"\\\\|\\\"\");"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "/*", " * Put a backslash before the file name in \"pp\", which is in allocated memory."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * For each file name in files[num_files]:"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  if (orig_pat[0] == '~' && vim_ispathsep(orig_pat[1])) {", "    for (i = 0; i < num_files; ++i) {", "      p = home_replace_save(NULL, files[i]);"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "/*", " * Show all matches for completion on the command line."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    i = expand_cmdline(xp, ccline.cmdbuff, ccline.cmdpos,", "        &num_files, &files_found);", "    showtail = expand_showtail(xp);"], "whitespace/alignment"]
["src/nvim/ex_getln.c", ["    showtail = expand_showtail(xp);", "    if (i != EXPAND_OK)", "      return i;"], "readability/braces"]
["src/nvim/ex_getln.c", ["  if (!wildmenu) {", "    msg_didany = FALSE;                 /* lines_left will be set */", "    msg_start();                        /* prepare for paging */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  if (!wildmenu) {", "    msg_didany = FALSE;                 /* lines_left will be set */", "    msg_start();                        /* prepare for paging */"], "readability/bool"]
["src/nvim/ex_getln.c", ["    msg_didany = FALSE;                 /* lines_left will be set */", "    msg_start();                        /* prepare for paging */", "    msg_putchar('\\n');"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    cmdline_row = msg_row;", "    msg_didany = FALSE;                 /* lines_left will be set again */", "    msg_start();                        /* prepare for paging */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    cmdline_row = msg_row;", "    msg_didany = FALSE;                 /* lines_left will be set again */", "    msg_start();                        /* prepare for paging */"], "readability/bool"]
["src/nvim/ex_getln.c", ["    msg_didany = FALSE;                 /* lines_left will be set again */", "    msg_start();                        /* prepare for paging */", "  }"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    maxlen = 0;", "    for (i = 0; i < num_files; ++i) {", "      if (!showtail && (xp->xp_context == EXPAND_FILES"], "readability/increment"]
["src/nvim/ex_getln.c", ["                        || xp->xp_context == EXPAND_BUFFERS)) {", "        home_replace(NULL, files_found[i], NameBuff, MAXPATHL, TRUE);", "        j = vim_strsize(NameBuff);"], "readability/bool"]
["src/nvim/ex_getln.c", ["        j = vim_strsize(NameBuff);", "      } else", "        j = vim_strsize(L_SHOWFILE(i));"], "readability/braces"]
["src/nvim/ex_getln.c", ["        j = vim_strsize(L_SHOWFILE(i));", "      if (j > maxlen)", "        maxlen = j;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "    /* list the files line by line */", "    for (i = 0; i < lines; ++i) {"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    /* list the files line by line */", "    for (i = 0; i < lines; ++i) {", "      lastlen = 999;"], "readability/increment"]
["src/nvim/ex_getln.c", ["        }", "        for (j = maxlen - lastlen; --j >= 0; )", "          msg_putchar(' ');"], "readability/braces"]
["src/nvim/ex_getln.c", ["            || xp->xp_context == EXPAND_BUFFERS) {", "          /* highlight directories */", "          if (xp->xp_numfiles != -1) {"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["            home_replace(NULL, files_found[k], NameBuff, MAXPATHL,", "                TRUE);", "            p = NameBuff;"], "whitespace/alignment"]
["src/nvim/ex_getln.c", ["            home_replace(NULL, files_found[k], NameBuff, MAXPATHL,", "                TRUE);", "            p = NameBuff;"], "readability/bool"]
["src/nvim/ex_getln.c", ["        } else {", "          j = FALSE;", "          p = L_SHOWFILE(k);"], "readability/bool"]
["src/nvim/ex_getln.c", ["      }", "      if (msg_col > 0) {        /* when not wrapped around */", "        msg_clr_eos();"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      }", "      ui_flush();                          /* show one line at a time */", "      if (got_int) {"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      if (got_int) {", "        got_int = FALSE;", "        break;"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "    /*", "     * we redraw the command below the lines that we have just listed"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["     */", "    cmdline_row = msg_row;      /* will put it back later */", "  }"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (xp->xp_numfiles == -1)", "    FreeWild(num_files, files_found);"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Private path_tail for showmatches() (and win_redr_status_matches()):"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  char_u      *t = s;", "  int had_sep = FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["      t = p;", "      had_sep = FALSE;", "    }"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * Return TRUE if we only need to show the tail of completion matches."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  /* When not completing file names a \"/\" may mean something different. */", "  if (xp->xp_context != EXPAND_FILES"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  /* When not completing file names a \"/\" may mean something different. */", "  if (xp->xp_context != EXPAND_FILES", "      && xp->xp_context != EXPAND_SHELLCMD"], "readability/braces"]
["src/nvim/ex_getln.c", ["      && xp->xp_context != EXPAND_DIRECTORIES)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["  end = path_tail(xp->xp_pattern);", "  if (end == xp->xp_pattern)            /* there is no path separator */", "    return FALSE;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  end = path_tail(xp->xp_pattern);", "  if (end == xp->xp_pattern)            /* there is no path separator */", "    return FALSE;"], "readability/braces"]
["src/nvim/ex_getln.c", ["  if (end == xp->xp_pattern)            /* there is no path separator */", "    return FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["  for (s = xp->xp_pattern; s < end; s++) {", "    /* Skip escaped wildcards.  Only when the backslash is not a path", "    * separator, on DOS the '*' \"path\\*\\file\" must not be skipped. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    * separator, on DOS the '*' \"path\\*\\file\" must not be skipped. */", "    if (rem_backslash(s))", "      ++s;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    if (rem_backslash(s))", "      ++s;", "    else if (vim_strchr((char_u *)\"*?[\", *s) != NULL)"], "readability/increment"]
["src/nvim/ex_getln.c", ["      ++s;", "    else if (vim_strchr((char_u *)\"*?[\", *s) != NULL)", "      return FALSE;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    else if (vim_strchr((char_u *)\"*?[\", *s) != NULL)", "      return FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_getln.c", ["  }", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/ex_getln.c", ["      && context != EXPAND_DIRECTORIES) {", "    /*", "     * Matching will be done internally (on something other than files)."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      for (i = 0; i < len; i++) {", "        if (fname[i] == '*' || fname[i] == '~')", "          new_len++;                    /* '*' needs to be replaced by \".*\""], "readability/braces"]
["src/nvim/ex_getln.c", ["        if (fname[i] == '*' || fname[i] == '~')", "          new_len++;                    /* '*' needs to be replaced by \".*\"", "                                           '~' needs to be replaced by \"\\~\" */"], "readability/multiline_comment"]
["src/nvim/ex_getln.c", ["        if (fname[i] == '*' || fname[i] == '~')", "          new_len++;                    /* '*' needs to be replaced by \".*\"", "                                           '~' needs to be replaced by \"\\~\" */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "        /* Buffer names are like file names.  \".\" should be literal */", "        if (context == EXPAND_BUFFERS && fname[i] == '.')"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["        /* Buffer names are like file names.  \".\" should be literal */", "        if (context == EXPAND_BUFFERS && fname[i] == '.')", "          new_len++;                    /* \".\" becomes \"\\.\" */"], "readability/braces"]
["src/nvim/ex_getln.c", ["        if (context == EXPAND_BUFFERS && fname[i] == '.')", "          new_len++;                    /* \".\" becomes \"\\.\" */", ""], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "        /* Custom expansion takes care of special things, match", "         * backslashes literally (perhaps also for other types?) */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["         * backslashes literally (perhaps also for other types?) */", "        if ((context == EXPAND_USER_DEFINED", "             || context == EXPAND_USER_LIST) && fname[i] == '\\\\')"], "readability/braces"]
["src/nvim/ex_getln.c", ["             || context == EXPAND_USER_LIST) && fname[i] == '\\\\')", "          new_len++;                    /* '\\' becomes \"\\\\\" */", "      }"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["        for (i = 0; i < len; i++, j++) {", "          /* Skip backslash.  But why?  At least keep it for custom", "           * expansion. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["           * expansion. */", "          if (context != EXPAND_USER_DEFINED", "              && context != EXPAND_USER_LIST"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "    /*", "     * Don't add a star to *, ~, ~user, $var or `cmd`."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["#endif", "    if ((*retval != '~' || tail != retval)", "        && !ends_in_star"], "readability/braces"]
["src/nvim/ex_getln.c", ["      retval[len++] = '*';", "    else if (len > 0 && retval[len - 1] == '$')", "      --len;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    else if (len > 0 && retval[len - 1] == '$')", "      --len;", "    retval[len] = NUL;"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "/*", " * Must parse the command line so far to work out what context we are in."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["{", "  /* only expansion for ':', '>' and '=' command-lines */", "  if (ccline.cmdfirstc != ':'"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "void ", "set_cmd_context ("], "whitespace/end_of_line"]
["src/nvim/ex_getln.c", ["void ", "set_cmd_context (", "    expand_T *xp,"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["", "  /*", "   * Avoid a UMR warning from Purify, only save the character if it has been"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["   */", "  if (col < len)", "    old_char = str[col];"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* Store the string here so that call_user_expand_func() can get to them", "   * easily. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Expand the command line \"str\" from context \"xp\"."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", [" */", "int ", "expand_cmdline ("], "whitespace/end_of_line"]
["src/nvim/ex_getln.c", ["int ", "expand_cmdline (", "    expand_T *xp,"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["    expand_T *xp,", "    char_u *str,               /* start of command line */", "    int col,                        /* position of cursor */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    char_u *str,               /* start of command line */", "    int col,                        /* position of cursor */", "    int *matchcount,        /* return: nr of matches */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    int col,                        /* position of cursor */", "    int *matchcount,        /* return: nr of matches */", "    char_u ***matches         /* return: array of pointers to matches */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    int *matchcount,        /* return: nr of matches */", "    char_u ***matches         /* return: array of pointers to matches */", ")"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    beep_flush();", "    return EXPAND_UNSUCCESSFUL;      /* Something illegal on command line */", "  }"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  if (xp->xp_context == EXPAND_NOTHING) {", "    /* Caller can use the character as a normal char instead */", "    return EXPAND_NOTHING;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (p_wic)", "    options += WILD_ICASE;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* find all files that match the description */", "  if (ExpandFromContext(xp, file_str, matchcount, matches, options) == FAIL) {"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Do the expansion based on xp->xp_context and \"pat\"."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", [" */", "static int ", "ExpandFromContext ("], "whitespace/end_of_line"]
["src/nvim/ex_getln.c", ["static int ", "ExpandFromContext (", "    expand_T *xp,"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["", "  flags = EW_DIR;       /* include directories */", "  if (options & WILD_LIST_NOTFOUND)"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  flags = EW_DIR;       /* include directories */", "  if (options & WILD_LIST_NOTFOUND)", "    flags |= EW_NOTFOUND;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    flags |= EW_NOTFOUND;", "  if (options & WILD_ADD_SLASH)", "    flags |= EW_ADDSLASH;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    flags |= EW_ADDSLASH;", "  if (options & WILD_KEEP_ALL)", "    flags |= EW_KEEPALL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    flags |= EW_KEEPALL;", "  if (options & WILD_SILENT)", "    flags |= EW_SILENT;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      || xp->xp_context == EXPAND_FILES_IN_PATH) {", "    /*", "     * Expand file or directory names."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["     */", "    int free_pat = FALSE;", "    int i;"], "readability/bool"]
["src/nvim/ex_getln.c", ["    if (xp->xp_backslash != XP_BS_NONE) {", "      free_pat = TRUE;", "      pat = vim_strsave(pat);"], "readability/bool"]
["src/nvim/ex_getln.c", ["      pat = vim_strsave(pat);", "      for (i = 0; pat[i]; ++i)", "        if (pat[i] == '\\\\') {"], "readability/braces"]
["src/nvim/ex_getln.c", ["      pat = vim_strsave(pat);", "      for (i = 0; pat[i]; ++i)", "        if (pat[i] == '\\\\') {"], "readability/increment"]
["src/nvim/ex_getln.c", ["        if (pat[i] == '\\\\') {", "          if (xp->xp_backslash == XP_BS_THREE", "              && pat[i + 1] == '\\\\'"], "readability/braces"]
["src/nvim/ex_getln.c", ["            STRMOVE(pat + i, pat + i + 3);", "          if (xp->xp_backslash == XP_BS_ONE", "              && pat[i + 1] == ' ')"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "    if (xp->xp_context == EXPAND_FILES)", "      flags |= EW_FILE;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      flags |= EW_FILE;", "    else if (xp->xp_context == EXPAND_FILES_IN_PATH)", "      flags |= (EW_FILE | EW_PATH);"], "readability/braces"]
["src/nvim/ex_getln.c", ["      flags |= (EW_FILE | EW_PATH);", "    else", "      flags = (flags | EW_DIR) & ~EW_FILE;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      flags = (flags | EW_DIR) & ~EW_FILE;", "    if (options & WILD_ICASE)", "      flags |= EW_ICASE;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "    /* Expand wildcards, supporting %:h and the like. */", "    ret = expand_wildcards_eval(&pat, num_file, file, flags);"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    ret = expand_wildcards_eval(&pat, num_file, file, flags);", "    if (free_pat)", "      xfree(pat);"], "readability/braces"]
["src/nvim/ex_getln.c", ["  if (xp->xp_context == EXPAND_HELP) {", "    /* With an empty argument we would get all the help tags, which is", "     * very slow.  Get matches for \"help\" instead. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  }", "  if (xp->xp_context == EXPAND_BUFFERS)", "    return ExpandBufnames(pat, num_file, file, options);"], "readability/braces"]
["src/nvim/ex_getln.c", ["  regmatch.regprog = vim_regcomp(pat, p_magic ? RE_MAGIC : 0);", "  if (regmatch.regprog == NULL)", "    return FAIL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* set ignore-case according to p_ic, p_scs and pat */", "  regmatch.rm_ic = ignorecase(pat);"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (xp->xp_context == EXPAND_SETTINGS", "      || xp->xp_context == EXPAND_BOOL_SETTINGS)"], "readability/braces"]
["src/nvim/ex_getln.c", ["    ret = ExpandSettings(xp, &regmatch, num_file, file);", "  else if (xp->xp_context == EXPAND_MAPPINGS)", "    ret = ExpandMappings(&regmatch, num_file, file);"], "readability/braces"]
["src/nvim/ex_getln.c", ["    ret = ExpandMappings(&regmatch, num_file, file);", "  else if (xp->xp_context == EXPAND_USER_DEFINED)", "    ret = ExpandUserDefined(xp, &regmatch, num_file, file);"], "readability/braces"]
["src/nvim/ex_getln.c", ["    ret = ExpandUserDefined(xp, &regmatch, num_file, file);", "  else {", "    static struct expgen {"], "readability/braces"]
["src/nvim/ex_getln.c", ["    ret = ExpandUserDefined(xp, &regmatch, num_file, file);", "  else {", "    static struct expgen {"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "    /*", "     * Find a context in the table and call the ExpandGeneric() with the"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    ret = FAIL;", "    for (i = 0; i < (int)ARRAY_SIZE(tab); ++i)", "      if (xp->xp_context == tab[i].context) {"], "readability/braces"]
["src/nvim/ex_getln.c", ["    ret = FAIL;", "    for (i = 0; i < (int)ARRAY_SIZE(tab); ++i)", "      if (xp->xp_context == tab[i].context) {"], "readability/increment"]
["src/nvim/ex_getln.c", ["        if (tab[i].ic) {", "          regmatch.rm_ic = TRUE;", "        }"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * Expand a list of names."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    int escaped", "    )", "{"], "whitespace/indent"]
["src/nvim/ex_getln.c", ["    char_u      ***file,", "    CompleteListItemGetter func, /* returns a string from the list */", "    int escaped"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  // count the number of matching names", "  for (i = 0;; ++i) {", "    str = (*func)(xp, i);"], "readability/increment"]
["src/nvim/ex_getln.c", ["    str = (*func)(xp, i);", "    if (str == NULL) // end of list", "      break;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    str = (*func)(xp, i);", "    if (str == NULL) // end of list", "      break;"], "whitespace/comments"]
["src/nvim/ex_getln.c", ["      break;", "    if (*str == NUL) // skip empty strings", "      continue;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      break;", "    if (*str == NUL) // skip empty strings", "      continue;"], "whitespace/comments"]
["src/nvim/ex_getln.c", ["    if (vim_regexec(regmatch, str, (colnr_T)0)) {", "      ++count;", "    }"], "readability/increment"]
["src/nvim/ex_getln.c", ["  }", "  if (count == 0)", "    return;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* Sort the results.  Keep menu's in the specified order. */", "  if (xp->xp_context != EXPAND_MENUNAMES && xp->xp_context != EXPAND_MENUS) {"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  if (xp->xp_context != EXPAND_MENUNAMES && xp->xp_context != EXPAND_MENUS) {", "    if (xp->xp_context == EXPAND_EXPRESSION", "        || xp->xp_context == EXPAND_FUNCTIONS"], "readability/braces"]
["src/nvim/ex_getln.c", ["        || xp->xp_context == EXPAND_USER_FUNC)", "      /* <SNR> functions should be sorted to the end. */", "      qsort((void *)*file, (size_t)*num_file, sizeof(char_u *),"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      /* <SNR> functions should be sorted to the end. */", "      qsort((void *)*file, (size_t)*num_file, sizeof(char_u *),", "          sort_func_compare);"], "whitespace/operators"]
["src/nvim/ex_getln.c", ["      qsort((void *)*file, (size_t)*num_file, sizeof(char_u *),", "          sort_func_compare);", "    else"], "whitespace/alignment"]
["src/nvim/ex_getln.c", ["          sort_func_compare);", "    else", "      sort_strings(*file, *num_file);"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* Reset the variables used for special highlight names expansion, so that", "   * they don't show up when getting normal highlight names by ID. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  pat = vim_strsave(filepat);", "  for (i = 0; pat[i]; ++i)", "    if (pat[i] == '\\\\' && pat[i + 1] == ' ')"], "readability/braces"]
["src/nvim/ex_getln.c", ["  pat = vim_strsave(filepat);", "  for (i = 0; pat[i]; ++i)", "    if (pat[i] == '\\\\' && pat[i + 1] == ' ')"], "readability/increment"]
["src/nvim/ex_getln.c", ["  for (i = 0; pat[i]; ++i)", "    if (pat[i] == '\\\\' && pat[i + 1] == ' ')", "      STRMOVE(pat + i, pat + i + 1);"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /*", "   * Go over all directories in $PATH.  Expand matches in that directory and"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "    /* Expand matches in one directory of $PATH. */", "    ret = expand_wildcards(1, &buf, num_file, file, flags);"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    }", "    if (*e != NUL)", "      ++e;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    if (*e != NUL)", "      ++e;", "  }"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "  if (xp->xp_arg == NULL || xp->xp_arg[0] == '\\0' || xp->xp_line == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* Save the cmdline, we don't know what the function may do. */", "  save_ccline = ccline;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Expand names with a function defined by the user."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", [" */", "static int ExpandUserDefined(expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file)", "{"], "whitespace/line_length"]
["src/nvim/ex_getln.c", ["    e = vim_strchr(s, '\\n');", "    if (e == NULL)", "      e = s + STRLEN(s);"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Expand names with a list returned by a function defined by the user."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (GA_EMPTY(&ga))", "    return FAIL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* Sort and remove duplicates which can happen when specifying multiple", "   * directories in dirnames. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*********************************", "*  Command line history stuff\t *"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Table of history names."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the possible first"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  }", "  if (idx < short_names_count + history_name_count)", "    return (char_u *)history_names[idx - short_names_count];"], "readability/braces"]
["src/nvim/ex_getln.c", ["    return (char_u *)history_names[idx - short_names_count];", "  if (idx == short_names_count + history_name_count)", "    return (char_u *)\"all\";"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Check if command line 'str' is already in history."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", [" */", "static int ", "in_history ("], "whitespace/end_of_line"]
["src/nvim/ex_getln.c", ["static int ", "in_history (", "    int type,"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["", "  if (hisidx[type] < 0)", "    return FALSE;"], "readability/braces"]
["src/nvim/ex_getln.c", ["  if (hisidx[type] < 0)", "    return FALSE;", "  i = hisidx[type];"], "readability/bool"]
["src/nvim/ex_getln.c", ["  do {", "    if (history[type][i].hisstr == NULL)", "      return FALSE;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    if (history[type][i].hisstr == NULL)", "      return FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["", "    /* For search history, check that the separator character matches as", "     * well. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["        && (type != HIST_SEARCH || sep == p[STRLEN(p) + 1])) {", "      if (!move_to_front)", "        return TRUE;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      if (!move_to_front)", "        return TRUE;", "      last_i = i;"], "readability/bool"]
["src/nvim/ex_getln.c", ["    }", "    if (--i < 0)", "      i = hislen - 1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    while (i != hisidx[type]) {", "      if (++i >= hislen)", "        i = 0;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "static int last_maptick = -1;           /* last seen maptick */", ""], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Add the given string to the given history.  If the string is already in the"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", [" */", "void ", "add_to_history ("], "whitespace/end_of_line"]
["src/nvim/ex_getln.c", ["void ", "add_to_history (", "    int histype,"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["    char_u *new_entry,", "    int in_map,                     /* consider maptick when inside a mapping */", "    int sep                        /* separator character used (search hist) */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    int in_map,                     /* consider maptick when inside a mapping */", "    int sep                        /* separator character used (search hist) */", ")"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (cmdmod.keeppatterns && histype == HIST_SEARCH)", "    return;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /*", "   * Searches inside the same mapping overwrite each other, so that only"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      hist_free_entry(hisptr);", "      --hisnum[histype];", "      if (--hisidx[HIST_SEARCH] < 0)"], "readability/increment"]
["src/nvim/ex_getln.c", ["      --hisnum[histype];", "      if (--hisidx[HIST_SEARCH] < 0)", "        hisidx[HIST_SEARCH] = hislen - 1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["  if (!in_history(histype, new_entry, true, sep)) {", "    if (++hisidx[histype] == hislen)", "      hisidx[histype] = 0;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    hisptr->hisnum = ++hisnum[histype];", "    if (histype == HIST_SEARCH && in_map)", "      last_maptick = maptick;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Get identifier of newest history entry."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["{", "  if (hislen == 0 || histype < 0 || histype >= HIST_COUNT", "      || hisidx[histype] < 0)"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Get pointer to the command line info to use. cmdline_paste() may clear"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Get the current command line in allocated memory."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (p == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Get the current command line position, counted in bytes."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (p == NULL)", "    return -1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Set the command line byte position to \"pos\".  Zero is the first position."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (p == NULL)", "    return 1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* The position is not set directly but after CTRL-\\ e or CTRL-R = has", "   * changed the command line. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["   * changed the command line. */", "  if (pos < 0)", "    new_cmdpos = 0;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    new_cmdpos = 0;", "  else", "    new_cmdpos = pos;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Get the current command-line type."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (p == NULL)", "    return NUL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    return NUL;", "  if (p->cmdfirstc == NUL)", "    return (p->input_fn) ? '@' : '-';"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Calculate history index from a number:"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  histentry_T *hist;", "  int wrapped = FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["", "  if (hislen == 0 || histype < 0 || histype >= HIST_COUNT", "      || (i = hisidx[histype]) < 0 || num == 0)"], "readability/braces"]
["src/nvim/ex_getln.c", ["  if (num > 0) {", "    while (hist[i].hisnum > num)", "      if (--i < 0) {"], "readability/braces"]
["src/nvim/ex_getln.c", ["      if (--i < 0) {", "        if (wrapped)", "          break;"], "readability/braces"]
["src/nvim/ex_getln.c", ["        i += hislen;", "        wrapped = TRUE;", "      }"], "readability/bool"]
["src/nvim/ex_getln.c", ["      }", "    if (hist[i].hisnum == num && hist[i].hisstr != NULL)", "      return i;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    i += num + 1;", "    if (i < 0)", "      i += hislen;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      i += hislen;", "    if (hist[i].hisstr != NULL)", "      return i;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Get a history entry by its index."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  idx = calc_hist_idx(histype, idx);", "  if (idx >= 0)", "    return history[histype][idx].hisstr;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    return history[histype][idx].hisstr;", "  else", "    return (char_u *)\"\";"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Remove all entries matching {str} from a history."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  regmatch.regprog = NULL;", "  regmatch.rm_ic = FALSE;       /* always match case */", "  if (hislen != 0"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  regmatch.regprog = NULL;", "  regmatch.rm_ic = FALSE;       /* always match case */", "  if (hislen != 0"], "readability/bool"]
["src/nvim/ex_getln.c", ["      hisptr = &history[histype][i];", "      if (hisptr->hisstr == NULL)", "        break;"], "readability/braces"]
["src/nvim/ex_getln.c", ["        }", "        if (--last < 0)", "          last += hislen;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      }", "      if (--i < 0)", "        i += hislen;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    } while (i != idx);", "    if (history[histype][idx].hisstr == NULL)", "      hisidx[histype] = -1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Remove an indexed entry from a history."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  i = calc_hist_idx(histype, idx);", "  if (i < 0)", "    return FALSE;"], "readability/braces"]
["src/nvim/ex_getln.c", ["  if (i < 0)", "    return FALSE;", "  idx = hisidx[histype];"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "  /* When deleting the last added search string in a mapping, reset", "   * last_maptick, so that the last added search string isn't deleted again."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["   */", "  if (histype == HIST_SEARCH && maptick == last_maptick && i == idx)", "    last_maptick = -1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["  hisidx[histype] = i;", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * :history command - print a history"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    end = arg;", "    while (ASCII_ISALPHA(*end)", "           || vim_strchr((char_u *)\":=@>/?\", *end) != NULL)"], "readability/braces"]
["src/nvim/ex_getln.c", ["      }", "    } else", "      histype2 = histype1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  for (; !got_int && histype1 <= histype2; ++histype1) {", "    STRCPY(IObuff, \"\\n      #  \");"], "readability/increment"]
["src/nvim/ex_getln.c", ["    k = hisidx2;", "    if (j < 0)", "      j = (-j > hislen) ? 0 : hist[(hislen+j+idx+1) % hislen].hisnum;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      j = (-j > hislen) ? 0 : hist[(hislen+j+idx+1) % hislen].hisnum;", "    if (k < 0)", "      k = (-k > hislen) ? 0 : hist[(hislen+k+idx+1) % hislen].hisnum;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      k = (-k > hislen) ? 0 : hist[(hislen+k+idx+1) % hislen].hisnum;", "    if (idx >= 0 && j <= k)", "      for (i = idx + 1; !got_int; ++i) {"], "readability/braces"]
["src/nvim/ex_getln.c", ["    if (idx >= 0 && j <= k)", "      for (i = idx + 1; !got_int; ++i) {", "        if (i == hislen)"], "readability/increment"]
["src/nvim/ex_getln.c", ["      for (i = idx + 1; !got_int; ++i) {", "        if (i == hislen)", "          i = 0;"], "readability/braces"]
["src/nvim/ex_getln.c", ["        }", "        if (i == idx)", "          break;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* Can't do this recursively.  Can't do it when typing a password. */", "  if (cmdwin_type != 0"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      do {", "        if (++i == hislen)", "          i = 0;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* Replace the empty last line with the current command-line and put the", "   * cursor there. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  /*", "   * Call the main loop until <CR> or CTRL-C is typed."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  /* Safety check: The old window or buffer was deleted: It's a bug when", "   * this happens! */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  } else {", "    /* autocmds may abort script processing */", "    if (aborting() && cmdwin_result != K_IGNORE)"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    /* autocmds may abort script processing */", "    if (aborting() && cmdwin_result != K_IGNORE)", "      cmdwin_result = Ctrl_C;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      cmdwin_result = Ctrl_C;", "    /* Set the new command line from the cmdline buffer. */", "    xfree(ccline.cmdbuff);"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    } else if (cmdwin_result == Ctrl_C) {", "      /* :q or :close, don't execute any command", "       * and don't modify the cmd window. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      ccline.cmdbuff = NULL;", "    } else", "      ccline.cmdbuff = vim_strsave(get_cursor_line_ptr());"], "readability/braces"]
["src/nvim/ex_getln.c", ["      ccline.cmdpos = curwin->w_cursor.col;", "      if (ccline.cmdpos > ccline.cmdlen)", "        ccline.cmdpos = ccline.cmdlen;"], "readability/braces"]
["src/nvim/ex_getln.c", ["  } else {", "    hiter = (histentry_T *) iter;", "  }"], "whitespace/cast"]
["src/nvim/ex_getln.c", ["  hiter++;", "  return (const void *) ((hiter > hend) ? hstart : hiter);", "}"], "whitespace/cast"]
