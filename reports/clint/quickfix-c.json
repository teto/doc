["src/nvim/quickfix.c", ["    qi->qf_curlist = LISTCOUNT - 1;", "  } else", "    qi->qf_curlist = qi->qf_listcount++;"], "readability/braces"]
["src/nvim/quickfix.c", ["  qi = *pqi;", "  if (qi == NULL)", "    return;"], "readability/braces"]
["src/nvim/quickfix.c", ["      (*stackptr)->dirname = (char_u *)concat_fnames((char *)ds_new->dirname,", "          (char *)dirbuf, TRUE);", "      if (os_isdir((*stackptr)->dirname))"], "whitespace/alignment"]
["src/nvim/quickfix.c", ["      (*stackptr)->dirname = (char_u *)concat_fnames((char *)ds_new->dirname,", "          (char *)dirbuf, TRUE);", "      if (os_isdir((*stackptr)->dirname))"], "readability/bool"]
["src/nvim/quickfix.c", ["          (char *)dirbuf, TRUE);", "      if (os_isdir((*stackptr)->dirname))", "        break;"], "readability/braces"]
["src/nvim/quickfix.c", ["", "  if ((*stackptr)->dirname != NULL)", "    return (*stackptr)->dirname;"], "readability/braces"]
["src/nvim/quickfix.c", ["    return (*stackptr)->dirname;", "  else {", "    ds_ptr = *stackptr;"], "readability/braces"]
["src/nvim/quickfix.c", ["    return (*stackptr)->dirname;", "  else {", "    ds_ptr = *stackptr;"], "readability/braces"]
["src/nvim/quickfix.c", ["    xfree(fullname);", "    fullname = (char_u *)concat_fnames((char *)ds_ptr->dirname, (char *)filename, TRUE);", ""], "whitespace/line_length"]
["src/nvim/quickfix.c", ["    xfree(fullname);", "    fullname = (char_u *)concat_fnames((char *)ds_ptr->dirname, (char *)filename, TRUE);", ""], "readability/bool"]
["src/nvim/quickfix.c", ["  qfline_T *qf_ptr = qfl->qf_ptr;", "  int qf_idx = qfl->qf_index;;", ""], "whitespace/newline"]
["src/nvim/quickfix.c", ["", "  if (qi == NULL)", "    qi = &ql_info;"], "readability/braces"]
["src/nvim/quickfix.c", ["      swb_flags = old_swb_flags;", "    } else", "      free_string_option(old_swb);"], "readability/braces"]
["src/nvim/quickfix.c", ["", "  for (i = 0; *p != NUL && i < bufsize - 1; ++i) {", "    if (*p == '\\n') {"], "readability/increment"]
["src/nvim/quickfix.c", ["      buf[i] = ' ';", "      while (*++p != NUL)", "        if (!ascii_iswhite(*p) && *p != '\\n')"], "readability/braces"]
["src/nvim/quickfix.c", ["      while (*++p != NUL)", "        if (!ascii_iswhite(*p) && *p != '\\n')", "          break;"], "readability/braces"]
["src/nvim/quickfix.c", ["          break;", "    } else", "      buf[i] = *p++;"], "readability/braces"]
["src/nvim/quickfix.c", ["      }", "      --qi->qf_curlist;", "    } else {"], "readability/increment"]
["src/nvim/quickfix.c", ["      }", "      ++qi->qf_curlist;", "    }"], "readability/increment"]
["src/nvim/quickfix.c", ["          if (qfp->qf_lnum >= line1 && qfp->qf_lnum <= line2) {", "            if (amount == MAXLNUM)", "              qfp->qf_cleared = TRUE;"], "readability/braces"]
["src/nvim/quickfix.c", ["            if (amount == MAXLNUM)", "              qfp->qf_cleared = TRUE;", "            else"], "readability/bool"]
["src/nvim/quickfix.c", ["              qfp->qf_cleared = TRUE;", "            else", "              qfp->qf_lnum += amount;"], "readability/braces"]
["src/nvim/quickfix.c", ["              qfp->qf_lnum += amount;", "          } else if (amount_after && qfp->qf_lnum > line2)", "            qfp->qf_lnum += amount_after;"], "readability/braces"]
["src/nvim/quickfix.c", ["", "  if (nr <= 0)", "    return p;"], "readability/braces"]
["src/nvim/quickfix.c", ["", "  sprintf((char *)buf, \"%s %3d\", (char *)p, nr);", "  return buf;"], "runtime/printf"]
["src/nvim/quickfix.c", ["         && STRCMP(\"internal\",", "      *curbuf->b_p_gp == NUL ? p_gp : curbuf->b_p_gp) == 0;", "}"], "whitespace/alignment"]
["src/nvim/quickfix.c", ["  fname = get_mef_name();", "  if (fname == NULL)", "    return;"], "readability/braces"]
["src/nvim/quickfix.c", ["    name = vim_tempname();", "    if (name == NULL)", "      EMSG(_(e_notmp));"], "readability/braces"]
["src/nvim/quickfix.c", ["", "  for (p = p_mef; *p; ++p)", "    if (p[0] == '#' && p[1] == '#')"], "readability/braces"]
["src/nvim/quickfix.c", ["", "  for (p = p_mef; *p; ++p)", "    if (p[0] == '#' && p[1] == '#')"], "readability/increment"]
["src/nvim/quickfix.c", ["  for (p = p_mef; *p; ++p)", "    if (p[0] == '#' && p[1] == '#')", "      break;"], "readability/braces"]
["src/nvim/quickfix.c", ["", "  if (*p == NUL)", "    return vim_strsave(p_mef);"], "readability/braces"]
["src/nvim/quickfix.c", ["    STRCPY(name, p_mef);", "    sprintf((char *)name + (p - p_mef), \"%d%d\", start, off);", "    STRCAT(name, p + 2);"], "runtime/printf"]
["src/nvim/quickfix.c", ["  buf_T       *buf;", "  int duplicate_name = FALSE;", "  int using_dummy;"], "readability/bool"]
["src/nvim/quickfix.c", ["  int using_dummy;", "  int redraw_for_dummy = FALSE;", "  int found_match;"], "readability/bool"]
["src/nvim/quickfix.c", ["", "  if (eap->addr_count > 0)", "    tomatch = eap->line2;"], "readability/braces"]
["src/nvim/quickfix.c", ["    tomatch = eap->line2;", "  else", "    tomatch = MAXLNUM;"], "readability/braces"]
["src/nvim/quickfix.c", ["      duplicate_name = (buf != NULL);", "      using_dummy = TRUE;", "      redraw_for_dummy = TRUE;"], "readability/bool"]
["src/nvim/quickfix.c", ["      using_dummy = TRUE;", "      redraw_for_dummy = TRUE;", ""], "readability/bool"]
["src/nvim/quickfix.c", ["    if (buf == NULL) {", "      if (!got_int)", "        smsg(_(\"Cannot open file \\\"%s\\\"\"), fname);"], "readability/braces"]
["src/nvim/quickfix.c", ["      if (using_dummy) {", "        if (found_match && first_match_buf == NULL)", "          first_match_buf = buf;"], "readability/braces"]
["src/nvim/quickfix.c", ["          apply_autocmds(EVENT_FILETYPE, buf->b_p_ft,", "              buf->b_fname, TRUE, buf);", "          do_modelines(OPT_NOWIN);"], "whitespace/alignment"]
["src/nvim/quickfix.c", ["          apply_autocmds(EVENT_FILETYPE, buf->b_p_ft,", "              buf->b_fname, TRUE, buf);", "          do_modelines(OPT_NOWIN);"], "readability/bool"]
["src/nvim/quickfix.c", ["", "  if (au_name != NULL)", "    apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,"], "readability/braces"]
["src/nvim/quickfix.c", ["    apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,", "        curbuf->b_fname, TRUE, curbuf);", ""], "whitespace/alignment"]
["src/nvim/quickfix.c", ["    apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,", "        curbuf->b_fname, TRUE, curbuf);", ""], "readability/bool"]
["src/nvim/quickfix.c", ["    }", "  } else", "    EMSG2(_(e_nomatch2), s);"], "readability/braces"]
["src/nvim/quickfix.c", ["static buf_T *", "load_dummy_buffer (", "    char_u *fname,"], "whitespace/parens"]
["src/nvim/quickfix.c", ["        && !(curbuf->b_flags & BF_NEW)) {", "      failed = FALSE;", "      if (curbuf != newbuf) {"], "readability/bool"]
["src/nvim/quickfix.c", ["", "    wipe_buffer(buf, FALSE);", ""], "readability/bool"]
["src/nvim/quickfix.c", ["", "  if (*eap->arg == NUL)", "    buf = curbuf;"], "readability/braces"]
["src/nvim/quickfix.c", ["    buf = curbuf;", "  else if (*skipwhite(skipdigits(eap->arg)) == NUL)", "    buf = buflist_findnr(atoi((char *)eap->arg));"], "readability/braces"]
