["src/nvim/api/buffer.c", ["  if (!buf) {", "    return (Object) OBJECT_INIT;", "  }"], "whitespace/cast"]
["src/nvim/api/buffer.c", ["  if (!buf) {", "    return (Object) OBJECT_INIT;", "  }"], "whitespace/cast"]
["src/nvim/api/buffer.c", ["  aucmd_prepbuf(&aco, buf);", "  int ren_ret = rename_buffer((char_u *) name.data);", "  aucmd_restbuf(&aco);"], "whitespace/cast"]
["src/nvim/api/private/defs.h", ["", "#define ARRAY_DICT_INIT {.size = 0, .capacity = 0, .items = NULL}", "#define STRING_INIT {.data = NULL, .size = 0}"], "whitespace/braces"]
["src/nvim/api/private/defs.h", ["", "#define ARRAY_DICT_INIT {.size = 0, .capacity = 0, .items = NULL}", "#define STRING_INIT {.data = NULL, .size = 0}"], "whitespace/braces"]
["src/nvim/api/private/defs.h", ["#define ARRAY_DICT_INIT {.size = 0, .capacity = 0, .items = NULL}", "#define STRING_INIT {.data = NULL, .size = 0}", "#define OBJECT_INIT { .type = kObjectTypeNil }"], "whitespace/braces"]
["src/nvim/api/private/defs.h", ["#define ARRAY_DICT_INIT {.size = 0, .capacity = 0, .items = NULL}", "#define STRING_INIT {.data = NULL, .size = 0}", "#define OBJECT_INIT { .type = kObjectTypeNil }"], "whitespace/braces"]
["src/nvim/api/private/helpers.c", ["{", "  ++trylevel;", "}"], "readability/increment"]
["src/nvim/api/private/helpers.c", ["  switch (opt_type)", "  {", "    case SREQ_WIN:"], "whitespace/braces"]
["src/nvim/api/private/helpers.c", ["    case SREQ_WIN:", "      if (switch_win(&save_curwin, &save_curtab, (win_T *)from,", "            win_find_tabpage((win_T *)from), false) == FAIL)"], "readability/braces"]
["src/nvim/api/private/helpers.c", ["      if (switch_win(&save_curwin, &save_curtab, (win_T *)from,", "            win_find_tabpage((win_T *)from), false) == FAIL)", "      {"], "whitespace/alignment"]
["src/nvim/api/private/helpers.c", ["            win_find_tabpage((win_T *)from), false) == FAIL)", "      {", "        if (try_end(err)) {"], "whitespace/braces"]
["src/nvim/api/private/helpers.h", ["", "#define STATIC_CSTR_AS_STRING(s) ((String) {.data = s, .size = sizeof(s) - 1})", ""], "whitespace/braces"]
["src/nvim/api/private/helpers.h", ["", "#define STATIC_CSTR_AS_STRING(s) ((String) {.data = s, .size = sizeof(s) - 1})", ""], "whitespace/braces"]
["src/nvim/api/tabpage.c", ["  if (!tab) {", "    return (Object) OBJECT_INIT;", "  }"], "whitespace/cast"]
["src/nvim/api/vim.c", ["", "  for (size_t i = 0; i < mode.size; ++i) {", "    switch (mode.data[i]) {"], "readability/increment"]
["src/nvim/api/vim.c", ["", "  ++no_wait_return;", "  for (uint32_t i = 0; i < message.size; i++) {"], "readability/increment"]
["src/nvim/api/vim.c", ["  }", "  --no_wait_return;", "  msg_end();"], "readability/increment"]
["src/nvim/api/window.c", ["  if (!win) {", "    return (Object) OBJECT_INIT;", "  }"], "whitespace/cast"]
["src/nvim/api/window.c", ["  if (!win) {", "    return (Object) OBJECT_INIT;", "  }"], "whitespace/cast"]
["src/nvim/assert.h", ["// _Static_assert but we need to suppress warnings, this is pretty ugly.", "#elif (!defined(__clang__) && !defined(__INTEL_COMPILER)) && \\", "  (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))"], "whitespace/parens"]
["src/nvim/buffer.c", ["", "  /*", "   * The 'readonly' flag is only set when BF_NEVERLOADED is being reset."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["   */", "  if (readonlymode && curbuf->b_ffname != NULL", "      && (curbuf->b_flags & BF_NEVERLOADED))"], "readability/braces"]
["src/nvim/buffer.c", ["  if (ml_open(curbuf) == FAIL) {", "    /*", "     * There MUST be a memfile, otherwise we can't do anything"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "    /*", "     * First read the text in binary mode into the buffer."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["    retval = readfile(NULL, NULL, (linenr_T)0,", "        (linenr_T)0, (linenr_T)MAXLNUM, NULL,", "        flags | (READ_NEW + READ_STDIN));"], "whitespace/alignment"]
["src/nvim/buffer.c", ["        (linenr_T)0, (linenr_T)MAXLNUM, NULL,", "        flags | (READ_NEW + READ_STDIN));", "    curbuf->b_p_bin = save_bin;"], "whitespace/alignment"]
["src/nvim/buffer.c", ["", "  /* Need to update automatic folding.  Do this before the autocommands,", "   * they may use the fold info. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /*", "   * The autocommands may have changed the current buffer.  Apply the"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["      wipe_buf = true;", "    } else if (buf->b_p_bh[0] == 'u')    // 'bufhidden' == \"unload\"", "      unload_buf = true;"], "readability/braces"]
["src/nvim/buffer.c", ["", "  /* Return when a window is displaying the buffer or when it's not", "   * unloaded. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /*", "   * Free all things allocated for this buffer."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["   */", "  /* Remember if we are closing the current buffer.  Restore the number of", "   * windows, so that autocommands in buf_freeall() don't get confused. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /*", "   * It's possible that autocommands change curbuf to the one being deleted."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /*", "   * Remove the buffer from the list."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /*", "   * It's possible that autocommands change curbuf to the one being deleted."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Free a buffer structure and the things it contains related to the buffer"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Free the b_wininfo list for buffer \"buf\"."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Go to another buffer.  Handles the result of the ATTENTION dialog."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "    /* Restore the error/interrupt/exception state if not discarded by a", "     * new aborting error, interrupt, or uncaught exception. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "    /* Restore the error/interrupt/exception state if not discarded by a", "     * new aborting error, interrupt, or uncaught exception. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "    /* Restore the error/interrupt/exception state if not discarded by a", "     * new aborting error, interrupt, or uncaught exception. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * do_bufdel() - delete or unload buffer(s)"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["    for (; !got_int; os_breakcheck()) {", "      /*", "       * delete the current buffer last, otherwise when the"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "      /*", "       * find next buffer number to delete/unload"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Make the current buffer empty."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["  retval = do_ecmd(0, NULL, NULL, NULL, ECMD_ONE,", "      forceit ? ECMD_FORCEIT : 0, curwin);", ""], "whitespace/alignment"]
["src/nvim/buffer.c", ["}", "/*", " * Implementation of the commands for the buffer list."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["    while (count > 0 || (!unload && !buf->b_p_bl && bp != buf)) {", "      /* remember the buffer where we start, we come back there when all", "       * buffers are unlisted. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /*", "   * delete buffer buf from memory and/or the list"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "    /* When unloading or deleting a buffer that's already unloaded and", "     * unlisted: fail silently. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "    /*", "     * If deleting the last (listed) buffer, make it empty."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "    /*", "     * If the deleted buffer is the current one, close the current window"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "    /*", "     * If the buffer to be deleted is not the current one, delete it here."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["  if (buf == NULL) {", "    /* Autocommands must have wiped out all other buffers.  Only option", "     * now is to make the current buffer empty. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /*", "   * make buf current buffer"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /*", "   * Check if the current buffer may be abandoned."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Set current buffer to \"buf\".  Executes autocommands and closes current"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["  }", "  /* An autocommand may have deleted \"buf\", already entered it (e.g., when", "   * it did \":bunload\") or aborted the script processing!"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["       && !aborting()", "       ) || curwin->w_buffer == NULL", "      ) {"], "whitespace/parens"]
["src/nvim/buffer.c", ["", "/*", " * Enter a new current buffer."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /* If autocommands did not change the cursor position, restore cursor lnum", "   * and possibly cursor col. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /*", "   * If file name already exists in the list, update the entry."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["   */", "  /* We can use inode numbers when the file exists.  Works better", "   * for hard links. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /*", "   * If the current buffer has no name and no contents, use the current"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["    buf = curbuf;", "    /* It's like this buffer is deleted.  Watch out for autocommands that", "     * change curbuf!  If that happens, allocate a new buffer anyway. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["  } else {", "    /*", "     * put new buffer at the end of the buffer list"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "    /*", "     * Always copy the options from the current buffer."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Free the memory for the options of a buffer."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["    col = fpos->col;", "  } else", "    col = 0;"], "readability/braces"]
["src/nvim/buffer.c", ["", "/*", " * Find file in buffer list by name (it has to be for the current window)."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["#endif", "      );", "  if (ffname != NULL) {"], "whitespace/alignment"]
["src/nvim/buffer.c", ["#endif", "      );", "  if (ffname != NULL) {"], "whitespace/parens"]
["src/nvim/buffer.c", ["", "/*", " * Find file in buffer list by name (it has to be for the current window)."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Same as buflist_findname(), but pass the FileID structure to avoid"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["            if (curtab_only) {", "              /* Ignore the match if the buffer is not open in", "               * the current tab. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "      /* Only search for unlisted buffers if there was no match with", "       * a listed buffer. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Find all buffer names that match."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["    STRCPY(patc + 11, pat + 1);", "  } else", "    patc = pat;"], "readability/braces"]
["src/nvim/buffer.c", ["", "  /*", "   * attempt == 0: try match with    '\\<', match at start of word"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "    /*", "     * round == 1: Count the matches."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Get name of file 'n' in the buffer list."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["  return home_replace_save(helptail ? buf : NULL,", "      fullname ? buf->b_ffname : buf->b_fname);", "}"], "whitespace/alignment"]
["src/nvim/buffer.c", ["", "/*", " * Reset the local window options to the values last used in this window."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["    cloneFoldGrowArray(&wip->wi_folds, &curwin->w_folds);", "  } else", "    copy_winopt(&curwin->w_allbuf_opt, &curwin->w_onebuf_opt);"], "readability/braces"]
["src/nvim/buffer.c", ["", "/*", " * Find the position (lnum and col) for the buffer 'buf' for the current"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Find the lnum for the buffer 'buf' for the current window."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Get file name and line number for file 'fnum'."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "    /*", "     * if the file name is already used in another buffer:"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Crude way of changing the name of a buffer.  Use with care!"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["    buf->b_sfname = NULL;", "    /* Allocate ffname and expand into full path.  Also resolves .lnk", "     * files on Win32. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Take care of what needs to be done when the name of buffer \"buf\" has"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["{", "  /*", "   * If the file name changed, also change the name of the swapfile"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * set alternate file name for current window"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Get alternate file name for current window."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Add a file name to the buflist and return its number."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["#if defined(BACKSLASH_IN_FILENAME)", "/*", " * Adjust slashes in file names.  Called after 'shellslash' was set."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Set alternate cursor position for the current buffer and window \"win\"."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Print info about the current buffer."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["    p = buffer + STRLEN(buffer);", "  } else", "    p = buffer;"], "readability/braces"]
["src/nvim/buffer.c", ["    vim_snprintf_add((char *)buffer, IOSIZE,", "        _(\"line %\" PRId64 \" of %\" PRId64 \" --%d%%-- col \"),", "        (int64_t)curwin->w_cursor.lnum,"], "whitespace/alignment"]
["src/nvim/buffer.c", ["        _(\"line %\" PRId64 \" of %\" PRId64 \" --%d%%-- col \"),", "        (int64_t)curwin->w_cursor.lnum,", "        (int64_t)curbuf->b_ml.ml_line_count,"], "whitespace/alignment"]
["src/nvim/buffer.c", ["        (int64_t)curwin->w_cursor.lnum,", "        (int64_t)curbuf->b_ml.ml_line_count,", "        n);"], "whitespace/alignment"]
["src/nvim/buffer.c", ["        (int64_t)curbuf->b_ml.ml_line_count,", "        n);", "    validate_virtcol();"], "whitespace/alignment"]
["src/nvim/buffer.c", ["    col_print(buffer + len, IOSIZE - len,", "        (int)curwin->w_cursor.col + 1, (int)curwin->w_virtcol + 1);", "  }"], "whitespace/alignment"]
["src/nvim/buffer.c", ["  if (dont_truncate) {", "    /* Temporarily set msg_scroll to avoid the message being truncated.", "     * First call msg_start() to get the message in the right place. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["    // or run out of room in our output buffer.", "    while (*fmt_p != NUL && *fmt_p != '%' && out_p < out_end_p)", "      *out_p++ = *fmt_p++;"], "readability/braces"]
["src/nvim/buffer.c", ["          min_group_width = 0 - min_group_width;", "          while (group_len++ < min_group_width && out_p < out_end_p)", "            *out_p++ = fillchar;"], "readability/braces"]
["src/nvim/buffer.c", ["      fmt_p++;", "      char *t = (char *) fmt_p;", "      while (*fmt_p != STL_CLICK_FUNC && *fmt_p) {"], "whitespace/cast"]
["src/nvim/buffer.c", ["      char_u *t = out_p;", "      while (*fmt_p != '}' && *fmt_p != NUL && out_p < out_end_p)", "        *out_p++ = *fmt_p++;"], "readability/braces"]
["src/nvim/buffer.c", ["      // Don't display %V if it's the same as %c.", "      if (opt == STL_VIRTCOL_ALT", "          && (virtcol == (colnr_T)(!(State & INSERT) && empty_line"], "readability/braces"]
["src/nvim/buffer.c", ["      itemisflag = true;", "      if (wp->w_buffer->b_help)", "        str = (char_u *)((opt == STL_HELPFLAG_ALT) ? \",HLP\""], "readability/braces"]
["src/nvim/buffer.c", ["      itemisflag = true;", "      if (wp->w_p_pvw)", "        str = (char_u *)((opt == STL_PREVIEWFLAG_ALT) ? \",PRV\""], "readability/braces"]
["src/nvim/buffer.c", ["    case STL_QUICKFIX:", "      if (bt_quickfix(wp->w_buffer))", "        str = (char_u *)(wp->w_llist_ref"], "readability/braces"]
["src/nvim/buffer.c", ["      if (itemisflag) {", "        if ((t[0] && t[1])", "            && ((!prevchar_isitem && *t == ',')"], "readability/braces"]
["src/nvim/buffer.c", ["        // digit follows.", "        if (fillable && out_p[-1] == ' '", "            && (!ascii_isdigit(*t) || fillchar != '-'))"], "readability/braces"]
["src/nvim/buffer.c", ["      long num_chars = 1;", "      for (long n = num; n >= (int) base; n /= (int) base) {", "        num_chars++;"], "whitespace/cast"]
["src/nvim/buffer.c", ["        vim_snprintf((char *)out_p, remaining_buf_len, (char *)nstr,", "            0, num, n);", "      } else {"], "whitespace/alignment"]
["src/nvim/buffer.c", ["        vim_snprintf((char *)out_p, remaining_buf_len, (char *)nstr,", "            minwid, num);", "      }"], "whitespace/alignment"]
["src/nvim/buffer.c", ["  return width;", "}", ""], "readability/fn_size"]
["src/nvim/buffer.c", ["", "/*", " * Get relative cursor position in window into \"buf[buflen]\", in the form 99%,"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Get the file name for an argument list entry."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * do_arg_all(): Open up to 'count' windows, one for each argument."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["  if (ARGCOUNT <= 0) {", "    /* Don't give an error message.  We don't want it when the \":all\"", "     * command is in the .vimrc. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /* Autocommands may do anything to the argument list.  Make sure it's not", "   * freed while we are working here by \"locking\" it.  We still have to"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /*", "   * Try closing all windows that are not in the argument list."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["            if (wp->w_alist != alist) {", "              /* Use the current argument list for all windows", "               * containing a file from it. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["            || !bufIsChanged(buf)) {", "          /* If the buffer was changed, and we would like to hide it,", "           * try autowriting. */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /*", "   * Open a window for files in the argument list that don't have one."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "      /*", "       * edit file \"i\""], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Open a window for a number of buffers."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /*", "   * Close superfluous windows (two windows for the same buffer)."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "        /* Restore the error/interrupt/exception state if not", "         * discarded by a new aborting error, interrupt, or uncaught"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["        leave_cleanup(&cs);", "      } else", "        handle_swap_exists(NULL);"], "readability/braces"]
["src/nvim/buffer.c", ["", "  /*", "   * Close superfluous windows."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * do_modelines() - process mode lines for the current file"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "  /* Disallow recursive entry here.  Can happen when executing a modeline", "   * triggers an autocommand, which reloads modelines with a \":do\". */"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * chk_modeline() - check a single line for a mode string"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["    if (prev == -1 || ascii_isspace(prev)) {", "      if ((prev != -1 && STRNCMP(s, \"ex:\", (size_t)3) == 0)", "          || STRNCMP(s, \"vi:\", (size_t)3) == 0)"], "readability/braces"]
["src/nvim/buffer.c", ["", "    /*", "     * Find end of set command: ':' or end of line."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "    /*", "     * If there is a \"set\" command, require a terminating ':' and"], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Return special buffer name."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Set 'buflisted' for curbuf to \"on\" and trigger autocommands if it changed."], "readability/old_style_comment"]
["src/nvim/buffer.c", ["", "/*", " * Wipe out a buffer and decrement the last buffer number if it was used for"], "readability/old_style_comment"]
["src/nvim/buffer.h", ["enum getf_values {", "  GETF_SETMARK = 0x01, // set pcmark before jumping", "  GETF_ALT     = 0x02, // jumping to alternate file (not buf num)"], "whitespace/comments"]
["src/nvim/buffer.h", ["  GETF_SETMARK = 0x01, // set pcmark before jumping", "  GETF_ALT     = 0x02, // jumping to alternate file (not buf num)", "  GETF_SWITCH  = 0x04, // respect 'switchbuf' settings when jumping"], "whitespace/comments"]
["src/nvim/buffer.h", ["  GETF_ALT     = 0x02, // jumping to alternate file (not buf num)", "  GETF_SWITCH  = 0x04, // respect 'switchbuf' settings when jumping", "};"], "whitespace/comments"]
["src/nvim/buffer.h", ["enum dobuf_action_values {", "  DOBUF_GOTO   = 0, // go to specified buffer", "  DOBUF_SPLIT  = 1, // split window and go to specified buffer"], "whitespace/comments"]
["src/nvim/buffer.h", ["  DOBUF_GOTO   = 0, // go to specified buffer", "  DOBUF_SPLIT  = 1, // split window and go to specified buffer", "  DOBUF_UNLOAD = 2, // unload specified buffer(s)"], "whitespace/comments"]
["src/nvim/buffer.h", ["  DOBUF_SPLIT  = 1, // split window and go to specified buffer", "  DOBUF_UNLOAD = 2, // unload specified buffer(s)", "  DOBUF_DEL    = 3, // delete specified buffer(s) from buflist"], "whitespace/comments"]
["src/nvim/buffer.h", ["  DOBUF_UNLOAD = 2, // unload specified buffer(s)", "  DOBUF_DEL    = 3, // delete specified buffer(s) from buflist", "  DOBUF_WIPE   = 4, // delete specified buffer(s) really"], "whitespace/comments"]
["src/nvim/buffer.h", ["  DOBUF_DEL    = 3, // delete specified buffer(s) from buflist", "  DOBUF_WIPE   = 4, // delete specified buffer(s) really", "};"], "whitespace/comments"]
["src/nvim/buffer.h", ["enum dobuf_start_values {", "  DOBUF_CURRENT = 0, // \"count\" buffer from current buffer", "  DOBUF_FIRST   = 1, // \"count\" buffer from first buffer"], "whitespace/comments"]
["src/nvim/buffer.h", ["  DOBUF_CURRENT = 0, // \"count\" buffer from current buffer", "  DOBUF_FIRST   = 1, // \"count\" buffer from first buffer", "  DOBUF_LAST    = 2, // \"count\" buffer from last buffer"], "whitespace/comments"]
["src/nvim/buffer.h", ["  DOBUF_FIRST   = 1, // \"count\" buffer from first buffer", "  DOBUF_LAST    = 2, // \"count\" buffer from last buffer", "  DOBUF_MOD     = 3, // \"count\" mod. buffer from current buffer"], "whitespace/comments"]
["src/nvim/buffer.h", ["  DOBUF_LAST    = 2, // \"count\" buffer from last buffer", "  DOBUF_MOD     = 3, // \"count\" mod. buffer from current buffer", "};"], "whitespace/comments"]
["src/nvim/buffer.h", ["enum bfa_values {", "  BFA_DEL       = 1, // buffer is going to be deleted", "  BFA_WIPE      = 2, // buffer is going to be wiped out"], "whitespace/comments"]
["src/nvim/buffer.h", ["  BFA_DEL       = 1, // buffer is going to be deleted", "  BFA_WIPE      = 2, // buffer is going to be wiped out", "  BFA_KEEP_UNDO = 4, // do not free undo information"], "whitespace/comments"]
["src/nvim/buffer.h", ["  BFA_WIPE      = 2, // buffer is going to be wiped out", "  BFA_KEEP_UNDO = 4, // do not free undo information", "};"], "whitespace/comments"]
["src/nvim/buffer_defs.h", ["", "#endif // NVIM_BUFFER_DEFS_H", ""], "build/header_guard"]
["src/nvim/buffer_defs.h", ["", "typedef struct file_buffer buf_T; // Forward declaration", ""], "whitespace/comments"]
["src/nvim/buffer_defs.h", ["", "/*", " * Flags for w_valid."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * The taggy struct is used to store the information about a :tag command."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * structure used to store one block of the stuff/redo/recording buffers"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * header used for the stuff buffer and the redo buffer"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * Structure that contains all options that are local to a window."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * Window info stored with a buffer."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * Argument list: Array of file names."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * Used for the typeahead buffer: typebuf."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * Structure used for mappings and abbreviations."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * Used for :syntime: timing of executing a syntax pattern."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * These are items normally related to a buffer.  But when using \":ownsyntax\""], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * buffer: structure that holds information about one file"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  bool b_saving;                /* Set to true if we are in the middle of", "                                   saving the buffer. */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["", "  bool b_saving;                /* Set to true if we are in the middle of", "                                   saving the buffer. */"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * Changes to a buffer require updating of the display.  To minimize the"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["   */", "  bool b_mod_set;               /* true when there are changes since the last", "                                   time the display was updated */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["   */", "  bool b_mod_set;               /* true when there are changes since the last", "                                   time the display was updated */"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * the changelist contains old change positions"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * Character table, only used in charset.c for 'iskeyword'"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["  garray_T b_ucmds;", "  /*", "   * start and end of an operator, also used for '[ and ']"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * The following only used in undo.c."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * variables for \"U\" command in undo.c"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * Options local to a buffer."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  linenr_T b_no_eol_lnum;       /* non-zero lnum when last line of next binary", "                                 * write should not have an end-of-line */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["", "  linenr_T b_no_eol_lnum;       /* non-zero lnum when last line of next binary", "                                 * write should not have an end-of-line */"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /* When a buffer is created, it starts without a swap file.  b_may_swap is", "   * then set to indicate that a swap file may be opened later.  It is reset"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["  bool b_may_swap;", "  bool b_did_warn;              /* Set to true if user has been warned on first", "                                   change of a read-only file */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["  bool b_may_swap;", "  bool b_did_warn;              /* Set to true if user has been warned on first", "                                   change of a read-only file */"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /* Two special kinds of buffers:", "   * help buffer  - used for help files, won't use a swap file."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * Stuff for diff mode."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * Each diffblock defines where a block of lines starts in each of the buffers"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * Structure to cache info for displayed lines in w_lines[]."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * Windows are kept in a tree of frames.  Each frame has a column (FR_COL)"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * Struct used for highlighting 'hlsearch' matches, matches defined by"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * matchitem_T provides a linked list for storing match items for \":match\" and"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * \"w_topline\", \"w_leftcol\" and \"w_skipcol\" specify the offsets for"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["   */", "  linenr_T w_topline;               /* buffer line number of the line at the", "                                       top of the window */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["   */", "  linenr_T w_topline;               /* buffer line number of the line at the", "                                       top of the window */"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["                                       top of the window */", "  char w_topline_was_set;           /* flag set to TRUE when topline is set,", "                                       e.g. by winrestview() */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["                                       top of the window */", "  char w_topline_was_set;           /* flag set to TRUE when topline is set,", "                                       e.g. by winrestview() */"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["                                       top of the window */", "  char w_topline_was_set;           /* flag set to TRUE when topline is set,", "                                       e.g. by winrestview() */"], "readability/bool"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * === start of cached values ===="], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["   */", "  /*", "   * Recomputing is minimized by storing the result of computations."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["  int w_valid;", "  pos_T w_valid_cursor;             /* last known position of w_cursor, used", "                                       to adjust w_valid */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["  int w_valid;", "  pos_T w_valid_cursor;             /* last known position of w_cursor, used", "                                       to adjust w_valid */"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * w_cline_height is the number of physical lines taken by the buffer line"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * w_wrow and w_wcol specify the cursor position in the window."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * Info about the lines currently in the window is remembered to avoid"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * === end of cached values ==="], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  char_u      *w_localdir;          /* absolute path of local directory or", "                                       NULL */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["", "  char_u      *w_localdir;          /* absolute path of local directory or", "                                       NULL */"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * The w_prev_pcmark field is used to check whether we really did jump to"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * the jumplist contains old cursor positions"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * the tagstack grows from 0 upwards:"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * w_fraction is the fractional row of the cursor within the window, from"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  linenr_T w_nrwidth_line_count;        /* line count when ml_nrwidth_width", "                                         * was computed. */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["", "  linenr_T w_nrwidth_line_count;        /* line count when ml_nrwidth_width", "                                         * was computed. */"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "#endif // NVIM_BUFFER_DEFS_H", ""], "whitespace/comments"]
["src/nvim/charset.c", ["        tilde = true;", "        ++p;", "      }"], "readability/increment"]
["src/nvim/charset.c", ["      if ((*p == '-') && (p[1] != NUL)) {", "        ++p;", ""], "readability/increment"]
["src/nvim/charset.c", ["        }", "        ++c;", "      }"], "readability/increment"]
["src/nvim/charset.c", ["      memmove(buf, trs, (size_t)trs_len);", "      --len;", "    }"], "readability/increment"]
["src/nvim/charset.c", ["/// Otherwise, put the result in buf, limited by buflen, and return buf.", "char_u* str_foldcase(char_u *str, int orglen, char_u *buf, int buflen)", "  FUNC_ATTR_NONNULL_RET"], "whitespace/operators"]
["src/nvim/charset.c", ["  colnr_T col = startcol;", "  char_u *line = s; /* pointer to start of line, for breakindent */", ""], "readability/old_style_comment"]
["src/nvim/charset.c", ["/// @return The number of characters taken up on the screen.", "int win_lbr_chartabsize(win_T *wp, char_u *line, char_u *s, colnr_T col, int *headp)", "{"], "whitespace/line_length"]
["src/nvim/charset.c", ["  colnr_T col2;", "  colnr_T col_adj = 0; /* col + screen size of tab */", "  colnr_T colmax;"], "readability/old_style_comment"]
["src/nvim/charset.c", ["", "      if (col2 >= colmax) { /* doesn't fit */", "        size = colmax - col + col_adj;"], "readability/old_style_comment"]
["src/nvim/charset.c", ["    // Count the \">\" in the last column.", "    ++size;", "    mb_added = 1;"], "readability/increment"]
["src/nvim/charset.c", ["", "      if (wp->w_p_bri)", "        added += get_breakindent_win(wp, line);"], "readability/braces"]
["src/nvim/charset.c", ["  char_u *ptr;    // points to current char", "  char_u *posptr; // points to char at pos->col", "  char_u *line;   // start of the line"], "whitespace/comments"]
["src/nvim/charset.c", ["/// @return Pointer to the character after the skipped digits.", "const char* skipbin(const char *q)", "  FUNC_ATTR_PURE"], "whitespace/operators"]
["src/nvim/charset.c", ["///         characters.", "char_u* skiphex(char_u *q)", "{"], "whitespace/operators"]
["src/nvim/charset.c", ["/// @return Pointer to the digit or (NUL after the string).", "char_u* skiptodigit(char_u *q)", "{"], "whitespace/operators"]
["src/nvim/charset.c", ["/// @return Pointer to the binary character or (NUL after the string).", "const char* skiptobin(const char *q)", "  FUNC_ATTR_PURE"], "whitespace/operators"]
["src/nvim/charset.c", ["/// @return Pointer to the hex character or (NUL after the string).", "char_u* skiptohex(char_u *q)", "{"], "whitespace/operators"]
["src/nvim/charset.c", ["/// @return Pointer to the next whitespace character.", "char_u* skiptowhite_esc(char_u *p) {", "  while (*p != ' ' && *p != '\\t' && *p != NUL) {"], "readability/braces"]
["src/nvim/charset.c", ["/// @return Pointer to the next whitespace character.", "char_u* skiptowhite_esc(char_u *p) {", "  while (*p != ' ' && *p != '\\t' && *p != NUL) {"], "whitespace/operators"]
["src/nvim/charset.c", ["    if (((*p == '\\\\') || (*p == Ctrl_V)) && (*(p + 1) != NUL)) {", "      ++p;", "    }"], "readability/increment"]
["src/nvim/charset.c", ["    }", "    ++p;", "  }"], "readability/increment"]
["src/nvim/charset.c", ["{", "  for (; *p; ++p) {", "    if (rem_backslash(p)) {"], "readability/increment"]
["src/nvim/cursor.c", ["", "/*", " * Get the screen position of the cursor."], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "/*", " * Get the screen position of character col with a coladd in the cursor line."], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "/*", " * Go to column \"wcol\", and add/insert white space as necessary to get the"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["  } else {", "    /* Virtcol is valid */", "    curwin->w_valid |= VALID_VIRTCOL;"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "/*", " * Try to advance the Cursor to the specified screen column."], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "  if (wcol == MAXCOL || rc == FAIL)", "    curwin->w_valid &= ~VALID_VIRTCOL;"], "readability/braces"]
["src/nvim/cursor.c", ["    curwin->w_valid &= ~VALID_VIRTCOL;", "  else if (*get_cursor_pos_ptr() != TAB) {", "    /* Virtcol is valid when not on a TAB */"], "readability/braces"]
["src/nvim/cursor.c", ["  else if (*get_cursor_pos_ptr() != TAB) {", "    /* Virtcol is valid when not on a TAB */", "    curwin->w_valid |= VALID_VIRTCOL;"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["      curwin->w_curswant = linetabsize(line) + one_more;", "      if (curwin->w_curswant > 0)", "        --curwin->w_curswant;"], "readability/braces"]
["src/nvim/cursor.c", ["      if (curwin->w_curswant > 0)", "        --curwin->w_curswant;", "    }"], "readability/increment"]
["src/nvim/cursor.c", ["      csize = linetabsize(line);", "      if (csize > 0)", "        csize--;"], "readability/braces"]
["src/nvim/cursor.c", ["          && ((State & INSERT) == 0 || (int)wcol > csize + 1)) {", "        /* In case of line wrapping don't move the cursor beyond the", "         * right screen edge.  In Insert mode allow going just beyond"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["    while (col <= wcol && *ptr != NUL) {", "      /* Count a tab for what it's worth (if list mode not on) */", "      csize = win_lbr_chartabsize(curwin, line, ptr, col, &head);"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["    idx = (int)(ptr - line);", "    /*", "     * Handle all the special cases.  The virtual_active() check"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["      idx -= 1;", "      /* Don't count the chars from 'showbreak'. */", "      csize -= head;"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["        && ((col != wcol && col != wcol + 1) || csize > 1)) {", "      /* 'virtualedit' is set: The difference between wcol and col is", "       * filled with spaces. */"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["      if (line[idx] == NUL) {", "        /* Append spaces */", "        int correct = wcol - col;"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["      } else {", "        /* Break a tab */", "        int linelen = (int)STRLEN(line);"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["        int linelen = (int)STRLEN(line);", "        int correct = wcol - col - csize + 1;             /* negative!! */", "        char_u  *newline;"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "        if (-correct > csize)", "          return FAIL;"], "readability/braces"]
["src/nvim/cursor.c", ["", "  if (idx < 0)", "    pos->col = 0;"], "readability/braces"]
["src/nvim/cursor.c", ["    pos->col = 0;", "  else", "    pos->col = idx;"], "readability/braces"]
["src/nvim/cursor.c", ["    if (wcol == MAXCOL) {", "      /* The width of the last character is used to set coladd. */", "      if (!one_more) {"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "/*", " * Return in \"pos\" the position of the cursor advanced to screen column \"wcol\"."], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "/*", " * Increment the cursor position.  See inc() for return values."], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "/*", " * dec(p)"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "/*", " * Make sure curwin->w_cursor.lnum is valid."], "readability/old_style_comment"]
["src/nvim/cursor.c", ["  if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count) {", "    /* If there is a closed fold at the end of the file, put the cursor in", "     * its first line.  Otherwise in the last line. */"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["     * its first line.  Otherwise in the last line. */", "    if (!hasFolding(curbuf->b_ml.ml_line_count,", "            &curwin->w_cursor.lnum, NULL))"], "readability/braces"]
["src/nvim/cursor.c", ["    if (!hasFolding(curbuf->b_ml.ml_line_count,", "            &curwin->w_cursor.lnum, NULL))", "      curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;"], "whitespace/alignment"]
["src/nvim/cursor.c", ["  }", "  if (curwin->w_cursor.lnum <= 0)", "    curwin->w_cursor.lnum = 1;"], "readability/braces"]
["src/nvim/cursor.c", ["", "/*", " * Make sure curwin->w_cursor.col is valid."], "readability/old_style_comment"]
["src/nvim/cursor.c", ["  } else if (win->w_cursor.col >= len) {", "    /* Allow cursor past end-of-line when:", "     * - in Insert mode or restarting Insert mode"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "/*", " * make sure curwin->w_cursor in on a valid character"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "/*", " * Make sure curwin->w_cursor is not on the NUL at the end of the line."], "readability/old_style_comment"]
["src/nvim/cursor.c", ["{", "  if (curwin->w_cursor.col > 0", "      && (!VIsual_active || *p_sel == 'o')"], "readability/braces"]
["src/nvim/cursor.c", ["      && gchar_cursor() == NUL)", "    --curwin->w_cursor.col;", "}"], "readability/increment"]
["src/nvim/cursor.c", ["", "/*", " * When curwin->w_leftcol has changed, adjust the cursor position."], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "  /*", "   * If the cursor is right or left of the screen, move it to last or first"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "  /*", "   * If the start of the character under the cursor is not on the screen,"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["    retval = true;", "    if (coladvance(e + 1) == FAIL) {    /* there isn't another character */", "      curwin->w_leftcol = s;            /* adjust w_leftcol instead */"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["    if (coladvance(e + 1) == FAIL) {    /* there isn't another character */", "      curwin->w_leftcol = s;            /* adjust w_leftcol instead */", "      changed_cline_bef_curs();"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "  if (retval)", "    curwin->w_set_curswant = true;"], "readability/braces"]
["src/nvim/cursor.c", ["", "/*", " * Write a character at the current cursor position."], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "/*", " * Return pointer to cursor line."], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "/*", " * Return pointer to cursor position."], "readability/old_style_comment"]
["src/nvim/cursor_shape.c", ["  { \"replace\", 0, 0, 0, 700L, 400L, 250L, 0, 0, \"r\", SHAPE_CURSOR+SHAPE_MOUSE },", "  { \"cmdline_normal\", 0, 0, 0, 700L, 400L, 250L, 0, 0, \"c\", SHAPE_CURSOR+SHAPE_MOUSE },", "  { \"cmdline_insert\", 0, 0, 0, 700L, 400L, 250L, 0, 0, \"ci\", SHAPE_CURSOR+SHAPE_MOUSE },"], "whitespace/line_length"]
["src/nvim/cursor_shape.c", ["  { \"cmdline_normal\", 0, 0, 0, 700L, 400L, 250L, 0, 0, \"c\", SHAPE_CURSOR+SHAPE_MOUSE },", "  { \"cmdline_insert\", 0, 0, 0, 700L, 400L, 250L, 0, 0, \"ci\", SHAPE_CURSOR+SHAPE_MOUSE },", "  { \"cmdline_replace\", 0, 0, 0, 700L, 400L, 250L, 0, 0, \"cr\", SHAPE_CURSOR+SHAPE_MOUSE },"], "whitespace/line_length"]
["src/nvim/cursor_shape.c", ["  { \"cmdline_insert\", 0, 0, 0, 700L, 400L, 250L, 0, 0, \"ci\", SHAPE_CURSOR+SHAPE_MOUSE },", "  { \"cmdline_replace\", 0, 0, 0, 700L, 400L, 250L, 0, 0, \"cr\", SHAPE_CURSOR+SHAPE_MOUSE },", "  { \"operator\", 0, 0, 0, 700L, 400L, 250L, 0, 0, \"o\", SHAPE_CURSOR+SHAPE_MOUSE },"], "whitespace/line_length"]
["src/nvim/cursor_shape.c", ["  { \"cmdline_replace\", 0, 0, 0, 700L, 400L, 250L, 0, 0, \"cr\", SHAPE_CURSOR+SHAPE_MOUSE },", "  { \"operator\", 0, 0, 0, 700L, 400L, 250L, 0, 0, \"o\", SHAPE_CURSOR+SHAPE_MOUSE },", "  { \"visual_select\", 0, 0, 0, 700L, 400L, 250L, 0, 0, \"ve\", SHAPE_CURSOR+SHAPE_MOUSE },"], "whitespace/line_length"]
["src/nvim/cursor_shape.c", ["  { \"operator\", 0, 0, 0, 700L, 400L, 250L, 0, 0, \"o\", SHAPE_CURSOR+SHAPE_MOUSE },", "  { \"visual_select\", 0, 0, 0, 700L, 400L, 250L, 0, 0, \"ve\", SHAPE_CURSOR+SHAPE_MOUSE },", "  { \"cmdline_hover\", 0, 0, 0,   0L,   0L,   0L, 0, 0, \"e\", SHAPE_MOUSE },"], "whitespace/line_length"]
["src/nvim/cursor_shape.c", ["      PUT(dic, \"attr_id_lm\", INTEGER_OBJ(cur->id_lm ? syn_id2attr(cur->id_lm)", "                                                    : 0));", "    }"], "whitespace/alignment"]
["src/nvim/cursor_shape.c", ["          } else {", "            for (idx = 0; idx < SHAPE_IDX_COUNT; ++idx)", "              if (STRNICMP(modep, shape_table[idx].name, len) == 0)"], "readability/braces"]
["src/nvim/cursor_shape.c", ["          } else {", "            for (idx = 0; idx < SHAPE_IDX_COUNT; ++idx)", "              if (STRNICMP(modep, shape_table[idx].name, len) == 0)"], "readability/increment"]
["src/nvim/cursor_shape.c", ["            for (idx = 0; idx < SHAPE_IDX_COUNT; ++idx)", "              if (STRNICMP(modep, shape_table[idx].name, len) == 0)", "                break;"], "readability/braces"]
["src/nvim/cursor_shape.c", ["                break;", "            if (idx == SHAPE_IDX_COUNT", "                    || (shape_table[idx].used_for & what) == 0)"], "readability/braces"]
["src/nvim/cursor_shape.c", ["            if (idx == SHAPE_IDX_COUNT", "                    || (shape_table[idx].used_for & what) == 0)", "              return (char_u *)N_(\"E546: Illegal mode\");"], "whitespace/alignment"]
["src/nvim/cursor_shape.c", ["              return (char_u *)N_(\"E546: Illegal mode\");", "            if (len == 2 && modep[0] == 'v' && modep[1] == 'e')", "              found_ve = true;"], "readability/braces"]
["src/nvim/cursor_shape.c", ["", "        /* Parse the part after the colon */", "        for (p = colonp + 1; *p && *p != ','; ) {"], "readability/old_style_comment"]
["src/nvim/cursor_shape.c", ["          {", "            /*", "             * First handle the ones with a number argument."], "readability/old_style_comment"]
["src/nvim/cursor_shape.c", ["            len = 0;", "            if (STRNICMP(p, \"ver\", 3) == 0)", "              len = 3;"], "readability/braces"]
["src/nvim/cursor_shape.c", ["              len = 3;", "            else if (STRNICMP(p, \"hor\", 3) == 0)", "              len = 3;"], "readability/braces"]
["src/nvim/cursor_shape.c", ["              len = 3;", "            else if (STRNICMP(p, \"blinkwait\", 9) == 0)", "              len = 9;"], "readability/braces"]
["src/nvim/cursor_shape.c", ["              len = 9;", "            else if (STRNICMP(p, \"blinkon\", 7) == 0)", "              len = 7;"], "readability/braces"]
["src/nvim/cursor_shape.c", ["              len = 7;", "            else if (STRNICMP(p, \"blinkoff\", 8) == 0)", "              len = 8;"], "readability/braces"]
["src/nvim/cursor_shape.c", ["              p += len;", "              if (!ascii_isdigit(*p))", "                return (char_u *)N_(\"E548: digit expected\");"], "readability/braces"]
["src/nvim/cursor_shape.c", ["              } else if (round == 2) {", "                if (len == 9)", "                  shape_table[idx].blinkwait = n;"], "readability/braces"]
["src/nvim/cursor_shape.c", ["                  shape_table[idx].blinkwait = n;", "                else if (len == 7)", "                  shape_table[idx].blinkon = n;"], "readability/braces"]
["src/nvim/cursor_shape.c", ["                  shape_table[idx].blinkon = n;", "                else", "                  shape_table[idx].blinkoff = n;"], "readability/braces"]
["src/nvim/cursor_shape.c", ["            } else if (STRNICMP(p, \"block\", 5) == 0) {", "              if (round == 2)", "                shape_table[idx].shape = SHAPE_BLOCK;"], "readability/braces"]
["src/nvim/cursor_shape.c", ["              p += 5;", "            } else {          /* must be a highlight group name then */", "              endp = vim_strchr(p, '-');"], "readability/old_style_comment"]
["src/nvim/cursor_shape.c", ["              endp = vim_strchr(p, '-');", "              if (commap == NULL) {                       /* last part */", "                if (endp == NULL)"], "readability/old_style_comment"]
["src/nvim/cursor_shape.c", ["              if (commap == NULL) {                       /* last part */", "                if (endp == NULL)", "                  endp = p + STRLEN(p);                  /* find end of part */"], "readability/braces"]
["src/nvim/cursor_shape.c", ["                if (endp == NULL)", "                  endp = p + STRLEN(p);                  /* find end of part */", "              } else if (endp > commap || endp == NULL) {"], "readability/old_style_comment"]
["src/nvim/cursor_shape.c", ["              if (slashp != NULL && slashp < endp) {", "                /* \"group/langmap_group\" */", "                i = syn_check_group(p, (int)(slashp - p));"], "readability/old_style_comment"]
["src/nvim/cursor_shape.c", ["                shape_table[idx].id = syn_check_group(p,", "                    (int)(endp - p));", "                shape_table[idx].id_lm = shape_table[idx].id;"], "whitespace/alignment"]
["src/nvim/cursor_shape.c", ["                shape_table[idx].id_lm = shape_table[idx].id;", "                if (slashp != NULL && slashp < endp)", "                  shape_table[idx].id = i;"], "readability/braces"]
["src/nvim/cursor_shape.c", ["            }", "          }           /* if (what != SHAPE_MOUSE) */", ""], "readability/old_style_comment"]
["src/nvim/cursor_shape.c", ["", "          if (*p == '-')", "            ++p;"], "readability/braces"]
["src/nvim/cursor_shape.c", ["          if (*p == '-')", "            ++p;", "        }"], "readability/increment"]
["src/nvim/cursor_shape.c", ["", "  /* If the 's' flag is not given, use the 'v' cursor for 's' */", "  if (!found_ve) {"], "readability/old_style_comment"]
["src/nvim/diff.c", ["{", "", "  if (!win->w_p_diff) {"], "whitespace/blank_line"]
["src/nvim/diff.c", ["  int i;", "  for (i = 0; i < DB_COUNT; ++i) {", "    if (curtab->tp_diffbuf[i] == NULL) {"], "readability/increment"]
["src/nvim/diff.c", ["  int idx;", "  for (idx = 0; idx < DB_COUNT; ++idx) {", "    if (curtab->tp_diffbuf[idx] == buf) {"], "readability/increment"]
["src/nvim/diff.c", ["  int idx;", "  for (idx = 0; idx < DB_COUNT; ++idx) {", "    if (tp->tp_diffbuf[idx] == buf) {"], "readability/increment"]
["src/nvim/diff.c", ["  linenr_T last;", "  linenr_T lnum_deleted = line1; // lnum of remaining deletion", "  int n;"], "whitespace/comments"]
["src/nvim/diff.c", ["      int i;", "      for (i = 0; i < DB_COUNT; ++i) {", "        if ((tp->tp_diffbuf[i] != NULL) && (i != idx)) {"], "readability/increment"]
["src/nvim/diff.c", ["          int i;", "          for (i = 0; i < DB_COUNT; ++i) {", "            if ((tp->tp_diffbuf[i] != NULL) && (i != idx)) {"], "readability/increment"]
["src/nvim/diff.c", ["          //", "          // TODO: also check for equal lines in the middle and perhaps split", "          // the block."], "readability/todo"]
["src/nvim/diff.c", ["      int i;", "      for (i = 0; i < DB_COUNT; ++i) {", "        if (tp->tp_diffbuf[i] != NULL) {"], "readability/increment"]
["src/nvim/diff.c", ["    int i;", "    for (i = 0; i < DB_COUNT; ++i) {", "      if ((tp->tp_diffbuf[i] != NULL) && (dp->df_count[i] != 0)) {"], "readability/increment"]
["src/nvim/diff.c", ["/// @return The new diff block.", "static diff_T* diff_alloc_new(tabpage_T *tp, diff_T *dprev, diff_T *dp)", "{"], "whitespace/operators"]
["src/nvim/diff.c", ["  int i_org;", "  for (i_org = 0; i_org < DB_COUNT; ++i_org) {", "    if (tp->tp_diffbuf[i_org] != NULL) {"], "readability/increment"]
["src/nvim/diff.c", ["      int i_new;", "      for (i_new = i_org + 1; i_new < DB_COUNT; ++i_new) {", "        if (tp->tp_diffbuf[i_new] == NULL) {"], "readability/increment"]
["src/nvim/diff.c", ["      // Line matched in all buffers, remove it from the diff.", "      for (i_new = i_org; i_new < DB_COUNT; ++i_new) {", "        if (tp->tp_diffbuf[i_new] != NULL) {"], "readability/increment"]
["src/nvim/diff.c", ["  int i;", "  for (i = 0; i < DB_COUNT; ++i) {", "    if (tp->tp_diffbuf[i] != NULL) {"], "readability/increment"]
["src/nvim/diff.c", ["  int idx_orig;", "  for (idx_orig = 0; idx_orig < DB_COUNT; ++idx_orig) {", "    if (curtab->tp_diffbuf[idx_orig] != NULL) {"], "readability/increment"]
["src/nvim/diff.c", ["  int idx_new;", "  for (idx_new = idx_orig + 1; idx_new < DB_COUNT; ++idx_new) {", "    if (curtab->tp_diffbuf[idx_new] != NULL) {"], "readability/increment"]
["src/nvim/diff.c", ["                 tmp_orig, tmp_new);", "    append_redir(cmd, len, (char *) p_srr, tmp_diff);", "    block_autocmds();  // Avoid ShellCmdPost stuff"], "whitespace/cast"]
["src/nvim/diff.c", ["    block_autocmds();  // Avoid ShellCmdPost stuff", "    (void)call_shell((char_u *) cmd,", "                     kShellOptFilter | kShellOptSilent | kShellOptDoOut,"], "whitespace/cast"]
["src/nvim/diff.c", ["      if (off > 0) {", "        for (i = idx_orig; i < idx_new; ++i) {", "          if (curtab->tp_diffbuf[i] != NULL) {"], "readability/increment"]
["src/nvim/diff.c", ["", "      for (i = idx_orig; i < idx_new; ++i) {", "        if (curtab->tp_diffbuf[i] != NULL) {"], "readability/increment"]
["src/nvim/diff.c", ["      // already.", "      for (i = idx_orig + 1; i < idx_new; ++i) {", "        if (curtab->tp_diffbuf[i] != NULL) {"], "readability/increment"]
["src/nvim/diff.c", ["{", "  int idx; // index in tp_diffbuf[] for this buffer", "  diff_T *dp;"], "whitespace/comments"]
["src/nvim/diff.c", ["", "    for (i = 0; i < DB_COUNT; ++i) {", "      if ((i != idx) && (curtab->tp_diffbuf[i] != NULL)) {"], "readability/increment"]
["src/nvim/diff.c", ["      // in some buffers, deleted in others, but not changed.", "      for (i = 0; i < DB_COUNT; ++i) {", "        if ((i != idx)"], "readability/increment"]
["src/nvim/diff.c", ["  maxcount = 0;", "  for (i = 0; i < DB_COUNT; ++i) {", "    if ((curtab->tp_diffbuf[i] != NULL) && (dp->df_count[i] > maxcount)) {"], "readability/increment"]
["src/nvim/diff.c", ["", "      for (i = 0; i < DB_COUNT; ++i) {", "        if ((curtab->tp_diffbuf[i] != NULL) && (max_count < dp->df_count[i])) {"], "readability/increment"]
["src/nvim/diff.c", ["    if (*p == ',') {", "      ++p;", "    }"], "readability/increment"]
["src/nvim/diff.c", ["  int i;", "  for (i = 0; i < DB_COUNT; ++i) {", "    if ((curtab->tp_diffbuf[i] != NULL) && (i != idx)) {"], "readability/increment"]
["src/nvim/diff.c", ["  int i;", "  for (i = 0; i < DB_COUNT; ++i) {", "    if (curtab->tp_diffbuf[i] == wp->w_buffer) {"], "readability/increment"]
["src/nvim/diff.c", ["  } else {", "    vim_snprintf(buf, 30, \"%zu\", count);", "    ea.arg = (char_u *)buf;"], "runtime/printf"]
["src/nvim/diff.c", ["    // No argument: Find the other buffer in the list of diff buffers.", "    for (idx_other = 0; idx_other < DB_COUNT; ++idx_other) {", "      if ((curtab->tp_diffbuf[idx_other] != curbuf)"], "readability/increment"]
["src/nvim/diff.c", ["    // Check that there isn't a third buffer in the list", "    for (i = idx_other + 1; i < DB_COUNT; ++i) {", "      if ((curtab->tp_diffbuf[i] != curbuf)"], "readability/increment"]
["src/nvim/diff.c", ["          && ((eap->cmdidx != CMD_diffput)", "            || MODIFIABLE(curtab->tp_diffbuf[i]))) {", "        EMSG(_(\"E101: More than two buffers in diff mode, don't know \""], "whitespace/alignment"]
["src/nvim/diff.c", ["          && ((eap->cmdidx != CMD_diffput)", "            || MODIFIABLE(curtab->tp_diffbuf[i]))) {", "        EMSG(_(\"E101: More than two buffers in diff mode, don't know \""], "whitespace/alignment"]
["src/nvim/diff.c", ["", "    for (i = 0; ascii_isdigit(eap->arg[i]) && eap->arg + i < p; ++i) {", "    }"], "readability/increment"]
["src/nvim/diff.c", ["        && ((eap->line1 == 1) || (diff_check(curwin, eap->line1 - 1) == 0))) {", "      ++eap->line2;", "    } else if (eap->line1 > 0) {"], "readability/increment"]
["src/nvim/diff.c", ["    } else if (eap->line1 > 0) {", "      --eap->line1;", "    }"], "readability/increment"]
["src/nvim/diff.c", ["", "      for (i = 0; i < count; ++i) {", "        // remember deleting the last line of the buffer"], "readability/increment"]
["src/nvim/diff.c", ["", "      for (i = 0; i < dp->df_count[idx_from] - start_skip - end_skip; ++i) {", "        linenr_T nr = dp->df_lnum[idx_from] + start_skip + i;"], "readability/increment"]
["src/nvim/diff.c", ["        // equal in them.", "        for (i = 0; i < DB_COUNT; ++i) {", "          if ((curtab->tp_diffbuf[i] != NULL)"], "readability/increment"]
["src/nvim/diff.c", ["  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {", "    for (int i = 0; i < DB_COUNT; ++i) {", "      if ((curtab->tp_diffbuf[i] == wp->w_buffer) && (i != skip_idx)) {"], "readability/increment"]
["src/nvim/digraph.c", ["// digraphs added by the user", "static garray_T user_digraphs = {0, 0, (int)sizeof(digr_T), 10, NULL};", ""], "whitespace/braces"]
["src/nvim/digraph.c", ["// digraphs added by the user", "static garray_T user_digraphs = {0, 0, (int)sizeof(digr_T), 10, NULL};", ""], "whitespace/braces"]
["src/nvim/digraph.c", ["{", "  { 'N', 'U', 0x0a }, // LF for NUL", "  { 'S', 'H', 0x01 },"], "whitespace/comments"]
["src/nvim/digraph.c", ["{", "  static int backspaced; // character before K_BS", "  static int lastchar;   // last typed character"], "whitespace/comments"]
["src/nvim/digraph.c", ["  digr_T *dp = (digr_T *)user_digraphs.ga_data;", "  for (int i = 0; i < user_digraphs.ga_len; ++i) {", "    if (((int) dp->char1 == char1) && ((int) dp->char2 == char2)) {"], "readability/increment"]
["src/nvim/digraph.c", ["  for (int i = 0; i < user_digraphs.ga_len; ++i) {", "    if (((int) dp->char1 == char1) && ((int) dp->char2 == char2)) {", "      retval = dp->result;"], "whitespace/cast"]
["src/nvim/digraph.c", ["    }", "    ++dp;", "  }"], "readability/increment"]
["src/nvim/digraph.c", ["", "    for (int i = 0; dp->char1 != 0; ++i) {", "      if (((int) dp->char1 == char1) && ((int) dp->char2 == char2)) {"], "readability/increment"]
["src/nvim/digraph.c", ["    for (int i = 0; dp->char1 != 0; ++i) {", "      if (((int) dp->char1 == char1) && ((int) dp->char2 == char2)) {", "        retval = dp->result;"], "whitespace/cast"]
["src/nvim/digraph.c", ["      }", "      ++dp;", "    }"], "readability/increment"]
["src/nvim/digraph.c", ["    int i;", "    for (i = 0; i < user_digraphs.ga_len; ++i) {", "      if (((int)dp->char1 == char1) && ((int)dp->char2 == char2)) {"], "readability/increment"]
["src/nvim/digraph.c", ["      }", "      ++dp;", "    }"], "readability/increment"]
["src/nvim/digraph.c", ["", "  for (int i = 0; dp->char1 != NUL && !got_int; ++i) {", "    digr_T tmp;"], "readability/increment"]
["src/nvim/digraph.c", ["    assert(p >= buf);", "    vim_snprintf((char *)p, sizeof(buf) - (size_t)(p - buf), \" %3d\", dp->result);", "    msg_outtrans(buf);"], "whitespace/line_length"]
["src/nvim/digraph.c", ["///         been checked.", "char_u* keymap_init(void)", "{"], "whitespace/operators"]
["src/nvim/digraph.c", ["        xfree(kp->to);", "        --curbuf->b_kmap_ga.ga_len;", "      }"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * edit.c: functions for Insert mode"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Structure used to store one match for insert completion."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * All the current matches are stored in a list."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/* After using a cursor key <Enter> selects a match in the popup menu,", " * otherwise it inserts a line break. */"], "readability/old_style_comment"]
["src/nvim/edit.c", [" * otherwise it inserts a line break. */", "static int compl_enter_selects = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["", "/* When \"compl_leader\" is not NULL only matches that start with this string", " * are used. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "static int compl_get_longest = FALSE;           /* put longest common string", "                                                   in compl_leader */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["", "static int compl_get_longest = FALSE;           /* put longest common string", "                                                   in compl_leader */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "static int compl_get_longest = FALSE;           /* put longest common string", "                                                   in compl_leader */"], "readability/bool"]
["src/nvim/edit.c", ["", "static int compl_no_insert = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noinsert */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["", "static int compl_no_insert = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noinsert */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "static int compl_no_insert = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noinsert */"], "readability/bool"]
["src/nvim/edit.c", ["static int compl_no_insert = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noinsert */", "static int compl_no_select = FALSE;             /* FALSE: select & insert"], "readability/bool"]
["src/nvim/edit.c", ["                                                   TRUE: noinsert */", "static int compl_no_select = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noselect */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["                                                   TRUE: noinsert */", "static int compl_no_select = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noselect */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["                                                   TRUE: noinsert */", "static int compl_no_select = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noselect */"], "readability/bool"]
["src/nvim/edit.c", ["static int compl_no_select = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noselect */", ""], "readability/bool"]
["src/nvim/edit.c", ["", "static int compl_was_interrupted = FALSE;         /* didn't finish finding", "                                                     completions. */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["", "static int compl_was_interrupted = FALSE;         /* didn't finish finding", "                                                     completions. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "static int compl_was_interrupted = FALSE;         /* didn't finish finding", "                                                     completions. */"], "readability/bool"]
["src/nvim/edit.c", ["static pos_T compl_startpos;", "static colnr_T compl_col = 0;               /* column where the text starts", "                                             * that is being completed */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["static pos_T compl_startpos;", "static colnr_T compl_col = 0;               /* column where the text starts", "                                             * that is being completed */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["                                             * that is being completed */", "static char_u     *compl_orig_text = NULL;  /* text as it was before", "                                             * completion started */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["                                             * that is being completed */", "static char_u     *compl_orig_text = NULL;  /* text as it was before", "                                             * completion started */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "static int compl_opt_refresh_always = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["", "    set_vim_var_string(VV_INSERTMODE, (char *) s->ptr, 1);", "    set_vim_var_string(VV_CHAR, NULL, -1);"], "whitespace/cast"]
["src/nvim/edit.c", ["      if (curwin->w_topfill > 0) {", "        --curwin->w_topfill;", "      } else if (hasFolding(curwin->w_topline, NULL, &s->old_topline)) {"], "readability/increment"]
["src/nvim/edit.c", ["", "  if (curwin->w_p_rl)", "    switch (s->c) {"], "readability/braces"]
["src/nvim/edit.c", ["      // then don't insert any character.", "      if (s->c == NUL)", "        break;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Redraw for Insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  if (char_avail())", "    return;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Handle a CTRL-V or CTRL-Q typed in Insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Put a character directly onto the screen.  It's not stored in a buffer."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Undo the previous edit_putchar()."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Called when p_dollar is set: display a '$' at the end of the changed text"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  if (!redrawing())", "    return;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Call this function before moving the cursor from the normal insert position"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Insert an indent (for <Tab> or CTRL-T) or delete an indent (for CTRL-D)."], "readability/old_style_comment"]
["src/nvim/edit.c", ["void", "change_indent (", "    int type,"], "whitespace/parens"]
["src/nvim/edit.c", ["  save_p_list = curwin->w_p_list;", "  curwin->w_p_list = FALSE;", "  vc = getvcol_nolist(&curwin->w_cursor);"], "readability/bool"]
["src/nvim/edit.c", ["", "  /*", "   * For Replace mode we need to fix the replace stack later, which is only"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * If the cursor is in the indent, compute how many screen columns the"], "readability/old_style_comment"]
["src/nvim/edit.c", ["   */", "  if (new_cursor_col < 0)", "    vcol = get_indent() - vcol;"], "readability/braces"]
["src/nvim/edit.c", ["", "  /*", "   * Set the new indent.  The cursor will be put on the first non-blank."], "readability/old_style_comment"]
["src/nvim/edit.c", ["   */", "  if (type == INDENT_SET)", "    (void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);"], "readability/braces"]
["src/nvim/edit.c", ["    (void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);", "  else {", "    int save_State = State;"], "readability/braces"]
["src/nvim/edit.c", ["    (void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);", "  else {", "    int save_State = State;"], "readability/braces"]
["src/nvim/edit.c", ["", "  /*", "   * Try to put cursor on same character."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (new_cursor_col >= 0) {", "    /*", "     * When changing the indent while the cursor is touching it, reset"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     */", "    if (new_cursor_col == 0)", "      insstart_less = MAXCOL;"], "readability/braces"]
["src/nvim/edit.c", ["    new_cursor_col += curwin->w_cursor.col;", "  } else if (!(State & INSERT))", "    new_cursor_col = curwin->w_cursor.col;"], "readability/braces"]
["src/nvim/edit.c", ["    new_cursor_col = curwin->w_cursor.col;", "  else {", "    /*"], "readability/braces"]
["src/nvim/edit.c", ["    new_cursor_col = curwin->w_cursor.col;", "  else {", "    /*"], "readability/braces"]
["src/nvim/edit.c", ["  else {", "    /*", "     * Compute the screen column where the cursor should be."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * Advance the cursor until we reach the right screen column."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * May need to insert spaces to be able to position the cursor on"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * When changing the indent while the cursor is in it, reset"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  if (new_cursor_col <= 0)", "    curwin->w_cursor.col = 0;"], "readability/braces"]
["src/nvim/edit.c", ["    curwin->w_cursor.col = 0;", "  else", "    curwin->w_cursor.col = (colnr_T)new_cursor_col;"], "readability/braces"]
["src/nvim/edit.c", ["    curwin->w_cursor.col = (colnr_T)new_cursor_col;", "  curwin->w_set_curswant = TRUE;", "  changed_cline_bef_curs();"], "readability/bool"]
["src/nvim/edit.c", ["", "  /*", "   * May have to adjust the start of the insert."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    if (curwin->w_cursor.lnum == Insstart.lnum && Insstart.col != 0) {", "      if ((int)Insstart.col <= insstart_less)", "        Insstart.col = 0;"], "readability/braces"]
["src/nvim/edit.c", ["        Insstart.col = 0;", "      else", "        Insstart.col -= insstart_less;"], "readability/braces"]
["src/nvim/edit.c", ["    }", "    if ((int)ai_col <= insstart_less)", "      ai_col = 0;"], "readability/braces"]
["src/nvim/edit.c", ["      ai_col = 0;", "    else", "      ai_col -= insstart_less;"], "readability/braces"]
["src/nvim/edit.c", ["", "  /*", "   * For REPLACE mode, may have to fix the replace stack, if it's possible."], "readability/old_style_comment"]
["src/nvim/edit.c", ["      }", "      ++start_col;", "    }"], "readability/increment"]
["src/nvim/edit.c", ["", "  /*", "   * For VREPLACE mode, we also have to fix the replace stack.  In this case"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Truncate the space at the end of a line.  This is to be used only in an"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Backspace the cursor until the given column.  Handles REPLACE and VREPLACE"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    curwin->w_cursor.col--;", "    if (State & REPLACE_FLAG)", "      replace_do_bs(col);"], "readability/braces"]
["src/nvim/edit.c", ["      replace_do_bs(col);", "    else if (!del_char_after_col(col))", "      break;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * CTRL-X pressed in Insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["{", "  /* CTRL-X after CTRL-X CTRL-V doesn't do anything, so that CTRL-X", "   * CTRL-V works like CTRL-N */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (ctrl_x_mode != CTRL_X_CMDLINE) {", "    /* if the next ^X<> won't ADD nothing, then reset", "     * compl_cont_status */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     * compl_cont_status */", "    if (compl_cont_status & CONT_N_ADDS)", "      compl_cont_status |= CONT_INTRPT;"], "readability/braces"]
["src/nvim/edit.c", ["      compl_cont_status |= CONT_INTRPT;", "    else", "      compl_cont_status = 0;"], "readability/braces"]
["src/nvim/edit.c", ["", "    /* \"actual_len\" may be smaller than \"actual_compl_length\" when using", "     * thesaurus, only use the minimum when comparing. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * Rule 2: No lower case, 2nd consecutive letter converted to"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * If the same match is already present, don't add it."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Allocate a new match structure."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Link the new match structure in the list of matches."], "readability/old_style_comment"]
["src/nvim/edit.c", ["   */", "  if (compl_first_match == NULL)", "    match->cp_next = match->cp_prev = NULL;"], "readability/braces"]
["src/nvim/edit.c", ["    match->cp_next = match->cp_prev = NULL;", "  else if (dir == FORWARD) {", "    match->cp_next = compl_curr_match->cp_next;"], "readability/braces"]
["src/nvim/edit.c", ["", "  /*", "   * Find the longest common string if still doing that."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Reduce the longest common string for match \"match\"."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    ins_bytes(compl_leader + ins_compl_len());", "    ins_redraw(FALSE);", ""], "readability/bool"]
["src/nvim/edit.c", ["", "    /* When the match isn't there (to avoid matching itself) remove it", "     * again after redrawing. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     * again after redrawing. */", "    if (!had_match)", "      ins_compl_delete();"], "readability/braces"]
["src/nvim/edit.c", ["      ins_bytes(compl_leader + ins_compl_len());", "      ins_redraw(FALSE);", ""], "readability/bool"]
["src/nvim/edit.c", ["", "      /* When the match isn't there (to avoid matching itself) remove it", "       * again after redrawing. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["       * again after redrawing. */", "      if (!had_match)", "        ins_compl_delete();"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Add an array of matches to the list of matches."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/* Make the completion list cyclic.", " * Return the number of matches (excluding the original)."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (compl_first_match != NULL) {", "    /*", "     * Find the end of the list."], "readability/old_style_comment"]
["src/nvim/edit.c", ["      match = match->cp_next;", "      ++count;", "    }"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * Start completion for the complete() function."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  compl_direction = FORWARD;", "  if (startcol > curwin->w_cursor.col)", "    startcol = curwin->w_cursor.col;"], "readability/braces"]
["src/nvim/edit.c", ["", "/* \"compl_match_array\" points the currently displayed list of entries in the", " * popup menu.  It is NULL when there is no popup menu. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Remove any popup menu."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  if (!pum_wanted() || !pum_enough_matches())", "    return;"], "readability/braces"]
["src/nvim/edit.c", ["    } while (compl != NULL && compl != compl_first_match);", "    if (compl_match_arraysize == 0)", "      return;"], "readability/braces"]
["src/nvim/edit.c", ["    compl_match_array = xcalloc(compl_match_arraysize, sizeof(pumitem_T));", "    /* If the current match is the original text don't find the first", "     * match after it, don't highlight anything. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["          if (compl == compl_shown_match || did_find_shown_match) {", "            /* This item is the shown match or this is the", "             * first displayed item after the shown match. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "        if (compl->cp_text[CPT_ABBR] != NULL)", "          compl_match_array[i].pum_text ="], "readability/braces"]
["src/nvim/edit.c", ["            compl->cp_text[CPT_ABBR];", "        else", "          compl_match_array[i].pum_text = compl->cp_str;"], "readability/braces"]
["src/nvim/edit.c", ["        compl_match_array[i].pum_info = compl->cp_text[CPT_INFO];", "        if (compl->cp_text[CPT_MENU] != NULL)", "          compl_match_array[i++].pum_extra ="], "readability/braces"]
["src/nvim/edit.c", ["            compl->cp_text[CPT_MENU];", "        else", "          compl_match_array[i++].pum_extra = compl->cp_fname;"], "readability/braces"]
["src/nvim/edit.c", ["", "        /* When the original text is the shown match don't set", "         * compl_shown_match. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        if (!shown_match_ok && shown_compl != NULL) {", "          /* The shown match isn't displayed, set it to the", "           * previously displayed match. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Add any identifiers that match the given pattern in the list of dictionary"], "readability/old_style_comment"]
["src/nvim/edit.c", ["static void", "ins_compl_dictionaries (", "    char_u *dict_start,"], "whitespace/parens"]
["src/nvim/edit.c", ["  if (*dict == NUL) {", "    /* When 'dictionary' is empty and spell checking is enabled use", "     * \"spell\". */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     * \"spell\". */", "    if (!thesaurus && curwin->w_p_spell)", "      dict = (char_u *)\"spell\";"], "readability/braces"]
["src/nvim/edit.c", ["      dict = (char_u *)\"spell\";", "    else", "      return;"], "readability/braces"]
["src/nvim/edit.c", ["  save_p_scs = p_scs;", "  if (curbuf->b_p_inf)", "    p_scs = FALSE;"], "readability/braces"]
["src/nvim/edit.c", ["  if (curbuf->b_p_inf)", "    p_scs = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["", "  /* When invoked to match whole lines for CTRL-X CTRL-L adjust the pattern", "   * to only match at the start of a line.  Otherwise just match the"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    regmatch.regprog = vim_regcomp(pat, p_magic ? RE_MAGIC : 0);", "    if (regmatch.regprog == NULL)", "      goto theend;"], "readability/braces"]
["src/nvim/edit.c", ["    } else {", "      /* Expand wildcards in the dictionary name, but do not allow", "       * backticks (for security, the 'dict' option may have been set in"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      copy_option_part(&dict, buf, LSIZE, \",\");", "      if (!thesaurus && STRCMP(buf, \"spell\") == 0)", "        count = -1;"], "readability/braces"]
["src/nvim/edit.c", ["        count = -1;", "      else if (vim_strchr(buf, '`') != NULL", "               || expand_wildcards(1, &buf, &count, &files,"], "readability/braces"]
["src/nvim/edit.c", ["               || expand_wildcards(1, &buf, &count, &files,", "                   EW_FILE|EW_SILENT) != OK)", "        count = 0;"], "whitespace/alignment"]
["src/nvim/edit.c", ["               || expand_wildcards(1, &buf, &count, &files,", "                   EW_FILE|EW_SILENT) != OK)", "        count = 0;"], "whitespace/alignment"]
["src/nvim/edit.c", ["    if (count == -1) {", "      /* Complete from active spelling.  Skip \"\\<\" in the pattern, we", "       * don't use it as a RE. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["       * don't use it as a RE. */", "      if (pat[0] == '\\\\' && pat[1] == '<')", "        ptr = pat + 2;"], "readability/braces"]
["src/nvim/edit.c", ["        ptr = pat + 2;", "      else", "        ptr = pat;"], "readability/braces"]
["src/nvim/edit.c", ["      ins_compl_files(count, files, thesaurus, flags,", "          &regmatch, buf, &dir);", "      if (flags != DICT_EXACT)"], "whitespace/alignment"]
["src/nvim/edit.c", ["          &regmatch, buf, &dir);", "      if (flags != DICT_EXACT)", "        FreeWild(count, files);"], "readability/braces"]
["src/nvim/edit.c", ["    }", "    if (flags != 0)", "      break;"], "readability/braces"]
["src/nvim/edit.c", ["    }", "    /*", "     * Read dictionary file line by line."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "          /*", "           * Add the other matches on the line"], "readability/old_style_comment"]
["src/nvim/edit.c", ["          while (!got_int) {", "            /* Find start of the next word.  Skip white", "             * space and punctuation. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["            ptr = find_word_start(ptr);", "            if (*ptr == NUL || *ptr == NL)", "              break;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Find the start of the next word."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Find the end of the word.  Assumes it starts inside a word."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Find the end of the line, omitting CR and NL at the end."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  s = ptr + STRLEN(ptr);", "  while (s > ptr && (s[-1] == CAR || s[-1] == NL))", "    --s;"], "readability/braces"]
["src/nvim/edit.c", ["  while (s > ptr && (s[-1] == CAR || s[-1] == NL))", "    --s;", "  return s;"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * Free the list of completions"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  if (compl_first_match == NULL)", "    return;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Delete one character before the cursor and show the subset of the matches"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /* Deleted more than what was used to find matches or didn't finish", "   * finding all matches: need to look for matches all over again. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["   * finding all matches: need to look for matches all over again. */", "  if (curwin->w_cursor.col <= compl_col + compl_length", "      || ins_compl_need_restart())"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Called after changing \"compl_leader\"."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /* Don't let Enter select the original text when there is no popup menu.", "   * Don't let Enter select when use user function and refresh_always is set */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["   * Don't let Enter select when use user function and refresh_always is set */", "  if (compl_match_array == NULL || ins_compl_need_restart())", "    compl_enter_selects = FALSE;"], "readability/braces"]
["src/nvim/edit.c", ["  if (compl_match_array == NULL || ins_compl_need_restart())", "    compl_enter_selects = FALSE;", "}"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * Return the length of the completion, from the completion start column to"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  if (off < 0)", "    return 0;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Append one character to the match leader.  May reduce the number of"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Setup for finding completions again without leaving CTRL-X mode.  Used when"], "readability/old_style_comment"]
["src/nvim/edit.c", ["{", "  /* update screen before restart.", "   * so if complete is blocked,"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Set the first match, the original text."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Append one character to the match leader.  May reduce the number of"], "readability/old_style_comment"]
["src/nvim/edit.c", ["            || ins_compl_equal(cp, compl_leader,", "                (int)STRLEN(compl_leader))) {", "          p = cp->cp_str;"], "whitespace/alignment"]
["src/nvim/edit.c", ["            || ins_compl_equal(cp, compl_leader,", "                (int)STRLEN(compl_leader))) {", "          p = cp->cp_str;"], "whitespace/alignment"]
["src/nvim/edit.c", ["      }", "      if (p == NULL || (int)STRLEN(p) <= len)", "        return;"], "readability/braces"]
["src/nvim/edit.c", ["        return;", "    } else", "      return;"], "readability/braces"]
["src/nvim/edit.c", ["", "  /* Forget any previous 'special' messages if this is actually", "   * a ^X mode key - bar ^R, in which case we wait to see what it gives us."], "readability/old_style_comment"]
["src/nvim/edit.c", ["   */", "  if (c != Ctrl_R && vim_is_ctrl_x_key(c))", "    edit_submode_extra = NULL;"], "readability/braces"]
["src/nvim/edit.c", ["  if (ctrl_x_mode == CTRL_X_NOT_DEFINED_YET) {", "    /*", "     * We have just typed CTRL-X and aren't quite sure which CTRL-X mode"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      ctrl_x_mode = CTRL_X_SCROLL;", "      if (!(State & REPLACE_FLAG))", "        edit_submode = (char_u *)_(\" (insert) Scroll (^E/^Y)\");"], "readability/braces"]
["src/nvim/edit.c", ["        edit_submode = (char_u *)_(\" (insert) Scroll (^E/^Y)\");", "      else", "        edit_submode = (char_u *)_(\" (replace) Scroll (^E/^Y)\");"], "readability/braces"]
["src/nvim/edit.c", ["    case Ctrl_N:", "      /* ^X^P means LOCAL expansion if nothing interrupted (eg we", "       * just started ^X mode, or there were enough ^X's to cancel"], "readability/old_style_comment"]
["src/nvim/edit.c", ["       * doesn't change when going to ADDING mode  -- Acevedo */", "      if (!(compl_cont_status & CONT_INTRPT))", "        compl_cont_status |= CONT_LOCAL;"], "readability/braces"]
["src/nvim/edit.c", ["        compl_cont_status |= CONT_LOCAL;", "      else if (compl_cont_mode != 0)", "        compl_cont_status &= ~CONT_LOCAL;"], "readability/braces"]
["src/nvim/edit.c", ["    default:", "      /* If we have typed at least 2 ^X's... for modes != 0, we set", "       * compl_cont_status = 0 (eg, as if we had just started ^X"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      if (c == Ctrl_X) {", "        if (compl_cont_mode != 0)", "          compl_cont_status = 0;"], "readability/braces"]
["src/nvim/edit.c", ["          compl_cont_status = 0;", "        else", "          compl_cont_mode = CTRL_X_NOT_DEFINED_YET;"], "readability/braces"]
["src/nvim/edit.c", ["  if (compl_started || ctrl_x_mode == CTRL_X_FINISHED) {", "    /* Show error message from attempted keyword completion (probably", "     * 'Pattern not found') until another key is hit, then go back to"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        || ctrl_x_mode == CTRL_X_FINISHED) {", "      /* Get here when we have finished typing a sequence of ^N and", "       * ^P or other completion characters in CTRL-X mode.  Free up"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      if (compl_curr_match != NULL || compl_leader != NULL || c == Ctrl_E) {", "        /*", "         * If any of the original typed text has been changed, eg when"], "readability/old_style_comment"]
["src/nvim/edit.c", ["         */", "        if (compl_curr_match != NULL && compl_used_match && c != Ctrl_E)", "          ptr = compl_curr_match->cp_str;"], "readability/braces"]
["src/nvim/edit.c", ["          ptr = compl_curr_match->cp_str;", "        else", "          ptr = NULL;"], "readability/braces"]
["src/nvim/edit.c", ["", "      /*", "       * Indent now if a key was typed that is in 'cinkeys'."], "readability/old_style_comment"]
["src/nvim/edit.c", ["       */", "      if (want_cindent && in_cinkeys(KEY_COMPLETE, ' ', inindent(0)))", "        do_c_expr_indent();"], "readability/braces"]
["src/nvim/edit.c", ["    }", "  } else if (ctrl_x_mode == CTRL_X_LOCAL_MSG)", "    /* Trigger the CompleteDone event to give scripts a chance to act"], "readability/braces"]
["src/nvim/edit.c", ["  } else if (ctrl_x_mode == CTRL_X_LOCAL_MSG)", "    /* Trigger the CompleteDone event to give scripts a chance to act", "     * upon the (possibly failed) completion. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /* reset continue_* if we left expansion-mode, if we stay they'll be", "   * (re)set properly in ins_complete() */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Fix the redo buffer for the completion leader replacing some of the typed"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Loops through the list of windows, loaded-buffers or non-loaded-buffers"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    assert(wp);", "    while ((wp = (wp->w_next != NULL ? wp->w_next : firstwin)) != curwin", "           && wp->w_buffer->b_scanned)"], "readability/braces"]
["src/nvim/edit.c", ["           && wp->w_buffer->b_scanned)", "      ;", "    buf = wp->w_buffer;"], "whitespace/semicolon"]
["src/nvim/edit.c", ["    buf = wp->w_buffer;", "  } else", "    /* 'b' (just loaded buffers), 'u' (just non-loaded buffers) or 'U'"], "readability/braces"]
["src/nvim/edit.c", ["  } else", "    /* 'b' (just loaded buffers), 'u' (just non-loaded buffers) or 'U'", "     * (unlisted buffers)"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     * When completing whole lines skip unloaded buffers. */", "    while ((buf = (buf->b_next != NULL ? buf->b_next : firstbuf)) != curbuf", "           && ((flag == 'U'"], "readability/braces"]
["src/nvim/edit.c", ["               || buf->b_scanned))", "      ;", "  return buf;"], "whitespace/semicolon"]
["src/nvim/edit.c", ["", "  if (matchlist != NULL)", "    ins_compl_add_list(matchlist);"], "readability/braces"]
["src/nvim/edit.c", ["    ins_compl_add_list(matchlist);", "  else if (matchdict != NULL)", "    ins_compl_add_dict(matchdict);"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Add completions from a list."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Add completions from a dict."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    }", "    found_all = FALSE;", "    ins_buf = curbuf;"], "readability/bool"]
["src/nvim/edit.c", ["    found_new_match = FAIL;", "    set_match_pos = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["        && (!compl_started || found_all)) {", "      found_all = FALSE;", "      while (*e_cpt == ',' || *e_cpt == ' ')"], "readability/bool"]
["src/nvim/edit.c", ["      found_all = FALSE;", "      while (*e_cpt == ',' || *e_cpt == ' ')", "        e_cpt++;"], "readability/braces"]
["src/nvim/edit.c", ["        } else if (*e_cpt == 'k' || *e_cpt == 's') {", "          if (*e_cpt == 'k')", "            type = CTRL_X_DICTIONARY;"], "readability/braces"]
["src/nvim/edit.c", ["            type = CTRL_X_DICTIONARY;", "          else", "            type = CTRL_X_THESAURUS;"], "readability/braces"]
["src/nvim/edit.c", ["", "        found_all = TRUE;", "        if (type == -1)"], "readability/bool"]
["src/nvim/edit.c", ["        found_all = TRUE;", "        if (type == -1)", "          continue;"], "readability/braces"]
["src/nvim/edit.c", ["      find_pattern_in_path(compl_pattern, compl_direction,", "                           STRLEN(compl_pattern), FALSE, FALSE,", "                           ((type == CTRL_X_PATH_DEFINES"], "readability/bool"]
["src/nvim/edit.c", ["    case CTRL_X_CMDLINE:", "      if (expand_cmdline(&compl_xp, compl_pattern,", "              (int)STRLEN(compl_pattern),"], "readability/braces"]
["src/nvim/edit.c", ["      if (expand_cmdline(&compl_xp, compl_pattern,", "              (int)STRLEN(compl_pattern),", "              &num_matches, &matches) == EXPAND_OK)"], "whitespace/alignment"]
["src/nvim/edit.c", ["              (int)STRLEN(compl_pattern),", "              &num_matches, &matches) == EXPAND_OK)", "        ins_compl_add_matches(num_matches, matches, FALSE);"], "whitespace/alignment"]
["src/nvim/edit.c", ["              &num_matches, &matches) == EXPAND_OK)", "        ins_compl_add_matches(num_matches, matches, FALSE);", "      break;"], "readability/bool"]
["src/nvim/edit.c", ["      num_matches = expand_spelling(first_match_pos.lnum,", "          compl_pattern, &matches);", "      if (num_matches > 0)"], "whitespace/alignment"]
["src/nvim/edit.c", ["          compl_pattern, &matches);", "      if (num_matches > 0)", "        ins_compl_add_matches(num_matches, matches, p_ic);"], "readability/braces"]
["src/nvim/edit.c", ["      assert(ins_buf);", "      if (ins_buf->b_p_inf)", "        p_scs = FALSE;"], "readability/braces"]
["src/nvim/edit.c", ["      if (ins_buf->b_p_inf)", "        p_scs = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["      save_p_ws = p_ws;", "      if (ins_buf != curbuf)", "        p_ws = false;"], "readability/braces"]
["src/nvim/edit.c", ["        p_ws = false;", "      else if (*e_cpt == '.')", "        p_ws = true;"], "readability/braces"]
["src/nvim/edit.c", ["        if (found_new_match == FAIL) {", "          if (ins_buf == curbuf)", "            found_all = TRUE;"], "readability/braces"]
["src/nvim/edit.c", ["          if (ins_buf == curbuf)", "            found_all = TRUE;", "          break;"], "readability/bool"]
["src/nvim/edit.c", ["              // compl_length, so the next STRNCPY always works -- Acevedo", "              STRNCPY(IObuff, ptr, len);", "              ptr = ml_get_buf(ins_buf, pos->lnum + 1, false);"], "runtime/printf"]
["src/nvim/edit.c", ["            }", "            if (len == compl_length)", "              continue;"], "readability/braces"]
["src/nvim/edit.c", ["        || found_new_match != FAIL) {", "      if (got_int)", "        break;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Fill in the next completion in the current direction."], "readability/old_style_comment"]
["src/nvim/edit.c", ["static int", "ins_compl_next (", "    int allow_get_expansion,"], "whitespace/parens"]
["src/nvim/edit.c", ["", "  /* When user complete function return -1 for findstart which is next", "   * time of 'always', compl_shown_match become NULL. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["   * time of 'always', compl_shown_match become NULL. */", "  if (compl_shown_match == NULL)", "    return -1;"], "readability/braces"]
["src/nvim/edit.c", ["", "    /* If we didn't find it searching forward, and compl_shows_dir is", "     * backward, find the last match. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        && !ins_compl_equal(compl_shown_match,", "            compl_leader, (int)STRLEN(compl_leader))", "        && (compl_shown_match->cp_next == NULL"], "whitespace/alignment"]
["src/nvim/edit.c", ["        && !ins_compl_equal(compl_shown_match,", "            compl_leader, (int)STRLEN(compl_leader))", "        && (compl_shown_match->cp_next == NULL"], "whitespace/alignment"]
["src/nvim/edit.c", ["            || compl_shown_match->cp_next == compl_first_match)) {", "      while (!ins_compl_equal(compl_shown_match,", "                 compl_leader, (int)STRLEN(compl_leader))"], "readability/braces"]
["src/nvim/edit.c", ["      while (!ins_compl_equal(compl_shown_match,", "                 compl_leader, (int)STRLEN(compl_leader))", "             && compl_shown_match->cp_prev != NULL"], "whitespace/alignment"]
["src/nvim/edit.c", ["", "  if (allow_get_expansion && insert_match", "      && (!(compl_get_longest || compl_restarting) || compl_used_match))"], "readability/braces"]
["src/nvim/edit.c", ["", "  /* Repeat this for when <PageUp> or <PageDown> is typed.  But don't wrap", "   * around. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        if (advance) {", "          if (compl_shows_dir == BACKWARD)", "            compl_pending -= todo + 1;"], "readability/braces"]
["src/nvim/edit.c", ["            compl_pending -= todo + 1;", "          else", "            compl_pending += todo + 1;"], "readability/braces"]
["src/nvim/edit.c", ["      if (!compl_no_select && advance) {", "        if (compl_shows_dir == BACKWARD)", "          --compl_pending;"], "readability/braces"]
["src/nvim/edit.c", ["        if (compl_shows_dir == BACKWARD)", "          --compl_pending;", "        else"], "readability/increment"]
["src/nvim/edit.c", ["          --compl_pending;", "        else", "          ++compl_pending;"], "readability/braces"]
["src/nvim/edit.c", ["        else", "          ++compl_pending;", "      }"], "readability/increment"]
["src/nvim/edit.c", ["          compl_shown_match = compl_shown_match->cp_next;", "          --compl_pending;", "        }"], "readability/increment"]
["src/nvim/edit.c", ["          compl_shown_match = compl_shown_match->cp_prev;", "          ++compl_pending;", "        } else"], "readability/increment"]
["src/nvim/edit.c", ["          ++compl_pending;", "        } else", "          break;"], "readability/braces"]
["src/nvim/edit.c", ["", "  /* Enter will select a match when the match wasn't inserted and the popup", "   * menu is visible. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (compl_no_insert && !started) {", "    compl_enter_selects = TRUE;", "  } else {"], "readability/bool"]
["src/nvim/edit.c", ["", "  /*", "   * Show the file name for the match (if any)"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /* Check for a typed key.  Do use mappings, otherwise vim_is_ctrl_x_key()", "   * can't do its work correctly. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      (void)ins_compl_next(false, ins_compl_key2count(c),", "          c != K_UP && c != K_DOWN, in_compl_func);", "    } else {"], "whitespace/alignment"]
["src/nvim/edit.c", ["    } else {", "      /* Need to get the character to have KeyTyped set.  We'll put it", "       * back with vungetc() below.  But skip K_IGNORE. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      if (c != K_IGNORE) {", "        /* Don't interrupt completion when the character wasn't typed,", "         * e.g., when doing @q to replay keys. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["         * e.g., when doing @q to replay keys. */", "        if (c != Ctrl_R && KeyTyped)", "          compl_interrupted = TRUE;"], "readability/braces"]
["src/nvim/edit.c", ["        if (c != Ctrl_R && KeyTyped)", "          compl_interrupted = TRUE;", ""], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * Decide the direction of Insert mode complete from the key typed."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Decide the number of completions to move forward."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Do Insert mode completion."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /* If this same ctrl_x_mode has been interrupted use the text from", "     * \"compl_startpos\" to the cursor as a pattern to add a new word"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        && compl_cont_mode == ctrl_x_mode) {", "      /*", "       * it is a continued search"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        if (compl_startpos.lnum != curwin->w_cursor.lnum) {", "          /* line (probably) wrapped, set compl_startpos to the", "           * first non_blank in the line, if it is not a wordchar"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        } else {", "          /* S_IPOS was set when we inserted a word that was at the", "           * beginning of the line, which means that we'll go to SOL"], "readability/old_style_comment"]
["src/nvim/edit.c", ["            compl_startpos.col = (colnr_T)(skipwhite(", "                                               line + compl_length", "                                               + compl_startpos.col) - line);"], "whitespace/indent"]
["src/nvim/edit.c", ["                                               line + compl_length", "                                               + compl_startpos.col) - line);", "          }"], "whitespace/indent"]
["src/nvim/edit.c", ["        compl_length = curwin->w_cursor.col - (int)compl_col;", "        /* IObuff is used to add a \"word from the next line\" would we", "         * have enough space?  just being paranoid */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        compl_cont_status |= CONT_ADDING | CONT_N_ADDS;", "        if (compl_length < 1)", "          compl_cont_status &= CONT_LOCAL;"], "readability/braces"]
["src/nvim/edit.c", ["        compl_cont_status = CONT_ADDING | CONT_N_ADDS;", "      } else", "        compl_cont_status = 0;"], "readability/braces"]
["src/nvim/edit.c", ["        compl_cont_status = 0;", "    } else", "      compl_cont_status &= CONT_LOCAL;"], "readability/braces"]
["src/nvim/edit.c", ["        if (!(compl_cont_status & CONT_ADDING)) {", "          while (--startcol >= 0 && vim_isIDc(line[startcol]))", "            ;"], "readability/braces"]
["src/nvim/edit.c", ["          while (--startcol >= 0 && vim_isIDc(line[startcol]))", "            ;", "          compl_col += ++startcol;"], "whitespace/semicolon"]
["src/nvim/edit.c", ["        }", "        if (p_ic)", "          compl_pattern = str_foldcase(line + compl_col, compl_length, NULL, 0);"], "readability/braces"]
["src/nvim/edit.c", ["          compl_pattern = str_foldcase(line + compl_col, compl_length, NULL, 0);", "        else", "          compl_pattern = vim_strnsave(line + compl_col, compl_length);"], "readability/braces"]
["src/nvim/edit.c", ["        compl_pattern = xmalloc(quote_meta(NULL, line + compl_col,", "                compl_length) + 2);", "        if (!vim_iswordp(line + compl_col)"], "whitespace/alignment"]
["src/nvim/edit.c", ["                compl_length) + 2);", "        if (!vim_iswordp(line + compl_col)", "            || (compl_col > 0"], "readability/braces"]
["src/nvim/edit.c", ["                && (", "                  vim_iswordp(mb_prevptr(line, line + compl_col))", "                  )))"], "whitespace/indent"]
["src/nvim/edit.c", ["                  vim_iswordp(mb_prevptr(line, line + compl_col))", "                  )))", "          prefix = (char_u *)\"\";"], "whitespace/indent"]
["src/nvim/edit.c", ["                && (", "                  vim_iswordp(mb_prevptr(line, line + compl_col))", "                  )))"], "whitespace/indent"]
["src/nvim/edit.c", ["                  vim_iswordp(mb_prevptr(line, line + compl_col))", "                  )))", "          prefix = (char_u *)\"\";"], "whitespace/indent"]
["src/nvim/edit.c", ["                && (", "                  vim_iswordp(mb_prevptr(line, line + compl_col))", "                  )))"], "whitespace/indent"]
["src/nvim/edit.c", ["                  vim_iswordp(mb_prevptr(line, line + compl_col))", "                  )))", "          prefix = (char_u *)\"\";"], "whitespace/indent"]
["src/nvim/edit.c", ["                  vim_iswordp(mb_prevptr(line, line + compl_col))", "                  )))", "          prefix = (char_u *)\"\";"], "whitespace/parens"]
["src/nvim/edit.c", ["        if (compl_length == 1) {", "          /* Only match word with at least two chars -- webb", "           * there's no need to call quote_meta,"], "readability/old_style_comment"]
["src/nvim/edit.c", ["          compl_pattern = xmalloc(quote_meta(NULL, line + compl_col,", "                  compl_length) + 2);", "          STRCPY((char *)compl_pattern, \"\\\\<\");"], "whitespace/alignment"]
["src/nvim/edit.c", ["          (void)quote_meta(compl_pattern + 2, line + compl_col,", "              compl_length);", "        }"], "whitespace/alignment"]
["src/nvim/edit.c", ["               CTRL_X_OMNI) {", "      /*", "       * Call user defined function 'completefunc' with \"a:findstart\""], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "      /* Call 'completefunc' or 'omnifunc' and get pattern length as a", "       * string */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        EMSG2(_(e_notset), ctrl_x_mode == CTRL_X_FUNCTION", "            ? \"completefunc\" : \"omnifunc\");", "        // restore did_ai, so that adding comment leader works"], "whitespace/alignment"]
["src/nvim/edit.c", ["", "      /* Return value -2 means the user complete function wants to", "       * cancel the complete without an error."], "readability/old_style_comment"]
["src/nvim/edit.c", ["       * Return value -3 does the same as -2 and leaves CTRL-X mode.*/", "      if (col == -2)", "        return FAIL;"], "readability/braces"]
["src/nvim/edit.c", ["", "      /*", "       * Reset extended parameters of completion, when start new"], "readability/old_style_comment"]
["src/nvim/edit.c", ["       */", "      compl_opt_refresh_always = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["", "      if (col < 0)", "        col = curs_col;"], "readability/braces"]
["src/nvim/edit.c", ["      compl_col = col;", "      if (compl_col > curs_col)", "        compl_col = curs_col;"], "readability/braces"]
["src/nvim/edit.c", ["", "      /* Setup variables for completion.  Need to obtain \"line\" again,", "       * it may have become invalid. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      }", "      else", "        compl_col = spell_word_start(startcol);"], "whitespace/newline"]
["src/nvim/edit.c", ["", "    if (compl_cont_status & CONT_LOCAL)", "      edit_submode = (char_u *)_(ctrl_x_msgs[CTRL_X_LOCAL_MSG]);"], "readability/braces"]
["src/nvim/edit.c", ["      edit_submode = (char_u *)_(ctrl_x_msgs[CTRL_X_LOCAL_MSG]);", "    else", "      edit_submode = (char_u *)_(CTRL_X_MSG(ctrl_x_mode));"], "readability/braces"]
["src/nvim/edit.c", ["", "    /* If any of the original typed text has been changed we need to fix", "     * the redo buffer. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /* showmode might reset the internal line pointers, so it must", "     * be called before line = ml_get(), or when this address is no"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Find next match (and following matches)."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /* Eat the ESC that vgetc() returns after a CTRL-C to avoid leaving Insert", "   * mode. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    (void)vgetc();", "    got_int = FALSE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["    edit_submode_highl = HLF_E;", "    /* remove N_ADDS flag, so next ^X<> won't try to go to ADDING mode,", "     * because we couldn't expand anything at first place, but if we used"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "      /* The match should always have a sequence number now, this is", "       * just a safety check. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      if (compl_curr_match->cp_number != -1) {", "        /* Space for 10 text chars. + 2x10-digit no.s = 31.", "         * Translations may need more than twice that. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "        if (compl_matches > 0)", "          vim_snprintf((char *)match_ref, sizeof(match_ref),"], "readability/braces"]
["src/nvim/edit.c", ["          vim_snprintf((char *)match_ref, sizeof(match_ref),", "              _(\"match %d of %d\"),", "              compl_curr_match->cp_number, compl_matches);"], "whitespace/alignment"]
["src/nvim/edit.c", ["              _(\"match %d of %d\"),", "              compl_curr_match->cp_number, compl_matches);", "        else"], "whitespace/alignment"]
["src/nvim/edit.c", ["              compl_curr_match->cp_number, compl_matches);", "        else", "          vim_snprintf((char *)match_ref, sizeof(match_ref),"], "readability/braces"]
["src/nvim/edit.c", ["          vim_snprintf((char *)match_ref, sizeof(match_ref),", "              _(\"match %d\"),", "              compl_curr_match->cp_number);"], "whitespace/alignment"]
["src/nvim/edit.c", ["              _(\"match %d\"),", "              compl_curr_match->cp_number);", "        edit_submode_extra = match_ref;"], "whitespace/alignment"]
["src/nvim/edit.c", ["  compl_was_interrupted = compl_interrupted;", "  compl_interrupted = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * Looks in the first \"len\" chars. of \"src\" for search-metachars."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    case '[':", "      if (ctrl_x_mode == CTRL_X_DICTIONARY", "          || ctrl_x_mode == CTRL_X_THESAURUS)"], "readability/braces"]
["src/nvim/edit.c", ["    case '\\\\':", "      if (ctrl_x_mode == CTRL_X_DICTIONARY", "          || ctrl_x_mode == CTRL_X_THESAURUS)"], "readability/braces"]
["src/nvim/edit.c", ["  }", "  if (dest != NULL)", "    *dest = NUL;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Next character is interpreted literally."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  int i;", "  int hex = FALSE;", "  int octal = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["  int hex = FALSE;", "  int octal = FALSE;", "  int unicode = 0;"], "readability/bool"]
["src/nvim/edit.c", ["", "  if (got_int)", "    return Ctrl_C;"], "readability/braces"]
["src/nvim/edit.c", ["    nc = plain_vgetc();", "    if (!(State & CMDLINE)", "        && MB_BYTE2LEN_CHECK(nc) == 1"], "readability/braces"]
["src/nvim/edit.c", ["      add_to_showcmd(nc);", "    if (nc == 'x' || nc == 'X')", "      hex = TRUE;"], "readability/braces"]
["src/nvim/edit.c", ["    if (nc == 'x' || nc == 'X')", "      hex = TRUE;", "    else if (nc == 'o' || nc == 'O')"], "readability/bool"]
["src/nvim/edit.c", ["      hex = TRUE;", "    else if (nc == 'o' || nc == 'O')", "      octal = TRUE;"], "readability/braces"]
["src/nvim/edit.c", ["    else if (nc == 'o' || nc == 'O')", "      octal = TRUE;", "    else if (nc == 'u' || nc == 'U')"], "readability/bool"]
["src/nvim/edit.c", ["      octal = TRUE;", "    else if (nc == 'u' || nc == 'U')", "      unicode = nc;"], "readability/braces"]
["src/nvim/edit.c", ["      unicode = nc;", "    else {", "      if (hex"], "readability/braces"]
["src/nvim/edit.c", ["      unicode = nc;", "    else {", "      if (hex"], "readability/braces"]
["src/nvim/edit.c", ["          ) {", "        if (!ascii_isxdigit(nc))", "          break;"], "readability/braces"]
["src/nvim/edit.c", ["      } else if (octal) {", "        if (nc < '0' || nc > '7')", "          break;"], "readability/braces"]
["src/nvim/edit.c", ["      } else {", "        if (!ascii_isdigit(nc))", "          break;"], "readability/braces"]
["src/nvim/edit.c", ["", "      ++i;", "    }"], "readability/increment"]
["src/nvim/edit.c", ["", "    if (cc > 255", "        && unicode == 0"], "readability/braces"]
["src/nvim/edit.c", ["", "  --no_mapping;", "  if (nc)"], "readability/increment"]
["src/nvim/edit.c", ["  --no_mapping;", "  if (nc)", "    vungetc(nc);"], "readability/braces"]
["src/nvim/edit.c", ["    if (len > 2) {", "      if (stop_arrow() == FAIL)", "        return;"], "readability/braces"]
["src/nvim/edit.c", ["      AppendToRedobuffLit(p, -1);", "      ctrlv = FALSE;", "    }"], "readability/bool"]
["src/nvim/edit.c", ["  }", "  if (stop_arrow() == OK)", "    insertchar(c, ctrlv ? INSCHAR_CTRLV : 0, -1);"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Special characters in this context are those that need processing other"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * \"flags\": INSCHAR_FORMAT - force formatting"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Try to break the line in two or more pieces when:"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    }", "    if (do_internal)", "      internal_format(textwidth, second_indent, flags, c == NUL, c);"], "readability/braces"]
["src/nvim/edit.c", ["", "    /*", "     * Need to remove existing (middle) comment leader and insert end"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      i = curwin->w_cursor.col;", "      while (--i >= 0 && ascii_iswhite(line[i]))", "        ;"], "readability/braces"]
["src/nvim/edit.c", ["      while (--i >= 0 && ascii_iswhite(line[i]))", "        ;", "      i++;"], "whitespace/semicolon"]
["src/nvim/edit.c", ["      i = 1;", "    } else", "      i = 0;"], "readability/braces"]
["src/nvim/edit.c", ["      i = 0;", "    if (buf[i] != NUL)", "      AppendToRedobuffLit(buf + i, -1);"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Format text at the current insert position."], "readability/old_style_comment"]
["src/nvim/edit.c", ["static void", "internal_format (", "    int textwidth,"], "whitespace/parens"]
["src/nvim/edit.c", ["", "  /*", "   * When 'ai' is off we don't want a space under the cursor to be"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Repeat breaking lines, until the current line is not too long."], "readability/old_style_comment"]
["src/nvim/edit.c", ["              + char2cells(c != NUL ? c : gchar_cursor());", "    if (virtcol <= (colnr_T)textwidth)", "      break;"], "readability/braces"]
["src/nvim/edit.c", ["", "    /*", "     * Find position to break at."], "readability/old_style_comment"]
["src/nvim/edit.c", ["           || curwin->w_cursor.col >= Insstart.col) {", "      if (curwin->w_cursor.col == startcol && c != NUL)", "        cc = c;"], "readability/braces"]
["src/nvim/edit.c", ["        cc = c;", "      else", "        cc = gchar_cursor();"], "readability/braces"]
["src/nvim/edit.c", ["        foundcol = curwin->w_cursor.col;", "        if (curwin->w_cursor.col <= (colnr_T)wantcol)", "          break;"], "readability/braces"]
["src/nvim/edit.c", ["            end_foundcol = foundcol;", "            if (curwin->w_cursor.col <= (colnr_T)wantcol)", "              break;"], "readability/braces"]
["src/nvim/edit.c", ["", "        if (curwin->w_cursor.col == 0)", "          break;"], "readability/braces"]
["src/nvim/edit.c", ["      }", "      if (curwin->w_cursor.col == 0)", "        break;"], "readability/braces"]
["src/nvim/edit.c", ["", "    /*", "     * Offset between cursor position and line break is used by replace"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * adjust startcol for spaces that will be deleted and"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    curwin->w_cursor.col = foundcol;", "    while ((cc = gchar_cursor(), WHITECHAR(cc))", "           && (!fo_white_par || curwin->w_cursor.col < startcol))"], "readability/braces"]
["src/nvim/edit.c", ["    startcol -= curwin->w_cursor.col;", "    if (startcol < 0)", "      startcol = 0;"], "readability/braces"]
["src/nvim/edit.c", ["    if (State & VREPLACE_FLAG) {", "      /*", "       * In VREPLACE mode, we will backspace over the text to be"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * Split the line just before the margin."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    open_line(FORWARD, OPENLINE_DELSPACES + OPENLINE_MARKFIX", "        + (fo_white_par ? OPENLINE_KEEPTRAIL : 0)", "        + (do_comments ? OPENLINE_DO_COM : 0)"], "whitespace/alignment"]
["src/nvim/edit.c", ["        + (fo_white_par ? OPENLINE_KEEPTRAIL : 0)", "        + (do_comments ? OPENLINE_DO_COM : 0)", "        + ((flags & INSCHAR_COM_LIST) ? OPENLINE_COM_LIST : 0)"], "whitespace/alignment"]
["src/nvim/edit.c", ["        + (do_comments ? OPENLINE_DO_COM : 0)", "        + ((flags & INSCHAR_COM_LIST) ? OPENLINE_COM_LIST : 0)", "        , ((flags & INSCHAR_COM_LIST) ? second_indent : old_indent));"], "whitespace/alignment"]
["src/nvim/edit.c", ["        + ((flags & INSCHAR_COM_LIST) ? OPENLINE_COM_LIST : 0)", "        , ((flags & INSCHAR_COM_LIST) ? second_indent : old_indent));", "    if (!(flags & INSCHAR_COM_LIST))"], "whitespace/alignment"]
["src/nvim/edit.c", ["        , ((flags & INSCHAR_COM_LIST) ? second_indent : old_indent));", "    if (!(flags & INSCHAR_COM_LIST))", "      old_indent = 0;"], "readability/braces"]
["src/nvim/edit.c", ["    if (State & VREPLACE_FLAG) {", "      /*", "       * In VREPLACE mode we have backspaced over the text to be"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    } else {", "      /*", "       * Check if cursor is not past the NUL off the line, cindent"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      len = (colnr_T)STRLEN(get_cursor_line_ptr());", "      if (curwin->w_cursor.col > len)", "        curwin->w_cursor.col = len;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Called after inserting or deleting text: When 'formatoptions' includes the"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  if (!has_format_option(FO_AUTO))", "    return;"], "readability/braces"]
["src/nvim/edit.c", ["    cc = gchar_cursor();", "    if (!WHITECHAR(cc) && curwin->w_cursor.col > 0", "        && has_format_option(FO_ONE_LETTER))"], "readability/braces"]
["src/nvim/edit.c", ["", "  /* With the 'c' flag in 'formatoptions' and 't' missing: only format", "   * comments. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["   * comments. */", "  if (has_format_option(FO_WRAP_COMS) && !has_format_option(FO_WRAP)", "      && get_leader_len(old, NULL, FALSE, TRUE) == 0)"], "readability/braces"]
["src/nvim/edit.c", ["  if (has_format_option(FO_WRAP_COMS) && !has_format_option(FO_WRAP)", "      && get_leader_len(old, NULL, FALSE, TRUE) == 0)", "    return;"], "readability/bool"]
["src/nvim/edit.c", ["", "  /*", "   * May start formatting in a previous line, so that after \"x\" a word is"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (prev_line && !paragraph_start(curwin->w_cursor.lnum)) {", "    --curwin->w_cursor.lnum;", "    if (u_save_cursor() == FAIL)"], "readability/increment"]
["src/nvim/edit.c", ["    --curwin->w_cursor.lnum;", "    if (u_save_cursor() == FAIL)", "      return;"], "readability/braces"]
["src/nvim/edit.c", ["", "  /*", "   * Do the formatting and restore the cursor position.  \"saved_cursor\" will"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  saved_cursor = pos;", "  format_lines((linenr_T)-1, FALSE);", "  curwin->w_cursor = saved_cursor;"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * When an extra space was added to continue a paragraph for auto-formatting,"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Find out textwidth to be used for formatting:"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    if (curwin->w_p_nu || curwin->w_p_rnu)", "      textwidth -= 8;"], "readability/braces"]
["src/nvim/edit.c", ["  }", "  if (textwidth < 0)", "    textwidth = 0;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Put a character in the redo buffer, for when just after a CTRL-V."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * If we skipped highlighting word at cursor, do it now."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Called when starting CTRL_X_SPELL mode: Move backwards to a previous badly"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  pos_T tpos = curwin->w_cursor;", "  spell_bad_len = spell_move_to(curwin, BACKWARD, TRUE, TRUE, NULL);", "  if (curwin->w_cursor.col != tpos.col)"], "readability/bool"]
["src/nvim/edit.c", ["  spell_bad_len = spell_move_to(curwin, BACKWARD, TRUE, TRUE, NULL);", "  if (curwin->w_cursor.col != tpos.col)", "    start_arrow(&tpos);"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * stop_arrow() is called before a change is made in insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (arrow_used) {", "    Insstart = curwin->w_cursor;  //new insertion starts here", "    if (Insstart.col > Insstart_orig.col && !ins_need_undo) {"], "whitespace/comments"]
["src/nvim/edit.c", ["      // right, except when nothing was inserted yet.", "      update_Insstart_orig = FALSE;", "    }"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * Do a few things to stop inserting."], "readability/old_style_comment"]
["src/nvim/edit.c", ["static void", "stop_insert (", "    pos_T *end_insert_pos,"], "whitespace/parens"]
["src/nvim/edit.c", ["", "  /*", "   * Save the inserted text for later redo with ^@ and CTRL-A."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    last_insert_skip = new_insert_skip;", "  } else", "    xfree(ptr);"], "readability/braces"]
["src/nvim/edit.c", ["        cc = gchar_cursor();", "        if (!ascii_iswhite(cc))", "          curwin->w_cursor = tpos;"], "readability/braces"]
["src/nvim/edit.c", ["      if (ascii_iswhite(cc)) {", "        if (gchar_cursor() != NUL)", "          inc_cursor();"], "readability/braces"]
["src/nvim/edit.c", ["          inc_cursor();", "        /* If the cursor is still at the same character, also keep", "         * the \"coladd\". */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["         * the \"coladd\". */", "        if (gchar_cursor() == NUL", "            && curwin->w_cursor.lnum == tpos.lnum"], "readability/braces"]
["src/nvim/edit.c", ["      for (;; ) {", "        if (gchar_cursor() == NUL && curwin->w_cursor.col > 0)", "          --curwin->w_cursor.col;"], "readability/braces"]
["src/nvim/edit.c", ["        if (gchar_cursor() == NUL && curwin->w_cursor.col > 0)", "          --curwin->w_cursor.col;", "        cc = gchar_cursor();"], "readability/increment"]
["src/nvim/edit.c", ["        if (cc != NUL && gchar_pos(&tpos) == NUL) {", "          ++curwin->w_cursor.col;         // put cursor back on the NUL", "        }"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * Set the last inserted text to a single character."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * move cursor to start of line"], "readability/old_style_comment"]
["src/nvim/edit.c", ["{", "  if ((flags & BL_SOL) && !p_sol)", "    coladvance(curwin->w_curswant);"], "readability/braces"]
["src/nvim/edit.c", ["    coladvance(curwin->w_curswant);", "  else {", "    curwin->w_cursor.col = 0;"], "readability/braces"]
["src/nvim/edit.c", ["    coladvance(curwin->w_curswant);", "  else {", "    curwin->w_cursor.col = 0;"], "readability/braces"]
["src/nvim/edit.c", ["", "      for (ptr = get_cursor_line_ptr(); ascii_iswhite(*ptr)", "           && !((flags & BL_FIX) && ptr[1] == NUL); ++ptr)"], "readability/braces"]
["src/nvim/edit.c", ["      for (ptr = get_cursor_line_ptr(); ascii_iswhite(*ptr)", "           && !((flags & BL_FIX) && ptr[1] == NUL); ++ptr)", "        ++curwin->w_cursor.col;"], "readability/increment"]
["src/nvim/edit.c", ["           && !((flags & BL_FIX) && ptr[1] == NUL); ++ptr)", "        ++curwin->w_cursor.col;", "    }"], "readability/increment"]
["src/nvim/edit.c", ["    }", "    curwin->w_set_curswant = TRUE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * oneright oneleft cursor_down cursor_up"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  curwin->w_set_curswant = TRUE;", "  return OK;"], "readability/bool"]
["src/nvim/edit.c", ["", "    if (v == 0)", "      return FAIL;"], "readability/braces"]
["src/nvim/edit.c", ["", "    curwin->w_set_curswant = TRUE;", "    return OK;"], "readability/bool"]
["src/nvim/edit.c", ["", "  if (curwin->w_cursor.col == 0)", "    return FAIL;"], "readability/braces"]
["src/nvim/edit.c", ["", "  curwin->w_set_curswant = TRUE;", "  --curwin->w_cursor.col;"], "readability/bool"]
["src/nvim/edit.c", ["  curwin->w_set_curswant = TRUE;", "  --curwin->w_cursor.col;", ""], "readability/increment"]
["src/nvim/edit.c", ["int", "cursor_up (", "    long n,"], "whitespace/parens"]
["src/nvim/edit.c", ["    }", "    if (n >= lnum)", "      lnum = 1;"], "readability/braces"]
["src/nvim/edit.c", ["      lnum = 1;", "    else if (hasAnyFolding(curwin)) {", "      /*"], "readability/braces"]
["src/nvim/edit.c", ["    else if (hasAnyFolding(curwin)) {", "      /*", "       * Count each sequence of folded lines as one logical line."], "readability/old_style_comment"]
["src/nvim/edit.c", ["      }", "      if (lnum < 1)", "        lnum = 1;"], "readability/braces"]
["src/nvim/edit.c", ["        lnum = 1;", "    } else", "      lnum -= n;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Cursor down a number of logical lines."], "readability/old_style_comment"]
["src/nvim/edit.c", ["int", "cursor_down (", "    long n,"], "whitespace/parens"]
["src/nvim/edit.c", ["    }", "    if (lnum + n >= curbuf->b_ml.ml_line_count)", "      lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/edit.c", ["      lnum = curbuf->b_ml.ml_line_count;", "    else if (hasAnyFolding(curwin)) {", "      linenr_T last;"], "readability/braces"]
["src/nvim/edit.c", ["      while (n--) {", "        if (hasFolding(lnum, NULL, &last))", "          lnum = last + 1;"], "readability/braces"]
["src/nvim/edit.c", ["          lnum = last + 1;", "        else", "          ++lnum;"], "readability/braces"]
["src/nvim/edit.c", ["        else", "          ++lnum;", "        if (lnum >= curbuf->b_ml.ml_line_count)"], "readability/increment"]
["src/nvim/edit.c", ["          ++lnum;", "        if (lnum >= curbuf->b_ml.ml_line_count)", "          break;"], "readability/braces"]
["src/nvim/edit.c", ["      }", "      if (lnum > curbuf->b_ml.ml_line_count)", "        lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/edit.c", ["        lnum = curbuf->b_ml.ml_line_count;", "    } else", "      lnum += n;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Stuff the last inserted text in the read buffer."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  if (last)", "    *last_ptr = last;"], "readability/braces"]
["src/nvim/edit.c", ["{", "  if (last_insert == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Get last inserted string, and remove trailing <Esc>."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  if (last_insert == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/edit.c", ["  return check_abbr(c, get_cursor_line_ptr(), curwin->w_cursor.col,", "      curwin->w_cursor.lnum == Insstart.lnum ? Insstart.col : 0);", "}"], "whitespace/alignment"]
["src/nvim/edit.c", ["", "/*", " * replace-stack functions"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  *p = (char_u)c;", "  ++replace_stack_nr;", "}"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * Push a character onto the replace stack.  Handles a multi-byte character in"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  for (j = l - 1; j >= 0; --j)", "    replace_push(p[j]);"], "readability/braces"]
["src/nvim/edit.c", ["", "  for (j = l - 1; j >= 0; --j)", "    replace_push(p[j]);"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * Join the top two items on the replace stack.  This removes to \"off\"'th NUL"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  for (i = replace_stack_nr; --i >= 0; )", "    if (replace_stack[i] == NUL && off-- <= 0) {"], "readability/braces"]
["src/nvim/edit.c", ["    if (replace_stack[i] == NUL && off-- <= 0) {", "      --replace_stack_nr;", "      memmove(replace_stack + i, replace_stack + i + 1,"], "readability/increment"]
["src/nvim/edit.c", ["      memmove(replace_stack + i, replace_stack + i + 1,", "          (size_t)(replace_stack_nr - i));", "      return;"], "whitespace/alignment"]
["src/nvim/edit.c", ["", "/*", " * Pop bytes from the replace stack until a NUL is found, and insert them"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Insert bytes popped from the replace stack. \"cc\" is the first byte.  If it"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    buf[0] = cc;", "    for (i = 1; i < n; ++i)", "      buf[i] = replace_pop();"], "readability/braces"]
["src/nvim/edit.c", ["    buf[0] = cc;", "    for (i = 1; i < n; ++i)", "      buf[i] = replace_pop();"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * make the replace stack empty"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Handle doing a BS for one character."], "readability/old_style_comment"]
["src/nvim/edit.c", ["      vcol = start_vcol;", "      for (i = 0; i < ins_len; ++i) {", "        vcol += chartabsize(p + i, vcol);"], "readability/increment"]
["src/nvim/edit.c", ["    changed_bytes(curwin->w_cursor.lnum, curwin->w_cursor.col);", "  } else if (cc == 0)", "    (void)del_char_after_col(limit_col);"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * Re-indent the current line, based on the current contents of it and the"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "void fix_indent(void) {", "  if (p_paste)"], "readability/braces"]
["src/nvim/edit.c", ["void fix_indent(void) {", "  if (p_paste)", "    return;"], "readability/braces"]
["src/nvim/edit.c", ["    return;", "  if (curbuf->b_p_lisp && curbuf->b_p_ai)", "    fixthisline(get_lisp_indent);"], "readability/braces"]
["src/nvim/edit.c", ["    fixthisline(get_lisp_indent);", "  else if (cindent_on())", "    do_c_expr_indent();"], "readability/braces"]
["src/nvim/edit.c", ["  while (*look) {", "    /*", "     * Find out if we want to try a match with this key, depending on"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      }", "      while (*look && *look != '>')", "        look++;"], "readability/braces"]
["src/nvim/edit.c", ["        look++;", "      while (*look == '>')", "        look++;"], "readability/braces"]
["src/nvim/edit.c", ["    }", "    /*", "     * Is it a word: \"=word\"?"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     */", "    else if (*look == '=' && look[1] != ',' && look[1] != NUL) {", "      ++look;"], "whitespace/newline"]
["src/nvim/edit.c", ["    else if (*look == '=' && look[1] != ',' && look[1] != NUL) {", "      ++look;", "      if (*look == '~') {"], "readability/increment"]
["src/nvim/edit.c", ["      if (*look == '~') {", "        icase = TRUE;", "        ++look;"], "readability/bool"]
["src/nvim/edit.c", ["        icase = TRUE;", "        ++look;", "      } else"], "readability/increment"]
["src/nvim/edit.c", ["        ++look;", "      } else", "        icase = FALSE;"], "readability/braces"]
["src/nvim/edit.c", ["      } else", "        icase = FALSE;", "      p = vim_strchr(look, ',');"], "readability/bool"]
["src/nvim/edit.c", ["      p = vim_strchr(look, ',');", "      if (p == NULL)", "        p = look + STRLEN(look);"], "readability/braces"]
["src/nvim/edit.c", ["", "          /* Just completed a word, check if it starts with \"look\".", "           * search back for the start of a word. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["          assert(p >= look && (uintmax_t)(p - look) <= SIZE_MAX);", "          if (s + (p - look) <= line + curwin->w_cursor.col", "              && (icase"], "readability/braces"]
["src/nvim/edit.c", ["        if (match && try_match_word && !try_match) {", "          /* \"0=word\": Check if there are only blanks before the", "           * word. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * Skip over \", \"."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Map Hebrew keyboard when in hkmap mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    static char_u map[26] =", "    {(char_u)hALEF /*a*/, (char_u)BET /*b*/, (char_u)hKAF /*c*/,", "     (char_u)DALET /*d*/, (char_u)-1 /*e*/, (char_u)PEIsofit /*f*/,"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    static char_u map[26] =", "    {(char_u)hALEF /*a*/, (char_u)BET /*b*/, (char_u)hKAF /*c*/,", "     (char_u)DALET /*d*/, (char_u)-1 /*e*/, (char_u)PEIsofit /*f*/,"], "whitespace/braces"]
["src/nvim/edit.c", ["    {(char_u)hALEF /*a*/, (char_u)BET /*b*/, (char_u)hKAF /*c*/,", "     (char_u)DALET /*d*/, (char_u)-1 /*e*/, (char_u)PEIsofit /*f*/,", "     (char_u)GIMEL /*g*/, (char_u)HEI /*h*/, (char_u)IUD /*i*/,"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     (char_u)DALET /*d*/, (char_u)-1 /*e*/, (char_u)PEIsofit /*f*/,", "     (char_u)GIMEL /*g*/, (char_u)HEI /*h*/, (char_u)IUD /*i*/,", "     (char_u)HET /*j*/, (char_u)KOF /*k*/, (char_u)LAMED /*l*/,"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     (char_u)GIMEL /*g*/, (char_u)HEI /*h*/, (char_u)IUD /*i*/,", "     (char_u)HET /*j*/, (char_u)KOF /*k*/, (char_u)LAMED /*l*/,", "     (char_u)MEM /*m*/, (char_u)NUN /*n*/, (char_u)SAMEH /*o*/,"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     (char_u)HET /*j*/, (char_u)KOF /*k*/, (char_u)LAMED /*l*/,", "     (char_u)MEM /*m*/, (char_u)NUN /*n*/, (char_u)SAMEH /*o*/,", "     (char_u)PEI /*p*/, (char_u)-1 /*q*/, (char_u)RESH /*r*/,"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     (char_u)MEM /*m*/, (char_u)NUN /*n*/, (char_u)SAMEH /*o*/,", "     (char_u)PEI /*p*/, (char_u)-1 /*q*/, (char_u)RESH /*r*/,", "     (char_u)ZAIN /*s*/, (char_u)TAV /*t*/, (char_u)TET /*u*/,"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     (char_u)PEI /*p*/, (char_u)-1 /*q*/, (char_u)RESH /*r*/,", "     (char_u)ZAIN /*s*/, (char_u)TAV /*t*/, (char_u)TET /*u*/,", "     (char_u)VAV /*v*/, (char_u)hSHIN /*w*/, (char_u)-1 /*x*/,"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     (char_u)ZAIN /*s*/, (char_u)TAV /*t*/, (char_u)TET /*u*/,", "     (char_u)VAV /*v*/, (char_u)hSHIN /*w*/, (char_u)-1 /*x*/,", "     (char_u)AIN /*y*/, (char_u)ZADI /*z*/};"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     (char_u)VAV /*v*/, (char_u)hSHIN /*w*/, (char_u)-1 /*x*/,", "     (char_u)AIN /*y*/, (char_u)ZADI /*z*/};", ""], "readability/old_style_comment"]
["src/nvim/edit.c", ["     (char_u)VAV /*v*/, (char_u)hSHIN /*w*/, (char_u)-1 /*x*/,", "     (char_u)AIN /*y*/, (char_u)ZADI /*z*/};", ""], "whitespace/braces"]
["src/nvim/edit.c", ["", "      if (c < 'a' || c > 'z')", "        return c;"], "readability/braces"]
["src/nvim/edit.c", ["{", "  int need_redraw = FALSE;", "  int regname;"], "readability/bool"]
["src/nvim/edit.c", ["", "  /*", "   * If we are going to wait for a character, show a '\"'."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Don't map the register name. This also prevents the mode message to be"], "readability/old_style_comment"]
["src/nvim/edit.c", ["   */", "  ++no_mapping;", "  regname = plain_vgetc();"], "readability/increment"]
["src/nvim/edit.c", ["  regname = plain_vgetc();", "  LANGMAP_ADJUST(regname, TRUE);", "  if (regname == Ctrl_R || regname == Ctrl_O || regname == Ctrl_P) {"], "readability/bool"]
["src/nvim/edit.c", ["    regname = plain_vgetc();", "    LANGMAP_ADJUST(regname, TRUE);", "  }"], "readability/bool"]
["src/nvim/edit.c", ["  }", "  --no_mapping;", ""], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * CTRL-G commands in Insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Don't map the second key. This also prevents the mode message to be"], "readability/old_style_comment"]
["src/nvim/edit.c", ["   */", "  ++no_mapping;", "  c = plain_vgetc();"], "readability/increment"]
["src/nvim/edit.c", ["  c = plain_vgetc();", "  --no_mapping;", "  switch (c) {"], "readability/increment"]
["src/nvim/edit.c", ["  case Ctrl_K:", "  case 'k': ins_up(TRUE);", "    break;"], "readability/bool"]
["src/nvim/edit.c", ["  case Ctrl_J:", "  case 'j': ins_down(TRUE);", "    break;"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * CTRL-^ in Insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * Repeating insert may take a long time.  Check for"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      line_breakcheck();", "      if (got_int)", "        *count = 0;"], "readability/braces"]
["src/nvim/edit.c", ["    }", "    stop_insert(&curwin->w_cursor, TRUE, nomove);", "    undisplay_dollar();"], "readability/bool"]
["src/nvim/edit.c", ["", "  /*", "   * The cursor should end up on the last inserted character."], "readability/old_style_comment"]
["src/nvim/edit.c", ["              && !VIsual_active", "              ))", "      && !revins_on"], "whitespace/parens"]
["src/nvim/edit.c", ["", "/*", " * Toggle language: hkmap and revins_on."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (revins_on && revins_chars && revins_scol >= 0) {", "    while (gchar_cursor() != NUL && revins_chars--)", "      ++curwin->w_cursor.col;"], "readability/braces"]
["src/nvim/edit.c", ["    while (gchar_cursor() != NUL && revins_chars--)", "      ++curwin->w_cursor.col;", "  }"], "readability/increment"]
["src/nvim/edit.c", ["    undisplay_dollar();", "  } else", "    revins_scol = -1;"], "readability/braces"]
["src/nvim/edit.c", ["  case K_KPAGEDOWN:", "    if (!(mod_mask & MOD_MASK_SHIFT))", "      break;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * <Insert> key in Insert mode: toggle insert/replace mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Pressed CTRL-O in Insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["{", "  if (State & VREPLACE_FLAG)", "    restart_edit = 'V';"], "readability/braces"]
["src/nvim/edit.c", ["    restart_edit = 'V';", "  else if (State & REPLACE_FLAG)", "    restart_edit = 'R';"], "readability/braces"]
["src/nvim/edit.c", ["    restart_edit = 'R';", "  else", "    restart_edit = 'I';"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * If the cursor is on an indent, ^T/^D insert/delete one"], "readability/old_style_comment"]
["src/nvim/edit.c", ["{", "  if (stop_arrow() == FAIL)", "    return;"], "readability/braces"]
["src/nvim/edit.c", ["", "  /*", "   * 0^D and ^^D: remove all indent."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    }", "    change_indent(INDENT_SET, 0, TRUE, 0, TRUE);", "  } else"], "readability/bool"]
["src/nvim/edit.c", ["    change_indent(INDENT_SET, 0, TRUE, 0, TRUE);", "  } else", "    change_indent(c == Ctrl_D ? INDENT_DEC : INDENT_INC, 0, TRUE, 0, TRUE);"], "readability/braces"]
["src/nvim/edit.c", ["  } else", "    change_indent(c == Ctrl_D ? INDENT_DEC : INDENT_INC, 0, TRUE, 0, TRUE);", ""], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * Delete one character for ins_bs()."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    }", "    /*", "     * In replace mode:"], "readability/old_style_comment"]
["src/nvim/edit.c", ["          char_u  *ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum,", "              TRUE);", "          int len;"], "whitespace/alignment"]
["src/nvim/edit.c", ["          char_u  *ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum,", "              TRUE);", "          int len;"], "readability/bool"]
["src/nvim/edit.c", ["          len = (int)STRLEN(ptr);", "          if (len > 0 && ptr[len - 1] == ' ')", "            ptr[len - 1] = NUL;"], "readability/braces"]
["src/nvim/edit.c", ["", "        do_join(2, FALSE, FALSE, FALSE, false);", "        if (temp == NUL && gchar_cursor() != NUL)"], "readability/bool"]
["src/nvim/edit.c", ["        do_join(2, FALSE, FALSE, FALSE, false);", "        if (temp == NUL && gchar_cursor() != NUL)", "          inc_cursor();"], "readability/braces"]
["src/nvim/edit.c", ["          inc_cursor();", "      } else", "        dec_cursor();"], "readability/braces"]
["src/nvim/edit.c", ["", "      /*", "       * In REPLACE mode we have to put back the text that was replaced"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      if (State & REPLACE_FLAG) {", "        /*", "         * Do the next ins_char() in NORMAL state, to"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        State = NORMAL;", "        /*", "         * restore characters (blanks) deleted after cursor"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      beginline(BL_WHITE);", "      if (curwin->w_cursor.col < save_col)", "        mincol = curwin->w_cursor.col;"], "readability/braces"]
["src/nvim/edit.c", ["", "    /*", "     * Handle deleting one 'shiftwidth' or 'softtabstop'."], "readability/old_style_comment"]
["src/nvim/edit.c", ["          ins_str((char_u *)\" \");", "          if ((State & REPLACE_FLAG))", "            replace_push(NUL);"], "readability/braces"]
["src/nvim/edit.c", ["          }", "          if (revins_on && gchar_cursor() == NUL)", "            break;"], "readability/braces"]
["src/nvim/edit.c", ["  }", "  if (curwin == old_curwin)", "    undisplay_dollar();"], "readability/braces"]
["src/nvim/edit.c", ["    if (dir == MSCR_DOWN || dir == MSCR_UP) {", "      if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))", "        scroll_redraw(dir,"], "readability/braces"]
["src/nvim/edit.c", ["        scroll_redraw(dir,", "            (long)(curwin->w_botline - curwin->w_topline));", "      else"], "whitespace/alignment"]
["src/nvim/edit.c", ["            (long)(curwin->w_botline - curwin->w_topline));", "      else", "        scroll_redraw(dir, 3L);"], "readability/braces"]
["src/nvim/edit.c", ["", "  curwin->w_redr_status = TRUE;", ""], "readability/bool"]
["src/nvim/edit.c", ["", "  if ((fdo_flags & FDO_HOR) && KeyTyped)", "    foldOpenCursor();"], "readability/braces"]
["src/nvim/edit.c", ["", "  if ((fdo_flags & FDO_HOR) && KeyTyped)", "    foldOpenCursor();"], "readability/braces"]
["src/nvim/edit.c", ["  tpos = curwin->w_cursor;", "  if (c == K_C_HOME)", "    curwin->w_cursor.lnum = 1;"], "readability/braces"]
["src/nvim/edit.c", ["", "  if ((fdo_flags & FDO_HOR) && KeyTyped)", "    foldOpenCursor();"], "readability/braces"]
["src/nvim/edit.c", ["  tpos = curwin->w_cursor;", "  if (c == K_C_END)", "    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/edit.c", ["    revins_legal++;", "    if (revins_chars)", "      revins_chars--;"], "readability/braces"]
["src/nvim/edit.c", ["  tpos = curwin->w_cursor;", "  if (cursor_up(1L, TRUE) == OK) {", "    if (startcol)"], "readability/bool"]
["src/nvim/edit.c", ["  if (cursor_up(1L, TRUE) == OK) {", "    if (startcol)", "      coladvance(getvcol_nolist(&Insstart));"], "readability/braces"]
["src/nvim/edit.c", ["      coladvance(getvcol_nolist(&Insstart));", "    if (old_topline != curwin->w_topline", "        || old_topfill != curwin->w_topfill"], "readability/braces"]
["src/nvim/edit.c", ["  tpos = curwin->w_cursor;", "  if (cursor_down(1L, TRUE) == OK) {", "    if (startcol)"], "readability/bool"]
["src/nvim/edit.c", ["  if (cursor_down(1L, TRUE) == OK) {", "    if (startcol)", "      coladvance(getvcol_nolist(&Insstart));"], "readability/braces"]
["src/nvim/edit.c", ["      coladvance(getvcol_nolist(&Insstart));", "    if (old_topline != curwin->w_topline", "        || old_topfill != curwin->w_topfill"], "readability/braces"]
["src/nvim/edit.c", ["", "  /*", "   * Insert the first space with ins_char().\tIt will delete one char in"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * When 'expandtab' not set: Replace spaces by TABs where possible."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * Get the current line.  For VREPLACE mode, don't make real changes"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    while (fpos.col > 0 && ascii_iswhite(ptr[-1])) {", "      --fpos.col;", "      --ptr;"], "readability/increment"]
["src/nvim/edit.c", ["      --fpos.col;", "      --ptr;", "    }"], "readability/increment"]
["src/nvim/edit.c", ["      i = lbr_chartabsize(NULL, (char_u *)\"\\t\", vcol);", "      if (vcol + i > want_vcol)", "        break;"], "readability/braces"]
["src/nvim/edit.c", ["      }", "      ++fpos.col;", "      ++ptr;"], "readability/increment"]
["src/nvim/edit.c", ["      ++fpos.col;", "      ++ptr;", "      vcol += i;"], "readability/increment"]
["src/nvim/edit.c", ["        vcol += lbr_chartabsize(line, ptr, vcol);", "        ++ptr;", "        ++repl_off;"], "readability/increment"]
["src/nvim/edit.c", ["        ++ptr;", "        ++repl_off;", "      }"], "readability/increment"]
["src/nvim/edit.c", ["", "      /*", "       * In VREPLACE mode, we haven't changed anything yet.  Do it now by"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        ins_bytes_len(saved_line + change_col,", "            cursor->col - change_col);", "      }"], "whitespace/alignment"]
["src/nvim/edit.c", ["", "    if (State & VREPLACE_FLAG)", "      xfree(saved_line);"], "readability/braces"]
["src/nvim/edit.c", ["", "  /*", "   * Strange Vi behaviour: In Replace mode, typing a NL will not delete the"], "readability/old_style_comment"]
["src/nvim/edit.c", ["   */", "  if ((State & REPLACE_FLAG)", "      && !(State & VREPLACE_FLAG)"], "readability/braces"]
["src/nvim/edit.c", ["", "  /*", "   * In VREPLACE mode, a NL replaces the rest of the line, and starts"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Handle digraph in insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    clear_showcmd();", "    insert_special(c, TRUE, FALSE);", "    return NUL;"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * Handle CTRL-E and CTRL-Y in Insert mode: copy char from other line."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  }", "  if ((colnr_T)temp > curwin->w_virtcol)", "    ptr = prev_ptr;"], "readability/braces"]
["src/nvim/edit.c", ["", "/*", " * CTRL-Y or CTRL-E typed in Insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (ctrl_x_mode == CTRL_X_SCROLL) {", "    if (c == Ctrl_Y)", "      scrolldown_clamp();"], "readability/braces"]
["src/nvim/edit.c", ["      scrolldown_clamp();", "    else", "      scrollup_clamp();"], "readability/braces"]
["src/nvim/edit.c", ["      curbuf->b_p_tw = -1;", "      insert_special(c, TRUE, FALSE);", "      curbuf->b_p_tw = tw_save;"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * Try to do some very smart auto-indenting."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * do some very smart indenting when entering '{' or '}'"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (((did_si || can_si_back) && c == '{') || (can_si && c == '}')) {", "    /*", "     * for '}' set indent equal to indent of line containing matching '{'"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      old_pos = curwin->w_cursor;", "      /*", "       * If the matching '{' has a ')' immediately before it (ignoring"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      curwin->w_cursor.col = i;", "      if (ptr[i] == ')' && (pos = findmatch(NULL, '(')) != NULL)", "        curwin->w_cursor = *pos;"], "readability/braces"]
["src/nvim/edit.c", ["      curwin->w_cursor = old_pos;", "      if (State & VREPLACE_FLAG)", "        change_indent(INDENT_SET, i, FALSE, NUL, TRUE);"], "readability/braces"]
["src/nvim/edit.c", ["      if (State & VREPLACE_FLAG)", "        change_indent(INDENT_SET, i, FALSE, NUL, TRUE);", "      else"], "readability/bool"]
["src/nvim/edit.c", ["        change_indent(INDENT_SET, i, FALSE, NUL, TRUE);", "      else", "        (void)set_indent(i, SIN_CHANGED);"], "readability/braces"]
["src/nvim/edit.c", ["    } else if (curwin->w_cursor.col > 0) {", "      /*", "       * when inserting '{' after \"O\" reduce indent, but not"], "readability/old_style_comment"]
["src/nvim/edit.c", ["       */", "      temp = TRUE;", "      if (c == '{' && can_si_back && curwin->w_cursor.lnum > 1) {"], "readability/bool"]
["src/nvim/edit.c", ["        }", "        if (get_indent() >= i)", "          temp = FALSE;"], "readability/braces"]
["src/nvim/edit.c", ["        if (get_indent() >= i)", "          temp = FALSE;", "        curwin->w_cursor = old_pos;"], "readability/bool"]
["src/nvim/edit.c", ["      }", "      if (temp)", "        shift_line(TRUE, FALSE, 1, TRUE);"], "readability/braces"]
["src/nvim/edit.c", ["      if (temp)", "        shift_line(TRUE, FALSE, 1, TRUE);", "    }"], "readability/bool"]
["src/nvim/edit.c", ["", "  /*", "   * set indent of '#' always to 0"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Get the value that w_virtcol would have when 'list' is off."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Handle the InsertCharPre autocommand."], "readability/old_style_comment"]
["src/nvim/edit.h", ["", "/*", " * Array indexes used for cptext argument of ins_compl_add()."], "readability/old_style_comment"]
["src/nvim/edit.h", ["", "/* Values for in_cinkeys() */", "#define KEY_OPEN_FORW   0x101"], "readability/old_style_comment"]
["src/nvim/edit.h", ["#define KEY_OPEN_BACK   0x102", "#define KEY_COMPLETE    0x103   /* end of completion */", ""], "readability/old_style_comment"]
["src/nvim/edit.h", ["", "/* Values for change_indent() */", "#define INDENT_SET      1       /* set indent */"], "readability/old_style_comment"]
["src/nvim/edit.h", ["/* Values for change_indent() */", "#define INDENT_SET      1       /* set indent */", "#define INDENT_INC      2       /* increase indent */"], "readability/old_style_comment"]
["src/nvim/edit.h", ["#define INDENT_SET      1       /* set indent */", "#define INDENT_INC      2       /* increase indent */", "#define INDENT_DEC      3       /* decrease indent */"], "readability/old_style_comment"]
["src/nvim/edit.h", ["#define INDENT_INC      2       /* increase indent */", "#define INDENT_DEC      3       /* decrease indent */", ""], "readability/old_style_comment"]
["src/nvim/edit.h", ["", "/* flags for beginline() */", "#define BL_WHITE        1       /* cursor on first non-white in the line */"], "readability/old_style_comment"]
["src/nvim/edit.h", ["/* flags for beginline() */", "#define BL_WHITE        1       /* cursor on first non-white in the line */", "#define BL_SOL          2       /* use 'sol' option */"], "readability/old_style_comment"]
["src/nvim/edit.h", ["#define BL_WHITE        1       /* cursor on first non-white in the line */", "#define BL_SOL          2       /* use 'sol' option */", "#define BL_FIX          4       /* don't leave cursor on a NUL */"], "readability/old_style_comment"]
["src/nvim/edit.h", ["#define BL_SOL          2       /* use 'sol' option */", "#define BL_FIX          4       /* don't leave cursor on a NUL */", ""], "readability/old_style_comment"]
["src/nvim/edit.h", ["", "/* flags for insertchar() */", "#define INSCHAR_FORMAT  1       /* force formatting */"], "readability/old_style_comment"]
["src/nvim/edit.h", ["/* flags for insertchar() */", "#define INSCHAR_FORMAT  1       /* force formatting */", "#define INSCHAR_DO_COM  2       /* format comments */"], "readability/old_style_comment"]
["src/nvim/edit.h", ["#define INSCHAR_FORMAT  1       /* force formatting */", "#define INSCHAR_DO_COM  2       /* format comments */", "#define INSCHAR_CTRLV   4       /* char typed just after CTRL-V */"], "readability/old_style_comment"]
["src/nvim/edit.h", ["#define INSCHAR_DO_COM  2       /* format comments */", "#define INSCHAR_CTRLV   4       /* char typed just after CTRL-V */", "#define INSCHAR_NO_FEX  8       /* don't use 'formatexpr' */"], "readability/old_style_comment"]
["src/nvim/edit.h", ["#define INSCHAR_CTRLV   4       /* char typed just after CTRL-V */", "#define INSCHAR_NO_FEX  8       /* don't use 'formatexpr' */", "#define INSCHAR_COM_LIST 16     /* format comments with list/2nd line indent */"], "readability/old_style_comment"]
["src/nvim/edit.h", ["#define INSCHAR_NO_FEX  8       /* don't use 'formatexpr' */", "#define INSCHAR_COM_LIST 16     /* format comments with list/2nd line indent */", ""], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * eval.c: Expression evaluation."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Old Vim variables such as \"v:version\" are also available without the \"v:\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Array to hold the hashtab with variables local to each sourced script."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "static garray_T ga_scripts = {0, 0, sizeof(scriptvar_T *), 4, NULL};", "#define SCRIPT_SV(id) (((scriptvar_T **)ga_scripts.ga_data)[(id) - 1])"], "whitespace/braces"]
["src/nvim/eval.c", ["", "static garray_T ga_scripts = {0, 0, sizeof(scriptvar_T *), 4, NULL};", "#define SCRIPT_SV(id) (((scriptvar_T **)ga_scripts.ga_data)[(id) - 1])"], "whitespace/braces"]
["src/nvim/eval.c", ["", "/*", " * Info used by a \":for\" loop."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Initialize the global and v: variables."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    STRCPY(p->vv_di.di_key, p->vv_name);", "    if (p->vv_flags & VV_RO)", "      p->vv_di.di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;"], "readability/braces"]
["src/nvim/eval.c", ["      p->vv_di.di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;", "    else if (p->vv_flags & VV_RO_SBX)", "      p->vv_di.di_flags = DI_FLAGS_RO_SBX | DI_FLAGS_FIX;"], "readability/braces"]
["src/nvim/eval.c", ["      p->vv_di.di_flags = DI_FLAGS_RO_SBX | DI_FLAGS_FIX;", "    else", "      p->vv_di.di_flags = DI_FLAGS_FIX;"], "readability/braces"]
["src/nvim/eval.c", ["", "  /* Script-local variables. First clear all the variables and in a second", "   * loop free the scriptvar_T, because a variable in one script might hold"], "readability/old_style_comment"]
["src/nvim/eval.c", ["   * a reference to the whole scope of another script. */", "  for (int i = 1; i <= ga_scripts.ga_len; ++i)", "    vars_clear(&SCRIPT_VARS(i));"], "readability/braces"]
["src/nvim/eval.c", ["   * a reference to the whole scope of another script. */", "  for (int i = 1; i <= ga_scripts.ga_len; ++i)", "    vars_clear(&SCRIPT_VARS(i));"], "readability/increment"]
["src/nvim/eval.c", ["    vars_clear(&SCRIPT_VARS(i));", "  for (int i = 1; i <= ga_scripts.ga_len; ++i)", "    xfree(SCRIPT_SV(i));"], "readability/braces"]
["src/nvim/eval.c", ["    vars_clear(&SCRIPT_VARS(i));", "  for (int i = 1; i <= ga_scripts.ga_len; ++i)", "    xfree(SCRIPT_SV(i));"], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * Set an internal variable to a string value. Creates the variable if it does"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Start recording command output to a variable"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /* check if we can write to the variable: set it to or append an empty", "   * string */"], "readability/old_style_comment"]
["src/nvim/eval.c", ["  save_emsg = did_emsg;", "  did_emsg = FALSE;", "  tv.v_type = VAR_STRING;"], "readability/bool"]
["src/nvim/eval.c", ["", "/*", " * Append \"value[value_len]\" to the variable set by var_redir_start()."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  if (redir_lval == NULL)", "    return;"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Stop redirecting command output to a variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  set_vim_var_string(VV_FNAME_OUT, outfile, -1);", "  (void)eval_to_bool(p_dex, &err, NULL, FALSE);", "  set_vim_var_string(VV_FNAME_IN, NULL, -1);"], "readability/bool"]
["src/nvim/eval.c", ["  set_vim_var_string(VV_FNAME_OUT, outfile, -1);", "  (void)eval_to_bool(p_pex, &err, NULL, FALSE);", "  set_vim_var_string(VV_FNAME_IN, NULL, -1);"], "readability/bool"]
["src/nvim/eval.c", ["", "/*", " * Top level evaluation function, returning a boolean."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Skip over an expression at \"*pp\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  *pp = skipwhite(*pp);", "  return eval1(pp, &rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval.c", ["", "/*", " * Top level evaluation function, returning a string."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Call eval_to_string() without using current local variables and using"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Top level evaluation function, returning a number."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  ++emsg_off;", ""], "readability/increment"]
["src/nvim/eval.c", ["  }", "  --emsg_off;", ""], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * Prepare v: variable \"idx\" to be used."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  *save_tv = vimvars[idx].vv_tv;", "  if (vimvars[idx].vv_type == VAR_UNKNOWN)", "    hash_add(&vimvarht, vimvars[idx].vv_di.di_key);"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Restore v: variable \"idx\" to typeval \"save_tv\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Evaluate an expression to a list with suggestions."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  vimvars[VV_VAL].vv_str = badword;", "  if (p_verbose == 0)", "    ++emsg_off;"], "readability/braces"]
["src/nvim/eval.c", ["  if (p_verbose == 0)", "    ++emsg_off;", ""], "readability/increment"]
["src/nvim/eval.c", ["", "  if (p_verbose == 0)", "    --emsg_off;"], "readability/braces"]
["src/nvim/eval.c", ["  if (p_verbose == 0)", "    --emsg_off;", "  restore_vimvar(VV_VAL, &save_val);"], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * Prepare profiling for entering a child or something else that is not"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Take care of time spent in a child."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Evaluate 'foldexpr'.  Returns the foldlevel, and any character preceding"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  ++emsg_off;", "  if (use_sandbox)"], "readability/increment"]
["src/nvim/eval.c", ["  ++emsg_off;", "  if (use_sandbox)", "    ++sandbox;"], "readability/braces"]
["src/nvim/eval.c", ["  if (use_sandbox)", "    ++sandbox;", "  ++textlock;"], "readability/increment"]
["src/nvim/eval.c", ["    ++sandbox;", "  ++textlock;", "  *cp = NUL;"], "readability/increment"]
["src/nvim/eval.c", ["  }", "  --emsg_off;", "  if (use_sandbox)"], "readability/increment"]
["src/nvim/eval.c", ["  --emsg_off;", "  if (use_sandbox)", "    --sandbox;"], "readability/braces"]
["src/nvim/eval.c", ["  if (use_sandbox)", "    --sandbox;", "  --textlock;"], "readability/increment"]
["src/nvim/eval.c", ["    --sandbox;", "  --textlock;", ""], "readability/increment"]
["src/nvim/eval.c", ["  char_u      *argend;", "  int first = TRUE;", ""], "readability/bool"]
["src/nvim/eval.c", ["", "    if (eap->skip)", "      ++emsg_skip;"], "readability/braces"]
["src/nvim/eval.c", ["    if (eap->skip)", "      ++emsg_skip;", "    i = eval0(expr, &rettv, &eap->nextcmd, !eap->skip);"], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * Assign the typevalue \"tv\" to the variable or variables at \"arg_start\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  if (*arg != '[') {", "    /*", "     * \":let var = expr\" or \":for var in list\""], "readability/old_style_comment"]
["src/nvim/eval.c", ["    if (*arg == ';') {", "      /* Put the rest of the list (may be empty) in the var after ';'.", "       * Create a new list for this. */"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Skip over assignable variable \"var\" or list of variables \"[var, var]\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["      }", "      ++*var_count;", ""], "readability/increment"]
["src/nvim/eval.c", ["      p = skipwhite(s);", "      if (*p == ']')", "        break;"], "readability/braces"]
["src/nvim/eval.c", ["        break;", "      else if (*p == ';') {", "        if (*semicolon == 1) {"], "readability/braces"]
["src/nvim/eval.c", ["    return p + 1;", "  } else", "    return skip_var_one(arg);"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Skip one (assignable) variable name, including @r, $VAR, &option, d.key,"], "readability/old_style_comment"]
["src/nvim/eval.c", ["{", "  if (*arg == '@' && arg[1] != NUL)", "    return arg + 2;"], "readability/braces"]
["src/nvim/eval.c", ["  return find_name_end(*arg == '$' || *arg == '&' ? arg + 1 : arg,", "      NULL, NULL, FNE_INCL_BR | FNE_CHECK_START);", "}"], "whitespace/alignment"]
["src/nvim/eval.c", ["", "/*", " * List variables for hashtab \"ht\" with prefix \"prefix\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  todo = (int)ht->ht_used;", "  for (hi = ht->ht_array; todo > 0 && !got_int; ++hi) {", "    if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * List global variables."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * List buffer variables."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * List window variables."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * List tab page variables."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * List Vim variables."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * List variables in \"arg\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["{", "  int error = FALSE;", "  int len;"], "readability/bool"]
["src/nvim/eval.c", ["      if (len <= 0) {", "        /* This is mainly to keep test 49 working: when expanding", "         * curly braces fails overrule the exception error message. */"], "readability/old_style_comment"]
["src/nvim/eval.c", ["        }", "        error = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/eval.c", ["", "  /*", "   * \":let $VAR = expr\": Set environment variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  }", "  /*", "   * \":let var = expr\": Set internal variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["   */", "  else if (eval_isnamec1(*arg) || *arg == '{') {", "    lval_T lv;"], "whitespace/newline"]
["src/nvim/eval.c", ["    clear_lval(&lv);", "  } else", "    EMSG2(_(e_invarg2), arg);"], "readability/braces"]
["src/nvim/eval.c", ["  typval_T var2;", "  int empty1 = FALSE;", "  listitem_T  *ni;"], "readability/bool"]
["src/nvim/eval.c", ["    if (lp->ll_exp_name == NULL) {", "      /* Report an invalid expression in braces, unless the", "       * expression evaluation has been cancelled due to an"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Loop until no more [idx] or .key is following."], "readability/old_style_comment"]
["src/nvim/eval.c", ["             && lp->ll_tv->vval.v_dict != NULL)) {", "      if (!quiet)", "        EMSG(_(\"E689: Can only index a List or Dictionary\"));"], "readability/braces"]
["src/nvim/eval.c", ["    if (lp->ll_range) {", "      if (!quiet)", "        EMSG(_(\"E708: [:] must come last\"));"], "readability/braces"]
["src/nvim/eval.c", ["", "      /* When assigning to a scope dictionary check that a function and", "       * variable name is valid (only variable name unless it is l: or"], "readability/old_style_comment"]
["src/nvim/eval.c", ["          if (ni == NULL) {", "            if (!quiet)", "              EMSGN(_(e_listidx), lp->ll_n2);"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Clear lval \"lp\" that was filled by get_lval()."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Set a variable that was parsed by get_lval() to \"rettv\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    /*", "     * Assign the List values to the list items."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Evaluate the expression used in a \":for var in expr\" command."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  expr = skip_var_list(arg, &fi->fi_varcount, &fi->fi_semicolon);", "  if (expr == NULL)", "    return fi;"], "readability/braces"]
["src/nvim/eval.c", ["", "  if (skip)", "    ++emsg_skip;"], "readability/braces"]
["src/nvim/eval.c", ["  if (skip)", "    ++emsg_skip;", "  if (eval0(skipwhite(expr + 2), &tv, nextcmdp, !skip) == OK) {"], "readability/increment"]
["src/nvim/eval.c", ["      } else {", "        /* No need to increment the refcount, it's already set for the", "         * list being used in \"tv\". */"], "readability/old_style_comment"]
["src/nvim/eval.c", ["  }", "  if (skip)", "    --emsg_skip;"], "readability/braces"]
["src/nvim/eval.c", ["  if (skip)", "    --emsg_skip;", ""], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * Use the first item in a \":for\" list.  Advance to the next."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Free the structure used to store info used by \":for\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["{", "  int got_eq = FALSE;", "  int c;"], "readability/bool"]
["src/nvim/eval.c", ["    }", "  } else", "    xp->xp_context = cmdidx == CMD_call ? EXPAND_FUNCTIONS"], "readability/braces"]
["src/nvim/eval.c", ["  while ((xp->xp_pattern = vim_strpbrk(arg,", "              (char_u *)\"\\\"'+-*/%.=!?~|&$([<>,#\")) != NULL) {", "    c = *xp->xp_pattern;"], "whitespace/alignment"]
["src/nvim/eval.c", ["      if (c == '&') {", "        ++xp->xp_pattern;", "        xp->xp_context = cmdidx != CMD_let || got_eq"], "readability/increment"]
["src/nvim/eval.c", ["        xp->xp_context = EXPAND_SETTINGS;", "        if ((c == 'l' || c == 'g') && xp->xp_pattern[2] == ':')", "          xp->xp_pattern += 2;"], "readability/braces"]
["src/nvim/eval.c", ["          xp->xp_pattern += 2;", "", "      }"], "whitespace/blank_line"]
["src/nvim/eval.c", ["    } else if (c == '=') {", "      got_eq = TRUE;", "      xp->xp_context = EXPAND_EXPRESSION;"], "readability/bool"]
["src/nvim/eval.c", ["        if (xp->xp_pattern[1] == '|') {", "          ++xp->xp_pattern;", "          xp->xp_context = EXPAND_EXPRESSION;"], "readability/increment"]
["src/nvim/eval.c", ["          xp->xp_context = EXPAND_EXPRESSION;", "        } else", "          xp->xp_context = EXPAND_COMMANDS;"], "readability/braces"]
["src/nvim/eval.c", ["          xp->xp_context = EXPAND_COMMANDS;", "      } else", "        xp->xp_context = EXPAND_EXPRESSION;"], "readability/braces"]
["src/nvim/eval.c", ["        xp->xp_context = EXPAND_EXPRESSION;", "    } else", "      /* Doesn't look like something valid, expand as an expression"], "readability/braces"]
["src/nvim/eval.c", ["    } else", "      /* Doesn't look like something valid, expand as an expression", "       * anyway. */"], "readability/old_style_comment"]
["src/nvim/eval.c", ["  }", "  if (forceit)", "    return OK;"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Delete all \"menutrans_\" variables."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Local string buffer for the next two functions to store a variable name"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Function to concatenate a prefix and a variable name."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the list of user defined"], "readability/old_style_comment"]
["src/nvim/eval.c", ["  if (gdone < globvarht.ht_used) {", "    if (gdone++ == 0)", "      hi = globvarht.ht_array;"], "readability/braces"]
["src/nvim/eval.c", ["      hi = globvarht.ht_array;", "    else", "      ++hi;"], "readability/braces"]
["src/nvim/eval.c", ["    else", "      ++hi;", "    while (HASHITEM_EMPTY(hi))"], "readability/increment"]
["src/nvim/eval.c", ["      ++hi;", "    while (HASHITEM_EMPTY(hi))", "      ++hi;"], "readability/braces"]
["src/nvim/eval.c", ["    while (HASHITEM_EMPTY(hi))", "      ++hi;", "    if (STRNCMP(\"g:\", xp->xp_pattern, 2) == 0)"], "readability/increment"]
["src/nvim/eval.c", ["      ++hi;", "    if (STRNCMP(\"g:\", xp->xp_pattern, 2) == 0)", "      return cat_prefix_varname('g', hi->hi_key);"], "readability/braces"]
["src/nvim/eval.c", ["  if (bdone < ht->ht_used) {", "    if (bdone++ == 0)", "      hi = ht->ht_array;"], "readability/braces"]
["src/nvim/eval.c", ["      hi = ht->ht_array;", "    else", "      ++hi;"], "readability/braces"]
["src/nvim/eval.c", ["    else", "      ++hi;", "    while (HASHITEM_EMPTY(hi))"], "readability/increment"]
["src/nvim/eval.c", ["      ++hi;", "    while (HASHITEM_EMPTY(hi))", "      ++hi;"], "readability/braces"]
["src/nvim/eval.c", ["    while (HASHITEM_EMPTY(hi))", "      ++hi;", "    return cat_prefix_varname('b', hi->hi_key);"], "readability/increment"]
["src/nvim/eval.c", ["  if (wdone < ht->ht_used) {", "    if (wdone++ == 0)", "      hi = ht->ht_array;"], "readability/braces"]
["src/nvim/eval.c", ["      hi = ht->ht_array;", "    else", "      ++hi;"], "readability/braces"]
["src/nvim/eval.c", ["    else", "      ++hi;", "    while (HASHITEM_EMPTY(hi))"], "readability/increment"]
["src/nvim/eval.c", ["      ++hi;", "    while (HASHITEM_EMPTY(hi))", "      ++hi;"], "readability/braces"]
["src/nvim/eval.c", ["    while (HASHITEM_EMPTY(hi))", "      ++hi;", "    return cat_prefix_varname('w', hi->hi_key);"], "readability/increment"]
["src/nvim/eval.c", ["  if (tdone < ht->ht_used) {", "    if (tdone++ == 0)", "      hi = ht->ht_array;"], "readability/braces"]
["src/nvim/eval.c", ["      hi = ht->ht_array;", "    else", "      ++hi;"], "readability/braces"]
["src/nvim/eval.c", ["    else", "      ++hi;", "    while (HASHITEM_EMPTY(hi))"], "readability/increment"]
["src/nvim/eval.c", ["      ++hi;", "    while (HASHITEM_EMPTY(hi))", "      ++hi;"], "readability/braces"]
["src/nvim/eval.c", ["    while (HASHITEM_EMPTY(hi))", "      ++hi;", "    return cat_prefix_varname('t', hi->hi_key);"], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * The \"evaluate\" argument: When FALSE, the argument is only parsed but not"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Handle zero level expression."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  }", "  if (nextcmd != NULL)", "    *nextcmd = check_nextcmd(p);"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Handle top level expression:"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Get the first variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["   */", "  if (eval2(arg, rettv, evaluate) == FAIL)", "    return FAIL;"], "readability/braces"]
["src/nvim/eval.c", ["  if ((*arg)[0] == '?') {", "    result = FALSE;", "    if (evaluate) {"], "readability/bool"]
["src/nvim/eval.c", ["", "    /*", "     * Get the second variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    /*", "     * Check for the \":\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    /*", "     * Get the third variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    }", "    if (evaluate && !result)", "      *rettv = var2;"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Handle first level expression:"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Get the first variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["   */", "  if (eval3(arg, rettv, evaluate) == FAIL)", "    return FAIL;"], "readability/braces"]
["src/nvim/eval.c", ["", "  /*", "   * Repeat until there is no following \"||\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["   */", "  first = TRUE;", "  result = FALSE;"], "readability/bool"]
["src/nvim/eval.c", ["  first = TRUE;", "  result = FALSE;", "  while ((*arg)[0] == '|' && (*arg)[1] == '|') {"], "readability/bool"]
["src/nvim/eval.c", ["", "    /*", "     * Get the second variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    *arg = skipwhite(*arg + 2);", "    if (eval3(arg, &var2, evaluate && !result) == FAIL)", "      return FAIL;"], "readability/braces"]
["src/nvim/eval.c", ["", "    /*", "     * Compute the result."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Handle second level expression:"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Get the first variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["   */", "  if (eval4(arg, rettv, evaluate) == FAIL)", "    return FAIL;"], "readability/braces"]
["src/nvim/eval.c", ["", "  /*", "   * Repeat until there is no following \"&&\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["   */", "  first = TRUE;", "  result = TRUE;"], "readability/bool"]
["src/nvim/eval.c", ["  first = TRUE;", "  result = TRUE;", "  while ((*arg)[0] == '&' && (*arg)[1] == '&') {"], "readability/bool"]
["src/nvim/eval.c", ["", "    /*", "     * Get the second variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    *arg = skipwhite(*arg + 2);", "    if (eval4(arg, &var2, evaluate && result) == FAIL)", "      return FAIL;"], "readability/braces"]
["src/nvim/eval.c", ["", "    /*", "     * Compute the result."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Handle third level expression:"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Get the first variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["   */", "  if (eval5(arg, rettv, evaluate) == FAIL)", "    return FAIL;"], "readability/braces"]
["src/nvim/eval.c", ["", "  /*", "   * If there is a comparative operator, use it."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Handle fourth level expression:"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Get the first variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["   */", "  if (eval6(arg, rettv, evaluate, FALSE) == FAIL)", "    return FAIL;"], "readability/braces"]
["src/nvim/eval.c", ["   */", "  if (eval6(arg, rettv, evaluate, FALSE) == FAIL)", "    return FAIL;"], "readability/bool"]
["src/nvim/eval.c", ["", "  /*", "   * Repeat computing, until no '+', '-' or '.' is following."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    op = **arg;", "    if (op != '+' && op != '-' && op != '.')", "      break;"], "readability/braces"]
["src/nvim/eval.c", ["", "    /*", "     * Get the second variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    if (evaluate) {", "      /*", "       * Compute the result."], "readability/old_style_comment"]
["src/nvim/eval.c", ["          if (error) {", "            /* This can only happen for \"list + non-list\".  For", "             * \"non-list + ...\" or \"something - ...\", we returned"], "readability/old_style_comment"]
["src/nvim/eval.c", ["          }", "          if (var2.v_type == VAR_FLOAT)", "            f1 = n1;"], "readability/braces"]
["src/nvim/eval.c", ["          }", "          if (rettv->v_type == VAR_FLOAT)", "            f2 = n2;"], "readability/braces"]
["src/nvim/eval.c", ["        if (rettv->v_type == VAR_FLOAT || var2.v_type == VAR_FLOAT) {", "          if (op == '+')", "            f1 = f1 + f2;"], "readability/braces"]
["src/nvim/eval.c", ["            f1 = f1 + f2;", "          else", "            f1 = f1 - f2;"], "readability/braces"]
["src/nvim/eval.c", ["        } else {", "          if (op == '+')", "            n1 = n1 + n2;"], "readability/braces"]
["src/nvim/eval.c", ["            n1 = n1 + n2;", "          else", "            n1 = n1 - n2;"], "readability/braces"]
["src/nvim/eval.c", ["", "  /*", "   * Get the first variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["   */", "  if (eval7(arg, rettv, evaluate, want_string) == FAIL)", "    return FAIL;"], "readability/braces"]
["src/nvim/eval.c", ["", "  /*", "   * Repeat computing, until no '*', '/' or '%' is following."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    /*", "     * Get the second variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    *arg = skipwhite(*arg + 1);", "    if (eval7(arg, &var2, evaluate, FALSE) == FAIL)", "      return FAIL;"], "readability/braces"]
["src/nvim/eval.c", ["    *arg = skipwhite(*arg + 1);", "    if (eval7(arg, &var2, evaluate, FALSE) == FAIL)", "      return FAIL;"], "readability/bool"]
["src/nvim/eval.c", ["", "      /*", "       * Compute the result."], "readability/old_style_comment"]
["src/nvim/eval.c", ["      if (*p == 'e' || *p == 'E') {", "        ++p;", "        if (*p == '-' || *p == '+') {"], "readability/increment"]
["src/nvim/eval.c", ["        if (*p == '-' || *p == '+') {", "          ++p;", "        }"], "readability/increment"]
["src/nvim/eval.c", ["", "      *arg += string2float((char *) *arg, &f);", "      if (evaluate) {"], "whitespace/cast"]
["src/nvim/eval.c", ["    if (**arg != NUL) {", "      ++*arg;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["    if (**arg == ')') {", "      ++*arg;", "    } else if (ret == OK) {"], "readability/increment"]
["src/nvim/eval.c", ["      while (end_leader > start_leader) {", "        --end_leader;", "        if (*end_leader == '!') {"], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * Evaluate an \"[expr]\" or \"[expr:expr]\" index.  Also \"dict.key\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  if (**arg == '.') {", "    /*", "     * dict.name"], "readability/old_style_comment"]
["src/nvim/eval.c", ["    key = *arg + 1;", "    for (len = 0; ASCII_ISALNUM(key[len]) || key[len] == '_'; ++len)", "      ;"], "readability/braces"]
["src/nvim/eval.c", ["    key = *arg + 1;", "    for (len = 0; ASCII_ISALNUM(key[len]) || key[len] == '_'; ++len)", "      ;"], "readability/increment"]
["src/nvim/eval.c", ["    for (len = 0; ASCII_ISALNUM(key[len]) || key[len] == '_'; ++len)", "      ;", "    if (len == 0)"], "whitespace/semicolon"]
["src/nvim/eval.c", ["      ;", "    if (len == 0)", "      return FAIL;"], "readability/braces"]
["src/nvim/eval.c", ["  } else {", "    /*", "     * something[idx]"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    /*", "     * Get the second variable from inside the [:]."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    if (**arg == ':') {", "      range = TRUE;", "      *arg = skipwhite(*arg + 1);"], "readability/bool"]
["src/nvim/eval.c", ["    }", "  } else if (working && (opt_type == -2 || opt_type == -1))", "    ret = FAIL;"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Allocate a variable for a string constant."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Find the end of the string, skipping backslashed characters."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Copy the string into allocated memory, handling backslashed"], "readability/old_style_comment"]
["src/nvim/eval.c", ["          while (--n >= 0 && ascii_isxdigit(p[1])) {", "            ++p;", "            nr = (nr << 4) + hex2nr(*p);"], "readability/increment"]
["src/nvim/eval.c", ["          }", "          ++p;", "          /* For \"\\u\" store the number according to"], "readability/increment"]
["src/nvim/eval.c", ["          ++p;", "          /* For \"\\u\" store the number according to", "           * 'encoding'. */"], "readability/old_style_comment"]
["src/nvim/eval.c", ["          *name = (*name << 3) + *p++ - '0';", "          if (*p >= '0' && *p <= '7')", "            *name = (*name << 3) + *p++ - '0';"], "readability/braces"]
["src/nvim/eval.c", ["        }", "        ++name;", "        break;"], "readability/increment"]
["src/nvim/eval.c", ["      }", "    } else", "      MB_COPY_CHAR(p, name);"], "readability/braces"]
["src/nvim/eval.c", ["      MB_COPY_CHAR(p, name);", "", "  }"], "whitespace/blank_line"]
["src/nvim/eval.c", ["", "/*", " * Allocate a variable for a 'str''ing' constant."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Find the end of the string, skipping ''."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    if (*p == '\\'') {", "      if (p[1] != '\\'')", "        break;"], "readability/braces"]
["src/nvim/eval.c", ["        break;", "      ++reduce;", "      ++p;"], "readability/increment"]
["src/nvim/eval.c", ["      ++reduce;", "      ++p;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["", "  /*", "   * Copy the string into allocated memory, handling '' to ' reduction."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    if (*p == '\\'') {", "      if (p[1] != '\\'')", "        break;"], "readability/braces"]
["src/nvim/eval.c", ["        break;", "      ++p;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["    bool ic         // ignore case", ") {", "  char_u *s1, *s2;"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Garbage collection for lists and dictionaries."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  // script-local variables", "  for (int i = 1; i <= ga_scripts.ga_len; ++i) {", "    ABORTING(set_ref_in_ht)(&SCRIPT_VARS(i), copyID, NULL);"], "readability/increment"]
["src/nvim/eval.c", ["", "  /*", "   * First check if it's not a curly-braces thing: {expr}."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    if (**arg == '}')", "      break;"], "readability/braces"]
["src/nvim/eval.c", ["  *ret_value = strtod(text, &s);", "  return (size_t) (s - text);", "}"], "whitespace/cast"]
["src/nvim/eval.c", ["", "  ++*arg;", "  name = *arg;"], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * Implementation of map() and filter()."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    save_did_emsg = did_emsg;", "    did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["      todo = (int)ht->ht_used;", "      for (hi = ht->ht_array; todo > 0; ++hi) {", "        if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval.c", ["        if (!HASHITEM_EMPTY(hi)) {", "          --todo;", ""], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * getwinvar() and gettabwinvar()"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * This function is used by f_input() and f_inputdialog() functions. The third"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * \"setwinvar()\" and \"settabwinvar()\" functions"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  set_vim_var_nr(VV_SHELL_ERROR, (long) status);", ""], "whitespace/cast"]
["src/nvim/eval.c", ["    } else {", "      rettv->vval.v_string = (char_u *) xstrdup(\"\");", "    }"], "whitespace/cast"]
["src/nvim/eval.c", ["    char *d = res;", "    for (char *s = res; *s; ++s) {", "      if (s[0] == CAR && s[1] == NL) {"], "readability/increment"]
["src/nvim/eval.c", ["      if (s[0] == CAR && s[1] == NL) {", "        ++s;", "      }"], "readability/increment"]
["src/nvim/eval.c", ["#endif", "    rettv->vval.v_string = (char_u *) res;", "  }"], "whitespace/cast"]
["src/nvim/eval.c", ["", "/*", " * Convert list in \"arg\" into a position and optional file number."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Get the length of an environment variable name."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Get the length of the name of a variable or function."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    /*", "     * Include any <SID> etc in the expanded string:"], "readability/old_style_comment"]
["src/nvim/eval.c", ["        if (*p == '\\\\' && p[1] != NUL) {", "          ++p;", "        }"], "readability/increment"]
["src/nvim/eval.c", ["      if (*p == '[') {", "        ++br_nest;", "      } else if (*p == ']') {"], "readability/increment"]
["src/nvim/eval.c", ["      } else if (*p == ']') {", "        --br_nest;", "      }"], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * Expands out the 'magic' {}'s in a variable/function name."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  if (expr_end == NULL || in_end == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/eval.c", ["", "  temp_result = eval_to_string(expr_start + 1, &nextcmd, FALSE);", "  if (temp_result != NULL && nextcmd == NULL) {"], "readability/bool"]
["src/nvim/eval.c", ["      temp_result = make_expanded_name(retval, expr_start,", "          expr_end, temp_result);", "      xfree(retval);"], "whitespace/alignment"]
["src/nvim/eval.c", ["", "/*", " * Return TRUE if character \"c\" can be used in a variable or function name."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Return TRUE if character \"c\" can be used as the first character in a"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Get number v: variable value."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Get List v: variable value.  Caller must take care of reference count when"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Set v:char to character \"c\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Set v:count to \"count\" and v:count1 to \"count1\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["{", "  if (set_prevcount)", "    vimvars[VV_PREVCOUNT].vv_nr = vimvars[VV_COUNT].vv_nr;"], "readability/braces"]
["src/nvim/eval.c", ["  } else if (len == -1) {", "    vimvars[idx].vv_str = (char_u *) xstrdup(val);", "  } else {"], "whitespace/cast"]
["src/nvim/eval.c", ["  } else {", "    vimvars[idx].vv_str = (char_u *) xstrndup(val, (size_t) len);", "  }"], "whitespace/cast"]
["src/nvim/eval.c", ["", "/*", " * Set v:register if needed."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Get or set v:exception.  If \"oldval\" == NULL, return the current value."], "readability/old_style_comment"]
["src/nvim/eval.c", ["{", "  if (oldval == NULL)", "    return vimvars[VV_EXCEPTION].vv_str;"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Get or set v:throwpoint.  If \"oldval\" == NULL, return the current value."], "readability/old_style_comment"]
["src/nvim/eval.c", ["{", "  if (oldval == NULL)", "    return vimvars[VV_THROWPOINT].vv_str;"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Set v:cmdarg."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  size_t len = 0;", "  if (eap->force_bin == FORCE_BIN)", "    len = 6;"], "readability/braces"]
["src/nvim/eval.c", ["    len = 6;", "  else if (eap->force_bin == FORCE_NOBIN)", "    len = 8;"], "readability/braces"]
["src/nvim/eval.c", ["", "  if (eap->read_edit)", "    len += 7;"], "readability/braces"]
["src/nvim/eval.c", ["", "  if (eap->force_bin == FORCE_BIN)", "    sprintf((char *)newval, \" ++bin\");"], "readability/braces"]
["src/nvim/eval.c", ["  if (eap->force_bin == FORCE_BIN)", "    sprintf((char *)newval, \" ++bin\");", "  else if (eap->force_bin == FORCE_NOBIN)"], "runtime/printf"]
["src/nvim/eval.c", ["    sprintf((char *)newval, \" ++bin\");", "  else if (eap->force_bin == FORCE_NOBIN)", "    sprintf((char *)newval, \" ++nobin\");"], "readability/braces"]
["src/nvim/eval.c", ["  else if (eap->force_bin == FORCE_NOBIN)", "    sprintf((char *)newval, \" ++nobin\");", "  else"], "runtime/printf"]
["src/nvim/eval.c", ["    sprintf((char *)newval, \" ++nobin\");", "  else", "    *newval = NUL;"], "readability/braces"]
["src/nvim/eval.c", ["", "  if (eap->read_edit)", "    STRCAT(newval, \" ++edit\");"], "readability/braces"]
["src/nvim/eval.c", ["", "      /* Stop the expression evaluation when immediately aborting on", "       * error, or when an interrupt occurred or an exception was thrown"], "readability/old_style_comment"]
["src/nvim/eval.c", ["        selfdict = rettv->vval.v_dict;", "        if (selfdict != NULL)", "          ++selfdict->dv_refcount;"], "readability/braces"]
["src/nvim/eval.c", ["        if (selfdict != NULL)", "          ++selfdict->dv_refcount;", "      } else"], "readability/increment"]
["src/nvim/eval.c", ["          ++selfdict->dv_refcount;", "      } else", "        selfdict = NULL;"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Get the string value of a (global/local) variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Allocate a new hashtab for a sourced script.  It will be used while"], "readability/old_style_comment"]
["src/nvim/eval.c", ["  {", "    /* Re-allocating ga_data means that an ht_array pointing to", "     * ht_smallarray becomes invalid.  We can recognize this: ht_mask is"], "readability/old_style_comment"]
["src/nvim/eval.c", ["     * at its init value.  Also reset \"v_dict\", it's always the same. */", "    for (int i = 1; i <= ga_scripts.ga_len; ++i) {", "      ht = &SCRIPT_VARS(i);"], "readability/increment"]
["src/nvim/eval.c", ["      ht = &SCRIPT_VARS(i);", "      if (ht->ht_mask == HT_INIT_SIZE - 1)", "        ht->ht_array = ht->ht_smallarray;"], "readability/braces"]
["src/nvim/eval.c", ["      init_var_dict(&sv->sv_dict, &sv->sv_var, VAR_SCOPE);", "      ++ga_scripts.ga_len;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * Initialize dictionary \"dict\" as a scope and set variable \"dict_var\" to"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Unreference a dictionary initialized by init_var_dict()."], "readability/old_style_comment"]
["src/nvim/eval.c", ["{", "  /* Now the dict needs to be freed if no one else is using it, go back to", "   * normal reference counting. */"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Clean up a list of internal variables."], "readability/old_style_comment"]
["src/nvim/eval.c", ["{", "  vars_clear_ext(ht, TRUE);", "}"], "readability/bool"]
["src/nvim/eval.c", ["", "/*", " * Like vars_clear(), but only free the value if \"free_val\" is TRUE."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  todo = (int)ht->ht_used;", "  for (hi = ht->ht_array; todo > 0; ++hi) {", "    if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval.c", ["    if (!HASHITEM_EMPTY(hi)) {", "      --todo;", ""], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * Delete a variable from hashtab \"ht\" at item \"hi\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * List the value of one internal variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    msg_putchar('[');", "    if (*string == '[')", "      ++string;"], "readability/braces"]
["src/nvim/eval.c", ["    if (*string == '[')", "      ++string;", "  } else if (type == VAR_DICT) {"], "readability/increment"]
["src/nvim/eval.c", ["    msg_putchar('{');", "    if (*string == '{')", "      ++string;"], "readability/braces"]
["src/nvim/eval.c", ["    if (*string == '{')", "      ++string;", "  } else"], "readability/increment"]
["src/nvim/eval.c", ["      ++string;", "  } else", "    msg_putchar(' ');"], "readability/braces"]
["src/nvim/eval.c", ["    msg_clr_eos();", "    *first = FALSE;", "  }"], "readability/bool"]
["src/nvim/eval.c", ["      && !ASCII_ISUPPER((name[0] != NUL && name[1] == ':') ? name[2]", "                                                           : name[0])) {", "    EMSG2(_(\"E704: Funcref variable name must start with a capital: %s\"), name);"], "whitespace/alignment"]
["src/nvim/eval.c", ["      && !ASCII_ISUPPER((name[0] != NUL && name[1] == ':') ? name[2]", "                                                           : name[0])) {", "    EMSG2(_(\"E704: Funcref variable name must start with a capital: %s\"), name);"], "whitespace/alignment"]
["src/nvim/eval.c", ["  }", "  ++recurse;", ""], "readability/increment"]
["src/nvim/eval.c", ["          == NULL) {", "        to->vval.v_string = (char_u *) xstrdup((char *) from->vval.v_string);", "      }"], "whitespace/cast"]
["src/nvim/eval.c", ["      to->vval.v_dict = from->vval.v_dict->dv_copydict;", "      ++to->vval.v_dict->dv_refcount;", "    } else {"], "readability/increment"]
["src/nvim/eval.c", ["  }", "  --recurse;", "  return ret;"], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * \":echo expr1 ...\"\tprint each argument separated with a space, add a"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  if (eap->skip)", "    ++emsg_skip;"], "readability/braces"]
["src/nvim/eval.c", ["  if (eap->skip)", "    ++emsg_skip;", "  while (*arg != NUL && *arg != '|' && *arg != '\\n' && !got_int) {"], "readability/increment"]
["src/nvim/eval.c", ["        atstart = false;", "        /* Call msg_start() after eval1(), evaluating the expression", "         * may cause a message to appear. */"], "readability/old_style_comment"]
["src/nvim/eval.c", ["        if (eap->cmdidx == CMD_echo) {", "          /* Mark the saved text as finishing the line, so that what", "           * follows is displayed on a new line when scrolling back"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * \":echohl {name}\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * \":execute expr1 ...\"\texecute the result of an expression."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  if (eap->skip)", "    ++emsg_skip;"], "readability/braces"]
["src/nvim/eval.c", ["  if (eap->skip)", "    ++emsg_skip;", "  while (*arg != NUL && *arg != '|' && *arg != '\\n') {"], "readability/increment"]
["src/nvim/eval.c", ["      EMSG((char_u *)ga.ga_data);", "      if (!force_abort)", "        did_emsg = save_did_emsg;"], "readability/braces"]
["src/nvim/eval.c", ["        did_emsg = save_did_emsg;", "    } else if (eap->cmdidx == CMD_execute)", "      do_cmdline((char_u *)ga.ga_data,"], "readability/braces"]
["src/nvim/eval.c", ["      do_cmdline((char_u *)ga.ga_data,", "          eap->getline, eap->cookie, DOCMD_NOWAIT|DOCMD_VERBOSE);", "  }"], "whitespace/alignment"]
["src/nvim/eval.c", ["", "  if (eap->skip)", "    --emsg_skip;"], "readability/braces"]
["src/nvim/eval.c", ["  if (eap->skip)", "    --emsg_skip;", ""], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * Skip over the name of an option: \"&option\", \"&g:option\" or \"&l:option\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  ++p;", "  if (*p == 'g' && p[1] == ':') {"], "readability/increment"]
["src/nvim/eval.c", ["", "  fp->uf_profiling = TRUE;", "}"], "readability/bool"]
["src/nvim/eval.c", ["", "/*", " * Dump the profiling results for all functions in file \"fd\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  for (hi = func_hashtab.ht_array; todo > 0; ++hi) {", "    if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval.c", ["    if (!HASHITEM_EMPTY(hi)) {", "      --todo;", "      fp = HI2UF(hi);"], "readability/increment"]
["src/nvim/eval.c", ["", "        for (int i = 0; i < fp->uf_lines.ga_len; ++i) {", "          if (FUNCLINE(fp, i) == NULL)"], "readability/increment"]
["src/nvim/eval.c", ["        for (int i = 0; i < fp->uf_lines.ga_len; ++i) {", "          if (FUNCLINE(fp, i) == NULL)", "            continue;"], "readability/braces"]
["src/nvim/eval.c", ["          prof_func_line(fd, fp->uf_tml_count[i],", "              &fp->uf_tml_total[i], &fp->uf_tml_self[i], TRUE);", "          fprintf(fd, \"%s\\n\", FUNCLINE(fp, i));"], "whitespace/alignment"]
["src/nvim/eval.c", ["          prof_func_line(fd, fp->uf_tml_count[i],", "              &fp->uf_tml_total[i], &fp->uf_tml_self[i], TRUE);", "          fprintf(fd, \"%s\\n\", FUNCLINE(fp, i));"], "readability/bool"]
["src/nvim/eval.c", ["    qsort((void *)sorttab, (size_t)st_len, sizeof(ufunc_T *),", "        prof_total_cmp);", "    prof_sort_list(fd, sorttab, st_len, \"TOTAL\", FALSE);"], "whitespace/alignment"]
["src/nvim/eval.c", ["        prof_total_cmp);", "    prof_sort_list(fd, sorttab, st_len, \"TOTAL\", FALSE);", "    qsort((void *)sorttab, (size_t)st_len, sizeof(ufunc_T *),"], "readability/bool"]
["src/nvim/eval.c", ["    qsort((void *)sorttab, (size_t)st_len, sizeof(ufunc_T *),", "        prof_self_cmp);", "    prof_sort_list(fd, sorttab, st_len, \"SELF\", TRUE);"], "whitespace/alignment"]
["src/nvim/eval.c", ["        prof_self_cmp);", "    prof_sort_list(fd, sorttab, st_len, \"SELF\", TRUE);", "  }"], "readability/bool"]
["src/nvim/eval.c", ["  fprintf(fd, \"count  total (s)   self (s)  function\\n\");", "  for (i = 0; i < 20 && i < st_len; ++i) {", "    fp = sorttab[i];"], "readability/increment"]
["src/nvim/eval.c", ["    prof_func_line(fd, fp->uf_tm_count, &fp->uf_tm_total, &fp->uf_tm_self,", "        prefer_self);", "    if (fp->uf_name[0] == K_SPECIAL)"], "whitespace/alignment"]
["src/nvim/eval.c", ["        prefer_self);", "    if (fp->uf_name[0] == K_SPECIAL)", "      fprintf(fd, \" <SNR>%s()\\n\", fp->uf_name + 3);"], "readability/braces"]
["src/nvim/eval.c", ["      fprintf(fd, \" <SNR>%s()\\n\", fp->uf_name + 3);", "    else", "      fprintf(fd, \" %s()\\n\", fp->uf_name);"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Print the count and times for one function or function line."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    fprintf(fd, \"%5d \", count);", "    if (prefer_self && profile_equal(*total, *self))", "      fprintf(fd, \"           \");"], "readability/braces"]
["src/nvim/eval.c", ["      fprintf(fd, \"           \");", "    else", "      fprintf(fd, \"%s \", profile_msg(*total));"], "readability/braces"]
["src/nvim/eval.c", ["      fprintf(fd, \"%s \", profile_msg(*total));", "    if (!prefer_self && profile_equal(*total, *self))", "      fprintf(fd, \"           \");"], "readability/braces"]
["src/nvim/eval.c", ["      fprintf(fd, \"           \");", "    else", "      fprintf(fd, \"%s \", profile_msg(*self));"], "readability/braces"]
["src/nvim/eval.c", ["      fprintf(fd, \"%s \", profile_msg(*self));", "  } else", "    fprintf(fd, \"                            \");"], "readability/braces"]
["src/nvim/eval.c", ["", "/*", " * Compare function for total time sorting."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Compare function for self time sorting."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Called when starting to read a function line."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Called when actually executing a function line."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  if (fp->uf_profiling && fp->uf_tml_idx >= 0)", "    fp->uf_tml_execed = TRUE;"], "readability/braces"]
["src/nvim/eval.c", ["  if (fp->uf_profiling && fp->uf_tml_idx >= 0)", "    fp->uf_tml_execed = TRUE;", "}"], "readability/bool"]
["src/nvim/eval.c", ["", "/*", " * Called when done with a function line."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    if (fp->uf_tml_execed) {", "      ++fp->uf_tml_count[fp->uf_tml_idx];", "      fp->uf_tml_start = profile_end(fp->uf_tml_start);"], "readability/increment"]
["src/nvim/eval.c", ["        profile_self(fp->uf_tml_self[fp->uf_tml_idx], fp->uf_tml_start,", "          fp->uf_tml_children);", "    }"], "whitespace/alignment"]
["src/nvim/eval.c", ["  if (ASCII_ISUPPER(*p)) {", "    while (*(++p))", "      if (ASCII_ISLOWER(*p)) {"], "readability/braces"]
["src/nvim/eval.c", ["  const hashitem_T *hifirst = globvarht.ht_array;", "  const size_t hinum = (size_t) globvarht.ht_mask + 1;", "  *name = NULL;"], "whitespace/cast"]
["src/nvim/eval.c", ["    hi = globvarht.ht_array;", "    while ((size_t) (hi - hifirst) < hinum", "           && (HASHITEM_EMPTY(hi)"], "whitespace/cast"]
["src/nvim/eval.c", ["    }", "    if ((size_t) (hi - hifirst) == hinum) {", "      return NULL;"], "whitespace/cast"]
["src/nvim/eval.c", ["  } else {", "    hi = (const hashitem_T *) iter;", "  }"], "whitespace/cast"]
["src/nvim/eval.c", ["", "/*", " * Display script name where an item was last set."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Adjust a filename, according to a string of modifiers."], "readability/old_style_comment"]
["src/nvim/eval.c", ["      *bufp = *fnamep;", "      if (*fnamep == NULL)", "        return -1;"], "readability/braces"]
["src/nvim/eval.c", ["      *bufp = *fnamep;", "      if (*fnamep == NULL)", "        return -1;"], "readability/braces"]
["src/nvim/eval.c", ["      *bufp = *fnamep;", "      if (*fnamep == NULL)", "        return -1;"], "readability/braces"]
["src/nvim/eval.c", ["        return -1;", "      add_pathsep((char *)*fnamep);", "    }"], "whitespace/operators"]
["src/nvim/eval.c", ["    if (!has_fullname) {", "      if (c == '.' && **fnamep == '~')", "        p = pbuf = expand_env_save(*fnamep);"], "readability/braces"]
["src/nvim/eval.c", ["        p = pbuf = expand_env_save(*fnamep);", "      else", "        p = pbuf = (char_u *)FullName_save((char *)*fnamep, FALSE);"], "readability/braces"]
["src/nvim/eval.c", ["      else", "        p = pbuf = (char_u *)FullName_save((char *)*fnamep, FALSE);", "    } else"], "whitespace/operators"]
["src/nvim/eval.c", ["      else", "        p = pbuf = (char_u *)FullName_save((char *)*fnamep, FALSE);", "    } else"], "readability/bool"]
["src/nvim/eval.c", ["        p = pbuf = (char_u *)FullName_save((char *)*fnamep, FALSE);", "    } else", "      p = *fnamep;"], "readability/braces"]
["src/nvim/eval.c", ["         && (src[*usedlen + 1] == 'e' || src[*usedlen + 1] == 'r')) {", "    /* find a '.' in the tail:", "     * - for second :e: before the current fname"], "readability/old_style_comment"]
["src/nvim/eval.c", ["    char_u      *flags;", "    int didit = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["      flags = (char_u *)\"g\";", "      ++s;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["          *bufp = s;", "          didit = TRUE;", "          xfree(sub);"], "readability/bool"]
["src/nvim/eval.c", ["      ga_grow(&ga, (int)((end - tail) + sublen -", "                     (regmatch.endp[0] - regmatch.startp[0])));", ""], "whitespace/alignment"]
["src/nvim/eval.c", ["      tail = regmatch.endp[0];", "      if (*tail == NUL)", "        break;"], "readability/braces"]
["src/nvim/eval.c", ["        break;", "      if (!do_all)", "        break;"], "readability/braces"]
["src/nvim/eval.c", ["", "    if (ga.ga_data != NULL)", "      STRCPY((char *)ga.ga_data + ga.ga_len, tail);"], "readability/braces"]
["src/nvim/eval.h", ["#include \"nvim/channel.h\"", "#include \"nvim/eval/funcs.h\" // For FunPtr", "#include \"nvim/event/time.h\"  // For TimeWatcher"], "whitespace/comments"]
["src/nvim/eval.h", ["", "/*", " * Structure returned by get_lval() and used by set_var_lval()."], "readability/old_style_comment"]
["src/nvim/eval.h", ["/// flags for find_name_end()", "#define FNE_INCL_BR     1       /* find_name_end(): include [] in name */", "#define FNE_CHECK_START 2       /* find_name_end(): check name starts with"], "readability/old_style_comment"]
["src/nvim/eval.h", ["#define FNE_INCL_BR     1       /* find_name_end(): include [] in name */", "#define FNE_CHECK_START 2       /* find_name_end(): check name starts with", "                                   valid character */"], "readability/multiline_comment"]
["src/nvim/eval.h", ["#define FNE_INCL_BR     1       /* find_name_end(): include [] in name */", "#define FNE_CHECK_START 2       /* find_name_end(): check name starts with", "                                   valid character */"], "readability/old_style_comment"]
["src/nvim/eval/decode.c", ["      // vval.v_list and vval.v_dict should have the same size and offset", "      && ((void *) obj.val.vval.v_list", "          == (void *) last_container.container.vval.v_list)) {"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["      && ((void *) obj.val.vval.v_list", "          == (void *) last_container.container.vval.v_list)) {", "    (void) kv_pop(*container_stack);"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["          == (void *) last_container.container.vval.v_list)) {", "    (void) kv_pop(*container_stack);", "    val_location = last_container.s;"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["      // Restart", "      (void) kv_pop(*container_stack);", "      ValuesStackItem last_container_val ="], "whitespace/cast"]
["src/nvim/eval/decode.c", ["#define LENP(p, e) \\", "    ((int) ((e) - (p))), (p)", "#define OBJ(obj_tv, is_sp_string, didcomma_, didcolon_) \\"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["        emsgf(_(\"E474: Unfinished escape sequence: %.*s\"),", "              (int) buf_len, buf);", "        goto parse_json_string_fail;"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["            emsgf(_(\"E474: Unfinished unicode escape sequence: %.*s\"),", "                  (int) buf_len, buf);", "            goto parse_json_string_fail;"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["    } else {", "      uint8_t p_byte = (uint8_t) *p;", "      // unescaped = %x20-21 / %x23-5B / %x5D-10FFFF"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["      }", "      const int ch = utf_ptr2char((char_u *) p);", "      // All characters above U+007F are encoded using two or more bytes"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["      if (ch >= 0x80 && p_byte == ch", "          && !(ch == 0xC3 && p + 1 < e && (uint8_t) p[1] == 0x83)) {", "        emsgf(_(\"E474: Only UTF-8 strings allowed: %.*s\"), LENP(p, e));"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["      }", "      const size_t ch_len = (size_t) utf_char2len(ch);", "      assert(ch_len == (size_t) (ch ? utf_ptr2len((char_u *) p) : 1));"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["      const size_t ch_len = (size_t) utf_char2len(ch);", "      assert(ch_len == (size_t) (ch ? utf_ptr2len((char_u *) p) : 1));", "      len += ch_len;"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["  if (p == e || *p != '\"') {", "    emsgf(_(\"E474: Expected string end: %.*s\"), (int) buf_len, buf);", "    goto parse_json_string_fail;"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["    if (fst_in_pair != 0) { \\", "      str_end += utf_char2bytes(fst_in_pair, (char_u *) str_end); \\", "      fst_in_pair = 0; \\"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["            PUT_FST_IN_PAIR(fst_in_pair, str_end);", "            fst_in_pair = (int) ch;", "          } else if (SURROGATE_LO_START <= ch && ch <= SURROGATE_LO_END"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["            const int full_char = (", "                (int) (ch - SURROGATE_LO_START)", "                + ((fst_in_pair - SURROGATE_HI_START) << 10)"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["                + SURROGATE_FIRST_CHAR);", "            str_end += utf_char2bytes(full_char, (char_u *) str_end);", "            fst_in_pair = 0;"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["            PUT_FST_IN_PAIR(fst_in_pair, str_end);", "            str_end += utf_char2bytes((int) ch, (char_u *) str_end);", "          }"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["          };", "          *str_end++ = escapes[(int) *t];", "          break;"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["  };", "  const size_t exp_num_len = (size_t) (p - s);", "  if (fracs || exps) {"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["              \"to float string2float consumed %zu bytes in place of %zu\"),", "            (int) exp_num_len, s, num_len, exp_num_len);", "    }"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["    int num_len;", "    vim_str2nr((char_u *) s, NULL, &num_len, 0, &nr, NULL, (int) (p - s));", "    if ((int) exp_num_len != num_len) {"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["    vim_str2nr((char_u *) s, NULL, &num_len, 0, &nr, NULL, (int) (p - s));", "    if ((int) exp_num_len != num_len) {", "      emsgf(_(\"E685: internal error: while converting number \\\"%.*s\\\" \""], "whitespace/cast"]
["src/nvim/eval/decode.c", ["              \"to integer vim_str2nr consumed %i bytes in place of %zu\"),", "            (int) exp_num_len, s, num_len, exp_num_len);", "    }"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["          p++;", "          (void) kv_pop(container_stack);", "          goto json_decode_string_after_cycle;"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["  }", "  emsgf(_(\"E474: Unexpected end of input: %.*s\"), (int) buf_len, buf);", "json_decode_string_fail:"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["          .v_lock = VAR_UNLOCKED,", "          .vval = { .v_number = (varnumber_T) mobj.via.u64 },", "        };"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["          .v_lock = VAR_UNLOCKED,", "          .vval = { .v_number = (varnumber_T) mobj.via.i64 },", "        };"], "whitespace/cast"]
["src/nvim/eval/decode.c", ["      }));", "      if (encode_list_write((void *) ext_val_list, mobj.via.ext.ptr,", "                            mobj.via.ext.size) == -1) {"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["  }", "  list_T *const list = (list_T *) data;", "  const char *const end = buf + len;"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["    const char *line_start = line_end;", "    line_end = xmemscan(line_start, NL, (size_t) (end - line_start));", "    char *str = NULL;"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["        char *const key = encode_tv2string(&key_tv, NULL);", "        vim_snprintf((char *) IObuff, IOSIZE, key_msg, key);", "        xfree(key);"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["          char *const key = encode_tv2echo(&key_tv, NULL);", "          vim_snprintf((char *) IObuff, IOSIZE, key_pair_msg, key, idx);", "          xfree(key);"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["      if (state->li == NULL) {", "        *read_bytes = (size_t) (p - buf);", "        return OK;"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["    do { \\", "      const char *const buf_ = (const char *) buf; \\", "      if (buf == NULL) { \\"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["        const size_t len_ = (len); \\", "        ga_grow(gap, (int) (2 + len_ + memcnt(buf_, '\\'', len_))); \\", "        ga_append(gap, '\\''); \\"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["      char numbuf[NUMBUFLEN]; \\", "      vim_snprintf(numbuf, ARRAY_SIZE(numbuf), \"%\" PRId64, (int64_t) (num)); \\", "      ga_concat(gap, numbuf); \\"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["          vim_snprintf(numbuf, ARRAY_SIZE(numbuf), \"%g\", flt_); \\", "          ga_concat(gap, (char_u *) numbuf); \\", "        } \\"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["          if (conv_type == kMPConvDict) { \\", "            if ((void *) mpval.data.d.dict == (void *) (val)) { \\", "              break; \\"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["          } else if (conv_type == kMPConvList) { \\", "            if ((void *) mpval.data.l.list == (void *) (val)) { \\", "              break; \\"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["          if (conv_type == kMPConvDict) { \\", "            if ((void *) mpval.data.d.dict == (void *) val) { \\", "              break; \\"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["          } else if (conv_type == kMPConvList) { \\", "            if ((void *) mpval.data.l.list == (void *) val) { \\", "              break; \\"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["          vim_snprintf(numbuf, ARRAY_SIZE(numbuf), \"%g\", flt_); \\", "          ga_concat(gap, (char_u *) numbuf); \\", "          break; \\"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["            str_len += ((sizeof(\"\\\\u1234\") - 1)", "                        * (size_t) (1 + (ch >= SURROGATE_FIRST_CHAR)));", "          }"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["    ga_append(gap, '\"');", "    ga_grow(gap, (int) str_len);", "    for (size_t i = 0; i < utf_len;) {"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["    do { \\", "      if (convert_to_json_string(gap, (const char *) (buf), (len)) != OK) { \\", "        return FAIL; \\"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["  if (len != NULL) {", "    *len = (size_t) ga.ga_len;", "  }"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["  ga_append(&ga, '\\0');", "  return (char *) ga.ga_data;", "}"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["  if (len != NULL) {", "    *len = (size_t) ga.ga_len;", "  }"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["  ga_append(&ga, '\\0');", "  return (char *) ga.ga_data;", "}"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["      if (buf == NULL) { \\", "        msgpack_pack_ext(packer, 0, (int8_t) type); \\", "      } else { \\"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["        const size_t len_ = (len); \\", "        msgpack_pack_ext(packer, len_, (int8_t) type); \\", "        msgpack_pack_ext_body(packer, buf, len_); \\"], "whitespace/cast"]
["src/nvim/eval/funcs.c", ["", "  if (idx == 0)", "    intidx = -1;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "  if (idx == 0)", "    intidx = -1;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["    name = get_function_name(xp, idx);", "    if (name != NULL)", "      return name;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * Return TRUE for a non-zero Number and a non-empty String."], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"abs(expr)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"add(list, item)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"and(expr, expr)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"argidx()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"argv(nr)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"atan2()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"browse(save, title, initdir, default)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"browsedir(title, initdir)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * Find a buffer by number or exact name."], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "  if (avar->v_type == VAR_NUMBER)", "    buf = buflist_findnr((int)avar->vval.v_number);"], "readability/braces"]
["src/nvim/eval/funcs.c", ["    buf = buflist_findnr((int)avar->vval.v_number);", "  else if (avar->v_type == VAR_STRING && avar->vval.v_string != NULL) {", "    buf = buflist_findname_exp(avar->vval.v_string);"], "readability/braces"]
["src/nvim/eval/funcs.c", ["    if (buf == NULL) {", "      /* No full path name match, try a match with a URL or a \"nofile\"", "       * buffer, these don't use the full path. */"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"bufexists(expr)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"buflisted(expr)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"bufloaded(expr)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"bufname(expr)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"bufnr(expr)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["/// \"bufwinid(nr)\" function", "static void f_bufwinid(typval_T *argvars, typval_T *rettv, FunPtr fptr) {", "  buf_win_common(argvars, rettv, false);"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * Get buffer by number or pattern."], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "  if (tv->v_type == VAR_NUMBER)", "    return buflist_findnr((int)tv->vval.v_number);"], "readability/braces"]
["src/nvim/eval/funcs.c", ["    return buflist_findnr((int)tv->vval.v_number);", "  if (tv->v_type != VAR_STRING)", "    return NULL;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["    return NULL;", "  if (name == NULL || *name == NUL)", "    return curbuf;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["    return curbuf;", "  if (name[0] == '$' && name[1] == NUL)", "    return lastbuf;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["  save_magic = p_magic;", "  p_magic = TRUE;", "  save_cpo = p_cpo;"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"byte2line(byte)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"byteidx()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  byteidx(argvars, rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"byteidxcomp()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  byteidx(argvars, rettv, TRUE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"changenr()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["  if (argvars[0].v_type != VAR_NUMBER || (argvars[1].v_type != VAR_STRING", "        && argvars[1].v_type != VAR_UNKNOWN)) {", "    EMSG(_(e_invarg));"], "whitespace/alignment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"char2nr(string)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"cindent(lnum)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["    curwin->w_cursor = pos;", "  } else", "    rettv->vval.v_number = -1;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"clearmatches()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"col(string)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "  fp = var2fpos(&argvars[0], FALSE, &fnum);", "  if (fp != NULL && fnum == curbuf->b_fnum) {"], "readability/bool"]
["src/nvim/eval/funcs.c", ["        if (curwin->w_cursor.coladd >= (colnr_T)chartabsize(p,", "                curwin->w_virtcol - curwin->w_cursor.coladd)) {", "          int l;"], "whitespace/alignment"]
["src/nvim/eval/funcs.c", ["", "          if (*p != NUL && p[(l = (*mb_ptr2len)(p))] == NUL)", "            col += l;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"complete()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "  /* Check for undo allowed here, because if something was already inserted", "   * the line was already saved for undo and this check isn't done. */"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["   * the line was already saved for undo and this check isn't done. */", "  if (!undo_allowed())", "    return;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"complete_add()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"complete_check()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"confirm(message, buttons[, default [, type]])\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"copy()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"count()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["        }", "        if (error)", "          li = NULL;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["      todo = error ? 0 : (int)d->dv_hashtab.ht_used;", "      for (hi = d->dv_hashtab.ht_array; todo > 0; ++hi) {", "        if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"cscope_connection([{num} , {dbpath} [, {prepend}]])\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"did_filetype()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"diff_filler()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"diff_hlID()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"empty({expr})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"escape({string}, {chars})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"eval()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["    }", "    need_clr_eos = FALSE;", "    rettv->v_type = VAR_NUMBER;"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"eventhandler()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"executable()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"exists()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"expand()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"extend(list, list [, idx])\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"feedkeys()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * Return 0 for not writable, 1 for writable file, 2 for a dir which we have"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["    do {", "      if (rettv->v_type == VAR_STRING || rettv->v_type == VAR_LIST)", "        xfree(fresult);"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "  if (rettv->v_type == VAR_STRING)", "    rettv->vval.v_string = fresult;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"filter()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  filter_map(argvars, rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"finddir({fname}[, {path}[, {count}]])\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"findfile({fname}[, {path}[, {count}]])\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"float2nr({float})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"fmod()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"fnameescape({string})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"fnamemodify({fname}, {mods})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"foldclosed()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"foldclosed()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  foldclosed_both(argvars, rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"foldclosedend()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  foldclosed_both(argvars, rettv, TRUE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"foldlevel()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"foldtext()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["        s = skipwhite(ml_get(lnum + 1));", "        if (*s == '*')", "          s = skipwhite(s + 1);"], "readability/braces"]
["src/nvim/eval/funcs.c", ["                + STRLEN(s));     // concatenated", "    sprintf((char *)r, txt, dashes, count);", "    len = (int)STRLEN(r);"], "runtime/printf"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"foldtextresult(lnum)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"foreground()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"get()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * Get line or list of lines from buffer \"buf\" into \"rettv\"."], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getbufline()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getbufvar()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getchar()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["      if (row >= 0 && col >= 0) {", "        /* Find the window at the mouse coordinates and compute the", "         * text position. */"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["        (void)mouse_comp_pos(win, &row, &col, &lnum);", "        for (wp = firstwin; wp != win; wp = wp->w_next)", "          ++winnr;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["        for (wp = firstwin; wp != win; wp = wp->w_next)", "          ++winnr;", "        set_vim_var_nr(VV_MOUSE_WIN, winnr);"], "readability/increment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getcharmod()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getcharsearch()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getcmdline()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getcmdpos()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getcmdtype()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getcmdwintype()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getfontname()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getfperm({fname})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getfsize({fname})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getftime({fname})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getftype({fname})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getline(lnum, [end])\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getmatches()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getpid()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getcurpos(string)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getpos(string)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getregtype()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"gettabvar()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"gettabwinvar()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getwinposx()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"getwinposy()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"glob()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "  /* When the optional second argument is non-zero, don't remove matches", "  * for 'wildignore' and don't put matches for 'suffixes' at the end. */"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["    xpc.xp_context = EXPAND_FILES;", "    if (p_wic)", "      options += WILD_ICASE;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["    }", "  } else", "    rettv->vval.v_string = NULL;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"has_key()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["  }", "  if (argvars[0].vval.v_dict == NULL)", "    return;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"hasmapto()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"histadd()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"histdel()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"histget()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"histnr()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"highlightID(name)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"highlight_exists()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"hostname()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * iconv() function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"indent()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"index()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"input()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  get_user_input(argvars, rettv, FALSE, inputsecret_flag);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"inputdialog()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  get_user_input(argvars, rettv, TRUE, inputsecret_flag);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"inputlist()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"insert()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"invert(expr)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"isdirectory()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"islocked()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"items(dict)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["  if (argvars[0].v_type != VAR_LIST || (argvars[1].v_type != VAR_NUMBER", "        && argvars[1].v_type != VAR_UNKNOWN)) {", "    EMSG(_(e_invarg));"], "whitespace/alignment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"join()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"keys()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"last_buffer_nr()\" function."], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"len()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"libcall()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"libcallnr()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"line(string)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "  fp = var2fpos(&argvars[0], TRUE, &fnum);", "  if (fp != NULL)"], "readability/bool"]
["src/nvim/eval/funcs.c", ["  fp = var2fpos(&argvars[0], TRUE, &fnum);", "  if (fp != NULL)", "    lnum = fp->lnum;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"line2byte(lnum)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"lispindent(lnum)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"localtime()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["  int mode;", "  int abbr = FALSE;", "  int get_dict = FALSE;"], "readability/bool"]
["src/nvim/eval/funcs.c", ["  int abbr = FALSE;", "  int get_dict = FALSE;", "  mapblock_T  *mp;"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"map()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  filter_map(argvars, rettv, TRUE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"maparg()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  get_maparg(argvars, rettv, TRUE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"mapcheck()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  get_maparg(argvars, rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["    } else {", "      if (start < 0)", "        start = 0;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["        start = 0;", "      if (start > len)", "        goto theend;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "      if (match && --nth <= 0)", "        break;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["        break;", "      if (l == NULL && !match)", "        break;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"match()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"matchadd()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"matcharg()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"matchdelete()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"matchend()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"matchlist()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"matchstr()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"max()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  max_min(argvars, rettv, TRUE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"min()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  max_min(argvars, rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"mkdir()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"nextnonblank()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"nr2char()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"or(expr, expr)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"pathshorten()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"pow()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"prevnonblank()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"printf()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"pumvisible()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  if (pum_visible())", "    rettv->vval.v_number = 1;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"pyeval()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"py3eval()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"range()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"readfile()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["        } else {", "          /* Change \"prev\" buffer to be the right size.  This way", "           * the bytes are only copied once, and very long lines are"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["            }", "            if (readlen > p - buf + 1)", "              memmove(dest, p + 1, readlen - (p - buf) - 1);"], "readability/braces"]
["src/nvim/eval/funcs.c", ["      if (p - start + prevlen >= prevsize) {", "        /* A common use case is ordinary text files and \"prev\" gets a", "         * fragment of a line, so the first allocation is made"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["         * 'reallocing' small. */", "        if (prevsize == 0)", "          prevsize = (long)(p - start);"], "readability/braces"]
["src/nvim/eval/funcs.c", ["          prevsize = (long)(p - start);", "        else {", "          long grow50pc = (prevsize * 3) / 2;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["          prevsize = (long)(p - start);", "        else {", "          long grow50pc = (prevsize * 3) / 2;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["  union {", "    struct { int32_t low, high; } split;", "    proftime_T prof;"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["  union {", "    struct { int32_t low, high; } split;", "    proftime_T prof;"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["  STATIC_ASSERT(sizeof(u.prof) == sizeof(u) && sizeof(u.split) == sizeof(u),", "      \"type punning will produce incorrect results on this platform\");", ""], "whitespace/alignment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"remove()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"rename({from}, {to})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"repeat()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"resolve()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"reverse({list})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * Get flags for a search function."], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "  /*", "   * This function does not accept SP_REPEAT and SP_RETCOUNT flags."], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["  if (subpatnum != FAIL) {", "    if (flags & SP_SUBPAT)", "      retval = subpatnum;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["      retval = subpatnum;", "    else", "      retval = pos.lnum;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["      retval = pos.lnum;", "    if (flags & SP_SETPCMARK)", "      setpcmark();"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"screenattr()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"screenchar()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"screencol()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"screenrow()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"search()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"searchdecl()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * Used by searchpair() and searchpairpos()"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"searchpair()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"searchpairpos()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * Search for a start/middle/end thing."], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "    if (firstpos.lnum == 0)", "      firstpos = pos;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["      }", "      if (r)", "        continue;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["      curwin->w_cursor = pos;", "      if (!(flags & SP_REPEAT))", "        break;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"searchpos()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"setbufvar()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"setcmdpos()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"setline()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"setloclist()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"setmatches()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"setpos()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"setqflist()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"setreg()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"settabvar()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"settabwinvar()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"setwinvar()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"shellescape({string})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * shiftwidth() function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"simplify()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * Compare functions for f_sort() and f_uniq() below."], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"sort({list})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"soundfold({word})\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"spellbadword()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"spellsuggest()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"str2float()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"strftime({format}[, {time}])\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"stridx()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"string()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"strlen()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"strchars()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"strdisplaywidth()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"strwidth()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"strpart()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"strridx()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"strtrans()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"submatch()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"substitute()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"synIDattr(id, what [, mode])\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"synIDtrans(id)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"synconcealed(lnum, col)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"synstack(lnum, col)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"tabpagebuflist()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"tabpagenr()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * Common code for tabpagewinnr() and winnr()."], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "  if (nr > 0)", "    for (wp = (tp == curtab) ? firstwin : tp->tp_firstwin;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["      }", "      ++nr;", "    }"], "readability/increment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"tabpagewinnr()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"tagfiles()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"taglist()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"tempname()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"tolower(string)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"toupper(string)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"tr(string, fromstr, tostr)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"type(expr)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"undofile(name)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"undotree()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"values(dict)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"virtcol(string)\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "  fp = var2fpos(&argvars[0], FALSE, &fnum);", "  if (fp != NULL && fp->lnum <= curbuf->b_ml.ml_line_count"], "readability/bool"]
["src/nvim/eval/funcs.c", ["    getvvcol(curwin, fp, NULL, NULL, &vcol);", "    ++vcol;", "  }"], "readability/increment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"visualmode()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"wildmenumode()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"wincol()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"winline()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"winnr()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"winrestcmd()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"winrestview()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["", "    if (curwin->w_topline <= 0)", "      curwin->w_topline = 1;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["      curwin->w_topline = 1;", "    if (curwin->w_topline > curbuf->b_ml.ml_line_count)", "      curwin->w_topline = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/eval/funcs.c", ["", "/*", " * \"winsaveview()\" function"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["}", "/*", " * \"xor(expr, expr)\" function"], "readability/old_style_comment"]
["src/nvim/eval/typval.h", ["      uint8_t di_flags;  /* Flags. */ \\", "      char_u di_key[__VA_ARGS__];  /* Key value. */ \\", "    }"], "runtime/arrays"]
["src/nvim/eval/typval_encode.h", ["          ? 0", "          : strlen((char *) tv->vval.v_string));", "}"], "whitespace/cast"]
["src/nvim/eval/userfunc.c", ["#include \"nvim/ex_getln.h\"", "#include \"nvim/ex_getln.h\"", "#include \"nvim/fileio.h\""], "build/include"]
["src/nvim/eval/userfunc.c", ["char_u *deref_func_name(const char *name, int *lenp,", "                               partial_T **const partialp, bool no_autoload)", "  FUNC_ATTR_NONNULL_ARG(1, 2)"], "whitespace/alignment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Allocate a variable for the result of a function."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  int ret = OK;", "  typval_T argvars[MAX_FUNC_ARGS + 1];          /* vars for arguments */", "  int argcount = 0;                     /* number of arguments found */"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  typval_T argvars[MAX_FUNC_ARGS + 1];          /* vars for arguments */", "  int argcount = 0;                     /* number of arguments found */", ""], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "  /*", "   * Get the arguments."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["    }", "    ++argcount;", "    if (*argp != ',')"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["    ++argcount;", "    if (*argp != ',')", "      break;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["  }", "  if (*argp == ')')", "    ++argp;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["  if (*argp == ')')", "    ++argp;", "  else"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["    ++argp;", "  else", "    ret = FAIL;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["  hi = hash_find(&func_hashtab, name);", "  if (!HASHITEM_EMPTY(hi))", "    return HI2UF(hi);"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Copy the function name of \"fp\" to buffer \"buf\"."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["    STRCAT(buf, fp->uf_name + 3);", "  } else", "    STRCPY(buf, fp->uf_name);"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Add a number variable \"name\" to dict \"dp\" with value \"nr\"."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  }", "  ++depth;", "  // Save search patterns and redo buffer."], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  }", "  ++fp->uf_calls;", "  // check for CTRL-C hit"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["    v->di_tv.vval.v_dict = selfdict;", "    ++selfdict->dv_refcount;", "  }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["    if (p_verbose >= 12) {", "      ++no_wait_return;", "      verbose_enter_scroll();"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["      verbose_leave_scroll();", "      --no_wait_return;", "    }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  if (func_or_func_caller_profiling) {", "    ++fp->uf_tm_count;", "    call_start = profile_start();"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  save_did_emsg = did_emsg;", "  did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/eval/userfunc.c", ["", "  --RedrawingDisabled;", ""], "readability/increment"]
["src/nvim/eval/userfunc.c", ["    fp->uf_tm_self = profile_self(fp->uf_tm_self, call_start,", "        fp->uf_tm_children);", "    if (fc->caller != NULL && fc->caller->func->uf_profiling) {"], "whitespace/alignment"]
["src/nvim/eval/userfunc.c", ["  if (p_verbose >= 12) {", "    ++no_wait_return;", "    verbose_enter_scroll();"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["", "    if (aborting())", "      smsg(_(\"%s aborted\"), sourcing_name);"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["      smsg(_(\"%s aborted\"), sourcing_name);", "    else if (fc->rettv->v_type == VAR_NUMBER)", "      smsg(_(\"%s returning #%\" PRId64 \"\"),"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["           sourcing_name, (int64_t)fc->rettv->vval.v_number);", "    else {", "      char_u buf[MSG_BUF_LEN];"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["           sourcing_name, (int64_t)fc->rettv->vval.v_number);", "    else {", "      char_u buf[MSG_BUF_LEN];"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["      emsg_off++;", "      char_u *s = (char_u *) encode_tv2string(fc->rettv, NULL);", "      char_u *tofree = s;"], "whitespace/cast"]
["src/nvim/eval/userfunc.c", ["    verbose_leave_scroll();", "    --no_wait_return;", "  }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  if (p_verbose >= 12 && sourcing_name != NULL) {", "    ++no_wait_return;", "    verbose_enter_scroll();"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["    verbose_leave_scroll();", "    --no_wait_return;", "  }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["      emsg_funcname(N_(\"E119: Not enough arguments for function: %s\"),", "          name);", "      break;"], "whitespace/alignment"]
["src/nvim/eval/userfunc.c", ["      emsg_funcname(N_(\"E120: Using <SID> not in a script context: %s\"),", "          name);", "      break;"], "whitespace/alignment"]
["src/nvim/eval/userfunc.c", ["      emsg_funcname(N_(\"E725: Calling dict function without Dictionary: %s\"),", "          name);", "      break;"], "whitespace/alignment"]
["src/nvim/eval/userfunc.c", ["      if (fp == NULL", "          && apply_autocmds(EVENT_FUNCUNDEFINED, rfname, rfname, TRUE, NULL)", "          && !aborting()) {"], "readability/bool"]
["src/nvim/eval/userfunc.c", ["    }", "    /*", "     * The function call (or \"FuncUndefined\" autocommand sequence) might"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  }", "  if (error == ERROR_NONE)", "    ret = OK;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["  msg_start();", "  if (indent)", "    MSG_PUTS(\"   \");"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "  if (fdp != NULL)", "    memset(fdp, 0, sizeof(funcdict_T));"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "  /* Check for hard coded <SNR>: already translated function ID (from a user", "   * command). */"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "  /* A name starting with \"<SID>\" or \"<SNR>\" is local to a script.  But", "   * don't skip over \"s:\", get_lval() needs it for \"s:dict.func\". */"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  if (end == start) {", "    if (!skip)", "      EMSG(_(\"E129: Function name required\"));"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["  if (end == NULL || (lv.ll_tv != NULL && (lead > 2 || lv.ll_range))) {", "    /*", "     * Report an invalid expression in braces, unless the expression"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "  /* Check if the name is a Funcref.  If so, use the value. */", "  if (lv.ll_exp_name != NULL) {"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * \":function\""], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "  /*", "   * \":function\" without argument: list functions."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["      todo = (int)func_hashtab.ht_used;", "      for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi) {", "        if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["        if (!HASHITEM_EMPTY(hi)) {", "          --todo;", "          fp = HI2UF(hi);"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["", "  /*", "   * \":function /pat\": list functions matching pattern."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  if (*eap->arg == '/') {", "    p = skip_regexp(eap->arg + 1, '/', TRUE, NULL);", "    if (!eap->skip) {"], "readability/bool"]
["src/nvim/eval/userfunc.c", ["        todo = (int)func_hashtab.ht_used;", "        for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi) {", "          if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["          if (!HASHITEM_EMPTY(hi)) {", "            --todo;", "            fp = HI2UF(hi);"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["            fp = HI2UF(hi);", "            if (!isdigit(*fp->uf_name)", "                && vim_regexec(&regmatch, fp->uf_name, 0))"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["    }", "    if (*p == '/')", "      ++p;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["    if (*p == '/')", "      ++p;", "    eap->nextcmd = check_nextcmd(p);"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  if (name == NULL && (fudi.fd_dict == NULL || !paren) && !eap->skip) {", "    /*", "     * Return on an invalid expression in braces, unless the expression"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["      return;", "    } else", "      eap->skip = TRUE;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["    } else", "      eap->skip = TRUE;", "  }"], "readability/bool"]
["src/nvim/eval/userfunc.c", ["", "  /* An error in a function call during evaluation of an expression in magic", "   * braces should not cause the function not to be defined. */"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  saved_did_emsg = did_emsg;", "  did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/eval/userfunc.c", ["    eap->nextcmd = check_nextcmd(p);", "    if (eap->nextcmd != NULL)", "      *p = NUL;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["        }", "      } else", "        emsg_funcname(N_(\"E123: Undefined function: %s\"), name);"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "  /*", "   * \":function name(arg1, arg2)\" Define function."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  if (!eap->skip) {", "    /* Check the name of the function.  Unless it's a dictionary function", "     * (that we are overwriting). */"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["     * (that we are overwriting). */", "    if (name != NULL)", "      arg = name;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["      arg = name;", "    else", "      arg = fudi.fd_newkey;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["      int j = (*arg == K_SPECIAL) ? 3 : 0;", "      while (arg[j] != NUL && (j == 0 ? eval_isnamec1(arg[j])", "                               : eval_isnamec(arg[j])))"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["                               : eval_isnamec(arg[j])))", "        ++j;", "      if (arg[j] != NUL)"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["        ++j;", "      if (arg[j] != NUL)", "        emsg_funcname((char *)e_invarg2, arg);"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "  /* When there is a line break use what follows for the function body.", "   * Makes 'exe \"func Test()\\n...\\nendfunc\"' work. */"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "  /*", "   * Read the body of the function, until \":endfunction\" is found."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  if (KeyTyped) {", "    /* Check if the function already exists, don't let the user type the", "     * whole function before telling him it doesn't work!  For a script we"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["    if (!eap->skip && !eap->forceit) {", "      if (fudi.fd_dict != NULL && fudi.fd_newkey == NULL)", "        EMSG(_(e_funcdict));"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["        EMSG(_(e_funcdict));", "      else if (name != NULL && find_func(name) != NULL)", "        emsg_funcname(e_funcexts, name);"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "    if (!eap->skip && did_emsg)", "      goto erret;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["      p = vim_strchr(theline, '\\n');", "      if (p == NULL)", "        line_arg += STRLEN(line_arg);"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["        line_arg += STRLEN(line_arg);", "      else {", "        *p = NUL;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["        line_arg += STRLEN(line_arg);", "      else {", "        *p = NUL;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "      /* Increase indent inside \"if\", \"while\", \"for\" and \"try\", decrease", "       * at \"end\". */"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["       * at \"end\". */", "      if (indent > 2 && STRNCMP(p, \"end\", 3) == 0)", "        indent -= 2;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["        indent -= 2;", "      else if (STRNCMP(p, \"if\", 2) == 0", "               || STRNCMP(p, \"wh\", 2) == 0"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["        p = skipwhite(arg + 2);", "        if (*p == NUL)", "          skip_until = vim_strsave((char_u *)\".\");"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["          skip_until = vim_strsave((char_u *)\".\");", "        else", "          skip_until = vim_strsave(p);"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "    /* Copy the line to newly allocated memory.  get_one_sourceline()", "     * allocates 250 bytes per line, this saves 80% on average.  The cost"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "    /* Add NULL lines for continuation lines, so that the line count is", "     * equal to the index in the growarray.   */"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["     * equal to the index in the growarray.   */", "    while (sourcing_lnum_off-- > 0)", "      ((char_u **)(newlines.ga_data))[newlines.ga_len++] = NULL;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "  /* Don't define the function when skipping commands or when an error was", "   * detected. */"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["   * detected. */", "  if (eap->skip || did_emsg)", "    goto erret;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "  /*", "   * If there are no errors, add the function"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["      emsg_funcname(N_(\"E707: Function name conflicts with variable: %s\"),", "          name);", "      goto erret;"], "whitespace/alignment"]
["src/nvim/eval/userfunc.c", ["        emsg_funcname(N_(\"E127: Cannot redefine function %s: It is in use\"),", "            name);", "        goto erret;"], "whitespace/alignment"]
["src/nvim/eval/userfunc.c", ["", "    /* Give the function a sequential number.  Can only be used with a", "     * Funcref! */"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["    xfree(name);", "    sprintf(numbuf, \"%d\", ++func_nr);", "    name = vim_strsave((char_u *)numbuf);"], "runtime/printf"]
["src/nvim/eval/userfunc.c", ["        slen = (int)STRLEN(sourcing_name);", "        if (slen > plen && fnamecmp(p,", "                sourcing_name + slen - plen) == 0)"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["        if (slen > plen && fnamecmp(p,", "                sourcing_name + slen - plen) == 0)", "          j = OK;"], "whitespace/alignment"]
["src/nvim/eval/userfunc.c", ["        EMSG2(_(", "                \"E746: Function name does not match script file name: %s\"),", "            name);"], "whitespace/indent"]
["src/nvim/eval/userfunc.c", ["                \"E746: Function name does not match script file name: %s\"),", "            name);", "        goto erret;"], "whitespace/alignment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Return 5 if \"p\" starts with \"<SID>\" or \"<SNR>\" (ignoring case)."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "  /* Only accept \"funcname\", \"funcname \", \"funcname (...\" and", "   * \"funcname(...\", not \"funcname!...\". */"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the list of user defined"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  if (done < func_hashtab.ht_used) {", "    if (done++ > 0)", "      ++hi;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["    if (done++ > 0)", "      ++hi;", "    while (HASHITEM_EMPTY(hi))"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["      ++hi;", "    while (HASHITEM_EMPTY(hi))", "      ++hi;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["    while (HASHITEM_EMPTY(hi))", "      ++hi;", "    fp = HI2UF(hi);"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["      STRCAT(IObuff, \"(\");", "      if (!fp->uf_varargs && GA_EMPTY(&fp->uf_args))", "        STRCAT(IObuff, \")\");"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["  if (name == NULL) {", "    if (fudi.fd_dict != NULL && !eap->skip)", "      EMSG(_(e_funcref));"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["  eap->nextcmd = check_nextcmd(p);", "  if (eap->nextcmd != NULL)", "    *p = NUL;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "  if (!eap->skip)", "    fp = find_func(name);"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["      EMSG2(_(\"Cannot delete function %s: It is being used internally\"),", "          eap->arg);", "      return;"], "whitespace/alignment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Unreference a Function: decrement the reference count and free it when it"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * \":return [expr]\""], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  typval_T rettv;", "  int returning = FALSE;", ""], "readability/bool"]
["src/nvim/eval/userfunc.c", ["", "  if (eap->skip)", "    ++emsg_skip;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["  if (eap->skip)", "    ++emsg_skip;", ""], "readability/increment"]
["src/nvim/eval/userfunc.c", ["", "  /* When skipping or the return gets pending, advance to the next command", "   * in this line (!returning).  Otherwise, ignore the rest of the line."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "  if (eap->skip)", "    --emsg_skip;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["  if (eap->skip)", "    --emsg_skip;", "}"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * \":1,25call func(arg1, arg2)\"\tfunction call."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Return from a function.  Possibly makes the return pending.  Also called"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "  /*", "   * Cleanup (and inactivate) conditionals, but stop when a try conditional"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["   */", "  idx = cleanup_conditionals(eap->cstack, 0, TRUE);", "  if (idx >= 0) {"], "readability/bool"]
["src/nvim/eval/userfunc.c", ["", "    if (!is_cmd && !reanimate)", "      /* A pending return again gets pending.  \"rettv\" points to an"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["    if (!is_cmd && !reanimate)", "      /* A pending return again gets pending.  \"rettv\" points to an", "       * allocated variable with the rettv of the original \":return\"'s"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["      cstack->cs_rettv[idx] = rettv;", "    else {", "      /* When undoing a return in order to make it pending, get the stored"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["      cstack->cs_rettv[idx] = rettv;", "    else {", "      /* When undoing a return in order to make it pending, get the stored"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["    else {", "      /* When undoing a return in order to make it pending, get the stored", "       * return rettv. */"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["        *(typval_T *)cstack->cs_rettv[idx] = *(typval_T *)rettv;", "      } else", "        cstack->cs_rettv[idx] = NULL;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["      if (reanimate) {", "        /* The pending return value could be overwritten by a \":return\"", "         * without argument in a finally clause; reset the default"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  } else {", "    current_funccal->returned = TRUE;", ""], "readability/bool"]
["src/nvim/eval/userfunc.c", ["", "    /* If the return is carried out now, store the return value.  For", "     * a return immediately after reanimation, the value is already"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["      *current_funccal->rettv = *(typval_T *)rettv;", "      if (!is_cmd)", "        xfree(rettv);"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Generate a return command for producing the value of \"rettv\".  The result"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  if (rettv != NULL) {", "    tofree = s = (char_u *) encode_tv2echo((typval_T *) rettv, NULL);", "  }"], "whitespace/cast"]
["src/nvim/eval/userfunc.c", ["  STRLCPY(IObuff + 8, s, IOSIZE - 8);", "  if (STRLEN(s) + 8 >= IOSIZE)", "    STRCPY(IObuff + IOSIZE - 4, \"...\");"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Get next function line."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["    fcp->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name,", "        sourcing_lnum);", "    fcp->dbg_tick = debug_tick;"], "whitespace/alignment"]
["src/nvim/eval/userfunc.c", ["  if (fcp->dbg_tick != debug_tick) {", "    fcp->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name,", "        sourcing_lnum);"], "readability/bool"]
["src/nvim/eval/userfunc.c", ["  }", "  if (do_profiling == PROF_YES)", "    func_line_end(cookie);"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["      sourcing_lnum = fcp->linenr;", "      if (do_profiling == PROF_YES)", "        func_line_start(cookie);"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Return TRUE if the currently active function should be ended, because a"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "  /* Ignore the \"abort\" flag if the abortion behavior has been changed due to", "   * an error inside a try conditional. */"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * return TRUE if cookie indicates a function which \"abort\"s on errors."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Return the name of the executed function."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Return the address holding the next breakpoint line for a funccall cookie."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Return the address holding the debug tick for a funccall cookie."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Return the nesting level for a funccall cookie."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Return TRUE when a function was ended by a \":return\" command."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * List function variables, if there is a function."], "readability/old_style_comment"]
["src/nvim/event/loop.h", ["        uint64_t now = os_hrtime(); \\", "        remaining -= (int) ((now - before) / 1000000); \\", "        before = now; \\"], "whitespace/cast"]
["src/nvim/event/multiqueue.c", ["", "static Event NILEVENT = { .handler = NULL, .argv = {NULL} };", ""], "whitespace/braces"]
["src/nvim/event/multiqueue.c", ["", "static Event NILEVENT = { .handler = NULL, .argv = {NULL} };", ""], "whitespace/braces"]
["src/nvim/event/process.c", ["      LOOP_PROCESS_EVENTS_UNTIL(proc->loop, events, -1,", "          proc->refcount == 1);", "    } else {"], "whitespace/alignment"]
["src/nvim/event/rstream.c", ["      1,", "      (int64_t) stream->fpos,", "      NULL);"], "whitespace/cast"]
["src/nvim/event/rstream.c", ["  // no errors (req.result (ssize_t) is positive), it's safe to cast.", "  size_t nread = (size_t) req.result;", "  rbuffer_produced(stream->buffer, nread);"], "whitespace/cast"]
["src/nvim/event/socket.c", ["  CREATE_EVENT(watcher->events, connection_event, 2, watcher,", "      (void *)(uintptr_t)status);", "}"], "whitespace/alignment"]
["src/nvim/event/stream.h", ["typedef void (*stream_read_cb)(Stream *stream, RBuffer *buf, size_t count,", "    void *data, bool eof);", ""], "whitespace/alignment"]
["src/nvim/event/time.c", ["void time_watcher_start(TimeWatcher *watcher, time_cb cb, uint64_t timeout,", "    uint64_t repeat)", "  FUNC_ATTR_NONNULL_ALL"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["", "/*", " * ex_cmds.c: some functions for command line commands"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":left\", \":center\" and \":right\": align text."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (curwin->w_p_rl) {", "    /* switch left and right aligning */", "    if (eap->cmdidx == CMD_right)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    /* switch left and right aligning */", "    if (eap->cmdidx == CMD_right)", "      eap->cmdidx = CMD_left;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      eap->cmdidx = CMD_left;", "    else if (eap->cmdidx == CMD_left)", "      eap->cmdidx = CMD_right;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  save_curpos = curwin->w_cursor;", "  if (eap->cmdidx == CMD_left) {    /* width is used for new indent */", "    if (width >= 0)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (eap->cmdidx == CMD_left) {    /* width is used for new indent */", "    if (width >= 0)", "      indent = width;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  } else {", "    /*", "     * if 'textwidth' set, use it"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["     */", "    if (width <= 0)", "      width = curbuf->b_p_tw;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  if (u_save((linenr_T)(eap->line1 - 1), (linenr_T)(eap->line2 + 1)) == FAIL)", "    return;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  for (curwin->w_cursor.lnum = eap->line1;", "       curwin->w_cursor.lnum <= eap->line2; ++curwin->w_cursor.lnum) {", "    if (eap->cmdidx == CMD_left)                /* left align */"], "readability/increment"]
["src/nvim/ex_cmds.c", ["       curwin->w_cursor.lnum <= eap->line2; ++curwin->w_cursor.lnum) {", "    if (eap->cmdidx == CMD_left)                /* left align */", "      new_indent = indent;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["       curwin->w_cursor.lnum <= eap->line2; ++curwin->w_cursor.lnum) {", "    if (eap->cmdidx == CMD_left)                /* left align */", "      new_indent = indent;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      new_indent = indent;", "    else {", "      has_tab = FALSE;          /* avoid uninit warnings */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      new_indent = indent;", "    else {", "      has_tab = FALSE;          /* avoid uninit warnings */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    else {", "      has_tab = FALSE;          /* avoid uninit warnings */", "      len = linelen(eap->cmdidx == CMD_right ? &has_tab"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    else {", "      has_tab = FALSE;          /* avoid uninit warnings */", "      len = linelen(eap->cmdidx == CMD_right ? &has_tab"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      len = linelen(eap->cmdidx == CMD_right ? &has_tab", "          : NULL) - get_indent();", ""], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["", "      if (len <= 0)                             /* skip blank lines */", "        continue;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "      if (len <= 0)                             /* skip blank lines */", "        continue;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "      if (eap->cmdidx == CMD_center)", "        new_indent = (width - len) / 2;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["        new_indent = (width - len) / 2;", "      else {", "        new_indent = width - len;               /* right align */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["        new_indent = (width - len) / 2;", "      else {", "        new_indent = width - len;               /* right align */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      else {", "        new_indent = width - len;               /* right align */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "        /*", "         * Make sure that embedded TABs don't make the text go too far"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["         */", "        if (has_tab)", "          while (new_indent > 0) {"], "readability/braces"]
["src/nvim/ex_cmds.c", ["            if (linelen(NULL) <= width) {", "              /*", "               * Now try to move the line as much as possible to"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["                (void)set_indent(++new_indent, 0);", "              while (linelen(NULL) <= width);", "              --new_indent;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["                (void)set_indent(++new_indent, 0);", "              while (linelen(NULL) <= width);", "              --new_indent;"], "whitespace/empty_loop_body"]
["src/nvim/ex_cmds.c", ["              while (linelen(NULL) <= width);", "              --new_indent;", "              break;"], "readability/increment"]
["src/nvim/ex_cmds.c", ["            }", "            --new_indent;", "          }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    }", "    if (new_indent < 0)", "      new_indent = 0;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      new_indent = 0;", "    (void)set_indent(new_indent, 0);                    /* set indent */", "  }"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * Get the length of the current line, excluding trailing white space."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/* Buffer for two lines used during sorting.  They are allocated to", " * contain the longest line being sorted. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /* If the user interrupts, there's no way to stop qsort() immediately, but", "   * if we return 0 every time, qsort will assume it's done sorting and"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["   * exit. */", "  if (sort_abort)", "    return 0;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  fast_breakcheck();", "  if (got_int)", "    sort_abort = TRUE;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (got_int)", "    sort_abort = TRUE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /* If two lines have the same value, preserve the original line order. */", "  if (result == 0)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  /* If two lines have the same value, preserve the original line order. */", "  if (result == 0)", "    return (int)(l1.lnum - l2.lnum);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  for (p = eap->arg; *p != NUL; ++p) {", "    if (ascii_iswhite(*p)) {"], "readability/increment"]
["src/nvim/ex_cmds.c", ["  // Also get the longest line length for allocating \"sortbuf\".", "  for (lnum = eap->line1; lnum <= eap->line2; ++lnum) {", "    s = ml_get(lnum);"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "    if (regmatch.regprog != NULL)", "      fast_breakcheck();"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      fast_breakcheck();", "    if (got_int)", "      goto sortend;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  if (sort_abort)", "    goto sortend;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    fast_breakcheck();", "    if (got_int)", "      goto sortend;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (i == count) {", "    for (i = 0; i < count; ++i) {", "      ml_delete(eap->line1, false);"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":retab\"."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  linenr_T lnum;", "  int got_tab = FALSE;", "  long num_spaces = 0;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  int save_list;", "  linenr_T first_line = 0;              /* first changed line */", "  linenr_T last_line = 0;               /* last changed line */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  linenr_T first_line = 0;              /* first changed line */", "  linenr_T last_line = 0;               /* last changed line */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  save_list = curwin->w_p_list;", "  curwin->w_p_list = 0;             /* don't want list mode here */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    vcol = 0;", "    did_undo = FALSE;", "    for (;; ) {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        if (!got_tab && num_spaces == 0) {", "          /* First consecutive white-space */", "          start_vcol = vcol;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        }", "        if (ptr[col] == ' ')", "          num_spaces++;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["          num_spaces++;", "        else", "          got_tab = TRUE;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["        else", "          got_tab = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        if (got_tab || (eap->forceit && num_spaces > 1)) {", "          /* Retabulate this string of white-space */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "          /* len is virtual length of white string */", "          len = num_spaces = vcol - start_vcol;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "            /* len is actual number of white characters used */", "            len = num_spaces + num_tabs;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "            if (start_col > 0)", "              memmove(new_line, ptr, (size_t)start_col);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["            memmove(new_line + start_col + len,", "                ptr + col, (size_t)(old_len - col + 1));", "            ptr = new_line + start_col;"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["        }", "        got_tab = FALSE;", "        num_spaces = 0;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      }", "      if (ptr[col] == NUL)", "        break;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    }", "    if (new_line == NULL)                   /* out of memory */", "      break;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    }", "    if (new_line == NULL)                   /* out of memory */", "      break;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  }", "  if (got_int)", "    EMSG(_(e_interr));"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  curwin->w_p_list = save_list;         /* restore 'list' */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * :move command - move lines line1-line2 to line dest"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * First we copy the old text to its new location -- webb"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["   */", "  if (u_save(dest, dest + 1) == FAIL)", "    return FAIL;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    xfree(str);", "    if (dest < line1)", "      extra++;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Now we must be careful adjusting our marks so that we don't overlap our"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Now we delete the original text -- webb"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["   */", "  if (u_save(line1 + extra - 1, line2 + extra + 1) == FAIL)", "    return FAIL;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (!global_busy && num_lines > p_report) {", "    if (num_lines == 1)", "      MSG(_(\"1 line moved\"));"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      MSG(_(\"1 line moved\"));", "    else", "      smsg(_(\"%\" PRId64 \" lines moved\"), (int64_t)num_lines);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Leave the cursor on the last of the moved lines."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["   */", "  if (dest >= line1)", "    curwin->w_cursor.lnum = dest;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    curwin->w_cursor.lnum = dest;", "  else", "    curwin->w_cursor.lnum = dest + (line2 - line1) + 1;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    last_line = curbuf->b_ml.ml_line_count;", "    if (dest > last_line + 1)", "      dest = last_line + 1;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":copy\""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * there are three situations:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["   */", "  if (u_save(n, n + 1) == FAIL)", "    return;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  while (line1 <= line2) {", "    /* need to use vim_strsave() because the line will be unlocked within", "     * ml_append() */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "    /* situation 2: skip already copied lines */", "    if (line1 == n)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    /* situation 2: skip already copied lines */", "    if (line1 == n)", "      line1 = curwin->w_cursor.lnum;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      line1 = curwin->w_cursor.lnum;", "    ++line1;", "    if (curwin->w_cursor.lnum < line1)"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    ++line1;", "    if (curwin->w_cursor.lnum < line1)", "      ++line1;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (curwin->w_cursor.lnum < line1)", "      ++line1;", "    if (curwin->w_cursor.lnum < line2)"], "readability/increment"]
["src/nvim/ex_cmds.c", ["      ++line1;", "    if (curwin->w_cursor.lnum < line2)", "      ++line2;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (curwin->w_cursor.lnum < line2)", "      ++line2;", "    ++curwin->w_cursor.lnum;"], "readability/increment"]
["src/nvim/ex_cmds.c", ["      ++line2;", "    ++curwin->w_cursor.lnum;", "  }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "static char_u   *prevcmd = NULL;        /* the previous command */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * Handle the \":!cmd\" command.\tAlso for \":r !cmd\" and \":w !cmd\""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  if (addr_count == 0) {                /* :! */", "    msg_scroll = FALSE;             /* don't scroll here */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (addr_count == 0) {                /* :! */", "    msg_scroll = FALSE;             /* don't scroll here */", "    autowrite_all();"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (addr_count == 0) {                /* :! */", "    msg_scroll = FALSE;             /* don't scroll here */", "    autowrite_all();"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Try to find an embedded bang, like in :!<cmd> ! [args]"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    len = (int)STRLEN(trailarg) + 1;", "    if (newcmd != NULL)", "      len += (int)STRLEN(newcmd);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    *t = NUL;", "    if (newcmd != NULL)", "      STRCAT(t, newcmd);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      STRCAT(t, newcmd);", "    if (ins_prevcmd)", "      STRCAT(t, prevcmd);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "    /*", "     * Scan the rest of the argument for '!', which is replaced by the"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      if (*p == '!') {", "        if (p > newcmd && p[-1] == '\\\\')", "          STRMOVE(p - 1, p);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["          STRMOVE(p - 1, p);", "        else {", "          trailarg = p;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["          STRMOVE(p - 1, p);", "        else {", "          trailarg = p;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      }", "      ++p;", "    }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "  if (bangredo) { /* put cmd in redo buffer for ! command */", "    /* If % or # appears in the command, it must have been escaped."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (bangredo) { /* put cmd in redo buffer for ! command */", "    /* If % or # appears in the command, it must have been escaped.", "     * Reescape them, so that redoing them does not substitute them by the"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  }", "  /*", "   * Add quotes around the command, for shells that need them."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  }", "  if (addr_count == 0) {                /* :! */", "    /* echo the command */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (addr_count == 0) {                /* :! */", "    /* echo the command */", "    msg_start();"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    do_shell(newcmd, 0);", "  } else {                            /* :range! */", "    /* Careful: This may recursively call do_bang() again! (because of"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  } else {                            /* :range! */", "    /* Careful: This may recursively call do_bang() again! (because of", "     * autocommands) */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    do_filter(line1, line2, eap, newcmd, do_in, do_out);", "    apply_autocmds(EVENT_SHELLFILTERPOST, NULL, NULL, FALSE, curbuf);", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  }", "  if (free_newcmd)", "    xfree(newcmd);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    linenr_T line2,", "    exarg_T *eap,               /* for forced 'ff' and 'fenc' */", "    char_u *cmd,"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  if (*cmd == NUL)          /* no filter command */", "    return;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  if (*cmd == NUL)          /* no filter command */", "    return;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * When using temp files:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  if (do_out)", "    shell_flags |= kShellOptDoOut;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  } else if ((do_in && (itmp = vim_tempname()) == NULL)", "      || (do_out && (otmp = vim_tempname()) == NULL)) {", "    EMSG(_(e_notmp));"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * The writing and reading of temp files will not be shown."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["   */", "  ++no_wait_return;             /* don't call wait_return() while busy */", "  if (itmp != NULL && buf_write(curbuf, itmp, NULL, line1, line2, eap,"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["   */", "  ++no_wait_return;             /* don't call wait_return() while busy */", "  if (itmp != NULL && buf_write(curbuf, itmp, NULL, line1, line2, eap,"], "readability/increment"]
["src/nvim/ex_cmds.c", ["  }", "  if (curbuf != old_curbuf)", "    goto filterend;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  if (!do_out)", "    msg_putchar('\\n');"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /* Create the shell command in allocated memory. */", "  cmd_buf = make_filter_cmd(cmd, itmp, otmp);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  did_check_timestamps = FALSE;", "  need_check_timestamps = TRUE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  did_check_timestamps = FALSE;", "  need_check_timestamps = TRUE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /* When interrupting the shell command, it may still have produced some", "   * useful output.  Reset got_int here, so that readfile() won't cancel"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  os_breakcheck();", "  got_int = FALSE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["      }", "      if (curbuf != old_curbuf)", "        goto filterend;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "      /*", "       * Put cursor on first filtered line for \":range!cmd\"."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      curwin->w_cursor.lnum = line1;", "      del_lines(linecount, TRUE);", "      curbuf->b_op_start.lnum -= linecount;             /* adjust '[ */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      del_lines(linecount, TRUE);", "      curbuf->b_op_start.lnum -= linecount;             /* adjust '[ */", "      curbuf->b_op_end.lnum -= linecount;               /* adjust '] */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      curbuf->b_op_start.lnum -= linecount;             /* adjust '[ */", "      curbuf->b_op_end.lnum -= linecount;               /* adjust '] */", "      write_lnum_adjust(-linecount);                    /* adjust last line"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      curbuf->b_op_end.lnum -= linecount;               /* adjust '] */", "      write_lnum_adjust(-linecount);                    /* adjust last line", "                                                           for next write */"], "readability/multiline_comment"]
["src/nvim/ex_cmds.c", ["      curbuf->b_op_end.lnum -= linecount;               /* adjust '] */", "      write_lnum_adjust(-linecount);                    /* adjust last line", "                                                           for next write */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    } else {", "      /*", "       * Put cursor on last new line for \":r !cmd\"."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "    beginline(BL_WHITE | BL_FIX);           /* cursor on first non-blank */", "    --no_wait_return;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    beginline(BL_WHITE | BL_FIX);           /* cursor on first non-blank */", "    --no_wait_return;", ""], "readability/increment"]
["src/nvim/ex_cmds.c", ["        vim_snprintf((char *)msg_buf, sizeof(msg_buf),", "            _(\"%\" PRId64 \" lines filtered\"), (int64_t)linecount);", "        if (msg(msg_buf) && !msg_scroll)"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["            _(\"%\" PRId64 \" lines filtered\"), (int64_t)linecount);", "        if (msg(msg_buf) && !msg_scroll)", "          /* save message to display it after redraw */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["        if (msg(msg_buf) && !msg_scroll)", "          /* save message to display it after redraw */", "          set_keep_msg(msg_buf, 0);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          set_keep_msg(msg_buf, 0);", "      } else", "        msgmore((long)linecount);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["error:", "    /* put cursor back in same position for \":w !cmd\" */", "    curwin->w_cursor = cursor_save;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    curwin->w_cursor = cursor_save;", "    --no_wait_return;", "    wait_return(FALSE);"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    --no_wait_return;", "    wait_return(FALSE);", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  if (curbuf != old_curbuf) {", "    --no_wait_return;", "    EMSG(_(\"E135: *Filter* Autocommands must not change current buffer\"));"], "readability/increment"]
["src/nvim/ex_cmds.c", ["  }", "  if (itmp != NULL)", "    os_remove((char *)itmp);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    os_remove((char *)itmp);", "  if (otmp != NULL)", "    os_remove((char *)otmp);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * For autocommands we want to get the output on the current screen, to"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  // This ui_cursor_goto is required for when the '\\n' resulted in a \"delete line", "  // 1\" command to the terminal."], "whitespace/line_length"]
["src/nvim/ex_cmds.c", ["", "  apply_autocmds(EVENT_SHELLCMDPOST, NULL, NULL, FALSE, curbuf);", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  if (otmp != NULL) {", "    append_redir(buf, len, (char *) p_srr, (char *) otmp);", "  }"], "whitespace/cast"]
["src/nvim/ex_cmds.c", ["  }", "  return (char_u *) buf;", "}"], "whitespace/cast"]
["src/nvim/ex_cmds.c", ["    *end = ' ';  // not really needed? Not with sh, ksh or bash", "    vim_snprintf(end + 1, (size_t) (buflen - (end + 1 - buf)), opt, fname);", "  } else {"], "whitespace/cast"]
["src/nvim/ex_cmds.c", ["  } else {", "    vim_snprintf(end, (size_t) (buflen - (end - buf)), \" %s %s\", opt, fname);", "  }"], "whitespace/cast"]
["src/nvim/ex_cmds.c", ["", "/*", " * Print a text line.  Also in silent mode (\"ex -s\")."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  msg_start();", "  silent_mode = FALSE;", "  info_message = TRUE;          /* use mch_msg(), not mch_errmsg() */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  silent_mode = FALSE;", "  info_message = TRUE;          /* use mch_msg(), not mch_errmsg() */", "  print_line_no_prefix(lnum, use_number, list);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  silent_mode = FALSE;", "  info_message = TRUE;          /* use mch_msg(), not mch_errmsg() */", "  print_line_no_prefix(lnum, use_number, list);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  }", "  info_message = FALSE;", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  buf = curbuf;", "  apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);", "  /* buffer changed, don't change name now */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);", "  /* buffer changed, don't change name now */", "  if (buf != curbuf)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  /* buffer changed, don't change name now */", "  if (buf != curbuf)", "    return FAIL;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    return FAIL;", "  if (aborting())           /* autocmds may abort script processing */", "    return FAIL;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    return FAIL;", "  if (aborting())           /* autocmds may abort script processing */", "    return FAIL;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    return FAIL;", "  /*", "   * The name of the current buffer will be changed."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  xfree(sfname);", "  apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);", "  /* Change directories when the 'acd' option is set. */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);", "  /* Change directories when the 'acd' option is set. */", "  do_autochdir();"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":file[!] [fname]\"."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["{", "  /* \":0file\" removes the file name.  Check for illegal uses \":3file\",", "   * \"0file name\", etc. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":update\"."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["{", "  if (curbufIsChanged())", "    (void)do_write(eap);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":write\" and \":saveas\"."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * write current buffer to file 'eap->arg'"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  int other;", "  char_u      *fname = NULL;            /* init to shut up gcc */", "  char_u      *ffname;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  if (not_writing())            /* check 'write' option */", "    return FAIL;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  if (not_writing())            /* check 'write' option */", "    return FAIL;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    }", "    other = FALSE;", "  } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    free_fname = (char_u *)fix_fname((char *)ffname);", "    /*", "     * When out-of-memory, keep unexpanded file name, because we MUST be"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["     */", "    if (free_fname != NULL)", "      ffname = free_fname;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * If we have a new file, put its name in the list of alternate file names."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (other) {", "    if (vim_strchr(p_cpo, CPO_ALTWRITE) != NULL", "        || eap->cmdidx == CMD_saveas)"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      alt_buf = setaltfname(ffname, fname, (linenr_T)1);", "    else", "      alt_buf = buflist_findname(ffname);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (alt_buf != NULL && alt_buf->b_ml.ml_mfp != NULL) {", "      /* Overwriting a file that is loaded in another buffer is not a", "       * good idea. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    fname = curbuf->b_fname;", "    /*", "     * Not writing the whole file is only allowed with '!'."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["                || eap->line2 != curbuf->b_ml.ml_line_count)", "               && !eap->forceit", "               && !eap->append"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["               && !eap->forceit", "               && !eap->append", "               && !p_wa) {"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["               && !eap->append", "               && !p_wa) {", "      if (p_confirm || cmdmod.confirm) {"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["      if (p_confirm || cmdmod.confirm) {", "        if (vim_dialog_yesno(VIM_QUESTION, NULL,", "                (char_u *)_(\"Write partial file?\"), 2) != VIM_YES)"], "readability/braces"]
["src/nvim/ex_cmds.c", ["        if (vim_dialog_yesno(VIM_QUESTION, NULL,", "                (char_u *)_(\"Write partial file?\"), 2) != VIM_YES)", "          goto theend;"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["          goto theend;", "        eap->forceit = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "      apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);", "      apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, alt_buf);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);", "      apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, alt_buf);", "      if (curbuf != was_curbuf || aborting()) {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      if (curbuf != was_curbuf || aborting()) {", "        /* buffer changed, don't change name now */", "        retval = FAIL;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      }", "      /* Exchange the file names for the current and the alternate", "       * buffer.  This makes it look like we are now editing the buffer"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      buf_name_changed(curbuf);", "      apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);", "      apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, alt_buf);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);", "      apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, alt_buf);", "      if (!alt_buf->b_p_bl) {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      if (!alt_buf->b_p_bl) {", "        alt_buf->b_p_bl = TRUE;", "        apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, alt_buf);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        alt_buf->b_p_bl = TRUE;", "        apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, alt_buf);", "      }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      if (curbuf != was_curbuf || aborting()) {", "        /* buffer changed, don't write the file */", "        retval = FAIL;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "      /* Autocommands may have changed buffer names, esp. when", "       * 'autochdir' is set. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    retval = buf_write(curbuf, ffname, fname, eap->line1, eap->line2,", "        eap, eap->append, eap->forceit, TRUE, FALSE);", ""], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["    retval = buf_write(curbuf, ffname, fname, eap->line1, eap->line2,", "        eap, eap->append, eap->forceit, TRUE, FALSE);", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "    /* After \":saveas fname\" reset 'readonly'. */", "    if (eap->cmdidx == CMD_saveas) {"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      if (retval == OK) {", "        curbuf->b_p_ro = FALSE;", "        redraw_tabline = TRUE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        curbuf->b_p_ro = FALSE;", "        redraw_tabline = TRUE;", "      }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "/*", " * Check if it is allowed to overwrite a file.  If b_flags has BF_NOTEDITED,"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["{", "  /*", "   * write to other file or b_flags set or not writing the whole file:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        dialog_msg(buff, _(\"Overwrite existing file \\\"%s\\\"?\"), fname);", "        if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) != VIM_YES)", "          return FAIL;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["          return FAIL;", "        eap->forceit = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "    /* For \":w! filename\" check that no swap file exists for \"filename\". */", "    if (other && !emsg_silent) {"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "      /* We only try the first entry in 'directory', without checking if", "       * it's writable.  If the \".\" directory is not writable the write"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          dialog_msg(buff,", "              _(\"Swap file \\\"%s\\\" exists, overwrite anyway?\"),", "              swapname);"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["              _(\"Swap file \\\"%s\\\" exists, overwrite anyway?\"),", "              swapname);", "          if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2)"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["          }", "          eap->forceit = TRUE;", "        } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["          EMSG2(_(\"E768: Swap file exists: %s (:silent! overrides)\"),", "              swapname);", "          xfree(swapname);"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["", "/*", " * Handle \":wnext\", \":wNext\" and \":wprevious\" commands."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  if (eap->cmd[1] == 'n')", "    i = curwin->w_arg_idx + (int)eap->line2;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    i = curwin->w_arg_idx + (int)eap->line2;", "  else", "    i = curwin->w_arg_idx - (int)eap->line2;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  eap->line2 = curbuf->b_ml.ml_line_count;", "  if (do_write(eap) != FAIL)", "    do_argfile(eap, i);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":wall\", \":wqall\" and \":xall\": Write all changed files (and exit)."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    }", "    /*", "     * Check if there is a reason the buffer cannot be written:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    if (not_writing()) {", "      ++error;", "      break;"], "readability/increment"]
["src/nvim/ex_cmds.c", ["      EMSGN(_(\"E141: No file name for buffer %\" PRId64), buf->b_fnum);", "      ++error;", "    } else if (check_readonly(&eap->forceit, buf)"], "readability/increment"]
["src/nvim/ex_cmds.c", ["               || check_overwrite(eap, buf, buf->b_fname, buf->b_ffname,", "                   FALSE) == FAIL) {", "      ++error;"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["               || check_overwrite(eap, buf, buf->b_fname, buf->b_ffname,", "                   FALSE) == FAIL) {", "      ++error;"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["               || check_overwrite(eap, buf, buf->b_fname, buf->b_ffname,", "                   FALSE) == FAIL) {", "      ++error;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["                   FALSE) == FAIL) {", "      ++error;", "    } else {"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    }", "    eap->forceit = save_forceit;          /* check_overwrite() may set it */", "  }"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (exiting) {", "    if (!error)", "      getout(0);                /* exit Vim */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (!error)", "      getout(0);                /* exit Vim */", "    not_exiting();"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * Check the 'write' option."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["{", "  if (p_write)", "    return FALSE;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (p_write)", "    return FALSE;", "  EMSG(_(\"E142: File not written: Writing is disabled by 'write' option\"));"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  EMSG(_(\"E142: File not written: Writing is disabled by 'write' option\"));", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "/*", " * Check if a buffer is read-only (either 'readonly' option is set or file is"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["{", "  /* Handle a file being readonly when the 'readonly' option is set or when", "   * the file exists and permissions are read-only. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "      if (buf->b_p_ro)", "        dialog_msg(buff,"], "readability/braces"]
["src/nvim/ex_cmds.c", ["        dialog_msg(buff,", "            _(", "                \"'readonly' option is set for \\\"%s\\\".\\nDo you wish to write anyway?\"),"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                \"'readonly' option is set for \\\"%s\\\".\\nDo you wish to write anyway?\"),", "            buf->b_fname);", "      else"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["            _(", "                \"'readonly' option is set for \\\"%s\\\".\\nDo you wish to write anyway?\"),", "            buf->b_fname);"], "whitespace/line_length"]
["src/nvim/ex_cmds.c", ["            buf->b_fname);", "      else", "        dialog_msg(buff,"], "readability/braces"]
["src/nvim/ex_cmds.c", ["        dialog_msg(buff,", "            _(", "                \"File permissions of \\\"%s\\\" are read-only.\\nIt may still be possible to write it.\\nDo you wish to try?\"),"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                \"File permissions of \\\"%s\\\" are read-only.\\nIt may still be possible to write it.\\nDo you wish to try?\"),", "            buf->b_fname);", ""], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["            _(", "                \"File permissions of \\\"%s\\\" are read-only.\\nIt may still be possible to write it.\\nDo you wish to try?\"),", "            buf->b_fname);"], "whitespace/line_length"]
["src/nvim/ex_cmds.c", ["      if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) == VIM_YES) {", "        /* Set forceit, to force the writing of a readonly file */", "        *forceit = TRUE;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        /* Set forceit, to force the writing of a readonly file */", "        *forceit = TRUE;", "        return FALSE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        *forceit = TRUE;", "        return FALSE;", "      } else"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        return FALSE;", "      } else", "        return TRUE;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      } else", "        return TRUE;", "    } else if (buf->b_p_ro)"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        return TRUE;", "    } else if (buf->b_p_ro)", "      EMSG(_(e_readonly));"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      EMSG(_(e_readonly));", "    else", "      EMSG2(_(\"E505: \\\"%s\\\" is read-only (add ! to override)\"),"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      EMSG2(_(\"E505: \\\"%s\\\" is read-only (add ! to override)\"),", "          buf->b_fname);", "    return TRUE;"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["          buf->b_fname);", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  if (fnum == 0) {", "    /* make ffname full path, set sfname */", "    fname_expand(curbuf, &ffname, &sfname);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    other = otherfile(ffname);", "    free_me = ffname;                   /* has been allocated, free() later */", "  } else"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    free_me = ffname;                   /* has been allocated, free() later */", "  } else", "    other = (fnum != curbuf->b_fnum);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  }", "  if (other)", "    --no_wait_return;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (other)", "    --no_wait_return;", "  if (setpm)"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    --no_wait_return;", "  if (setpm)", "    setpcmark();"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    char_u *sfname,", "    exarg_T *eap,                       /* can be NULL! */", "    linenr_T newlnum,"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["{", "  int other_file;                       /* TRUE if editing another file */", "  int oldbuf;                           /* TRUE if using existing buffer */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  int other_file;                       /* TRUE if editing another file */", "  int oldbuf;                           /* TRUE if using existing buffer */", "  int auto_buf = FALSE;                 /* TRUE if autocommands brought us"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  int oldbuf;                           /* TRUE if using existing buffer */", "  int auto_buf = FALSE;                 /* TRUE if autocommands brought us", "                                           into the buffer unexpectedly */"], "readability/multiline_comment"]
["src/nvim/ex_cmds.c", ["  int oldbuf;                           /* TRUE if using existing buffer */", "  int auto_buf = FALSE;                 /* TRUE if autocommands brought us", "                                           into the buffer unexpectedly */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  int oldbuf;                           /* TRUE if using existing buffer */", "  int auto_buf = FALSE;                 /* TRUE if autocommands brought us", "                                           into the buffer unexpectedly */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  char_u      *new_name = NULL;", "  int did_set_swapcommand = FALSE;", "  buf_T       *buf;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  char_u      *command = NULL;", "  int did_get_winopts = FALSE;", "  int readfile_flags = 0;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  if (eap != NULL)", "    command = eap->do_ecmd_cmd;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (fnum != 0) {", "    if (fnum == curbuf->b_fnum)         /* file is already being edited */", "      return OK;                        /* nothing to do */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (fnum != 0) {", "    if (fnum == curbuf->b_fnum)         /* file is already being edited */", "      return OK;                        /* nothing to do */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (fnum == curbuf->b_fnum)         /* file is already being edited */", "      return OK;                        /* nothing to do */", "    other_file = TRUE;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      return OK;                        /* nothing to do */", "    other_file = TRUE;", "  } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  } else {", "    /* if no short name given, use ffname for short name */", "    if (sfname == NULL)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    /* if no short name given, use ffname for short name */", "    if (sfname == NULL)", "      sfname = ffname;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["#ifdef USE_FNAME_CASE", "    if (sfname != NULL)", "      path_fix_case(sfname);             // set correct case for sfname"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "    if (ffname == NULL)", "      other_file = TRUE;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (ffname == NULL)", "      other_file = TRUE;", "    /* there is no file name */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      other_file = TRUE;", "    /* there is no file name */", "    else if (*ffname == NUL && curbuf->b_ffname == NULL)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    /* there is no file name */", "    else if (*ffname == NUL && curbuf->b_ffname == NULL)", "      other_file = FALSE;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    else if (*ffname == NUL && curbuf->b_ffname == NULL)", "      other_file = FALSE;", "    else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      other_file = FALSE;", "    else {", "      if (*ffname == NUL) {                 /* re-edit with same file name */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      other_file = FALSE;", "    else {", "      if (*ffname == NUL) {                 /* re-edit with same file name */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    else {", "      if (*ffname == NUL) {                 /* re-edit with same file name */", "        ffname = curbuf->b_ffname;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      }", "      free_fname = (char_u *)fix_fname((char *)ffname);       /* may expand to full path name */", "      if (free_fname != NULL)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      }", "      free_fname = (char_u *)fix_fname((char *)ffname);       /* may expand to full path name */", "      if (free_fname != NULL)"], "whitespace/line_length"]
["src/nvim/ex_cmds.c", ["      free_fname = (char_u *)fix_fname((char *)ffname);       /* may expand to full path name */", "      if (free_fname != NULL)", "        ffname = free_fname;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * End Visual mode before switching to another buffer, so the text can be"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    set_vim_var_string(VV_SWAPCOMMAND, p, -1);", "    did_set_swapcommand = TRUE;", "    xfree(p);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * If we are starting to edit another file, open a (new) buffer."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          tlnum = atol((char *)command);", "          if (tlnum <= 0)", "            tlnum = 1L;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    }", "    if (buf == NULL)", "      goto theend;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "    /* May jump to last used line number for a loaded buffer or when asked", "     * for explicitly */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "    /*", "     * Make the (new) buffer the one used by the current window."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    if (buf != curbuf) {", "      /*", "       * Be careful: The autocommands may delete any buffer and change"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      }", "      if (aborting()) {             /* autocmds may abort script processing */", "        xfree(new_name);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          curbuf = buf;", "          ++curbuf->b_nwindows;", ""], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "          /* Set 'fileformat', 'binary' and 'fenc' when forced. */", "          if (!oldbuf && eap != NULL) {"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          if (!oldbuf && eap != NULL) {", "            set_file_options(TRUE, eap);", "            set_forced_fenc(eap);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "        /* May get the window options from the last time this buffer", "         * was in this window (or another window).  If not used"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        get_winopts(curbuf);", "        did_get_winopts = TRUE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["        did_get_winopts = TRUE;", "", "      }"], "whitespace/blank_line"]
["src/nvim/ex_cmds.c", ["    // CTRL-O to go back to a help file.", "    set_buflisted(TRUE);", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /* If autocommands change buffers under our fingers, forget about", "   * editing the file. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["   * editing the file. */", "  if (buf != curbuf)", "    goto theend;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    goto theend;", "  if (aborting())           /* autocmds may abort script processing */", "    goto theend;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    goto theend;", "  if (aborting())           /* autocmds may abort script processing */", "    goto theend;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /* Since we are starting to edit a file, consider the filetype to be", "   * unset.  Helps for when an autocommand changes files and expects syntax"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["   * highlighting to work in the other file. */", "  did_filetype = FALSE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * other_file\toldbuf"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["   */", "  if (!other_file && !oldbuf) {         /* re-use the buffer */", "    set_last_cursor(curwin);            /* may set b_last_cursor */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (!other_file && !oldbuf) {         /* re-use the buffer */", "    set_last_cursor(curwin);            /* may set b_last_cursor */", "    if (newlnum == ECMD_LAST || newlnum == ECMD_LASTL) {"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "    /* If autocommands change buffers under our fingers, forget about", "     * re-editing the file.  Should do the buf_clear_file(), but perhaps"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["     * the autocommands changed the buffer... */", "    if (buf != curbuf)", "      goto theend;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      goto theend;", "    if (aborting())         /* autocmds may abort script processing */", "      goto theend;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      goto theend;", "    if (aborting())         /* autocmds may abort script processing */", "      goto theend;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    buf_clear_file(curbuf);", "    curbuf->b_op_start.lnum = 0;        /* clear '[ and '] marks */", "    curbuf->b_op_end.lnum = 0;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * If we get here we are sure to start editing"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /* Assume success now */", "  retval = OK;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Check if we are editing the w_arg_idx file in the argument list."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (!auto_buf) {", "    /*", "     * Set cursor and init window before reading the file and executing"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "    /* It's possible that all lines in the buffer changed.  Need to update", "     * automatic folding for all windows where it's used. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "    /* Change directories when the 'acd' option is set. */", "    do_autochdir();"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "    /*", "     * Careful: open_buffer() and apply_autocmds() may change the current"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    topline = curwin->w_topline;", "    if (!oldbuf) {                          /* need to read the file */", "      swap_exists_action = SEA_DIALOG;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      swap_exists_action = SEA_DIALOG;", "      curbuf->b_flags |= BF_CHECK_RO;       /* set/reset 'ro' flag */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "      /*", "       * Open the buffer and read the file."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["       */", "      if (should_abort(open_buffer(FALSE, eap, readfile_flags)))", "        retval = FAIL;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["       */", "      if (should_abort(open_buffer(FALSE, eap, readfile_flags)))", "        retval = FAIL;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "      if (swap_exists_action == SEA_QUIT)", "        retval = FAIL;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    } else {", "      /* Read the modelines, but only to set window-local options.  Any", "       * buffer-local options have already been set and may have been"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf,", "          &retval);", "      apply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf,"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["", "      apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf,", "          &retval);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      apply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf,", "          &retval);", "    }"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["          &retval);", "      apply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf,", "          &retval);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    }", "    if (curwin->w_topline == topline)", "      topline = 0;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "    /* Even when cursor didn't move we need to recompute topline. */", "    changed_line_abv_curs();"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /* Tell the diff stuff that this buffer is new and/or needs updating.", "   * Also needed when re-editing the same buffer, because unloading will"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /* If the window options were changed may need to set the spell language.", "   * Can only do this after the buffer has been properly setup. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["   * Can only do this after the buffer has been properly setup. */", "  if (did_get_winopts && curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)", "    (void)did_set_spelllang(curwin);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (command == NULL) {", "    if (newcol >= 0) {          /* position set by autocommands */", "      curwin->w_cursor.lnum = newlnum;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      check_cursor();", "    } else if (newlnum > 0) { /* line number from caller or old position */", "      curwin->w_cursor.lnum = newlnum;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      if (solcol >= 0 && !p_sol) {", "        /* 'sol' is off: Use last known column. */", "        curwin->w_cursor.col = solcol;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        curwin->w_cursor.coladd = 0;", "        curwin->w_set_curswant = TRUE;", "      } else"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        curwin->w_set_curswant = TRUE;", "      } else", "        beginline(BL_SOL | BL_FIX);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["        beginline(BL_SOL | BL_FIX);", "    } else {                  /* no line number, go to last line in Ex mode */", "      if (exmode_active)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    } else {                  /* no line number, go to last line in Ex mode */", "      if (exmode_active)", "        curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /* Check if cursors in other windows on the same buffer are still valid */", "  check_lnums(FALSE);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  /* Check if cursors in other windows on the same buffer are still valid */", "  check_lnums(FALSE);", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Did not read the file, need to show some info about the file."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "    /* Obey the 'O' flag in 'cpoptions': overwrite any previous file", "     * message. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["     * message. */", "    if (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0)", "      msg_scroll = FALSE;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0)", "      msg_scroll = FALSE;", "    if (!msg_scroll)            /* wait a bit when overwriting an error msg */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      msg_scroll = FALSE;", "    if (!msg_scroll)            /* wait a bit when overwriting an error msg */", "      check_for_delay(FALSE);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      msg_scroll = FALSE;", "    if (!msg_scroll)            /* wait a bit when overwriting an error msg */", "      check_for_delay(FALSE);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (!msg_scroll)            /* wait a bit when overwriting an error msg */", "      check_for_delay(FALSE);", "    msg_start();"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    msg_scroll = msg_scroll_save;", "    msg_scrolled_ign = TRUE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "    msg_scrolled_ign = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  if (command != NULL)", "    do_cmdline(command, NULL, NULL, DOCMD_VERBOSE);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  if (curbuf->b_kmap_state & KEYMAP_INIT)", "    (void)keymap_init();"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  if (p_im)", "    need_start_insertmode = TRUE;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (p_im)", "    need_start_insertmode = TRUE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /* Change directories when the 'acd' option is set. */", "  do_autochdir();"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  EMSG2(_(\"E143: Autocommands unexpectedly deleted new buffer %s\"),", "      name == NULL ? (char_u *)\"\" : name);", "  xfree(name);"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["", "static int append_indent = 0;       /* autoindent for first line */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":insert\" and \":append\", also used by \":change\""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /* the ! flag toggles autoindent */", "  if (eap->forceit)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  /* the ! flag toggles autoindent */", "  if (eap->forceit)", "    curbuf->b_p_ai = !curbuf->b_p_ai;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /* First autoindent comes from the line we start on */", "  if (eap->cmdidx != CMD_change && curbuf->b_p_ai && lnum > 0)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  /* First autoindent comes from the line we start on */", "  if (eap->cmdidx != CMD_change && curbuf->b_p_ai && lnum > 0)", "    append_indent = get_indent_lnum(lnum);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  if (eap->cmdidx != CMD_append)", "    --lnum;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (eap->cmdidx != CMD_append)", "    --lnum;", ""], "readability/increment"]
["src/nvim/ex_cmds.c", ["  // when the buffer is empty need to delete the dummy line", "  if (empty && lnum == 1)", "    lnum = 0;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  State = INSERT;                   /* behave like in Insert mode */", "  if (curbuf->b_p_iminsert == B_IMODE_LMAP)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  State = INSERT;                   /* behave like in Insert mode */", "  if (curbuf->b_p_iminsert == B_IMODE_LMAP)", "    State |= LANGMAP;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  for (;; ) {", "    msg_scroll = TRUE;", "    need_wait_return = FALSE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    msg_scroll = TRUE;", "    need_wait_return = FALSE;", "    if (curbuf->b_p_ai) {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        append_indent = -1;", "      } else if (lnum > 0)", "        indent = get_indent_lnum(lnum);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    }", "    ex_keep_indent = FALSE;", "    if (eap->getline == NULL) {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    if (eap->getline == NULL) {", "      /* No getline() function, use the lines that follow. This ends", "       * when there is no more. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["       * when there is no more. */", "      if (eap->nextcmd == NULL || *eap->nextcmd == NUL)", "        break;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      p = vim_strchr(eap->nextcmd, NL);", "      if (p == NULL)", "        p = eap->nextcmd + STRLEN(eap->nextcmd);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    lines_left = Rows - 1;", "    if (theline == NULL)", "      break;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "    /* Using ^ CTRL-D in getexmodeline() makes us repeat the indent. */", "    if (ex_keep_indent)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    /* Using ^ CTRL-D in getexmodeline() makes us repeat the indent. */", "    if (ex_keep_indent)", "      append_indent = indent;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "    /* Look for the \".\" after automatic indent. */", "    vcol = 0;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    vcol = 0;", "    for (p = theline; indent > vcol; ++p) {", "      if (*p == ' ')"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    for (p = theline; indent > vcol; ++p) {", "      if (*p == ' ')", "        ++vcol;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      if (*p == ' ')", "        ++vcol;", "      else if (*p == TAB)"], "readability/increment"]
["src/nvim/ex_cmds.c", ["        ++vcol;", "      else if (*p == TAB)", "        vcol += 8 - vcol % 8;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["        vcol += 8 - vcol % 8;", "      else", "        break;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "    /* don't use autoindent if nothing was typed. */", "    if (p[0] == NUL)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    /* don't use autoindent if nothing was typed. */", "    if (p[0] == NUL)", "      theline[0] = NUL;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    xfree(theline);", "    ++lnum;", ""], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "  if (eap->forceit)", "    curbuf->b_p_ai = !curbuf->b_p_ai;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /* \"start\" is set to eap->line2+1 unless that position is invalid (when", "   * eap->line2 pointed to the end of the buffer and nothing was appended)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["                            eap->line2 + 1 : curbuf->b_ml.ml_line_count;", "  if (eap->cmdidx != CMD_append)", "    --curbuf->b_op_start.lnum;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (eap->cmdidx != CMD_append)", "    --curbuf->b_op_start.lnum;", "  curbuf->b_op_end.lnum = (eap->line2 < lnum)"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "  need_wait_return = FALSE;     /* don't use wait_return() now */", "  ex_no_reprint = TRUE;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  need_wait_return = FALSE;     /* don't use wait_return() now */", "  ex_no_reprint = TRUE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  need_wait_return = FALSE;     /* don't use wait_return() now */", "  ex_no_reprint = TRUE;", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":change\""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  if (eap->line2 >= eap->line1", "      && u_save(eap->line1 - 1, eap->line2 + 1) == FAIL)"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /* the ! flag toggles autoindent */", "  if (eap->forceit ? !curbuf->b_p_ai : curbuf->b_p_ai)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  /* the ! flag toggles autoindent */", "  if (eap->forceit ? !curbuf->b_p_ai : curbuf->b_p_ai)", "    append_indent = get_indent_lnum(eap->line1);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  for (lnum = eap->line2; lnum >= eap->line1; --lnum) {", "    if (curbuf->b_ml.ml_flags & ML_EMPTY)           /* nothing to delete */"], "readability/increment"]
["src/nvim/ex_cmds.c", ["  for (lnum = eap->line2; lnum >= eap->line1; --lnum) {", "    if (curbuf->b_ml.ml_flags & ML_EMPTY)           /* nothing to delete */", "      break;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  for (lnum = eap->line2; lnum >= eap->line1; --lnum) {", "    if (curbuf->b_ml.ml_flags & ML_EMPTY)           /* nothing to delete */", "      break;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /* make sure the cursor is not beyond the end of the file now */", "  check_cursor_lnum();"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /* \":append\" on the line above the deleted lines. */", "  eap->line2 = eap->line1;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  kind = x;", "  if (*kind == '-' || *kind == '+' || *kind == '='", "      || *kind == '^' || *kind == '.')"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      || *kind == '^' || *kind == '.')", "    ++x;", "  while (*x == '-' || *x == '+')"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    ++x;", "  while (*x == '-' || *x == '+')", "    ++x;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  while (*x == '-' || *x == '+')", "    ++x;", ""], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "  /* the number of '-' and '+' multiplies the distance */", "  if (*kind == '-' || *kind == '+')"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  /* the number of '-' and '+' multiplies the distance */", "  if (*kind == '-' || *kind == '+')", "    for (x = kind + 1; *x == *kind; ++x)"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (*kind == '-' || *kind == '+')", "    for (x = kind + 1; *x == *kind; ++x)", "      ;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (*kind == '-' || *kind == '+')", "    for (x = kind + 1; *x == *kind; ++x)", "      ;"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    for (x = kind + 1; *x == *kind; ++x)", "      ;", ""], "whitespace/semicolon"]
["src/nvim/ex_cmds.c", ["", "  default:        /* '+' */", "    start = lnum;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    start = lnum;", "    if (*kind == '+')", "      start += bigness * (linenr_T)(x - kind - 1) + 1;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      start += bigness * (linenr_T)(x - kind - 1) + 1;", "    else if (eap->addr_count == 0)", "      ++start;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    else if (eap->addr_count == 0)", "      ++start;", "    end = start + bigness - 1;"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "  if (start < 1)", "    start = 1;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  if (end > curbuf->b_ml.ml_line_count)", "    end = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "      for (j = 1; j < Columns; j++)", "        msg_putchar('-');"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "      for (j = 1; j < Columns; j++)", "        msg_putchar('-');"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "/*", " * Check if the secure flag is set (.exrc or .vimrc in current directory)."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    EMSG(_(e_curdir));", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    EMSG(_(e_sandbox));", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", ["/// Previous substitute replacement string", "static SubReplacementString old_sub = {NULL, 0, NULL};", ""], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["/// Previous substitute replacement string", "static SubReplacementString old_sub = {NULL, 0, NULL};", ""], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["    if (joined_lines_count > 1) {", "      do_join(joined_lines_count, FALSE, TRUE, FALSE, true);", "      sub_nsubs = joined_lines_count - 1;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  if (eap->cmdidx == CMD_tilde)", "    which_pat = RE_LAST;        /* use last used regexp */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (eap->cmdidx == CMD_tilde)", "    which_pat = RE_LAST;        /* use last used regexp */", "  else"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    which_pat = RE_LAST;        /* use last used regexp */", "  else", "    which_pat = RE_SUBST;       /* use last substitute regexp */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  else", "    which_pat = RE_SUBST;       /* use last substitute regexp */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /* new pattern and substitution */", "  if (eap->cmd[0] == 's' && *cmd != NUL && !ascii_iswhite(*cmd)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      && vim_strchr((char_u *)\"0123456789cegriIp|\\\"\", *cmd) == NULL) {", "    /* don't accept alphanumeric for separator */", "    if (isalpha(*cmd)) {"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    }", "    /*", "     * undocumented vi feature:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    if (*cmd == '\\\\') {", "      ++cmd;", "      if (vim_strchr((char_u *)\"/?&\", *cmd) == NULL) {"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "    /*", "     * Small incompatibility: vi sees '\\n' as end of the command, but in"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["     */", "    sub = cmd;              /* remember the start of the substitution */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    while (cmd[0]) {", "      if (cmd[0] == delimiter) {                /* end delimiter found */", "        *cmd++ = NUL;                           /* replace it with a NUL */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      if (cmd[0] == delimiter) {                /* end delimiter found */", "        *cmd++ = NUL;                           /* replace it with a NUL */", "        break;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      sub_set_replacement((SubReplacementString) {", "        .sub = xstrdup((char *) sub),", "        .timestamp = os_time(),"], "whitespace/cast"]
["src/nvim/ex_cmds.c", ["    }", "  } else if (!eap->skip) {    /* use previous pattern and substitution */", "    if (old_sub.sub == NULL) {      /* there is no previous command */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  } else if (!eap->skip) {    /* use previous pattern and substitution */", "    if (old_sub.sub == NULL) {      /* there is no previous command */", "      EMSG(_(e_nopresub));"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    }", "    pat = NULL;                 /* search_regcomp() will use previous pattern */", "    sub = (char_u *) old_sub.sub;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    pat = NULL;                 /* search_regcomp() will use previous pattern */", "    sub = (char_u *) old_sub.sub;", ""], "whitespace/cast"]
["src/nvim/ex_cmds.c", ["", "    /* Vi compatibility quirk: repeating with \":s\" keeps the cursor in the", "     * last column after using \"$\". */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    eap->line2 += i - 1;", "    if (eap->line2 > curbuf->b_ml.ml_line_count)", "      eap->line2 = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * check for trailing command or garbage"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  cmd = skipwhite(cmd);", "  if (*cmd && *cmd != '\"') {        /* if not end-of-line or comment */", "    eap->nextcmd = check_nextcmd(cmd);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      char_u      *p1;", "      int did_sub = FALSE;", "      int lastone;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "      /*", "       * The new text is build up step by step, to avoid too much"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "      /* At first match, remember current cursor position. */", "      if (!got_match) {"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        setpcmark();", "        got_match = TRUE;", "      }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "      /*", "       * Loop until nothing more to replace in this line."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "        /* Save the line number of the last change for the final", "         * cursor position (just like Vi). */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        curwin->w_cursor.lnum = lnum;", "        do_again = FALSE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "        /*", "         * 1. Match empty string does not count, except for first"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "        /* Normally we continue searching for a match just after the", "         * previous match. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          sub_nsubs++;", "          did_sub = TRUE;", "          /* Skip the substitution, unless an expression is used,"], "readability/bool"]
["src/nvim/ex_cmds.c", ["          did_sub = TRUE;", "          /* Skip the substitution, unless an expression is used,", "           * then it is evaluated in the sandbox. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["           * then it is evaluated in the sandbox. */", "          if (!(sub[0] == '\\\\' && sub[1] == '='))", "            goto skip;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "          /* change State to CONFIRM, so that the mouse works", "           * properly */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          State = CONFIRM;", "          setmouse();                   /* disable mouse in xterm */", "          curwin->w_cursor.col = regmatch.startpos[0].col;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "          /* When 'cpoptions' contains \"u\" don't sync undo when", "           * asking for confirmation. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["           * asking for confirmation. */", "          if (vim_strchr(p_cpo, CPO_UNDO) != NULL)", "            ++no_u_sync;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["          if (vim_strchr(p_cpo, CPO_UNDO) != NULL)", "            ++no_u_sync;", ""], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "          /*", "           * Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["              msg_start();", "              for (i = 0; i < (long)sc; ++i)", "                msg_putchar(' ');"], "readability/braces"]
["src/nvim/ex_cmds.c", ["              msg_start();", "              for (i = 0; i < (long)sc; ++i)", "                msg_putchar(' ');"], "readability/increment"]
["src/nvim/ex_cmds.c", ["                msg_putchar(' ');", "              for (; i <= (long)ec; ++i)", "                msg_putchar('^');"], "readability/braces"]
["src/nvim/ex_cmds.c", ["                msg_putchar(' ');", "              for (; i <= (long)ec; ++i)", "                msg_putchar('^');"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "              curwin->w_p_fen = FALSE;", "              /* Invert the matched string."], "readability/bool"]
["src/nvim/ex_cmds.c", ["              curwin->w_p_fen = FALSE;", "              /* Invert the matched string.", "               * Remove the inversion afterwards. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["              if (new_start != NULL) {", "                /* There already was a substitution, we would", "                 * like to show this to the user.  We cannot"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["                orig_line = vim_strsave(ml_get(lnum));", "                char_u *new_line = concat_str(new_start, sub_firstline + copycol);", ""], "whitespace/line_length"]
["src/nvim/ex_cmds.c", ["                                    + len_change;", "              highlight_match = TRUE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["              curwin->w_p_fen = save_p_fen;", "              if (msg_row == Rows - 1)", "                msg_didout = FALSE;                     /* avoid a scroll-up */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["              if (msg_row == Rows - 1)", "                msg_didout = FALSE;                     /* avoid a scroll-up */", "              msg_starthere();"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["              if (msg_row == Rows - 1)", "                msg_didout = FALSE;                     /* avoid a scroll-up */", "              msg_starthere();"], "readability/bool"]
["src/nvim/ex_cmds.c", ["              i = msg_scroll;", "              msg_scroll = 0;                           /* truncate msg when", "                                                           needed */"], "readability/multiline_comment"]
["src/nvim/ex_cmds.c", ["              i = msg_scroll;", "              msg_scroll = 0;                           /* truncate msg when", "                                                           needed */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["                        _(\"replace with %s (y/n/a/q/l/^E/^Y)?\"), sub);", "              msg_no_more = FALSE;", "              msg_scroll = i;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["              msg_scroll = i;", "              showruler(TRUE);", "              ui_cursor_goto(msg_row, msg_col);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "              /* clear the question */", "              msg_didout = FALSE;               /* don't scroll up */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["              /* clear the question */", "              msg_didout = FALSE;               /* don't scroll up */", "              msg_col = 0;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["              /* clear the question */", "              msg_didout = FALSE;               /* don't scroll up */", "              msg_col = 0;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["            }", "            if (typed == 'n')", "              break;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["              break;", "            if (typed == 'y')", "              break;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["            }", "            if (typed == Ctrl_E)", "              scrollup_clamp();"], "readability/braces"]
["src/nvim/ex_cmds.c", ["              scrollup_clamp();", "            else if (typed == Ctrl_Y)", "              scrolldown_clamp();"], "readability/braces"]
["src/nvim/ex_cmds.c", ["          setmouse();", "          if (vim_strchr(p_cpo, CPO_UNDO) != NULL)", "            --no_u_sync;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["          if (vim_strchr(p_cpo, CPO_UNDO) != NULL)", "            --no_u_sync;", ""], "readability/increment"]
["src/nvim/ex_cmds.c", ["          if (typed == 'n') {", "            /* For a multi-line match, put matchcol at the NUL at", "             * the end of the line and set nmatch to one, so that"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          }", "          if (got_quit)", "            goto skip;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "        /* Move the cursor to the start of the match, so that we can", "         * use \"\\=col(\".\"). */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["skip:", "        /* We already know that we did the last subst when we are at", "         * the end of the line, except that a pattern like"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "        /*", "         * Replace the line in the buffer when needed.  This is"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          if (new_start != NULL) {", "            /*", "             * Copy the rest of the line, that didn't match."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["            if (nmatch_tl > 0) {", "              /*", "               * Matched lines have now been substituted and are"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["               */", "              ++lnum;", "              if (u_savedel(lnum, nmatch_tl) != OK)"], "readability/increment"]
["src/nvim/ex_cmds.c", ["              ++lnum;", "              if (u_savedel(lnum, nmatch_tl) != OK)", "                break;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "            /* When asking, undo is saved each time, must also set", "             * changed flag each time. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["            sub_firstlnum = lnum;", "            xfree(sub_firstline);                /* free the temp buffer */", "            sub_firstline = new_start;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          }", "          if (nmatch == -1 && !lastone)", "            nmatch = vim_regexec_multi(&regmatch, curwin, curbuf,"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "          /*", "           * 5. break if there isn't another match in this line"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          if (nmatch <= 0) {", "            /* If the match found didn't start where we were", "             * searching, do the next search in the line where we"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["             * found the match. */", "            if (nmatch == -1)", "              lnum -= regmatch.startpos[0].lnum;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (first_line != 0) {", "    /* Need to subtract the number of added lines from \"last_line\" to get", "     * the line number before the change (same as adding the number of"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  xfree(sub_firstline);   /* may have to free allocated copy of the line */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (sub_nsubs > start_nsubs) {", "    /* Set the '[ and '] marks. */", "    curbuf->b_op_start.lnum = eap->line1;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * Give message for number of substitutions."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["bool", "do_sub_msg (", "    bool count_only                /* used 'n' flag for \":s\" */"], "whitespace/parens"]
["src/nvim/ex_cmds.c", ["do_sub_msg (", "    bool count_only                /* used 'n' flag for \":s\" */", ")"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["{", "  /*", "   * Only report substitutions when:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      && messaging()) {", "    if (got_int)", "      STRCPY(msg_buf, _(\"(Interrupted) \"));"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      STRCPY(msg_buf, _(\"(Interrupted) \"));", "    else", "      *msg_buf = NUL;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      *msg_buf = NUL;", "    if (sub_nsubs == 1)", "      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),", "          \"%s\", count_only ? _(\"1 match\") : _(\"1 substitution\"));", "    else"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["          \"%s\", count_only ? _(\"1 match\") : _(\"1 substitution\"));", "    else", "      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),", "          count_only ? _(\"%\" PRId64 \" matches\")", "                     : _(\"%\" PRId64 \" substitutions\"),"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["          count_only ? _(\"%\" PRId64 \" matches\")", "                     : _(\"%\" PRId64 \" substitutions\"),", "          (int64_t)sub_nsubs);"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                     : _(\"%\" PRId64 \" substitutions\"),", "          (int64_t)sub_nsubs);", "    if (sub_nlines == 1)"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["          (int64_t)sub_nsubs);", "    if (sub_nlines == 1)", "      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),", "          \"%s\", _(\" on 1 line\"));", "    else"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["          \"%s\", _(\" on 1 line\"));", "    else", "      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),", "          _(\" on %\" PRId64 \" lines\"), (int64_t)sub_nlines);", "    if (msg(msg_buf))"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["          _(\" on %\" PRId64 \" lines\"), (int64_t)sub_nlines);", "    if (msg(msg_buf))", "      /* save message to display it after redraw */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (msg(msg_buf))", "      /* save message to display it after redraw */", "      set_keep_msg(msg_buf, 0);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * Execute a global command of the form:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["{", "  linenr_T lnum;                /* line number according to old situation */", "  int ndone = 0;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  int ndone = 0;", "  int type;                     /* first char of cmd: 'v' or 'g' */", "  char_u      *cmd;             /* command argument */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  int type;                     /* first char of cmd: 'v' or 'g' */", "  char_u      *cmd;             /* command argument */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  char_u delim;                 /* delimiter, normally '/' */", "  char_u      *pat;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  if (eap->forceit)                 /* \":global!\" is like \":vglobal\" */", "    type = 'v';"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  if (eap->forceit)                 /* \":global!\" is like \":vglobal\" */", "    type = 'v';"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    type = 'v';", "  else", "    type = *eap->cmd;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  cmd = eap->arg;", "  which_pat = RE_LAST;              /* default: use last used regexp */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * undocumented vi feature:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (*cmd == '\\\\') {", "    ++cmd;", "    if (vim_strchr((char_u *)\"/?&\", *cmd) == NULL) {"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    }", "    if (*cmd == '&')", "      which_pat = RE_SUBST;             /* use previous substitute pattern */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (*cmd == '&')", "      which_pat = RE_SUBST;             /* use previous substitute pattern */", "    else"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      which_pat = RE_SUBST;             /* use previous substitute pattern */", "    else", "      which_pat = RE_SEARCH;            /* use previous search pattern */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    else", "      which_pat = RE_SEARCH;            /* use previous search pattern */", "    ++cmd;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      which_pat = RE_SEARCH;            /* use previous search pattern */", "    ++cmd;", "    pat = (char_u *)\"\";"], "readability/increment"]
["src/nvim/ex_cmds.c", ["  } else {", "    delim = *cmd;               /* get the delimiter */", "    if (delim)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    delim = *cmd;               /* get the delimiter */", "    if (delim)", "      ++cmd;                    /* skip delimiter if there is one */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (delim)", "      ++cmd;                    /* skip delimiter if there is one */", "    pat = cmd;                  /* remember start of pattern */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    if (delim)", "      ++cmd;                    /* skip delimiter if there is one */", "    pat = cmd;                  /* remember start of pattern */"], "readability/increment"]
["src/nvim/ex_cmds.c", ["      ++cmd;                    /* skip delimiter if there is one */", "    pat = cmd;                  /* remember start of pattern */", "    cmd = skip_regexp(cmd, delim, p_magic, &eap->arg);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    cmd = skip_regexp(cmd, delim, p_magic, &eap->arg);", "    if (cmd[0] == delim)                    /* end delimiter found */", "      *cmd++ = NUL;                         /* replace it with a NUL */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    cmd = skip_regexp(cmd, delim, p_magic, &eap->arg);", "    if (cmd[0] == delim)                    /* end delimiter found */", "      *cmd++ = NUL;                         /* replace it with a NUL */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (cmd[0] == delim)                    /* end delimiter found */", "      *cmd++ = NUL;                         /* replace it with a NUL */", "  }"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["{", "  sub_set_replacement((SubReplacementString) {NULL, 0, NULL});", "}"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["{", "  sub_set_replacement((SubReplacementString) {NULL, 0, NULL});", "}"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["", "/*", " * Set up for a tagpreview."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["bool", "prepare_tagpreview (", "    bool undo_sync                  /* sync undo when leaving the window */"], "whitespace/parens"]
["src/nvim/ex_cmds.c", ["prepare_tagpreview (", "    bool undo_sync                  /* sync undo when leaving the window */", ")"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["{", "  /*", "   * If there is already a preview window open, use that one."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    if (!found_win) {", "      /*", "       * There is no preview window open yet.  Create one."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["       */", "      if (win_split(g_do_tagpreview > 0 ? g_do_tagpreview : 0, 0)", "          == FAIL)"], "readability/braces"]
["src/nvim/ex_cmds.c", ["        return false;", "      curwin->w_p_pvw = TRUE;", "      curwin->w_p_wfh = TRUE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      curwin->w_p_pvw = TRUE;", "      curwin->w_p_wfh = TRUE;", "      RESET_BINDING(curwin);                /* don't take over 'scrollbind'"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      curwin->w_p_wfh = TRUE;", "      RESET_BINDING(curwin);                /* don't take over 'scrollbind'", "                                               and 'cursorbind' */"], "readability/multiline_comment"]
["src/nvim/ex_cmds.c", ["      curwin->w_p_wfh = TRUE;", "      RESET_BINDING(curwin);                /* don't take over 'scrollbind'", "                                               and 'cursorbind' */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":help\": open a read-only window on a help file"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  char_u      *tag;", "  FILE        *helpfd;          /* file descriptor of help file */", "  int n;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (eap != NULL) {", "    /*", "     * A \":help\" command ends at the first LF, or at a '|' that is"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["     */", "    for (arg = eap->arg; *arg; ++arg) {", "      if (*arg == '\\n' || *arg == '\\r'"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "    if (eap->skip)          /* not executing commands */", "      return;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "    if (eap->skip)          /* not executing commands */", "      return;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      return;", "  } else", "    arg = (char_u *)\"\";"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /* remove trailing blanks */", "  p = arg + STRLEN(arg) - 1;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  p = arg + STRLEN(arg) - 1;", "  while (p > arg && ascii_iswhite(*p) && p[-1] != '\\\\')", "    *p-- = NUL;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /* Check for a specified language */", "  lang = check_help_lang(arg);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /* When no argument given go to the index. */", "  if (*arg == NUL)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  /* When no argument given go to the index. */", "  if (*arg == NUL)", "    arg = (char_u *)\"help.txt\";"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Check if there is a match for the argument."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  n = find_help_tags(arg, &num_matches, &matches,", "      eap != NULL && eap->forceit);", ""], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["  i = 0;", "  if (n != FAIL && lang != NULL)", "    /* Find first item with the requested language. */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (n != FAIL && lang != NULL)", "    /* Find first item with the requested language. */", "    for (i = 0; i < num_matches; ++i) {"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    /* Find first item with the requested language. */", "    for (i = 0; i < num_matches; ++i) {", "      len = (int)STRLEN(matches[i]);"], "readability/increment"]
["src/nvim/ex_cmds.c", ["      len = (int)STRLEN(matches[i]);", "      if (len > 3 && matches[i][len - 3] == '@'", "          && STRICMP(matches[i] + len - 2, lang) == 0)"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (i >= num_matches || n == FAIL) {", "    if (lang != NULL)", "      EMSG3(_(\"E661: Sorry, no '%s' help for %s\"), lang, arg);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      EMSG3(_(\"E661: Sorry, no '%s' help for %s\"), lang, arg);", "    else", "      EMSG2(_(\"E149: Sorry, no help for %s\"), arg);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      EMSG2(_(\"E149: Sorry, no help for %s\"), arg);", "    if (n != FAIL)", "      FreeWild(num_matches, matches);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /* The first match (in the requested language) is the best match. */", "  tag = vim_strsave(matches[i]);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Re-use an existing help window or open a new one."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "      /* Split off help window; put it at far top if no position", "       * specified, the current window is vertically split and"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      n = WSP_HELP;", "      if (cmdmod.split == 0 && curwin->w_width != Columns", "          && curwin->w_width < 80)"], "readability/braces"]
["src/nvim/ex_cmds.c", ["        n |= WSP_TOP;", "      if (win_split(0, n) == FAIL)", "        goto erret;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "      if (curwin->w_height < p_hh)", "        win_setheight((int)p_hh);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "      /*", "       * Open help file (do_ecmd() will set b_help flag, readfile() will"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      (void)do_ecmd(0, NULL, NULL, NULL, ECMD_LASTL,", "          ECMD_HIDE + ECMD_SET_HELP,", "          NULL                  /* buffer is still open, don't store info */"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["          ECMD_HIDE + ECMD_SET_HELP,", "          NULL                  /* buffer is still open, don't store info */", "          );"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["          NULL                  /* buffer is still open, don't store info */", "          );", "      if (!cmdmod.keepalt)"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["          ECMD_HIDE + ECMD_SET_HELP,", "          NULL                  /* buffer is still open, don't store info */", "          );"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          NULL                  /* buffer is still open, don't store info */", "          );", "      if (!cmdmod.keepalt)"], "whitespace/parens"]
["src/nvim/ex_cmds.c", ["          );", "      if (!cmdmod.keepalt)", "        curwin->w_alt_fnum = alt_fnum;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  if (!p_im)", "    restart_edit = 0;               /* don't want insert mode in help file */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (!p_im)", "    restart_edit = 0;               /* don't want insert mode in help file */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /* Restore KeyTyped, setting 'filetype=help' may reset it.", "   * It is needed for do_tag top open folds under the cursor. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  do_tag(tag, DT_HELP, 1, FALSE, TRUE);", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /* Delete the empty buffer if we're not using it.  Careful: autocommands", "   * may have jumped to another window, check that the buffer is not in a"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    buf = buflist_findnr(empty_fnum);", "    if (buf != NULL && buf->b_nwindows == 0)", "      wipe_buffer(buf, TRUE);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (buf != NULL && buf->b_nwindows == 0)", "      wipe_buffer(buf, TRUE);", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /* keep the previous alternate file */", "  if (alt_fnum != 0 && curwin->w_alt_fnum == empty_fnum && !cmdmod.keepalt)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  /* keep the previous alternate file */", "  if (alt_fnum != 0 && curwin->w_alt_fnum == empty_fnum && !cmdmod.keepalt)", "    curwin->w_alt_fnum = alt_fnum;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "/*", " * In an argument search for a language specifiers in the form \"@xx\"."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      && ASCII_ISALPHA(arg[len - 1])) {", "    arg[len - 3] = NUL;                 /* remove the '@' */", "    return arg + len - 2;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * Return a heuristic indicating how well the given string matches.  The"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  num_letters = 0;", "  for (p = matched_string; *p; p++)", "    if (ASCII_ISALNUM(*p))"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  for (p = matched_string; *p; p++)", "    if (ASCII_ISALNUM(*p))", "      num_letters++;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Multiply the number of letters by 100 to give it a much bigger"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * Compare functions for qsort() below, that checks the help heuristics number"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      \"*\", \"g*\", \"[*\", \"]*\",", "      \"/*\", \"/\\\\*\", \"\\\"*\", \"**\",", "      \"/\\\\(\\\\)\", \"/\\\\%(\\\\)\","], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  if (i < 0) {  /* no match in table */", "    /* Replace \"\\S\" with \"/\\\\S\", etc.  Otherwise every tag is matched."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (i < 0) {  /* no match in table */", "    /* Replace \"\\S\" with \"/\\\\S\", etc.  Otherwise every tag is matched.", "     * Also replace \"\\%^\" and \"\\%(\", they match every tag too."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      STRCPY(d + 3, arg + 1);", "      /* Check for \"/\\\\_$\", should be \"/\\\\_\\$\" */", "      if (d[3] == '_' && d[4] == '$')"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      /* Check for \"/\\\\_$\", should be \"/\\\\_\\$\" */", "      if (d[3] == '_' && d[4] == '$')", "        STRCPY(d + 4, \"\\\\$\");"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    } else {", "      /* Replace:", "       * \"[:...:]\" with \"\\[:...:]\""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["       */", "      if ((arg[0] == '[' && (arg[1] == ':'", "                             || (arg[1] == '+' && arg[2] == '+')))"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "        /*", "         * Replace \"^x\" by \"CTRL-X\". Don't do this for \"^_\" to make"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["                                               || vim_strchr((char_u *)", "                                                   \"?@[\\\\]^\",", "                                                   s[1]) != NULL))) {"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                                                   \"?@[\\\\]^\",", "                                                   s[1]) != NULL))) {", "          if (d > IObuff && d[-1] != '_' && d[-1] != '\\\\')"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                                               || vim_strchr((char_u *)", "                                                   \"?@[\\\\]^\",", "                                                   s[1]) != NULL))) {"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                                                   \"?@[\\\\]^\",", "                                                   s[1]) != NULL))) {", "          if (d > IObuff && d[-1] != '_' && d[-1] != '\\\\')"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                                                   s[1]) != NULL))) {", "          if (d > IObuff && d[-1] != '_' && d[-1] != '\\\\')", "            *d++ = '_';                 /* prepend a '_' to make x_CTRL-x */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["          if (d > IObuff && d[-1] != '_' && d[-1] != '\\\\')", "            *d++ = '_';                 /* prepend a '_' to make x_CTRL-x */", "          STRCPY(d, \"CTRL-\");"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["            *d++ = *s + '@';", "            if (d[-1] == '\\\\')", "              *d++ = '\\\\';              /* double a backslash */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["            if (d[-1] == '\\\\')", "              *d++ = '\\\\';              /* double a backslash */", "          } else"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["              *d++ = '\\\\';              /* double a backslash */", "          } else", "            *d++ = *++s;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["            *d++ = *++s;", "          if (s[1] != NUL && s[1] != '_')", "            *d++ = '_';                 /* append a '_' */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["          if (s[1] != NUL && s[1] != '_')", "            *d++ = '_';                 /* append a '_' */", "          continue;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          continue;", "        } else if (*s == '^')           /* \"^\" or \"CTRL-^\" or \"^_\" */", "          *d++ = '\\\\';"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          continue;", "        } else if (*s == '^')           /* \"^\" or \"CTRL-^\" or \"^_\" */", "          *d++ = '\\\\';"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "        /*", "         * Insert a backslash before a backslash after a slash, for search"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["         */", "        else if (s[0] == '\\\\' && s[1] != '\\\\'", "                 && *arg == '/' && s == arg + 1)"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "        /* \"CTRL-\\_\" -> \"CTRL-\\\\_\" to avoid the special meaning of \"\\_\" in", "         * \"CTRL-\\_CTRL-N\" */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        if (d > IObuff + 2 && d[-1] == '`') {", "          /* remove the backticks from `command` */", "          memmove(IObuff, IObuff + 1, STRLEN(IObuff));"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        } else if (d > IObuff + 3 && d[-2] == '`' && d[-1] == ',') {", "          /* remove the backticks and comma from `command`, */", "          memmove(IObuff, IObuff + 1, STRLEN(IObuff));"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["                   && d[-2] == '\\\\' && d[-1] == '.') {", "          /* remove the backticks and dot from `command`\\. */", "          memmove(IObuff, IObuff + 1, STRLEN(IObuff));"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      && *num_matches > 0) {", "    /* Sort the matches found on the heuristic number that is after the", "     * tag name. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["     * tag name. */", "    qsort((void *)*matches, (size_t)*num_matches,", "        sizeof(char_u *), help_compare);"], "whitespace/operators"]
["src/nvim/ex_cmds.c", ["    qsort((void *)*matches, (size_t)*num_matches,", "        sizeof(char_u *), help_compare);", "    /* Delete more than TAG_MANY to reduce the size of the listing. */"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["        sizeof(char_u *), help_compare);", "    /* Delete more than TAG_MANY to reduce the size of the listing. */", "    while (*num_matches > TAG_MANY)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    /* Delete more than TAG_MANY to reduce the size of the listing. */", "    while (*num_matches > TAG_MANY)", "      xfree((*matches)[--*num_matches]);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    check_buf_options(curbuf);", "    (void)buf_init_chartab(curbuf, FALSE);", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curbuf->b_p_ts = 8;         // 'tabstop' is 8.", "  curwin->w_p_list = FALSE;   // No list mode.", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  curbuf->b_p_ma = FALSE;     // Not modifiable.", "  curbuf->b_p_bin = FALSE;    // Reset 'bin' before reading file."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curbuf->b_p_ma = FALSE;     // Not modifiable.", "  curbuf->b_p_bin = FALSE;    // Reset 'bin' before reading file.", "  curwin->w_p_nu = 0;         // No line numbers."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  RESET_BINDING(curwin);      // No scroll or cursor binding.", "  curwin->w_p_arab = FALSE;   // No arabic mode.", "  curwin->w_p_rl  = FALSE;    // Help window is left-to-right."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curwin->w_p_arab = FALSE;   // No arabic mode.", "  curwin->w_p_rl  = FALSE;    // Help window is left-to-right.", "  curwin->w_p_fen = FALSE;    // No folding in the help window."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curwin->w_p_rl  = FALSE;    // Help window is left-to-right.", "  curwin->w_p_fen = FALSE;    // No folding in the help window.", "  curwin->w_p_diff = FALSE;   // No 'diff'."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curwin->w_p_fen = FALSE;    // No folding in the help window.", "  curwin->w_p_diff = FALSE;   // No 'diff'.", "  curwin->w_p_spell = FALSE;  // No spell checking."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curwin->w_p_diff = FALSE;   // No 'diff'.", "  curwin->w_p_spell = FALSE;  // No spell checking.", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  set_buflisted(FALSE);", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "/*", " * After reading a help file: May cleanup a help buffer when syntax"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      if (in_example && len > 0 && !ascii_iswhite(line[0])) {", "        /* End of example: non-white or '<' in first column. */", "        if (line[0] == '<') {"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        if (line[0] == '<') {", "          /* blank-out a '<' in the first column */", "          line = ml_get_buf(curbuf, lnum, TRUE);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          /* blank-out a '<' in the first column */", "          line = ml_get_buf(curbuf, lnum, TRUE);", "          line[0] = ' ';"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        if (line[len - 1] == '>' && (len == 1 || line[len - 2] == ' ')) {", "          /* blank-out a '>' in the last column (start of example) */", "          line = ml_get_buf(curbuf, lnum, TRUE);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          /* blank-out a '>' in the last column (start of example) */", "          line = ml_get_buf(curbuf, lnum, TRUE);", "          line[len - 1] = ' ';"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        } else if (line[len - 1] == '~') {", "          /* blank-out a '~' at the end of line (header marker) */", "          line = ml_get_buf(curbuf, lnum, TRUE);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          /* blank-out a '~' at the end of line (header marker) */", "          line = ml_get_buf(curbuf, lnum, TRUE);", "          line[len - 1] = ' ';"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * In the \"help.txt\" and \"help.abx\" file, add the locally added help"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      ) {", "    for (lnum = 1; lnum < curbuf->b_ml.ml_line_count; ++lnum) {", "      line = ml_get_buf(curbuf, lnum, FALSE);"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    for (lnum = 1; lnum < curbuf->b_ml.ml_line_count; ++lnum) {", "      line = ml_get_buf(curbuf, lnum, FALSE);", "      if (strstr((char *)line, \"*local-additions*\") == NULL)"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      line = ml_get_buf(curbuf, lnum, FALSE);", "      if (strstr((char *)line, \"*local-additions*\") == NULL)", "        continue;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "      /* Go through all directories in 'runtimepath', skipping", "       * $VIMRUNTIME. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          if (!add_pathsep((char *)NameBuff)", "              || STRLCAT(NameBuff, \"doc/*.??[tx]\",", "                         sizeof(NameBuff)) >= MAXPATHL) {"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "          // Note: We cannot just do `&NameBuff` because it is a statically sized array", "          //       so `NameBuff == &NameBuff` according to C semantics."], "whitespace/line_length"]
["src/nvim/ex_cmds.c", ["          //       so `NameBuff == &NameBuff` according to C semantics.", "          char_u *buff_list[1] = {NameBuff};", "          if (gen_expand_wildcards(1, buff_list, &fcount,"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["          //       so `NameBuff == &NameBuff` according to C semantics.", "          char_u *buff_list[1] = {NameBuff};", "          if (gen_expand_wildcards(1, buff_list, &fcount,"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["          if (gen_expand_wildcards(1, buff_list, &fcount,", "                  &fnames, EW_FILE|EW_SILENT) == OK", "              && fcount > 0) {"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                while (*s != NUL) {", "                  if (*s == '\\r' || *s == '\\n')", "                    *s = NUL;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["                    *s = NUL;", "                  /* The text is utf-8 when a byte", "                   * above 127 is found and no"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["                  }", "                  ++s;", "                }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["                }", "                /* The help file is latin1 or utf-8;", "                 * conversion to the current"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":exusage\""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":viusage\""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  //       so `NameBuff == &NameBuff` according to C semantics.", "  char_u *buff_list[1] = {NameBuff};", "  if (gen_expand_wildcards(1, buff_list, &filecount, &files,"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["  //       so `NameBuff == &NameBuff` according to C semantics.", "  char_u *buff_list[1] = {NameBuff};", "  if (gen_expand_wildcards(1, buff_list, &filecount, &files,"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["  if (gen_expand_wildcards(1, buff_list, &filecount, &files,", "          EW_FILE|EW_SILENT) == FAIL", "      || filecount == 0) {"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["    s = xmalloc(18 + STRLEN(tagfname));", "    sprintf((char *)s, \"help-tags\\t%s\\t1\\n\", tagfname);", "    GA_APPEND(char_u *, &ga, s);"], "runtime/printf"]
["src/nvim/ex_cmds.c", ["          EMSG2(_(", "                  \"E670: Mix of help file encodings within a language: %s\"),", "              files[fi]);"], "whitespace/indent"]
["src/nvim/ex_cmds.c", ["                  \"E670: Mix of help file encodings within a language: %s\"),", "              files[fi]);", "          mix = !got_int;"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["          mix = !got_int;", "          got_int = TRUE;", "        }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["            *p2 = '\\0';", "            ++p1;", "            s = xmalloc((p2 - p1) + STRLEN(fname) + 2);"], "readability/increment"]
["src/nvim/ex_cmds.c", ["            GA_APPEND(char_u *, &ga, s);", "            sprintf((char *)s, \"%s\\t%s\", p1, fname);", ""], "runtime/printf"]
["src/nvim/ex_cmds.c", ["          vim_snprintf((char *)NameBuff, MAXPATHL,", "              _(\"E154: Duplicate tag \\\"%s\\\" in file %s/%s\"),", "              ((char_u **)ga.ga_data)[i], dir, p2 + 1);"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["              _(\"E154: Duplicate tag \\\"%s\\\" in file %s/%s\"),", "              ((char_u **)ga.ga_data)[i], dir, p2 + 1);", "          EMSG(NameBuff);"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["        }", "        ++p1;", "        ++p2;"], "readability/increment"]
["src/nvim/ex_cmds.c", ["        ++p1;", "        ++p2;", "      }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["  //       so `NameBuff == &NameBuff` according to C semantics.", "  char_u *buff_list[1] = {NameBuff};", "  if (gen_expand_wildcards(1, buff_list, &filecount, &files,"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["  //       so `NameBuff == &NameBuff` according to C semantics.", "  char_u *buff_list[1] = {NameBuff};", "  if (gen_expand_wildcards(1, buff_list, &filecount, &files,"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["", "  /* Go over all files in the directory to find out what languages are", "   * present. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    if (STRICMP(files[i] + len - 4, \".txt\") == 0) {", "      /* \".txt\" -> language \"en\" */", "      lang[0] = 'e';"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["               && TOLOWER_ASC(files[i][len - 1]) == 'x') {", "      /* \".abx\" -> language \"ab\" */", "      lang[0] = TOLOWER_ASC(files[i][len - 3]);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      lang[1] = TOLOWER_ASC(files[i][len - 2]);", "    } else", "      continue;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Loop over the found languages to generate a tags file for each one."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    if (fname[5] == 'e' && fname[6] == 'n') {", "      /* English is an exception: use \".txt\" and \"tags\". */", "      fname[4] = NUL;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    } else {", "      /* Language \"ab\" uses \".abx\" and \"tags-ab\". */", "      STRCPY(ext, \".xxx\");"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":helptags\""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /* Check for \":helptags ++t {dir}\". */", "  if (STRNCMP(eap->arg, \"++t\", 3) == 0 && ascii_iswhite(eap->arg[3])) {"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":helpclose\": Close one help window"], "readability/old_style_comment"]
["src/nvim/ex_cmds.h", ["", "/* for lnum argument in do_ecmd() */", "#define ECMD_LASTL      (linenr_T)0     /* use last position in loaded file */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.h", ["/* for lnum argument in do_ecmd() */", "#define ECMD_LASTL      (linenr_T)0     /* use last position in loaded file */", "#define ECMD_LAST       (linenr_T)-1    /* use last position in all files */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.h", ["#define ECMD_LASTL      (linenr_T)0     /* use last position in loaded file */", "#define ECMD_LAST       (linenr_T)-1    /* use last position in all files */", "#define ECMD_ONE        (linenr_T)1     /* use first line */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.h", ["#define ECMD_LAST       (linenr_T)-1    /* use last position in all files */", "#define ECMD_ONE        (linenr_T)1     /* use first line */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds_defs.h", ["", "/* behavior for bad character, \"++bad=\" argument */", "#define BAD_REPLACE     '?'     /* replace it with '?' (default) */"], "readability/old_style_comment"]
["src/nvim/ex_cmds_defs.h", ["/* behavior for bad character, \"++bad=\" argument */", "#define BAD_REPLACE     '?'     /* replace it with '?' (default) */", "#define BAD_KEEP        -1      /* leave it */"], "readability/old_style_comment"]
["src/nvim/ex_cmds_defs.h", ["#define BAD_REPLACE     '?'     /* replace it with '?' (default) */", "#define BAD_KEEP        -1      /* leave it */", "#define BAD_DROP        -2      /* erase it */"], "readability/old_style_comment"]
["src/nvim/ex_cmds_defs.h", ["#define BAD_KEEP        -1      /* leave it */", "#define BAD_DROP        -2      /* erase it */", ""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "#define UC_BUFFER       1       /* -buffer: local to current buffer */", ""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "static garray_T ucmds = {0, 0, sizeof(ucmd_T), 4, NULL};", ""], "whitespace/braces"]
["src/nvim/ex_docmd.c", ["", "static garray_T ucmds = {0, 0, sizeof(ucmd_T), 4, NULL};", ""], "whitespace/braces"]
["src/nvim/ex_docmd.c", ["", "/* Wether a command index indicates a user command. */", "# define IS_USER_CMDIDX(idx) ((int)(idx) < 0)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/* Struct for storing a line inside a while/for loop */", "typedef struct {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["typedef struct {", "  char_u      *line;            /* command line */", "  linenr_T lnum;                /* sourcing_lnum of the line */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  char_u      *line;            /* command line */", "  linenr_T lnum;                /* sourcing_lnum of the line */", "} wcmd_T;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Structure used to store info for line position in a while or for loop."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/* Struct to save a few things while debugging.  Used in do_cmdline() only. */", "struct dbg_stuff {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Declare cmdnames[]."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "static char_u dollar_command[2] = {'$', 0};", ""], "whitespace/braces"]
["src/nvim/ex_docmd.c", ["", "static char_u dollar_command[2] = {'$', 0};", ""], "whitespace/braces"]
["src/nvim/ex_docmd.c", ["{", "  dsp->trylevel       = trylevel;             trylevel = 0;", "  dsp->force_abort    = force_abort;          force_abort = FALSE;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  dsp->trylevel       = trylevel;             trylevel = 0;", "  dsp->force_abort    = force_abort;          force_abort = FALSE;", "  dsp->caught_stack   = caught_stack;         caught_stack = NULL;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  dsp->force_abort    = force_abort;          force_abort = FALSE;", "  dsp->caught_stack   = caught_stack;         caught_stack = NULL;", "  dsp->vv_exception   = v_exception(NULL);"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  // Necessary for debugging an inactive \":catch\", \":finally\", \":endtry\".", "  dsp->did_emsg       = did_emsg;             did_emsg     = false;", "  dsp->got_int        = got_int;              got_int      = false;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  dsp->did_emsg       = did_emsg;             did_emsg     = false;", "  dsp->got_int        = got_int;              got_int      = false;", "  dsp->need_rethrow   = need_rethrow;         need_rethrow = false;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  dsp->got_int        = got_int;              got_int      = false;", "  dsp->need_rethrow   = need_rethrow;         need_rethrow = false;", "  dsp->check_cstack   = check_cstack;         check_cstack = false;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  dsp->need_rethrow   = need_rethrow;         need_rethrow = false;", "  dsp->check_cstack   = check_cstack;         check_cstack = false;", "  dsp->current_exception = current_exception; current_exception = NULL;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  dsp->check_cstack   = check_cstack;         check_cstack = false;", "  dsp->current_exception = current_exception; current_exception = NULL;", "}"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["", "  if (improved)", "    exmode_active = EXMODE_VIM;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    exmode_active = EXMODE_VIM;", "  else", "    exmode_active = EXMODE_NORMAL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /* When using \":global /pat/ visual\" and then \"Q\" we return to continue", "   * the :global command. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["   * the :global command. */", "  if (global_busy)", "    return;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  while (exmode_active) {", "    /* Check for a \":normal\" command and no more characters left. */", "    if (ex_normal_busy > 0 && typebuf.tb_len == 0) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (ex_normal_busy > 0 && typebuf.tb_len == 0) {", "      exmode_active = FALSE;", "      break;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        if (ex_pressedreturn) {", "          /* go up one line, to overwrite the \":<CR>\" line, so the", "           * output doesn't contain empty lines. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["          msg_row = prev_msg_row;", "          if (prev_msg_row == Rows - 1)", "            msg_row--;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        msg_col = 0;", "        print_line_no_prefix(curwin->w_cursor.lnum, FALSE, FALSE);", "        msg_clr_eos();"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      }", "    } else if (ex_pressedreturn && !ex_no_reprint) {  /* must be at EOF */", "      if (curbuf->b_ml.ml_flags & ML_EMPTY)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    } else if (ex_pressedreturn && !ex_no_reprint) {  /* must be at EOF */", "      if (curbuf->b_ml.ml_flags & ML_EMPTY)", "        EMSG(_(e_emptybuf));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        EMSG(_(e_emptybuf));", "      else", "        EMSG(_(\"E501: At end-of-file\"));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Execute a simple command line.  Used for translated commands like \"*\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["int do_cmdline(char_u *cmdline, LineGetter fgetline,", "               void *cookie, /* argument for fgetline() */", "               int flags)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  char_u      *next_cmdline;            /* next cmd to execute */", "  char_u      *cmdline_copy = NULL;     /* copy of cmd line */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  char_u      *next_cmdline;            /* next cmd to execute */", "  char_u      *cmdline_copy = NULL;     /* copy of cmd line */", "  int used_getline = FALSE;             /* used \"fgetline\" to obtain command */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  char_u      *cmdline_copy = NULL;     /* copy of cmd line */", "  int used_getline = FALSE;             /* used \"fgetline\" to obtain command */", "  static int recursive = 0;             /* recursive depth */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  char_u      *cmdline_copy = NULL;     /* copy of cmd line */", "  int used_getline = FALSE;             /* used \"fgetline\" to obtain command */", "  static int recursive = 0;             /* recursive depth */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  int used_getline = FALSE;             /* used \"fgetline\" to obtain command */", "  static int recursive = 0;             /* recursive depth */", "  int msg_didout_before_start = 0;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  int msg_didout_before_start = 0;", "  int count = 0;                        /* line number count */", "  int did_inc = FALSE;                  /* incremented RedrawingDisabled */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  int count = 0;                        /* line number count */", "  int did_inc = FALSE;                  /* incremented RedrawingDisabled */", "  int retval = OK;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  int count = 0;                        /* line number count */", "  int did_inc = FALSE;                  /* incremented RedrawingDisabled */", "  int retval = OK;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  int getline_is_func;", "  static int call_depth = 0;            /* recursiveness */", ""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* For every pair of do_cmdline()/do_one_cmd() calls, use an extra memory", "   * location for storing error messages to be converted to an exception."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* Inside a function use a higher nesting level. */", "  getline_is_func = getline_equal(fgetline, cookie, get_func_line);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  getline_is_func = getline_equal(fgetline, cookie, get_func_line);", "  if (getline_is_func && ex_nesting_level == func_level(real_cookie))", "    ++ex_nesting_level;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  if (getline_is_func && ex_nesting_level == func_level(real_cookie))", "    ++ex_nesting_level;", ""], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  /* Get the function or script name and the address where the next breakpoint", "   * line and the debug tick for a function or script are stored. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Initialize \"force_abort\"  and \"suppress_errthrow\" at the top level."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Continue executing command lines:"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /* stop skipping cmds for an error msg after all endif/while/for */", "    if (next_cmdline == NULL"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    /* stop skipping cmds for an error msg after all endif/while/for */", "    if (next_cmdline == NULL", "        && !force_abort"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        )", "      did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * 1. If repeating a line in a loop, get a line from lines_ga."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /* 1. If repeating, get a previous line from lines_ga. */", "    if (cstack.cs_looplevel > 0 && current_line < lines_ga.ga_len) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (cstack.cs_looplevel > 0 && current_line < lines_ga.ga_len) {", "      /* Each '|' separated command is stored separately in lines_ga, to", "       * be able to jump to it.  Don't use next_cmdline now. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "      /* Check if a function has returned or, unless it has an unclosed", "       * try conditional, aborted. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      if (getline_is_func) {", "        if (do_profiling == PROF_YES)", "          func_line_end(real_cookie);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        }", "      } else if (do_profiling == PROF_YES", "                 && getline_equal(fgetline, cookie, getsourceline))"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "      /* Check if a sourced file hit a \":finish\" command. */", "      if (source_finished(fgetline, cookie)) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "      /* If breakpoints have been added/deleted need to check for it. */", "      if (breakpoint != NULL && dbg_tick != NULL"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "      /* Did we encounter a breakpoint? */", "      if (breakpoint != NULL && *breakpoint != 0"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        dbg_breakpoint(fname, sourcing_lnum);", "        /* Find next breakpoint. */", "        *breakpoint = dbg_find_breakpoint("], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      if (do_profiling == PROF_YES) {", "        if (getline_is_func)", "          func_line_start(real_cookie);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          func_line_start(real_cookie);", "        else if (getline_equal(fgetline, cookie, getsourceline))", "          script_line_start();"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (cstack.cs_looplevel > 0) {", "      /* Inside a while/for loop we need to store the lines and use them", "       * again.  Pass a different \"fgetline\" function to do_one_cmd()"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /* 2. If no line given, get an allocated line with fgetline(). */", "    if (next_cmdline == NULL) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (next_cmdline == NULL) {", "      /*", "       * Need to set msg_didout for the first line after an \":if\","], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      }", "      used_getline = TRUE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "      /*", "       * Keep the first typed line.  Clear it when more lines are typed."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        xfree(repeat_cmdline);", "        if (count == 0)", "          repeat_cmdline = vim_strsave(next_cmdline);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          repeat_cmdline = vim_strsave(next_cmdline);", "        else", "          repeat_cmdline = NULL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    }", "    /* 3. Make a copy of the command so we can mess with it. */", "    else if (cmdline_copy == NULL) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    /* 3. Make a copy of the command so we can mess with it. */", "    else if (cmdline_copy == NULL) {", "      next_cmdline = vim_strsave(next_cmdline);"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * Save the current line when inside a \":while\" or \":for\", and when"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    }", "    did_endif = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["    if (count++ == 0) {", "      /*", "       * All output from the commands is put below each other, without"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        msg_didout_before_start = msg_didout;", "        msg_didany = FALSE;         /* no output yet */", "        msg_start();"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        msg_didout_before_start = msg_didout;", "        msg_didany = FALSE;         /* no output yet */", "        msg_start();"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        msg_start();", "        msg_scroll = TRUE;          /* put messages below each other */", "        ++no_wait_return;           /* don't wait for return until finished */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        msg_start();", "        msg_scroll = TRUE;          /* put messages below each other */", "        ++no_wait_return;           /* don't wait for return until finished */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        msg_scroll = TRUE;          /* put messages below each other */", "        ++no_wait_return;           /* don't wait for return until finished */", "        ++RedrawingDisabled;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        msg_scroll = TRUE;          /* put messages below each other */", "        ++no_wait_return;           /* don't wait for return until finished */", "        ++RedrawingDisabled;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        ++no_wait_return;           /* don't wait for return until finished */", "        ++RedrawingDisabled;", "        did_inc = TRUE;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        ++RedrawingDisabled;", "        did_inc = TRUE;", "      }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * 2. Execute one '|' separated command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    if (cmd_cookie == (void *)&cmd_loop_cookie)", "      /* Use \"current_line\" from \"cmd_loop_cookie\", it may have been"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (cmd_cookie == (void *)&cmd_loop_cookie)", "      /* Use \"current_line\" from \"cmd_loop_cookie\", it may have been", "       * incremented when defining a function. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    } else {", "      /* need to copy the command after the '|' to cmdline_copy, for the", "       * next do_one_cmd() */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /* reset did_emsg for a function that is not aborted by an error */", "    if (did_emsg && !force_abort"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    /* reset did_emsg for a function that is not aborted by an error */", "    if (did_emsg && !force_abort", "        && getline_equal(fgetline, cookie, get_func_line)"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        && !func_has_abort(real_cookie))", "      did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["    if (cstack.cs_looplevel > 0) {", "      ++current_line;", ""], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "      /*", "       * An \":endwhile\", \":endfor\" and \":continue\" is handled here."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "        /* Jump back to the matching \":while\" or \":for\".  Be careful", "         * not to use a cs_line[] from an entry that isn't a \":while\""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["          current_line = cstack.cs_line[cstack.cs_idx];", "          /* remember we jumped there */", "          cstack.cs_lflags |= CSL_HAD_LOOP;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["          cstack.cs_lflags |= CSL_HAD_LOOP;", "          line_breakcheck();                    /* check if CTRL-C typed */", ""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "          /* Check for the next breakpoint at or after the \":while\"", "           * or \":for\". */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        } else {", "          /* can only get here with \":endwhile\" or \":endfor\" */", "          if (cstack.cs_idx >= 0)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["          /* can only get here with \":endwhile\" or \":endfor\" */", "          if (cstack.cs_idx >= 0)", "            rewind_conditionals(&cstack, cstack.cs_idx - 1,"], "readability/braces"]
["src/nvim/ex_docmd.c", ["            rewind_conditionals(&cstack, cstack.cs_idx - 1,", "                CSF_WHILE | CSF_FOR, &cstack.cs_looplevel);", "        }"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["      }", "      /*", "       * For a \":while\" or \":for\" we need to remember the line number."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["       */", "      else if (cstack.cs_lflags & CSL_HAD_LOOP) {", "        cstack.cs_lflags &= ~CSL_HAD_LOOP;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * When not inside any \":while\" loop, clear remembered lines."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * A \":finally\" makes did_emsg, got_int and current_exception pending for"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /* Update global \"trylevel\" for recursive calls to do_cmdline() from", "     * within this loop. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /* Convert an interrupt to an exception if appropriate. */", "    (void)do_intthrow(&cstack);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    (void)do_intthrow(&cstack);", "", "  }"], "whitespace/blank_line"]
["src/nvim/ex_docmd.c", ["  }", "  /*", "   * Continue executing command lines when:"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["   */", "  while (!((got_int || (did_emsg && force_abort) || current_exception)", "           && cstack.cs_trylevel == 0)"], "readability/braces"]
["src/nvim/ex_docmd.c", ["             || cstack.cs_idx >= 0", "             || (flags & DOCMD_REPEAT)));", ""], "whitespace/empty_loop_body"]
["src/nvim/ex_docmd.c", ["         && !(did_emsg", "              /* Keep going when inside try/catch, so that the error can be", "               * deal with, except when it is a syntax error, it may cause"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  xfree(cmdline_copy);", "  did_emsg_syntax = FALSE;", "  GA_DEEP_CLEAR(&lines_ga, wcmd_T, FREE_WCMD);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  if (cstack.cs_idx >= 0) {", "    /*", "     * If a sourced file or executed function ran to its end, report the"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["                && !func_has_ended(real_cookie)))) {", "      if (cstack.cs_flags[cstack.cs_idx] & CSF_TRY)", "        EMSG(_(e_endtry));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        EMSG(_(e_endtry));", "      else if (cstack.cs_flags[cstack.cs_idx] & CSF_WHILE)", "        EMSG(_(e_endwhile));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        EMSG(_(e_endwhile));", "      else if (cstack.cs_flags[cstack.cs_idx] & CSF_FOR)", "        EMSG(_(e_endfor));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        EMSG(_(e_endfor));", "      else", "        EMSG(_(e_endif));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * Reset \"trylevel\" in case of a \":finish\" or \":return\" or a missing"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    do {", "      int idx = cleanup_conditionals(&cstack, 0, TRUE);", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "      if (idx >= 0)", "        --idx;              /* remove try block not in its finally clause */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      if (idx >= 0)", "        --idx;              /* remove try block not in its finally clause */", "      rewind_conditionals(&cstack, idx, CSF_WHILE | CSF_FOR,"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      if (idx >= 0)", "        --idx;              /* remove try block not in its finally clause */", "      rewind_conditionals(&cstack, idx, CSF_WHILE | CSF_FOR,"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      rewind_conditionals(&cstack, idx, CSF_WHILE | CSF_FOR,", "          &cstack.cs_looplevel);", "    } while (cstack.cs_idx >= 0);"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["", "  /* If a missing \":endtry\", \":endwhile\", \":endfor\", or \":endif\" or a memory", "   * lack was reported above and the error message is to be converted to an"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  do_errthrow(&cstack, getline_equal(fgetline, cookie, get_func_line)", "      ? (char_u *)\"endfunction\" : (char_u *)NULL);", ""], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["", "      /*", "       * If the uncaught exception is a user exception, report it as an"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        vim_snprintf((char *)IObuff, IOSIZE,", "            _(\"E605: Exception not caught: %s\"),", "            current_exception->value);"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["            _(\"E605: Exception not caught: %s\"),", "            current_exception->value);", "        p = vim_strsave(IObuff);"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["  } else {", "    /* When leaving a function, reduce nesting level. */", "    if (getline_equal(fgetline, cookie, get_func_line))"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    /* When leaving a function, reduce nesting level. */", "    if (getline_equal(fgetline, cookie, get_func_line))", "      --ex_nesting_level;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (getline_equal(fgetline, cookie, get_func_line))", "      --ex_nesting_level;", "    /*"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      --ex_nesting_level;", "    /*", "     * Go to debug mode when returning from a function in which we are"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["     */", "    if ((getline_equal(fgetline, cookie, getsourceline)", "         || getline_equal(fgetline, cookie, get_func_line))"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      do_debug(getline_equal(fgetline, cookie, getsourceline)", "          ? (char_u *)_(\"End of sourced file\")", "          : (char_u *)_(\"End of function\"));"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["          ? (char_u *)_(\"End of sourced file\")", "          : (char_u *)_(\"End of function\"));", "  }"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Restore the exception environment (done after returning from the"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["   */", "  if (flags & DOCMD_EXCRESET)", "    restore_dbg_stuff(&debug_saved);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * If there was too much output to fit on the command line, ask the user to"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (did_inc) {", "    --RedrawingDisabled;", "    --no_wait_return;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    --RedrawingDisabled;", "    --no_wait_return;", "    msg_scroll = FALSE;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    --no_wait_return;", "    msg_scroll = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * When just finished an \":if\"-\":else\" which was typed, no need to"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        ) {", "      need_wait_return = FALSE;", "      msg_didany = FALSE;               /* don't wait when restarting edit */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      need_wait_return = FALSE;", "      msg_didany = FALSE;               /* don't wait when restarting edit */", "    } else if (need_wait_return) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      need_wait_return = FALSE;", "      msg_didany = FALSE;               /* don't wait when restarting edit */", "    } else if (need_wait_return) {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    } else if (need_wait_return) {", "      /*", "       * The msg_start() above clears msg_didout. The wait_return we do"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      msg_didout |= msg_didout_before_start;", "      wait_return(FALSE);", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  did_endif = FALSE;    /* in case do_cmdline used recursively */", ""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  did_endif = FALSE;    /* in case do_cmdline used recursively */", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * Obtain a line when inside a \":while\" or \":for\" loop."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (cp->current_line + 1 >= cp->lines_gap->ga_len) {", "    if (cp->repeating)", "      return NULL;              /* trying to read past \":endwhile\"/\":endfor\" */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (cp->repeating)", "      return NULL;              /* trying to read past \":endwhile\"/\":endfor\" */", ""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      store_loop_line(cp->lines_gap, line);", "      ++cp->current_line;", "    }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Store a line in \"gap\" so that a \":while\" loop can execute it again."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * If \"fgetline\" is get_loop_line(), return TRUE if the getline it uses equals"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["int getline_equal(LineGetter fgetline,", "                  void *cookie, /* argument for fgetline() */", "                  LineGetter func)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* When \"fgetline\" is \"get_loop_line()\" use the \"cookie\" to find the", "   * function that's originally used to obtain the lines.  This may be"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * If \"fgetline\" is get_loop_line(), return the cookie used by the original"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["void * getline_cookie(LineGetter fgetline,", "                      void *cookie /* argument for fgetline() */", "                      )"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* When \"fgetline\" is \"get_loop_line()\" use the \"cookie\" to find the", "   * cookie that's originally used to obtain the lines.  This may be nested"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Helper function to apply an offset for buffer commands, i.e. \":bdelete\","], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  buf = firstbuf;", "  while (buf->b_next != NULL && buf->b_fnum < lnum)", "    buf = buf->b_next;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    nextbuf = (offset < 0) ? buf->b_prev : buf->b_next;", "    if (nextbuf == NULL)", "      break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    buf = nextbuf;", "    if (addr_type == ADDR_LOADED_BUFFERS)", "      /* skip over unloaded buffers */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (addr_type == ADDR_LOADED_BUFFERS)", "      /* skip over unloaded buffers */", "      while (buf->b_ml.ml_mfp == NULL) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      nextbuf = (offset >= 0) ? buf->b_prev : buf->b_next;", "      if (nextbuf == NULL)", "        break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {", "    ++nr;", "    if (wp == win)"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    ++nr;", "    if (wp == win)", "      break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  FOR_ALL_TABS(tp) {", "    ++nr;", "    if (tp == tab)"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    ++nr;", "    if (tp == tab)", "      break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Execute one Ex command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["                           LineGetter fgetline,", "                           void *cookie /* argument for fgetline() */", "                           )"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* When the last file has not been edited :q has to be typed twice. */", "  if (quitmore"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  /* When the last file has not been edited :q has to be typed twice. */", "  if (quitmore", "      /* avoid that a function call in 'statusline' does this */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  if (quitmore", "      /* avoid that a function call in 'statusline' does this */", "      && !getline_equal(fgetline, cookie, get_func_line)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      && !getline_equal(fgetline, cookie, get_func_line)", "      /* avoid that an autocommand, e.g. QuitPre, does this */", "      && !getline_equal(fgetline, cookie, getnextac)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      )", "    --quitmore;", ""], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Reset browse, confirm, etc..  They are restored when returning, for"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (!ea.skip && got_int) {", "    ea.skip = TRUE;", "    (void)do_intthrow(cstack);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * 5. Parse the command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Skip ':' and any white space"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * If we got a line, but no command, then go to the line."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "      if (ea.line2 < 0)", "        errormsg = (char_u *)_(e_invrange);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        errormsg = (char_u *)_(e_invrange);", "      else {", "        if (ea.line2 == 0)"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        errormsg = (char_u *)_(e_invrange);", "      else {", "        if (ea.line2 == 0)"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      else {", "        if (ea.line2 == 0)", "          curwin->w_cursor.lnum = 1;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          curwin->w_cursor.lnum = 1;", "        else", "          curwin->w_cursor.lnum = ea.line2;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    while (ASCII_ISALNUM(*p)) {", "      ++p;", "    }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    p = vim_strnsave(ea.cmd, p - ea.cmd);", "    int ret = apply_autocmds(EVENT_CMDUNDEFINED, p, p, TRUE, NULL);", "    xfree(p);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  if (p == NULL) {", "    if (!ea.skip)", "      errormsg = (char_u *)_(\"E464: Ambiguous use of user-defined command\");"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      errormsg = IObuff;", "      did_emsg_syntax = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        && (!curbuf->terminal || ea.cmdidx != CMD_put)) {", "      /* Command not allowed in non-'modifiable' buffer */", "      errormsg = (char_u *)_(e_modifiable);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Don't complain about the range if it is not used"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    }", "    if ((errormsg = invalid_range(&ea)) != NULL)", "      goto doend;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * For the \":make\" and \":grep\" commands we insert the 'makeprg'/'grepprg'"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  p = replace_makeprg(&ea, p, cmdlinep);", "  if (p == NULL)", "    goto doend;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Skip to start of argument."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["   */", "  if (ea.cmdidx == CMD_bang)", "    ea.arg = p;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    ea.arg = p;", "  else", "    ea.arg = skipwhite(p);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Check for \"++opt=val\" argument."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (ea.cmdidx == CMD_write || ea.cmdidx == CMD_update) {", "    if (*ea.arg == '>') {                       /* append */", "      if (*++ea.arg != '>') {                   /* typed wrong */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (*ea.arg == '>') {                       /* append */", "      if (*++ea.arg != '>') {                   /* typed wrong */", "        errormsg = (char_u *)_(\"E494: Use w or w>>\");"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      ea.arg = skipwhite(ea.arg + 1);", "      ea.append = TRUE;", "    } else if (*ea.arg == '!' && ea.cmdidx == CMD_write) { /* :w !filter */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      ea.append = TRUE;", "    } else if (*ea.arg == '!' && ea.cmdidx == CMD_write) { /* :w !filter */", "      ++ea.arg;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    } else if (*ea.arg == '!' && ea.cmdidx == CMD_write) { /* :w !filter */", "      ++ea.arg;", "      ea.usefilter = TRUE;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      ++ea.arg;", "      ea.usefilter = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    if (ea.forceit) {", "      ea.usefilter = TRUE;                      /* :r! filter if ea.forceit */", "      ea.forceit = FALSE;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (ea.forceit) {", "      ea.usefilter = TRUE;                      /* :r! filter if ea.forceit */", "      ea.forceit = FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      ea.usefilter = TRUE;                      /* :r! filter if ea.forceit */", "      ea.forceit = FALSE;", "    } else if (*ea.arg == '!') {              /* :r !filter */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      ea.forceit = FALSE;", "    } else if (*ea.arg == '!') {              /* :r !filter */", "      ++ea.arg;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    } else if (*ea.arg == '!') {              /* :r !filter */", "      ++ea.arg;", "      ea.usefilter = TRUE;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      ++ea.arg;", "      ea.usefilter = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    ea.amount = 1;", "    while (*ea.arg == *ea.cmd) {                /* count number of '>' or '<' */", "      ++ea.arg;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    while (*ea.arg == *ea.cmd) {                /* count number of '>' or '<' */", "      ++ea.arg;", "      ++ea.amount;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      ++ea.arg;", "      ++ea.amount;", "    }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Check for \"+command\" argument, before checking for next command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Check for '|' to separate commands and '\"' to start comments."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      && *ea.arg != NUL", "      /* Do not allow register = for user commands */", "      && (!IS_USER_CMDIDX(ea.cmdidx) || *ea.arg != '=')"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      ea.regname = *ea.arg++;", "      /* for '=' register: accept the rest of the line as an expression */", "      if (ea.arg[-1] == '=' && ea.arg[0] != NUL) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      ea.line2 = n;", "      if (ea.addr_count == 0)", "        ea.addr_count = 1;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      ea.line2 += n - 1;", "      ++ea.addr_count;", "      // Be vi compatible: no error message for out of range."], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Check for flags: 'l', 'p' and '#'."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Skip the command when it's not going to be executed."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    switch (ea.cmdidx) {", "    /* commands that need evaluation */", "    case CMD_while:"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Accept buffer name.  Cannot be used at the same time with a buffer"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      ) {", "    /*", "     * :bdelete, :bwipeout and :bunload take several arguments, separated"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["     */", "    if (ea.cmdidx == CMD_bdelete || ea.cmdidx == CMD_bwipeout", "        || ea.cmdidx == CMD_bunload)"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      p = skiptowhite_esc(ea.arg);", "    else {", "      p = ea.arg + STRLEN(ea.arg);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      p = skiptowhite_esc(ea.arg);", "    else {", "      p = ea.arg + STRLEN(ea.arg);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      p = ea.arg + STRLEN(ea.arg);", "      while (p > ea.arg && ascii_iswhite(p[-1]))", "        --p;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      while (p > ea.arg && ascii_iswhite(p[-1]))", "        --p;", "    }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  if (IS_USER_CMDIDX(ea.cmdidx)) {", "    /*", "     * Execute a user-defined command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  } else {", "    /*", "     * Call the function to execute the command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    (cmdnames[ea.cmdidx].cmd_func)(&ea);", "    if (ea.errmsg != NULL)", "      errormsg = (char_u *)_(ea.errmsg);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * If the command just executed called do_cmdline(), any throw or \":return\""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["   */", "  if (need_rethrow)", "    do_throw(cstack);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    do_throw(cstack);", "  else if (check_cstack) {", "    if (source_finished(fgetline, cookie))"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  else if (check_cstack) {", "    if (source_finished(fgetline, cookie))", "      do_finish(&ea, TRUE);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (source_finished(fgetline, cookie))", "      do_finish(&ea, TRUE);", "    else if (getline_equal(fgetline, cookie, get_func_line)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      do_finish(&ea, TRUE);", "    else if (getline_equal(fgetline, cookie, get_func_line)", "             && current_func_returned())"], "readability/braces"]
["src/nvim/ex_docmd.c", ["             && current_func_returned())", "      do_return(&ea, TRUE, FALSE, NULL);", "  }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  }", "  need_rethrow = check_cstack = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["  do_errthrow(cstack,", "      (ea.cmdidx != CMD_SIZE && !IS_USER_CMDIDX(ea.cmdidx))", "      ? cmdnames[(int)ea.cmdidx].cmd_name"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["      (ea.cmdidx != CMD_SIZE && !IS_USER_CMDIDX(ea.cmdidx))", "      ? cmdnames[(int)ea.cmdidx].cmd_name", "      : (char_u *)NULL);"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["      ? cmdnames[(int)ea.cmdidx].cmd_name", "      : (char_u *)NULL);", ""], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["", "  if (ea.nextcmd && *ea.nextcmd == NUL)         /* not really a next command */", "    ea.nextcmd = NULL;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  if (ea.nextcmd && *ea.nextcmd == NUL)         /* not really a next command */", "    ea.nextcmd = NULL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  --ex_nesting_level;", ""], "readability/increment"]
["src/nvim/ex_docmd.c", ["  return ea.nextcmd;", "}", ""], "readability/fn_size"]
["src/nvim/ex_docmd.c", ["    }", "      if (!checkforcmd(&p, \"verbose\", 4))", "        break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Check for an Ex command with optional tail."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  for (i = 0; cmd[i] != NUL; ++i)", "    if (((char_u *)cmd)[i] != (*pp)[i])"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  for (i = 0; cmd[i] != NUL; ++i)", "    if (((char_u *)cmd)[i] != (*pp)[i])"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  for (i = 0; cmd[i] != NUL; ++i)", "    if (((char_u *)cmd)[i] != (*pp)[i])", "      break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    *pp = skipwhite(*pp + i);", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * Append \"cmd\" to the error message in IObuff."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      d += 4;", "    } else", "      MB_COPY_CHAR(s, d);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Isolate the command and search for it in the command table."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    eap->cmdidx = CMD_k;", "    ++p;", "  } else if (p[0] == 's'"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    eap->cmdidx = CMD_substitute;", "    ++p;", "  } else {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  } else {", "    while (ASCII_ISALPHA(*p))", "      ++p;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    while (ASCII_ISALPHA(*p))", "      ++p;", "    /* for python 3.x support \":py3\", \":python3\", \":py3file\", etc. */"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      ++p;", "    /* for python 3.x support \":py3\", \":python3\", \":py3file\", etc. */", "    if (eap->cmd[0] == 'p' && eap->cmd[1] == 'y')"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    /* for python 3.x support \":py3\", \":python3\", \":py3file\", etc. */", "    if (eap->cmd[0] == 'p' && eap->cmd[1] == 'y')", "      while (ASCII_ISALNUM(*p))"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (eap->cmd[0] == 'p' && eap->cmd[1] == 'y')", "      while (ASCII_ISALNUM(*p))", "        ++p;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      while (ASCII_ISALNUM(*p))", "        ++p;", ""], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "    /* check for non-alpha command */", "    if (p == eap->cmd && vim_strchr((char_u *)\"@!=><&~#\", *p) != NULL)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    /* check for non-alpha command */", "    if (p == eap->cmd && vim_strchr((char_u *)\"@!=><&~#\", *p) != NULL)", "      ++p;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (p == eap->cmd && vim_strchr((char_u *)\"@!=><&~#\", *p) != NULL)", "      ++p;", "    len = (int)(p - eap->cmd);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    if (*eap->cmd == 'd' && (p[-1] == 'l' || p[-1] == 'p')) {", "      /* Check for \":dl\", \":dell\", etc. to \":deletel\": that's", "       * :delete with the 'l' flag.  Same for 'p'. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["       * :delete with the 'l' flag.  Same for 'p'. */", "      for (i = 0; i < len; ++i)", "        if (eap->cmd[i] != ((char_u *)\"delete\")[i])"], "readability/braces"]
["src/nvim/ex_docmd.c", ["       * :delete with the 'l' flag.  Same for 'p'. */", "      for (i = 0; i < len; ++i)", "        if (eap->cmd[i] != ((char_u *)\"delete\")[i])"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      for (i = 0; i < len; ++i)", "        if (eap->cmd[i] != ((char_u *)\"delete\")[i])", "          break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      if (i == len - 1) {", "        --len;", "        if (p[-1] == 'l')"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        --len;", "        if (p[-1] == 'l')", "          eap->flags |= EXFLAG_LIST;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          eap->flags |= EXFLAG_LIST;", "        else", "          eap->flags |= EXFLAG_PRINT;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "    for (; (int)eap->cmdidx < (int)CMD_SIZE;", "         eap->cmdidx = (cmdidx_T)((int)eap->cmdidx + 1))"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      if (STRNCMP(cmdnames[(int)eap->cmdidx].cmd_name, (char *)eap->cmd,", "              (size_t)len) == 0) {", "        if (full != NULL"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["              (size_t)len) == 0) {", "        if (full != NULL", "            && cmdnames[(int)eap->cmdidx].cmd_name[len] == NUL)"], "readability/braces"]
["src/nvim/ex_docmd.c", ["            && cmdnames[(int)eap->cmdidx].cmd_name[len] == NUL)", "          *full = TRUE;", "        break;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        && *eap->cmd >= 'A' && *eap->cmd <= 'Z') {", "      /* User defined commands may contain digits. */", "      while (ASCII_ISALNUM(*p))"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      /* User defined commands may contain digits. */", "      while (ASCII_ISALNUM(*p))", "        ++p;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      while (ASCII_ISALNUM(*p))", "        ++p;", "      p = find_ucmd(eap, p, full, NULL, NULL);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    }", "    if (p == eap->cmd)", "      eap->cmdidx = CMD_SIZE;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Search for a user command that matches \"eap->cmd\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["static char_u *", "find_ucmd (", "    exarg_T *eap,"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["  ucmd_T      *uc;", "  int found = FALSE;", "  int possible = FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  int found = FALSE;", "  int possible = FALSE;", "  char_u      *cp, *np;             /* Point into typed cmd and test name */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  int possible = FALSE;", "  char_u      *cp, *np;             /* Point into typed cmd and test name */", "  garray_T    *gap;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  garray_T    *gap;", "  int amb_local = FALSE;            /* Found ambiguous buffer-local command,", "                                       only full match global is accepted. */"], "readability/multiline_comment"]
["src/nvim/ex_docmd.c", ["  garray_T    *gap;", "  int amb_local = FALSE;            /* Found ambiguous buffer-local command,", "                                       only full match global is accepted. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  garray_T    *gap;", "  int amb_local = FALSE;            /* Found ambiguous buffer-local command,", "                                       only full match global is accepted. */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Look for buffer-local user commands first, then global ones."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  for (;; ) {", "    for (j = 0; j < gap->ga_len; ++j) {", "      uc = USER_CMD_GA(gap, j);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      k = 0;", "      while (k < len && *np != NUL && *cp++ == *np++)", "        k++;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      if (k == len || (*np == NUL && ascii_isdigit(eap->cmd[k]))) {", "        /* If finding a second match, the command is ambiguous.  But", "         * not if a buffer-local command wasn't a full match and a"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        if (k == len && found && *np != NUL) {", "          if (gap == &ucmds)", "            return NULL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["            return NULL;", "          amb_local = TRUE;", "        }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        if (!found || (k == len && *np == NUL)) {", "          /* If we matched up to a digit, then there could", "           * be another command including the digit that we"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["           */", "          if (k == len)", "            found = TRUE;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          if (k == len)", "            found = TRUE;", "          else"], "readability/bool"]
["src/nvim/ex_docmd.c", ["            found = TRUE;", "          else", "            possible = TRUE;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          else", "            possible = TRUE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "          if (gap == &ucmds)", "            eap->cmdidx = CMD_USER;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["            eap->cmdidx = CMD_USER;", "          else", "            eap->cmdidx = CMD_USER_BUF;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          }", "          /* Do not search for further abbreviations", "           * if this is an exact match. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["          if (k == len && *np == NUL) {", "            if (full != NULL)", "              *full = TRUE;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["            if (full != NULL)", "              *full = TRUE;", "            amb_local = FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["              *full = TRUE;", "            amb_local = FALSE;", "            break;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "    /* Stop if we found a full match or searched all. */", "    if (j < gap->ga_len || gap == &ucmds)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    /* Stop if we found a full match or searched all. */", "    if (j < gap->ga_len || gap == &ucmds)", "      break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /* Only found ambiguous matches. */", "  if (amb_local) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (amb_local) {", "    if (xp != NULL)", "      xp->xp_context = EXPAND_UNSUCCESSFUL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /* The match we found may be followed immediately by a number.  Move \"p\"", "   * back to point to it. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["   * back to point to it. */", "  if (found || possible)", "    return p + (matchlen - len);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  int minlen;", "  int has_count;            /* :123verbose  :3tab */", "} cmdmods[] = {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Return length of a command modifier (including optional count)."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  if (ascii_isdigit(*cmd))", "    p = skipwhite(skipdigits(cmd));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    p = skipwhite(skipdigits(cmd));", "  for (i = 0; i < (int)ARRAY_SIZE(cmdmods); ++i) {", "    for (j = 0; p[j] != NUL; ++j)"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  for (i = 0; i < (int)ARRAY_SIZE(cmdmods); ++i) {", "    for (j = 0; p[j] != NUL; ++j)", "      if (p[j] != cmdmods[i].name[j])"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  for (i = 0; i < (int)ARRAY_SIZE(cmdmods); ++i) {", "    for (j = 0; p[j] != NUL; ++j)", "      if (p[j] != cmdmods[i].name[j])"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    for (j = 0; p[j] != NUL; ++j)", "      if (p[j] != cmdmods[i].name[j])", "        break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Return > 0 if an Ex command \"name\" exists."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* Check built-in commands and user defined commands.", "   * For \":2match\" and \":3match\" we need to skip the number. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  p = find_command(&ea, &full);", "  if (p == NULL)", "    return 3;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    return 3;", "  if (ascii_isdigit(*name) && ea.cmdidx != CMD_match)", "    return 0;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    return 0;", "  if (*skipwhite(p) != NUL)", "    return 0;           /* trailing garbage */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  if (*skipwhite(p) != NUL)", "    return 0;           /* trailing garbage */", "  return ea.cmdidx == CMD_SIZE ? 0 : (full ? 2 : 1);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * This is all pretty much copied from do_one_cmd(), with all the extra stuff"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  if (*cmd == NUL)", "    return NULL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    return NULL;", "  if (*cmd == '\"') {        /* ignore comment lines */", "    xp->xp_context = EXPAND_NOTHING;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * 3. parse a range specifier of the form: addr [,addr] [;addr] .."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * 4. parse command"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  if (*cmd == '|' || *cmd == '\\n')", "    return cmd + 1;                     /* There's another command */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  if (*cmd == '|' || *cmd == '\\n')", "    return cmd + 1;                     /* There's another command */", ""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Isolate the command and search for it in the command table."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * If the cursor is touching the command, and it ends in an alpha-numeric"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["   */", "  if (*p == NUL && ASCII_ISALNUM(p[-1]))", "    return NULL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  if (ea.cmdidx == CMD_SIZE) {", "    /* Not still touching the command and it was an illegal one */", "    xp->xp_context = EXPAND_UNSUCCESSFUL;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  xp->xp_context = EXPAND_NOTHING;   /* Default now that we're past command */", ""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * 5. parse arguments"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Check for '|' to separate commands and '\"' to start comments."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    p = arg;", "    /* \":redir @\" is not the start of a comment */", "    if (ea.cmdidx == CMD_redir && p[0] == '@' && p[1] == '\"')"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    /* \":redir @\" is not the start of a comment */", "    if (ea.cmdidx == CMD_redir && p[0] == '@' && p[1] == '\"')", "      p += 2;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        if (*(p - 1) != '\\\\') {", "          if (*p == '|' || *p == '\\n')", "            return p + 1;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["            return p + 1;", "          return NULL;              /* It's a comment */", "        }"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* Find start of last argument (argument just before cursor): */", "  p = buff;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * Allow spaces within back-quotes to count as part of the argument"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      }", "      /* An argument can contain just about everything, except", "       * characters that end the command and white space. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["       * characters that end the command and white space. */", "      else if (c == '|'", "            || c == '\\n'"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["      else if (c == '|'", "            || c == '\\n'", "            || c == '\"'"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["            || c == '\\n'", "            || c == '\"'", "            || ascii_iswhite(c)) {"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["            || c == '\"'", "            || ascii_iswhite(c)) {", "        len = 0;          /* avoid getting stuck when space is in 'isfname' */"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["            || ascii_iswhite(c)) {", "        len = 0;          /* avoid getting stuck when space is in 'isfname' */", "        while (*p != NUL) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * If we are still inside the quotes, and we passed a space, just"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /* For a shell command more chars need to be escaped. */", "    if (usefilter || ea.cmdidx == CMD_bang || ea.cmdidx == CMD_terminal) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["#ifndef BACKSLASH_IN_FILENAME", "      xp->xp_shell = TRUE;", "#endif"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    }", "    /* Check for user names */", "    if (*xp->xp_pattern == '~') {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        xp->xp_context = EXPAND_USER;", "        ++xp->xp_pattern;", "      }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * 6. switch on command name"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  case CMD_tabfind:", "    if (xp->xp_context == EXPAND_FILES)", "      xp->xp_context = EXPAND_FILES_IN_PATH;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /* Command modifiers: return the argument.", "   * Also for commands with an argument that is a command. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (*arg == NUL || !ends_excmd(*arg)) {", "      /* also complete \"None\" */", "      set_context_in_echohl_cmd(xp, arg);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * All completion for the +cmdline_compl feature goes here."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  case CMD_command:", "    /* Check for attributes */", "    while (*arg == '-') {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    }", "    if (arg[0] != NUL)", "      return arg + 1;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  return NULL;", "}", ""], "readability/fn_size"]
["src/nvim/ex_docmd.c", ["      delim = *cmd++;", "      while (*cmd != NUL && *cmd != delim)", "        if (*cmd++ == '\\\\' && *cmd != NUL)"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      while (*cmd != NUL && *cmd != delim)", "        if (*cmd++ == '\\\\' && *cmd != NUL)", "          ++cmd;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        if (*cmd++ == '\\\\' && *cmd != NUL)", "          ++cmd;", "      if (*cmd == NUL && ctx != NULL)"], "readability/increment"]
["src/nvim/ex_docmd.c", ["          ++cmd;", "      if (*cmd == NUL && ctx != NULL)", "        *ctx = EXPAND_NOTHING;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    }", "    if (*cmd != NUL)", "      ++cmd;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (*cmd != NUL)", "      ++cmd;", "  }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    switch (*cmd) {", "    case '.':                               /* '.' - Cursor position */", "      ++cmd;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    case '.':                               /* '.' - Cursor position */", "      ++cmd;", "      switch (addr_type) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "    case '$':                               /* '$' - last line */", "      ++cmd;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    case '$':                               /* '$' - last line */", "      ++cmd;", "      switch (addr_type) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "    case '\\'':                              /* ''' - mark */", "      if (*++cmd == NUL) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      }", "      if (skip)", "        ++cmd;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      if (skip)", "        ++cmd;", "      else {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        ++cmd;", "      else {", "        /* Only accept a mark in another file when it is"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        ++cmd;", "      else {", "        /* Only accept a mark in another file when it is"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      else {", "        /* Only accept a mark in another file when it is", "         * used by itself: \":'M\". */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        fp = getmark(*cmd, to_other_file && cmd[1] == NUL);", "        ++cmd;", "        if (fp == (pos_T *)-1)"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        ++cmd;", "        if (fp == (pos_T *)-1)", "          /* Jumped to another file. */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        if (fp == (pos_T *)-1)", "          /* Jumped to another file. */", "          lnum = curwin->w_cursor.lnum;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["          lnum = curwin->w_cursor.lnum;", "        else {", "          if (check_mark(fp) == FAIL) {"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          lnum = curwin->w_cursor.lnum;", "        else {", "          if (check_mark(fp) == FAIL) {"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    case '/':", "    case '?':                           /* '/' or '?' - search */", "      c = *cmd++;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      }", "      if (skip) {                       /* skip \"/pat/\" */", "        cmd = skip_regexp(cmd, c, p_magic, NULL);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        cmd = skip_regexp(cmd, c, p_magic, NULL);", "        if (*cmd == c)", "          ++cmd;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        if (*cmd == c)", "          ++cmd;", "      } else {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        curwin->w_cursor = pos;", "        /* adjust command string pointer */", "        cmd += searchcmdlen;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    case '\\\\':                      /* \"\\?\", \"\\/\" or \"\\&\", repeat search */", "      ++cmd;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    case '\\\\':                      /* \"\\?\", \"\\/\" or \"\\&\", repeat search */", "      ++cmd;", "      if (addr_type != ADDR_LINES) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      }", "      if (*cmd == '&')", "        i = RE_SUBST;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        i = RE_SUBST;", "      else if (*cmd == '?' || *cmd == '/')", "        i = RE_SEARCH;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        i = RE_SEARCH;", "      else {", "        EMSG(_(e_backslash));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        i = RE_SEARCH;", "      else {", "        EMSG(_(e_backslash));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      }", "      ++cmd;", "      break;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        goto error;", "      } else if (addr_type == ADDR_LOADED_BUFFERS || addr_type == ADDR_BUFFERS) {", "        lnum = compute_buffer_local_count("], "whitespace/line_length"]
["src/nvim/ex_docmd.c", ["", "/*", " * Get flags from an Ex command argument."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  while (vim_strchr((char_u *)\"lp#\", *eap->arg) != NULL) {", "    if (*eap->arg == 'l')", "      eap->flags |= EXFLAG_LIST;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      eap->flags |= EXFLAG_LIST;", "    else if (*eap->arg == 'p')", "      eap->flags |= EXFLAG_PRINT;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      eap->flags |= EXFLAG_PRINT;", "    else", "      eap->flags |= EXFLAG_NR;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["{", "  if (!eap->skip)", "    eap->errmsg = (char_u *)N_("], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Check range in Ex command for validity."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Correct the range for zero line number, if required."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * For a \":vimgrep\" or \":vimgrepadd\" command return a pointer past the"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    p = skip_vimgrep_pat(p, NULL, NULL);", "    if (p == NULL)", "      p = eap->arg;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * For the \":make\" and \":grep\" commands insert the 'makeprg'/'grepprg' option"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Don't do it when \":vimgrep\" is used for \":grep\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        || eap->cmdidx == CMD_grepadd || eap->cmdidx == CMD_lgrepadd) {", "      if (*curbuf->b_p_gp == NUL)", "        program = p_gp;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        program = p_gp;", "      else", "        program = curbuf->b_p_gp;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    } else {", "      if (*curbuf->b_p_mp == NUL)", "        program = p_mp;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        program = p_mp;", "      else", "        program = curbuf->b_p_mp;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if ((pos = (char_u *)strstr((char *)program, \"$*\")) != NULL) {", "      /* replace $* by given arguments */", "      i = 1;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      i = 1;", "      while ((pos = (char_u *)strstr((char *)pos + 2, \"$*\")) != NULL)", "        ++i;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      while ((pos = (char_u *)strstr((char *)pos + 2, \"$*\")) != NULL)", "        ++i;", "      len = (int)STRLEN(p);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "    /* 'eap->cmd' is not set here, because it is not used at CMD_make */", "    xfree(*cmdlinep);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  int has_wildcards;            /* need to expand wildcards */", "  char_u      *repl;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* Skip a regexp pattern for \":vimgrep[add] pat file...\" */", "  p = skip_grep_pat(eap);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Decide to expand wildcards *before* replacing '%', '#', etc.  If"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  while (*p != NUL) {", "    /* Skip over `=expr`, wildcards in it are not expanded. */", "    if (p[0] == '`' && p[1] == '=') {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      (void)skip_expr(&p);", "      if (*p == '`')", "        ++p;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      if (*p == '`')", "        ++p;", "      continue;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    }", "    /*", "     * Quick check if this cannot be the start of a special string."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (vim_strchr((char_u *)\"%#<\", *p) == NULL) {", "      ++p;", "      continue;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * Try to find a match at this position."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    repl = eval_vars(p, eap->arg, &srclen, &(eap->do_ecmd_lnum),", "        errormsgp, &escaped);", "    if (*errormsgp != NULL)             /* error detected */"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["        errormsgp, &escaped);", "    if (*errormsgp != NULL)             /* error detected */", "      return FAIL;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        errormsgp, &escaped);", "    if (*errormsgp != NULL)             /* error detected */", "      return FAIL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      return FAIL;", "    if (repl == NULL) {                 /* no match found */", "      p += srclen;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /* Wildcards won't be expanded below, the replacement is taken", "     * literally.  But do expand \"~/file\", \"~user/file\" and \"$HOME/file\". */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /* Need to escape white space et al. with a backslash.", "     * Don't do this for:"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["#ifdef BACKSLASH_IN_FILENAME", "      /* Don't escape a backslash here, because rem_backslash() doesn't", "       * remove it later. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "      for (l = repl; *l; ++l)", "        if (vim_strchr(ESCAPE_CHARS, *l) != NULL) {"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "      for (l = repl; *l; ++l)", "        if (vim_strchr(ESCAPE_CHARS, *l) != NULL) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * One file argument: Expand wildcards."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (has_wildcards) {", "      /*", "       * May expand environment variables.  This"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        expand_env_esc(eap->arg, NameBuff, MAXPATHL,", "            TRUE, TRUE, NULL);", "        has_wildcards = path_has_wildcard(NameBuff);"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["        expand_env_esc(eap->arg, NameBuff, MAXPATHL,", "            TRUE, TRUE, NULL);", "        has_wildcards = path_has_wildcard(NameBuff);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        p = NameBuff;", "      } else", "        p = NULL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * Halve the number of backslashes (this is Vi compatible)."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["#ifdef UNIX", "    if (!has_wildcards)", "#endif"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      xpc.xp_context = EXPAND_FILES;", "      if (p_wic)", "        options += WILD_ICASE;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Replace part of the command line, keeping eap->cmd, eap->arg and"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  /*", "   * The new command line is build in new_cmdline[]."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  size_t i = (size_t)(src - *cmdlinep) + STRLEN(src + srclen) + len + 3;", "  if (eap->nextcmd != NULL)", "    i += STRLEN(eap->nextcmd);    /* add space for next command */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  if (eap->nextcmd != NULL)", "    i += STRLEN(eap->nextcmd);    /* add space for next command */", "  char_u *new_cmdline = xmalloc(i);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Copy the stuff before the expanded part."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["   */", "  i = (size_t)(src - *cmdlinep);   /* length of part before match */", "  memmove(new_cmdline, *cmdlinep, i);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  memmove(new_cmdline + i, repl, len);", "  i += len;                             /* remember the end of the string */", "  STRCPY(new_cmdline + i, src + srclen);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  STRCPY(new_cmdline + i, src + srclen);", "  src = new_cmdline + i;                /* remember where to continue */", ""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  if (eap->nextcmd != NULL) {           /* append next command */", "    i = STRLEN(new_cmdline) + 1;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  eap->arg = new_cmdline + (eap->arg - *cmdlinep);", "  if (eap->do_ecmd_cmd != NULL && eap->do_ecmd_cmd != dollar_command)", "    eap->do_ecmd_cmd = new_cmdline + (eap->do_ecmd_cmd - *cmdlinep);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Check for '|' to separate commands and '\"' to start comments."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * get + command from ex argument"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  if (*arg == '+') {        /* +[command] */", "    ++arg;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (*arg == '+') {        /* +[command] */", "    ++arg;", "    if (ascii_isspace(*arg) || *arg == '\\0')"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    ++arg;", "    if (ascii_isspace(*arg) || *arg == '\\0')", "      command = dollar_command;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      command = dollar_command;", "    else {", "      command = arg;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      command = dollar_command;", "    else {", "      command = arg;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      command = arg;", "      arg = skip_cmd_arg(command, TRUE);", "      if (*arg != NUL)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      arg = skip_cmd_arg(command, TRUE);", "      if (*arg != NUL)", "        *arg++ = NUL;                   /* terminate command with NUL */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      if (*arg != NUL)", "        *arg++ = NUL;                   /* terminate command with NUL */", "    }"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    arg = skipwhite(arg);       /* skip over spaces */", "    *argp = arg;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Find end of \"+command\" argument.  Skip over \"\\ \" and \"\\\\\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["static char_u *", "skip_cmd_arg (", "    char_u *p,"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["    char_u *p,", "    int rembs              /* TRUE to halve the number of backslashes */", ")"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (*p == '\\\\' && p[1] != NUL) {", "      if (rembs)", "        STRMOVE(p, p + 1);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        STRMOVE(p, p + 1);", "      else", "        ++p;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      else", "        ++p;", "    }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Get \"++opt=arg\" argument."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* \":edit ++[no]bin[ary] file\" */", "  if (STRNCMP(arg, \"bin\", 3) == 0 || STRNCMP(arg, \"nobin\", 5) == 0) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      eap->force_bin = FORCE_NOBIN;", "    } else", "      eap->force_bin = FORCE_BIN;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      eap->force_bin = FORCE_BIN;", "    if (!checkforcmd(&arg, \"binary\", 3))", "      return FAIL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /* \":read ++edit file\" */", "  if (STRNCMP(arg, \"edit\", 4) == 0) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (STRNCMP(arg, \"edit\", 4) == 0) {", "    eap->read_edit = TRUE;", "    eap->arg = skipwhite(arg + 4);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  } else if (STRNCMP(arg, \"enc\", 3) == 0) {", "    if (STRNCMP(arg, \"encoding\", 8) == 0)", "      arg += 8;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      arg += 8;", "    else", "      arg += 3;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  if (pp == NULL || *arg != '=')", "    return FAIL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  ++arg;", "  *pp = (int)(arg - eap->cmd);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  *pp = (int)(arg - eap->cmd);", "  arg = skip_cmd_arg(arg, FALSE);", "  eap->arg = skipwhite(arg);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  } else if (pp == &eap->force_enc) {", "    /* Make 'fileencoding' lower case. */", "    for (p = eap->cmd + eap->force_enc; *p != NUL; ++p)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    /* Make 'fileencoding' lower case. */", "    for (p = eap->cmd + eap->force_enc; *p != NUL; ++p)", "      *p = TOLOWER_ASC(*p);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    /* Make 'fileencoding' lower case. */", "    for (p = eap->cmd + eap->force_enc; *p != NUL; ++p)", "      *p = TOLOWER_ASC(*p);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  } else {", "    /* Check ++bad= argument.  Must be a single-byte character, \"keep\" or", "     * \"drop\". */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    char_u *p_save;", "    int relative = 0; // argument +N/-N means: go to N places to the", "                      // right/left relative to the current position."], "whitespace/comments"]
["src/nvim/ex_docmd.c", ["      }", "      else if (p == p_save || *p_save == '-' || *p != NUL || tab_number == 0) {", "        // No numbers as argument."], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["      if (!unaccept_arg0 && relative == -1) {", "        --tab_number;", "      }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      tab_number = tabpage_index(curtab) + 1;", "      if (tab_number > LAST_TAB_NR)", "        tab_number = 1;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":abbreviate\" and friends."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  do_exmap(eap, TRUE);          /* almost the same as mapping */", "}"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  do_exmap(eap, TRUE);          /* almost the same as mapping */", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":map\" and friends."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  /*", "   * If we are sourcing .exrc or .vimrc in current directory we"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  }", "  do_exmap(eap, FALSE);", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":unmap\" and friends."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  do_exmap(eap, FALSE);", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":mapclear\" and friends."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":abclear\" and friends."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    eap->errmsg = e_curdir;", "  } else if (eap->cmdidx == CMD_autocmd)", "    do_autocmd(eap->arg, eap->forceit);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    do_autocmd(eap->arg, eap->forceit);", "  else", "    do_augroup(eap->arg, eap->forceit);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":doautocmd\": Apply the automatic commands to the current buffer."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * :[N]bunload[!] [N] [bufname] unload buffer"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * :[N]buffer [N]\tto buffer N"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * :[N]bmodified [N]\tto next mod. buffer"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * :[N]bnext [N]\tto next buffer"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * :[N]bNext [N]\tto previous buffer"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * :brewind\t\tto first buffer"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * :blast\t\tto last buffer"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Return the next command, after the first '|' or '\\n'."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * - if there are more files to edit"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "        if (n == 1)", "          STRLCPY(buff, _(\"1 more file to edit.  Quit anyway?\"),"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          STRLCPY(buff, _(\"1 more file to edit.  Quit anyway?\"),", "              DIALOG_MSG_SIZE);", "        else"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["              DIALOG_MSG_SIZE);", "        else", "          vim_snprintf((char *)buff, DIALOG_MSG_SIZE,"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          vim_snprintf((char *)buff, DIALOG_MSG_SIZE,", "              _(\"%d more files to edit.  Quit anyway?\"), n);", "        if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 1) == VIM_YES)"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["              _(\"%d more files to edit.  Quit anyway?\"), n);", "        if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 1) == VIM_YES)", "          return OK;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      }", "      if (n == 1)", "        EMSG(_(\"E173: 1 more file to edit\"));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        EMSG(_(\"E173: 1 more file to edit\"));", "      else", "        EMSGN(_(\"E173: %\" PRId64 \" more files to edit\"), n);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        EMSGN(_(\"E173: %\" PRId64 \" more files to edit\"), n);", "      quitmore = 2;                 /* next try to quit is allowed */", "    }"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the list of command names."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  if (idx >= (int)CMD_SIZE)", "    return get_user_command_name(idx);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  if (rep_buf == NULL) {", "    /* Can't replace termcodes - try using the string as is */", "    rep_buf = vim_strsave(rep);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* get address of growarray: global or in curbuf */", "  if (flags & UC_BUFFER) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    gap = &curbuf->b_ucmds;", "    if (gap->ga_itemsize == 0)", "      ga_init(gap, (int)sizeof(ucmd_T), 4);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      ga_init(gap, (int)sizeof(ucmd_T), 4);", "  } else", "    gap = &ucmds;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /* Search for the command in the already defined commands. */", "  for (i = 0; i < gap->ga_len; ++i) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  /* Search for the command in the already defined commands. */", "  for (i = 0; i < gap->ga_len; ++i) {", "    size_t len;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    if (cmp == 0) {", "      if (name_len < len)", "        cmp = -1;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        cmp = -1;", "      else if (name_len > len)", "        cmp = 1;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "    /* Stop as soon as we pass the name to add */", "    if (cmp < 0)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    /* Stop as soon as we pass the name to add */", "    if (cmp < 0)", "      break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /* Extend the array unless we're replacing an existing command */", "  if (cmp != 0) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    ++gap->ga_len;", ""], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "/*", " * List of names for completion for \":command\" with the EXPAND_ flag."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  for (;; ) {", "    for (i = 0; i < gap->ga_len; ++i) {", "      cmd = USER_CMD_GA(gap, i);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      msg_putchar('\\n');", "      if (got_int)", "        break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    }", "    if (gap == &ucmds || i < gap->ga_len)", "      break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  if (!found)", "    MSG(_(\"No user-defined commands found\"));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        p = val;", "        if (*def >= 0)", "          goto two_count;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "        if (p != val + vallen)", "          goto invalid_count;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "      if (*def < 0)", "        *def = 0;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":command ...\""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* Check for attributes */", "  while (*p == '-') {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  while (*p == '-') {", "    ++p;", "    end = skiptowhite(p);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":comclear\""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "static void free_ucmd(ucmd_T* cmd) {", "  xfree(cmd->uc_name);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "static void free_ucmd(ucmd_T* cmd) {", "  xfree(cmd->uc_name);"], "whitespace/operators"]
["src/nvim/ex_docmd.c", ["", "/*", " * Clear all user commands for \"gap\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  for (;; ) {", "    for (i = 0; i < gap->ga_len; ++i) {", "      cmd = USER_CMD_GA(gap, i);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      cmp = STRCMP(eap->arg, cmd->uc_name);", "      if (cmp <= 0)", "        break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    }", "    if (gap == &ucmds || cmp == 0)", "      break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  --gap->ga_len;", ""], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  if (i < gap->ga_len)", "    memmove(cmd, cmd + 1, (gap->ga_len - i) * sizeof(ucmd_T));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * split and quote args for <f-args>"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* Precalculate length */", "  p = arg;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  p = arg;", "  len = 2;   /* Initial and final quotes */", ""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      p = skipwhite(p);", "      if (*p == NUL)", "        break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        break;", "      len += 3;       /* \",\" */", "    } else {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      p = skipwhite(p);", "      if (*p == NUL)", "        break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Check for a <> code in a user command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    char_u *buf,", "    ucmd_T *cmd,               /* the user command we're expanding */", "    exarg_T *eap,               /* ex arguments */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    ucmd_T *cmd,               /* the user command we're expanding */", "    exarg_T *eap,               /* ex arguments */", "    char_u **split_buf,"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  case ct_ARGS:", "    /* Simple case first */", "    if (*eap->arg == NUL) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        result = 2;", "        if (buf != NULL)", "          STRCPY(buf, \"''\");"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          STRCPY(buf, \"''\");", "      } else", "        result = 0;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "    /* When specified there is a single argument don't split it.", "     * Works for \":Cmd %\" when % is \"a b c\". */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    switch (quote) {", "    case 0:     /* No quoting, no splitting */", "      result = STRLEN(eap->arg);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      result = STRLEN(eap->arg);", "      if (buf != NULL)", "        STRCPY(buf, eap->arg);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      break;", "    case 1:     /* Quote, but don't split */", "      result = STRLEN(eap->arg) + 2;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      break;", "    case 2:     /* Quote and split (<f-args>) */", "      /* This is hard, so only do it once, and cache the result */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    case 2:     /* Quote and split (<f-args>) */", "      /* This is hard, so only do it once, and cache the result */", "      if (*split_buf == NULL)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      /* This is hard, so only do it once, and cache the result */", "      if (*split_buf == NULL)", "        *split_buf = uc_split_args(eap->arg, split_len);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      result = *split_len;", "      if (buf != NULL && result != 0)", "        STRCPY(buf, *split_buf);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    result = eap->forceit ? 1 : 0;", "    if (quote)", "      result += 2;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (buf != NULL) {", "      if (quote)", "        *buf++ = '\"';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        *buf++ = '\"';", "      if (eap->forceit)", "        *buf++ = '!';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        *buf++ = '!';", "      if (quote)", "        *buf = '\"';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "    sprintf(num_buf, \"%\" PRId64, (int64_t)num);", "    num_len = STRLEN(num_buf);"], "runtime/printf"]
["src/nvim/ex_docmd.c", ["", "    if (quote)", "      result += 2;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (buf != NULL) {", "      if (quote)", "        *buf++ = '\"';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      buf += num_len;", "      if (quote)", "        *buf = '\"';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    result = eap->regname ? 1 : 0;", "    if (quote)", "      result += 2;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (buf != NULL) {", "      if (quote)", "        *buf++ = '\\'';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        *buf++ = '\\'';", "      if (eap->regname)", "        *buf++ = eap->regname;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        *buf++ = eap->regname;", "      if (quote)", "        *buf = '\\'';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    result = 1;", "    if (buf != NULL)", "      *buf = '<';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  default:", "    /* Not recognized: just copy the '<' and return -1. */", "    result = (size_t)-1;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    result = (size_t)-1;", "    if (buf != NULL)", "      *buf = '<';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  if (eap->cmdidx == CMD_USER)", "    cmd = USER_CMD(eap->useridx);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    cmd = USER_CMD(eap->useridx);", "  else", "    cmd = USER_CMD_GA(&curbuf->b_ucmds, eap->useridx);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Replace <> in the command by the arguments."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  for (;; ) {", "    p = cmd->uc_rep;        /* source */", "    q = buf;                /* destination */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    p = cmd->uc_rep;        /* source */", "    q = buf;                /* destination */", "    totlen = 0;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      start = vim_strchr(p, '<');", "      if (start != NULL)", "        end = vim_strchr(start + 1, '>');"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "      /* break if there no <item> is found */", "      if (start == NULL || end == NULL)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      /* break if there no <item> is found */", "      if (start == NULL || end == NULL)", "        break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "      /* Include the '>' */", "      ++end;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      /* Include the '>' */", "      ++end;", ""], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "      /* Take everything up to the '<' */", "      len = start - p;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      len = start - p;", "      if (buf == NULL)", "        totlen += len;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        totlen += len;", "      else {", "        memmove(q, p, len);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        totlen += len;", "      else {", "        memmove(q, p, len);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      len = uc_check_code(start, end - start, q, cmd, eap,", "          &split_buf, &split_len);", "      if (len == (size_t)-1) {"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["      if (len == (size_t)-1) {", "        /* no match, continue after '<' */", "        p = start + 1;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        len = 1;", "      } else", "        p = end;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        p = end;", "      if (buf == NULL)", "        totlen += len;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        totlen += len;", "      else", "        q += len;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    }", "    if (buf != NULL) {              /* second time here, finished */", "      STRCPY(q, p);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    totlen += STRLEN(p);            /* Add on the trailing characters */", "    buf = xmalloc(totlen + 1);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["}", "/*", " * Function given to ExpandGeneric() to obtain the list of user address type names."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the list of user command names."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the list of user command"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  static char *user_cmd_flags[] = {\"addr\",   \"bang\",     \"bar\",", "                                   \"buffer\", \"complete\", \"count\","], "whitespace/braces"]
["src/nvim/ex_docmd.c", ["                                   \"buffer\", \"complete\", \"count\",", "                                   \"nargs\",  \"range\",    \"register\"};", ""], "whitespace/braces"]
["src/nvim/ex_docmd.c", ["", "  if (idx >= (int)ARRAY_SIZE(user_cmd_flags))", "    return NULL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the list of values for -nargs."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  static char *user_cmd_nargs[] = {\"0\", \"1\", \"*\", \"?\", \"+\"};", ""], "whitespace/braces"]
["src/nvim/ex_docmd.c", ["{", "  static char *user_cmd_nargs[] = {\"0\", \"1\", \"*\", \"?\", \"+\"};", ""], "whitespace/braces"]
["src/nvim/ex_docmd.c", ["", "  if (idx >= (int)ARRAY_SIZE(user_cmd_nargs))", "    return NULL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the list of values for -complete."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Parse address type argument"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Parse a completion argument \"value[vallen]\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* Look for any argument part - which is the part after any ',' */", "  for (i = 0; i < vallen; ++i) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  /* Look for any argument part - which is the part after any ',' */", "  for (i = 0; i < vallen; ++i) {", "    if (value[i] == ',') {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "    ++emsg_off;", "    p = eval_to_string(expr, NULL, FALSE);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    ++emsg_off;", "    p = eval_to_string(expr, NULL, FALSE);", "    --emsg_off;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    p = eval_to_string(expr, NULL, FALSE);", "    --emsg_off;", "    xfree(expr);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      xfree(p);", "    } else", "      MSG(\"default\");"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      MSG(\"default\");", "  } else if (load_colors(eap->arg) == FAIL)", "    EMSG2(_(\"E185: Cannot find color scheme '%s'\"), eap->arg);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Call this function if we thought we were going to exit, but we won't"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  }", "  /* Don't quit while editing the command line. */", "  if (text_locked()) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    for (wp = firstwin; wp->w_next != NULL; wp = wp->w_next) {", "      if (--wnr <= 0)", "        break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /* Don't quit while editing the command line. */", "  if (text_locked()) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":close\": close current window, unless it is the last one"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      }", "      if (win == NULL)", "        win = lastwin;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":pclose\": Close any preview window."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Close window \"win\" and take care of handling closing the last window for a"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    win_T *win,", "    tabpage_T *tp                /* NULL or the tab page \"win\" is in */", ")"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":tabclose\": close current tab page, unless it is the last one."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  if (cmdwin_type != 0)", "    cmdwin_result = K_IGNORE;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    cmdwin_result = K_IGNORE;", "  else if (first_tabpage->tp_next == NULL)", "    EMSG(_(\"E784: Cannot close last tab page\"));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    EMSG(_(\"E784: Cannot close last tab page\"));", "  else {", "    int tab_number = get_tabpage_arg(eap);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    EMSG(_(\"E784: Cannot close last tab page\"));", "  else {", "    int tab_number = get_tabpage_arg(eap);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Close the current tab page."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Close tab page \"tp\", which is not the current tab page."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* Limit to 1000 windows, autocommands may add a window while we close", "   * one.  OK, so I'm paranoid... */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /* Autocommands may delete the tab page under our fingers and we may", "     * fail to close a window with a modified buffer. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["     * fail to close a window with a modified buffer. */", "    if (!valid_tabpage(tp) || tp->tp_firstwin == wp)", "      break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  redraw_tabline = TRUE;", "  if (h != tabline_height())"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  redraw_tabline = TRUE;", "  if (h != tabline_height())", "    shell_new_rows();"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":only\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    for (wp = firstwin; --wnr > 0;) {", "      if (wp->w_next == NULL)", "        break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        break;", "      else", "        wp = wp->w_next;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  }", "  close_others(TRUE, eap->forceit);", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":all\" and \":sall\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  if (eap->addr_count == 0)", "    eap->line2 = 9999;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  }", "  /* Don't quit while editing the command line. */", "  if (text_locked()) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":print\", \":list\", \":number\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  if (curbuf->b_ml.ml_flags & ML_EMPTY)", "    EMSG(_(e_emptybuf));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    EMSG(_(e_emptybuf));", "  else {", "    for (; !got_int; os_breakcheck()) {"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    EMSG(_(e_emptybuf));", "  else {", "    for (; !got_int; os_breakcheck()) {"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      print_line(eap->line1,", "          (eap->cmdidx == CMD_number || eap->cmdidx == CMD_pound", "           || (eap->flags & EXFLAG_NR)),"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["           || (eap->flags & EXFLAG_NR)),", "          eap->cmdidx == CMD_list || (eap->flags & EXFLAG_LIST));", "      if (++eap->line1 > eap->line2)"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["          eap->cmdidx == CMD_list || (eap->flags & EXFLAG_LIST));", "      if (++eap->line1 > eap->line2)", "        break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        break;", "      ui_flush();                  /* show one line at a time */", "    }"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    setpcmark();", "    /* put cursor at last line */", "    curwin->w_cursor.lnum = eap->line2;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  ex_no_reprint = TRUE;", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * Clear an argument list: free all file names and reset it to zero entries."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Init an argument list."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Remove a reference from an argument list."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Create a new argument list and use it for the current window."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["#if !defined(UNIX)", "/*", " * Expand the file names in the global argument list."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* Don't use 'suffixes' here.  This should work like the shell did the", "   * expansion.  Also, the vimrc file isn't read yet, thus the user"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  old_arg_files = xmalloc(sizeof(*old_arg_files) * GARGCOUNT);", "  for (i = 0; i < GARGCOUNT; ++i)", "    old_arg_files[i] = vim_strsave(GARGLIST[i].ae_fname);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  old_arg_files = xmalloc(sizeof(*old_arg_files) * GARGCOUNT);", "  for (i = 0; i < GARGCOUNT; ++i)", "    old_arg_files[i] = vim_strsave(GARGLIST[i].ae_fname);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  if (expand_wildcards(old_arg_count, old_arg_files,", "          &new_arg_file_count, &new_arg_files,", "          EW_FILE|EW_NOTFOUND|EW_ADDSLASH|EW_NOERROR) == OK"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["          &new_arg_file_count, &new_arg_files,", "          EW_FILE|EW_NOTFOUND|EW_ADDSLASH|EW_NOERROR) == OK", "      && new_arg_file_count > 0) {"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["    alist_set(&global_alist, new_arg_file_count, new_arg_files,", "        TRUE, fnum_list, fnum_len);", "    FreeWild(old_arg_count, old_arg_files);"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["    alist_set(&global_alist, new_arg_file_count, new_arg_files,", "        TRUE, fnum_list, fnum_len);", "    FreeWild(old_arg_count, old_arg_files);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * Set the argument list for the current window."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", [" */", "void alist_set(alist_T *al, int count, char_u **files, int use_curbuf, int *fnum_list, int fnum_len)", "{"], "whitespace/line_length"]
["src/nvim/ex_docmd.c", ["  {", "    for (i = 0; i < count; ++i) {", "      if (got_int) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      if (got_int) {", "        /* When adding many buffers this can take a long time.  Allow", "         * interrupting here. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["         * interrupting here. */", "        while (i < count)", "          xfree(files[i++]);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "      /* May set buffer name of a buffer previously used for the", "       * argument list, so that it's re-used by alist_add. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["       * argument list, so that it's re-used by alist_add. */", "      if (fnum_list != NULL && i < fnum_len)", "        buf_set_name(fnum_list[i], files[i]);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Add file \"fname\" to argument list \"al\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    char_u *fname,", "    int set_fnum                   /* 1: set buffer number; 2: re-use curbuf */", ")"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  if (fname == NULL)            /* don't add NULL file names */", "    return;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  if (fname == NULL)            /* don't add NULL file names */", "    return;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  AARGLIST(al)[al->al_ga.ga_len].ae_fname = fname;", "  if (set_fnum > 0)", "    AARGLIST(al)[al->al_ga.ga_len].ae_fnum ="], "readability/braces"]
["src/nvim/ex_docmd.c", ["      buflist_add(fname, BLN_LISTED | (set_fnum == 2 ? BLN_CURBUF : 0));", "  ++al->al_ga.ga_len;", "}"], "readability/increment"]
["src/nvim/ex_docmd.c", ["#if defined(BACKSLASH_IN_FILENAME)", "/*", " * Adjust slashes in file names.  Called after 'shellslash' was set."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  for (int i = 0; i < GARGCOUNT; ++i) {", "    if (GARGLIST[i].ae_fname != NULL) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    if (wp->w_alist != &global_alist) {", "      for (int i = 0; i < WARGCOUNT(wp); ++i) {", "        if (WARGLIST(wp)[i].ae_fname != NULL) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  if (!check_changed(curbuf, (p_awa ? CCGD_AW : 0)", "          | CCGD_MULTWIN", "          | (eap->forceit ? CCGD_FORCEIT : 0)"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["          | CCGD_MULTWIN", "          | (eap->forceit ? CCGD_FORCEIT : 0)", "          | CCGD_EXCMD)"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["          | (eap->forceit ? CCGD_FORCEIT : 0)", "          | CCGD_EXCMD)", ""], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Command modifier used in a wrong way."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * :sview [+command] file\tsplit window with new file, read-only"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* A \":split\" in the quickfix window works like \":new\".  Don't want two", "   * quickfix windows.  But it's OK when doing \":tab split\". */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (bt_quickfix(curbuf) && cmdmod.tab == 0) {", "    if (eap->cmdidx == CMD_split)", "      eap->cmdidx = CMD_new;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      eap->cmdidx = CMD_new;", "    if (eap->cmdidx == CMD_vsplit)", "      eap->cmdidx = CMD_vnew;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    fname = find_file_in_path(eap->arg, STRLEN(eap->arg),", "                              FNAME_MESS, TRUE, curbuf->b_ffname);", "    if (fname == NULL)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["                              FNAME_MESS, TRUE, curbuf->b_ffname);", "    if (fname == NULL)", "      goto theend;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Either open new tab page or split the window."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      do_exedit(eap, old_curwin);", "      apply_autocmds(EVENT_TABNEWENTERED, NULL, NULL, FALSE, curbuf);", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "      /* set the alternate buffer for the window we came from */", "      if (curwin != old_curwin"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      /* set the alternate buffer for the window we came from */", "      if (curwin != old_curwin", "          && win_valid(old_curwin)"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  } else if (win_split(eap->addr_count > 0 ? (int)eap->line2 : 0,", "                 *eap->cmd == 'v' ? WSP_VERT : 0) != FAIL) {", "    /* Reset 'scrollbind' when editing another file, but keep it when"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["                 *eap->cmd == 'v' ? WSP_VERT : 0) != FAIL) {", "    /* Reset 'scrollbind' when editing another file, but keep it when", "     * doing \":split\" without arguments. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Open a new tab page."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * :tabnext command"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * :tabmove command"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * :tabs command: List tabs and their contents."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  msg_start();", "  msg_scroll = TRUE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["      msg_putchar(' ');", "      if (buf_spname(wp->w_buffer) != NULL)", "        STRLCPY(IObuff, buf_spname(wp->w_buffer), IOSIZE);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        STRLCPY(IObuff, buf_spname(wp->w_buffer), IOSIZE);", "      else", "        home_replace(wp->w_buffer, wp->w_buffer->b_fname,"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        home_replace(wp->w_buffer, wp->w_buffer->b_fname,", "            IObuff, IOSIZE, TRUE);", "      msg_outtrans(IObuff);"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["        home_replace(wp->w_buffer, wp->w_buffer->b_fname,", "            IObuff, IOSIZE, TRUE);", "      msg_outtrans(IObuff);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      msg_outtrans(IObuff);", "      ui_flush();                  /* output one line at a time */", "      os_breakcheck();"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":mode\":"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":resize\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    n = eap->line2;", "    for (wp = firstwin; wp->w_next != NULL && --n > 0; wp = wp->w_next)", "      ;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    for (wp = firstwin; wp->w_next != NULL && --n > 0; wp = wp->w_next)", "      ;", "  }"], "whitespace/semicolon"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":find [+command] <file>\" command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  fname = find_file_in_path(eap->arg, STRLEN(eap->arg),", "                            FNAME_MESS, TRUE, curbuf->b_ffname);", "  if (eap->addr_count > 0) {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  if (eap->addr_count > 0) {", "    /* Repeat finding the file \"count\" times.  This matters when it", "     * appears several times in the path. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      xfree(fname);", "      fname = find_file_in_path(NULL, 0, FNAME_MESS, FALSE, curbuf->b_ffname);", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":edit <file>\" command and alikes."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    exarg_T *eap,", "    win_T *old_curwin            /* curwin before doing a split or NULL */", ")"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * \":vi\" command ends Ex mode."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["                        || eap->cmdidx == CMD_view)) {", "    exmode_active = FALSE;", "    if (*eap->arg == NUL) {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    if (*eap->arg == NUL) {", "      /* Special case:  \":global/pat/visual\\NLvi-commands\" */", "      if (global_busy) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        no_wait_return = 0;", "        need_wait_return = FALSE;", "        msg_scroll = 0;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["       || eap->cmdidx == CMD_vnew", "       ) && *eap->arg == NUL) {", "    /* \":new\" or \":tabnew\" without argument: edit an new empty buffer */"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["       ) && *eap->arg == NUL) {", "    /* \":new\" or \":tabnew\" without argument: edit an new empty buffer */", "    setpcmark();"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    (void)do_ecmd(0, NULL, NULL, eap, ECMD_ONE,", "        ECMD_HIDE + (eap->forceit ? ECMD_FORCEIT : 0),", "        old_curwin == NULL ? curwin : NULL);"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["        ECMD_HIDE + (eap->forceit ? ECMD_FORCEIT : 0),", "        old_curwin == NULL ? curwin : NULL);", "  } else if ((eap->cmdidx != CMD_split && eap->cmdidx != CMD_vsplit)"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["             || *eap->arg != NUL) {", "    /* Can't edit another file when \"curbuf_lock\" is set.  Only \":edit\"", "     * can bring us here, others are stopped earlier. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["     * can bring us here, others are stopped earlier. */", "    if (*eap->arg != NUL && curbuf_locked())", "      return;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    n = readonlymode;", "    if (eap->cmdidx == CMD_view || eap->cmdidx == CMD_sview)", "      readonlymode = TRUE;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (eap->cmdidx == CMD_view || eap->cmdidx == CMD_sview)", "      readonlymode = TRUE;", "    else if (eap->cmdidx == CMD_enew)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      readonlymode = TRUE;", "    else if (eap->cmdidx == CMD_enew)", "      readonlymode = FALSE;         /* 'readonly' doesn't make sense in an"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    else if (eap->cmdidx == CMD_enew)", "      readonlymode = FALSE;         /* 'readonly' doesn't make sense in an", "                                       empty buffer */"], "readability/multiline_comment"]
["src/nvim/ex_docmd.c", ["    else if (eap->cmdidx == CMD_enew)", "      readonlymode = FALSE;         /* 'readonly' doesn't make sense in an", "                                       empty buffer */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    else if (eap->cmdidx == CMD_enew)", "      readonlymode = FALSE;         /* 'readonly' doesn't make sense in an", "                                       empty buffer */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "          /* Reset the error/interrupt/exception state here so that", "           * aborting() returns FALSE when closing a window. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "          /* Restore the error/interrupt/exception state if not", "           * discarded by a new aborting error, interrupt, or"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    } else if (readonlymode && curbuf->b_nwindows == 1) {", "      /* When editing an already visited buffer, 'readonly' won't be set", "       * but the previous value is kept.  With \":view\" and \":sview\" we"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["       * editing the same buffer. */", "      curbuf->b_p_ro = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  } else {", "    if (eap->do_ecmd_cmd != NULL)", "      do_cmdline_cmd((char *)eap->do_ecmd_cmd);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    check_arg_idx(curwin);", "    if (n != curwin->w_arg_idx_invalid)", "      maketitle();"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * if \":split file\" worked, set alternate file name in old window to new"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["   */", "  if (old_curwin != NULL", "      && *eap->arg != NUL"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  ex_no_reprint = TRUE;", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["{", "  if (curbuf->b_ml.ml_mfp == NULL || curbuf->b_ml.ml_mfp->mf_fname == NULL)", "    MSG(_(\"No swap file\"));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    MSG(_(\"No swap file\"));", "  else", "    msg(curbuf->b_ml.ml_mfp->mf_fname);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":syncbind\" forces all 'scrollbind' windows to have the same relative"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * determine max topline"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Set all scrollbind windows to the same topline."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      y = topline - curwin->w_topline;", "      if (y > 0)", "        scrollup(y, TRUE);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      if (y > 0)", "        scrollup(y, TRUE);", "      else"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        scrollup(y, TRUE);", "      else", "        scrolldown(-y, TRUE);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      else", "        scrolldown(-y, TRUE);", "      curwin->w_scbind_pos = topline;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      cursor_correct();", "      curwin->w_redr_status = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  if (curwin->w_p_scb) {", "    did_syncbind = TRUE;", "    checkpcmark();"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      i = readfile(curbuf->b_ffname, curbuf->b_fname,", "          eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);", "    } else {"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["    } else {", "      if (vim_strchr(p_cpo, CPO_ALTREAD) != NULL)", "        (void)setaltfname(eap->arg, eap->arg, (linenr_T)1);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      i = readfile(eap->arg, NULL,", "          eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);", ""], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["          eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);", "", "    }"], "whitespace/blank_line"]
["src/nvim/ex_docmd.c", ["      if (empty && exmode_active) {", "        /* Delete the empty line that remains.  Historically ex does", "         * this but vi doesn't. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["         * this but vi doesn't. */", "        if (eap->line2 == 0)", "          lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          lnum = curbuf->b_ml.ml_line_count;", "        else", "          lnum = 1;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["#if !defined(UNIX)", "  /* for non-UNIX \":cd\" means: print current directory */", "  if (*new_dir == NUL)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  /* for non-UNIX \":cd\" means: print current directory */", "  if (*new_dir == NUL)", "    ex_pwd(NULL);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    ex_pwd(NULL);", "  else", "#endif"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  {", "    if (allbuf_locked())", "      return;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "    /* \":cd -\": Change to previous directory */", "    if (STRCMP(new_dir, \"-\") == 0) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /* Save current directory for next \":cd -\" */", "    tofree = prev_dir;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    tofree = prev_dir;", "    if (os_dirname(NameBuff, MAXPATHL) == OK)", "      prev_dir = vim_strsave(NameBuff);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      prev_dir = vim_strsave(NameBuff);", "    else", "      prev_dir = NULL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":pwd\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    msg(NameBuff);", "  } else", "    EMSG(_(\"E187: Unknown\"));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":=\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    n = curwin->w_winrow + curwin->w_wrow - msg_scrolled;", "    if (n >= 0)", "      ui_cursor_goto(n, curwin->w_wincol + curwin->w_wcol);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  case NUL: len *= 1000L; break;", "  default: EMSG2(_(e_invarg2), eap->arg); return;", "  }"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["", "/*", " * Sleep for \"msec\" milliseconds, but keep checking for a CTRL-C every second."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  switch (do_map((*cmdp == 'n') ? 2 : (*cmdp == 'u'),", "              eap->arg, mode, isabbrev)) {", "  case 1: EMSG(_(e_invarg));"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":winsize\" command (obsolete)."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (*eap->arg == 'g' || *eap->arg == Ctrl_G) {", "    /* CTRL-W g and CTRL-W CTRL-G  have an extra command character */", "    if (eap->arg[1] == NUL) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    p = eap->arg + 2;", "  } else", "    p = eap->arg + 1;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  p = skipwhite(p);", "  if (*p != NUL && *p != '\"' && eap->nextcmd == NULL)", "    EMSG(_(e_invarg));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    EMSG(_(e_invarg));", "  else if (!eap->skip) {", "    /* Pass flags on for \":vertical wincmd ]\". */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  else if (!eap->skip) {", "    /* Pass flags on for \":vertical wincmd ]\". */", "    postponed_split_flags = cmdmod.split;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Handle command that work like operators: \":delete\", \":yank\", \":>\" and \":<\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  if (VIsual_active)", "    end_visual_mode();"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  default:          /* CMD_rshift or CMD_lshift */", "    if ("], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  default:          /* CMD_rshift or CMD_lshift */", "    if (", "      (eap->cmdidx == CMD_rshift) ^ curwin->w_p_rl"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (", "      (eap->cmdidx == CMD_rshift) ^ curwin->w_p_rl", "      )"], "whitespace/indent"]
["src/nvim/ex_docmd.c", ["      (eap->cmdidx == CMD_rshift) ^ curwin->w_p_rl", "      )", "      oa.op_type = OP_RSHIFT;"], "whitespace/indent"]
["src/nvim/ex_docmd.c", ["      oa.op_type = OP_RSHIFT;", "    else", "      oa.op_type = OP_LSHIFT;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      oa.op_type = OP_LSHIFT;", "    op_shift(&oa, FALSE, eap->amount);", "    break;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":put\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  /* \":0put\" works like \":1put!\". */", "  if (eap->line2 == 0) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    eap->line2 = 1;", "    eap->forceit = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * Handle \":copy\" and \":move\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * move or copy lines from 'eap->line1'-'eap->line2' to below line 'n'"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (eap->cmdidx == CMD_move) {", "    if (do_move(eap->line1, eap->line2, n) == FAIL)", "      return;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      return;", "  } else", "    ex_copy(eap->line1, eap->line2, n);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Print the current line if flags were given to the Ex command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    print_line(curwin->w_cursor.lnum, (eap->flags & EXFLAG_NR),", "        (eap->flags & EXFLAG_LIST));", "    ex_no_reprint = TRUE;"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["        (eap->flags & EXFLAG_LIST));", "    ex_no_reprint = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":join\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (eap->line1 == eap->line2) {", "    if (eap->addr_count >= 2)       /* :2,2join does nothing */", "      return;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (eap->line1 == eap->line2) {", "    if (eap->addr_count >= 2)       /* :2,2join does nothing */", "      return;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    }", "    ++eap->line2;", "  }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  }", "  do_join(eap->line2 - eap->line1 + 1, !eap->forceit, TRUE, TRUE, true);", "  beginline(BL_WHITE | BL_FIX);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":[addr]@r\": execute register"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* Put the register in the typeahead buffer with the \"silent\" flag. */", "  if (do_execreg(c, TRUE, vim_strchr(p_cpo, CPO_EXECBUF) != NULL, TRUE)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  /* Put the register in the typeahead buffer with the \"silent\" flag. */", "  if (do_execreg(c, TRUE, vim_strchr(p_cpo, CPO_EXECBUF) != NULL, TRUE)", "      == FAIL) {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "    exec_from_reg = TRUE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * Execute from the typeahead buffer."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["     */", "    while (!stuff_empty() || typebuf.tb_len > prev_len)", "      (void)do_cmdline(NULL, getexline, NULL, DOCMD_NOWAIT|DOCMD_VERBOSE);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":!\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":undo\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  u_compute_hash(hash);", "  u_write_undo((char *) eap->arg, eap->forceit, curbuf, hash);", "}"], "whitespace/cast"]
["src/nvim/ex_docmd.c", ["  u_compute_hash(hash);", "  u_read_undo((char *) eap->arg, hash, NULL);", "}"], "whitespace/cast"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":redir\": start/stop redirection."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  if (STRICMP(eap->arg, \"END\") == 0)", "    close_redir();"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    close_redir();", "  else {", "    if (*arg == '>') {"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    close_redir();", "  else {", "    if (*arg == '>') {"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (*arg == '>') {", "      ++arg;", "      if (*arg == '>') {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      if (*arg == '>') {", "        ++arg;", "        mode = \"a\";"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        mode = \"a\";", "      } else", "        mode = \"w\";"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "      /* Expand environment variables and \"~/\". */", "      fname = expand_env_save(arg);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      fname = expand_env_save(arg);", "      if (fname == NULL)", "        return;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    } else if (*arg == '@') {", "      /* redirect to a register a-z (resp. A-Z for appending) */", "      close_redir();"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      close_redir();", "      ++arg;", "      if (valid_yank_reg(*arg, true) && *arg != '_') {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        redir_reg = *arg++;", "        if (*arg == '>' && arg[1] == '>')          /* append */", "          arg += 2;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        redir_reg = *arg++;", "        if (*arg == '>' && arg[1] == '>')          /* append */", "          arg += 2;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          arg += 2;", "        else {", "          /* Can use both \"@a\" and \"@a>\". */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          arg += 2;", "        else {", "          /* Can use both \"@a\" and \"@a>\". */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        else {", "          /* Can use both \"@a\" and \"@a>\". */", "          if (*arg == '>')"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["          /* Can use both \"@a\" and \"@a>\". */", "          if (*arg == '>')", "            arg++;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "      /* redirect to a variable */", "      close_redir();"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      if (*arg == '>') {", "        ++arg;", "        append = TRUE;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        ++arg;", "        append = TRUE;", "      } else"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        append = TRUE;", "      } else", "        append = FALSE;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      } else", "        append = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "      if (var_redir_start(skipwhite(arg), append) == OK)", "        redir_vname = 1;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    }", "    /* TODO: redirect to a buffer */", "    else"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    /* TODO: redirect to a buffer */", "    else", "      EMSG2(_(e_invarg2), eap->arg);"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["", "  /* Make sure redirection is not off.  Can happen for cmdline completion", "   * that indirectly invokes a command to catch its output. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["   * that indirectly invokes a command to catch its output. */", "  if (redir_fd != NULL", "      || redir_reg || redir_vname"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      )", "    redir_off = FALSE;", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  RedrawingDisabled = 0;", "  p_lz = FALSE;", "  validate_cursor();"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /* Reset msg_didout, so that a message that's there is overwritten. */", "  msg_didout = FALSE;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  /* Reset msg_didout, so that a message that's there is overwritten. */", "  msg_didout = FALSE;", "  msg_col = 0;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /* No need to wait after an intentional redraw. */", "  need_wait_return = FALSE;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  /* No need to wait after an intentional redraw. */", "  need_wait_return = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["  RedrawingDisabled = 0;", "  p_lz = FALSE;", "  if (eap->forceit)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  p_lz = FALSE;", "  if (eap->forceit)", "    status_redraw_all();"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    status_redraw_all();", "  else", "    status_redraw_curbuf();"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Open a file for writing for an Ex command, with some checks."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["FILE *", "open_exfile (", "    char_u *fname,"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["    int forceit,", "    char *mode          /* \"w\" for create new file or \"a\" for append */", ")"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["#ifdef UNIX", "  /* with Unix it is possible to open a directory */", "  if (os_isdir(fname)) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":mark\" and \":k\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  if (*eap->arg == NUL)                 /* No argument? */", "    EMSG(_(e_argreq));"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  if (*eap->arg == NUL)                 /* No argument? */", "    EMSG(_(e_argreq));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    EMSG(_(e_argreq));", "  else if (eap->arg[1] != NUL)          /* more than one character? */", "    EMSG(_(e_trailing));"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    EMSG(_(e_argreq));", "  else if (eap->arg[1] != NUL)          /* more than one character? */", "    EMSG(_(e_trailing));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    EMSG(_(e_trailing));", "  else {", "    pos = curwin->w_cursor;             /* save curwin->w_cursor */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    EMSG(_(e_trailing));", "  else {", "    pos = curwin->w_cursor;             /* save curwin->w_cursor */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  else {", "    pos = curwin->w_cursor;             /* save curwin->w_cursor */", "    curwin->w_cursor.lnum = eap->line2;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    beginline(BL_WHITE | BL_FIX);", "    if (setmark(*eap->arg) == FAIL)     /* set mark */", "      EMSG(_(\"E191: Argument must be a letter or forward/backward quote\"));"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    beginline(BL_WHITE | BL_FIX);", "    if (setmark(*eap->arg) == FAIL)     /* set mark */", "      EMSG(_(\"E191: Argument must be a letter or forward/backward quote\"));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      EMSG(_(\"E191: Argument must be a letter or forward/backward quote\"));", "    curwin->w_cursor = pos;             /* restore curwin->w_cursor */", "  }"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Update w_topline, w_leftcol and the cursor position."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":normal[!] {commands}\": Execute normal mode commands."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /* Count the number of characters to be escaped. */", "    for (p = eap->arg; *p != NUL; ++p) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    /* Count the number of characters to be escaped. */", "    for (p = eap->arg; *p != NUL; ++p) {", "      for (l = (*mb_ptr2len)(p) - 1; l > 0; --l)"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    for (p = eap->arg; *p != NUL; ++p) {", "      for (l = (*mb_ptr2len)(p) - 1; l > 0; --l)", "        if (*++p == K_SPECIAL             /* trailbyte K_SPECIAL or CSI */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    for (p = eap->arg; *p != NUL; ++p) {", "      for (l = (*mb_ptr2len)(p) - 1; l > 0; --l)", "        if (*++p == K_SPECIAL             /* trailbyte K_SPECIAL or CSI */"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      for (l = (*mb_ptr2len)(p) - 1; l > 0; --l)", "        if (*++p == K_SPECIAL             /* trailbyte K_SPECIAL or CSI */", "            )"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      for (l = (*mb_ptr2len)(p) - 1; l > 0; --l)", "        if (*++p == K_SPECIAL             /* trailbyte K_SPECIAL or CSI */", "            )"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      len = 0;", "      for (p = eap->arg; *p != NUL; ++p) {", "        arg[len++] = *p;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        arg[len++] = *p;", "        for (l = (*mb_ptr2len)(p) - 1; l > 0; --l) {", "          arg[len++] = *++p;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  /* Might not return to the main loop when in an event handler. */", "  update_topline_cursor();"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":startinsert\", \":startreplace\" and \":startgreplace\""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  if (eap->cmdidx == CMD_startinsert)", "    restart_edit = 'a';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    restart_edit = 'a';", "  else if (eap->cmdidx == CMD_startreplace)", "    restart_edit = 'R';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    restart_edit = 'R';", "  else", "    restart_edit = 'V';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  if (!eap->forceit) {", "    if (eap->cmdidx == CMD_startinsert)", "      restart_edit = 'i';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":stopinsert\""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Execute normal mode command \"cmd\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  find_pattern_in_path(NULL, 0, 0, FALSE, FALSE, CHECK_PATH, 1L,", "                       eap->forceit ? ACTION_SHOW_ALL : ACTION_SHOW,"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":psearch\""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  int whole = TRUE;", "  long n;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  switch (cmdnames[eap->cmdidx].cmd_name[2]) {", "  case 'e':             /* \":psearch\", \":isearch\" and \":dsearch\" */", "    if (cmdnames[eap->cmdidx].cmd_name[0] == 'p')"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  case 'e':             /* \":psearch\", \":isearch\" and \":dsearch\" */", "    if (cmdnames[eap->cmdidx].cmd_name[0] == 'p')", "      action = ACTION_GOTO;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      action = ACTION_GOTO;", "    else", "      action = ACTION_SHOW;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    break;", "  case 'i':             /* \":ilist\" and \":dlist\" */", "    action = ACTION_SHOW_ALL;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    break;", "  case 'u':             /* \":ijump\" and \":djump\" */", "    action = ACTION_GOTO;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    break;", "  default:              /* \":isplit\" and \":dsplit\" */", "    action = ACTION_SPLIT;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  }", "  if (!eap->skip)", "    find_pattern_in_path(eap->arg, 0, STRLEN(eap->arg), whole, !eap->forceit,"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":ptag\", \":ptselect\", \":ptjump\", \":ptnext\", etc."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  g_do_tagpreview = p_pvh;    /* will be reset to 0 in ex_tag_cmd() */", "  ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name + 1);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":pedit\""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":stag\", \":stselect\" and \":stjump\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":tag\", \":tselect\", \":tjump\", \":tnext\", etc."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  do_tag(eap->arg, cmd, eap->addr_count > 0 ? (int)eap->line2 : 1,", "      eap->forceit, TRUE);", "}"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["  do_tag(eap->arg, cmd, eap->addr_count > 0 ? (int)eap->line2 : 1,", "      eap->forceit, TRUE);", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "/*", " * Check \"str\" for starting with a special cmdline variable."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  for (size_t i = 0; i < ARRAY_SIZE(spec_str); ++i) {", "    len = STRLEN(spec_str[i]);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Evaluate cmdline variables."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["char_u *", "eval_vars (", "    char_u *src,               /* pointer into commandline */"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["    int *escaped           /* return value has escaped white space (can", "                                 * be NULL) */", ")"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["eval_vars (", "    char_u *src,               /* pointer into commandline */", "    char_u *srcstart,          /* beginning of valid memory for src */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    char_u *src,               /* pointer into commandline */", "    char_u *srcstart,          /* beginning of valid memory for src */", "    size_t *usedlen,           /* characters after src that are used */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    char_u *srcstart,          /* beginning of valid memory for src */", "    size_t *usedlen,           /* characters after src that are used */", "    linenr_T *lnump,             /* line number for :e command, or NULL */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    size_t *usedlen,           /* characters after src that are used */", "    linenr_T *lnump,             /* line number for :e command, or NULL */", "    char_u **errormsg,         /* pointer to error message */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    linenr_T *lnump,             /* line number for :e command, or NULL */", "    char_u **errormsg,         /* pointer to error message */", "    int *escaped           /* return value has escaped white space (can"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    char_u **errormsg,         /* pointer to error message */", "    int *escaped           /* return value has escaped white space (can", "                                 * be NULL) */"], "readability/multiline_comment"]
["src/nvim/ex_docmd.c", ["    char_u **errormsg,         /* pointer to error message */", "    int *escaped           /* return value has escaped white space (can", "                                 * be NULL) */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    int *escaped           /* return value has escaped white space (can", "                                 * be NULL) */", ")"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["  *errormsg = NULL;", "  if (escaped != NULL)", "    *escaped = FALSE;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  if (escaped != NULL)", "    *escaped = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Check if there is something to do."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  ssize_t spec_idx = find_cmdline_var(src, usedlen);", "  if (spec_idx < 0) {   /* no match */", "    *usedlen = 1;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Skip when preceded with a backslash \"\\%\" and \"\\#\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    *usedlen = 0;", "    STRMOVE(src - 1, src);      /* remove backslash */", "    return NULL;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * word or WORD under cursor"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    case SPEC_HASH:             /* '#' or \"#99\": alternate file */", "      if (src[1] == '#') {          /* \"##\": the argument list */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    case SPEC_HASH:             /* '#' or \"#99\": alternate file */", "      if (src[1] == '#') {          /* \"##\": the argument list */", "        result = arg_all();"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        *usedlen = 2;", "        if (escaped != NULL)", "          *escaped = TRUE;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        if (escaped != NULL)", "          *escaped = TRUE;", "        skip_mod = TRUE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["          *escaped = TRUE;", "        skip_mod = TRUE;", "        break;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        if (*usedlen < 2) {", "          /* Should we give an error message for #<text? */", "          *usedlen = 1;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        }", "        if (lnump != NULL)", "          *lnump = ECMD_LAST;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "    case SPEC_CFILE:            /* file name under cursor */", "      result = file_name_at_cursor(FNAME_MESS|FNAME_HYP, 1L, NULL);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      }", "      resultbuf = result;                   /* remember allocated string */", "      break;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    case SPEC_ABUF:             /* buffer number for autocommand */", "      if (autocmd_bufnr <= 0) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    case SPEC_AMATCH:           /* match name for autocommand */", "      result = autocmd_match;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    case SPEC_SFILE:            /* file name for \":so\" command */", "      result = sourcing_name;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (resultlen == 0 || valid != VALID_HEAD + VALID_PATH) {", "    if (valid != VALID_HEAD + VALID_PATH)", "      /* xgettext:no-c-format */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (valid != VALID_HEAD + VALID_PATH)", "      /* xgettext:no-c-format */", "      *errormsg = (char_u *)_("], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["          \"E499: Empty file name for '%' or '#', only works with \\\":p:h\\\"\");", "    else", "      *errormsg = (char_u *)_(\"E500: Evaluates to an empty string\");"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    result = NULL;", "  } else", "    result = vim_strnsave(result, resultlen);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * Concatenate all files in the argument list, separated by spaces, and return"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Do this loop two times:"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    len = 0;", "    for (idx = 0; idx < ARGCOUNT; ++idx) {", "      p = alist_name(&ARGLIST[idx]);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      if (len > 0) {", "        /* insert a space in between names */", "        if (retval != NULL)"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        /* insert a space in between names */", "        if (retval != NULL)", "          retval[len] = ' ';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          retval[len] = ' ';", "        ++len;", "      }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "    /* second time: break here */", "    if (retval != NULL) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /* allocate memory */", "    retval = xmalloc(len + 1);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Expand the <sfile> string in \"arg\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  for (p = result; *p; ) {", "    if (STRNCMP(p, \"<sfile>\", 7) != 0)", "      ++p;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (STRNCMP(p, \"<sfile>\", 7) != 0)", "      ++p;", "    else {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      ++p;", "    else {", "      /* replace \"<sfile>\" with the sourced file name, and do \":\" stuff */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      ++p;", "    else {", "      /* replace \"<sfile>\" with the sourced file name, and do \":\" stuff */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    else {", "      /* replace \"<sfile>\" with the sourced file name, and do \":\" stuff */", "      repl = eval_vars(p, result, &srclen, NULL, &errormsg, NULL);"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      if (errormsg != NULL) {", "        if (*errormsg)", "          emsg(errormsg);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      }", "      if (repl == NULL) {               /* no match (cannot happen) */", "        p += srclen;"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      result = newres;", "      p = newres + len;                 /* continue after the match */", "    }"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":rshada\" and \":wshada\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  save_shada = p_shada;", "  if (*p_shada == NUL)", "    p_shada = (char_u *)\"'100\";"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  if (eap->cmdidx == CMD_rviminfo || eap->cmdidx == CMD_rshada) {", "    (void) shada_read_everything((char *) eap->arg, eap->forceit, false);", "  } else {"], "whitespace/cast"]
["src/nvim/ex_docmd.c", ["  } else {", "    shada_write_file((char *) eap->arg, eap->forceit);", "  }"], "whitespace/cast"]
["src/nvim/ex_docmd.c", ["", "/*", " * Make a dialog message in \"buff[DIALOG_MSG_SIZE]\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  if (fname == NULL)", "    fname = (char_u *)_(\"Untitled\");"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":behave {mswin,xterm}\""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the possible arguments of the"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  if (idx == 0)", "    return (char_u *)\"mswin\";"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    return (char_u *)\"mswin\";", "  if (idx == 1)", "    return (char_u *)\"xterm\";"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":filetype [plugin] [indent] {on,off,detect}\""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (*eap->arg == NUL) {", "    /* Print current status. */", "    smsg(\"filetype detection:%s  plugin:%s  indent:%s\","], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* Accept \"plugin\" and \"indent\" in any order. */", "  for (;; ) {"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    }", "  } else", "    EMSG2(_(e_invarg2), arg);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  if (eap->cmdidx == CMD_setlocal)", "    flags = OPT_LOCAL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    flags = OPT_LOCAL;", "  else if (eap->cmdidx == CMD_setglobal)", "    flags = OPT_GLOBAL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "/*", " * \":nohlsearch\""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  // First set the marks for all lines closed/open.", "  for (linenr_T lnum = eap->line1; lnum <= eap->line2; ++lnum) {", "    if (hasFolding(lnum, NULL, NULL) == (eap->cmdidx == CMD_folddoclosed)) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      case 0:                                 arg[0] = '0'; break;", "      case(EX_EXTRA):                         arg[0] = '*'; break;", "      case(EX_EXTRA | EX_NOSPC):              arg[0] = '?'; break;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["      case(EX_EXTRA):                         arg[0] = '*'; break;", "      case(EX_EXTRA | EX_NOSPC):              arg[0] = '?'; break;", "      case(EX_EXTRA | EX_NEEDARG):            arg[0] = '+'; break;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["      case(EX_EXTRA | EX_NOSPC):              arg[0] = '?'; break;", "      case(EX_EXTRA | EX_NEEDARG):            arg[0] = '+'; break;", "      case(EX_EXTRA | EX_NOSPC | EX_NEEDARG): arg[0] = '1'; break;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["      case(EX_EXTRA | EX_NEEDARG):            arg[0] = '+'; break;", "      case(EX_EXTRA | EX_NOSPC | EX_NEEDARG): arg[0] = '1'; break;", "    }"], "whitespace/newline"]
["src/nvim/ex_docmd.h", ["", "/* defines for eval_vars() */", "#define VALID_PATH              1"], "readability/old_style_comment"]
["src/nvim/ex_docmd.h", ["", "/* Values for exmode_active (0 is no exmode) */", "#define EXMODE_NORMAL           1"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  (did_emsg \\", "   || got_int \\", "   || current_exception \\"], "whitespace/indent"]
["src/nvim/ex_eval.c", ["   || got_int \\", "   || current_exception \\", "   || (cstack->cs_idx > 0 \\"], "whitespace/indent"]
["src/nvim/ex_eval.c", ["   || current_exception \\", "   || (cstack->cs_idx > 0 \\", "       && !(cstack->cs_flags[cstack->cs_idx - 1] & CSF_ACTIVE)))"], "whitespace/indent"]
["src/nvim/ex_eval.c", ["", "/*", " * When several errors appear in a row, setting \"force_abort\" is delayed until"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", [" */", "static int cause_abort = FALSE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["", "/*", " * The value of \"force_abort\" is temporarily reset by the first emsg() call"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["{", "  if (cause_abort)", "    force_abort = TRUE;"], "readability/braces"]
["src/nvim/ex_eval.c", ["  if (cause_abort)", "    force_abort = TRUE;", "}"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "/*", " * Return TRUE if a command with a subcommand resulting in \"retcode\" should"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * Return TRUE if a function with the \"abort\" flag should not be considered"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["{", "  /* This function is only called after an error.  In this case, \"force_abort\"", "   * determines whether searching for finally clauses is necessary. */"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  /*", "   * Do nothing when displaying the interrupt message or reporting an"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  /*", "   * If emsg() has not been called previously, temporarily reset"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    cause_abort = force_abort;", "    force_abort = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  /*", "   * If no try conditional is active and no exception is being thrown and"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  /*", "   * Ignore an interrupt message when inside a try conditional or when an"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  /*", "   * Ensure that all commands in nested function calls and sourced files"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["   */", "  cause_abort = TRUE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  /*", "   * When an exception is being thrown, some commands (like conditionals) are"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  if (!THROW_ON_ERROR) {", "    /*", "     * Print error message immediately without searching for a matching"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  {", "    /*", "     * Prepare the throw of an error exception, so that everything will"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      plist = msg_list;", "      while (*plist != NULL)", "        plist = &(*plist)->next;"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "        /* Skip the extra \"Vim \" prefix for message \"E458\". */", "        tmsg = elem->msg;"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["        tmsg = elem->msg;", "        if (STRNCMP(tmsg, \"Vim E\", 5) == 0", "            && ascii_isdigit(tmsg[5])"], "readability/braces"]
["src/nvim/ex_eval.c", ["          (*msg_list)->throw_msg = &tmsg[4];", "        else", "          (*msg_list)->throw_msg = tmsg;"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "/*", " * Free a \"msg_list\" and the messages it contains."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * Free global \"*msg_list\" and the messages it contains, then set \"*msg_list\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * Throw the message specified in the call to cause_errthrow() above as an"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["{", "  /*", "   * Ensure that all commands in nested function calls and sourced files"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  if (cause_abort) {", "    cause_abort = FALSE;", "    force_abort = TRUE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    cause_abort = FALSE;", "    force_abort = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  /* If no exception is to be thrown or the conversion should be done after", "   * returning to a previous invocation of do_one_cmd(), do nothing. */"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["   * returning to a previous invocation of do_one_cmd(), do nothing. */", "  if (msg_list == NULL || *msg_list == NULL)", "    return;"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "  if (throw_exception(*msg_list, ET_ERROR, cmdname) == FAIL)", "    free_msglist(*msg_list);"], "readability/braces"]
["src/nvim/ex_eval.c", ["    free_msglist(*msg_list);", "  else {", "    if (cstack != NULL)"], "readability/braces"]
["src/nvim/ex_eval.c", ["    free_msglist(*msg_list);", "  else {", "    if (cstack != NULL)"], "readability/braces"]
["src/nvim/ex_eval.c", ["  else {", "    if (cstack != NULL)", "      do_throw(cstack);"], "readability/braces"]
["src/nvim/ex_eval.c", ["      do_throw(cstack);", "    else", "      need_rethrow = TRUE;"], "readability/braces"]
["src/nvim/ex_eval.c", ["    else", "      need_rethrow = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "/*", " * do_intthrow(): Replace the current exception by an interrupt or interrupt"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "    /* msg_add_fname may have been used to prefix the message with a file", "     * name in quotes.  In the exception value, put the file name in"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["          p[-2] = NUL;", "          sprintf((char *)(val + STRLEN(p)), \" (%s)\", &mesg[1]);", "          p[-2] = '\"';"], "runtime/printf"]
["src/nvim/ex_eval.c", ["  } else {", "    *should_free = FALSE;", "    ret = (char_u *) value;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    *should_free = FALSE;", "    ret = (char_u *) value;", "  }"], "whitespace/cast"]
["src/nvim/ex_eval.c", ["", "  /*", "   * Disallow faking Interrupt or error exceptions as user exceptions.  They"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  if (type == ET_ERROR)", "    /* Store the original message and prefix the exception value with"], "readability/braces"]
["src/nvim/ex_eval.c", ["  if (type == ET_ERROR)", "    /* Store the original message and prefix the exception value with", "     * \"Vim:\" or, if a command name is given, \"Vim(cmdname):\". */"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  excp->value = get_exception_string(value, type, cmdname, &should_free);", "  if (excp->value == NULL && should_free)", "    goto nomem;"], "readability/braces"]
["src/nvim/ex_eval.c", ["  excp->throw_name = vim_strsave(sourcing_name == NULL", "      ? (char_u *)\"\" : sourcing_name);", "  excp->throw_lnum = sourcing_lnum;"], "whitespace/alignment"]
["src/nvim/ex_eval.c", ["", "    if (debug_break_level > 0)", "      msg_silent = FALSE;               /* display messages */"], "readability/braces"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0)", "      msg_silent = FALSE;               /* display messages */", "    else"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0)", "      msg_silent = FALSE;               /* display messages */", "    else"], "readability/bool"]
["src/nvim/ex_eval.c", ["      msg_silent = FALSE;               /* display messages */", "    else", "      verbose_enter();"], "readability/braces"]
["src/nvim/ex_eval.c", ["      verbose_enter();", "    ++no_wait_return;", "    if (debug_break_level > 0 || *p_vfile == NUL)"], "readability/increment"]
["src/nvim/ex_eval.c", ["    ++no_wait_return;", "    if (debug_break_level > 0 || *p_vfile == NUL)", "      msg_scroll = TRUE;            /* always scroll up, don't overwrite */"], "readability/braces"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0 || *p_vfile == NUL)", "      msg_scroll = TRUE;            /* always scroll up, don't overwrite */", ""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0 || *p_vfile == NUL)", "      msg_scroll = TRUE;            /* always scroll up, don't overwrite */", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["", "    if (debug_break_level > 0 || *p_vfile == NUL)", "      cmdline_row = msg_row;"], "readability/braces"]
["src/nvim/ex_eval.c", ["      cmdline_row = msg_row;", "    --no_wait_return;", "    if (debug_break_level > 0)"], "readability/increment"]
["src/nvim/ex_eval.c", ["    --no_wait_return;", "    if (debug_break_level > 0)", "      msg_silent = save_msg_silent;"], "readability/braces"]
["src/nvim/ex_eval.c", ["      msg_silent = save_msg_silent;", "    else", "      verbose_leave();"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "/*", " * Discard an exception.  \"was_finished\" is set when the exception has been"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    saved_IObuff = vim_strsave(IObuff);", "    if (debug_break_level > 0)", "      msg_silent = FALSE;               /* display messages */"], "readability/braces"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0)", "      msg_silent = FALSE;               /* display messages */", "    else"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0)", "      msg_silent = FALSE;               /* display messages */", "    else"], "readability/bool"]
["src/nvim/ex_eval.c", ["      msg_silent = FALSE;               /* display messages */", "    else", "      verbose_enter();"], "readability/braces"]
["src/nvim/ex_eval.c", ["      verbose_enter();", "    ++no_wait_return;", "    if (debug_break_level > 0 || *p_vfile == NUL)"], "readability/increment"]
["src/nvim/ex_eval.c", ["    ++no_wait_return;", "    if (debug_break_level > 0 || *p_vfile == NUL)", "      msg_scroll = TRUE;            /* always scroll up, don't overwrite */"], "readability/braces"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0 || *p_vfile == NUL)", "      msg_scroll = TRUE;            /* always scroll up, don't overwrite */", "    smsg(was_finished ? _(\"Exception finished: %s\")"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0 || *p_vfile == NUL)", "      msg_scroll = TRUE;            /* always scroll up, don't overwrite */", "    smsg(was_finished ? _(\"Exception finished: %s\")"], "readability/bool"]
["src/nvim/ex_eval.c", ["    smsg(was_finished ? _(\"Exception finished: %s\")", "                      : _(\"Exception discarded: %s\"),", "         excp->value);"], "whitespace/alignment"]
["src/nvim/ex_eval.c", ["  }", "  if (excp->type != ET_INTERRUPT)", "    xfree(excp->value);"], "readability/braces"]
["src/nvim/ex_eval.c", ["    xfree(excp->value);", "  if (excp->type == ET_ERROR)", "    free_msglist(excp->messages);"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "/*", " * Discard the exception currently being thrown."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * Put an exception on the caught stack."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  caught_stack = excp;", "  set_vim_var_string(VV_EXCEPTION, (char *) excp->value, -1);", "  if (*excp->throw_name != NUL) {"], "whitespace/cast"]
["src/nvim/ex_eval.c", ["    }", "    set_vim_var_string(VV_THROWPOINT, (char *) IObuff, -1);", "  } else {"], "whitespace/cast"]
["src/nvim/ex_eval.c", ["", "    if (debug_break_level > 0)", "      msg_silent = FALSE;               /* display messages */"], "readability/braces"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0)", "      msg_silent = FALSE;               /* display messages */", "    else"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0)", "      msg_silent = FALSE;               /* display messages */", "    else"], "readability/bool"]
["src/nvim/ex_eval.c", ["      msg_silent = FALSE;               /* display messages */", "    else", "      verbose_enter();"], "readability/braces"]
["src/nvim/ex_eval.c", ["      verbose_enter();", "    ++no_wait_return;", "    if (debug_break_level > 0 || *p_vfile == NUL)"], "readability/increment"]
["src/nvim/ex_eval.c", ["    ++no_wait_return;", "    if (debug_break_level > 0 || *p_vfile == NUL)", "      msg_scroll = TRUE;            /* always scroll up, don't overwrite */"], "readability/braces"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0 || *p_vfile == NUL)", "      msg_scroll = TRUE;            /* always scroll up, don't overwrite */", ""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0 || *p_vfile == NUL)", "      msg_scroll = TRUE;            /* always scroll up, don't overwrite */", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["", "    if (debug_break_level > 0 || *p_vfile == NUL)", "      cmdline_row = msg_row;"], "readability/braces"]
["src/nvim/ex_eval.c", ["      cmdline_row = msg_row;", "    --no_wait_return;", "    if (debug_break_level > 0)"], "readability/increment"]
["src/nvim/ex_eval.c", ["    --no_wait_return;", "    if (debug_break_level > 0)", "      msg_silent = save_msg_silent;"], "readability/braces"]
["src/nvim/ex_eval.c", ["      msg_silent = save_msg_silent;", "    else", "      verbose_leave();"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "/*", " * Remove an exception from the caught stack."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  if (caught_stack != NULL) {", "    set_vim_var_string(VV_EXCEPTION, (char *) caught_stack->value, -1);", "    if (*caught_stack->throw_name != NUL) {"], "whitespace/cast"]
["src/nvim/ex_eval.c", ["      }", "      set_vim_var_string(VV_THROWPOINT, (char *) IObuff, -1);", "    } else {"], "whitespace/cast"]
["src/nvim/ex_eval.c", ["", "/*", " * Flags specifying the message displayed by report_pending."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * Report information about something pending in a finally clause if required by"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    break;", "  /* case RP_DISCARD: */", "  default:"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  case CSTP_RETURN:", "    /* \":return\" command producing value, allocated */", "    s = (char *)get_return_cmd(value);"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      s = (char *)((except_T *)value)->value;", "    } else if ((pending & CSTP_ERROR) && (pending & CSTP_INTERRUPT))", "      s = _(\"Error and interrupt\");"], "readability/braces"]
["src/nvim/ex_eval.c", ["      s = _(\"Error and interrupt\");", "    else if (pending & CSTP_ERROR)", "      s = _(\"Error\");"], "readability/braces"]
["src/nvim/ex_eval.c", ["      s = _(\"Error\");", "    else         /* if (pending & CSTP_INTERRUPT) */", "      s = _(\"Interrupt\");"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      s = _(\"Error\");", "    else         /* if (pending & CSTP_INTERRUPT) */", "      s = _(\"Interrupt\");"], "readability/braces"]
["src/nvim/ex_eval.c", ["  save_msg_silent = msg_silent;", "  if (debug_break_level > 0)", "    msg_silent = FALSE;         /* display messages */"], "readability/braces"]
["src/nvim/ex_eval.c", ["  if (debug_break_level > 0)", "    msg_silent = FALSE;         /* display messages */", "  ++no_wait_return;"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  if (debug_break_level > 0)", "    msg_silent = FALSE;         /* display messages */", "  ++no_wait_return;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    msg_silent = FALSE;         /* display messages */", "  ++no_wait_return;", "  msg_scroll = TRUE;            /* always scroll up, don't overwrite */"], "readability/increment"]
["src/nvim/ex_eval.c", ["  ++no_wait_return;", "  msg_scroll = TRUE;            /* always scroll up, don't overwrite */", "  smsg(mesg, s);"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  ++no_wait_return;", "  msg_scroll = TRUE;            /* always scroll up, don't overwrite */", "  smsg(mesg, s);"], "readability/bool"]
["src/nvim/ex_eval.c", ["  cmdline_row = msg_row;", "  --no_wait_return;", "  if (debug_break_level > 0)"], "readability/increment"]
["src/nvim/ex_eval.c", ["  --no_wait_return;", "  if (debug_break_level > 0)", "    msg_silent = save_msg_silent;"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "  if (pending == CSTP_RETURN)", "    xfree(s);"], "readability/braces"]
["src/nvim/ex_eval.c", ["    xfree(s);", "  else if (pending & CSTP_THROW)", "    xfree(mesg);"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "/*", " * If something is made pending in a finally clause, report it if required by"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  if (p_verbose >= 14 || debug_break_level > 0) {", "    if (debug_break_level <= 0)", "      verbose_enter();"], "readability/braces"]
["src/nvim/ex_eval.c", ["    report_pending(RP_MAKE, pending, value);", "    if (debug_break_level <= 0)", "      verbose_leave();"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "/*", " * If something pending in a finally clause is resumed at the \":endtry\", report"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  if (p_verbose >= 14 || debug_break_level > 0) {", "    if (debug_break_level <= 0)", "      verbose_enter();"], "readability/braces"]
["src/nvim/ex_eval.c", ["    report_pending(RP_RESUME, pending, value);", "    if (debug_break_level <= 0)", "      verbose_leave();"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "/*", " * If something pending in a finally clause is discarded, report it if required"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  if (p_verbose >= 14 || debug_break_level > 0) {", "    if (debug_break_level <= 0)", "      verbose_enter();"], "readability/braces"]
["src/nvim/ex_eval.c", ["    report_pending(RP_DISCARD, pending, value);", "    if (debug_break_level <= 0)", "      verbose_leave();"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "/*", " * \":if\"."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  if (cstack->cs_idx == CSTACK_LEN - 1)", "    eap->errmsg = (char_u *)N_(\"E579: :if nesting too deep\");"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E579: :if nesting too deep\");", "  else {", "    ++cstack->cs_idx;"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E579: :if nesting too deep\");", "  else {", "    ++cstack->cs_idx;"], "readability/braces"]
["src/nvim/ex_eval.c", ["  else {", "    ++cstack->cs_idx;", "    cstack->cs_flags[cstack->cs_idx] = 0;"], "readability/increment"]
["src/nvim/ex_eval.c", ["    if (!skip && !error) {", "      if (result)", "        cstack->cs_flags[cstack->cs_idx] = CSF_ACTIVE | CSF_TRUE;"], "readability/braces"]
["src/nvim/ex_eval.c", ["        cstack->cs_flags[cstack->cs_idx] = CSF_ACTIVE | CSF_TRUE;", "    } else", "      /* set TRUE, so this conditional will never get active */"], "readability/braces"]
["src/nvim/ex_eval.c", ["    } else", "      /* set TRUE, so this conditional will never get active */", "      cstack->cs_flags[cstack->cs_idx] = CSF_TRUE;"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * \":endif\"."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["{", "  did_endif = TRUE;", "  if (eap->cstack->cs_idx < 0"], "readability/bool"]
["src/nvim/ex_eval.c", ["  did_endif = TRUE;", "  if (eap->cstack->cs_idx < 0", "      || (eap->cstack->cs_flags[eap->cstack->cs_idx]"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E580: :endif without :if\");", "  else {", "    /*"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E580: :endif without :if\");", "  else {", "    /*"], "readability/braces"]
["src/nvim/ex_eval.c", ["  else {", "    /*", "     * When debugging or a breakpoint was encountered, display the debug"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["     */", "    if (!(eap->cstack->cs_flags[eap->cstack->cs_idx] & CSF_TRUE)", "        && dbg_check_skipped(eap))"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "    --eap->cstack->cs_idx;", "  }"], "readability/increment"]
["src/nvim/ex_eval.c", ["", "/*", " * \":else\" and \":elseif\"."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E582: :elseif without :if\");", "    skip = TRUE;", "  } else if (cstack->cs_flags[cstack->cs_idx] & CSF_ELSE) {"], "readability/bool"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E584: :elseif after :else\");", "    skip = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  /* if skipping or the \":if\" was TRUE, reset ACTIVE, otherwise set it */", "  if (skip || cstack->cs_flags[cstack->cs_idx] & CSF_TRUE) {"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  if (skip || cstack->cs_flags[cstack->cs_idx] & CSF_TRUE) {", "    if (eap->errmsg == NULL)", "      cstack->cs_flags[cstack->cs_idx] = CSF_TRUE;"], "readability/braces"]
["src/nvim/ex_eval.c", ["      cstack->cs_flags[cstack->cs_idx] = CSF_TRUE;", "    skip = TRUE;        /* don't evaluate an \":elseif\" */", "  } else"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      cstack->cs_flags[cstack->cs_idx] = CSF_TRUE;", "    skip = TRUE;        /* don't evaluate an \":elseif\" */", "  } else"], "readability/bool"]
["src/nvim/ex_eval.c", ["    skip = TRUE;        /* don't evaluate an \":elseif\" */", "  } else", "    cstack->cs_flags[cstack->cs_idx] = CSF_ACTIVE;"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "  /*", "   * When debugging or a breakpoint was encountered, display the debug prompt"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    (void)do_intthrow(cstack);", "    skip = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["    result = eval_to_bool(eap->arg, &error, &eap->nextcmd, skip);", "    /* When throwing error exceptions, we want to throw always the first", "     * of several errors in a row.  This is what actually happens when"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if (!skip && !error) {", "      if (result)", "        cstack->cs_flags[cstack->cs_idx] = CSF_ACTIVE | CSF_TRUE;"], "readability/braces"]
["src/nvim/ex_eval.c", ["        cstack->cs_flags[cstack->cs_idx] = CSF_ACTIVE | CSF_TRUE;", "      else", "        cstack->cs_flags[cstack->cs_idx] = 0;"], "readability/braces"]
["src/nvim/ex_eval.c", ["        cstack->cs_flags[cstack->cs_idx] = 0;", "    } else if (eap->errmsg == NULL)", "      /* set TRUE, so this conditional will never get active */"], "readability/braces"]
["src/nvim/ex_eval.c", ["    } else if (eap->errmsg == NULL)", "      /* set TRUE, so this conditional will never get active */", "      cstack->cs_flags[cstack->cs_idx] = CSF_TRUE;"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      cstack->cs_flags[cstack->cs_idx] = CSF_TRUE;", "  } else", "    cstack->cs_flags[cstack->cs_idx] |= CSF_ELSE;"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "/*", " * Handle \":while\" and \":for\"."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  if (cstack->cs_idx == CSTACK_LEN - 1)", "    eap->errmsg = (char_u *)N_(\"E585: :while/:for nesting too deep\");"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E585: :while/:for nesting too deep\");", "  else {", "    /*"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E585: :while/:for nesting too deep\");", "  else {", "    /*"], "readability/braces"]
["src/nvim/ex_eval.c", ["  else {", "    /*", "     * The loop flag is set when we have jumped back from the matching"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if ((cstack->cs_lflags & CSL_HAD_LOOP) == 0) {", "      ++cstack->cs_idx;", "      ++cstack->cs_looplevel;"], "readability/increment"]
["src/nvim/ex_eval.c", ["      ++cstack->cs_idx;", "      ++cstack->cs_looplevel;", "      cstack->cs_line[cstack->cs_idx] = -1;"], "readability/increment"]
["src/nvim/ex_eval.c", ["    if (eap->cmdidx == CMD_while) {", "      /*", "       * \":while bool-expr\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * \":for var in list-expr\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      if ((cstack->cs_lflags & CSL_HAD_LOOP) != 0) {", "        /* Jumping here from a \":continue\" or \":endfor\": use the", "         * previously evaluated list. */"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["        fi = cstack->cs_forinfo[cstack->cs_idx];", "        error = FALSE;", "      } else {"], "readability/bool"]
["src/nvim/ex_eval.c", ["      } else {", "        /* Evaluate the argument and get the info in a structure. */", "        fi = eval_for_line(eap->arg, &error, &eap->nextcmd, skip);"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /* use the element at the start of the list and advance */", "      if (!error && fi != NULL && !skip)"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      /* use the element at the start of the list and advance */", "      if (!error && fi != NULL && !skip)", "        result = next_for_item(fi, eap->arg);"], "readability/braces"]
["src/nvim/ex_eval.c", ["        result = next_for_item(fi, eap->arg);", "      else", "        result = FALSE;"], "readability/braces"]
["src/nvim/ex_eval.c", ["      else", "        result = FALSE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["", "    /*", "     * If this cstack entry was just initialised and is active, set the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      cstack->cs_lflags &= ~CSL_HAD_LOOP;", "      /* If the \":while\" evaluates to FALSE or \":for\" is past the end of", "       * the list, show the debug prompt at the \":endwhile\"/\":endfor\" as"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["       * TRUE. */", "      if (!skip && !error)", "        cstack->cs_flags[cstack->cs_idx] |= CSF_TRUE;"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "/*", " * \":continue\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  if (cstack->cs_looplevel <= 0 || cstack->cs_idx < 0)", "    eap->errmsg = (char_u *)N_(\"E586: :continue without :while or :for\");"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E586: :continue without :while or :for\");", "  else {", "    /* Try to find the matching \":while\".  This might stop at a try"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E586: :continue without :while or :for\");", "  else {", "    /* Try to find the matching \":while\".  This might stop at a try"], "readability/braces"]
["src/nvim/ex_eval.c", ["  else {", "    /* Try to find the matching \":while\".  This might stop at a try", "     * conditional not in its finally clause (which is then to be executed"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["     * itself (if reached). */", "    idx = cleanup_conditionals(cstack, CSF_WHILE | CSF_FOR, FALSE);", "    assert(idx >= 0);"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "      /*", "       * Set CSL_HAD_CONT, so do_cmdline() will jump back to the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["       */", "      cstack->cs_lflags |= CSL_HAD_CONT;        /* let do_cmdline() handle it */", "    } else {"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    } else {", "      /* If a try conditional not in its finally clause is reached first,", "       * make the \":continue\" pending for execution at the \":endtry\". */"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * \":break\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  if (cstack->cs_looplevel <= 0 || cstack->cs_idx < 0)", "    eap->errmsg = (char_u *)N_(\"E587: :break without :while or :for\");"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E587: :break without :while or :for\");", "  else {", "    /* Inactivate conditionals until the matching \":while\" or a try"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E587: :break without :while or :for\");", "  else {", "    /* Inactivate conditionals until the matching \":while\" or a try"], "readability/braces"]
["src/nvim/ex_eval.c", ["  else {", "    /* Inactivate conditionals until the matching \":while\" or a try", "     * conditional not in its finally clause (which is then to be"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["     * pending for execution at the \":endtry\". */", "    idx = cleanup_conditionals(cstack, CSF_WHILE | CSF_FOR, TRUE);", "    if (idx >= 0 && !(cstack->cs_flags[idx] & (CSF_WHILE | CSF_FOR))) {"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "/*", " * \":endwhile\" and \":endfor\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  if (cstack->cs_looplevel <= 0 || cstack->cs_idx < 0)", "    eap->errmsg = err;"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = err;", "  else {", "    fl =  cstack->cs_flags[cstack->cs_idx];"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = err;", "  else {", "    fl =  cstack->cs_flags[cstack->cs_idx];"], "readability/braces"]
["src/nvim/ex_eval.c", ["    if (!(fl & csf)) {", "      /* If we are in a \":while\" or \":for\" but used the wrong endloop", "       * command, do not rewind to the next enclosing \":for\"/\":while\". */"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["       * command, do not rewind to the next enclosing \":for\"/\":while\". */", "      if (fl & CSF_WHILE)", "        eap->errmsg = (char_u *)_(\"E732: Using :endfor with :while\");"], "readability/braces"]
["src/nvim/ex_eval.c", ["        eap->errmsg = (char_u *)_(\"E732: Using :endfor with :while\");", "      else if (fl & CSF_FOR)", "        eap->errmsg = (char_u *)_(\"E733: Using :endwhile with :for\");"], "readability/braces"]
["src/nvim/ex_eval.c", ["    if (!(fl & (CSF_WHILE | CSF_FOR))) {", "      if (!(fl & CSF_TRY))", "        eap->errmsg = e_endif;"], "readability/braces"]
["src/nvim/ex_eval.c", ["        eap->errmsg = e_endif;", "      else if (fl & CSF_FINALLY)", "        eap->errmsg = e_endtry;"], "readability/braces"]
["src/nvim/ex_eval.c", ["        eap->errmsg = e_endtry;", "      /* Try to find the matching \":while\" and report what's missing. */", "      for (idx = cstack->cs_idx; idx > 0; --idx) {"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      /* Try to find the matching \":while\" and report what's missing. */", "      for (idx = cstack->cs_idx; idx > 0; --idx) {", "        fl =  cstack->cs_flags[idx];"], "readability/increment"]
["src/nvim/ex_eval.c", ["        if ((fl & CSF_TRY) && !(fl & CSF_FINALLY)) {", "          /* Give up at a try conditional not in its finally clause.", "           * Ignore the \":endwhile\"/\":endfor\". */"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["        }", "        if (fl & csf)", "          break;"], "readability/braces"]
["src/nvim/ex_eval.c", ["      }", "      /* Cleanup and rewind all contained (and unclosed) conditionals. */", "      (void)cleanup_conditionals(cstack, CSF_WHILE | CSF_FOR, FALSE);"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      /* Cleanup and rewind all contained (and unclosed) conditionals. */", "      (void)cleanup_conditionals(cstack, CSF_WHILE | CSF_FOR, FALSE);", "      rewind_conditionals(cstack, idx, CSF_TRY, &cstack->cs_trylevel);"], "readability/bool"]
["src/nvim/ex_eval.c", ["    }", "    /*", "     * When debugging or a breakpoint was encountered, display the debug"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["     */", "    else if (cstack->cs_flags[cstack->cs_idx] & CSF_TRUE", "             && !(cstack->cs_flags[cstack->cs_idx] & CSF_ACTIVE)"], "whitespace/newline"]
["src/nvim/ex_eval.c", ["", "    /*", "     * Set loop flag, so do_cmdline() will jump back to the matching"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * \":throw expr\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * Throw the current exception through the specified cstack.  Common routine"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  int idx;", "  int inactivate_try = FALSE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  /*", "   * Cleanup and inactivate up to the next surrounding try conditional that"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  if (did_emsg && !THROW_ON_ERROR) {", "    inactivate_try = TRUE;", "    did_emsg = FALSE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    inactivate_try = TRUE;", "    did_emsg = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["  if (got_int && !THROW_ON_INTERRUPT) {", "    inactivate_try = TRUE;", "    got_int = FALSE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    inactivate_try = TRUE;", "    got_int = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["  if (idx >= 0) {", "    /*", "     * If this try conditional is active and we are before its first"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if (!(cstack->cs_flags[idx] & CSF_CAUGHT)) {", "      if (cstack->cs_flags[idx] & CSF_ACTIVE)", "        cstack->cs_flags[idx] |= CSF_THROWN;"], "readability/braces"]
["src/nvim/ex_eval.c", ["        cstack->cs_flags[idx] |= CSF_THROWN;", "      else", "        /* THROWN may have already been set for a catchable exception"], "readability/braces"]
["src/nvim/ex_eval.c", ["      else", "        /* THROWN may have already been set for a catchable exception", "         * that has been discarded.  Ensure it is reset for the new"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * \":try\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  if (cstack->cs_idx == CSTACK_LEN - 1)", "    eap->errmsg = (char_u *)N_(\"E601: :try nesting too deep\");"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E601: :try nesting too deep\");", "  else {", "    ++cstack->cs_idx;"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E601: :try nesting too deep\");", "  else {", "    ++cstack->cs_idx;"], "readability/braces"]
["src/nvim/ex_eval.c", ["  else {", "    ++cstack->cs_idx;", "    ++cstack->cs_trylevel;"], "readability/increment"]
["src/nvim/ex_eval.c", ["    ++cstack->cs_idx;", "    ++cstack->cs_trylevel;", "    cstack->cs_flags[cstack->cs_idx] = CSF_TRY;"], "readability/increment"]
["src/nvim/ex_eval.c", ["    if (!skip) {", "      /* Set ACTIVE and TRUE.  TRUE means that the corresponding \":catch\"", "       * commands should check for a match if an exception is thrown and"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * \":silent!\", even when used in a try conditional, disables"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    }", "", "  }"], "whitespace/blank_line"]
["src/nvim/ex_eval.c", ["", "/*", " * \":catch /{pattern}/\" and \":catch\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  int idx = 0;", "  int give_up = FALSE;", "  int skip = FALSE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["  int give_up = FALSE;", "  int skip = FALSE;", "  int caught = FALSE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["  int skip = FALSE;", "  int caught = FALSE;", "  char_u      *end;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E603: :catch without :try\");", "    give_up = TRUE;", "  } else {"], "readability/bool"]
["src/nvim/ex_eval.c", ["    if (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY)) {", "      /* Report what's missing if the matching \":try\" is not in its", "       * finally clause. */"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      eap->errmsg = get_end_emsg(cstack);", "      skip = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_eval.c", ["    }", "    for (idx = cstack->cs_idx; idx > 0; --idx)", "      if (cstack->cs_flags[idx] & CSF_TRY)"], "readability/braces"]
["src/nvim/ex_eval.c", ["    }", "    for (idx = cstack->cs_idx; idx > 0; --idx)", "      if (cstack->cs_flags[idx] & CSF_TRY)"], "readability/increment"]
["src/nvim/ex_eval.c", ["    for (idx = cstack->cs_idx; idx > 0; --idx)", "      if (cstack->cs_flags[idx] & CSF_TRY)", "        break;"], "readability/braces"]
["src/nvim/ex_eval.c", ["    if (cstack->cs_flags[idx] & CSF_FINALLY) {", "      /* Give up for a \":catch\" after \":finally\" and ignore it.", "       * Just parse. */"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      eap->errmsg = (char_u *)N_(\"E604: :catch after :finally\");", "      give_up = TRUE;", "    } else"], "readability/bool"]
["src/nvim/ex_eval.c", ["      give_up = TRUE;", "    } else", "      rewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,"], "readability/braces"]
["src/nvim/ex_eval.c", ["      rewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,", "          &cstack->cs_looplevel);", "  }"], "whitespace/alignment"]
["src/nvim/ex_eval.c", ["", "  if (ends_excmd(*eap->arg)) {  /* no argument, catch all errors */", "    pat = (char_u *)\".*\";"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    pat = eap->arg + 1;", "    end = skip_regexp(pat, *eap->arg, TRUE, NULL);", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["  if (!give_up) {", "    /*", "     * Don't do something when no exception has been thrown or when the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "    /*", "     * Check for a match only if an exception is thrown but not caught by"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /* When debugging or a breakpoint was encountered, display the", "       * debug prompt (if not already done) before checking for a match."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      if (!dbg_check_skipped(eap) || !do_intthrow(cstack)) {", "        /* Terminate the pattern and avoid the 'l' flag in 'cpoptions'", "         * while compiling it. */"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["          prev_got_int = got_int;", "          got_int = FALSE;", "          caught = vim_regexec_nl(&regmatch, current_exception->value,"], "readability/bool"]
["src/nvim/ex_eval.c", ["          caught = vim_regexec_nl(&regmatch, current_exception->value,", "              (colnr_T)0);", "          got_int |= prev_got_int;"], "whitespace/alignment"]
["src/nvim/ex_eval.c", ["    if (caught) {", "      /* Make this \":catch\" clause active and reset did_emsg and got_int.", "       * Put the exception on the caught stack. */"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      catch_exception((except_T *)cstack->cs_exception[idx]);", "      /* It's mandatory that the current exception is stored in the cstack", "       * so that it can be discarded at the next \":catch\", \":finally\", or"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    } else {", "      /*", "       * If there is a preceding catch clause and it caught the exception,"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["       */", "      cleanup_conditionals(cstack, CSF_TRY, TRUE);", "    }"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  if (end != NULL)", "    eap->nextcmd = find_nextcmd(end);"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "/*", " * \":finally\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  int idx;", "  int skip = FALSE;", "  int pending = CSTP_NONE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  if (cstack->cs_trylevel <= 0 || cstack->cs_idx < 0)", "    eap->errmsg = (char_u *)N_(\"E606: :finally without :try\");"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E606: :finally without :try\");", "  else {", "    if (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY)) {"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E606: :finally without :try\");", "  else {", "    if (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY)) {"], "readability/braces"]
["src/nvim/ex_eval.c", ["      eap->errmsg = get_end_emsg(cstack);", "      for (idx = cstack->cs_idx - 1; idx > 0; --idx)", "        if (cstack->cs_flags[idx] & CSF_TRY)"], "readability/braces"]
["src/nvim/ex_eval.c", ["      eap->errmsg = get_end_emsg(cstack);", "      for (idx = cstack->cs_idx - 1; idx > 0; --idx)", "        if (cstack->cs_flags[idx] & CSF_TRY)"], "readability/increment"]
["src/nvim/ex_eval.c", ["      for (idx = cstack->cs_idx - 1; idx > 0; --idx)", "        if (cstack->cs_flags[idx] & CSF_TRY)", "          break;"], "readability/braces"]
["src/nvim/ex_eval.c", ["          break;", "      /* Make this error pending, so that the commands in the following", "       * finally clause can be executed.  This overrules also a pending"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      pending = CSTP_ERROR;", "    } else", "      idx = cstack->cs_idx;"], "readability/braces"]
["src/nvim/ex_eval.c", ["    if (cstack->cs_flags[idx] & CSF_FINALLY) {", "      /* Give up for a multiple \":finally\" and ignore it. */", "      eap->errmsg = (char_u *)N_(\"E607: multiple :finally\");"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    rewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,", "        &cstack->cs_looplevel);", ""], "whitespace/alignment"]
["src/nvim/ex_eval.c", ["", "    /*", "     * Don't do something when the corresponding try block never got active"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if (!skip) {", "      /* When debugging or a breakpoint was encountered, display the", "       * debug prompt (if not already done).  The user then knows that the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      if (dbg_check_skipped(eap)) {", "        /* Handle a \">quit\" debug command as if an interrupt had", "         * occurred before the \":finally\".  That is, discard the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * If there is a preceding catch clause and it caught the exception,"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["       */", "      cleanup_conditionals(cstack, CSF_TRY, FALSE);", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["", "      /*", "       * Make did_emsg, got_int, current_exception pending.  If set, they"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["          report_discard_pending(CSTP_RETURN,", "              cstack->cs_rettv[cstack->cs_idx]);", "          discard_pending_return(cstack->cs_rettv[cstack->cs_idx]);"], "whitespace/alignment"]
["src/nvim/ex_eval.c", ["", "        /* It's mandatory that the current exception is stored in the", "         * cstack so that it can be rethrown at the \":endtry\" or be"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * Set CSL_HAD_FINA, so do_cmdline() will reset did_emsg,"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * \":endtry\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  int skip;", "  int rethrow = FALSE;", "  int pending = CSTP_NONE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["      eap->errmsg = get_end_emsg(cstack);", "      /* Find the matching \":try\" and report what's missing. */", "      idx = cstack->cs_idx;"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      do", "        --idx;", "      while (idx > 0 && !(cstack->cs_flags[idx] & CSF_TRY));"], "readability/increment"]
["src/nvim/ex_eval.c", ["        --idx;", "      while (idx > 0 && !(cstack->cs_flags[idx] & CSF_TRY));", "      rewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,"], "readability/braces"]
["src/nvim/ex_eval.c", ["        --idx;", "      while (idx > 0 && !(cstack->cs_flags[idx] & CSF_TRY));", "      rewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,"], "whitespace/empty_loop_body"]
["src/nvim/ex_eval.c", ["      rewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,", "          &cstack->cs_looplevel);", "      skip = TRUE;"], "whitespace/alignment"]
["src/nvim/ex_eval.c", ["          &cstack->cs_looplevel);", "      skip = TRUE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["", "      /*", "       * If an exception is being thrown, discard it to prevent it from"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * If we stopped with the exception currently being thrown at this"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "    /* If there was no finally clause, show the user when debugging or", "     * a breakpoint was encountered that the end of the try conditional has"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["        && dbg_check_skipped(eap)) {", "      /* Handle a \">quit\" debug command as if an interrupt had occurred", "       * before the \":endtry\".  That is, throw an interrupt exception and"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      if (got_int) {", "        skip = TRUE;", "        (void)do_intthrow(cstack);"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "    /*", "     * If a \":return\" is pending, we need to resume it after closing the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      cstack->cs_pending[idx] = CSTP_NONE;", "      if (pending == CSTP_RETURN)", "        rettv = cstack->cs_rettv[idx];"], "readability/braces"]
["src/nvim/ex_eval.c", ["        rettv = cstack->cs_rettv[idx];", "      else if (pending & CSTP_THROW)", "        current_exception = cstack->cs_exception[idx];"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "    /*", "     * Discard anything pending on an error, interrupt, or throw in the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["     */", "    (void)cleanup_conditionals(cstack, CSF_TRY | CSF_SILENT, TRUE);", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["", "    --cstack->cs_idx;", "    --cstack->cs_trylevel;"], "readability/increment"]
["src/nvim/ex_eval.c", ["    --cstack->cs_idx;", "    --cstack->cs_trylevel;", ""], "readability/increment"]
["src/nvim/ex_eval.c", ["      report_resume_pending(pending,", "          (pending == CSTP_RETURN) ? rettv :", "          (pending & CSTP_THROW) ? (void *)current_exception : NULL);"], "whitespace/alignment"]
["src/nvim/ex_eval.c", ["          (pending == CSTP_RETURN) ? rettv :", "          (pending & CSTP_THROW) ? (void *)current_exception : NULL);", "      switch (pending) {"], "whitespace/alignment"]
["src/nvim/ex_eval.c", ["", "      /* Reactivate a pending \":continue\", \":break\", \":return\",", "       * \":finish\" from the try block or a catch clause of this try"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      case CSTP_RETURN:", "        do_return(eap, FALSE, FALSE, rettv);", "        break;"], "readability/bool"]
["src/nvim/ex_eval.c", ["      case CSTP_FINISH:", "        do_finish(eap, FALSE);", "        break;"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "/*", " * enter_cleanup() and leave_cleanup()"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * This function works a bit like ex_finally() except that there was not"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  /*", "   * Postpone did_emsg, got_int, current_exception.  The pending values will be"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "    /* If we are currently throwing an exception, save it as well.  On an error", "     * not yet converted to an exception, update \"force_abort\" and reset"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["        force_abort |= cause_abort;", "        cause_abort = FALSE;", "      }"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "    /* Report if required by the 'verbose' option or when debugging.  */", "    report_make_pending(pending, csp->exception);"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * See comment above enter_cleanup() for how this function is used."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  if (pending == CSTP_NONE)     /* nothing to do */", "    return;"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  if (pending == CSTP_NONE)     /* nothing to do */", "    return;"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "  /* If there was an aborting error, an interrupt, or an uncaught exception", "   * after the corresponding call to enter_cleanup(), discard what has been"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "    /* If an error was about to be converted to an exception when", "     * enter_cleanup() was called, free the message list. */"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["     * enter_cleanup() was called, free the message list. */", "    if (msg_list != NULL)", "      free_global_msglist();"], "readability/braces"]
["src/nvim/ex_eval.c", ["  }", "  /*", "   * If there was no new error, interrupt, or throw between the calls"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["   */", "  else {", "    /*"], "whitespace/newline"]
["src/nvim/ex_eval.c", ["   */", "  else {", "    /*"], "readability/braces"]
["src/nvim/ex_eval.c", ["  else {", "    /*", "     * If there was an exception being thrown when enter_cleanup() was"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["     */", "    if (pending & CSTP_THROW)", "      current_exception = csp->exception;"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "    /*", "     * If an error was about to be converted to an exception when"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["     */", "    else if (pending & CSTP_ERROR) {", "      cause_abort = force_abort;"], "readability/braces"]
["src/nvim/ex_eval.c", ["      cause_abort = force_abort;", "      force_abort = FALSE;", "    }"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "/*", " * Make conditionals inactive and discard what's pending in finally clauses"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  int idx;", "  int stop = FALSE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  for (idx = cstack->cs_idx; idx >= 0; --idx) {", "    if (cstack->cs_flags[idx] & CSF_TRY) {"], "readability/increment"]
["src/nvim/ex_eval.c", ["    if (cstack->cs_flags[idx] & CSF_TRY) {", "      /*", "       * Discard anything pending in a finally clause and continue the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["          report_discard_pending(CSTP_RETURN,", "              cstack->cs_rettv[idx]);", "          discard_pending_return(cstack->cs_rettv[idx]);"], "whitespace/alignment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * Stop at a try conditional not in its finally clause.  If this try"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      if (!(cstack->cs_flags[idx] & CSF_FINALLY)) {", "        if ((cstack->cs_flags[idx] & CSF_ACTIVE)", "            && (cstack->cs_flags[idx] & CSF_CAUGHT))"], "readability/braces"]
["src/nvim/ex_eval.c", ["          finish_exception((except_T *)cstack->cs_exception[idx]);", "        /* Stop at this try conditional - except the try block never", "         * got active (because of an inactive surrounding conditional"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["        if (cstack->cs_flags[idx] & CSF_TRUE) {", "          if (searched_cond == 0 && !inclusive)", "            break;"], "readability/braces"]
["src/nvim/ex_eval.c", ["            break;", "          stop = TRUE;", "        }"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "    /* Stop on the searched conditional type (even when the surrounding", "     * conditional is not active or something has been made pending)."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if (cstack->cs_flags[idx] & searched_cond) {", "      if (!inclusive)", "        break;"], "readability/braces"]
["src/nvim/ex_eval.c", ["        break;", "      stop = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_eval.c", ["    cstack->cs_flags[idx] &= ~CSF_ACTIVE;", "    if (stop && searched_cond != (CSF_TRY | CSF_SILENT))", "      break;"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "    /*", "     * When leaving a try conditional that reset \"emsg_silent\" on its"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    }", "    if (stop)", "      break;"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "/*", " * Return an appropriate error message for a missing endwhile/endfor/endif."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["{", "  if (cstack->cs_flags[cstack->cs_idx] & CSF_WHILE)", "    return e_endwhile;"], "readability/braces"]
["src/nvim/ex_eval.c", ["    return e_endwhile;", "  if (cstack->cs_flags[cstack->cs_idx] & CSF_FOR)", "    return e_endfor;"], "readability/braces"]
["src/nvim/ex_eval.c", ["", "/*", " * Rewind conditionals until index \"idx\" is reached.  \"cond_type\" and"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  while (cstack->cs_idx > idx) {", "    if (cstack->cs_flags[cstack->cs_idx] & cond_type)", "      --*cond_level;"], "readability/braces"]
["src/nvim/ex_eval.c", ["    if (cstack->cs_flags[cstack->cs_idx] & cond_type)", "      --*cond_level;", "    if (cstack->cs_flags[cstack->cs_idx] & CSF_FOR)"], "readability/increment"]
["src/nvim/ex_eval.c", ["      --*cond_level;", "    if (cstack->cs_flags[cstack->cs_idx] & CSF_FOR)", "      free_for_info(cstack->cs_forinfo[cstack->cs_idx]);"], "readability/braces"]
["src/nvim/ex_eval.c", ["      free_for_info(cstack->cs_forinfo[cstack->cs_idx]);", "    --cstack->cs_idx;", "  }"], "readability/increment"]
["src/nvim/ex_eval.c", ["", "/*", " * \":endfunction\" when not after a \":function\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "/*", " * Return TRUE if the string \"p\" looks like a \":while\" or \":for\" command."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  /* skip modifiers, white space and ':' */", "  for (;; ) {"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  for (;; ) {", "    while (*p == ' ' || *p == '\\t' || *p == ':')", "      ++p;"], "readability/braces"]
["src/nvim/ex_eval.c", ["    while (*p == ' ' || *p == '\\t' || *p == ':')", "      ++p;", "    len = modifier_len(p);"], "readability/increment"]
["src/nvim/ex_eval.c", ["    len = modifier_len(p);", "    if (len == 0)", "      break;"], "readability/braces"]
["src/nvim/ex_eval.c", ["  }", "  if ((p[0] == 'w' && p[1] == 'h')", "      || (p[0] == 'f' && p[1] == 'o' && p[2] == 'r'))"], "readability/braces"]
["src/nvim/ex_eval.c", ["      || (p[0] == 'f' && p[1] == 'o' && p[2] == 'r'))", "    return TRUE;", "  return FALSE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    return TRUE;", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ex_eval.h", ["", "/* There is no CSF_IF, the lack of CSF_WHILE, CSF_FOR and CSF_TRY means \":if\"", " * was used. */"], "readability/old_style_comment"]
["src/nvim/ex_eval.h", [" * was used. */", "# define CSF_TRUE       0x0001  /* condition was TRUE */", "# define CSF_ACTIVE     0x0002  /* current state is active */"], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["# define CSF_TRUE       0x0001  /* condition was TRUE */", "# define CSF_ACTIVE     0x0002  /* current state is active */", "# define CSF_ELSE       0x0004  /* \":else\" has been passed */"], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["# define CSF_ACTIVE     0x0002  /* current state is active */", "# define CSF_ELSE       0x0004  /* \":else\" has been passed */", "# define CSF_WHILE      0x0008  /* is a \":while\" */"], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["# define CSF_ELSE       0x0004  /* \":else\" has been passed */", "# define CSF_WHILE      0x0008  /* is a \":while\" */", "# define CSF_FOR        0x0010  /* is a \":for\" */"], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["# define CSF_WHILE      0x0008  /* is a \":while\" */", "# define CSF_FOR        0x0010  /* is a \":for\" */", ""], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["", "# define CSF_TRY        0x0100  /* is a \":try\" */", "# define CSF_FINALLY    0x0200  /* \":finally\" has been passed */"], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["# define CSF_TRY        0x0100  /* is a \":try\" */", "# define CSF_FINALLY    0x0200  /* \":finally\" has been passed */", "# define CSF_THROWN     0x0400  /* exception thrown to this try conditional */"], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["# define CSF_FINALLY    0x0200  /* \":finally\" has been passed */", "# define CSF_THROWN     0x0400  /* exception thrown to this try conditional */", "# define CSF_CAUGHT     0x0800  /* exception caught by this try conditional */"], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["# define CSF_THROWN     0x0400  /* exception thrown to this try conditional */", "# define CSF_CAUGHT     0x0800  /* exception caught by this try conditional */", "# define CSF_SILENT     0x1000  /* \"emsg_silent\" reset by \":try\" */"], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["# define CSF_CAUGHT     0x0800  /* exception caught by this try conditional */", "# define CSF_SILENT     0x1000  /* \"emsg_silent\" reset by \":try\" */", "/* Note that CSF_ELSE is only used when CSF_TRY and CSF_WHILE are unset"], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["# define CSF_SILENT     0x1000  /* \"emsg_silent\" reset by \":try\" */", "/* Note that CSF_ELSE is only used when CSF_TRY and CSF_WHILE are unset", " * (an \":if\"), and CSF_SILENT is only used when CSF_TRY is set. */"], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["", "/*", " * What's pending for being reactivated at the \":endtry\" of this try"], "readability/old_style_comment"]
["src/nvim/ex_eval.h", [" */", "# define CSTP_NONE      0       /* nothing pending in \":finally\" clause */", "# define CSTP_ERROR     1       /* an error is pending */"], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["# define CSTP_NONE      0       /* nothing pending in \":finally\" clause */", "# define CSTP_ERROR     1       /* an error is pending */", "# define CSTP_INTERRUPT 2       /* an interrupt is pending */"], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["# define CSTP_ERROR     1       /* an error is pending */", "# define CSTP_INTERRUPT 2       /* an interrupt is pending */", "# define CSTP_THROW     4       /* a throw is pending */"], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["# define CSTP_INTERRUPT 2       /* an interrupt is pending */", "# define CSTP_THROW     4       /* a throw is pending */", "# define CSTP_BREAK     8       /* \":break\" is pending */"], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["# define CSTP_THROW     4       /* a throw is pending */", "# define CSTP_BREAK     8       /* \":break\" is pending */", "# define CSTP_CONTINUE  16      /* \":continue\" is pending */"], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["# define CSTP_BREAK     8       /* \":break\" is pending */", "# define CSTP_CONTINUE  16      /* \":continue\" is pending */", "# define CSTP_RETURN    24      /* \":return\" is pending */"], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["# define CSTP_CONTINUE  16      /* \":continue\" is pending */", "# define CSTP_RETURN    24      /* \":return\" is pending */", "# define CSTP_FINISH    32      /* \":finish\" is pending */"], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["# define CSTP_RETURN    24      /* \":return\" is pending */", "# define CSTP_FINISH    32      /* \":finish\" is pending */", ""], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["", "/*", " * A list of error messages that can be converted to an exception.  \"throw_msg\""], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["struct msglist {", "  char_u              *msg;             /* original message */", "  char_u              *throw_msg;       /* msg to throw: usually original one */"], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["  char_u              *msg;             /* original message */", "  char_u              *throw_msg;       /* msg to throw: usually original one */", "  struct msglist      *next;            /* next of several messages in a row */"], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["  char_u              *throw_msg;       /* msg to throw: usually original one */", "  struct msglist      *next;            /* next of several messages in a row */", "};"], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["", "/*", " * Structure describing an exception."], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["", "/*", " * Structure to save the error/interrupt/exception state between calls to"], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["struct cleanup_stuff {", "  int pending;                  /* error/interrupt/exception state */", "  except_T *exception;          /* exception value */"], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["  int pending;                  /* error/interrupt/exception state */", "  except_T *exception;          /* exception value */", "};"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * ex_getln.c: Functions for entering and editing an Ex command line."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Variables shared between getcmdline(), redrawcmdline() and others."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/* The current cmdline_info.  It is initialized in getcmdline() and after that", " * used by other functions.  When invoking getcmdline() recursively it needs"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "static int cmd_showtail;                /* Only show path tail in lists ? */", ""], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "static int new_cmdpos;          /* position set by set_cmdline_pos() */", ""], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Type used by call_user_expand_func"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "static histentry_T *(history[HIST_COUNT]) = {NULL, NULL, NULL, NULL, NULL};", "static int hisidx[HIST_COUNT] = {-1, -1, -1, -1, -1};       /* lastused entry */"], "whitespace/braces"]
["src/nvim/ex_getln.c", ["", "static histentry_T *(history[HIST_COUNT]) = {NULL, NULL, NULL, NULL, NULL};", "static int hisidx[HIST_COUNT] = {-1, -1, -1, -1, -1};       /* lastused entry */"], "whitespace/braces"]
["src/nvim/ex_getln.c", ["static histentry_T *(history[HIST_COUNT]) = {NULL, NULL, NULL, NULL, NULL};", "static int hisidx[HIST_COUNT] = {-1, -1, -1, -1, -1};       /* lastused entry */", "static int hisnum[HIST_COUNT] = {0, 0, 0, 0, 0};"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["static histentry_T *(history[HIST_COUNT]) = {NULL, NULL, NULL, NULL, NULL};", "static int hisidx[HIST_COUNT] = {-1, -1, -1, -1, -1};       /* lastused entry */", "static int hisnum[HIST_COUNT] = {0, 0, 0, 0, 0};"], "whitespace/braces"]
["src/nvim/ex_getln.c", ["static histentry_T *(history[HIST_COUNT]) = {NULL, NULL, NULL, NULL, NULL};", "static int hisidx[HIST_COUNT] = {-1, -1, -1, -1, -1};       /* lastused entry */", "static int hisnum[HIST_COUNT] = {0, 0, 0, 0, 0};"], "whitespace/braces"]
["src/nvim/ex_getln.c", ["static int hisidx[HIST_COUNT] = {-1, -1, -1, -1, -1};       /* lastused entry */", "static int hisnum[HIST_COUNT] = {0, 0, 0, 0, 0};", "/* identifying (unique) number of newest history entry */"], "whitespace/braces"]
["src/nvim/ex_getln.c", ["static int hisidx[HIST_COUNT] = {-1, -1, -1, -1, -1};       /* lastused entry */", "static int hisnum[HIST_COUNT] = {0, 0, 0, 0, 0};", "/* identifying (unique) number of newest history entry */"], "whitespace/braces"]
["src/nvim/ex_getln.c", ["static int hisnum[HIST_COUNT] = {0, 0, 0, 0, 0};", "/* identifying (unique) number of newest history entry */", "static int hislen = 0;                  /* actual length of history tables */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["/* identifying (unique) number of newest history entry */", "static int hislen = 0;                  /* actual length of history tables */", ""], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      add_to_history(s->histype, ccline.cmdbuff, true,", "          s->histype == HIST_SEARCH ? s->firstc : NUL);", "      if (s->firstc == ':') {"], "whitespace/alignment"]
["src/nvim/ex_getln.c", ["    } else if (STRNCMP(s->xpc.xp_pattern, upseg + 1, 3) == 0", "        && s->c == K_DOWN) {", "      // If in a direct ancestor, strip off one ../ to go down"], "whitespace/alignment"]
["src/nvim/ex_getln.c", ["      || (s->c == ESC", "        && (!KeyTyped || vim_strchr(p_cpo, CPO_ESC) != NULL))) {", "    // In Ex mode a backslash escapes a newline."], "whitespace/alignment"]
["src/nvim/ex_getln.c", ["      || (s->c == ESC", "        && (!KeyTyped || vim_strchr(p_cpo, CPO_ESC) != NULL))) {", "    // In Ex mode a backslash escapes a newline."], "whitespace/alignment"]
["src/nvim/ex_getln.c", ["          (void)showmatches(&s->xpc, p_wmnu", "              && ((wim_flags[s->wim_index] & WIM_LIST) == 0));", "          redrawcmd();"], "whitespace/alignment"]
["src/nvim/ex_getln.c", ["    if (s->wim_index < 3) {", "      ++s->wim_index;", "    }"], "readability/increment"]
["src/nvim/ex_getln.c", ["    if (s->c == K_DEL && ccline.cmdpos != ccline.cmdlen) {", "      ++ccline.cmdpos;", "    }"], "readability/increment"]
["src/nvim/ex_getln.c", ["      ccline.cmdpos += mb_off_next(ccline.cmdbuff,", "          ccline.cmdbuff + ccline.cmdpos);", "    }"], "whitespace/alignment"]
["src/nvim/ex_getln.c", ["    }", "    --no_mapping;", "    // Insert the result of an expression."], "readability/increment"]
["src/nvim/ex_getln.c", ["  case Ctrl_A:            // all matches", "    if (nextwild(&s->xpc, WILD_ALL, 0, s->firstc != '@') == FAIL)", "      break;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      if (nextwild(&s->xpc, (s->c == Ctrl_P) ? WILD_PREV : WILD_NEXT,", "              0, s->firstc != '@') == FAIL) {", "        break;"], "whitespace/alignment"]
["src/nvim/ex_getln.c", ["                }", "                ++len;", "              }"], "readability/increment"]
["src/nvim/ex_getln.c", ["            }", "            ++len;", "          }"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "/*", " * getcmdline() - accept a command line starting with firstc."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["char_u *", "getcmdline (", "    int firstc,"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["", "/*", " * Return TRUE when the text must not be changed and we can't switch to"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", [" */", "int text_locked(void) {", "  if (cmdwin_type != 0)"], "readability/braces"]
["src/nvim/ex_getln.c", ["int text_locked(void) {", "  if (cmdwin_type != 0)", "    return TRUE;"], "readability/braces"]
["src/nvim/ex_getln.c", ["  if (cmdwin_type != 0)", "    return TRUE;", "  return textlock != 0;"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * Give an error message for a command that isn't allowed while the cmdline"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "char_u * get_text_locked_msg(void) {", "  if (cmdwin_type != 0) {"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Check if \"curbuf_lock\" or \"allbuf_lock\" is set and return TRUE when it is"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    EMSG(_(\"E788: Not allowed to edit another buffer now\"));", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * Check if \"allbuf_lock\" is set and return TRUE when it is and give an error"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    EMSG(_(\"E811: Not allowed to change buffer information now\"));", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_getln.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ex_getln.c", ["{", "  if (cmdline_star > 0)             /* showing '*', always 1 position */", "    return 1;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["{", "  if (cmdline_star > 0)             /* showing '*', always 1 position */", "    return 1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    m = Columns * Rows;", "    if (m < 0)          /* overflow, Columns or Rows at weird value */", "      m = MAXCOL;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    m = Columns * Rows;", "    if (m < 0)          /* overflow, Columns or Rows at weird value */", "      m = MAXCOL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Get an Ex command line for the \":\" command."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["{", "  /* When executing a register, remove ':' that's in front of each line. */", "  if (exec_from_reg && vpeekc() == ':')"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  /* When executing a register, remove ':' that's in front of each line. */", "  if (exec_from_reg && vpeekc() == ':')", "    (void)vgetc();"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Get an Ex command line for Ex mode."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  int c1 = 0;", "  int escaped = FALSE;                  /* CTRL-V typed */", "  int vcol = 0;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  int c1 = 0;", "  int escaped = FALSE;                  /* CTRL-V typed */", "  int vcol = 0;"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "  /* always start in column 0; write a newline if necessary */", "  compute_cmdrow();"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  compute_cmdrow();", "  if ((msg_col || msg_didout) && promptc != '?')", "    msg_putchar('\\n');"], "readability/braces"]
["src/nvim/ex_getln.c", ["  if (promptc == ':') {", "    /* indent that is only displayed, not in the line itself */", "    if (p_prompt)"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    /* indent that is only displayed, not in the line itself */", "    if (p_prompt)", "      msg_putchar(':');"], "readability/braces"]
["src/nvim/ex_getln.c", ["      msg_putchar(':');", "    while (indent-- > 0)", "      msg_putchar(' ');"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* autoindent for :insert and :append is in the line itself */", "  if (promptc <= 0) {"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  /*", "   * Get the line, one character at a time."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["   */", "  got_int = FALSE;", "  while (!got_int) {"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "    /* Get one character at a time.  Don't use inchar(), it can't handle", "     * special characters. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "    /*", "     * Handle line editing."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    if (!escaped) {", "      /* CR typed means \"enter\", which is NL */", "      if (c1 == '\\r')"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      /* CR typed means \"enter\", which is NL */", "      if (c1 == '\\r')", "        c1 = '\\n';"], "readability/braces"]
["src/nvim/ex_getln.c", ["        p[line_ga.ga_len] = NUL;", "        indent = get_indent_str(p, 8, FALSE);", "        num_spaces = sw - indent % sw;"], "readability/bool"]
["src/nvim/ex_getln.c", ["redraw:", "        /* redraw the line */", "        msg_col = startcol;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      if (c1 == Ctrl_D) {", "        /* Delete one shiftwidth. */", "        p = (char_u *)line_ga.ga_data;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["        if (prev_char == '0' || prev_char == '^') {", "          if (prev_char == '^')", "            ex_keep_indent = TRUE;"], "readability/braces"]
["src/nvim/ex_getln.c", ["          if (prev_char == '^')", "            ex_keep_indent = TRUE;", "          indent = 0;"], "readability/bool"]
["src/nvim/ex_getln.c", ["          p[line_ga.ga_len] = NUL;", "          indent = get_indent_str(p, 8, FALSE);", "          if (indent == 0) {"], "readability/bool"]
["src/nvim/ex_getln.c", ["          }", "          --indent;", "          indent -= indent % get_sw_value(curbuf);"], "readability/increment"]
["src/nvim/ex_getln.c", ["        int old_indent;", "        while ((old_indent = get_indent_str(p, 8, FALSE)) > indent) {", "          *--to = NUL;"], "readability/bool"]
["src/nvim/ex_getln.c", ["      if (c1 == Ctrl_V || c1 == Ctrl_Q) {", "        escaped = TRUE;", "        continue;"], "readability/bool"]
["src/nvim/ex_getln.c", ["    line_ga.ga_len += len;", "    escaped = FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["", "    /* We are done when a NL is entered, but not when it comes after an", "     * odd number of backslashes, that results in a NUL. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "      while (line_ga.ga_len - 2 >= bcount && pend[-2 - bcount] == '\\\\')", "        ++bcount;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      while (line_ga.ga_len - 2 >= bcount && pend[-2 - bcount] == '\\\\')", "        ++bcount;", ""], "readability/increment"]
["src/nvim/ex_getln.c", ["      if (bcount > 0) {", "        /* Halve the number of backslashes: \"\\NL\" -> \"NUL\", \"\\\\NL\" ->", "         * \"\\NL\", etc. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      if ((bcount & 1) == 0) {", "        --line_ga.ga_len;", "        --pend;"], "readability/increment"]
["src/nvim/ex_getln.c", ["        --line_ga.ga_len;", "        --pend;", "        *pend = NUL;"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "  /* make following messages go to the next line */", "  msg_didout = FALSE;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  /* make following messages go to the next line */", "  msg_didout = FALSE;", "  msg_col = 0;"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "  if (got_int)", "    ga_clear(&line_ga);"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Allocate a new command line buffer."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["{", "  /*", "   * give some extra space to avoid having to allocate all the time"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["   */", "  if (len < 80)", "    len = 100;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    len = 100;", "  else", "    len += 20;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Re-allocate the command line to length len + something extra."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  char_u *p = ccline.cmdbuff;", "  alloc_cmdbuff(len);                   /* will get some more */", "  /* There isn't always a NUL after the command, but it may need to be"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  alloc_cmdbuff(len);                   /* will get some more */", "  /* There isn't always a NUL after the command, but it may need to be", "   * there, thus copy up to the NUL and add a NUL. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "    /* If xp_pattern points inside the old cmdbuff it needs to be adjusted", "     * to point into the newly allocated memory. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["     * to point into the newly allocated memory. */", "    if (i >= 0 && i <= ccline.cmdlen)", "      ccline.xpc->xp_pattern = ccline.cmdbuff + i;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Draw part of the cmdline at the current cursor position.  But draw stars"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Put a character on the command line.  Shifts the following text to the"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Put the given string, of the given length, onto the command line."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (len < 0)", "    len = (int)STRLEN(str);"], "readability/braces"]
["src/nvim/ex_getln.c", ["    memmove(ccline.cmdbuff + ccline.cmdpos + len,", "        ccline.cmdbuff + ccline.cmdpos,", "        (size_t)(ccline.cmdlen - ccline.cmdpos));"], "whitespace/alignment"]
["src/nvim/ex_getln.c", ["        ccline.cmdbuff + ccline.cmdpos,", "        (size_t)(ccline.cmdlen - ccline.cmdpos));", "    ccline.cmdlen += len;"], "whitespace/alignment"]
["src/nvim/ex_getln.c", ["        len += i;", "      } else", "        i = 0;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    if (i != 0) {", "      /* Also backup the cursor position. */", "      i = ptr2cells(ccline.cmdbuff + ccline.cmdpos);"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["        msg_col += Columns;", "        --msg_row;", "      }"], "readability/increment"]
["src/nvim/ex_getln.c", ["  if (redraw && !cmd_silent) {", "    msg_no_more = TRUE;", "    i = cmdline_row;"], "readability/bool"]
["src/nvim/ex_getln.c", ["    draw_cmdline(ccline.cmdpos, ccline.cmdlen - ccline.cmdpos);", "    /* Avoid clearing the rest of the line too often. */", "    if (cmdline_row != i || ccline.overstrike)"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    /* Avoid clearing the rest of the line too often. */", "    if (cmdline_row != i || ccline.overstrike)", "      msg_clr_eos();"], "readability/braces"]
["src/nvim/ex_getln.c", ["      msg_clr_eos();", "    msg_no_more = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * Save ccline, because obtaining the \"=\" register may execute \"normal :cmd\""], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Restore ccline after it has been saved with save_cmdline()."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Save the command line into allocated memory.  Returns a pointer to be"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Restore the command line from the return value of save_cmdline_alloc()."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  /* check for valid regname; also accept special characters for CTRL-R in", "   * the command line */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  /* A register containing CTRL-R can cause an endless loop.  Allow using", "   * CTRL-C to break the loop. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  line_breakcheck();", "  if (got_int)", "    return FAIL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* Need to save and restore ccline.  And set \"textlock\" to avoid nasty", "   * things like going to another buffer when evaluating an expression. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  if (i) {", "    /* Got the value of a special register in \"arg\". */", "    if (arg == NULL)"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    /* Got the value of a special register in \"arg\". */", "    if (arg == NULL)", "      return FAIL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "    /* When 'incsearch' is set and CTRL-R CTRL-W used: skip the duplicate", "     * part of the word. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "      /* Locate start of last word in the cmd buffer. */", "      for (w = ccline.cmdbuff + ccline.cmdpos; w > ccline.cmdbuff; ) {"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      len = (int)((ccline.cmdbuff + ccline.cmdpos) - w);", "      if (p_ic ? STRNICMP(w, arg, len) == 0 : STRNCMP(w, arg, len) == 0)", "        p += len;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    cmdline_paste_str(p, literally);", "    if (allocated)", "      xfree(arg);"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Put a string on the command line."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (literally)", "    put_on_cmdline(s, -1, TRUE);"], "readability/braces"]
["src/nvim/ex_getln.c", ["  if (literally)", "    put_on_cmdline(s, -1, TRUE);", "  else"], "readability/bool"]
["src/nvim/ex_getln.c", ["    put_on_cmdline(s, -1, TRUE);", "  else", "    while (*s != NUL) {"], "readability/braces"]
["src/nvim/ex_getln.c", ["{", "  if (cmd_silent)", "    return;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    return;", "  need_wait_return = FALSE;", "  compute_cmdrow();"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "  if (cmd_silent)", "    return;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Redraw what is currently on the command line."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["{", "  if (cmd_silent)", "    return;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* when 'incsearch' is set there may be no command line while redrawing */", "  if (ccline.cmdbuff == NULL) {"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  /* Don't use more prompt, truncate the cmdline if it doesn't fit. */", "  msg_no_more = TRUE;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  /* Don't use more prompt, truncate the cmdline if it doesn't fit. */", "  msg_no_more = TRUE;", "  draw_cmdline(0, ccline.cmdlen);"], "readability/bool"]
["src/nvim/ex_getln.c", ["  msg_clr_eos();", "  msg_no_more = FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["", "  /*", "   * An emsg() before may have set msg_scroll. This is used in normal mode,"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["   */", "  msg_scroll = FALSE;           /* next message overwrites cmdline */", ""], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["   */", "  msg_scroll = FALSE;           /* next message overwrites cmdline */", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["{", "  if (cmd_silent)", "    return;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Check the word in front of the cursor for an abbreviation."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (*p1 != '<' && *p2 == '<') return -1;", "  if (*p1 == '<' && *p2 != '<') return 1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["  if (*p1 != '<' && *p2 == '<') return -1;", "  if (*p1 == '<' && *p2 != '<') return 1;", "  return STRCMP(p1, p2);"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Return FAIL if this is not an appropriate context in which to do"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", [" */", "static int ", "nextwild ("], "whitespace/end_of_line"]
["src/nvim/ex_getln.c", ["static int ", "nextwild (", "    expand_T *xp,"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["    int type,", "    int options,                    /* extra options for ExpandOne() */", "    int escape                     /* if TRUE, escape the returned matches */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    int options,                    /* extra options for ExpandOne() */", "    int escape                     /* if TRUE, escape the returned matches */", ")"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    beep_flush();", "    return OK;      /* Something illegal on command line */", "  }"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  if (xp->xp_context == EXPAND_NOTHING) {", "    /* Caller can use the character as a normal char instead */", "    return FAIL;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  /* When expanding a \":map\" command and no matches are found, assume that", "   * the key is supposed to be inserted literally */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["   * the key is supposed to be inserted literally */", "  if (xp->xp_context == EXPAND_MAPPINGS && p2 == NULL)", "    return FAIL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  if (xp->xp_numfiles <= 0 && p2 == NULL)", "    beep_flush();"], "readability/braces"]
["src/nvim/ex_getln.c", ["    beep_flush();", "  else if (xp->xp_numfiles == 1)", "    /* free expanded pattern */"], "readability/braces"]
["src/nvim/ex_getln.c", ["  else if (xp->xp_numfiles == 1)", "    /* free expanded pattern */", "    (void)ExpandOne(xp, NULL, NULL, 0, WILD_FREE);"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Do wildcard expansion on the string 'str'."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["char_u *", "ExpandOne (", "    expand_T *xp,"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["    char_u *str,", "    char_u *orig,          /* allocated copy of original of expanded string */", "    int options,"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  static int findex;", "  static char_u *orig_save = NULL;      /* kept value of orig */", "  int orig_saved = FALSE;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  static char_u *orig_save = NULL;      /* kept value of orig */", "  int orig_saved = FALSE;", "  int i;"], "readability/bool"]
["src/nvim/ex_getln.c", ["  int i;", "  int non_suf_match;                    /* number without matching suffix */", ""], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  /*", "   * first handle the case of using an old match"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      if (mode == WILD_PREV) {", "        if (findex == -1)", "          findex = xp->xp_numfiles;"], "readability/braces"]
["src/nvim/ex_getln.c", ["          findex = xp->xp_numfiles;", "        --findex;", "      } else        /* mode == WILD_NEXT */"], "readability/increment"]
["src/nvim/ex_getln.c", ["        --findex;", "      } else        /* mode == WILD_NEXT */", "        ++findex;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["        --findex;", "      } else        /* mode == WILD_NEXT */", "        ++findex;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      } else        /* mode == WILD_NEXT */", "        ++findex;", ""], "readability/increment"]
["src/nvim/ex_getln.c", ["", "      /*", "       * When wrapping around, return the original string, set findex to"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      if (findex < 0) {", "        if (orig_save == NULL)", "          findex = xp->xp_numfiles - 1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["          findex = xp->xp_numfiles - 1;", "        else", "          findex = -1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      if (findex >= xp->xp_numfiles) {", "        if (orig_save == NULL)", "          findex = 0;"], "readability/braces"]
["src/nvim/ex_getln.c", ["          findex = 0;", "        else", "          findex = -1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      return vim_strsave(xp->xp_files[findex]);", "    } else", "      return NULL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* free old names */", "  if (xp->xp_numfiles != -1 && mode != WILD_ALL && mode != WILD_LONGEST) {"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (mode == WILD_FREE)        /* only release file name */", "    return NULL;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (mode == WILD_FREE)        /* only release file name */", "    return NULL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    orig_save = orig;", "    orig_saved = TRUE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["", "    /*", "     * Do the expansion."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    if (ExpandFromContext(xp, str, &xp->xp_numfiles, &xp->xp_files,", "            options) == FAIL) {", "#ifdef FNAME_ILLEGAL"], "whitespace/alignment"]
["src/nvim/ex_getln.c", ["#ifdef FNAME_ILLEGAL", "      /* Illegal file name has been silently skipped.  But when there", "       * are wildcards, the real problem is that there was no match,"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["       */", "      if (!(options & WILD_SILENT) && (options & WILD_LIST_NOTFOUND))", "        EMSG2(_(e_nomatch2), str);"], "readability/braces"]
["src/nvim/ex_getln.c", ["    } else if (xp->xp_numfiles == 0) {", "      if (!(options & WILD_SILENT))", "        EMSG2(_(e_nomatch2), str);"], "readability/braces"]
["src/nvim/ex_getln.c", ["    } else {", "      /* Escape the matches for use on the command line. */", "      ExpandEscape(xp, str, xp->xp_numfiles, xp->xp_files, options);"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "      /*", "       * Check for matching suffixes in file names."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["          && mode != WILD_LONGEST) {", "        if (xp->xp_numfiles)", "          non_suf_match = xp->xp_numfiles;"], "readability/braces"]
["src/nvim/ex_getln.c", ["          non_suf_match = xp->xp_numfiles;", "        else", "          non_suf_match = 1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["            && xp->xp_numfiles > 1) {", "          /*", "           * More than one match; check suffix."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["          non_suf_match = 0;", "          for (i = 0; i < 2; ++i)", "            if (match_suffix(xp->xp_files[i]))"], "readability/braces"]
["src/nvim/ex_getln.c", ["          non_suf_match = 0;", "          for (i = 0; i < 2; ++i)", "            if (match_suffix(xp->xp_files[i]))"], "readability/increment"]
["src/nvim/ex_getln.c", ["          for (i = 0; i < 2; ++i)", "            if (match_suffix(xp->xp_files[i]))", "              ++non_suf_match;"], "readability/braces"]
["src/nvim/ex_getln.c", ["            if (match_suffix(xp->xp_files[i]))", "              ++non_suf_match;", "        }"], "readability/increment"]
["src/nvim/ex_getln.c", ["        if (non_suf_match != 1) {", "          /* Can we ever get here unless it's while expanding", "           * interactively?  If not, we can get rid of this all"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["           */", "          if (!(options & WILD_SILENT))", "            EMSG(_(e_toomany));"], "readability/braces"]
["src/nvim/ex_getln.c", ["            EMSG(_(e_toomany));", "          else if (!(options & WILD_NO_BEEP))", "            beep_flush();"], "readability/braces"]
["src/nvim/ex_getln.c", ["        }", "        if (!(non_suf_match != 1 && mode == WILD_EXPAND_FREE))", "          ss = vim_strsave(xp->xp_files[0]);"], "readability/braces"]
["src/nvim/ex_getln.c", ["    size_t len = 0;", "    for (i = 0; i < xp->xp_numfiles; ++i)", "      len += STRLEN(xp->xp_files[i]) + 1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    size_t len = 0;", "    for (i = 0; i < xp->xp_numfiles; ++i)", "      len += STRLEN(xp->xp_files[i]) + 1;"], "readability/increment"]
["src/nvim/ex_getln.c", ["    *ss = NUL;", "    for (i = 0; i < xp->xp_numfiles; ++i) {", "      STRCAT(ss, xp->xp_files[i]);"], "readability/increment"]
["src/nvim/ex_getln.c", ["      STRCAT(ss, xp->xp_files[i]);", "      if (i != xp->xp_numfiles - 1)", "        STRCAT(ss, (options & WILD_USE_NL) ? \"\\n\" : \" \");"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  if (mode == WILD_EXPAND_FREE || mode == WILD_ALL)", "    ExpandCleanup(xp);"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* Free \"orig\" if it wasn't stored in \"orig_save\". */", "  if (!orig_saved)"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  /* Free \"orig\" if it wasn't stored in \"orig_save\". */", "  if (!orig_saved)", "    xfree(orig);"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Prepare an expand structure for use."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Cleanup an expand structure after use."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "void ExpandEscape(expand_T *xp, char_u *str, int numfiles, char_u **files, int options)", "{"], "whitespace/line_length"]
["src/nvim/ex_getln.c", ["", "  /*", "   * May change home directory back to \"~\""], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["   */", "  if (options & WILD_HOME_REPLACE)", "    tilde_replace(str, numfiles, files);"], "readability/braces"]
["src/nvim/ex_getln.c", ["        || xp->xp_context == EXPAND_DIRECTORIES) {", "      /*", "       * Insert a backslash into a file name before a space, \\, %, #"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["       */", "      for (i = 0; i < numfiles; ++i) {", "        /* for \":set path=\" we need to escape spaces twice */"], "readability/increment"]
["src/nvim/ex_getln.c", ["      for (i = 0; i < numfiles; ++i) {", "        /* for \":set path=\" we need to escape spaces twice */", "        if (xp->xp_backslash == XP_BS_THREE) {"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "        /* If 'str' starts with \"\\~\", replace \"~\" at start of", "         * files[i] with \"\\~\". */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["         * files[i] with \"\\~\". */", "        if (str[0] == '\\\\' && str[1] == '~' && files[i][0] == '~')", "          escape_fname(&files[i]);"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "      /* If the first file starts with a '+' escape it.  Otherwise it", "       * could be seen as \"+cmd\". */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["       * could be seen as \"+cmd\". */", "      if (*files[0] == '+')", "        escape_fname(&files[0]);"], "readability/braces"]
["src/nvim/ex_getln.c", ["    } else if (xp->xp_context == EXPAND_TAGS) {", "      /*", "       * Insert a backslash before characters in a tag name that"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["       */", "      for (i = 0; i < numfiles; ++i) {", "        p = vim_strsave_escaped(files[i], (char_u *)\"\\\\|\\\"\");"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "/*", " * Put a backslash before the file name in \"pp\", which is in allocated memory."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * For each file name in files[num_files]:"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  if (orig_pat[0] == '~' && vim_ispathsep(orig_pat[1])) {", "    for (i = 0; i < num_files; ++i) {", "      p = home_replace_save(NULL, files[i]);"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "/*", " * Show all matches for completion on the command line."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    i = expand_cmdline(xp, ccline.cmdbuff, ccline.cmdpos,", "        &num_files, &files_found);", "    showtail = expand_showtail(xp);"], "whitespace/alignment"]
["src/nvim/ex_getln.c", ["    showtail = expand_showtail(xp);", "    if (i != EXPAND_OK)", "      return i;"], "readability/braces"]
["src/nvim/ex_getln.c", ["  if (!wildmenu) {", "    msg_didany = FALSE;                 /* lines_left will be set */", "    msg_start();                        /* prepare for paging */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  if (!wildmenu) {", "    msg_didany = FALSE;                 /* lines_left will be set */", "    msg_start();                        /* prepare for paging */"], "readability/bool"]
["src/nvim/ex_getln.c", ["    msg_didany = FALSE;                 /* lines_left will be set */", "    msg_start();                        /* prepare for paging */", "    msg_putchar('\\n');"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    cmdline_row = msg_row;", "    msg_didany = FALSE;                 /* lines_left will be set again */", "    msg_start();                        /* prepare for paging */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    cmdline_row = msg_row;", "    msg_didany = FALSE;                 /* lines_left will be set again */", "    msg_start();                        /* prepare for paging */"], "readability/bool"]
["src/nvim/ex_getln.c", ["    msg_didany = FALSE;                 /* lines_left will be set again */", "    msg_start();                        /* prepare for paging */", "  }"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    maxlen = 0;", "    for (i = 0; i < num_files; ++i) {", "      if (!showtail && (xp->xp_context == EXPAND_FILES"], "readability/increment"]
["src/nvim/ex_getln.c", ["                        || xp->xp_context == EXPAND_BUFFERS)) {", "        home_replace(NULL, files_found[i], NameBuff, MAXPATHL, TRUE);", "        j = vim_strsize(NameBuff);"], "readability/bool"]
["src/nvim/ex_getln.c", ["        j = vim_strsize(NameBuff);", "      } else", "        j = vim_strsize(L_SHOWFILE(i));"], "readability/braces"]
["src/nvim/ex_getln.c", ["        j = vim_strsize(L_SHOWFILE(i));", "      if (j > maxlen)", "        maxlen = j;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "    /* list the files line by line */", "    for (i = 0; i < lines; ++i) {"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    /* list the files line by line */", "    for (i = 0; i < lines; ++i) {", "      lastlen = 999;"], "readability/increment"]
["src/nvim/ex_getln.c", ["        }", "        for (j = maxlen - lastlen; --j >= 0; )", "          msg_putchar(' ');"], "readability/braces"]
["src/nvim/ex_getln.c", ["            || xp->xp_context == EXPAND_BUFFERS) {", "          /* highlight directories */", "          if (xp->xp_numfiles != -1) {"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["            home_replace(NULL, files_found[k], NameBuff, MAXPATHL,", "                TRUE);", "            p = NameBuff;"], "whitespace/alignment"]
["src/nvim/ex_getln.c", ["            home_replace(NULL, files_found[k], NameBuff, MAXPATHL,", "                TRUE);", "            p = NameBuff;"], "readability/bool"]
["src/nvim/ex_getln.c", ["        } else {", "          j = FALSE;", "          p = L_SHOWFILE(k);"], "readability/bool"]
["src/nvim/ex_getln.c", ["      }", "      if (msg_col > 0) {        /* when not wrapped around */", "        msg_clr_eos();"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      }", "      ui_flush();                          /* show one line at a time */", "      if (got_int) {"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      if (got_int) {", "        got_int = FALSE;", "        break;"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "    /*", "     * we redraw the command below the lines that we have just listed"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["     */", "    cmdline_row = msg_row;      /* will put it back later */", "  }"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (xp->xp_numfiles == -1)", "    FreeWild(num_files, files_found);"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Private path_tail for showmatches() (and win_redr_status_matches()):"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  char_u      *t = s;", "  int had_sep = FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["      t = p;", "      had_sep = FALSE;", "    }"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * Return TRUE if we only need to show the tail of completion matches."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  /* When not completing file names a \"/\" may mean something different. */", "  if (xp->xp_context != EXPAND_FILES"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  /* When not completing file names a \"/\" may mean something different. */", "  if (xp->xp_context != EXPAND_FILES", "      && xp->xp_context != EXPAND_SHELLCMD"], "readability/braces"]
["src/nvim/ex_getln.c", ["      && xp->xp_context != EXPAND_DIRECTORIES)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["  end = path_tail(xp->xp_pattern);", "  if (end == xp->xp_pattern)            /* there is no path separator */", "    return FALSE;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  end = path_tail(xp->xp_pattern);", "  if (end == xp->xp_pattern)            /* there is no path separator */", "    return FALSE;"], "readability/braces"]
["src/nvim/ex_getln.c", ["  if (end == xp->xp_pattern)            /* there is no path separator */", "    return FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["  for (s = xp->xp_pattern; s < end; s++) {", "    /* Skip escaped wildcards.  Only when the backslash is not a path", "    * separator, on DOS the '*' \"path\\*\\file\" must not be skipped. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    * separator, on DOS the '*' \"path\\*\\file\" must not be skipped. */", "    if (rem_backslash(s))", "      ++s;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    if (rem_backslash(s))", "      ++s;", "    else if (vim_strchr((char_u *)\"*?[\", *s) != NULL)"], "readability/increment"]
["src/nvim/ex_getln.c", ["      ++s;", "    else if (vim_strchr((char_u *)\"*?[\", *s) != NULL)", "      return FALSE;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    else if (vim_strchr((char_u *)\"*?[\", *s) != NULL)", "      return FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_getln.c", ["  }", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/ex_getln.c", ["      && context != EXPAND_DIRECTORIES) {", "    /*", "     * Matching will be done internally (on something other than files)."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      for (i = 0; i < len; i++) {", "        if (fname[i] == '*' || fname[i] == '~')", "          new_len++;                    /* '*' needs to be replaced by \".*\""], "readability/braces"]
["src/nvim/ex_getln.c", ["        if (fname[i] == '*' || fname[i] == '~')", "          new_len++;                    /* '*' needs to be replaced by \".*\"", "                                           '~' needs to be replaced by \"\\~\" */"], "readability/multiline_comment"]
["src/nvim/ex_getln.c", ["        if (fname[i] == '*' || fname[i] == '~')", "          new_len++;                    /* '*' needs to be replaced by \".*\"", "                                           '~' needs to be replaced by \"\\~\" */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "        /* Buffer names are like file names.  \".\" should be literal */", "        if (context == EXPAND_BUFFERS && fname[i] == '.')"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["        /* Buffer names are like file names.  \".\" should be literal */", "        if (context == EXPAND_BUFFERS && fname[i] == '.')", "          new_len++;                    /* \".\" becomes \"\\.\" */"], "readability/braces"]
["src/nvim/ex_getln.c", ["        if (context == EXPAND_BUFFERS && fname[i] == '.')", "          new_len++;                    /* \".\" becomes \"\\.\" */", ""], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "        /* Custom expansion takes care of special things, match", "         * backslashes literally (perhaps also for other types?) */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["         * backslashes literally (perhaps also for other types?) */", "        if ((context == EXPAND_USER_DEFINED", "             || context == EXPAND_USER_LIST) && fname[i] == '\\\\')"], "readability/braces"]
["src/nvim/ex_getln.c", ["             || context == EXPAND_USER_LIST) && fname[i] == '\\\\')", "          new_len++;                    /* '\\' becomes \"\\\\\" */", "      }"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["        for (i = 0; i < len; i++, j++) {", "          /* Skip backslash.  But why?  At least keep it for custom", "           * expansion. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["           * expansion. */", "          if (context != EXPAND_USER_DEFINED", "              && context != EXPAND_USER_LIST"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "    /*", "     * Don't add a star to *, ~, ~user, $var or `cmd`."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["#endif", "    if ((*retval != '~' || tail != retval)", "        && !ends_in_star"], "readability/braces"]
["src/nvim/ex_getln.c", ["      retval[len++] = '*';", "    else if (len > 0 && retval[len - 1] == '$')", "      --len;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    else if (len > 0 && retval[len - 1] == '$')", "      --len;", "    retval[len] = NUL;"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "/*", " * Must parse the command line so far to work out what context we are in."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["{", "  /* only expansion for ':', '>' and '=' command-lines */", "  if (ccline.cmdfirstc != ':'"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "void ", "set_cmd_context ("], "whitespace/end_of_line"]
["src/nvim/ex_getln.c", ["void ", "set_cmd_context (", "    expand_T *xp,"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["", "  /*", "   * Avoid a UMR warning from Purify, only save the character if it has been"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["   */", "  if (col < len)", "    old_char = str[col];"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* Store the string here so that call_user_expand_func() can get to them", "   * easily. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Expand the command line \"str\" from context \"xp\"."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", [" */", "int ", "expand_cmdline ("], "whitespace/end_of_line"]
["src/nvim/ex_getln.c", ["int ", "expand_cmdline (", "    expand_T *xp,"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["    expand_T *xp,", "    char_u *str,               /* start of command line */", "    int col,                        /* position of cursor */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    char_u *str,               /* start of command line */", "    int col,                        /* position of cursor */", "    int *matchcount,        /* return: nr of matches */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    int col,                        /* position of cursor */", "    int *matchcount,        /* return: nr of matches */", "    char_u ***matches         /* return: array of pointers to matches */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    int *matchcount,        /* return: nr of matches */", "    char_u ***matches         /* return: array of pointers to matches */", ")"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    beep_flush();", "    return EXPAND_UNSUCCESSFUL;      /* Something illegal on command line */", "  }"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  if (xp->xp_context == EXPAND_NOTHING) {", "    /* Caller can use the character as a normal char instead */", "    return EXPAND_NOTHING;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (p_wic)", "    options += WILD_ICASE;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* find all files that match the description */", "  if (ExpandFromContext(xp, file_str, matchcount, matches, options) == FAIL) {"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Do the expansion based on xp->xp_context and \"pat\"."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", [" */", "static int ", "ExpandFromContext ("], "whitespace/end_of_line"]
["src/nvim/ex_getln.c", ["static int ", "ExpandFromContext (", "    expand_T *xp,"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["", "  flags = EW_DIR;       /* include directories */", "  if (options & WILD_LIST_NOTFOUND)"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  flags = EW_DIR;       /* include directories */", "  if (options & WILD_LIST_NOTFOUND)", "    flags |= EW_NOTFOUND;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    flags |= EW_NOTFOUND;", "  if (options & WILD_ADD_SLASH)", "    flags |= EW_ADDSLASH;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    flags |= EW_ADDSLASH;", "  if (options & WILD_KEEP_ALL)", "    flags |= EW_KEEPALL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    flags |= EW_KEEPALL;", "  if (options & WILD_SILENT)", "    flags |= EW_SILENT;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      || xp->xp_context == EXPAND_FILES_IN_PATH) {", "    /*", "     * Expand file or directory names."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["     */", "    int free_pat = FALSE;", "    int i;"], "readability/bool"]
["src/nvim/ex_getln.c", ["    if (xp->xp_backslash != XP_BS_NONE) {", "      free_pat = TRUE;", "      pat = vim_strsave(pat);"], "readability/bool"]
["src/nvim/ex_getln.c", ["      pat = vim_strsave(pat);", "      for (i = 0; pat[i]; ++i)", "        if (pat[i] == '\\\\') {"], "readability/braces"]
["src/nvim/ex_getln.c", ["      pat = vim_strsave(pat);", "      for (i = 0; pat[i]; ++i)", "        if (pat[i] == '\\\\') {"], "readability/increment"]
["src/nvim/ex_getln.c", ["        if (pat[i] == '\\\\') {", "          if (xp->xp_backslash == XP_BS_THREE", "              && pat[i + 1] == '\\\\'"], "readability/braces"]
["src/nvim/ex_getln.c", ["            STRMOVE(pat + i, pat + i + 3);", "          if (xp->xp_backslash == XP_BS_ONE", "              && pat[i + 1] == ' ')"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "    if (xp->xp_context == EXPAND_FILES)", "      flags |= EW_FILE;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      flags |= EW_FILE;", "    else if (xp->xp_context == EXPAND_FILES_IN_PATH)", "      flags |= (EW_FILE | EW_PATH);"], "readability/braces"]
["src/nvim/ex_getln.c", ["      flags |= (EW_FILE | EW_PATH);", "    else", "      flags = (flags | EW_DIR) & ~EW_FILE;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      flags = (flags | EW_DIR) & ~EW_FILE;", "    if (options & WILD_ICASE)", "      flags |= EW_ICASE;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "    /* Expand wildcards, supporting %:h and the like. */", "    ret = expand_wildcards_eval(&pat, num_file, file, flags);"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    ret = expand_wildcards_eval(&pat, num_file, file, flags);", "    if (free_pat)", "      xfree(pat);"], "readability/braces"]
["src/nvim/ex_getln.c", ["  if (xp->xp_context == EXPAND_HELP) {", "    /* With an empty argument we would get all the help tags, which is", "     * very slow.  Get matches for \"help\" instead. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  }", "  if (xp->xp_context == EXPAND_BUFFERS)", "    return ExpandBufnames(pat, num_file, file, options);"], "readability/braces"]
["src/nvim/ex_getln.c", ["  regmatch.regprog = vim_regcomp(pat, p_magic ? RE_MAGIC : 0);", "  if (regmatch.regprog == NULL)", "    return FAIL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* set ignore-case according to p_ic, p_scs and pat */", "  regmatch.rm_ic = ignorecase(pat);"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (xp->xp_context == EXPAND_SETTINGS", "      || xp->xp_context == EXPAND_BOOL_SETTINGS)"], "readability/braces"]
["src/nvim/ex_getln.c", ["    ret = ExpandSettings(xp, &regmatch, num_file, file);", "  else if (xp->xp_context == EXPAND_MAPPINGS)", "    ret = ExpandMappings(&regmatch, num_file, file);"], "readability/braces"]
["src/nvim/ex_getln.c", ["    ret = ExpandMappings(&regmatch, num_file, file);", "  else if (xp->xp_context == EXPAND_USER_DEFINED)", "    ret = ExpandUserDefined(xp, &regmatch, num_file, file);"], "readability/braces"]
["src/nvim/ex_getln.c", ["    ret = ExpandUserDefined(xp, &regmatch, num_file, file);", "  else {", "    static struct expgen {"], "readability/braces"]
["src/nvim/ex_getln.c", ["    ret = ExpandUserDefined(xp, &regmatch, num_file, file);", "  else {", "    static struct expgen {"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "    /*", "     * Find a context in the table and call the ExpandGeneric() with the"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    ret = FAIL;", "    for (i = 0; i < (int)ARRAY_SIZE(tab); ++i)", "      if (xp->xp_context == tab[i].context) {"], "readability/braces"]
["src/nvim/ex_getln.c", ["    ret = FAIL;", "    for (i = 0; i < (int)ARRAY_SIZE(tab); ++i)", "      if (xp->xp_context == tab[i].context) {"], "readability/increment"]
["src/nvim/ex_getln.c", ["        if (tab[i].ic) {", "          regmatch.rm_ic = TRUE;", "        }"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * Expand a list of names."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    int escaped", "    )", "{"], "whitespace/indent"]
["src/nvim/ex_getln.c", ["    char_u      ***file,", "    CompleteListItemGetter func, /* returns a string from the list */", "    int escaped"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  // count the number of matching names", "  for (i = 0;; ++i) {", "    str = (*func)(xp, i);"], "readability/increment"]
["src/nvim/ex_getln.c", ["    str = (*func)(xp, i);", "    if (str == NULL) // end of list", "      break;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    str = (*func)(xp, i);", "    if (str == NULL) // end of list", "      break;"], "whitespace/comments"]
["src/nvim/ex_getln.c", ["      break;", "    if (*str == NUL) // skip empty strings", "      continue;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      break;", "    if (*str == NUL) // skip empty strings", "      continue;"], "whitespace/comments"]
["src/nvim/ex_getln.c", ["    if (vim_regexec(regmatch, str, (colnr_T)0)) {", "      ++count;", "    }"], "readability/increment"]
["src/nvim/ex_getln.c", ["  }", "  if (count == 0)", "    return;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* Sort the results.  Keep menu's in the specified order. */", "  if (xp->xp_context != EXPAND_MENUNAMES && xp->xp_context != EXPAND_MENUS) {"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  if (xp->xp_context != EXPAND_MENUNAMES && xp->xp_context != EXPAND_MENUS) {", "    if (xp->xp_context == EXPAND_EXPRESSION", "        || xp->xp_context == EXPAND_FUNCTIONS"], "readability/braces"]
["src/nvim/ex_getln.c", ["        || xp->xp_context == EXPAND_USER_FUNC)", "      /* <SNR> functions should be sorted to the end. */", "      qsort((void *)*file, (size_t)*num_file, sizeof(char_u *),"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      /* <SNR> functions should be sorted to the end. */", "      qsort((void *)*file, (size_t)*num_file, sizeof(char_u *),", "          sort_func_compare);"], "whitespace/operators"]
["src/nvim/ex_getln.c", ["      qsort((void *)*file, (size_t)*num_file, sizeof(char_u *),", "          sort_func_compare);", "    else"], "whitespace/alignment"]
["src/nvim/ex_getln.c", ["          sort_func_compare);", "    else", "      sort_strings(*file, *num_file);"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* Reset the variables used for special highlight names expansion, so that", "   * they don't show up when getting normal highlight names by ID. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  pat = vim_strsave(filepat);", "  for (i = 0; pat[i]; ++i)", "    if (pat[i] == '\\\\' && pat[i + 1] == ' ')"], "readability/braces"]
["src/nvim/ex_getln.c", ["  pat = vim_strsave(filepat);", "  for (i = 0; pat[i]; ++i)", "    if (pat[i] == '\\\\' && pat[i + 1] == ' ')"], "readability/increment"]
["src/nvim/ex_getln.c", ["  for (i = 0; pat[i]; ++i)", "    if (pat[i] == '\\\\' && pat[i + 1] == ' ')", "      STRMOVE(pat + i, pat + i + 1);"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /*", "   * Go over all directories in $PATH.  Expand matches in that directory and"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "    /* Expand matches in one directory of $PATH. */", "    ret = expand_wildcards(1, &buf, num_file, file, flags);"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    }", "    if (*e != NUL)", "      ++e;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    if (*e != NUL)", "      ++e;", "  }"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "  if (xp->xp_arg == NULL || xp->xp_arg[0] == '\\0' || xp->xp_line == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* Save the cmdline, we don't know what the function may do. */", "  save_ccline = ccline;"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Expand names with a function defined by the user."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", [" */", "static int ExpandUserDefined(expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file)", "{"], "whitespace/line_length"]
["src/nvim/ex_getln.c", ["    e = vim_strchr(s, '\\n');", "    if (e == NULL)", "      e = s + STRLEN(s);"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Expand names with a list returned by a function defined by the user."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (GA_EMPTY(&ga))", "    return FAIL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* Sort and remove duplicates which can happen when specifying multiple", "   * directories in dirnames. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*********************************", "*  Command line history stuff\t *"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Table of history names."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the possible first"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  }", "  if (idx < short_names_count + history_name_count)", "    return (char_u *)history_names[idx - short_names_count];"], "readability/braces"]
["src/nvim/ex_getln.c", ["    return (char_u *)history_names[idx - short_names_count];", "  if (idx == short_names_count + history_name_count)", "    return (char_u *)\"all\";"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Check if command line 'str' is already in history."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", [" */", "static int ", "in_history ("], "whitespace/end_of_line"]
["src/nvim/ex_getln.c", ["static int ", "in_history (", "    int type,"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["", "  if (hisidx[type] < 0)", "    return FALSE;"], "readability/braces"]
["src/nvim/ex_getln.c", ["  if (hisidx[type] < 0)", "    return FALSE;", "  i = hisidx[type];"], "readability/bool"]
["src/nvim/ex_getln.c", ["  do {", "    if (history[type][i].hisstr == NULL)", "      return FALSE;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    if (history[type][i].hisstr == NULL)", "      return FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["", "    /* For search history, check that the separator character matches as", "     * well. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["        && (type != HIST_SEARCH || sep == p[STRLEN(p) + 1])) {", "      if (!move_to_front)", "        return TRUE;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      if (!move_to_front)", "        return TRUE;", "      last_i = i;"], "readability/bool"]
["src/nvim/ex_getln.c", ["    }", "    if (--i < 0)", "      i = hislen - 1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    while (i != hisidx[type]) {", "      if (++i >= hislen)", "        i = 0;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "static int last_maptick = -1;           /* last seen maptick */", ""], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Add the given string to the given history.  If the string is already in the"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", [" */", "void ", "add_to_history ("], "whitespace/end_of_line"]
["src/nvim/ex_getln.c", ["void ", "add_to_history (", "    int histype,"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["    char_u *new_entry,", "    int in_map,                     /* consider maptick when inside a mapping */", "    int sep                        /* separator character used (search hist) */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    int in_map,                     /* consider maptick when inside a mapping */", "    int sep                        /* separator character used (search hist) */", ")"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (cmdmod.keeppatterns && histype == HIST_SEARCH)", "    return;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /*", "   * Searches inside the same mapping overwrite each other, so that only"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      hist_free_entry(hisptr);", "      --hisnum[histype];", "      if (--hisidx[HIST_SEARCH] < 0)"], "readability/increment"]
["src/nvim/ex_getln.c", ["      --hisnum[histype];", "      if (--hisidx[HIST_SEARCH] < 0)", "        hisidx[HIST_SEARCH] = hislen - 1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["  if (!in_history(histype, new_entry, true, sep)) {", "    if (++hisidx[histype] == hislen)", "      hisidx[histype] = 0;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    hisptr->hisnum = ++hisnum[histype];", "    if (histype == HIST_SEARCH && in_map)", "      last_maptick = maptick;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Get identifier of newest history entry."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["{", "  if (hislen == 0 || histype < 0 || histype >= HIST_COUNT", "      || hisidx[histype] < 0)"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Get pointer to the command line info to use. cmdline_paste() may clear"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Get the current command line in allocated memory."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (p == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Get the current command line position, counted in bytes."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (p == NULL)", "    return -1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Set the command line byte position to \"pos\".  Zero is the first position."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (p == NULL)", "    return 1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* The position is not set directly but after CTRL-\\ e or CTRL-R = has", "   * changed the command line. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["   * changed the command line. */", "  if (pos < 0)", "    new_cmdpos = 0;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    new_cmdpos = 0;", "  else", "    new_cmdpos = pos;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Get the current command-line type."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  if (p == NULL)", "    return NUL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    return NUL;", "  if (p->cmdfirstc == NUL)", "    return (p->input_fn) ? '@' : '-';"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Calculate history index from a number:"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  histentry_T *hist;", "  int wrapped = FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["", "  if (hislen == 0 || histype < 0 || histype >= HIST_COUNT", "      || (i = hisidx[histype]) < 0 || num == 0)"], "readability/braces"]
["src/nvim/ex_getln.c", ["  if (num > 0) {", "    while (hist[i].hisnum > num)", "      if (--i < 0) {"], "readability/braces"]
["src/nvim/ex_getln.c", ["      if (--i < 0) {", "        if (wrapped)", "          break;"], "readability/braces"]
["src/nvim/ex_getln.c", ["        i += hislen;", "        wrapped = TRUE;", "      }"], "readability/bool"]
["src/nvim/ex_getln.c", ["      }", "    if (hist[i].hisnum == num && hist[i].hisstr != NULL)", "      return i;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    i += num + 1;", "    if (i < 0)", "      i += hislen;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      i += hislen;", "    if (hist[i].hisstr != NULL)", "      return i;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Get a history entry by its index."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  idx = calc_hist_idx(histype, idx);", "  if (idx >= 0)", "    return history[histype][idx].hisstr;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    return history[histype][idx].hisstr;", "  else", "    return (char_u *)\"\";"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Remove all entries matching {str} from a history."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  regmatch.regprog = NULL;", "  regmatch.rm_ic = FALSE;       /* always match case */", "  if (hislen != 0"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  regmatch.regprog = NULL;", "  regmatch.rm_ic = FALSE;       /* always match case */", "  if (hislen != 0"], "readability/bool"]
["src/nvim/ex_getln.c", ["      hisptr = &history[histype][i];", "      if (hisptr->hisstr == NULL)", "        break;"], "readability/braces"]
["src/nvim/ex_getln.c", ["        }", "        if (--last < 0)", "          last += hislen;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      }", "      if (--i < 0)", "        i += hislen;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    } while (i != idx);", "    if (history[histype][idx].hisstr == NULL)", "      hisidx[histype] = -1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "/*", " * Remove an indexed entry from a history."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  i = calc_hist_idx(histype, idx);", "  if (i < 0)", "    return FALSE;"], "readability/braces"]
["src/nvim/ex_getln.c", ["  if (i < 0)", "    return FALSE;", "  idx = hisidx[histype];"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "  /* When deleting the last added search string in a mapping, reset", "   * last_maptick, so that the last added search string isn't deleted again."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["   */", "  if (histype == HIST_SEARCH && maptick == last_maptick && i == idx)", "    last_maptick = -1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["  hisidx[histype] = i;", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * :history command - print a history"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    end = arg;", "    while (ASCII_ISALPHA(*end)", "           || vim_strchr((char_u *)\":=@>/?\", *end) != NULL)"], "readability/braces"]
["src/nvim/ex_getln.c", ["      }", "    } else", "      histype2 = histype1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  for (; !got_int && histype1 <= histype2; ++histype1) {", "    STRCPY(IObuff, \"\\n      #  \");"], "readability/increment"]
["src/nvim/ex_getln.c", ["    k = hisidx2;", "    if (j < 0)", "      j = (-j > hislen) ? 0 : hist[(hislen+j+idx+1) % hislen].hisnum;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      j = (-j > hislen) ? 0 : hist[(hislen+j+idx+1) % hislen].hisnum;", "    if (k < 0)", "      k = (-k > hislen) ? 0 : hist[(hislen+k+idx+1) % hislen].hisnum;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      k = (-k > hislen) ? 0 : hist[(hislen+k+idx+1) % hislen].hisnum;", "    if (idx >= 0 && j <= k)", "      for (i = idx + 1; !got_int; ++i) {"], "readability/braces"]
["src/nvim/ex_getln.c", ["    if (idx >= 0 && j <= k)", "      for (i = idx + 1; !got_int; ++i) {", "        if (i == hislen)"], "readability/increment"]
["src/nvim/ex_getln.c", ["      for (i = idx + 1; !got_int; ++i) {", "        if (i == hislen)", "          i = 0;"], "readability/braces"]
["src/nvim/ex_getln.c", ["        }", "        if (i == idx)", "          break;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* Can't do this recursively.  Can't do it when typing a password. */", "  if (cmdwin_type != 0"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      do {", "        if (++i == hislen)", "          i = 0;"], "readability/braces"]
["src/nvim/ex_getln.c", ["", "  /* Replace the empty last line with the current command-line and put the", "   * cursor there. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  /*", "   * Call the main loop until <CR> or CTRL-C is typed."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  /* Safety check: The old window or buffer was deleted: It's a bug when", "   * this happens! */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  } else {", "    /* autocmds may abort script processing */", "    if (aborting() && cmdwin_result != K_IGNORE)"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    /* autocmds may abort script processing */", "    if (aborting() && cmdwin_result != K_IGNORE)", "      cmdwin_result = Ctrl_C;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      cmdwin_result = Ctrl_C;", "    /* Set the new command line from the cmdline buffer. */", "    xfree(ccline.cmdbuff);"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    } else if (cmdwin_result == Ctrl_C) {", "      /* :q or :close, don't execute any command", "       * and don't modify the cmd window. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      ccline.cmdbuff = NULL;", "    } else", "      ccline.cmdbuff = vim_strsave(get_cursor_line_ptr());"], "readability/braces"]
["src/nvim/ex_getln.c", ["      ccline.cmdpos = curwin->w_cursor.col;", "      if (ccline.cmdpos > ccline.cmdlen)", "        ccline.cmdpos = ccline.cmdlen;"], "readability/braces"]
["src/nvim/ex_getln.c", ["  } else {", "    hiter = (histentry_T *) iter;", "  }"], "whitespace/cast"]
["src/nvim/ex_getln.c", ["  hiter++;", "  return (const void *) ((hiter > hend) ? hstart : hiter);", "}"], "whitespace/cast"]
["src/nvim/ex_getln.h", ["", "/* Values for nextwild() and ExpandOne().  See ExpandOne() for meaning. */", "#define WILD_FREE               1"], "readability/old_style_comment"]
["src/nvim/extmark.c", ["  static Map(uint64_t, ssize_t) *delete_set = NULL;", "  typedef struct { Decoration *decor; int row1; } DecorItem;", "  static kvec_t(DecorItem) decors;"], "whitespace/newline"]
["src/nvim/file_search.c", ["", "static char_u   *ff_expand_buffer = NULL; /* used for expanding filenames */", ""], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * type for the directory search stack"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* the fix part (no wildcards) and the part containing the wildcards", "   * of the search path"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* files/dirs found in the above directory, matched by the first wildcard", "   * of wc_part"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  int ffs_filearray_size;", "  char_u ffs_filearray_cur;                  /* needed for partly handled dirs */", ""], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  int ffs_filearray_size;", "  char_u ffs_filearray_cur;                  /* needed for partly handled dirs */", ""], "whitespace/line_length"]
["src/nvim/file_search.c", ["", "  /* to store status of partly handled directories", "   * 0: we work on this directory for the first time"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* How deep are we in the directory tree?", "   * Counts backward from value of level parameter to vim_findfile_init"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* Did we already expand '**' to an empty string? */", "  int ffs_star_star_empty;"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * type for already visited directories or files."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* Visited directories are different if the wildcard string are", "   * different. So we have to save it."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  FileID file_id;", "  /* The memory for this struct is allocated according to the length of", "   * ffv_fname."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["   */", "  char_u ffv_fname[1];                  /* actually longer */", "} ff_visited_T;"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * We might have to manage several visited lists during a search."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* the filename the attached visited list is for */", "  char_u                      *ffvl_filename;"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  ff_visited_T                *ffvl_visited_list;", "", "} ff_visited_list_hdr_T;"], "whitespace/blank_line"]
["src/nvim/file_search.c", ["", "/*", " * '**' can be expanded to several directory levels."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * The search context:"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/* locally needed functions */", ""], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * Initialization routine for vim_findfile()."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["void *", "vim_findfile_init (", "    char_u *path,"], "whitespace/parens"]
["src/nvim/file_search.c", ["    void *search_ctx_arg,", "    int tagfile,                    /* expanding names of tags files */", "    char_u *rel_fname         /* file name to use for \".\" */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    int tagfile,                    /* expanding names of tags files */", "    char_u *rel_fname         /* file name to use for \".\" */", ")"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* If a search context is given by the caller, reuse it, else allocate a", "   * new one."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["   */", "  if (search_ctx_arg != NULL)", "    search_ctx = search_ctx_arg;"], "readability/braces"]
["src/nvim/file_search.c", ["    search_ctx = search_ctx_arg;", "  else {", "    search_ctx = xcalloc(1, sizeof(ff_search_ctx_T));"], "readability/braces"]
["src/nvim/file_search.c", ["    search_ctx = search_ctx_arg;", "  else {", "    search_ctx = xcalloc(1, sizeof(ff_search_ctx_T));"], "readability/braces"]
["src/nvim/file_search.c", ["", "  /* clear the search context, but NOT the visited lists */", "  ff_clear(search_ctx);"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* clear visited list if wanted */", "  if (free_visited == TRUE)"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  /* clear visited list if wanted */", "  if (free_visited == TRUE)", "    vim_findfile_free_visited(search_ctx);"], "readability/braces"]
["src/nvim/file_search.c", ["  /* clear visited list if wanted */", "  if (free_visited == TRUE)", "    vim_findfile_free_visited(search_ctx);"], "readability/bool"]
["src/nvim/file_search.c", ["    vim_findfile_free_visited(search_ctx);", "  else {", "    /* Reuse old visited lists. Get the visited list for the given"], "readability/braces"]
["src/nvim/file_search.c", ["    vim_findfile_free_visited(search_ctx);", "  else {", "    /* Reuse old visited lists. Get the visited list for the given"], "readability/braces"]
["src/nvim/file_search.c", ["  else {", "    /* Reuse old visited lists. Get the visited list for the given", "     * filename. If no list for the current filename exists, creates a new"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    search_ctx->ffsc_visited_list = ff_get_visited_list(filename,", "        &search_ctx->ffsc_visited_lists_list);", "    if (search_ctx->ffsc_visited_list == NULL)"], "whitespace/alignment"]
["src/nvim/file_search.c", ["        &search_ctx->ffsc_visited_lists_list);", "    if (search_ctx->ffsc_visited_list == NULL)", "      goto error_return;"], "readability/braces"]
["src/nvim/file_search.c", ["    search_ctx->ffsc_dir_visited_list = ff_get_visited_list(filename,", "        &search_ctx->ffsc_dir_visited_lists_list);", "    if (search_ctx->ffsc_dir_visited_list == NULL)"], "whitespace/alignment"]
["src/nvim/file_search.c", ["        &search_ctx->ffsc_dir_visited_lists_list);", "    if (search_ctx->ffsc_dir_visited_list == NULL)", "      goto error_return;"], "readability/braces"]
["src/nvim/file_search.c", ["", "  /* Store information on starting dir now if path is relative.", "   * If path is absolute, we do that later.  */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    if (!vim_isAbsName(rel_fname) && len + 1 < MAXPATHL) {", "      /* Make the start dir an absolute path name. */", "      STRLCPY(ff_expand_buffer, rel_fname, len + 1);"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["      STRLCPY(ff_expand_buffer, rel_fname, len + 1);", "      search_ctx->ffsc_start_dir = (char_u *)FullName_save((char *)ff_expand_buffer, FALSE);", "    } else"], "whitespace/line_length"]
["src/nvim/file_search.c", ["      STRLCPY(ff_expand_buffer, rel_fname, len + 1);", "      search_ctx->ffsc_start_dir = (char_u *)FullName_save((char *)ff_expand_buffer, FALSE);", "    } else"], "readability/bool"]
["src/nvim/file_search.c", ["      search_ctx->ffsc_start_dir = (char_u *)FullName_save((char *)ff_expand_buffer, FALSE);", "    } else", "      search_ctx->ffsc_start_dir = vim_strnsave(rel_fname, len);"], "readability/braces"]
["src/nvim/file_search.c", ["      search_ctx->ffsc_start_dir = vim_strnsave(rel_fname, len);", "    if (*++path != NUL)", "      ++path;"], "readability/braces"]
["src/nvim/file_search.c", ["    if (*++path != NUL)", "      ++path;", "  } else if (*path == NUL || !vim_isAbsName(path)) {"], "readability/increment"]
["src/nvim/file_search.c", ["#ifdef BACKSLASH_IN_FILENAME", "    /* \"c:dir\" needs \"c:\" to be expanded, otherwise use current dir */", "    if (*path != NUL && path[1] == ':') {"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["      path += 2;", "    } else", "#endif"], "readability/braces"]
["src/nvim/file_search.c", ["#endif", "    if (os_dirname(ff_expand_buffer, MAXPATHL) == FAIL)", "      goto error_return;"], "readability/braces"]
["src/nvim/file_search.c", ["#ifdef BACKSLASH_IN_FILENAME", "    /* A path that starts with \"/dir\" is relative to the drive, not to the", "     * directory (but not for \"//machine/dir\").  Only use the drive name. */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["     * directory (but not for \"//machine/dir\").  Only use the drive name. */", "    if ((*path == '/' || *path == '\\\\')", "        && path[1] != path[0]"], "readability/braces"]
["src/nvim/file_search.c", ["", "  /*", "   * If stopdirs are given, split them into an array of pointers."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "    while (*walker == ';')", "      walker++;"], "readability/braces"]
["src/nvim/file_search.c", ["      ptr = xrealloc(search_ctx->ffsc_stopdirs_v,", "          (dircount + 1) * sizeof(char_u *));", "      search_ctx->ffsc_stopdirs_v = ptr;"], "whitespace/alignment"]
["src/nvim/file_search.c", ["        walker++;", "      } else", "        /* this might be \"\", which means ascent till top"], "readability/braces"]
["src/nvim/file_search.c", ["      } else", "        /* this might be \"\", which means ascent till top", "         * of directory tree."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["      dircount++;", "", "    } while (walker != NULL);"], "whitespace/blank_line"]
["src/nvim/file_search.c", ["", "  /* split into:", "   *  -fix path"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "    /* save the fix part of the path */", "    assert(wc_part - path >= 0);"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "    /*", "     * copy wc_path and add restricts to the '**' wildcard."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["        llevel = strtol((char *)wc_part, &errpt, 10);", "        if ((char_u *)errpt != wc_part && llevel > 0 && llevel < 255)", "          ff_expand_buffer[len++] = (char_u)llevel;"], "readability/braces"]
["src/nvim/file_search.c", ["          ff_expand_buffer[len++] = (char_u)llevel;", "        else if ((char_u *)errpt != wc_part && llevel == 0)", "          /* restrict is 0 -> remove already added '**' */"], "readability/braces"]
["src/nvim/file_search.c", ["        else if ((char_u *)errpt != wc_part && llevel == 0)", "          /* restrict is 0 -> remove already added '**' */", "          len -= 2;"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["          len -= 2;", "        else", "          ff_expand_buffer[len++] = FF_MAX_STAR_STAR_EXPAND;"], "readability/braces"]
["src/nvim/file_search.c", ["          EMSG2(_(", "                  \"E343: Invalid path: '**[number]' must be at the end of the path or be followed by '%s'.\"),", "              PATHSEPSTR);"], "whitespace/indent"]
["src/nvim/file_search.c", ["                  \"E343: Invalid path: '**[number]' must be at the end of the path or be followed by '%s'.\"),", "              PATHSEPSTR);", "          goto error_return;"], "whitespace/alignment"]
["src/nvim/file_search.c", ["          EMSG2(_(", "                  \"E343: Invalid path: '**[number]' must be at the end of the path or be followed by '%s'.\"),", "              PATHSEPSTR);"], "whitespace/line_length"]
["src/nvim/file_search.c", ["        }", "      } else", "        ff_expand_buffer[len++] = *wc_part++;"], "readability/braces"]
["src/nvim/file_search.c", ["    search_ctx->ffsc_wc_path = vim_strsave(ff_expand_buffer);", "  } else", "    search_ctx->ffsc_fix_path = vim_strsave(path);"], "readability/braces"]
["src/nvim/file_search.c", ["  if (search_ctx->ffsc_start_dir == NULL) {", "    /* store the fix part as startdir.", "     * This is needed if the parameter path is fully qualified."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* create an absolute path */", "  if (STRLEN(search_ctx->ffsc_start_dir)"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["        len = (int)(p - search_ctx->ffsc_fix_path) - 1;", "        STRNCAT(ff_expand_buffer, search_ctx->ffsc_fix_path, len);", "        add_pathsep((char *)ff_expand_buffer);"], "runtime/printf"]
["src/nvim/file_search.c", ["  sptr = ff_create_stack_element(ff_expand_buffer,", "      search_ctx->ffsc_wc_path,", "      level, 0);"], "whitespace/alignment"]
["src/nvim/file_search.c", ["      search_ctx->ffsc_wc_path,", "      level, 0);", ""], "whitespace/alignment"]
["src/nvim/file_search.c", ["error_return:", "  /*", "   * We clear the search context now!"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * Get the stopdir string.  Check that ';' is not escaped."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    if (r_ptr[0] == '\\\\' && r_ptr[1] == ';') {", "      /* Overwrite the escape char,", "       * use STRLEN(r_ptr) to move the trailing '\\0'. */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    r_ptr++;", "  } else if (*r_ptr == NUL)", "    r_ptr = NULL;"], "readability/braces"]
["src/nvim/file_search.c", ["", "/*", " * Clean up the given search context. Can handle a NULL pointer."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["{", "  if (ctx == NULL)", "    return;"], "readability/braces"]
["src/nvim/file_search.c", ["", "/*", " * Find a file in a search context."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  if (search_ctx_arg == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/file_search.c", ["", "  /*", "   * filepath is used as buffer for various actions and as the storage to"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* store the end of the start dir -- needed for upward search */", "  if (search_ctx->ffsc_start_dir != NULL)"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  /* store the end of the start dir -- needed for upward search */", "  if (search_ctx->ffsc_start_dir != NULL)", "    path_end = &search_ctx->ffsc_start_dir["], "readability/braces"]
["src/nvim/file_search.c", ["    path_end = &search_ctx->ffsc_start_dir[", "      STRLEN(search_ctx->ffsc_start_dir)];", ""], "whitespace/indent"]
["src/nvim/file_search.c", ["", "  /* upward search loop */", "  for (;; ) {"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  for (;; ) {", "    /* downward search loop */", "    for (;; ) {"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    for (;; ) {", "      /* check if user user wants to stop the search*/", "      os_breakcheck();"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["      os_breakcheck();", "      if (got_int)", "        break;"], "readability/braces"]
["src/nvim/file_search.c", ["", "      /* get directory to work on from stack */", "      stackp = ff_pop(search_ctx);"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["      stackp = ff_pop(search_ctx);", "      if (stackp == NULL)", "        break;"], "readability/braces"]
["src/nvim/file_search.c", ["", "      /*", "       * TODO: decide if we leave this test in"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["          && ff_check_visited(&search_ctx->ffsc_dir_visited_list", "              ->ffvl_visited_list,", "              stackp->ffs_fix_path"], "whitespace/alignment"]
["src/nvim/file_search.c", ["              ->ffvl_visited_list,", "              stackp->ffs_fix_path", "              , stackp->ffs_wc_path"], "whitespace/alignment"]
["src/nvim/file_search.c", ["              stackp->ffs_fix_path", "              , stackp->ffs_wc_path", "              ) == FAIL) {"], "whitespace/alignment"]
["src/nvim/file_search.c", ["              , stackp->ffs_wc_path", "              ) == FAIL) {", "#ifdef FF_VERBOSE"], "whitespace/alignment"]
["src/nvim/file_search.c", ["          && ff_check_visited(&search_ctx->ffsc_dir_visited_list", "              ->ffvl_visited_list,", "              stackp->ffs_fix_path"], "whitespace/alignment"]
["src/nvim/file_search.c", ["              ->ffvl_visited_list,", "              stackp->ffs_fix_path", "              , stackp->ffs_wc_path"], "whitespace/alignment"]
["src/nvim/file_search.c", ["              stackp->ffs_fix_path", "              , stackp->ffs_wc_path", "              ) == FAIL) {"], "whitespace/alignment"]
["src/nvim/file_search.c", ["              , stackp->ffs_wc_path", "              ) == FAIL) {", "#ifdef FF_VERBOSE"], "whitespace/alignment"]
["src/nvim/file_search.c", ["              , stackp->ffs_wc_path", "              ) == FAIL) {", "#ifdef FF_VERBOSE"], "whitespace/parens"]
["src/nvim/file_search.c", ["#ifdef FF_VERBOSE", "      else if (p_verbose >= 5) {", "        verbose_enter_scroll();"], "readability/braces"]
["src/nvim/file_search.c", ["", "      /* check depth */", "      if (stackp->ffs_level <= 0) {"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "      /*", "       * If no filearray till now expand wildcards"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "        /* we use filepath to build the path expand_wildcards() should", "         * expand."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["            if (*p == 0) {", "              /* remove '**<numb> from wildcards */", "              STRMOVE(rest_of_wildcards, rest_of_wildcards + 3);"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["              STRMOVE(rest_of_wildcards, rest_of_wildcards + 3);", "            } else", "              rest_of_wildcards += 3;"], "readability/braces"]
["src/nvim/file_search.c", ["            if (stackp->ffs_star_star_empty == 0) {", "              /* if not done before, expand '**' to empty */", "              stackp->ffs_star_star_empty = 1;"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "          /*", "           * Here we copy until the next path separator or the end of"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["          file_path[len] = NUL;", "          if (vim_ispathsep(*rest_of_wildcards))", "            rest_of_wildcards++;"], "readability/braces"]
["src/nvim/file_search.c", ["", "        /*", "         * Expand wildcards like \"*\" and \"$VAR\"."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["          stackp->ffs_filearray_size = 1;", "        } else", "          /* Add EW_NOTWILD because the expanded path may contain"], "readability/braces"]
["src/nvim/file_search.c", ["        } else", "          /* Add EW_NOTWILD because the expanded path may contain", "           * wildcard characters that are to be taken literally."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["          expand_wildcards((dirptrs[1] == NULL) ? 1 : 2, dirptrs,", "              &stackp->ffs_filearray_size,", "              &stackp->ffs_filearray,"], "whitespace/alignment"]
["src/nvim/file_search.c", ["              &stackp->ffs_filearray_size,", "              &stackp->ffs_filearray,", "              EW_DIR|EW_ADDSLASH|EW_SILENT|EW_NOTWILD);"], "whitespace/alignment"]
["src/nvim/file_search.c", ["              &stackp->ffs_filearray,", "              EW_DIR|EW_ADDSLASH|EW_SILENT|EW_NOTWILD);", ""], "whitespace/alignment"]
["src/nvim/file_search.c", ["        stackp->ffs_stage = 0;", "      } else", "        rest_of_wildcards = &stackp->ffs_wc_path["], "readability/braces"]
["src/nvim/file_search.c", ["        rest_of_wildcards = &stackp->ffs_wc_path[", "          STRLEN(stackp->ffs_wc_path)];", ""], "whitespace/indent"]
["src/nvim/file_search.c", ["      if (stackp->ffs_stage == 0) {", "        /* this is the first time we work on this directory */", "        if (*rest_of_wildcards == NUL) {"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["        if (*rest_of_wildcards == NUL) {", "          /*", "           * We don't have further wildcards to expand, so we have to"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["          for (int i = stackp->ffs_filearray_cur;", "               i < stackp->ffs_filearray_size; ++i) {", "            if (!path_with_url((char *)stackp->ffs_filearray[i])"], "readability/increment"]
["src/nvim/file_search.c", ["               i < stackp->ffs_filearray_size; ++i) {", "            if (!path_with_url((char *)stackp->ffs_filearray[i])", "                && !os_isdir(stackp->ffs_filearray[i]))"], "readability/braces"]
["src/nvim/file_search.c", ["                && !os_isdir(stackp->ffs_filearray[i]))", "              continue;                 /* not a directory */", ""], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "            /*", "             * Try without extra suffix and then with suffixes"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["            len = STRLEN(file_path);", "            if (search_ctx->ffsc_tagfile)", "              suf = (char_u *)\"\";"], "readability/braces"]
["src/nvim/file_search.c", ["              suf = (char_u *)\"\";", "            else", "              suf = curbuf->b_p_sua;"], "readability/braces"]
["src/nvim/file_search.c", ["            for (;; ) {", "              /* if file exists and we didn't already find it */", "              if ((path_with_url((char *)file_path)"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["                  && (ff_check_visited(", "                          &search_ctx->ffsc_visited_list->ffvl_visited_list,", "                          file_path"], "whitespace/indent"]
["src/nvim/file_search.c", ["                          &search_ctx->ffsc_visited_list->ffvl_visited_list,", "                          file_path", "                          , (char_u *)\"\""], "whitespace/indent"]
["src/nvim/file_search.c", ["                          file_path", "                          , (char_u *)\"\"", "                          ) == OK)"], "whitespace/indent"]
["src/nvim/file_search.c", ["                          , (char_u *)\"\"", "                          ) == OK)", "#endif"], "whitespace/indent"]
["src/nvim/file_search.c", ["                  && (ff_check_visited(", "                          &search_ctx->ffsc_visited_list->ffvl_visited_list,", "                          file_path"], "whitespace/indent"]
["src/nvim/file_search.c", ["                          &search_ctx->ffsc_visited_list->ffvl_visited_list,", "                          file_path", "                          , (char_u *)\"\""], "whitespace/indent"]
["src/nvim/file_search.c", ["                          file_path", "                          , (char_u *)\"\"", "                          ) == OK)"], "whitespace/indent"]
["src/nvim/file_search.c", ["                          , (char_u *)\"\"", "                          ) == OK)", "#endif"], "whitespace/indent"]
["src/nvim/file_search.c", ["                          , (char_u *)\"\"", "                          ) == OK)", "#endif"], "whitespace/parens"]
["src/nvim/file_search.c", ["                if (ff_check_visited(", "                        &search_ctx->ffsc_visited_list->ffvl_visited_list,", "                        file_path"], "whitespace/indent"]
["src/nvim/file_search.c", ["                        &search_ctx->ffsc_visited_list->ffvl_visited_list,", "                        file_path", "                        , (char_u *)\"\""], "whitespace/indent"]
["src/nvim/file_search.c", ["                        file_path", "                        , (char_u *)\"\"", "                        ) == FAIL) {"], "whitespace/indent"]
["src/nvim/file_search.c", ["                        , (char_u *)\"\"", "                        ) == FAIL) {", "                  if (p_verbose >= 5) {"], "whitespace/indent"]
["src/nvim/file_search.c", ["                        , (char_u *)\"\"", "                        ) == FAIL) {", "                  if (p_verbose >= 5) {"], "whitespace/parens"]
["src/nvim/file_search.c", ["", "                /* push dir to examine rest of subdirs later */", "                assert(i < UCHAR_MAX - 1);"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "                if (!path_with_url((char *)file_path))", "                  simplify_filename(file_path);"], "readability/braces"]
["src/nvim/file_search.c", ["                  p = path_shorten_fname(file_path,", "                      ff_expand_buffer);", "                  if (p != NULL)"], "whitespace/alignment"]
["src/nvim/file_search.c", ["                      ff_expand_buffer);", "                  if (p != NULL)", "                    STRMOVE(file_path, p);"], "readability/braces"]
["src/nvim/file_search.c", ["", "              /* Not found or found already, try next suffix. */", "              if (*suf == NUL)"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["              /* Not found or found already, try next suffix. */", "              if (*suf == NUL)", "                break;"], "readability/braces"]
["src/nvim/file_search.c", ["              copy_option_part(&suf, file_path + len,", "                  MAXPATHL - len, \",\");", "            }"], "whitespace/alignment"]
["src/nvim/file_search.c", ["        } else {", "          /*", "           * still wildcards left, push the directories for further"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["          for (int i = stackp->ffs_filearray_cur;", "               i < stackp->ffs_filearray_size; ++i) {", "            if (!os_isdir(stackp->ffs_filearray[i]))"], "readability/increment"]
["src/nvim/file_search.c", ["               i < stackp->ffs_filearray_size; ++i) {", "            if (!os_isdir(stackp->ffs_filearray[i]))", "              continue;                 /* not a directory */"], "readability/braces"]
["src/nvim/file_search.c", ["            if (!os_isdir(stackp->ffs_filearray[i]))", "              continue;                 /* not a directory */", ""], "readability/old_style_comment"]
["src/nvim/file_search.c", ["            ff_push(search_ctx,", "                ff_create_stack_element(", "                    stackp->ffs_filearray[i],"], "whitespace/alignment"]
["src/nvim/file_search.c", ["", "      /*", "       * if wildcards contains '**' we have to descent till we reach the"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["        for (int i = stackp->ffs_filearray_cur;", "             i < stackp->ffs_filearray_size; ++i) {", "          if (fnamecmp(stackp->ffs_filearray[i],"], "readability/increment"]
["src/nvim/file_search.c", ["             i < stackp->ffs_filearray_size; ++i) {", "          if (fnamecmp(stackp->ffs_filearray[i],", "                  stackp->ffs_fix_path) == 0)"], "readability/braces"]
["src/nvim/file_search.c", ["          if (fnamecmp(stackp->ffs_filearray[i],", "                  stackp->ffs_fix_path) == 0)", "            continue;             /* don't repush same directory */"], "whitespace/alignment"]
["src/nvim/file_search.c", ["                  stackp->ffs_fix_path) == 0)", "            continue;             /* don't repush same directory */", "          if (!os_isdir(stackp->ffs_filearray[i]))"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["            continue;             /* don't repush same directory */", "          if (!os_isdir(stackp->ffs_filearray[i]))", "            continue;               /* not a directory */"], "readability/braces"]
["src/nvim/file_search.c", ["          if (!os_isdir(stackp->ffs_filearray[i]))", "            continue;               /* not a directory */", "          ff_push(search_ctx,"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["          ff_push(search_ctx,", "              ff_create_stack_element(stackp->ffs_filearray[i],", "                  stackp->ffs_wc_path, stackp->ffs_level - 1, 1));"], "whitespace/alignment"]
["src/nvim/file_search.c", ["              ff_create_stack_element(stackp->ffs_filearray[i],", "                  stackp->ffs_wc_path, stackp->ffs_level - 1, 1));", "        }"], "whitespace/alignment"]
["src/nvim/file_search.c", ["              ff_create_stack_element(stackp->ffs_filearray[i],", "                  stackp->ffs_wc_path, stackp->ffs_level - 1, 1));", "        }"], "whitespace/alignment"]
["src/nvim/file_search.c", ["", "      /* we are done with the current directory */", "      ff_free_stack_element(stackp);"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["      ff_free_stack_element(stackp);", "", "    }"], "whitespace/blank_line"]
["src/nvim/file_search.c", ["", "    /* If we reached this, we didn't find anything downwards.", "     * Let's check if we should do an upward search."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "      /* is the last starting directory in the stop list? */", "      if (ff_path_in_stoplist(search_ctx->ffsc_start_dir,"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["      /* is the last starting directory in the stop list? */", "      if (ff_path_in_stoplist(search_ctx->ffsc_start_dir,", "              (int)(path_end - search_ctx->ffsc_start_dir),"], "readability/braces"]
["src/nvim/file_search.c", ["      if (ff_path_in_stoplist(search_ctx->ffsc_start_dir,", "              (int)(path_end - search_ctx->ffsc_start_dir),", "              search_ctx->ffsc_stopdirs_v) == TRUE)"], "whitespace/alignment"]
["src/nvim/file_search.c", ["              (int)(path_end - search_ctx->ffsc_start_dir),", "              search_ctx->ffsc_stopdirs_v) == TRUE)", "        break;"], "whitespace/alignment"]
["src/nvim/file_search.c", ["              (int)(path_end - search_ctx->ffsc_start_dir),", "              search_ctx->ffsc_stopdirs_v) == TRUE)", "        break;"], "readability/bool"]
["src/nvim/file_search.c", ["", "      /* cut of last dir */", "      while (path_end > search_ctx->ffsc_start_dir"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["      /* cut of last dir */", "      while (path_end > search_ctx->ffsc_start_dir", "             && vim_ispathsep(*path_end))"], "readability/braces"]
["src/nvim/file_search.c", ["        path_end--;", "      while (path_end > search_ctx->ffsc_start_dir", "             && !vim_ispathsep(path_end[-1]))"], "readability/braces"]
["src/nvim/file_search.c", ["", "      if (*search_ctx->ffsc_start_dir == 0)", "        break;"], "readability/braces"]
["src/nvim/file_search.c", ["", "      /* create a new stack entry */", "      sptr = ff_create_stack_element(file_path,"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["      sptr = ff_create_stack_element(file_path,", "          search_ctx->ffsc_wc_path, search_ctx->ffsc_level, 0);", "      ff_push(search_ctx, sptr);"], "whitespace/alignment"]
["src/nvim/file_search.c", ["      ff_push(search_ctx, sptr);", "    } else", "      break;"], "readability/braces"]
["src/nvim/file_search.c", ["", "/*", " * Free the list of lists of visited files and directories"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  if (search_ctx_arg == NULL)", "    return;"], "readability/braces"]
["src/nvim/file_search.c", ["", "/*", " * Returns the already visited list for the given filename. If none is found it"], "readability/old_style_comment"]
["src/nvim/file_search.c", [" */", "static ff_visited_list_hdr_T *ff_get_visited_list(char_u *filename, ff_visited_list_hdr_T **list_headp)", "{"], "whitespace/line_length"]
["src/nvim/file_search.c", ["", "  /* check if a visited list for the given filename exists */", "  if (*list_headp != NULL) {"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /*", "   * if we reach this we didn't find a list and we have to allocate new list"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * maintains the list of already visited files and dirs"], "readability/old_style_comment"]
["src/nvim/file_search.c", [" */", "static int ff_check_visited(ff_visited_T **visited_list, char_u *fname, char_u *wc_path)", "{"], "whitespace/line_length"]
["src/nvim/file_search.c", ["", "  /* check against list of already visited files */", "  for (vp = *visited_list; vp != NULL; vp = vp->ffv_next) {"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /*", "   * New file/dir.  Add it to the list of visited files/dirs."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  if (wc_path != NULL)", "    vp->ffv_wc_path = vim_strsave(wc_path);"], "readability/braces"]
["src/nvim/file_search.c", ["    vp->ffv_wc_path = vim_strsave(wc_path);", "  else", "    vp->ffv_wc_path = NULL;"], "readability/braces"]
["src/nvim/file_search.c", ["", "/*", " * create stack element from given path pieces"], "readability/old_style_comment"]
["src/nvim/file_search.c", [" */", "static ff_stack_T *ff_create_stack_element(char_u *fix_part, char_u *wc_part, int level, int star_star_empty)", "{"], "whitespace/line_length"]
["src/nvim/file_search.c", ["", "  /* the following saves NULL pointer checks in vim_findfile */", "  if (fix_part == NULL)"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  /* the following saves NULL pointer checks in vim_findfile */", "  if (fix_part == NULL)", "    fix_part = (char_u *)\"\";"], "readability/braces"]
["src/nvim/file_search.c", ["", "  if (wc_part == NULL)", "    wc_part  = (char_u *)\"\";"], "readability/braces"]
["src/nvim/file_search.c", ["", "/*", " * Push a dir on the directory stack."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["{", "  /* check for NULL pointer, not to return an error to the user, but", "   * to prevent a crash */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * Pop a dir from the directory stack."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  sptr = search_ctx->ffsc_stack_ptr;", "  if (search_ctx->ffsc_stack_ptr != NULL)", "    search_ctx->ffsc_stack_ptr = search_ctx->ffsc_stack_ptr->ffs_prev;"], "readability/braces"]
["src/nvim/file_search.c", ["", "/*", " * free the given stack element"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * Clear the search context, but NOT the visited list."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* clear up stack */", "  while ((sptr = ff_pop(search_ctx)) != NULL)"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  /* clear up stack */", "  while ((sptr = ff_pop(search_ctx)) != NULL)", "    ff_free_stack_element(sptr);"], "readability/braces"]
["src/nvim/file_search.c", ["", "  /* reset everything */", "  search_ctx->ffsc_file_to_search = NULL;"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * check if the given path is in the stopdirs"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* eat up trailing path separators, except the first */", "  while (path_len > 1 && vim_ispathsep(path[path_len - 1]))"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  /* eat up trailing path separators, except the first */", "  while (path_len > 1 && vim_ispathsep(path[path_len - 1]))", "    path_len--;"], "readability/braces"]
["src/nvim/file_search.c", ["", "  /* if no path consider it as match */", "  if (path_len == 0)"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  /* if no path consider it as match */", "  if (path_len == 0)", "    return TRUE;"], "readability/braces"]
["src/nvim/file_search.c", ["  if (path_len == 0)", "    return TRUE;", ""], "readability/bool"]
["src/nvim/file_search.c", ["    if ((int)STRLEN(stopdirs_v[i]) > path_len) {", "      /* match for parent directory. So '/home' also matches", "       * '/home/rks'. Check for PATHSEP in stopdirs_v[i], else"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["       */", "      if (fnamencmp(stopdirs_v[i], path, path_len) == 0", "          && vim_ispathsep(stopdirs_v[i][path_len]))"], "readability/braces"]
["src/nvim/file_search.c", ["          && vim_ispathsep(stopdirs_v[i][path_len]))", "        return TRUE;", "    } else {"], "readability/bool"]
["src/nvim/file_search.c", ["    } else {", "      if (fnamecmp(stopdirs_v[i], path) == 0)", "        return TRUE;"], "readability/braces"]
["src/nvim/file_search.c", ["      if (fnamecmp(stopdirs_v[i], path) == 0)", "        return TRUE;", "    }"], "readability/bool"]
["src/nvim/file_search.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/file_search.c", ["", "/*", " * Find the file name \"ptr[len]\" in the path.  Also finds directory names."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["char_u *", "find_file_in_path (", "    char_u *ptr,               /* file name */"], "whitespace/parens"]
["src/nvim/file_search.c", ["find_file_in_path (", "    char_u *ptr,               /* file name */", "    size_t len,                /* length of file name */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    char_u *ptr,               /* file name */", "    size_t len,                /* length of file name */", "    int options,"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    int options,", "    int first,                      /* use count'th matching file name */", "    char_u *rel_fname         /* file name searching relative to */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    int first,                      /* use count'th matching file name */", "    char_u *rel_fname         /* file name searching relative to */", ")"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * Find the directory name \"ptr[len]\" in the path."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["char_u *", "find_directory_in_path (", "    char_u *ptr,               /* file name */"], "whitespace/parens"]
["src/nvim/file_search.c", ["find_directory_in_path (", "    char_u *ptr,               /* file name */", "    size_t len,                /* length of file name */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    char_u *ptr,               /* file name */", "    size_t len,                /* length of file name */", "    int options,"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    int options,", "    char_u *rel_fname         /* file name searching relative to */", ")"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["{", "  return find_file_in_path_option(ptr, len, options, TRUE, p_cdpath,", "                                  FINDFILE_DIR, rel_fname, (char_u *)\"\");"], "readability/bool"]
["src/nvim/file_search.c", ["char_u *", "find_file_in_path_option (", "    char_u *ptr,               /* file name */"], "whitespace/parens"]
["src/nvim/file_search.c", ["find_file_in_path_option (", "    char_u *ptr,               /* file name */", "    size_t len,                /* length of file name */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    char_u *ptr,               /* file name */", "    size_t len,                /* length of file name */", "    int options,"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    int options,", "    int first,                      /* use count'th matching file name */", "    char_u *path_option,       /* p_path or p_cdpath */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    int first,                      /* use count'th matching file name */", "    char_u *path_option,       /* p_path or p_cdpath */", "    int find_what,                  /* FINDFILE_FILE, _DIR or _BOTH */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    char_u *path_option,       /* p_path or p_cdpath */", "    int find_what,                  /* FINDFILE_FILE, _DIR or _BOTH */", "    char_u *rel_fname,         /* file name we are looking relative to. */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    int find_what,                  /* FINDFILE_FILE, _DIR or _BOTH */", "    char_u *rel_fname,         /* file name we are looking relative to. */", "    char_u *suffixes          /* list of suffixes, 'suffixesadd' option */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    char_u *rel_fname,         /* file name we are looking relative to. */", "    char_u *suffixes          /* list of suffixes, 'suffixesadd' option */", ")"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  static char_u       *dir;", "  static int did_findfile_init = FALSE;", "  char_u save_char;"], "readability/bool"]
["src/nvim/file_search.c", ["", "  if (first == TRUE) {", "    /* copy file name into NameBuff, expanding environment variables */"], "readability/bool"]
["src/nvim/file_search.c", ["  if (first == TRUE) {", "    /* copy file name into NameBuff, expanding environment variables */", "    save_char = ptr[len];"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["      // Change all \"\\ \" to \" \".", "      for (ptr = ff_file_to_find; *ptr != NUL; ++ptr) {", "        if (ptr[0] == '\\\\' && ptr[1] == ' ') {"], "readability/increment"]
["src/nvim/file_search.c", ["      ) {", "    /*", "     * Absolute path, no need to use \"path_option\"."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["     */", "    if (first == TRUE) {", "      if (path_with_url((char *)ff_file_to_find)) {"], "readability/bool"]
["src/nvim/file_search.c", ["", "      /* When FNAME_REL flag given first use the directory of the file.", "       * Otherwise or when this fails use the current directory. */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["       * Otherwise or when this fails use the current directory. */", "      for (int run = 1; run <= 2; ++run) {", "        size_t l = STRLEN(ff_file_to_find);"], "readability/increment"]
["src/nvim/file_search.c", ["", "        /* When the file doesn't exist, try adding parts of", "         * 'suffixesadd'. */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["          }", "          if (*buf == NUL)", "            break;"], "readability/braces"]
["src/nvim/file_search.c", ["  } else {", "    /*", "     * Loop over all paths in the 'path' or 'cdpath' option."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["     */", "    if (first == TRUE) {", "      /* vim_findfile_free_visited can handle a possible NULL pointer */"], "readability/bool"]
["src/nvim/file_search.c", ["    if (first == TRUE) {", "      /* vim_findfile_free_visited can handle a possible NULL pointer */", "      vim_findfile_free_visited(fdip_search_ctx);"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["      dir = path_option;", "      did_findfile_init = FALSE;", "    }"], "readability/bool"]
["src/nvim/file_search.c", ["        file_name = vim_findfile(fdip_search_ctx);", "        if (file_name != NULL)", "          break;"], "readability/braces"]
["src/nvim/file_search.c", ["", "        did_findfile_init = FALSE;", "      } else {"], "readability/bool"]
["src/nvim/file_search.c", ["        if (dir == NULL || *dir == NUL) {", "          /* We searched all paths of the option, now we can", "           * free the search context. */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "        /* copy next path */", "        buf[0] = 0;"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "        /* get the stopdir string */", "        r_ptr = vim_findfile_stopdir(buf);"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["        fdip_search_ctx = vim_findfile_init(buf, ff_file_to_find,", "            r_ptr, 100, FALSE, find_what,", "            fdip_search_ctx, FALSE, rel_fname);"], "whitespace/alignment"]
["src/nvim/file_search.c", ["            r_ptr, 100, FALSE, find_what,", "            fdip_search_ctx, FALSE, rel_fname);", "        if (fdip_search_ctx != NULL)"], "whitespace/alignment"]
["src/nvim/file_search.c", ["        fdip_search_ctx = vim_findfile_init(buf, ff_file_to_find,", "            r_ptr, 100, FALSE, find_what,", "            fdip_search_ctx, FALSE, rel_fname);"], "readability/bool"]
["src/nvim/file_search.c", ["            r_ptr, 100, FALSE, find_what,", "            fdip_search_ctx, FALSE, rel_fname);", "        if (fdip_search_ctx != NULL)"], "readability/bool"]
["src/nvim/file_search.c", ["            fdip_search_ctx, FALSE, rel_fname);", "        if (fdip_search_ctx != NULL)", "          did_findfile_init = TRUE;"], "readability/braces"]
["src/nvim/file_search.c", ["        if (fdip_search_ctx != NULL)", "          did_findfile_init = TRUE;", "        xfree(buf);"], "readability/bool"]
["src/nvim/file_search.c", ["  if (file_name == NULL && (options & FNAME_MESS)) {", "    if (first == TRUE) {", "      if (find_what == FINDFILE_DIR)"], "readability/bool"]
["src/nvim/file_search.c", ["    if (first == TRUE) {", "      if (find_what == FINDFILE_DIR)", "        EMSG2(_(\"E344: Can't find directory \\\"%s\\\" in cdpath\"),"], "readability/braces"]
["src/nvim/file_search.c", ["        EMSG2(_(\"E344: Can't find directory \\\"%s\\\" in cdpath\"),", "            ff_file_to_find);", "      else"], "whitespace/alignment"]
["src/nvim/file_search.c", ["            ff_file_to_find);", "      else", "        EMSG2(_(\"E345: Can't find file \\\"%s\\\" in path\"),"], "readability/braces"]
["src/nvim/file_search.c", ["        EMSG2(_(\"E345: Can't find file \\\"%s\\\" in path\"),", "            ff_file_to_find);", "    } else {"], "whitespace/alignment"]
["src/nvim/file_search.c", ["    } else {", "      if (find_what == FINDFILE_DIR)", "        EMSG2(_(\"E346: No more directory \\\"%s\\\" found in cdpath\"),"], "readability/braces"]
["src/nvim/file_search.c", ["        EMSG2(_(\"E346: No more directory \\\"%s\\\" found in cdpath\"),", "            ff_file_to_find);", "      else"], "whitespace/alignment"]
["src/nvim/file_search.c", ["            ff_file_to_find);", "      else", "        EMSG2(_(\"E347: No more file \\\"%s\\\" found in path\"),"], "readability/braces"]
["src/nvim/file_search.c", ["        EMSG2(_(\"E347: No more file \\\"%s\\\" found in path\"),", "            ff_file_to_find);", "    }"], "whitespace/alignment"]
["src/nvim/file_search.h", ["", "#include <stdlib.h> // for size_t", ""], "whitespace/comments"]
["src/nvim/file_search.h", ["", "#include \"nvim/types.h\" // for char_u", "#include \"nvim/globals.h\" // for CdScope"], "whitespace/comments"]
["src/nvim/file_search.h", ["#include \"nvim/types.h\" // for char_u", "#include \"nvim/globals.h\" // for CdScope", ""], "whitespace/comments"]
["src/nvim/file_search.h", ["", "/* Flags for find_file_*() functions. */", "#define FINDFILE_FILE   0       /* only files */"], "readability/old_style_comment"]
["src/nvim/file_search.h", ["/* Flags for find_file_*() functions. */", "#define FINDFILE_FILE   0       /* only files */", "#define FINDFILE_DIR    1       /* only directories */"], "readability/old_style_comment"]
["src/nvim/file_search.h", ["#define FINDFILE_FILE   0       /* only files */", "#define FINDFILE_DIR    1       /* only directories */", "#define FINDFILE_BOTH   2       /* files and directories */"], "readability/old_style_comment"]
["src/nvim/file_search.h", ["#define FINDFILE_DIR    1       /* only directories */", "#define FINDFILE_BOTH   2       /* files and directories */", ""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "#define BUFSIZE         8192    /* size of normal write buffer */", "#define SMBUFSIZE       256     /* size of emergency write buffer */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#define BUFSIZE         8192    /* size of normal write buffer */", "#define SMBUFSIZE       256     /* size of emergency write buffer */", ""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#define HAS_BW_FLAGS", "#define FIO_LATIN1     0x01    /* convert Latin1 */", "#define FIO_UTF8       0x02    /* convert UTF-8 */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#define FIO_LATIN1     0x01    /* convert Latin1 */", "#define FIO_UTF8       0x02    /* convert UTF-8 */", "#define FIO_UCS2       0x04    /* convert UCS-2 */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#define FIO_UTF8       0x02    /* convert UTF-8 */", "#define FIO_UCS2       0x04    /* convert UCS-2 */", "#define FIO_UCS4       0x08    /* convert UCS-4 */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#define FIO_UCS2       0x04    /* convert UCS-2 */", "#define FIO_UCS4       0x08    /* convert UCS-4 */", "#define FIO_UTF16      0x10    /* convert UTF-16 */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#define FIO_UCS4       0x08    /* convert UCS-4 */", "#define FIO_UTF16      0x10    /* convert UTF-16 */", "#define FIO_ENDIAN_L   0x80    /* little endian */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#define FIO_UTF16      0x10    /* convert UTF-16 */", "#define FIO_ENDIAN_L   0x80    /* little endian */", "#define FIO_NOCONVERT  0x2000  /* skip encoding conversion */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#define FIO_ENDIAN_L   0x80    /* little endian */", "#define FIO_NOCONVERT  0x2000  /* skip encoding conversion */", "#define FIO_UCSBOM     0x4000  /* check for BOM at start of file */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#define FIO_NOCONVERT  0x2000  /* skip encoding conversion */", "#define FIO_UCSBOM     0x4000  /* check for BOM at start of file */", "#define FIO_ALL        -1      /* allow all formats */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#define FIO_UCSBOM     0x4000  /* check for BOM at start of file */", "#define FIO_ALL        -1      /* allow all formats */", ""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/* When converting, a read() or write() may leave some bytes to be converted", " * for the next call.  The value is guessed... */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/* We have to guess how much a sequence of bytes may expand when converting", " * with iconv() to be able to allocate a buffer. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/*", " * Structure to pass arguments from buf_write() to buf_write_bytes()."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  msg_scroll_save = msg_scroll;", "  if (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0)", "    msg_scroll = FALSE;"], "readability/braces"]
["src/nvim/fileio.c", ["  if (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0)", "    msg_scroll = FALSE;", "  if (!msg_scroll)      /* wait a bit when overwriting an error msg */"], "readability/bool"]
["src/nvim/fileio.c", ["    msg_scroll = FALSE;", "  if (!msg_scroll)      /* wait a bit when overwriting an error msg */", "    check_for_delay(FALSE);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    msg_scroll = FALSE;", "  if (!msg_scroll)      /* wait a bit when overwriting an error msg */", "    check_for_delay(FALSE);"], "readability/braces"]
["src/nvim/fileio.c", ["  if (!msg_scroll)      /* wait a bit when overwriting an error msg */", "    check_for_delay(FALSE);", "  msg_start();"], "readability/bool"]
["src/nvim/fileio.c", ["  msg_scroll = msg_scroll_save;", "  msg_scrolled_ign = TRUE;", "  /* may truncate the message to avoid a hit-return prompt */"], "readability/bool"]
["src/nvim/fileio.c", ["  msg_scrolled_ign = TRUE;", "  /* may truncate the message to avoid a hit-return prompt */", "  msg_outtrans_attr(msg_may_trunc(FALSE, IObuff), attr);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  /* may truncate the message to avoid a hit-return prompt */", "  msg_outtrans_attr(msg_may_trunc(FALSE, IObuff), attr);", "  msg_clr_eos();"], "readability/bool"]
["src/nvim/fileio.c", ["  ui_flush();", "  msg_scrolled_ign = FALSE;", "}"], "readability/bool"]
["src/nvim/fileio.c", ["", "/*", " * Read lines from file \"fname\" into the buffer after line \"from\"."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["                    || (eap != NULL && eap->read_edit);", "  linenr_T read_buf_lnum = 1;           /* next line to read from curbuf */", "  colnr_T read_buf_col = 0;             /* next char to read from this line */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  linenr_T read_buf_lnum = 1;           /* next line to read from curbuf */", "  colnr_T read_buf_col = 0;             /* next char to read from this line */", "  char_u c;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  linenr_T lnum = from;", "  char_u      *ptr = NULL;              /* pointer into read buffer */", "  char_u      *buffer = NULL;           /* read buffer */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  char_u      *ptr = NULL;              /* pointer into read buffer */", "  char_u      *buffer = NULL;           /* read buffer */", "  char_u      *new_buffer = NULL;       /* init to shut up gcc */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  char_u      *buffer = NULL;           /* read buffer */", "  char_u      *new_buffer = NULL;       /* init to shut up gcc */", "  char_u      *line_start = NULL;       /* init to shut up gcc */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  char_u      *new_buffer = NULL;       /* init to shut up gcc */", "  char_u      *line_start = NULL;       /* init to shut up gcc */", "  int wasempty;                         /* buffer was empty before reading */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  char_u      *line_start = NULL;       /* init to shut up gcc */", "  int wasempty;                         /* buffer was empty before reading */", "  colnr_T len;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  linenr_T linecnt;", "  int error = FALSE;                    /* errors encountered */", "  int ff_error = EOL_UNKNOWN;           /* file format with errors */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  linenr_T linecnt;", "  int error = FALSE;                    /* errors encountered */", "  int ff_error = EOL_UNKNOWN;           /* file format with errors */"], "readability/bool"]
["src/nvim/fileio.c", ["  int error = FALSE;                    /* errors encountered */", "  int ff_error = EOL_UNKNOWN;           /* file format with errors */", "  long linerest = 0;                    /* remaining chars in line */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  int ff_error = EOL_UNKNOWN;           /* file format with errors */", "  long linerest = 0;                    /* remaining chars in line */", "  int perm = 0;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#ifdef UNIX", "  int swap_mode = -1;                   /* protection bits for swap file */", "#endif"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  int bad_char_behavior = BAD_REPLACE;", "  /* BAD_KEEP, BAD_DROP or character to", "   * replace with */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["   * replace with */", "  char_u      *tmpname = NULL;          /* name of 'charconvert' output file */", "  int fio_flags = 0;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["# endif", "  int converted = FALSE;                /* TRUE if conversion done */", "  int notconverted = FALSE;             /* TRUE if conversion wanted but it"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["# endif", "  int converted = FALSE;                /* TRUE if conversion done */", "  int notconverted = FALSE;             /* TRUE if conversion wanted but it"], "readability/bool"]
["src/nvim/fileio.c", ["  int converted = FALSE;                /* TRUE if conversion done */", "  int notconverted = FALSE;             /* TRUE if conversion wanted but it", "                                           wasn't possible */"], "readability/multiline_comment"]
["src/nvim/fileio.c", ["  int converted = FALSE;                /* TRUE if conversion done */", "  int notconverted = FALSE;             /* TRUE if conversion wanted but it", "                                           wasn't possible */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  int converted = FALSE;                /* TRUE if conversion done */", "  int notconverted = FALSE;             /* TRUE if conversion wanted but it", "                                           wasn't possible */"], "readability/bool"]
["src/nvim/fileio.c", ["  char_u conv_rest[CONV_RESTLEN];", "  int conv_restlen = 0;                 /* nr of bytes in conv_rest[] */", "  buf_T       *old_curbuf;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  curbuf->b_no_eol_lnum = 0;    /* in case it was set by the previous read */", ""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * If there is no file name yet, use the one for the read file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      && !(flags & READ_DUMMY)) {", "    if (set_rw_fname(fname, sfname) == FAIL)", "      return FAIL;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /* Remember the initial values of curbuf, curbuf->b_ffname and", "   * curbuf->b_fname to detect whether they are altered as a result of"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* After reading a file the cursor line changes but we don't want to", "   * display the line. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["   * display the line. */", "  ex_no_reprint = TRUE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  /* don't display the file info for another buffer now */", "  need_fileinfo = FALSE;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  /* don't display the file info for another buffer now */", "  need_fileinfo = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * The BufReadCmd and FileReadCmd events intercept the reading process by"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /* Set '[ mark to the line above where the lines go (line 1 if zero). */", "    curbuf->b_op_start.lnum = ((from == 0) ? 1 : from);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  if ((shortmess(SHM_OVER) || curbuf->b_help) && p_verbose == 0)", "    msg_scroll = FALSE;         /* overwrite previous file message */"], "readability/braces"]
["src/nvim/fileio.c", ["  if ((shortmess(SHM_OVER) || curbuf->b_help) && p_verbose == 0)", "    msg_scroll = FALSE;         /* overwrite previous file message */", "  else"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if ((shortmess(SHM_OVER) || curbuf->b_help) && p_verbose == 0)", "    msg_scroll = FALSE;         /* overwrite previous file message */", "  else"], "readability/bool"]
["src/nvim/fileio.c", ["    msg_scroll = FALSE;         /* overwrite previous file message */", "  else", "    msg_scroll = TRUE;          /* don't overwrite previous file message */"], "readability/braces"]
["src/nvim/fileio.c", ["  else", "    msg_scroll = TRUE;          /* don't overwrite previous file message */", ""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  else", "    msg_scroll = TRUE;          /* don't overwrite previous file message */", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  /* Set default or forced 'fileformat' and 'binary'. */", "  set_file_options(set_options, eap);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * When opening a new file we take the readonly flag from the file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  check_readonly = (newfile && (curbuf->b_flags & BF_CHECK_RO));", "  if (check_readonly && !readonlymode)", "    curbuf->b_p_ro = FALSE;"], "readability/braces"]
["src/nvim/fileio.c", ["  if (check_readonly && !readonlymode)", "    curbuf->b_p_ro = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["#ifdef UNIX", "      /*", "       * Use the protection bits of the original file for the swap file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /* Reset the \"new file\" flag.  It will be set again below when the", "     * file doesn't exist. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "      /* Create a swap file now, so that other Vims are warned", "       * that we are editing this file.  Don't do this for a"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        check_need_swap(newfile);", "        /* SwapExists autocommand may mess things up */", "        if (curbuf != old_curbuf"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "      if (aborting())               /* autocmds may abort script processing */", "        return FAIL;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "      if (aborting())               /* autocmds may abort script processing */", "        return FAIL;"], "readability/braces"]
["src/nvim/fileio.c", ["        return FAIL;", "      return OK;                  /* a new file is not an error */", "    } else {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      filemess(curbuf, sfname, (char_u *)(", "            (fd == UV_EFBIG) ? _(\"[File too big]\") :", "# if defined(UNIX) && defined(EOVERFLOW)"], "whitespace/indent"]
["src/nvim/fileio.c", ["            // set EOVERFLOW", "            (fd == -EOVERFLOW) ? _(\"[File too big]\") :", "# endif"], "whitespace/indent"]
["src/nvim/fileio.c", ["# endif", "            _(\"[Permission Denied]\")), 0);", "      curbuf->b_p_ro = TRUE;                  /* must use \"w!\" now */"], "whitespace/indent"]
["src/nvim/fileio.c", ["            _(\"[Permission Denied]\")), 0);", "      curbuf->b_p_ro = TRUE;                  /* must use \"w!\" now */", "    }"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            _(\"[Permission Denied]\")), 0);", "      curbuf->b_p_ro = TRUE;                  /* must use \"w!\" now */", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * Only set the 'ro' flag for readonly files the first time they are"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["   */", "  if ((check_readonly && file_readonly) || curbuf->b_help)", "    curbuf->b_p_ro = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["  if ((check_readonly && file_readonly) || curbuf->b_help)", "    curbuf->b_p_ro = TRUE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["  if (set_options) {", "    /* Don't change 'eol' if reading from buffer as it will already be", "     * correctly set when reading stdin. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (!read_buffer) {", "      curbuf->b_p_eol = TRUE;", "      curbuf->b_start_eol = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["      curbuf->b_p_eol = TRUE;", "      curbuf->b_start_eol = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["    }", "    curbuf->b_p_bomb = FALSE;", "    curbuf->b_start_bomb = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    curbuf->b_p_bomb = FALSE;", "    curbuf->b_start_bomb = FALSE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /* Create a swap file now, so that other Vims are warned that we are", "   * editing this file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (swap_exists_action == SEA_QUIT) {", "    if (!read_buffer && !read_stdin)", "      close(fd);"], "readability/braces"]
["src/nvim/fileio.c", ["", "  ++no_wait_return;         /* don't wait for return yet */", ""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  ++no_wait_return;         /* don't wait for return yet */", ""], "readability/increment"]
["src/nvim/fileio.c", ["", "  /*", "   * Set '[ mark to the line above where the lines go (line 1 if zero)."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    if (aborting()) {       /* autocmds may abort script processing */", "      --no_wait_return;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (aborting()) {       /* autocmds may abort script processing */", "      --no_wait_return;", "      msg_scroll = msg_save;"], "readability/increment"]
["src/nvim/fileio.c", ["      msg_scroll = msg_save;", "      curbuf->b_p_ro = TRUE;            /* must use \"w!\" now */", "      return FAIL;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      msg_scroll = msg_save;", "      curbuf->b_p_ro = TRUE;            /* must use \"w!\" now */", "      return FAIL;"], "readability/bool"]
["src/nvim/fileio.c", ["    }", "    /*", "     * Don't allow the autocommands to change the current buffer."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (!read_stdin && (curbuf != old_curbuf", "                        || (using_b_ffname && (old_b_ffname != curbuf->b_ffname))", "                        || (using_b_fname && (old_b_fname != curbuf->b_fname))"], "whitespace/line_length"]
["src/nvim/fileio.c", ["                        || (fd = os_open((char *)fname, O_RDONLY, 0)) < 0)) {", "      --no_wait_return;", "      msg_scroll = msg_save;"], "readability/increment"]
["src/nvim/fileio.c", ["      msg_scroll = msg_save;", "      if (fd < 0)", "        EMSG(_(\"E200: *ReadPre autocommands made the file unreadable\"));"], "readability/braces"]
["src/nvim/fileio.c", ["        EMSG(_(\"E200: *ReadPre autocommands made the file unreadable\"));", "      else", "        EMSG(_(\"E201: *ReadPre autocommands must not change current buffer\"));"], "readability/braces"]
["src/nvim/fileio.c", ["        EMSG(_(\"E201: *ReadPre autocommands must not change current buffer\"));", "      curbuf->b_p_ro = TRUE;            /* must use \"w!\" now */", "      return FAIL;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        EMSG(_(\"E201: *ReadPre autocommands must not change current buffer\"));", "      curbuf->b_p_ro = TRUE;            /* must use \"w!\" now */", "      return FAIL;"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /* Autocommands may add lines to the file, need to check if it is empty */", "  wasempty = (curbuf->b_ml.ml_flags & ML_EMPTY);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  msg_scroll = FALSE;                   /* overwrite the file message */", ""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  msg_scroll = FALSE;                   /* overwrite the file message */", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * Set linecnt now, before the \"retry\" caused by a wrong guess for"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* \"++bad=\" argument. */", "  if (eap != NULL && eap->bad_char != 0) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    bad_char_behavior = eap->bad_char;", "    if (set_options)", "      curbuf->b_bad_char = eap->bad_char;"], "readability/braces"]
["src/nvim/fileio.c", ["      curbuf->b_bad_char = eap->bad_char;", "  } else", "    curbuf->b_bad_char = 0;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /*", "   * Decide which 'encoding' to use or use first."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Jump back here to retry reading the file in different ways."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (set_options) {", "      curbuf->b_p_bomb = FALSE;", "      curbuf->b_start_bomb = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["      curbuf->b_p_bomb = FALSE;", "      curbuf->b_start_bomb = FALSE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * When retrying with another \"fenc\" and the first time \"fileformat\""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      fileformat = get_fileformat_force(curbuf, eap);", "      try_unix = try_dos = try_mac = FALSE;", "    } else if (curbuf->b_p_bin)"], "readability/bool"]
["src/nvim/fileio.c", ["      try_unix = try_dos = try_mac = FALSE;", "    } else if (curbuf->b_p_bin)", "      fileformat = EOL_UNIX;                    /* binary: use Unix format */"], "readability/braces"]
["src/nvim/fileio.c", ["    } else if (curbuf->b_p_bin)", "      fileformat = EOL_UNIX;                    /* binary: use Unix format */", "    else if (*p_ffs == NUL)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      fileformat = EOL_UNIX;                    /* binary: use Unix format */", "    else if (*p_ffs == NUL)", "      fileformat = get_fileformat(curbuf);      /* use format from buffer */"], "readability/braces"]
["src/nvim/fileio.c", ["    else if (*p_ffs == NUL)", "      fileformat = get_fileformat(curbuf);      /* use format from buffer */", "    else"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      fileformat = get_fileformat(curbuf);      /* use format from buffer */", "    else", "      fileformat = EOL_UNKNOWN;                 /* detect from file */"], "readability/braces"]
["src/nvim/fileio.c", ["    else", "      fileformat = EOL_UNKNOWN;                 /* detect from file */", "  }"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (iconv_fd != (iconv_t)-1) {", "    /* aborted conversion with iconv(), close the descriptor */", "    iconv_close(iconv_fd);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (advance_fenc) {", "    /*", "     * Try the next entry in 'fileencodings'."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (eap != NULL && eap->force_enc != 0) {", "      /* Conversion given with \"++cc=\" wasn't possible, read", "       * without conversion. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["       * without conversion. */", "      notconverted = TRUE;", "      conv_error = 0;"], "readability/bool"]
["src/nvim/fileio.c", ["      conv_error = 0;", "      if (fenc_alloced)", "        xfree(fenc);"], "readability/braces"]
["src/nvim/fileio.c", ["    } else {", "      if (fenc_alloced)", "        xfree(fenc);"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /*", "   * Conversion may be required when the encoding of the file is different"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (converted) {", "", "    /* \"ucs-bom\" means we need to check the first bytes of the file"], "whitespace/blank_line"]
["src/nvim/fileio.c", ["", "    /* \"ucs-bom\" means we need to check the first bytes of the file", "     * for a BOM. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * Use the 'charconvert' expression when conversion is required"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#  endif", "      /* Skip conversion when it's already done (retry for wrong", "       * \"fileformat\"). */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          if (fd < 0) {", "            /* Re-opening the original file failed! */", "            EMSG(_(\"E202: Conversion made file unreadable!\"));"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            EMSG(_(\"E202: Conversion made file unreadable!\"));", "            error = TRUE;", "            goto failed;"], "readability/bool"]
["src/nvim/fileio.c", ["          ) {", "        /* Conversion wanted but we can't.", "         * Try the next conversion in 'fileencodings' */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* Set \"can_retry\" when it's possible to rewind the file and try with", "   * another \"fenc\" value.  It's FALSE when no other \"fenc\" to try, reading"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["                      && !read_buffer);", "    if (read_undo_file)", "      sha256_start(&sha_ctx);"], "readability/braces"]
["src/nvim/fileio.c", ["  while (!error && !got_int) {", "    /*", "     * We allocate as much space for the file as we can get, plus"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (new_buffer == NULL) {", "          error = TRUE;", "          break;"], "readability/bool"]
["src/nvim/fileio.c", ["        }", "        if (linerest)           /* copy characters from the previous buffer */", "          memmove(new_buffer, ptr - linerest, (size_t)linerest);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        }", "        if (linerest)           /* copy characters from the previous buffer */", "          memmove(new_buffer, ptr - linerest, (size_t)linerest);"], "readability/braces"]
["src/nvim/fileio.c", ["", "        /* May need room to translate into.", "         * For iconv() we don't really know the required space, use a"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (read_buffer) {", "          /*", "           * Read bytes from curbuf.  Used for converting text read"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["           */", "          if (read_buf_lnum > from)", "            size = 0;"], "readability/braces"]
["src/nvim/fileio.c", ["            size = 0;", "          else {", "            int n, ni;"], "readability/braces"]
["src/nvim/fileio.c", ["            size = 0;", "          else {", "            int n, ni;"], "readability/braces"]
["src/nvim/fileio.c", ["              if ((int)tlen + n + 1 > size) {", "                /* Filled up to \"size\", append partial line.", "                 * Change NL to NUL to reverse the effect done"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["                n = (int)(size - tlen);", "                for (ni = 0; ni < n; ++ni) {", "                  if (p[ni] == NL)"], "readability/increment"]
["src/nvim/fileio.c", ["                for (ni = 0; ni < n; ++ni) {", "                  if (p[ni] == NL)", "                    ptr[tlen++] = NUL;"], "readability/braces"]
["src/nvim/fileio.c", ["                    ptr[tlen++] = NUL;", "                  else", "                    ptr[tlen++] = p[ni];"], "readability/braces"]
["src/nvim/fileio.c", ["              } else {", "                /* Append whole line and new-line.  Change NL", "                * to NUL to reverse the effect done below. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["                * to NUL to reverse the effect done below. */", "                for (ni = 0; ni < n; ++ni) {", "                  if (p[ni] == NL)"], "readability/increment"]
["src/nvim/fileio.c", ["                for (ni = 0; ni < n; ++ni) {", "                  if (p[ni] == NL)", "                    ptr[tlen++] = NUL;"], "readability/braces"]
["src/nvim/fileio.c", ["                    ptr[tlen++] = NUL;", "                  else", "                    ptr[tlen++] = p[ni];"], "readability/braces"]
["src/nvim/fileio.c", ["                if (++read_buf_lnum > from) {", "                  /* When the last line didn't have an", "                   * end-of-line don't add it now either. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["                   * end-of-line don't add it now either. */", "                  if (!curbuf->b_p_eol)", "                    --tlen;"], "readability/braces"]
["src/nvim/fileio.c", ["                  if (!curbuf->b_p_eol)", "                    --tlen;", "                  size = tlen;"], "readability/increment"]
["src/nvim/fileio.c", ["        } else {", "          /*", "           * Read bytes from the file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (size <= 0) {", "          if (size < 0)                             /* read error */", "            error = TRUE;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (size <= 0) {", "          if (size < 0)                             /* read error */", "            error = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["          if (size < 0)                             /* read error */", "            error = TRUE;", "          else if (conv_restlen > 0) {"], "readability/bool"]
["src/nvim/fileio.c", ["            error = TRUE;", "          else if (conv_restlen > 0) {", "            /*"], "readability/braces"]
["src/nvim/fileio.c", ["          else if (conv_restlen > 0) {", "            /*", "             * Reached end-of-file but some trailing bytes could"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "            /* When we did a conversion report an error. */", "            if (fio_flags != 0"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["                ) {", "              if (can_retry)", "                goto rewind_retry;"], "readability/braces"]
["src/nvim/fileio.c", ["                goto rewind_retry;", "              if (conv_error == 0)", "                conv_error = curbuf->b_ml.ml_line_count"], "readability/braces"]
["src/nvim/fileio.c", ["            }", "            /* Remember the first linenr with an illegal byte */", "            else if (illegal_byte == 0)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            /* Remember the first linenr with an illegal byte */", "            else if (illegal_byte == 0)", "              illegal_byte = curbuf->b_ml.ml_line_count"], "whitespace/newline"]
["src/nvim/fileio.c", ["            } else {", "              /* Replace the trailing bytes with the replacement", "               * character if we were converting; if we weren't,"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["# endif", "                                                    )) {", "                while (conv_restlen > 0) {"], "whitespace/parens"]
["src/nvim/fileio.c", ["                  *(--ptr) = bad_char_behavior;", "                  --conv_restlen;", "                }"], "readability/increment"]
["src/nvim/fileio.c", ["", "      skip_read = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "      /*", "       * At start of file: Check for BOM."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "        /* no BOM detection in a short file or in binary mode */", "        if (size < 2 || curbuf->b_p_bin)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        /* no BOM detection in a short file or in binary mode */", "        if (size < 2 || curbuf->b_p_bin)", "          ccname = NULL;"], "readability/braces"]
["src/nvim/fileio.c", ["          ccname = NULL;", "        else", "          ccname = check_for_bom(ptr, size, &blen,"], "readability/braces"]
["src/nvim/fileio.c", ["          ccname = check_for_bom(ptr, size, &blen,", "              fio_flags == FIO_UCSBOM ? FIO_ALL : get_fio_flags(fenc));", "        if (ccname != NULL) {"], "whitespace/alignment"]
["src/nvim/fileio.c", ["        if (ccname != NULL) {", "          /* Remove BOM from the text */", "          filesize += blen;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          if (set_options) {", "            curbuf->b_p_bomb = TRUE;", "            curbuf->b_start_bomb = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["            curbuf->b_p_bomb = TRUE;", "            curbuf->b_start_bomb = TRUE;", "          }"], "readability/bool"]
["src/nvim/fileio.c", ["          } else {", "            /* BOM detected: set \"fenc\" and jump back */", "            if (fenc_alloced)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            /* BOM detected: set \"fenc\" and jump back */", "            if (fenc_alloced)", "              xfree(fenc);"], "readability/braces"]
["src/nvim/fileio.c", ["          }", "          /* retry reading without getting new bytes or rewinding */", "          skip_read = TRUE;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          /* retry reading without getting new bytes or rewinding */", "          skip_read = TRUE;", "          goto retry;"], "readability/bool"]
["src/nvim/fileio.c", ["", "      /* Include not converted bytes. */", "      ptr -= conv_restlen;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      conv_restlen = 0;", "      /*", "       * Break here for a read error or end-of-file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["       */", "      if (size <= 0)", "        break;"], "readability/braces"]
["src/nvim/fileio.c", ["      if (iconv_fd != (iconv_t)-1) {", "        /*", "         * Attempt conversion of the read bytes to 'encoding' using"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "        /*", "         * If there is conversion error or not enough room try using"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        while ((iconv(iconv_fd, (void *)&fromp, &from_size,", "                    &top, &to_size)", "                == (size_t)-1 && ICONV_ERRNO != ICONV_EINVAL)"], "whitespace/alignment"]
["src/nvim/fileio.c", ["               || from_size > CONV_RESTLEN) {", "          if (can_retry)", "            goto rewind_retry;"], "readability/braces"]
["src/nvim/fileio.c", ["            goto rewind_retry;", "          if (conv_error == 0)", "            conv_error = readfile_linenr(linecnt,"], "readability/braces"]
["src/nvim/fileio.c", ["            conv_error = readfile_linenr(linecnt,", "                ptr, (char_u *)top);", ""], "whitespace/alignment"]
["src/nvim/fileio.c", ["", "          /* Deal with a bad byte and continue with the next. */", "          ++fromp;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          /* Deal with a bad byte and continue with the next. */", "          ++fromp;", "          --from_size;"], "readability/increment"]
["src/nvim/fileio.c", ["          ++fromp;", "          --from_size;", "          if (bad_char_behavior == BAD_KEEP) {"], "readability/increment"]
["src/nvim/fileio.c", ["            *top++ = *(fromp - 1);", "            --to_size;", "          } else if (bad_char_behavior != BAD_DROP) {"], "readability/increment"]
["src/nvim/fileio.c", ["            *top++ = bad_char_behavior;", "            --to_size;", "          }"], "readability/increment"]
["src/nvim/fileio.c", ["        if (from_size > 0) {", "          /* Some remaining characters, keep them for the next", "           * round. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "        /* move the linerest to before the converted characters */", "        line_start = ptr - linerest;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          if (fio_flags == FIO_UTF8) {", "            /* Check for a trailing incomplete UTF-8 sequence */", "            tail = ptr + size - 1;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            tail = ptr + size - 1;", "            while (tail > ptr && (*tail & 0xc0) == 0x80)", "              --tail;"], "readability/braces"]
["src/nvim/fileio.c", ["            while (tail > ptr && (*tail & 0xc0) == 0x80)", "              --tail;", "            if (tail + utf_byte2len(*tail) <= ptr + size)"], "readability/increment"]
["src/nvim/fileio.c", ["              --tail;", "            if (tail + utf_byte2len(*tail) <= ptr + size)", "              tail = NULL;"], "readability/braces"]
["src/nvim/fileio.c", ["              tail = NULL;", "            else", "              p = tail;"], "readability/braces"]
["src/nvim/fileio.c", ["        } else if (fio_flags & (FIO_UCS2 | FIO_UTF16)) {", "          /* Check for a trailing byte */", "          p = ptr + (size & ~1);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          p = ptr + (size & ~1);", "          if (size & 1)", "            tail = p;"], "readability/braces"]
["src/nvim/fileio.c", ["          if ((fio_flags & FIO_UTF16) && p > ptr) {", "            /* Check for a trailing leading word */", "            if (fio_flags & FIO_ENDIAN_L) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            }", "            if (u8c >= 0xd800 && u8c <= 0xdbff)", "              tail = p;"], "readability/braces"]
["src/nvim/fileio.c", ["              tail = p;", "            else", "              p += 2;"], "readability/braces"]
["src/nvim/fileio.c", ["          }", "        } else {   /*  FIO_UCS4 */", "                     /* Check for trailing 1, 2 or 3 bytes */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        } else {   /*  FIO_UCS4 */", "                     /* Check for trailing 1, 2 or 3 bytes */", "          p = ptr + (size & ~3);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          p = ptr + (size & ~3);", "          if (size & 3)", "            tail = p;"], "readability/braces"]
["src/nvim/fileio.c", ["", "        /* If there is a trailing incomplete sequence move it to", "         * conv_rest[]. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        while (p > ptr) {", "          if (fio_flags & FIO_LATIN1)", "            u8c = *--p;"], "readability/braces"]
["src/nvim/fileio.c", ["            u8c = *--p;", "          else if (fio_flags & (FIO_UCS2 | FIO_UTF16)) {", "            if (fio_flags & FIO_ENDIAN_L) {"], "readability/braces"]
["src/nvim/fileio.c", ["              if (p == ptr) {", "                /* Missing leading word. */", "                if (can_retry)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["                /* Missing leading word. */", "                if (can_retry)", "                  goto rewind_retry;"], "readability/braces"]
["src/nvim/fileio.c", ["                  goto rewind_retry;", "                if (conv_error == 0)", "                  conv_error = readfile_linenr(linecnt,"], "readability/braces"]
["src/nvim/fileio.c", ["                  conv_error = readfile_linenr(linecnt,", "                      ptr, p);", "                if (bad_char_behavior == BAD_DROP)"], "whitespace/alignment"]
["src/nvim/fileio.c", ["                      ptr, p);", "                if (bad_char_behavior == BAD_DROP)", "                  continue;"], "readability/braces"]
["src/nvim/fileio.c", ["                  continue;", "                if (bad_char_behavior != BAD_KEEP)", "                  u8c = bad_char_behavior;"], "readability/braces"]
["src/nvim/fileio.c", ["", "              /* found second word of double-word, get the first", "               * word and compute the resulting character */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "              /* Check if the word is indeed a leading word. */", "              if (u16c < 0xd800 || u16c > 0xdbff) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["              if (u16c < 0xd800 || u16c > 0xdbff) {", "                if (can_retry)", "                  goto rewind_retry;"], "readability/braces"]
["src/nvim/fileio.c", ["                  goto rewind_retry;", "                if (conv_error == 0)", "                  conv_error = readfile_linenr(linecnt,"], "readability/braces"]
["src/nvim/fileio.c", ["                  conv_error = readfile_linenr(linecnt,", "                      ptr, p);", "                if (bad_char_behavior == BAD_DROP)"], "whitespace/alignment"]
["src/nvim/fileio.c", ["                      ptr, p);", "                if (bad_char_behavior == BAD_DROP)", "                  continue;"], "readability/braces"]
["src/nvim/fileio.c", ["                  continue;", "                if (bad_char_behavior != BAD_KEEP)", "                  u8c = bad_char_behavior;"], "readability/braces"]
["src/nvim/fileio.c", ["              u8c += *--p;", "            } else {          /* big endian */", "              u8c = *--p;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            }", "          } else {        /* UTF-8 */", "            if (*--p < 0x80)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          } else {        /* UTF-8 */", "            if (*--p < 0x80)", "              u8c = *p;"], "readability/braces"]
["src/nvim/fileio.c", ["              u8c = *p;", "            else {", "              len = utf_head_off(ptr, p);"], "readability/braces"]
["src/nvim/fileio.c", ["              u8c = *p;", "            else {", "              len = utf_head_off(ptr, p);"], "readability/braces"]
["src/nvim/fileio.c", ["              if (len == 0) {", "                /* Not a valid UTF-8 character, retry with", "                 * another fenc when possible, otherwise just"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["                 * report the error. */", "                if (can_retry)", "                  goto rewind_retry;"], "readability/braces"]
["src/nvim/fileio.c", ["                  goto rewind_retry;", "                if (conv_error == 0)", "                  conv_error = readfile_linenr(linecnt,"], "readability/braces"]
["src/nvim/fileio.c", ["                  conv_error = readfile_linenr(linecnt,", "                      ptr, p);", "                if (bad_char_behavior == BAD_DROP)"], "whitespace/alignment"]
["src/nvim/fileio.c", ["                      ptr, p);", "                if (bad_char_behavior == BAD_DROP)", "                  continue;"], "readability/braces"]
["src/nvim/fileio.c", ["                  continue;", "                if (bad_char_behavior != BAD_KEEP)", "                  u8c = bad_char_behavior;"], "readability/braces"]
["src/nvim/fileio.c", ["            if (l == 1 || l > todo) {", "              /* Illegal byte.  If we can try another encoding", "               * do that, unless at EOF where a truncated"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["               * file is more likely than a conversion error. */", "              if (can_retry && !incomplete_tail)", "                break;"], "readability/braces"]
["src/nvim/fileio.c", ["# endif", "              /* Remember the first linenr with an illegal byte */", "              if (conv_error == 0 && illegal_byte == 0)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["              /* Remember the first linenr with an illegal byte */", "              if (conv_error == 0 && illegal_byte == 0)", "                illegal_byte = readfile_linenr(linecnt, ptr, p);"], "readability/braces"]
["src/nvim/fileio.c", ["", "              /* Drop, keep or replace the bad byte. */", "              if (bad_char_behavior == BAD_DROP) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["                memmove(p, p + 1, todo - 1);", "                --p;", "                --size;"], "readability/increment"]
["src/nvim/fileio.c", ["                --p;", "                --size;", "              } else if (bad_char_behavior != BAD_KEEP)"], "readability/increment"]
["src/nvim/fileio.c", ["                --size;", "              } else if (bad_char_behavior != BAD_KEEP)", "                *p = bad_char_behavior;"], "readability/braces"]
["src/nvim/fileio.c", ["                *p = bad_char_behavior;", "            } else", "              p += l - 1;"], "readability/braces"]
["src/nvim/fileio.c", ["        if (p < ptr + size && !incomplete_tail) {", "          /* Detected a UTF-8 error. */", "rewind_retry:"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "      /* count the number of characters (after conversion!) */", "      filesize += size;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "      /*", "       * when reading the first part of a file: guess EOL type"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      if (fileformat == EOL_UNKNOWN) {", "        /* First try finding a NL, for Dos and Unix */", "        if (try_dos || try_unix) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "          for (p = ptr; p < ptr + size; ++p) {", "            if (*p == NL) {"], "readability/increment"]
["src/nvim/fileio.c", ["            if (*p == NL) {", "              if (!try_unix", "                  || (try_dos && p > ptr && p[-1] == CAR))"], "readability/braces"]
["src/nvim/fileio.c", ["                fileformat = EOL_DOS;", "              else", "                fileformat = EOL_UNIX;"], "readability/braces"]
["src/nvim/fileio.c", ["", "          /* Don't give in to EOL_UNIX if EOL_MAC is more likely */", "          if (fileformat == EOL_UNIX && try_mac) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          if (fileformat == EOL_UNIX && try_mac) {", "            /* Need to reset the counters when retrying fenc. */", "            try_mac = 1;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            try_unix = 1;", "            for (; p >= ptr && *p != CAR; p--)", "              ;"], "readability/braces"]
["src/nvim/fileio.c", ["            for (; p >= ptr && *p != CAR; p--)", "              ;", "            if (p >= ptr) {"], "whitespace/semicolon"]
["src/nvim/fileio.c", ["            if (p >= ptr) {", "              for (p = ptr; p < ptr + size; ++p) {", "                if (*p == NL)"], "readability/increment"]
["src/nvim/fileio.c", ["              for (p = ptr; p < ptr + size; ++p) {", "                if (*p == NL)", "                  try_unix++;"], "readability/braces"]
["src/nvim/fileio.c", ["                  try_unix++;", "                else if (*p == CAR)", "                  try_mac++;"], "readability/braces"]
["src/nvim/fileio.c", ["              }", "              if (try_mac > try_unix)", "                fileformat = EOL_MAC;"], "readability/braces"]
["src/nvim/fileio.c", ["", "        /* No NL found: may use Mac format */", "        if (fileformat == EOL_UNKNOWN && try_mac)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        /* No NL found: may use Mac format */", "        if (fileformat == EOL_UNKNOWN && try_mac)", "          fileformat = EOL_MAC;"], "readability/braces"]
["src/nvim/fileio.c", ["", "        /* Still nothing found?  Use first format in 'ffs' */", "        if (fileformat == EOL_UNKNOWN)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        /* Still nothing found?  Use first format in 'ffs' */", "        if (fileformat == EOL_UNKNOWN)", "          fileformat = default_fileformat();"], "readability/braces"]
["src/nvim/fileio.c", ["", "    /*", "     * This loop is executed once for every character read."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (fileformat == EOL_MAC) {", "      --ptr;", "      while (++ptr, --size >= 0) {"], "readability/increment"]
["src/nvim/fileio.c", ["      while (++ptr, --size >= 0) {", "        /* catch most common case first */", "        if ((c = *ptr) != NUL && c != CAR && c != NL)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        /* catch most common case first */", "        if ((c = *ptr) != NUL && c != CAR && c != NL)", "          continue;"], "readability/braces"]
["src/nvim/fileio.c", ["          continue;", "        if (c == NUL)", "          *ptr = NL;            /* NULs are replaced by newlines! */"], "readability/braces"]
["src/nvim/fileio.c", ["        if (c == NUL)", "          *ptr = NL;            /* NULs are replaced by newlines! */", "        else if (c == NL)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          *ptr = NL;            /* NULs are replaced by newlines! */", "        else if (c == NL)", "          *ptr = CAR;           /* NLs are replaced by CRs! */"], "readability/braces"]
["src/nvim/fileio.c", ["        else if (c == NL)", "          *ptr = CAR;           /* NLs are replaced by CRs! */", "        else {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          *ptr = CAR;           /* NLs are replaced by CRs! */", "        else {", "          if (skip_count == 0) {"], "readability/braces"]
["src/nvim/fileio.c", ["          *ptr = CAR;           /* NLs are replaced by CRs! */", "        else {", "          if (skip_count == 0) {"], "readability/braces"]
["src/nvim/fileio.c", ["          if (skip_count == 0) {", "            *ptr = NUL;                     /* end of line */", "            len = (colnr_T) (ptr - line_start + 1);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            *ptr = NUL;                     /* end of line */", "            len = (colnr_T) (ptr - line_start + 1);", "            if (ml_append(lnum, line_start, len, newfile) == FAIL) {"], "whitespace/cast"]
["src/nvim/fileio.c", ["            if (ml_append(lnum, line_start, len, newfile) == FAIL) {", "              error = TRUE;", "              break;"], "readability/bool"]
["src/nvim/fileio.c", ["            }", "            if (read_undo_file)", "              sha256_update(&sha_ctx, line_start, len);"], "readability/braces"]
["src/nvim/fileio.c", ["              sha256_update(&sha_ctx, line_start, len);", "            ++lnum;", "            if (--read_count == 0) {"], "readability/increment"]
["src/nvim/fileio.c", ["            if (--read_count == 0) {", "              error = TRUE;                     /* break loop */", "              line_start = ptr;                 /* nothing left to write */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            if (--read_count == 0) {", "              error = TRUE;                     /* break loop */", "              line_start = ptr;                 /* nothing left to write */"], "readability/bool"]
["src/nvim/fileio.c", ["              error = TRUE;                     /* break loop */", "              line_start = ptr;                 /* nothing left to write */", "              break;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            }", "          } else", "            --skip_count;"], "readability/braces"]
["src/nvim/fileio.c", ["          } else", "            --skip_count;", "          line_start = ptr + 1;"], "readability/increment"]
["src/nvim/fileio.c", ["    } else {", "      --ptr;", "      while (++ptr, --size >= 0) {"], "readability/increment"]
["src/nvim/fileio.c", ["      while (++ptr, --size >= 0) {", "        if ((c = *ptr) != NUL && c != NL)          /* catch most common case */", "          continue;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      while (++ptr, --size >= 0) {", "        if ((c = *ptr) != NUL && c != NL)          /* catch most common case */", "          continue;"], "readability/braces"]
["src/nvim/fileio.c", ["          continue;", "        if (c == NUL)", "          *ptr = NL;            /* NULs are replaced by newlines! */"], "readability/braces"]
["src/nvim/fileio.c", ["        if (c == NUL)", "          *ptr = NL;            /* NULs are replaced by newlines! */", "        else {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          *ptr = NL;            /* NULs are replaced by newlines! */", "        else {", "          if (skip_count == 0) {"], "readability/braces"]
["src/nvim/fileio.c", ["          *ptr = NL;            /* NULs are replaced by newlines! */", "        else {", "          if (skip_count == 0) {"], "readability/braces"]
["src/nvim/fileio.c", ["          if (skip_count == 0) {", "            *ptr = NUL;                         /* end of line */", "            len = (colnr_T)(ptr - line_start + 1);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["                  fileformat = EOL_UNIX;", "                  if (set_options)", "                    set_fileformat(EOL_UNIX, OPT_LOCAL);"], "readability/braces"]
["src/nvim/fileio.c", ["            if (ml_append(lnum, line_start, len, newfile) == FAIL) {", "              error = TRUE;", "              break;"], "readability/bool"]
["src/nvim/fileio.c", ["            }", "            if (read_undo_file)", "              sha256_update(&sha_ctx, line_start, len);"], "readability/braces"]
["src/nvim/fileio.c", ["              sha256_update(&sha_ctx, line_start, len);", "            ++lnum;", "            if (--read_count == 0) {"], "readability/increment"]
["src/nvim/fileio.c", ["            if (--read_count == 0) {", "              error = TRUE;                         /* break loop */", "              line_start = ptr;                 /* nothing left to write */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            if (--read_count == 0) {", "              error = TRUE;                         /* break loop */", "              line_start = ptr;                 /* nothing left to write */"], "readability/bool"]
["src/nvim/fileio.c", ["              error = TRUE;                         /* break loop */", "              line_start = ptr;                 /* nothing left to write */", "              break;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            }", "          } else", "            --skip_count;"], "readability/braces"]
["src/nvim/fileio.c", ["          } else", "            --skip_count;", "          line_start = ptr + 1;"], "readability/increment"]
["src/nvim/fileio.c", ["failed:", "  /* not an error, max. number of lines reached */", "  if (error && read_count == 0)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  /* not an error, max. number of lines reached */", "  if (error && read_count == 0)", "    error = FALSE;"], "readability/braces"]
["src/nvim/fileio.c", ["  if (error && read_count == 0)", "    error = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * If we get EOF in the middle of a line, note the fact and"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["           && ptr == line_start + 1)) {", "    /* remember for when writing */", "    if (set_options)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    /* remember for when writing */", "    if (set_options)", "      curbuf->b_p_eol = FALSE;"], "readability/braces"]
["src/nvim/fileio.c", ["    if (set_options)", "      curbuf->b_p_eol = FALSE;", "    *ptr = NUL;"], "readability/bool"]
["src/nvim/fileio.c", ["    len = (colnr_T)(ptr - line_start + 1);", "    if (ml_append(lnum, line_start, len, newfile) == FAIL)", "      error = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["    if (ml_append(lnum, line_start, len, newfile) == FAIL)", "      error = TRUE;", "    else {"], "readability/bool"]
["src/nvim/fileio.c", ["      error = TRUE;", "    else {", "      if (read_undo_file)"], "readability/braces"]
["src/nvim/fileio.c", ["      error = TRUE;", "    else {", "      if (read_undo_file)"], "readability/braces"]
["src/nvim/fileio.c", ["    else {", "      if (read_undo_file)", "        sha256_update(&sha_ctx, line_start, len);"], "readability/braces"]
["src/nvim/fileio.c", ["  }", "  if (fenc_alloced)", "    xfree(fenc);"], "readability/braces"]
["src/nvim/fileio.c", ["  }", "  --no_wait_return;                     /* may wait for return now */", ""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  }", "  --no_wait_return;                     /* may wait for return now */", ""], "readability/increment"]
["src/nvim/fileio.c", ["", "  /*", "   * In recovery mode everything but autocommands is skipped."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (!recoverymode) {", "    /* need to delete the last line, which comes from the empty buffer */", "    if (newfile && wasempty && !(curbuf->b_ml.ml_flags & ML_EMPTY)) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    linecnt = curbuf->b_ml.ml_line_count - linecnt;", "    if (filesize == 0)", "      linecnt = 0;"], "readability/braces"]
["src/nvim/fileio.c", ["      redraw_curbuf_later(NOT_VALID);", "      /* After reading the text into the buffer the diff info needs to", "       * be updated. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      diff_invalidate(curbuf);", "      /* All folds in the window are invalid now.  Mark them for update", "       * before triggering autocommands. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      foldUpdateAll(curwin);", "    } else if (linecnt)                 /* appended at least one line */", "      appended_lines_mark(from, linecnt);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      foldUpdateAll(curwin);", "    } else if (linecnt)                 /* appended at least one line */", "      appended_lines_mark(from, linecnt);"], "readability/braces"]
["src/nvim/fileio.c", ["", "    /*", "     * If we were reading from the same terminal as where messages go,"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        filemess(curbuf, sfname, (char_u *)_(e_interr), 0);", "        if (newfile)", "          curbuf->b_p_ro = TRUE;                /* must use \"w!\" now */"], "readability/braces"]
["src/nvim/fileio.c", ["        if (newfile)", "          curbuf->b_p_ro = TRUE;                /* must use \"w!\" now */", "      }"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (newfile)", "          curbuf->b_p_ro = TRUE;                /* must use \"w!\" now */", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["      check_marks_read();", "      return OK;                /* an interrupt isn't really an error */", "    }"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[fifo]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[socket]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["# ifdef OPEN_CHR_FILES", "      if (S_ISCHR(perm)) {                          /* or character special */", "        STRCAT(IObuff, _(\"[character special]\"));"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[character special]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, shortmess(SHM_RO) ? _(\"[RO]\") : _(\"[readonly]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        msg_add_eol();", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[CR missing]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[NOT converted]\"));", "        c = TRUE;", "      } else if (converted) {"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[converted]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        sprintf((char *)IObuff + STRLEN(IObuff),", "            _(\"[CONVERSION ERROR in line %\" PRId64 \"]\"), (int64_t)conv_error);", "        c = TRUE;"], "whitespace/alignment"]
["src/nvim/fileio.c", ["      if (conv_error != 0) {", "        sprintf((char *)IObuff + STRLEN(IObuff),", "            _(\"[CONVERSION ERROR in line %\" PRId64 \"]\"), (int64_t)conv_error);"], "runtime/printf"]
["src/nvim/fileio.c", ["            _(\"[CONVERSION ERROR in line %\" PRId64 \"]\"), (int64_t)conv_error);", "        c = TRUE;", "      } else if (illegal_byte > 0) {"], "readability/bool"]
["src/nvim/fileio.c", ["        sprintf((char *)IObuff + STRLEN(IObuff),", "            _(\"[ILLEGAL BYTE in line %\" PRId64 \"]\"), (int64_t)illegal_byte);", "        c = TRUE;"], "whitespace/alignment"]
["src/nvim/fileio.c", ["      } else if (illegal_byte > 0) {", "        sprintf((char *)IObuff + STRLEN(IObuff),", "            _(\"[ILLEGAL BYTE in line %\" PRId64 \"]\"), (int64_t)illegal_byte);"], "runtime/printf"]
["src/nvim/fileio.c", ["            _(\"[ILLEGAL BYTE in line %\" PRId64 \"]\"), (int64_t)illegal_byte);", "        c = TRUE;", "      } else if (error)  {"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[READ ERRORS]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["      }", "      if (msg_add_fileformat(fileformat))", "        c = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["      if (msg_add_fileformat(fileformat))", "        c = TRUE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["      p = NULL;", "      msg_scrolled_ign = TRUE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["      if (!read_stdin && !read_buffer) {", "        p = msg_trunc_attr(IObuff, FALSE, 0);", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["      }", "      msg_scrolled_ign = FALSE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["", "    /* with errors writing the file requires \":w!\" */", "    if (newfile && (error"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    /* with errors writing the file requires \":w!\" */", "    if (newfile && (error", "                    || conv_error != 0"], "readability/braces"]
["src/nvim/fileio.c", ["                    || (illegal_byte > 0 && bad_char_behavior != BAD_KEEP)", "                    ))", "      curbuf->b_p_ro = TRUE;"], "whitespace/parens"]
["src/nvim/fileio.c", ["                    ))", "      curbuf->b_p_ro = TRUE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "    u_clearline();          /* cannot use \"U\" command after adding lines */", ""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * In Ex mode: cursor at last new line."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["     */", "    if (exmode_active)", "      curwin->w_cursor.lnum = from + linecnt;"], "readability/braces"]
["src/nvim/fileio.c", ["      curwin->w_cursor.lnum = from + linecnt;", "    else", "      curwin->w_cursor.lnum = from + 1;"], "readability/braces"]
["src/nvim/fileio.c", ["    check_cursor_lnum();", "    beginline(BL_WHITE | BL_FIX);           /* on first non-blank */", ""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * Set '[ and '] marks to the newly read lines."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    curbuf->b_op_end.col = 0;", "", "  }"], "whitespace/blank_line"]
["src/nvim/fileio.c", ["", "  /*", "   * Get the marks before executing autocommands, so they can be used there."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * We remember if the last line of the read didn't have"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* When reloading a buffer put the cursor at the first line that is", "   * different. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["   * different. */", "  if (flags & READ_KEEP_UNDO)", "    u_find_first_changed();"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /*", "   * When opening a new file locate undo info and read it."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /* Save the fileformat now, otherwise the buffer will be considered", "     * modified if the format/encoding was automatically detected. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["     * modified if the format/encoding was automatically detected. */", "    if (set_options)", "      save_file_ff(curbuf);"], "readability/braces"]
["src/nvim/fileio.c", ["", "    /*", "     * The output from the autocommands should not overwrite anything and"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  if (recoverymode && error)", "    return FAIL;"], "readability/braces"]
["src/nvim/fileio.c", ["  return OK;", "}", ""], "readability/fn_size"]
["src/nvim/fileio.c", ["", "/*", " * From the current line count and characters read after that, estimate the"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  lnum = curbuf->b_ml.ml_line_count - linecnt + 1;", "  for (s = p; s < endp; ++s)", "    if (*s == '\\n')"], "readability/braces"]
["src/nvim/fileio.c", ["  lnum = curbuf->b_ml.ml_line_count - linecnt + 1;", "  for (s = p; s < endp; ++s)", "    if (*s == '\\n')"], "readability/increment"]
["src/nvim/fileio.c", ["  for (s = p; s < endp; ++s)", "    if (*s == '\\n')", "      ++lnum;"], "readability/braces"]
["src/nvim/fileio.c", ["    if (*s == '\\n')", "      ++lnum;", "  return lnum;"], "readability/increment"]
["src/nvim/fileio.c", ["", "/*", " * Fill \"*eap\" to force the 'fileencoding', 'fileformat' and 'binary to be"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  eap->force_bin = buf->b_p_bin ? FORCE_BIN : FORCE_NOBIN;", "  eap->read_edit = FALSE;", "  eap->forceit = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["  eap->read_edit = FALSE;", "  eap->forceit = FALSE;", "}"], "readability/bool"]
["src/nvim/fileio.c", ["", "/*", " * Set default or forced 'fileformat' and 'binary'."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["{", "  /* set default 'fileformat' */", "  if (set_options) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (set_options) {", "    if (eap != NULL && eap->force_ff != 0)", "      set_fileformat(get_fileformat_force(curbuf, eap), OPT_LOCAL);"], "readability/braces"]
["src/nvim/fileio.c", ["      set_fileformat(get_fileformat_force(curbuf, eap), OPT_LOCAL);", "    else if (*p_ffs != NUL)", "      set_fileformat(default_fileformat(), OPT_LOCAL);"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /* set or reset 'binary' */", "  if (eap != NULL && eap->force_bin != 0) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/*", " * Set forced 'fileencoding'."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/*", " * Convert a file with the 'charconvert' expression."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["static char_u *", "readfile_charconvert (", "    char_u *fname,             /* name of input file */"], "whitespace/parens"]
["src/nvim/fileio.c", ["readfile_charconvert (", "    char_u *fname,             /* name of input file */", "    char_u *fenc,              /* converted from */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    char_u *fname,             /* name of input file */", "    char_u *fenc,              /* converted from */", "    int *fdp               /* in/out: file descriptor of file */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    char_u *fenc,              /* converted from */", "    int *fdp               /* in/out: file descriptor of file */", ")"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  tmpname = vim_tempname();", "  if (tmpname == NULL)", "    errmsg = (char_u *)_(\"Can't find temp file for conversion\");"], "readability/braces"]
["src/nvim/fileio.c", ["    errmsg = (char_u *)_(\"Can't find temp file for conversion\");", "  else {", "    close(*fdp);                /* close the input file, ignore errors */"], "readability/braces"]
["src/nvim/fileio.c", ["    errmsg = (char_u *)_(\"Can't find temp file for conversion\");", "  else {", "    close(*fdp);                /* close the input file, ignore errors */"], "readability/braces"]
["src/nvim/fileio.c", ["  else {", "    close(*fdp);                /* close the input file, ignore errors */", "    *fdp = -1;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (errmsg != NULL) {", "    /* Don't use emsg(), it breaks mappings, the retry with", "     * another type of conversion might still work. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* If the input file is closed, open it (caller should check for error). */", "  if (*fdp < 0) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/*", " * Read marks for the current buffer from the ShaDa file, when we support"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* Always set b_marks_read; needed when 'shada' is changed to include", "   * the ' parameter after opening a buffer. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/*", " * buf_write() - write to file \"fname\" lines \"start\" through \"end\""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    exarg_T *eap,                   /* for forced 'ff' and 'fenc', can be", "                                           NULL! */", "    int append,                             /* append to the file */"], "whitespace/indent"]
["src/nvim/fileio.c", ["    linenr_T end,", "    exarg_T *eap,                   /* for forced 'ff' and 'fenc', can be", "                                           NULL! */"], "readability/multiline_comment"]
["src/nvim/fileio.c", ["    linenr_T end,", "    exarg_T *eap,                   /* for forced 'ff' and 'fenc', can be", "                                           NULL! */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    exarg_T *eap,                   /* for forced 'ff' and 'fenc', can be", "                                           NULL! */", "    int append,                             /* append to the file */"], "whitespace/operators"]
["src/nvim/fileio.c", ["                                           NULL! */", "    int append,                             /* append to the file */", "    int forceit,"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  char_u          *backup = NULL;", "  int backup_copy = FALSE;               /* copy the original file? */", "  int dobackup;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  char_u          *backup = NULL;", "  int backup_copy = FALSE;               /* copy the original file? */", "  int dobackup;"], "readability/bool"]
["src/nvim/fileio.c", ["  char_u          *ffname;", "  char_u          *wfname = NULL;       /* name of file to write to */", "  char_u          *s;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#if defined(UNIX)", "  int made_writable = FALSE;                /* 'w' bit has been set */", "#endif"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#if defined(UNIX)", "  int made_writable = FALSE;                /* 'w' bit has been set */", "#endif"], "readability/bool"]
["src/nvim/fileio.c", ["#endif", "  /* writing everything */", "  int whole = (start == 1 && end == buf->b_ml.ml_line_count);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  int write_bin;", "  struct bw_info write_info;            /* info for buf_write_bytes() */", "  int converted = FALSE;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  struct bw_info write_info;            /* info for buf_write_bytes() */", "  int converted = FALSE;", "  int notconverted = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["  int converted = FALSE;", "  int notconverted = FALSE;", "  char_u          *fenc;                /* effective 'fileencoding' */"], "readability/bool"]
["src/nvim/fileio.c", ["  int notconverted = FALSE;", "  char_u          *fenc;                /* effective 'fileencoding' */", "  char_u          *fenc_tofree = NULL;   /* allocated \"fenc\" */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  char_u          *fenc;                /* effective 'fileencoding' */", "  char_u          *fenc_tofree = NULL;   /* allocated \"fenc\" */", "#ifdef HAS_BW_FLAGS"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#ifdef HAVE_ACL", "  vim_acl_T acl = NULL;                 /* ACL copied from original file to", "                                           backup or new file */"], "readability/multiline_comment"]
["src/nvim/fileio.c", ["#ifdef HAVE_ACL", "  vim_acl_T acl = NULL;                 /* ACL copied from original file to", "                                           backup or new file */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#endif", "  int write_undo_file = FALSE;", "  context_sha256_T sha_ctx;"], "readability/bool"]
["src/nvim/fileio.c", ["", "  if (fname == NULL || *fname == NUL)   /* safety check */", "    return FAIL;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  if (fname == NULL || *fname == NUL)   /* safety check */", "    return FAIL;"], "readability/braces"]
["src/nvim/fileio.c", ["  if (buf->b_ml.ml_mfp == NULL) {", "    /* This can happen during startup when there is a stray \"w\" in the", "     * vimrc file. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Disallow writing from .exrc and .vimrc in current directory for"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["   */", "  if (check_secure())", "    return FAIL;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /* Avoid a crash for a long name. */", "  if (STRLEN(fname) >= MAXPATHL) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* must init bw_conv_buf and bw_iconv_fd before jumping to \"fail\" */", "  write_info.bw_conv_buf = NULL;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  write_info.bw_conv_buf = NULL;", "  write_info.bw_conv_error = FALSE;", "  write_info.bw_conv_error_lnum = 0;"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /* After writing a file changedtick changes but we don't want to display", "   * the line. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["   * the line. */", "  ex_no_reprint = TRUE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * If there is no file name yet, use the one for the written file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      && vim_strchr(p_cpo, CPO_FNAMEW) != NULL) {", "    if (set_rw_fname(fname, sfname) == FAIL)", "      return FAIL;"], "readability/braces"]
["src/nvim/fileio.c", ["      return FAIL;", "    buf = curbuf;           /* just in case autocmds made \"buf\" invalid */", "  }"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  if (sfname == NULL)", "    sfname = fname;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  if (buf->b_ffname != NULL && fnamecmp(ffname, buf->b_ffname) == 0)", "    overwriting = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["  if (buf->b_ffname != NULL && fnamecmp(ffname, buf->b_ffname) == 0)", "    overwriting = TRUE;", "  else"], "readability/bool"]
["src/nvim/fileio.c", ["    overwriting = TRUE;", "  else", "    overwriting = FALSE;"], "readability/braces"]
["src/nvim/fileio.c", ["  else", "    overwriting = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  ++no_wait_return;                 /* don't wait for return yet */", ""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  ++no_wait_return;                 /* don't wait for return yet */", ""], "readability/increment"]
["src/nvim/fileio.c", ["", "  /*", "   * Set '[ and '] marks to the lines to be written."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    aco_save_T aco;", "    int buf_ffname = FALSE;", "    int buf_sfname = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    int buf_ffname = FALSE;", "    int buf_sfname = FALSE;", "    int buf_fname_f = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    int buf_sfname = FALSE;", "    int buf_fname_f = FALSE;", "    int buf_fname_s = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    int buf_fname_f = FALSE;", "    int buf_fname_s = FALSE;", "    int did_cmd = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    int buf_fname_s = FALSE;", "    int did_cmd = FALSE;", "    int nofile_err = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    int did_cmd = FALSE;", "    int nofile_err = FALSE;", "    int empty_memline = (buf->b_ml.ml_mfp == NULL);"], "readability/bool"]
["src/nvim/fileio.c", ["", "    /*", "     * Apply PRE autocommands."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["     */", "    if (ffname == buf->b_ffname)", "      buf_ffname = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["    if (ffname == buf->b_ffname)", "      buf_ffname = TRUE;", "    if (sfname == buf->b_sfname)"], "readability/bool"]
["src/nvim/fileio.c", ["      buf_ffname = TRUE;", "    if (sfname == buf->b_sfname)", "      buf_sfname = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["    if (sfname == buf->b_sfname)", "      buf_sfname = TRUE;", "    if (fname == buf->b_ffname)"], "readability/bool"]
["src/nvim/fileio.c", ["      buf_sfname = TRUE;", "    if (fname == buf->b_ffname)", "      buf_fname_f = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["    if (fname == buf->b_ffname)", "      buf_fname_f = TRUE;", "    if (fname == buf->b_sfname)"], "readability/bool"]
["src/nvim/fileio.c", ["      buf_fname_f = TRUE;", "    if (fname == buf->b_sfname)", "      buf_fname_s = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["    if (fname == buf->b_sfname)", "      buf_fname_s = TRUE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["      if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEAPPENDCMD,", "                sfname, sfname, FALSE, curbuf, eap))) {", "        if (overwriting && bt_nofile(curbuf))"], "whitespace/alignment"]
["src/nvim/fileio.c", ["      if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEAPPENDCMD,", "                sfname, sfname, FALSE, curbuf, eap))) {", "        if (overwriting && bt_nofile(curbuf))"], "readability/bool"]
["src/nvim/fileio.c", ["                sfname, sfname, FALSE, curbuf, eap))) {", "        if (overwriting && bt_nofile(curbuf))", "          nofile_err = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["        if (overwriting && bt_nofile(curbuf))", "          nofile_err = TRUE;", "        else"], "readability/bool"]
["src/nvim/fileio.c", ["          nofile_err = TRUE;", "        else", "          apply_autocmds_exarg(EVENT_FILEAPPENDPRE,"], "readability/braces"]
["src/nvim/fileio.c", ["          apply_autocmds_exarg(EVENT_FILEAPPENDPRE,", "              sfname, sfname, FALSE, curbuf, eap);", "      }"], "whitespace/alignment"]
["src/nvim/fileio.c", ["          apply_autocmds_exarg(EVENT_FILEAPPENDPRE,", "              sfname, sfname, FALSE, curbuf, eap);", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILTERWRITEPRE,", "          NULL, sfname, FALSE, curbuf, eap);", "    } else if (reset_changed && whole)   {"], "whitespace/alignment"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILTERWRITEPRE,", "          NULL, sfname, FALSE, curbuf, eap);", "    } else if (reset_changed && whole)   {"], "readability/bool"]
["src/nvim/fileio.c", ["      did_cmd = apply_autocmds_exarg(EVENT_BUFWRITECMD,", "          sfname, sfname, FALSE, curbuf, eap);", "      if (did_cmd) {"], "whitespace/alignment"]
["src/nvim/fileio.c", ["      did_cmd = apply_autocmds_exarg(EVENT_BUFWRITECMD,", "          sfname, sfname, FALSE, curbuf, eap);", "      if (did_cmd) {"], "readability/bool"]
["src/nvim/fileio.c", ["        if (was_changed && !curbufIsChanged()) {", "          /* Written everything correctly and BufWriteCmd has reset", "           * 'modified': Correct the undo information so that an"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      } else {", "        if (overwriting && bt_nofile(curbuf))", "          nofile_err = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["        if (overwriting && bt_nofile(curbuf))", "          nofile_err = TRUE;", "        else"], "readability/bool"]
["src/nvim/fileio.c", ["          nofile_err = TRUE;", "        else", "          apply_autocmds_exarg(EVENT_BUFWRITEPRE,"], "readability/braces"]
["src/nvim/fileio.c", ["          apply_autocmds_exarg(EVENT_BUFWRITEPRE,", "              sfname, sfname, FALSE, curbuf, eap);", "      }"], "whitespace/alignment"]
["src/nvim/fileio.c", ["          apply_autocmds_exarg(EVENT_BUFWRITEPRE,", "              sfname, sfname, FALSE, curbuf, eap);", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["      if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEWRITECMD,", "                sfname, sfname, FALSE, curbuf, eap))) {", "        if (overwriting && bt_nofile(curbuf))"], "whitespace/alignment"]
["src/nvim/fileio.c", ["      if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEWRITECMD,", "                sfname, sfname, FALSE, curbuf, eap))) {", "        if (overwriting && bt_nofile(curbuf))"], "readability/bool"]
["src/nvim/fileio.c", ["                sfname, sfname, FALSE, curbuf, eap))) {", "        if (overwriting && bt_nofile(curbuf))", "          nofile_err = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["        if (overwriting && bt_nofile(curbuf))", "          nofile_err = TRUE;", "        else"], "readability/bool"]
["src/nvim/fileio.c", ["          nofile_err = TRUE;", "        else", "          apply_autocmds_exarg(EVENT_FILEWRITEPRE,"], "readability/braces"]
["src/nvim/fileio.c", ["          apply_autocmds_exarg(EVENT_FILEWRITEPRE,", "              sfname, sfname, FALSE, curbuf, eap);", "      }"], "whitespace/alignment"]
["src/nvim/fileio.c", ["          apply_autocmds_exarg(EVENT_FILEWRITEPRE,", "              sfname, sfname, FALSE, curbuf, eap);", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["", "    /* restore curwin/curbuf and a few other things */", "    aucmd_restbuf(&aco);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        ) {", "      --no_wait_return;", "      msg_scroll = msg_save;"], "readability/increment"]
["src/nvim/fileio.c", ["      msg_scroll = msg_save;", "      if (nofile_err)", "        EMSG(_(\"E676: No matching autocommands for acwrite buffer\"));"], "readability/braces"]
["src/nvim/fileio.c", ["", "      if (nofile_err", "          || aborting()"], "readability/braces"]
["src/nvim/fileio.c", ["          )", "        /* An aborting error, interrupt or exception in the", "         * autocommands. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      if (did_cmd) {", "        if (buf == NULL)", "          /* The buffer was deleted.  We assume it was written"], "readability/braces"]
["src/nvim/fileio.c", ["        if (buf == NULL)", "          /* The buffer was deleted.  We assume it was written", "           * (can't retry anyway). */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (overwriting) {", "          /* Assume the buffer was written, update the timestamp. */", "          ml_timestamp(buf);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          ml_timestamp(buf);", "          if (append)", "            buf->b_flags &= ~BF_NEW;"], "readability/braces"]
["src/nvim/fileio.c", ["            buf->b_flags &= ~BF_NEW;", "          else", "            buf->b_flags &= ~BF_WRITE_MASK;"], "readability/braces"]
["src/nvim/fileio.c", ["        }", "        if (reset_changed && buf->b_changed && !append", "            && (overwriting || vim_strchr(p_cpo, CPO_PLUS) != NULL))"], "readability/braces"]
["src/nvim/fileio.c", ["            && (overwriting || vim_strchr(p_cpo, CPO_PLUS) != NULL))", "          /* Buffer still changed, the autocommands didn't work", "           * properly. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      }", "      if (!aborting())", "        EMSG(_(\"E203: Autocommands deleted or unloaded buffer to be written\"));"], "readability/braces"]
["src/nvim/fileio.c", ["", "    /*", "     * The autocommands may have changed the number of lines in the file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (buf->b_ml.ml_line_count != old_line_count) {", "      if (whole)                                                /* write all */", "        end = buf->b_ml.ml_line_count;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (buf->b_ml.ml_line_count != old_line_count) {", "      if (whole)                                                /* write all */", "        end = buf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/fileio.c", ["        end = buf->b_ml.ml_line_count;", "      else if (buf->b_ml.ml_line_count > old_line_count)        /* more lines */", "        end += buf->b_ml.ml_line_count - old_line_count;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        end = buf->b_ml.ml_line_count;", "      else if (buf->b_ml.ml_line_count > old_line_count)        /* more lines */", "        end += buf->b_ml.ml_line_count - old_line_count;"], "readability/braces"]
["src/nvim/fileio.c", ["        end += buf->b_ml.ml_line_count - old_line_count;", "      else {                                                    /* less lines */", "        end -= old_line_count - buf->b_ml.ml_line_count;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        end += buf->b_ml.ml_line_count - old_line_count;", "      else {                                                    /* less lines */", "        end -= old_line_count - buf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/fileio.c", ["        end += buf->b_ml.ml_line_count - old_line_count;", "      else {                                                    /* less lines */", "        end -= old_line_count - buf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/fileio.c", ["        if (end < start) {", "          --no_wait_return;", "          msg_scroll = msg_save;"], "readability/increment"]
["src/nvim/fileio.c", ["          msg_scroll = msg_save;", "          EMSG(_(\"E204: Autocommand changed number of lines in unexpected way\"));", "          return FAIL;"], "whitespace/line_length"]
["src/nvim/fileio.c", ["", "    /*", "     * The autocommands may have changed the name of the buffer, which may"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["     */", "    if (buf_ffname)", "      ffname = buf->b_ffname;"], "readability/braces"]
["src/nvim/fileio.c", ["      ffname = buf->b_ffname;", "    if (buf_sfname)", "      sfname = buf->b_sfname;"], "readability/braces"]
["src/nvim/fileio.c", ["      sfname = buf->b_sfname;", "    if (buf_fname_f)", "      fname = buf->b_ffname;"], "readability/braces"]
["src/nvim/fileio.c", ["      fname = buf->b_ffname;", "    if (buf_fname_s)", "      fname = buf->b_sfname;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  if (shortmess(SHM_OVER) && !exiting)", "    msg_scroll = FALSE;             /* overwrite previous file message */"], "readability/braces"]
["src/nvim/fileio.c", ["  if (shortmess(SHM_OVER) && !exiting)", "    msg_scroll = FALSE;             /* overwrite previous file message */", "  else"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (shortmess(SHM_OVER) && !exiting)", "    msg_scroll = FALSE;             /* overwrite previous file message */", "  else"], "readability/bool"]
["src/nvim/fileio.c", ["    msg_scroll = FALSE;             /* overwrite previous file message */", "  else", "    msg_scroll = TRUE;              /* don't overwrite previous file message */"], "readability/braces"]
["src/nvim/fileio.c", ["  else", "    msg_scroll = TRUE;              /* don't overwrite previous file message */", "  if (!filtering)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  else", "    msg_scroll = TRUE;              /* don't overwrite previous file message */", "  if (!filtering)"], "readability/bool"]
["src/nvim/fileio.c", ["    msg_scroll = TRUE;              /* don't overwrite previous file message */", "  if (!filtering)", "    filemess(buf,"], "readability/braces"]
["src/nvim/fileio.c", ["#ifndef UNIX", "        sfname,", "#else"], "whitespace/alignment"]
["src/nvim/fileio.c", ["#else", "        fname,", "#endif"], "whitespace/alignment"]
["src/nvim/fileio.c", ["#endif", "        (char_u *)\"\", 0);               /* show that we are busy */", "  msg_scroll = FALSE;               /* always overwrite the file message now */"], "whitespace/alignment"]
["src/nvim/fileio.c", ["#endif", "        (char_u *)\"\", 0);               /* show that we are busy */", "  msg_scroll = FALSE;               /* always overwrite the file message now */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        (char_u *)\"\", 0);               /* show that we are busy */", "  msg_scroll = FALSE;               /* always overwrite the file message now */", ""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        (char_u *)\"\", 0);               /* show that we are busy */", "  msg_scroll = FALSE;               /* always overwrite the file message now */", ""], "readability/bool"]
["src/nvim/fileio.c", ["    bufsize = SMBUFSIZE;", "  } else", "    bufsize = BUFSIZE;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /*", "   * Get information about original file (if there is one)."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (!os_fileinfo((char *)fname, &file_info_old)) {", "    newfile = TRUE;", "  } else {"], "readability/bool"]
["src/nvim/fileio.c", ["    perm = file_info_old.stat.st_mode;", "    if (!S_ISREG(file_info_old.stat.st_mode)) {             /* not a file */", "      if (S_ISDIR(file_info_old.stat.st_mode)) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      }", "      /* It's a device of some kind (or a fifo) which we can write to", "       * but for which we can't make a backup. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["       * but for which we can't make a backup. */", "      device = TRUE;", "      newfile = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["      device = TRUE;", "      newfile = TRUE;", "      perm = -1;"], "readability/bool"]
["src/nvim/fileio.c", ["  if (c == NODE_WRITABLE) {", "    device = TRUE;", "    newfile = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["    device = TRUE;", "    newfile = TRUE;", "    perm = -1;"], "readability/bool"]
["src/nvim/fileio.c", ["  if (!device && !newfile) {", "    /*", "     * Check if the file is really writable (when renaming the file to"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * Check if the timestamp hasn't changed since reading the file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      retval = check_mtime(buf, &file_info_old);", "      if (retval == FAIL)", "        goto fail;"], "readability/braces"]
["src/nvim/fileio.c", ["#ifdef HAVE_ACL", "  /*", "   * For systems that support ACL: get the ACL from the original file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["   */", "  if (!newfile)", "    acl = mch_get_acl(fname);"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /*", "   * If 'backupskip' is not empty, don't make a backup for some files."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  dobackup = (p_wb || p_bk || *p_pm != NUL);", "  if (dobackup && *p_bsk != NUL && match_file_list(p_bsk, sfname, ffname))", "    dobackup = FALSE;"], "readability/braces"]
["src/nvim/fileio.c", ["  if (dobackup && *p_bsk != NUL && match_file_list(p_bsk, sfname, ffname))", "    dobackup = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * Save the value of got_int and reset it.  We don't want a previous"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  prev_got_int = got_int;", "  got_int = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  /* Mark the buffer as 'being saved' to prevent changed buffer warnings */", "  buf->b_saving = true;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * If we are not appending or filtering, the file exists, and the"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    if ((bkc & BKC_YES) || append) {       /* \"yes\" */", "      backup_copy = TRUE;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if ((bkc & BKC_YES) || append) {       /* \"yes\" */", "      backup_copy = TRUE;", "    } else if ((bkc & BKC_AUTO)) {          /* \"auto\" */"], "readability/bool"]
["src/nvim/fileio.c", ["      backup_copy = TRUE;", "    } else if ((bkc & BKC_AUTO)) {          /* \"auto\" */", "      int i;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "      /*", "       * Don't rename the file when:"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          || !os_fileinfo_id_equal(&file_info, &file_info_old)) {", "        backup_copy = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/fileio.c", ["      } else {", "        /*", "         * Check if we can create a file and set the owner/group to"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        for (i = 4913;; i += 123) {", "          sprintf((char *)path_tail(IObuff), \"%d\", i);", "          if (!os_fileinfo_link((char *)IObuff, &file_info)) {"], "runtime/printf"]
["src/nvim/fileio.c", ["        fd = os_open((char *)IObuff,", "            O_CREAT|O_WRONLY|O_EXCL|O_NOFOLLOW, perm);", "        if (fd < 0)             /* can't write in directory */"], "whitespace/alignment"]
["src/nvim/fileio.c", ["            O_CREAT|O_WRONLY|O_EXCL|O_NOFOLLOW, perm);", "        if (fd < 0)             /* can't write in directory */", "          backup_copy = TRUE;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            O_CREAT|O_WRONLY|O_EXCL|O_NOFOLLOW, perm);", "        if (fd < 0)             /* can't write in directory */", "          backup_copy = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["        if (fd < 0)             /* can't write in directory */", "          backup_copy = TRUE;", "        else {"], "readability/bool"]
["src/nvim/fileio.c", ["          backup_copy = TRUE;", "        else {", "# ifdef UNIX"], "readability/braces"]
["src/nvim/fileio.c", ["          backup_copy = TRUE;", "        else {", "# ifdef UNIX"], "readability/braces"]
["src/nvim/fileio.c", ["              || (long)file_info.stat.st_mode != perm) {", "            backup_copy = TRUE;", "          }"], "readability/bool"]
["src/nvim/fileio.c", ["# endif", "          /* Close the file before removing it, on MS-Windows we", "           * can't delete an open file. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * Break symlinks and/or hardlinks if we've been asked to."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "      /* Symlinks. */", "      if ((bkc & BKC_BREAKSYMLINK)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          && !os_fileinfo_id_equal(&file_info, &file_info_old)) {", "        backup_copy = FALSE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["", "      /* Hardlinks. */", "      if ((bkc & BKC_BREAKHARDLINK)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["              || os_fileinfo_id_equal(&file_info, &file_info_old))) {", "        backup_copy = FALSE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["", "    /* make sure we have a valid backup extension to use */", "    if (*p_bex == NUL)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    /* make sure we have a valid backup extension to use */", "    if (*p_bex == NUL)", "      backup_ext = (char_u *)\".bak\";"], "readability/braces"]
["src/nvim/fileio.c", ["      backup_ext = (char_u *)\".bak\";", "    else", "      backup_ext = p_bex;"], "readability/braces"]
["src/nvim/fileio.c", ["", "      /*", "       * Try to make the backup in each directory in the 'bdir' option."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      while (*dirp) {", "        /*", "         * Isolate one directory name, using an entry in 'bdir'."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (rootname == NULL) {", "          some_error = TRUE;                /* out of memory */", "          goto nobackup;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (rootname == NULL) {", "          some_error = TRUE;                /* out of memory */", "          goto nobackup;"], "readability/bool"]
["src/nvim/fileio.c", ["            xfree(rootname);", "            some_error = TRUE;                          /* out of memory */", "            goto nobackup;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            xfree(rootname);", "            some_error = TRUE;                          /* out of memory */", "            goto nobackup;"], "readability/bool"]
["src/nvim/fileio.c", ["", "          /*", "           * Check if backup file already exists."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["                     && os_fileinfo((char *)backup, &file_info_new)) {", "                --*wp;", "              }"], "readability/increment"]
["src/nvim/fileio.c", ["", "        /*", "         * Try to create the backup file"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (backup != NULL) {", "          /* remove old backup, if present */", "          os_remove((char *)backup);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "      /*", "       * Make a backup by renaming the original file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["       */", "      /*", "       * If 'cpoptions' includes the \"W\" flag, we don't want to"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "      /*", "       *"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      while (*dirp) {", "        /*", "         * Isolate one directory name and make the backup file name."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (backup != NULL) {", "          /*", "           * If we are not going to keep the backup file, don't"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            p = backup + STRLEN(backup) - 1 - STRLEN(backup_ext);", "            if (p < backup)             /* empty file name ??? */", "              p = backup;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            p = backup + STRLEN(backup) - 1 - STRLEN(backup_ext);", "            if (p < backup)             /* empty file name ??? */", "              p = backup;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  if (end > buf->b_ml.ml_line_count)", "    end = buf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/fileio.c", ["    end = buf->b_ml.ml_line_count;", "  if (buf->b_ml.ml_flags & ML_EMPTY)", "    start = end + 1;"], "readability/braces"]
["src/nvim/fileio.c", ["    if (write_info.bw_iconv_fd != (iconv_t)-1) {", "      /* We're going to use iconv(), allocate a buffer to convert in. */", "      write_info.bw_conv_buflen = bufsize * ICONV_MULT;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      }", "      write_info.bw_first = TRUE;", "    } else"], "readability/bool"]
["src/nvim/fileio.c", ["      write_info.bw_first = TRUE;", "    } else", "#  endif"], "readability/braces"]
["src/nvim/fileio.c", ["", "    /*", "     * When the file needs to be converted with 'charconvert' after"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    }", "    notconverted = TRUE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["", "  lnum -= start;            /* compute number of written lines */", "  --no_wait_return;         /* may wait for return now */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  lnum -= start;            /* compute number of written lines */", "  --no_wait_return;         /* may wait for return now */", ""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  lnum -= start;            /* compute number of written lines */", "  --no_wait_return;         /* may wait for return now */", ""], "readability/increment"]
["src/nvim/fileio.c", ["#if !defined(UNIX)", "  fname = sfname;           /* use shortname now, for the messages */", "#endif"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      STRCAT(IObuff, _(\" CONVERSION ERROR\"));", "      c = TRUE;", "      if (write_info.bw_conv_error_lnum != 0)"], "readability/bool"]
["src/nvim/fileio.c", ["      c = TRUE;", "      if (write_info.bw_conv_error_lnum != 0)", "        vim_snprintf_add((char *)IObuff, IOSIZE, _(\" in line %\" PRId64 \";\"),"], "readability/braces"]
["src/nvim/fileio.c", ["        vim_snprintf_add((char *)IObuff, IOSIZE, _(\" in line %\" PRId64 \";\"),", "            (int64_t)write_info.bw_conv_error_lnum);", "    } else if (notconverted) {"], "whitespace/alignment"]
["src/nvim/fileio.c", ["      STRCAT(IObuff, _(\"[NOT converted]\"));", "      c = TRUE;", "    } else if (converted) {"], "readability/bool"]
["src/nvim/fileio.c", ["      STRCAT(IObuff, _(\"[converted]\"));", "      c = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["      STRCAT(IObuff, _(\"[Device]\"));", "      c = TRUE;", "    } else if (newfile) {"], "readability/bool"]
["src/nvim/fileio.c", ["      msg_add_eol();", "      c = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["    }", "    /* may add [unix/dos/mac] */", "    if (msg_add_fileformat(fileformat))"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    /* may add [unix/dos/mac] */", "    if (msg_add_fileformat(fileformat))", "      c = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["    if (msg_add_fileformat(fileformat))", "      c = TRUE;", "    msg_add_lines(c, (long)lnum, nchars);       /* add line/char count */"], "readability/bool"]
["src/nvim/fileio.c", ["      c = TRUE;", "    msg_add_lines(c, (long)lnum, nchars);       /* add line/char count */", "    if (!shortmess(SHM_WRITE)) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (!shortmess(SHM_WRITE)) {", "      if (append)", "        STRCAT(IObuff, shortmess(SHM_WRI) ? _(\" [a]\") : _(\" appended\"));"], "readability/braces"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, shortmess(SHM_WRI) ? _(\" [a]\") : _(\" appended\"));", "      else", "        STRCAT(IObuff, shortmess(SHM_WRI) ? _(\" [w]\") : _(\" written\"));"], "readability/braces"]
["src/nvim/fileio.c", ["", "    set_keep_msg(msg_trunc_attr(IObuff, FALSE, 0), 0);", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /* When written everything correctly: reset 'modified'.  Unless not", "   * writing to the original file and '+' is not in 'cpoptions'. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * If written to the current file, update the timestamp of the swap file"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    ml_timestamp(buf);", "    if (append)", "      buf->b_flags &= ~BF_NEW;"], "readability/braces"]
["src/nvim/fileio.c", ["      buf->b_flags &= ~BF_NEW;", "    else", "      buf->b_flags &= ~BF_WRITE_MASK;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /*", "   * If we kept a backup until now, and we are in patch mode, then we make"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (backup != NULL) {", "      /*", "       * If the original file does not exist yet"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    }", "    /*", "     * If there is no backup file, remember that a (new) file was"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["     */", "    else {", "      int empty_fd;"], "whitespace/newline"]
["src/nvim/fileio.c", ["     */", "    else {", "      int empty_fd;"], "readability/braces"]
["src/nvim/fileio.c", ["", "      if (org == NULL", "          || (empty_fd = os_open(org,"], "readability/braces"]
["src/nvim/fileio.c", ["          || (empty_fd = os_open(org,", "                  O_CREAT | O_EXCL | O_NOFOLLOW,", "                  perm < 0 ? 0666 : (perm & 0777))) < 0)"], "whitespace/alignment"]
["src/nvim/fileio.c", ["                  O_CREAT | O_EXCL | O_NOFOLLOW,", "                  perm < 0 ? 0666 : (perm & 0777))) < 0)", "        EMSG(_(\"E206: patchmode: can't touch empty original file\"));"], "whitespace/alignment"]
["src/nvim/fileio.c", ["          || (empty_fd = os_open(org,", "                  O_CREAT | O_EXCL | O_NOFOLLOW,", "                  perm < 0 ? 0666 : (perm & 0777))) < 0)"], "whitespace/alignment"]
["src/nvim/fileio.c", ["                  O_CREAT | O_EXCL | O_NOFOLLOW,", "                  perm < 0 ? 0666 : (perm & 0777))) < 0)", "        EMSG(_(\"E206: patchmode: can't touch empty original file\"));"], "whitespace/alignment"]
["src/nvim/fileio.c", ["        EMSG(_(\"E206: patchmode: can't touch empty original file\"));", "      else", "        close(empty_fd);"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /*", "   * Remove the backup unless 'backup' option is set"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Finish up.  We get here either after failure or success."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["fail:", "  --no_wait_return;             /* may wait for return now */", "nofail:"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["fail:", "  --no_wait_return;             /* may wait for return now */", "nofail:"], "readability/increment"]
["src/nvim/fileio.c", ["", "  /* Done saving, we accept changed buffer warnings again */", "  buf->b_saving = false;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  xfree(backup);", "  if (buffer != smallbuf)", "    xfree(buffer);"], "readability/braces"]
["src/nvim/fileio.c", ["      MSG_PUTS_ATTR(_(", "              \"don't quit the editor until the file is successfully written!\"),", "          attr | MSG_HIST);"], "whitespace/indent"]
["src/nvim/fileio.c", ["              \"don't quit the editor until the file is successfully written!\"),", "          attr | MSG_HIST);", ""], "whitespace/alignment"]
["src/nvim/fileio.c", ["", "      /* Update the timestamp to avoid an \"overwrite changed file\"", "       * prompt when writing again. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * When writing the whole file and 'undofile' is set, also write the undo"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    sha256_finish(&sha_ctx, hash);", "    u_write_undo(NULL, FALSE, buf, hash);", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["", "    curbuf->b_no_eol_lnum = 0;      /* in case it was set by the previous read */", ""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    curbuf->b_no_eol_lnum = 0;      /* in case it was set by the previous read */", ""], "whitespace/line_length"]
["src/nvim/fileio.c", ["", "    /*", "     * Apply POST autocommands."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    if (append)", "      apply_autocmds_exarg(EVENT_FILEAPPENDPOST, fname, fname,"], "readability/braces"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILEAPPENDPOST, fname, fname,", "          FALSE, curbuf, eap);", "    else if (filtering)"], "whitespace/alignment"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILEAPPENDPOST, fname, fname,", "          FALSE, curbuf, eap);", "    else if (filtering)"], "readability/bool"]
["src/nvim/fileio.c", ["          FALSE, curbuf, eap);", "    else if (filtering)", "      apply_autocmds_exarg(EVENT_FILTERWRITEPOST, NULL, fname,"], "readability/braces"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILTERWRITEPOST, NULL, fname,", "          FALSE, curbuf, eap);", "    else if (reset_changed && whole)"], "whitespace/alignment"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILTERWRITEPOST, NULL, fname,", "          FALSE, curbuf, eap);", "    else if (reset_changed && whole)"], "readability/bool"]
["src/nvim/fileio.c", ["          FALSE, curbuf, eap);", "    else if (reset_changed && whole)", "      apply_autocmds_exarg(EVENT_BUFWRITEPOST, fname, fname,"], "readability/braces"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_BUFWRITEPOST, fname, fname,", "          FALSE, curbuf, eap);", "    else"], "whitespace/alignment"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_BUFWRITEPOST, fname, fname,", "          FALSE, curbuf, eap);", "    else"], "readability/bool"]
["src/nvim/fileio.c", ["          FALSE, curbuf, eap);", "    else", "      apply_autocmds_exarg(EVENT_FILEWRITEPOST, fname, fname,"], "readability/braces"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILEWRITEPOST, fname, fname,", "          FALSE, curbuf, eap);", ""], "whitespace/alignment"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILEWRITEPOST, fname, fname,", "          FALSE, curbuf, eap);", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "    /* restore curwin/curbuf and a few other things */", "    aucmd_restbuf(&aco);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    if (aborting())         /* autocmds may abort script processing */", "      retval = FALSE;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    if (aborting())         /* autocmds may abort script processing */", "      retval = FALSE;"], "readability/braces"]
["src/nvim/fileio.c", ["    if (aborting())         /* autocmds may abort script processing */", "      retval = FALSE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["#undef SET_ERRMSG_NUM", "}", ""], "readability/fn_size"]
["src/nvim/fileio.c", ["", "/*", " * Set the name of the current buffer.  Use when the buffer doesn't have a"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* It's like the unnamed buffer is deleted.... */", "  if (curbuf->b_p_bl)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  /* It's like the unnamed buffer is deleted.... */", "  if (curbuf->b_p_bl)", "    apply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);"], "readability/braces"]
["src/nvim/fileio.c", ["  if (curbuf->b_p_bl)", "    apply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);", "  apply_autocmds(EVENT_BUFWIPEOUT, NULL, NULL, FALSE, curbuf);"], "readability/bool"]
["src/nvim/fileio.c", ["    apply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);", "  apply_autocmds(EVENT_BUFWIPEOUT, NULL, NULL, FALSE, curbuf);", "  if (aborting())           /* autocmds may abort script processing */"], "readability/bool"]
["src/nvim/fileio.c", ["  apply_autocmds(EVENT_BUFWIPEOUT, NULL, NULL, FALSE, curbuf);", "  if (aborting())           /* autocmds may abort script processing */", "    return FAIL;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  apply_autocmds(EVENT_BUFWIPEOUT, NULL, NULL, FALSE, curbuf);", "  if (aborting())           /* autocmds may abort script processing */", "    return FAIL;"], "readability/braces"]
["src/nvim/fileio.c", ["  if (curbuf != buf) {", "    /* We are in another buffer now, don't do the renaming. */", "    EMSG(_(e_auchangedbuf));"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* ....and a new named one is created */", "  apply_autocmds(EVENT_BUFNEW, NULL, NULL, FALSE, curbuf);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  /* ....and a new named one is created */", "  apply_autocmds(EVENT_BUFNEW, NULL, NULL, FALSE, curbuf);", "  if (curbuf->b_p_bl)"], "readability/bool"]
["src/nvim/fileio.c", ["  apply_autocmds(EVENT_BUFNEW, NULL, NULL, FALSE, curbuf);", "  if (curbuf->b_p_bl)", "    apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, curbuf);"], "readability/braces"]
["src/nvim/fileio.c", ["  if (curbuf->b_p_bl)", "    apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, curbuf);", "  if (aborting())           /* autocmds may abort script processing */"], "readability/bool"]
["src/nvim/fileio.c", ["    apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, curbuf);", "  if (aborting())           /* autocmds may abort script processing */", "    return FAIL;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, curbuf);", "  if (aborting())           /* autocmds may abort script processing */", "    return FAIL;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /* Do filetype detection now if 'filetype' is empty. */", "  if (*curbuf->b_p_ft == NUL) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/*", " * Append line and character count to IObuff."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  if (insert_space)", "    *p++ = ' ';"], "readability/braces"]
["src/nvim/fileio.c", ["  if (shortmess(SHM_LINES)) {", "     sprintf((char *)p, \"%\" PRId64 \"L, %\" PRId64 \"C\",", "             (int64_t)lnum, (int64_t)nchars);"], "runtime/printf"]
["src/nvim/fileio.c", ["  }", "  else {", "    if (lnum == 1)"], "whitespace/newline"]
["src/nvim/fileio.c", ["  }", "  else {", "    if (lnum == 1)"], "readability/braces"]
["src/nvim/fileio.c", ["  else {", "    if (lnum == 1)", "      STRCPY(p, _(\"1 line, \"));"], "readability/braces"]
["src/nvim/fileio.c", ["      STRCPY(p, _(\"1 line, \"));", "    else", "      sprintf((char *)p, _(\"%\" PRId64 \" lines, \"), (int64_t)lnum);"], "readability/braces"]
["src/nvim/fileio.c", ["    else", "      sprintf((char *)p, _(\"%\" PRId64 \" lines, \"), (int64_t)lnum);", "    p += STRLEN(p);"], "runtime/printf"]
["src/nvim/fileio.c", ["    p += STRLEN(p);", "    if (nchars == 1)", "      STRCPY(p, _(\"1 character\"));"], "readability/braces"]
["src/nvim/fileio.c", ["      STRCPY(p, _(\"1 character\"));", "    else {", "      sprintf((char *)p, _(\"%\" PRId64 \" characters\"), (int64_t)nchars);"], "readability/braces"]
["src/nvim/fileio.c", ["      STRCPY(p, _(\"1 character\"));", "    else {", "      sprintf((char *)p, _(\"%\" PRId64 \" characters\"), (int64_t)nchars);"], "readability/braces"]
["src/nvim/fileio.c", ["    else {", "      sprintf((char *)p, _(\"%\" PRId64 \" characters\"), (int64_t)nchars);", "    }"], "runtime/printf"]
["src/nvim/fileio.c", ["", "/*", " * Append message for missing line separator to IObuff."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  STRCAT(IObuff,", "      shortmess(SHM_LAST) ? _(\"[noeol]\") : _(\"[Incomplete last line]\"));", "}"], "whitespace/alignment"]
["src/nvim/fileio.c", ["", "/*", " * Check modification time of file, before writing to it."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#if defined(__linux__) || defined(MSWIN)", "  /* On a FAT filesystem, esp. under Linux, there are only 5 bits to store", "   * the seconds.  Since the roundoff is done when flushing the inode, the"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/*", " * Call write() to write a number of bytes to the file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  int wlen;", "  char_u      *buf = ip->bw_buf;        /* data to write */", "  int len = ip->bw_len;                 /* length of data */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  char_u      *buf = ip->bw_buf;        /* data to write */", "  int len = ip->bw_len;                 /* length of data */", "#ifdef HAS_BW_FLAGS"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#ifdef HAS_BW_FLAGS", "  int flags = ip->bw_flags;             /* extra flags */", "#endif"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Skip conversion when writing the BOM."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (flags & FIO_UTF8) {", "      /*", "       * Convert latin1 in the buffer to UTF-8 in the file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["       */", "      p = ip->bw_conv_buf;              /* translate to buffer */", "      for (wlen = 0; wlen < len; ++wlen)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      p = ip->bw_conv_buf;              /* translate to buffer */", "      for (wlen = 0; wlen < len; ++wlen)", "        p += utf_char2bytes(buf[wlen], p);"], "readability/braces"]
["src/nvim/fileio.c", ["      p = ip->bw_conv_buf;              /* translate to buffer */", "      for (wlen = 0; wlen < len; ++wlen)", "        p += utf_char2bytes(buf[wlen], p);"], "readability/increment"]
["src/nvim/fileio.c", ["    } else if (flags & (FIO_UCS4 | FIO_UTF16 | FIO_UCS2 | FIO_LATIN1)) {", "      /*", "       * Convert UTF-8 bytes in the buffer to UCS-2, UCS-4, UTF-16 or"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["       */", "      if (flags & FIO_LATIN1)", "        p = buf;                /* translate in-place (can only get shorter) */"], "readability/braces"]
["src/nvim/fileio.c", ["      if (flags & FIO_LATIN1)", "        p = buf;                /* translate in-place (can only get shorter) */", "      else"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        p = buf;                /* translate in-place (can only get shorter) */", "      else", "        p = ip->bw_conv_buf;            /* translate to buffer */"], "readability/braces"]
["src/nvim/fileio.c", ["      else", "        p = ip->bw_conv_buf;            /* translate to buffer */", "      for (wlen = 0; wlen < len; wlen += n) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "          /* Use remainder of previous call.  Append the start of", "           * buf[] to get a full sequence.  Might still be too"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          l = CONV_RESTLEN - ip->bw_restlen;", "          if (l > len)", "            l = len;"], "readability/braces"]
["src/nvim/fileio.c", ["          if (n > ip->bw_restlen + len) {", "            /* We have an incomplete byte sequence at the end to", "             * be written.  We can't convert it without the"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["             * remaining bytes.  Keep them for the next call. */", "            if (ip->bw_restlen + len > CONV_RESTLEN)", "              return FAIL;"], "readability/braces"]
["src/nvim/fileio.c", ["          }", "          if (n > 1)", "            c = utf_ptr2char(ip->bw_rest);"], "readability/braces"]
["src/nvim/fileio.c", ["            c = utf_ptr2char(ip->bw_rest);", "          else", "            c = ip->bw_rest[0];"], "readability/braces"]
["src/nvim/fileio.c", ["            memmove(ip->bw_rest, ip->bw_rest + n,", "                (size_t)ip->bw_restlen);", "            n = 0;"], "whitespace/alignment"]
["src/nvim/fileio.c", ["          if (n > len - wlen) {", "            /* We have an incomplete byte sequence at the end to", "             * be written.  We can't convert it without the"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["             * remaining bytes.  Keep them for the next call. */", "            if (len - wlen > CONV_RESTLEN)", "              return FAIL;"], "readability/braces"]
["src/nvim/fileio.c", ["            memmove(ip->bw_rest, buf + wlen,", "                (size_t)ip->bw_restlen);", "            break;"], "whitespace/alignment"]
["src/nvim/fileio.c", ["          }", "          if (n > 1)", "            c = utf_ptr2char(buf + wlen);"], "readability/braces"]
["src/nvim/fileio.c", ["            c = utf_ptr2char(buf + wlen);", "          else", "            c = buf[wlen];"], "readability/braces"]
["src/nvim/fileio.c", ["        if (ucs2bytes(c, &p, flags) && !ip->bw_conv_error) {", "          ip->bw_conv_error = TRUE;", "          ip->bw_conv_error_lnum = ip->bw_start_lnum;"], "readability/bool"]
["src/nvim/fileio.c", ["        }", "        if (c == NL)", "          ++ip->bw_start_lnum;"], "readability/braces"]
["src/nvim/fileio.c", ["        if (c == NL)", "          ++ip->bw_start_lnum;", "      }"], "readability/increment"]
["src/nvim/fileio.c", ["      }", "      if (flags & FIO_LATIN1)", "        len = (int)(p - buf);"], "readability/braces"]
["src/nvim/fileio.c", ["        len = (int)(p - buf);", "      else {", "        buf = ip->bw_conv_buf;"], "readability/braces"]
["src/nvim/fileio.c", ["        len = (int)(p - buf);", "      else {", "        buf = ip->bw_conv_buf;"], "readability/braces"]
["src/nvim/fileio.c", ["", "      /* Convert with iconv(). */", "      if (ip->bw_restlen > 0) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "        /* Need to concatenate the remainder of the previous call and", "         * the bytes of the current call.  Use the end of the"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "        /* output the initial shift state sequence */", "        (void)iconv(ip->bw_iconv_fd, NULL, NULL, &to, &tolen);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "        /* There is a bug in iconv() on Linux (which appears to be", "         * wide-spread) which sets \"to\" to NULL and messes up \"tolen\"."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        }", "        ip->bw_first = FALSE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["", "      /*", "       * If iconv() has an error or there is not enough room, fail."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          || fromlen > CONV_RESTLEN) {", "        ip->bw_conv_error = TRUE;", "        return FAIL;"], "readability/bool"]
["src/nvim/fileio.c", ["", "      /* copy remainder to ip->bw_rest[] to be used for the next call. */", "      if (fromlen > 0)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      /* copy remainder to ip->bw_rest[] to be used for the next call. */", "      if (fromlen > 0)", "        memmove(ip->bw_rest, (void *)from, fromlen);"], "readability/braces"]
["src/nvim/fileio.c", ["      if (flags & FIO_UTF16) {", "        /* Make two words, ten bits of the character in each.  First", "         * word is 0xd800 - 0xdbff, second one 0xdc00 - 0xdfff */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    }", "  } else { /* Latin1 */", "    if (c >= 0x100) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      *p++ = 0xBF;", "    } else", "      *p++ = c;"], "readability/braces"]
["src/nvim/fileio.c", ["  if (*fenc == NUL || STRCMP(p_enc, fenc) == 0) {", "    same_encoding = TRUE;", "    fenc_flags = 0;"], "readability/bool"]
["src/nvim/fileio.c", ["  } else {", "    /* Ignore difference between \"ansi\" and \"latin1\", \"ucs-4\" and", "     * \"ucs-4be\", etc. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* Encodings differ.  However, conversion is not needed when 'enc' is any", "   * Unicode encoding and the file is UTF-8. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (prop & ENC_2BYTE) {", "      if (prop & ENC_ENDIAN_L)", "        return FIO_UCS2 | FIO_ENDIAN_L;"], "readability/braces"]
["src/nvim/fileio.c", ["    if (prop & ENC_4BYTE) {", "      if (prop & ENC_ENDIAN_L)", "        return FIO_UCS4 | FIO_ENDIAN_L;"], "readability/braces"]
["src/nvim/fileio.c", ["    if (prop & ENC_2WORD) {", "      if (prop & ENC_ENDIAN_L)", "        return FIO_UTF16 | FIO_ENDIAN_L;"], "readability/braces"]
["src/nvim/fileio.c", ["  }", "  if (prop & ENC_LATIN1)", "    return FIO_LATIN1;"], "readability/braces"]
["src/nvim/fileio.c", ["    return FIO_LATIN1;", "  /* must be ENC_DBCS, requires iconv() */", "  return 0;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/*", " * Check for a Unicode BOM (Byte Order Mark) at the start of p[size]."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      && (flags == FIO_ALL || flags == FIO_UTF8 || flags == 0)) {", "    name = \"utf-8\";             /* EF BB BF */", "    len = 3;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        && (flags == FIO_ALL || flags == (FIO_UCS4 | FIO_ENDIAN_L))) {", "      name = \"ucs-4le\";         /* FF FE 00 00 */", "      len = 4;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      len = 4;", "    } else if (flags == (FIO_UCS2 | FIO_ENDIAN_L))", "      name = \"ucs-2le\";         /* FF FE */"], "readability/braces"]
["src/nvim/fileio.c", ["    } else if (flags == (FIO_UCS2 | FIO_ENDIAN_L))", "      name = \"ucs-2le\";         /* FF FE */", "    else if (flags == FIO_ALL || flags == (FIO_UTF16 | FIO_ENDIAN_L))"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      name = \"ucs-2le\";         /* FF FE */", "    else if (flags == FIO_ALL || flags == (FIO_UTF16 | FIO_ENDIAN_L))", "      /* utf-16le is preferred, it also works for ucs-2le text */"], "readability/braces"]
["src/nvim/fileio.c", ["    else if (flags == FIO_ALL || flags == (FIO_UTF16 | FIO_ENDIAN_L))", "      /* utf-16le is preferred, it also works for ucs-2le text */", "      name = \"utf-16le\";        /* FF FE */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      /* utf-16le is preferred, it also works for ucs-2le text */", "      name = \"utf-16le\";        /* FF FE */", "  } else if (p[0] == 0xfe && p[1] == 0xff"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["                 FIO_UTF16)) {", "    /* Default to utf-16, it works also for ucs-2 text. */", "    if (flags == FIO_UCS2)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    /* Default to utf-16, it works also for ucs-2 text. */", "    if (flags == FIO_UCS2)", "      name = \"ucs-2\";           /* FE FF */"], "readability/braces"]
["src/nvim/fileio.c", ["    if (flags == FIO_UCS2)", "      name = \"ucs-2\";           /* FE FF */", "    else"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      name = \"ucs-2\";           /* FE FF */", "    else", "      name = \"utf-16\";          /* FE FF */"], "readability/braces"]
["src/nvim/fileio.c", ["    else", "      name = \"utf-16\";          /* FE FF */", "  } else if (size >= 4 && p[0] == 0 && p[1] == 0 && p[2] == 0xfe"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["             && p[3] == 0xff && (flags == FIO_ALL || flags == FIO_UCS4)) {", "    name = \"ucs-4\";             /* 00 00 FE FF */", "    len = 4;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/*", " * Generate a BOM in \"buf[4]\" for encoding \"name\"."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* Can't put a BOM in a non-Unicode file. */", "  if (flags == FIO_LATIN1 || flags == 0)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  /* Can't put a BOM in a non-Unicode file. */", "  if (flags == FIO_LATIN1 || flags == 0)", "    return 0;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  if (flags == FIO_UTF8) {      /* UTF-8 */", "    buf[0] = 0xef;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  status_redraw_all();", "  redraw_tabline = TRUE;", "}"], "readability/bool"]
["src/nvim/fileio.c", ["    fnamelen = strlen(retval);", "    prepend_dot = FALSE;  // nothing to prepend a dot to", "  } else {"], "readability/bool"]
["src/nvim/fileio.c", ["    retval = xmalloc(fnamelen + extlen + 3);", "    strcpy(retval, fname);", "  }"], "runtime/printf"]
["src/nvim/fileio.c", ["  // ext can start with '.' and cannot exceed 3 more characters.", "  strcpy(s, ext);", ""], "runtime/printf"]
["src/nvim/fileio.c", ["#ifdef HAVE_ACL", "  vim_acl_T acl;                /* ACL from original file */", "#endif"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * When the names are identical, there is nothing to do.  When they refer"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * Find a name that doesn't exist and is in the same directory."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["     */", "    if (STRLEN(from) >= MAXPATHL - 5)", "      return -1;"], "readability/braces"]
["src/nvim/fileio.c", ["        if (os_rename(from, tempname) == OK) {", "          if (os_rename(tempname, to) == OK)", "            return 0;"], "readability/braces"]
["src/nvim/fileio.c", ["            return 0;", "          /* Strange, the second step failed.  Try moving the", "           * file back and return failure. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        }", "        /* If it fails for one temp name it will most likely fail", "         * for any temp name, give up. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Delete the \"to\" file, this is required on some systems to make the"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * First try a normal rename, return if it works."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["   */", "  if (os_rename(from, to) == OK)", "    return 0;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /*", "   * Rename() failed, try copying the file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* Create the new file with same permissions as the original. */", "  fd_out = os_open((char *)to,"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  fd_out = os_open((char *)to,", "      O_CREAT|O_EXCL|O_WRONLY|O_NOFOLLOW, (int)perm);", "  if (fd_out < 0) {"], "whitespace/alignment"]
["src/nvim/fileio.c", ["", "  while ((n = read_eintr(fd_in, buffer, BUFSIZE)) > 0)", "    if (write_eintr(fd_out, buffer, n) != n) {"], "readability/braces"]
["src/nvim/fileio.c", ["  close(fd_in);", "  if (close(fd_out) < 0)", "    errmsg = _(\"E209: Error closing \\\"%s\\\"\");"], "readability/braces"]
["src/nvim/fileio.c", ["", "static int already_warned = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  /* Don't check timestamps while system() or another low-level function may", "   * cause us to lose and gain focus. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["   * cause us to lose and gain focus. */", "  if (no_check_timestamps > 0)", "    return FALSE;"], "readability/braces"]
["src/nvim/fileio.c", ["  if (no_check_timestamps > 0)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  /* Avoid doing a check twice.  The OK/Reload dialog can cause a focus", "   * event and we would keep on checking if the file is steadily growing."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (focus && did_check_timestamps) {", "    need_check_timestamps = TRUE;", "    return FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    need_check_timestamps = TRUE;", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["    }", "    --no_wait_return;", "    need_check_timestamps = FALSE;"], "readability/increment"]
["src/nvim/fileio.c", ["    --no_wait_return;", "    need_check_timestamps = FALSE;", "    if (need_wait_return && didit == 2) {"], "readability/bool"]
["src/nvim/fileio.c", ["", "/*", " * Move all the lines from buffer \"frombuf\" to buffer \"tobuf\"."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* Copy the lines in \"frombuf\" to \"tobuf\". */", "  curbuf = tobuf;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* Delete all the lines in \"frombuf\". */", "  if (retval != FAIL) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/*", " * Check if buffer \"buf\" has been changed."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  // recursively: ignore this buffer.", "  if (buf->terminal", "      || buf->b_ffname == NULL"], "readability/braces"]
["src/nvim/fileio.c", ["", "    /* Don't do anything for a directory.  Might contain the file", "     * explorer. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            mesg = _(", "                \"W12: Warning: File \\\"%s\\\" has changed and the buffer was changed in Vim as well\");", "            mesg2 = _(\"See \\\":help W12\\\" for more info.\");"], "whitespace/line_length"]
["src/nvim/fileio.c", ["            mesg = _(", "                \"W16: Warning: Mode of file \\\"%s\\\" has changed since editing started\");", "            mesg2 = _(\"See \\\":help W16\\\" for more info.\");"], "whitespace/line_length"]
["src/nvim/fileio.c", ["            mesg2 = _(\"See \\\":help W16\\\" for more info.\");", "          } else", "            /* Only timestamp changed, store it to avoid a warning"], "readability/braces"]
["src/nvim/fileio.c", ["          } else", "            /* Only timestamp changed, store it to avoid a warning", "             * in check_mtime() later. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    retval = 1;", "    mesg = _(\"W13: Warning: File \\\"%s\\\" has been created after editing started\");", "    buf->b_flags |= BF_NEW_W;"], "whitespace/line_length"]
["src/nvim/fileio.c", ["      }", "      if (do_dialog(VIM_WARNING, (char_u *) _(\"Warning\"), (char_u *) tbuf,", "                    (char_u *) _(\"&OK\\n&Load File\"), 1, NULL, true) == 2) {"], "whitespace/cast"]
["src/nvim/fileio.c", ["      if (do_dialog(VIM_WARNING, (char_u *) _(\"Warning\"), (char_u *) tbuf,", "                    (char_u *) _(\"&OK\\n&Load File\"), 1, NULL, true) == 2) {", "        reload = true;"], "whitespace/cast"]
["src/nvim/fileio.c", ["      }", "      already_warned = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["  if (reload) {", "    /* Reload the buffer. */", "    buf_reload(buf, orig_mode);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "      /* Any existing undo file is unusable, write it now. */", "      curbuf = buf;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      u_compute_hash(hash);", "      u_write_undo(NULL, FALSE, buf, hash);", "      curbuf = save_curbuf;"], "readability/bool"]
["src/nvim/fileio.c", ["", "/*", " * Reload a buffer that is already loaded."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* set curwin/curbuf for \"buf\" and save some things */", "  aucmd_prepbuf(&aco, buf);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (p_ur < 0 || curbuf->b_ml.ml_line_count <= p_ur) {", "    /* Save all the text, so that the reload can be undone.", "     * Sync first so that this is a separate undo-able action. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["     * Sync first so that this is a separate undo-able action. */", "    u_sync(FALSE);", "    saved = u_savecommon(0, curbuf->b_ml.ml_line_count + 1, 0, TRUE);"], "readability/bool"]
["src/nvim/fileio.c", ["    u_sync(FALSE);", "    saved = u_savecommon(0, curbuf->b_ml.ml_line_count + 1, 0, TRUE);", "    flags |= READ_KEEP_UNDO;"], "readability/bool"]
["src/nvim/fileio.c", ["    if (savebuf != NULL && buf == curbuf) {", "      /* Open the memline. */", "      curbuf = savebuf;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      EMSG2(_(\"E462: Could not prepare for reloading \\\"%s\\\"\"),", "          buf->b_fname);", "      saved = FAIL;"], "whitespace/alignment"]
["src/nvim/fileio.c", ["", "  /* Invalidate diff info if necessary. */", "  diff_invalidate(curbuf);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* Restore the topline and cursor position and check it (lines may", "   * have been removed). */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["   * have been removed). */", "  if (old_topline > curbuf->b_ml.ml_line_count)", "    curwin->w_topline = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/fileio.c", ["    curwin->w_topline = curbuf->b_ml.ml_line_count;", "  else", "    curwin->w_topline = old_topline;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /* Update folds unless they are defined manually. */", "  FOR_ALL_TAB_WINDOWS(tp, wp) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* If the mode didn't change and 'readonly' was set, keep the old", "   * value; the user probably used the \":view\" command.  But don't"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["   * reset it, might have had a read error. */", "  if (orig_mode == curbuf->b_orig_mode)", "    curbuf->b_p_ro |= old_ro;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /* Modelines must override settings done by autocommands. */", "  do_modelines(0);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* restore curwin/curbuf and a few other things */", "  aucmd_restbuf(&aco);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  aucmd_restbuf(&aco);", "  /* Careful: autocommands may have made \"buf\" invalid! */", "}"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/*", " * Adjust the line with missing eol, used for the next write."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["{", "  if (curbuf->b_no_eol_lnum != 0)       /* only if there is a missing eol */", "    curbuf->b_no_eol_lnum += offset;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["{", "  if (curbuf->b_no_eol_lnum != 0)       /* only if there is a missing eol */", "    curbuf->b_no_eol_lnum += offset;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  regmatch.rm_ic = p_fic;   /* ignore case if 'fileignorecase' is set */", "  {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  {", "    if (prog != NULL)", "      regmatch.regprog = *prog;"], "readability/braces"]
["src/nvim/fileio.c", ["      regmatch.regprog = *prog;", "    else", "      regmatch.regprog = vim_regcomp(pattern, RE_MAGIC);"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /*", "   * Try for a match with the pattern with:"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  int nested = 0;", "  int add_dollar = TRUE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  if (allow_dirs != NULL)", "    *allow_dirs = FALSE;"], "readability/braces"]
["src/nvim/fileio.c", ["  if (allow_dirs != NULL)", "    *allow_dirs = FALSE;", "  if (pat_end == NULL)"], "readability/bool"]
["src/nvim/fileio.c", ["    *allow_dirs = FALSE;", "  if (pat_end == NULL)", "    pat_end = pat + STRLEN(pat);"], "readability/braces"]
["src/nvim/fileio.c", ["    case '~':", "      size += 2;                /* extra backslash */", "      break;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    case '/':", "      size += 4;                /* could become \"[\\/]\" */", "      break;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  if (pat[0] == '*')", "    while (pat[0] == '*' && pat < pat_end - 1)"], "readability/braces"]
["src/nvim/fileio.c", ["  if (pat[0] == '*')", "    while (pat[0] == '*' && pat < pat_end - 1)", "      pat++;"], "readability/braces"]
["src/nvim/fileio.c", ["      pat++;", "  else", "    reg_pat[i++] = '^';"], "readability/braces"]
["src/nvim/fileio.c", ["      reg_pat[i++] = '*';", "      while (p[1] == '*')               /* \"**\" matches like \"*\" */", "        ++p;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      reg_pat[i++] = '*';", "      while (p[1] == '*')               /* \"**\" matches like \"*\" */", "        ++p;"], "readability/braces"]
["src/nvim/fileio.c", ["      while (p[1] == '*')               /* \"**\" matches like \"*\" */", "        ++p;", "      break;"], "readability/increment"]
["src/nvim/fileio.c", ["    case '\\\\':", "      if (p[1] == NUL)", "        break;"], "readability/braces"]
["src/nvim/fileio.c", ["      if (!no_bslash) {", "        /* translate:", "         * \"\\x\" to \"\\\\x\"  e.g., \"dir\\file\""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          reg_pat[i++] = ']';", "          if (allow_dirs != NULL)", "            *allow_dirs = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["          if (allow_dirs != NULL)", "            *allow_dirs = TRUE;", "          break;"], "readability/bool"]
["src/nvim/fileio.c", ["#endif", "      /* Undo escaping from ExpandEscape():", "       * foo\\?bar -> foo?bar"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      } else {", "        if (allow_dirs != NULL && vim_ispathsep(*p)", "#ifdef BACKSLASH_IN_FILENAME"], "readability/braces"]
["src/nvim/fileio.c", ["            )", "          *allow_dirs = TRUE;", "        reg_pat[i++] = '\\\\';"], "readability/bool"]
["src/nvim/fileio.c", ["      reg_pat[i++] = ']';", "      if (allow_dirs != NULL)", "        *allow_dirs = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["      if (allow_dirs != NULL)", "        *allow_dirs = TRUE;", "      break;"], "readability/bool"]
["src/nvim/fileio.c", ["      reg_pat[i++] = ')';", "      --nested;", "      break;"], "readability/increment"]
["src/nvim/fileio.c", ["        reg_pat[i++] = '|';", "      } else", "        reg_pat[i++] = ',';"], "readability/braces"]
["src/nvim/fileio.c", ["  }", "  if (add_dollar)", "    reg_pat[i++] = '$';"], "readability/braces"]
["src/nvim/fileio.c", ["#if defined(EINTR)", "/*", " * Version of read() that retries when interrupted by EINTR (possibly"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    ret = read(fd, buf, bufsize);", "    if (ret >= 0 || errno != EINTR)", "      break;"], "readability/braces"]
["src/nvim/fileio.c", ["", "/*", " * Version of write() that retries when interrupted by EINTR (possibly"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* Repeat the write() so long it didn't fail, other than being interrupted", "   * by a signal. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (wlen < 0) {", "      if (errno != EINTR)", "        break;"], "readability/braces"]
["src/nvim/fileio.c", ["        break;", "    } else", "      ret += wlen;"], "readability/braces"]
["src/nvim/fold.c", ["", "/*", " * fold.c: code for folding"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* local declarations. {{{1 */", "/* typedef fold_T {{{2 */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* local declarations. {{{1 */", "/* typedef fold_T {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* typedef fold_T {{{2 */", "/*", " * The toplevel folds for each window are stored in the w_folds growarray."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "#define FD_OPEN         0       /* fold is open (nested ones can be closed) */", "#define FD_CLOSED       1       /* fold is closed */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["#define FD_OPEN         0       /* fold is open (nested ones can be closed) */", "#define FD_CLOSED       1       /* fold is closed */", "#define FD_LEVEL        2       /* depends on 'foldlevel' (nested folds too) */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["#define FD_CLOSED       1       /* fold is closed */", "#define FD_LEVEL        2       /* depends on 'foldlevel' (nested folds too) */", ""], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "#define MAX_LEVEL       20      /* maximum fold depth */", ""], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* Define \"fline_T\", passed to get fold level for a line. {{{2 */", "typedef struct {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["typedef struct {", "  win_T       *wp;              /* window */", "  linenr_T lnum;                /* current line number */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  win_T       *wp;              /* window */", "  linenr_T lnum;                /* current line number */", "  linenr_T off;                 /* offset between lnum and real line number */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  linenr_T lnum;                /* current line number */", "  linenr_T off;                 /* offset between lnum and real line number */", "  linenr_T lnum_save;           /* line nr used by foldUpdateIEMSRecurse() */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  linenr_T off;                 /* offset between lnum and real line number */", "  linenr_T lnum_save;           /* line nr used by foldUpdateIEMSRecurse() */", "  int lvl;                      /* current level (-1 for undefined) */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  linenr_T lnum_save;           /* line nr used by foldUpdateIEMSRecurse() */", "  int lvl;                      /* current level (-1 for undefined) */", "  int lvl_next;                 /* level used for next line */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  int lvl;                      /* current level (-1 for undefined) */", "  int lvl_next;                 /* level used for next line */", "  int start;                    /* number of folds that are forced to start at"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  int lvl_next;                 /* level used for next line */", "  int start;                    /* number of folds that are forced to start at", "                                   this line. */"], "readability/multiline_comment"]
["src/nvim/fold.c", ["  int lvl_next;                 /* level used for next line */", "  int start;                    /* number of folds that are forced to start at", "                                   this line. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["                                   this line. */", "  int end;                      /* level of fold that is forced to end below", "                                   this line */"], "readability/multiline_comment"]
["src/nvim/fold.c", ["                                   this line. */", "  int end;                      /* level of fold that is forced to end below", "                                   this line */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["                                   this line */", "  int had_end;                  /* level of fold that is forced to end above", "                                   this line (copy of \"end\" of prev. line) */"], "readability/multiline_comment"]
["src/nvim/fold.c", ["                                   this line */", "  int had_end;                  /* level of fold that is forced to end above", "                                   this line (copy of \"end\" of prev. line) */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  int had_end;                  /* level of fold that is forced to end above", "                                   this line (copy of \"end\" of prev. line) */", "} fline_T;"], "whitespace/parens"]
["src/nvim/fold.c", ["", "/* Function used by foldUpdateIEMSRecurse */", "typedef void (*LevelGetter)(fline_T *);"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* static functions {{{2 */", ""], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/*", " * While updating the folds lines between invalid_top and invalid_bot have an"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/*", " * When using 'foldexpr' we sometimes get the level of the next line, which"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* Flags used for \"done\" argument of setManualFold. */", "#define DONE_NOTHING    0"], "readability/old_style_comment"]
["src/nvim/fold.c", ["#define DONE_NOTHING    0", "#define DONE_ACTION     1       /* did close or open a fold */", "#define DONE_FOLD       2       /* did find a fold */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["#define DONE_ACTION     1       /* did close or open a fold */", "#define DONE_FOLD       2       /* did find a fold */", ""], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* Exported folding functions. {{{1 */", "/* copyFoldingState() {{{2 */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* Exported folding functions. {{{1 */", "/* copyFoldingState() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* copyFoldingState() {{{2 */", "/*", " * Copy that folding state from window \"wp_from\" to window \"wp_to\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* hasAnyFolding() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* hasAnyFolding() {{{2 */", "/*", " * Return TRUE if there may be folded lines in the current window."], "readability/old_style_comment"]
["src/nvim/fold.c", ["{", "  /* very simple now, but can become more complex later */", "  return !win->w_buffer->terminal && win->w_p_fen"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* hasFolding() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* hasFolding() {{{2 */", "/*", " * Return TRUE if line \"lnum\" in the current window is part of a closed"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  if (!hasAnyFolding(win)) {", "    if (infop != NULL)", "      infop->fi_level = 0;"], "readability/braces"]
["src/nvim/fold.c", ["  if (cache) {", "    /*", "     * First look in cached info for displayed lines.  This is probably"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  if (first == 0) {", "    /*", "     * Recursively search for a fold that contains \"lnum\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["    for (;; ) {", "      if (!foldFind(gap, lnum_rel, &fp))", "        break;"], "readability/braces"]
["src/nvim/fold.c", ["", "      /* Remember lowest level of fold that starts in \"lnum\". */", "      if (lnum_rel == fp->fd_top && low_level == 0)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      /* Remember lowest level of fold that starts in \"lnum\". */", "      if (lnum_rel == fp->fd_top && low_level == 0)", "        low_level = level + 1;"], "readability/braces"]
["src/nvim/fold.c", ["", "      /* is this fold closed? */", "      had_folded = check_closed(win, fp, &use_level, level,"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      had_folded = check_closed(win, fp, &use_level, level,", "          &maybe_small, lnum - lnum_rel);", "      if (had_folded) {"], "whitespace/alignment"]
["src/nvim/fold.c", ["      if (had_folded) {", "        /* Fold closed: Set last and quit loop. */", "        last += fp->fd_len - 1;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "      /* Fold found, but it's open: Check nested folds.  Line number is", "       * relative to containing fold. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      lnum_rel -= fp->fd_top;", "      ++level;", "    }"], "readability/increment"]
["src/nvim/fold.c", ["  }", "  if (lastp != NULL)", "    *lastp = last;"], "readability/braces"]
["src/nvim/fold.c", ["    *lastp = last;", "  if (firstp != NULL)", "    *firstp = first;"], "readability/braces"]
["src/nvim/fold.c", ["", "/* foldLevel() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldLevel() {{{2 */", "/*", " * Return fold level at line number \"lnum\" in the current window."], "readability/old_style_comment"]
["src/nvim/fold.c", ["{", "  /* While updating the folds lines between invalid_top and invalid_bot have", "   * an undefined fold level.  Otherwise update the folds first. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["   * an undefined fold level.  Otherwise update the folds first. */", "  if (invalid_top == (linenr_T)0)", "    checkupdate(curwin);"], "readability/braces"]
["src/nvim/fold.c", ["    checkupdate(curwin);", "  else if (lnum == prev_lnum && prev_lnum_lvl >= 0)", "    return prev_lnum_lvl;"], "readability/braces"]
["src/nvim/fold.c", ["    return prev_lnum_lvl;", "  else if (lnum >= invalid_top && lnum <= invalid_bot)", "    return -1;"], "readability/braces"]
["src/nvim/fold.c", ["", "  /* Return quickly when there is no folding at all in this window. */", "  if (!hasAnyFolding(curwin))"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  /* Return quickly when there is no folding at all in this window. */", "  if (!hasAnyFolding(curwin))", "    return 0;"], "readability/braces"]
["src/nvim/fold.c", ["", "/* foldmethodIsManual() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldmethodIsManual() {{{2 */", "/*", " * Return TRUE if 'foldmethod' is \"manual\""], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldmethodIsIndent() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldmethodIsIndent() {{{2 */", "/*", " * Return TRUE if 'foldmethod' is \"indent\""], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldmethodIsExpr() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldmethodIsExpr() {{{2 */", "/*", " * Return TRUE if 'foldmethod' is \"expr\""], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldmethodIsMarker() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldmethodIsMarker() {{{2 */", "/*", " * Return TRUE if 'foldmethod' is \"marker\""], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldmethodIsSyntax() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldmethodIsSyntax() {{{2 */", "/*", " * Return TRUE if 'foldmethod' is \"syntax\""], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldmethodIsDiff() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldmethodIsDiff() {{{2 */", "/*", " * Return TRUE if 'foldmethod' is \"diff\""], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* closeFoldRecurse() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* closeFoldRecurse() {{{2 */", "/*", " * Close fold for current window at line \"lnum\" recursively."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* opFoldRange() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* opFoldRange() {{{2 */", "/*", " * Open or Close folds for current window in lines \"first\" to \"last\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["    lnum_next = lnum;", "    /* Opening one level only: next fold to open is after the one going to", "     * be opened. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["     * be opened. */", "    if (opening && !recurse)", "      (void)hasFolding(lnum, NULL, &lnum_next);"], "readability/braces"]
["src/nvim/fold.c", ["  }", "  if (done == DONE_NOTHING)", "    EMSG(_(e_nofold));"], "readability/braces"]
["src/nvim/fold.c", ["    EMSG(_(e_nofold));", "  /* Force a redraw to remove the Visual highlighting. */", "  if (had_visual)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  /* Force a redraw to remove the Visual highlighting. */", "  if (had_visual)", "    redraw_curbuf_later(INVERTED);"], "readability/braces"]
["src/nvim/fold.c", ["", "/* openFold() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* openFold() {{{2 */", "/*", " * Open fold for current window at line \"lnum\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* openFoldRecurse() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* openFoldRecurse() {{{2 */", "/*", " * Open fold for current window at line \"lnum\" recursively."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldOpenCursor() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldOpenCursor() {{{2 */", "/*", " * Open folds until the cursor line is not in a closed fold."], "readability/old_style_comment"]
["src/nvim/fold.c", ["  checkupdate(curwin);", "  if (hasAnyFolding(curwin))", "    for (;; ) {"], "readability/braces"]
["src/nvim/fold.c", ["", "/* newFoldLevel() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* newFoldLevel() {{{2 */", "/*", " * Set new foldlevel for current window."], "readability/old_style_comment"]
["src/nvim/fold.c", ["  if (foldmethodIsDiff(curwin) && curwin->w_p_scb) {", "    /*", "     * Set the same foldlevel in other windows in diff mode."], "readability/old_style_comment"]
["src/nvim/fold.c", ["  if (wp->w_fold_manual) {", "    /* Set all flags for the first level of folds to FD_LEVEL.  Following", "     * manual open/close will then change the flags to FD_OPEN or"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    fp = (fold_T *)wp->w_folds.ga_data;", "    for (int i = 0; i < wp->w_folds.ga_len; ++i)", "      fp[i].fd_flags = FD_LEVEL;"], "readability/braces"]
["src/nvim/fold.c", ["    fp = (fold_T *)wp->w_folds.ga_data;", "    for (int i = 0; i < wp->w_folds.ga_len; ++i)", "      fp[i].fd_flags = FD_LEVEL;"], "readability/increment"]
["src/nvim/fold.c", ["", "/* foldCheckClose() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldCheckClose() {{{2 */", "/*", " * Apply 'foldlevel' to all folds that don't contain the cursor."], "readability/old_style_comment"]
["src/nvim/fold.c", ["{", "  if (*p_fcl != NUL) {  /* can only be \"all\" right now */", "    checkupdate(curwin);"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    checkupdate(curwin);", "    if (checkCloseRec(&curwin->w_folds, curwin->w_cursor.lnum,", "            (int)curwin->w_p_fdl))"], "readability/braces"]
["src/nvim/fold.c", ["    if (checkCloseRec(&curwin->w_folds, curwin->w_cursor.lnum,", "            (int)curwin->w_p_fdl))", "      changed_window_setting();"], "whitespace/alignment"]
["src/nvim/fold.c", ["", "/* checkCloseRec() {{{2 */", "static int checkCloseRec(garray_T *gap, linenr_T lnum, int level)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  fold_T      *fp;", "  int retval = FALSE;", ""], "readability/bool"]
["src/nvim/fold.c", ["  fp = (fold_T *)gap->ga_data;", "  for (int i = 0; i < gap->ga_len; ++i) {", "    /* Only manually opened folds may need to be closed. */"], "readability/increment"]
["src/nvim/fold.c", ["  for (int i = 0; i < gap->ga_len; ++i) {", "    /* Only manually opened folds may need to be closed. */", "    if (fp[i].fd_flags == FD_OPEN) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["        fp[i].fd_flags = FD_LEVEL;", "        retval = TRUE;", "      } else"], "readability/bool"]
["src/nvim/fold.c", ["        retval = TRUE;", "      } else", "        retval |= checkCloseRec(&fp[i].fd_nested, lnum - fp[i].fd_top,"], "readability/braces"]
["src/nvim/fold.c", ["        retval |= checkCloseRec(&fp[i].fd_nested, lnum - fp[i].fd_top,", "            level - 1);", "    }"], "whitespace/alignment"]
["src/nvim/fold.c", ["", "/* foldCreateAllowed() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldCreateAllowed() {{{2 */", "/*", " * Return TRUE if it's allowed to manually create or delete a fold."], "readability/old_style_comment"]
["src/nvim/fold.c", ["{", "  if (foldmethodIsManual(curwin) || foldmethodIsMarker(curwin))", "    return TRUE;"], "readability/braces"]
["src/nvim/fold.c", ["  if (foldmethodIsManual(curwin) || foldmethodIsMarker(curwin))", "    return TRUE;", "  if (create)"], "readability/bool"]
["src/nvim/fold.c", ["    return TRUE;", "  if (create)", "    EMSG(_(\"E350: Cannot create fold with current 'foldmethod'\"));"], "readability/braces"]
["src/nvim/fold.c", ["    EMSG(_(\"E350: Cannot create fold with current 'foldmethod'\"));", "  else", "    EMSG(_(\"E351: Cannot delete fold with current 'foldmethod'\"));"], "readability/braces"]
["src/nvim/fold.c", ["    EMSG(_(\"E351: Cannot delete fold with current 'foldmethod'\"));", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/fold.c", ["  int cont;", "  int use_level = FALSE;", "  int closed = FALSE;"], "readability/bool"]
["src/nvim/fold.c", ["  int use_level = FALSE;", "  int closed = FALSE;", "  int level = 0;"], "readability/bool"]
["src/nvim/fold.c", ["      ga_grow(&fold_ga, cont);", "      /* If the first fold starts before the new fold, let the new fold", "       * start there.  Otherwise the existing fold would change. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "      /* Adjust line numbers in contained folds to be relative to the", "       * new fold. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    }", "    /* Move remaining entries to after the new fold. */", "    if (i < gap->ga_len)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    /* Move remaining entries to after the new fold. */", "    if (i < gap->ga_len)", "      memmove(fp + 1, (fold_T *)gap->ga_data + i,"], "readability/braces"]
["src/nvim/fold.c", ["", "    /* insert new fold */", "    fp->fd_nested = fold_ga;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "    /* We want the new fold to be closed.  If it would remain open because", "     * of using 'foldlevel', need to adjust fd_flags of containing folds."], "readability/old_style_comment"]
["src/nvim/fold.c", ["    for (;; ) {", "      if (!foldFind(gap, lnum - lnum_off, &fp))", "        break;"], "readability/braces"]
["src/nvim/fold.c", ["        break;", "      /* lnum is inside this fold, remember info */", "      found_ga = gap;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "      /* check nested folds */", "      gap = &fp->fd_nested;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      lnum_off += fp->fd_top;", "      ++level;", "    }"], "readability/increment"]
["src/nvim/fold.c", ["    if (found_ga == NULL) {", "      ++lnum;", "    } else {"], "readability/increment"]
["src/nvim/fold.c", ["", "/* clearFolding() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* clearFolding() {{{2 */", "/*", " * Remove all folding for window \"win\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldUpdate() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldUpdate() {{{2 */", "/*", " * Update folds for changes in the buffer of a window."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "    /* reset got_int here, otherwise it won't work */", "    got_int = FALSE;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    /* reset got_int here, otherwise it won't work */", "    got_int = FALSE;", "    foldUpdateIEMS(wp, top, bot);"], "readability/bool"]
["src/nvim/fold.c", ["", "/* foldUpdateAll() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldUpdateAll() {{{2 */", "/*", " * Update all lines in a window for folding."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "        /* When moving up, consider a fold above the cursor; when", "         * moving down consider a fold below the cursor. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["        if (dir == FORWARD) {", "          if (fp - (fold_T *)gap->ga_data >= gap->ga_len)", "            break;"], "readability/braces"]
["src/nvim/fold.c", ["            break;", "          --fp;", "        } else {"], "readability/increment"]
["src/nvim/fold.c", ["        } else {", "          if (fp == (fold_T *)gap->ga_data)", "            break;"], "readability/braces"]
["src/nvim/fold.c", ["        }", "        /* don't look for contained folds, they will always move", "         * the cursor too far. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      if (!last) {", "        /* Check if this fold is closed. */", "        if (check_closed(curwin, fp, &use_level, level,"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "        /* \"[z\" and \"]z\" stop at closed fold */", "        if (last && !updown)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["        /* \"[z\" and \"]z\" stop at closed fold */", "        if (last && !updown)", "          break;"], "readability/braces"]
["src/nvim/fold.c", ["        if (dir == FORWARD) {", "          /* to start of next fold if there is one */", "          if (fp + 1 - (fold_T *)gap->ga_data < gap->ga_len) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["            lnum = fp[1].fd_top + lnum_off;", "            if (lnum > curwin->w_cursor.lnum)", "              lnum_found = lnum;"], "readability/braces"]
["src/nvim/fold.c", ["        } else {", "          /* to end of previous fold if there is one */", "          if (fp > (fold_T *)gap->ga_data) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["            lnum = fp[-1].fd_top + lnum_off + fp[-1].fd_len - 1;", "            if (lnum < curwin->w_cursor.lnum)", "              lnum_found = lnum;"], "readability/braces"]
["src/nvim/fold.c", ["      } else {", "        /* Open fold found, set cursor to its start/end and then check", "         * nested folds. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["          lnum = fp->fd_top + lnum_off + fp->fd_len - 1;", "          if (lnum > curwin->w_cursor.lnum)", "            lnum_found = lnum;"], "readability/braces"]
["src/nvim/fold.c", ["          lnum = fp->fd_top + lnum_off;", "          if (lnum < curwin->w_cursor.lnum)", "            lnum_found = lnum;"], "readability/braces"]
["src/nvim/fold.c", ["", "      if (last)", "        break;"], "readability/braces"]
["src/nvim/fold.c", ["", "      /* Check nested folds (if any). */", "      gap = &fp->fd_nested;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      lnum_off += fp->fd_top;", "      ++level;", "    }"], "readability/increment"]
["src/nvim/fold.c", ["    if (lnum_found != curwin->w_cursor.lnum) {", "      if (retval == FAIL)", "        setpcmark();"], "readability/braces"]
["src/nvim/fold.c", ["      retval = OK;", "    } else", "      break;"], "readability/braces"]
["src/nvim/fold.c", ["", "/* foldInitWin() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldInitWin() {{{2 */", "/*", " * Init the fold info in a new window."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* find_wl_entry() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* find_wl_entry() {{{2 */", "/*", " * Find an entry in the win->w_lines[] array for buffer line \"lnum\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  for (i = 0; i < win->w_lines_valid; ++i)", "    if (win->w_lines[i].wl_valid) {"], "readability/braces"]
["src/nvim/fold.c", ["", "  for (i = 0; i < win->w_lines_valid; ++i)", "    if (win->w_lines[i].wl_valid) {"], "readability/increment"]
["src/nvim/fold.c", ["    if (win->w_lines[i].wl_valid) {", "      if (lnum < win->w_lines[i].wl_lnum)", "        return -1;"], "readability/braces"]
["src/nvim/fold.c", ["        return -1;", "      if (lnum <= win->w_lines[i].wl_lastlnum)", "        return i;"], "readability/braces"]
["src/nvim/fold.c", ["", "/* foldAdjustVisual() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldAdjustVisual() {{{2 */", "/*", " * Adjust the Visual area to include any fold at the start or end completely."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  if (!VIsual_active || !hasAnyFolding(curwin))", "    return;"], "readability/braces"]
["src/nvim/fold.c", ["  }", "  if (hasFolding(start->lnum, &start->lnum, NULL))", "    start->col = 0;"], "readability/braces"]
["src/nvim/fold.c", ["", "/* cursor_foldstart() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* cursor_foldstart() {{{2 */", "/*", " * Move the cursor to the first line of a closed fold."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* Internal functions for \"fold_T\" {{{1 */", "/* cloneFoldGrowArray() {{{2 */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* Internal functions for \"fold_T\" {{{1 */", "/* cloneFoldGrowArray() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* cloneFoldGrowArray() {{{2 */", "/*", " * Will \"clone\" (i.e deep copy) a garray_T of folds."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  if (GA_EMPTY(from))", "    return;"], "readability/braces"]
["src/nvim/fold.c", ["    cloneFoldGrowArray(&from_p->fd_nested, &to_p->fd_nested);", "    ++to->ga_len;", "    ++from_p;"], "readability/increment"]
["src/nvim/fold.c", ["    ++to->ga_len;", "    ++from_p;", "    ++to_p;"], "readability/increment"]
["src/nvim/fold.c", ["    ++from_p;", "    ++to_p;", "  }"], "readability/increment"]
["src/nvim/fold.c", ["", "/* foldFind() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldFind() {{{2 */", "/*", " * Search for line \"lnum\" in folds of growarray \"gap\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /*", "   * Perform a binary search."], "readability/old_style_comment"]
["src/nvim/fold.c", ["    linenr_T i = (low + high) / 2;", "    if (fp[i].fd_top > lnum)", "      /* fold below lnum, adjust high */"], "readability/braces"]
["src/nvim/fold.c", ["    if (fp[i].fd_top > lnum)", "      /* fold below lnum, adjust high */", "      high = i - 1;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      high = i - 1;", "    else if (fp[i].fd_top + fp[i].fd_len <= lnum)", "      /* fold above lnum, adjust low */"], "readability/braces"]
["src/nvim/fold.c", ["    else if (fp[i].fd_top + fp[i].fd_len <= lnum)", "      /* fold above lnum, adjust low */", "      low = i + 1;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      low = i + 1;", "    else {", "      /* lnum is inside this fold */"], "readability/braces"]
["src/nvim/fold.c", ["      low = i + 1;", "    else {", "      /* lnum is inside this fold */"], "readability/braces"]
["src/nvim/fold.c", ["    else {", "      /* lnum is inside this fold */", "      *fpp = fp + i;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      *fpp = fp + i;", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/fold.c", ["", "/* foldLevelWin() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldLevelWin() {{{2 */", "/*", " * Return fold level at line number \"lnum\" in window \"wp\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* Recursively search for a fold that contains \"lnum\". */", "  gap = &wp->w_folds;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  for (;; ) {", "    if (!foldFind(gap, lnum_rel, &fp))", "      break;"], "readability/braces"]
["src/nvim/fold.c", ["      break;", "    /* Check nested folds.  Line number is relative to containing fold. */", "    gap = &fp->fd_nested;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    lnum_rel -= fp->fd_top;", "    ++level;", "  }"], "readability/increment"]
["src/nvim/fold.c", ["", "/* checkupdate() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* checkupdate() {{{2 */", "/*", " * Check if the folds in window \"wp\" are invalid and update them if needed."], "readability/old_style_comment"]
["src/nvim/fold.c", ["  if (wp->w_foldinvalid) {", "    foldUpdate(wp, (linenr_T)1, (linenr_T)MAXLNUM);     /* will update all */", "    wp->w_foldinvalid = false;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* setFoldRepeat() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* setFoldRepeat() {{{2 */", "/*", " * Open or close fold for current window at line \"lnum\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  for (n = 0; n < count; ++n) {", "    done = DONE_NOTHING;"], "readability/increment"]
["src/nvim/fold.c", ["    if (!(done & DONE_ACTION)) {", "      /* Only give an error message when no fold could be opened. */", "      if (n == 0 && !(done & DONE_FOLD))"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      /* Only give an error message when no fold could be opened. */", "      if (n == 0 && !(done & DONE_FOLD))", "        EMSG(_(e_nofold));"], "readability/braces"]
["src/nvim/fold.c", ["", "/* setManualFold() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* setManualFold() {{{2 */", "/*", " * Open or close the fold in the current window which contains \"lnum\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "    /*", "     * Do the same operation in other windows in diff mode.  Calculate the"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* setManualFoldWin() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* setManualFoldWin() {{{2 */", "/*", " * Open or close the fold in window \"wp\" which contains \"lnum\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["  int level = 0;", "  int use_level = FALSE;", "  int found_fold = FALSE;"], "readability/bool"]
["src/nvim/fold.c", ["  int use_level = FALSE;", "  int found_fold = FALSE;", "  garray_T    *gap;"], "readability/bool"]
["src/nvim/fold.c", ["", "  /*", "   * Find the fold, open or close it."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "    /* lnum is inside this fold */", "    found_fold = TRUE;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    /* lnum is inside this fold */", "    found_fold = TRUE;", ""], "readability/bool"]
["src/nvim/fold.c", ["", "    /* If there is a following fold, continue there next time. */", "    if (fp + 1 < (fold_T *)gap->ga_data + gap->ga_len)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    /* If there is a following fold, continue there next time. */", "    if (fp + 1 < (fold_T *)gap->ga_data + gap->ga_len)", "      next = fp[1].fd_top + off;"], "readability/braces"]
["src/nvim/fold.c", ["", "    /* Change from level-dependent folding to manual. */", "    if (use_level || fp->fd_flags == FD_LEVEL) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    if (use_level || fp->fd_flags == FD_LEVEL) {", "      use_level = TRUE;", "      if (level >= wp->w_p_fdl)"], "readability/bool"]
["src/nvim/fold.c", ["      use_level = TRUE;", "      if (level >= wp->w_p_fdl)", "        fp->fd_flags = FD_CLOSED;"], "readability/braces"]
["src/nvim/fold.c", ["        fp->fd_flags = FD_CLOSED;", "      else", "        fp->fd_flags = FD_OPEN;"], "readability/braces"]
["src/nvim/fold.c", ["      fp2 = (fold_T *)fp->fd_nested.ga_data;", "      for (j = 0; j < fp->fd_nested.ga_len; ++j)", "        fp2[j].fd_flags = FD_LEVEL;"], "readability/braces"]
["src/nvim/fold.c", ["      fp2 = (fold_T *)fp->fd_nested.ga_data;", "      for (j = 0; j < fp->fd_nested.ga_len; ++j)", "        fp2[j].fd_flags = FD_LEVEL;"], "readability/increment"]
["src/nvim/fold.c", ["", "    /* Simple case: Close recursively means closing the fold. */", "    if (!opening && recurse) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    } else if (fp->fd_flags == FD_CLOSED) {", "      /* When opening, open topmost closed fold. */", "      if (opening) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["        done |= DONE_ACTION;", "        if (recurse)", "          foldOpenNested(fp);"], "readability/braces"]
["src/nvim/fold.c", ["", "    /* fold is open, check nested folds */", "    found = fp;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    off += fp->fd_top;", "    ++level;", "  }"], "readability/increment"]
["src/nvim/fold.c", ["  if (found_fold) {", "    /* When closing and not recurse, close deepest open fold. */", "    if (!opening && found != NULL) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    wp->w_fold_manual = true;", "    if (done & DONE_ACTION)", "      changed_window_setting_win(wp);"], "readability/braces"]
["src/nvim/fold.c", ["    done |= DONE_FOLD;", "  } else if (donep == NULL && wp == curwin)", "    EMSG(_(e_nofold));"], "readability/braces"]
["src/nvim/fold.c", ["", "  if (donep != NULL)", "    *donep |= done;"], "readability/braces"]
["src/nvim/fold.c", ["", "/* foldOpenNested() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldOpenNested() {{{2 */", "/*", " * Open all nested folds in fold \"fpr\" recursively."], "readability/old_style_comment"]
["src/nvim/fold.c", ["  fp = (fold_T *)fpr->fd_nested.ga_data;", "  for (int i = 0; i < fpr->fd_nested.ga_len; ++i) {", "    foldOpenNested(&fp[i]);"], "readability/increment"]
["src/nvim/fold.c", ["  } else {", "    /* Move nested folds one level up, to overwrite the fold that is", "     * deleted. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    {", "      /* Get \"fp\" again, the array may have been reallocated. */", "      fp = (fold_T *)gap->ga_data + idx;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["        nfp[i].fd_top += fp->fd_top;", "        if (fp->fd_flags == FD_LEVEL)", "          nfp[i].fd_flags = FD_LEVEL;"], "readability/braces"]
["src/nvim/fold.c", ["", "/* deleteFoldRecurse() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* deleteFoldRecurse() {{{2 */", "/*", " * Delete nested folds in a fold."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldMarkAdjust() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldMarkAdjust() {{{2 */", "/*", " * Update line numbers of folds for inserted/deleted lines."], "readability/old_style_comment"]
["src/nvim/fold.c", [" */", "void foldMarkAdjust(win_T *wp, linenr_T line1, linenr_T line2, long amount, long amount_after)", "{"], "whitespace/line_length"]
["src/nvim/fold.c", ["{", "  /* If deleting marks from line1 to line2, but not deleting all those", "   * lines, set line2 so that only deleted lines have their folds removed. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["   * lines, set line2 so that only deleted lines have their folds removed. */", "  if (amount == MAXLNUM && line2 >= line1 && line2 - line1 >= -amount_after)", "    line2 = line1 - amount_after - 1;"], "readability/braces"]
["src/nvim/fold.c", ["    line2 = line1 - amount_after - 1;", "  /* If appending a line in Insert mode, it should be included in the fold", "   * just above the line. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* In Insert mode an inserted line at the top of a fold is considered part", "   * of the fold, otherwise it isn't. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["   * of the fold, otherwise it isn't. */", "  if ((State & INSERT) && amount == (linenr_T)1 && line2 == MAXLNUM)", "    top = line1 + 1;"], "readability/braces"]
["src/nvim/fold.c", ["    top = line1 + 1;", "  else", "    top = line1;"], "readability/braces"]
["src/nvim/fold.c", ["", "  /* Find the fold containing or just below \"line1\". */", "  (void)foldFind(gap, line1, &fp);"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /*", "   * Adjust all folds below \"line1\" that are affected."], "readability/old_style_comment"]
["src/nvim/fold.c", ["   */", "  for (int i = (int)(fp - (fold_T *)gap->ga_data); i < gap->ga_len; ++i, ++fp) {", "    /*"], "readability/increment"]
["src/nvim/fold.c", ["  for (int i = (int)(fp - (fold_T *)gap->ga_data); i < gap->ga_len; ++i, ++fp) {", "    /*", "     * Check for these situations:"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "    last = fp->fd_top + fp->fd_len - 1;     /* last line of fold */", ""], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "    /* 1. fold completely above line1: nothing to do */", "    if (last < line1)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    /* 1. fold completely above line1: nothing to do */", "    if (last < line1)", "      continue;"], "readability/braces"]
["src/nvim/fold.c", ["", "    /* 6. fold below line2: only adjust for amount_after */", "    if (fp->fd_top > line2) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    if (fp->fd_top > line2) {", "      if (amount_after == 0)", "        break;"], "readability/braces"]
["src/nvim/fold.c", ["          if (last <= line2) {", "            /* 2. fold contains line1, line2 is below fold */", "            if (amount == MAXLNUM)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["            /* 2. fold contains line1, line2 is below fold */", "            if (amount == MAXLNUM)", "              fp->fd_len = line1 - fp->fd_top;"], "readability/braces"]
["src/nvim/fold.c", ["              fp->fd_len = line1 - fp->fd_top;", "            else", "              fp->fd_len += amount;"], "readability/braces"]
["src/nvim/fold.c", ["          } else {", "            /* 3. fold contains line1 and line2 */", "            fp->fd_len += amount_after;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["        } else {", "          /* 5. fold is below line1 and contains line2; need to", "           * correct nested folds too */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* getDeepestNesting() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* getDeepestNesting() {{{2 */", "/*", " * Get the lowest 'foldlevel' value that makes the deepest nested fold in the"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  fp = (fold_T *)gap->ga_data;", "  for (int i = 0; i < gap->ga_len; ++i) {", "    level = getDeepestNestingRecurse(&fp[i].fd_nested) + 1;"], "readability/increment"]
["src/nvim/fold.c", ["    level = getDeepestNestingRecurse(&fp[i].fd_nested) + 1;", "    if (level > maxlevel)", "      maxlevel = level;"], "readability/braces"]
["src/nvim/fold.c", ["", "  /* Check if this fold is closed.  If the flag is FD_LEVEL this", "   * fold and all folds it contains depend on 'foldlevel'. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldCreateMarkers() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldCreateMarkers() {{{2 */", "/*", " * Create a fold from line \"start\" to line \"end\" (inclusive) in the current"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* Update both changes here, to avoid all folds after the start are", "   * changed when the start marker is inserted and the end isn't. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldAddMarker() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldAddMarker() {{{2 */", "/*", " * Add \"marker[markerlen]\" in 'commentstring' to line \"lnum\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* deleteFoldMarkers() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* deleteFoldMarkers() {{{2 */", "/*", " * Delete the markers for a fold, causing it to be deleted."], "readability/old_style_comment"]
["src/nvim/fold.c", ["    }", "    /* Found the marker, include a digit if it's there. */", "    size_t len = markerlen;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    size_t len = markerlen;", "    if (ascii_isdigit(p[len]))", "      ++len;"], "readability/braces"]
["src/nvim/fold.c", ["    if (ascii_isdigit(p[len]))", "      ++len;", "    if (*cms != NUL) {"], "readability/increment"]
["src/nvim/fold.c", ["    if (*cms != NUL) {", "      /* Also delete 'commentstring' if it matches. */", "      cms2 = (char_u *)strstr((char *)cms, \"%s\");"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    if (u_save(lnum - 1, lnum + 1) == OK) {", "      /* Make new line: text-before-marker + text-after-marker */", "      newline = xmalloc(STRLEN(line) - len + 1);"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  char_u      *text = NULL;", "  /* an error occurred when evaluating 'fdt' setting */", "  static int got_fdt_error = FALSE;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  /* an error occurred when evaluating 'fdt' setting */", "  static int got_fdt_error = FALSE;", "  int save_did_emsg = did_emsg;"], "readability/bool"]
["src/nvim/fold.c", ["", "  if (last_wp == NULL || last_wp != wp || last_lnum > lnum || last_lnum == 0)", "    /* window changed, try evaluating foldtext setting once again */"], "readability/braces"]
["src/nvim/fold.c", ["  if (last_wp == NULL || last_wp != wp || last_lnum > lnum || last_lnum == 0)", "    /* window changed, try evaluating foldtext setting once again */", "    got_fdt_error = FALSE;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    /* window changed, try evaluating foldtext setting once again */", "    got_fdt_error = FALSE;", ""], "readability/bool"]
["src/nvim/fold.c", ["", "  if (!got_fdt_error)", "    /* a previous error should not abort evaluating 'foldexpr' */"], "readability/braces"]
["src/nvim/fold.c", ["  if (!got_fdt_error)", "    /* a previous error should not abort evaluating 'foldexpr' */", "    did_emsg = FALSE;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    /* a previous error should not abort evaluating 'foldexpr' */", "    did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/fold.c", ["    // Set \"v:foldstart\" and \"v:foldend\".", "    set_vim_var_nr(VV_FOLDSTART, (varnumber_T) lnum);", "    set_vim_var_nr(VV_FOLDEND, (varnumber_T) lnume);"], "whitespace/cast"]
["src/nvim/fold.c", ["    set_vim_var_nr(VV_FOLDSTART, (varnumber_T) lnum);", "    set_vim_var_nr(VV_FOLDEND, (varnumber_T) lnume);", ""], "whitespace/cast"]
["src/nvim/fold.c", ["    set_vim_var_string(VV_FOLDDASHES, dashes, -1);", "    set_vim_var_nr(VV_FOLDLEVEL, (varnumber_T) level);", ""], "whitespace/cast"]
["src/nvim/fold.c", ["", "    /* skip evaluating foldtext on errors */", "    if (!got_fdt_error) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "      if (text == NULL || did_emsg)", "        got_fdt_error = TRUE;"], "readability/braces"]
["src/nvim/fold.c", ["      if (text == NULL || did_emsg)", "        got_fdt_error = TRUE;", ""], "readability/bool"]
["src/nvim/fold.c", ["", "    if (!did_emsg && save_did_emsg)", "      did_emsg = save_did_emsg;"], "readability/braces"]
["src/nvim/fold.c", ["    if (text != NULL) {", "      /* Replace unprintable characters, if there are any.  But", "       * replace a TAB with a space. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["          p += len - 1;", "        } else if (*p == TAB)", "          *p = ' ';"], "readability/braces"]
["src/nvim/fold.c", ["          *p = ' ';", "        else if (ptr2cells(p) > 1)", "          break;"], "readability/braces"]
["src/nvim/fold.c", ["", "/* foldtext_cleanup() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldtext_cleanup() {{{2 */", "/*", " * Remove 'foldmarker' and 'commentstring' from \"str\" (in-place)."], "readability/old_style_comment"]
["src/nvim/fold.c", ["  char_u      *p;", "  int did1 = FALSE;", "  int did2 = FALSE;"], "readability/bool"]
["src/nvim/fold.c", ["  int did1 = FALSE;", "  int did2 = FALSE;", ""], "readability/bool"]
["src/nvim/fold.c", ["", "  /* Ignore leading and trailing white space in 'commentstring'. */", "  char_u *cms_start = skipwhite(curbuf->b_p_cms);"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  size_t cms_slen = STRLEN(cms_start);", "  while (cms_slen > 0 && ascii_iswhite(cms_start[cms_slen - 1]))", "    --cms_slen;"], "readability/braces"]
["src/nvim/fold.c", ["  while (cms_slen > 0 && ascii_iswhite(cms_start[cms_slen - 1]))", "    --cms_slen;", ""], "readability/increment"]
["src/nvim/fold.c", ["", "  /* locate \"%s\" in 'commentstring', use the part before and after it. */", "  char_u *cms_end = (char_u *)strstr((char *)cms_start, \"%s\");"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "    /* exclude white space before \"%s\" */", "    while (cms_slen > 0 && ascii_iswhite(cms_start[cms_slen - 1]))"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    /* exclude white space before \"%s\" */", "    while (cms_slen > 0 && ascii_iswhite(cms_start[cms_slen - 1]))", "      --cms_slen;"], "readability/braces"]
["src/nvim/fold.c", ["    while (cms_slen > 0 && ascii_iswhite(cms_start[cms_slen - 1]))", "      --cms_slen;", ""], "readability/increment"]
["src/nvim/fold.c", ["", "    /* skip \"%s\" and white space after it */", "    s = skipwhite(cms_end + 2);"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    size_t len = 0;", "    if (STRNCMP(s, curwin->w_p_fmr, foldstartmarkerlen) == 0)", "      len = foldstartmarkerlen;"], "readability/braces"]
["src/nvim/fold.c", ["      len = foldstartmarkerlen;", "    else if (STRNCMP(s, foldendmarker, foldendmarkerlen) == 0)", "      len = foldendmarkerlen;"], "readability/braces"]
["src/nvim/fold.c", ["    if (len > 0) {", "      if (ascii_isdigit(s[len]))", "        ++len;"], "readability/braces"]
["src/nvim/fold.c", ["      if (ascii_isdigit(s[len]))", "        ++len;", ""], "readability/increment"]
["src/nvim/fold.c", ["", "      /* May remove 'commentstring' start.  Useful when it's a double", "       * quote and we already removed a double quote. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["       * quote and we already removed a double quote. */", "      for (p = s; p > str && ascii_iswhite(p[-1]); --p)", "        ;"], "readability/braces"]
["src/nvim/fold.c", ["       * quote and we already removed a double quote. */", "      for (p = s; p > str && ascii_iswhite(p[-1]); --p)", "        ;"], "readability/increment"]
["src/nvim/fold.c", ["      for (p = s; p > str && ascii_iswhite(p[-1]); --p)", "        ;", "      if (p >= str + cms_slen"], "whitespace/semicolon"]
["src/nvim/fold.c", ["        len = cms_slen;", "        did1 = TRUE;", "      } else if (!did2 && cms_elen > 0"], "readability/bool"]
["src/nvim/fold.c", ["        len = cms_elen;", "        did2 = TRUE;", "      }"], "readability/bool"]
["src/nvim/fold.c", ["    if (len != 0) {", "      while (ascii_iswhite(s[len]))", "        ++len;"], "readability/braces"]
["src/nvim/fold.c", ["      while (ascii_iswhite(s[len]))", "        ++len;", "      STRMOVE(s, s + len);"], "readability/increment"]
["src/nvim/fold.c", ["", "/* Folding by indent, expr, marker and syntax. {{{1 */", "/* Function declarations. {{{2 */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* Folding by indent, expr, marker and syntax. {{{1 */", "/* Function declarations. {{{2 */", ""], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldUpdateIEMS() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldUpdateIEMS() {{{2 */", "/*", " * Update the folding for window \"wp\", at least from lines \"top\" to \"bot\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* Avoid problems when being called recursively. */", "  if (invalid_top != (linenr_T)0)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  /* Avoid problems when being called recursively. */", "  if (invalid_top != (linenr_T)0)", "    return;"], "readability/braces"]
["src/nvim/fold.c", ["  if (wp->w_foldinvalid) {", "    /* Need to update all folds. */", "    top = 1;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "    /* Mark all folds a maybe-small. */", "    setSmallMaybe(&wp->w_folds);"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* add the context for \"diff\" folding */", "  if (foldmethodIsDiff(wp)) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  if (foldmethodIsDiff(wp)) {", "    if (top > diff_context)", "      top -= diff_context;"], "readability/braces"]
["src/nvim/fold.c", ["      top -= diff_context;", "    else", "      top = 1;"], "readability/braces"]
["src/nvim/fold.c", ["", "    /* Init marker variables to speed up foldlevelMarker(). */", "    parseMarker(wp);"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "    /* Need to get the level of the line above top, it is used if there is", "     * no marker at the top. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "      /* The fold may end just above the top, check for that. */", "      fline.lnum = top - 1;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "      /* If a fold started here, we already had the level, if it stops", "       * here, we need to use lvl_next.  Could also start and end a fold"], "readability/old_style_comment"]
["src/nvim/fold.c", ["       * in the same line. */", "      if (fline.lvl > level)", "        fline.lvl = level - (fline.lvl - fline.lvl_next);"], "readability/braces"]
["src/nvim/fold.c", ["        fline.lvl = level - (fline.lvl - fline.lvl_next);", "      else", "        fline.lvl = fline.lvl_next;"], "readability/braces"]
["src/nvim/fold.c", ["      getlevel = foldlevelExpr;", "      /* start one line back, because a \"<1\" may indicate the end of a", "       * fold in the topline */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["       * fold in the topline */", "      if (top > 1)", "        --fline.lnum;"], "readability/braces"]
["src/nvim/fold.c", ["      if (top > 1)", "        --fline.lnum;", "    } else if (foldmethodIsSyntax(wp))"], "readability/increment"]
["src/nvim/fold.c", ["        --fline.lnum;", "    } else if (foldmethodIsSyntax(wp))", "      getlevel = foldlevelSyntax;"], "readability/braces"]
["src/nvim/fold.c", ["      getlevel = foldlevelSyntax;", "    else if (foldmethodIsDiff(wp))", "      getlevel = foldlevelDiff;"], "readability/braces"]
["src/nvim/fold.c", ["      getlevel = foldlevelDiff;", "    else", "      getlevel = foldlevelIndent;"], "readability/braces"]
["src/nvim/fold.c", ["", "    /* Backup to a line for which the fold level is defined.  Since it's", "     * always defined for line one, we will stop there. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    fline.lvl = -1;", "    for (; !got_int; --fline.lnum) {", "      /* Reset lvl_next each time, because it will be set to a value for"], "readability/increment"]
["src/nvim/fold.c", ["    for (; !got_int; --fline.lnum) {", "      /* Reset lvl_next each time, because it will be set to a value for", "       * the next line, but we search backwards here. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      getlevel(&fline);", "      if (fline.lvl >= 0)", "        break;"], "readability/braces"]
["src/nvim/fold.c", ["", "  /*", "   * If folding is defined by the syntax, it is possible that a change in"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    while (current_fdl < fline.lvl) {", "      if (!foldFind(gap, lnum_rel, &fpn))", "        break;"], "readability/braces"]
["src/nvim/fold.c", ["        break;", "      ++current_fdl;", ""], "readability/increment"]
["src/nvim/fold.c", ["", "      if (fold_end_lnum > bot)", "        bot = fold_end_lnum;"], "readability/braces"]
["src/nvim/fold.c", ["  while (!got_int) {", "    /* Always stop at the end of the file (\"end\" can be past the end of", "     * the file). */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["     * the file). */", "    if (fline.lnum > wp->w_buffer->b_ml.ml_line_count)", "      break;"], "readability/braces"]
["src/nvim/fold.c", ["    if (fline.lnum > end) {", "      /* For \"marker\", \"expr\"  and \"syntax\"  methods: If a change caused", "       * a fold to be removed, we need to continue at least until where"], "readability/old_style_comment"]
["src/nvim/fold.c", ["       * it ended. */", "      if (getlevel != foldlevelMarker", "          && getlevel != foldlevelSyntax"], "readability/braces"]
["src/nvim/fold.c", ["        break;", "      if ((start <= end", "           && foldFind(&wp->w_folds, end, &fp)"], "readability/braces"]
["src/nvim/fold.c", ["        end = fp->fd_top + fp->fd_len - 1;", "      else if (getlevel == foldlevelSyntax", "               && foldLevelWin(wp, fline.lnum) != fline.lvl)"], "readability/braces"]
["src/nvim/fold.c", ["               && foldLevelWin(wp, fline.lnum) != fline.lvl)", "        /* For \"syntax\" method: Compare the foldlevel that the syntax", "         * tells us to the foldlevel from the existing folds.  If they"], "readability/old_style_comment"]
["src/nvim/fold.c", ["        end = fline.lnum;", "      else", "        break;"], "readability/braces"]
["src/nvim/fold.c", ["", "    /* A level 1 fold starts at a line with foldlevel > 0. */", "    if (fline.lvl > 0) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    } else {", "      if (fline.lnum == wp->w_buffer->b_ml.ml_line_count)", "        break;"], "readability/braces"]
["src/nvim/fold.c", ["        break;", "      ++fline.lnum;", "      fline.lvl = fline.lvl_next;"], "readability/increment"]
["src/nvim/fold.c", ["", "  /* If some fold changed, need to redraw and position cursor. */", "  if (fold_changed && wp->w_p_fen)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  /* If some fold changed, need to redraw and position cursor. */", "  if (fold_changed && wp->w_p_fen)", "    changed_window_setting_win(wp);"], "readability/braces"]
["src/nvim/fold.c", ["", "  /* If we updated folds past \"bot\", need to redraw more lines.  Don't do", "   * this in other situations, the changed lines will be redrawn anyway and"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  if (end != bot) {", "    if (wp->w_redraw_top == 0 || wp->w_redraw_top > top)", "      wp->w_redraw_top = top;"], "readability/braces"]
["src/nvim/fold.c", ["      wp->w_redraw_top = top;", "    if (wp->w_redraw_bot < end)", "      wp->w_redraw_bot = end;"], "readability/braces"]
["src/nvim/fold.c", ["", "/* foldUpdateIEMSRecurse() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldUpdateIEMSRecurse() {{{2 */", "/*", " * Update a fold that starts at \"flp->lnum\".  At this line there is always a"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /*", "   * If using the marker method, the start line is not the start of a fold"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /*", "   * Loop over all lines in this fold, or until \"bot\" is hit."], "readability/old_style_comment"]
["src/nvim/fold.c", ["  while (!got_int) {", "    /* Updating folds can be slow, check for CTRL-C. */", "    line_breakcheck();"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "    /* Set \"lvl\" to the level of line \"flp->lnum\".  When flp->start is set", "     * and after the first line of the fold, set the level to zero to"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    lvl = flp->lvl;", "    if (lvl > MAX_LEVEL)", "      lvl = MAX_LEVEL;"], "readability/braces"]
["src/nvim/fold.c", ["      lvl = MAX_LEVEL;", "    if (flp->lnum > firstlnum", "        && (level > lvl - flp->start || level >= flp->had_end))"], "readability/braces"]
["src/nvim/fold.c", ["    if (flp->lnum > bot && !finish && fp != NULL) {", "      /* For \"marker\" and \"syntax\" methods:", "       * - If a change caused a nested fold to be removed, we need to"], "readability/old_style_comment"]
["src/nvim/fold.c", ["       */", "      if (getlevel != foldlevelMarker", "          && getlevel != foldlevelExpr"], "readability/braces"]
["src/nvim/fold.c", ["      if (lvl >= level) {", "        /* Compute how deep the folds currently are, if it's deeper", "         * than \"lvl\" then some must be deleted, need to update"], "readability/old_style_comment"]
["src/nvim/fold.c", ["        while (foldFind(&fp2->fd_nested, ll, &fp2)) {", "          ++i;", "          ll -= fp2->fd_top;"], "readability/increment"]
["src/nvim/fold.c", ["", "    /* At the start of the first nested fold and at the end of the current", "     * fold: check if existing folds at this level, before the current"], "readability/old_style_comment"]
["src/nvim/fold.c", ["            || flp->lnum == linecount)) {", "      /*", "       * Remove or update folds that have lines between startlnum and"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      while (!got_int) {", "        /* set concat to 1 if it's allowed to concatenated this fold", "         * with a previous one that touches it. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["         * with a previous one that touches it. */", "        if (flp->start != 0 || flp->had_end <= MAX_LEVEL)", "          concat = 0;"], "readability/braces"]
["src/nvim/fold.c", ["          concat = 0;", "        else", "          concat = 1;"], "readability/braces"]
["src/nvim/fold.c", ["", "        /* Find an existing fold to re-use.  Preferably one that", "         * includes startlnum, otherwise one that ends just before"], "readability/old_style_comment"]
["src/nvim/fold.c", ["          if (fp->fd_top + fp->fd_len + concat > firstlnum) {", "            /* Use existing fold for the new fold.  If it starts", "             * before where we started looking, extend it.  If it"], "readability/old_style_comment"]
["src/nvim/fold.c", ["              fp = (fold_T *)gap->ga_data + i + 1;", "              /* If using the \"marker\" or \"syntax\" method, we", "               * need to continue until the end of the fold is"], "readability/old_style_comment"]
["src/nvim/fold.c", ["          } else {", "            /* A fold has some lines above startlnum, truncate it", "             * to stop just above startlnum.  */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["        } else {", "          /* Insert new fold.  Careful: ga_data may be NULL and it", "           * may change! */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["          fp = (fold_T *)gap->ga_data + i;", "          /* The new fold continues until bot, unless we find the", "           * end earlier. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["          fp->fd_len = bot - firstlnum + 1;", "          /* When the containing fold is open, the new fold is open.", "           * The new fold is closed if the fold above it is closed."], "readability/old_style_comment"]
["src/nvim/fold.c", ["            fp->fd_flags = topflags;", "            if (topflags != FD_LEVEL)", "              flp->wp->w_fold_manual = true;"], "readability/braces"]
["src/nvim/fold.c", ["              flp->wp->w_fold_manual = true;", "          } else", "            fp->fd_flags = (fp - 1)->fd_flags;"], "readability/braces"]
["src/nvim/fold.c", ["    if (lvl < level || flp->lnum > linecount) {", "      /*", "       * Found a line with a lower foldlevel, this fold ends just above"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "    /*", "     * The fold includes the line \"flp->lnum\" and \"flp->lnum_save\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "      /* Line numbers in the nested fold are relative to the start of", "       * this fold. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "      /* This fold may end at the same line, don't incr. flp->lnum. */", "    } else {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    } else {", "      /*", "       * Get the level of the next line, then continue the loop to check"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      while (!got_int) {", "        /* Make the previous level available to foldlevel(). */", "        prev_lnum = flp->lnum;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "        if (++flp->lnum > linecount)", "          break;"], "readability/braces"]
["src/nvim/fold.c", ["        getlevel(flp);", "        if (flp->lvl >= 0 || flp->had_end <= MAX_LEVEL)", "          break;"], "readability/braces"]
["src/nvim/fold.c", ["      prev_lnum = 0;", "      if (flp->lnum > linecount)", "        break;"], "readability/braces"]
["src/nvim/fold.c", ["", "      /* leave flp->lnum_save to lnum of the line that was used to get", "       * the level, flp->lnum to the lnum of the next line. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  if (fp == NULL)       /* only happens when got_int is set */", "    return bot;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  if (fp == NULL)       /* only happens when got_int is set */", "    return bot;"], "readability/braces"]
["src/nvim/fold.c", ["", "  /*", "   * Get here when:"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* delete following folds that end before the current line */", "  for (;; ) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    fp2 = fp + 1;", "    if (fp2 >= (fold_T *)gap->ga_data + gap->ga_len", "        || fp2->fd_top > flp->lnum)"], "readability/braces"]
["src/nvim/fold.c", ["", "  /* Need to redraw the lines we inspected, which might be further down than", "   * was asked for. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["   * was asked for. */", "  if (bot < flp->lnum - 1)", "    bot = flp->lnum - 1;"], "readability/braces"]
["src/nvim/fold.c", ["", "/* foldInsert() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldInsert() {{{2 */", "/*", " * Insert a new fold in \"gap\" at position \"i\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldSplit() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldSplit() {{{2 */", "/*", " * Split the \"i\"th fold in \"gap\", which starts before \"top\" and ends below"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* The fold continues below bot, need to split it. */", "  foldInsert(gap, i + 1);"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* Move nested folds below bot to new fold.  There can't be", "   * any between top and bot, they have been removed by the caller. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldRemove() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldRemove() {{{2 */", "/*", " * Remove folds within the range \"top\" to and including \"bot\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldMerge() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldMerge() {{{2 */", "/*", " * Merge two adjacent folds (and the nested ones in them)."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* If the last nested fold in fp1 touches the first nested fold in fp2,", "   * merge them recursively. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* Move nested folds in fp2 to the end of fp1. */", "  if (!GA_EMPTY(gap2)) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    ga_grow(gap1, gap2->ga_len);", "    for (idx = 0; idx < gap2->ga_len; ++idx) {", "      ((fold_T *)gap1->ga_data)[gap1->ga_len]"], "readability/increment"]
["src/nvim/fold.c", ["      ((fold_T *)gap1->ga_data)[gap1->ga_len].fd_top += fp1->fd_len;", "      ++gap1->ga_len;", "    }"], "readability/increment"]
["src/nvim/fold.c", ["", "/* foldlevelIndent() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldlevelIndent() {{{2 */", "/*", " * Low level function to get the foldlevel for the \"indent\" method."], "readability/old_style_comment"]
["src/nvim/fold.c", ["  buf = flp->wp->w_buffer;", "  s = skipwhite(ml_get_buf(buf, lnum, FALSE));", ""], "readability/bool"]
["src/nvim/fold.c", ["", "  /* empty line or lines starting with a character in 'foldignore': level", "   * depends on surrounding lines */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  if (*s == NUL || vim_strchr(flp->wp->w_p_fdi, *s) != NULL) {", "    /* first and last line can't be undefined, use level 0 */", "    if (lnum == 1 || lnum == buf->b_ml.ml_line_count)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    /* first and last line can't be undefined, use level 0 */", "    if (lnum == 1 || lnum == buf->b_ml.ml_line_count)", "      flp->lvl = 0;"], "readability/braces"]
["src/nvim/fold.c", ["      flp->lvl = 0;", "    else", "      flp->lvl = -1;"], "readability/braces"]
["src/nvim/fold.c", ["  if (flp->lvl > flp->wp->w_p_fdn) {", "    flp->lvl = (int) MAX(0, flp->wp->w_p_fdn);", "  }"], "whitespace/cast"]
["src/nvim/fold.c", ["", "/* foldlevelDiff() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldlevelDiff() {{{2 */", "/*", " * Low level function to get the foldlevel for the \"diff\" method."], "readability/old_style_comment"]
["src/nvim/fold.c", ["{", "  if (diff_infold(flp->wp, flp->lnum + flp->off))", "    flp->lvl = 1;"], "readability/braces"]
["src/nvim/fold.c", ["    flp->lvl = 1;", "  else", "    flp->lvl = 0;"], "readability/braces"]
["src/nvim/fold.c", ["", "/* foldlevelExpr() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldlevelExpr() {{{2 */", "/*", " * Low level function to get the foldlevel for the \"expr\" method."], "readability/old_style_comment"]
["src/nvim/fold.c", ["  curbuf = flp->wp->w_buffer;", "  set_vim_var_nr(VV_LNUM, (varnumber_T) lnum);", ""], "whitespace/cast"]
["src/nvim/fold.c", ["  flp->end = MAX_LEVEL + 1;", "  if (lnum <= 1)", "    flp->lvl = 0;"], "readability/braces"]
["src/nvim/fold.c", ["", "  /* KeyTyped may be reset to 0 when calling a function which invokes", "   * do_cmdline().  To make 'foldopen' work correctly restore KeyTyped. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  switch (c) {", "  /* \"a1\", \"a2\", .. : add to the fold level */", "  case 'a': if (flp->lvl >= 0) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* \"s1\", \"s2\", .. : subtract from the fold level */", "  case 's': if (flp->lvl >= 0) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  case 's': if (flp->lvl >= 0) {", "      if (n > flp->lvl)", "        flp->lvl_next = 0;"], "readability/braces"]
["src/nvim/fold.c", ["        flp->lvl_next = 0;", "      else", "        flp->lvl_next = flp->lvl - n;"], "readability/braces"]
["src/nvim/fold.c", ["", "  /* \">1\", \">2\", .. : start a fold with a certain level */", "  case '>': flp->lvl = n;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* \"<1\", \"<2\", .. : end a fold with a certain level */", "  case '<': flp->lvl_next = n - 1;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* \"=\": No change in level */", "  case '=': flp->lvl_next = flp->lvl;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* \"-1\", \"0\", \"1\", ..: set fold level */", "  default:  if (n < 0)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  default:  if (n < 0)", "      /* Use the current level for the next line, so that \"a1\"", "       * will work there. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      flp->lvl_next = flp->lvl;", "    else", "      flp->lvl_next = n;"], "readability/braces"]
["src/nvim/fold.c", ["", "  /* If the level is unknown for the first or the last line in the file, use", "   * level 0. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    }", "    if (lnum == curbuf->b_ml.ml_line_count)", "      flp->lvl_next = 0;"], "readability/braces"]
["src/nvim/fold.c", ["", "/* parseMarker() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* parseMarker() {{{2 */", "/*", " * Parse 'foldmarker' and set \"foldendmarker\", \"foldstartmarkerlen\" and"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldlevelMarker() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldlevelMarker() {{{2 */", "/*", " * Low level function to get the foldlevel for the \"marker\" method."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* cache a few values for speed */", "  startmarker = flp->wp->w_p_fmr;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  cstart = *startmarker;", "  ++startmarker;", "  cend = *foldendmarker;"], "readability/increment"]
["src/nvim/fold.c", ["", "  /* Default: no start found, next level is same as current level */", "  flp->start = 0;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  s = ml_get_buf(flp->wp->w_buffer, flp->lnum + flp->off, FALSE);", "  while (*s) {"], "readability/bool"]
["src/nvim/fold.c", ["        && STRNCMP(s + 1, startmarker, foldstartmarkerlen - 1) == 0) {", "      /* found startmarker: set flp->lvl */", "      s += foldstartmarkerlen;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["          flp->lvl_next = n;", "          if (n <= start_lvl)", "            flp->start = 1;"], "readability/braces"]
["src/nvim/fold.c", ["            flp->start = 1;", "          else", "            flp->start = n - start_lvl;"], "readability/braces"]
["src/nvim/fold.c", ["      } else {", "        ++flp->lvl;", "        ++flp->lvl_next;"], "readability/increment"]
["src/nvim/fold.c", ["        ++flp->lvl;", "        ++flp->lvl_next;", "        ++flp->start;"], "readability/increment"]
["src/nvim/fold.c", ["        ++flp->lvl_next;", "        ++flp->start;", "      }"], "readability/increment"]
["src/nvim/fold.c", ["                                     foldendmarkerlen - 1) == 0) {", "      /* found endmarker: set flp->lvl_next */", "      s += foldendmarkerlen;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["          flp->lvl_next = n - 1;", "          /* never start a fold with an end marker */", "          if (flp->lvl_next > start_lvl)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["          /* never start a fold with an end marker */", "          if (flp->lvl_next > start_lvl)", "            flp->lvl_next = start_lvl;"], "readability/braces"]
["src/nvim/fold.c", ["", "  /* The level can't go negative, must be missing a start marker. */", "  if (flp->lvl_next < 0)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  /* The level can't go negative, must be missing a start marker. */", "  if (flp->lvl_next < 0)", "    flp->lvl_next = 0;"], "readability/braces"]
["src/nvim/fold.c", ["", "/* foldlevelSyntax() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldlevelSyntax() {{{2 */", "/*", " * Low level function to get the foldlevel for the \"syntax\" method."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* Use the maximum fold level at the start of this line and the next. */", "  flp->lvl = syn_get_foldlevel(flp->wp, lnum);"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    if (n > flp->lvl) {", "      flp->start = n - flp->lvl;        /* fold(s) start here */", "      flp->lvl = n;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* functions for storing the fold state in a View {{{1 */", "/* put_folds() {{{2 */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* functions for storing the fold state in a View {{{1 */", "/* put_folds() {{{2 */", ""], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/*", " * Write commands to \"fd\" to restore the manual folds in window \"wp\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* If some folds are manually opened/closed, need to restore that. */", "  if (wp->w_fold_manual)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  /* If some folds are manually opened/closed, need to restore that. */", "  if (wp->w_fold_manual)", "    return put_foldopen_recurse(fd, wp, &wp->w_folds, (linenr_T)0);"], "readability/braces"]
["src/nvim/fold.c", ["", "/* put_folds_recurse() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* put_folds_recurse() {{{2 */", "/*", " * Write commands to \"fd\" to recreate manually created folds."], "readability/old_style_comment"]
["src/nvim/fold.c", ["  for (int i = 0; i < gap->ga_len; i++) {", "    /* Do nested folds first, they will be created closed. */", "    if (put_folds_recurse(fd, &fp->fd_nested, off + fp->fd_top) == FAIL)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    /* Do nested folds first, they will be created closed. */", "    if (put_folds_recurse(fd, &fp->fd_nested, off + fp->fd_top) == FAIL)", "      return FAIL;"], "readability/braces"]
["src/nvim/fold.c", ["      return FAIL;", "    if (fprintf(fd, \"%\" PRId64 \",%\" PRId64 \"fold\",", "                (int64_t)(fp->fd_top + off),"], "readability/braces"]
["src/nvim/fold.c", ["      return FAIL;", "    ++fp;", "  }"], "readability/increment"]
["src/nvim/fold.c", ["", "/* put_foldopen_recurse() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* put_foldopen_recurse() {{{2 */", "/*", " * Write commands to \"fd\" to open and close manually opened/closed folds."], "readability/old_style_comment"]
["src/nvim/fold.c", [" */", "static int put_foldopen_recurse(FILE *fd, win_T *wp, garray_T *gap, linenr_T off)", "{"], "whitespace/line_length"]
["src/nvim/fold.c", ["      if (!GA_EMPTY(&fp->fd_nested)) {", "        /* open nested folds while this fold is open */", "        if (fprintf(fd, \"%\" PRId64, (int64_t)(fp->fd_top + off)) < 0"], "readability/old_style_comment"]
["src/nvim/fold.c", ["        /* open nested folds while this fold is open */", "        if (fprintf(fd, \"%\" PRId64, (int64_t)(fp->fd_top + off)) < 0", "            || put_eol(fd) == FAIL"], "readability/braces"]
["src/nvim/fold.c", ["          return FAIL;", "        if (put_foldopen_recurse(fd, wp, &fp->fd_nested,", "                off + fp->fd_top)"], "readability/braces"]
["src/nvim/fold.c", ["        if (put_foldopen_recurse(fd, wp, &fp->fd_nested,", "                off + fp->fd_top)", "            == FAIL)"], "whitespace/alignment"]
["src/nvim/fold.c", ["          return FAIL;", "        /* close the parent when needed */", "        if (fp->fd_flags == FD_CLOSED) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["        if (fp->fd_flags == FD_CLOSED) {", "          if (put_fold_open_close(fd, fp, off) == FAIL)", "            return FAIL;"], "readability/braces"]
["src/nvim/fold.c", ["      } else {", "        /* Open or close the leaf according to the window foldlevel.", "         * Do not close a leaf that is already closed, as it will close"], "readability/old_style_comment"]
["src/nvim/fold.c", ["        level = foldLevelWin(wp, off + fp->fd_top);", "        if ((fp->fd_flags == FD_CLOSED && wp->w_p_fdl >= level)", "            || (fp->fd_flags != FD_CLOSED && wp->w_p_fdl < level))"], "readability/braces"]
["src/nvim/fold.c", ["            || (fp->fd_flags != FD_CLOSED && wp->w_p_fdl < level))", "          if (put_fold_open_close(fd, fp, off) == FAIL)", "            return FAIL;"], "readability/braces"]
["src/nvim/fold.c", ["    }", "    ++fp;", "  }"], "readability/increment"]
["src/nvim/fold.c", ["", "/* put_fold_open_close() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* put_fold_open_close() {{{2 */", "/*", " * Write the open or close command to \"fd\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["{", "  if (fprintf(fd, \"%\" PRId64, (int64_t)(fp->fd_top + off)) < 0", "      || put_eol(fd) == FAIL"], "readability/braces"]
["src/nvim/fold.c", ["      || fprintf(fd, \"normal! z%c\",", "          fp->fd_flags == FD_CLOSED ? 'c' : 'o') < 0", "      || put_eol(fd) == FAIL)"], "whitespace/alignment"]
["src/nvim/fold.c", ["      || fprintf(fd, \"normal! z%c\",", "          fp->fd_flags == FD_CLOSED ? 'c' : 'o') < 0", "      || put_eol(fd) == FAIL)"], "whitespace/alignment"]
["src/nvim/fold.c", ["", "/* }}}1 */", ""], "readability/old_style_comment"]
["src/nvim/fold.h", ["", "/*", " * Info used to pass info about a fold from the fold-detection code to the"], "readability/old_style_comment"]
["src/nvim/fold.h", ["typedef struct foldinfo {", "  linenr_T fi_lnum;             /* line number where fold starts */", "  int fi_level;                 /* level of the fold; when this is zero the"], "readability/old_style_comment"]
["src/nvim/fold.h", ["  linenr_T fi_lnum;             /* line number where fold starts */", "  int fi_level;                 /* level of the fold; when this is zero the", "                                   other fields are invalid */"], "readability/multiline_comment"]
["src/nvim/fold.h", ["  linenr_T fi_lnum;             /* line number where fold starts */", "  int fi_level;                 /* level of the fold; when this is zero the", "                                   other fields are invalid */"], "readability/old_style_comment"]
["src/nvim/fold.h", ["  linenr_T fi_lnum;             /* line number where fold starts */", "  int fi_level;                 /* level of the fold; when this is zero the", "                                   other fields are invalid */"], "whitespace/newline"]
["src/nvim/fold.h", ["                                   other fields are invalid */", "  int fi_low_level;             /* lowest fold level that starts in the same", "                                   line */"], "readability/multiline_comment"]
["src/nvim/fold.h", ["                                   other fields are invalid */", "  int fi_low_level;             /* lowest fold level that starts in the same", "                                   line */"], "readability/old_style_comment"]
["src/nvim/func_attr.h", ["// marker so line numbers and indices both start at 1", "// If DEFINE_FUNC_ATTRIBUTES macro is not defined then all function attributes ", "// are defined as empty values."], "whitespace/end_of_line"]
["src/nvim/func_attr.h", ["//", "// If DO_NOT_DEFINE_EMPTY_ATTRIBUTES then empty macros are not defined. Thus ", "// undefined DEFINE_FUNC_ATTRIBUTES and defined DO_NOT_DEFINE_EMPTY_ATTRIBUTES "], "whitespace/end_of_line"]
["src/nvim/func_attr.h", ["// If DO_NOT_DEFINE_EMPTY_ATTRIBUTES then empty macros are not defined. Thus ", "// undefined DEFINE_FUNC_ATTRIBUTES and defined DO_NOT_DEFINE_EMPTY_ATTRIBUTES ", "// leaves file with untouched FUNC_ATTR_* macros. This variant is used for "], "whitespace/end_of_line"]
["src/nvim/func_attr.h", ["// undefined DEFINE_FUNC_ATTRIBUTES and defined DO_NOT_DEFINE_EMPTY_ATTRIBUTES ", "// leaves file with untouched FUNC_ATTR_* macros. This variant is used for ", "// scripts/gendeclarations.lua."], "whitespace/end_of_line"]
["src/nvim/func_attr.h", ["//", "// Empty macros are used for *.c files. (undefined DEFINE_FUNC_ATTRIBUTES and ", "// undefined DO_NOT_DEFINE_EMPTY_ATTRIBUTES)"], "whitespace/end_of_line"]
["src/nvim/func_attr.h", ["//", "// Macros defined as __attribute__((*)) are used by generated header files. ", "// (defined DEFINE_FUNC_ATTRIBUTES and undefined "], "whitespace/end_of_line"]
["src/nvim/func_attr.h", ["// Macros defined as __attribute__((*)) are used by generated header files. ", "// (defined DEFINE_FUNC_ATTRIBUTES and undefined ", "// DO_NOT_DEFINE_EMPTY_ATTRIBUTES)"], "whitespace/end_of_line"]
["src/nvim/func_attr.h", ["//", "// Defined DEFINE_FUNC_ATTRIBUTES and defined DO_NOT_DEFINE_EMPTY_ATTRIBUTES is ", "// not used by anything."], "whitespace/end_of_line"]
["src/nvim/func_attr.h", ["", "// FUNC_ATTR_* macros should be in *.c files for declarations generator. If you ", "// define a function for which declaration is not generated by "], "whitespace/end_of_line"]
["src/nvim/func_attr.h", ["// FUNC_ATTR_* macros should be in *.c files for declarations generator. If you ", "// define a function for which declaration is not generated by ", "// gendeclarations.lua (e.g. template hash implementation) then you should use "], "whitespace/end_of_line"]
["src/nvim/func_attr.h", ["// define a function for which declaration is not generated by ", "// gendeclarations.lua (e.g. template hash implementation) then you should use ", "// REAL_FATTR_* macros."], "whitespace/end_of_line"]
["src/nvim/garray.c", ["", "      --gap->ga_len;", "    }"], "readability/increment"]
["src/nvim/garray.c", ["{", "  const size_t nelem = (size_t) gap->ga_len;", "  const char **strings = gap->ga_data;"], "whitespace/cast"]
["src/nvim/garray.c", ["  if (nelem == 0) {", "    return (char_u *) xstrdup(\"\");", "  }"], "whitespace/cast"]
["src/nvim/garray.c", ["  }", "  strcpy(s, strings[nelem - 1]);", ""], "runtime/printf"]
["src/nvim/garray.c", ["", "  return (char_u *) ret;", "}"], "whitespace/cast"]
["src/nvim/garray.c", ["/// @returns the concatenated strings", "char_u* ga_concat_strings(const garray_T *gap) FUNC_ATTR_NONNULL_RET", "{"], "whitespace/operators"]
["src/nvim/garray.c", ["", "  ga_concat_len(gap, (const char *restrict) s, strlen((char *) s));", "}"], "whitespace/cast"]
["src/nvim/garray.c", ["  if (len) {", "    ga_grow(gap, (int) len);", "    char *data = gap->ga_data;"], "whitespace/cast"]
["src/nvim/garray.c", ["    memcpy(data + gap->ga_len, s, len);", "    gap->ga_len += (int) len;", "  }"], "whitespace/cast"]
["src/nvim/garray.h", ["/// @param gap the garray to be freed", "#define GA_DEEP_CLEAR_PTR(gap) GA_DEEP_CLEAR(gap, void*, FREE_PTR_PTR)", ""], "whitespace/operators"]
["src/nvim/getchar.c", ["", "/*", " * getchar.c"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * These buffers are used for storing:"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * when block_redo is TRUE redo buffer will not be changed"], "readability/old_style_comment"]
["src/nvim/getchar.c", [" */", "static int block_redo = FALSE;", ""], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * List used for abbreviations."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Variables used by vgetorpeek() and flush_buffers()"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/* typebuf.tb_buf has three parts: room in front (for result of mappings), the", " * middle for typeahead and room for new characters (which needs to be 3 *"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Free and clear a buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Return the contents of a buffer as a single string."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Return the contents of the record buffer as a single string"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  p = get_buffcont(&recordbuff, TRUE);", "  free_buff(&recordbuff);"], "readability/bool"]
["src/nvim/getchar.c", ["", "  /*", "   * Remove the characters that were added the last time, these must be the"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * When stopping recording from Insert mode with CTRL-O q, also remove the"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   */", "  if (len > 0 && restart_edit != 0 && p[len - 1] == Ctrl_O)", "    p[len - 1] = NUL;"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Return the contents of the redo buffer as a single string."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["{", "  return get_buffcont(&redobuff, FALSE);", "}"], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * Add number \"n\" to buffer \"buf\"."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Add character 'c' to buffer \"buf\"."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Get one byte from the read buffers.  Use readbuf1 one first, use readbuf2"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  c = read_readbuf(&readbuf1, advance);", "  if (c == NUL)", "    c = read_readbuf(&readbuf2, advance);"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Prepare the read buffers for reading (if they contain something)."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Return TRUE if the stuff buffer is empty."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Return TRUE if readbuf1 is empty.  There may still be redo characters in"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Set a typeahead character that won't be flushed."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Remove the contents of the stuff buffer and the mapped characters in the"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  start_stuff();", "  while (read_readbuffers(TRUE) != NUL) {", "  }"], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * The previous contents of the redo buffer is kept in old_redobuffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Discard the contents of the redo buffer and restore the previous redo"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    start_stuff();", "    while (read_readbuffers(TRUE) != NUL) {", "    }"], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * Append \"s\" to the redo buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Append a character to the redo buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["{", "  if (!block_redo)", "    add_char_buff(&redobuff, c);"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Append a number to the redo buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["{", "  if (!block_redo)", "    add_num_buff(&redobuff, n);"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Append string \"s\" to the stuff buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Stuff \"s\" into the stuff buffer, leaving special key codes unmodified and"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Append a character to the stuff buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Append a number to the stuff buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Repeat the last insert (R, o, O, a, A, i or I command) by stuffing"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["{", "  block_redo = FALSE;", "}"], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * Initialize typebuf.tb_buf to point to typebuf_init."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  init_typebuf();", "  if (++typebuf.tb_change_cnt == 0)", "    typebuf.tb_change_cnt = 1;"], "readability/braces"]
["src/nvim/getchar.c", ["    memmove(s2 + newoff, typebuf.tb_noremap + typebuf.tb_off,", "        (size_t)offset);", "    memmove(s2 + newoff + offset + addlen,"], "whitespace/alignment"]
["src/nvim/getchar.c", ["    memmove(s2 + newoff + offset + addlen,", "        typebuf.tb_noremap + typebuf.tb_off + offset,", "        (size_t)(typebuf.tb_len - offset));"], "whitespace/alignment"]
["src/nvim/getchar.c", ["        typebuf.tb_noremap + typebuf.tb_off + offset,", "        (size_t)(typebuf.tb_len - offset));", "    if (typebuf.tb_noremap != noremapbuf_init)"], "whitespace/alignment"]
["src/nvim/getchar.c", ["        (size_t)(typebuf.tb_len - offset));", "    if (typebuf.tb_noremap != noremapbuf_init)", "      xfree(typebuf.tb_noremap);"], "readability/braces"]
["src/nvim/getchar.c", ["", "  /*", "   * Adjust typebuf.tb_noremap[] for the new characters:"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   */", "  if (noremap == REMAP_SKIP)", "    nrm = 1;"], "readability/braces"]
["src/nvim/getchar.c", ["    nrm = 1;", "  else if (noremap < 0)", "    nrm = addlen;"], "readability/braces"]
["src/nvim/getchar.c", ["    nrm = addlen;", "  else", "    nrm = noremap;"], "readability/braces"]
["src/nvim/getchar.c", ["    nrm = noremap;", "  for (i = 0; i < addlen; ++i)", "    typebuf.tb_noremap[typebuf.tb_off + i + offset] ="], "readability/braces"]
["src/nvim/getchar.c", ["    nrm = noremap;", "  for (i = 0; i < addlen; ++i)", "    typebuf.tb_noremap[typebuf.tb_off + i + offset] ="], "readability/increment"]
["src/nvim/getchar.c", ["", "  /* tb_maplen and tb_silent only remember the length of mapped and/or", "   * silent mappings at the start of the buffer, assuming that a mapped"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   * sequence doesn't result in typed characters. */", "  if (nottyped || typebuf.tb_maplen > offset)", "    typebuf.tb_maplen += addlen;"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Put character \"c\" back into the typeahead buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Return TRUE if the typeahead buffer was changed (while waiting for a"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["                                || typebuf_was_filled", "                                );", "}"], "whitespace/parens"]
["src/nvim/getchar.c", ["", "/*", " * Return TRUE if there are no characters in the typeahead buffer that have"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Return the number of characters that are mapped (or not typed)."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * remove \"len\" characters from typebuf.tb_buf[typebuf.tb_off + offset]"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * Easy case: Just increase typebuf.tb_off."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   */", "  if (offset == 0 && typebuf.tb_buflen - (typebuf.tb_off + len)", "      >= 3 * MAXMAPLEN + 3)"], "readability/braces"]
["src/nvim/getchar.c", ["    typebuf.tb_off += len;", "  /*", "   * Have to move the characters in typebuf.tb_buf[] and typebuf.tb_noremap[]"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   */", "  else {", "    i = typebuf.tb_off + offset;"], "readability/braces"]
["src/nvim/getchar.c", ["   */", "  else {", "    i = typebuf.tb_off + offset;"], "readability/braces"]
["src/nvim/getchar.c", ["    i = typebuf.tb_off + offset;", "    /*", "     * Leave some extra room at the end to avoid reallocation."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      memmove(typebuf.tb_buf + MAXMAPLEN,", "          typebuf.tb_buf + typebuf.tb_off, (size_t)offset);", "      memmove(typebuf.tb_noremap + MAXMAPLEN,"], "whitespace/alignment"]
["src/nvim/getchar.c", ["      memmove(typebuf.tb_noremap + MAXMAPLEN,", "          typebuf.tb_noremap + typebuf.tb_off, (size_t)offset);", "      typebuf.tb_off = MAXMAPLEN;"], "whitespace/alignment"]
["src/nvim/getchar.c", ["    memmove(typebuf.tb_noremap + typebuf.tb_off + offset,", "        typebuf.tb_noremap + i + len,", "        (size_t)(typebuf.tb_len - offset));"], "whitespace/alignment"]
["src/nvim/getchar.c", ["        typebuf.tb_noremap + i + len,", "        (size_t)(typebuf.tb_len - offset));", "  }"], "whitespace/alignment"]
["src/nvim/getchar.c", ["", "  /* Reset the flag that text received from a client or from feedkeys()", "   * was inserted in the typeahead buffer. */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Write typed characters to script file."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /* Since characters have been typed, consider the following to be in", "   * another mapping.  Search string will be kept in history. */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   * another mapping.  Search string will be kept in history. */", "  ++maptick;", "}"], "readability/increment"]
["src/nvim/getchar.c", ["", "/*", " * Sync undo.  Called when typed characters are obtained from the typeahead"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["{", "  if ((!(State & (INSERT + CMDLINE)) || arrow_used)", "      && scriptin[curscript] == NULL)"], "readability/braces"]
["src/nvim/getchar.c", ["      && scriptin[curscript] == NULL)", "    u_sync(FALSE);", "}"], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * Make \"typebuf\" empty and allocate new buffers."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  typebuf.tb_no_abbr_cnt = 0;", "  if (++typebuf.tb_change_cnt == 0)", "    typebuf.tb_change_cnt = 1;"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Free the buffers of \"typebuf\"."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * When doing \":so! file\", the current typeahead needs to be saved, and"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Save all three kinds of typeahead, so that the user must type at a prompt."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Restore the typeahead to what it was before calling save_typeahead()."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Open a new script file for the \":source!\" command."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * Execute the commands from the file right now when using \":source!\""], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Close the currently active input script."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  scriptin[curscript] = NULL;", "  if (curscript > 0)", "    --curscript;"], "readability/braces"]
["src/nvim/getchar.c", ["  if (curscript > 0)", "    --curscript;", "}"], "readability/increment"]
["src/nvim/getchar.c", ["{", "  while (scriptin[0] != NULL)", "    closescript();"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Return TRUE when reading keys from a script file."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Get the next input character."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * If a character was put back with vungetc, it was already processed."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["        c = TO_SPECIAL(c2, c);", "", "      }"], "whitespace/blank_line"]
["src/nvim/getchar.c", ["", "  /*", "   * In the main loop \"may_garbage_collect\" can be set to do garbage"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Like vgetc(), but never return a NUL when called recursively, get a key"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Like safe_vgetc(), but loop to handle K_IGNORE."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Check if a character is available, such that vgetc() will not block."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["{", "  if (old_char != -1)", "    return old_char;"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Check if any character is available, also half an escape sequence."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  c = vpeekc();", "  if (c == NUL && typebuf.tb_len > 0)", "    c = ESC;"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Call vpeekc() without causing anything to be mapped."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * This function doesn't work very well when called recursively.  This may"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   */", "  if (vgetc_busy > 0", "      && ex_normal_busy == 0"], "readability/braces"]
["src/nvim/getchar.c", ["", "  ++vgetc_busy;", ""], "readability/increment"]
["src/nvim/getchar.c", ["", "  if (advance)", "    KeyStuffed = FALSE;"], "readability/braces"]
["src/nvim/getchar.c", ["  if (advance)", "    KeyStuffed = FALSE;", ""], "readability/bool"]
["src/nvim/getchar.c", ["  do {", "    /*", "     * get a character: 1. from the stuffbuffer"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      c = typeahead_char;", "      if (advance)", "        typeahead_char = 0;"], "readability/braces"]
["src/nvim/getchar.c", ["    } else {", "      /*", "       * Loop until we either find a matching mapped key, or we"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      for (;; ) {", "        /*", "         * os_breakcheck() is slow, don't use it too often when"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["          if (advance) {", "            /* Also record this character, it might be needed to", "             * get out of Insert mode. */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["        } else if (typebuf.tb_len > 0) {", "          /*", "           * Check for a mappable key sequence."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["            }", "            /*", "             * Loop until a partly matching mapping is found or"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["                 (mp = mp->m_next)) {", "              /*", "               * Only consider an entry if the first character"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["                  c2 = typebuf.tb_buf[typebuf.tb_off + mlen];", "                  if (nomap > 0)", "                    --nomap;"], "readability/braces"]
["src/nvim/getchar.c", ["                  if (nomap > 0)", "                    --nomap;", "                  else if (c2 == K_SPECIAL)"], "readability/increment"]
["src/nvim/getchar.c", ["                    --nomap;", "                  else if (c2 == K_SPECIAL)", "                    nomap = 2;"], "readability/braces"]
["src/nvim/getchar.c", ["                    nomap = 2;", "                  else", "                    LANGMAP_ADJUST(c2, TRUE);"], "readability/braces"]
["src/nvim/getchar.c", ["                  else", "                    LANGMAP_ADJUST(c2, TRUE);", "                  if (mp->m_keys[mlen] != c2)"], "readability/bool"]
["src/nvim/getchar.c", ["                    LANGMAP_ADJUST(c2, TRUE);", "                  if (mp->m_keys[mlen] != c2)", "                    break;"], "readability/braces"]
["src/nvim/getchar.c", ["", "                /* Don't allow mapping the first byte(s) of a", "                 * multi-byte char.  Happens when mapping"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["                        && typebuf.tb_len < keylen)) {", "                  /*", "                   * If only script-local mappings are"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["                  s = typebuf.tb_noremap + typebuf.tb_off;", "                  if (*s == RM_SCRIPT", "                      && (mp->m_keys[0] != K_SPECIAL"], "readability/braces"]
["src/nvim/getchar.c", ["                    continue;", "                  /*", "                   * If one of the typed keys cannot be"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["                   */", "                  for (n = mlen; --n >= 0; )", "                    if (*s++ & (RM_NONE|RM_ABBR))"], "readability/braces"]
["src/nvim/getchar.c", ["                  for (n = mlen; --n >= 0; )", "                    if (*s++ & (RM_NONE|RM_ABBR))", "                      break;"], "readability/braces"]
["src/nvim/getchar.c", ["                      break;", "                  if (n >= 0)", "                    continue;"], "readability/braces"]
["src/nvim/getchar.c", ["", "            /* If no partly match found, use the longest full", "             * match. */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "            /*", "             * Put the replacement string in front of mapstr."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["              EMSG(_(\"E223: recursive mapping\"));", "              if (State & CMDLINE)", "                redrawcmdline();"], "readability/braces"]
["src/nvim/getchar.c", ["                redrawcmdline();", "              else", "                setcursor();"], "readability/braces"]
["src/nvim/getchar.c", ["", "            /*", "             * In Select mode and a Visual mode mapping is used:"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "            /* Copy the values from *mp that are used, because", "             * evaluating the expression may invoke a function"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "            /*", "             * Handle \":map <expr>\": evaluate the {rhs} as an"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "            /*", "             * Insert the 'to' part in the typebuf.tb_buf."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["             */", "            if (s == NULL)", "              i = FAIL;"], "readability/braces"]
["src/nvim/getchar.c", ["              i = FAIL;", "            else {", "              int noremap;"], "readability/braces"]
["src/nvim/getchar.c", ["              i = FAIL;", "            else {", "              int noremap;"], "readability/braces"]
["src/nvim/getchar.c", ["", "              if (save_m_noremap != REMAP_YES)", "                noremap = save_m_noremap;"], "readability/braces"]
["src/nvim/getchar.c", ["                noremap = save_m_noremap;", "              else if (", "                STRNCMP(s, save_m_keys != NULL"], "readability/braces"]
["src/nvim/getchar.c", ["              else if (", "                STRNCMP(s, save_m_keys != NULL", "                    ? save_m_keys : mp->m_keys,"], "whitespace/indent"]
["src/nvim/getchar.c", ["                STRNCMP(s, save_m_keys != NULL", "                    ? save_m_keys : mp->m_keys,", "                    (size_t)keylen)"], "whitespace/alignment"]
["src/nvim/getchar.c", ["                    ? save_m_keys : mp->m_keys,", "                    (size_t)keylen)", "                != 0)"], "whitespace/alignment"]
["src/nvim/getchar.c", ["                    (size_t)keylen)", "                != 0)", "                noremap = REMAP_YES;"], "whitespace/indent"]
["src/nvim/getchar.c", ["                STRNCMP(s, save_m_keys != NULL", "                    ? save_m_keys : mp->m_keys,", "                    (size_t)keylen)"], "whitespace/alignment"]
["src/nvim/getchar.c", ["                    ? save_m_keys : mp->m_keys,", "                    (size_t)keylen)", "                != 0)"], "whitespace/alignment"]
["src/nvim/getchar.c", ["                noremap = REMAP_YES;", "              else", "                noremap = REMAP_SKIP;"], "readability/braces"]
["src/nvim/getchar.c", ["              i = ins_typebuf(s, noremap,", "                  0, TRUE, cmd_silent || save_m_silent);", "              if (save_m_expr)"], "whitespace/alignment"]
["src/nvim/getchar.c", ["              i = ins_typebuf(s, noremap,", "                  0, TRUE, cmd_silent || save_m_silent);", "              if (save_m_expr)"], "readability/bool"]
["src/nvim/getchar.c", ["                  0, TRUE, cmd_silent || save_m_silent);", "              if (save_m_expr)", "                xfree(s);"], "readability/braces"]
["src/nvim/getchar.c", ["", "        /*", "         * get a character: 3. from the user - handle <Esc> in Insert mode"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["         */", "        /*", "         * special case: if we get an <ESC> in insert mode and there"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["              if (did_ai) {", "                /*", "                 * We are expecting to truncate the trailing"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["              } else {", "                --curwin->w_wcol;", "                col = curwin->w_cursor.col - 1;"], "readability/increment"]
["src/nvim/getchar.c", ["          }", "          /* When 'insertmode' is set, ESC just beeps in Insert", "           * mode.  Use CTRL-L to make edit() return."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["           * cmdline window. */", "          if (p_im && (State & INSERT))", "            c = Ctrl_L;"], "readability/braces"]
["src/nvim/getchar.c", ["            c = Ctrl_L;", "          else if ((State & CMDLINE)", "                   || (cmdwin_type > 0 && tc == ESC)"], "readability/braces"]
["src/nvim/getchar.c", ["            c = Ctrl_C;", "          else", "            c = ESC;"], "readability/braces"]
["src/nvim/getchar.c", ["", "        /*", "         * get a character: 3. from the user - update display"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["         */", "        /* In insert mode a screen update is skipped when characters", "         * are still available.  But when those available characters"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "        /*", "         * If we have a partial match (and are going to wait for more"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["            push_showcmd();", "            if (typebuf.tb_len > SHOWCMD_COLS)", "              i = typebuf.tb_len - SHOWCMD_COLS;"], "readability/braces"]
["src/nvim/getchar.c", ["              i = typebuf.tb_len - SHOWCMD_COLS;", "            while (i < typebuf.tb_len)", "              (void)add_to_showcmd(typebuf.tb_buf[typebuf.tb_off"], "readability/braces"]
["src/nvim/getchar.c", ["", "        /*", "         * get a character: 3. from the user - get it"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "        if (i != 0)", "          pop_showcmd();"], "readability/braces"]
["src/nvim/getchar.c", ["", "  /*", "   * The \"INSERT\" message is taken care of here:"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  --vgetc_busy;", ""], "readability/increment"]
["src/nvim/getchar.c", ["", "/*", " * inchar() - get one character from"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * Don't reset these when at the hit-return prompt, otherwise an endless"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  // Two characters are special: NUL and K_SPECIAL.", "  // Replace\t     NUL by K_SPECIAL KS_ZERO\t KE_FILLER", "  // Replace K_SPECIAL by K_SPECIAL KS_SPECIAL KE_FILLER"], "whitespace/tab"]
["src/nvim/getchar.c", ["", "/*", " * Delete one entry from the abbrlist or maphash[]."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Initialize maphash[] for first use."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    memset(maphash, 0, sizeof(maphash));", "    maphash_valid = TRUE;", "  }"], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * Get the mapping mode from the command name."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Clear all mappings or abbreviations."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  map_clear_int(curbuf, mode,", "      local,", "      abbr);"], "whitespace/alignment"]
["src/nvim/getchar.c", ["      local,", "      abbr);", "}"], "whitespace/alignment"]
["src/nvim/getchar.c", ["", "/*", " * Clear all mappings in \"mode\"."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  for (hash = 0; hash < 256; ++hash) {", "    if (abbr) {"], "readability/increment"]
["src/nvim/getchar.c", ["    } else {", "      if (local)", "        mpp = &buf->b_maphash[hash];"], "readability/braces"]
["src/nvim/getchar.c", ["        mpp = &buf->b_maphash[hash];", "      else", "        mpp = &maphash[hash];"], "readability/braces"]
["src/nvim/getchar.c", ["        }", "        /*", "         * May need to put this entry into another hash list."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  while (++len <= 3)", "    msg_putchar(' ');"], "readability/braces"]
["src/nvim/getchar.c", ["", "  if (local)", "    msg_putchar('@');"], "readability/braces"]
["src/nvim/getchar.c", ["    msg_putchar('@');", "  else", "    msg_putchar(' ');"], "readability/braces"]
["src/nvim/getchar.c", ["", "  /* Use FALSE below if we only want things like <Up> to show up as such on", "   * the rhs, and not M-x etc, TRUE gets both -- webb */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Used below when expanding mapping/abbreviation names."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Work out what to complete when doing command line completion of mapping"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["{", "  if (forceit && cmdidx != CMD_map && cmdidx != CMD_unmap)", "    xp->xp_context = EXPAND_NOTHING;"], "readability/braces"]
["src/nvim/getchar.c", ["    xp->xp_context = EXPAND_NOTHING;", "  else {", "    if (isunmap)"], "readability/braces"]
["src/nvim/getchar.c", ["    xp->xp_context = EXPAND_NOTHING;", "  else {", "    if (isunmap)"], "readability/braces"]
["src/nvim/getchar.c", ["  else {", "    if (isunmap)", "      expand_mapmodes = get_map_mode(&cmd, forceit || isabbrev);"], "readability/braces"]
["src/nvim/getchar.c", ["      expand_mapmodes = get_map_mode(&cmd, forceit || isabbrev);", "    else {", "      expand_mapmodes = INSERT + CMDLINE;"], "readability/braces"]
["src/nvim/getchar.c", ["      expand_mapmodes = get_map_mode(&cmd, forceit || isabbrev);", "    else {", "      expand_mapmodes = INSERT + CMDLINE;"], "readability/braces"]
["src/nvim/getchar.c", ["      expand_mapmodes = INSERT + CMDLINE;", "      if (!isabbrev)", "        expand_mapmodes += VISUAL + SELECTMODE + NORMAL + OP_PENDING;"], "readability/braces"]
["src/nvim/getchar.c", ["", "  /*", "   * round == 1: Count the matches."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   */", "  for (round = 1; round <= 2; ++round) {", "    count = 0;"], "readability/increment"]
["src/nvim/getchar.c", ["      if (vim_regexec(regmatch, p, (colnr_T)0)) {", "        if (round == 1)", "          ++count;"], "readability/braces"]
["src/nvim/getchar.c", ["        if (round == 1)", "          ++count;", "        else"], "readability/increment"]
["src/nvim/getchar.c", ["          ++count;", "        else", "          (*file)[count++] = vim_strsave(p);"], "readability/braces"]
["src/nvim/getchar.c", ["", "    for (hash = 0; hash < 256; ++hash) {", "      if (expand_isabbrev) {"], "readability/increment"]
["src/nvim/getchar.c", ["        mp = first_abbr;", "      } else if (expand_buffer)", "        mp = curbuf->b_maphash[hash];"], "readability/braces"]
["src/nvim/getchar.c", ["        mp = curbuf->b_maphash[hash];", "      else", "        mp = maphash[hash];"], "readability/braces"]
["src/nvim/getchar.c", ["          if (p != NULL && vim_regexec(regmatch, p, (colnr_T)0)) {", "            if (round == 1)", "              ++count;"], "readability/braces"]
["src/nvim/getchar.c", ["            if (round == 1)", "              ++count;", "            else {"], "readability/increment"]
["src/nvim/getchar.c", ["              ++count;", "            else {", "              (*file)[count++] = p;"], "readability/braces"]
["src/nvim/getchar.c", ["              ++count;", "            else {", "              (*file)[count++] = p;"], "readability/braces"]
["src/nvim/getchar.c", ["    while (ptr2 < ptr3) {", "      if (STRCMP(*ptr1, *ptr2))", "        *++ptr1 = *ptr2++;"], "readability/braces"]
["src/nvim/getchar.c", ["        *++ptr1 = *ptr2++;", "      else {", "        xfree(*ptr2++);"], "readability/braces"]
["src/nvim/getchar.c", ["        *++ptr1 = *ptr2++;", "      else {", "        xfree(*ptr2++);"], "readability/braces"]
["src/nvim/getchar.c", ["      }", "      ++clen;", "    }"], "readability/increment"]
["src/nvim/getchar.c", ["", "  if (scol < mincol)", "    scol = mincol;"], "readability/braces"]
["src/nvim/getchar.c", ["    if (mp != NULL) {", "      /*", "       * Found a match:"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      }", "      if (mp->m_expr)", "        s = eval_map_expr(mp->m_str, c);"], "readability/braces"]
["src/nvim/getchar.c", ["        s = eval_map_expr(mp->m_str, c);", "      else", "        s = mp->m_str;"], "readability/braces"]
["src/nvim/getchar.c", ["        typebuf.tb_no_abbr_cnt += (int)STRLEN(s) + j + 1;", "        if (mp->m_expr)", "          xfree(s);"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Evaluate the RHS of a mapping or abbreviations and take care of escaping"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["static char_u *", "eval_map_expr (", "    char_u *str,"], "whitespace/parens"]
["src/nvim/getchar.c", ["", "  /* Remove escaping of CSI, because \"str\" is in a format to be used as", "   * typeahead. */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  save_msg_row = msg_row;", "  p = eval_to_string(expr, NULL, FALSE);", "  --textlock;"], "readability/bool"]
["src/nvim/getchar.c", ["  p = eval_to_string(expr, NULL, FALSE);", "  --textlock;", "  --ex_normal_lock;"], "readability/increment"]
["src/nvim/getchar.c", ["  --textlock;", "  --ex_normal_lock;", "  curwin->w_cursor = save_cursor;"], "readability/increment"]
["src/nvim/getchar.c", ["", "  if (p == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Copy \"p\" to allocated memory, escaping K_SPECIAL and CSI so that the result"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Remove escaping from CSI and K_SPECIAL characters.  Reverse of"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      s += 3;", "    } else", "      *d++ = *s++;"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Write map commands for the current mappings to an .exrc file."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  if (*str == NUL && what == 1) {", "    if (fprintf(fd, \"<Nop>\") < 0)", "      return FAIL;"], "readability/braces"]
["src/nvim/getchar.c", ["    if (p != NULL) {", "      while (*p != NUL)", "        if (fputc(*p++, fd) < 0)"], "readability/braces"]
["src/nvim/getchar.c", ["      while (*p != NUL)", "        if (fputc(*p++, fd) < 0)", "          return FAIL;"], "readability/braces"]
["src/nvim/getchar.c", ["          return FAIL;", "      --str;", "      continue;"], "readability/increment"]
["src/nvim/getchar.c", ["    c = *str;", "    /*", "     * Special key codes have to be translated to be able to make sense"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "    /*", "     * A '\\n' in a map command should be written as <NL>."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      if (what == 2) {", "        if (fprintf(fd, \"\\\\\\026\\n\") < 0)", "          return FAIL;"], "readability/braces"]
["src/nvim/getchar.c", ["      } else {", "        if (fprintf(fd, \"<NL>\") < 0)", "          return FAIL;"], "readability/braces"]
["src/nvim/getchar.c", ["", "    /*", "     * Some characters have to be escaped with CTRL-V to"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    if (what == 2 && (ascii_iswhite(c) || c == '\"' || c == '\\\\')) {", "      if (putc('\\\\', fd) < 0)", "        return FAIL;"], "readability/braces"]
["src/nvim/getchar.c", ["               || (what != 2 && c == '<')) {", "      if (putc(Ctrl_V, fd) < 0)", "        return FAIL;"], "readability/braces"]
["src/nvim/getchar.c", ["    }", "    if (putc(c, fd) < 0)", "      return FAIL;"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Check the string \"keys\" against the lhs of all mappings."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["char_u *", "check_map (", "    char_u *keys,"], "whitespace/parens"]
["src/nvim/getchar.c", ["      for (; mp != NULL; mp = mp->m_next) {", "        /* skip entries with wrong mode, wrong length and not matching", "         * ones */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["          if (STRNCMP(s, keys, minlen) == 0) {", "            if (mp_ptr != NULL)", "              *mp_ptr = mp;"], "readability/braces"]
["src/nvim/getchar.c", ["              *mp_ptr = mp;", "            if (local_ptr != NULL)", "              *local_ptr = local;"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Add a mapping \"map\" for mode \"mode\"."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  s = vim_strsave(map);", "  (void)do_map(0, s, mode, FALSE);", "  xfree(s);"], "readability/bool"]
["src/nvim/getchar.c", ["// Returns NULL when there is a problem.", "static char_u * translate_mapping (", "    char_u *str,"], "whitespace/parens"]
["src/nvim/getchar.c", ["", "  for (; *str; ++str) {", "    int c = *str;"], "readability/increment"]
["src/nvim/getchar.c", ["  for (i = 0; i < typebuf.tb_len && str[i]; i++) {", "    if (str[i] != typebuf.tb_buf[typebuf.tb_off + i])", "      break;"], "readability/braces"]
["src/nvim/globals.h", ["# define MSG_BUF_LEN 480                 // length of buffer for small messages", "# define MSG_BUF_CLEN  (MSG_BUF_LEN / 6) // cell length (worst case: utf-8", "                                         // takes 6 bytes for one cell)"], "whitespace/comments"]
["src/nvim/globals.h", ["# define FOR_ALL_WINDOWS_IN_TAB(wp, tp) \\", "  for (win_T *wp = ((tp) == curtab) \\", "              ? firstwin : (tp)->tp_firstwin; wp != NULL; wp = wp->w_next)"], "readability/braces"]
["src/nvim/globals.h", ["  for (win_T *wp = ((tp) == curtab) \\", "              ? firstwin : (tp)->tp_firstwin; wp != NULL; wp = wp->w_next)", ""], "whitespace/alignment"]
["src/nvim/globals.h", ["// Iterates over all tabs in the tab list", "# define FOR_ALL_TABS(tp) for (tabpage_T *tp = first_tabpage; tp != NULL; tp = tp->tp_next)", ""], "whitespace/line_length"]
["src/nvim/globals.h", ["#define FOR_ALL_BUFFERS(buf) \\", "  for (buf_T *buf = firstbuf; buf != NULL; buf = buf->b_next)", "#define FOR_ALL_BUFFERS_BACKWARDS(buf) \\"], "readability/braces"]
["src/nvim/globals.h", ["#define FOR_ALL_BUFFERS_BACKWARDS(buf) \\", "  for (buf_T *buf = lastbuf; buf != NULL; buf = buf->b_prev)", ""], "readability/braces"]
["src/nvim/globals.h", ["#if MAXPATHL > IOSIZE", "MAXPATHL", "#else"], "whitespace/indent"]
["src/nvim/globals.h", ["#else", "IOSIZE", "#endif"], "whitespace/indent"]
["src/nvim/globals.h", ["EXTERN char_u e_afterinit[] INIT(= N_(", "        \"E905: Cannot set this option after startup\"));", "EXTERN char_u e_api_spawn_failed[] INIT(= N_(\"E903: Could not spawn API job\"));"], "whitespace/indent"]
["src/nvim/globals.h", ["EXTERN char_u e_argreq[] INIT(= N_(\"E471: Argument required\"));", "EXTERN char_u e_backslash[] INIT(= N_(\"E10: \\\\ should be followed by /, ? or &\"));", "EXTERN char_u e_cmdwin[] INIT(= N_("], "whitespace/line_length"]
["src/nvim/globals.h", ["EXTERN char_u e_cmdwin[] INIT(= N_(", "        \"E11: Invalid in command-line window; <CR> executes, CTRL-C quits\"));", "EXTERN char_u e_curdir[] INIT(= N_("], "whitespace/indent"]
["src/nvim/globals.h", ["EXTERN char_u e_curdir[] INIT(= N_(", "        \"E12: Command not allowed from exrc/vimrc in current dir or tag search\"));", "EXTERN char_u e_endif[] INIT(= N_(\"E171: Missing :endif\"));"], "whitespace/indent"]
["src/nvim/globals.h", ["EXTERN char_u e_curdir[] INIT(= N_(", "        \"E12: Command not allowed from exrc/vimrc in current dir or tag search\"));", "EXTERN char_u e_endif[] INIT(= N_(\"E171: Missing :endif\"));"], "whitespace/line_length"]
["src/nvim/globals.h", ["EXTERN char_u e_modifiable[] INIT(= N_(", "        \"E21: Cannot make changes, 'modifiable' is off\"));", "EXTERN char_u e_nesting[] INIT(= N_(\"E22: Scripts nested too deep\"));"], "whitespace/indent"]
["src/nvim/globals.h", ["EXTERN char_u e_nopresub[] INIT(= N_(", "        \"E33: No previous substitute regular expression\"));", "EXTERN char_u e_noprev[] INIT(= N_(\"E34: No previous command\"));"], "whitespace/indent"]
["src/nvim/globals.h", ["EXTERN char_u e_prev_dir[] INIT(= N_(", "        \"E459: Cannot go back to previous directory\"));", ""], "whitespace/indent"]
["src/nvim/globals.h", ["EXTERN char_u e_screenmode[] INIT(= N_(", "        \"E359: Screen mode setting not supported\"));", "EXTERN char_u e_scroll[] INIT(= N_(\"E49: Invalid scroll size\"));"], "whitespace/indent"]
["src/nvim/globals.h", ["EXTERN char_u e_winheight[] INIT(= N_(", "        \"E591: 'winheight' cannot be smaller than 'winminheight'\"));", "EXTERN char_u e_winwidth[] INIT(= N_("], "whitespace/indent"]
["src/nvim/globals.h", ["EXTERN char_u e_winwidth[] INIT(= N_(", "        \"E592: 'winwidth' cannot be smaller than 'winminwidth'\"));", "EXTERN char_u e_write[] INIT(= N_(\"E80: Error while writing\"));"], "whitespace/indent"]
["src/nvim/globals.h", ["EXTERN char_u e_maxmempat[] INIT(= N_(", "        \"E363: pattern uses more memory than 'maxmempattern'\"));", "EXTERN char_u e_emptybuf[] INIT(= N_(\"E749: empty buffer\"));"], "whitespace/indent"]
["src/nvim/globals.h", ["EXTERN char_u e_invalpat[] INIT(= N_(", "        \"E682: Invalid search pattern or delimiter\"));", "EXTERN char_u e_bufloaded[] INIT(= N_(\"E139: File is loaded in another buffer\"));"], "whitespace/indent"]
["src/nvim/globals.h", ["        \"E682: Invalid search pattern or delimiter\"));", "EXTERN char_u e_bufloaded[] INIT(= N_(\"E139: File is loaded in another buffer\"));", "EXTERN char_u e_notset[] INIT(= N_(\"E764: Option '%s' is not set\"));"], "whitespace/line_length"]
["src/nvim/hardcopy.c", ["", "/*", " * hardcopy.c: printing to paper"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * To implement printing on a platform, the following functions must be"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["  =", "  {", "  {\"top\",     TRUE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {", "  {\"top\",     TRUE, 0, NULL, 0, FALSE},", "  {\"bottom\",  TRUE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {", "  {\"top\",     TRUE, 0, NULL, 0, FALSE},", "  {\"bottom\",  TRUE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {", "  {\"top\",     TRUE, 0, NULL, 0, FALSE},", "  {\"bottom\",  TRUE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"top\",     TRUE, 0, NULL, 0, FALSE},", "  {\"bottom\",  TRUE, 0, NULL, 0, FALSE},", "  {\"left\",    TRUE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"top\",     TRUE, 0, NULL, 0, FALSE},", "  {\"bottom\",  TRUE, 0, NULL, 0, FALSE},", "  {\"left\",    TRUE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"top\",     TRUE, 0, NULL, 0, FALSE},", "  {\"bottom\",  TRUE, 0, NULL, 0, FALSE},", "  {\"left\",    TRUE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"bottom\",  TRUE, 0, NULL, 0, FALSE},", "  {\"left\",    TRUE, 0, NULL, 0, FALSE},", "  {\"right\",   TRUE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"bottom\",  TRUE, 0, NULL, 0, FALSE},", "  {\"left\",    TRUE, 0, NULL, 0, FALSE},", "  {\"right\",   TRUE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"bottom\",  TRUE, 0, NULL, 0, FALSE},", "  {\"left\",    TRUE, 0, NULL, 0, FALSE},", "  {\"right\",   TRUE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"left\",    TRUE, 0, NULL, 0, FALSE},", "  {\"right\",   TRUE, 0, NULL, 0, FALSE},", "  {\"header\",  TRUE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"left\",    TRUE, 0, NULL, 0, FALSE},", "  {\"right\",   TRUE, 0, NULL, 0, FALSE},", "  {\"header\",  TRUE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"left\",    TRUE, 0, NULL, 0, FALSE},", "  {\"right\",   TRUE, 0, NULL, 0, FALSE},", "  {\"header\",  TRUE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"right\",   TRUE, 0, NULL, 0, FALSE},", "  {\"header\",  TRUE, 0, NULL, 0, FALSE},", "  {\"syntax\",  FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"right\",   TRUE, 0, NULL, 0, FALSE},", "  {\"header\",  TRUE, 0, NULL, 0, FALSE},", "  {\"syntax\",  FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"right\",   TRUE, 0, NULL, 0, FALSE},", "  {\"header\",  TRUE, 0, NULL, 0, FALSE},", "  {\"syntax\",  FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"header\",  TRUE, 0, NULL, 0, FALSE},", "  {\"syntax\",  FALSE, 0, NULL, 0, FALSE},", "  {\"number\",  FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"header\",  TRUE, 0, NULL, 0, FALSE},", "  {\"syntax\",  FALSE, 0, NULL, 0, FALSE},", "  {\"number\",  FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"header\",  TRUE, 0, NULL, 0, FALSE},", "  {\"syntax\",  FALSE, 0, NULL, 0, FALSE},", "  {\"number\",  FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"syntax\",  FALSE, 0, NULL, 0, FALSE},", "  {\"number\",  FALSE, 0, NULL, 0, FALSE},", "  {\"wrap\",    FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"syntax\",  FALSE, 0, NULL, 0, FALSE},", "  {\"number\",  FALSE, 0, NULL, 0, FALSE},", "  {\"wrap\",    FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"syntax\",  FALSE, 0, NULL, 0, FALSE},", "  {\"number\",  FALSE, 0, NULL, 0, FALSE},", "  {\"wrap\",    FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"number\",  FALSE, 0, NULL, 0, FALSE},", "  {\"wrap\",    FALSE, 0, NULL, 0, FALSE},", "  {\"duplex\",  FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"number\",  FALSE, 0, NULL, 0, FALSE},", "  {\"wrap\",    FALSE, 0, NULL, 0, FALSE},", "  {\"duplex\",  FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"number\",  FALSE, 0, NULL, 0, FALSE},", "  {\"wrap\",    FALSE, 0, NULL, 0, FALSE},", "  {\"duplex\",  FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"wrap\",    FALSE, 0, NULL, 0, FALSE},", "  {\"duplex\",  FALSE, 0, NULL, 0, FALSE},", "  {\"portrait\", FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"wrap\",    FALSE, 0, NULL, 0, FALSE},", "  {\"duplex\",  FALSE, 0, NULL, 0, FALSE},", "  {\"portrait\", FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"wrap\",    FALSE, 0, NULL, 0, FALSE},", "  {\"duplex\",  FALSE, 0, NULL, 0, FALSE},", "  {\"portrait\", FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"duplex\",  FALSE, 0, NULL, 0, FALSE},", "  {\"portrait\", FALSE, 0, NULL, 0, FALSE},", "  {\"paper\",   FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"duplex\",  FALSE, 0, NULL, 0, FALSE},", "  {\"portrait\", FALSE, 0, NULL, 0, FALSE},", "  {\"paper\",   FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"duplex\",  FALSE, 0, NULL, 0, FALSE},", "  {\"portrait\", FALSE, 0, NULL, 0, FALSE},", "  {\"paper\",   FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"portrait\", FALSE, 0, NULL, 0, FALSE},", "  {\"paper\",   FALSE, 0, NULL, 0, FALSE},", "  {\"collate\", FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"portrait\", FALSE, 0, NULL, 0, FALSE},", "  {\"paper\",   FALSE, 0, NULL, 0, FALSE},", "  {\"collate\", FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"portrait\", FALSE, 0, NULL, 0, FALSE},", "  {\"paper\",   FALSE, 0, NULL, 0, FALSE},", "  {\"collate\", FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"paper\",   FALSE, 0, NULL, 0, FALSE},", "  {\"collate\", FALSE, 0, NULL, 0, FALSE},", "  {\"jobsplit\", FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"paper\",   FALSE, 0, NULL, 0, FALSE},", "  {\"collate\", FALSE, 0, NULL, 0, FALSE},", "  {\"jobsplit\", FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"paper\",   FALSE, 0, NULL, 0, FALSE},", "  {\"collate\", FALSE, 0, NULL, 0, FALSE},", "  {\"jobsplit\", FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"collate\", FALSE, 0, NULL, 0, FALSE},", "  {\"jobsplit\", FALSE, 0, NULL, 0, FALSE},", "  {\"formfeed\", FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"collate\", FALSE, 0, NULL, 0, FALSE},", "  {\"jobsplit\", FALSE, 0, NULL, 0, FALSE},", "  {\"formfeed\", FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"collate\", FALSE, 0, NULL, 0, FALSE},", "  {\"jobsplit\", FALSE, 0, NULL, 0, FALSE},", "  {\"formfeed\", FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"jobsplit\", FALSE, 0, NULL, 0, FALSE},", "  {\"formfeed\", FALSE, 0, NULL, 0, FALSE},", "  }"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"jobsplit\", FALSE, 0, NULL, 0, FALSE},", "  {\"formfeed\", FALSE, 0, NULL, 0, FALSE},", "  }"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"jobsplit\", FALSE, 0, NULL, 0, FALSE},", "  {\"formfeed\", FALSE, 0, NULL, 0, FALSE},", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["  }", ";", ""], "whitespace/semicolon"]
["src/nvim/hardcopy.c", ["{", "  {\"c\",       FALSE, 0, NULL, 0, FALSE},", "  {\"a\",       FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["{", "  {\"c\",       FALSE, 0, NULL, 0, FALSE},", "  {\"a\",       FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["{", "  {\"c\",       FALSE, 0, NULL, 0, FALSE},", "  {\"a\",       FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"c\",       FALSE, 0, NULL, 0, FALSE},", "  {\"a\",       FALSE, 0, NULL, 0, FALSE},", "  {\"r\",       FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"c\",       FALSE, 0, NULL, 0, FALSE},", "  {\"a\",       FALSE, 0, NULL, 0, FALSE},", "  {\"r\",       FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"c\",       FALSE, 0, NULL, 0, FALSE},", "  {\"a\",       FALSE, 0, NULL, 0, FALSE},", "  {\"r\",       FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"a\",       FALSE, 0, NULL, 0, FALSE},", "  {\"r\",       FALSE, 0, NULL, 0, FALSE},", "  {\"b\",       FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"a\",       FALSE, 0, NULL, 0, FALSE},", "  {\"r\",       FALSE, 0, NULL, 0, FALSE},", "  {\"b\",       FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"a\",       FALSE, 0, NULL, 0, FALSE},", "  {\"r\",       FALSE, 0, NULL, 0, FALSE},", "  {\"b\",       FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"r\",       FALSE, 0, NULL, 0, FALSE},", "  {\"b\",       FALSE, 0, NULL, 0, FALSE},", "  {\"i\",       FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"r\",       FALSE, 0, NULL, 0, FALSE},", "  {\"b\",       FALSE, 0, NULL, 0, FALSE},", "  {\"i\",       FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"r\",       FALSE, 0, NULL, 0, FALSE},", "  {\"b\",       FALSE, 0, NULL, 0, FALSE},", "  {\"i\",       FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"b\",       FALSE, 0, NULL, 0, FALSE},", "  {\"i\",       FALSE, 0, NULL, 0, FALSE},", "  {\"o\",       FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"b\",       FALSE, 0, NULL, 0, FALSE},", "  {\"i\",       FALSE, 0, NULL, 0, FALSE},", "  {\"o\",       FALSE, 0, NULL, 0, FALSE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"b\",       FALSE, 0, NULL, 0, FALSE},", "  {\"i\",       FALSE, 0, NULL, 0, FALSE},", "  {\"o\",       FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"i\",       FALSE, 0, NULL, 0, FALSE},", "  {\"o\",       FALSE, 0, NULL, 0, FALSE},", "};"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"i\",       FALSE, 0, NULL, 0, FALSE},", "  {\"o\",       FALSE, 0, NULL, 0, FALSE},", "};"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"i\",       FALSE, 0, NULL, 0, FALSE},", "  {\"o\",       FALSE, 0, NULL, 0, FALSE},", "};"], "readability/bool"]
["src/nvim/hardcopy.c", ["", "/*", " * These values determine the print position on a page."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/* Structures to map user named encoding and mapping to PS equivalents for", " * building CID font name */"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/* Static buffer to read initial comments in a resource file, some can have a", " * couple of KB of comments! */"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Parse 'printoptions' and set the flags in \"printer_opts\"."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Parse 'printoptions' and set the flags in \"printer_opts\"."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Parse a list of options in the form"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Repeat for all comma separated parts."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["    commap = vim_strchr(stringp, ',');", "    if (commap == NULL)", "      commap = option_str + STRLEN(option_str);"], "readability/braces"]
["src/nvim/hardcopy.c", ["", "    for (idx = 0; idx < table_size; ++idx)", "      if (STRNICMP(stringp, table[idx].name, len) == 0)"], "readability/braces"]
["src/nvim/hardcopy.c", ["", "    for (idx = 0; idx < table_size; ++idx)", "      if (STRNICMP(stringp, table[idx].name, len) == 0)"], "readability/increment"]
["src/nvim/hardcopy.c", ["    for (idx = 0; idx < table_size; ++idx)", "      if (STRNICMP(stringp, table[idx].name, len) == 0)", "        break;"], "readability/braces"]
["src/nvim/hardcopy.c", ["    p = colonp + 1;", "    table[idx].present = TRUE;", ""], "readability/bool"]
["src/nvim/hardcopy.c", ["    stringp = commap;", "    if (*stringp == ',')", "      ++stringp;"], "readability/braces"]
["src/nvim/hardcopy.c", ["    if (*stringp == ',')", "      ++stringp;", "  }"], "readability/increment"]
["src/nvim/hardcopy.c", ["", "/*", " * If using a dark background, the colors will probably be too bright to show"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "    if (colorindex >= 0 && colorindex < t_colors)", "      fg_color = prt_get_term_color(colorindex);"], "readability/braces"]
["src/nvim/hardcopy.c", ["      fg_color = prt_get_term_color(colorindex);", "    else", "      fg_color = PRCOLOR_BLACK;"], "readability/braces"]
["src/nvim/hardcopy.c", ["", "  if (fg_color == PRCOLOR_WHITE)", "    fg_color = PRCOLOR_BLACK;"], "readability/braces"]
["src/nvim/hardcopy.c", ["    fg_color = PRCOLOR_BLACK;", "  else if (*p_bg == 'd')", "    fg_color = darken_rgb(fg_color);"], "readability/braces"]
["src/nvim/hardcopy.c", ["", "/*", " * Get the currently effective header height."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Return TRUE if using a line number for printing."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Return the unit used in a margin item in 'printoptions'."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "  if (printer_opts[idx].present)", "    for (i = 0; i < 4; ++i)"], "readability/braces"]
["src/nvim/hardcopy.c", ["  if (printer_opts[idx].present)", "    for (i = 0; i < 4; ++i)", "      if (STRNICMP(printer_opts[idx].string, units[i], 2) == 0) {"], "readability/braces"]
["src/nvim/hardcopy.c", ["  if (printer_opts[idx].present)", "    for (i = 0; i < 4; ++i)", "      if (STRNICMP(printer_opts[idx].string, units[i], 2) == 0) {"], "readability/increment"]
["src/nvim/hardcopy.c", ["    linenr_T tmp_lnum, tmp_topline, tmp_botline;", "    int use_sandbox = FALSE;", ""], "readability/bool"]
["src/nvim/hardcopy.c", ["", "    /*", "     * Need to (temporarily) set current line number and first/last line"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["    build_stl_str_hl(curwin, tbuf, (size_t)width + IOSIZE,", "        p_header, use_sandbox,", "        ' ', width, NULL, NULL);"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["        p_header, use_sandbox,", "        ' ', width, NULL, NULL);", ""], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["", "/*", " * Display a print status message."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["  memset(&settings, 0, sizeof(prt_settings_T));", "  settings.has_color = TRUE;", ""], "readability/bool"]
["src/nvim/hardcopy.c", ["    if (expand_filename(eap, eap->cmdlinep, &errormsg) == FAIL) {", "      if (errormsg != NULL)", "        EMSG(errormsg);"], "readability/braces"]
["src/nvim/hardcopy.c", ["    settings.outfile = skipwhite(eap->arg + 1);", "  } else if (*eap->arg != NUL)", "    settings.arguments = eap->arg;"], "readability/braces"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Initialise for printing.  Ask the user for settings, unless forceit is"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["   */", "  if (mch_print_init(&settings,", "          curbuf->b_fname == NULL"], "readability/braces"]
["src/nvim/hardcopy.c", ["  if (mch_print_init(&settings,", "          curbuf->b_fname == NULL", "          ? (char_u *)buf_spname(curbuf)"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["          curbuf->b_fname == NULL", "          ? (char_u *)buf_spname(curbuf)", "          : curbuf->b_sfname == NULL"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["          ? (char_u *)buf_spname(curbuf)", "          : curbuf->b_sfname == NULL", "          ? curbuf->b_fname"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["          : curbuf->b_sfname == NULL", "          ? curbuf->b_fname", "          : curbuf->b_sfname,"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["          ? curbuf->b_fname", "          : curbuf->b_sfname,", "          eap->forceit) == FAIL)"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["          : curbuf->b_sfname,", "          eap->forceit) == FAIL)", "    return;"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["", "  if (!syntax_present(curwin))", "    settings.do_syntax = FALSE;"], "readability/braces"]
["src/nvim/hardcopy.c", ["  if (!syntax_present(curwin))", "    settings.do_syntax = FALSE;", "  else if (printer_opts[OPT_PRINT_SYNTAX].present"], "readability/bool"]
["src/nvim/hardcopy.c", ["    settings.do_syntax = FALSE;", "  else if (printer_opts[OPT_PRINT_SYNTAX].present", "           && TOLOWER_ASC(printer_opts[OPT_PRINT_SYNTAX].string[0]) != 'a')"], "readability/braces"]
["src/nvim/hardcopy.c", ["      (TOLOWER_ASC(printer_opts[OPT_PRINT_SYNTAX].string[0]) == 'y');", "  else", "    settings.do_syntax = settings.has_color;"], "readability/braces"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Estimate the total lines to be printed"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["   */", "  for (lnum = eap->line1; lnum <= eap->line2; lnum++)", "    bytes_to_print += STRLEN(skipwhite(ml_get(lnum)));"], "readability/braces"]
["src/nvim/hardcopy.c", ["  jobsplit = (printer_opts[OPT_PRINT_JOBSPLIT].present", "              && TOLOWER_ASC(printer_opts[OPT_PRINT_JOBSPLIT].string[0]) == 'y');", ""], "whitespace/line_length"]
["src/nvim/hardcopy.c", ["", "  if (!mch_print_begin(&settings))", "    goto print_fail_no_begin;"], "readability/braces"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Loop over collated copies: 1 2 3, 1 2 3, ..."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["      mch_print_end(&settings);", "      if (!mch_print_begin(&settings))", "        goto print_fail_no_begin;"], "readability/braces"]
["src/nvim/hardcopy.c", ["", "    /*", "     * Loop over all pages in the print job: 1 2 3 ..."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["     */", "    for (page_count = 0; prtpos.file_line <= eap->line2; ++page_count) {", "      /*"], "readability/increment"]
["src/nvim/hardcopy.c", ["    for (page_count = 0; prtpos.file_line <= eap->line2; ++page_count) {", "      /*", "       * Loop over uncollated copies: 1 1 1, 2 2 2, 3 3 3, ..."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "        /*", "         * Do front and rear side of a page."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["         */", "        for (side = 0; side <= settings.duplex; ++side) {", "          /*"], "readability/increment"]
["src/nvim/hardcopy.c", ["        for (side = 0; side <= settings.duplex; ++side) {", "          /*", "           * Print one page."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["          os_breakcheck();", "          if (got_int || settings.user_abort)", "            goto print_fail;"], "readability/braces"]
["src/nvim/hardcopy.c", ["          assert(prtpos.bytes_printed <= SIZE_MAX / 100);", "          sprintf((char *)IObuff, _(\"Printing page %d (%zu%%)\"),", "                  page_count + 1 + side,"], "runtime/printf"]
["src/nvim/hardcopy.c", ["                  prtpos.bytes_printed * 100 / bytes_to_print);", "          if (!mch_print_begin_page(IObuff))", "            goto print_fail;"], "readability/braces"]
["src/nvim/hardcopy.c", ["", "          if (settings.n_collated_copies > 1)", "            sprintf((char *)IObuff + STRLEN(IObuff),"], "readability/braces"]
["src/nvim/hardcopy.c", ["            sprintf((char *)IObuff + STRLEN(IObuff),", "                _(\" Copy %d of %d\"),", "                collated_copies + 1,"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["                _(\" Copy %d of %d\"),", "                collated_copies + 1,", "                settings.n_collated_copies);"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["                collated_copies + 1,", "                settings.n_collated_copies);", "          prt_message(IObuff);"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["          if (settings.n_collated_copies > 1)", "            sprintf((char *)IObuff + STRLEN(IObuff),", "                _(\" Copy %d of %d\"),"], "runtime/printf"]
["src/nvim/hardcopy.c", ["", "          /*", "           * Output header if required"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["           */", "          if (prt_header_height() > 0)", "            prt_header(&settings, page_count + 1 + side,"], "readability/braces"]
["src/nvim/hardcopy.c", ["            prt_header(&settings, page_count + 1 + side,", "                prtpos.file_line);", ""], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["          for (page_line = 0; page_line < settings.lines_per_page;", "               ++page_line) {", "            prtpos.column = hardcopy_line(&settings,"], "readability/increment"]
["src/nvim/hardcopy.c", ["            prtpos.column = hardcopy_line(&settings,", "                page_line, &prtpos);", "            if (prtpos.column == 0) {"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["            } else if (prtpos.ff) {", "              /* Line had a formfeed in it - start new page but", "               * stay on the current line */"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "        /*", "         * Extra blank page for duplexing with odd number of pages and"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["            && uncollated_copies + 1 < settings.n_uncollated_copies) {", "          if (!mch_print_blank_page())", "            goto print_fail;"], "readability/braces"]
["src/nvim/hardcopy.c", ["      }", "      if (settings.duplex && prtpos.file_line <= eap->line2)", "        ++page_count;"], "readability/braces"]
["src/nvim/hardcopy.c", ["      if (settings.duplex && prtpos.file_line <= eap->line2)", "        ++page_count;", ""], "readability/increment"]
["src/nvim/hardcopy.c", ["    vim_snprintf((char *)IObuff, IOSIZE, _(\"Printed: %s\"),", "        settings.jobname);", "    prt_message(IObuff);"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["  if (got_int || settings.user_abort) {", "    sprintf((char *)IObuff, \"%s\", _(\"Printing aborted\"));", "    prt_message(IObuff);"], "runtime/printf"]
["src/nvim/hardcopy.c", ["", "/*", " * Print one page line."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", [" */", "static colnr_T hardcopy_line(prt_settings_T *psettings, int page_line, prt_pos_T *ppos)", "{"], "whitespace/line_length"]
["src/nvim/hardcopy.c", ["  char_u      *line;", "  int need_break = FALSE;", "  int outputlen;"], "readability/bool"]
["src/nvim/hardcopy.c", ["    tab_spaces = 0;", "    if (!ppos->ff && prt_use_number())", "      prt_line_number(psettings, page_line, ppos->file_line);"], "readability/braces"]
["src/nvim/hardcopy.c", ["      prt_line_number(psettings, page_line, ppos->file_line);", "    ppos->ff = FALSE;", "  } else {"], "readability/bool"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Loop over the columns until the end of the file line or right margin."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["    if (psettings->do_syntax) {", "      id = syn_get_id(curwin, ppos->file_line, col, 1, NULL, FALSE);", "      if (id > 0)"], "readability/bool"]
["src/nvim/hardcopy.c", ["      id = syn_get_id(curwin, ppos->file_line, col, 1, NULL, FALSE);", "      if (id > 0)", "        id = syn_get_final_id(id);"], "readability/braces"]
["src/nvim/hardcopy.c", ["        id = syn_get_final_id(id);", "      else", "        id = 0;"], "readability/braces"]
["src/nvim/hardcopy.c", ["", "    /*", "     * Appropriately expand any tabs to spaces."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["        tab_spaces--;", "        if (need_break)", "          break;"], "readability/braces"]
["src/nvim/hardcopy.c", ["               == 'y') {", "      ppos->ff = TRUE;", "      need_break = 1;"], "readability/bool"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Start next line of file if we clip lines, or have reached end of the"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["   */", "  if (!ppos->ff", "      && (line[col] == NUL"], "readability/braces"]
["src/nvim/hardcopy.c", ["", "/*", " * PS printer stuff."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["  -250, 805,", "  {\"Courier\", \"Courier-Bold\", \"Courier-Oblique\", \"Courier-BoldOblique\"}", "};"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  -250, 805,", "  {\"Courier\", \"Courier-Bold\", \"Courier-Oblique\", \"Courier-BoldOblique\"}", "};"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  -250, 805,", "  {NULL, NULL, NULL, NULL}", "};"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  -250, 805,", "  {NULL, NULL, NULL, NULL}", "};"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["{", "  {\"iso-2022-jp\", NULL,       (CS_JIS_C_1978|CS_JIS_X_1983|CS_JIS_X_1990|", "                               CS_NEC)},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"iso-2022-jp\", NULL,       (CS_JIS_C_1978|CS_JIS_X_1983|CS_JIS_X_1990|", "                               CS_NEC)},", "  {\"euc-jp\",      \"EUC\",      (CS_JIS_C_1978|CS_JIS_X_1983|CS_JIS_X_1990)},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["                               CS_NEC)},", "  {\"euc-jp\",      \"EUC\",      (CS_JIS_C_1978|CS_JIS_X_1983|CS_JIS_X_1990)},", "  {\"sjis\",        \"RKSJ\",     (CS_JIS_C_1978|CS_JIS_X_1983|CS_MSWINDOWS|"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["                               CS_NEC)},", "  {\"euc-jp\",      \"EUC\",      (CS_JIS_C_1978|CS_JIS_X_1983|CS_JIS_X_1990)},", "  {\"sjis\",        \"RKSJ\",     (CS_JIS_C_1978|CS_JIS_X_1983|CS_MSWINDOWS|"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"euc-jp\",      \"EUC\",      (CS_JIS_C_1978|CS_JIS_X_1983|CS_JIS_X_1990)},", "  {\"sjis\",        \"RKSJ\",     (CS_JIS_C_1978|CS_JIS_X_1983|CS_MSWINDOWS|", "                               CS_KANJITALK6|CS_KANJITALK7)},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"sjis\",        \"RKSJ\",     (CS_JIS_C_1978|CS_JIS_X_1983|CS_MSWINDOWS|", "                               CS_KANJITALK6|CS_KANJITALK7)},", "  {\"cp932\",       \"RKSJ\",     CS_JIS_X_1983},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["                               CS_KANJITALK6|CS_KANJITALK7)},", "  {\"cp932\",       \"RKSJ\",     CS_JIS_X_1983},", "  {\"ucs-2\",       \"UCS2\",     CS_JIS_X_1990},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["                               CS_KANJITALK6|CS_KANJITALK7)},", "  {\"cp932\",       \"RKSJ\",     CS_JIS_X_1983},", "  {\"ucs-2\",       \"UCS2\",     CS_JIS_X_1990},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"cp932\",       \"RKSJ\",     CS_JIS_X_1983},", "  {\"ucs-2\",       \"UCS2\",     CS_JIS_X_1990},", "  {\"utf-8\",       \"UTF8\",    CS_JIS_X_1990}"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"cp932\",       \"RKSJ\",     CS_JIS_X_1983},", "  {\"ucs-2\",       \"UCS2\",     CS_JIS_X_1990},", "  {\"utf-8\",       \"UTF8\",    CS_JIS_X_1990}"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"ucs-2\",       \"UCS2\",     CS_JIS_X_1990},", "  {\"utf-8\",       \"UTF8\",    CS_JIS_X_1990}", "};"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"ucs-2\",       \"UCS2\",     CS_JIS_X_1990},", "  {\"utf-8\",       \"UTF8\",    CS_JIS_X_1990}", "};"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["{", "  {\"JIS_C_1978\",  \"78\",       CS_JIS_C_1978},", "  {\"JIS_X_1983\",  NULL,       CS_JIS_X_1983},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["{", "  {\"JIS_C_1978\",  \"78\",       CS_JIS_C_1978},", "  {\"JIS_X_1983\",  NULL,       CS_JIS_X_1983},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"JIS_C_1978\",  \"78\",       CS_JIS_C_1978},", "  {\"JIS_X_1983\",  NULL,       CS_JIS_X_1983},", "  {\"JIS_X_1990\",  \"Hojo\",     CS_JIS_X_1990},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"JIS_C_1978\",  \"78\",       CS_JIS_C_1978},", "  {\"JIS_X_1983\",  NULL,       CS_JIS_X_1983},", "  {\"JIS_X_1990\",  \"Hojo\",     CS_JIS_X_1990},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"JIS_X_1983\",  NULL,       CS_JIS_X_1983},", "  {\"JIS_X_1990\",  \"Hojo\",     CS_JIS_X_1990},", "  {\"NEC\",         \"Ext\",      CS_NEC},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"JIS_X_1983\",  NULL,       CS_JIS_X_1983},", "  {\"JIS_X_1990\",  \"Hojo\",     CS_JIS_X_1990},", "  {\"NEC\",         \"Ext\",      CS_NEC},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"JIS_X_1990\",  \"Hojo\",     CS_JIS_X_1990},", "  {\"NEC\",         \"Ext\",      CS_NEC},", "  {\"MSWINDOWS\",   \"90ms\",     CS_MSWINDOWS},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"JIS_X_1990\",  \"Hojo\",     CS_JIS_X_1990},", "  {\"NEC\",         \"Ext\",      CS_NEC},", "  {\"MSWINDOWS\",   \"90ms\",     CS_MSWINDOWS},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"NEC\",         \"Ext\",      CS_NEC},", "  {\"MSWINDOWS\",   \"90ms\",     CS_MSWINDOWS},", "  {\"CP932\",       \"90ms\",     CS_JIS_X_1983},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"NEC\",         \"Ext\",      CS_NEC},", "  {\"MSWINDOWS\",   \"90ms\",     CS_MSWINDOWS},", "  {\"CP932\",       \"90ms\",     CS_JIS_X_1983},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"MSWINDOWS\",   \"90ms\",     CS_MSWINDOWS},", "  {\"CP932\",       \"90ms\",     CS_JIS_X_1983},", "  {\"KANJITALK6\",  \"83pv\",     CS_KANJITALK6},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"MSWINDOWS\",   \"90ms\",     CS_MSWINDOWS},", "  {\"CP932\",       \"90ms\",     CS_JIS_X_1983},", "  {\"KANJITALK6\",  \"83pv\",     CS_KANJITALK6},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"CP932\",       \"90ms\",     CS_JIS_X_1983},", "  {\"KANJITALK6\",  \"83pv\",     CS_KANJITALK6},", "  {\"KANJITALK7\",  \"90pv\",     CS_KANJITALK7}"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"CP932\",       \"90ms\",     CS_JIS_X_1983},", "  {\"KANJITALK6\",  \"83pv\",     CS_KANJITALK6},", "  {\"KANJITALK7\",  \"90pv\",     CS_KANJITALK7}"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"KANJITALK6\",  \"83pv\",     CS_KANJITALK6},", "  {\"KANJITALK7\",  \"90pv\",     CS_KANJITALK7}", "};"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"KANJITALK6\",  \"83pv\",     CS_KANJITALK6},", "  {\"KANJITALK7\",  \"90pv\",     CS_KANJITALK7}", "};"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["{", "  {\"iso-2022\",    NULL,       (CS_GB_2312_80|CS_GBT_12345_90)},", "  {\"gb18030\",     NULL,       CS_GBK2K},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["{", "  {\"iso-2022\",    NULL,       (CS_GB_2312_80|CS_GBT_12345_90)},", "  {\"gb18030\",     NULL,       CS_GBK2K},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"iso-2022\",    NULL,       (CS_GB_2312_80|CS_GBT_12345_90)},", "  {\"gb18030\",     NULL,       CS_GBK2K},", "  {\"euc-cn\",      \"EUC\",      (CS_GB_2312_80|CS_GBT_12345_90|CS_SC_MAC|"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"iso-2022\",    NULL,       (CS_GB_2312_80|CS_GBT_12345_90)},", "  {\"gb18030\",     NULL,       CS_GBK2K},", "  {\"euc-cn\",      \"EUC\",      (CS_GB_2312_80|CS_GBT_12345_90|CS_SC_MAC|"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"gb18030\",     NULL,       CS_GBK2K},", "  {\"euc-cn\",      \"EUC\",      (CS_GB_2312_80|CS_GBT_12345_90|CS_SC_MAC|", "                               CS_GBT_90_MAC)},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"euc-cn\",      \"EUC\",      (CS_GB_2312_80|CS_GBT_12345_90|CS_SC_MAC|", "                               CS_GBT_90_MAC)},", "  {\"gbk\",         \"EUC\",      CS_GBK},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["                               CS_GBT_90_MAC)},", "  {\"gbk\",         \"EUC\",      CS_GBK},", "  {\"ucs-2\",       \"UCS2\",     CS_SC_ISO10646},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["                               CS_GBT_90_MAC)},", "  {\"gbk\",         \"EUC\",      CS_GBK},", "  {\"ucs-2\",       \"UCS2\",     CS_SC_ISO10646},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"gbk\",         \"EUC\",      CS_GBK},", "  {\"ucs-2\",       \"UCS2\",     CS_SC_ISO10646},", "  {\"utf-8\",       \"UTF8\",     CS_SC_ISO10646}"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"gbk\",         \"EUC\",      CS_GBK},", "  {\"ucs-2\",       \"UCS2\",     CS_SC_ISO10646},", "  {\"utf-8\",       \"UTF8\",     CS_SC_ISO10646}"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"ucs-2\",       \"UCS2\",     CS_SC_ISO10646},", "  {\"utf-8\",       \"UTF8\",     CS_SC_ISO10646}", "};"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"ucs-2\",       \"UCS2\",     CS_SC_ISO10646},", "  {\"utf-8\",       \"UTF8\",     CS_SC_ISO10646}", "};"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["{", "  {\"GB_2312-80\",  \"GB\",       CS_GB_2312_80},", "  {\"GBT_12345-90\",\"GBT\",      CS_GBT_12345_90},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["{", "  {\"GB_2312-80\",  \"GB\",       CS_GB_2312_80},", "  {\"GBT_12345-90\",\"GBT\",      CS_GBT_12345_90},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"GB_2312-80\",  \"GB\",       CS_GB_2312_80},", "  {\"GBT_12345-90\",\"GBT\",      CS_GBT_12345_90},", "  {\"MAC\",         \"GBpc\",     CS_SC_MAC},"], "whitespace/comma"]
["src/nvim/hardcopy.c", ["  {\"GB_2312-80\",  \"GB\",       CS_GB_2312_80},", "  {\"GBT_12345-90\",\"GBT\",      CS_GBT_12345_90},", "  {\"MAC\",         \"GBpc\",     CS_SC_MAC},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"GB_2312-80\",  \"GB\",       CS_GB_2312_80},", "  {\"GBT_12345-90\",\"GBT\",      CS_GBT_12345_90},", "  {\"MAC\",         \"GBpc\",     CS_SC_MAC},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"GBT_12345-90\",\"GBT\",      CS_GBT_12345_90},", "  {\"MAC\",         \"GBpc\",     CS_SC_MAC},", "  {\"GBT-90_MAC\",  \"GBTpc\",    CS_GBT_90_MAC},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"GBT_12345-90\",\"GBT\",      CS_GBT_12345_90},", "  {\"MAC\",         \"GBpc\",     CS_SC_MAC},", "  {\"GBT-90_MAC\",  \"GBTpc\",    CS_GBT_90_MAC},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"MAC\",         \"GBpc\",     CS_SC_MAC},", "  {\"GBT-90_MAC\",  \"GBTpc\",    CS_GBT_90_MAC},", "  {\"GBK\",         \"GBK\",      CS_GBK},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"MAC\",         \"GBpc\",     CS_SC_MAC},", "  {\"GBT-90_MAC\",  \"GBTpc\",    CS_GBT_90_MAC},", "  {\"GBK\",         \"GBK\",      CS_GBK},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"GBT-90_MAC\",  \"GBTpc\",    CS_GBT_90_MAC},", "  {\"GBK\",         \"GBK\",      CS_GBK},", "  {\"GB18030\",     \"GBK2K\",    CS_GBK2K},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"GBT-90_MAC\",  \"GBTpc\",    CS_GBT_90_MAC},", "  {\"GBK\",         \"GBK\",      CS_GBK},", "  {\"GB18030\",     \"GBK2K\",    CS_GBK2K},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"GBK\",         \"GBK\",      CS_GBK},", "  {\"GB18030\",     \"GBK2K\",    CS_GBK2K},", "  {\"ISO10646\",    \"UniGB\",    CS_SC_ISO10646}"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"GBK\",         \"GBK\",      CS_GBK},", "  {\"GB18030\",     \"GBK2K\",    CS_GBK2K},", "  {\"ISO10646\",    \"UniGB\",    CS_SC_ISO10646}"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"GB18030\",     \"GBK2K\",    CS_GBK2K},", "  {\"ISO10646\",    \"UniGB\",    CS_SC_ISO10646}", "};"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"GB18030\",     \"GBK2K\",    CS_GBK2K},", "  {\"ISO10646\",    \"UniGB\",    CS_SC_ISO10646}", "};"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["{", "  {\"iso-2022\",    NULL,       (CS_CNS_PLANE_1|CS_CNS_PLANE_2)},", "  {\"euc-tw\",      \"EUC\",      CS_CNS_PLANE_1_2},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["{", "  {\"iso-2022\",    NULL,       (CS_CNS_PLANE_1|CS_CNS_PLANE_2)},", "  {\"euc-tw\",      \"EUC\",      CS_CNS_PLANE_1_2},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"iso-2022\",    NULL,       (CS_CNS_PLANE_1|CS_CNS_PLANE_2)},", "  {\"euc-tw\",      \"EUC\",      CS_CNS_PLANE_1_2},", "  {\"big5\",        \"B5\",       (CS_B5|CS_ETEN|CS_HK_GCCS|CS_HK_SCS|"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"iso-2022\",    NULL,       (CS_CNS_PLANE_1|CS_CNS_PLANE_2)},", "  {\"euc-tw\",      \"EUC\",      CS_CNS_PLANE_1_2},", "  {\"big5\",        \"B5\",       (CS_B5|CS_ETEN|CS_HK_GCCS|CS_HK_SCS|"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"euc-tw\",      \"EUC\",      CS_CNS_PLANE_1_2},", "  {\"big5\",        \"B5\",       (CS_B5|CS_ETEN|CS_HK_GCCS|CS_HK_SCS|", "                               CS_HK_SCS_ETEN|CS_MTHKL|CS_MTHKS|CS_DLHKL|"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["                               CS_HK_SCS_ETEN|CS_MTHKL|CS_MTHKS|CS_DLHKL|", "                               CS_DLHKS)},", "  {\"cp950\",       \"B5\",       CS_B5},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["                               CS_DLHKS)},", "  {\"cp950\",       \"B5\",       CS_B5},", "  {\"ucs-2\",       \"UCS2\",     CS_TC_ISO10646},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["                               CS_DLHKS)},", "  {\"cp950\",       \"B5\",       CS_B5},", "  {\"ucs-2\",       \"UCS2\",     CS_TC_ISO10646},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"cp950\",       \"B5\",       CS_B5},", "  {\"ucs-2\",       \"UCS2\",     CS_TC_ISO10646},", "  {\"utf-8\",       \"UTF8\",     CS_TC_ISO10646},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"cp950\",       \"B5\",       CS_B5},", "  {\"ucs-2\",       \"UCS2\",     CS_TC_ISO10646},", "  {\"utf-8\",       \"UTF8\",     CS_TC_ISO10646},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"ucs-2\",       \"UCS2\",     CS_TC_ISO10646},", "  {\"utf-8\",       \"UTF8\",     CS_TC_ISO10646},", "  {\"utf-16\",      \"UTF16\",    CS_TC_ISO10646},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"ucs-2\",       \"UCS2\",     CS_TC_ISO10646},", "  {\"utf-8\",       \"UTF8\",     CS_TC_ISO10646},", "  {\"utf-16\",      \"UTF16\",    CS_TC_ISO10646},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"utf-8\",       \"UTF8\",     CS_TC_ISO10646},", "  {\"utf-16\",      \"UTF16\",    CS_TC_ISO10646},", "  {\"utf-32\",      \"UTF32\",    CS_TC_ISO10646}"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"utf-8\",       \"UTF8\",     CS_TC_ISO10646},", "  {\"utf-16\",      \"UTF16\",    CS_TC_ISO10646},", "  {\"utf-32\",      \"UTF32\",    CS_TC_ISO10646}"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"utf-16\",      \"UTF16\",    CS_TC_ISO10646},", "  {\"utf-32\",      \"UTF32\",    CS_TC_ISO10646}", "};"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"utf-16\",      \"UTF16\",    CS_TC_ISO10646},", "  {\"utf-32\",      \"UTF32\",    CS_TC_ISO10646}", "};"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["{", "  {\"CNS_1992_1\",  \"CNS1\",     CS_CNS_PLANE_1},", "  {\"CNS_1992_2\",  \"CNS2\",     CS_CNS_PLANE_2},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["{", "  {\"CNS_1992_1\",  \"CNS1\",     CS_CNS_PLANE_1},", "  {\"CNS_1992_2\",  \"CNS2\",     CS_CNS_PLANE_2},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"CNS_1992_1\",  \"CNS1\",     CS_CNS_PLANE_1},", "  {\"CNS_1992_2\",  \"CNS2\",     CS_CNS_PLANE_2},", "  {\"CNS_1993\",    \"CNS\",      CS_CNS_PLANE_1_2},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"CNS_1992_1\",  \"CNS1\",     CS_CNS_PLANE_1},", "  {\"CNS_1992_2\",  \"CNS2\",     CS_CNS_PLANE_2},", "  {\"CNS_1993\",    \"CNS\",      CS_CNS_PLANE_1_2},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"CNS_1992_2\",  \"CNS2\",     CS_CNS_PLANE_2},", "  {\"CNS_1993\",    \"CNS\",      CS_CNS_PLANE_1_2},", "  {\"BIG5\",        NULL,       CS_B5},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"CNS_1992_2\",  \"CNS2\",     CS_CNS_PLANE_2},", "  {\"CNS_1993\",    \"CNS\",      CS_CNS_PLANE_1_2},", "  {\"BIG5\",        NULL,       CS_B5},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"CNS_1993\",    \"CNS\",      CS_CNS_PLANE_1_2},", "  {\"BIG5\",        NULL,       CS_B5},", "  {\"CP950\",       NULL,       CS_B5},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"CNS_1993\",    \"CNS\",      CS_CNS_PLANE_1_2},", "  {\"BIG5\",        NULL,       CS_B5},", "  {\"CP950\",       NULL,       CS_B5},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"BIG5\",        NULL,       CS_B5},", "  {\"CP950\",       NULL,       CS_B5},", "  {\"ETEN\",        \"ETen\",     CS_ETEN},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"BIG5\",        NULL,       CS_B5},", "  {\"CP950\",       NULL,       CS_B5},", "  {\"ETEN\",        \"ETen\",     CS_ETEN},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"CP950\",       NULL,       CS_B5},", "  {\"ETEN\",        \"ETen\",     CS_ETEN},", "  {\"HK_GCCS\",     \"HKgccs\",   CS_HK_GCCS},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"CP950\",       NULL,       CS_B5},", "  {\"ETEN\",        \"ETen\",     CS_ETEN},", "  {\"HK_GCCS\",     \"HKgccs\",   CS_HK_GCCS},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"ETEN\",        \"ETen\",     CS_ETEN},", "  {\"HK_GCCS\",     \"HKgccs\",   CS_HK_GCCS},", "  {\"SCS\",         \"HKscs\",    CS_HK_SCS},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"ETEN\",        \"ETen\",     CS_ETEN},", "  {\"HK_GCCS\",     \"HKgccs\",   CS_HK_GCCS},", "  {\"SCS\",         \"HKscs\",    CS_HK_SCS},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"HK_GCCS\",     \"HKgccs\",   CS_HK_GCCS},", "  {\"SCS\",         \"HKscs\",    CS_HK_SCS},", "  {\"SCS_ETEN\",    \"ETHK\",     CS_HK_SCS_ETEN},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"HK_GCCS\",     \"HKgccs\",   CS_HK_GCCS},", "  {\"SCS\",         \"HKscs\",    CS_HK_SCS},", "  {\"SCS_ETEN\",    \"ETHK\",     CS_HK_SCS_ETEN},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"SCS\",         \"HKscs\",    CS_HK_SCS},", "  {\"SCS_ETEN\",    \"ETHK\",     CS_HK_SCS_ETEN},", "  {\"MTHKL\",       \"HKm471\",   CS_MTHKL},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"SCS\",         \"HKscs\",    CS_HK_SCS},", "  {\"SCS_ETEN\",    \"ETHK\",     CS_HK_SCS_ETEN},", "  {\"MTHKL\",       \"HKm471\",   CS_MTHKL},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"SCS_ETEN\",    \"ETHK\",     CS_HK_SCS_ETEN},", "  {\"MTHKL\",       \"HKm471\",   CS_MTHKL},", "  {\"MTHKS\",       \"HKm314\",   CS_MTHKS},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"SCS_ETEN\",    \"ETHK\",     CS_HK_SCS_ETEN},", "  {\"MTHKL\",       \"HKm471\",   CS_MTHKL},", "  {\"MTHKS\",       \"HKm314\",   CS_MTHKS},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"MTHKL\",       \"HKm471\",   CS_MTHKL},", "  {\"MTHKS\",       \"HKm314\",   CS_MTHKS},", "  {\"DLHKL\",       \"HKdla\",    CS_DLHKL},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"MTHKL\",       \"HKm471\",   CS_MTHKL},", "  {\"MTHKS\",       \"HKm314\",   CS_MTHKS},", "  {\"DLHKL\",       \"HKdla\",    CS_DLHKL},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"MTHKS\",       \"HKm314\",   CS_MTHKS},", "  {\"DLHKL\",       \"HKdla\",    CS_DLHKL},", "  {\"DLHKS\",       \"HKdlb\",    CS_DLHKS},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"MTHKS\",       \"HKm314\",   CS_MTHKS},", "  {\"DLHKL\",       \"HKdla\",    CS_DLHKL},", "  {\"DLHKS\",       \"HKdlb\",    CS_DLHKS},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"DLHKL\",       \"HKdla\",    CS_DLHKL},", "  {\"DLHKS\",       \"HKdlb\",    CS_DLHKS},", "  {\"ISO10646\",    \"UniCNS\",   CS_TC_ISO10646}"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"DLHKL\",       \"HKdla\",    CS_DLHKL},", "  {\"DLHKS\",       \"HKdlb\",    CS_DLHKS},", "  {\"ISO10646\",    \"UniCNS\",   CS_TC_ISO10646}"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"DLHKS\",       \"HKdlb\",    CS_DLHKS},", "  {\"ISO10646\",    \"UniCNS\",   CS_TC_ISO10646}", "};"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"DLHKS\",       \"HKdlb\",    CS_DLHKS},", "  {\"ISO10646\",    \"UniCNS\",   CS_TC_ISO10646}", "};"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["{", "  {\"iso-2022-kr\", NULL,       CS_KR_X_1992},", "  {\"euc-kr\",      \"EUC\",      (CS_KR_X_1992|CS_KR_MAC)},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["{", "  {\"iso-2022-kr\", NULL,       CS_KR_X_1992},", "  {\"euc-kr\",      \"EUC\",      (CS_KR_X_1992|CS_KR_MAC)},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"iso-2022-kr\", NULL,       CS_KR_X_1992},", "  {\"euc-kr\",      \"EUC\",      (CS_KR_X_1992|CS_KR_MAC)},", "  {\"johab\",       \"Johab\",    CS_KR_X_1992},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"iso-2022-kr\", NULL,       CS_KR_X_1992},", "  {\"euc-kr\",      \"EUC\",      (CS_KR_X_1992|CS_KR_MAC)},", "  {\"johab\",       \"Johab\",    CS_KR_X_1992},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"euc-kr\",      \"EUC\",      (CS_KR_X_1992|CS_KR_MAC)},", "  {\"johab\",       \"Johab\",    CS_KR_X_1992},", "  {\"cp1361\",      \"Johab\",    CS_KR_X_1992},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"euc-kr\",      \"EUC\",      (CS_KR_X_1992|CS_KR_MAC)},", "  {\"johab\",       \"Johab\",    CS_KR_X_1992},", "  {\"cp1361\",      \"Johab\",    CS_KR_X_1992},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"johab\",       \"Johab\",    CS_KR_X_1992},", "  {\"cp1361\",      \"Johab\",    CS_KR_X_1992},", "  {\"uhc\",         \"UHC\",      CS_KR_X_1992_MS},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"johab\",       \"Johab\",    CS_KR_X_1992},", "  {\"cp1361\",      \"Johab\",    CS_KR_X_1992},", "  {\"uhc\",         \"UHC\",      CS_KR_X_1992_MS},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"cp1361\",      \"Johab\",    CS_KR_X_1992},", "  {\"uhc\",         \"UHC\",      CS_KR_X_1992_MS},", "  {\"cp949\",       \"UHC\",      CS_KR_X_1992_MS},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"cp1361\",      \"Johab\",    CS_KR_X_1992},", "  {\"uhc\",         \"UHC\",      CS_KR_X_1992_MS},", "  {\"cp949\",       \"UHC\",      CS_KR_X_1992_MS},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"uhc\",         \"UHC\",      CS_KR_X_1992_MS},", "  {\"cp949\",       \"UHC\",      CS_KR_X_1992_MS},", "  {\"ucs-2\",       \"UCS2\",     CS_KR_ISO10646},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"uhc\",         \"UHC\",      CS_KR_X_1992_MS},", "  {\"cp949\",       \"UHC\",      CS_KR_X_1992_MS},", "  {\"ucs-2\",       \"UCS2\",     CS_KR_ISO10646},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"cp949\",       \"UHC\",      CS_KR_X_1992_MS},", "  {\"ucs-2\",       \"UCS2\",     CS_KR_ISO10646},", "  {\"utf-8\",       \"UTF8\",     CS_KR_ISO10646}"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"cp949\",       \"UHC\",      CS_KR_X_1992_MS},", "  {\"ucs-2\",       \"UCS2\",     CS_KR_ISO10646},", "  {\"utf-8\",       \"UTF8\",     CS_KR_ISO10646}"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"ucs-2\",       \"UCS2\",     CS_KR_ISO10646},", "  {\"utf-8\",       \"UTF8\",     CS_KR_ISO10646}", "};"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"ucs-2\",       \"UCS2\",     CS_KR_ISO10646},", "  {\"utf-8\",       \"UTF8\",     CS_KR_ISO10646}", "};"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["{", "  {\"KS_X_1992\",   \"KSC\",      CS_KR_X_1992},", "  {\"CP1361\",      \"KSC\",      CS_KR_X_1992},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["{", "  {\"KS_X_1992\",   \"KSC\",      CS_KR_X_1992},", "  {\"CP1361\",      \"KSC\",      CS_KR_X_1992},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"KS_X_1992\",   \"KSC\",      CS_KR_X_1992},", "  {\"CP1361\",      \"KSC\",      CS_KR_X_1992},", "  {\"MAC\",         \"KSCpc\",    CS_KR_MAC},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"KS_X_1992\",   \"KSC\",      CS_KR_X_1992},", "  {\"CP1361\",      \"KSC\",      CS_KR_X_1992},", "  {\"MAC\",         \"KSCpc\",    CS_KR_MAC},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"CP1361\",      \"KSC\",      CS_KR_X_1992},", "  {\"MAC\",         \"KSCpc\",    CS_KR_MAC},", "  {\"MSWINDOWS\",   \"KSCms\",    CS_KR_X_1992_MS},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"CP1361\",      \"KSC\",      CS_KR_X_1992},", "  {\"MAC\",         \"KSCpc\",    CS_KR_MAC},", "  {\"MSWINDOWS\",   \"KSCms\",    CS_KR_X_1992_MS},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"MAC\",         \"KSCpc\",    CS_KR_MAC},", "  {\"MSWINDOWS\",   \"KSCms\",    CS_KR_X_1992_MS},", "  {\"CP949\",       \"KSCms\",    CS_KR_X_1992_MS},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"MAC\",         \"KSCpc\",    CS_KR_MAC},", "  {\"MSWINDOWS\",   \"KSCms\",    CS_KR_X_1992_MS},", "  {\"CP949\",       \"KSCms\",    CS_KR_X_1992_MS},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"MSWINDOWS\",   \"KSCms\",    CS_KR_X_1992_MS},", "  {\"CP949\",       \"KSCms\",    CS_KR_X_1992_MS},", "  {\"WANSUNG\",     \"KSCms\",    CS_KR_X_1992_MS},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"MSWINDOWS\",   \"KSCms\",    CS_KR_X_1992_MS},", "  {\"CP949\",       \"KSCms\",    CS_KR_X_1992_MS},", "  {\"WANSUNG\",     \"KSCms\",    CS_KR_X_1992_MS},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"CP949\",       \"KSCms\",    CS_KR_X_1992_MS},", "  {\"WANSUNG\",     \"KSCms\",    CS_KR_X_1992_MS},", "  {\"ISO10646\",    \"UniKS\",    CS_KR_ISO10646}"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"CP949\",       \"KSCms\",    CS_KR_X_1992_MS},", "  {\"WANSUNG\",     \"KSCms\",    CS_KR_X_1992_MS},", "  {\"ISO10646\",    \"UniKS\",    CS_KR_ISO10646}"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"WANSUNG\",     \"KSCms\",    CS_KR_X_1992_MS},", "  {\"ISO10646\",    \"UniKS\",    CS_KR_ISO10646}", "};"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {\"WANSUNG\",     \"KSCms\",    CS_KR_X_1992_MS},", "  {\"ISO10646\",    \"UniKS\",    CS_KR_ISO10646}", "};"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["", "/* The PS prolog file version number has to match - if the prolog file is", " * updated, increment the number in the file and here.  Version checking was"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/* Data for table based DSC comment recognition, easy to extend if VIM needs to", " * read more comments. */"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["{", "  {PRT_DSC_TITLE,       SIZEOF_CSTR(PRT_DSC_TITLE),     PRT_DSC_TITLE_TYPE},", "  {PRT_DSC_VERSION,     SIZEOF_CSTR(PRT_DSC_VERSION),"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["{", "  {PRT_DSC_TITLE,       SIZEOF_CSTR(PRT_DSC_TITLE),     PRT_DSC_TITLE_TYPE},", "  {PRT_DSC_VERSION,     SIZEOF_CSTR(PRT_DSC_VERSION),"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {PRT_DSC_TITLE,       SIZEOF_CSTR(PRT_DSC_TITLE),     PRT_DSC_TITLE_TYPE},", "  {PRT_DSC_VERSION,     SIZEOF_CSTR(PRT_DSC_VERSION),", "   PRT_DSC_VERSION_TYPE},"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {PRT_DSC_VERSION,     SIZEOF_CSTR(PRT_DSC_VERSION),", "   PRT_DSC_VERSION_TYPE},", "  {PRT_DSC_ENDCOMMENTS, SIZEOF_CSTR(PRT_DSC_ENDCOMMENTS),"], "whitespace/indent"]
["src/nvim/hardcopy.c", ["  {PRT_DSC_VERSION,     SIZEOF_CSTR(PRT_DSC_VERSION),", "   PRT_DSC_VERSION_TYPE},", "  {PRT_DSC_ENDCOMMENTS, SIZEOF_CSTR(PRT_DSC_ENDCOMMENTS),"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["   PRT_DSC_VERSION_TYPE},", "  {PRT_DSC_ENDCOMMENTS, SIZEOF_CSTR(PRT_DSC_ENDCOMMENTS),", "   PRT_DSC_ENDCOMMENTS_TYPE}"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {PRT_DSC_ENDCOMMENTS, SIZEOF_CSTR(PRT_DSC_ENDCOMMENTS),", "   PRT_DSC_ENDCOMMENTS_TYPE}", "};"], "whitespace/indent"]
["src/nvim/hardcopy.c", ["  {PRT_DSC_ENDCOMMENTS, SIZEOF_CSTR(PRT_DSC_ENDCOMMENTS),", "   PRT_DSC_ENDCOMMENTS_TYPE}", "};"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["", "/*", " * Variables for the output PostScript file."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Various offsets and dimensions in default PostScript user space (points)."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Various control variables used to decide when and how to change the"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Variables controlling physical printing."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Buffers used when generating PostScript output"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["    EMSG(_(\"E455: Error writing to PostScript output file\"));", "    prt_file_error = TRUE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["", "/*", " * Write a string."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Write an int and a space."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["{", "  sprintf((char *)prt_line_buffer, \"%d \", i);", "  prt_write_file(prt_line_buffer);"], "runtime/printf"]
["src/nvim/hardcopy.c", ["", "/*", " * Write a boolean and a space."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["{", "  sprintf((char *)prt_line_buffer, \"%s \", (b ? \"T\" : \"F\"));", "  prt_write_file(prt_line_buffer);"], "runtime/printf"]
["src/nvim/hardcopy.c", ["", "/*", " * Write PostScript to re-encode and define the font."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["  vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),", "      \"/_%s /VIM-%s /%s ref\\n\", new_name, encoding, font);", "  prt_write_file(prt_line_buffer);"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["  prt_write_file(prt_line_buffer);", "  if (prt_out_mbyte)", "    sprintf((char *)prt_line_buffer, \"/%s %d %f /_%s sffs\\n\","], "readability/braces"]
["src/nvim/hardcopy.c", ["    sprintf((char *)prt_line_buffer, \"/%s %d %f /_%s sffs\\n\",", "        new_name, height, 500./prt_ps_courier_font.wx, new_name);", "  else"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["  if (prt_out_mbyte)", "    sprintf((char *)prt_line_buffer, \"/%s %d %f /_%s sffs\\n\",", "        new_name, height, 500./prt_ps_courier_font.wx, new_name);"], "runtime/printf"]
["src/nvim/hardcopy.c", ["        new_name, height, 500./prt_ps_courier_font.wx, new_name);", "  else", "    vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),"], "readability/braces"]
["src/nvim/hardcopy.c", ["    vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),", "        \"/%s %d /_%s ffs\\n\", new_name, height, new_name);", "  prt_write_file(prt_line_buffer);"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["", "/*", " * Write a line to define the CID font."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["  vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),", "      \"/_%s /%s[/%s] vim_composefont\\n\", new_name, prt_cmap, cidfont);", "  prt_write_file(prt_line_buffer);"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["  vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),", "      \"/%s %d /_%s ffs\\n\", new_name, height, new_name);", "  prt_write_file(prt_line_buffer);"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["", "/*", " * Write a line to define a duplicate of a CID font"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["  vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),", "      \"/%s %s d\\n\", new_name, original_name);", "  prt_write_file(prt_line_buffer);"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["", "/*", " * Convert a real value into an integer and fractional part as integers, with"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", [" */", "static void prt_real_bits(double real, int precision, int *pinteger, int *pfraction)", "{"], "whitespace/line_length"]
["src/nvim/hardcopy.c", ["  double fraction = real - integer;", "  if (real < integer)", "    fraction = -fraction;"], "readability/braces"]
["src/nvim/hardcopy.c", ["    fraction = -fraction;", "  for (int i = 0; i < precision; i++)", "    fraction *= 10.0;"], "readability/braces"]
["src/nvim/hardcopy.c", ["", "/*", " * Write a real and a space.  Save bytes if real value has no fractional part!"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["  }", "  sprintf((char *)prt_line_buffer, \" \");", "  prt_write_file(prt_line_buffer);"], "runtime/printf"]
["src/nvim/hardcopy.c", ["", "/*", " * Write a line to define a numeric variable."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["  vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),", "      \"/%s \", name);", "  prt_write_file(prt_line_buffer);"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["  prt_write_real(value, prec);", "  sprintf((char *)prt_line_buffer, \"d\\n\");", "  prt_write_file(prt_line_buffer);"], "runtime/printf"]
["src/nvim/hardcopy.c", ["    }", "    /* Draw underlines before the text as it makes it slightly easier to", "     * find the starting point."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["    // Draw the text", "    if (prt_out_mbyte)", "      prt_write_string(\"<\");"], "readability/braces"]
["src/nvim/hardcopy.c", ["      prt_write_string(\"<\");", "    else", "      prt_write_string(\"(\");"], "readability/braces"]
["src/nvim/hardcopy.c", ["    prt_write_file_raw_len(prt_ps_buffer.ga_data, (size_t)prt_ps_buffer.ga_len);", "    if (prt_out_mbyte)", "      prt_write_string(\">\");"], "readability/braces"]
["src/nvim/hardcopy.c", ["      prt_write_string(\">\");", "    else", "      prt_write_string(\")\");"], "readability/braces"]
["src/nvim/hardcopy.c", ["", "  if (STRLEN(filename) >= MAXPATHL)", "    *resource_filename = NUL;"], "readability/braces"]
["src/nvim/hardcopy.c", ["    *resource_filename = NUL;", "  else", "    STRCPY(resource_filename, filename);"], "readability/braces"]
["src/nvim/hardcopy.c", ["  while (idx < prt_resfile.len) {", "    if (prt_resfile.buffer[idx] != PSLF && prt_resfile.buffer[idx] != PSCR)", "      break;"], "readability/braces"]
["src/nvim/hardcopy.c", ["  while (idx < prt_resfile.len) {", "    if (prt_resfile.buffer[idx] == PSLF || prt_resfile.buffer[idx] == PSCR)", "      break;"], "readability/braces"]
["src/nvim/hardcopy.c", ["  return STRNCMP(&prt_resfile.buffer[prt_resfile.line_start + offset],", "      string, len);", "}"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["  while (idx < prt_resfile.line_end) {", "    if (isspace(prt_resfile.buffer[idx]))", "      return idx - prt_resfile.line_start;"], "readability/braces"]
["src/nvim/hardcopy.c", ["  while (idx < prt_resfile.line_end) {", "    if (!isspace(prt_resfile.buffer[idx]))", "      return idx - prt_resfile.line_start;"], "readability/braces"]
["src/nvim/hardcopy.c", ["", "/* prt_next_dsc() - returns detail on next DSC comment line found.  Returns true", " * if a DSC comment is found, else false */"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/* Improved hand crafted parser to get the type, title, and version number of a", " * PS resource file so the file details can be added to the DSC header comments."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["  prt_resfile.len = (int)fread((char *)prt_resfile.buffer, sizeof(char_u),", "      PRT_FILE_BUFFER_LEN, fd_resource);", "  if (ferror(fd_resource)) {"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["    EMSG2(_(\"E457: Can't read PostScript resource file \\\"%s\\\"\"),", "        resource->filename);", "    fclose(fd_resource);"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["  if (prt_resfile_strncmp(offset, PRT_RESOURCE_HEADER,", "          (int)STRLEN(PRT_RESOURCE_HEADER)) != 0) {", "    EMSG2(_(\"E618: file \\\"%s\\\" is not a PostScript resource file\"),"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["  if (prt_resfile_strncmp(offset, PRT_RESOURCE_RESOURCE,", "          (int)STRLEN(PRT_RESOURCE_RESOURCE)) != 0) {", "    EMSG2(_(\"E619: file \\\"%s\\\" is not a supported PostScript resource file\"),"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["  vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),", "      \"%%%%%s\\n\", comment);", "  prt_write_file(prt_line_buffer);"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["  vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),", "      \"%%%%%s: %s\\n\", comment, text);", "  prt_write_file(prt_line_buffer);"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["  vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),", "      \"%%%%%s: (%s)\\n\", comment, text);", "  prt_write_file(prt_line_buffer);"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["  vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),", "      \"%%%%%s:\", comment);", "  prt_write_file(prt_line_buffer);"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["  for (i = 0; i < count; i++) {", "    sprintf((char *)prt_line_buffer, \" %d\", ints[i]);", "    prt_write_file(prt_line_buffer);"], "runtime/printf"]
["src/nvim/hardcopy.c", ["{", "  if (comment != NULL)", "    vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),"], "readability/braces"]
["src/nvim/hardcopy.c", ["    vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),", "        \"%%%%%s: %s\", comment, type);", "  else"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["        \"%%%%%s: %s\", comment, type);", "  else", "    vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),"], "readability/braces"]
["src/nvim/hardcopy.c", ["    vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),", "        \"%%%%+ %s\", type);", "  prt_write_file(prt_line_buffer);"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["  vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),", "      \" %s\\n\", string);", "  prt_write_file(prt_line_buffer);"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["  prt_dsc_resources(resource, \"font\",", "      ps_font->ps_fontname[PRT_PS_FONT_ROMAN]);", "  for (i = PRT_PS_FONT_BOLD; i <= PRT_PS_FONT_BOLDOBLIQUE; i++)"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["      ps_font->ps_fontname[PRT_PS_FONT_ROMAN]);", "  for (i = PRT_PS_FONT_BOLD; i <= PRT_PS_FONT_BOLDOBLIQUE; i++)", "    if (ps_font->ps_fontname[i] != NULL)"], "readability/braces"]
["src/nvim/hardcopy.c", ["  for (i = PRT_PS_FONT_BOLD; i <= PRT_PS_FONT_BOLDOBLIQUE; i++)", "    if (ps_font->ps_fontname[i] != NULL)", "      prt_dsc_resources(NULL, \"font\", ps_font->ps_fontname[i]);"], "readability/braces"]
["src/nvim/hardcopy.c", ["", "static void prt_dsc_requirements(int duplex, int tumble, int collate, int color, int num_copies)", "{"], "whitespace/line_length"]
["src/nvim/hardcopy.c", ["{", "  /* Only output the comment if we need to.", "   * Note: tumble is ignored if we are not duplexing"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["   */", "  if (!(duplex || collate || color || (num_copies > 1)))", "    return;"], "readability/braces"]
["src/nvim/hardcopy.c", ["", "  sprintf((char *)prt_line_buffer, \"%%%%Requirements:\");", "  prt_write_file(prt_line_buffer);"], "runtime/printf"]
["src/nvim/hardcopy.c", ["    prt_write_string(\" duplex\");", "    if (tumble)", "      prt_write_string(\"(tumble)\");"], "readability/braces"]
["src/nvim/hardcopy.c", ["  }", "  if (collate)", "    prt_write_string(\" collate\");"], "readability/braces"]
["src/nvim/hardcopy.c", ["    prt_write_string(\" collate\");", "  if (color)", "    prt_write_string(\" color\");"], "readability/braces"]
["src/nvim/hardcopy.c", ["", "static void prt_dsc_docmedia(char *paper_name, double width, double height, double weight, char *colour, char *type)", "{"], "whitespace/line_length"]
["src/nvim/hardcopy.c", ["  vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),", "      \"%%%%DocumentMedia: %s \", paper_name);", "  prt_write_file(prt_line_buffer);"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["  prt_write_real(weight, 2);", "  if (colour == NULL)", "    prt_write_string(\"()\");"], "readability/braces"]
["src/nvim/hardcopy.c", ["    prt_write_string(\"()\");", "  else", "    prt_write_string(colour);"], "readability/braces"]
["src/nvim/hardcopy.c", ["  prt_write_string(\" \");", "  if (type == NULL)", "    prt_write_string(\"()\");"], "readability/braces"]
["src/nvim/hardcopy.c", ["    prt_write_string(\"()\");", "  else", "    prt_write_string(type);"], "readability/braces"]
["src/nvim/hardcopy.c", ["", "    /* Free off all CID font names created, but first clear duplicate", "     * pointers to the same string (when the same font is used for more than"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["    for (i = PRT_PS_FONT_ROMAN; i <= PRT_PS_FONT_BOLDOBLIQUE; i++) {", "      if (prt_ps_mb_font.ps_fontname[i] != NULL)", "        xfree(prt_ps_mb_font.ps_fontname[i]);"], "readability/braces"]
["src/nvim/hardcopy.c", ["    convert_setup(&prt_conv, NULL, NULL);", "    prt_do_conv = FALSE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["    prt_ps_fd = NULL;", "    prt_file_error = FALSE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["", "/*", " * Calculate margins for given width and height from printoptions settings."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", [" */", "static void prt_page_margins(double width, double height, double *left, double *right, double *top, double *bottom)", "{"], "whitespace/line_length"]
["src/nvim/hardcopy.c", ["    prt_number_width = PRINT_NUMBER_WIDTH * prt_char_width;", "    /* If we are outputting multi-byte characters then line numbers will be", "     * printed with half width characters"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["     */", "    if (prt_out_mbyte)", "      prt_number_width /= 2;"], "readability/braces"]
["src/nvim/hardcopy.c", ["    prt_left_margin += prt_number_width;", "  } else", "    prt_number_width = 0.0;"], "readability/braces"]
["src/nvim/hardcopy.c", ["", "/*", " * Get number of lines of text that fit on a page (excluding the header)."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Calculate offset to lower left corner of background rect based on actual"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["  prt_bgcol_offset = PRT_PS_FONT_TO_USER(prt_line_height,", "      prt_ps_font->bbox_min_y);", "  if ((prt_ps_font->bbox_max_y - prt_ps_font->bbox_min_y) < 1000.0) {"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["    prt_bgcol_offset -= PRT_PS_FONT_TO_USER(prt_line_height,", "        (1000.0 - (prt_ps_font->bbox_max_y -", "                   prt_ps_font->bbox_min_y)) / 2);"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["", "static int prt_match_encoding(char *p_encoding, struct prt_ps_mbfont_S *p_cmap, struct prt_ps_encoding_S **pp_mbenc)", "{"], "whitespace/line_length"]
["src/nvim/hardcopy.c", ["      *pp_mbenc = p_mbenc;", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/hardcopy.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/hardcopy.c", ["", "static int prt_match_charset(char *p_charset, struct prt_ps_mbfont_S *p_cmap, struct prt_ps_charset_S **pp_mbchar)", "{"], "whitespace/line_length"]
["src/nvim/hardcopy.c", ["      *pp_mbchar = p_mbchar;", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/hardcopy.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Set up font and encoding."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["  p_encoding = enc_skip(p_penc);", "  if (*p_encoding == NUL)", "    p_encoding = enc_skip(p_enc);"], "readability/braces"]
["src/nvim/hardcopy.c", ["", "  /* Look for a multi-byte font that matches the encoding and character set.", "   * Only look if multi-byte character set is defined, or using multi-byte"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["    int effective_cmap = 0;", "    for (cmap = 0; cmap < (int)ARRAY_SIZE(prt_ps_mbfonts); cmap++)", "      if (prt_match_encoding((char *)p_encoding, &prt_ps_mbfonts[cmap],"], "readability/braces"]
["src/nvim/hardcopy.c", ["        }", "        if (prt_match_charset((char *)p_pmcs, &prt_ps_mbfonts[cmap], &p_mbchar))", "          break;"], "readability/braces"]
["src/nvim/hardcopy.c", ["        EMSG(_(\"E673: Incompatible multi-byte encoding and character set.\"));", "        return FALSE;", "      }"], "readability/bool"]
["src/nvim/hardcopy.c", ["      if (*p_pmcs == NUL) {", "        EMSG(_(\"E674: printmbcharset cannot be empty with multi-byte encoding.\"));", "        return FALSE;"], "whitespace/line_length"]
["src/nvim/hardcopy.c", ["        EMSG(_(\"E674: printmbcharset cannot be empty with multi-byte encoding.\"));", "        return FALSE;", "      }"], "readability/bool"]
["src/nvim/hardcopy.c", ["      EMSG(_(\"E675: No default font specified for multi-byte printing.\"));", "      return FALSE;", "    }"], "readability/bool"]
["src/nvim/hardcopy.c", ["                             mbfont_opts[OPT_MBFONT_BOLD].strlen);", "", "    }"], "whitespace/blank_line"]
["src/nvim/hardcopy.c", ["  } else {", "    prt_use_courier = FALSE;", "    prt_ps_font = &prt_ps_courier_font;"], "readability/bool"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Find the size of the paper and set the margins."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["  }", "  for (i = 0; i < (int)PRT_MEDIASIZE_LEN; ++i)", "    if (STRLEN(prt_mediasize[i].name) == (unsigned)paper_strlen"], "readability/braces"]
["src/nvim/hardcopy.c", ["  }", "  for (i = 0; i < (int)PRT_MEDIASIZE_LEN; ++i)", "    if (STRLEN(prt_mediasize[i].name) == (unsigned)paper_strlen"], "readability/increment"]
["src/nvim/hardcopy.c", ["  for (i = 0; i < (int)PRT_MEDIASIZE_LEN; ++i)", "    if (STRLEN(prt_mediasize[i].name) == (unsigned)paper_strlen", "        && STRNICMP(prt_mediasize[i].name, paper_name,"], "readability/braces"]
["src/nvim/hardcopy.c", ["        && STRNICMP(prt_mediasize[i].name, paper_name,", "            paper_strlen) == 0)", "      break;"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["        && STRNICMP(prt_mediasize[i].name, paper_name,", "            paper_strlen) == 0)", "      break;"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["      break;", "  if (i == PRT_MEDIASIZE_LEN)", "    i = 0;"], "readability/braces"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Set PS pagesize based on media dimensions and print orientation."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["  prt_page_margins(prt_page_width, prt_page_height, &left, &right, &top,", "      &bottom);", "  prt_left_margin = left;"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Set up the font size."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["  fontsize = PRT_PS_DEFAULT_FONTSIZE;", "  for (p = p_pfn; (p = vim_strchr(p, ':')) != NULL; ++p)", "    if (p[1] == 'h' && ascii_isdigit(p[2]))"], "readability/braces"]
["src/nvim/hardcopy.c", ["  fontsize = PRT_PS_DEFAULT_FONTSIZE;", "  for (p = p_pfn; (p = vim_strchr(p, ':')) != NULL; ++p)", "    if (p[1] == 'h' && ascii_isdigit(p[2]))"], "readability/increment"]
["src/nvim/hardcopy.c", ["  for (p = p_pfn; (p = vim_strchr(p, ':')) != NULL; ++p)", "    if (p[1] == 'h' && ascii_isdigit(p[2]))", "      fontsize = atoi((char *)p + 2);"], "readability/braces"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Return the number of characters per line, and lines per page for the"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Sort out the number of copies to be printed.  PS by default will do"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Set up printer duplex and tumble based on Duplex option setting - default"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["   */", "  prt_duplex = TRUE;", "  prt_tumble = FALSE;"], "readability/bool"]
["src/nvim/hardcopy.c", ["  prt_duplex = TRUE;", "  prt_tumble = FALSE;", "  psettings->duplex = 1;"], "readability/bool"]
["src/nvim/hardcopy.c", ["    if (STRNICMP(printer_opts[OPT_PRINT_DUPLEX].string, \"off\", 3) == 0) {", "      prt_duplex = FALSE;", "      psettings->duplex = 0;"], "readability/bool"]
["src/nvim/hardcopy.c", ["      psettings->duplex = 0;", "    } else if (STRNICMP(printer_opts[OPT_PRINT_DUPLEX].string, \"short\", 5)", "               == 0)"], "readability/braces"]
["src/nvim/hardcopy.c", ["               == 0)", "      prt_tumble = TRUE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["  prt_bufsiz = psettings->chars_per_line;", "  if (prt_out_mbyte)", "    prt_bufsiz *= 2;"], "readability/braces"]
["src/nvim/hardcopy.c", ["", "  prt_file_error = FALSE;", ""], "readability/bool"]
["src/nvim/hardcopy.c", ["{", "  FILE*       fd_resource;", "  char_u resource_buffer[512];"], "whitespace/operators"]
["src/nvim/hardcopy.c", ["    EMSG2(_(\"E456: Can't open file \\\"%s\\\"\"), resource->filename);", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["  prt_dsc_resources(\"BeginResource\", prt_resource_types[resource->type],", "      (char *)resource->title);", ""], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["    bytes_read = fread((char *)resource_buffer, sizeof(char_u),", "        sizeof(resource_buffer), fd_resource);", "    if (ferror(fd_resource)) {"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["      EMSG2(_(\"E457: Can't read PostScript resource file \\\"%s\\\"\"),", "          resource->filename);", "      fclose(fd_resource);"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["      fclose(fd_resource);", "      return FALSE;", "    }"], "readability/bool"]
["src/nvim/hardcopy.c", ["    }", "    if (bytes_read == 0)", "      break;"], "readability/braces"]
["src/nvim/hardcopy.c", ["      fclose(fd_resource);", "      return FALSE;", "    }"], "readability/bool"]
["src/nvim/hardcopy.c", ["", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/hardcopy.c", ["  struct prt_ps_resource_S res_cmap;", "  int retval = FALSE;", ""], "readability/bool"]
["src/nvim/hardcopy.c", ["", "  /*", "   * PS DSC Header comments - no PS code!"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["  p = vim_strchr((char_u *)p_time, '\\n');", "  if (p != NULL)", "    *p = NUL;"], "readability/braces"]
["src/nvim/hardcopy.c", ["  prt_dsc_textline(\"PageOrder\", \"Ascend\");", "  /* The bbox does not change with orientation - it is always in the default", "   * user coordinate system!  We have to recalculate right and bottom"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["  prt_page_margins(prt_mediasize[prt_media].width,", "      prt_mediasize[prt_media].height,", "      &left, &right, &top, &bottom);"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["      prt_mediasize[prt_media].height,", "      &left, &right, &top, &bottom);", "  bbox[0] = (int)left;"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["  if (prt_portrait) {", "    /* In portrait printing the fixed point is the top left corner so we", "     * derive the bbox from that point.  We have the expected cpl chars"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["  } else {", "    /* In landscape printing the fixed point is the bottom left corner so we", "     * derive the bbox from that point.  We have lpp chars across the media"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["                           : \"DocumentNeededResources\"), &prt_ps_mb_font);", "    if (!prt_custom_cmap)", "      prt_dsc_resources(NULL, \"cmap\", prt_cmap);"], "readability/braces"]
["src/nvim/hardcopy.c", ["    EMSG(_(\"E456: Can't find PostScript resource file \\\"prolog.ps\\\"\"));", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["  }", "  if (!prt_open_resource(&res_prolog))", "    return FALSE;"], "readability/braces"]
["src/nvim/hardcopy.c", ["  if (!prt_open_resource(&res_prolog))", "    return FALSE;", "  if (!prt_check_resource(&res_prolog, PRT_PROLOG_VERSION))"], "readability/bool"]
["src/nvim/hardcopy.c", ["    return FALSE;", "  if (!prt_check_resource(&res_prolog, PRT_PROLOG_VERSION))", "    return FALSE;"], "readability/braces"]
["src/nvim/hardcopy.c", ["  if (!prt_check_resource(&res_prolog, PRT_PROLOG_VERSION))", "    return FALSE;", "  if (prt_out_mbyte) {"], "readability/bool"]
["src/nvim/hardcopy.c", ["      EMSG(_(\"E456: Can't find PostScript resource file \\\"cidfont.ps\\\"\"));", "      return FALSE;", "    }"], "readability/bool"]
["src/nvim/hardcopy.c", ["    }", "    if (!prt_open_resource(&res_cidfont))", "      return FALSE;"], "readability/braces"]
["src/nvim/hardcopy.c", ["    if (!prt_open_resource(&res_cidfont))", "      return FALSE;", "    if (!prt_check_resource(&res_cidfont, PRT_CID_PROLOG_VERSION))"], "readability/bool"]
["src/nvim/hardcopy.c", ["      return FALSE;", "    if (!prt_check_resource(&res_cidfont, PRT_CID_PROLOG_VERSION))", "      return FALSE;"], "readability/braces"]
["src/nvim/hardcopy.c", ["    if (!prt_check_resource(&res_cidfont, PRT_CID_PROLOG_VERSION))", "      return FALSE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["", "  /* Find an encoding to use for printing.", "   * Check 'printencoding'. If not set or not found, then use 'encoding'. If"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["          EMSG2(_(\"E456: Can't find PostScript resource file \\\"%s.ps\\\"\"),", "              p_encoding);", "          return FALSE;"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["              p_encoding);", "          return FALSE;", "        }"], "readability/bool"]
["src/nvim/hardcopy.c", ["    }", "    if (!prt_open_resource(&res_encoding))", "      return FALSE;"], "readability/braces"]
["src/nvim/hardcopy.c", ["    if (!prt_open_resource(&res_encoding))", "      return FALSE;", "    /* For the moment there are no checks on encoding resource files to"], "readability/bool"]
["src/nvim/hardcopy.c", ["      return FALSE;", "    /* For the moment there are no checks on encoding resource files to", "     * perform */"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["    p_encoding = enc_skip(p_penc);", "    if (*p_encoding == NUL)", "      p_encoding = enc_skip(p_enc);"], "readability/braces"]
["src/nvim/hardcopy.c", ["        EMSG2(_(\"E456: Can't find PostScript resource file \\\"%s.ps\\\"\"),", "            prt_ascii_encoding);", "        return FALSE;"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["            prt_ascii_encoding);", "        return FALSE;", "      }"], "readability/bool"]
["src/nvim/hardcopy.c", ["      }", "      if (!prt_open_resource(&res_encoding))", "        return FALSE;"], "readability/braces"]
["src/nvim/hardcopy.c", ["      if (!prt_open_resource(&res_encoding))", "        return FALSE;", "      /* For the moment there are no checks on encoding resource files to"], "readability/bool"]
["src/nvim/hardcopy.c", ["        return FALSE;", "      /* For the moment there are no checks on encoding resource files to", "       * perform */"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["      EMSG2(_(\"E456: Can't find PostScript resource file \\\"%s.ps\\\"\"),", "          prt_cmap);", "      return FALSE;"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["          prt_cmap);", "      return FALSE;", "    }"], "readability/bool"]
["src/nvim/hardcopy.c", ["    }", "    if (!prt_open_resource(&res_cmap))", "      return FALSE;"], "readability/braces"]
["src/nvim/hardcopy.c", ["    if (!prt_open_resource(&res_cmap))", "      return FALSE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["  prt_dsc_requirements(prt_duplex, prt_tumble, prt_collate,", "      psettings->do_syntax", "      , prt_num_copies);"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["      psettings->do_syntax", "      , prt_num_copies);", "  prt_dsc_noarg(\"EndComments\");"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["", "  /*", "   * PS Document page defaults"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["    prt_dsc_font_resource((prt_use_courier ? NULL : \"PageResources\"),", "        &prt_ps_mb_font);", "    if (!prt_custom_cmap)"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["        &prt_ps_mb_font);", "    if (!prt_custom_cmap)", "      prt_dsc_resources(NULL, \"cmap\", prt_cmap);"], "readability/braces"]
["src/nvim/hardcopy.c", ["", "  /*", "   * PS Document prolog inclusion - all required procsets."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "  if (!prt_out_mbyte || prt_use_courier)", "    /* There will be only one Roman font encoding to be included in the PS"], "readability/braces"]
["src/nvim/hardcopy.c", ["  if (!prt_out_mbyte || prt_use_courier)", "    /* There will be only one Roman font encoding to be included in the PS", "     * file. */"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["     * file. */", "    if (!prt_add_resource(&res_encoding))", "      return FALSE;"], "readability/braces"]
["src/nvim/hardcopy.c", ["    if (!prt_add_resource(&res_encoding))", "      return FALSE;", ""], "readability/bool"]
["src/nvim/hardcopy.c", ["", "  /*", "   * PS Document setup - must appear after the prolog"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["  if (!prt_out_mbyte || prt_use_courier) {", "    /* When using Courier for ASCII range when printing multi-byte, need to", "     * pick up ASCII encoding to use with it. */"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["     * pick up ASCII encoding to use with it. */", "    if (prt_use_courier)", "      p_encoding = (char_u *)prt_ascii_encoding;"], "readability/braces"]
["src/nvim/hardcopy.c", ["    prt_dsc_resources(\"IncludeResource\", \"font\",", "        prt_ps_courier_font.ps_fontname[PRT_PS_FONT_ROMAN]);", "    prt_def_font(\"F0\", (char *)p_encoding, (int)prt_line_height,"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["    prt_def_font(\"F0\", (char *)p_encoding, (int)prt_line_height,", "        prt_ps_courier_font.ps_fontname[PRT_PS_FONT_ROMAN]);", "    prt_dsc_resources(\"IncludeResource\", \"font\","], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["    prt_dsc_resources(\"IncludeResource\", \"font\",", "        prt_ps_courier_font.ps_fontname[PRT_PS_FONT_BOLD]);", "    prt_def_font(\"F1\", (char *)p_encoding, (int)prt_line_height,"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["    prt_def_font(\"F1\", (char *)p_encoding, (int)prt_line_height,", "        prt_ps_courier_font.ps_fontname[PRT_PS_FONT_BOLD]);", "    prt_dsc_resources(\"IncludeResource\", \"font\","], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["    prt_dsc_resources(\"IncludeResource\", \"font\",", "        prt_ps_courier_font.ps_fontname[PRT_PS_FONT_OBLIQUE]);", "    prt_def_font(\"F2\", (char *)p_encoding, (int)prt_line_height,"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["    prt_def_font(\"F2\", (char *)p_encoding, (int)prt_line_height,", "        prt_ps_courier_font.ps_fontname[PRT_PS_FONT_OBLIQUE]);", "    prt_dsc_resources(\"IncludeResource\", \"font\","], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["    prt_dsc_resources(\"IncludeResource\", \"font\",", "        prt_ps_courier_font.ps_fontname[PRT_PS_FONT_BOLDOBLIQUE]);", "    prt_def_font(\"F3\", (char *)p_encoding, (int)prt_line_height,"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["    prt_def_font(\"F3\", (char *)p_encoding, (int)prt_line_height,", "        prt_ps_courier_font.ps_fontname[PRT_PS_FONT_BOLDOBLIQUE]);", "  }"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["  if (prt_out_mbyte) {", "    /* Define the CID fonts to be used in the job.\tTypically CJKV fonts do", "     * not have an italic form being a western style, so where no font is"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["    prt_dsc_resources(\"IncludeResource\", \"font\",", "        prt_ps_mb_font.ps_fontname[PRT_PS_FONT_ROMAN]);", "    if (!prt_custom_cmap)"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["        prt_ps_mb_font.ps_fontname[PRT_PS_FONT_ROMAN]);", "    if (!prt_custom_cmap)", "      prt_dsc_resources(\"IncludeResource\", \"cmap\", prt_cmap);"], "readability/braces"]
["src/nvim/hardcopy.c", ["    prt_def_cidfont(\"CF0\", (int)prt_line_height,", "        prt_ps_mb_font.ps_fontname[PRT_PS_FONT_ROMAN]);", ""], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["      prt_dsc_resources(\"IncludeResource\", \"font\",", "          prt_ps_mb_font.ps_fontname[PRT_PS_FONT_BOLD]);", "      if (!prt_custom_cmap)"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["          prt_ps_mb_font.ps_fontname[PRT_PS_FONT_BOLD]);", "      if (!prt_custom_cmap)", "        prt_dsc_resources(\"IncludeResource\", \"cmap\", prt_cmap);"], "readability/braces"]
["src/nvim/hardcopy.c", ["      prt_dsc_resources(\"IncludeResource\", \"font\",", "          prt_ps_mb_font.ps_fontname[PRT_PS_FONT_OBLIQUE]);", "      if (!prt_custom_cmap)"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["          prt_ps_mb_font.ps_fontname[PRT_PS_FONT_OBLIQUE]);", "      if (!prt_custom_cmap)", "        prt_dsc_resources(\"IncludeResource\", \"cmap\", prt_cmap);"], "readability/braces"]
["src/nvim/hardcopy.c", ["      prt_dsc_resources(\"IncludeResource\", \"font\",", "          prt_ps_mb_font.ps_fontname[PRT_PS_FONT_BOLDOBLIQUE]);", "      if (!prt_custom_cmap)"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["          prt_ps_mb_font.ps_fontname[PRT_PS_FONT_BOLDOBLIQUE]);", "      if (!prt_custom_cmap)", "        prt_dsc_resources(\"IncludeResource\", \"cmap\", prt_cmap);"], "readability/braces"]
["src/nvim/hardcopy.c", ["  prt_def_var(\"UO\", PRT_PS_FONT_TO_USER(prt_line_height,", "          prt_ps_font->uline_offset), 2);", "  prt_def_var(\"UW\", PRT_PS_FONT_TO_USER(prt_line_height,"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["  prt_def_var(\"UW\", PRT_PS_FONT_TO_USER(prt_line_height,", "          prt_ps_font->uline_width), 2);", "  prt_def_var(\"BO\", prt_bgcol_offset, 2);"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Output any info we don't know in toto until we finish"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "  /* Write CTRL-D to close serial communication link if used.", "   * NOTHING MUST BE WRITTEN AFTER THIS! */"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["    // Not printing to a file: use 'printexpr' to print the file.", "    if (eval_printexpr((char *) prt_ps_file_name, (char *) psettings->arguments)", "        == FAIL) {"], "whitespace/cast"]
["src/nvim/hardcopy.c", ["  prt_in_ascii = !prt_out_mbyte;", "  if (prt_out_mbyte)", "    prt_write_string(\"CF0 sf\\n\");"], "readability/braces"]
["src/nvim/hardcopy.c", ["    prt_write_string(\"CF0 sf\\n\");", "  else", "    prt_write_string(\"F0 sf\\n\");"], "readability/braces"]
["src/nvim/hardcopy.c", ["{", "  return mch_print_begin_page(NULL) ? (mch_print_end_page()) : FALSE;", "}"], "readability/bool"]
["src/nvim/hardcopy.c", ["", "  /* Ideally VIM would create a rearranged CID font to combine a Roman and", "   * CJKV font to do what VIM is doing here - use a Roman font for characters"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "  /* Output any required changes to the graphics state, after flushing any", "   * text buffered so far."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["      prt_write_real(r / 255.0, 3);", "      if (r == g && g == b)", "        prt_write_string(\"g\\n\");"], "readability/braces"]
["src/nvim/hardcopy.c", ["        prt_write_string(\"g\\n\");", "      else {", "        prt_write_real(g / 255.0, 3);"], "readability/braces"]
["src/nvim/hardcopy.c", ["        prt_write_string(\"g\\n\");", "      else {", "        prt_write_real(g / 255.0, 3);"], "readability/braces"]
["src/nvim/hardcopy.c", ["", "    if (prt_need_underline)", "      prt_do_underline = prt_underline;"], "readability/braces"]
["src/nvim/hardcopy.c", ["  } else {", "    /* Add next character to buffer of characters to output.", "     * Note: One printed character may require several PS characters to"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["    if (ch < 32 || ch == '(' || ch == ')' || ch == '\\\\') {", "      /* Convert non-printing characters to either their escape or octal", "       * sequence, ensures PS sent over a serial line does not interfere"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["      default:", "        sprintf((char *)ch_buff, \"%03o\", (unsigned int)ch);", "        ga_append(&prt_ps_buffer, (char)ch_buff[0]);"], "runtime/printf"]
["src/nvim/hardcopy.c", ["      }", "    } else", "      ga_append(&prt_ps_buffer, (char)ch);"], "readability/braces"]
["src/nvim/hardcopy.c", ["", "  if (iBold)", "    font |= 0x01;"], "readability/braces"]
["src/nvim/hardcopy.c", ["    font |= 0x01;", "  if (iItalic)", "    font |= 0x02;"], "readability/braces"]
["src/nvim/hardcopy.h", ["", "/*", " * Structure to hold printing color and font attributes."], "readability/old_style_comment"]
["src/nvim/hardcopy.h", ["", "/*", " * Structure passed back to the generic printer code."], "readability/old_style_comment"]
["src/nvim/hardcopy.h", ["", "/*", " * Generic option table item, only used for printer at the moment."], "readability/old_style_comment"]
["src/nvim/hardcopy.h", ["  int number;", "  char_u      *string;          /* points into option string */", "  int strlen;"], "readability/old_style_comment"]
["src/nvim/hardcopy.h", ["", "/* For prt_get_unit(). */", "#define PRT_UNIT_NONE  -1"], "readability/old_style_comment"]
["src/nvim/hardcopy.h", ["#define PRT_UNIT_POINT 3", "#define PRT_UNIT_NAMES {\"pc\", \"in\", \"mm\", \"pt\"}", ""], "whitespace/braces"]
["src/nvim/hardcopy.h", ["#define PRT_UNIT_POINT 3", "#define PRT_UNIT_NAMES {\"pc\", \"in\", \"mm\", \"pt\"}", ""], "whitespace/braces"]
["src/nvim/hashtab.c", ["  size_t todo = ht->ht_used;", "  for (hashitem_T *hi = ht->ht_array; todo > 0; ++hi) {", "    if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/hashtab.c", ["", "  for (hashitem_T *olditem = oldarray; todo > 0; ++olditem) {", "    if (HASHITEM_EMPTY(olditem)) {"], "readability/increment"]
["src/nvim/if_cscope.c", ["", "/*", " * CSCOPE support for Vim added by Andy Kahn <kahn@zk3.dec.com>"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["", "#include <sys/types.h>", "#include <sys/stat.h>"], "build/include_order"]
["src/nvim/if_cscope.c", ["#include <sys/types.h>", "#include <sys/stat.h>", "#if defined(UNIX)"], "build/include_order"]
["src/nvim/if_cscope.c", ["#if defined(UNIX)", "# include <sys/wait.h>", "#endif"], "build/include_order"]
["src/nvim/if_cscope.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the cscope command"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["    int i;", "    for (i = 0, current_idx = 0; cs_cmds[i].name != NULL; i++)", "      if (cs_cmds[i].cansplit)"], "readability/braces"]
["src/nvim/if_cscope.c", ["    for (i = 0, current_idx = 0; cs_cmds[i].name != NULL; i++)", "      if (cs_cmds[i].cansplit)", "        if (current_idx++ == idx)"], "readability/braces"]
["src/nvim/if_cscope.c", ["      if (cs_cmds[i].cansplit)", "        if (current_idx++ == idx)", "          break;"], "readability/braces"]
["src/nvim/if_cscope.c", ["    const char *query_type[] =", "    {", "      \"a\", \"c\", \"d\", \"e\", \"f\", \"g\", \"i\", \"s\", \"t\", NULL"], "whitespace/braces"]
["src/nvim/if_cscope.c", ["    for (i = 0, current_idx = 0; i < csinfo_size; i++) {", "      if (csinfo[i].fname == NULL)", "        continue;"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "/*", " * Handle command line completion for :cscope command."], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["      (void)MSG_PUTS(_(", "              \"This cscope command does not support splitting the window.\\n\"));", "      return;"], "whitespace/indent"]
["src/nvim/if_cscope.c", ["{", "  do_cscope_general(eap, FALSE);", "}"], "readability/bool"]
["src/nvim/if_cscope.c", ["{", "  do_cscope_general(eap, TRUE);", "}"], "readability/bool"]
["src/nvim/if_cscope.c", ["{", "  int ret = FALSE;", ""], "readability/bool"]
["src/nvim/if_cscope.c", ["      ret = cs_find_common(\"g\", (char *)(eap->arg), eap->forceit, FALSE,", "          FALSE, *eap->cmdlinep);", "      if (ret == FALSE) {"], "whitespace/alignment"]
["src/nvim/if_cscope.c", ["    if (cs_check_for_connections()) {", "      ret = cs_find_common(\"g\", (char *)(eap->arg), eap->forceit, FALSE,", "          FALSE, *eap->cmdlinep);"], "readability/bool"]
["src/nvim/if_cscope.c", ["      ret = cs_find_common(\"g\", (char *)(eap->arg), eap->forceit, FALSE,", "          FALSE, *eap->cmdlinep);", "      if (ret == FALSE) {"], "readability/bool"]
["src/nvim/if_cscope.c", ["          FALSE, *eap->cmdlinep);", "      if (ret == FALSE) {", "        cs_free_tags();"], "readability/bool"]
["src/nvim/if_cscope.c", ["        cs_free_tags();", "        if (msg_col)", "          msg_putchar('\\n');"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "        if (cs_check_for_tags())", "          ret = do_tag(eap->arg, DT_JUMP, 0, eap->forceit, FALSE);"], "readability/braces"]
["src/nvim/if_cscope.c", ["        if (cs_check_for_tags())", "          ret = do_tag(eap->arg, DT_JUMP, 0, eap->forceit, FALSE);", "      }"], "readability/bool"]
["src/nvim/if_cscope.c", ["    } else if (cs_check_for_tags()) {", "      ret = do_tag(eap->arg, DT_JUMP, 0, eap->forceit, FALSE);", "    }"], "readability/bool"]
["src/nvim/if_cscope.c", ["    if (cs_check_for_tags()) {", "      ret = do_tag(eap->arg, DT_JUMP, 0, eap->forceit, FALSE);", "      if (ret == FALSE) {"], "readability/bool"]
["src/nvim/if_cscope.c", ["      ret = do_tag(eap->arg, DT_JUMP, 0, eap->forceit, FALSE);", "      if (ret == FALSE) {", "        if (msg_col)"], "readability/bool"]
["src/nvim/if_cscope.c", ["      if (ret == FALSE) {", "        if (msg_col)", "          msg_putchar('\\n');"], "readability/braces"]
["src/nvim/if_cscope.c", ["          ret = cs_find_common(\"g\", (char *)(eap->arg), eap->forceit,", "              FALSE, FALSE, *eap->cmdlinep);", "          if (ret == FALSE)"], "whitespace/alignment"]
["src/nvim/if_cscope.c", ["          ret = cs_find_common(\"g\", (char *)(eap->arg), eap->forceit,", "              FALSE, FALSE, *eap->cmdlinep);", "          if (ret == FALSE)"], "readability/bool"]
["src/nvim/if_cscope.c", ["              FALSE, FALSE, *eap->cmdlinep);", "          if (ret == FALSE)", "            cs_free_tags();"], "readability/braces"]
["src/nvim/if_cscope.c", ["              FALSE, FALSE, *eap->cmdlinep);", "          if (ret == FALSE)", "            cs_free_tags();"], "readability/bool"]
["src/nvim/if_cscope.c", ["      ret = cs_find_common(\"g\", (char *)(eap->arg), eap->forceit, FALSE,", "          FALSE, *eap->cmdlinep);", "      if (ret == FALSE)"], "whitespace/alignment"]
["src/nvim/if_cscope.c", ["    } else if (cs_check_for_connections()) {", "      ret = cs_find_common(\"g\", (char *)(eap->arg), eap->forceit, FALSE,", "          FALSE, *eap->cmdlinep);"], "readability/bool"]
["src/nvim/if_cscope.c", ["      ret = cs_find_common(\"g\", (char *)(eap->arg), eap->forceit, FALSE,", "          FALSE, *eap->cmdlinep);", "      if (ret == FALSE)"], "readability/bool"]
["src/nvim/if_cscope.c", ["          FALSE, *eap->cmdlinep);", "      if (ret == FALSE)", "        cs_free_tags();"], "readability/braces"]
["src/nvim/if_cscope.c", ["          FALSE, *eap->cmdlinep);", "      if (ret == FALSE)", "        cs_free_tags();"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "/*", " * \"cscope_connection([{num} , {dbpath} [, {prepend}]])\" function"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["", "/*", " * PRIVATE functions"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["", "  if ((fname = strtok((char *)NULL, (const char *)\" \")) == NULL) {", "    cs_usage_msg(Add);"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["  }", "  if ((ppath = strtok((char *)NULL, (const char *)\" \")) != NULL)", "    flags = strtok((char *)NULL, (const char *)\" \");"], "readability/braces"]
["src/nvim/if_cscope.c", ["  }", "  if ((ppath = strtok((char *)NULL, (const char *)\" \")) != NULL)", "    flags = strtok((char *)NULL, (const char *)\" \");"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["  if ((ppath = strtok((char *)NULL, (const char *)\" \")) != NULL)", "    flags = strtok((char *)NULL, (const char *)\" \");", ""], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["", "  (void)sprintf(buf, stat_emsg, fname, errno);", "  (void)EMSG(buf);"], "runtime/printf"]
["src/nvim/if_cscope.c", ["staterr:", "    if (p_csverbose)", "      cs_stat_emsg(fname);"], "readability/braces"]
["src/nvim/if_cscope.c", ["      fname[strlen(fname)-1] = '\\0';", "      if (fname[0] == '\\0')", "        break;"], "readability/braces"]
["src/nvim/if_cscope.c", ["    }", "    if (fname[0] == '\\0')", "      (void)sprintf(fname2, \"/%s\", CSCOPE_DBFILE);"], "readability/braces"]
["src/nvim/if_cscope.c", ["    if (fname[0] == '\\0')", "      (void)sprintf(fname2, \"/%s\", CSCOPE_DBFILE);", "    else"], "runtime/printf"]
["src/nvim/if_cscope.c", ["      (void)sprintf(fname2, \"/%s\", CSCOPE_DBFILE);", "    else", "      (void)sprintf(fname2, \"%s/%s\", fname, CSCOPE_DBFILE);"], "readability/braces"]
["src/nvim/if_cscope.c", ["    else", "      (void)sprintf(fname2, \"%s/%s\", fname, CSCOPE_DBFILE);", ""], "runtime/printf"]
["src/nvim/if_cscope.c", ["    if (!file_info_ok) {", "      if (p_csverbose)", "        cs_stat_emsg(fname2);"], "readability/braces"]
["src/nvim/if_cscope.c", ["  }", "  else if (S_ISREG(file_info.stat.st_mode) || S_ISLNK(file_info.stat.st_mode))", "  {"], "whitespace/newline"]
["src/nvim/if_cscope.c", ["  else if (S_ISREG(file_info.stat.st_mode) || S_ISLNK(file_info.stat.st_mode))", "  {", "    i = cs_insert_filelist(fname, ppath, flags, &file_info);"], "whitespace/braces"]
["src/nvim/if_cscope.c", ["  } else {", "    if (p_csverbose)", "      (void)EMSG2("], "readability/braces"]
["src/nvim/if_cscope.c", ["  for (size_t i = 0; i < csinfo_size; i++) {", "    if (csinfo[i].fname != NULL)", "      cnt++;"], "readability/braces"]
["src/nvim/if_cscope.c", ["    }", "    if ((stok = strtok(buf, (const char *)\" \")) == NULL) {", "      continue;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["", "    if ((stok = strtok(NULL, (const char *)\" \")) == NULL)", "      continue;"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "    if ((stok = strtok(NULL, (const char *)\" \")) == NULL)", "      continue;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["", "    if ((stok = strtok(NULL, (const char *)\" \")) == NULL)", "      continue;"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "    if ((stok = strtok(NULL, (const char *)\" \")) == NULL)", "      continue;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["      continue;", "    if (strncmp((const char *)stok, \"lines\", 5))", "      continue;"], "readability/braces"]
["src/nvim/if_cscope.c", ["  char *cmd;", "  short search;", "  char *pat;"], "runtime/int"]
["src/nvim/if_cscope.c", ["  pat = pattern;", "  if (search != 4 && search != 6)", "    while (ascii_iswhite(*pat))"], "readability/braces"]
["src/nvim/if_cscope.c", ["  if (search != 4 && search != 6)", "    while (ascii_iswhite(*pat))", "      ++pat;"], "readability/braces"]
["src/nvim/if_cscope.c", ["    while (ascii_iswhite(*pat))", "      ++pat;", ""], "readability/increment"]
["src/nvim/if_cscope.c", ["", "  (void)sprintf(cmd, \"%d%s\", search, pat);", ""], "runtime/printf"]
["src/nvim/if_cscope.c", ["#if defined(UNIX)", "  /*", "   * Cscope reads from to_cs[0] and writes to from_cs[1]; vi reads from"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["err_closing:", "    if (to_cs[0] != -1)", "      (void)close(to_cs[0]);"], "readability/braces"]
["src/nvim/if_cscope.c", ["      (void)close(to_cs[0]);", "    if (to_cs[1] != -1)", "      (void)close(to_cs[1]);"], "readability/braces"]
["src/nvim/if_cscope.c", ["      (void)close(to_cs[1]);", "    if (from_cs[0] != -1)", "      (void)close(from_cs[0]);"], "readability/braces"]
["src/nvim/if_cscope.c", ["      (void)close(from_cs[0]);", "    if (from_cs[1] != -1)", "      (void)close(from_cs[1]);"], "readability/braces"]
["src/nvim/if_cscope.c", ["  sa.nLength = sizeof(SECURITY_ATTRIBUTES);", "  sa.bInheritHandle = TRUE;", "  sa.lpSecurityDescriptor = NULL;"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "    if (csinfo[i].flags)", "      len += strlen(csinfo[i].flags);"], "readability/braces"]
["src/nvim/if_cscope.c", ["    if (csinfo[i].ppath != NULL) {", "      (void)strcat(cmd, \" -P\");", "      (void)strcat(cmd, csinfo[i].ppath);"], "runtime/printf"]
["src/nvim/if_cscope.c", ["      (void)strcat(cmd, \" -P\");", "      (void)strcat(cmd, csinfo[i].ppath);", "    }"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    if (csinfo[i].flags != NULL) {", "      (void)strcat(cmd, \" \");", "      (void)strcat(cmd, csinfo[i].flags);"], "runtime/printf"]
["src/nvim/if_cscope.c", ["      (void)strcat(cmd, \" \");", "      (void)strcat(cmd, csinfo[i].flags);", "    }"], "runtime/printf"]
["src/nvim/if_cscope.c", ["#  else", "    if (setpgid(0, 0) == -1)", "      PERROR(_(\"cs_create_connection setpgid failed\"));"], "readability/braces"]
["src/nvim/if_cscope.c", ["# endif", "    if (execl(\"/bin/sh\", \"sh\", \"-c\", cmd, (char *)NULL) == -1)", "      PERROR(_(\"cs_create_connection exec failed\"));"], "readability/braces"]
["src/nvim/if_cscope.c", ["    created = CreateProcess(NULL, cmd, NULL, NULL, TRUE, CREATE_NEW_CONSOLE,", "        NULL, NULL, &si, &pi);", "    xfree(prog);"], "whitespace/alignment"]
["src/nvim/if_cscope.c", ["    si.hStdInput  = stdin_rd;", "    created = CreateProcess(NULL, cmd, NULL, NULL, TRUE, CREATE_NEW_CONSOLE,", "        NULL, NULL, &si, &pi);"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "  if (cs_check_for_connections() == FALSE) {", "    (void)EMSG(_(\"E567: no cscope connections\"));"], "readability/bool"]
["src/nvim/if_cscope.c", ["    (void)EMSG(_(\"E567: no cscope connections\"));", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "  if ((opt = strtok((char *)NULL, (const char *)\" \")) == NULL) {", "    cs_usage_msg(Find);"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["    cs_usage_msg(Find);", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/if_cscope.c", ["    cs_usage_msg(Find);", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "  /*", "   * Let's replace the NULs written by strtok() with spaces - we need the"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["   */", "  for (int i = 0; i < eap_arg_len; ++i)", "    if (NUL == eap->arg[i])"], "readability/braces"]
["src/nvim/if_cscope.c", ["   */", "  for (int i = 0; i < eap_arg_len; ++i)", "    if (NUL == eap->arg[i])"], "readability/increment"]
["src/nvim/if_cscope.c", ["  for (int i = 0; i < eap_arg_len; ++i)", "    if (NUL == eap->arg[i])", "      eap->arg[i] = ' ';"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "      sprintf(buf, nf, *qfpos, *(qfpos-1));", "      (void)EMSG(buf);"], "runtime/printf"]
["src/nvim/if_cscope.c", ["      xfree(buf);", "      return FALSE;", "    }"], "readability/bool"]
["src/nvim/if_cscope.c", ["  cmd = cs_create_cmd(opt, pat);", "  if (cmd == NULL)", "    return FALSE;"], "readability/braces"]
["src/nvim/if_cscope.c", ["  if (cmd == NULL)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/if_cscope.c", ["  for (size_t i = 0; i < csinfo_size; i++) {", "    if (csinfo[i].fname == NULL || csinfo[i].to_fp == NULL)", "      continue;"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "    if (nummatches[i] > -1)", "      totmatches += (size_t)nummatches[i];"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "    if (nummatches[i] == 0)", "      (void)cs_read_prompt(i);"], "readability/braces"]
["src/nvim/if_cscope.c", ["      xfree(nummatches);", "      return FALSE;", "    }"], "readability/bool"]
["src/nvim/if_cscope.c", ["    buf = xmalloc(strlen(opt) + strlen(pat) + strlen(nf));", "    sprintf(buf, nf, opt, pat);", "    (void)EMSG(buf);"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    xfree(nummatches);", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/if_cscope.c", ["        apply_autocmds(EVENT_QUICKFIXCMDPOST, (char_u *)\"cscope\",", "            curbuf->b_fname, TRUE, curbuf);", "        if (use_ll)"], "whitespace/alignment"]
["src/nvim/if_cscope.c", ["        apply_autocmds(EVENT_QUICKFIXCMDPOST, (char_u *)\"cscope\",", "            curbuf->b_fname, TRUE, curbuf);", "        if (use_ll)"], "readability/bool"]
["src/nvim/if_cscope.c", ["            curbuf->b_fname, TRUE, curbuf);", "        if (use_ll)", "          /*"], "readability/braces"]
["src/nvim/if_cscope.c", ["        if (use_ll)", "          /*", "           * In the location list window, use the displayed location"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["    xfree(nummatches);", "    return TRUE;", "  } else {"], "readability/bool"]
["src/nvim/if_cscope.c", ["    cs_fill_results((char *)pat, totmatches, nummatches, &matches,", "        &contexts, &matched);", "    xfree(nummatches);"], "whitespace/alignment"]
["src/nvim/if_cscope.c", ["    xfree(nummatches);", "    if (matches == NULL)", "      return FALSE;"], "readability/braces"]
["src/nvim/if_cscope.c", ["    if (matches == NULL)", "      return FALSE;", ""], "readability/bool"]
["src/nvim/if_cscope.c", ["    (void)smsg(_(\"%-5s: %s%*s (Usage: %s)\"),", "        cmdp->name,", "        help, space_cnt, \" \","], "whitespace/alignment"]
["src/nvim/if_cscope.c", ["        cmdp->name,", "        help, space_cnt, \" \",", "        cmdp->usage);"], "whitespace/alignment"]
["src/nvim/if_cscope.c", ["        help, space_cnt, \" \",", "        cmdp->usage);", "    if (strcmp(cmdp->name, \"find\") == 0)"], "whitespace/alignment"]
["src/nvim/if_cscope.c", ["        cmdp->usage);", "    if (strcmp(cmdp->name, \"find\") == 0)", "      MSG_PUTS(_(\"\\n\""], "readability/braces"]
["src/nvim/if_cscope.c", ["", "  wait_return(TRUE);", "  return CSCOPE_SUCCESS;"], "readability/bool"]
["src/nvim/if_cscope.c", ["        && os_fileid_equal_fileinfo(&(csinfo[j].file_id), file_info)) {", "      if (p_csverbose)", "        (void)EMSG(_(\"E568: duplicate cscope database not added\"));"], "readability/braces"]
["src/nvim/if_cscope.c", ["      csinfo_size *= 2;", "      csinfo = xrealloc(csinfo, sizeof(csinfo_T)*csinfo_size);", "    }"], "whitespace/operators"]
["src/nvim/if_cscope.c", ["    }", "    for (size_t j = csinfo_size/2; j < csinfo_size; j++)", "      clear_csinfo(j);"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "  (void)strcpy(csinfo[i].fname, (const char *)fname);", ""], "runtime/printf"]
["src/nvim/if_cscope.c", ["    csinfo[i].ppath = xmalloc(strlen(ppath) + 1);", "    (void)strcpy(csinfo[i].ppath, (const char *)ppath);", "  } else"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    (void)strcpy(csinfo[i].ppath, (const char *)ppath);", "  } else", "    csinfo[i].ppath = NULL;"], "readability/braces"]
["src/nvim/if_cscope.c", ["    csinfo[i].flags = xmalloc(strlen(flags) + 1);", "    (void)strcpy(csinfo[i].flags, (const char *)flags);", "  } else"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    (void)strcpy(csinfo[i].flags, (const char *)flags);", "  } else", "    csinfo[i].flags = NULL;"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "  if (eap->arg == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "  if ((stok = strtok((char *)(eap->arg), (const char *)\" \")) == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "  if ((stok = strtok((char *)(eap->arg), (const char *)\" \")) == NULL)", "    return NULL;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["  len = strlen(stok);", "  for (cmdp = cs_cmds; cmdp->name != NULL; ++cmdp) {", "    if (strncmp((const char *)(stok), cmdp->name, len) == 0)"], "readability/increment"]
["src/nvim/if_cscope.c", ["  for (cmdp = cs_cmds; cmdp->name != NULL; ++cmdp) {", "    if (strncmp((const char *)(stok), cmdp->name, len) == 0)", "      return cmdp;"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "  if ((stok = strtok((char *)NULL, (const char *)\" \")) == NULL) {", "    cs_usage_msg(Kill);"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["    num = atoi(stok);", "    if (num == -1)", "      killall = true;"], "readability/braces"]
["src/nvim/if_cscope.c", ["      killall = true;", "    else if (num >= 0) {", "      i = (size_t)num;"], "readability/braces"]
["src/nvim/if_cscope.c", ["    } else {      // All negative values besides -1 are invalid.", "      if (p_csverbose)", "        (void)EMSG2(_(\"E261: cscope connection %s not found\"), stok);"], "readability/braces"]
["src/nvim/if_cscope.c", ["    for (i = 0; i < csinfo_size; i++) {", "      if (csinfo[i].fname != NULL && strstr(csinfo[i].fname, stok))", "        break;"], "readability/braces"]
["src/nvim/if_cscope.c", ["      for (i = 0; i < csinfo_size; i++) {", "        if (csinfo[i].fname)", "          cs_kill_execute(i, csinfo[i].fname);"], "readability/braces"]
["src/nvim/if_cscope.c", ["  }", "  cs_release_csp(i, TRUE);", "}"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "    (void)sprintf(buf, \"%s\\t%s\\t%s;\\\"\\t%s\", tagstr, fname, slno, search);", "  } else {"], "runtime/printf"]
["src/nvim/if_cscope.c", ["", "    (void)sprintf(buf, \"%s\\t%s\\t%s;\\\"\", tagstr, fname, slno);", "  }"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    assert(totmatches > 0);", "    if (mp != NULL || cp != NULL)", "      (void)cs_manage_matches(NULL, NULL, 0, Free);"], "readability/braces"]
["src/nvim/if_cscope.c", ["  case Get:", "    if (next >= cnt)", "      return NULL;"], "readability/braces"]
["src/nvim/if_cscope.c", ["        xfree(mp[cnt]);", "        if (cp != NULL)", "          xfree(cp[cnt]);"], "readability/braces"]
["src/nvim/if_cscope.c", ["  if ((p = strchr(buf, '\\n')) == NULL) {", "    while ((ch = getc(csinfo[cnumber].fr_fp)) != EOF && ch != '\\n')", "      ;"], "readability/braces"]
["src/nvim/if_cscope.c", ["    while ((ch = getc(csinfo[cnumber].fr_fp)) != EOF && ch != '\\n')", "      ;", "    return NULL;"], "whitespace/semicolon"]
["src/nvim/if_cscope.c", ["", "  /*", "   * cscope output is in the following format:"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["   */", "  if ((name = strtok((char *)buf, (const char *)\" \")) == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/if_cscope.c", ["   */", "  if ((name = strtok((char *)buf, (const char *)\" \")) == NULL)", "    return NULL;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["    return NULL;", "  if ((*context = strtok(NULL, (const char *)\" \")) == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/if_cscope.c", ["    return NULL;", "  if ((*context = strtok(NULL, (const char *)\" \")) == NULL)", "    return NULL;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["    return NULL;", "  if ((*linenumber = strtok(NULL, (const char *)\" \")) == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/if_cscope.c", ["    return NULL;", "  if ((*linenumber = strtok(NULL, (const char *)\" \")) == NULL)", "    return NULL;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["  for (size_t i = 0; i < csinfo_size; i++) {", "    if (nummatches_a[i] < 1)", "      continue;"], "readability/braces"]
["src/nvim/if_cscope.c", ["    for (int j = 0; j < nummatches_a[i]; j++) {", "      if ((fullname = cs_parse_results(i, buf, CSREAD_BUFSIZE, &cntx,", "               &slno, &search)) == NULL)"], "readability/braces"]
["src/nvim/if_cscope.c", ["      if ((fullname = cs_parse_results(i, buf, CSREAD_BUFSIZE, &cntx,", "               &slno, &search)) == NULL)", "        continue;"], "whitespace/alignment"]
["src/nvim/if_cscope.c", ["", "      if (strcmp(cntx, \"<global>\")==0)", "        strcpy(context, \"<<global>>\");"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "      if (strcmp(cntx, \"<global>\")==0)", "        strcpy(context, \"<<global>>\");"], "whitespace/operators"]
["src/nvim/if_cscope.c", ["      if (strcmp(cntx, \"<global>\")==0)", "        strcpy(context, \"<<global>>\");", "      else"], "runtime/printf"]
["src/nvim/if_cscope.c", ["        strcpy(context, \"<<global>>\");", "      else", "        sprintf(context, \"<<%s>>\", cntx);"], "readability/braces"]
["src/nvim/if_cscope.c", ["      else", "        sprintf(context, \"<<%s>>\", cntx);", ""], "runtime/printf"]
["src/nvim/if_cscope.c", ["", "      if (search == NULL)", "        fprintf(f, \"%s\\t%s\\t%s\\n\", fullname, slno, context);"], "readability/braces"]
["src/nvim/if_cscope.c", ["        fprintf(f, \"%s\\t%s\\t%s\\n\", fullname, slno, context);", "      else", "        fprintf(f, \"%s\\t%s\\t%s %s\\n\", fullname, slno, context, search);"], "readability/braces"]
["src/nvim/if_cscope.c", ["  for (size_t i = 0; i < csinfo_size; i++) {", "    if (nummatches_a[i] < 1)", "      continue;"], "readability/braces"]
["src/nvim/if_cscope.c", ["    for (int j = 0; j < nummatches_a[i]; j++) {", "      if ((fullname = cs_parse_results(i, buf, CSREAD_BUFSIZE, &cntx,", "               &slno, &search)) == NULL)"], "readability/braces"]
["src/nvim/if_cscope.c", ["      if ((fullname = cs_parse_results(i, buf, CSREAD_BUFSIZE, &cntx,", "               &slno, &search)) == NULL)", "        continue;"], "whitespace/alignment"]
["src/nvim/if_cscope.c", ["", "      if (strcmp(cntx, \"<global>\") == 0)", "        cntxts[totsofar] = NULL;"], "readability/braces"]
["src/nvim/if_cscope.c", ["        cntxts[totsofar] = NULL;", "      else {", "        cntxts[totsofar] = xstrdup(cntx);"], "readability/braces"]
["src/nvim/if_cscope.c", ["        cntxts[totsofar] = NULL;", "      else {", "        cntxts[totsofar] = xstrdup(cntx);"], "readability/braces"]
["src/nvim/if_cscope.c", ["#if defined(UNIX) && defined(SIGALRM)", "/*", " * Used to catch and ignore SIGALRM below."], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["    sleep(0);", "    for (waited = 0; waited < 40; ++waited) {", "      pid = waitpid(csinfo[i].pid, &pstat, WNOHANG);"], "readability/increment"]
["src/nvim/if_cscope.c", ["# endif", "    /*", "     * If the cscope process is still running: kill it."], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["      if (waitpid_errno == ECHILD) {", "        /*", "         * When using 'vim -g', vim is forked and cscope process is"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["      }", "      if (alive)", "# endif"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "  if (csinfo[i].fr_fp != NULL)", "    (void)fclose(csinfo[i].fr_fp);"], "readability/braces"]
["src/nvim/if_cscope.c", ["    (void)fclose(csinfo[i].fr_fp);", "  if (csinfo[i].to_fp != NULL)", "    (void)fclose(csinfo[i].to_fp);"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "  if (csinfo_size == 0)", "    return CSCOPE_SUCCESS;"], "readability/braces"]
["src/nvim/if_cscope.c", ["    fllist[i] = csinfo[i].flags;", "    if (csinfo[i].fname != NULL)", "      cs_release_csp(i, FALSE);"], "readability/braces"]
["src/nvim/if_cscope.c", ["    if (csinfo[i].fname != NULL)", "      cs_release_csp(i, FALSE);", "  }"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "  /*", "   * Ppath is freed when we destroy the cscope connection."], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["    STRLCPY(csdir, csinfo[i].fname,", "        path_tail((char_u *)csinfo[i].fname)", "        - (char_u *)csinfo[i].fname + 1);"], "whitespace/alignment"]
["src/nvim/if_cscope.c", ["        path_tail((char_u *)csinfo[i].fname)", "        - (char_u *)csinfo[i].fname + 1);", "    len += STRLEN(csdir);"], "whitespace/alignment"]
["src/nvim/if_cscope.c", ["    fullname = xmalloc(len);", "    (void)sprintf(fullname, \"%s/%s\", csinfo[i].ppath, name);", "  } else if (csdir != NULL && csinfo[i].fname != NULL && *csdir != NUL) {"], "runtime/printf"]
["src/nvim/if_cscope.c", ["{", "  if (cs_cnt_connections() == 0)", "    MSG_PUTS(_(\"no cscope connections\\n\"));"], "readability/braces"]
["src/nvim/if_cscope.c", ["    MSG_PUTS(_(\"no cscope connections\\n\"));", "  else {", "    MSG_PUTS_ATTR("], "readability/braces"]
["src/nvim/if_cscope.c", ["    MSG_PUTS(_(\"no cscope connections\\n\"));", "  else {", "    MSG_PUTS_ATTR("], "readability/braces"]
["src/nvim/if_cscope.c", ["    for (size_t i = 0; i < csinfo_size; i++) {", "      if (csinfo[i].fname == NULL)", "        continue;"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "  wait_return(TRUE);", "  return CSCOPE_SUCCESS;"], "readability/bool"]
["src/nvim/if_cscope.c", ["{", "  for (size_t i = 0; i < csinfo_size; i++)", "    cs_release_csp(i, true);"], "readability/braces"]
["src/nvim/if_cscope.h", ["", "#include \"nvim/types.h\" // for char_u and expand_T", "#include \"nvim/ex_cmds_defs.h\" // for exarg_T"], "whitespace/comments"]
["src/nvim/if_cscope.h", ["#include \"nvim/types.h\" // for char_u and expand_T", "#include \"nvim/ex_cmds_defs.h\" // for exarg_T", ""], "whitespace/comments"]
["src/nvim/indent.c", ["", "  for (; *ptr; ++ptr) {", "    // Count a tab for what it is worth."], "readability/increment"]
["src/nvim/indent.c", ["    - ((wp->w_p_nu || wp->w_p_rnu)", "        && (vim_strchr(p_cpo, CPO_NUMCOL) == NULL)", "        ? number_width(wp) + 1 : 0);"], "whitespace/alignment"]
["src/nvim/indent.c", ["        && (vim_strchr(p_cpo, CPO_NUMCOL) == NULL)", "        ? number_width(wp) + 1 : 0);", ""], "whitespace/alignment"]
["src/nvim/indent.c", ["", "  for (col = 0, ptr = get_cursor_line_ptr(); ascii_iswhite(*ptr); ++col) {", "    ptr++;"], "readability/increment"]
["src/nvim/indent.c", ["  save_set_curswant = curwin->w_set_curswant;", "  set_vim_var_nr(VV_LNUM, (varnumber_T) curwin->w_cursor.lnum);", ""], "whitespace/cast"]
["src/nvim/indent.c", ["", "      for (that = get_cursor_line_ptr(); *that != NUL; ++that) {", "        if (*that == ';') {"], "readability/increment"]
["src/nvim/indent.c", ["            if (vi_lisp || ((*that != '\"') && (*that != '\\'')", "                && (*that != '#') && ((*that < '0') || (*that > '9')))) {", "              while (*that"], "whitespace/alignment"]
["src/nvim/indent.c", ["                     && (!((*that == '(' || *that == '[')", "                     && !quotecount && !parencount && vi_lisp))) {", "                if (*that == '\"') {"], "whitespace/alignment"]
["src/nvim/indent.c", ["                     && (!((*that == '(' || *that == '[')", "                     && !quotecount && !parencount && vi_lisp))) {", "                if (*that == '\"') {"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["#endif", "/*", " * Find the start of a comment, not knowing if we are in a comment right now."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    pos = findmatchlimit(NULL, '*', FM_BACKWARD, cur_maxcomment);", "    if (pos == NULL)", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * Check if the comment start we found is inside a string."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    line = ml_get(pos->lnum);", "    for (p = line; *p && (colnr_T)(p - line) < pos->col; ++p)", "      p = skip_string(p);"], "readability/braces"]
["src/nvim/indent_c.c", ["    line = ml_get(pos->lnum);", "    for (p = line; *p && (colnr_T)(p - line) < pos->col; ++p)", "      p = skip_string(p);"], "readability/increment"]
["src/nvim/indent_c.c", ["      p = skip_string(p);", "    if ((colnr_T)(p - line) <= pos->col)", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Find the start of a raw string, not knowing if we are in one right now."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    for (;;)", "    {"], "readability/braces"]
["src/nvim/indent_c.c", ["    for (;;)", "    {", "        pos = findmatchlimit(NULL, 'R', FM_BACKWARD, cur_maxcomment);"], "whitespace/braces"]
["src/nvim/indent_c.c", ["        pos = findmatchlimit(NULL, 'R', FM_BACKWARD, cur_maxcomment);", "        if (pos == NULL)", "            break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "        /*", "         * Check if the raw string start we found is inside a string."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        line = ml_get(pos->lnum);", "        for (p = line; *p && (colnr_T)(p - line) < pos->col; ++p)", "            p = skip_string(p);"], "readability/braces"]
["src/nvim/indent_c.c", ["        line = ml_get(pos->lnum);", "        for (p = line; *p && (colnr_T)(p - line) < pos->col; ++p)", "            p = skip_string(p);"], "readability/increment"]
["src/nvim/indent_c.c", ["            p = skip_string(p);", "        if ((colnr_T)(p - line) <= pos->col)", "            break;"], "readability/braces"]
["src/nvim/indent_c.c", ["        cur_maxcomment = curwin->w_cursor.lnum - pos->lnum - 1;", "        if (cur_maxcomment <= 0)", "        {"], "readability/braces"]
["src/nvim/indent_c.c", ["        if (cur_maxcomment <= 0)", "        {", "            pos = NULL;"], "whitespace/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Skip to the end of a \"string\" and a 'c' character."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /*", "   * We loop, because strings may be concatenated: \"date\"\"time\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            for (p += 3; *p; ++p)", "                if (p[0] == ')' && STRNCMP(p + 1, delim, delim_len) == 0"], "readability/braces"]
["src/nvim/indent_c.c", ["", "            for (p += 3; *p; ++p)", "                if (p[0] == ')' && STRNCMP(p + 1, delim, delim_len) == 0"], "readability/increment"]
["src/nvim/indent_c.c", ["            for (p += 3; *p; ++p)", "                if (p[0] == ')' && STRNCMP(p + 1, delim, delim_len) == 0", "                        && p[delim_len + 1] == '\"')"], "readability/braces"]
["src/nvim/indent_c.c", ["                if (p[0] == ')' && STRNCMP(p + 1, delim, delim_len) == 0", "                        && p[delim_len + 1] == '\"')", "                {"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["                        && p[delim_len + 1] == '\"')", "                {", "                    p += delim_len + 1;"], "whitespace/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Functions for C-indenting."], "readability/old_style_comment"]
["src/nvim/indent_c.c", [" */", "/*", " * Below \"XXX\" means that this function may unlock the current line."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Return true if the string \"line\" starts with a word from 'cinwords'."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Skip over white space and C comments within the line."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /* Perl/shell # comment comment continues until eol.  Require a space", "     * before # to avoid recognizing $#array. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    }", "    if (*s != '*')", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Return TRUE if there is no code at *s.  White space and comments are"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Check previous lines for a \"//\" line comment, skipping over blank lines."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    }", "    if (*p != NUL)", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["    quote = *s;", "    ++s;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["  }", "  if (!vim_isIDc(*s))\t{   // need at least one ID character", "    return FALSE;"], "whitespace/tab"]
["src/nvim/indent_c.c", ["  }", "  if (!vim_isIDc(*s))\t{   // need at least one ID character", "    return FALSE;"], "whitespace/braces"]
["src/nvim/indent_c.c", ["  if (!vim_isIDc(*s))\t{   // need at least one ID character", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/indent_c.c", ["  while (vim_isIDc(*s)) {", "    ++s;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["  if (*s && *s == quote) {", "    ++s;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["", "  while (vim_isIDc(**s))", "    (*s)++;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "  /*", "   * Only accept a label if the previous line is terminated or is a case"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  while (curwin->w_cursor.lnum > 1) {", "    --curwin->w_cursor.lnum;", ""], "readability/increment"]
["src/nvim/indent_c.c", ["", "    /*", "     * If we're in a comment or raw string now, skip to the start of"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    curwin->w_cursor = cursor_save;", "    if (cin_isterminated(line, TRUE, FALSE)", "        || cin_isscopedecl(line)"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize structure initialization and enumerations:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  char_u      *s;", "  static char *skip[] = {\"static\", \"public\", \"protected\", \"private\"};", ""], "whitespace/braces"]
["src/nvim/indent_c.c", ["  char_u      *s;", "  static char *skip[] = {\"static\", \"public\", \"protected\", \"private\"};", ""], "whitespace/braces"]
["src/nvim/indent_c.c", ["", "  if (cin_starts_with(s, \"typedef\"))", "    s = cin_skipcomment(s + 7);"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    for (i = 0; i < (int)ARRAY_SIZE(skip); ++i) {", "      l = (int)strlen(skip[i]);"], "readability/increment"]
["src/nvim/indent_c.c", ["    }", "    if (l != 0)", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "  if (cin_starts_with(s, \"enum\"))", "    return TRUE;"], "readability/braces"]
["src/nvim/indent_c.c", ["  if (cin_starts_with(s, \"enum\"))", "    return TRUE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "  if (cin_ends_in(s, (char_u *)\"=\", (char_u *)\"{\"))", "    return TRUE;"], "readability/braces"]
["src/nvim/indent_c.c", ["  if (cin_ends_in(s, (char_u *)\"=\", (char_u *)\"{\"))", "    return TRUE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize a switch label: \"case .*:\" or \"default:\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  if (cin_starts_with(s, \"case\")) {", "    for (s += 4; *s; ++s) {", "      s = cin_skipcomment(s);"], "readability/increment"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize a \"default\" switch label."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize a \"public/private/protected\" scope declaration label."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Return a pointer to the first non-empty non-comment character after a ':'."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["{", "  for (; *l; ++l) {", "    if (*l == ':') {"], "readability/increment"]
["src/nvim/indent_c.c", ["  }", "  if (*l == NUL)", "    return NULL;"], "readability/braces"]
["src/nvim/indent_c.c", ["  l = cin_skipcomment(l + 1);", "  if (*l == NUL)", "    return NULL;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Get indent of line \"lnum\", skipping a label."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  p = after_label(l);", "  if (p == NULL)", "    return 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Find indent for line \"lnum\", ignoring any case or jump label."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Return the indent of the first variable name after a type in a declaration."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  }", "  if (len == 6 && STRNCMP(p, \"struct\", 6) == 0)", "    p = skipwhite(p + 6);"], "readability/braces"]
["src/nvim/indent_c.c", ["    p = skipwhite(p + 6);", "  else if (len == 4 && STRNCMP(p, \"enum\", 4) == 0)", "    p = skipwhite(p + 4);"], "readability/braces"]
["src/nvim/indent_c.c", ["    p = skipwhite(p + 4);", "  else if ((len == 8 && STRNCMP(p, \"unsigned\", 8) == 0)", "           || (len == 6 && STRNCMP(p, \"signed\", 6) == 0)) {"], "readability/braces"]
["src/nvim/indent_c.c", ["    s = skipwhite(p + len);", "    if ((STRNCMP(s, \"int\", 3) == 0 && ascii_iswhite(s[3]))", "        || (STRNCMP(s, \"long\", 4) == 0 && ascii_iswhite(s[4]))"], "readability/braces"]
["src/nvim/indent_c.c", ["  }", "  for (len = 0; vim_isIDc(p[len]); ++len)", "    ;"], "readability/braces"]
["src/nvim/indent_c.c", ["  }", "  for (len = 0; vim_isIDc(p[len]); ++len)", "    ;"], "readability/increment"]
["src/nvim/indent_c.c", ["  for (len = 0; vim_isIDc(p[len]); ++len)", "    ;", "  if (len == 0 || !ascii_iswhite(p[len]) || cin_nocode(p))"], "whitespace/semicolon"]
["src/nvim/indent_c.c", ["    ;", "  if (len == 0 || !ascii_iswhite(p[len]) || cin_nocode(p))", "    return 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Return the indent of the first non-blank after an equal sign."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    line = ml_get(lnum - 1);", "    if (*line != NUL && line[STRLEN(line) - 1] == '\\\\')", "      return -1;"], "readability/braces"]
["src/nvim/indent_c.c", ["  }", "  if (*s != '=')", "    return 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["  s = skipwhite(s + 1);", "  if (cin_nocode(s))", "    return 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize a preprocessor statement: Any line that starts with '#'."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["{", "  if (*skipwhite(s) == '#')", "    return TRUE;"], "readability/braces"]
["src/nvim/indent_c.c", ["  if (*skipwhite(s) == '#')", "    return TRUE;", "  return FALSE;"], "readability/bool"]
["src/nvim/indent_c.c", ["    return TRUE;", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/indent_c.c", ["    if (cin_ispreproc(line)) {", "      retval = TRUE;", "      *lnump = lnum;"], "readability/bool"]
["src/nvim/indent_c.c", ["    }", "    if (lnum == 1)", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["    line = ml_get(--lnum);", "    if (*line == NUL || line[STRLEN(line) - 1] != '\\\\')", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize the start of a C or C++ comment."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize the start of a \"//\" comment."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize a line that starts with '{' or '}', or ends with ';', ',', '{' or"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["static char_u", "cin_isterminated (", "    char_u *s,"], "whitespace/parens"]
["src/nvim/indent_c.c", ["  unsigned n_open = 0;", "  int is_else = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "  if (*s == '{' || (*s == '}' && !cin_iselse(s)))", "    found_start = *s;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "  if (!found_start)", "    is_else = cin_iselse(s);"], "readability/braces"]
["src/nvim/indent_c.c", ["    s = skip_string(cin_skipcomment(s));", "    if (*s == '}' && n_open > 0)", "      --n_open;"], "readability/braces"]
["src/nvim/indent_c.c", ["    if (*s == '}' && n_open > 0)", "      --n_open;", "    if ((!is_else || n_open == 0)"], "readability/increment"]
["src/nvim/indent_c.c", ["      --n_open;", "    if ((!is_else || n_open == 0)", "        && (*s == ';' || *s == '}' || (incl_comma && *s == ','))"], "readability/braces"]
["src/nvim/indent_c.c", ["      return *s;", "    else if (*s == '{') {", "      if (incl_open && cin_nocode(s + 1))"], "readability/braces"]
["src/nvim/indent_c.c", ["    else if (*s == '{') {", "      if (incl_open && cin_nocode(s + 1))", "        return *s;"], "readability/braces"]
["src/nvim/indent_c.c", ["        return *s;", "      else", "        ++n_open;"], "readability/braces"]
["src/nvim/indent_c.c", ["      else", "        ++n_open;", "    }"], "readability/increment"]
["src/nvim/indent_c.c", ["", "    if (*s)", "      s++;"], "readability/braces"]
["src/nvim/indent_c.c", ["  pos_T       *trypos;", "  int just_started = TRUE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "  if (sp == NULL)", "    s = ml_get(lnum);"], "readability/braces"]
["src/nvim/indent_c.c", ["    s = ml_get(lnum);", "  else", "    s = *sp;"], "readability/braces"]
["src/nvim/indent_c.c", ["    if (*s == ')' && cin_nocode(s + 1)) {", "      /* ')' at the end: may have found a match", "       * Check for he previous line not to end in a backslash:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      s = ml_get(lnum);", "      if (*s == NUL || s[STRLEN(s) - 1] != '\\\\')", "        retval = TRUE;"], "readability/braces"]
["src/nvim/indent_c.c", ["      if (*s == NUL || s[STRLEN(s) - 1] != '\\\\')", "        retval = TRUE;", "      goto done;"], "readability/bool"]
["src/nvim/indent_c.c", ["", "      /* ',' at the end: continue looking in the next line.", "       * At the end: check for ',' in the next line, for this style:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      for (;; ) {", "        if (lnum >= curbuf->b_ml.ml_line_count)", "          break;"], "readability/braces"]
["src/nvim/indent_c.c", ["        s = ml_get(++lnum);", "        if (!cin_ispreproc(s))", "          break;"], "readability/braces"]
["src/nvim/indent_c.c", ["      }", "      if (lnum >= curbuf->b_ml.ml_line_count)", "        break;"], "readability/braces"]
["src/nvim/indent_c.c", ["        break;", "      /* Require a comma at end of the line or a comma or ')' at the", "       * start of next line. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      s = skipwhite(s);", "      if (!just_started && (!comma && *s != ',' && *s != ')'))", "        break;"], "readability/braces"]
["src/nvim/indent_c.c", ["done:", "  if (lnum != first_lnum && sp != NULL)", "    *sp = ml_get(first_lnum);"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Check if this is a \"while\" that should have a matching \"do\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  pos_T       *trypos;", "  int retval = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["    }", "    if ((trypos = findmatchlimit(NULL, 0, 0,", "             curbuf->b_ind_maxparen)) != NULL"], "readability/braces"]
["src/nvim/indent_c.c", ["    if ((trypos = findmatchlimit(NULL, 0, 0,", "             curbuf->b_ind_maxparen)) != NULL", "        && *cin_skipcomment(ml_get_pos(trypos) + 1) == ';')"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["        && *cin_skipcomment(ml_get_pos(trypos) + 1) == ';')", "      retval = TRUE;", "    curwin->w_cursor = cursor_save;"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Check whether in \"p\" there is an \"if\", \"for\" or \"while\" before \"*poffset\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  if (offset-- < 2)", "    return 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["    return 0;", "  while (offset > 2 && ascii_iswhite(line[offset]))", "    --offset;"], "readability/braces"]
["src/nvim/indent_c.c", ["  while (offset > 2 && ascii_iswhite(line[offset]))", "    --offset;", ""], "readability/increment"]
["src/nvim/indent_c.c", ["  offset -= 1;", "  if (!STRNCMP(line + offset, \"if\", 2))", "    goto probablyFound;"], "readability/braces"]
["src/nvim/indent_c.c", ["    offset -= 1;", "    if (!STRNCMP(line + offset, \"for\", 3))", "      goto probablyFound;"], "readability/braces"]
["src/nvim/indent_c.c", ["      offset -= 2;", "      if (!STRNCMP(line + offset, \"while\", 5))", "        goto probablyFound;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Return TRUE if we are at the end of a do-while."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      if (*s == ';' && cin_nocode(s + 1)) {", "        /* Found \");\" at end of the line, now check there is \"while\"", "         * before the matching '('.  XXX */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            curwin->w_cursor.lnum = trypos->lnum;", "            return TRUE;", "          }"], "readability/bool"]
["src/nvim/indent_c.c", ["    }", "    if (*p != NUL)", "      ++p;"], "readability/braces"]
["src/nvim/indent_c.c", ["    if (*p != NUL)", "      ++p;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Find the position of a C++ base-class declaration or"], "readability/old_style_comment"]
["src/nvim/indent_c.c", [" */", "static int cin_is_cpp_baseclass(cpp_baseclass_cache_T *cached) {", "  lpos_T *pos = &cached->lpos;  // find position"], "readability/braces"]
["src/nvim/indent_c.c", ["  s = cin_skipcomment(s);", "  if (*s == NUL)", "    return FALSE;"], "readability/braces"]
["src/nvim/indent_c.c", ["  if (*s == NUL)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "  cpp_base_class = lookfor_ctor_init = class_or_struct = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "  /* Search for a line starting with '#', empty, ending in ';' or containing", "   * '{' or '}' and start below it.  This handles the following situations:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    s = skipwhite(line);", "    if (*s == '#' || *s == NUL)", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["      s = cin_skipcomment(s);", "      if (*s == '{' || *s == '}'", "          || (*s == ';' && cin_nocode(s + 1)))"], "readability/braces"]
["src/nvim/indent_c.c", ["        break;", "      if (*s != NUL)", "        ++s;"], "readability/braces"]
["src/nvim/indent_c.c", ["      if (*s != NUL)", "        ++s;", "    }"], "readability/increment"]
["src/nvim/indent_c.c", ["    }", "    if (*s != NUL)", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["      break;", "    --lnum;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["      s = cin_skipcomment(line);", "      if (*s == NUL)", "        continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    if (s[0] == '\"' || (s[0] == 'R' && s[1] == '\"'))", "      s = skip_string(s) + 1;"], "readability/braces"]
["src/nvim/indent_c.c", ["      s = skip_string(s) + 1;", "    else if (s[0] == ':') {", "      if (s[1] == ':') {"], "readability/braces"]
["src/nvim/indent_c.c", ["      if (s[1] == ':') {", "        /* skip double colon. It can't be a constructor", "         * initialization any more */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["         * initialization any more */", "        lookfor_ctor_init = FALSE;", "        s = cin_skipcomment(s + 2);"], "readability/bool"]
["src/nvim/indent_c.c", ["      } else if (lookfor_ctor_init || class_or_struct) {", "        /* we have something found, that looks like the start of", "         * cpp-base-class-declaration or constructor-initialization */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        s = cin_skipcomment(s + 1);", "      } else", "        s = cin_skipcomment(s + 1);"], "readability/braces"]
["src/nvim/indent_c.c", ["               || (STRNCMP(s, \"struct\", 6) == 0 && !vim_isIDc(s[6]))) {", "      class_or_struct = TRUE;", "      lookfor_ctor_init = FALSE;"], "readability/bool"]
["src/nvim/indent_c.c", ["      class_or_struct = TRUE;", "      lookfor_ctor_init = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "      if (*s == 'c')", "        s = cin_skipcomment(s + 5);"], "readability/braces"]
["src/nvim/indent_c.c", ["        s = cin_skipcomment(s + 5);", "      else", "        s = cin_skipcomment(s + 6);"], "readability/braces"]
["src/nvim/indent_c.c", ["      if (s[0] == '{' || s[0] == '}' || s[0] == ';') {", "        cpp_base_class = lookfor_ctor_init = class_or_struct = FALSE;", "      } else if (s[0] == ')') {"], "readability/bool"]
["src/nvim/indent_c.c", ["      } else if (s[0] == ')') {", "        /* Constructor-initialization is assumed if we come across", "         * something like \"):\" */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["         * something like \"):\" */", "        class_or_struct = FALSE;", "        lookfor_ctor_init = TRUE;"], "readability/bool"]
["src/nvim/indent_c.c", ["        class_or_struct = FALSE;", "        lookfor_ctor_init = TRUE;", "      } else if (s[0] == '?') {"], "readability/bool"]
["src/nvim/indent_c.c", ["  }", "  if (amount < curbuf->b_ind_cpp_baseclass)", "    amount = curbuf->b_ind_cpp_baseclass;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Return TRUE if string \"s\" ends with the string \"find\", possibly followed by"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      r = skipwhite(p + len);", "      if (ignore != NULL && STRNCMP(r, ignore, STRLEN(ignore)) == 0)", "        r = skipwhite(r + STRLEN(ignore));"], "readability/braces"]
["src/nvim/indent_c.c", ["        r = skipwhite(r + STRLEN(ignore));", "      if (cin_nocode(r))", "        return TRUE;"], "readability/braces"]
["src/nvim/indent_c.c", ["      if (cin_nocode(r))", "        return TRUE;", "    }"], "readability/bool"]
["src/nvim/indent_c.c", ["    }", "    if (*p != NUL)", "      ++p;"], "readability/braces"]
["src/nvim/indent_c.c", ["    if (*p != NUL)", "      ++p;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Return TRUE when \"s\" starts with \"word\" and then a non-ID character."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Skip strings, chars and comments until at or past \"trypos\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Find the '{' at the start of the block we are in."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        ind_maxp_wk = ind_maxparen - (int)(cursor_save.lnum", "            - trypos_wk->lnum);", "        if (ind_maxp_wk > 0) {"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["", "/*", " * Return ind_maxparen corrected for the difference in line number between the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  if (n > 0 && n < curbuf->b_ind_maxparen / 2)", "    return curbuf->b_ind_maxparen - (int)n;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Set w_cursor.col to the column number of the last unmatched ')' or '{' in"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  int i;", "  int retval = FALSE;", "  int open_count = 0;"], "readability/bool"]
["src/nvim/indent_c.c", ["        curwin->w_cursor.col = i;", "        retval = TRUE;", "      }"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Parse 'cinoptions' and set the values in \"curbuf\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /*", "   * Set the default values."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["   */", "  /* Spaces from a block's opening brace the prevailing indent for that", "   * block should be. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the edge of the line an open brace that's at the end of a", "   * line is imagined to be. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the prevailing indent for a line that is not preceded by", "   * an opening brace. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the prevailing indent a leftmost open brace should be", "   * located. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the matching open brace (real location for one at the left", "   * edge; imaginary location from one that ends a line) the matching close"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the edge of the line an open brace sitting in the leftmost", "   * column is imagined to be. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces jump labels should be shifted to the left if N is non-negative,", "   * otherwise the jump label will be put to column 1. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the class declaration indent a scope declaration label", "   * should be located. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Amount a cpp base class declaration or constructor initialization", "   * should be indented. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* additional spaces beyond the prevailing indent a continuation line", "   * should be located. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the indent of the line with an unclosed parentheses, which", "   * itself is also unclosed. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Suppress ignoring spaces from the indent of a line starting with an", "   * unclosed parentheses. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* If the opening paren is the last nonwhite character on the line, and", "   * b_ind_unclosed_wrapped is nonzero, use this indent relative to the outer"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Suppress ignoring white space when lining up with the character after", "   * an unclosed parentheses. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Indent a closing parentheses under the line start of the matching", "   * opening parentheses. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Boolean: if non-zero, use b_ind_in_comment even if there is something", "   * after the comment opener. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Handle continuation lines containing conditions of if(), for() and", "   * while(). */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        n *= sw;", "        if (divider)", "          n += (sw * fraction + divider / 2) / divider;"], "readability/braces"]
["src/nvim/indent_c.c", ["      }", "      ++p;", "    }"], "readability/increment"]
["src/nvim/indent_c.c", ["    }", "    if (l[1] == '-')", "      n = -n;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /* When adding an entry here, also update the default 'cinoptions' in", "     * doc/indent.txt, and add explanation for it! */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    }", "    if (*p == ',')", "      ++p;"], "readability/braces"]
["src/nvim/indent_c.c", ["    if (*p == ',')", "      ++p;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["", "/*", " * Return the desired indent for C code."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Get a copy of the current contents of the line.", "   * This is required, because only the most recent line obtained with"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /*", "   * In insert mode and the cursor is on a ')' truncate the line at the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["   */", "  if ((State & INSERT)", "      && curwin->w_cursor.col < (colnr_T)STRLEN(linecopy)"], "readability/braces"]
["src/nvim/indent_c.c", ["", "  /*", "   * If we are inside a raw string don't change the indent."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /*", "   * Is it a non-case label?\tThen that goes at the left margin too unless:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  if (original_line_islabel && !curbuf->b_ind_js", "           && curbuf->b_ind_jump_label < 0) {", "    amount = 0;"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["  }", "  /*", "   * If we're inside a \"//\" comment and there is a \"//\" comment in a"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  }", "  /*", "   * If we're inside a comment and not looking at the start of the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    int start_off = 0;", "    int done = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "      if (*p == ':')", "        ++p;"], "readability/braces"]
["src/nvim/indent_c.c", ["      if (*p == ':')", "        ++p;", "      (void)copy_option_part(&p, lead_end, COM_MAX_LEN, \",\");"], "readability/increment"]
["src/nvim/indent_c.c", ["      } else if (what == COM_END) {", "        /* If our line starts with the middle comment string, line it", "         * up with the comment opener per the 'comments' option. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            && STRNCMP(theline, lead_end, STRLEN(lead_end)) != 0) {", "          done = TRUE;", "          if (curwin->w_cursor.lnum > 1) {"], "readability/bool"]
["src/nvim/indent_c.c", ["          if (curwin->w_cursor.lnum > 1) {", "            /* If the start comment string matches in the previous", "             * line, use the indent of that line plus offset.  If"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            look = skipwhite(ml_get(curwin->w_cursor.lnum - 1));", "            if (STRNCMP(look, lead_start, lead_start_len) == 0)", "              amount = get_indent_lnum(curwin->w_cursor.lnum - 1);"], "readability/braces"]
["src/nvim/indent_c.c", ["              amount = get_indent_lnum(curwin->w_cursor.lnum - 1);", "            else if (STRNCMP(look, lead_middle,", "                         lead_middle_len) == 0) {"], "readability/braces"]
["src/nvim/indent_c.c", ["            else if (STRNCMP(look, lead_middle,", "                         lead_middle_len) == 0) {", "              amount = get_indent_lnum(curwin->w_cursor.lnum - 1);"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["            } else if (STRNCMP(ml_get(comment_pos->lnum) + comment_pos->col,", "                        lead_start, lead_start_len) != 0) {", "              /* If the start comment string doesn't match with the"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["                        lead_start, lead_start_len) != 0) {", "              /* If the start comment string doesn't match with the", "               * start of the comment, skip this entry. XXX */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          }", "          if (start_off != 0)", "            amount += start_off;"], "readability/braces"]
["src/nvim/indent_c.c", ["            amount += start_off;", "          else if (start_align == COM_RIGHT)", "            amount += vim_strsize(lead_start)"], "readability/braces"]
["src/nvim/indent_c.c", ["", "        /* If our line starts with the end comment string, line it up", "         * with the middle comment */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /* If our line starts with an asterisk, line up with the", "     * asterisk in the comment opener; otherwise, line up"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["     */", "    if (done)", "      ;"], "readability/braces"]
["src/nvim/indent_c.c", ["    if (done)", "      ;", "    else if (theline[0] == '*')"], "whitespace/semicolon"]
["src/nvim/indent_c.c", ["      ;", "    else if (theline[0] == '*')", "      amount += 1;"], "readability/braces"]
["src/nvim/indent_c.c", ["      amount += 1;", "    else {", "      /*"], "readability/braces"]
["src/nvim/indent_c.c", ["      amount += 1;", "    else {", "      /*"], "readability/braces"]
["src/nvim/indent_c.c", ["    else {", "      /*", "       * If we are more than one line away from the comment opener, take"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        amount = col;", "        if (curbuf->b_ind_in_comment2 || *look == NUL)", "          amount += curbuf->b_ind_in_comment;"], "readability/braces"]
["src/nvim/indent_c.c", ["  if (*skipwhite(theline) == ']'", "           && (trypos = find_match_char('[', curbuf->b_ind_maxparen)) != NULL) {", "    // align with the line containing the '['."], "whitespace/alignment"]
["src/nvim/indent_c.c", ["  if (((trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL", "            && curbuf->b_ind_java == 0)", "           || (tryposBrace = find_start_brace()) != NULL"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["            && curbuf->b_ind_java == 0)", "           || (tryposBrace = find_start_brace()) != NULL", "           || trypos != NULL) {"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["           || (tryposBrace = find_start_brace()) != NULL", "           || trypos != NULL) {", "    if (trypos != NULL && tryposBrace != NULL) {"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["    if (trypos != NULL && tryposBrace != NULL) {", "      /* Both an unmatched '(' and '{' is found.  Use the one which is", "       * closer to the current cursor position, set the other to NULL. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["       * closer to the current cursor position, set the other to NULL. */", "      if (trypos->lnum != tryposBrace->lnum", "          ? trypos->lnum < tryposBrace->lnum"], "readability/braces"]
["src/nvim/indent_c.c", ["        trypos = NULL;", "      else", "        tryposBrace = NULL;"], "readability/braces"]
["src/nvim/indent_c.c", ["      our_paren_pos = *trypos;", "      /*", "       * If the matching paren is more than one line away, use the indent of"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        amount = -1;", "        for (lnum = cur_curpos.lnum - 1; lnum > our_paren_pos.lnum; --lnum) {", "          l = skipwhite(ml_get(lnum));"], "readability/increment"]
["src/nvim/indent_c.c", ["          if ((trypos = find_match_paren(", "                   corr_ind_maxparen(&cur_curpos))) != NULL", "              && trypos->lnum == our_paren_pos.lnum"], "whitespace/indent"]
["src/nvim/indent_c.c", ["            if (theline[0] == ')') {", "              if (our_paren_pos.lnum != lnum", "                  && cur_amount > amount)"], "readability/braces"]
["src/nvim/indent_c.c", ["", "      /*", "       * Line up with line where the matching paren is. XXX"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        if (curbuf->b_ind_if_for_while) {", "          /* Look for the outermost opening parenthesis on this line", "           * and check whether it belongs to an \"if\", \"for\" or \"while\". */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "          /* Ignore a '(' in front of the line that has a match before", "           * our matching '('. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          curwin->w_cursor.col = look_col + 1;", "          if ((trypos = findmatchlimit(NULL, ')', 0,", "                   curbuf->b_ind_maxparen))"], "readability/braces"]
["src/nvim/indent_c.c", ["          if ((trypos = findmatchlimit(NULL, ')', 0,", "                   curbuf->b_ind_maxparen))", "              != NULL"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["                && ignore_paren_col == 0)) {", "          /*", "           * If we're looking at a close paren, line up right there;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                && cin_ends_in(l, (char_u *)\"(\", NULL)) {", "              /* look for opening unmatched paren, indent one level", "               * for each additional level */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              n = 1;", "              for (col = 0; col < our_paren_pos.col; ++col) {", "                switch (l[col]) {"], "readability/increment"]
["src/nvim/indent_c.c", ["                case '}': if (n > 1)", "                    --n;", "                  break;"], "readability/increment"]
["src/nvim/indent_c.c", ["              amount += n * curbuf->b_ind_unclosed_wrapped;", "            } else if (curbuf->b_ind_unclosed_whiteok)", "              our_paren_pos.col++;"], "readability/braces"]
["src/nvim/indent_c.c", ["              our_paren_pos.col++;", "            else {", "              col = our_paren_pos.col + 1;"], "readability/braces"]
["src/nvim/indent_c.c", ["              our_paren_pos.col++;", "            else {", "              col = our_paren_pos.col + 1;"], "readability/braces"]
["src/nvim/indent_c.c", ["              col = our_paren_pos.col + 1;", "              while (ascii_iswhite(l[col]))", "                col++;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "          /*", "           * Find how indented the paren is, or the character after it"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            getvcol(curwin, &our_paren_pos, &col, NULL, NULL);", "            if (cur_amount > (int)col)", "              cur_amount = col;"], "readability/braces"]
["src/nvim/indent_c.c", ["                       && *look == '(' && ignore_paren_col == 0)) {", "          if (cur_amount != MAXCOL)", "            amount = cur_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["        } else {", "          /* Add b_ind_unclosed2 for each '(' before our matching one,", "           * but ignore (void) before the line (ignore_paren_col). */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          while ((int)our_paren_pos.col > ignore_paren_col) {", "            --our_paren_pos.col;", "            switch (*ml_get_pos(&our_paren_pos)) {"], "readability/increment"]
["src/nvim/indent_c.c", ["", "          /* Use b_ind_unclosed once, when the first '(' is not inside", "           * braces */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["           * braces */", "          if (col == MAXCOL)", "            amount += curbuf->b_ind_unclosed;"], "readability/braces"]
["src/nvim/indent_c.c", ["            amount += curbuf->b_ind_unclosed;", "          else {", "            curwin->w_cursor.lnum = our_paren_pos.lnum;"], "readability/braces"]
["src/nvim/indent_c.c", ["            amount += curbuf->b_ind_unclosed;", "          else {", "            curwin->w_cursor.lnum = our_paren_pos.lnum;"], "readability/braces"]
["src/nvim/indent_c.c", ["          }", "          /*", "           * For a line starting with ')' use the minimum of the two"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["           */", "          if (cur_amount < amount)", "            amount = cur_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "      /*", "       * Now figure out how indented the line is in general."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        amount = col;", "        if (*start == '{')", "          start_brace = BRACE_IN_COL0;"], "readability/braces"]
["src/nvim/indent_c.c", ["          start_brace = BRACE_IN_COL0;", "        else", "          start_brace = BRACE_AT_START;"], "readability/braces"]
["src/nvim/indent_c.c", ["        // It could have been something like", "        //\t   case 1: if (asdf &&", "        //\t\t\tldfd) {"], "whitespace/tab"]
["src/nvim/indent_c.c", ["        // It could have been something like", "        //\t   case 1: if (asdf &&", "        //\t\t\tldfd) {"], "whitespace/comments"]
["src/nvim/indent_c.c", ["        //\t   case 1: if (asdf &&", "        //\t\t\tldfd) {", "        //\t\t    }"], "whitespace/tab"]
["src/nvim/indent_c.c", ["        //\t   case 1: if (asdf &&", "        //\t\t\tldfd) {", "        //\t\t    }"], "whitespace/comments"]
["src/nvim/indent_c.c", ["        //\t\t\tldfd) {", "        //\t\t    }", "        if ((curbuf->b_ind_js || curbuf->b_ind_keep_case_label)"], "whitespace/tab"]
["src/nvim/indent_c.c", ["        //\t\t\tldfd) {", "        //\t\t    }", "        if ((curbuf->b_ind_js || curbuf->b_ind_keep_case_label)"], "whitespace/comments"]
["src/nvim/indent_c.c", ["      if (theline[0] == '}') {", "        /*", "         * they may want closing braces to line up with something"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      } else {", "        /*", "         * If we're looking at an \"else\", try to find an \"if\""], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "        /*", "         * We get here if we are not on an \"while-of-do\" or \"else\" (or"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "        /*", "         * if the '{' is  _really_ at the left margin, use the imaginary"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            amount -= curbuf->b_ind_open_extra;", "            if (amount < 0)", "              amount = 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "        lookfor_break = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "          /*", "           * If we went all the way back to the start of our scope, line"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                  < ourscope - curbuf->b_ind_maxparen) {", "                /* nothing found (abuse curbuf->b_ind_maxparen as", "                 * limit) assume terminated line (i.e. a variable"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                 * initialization) */", "                if (cont_amount > 0)", "                  amount = cont_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["                  amount = cont_amount;", "                else if (!curbuf->b_ind_js)", "                  amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "              /*", "               * If we're in a comment or raw string now, skip to"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              if (cin_nocode(l))", "                continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "              terminated = cin_isterminated(l, FALSE, TRUE);", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "              /*", "               * If we are at top level and the line looks like a"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                  || !cin_isfuncdecl(&l, curwin->w_cursor.lnum, 0)) {", "                /* if the line is terminated with another ','", "                 * it is a continued variable initialization."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                 */", "                if (terminated == ',')", "                  break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "                /* if it is an enum declaration or an assignment,", "                 * we are done."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                 */", "                if (terminated != ';' && cin_isinit())", "                  break;"], "readability/braces"]
["src/nvim/indent_c.c", ["                trypos = NULL;", "                if (find_last_paren(l, '(', ')'))", "                  trypos = find_match_paren("], "readability/braces"]
["src/nvim/indent_c.c", ["", "                if (trypos == NULL && find_last_paren(l, '{', '}'))", "                  trypos = find_start_brace();"], "readability/braces"]
["src/nvim/indent_c.c", ["", "              /* it's a variable declaration, add indentation", "               * like in"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["               */", "              if (cont_amount > 0)", "                amount = cont_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["                amount = cont_amount;", "              else", "                amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["            } else if (lookfor == LOOKFOR_UNTERM) {", "              if (cont_amount > 0)", "                amount = cont_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["                amount = cont_amount;", "              else", "                amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["              if (lookfor_cpp_namespace) {", "                /*", "                 * Looking for C++ namespace, need to look further"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                 */", "                if (curwin->w_cursor.lnum == ourscope)", "                  continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "                if (curwin->w_cursor.lnum == 0", "                    || curwin->w_cursor.lnum"], "readability/braces"]
["src/nvim/indent_c.c", ["", "                /* If we're in a comment or raw string now, skip", "                 * to the start of it. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "                if (cin_nocode(l))", "                  continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "          /*", "           * If this is a switch() label, may line up relative to that."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          if (iscase || cin_isscopedecl(l)) {", "            /* we are only looking for cpp base class", "             * declaration/initialization any longer */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["             * declaration/initialization any longer */", "            if (lookfor == LOOKFOR_CPP_BASECLASS)", "              break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "            /* When looking for a \"do\" we are not interested in", "             * labels. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["             * labels. */", "            if (whilelevel > 0)", "              continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "            /*", "             *\tcase xx:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                || lookfor == LOOKFOR_ENUM_OR_INIT) {", "              if (cont_amount > 0)", "                amount = cont_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["                amount = cont_amount;", "              else", "                amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "            /*", "             *\t case xx: if (cond)\t    <- line up with this if"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            if (lookfor == LOOKFOR_TERM) {", "              if (n)", "                amount = n;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "              if (!lookfor_break)", "                break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "            /*", "             *\t case xx: x = x + 1;\t    <- line up with this x"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              if (l != NULL && cin_is_cinword(l)) {", "                if (theline[0] == '{')", "                  amount += curbuf->b_ind_open_extra;"], "readability/braces"]
["src/nvim/indent_c.c", ["                  amount += curbuf->b_ind_open_extra;", "                else", "                  amount += curbuf->b_ind_level"], "readability/braces"]
["src/nvim/indent_c.c", ["", "            /*", "             * Try to get the indent of a statement before the switch"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "          /*", "           * Looking for a switch() label or C++ scope declaration,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "          /*", "           * Ignore jump labels with nothing after them."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            l = after_label(get_cursor_line_ptr());", "            if (l == NULL || cin_nocode(l))", "              continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "          /*", "           * Ignore #defines, #if, etc."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            if (lookfor == LOOKFOR_UNTERM) {", "              if (cont_amount > 0)", "                amount = cont_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["                amount = cont_amount;", "              else", "                amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["          } else if (lookfor == LOOKFOR_CPP_BASECLASS) {", "            /* only look, whether there is a cpp base class", "             * declaration or initialization before the opening brace."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["             */", "            if (cin_isterminated(l, TRUE, FALSE))", "              break;"], "readability/braces"]
["src/nvim/indent_c.c", ["             */", "            if (cin_isterminated(l, TRUE, FALSE))", "              break;"], "readability/bool"]
["src/nvim/indent_c.c", ["              break;", "            else", "              continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "          /*", "           * What happens next depends on the line being terminated."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["           */", "          terminated = cin_isterminated(l, FALSE, TRUE);", ""], "readability/bool"]
["src/nvim/indent_c.c", ["          if (js_cur_has_key) {", "            js_cur_has_key = false; // only check the first line", "            if (curbuf->b_ind_js && terminated == ',') {"], "whitespace/comments"]
["src/nvim/indent_c.c", ["            // that starts it so we can get the right prevailing indent", "            //\t   if ( foo &&", "            //\t\t    bar )"], "whitespace/tab"]
["src/nvim/indent_c.c", ["            // that starts it so we can get the right prevailing indent", "            //\t   if ( foo &&", "            //\t\t    bar )"], "whitespace/comments"]
["src/nvim/indent_c.c", ["            //\t   if ( foo &&", "            //\t\t    bar )", ""], "whitespace/tab"]
["src/nvim/indent_c.c", ["            //\t   if ( foo &&", "            //\t\t    bar )", ""], "whitespace/comments"]
["src/nvim/indent_c.c", ["            // braces.", "            if (trypos == NULL && terminated == ','", "                && find_last_paren(l, '{', '}'))"], "readability/braces"]
["src/nvim/indent_c.c", ["            if (trypos != NULL) {", "              /*", "               * Check if we are on a case label now.  This is"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Skip over continuation lines to find the one to get the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                l = ml_get(curwin->w_cursor.lnum - 1);", "                if (*l == NUL || l[STRLEN(l) - 1] != '\\\\')", "                  break;"], "readability/braces"]
["src/nvim/indent_c.c", ["                  break;", "                --curwin->w_cursor.lnum;", "                curwin->w_cursor.col = 0;"], "readability/increment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Get indent and pointer to text for current line,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            }", "            /*", "             * If this is just above the line we are indenting, and it"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              amount = cur_amount;", "              /*", "               * Only add b_ind_open_extra when the current line"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["               */", "              if (*skipwhite(l) != '{')", "                amount += curbuf->b_ind_open_extra;"], "readability/braces"]
["src/nvim/indent_c.c", ["              if (curbuf->b_ind_cpp_baseclass && !curbuf->b_ind_js) {", "                /* have to look back, whether it is a cpp base", "                 * class declaration or initialization */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Check if we are after an \"if\", \"while\", etc."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            if (cin_is_cinword(l) || cin_iselse(skipwhite(l))) {", "              /*", "               * Found an unterminated line after an if (), line up"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                  || lookfor == LOOKFOR_ENUM_OR_INIT) {", "                if (cont_amount > 0)", "                  amount = cont_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["                  amount = cont_amount;", "                else", "                  amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "              /*", "               * If this is just above the line we are indenting, we"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              amount = cur_amount;", "              if (theline[0] == '{')", "                amount += curbuf->b_ind_open_extra;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "              /*", "               * Special trick: when expecting the while () after a"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              if (cin_isdo(l)) {", "                if (whilelevel == 0)", "                  break;"], "readability/braces"]
["src/nvim/indent_c.c", ["                  break;", "                --whilelevel;", "              }"], "readability/increment"]
["src/nvim/indent_c.c", ["", "              /*", "               * When searching for a terminated line, don't use the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              if (cin_iselse(l) && whilelevel == 0) {", "                /* If we're looking at \"} else\", let's make sure we", "                 * find the opening brace of the enclosing scope,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                 * not the one from \"if () {\". */", "                if (*l == '}')", "                  curwin->w_cursor.col ="], "readability/braces"]
["src/nvim/indent_c.c", ["", "                if ((trypos = find_start_brace()) == NULL", "                    || find_match(LOOKFOR_IF, trypos->lnum)"], "readability/braces"]
["src/nvim/indent_c.c", ["            }", "            /*", "             * If we're below an unterminated line that is not an"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["             */", "            else {", "              /*"], "whitespace/newline"]
["src/nvim/indent_c.c", ["             */", "            else {", "              /*"], "readability/braces"]
["src/nvim/indent_c.c", ["            else {", "              /*", "               * Found two unterminated lines on a row, line up with"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              if (lookfor == LOOKFOR_ENUM_OR_INIT) {", "                /* Found two lines ending in ',', lineup with the", "                 * lowest one, but check for cpp base class"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                if (terminated == ',') {", "                  if (curbuf->b_ind_cpp_baseclass == 0)", "                    break;"], "readability/braces"]
["src/nvim/indent_c.c", ["                    // XXX", "                    cont_amount = cin_get_equal_amount( curwin->w_cursor.lnum);", "                  }"], "whitespace/parens"]
["src/nvim/indent_c.c", ["          }", "          /*", "           * Check if we are after a while (cond);"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["           */", "          else if (cin_iswhileofdo_end(terminated)) {  // XXX", "            /*"], "whitespace/newline"]
["src/nvim/indent_c.c", ["          else if (cin_iswhileofdo_end(terminated)) {  // XXX", "            /*", "             * Found an unterminated line after a while ();, line up"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                || lookfor == LOOKFOR_ENUM_OR_INIT) {", "              if (cont_amount > 0)", "                amount = cont_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["                amount = cont_amount;", "              else", "                amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["            }", "            ++whilelevel;", "          }"], "readability/increment"]
["src/nvim/indent_c.c", ["          }", "          /*", "           * We are after a \"normal\" statement."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["           */", "          else {", "            /*"], "whitespace/newline"]
["src/nvim/indent_c.c", ["           */", "          else {", "            /*"], "readability/braces"]
["src/nvim/indent_c.c", ["          else {", "            /*", "             * Skip single break line, if before a switch label. It"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Handle \"do {\" line."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Found a terminated line above an unterminated line. Add"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                || lookfor == LOOKFOR_ENUM_OR_INIT) {", "              if (cont_amount > 0)", "                amount = cont_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["                amount = cont_amount;", "              else", "                amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "            /*", "             * Found a terminated line above a terminated line or \"if\""], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            if (lookfor == LOOKFOR_TERM) {", "              if (!lookfor_break && whilelevel == 0)", "                break;"], "readability/braces"]
["src/nvim/indent_c.c", ["            }", "            /*", "             * First line above the one we're indenting is terminated."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["             */", "            else {", "              /*"], "whitespace/newline"]
["src/nvim/indent_c.c", ["             */", "            else {", "              /*"], "readability/braces"]
["src/nvim/indent_c.c", ["            else {", "              /*", "               * position the cursor over the rightmost paren, so"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                  && (trypos = find_match_paren(", "                          curbuf->b_ind_maxparen)) != NULL) {", "                /*"], "whitespace/indent"]
["src/nvim/indent_c.c", ["                  && (trypos = find_match_paren(", "                          curbuf->b_ind_maxparen)) != NULL) {", "                /*"], "whitespace/indent"]
["src/nvim/indent_c.c", ["                          curbuf->b_ind_maxparen)) != NULL) {", "                /*", "                 * Check if we are on a case label now.  This is"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              /* When aligning with the case statement, don't align", "               * with a statement after it."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              /*", "               * Get indent and pointer to text for current line,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              if (theline[0] == '{')", "                amount += curbuf->b_ind_open_extra;"], "readability/braces"]
["src/nvim/indent_c.c", ["              l = skipwhite(l);", "              if (*l == '{')", "                amount -= curbuf->b_ind_open_extra;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "              /*", "               * When a terminated line starts with \"else\" skip to"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                  && whilelevel == 0) {", "                if ((trypos = find_start_brace()) == NULL", "                    || find_match(LOOKFOR_IF, trypos->lnum)"], "readability/braces"]
["src/nvim/indent_c.c", ["", "              /*", "               * If we're at the end of a block, skip to the start of"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                l = cin_skipcomment(get_cursor_line_ptr());", "                if (*l == '}' || !cin_iselse(l))", "                  goto term_again;"], "readability/braces"]
["src/nvim/indent_c.c", ["                  goto term_again;", "                ++curwin->w_cursor.lnum;", "                curwin->w_cursor.col = 0;"], "readability/increment"]
["src/nvim/indent_c.c", ["  }", "  /*", "   * If the NEXT line is a function declaration, the current"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  if (cur_curpos.lnum < curbuf->b_ml.ml_line_count", "          && !cin_nocode(theline)", "          && vim_strchr(theline, '{') == NULL"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["          && !cin_nocode(theline)", "          && vim_strchr(theline, '{') == NULL", "          && vim_strchr(theline, '}') == NULL"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["          && vim_strchr(theline, '{') == NULL", "          && vim_strchr(theline, '}') == NULL", "          && !cin_ends_in(theline, (char_u *)\":\", NULL)"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["          && vim_strchr(theline, '}') == NULL", "          && !cin_ends_in(theline, (char_u *)\":\", NULL)", "          && !cin_ends_in(theline, (char_u *)\",\", NULL)"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["          && !cin_ends_in(theline, (char_u *)\":\", NULL)", "          && !cin_ends_in(theline, (char_u *)\",\", NULL)", "          && cin_isfuncdecl(NULL, cur_curpos.lnum + 1,"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["          && !cin_ends_in(theline, (char_u *)\",\", NULL)", "          && cin_isfuncdecl(NULL, cur_curpos.lnum + 1,", "              cur_curpos.lnum + 1)"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["          && cin_isfuncdecl(NULL, cur_curpos.lnum + 1,", "              cur_curpos.lnum + 1)", "          && !cin_isterminated(theline, false, true)) {"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["              cur_curpos.lnum + 1)", "          && !cin_isterminated(theline, false, true)) {", "    amount = curbuf->b_ind_func_type;"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["          && cin_isfuncdecl(NULL, cur_curpos.lnum + 1,", "              cur_curpos.lnum + 1)", "          && !cin_isterminated(theline, false, true)) {"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["", "    if (cin_nocode(l))", "      continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * If the previous line ends in ',', use one level of"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "      /* For a line ending in ',' that is a continuation line go", "       * back to the first line with a backslash:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        l = ml_get(curwin->w_cursor.lnum - 1);", "        if (*l == NUL || l[STRLEN(l) - 1] != '\\\\')", "          break;"], "readability/braces"]
["src/nvim/indent_c.c", ["          break;", "        --curwin->w_cursor.lnum;", "        curwin->w_cursor.col = 0;"], "readability/increment"]
["src/nvim/indent_c.c", ["", "      if (amount == 0)", "        amount = cin_first_id_amount();"], "readability/braces"]
["src/nvim/indent_c.c", ["        amount = cin_first_id_amount();", "      if (amount == 0)", "        amount = ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * If the line looks like a function declaration, and we're"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * Finding the closing '}' of a previous function.  Put"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["     */", "    if (*skipwhite(l) == '}')", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*\t\t\t    (matching {)", "     * If the previous line ends on '};' (maybe followed by"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["     */", "    if (cin_ends_in(l, (char_u *)\"};\", NULL))", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * Find a line only has a semicolon that belongs to a previous"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      }", "      if (curwin->w_cursor.lnum > 0", "          && cin_ends_in(look, (char_u *)\"}\", NULL))"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * If the PREVIOUS line is a function declaration, the current"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * If the previous line ends in ';' and the line before the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      l = ml_get(curwin->w_cursor.lnum - 1);", "      if (cin_ends_in(l, (char_u *)\",\", NULL)", "          || (*l != NUL && l[STRLEN(l) - 1] == '\\\\'))"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * Doesn't look like anything interesting -- so just"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    if ((trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL)", "      curwin->w_cursor = *trypos;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "  /* add extra indent if the previous line ended in a backslash:", "   *\t      \"asdfasdf\\"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      cur_amount = cin_get_equal_amount(cur_curpos.lnum - 1);", "      if (cur_amount > 0)", "        amount = cur_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["        amount = cur_amount;", "      else if (cur_amount == 0)", "        amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["theend:", "  if (amount < 0)", "    amount = 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["  return amount;", "}", ""], "readability/fn_size"]
["src/nvim/indent_c.c", ["  if (lookfor == LOOKFOR_IF) {", "    elselevel = 1;", "    whilelevel = 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["  } else {", "    elselevel = 0;", "    whilelevel = 1;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * if we've gone outside the braces entirely,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * and if the brace enclosing this is further"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["     */", "    if (theirscope->lnum < ourscope)", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * and if they're enclosed in a *deeper* brace,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["     */", "    if (theirscope->lnum > ourscope)", "      continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * if it was an \"else\" (that's not an \"else if\")"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      mightbeif = cin_skipcomment(look + 4);", "      if (!cin_isif(mightbeif))", "        ++elselevel;"], "readability/braces"]
["src/nvim/indent_c.c", ["      if (!cin_isif(mightbeif))", "        ++elselevel;", "      continue;"], "readability/increment"]
["src/nvim/indent_c.c", ["", "    /*", "     * if it was a \"while\" then we need to go back to"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    if (cin_iswhileofdo(look, curwin->w_cursor.lnum)) {", "      ++whilelevel;", "      continue;"], "readability/increment"]
["src/nvim/indent_c.c", ["    if (cin_isif(look)) {", "      elselevel--;", "      /*"], "readability/braces"]
["src/nvim/indent_c.c", ["      elselevel--;", "      /*", "       * When looking for an \"if\" ignore \"while\"s that"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["       */", "      if (elselevel == 0 && lookfor == LOOKFOR_IF)", "        whilelevel = 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * if we've used up all the elses, then"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Do C or expression indenting on the current line."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["{", "  if (*curbuf->b_p_inde != NUL)", "    fixthisline(get_expr_indent);"], "readability/braces"]
["src/nvim/indent_c.c", ["    fixthisline(get_expr_indent);", "  else", "    fixthisline(get_c_indent);"], "readability/braces"]
["src/nvim/keymap.c", ["", "/*", " * Some useful tables."], "readability/old_style_comment"]
["src/nvim/keymap.c", ["", "/*", " * Shifted key terminal codes and their unshifted equivalent."], "readability/old_style_comment"]
["src/nvim/keymap.c", ["{", "  /*  mod mask\t    with modifier\t\twithout modifier */", "  MOD_MASK_SHIFT, '&', '9',                   '@', '1',         /* begin */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["{", "  /*  mod mask\t    with modifier\t\twithout modifier */", "  MOD_MASK_SHIFT, '&', '9',                   '@', '1',         /* begin */"], "whitespace/tab"]
["src/nvim/keymap.c", ["  /*  mod mask\t    with modifier\t\twithout modifier */", "  MOD_MASK_SHIFT, '&', '9',                   '@', '1',         /* begin */", "  MOD_MASK_SHIFT, '&', '0',                   '@', '2',         /* cancel */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '&', '9',                   '@', '1',         /* begin */", "  MOD_MASK_SHIFT, '&', '0',                   '@', '2',         /* cancel */", "  MOD_MASK_SHIFT, '*', '1',                   '@', '4',         /* command */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '&', '0',                   '@', '2',         /* cancel */", "  MOD_MASK_SHIFT, '*', '1',                   '@', '4',         /* command */", "  MOD_MASK_SHIFT, '*', '2',                   '@', '5',         /* copy */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '*', '1',                   '@', '4',         /* command */", "  MOD_MASK_SHIFT, '*', '2',                   '@', '5',         /* copy */", "  MOD_MASK_SHIFT, '*', '3',                   '@', '6',         /* create */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '*', '2',                   '@', '5',         /* copy */", "  MOD_MASK_SHIFT, '*', '3',                   '@', '6',         /* create */", "  MOD_MASK_SHIFT, '*', '4',                   'k', 'D',         /* delete char */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '*', '3',                   '@', '6',         /* create */", "  MOD_MASK_SHIFT, '*', '4',                   'k', 'D',         /* delete char */", "  MOD_MASK_SHIFT, '*', '5',                   'k', 'L',         /* delete line */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '*', '3',                   '@', '6',         /* create */", "  MOD_MASK_SHIFT, '*', '4',                   'k', 'D',         /* delete char */", "  MOD_MASK_SHIFT, '*', '5',                   'k', 'L',         /* delete line */"], "whitespace/line_length"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '*', '4',                   'k', 'D',         /* delete char */", "  MOD_MASK_SHIFT, '*', '5',                   'k', 'L',         /* delete line */", "  MOD_MASK_SHIFT, '*', '7',                   '@', '7',         /* end */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '*', '4',                   'k', 'D',         /* delete char */", "  MOD_MASK_SHIFT, '*', '5',                   'k', 'L',         /* delete line */", "  MOD_MASK_SHIFT, '*', '7',                   '@', '7',         /* end */"], "whitespace/line_length"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '*', '5',                   'k', 'L',         /* delete line */", "  MOD_MASK_SHIFT, '*', '7',                   '@', '7',         /* end */", "  MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_END,    '@', '7',         /* end */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '*', '7',                   '@', '7',         /* end */", "  MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_END,    '@', '7',         /* end */", "  MOD_MASK_SHIFT, '*', '9',                   '@', '9',         /* exit */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_END,    '@', '7',         /* end */", "  MOD_MASK_SHIFT, '*', '9',                   '@', '9',         /* exit */", "  MOD_MASK_SHIFT, '*', '0',                   '@', '0',         /* find */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '*', '9',                   '@', '9',         /* exit */", "  MOD_MASK_SHIFT, '*', '0',                   '@', '0',         /* find */", "  MOD_MASK_SHIFT, '#', '1',                   '%', '1',         /* help */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '*', '0',                   '@', '0',         /* find */", "  MOD_MASK_SHIFT, '#', '1',                   '%', '1',         /* help */", "  MOD_MASK_SHIFT, '#', '2',                   'k', 'h',         /* home */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '#', '1',                   '%', '1',         /* help */", "  MOD_MASK_SHIFT, '#', '2',                   'k', 'h',         /* home */", "  MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_HOME,   'k', 'h',         /* home */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '#', '2',                   'k', 'h',         /* home */", "  MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_HOME,   'k', 'h',         /* home */", "  MOD_MASK_SHIFT, '#', '3',                   'k', 'I',         /* insert */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_HOME,   'k', 'h',         /* home */", "  MOD_MASK_SHIFT, '#', '3',                   'k', 'I',         /* insert */", "  MOD_MASK_SHIFT, '#', '4',                   'k', 'l',         /* left arrow */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '#', '3',                   'k', 'I',         /* insert */", "  MOD_MASK_SHIFT, '#', '4',                   'k', 'l',         /* left arrow */", "  MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_LEFT,   'k', 'l',         /* left arrow */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '#', '4',                   'k', 'l',         /* left arrow */", "  MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_LEFT,   'k', 'l',         /* left arrow */", "  MOD_MASK_SHIFT, '%', 'a',                   '%', '3',         /* message */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_LEFT,   'k', 'l',         /* left arrow */", "  MOD_MASK_SHIFT, '%', 'a',                   '%', '3',         /* message */", "  MOD_MASK_SHIFT, '%', 'b',                   '%', '4',         /* move */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '%', 'a',                   '%', '3',         /* message */", "  MOD_MASK_SHIFT, '%', 'b',                   '%', '4',         /* move */", "  MOD_MASK_SHIFT, '%', 'c',                   '%', '5',         /* next */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '%', 'b',                   '%', '4',         /* move */", "  MOD_MASK_SHIFT, '%', 'c',                   '%', '5',         /* next */", "  MOD_MASK_SHIFT, '%', 'd',                   '%', '7',         /* options */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '%', 'c',                   '%', '5',         /* next */", "  MOD_MASK_SHIFT, '%', 'd',                   '%', '7',         /* options */", "  MOD_MASK_SHIFT, '%', 'e',                   '%', '8',         /* previous */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '%', 'd',                   '%', '7',         /* options */", "  MOD_MASK_SHIFT, '%', 'e',                   '%', '8',         /* previous */", "  MOD_MASK_SHIFT, '%', 'f',                   '%', '9',         /* print */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '%', 'e',                   '%', '8',         /* previous */", "  MOD_MASK_SHIFT, '%', 'f',                   '%', '9',         /* print */", "  MOD_MASK_SHIFT, '%', 'g',                   '%', '0',         /* redo */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '%', 'f',                   '%', '9',         /* print */", "  MOD_MASK_SHIFT, '%', 'g',                   '%', '0',         /* redo */", "  MOD_MASK_SHIFT, '%', 'h',                   '&', '3',         /* replace */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '%', 'g',                   '%', '0',         /* redo */", "  MOD_MASK_SHIFT, '%', 'h',                   '&', '3',         /* replace */", "  MOD_MASK_SHIFT, '%', 'i',                   'k', 'r',         /* right arr. */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '%', 'h',                   '&', '3',         /* replace */", "  MOD_MASK_SHIFT, '%', 'i',                   'k', 'r',         /* right arr. */", "  MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_RIGHT,  'k', 'r',         /* right arr. */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '%', 'i',                   'k', 'r',         /* right arr. */", "  MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_RIGHT,  'k', 'r',         /* right arr. */", "  MOD_MASK_SHIFT, '%', 'j',                   '&', '5',         /* resume */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_RIGHT,  'k', 'r',         /* right arr. */", "  MOD_MASK_SHIFT, '%', 'j',                   '&', '5',         /* resume */", "  MOD_MASK_SHIFT, '!', '1',                   '&', '6',         /* save */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '%', 'j',                   '&', '5',         /* resume */", "  MOD_MASK_SHIFT, '!', '1',                   '&', '6',         /* save */", "  MOD_MASK_SHIFT, '!', '2',                   '&', '7',         /* suspend */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '!', '1',                   '&', '6',         /* save */", "  MOD_MASK_SHIFT, '!', '2',                   '&', '7',         /* suspend */", "  MOD_MASK_SHIFT, '!', '3',                   '&', '8',         /* undo */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '!', '2',                   '&', '7',         /* suspend */", "  MOD_MASK_SHIFT, '!', '3',                   '&', '8',         /* undo */", "  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_UP,     'k', 'u',         /* up arrow */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '!', '3',                   '&', '8',         /* undo */", "  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_UP,     'k', 'u',         /* up arrow */", "  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_DOWN,   'k', 'd',         /* down arrow */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_UP,     'k', 'u',         /* up arrow */", "  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_DOWN,   'k', 'd',         /* down arrow */", ""], "readability/old_style_comment"]
["src/nvim/keymap.c", ["", "  /* vt100 F1 */", "  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_XF1,    KS_EXTRA, (int)KE_XF1,"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["", "  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F1,     'k', '1',         /* F1 */", "  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F2,     'k', '2',"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F9,     'k', '9',", "  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F10,    'k', ';',         /* F10 */", ""], "readability/old_style_comment"]
["src/nvim/keymap.c", ["", "  /* TAB pseudo code*/", "  MOD_MASK_SHIFT, 'k', 'B',                   KS_EXTRA, (int)KE_TAB,"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["static struct mousetable {", "  int pseudo_code;              /* Code for pseudo mouse event */", "  int button;                   /* Which mouse button is it? */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  int pseudo_code;              /* Code for pseudo mouse event */", "  int button;                   /* Which mouse button is it? */", "  int is_click;                 /* Is it a mouse button click event? */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  int button;                   /* Which mouse button is it? */", "  int is_click;                 /* Is it a mouse button click event? */", "  int is_drag;                  /* Is it a mouse drag event? */"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  int is_click;                 /* Is it a mouse button click event? */", "  int is_drag;                  /* Is it a mouse drag event? */", "} mouse_table[] ="], "readability/old_style_comment"]
["src/nvim/keymap.c", ["{", "  {(int)KE_LEFTMOUSE,         MOUSE_LEFT,     TRUE,   FALSE},", "  {(int)KE_LEFTDRAG,          MOUSE_LEFT,     FALSE,  TRUE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["{", "  {(int)KE_LEFTMOUSE,         MOUSE_LEFT,     TRUE,   FALSE},", "  {(int)KE_LEFTDRAG,          MOUSE_LEFT,     FALSE,  TRUE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["{", "  {(int)KE_LEFTMOUSE,         MOUSE_LEFT,     TRUE,   FALSE},", "  {(int)KE_LEFTDRAG,          MOUSE_LEFT,     FALSE,  TRUE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_LEFTMOUSE,         MOUSE_LEFT,     TRUE,   FALSE},", "  {(int)KE_LEFTDRAG,          MOUSE_LEFT,     FALSE,  TRUE},", "  {(int)KE_LEFTRELEASE,       MOUSE_LEFT,     FALSE,  FALSE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_LEFTMOUSE,         MOUSE_LEFT,     TRUE,   FALSE},", "  {(int)KE_LEFTDRAG,          MOUSE_LEFT,     FALSE,  TRUE},", "  {(int)KE_LEFTRELEASE,       MOUSE_LEFT,     FALSE,  FALSE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_LEFTMOUSE,         MOUSE_LEFT,     TRUE,   FALSE},", "  {(int)KE_LEFTDRAG,          MOUSE_LEFT,     FALSE,  TRUE},", "  {(int)KE_LEFTRELEASE,       MOUSE_LEFT,     FALSE,  FALSE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_LEFTDRAG,          MOUSE_LEFT,     FALSE,  TRUE},", "  {(int)KE_LEFTRELEASE,       MOUSE_LEFT,     FALSE,  FALSE},", "  {(int)KE_MIDDLEMOUSE,       MOUSE_MIDDLE,   TRUE,   FALSE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_LEFTDRAG,          MOUSE_LEFT,     FALSE,  TRUE},", "  {(int)KE_LEFTRELEASE,       MOUSE_LEFT,     FALSE,  FALSE},", "  {(int)KE_MIDDLEMOUSE,       MOUSE_MIDDLE,   TRUE,   FALSE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_LEFTDRAG,          MOUSE_LEFT,     FALSE,  TRUE},", "  {(int)KE_LEFTRELEASE,       MOUSE_LEFT,     FALSE,  FALSE},", "  {(int)KE_MIDDLEMOUSE,       MOUSE_MIDDLE,   TRUE,   FALSE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_LEFTRELEASE,       MOUSE_LEFT,     FALSE,  FALSE},", "  {(int)KE_MIDDLEMOUSE,       MOUSE_MIDDLE,   TRUE,   FALSE},", "  {(int)KE_MIDDLEDRAG,        MOUSE_MIDDLE,   FALSE,  TRUE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_LEFTRELEASE,       MOUSE_LEFT,     FALSE,  FALSE},", "  {(int)KE_MIDDLEMOUSE,       MOUSE_MIDDLE,   TRUE,   FALSE},", "  {(int)KE_MIDDLEDRAG,        MOUSE_MIDDLE,   FALSE,  TRUE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_LEFTRELEASE,       MOUSE_LEFT,     FALSE,  FALSE},", "  {(int)KE_MIDDLEMOUSE,       MOUSE_MIDDLE,   TRUE,   FALSE},", "  {(int)KE_MIDDLEDRAG,        MOUSE_MIDDLE,   FALSE,  TRUE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_MIDDLEMOUSE,       MOUSE_MIDDLE,   TRUE,   FALSE},", "  {(int)KE_MIDDLEDRAG,        MOUSE_MIDDLE,   FALSE,  TRUE},", "  {(int)KE_MIDDLERELEASE,     MOUSE_MIDDLE,   FALSE,  FALSE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_MIDDLEMOUSE,       MOUSE_MIDDLE,   TRUE,   FALSE},", "  {(int)KE_MIDDLEDRAG,        MOUSE_MIDDLE,   FALSE,  TRUE},", "  {(int)KE_MIDDLERELEASE,     MOUSE_MIDDLE,   FALSE,  FALSE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_MIDDLEMOUSE,       MOUSE_MIDDLE,   TRUE,   FALSE},", "  {(int)KE_MIDDLEDRAG,        MOUSE_MIDDLE,   FALSE,  TRUE},", "  {(int)KE_MIDDLERELEASE,     MOUSE_MIDDLE,   FALSE,  FALSE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_MIDDLEDRAG,        MOUSE_MIDDLE,   FALSE,  TRUE},", "  {(int)KE_MIDDLERELEASE,     MOUSE_MIDDLE,   FALSE,  FALSE},", "  {(int)KE_RIGHTMOUSE,        MOUSE_RIGHT,    TRUE,   FALSE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_MIDDLEDRAG,        MOUSE_MIDDLE,   FALSE,  TRUE},", "  {(int)KE_MIDDLERELEASE,     MOUSE_MIDDLE,   FALSE,  FALSE},", "  {(int)KE_RIGHTMOUSE,        MOUSE_RIGHT,    TRUE,   FALSE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_MIDDLEDRAG,        MOUSE_MIDDLE,   FALSE,  TRUE},", "  {(int)KE_MIDDLERELEASE,     MOUSE_MIDDLE,   FALSE,  FALSE},", "  {(int)KE_RIGHTMOUSE,        MOUSE_RIGHT,    TRUE,   FALSE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_MIDDLERELEASE,     MOUSE_MIDDLE,   FALSE,  FALSE},", "  {(int)KE_RIGHTMOUSE,        MOUSE_RIGHT,    TRUE,   FALSE},", "  {(int)KE_RIGHTDRAG,         MOUSE_RIGHT,    FALSE,  TRUE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_MIDDLERELEASE,     MOUSE_MIDDLE,   FALSE,  FALSE},", "  {(int)KE_RIGHTMOUSE,        MOUSE_RIGHT,    TRUE,   FALSE},", "  {(int)KE_RIGHTDRAG,         MOUSE_RIGHT,    FALSE,  TRUE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_MIDDLERELEASE,     MOUSE_MIDDLE,   FALSE,  FALSE},", "  {(int)KE_RIGHTMOUSE,        MOUSE_RIGHT,    TRUE,   FALSE},", "  {(int)KE_RIGHTDRAG,         MOUSE_RIGHT,    FALSE,  TRUE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_RIGHTMOUSE,        MOUSE_RIGHT,    TRUE,   FALSE},", "  {(int)KE_RIGHTDRAG,         MOUSE_RIGHT,    FALSE,  TRUE},", "  {(int)KE_RIGHTRELEASE,      MOUSE_RIGHT,    FALSE,  FALSE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_RIGHTMOUSE,        MOUSE_RIGHT,    TRUE,   FALSE},", "  {(int)KE_RIGHTDRAG,         MOUSE_RIGHT,    FALSE,  TRUE},", "  {(int)KE_RIGHTRELEASE,      MOUSE_RIGHT,    FALSE,  FALSE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_RIGHTMOUSE,        MOUSE_RIGHT,    TRUE,   FALSE},", "  {(int)KE_RIGHTDRAG,         MOUSE_RIGHT,    FALSE,  TRUE},", "  {(int)KE_RIGHTRELEASE,      MOUSE_RIGHT,    FALSE,  FALSE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_RIGHTDRAG,         MOUSE_RIGHT,    FALSE,  TRUE},", "  {(int)KE_RIGHTRELEASE,      MOUSE_RIGHT,    FALSE,  FALSE},", "  {(int)KE_X1MOUSE,           MOUSE_X1,       TRUE,   FALSE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_RIGHTDRAG,         MOUSE_RIGHT,    FALSE,  TRUE},", "  {(int)KE_RIGHTRELEASE,      MOUSE_RIGHT,    FALSE,  FALSE},", "  {(int)KE_X1MOUSE,           MOUSE_X1,       TRUE,   FALSE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_RIGHTDRAG,         MOUSE_RIGHT,    FALSE,  TRUE},", "  {(int)KE_RIGHTRELEASE,      MOUSE_RIGHT,    FALSE,  FALSE},", "  {(int)KE_X1MOUSE,           MOUSE_X1,       TRUE,   FALSE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_RIGHTRELEASE,      MOUSE_RIGHT,    FALSE,  FALSE},", "  {(int)KE_X1MOUSE,           MOUSE_X1,       TRUE,   FALSE},", "  {(int)KE_X1DRAG,            MOUSE_X1,       FALSE,  TRUE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_RIGHTRELEASE,      MOUSE_RIGHT,    FALSE,  FALSE},", "  {(int)KE_X1MOUSE,           MOUSE_X1,       TRUE,   FALSE},", "  {(int)KE_X1DRAG,            MOUSE_X1,       FALSE,  TRUE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_RIGHTRELEASE,      MOUSE_RIGHT,    FALSE,  FALSE},", "  {(int)KE_X1MOUSE,           MOUSE_X1,       TRUE,   FALSE},", "  {(int)KE_X1DRAG,            MOUSE_X1,       FALSE,  TRUE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_X1MOUSE,           MOUSE_X1,       TRUE,   FALSE},", "  {(int)KE_X1DRAG,            MOUSE_X1,       FALSE,  TRUE},", "  {(int)KE_X1RELEASE,         MOUSE_X1,       FALSE,  FALSE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_X1MOUSE,           MOUSE_X1,       TRUE,   FALSE},", "  {(int)KE_X1DRAG,            MOUSE_X1,       FALSE,  TRUE},", "  {(int)KE_X1RELEASE,         MOUSE_X1,       FALSE,  FALSE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_X1MOUSE,           MOUSE_X1,       TRUE,   FALSE},", "  {(int)KE_X1DRAG,            MOUSE_X1,       FALSE,  TRUE},", "  {(int)KE_X1RELEASE,         MOUSE_X1,       FALSE,  FALSE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_X1DRAG,            MOUSE_X1,       FALSE,  TRUE},", "  {(int)KE_X1RELEASE,         MOUSE_X1,       FALSE,  FALSE},", "  {(int)KE_X2MOUSE,           MOUSE_X2,       TRUE,   FALSE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_X1DRAG,            MOUSE_X1,       FALSE,  TRUE},", "  {(int)KE_X1RELEASE,         MOUSE_X1,       FALSE,  FALSE},", "  {(int)KE_X2MOUSE,           MOUSE_X2,       TRUE,   FALSE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_X1DRAG,            MOUSE_X1,       FALSE,  TRUE},", "  {(int)KE_X1RELEASE,         MOUSE_X1,       FALSE,  FALSE},", "  {(int)KE_X2MOUSE,           MOUSE_X2,       TRUE,   FALSE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_X1RELEASE,         MOUSE_X1,       FALSE,  FALSE},", "  {(int)KE_X2MOUSE,           MOUSE_X2,       TRUE,   FALSE},", "  {(int)KE_X2DRAG,            MOUSE_X2,       FALSE,  TRUE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_X1RELEASE,         MOUSE_X1,       FALSE,  FALSE},", "  {(int)KE_X2MOUSE,           MOUSE_X2,       TRUE,   FALSE},", "  {(int)KE_X2DRAG,            MOUSE_X2,       FALSE,  TRUE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_X1RELEASE,         MOUSE_X1,       FALSE,  FALSE},", "  {(int)KE_X2MOUSE,           MOUSE_X2,       TRUE,   FALSE},", "  {(int)KE_X2DRAG,            MOUSE_X2,       FALSE,  TRUE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_X2MOUSE,           MOUSE_X2,       TRUE,   FALSE},", "  {(int)KE_X2DRAG,            MOUSE_X2,       FALSE,  TRUE},", "  {(int)KE_X2RELEASE,         MOUSE_X2,       FALSE,  FALSE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_X2MOUSE,           MOUSE_X2,       TRUE,   FALSE},", "  {(int)KE_X2DRAG,            MOUSE_X2,       FALSE,  TRUE},", "  {(int)KE_X2RELEASE,         MOUSE_X2,       FALSE,  FALSE},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_X2MOUSE,           MOUSE_X2,       TRUE,   FALSE},", "  {(int)KE_X2DRAG,            MOUSE_X2,       FALSE,  TRUE},", "  {(int)KE_X2RELEASE,         MOUSE_X2,       FALSE,  FALSE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_X2DRAG,            MOUSE_X2,       FALSE,  TRUE},", "  {(int)KE_X2RELEASE,         MOUSE_X2,       FALSE,  FALSE},", "  /* DRAG without CLICK */"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_X2DRAG,            MOUSE_X2,       FALSE,  TRUE},", "  {(int)KE_X2RELEASE,         MOUSE_X2,       FALSE,  FALSE},", "  /* DRAG without CLICK */"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_X2DRAG,            MOUSE_X2,       FALSE,  TRUE},", "  {(int)KE_X2RELEASE,         MOUSE_X2,       FALSE,  FALSE},", "  /* DRAG without CLICK */"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_X2RELEASE,         MOUSE_X2,       FALSE,  FALSE},", "  /* DRAG without CLICK */", "  {(int)KE_IGNORE,            MOUSE_RELEASE,  FALSE,  TRUE},"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  /* DRAG without CLICK */", "  {(int)KE_IGNORE,            MOUSE_RELEASE,  FALSE,  TRUE},", "  /* RELEASE without CLICK */"], "whitespace/braces"]
["src/nvim/keymap.c", ["  /* DRAG without CLICK */", "  {(int)KE_IGNORE,            MOUSE_RELEASE,  FALSE,  TRUE},", "  /* RELEASE without CLICK */"], "whitespace/braces"]
["src/nvim/keymap.c", ["  /* DRAG without CLICK */", "  {(int)KE_IGNORE,            MOUSE_RELEASE,  FALSE,  TRUE},", "  /* RELEASE without CLICK */"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_IGNORE,            MOUSE_RELEASE,  FALSE,  TRUE},", "  /* RELEASE without CLICK */", "  {(int)KE_IGNORE,            MOUSE_RELEASE,  FALSE,  FALSE},"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  /* RELEASE without CLICK */", "  {(int)KE_IGNORE,            MOUSE_RELEASE,  FALSE,  FALSE},", "  {0,                         0,              0,      0},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  /* RELEASE without CLICK */", "  {(int)KE_IGNORE,            MOUSE_RELEASE,  FALSE,  FALSE},", "  {0,                         0,              0,      0},"], "whitespace/braces"]
["src/nvim/keymap.c", ["  /* RELEASE without CLICK */", "  {(int)KE_IGNORE,            MOUSE_RELEASE,  FALSE,  FALSE},", "  {0,                         0,              0,      0},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_IGNORE,            MOUSE_RELEASE,  FALSE,  FALSE},", "  {0,                         0,              0,      0},", "};"], "whitespace/braces"]
["src/nvim/keymap.c", ["  {(int)KE_IGNORE,            MOUSE_RELEASE,  FALSE,  FALSE},", "  {0,                         0,              0,      0},", "};"], "whitespace/braces"]
["src/nvim/keymap.c", ["", "/*", " * Return a string which contains the name of the given key when the given"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["", "  /* Key that stands for a normal character. */", "  if (IS_SPECIAL(c) && KEY2TERMCAP0(c) == KS_KEY)"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  /* Key that stands for a normal character. */", "  if (IS_SPECIAL(c) && KEY2TERMCAP0(c) == KS_KEY)", "    c = KEY2TERMCAP1(c);"], "readability/braces"]
["src/nvim/keymap.c", ["", "  /*", "   * Translate shifted special keys into unshifted keys and set modifier."], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  if (IS_SPECIAL(c)) {", "    for (i = 0; modifier_keys_table[i] != 0; i += MOD_KEYS_ENTRY_SIZE)", "      if (       KEY2TERMCAP0(c) == (int)modifier_keys_table[i + 1]"], "readability/braces"]
["src/nvim/keymap.c", ["      if (       KEY2TERMCAP0(c) == (int)modifier_keys_table[i + 1]", "                 && (int)KEY2TERMCAP1(c) == (int)modifier_keys_table[i + 2]) {", "        modifiers |= modifier_keys_table[i];"], "whitespace/alignment"]
["src/nvim/keymap.c", ["        c = TERMCAP2KEY(modifier_keys_table[i + 3],", "            modifier_keys_table[i + 4]);", "        break;"], "whitespace/alignment"]
["src/nvim/keymap.c", ["", "  /* try to find the key in the special key table */", "  table_idx = find_special_key_in_table(c);"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["", "  /*", "   * When not a known special key, and not a printable character, try to"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["      modifiers |= MOD_MASK_ALT;", "      /* try again, to find the un-alted key in the special key table */", "      table_idx = find_special_key_in_table(c);"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["", "  /* translate the modifier into a string */", "  for (i = 0; mod_mask_table[i].name != 'A'; i++)"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["  /* translate the modifier into a string */", "  for (i = 0; mod_mask_table[i].name != 'A'; i++)", "    if ((modifiers & mod_mask_table[i].mod_mask)"], "readability/braces"]
["src/nvim/keymap.c", ["", "  if (table_idx < 0) {          /* unknown special key, may output t_xx */", "    if (IS_SPECIAL(c)) {"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["        s = transchar(c);", "        while (*s)", "          string[idx++] = *s++;"], "readability/braces"]
["src/nvim/keymap.c", ["", "    /* Which modifiers are given? */", "    modifiers = 0x0;"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["", "/*", " * Try to find key \"c\" in the special key table."], "readability/old_style_comment"]
["src/nvim/keymap.c", ["", "/*", " * Look up the given mouse code to return the relevant information in the other"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["", "  for (i = 0; mouse_table[i].pseudo_code; i++)", "    if (code == mouse_table[i].pseudo_code) {"], "readability/braces"]
["src/nvim/keymap.c", ["    }", "  return 0;         /* Shouldn't get here */", "}"], "readability/old_style_comment"]
["src/nvim/keymap.c", ["      }", "      ++src;", "    }"], "readability/increment"]
["src/nvim/keymap.h", ["", "/*", " * Keycode definitions for special keys."], "readability/old_style_comment"]
["src/nvim/keymap.h", ["", "/*", " * For MSDOS some keys produce codes larger than 0xff. They are split into two"], "readability/old_style_comment"]
["src/nvim/keymap.h", ["", "/*", " * K_SPECIAL is the first byte of a special key code and is always followed by"], "readability/old_style_comment"]
["src/nvim/keymap.h", ["", "/*", " * Positive characters are \"normal\" characters."], "readability/old_style_comment"]
["src/nvim/keymap.h", ["", "/*", " * Characters 0x0100 - 0x01ff have a special meaning for abbreviations."], "readability/old_style_comment"]
["src/nvim/keymap.h", ["", "/*", " * NUL cannot be in the input string, therefore it is replaced by"], "readability/old_style_comment"]
["src/nvim/keymap.h", ["", "/*", " * K_SPECIAL cannot be in the input string, therefore it is replaced by"], "readability/old_style_comment"]
["src/nvim/keymap.h", ["", "/*", " * KS_EXTRA is used for keys that have no termcap name"], "readability/old_style_comment"]
["src/nvim/keymap.h", ["", "/*", " * KS_MODIFIER is used when a modifier is given for a (special) key"], "readability/old_style_comment"]
["src/nvim/keymap.h", ["", "/*", " * These are used for the GUI"], "readability/old_style_comment"]
["src/nvim/keymap.h", ["", "/*", " * Used for switching Select mode back on after a mapping or menu."], "readability/old_style_comment"]
["src/nvim/keymap.h", ["", "/*", " * Filler used after KS_SPECIAL and others"], "readability/old_style_comment"]
["src/nvim/keymap.h", ["", "/*", " * translation of three byte code \"K_SPECIAL a b\" into int \"K_xxx\" and back"], "readability/old_style_comment"]
["src/nvim/keymap.h", ["", "/*", " * get second or third byte when translating special key code into three bytes"], "readability/old_style_comment"]
["src/nvim/keymap.h", ["", "/*", " * get single int code from second byte after K_SPECIAL"], "readability/old_style_comment"]
["src/nvim/keymap.h", ["", "/*", " * the three byte codes are replaced with the following int when using vgetc()"], "readability/old_style_comment"]
["src/nvim/keymap.h", ["", "/*", " * Symbols for pseudo keys which are translated from the real key symbols"], "readability/old_style_comment"]
["src/nvim/keymap.h", ["", "/*", " * The length of the longest special key name, including modifiers."], "readability/old_style_comment"]
["src/nvim/lib/kbtree.h", ["// marker so line numbers and indices both start at 1", "/*-", " * Copyright 1997-1999, 2001, John-Mark Gurney."], "readability/old_style_comment"]
["src/nvim/lib/kbtree.h", ["", "#define\t__KB_KEY(type, x)\t(x->key)", "#define __KB_PTR(btr, x)\t(x->ptr)"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["#define\t__KB_KEY(type, x)\t(x->key)", "#define __KB_PTR(btr, x)\t(x->ptr)", ""], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["", "#define __KB_TREE_T(name,key_t,T)\t\t\t\t\t\t\\", "    typedef struct kbnode_##name##_s kbnode_##name##_t;     \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["", "#define __KB_TREE_T(name,key_t,T)\t\t\t\t\t\t\\", "    typedef struct kbnode_##name##_s kbnode_##name##_t;     \\"], "whitespace/comma"]
["src/nvim/lib/kbtree.h", ["#define __KB_TREE_T(name,key_t,T)\t\t\t\t\t\t\\", "    typedef struct kbnode_##name##_s kbnode_##name##_t;     \\", "    struct kbnode_##name##_s {              \\"], "whitespace/line_continuation"]
["src/nvim/lib/kbtree.h", ["    typedef struct kbnode_##name##_s kbnode_##name##_t;     \\", "    struct kbnode_##name##_s {              \\", "      int32_t n; \\"], "whitespace/line_continuation"]
["src/nvim/lib/kbtree.h", ["      bool is_internal; \\", "      key_t key[2*T-1]; \\", "      kbnode_##name##_t *ptr[]; \\"], "whitespace/operators"]
["src/nvim/lib/kbtree.h", ["        kbnode_##name##_t *root; \\", "        int\tn_keys, n_nodes; \\", "    } kbtree_##name##_t; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["", "#define __kb_destroy(kbnode_t,b) do {\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tint i;                                                          \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["", "#define __kb_destroy(kbnode_t,b) do {\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tint i;                                                          \\"], "whitespace/comma"]
["src/nvim/lib/kbtree.h", ["#define __kb_destroy(kbnode_t,b) do {\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tint i;                                                          \\", "        unsigned int max = 8;\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["#define __kb_destroy(kbnode_t,b) do {\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tint i;                                                          \\", "        unsigned int max = 8;\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/line_continuation"]
["src/nvim/lib/kbtree.h", ["\t\tint i;                                                          \\", "        unsigned int max = 8;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tkbnode_t *x, **top, **stack = 0;\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["        unsigned int max = 8;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tkbnode_t *x, **top, **stack = 0;\t\t\t\t\t\t\t\t\\", "\t\tif (b->root) {\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tkbnode_t *x, **top, **stack = 0;\t\t\t\t\t\t\t\t\\", "\t\tif (b->root) {\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\ttop = stack = (kbnode_t**)xcalloc(max, sizeof(kbnode_t*));\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tif (b->root) {\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\ttop = stack = (kbnode_t**)xcalloc(max, sizeof(kbnode_t*));\t\\", "\t\t\t*top++ = (b)->root;\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tif (b->root) {\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\ttop = stack = (kbnode_t**)xcalloc(max, sizeof(kbnode_t*));\t\\", "\t\t\t*top++ = (b)->root;\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/operators"]
["src/nvim/lib/kbtree.h", ["\t\t\ttop = stack = (kbnode_t**)xcalloc(max, sizeof(kbnode_t*));\t\\", "\t\t\t*top++ = (b)->root;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\twhile (top != stack) {\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\ttop = stack = (kbnode_t**)xcalloc(max, sizeof(kbnode_t*));\t\\", "\t\t\t*top++ = (b)->root;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\twhile (top != stack) {\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/operators"]
["src/nvim/lib/kbtree.h", ["\t\t\t*top++ = (b)->root;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\twhile (top != stack) {\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tx = *--top;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\twhile (top != stack) {\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tx = *--top;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tif (x->is_internal == 0) { XFREE_CLEAR(x); continue; }\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tx = *--top;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tif (x->is_internal == 0) { XFREE_CLEAR(x); continue; }\t\t\t\\", "\t\t\t\tfor (i = 0; i <= x->n; ++i)\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tx = *--top;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tif (x->is_internal == 0) { XFREE_CLEAR(x); continue; }\t\t\t\\", "\t\t\t\tfor (i = 0; i <= x->n; ++i)\t\t\t\t\t\t\t\t\\"], "whitespace/newline"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tif (x->is_internal == 0) { XFREE_CLEAR(x); continue; }\t\t\t\\", "\t\t\t\tfor (i = 0; i <= x->n; ++i)\t\t\t\t\t\t\t\t\\", "\t\t\t\t\tif (__KB_PTR(b, x)[i]) {\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tif (x->is_internal == 0) { XFREE_CLEAR(x); continue; }\t\t\t\\", "\t\t\t\tfor (i = 0; i <= x->n; ++i)\t\t\t\t\t\t\t\t\\", "\t\t\t\t\tif (__KB_PTR(b, x)[i]) {\t\t\t\t\t\t\t\\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tif (x->is_internal == 0) { XFREE_CLEAR(x); continue; }\t\t\t\\", "\t\t\t\tfor (i = 0; i <= x->n; ++i)\t\t\t\t\t\t\t\t\\", "\t\t\t\t\tif (__KB_PTR(b, x)[i]) {\t\t\t\t\t\t\t\\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tfor (i = 0; i <= x->n; ++i)\t\t\t\t\t\t\t\t\\", "\t\t\t\t\tif (__KB_PTR(b, x)[i]) {\t\t\t\t\t\t\t\\", "\t\t\t\t\t\tif (top - stack == (int)max) {\t\t        \t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t\tif (__KB_PTR(b, x)[i]) {\t\t\t\t\t\t\t\\", "\t\t\t\t\t\tif (top - stack == (int)max) {\t\t        \t\\", "\t\t\t\t\t\t\tmax <<= 1;\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t\t\tif (top - stack == (int)max) {\t\t        \t\\", "\t\t\t\t\t\t\tmax <<= 1;\t\t\t\t\t\t\t\t\t\\", "\t\t\t\t\t\t\tstack = (kbnode_t**)xrealloc(stack, max * sizeof(kbnode_t*)); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t\t\t\tmax <<= 1;\t\t\t\t\t\t\t\t\t\\", "\t\t\t\t\t\t\tstack = (kbnode_t**)xrealloc(stack, max * sizeof(kbnode_t*)); \\", "\t\t\t\t\t\t\ttop = stack + (max>>1);\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t\t\t\tmax <<= 1;\t\t\t\t\t\t\t\t\t\\", "\t\t\t\t\t\t\tstack = (kbnode_t**)xrealloc(stack, max * sizeof(kbnode_t*)); \\", "\t\t\t\t\t\t\ttop = stack + (max>>1);\t\t\t\t\t\t\\"], "whitespace/operators"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t\t\t\tstack = (kbnode_t**)xrealloc(stack, max * sizeof(kbnode_t*)); \\", "\t\t\t\t\t\t\ttop = stack + (max>>1);\t\t\t\t\t\t\\", "\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t\t\t\ttop = stack + (max>>1);\t\t\t\t\t\t\\", "\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\t\t\t*top++ = __KB_PTR(b, x)[i];\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\t\t\t*top++ = __KB_PTR(b, x)[i];\t\t\t\t\t\t\\", "\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\t\t\t*top++ = __KB_PTR(b, x)[i];\t\t\t\t\t\t\\", "\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/operators"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t\t\t*top++ = __KB_PTR(b, x)[i];\t\t\t\t\t\t\\", "\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tXFREE_CLEAR(x);\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tXFREE_CLEAR(x);\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tXFREE_CLEAR(x);\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tXFREE_CLEAR(stack);\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tXFREE_CLEAR(stack);\t\t\t\t\t\t\t\t\t\t\t\\", "\t} while (0)"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tXFREE_CLEAR(stack);\t\t\t\t\t\t\t\t\t\t\t\\", "\t} while (0)", ""], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["", "#define __KB_GET_AUX1(name, key_t, kbnode_t, __cmp)\t\t\t\t\t\t\t\t\\", "\tstatic inline int __kb_getp_aux_##name(const kbnode_t * __restrict x, key_t * __restrict k, int *r) \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["#define __KB_GET_AUX1(name, key_t, kbnode_t, __cmp)\t\t\t\t\t\t\t\t\\", "\tstatic inline int __kb_getp_aux_##name(const kbnode_t * __restrict x, key_t * __restrict k, int *r) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["#define __KB_GET_AUX1(name, key_t, kbnode_t, __cmp)\t\t\t\t\t\t\t\t\\", "\tstatic inline int __kb_getp_aux_##name(const kbnode_t * __restrict x, key_t * __restrict k, int *r) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\tstatic inline int __kb_getp_aux_##name(const kbnode_t * __restrict x, key_t * __restrict k, int *r) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tint tr, *rr, begin = 0, end = x->n;\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\tstatic inline int __kb_getp_aux_##name(const kbnode_t * __restrict x, key_t * __restrict k, int *r) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tint tr, *rr, begin = 0, end = x->n;\t\t\t\t\t\t\t\t\\"], "whitespace/braces"]
["src/nvim/lib/kbtree.h", ["\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tint tr, *rr, begin = 0, end = x->n;\t\t\t\t\t\t\t\t\\", "\t\tif (x->n == 0) return -1;\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tint tr, *rr, begin = 0, end = x->n;\t\t\t\t\t\t\t\t\\", "\t\tif (x->n == 0) return -1;\t\t\t\t\t\t\t\t\t\t\\", "\t\trr = r? r : &tr;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tint tr, *rr, begin = 0, end = x->n;\t\t\t\t\t\t\t\t\\", "\t\tif (x->n == 0) return -1;\t\t\t\t\t\t\t\t\t\t\\", "\t\trr = r? r : &tr;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\tif (x->n == 0) return -1;\t\t\t\t\t\t\t\t\t\t\\", "\t\trr = r? r : &tr;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\twhile (begin < end) {\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\trr = r? r : &tr;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\twhile (begin < end) {\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\tint mid = (begin + end) >> 1;\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\twhile (begin < end) {\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\tint mid = (begin + end) >> 1;\t\t\t\t\t\t\t\t\\", "\t\t\tif (__cmp(__KB_KEY(key_t, x)[mid], *k) < 0) begin = mid + 1; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tint mid = (begin + end) >> 1;\t\t\t\t\t\t\t\t\\", "\t\t\tif (__cmp(__KB_KEY(key_t, x)[mid], *k) < 0) begin = mid + 1; \\", "\t\t\telse end = mid;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tint mid = (begin + end) >> 1;\t\t\t\t\t\t\t\t\\", "\t\t\tif (__cmp(__KB_KEY(key_t, x)[mid], *k) < 0) begin = mid + 1; \\", "\t\t\telse end = mid;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\t\tif (__cmp(__KB_KEY(key_t, x)[mid], *k) < 0) begin = mid + 1; \\", "\t\t\telse end = mid;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tif (__cmp(__KB_KEY(key_t, x)[mid], *k) < 0) begin = mid + 1; \\", "\t\t\telse end = mid;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\t\tif (__cmp(__KB_KEY(key_t, x)[mid], *k) < 0) begin = mid + 1; \\", "\t\t\telse end = mid;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/newline"]
["src/nvim/lib/kbtree.h", ["\t\t\telse end = mid;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif (begin == x->n) { *rr = 1; return x->n - 1; }\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif (begin == x->n) { *rr = 1; return x->n - 1; }\t\t\t\t\\", "\t\tif ((*rr = __cmp(*k, __KB_KEY(key_t, x)[begin])) < 0) --begin;\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif (begin == x->n) { *rr = 1; return x->n - 1; }\t\t\t\t\\", "\t\tif ((*rr = __cmp(*k, __KB_KEY(key_t, x)[begin])) < 0) --begin;\t\\"], "whitespace/newline"]
["src/nvim/lib/kbtree.h", ["\t\tif (begin == x->n) { *rr = 1; return x->n - 1; }\t\t\t\t\\", "\t\tif ((*rr = __cmp(*k, __KB_KEY(key_t, x)[begin])) < 0) --begin;\t\\", "\t\treturn begin;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tif (begin == x->n) { *rr = 1; return x->n - 1; }\t\t\t\t\\", "\t\tif ((*rr = __cmp(*k, __KB_KEY(key_t, x)[begin])) < 0) --begin;\t\\", "\t\treturn begin;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\tif ((*rr = __cmp(*k, __KB_KEY(key_t, x)[begin])) < 0) --begin;\t\\", "\t\treturn begin;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t}"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\treturn begin;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t}", ""], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["", "#define __KB_GET(name, key_t, kbnode_t)\t\t\t\t\t\t\t\t\t\t\t\\", "\tstatic key_t *kb_getp_##name(kbtree_##name##_t *b, key_t * __restrict k) \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["#define __KB_GET(name, key_t, kbnode_t)\t\t\t\t\t\t\t\t\t\t\t\\", "\tstatic key_t *kb_getp_##name(kbtree_##name##_t *b, key_t * __restrict k) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\tstatic key_t *kb_getp_##name(kbtree_##name##_t *b, key_t * __restrict k) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif (!b->root) { \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\tstatic key_t *kb_getp_##name(kbtree_##name##_t *b, key_t * __restrict k) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif (!b->root) { \\"], "whitespace/braces"]
["src/nvim/lib/kbtree.h", ["\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif (!b->root) { \\", "\t\t    return 0; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tif (!b->root) { \\", "\t\t    return 0; \\", "\t\t} \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t    return 0; \\", "\t\t} \\", "\t\tint i, r = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t} \\", "\t\tint i, r = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tkbnode_t *x = b->root;\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tint i, r = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tkbnode_t *x = b->root;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\twhile (x) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tkbnode_t *x = b->root;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\twhile (x) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\ti = __kb_getp_aux_##name(x, k, &r);\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\twhile (x) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\ti = __kb_getp_aux_##name(x, k, &r);\t\t\t\t\t\t\t\\", "\t\t\tif (i >= 0 && r == 0) return &__KB_KEY(key_t, x)[i];\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\ti = __kb_getp_aux_##name(x, k, &r);\t\t\t\t\t\t\t\\", "\t\t\tif (i >= 0 && r == 0) return &__KB_KEY(key_t, x)[i];\t\t\\", "\t\t\tif (x->is_internal == 0) return 0;\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\ti = __kb_getp_aux_##name(x, k, &r);\t\t\t\t\t\t\t\\", "\t\t\tif (i >= 0 && r == 0) return &__KB_KEY(key_t, x)[i];\t\t\\", "\t\t\tif (x->is_internal == 0) return 0;\t\t\t\t\t\t\t\\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\t\tif (i >= 0 && r == 0) return &__KB_KEY(key_t, x)[i];\t\t\\", "\t\t\tif (x->is_internal == 0) return 0;\t\t\t\t\t\t\t\\", "\t\t\tx = __KB_PTR(b, x)[i + 1];\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tif (i >= 0 && r == 0) return &__KB_KEY(key_t, x)[i];\t\t\\", "\t\t\tif (x->is_internal == 0) return 0;\t\t\t\t\t\t\t\\", "\t\t\tx = __KB_PTR(b, x)[i + 1];\t\t\t\t\t\t\t\t\t\\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\t\tif (x->is_internal == 0) return 0;\t\t\t\t\t\t\t\\", "\t\t\tx = __KB_PTR(b, x)[i + 1];\t\t\t\t\t\t\t\t\t\\", "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tx = __KB_PTR(b, x)[i + 1];\t\t\t\t\t\t\t\t\t\\", "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\treturn 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\treturn 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\treturn 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\tstatic inline key_t *kb_get_##name(kbtree_##name##_t *b, key_t k) \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\tstatic inline key_t *kb_get_##name(kbtree_##name##_t *b, key_t k) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\tstatic inline key_t *kb_get_##name(kbtree_##name##_t *b, key_t k) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\treturn kb_getp_##name(b, &k);\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\tstatic inline key_t *kb_get_##name(kbtree_##name##_t *b, key_t k) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\treturn kb_getp_##name(b, &k);\t\t\t\t\t\t\t\t\t\\"], "whitespace/braces"]
["src/nvim/lib/kbtree.h", ["\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\treturn kb_getp_##name(b, &k);\t\t\t\t\t\t\t\t\t\\", "\t}"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\treturn kb_getp_##name(b, &k);\t\t\t\t\t\t\t\t\t\\", "\t}", ""], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["", "#define __KB_INTERVAL(name, key_t, kbnode_t)\t\t\t\t\t\t\t\t\t\t\\", "\tstatic inline void kb_intervalp_##name(kbtree_##name##_t *b, key_t * __restrict k, key_t **lower, key_t **upper)\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["#define __KB_INTERVAL(name, key_t, kbnode_t)\t\t\t\t\t\t\t\t\t\t\\", "\tstatic inline void kb_intervalp_##name(kbtree_##name##_t *b, key_t * __restrict k, key_t **lower, key_t **upper)\t\\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["#define __KB_INTERVAL(name, key_t, kbnode_t)\t\t\t\t\t\t\t\t\t\t\\", "\tstatic inline void kb_intervalp_##name(kbtree_##name##_t *b, key_t * __restrict k, key_t **lower, key_t **upper)\t\\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\tstatic inline void kb_intervalp_##name(kbtree_##name##_t *b, key_t * __restrict k, key_t **lower, key_t **upper)\t\\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif (!b->root) { \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\tstatic inline void kb_intervalp_##name(kbtree_##name##_t *b, key_t * __restrict k, key_t **lower, key_t **upper)\t\\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif (!b->root) { \\"], "whitespace/braces"]
["src/nvim/lib/kbtree.h", ["\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif (!b->root) { \\", "\t\t    return; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tif (!b->root) { \\", "\t\t    return; \\", "\t\t} \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t    return; \\", "\t\t} \\", "\t\tint i, r = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t} \\", "\t\tint i, r = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tkbnode_t *x = b->root;\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tint i, r = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tkbnode_t *x = b->root;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t*lower = *upper = 0;\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tkbnode_t *x = b->root;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t*lower = *upper = 0;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\twhile (x) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tkbnode_t *x = b->root;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t*lower = *upper = 0;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\twhile (x) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/operators"]
["src/nvim/lib/kbtree.h", ["\t\t*lower = *upper = 0;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\twhile (x) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\ti = __kb_getp_aux_##name(x, k, &r);\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\twhile (x) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\ti = __kb_getp_aux_##name(x, k, &r);\t\t\t\t\t\t\t\\", "\t\t\tif (i >= 0 && r == 0) {\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\ti = __kb_getp_aux_##name(x, k, &r);\t\t\t\t\t\t\t\\", "\t\t\tif (i >= 0 && r == 0) {\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\t*lower = *upper = &__KB_KEY(key_t, x)[i];\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tif (i >= 0 && r == 0) {\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\t*lower = *upper = &__KB_KEY(key_t, x)[i];\t\t\t\t\\", "\t\t\t\treturn;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tif (i >= 0 && r == 0) {\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\t*lower = *upper = &__KB_KEY(key_t, x)[i];\t\t\t\t\\", "\t\t\t\treturn;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/operators"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t*lower = *upper = &__KB_KEY(key_t, x)[i];\t\t\t\t\\", "\t\t\t\treturn;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\treturn;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\tif (i >= 0) *lower = &__KB_KEY(key_t, x)[i];\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\tif (i >= 0) *lower = &__KB_KEY(key_t, x)[i];\t\t\t\t\\", "\t\t\tif (i < x->n - 1) *upper = &__KB_KEY(key_t, x)[i + 1];\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\tif (i >= 0) *lower = &__KB_KEY(key_t, x)[i];\t\t\t\t\\", "\t\t\tif (i < x->n - 1) *upper = &__KB_KEY(key_t, x)[i + 1];\t\t\\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\t\tif (i >= 0) *lower = &__KB_KEY(key_t, x)[i];\t\t\t\t\\", "\t\t\tif (i < x->n - 1) *upper = &__KB_KEY(key_t, x)[i + 1];\t\t\\", "\t\t\tif (x->is_internal == 0) return;\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tif (i >= 0) *lower = &__KB_KEY(key_t, x)[i];\t\t\t\t\\", "\t\t\tif (i < x->n - 1) *upper = &__KB_KEY(key_t, x)[i + 1];\t\t\\", "\t\t\tif (x->is_internal == 0) return;\t\t\t\t\t\t\t\\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\t\tif (i < x->n - 1) *upper = &__KB_KEY(key_t, x)[i + 1];\t\t\\", "\t\t\tif (x->is_internal == 0) return;\t\t\t\t\t\t\t\\", "\t\t\tx = __KB_PTR(b, x)[i + 1];\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tif (i < x->n - 1) *upper = &__KB_KEY(key_t, x)[i + 1];\t\t\\", "\t\t\tif (x->is_internal == 0) return;\t\t\t\t\t\t\t\\", "\t\t\tx = __KB_PTR(b, x)[i + 1];\t\t\t\t\t\t\t\t\t\\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\t\tif (x->is_internal == 0) return;\t\t\t\t\t\t\t\\", "\t\t\tx = __KB_PTR(b, x)[i + 1];\t\t\t\t\t\t\t\t\t\\", "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tx = __KB_PTR(b, x)[i + 1];\t\t\t\t\t\t\t\t\t\\", "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\tstatic inline void kb_interval_##name(kbtree_##name##_t *b, key_t k, key_t **lower, key_t **upper) \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\tstatic inline void kb_interval_##name(kbtree_##name##_t *b, key_t k, key_t **lower, key_t **upper) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\tstatic inline void kb_interval_##name(kbtree_##name##_t *b, key_t k, key_t **lower, key_t **upper) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\tstatic inline void kb_interval_##name(kbtree_##name##_t *b, key_t k, key_t **lower, key_t **upper) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tkb_intervalp_##name(b, &k, lower, upper);\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\tstatic inline void kb_interval_##name(kbtree_##name##_t *b, key_t k, key_t **lower, key_t **upper) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tkb_intervalp_##name(b, &k, lower, upper);\t\t\t\t\t\t\\"], "whitespace/braces"]
["src/nvim/lib/kbtree.h", ["\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tkb_intervalp_##name(b, &k, lower, upper);\t\t\t\t\t\t\\", "\t}"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tkb_intervalp_##name(b, &k, lower, upper);\t\t\t\t\t\t\\", "\t}", ""], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["", "#define __KB_PUT(name, key_t, kbnode_t, __cmp, T, ILEN)\t\t\t\t\t\t\t\t\t\\", "\t/* x must be an internal node */\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["#define __KB_PUT(name, key_t, kbnode_t, __cmp, T, ILEN)\t\t\t\t\t\t\t\t\t\\", "\t/* x must be an internal node */\t\t\t\t\t\t\t\t\t\\", "\tstatic inline void __kb_split_##name(kbtree_##name##_t *b, kbnode_t *x, int i, kbnode_t *y) \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t/* x must be an internal node */\t\t\t\t\t\t\t\t\t\\", "\tstatic inline void __kb_split_##name(kbtree_##name##_t *b, kbnode_t *x, int i, kbnode_t *y) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t/* x must be an internal node */\t\t\t\t\t\t\t\t\t\\", "\tstatic inline void __kb_split_##name(kbtree_##name##_t *b, kbnode_t *x, int i, kbnode_t *y) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\tstatic inline void __kb_split_##name(kbtree_##name##_t *b, kbnode_t *x, int i, kbnode_t *y) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tkbnode_t *z;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\tstatic inline void __kb_split_##name(kbtree_##name##_t *b, kbnode_t *x, int i, kbnode_t *y) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tkbnode_t *z;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/braces"]
["src/nvim/lib/kbtree.h", ["\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tkbnode_t *z;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tz = (kbnode_t*)xcalloc(1, y->is_internal? ILEN : sizeof(kbnode_##name##_t));\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tkbnode_t *z;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tz = (kbnode_t*)xcalloc(1, y->is_internal? ILEN : sizeof(kbnode_##name##_t));\t\\", "\t\t++b->n_nodes;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tkbnode_t *z;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tz = (kbnode_t*)xcalloc(1, y->is_internal? ILEN : sizeof(kbnode_##name##_t));\t\\", "\t\t++b->n_nodes;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/operators"]
["src/nvim/lib/kbtree.h", ["\t\tz = (kbnode_t*)xcalloc(1, y->is_internal? ILEN : sizeof(kbnode_##name##_t));\t\\", "\t\t++b->n_nodes;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tz->is_internal = y->is_internal;\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tz = (kbnode_t*)xcalloc(1, y->is_internal? ILEN : sizeof(kbnode_##name##_t));\t\\", "\t\t++b->n_nodes;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tz->is_internal = y->is_internal;\t\t\t\t\t\t\t\t\\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["\t\t++b->n_nodes;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tz->is_internal = y->is_internal;\t\t\t\t\t\t\t\t\\", "\t\tz->n = T - 1;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tz->is_internal = y->is_internal;\t\t\t\t\t\t\t\t\\", "\t\tz->n = T - 1;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tmemcpy(__KB_KEY(key_t, z), &__KB_KEY(key_t, y)[T], sizeof(key_t) * (T - 1)); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tz->n = T - 1;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tmemcpy(__KB_KEY(key_t, z), &__KB_KEY(key_t, y)[T], sizeof(key_t) * (T - 1)); \\", "\t\tif (y->is_internal) memcpy(__KB_PTR(b, z), &__KB_PTR(b, y)[T], sizeof(void*) * T); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tmemcpy(__KB_KEY(key_t, z), &__KB_KEY(key_t, y)[T], sizeof(key_t) * (T - 1)); \\", "\t\tif (y->is_internal) memcpy(__KB_PTR(b, z), &__KB_PTR(b, y)[T], sizeof(void*) * T); \\", "\t\ty->n = T - 1;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tmemcpy(__KB_KEY(key_t, z), &__KB_KEY(key_t, y)[T], sizeof(key_t) * (T - 1)); \\", "\t\tif (y->is_internal) memcpy(__KB_PTR(b, z), &__KB_PTR(b, y)[T], sizeof(void*) * T); \\", "\t\ty->n = T - 1;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\t\tmemcpy(__KB_KEY(key_t, z), &__KB_KEY(key_t, y)[T], sizeof(key_t) * (T - 1)); \\", "\t\tif (y->is_internal) memcpy(__KB_PTR(b, z), &__KB_PTR(b, y)[T], sizeof(void*) * T); \\", "\t\ty->n = T - 1;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\tmemcpy(__KB_KEY(key_t, z), &__KB_KEY(key_t, y)[T], sizeof(key_t) * (T - 1)); \\", "\t\tif (y->is_internal) memcpy(__KB_PTR(b, z), &__KB_PTR(b, y)[T], sizeof(void*) * T); \\", "\t\ty->n = T - 1;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/operators"]
["src/nvim/lib/kbtree.h", ["\t\tif (y->is_internal) memcpy(__KB_PTR(b, z), &__KB_PTR(b, y)[T], sizeof(void*) * T); \\", "\t\ty->n = T - 1;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tmemmove(&__KB_PTR(b, x)[i + 2], &__KB_PTR(b, x)[i + 1], sizeof(void*) * (unsigned int)(x->n - i)); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\ty->n = T - 1;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tmemmove(&__KB_PTR(b, x)[i + 2], &__KB_PTR(b, x)[i + 1], sizeof(void*) * (unsigned int)(x->n - i)); \\", "\t\t__KB_PTR(b, x)[i + 1] = z;\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\ty->n = T - 1;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tmemmove(&__KB_PTR(b, x)[i + 2], &__KB_PTR(b, x)[i + 1], sizeof(void*) * (unsigned int)(x->n - i)); \\", "\t\t__KB_PTR(b, x)[i + 1] = z;\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\t\ty->n = T - 1;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tmemmove(&__KB_PTR(b, x)[i + 2], &__KB_PTR(b, x)[i + 1], sizeof(void*) * (unsigned int)(x->n - i)); \\", "\t\t__KB_PTR(b, x)[i + 1] = z;\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/operators"]
["src/nvim/lib/kbtree.h", ["\t\tmemmove(&__KB_PTR(b, x)[i + 2], &__KB_PTR(b, x)[i + 1], sizeof(void*) * (unsigned int)(x->n - i)); \\", "\t\t__KB_PTR(b, x)[i + 1] = z;\t\t\t\t\t\t\t\t\t\t\\", "\t\tmemmove(&__KB_KEY(key_t, x)[i + 1], &__KB_KEY(key_t, x)[i], sizeof(key_t) * (unsigned int)(x->n - i)); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t__KB_PTR(b, x)[i + 1] = z;\t\t\t\t\t\t\t\t\t\t\\", "\t\tmemmove(&__KB_KEY(key_t, x)[i + 1], &__KB_KEY(key_t, x)[i], sizeof(key_t) * (unsigned int)(x->n - i)); \\", "\t\t__KB_KEY(key_t, x)[i] = __KB_KEY(key_t, y)[T - 1];\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t__KB_PTR(b, x)[i + 1] = z;\t\t\t\t\t\t\t\t\t\t\\", "\t\tmemmove(&__KB_KEY(key_t, x)[i + 1], &__KB_KEY(key_t, x)[i], sizeof(key_t) * (unsigned int)(x->n - i)); \\", "\t\t__KB_KEY(key_t, x)[i] = __KB_KEY(key_t, y)[T - 1];\t\t\t\\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\t\tmemmove(&__KB_KEY(key_t, x)[i + 1], &__KB_KEY(key_t, x)[i], sizeof(key_t) * (unsigned int)(x->n - i)); \\", "\t\t__KB_KEY(key_t, x)[i] = __KB_KEY(key_t, y)[T - 1];\t\t\t\\", "\t\t++x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t__KB_KEY(key_t, x)[i] = __KB_KEY(key_t, y)[T - 1];\t\t\t\\", "\t\t++x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t__KB_KEY(key_t, x)[i] = __KB_KEY(key_t, y)[T - 1];\t\t\t\\", "\t\t++x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["\t\t++x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\tstatic inline key_t *__kb_putp_aux_##name(kbtree_##name##_t *b, kbnode_t *x, key_t * __restrict k) \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\tstatic inline key_t *__kb_putp_aux_##name(kbtree_##name##_t *b, kbnode_t *x, key_t * __restrict k) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\tstatic inline key_t *__kb_putp_aux_##name(kbtree_##name##_t *b, kbnode_t *x, key_t * __restrict k) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\tstatic inline key_t *__kb_putp_aux_##name(kbtree_##name##_t *b, kbnode_t *x, key_t * __restrict k) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tint i = x->n - 1;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\tstatic inline key_t *__kb_putp_aux_##name(kbtree_##name##_t *b, kbnode_t *x, key_t * __restrict k) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tint i = x->n - 1;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/braces"]
["src/nvim/lib/kbtree.h", ["\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tint i = x->n - 1;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tkey_t *ret;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tint i = x->n - 1;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tkey_t *ret;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif (x->is_internal == 0) {\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tkey_t *ret;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif (x->is_internal == 0) {\t\t\t\t\t\t\t\t\t\t\\", "\t\t\ti = __kb_getp_aux_##name(x, k, 0);\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tif (x->is_internal == 0) {\t\t\t\t\t\t\t\t\t\t\\", "\t\t\ti = __kb_getp_aux_##name(x, k, 0);\t\t\t\t\t\t\t\\", "\t\t\tif (i != x->n - 1)\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\ti = __kb_getp_aux_##name(x, k, 0);\t\t\t\t\t\t\t\\", "\t\t\tif (i != x->n - 1)\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tmemmove(&__KB_KEY(key_t, x)[i + 2], &__KB_KEY(key_t, x)[i + 1], (unsigned int)(x->n - i - 1) * sizeof(key_t)); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\ti = __kb_getp_aux_##name(x, k, 0);\t\t\t\t\t\t\t\\", "\t\t\tif (i != x->n - 1)\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tmemmove(&__KB_KEY(key_t, x)[i + 2], &__KB_KEY(key_t, x)[i + 1], (unsigned int)(x->n - i - 1) * sizeof(key_t)); \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\t\tif (i != x->n - 1)\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tmemmove(&__KB_KEY(key_t, x)[i + 2], &__KB_KEY(key_t, x)[i + 1], (unsigned int)(x->n - i - 1) * sizeof(key_t)); \\", "\t\t\tret = &__KB_KEY(key_t, x)[i + 1];\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tif (i != x->n - 1)\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tmemmove(&__KB_KEY(key_t, x)[i + 2], &__KB_KEY(key_t, x)[i + 1], (unsigned int)(x->n - i - 1) * sizeof(key_t)); \\", "\t\t\tret = &__KB_KEY(key_t, x)[i + 1];\t\t\t\t\t\t\t\\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_KEY(key_t, x)[i + 2], &__KB_KEY(key_t, x)[i + 1], (unsigned int)(x->n - i - 1) * sizeof(key_t)); \\", "\t\t\tret = &__KB_KEY(key_t, x)[i + 1];\t\t\t\t\t\t\t\\", "\t\t\t*ret = *k;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tret = &__KB_KEY(key_t, x)[i + 1];\t\t\t\t\t\t\t\\", "\t\t\t*ret = *k;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t++x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tret = &__KB_KEY(key_t, x)[i + 1];\t\t\t\t\t\t\t\\", "\t\t\t*ret = *k;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t++x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/operators"]
["src/nvim/lib/kbtree.h", ["\t\t\t*ret = *k;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t++x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t} else {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t*ret = *k;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t++x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t} else {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["\t\t\t++x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t} else {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\ti = __kb_getp_aux_##name(x, k, 0) + 1;\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t} else {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\ti = __kb_getp_aux_##name(x, k, 0) + 1;\t\t\t\t\t\t\\", "\t\t\tif (__KB_PTR(b, x)[i]->n == 2 * T - 1) {\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\ti = __kb_getp_aux_##name(x, k, 0) + 1;\t\t\t\t\t\t\\", "\t\t\tif (__KB_PTR(b, x)[i]->n == 2 * T - 1) {\t\t\t\t\t\\", "\t\t\t\t__kb_split_##name(b, x, i, __KB_PTR(b, x)[i]);\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tif (__KB_PTR(b, x)[i]->n == 2 * T - 1) {\t\t\t\t\t\\", "\t\t\t\t__kb_split_##name(b, x, i, __KB_PTR(b, x)[i]);\t\t\t\\", "\t\t\t\tif (__cmp(*k, __KB_KEY(key_t, x)[i]) > 0) ++i;\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t__kb_split_##name(b, x, i, __KB_PTR(b, x)[i]);\t\t\t\\", "\t\t\t\tif (__cmp(*k, __KB_KEY(key_t, x)[i]) > 0) ++i;\t\t\t\\", "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t__kb_split_##name(b, x, i, __KB_PTR(b, x)[i]);\t\t\t\\", "\t\t\t\tif (__cmp(*k, __KB_KEY(key_t, x)[i]) > 0) ++i;\t\t\t\\", "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tif (__cmp(*k, __KB_KEY(key_t, x)[i]) > 0) ++i;\t\t\t\\", "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\tret = __kb_putp_aux_##name(b, __KB_PTR(b, x)[i], k);\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\tret = __kb_putp_aux_##name(b, __KB_PTR(b, x)[i], k);\t\t\\", "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tret = __kb_putp_aux_##name(b, __KB_PTR(b, x)[i], k);\t\t\\", "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\treturn ret; \t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\treturn ret; \t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\treturn ret; \t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\tstatic inline key_t *kb_putp_##name(kbtree_##name##_t *b, key_t * __restrict k) \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\tstatic inline key_t *kb_putp_##name(kbtree_##name##_t *b, key_t * __restrict k) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\tstatic inline key_t *kb_putp_##name(kbtree_##name##_t *b, key_t * __restrict k) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\tstatic inline key_t *kb_putp_##name(kbtree_##name##_t *b, key_t * __restrict k) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif (!b->root) { \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\tstatic inline key_t *kb_putp_##name(kbtree_##name##_t *b, key_t * __restrict k) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif (!b->root) { \\"], "whitespace/braces"]
["src/nvim/lib/kbtree.h", ["\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif (!b->root) { \\", "\t\t\tb->root = (kbnode_t*)xcalloc(1, ILEN);\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tif (!b->root) { \\", "\t\t\tb->root = (kbnode_t*)xcalloc(1, ILEN);\t\t\t\t\t\t\\", "\t\t\t++b->n_nodes;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tif (!b->root) { \\", "\t\t\tb->root = (kbnode_t*)xcalloc(1, ILEN);\t\t\t\t\t\t\\", "\t\t\t++b->n_nodes;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/operators"]
["src/nvim/lib/kbtree.h", ["\t\t\tb->root = (kbnode_t*)xcalloc(1, ILEN);\t\t\t\t\t\t\\", "\t\t\t++b->n_nodes;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t} \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tb->root = (kbnode_t*)xcalloc(1, ILEN);\t\t\t\t\t\t\\", "\t\t\t++b->n_nodes;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t} \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["\t\t\t++b->n_nodes;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t} \\", "\t\tkbnode_t *r, *s;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t} \\", "\t\tkbnode_t *r, *s;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t++b->n_keys;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tkbnode_t *r, *s;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t++b->n_keys;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tr = b->root;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tkbnode_t *r, *s;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t++b->n_keys;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tr = b->root;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["\t\t++b->n_keys;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tr = b->root;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif (r->n == 2 * T - 1) {\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tr = b->root;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif (r->n == 2 * T - 1) {\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t++b->n_nodes;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tif (r->n == 2 * T - 1) {\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t++b->n_nodes;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\ts = (kbnode_t*)xcalloc(1, ILEN);\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tif (r->n == 2 * T - 1) {\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t++b->n_nodes;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\ts = (kbnode_t*)xcalloc(1, ILEN);\t\t\t\t\t\t\t\\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["\t\t\t++b->n_nodes;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\ts = (kbnode_t*)xcalloc(1, ILEN);\t\t\t\t\t\t\t\\", "\t\t\tb->root = s; s->is_internal = 1; s->n = 0;\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t++b->n_nodes;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\ts = (kbnode_t*)xcalloc(1, ILEN);\t\t\t\t\t\t\t\\", "\t\t\tb->root = s; s->is_internal = 1; s->n = 0;\t\t\t\t\t\\"], "whitespace/operators"]
["src/nvim/lib/kbtree.h", ["\t\t\ts = (kbnode_t*)xcalloc(1, ILEN);\t\t\t\t\t\t\t\\", "\t\t\tb->root = s; s->is_internal = 1; s->n = 0;\t\t\t\t\t\\", "\t\t\t__KB_PTR(b, s)[0] = r;\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\ts = (kbnode_t*)xcalloc(1, ILEN);\t\t\t\t\t\t\t\\", "\t\t\tb->root = s; s->is_internal = 1; s->n = 0;\t\t\t\t\t\\", "\t\t\t__KB_PTR(b, s)[0] = r;\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/newline"]
["src/nvim/lib/kbtree.h", ["\t\t\tb->root = s; s->is_internal = 1; s->n = 0;\t\t\t\t\t\\", "\t\t\t__KB_PTR(b, s)[0] = r;\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t__kb_split_##name(b, s, 0, r);\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t__KB_PTR(b, s)[0] = r;\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t__kb_split_##name(b, s, 0, r);\t\t\t\t\t\t\t\t\\", "\t\t\tr = s;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t__kb_split_##name(b, s, 0, r);\t\t\t\t\t\t\t\t\\", "\t\t\tr = s;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tr = s;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\treturn __kb_putp_aux_##name(b, r, k);\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\treturn __kb_putp_aux_##name(b, r, k);\t\t\t\t\t\t\t\\", "\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\treturn __kb_putp_aux_##name(b, r, k);\t\t\t\t\t\t\t\\", "\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\tstatic inline void kb_put_##name(kbtree_##name##_t *b, key_t k) \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\tstatic inline void kb_put_##name(kbtree_##name##_t *b, key_t k) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\tstatic inline void kb_put_##name(kbtree_##name##_t *b, key_t k) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tkb_putp_##name(b, &k);\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\tstatic inline void kb_put_##name(kbtree_##name##_t *b, key_t k) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tkb_putp_##name(b, &k);\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/braces"]
["src/nvim/lib/kbtree.h", ["\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tkb_putp_##name(b, &k);\t\t\t\t\t\t\t\t\t\t\t\\", "\t}"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tkb_putp_##name(b, &k);\t\t\t\t\t\t\t\t\t\t\t\\", "\t}", ""], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["", "#define __KB_DEL(name, key_t, kbnode_t, T)\t\t\t\t\t\t\t\t\t\t\t\\", "\tstatic inline key_t __kb_delp_aux_##name(kbtree_##name##_t *b, kbnode_t *x, key_t * __restrict k, int s) \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["#define __KB_DEL(name, key_t, kbnode_t, T)\t\t\t\t\t\t\t\t\t\t\t\\", "\tstatic inline key_t __kb_delp_aux_##name(kbtree_##name##_t *b, kbnode_t *x, key_t * __restrict k, int s) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["#define __KB_DEL(name, key_t, kbnode_t, T)\t\t\t\t\t\t\t\t\t\t\t\\", "\tstatic inline key_t __kb_delp_aux_##name(kbtree_##name##_t *b, kbnode_t *x, key_t * __restrict k, int s) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\tstatic inline key_t __kb_delp_aux_##name(kbtree_##name##_t *b, kbnode_t *x, key_t * __restrict k, int s) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tint yn, zn, i, r = 0;\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\tstatic inline key_t __kb_delp_aux_##name(kbtree_##name##_t *b, kbnode_t *x, key_t * __restrict k, int s) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tint yn, zn, i, r = 0;\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/braces"]
["src/nvim/lib/kbtree.h", ["\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tint yn, zn, i, r = 0;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tkbnode_t *xp, *y, *z;\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tint yn, zn, i, r = 0;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tkbnode_t *xp, *y, *z;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tkey_t kp;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tkbnode_t *xp, *y, *z;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tkey_t kp;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif (x == 0) return *k;\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tkey_t kp;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif (x == 0) return *k;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif (s) { /* s can only be 0, 1 or 2 */\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tkey_t kp;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif (x == 0) return *k;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif (s) { /* s can only be 0, 1 or 2 */\t\t\t\t\t\t\t\\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\tif (x == 0) return *k;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif (s) { /* s can only be 0, 1 or 2 */\t\t\t\t\t\t\t\\", "\t\t\tr = x->is_internal == 0? 0 : s == 1? 1 : -1;\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tif (s) { /* s can only be 0, 1 or 2 */\t\t\t\t\t\t\t\\", "\t\t\tr = x->is_internal == 0? 0 : s == 1? 1 : -1;\t\t\t\t\\", "\t\t\ti = s == 1? x->n - 1 : -1;\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tr = x->is_internal == 0? 0 : s == 1? 1 : -1;\t\t\t\t\\", "\t\t\ti = s == 1? x->n - 1 : -1;\t\t\t\t\t\t\t\t\t\\", "\t\t} else i = __kb_getp_aux_##name(x, k, &r);\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\ti = s == 1? x->n - 1 : -1;\t\t\t\t\t\t\t\t\t\\", "\t\t} else i = __kb_getp_aux_##name(x, k, &r);\t\t\t\t\t\t\\", "\t\tif (x->is_internal == 0) {\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\ti = s == 1? x->n - 1 : -1;\t\t\t\t\t\t\t\t\t\\", "\t\t} else i = __kb_getp_aux_##name(x, k, &r);\t\t\t\t\t\t\\", "\t\tif (x->is_internal == 0) {\t\t\t\t\t\t\t\t\t\t\\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\t\ti = s == 1? x->n - 1 : -1;\t\t\t\t\t\t\t\t\t\\", "\t\t} else i = __kb_getp_aux_##name(x, k, &r);\t\t\t\t\t\t\\", "\t\tif (x->is_internal == 0) {\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/newline"]
["src/nvim/lib/kbtree.h", ["\t\t} else i = __kb_getp_aux_##name(x, k, &r);\t\t\t\t\t\t\\", "\t\tif (x->is_internal == 0) {\t\t\t\t\t\t\t\t\t\t\\", "\t\t\tif (s == 2) ++i;\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tif (x->is_internal == 0) {\t\t\t\t\t\t\t\t\t\t\\", "\t\t\tif (s == 2) ++i;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\tkp = __KB_KEY(key_t, x)[i];\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tif (x->is_internal == 0) {\t\t\t\t\t\t\t\t\t\t\\", "\t\t\tif (s == 2) ++i;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\tkp = __KB_KEY(key_t, x)[i];\t\t\t\t\t\t\t\t\t\\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\t\tif (s == 2) ++i;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\tkp = __KB_KEY(key_t, x)[i];\t\t\t\t\t\t\t\t\t\\", "\t\t\tmemmove(&__KB_KEY(key_t, x)[i], &__KB_KEY(key_t, x)[i + 1], (unsigned int)(x->n - i - 1) * sizeof(key_t)); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tkp = __KB_KEY(key_t, x)[i];\t\t\t\t\t\t\t\t\t\\", "\t\t\tmemmove(&__KB_KEY(key_t, x)[i], &__KB_KEY(key_t, x)[i + 1], (unsigned int)(x->n - i - 1) * sizeof(key_t)); \\", "\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tkp = __KB_KEY(key_t, x)[i];\t\t\t\t\t\t\t\t\t\\", "\t\t\tmemmove(&__KB_KEY(key_t, x)[i], &__KB_KEY(key_t, x)[i + 1], (unsigned int)(x->n - i - 1) * sizeof(key_t)); \\", "\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\t\t\tmemmove(&__KB_KEY(key_t, x)[i], &__KB_KEY(key_t, x)[i + 1], (unsigned int)(x->n - i - 1) * sizeof(key_t)); \\", "\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\treturn kp;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tmemmove(&__KB_KEY(key_t, x)[i], &__KB_KEY(key_t, x)[i + 1], (unsigned int)(x->n - i - 1) * sizeof(key_t)); \\", "\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\treturn kp;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\treturn kp;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\treturn kp;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif (r == 0) {\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif (r == 0) {\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\tif ((yn = __KB_PTR(b, x)[i]->n) >= T) {\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tif (r == 0) {\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\tif ((yn = __KB_PTR(b, x)[i]->n) >= T) {\t\t\t\t\t\\", "\t\t\t\txp = __KB_PTR(b, x)[i];\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tif ((yn = __KB_PTR(b, x)[i]->n) >= T) {\t\t\t\t\t\\", "\t\t\t\txp = __KB_PTR(b, x)[i];\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tkp = __KB_KEY(key_t, x)[i];\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\txp = __KB_PTR(b, x)[i];\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tkp = __KB_KEY(key_t, x)[i];\t\t\t\t\t\t\t\t\\", "\t\t\t\t__KB_KEY(key_t, x)[i] = __kb_delp_aux_##name(b, xp, 0, 1); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tkp = __KB_KEY(key_t, x)[i];\t\t\t\t\t\t\t\t\\", "\t\t\t\t__KB_KEY(key_t, x)[i] = __kb_delp_aux_##name(b, xp, 0, 1); \\", "\t\t\t\treturn kp;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t__KB_KEY(key_t, x)[i] = __kb_delp_aux_##name(b, xp, 0, 1); \\", "\t\t\t\treturn kp;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t} else if ((zn = __KB_PTR(b, x)[i + 1]->n) >= T) {\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\treturn kp;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t} else if ((zn = __KB_PTR(b, x)[i + 1]->n) >= T) {\t\t\\", "\t\t\t\txp = __KB_PTR(b, x)[i + 1];\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t} else if ((zn = __KB_PTR(b, x)[i + 1]->n) >= T) {\t\t\\", "\t\t\t\txp = __KB_PTR(b, x)[i + 1];\t\t\t\t\t\t\t\t\\", "\t\t\t\tkp = __KB_KEY(key_t, x)[i];\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\txp = __KB_PTR(b, x)[i + 1];\t\t\t\t\t\t\t\t\\", "\t\t\t\tkp = __KB_KEY(key_t, x)[i];\t\t\t\t\t\t\t\t\\", "\t\t\t\t__KB_KEY(key_t, x)[i] = __kb_delp_aux_##name(b, xp, 0, 2); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tkp = __KB_KEY(key_t, x)[i];\t\t\t\t\t\t\t\t\\", "\t\t\t\t__KB_KEY(key_t, x)[i] = __kb_delp_aux_##name(b, xp, 0, 2); \\", "\t\t\t\treturn kp;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t__KB_KEY(key_t, x)[i] = __kb_delp_aux_##name(b, xp, 0, 2); \\", "\t\t\t\treturn kp;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t} else if (yn == T - 1 && zn == T - 1) {\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\treturn kp;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t} else if (yn == T - 1 && zn == T - 1) {\t\t\t\t\\", "\t\t\t\ty = __KB_PTR(b, x)[i]; z = __KB_PTR(b, x)[i + 1];\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t} else if (yn == T - 1 && zn == T - 1) {\t\t\t\t\\", "\t\t\t\ty = __KB_PTR(b, x)[i]; z = __KB_PTR(b, x)[i + 1];\t\t\\", "\t\t\t\t__KB_KEY(key_t, y)[y->n++] = *k;\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t} else if (yn == T - 1 && zn == T - 1) {\t\t\t\t\\", "\t\t\t\ty = __KB_PTR(b, x)[i]; z = __KB_PTR(b, x)[i + 1];\t\t\\", "\t\t\t\t__KB_KEY(key_t, y)[y->n++] = *k;\t\t\t\t\t\t\\"], "whitespace/newline"]
["src/nvim/lib/kbtree.h", ["\t\t\t\ty = __KB_PTR(b, x)[i]; z = __KB_PTR(b, x)[i + 1];\t\t\\", "\t\t\t\t__KB_KEY(key_t, y)[y->n++] = *k;\t\t\t\t\t\t\\", "\t\t\t\tmemmove(&__KB_KEY(key_t, y)[y->n], __KB_KEY(key_t, z), (unsigned int)z->n * sizeof(key_t)); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t__KB_KEY(key_t, y)[y->n++] = *k;\t\t\t\t\t\t\\", "\t\t\t\tmemmove(&__KB_KEY(key_t, y)[y->n], __KB_KEY(key_t, z), (unsigned int)z->n * sizeof(key_t)); \\", "\t\t\t\tif (y->is_internal) memmove(&__KB_PTR(b, y)[y->n], __KB_PTR(b, z), (unsigned int)(z->n + 1) * sizeof(void*)); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t__KB_KEY(key_t, y)[y->n++] = *k;\t\t\t\t\t\t\\", "\t\t\t\tmemmove(&__KB_KEY(key_t, y)[y->n], __KB_KEY(key_t, z), (unsigned int)z->n * sizeof(key_t)); \\", "\t\t\t\tif (y->is_internal) memmove(&__KB_PTR(b, y)[y->n], __KB_PTR(b, z), (unsigned int)(z->n + 1) * sizeof(void*)); \\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_KEY(key_t, y)[y->n], __KB_KEY(key_t, z), (unsigned int)z->n * sizeof(key_t)); \\", "\t\t\t\tif (y->is_internal) memmove(&__KB_PTR(b, y)[y->n], __KB_PTR(b, z), (unsigned int)(z->n + 1) * sizeof(void*)); \\", "\t\t\t\ty->n += z->n;\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_KEY(key_t, y)[y->n], __KB_KEY(key_t, z), (unsigned int)z->n * sizeof(key_t)); \\", "\t\t\t\tif (y->is_internal) memmove(&__KB_PTR(b, y)[y->n], __KB_PTR(b, z), (unsigned int)(z->n + 1) * sizeof(void*)); \\", "\t\t\t\ty->n += z->n;\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_KEY(key_t, y)[y->n], __KB_KEY(key_t, z), (unsigned int)z->n * sizeof(key_t)); \\", "\t\t\t\tif (y->is_internal) memmove(&__KB_PTR(b, y)[y->n], __KB_PTR(b, z), (unsigned int)(z->n + 1) * sizeof(void*)); \\", "\t\t\t\ty->n += z->n;\t\t\t\t\t\t\t\t\t\t\t\\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_KEY(key_t, y)[y->n], __KB_KEY(key_t, z), (unsigned int)z->n * sizeof(key_t)); \\", "\t\t\t\tif (y->is_internal) memmove(&__KB_PTR(b, y)[y->n], __KB_PTR(b, z), (unsigned int)(z->n + 1) * sizeof(void*)); \\", "\t\t\t\ty->n += z->n;\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/operators"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tif (y->is_internal) memmove(&__KB_PTR(b, y)[y->n], __KB_PTR(b, z), (unsigned int)(z->n + 1) * sizeof(void*)); \\", "\t\t\t\ty->n += z->n;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tmemmove(&__KB_KEY(key_t, x)[i], &__KB_KEY(key_t, x)[i + 1], (unsigned int)(x->n - i - 1) * sizeof(key_t)); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\ty->n += z->n;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tmemmove(&__KB_KEY(key_t, x)[i], &__KB_KEY(key_t, x)[i + 1], (unsigned int)(x->n - i - 1) * sizeof(key_t)); \\", "\t\t\t\tmemmove(&__KB_PTR(b, x)[i + 1], &__KB_PTR(b, x)[i + 2], (unsigned int)(x->n - i - 1) * sizeof(void*)); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\ty->n += z->n;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tmemmove(&__KB_KEY(key_t, x)[i], &__KB_KEY(key_t, x)[i + 1], (unsigned int)(x->n - i - 1) * sizeof(key_t)); \\", "\t\t\t\tmemmove(&__KB_PTR(b, x)[i + 1], &__KB_PTR(b, x)[i + 2], (unsigned int)(x->n - i - 1) * sizeof(void*)); \\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_KEY(key_t, x)[i], &__KB_KEY(key_t, x)[i + 1], (unsigned int)(x->n - i - 1) * sizeof(key_t)); \\", "\t\t\t\tmemmove(&__KB_PTR(b, x)[i + 1], &__KB_PTR(b, x)[i + 2], (unsigned int)(x->n - i - 1) * sizeof(void*)); \\", "\t\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_KEY(key_t, x)[i], &__KB_KEY(key_t, x)[i + 1], (unsigned int)(x->n - i - 1) * sizeof(key_t)); \\", "\t\t\t\tmemmove(&__KB_PTR(b, x)[i + 1], &__KB_PTR(b, x)[i + 2], (unsigned int)(x->n - i - 1) * sizeof(void*)); \\", "\t\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_KEY(key_t, x)[i], &__KB_KEY(key_t, x)[i + 1], (unsigned int)(x->n - i - 1) * sizeof(key_t)); \\", "\t\t\t\tmemmove(&__KB_PTR(b, x)[i + 1], &__KB_PTR(b, x)[i + 2], (unsigned int)(x->n - i - 1) * sizeof(void*)); \\", "\t\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/operators"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_PTR(b, x)[i + 1], &__KB_PTR(b, x)[i + 2], (unsigned int)(x->n - i - 1) * sizeof(void*)); \\", "\t\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tXFREE_CLEAR(z);\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_PTR(b, x)[i + 1], &__KB_PTR(b, x)[i + 2], (unsigned int)(x->n - i - 1) * sizeof(void*)); \\", "\t\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tXFREE_CLEAR(z);\t\t\t\t\t\t\t\t\t\t\t\t\\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tXFREE_CLEAR(z);\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\treturn __kb_delp_aux_##name(b, y, k, s);\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tXFREE_CLEAR(z);\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\treturn __kb_delp_aux_##name(b, y, k, s);\t\t\t\t\\", "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\treturn __kb_delp_aux_##name(b, y, k, s);\t\t\t\t\\", "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t++i;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t++i;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif ((xp = __KB_PTR(b, x)[i])->n == T - 1) {\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t++i;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif ((xp = __KB_PTR(b, x)[i])->n == T - 1) {\t\t\t\t\t\\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["\t\t++i;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif ((xp = __KB_PTR(b, x)[i])->n == T - 1) {\t\t\t\t\t\\", "\t\t\tif (i > 0 && (y = __KB_PTR(b, x)[i - 1])->n >= T) {\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tif ((xp = __KB_PTR(b, x)[i])->n == T - 1) {\t\t\t\t\t\\", "\t\t\tif (i > 0 && (y = __KB_PTR(b, x)[i - 1])->n >= T) {\t\t\\", "\t\t\t\tmemmove(&__KB_KEY(key_t, xp)[1], __KB_KEY(key_t, xp), (unsigned int)xp->n * sizeof(key_t)); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tif (i > 0 && (y = __KB_PTR(b, x)[i - 1])->n >= T) {\t\t\\", "\t\t\t\tmemmove(&__KB_KEY(key_t, xp)[1], __KB_KEY(key_t, xp), (unsigned int)xp->n * sizeof(key_t)); \\", "\t\t\t\tif (xp->is_internal) memmove(&__KB_PTR(b, xp)[1], __KB_PTR(b, xp), (unsigned int)(xp->n + 1) * sizeof(void*)); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tif (i > 0 && (y = __KB_PTR(b, x)[i - 1])->n >= T) {\t\t\\", "\t\t\t\tmemmove(&__KB_KEY(key_t, xp)[1], __KB_KEY(key_t, xp), (unsigned int)xp->n * sizeof(key_t)); \\", "\t\t\t\tif (xp->is_internal) memmove(&__KB_PTR(b, xp)[1], __KB_PTR(b, xp), (unsigned int)(xp->n + 1) * sizeof(void*)); \\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_KEY(key_t, xp)[1], __KB_KEY(key_t, xp), (unsigned int)xp->n * sizeof(key_t)); \\", "\t\t\t\tif (xp->is_internal) memmove(&__KB_PTR(b, xp)[1], __KB_PTR(b, xp), (unsigned int)(xp->n + 1) * sizeof(void*)); \\", "\t\t\t\t__KB_KEY(key_t, xp)[0] = __KB_KEY(key_t, x)[i - 1];\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_KEY(key_t, xp)[1], __KB_KEY(key_t, xp), (unsigned int)xp->n * sizeof(key_t)); \\", "\t\t\t\tif (xp->is_internal) memmove(&__KB_PTR(b, xp)[1], __KB_PTR(b, xp), (unsigned int)(xp->n + 1) * sizeof(void*)); \\", "\t\t\t\t__KB_KEY(key_t, xp)[0] = __KB_KEY(key_t, x)[i - 1];\t\t\\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_KEY(key_t, xp)[1], __KB_KEY(key_t, xp), (unsigned int)xp->n * sizeof(key_t)); \\", "\t\t\t\tif (xp->is_internal) memmove(&__KB_PTR(b, xp)[1], __KB_PTR(b, xp), (unsigned int)(xp->n + 1) * sizeof(void*)); \\", "\t\t\t\t__KB_KEY(key_t, xp)[0] = __KB_KEY(key_t, x)[i - 1];\t\t\\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_KEY(key_t, xp)[1], __KB_KEY(key_t, xp), (unsigned int)xp->n * sizeof(key_t)); \\", "\t\t\t\tif (xp->is_internal) memmove(&__KB_PTR(b, xp)[1], __KB_PTR(b, xp), (unsigned int)(xp->n + 1) * sizeof(void*)); \\", "\t\t\t\t__KB_KEY(key_t, xp)[0] = __KB_KEY(key_t, x)[i - 1];\t\t\\"], "whitespace/operators"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tif (xp->is_internal) memmove(&__KB_PTR(b, xp)[1], __KB_PTR(b, xp), (unsigned int)(xp->n + 1) * sizeof(void*)); \\", "\t\t\t\t__KB_KEY(key_t, xp)[0] = __KB_KEY(key_t, x)[i - 1];\t\t\\", "\t\t\t\t__KB_KEY(key_t, x)[i - 1] = __KB_KEY(key_t, y)[y->n - 1]; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t__KB_KEY(key_t, xp)[0] = __KB_KEY(key_t, x)[i - 1];\t\t\\", "\t\t\t\t__KB_KEY(key_t, x)[i - 1] = __KB_KEY(key_t, y)[y->n - 1]; \\", "\t\t\t\tif (xp->is_internal) __KB_PTR(b, xp)[0] = __KB_PTR(b, y)[y->n]; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t__KB_KEY(key_t, x)[i - 1] = __KB_KEY(key_t, y)[y->n - 1]; \\", "\t\t\t\tif (xp->is_internal) __KB_PTR(b, xp)[0] = __KB_PTR(b, y)[y->n]; \\", "\t\t\t\t--y->n; ++xp->n;\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t__KB_KEY(key_t, x)[i - 1] = __KB_KEY(key_t, y)[y->n - 1]; \\", "\t\t\t\tif (xp->is_internal) __KB_PTR(b, xp)[0] = __KB_PTR(b, y)[y->n]; \\", "\t\t\t\t--y->n; ++xp->n;\t\t\t\t\t\t\t\t\t\t\\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tif (xp->is_internal) __KB_PTR(b, xp)[0] = __KB_PTR(b, y)[y->n]; \\", "\t\t\t\t--y->n; ++xp->n;\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t} else if (i < x->n && (y = __KB_PTR(b, x)[i + 1])->n >= T) { \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tif (xp->is_internal) __KB_PTR(b, xp)[0] = __KB_PTR(b, y)[y->n]; \\", "\t\t\t\t--y->n; ++xp->n;\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t} else if (i < x->n && (y = __KB_PTR(b, x)[i + 1])->n >= T) { \\"], "whitespace/newline"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tif (xp->is_internal) __KB_PTR(b, xp)[0] = __KB_PTR(b, y)[y->n]; \\", "\t\t\t\t--y->n; ++xp->n;\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t} else if (i < x->n && (y = __KB_PTR(b, x)[i + 1])->n >= T) { \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t--y->n; ++xp->n;\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t} else if (i < x->n && (y = __KB_PTR(b, x)[i + 1])->n >= T) { \\", "\t\t\t\t__KB_KEY(key_t, xp)[xp->n++] = __KB_KEY(key_t, x)[i];\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t} else if (i < x->n && (y = __KB_PTR(b, x)[i + 1])->n >= T) { \\", "\t\t\t\t__KB_KEY(key_t, xp)[xp->n++] = __KB_KEY(key_t, x)[i];\t\\", "\t\t\t\t__KB_KEY(key_t, x)[i] = __KB_KEY(key_t, y)[0];\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t__KB_KEY(key_t, xp)[xp->n++] = __KB_KEY(key_t, x)[i];\t\\", "\t\t\t\t__KB_KEY(key_t, x)[i] = __KB_KEY(key_t, y)[0];\t\t\t\\", "\t\t\t\tif (xp->is_internal) __KB_PTR(b, xp)[xp->n] = __KB_PTR(b, y)[0]; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t__KB_KEY(key_t, x)[i] = __KB_KEY(key_t, y)[0];\t\t\t\\", "\t\t\t\tif (xp->is_internal) __KB_PTR(b, xp)[xp->n] = __KB_PTR(b, y)[0]; \\", "\t\t\t\t--y->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t__KB_KEY(key_t, x)[i] = __KB_KEY(key_t, y)[0];\t\t\t\\", "\t\t\t\tif (xp->is_internal) __KB_PTR(b, xp)[xp->n] = __KB_PTR(b, y)[0]; \\", "\t\t\t\t--y->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tif (xp->is_internal) __KB_PTR(b, xp)[xp->n] = __KB_PTR(b, y)[0]; \\", "\t\t\t\t--y->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tmemmove(__KB_KEY(key_t, y), &__KB_KEY(key_t, y)[1], (unsigned int)y->n * sizeof(key_t)); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tif (xp->is_internal) __KB_PTR(b, xp)[xp->n] = __KB_PTR(b, y)[0]; \\", "\t\t\t\t--y->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tmemmove(__KB_KEY(key_t, y), &__KB_KEY(key_t, y)[1], (unsigned int)y->n * sizeof(key_t)); \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t--y->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tmemmove(__KB_KEY(key_t, y), &__KB_KEY(key_t, y)[1], (unsigned int)y->n * sizeof(key_t)); \\", "\t\t\t\tif (y->is_internal) memmove(__KB_PTR(b, y), &__KB_PTR(b, y)[1], (unsigned int)(y->n + 1) * sizeof(void*)); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t--y->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tmemmove(__KB_KEY(key_t, y), &__KB_KEY(key_t, y)[1], (unsigned int)y->n * sizeof(key_t)); \\", "\t\t\t\tif (y->is_internal) memmove(__KB_PTR(b, y), &__KB_PTR(b, y)[1], (unsigned int)(y->n + 1) * sizeof(void*)); \\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(__KB_KEY(key_t, y), &__KB_KEY(key_t, y)[1], (unsigned int)y->n * sizeof(key_t)); \\", "\t\t\t\tif (y->is_internal) memmove(__KB_PTR(b, y), &__KB_PTR(b, y)[1], (unsigned int)(y->n + 1) * sizeof(void*)); \\", "\t\t\t} else if (i > 0 && (y = __KB_PTR(b, x)[i - 1])->n == T - 1) { \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(__KB_KEY(key_t, y), &__KB_KEY(key_t, y)[1], (unsigned int)y->n * sizeof(key_t)); \\", "\t\t\t\tif (y->is_internal) memmove(__KB_PTR(b, y), &__KB_PTR(b, y)[1], (unsigned int)(y->n + 1) * sizeof(void*)); \\", "\t\t\t} else if (i > 0 && (y = __KB_PTR(b, x)[i - 1])->n == T - 1) { \\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(__KB_KEY(key_t, y), &__KB_KEY(key_t, y)[1], (unsigned int)y->n * sizeof(key_t)); \\", "\t\t\t\tif (y->is_internal) memmove(__KB_PTR(b, y), &__KB_PTR(b, y)[1], (unsigned int)(y->n + 1) * sizeof(void*)); \\", "\t\t\t} else if (i > 0 && (y = __KB_PTR(b, x)[i - 1])->n == T - 1) { \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(__KB_KEY(key_t, y), &__KB_KEY(key_t, y)[1], (unsigned int)y->n * sizeof(key_t)); \\", "\t\t\t\tif (y->is_internal) memmove(__KB_PTR(b, y), &__KB_PTR(b, y)[1], (unsigned int)(y->n + 1) * sizeof(void*)); \\", "\t\t\t} else if (i > 0 && (y = __KB_PTR(b, x)[i - 1])->n == T - 1) { \\"], "whitespace/operators"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tif (y->is_internal) memmove(__KB_PTR(b, y), &__KB_PTR(b, y)[1], (unsigned int)(y->n + 1) * sizeof(void*)); \\", "\t\t\t} else if (i > 0 && (y = __KB_PTR(b, x)[i - 1])->n == T - 1) { \\", "\t\t\t\t__KB_KEY(key_t, y)[y->n++] = __KB_KEY(key_t, x)[i - 1];\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t} else if (i > 0 && (y = __KB_PTR(b, x)[i - 1])->n == T - 1) { \\", "\t\t\t\t__KB_KEY(key_t, y)[y->n++] = __KB_KEY(key_t, x)[i - 1];\t\\", "\t\t\t\tmemmove(&__KB_KEY(key_t, y)[y->n], __KB_KEY(key_t, xp), (unsigned int)xp->n * sizeof(key_t));\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t__KB_KEY(key_t, y)[y->n++] = __KB_KEY(key_t, x)[i - 1];\t\\", "\t\t\t\tmemmove(&__KB_KEY(key_t, y)[y->n], __KB_KEY(key_t, xp), (unsigned int)xp->n * sizeof(key_t));\t\\", "\t\t\t\tif (y->is_internal) memmove(&__KB_PTR(b, y)[y->n], __KB_PTR(b, xp), (unsigned int)(xp->n + 1) * sizeof(void*)); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t__KB_KEY(key_t, y)[y->n++] = __KB_KEY(key_t, x)[i - 1];\t\\", "\t\t\t\tmemmove(&__KB_KEY(key_t, y)[y->n], __KB_KEY(key_t, xp), (unsigned int)xp->n * sizeof(key_t));\t\\", "\t\t\t\tif (y->is_internal) memmove(&__KB_PTR(b, y)[y->n], __KB_PTR(b, xp), (unsigned int)(xp->n + 1) * sizeof(void*)); \\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_KEY(key_t, y)[y->n], __KB_KEY(key_t, xp), (unsigned int)xp->n * sizeof(key_t));\t\\", "\t\t\t\tif (y->is_internal) memmove(&__KB_PTR(b, y)[y->n], __KB_PTR(b, xp), (unsigned int)(xp->n + 1) * sizeof(void*)); \\", "\t\t\t\ty->n += xp->n;\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_KEY(key_t, y)[y->n], __KB_KEY(key_t, xp), (unsigned int)xp->n * sizeof(key_t));\t\\", "\t\t\t\tif (y->is_internal) memmove(&__KB_PTR(b, y)[y->n], __KB_PTR(b, xp), (unsigned int)(xp->n + 1) * sizeof(void*)); \\", "\t\t\t\ty->n += xp->n;\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_KEY(key_t, y)[y->n], __KB_KEY(key_t, xp), (unsigned int)xp->n * sizeof(key_t));\t\\", "\t\t\t\tif (y->is_internal) memmove(&__KB_PTR(b, y)[y->n], __KB_PTR(b, xp), (unsigned int)(xp->n + 1) * sizeof(void*)); \\", "\t\t\t\ty->n += xp->n;\t\t\t\t\t\t\t\t\t\t\t\\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_KEY(key_t, y)[y->n], __KB_KEY(key_t, xp), (unsigned int)xp->n * sizeof(key_t));\t\\", "\t\t\t\tif (y->is_internal) memmove(&__KB_PTR(b, y)[y->n], __KB_PTR(b, xp), (unsigned int)(xp->n + 1) * sizeof(void*)); \\", "\t\t\t\ty->n += xp->n;\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/operators"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tif (y->is_internal) memmove(&__KB_PTR(b, y)[y->n], __KB_PTR(b, xp), (unsigned int)(xp->n + 1) * sizeof(void*)); \\", "\t\t\t\ty->n += xp->n;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tmemmove(&__KB_KEY(key_t, x)[i - 1], &__KB_KEY(key_t, x)[i], (unsigned int)(x->n - i) * sizeof(key_t)); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\ty->n += xp->n;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tmemmove(&__KB_KEY(key_t, x)[i - 1], &__KB_KEY(key_t, x)[i], (unsigned int)(x->n - i) * sizeof(key_t)); \\", "\t\t\t\tmemmove(&__KB_PTR(b, x)[i], &__KB_PTR(b, x)[i + 1], (unsigned int)(x->n - i) * sizeof(void*)); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\ty->n += xp->n;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tmemmove(&__KB_KEY(key_t, x)[i - 1], &__KB_KEY(key_t, x)[i], (unsigned int)(x->n - i) * sizeof(key_t)); \\", "\t\t\t\tmemmove(&__KB_PTR(b, x)[i], &__KB_PTR(b, x)[i + 1], (unsigned int)(x->n - i) * sizeof(void*)); \\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_KEY(key_t, x)[i - 1], &__KB_KEY(key_t, x)[i], (unsigned int)(x->n - i) * sizeof(key_t)); \\", "\t\t\t\tmemmove(&__KB_PTR(b, x)[i], &__KB_PTR(b, x)[i + 1], (unsigned int)(x->n - i) * sizeof(void*)); \\", "\t\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_KEY(key_t, x)[i - 1], &__KB_KEY(key_t, x)[i], (unsigned int)(x->n - i) * sizeof(key_t)); \\", "\t\t\t\tmemmove(&__KB_PTR(b, x)[i], &__KB_PTR(b, x)[i + 1], (unsigned int)(x->n - i) * sizeof(void*)); \\", "\t\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_KEY(key_t, x)[i - 1], &__KB_KEY(key_t, x)[i], (unsigned int)(x->n - i) * sizeof(key_t)); \\", "\t\t\t\tmemmove(&__KB_PTR(b, x)[i], &__KB_PTR(b, x)[i + 1], (unsigned int)(x->n - i) * sizeof(void*)); \\", "\t\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/operators"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_PTR(b, x)[i], &__KB_PTR(b, x)[i + 1], (unsigned int)(x->n - i) * sizeof(void*)); \\", "\t\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tXFREE_CLEAR(xp);\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_PTR(b, x)[i], &__KB_PTR(b, x)[i + 1], (unsigned int)(x->n - i) * sizeof(void*)); \\", "\t\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tXFREE_CLEAR(xp);\t\t\t\t\t\t\t\t\t\t\t\t\\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tXFREE_CLEAR(xp);\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\txp = y;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tXFREE_CLEAR(xp);\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\txp = y;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t} else if (i < x->n && (y = __KB_PTR(b, x)[i + 1])->n == T - 1) { \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\txp = y;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t} else if (i < x->n && (y = __KB_PTR(b, x)[i + 1])->n == T - 1) { \\", "\t\t\t\t__KB_KEY(key_t, xp)[xp->n++] = __KB_KEY(key_t, x)[i];\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t} else if (i < x->n && (y = __KB_PTR(b, x)[i + 1])->n == T - 1) { \\", "\t\t\t\t__KB_KEY(key_t, xp)[xp->n++] = __KB_KEY(key_t, x)[i];\t\\", "\t\t\t\tmemmove(&__KB_KEY(key_t, xp)[xp->n], __KB_KEY(key_t, y), (unsigned int)y->n * sizeof(key_t));\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t__KB_KEY(key_t, xp)[xp->n++] = __KB_KEY(key_t, x)[i];\t\\", "\t\t\t\tmemmove(&__KB_KEY(key_t, xp)[xp->n], __KB_KEY(key_t, y), (unsigned int)y->n * sizeof(key_t));\t\\", "\t\t\t\tif (xp->is_internal) memmove(&__KB_PTR(b, xp)[xp->n], __KB_PTR(b, y), (unsigned int)(y->n + 1) * sizeof(void*)); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t__KB_KEY(key_t, xp)[xp->n++] = __KB_KEY(key_t, x)[i];\t\\", "\t\t\t\tmemmove(&__KB_KEY(key_t, xp)[xp->n], __KB_KEY(key_t, y), (unsigned int)y->n * sizeof(key_t));\t\\", "\t\t\t\tif (xp->is_internal) memmove(&__KB_PTR(b, xp)[xp->n], __KB_PTR(b, y), (unsigned int)(y->n + 1) * sizeof(void*)); \\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_KEY(key_t, xp)[xp->n], __KB_KEY(key_t, y), (unsigned int)y->n * sizeof(key_t));\t\\", "\t\t\t\tif (xp->is_internal) memmove(&__KB_PTR(b, xp)[xp->n], __KB_PTR(b, y), (unsigned int)(y->n + 1) * sizeof(void*)); \\", "\t\t\t\txp->n += y->n;\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_KEY(key_t, xp)[xp->n], __KB_KEY(key_t, y), (unsigned int)y->n * sizeof(key_t));\t\\", "\t\t\t\tif (xp->is_internal) memmove(&__KB_PTR(b, xp)[xp->n], __KB_PTR(b, y), (unsigned int)(y->n + 1) * sizeof(void*)); \\", "\t\t\t\txp->n += y->n;\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_KEY(key_t, xp)[xp->n], __KB_KEY(key_t, y), (unsigned int)y->n * sizeof(key_t));\t\\", "\t\t\t\tif (xp->is_internal) memmove(&__KB_PTR(b, xp)[xp->n], __KB_PTR(b, y), (unsigned int)(y->n + 1) * sizeof(void*)); \\", "\t\t\t\txp->n += y->n;\t\t\t\t\t\t\t\t\t\t\t\\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_KEY(key_t, xp)[xp->n], __KB_KEY(key_t, y), (unsigned int)y->n * sizeof(key_t));\t\\", "\t\t\t\tif (xp->is_internal) memmove(&__KB_PTR(b, xp)[xp->n], __KB_PTR(b, y), (unsigned int)(y->n + 1) * sizeof(void*)); \\", "\t\t\t\txp->n += y->n;\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/operators"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tif (xp->is_internal) memmove(&__KB_PTR(b, xp)[xp->n], __KB_PTR(b, y), (unsigned int)(y->n + 1) * sizeof(void*)); \\", "\t\t\t\txp->n += y->n;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tmemmove(&__KB_KEY(key_t, x)[i], &__KB_KEY(key_t, x)[i + 1], (unsigned int)(x->n - i - 1) * sizeof(key_t)); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\txp->n += y->n;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tmemmove(&__KB_KEY(key_t, x)[i], &__KB_KEY(key_t, x)[i + 1], (unsigned int)(x->n - i - 1) * sizeof(key_t)); \\", "\t\t\t\tmemmove(&__KB_PTR(b, x)[i + 1], &__KB_PTR(b, x)[i + 2], (unsigned int)(x->n - i - 1) * sizeof(void*)); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\txp->n += y->n;\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tmemmove(&__KB_KEY(key_t, x)[i], &__KB_KEY(key_t, x)[i + 1], (unsigned int)(x->n - i - 1) * sizeof(key_t)); \\", "\t\t\t\tmemmove(&__KB_PTR(b, x)[i + 1], &__KB_PTR(b, x)[i + 2], (unsigned int)(x->n - i - 1) * sizeof(void*)); \\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_KEY(key_t, x)[i], &__KB_KEY(key_t, x)[i + 1], (unsigned int)(x->n - i - 1) * sizeof(key_t)); \\", "\t\t\t\tmemmove(&__KB_PTR(b, x)[i + 1], &__KB_PTR(b, x)[i + 2], (unsigned int)(x->n - i - 1) * sizeof(void*)); \\", "\t\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_KEY(key_t, x)[i], &__KB_KEY(key_t, x)[i + 1], (unsigned int)(x->n - i - 1) * sizeof(key_t)); \\", "\t\t\t\tmemmove(&__KB_PTR(b, x)[i + 1], &__KB_PTR(b, x)[i + 2], (unsigned int)(x->n - i - 1) * sizeof(void*)); \\", "\t\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_KEY(key_t, x)[i], &__KB_KEY(key_t, x)[i + 1], (unsigned int)(x->n - i - 1) * sizeof(key_t)); \\", "\t\t\t\tmemmove(&__KB_PTR(b, x)[i + 1], &__KB_PTR(b, x)[i + 2], (unsigned int)(x->n - i - 1) * sizeof(void*)); \\", "\t\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/operators"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_PTR(b, x)[i + 1], &__KB_PTR(b, x)[i + 2], (unsigned int)(x->n - i - 1) * sizeof(void*)); \\", "\t\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tXFREE_CLEAR(y);\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tmemmove(&__KB_PTR(b, x)[i + 1], &__KB_PTR(b, x)[i + 2], (unsigned int)(x->n - i - 1) * sizeof(void*)); \\", "\t\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tXFREE_CLEAR(y);\t\t\t\t\t\t\t\t\t\t\t\t\\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t\tXFREE_CLEAR(y);\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\tXFREE_CLEAR(y);\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\treturn __kb_delp_aux_##name(b, xp, k, s);\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\treturn __kb_delp_aux_##name(b, xp, k, s);\t\t\t\t\t\t\\", "\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\treturn __kb_delp_aux_##name(b, xp, k, s);\t\t\t\t\t\t\\", "\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\tstatic inline key_t kb_delp_##name(kbtree_##name##_t *b, key_t * __restrict k) \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\tstatic inline key_t kb_delp_##name(kbtree_##name##_t *b, key_t * __restrict k) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\tstatic inline key_t kb_delp_##name(kbtree_##name##_t *b, key_t * __restrict k) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\tstatic inline key_t kb_delp_##name(kbtree_##name##_t *b, key_t * __restrict k) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tkbnode_t *x;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\tstatic inline key_t kb_delp_##name(kbtree_##name##_t *b, key_t * __restrict k) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tkbnode_t *x;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/braces"]
["src/nvim/lib/kbtree.h", ["\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tkbnode_t *x;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tkey_t ret;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tkbnode_t *x;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tkey_t ret;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tret = __kb_delp_aux_##name(b, b->root, k, 0);\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tkey_t ret;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tret = __kb_delp_aux_##name(b, b->root, k, 0);\t\t\t\t\t\\", "\t\t--b->n_keys;\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tret = __kb_delp_aux_##name(b, b->root, k, 0);\t\t\t\t\t\\", "\t\t--b->n_keys;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif (b->root->n == 0 && b->root->is_internal) {\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tret = __kb_delp_aux_##name(b, b->root, k, 0);\t\t\t\t\t\\", "\t\t--b->n_keys;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif (b->root->n == 0 && b->root->is_internal) {\t\t\t\t\t\\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["\t\t--b->n_keys;\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\tif (b->root->n == 0 && b->root->is_internal) {\t\t\t\t\t\\", "\t\t\t--b->n_nodes;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tif (b->root->n == 0 && b->root->is_internal) {\t\t\t\t\t\\", "\t\t\t--b->n_nodes;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\tx = b->root;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tif (b->root->n == 0 && b->root->is_internal) {\t\t\t\t\t\\", "\t\t\t--b->n_nodes;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\tx = b->root;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["\t\t\t--b->n_nodes;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\tx = b->root;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\tb->root = __KB_PTR(b, x)[0];\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tx = b->root;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t\tb->root = __KB_PTR(b, x)[0];\t\t\t\t\t\t\t\t\\", "\t\t\tXFREE_CLEAR(x);\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tb->root = __KB_PTR(b, x)[0];\t\t\t\t\t\t\t\t\\", "\t\t\tXFREE_CLEAR(x);\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tXFREE_CLEAR(x);\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\treturn ret;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\treturn ret;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\treturn ret;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\tstatic inline key_t kb_del_##name(kbtree_##name##_t *b, key_t k) \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\tstatic inline key_t kb_del_##name(kbtree_##name##_t *b, key_t k) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\tstatic inline key_t kb_del_##name(kbtree_##name##_t *b, key_t k) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\treturn kb_delp_##name(b, &k);\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\tstatic inline key_t kb_del_##name(kbtree_##name##_t *b, key_t k) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\treturn kb_delp_##name(b, &k);\t\t\t\t\t\t\t\t\t\\"], "whitespace/braces"]
["src/nvim/lib/kbtree.h", ["\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\treturn kb_delp_##name(b, &k);\t\t\t\t\t\t\t\t\t\\", "\t}"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\treturn kb_delp_##name(b, &k);\t\t\t\t\t\t\t\t\t\\", "\t}", ""], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["#define __KB_ITR(name, key_t, kbnode_t) \\", "\tstatic inline void kb_itr_first_##name(kbtree_##name##_t *b, kbitr_##name##_t *itr) \\", "\t{ \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["#define __KB_ITR(name, key_t, kbnode_t) \\", "\tstatic inline void kb_itr_first_##name(kbtree_##name##_t *b, kbitr_##name##_t *itr) \\", "\t{ \\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\tstatic inline void kb_itr_first_##name(kbtree_##name##_t *b, kbitr_##name##_t *itr) \\", "\t{ \\", "\t\titr->p = NULL; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\tstatic inline void kb_itr_first_##name(kbtree_##name##_t *b, kbitr_##name##_t *itr) \\", "\t{ \\", "\t\titr->p = NULL; \\"], "whitespace/braces"]
["src/nvim/lib/kbtree.h", ["\t{ \\", "\t\titr->p = NULL; \\", "\t\tif (b->n_keys == 0) return; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\titr->p = NULL; \\", "\t\tif (b->n_keys == 0) return; \\", "\t\titr->p = itr->stack; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\titr->p = NULL; \\", "\t\tif (b->n_keys == 0) return; \\", "\t\titr->p = itr->stack; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\tif (b->n_keys == 0) return; \\", "\t\titr->p = itr->stack; \\", "\t\titr->p->x = b->root; itr->p->i = 0; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\titr->p = itr->stack; \\", "\t\titr->p->x = b->root; itr->p->i = 0; \\", "\t\twhile (itr->p->x->is_internal && __KB_PTR(b, itr->p->x)[0] != 0) { \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\titr->p = itr->stack; \\", "\t\titr->p->x = b->root; itr->p->i = 0; \\", "\t\twhile (itr->p->x->is_internal && __KB_PTR(b, itr->p->x)[0] != 0) { \\"], "whitespace/newline"]
["src/nvim/lib/kbtree.h", ["\t\titr->p->x = b->root; itr->p->i = 0; \\", "\t\twhile (itr->p->x->is_internal && __KB_PTR(b, itr->p->x)[0] != 0) { \\", "\t\t\tkbnode_t *x = itr->p->x; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\twhile (itr->p->x->is_internal && __KB_PTR(b, itr->p->x)[0] != 0) { \\", "\t\t\tkbnode_t *x = itr->p->x; \\", "\t\t\t++itr->p; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tkbnode_t *x = itr->p->x; \\", "\t\t\t++itr->p; \\", "\t\t\titr->p->x = __KB_PTR(b, x)[0]; itr->p->i = 0; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tkbnode_t *x = itr->p->x; \\", "\t\t\t++itr->p; \\", "\t\t\titr->p->x = __KB_PTR(b, x)[0]; itr->p->i = 0; \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["\t\t\t++itr->p; \\", "\t\t\titr->p->x = __KB_PTR(b, x)[0]; itr->p->i = 0; \\", "\t\t} \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t++itr->p; \\", "\t\t\titr->p->x = __KB_PTR(b, x)[0]; itr->p->i = 0; \\", "\t\t} \\"], "whitespace/newline"]
["src/nvim/lib/kbtree.h", ["\t\t\titr->p->x = __KB_PTR(b, x)[0]; itr->p->i = 0; \\", "\t\t} \\", "\t} \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t} \\", "\t} \\", "\tstatic inline int kb_itr_next_##name(kbtree_##name##_t *b, kbitr_##name##_t *itr) \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t} \\", "\tstatic inline int kb_itr_next_##name(kbtree_##name##_t *b, kbitr_##name##_t *itr) \\", "\t{ \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t} \\", "\tstatic inline int kb_itr_next_##name(kbtree_##name##_t *b, kbitr_##name##_t *itr) \\", "\t{ \\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\tstatic inline int kb_itr_next_##name(kbtree_##name##_t *b, kbitr_##name##_t *itr) \\", "\t{ \\", "\t\tif (itr->p == NULL) return 0; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\tstatic inline int kb_itr_next_##name(kbtree_##name##_t *b, kbitr_##name##_t *itr) \\", "\t{ \\", "\t\tif (itr->p == NULL) return 0; \\"], "whitespace/braces"]
["src/nvim/lib/kbtree.h", ["\t{ \\", "\t\tif (itr->p == NULL) return 0; \\", "\t\tfor (;;) { \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t{ \\", "\t\tif (itr->p == NULL) return 0; \\", "\t\tfor (;;) { \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\tif (itr->p == NULL) return 0; \\", "\t\tfor (;;) { \\", "\t\t\t++itr->p->i; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tfor (;;) { \\", "\t\t\t++itr->p->i; \\", "\t\t\tassert(itr->p->i <= 21); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tfor (;;) { \\", "\t\t\t++itr->p->i; \\", "\t\t\tassert(itr->p->i <= 21); \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["\t\t\t++itr->p->i; \\", "\t\t\tassert(itr->p->i <= 21); \\", "\t\t\twhile (itr->p->x && itr->p->i <= itr->p->x->n) { \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tassert(itr->p->i <= 21); \\", "\t\t\twhile (itr->p->x && itr->p->i <= itr->p->x->n) { \\", "\t\t\t\titr->p[1].i = 0; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\twhile (itr->p->x && itr->p->i <= itr->p->x->n) { \\", "\t\t\t\titr->p[1].i = 0; \\", "\t\t\t\titr->p[1].x = itr->p->x->is_internal? __KB_PTR(b, itr->p->x)[itr->p->i] : 0; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\titr->p[1].i = 0; \\", "\t\t\t\titr->p[1].x = itr->p->x->is_internal? __KB_PTR(b, itr->p->x)[itr->p->i] : 0; \\", "\t\t\t\t++itr->p; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\titr->p[1].i = 0; \\", "\t\t\t\titr->p[1].x = itr->p->x->is_internal? __KB_PTR(b, itr->p->x)[itr->p->i] : 0; \\", "\t\t\t\t++itr->p; \\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\t\t\t\titr->p[1].x = itr->p->x->is_internal? __KB_PTR(b, itr->p->x)[itr->p->i] : 0; \\", "\t\t\t\t++itr->p; \\", "\t\t\t} \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\titr->p[1].x = itr->p->x->is_internal? __KB_PTR(b, itr->p->x)[itr->p->i] : 0; \\", "\t\t\t\t++itr->p; \\", "\t\t\t} \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t++itr->p; \\", "\t\t\t} \\", "\t\t\tif (itr->p == itr->stack) { \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t} \\", "\t\t\tif (itr->p == itr->stack) { \\", "\t\t\t\titr->p = NULL; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tif (itr->p == itr->stack) { \\", "\t\t\t\titr->p = NULL; \\", "\t\t\t\treturn 0; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\titr->p = NULL; \\", "\t\t\t\treturn 0; \\", "\t\t\t} \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\treturn 0; \\", "\t\t\t} \\", "\t\t\t--itr->p; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t} \\", "\t\t\t--itr->p; \\", "\t\t\tif (itr->p->x && itr->p->i < itr->p->x->n) return 1; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t} \\", "\t\t\t--itr->p; \\", "\t\t\tif (itr->p->x && itr->p->i < itr->p->x->n) return 1; \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["\t\t\t--itr->p; \\", "\t\t\tif (itr->p->x && itr->p->i < itr->p->x->n) return 1; \\", "\t\t} \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t--itr->p; \\", "\t\t\tif (itr->p->x && itr->p->i < itr->p->x->n) return 1; \\", "\t\t} \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\t\tif (itr->p->x && itr->p->i < itr->p->x->n) return 1; \\", "\t\t} \\", "\t} \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t} \\", "\t} \\", "\tstatic inline int kb_itr_prev_##name(kbtree_##name##_t *b, kbitr_##name##_t *itr) \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t} \\", "\tstatic inline int kb_itr_prev_##name(kbtree_##name##_t *b, kbitr_##name##_t *itr) \\", "\t{ \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t} \\", "\tstatic inline int kb_itr_prev_##name(kbtree_##name##_t *b, kbitr_##name##_t *itr) \\", "\t{ \\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\tstatic inline int kb_itr_prev_##name(kbtree_##name##_t *b, kbitr_##name##_t *itr) \\", "\t{ \\", "\t\tif (itr->p == NULL) return 0; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\tstatic inline int kb_itr_prev_##name(kbtree_##name##_t *b, kbitr_##name##_t *itr) \\", "\t{ \\", "\t\tif (itr->p == NULL) return 0; \\"], "whitespace/braces"]
["src/nvim/lib/kbtree.h", ["\t{ \\", "\t\tif (itr->p == NULL) return 0; \\", "\t\tfor (;;) { \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t{ \\", "\t\tif (itr->p == NULL) return 0; \\", "\t\tfor (;;) { \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\tif (itr->p == NULL) return 0; \\", "\t\tfor (;;) { \\", "\t\t\twhile (itr->p->x && itr->p->i >= 0) { \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tfor (;;) { \\", "\t\t\twhile (itr->p->x && itr->p->i >= 0) { \\", "\t\t\t\titr->p[1].x = itr->p->x->is_internal? __KB_PTR(b, itr->p->x)[itr->p->i] : 0; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\twhile (itr->p->x && itr->p->i >= 0) { \\", "\t\t\t\titr->p[1].x = itr->p->x->is_internal? __KB_PTR(b, itr->p->x)[itr->p->i] : 0; \\", "\t\t\t\titr->p[1].i = itr->p[1].x ? itr->p[1].x->n : -1; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\twhile (itr->p->x && itr->p->i >= 0) { \\", "\t\t\t\titr->p[1].x = itr->p->x->is_internal? __KB_PTR(b, itr->p->x)[itr->p->i] : 0; \\", "\t\t\t\titr->p[1].i = itr->p[1].x ? itr->p[1].x->n : -1; \\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\t\t\t\titr->p[1].x = itr->p->x->is_internal? __KB_PTR(b, itr->p->x)[itr->p->i] : 0; \\", "\t\t\t\titr->p[1].i = itr->p[1].x ? itr->p[1].x->n : -1; \\", "\t\t\t\t++itr->p; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\titr->p[1].i = itr->p[1].x ? itr->p[1].x->n : -1; \\", "\t\t\t\t++itr->p; \\", "\t\t\t} \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\titr->p[1].i = itr->p[1].x ? itr->p[1].x->n : -1; \\", "\t\t\t\t++itr->p; \\", "\t\t\t} \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["\t\t\t\t++itr->p; \\", "\t\t\t} \\", "\t\t\tif (itr->p == itr->stack) { \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t} \\", "\t\t\tif (itr->p == itr->stack) { \\", "\t\t\t\titr->p = NULL; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tif (itr->p == itr->stack) { \\", "\t\t\t\titr->p = NULL; \\", "\t\t\t\treturn 0; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\titr->p = NULL; \\", "\t\t\t\treturn 0; \\", "\t\t\t} \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t\treturn 0; \\", "\t\t\t} \\", "\t\t\t--itr->p; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t} \\", "\t\t\t--itr->p; \\", "\t\t\t--itr->p->i; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t} \\", "\t\t\t--itr->p; \\", "\t\t\t--itr->p->i; \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["\t\t\t--itr->p; \\", "\t\t\t--itr->p->i; \\", "\t\t\tif (itr->p->x && itr->p->i >= 0) return 1; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t--itr->p; \\", "\t\t\t--itr->p->i; \\", "\t\t\tif (itr->p->x && itr->p->i >= 0) return 1; \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["\t\t\t--itr->p->i; \\", "\t\t\tif (itr->p->x && itr->p->i >= 0) return 1; \\", "\t\t} \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\t--itr->p->i; \\", "\t\t\tif (itr->p->x && itr->p->i >= 0) return 1; \\", "\t\t} \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\t\tif (itr->p->x && itr->p->i >= 0) return 1; \\", "\t\t} \\", "\t} \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t} \\", "\t} \\", "\tstatic inline int kb_itr_getp_##name(kbtree_##name##_t *b, key_t * __restrict k, kbitr_##name##_t *itr) \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t} \\", "\tstatic inline int kb_itr_getp_##name(kbtree_##name##_t *b, key_t * __restrict k, kbitr_##name##_t *itr) \\", "\t{ \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t} \\", "\tstatic inline int kb_itr_getp_##name(kbtree_##name##_t *b, key_t * __restrict k, kbitr_##name##_t *itr) \\", "\t{ \\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\tstatic inline int kb_itr_getp_##name(kbtree_##name##_t *b, key_t * __restrict k, kbitr_##name##_t *itr) \\", "\t{ \\", "\t\tif (b->n_keys == 0) { \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\tstatic inline int kb_itr_getp_##name(kbtree_##name##_t *b, key_t * __restrict k, kbitr_##name##_t *itr) \\", "\t{ \\", "\t\tif (b->n_keys == 0) { \\"], "whitespace/braces"]
["src/nvim/lib/kbtree.h", ["\t{ \\", "\t\tif (b->n_keys == 0) { \\", "            itr->p = NULL; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["        } \\", "\t\tint i, r = 0; \\", "\t\titr->p = itr->stack; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tint i, r = 0; \\", "\t\titr->p = itr->stack; \\", "\t\titr->p->x = b->root; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\titr->p = itr->stack; \\", "\t\titr->p->x = b->root; \\", "\t\twhile (itr->p->x) { \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\titr->p->x = b->root; \\", "\t\twhile (itr->p->x) { \\", "\t\t\ti = __kb_getp_aux_##name(itr->p->x, k, &r); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\twhile (itr->p->x) { \\", "\t\t\ti = __kb_getp_aux_##name(itr->p->x, k, &r); \\", "\t\t\titr->p->i = i; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\ti = __kb_getp_aux_##name(itr->p->x, k, &r); \\", "\t\t\titr->p->i = i; \\", "\t\t\tif (i >= 0 && r == 0) return 1; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\titr->p->i = i; \\", "\t\t\tif (i >= 0 && r == 0) return 1; \\", "\t\t\t++itr->p->i; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\titr->p->i = i; \\", "\t\t\tif (i >= 0 && r == 0) return 1; \\", "\t\t\t++itr->p->i; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["\t\t\tif (i >= 0 && r == 0) return 1; \\", "\t\t\t++itr->p->i; \\", "\t\t\tassert(itr->p->i <= 21); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tif (i >= 0 && r == 0) return 1; \\", "\t\t\t++itr->p->i; \\", "\t\t\tassert(itr->p->i <= 21); \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["\t\t\t++itr->p->i; \\", "\t\t\tassert(itr->p->i <= 21); \\", "\t\t\titr->p[1].x = itr->p->x->is_internal? __KB_PTR(b, itr->p->x)[i + 1] : 0; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\tassert(itr->p->i <= 21); \\", "\t\t\titr->p[1].x = itr->p->x->is_internal? __KB_PTR(b, itr->p->x)[i + 1] : 0; \\", "\t\t\t++itr->p; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\titr->p[1].x = itr->p->x->is_internal? __KB_PTR(b, itr->p->x)[i + 1] : 0; \\", "\t\t\t++itr->p; \\", "\t\t} \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t\titr->p[1].x = itr->p->x->is_internal? __KB_PTR(b, itr->p->x)[i + 1] : 0; \\", "\t\t\t++itr->p; \\", "\t\t} \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["\t\t\t++itr->p; \\", "\t\t} \\", "\t\titr->p->i = 0; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\t} \\", "\t\titr->p->i = 0; \\", "\t\treturn 0; \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\titr->p->i = 0; \\", "\t\treturn 0; \\", "\t} \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\treturn 0; \\", "\t} \\", "\tstatic inline int kb_itr_get_##name(kbtree_##name##_t *b, key_t k, kbitr_##name##_t *itr) \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t} \\", "\tstatic inline int kb_itr_get_##name(kbtree_##name##_t *b, key_t k, kbitr_##name##_t *itr) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t} \\", "\tstatic inline int kb_itr_get_##name(kbtree_##name##_t *b, key_t k, kbitr_##name##_t *itr) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\tstatic inline int kb_itr_get_##name(kbtree_##name##_t *b, key_t k, kbitr_##name##_t *itr) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\treturn kb_itr_getp_##name(b,&k,itr); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\tstatic inline int kb_itr_get_##name(kbtree_##name##_t *b, key_t k, kbitr_##name##_t *itr) \\", "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\treturn kb_itr_getp_##name(b,&k,itr); \\"], "whitespace/braces"]
["src/nvim/lib/kbtree.h", ["\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\treturn kb_itr_getp_##name(b,&k,itr); \\", "\t} \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\treturn kb_itr_getp_##name(b,&k,itr); \\", "\t} \\"], "whitespace/comma"]
["src/nvim/lib/kbtree.h", ["\t\treturn kb_itr_getp_##name(b,&k,itr); \\", "\t} \\", "\tstatic inline void kb_del_itr_##name(kbtree_##name##_t *b, kbitr_##name##_t *itr) \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t} \\", "\tstatic inline void kb_del_itr_##name(kbtree_##name##_t *b, kbitr_##name##_t *itr) \\", "\t{ \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t} \\", "\tstatic inline void kb_del_itr_##name(kbtree_##name##_t *b, kbitr_##name##_t *itr) \\", "\t{ \\"], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["\tstatic inline void kb_del_itr_##name(kbtree_##name##_t *b, kbitr_##name##_t *itr) \\", "\t{ \\", "\t\tkey_t k = kb_itr_key(itr); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\tstatic inline void kb_del_itr_##name(kbtree_##name##_t *b, kbitr_##name##_t *itr) \\", "\t{ \\", "\t\tkey_t k = kb_itr_key(itr); \\"], "whitespace/braces"]
["src/nvim/lib/kbtree.h", ["\t{ \\", "\t\tkey_t k = kb_itr_key(itr); \\", "\t\tkb_delp_##name(b, &k); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tkey_t k = kb_itr_key(itr); \\", "\t\tkb_delp_##name(b, &k); \\", "\t\tkb_itr_getp_##name(b, &k, itr); \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tkb_delp_##name(b, &k); \\", "\t\tkb_itr_getp_##name(b, &k, itr); \\", "\t} "], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tkb_itr_getp_##name(b, &k, itr); \\", "\t} ", ""], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t\tkb_itr_getp_##name(b, &k, itr); \\", "\t} ", ""], "whitespace/end_of_line"]
["src/nvim/lib/kbtree.h", ["#define KBTREE_INIT(name, key_t, __cmp, T) \\", "  KBTREE_INIT_IMPL(name, key_t, kbnode_##name##_t, __cmp, T, (sizeof(kbnode_##name##_t)+(2*T)*sizeof(void *)))", ""], "whitespace/line_length"]
["src/nvim/lib/kbtree.h", ["#define KBTREE_INIT(name, key_t, __cmp, T) \\", "  KBTREE_INIT_IMPL(name, key_t, kbnode_##name##_t, __cmp, T, (sizeof(kbnode_##name##_t)+(2*T)*sizeof(void *)))", ""], "whitespace/operators"]
["src/nvim/lib/kbtree.h", ["", "#define KBTREE_INIT_IMPL(name, key_t, kbnode_t, __cmp, T, ILEN)\t\t\t\\", "\t__KB_TREE_T(name, key_t, T)\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["#define KBTREE_INIT_IMPL(name, key_t, kbnode_t, __cmp, T, ILEN)\t\t\t\\", "\t__KB_TREE_T(name, key_t, T)\t\t\t\t\t\t\t\\", "\t__KB_GET_AUX1(name, key_t, kbnode_t, __cmp)\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t__KB_TREE_T(name, key_t, T)\t\t\t\t\t\t\t\\", "\t__KB_GET_AUX1(name, key_t, kbnode_t, __cmp)\t\t\t\\", "\t__KB_GET(name, key_t, kbnode_t)\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t__KB_GET_AUX1(name, key_t, kbnode_t, __cmp)\t\t\t\\", "\t__KB_GET(name, key_t, kbnode_t)\t\t\t\t\t\t\\", "\t__KB_INTERVAL(name, key_t, kbnode_t)\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t__KB_GET(name, key_t, kbnode_t)\t\t\t\t\t\t\\", "\t__KB_INTERVAL(name, key_t, kbnode_t)\t\t\t\t\t\\", "\t__KB_PUT(name, key_t, kbnode_t, __cmp, T, ILEN)\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t__KB_INTERVAL(name, key_t, kbnode_t)\t\t\t\t\t\\", "\t__KB_PUT(name, key_t, kbnode_t, __cmp, T, ILEN)\t\t\t\t\\", "\t__KB_DEL(name, key_t, kbnode_t, T) \\"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t__KB_PUT(name, key_t, kbnode_t, __cmp, T, ILEN)\t\t\t\t\\", "\t__KB_DEL(name, key_t, kbnode_t, T) \\", "\t__KB_ITR(name, key_t, kbnode_t)"], "whitespace/tab"]
["src/nvim/lib/kbtree.h", ["\t__KB_DEL(name, key_t, kbnode_t, T) \\", "\t__KB_ITR(name, key_t, kbnode_t)", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["// marker so line numbers and indices both start at 1", "/* The MIT License", ""], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*", "  Example:"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*", "  2013-05-02 (0.2.8):"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*!", "  @header"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/* compiler specific configuration */", ""], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["#else", "typedef unsigned long long khint64_t;", "#endif"], "runtime/int"]
["src/nvim/lib/khash.h", ["", "#define __ac_isempty(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&2)", "#define __ac_isdel(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&1)"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_isempty(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&2)", "#define __ac_isdel(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&1)", "#define __ac_iseither(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&3)"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_isdel(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&1)", "#define __ac_iseither(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&3)", "#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(khint_t)(1ul<<((i&0xfU)<<1)))"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_iseither(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&3)", "#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(khint_t)(1ul<<((i&0xfU)<<1)))", "#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(khint_t)(2ul<<((i&0xfU)<<1)))"], "whitespace/line_length"]
["src/nvim/lib/khash.h", ["#define __ac_iseither(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&3)", "#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(khint_t)(1ul<<((i&0xfU)<<1)))", "#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(khint_t)(2ul<<((i&0xfU)<<1)))"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(khint_t)(1ul<<((i&0xfU)<<1)))", "#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(khint_t)(2ul<<((i&0xfU)<<1)))", "#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(khint_t)(3ul<<((i&0xfU)<<1)))"], "whitespace/line_length"]
["src/nvim/lib/khash.h", ["#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(khint_t)(1ul<<((i&0xfU)<<1)))", "#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(khint_t)(2ul<<((i&0xfU)<<1)))", "#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(khint_t)(3ul<<((i&0xfU)<<1)))"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(khint_t)(2ul<<((i&0xfU)<<1)))", "#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(khint_t)(3ul<<((i&0xfU)<<1)))", "#define __ac_set_isdel_true(flag, i) (flag[i>>4]|=(khint_t)1ul<<((i&0xfU)<<1))"], "whitespace/line_length"]
["src/nvim/lib/khash.h", ["#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(khint_t)(2ul<<((i&0xfU)<<1)))", "#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(khint_t)(3ul<<((i&0xfU)<<1)))", "#define __ac_set_isdel_true(flag, i) (flag[i>>4]|=(khint_t)1ul<<((i&0xfU)<<1))"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(khint_t)(3ul<<((i&0xfU)<<1)))", "#define __ac_set_isdel_true(flag, i) (flag[i>>4]|=(khint_t)1ul<<((i&0xfU)<<1))", ""], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#ifndef kroundup32", "#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))", "#endif"], "whitespace/line_length"]
["src/nvim/lib/khash.h", ["#ifndef kcalloc", "#define kcalloc(N,Z) xcalloc(N,Z)", "#endif"], "whitespace/comma"]
["src/nvim/lib/khash.h", ["#ifndef krealloc", "#define krealloc(P,Z) xrealloc(P,Z)", "#endif"], "whitespace/comma"]
["src/nvim/lib/khash.h", ["#define __KHASH_TYPE(name, khkey_t, khval_t) \\", "\ttypedef struct { \\", "\t\tkhint_t n_buckets, size, n_occupied, upper_bound; \\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\ttypedef struct { \\", "\t\tkhint_t n_buckets, size, n_occupied, upper_bound; \\", "\t\tkhint32_t *flags; \\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t\tkhint_t n_buckets, size, n_occupied, upper_bound; \\", "\t\tkhint32_t *flags; \\", "\t\tkhkey_t *keys; \\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t\tkhint32_t *flags; \\", "\t\tkhkey_t *keys; \\", "\t\tkhval_t *vals; \\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t\tkhkey_t *keys; \\", "\t\tkhval_t *vals; \\", "\t} kh_##name##_t;"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t\tkhval_t *vals; \\", "\t} kh_##name##_t;", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["  SCOPE kh_##name##_t *kh_init_##name(void) { \\", "    return (kh_##name##_t*)kcalloc(1, sizeof(kh_##name##_t)); \\", "  } \\"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["      mask = h->n_buckets - 1; \\", "      k = __hash_func(key); i = k & mask; \\", "      last = i; \\"], "whitespace/newline"]
["src/nvim/lib/khash.h", ["      } else { /* hash table size to be changed (shrink or expand); rehash */ \\", "        new_flags = (khint32_t*)kmalloc(__ac_fsize(new_n_buckets) \\", "                                        * sizeof(khint32_t)); \\"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["        if (h->n_buckets < new_n_buckets) { /* expand */ \\", "          khkey_t *new_keys = (khkey_t*)krealloc( \\", "              (void *)h->keys, new_n_buckets * sizeof(khkey_t)); \\"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["          if (kh_is_map) { \\", "            khval_t *new_vals = (khval_t*)krealloc( \\", "                (void *)h->vals, new_n_buckets * sizeof(khval_t)); \\"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["    if (j) { /* rehashing is needed */ \\", "      for (j = 0; j != h->n_buckets; ++j) { \\", "        if (__ac_iseither(h->flags, j) == 0) { \\"], "readability/increment"]
["src/nvim/lib/khash.h", ["      if (h->n_buckets > new_n_buckets) { /* shrink the hash table */ \\", "        h->keys = (khkey_t*)krealloc((void *)h->keys, \\", "                                     new_n_buckets * sizeof(khkey_t)); \\"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["        if (kh_is_map) { \\", "          h->vals = (khval_t*)krealloc((void *)h->vals, \\", "                                       new_n_buckets * sizeof(khval_t)); \\"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["      __ac_set_isdel_true(h->flags, x); \\", "      --h->size; \\", "    } \\"], "readability/increment"]
["src/nvim/lib/khash.h", ["", "#define KHASH_DECLARE(name, khkey_t, khval_t)\t\t \t\t\t\t\t\\", "\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define KHASH_DECLARE(name, khkey_t, khval_t)\t\t \t\t\t\t\t\\", "\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\", "\t__KHASH_PROTOTYPES(name, khkey_t, khval_t)"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\", "\t__KHASH_PROTOTYPES(name, khkey_t, khval_t)", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["", "#define KHASH_INIT2(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \\", "\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\"], "whitespace/line_length"]
["src/nvim/lib/khash.h", ["#define KHASH_INIT2(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \\", "\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\", "\t__KHASH_IMPL(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\", "\t__KHASH_IMPL(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\", "\t__KHASH_IMPL(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)", ""], "whitespace/line_length"]
["src/nvim/lib/khash.h", ["", "#define KHASH_INIT(name, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \\", "\tKHASH_INIT2(name, static kh_inline, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)"], "whitespace/line_length"]
["src/nvim/lib/khash.h", ["#define KHASH_INIT(name, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \\", "\tKHASH_INIT2(name, static kh_inline, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define KHASH_INIT(name, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \\", "\tKHASH_INIT2(name, static kh_inline, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)", ""], "whitespace/line_length"]
["src/nvim/lib/khash.h", ["", "/* --- BEGIN OF HASH FUNCTIONS --- */", ""], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Integer hash function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["#define kh_int_hash_func(key) (khint32_t)(key)", "/*! @function", "  @abstract     Integer comparison function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["#define kh_int_hash_equal(a, b) ((a) == (b))", "/*! @function", "  @abstract     64-bit integer hash function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", [" */", "#define kh_int64_hash_func(key) (khint32_t)((key)>>33^(key)^(key)<<11)", "/*! @function"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define kh_int64_hash_func(key) (khint32_t)((key)>>33^(key)^(key)<<11)", "/*! @function", "  @abstract     64-bit integer comparison function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["#define kh_int64_hash_equal(a, b) ((a) == (b))", "/*! @function", "  @abstract     const char* hash function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["{", "\tkhint_t h = (khint_t)*s;", "\tif (h) for (++s ; *s; ++s) h = (h << 5) - h + (uint8_t)*s;"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["{", "\tkhint_t h = (khint_t)*s;", "\tif (h) for (++s ; *s; ++s) h = (h << 5) - h + (uint8_t)*s;"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["\tkhint_t h = (khint_t)*s;", "\tif (h) for (++s ; *s; ++s) h = (h << 5) - h + (uint8_t)*s;", "\treturn h;"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\tkhint_t h = (khint_t)*s;", "\tif (h) for (++s ; *s; ++s) h = (h << 5) - h + (uint8_t)*s;", "\treturn h;"], "readability/braces"]
["src/nvim/lib/khash.h", ["\tkhint_t h = (khint_t)*s;", "\tif (h) for (++s ; *s; ++s) h = (h << 5) - h + (uint8_t)*s;", "\treturn h;"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["\tkhint_t h = (khint_t)*s;", "\tif (h) for (++s ; *s; ++s) h = (h << 5) - h + (uint8_t)*s;", "\treturn h;"], "readability/increment"]
["src/nvim/lib/khash.h", ["\tif (h) for (++s ; *s; ++s) h = (h << 5) - h + (uint8_t)*s;", "\treturn h;", "}"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["}", "/*! @function", "  @abstract     Another interface to const char* hash function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["#define kh_str_hash_func(key) __ac_X31_hash_string(key)", "/*! @function", "  @abstract     Const char* comparison function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/* --- END OF HASH FUNCTIONS --- */", ""], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/* Other convenient macros... */", ""], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*!", "  @abstract Type of the hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Initiate a hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Destroy a hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Free memory referenced directly inside a hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Reset a hash table without deallocating memory."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Resize a hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Insert a key to the hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Retrieve a key from the hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Remove a key from the hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Test whether a bucket contains data."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Get key given an iterator"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Get value given an iterator"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Alias of kh_val()"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Get the start iterator"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Get the end iterator"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Get the number of elements in the hash table"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Get the number of buckets in the hash table"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Iterate over the entries in the hash table"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", [" */", "#define kh_foreach(h, kvar, vvar, code) { khint_t __i;\t\t\\", "\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define kh_foreach(h, kvar, vvar, code) { khint_t __i;\t\t\\", "\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\", "\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define kh_foreach(h, kvar, vvar, code) { khint_t __i;\t\t\\", "\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\", "\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\"], "readability/increment"]
["src/nvim/lib/khash.h", ["\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\", "\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(kvar) = kh_key(h,__i);\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\", "\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(kvar) = kh_key(h,__i);\t\t\t\t\t\t\t\t\\"], "readability/braces"]
["src/nvim/lib/khash.h", ["\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\", "\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(kvar) = kh_key(h,__i);\t\t\t\t\t\t\t\t\\"], "whitespace/comma"]
["src/nvim/lib/khash.h", ["\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(kvar) = kh_key(h,__i);\t\t\t\t\t\t\t\t\\", "\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(kvar) = kh_key(h,__i);\t\t\t\t\t\t\t\t\\", "\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\"], "whitespace/comma"]
["src/nvim/lib/khash.h", ["\t\t(kvar) = kh_key(h,__i);\t\t\t\t\t\t\t\t\\", "\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\", "\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t\t(kvar) = kh_key(h,__i);\t\t\t\t\t\t\t\t\\", "\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\", "\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/comma"]
["src/nvim/lib/khash.h", ["\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\", "\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t} }"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t} }", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Iterate over the values in the hash table"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", [" */", "#define kh_foreach_value(h, vvar, code) { khint_t __i;\t\t\\", "\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define kh_foreach_value(h, vvar, code) { khint_t __i;\t\t\\", "\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\", "\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define kh_foreach_value(h, vvar, code) { khint_t __i;\t\t\\", "\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\", "\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\"], "readability/increment"]
["src/nvim/lib/khash.h", ["\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\", "\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\", "\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\"], "readability/braces"]
["src/nvim/lib/khash.h", ["\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\", "\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\"], "whitespace/comma"]
["src/nvim/lib/khash.h", ["\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\", "\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\", "\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/comma"]
["src/nvim/lib/khash.h", ["\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\", "\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t} }"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t} }", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Iterate over the keys in the hash table"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/* More conenient interfaces */", ""], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Instantiate a hash set containing integer keys"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", [" */", "#define KHASH_SET_INIT_INT(name)\t\t\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, khint32_t, char, 0, kh_int_hash_func, kh_int_hash_equal)"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define KHASH_SET_INIT_INT(name)\t\t\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, khint32_t, char, 0, kh_int_hash_func, kh_int_hash_equal)", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Instantiate a hash map containing integer keys"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", [" */", "#define KHASH_MAP_INIT_INT(name, khval_t)\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, khint32_t, khval_t, 1, kh_int_hash_func, kh_int_hash_equal)"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define KHASH_MAP_INIT_INT(name, khval_t)\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, khint32_t, khval_t, 1, kh_int_hash_func, kh_int_hash_equal)", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Instantiate a hash map containing 64-bit integer keys"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", [" */", "#define KHASH_SET_INIT_INT64(name)\t\t\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, khint64_t, char, 0, kh_int64_hash_func, kh_int64_hash_equal)"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define KHASH_SET_INIT_INT64(name)\t\t\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, khint64_t, char, 0, kh_int64_hash_func, kh_int64_hash_equal)", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Instantiate a hash map containing 64-bit integer keys"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", [" */", "#define KHASH_MAP_INIT_INT64(name, khval_t)\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, khint64_t, khval_t, 1, kh_int64_hash_func, kh_int64_hash_equal)"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define KHASH_MAP_INIT_INT64(name, khval_t)\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, khint64_t, khval_t, 1, kh_int64_hash_func, kh_int64_hash_equal)", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define KHASH_MAP_INIT_INT64(name, khval_t)\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, khint64_t, khval_t, 1, kh_int64_hash_func, kh_int64_hash_equal)", ""], "whitespace/line_length"]
["src/nvim/lib/khash.h", ["typedef const char *kh_cstr_t;", "/*! @function", "  @abstract     Instantiate a hash map containing const char* keys"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", [" */", "#define KHASH_SET_INIT_STR(name)\t\t\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, kh_cstr_t, char, 0, kh_str_hash_func, kh_str_hash_equal)"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define KHASH_SET_INIT_STR(name)\t\t\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, kh_cstr_t, char, 0, kh_str_hash_func, kh_str_hash_equal)", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Instantiate a hash map containing const char* keys"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Return a literal for an empty hash table."], "readability/old_style_comment"]
["src/nvim/lib/klist.h", ["", "#ifndef _AC_KLIST_H", "#define _AC_KLIST_H"], "build/header_guard"]
["src/nvim/lib/klist.h", ["", "#endif", ""], "build/header_guard"]
["src/nvim/lib/klist.h", ["// marker so line numbers and indices both start at 1", "/* The MIT License", ""], "readability/old_style_comment"]
["src/nvim/lib/klist.h", ["        for (k = 0; k < mp->n; k++) { \\", "            kmpfree_f(mp->buf[k]); XFREE_CLEAR(mp->buf[k]); \\", "        } \\"], "whitespace/newline"]
["src/nvim/lib/klist.h", ["        } \\", "        XFREE_CLEAR(mp->buf); XFREE_CLEAR(mp); \\", "    } \\"], "whitespace/newline"]
["src/nvim/lib/klist.h", ["        kl1_##name *q, *p = kmp_alloc(name, kl->mp); \\", "        q = kl->tail; p->next = 0; kl->tail->next = p; kl->tail = p; \\", "        kl->size++; \\"], "whitespace/newline"]
["src/nvim/lib/klist.h", ["#define kl_iter_at(name, kl, p, h) \\", "  for (kl1_##name **p = h ? h : &kl->head; *p != kl->tail; p = &(*p)->next)", ""], "readability/braces"]
["src/nvim/lib/kvec.h", ["    (*(((v).capacity <= (size_t) (i) \\", "      ? ((v).capacity = (v).size = (i) + 1, \\", "         kv_roundup32((v).capacity), \\"], "whitespace/alignment"]
["src/nvim/lib/kvec.h", ["         kv_resize((v), (v).capacity), 0UL) \\", "      : ((v).size <= (size_t) (i) \\", "         ? (v).size = (i) + 1 \\"], "whitespace/alignment"]
["src/nvim/lib/kvec.h", ["         : 0UL)), \\", "     &(v).items[(i)]))", ""], "whitespace/alignment"]
["src/nvim/lib/kvec.h", ["#define kv_a(v, i) \\", "    (*(((v).capacity <= (size_t) (i) \\", "      ? ((v).capacity = (v).size = (i) + 1, \\"], "whitespace/cast"]
["src/nvim/lib/kvec.h", ["         kv_resize((v), (v).capacity), 0UL) \\", "      : ((v).size <= (size_t) (i) \\", "         ? (v).size = (i) + 1 \\"], "whitespace/cast"]
["src/nvim/lib/queue.h", ["  (q) = (h)->next; \\", "  while((q) != (h)) { \\", "    QUEUE *next = q->next; \\"], "whitespace/parens"]
["src/nvim/lib/ringbuf.h", ["    ((rb)->first == NULL ? 0 \\", "     : ((rb)->next == (rb)->first) ? (size_t) ((rb)->buf_end - (rb)->buf) + 1 \\", "     : ((rb)->next > (rb)->first) ? (size_t) ((rb)->next - (rb)->first) \\"], "whitespace/cast"]
["src/nvim/lib/ringbuf.h", ["     : ((rb)->next == (rb)->first) ? (size_t) ((rb)->buf_end - (rb)->buf) + 1 \\", "     : ((rb)->next > (rb)->first) ? (size_t) ((rb)->next - (rb)->first) \\", "     : (size_t) ((rb)->next - (rb)->buf + (rb)->buf_end - (rb)->first + 1))"], "whitespace/cast"]
["src/nvim/lib/ringbuf.h", ["     : ((rb)->next > (rb)->first) ? (size_t) ((rb)->next - (rb)->first) \\", "     : (size_t) ((rb)->next - (rb)->buf + (rb)->buf_end - (rb)->first + 1))", ""], "whitespace/cast"]
["src/nvim/lib/ringbuf.h", ["    size_t varname##_length_fa_ = _RINGBUF_LENGTH(rb); \\", "    for (RBType *varname = ((rb)->first == NULL ? (rb)->next : (rb)->first); \\", "         varname##_length_fa_; \\"], "readability/braces"]
["src/nvim/lib/ringbuf.h", ["    size_t varname##_length_ib_ = _RINGBUF_LENGTH(rb); \\", "    for (varname = ((rb)->next == (rb)->buf ? (rb)->buf_end : (rb)->next - 1); \\", "         varname##_length_ib_; \\"], "readability/braces"]
["src/nvim/lib/ringbuf.h", ["{ \\", "  return (size_t) (rb->buf_end - rb->buf) + 1; \\", "} \\"], "whitespace/cast"]
["src/nvim/lib/ringbuf.h", ["    memmove(insertpos + 1, insertpos, \\", "            (size_t) ((uintptr_t) rb->next - (uintptr_t) insertpos)); \\", "  } else { \\"], "whitespace/cast"]
["src/nvim/lib/ringbuf.h", ["    memmove(rb->buf + 1, rb->buf, \\", "            (size_t) ((uintptr_t) rb->next - (uintptr_t) rb->buf)); \\", "    *rb->buf = *rb->buf_end; \\"], "whitespace/cast"]
["src/nvim/lib/ringbuf.h", ["    memmove(insertpos + 1, insertpos, \\", "            (size_t) ((uintptr_t) (rb->buf_end + 1) - (uintptr_t) insertpos)); \\", "  } \\"], "whitespace/cast"]
["src/nvim/lib/ringbuf.h", ["    memmove(rb->first + 1, rb->first, \\", "            (size_t) ((uintptr_t) rmpos - (uintptr_t) rb->first)); \\", "    rb->first = _RINGBUF_NEXT(rb, rb->first); \\"], "whitespace/cast"]
["src/nvim/lib/ringbuf.h", ["    memmove(rmpos, rmpos + 1, \\", "            (size_t) ((uintptr_t) rb->next - (uintptr_t) rmpos)); \\", "    rb->next = _RINGBUF_PREV(rb, rb->next); \\"], "whitespace/cast"]
["src/nvim/lib/ringbuf.h", ["    memmove(rb->first + 1, rb->first, \\", "            (size_t) ((uintptr_t) rmpos - (uintptr_t) rb->first)); \\", "    rb->first = _RINGBUF_NEXT(rb, rb->first); \\"], "whitespace/cast"]
["src/nvim/macros.h", ["  do { \\", "    if (*p_langmap \\", "        && (condition) \\"], "readability/braces"]
["src/nvim/macros.h", ["    { \\", "      if ((c) < 256) \\", "        c = langmap_mapchar[c]; \\"], "readability/braces"]
["src/nvim/macros.h", ["        c = langmap_mapchar[c]; \\", "      else \\", "        c = langmap_adjust_mb(c); \\"], "readability/braces"]
["src/nvim/macros.h", ["        c = langmap_mapchar[c]; \\", "      else \\", "        c = langmap_adjust_mb(c); \\"], "whitespace/newline"]
["src/nvim/main.c", ["", "  if (params.diff_mode && params.window_count == -1)", "    params.window_count = 0;            /* open up to 3 windows */"], "readability/braces"]
["src/nvim/main.c", ["  if (params.diff_mode && params.window_count == -1)", "    params.window_count = 0;            /* open up to 3 windows */", ""], "readability/old_style_comment"]
["src/nvim/main.c", ["", "  apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);", "  TIME_MSG(\"BufEnter autocommands\");"], "readability/bool"]
["src/nvim/main.c", ["  if (params.edit_type == EDIT_QF) {", "    qf_jump(NULL, 0, 0, FALSE);", "    TIME_MSG(\"jump to first error\");"], "readability/bool"]
["src/nvim/main.c", ["    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {", "      diff_win_options(wp, TRUE);", "    }"], "readability/bool"]
["src/nvim/main.c", ["", "  /* When running in Ex mode an error causes us to exit with a non-zero exit", "   * code.  POSIX requires this, although it's not 100% clear from the"], "readability/old_style_comment"]
["src/nvim/main.c", ["   * standard. */", "  if (exmode_active)", "    exitval += ex_exitval;"], "readability/braces"]
["src/nvim/main.c", ["", "  /* Optionally print hashtable efficiency. */", "  hash_debug_results();"], "readability/old_style_comment"]
["src/nvim/main.c", ["        if (wp->w_buffer == NULL) {", "          /* Autocmd must have close the buffer already, skip. */", "          continue;"], "readability/old_style_comment"]
["src/nvim/main.c", ["", "    /* Trigger BufUnload for buffers that are loaded */", "    FOR_ALL_BUFFERS(buf) {"], "readability/old_style_comment"]
["src/nvim/main.c", ["  if (did_emsg", "     ) {", "    /* give the user a chance to read the (error) message */"], "whitespace/alignment"]
["src/nvim/main.c", ["     ) {", "    /* give the user a chance to read the (error) message */", "    no_wait_return = FALSE;"], "readability/old_style_comment"]
["src/nvim/main.c", ["    /* give the user a chance to read the (error) message */", "    no_wait_return = FALSE;", "    wait_return(FALSE);"], "readability/bool"]
["src/nvim/main.c", ["    no_wait_return = FALSE;", "    wait_return(FALSE);", "  }"], "readability/bool"]
["src/nvim/main.c", ["# ifdef LC_NUMERIC", "  /* Make sure strtod() uses a decimal point, not a comma. */", "  setlocale(LC_NUMERIC, \"C\");"], "readability/old_style_comment"]
["src/nvim/main.c", ["          } else {", "            if (argv[0][argv_idx])", "              mainerr(err_opt_unknown, argv[0]);"], "readability/braces"]
["src/nvim/main.c", ["                a = SESSION_FILE;", "                ++argc;", "                --argv;"], "readability/increment"]
["src/nvim/main.c", ["                ++argc;", "                --argv;", "              } else {"], "readability/increment"]
["src/nvim/main.c", ["        char_u *r = (char_u *)concat_fnames((char *)p,", "            (char *)path_tail(alist_name(&GARGLIST[0])), true);", "        xfree(p);"], "whitespace/alignment"]
["src/nvim/main.c", ["", "/*", " * Many variables are in \"params\" so that we can pass them to invoked"], "readability/old_style_comment"]
["src/nvim/main.c", ["", "/*", " * Decide about window layout for diff mode after reading vimrc."], "readability/old_style_comment"]
["src/nvim/main.c", ["  if (paramp->diff_mode && paramp->window_layout == 0) {", "    if (diffopt_horizontal())", "      paramp->window_layout = WIN_HOR;             /* use horizontal split */"], "readability/braces"]
["src/nvim/main.c", ["    if (diffopt_horizontal())", "      paramp->window_layout = WIN_HOR;             /* use horizontal split */", "    else"], "readability/old_style_comment"]
["src/nvim/main.c", ["      paramp->window_layout = WIN_HOR;             /* use horizontal split */", "    else", "      paramp->window_layout = WIN_VER;             /* use vertical split */"], "readability/braces"]
["src/nvim/main.c", ["    else", "      paramp->window_layout = WIN_VER;             /* use vertical split */", "  }"], "readability/old_style_comment"]
["src/nvim/main.c", ["", "/*", " * Read all the plugin files."], "readability/old_style_comment"]
["src/nvim/main.c", ["", "/*", " * \"-q errorfile\": Load the error file now."], "readability/old_style_comment"]
["src/nvim/main.c", ["", "/*", " * Need to jump to the tag before executing the '-c command'."], "readability/old_style_comment"]
["src/nvim/main.c", ["  if (tagname != NULL) {", "    swap_exists_did_quit = FALSE;", ""], "readability/bool"]
["src/nvim/main.c", ["", "    /* If the user doesn't want to edit the file then we quit here. */", "    if (swap_exists_did_quit)"], "readability/old_style_comment"]
["src/nvim/main.c", ["    /* If the user doesn't want to edit the file then we quit here. */", "    if (swap_exists_did_quit)", "      getout(1);"], "readability/braces"]
["src/nvim/main.c", ["", "/*", " * Create the requested number of windows and edit buffers in them."], "readability/old_style_comment"]
["src/nvim/main.c", ["", "  /*", "   * Create the number of windows that was requested."], "readability/old_style_comment"]
["src/nvim/main.c", ["   */", "  if (parmp->window_count == -1)        /* was not set */", "    parmp->window_count = 1;"], "readability/old_style_comment"]
["src/nvim/main.c", ["   */", "  if (parmp->window_count == -1)        /* was not set */", "    parmp->window_count = 1;"], "readability/braces"]
["src/nvim/main.c", ["    parmp->window_count = 1;", "  if (parmp->window_count == 0)", "    parmp->window_count = GARGCOUNT;"], "readability/braces"]
["src/nvim/main.c", ["    // already split some windows", "    if (parmp->window_layout == 0)", "      parmp->window_layout = WIN_HOR;"], "readability/braces"]
["src/nvim/main.c", ["      parmp->window_count = make_windows(parmp->window_count,", "          parmp->window_layout == WIN_VER);", "      TIME_MSG(\"making windows\");"], "whitespace/alignment"]
["src/nvim/main.c", ["      TIME_MSG(\"making windows\");", "    } else", "      parmp->window_count = win_count();"], "readability/braces"]
["src/nvim/main.c", ["      parmp->window_count = win_count();", "  } else", "    parmp->window_count = 1;"], "readability/braces"]
["src/nvim/main.c", ["    // Don't execute Win/Buf Enter/Leave autocommands here", "    ++autocmd_no_enter;", "    ++autocmd_no_leave;"], "readability/increment"]
["src/nvim/main.c", ["    ++autocmd_no_enter;", "    ++autocmd_no_leave;", "    dorewind = TRUE;"], "readability/increment"]
["src/nvim/main.c", ["    ++autocmd_no_leave;", "    dorewind = TRUE;", "    while (done++ < 1000) {"], "readability/bool"]
["src/nvim/main.c", ["      if (dorewind) {", "        if (parmp->window_layout == WIN_TABS)", "          goto_tabpage(1);"], "readability/braces"]
["src/nvim/main.c", ["          goto_tabpage(1);", "        else", "          curwin = firstwin;"], "readability/braces"]
["src/nvim/main.c", ["      } else if (parmp->window_layout == WIN_TABS) {", "        if (curtab->tp_next == NULL)", "          break;"], "readability/braces"]
["src/nvim/main.c", ["      } else {", "        if (curwin->w_next == NULL)", "          break;"], "readability/braces"]
["src/nvim/main.c", ["      }", "      dorewind = FALSE;", "      curbuf = curwin->w_buffer;"], "readability/bool"]
["src/nvim/main.c", ["        swap_exists_action = SEA_DIALOG;", "        set_buflisted(TRUE);", ""], "readability/bool"]
["src/nvim/main.c", ["", "        /* create memfile, read file */", "        (void)open_buffer(FALSE, NULL, 0);"], "readability/old_style_comment"]
["src/nvim/main.c", ["        /* create memfile, read file */", "        (void)open_buffer(FALSE, NULL, 0);", ""], "readability/bool"]
["src/nvim/main.c", ["          if (got_int || only_one_window()) {", "            /* abort selected or quit and only one window */", "            did_emsg = FALSE;               /* avoid hit-enter prompt */"], "readability/old_style_comment"]
["src/nvim/main.c", ["            /* abort selected or quit and only one window */", "            did_emsg = FALSE;               /* avoid hit-enter prompt */", "            getout(1);"], "readability/old_style_comment"]
["src/nvim/main.c", ["            /* abort selected or quit and only one window */", "            did_emsg = FALSE;               /* avoid hit-enter prompt */", "            getout(1);"], "readability/bool"]
["src/nvim/main.c", ["          }", "          /* We can't close the window, it would disturb what", "           * happens next.  Clear the file name and set the arg"], "readability/old_style_comment"]
["src/nvim/main.c", ["          swap_exists_action = SEA_NONE;", "        } else", "          handle_swap_exists(NULL);"], "readability/braces"]
["src/nvim/main.c", ["          handle_swap_exists(NULL);", "        dorewind = TRUE;                        /* start again */", "      }"], "readability/old_style_comment"]
["src/nvim/main.c", ["          handle_swap_exists(NULL);", "        dorewind = TRUE;                        /* start again */", "      }"], "readability/bool"]
["src/nvim/main.c", ["      if (got_int) {", "        (void)vgetc();          /* only break the file loading, not the rest */", "        break;"], "readability/old_style_comment"]
["src/nvim/main.c", ["    }", "    if (parmp->window_layout == WIN_TABS)", "      goto_tabpage(1);"], "readability/braces"]
["src/nvim/main.c", ["      goto_tabpage(1);", "    else", "      curwin = firstwin;"], "readability/braces"]
["src/nvim/main.c", ["    curbuf = curwin->w_buffer;", "    --autocmd_no_enter;", "    --autocmd_no_leave;"], "readability/increment"]
["src/nvim/main.c", ["    --autocmd_no_enter;", "    --autocmd_no_leave;", "  }"], "readability/increment"]
["src/nvim/main.c", ["{", "  int arg_idx;                          /* index in argument list */", "  int i;"], "readability/old_style_comment"]
["src/nvim/main.c", ["", "  /*", "   * Don't execute Win/Buf Enter/Leave autocommands here"], "readability/old_style_comment"]
["src/nvim/main.c", ["   */", "  ++autocmd_no_enter;", "  ++autocmd_no_leave;"], "readability/increment"]
["src/nvim/main.c", ["  ++autocmd_no_enter;", "  ++autocmd_no_leave;", ""], "readability/increment"]
["src/nvim/main.c", ["", "  /* When w_arg_idx is -1 remove the window (see create_windows()). */", "  if (curwin->w_arg_idx == -1) {"], "readability/old_style_comment"]
["src/nvim/main.c", ["  arg_idx = 1;", "  for (i = 1; i < parmp->window_count; ++i) {", "    if (cwd != NULL) {"], "readability/increment"]
["src/nvim/main.c", ["      if (parmp->window_layout == WIN_TABS) {", "        if (curtab->tp_next == NULL)            /* just checking */", "          break;"], "readability/old_style_comment"]
["src/nvim/main.c", ["      if (parmp->window_layout == WIN_TABS) {", "        if (curtab->tp_next == NULL)            /* just checking */", "          break;"], "readability/braces"]
["src/nvim/main.c", ["      } else {", "        if (curwin->w_next == NULL)             /* just checking */", "          break;"], "readability/old_style_comment"]
["src/nvim/main.c", ["      } else {", "        if (curwin->w_next == NULL)             /* just checking */", "          break;"], "readability/braces"]
["src/nvim/main.c", ["      curwin->w_arg_idx = arg_idx;", "      /* Edit file from arg list, if there is one.  When \"Quit\" selected", "       * at the ATTENTION prompt close the window. */"], "readability/old_style_comment"]
["src/nvim/main.c", ["       * at the ATTENTION prompt close the window. */", "      swap_exists_did_quit = FALSE;", "      (void)do_ecmd(0, arg_idx < GARGCOUNT"], "readability/bool"]
["src/nvim/main.c", ["      (void)do_ecmd(0, arg_idx < GARGCOUNT", "          ? alist_name(&GARGLIST[arg_idx]) : NULL,", "          NULL, NULL, ECMD_LASTL, ECMD_HIDE, curwin);"], "whitespace/alignment"]
["src/nvim/main.c", ["          ? alist_name(&GARGLIST[arg_idx]) : NULL,", "          NULL, NULL, ECMD_LASTL, ECMD_HIDE, curwin);", "      if (swap_exists_did_quit) {"], "whitespace/alignment"]
["src/nvim/main.c", ["      if (swap_exists_did_quit) {", "        /* abort or quit selected */", "        if (got_int || only_one_window()) {"], "readability/old_style_comment"]
["src/nvim/main.c", ["        if (got_int || only_one_window()) {", "          /* abort selected and only one window */", "          did_emsg = FALSE;             /* avoid hit-enter prompt */"], "readability/old_style_comment"]
["src/nvim/main.c", ["          /* abort selected and only one window */", "          did_emsg = FALSE;             /* avoid hit-enter prompt */", "          getout(1);"], "readability/old_style_comment"]
["src/nvim/main.c", ["          /* abort selected and only one window */", "          did_emsg = FALSE;             /* avoid hit-enter prompt */", "          getout(1);"], "readability/bool"]
["src/nvim/main.c", ["    if (got_int) {", "      (void)vgetc();            /* only break the file loading, not the rest */", "      break;"], "readability/old_style_comment"]
["src/nvim/main.c", ["", "  if (parmp->window_layout == WIN_TABS)", "    goto_tabpage(1);"], "readability/braces"]
["src/nvim/main.c", ["    goto_tabpage(1);", "  --autocmd_no_enter;", ""], "readability/increment"]
["src/nvim/main.c", ["", "  /* make the first window the current window */", "  win = firstwin;"], "readability/old_style_comment"]
["src/nvim/main.c", ["  win = firstwin;", "  /* Avoid making a preview window the current window. */", "  while (win->w_p_pvw) {"], "readability/old_style_comment"]
["src/nvim/main.c", ["", "  --autocmd_no_leave;", "  TIME_MSG(\"editing files in windows\");"], "readability/increment"]
["src/nvim/main.c", ["  TIME_MSG(\"editing files in windows\");", "  if (parmp->window_count > 1 && parmp->window_layout != WIN_TABS)", "    win_equal(curwin, false, 'b');      /* adjust heights */"], "readability/braces"]
["src/nvim/main.c", ["  if (parmp->window_count > 1 && parmp->window_layout != WIN_TABS)", "    win_equal(curwin, false, 'b');      /* adjust heights */", "}"], "readability/old_style_comment"]
["src/nvim/main.c", ["", "/*", " * Execute the commands from --cmd arguments \"cmds[cnt]\"."], "readability/old_style_comment"]
["src/nvim/main.c", ["  if (cnt > 0) {", "    curwin->w_cursor.lnum = 0;     /* just in case.. */", "    sourcing_name = (char_u *)_(\"pre-vimrc command line\");"], "readability/old_style_comment"]
["src/nvim/main.c", ["", "/*", " * Execute \"+\", \"-c\" and \"-S\" arguments."], "readability/old_style_comment"]
["src/nvim/main.c", ["", "  /*", "   * We start commands on line 0, make \"vim +/pat file\" match a"], "readability/old_style_comment"]
["src/nvim/main.c", ["   */", "  msg_scroll = TRUE;", "  if (parmp->tagname == NULL && curwin->w_cursor.lnum <= 1)"], "readability/bool"]
["src/nvim/main.c", ["  msg_scroll = TRUE;", "  if (parmp->tagname == NULL && curwin->w_cursor.lnum <= 1)", "    curwin->w_cursor.lnum = 0;"], "readability/braces"]
["src/nvim/main.c", ["    do_cmdline_cmd(parmp->commands[i]);", "    if (parmp->cmds_tofree[i])", "      xfree(parmp->commands[i]);"], "readability/braces"]
["src/nvim/main.c", ["", "  if (!exmode_active)", "    msg_scroll = FALSE;"], "readability/braces"]
["src/nvim/main.c", ["  if (!exmode_active)", "    msg_scroll = FALSE;", ""], "readability/bool"]
["src/nvim/main.c", ["", "  /* When started with \"-q errorfile\" jump to first error again. */", "  if (parmp->edit_type == EDIT_QF)"], "readability/old_style_comment"]
["src/nvim/main.c", ["  /* When started with \"-q errorfile\" jump to first error again. */", "  if (parmp->edit_type == EDIT_QF)", "    qf_jump(NULL, 0, 0, FALSE);"], "readability/braces"]
["src/nvim/main.c", ["  if (parmp->edit_type == EDIT_QF)", "    qf_jump(NULL, 0, 0, FALSE);", "  TIME_MSG(\"executing command arguments\");"], "readability/bool"]
["src/nvim/main.c", ["      memmove(vimrc + dir_len + 1, path_tail, sizeof(path_tail));", "      if (do_source((char_u *) vimrc, true, DOSO_VIMRC) != FAIL) {", "        do_exrc = p_exrc;"], "whitespace/cast"]
["src/nvim/main.c", ["      // If vimrc file is not owned by user, set 'secure' mode.", "      if (!file_owned(VIMRC_FILE))", "#endif"], "readability/braces"]
["src/nvim/main.c", ["{", "  info_message = TRUE;  // use mch_msg(), not mch_errmsg()", "  list_version();"], "readability/bool"]
["src/nvim/main.c", ["  msg_putchar('\\n');", "  msg_didout = FALSE;", "}"], "readability/bool"]
["src/nvim/main.c", ["  mch_msg(_(\"  nvim [options] [file ...]      Edit file(s)\\n\"));", "  mch_msg(_(\"  nvim [options] -t <tag>        Edit file where tag is defined\\n\"));", "  mch_msg(_(\"  nvim [options] -q [errorfile]  Edit file with first error\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  --cmd <cmd>           Execute <cmd> before any config\\n\"));", "  mch_msg(_(\"  +<cmd>, -c <cmd>      Execute <cmd> after config and first file\\n\"));", "  mch_msg(\"\\n\");"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  -i <shada>            Use this shada file\\n\"));", "  mch_msg(_(\"  -m                    Modifications (writing files) not allowed\\n\"));", "  mch_msg(_(\"  -M                    Modifications in text not allowed\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  -n                    No swap file, use memory only\\n\"));", "  mch_msg(_(\"  -o[N]                 Open N windows (default: one per file)\\n\"));", "  mch_msg(_(\"  -O[N]                 Open N vertical windows (default: one per file)\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  -o[N]                 Open N windows (default: one per file)\\n\"));", "  mch_msg(_(\"  -O[N]                 Open N vertical windows (default: one per file)\\n\"));", "  mch_msg(_(\"  -p[N]                 Open N tab pages (default: one per file)\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  -O[N]                 Open N vertical windows (default: one per file)\\n\"));", "  mch_msg(_(\"  -p[N]                 Open N tab pages (default: one per file)\\n\"));", "  mch_msg(_(\"  -r, -L                List swap files\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  -R                    Read-only mode\\n\"));", "  mch_msg(_(\"  -S <session>          Source <session> after loading the first file\\n\"));", "  mch_msg(_(\"  -s <scriptin>         Read Normal mode commands from <scriptin>\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  -S <session>          Source <session> after loading the first file\\n\"));", "  mch_msg(_(\"  -s <scriptin>         Read Normal mode commands from <scriptin>\\n\"));", "  mch_msg(_(\"  -u <config>           Use this config file\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(\"\\n\");", "  mch_msg(_(\"  --api-info            Write msgpack-encoded API metadata to stdout\\n\"));", "  mch_msg(_(\"  --embed               Use stdin/stdout as a msgpack-rpc channel\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  --api-info            Write msgpack-encoded API metadata to stdout\\n\"));", "  mch_msg(_(\"  --embed               Use stdin/stdout as a msgpack-rpc channel\\n\"));", "  mch_msg(_(\"  --headless            Don't start a user interface\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  --noplugin            Don't load plugins\\n\"));", "  mch_msg(_(\"  --startuptime <file>  Write startup timing messages to <file>\\n\"));", "  mch_msg(_(\"\\nSee \\\":help startup-options\\\" for all options.\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["", "/*", " * Check the result of the ATTENTION dialog:"], "readability/old_style_comment"]
["src/nvim/main.c", ["{", "  if (swap_exists_action == SEA_QUIT)", "    getout(1);"], "readability/braces"]
["src/nvim/mark.c", ["", "/*", " * mark.c: functions for setting marks and jumping to them"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * This file contains routines to maintain and manipulate marks."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * If a named file mark's lnum is non-zero, it is valid."], "readability/old_style_comment"]
["src/nvim/mark.c", ["#endif", "/*", " * Set named mark \"c\" at current cursor position."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * Set named mark \"c\" to position \"pos\"."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* Check for a special key (may cause islower() to crash). */", "  if (c < 0)"], "readability/old_style_comment"]
["src/nvim/mark.c", ["  /* Check for a special key (may cause islower() to crash). */", "  if (c < 0)", "    return FAIL;"], "readability/braces"]
["src/nvim/mark.c", ["      setpcmark();", "      /* keep it even when the cursor doesn't move */", "      curwin->w_prev_pcmark = curwin->w_pcmark;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["      curwin->w_prev_pcmark = curwin->w_pcmark;", "    } else", "      curwin->w_pcmark = *pos;"], "readability/braces"]
["src/nvim/mark.c", ["", "  /* Allow setting '[ and '] for an autocommand that simulates reading a", "   * file. */"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * Set the previous context mark to the current position and add it to the"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* for :global the mark is set only once */", "  if (global_busy || listcmd_busy || cmdmod.keepjumps)"], "readability/old_style_comment"]
["src/nvim/mark.c", ["  /* for :global the mark is set only once */", "  if (global_busy || listcmd_busy || cmdmod.keepjumps)", "    return;"], "readability/braces"]
["src/nvim/mark.c", ["", "  /* If jumplist is full: remove oldest entry */", "  if (++curwin->w_jumplistlen > JUMPLISTSIZE) {"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * To change context, call setpcmark(), then move the current position to"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    curwin->w_pcmark = curwin->w_prev_pcmark;", "    curwin->w_prev_pcmark.lnum = 0;             /* Show it has been checked */", "  }"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * move \"count\" positions in the jump list (count may be negative)"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  if (curwin->w_jumplistlen == 0)           /* nothing to jump to */", "    return (pos_T *)NULL;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  if (curwin->w_jumplistlen == 0)           /* nothing to jump to */", "    return (pos_T *)NULL;"], "readability/braces"]
["src/nvim/mark.c", ["  for (;; ) {", "    if (curwin->w_jumplistidx + count < 0", "        || curwin->w_jumplistidx + count >= curwin->w_jumplistlen)"], "readability/braces"]
["src/nvim/mark.c", ["", "    /*", "     * if first CTRL-O or CTRL-I command after a jump, add cursor position"], "readability/old_style_comment"]
["src/nvim/mark.c", ["      setpcmark();", "      --curwin->w_jumplistidx;          /* skip the new entry */", "      if (curwin->w_jumplistidx + count < 0)"], "readability/old_style_comment"]
["src/nvim/mark.c", ["      setpcmark();", "      --curwin->w_jumplistidx;          /* skip the new entry */", "      if (curwin->w_jumplistidx + count < 0)"], "readability/increment"]
["src/nvim/mark.c", ["      --curwin->w_jumplistidx;          /* skip the new entry */", "      if (curwin->w_jumplistidx + count < 0)", "        return (pos_T *)NULL;"], "readability/braces"]
["src/nvim/mark.c", ["    jmp = curwin->w_jumplist + curwin->w_jumplistidx;", "    if (jmp->fmark.fnum == 0)", "      fname2fnum(jmp);"], "readability/braces"]
["src/nvim/mark.c", ["    if (jmp->fmark.fnum != curbuf->b_fnum) {", "      /* jump to other file */", "      if (buflist_findnr(jmp->fmark.fnum) == NULL) { /* Skip this one .. */"], "readability/old_style_comment"]
["src/nvim/mark.c", ["      /* jump to other file */", "      if (buflist_findnr(jmp->fmark.fnum) == NULL) { /* Skip this one .. */", "        count += count < 0 ? -1 : 1;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["      }", "      if (buflist_getfile(jmp->fmark.fnum, jmp->fmark.mark.lnum,", "              0, FALSE) == FAIL)"], "readability/braces"]
["src/nvim/mark.c", ["      if (buflist_getfile(jmp->fmark.fnum, jmp->fmark.mark.lnum,", "              0, FALSE) == FAIL)", "        return (pos_T *)NULL;"], "whitespace/alignment"]
["src/nvim/mark.c", ["      if (buflist_getfile(jmp->fmark.fnum, jmp->fmark.mark.lnum,", "              0, FALSE) == FAIL)", "        return (pos_T *)NULL;"], "readability/bool"]
["src/nvim/mark.c", ["        return (pos_T *)NULL;", "      /* Set lnum again, autocommands my have changed it */", "      curwin->w_cursor = jmp->fmark.mark;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["      pos = (pos_T *)-1;", "    } else", "      pos = &(jmp->fmark.mark);"], "readability/braces"]
["src/nvim/mark.c", ["", "/*", " * Move \"count\" positions in the changelist (count may be negative)."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  if (curbuf->b_changelistlen == 0)         /* nothing to jump to */", "    return (pos_T *)NULL;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  if (curbuf->b_changelistlen == 0)         /* nothing to jump to */", "    return (pos_T *)NULL;"], "readability/braces"]
["src/nvim/mark.c", ["  if (n + count < 0) {", "    if (n == 0)", "      return (pos_T *)NULL;"], "readability/braces"]
["src/nvim/mark.c", ["  } else if (n + count >= curbuf->b_changelistlen) {", "    if (n == curbuf->b_changelistlen - 1)", "      return (pos_T *)NULL;"], "readability/braces"]
["src/nvim/mark.c", ["    n = curbuf->b_changelistlen - 1;", "  } else", "    n += count;"], "readability/braces"]
["src/nvim/mark.c", ["", "/*", " * Find mark \"c\" in buffer pointed to by \"buf\"."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* Check for special key, can't be a mark name and might cause islower()", "   * to crash. */"], "readability/old_style_comment"]
["src/nvim/mark.c", ["   * to crash. */", "  if (c < 0)", "    return posp;"], "readability/braces"]
["src/nvim/mark.c", ["    pos = curwin->w_cursor;", "    listcmd_busy = TRUE;            /* avoid that '' is changed */", "    if (findpar(&oa.inclusive,"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    pos = curwin->w_cursor;", "    listcmd_busy = TRUE;            /* avoid that '' is changed */", "    if (findpar(&oa.inclusive,"], "readability/bool"]
["src/nvim/mark.c", ["    if (findpar(&oa.inclusive,", "            c == '}' ? FORWARD : BACKWARD, 1L, NUL, FALSE)) {", "      pos_copy = curwin->w_cursor;"], "whitespace/alignment"]
["src/nvim/mark.c", ["    if (findpar(&oa.inclusive,", "            c == '}' ? FORWARD : BACKWARD, 1L, NUL, FALSE)) {", "      pos_copy = curwin->w_cursor;"], "readability/bool"]
["src/nvim/mark.c", ["    listcmd_busy = slcb;", "  } else if (c == '(' || c == ')') {  /* to previous/next sentence */", "    pos_T pos;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    pos = curwin->w_cursor;", "    listcmd_busy = TRUE;            /* avoid that '' is changed */", "    if (findsent(c == ')' ? FORWARD : BACKWARD, 1L)) {"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    pos = curwin->w_cursor;", "    listcmd_busy = TRUE;            /* avoid that '' is changed */", "    if (findsent(c == ')' ? FORWARD : BACKWARD, 1L)) {"], "readability/bool"]
["src/nvim/mark.c", ["    listcmd_busy = slcb;", "  } else if (c == '<' || c == '>') {  /* start/end of visual area */", "    startp = &buf->b_visual.vi_start;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["      posp = &pos_copy;", "      if (c == '<')", "        pos_copy.col = 0;"], "readability/braces"]
["src/nvim/mark.c", ["        pos_copy.col = 0;", "      else", "        pos_copy.col = MAXCOL;"], "readability/braces"]
["src/nvim/mark.c", ["    }", "  } else if (ASCII_ISLOWER(c)) {      /* normal named mark */", "    posp = &(buf->b_namedm[c - 'a'].mark);"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    posp = &(buf->b_namedm[c - 'a'].mark);", "  } else if (ASCII_ISUPPER(c) || ascii_isdigit(c)) {    /* named file mark */", "    if (ascii_isdigit(c))"], "readability/old_style_comment"]
["src/nvim/mark.c", ["  } else if (ASCII_ISUPPER(c) || ascii_isdigit(c)) {    /* named file mark */", "    if (ascii_isdigit(c))", "      c = c - '0' + NMARKS;"], "readability/braces"]
["src/nvim/mark.c", ["      c = c - '0' + NMARKS;", "    else", "      c -= 'A';"], "readability/braces"]
["src/nvim/mark.c", ["", "    if (fnum != NULL)", "      *fnum = namedfm[c].fmark.fnum;"], "readability/braces"]
["src/nvim/mark.c", ["      *fnum = namedfm[c].fmark.fnum;", "    else if (namedfm[c].fmark.fnum != buf->b_fnum) {", "      /* mark is in another file */"], "readability/braces"]
["src/nvim/mark.c", ["    else if (namedfm[c].fmark.fnum != buf->b_fnum) {", "      /* mark is in another file */", "      posp = &pos_copy;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["        if (buflist_getfile(namedfm[c].fmark.fnum,", "                (linenr_T)1, GETF_SETMARK, FALSE) == OK) {", "          /* Set the lnum now, autocommands could have changed it */"], "whitespace/alignment"]
["src/nvim/mark.c", ["        if (buflist_getfile(namedfm[c].fmark.fnum,", "                (linenr_T)1, GETF_SETMARK, FALSE) == OK) {", "          /* Set the lnum now, autocommands could have changed it */"], "readability/bool"]
["src/nvim/mark.c", ["                (linenr_T)1, GETF_SETMARK, FALSE) == OK) {", "          /* Set the lnum now, autocommands could have changed it */", "          curwin->w_cursor = namedfm[c].fmark.mark;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["        }", "        pos_copy.lnum = -1;             /* can't get file */", "      } else"], "readability/old_style_comment"]
["src/nvim/mark.c", ["        pos_copy.lnum = -1;             /* can't get file */", "      } else", "        pos_copy.lnum = 0;              /* mark exists, but is not valid in"], "readability/braces"]
["src/nvim/mark.c", ["      } else", "        pos_copy.lnum = 0;              /* mark exists, but is not valid in", "                                           current buffer */"], "readability/multiline_comment"]
["src/nvim/mark.c", ["      } else", "        pos_copy.lnum = 0;              /* mark exists, but is not valid in", "                                           current buffer */"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * Search for the next named mark in the current file."], "readability/old_style_comment"]
["src/nvim/mark.c", ["pos_T *", "getnextmark (", "    pos_T *startpos,          /* where to start */"], "whitespace/parens"]
["src/nvim/mark.c", ["getnextmark (", "    pos_T *startpos,          /* where to start */", "    int dir,                /* direction for search */"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    pos_T *startpos,          /* where to start */", "    int dir,                /* direction for search */", "    int begin_line"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* When searching backward and leaving the cursor on the first non-blank,", "   * position must be in a previous line."], "readability/old_style_comment"]
["src/nvim/mark.c", ["   * position must be in a next line. */", "  if (dir == BACKWARD && begin_line)", "    pos.col = 0;"], "readability/braces"]
["src/nvim/mark.c", ["    pos.col = 0;", "  else if (dir == FORWARD && begin_line)", "    pos.col = MAXCOL;"], "readability/braces"]
["src/nvim/mark.c", ["      if (dir == FORWARD) {", "        if ((result == NULL || lt(curbuf->b_namedm[i].mark, *result))", "            && lt(pos, curbuf->b_namedm[i].mark))"], "readability/braces"]
["src/nvim/mark.c", ["      } else {", "        if ((result == NULL || lt(*result, curbuf->b_namedm[i].mark))", "            && lt(curbuf->b_namedm[i].mark, pos))"], "readability/braces"]
["src/nvim/mark.c", ["", "/*", " * For an xtended filemark: set the fnum from the fname."], "readability/old_style_comment"]
["src/nvim/mark.c", ["  if (fm->fname != NULL) {", "    /*", "     * First expand \"~/\" in the file name to the home directory."], "readability/old_style_comment"]
["src/nvim/mark.c", ["#endif", "                                )) {", "      int len;"], "whitespace/parens"]
["src/nvim/mark.c", ["      STRLCPY(NameBuff + len, fm->fname + 2, MAXPATHL - len);", "    } else", "      STRLCPY(NameBuff, fm->fname, MAXPATHL);"], "readability/braces"]
["src/nvim/mark.c", ["", "    /* Try to shorten the file name. */", "    os_dirname(IObuff, IOSIZE);"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * Check all file marks for a name that matches the file name in buf."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  if (buf->b_ffname == NULL)", "    return;"], "readability/braces"]
["src/nvim/mark.c", ["", "  for (i = 0; i < NGLOBALMARKS; ++i)", "    fmarks_check_one(&namedfm[i], name, buf);"], "readability/braces"]
["src/nvim/mark.c", ["", "  for (i = 0; i < NGLOBALMARKS; ++i)", "    fmarks_check_one(&namedfm[i], name, buf);"], "readability/increment"]
["src/nvim/mark.c", ["  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {", "    for (i = 0; i < wp->w_jumplistlen; ++i) {", "      fmarks_check_one(&wp->w_jumplist[i], name, buf);"], "readability/increment"]
["src/nvim/mark.c", ["", "/*", " * Check a if a position from a mark is valid."], "readability/old_style_comment"]
["src/nvim/mark.c", ["  if (pos->lnum <= 0) {", "    /* lnum is negative if mark is in another file can can't get that", "     * file, error message already give then. */"], "readability/old_style_comment"]
["src/nvim/mark.c", ["     * file, error message already give then. */", "    if (pos->lnum == 0)", "      EMSG(_(e_marknotset));"], "readability/braces"]
["src/nvim/mark.c", ["", "/*", " * Get name of file from a filemark."], "readability/old_style_comment"]
["src/nvim/mark.c", ["{", "  if (fmark->fnum == curbuf->b_fnum)                /* current buffer */", "    return mark_line(&(fmark->mark), lead_len);"], "readability/old_style_comment"]
["src/nvim/mark.c", ["{", "  if (fmark->fnum == curbuf->b_fnum)                /* current buffer */", "    return mark_line(&(fmark->mark), lead_len);"], "readability/braces"]
["src/nvim/mark.c", ["    return mark_line(&(fmark->mark), lead_len);", "  return buflist_nr2name(fmark->fnum, FALSE, TRUE);", "}"], "readability/bool"]
["src/nvim/mark.c", ["", "/*", " * Return the line at mark \"mp\".  Truncate to fit in window."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  if (mp->lnum == 0 || mp->lnum > curbuf->b_ml.ml_line_count)", "    return vim_strsave((char_u *)\"-invalid-\");"], "readability/braces"]
["src/nvim/mark.c", ["    len += ptr2cells(p);", "    if (len >= Columns - lead_len)", "      break;"], "readability/braces"]
["src/nvim/mark.c", ["", "/*", " * print the marks"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  if (arg != NULL && *arg == NUL)", "    arg = NULL;"], "readability/braces"]
["src/nvim/mark.c", ["  show_one_mark('\\'', arg, &curwin->w_pcmark, NULL, true);", "  for (i = 0; i < NMARKS; ++i)", "    show_one_mark(i + 'a', arg, &curbuf->b_namedm[i].mark, NULL, true);"], "readability/braces"]
["src/nvim/mark.c", ["  show_one_mark('\\'', arg, &curwin->w_pcmark, NULL, true);", "  for (i = 0; i < NMARKS; ++i)", "    show_one_mark(i + 'a', arg, &curbuf->b_namedm[i].mark, NULL, true);"], "readability/increment"]
["src/nvim/mark.c", ["    show_one_mark(i + 'a', arg, &curbuf->b_namedm[i].mark, NULL, true);", "  for (i = 0; i < NGLOBALMARKS; ++i) {", "    if (namedfm[i].fmark.fnum != 0)"], "readability/increment"]
["src/nvim/mark.c", ["  for (i = 0; i < NGLOBALMARKS; ++i) {", "    if (namedfm[i].fmark.fnum != 0)", "      name = fm_getname(&namedfm[i].fmark, 15);"], "readability/braces"]
["src/nvim/mark.c", ["      name = fm_getname(&namedfm[i].fmark, 15);", "    else", "      name = namedfm[i].fname;"], "readability/braces"]
["src/nvim/mark.c", ["      show_one_mark(i >= NMARKS ? i - NMARKS + '0' : i + 'A',", "          arg, &namedfm[i].fmark.mark, name,", "          namedfm[i].fmark.fnum == curbuf->b_fnum);"], "whitespace/alignment"]
["src/nvim/mark.c", ["          arg, &namedfm[i].fmark.mark, name,", "          namedfm[i].fmark.fnum == curbuf->b_fnum);", "      if (namedfm[i].fmark.fnum != 0)"], "whitespace/alignment"]
["src/nvim/mark.c", ["          namedfm[i].fmark.fnum == curbuf->b_fnum);", "      if (namedfm[i].fmark.fnum != 0)", "        xfree(name);"], "readability/braces"]
["src/nvim/mark.c", ["", "/*", " * \":delmarks[!] [marks]\""], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  if (*eap->arg == NUL && eap->forceit)", "    /* clear all marks */"], "readability/braces"]
["src/nvim/mark.c", ["  if (*eap->arg == NUL && eap->forceit)", "    /* clear all marks */", "    clrallmarks(curbuf);"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    clrallmarks(curbuf);", "  else if (eap->forceit)", "    EMSG(_(e_invarg));"], "readability/braces"]
["src/nvim/mark.c", ["    EMSG(_(e_invarg));", "  else if (*eap->arg == NUL)", "    EMSG(_(e_argreq));"], "readability/braces"]
["src/nvim/mark.c", ["    EMSG(_(e_argreq));", "  else {", "    /* clear specified marks only */"], "readability/braces"]
["src/nvim/mark.c", ["    EMSG(_(e_argreq));", "  else {", "    /* clear specified marks only */"], "readability/braces"]
["src/nvim/mark.c", ["  else {", "    /* clear specified marks only */", "    for (p = eap->arg; *p != NUL; ++p) {"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    /* clear specified marks only */", "    for (p = eap->arg; *p != NUL; ++p) {", "      lower = ASCII_ISLOWER(*p);"], "readability/increment"]
["src/nvim/mark.c", ["        if (p[1] == '-') {", "          /* clear range of marks */", "          from = *p;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["          p += 2;", "        } else", "          /* clear one lower case mark */"], "readability/braces"]
["src/nvim/mark.c", ["        } else", "          /* clear one lower case mark */", "          from = to = *p;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "        for (i = from; i <= to; ++i) {", "          if (lower) {"], "readability/increment"]
["src/nvim/mark.c", ["        }", "      } else", "        switch (*p) {"], "readability/braces"]
["src/nvim/mark.c", ["", "/*", " * print the jumplist"], "readability/old_style_comment"]
["src/nvim/mark.c", ["  MSG_PUTS_TITLE(_(\"\\n jump line  col file/text\"));", "  for (i = 0; i < curwin->w_jumplistlen && !got_int; ++i) {", "    if (curwin->w_jumplist[i].fmark.mark.lnum != 0) {"], "readability/increment"]
["src/nvim/mark.c", ["      sprintf((char *)IObuff, \"%c %2d %5ld %4d \",", "          i == curwin->w_jumplistidx ? '>' : ' ',", "          i > curwin->w_jumplistidx ? i - curwin->w_jumplistidx"], "whitespace/alignment"]
["src/nvim/mark.c", ["          i == curwin->w_jumplistidx ? '>' : ' ',", "          i > curwin->w_jumplistidx ? i - curwin->w_jumplistidx", "          : curwin->w_jumplistidx - i,"], "whitespace/alignment"]
["src/nvim/mark.c", ["          i > curwin->w_jumplistidx ? i - curwin->w_jumplistidx", "          : curwin->w_jumplistidx - i,", "          curwin->w_jumplist[i].fmark.mark.lnum,"], "whitespace/alignment"]
["src/nvim/mark.c", ["          : curwin->w_jumplistidx - i,", "          curwin->w_jumplist[i].fmark.mark.lnum,", "          curwin->w_jumplist[i].fmark.mark.col);"], "whitespace/alignment"]
["src/nvim/mark.c", ["          curwin->w_jumplist[i].fmark.mark.lnum,", "          curwin->w_jumplist[i].fmark.mark.col);", "      msg_outtrans(IObuff);"], "whitespace/alignment"]
["src/nvim/mark.c", ["      }", "      sprintf((char *)IObuff, \"%c %2d %5ld %4d \",", "          i == curwin->w_jumplistidx ? '>' : ' ',"], "runtime/printf"]
["src/nvim/mark.c", ["  }", "  if (curwin->w_jumplistidx == curwin->w_jumplistlen)", "    MSG_PUTS(\"\\n>\");"], "readability/braces"]
["src/nvim/mark.c", ["", "/*", " * print the changelist"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  for (i = 0; i < curbuf->b_changelistlen && !got_int; ++i) {", "    if (curbuf->b_changelist[i].mark.lnum != 0) {"], "readability/increment"]
["src/nvim/mark.c", ["      msg_putchar('\\n');", "      if (got_int)", "        break;"], "readability/braces"]
["src/nvim/mark.c", ["      sprintf((char *)IObuff, \"%c %3d %5ld %4d \",", "          i == curwin->w_changelistidx ? '>' : ' ',", "          i > curwin->w_changelistidx ? i - curwin->w_changelistidx"], "whitespace/alignment"]
["src/nvim/mark.c", ["          i == curwin->w_changelistidx ? '>' : ' ',", "          i > curwin->w_changelistidx ? i - curwin->w_changelistidx", "          : curwin->w_changelistidx - i,"], "whitespace/alignment"]
["src/nvim/mark.c", ["          i > curwin->w_changelistidx ? i - curwin->w_changelistidx", "          : curwin->w_changelistidx - i,", "          (long)curbuf->b_changelist[i].mark.lnum,"], "whitespace/alignment"]
["src/nvim/mark.c", ["          : curwin->w_changelistidx - i,", "          (long)curbuf->b_changelist[i].mark.lnum,", "          curbuf->b_changelist[i].mark.col);"], "whitespace/alignment"]
["src/nvim/mark.c", ["          (long)curbuf->b_changelist[i].mark.lnum,", "          curbuf->b_changelist[i].mark.col);", "      msg_outtrans(IObuff);"], "whitespace/alignment"]
["src/nvim/mark.c", ["        break;", "      sprintf((char *)IObuff, \"%c %3d %5ld %4d \",", "          i == curwin->w_changelistidx ? '>' : ' ',"], "runtime/printf"]
["src/nvim/mark.c", ["  }", "  if (curwin->w_changelistidx == curbuf->b_changelistlen)", "    MSG_PUTS(\"\\n>\");"], "readability/braces"]
["src/nvim/mark.c", ["    lp = add; \\", "    if (*lp >= line1 && *lp <= line2) \\", "    { \\"], "readability/braces"]
["src/nvim/mark.c", ["    { \\", "      if (amount == MAXLNUM) \\", "        *lp = 0; \\"], "readability/braces"]
["src/nvim/mark.c", ["        *lp = 0; \\", "      else \\", "        *lp += amount; \\"], "readability/braces"]
["src/nvim/mark.c", ["        *lp = 0; \\", "      else \\", "        *lp += amount; \\"], "whitespace/newline"]
["src/nvim/mark.c", ["    } \\", "    else if (amount_after && *lp > line2) \\", "      *lp += amount_after; \\"], "readability/braces"]
["src/nvim/mark.c", ["", "/* don't delete the line, just put at first deleted line */", "#define one_adjust_nodel(add) \\"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    lp = add; \\", "    if (*lp >= line1 && *lp <= line2) \\", "    { \\"], "readability/braces"]
["src/nvim/mark.c", ["    { \\", "      if (amount == MAXLNUM) \\", "        *lp = line1; \\"], "readability/braces"]
["src/nvim/mark.c", ["        *lp = line1; \\", "      else \\", "        *lp += amount; \\"], "readability/braces"]
["src/nvim/mark.c", ["        *lp = line1; \\", "      else \\", "        *lp += amount; \\"], "whitespace/newline"]
["src/nvim/mark.c", ["    } \\", "    else if (amount_after && *lp > line2) \\", "      *lp += amount_after; \\"], "readability/braces"]
["src/nvim/mark.c", ["", "/*", " * Adjust marks between line1 and line2 (inclusive) to move 'amount' lines."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  if (line2 < line1 && amount_after == 0L)          /* nothing to do */", "    return;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  if (line2 < line1 && amount_after == 0L)          /* nothing to do */", "    return;"], "readability/braces"]
["src/nvim/mark.c", ["  if (!cmdmod.lockmarks) {", "    /* named marks, lower case and upper case */", "    for (i = 0; i < NMARKS; i++) {"], "readability/old_style_comment"]
["src/nvim/mark.c", ["      one_adjust(&(curbuf->b_namedm[i].mark.lnum));", "      if (namedfm[i].fmark.fnum == fnum)", "        one_adjust_nodel(&(namedfm[i].fmark.mark.lnum));"], "readability/braces"]
["src/nvim/mark.c", ["    for (i = NMARKS; i < NGLOBALMARKS; i++) {", "      if (namedfm[i].fmark.fnum == fnum)", "        one_adjust_nodel(&(namedfm[i].fmark.mark.lnum));"], "readability/braces"]
["src/nvim/mark.c", ["", "    /* last Insert position */", "    one_adjust(&(curbuf->b_last_insert.mark.lnum));"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "    /* last change position */", "    one_adjust(&(curbuf->b_last_change.mark.lnum));"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "    /* last cursor position, if it was set */", "    if (!equalpos(curbuf->b_last_cursor.mark, initpos))"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    /* last cursor position, if it was set */", "    if (!equalpos(curbuf->b_last_cursor.mark, initpos))", "      one_adjust(&(curbuf->b_last_cursor.mark.lnum));"], "readability/braces"]
["src/nvim/mark.c", ["", "    /* list of change positions */", "    for (i = 0; i < curbuf->b_changelistlen; ++i)"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    /* list of change positions */", "    for (i = 0; i < curbuf->b_changelistlen; ++i)", "      one_adjust_nodel(&(curbuf->b_changelist[i].mark.lnum));"], "readability/braces"]
["src/nvim/mark.c", ["    /* list of change positions */", "    for (i = 0; i < curbuf->b_changelistlen; ++i)", "      one_adjust_nodel(&(curbuf->b_changelist[i].mark.lnum));"], "readability/increment"]
["src/nvim/mark.c", ["", "    /* Visual area */", "    one_adjust_nodel(&(curbuf->b_visual.vi_start.lnum));"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* previous context mark */", "  one_adjust(&(curwin->w_pcmark.lnum));"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* previous pcmark */", "  one_adjust(&(curwin->w_prev_pcmark.lnum));"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* saved cursor for formatting */", "  if (saved_cursor.lnum != 0)"], "readability/old_style_comment"]
["src/nvim/mark.c", ["  /* saved cursor for formatting */", "  if (saved_cursor.lnum != 0)", "    one_adjust_nodel(&(saved_cursor.lnum));"], "readability/braces"]
["src/nvim/mark.c", ["", "  /*", "   * Adjust items in all windows related to the current buffer."], "readability/old_style_comment"]
["src/nvim/mark.c", ["    if (!cmdmod.lockmarks) {", "      /* Marks in the jumplist.  When deleting lines, this may create", "       * duplicate marks in the jumplist, they will be removed later. */"], "readability/old_style_comment"]
["src/nvim/mark.c", ["       * duplicate marks in the jumplist, they will be removed later. */", "      for (i = 0; i < win->w_jumplistlen; ++i) {", "        if (win->w_jumplist[i].fmark.fnum == fnum) {"], "readability/increment"]
["src/nvim/mark.c", ["      if (!cmdmod.lockmarks) {", "        /* marks in the tag stack */", "        for (i = 0; i < win->w_tagstacklen; i++) {"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "      /* the displayed Visual area */", "      if (win->w_old_cursor_lnum != 0) {"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "      /* topline and cursor position for windows with the same buffer", "       * other than the current window */"], "readability/old_style_comment"]
["src/nvim/mark.c", ["        if (win->w_topline >= line1 && win->w_topline <= line2) {", "          if (amount == MAXLNUM) {                  /* topline is deleted */", "            if (line1 <= 1) {"], "readability/old_style_comment"]
["src/nvim/mark.c", ["            }", "          } else {                      /* keep topline on the same line */", "            win->w_topline += amount;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["        if (win->w_cursor.lnum >= line1 && win->w_cursor.lnum <= line2) {", "          if (amount == MAXLNUM) {         /* line with cursor is deleted */", "            if (line1 <= 1) {"], "readability/old_style_comment"]
["src/nvim/mark.c", ["            win->w_cursor.col = 0;", "          } else {                      /* keep cursor on the same line */", "            win->w_cursor.lnum += amount;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* adjust diffs */", "  diff_mark_adjust(line1, line2, amount, amount_after);"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/* This code is used often, needs to be fast. */", "#define col_adjust(pp) \\"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    posp = pp; \\", "    if (posp->lnum == lnum && posp->col >= mincol) \\", "    { \\"], "readability/braces"]
["src/nvim/mark.c", ["", "  if ((col_amount == 0L && lnum_amount == 0L) || cmdmod.lockmarks)", "    return;     /* nothing to do */"], "readability/braces"]
["src/nvim/mark.c", ["  if ((col_amount == 0L && lnum_amount == 0L) || cmdmod.lockmarks)", "    return;     /* nothing to do */", ""], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* named marks, lower case and upper case */", "  for (i = 0; i < NMARKS; i++) {"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    col_adjust(&(curbuf->b_namedm[i].mark));", "    if (namedfm[i].fmark.fnum == fnum)", "      col_adjust(&(namedfm[i].fmark.mark));"], "readability/braces"]
["src/nvim/mark.c", ["  for (i = NMARKS; i < NGLOBALMARKS; i++) {", "    if (namedfm[i].fmark.fnum == fnum)", "      col_adjust(&(namedfm[i].fmark.mark));"], "readability/braces"]
["src/nvim/mark.c", ["", "  /* last Insert position */", "  col_adjust(&(curbuf->b_last_insert.mark));"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* last change position */", "  col_adjust(&(curbuf->b_last_change.mark));"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* list of change positions */", "  for (i = 0; i < curbuf->b_changelistlen; ++i)"], "readability/old_style_comment"]
["src/nvim/mark.c", ["  /* list of change positions */", "  for (i = 0; i < curbuf->b_changelistlen; ++i)", "    col_adjust(&(curbuf->b_changelist[i].mark));"], "readability/braces"]
["src/nvim/mark.c", ["  /* list of change positions */", "  for (i = 0; i < curbuf->b_changelistlen; ++i)", "    col_adjust(&(curbuf->b_changelist[i].mark));"], "readability/increment"]
["src/nvim/mark.c", ["", "  /* Visual area */", "  col_adjust(&(curbuf->b_visual.vi_start));"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* previous context mark */", "  col_adjust(&(curwin->w_pcmark));"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* previous pcmark */", "  col_adjust(&(curwin->w_prev_pcmark));"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* saved cursor for formatting */", "  col_adjust(&saved_cursor);"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /*", "   * Adjust items in all windows related to the current buffer."], "readability/old_style_comment"]
["src/nvim/mark.c", ["  FOR_ALL_WINDOWS_IN_TAB(win, curtab) {", "    /* marks in the jumplist */", "    for (i = 0; i < win->w_jumplistlen; ++i) {"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    /* marks in the jumplist */", "    for (i = 0; i < win->w_jumplistlen; ++i) {", "      if (win->w_jumplist[i].fmark.fnum == fnum) {"], "readability/increment"]
["src/nvim/mark.c", ["    if (win->w_buffer == curbuf) {", "      /* marks in the tag stack */", "      for (i = 0; i < win->w_tagstacklen; i++) {"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "      /* cursor position for other windows with the same buffer */", "      if (win != curwin) {"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * Copy the jumplist from window \"from\" to window \"to\"."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  for (i = 0; i < from->w_jumplistlen; ++i) {", "    to->w_jumplist[i] = from->w_jumplist[i];"], "readability/increment"]
["src/nvim/mark.c", ["    to->w_jumplist[i] = from->w_jumplist[i];", "    if (from->w_jumplist[i].fname != NULL)", "      to->w_jumplist[i].fname = vim_strsave(from->w_jumplist[i].fname);"], "readability/braces"]
["src/nvim/mark.c", ["  if (iter == NULL && win->w_jumplistlen == 0) {", "    *fm = (xfmark_T) {{{0, 0, 0}, 0, 0, NULL}, NULL};", "    return NULL;"], "whitespace/braces"]
["src/nvim/mark.c", ["  if (iter == NULL && win->w_jumplistlen == 0) {", "    *fm = (xfmark_T) {{{0, 0, 0}, 0, 0, NULL}, NULL};", "    return NULL;"], "whitespace/braces"]
["src/nvim/mark.c", ["       ? &(win->w_jumplist[0])", "       : (const xfmark_T *const) iter);", "  *fm = *iter_mark;"], "whitespace/cast"]
["src/nvim/mark.c", ["                               ? &(namedfm[0])", "                               : (const xfmark_T *const) iter);", "  while ((size_t) (iter_mark - &(namedfm[0])) < ARRAY_SIZE(namedfm)"], "whitespace/cast"]
["src/nvim/mark.c", ["                               : (const xfmark_T *const) iter);", "  while ((size_t) (iter_mark - &(namedfm[0])) < ARRAY_SIZE(namedfm)", "         && !iter_mark->fmark.mark.lnum) {"], "whitespace/cast"]
["src/nvim/mark.c", ["  }", "  if ((size_t) (iter_mark - &(namedfm[0])) == ARRAY_SIZE(namedfm)", "      || !iter_mark->fmark.mark.lnum) {"], "whitespace/cast"]
["src/nvim/mark.c", ["  }", "  size_t iter_off = (size_t) (iter_mark - &(namedfm[0]));", "  *name = (char) (iter_off < NMARKS"], "whitespace/cast"]
["src/nvim/mark.c", ["  size_t iter_off = (size_t) (iter_mark - &(namedfm[0]));", "  *name = (char) (iter_off < NMARKS", "                  ? 'A' + (char) iter_off"], "whitespace/cast"]
["src/nvim/mark.c", ["  *name = (char) (iter_off < NMARKS", "                  ? 'A' + (char) iter_off", "                  : '0' + (char) (iter_off - NMARKS));"], "whitespace/cast"]
["src/nvim/mark.c", ["                  ? 'A' + (char) iter_off", "                  : '0' + (char) (iter_off - NMARKS));", "  *fm = *iter_mark;"], "whitespace/cast"]
["src/nvim/mark.c", ["  *fm = *iter_mark;", "  while ((size_t) (++iter_mark - &(namedfm[0])) < ARRAY_SIZE(namedfm)) {", "    if (iter_mark->fmark.mark.lnum) {"], "whitespace/cast"]
["src/nvim/mark.c", ["    if (iter_mark->fmark.mark.lnum) {", "      return (const void *) iter_mark;", "    }"], "whitespace/cast"]
["src/nvim/mark.c", ["  *name = NUL;", "  char mark_name = (char) (iter == NULL", "                           ? NUL"], "whitespace/cast"]
["src/nvim/mark.c", ["                                    ? '.'", "                                    : 'a' + (char) ((const fmark_T *)iter", "                                                    - &(buf->b_namedm[0]))))));"], "whitespace/cast"]
["src/nvim/mark.c", ["  }", "  size_t iter_off = (size_t) (iter_mark - &(buf->b_namedm[0]));", "  if (mark_name) {"], "whitespace/cast"]
["src/nvim/mark.c", ["  } else {", "    *name = (char) ('a' + (char) iter_off);", "  }"], "whitespace/cast"]
["src/nvim/mark.c", ["  *fm = *iter_mark;", "  return (const void *) iter_mark;", "}"], "whitespace/cast"]
["src/nvim/mark.c", ["", "/*", " * Free items in the jumplist of window \"wp\"."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  for (i = 0; i < wp->w_jumplistlen; ++i) {", "    free_xfmark(wp->w_jumplist[i]);"], "readability/increment"]
["src/nvim/mark.h", ["#include \"nvim/os/time.h\"", "#include \"nvim/ex_cmds_defs.h\" // for exarg_T", ""], "whitespace/comments"]
["src/nvim/mark_defs.h", ["", "#endif // NVIM_MARK_DEFS_H", ""], "build/header_guard"]
["src/nvim/mark_defs.h", ["", "/*", " * marks: positions in a file"], "readability/old_style_comment"]
["src/nvim/mark_defs.h", ["", "#endif // NVIM_MARK_DEFS_H", ""], "whitespace/comments"]
["src/nvim/marktree.c", ["  }", "  if (begin == x->n) { *rr = 1; return x->n - 1; }", "  if ((*rr = key_cmp(k, x->key[begin])) < 0) {"], "whitespace/newline"]
["src/nvim/marktree.c", ["    s = (mtnode_t *)xcalloc(1, ILEN);", "    b->root = s; s->level = r->level+1; s->n = 0;", "    s->ptr[0] = r;"], "whitespace/newline"]
["src/nvim/mbyte.c", ["", "/*", " * Canonical encoding names and their properties."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["static struct", "{   const char *name;   int prop;              int codepage; }", "enc_canon_table[] ="], "whitespace/newline"]
["src/nvim/mbyte.c", ["#define IDX_LATIN_1     0", "  {\"latin1\",          ENC_8BIT + ENC_LATIN1,  1252},", "#define IDX_ISO_2       1"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_LATIN_1     0", "  {\"latin1\",          ENC_8BIT + ENC_LATIN1,  1252},", "#define IDX_ISO_2       1"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_2       1", "  {\"iso-8859-2\",      ENC_8BIT,               0},", "#define IDX_ISO_3       2"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_2       1", "  {\"iso-8859-2\",      ENC_8BIT,               0},", "#define IDX_ISO_3       2"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_3       2", "  {\"iso-8859-3\",      ENC_8BIT,               0},", "#define IDX_ISO_4       3"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_3       2", "  {\"iso-8859-3\",      ENC_8BIT,               0},", "#define IDX_ISO_4       3"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_4       3", "  {\"iso-8859-4\",      ENC_8BIT,               0},", "#define IDX_ISO_5       4"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_4       3", "  {\"iso-8859-4\",      ENC_8BIT,               0},", "#define IDX_ISO_5       4"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_5       4", "  {\"iso-8859-5\",      ENC_8BIT,               0},", "#define IDX_ISO_6       5"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_5       4", "  {\"iso-8859-5\",      ENC_8BIT,               0},", "#define IDX_ISO_6       5"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_6       5", "  {\"iso-8859-6\",      ENC_8BIT,               0},", "#define IDX_ISO_7       6"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_6       5", "  {\"iso-8859-6\",      ENC_8BIT,               0},", "#define IDX_ISO_7       6"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_7       6", "  {\"iso-8859-7\",      ENC_8BIT,               0},", "#define IDX_ISO_8       7"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_7       6", "  {\"iso-8859-7\",      ENC_8BIT,               0},", "#define IDX_ISO_8       7"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_8       7", "  {\"iso-8859-8\",      ENC_8BIT,               0},", "#define IDX_ISO_9       8"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_8       7", "  {\"iso-8859-8\",      ENC_8BIT,               0},", "#define IDX_ISO_9       8"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_9       8", "  {\"iso-8859-9\",      ENC_8BIT,               0},", "#define IDX_ISO_10      9"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_9       8", "  {\"iso-8859-9\",      ENC_8BIT,               0},", "#define IDX_ISO_10      9"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_10      9", "  {\"iso-8859-10\",     ENC_8BIT,               0},", "#define IDX_ISO_11      10"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_10      9", "  {\"iso-8859-10\",     ENC_8BIT,               0},", "#define IDX_ISO_11      10"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_11      10", "  {\"iso-8859-11\",     ENC_8BIT,               0},", "#define IDX_ISO_13      11"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_11      10", "  {\"iso-8859-11\",     ENC_8BIT,               0},", "#define IDX_ISO_13      11"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_13      11", "  {\"iso-8859-13\",     ENC_8BIT,               0},", "#define IDX_ISO_14      12"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_13      11", "  {\"iso-8859-13\",     ENC_8BIT,               0},", "#define IDX_ISO_14      12"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_14      12", "  {\"iso-8859-14\",     ENC_8BIT,               0},", "#define IDX_ISO_15      13"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_14      12", "  {\"iso-8859-14\",     ENC_8BIT,               0},", "#define IDX_ISO_15      13"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_15      13", "  {\"iso-8859-15\",     ENC_8BIT + ENC_LATIN9,  0},", "#define IDX_KOI8_R      14"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_ISO_15      13", "  {\"iso-8859-15\",     ENC_8BIT + ENC_LATIN9,  0},", "#define IDX_KOI8_R      14"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_KOI8_R      14", "  {\"koi8-r\",          ENC_8BIT,               0},", "#define IDX_KOI8_U      15"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_KOI8_R      14", "  {\"koi8-r\",          ENC_8BIT,               0},", "#define IDX_KOI8_U      15"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_KOI8_U      15", "  {\"koi8-u\",          ENC_8BIT,               0},", "#define IDX_UTF8        16"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_KOI8_U      15", "  {\"koi8-u\",          ENC_8BIT,               0},", "#define IDX_UTF8        16"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UTF8        16", "  {\"utf-8\",           ENC_UNICODE,            0},", "#define IDX_UCS2        17"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UTF8        16", "  {\"utf-8\",           ENC_UNICODE,            0},", "#define IDX_UCS2        17"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UCS2        17", "  {\"ucs-2\",           ENC_UNICODE + ENC_ENDIAN_B + ENC_2BYTE, 0},", "#define IDX_UCS2LE      18"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UCS2        17", "  {\"ucs-2\",           ENC_UNICODE + ENC_ENDIAN_B + ENC_2BYTE, 0},", "#define IDX_UCS2LE      18"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UCS2LE      18", "  {\"ucs-2le\",         ENC_UNICODE + ENC_ENDIAN_L + ENC_2BYTE, 0},", "#define IDX_UTF16       19"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UCS2LE      18", "  {\"ucs-2le\",         ENC_UNICODE + ENC_ENDIAN_L + ENC_2BYTE, 0},", "#define IDX_UTF16       19"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UTF16       19", "  {\"utf-16\",          ENC_UNICODE + ENC_ENDIAN_B + ENC_2WORD, 0},", "#define IDX_UTF16LE     20"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UTF16       19", "  {\"utf-16\",          ENC_UNICODE + ENC_ENDIAN_B + ENC_2WORD, 0},", "#define IDX_UTF16LE     20"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UTF16LE     20", "  {\"utf-16le\",        ENC_UNICODE + ENC_ENDIAN_L + ENC_2WORD, 0},", "#define IDX_UCS4        21"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UTF16LE     20", "  {\"utf-16le\",        ENC_UNICODE + ENC_ENDIAN_L + ENC_2WORD, 0},", "#define IDX_UCS4        21"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UCS4        21", "  {\"ucs-4\",           ENC_UNICODE + ENC_ENDIAN_B + ENC_4BYTE, 0},", "#define IDX_UCS4LE      22"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UCS4        21", "  {\"ucs-4\",           ENC_UNICODE + ENC_ENDIAN_B + ENC_4BYTE, 0},", "#define IDX_UCS4LE      22"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UCS4LE      22", "  {\"ucs-4le\",         ENC_UNICODE + ENC_ENDIAN_L + ENC_4BYTE, 0},", ""], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_UCS4LE      22", "  {\"ucs-4le\",         ENC_UNICODE + ENC_ENDIAN_L + ENC_4BYTE, 0},", ""], "whitespace/braces"]
["src/nvim/mbyte.c", ["", "  /* For debugging DBCS encoding on Unix. */", "#define IDX_DEBUG       23"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_DEBUG       23", "  {\"debug\",           ENC_DBCS,               DBCS_DEBUG},", "#define IDX_EUC_JP      24"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_DEBUG       23", "  {\"debug\",           ENC_DBCS,               DBCS_DEBUG},", "#define IDX_EUC_JP      24"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_EUC_JP      24", "  {\"euc-jp\",          ENC_DBCS,               DBCS_JPNU},", "#define IDX_SJIS        25"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_EUC_JP      24", "  {\"euc-jp\",          ENC_DBCS,               DBCS_JPNU},", "#define IDX_SJIS        25"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_SJIS        25", "  {\"sjis\",            ENC_DBCS,               DBCS_JPN},", "#define IDX_EUC_KR      26"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_SJIS        25", "  {\"sjis\",            ENC_DBCS,               DBCS_JPN},", "#define IDX_EUC_KR      26"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_EUC_KR      26", "  {\"euc-kr\",          ENC_DBCS,               DBCS_KORU},", "#define IDX_EUC_CN      27"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_EUC_KR      26", "  {\"euc-kr\",          ENC_DBCS,               DBCS_KORU},", "#define IDX_EUC_CN      27"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_EUC_CN      27", "  {\"euc-cn\",          ENC_DBCS,               DBCS_CHSU},", "#define IDX_EUC_TW      28"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_EUC_CN      27", "  {\"euc-cn\",          ENC_DBCS,               DBCS_CHSU},", "#define IDX_EUC_TW      28"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_EUC_TW      28", "  {\"euc-tw\",          ENC_DBCS,               DBCS_CHTU},", "#define IDX_BIG5        29"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_EUC_TW      28", "  {\"euc-tw\",          ENC_DBCS,               DBCS_CHTU},", "#define IDX_BIG5        29"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_BIG5        29", "  {\"big5\",            ENC_DBCS,               DBCS_CHT},", ""], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_BIG5        29", "  {\"big5\",            ENC_DBCS,               DBCS_CHT},", ""], "whitespace/braces"]
["src/nvim/mbyte.c", ["", "  /* MS-DOS and MS-Windows codepages are included here, so that they can be", "   * used on Unix too.  Most of them are similar to ISO-8859 encodings, but"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP437       30", "  {\"cp437\",           ENC_8BIT,               437},   /* like iso-8859-1 */", "#define IDX_CP737       31"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP437       30", "  {\"cp437\",           ENC_8BIT,               437},   /* like iso-8859-1 */", "#define IDX_CP737       31"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP437       30", "  {\"cp437\",           ENC_8BIT,               437},   /* like iso-8859-1 */", "#define IDX_CP737       31"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP737       31", "  {\"cp737\",           ENC_8BIT,               737},   /* like iso-8859-7 */", "#define IDX_CP775       32"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP737       31", "  {\"cp737\",           ENC_8BIT,               737},   /* like iso-8859-7 */", "#define IDX_CP775       32"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP737       31", "  {\"cp737\",           ENC_8BIT,               737},   /* like iso-8859-7 */", "#define IDX_CP775       32"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP775       32", "  {\"cp775\",           ENC_8BIT,               775},   /* Baltic */", "#define IDX_CP850       33"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP775       32", "  {\"cp775\",           ENC_8BIT,               775},   /* Baltic */", "#define IDX_CP850       33"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP775       32", "  {\"cp775\",           ENC_8BIT,               775},   /* Baltic */", "#define IDX_CP850       33"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP850       33", "  {\"cp850\",           ENC_8BIT,               850},   /* like iso-8859-4 */", "#define IDX_CP852       34"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP850       33", "  {\"cp850\",           ENC_8BIT,               850},   /* like iso-8859-4 */", "#define IDX_CP852       34"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP850       33", "  {\"cp850\",           ENC_8BIT,               850},   /* like iso-8859-4 */", "#define IDX_CP852       34"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP852       34", "  {\"cp852\",           ENC_8BIT,               852},   /* like iso-8859-1 */", "#define IDX_CP855       35"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP852       34", "  {\"cp852\",           ENC_8BIT,               852},   /* like iso-8859-1 */", "#define IDX_CP855       35"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP852       34", "  {\"cp852\",           ENC_8BIT,               852},   /* like iso-8859-1 */", "#define IDX_CP855       35"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP855       35", "  {\"cp855\",           ENC_8BIT,               855},   /* like iso-8859-2 */", "#define IDX_CP857       36"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP855       35", "  {\"cp855\",           ENC_8BIT,               855},   /* like iso-8859-2 */", "#define IDX_CP857       36"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP855       35", "  {\"cp855\",           ENC_8BIT,               855},   /* like iso-8859-2 */", "#define IDX_CP857       36"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP857       36", "  {\"cp857\",           ENC_8BIT,               857},   /* like iso-8859-5 */", "#define IDX_CP860       37"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP857       36", "  {\"cp857\",           ENC_8BIT,               857},   /* like iso-8859-5 */", "#define IDX_CP860       37"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP857       36", "  {\"cp857\",           ENC_8BIT,               857},   /* like iso-8859-5 */", "#define IDX_CP860       37"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP860       37", "  {\"cp860\",           ENC_8BIT,               860},   /* like iso-8859-9 */", "#define IDX_CP861       38"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP860       37", "  {\"cp860\",           ENC_8BIT,               860},   /* like iso-8859-9 */", "#define IDX_CP861       38"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP860       37", "  {\"cp860\",           ENC_8BIT,               860},   /* like iso-8859-9 */", "#define IDX_CP861       38"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP861       38", "  {\"cp861\",           ENC_8BIT,               861},   /* like iso-8859-1 */", "#define IDX_CP862       39"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP861       38", "  {\"cp861\",           ENC_8BIT,               861},   /* like iso-8859-1 */", "#define IDX_CP862       39"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP861       38", "  {\"cp861\",           ENC_8BIT,               861},   /* like iso-8859-1 */", "#define IDX_CP862       39"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP862       39", "  {\"cp862\",           ENC_8BIT,               862},   /* like iso-8859-1 */", "#define IDX_CP863       40"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP862       39", "  {\"cp862\",           ENC_8BIT,               862},   /* like iso-8859-1 */", "#define IDX_CP863       40"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP862       39", "  {\"cp862\",           ENC_8BIT,               862},   /* like iso-8859-1 */", "#define IDX_CP863       40"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP863       40", "  {\"cp863\",           ENC_8BIT,               863},   /* like iso-8859-8 */", "#define IDX_CP865       41"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP863       40", "  {\"cp863\",           ENC_8BIT,               863},   /* like iso-8859-8 */", "#define IDX_CP865       41"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP863       40", "  {\"cp863\",           ENC_8BIT,               863},   /* like iso-8859-8 */", "#define IDX_CP865       41"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP865       41", "  {\"cp865\",           ENC_8BIT,               865},   /* like iso-8859-1 */", "#define IDX_CP866       42"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP865       41", "  {\"cp865\",           ENC_8BIT,               865},   /* like iso-8859-1 */", "#define IDX_CP866       42"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP865       41", "  {\"cp865\",           ENC_8BIT,               865},   /* like iso-8859-1 */", "#define IDX_CP866       42"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP866       42", "  {\"cp866\",           ENC_8BIT,               866},   /* like iso-8859-5 */", "#define IDX_CP869       43"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP866       42", "  {\"cp866\",           ENC_8BIT,               866},   /* like iso-8859-5 */", "#define IDX_CP869       43"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP866       42", "  {\"cp866\",           ENC_8BIT,               866},   /* like iso-8859-5 */", "#define IDX_CP869       43"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP869       43", "  {\"cp869\",           ENC_8BIT,               869},   /* like iso-8859-7 */", "#define IDX_CP874       44"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP869       43", "  {\"cp869\",           ENC_8BIT,               869},   /* like iso-8859-7 */", "#define IDX_CP874       44"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP869       43", "  {\"cp869\",           ENC_8BIT,               869},   /* like iso-8859-7 */", "#define IDX_CP874       44"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP874       44", "  {\"cp874\",           ENC_8BIT,               874},   /* Thai */", "#define IDX_CP932       45"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP874       44", "  {\"cp874\",           ENC_8BIT,               874},   /* Thai */", "#define IDX_CP932       45"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP874       44", "  {\"cp874\",           ENC_8BIT,               874},   /* Thai */", "#define IDX_CP932       45"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP932       45", "  {\"cp932\",           ENC_DBCS,               DBCS_JPN},", "#define IDX_CP936       46"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP932       45", "  {\"cp932\",           ENC_DBCS,               DBCS_JPN},", "#define IDX_CP936       46"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP936       46", "  {\"cp936\",           ENC_DBCS,               DBCS_CHS},", "#define IDX_CP949       47"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP936       46", "  {\"cp936\",           ENC_DBCS,               DBCS_CHS},", "#define IDX_CP949       47"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP949       47", "  {\"cp949\",           ENC_DBCS,               DBCS_KOR},", "#define IDX_CP950       48"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP949       47", "  {\"cp949\",           ENC_DBCS,               DBCS_KOR},", "#define IDX_CP950       48"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP950       48", "  {\"cp950\",           ENC_DBCS,               DBCS_CHT},", "#define IDX_CP1250      49"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP950       48", "  {\"cp950\",           ENC_DBCS,               DBCS_CHT},", "#define IDX_CP1250      49"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1250      49", "  {\"cp1250\",          ENC_8BIT,               1250},   /* Czech, Polish, etc. */", "#define IDX_CP1251      50"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP1250      49", "  {\"cp1250\",          ENC_8BIT,               1250},   /* Czech, Polish, etc. */", "#define IDX_CP1251      50"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1250      49", "  {\"cp1250\",          ENC_8BIT,               1250},   /* Czech, Polish, etc. */", "#define IDX_CP1251      50"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1251      50", "  {\"cp1251\",          ENC_8BIT,               1251},   /* Cyrillic */", "  /* cp1252 is considered to be equal to latin1 */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP1251      50", "  {\"cp1251\",          ENC_8BIT,               1251},   /* Cyrillic */", "  /* cp1252 is considered to be equal to latin1 */"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1251      50", "  {\"cp1251\",          ENC_8BIT,               1251},   /* Cyrillic */", "  /* cp1252 is considered to be equal to latin1 */"], "whitespace/braces"]
["src/nvim/mbyte.c", ["  {\"cp1251\",          ENC_8BIT,               1251},   /* Cyrillic */", "  /* cp1252 is considered to be equal to latin1 */", "#define IDX_CP1253      51"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP1253      51", "  {\"cp1253\",          ENC_8BIT,               1253},   /* Greek */", "#define IDX_CP1254      52"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP1253      51", "  {\"cp1253\",          ENC_8BIT,               1253},   /* Greek */", "#define IDX_CP1254      52"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1253      51", "  {\"cp1253\",          ENC_8BIT,               1253},   /* Greek */", "#define IDX_CP1254      52"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1254      52", "  {\"cp1254\",          ENC_8BIT,               1254},   /* Turkish */", "#define IDX_CP1255      53"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP1254      52", "  {\"cp1254\",          ENC_8BIT,               1254},   /* Turkish */", "#define IDX_CP1255      53"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1254      52", "  {\"cp1254\",          ENC_8BIT,               1254},   /* Turkish */", "#define IDX_CP1255      53"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1255      53", "  {\"cp1255\",          ENC_8BIT,               1255},   /* Hebrew */", "#define IDX_CP1256      54"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP1255      53", "  {\"cp1255\",          ENC_8BIT,               1255},   /* Hebrew */", "#define IDX_CP1256      54"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1255      53", "  {\"cp1255\",          ENC_8BIT,               1255},   /* Hebrew */", "#define IDX_CP1256      54"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1256      54", "  {\"cp1256\",          ENC_8BIT,               1256},   /* Arabic */", "#define IDX_CP1257      55"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP1256      54", "  {\"cp1256\",          ENC_8BIT,               1256},   /* Arabic */", "#define IDX_CP1257      55"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1256      54", "  {\"cp1256\",          ENC_8BIT,               1256},   /* Arabic */", "#define IDX_CP1257      55"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1257      55", "  {\"cp1257\",          ENC_8BIT,               1257},   /* Baltic */", "#define IDX_CP1258      56"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP1257      55", "  {\"cp1257\",          ENC_8BIT,               1257},   /* Baltic */", "#define IDX_CP1258      56"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1257      55", "  {\"cp1257\",          ENC_8BIT,               1257},   /* Baltic */", "#define IDX_CP1258      56"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1258      56", "  {\"cp1258\",          ENC_8BIT,               1258},   /* Vietnamese */", ""], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_CP1258      56", "  {\"cp1258\",          ENC_8BIT,               1258},   /* Vietnamese */", ""], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_CP1258      56", "  {\"cp1258\",          ENC_8BIT,               1258},   /* Vietnamese */", ""], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_MACROMAN    57", "  {\"macroman\",        ENC_8BIT + ENC_MACROMAN, 0},      /* Mac OS */", "#define IDX_HPROMAN8    58"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_MACROMAN    57", "  {\"macroman\",        ENC_8BIT + ENC_MACROMAN, 0},      /* Mac OS */", "#define IDX_HPROMAN8    58"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_MACROMAN    57", "  {\"macroman\",        ENC_8BIT + ENC_MACROMAN, 0},      /* Mac OS */", "#define IDX_HPROMAN8    58"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_HPROMAN8    58", "  {\"hp-roman8\",       ENC_8BIT,               0},       /* HP Roman8 */", "#define IDX_COUNT       59"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#define IDX_HPROMAN8    58", "  {\"hp-roman8\",       ENC_8BIT,               0},       /* HP Roman8 */", "#define IDX_COUNT       59"], "whitespace/braces"]
["src/nvim/mbyte.c", ["#define IDX_HPROMAN8    58", "  {\"hp-roman8\",       ENC_8BIT,               0},       /* HP Roman8 */", "#define IDX_COUNT       59"], "whitespace/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Aliases for encoding names."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["static struct", "{   const char *name; int canon; }", "enc_alias_table[] ="], "whitespace/newline"]
["src/nvim/mbyte.c", ["", "/*", " * Find encoding \"name\" in the list of canonical encoding names."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  for (i = 0; i < IDX_COUNT; ++i)", "    if (STRCMP(name, enc_canon_table[i].name) == 0)"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  for (i = 0; i < IDX_COUNT; ++i)", "    if (STRCMP(name, enc_canon_table[i].name) == 0)"], "readability/increment"]
["src/nvim/mbyte.c", ["  for (i = 0; i < IDX_COUNT; ++i)", "    if (STRCMP(name, enc_canon_table[i].name) == 0)", "      return i;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Find canonical encoding \"name\" in the list and return its properties."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  i = enc_canon_search(name);", "  if (i >= 0)", "    return enc_canon_table[i].prop;"], "readability/braces"]
["src/nvim/mbyte.c", ["    return enc_canon_table[i].prop;", "  if (STRNCMP(name, \"2byte-\", 6) == 0)", "    return ENC_DBCS;"], "readability/braces"]
["src/nvim/mbyte.c", ["    return ENC_DBCS;", "  if (STRNCMP(name, \"8bit-\", 5) == 0 || STRNCMP(name, \"iso-8859-\", 9) == 0)", "    return ENC_8BIT;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Return the size of the BOM for the current buffer:"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Remove all BOM from \"s\" by moving remaining text."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Get class of pointer:"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Return true if \"c\" is in \"table\"."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  /* first quick check for Latin1 etc. characters */", "  if (c < table[0].first)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  /* first quick check for Latin1 etc. characters */", "  if (c < table[0].first)", "    return false;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* binary search in table */", "  bot = 0;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    mid = (bot + top) / 2;", "    if (table[mid].last < c)", "      bot = mid + 1;"], "readability/braces"]
["src/nvim/mbyte.c", ["      bot = mid + 1;", "    else if (table[mid].first > c)", "      top = mid - 1;"], "readability/braces"]
["src/nvim/mbyte.c", ["      top = mid - 1;", "    else", "      return true;"], "readability/braces"]
["src/nvim/mbyte.c", ["    c = utf_ptr2char(p);", "    /* An illegal byte is displayed as <xx>. */", "    if (utf_ptr2len(p) == 1 || c == NUL)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    /* An illegal byte is displayed as <xx>. */", "    if (utf_ptr2len(p) == 1 || c == NUL)", "      return 4;"], "readability/braces"]
["src/nvim/mbyte.c", ["      return 4;", "    /* If the char is ASCII it must be an overlong sequence. */", "    if (c < 0x80)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    /* If the char is ASCII it must be an overlong sequence. */", "    if (c < 0x80)", "      return char2cells(c);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* Need to convert to a wide character. */", "  if (size > 0 && *p >= 0x80) {"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  if (size > 0 && *p >= 0x80) {", "    if (utf_ptr2len_len(p, size) < utf8len_tab[*p])", "      return 1;        /* truncated */"], "readability/braces"]
["src/nvim/mbyte.c", ["    if (utf_ptr2len_len(p, size) < utf8len_tab[*p])", "      return 1;        /* truncated */", "    c = utf_ptr2char(p);"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    c = utf_ptr2char(p);", "    /* An illegal byte is displayed as <xx>. */", "    if (utf_ptr2len(p) == 1 || c == NUL)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    /* An illegal byte is displayed as <xx>. */", "    if (utf_ptr2len(p) == 1 || c == NUL)", "      return 4;"], "readability/braces"]
["src/nvim/mbyte.c", ["      return 4;", "    /* If the char is ASCII it must be an overlong sequence. */", "    if (c < 0x80)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    /* If the char is ASCII it must be an overlong sequence. */", "    if (c < 0x80)", "      return char2cells(c);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Convert a UTF-8 byte sequence to a wide character."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  if (*n == 0)   /* end of buffer */", "    return 0;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  if (*n == 0)   /* end of buffer */", "    return 0;"], "readability/braces"]
["src/nvim/mbyte.c", ["  if (k == 1) {", "    /* ASCII character or NUL */", "    (*n)--;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  if (k <= *n) {", "    /* We have a multibyte sequence and it isn't truncated by buffer", "     * limits so utf_ptr2char() is safe to use. Or the first byte is"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "    /* On failure, utf_ptr2char() returns the first byte, so here we", "     * check equality with the first byte. The only non-ASCII character"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    if (c != (int)(**s) || (c == 0xC3 && (*s)[1] == 0x83)) {", "      /* byte sequence was successfully decoded */", "      *s += k;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  /* byte sequence is incomplete or illegal */", "  return -1;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Get character at **pp and advance *pp to the next character."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Get character at **pp and advance *pp to the next character."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Check if the character pointed to by \"p2\" is a composing character when it"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  c2 = utf_ptr2char(p2);", "  if (utf_iscomposing(c2))", "    return true;"], "readability/braces"]
["src/nvim/mbyte.c", ["    return true;", "  if (!arabic_maycombine(c2))", "    return false;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* Only accept a composing char when the first char isn't illegal. */", "  if ((len > 1 || *p < 0x80)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["      pcc[i++] = cc;", "      if (i == MAX_MCO)", "        break;"], "readability/braces"]
["src/nvim/mbyte.c", ["      len += utf_ptr2len(p + len);", "      if (p[len] < 0x80 || !utf_iscomposing(cc = utf_ptr2char(p + len)))", "        break;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  if (i < MAX_MCO)      /* last composing char must be 0 */", "    pcc[i] = 0;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  if (i < MAX_MCO)      /* last composing char must be 0 */", "    pcc[i] = 0;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Convert a UTF-8 byte string to a wide character.  Also get up to MAX_MCO"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Return length of UTF-8 character, obtained from the first byte."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Get the length of UTF-8 byte sequence \"p[size]\".  Does not include any"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  len = utf8len_tab[*p];", "  if (len == 1)", "    return 1;           /* NUL, ascii or illegal lead byte */"], "readability/braces"]
["src/nvim/mbyte.c", ["  if (len == 1)", "    return 1;           /* NUL, ascii or illegal lead byte */", "  if (len > size)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    return 1;           /* NUL, ascii or illegal lead byte */", "  if (len > size)", "    m = size;           /* incomplete byte sequence. */"], "readability/braces"]
["src/nvim/mbyte.c", ["  if (len > size)", "    m = size;           /* incomplete byte sequence. */", "  else"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    m = size;           /* incomplete byte sequence. */", "  else", "    m = len;"], "readability/braces"]
["src/nvim/mbyte.c", ["    m = len;", "  for (i = 1; i < m; ++i)", "    if ((p[i] & 0xc0) != 0x80)"], "readability/braces"]
["src/nvim/mbyte.c", ["    m = len;", "  for (i = 1; i < m; ++i)", "    if ((p[i] & 0xc0) != 0x80)"], "readability/increment"]
["src/nvim/mbyte.c", ["  for (i = 1; i < m; ++i)", "    if ((p[i] & 0xc0) != 0x80)", "      return 1;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Return the number of bytes the UTF-8 encoding of the character at \"p[size]\""], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  if (size < 1 || *p == NUL)", "    return 0;"], "readability/braces"]
["src/nvim/mbyte.c", ["    return 0;", "  if (p[0] < 0x80 && (size == 1 || p[1] < 0x80))   /* be quick for ASCII */", "    return 1;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    return 0;", "  if (p[0] < 0x80 && (size == 1 || p[1] < 0x80))   /* be quick for ASCII */", "    return 1;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* Skip over first UTF-8 char, stopping at a NUL byte. */", "  len = utf_ptr2len_len(p, size);"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  /* Check for illegal byte and incomplete byte sequence. */", "  if ((len == 1 && p[0] >= 0x80) || len > size)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  /* Check for illegal byte and incomplete byte sequence. */", "  if ((len == 1 && p[0] >= 0x80) || len > size)", "    return 1;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /*", "   * Check for composing characters.  We can handle only the first six, but"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "    if (p[len] < 0x80)", "      break;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "    /*", "     * Next character length should not go beyond size to ensure that"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    len_next_char = utf_ptr2len_len(p + len, size - len);", "    if (len_next_char > size - len)", "      break;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "    if (!UTF_COMPOSINGLIKE(p + prevlen, p + len))", "      break;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "    /* Skip over composing char */", "    prevlen = len;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Return true if \"c\" is a composing UTF-8 character.  This means it will be"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Return true for characters that can be displayed in a normal way."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#ifdef USE_WCHAR_FUNCTIONS", "  /*", "   * Assume the iswprint() library function works better than our own stuff."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#else", "  /* Sorted list of non-overlapping intervals.", "   * 0xd800-0xdfff is reserved for UTF-16, actually illegal. */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  static struct interval nonprint[] =", "  {", "    {0x070f, 0x070f}, {0x180b, 0x180e}, {0x200b, 0x200f}, {0x202a, 0x202e},"], "whitespace/braces"]
["src/nvim/mbyte.c", ["  {", "    {0x070f, 0x070f}, {0x180b, 0x180e}, {0x200b, 0x200f}, {0x202a, 0x202e},", "    {0x206a, 0x206f}, {0xd800, 0xdfff}, {0xfeff, 0xfeff}, {0xfff9, 0xfffb},"], "whitespace/braces"]
["src/nvim/mbyte.c", ["  {", "    {0x070f, 0x070f}, {0x180b, 0x180e}, {0x200b, 0x200f}, {0x202a, 0x202e},", "    {0x206a, 0x206f}, {0xd800, 0xdfff}, {0xfeff, 0xfeff}, {0xfff9, 0xfffb},"], "whitespace/braces"]
["src/nvim/mbyte.c", ["    {0x070f, 0x070f}, {0x180b, 0x180e}, {0x200b, 0x200f}, {0x202a, 0x202e},", "    {0x206a, 0x206f}, {0xd800, 0xdfff}, {0xfeff, 0xfeff}, {0xfff9, 0xfffb},", "    {0xfffe, 0xffff}"], "whitespace/braces"]
["src/nvim/mbyte.c", ["    {0x070f, 0x070f}, {0x180b, 0x180e}, {0x200b, 0x200f}, {0x202a, 0x202e},", "    {0x206a, 0x206f}, {0xd800, 0xdfff}, {0xfeff, 0xfeff}, {0xfff9, 0xfffb},", "    {0xfffe, 0xffff}"], "whitespace/braces"]
["src/nvim/mbyte.c", ["    {0x206a, 0x206f}, {0xd800, 0xdfff}, {0xfeff, 0xfeff}, {0xfff9, 0xfffb},", "    {0xfffe, 0xffff}", "  };"], "whitespace/braces"]
["src/nvim/mbyte.c", ["    {0x206a, 0x206f}, {0xd800, 0xdfff}, {0xfeff, 0xfeff}, {0xfff9, 0xfffb},", "    {0xfffe, 0xffff}", "  };"], "whitespace/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Get class of a Unicode character."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["{", "  /* sorted list of non-overlapping intervals */", "  static struct clinterval {"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  /* First quick check for Latin1 characters, use 'iskeyword'. */", "  if (c < 0x100) {"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  /* binary search in table */", "  while (top >= bot) {"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    mid = (bot + top) / 2;", "    if (classes[mid].last < (unsigned int)c)", "      bot = mid + 1;"], "readability/braces"]
["src/nvim/mbyte.c", ["      bot = mid + 1;", "    else if (classes[mid].first > (unsigned int)c)", "      top = mid - 1;"], "readability/braces"]
["src/nvim/mbyte.c", ["      top = mid - 1;", "    else", "      return (int)classes[mid].class;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* most other characters are \"word\" characters */", "  return 2;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Generic conversion function for case operations."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["{", "  size_t start, mid, end;   /* indices into table */", ""], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  while (start < end) {", "    /* need to search further */", "    mid = (end + start) / 2;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    mid = (end + start) / 2;", "    if (table[mid].rangeEnd < a)", "      start = mid + 1;"], "readability/braces"]
["src/nvim/mbyte.c", ["      start = mid + 1;", "    else", "      end = mid;"], "readability/braces"]
["src/nvim/mbyte.c", ["  }", "  if (start < n_items", "      && table[start].rangeStart <= a"], "readability/braces"]
["src/nvim/mbyte.c", ["    return a + table[start].offset;", "  else", "    return a;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Return the folded-case equivalent of \"a\", which is a UCS-4 character.  Uses"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["{", "  /* If 'casemap' contains \"keepascii\" use ASCII style toupper(). */", "  if (a < 128 && (cmp_flags & CMP_KEEPASCII))"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  /* If 'casemap' contains \"keepascii\" use ASCII style toupper(). */", "  if (a < 128 && (cmp_flags & CMP_KEEPASCII))", "    return TOUPPER_ASC(a);"], "readability/braces"]
["src/nvim/mbyte.c", ["#if defined(__STDC_ISO_10646__)", "  /* If towupper() is available and handles Unicode, use it. */", "  if (!(cmp_flags & CMP_INTERNAL))"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  /* If towupper() is available and handles Unicode, use it. */", "  if (!(cmp_flags & CMP_INTERNAL))", "    return towupper(a);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* For characters below 128 use locale sensitive toupper(). */", "  if (a < 128)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  /* For characters below 128 use locale sensitive toupper(). */", "  if (a < 128)", "    return TOUPPER_LOC(a);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* For any other characters use the above mapping table. */", "  return utf_convert(a, toUpper, ARRAY_SIZE(toUpper));"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["{", "  /* If 'casemap' contains \"keepascii\" use ASCII style tolower(). */", "  if (a < 128 && (cmp_flags & CMP_KEEPASCII))"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  /* If 'casemap' contains \"keepascii\" use ASCII style tolower(). */", "  if (a < 128 && (cmp_flags & CMP_KEEPASCII))", "    return TOLOWER_ASC(a);"], "readability/braces"]
["src/nvim/mbyte.c", ["#if defined(__STDC_ISO_10646__)", "  /* If towlower() is available and handles Unicode, use it. */", "  if (!(cmp_flags & CMP_INTERNAL))"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  /* If towlower() is available and handles Unicode, use it. */", "  if (!(cmp_flags & CMP_INTERNAL))", "    return towlower(a);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* For characters below 128 use locale sensitive tolower(). */", "  if (a < 128)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  /* For characters below 128 use locale sensitive tolower(). */", "  if (a < 128)", "    return TOLOWER_LOC(a);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* For any other characters use the above mapping table. */", "  return utf_convert(a, toLower, ARRAY_SIZE(toLower));"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "    if (c1 <= 0 || c2 <= 0)", "      break;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "    if (c1 == c2)", "      continue;"], "readability/braces"]
["src/nvim/mbyte.c", ["    cdiff = utf_fold(c1) - utf_fold(c2);", "    if (cdiff != 0)", "      return cdiff;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* some string ended or has an incomplete/illegal character sequence */", ""], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  if (c1 == 0 || c2 == 0) {", "    /* some string ended. shorter string is smaller */", "    if (c1 == 0 && c2 == 0)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    /* some string ended. shorter string is smaller */", "    if (c1 == 0 && c2 == 0)", "      return 0;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* Continue with bytewise comparison to produce some result that", "   * would make comparison operations involving this function transitive."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    cdiff = (int)(*s1) - (int)(*s2);", "    if (cdiff != 0)", "      return cdiff;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  if (n1 > 0 && *s1 == NUL)", "    n1 = 0;"], "readability/braces"]
["src/nvim/mbyte.c", ["    n1 = 0;", "  if (n2 > 0 && *s2 == NUL)", "    n2 = 0;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  if (n1 == 0 && n2 == 0)", "    return 0;"], "readability/braces"]
["src/nvim/mbyte.c", ["#ifndef CP_UTF8", "# define CP_UTF8 65001  /* magic number from winnls.h */", "#endif"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Version of strnicmp() that handles multi-byte characters."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * \"g8\": show bytes of the UTF-8 char under the cursor.  Doesn't matter what"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  /* Get the byte length of the char under the cursor, including composing", "   * characters. */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  clen = 0;", "  for (i = 0; i < len; ++i) {", "    if (clen == 0) {"], "readability/increment"]
["src/nvim/mbyte.c", ["    if (clen == 0) {", "      /* start of (composing) character, get its length */", "      if (i > 0) {"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    sprintf((char *)IObuff + rlen, \"%02x \",", "        (line[i] == NL) ? NUL : line[i]);          /* NUL is stored as NL */", "    --clen;"], "whitespace/alignment"]
["src/nvim/mbyte.c", ["    }", "    sprintf((char *)IObuff + rlen, \"%02x \",", "        (line[i] == NL) ? NUL : line[i]);          /* NUL is stored as NL */"], "runtime/printf"]
["src/nvim/mbyte.c", ["    sprintf((char *)IObuff + rlen, \"%02x \",", "        (line[i] == NL) ? NUL : line[i]);          /* NUL is stored as NL */", "    --clen;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["        (line[i] == NL) ? NUL : line[i]);          /* NUL is stored as NL */", "    --clen;", "    rlen += (int)STRLEN(IObuff + rlen);"], "readability/increment"]
["src/nvim/mbyte.c", ["    rlen += (int)STRLEN(IObuff + rlen);", "    if (rlen > IOSIZE - 20)", "      break;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  if (*p < 0x80)                /* be quick for ASCII */", "    return 0;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  if (*p < 0x80)                /* be quick for ASCII */", "    return 0;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* Skip backwards over trailing bytes: 10xx.xxxx", "   * Skip backwards again if on a composing char. */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  const char_u *q;", "  for (q = p;; --q) {", "    /* Move s to the last byte of this char. */"], "readability/increment"]
["src/nvim/mbyte.c", ["  for (q = p;; --q) {", "    /* Move s to the last byte of this char. */", "    const char_u *s;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    const char_u *s;", "    for (s = q; (s[1] & 0xc0) == 0x80; ++s) {}", ""], "readability/increment"]
["src/nvim/mbyte.c", ["", "    /* Move q to the first byte of this char. */", "    while (q > base && (*q & 0xc0) == 0x80)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    /* Move q to the first byte of this char. */", "    while (q > base && (*q & 0xc0) == 0x80)", "      --q;"], "readability/braces"]
["src/nvim/mbyte.c", ["    while (q > base && (*q & 0xc0) == 0x80)", "      --q;", "    /* Check for illegal sequence. Do allow an illegal byte after where we"], "readability/increment"]
["src/nvim/mbyte.c", ["      --q;", "    /* Check for illegal sequence. Do allow an illegal byte after where we", "     * started. */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    len = utf8len_tab[*q];", "    if (len != (int)(s - q + 1) && len != (int)(p - q + 1))", "      return 0;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "    if (q <= base)", "      break;"], "readability/braces"]
["src/nvim/mbyte.c", ["    c = utf_ptr2char(q);", "    if (utf_iscomposing(c))", "      continue;"], "readability/braces"]
["src/nvim/mbyte.c", ["    if (arabic_maycombine(c)) {", "      /* Advance to get a sneak-peak at the next char */", "      const char_u *j = q;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["      const char_u *j = q;", "      --j;", "      /* Move j to the first byte of this char. */"], "readability/increment"]
["src/nvim/mbyte.c", ["      --j;", "      /* Move j to the first byte of this char. */", "      while (j > base && (*j & 0xc0) == 0x80)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["      /* Move j to the first byte of this char. */", "      while (j > base && (*j & 0xc0) == 0x80)", "        --j;"], "readability/braces"]
["src/nvim/mbyte.c", ["      while (j > base && (*j & 0xc0) == 0x80)", "        --j;", "      if (arabic_combine(utf_ptr2char(j), c))"], "readability/increment"]
["src/nvim/mbyte.c", ["        --j;", "      if (arabic_combine(utf_ptr2char(j), c))", "        continue;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Return the offset from \"p\" to the first byte of a character.  When \"p\" is"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Return the offset from \"p\" to the last byte of the character it points"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  if (*p == NUL)", "    return 0;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Find the next illegal byte sequence."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["      tofree = string_convert(&vimconv, p, NULL);", "      if (tofree == NULL)", "        break;"], "readability/braces"]
["src/nvim/mbyte.c", ["    while (*p != NUL) {", "      /* Illegal means that there are not enough trail bytes (checked by", "       * utf_ptr2len()) or too many of them (overlong sequence). */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["      if (*p >= 0x80 && (len == 1", "            || utf_char2len(utf_ptr2char(p)) != len)) {", "        if (vimconv.vc_type == CONV_NONE)"], "whitespace/alignment"]
["src/nvim/mbyte.c", ["            || utf_char2len(utf_ptr2char(p)) != len)) {", "        if (vimconv.vc_type == CONV_NONE)", "          curwin->w_cursor.col += (colnr_T)(p - get_cursor_pos_ptr());"], "readability/braces"]
["src/nvim/mbyte.c", ["          curwin->w_cursor.col += (colnr_T)(p - get_cursor_pos_ptr());", "        else {", "          int l;"], "readability/braces"]
["src/nvim/mbyte.c", ["          curwin->w_cursor.col += (colnr_T)(p - get_cursor_pos_ptr());", "        else {", "          int l;"], "readability/braces"]
["src/nvim/mbyte.c", ["    }", "    if (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)", "      break;"], "readability/braces"]
["src/nvim/mbyte.c", ["      break;", "    ++curwin->w_cursor.lnum;", "    curwin->w_cursor.col = 0;"], "readability/increment"]
["src/nvim/mbyte.c", ["", "  /* didn't find it: don't move and beep */", "  curwin->w_cursor = pos;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * If the cursor moves on an trail byte, set the cursor on the lead byte."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Return a pointer to the character before \"*p\", if there is one."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    char_u *p", "    )", "{"], "whitespace/indent"]
["src/nvim/mbyte.c", ["char_u * mb_prevptr(", "    char_u *line,           /* start of the string */", "    char_u *p"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Return the character length of \"str\".  Each multi-byte character (with"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  if (p == NULL)", "    return 0;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  for (count = 0; *p != NUL; count++)", "    p += (*mb_ptr2len)(p);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Like mb_charlen() but for a string with specified length."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  for (count = 0; *p != NUL && p < str + len; count++)", "    p += (*mb_ptr2len)(p);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Skip the Vim specific head of a 'encoding' name."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["{", "  if (STRNCMP(p, \"2byte-\", 6) == 0)", "    return p + 6;"], "readability/braces"]
["src/nvim/mbyte.c", ["    return p + 6;", "  if (STRNCMP(p, \"8bit-\", 5) == 0)", "    return p + 5;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Find the canonical name for encoding \"enc\"."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  /* copy \"enc\" to allocated memory, with room for two '-' */", "  char_u *r = xmalloc(STRLEN(enc) + 3);"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  char_u *r = xmalloc(STRLEN(enc) + 3);", "  /* Make it all lower case and replace '_' with '-'. */", "  p = r;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  p = r;", "  for (s = enc; *s != NUL; ++s) {", "    if (*s == '_')"], "readability/increment"]
["src/nvim/mbyte.c", ["  for (s = enc; *s != NUL; ++s) {", "    if (*s == '_')", "      *p++ = '-';"], "readability/braces"]
["src/nvim/mbyte.c", ["      *p++ = '-';", "    else", "      *p++ = TOLOWER_ASC(*s);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* Skip \"2byte-\" and \"8bit-\". */", "  p = enc_skip(r);"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  /* Change \"microsoft-cp\" to \"cp\".  Used in some spell files. */", "  if (STRNCMP(p, \"microsoft-cp\", 12) == 0)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  /* Change \"microsoft-cp\" to \"cp\".  Used in some spell files. */", "  if (STRNCMP(p, \"microsoft-cp\", 12) == 0)", "    STRMOVE(p, p + 10);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  /* \"iso8859\" -> \"iso-8859\" */", "  if (STRNCMP(p, \"iso8859\", 7) == 0) {"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  /* \"iso-8859n\" -> \"iso-8859-n\" */", "  if (STRNCMP(p, \"iso-8859\", 8) == 0 && p[8] != '-') {"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  /* \"latin-N\" -> \"latinN\" */", "  if (STRNCMP(p, \"latin-\", 6) == 0)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  /* \"latin-N\" -> \"latinN\" */", "  if (STRNCMP(p, \"latin-\", 6) == 0)", "    STRMOVE(p + 5, p + 6);"], "readability/braces"]
["src/nvim/mbyte.c", ["  if (enc_canon_search(p) >= 0) {", "    /* canonical name can be used unmodified */", "    if (p != r)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    /* canonical name can be used unmodified */", "    if (p != r)", "      STRMOVE(r, p);"], "readability/braces"]
["src/nvim/mbyte.c", ["  } else if ((i = enc_alias_search(p)) >= 0) {", "    /* alias recognized, get canonical name */", "    xfree(r);"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Search for an encoding alias of \"name\"."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  for (i = 0; enc_alias_table[i].name != NULL; ++i)", "    if (STRCMP(name, enc_alias_table[i].name) == 0)"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  for (i = 0; enc_alias_table[i].name != NULL; ++i)", "    if (STRCMP(name, enc_alias_table[i].name) == 0)"], "readability/increment"]
["src/nvim/mbyte.c", ["  for (i = 0; enc_alias_table[i].name != NULL; ++i)", "    if (STRCMP(name, enc_alias_table[i].name) == 0)", "      return enc_alias_table[i].canon;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Get the canonicalized encoding of the current locale."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["# ifdef HAVE_NL_LANGINFO_CODESET", "  if (!(s = nl_langinfo(CODESET)) || *s == NUL)", "# endif"], "readability/braces"]
["src/nvim/mbyte.c", ["#  if defined(HAVE_LOCALE_H)", "    if (!(s = setlocale(LC_CTYPE, NULL)) || *s == NUL)", "#  endif"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Call iconv_open() with a check if iconv() works properly (there are broken"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  if (iconv_working == kBroken)", "    return (void *)-1;          /* detected a broken iconv() previously */"], "readability/braces"]
["src/nvim/mbyte.c", ["  if (iconv_working == kBroken)", "    return (void *)-1;          /* detected a broken iconv() previously */", ""], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  if (fd != (iconv_t)-1 && iconv_working == kUnknown) {", "    /*", "     * Do a dummy iconv() call to check if it actually works.  There is a"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["      fd = (iconv_t)-1;", "    } else", "      iconv_working = kWorking;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Convert the string \"str[slen]\" with iconv()."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    if (len == 0 || ICONV_ERRNO == ICONV_E2BIG) {", "      /* Allocate enough room for most conversions.  When re-allocating", "       * increase the buffer size. */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["      p = xmalloc(len);", "      if (done > 0)", "        memmove(p, result, done);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "  if (resultlenp != NULL && result != NULL)", "    *resultlenp = (size_t)(to - (char *)result);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Setup \"vcp\" for conversion from \"from\" to \"to\"."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * As convert_setup(), but only when from_unicode_is_utf8 is TRUE will all"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  /* No conversion when one of the names is empty or they are equal. */", "  if (from == NULL || *from == NUL || to == NULL || *to == NUL"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  /* No conversion when one of the names is empty or they are equal. */", "  if (from == NULL || *from == NUL || to == NULL || *to == NUL", "      || STRCMP(from, to) == 0)"], "readability/braces"]
["src/nvim/mbyte.c", ["  to_prop = enc_canon_props(to);", "  if (from_unicode_is_utf8)", "    from_is_utf8 = from_prop & ENC_UNICODE;"], "readability/braces"]
["src/nvim/mbyte.c", ["    from_is_utf8 = from_prop & ENC_UNICODE;", "  else", "    from_is_utf8 = from_prop == ENC_UNICODE;"], "readability/braces"]
["src/nvim/mbyte.c", ["    from_is_utf8 = from_prop == ENC_UNICODE;", "  if (to_unicode_is_utf8)", "    to_is_utf8 = to_prop & ENC_UNICODE;"], "readability/braces"]
["src/nvim/mbyte.c", ["    to_is_utf8 = to_prop & ENC_UNICODE;", "  else", "    to_is_utf8 = to_prop == ENC_UNICODE;"], "readability/braces"]
["src/nvim/mbyte.c", ["  if ((from_prop & ENC_LATIN1) && to_is_utf8) {", "    /* Internal latin1 -> utf-8 conversion. */", "    vcp->vc_type = CONV_TO_UTF8;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    vcp->vc_type = CONV_TO_UTF8;", "    vcp->vc_factor = 2;         /* up to twice as long */", "  } else if ((from_prop & ENC_LATIN9) && to_is_utf8) {"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  } else if ((from_prop & ENC_LATIN9) && to_is_utf8) {", "    /* Internal latin9 -> utf-8 conversion. */", "    vcp->vc_type = CONV_9_TO_UTF8;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    vcp->vc_type = CONV_9_TO_UTF8;", "    vcp->vc_factor = 3;         /* up to three as long (euro sign) */", "  } else if (from_is_utf8 && (to_prop & ENC_LATIN1)) {"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  } else if (from_is_utf8 && (to_prop & ENC_LATIN1)) {", "    /* Internal utf-8 -> latin1 conversion. */", "    vcp->vc_type = CONV_TO_LATIN1;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  } else if (from_is_utf8 && (to_prop & ENC_LATIN9)) {", "    /* Internal utf-8 -> latin9 conversion. */", "    vcp->vc_type = CONV_TO_LATIN9;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["      vcp->vc_type = CONV_ICONV;", "      vcp->vc_factor = 4;       /* could be longer too... */", "    }"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["# endif", "  if (vcp->vc_type == CONV_NONE)", "    return FAIL;"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Convert text \"ptr[*lenp]\" according to \"vcp\"."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Like string_convert(), but when \"unconvlenp\" is not NULL and there are is"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  size_t len;", "  if (lenp == NULL)", "    len = STRLEN(ptr);"], "readability/braces"]
["src/nvim/mbyte.c", ["    len = STRLEN(ptr);", "  else", "    len = *lenp;"], "readability/braces"]
["src/nvim/mbyte.c", ["    len = *lenp;", "  if (len == 0)", "    return vim_strsave((char_u *)\"\");"], "readability/braces"]
["src/nvim/mbyte.c", ["  switch (vcp->vc_type) {", "    case CONV_TO_UTF8:            /* latin1 to utf-8 conversion */", "      retval = xmalloc(len * 2 + 1);"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["      d = retval;", "      for (size_t i = 0; i < len; ++i) {", "        c = ptr[i];"], "readability/increment"]
["src/nvim/mbyte.c", ["        c = ptr[i];", "        if (c < 0x80)", "          *d++ = c;"], "readability/braces"]
["src/nvim/mbyte.c", ["          *d++ = c;", "        else {", "          *d++ = 0xc0 + ((unsigned)c >> 6);"], "readability/braces"]
["src/nvim/mbyte.c", ["          *d++ = c;", "        else {", "          *d++ = 0xc0 + ((unsigned)c >> 6);"], "readability/braces"]
["src/nvim/mbyte.c", ["      *d = NUL;", "      if (lenp != NULL)", "        *lenp = (size_t)(d - retval);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "    case CONV_9_TO_UTF8:          /* latin9 to utf-8 conversion */", "      retval = xmalloc(len * 3 + 1);"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["      d = retval;", "      for (size_t i = 0; i < len; ++i) {", "        c = ptr[i];"], "readability/increment"]
["src/nvim/mbyte.c", ["        switch (c) {", "          case 0xa4: c = 0x20ac; break;                 /* euro */", "          case 0xa6: c = 0x0160; break;                 /* S hat */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["          case 0xa4: c = 0x20ac; break;                 /* euro */", "          case 0xa6: c = 0x0160; break;                 /* S hat */", "          case 0xa8: c = 0x0161; break;                 /* S -hat */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["          case 0xa6: c = 0x0160; break;                 /* S hat */", "          case 0xa8: c = 0x0161; break;                 /* S -hat */", "          case 0xb4: c = 0x017d; break;                 /* Z hat */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["          case 0xa8: c = 0x0161; break;                 /* S -hat */", "          case 0xb4: c = 0x017d; break;                 /* Z hat */", "          case 0xb8: c = 0x017e; break;                 /* Z -hat */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["          case 0xb4: c = 0x017d; break;                 /* Z hat */", "          case 0xb8: c = 0x017e; break;                 /* Z -hat */", "          case 0xbc: c = 0x0152; break;                 /* OE */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["          case 0xb8: c = 0x017e; break;                 /* Z -hat */", "          case 0xbc: c = 0x0152; break;                 /* OE */", "          case 0xbd: c = 0x0153; break;                 /* oe */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["          case 0xbc: c = 0x0152; break;                 /* OE */", "          case 0xbd: c = 0x0153; break;                 /* oe */", "          case 0xbe: c = 0x0178; break;                 /* Y */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["          case 0xbd: c = 0x0153; break;                 /* oe */", "          case 0xbe: c = 0x0178; break;                 /* Y */", "        }"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["      *d = NUL;", "      if (lenp != NULL)", "        *lenp = (size_t)(d - retval);"], "readability/braces"]
["src/nvim/mbyte.c", ["", "    case CONV_TO_LATIN1:          /* utf-8 to latin1 conversion */", "    case CONV_TO_LATIN9:          /* utf-8 to latin9 conversion */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    case CONV_TO_LATIN1:          /* utf-8 to latin1 conversion */", "    case CONV_TO_LATIN9:          /* utf-8 to latin9 conversion */", "      retval = xmalloc(len + 1);"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["      d = retval;", "      for (size_t i = 0; i < len; ++i) {", "        l = utf_ptr2len_len(ptr + i, len - i);"], "readability/increment"]
["src/nvim/mbyte.c", ["        l = utf_ptr2len_len(ptr + i, len - i);", "        if (l == 0)", "          *d++ = NUL;"], "readability/braces"]
["src/nvim/mbyte.c", ["          *d++ = NUL;", "        else if (l == 1) {", "          uint8_t l_w = utf8len_tab_zero[ptr[i]];"], "readability/braces"]
["src/nvim/mbyte.c", ["          if (l_w == 0) {", "            /* Illegal utf-8 byte cannot be converted */", "            xfree(retval);"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["          if (unconvlenp != NULL && l_w > len - i) {", "            /* Incomplete sequence at the end. */", "            *unconvlenp = len - i;"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["          c = utf_ptr2char(ptr + i);", "          if (vcp->vc_type == CONV_TO_LATIN9)", "            switch (c) {"], "readability/braces"]
["src/nvim/mbyte.c", ["            switch (c) {", "              case 0x20ac: c = 0xa4; break;                     /* euro */", "              case 0x0160: c = 0xa6; break;                     /* S hat */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["              case 0x20ac: c = 0xa4; break;                     /* euro */", "              case 0x0160: c = 0xa6; break;                     /* S hat */", "              case 0x0161: c = 0xa8; break;                     /* S -hat */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["              case 0x0160: c = 0xa6; break;                     /* S hat */", "              case 0x0161: c = 0xa8; break;                     /* S -hat */", "              case 0x017d: c = 0xb4; break;                     /* Z hat */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["              case 0x0161: c = 0xa8; break;                     /* S -hat */", "              case 0x017d: c = 0xb4; break;                     /* Z hat */", "              case 0x017e: c = 0xb8; break;                     /* Z -hat */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["              case 0x017d: c = 0xb4; break;                     /* Z hat */", "              case 0x017e: c = 0xb8; break;                     /* Z -hat */", "              case 0x0152: c = 0xbc; break;                     /* OE */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["              case 0x017e: c = 0xb8; break;                     /* Z -hat */", "              case 0x0152: c = 0xbc; break;                     /* OE */", "              case 0x0153: c = 0xbd; break;                     /* oe */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["              case 0x0152: c = 0xbc; break;                     /* OE */", "              case 0x0153: c = 0xbd; break;                     /* oe */", "              case 0x0178: c = 0xbe; break;                     /* Y */"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["              case 0x0153: c = 0xbd; break;                     /* oe */", "              case 0x0178: c = 0xbe; break;                     /* Y */", "              case 0xa4:"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["              case 0xbd:", "              case 0xbe: c = 0x100; break;                   /* not in latin9 */", "            }"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["            }", "          if (!utf_iscomposing(c)) {              /* skip composing chars */", "            if (c < 0x100)"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["          if (!utf_iscomposing(c)) {              /* skip composing chars */", "            if (c < 0x100)", "              *d++ = c;"], "readability/braces"]
["src/nvim/mbyte.c", ["              *d++ = c;", "            else if (vcp->vc_fail) {", "              xfree(retval);"], "readability/braces"]
["src/nvim/mbyte.c", ["              *d++ = 0xbf;", "              if (utf_char2cells(c) > 1)", "                *d++ = '?';"], "readability/braces"]
["src/nvim/mbyte.c", ["      *d = NUL;", "      if (lenp != NULL)", "        *lenp = (size_t)(d - retval);"], "readability/braces"]
["src/nvim/mbyte.h", ["", "/*", " * Return byte length of character that starts with byte \"b\"."], "readability/old_style_comment"]
["src/nvim/mbyte.h", ["", "/* properties used in enc_canon_table[] (first three mutually exclusive) */", "#define ENC_8BIT       0x01"], "readability/old_style_comment"]
["src/nvim/mbyte.h", ["", "#define ENC_ENDIAN_B   0x10        /* Unicode: Big endian */", "#define ENC_ENDIAN_L   0x20        /* Unicode: Little endian */"], "readability/old_style_comment"]
["src/nvim/mbyte.h", ["#define ENC_ENDIAN_B   0x10        /* Unicode: Big endian */", "#define ENC_ENDIAN_L   0x20        /* Unicode: Little endian */", ""], "readability/old_style_comment"]
["src/nvim/mbyte.h", ["", "#define ENC_2BYTE      0x40        /* Unicode: UCS-2 */", "#define ENC_4BYTE      0x80        /* Unicode: UCS-4 */"], "readability/old_style_comment"]
["src/nvim/mbyte.h", ["#define ENC_2BYTE      0x40        /* Unicode: UCS-2 */", "#define ENC_4BYTE      0x80        /* Unicode: UCS-4 */", "#define ENC_2WORD      0x100       /* Unicode: UTF-16 */"], "readability/old_style_comment"]
["src/nvim/mbyte.h", ["#define ENC_4BYTE      0x80        /* Unicode: UCS-4 */", "#define ENC_2WORD      0x100       /* Unicode: UTF-16 */", ""], "readability/old_style_comment"]
["src/nvim/mbyte.h", ["", "#define ENC_LATIN1     0x200       /* Latin1 */", "#define ENC_LATIN9     0x400       /* Latin9 */"], "readability/old_style_comment"]
["src/nvim/mbyte.h", ["#define ENC_LATIN1     0x200       /* Latin1 */", "#define ENC_LATIN9     0x400       /* Latin9 */", "#define ENC_MACROMAN   0x800       /* Mac Roman (not Macro Man! :-) */"], "readability/old_style_comment"]
["src/nvim/mbyte.h", ["#define ENC_LATIN9     0x400       /* Latin9 */", "#define ENC_MACROMAN   0x800       /* Mac Roman (not Macro Man! :-) */", ""], "readability/old_style_comment"]
["src/nvim/memfile.c", ["  // check block number exists", "  if (nr >= mfp->mf_blocknr_max || nr <= mfp->mf_blocknr_min)", "    return NULL;"], "readability/braces"]
["src/nvim/memfile.c", ["  if (hp == NULL) {                             // not in the hash list", "    if (nr < 0 || nr >= mfp->mf_infile_count)   // can't be in the file", "      return NULL;"], "readability/braces"]
["src/nvim/memfile.c", ["  hp->bh_flags = flags;", "  if (infile)", "    mf_trans_add(mfp, hp);      // may translate negative in positive nr"], "readability/braces"]
["src/nvim/memfile.c", ["  bhdr_T *hp;", "  for (hp = mfp->mf_used_last; hp != NULL; hp = hp->bh_prev)", "    if (((flags & MFS_ALL) || hp->bh_bnum >= 0)"], "readability/braces"]
["src/nvim/memfile.c", ["                             && hp->bh_bnum < mfp->mf_infile_count))) {", "      if ((flags & MFS_ZERO) && hp->bh_bnum != 0)", "        continue;"], "readability/braces"]
["src/nvim/memfile.c", ["      if (mf_write(mfp, hp) == FAIL) {", "        if (status == FAIL)     // double error: quit syncing", "          break;"], "readability/braces"]
["src/nvim/memfile.c", ["      if (flags & MFS_STOP) {   // Stop when char available now.", "        if (os_char_avail())", "          break;"], "readability/braces"]
["src/nvim/memfile.c", ["      }", "      if (got_int)", "        break;"], "readability/braces"]
["src/nvim/memfile.c", ["  // In case of an error, dirty flag is also set, to avoid trying all the time.", "  if (hp == NULL || status == FAIL)", "    mfp->mf_dirty = false;"], "readability/braces"]
["src/nvim/memfile.c", ["{", "  if (hp->bh_next == NULL)                 // last block in used list", "    mfp->mf_used_last = hp->bh_prev;"], "readability/braces"]
["src/nvim/memfile.c", ["    mfp->mf_used_last = hp->bh_prev;", "  else", "    hp->bh_next->bh_prev = hp->bh_prev;"], "readability/braces"]
["src/nvim/memfile.c", ["", "  if (hp->bh_prev == NULL)                 // first block in used list", "    mfp->mf_used_first = hp->bh_next;"], "readability/braces"]
["src/nvim/memfile.c", ["    mfp->mf_used_first = hp->bh_next;", "  else", "    hp->bh_prev->bh_next = hp->bh_next;"], "readability/braces"]
["src/nvim/memfile.c", ["{", "  if (mfp->mf_fd < 0)       // there is no file, can't read", "    return FAIL;"], "readability/braces"]
["src/nvim/memfile.c", ["", "  if (mfp->mf_fd < 0)       // there is no file, can't write", "    return FAIL;"], "readability/braces"]
["src/nvim/memfile.c", ["", "  if (hp->bh_bnum < 0)      // must assign file block number", "    if (mf_trans_add(mfp, hp) == FAIL)"], "readability/braces"]
["src/nvim/memfile.c", ["  if (hp->bh_bnum < 0)      // must assign file block number", "    if (mf_trans_add(mfp, hp) == FAIL)", "      return FAIL;"], "readability/braces"]
["src/nvim/memfile.c", ["    }", "    if (hp2 == NULL)                // freed block, fill with dummy data", "      page_count = 1;"], "readability/braces"]
["src/nvim/memfile.c", ["      page_count = 1;", "    else", "      page_count = hp2->bh_page_count;"], "readability/braces"]
["src/nvim/memfile.c", ["      /// space becomes available.", "      if (!did_swapwrite_msg)", "        EMSG(_(\"E297: Write error in swap file\"));"], "readability/braces"]
["src/nvim/memfile.c", ["    did_swapwrite_msg = false;", "    if (hp2 != NULL)                               // written a non-dummy block", "      hp2->bh_flags &= ~BH_DIRTY;"], "readability/braces"]
["src/nvim/memfile.c", ["      hp2->bh_flags &= ~BH_DIRTY;", "    if (nr + (blocknr_T)page_count > mfp->mf_infile_count)  // appended to file", "      mfp->mf_infile_count = nr + page_count;"], "readability/braces"]
["src/nvim/memfile.c", ["      mfp->mf_infile_count = nr + page_count;", "    if (nr == hp->bh_bnum)                         // written the desired block", "      break;"], "readability/braces"]
["src/nvim/memfile.c", ["{", "  if (hp->bh_bnum >= 0)                     // it's already positive", "    return OK;"], "readability/braces"]
["src/nvim/memfile.c", ["", "  if (np == NULL)    // not found", "    return old_nr;"], "readability/braces"]
["src/nvim/memfile.c", ["  mf_hashitem_T *mhi = mht->mht_buckets[(size_t)key & mht->mht_mask];", "  while (mhi != NULL && mhi->mhi_key != key)", "    mhi = mhi->mhi_next;"], "readability/braces"]
["src/nvim/memfile.c", ["  mhi->mhi_prev = NULL;", "  if (mhi->mhi_next != NULL)", "    mhi->mhi_next->mhi_prev = mhi;"], "readability/braces"]
["src/nvim/memfile.c", ["{", "  if (mhi->mhi_prev == NULL)", "    mht->mht_buckets[(size_t)mhi->mhi_key & mht->mht_mask] ="], "readability/braces"]
["src/nvim/memfile.c", ["      mhi->mhi_next;", "  else", "    mhi->mhi_prev->mhi_next = mhi->mhi_next;"], "readability/braces"]
["src/nvim/memfile.c", ["", "  if (mhi->mhi_next != NULL)", "    mhi->mhi_next->mhi_prev = mhi->mhi_prev;"], "readability/braces"]
["src/nvim/memfile.c", ["  int shift = 0;", "  while ((mht->mht_mask >> shift) != 0)", "    shift++;"], "readability/braces"]
["src/nvim/memfile.c", ["", "    for (size_t j = 0; j < MHT_GROWTH_FACTOR; j++)", "      if (tails[j] != NULL)"], "readability/braces"]
["src/nvim/memfile.c", ["    for (size_t j = 0; j < MHT_GROWTH_FACTOR; j++)", "      if (tails[j] != NULL)", "        tails[j]->mhi_next = NULL;"], "readability/braces"]
["src/nvim/memfile.c", ["", "  if (mht->mht_buckets != mht->mht_small_buckets)", "    xfree(mht->mht_buckets);"], "readability/braces"]
["src/nvim/memline.c", ["", "/*", " * memline.c: Contains the functions for appending, deleting and changing the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "#ifndef UNIX            /* it's in os/unix_defs.h for Unix */", "# include <time.h>"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#ifndef UNIX            /* it's in os/unix_defs.h for Unix */", "# include <time.h>", "#endif"], "build/include_order"]
["src/nvim/memline.c", ["", "typedef struct block0 ZERO_BL;              /* contents of the first block */", "typedef struct pointer_block PTR_BL;        /* contents of a pointer block */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["typedef struct block0 ZERO_BL;              /* contents of the first block */", "typedef struct pointer_block PTR_BL;        /* contents of a pointer block */", "typedef struct data_block DATA_BL;          /* contents of a data block */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["typedef struct pointer_block PTR_BL;        /* contents of a pointer block */", "typedef struct data_block DATA_BL;          /* contents of a data block */", "typedef struct pointer_entry PTR_EN;        /* block/line-count pair */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["typedef struct data_block DATA_BL;          /* contents of a data block */", "typedef struct pointer_entry PTR_EN;        /* block/line-count pair */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "#define DATA_ID        (('d' << 8) + 'a')   /* data block id */", "#define PTR_ID         (('p' << 8) + 't')   /* pointer block id */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define DATA_ID        (('d' << 8) + 'a')   /* data block id */", "#define PTR_ID         (('p' << 8) + 't')   /* pointer block id */", "#define BLOCK0_ID0     'b'                  /* block 0 id 0 */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define PTR_ID         (('p' << 8) + 't')   /* pointer block id */", "#define BLOCK0_ID0     'b'                  /* block 0 id 0 */", "#define BLOCK0_ID1     '0'                  /* block 0 id 1 */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define BLOCK0_ID0     'b'                  /* block 0 id 0 */", "#define BLOCK0_ID1     '0'                  /* block 0 id 1 */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * pointer to a block, used in a pointer block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["struct pointer_entry {", "  blocknr_T pe_bnum;            /* block number */", "  linenr_T pe_line_count;       /* number of lines in this branch */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  blocknr_T pe_bnum;            /* block number */", "  linenr_T pe_line_count;       /* number of lines in this branch */", "  linenr_T pe_old_lnum;         /* lnum for this block (for recovery) */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  linenr_T pe_line_count;       /* number of lines in this branch */", "  linenr_T pe_old_lnum;         /* lnum for this block (for recovery) */", "  int pe_page_count;            /* number of pages in block pe_bnum */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  linenr_T pe_old_lnum;         /* lnum for this block (for recovery) */", "  int pe_page_count;            /* number of pages in block pe_bnum */", "};"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * A pointer block contains a list of branches in the tree."], "readability/old_style_comment"]
["src/nvim/memline.c", ["struct pointer_block {", "  uint16_t pb_id;               /* ID for pointer block: PTR_ID */", "  uint16_t pb_count;            /* number of pointers in this block */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  uint16_t pb_id;               /* ID for pointer block: PTR_ID */", "  uint16_t pb_count;            /* number of pointers in this block */", "  uint16_t pb_count_max;        /* maximum value for pb_count */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  uint16_t pb_count;            /* number of pointers in this block */", "  uint16_t pb_count_max;        /* maximum value for pb_count */", "  PTR_EN pb_pointer[1];         /* list of pointers to blocks (actually longer)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  uint16_t pb_count_max;        /* maximum value for pb_count */", "  PTR_EN pb_pointer[1];         /* list of pointers to blocks (actually longer)", "                                 * followed by empty space until end of page */"], "readability/multiline_comment"]
["src/nvim/memline.c", ["  uint16_t pb_count_max;        /* maximum value for pb_count */", "  PTR_EN pb_pointer[1];         /* list of pointers to blocks (actually longer)", "                                 * followed by empty space until end of page */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  uint16_t pb_count_max;        /* maximum value for pb_count */", "  PTR_EN pb_pointer[1];         /* list of pointers to blocks (actually longer)", "                                 * followed by empty space until end of page */"], "whitespace/parens"]
["src/nvim/memline.c", ["", "/*", " * A data block is a leaf in the tree."], "readability/old_style_comment"]
["src/nvim/memline.c", ["struct data_block {", "  uint16_t db_id;               /* ID for data block: DATA_ID */", "  unsigned db_free;             /* free space available */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  uint16_t db_id;               /* ID for data block: DATA_ID */", "  unsigned db_free;             /* free space available */", "  unsigned db_txt_start;        /* byte where text starts */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  unsigned db_free;             /* free space available */", "  unsigned db_txt_start;        /* byte where text starts */", "  unsigned db_txt_end;          /* byte just after data block */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  unsigned db_txt_start;        /* byte where text starts */", "  unsigned db_txt_end;          /* byte just after data block */", "  linenr_T db_line_count;       /* number of lines in this block */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  unsigned db_txt_end;          /* byte just after data block */", "  linenr_T db_line_count;       /* number of lines in this block */", "  unsigned db_index[1];         /* index for start of line (actually bigger)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  linenr_T db_line_count;       /* number of lines in this block */", "  unsigned db_index[1];         /* index for start of line (actually bigger)", "                                 * followed by empty space upto db_txt_start"], "readability/multiline_comment"]
["src/nvim/memline.c", ["  linenr_T db_line_count;       /* number of lines in this block */", "  unsigned db_index[1];         /* index for start of line (actually bigger)", "                                 * followed by empty space upto db_txt_start"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * The low bits of db_index hold the actual index. The topmost bit is"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "#define INDEX_SIZE  (sizeof(unsigned))      /* size of one db_index entry */", "#define HEADER_SIZE (sizeof(DATA_BL) - INDEX_SIZE)  /* size of data block header */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define INDEX_SIZE  (sizeof(unsigned))      /* size of one db_index entry */", "#define HEADER_SIZE (sizeof(DATA_BL) - INDEX_SIZE)  /* size of data block header */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define INDEX_SIZE  (sizeof(unsigned))      /* size of one db_index entry */", "#define HEADER_SIZE (sizeof(DATA_BL) - INDEX_SIZE)  /* size of data block header */", ""], "whitespace/line_length"]
["src/nvim/memline.c", ["", "#define B0_FNAME_SIZE_ORG       900     /* what it was in older versions */", "#define B0_FNAME_SIZE_NOCRYPT   898     /* 2 bytes used for other things */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define B0_FNAME_SIZE_ORG       900     /* what it was in older versions */", "#define B0_FNAME_SIZE_NOCRYPT   898     /* 2 bytes used for other things */", "#define B0_FNAME_SIZE_CRYPT     890     /* 10 bytes used for other things */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define B0_FNAME_SIZE_NOCRYPT   898     /* 2 bytes used for other things */", "#define B0_FNAME_SIZE_CRYPT     890     /* 10 bytes used for other things */", "#define B0_UNAME_SIZE           40"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define B0_HNAME_SIZE           40", "/*", " * Restrict the numbers to 32 bits, otherwise most compilers will complain."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Block zero holds all info about the swap file."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  char_u b0_id[2];              ///< ID for block 0: BLOCK0_ID0 and BLOCK0_ID1.", "  char_u b0_version[10];        /* Vim version string */", "  char_u b0_page_size[4];       /* number of bytes per page */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  char_u b0_version[10];        /* Vim version string */", "  char_u b0_page_size[4];       /* number of bytes per page */", "  char_u b0_mtime[4];           /* last modification time of file */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  char_u b0_page_size[4];       /* number of bytes per page */", "  char_u b0_mtime[4];           /* last modification time of file */", "  char_u b0_ino[4];             /* inode of b0_fname */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  char_u b0_mtime[4];           /* last modification time of file */", "  char_u b0_ino[4];             /* inode of b0_fname */", "  char_u b0_pid[4];             /* process id of creator (or 0) */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  char_u b0_ino[4];             /* inode of b0_fname */", "  char_u b0_pid[4];             /* process id of creator (or 0) */", "  char_u b0_uname[B0_UNAME_SIZE];        /* name of user (uid if no name) */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  char_u b0_pid[4];             /* process id of creator (or 0) */", "  char_u b0_uname[B0_UNAME_SIZE];        /* name of user (uid if no name) */", "  char_u b0_hname[B0_HNAME_SIZE];        /* host name (if it has a name) */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  char_u b0_uname[B0_UNAME_SIZE];        /* name of user (uid if no name) */", "  char_u b0_hname[B0_HNAME_SIZE];        /* host name (if it has a name) */", "  char_u b0_fname[B0_FNAME_SIZE_ORG];        /* name of file being edited */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  char_u b0_hname[B0_HNAME_SIZE];        /* host name (if it has a name) */", "  char_u b0_fname[B0_FNAME_SIZE_ORG];        /* name of file being edited */", "  long b0_magic_long;           /* check for byte order of long */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  char_u b0_fname[B0_FNAME_SIZE_ORG];        /* name of file being edited */", "  long b0_magic_long;           /* check for byte order of long */", "  int b0_magic_int;             /* check for byte order of int */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  long b0_magic_long;           /* check for byte order of long */", "  int b0_magic_int;             /* check for byte order of int */", "  short b0_magic_short;         /* check for byte order of short */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  int b0_magic_int;             /* check for byte order of int */", "  short b0_magic_short;         /* check for byte order of short */", "  char_u b0_magic_char;         /* check for last char */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  int b0_magic_int;             /* check for byte order of int */", "  short b0_magic_short;         /* check for byte order of short */", "  char_u b0_magic_char;         /* check for last char */"], "runtime/int"]
["src/nvim/memline.c", ["  short b0_magic_short;         /* check for byte order of short */", "  char_u b0_magic_char;         /* check for last char */", "};"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Note: b0_dirty and b0_flags are put at the end of the file name.  For very"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * The b0_flags field is new in Vim 7.0."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/* The lowest two bits contain the fileformat.  Zero means it's not set", " * (compatible with Vim 6.x), otherwise it's EOL_UNIX + 1, EOL_DOS + 1 or"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/* Swap file is in directory of edited file.  Used to find the file from", " * different mount points. */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/* The 'fileencoding' is at the end of b0_fname[], with a NUL in front of it.", " * When empty there is only the NUL. */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "#define STACK_INCR      5       /* nr of entries added to ml_stack at a time */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * The line number where the first mark may be is remembered."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * arguments for ml_find_line()"], "readability/old_style_comment"]
["src/nvim/memline.c", [" */", "#define ML_DELETE       0x11        /* delete line */", "#define ML_INSERT       0x12        /* insert line */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define ML_DELETE       0x11        /* delete line */", "#define ML_INSERT       0x12        /* insert line */", "#define ML_FIND         0x13        /* just find the line */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define ML_INSERT       0x12        /* insert line */", "#define ML_FIND         0x13        /* just find the line */", "#define ML_FLUSH        0x02        /* flush locked block */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define ML_FIND         0x13        /* just find the line */", "#define ML_FLUSH        0x02        /* flush locked block */", "#define ML_SIMPLE(x)    (x & 0x10)  /* DEL, INS or FIND */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define ML_FLUSH        0x02        /* flush locked block */", "#define ML_SIMPLE(x)    (x & 0x10)  /* DEL, INS or FIND */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/* argument for ml_upd_block0() */", "typedef enum {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["typedef enum {", "  UB_FNAME = 0          /* update timestamp and filename */", "  , UB_SAME_DIR         /* update the B0_SAME_DIR flag */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  UB_FNAME = 0          /* update timestamp and filename */", "  , UB_SAME_DIR         /* update the B0_SAME_DIR flag */", "} upd_block0_T;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Open a new memline for \"buf\"."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * init fields in memline struct"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * When 'updatecount' is non-zero swap file may be opened later."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * fill block0 struct and write page 0"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  b0p->b0_magic_int = (int)B0_MAGIC_INT;", "  b0p->b0_magic_short = (short)B0_MAGIC_SHORT;", "  b0p->b0_magic_char = B0_MAGIC_CHAR;"], "runtime/int"]
["src/nvim/memline.c", ["  b0p->b0_magic_char = B0_MAGIC_CHAR;", "  xstrlcpy(xstpcpy((char *) b0p->b0_version, \"VIM \"), Version, 6);", "  long_to_char((long)mfp->mf_page_size, b0p->b0_page_size);"], "whitespace/cast"]
["src/nvim/memline.c", ["", "  /*", "   * Always sync block number 0 to disk, so we can check the file name in"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  mf_put(mfp, hp, true, false);", "  if (!buf->b_help && !B_SPELL(buf))", "    (void)mf_sync(mfp, 0);"], "readability/braces"]
["src/nvim/memline.c", ["", "  /*", "   * Fill in root pointer block and write page 1."], "readability/old_style_comment"]
["src/nvim/memline.c", ["   */", "  if ((hp = ml_new_ptr(mfp)) == NULL)", "    goto error;"], "readability/braces"]
["src/nvim/memline.c", ["  pp->pb_pointer[0].pe_old_lnum = 1;", "  pp->pb_pointer[0].pe_line_count = 1;      /* line count after insertion */", "  mf_put(mfp, hp, true, false);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Allocate first data block and create an empty line 1."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  dp = hp->bh_data;", "  dp->db_index[0] = --dp->db_txt_start;         /* at end of block */", "  dp->db_free -= 1 + INDEX_SIZE;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  dp->db_line_count = 1;", "  *((char_u *)dp + dp->db_txt_start) = NUL;     /* empty line */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * ml_setname() is called when the file name of \"buf\" has been changed."], "readability/old_style_comment"]
["src/nvim/memline.c", ["{", "  int success = FALSE;", "  memfile_T   *mfp;"], "readability/bool"]
["src/nvim/memline.c", ["  mfp = buf->b_ml.ml_mfp;", "  if (mfp->mf_fd < 0) {             /* there is no swap file yet */", "    /*"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if (mfp->mf_fd < 0) {             /* there is no swap file yet */", "    /*", "     * When 'updatecount' is 0 and 'noswapfile' there is no swap file."], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (p_uc != 0 && !cmdmod.noswapfile) {", "      ml_open_file(buf); /* create a swap file */", "    }"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Try all directories in the 'directory' option."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  for (;; ) {", "    if (*dirp == NUL)               /* tried all directories, fail */", "      break;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  for (;; ) {", "    if (*dirp == NUL)               /* tried all directories, fail */", "      break;"], "readability/braces"]
["src/nvim/memline.c", ["                                   &found_existing_dir);", "    /* alloc's fname */", "    if (dirp == NULL)               /* out of memory */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    /* alloc's fname */", "    if (dirp == NULL)               /* out of memory */", "      break;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    /* alloc's fname */", "    if (dirp == NULL)               /* out of memory */", "      break;"], "readability/braces"]
["src/nvim/memline.c", ["      break;", "    if (fname == NULL)              /* no file name found for this dir */", "      continue;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      break;", "    if (fname == NULL)              /* no file name found for this dir */", "      continue;"], "readability/braces"]
["src/nvim/memline.c", ["", "    /* if the file name is the same we don't have to do anything */", "    if (fnamecmp(fname, mfp->mf_fname) == 0) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      xfree(fname);", "      success = TRUE;", "      break;"], "readability/bool"]
["src/nvim/memline.c", ["    }", "    /* need to close the swap file before renaming */", "    if (mfp->mf_fd >= 0) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /* try to rename the swap file */", "    if (vim_rename(mfp->mf_fname, fname) == 0) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (vim_rename(mfp->mf_fname, fname) == 0) {", "      success = TRUE;", "      mf_free_fnames(mfp);"], "readability/bool"]
["src/nvim/memline.c", ["    }", "    xfree(fname);                /* this fname didn't work, try another */", "  }"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (mfp->mf_fd == -1) {           /* need to (re)open the swap file */", "    mfp->mf_fd = os_open((char *)mfp->mf_fname, O_RDWR, 0);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (mfp->mf_fd < 0) {", "      /* could not (re)open the swap file, what can we do???? */", "      EMSG(_(\"E301: Oops, lost the swap file!!!\"));"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  }", "  if (!success)", "    EMSG(_(\"E302: Could not rename swap file\"));"], "readability/braces"]
["src/nvim/memline.c", ["", "/*", " * Open a file for the memfile for all buffers that are not readonly or have"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Open a swap file for an existing memfile, if there is no swap file yet."], "readability/old_style_comment"]
["src/nvim/memline.c", ["      || buf->terminal) {", "    return; /* nothing to do */", "  }"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /* For a spell buffer use a temp file name. */", "  if (buf->b_spell) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    fname = vim_tempname();", "    if (fname != NULL)", "      (void)mf_open_file(mfp, fname);           /* consumes fname! */"], "readability/braces"]
["src/nvim/memline.c", ["    if (fname != NULL)", "      (void)mf_open_file(mfp, fname);           /* consumes fname! */", "    buf->b_may_swap = false;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Try all directories in 'directory' option."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  for (;; ) {", "    if (*dirp == NUL)", "      break;"], "readability/braces"]
["src/nvim/memline.c", ["                                   &found_existing_dir);", "    if (dirp == NULL)", "      break;        /* out of memory */"], "readability/braces"]
["src/nvim/memline.c", ["    if (dirp == NULL)", "      break;        /* out of memory */", "    if (fname == NULL)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      break;        /* out of memory */", "    if (fname == NULL)", "      continue;"], "readability/braces"]
["src/nvim/memline.c", ["      continue;", "    if (mf_open_file(mfp, fname) == OK) {       /* consumes fname! */", "      ml_upd_block0(buf, UB_SAME_DIR);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "      /* Flush block zero, so others can read it */", "      if (mf_sync(mfp, MFS_ZERO) == OK) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      if (mf_sync(mfp, MFS_ZERO) == OK) {", "        /* Mark all blocks that should be in the swapfile as dirty.", "         * Needed for when the 'swapfile' option was reset, so that"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      }", "      /* Writing block 0 failed: close the file and try another dir */", "      mf_close_file(buf, false);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    (void)EMSG2(_(", "            \"E303: Unable to open swap file for \\\"%s\\\", recovery impossible\"),", "        buf_spname(buf) != NULL ? buf_spname(buf) : buf->b_fname);"], "whitespace/indent"]
["src/nvim/memline.c", ["            \"E303: Unable to open swap file for \\\"%s\\\", recovery impossible\"),", "        buf_spname(buf) != NULL ? buf_spname(buf) : buf->b_fname);", "    --no_wait_return;"], "whitespace/alignment"]
["src/nvim/memline.c", ["        buf_spname(buf) != NULL ? buf_spname(buf) : buf->b_fname);", "    --no_wait_return;", "  }"], "readability/increment"]
["src/nvim/memline.c", ["", "  /* don't try to open a swap file again */", "  buf->b_may_swap = false;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Close memline for buffer 'buf'."], "readability/old_style_comment"]
["src/nvim/memline.c", ["{", "  if (buf->b_ml.ml_mfp == NULL)                 /* not open */", "    return;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["{", "  if (buf->b_ml.ml_mfp == NULL)                 /* not open */", "    return;"], "readability/braces"]
["src/nvim/memline.c", ["    return;", "  mf_close(buf->b_ml.ml_mfp, del_file);       /* close the .swp file */", "  if (buf->b_ml.ml_line_lnum != 0 && (buf->b_ml.ml_flags & ML_LINE_DIRTY))"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  mf_close(buf->b_ml.ml_mfp, del_file);       /* close the .swp file */", "  if (buf->b_ml.ml_line_lnum != 0 && (buf->b_ml.ml_flags & ML_LINE_DIRTY))", "    xfree(buf->b_ml.ml_line_ptr);"], "readability/braces"]
["src/nvim/memline.c", ["", "  /* Reset the \"recovered\" flag, give the ATTENTION prompt the next time", "   * this buffer is loaded. */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Close all existing memlines and memfiles."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  }", "  spell_delete_wordlist();      /* delete the internal wordlist */", "  vim_deltempdir();             /* delete created temp directory */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  spell_delete_wordlist();      /* delete the internal wordlist */", "  vim_deltempdir();             /* delete created temp directory */", "}"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Close all memfiles for not modified buffers."], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (!bufIsChanged(buf)) {", "      ml_close(buf, TRUE);          /* close all not-modified buffers */", "    }"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (!bufIsChanged(buf)) {", "      ml_close(buf, TRUE);          /* close all not-modified buffers */", "    }"], "readability/bool"]
["src/nvim/memline.c", ["", "/*", " * Update the timestamp in the .swp file."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Update the timestamp or the B0_SAME_DIR flag of the .swp file."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  mfp = buf->b_ml.ml_mfp;", "  if (mfp == NULL || (hp = mf_get(mfp, 0, 1)) == NULL)", "    return;"], "readability/braces"]
["src/nvim/memline.c", ["", "/*", " * Write file name and timestamp into block 0 of a swap file."], "readability/old_style_comment"]
["src/nvim/memline.c", ["{", "  if (buf->b_ffname == NULL)", "    b0p->b0_fname[0] = NUL;"], "readability/braces"]
["src/nvim/memline.c", ["    b0p->b0_fname[0] = NUL;", "  else {", "    char uname[B0_UNAME_SIZE];"], "readability/braces"]
["src/nvim/memline.c", ["    b0p->b0_fname[0] = NUL;", "  else {", "    char uname[B0_UNAME_SIZE];"], "readability/braces"]
["src/nvim/memline.c", ["", "    /*", "     * For a file under the home directory of the current user, we try to"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    home_replace(NULL, buf->b_ffname, b0p->b0_fname,", "        B0_FNAME_SIZE_CRYPT, TRUE);", "    if (b0p->b0_fname[0] == '~') {"], "whitespace/alignment"]
["src/nvim/memline.c", ["    home_replace(NULL, buf->b_ffname, b0p->b0_fname,", "        B0_FNAME_SIZE_CRYPT, TRUE);", "    if (b0p->b0_fname[0] == '~') {"], "readability/bool"]
["src/nvim/memline.c", ["    if (b0p->b0_fname[0] == '~') {", "      /* If there is no user name or it is too long, don't use \"~/\" */", "      int retval = os_get_user_name(uname, B0_UNAME_SIZE);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /* Also add the 'fileencoding' if there is room. */", "  add_b0_fenc(b0p, curbuf);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Update the B0_SAME_DIR flag of the swap file.  It's set if the file and the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["{", "  if (same_directory(buf->b_ml.ml_mfp->mf_fname, buf->b_ffname))", "    b0p->b0_flags |= B0_SAME_DIR;"], "readability/braces"]
["src/nvim/memline.c", ["    b0p->b0_flags |= B0_SAME_DIR;", "  else", "    b0p->b0_flags &= ~B0_SAME_DIR;"], "readability/braces"]
["src/nvim/memline.c", ["", "/*", " * When there is room, add the 'fileencoding' to block zero."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  n = (int)STRLEN(buf->b_p_fenc);", "  if ((int)STRLEN(b0p->b0_fname) + n + 1 > size)", "    b0p->b0_flags &= ~B0_HAS_FENC;"], "readability/braces"]
["src/nvim/memline.c", ["    b0p->b0_flags &= ~B0_HAS_FENC;", "  else {", "    memmove((char *)b0p->b0_fname + size - n,"], "readability/braces"]
["src/nvim/memline.c", ["    b0p->b0_flags &= ~B0_HAS_FENC;", "  else {", "    memmove((char *)b0p->b0_fname + size - n,"], "readability/braces"]
["src/nvim/memline.c", ["    memmove((char *)b0p->b0_fname + size - n,", "        (char *)buf->b_p_fenc, (size_t)n);", "    *(b0p->b0_fname + size - n - 1) = NUL;"], "whitespace/alignment"]
["src/nvim/memline.c", ["  int called_from_main;", "  int serious_error = TRUE;", "  long mtime;"], "readability/bool"]
["src/nvim/memline.c", ["", "  recoverymode = TRUE;", "  called_from_main = (curbuf->b_ml.ml_mfp == NULL);"], "readability/bool"]
["src/nvim/memline.c", ["  fname = curbuf->b_fname;", "  if (fname == NULL)                /* When there is no file name */", "    fname = (char_u *)\"\";"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  fname = curbuf->b_fname;", "  if (fname == NULL)                /* When there is no file name */", "    fname = (char_u *)\"\";"], "readability/braces"]
["src/nvim/memline.c", ["      && ASCII_ISALPHA(fname[len - 1])) {", "    directly = TRUE;", "    fname_used = vim_strsave(fname);     /* make a copy for mf_open() */"], "readability/bool"]
["src/nvim/memline.c", ["    directly = TRUE;", "    fname_used = vim_strsave(fname);     /* make a copy for mf_open() */", "  } else {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  } else {", "    directly = FALSE;", ""], "readability/bool"]
["src/nvim/memline.c", ["", "    /* count the number of matching swap files */", "    len = recover_names(fname, FALSE, 0, NULL);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    /* count the number of matching swap files */", "    len = recover_names(fname, FALSE, 0, NULL);", "    if (len == 0) {                 /* no swap files found */"], "readability/bool"]
["src/nvim/memline.c", ["    len = recover_names(fname, FALSE, 0, NULL);", "    if (len == 0) {                 /* no swap files found */", "      EMSG2(_(\"E305: No swap file found for %s\"), fname);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    }", "    if (len == 1)                   /* one swap file found, use it */", "      i = 1;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    }", "    if (len == 1)                   /* one swap file found, use it */", "      i = 1;"], "readability/braces"]
["src/nvim/memline.c", ["      i = 1;", "    else {                          /* several swap files found, choose */", "      /* list the names of the swap files */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      i = 1;", "    else {                          /* several swap files found, choose */", "      /* list the names of the swap files */"], "readability/braces"]
["src/nvim/memline.c", ["      i = 1;", "    else {                          /* several swap files found, choose */", "      /* list the names of the swap files */"], "readability/braces"]
["src/nvim/memline.c", ["    else {                          /* several swap files found, choose */", "      /* list the names of the swap files */", "      (void)recover_names(fname, TRUE, 0, NULL);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      /* list the names of the swap files */", "      (void)recover_names(fname, TRUE, 0, NULL);", "      msg_putchar('\\n');"], "readability/bool"]
["src/nvim/memline.c", ["      MSG_PUTS(_(\"Enter number of swap file to use (0 to quit): \"));", "      i = get_number(FALSE, NULL);", "      if (i < 1 || i > len)"], "readability/bool"]
["src/nvim/memline.c", ["      i = get_number(FALSE, NULL);", "      if (i < 1 || i > len)", "        goto theend;"], "readability/braces"]
["src/nvim/memline.c", ["    }", "    /* get the swap file name that will be used */", "    (void)recover_names(fname, FALSE, i, &fname_used);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    /* get the swap file name that will be used */", "    (void)recover_names(fname, FALSE, i, &fname_used);", "  }"], "readability/bool"]
["src/nvim/memline.c", ["  }", "  if (fname_used == NULL)", "    goto theend;  // user chose invalid number."], "readability/braces"]
["src/nvim/memline.c", ["", "  /* When called from main() still need to initialize storage structure */", "  if (called_from_main && ml_open(curbuf) == FAIL)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  /* When called from main() still need to initialize storage structure */", "  if (called_from_main && ml_open(curbuf) == FAIL)", "    getout(1);"], "readability/braces"]
["src/nvim/memline.c", ["", "  /*", "   * Allocate a buffer structure for the swap file that is used for recovery."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * init fields in memline struct"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * open the memfile from the old swap file"], "readability/old_style_comment"]
["src/nvim/memline.c", ["   */", "  p = vim_strsave(fname_used);   /* save \"fname_used\" for the message:", "                                    mf_open() will consume \"fname_used\"! */"], "readability/multiline_comment"]
["src/nvim/memline.c", ["   */", "  p = vim_strsave(fname_used);   /* save \"fname_used\" for the message:", "                                    mf_open() will consume \"fname_used\"! */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  p = vim_strsave(fname_used);   /* save \"fname_used\" for the message:", "                                    mf_open() will consume \"fname_used\"! */", "  mfp = mf_open(fname_used, O_RDONLY);"], "whitespace/operators"]
["src/nvim/memline.c", ["", "  /*", "   * The page size set in mf_open() might be different from the page size"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * try to read block 0"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    MSG_PUTS_ATTR(_(", "            \"\\nMaybe no changes were made or Vim did not update the swap file.\"),", "        attr | MSG_HIST);"], "whitespace/indent"]
["src/nvim/memline.c", ["            \"\\nMaybe no changes were made or Vim did not update the swap file.\"),", "        attr | MSG_HIST);", "    msg_end();"], "whitespace/alignment"]
["src/nvim/memline.c", ["    MSG_PUTS_ATTR(_(", "            \"\\nMaybe no changes were made or Vim did not update the swap file.\"),", "        attr | MSG_HIST);"], "whitespace/line_length"]
["src/nvim/memline.c", ["    MSG_PUTS_ATTR(_(\" cannot be used with this version of Vim.\\n\"),", "        MSG_HIST);", "    MSG_PUTS_ATTR(_(\"Use Vim version 3.0.\\n\"), MSG_HIST);"], "whitespace/alignment"]
["src/nvim/memline.c", ["    MSG_PUTS_ATTR(_(\" cannot be used on this computer.\\n\"),", "        attr | MSG_HIST);", "    MSG_PUTS_ATTR(_(\"The file was created on \"), attr | MSG_HIST);"], "whitespace/alignment"]
["src/nvim/memline.c", ["    MSG_PUTS_ATTR(_(\"The file was created on \"), attr | MSG_HIST);", "    /* avoid going past the end of a corrupted hostname */", "    b0p->b0_fname[0] = NUL;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * If we guessed the wrong page size, we have to recalculate the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      MSG_PUTS_ATTR(_(", "              \" has been damaged (page size is smaller than minimum value).\\n\"),", "          attr | MSG_HIST);"], "whitespace/indent"]
["src/nvim/memline.c", ["              \" has been damaged (page size is smaller than minimum value).\\n\"),", "          attr | MSG_HIST);", "      msg_end();"], "whitespace/alignment"]
["src/nvim/memline.c", ["", "    /* need to reallocate the memory used to store the data */", "    p = xmalloc(mfp->mf_page_size);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * If .swp file name given directly, use name from swap file for buffer."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  home_replace(NULL, mfp->mf_fname, NameBuff, MAXPATHL, TRUE);", "  smsg(_(\"Using swap file \\\"%s\\\"\"), NameBuff);"], "readability/bool"]
["src/nvim/memline.c", ["", "  if (buf_spname(curbuf) != NULL)", "    STRLCPY(NameBuff, buf_spname(curbuf), MAXPATHL);"], "readability/braces"]
["src/nvim/memline.c", ["    STRLCPY(NameBuff, buf_spname(curbuf), MAXPATHL);", "  else", "    home_replace(NULL, curbuf->b_ffname, NameBuff, MAXPATHL, TRUE);"], "readability/braces"]
["src/nvim/memline.c", ["  else", "    home_replace(NULL, curbuf->b_ffname, NameBuff, MAXPATHL, TRUE);", "  smsg(_(\"Original file \\\"%s\\\"\"), NameBuff);"], "readability/bool"]
["src/nvim/memline.c", ["", "  /*", "   * check date of swap file and original file"], "readability/old_style_comment"]
["src/nvim/memline.c", ["           && org_file_info.stat.st_mtim.tv_sec", "              > swp_file_info.stat.st_mtim.tv_sec)", "          || org_file_info.stat.st_mtim.tv_sec != mtime)) {"], "whitespace/alignment"]
["src/nvim/memline.c", ["           && org_file_info.stat.st_mtim.tv_sec", "              > swp_file_info.stat.st_mtim.tv_sec)", "          || org_file_info.stat.st_mtim.tv_sec != mtime)) {"], "whitespace/alignment"]
["src/nvim/memline.c", ["", "  /* Get the 'fileformat' and 'fileencoding' from block zero. */", "  b0_ff = (b0p->b0_flags & B0_FF_MASK);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  mf_put(mfp, hp, false, false);        /* release block 0 */", "  hp = NULL;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Now that we are sure that the file is going to be recovered, clear the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Try reading the original file to obtain the values of 'fileformat',"], "readability/old_style_comment"]
["src/nvim/memline.c", ["   */", "  if (curbuf->b_ffname != NULL)", "    orig_file_status = readfile(curbuf->b_ffname, NULL, (linenr_T)0,"], "readability/braces"]
["src/nvim/memline.c", ["    orig_file_status = readfile(curbuf->b_ffname, NULL, (linenr_T)0,", "        (linenr_T)0, (linenr_T)MAXLNUM, NULL, READ_NEW);", ""], "whitespace/alignment"]
["src/nvim/memline.c", ["", "  /* Use the 'fileformat' and 'fileencoding' as stored in the swap file. */", "  if (b0_ff != 0)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  /* Use the 'fileformat' and 'fileencoding' as stored in the swap file. */", "  if (b0_ff != 0)", "    set_fileformat(b0_ff - 1, OPT_LOCAL);"], "readability/braces"]
["src/nvim/memline.c", ["", "  bnum = 1;             /* start with block 1 */", "  page_count = 1;       /* which is 1 page */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  bnum = 1;             /* start with block 1 */", "  page_count = 1;       /* which is 1 page */", "  lnum = 0;             /* append after line 0 in curbuf */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  page_count = 1;       /* which is 1 page */", "  lnum = 0;             /* append after line 0 in curbuf */", "  line_count = 0;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  line_count = 0;", "  idx = 0;              /* start with first index in block 1 */", "  error = 0;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  buf->b_ml.ml_stack = NULL;", "  buf->b_ml.ml_stack_size = 0;          /* no stack yet */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (curbuf->b_ffname == NULL)", "    cannot_open = TRUE;"], "readability/braces"]
["src/nvim/memline.c", ["  if (curbuf->b_ffname == NULL)", "    cannot_open = TRUE;", "  else"], "readability/bool"]
["src/nvim/memline.c", ["    cannot_open = TRUE;", "  else", "    cannot_open = FALSE;"], "readability/braces"]
["src/nvim/memline.c", ["  else", "    cannot_open = FALSE;", ""], "readability/bool"]
["src/nvim/memline.c", ["", "  serious_error = FALSE;", "  for (; !got_int; line_breakcheck()) {"], "readability/bool"]
["src/nvim/memline.c", ["  for (; !got_int; line_breakcheck()) {", "    if (hp != NULL)", "      mf_put(mfp, hp, false, false);            /* release previous block */"], "readability/braces"]
["src/nvim/memline.c", ["    if (hp != NULL)", "      mf_put(mfp, hp, false, false);            /* release previous block */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * get block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      }", "      ++error;", "      ml_append(lnum++, (char_u *)_(\"???MANY LINES MISSING\"),"], "readability/increment"]
["src/nvim/memline.c", ["      pp = hp->bh_data;", "      if (pp->pb_id == PTR_ID) {                /* it is a pointer block */", "        /* check line count when using pointer block first time */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      if (pp->pb_id == PTR_ID) {                /* it is a pointer block */", "        /* check line count when using pointer block first time */", "        if (idx == 0 && line_count != 0) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        if (idx == 0 && line_count != 0) {", "          for (i = 0; i < (int)pp->pb_count; ++i)", "            line_count -= pp->pb_pointer[i].pe_line_count;"], "readability/braces"]
["src/nvim/memline.c", ["        if (idx == 0 && line_count != 0) {", "          for (i = 0; i < (int)pp->pb_count; ++i)", "            line_count -= pp->pb_pointer[i].pe_line_count;"], "readability/increment"]
["src/nvim/memline.c", ["          if (line_count != 0) {", "            ++error;", "            ml_append(lnum++, (char_u *)_(\"???LINE COUNT WRONG\"),"], "readability/increment"]
["src/nvim/memline.c", ["          if (pp->pb_pointer[idx].pe_bnum < 0) {", "            /*", "             * Data block with negative block number."], "readability/old_style_comment"]
["src/nvim/memline.c", ["            if (cannot_open) {", "              ++error;", "              ml_append(lnum++, (char_u *)_(\"???LINES MISSING\"),"], "readability/increment"]
["src/nvim/memline.c", ["            }", "            ++idx;                  /* get same block again for next index */", "            continue;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["            }", "            ++idx;                  /* get same block again for next index */", "            continue;"], "readability/increment"]
["src/nvim/memline.c", ["", "          /*", "           * going one block deeper in the tree"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        }", "      } else {            /* not a pointer block */", "        dp = hp->bh_data;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        dp = hp->bh_data;", "        if (dp->db_id != DATA_ID) {             /* block id wrong */", "          if (bnum == 1) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["            EMSG2(_(\"E310: Block 1 ID wrong (%s not a .swp file?)\"),", "                mfp->mf_fname);", "            goto theend;"], "whitespace/alignment"]
["src/nvim/memline.c", ["          }", "          ++error;", "          ml_append(lnum++, (char_u *)_(\"???BLOCK MISSING\"),"], "readability/increment"]
["src/nvim/memline.c", ["", "          /* make sure there is a NUL at the end of the block */", "          *((char_u *)dp + dp->db_txt_end - 1) = NUL;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "          /*", "           * check number of lines in block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "          for (i = 0; i < dp->db_line_count; ++i) {", "            txt_start = (dp->db_index[i] & DB_INDEX_MASK);"], "readability/increment"]
["src/nvim/memline.c", ["              p = (char_u *)\"???\";", "              ++error;", "            } else"], "readability/increment"]
["src/nvim/memline.c", ["              ++error;", "            } else", "              p = (char_u *)dp + txt_start;"], "readability/braces"]
["src/nvim/memline.c", ["", "    if (buf->b_ml.ml_stack_top == 0)            /* finished */", "      break;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    if (buf->b_ml.ml_stack_top == 0)            /* finished */", "      break;"], "readability/braces"]
["src/nvim/memline.c", ["", "    /*", "     * go one block up in the tree"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    bnum = ip->ip_bnum;", "    idx = ip->ip_index + 1;         /* go to next index */", "    page_count = 1;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Compare the buffer contents with the original file.  When they differ"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if (orig_file_status != OK || curbuf->b_ml.ml_line_count != lnum * 2 + 1) {", "    /* Recovering an empty file results in two lines and the first line is", "     * empty.  Don't set the modified flag then. */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  } else {", "    for (idx = 1; idx <= lnum; ++idx) {", "      /* Need to copy one line, fetching the other one may flush it. */"], "readability/increment"]
["src/nvim/memline.c", ["    for (idx = 1; idx <= lnum; ++idx) {", "      /* Need to copy one line, fetching the other one may flush it. */", "      p = vim_strsave(ml_get(idx));"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Delete the lines from the original file and the dummy line from the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["   */", "  while (curbuf->b_ml.ml_line_count > lnum", "         && !(curbuf->b_ml.ml_flags & ML_EMPTY))"], "readability/braces"]
["src/nvim/memline.c", ["", "  recoverymode = FALSE;", "  if (got_int)"], "readability/bool"]
["src/nvim/memline.c", ["  recoverymode = FALSE;", "  if (got_int)", "    EMSG(_(\"E311: Recovery Interrupted\"));"], "readability/braces"]
["src/nvim/memline.c", ["    EMSG(_(\"E311: Recovery Interrupted\"));", "  else if (error) {", "    ++no_wait_return;"], "readability/braces"]
["src/nvim/memline.c", ["  else if (error) {", "    ++no_wait_return;", "    MSG(\">>>>>>>>>>>>>\");"], "readability/increment"]
["src/nvim/memline.c", ["    EMSG(_(", "            \"E312: Errors detected while recovering; look for lines starting with ???\"));", "    --no_wait_return;"], "whitespace/indent"]
["src/nvim/memline.c", ["    EMSG(_(", "            \"E312: Errors detected while recovering; look for lines starting with ???\"));", "    --no_wait_return;"], "whitespace/line_length"]
["src/nvim/memline.c", ["            \"E312: Errors detected while recovering; look for lines starting with ???\"));", "    --no_wait_return;", "    MSG(_(\"See \\\":help E312\\\" for more information.\"));"], "readability/increment"]
["src/nvim/memline.c", ["      MSG_PUTS(_(", "              \"\\n(You might want to write out this file under another name\\n\"));", "      MSG_PUTS(_(\"and run diff with the original file to check for changes)\"));"], "whitespace/indent"]
["src/nvim/memline.c", ["      MSG_PUTS(_(\"and run diff with the original file to check for changes)\"));", "    } else", "      MSG(_(\"Recovery completed. Buffer contents equals file contents.\"));"], "readability/braces"]
["src/nvim/memline.c", ["  xfree(fname_used);", "  recoverymode = FALSE;", "  if (mfp != NULL) {"], "readability/bool"]
["src/nvim/memline.c", ["  if (mfp != NULL) {", "    if (hp != NULL)", "      mf_put(mfp, hp, false, false);"], "readability/braces"]
["src/nvim/memline.c", ["      mf_put(mfp, hp, false, false);", "    mf_close(mfp, false);           /* will also xfree(mfp->mf_fname) */", "  }"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  }", "  if (buf != NULL) {  //may be NULL if swap file not found.", "    xfree(buf->b_ml.ml_stack);"], "whitespace/comments"]
["src/nvim/memline.c", ["  }", "  if (serious_error && called_from_main)", "    ml_close(curbuf, TRUE);"], "readability/braces"]
["src/nvim/memline.c", ["  if (serious_error && called_from_main)", "    ml_close(curbuf, TRUE);", "  else {"], "readability/bool"]
["src/nvim/memline.c", ["    ml_close(curbuf, TRUE);", "  else {", "    apply_autocmds(EVENT_BUFREADPOST, NULL, curbuf->b_fname, FALSE, curbuf);"], "readability/braces"]
["src/nvim/memline.c", ["    ml_close(curbuf, TRUE);", "  else {", "    apply_autocmds(EVENT_BUFREADPOST, NULL, curbuf->b_fname, FALSE, curbuf);"], "readability/braces"]
["src/nvim/memline.c", ["  else {", "    apply_autocmds(EVENT_BUFREADPOST, NULL, curbuf->b_fname, FALSE, curbuf);", "    apply_autocmds(EVENT_BUFWINENTER, NULL, curbuf->b_fname, FALSE, curbuf);"], "readability/bool"]
["src/nvim/memline.c", ["    apply_autocmds(EVENT_BUFREADPOST, NULL, curbuf->b_fname, FALSE, curbuf);", "    apply_autocmds(EVENT_BUFWINENTER, NULL, curbuf->b_fname, FALSE, curbuf);", "  }"], "readability/bool"]
["src/nvim/memline.c", ["", "/*", " * Find the names of swap files in current directory and the directory given"], "readability/old_style_comment"]
["src/nvim/memline.c", [" */", "int ", "recover_names ("], "whitespace/end_of_line"]
["src/nvim/memline.c", ["int ", "recover_names (", "    char_u *fname,             /* base for swap file name */"], "whitespace/parens"]
["src/nvim/memline.c", ["recover_names (", "    char_u *fname,             /* base for swap file name */", "    int list,                       /* when TRUE, list the swap file names */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    char_u *fname,             /* base for swap file name */", "    int list,                       /* when TRUE, list the swap file names */", "    int nr,                         /* when non-zero, return nr'th swap file name */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    int list,                       /* when TRUE, list the swap file names */", "    int nr,                         /* when non-zero, return nr'th swap file name */", "    char_u **fname_out        /* result when \"nr\" > 0 */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    int list,                       /* when TRUE, list the swap file names */", "    int nr,                         /* when non-zero, return nr'th swap file name */", "    char_u **fname_out        /* result when \"nr\" > 0 */"], "whitespace/line_length"]
["src/nvim/memline.c", ["    int nr,                         /* when non-zero, return nr'th swap file name */", "    char_u **fname_out        /* result when \"nr\" > 0 */", ")"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#ifdef HAVE_READLINK", "    /* Expand symlink in the file name, because the swap file is created", "     * with the actual file instead of with the symlink. */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["     * with the actual file instead of with the symlink. */", "    if (resolve_symlink(fname, fname_buf) == OK)", "      fname_res = fname_buf;"], "readability/braces"]
["src/nvim/memline.c", ["      fname_res = fname_buf;", "    else", "#endif"], "readability/braces"]
["src/nvim/memline.c", ["  if (list) {", "    /* use msg() to start the scrolling properly */", "    msg((char_u *)_(\"Swap files found:\"));"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    if (dir_name[0] == '.' && dir_name[1] == NUL) {     /* check current dir */", "      if (fname == NULL) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        names[0] = vim_strsave((char_u *)\"*.sw?\");", "        /* For Unix names starting with a dot are special.  MS-Windows", "         * supports this too, on some file systems. */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        num_names = 3;", "      } else", "        num_names = recov_file_names(names, fname_res, TRUE);"], "readability/braces"]
["src/nvim/memline.c", ["      } else", "        num_names = recov_file_names(names, fname_res, TRUE);", "    } else {                      /* check directory dir_name */"], "readability/bool"]
["src/nvim/memline.c", ["        num_names = recov_file_names(names, fname_res, TRUE);", "    } else {                      /* check directory dir_name */", "      if (fname == NULL) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      if (fname == NULL) {", "        names[0] = (char_u *)concat_fnames((char *)dir_name, \"*.sw?\", TRUE);", "        /* For Unix names starting with a dot are special.  MS-Windows"], "readability/bool"]
["src/nvim/memline.c", ["        names[0] = (char_u *)concat_fnames((char *)dir_name, \"*.sw?\", TRUE);", "        /* For Unix names starting with a dot are special.  MS-Windows", "         * supports this too, on some file systems. */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["         * supports this too, on some file systems. */", "        names[1] = (char_u *)concat_fnames((char *)dir_name, \".*.sw?\", TRUE);", "        names[2] = (char_u *)concat_fnames((char *)dir_name, \".sw?\", TRUE);"], "readability/bool"]
["src/nvim/memline.c", ["        names[1] = (char_u *)concat_fnames((char *)dir_name, \".*.sw?\", TRUE);", "        names[2] = (char_u *)concat_fnames((char *)dir_name, \".sw?\", TRUE);", "        num_names = 3;"], "readability/bool"]
["src/nvim/memline.c", ["          tail = path_tail(fname_res);", "          tail = (char_u *)concat_fnames((char *)dir_name, (char *)tail, TRUE);", "        }"], "readability/bool"]
["src/nvim/memline.c", ["        }", "        num_names = recov_file_names(names, tail, FALSE);", "        xfree(tail);"], "readability/bool"]
["src/nvim/memline.c", ["", "    if (num_names == 0)", "      num_files = 0;"], "readability/braces"]
["src/nvim/memline.c", ["      num_files = 0;", "    else if (expand_wildcards(num_names, names, &num_files, &files,", "                 EW_KEEPALL|EW_FILE|EW_SILENT) == FAIL)"], "readability/braces"]
["src/nvim/memline.c", ["    else if (expand_wildcards(num_names, names, &num_files, &files,", "                 EW_KEEPALL|EW_FILE|EW_SILENT) == FAIL)", "      num_files = 0;"], "whitespace/alignment"]
["src/nvim/memline.c", ["", "    /*", "     * When no swap file found, wildcard expansion might have failed (e.g."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * remove swapfile name of the current buffer, it must be ignored"], "readability/old_style_comment"]
["src/nvim/memline.c", ["          xfree(files[i]);", "          if (--num_files == 0)", "            xfree(files);"], "readability/braces"]
["src/nvim/memline.c", ["            xfree(files);", "          else", "            for (; i < num_files; ++i)"], "readability/braces"]
["src/nvim/memline.c", ["          else", "            for (; i < num_files; ++i)", "              files[i] = files[i + 1];"], "readability/braces"]
["src/nvim/memline.c", ["          else", "            for (; i < num_files; ++i)", "              files[i] = files[i + 1];"], "readability/increment"]
["src/nvim/memline.c", ["            files[nr - 1 + num_files - file_count]);", "        dirp = (char_u *)\"\";                        /* stop searching */", "      }"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      if (dir_name[0] == '.' && dir_name[1] == NUL) {", "        if (fname == NULL)", "          MSG_PUTS(_(\"   In current directory:\\n\"));"], "readability/braces"]
["src/nvim/memline.c", ["          MSG_PUTS(_(\"   In current directory:\\n\"));", "        else", "          MSG_PUTS(_(\"   Using specified name:\\n\"));"], "readability/braces"]
["src/nvim/memline.c", ["      if (num_files) {", "        for (int i = 0; i < num_files; ++i) {", "          /* print the swap file name */"], "readability/increment"]
["src/nvim/memline.c", ["        for (int i = 0; i < num_files; ++i) {", "          /* print the swap file name */", "          msg_outnum((long)++file_count);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        }", "      } else", "        MSG_PUTS(_(\"      -- none --\\n\"));"], "readability/braces"]
["src/nvim/memline.c", ["      ui_flush();", "    } else", "      file_count += num_files;"], "readability/braces"]
["src/nvim/memline.c", ["", "    for (int i = 0; i < num_names; ++i)", "      xfree(names[i]);"], "readability/braces"]
["src/nvim/memline.c", ["", "    for (int i = 0; i < num_names; ++i)", "      xfree(names[i]);"], "readability/increment"]
["src/nvim/memline.c", ["      xfree(names[i]);", "    if (num_files > 0)", "      FreeWild(num_files, files);"], "readability/braces"]
["src/nvim/memline.c", ["", "/*", " * Append the full path to name with path separators made into percent"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    }", "    d = concat_fnames(dir, s, TRUE);", "    xfree(s);"], "readability/bool"]
["src/nvim/memline.c", ["      MSG_PUTS(_(\"   dated: \"));", "    } else", "#endif"], "readability/braces"]
["src/nvim/memline.c", ["", "  /*", "   * print the original file name"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        MSG_PUTS(_(\"         file name: \"));", "        if (b0.b0_fname[0] == NUL)", "          MSG_PUTS(_(\"[No Name]\"));"], "readability/braces"]
["src/nvim/memline.c", ["          MSG_PUTS(_(\"[No Name]\"));", "        else", "          msg_outtrans(b0.b0_fname);"], "readability/braces"]
["src/nvim/memline.c", ["        if (*(b0.b0_hname) != NUL) {", "          if (*(b0.b0_uname) != NUL)", "            MSG_PUTS(_(\"   host name: \"));"], "readability/braces"]
["src/nvim/memline.c", ["            MSG_PUTS(_(\"   host name: \"));", "          else", "            MSG_PUTS(_(\"\\n         host name: \"));"], "readability/braces"]
["src/nvim/memline.c", ["      }", "    } else", "      MSG_PUTS(_(\"         [cannot be read]\"));"], "readability/braces"]
["src/nvim/memline.c", ["    close(fd);", "  } else", "    MSG_PUTS(_(\"         [cannot be opened]\"));"], "readability/braces"]
["src/nvim/memline.c", ["  // Form the normal swap file name pattern by appending \".sw?\".", "  names[num_names] = (char_u *)concat_fnames((char *)path, \".sw?\", FALSE);", "  if (num_names >= 1) {     /* check if we have the same name twice */"], "readability/bool"]
["src/nvim/memline.c", ["  names[num_names] = (char_u *)concat_fnames((char *)path, \".sw?\", FALSE);", "  if (num_names >= 1) {     /* check if we have the same name twice */", "    char_u *p = names[num_names - 1];"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    int i = (int)STRLEN(names[num_names - 1]) - (int)STRLEN(names[num_names]);", "    if (i > 0)", "      p += i;               /* file name has been expanded to full path */"], "readability/braces"]
["src/nvim/memline.c", ["    if (i > 0)", "      p += i;               /* file name has been expanded to full path */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    if (STRCMP(p, names[num_names]) != 0)", "      ++num_names;"], "readability/braces"]
["src/nvim/memline.c", ["    if (STRCMP(p, names[num_names]) != 0)", "      ++num_names;", "    else"], "readability/increment"]
["src/nvim/memline.c", ["      ++num_names;", "    else", "      xfree(names[num_names]);"], "readability/braces"]
["src/nvim/memline.c", ["      xfree(names[num_names]);", "  } else", "    ++num_names;"], "readability/braces"]
["src/nvim/memline.c", ["  } else", "    ++num_names;", ""], "readability/increment"]
["src/nvim/memline.c", ["", "/*", " * sync all memlines"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  FOR_ALL_BUFFERS(buf) {", "    if (buf->b_ml.ml_mfp == NULL || buf->b_ml.ml_mfp->mf_fname == NULL)", "      continue;                             /* no file */"], "readability/braces"]
["src/nvim/memline.c", ["    if (buf->b_ml.ml_mfp == NULL || buf->b_ml.ml_mfp->mf_fname == NULL)", "      continue;                             /* no file */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    ml_flush_line(buf);                     /* flush buffered line */", "                                            /* flush locked block */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    ml_flush_line(buf);                     /* flush buffered line */", "                                            /* flush locked block */", "    (void)ml_find_line(buf, (linenr_T)0, ML_FLUSH);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        && buf->b_ffname != NULL) {", "      /*", "       * If the original file does not exist anymore or has been changed"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * sync one buffer, including negative blocks"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if (mfp == NULL || mfp->mf_fname == NULL) {", "    if (message)", "      EMSG(_(\"E313: Cannot preserve, there is no swap file\"));"], "readability/braces"]
["src/nvim/memline.c", ["", "  /* We only want to stop when interrupted here, not when interrupted", "   * before. */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["   * before. */", "  got_int = FALSE;", ""], "readability/bool"]
["src/nvim/memline.c", ["", "  /* stack is invalid after mf_sync(.., MFS_ALL) */", "  buf->b_ml.ml_stack_top = 0;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Some of the data blocks may have been changed from negative to"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if (message) {", "    if (status == OK)", "      MSG(_(\"File preserved\"));"], "readability/braces"]
["src/nvim/memline.c", ["      MSG(_(\"File preserved\"));", "    else", "      EMSG(_(\"E314: Preserve failed\"));"], "readability/braces"]
["src/nvim/memline.c", ["", "/*", " * NOTE: The pointer returned by the ml_get_*() functions only remains valid"], "readability/old_style_comment"]
["src/nvim/memline.c", [" */", "/*", " * Return a pointer to a (read-only copy of a) line."], "readability/old_style_comment"]
["src/nvim/memline.c", ["{", "  return ml_get_buf(curbuf, lnum, FALSE);", "}"], "readability/bool"]
["src/nvim/memline.c", ["", "/*", " * Return pointer to position \"pos\"."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Return a pointer to a line in a specific buffer"], "readability/old_style_comment"]
["src/nvim/memline.c", ["char_u *", "ml_get_buf (", "    buf_T *buf,"], "whitespace/parens"]
["src/nvim/memline.c", ["", "  if (lnum > buf->b_ml.ml_line_count) { /* invalid line number */", "    if (recursive == 0) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  }", "  if (lnum <= 0)                        /* pretend line 0 is line 1 */", "    lnum = 1;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  }", "  if (lnum <= 0)                        /* pretend line 0 is line 1 */", "    lnum = 1;"], "readability/braces"]
["src/nvim/memline.c", ["", "  if (buf->b_ml.ml_mfp == NULL)         /* there are no lines */", "    return (char_u *)\"\";"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (buf->b_ml.ml_mfp == NULL)         /* there are no lines */", "    return (char_u *)\"\";"], "readability/braces"]
["src/nvim/memline.c", ["", "  /*", "   * See if it is the same line as requested last time."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * Find the data block containing the line."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Check if a line that was just obtained by a call to ml_get"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Append a line after lnum (may be 0 to insert a line in front of the file)."], "readability/old_style_comment"]
["src/nvim/memline.c", ["{", "  /* When starting up, we might still need to create the memfile */", "  if (curbuf->b_ml.ml_mfp == NULL && open_buffer(FALSE, NULL, 0) == FAIL)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  /* When starting up, we might still need to create the memfile */", "  if (curbuf->b_ml.ml_mfp == NULL && open_buffer(FALSE, NULL, 0) == FAIL)", "    return FAIL;"], "readability/braces"]
["src/nvim/memline.c", ["  /* When starting up, we might still need to create the memfile */", "  if (curbuf->b_ml.ml_mfp == NULL && open_buffer(FALSE, NULL, 0) == FAIL)", "    return FAIL;"], "readability/bool"]
["src/nvim/memline.c", ["", "  if (curbuf->b_ml.ml_line_lnum != 0)", "    ml_flush_line(curbuf);"], "readability/braces"]
["src/nvim/memline.c", ["    ml_flush_line(curbuf);", "  return ml_append_int(curbuf, lnum, line, len, newfile, FALSE);", "}"], "readability/bool"]
["src/nvim/memline.c", ["", "/*", " * Like ml_append() but for an arbitrary buffer.  The buffer must already have"], "readability/old_style_comment"]
["src/nvim/memline.c", ["{", "  if (buf->b_ml.ml_mfp == NULL)", "    return FAIL;"], "readability/braces"]
["src/nvim/memline.c", ["", "  if (buf->b_ml.ml_line_lnum != 0)", "    ml_flush_line(buf);"], "readability/braces"]
["src/nvim/memline.c", ["    ml_flush_line(buf);", "  return ml_append_int(buf, lnum, line, len, newfile, FALSE);", "}"], "readability/bool"]
["src/nvim/memline.c", ["  int i;", "  int line_count;               /* number of indexes in current block */", "  int offset;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  int from, to;", "  int space_needed;             /* space needed for new line */", "  int page_size;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  int page_count;", "  int db_idx;                   /* index for lnum in data block */", "  bhdr_T      *hp;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /* lnum out of range */", "  if (lnum > buf->b_ml.ml_line_count || buf->b_ml.ml_mfp == NULL)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  /* lnum out of range */", "  if (lnum > buf->b_ml.ml_line_count || buf->b_ml.ml_mfp == NULL)", "    return FAIL;"], "readability/braces"]
["src/nvim/memline.c", ["", "  if (lowest_marked && lowest_marked > lnum)", "    lowest_marked = lnum + 1;"], "readability/braces"]
["src/nvim/memline.c", ["", "  if (len == 0)", "    len = (colnr_T)STRLEN(line) + 1;            /* space needed for the text */"], "readability/braces"]
["src/nvim/memline.c", ["  if (len == 0)", "    len = (colnr_T)STRLEN(line) + 1;            /* space needed for the text */", "  space_needed = len + INDEX_SIZE;      /* space needed for text + index */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    len = (colnr_T)STRLEN(line) + 1;            /* space needed for the text */", "  space_needed = len + INDEX_SIZE;      /* space needed for text + index */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * find the data block containing the previous line"], "readability/old_style_comment"]
["src/nvim/memline.c", ["   */", "  if ((hp = ml_find_line(buf, lnum == 0 ? (linenr_T)1 : lnum,", "           ML_INSERT)) == NULL)"], "readability/braces"]
["src/nvim/memline.c", ["  if ((hp = ml_find_line(buf, lnum == 0 ? (linenr_T)1 : lnum,", "           ML_INSERT)) == NULL)", "    return FAIL;"], "whitespace/alignment"]
["src/nvim/memline.c", ["", "  if (lnum == 0)                /* got line one instead, correct db_idx */", "    db_idx = -1;                /* careful, it is negative! */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (lnum == 0)                /* got line one instead, correct db_idx */", "    db_idx = -1;                /* careful, it is negative! */"], "readability/braces"]
["src/nvim/memline.c", ["  if (lnum == 0)                /* got line one instead, correct db_idx */", "    db_idx = -1;                /* careful, it is negative! */", "  else"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    db_idx = -1;                /* careful, it is negative! */", "  else", "    db_idx = lnum - buf->b_ml.ml_locked_low;"], "readability/braces"]
["src/nvim/memline.c", ["    db_idx = lnum - buf->b_ml.ml_locked_low;", "  /* get line count before the insertion */", "  line_count = buf->b_ml.ml_locked_high - buf->b_ml.ml_locked_low;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * If"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      && lnum < buf->b_ml.ml_line_count) {", "    /*", "     * Now that the line is not going to be inserted in the block that we"], "readability/old_style_comment"]
["src/nvim/memline.c", ["     */", "    --(buf->b_ml.ml_locked_lineadd);", "    --(buf->b_ml.ml_locked_high);"], "readability/increment"]
["src/nvim/memline.c", ["    --(buf->b_ml.ml_locked_lineadd);", "    --(buf->b_ml.ml_locked_high);", "    if ((hp = ml_find_line(buf, lnum + 1, ML_INSERT)) == NULL)"], "readability/increment"]
["src/nvim/memline.c", ["    --(buf->b_ml.ml_locked_high);", "    if ((hp = ml_find_line(buf, lnum + 1, ML_INSERT)) == NULL)", "      return FAIL;"], "readability/braces"]
["src/nvim/memline.c", ["", "    db_idx = -1;                    /* careful, it is negative! */", "    /* get line count before the insertion */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    db_idx = -1;                    /* careful, it is negative! */", "    /* get line count before the insertion */", "    line_count = buf->b_ml.ml_locked_high - buf->b_ml.ml_locked_low;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  ++buf->b_ml.ml_line_count;", ""], "readability/increment"]
["src/nvim/memline.c", ["", "  if ((int)dp->db_free >= space_needed) {       /* enough room in data block */", "    /*"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if ((int)dp->db_free >= space_needed) {       /* enough room in data block */", "    /*", "     * Insert new line in existing data block, or in data block allocated above."], "readability/old_style_comment"]
["src/nvim/memline.c", ["    dp->db_free -= space_needed;", "    ++(dp->db_line_count);", ""], "readability/increment"]
["src/nvim/memline.c", ["", "    /*", "     * move the text of the lines that follow to the front"], "readability/old_style_comment"]
["src/nvim/memline.c", ["     */", "    if (line_count > db_idx + 1) {          /* if there are following lines */", "      /*"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (line_count > db_idx + 1) {          /* if there are following lines */", "      /*", "       * Offset is the start of the previous line."], "readability/old_style_comment"]
["src/nvim/memline.c", ["       */", "      if (db_idx < 0)", "        offset = dp->db_txt_end;"], "readability/braces"]
["src/nvim/memline.c", ["        offset = dp->db_txt_end;", "      else", "        offset = ((dp->db_index[db_idx]) & DB_INDEX_MASK);"], "readability/braces"]
["src/nvim/memline.c", ["      memmove((char *)dp + dp->db_txt_start,", "          (char *)dp + dp->db_txt_start + len,", "          (size_t)(offset - (dp->db_txt_start + len)));"], "whitespace/alignment"]
["src/nvim/memline.c", ["          (char *)dp + dp->db_txt_start + len,", "          (size_t)(offset - (dp->db_txt_start + len)));", "      for (i = line_count - 1; i > db_idx; --i)"], "whitespace/alignment"]
["src/nvim/memline.c", ["          (size_t)(offset - (dp->db_txt_start + len)));", "      for (i = line_count - 1; i > db_idx; --i)", "        dp->db_index[i + 1] = dp->db_index[i] - len;"], "readability/braces"]
["src/nvim/memline.c", ["          (size_t)(offset - (dp->db_txt_start + len)));", "      for (i = line_count - 1; i > db_idx; --i)", "        dp->db_index[i + 1] = dp->db_index[i] - len;"], "readability/increment"]
["src/nvim/memline.c", ["      dp->db_index[db_idx + 1] = offset - len;", "    } else                                  /* add line at the end */", "      dp->db_index[db_idx + 1] = dp->db_txt_start;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      dp->db_index[db_idx + 1] = offset - len;", "    } else                                  /* add line at the end */", "      dp->db_index[db_idx + 1] = dp->db_txt_start;"], "readability/braces"]
["src/nvim/memline.c", ["", "    /*", "     * copy the text into the block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    memmove((char *)dp + dp->db_index[db_idx + 1], line, (size_t)len);", "    if (mark)", "      dp->db_index[db_idx + 1] |= DB_MARKED;"], "readability/braces"]
["src/nvim/memline.c", ["", "    /*", "     * Mark the block dirty."], "readability/old_style_comment"]
["src/nvim/memline.c", ["    buf->b_ml.ml_flags |= ML_LOCKED_DIRTY;", "    if (!newfile)", "      buf->b_ml.ml_flags |= ML_LOCKED_POS;"], "readability/braces"]
["src/nvim/memline.c", ["      buf->b_ml.ml_flags |= ML_LOCKED_POS;", "  } else {        /* not enough space in data block */", "    /*"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  } else {        /* not enough space in data block */", "    /*", "     * If there is not enough room we have to create a new data block and copy some"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    int lines_moved;", "    int data_moved = 0;                     /* init to shut up gcc */", "    int total_moved = 0;                    /* init to shut up gcc */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    int data_moved = 0;                     /* init to shut up gcc */", "    int total_moved = 0;                    /* init to shut up gcc */", "    DATA_BL     *dp_right, *dp_left;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * We are going to allocate a new data block. Depending on the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["     */", "    if (db_idx < 0) {           /* left block is new, right block is existing */", "      lines_moved = 0;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      lines_moved = 0;", "      in_left = TRUE;", "      /* space_needed does not change */"], "readability/bool"]
["src/nvim/memline.c", ["      in_left = TRUE;", "      /* space_needed does not change */", "    } else {                  /* left block is existing, right block is new */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      /* space_needed does not change */", "    } else {                  /* left block is existing, right block is new */", "      lines_moved = line_count - db_idx - 1;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      lines_moved = line_count - db_idx - 1;", "      if (lines_moved == 0)", "        in_left = FALSE;                /* put new line in right block */"], "readability/braces"]
["src/nvim/memline.c", ["      if (lines_moved == 0)", "        in_left = FALSE;                /* put new line in right block */", "                                        /* space_needed does not change */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      if (lines_moved == 0)", "        in_left = FALSE;                /* put new line in right block */", "                                        /* space_needed does not change */"], "readability/bool"]
["src/nvim/memline.c", ["        in_left = FALSE;                /* put new line in right block */", "                                        /* space_needed does not change */", "      else {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["                                        /* space_needed does not change */", "      else {", "        data_moved = ((dp->db_index[db_idx]) & DB_INDEX_MASK) -"], "readability/braces"]
["src/nvim/memline.c", ["                                        /* space_needed does not change */", "      else {", "        data_moved = ((dp->db_index[db_idx]) & DB_INDEX_MASK) -"], "readability/braces"]
["src/nvim/memline.c", ["        if ((int)dp->db_free + total_moved >= space_needed) {", "          in_left = TRUE;               /* put new line in left block */", "          space_needed = total_moved;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        if ((int)dp->db_free + total_moved >= space_needed) {", "          in_left = TRUE;               /* put new line in left block */", "          space_needed = total_moved;"], "readability/bool"]
["src/nvim/memline.c", ["        } else {", "          in_left = FALSE;                  /* put new line in right block */", "          space_needed += total_moved;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        } else {", "          in_left = FALSE;                  /* put new line in right block */", "          space_needed += total_moved;"], "readability/bool"]
["src/nvim/memline.c", ["    hp_new = ml_new_data(mfp, newfile, page_count);", "    if (db_idx < 0) {           /* left block is new */", "      hp_left = hp_new;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      line_count_right = line_count;", "    } else {                  /* right block is new */", "      hp_left = hp;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * May move the new line into the right/new block."], "readability/old_style_comment"]
["src/nvim/memline.c", ["      dp_right->db_index[0] = dp_right->db_txt_start;", "      if (mark)", "        dp_right->db_index[0] |= DB_MARKED;"], "readability/braces"]
["src/nvim/memline.c", ["      memmove((char *)dp_right + dp_right->db_txt_start,", "          line, (size_t)len);", "      ++line_count_right;"], "whitespace/alignment"]
["src/nvim/memline.c", ["          line, (size_t)len);", "      ++line_count_right;", "    }"], "readability/increment"]
["src/nvim/memline.c", ["    }", "    /*", "     * may move lines from the left/old block to the right/new one."], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (lines_moved) {", "      /*", "       */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      memmove((char *)dp_right + dp_right->db_txt_start,", "          (char *)dp_left + dp_left->db_txt_start,", "          (size_t)data_moved);"], "whitespace/alignment"]
["src/nvim/memline.c", ["          (char *)dp_left + dp_left->db_txt_start,", "          (size_t)data_moved);", "      offset = dp_right->db_txt_start - dp_left->db_txt_start;"], "whitespace/alignment"]
["src/nvim/memline.c", ["", "      /*", "       * update indexes in the new block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["       */", "      for (to = line_count_right, from = db_idx + 1;", "           from < line_count_left; ++from, ++to)"], "readability/braces"]
["src/nvim/memline.c", ["      for (to = line_count_right, from = db_idx + 1;", "           from < line_count_left; ++from, ++to)", "        dp_right->db_index[to] = dp->db_index[from] + offset;"], "readability/increment"]
["src/nvim/memline.c", ["", "    /*", "     * May move the new line into the left (old or new) block."], "readability/old_style_comment"]
["src/nvim/memline.c", ["      dp_left->db_index[line_count_left] = dp_left->db_txt_start;", "      if (mark)", "        dp_left->db_index[line_count_left] |= DB_MARKED;"], "readability/braces"]
["src/nvim/memline.c", ["      memmove((char *)dp_left + dp_left->db_txt_start,", "          line, (size_t)len);", "      ++line_count_left;"], "whitespace/alignment"]
["src/nvim/memline.c", ["          line, (size_t)len);", "      ++line_count_left;", "    }"], "readability/increment"]
["src/nvim/memline.c", ["", "    if (db_idx < 0) {           /* left block is new */", "      lnum_left = lnum + 1;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      lnum_right = 0;", "    } else {                  /* right block is new */", "      lnum_left = 0;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      lnum_left = 0;", "      if (in_left)", "        lnum_right = lnum + 2;"], "readability/braces"]
["src/nvim/memline.c", ["        lnum_right = lnum + 2;", "      else", "        lnum_right = lnum + 1;"], "readability/braces"]
["src/nvim/memline.c", ["", "    /*", "     * release the two data blocks"], "readability/old_style_comment"]
["src/nvim/memline.c", ["     */", "    if (lines_moved || in_left)", "      buf->b_ml.ml_flags |= ML_LOCKED_DIRTY;"], "readability/braces"]
["src/nvim/memline.c", ["      buf->b_ml.ml_flags |= ML_LOCKED_DIRTY;", "    if (!newfile && db_idx >= 0 && in_left)", "      buf->b_ml.ml_flags |= ML_LOCKED_POS;"], "readability/braces"]
["src/nvim/memline.c", ["", "    /*", "     * flush the old data block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    buf->b_ml.ml_locked_lineadd = 0;", "    ml_find_line(buf, (linenr_T)0, ML_FLUSH);       /* flush data block */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * update pointer blocks for the new data block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    for (stack_idx = buf->b_ml.ml_stack_top - 1; stack_idx >= 0;", "         --stack_idx) {", "      ip = &(buf->b_ml.ml_stack[stack_idx]);"], "readability/increment"]
["src/nvim/memline.c", ["      pb_idx = ip->ip_index;", "      if ((hp = mf_get(mfp, ip->ip_bnum, 1)) == NULL)", "        return FAIL;"], "readability/braces"]
["src/nvim/memline.c", ["        return FAIL;", "      pp = hp->bh_data;         /* must be pointer block */", "      if (pp->pb_id != PTR_ID) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      }", "      /*", "       * TODO: If the pointer block is full and we are adding at the end"], "readability/old_style_comment"]
["src/nvim/memline.c", ["       */", "      /* block not full, add one entry */", "      if (pp->pb_count < pp->pb_count_max) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      if (pp->pb_count < pp->pb_count_max) {", "        if (pb_idx + 1 < (int)pp->pb_count)", "          memmove(&pp->pb_pointer[pb_idx + 2],"], "readability/braces"]
["src/nvim/memline.c", ["          memmove(&pp->pb_pointer[pb_idx + 2],", "              &pp->pb_pointer[pb_idx + 1],", "              (size_t)(pp->pb_count - pb_idx - 1) * sizeof(PTR_EN));"], "whitespace/alignment"]
["src/nvim/memline.c", ["              &pp->pb_pointer[pb_idx + 1],", "              (size_t)(pp->pb_count - pb_idx - 1) * sizeof(PTR_EN));", "        ++pp->pb_count;"], "whitespace/alignment"]
["src/nvim/memline.c", ["              (size_t)(pp->pb_count - pb_idx - 1) * sizeof(PTR_EN));", "        ++pp->pb_count;", "        pp->pb_pointer[pb_idx].pe_line_count = line_count_left;"], "readability/increment"]
["src/nvim/memline.c", ["", "        if (lnum_left != 0)", "          pp->pb_pointer[pb_idx].pe_old_lnum = lnum_left;"], "readability/braces"]
["src/nvim/memline.c", ["          pp->pb_pointer[pb_idx].pe_old_lnum = lnum_left;", "        if (lnum_right != 0)", "          pp->pb_pointer[pb_idx + 1].pe_old_lnum = lnum_right;"], "readability/braces"]
["src/nvim/memline.c", ["        mf_put(mfp, hp, true, false);", "        buf->b_ml.ml_stack_top = stack_idx + 1;             /* truncate stack */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["        if (lineadd) {", "          --(buf->b_ml.ml_stack_top);", "          /* fix line count for rest of blocks in the stack */"], "readability/increment"]
["src/nvim/memline.c", ["          --(buf->b_ml.ml_stack_top);", "          /* fix line count for rest of blocks in the stack */", "          ml_lineadd(buf, lineadd);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["          ml_lineadd(buf, lineadd);", "          /* fix stack itself */", "          buf->b_ml.ml_stack[buf->b_ml.ml_stack_top].ip_high +="], "readability/old_style_comment"]
["src/nvim/memline.c", ["            lineadd;", "          ++(buf->b_ml.ml_stack_top);", "        }"], "readability/increment"]
["src/nvim/memline.c", ["", "        /*", "         * We are finished, break the loop here."], "readability/old_style_comment"]
["src/nvim/memline.c", ["        break;", "      } else {                        /* pointer block full */", "        /*"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      } else {                        /* pointer block full */", "        /*", "         * split the pointer block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["         */", "        for (;; ) {             /* do this twice when splitting block 1 */", "          hp_new = ml_new_ptr(mfp);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["          hp_new = ml_new_ptr(mfp);", "          if (hp_new == NULL)               /* TODO: try to fix tree */", "            return FAIL;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["          hp_new = ml_new_ptr(mfp);", "          if (hp_new == NULL)               /* TODO: try to fix tree */", "            return FAIL;"], "readability/braces"]
["src/nvim/memline.c", ["", "          if (hp->bh_bnum != 1)", "            break;"], "readability/braces"]
["src/nvim/memline.c", ["", "          /*", "           * if block 1 becomes full the tree is given an extra level"], "readability/old_style_comment"]
["src/nvim/memline.c", ["          pp->pb_pointer[0].pe_page_count = 1;", "          mf_put(mfp, hp, true, false);             /* release block 1 */", "          hp = hp_new;                          /* new block is to be split */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["          mf_put(mfp, hp, true, false);             /* release block 1 */", "          hp = hp_new;                          /* new block is to be split */", "          pp = pp_new;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["          ip->ip_index = 0;", "          ++stack_idx;                  /* do block 1 again later */", "        }"], "readability/old_style_comment"]
["src/nvim/memline.c", ["          ip->ip_index = 0;", "          ++stack_idx;                  /* do block 1 again later */", "        }"], "readability/increment"]
["src/nvim/memline.c", ["        }", "        /*", "         * move the pointers after the current one to the new block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["          memmove(&pp_new->pb_pointer[0],", "              &pp->pb_pointer[pb_idx + 1],", "              (size_t)(total_moved) * sizeof(PTR_EN));"], "whitespace/alignment"]
["src/nvim/memline.c", ["              &pp->pb_pointer[pb_idx + 1],", "              (size_t)(total_moved) * sizeof(PTR_EN));", "          pp_new->pb_count = total_moved;"], "whitespace/alignment"]
["src/nvim/memline.c", ["          pp->pb_pointer[pb_idx + 1].pe_page_count = page_count_right;", "          if (lnum_right)", "            pp->pb_pointer[pb_idx + 1].pe_old_lnum = lnum_right;"], "readability/braces"]
["src/nvim/memline.c", ["        pp->pb_pointer[pb_idx].pe_page_count = page_count_left;", "        if (lnum_left)", "          pp->pb_pointer[pb_idx].pe_old_lnum = lnum_left;"], "readability/braces"]
["src/nvim/memline.c", ["", "        /*", "         * recompute line counts"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        line_count_right = 0;", "        for (i = 0; i < (int)pp_new->pb_count; ++i)", "          line_count_right += pp_new->pb_pointer[i].pe_line_count;"], "readability/braces"]
["src/nvim/memline.c", ["        line_count_right = 0;", "        for (i = 0; i < (int)pp_new->pb_count; ++i)", "          line_count_right += pp_new->pb_pointer[i].pe_line_count;"], "readability/increment"]
["src/nvim/memline.c", ["        line_count_left = 0;", "        for (i = 0; i < (int)pp->pb_count; ++i)", "          line_count_left += pp->pb_pointer[i].pe_line_count;"], "readability/braces"]
["src/nvim/memline.c", ["        line_count_left = 0;", "        for (i = 0; i < (int)pp->pb_count; ++i)", "          line_count_left += pp->pb_pointer[i].pe_line_count;"], "readability/increment"]
["src/nvim/memline.c", ["", "    /*", "     * Safety check: fallen out of for loop?"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /* The line was inserted below 'lnum' */", "  ml_updatechunk(buf, lnum + 1, (long)len, ML_CHNK_ADDLINE);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["{", "  if (line == NULL)             /* just checking... */", "    return FAIL;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["{", "  if (line == NULL)             /* just checking... */", "    return FAIL;"], "readability/braces"]
["src/nvim/memline.c", ["  infoptr_T   *ip;", "  int count;                /* number of entries in block */", "  int idx;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (lnum < 1 || lnum > buf->b_ml.ml_line_count)", "    return FAIL;"], "readability/braces"]
["src/nvim/memline.c", ["", "  if (lowest_marked && lowest_marked > lnum)", "    lowest_marked--;"], "readability/braces"]
["src/nvim/memline.c", ["", "  /*", "   * If the file becomes empty the last line is replaced by an empty line."], "readability/old_style_comment"]
["src/nvim/memline.c", ["   */", "  if (buf->b_ml.ml_line_count == 1) {       /* file becomes empty */", "    if (message"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if (buf->b_ml.ml_line_count == 1) {       /* file becomes empty */", "    if (message", "        )"], "readability/braces"]
["src/nvim/memline.c", ["", "  /*", "   * find the data block containing the line"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  mfp = buf->b_ml.ml_mfp;", "  if (mfp == NULL)", "    return FAIL;"], "readability/braces"]
["src/nvim/memline.c", ["", "  if ((hp = ml_find_line(buf, lnum, ML_DELETE)) == NULL)", "    return FAIL;"], "readability/braces"]
["src/nvim/memline.c", ["  dp = hp->bh_data;", "  /* compute line count before the delete */", "  count = (long)(buf->b_ml.ml_locked_high)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  --buf->b_ml.ml_line_count;", ""], "readability/increment"]
["src/nvim/memline.c", ["  line_start = ((dp->db_index[idx]) & DB_INDEX_MASK);", "  if (idx == 0)                 /* first line in block, text at the end */", "    line_size = dp->db_txt_end - line_start;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  line_start = ((dp->db_index[idx]) & DB_INDEX_MASK);", "  if (idx == 0)                 /* first line in block, text at the end */", "    line_size = dp->db_txt_end - line_start;"], "readability/braces"]
["src/nvim/memline.c", ["    line_size = dp->db_txt_end - line_start;", "  else", "    line_size = ((dp->db_index[idx - 1]) & DB_INDEX_MASK) - line_start;"], "readability/braces"]
["src/nvim/memline.c", ["", "  /*", "   * special case: If there is only one line in the data block it becomes empty."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if (count == 1) {", "    mf_free(mfp, hp);           /* free the data block */", "    buf->b_ml.ml_locked = NULL;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    for (stack_idx = buf->b_ml.ml_stack_top - 1; stack_idx >= 0;", "         --stack_idx) {", "      buf->b_ml.ml_stack_top = 0;           /* stack is invalid when failing */"], "readability/increment"]
["src/nvim/memline.c", ["         --stack_idx) {", "      buf->b_ml.ml_stack_top = 0;           /* stack is invalid when failing */", "      ip = &(buf->b_ml.ml_stack[stack_idx]);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      idx = ip->ip_index;", "      if ((hp = mf_get(mfp, ip->ip_bnum, 1)) == NULL)", "        return FAIL;"], "readability/braces"]
["src/nvim/memline.c", ["        return FAIL;", "      pp = hp->bh_data;         /* must be pointer block */", "      if (pp->pb_id != PTR_ID) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      count = --(pp->pb_count);", "      if (count == 0)               /* the pointer block becomes empty! */", "        mf_free(mfp, hp);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      count = --(pp->pb_count);", "      if (count == 0)               /* the pointer block becomes empty! */", "        mf_free(mfp, hp);"], "readability/braces"]
["src/nvim/memline.c", ["        mf_free(mfp, hp);", "      else {", "        if (count != idx)               /* move entries after the deleted one */"], "readability/braces"]
["src/nvim/memline.c", ["        mf_free(mfp, hp);", "      else {", "        if (count != idx)               /* move entries after the deleted one */"], "readability/braces"]
["src/nvim/memline.c", ["      else {", "        if (count != idx)               /* move entries after the deleted one */", "          memmove(&pp->pb_pointer[idx], &pp->pb_pointer[idx + 1],"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      else {", "        if (count != idx)               /* move entries after the deleted one */", "          memmove(&pp->pb_pointer[idx], &pp->pb_pointer[idx + 1],"], "readability/braces"]
["src/nvim/memline.c", ["          memmove(&pp->pb_pointer[idx], &pp->pb_pointer[idx + 1],", "              (size_t)(count - idx) * sizeof(PTR_EN));", "        mf_put(mfp, hp, true, false);"], "whitespace/alignment"]
["src/nvim/memline.c", ["", "        buf->b_ml.ml_stack_top = stack_idx;             /* truncate stack */", "        /* fix line count for rest of blocks in the stack */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        buf->b_ml.ml_stack_top = stack_idx;             /* truncate stack */", "        /* fix line count for rest of blocks in the stack */", "        if (buf->b_ml.ml_locked_lineadd != 0) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        }", "        ++(buf->b_ml.ml_stack_top);", ""], "readability/increment"]
["src/nvim/memline.c", ["  } else {", "    /*", "     * delete the text by moving the next lines forwards"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    memmove((char *)dp + text_start + line_size,", "        (char *)dp + text_start, (size_t)(line_start - text_start));", ""], "whitespace/alignment"]
["src/nvim/memline.c", ["", "    /*", "     * delete the index by moving the next indexes backwards"], "readability/old_style_comment"]
["src/nvim/memline.c", ["     */", "    for (i = idx; i < count - 1; ++i)", "      dp->db_index[i] = dp->db_index[i + 1] + line_size;"], "readability/braces"]
["src/nvim/memline.c", ["     */", "    for (i = idx; i < count - 1; ++i)", "      dp->db_index[i] = dp->db_index[i + 1] + line_size;"], "readability/increment"]
["src/nvim/memline.c", ["    dp->db_txt_start += line_size;", "    --(dp->db_line_count);", ""], "readability/increment"]
["src/nvim/memline.c", ["", "    /*", "     * mark the block dirty and make sure it is in the file (for recovery)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * set the B_MARKED flag for line 'lnum'"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  DATA_BL *dp;", "  /* invalid line number */", "  if (lnum < 1 || lnum > curbuf->b_ml.ml_line_count"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  /* invalid line number */", "  if (lnum < 1 || lnum > curbuf->b_ml.ml_line_count", "      || curbuf->b_ml.ml_mfp == NULL)"], "readability/braces"]
["src/nvim/memline.c", ["      || curbuf->b_ml.ml_mfp == NULL)", "    return;                         /* give error message? */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (lowest_marked == 0 || lowest_marked > lnum)", "    lowest_marked = lnum;"], "readability/braces"]
["src/nvim/memline.c", ["", "  /*", "   * find the data block containing the line"], "readability/old_style_comment"]
["src/nvim/memline.c", ["   */", "  if ((hp = ml_find_line(curbuf, lnum, ML_FIND)) == NULL)", "    return;                 /* give error message? */"], "readability/braces"]
["src/nvim/memline.c", ["  if ((hp = ml_find_line(curbuf, lnum, ML_FIND)) == NULL)", "    return;                 /* give error message? */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * find the first line with its B_MARKED flag set"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (curbuf->b_ml.ml_mfp == NULL)", "    return (linenr_T) 0;"], "readability/braces"]
["src/nvim/memline.c", ["  if (curbuf->b_ml.ml_mfp == NULL)", "    return (linenr_T) 0;", ""], "whitespace/cast"]
["src/nvim/memline.c", ["", "  /*", "   * The search starts with lowest_marked line. This is the last line where"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  for (lnum = lowest_marked; lnum <= curbuf->b_ml.ml_line_count; ) {", "    /*", "     * Find the data block containing the line."], "readability/old_style_comment"]
["src/nvim/memline.c", ["     */", "    if ((hp = ml_find_line(curbuf, lnum, ML_FIND)) == NULL)", "      return (linenr_T)0;                   /* give error message? */"], "readability/braces"]
["src/nvim/memline.c", ["    if ((hp = ml_find_line(curbuf, lnum, ML_FIND)) == NULL)", "      return (linenr_T)0;                   /* give error message? */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    for (i = lnum - curbuf->b_ml.ml_locked_low;", "         lnum <= curbuf->b_ml.ml_locked_high; ++i, ++lnum)"], "readability/braces"]
["src/nvim/memline.c", ["    for (i = lnum - curbuf->b_ml.ml_locked_low;", "         lnum <= curbuf->b_ml.ml_locked_high; ++i, ++lnum)", "      if ((dp->db_index[i]) & DB_MARKED) {"], "readability/increment"]
["src/nvim/memline.c", ["", "  return (linenr_T) 0;", "}"], "whitespace/cast"]
["src/nvim/memline.c", ["", "/*", " * clear all DB_MARKED flags"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (curbuf->b_ml.ml_mfp == NULL)          /* nothing to do */", "    return;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (curbuf->b_ml.ml_mfp == NULL)          /* nothing to do */", "    return;"], "readability/braces"]
["src/nvim/memline.c", ["", "  /*", "   * The search starts with line lowest_marked."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  for (lnum = lowest_marked; lnum <= curbuf->b_ml.ml_line_count; ) {", "    /*", "     * Find the data block containing the line."], "readability/old_style_comment"]
["src/nvim/memline.c", ["     */", "    if ((hp = ml_find_line(curbuf, lnum, ML_FIND)) == NULL)", "      return;                   /* give error message? */"], "readability/braces"]
["src/nvim/memline.c", ["    if ((hp = ml_find_line(curbuf, lnum, ML_FIND)) == NULL)", "      return;                   /* give error message? */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    for (i = lnum - curbuf->b_ml.ml_locked_low;", "         lnum <= curbuf->b_ml.ml_locked_high; ++i, ++lnum)"], "readability/braces"]
["src/nvim/memline.c", ["    for (i = lnum - curbuf->b_ml.ml_locked_low;", "         lnum <= curbuf->b_ml.ml_locked_high; ++i, ++lnum)", "      if ((dp->db_index[i]) & DB_MARKED) {"], "readability/increment"]
["src/nvim/memline.c", ["", "/*", " * flush ml_line if necessary"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  int i;", "  static int entered = FALSE;", ""], "readability/bool"]
["src/nvim/memline.c", ["", "  if (buf->b_ml.ml_line_lnum == 0 || buf->b_ml.ml_mfp == NULL)", "    return;             /* nothing to do */"], "readability/braces"]
["src/nvim/memline.c", ["  if (buf->b_ml.ml_line_lnum == 0 || buf->b_ml.ml_mfp == NULL)", "    return;             /* nothing to do */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if (buf->b_ml.ml_flags & ML_LINE_DIRTY) {", "    /* This code doesn't work recursively. */", "    if (entered)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    /* This code doesn't work recursively. */", "    if (entered)", "      return;"], "readability/braces"]
["src/nvim/memline.c", ["      return;", "    entered = TRUE;", ""], "readability/bool"]
["src/nvim/memline.c", ["      old_line = (char_u *)dp + start;", "      if (idx == 0)             /* line is last in block */", "        old_len = dp->db_txt_end - start;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      old_line = (char_u *)dp + start;", "      if (idx == 0)             /* line is last in block */", "        old_len = dp->db_txt_end - start;"], "readability/braces"]
["src/nvim/memline.c", ["        old_len = dp->db_txt_end - start;", "      else                      /* text of previous line follows */", "        old_len = (dp->db_index[idx - 1] & DB_INDEX_MASK) - start;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        old_len = dp->db_txt_end - start;", "      else                      /* text of previous line follows */", "        old_len = (dp->db_index[idx - 1] & DB_INDEX_MASK) - start;"], "readability/braces"]
["src/nvim/memline.c", ["      new_len = (colnr_T)STRLEN(new_line) + 1;", "      extra = new_len - old_len;            /* negative if lines gets smaller */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "      /*", "       * if new line fits in data block, replace directly"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      if ((int)dp->db_free >= extra) {", "        /* if the length changes and there are following lines */", "        count = buf->b_ml.ml_locked_high - buf->b_ml.ml_locked_low + 1;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        if (extra != 0 && idx < count - 1) {", "          /* move text of following lines */", "          memmove((char *)dp + dp->db_txt_start - extra,"], "readability/old_style_comment"]
["src/nvim/memline.c", ["          memmove((char *)dp + dp->db_txt_start - extra,", "              (char *)dp + dp->db_txt_start,", "              (size_t)(start - dp->db_txt_start));"], "whitespace/alignment"]
["src/nvim/memline.c", ["              (char *)dp + dp->db_txt_start,", "              (size_t)(start - dp->db_txt_start));", ""], "whitespace/alignment"]
["src/nvim/memline.c", ["", "          /* adjust pointers of this and following lines */", "          for (i = idx + 1; i < count; ++i)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["          /* adjust pointers of this and following lines */", "          for (i = idx + 1; i < count; ++i)", "            dp->db_index[i] -= extra;"], "readability/braces"]
["src/nvim/memline.c", ["          /* adjust pointers of this and following lines */", "          for (i = idx + 1; i < count; ++i)", "            dp->db_index[i] -= extra;"], "readability/increment"]
["src/nvim/memline.c", ["", "        /* adjust free space */", "        dp->db_free -= extra;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "        /* copy new line into the data block */", "        memmove(old_line - extra, new_line, (size_t)new_len);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        buf->b_ml.ml_flags |= (ML_LOCKED_DIRTY | ML_LOCKED_POS);", "        /* The else case is already covered by the insert and delete */", "        ml_updatechunk(buf, lnum, (long)extra, ML_CHNK_UPDLINE);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    entered = FALSE;", "  }"], "readability/bool"]
["src/nvim/memline.c", ["", "/*", " * create a new, empty, data block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * create a new, empty, pointer block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * lookup line 'lnum' in a memline"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * If there is a locked block check if the wanted line is in it."], "readability/old_style_comment"]
["src/nvim/memline.c", ["      if (action == ML_INSERT) {", "        ++(buf->b_ml.ml_locked_lineadd);", "        ++(buf->b_ml.ml_locked_high);"], "readability/increment"]
["src/nvim/memline.c", ["        ++(buf->b_ml.ml_locked_lineadd);", "        ++(buf->b_ml.ml_locked_high);", "      } else if (action == ML_DELETE) {"], "readability/increment"]
["src/nvim/memline.c", ["      } else if (action == ML_DELETE) {", "        --(buf->b_ml.ml_locked_lineadd);", "        --(buf->b_ml.ml_locked_high);"], "readability/increment"]
["src/nvim/memline.c", ["        --(buf->b_ml.ml_locked_lineadd);", "        --(buf->b_ml.ml_locked_high);", "      }"], "readability/increment"]
["src/nvim/memline.c", ["    mf_put(mfp, buf->b_ml.ml_locked, buf->b_ml.ml_flags & ML_LOCKED_DIRTY,", "        buf->b_ml.ml_flags & ML_LOCKED_POS);", "    buf->b_ml.ml_locked = NULL;"], "whitespace/alignment"]
["src/nvim/memline.c", ["", "    /*", "     * If lines have been added or deleted in the locked block, need to"], "readability/old_style_comment"]
["src/nvim/memline.c", ["     */", "    if (buf->b_ml.ml_locked_lineadd != 0)", "      ml_lineadd(buf, buf->b_ml.ml_locked_lineadd);"], "readability/braces"]
["src/nvim/memline.c", ["", "  if (action == ML_FLUSH)           /* nothing else to do */", "    return NULL;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (action == ML_FLUSH)           /* nothing else to do */", "    return NULL;"], "readability/braces"]
["src/nvim/memline.c", ["", "  bnum = 1;                         /* start at the root of the tree */", "  page_count = 1;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (action == ML_FIND) {      /* first try stack entries */", "    for (top = buf->b_ml.ml_stack_top - 1; top >= 0; --top) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if (action == ML_FIND) {      /* first try stack entries */", "    for (top = buf->b_ml.ml_stack_top - 1; top >= 0; --top) {", "      ip = &(buf->b_ml.ml_stack[top]);"], "readability/increment"]
["src/nvim/memline.c", ["        high = ip->ip_high;", "        buf->b_ml.ml_stack_top = top;           /* truncate stack at prev entry */", "        break;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        high = ip->ip_high;", "        buf->b_ml.ml_stack_top = top;           /* truncate stack at prev entry */", "        break;"], "whitespace/line_length"]
["src/nvim/memline.c", ["    }", "    if (top < 0)", "      buf->b_ml.ml_stack_top = 0;               /* not found, start at the root */"], "readability/braces"]
["src/nvim/memline.c", ["    if (top < 0)", "      buf->b_ml.ml_stack_top = 0;               /* not found, start at the root */", "  } else        /* ML_DELETE or ML_INSERT */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (top < 0)", "      buf->b_ml.ml_stack_top = 0;               /* not found, start at the root */", "  } else        /* ML_DELETE or ML_INSERT */"], "whitespace/line_length"]
["src/nvim/memline.c", ["      buf->b_ml.ml_stack_top = 0;               /* not found, start at the root */", "  } else        /* ML_DELETE or ML_INSERT */", "    buf->b_ml.ml_stack_top = 0;         /* start at the root */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      buf->b_ml.ml_stack_top = 0;               /* not found, start at the root */", "  } else        /* ML_DELETE or ML_INSERT */", "    buf->b_ml.ml_stack_top = 0;         /* start at the root */"], "readability/braces"]
["src/nvim/memline.c", ["  } else        /* ML_DELETE or ML_INSERT */", "    buf->b_ml.ml_stack_top = 0;         /* start at the root */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * search downwards in the tree until a data block is found"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  for (;; ) {", "    if ((hp = mf_get(mfp, bnum, page_count)) == NULL)", "      goto error_noblock;"], "readability/braces"]
["src/nvim/memline.c", ["", "    /*", "     * update high for insert/delete"], "readability/old_style_comment"]
["src/nvim/memline.c", ["     */", "    if (action == ML_INSERT)", "      ++high;"], "readability/braces"]
["src/nvim/memline.c", ["    if (action == ML_INSERT)", "      ++high;", "    else if (action == ML_DELETE)"], "readability/increment"]
["src/nvim/memline.c", ["      ++high;", "    else if (action == ML_DELETE)", "      --high;"], "readability/braces"]
["src/nvim/memline.c", ["    else if (action == ML_DELETE)", "      --high;", ""], "readability/increment"]
["src/nvim/memline.c", ["    dp = hp->bh_data;", "    if (dp->db_id == DATA_ID) {         /* data block */", "      buf->b_ml.ml_locked = hp;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    pp = (PTR_BL *)(dp);                /* must be pointer block */", "    if (pp->pb_id != PTR_ID) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    ip->ip_high = high;", "    ip->ip_index = -1;                  /* index not known yet */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    dirty = FALSE;", "    for (idx = 0; idx < (int)pp->pb_count; ++idx) {"], "readability/bool"]
["src/nvim/memline.c", ["    dirty = FALSE;", "    for (idx = 0; idx < (int)pp->pb_count; ++idx) {", "      t = pp->pb_pointer[idx].pe_line_count;"], "readability/increment"]
["src/nvim/memline.c", ["", "        /*", "         * a negative block number may have been changed"], "readability/old_style_comment"]
["src/nvim/memline.c", ["            pp->pb_pointer[idx].pe_bnum = bnum;", "            dirty = TRUE;", "          }"], "readability/bool"]
["src/nvim/memline.c", ["      pp->pb_pointer[idx].pe_line_count--;", "      dirty = TRUE;", "    } else if (action == ML_INSERT) {"], "readability/bool"]
["src/nvim/memline.c", ["      pp->pb_pointer[idx].pe_line_count++;", "      dirty = TRUE;", "    }"], "readability/bool"]
["src/nvim/memline.c", ["error_noblock:", "  /*", "   * If action is ML_DELETE or ML_INSERT we have to correct the tree for"], "readability/old_style_comment"]
["src/nvim/memline.c", ["   */", "  if (action == ML_DELETE)", "    ml_lineadd(buf, 1);"], "readability/braces"]
["src/nvim/memline.c", ["    ml_lineadd(buf, 1);", "  else if (action == ML_INSERT)", "    ml_lineadd(buf, -1);"], "readability/braces"]
["src/nvim/memline.c", ["", "/*", " * add an entry to the info pointer stack"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /* may have to increase the stack size */", "  if (top == buf->b_ml.ml_stack_size) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if (top == buf->b_ml.ml_stack_size) {", "    CHECK(top > 0, _(\"Stack size increases\"));     /* more than 5 levels??? */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Update the pointer blocks on the stack for inserted/deleted lines."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  for (idx = buf->b_ml.ml_stack_top - 1; idx >= 0; --idx) {", "    ip = &(buf->b_ml.ml_stack[idx]);"], "readability/increment"]
["src/nvim/memline.c", ["    ip = &(buf->b_ml.ml_stack[idx]);", "    if ((hp = mf_get(mfp, ip->ip_bnum, 1)) == NULL)", "      break;"], "readability/braces"]
["src/nvim/memline.c", ["      break;", "    pp = hp->bh_data;       /* must be pointer block */", "    if (pp->pb_id != PTR_ID) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#if defined(HAVE_READLINK)", "/*", " * Resolve a symlink in the last component of a file name."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (fname == NULL)", "    return FAIL;"], "readability/braces"]
["src/nvim/memline.c", ["", "  /* Put the result so far in tmp[], starting with the original name. */", "  STRLCPY(tmp, fname, MAXPATHL);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  for (;; ) {", "    /* Limit symlink depth to 100, catch recursive loops. */", "    if (++depth == 100) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      if (errno == EINVAL || errno == ENOENT) {", "        /* Found non-symlink or not existing file, stop here.", "         * When at the first level use the unmodified name, skip the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["         * call to vim_FullName(). */", "        if (depth == 1)", "          return FAIL;"], "readability/braces"]
["src/nvim/memline.c", ["", "        /* Use the resolved name in tmp[]. */", "        break;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "      /* There must be some error reading links, use original name. */", "      return FAIL;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Try to resolve the full name of the file so that the swapfile name will"], "readability/old_style_comment"]
["src/nvim/memline.c", ["   */", "  return vim_FullName((char *)tmp, (char *)buf, MAXPATHL, TRUE);", "}"], "readability/bool"]
["src/nvim/memline.c", ["", "/*", " * Make swap file name out of the file name and a directory name."], "readability/old_style_comment"]
["src/nvim/memline.c", [" */", "char_u *makeswapname(char_u *fname, char_u *ffname, buf_T *buf, char_u *dir_name)", "{"], "whitespace/line_length"]
["src/nvim/memline.c", ["  r = (char_u *)modname((char *)fname_res, \".swp\",", "              dir_name[0] == '.' && dir_name[1] == NUL);", "  if (r == NULL)            /* out of memory */"], "whitespace/alignment"]
["src/nvim/memline.c", ["              dir_name[0] == '.' && dir_name[1] == NUL);", "  if (r == NULL)            /* out of memory */", "    return NULL;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["              dir_name[0] == '.' && dir_name[1] == NUL);", "  if (r == NULL)            /* out of memory */", "    return NULL;"], "readability/braces"]
["src/nvim/memline.c", ["", "/*", " * Get file name to use for swap file or backup file."], "readability/old_style_comment"]
["src/nvim/memline.c", ["char_u *", "get_file_in_dir (", "    char_u *fname,"], "whitespace/parens"]
["src/nvim/memline.c", ["    char_u *fname,", "    char_u *dname         /* don't use \"dirname\", it is a global for Alpha */", ")"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (dname[0] == '.' && dname[1] == NUL)", "    retval = vim_strsave(fname);"], "readability/braces"]
["src/nvim/memline.c", ["    retval = vim_strsave(fname);", "  else if (dname[0] == '.' && vim_ispathsep(dname[1])) {", "    if (tail == fname)              /* no path before file name */"], "readability/braces"]
["src/nvim/memline.c", ["  else if (dname[0] == '.' && vim_ispathsep(dname[1])) {", "    if (tail == fname)              /* no path before file name */", "      retval = (char_u *)concat_fnames((char *)dname + 2, (char *)tail, TRUE);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  else if (dname[0] == '.' && vim_ispathsep(dname[1])) {", "    if (tail == fname)              /* no path before file name */", "      retval = (char_u *)concat_fnames((char *)dname + 2, (char *)tail, TRUE);"], "readability/braces"]
["src/nvim/memline.c", ["    if (tail == fname)              /* no path before file name */", "      retval = (char_u *)concat_fnames((char *)dname + 2, (char *)tail, TRUE);", "    else {"], "readability/bool"]
["src/nvim/memline.c", ["      retval = (char_u *)concat_fnames((char *)dname + 2, (char *)tail, TRUE);", "    else {", "      save_char = *tail;"], "readability/braces"]
["src/nvim/memline.c", ["      retval = (char_u *)concat_fnames((char *)dname + 2, (char *)tail, TRUE);", "    else {", "      save_char = *tail;"], "readability/braces"]
["src/nvim/memline.c", ["      *tail = NUL;", "      t = (char_u *)concat_fnames((char *)fname, (char *)dname + 2, TRUE);", "      *tail = save_char;"], "readability/bool"]
["src/nvim/memline.c", ["      *tail = save_char;", "      retval = (char_u *)concat_fnames((char *)t, (char *)tail, TRUE);", "      xfree(t);"], "readability/bool"]
["src/nvim/memline.c", ["  } else {", "    retval = (char_u *)concat_fnames((char *)dname, (char *)tail, TRUE);", "  }"], "readability/bool"]
["src/nvim/memline.c", ["", "/*", " * Print the ATTENTION message: info about an existing swap file."], "readability/old_style_comment"]
["src/nvim/memline.c", [" */", "static void ", "attention_message ("], "whitespace/end_of_line"]
["src/nvim/memline.c", ["static void ", "attention_message (", "    buf_T *buf,           /* buffer being edited */"], "whitespace/parens"]
["src/nvim/memline.c", ["attention_message (", "    buf_T *buf,           /* buffer being edited */", "    char_u *fname         /* swap file name */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    buf_T *buf,           /* buffer being edited */", "    char_u *fname         /* swap file name */", ")"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  ++no_wait_return;", "  (void)EMSG(_(\"E325: ATTENTION\"));"], "readability/increment"]
["src/nvim/memline.c", ["  }", "  /* Some of these messages are long to allow translation to", "   * other languages. */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  cmdline_row = msg_row;", "  --no_wait_return;", "}"], "readability/increment"]
["src/nvim/memline.c", ["", "/*", " * Trigger the SwapExists autocommands."], "readability/old_style_comment"]
["src/nvim/memline.c", ["{", "  set_vim_var_string(VV_SWAPNAME, (char *) fname, -1);", "  set_vim_var_string(VV_SWAPCHOICE, NULL, -1);"], "whitespace/cast"]
["src/nvim/memline.c", ["", "  /* Trigger SwapExists autocommands with <afile> set to the file being", "   * edited.  Disallow changing directory here. */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["   * edited.  Disallow changing directory here. */", "  ++allbuf_lock;", "  apply_autocmds(EVENT_SWAPEXISTS, buf->b_fname, NULL, FALSE, NULL);"], "readability/increment"]
["src/nvim/memline.c", ["  ++allbuf_lock;", "  apply_autocmds(EVENT_SWAPEXISTS, buf->b_fname, NULL, FALSE, NULL);", "  --allbuf_lock;"], "readability/bool"]
["src/nvim/memline.c", ["  apply_autocmds(EVENT_SWAPEXISTS, buf->b_fname, NULL, FALSE, NULL);", "  --allbuf_lock;", ""], "readability/increment"]
["src/nvim/memline.c", ["  char *dir_name;", "  char *buf_fname = (char *) buf->b_fname;", ""], "whitespace/cast"]
["src/nvim/memline.c", ["", "  /*", "   * Isolate a directory name from *dirp and put it in dir_name."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  dir_name = xmalloc(dir_len);", "  (void)copy_option_part((char_u **) dirp, (char_u *) dir_name, dir_len, \",\");", ""], "whitespace/cast"]
["src/nvim/memline.c", ["", "  /*", "   * we try different names until we find one that does not exist yet"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        struct block0 b0;", "        int differ = FALSE;", ""], "readability/bool"]
["src/nvim/memline.c", ["                if (fnamecmp_ino(buf->b_ffname, NameBuff,", "                    char_to_long(b0.b0_ino))) {", "                  differ = TRUE;"], "whitespace/alignment"]
["src/nvim/memline.c", ["                    char_to_long(b0.b0_ino))) {", "                  differ = TRUE;", "                }"], "readability/bool"]
["src/nvim/memline.c", ["              if (fnamecmp_ino(buf->b_ffname, NameBuff,", "                  char_to_long(b0.b0_ino))) {", "                differ = TRUE;"], "whitespace/alignment"]
["src/nvim/memline.c", ["                  char_to_long(b0.b0_ino))) {", "                differ = TRUE;", "              }"], "readability/bool"]
["src/nvim/memline.c", ["            case 1:", "              buf->b_p_ro = TRUE;", "              break;"], "readability/bool"]
["src/nvim/memline.c", ["              swap_exists_action = SEA_QUIT;", "              got_int = TRUE;", "              break;"], "readability/bool"]
["src/nvim/memline.c", ["            MSG_PUTS(\"\\n\");", "            if (msg_silent == 0)", "              /* call wait_return() later */"], "readability/braces"]
["src/nvim/memline.c", ["            if (msg_silent == 0)", "              /* call wait_return() later */", "              need_wait_return = TRUE;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["              /* call wait_return() later */", "              need_wait_return = TRUE;", "          }"], "readability/bool"]
["src/nvim/memline.c", ["          }", "", "        }"], "whitespace/blank_line"]
["src/nvim/memline.c", ["", "    /*", "     * Change the \".swp\" extension to find another file that can be used."], "readability/old_style_comment"]
["src/nvim/memline.c", ["     */", "    if (fname[n - 1] == 'a') {          /* \".s?a\" */", "      if (fname[n - 2] == 'a') {        /* \".saa\": tried enough, give up */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (fname[n - 1] == 'a') {          /* \".s?a\" */", "      if (fname[n - 2] == 'a') {        /* \".saa\": tried enough, give up */", "        EMSG(_(\"E326: Too many swap files found\"));"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      }", "      --fname[n - 2];                   /* \".svz\", \".suz\", etc. */", "      fname[n - 1] = 'z' + 1;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      }", "      --fname[n - 2];                   /* \".svz\", \".suz\", etc. */", "      fname[n - 1] = 'z' + 1;"], "readability/increment"]
["src/nvim/memline.c", ["    }", "    --fname[n - 1];                     /* \".swo\", \".swn\", etc. */", "  }"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    }", "    --fname[n - 1];                     /* \".swo\", \".swn\", etc. */", "  }"], "readability/increment"]
["src/nvim/memline.c", ["", "  if (os_isdir((char_u *) dir_name)) {", "    *found_existing_dir = true;"], "whitespace/cast"]
["src/nvim/memline.c", ["         || b0p->b0_magic_int != (int)B0_MAGIC_INT", "         || b0p->b0_magic_short != (short)B0_MAGIC_SHORT", "         || b0p->b0_magic_char != B0_MAGIC_CHAR;"], "runtime/int"]
["src/nvim/memline.c", ["", "/*", " * Compare current file name with file name from swap file."], "readability/old_style_comment"]
["src/nvim/memline.c", ["{", "  uint64_t ino_c = 0;               /* ino of current file */", "  uint64_t ino_s;                   /* ino of file from swap file */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  uint64_t ino_c = 0;               /* ino of current file */", "  uint64_t ino_s;                   /* ino of file from swap file */", "  char_u buf_c[MAXPATHL];           /* full path of fname_c */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  uint64_t ino_s;                   /* ino of file from swap file */", "  char_u buf_c[MAXPATHL];           /* full path of fname_c */", "  char_u buf_s[MAXPATHL];           /* full path of fname_s */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  char_u buf_c[MAXPATHL];           /* full path of fname_c */", "  char_u buf_s[MAXPATHL];           /* full path of fname_s */", "  int retval_c;                     /* flag: buf_c valid */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  char_u buf_s[MAXPATHL];           /* full path of fname_s */", "  int retval_c;                     /* flag: buf_c valid */", "  int retval_s;                     /* flag: buf_s valid */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  int retval_c;                     /* flag: buf_c valid */", "  int retval_s;                     /* flag: buf_s valid */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * First we try to get the inode from the file name, because the inode in"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (ino_c && ino_s)", "    return ino_c != ino_s;"], "readability/braces"]
["src/nvim/memline.c", ["", "  /*", "   * One of the inode numbers is unknown, try a forced vim_FullName() and"], "readability/old_style_comment"]
["src/nvim/memline.c", ["   */", "  retval_c = vim_FullName((char *)fname_c, (char *)buf_c, MAXPATHL, TRUE);", "  retval_s = vim_FullName((char *)fname_s, (char *)buf_s, MAXPATHL, TRUE);"], "readability/bool"]
["src/nvim/memline.c", ["  retval_c = vim_FullName((char *)fname_c, (char *)buf_c, MAXPATHL, TRUE);", "  retval_s = vim_FullName((char *)fname_s, (char *)buf_s, MAXPATHL, TRUE);", "  if (retval_c == OK && retval_s == OK)"], "readability/bool"]
["src/nvim/memline.c", ["  retval_s = vim_FullName((char *)fname_s, (char *)buf_s, MAXPATHL, TRUE);", "  if (retval_c == OK && retval_s == OK)", "    return STRCMP(buf_c, buf_s) != 0;"], "readability/braces"]
["src/nvim/memline.c", ["", "  /*", "   * Can't compare inodes or file names, guess that the files are different,"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Move a long integer into a four byte character array."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Set the flags in the first block of the swap file:"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (!buf->b_ml.ml_mfp)", "    return;"], "readability/braces"]
["src/nvim/memline.c", ["", "#define MLCS_MAXL 800   /* max no of lines in chunk */", "#define MLCS_MINL 400   /* should be half of MLCS_MAXL */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define MLCS_MAXL 800   /* max no of lines in chunk */", "#define MLCS_MINL 400   /* should be half of MLCS_MAXL */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Keep information for finding byte offset of a line, updtype may be one of:"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (buf->b_ml.ml_usedchunks == -1 || len == 0)", "    return;"], "readability/braces"]
["src/nvim/memline.c", ["  if (updtype == ML_CHNK_UPDLINE && buf->b_ml.ml_line_count == 1) {", "    /*", "     * First line in empty buffer from ml_flush_line() -- reset"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Find chunk that our line belongs to, curline will be at start of the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["         curix < buf->b_ml.ml_usedchunks - 1", "                 && line >= curline +", "                             buf->b_ml.ml_chunksize[curix].mlcs_numlines;"], "whitespace/alignment"]
["src/nvim/memline.c", ["                 && line >= curline +", "                             buf->b_ml.ml_chunksize[curix].mlcs_numlines;", "         curix++) {"], "whitespace/alignment"]
["src/nvim/memline.c", ["", "  if (updtype == ML_CHNK_DELLINE)", "    len = -len;"], "readability/braces"]
["src/nvim/memline.c", ["", "    /* May resize here so we don't have to do it in both cases below */", "    if (buf->b_ml.ml_usedchunks + 1 >= buf->b_ml.ml_numchunks) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (buf->b_ml.ml_chunksize[curix].mlcs_numlines >= MLCS_MAXL) {", "      int count;                    /* number of entries in block */", "      int idx;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      memmove(buf->b_ml.ml_chunksize + curix + 1,", "          buf->b_ml.ml_chunksize + curix,", "          (buf->b_ml.ml_usedchunks - curix) *"], "whitespace/alignment"]
["src/nvim/memline.c", ["          buf->b_ml.ml_chunksize + curix,", "          (buf->b_ml.ml_usedchunks - curix) *", "          sizeof(chunksize_T));"], "whitespace/alignment"]
["src/nvim/memline.c", ["          (buf->b_ml.ml_usedchunks - curix) *", "          sizeof(chunksize_T));", "      /* Compute length of first half of lines in the split chunk */"], "whitespace/alignment"]
["src/nvim/memline.c", ["          sizeof(chunksize_T));", "      /* Compute length of first half of lines in the split chunk */", "      size = 0;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        curline = buf->b_ml.ml_locked_high + 1;", "        if (idx == 0)        /* first line in block, text at the end */", "          text_end = dp->db_txt_end;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        curline = buf->b_ml.ml_locked_high + 1;", "        if (idx == 0)        /* first line in block, text at the end */", "          text_end = dp->db_txt_end;"], "readability/braces"]
["src/nvim/memline.c", ["          text_end = dp->db_txt_end;", "        else", "          text_end = ((dp->db_index[idx - 1]) & DB_INDEX_MASK);"], "readability/braces"]
["src/nvim/memline.c", ["          text_end = ((dp->db_index[idx - 1]) & DB_INDEX_MASK);", "        /* Compute index of last line to use in this MEMLINE */", "        rest = count - idx;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      buf->b_ml.ml_usedchunks++;", "      ml_upd_lastbuf = NULL;         /* Force recalc of curix & curline */", "      return;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["               && buf->b_ml.ml_line_count - line <= 1) {", "      /*", "       * We are in the last chunk and it is cheap to crate a new one"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      } else {", "        /*", "         * Line is just prior to last, move count for last"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        dp = hp->bh_data;", "        if (dp->db_line_count == 1)", "          rest = dp->db_txt_end - dp->db_txt_start;"], "readability/braces"]
["src/nvim/memline.c", ["          rest = dp->db_txt_end - dp->db_txt_start;", "        else", "          rest ="], "readability/braces"]
["src/nvim/memline.c", ["    curchnk->mlcs_numlines--;", "    ml_upd_lastbuf = NULL;       /* Force recalc of curix & curline */", "    if (curix < (buf->b_ml.ml_usedchunks - 1)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      memmove(buf->b_ml.ml_chunksize, buf->b_ml.ml_chunksize + 1,", "          buf->b_ml.ml_usedchunks * sizeof(chunksize_T));", "      return;"], "whitespace/alignment"]
["src/nvim/memline.c", ["", "    /* Collapse chunks */", "    curchnk[-1].mlcs_numlines += curchnk->mlcs_numlines;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      memmove(buf->b_ml.ml_chunksize + curix,", "          buf->b_ml.ml_chunksize + curix + 1,", "          (buf->b_ml.ml_usedchunks - curix) *"], "whitespace/alignment"]
["src/nvim/memline.c", ["          buf->b_ml.ml_chunksize + curix + 1,", "          (buf->b_ml.ml_usedchunks - curix) *", "          sizeof(chunksize_T));"], "whitespace/alignment"]
["src/nvim/memline.c", ["          (buf->b_ml.ml_usedchunks - curix) *", "          sizeof(chunksize_T));", "    }"], "whitespace/alignment"]
["src/nvim/memline.c", ["  DATA_BL     *dp;", "  int count;                    /* number of entries in block */", "  int idx;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (buf->b_ml.ml_usedchunks == -1", "      || buf->b_ml.ml_chunksize == NULL"], "readability/braces"]
["src/nvim/memline.c", ["", "  if (offp == NULL)", "    offset = 0;"], "readability/braces"]
["src/nvim/memline.c", ["    offset = 0;", "  else", "    offset = *offp;"], "readability/braces"]
["src/nvim/memline.c", ["    offset = *offp;", "  if (lnum == 0 && offset <= 0)", "    return 1;       /* Not a \"find offset\" and offset 0 _must_ be in line 1 */"], "readability/braces"]
["src/nvim/memline.c", ["  if (lnum == 0 && offset <= 0)", "    return 1;       /* Not a \"find offset\" and offset 0 _must_ be in line 1 */", "  /*"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    return 1;       /* Not a \"find offset\" and offset 0 _must_ be in line 1 */", "  /*", "   * Find the last chunk before the one containing our line. Last chunk is"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    size += buf->b_ml.ml_chunksize[curix].mlcs_totalsize;", "    if (offset && ffdos)", "      size += buf->b_ml.ml_chunksize[curix].mlcs_numlines;"], "readability/braces"]
["src/nvim/memline.c", ["  while ((lnum != 0 && curline < lnum) || (offset != 0 && size < offset)) {", "    if (curline > buf->b_ml.ml_line_count", "        || (hp = ml_find_line(buf, curline, ML_FIND)) == NULL)"], "readability/braces"]
["src/nvim/memline.c", ["    start_idx = idx = curline - buf->b_ml.ml_locked_low;", "    if (idx == 0)    /* first line in block, text at the end */", "      text_end = dp->db_txt_end;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    start_idx = idx = curline - buf->b_ml.ml_locked_low;", "    if (idx == 0)    /* first line in block, text at the end */", "      text_end = dp->db_txt_end;"], "readability/braces"]
["src/nvim/memline.c", ["      text_end = dp->db_txt_end;", "    else", "      text_end = ((dp->db_index[idx - 1]) & DB_INDEX_MASK);"], "readability/braces"]
["src/nvim/memline.c", ["      text_end = ((dp->db_index[idx - 1]) & DB_INDEX_MASK);", "    /* Compute index of last line to use in this MEMLINE */", "    if (lnum != 0) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (lnum != 0) {", "      if (curline + (count - idx) >= lnum)", "        idx += lnum - curline - 1;"], "readability/braces"]
["src/nvim/memline.c", ["        idx += lnum - curline - 1;", "      else", "        idx = count - 1;"], "readability/braces"]
["src/nvim/memline.c", ["             + ffdos) {", "        if (ffdos)", "          size++;"], "readability/braces"]
["src/nvim/memline.c", ["    if (offset != 0 && size >= offset) {", "      if (size + ffdos == offset)", "        *offp = 0;"], "readability/braces"]
["src/nvim/memline.c", ["        *offp = 0;", "      else if (idx == start_idx)", "        *offp = offset - size + len;"], "readability/braces"]
["src/nvim/memline.c", ["        *offp = offset - size + len;", "      else", "        *offp = offset - size + len"], "readability/braces"]
["src/nvim/memline.c", ["      curline += idx - start_idx + extra;", "      if (curline > buf->b_ml.ml_line_count)", "        return -1;              /* exactly one byte beyond the end */"], "readability/braces"]
["src/nvim/memline.c", ["      if (curline > buf->b_ml.ml_line_count)", "        return -1;              /* exactly one byte beyond the end */", "      return curline;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if (lnum != 0) {", "    /* Count extra CR characters. */", "    if (ffdos)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    /* Count extra CR characters. */", "    if (ffdos)", "      size += lnum - 1;"], "readability/braces"]
["src/nvim/memline.c", ["", "    /* Don't count the last line break if 'noeol' and ('bin' or", "     * 'nofixeol'). */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    curwin->w_cursor.coladd = 0;", "    curwin->w_set_curswant = TRUE;", "  }"], "readability/bool"]
["src/nvim/memline.h", ["#include \"nvim/types.h\"", "#include \"nvim/pos.h\" // for pos_T, linenr_T, colnr_T", "#include \"nvim/buffer_defs.h\" // for buf_T"], "whitespace/comments"]
["src/nvim/memline.h", ["#include \"nvim/pos.h\" // for pos_T, linenr_T, colnr_T", "#include \"nvim/buffer_defs.h\" // for buf_T", ""], "whitespace/comments"]
["src/nvim/memline_defs.h", ["", "#endif // NVIM_MEMLINE_DEFS_H", ""], "build/header_guard"]
["src/nvim/memline_defs.h", ["", "#endif // NVIM_MEMLINE_DEFS_H", ""], "whitespace/comments"]
["src/nvim/memory.c", ["", " // Various routines dealing with allocation and deallocation of memory.", ""], "whitespace/indent"]
["src/nvim/memory.c", ["  // avoid recursive calls", "  if (trying_to_free)", "    return;"], "readability/braces"]
["src/nvim/memory.c", ["  void *ret = xmalloc(total_size);", "  ((char*)ret)[size] = 0;", ""], "whitespace/operators"]
["src/nvim/memory.c", ["    if (((uint8_t *)src)[len] == c) {", "      return (uint8_t *) src + len;", "    }"], "whitespace/cast"]
["src/nvim/memory.c", ["", "/*", " * Avoid repeating the error message many times (they take 1 second each)."], "readability/old_style_comment"]
["src/nvim/memory.c", ["  if (!did_outofmem_msg) {", "    /* Don't hide this message */", "    emsg_silent = 0;"], "readability/old_style_comment"]
["src/nvim/memory.c", ["", "    /* Must come first to avoid coming back here when printing the error", "     * message fails, e.g. when setting v:errmsg. */"], "readability/old_style_comment"]
["src/nvim/memory.c", ["", "/*", " * Free everything that we allocated."], "readability/old_style_comment"]
["src/nvim/memory.c", ["", "  /* Close all tabs and windows.  Reset 'equalalways' to avoid redraws. */", "  p_ea = false;"], "readability/old_style_comment"]
["src/nvim/memory.c", ["  p_ea = false;", "  if (first_tabpage->tp_next != NULL)", "    do_cmdline_cmd(\"tabonly!\");"], "readability/braces"]
["src/nvim/memory.c", ["", "  /* Free all spell info. */", "  spell_free_all();"], "readability/old_style_comment"]
["src/nvim/memory.c", ["", "  /* Clear user commands (before deleting buffers). */", "  ex_comclear(NULL);"], "readability/old_style_comment"]
["src/nvim/memory.c", ["", "  /* Clear menus. */", "  do_cmdline_cmd(\"aunmenu *\");"], "readability/old_style_comment"]
["src/nvim/memory.c", ["", "  /* Clear mappings, abbreviations, breakpoints. */", "  do_cmdline_cmd(\"lmapclear\");"], "readability/old_style_comment"]
["src/nvim/memory.c", ["", "  /* Obviously named calls. */", "  free_all_autocmds();"], "readability/old_style_comment"]
["src/nvim/memory.c", ["", "  /* Free some global vars. */", "  xfree(last_cmdline);"], "readability/old_style_comment"]
["src/nvim/memory.c", ["", "  /* Clear cmdline history. */", "  p_hi = 0;"], "readability/old_style_comment"]
["src/nvim/memory.c", ["  qf_free_all(NULL);", "  /* Free all location lists */", "  FOR_ALL_TAB_WINDOWS(tab, win) {"], "readability/old_style_comment"]
["src/nvim/memory.c", ["", "  /* Close all script inputs. */", "  close_all_scripts();"], "readability/old_style_comment"]
["src/nvim/memory.c", ["", "  /* Destroy all windows.  Must come before freeing buffers. */", "  win_free_all();"], "readability/old_style_comment"]
["src/nvim/memory.c", ["", "  /* Clear registers. */", "  clear_registers();"], "readability/old_style_comment"]
["src/nvim/memory.c", ["", "  /* highlight info */", "  free_highlight();"], "readability/old_style_comment"]
["src/nvim/memory.c", ["", "  /* message history */", "  for (;; )"], "readability/old_style_comment"]
["src/nvim/memory.c", ["  /* message history */", "  for (;; )", "    if (delete_first_msg() == FAIL)"], "readability/braces"]
["src/nvim/memory.c", ["  for (;; )", "    if (delete_first_msg() == FAIL)", "      break;"], "readability/braces"]
["src/nvim/menu.c", ["", "/*", " * Code for menus.  Used for the GUI and 'wildmenu'."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "#define MENUDEPTH   10          /* maximum depth of menus */", ""], "readability/old_style_comment"]
["src/nvim/menu.c", ["    while (*arg != NUL && *arg != ' ') {", "      if (*arg == '\\\\')", "        STRMOVE(arg, arg + 1);"], "readability/braces"]
["src/nvim/menu.c", ["    i = 1;", "  } else", "    i = 0;"], "readability/braces"]
["src/nvim/menu.c", ["    i = 0;", "  while (i < MENUDEPTH)", "    pri_tab[i++] = 500;"], "readability/braces"]
["src/nvim/menu.c", ["    pri_tab[i++] = 500;", "  pri_tab[MENUDEPTH] = -1;              /* mark end of the table */", ""], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /*", "   * Check for \"disable\" or \"enable\" argument."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /*", "   * If there is no argument, display all menus."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /*", "   * If there is only a menu name, display menus with that name."], "readability/old_style_comment"]
["src/nvim/menu.c", ["    if (menu_is_popup(menu_path)) {", "      for (i = 0; i < MENU_INDEX_TIP; ++i)", "        if (modes & (1 << i)) {"], "readability/braces"]
["src/nvim/menu.c", ["    if (menu_is_popup(menu_path)) {", "      for (i = 0; i < MENU_INDEX_TIP; ++i)", "        if (modes & (1 << i)) {"], "readability/increment"]
["src/nvim/menu.c", ["  } else if (unmenu) {", "    /*", "     * Delete menu(s)."], "readability/old_style_comment"]
["src/nvim/menu.c", ["     */", "    if (STRCMP(menu_path, \"*\") == 0)            /* meaning: remove all menus */", "      menu_path = (char_u *)\"\";"], "readability/old_style_comment"]
["src/nvim/menu.c", ["     */", "    if (STRCMP(menu_path, \"*\") == 0)            /* meaning: remove all menus */", "      menu_path = (char_u *)\"\";"], "readability/braces"]
["src/nvim/menu.c", ["", "    /*", "     * For the PopUp menu, remove a menu for each mode separately."], "readability/old_style_comment"]
["src/nvim/menu.c", ["    if (menu_is_popup(menu_path)) {", "      for (i = 0; i < MENU_INDEX_TIP; ++i)", "        if (modes & (1 << i)) {"], "readability/braces"]
["src/nvim/menu.c", ["    if (menu_is_popup(menu_path)) {", "      for (i = 0; i < MENU_INDEX_TIP; ++i)", "        if (modes & (1 << i)) {"], "readability/increment"]
["src/nvim/menu.c", ["  } else {", "    /*", "     * Add menu(s)."], "readability/old_style_comment"]
["src/nvim/menu.c", ["     */", "    if (STRICMP(map_to, \"<nop>\") == 0) {        /* \"<Nop>\" means nothing */", "      map_to = (char_u *)\"\";"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "    /*", "     * For the PopUp menu, add a menu for each mode separately."], "readability/old_style_comment"]
["src/nvim/menu.c", ["    if (menu_is_popup(menu_path)) {", "      for (i = 0; i < MENU_INDEX_TIP; ++i)", "        if (modes & (1 << i)) {"], "readability/braces"]
["src/nvim/menu.c", ["    if (menu_is_popup(menu_path)) {", "      for (i = 0; i < MENU_INDEX_TIP; ++i)", "        if (modes & (1 << i)) {"], "readability/increment"]
["src/nvim/menu.c", ["theend:", "  ;", "}"], "whitespace/semicolon"]
["src/nvim/menu.c", ["", "  /* Make a copy so we can stuff around with it, since it could be const */", "  path_name = vim_strsave(menu_path);"], "readability/old_style_comment"]
["src/nvim/menu.c", ["  while (*name) {", "    /* Get name of this element in the menu hierarchy, and the simplified", "     * name (without mnemonic and accelerator text). */"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    if (*dname == NUL) {", "      /* Only a mnemonic or accelerator is not valid. */", "      EMSG(_(\"E792: Empty menu name\"));"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "    /* See if it's already there */", "    lower_pri = menup;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "      /* Count menus, to find where this one needs to be inserted.", "       * Ignore menus that are not in the menubar (PopUp and Toolbar) */"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "      /* Not already there, so lets add it */", "      menu = xcalloc(1, sizeof(vimmenu_T));"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "      /*", "       * If this menu option was previously only available in other"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /*", "   * Only add system menu items which have not been defined yet."], "readability/old_style_comment"]
["src/nvim/menu.c", ["           (MENU_NORMAL_MODE | MENU_INSERT_MODE));", "  if (sys_menu)", "    modes &= ~old_modes;"], "readability/braces"]
["src/nvim/menu.c", ["", "    /* loop over all modes, may add more than one */", "    for (i = 0; i < MENU_MODES; ++i) {"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    /* loop over all modes, may add more than one */", "    for (i = 0; i < MENU_MODES; ++i) {", "      if (modes & (1 << i)) {"], "readability/increment"]
["src/nvim/menu.c", ["      if (modes & (1 << i)) {", "        /* free any old menu */", "        free_menu_string(menu, i);"], "readability/old_style_comment"]
["src/nvim/menu.c", ["        if (c != 0) {", "          menu->strings[i] = xmalloc(STRLEN(call_data) + 5 );", "          menu->strings[i][0] = c;"], "whitespace/parens"]
["src/nvim/menu.c", ["", "            /* Append CTRL-\\ CTRL-G to obey 'insertmode'. */", "            menu->strings[i][len] = Ctrl_BSL;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /* Delete any empty submenu we added before discovering the error.  Repeat", "   * for higher levels. */"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "/*", " * Set the (sub)menu with the given name to enabled or disabled."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  if (menu == NULL)", "    return OK;                  /* Got to bottom of hierarchy */"], "readability/braces"]
["src/nvim/menu.c", ["  if (menu == NULL)", "    return OK;                  /* Got to bottom of hierarchy */", ""], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /* Get name of this element in the menu hierarchy */", "  p = menu_name_skip(name);"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /* Find the menu */", "  while (menu != NULL) {"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "      /*", "       * When name is empty, we are doing all menu items for the given"], "readability/old_style_comment"]
["src/nvim/menu.c", ["       */", "      if (*name != NUL && *name != '*')", "        break;"], "readability/braces"]
["src/nvim/menu.c", ["", "/*", " * Remove the (sub)menu with the given name from the menu hierarchy"], "readability/old_style_comment"]
["src/nvim/menu.c", [" */", "static int ", "remove_menu ("], "whitespace/end_of_line"]
["src/nvim/menu.c", ["static int ", "remove_menu (", "    vimmenu_T **menup,"], "whitespace/parens"]
["src/nvim/menu.c", ["    int modes,", "    bool silent                     /* don't give error messages */", ")"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  if (*menup == NULL)", "    return OK;                  /* Got to bottom of hierarchy */"], "readability/braces"]
["src/nvim/menu.c", ["  if (*menup == NULL)", "    return OK;                  /* Got to bottom of hierarchy */", ""], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /* Get name of this element in the menu hierarchy */", "  p = menu_name_skip(name);"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /* Find the menu */", "  while ((menu = *menup) != NULL) {"], "readability/old_style_comment"]
["src/nvim/menu.c", ["      if (*p != NUL && menu->children == NULL) {", "        if (!silent)", "          EMSG(_(e_notsubmenu));"], "readability/braces"]
["src/nvim/menu.c", ["      if ((menu->modes & modes) != 0x0) {", "        if (remove_menu(&menu->children, p, modes, silent) == FAIL)", "          return FAIL;"], "readability/braces"]
["src/nvim/menu.c", ["      } else if (*name != NUL) {", "        if (!silent)", "          EMSG(_(e_othermode));"], "readability/braces"]
["src/nvim/menu.c", ["", "      /*", "       * When name is empty, we are removing all menu items for the given"], "readability/old_style_comment"]
["src/nvim/menu.c", ["       */", "      if (*name != NUL)", "        break;"], "readability/braces"]
["src/nvim/menu.c", ["", "      /* Remove the menu item for the given mode[s].  If the menu item", "       * is no longer valid in ANY mode, delete it */"], "readability/old_style_comment"]
["src/nvim/menu.c", ["      menu->modes &= ~modes;", "      if (modes & MENU_TIP_MODE)", "        free_menu_string(menu, MENU_INDEX_TIP);"], "readability/braces"]
["src/nvim/menu.c", ["        free_menu_string(menu, MENU_INDEX_TIP);", "      if ((menu->modes & MENU_ALL_MODES) == 0)", "        free_menu(menup);"], "readability/braces"]
["src/nvim/menu.c", ["        free_menu(menup);", "      else", "        menup = &menu->next;"], "readability/braces"]
["src/nvim/menu.c", ["        menup = &menu->next;", "    } else", "      menup = &menu->next;"], "readability/braces"]
["src/nvim/menu.c", ["    if (menu == NULL) {", "      if (!silent)", "        EMSG2(_(e_nomenu), name);"], "readability/braces"]
["src/nvim/menu.c", ["", "    /* Recalculate modes for menu based on the new updated children */", "    menu->modes &= ~modes;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    child = menu->children;", "    for (; child != NULL; child = child->next)", "      menu->modes |= child->modes;"], "readability/braces"]
["src/nvim/menu.c", ["    if ((menu->modes & MENU_ALL_MODES) == 0) {", "      /* The menu item is no longer valid in ANY mode, so delete it */", "      *menup = menu;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "/*", " * Free the given menu structure and remove it from the linked list."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /* Don't change *menup until after calling gui_mch_destroy_menu(). The", "   * MacOS code needs the original structure to properly delete the menu. */"], "readability/old_style_comment"]
["src/nvim/menu.c", ["  xfree(menu->actext);", "  for (i = 0; i < MENU_MODES; i++)", "    free_menu_string(menu, i);"], "readability/braces"]
["src/nvim/menu.c", ["  xfree(menu);", "", "}"], "whitespace/blank_line"]
["src/nvim/menu.c", ["", "/*", " * Free the menu->string with the given index."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  for (i = 0; i < MENU_MODES; i++)", "    if (menu->strings[i] == menu->strings[idx])"], "readability/braces"]
["src/nvim/menu.c", ["  for (i = 0; i < MENU_MODES; i++)", "    if (menu->strings[i] == menu->strings[idx])", "      count++;"], "readability/braces"]
["src/nvim/menu.c", ["      count++;", "  if (count == 1)", "    xfree(menu->strings[idx]);"], "readability/braces"]
["src/nvim/menu.c", ["", "  /* Now we have found the matching menu, and we list the mappings */", "  /* Highlight title */"], "readability/old_style_comment"]
["src/nvim/menu.c", ["  /* Now we have found the matching menu, and we list the mappings */", "  /* Highlight title */", "  MSG_PUTS_TITLE(_(\"\\n--- Menus ---\"));"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  if (menu != NULL && (menu->modes & modes) == 0x0)", "    return;"], "readability/braces"]
["src/nvim/menu.c", ["    msg_putchar('\\n');", "    if (got_int)                /* \"q\" hit for \"--more--\" */", "      return;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    msg_putchar('\\n');", "    if (got_int)                /* \"q\" hit for \"--more--\" */", "      return;"], "readability/braces"]
["src/nvim/menu.c", ["      return;", "    for (i = 0; i < depth; i++)", "      MSG_PUTS(\"  \");"], "readability/braces"]
["src/nvim/menu.c", ["  if (menu != NULL && menu->children == NULL) {", "    for (bit = 0; bit < MENU_MODES; bit++)", "      if ((menu->modes & modes & (1 << bit)) != 0) {"], "readability/braces"]
["src/nvim/menu.c", ["        msg_putchar('\\n');", "        if (got_int)                    /* \"q\" hit for \"--more--\" */", "          return;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["        msg_putchar('\\n');", "        if (got_int)                    /* \"q\" hit for \"--more--\" */", "          return;"], "readability/braces"]
["src/nvim/menu.c", ["          return;", "        for (i = 0; i < depth + 2; i++)", "          MSG_PUTS(\"  \");"], "readability/braces"]
["src/nvim/menu.c", ["        msg_putchar(menu_mode_chars[bit]);", "        if (menu->noremap[bit] == REMAP_NONE)", "          msg_putchar('*');"], "readability/braces"]
["src/nvim/menu.c", ["          msg_putchar('*');", "        else if (menu->noremap[bit] == REMAP_SCRIPT)", "          msg_putchar('&');"], "readability/braces"]
["src/nvim/menu.c", ["          msg_putchar('&');", "        else", "          msg_putchar(' ');"], "readability/braces"]
["src/nvim/menu.c", ["          msg_putchar(' ');", "        if (menu->silent[bit])", "          msg_putchar('s');"], "readability/braces"]
["src/nvim/menu.c", ["          msg_putchar('s');", "        else", "          msg_putchar(' ');"], "readability/braces"]
["src/nvim/menu.c", ["          msg_putchar(' ');", "        if ((menu->modes & menu->enabled & (1 << bit)) == 0)", "          msg_putchar('-');"], "readability/braces"]
["src/nvim/menu.c", ["          msg_putchar('-');", "        else", "          msg_putchar(' ');"], "readability/braces"]
["src/nvim/menu.c", ["      depth--;", "    } else", "      menu = menu->children;"], "readability/braces"]
["src/nvim/menu.c", ["", "    /* recursively show all children.  Skip PopUp[nvoci]. */", "    for (; menu != NULL && !got_int; menu = menu->next)"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    /* recursively show all children.  Skip PopUp[nvoci]. */", "    for (; menu != NULL && !got_int; menu = menu->next)", "      if (!menu_is_hidden(menu->dname))"], "readability/braces"]
["src/nvim/menu.c", ["    for (; menu != NULL && !got_int; menu = menu->next)", "      if (!menu_is_hidden(menu->dname))", "        show_menus_recursive(menu, modes, depth + 1);"], "readability/braces"]
["src/nvim/menu.c", ["", "/*", " * Used when expanding menu names."], "readability/old_style_comment"]
["src/nvim/menu.c", ["static int expand_modes = 0x0;", "static int expand_emenu;                /* TRUE for \":emenu\" command */", ""], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "/*", " * Work out what to complete when doing command line completion of menu names."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /* Check for priority numbers, enable and disable */", "  for (p = arg; *p; ++p)"], "readability/old_style_comment"]
["src/nvim/menu.c", ["  /* Check for priority numbers, enable and disable */", "  for (p = arg; *p; ++p)", "    if (!ascii_isdigit(*p) && *p != '.')"], "readability/braces"]
["src/nvim/menu.c", ["  /* Check for priority numbers, enable and disable */", "  for (p = arg; *p; ++p)", "    if (!ascii_isdigit(*p) && *p != '.')"], "readability/increment"]
["src/nvim/menu.c", ["  for (p = arg; *p; ++p)", "    if (!ascii_isdigit(*p) && *p != '.')", "      break;"], "readability/braces"]
["src/nvim/menu.c", ["  if (!ascii_iswhite(*p)) {", "    if (STRNCMP(arg, \"enable\", 6) == 0", "        && (arg[6] == NUL ||  ascii_iswhite(arg[6])))"], "readability/braces"]
["src/nvim/menu.c", ["      p = arg + 6;", "    else if (STRNCMP(arg, \"disable\", 7) == 0", "             && (arg[7] == NUL || ascii_iswhite(arg[7])))"], "readability/braces"]
["src/nvim/menu.c", ["      p = arg + 7;", "    else", "      p = arg;"], "readability/braces"]
["src/nvim/menu.c", ["", "  while (*p != NUL && ascii_iswhite(*p))", "    ++p;"], "readability/braces"]
["src/nvim/menu.c", ["  while (*p != NUL && ascii_iswhite(*p))", "    ++p;", ""], "readability/increment"]
["src/nvim/menu.c", ["", "  for (; *p && !ascii_iswhite(*p); ++p) {", "    if ((*p == '\\\\' || *p == Ctrl_V) && p[1] != NUL)"], "readability/increment"]
["src/nvim/menu.c", ["  for (; *p && !ascii_iswhite(*p); ++p) {", "    if ((*p == '\\\\' || *p == Ctrl_V) && p[1] != NUL)", "      p++;"], "readability/braces"]
["src/nvim/menu.c", ["      p++;", "    else if (*p == '.')", "      after_dot = p + 1;"], "readability/braces"]
["src/nvim/menu.c", ["    expand_modes = get_menu_cmd_modes(cmd, forceit, NULL, &unmenu);", "    if (!unmenu)", "      expand_modes = MENU_ALL_MODES;"], "readability/braces"]
["src/nvim/menu.c", ["    if (after_dot > arg) {", "      size_t path_len = (size_t) (after_dot - arg);", "      path_name = xmalloc(path_len);"], "whitespace/cast"]
["src/nvim/menu.c", ["        if (menu_name_equal(name, menu)) {", "          /* Found menu */", "          if ((*p != NUL && menu->children == NULL)"], "readability/old_style_comment"]
["src/nvim/menu.c", ["              || ((menu->modes & expand_modes) == 0x0)) {", "            /*", "             * Menu path continues, but we have reached a leaf."], "readability/old_style_comment"]
["src/nvim/menu.c", ["      if (menu == NULL) {", "        /* No menu found with the name we were looking for */", "        xfree(path_name);"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the list of (sub)menus (not"], "readability/old_style_comment"]
["src/nvim/menu.c", ["  char_u              *str;", "  static int should_advance = FALSE;", ""], "readability/bool"]
["src/nvim/menu.c", ["", "  if (idx == 0) {           /* first call: start at first item */", "    menu = expand_menu;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /* Skip PopUp[nvoci]. */", "  while (menu != NULL && (menu_is_hidden(menu->dname)"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  if (menu == NULL)         /* at end of linked list */", "    return NULL;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  if (menu == NULL)         /* at end of linked list */", "    return NULL;"], "readability/braces"]
["src/nvim/menu.c", ["", "  if (menu->modes & expand_modes)", "    if (should_advance)"], "readability/braces"]
["src/nvim/menu.c", ["  if (menu->modes & expand_modes)", "    if (should_advance)", "      str = menu->en_dname;"], "readability/braces"]
["src/nvim/menu.c", ["      str = menu->en_dname;", "    else {", "      str = menu->dname;"], "readability/braces"]
["src/nvim/menu.c", ["      str = menu->en_dname;", "    else {", "      str = menu->dname;"], "readability/braces"]
["src/nvim/menu.c", ["      str = menu->dname;", "      if (menu->en_dname == NULL)", "        should_advance = TRUE;"], "readability/braces"]
["src/nvim/menu.c", ["      if (menu->en_dname == NULL)", "        should_advance = TRUE;", "    }"], "readability/bool"]
["src/nvim/menu.c", ["    }", "  else", "    str = (char_u *)\"\";"], "whitespace/newline"]
["src/nvim/menu.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the list of menus and menu"], "readability/old_style_comment"]
["src/nvim/menu.c", ["#define TBUFFER_LEN 256", "  static char_u tbuffer[TBUFFER_LEN];         /*hack*/", "  char_u              *str;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["  char_u              *str;", "  static int should_advance = FALSE;", ""], "readability/bool"]
["src/nvim/menu.c", ["", "  if (idx == 0) {           /* first call: start at first item */", "    menu = expand_menu;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /* Skip Browse-style entries, popup menus and separators. */", "  while (menu != NULL"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  if (menu == NULL)         /* at end of linked list */", "    return NULL;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  if (menu == NULL)         /* at end of linked list */", "    return NULL;"], "readability/braces"]
["src/nvim/menu.c", ["    if (menu->children != NULL) {", "      if (should_advance)", "        STRLCPY(tbuffer, menu->en_dname, TBUFFER_LEN - 1);"], "readability/braces"]
["src/nvim/menu.c", ["        STRLCPY(tbuffer, menu->en_dname, TBUFFER_LEN - 1);", "      else {", "        STRLCPY(tbuffer, menu->dname,  TBUFFER_LEN - 1);"], "readability/braces"]
["src/nvim/menu.c", ["        STRLCPY(tbuffer, menu->en_dname, TBUFFER_LEN - 1);", "      else {", "        STRLCPY(tbuffer, menu->dname,  TBUFFER_LEN - 1);"], "readability/braces"]
["src/nvim/menu.c", ["        STRLCPY(tbuffer, menu->dname,  TBUFFER_LEN - 1);", "        if (menu->en_dname == NULL)", "          should_advance = TRUE;"], "readability/braces"]
["src/nvim/menu.c", ["        if (menu->en_dname == NULL)", "          should_advance = TRUE;", "      }"], "readability/bool"]
["src/nvim/menu.c", ["      }", "      /* hack on menu separators:  use a 'magic' char for the separator", "       * so that '.' in names gets escaped properly */"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    } else {", "      if (should_advance)", "        str = menu->en_dname;"], "readability/braces"]
["src/nvim/menu.c", ["        str = menu->en_dname;", "      else {", "        str = menu->dname;"], "readability/braces"]
["src/nvim/menu.c", ["        str = menu->en_dname;", "      else {", "        str = menu->dname;"], "readability/braces"]
["src/nvim/menu.c", ["        str = menu->dname;", "        if (menu->en_dname == NULL)", "          should_advance = TRUE;"], "readability/braces"]
["src/nvim/menu.c", ["        if (menu->en_dname == NULL)", "          should_advance = TRUE;", "      }"], "readability/bool"]
["src/nvim/menu.c", ["    }", "  } else", "    str = (char_u *)\"\";"], "readability/braces"]
["src/nvim/menu.c", ["      STRMOVE(p, p + 1);", "      if (*p == NUL)", "        break;"], "readability/braces"]
["src/nvim/menu.c", ["  }", "  if (*p)", "    *p++ = NUL;"], "readability/braces"]
["src/nvim/menu.c", ["", "/*", " * Return TRUE when \"name\" matches with menu \"menu\".  The name is compared in"], "readability/old_style_comment"]
["src/nvim/menu.c", ["{", "  if (menu->en_name != NULL", "      && (menu_namecmp(name, menu->en_name)"], "readability/braces"]
["src/nvim/menu.c", ["", "  for (i = 0; name[i] != NUL && name[i] != TAB; ++i)", "    if (name[i] != mname[i])"], "readability/braces"]
["src/nvim/menu.c", ["", "  for (i = 0; name[i] != NUL && name[i] != TAB; ++i)", "    if (name[i] != mname[i])"], "readability/increment"]
["src/nvim/menu.c", ["  for (i = 0; name[i] != NUL && name[i] != TAB; ++i)", "    if (name[i] != mname[i])", "      break;"], "readability/braces"]
["src/nvim/menu.c", ["  switch (*cmd++) {", "  case 'v':                             /* vmenu, vunmenu, vnoremenu */", "    modes = MENU_VISUAL_MODE | MENU_SELECT_MODE;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    break;", "  case 'x':                             /* xmenu, xunmenu, xnoremenu */", "    modes = MENU_VISUAL_MODE;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    break;", "  case 's':                             /* smenu, sunmenu, snoremenu */", "    modes = MENU_SELECT_MODE;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    break;", "  case 'o':                             /* omenu */", "    modes = MENU_OP_PENDING_MODE;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    break;", "  case 'i':                             /* imenu */", "    modes = MENU_INSERT_MODE;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["  case 't':", "    modes = MENU_TIP_MODE;              /* tmenu */", "    break;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    break;", "  case 'c':                             /* cmenu */", "    modes = MENU_CMDLINE_MODE;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    break;", "  case 'a':                             /* amenu */", "    modes = MENU_INSERT_MODE | MENU_CMDLINE_MODE | MENU_NORMAL_MODE"], "readability/old_style_comment"]
["src/nvim/menu.c", ["  case 'n':", "    if (*cmd != 'o') {                  /* nmenu, not noremenu */", "      modes = MENU_NORMAL_MODE;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  if (noremap != NULL)", "    *noremap = (*cmd == 'n' ? REMAP_NONE : REMAP_YES);"], "readability/braces"]
["src/nvim/menu.c", ["    *noremap = (*cmd == 'n' ? REMAP_NONE : REMAP_YES);", "  if (unmenu != NULL)", "    *unmenu = (*cmd == 'u');"], "readability/braces"]
["src/nvim/menu.c", ["", "/*", " * Modify a menu name starting with \"PopUp\" to include the mode character."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /* Locate accelerator text, after the first TAB */", "  p = vim_strchr(str, TAB);"], "readability/old_style_comment"]
["src/nvim/menu.c", ["  if (p != NULL) {", "    if (actext != NULL)", "      *actext = vim_strsave(p + 1);"], "readability/braces"]
["src/nvim/menu.c", ["    text = vim_strnsave(str, (size_t)(p - str));", "  } else", "    text = vim_strsave(str);"], "readability/braces"]
["src/nvim/menu.c", ["", "  /* Find mnemonic characters \"&a\" and reduce \"&&\" to \"&\". */", "  for (p = text; p != NULL; ) {"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    if (p != NULL) {", "      if (p[1] == NUL)              /* trailing \"&\" */", "        break;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    if (p != NULL) {", "      if (p[1] == NUL)              /* trailing \"&\" */", "        break;"], "readability/braces"]
["src/nvim/menu.c", ["        break;", "      if (mnemonic != NULL && p[1] != '&')", "        *mnemonic = p[1];"], "readability/braces"]
["src/nvim/menu.c", ["", "/*", " * Return TRUE if the name is a menu separator identifier: Starts and ends"], "readability/old_style_comment"]
["src/nvim/menu.c", ["  } else if (get_real_state() & VISUAL) {", "    /* Detect real visual mode -- if we are really in visual mode we", "     * don't need to do any guesswork to figure out what the selection"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "    /* GEDDES: This is not perfect - but it is a", "     * quick way of detecting whether we are doing this from a"], "readability/old_style_comment"]
["src/nvim/menu.c", ["        && (curbuf->b_visual.vi_end.lnum) == eap->line2) {", "      /* Set it up for visual mode - equivalent to gv.  */", "      VIsual_mode = curbuf->b_visual.vi_mode;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    } else {", "      /* Set it up for line-wise visual mode */", "      VIsual_mode = 'V';"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "    /* Activate visual mode */", "    VIsual_active = TRUE;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    /* Activate visual mode */", "    VIsual_active = TRUE;", "    VIsual_reselect = TRUE;"], "readability/bool"]
["src/nvim/menu.c", ["    VIsual_active = TRUE;", "    VIsual_reselect = TRUE;", "    check_cursor();"], "readability/bool"]
["src/nvim/menu.c", ["", "    /* Adjust the cursor to make sure it is in the correct pos", "     * for exclusive mode */"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "/*", " * Translation of menu names.  Just a simple lookup table."], "readability/old_style_comment"]
["src/nvim/menu.c", ["typedef struct {", "  char_u      *from;            /* English name */", "  char_u      *from_noamp;      /* same, without '&' */"], "readability/old_style_comment"]
["src/nvim/menu.c", ["  char_u      *from;            /* English name */", "  char_u      *from_noamp;      /* same, without '&' */", "  char_u      *to;              /* translated name */"], "readability/old_style_comment"]
["src/nvim/menu.c", ["  char_u      *from_noamp;      /* same, without '&' */", "  char_u      *to;              /* translated name */", "} menutrans_T;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["#define FREE_MENUTRANS(mt) \\", "  menutrans_T* _mt = (mt); \\", "  xfree(_mt->from); \\"], "whitespace/operators"]
["src/nvim/menu.c", ["", "/*", " * \":menutrans\"."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  if (menutrans_ga.ga_itemsize == 0)", "    ga_init(&menutrans_ga, (int)sizeof(menutrans_T), 5);"], "readability/braces"]
["src/nvim/menu.c", ["", "  /*", "   * \":menutrans clear\": clear all translations."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "    /* Delete all \"menutrans_\" global variables. */", "    del_menutrans_vars();"], "readability/old_style_comment"]
["src/nvim/menu.c", ["  } else {", "    /* \":menutrans from to\": add translation */", "    from = arg;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    arg = menu_skip_part(to);", "    if (arg == to)", "      EMSG(_(e_invarg));"], "readability/braces"]
["src/nvim/menu.c", ["      EMSG(_(e_invarg));", "    else {", "      from = vim_strsave(from);"], "readability/braces"]
["src/nvim/menu.c", ["      EMSG(_(e_invarg));", "    else {", "      from = vim_strsave(from);"], "readability/braces"]
["src/nvim/menu.c", ["      menu_unescape_name(to);", "      menutrans_T* tp = GA_APPEND_VIA_PTR(menutrans_T, &menutrans_ga);", "      tp->from = from;"], "whitespace/operators"]
["src/nvim/menu.c", ["", "/*", " * Find the character just after one part of a menu name."], "readability/old_style_comment"]
["src/nvim/menu.c", ["  while (*p != NUL && *p != '.' && !ascii_iswhite(*p)) {", "    if ((*p == '\\\\' || *p == Ctrl_V) && p[1] != NUL)", "      ++p;"], "readability/braces"]
["src/nvim/menu.c", ["    if ((*p == '\\\\' || *p == Ctrl_V) && p[1] != NUL)", "      ++p;", "    ++p;"], "readability/increment"]
["src/nvim/menu.c", ["      ++p;", "    ++p;", "  }"], "readability/increment"]
["src/nvim/menu.c", ["", "/*", " * Lookup part of a menu name in the translations."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /* Now try again while ignoring '&' characters. */", "  char_u c = name[len];"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "/*", " * Unescape the name in the translate dictionary table."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "/*", " * Isolate the menu name."], "readability/old_style_comment"]
["src/nvim/menu.c", ["  while (*arg && !ascii_iswhite(*arg)) {", "    if ((*arg == '\\\\' || *arg == Ctrl_V) && arg[1] != NUL)", "      arg++;"], "readability/braces"]
["src/nvim/menu.c", ["      arg++;", "    else if (STRNICMP(arg, \"<TAB>\", 5) == 0) {", "      *arg = TAB;"], "readability/braces"]
["src/nvim/menu.c", ["  }", "  if (*arg != NUL)", "    *arg++ = NUL;"], "readability/braces"]
["src/nvim/menu.h", ["", "#include <stdbool.h> // for bool", ""], "whitespace/comments"]
["src/nvim/menu.h", ["", "#include \"nvim/types.h\" // for char_u and expand_T", "#include \"nvim/ex_cmds_defs.h\" // for exarg_T"], "whitespace/comments"]
["src/nvim/menu.h", ["#include \"nvim/types.h\" // for char_u and expand_T", "#include \"nvim/ex_cmds_defs.h\" // for exarg_T", ""], "whitespace/comments"]
["src/nvim/message.c", ["", "/*", " * message.c: functions for displaying messages on the command line"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * To be able to scroll back at the \"more\" and \"hit-enter\" prompts we need to"], "readability/old_style_comment"]
["src/nvim/message.c", ["  msgchunk_T  *sb_prev;", "  char sb_eol;                  /* TRUE when line ends after this text */", "  int sb_msg_col;               /* column in which text starts */"], "readability/old_style_comment"]
["src/nvim/message.c", ["  char sb_eol;                  /* TRUE when line ends after this text */", "  int sb_msg_col;               /* column in which text starts */", "  int sb_attr;                  /* text attributes */"], "readability/old_style_comment"]
["src/nvim/message.c", ["  int sb_msg_col;               /* column in which text starts */", "  int sb_attr;                  /* text attributes */", "  char_u sb_text[1];            /* text to be displayed, actually longer */"], "readability/old_style_comment"]
["src/nvim/message.c", ["  int sb_attr;                  /* text attributes */", "  char_u sb_text[1];            /* text to be displayed, actually longer */", "};"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/* Magic chars used in confirm dialog strings */", "#define DLG_BUTTON_SEP  '\\n'"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "static int confirm_msg_used = FALSE;            /* displaying confirm_msg */", "#ifdef INCLUDE_GENERATED_DECLARATIONS"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "static int confirm_msg_used = FALSE;            /* displaying confirm_msg */", "#ifdef INCLUDE_GENERATED_DECLARATIONS"], "readability/bool"]
["src/nvim/message.c", ["#endif", "static char_u   *confirm_msg = NULL;            /* \":confirm\" message */", "static char_u   *confirm_msg_tail;              /* tail of confirm_msg */"], "readability/old_style_comment"]
["src/nvim/message.c", ["static char_u   *confirm_msg = NULL;            /* \":confirm\" message */", "static char_u   *confirm_msg_tail;              /* tail of confirm_msg */", ""], "readability/old_style_comment"]
["src/nvim/message.c", ["static FILE *verbose_fd = NULL;", "static int verbose_did_open = FALSE;", ""], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * When writing messages to the screen, there are many different situations."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * msg(s) - displays the string 's' on the status line"], "readability/old_style_comment"]
["src/nvim/message.c", ["  if (attr == 0) {", "    set_vim_var_string(VV_STATUSMSG, (char *) s, -1);", "  }"], "whitespace/cast"]
["src/nvim/message.c", ["", "  /*", "   * It is possible that displaying a messages causes a problem (e.g.,"], "readability/old_style_comment"]
["src/nvim/message.c", ["   */", "  if (entered >= 3)", "    return TRUE;"], "readability/braces"]
["src/nvim/message.c", ["  if (entered >= 3)", "    return TRUE;", "  ++entered;"], "readability/bool"]
["src/nvim/message.c", ["    return TRUE;", "  ++entered;", ""], "readability/increment"]
["src/nvim/message.c", ["", "  /* Add message to history (unless it's a repeated kept message or a", "   * truncated message) */"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  /* Truncate the message if needed. */", "  msg_start();"], "readability/old_style_comment"]
["src/nvim/message.c", ["  msg_start();", "  buf = msg_strtrunc(s, FALSE);", "  if (buf != NULL)"], "readability/bool"]
["src/nvim/message.c", ["  buf = msg_strtrunc(s, FALSE);", "  if (buf != NULL)", "    s = buf;"], "readability/braces"]
["src/nvim/message.c", ["  xfree(buf);", "  --entered;", "  return retval;"], "readability/increment"]
["src/nvim/message.c", ["", "/*", " * Truncate a string such that it can be printed without causing a scroll."], "readability/old_style_comment"]
["src/nvim/message.c", ["char_u *", "msg_strtrunc (", "    char_u *s,"], "whitespace/parens"]
["src/nvim/message.c", ["    char_u *s,", "    int force                  /* always truncate */", ")"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  /* May truncate message to avoid a hit-return prompt */", "  if ((!msg_scroll && !need_wait_return && shortmess(SHM_TRUNCALL)"], "readability/old_style_comment"]
["src/nvim/message.c", ["    len = vim_strsize(s);", "    if (msg_scrolled != 0)", "      /* Use all the columns. */"], "readability/braces"]
["src/nvim/message.c", ["    if (msg_scrolled != 0)", "      /* Use all the columns. */", "      room = (int)(Rows - msg_row) * Columns - 1;"], "readability/old_style_comment"]
["src/nvim/message.c", ["      room = (int)(Rows - msg_row) * Columns - 1;", "    else", "      /* Use up to 'showcmd' column. */"], "readability/braces"]
["src/nvim/message.c", ["    else", "      /* Use up to 'showcmd' column. */", "      room = (int)(Rows - msg_row - 1) * Columns + sc_col - 1;"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Truncate a string \"s\" to \"buf\" with cell width \"room\"."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  /* First part: Start of the string. */", "  for (e = 0; len < half && e < buflen; ++e) {"], "readability/old_style_comment"]
["src/nvim/message.c", ["  /* First part: Start of the string. */", "  for (e = 0; len < half && e < buflen; ++e) {", "    if (s[e] == NUL) {"], "readability/increment"]
["src/nvim/message.c", ["    if (s[e] == NUL) {", "      /* text fits without truncating! */", "      buf[e] = NUL;"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Note: Caller of smgs() and smsg_attr() must check the resulting string is"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Remember the last sourcing name/lnum used in an error message, so that it"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Reset the last used sourcing name/lnum.  Makes sure it is displayed again"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Return TRUE if \"sourcing_name\" differs from \"last_sourcing_name\"."], "readability/old_style_comment"]
["src/nvim/message.c", ["  if (sourcing_name != NULL) {", "    if (last_sourcing_name != NULL)", "      return STRCMP(sourcing_name, last_sourcing_name) != 0;"], "readability/braces"]
["src/nvim/message.c", ["      return STRCMP(sourcing_name, last_sourcing_name) != 0;", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/message.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * Display name and line number for the source of an error."], "readability/old_style_comment"]
["src/nvim/message.c", ["    xfree(p);", "    last_sourcing_lnum = sourcing_lnum;      /* only once for each line */", "  }"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  /* remember the last sourcing name printed, also when it's empty */", "  if (sourcing_name == NULL || other_sourcing_name()) {"], "readability/old_style_comment"]
["src/nvim/message.c", ["    xfree(last_sourcing_name);", "    if (sourcing_name == NULL)", "      last_sourcing_name = NULL;"], "readability/braces"]
["src/nvim/message.c", ["      last_sourcing_name = NULL;", "    else", "      last_sourcing_name = vim_strsave(sourcing_name);"], "readability/braces"]
["src/nvim/message.c", ["  }", "  --no_wait_return;", "}"], "readability/increment"]
["src/nvim/message.c", ["", "/*", " * Return TRUE if not giving error messages right now:"], "readability/old_style_comment"]
["src/nvim/message.c", ["{", "  if ((emsg_off > 0 && vim_strchr(p_debug, 'm') == NULL", "       && vim_strchr(p_debug, 't') == NULL)"], "readability/braces"]
["src/nvim/message.c", ["      )", "    return TRUE;", "  return FALSE;"], "readability/bool"]
["src/nvim/message.c", ["    return TRUE;", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/message.c", ["  if (!emsg_off || vim_strchr(p_debug, 't') != NULL) {", "    /*", "     * Cause a throw of an error exception if appropriate.  Don't display"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "    /*", "     * When using \":silent! cmd\" ignore error messages."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  /*", "   * Display name and line number for the source of the error."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Like msg(), but truncate to a single line if p_shm contains 't', or when"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  if (n)", "    return s;"], "readability/braces"]
["src/nvim/message.c", ["", "/*", " * Check if message \"s\" should be truncated at the start (for filenames)."], "readability/old_style_comment"]
["src/nvim/message.c", ["{", "  if (msg_hist_off || msg_silent != 0)", "    return;"], "readability/braces"]
["src/nvim/message.c", ["", "  /* Don't let the message history get too big */", "  while (msg_hist_len > MAX_MSG_HIST_LEN)"], "readability/old_style_comment"]
["src/nvim/message.c", ["  /* Don't let the message history get too big */", "  while (msg_hist_len > MAX_MSG_HIST_LEN)", "    (void)delete_first_msg();"], "readability/braces"]
["src/nvim/message.c", ["", "  /* allocate an entry and add the message at the end of the history */", "  struct msg_hist *p = xmalloc(sizeof(struct msg_hist));"], "readability/old_style_comment"]
["src/nvim/message.c", ["  struct msg_hist *p = xmalloc(sizeof(struct msg_hist));", "  if (len < 0)", "    len = (int)STRLEN(s);"], "readability/braces"]
["src/nvim/message.c", ["    len = (int)STRLEN(s);", "  /* remove leading and trailing newlines */", "  while (len > 0 && *s == '\\n') {"], "readability/old_style_comment"]
["src/nvim/message.c", ["  while (len > 0 && *s == '\\n') {", "    ++s;", "    --len;"], "readability/increment"]
["src/nvim/message.c", ["    ++s;", "    --len;", "  }"], "readability/increment"]
["src/nvim/message.c", ["", "/*", " * Delete the first (oldest) message from the history."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  if (msg_hist_len <= 0)", "    return FAIL;"], "readability/braces"]
["src/nvim/message.c", ["  first_msg_hist = p->next;", "  if (first_msg_hist == NULL) {  /* history is becoming empty */", "    assert(msg_hist_len == 1);"], "readability/old_style_comment"]
["src/nvim/message.c", ["  xfree(p);", "  --msg_hist_len;", "  return OK;"], "readability/increment"]
["src/nvim/message.c", ["", "/*", " * Call this after prompting the user.  This will avoid a hit-return message"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  /* If using \":silent cmd\", don't wait for a return.  Also don't set", "   * need_wait_return to do it later. */"], "readability/old_style_comment"]
["src/nvim/message.c", ["   * need_wait_return to do it later. */", "  if (msg_silent != 0)", "    return;"], "readability/braces"]
["src/nvim/message.c", ["", "  /*", "   * When inside vgetc(), we can't wait for a typed character at all."], "readability/old_style_comment"]
["src/nvim/message.c", ["   */", "  if (vgetc_busy > 0)", "    return;"], "readability/braces"]
["src/nvim/message.c", ["    return;", "  need_wait_return = TRUE;", "  if (no_wait_return) {"], "readability/bool"]
["src/nvim/message.c", ["  if (no_wait_return) {", "    if (!exmode_active)", "      cmdline_row = msg_row;"], "readability/braces"]
["src/nvim/message.c", ["", "  redir_off = TRUE;             /* don't redirect this message */", "  oldState = State;"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  redir_off = TRUE;             /* don't redirect this message */", "  oldState = State;"], "readability/bool"]
["src/nvim/message.c", ["  if (quit_more) {", "    c = CAR;                    /* just pretend CR was hit */", "    quit_more = FALSE;"], "readability/old_style_comment"]
["src/nvim/message.c", ["    c = CAR;                    /* just pretend CR was hit */", "    quit_more = FALSE;", "    got_int = FALSE;"], "readability/bool"]
["src/nvim/message.c", ["    quit_more = FALSE;", "    got_int = FALSE;", "  } else if (exmode_active) {"], "readability/bool"]
["src/nvim/message.c", ["  } else if (exmode_active) {", "    MSG_PUTS(\" \");              /* make sure the cursor is on the right line */", "    c = CAR;                    /* no need for a return in ex mode */"], "readability/old_style_comment"]
["src/nvim/message.c", ["    MSG_PUTS(\" \");              /* make sure the cursor is on the right line */", "    c = CAR;                    /* no need for a return in ex mode */", "    got_int = FALSE;"], "readability/old_style_comment"]
["src/nvim/message.c", ["    c = CAR;                    /* no need for a return in ex mode */", "    got_int = FALSE;", "  } else {"], "readability/bool"]
["src/nvim/message.c", ["    do {", "      /* Remember \"got_int\", if it is set vgetc() probably returns a", "       * CTRL-C, but we need to loop then. */"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "      /*", "       * Allow scrolling back in the messages."], "readability/old_style_comment"]
["src/nvim/message.c", ["            || c == K_UP || c == K_PAGEUP) {", "          if (msg_scrolled > Rows)", "            /* scroll back to show older messages */"], "readability/braces"]
["src/nvim/message.c", ["          if (msg_scrolled > Rows)", "            /* scroll back to show older messages */", "            do_more_prompt(c);"], "readability/old_style_comment"]
["src/nvim/message.c", ["            do_more_prompt(c);", "          else {", "            msg_didout = FALSE;"], "readability/braces"]
["src/nvim/message.c", ["            do_more_prompt(c);", "          else {", "            msg_didout = FALSE;"], "readability/braces"]
["src/nvim/message.c", ["          else {", "            msg_didout = FALSE;", "            c = K_IGNORE;"], "readability/bool"]
["src/nvim/message.c", ["          if (quit_more) {", "            c = CAR;                            /* just pretend CR was hit */", "            quit_more = FALSE;"], "readability/old_style_comment"]
["src/nvim/message.c", ["            c = CAR;                            /* just pretend CR was hit */", "            quit_more = FALSE;", "            got_int = FALSE;"], "readability/bool"]
["src/nvim/message.c", ["            quit_more = FALSE;", "            got_int = FALSE;", "          } else if (c != K_IGNORE) {"], "readability/bool"]
["src/nvim/message.c", ["          }", "        } else if (msg_scrolled > Rows - 2", "                   && (c == 'j' || c == 'd' || c == 'f'"], "readability/braces"]
["src/nvim/message.c", ["    os_breakcheck();", "    /*", "     * Avoid that the mouse-up event causes visual mode to start."], "readability/old_style_comment"]
["src/nvim/message.c", ["     */", "    if (c == K_LEFTMOUSE || c == K_MIDDLEMOUSE || c == K_RIGHTMOUSE", "        || c == K_X1MOUSE || c == K_X2MOUSE)"], "readability/braces"]
["src/nvim/message.c", ["      (void)jump_to_mouse(MOUSE_SETPOS, NULL, 0);", "    else if (vim_strchr((char_u *)\"\\r\\n \", c) == NULL && c != Ctrl_C) {", "      /* Put the character back in the typeahead buffer.  Don't use the"], "readability/braces"]
["src/nvim/message.c", ["    else if (vim_strchr((char_u *)\"\\r\\n \", c) == NULL && c != Ctrl_C) {", "      /* Put the character back in the typeahead buffer.  Don't use the", "       * stuff buffer, because lmaps wouldn't work. */"], "readability/old_style_comment"]
["src/nvim/message.c", ["  if (c == ':' || c == '?' || c == '/') {", "    if (!exmode_active)", "      cmdline_row = msg_row;"], "readability/braces"]
["src/nvim/message.c", ["", "  if (tmpState == SETWSIZE) {       /* got resize event while in vgetc() */", "    ui_refresh();"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Write the hit-return prompt."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  p_more = FALSE;       /* don't want see this message when scrolling back */", "  if (msg_didout)       /* start on a new line */"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  p_more = FALSE;       /* don't want see this message when scrolling back */", "  if (msg_didout)       /* start on a new line */"], "readability/bool"]
["src/nvim/message.c", ["  p_more = FALSE;       /* don't want see this message when scrolling back */", "  if (msg_didout)       /* start on a new line */", "    msg_putchar('\\n');"], "readability/old_style_comment"]
["src/nvim/message.c", ["  p_more = FALSE;       /* don't want see this message when scrolling back */", "  if (msg_didout)       /* start on a new line */", "    msg_putchar('\\n');"], "readability/braces"]
["src/nvim/message.c", ["", "/*", " * Set \"keep_msg\" to \"s\".  Free the old value and check for NULL pointer."], "readability/old_style_comment"]
["src/nvim/message.c", ["  xfree(keep_msg);", "  if (s != NULL && msg_silent == 0)", "    keep_msg = vim_strsave(s);"], "readability/braces"]
["src/nvim/message.c", ["    keep_msg = vim_strsave(s);", "  else", "    keep_msg = NULL;"], "readability/braces"]
["src/nvim/message.c", ["    keep_msg = NULL;", "  keep_msg_more = FALSE;", "  keep_msg_attr = attr;"], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * Prepare for outputting characters in the command line."], "readability/old_style_comment"]
["src/nvim/message.c", ["    msg_putchar('\\n');", "    did_return = TRUE;", "    if (exmode_active != EXMODE_NORMAL)"], "readability/bool"]
["src/nvim/message.c", ["    did_return = TRUE;", "    if (exmode_active != EXMODE_NORMAL)", "      cmdline_row = msg_row;"], "readability/braces"]
["src/nvim/message.c", ["  }", "  if (!msg_didany || lines_left < 0)", "    msg_starthere();"], "readability/braces"]
["src/nvim/message.c", ["", "/*", " * Note that the current msg position is where messages start."], "readability/old_style_comment"]
["src/nvim/message.c", ["  lines_left = cmdline_row;", "  msg_didany = FALSE;", "}"], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * Output 'len' characters in 'str' (including NULs) with translation"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Output one character at \"p\".  Return pointer to the next character."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  /* if MSG_HIST flag set, add message to history */", "  if (attr & MSG_HIST) {"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  /*", "   * Go over the string.  Special characters are translated and printed."], "readability/old_style_comment"]
["src/nvim/message.c", ["  arg = skipwhite(arg);", "  for (i = 5; *arg && i >= 0; --i)", "    if (*arg++ != str[i])"], "readability/braces"]
["src/nvim/message.c", ["  arg = skipwhite(arg);", "  for (i = 5; *arg && i >= 0; --i)", "    if (*arg++ != str[i])"], "readability/increment"]
["src/nvim/message.c", ["  for (i = 5; *arg && i >= 0; --i)", "    if (*arg++ != str[i])", "      break;"], "readability/braces"]
["src/nvim/message.c", ["    msg_putchar('\\n');", "    for (i = 0; rs[i]; ++i)", "      msg_putchar(rs[i] - 3);"], "readability/braces"]
["src/nvim/message.c", ["    msg_putchar('\\n');", "    for (i = 0; rs[i]; ++i)", "      msg_putchar(rs[i] - 3);"], "readability/increment"]
["src/nvim/message.c", ["", "/*", " * print line for :print or :list command"], "readability/old_style_comment"]
["src/nvim/message.c", ["        c = *p_extra++;", "        /* Use special coloring to be able to distinguish <hex> from", "         * the same in plain text. */"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "    if (c == NUL)", "      break;"], "readability/braces"]
["src/nvim/message.c", ["      msg_col = Columns;", "      ++msg_row;", "    }"], "readability/increment"]
["src/nvim/message.c", ["      msg_col = 0;", "      ++msg_row;", "    }"], "readability/increment"]
["src/nvim/message.c", ["", "/*", " * Output a string to the screen at position msg_row, msg_col."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Show a message in such a way that it always fits in the line.  Cut out a"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Basic function for writing a message with highlight attributes."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * The display part of msg_puts_attr_len()."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "      /* When no more prompt and no more room, truncate here */", "      if (msg_no_more && lines_left == 0)"], "readability/old_style_comment"]
["src/nvim/message.c", ["      /* When no more prompt and no more room, truncate here */", "      if (msg_no_more && lines_left == 0)", "        break;"], "readability/braces"]
["src/nvim/message.c", ["      msg_row = Rows - 2;", "      if (msg_col >= Columns)           /* can happen after screen resize */", "        msg_col = Columns - 1;"], "readability/old_style_comment"]
["src/nvim/message.c", ["      msg_row = Rows - 2;", "      if (msg_col >= Columns)           /* can happen after screen resize */", "        msg_col = Columns - 1;"], "readability/braces"]
["src/nvim/message.c", ["", "      /*", "       * If screen is completely filled and 'more' is set then wait"], "readability/old_style_comment"]
["src/nvim/message.c", ["       */", "      if (lines_left > 0)", "        --lines_left;"], "readability/braces"]
["src/nvim/message.c", ["      if (lines_left > 0)", "        --lines_left;", "      if (p_more && lines_left == 0 && State != HITRETURN"], "readability/increment"]
["src/nvim/message.c", ["          && !msg_no_more && !exmode_active) {", "        if (do_more_prompt(NUL))", "          s = confirm_msg_tail;"], "readability/braces"]
["src/nvim/message.c", ["          s = confirm_msg_tail;", "        if (quit_more)", "          return;"], "readability/braces"]
["src/nvim/message.c", ["", "      /* When we displayed a char in last column need to check if there", "       * is still more. */"], "readability/old_style_comment"]
["src/nvim/message.c", ["       * is still more. */", "      if (did_last_char)", "        continue;"], "readability/braces"]
["src/nvim/message.c", ["               && msg_col + t_col >= Columns - 1)", "    ;", "    if (t_col > 0 && (wrap || *s == '\\r' || *s == '\\b'"], "whitespace/semicolon"]
["src/nvim/message.c", ["", "    if (*s == '\\n') {               /* go to next line */", "      msg_didout = FALSE;           /* remember that line is empty */"], "readability/old_style_comment"]
["src/nvim/message.c", ["    if (*s == '\\n') {               /* go to next line */", "      msg_didout = FALSE;           /* remember that line is empty */", "      if (cmdmsg_rl)"], "readability/old_style_comment"]
["src/nvim/message.c", ["    if (*s == '\\n') {               /* go to next line */", "      msg_didout = FALSE;           /* remember that line is empty */", "      if (cmdmsg_rl)"], "readability/bool"]
["src/nvim/message.c", ["      msg_didout = FALSE;           /* remember that line is empty */", "      if (cmdmsg_rl)", "        msg_col = Columns - 1;"], "readability/braces"]
["src/nvim/message.c", ["        msg_col = Columns - 1;", "      else", "        msg_col = 0;"], "readability/braces"]
["src/nvim/message.c", ["        msg_col = 0;", "      if (++msg_row >= Rows)        /* safety check */", "        msg_row = Rows - 1;"], "readability/old_style_comment"]
["src/nvim/message.c", ["        msg_col = 0;", "      if (++msg_row >= Rows)        /* safety check */", "        msg_row = Rows - 1;"], "readability/braces"]
["src/nvim/message.c", ["        msg_row = Rows - 1;", "    } else if (*s == '\\r') {      /* go to column 0 */", "      msg_col = 0;"], "readability/old_style_comment"]
["src/nvim/message.c", ["      msg_col = 0;", "    } else if (*s == '\\b') {      /* go to previous char */", "      if (msg_col)"], "readability/old_style_comment"]
["src/nvim/message.c", ["    } else if (*s == '\\b') {      /* go to previous char */", "      if (msg_col)", "        --msg_col;"], "readability/braces"]
["src/nvim/message.c", ["      if (msg_col)", "        --msg_col;", "    } else if (*s == TAB) {       /* translate Tab into spaces */"], "readability/increment"]
["src/nvim/message.c", ["        --msg_col;", "    } else if (*s == TAB) {       /* translate Tab into spaces */", "      do {"], "readability/old_style_comment"]
["src/nvim/message.c", ["      } else {", "        /* postpone this character until later */", "        if (t_col == 0)"], "readability/old_style_comment"]
["src/nvim/message.c", ["        /* postpone this character until later */", "        if (t_col == 0)", "          t_s = s;"], "readability/braces"]
["src/nvim/message.c", ["    }", "    ++s;", "  }"], "readability/increment"]
["src/nvim/message.c", ["", "/*", " * Increment \"msg_scrolled\"."], "readability/old_style_comment"]
["src/nvim/message.c", ["  if (*get_vim_var_str(VV_SCROLLSTART) == NUL) {", "    char *p = (char *) sourcing_name;", "    char *tofree = NULL;"], "whitespace/cast"]
["src/nvim/message.c", ["      vim_snprintf(tofree, len, _(\"%s line %\" PRId64),", "                   p, (int64_t) sourcing_lnum);", "      p = tofree;"], "whitespace/cast"]
["src/nvim/message.c", ["    mp->sb_next = NULL;", "  } else if (finish && last_msgchunk != NULL)", "    last_msgchunk->sb_eol = TRUE;"], "readability/braces"]
["src/nvim/message.c", ["  } else if (finish && last_msgchunk != NULL)", "    last_msgchunk->sb_eol = TRUE;", ""], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * Finished showing messages, clear the scroll-back text on the next message."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * \"g<\" command."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  /* Only show something if there is more than one line, otherwise it looks", "   * weird, typing a command without output results in one line. */"], "readability/old_style_comment"]
["src/nvim/message.c", ["    do_more_prompt('G');", "    wait_return(FALSE);", "  }"], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * Move to the start of screen line in already displayed text."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  while (mp != NULL && mp->sb_prev != NULL && !mp->sb_prev->sb_eol)", "    mp = mp->sb_prev;"], "readability/braces"]
["src/nvim/message.c", ["", "/*", " * Mark the last message chunk as finishing the line."], "readability/old_style_comment"]
["src/nvim/message.c", ["{", "  if (last_msgchunk != NULL)", "    last_msgchunk->sb_eol = TRUE;"], "readability/braces"]
["src/nvim/message.c", ["  if (last_msgchunk != NULL)", "    last_msgchunk->sb_eol = TRUE;", "}"], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * Display a screen line from previously displayed text at row \"row\"."], "readability/old_style_comment"]
["src/nvim/message.c", ["    p = mp->sb_text;", "    if (*p == '\\n')         /* don't display the line break */", "      ++p;"], "readability/old_style_comment"]
["src/nvim/message.c", ["    p = mp->sb_text;", "    if (*p == '\\n')         /* don't display the line break */", "      ++p;"], "readability/braces"]
["src/nvim/message.c", ["    if (*p == '\\n')         /* don't display the line break */", "      ++p;", "    msg_puts_display(p, -1, mp->sb_attr, TRUE);"], "readability/increment"]
["src/nvim/message.c", ["      ++p;", "    msg_puts_display(p, -1, mp->sb_attr, TRUE);", "    if (mp->sb_eol || mp->sb_next == NULL)"], "readability/bool"]
["src/nvim/message.c", ["    msg_puts_display(p, -1, mp->sb_attr, TRUE);", "    if (mp->sb_eol || mp->sb_next == NULL)", "      break;"], "readability/braces"]
["src/nvim/message.c", ["", "/*", " * Output any postponed text for msg_puts_attr_len()."], "readability/old_style_comment"]
["src/nvim/message.c", ["  *t_col = 0;", "  /* If the string starts with a composing character don't increment the", "   * column position for it. */"], "readability/old_style_comment"]
["src/nvim/message.c", ["    msg_col = 0;", "    ++msg_row;", "  }"], "readability/increment"]
["src/nvim/message.c", ["", "/*", " * Show the more-prompt and handle the user response."], "readability/old_style_comment"]
["src/nvim/message.c", ["  int c;", "  int retval = FALSE;", "  int toscroll;"], "readability/bool"]
["src/nvim/message.c", ["  if (typed_char == 'G') {", "    /* \"g<\": Find first line on the last page. */", "    mp_last = msg_sb_start(last_msgchunk);"], "readability/old_style_comment"]
["src/nvim/message.c", ["    mp_last = msg_sb_start(last_msgchunk);", "    for (i = 0; i < Rows - 2 && mp_last != NULL", "         && mp_last->sb_prev != NULL; ++i)"], "readability/braces"]
["src/nvim/message.c", ["    for (i = 0; i < Rows - 2 && mp_last != NULL", "         && mp_last->sb_prev != NULL; ++i)", "      mp_last = msg_sb_start(mp_last->sb_prev);"], "readability/increment"]
["src/nvim/message.c", ["  setmouse();", "  if (typed_char == NUL)", "    msg_moremsg(FALSE);"], "readability/braces"]
["src/nvim/message.c", ["  if (typed_char == NUL)", "    msg_moremsg(FALSE);", "  for (;; ) {"], "readability/bool"]
["src/nvim/message.c", ["  for (;; ) {", "    /*", "     * Get a typed character directly from the user."], "readability/old_style_comment"]
["src/nvim/message.c", ["    if (used_typed_char != NUL) {", "      c = used_typed_char;              /* was typed at hit-enter prompt */", "      used_typed_char = NUL;"], "readability/old_style_comment"]
["src/nvim/message.c", ["    switch (c) {", "    case BS:                    /* scroll one line back */", "    case K_BS:"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "    case CAR:                   /* one extra line */", "    case NL:"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "    case 'u':                   /* Up half a page */", "      toscroll = -(Rows / 2);"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "    case 'd':                   /* Down half a page */", "      toscroll = Rows / 2;"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "    case 'b':                   /* one page back */", "    case K_PAGEUP:"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "    case ' ':                   /* one extra page */", "    case 'f':"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "    case 'g':                   /* all the way back to the start */", "      toscroll = -999999;"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "    case 'G':                   /* all the way to the end */", "      toscroll = 999999;"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "    case ':':                   /* start new command line */", "      if (!confirm_msg_used) {"], "readability/old_style_comment"]
["src/nvim/message.c", ["      if (!confirm_msg_used) {", "        /* Since got_int is set all typeahead will be flushed, but we", "         * want to keep this ':', remember that in a special way. */"], "readability/old_style_comment"]
["src/nvim/message.c", ["        typeahead_noflush(':');", "        cmdline_row = Rows - 1;                 /* put ':' on this line */", "        skip_redraw = TRUE;                     /* skip redraw once */"], "readability/old_style_comment"]
["src/nvim/message.c", ["        cmdline_row = Rows - 1;                 /* put ':' on this line */", "        skip_redraw = TRUE;                     /* skip redraw once */", "        need_wait_return = FALSE;               /* don't wait in main() */"], "readability/old_style_comment"]
["src/nvim/message.c", ["        cmdline_row = Rows - 1;                 /* put ':' on this line */", "        skip_redraw = TRUE;                     /* skip redraw once */", "        need_wait_return = FALSE;               /* don't wait in main() */"], "readability/bool"]
["src/nvim/message.c", ["        skip_redraw = TRUE;                     /* skip redraw once */", "        need_wait_return = FALSE;               /* don't wait in main() */", "      }"], "readability/old_style_comment"]
["src/nvim/message.c", ["        skip_redraw = TRUE;                     /* skip redraw once */", "        need_wait_return = FALSE;               /* don't wait in main() */", "      }"], "readability/bool"]
["src/nvim/message.c", ["      if (confirm_msg_used) {", "        /* Jump to the choices of the dialog. */", "        retval = TRUE;"], "readability/old_style_comment"]
["src/nvim/message.c", ["        /* Jump to the choices of the dialog. */", "        retval = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/message.c", ["      } else {", "        got_int = TRUE;", "        quit_more = TRUE;"], "readability/bool"]
["src/nvim/message.c", ["        got_int = TRUE;", "        quit_more = TRUE;", "      }"], "readability/bool"]
["src/nvim/message.c", ["      }", "      /* When there is some more output (wrapping line) display that", "       * without another prompt. */"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "    default:                    /* no valid response */", "      msg_moremsg(TRUE);"], "readability/old_style_comment"]
["src/nvim/message.c", ["    default:                    /* no valid response */", "      msg_moremsg(TRUE);", "      continue;"], "readability/bool"]
["src/nvim/message.c", ["", "        /* go to start of line at top of the screen */", "        for (i = 0; i < Rows - 2 && mp != NULL && mp->sb_prev != NULL;"], "readability/old_style_comment"]
["src/nvim/message.c", ["        /* go to start of line at top of the screen */", "        for (i = 0; i < Rows - 2 && mp != NULL && mp->sb_prev != NULL;", "             ++i)"], "readability/braces"]
["src/nvim/message.c", ["        for (i = 0; i < Rows - 2 && mp != NULL && mp->sb_prev != NULL;", "             ++i)", "          mp = msg_sb_start(mp->sb_prev);"], "readability/increment"]
["src/nvim/message.c", ["            mp = msg_sb_start(mp->sb_prev);", "            if (mp_last == NULL)", "              mp_last = msg_sb_start(last_msgchunk);"], "readability/braces"]
["src/nvim/message.c", ["              mp_last = msg_sb_start(last_msgchunk);", "            else", "              mp_last = msg_sb_start(mp_last->sb_prev);"], "readability/braces"]
["src/nvim/message.c", ["              mp = disp_sb_line(i, mp);", "              ++msg_scrolled;", "            }"], "readability/increment"]
["src/nvim/message.c", ["      } else {", "        /* First display any text that we scrolled back. */", "        while (toscroll > 0 && mp_last != NULL) {"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "      /* display more text, return to caller */", "      lines_left = toscroll;"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Put a character on the screen at the current message position and advance"], "readability/old_style_comment"]
["src/nvim/message.c", ["      msg_col = Columns;", "      ++msg_row;", "    }"], "readability/increment"]
["src/nvim/message.c", ["      msg_col = 0;", "      ++msg_row;", "    }"], "readability/increment"]
["src/nvim/message.c", ["", "/*", " * Repeat the message for the current mode: ASKMORE, EXTERNCMD, CONFIRM or"], "readability/old_style_comment"]
["src/nvim/message.c", ["  if (State == ASKMORE) {", "    msg_moremsg(TRUE);          /* display --more-- message again */", "    msg_row = Rows - 1;"], "readability/old_style_comment"]
["src/nvim/message.c", ["  if (State == ASKMORE) {", "    msg_moremsg(TRUE);          /* display --more-- message again */", "    msg_row = Rows - 1;"], "readability/bool"]
["src/nvim/message.c", ["  } else if (State == CONFIRM) {", "    display_confirm_msg();      /* display \":confirm\" message again */", "    msg_row = Rows - 1;"], "readability/old_style_comment"]
["src/nvim/message.c", ["  } else if (State == EXTERNCMD) {", "    ui_cursor_goto(msg_row, msg_col);     /* put cursor back */", "  } else if (State == HITRETURN || State == SETWSIZE) {"], "readability/old_style_comment"]
["src/nvim/message.c", ["    if (msg_row == Rows - 1) {", "      /* Avoid drawing the \"hit-enter\" prompt below the previous one,", "       * overwrite it.  Esp. useful when regaining focus and a"], "readability/old_style_comment"]
["src/nvim/message.c", ["       * FocusGained autocmd exists but didn't draw anything. */", "      msg_didout = FALSE;", "      msg_col = 0;"], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * Clear from current message position to end of screen."], "readability/old_style_comment"]
["src/nvim/message.c", ["{", "  if (msg_silent == 0)", "    msg_clr_eos_force();"], "readability/braces"]
["src/nvim/message.c", ["", "/*", " * Clear from current message position to end of screen."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Clear the command line."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * end putting a message on the screen"], "readability/old_style_comment"]
["src/nvim/message.c", ["{", "  /*", "   * If the string is larger than the window,"], "readability/old_style_comment"]
["src/nvim/message.c", ["  if (!exiting && need_wait_return && !(State & CMDLINE)) {", "    wait_return(FALSE);", "    return FALSE;"], "readability/bool"]
["src/nvim/message.c", ["    wait_return(FALSE);", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * If the written message runs into the shown command or ruler, we have to"], "readability/old_style_comment"]
["src/nvim/message.c", ["  if (msg_row == Rows - 1 && msg_col >= sc_col) {", "    need_wait_return = TRUE;", "    redraw_cmdline = TRUE;"], "readability/bool"]
["src/nvim/message.c", ["    need_wait_return = TRUE;", "    redraw_cmdline = TRUE;", "  }"], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * May write a string to the redirection file."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  /* Don't do anything for displaying prompts and the like. */", "  if (redir_off)"], "readability/old_style_comment"]
["src/nvim/message.c", ["  /* Don't do anything for displaying prompts and the like. */", "  if (redir_off)", "    return;"], "readability/braces"]
["src/nvim/message.c", ["", "  /* If 'verbosefile' is set prepare for writing in that file. */", "  if (*p_vfile != NUL && verbose_fd == NULL)"], "readability/old_style_comment"]
["src/nvim/message.c", ["  /* If 'verbosefile' is set prepare for writing in that file. */", "  if (*p_vfile != NUL && verbose_fd == NULL)", "    verbose_open();"], "readability/braces"]
["src/nvim/message.c", ["  if (redirecting()) {", "    /* If the string doesn't start with CR or NL, go to msg_col */", "    if (*s != '\\n' && *s != '\\r') {"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "    if (msg_silent != 0)        /* should update msg_col */", "      msg_col = cur_col;"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "    if (msg_silent != 0)        /* should update msg_col */", "      msg_col = cur_col;"], "readability/braces"]
["src/nvim/message.c", ["", "/*", " * Before giving verbose message."], "readability/old_style_comment"]
["src/nvim/message.c", ["{", "  if (*p_vfile != NUL)", "    ++msg_silent;"], "readability/braces"]
["src/nvim/message.c", ["  if (*p_vfile != NUL)", "    ++msg_silent;", "}"], "readability/increment"]
["src/nvim/message.c", ["", "/*", " * After giving verbose message."], "readability/old_style_comment"]
["src/nvim/message.c", ["{", "  if (*p_vfile != NUL)", "    if (--msg_silent < 0)"], "readability/braces"]
["src/nvim/message.c", ["  if (*p_vfile != NUL)", "    if (--msg_silent < 0)", "      msg_silent = 0;"], "readability/braces"]
["src/nvim/message.c", ["", "/*", " * Like verbose_enter() and set msg_scroll when displaying the message."], "readability/old_style_comment"]
["src/nvim/message.c", ["{", "  if (*p_vfile != NUL)", "    ++msg_silent;"], "readability/braces"]
["src/nvim/message.c", ["  if (*p_vfile != NUL)", "    ++msg_silent;", "  else"], "readability/increment"]
["src/nvim/message.c", ["    ++msg_silent;", "  else", "    /* always scroll up, don't overwrite */"], "readability/braces"]
["src/nvim/message.c", ["  else", "    /* always scroll up, don't overwrite */", "    msg_scroll = TRUE;"], "readability/old_style_comment"]
["src/nvim/message.c", ["    /* always scroll up, don't overwrite */", "    msg_scroll = TRUE;", "}"], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * Like verbose_leave() and set cmdline_row when displaying the message."], "readability/old_style_comment"]
["src/nvim/message.c", ["  if (*p_vfile != NUL) {", "    if (--msg_silent < 0)", "      msg_silent = 0;"], "readability/braces"]
["src/nvim/message.c", ["      msg_silent = 0;", "  } else", "    cmdline_row = msg_row;"], "readability/braces"]
["src/nvim/message.c", ["", "/*", " * Called when 'verbosefile' is set: stop writing to the file."], "readability/old_style_comment"]
["src/nvim/message.c", ["  }", "  verbose_did_open = FALSE;", "}"], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * Open the file 'verbosefile'."], "readability/old_style_comment"]
["src/nvim/message.c", ["  if (verbose_fd == NULL && !verbose_did_open) {", "    /* Only give the error message once. */", "    verbose_did_open = TRUE;"], "readability/old_style_comment"]
["src/nvim/message.c", ["    /* Only give the error message once. */", "    verbose_did_open = TRUE;", ""], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * Give a warning message (for searching)."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Advance msg cursor to column \"col\"."], "readability/old_style_comment"]
["src/nvim/message.c", ["{", "  if (msg_silent != 0) {        /* nothing to advance to */", "    msg_col = col;              /* for redirection, may fill it up later */"], "readability/old_style_comment"]
["src/nvim/message.c", ["  if (msg_silent != 0) {        /* nothing to advance to */", "    msg_col = col;              /* for redirection, may fill it up later */", "    return;"], "readability/old_style_comment"]
["src/nvim/message.c", ["  }", "  if (col >= Columns)           /* not enough room */", "    col = Columns - 1;"], "readability/old_style_comment"]
["src/nvim/message.c", ["  }", "  if (col >= Columns)           /* not enough room */", "    col = Columns - 1;"], "readability/braces"]
["src/nvim/message.c", ["    col = Columns - 1;", "  if (cmdmsg_rl)", "    while (msg_col > Columns - col)"], "readability/braces"]
["src/nvim/message.c", ["  if (cmdmsg_rl)", "    while (msg_col > Columns - col)", "      msg_putchar(' ');"], "readability/braces"]
["src/nvim/message.c", ["      msg_putchar(' ');", "  else", "    while (msg_col < col)"], "readability/braces"]
["src/nvim/message.c", ["  else", "    while (msg_col < col)", "      msg_putchar(' ');"], "readability/braces"]
["src/nvim/message.c", ["", "/*", " * Used for \"confirm()\" function, and the :confirm command prefix."], "readability/old_style_comment"]
["src/nvim/message.c", ["int", "do_dialog (", "    int type,"], "whitespace/parens"]
["src/nvim/message.c", ["    char_u *textfield,          /* IObuff for inputdialog(), NULL", "                                           otherwise */", "    int ex_cmd                 /* when TRUE pressing : accepts default and starts"], "whitespace/indent"]
["src/nvim/message.c", ["    int ex_cmd                 /* when TRUE pressing : accepts default and starts", "                               Ex command */", ")"], "whitespace/indent"]
["src/nvim/message.c", ["    int dfltbutton,", "    char_u *textfield,          /* IObuff for inputdialog(), NULL", "                                           otherwise */"], "readability/multiline_comment"]
["src/nvim/message.c", ["    int dfltbutton,", "    char_u *textfield,          /* IObuff for inputdialog(), NULL", "                                           otherwise */"], "readability/old_style_comment"]
["src/nvim/message.c", ["                                           otherwise */", "    int ex_cmd                 /* when TRUE pressing : accepts default and starts", "                               Ex command */"], "readability/multiline_comment"]
["src/nvim/message.c", ["                                           otherwise */", "    int ex_cmd                 /* when TRUE pressing : accepts default and starts", "                               Ex command */"], "readability/old_style_comment"]
["src/nvim/message.c", ["                                           otherwise */", "    int ex_cmd                 /* when TRUE pressing : accepts default and starts", "                               Ex command */"], "whitespace/line_length"]
["src/nvim/message.c", ["                                           otherwise */", "    int ex_cmd                 /* when TRUE pressing : accepts default and starts", "                               Ex command */"], "readability/bool"]
["src/nvim/message.c", ["", "  /*", "   * Since we wait for a keypress, don't make the"], "readability/old_style_comment"]
["src/nvim/message.c", ["   */", "  ++no_wait_return;", "  hotkeys = msg_show_console_dialog(message, buttons, dfltbutton);"], "readability/increment"]
["src/nvim/message.c", ["    switch (c) {", "    case CAR:                 /* User accepts default option */", "    case NL:"], "readability/old_style_comment"]
["src/nvim/message.c", ["      break;", "    case Ctrl_C:              /* User aborts/cancels */", "    case ESC:"], "readability/old_style_comment"]
["src/nvim/message.c", ["      break;", "    default:                  /* Could be a hotkey? */", "      if (c < 0) {            /* special keys are ignored here */"], "readability/old_style_comment"]
["src/nvim/message.c", ["    default:                  /* Could be a hotkey? */", "      if (c < 0) {            /* special keys are ignored here */", "        continue;"], "readability/old_style_comment"]
["src/nvim/message.c", ["      }", "      if (hotkeys[i])", "        break;"], "readability/braces"]
["src/nvim/message.c", ["        break;", "      /* No hotkey match, so keep waiting */", "      continue;"], "readability/old_style_comment"]
["src/nvim/message.c", ["  setmouse();", "  --no_wait_return;", "  msg_end_prompt();"], "readability/increment"]
["src/nvim/message.c", ["", "/*", " * Copy one character from \"*from\" to \"*to\", taking care of multi-byte"], "readability/old_style_comment"]
["src/nvim/message.c", ["  len += (int)(STRLEN(message)", "                + 2                          // for the NL's", "                + STRLEN(buttons)"], "whitespace/alignment"]
["src/nvim/message.c", ["                + 2                          // for the NL's", "                + STRLEN(buttons)", "                + 3);                        // for the \": \" and NUL"], "whitespace/alignment"]
["src/nvim/message.c", ["                + STRLEN(buttons)", "                + 3);                        // for the \": \" and NUL", "  lenhotkey++;                               // for the NUL"], "whitespace/alignment"]
["src/nvim/message.c", ["", "/*", " * Format the dialog string, and display it at the bottom of"], "readability/old_style_comment"]
["src/nvim/message.c", [" */", "static char_u *msg_show_console_dialog(char_u *message, char_u *buttons, int dfltbutton)", "  FUNC_ATTR_NONNULL_RET"], "whitespace/line_length"]
["src/nvim/message.c", ["{", "  bool has_hotkey[HAS_HOTKEY_LEN] = {false};", "  char_u *hotk = console_dialog_alloc(message, buttons, has_hotkey);"], "whitespace/braces"]
["src/nvim/message.c", ["{", "  bool has_hotkey[HAS_HOTKEY_LEN] = {false};", "  char_u *hotk = console_dialog_alloc(message, buttons, has_hotkey);"], "whitespace/braces"]
["src/nvim/message.c", ["///                   has a hotkey", "/// @param[out] hotkeys_ptr Pointer to the memory location where hotkeys will be copied", "static void copy_hotkeys_and_msg(const char_u *message, char_u *buttons,"], "whitespace/line_length"]
["src/nvim/message.c", ["static void copy_hotkeys_and_msg(const char_u *message, char_u *buttons,", "                                 int default_button_idx, const bool has_hotkey[],", "                                 char_u *hotkeys_ptr)"], "whitespace/line_length"]
["src/nvim/message.c", ["      if (*r == DLG_HOTKEY_CHAR) {", "        ++r;", "      }"], "readability/increment"]
["src/nvim/message.c", ["", "/*", " * Display the \":confirm\" message.  Also called when screen resized."], "readability/old_style_comment"]
["src/nvim/message.c", ["{", "  if (do_dialog(type,", "          title == NULL ? (char_u *)_(\"Question\") : title,"], "readability/braces"]
["src/nvim/message.c", ["  if (do_dialog(type,", "          title == NULL ? (char_u *)_(\"Question\") : title,", "          message,"], "whitespace/alignment"]
["src/nvim/message.c", ["          title == NULL ? (char_u *)_(\"Question\") : title,", "          message,", "          (char_u *)_(\"&Yes\\n&No\"), dflt, NULL, FALSE) == 1)"], "whitespace/alignment"]
["src/nvim/message.c", ["          message,", "          (char_u *)_(\"&Yes\\n&No\"), dflt, NULL, FALSE) == 1)", "    return VIM_YES;"], "whitespace/alignment"]
["src/nvim/message.c", ["          message,", "          (char_u *)_(\"&Yes\\n&No\"), dflt, NULL, FALSE) == 1)", "    return VIM_YES;"], "readability/bool"]
["src/nvim/message.c", ["  switch (do_dialog(type,", "              title == NULL ? (char_u *)_(\"Question\") : title,", "              message,"], "whitespace/alignment"]
["src/nvim/message.c", ["              title == NULL ? (char_u *)_(\"Question\") : title,", "              message,", "              (char_u *)_(\"&Yes\\n&No\\n&Cancel\"), dflt, NULL, FALSE)) {"], "whitespace/alignment"]
["src/nvim/message.c", ["              message,", "              (char_u *)_(\"&Yes\\n&No\\n&Cancel\"), dflt, NULL, FALSE)) {", "  case 1: return VIM_YES;"], "whitespace/alignment"]
["src/nvim/message.c", ["              message,", "              (char_u *)_(\"&Yes\\n&No\\n&Cancel\"), dflt, NULL, FALSE)) {", "  case 1: return VIM_YES;"], "readability/bool"]
["src/nvim/message.c", ["", "int vim_dialog_yesnoallcancel(int type, char_u *title, char_u *message, int dflt)", "{"], "whitespace/line_length"]
["src/nvim/message.c", ["  switch (do_dialog(type,", "              title == NULL ? (char_u *)\"Question\" : title,", "              message,"], "whitespace/alignment"]
["src/nvim/message.c", ["              title == NULL ? (char_u *)\"Question\" : title,", "              message,", "              (char_u *)_(\"&Yes\\n&No\\nSave &All\\n&Discard All\\n&Cancel\"),"], "whitespace/alignment"]
["src/nvim/message.c", ["              message,", "              (char_u *)_(\"&Yes\\n&No\\nSave &All\\n&Discard All\\n&Cancel\"),", "              dflt, NULL, FALSE)) {"], "whitespace/alignment"]
["src/nvim/message.c", ["              (char_u *)_(\"&Yes\\n&No\\nSave &All\\n&Discard All\\n&Cancel\"),", "              dflt, NULL, FALSE)) {", "  case 1: return VIM_YES;"], "whitespace/alignment"]
["src/nvim/message.c", ["              (char_u *)_(\"&Yes\\n&No\\nSave &All\\n&Discard All\\n&Cancel\"),", "              dflt, NULL, FALSE)) {", "  case 1: return VIM_YES;"], "readability/bool"]
["src/nvim/message.h", ["", "/*", " * Types of dialogs passed to do_dialog()."], "readability/old_style_comment"]
["src/nvim/message.h", ["#define VIM_QUESTION    4", "#define VIM_LAST_TYPE   4       /* sentinel value */", ""], "readability/old_style_comment"]
["src/nvim/message.h", ["", "/*", " * Return values for functions like vim_dialogyesno()"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "/*", " * misc1.c: functions that didn't seem to fit elsewhere"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "/*", " * get_leader_len() returns the length in bytes of the prefix of the given"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["  int result;", "  int got_com = FALSE;", "  int found_one;"], "readability/bool"]
["src/nvim/misc1.c", ["  int found_one;", "  char_u part_buf[COM_MAX_LEN];         /* buffer for one option part */", "  char_u      *string;                  /* pointer to comment string */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["  char_u part_buf[COM_MAX_LEN];         /* buffer for one option part */", "  char_u      *string;                  /* pointer to comment string */", "  char_u      *list;"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["  result = i = 0;", "  while (ascii_iswhite(line[i]))      /* leading white space is ignored */", "    ++i;"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["  result = i = 0;", "  while (ascii_iswhite(line[i]))      /* leading white space is ignored */", "    ++i;"], "readability/braces"]
["src/nvim/misc1.c", ["  while (ascii_iswhite(line[i]))      /* leading white space is ignored */", "    ++i;", ""], "readability/increment"]
["src/nvim/misc1.c", ["", "  /*", "   * Repeat to match several nested comment strings."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["  while (line[i] != NUL) {", "    /*", "     * scan through the 'comments' option for a match"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["     */", "    found_one = FALSE;", "    for (list = curbuf->b_p_com; *list; ) {"], "readability/bool"]
["src/nvim/misc1.c", ["    for (list = curbuf->b_p_com; *list; ) {", "      /* Get one option part into part_buf[].  Advance \"list\" to next", "       * one.  Put \"string\" at start of string.  */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["       * one.  Put \"string\" at start of string.  */", "      if (!got_com && flags != NULL)", "        *flags = list;              /* remember where flags started */"], "readability/braces"]
["src/nvim/misc1.c", ["      if (!got_com && flags != NULL)", "        *flags = list;              /* remember where flags started */", "      prev_list = list;"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["      string = vim_strchr(part_buf, ':');", "      if (string == NULL)           /* missing ':', ignore this part */", "        continue;"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["      string = vim_strchr(part_buf, ':');", "      if (string == NULL)           /* missing ':', ignore this part */", "        continue;"], "readability/braces"]
["src/nvim/misc1.c", ["        continue;", "      *string++ = NUL;              /* isolate flags from string */", ""], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "      /* If we found a middle match previously, use that match when this", "       * is not a middle or end. */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["       * is not a middle or end. */", "      if (middle_match_len != 0", "          && vim_strchr(part_buf, COM_MIDDLE) == NULL"], "readability/braces"]
["src/nvim/misc1.c", ["", "      /* When we already found a nested comment, only accept further", "       * nested comments. */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["       * nested comments. */", "      if (got_com && vim_strchr(part_buf, COM_NEST) == NULL)", "        continue;"], "readability/braces"]
["src/nvim/misc1.c", ["", "      /* When 'O' flag present and using \"O\" command skip this one. */", "      if (backward && vim_strchr(part_buf, COM_NOBACK) != NULL)"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["      /* When 'O' flag present and using \"O\" command skip this one. */", "      if (backward && vim_strchr(part_buf, COM_NOBACK) != NULL)", "        continue;"], "readability/braces"]
["src/nvim/misc1.c", ["", "      /* Line contents and string must match.", "       * When string starts with white space, must have some white space"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["      if (ascii_iswhite(string[0])) {", "        if (i == 0 || !ascii_iswhite(line[i - 1]))", "          continue;            /* missing white space */"], "readability/braces"]
["src/nvim/misc1.c", ["        if (i == 0 || !ascii_iswhite(line[i - 1]))", "          continue;            /* missing white space */", "        while (ascii_iswhite(string[0]))"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["          continue;            /* missing white space */", "        while (ascii_iswhite(string[0]))", "          ++string;"], "readability/braces"]
["src/nvim/misc1.c", ["        while (ascii_iswhite(string[0]))", "          ++string;", "      }"], "readability/increment"]
["src/nvim/misc1.c", ["      }", "      for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)", "        ;"], "readability/braces"]
["src/nvim/misc1.c", ["      }", "      for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)", "        ;"], "readability/increment"]
["src/nvim/misc1.c", ["      for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)", "        ;", "      if (string[j] != NUL)"], "whitespace/semicolon"]
["src/nvim/misc1.c", ["        ;", "      if (string[j] != NUL)", "        continue;          /* string doesn't match */"], "readability/braces"]
["src/nvim/misc1.c", ["      if (string[j] != NUL)", "        continue;          /* string doesn't match */", ""], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "      /* When 'b' flag used, there must be white space or an", "       * end-of-line after the string in the line. */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["       * end-of-line after the string in the line. */", "      if (vim_strchr(part_buf, COM_BLANK) != NULL", "          && !ascii_iswhite(line[i + j]) && line[i + j] != NUL)"], "readability/braces"]
["src/nvim/misc1.c", ["", "      /* We have found a match, stop searching unless this is a middle", "       * comment. The middle comment can be a substring of the end"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["      }", "      if (middle_match_len != 0 && j > middle_match_len)", "        /* Use this match instead of the middle match, since it's a"], "readability/braces"]
["src/nvim/misc1.c", ["      if (middle_match_len != 0 && j > middle_match_len)", "        /* Use this match instead of the middle match, since it's a", "         * longer thus better match. */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "      if (middle_match_len == 0)", "        i += j;"], "readability/braces"]
["src/nvim/misc1.c", ["        i += j;", "      found_one = TRUE;", "      break;"], "readability/bool"]
["src/nvim/misc1.c", ["    if (middle_match_len != 0) {", "      /* Use the previously found middle match after failing to find a", "       * match with an end. */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["       * match with an end. */", "      if (!got_com && flags != NULL)", "        *flags = saved_flags;"], "readability/braces"]
["src/nvim/misc1.c", ["      i += middle_match_len;", "      found_one = TRUE;", "    }"], "readability/bool"]
["src/nvim/misc1.c", ["", "    /* No match found, stop scanning. */", "    if (!found_one)"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["    /* No match found, stop scanning. */", "    if (!found_one)", "      break;"], "readability/braces"]
["src/nvim/misc1.c", ["", "    /* Include any trailing white space. */", "    while (ascii_iswhite(line[i]))"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["    /* Include any trailing white space. */", "    while (ascii_iswhite(line[i]))", "      ++i;"], "readability/braces"]
["src/nvim/misc1.c", ["    while (ascii_iswhite(line[i]))", "      ++i;", ""], "readability/increment"]
["src/nvim/misc1.c", ["", "    if (include_space)", "      result = i;"], "readability/braces"]
["src/nvim/misc1.c", ["", "    /* If this comment doesn't nest, stop here. */", "    got_com = TRUE;"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["    /* If this comment doesn't nest, stop here. */", "    got_com = TRUE;", "    if (vim_strchr(part_buf, COM_NEST) == NULL)"], "readability/bool"]
["src/nvim/misc1.c", ["    got_com = TRUE;", "    if (vim_strchr(part_buf, COM_NEST) == NULL)", "      break;"], "readability/braces"]
["src/nvim/misc1.c", ["", "/*", " * Return the offset at which the last comment in line starts. If there is no"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["  int found_one;", "  char_u part_buf[COM_MAX_LEN];         /* buffer for one option part */", ""], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "  /*", "   * Repeat to match several nested comment strings."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["  while (--i >= lower_check_bound) {", "    /*", "     * scan through the 'comments' option for a match"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["     */", "    found_one = FALSE;", "    for (list = curbuf->b_p_com; *list; ) {"], "readability/bool"]
["src/nvim/misc1.c", ["", "      /*", "       * Get one option part into part_buf[].  Advance list to next one."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["      string = vim_strchr(part_buf, ':');", "      if (string == NULL) {     /* If everything is fine, this cannot actually", "                                 * happen. */"], "readability/multiline_comment"]
["src/nvim/misc1.c", ["      string = vim_strchr(part_buf, ':');", "      if (string == NULL) {     /* If everything is fine, this cannot actually", "                                 * happen. */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["      }", "      *string++ = NUL;          /* Isolate flags from string. */", "      com_leader = string;"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "      /*", "       * Line contents and string must match."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["      if (ascii_iswhite(string[0])) {", "        if (i == 0 || !ascii_iswhite(line[i - 1]))", "          continue;"], "readability/braces"]
["src/nvim/misc1.c", ["      }", "      for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)", "        /* do nothing */;"], "readability/braces"]
["src/nvim/misc1.c", ["      }", "      for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)", "        /* do nothing */;"], "readability/increment"]
["src/nvim/misc1.c", ["      for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)", "        /* do nothing */;", "      if (string[j] != NUL)"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["      for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)", "        /* do nothing */;", "      if (string[j] != NUL)"], "whitespace/semicolon"]
["src/nvim/misc1.c", ["        /* do nothing */;", "      if (string[j] != NUL)", "        continue;"], "readability/braces"]
["src/nvim/misc1.c", ["", "      /*", "       * When 'b' flag used, there must be white space or an"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "      /*", "       * We have found a match, stop searching."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["       */", "      found_one = TRUE;", ""], "readability/bool"]
["src/nvim/misc1.c", ["", "      if (flags)", "        *flags = flags_save;"], "readability/braces"]
["src/nvim/misc1.c", ["    if (found_one) {", "      char_u part_buf2[COM_MAX_LEN];            /* buffer for one option part */", "      int len1, len2, off;"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["      result = i;", "      /*", "       * If this comment nests, continue searching."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["       */", "      if (vim_strchr(part_buf, COM_NEST) != NULL)", "        continue;"], "readability/braces"]
["src/nvim/misc1.c", ["", "      /* Let's verify whether the comment leader found is a substring", "       * of other comment leaders. If it is, let's adjust the"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "      while (ascii_iswhite(*com_leader))", "        ++com_leader;"], "readability/braces"]
["src/nvim/misc1.c", ["      while (ascii_iswhite(*com_leader))", "        ++com_leader;", "      len1 = (int)STRLEN(com_leader);"], "readability/increment"]
["src/nvim/misc1.c", ["        (void)copy_option_part(&list, part_buf2, COM_MAX_LEN, \",\");", "        if (flags_save == com_flags)", "          continue;"], "readability/braces"]
["src/nvim/misc1.c", ["        string = vim_strchr(part_buf2, ':');", "        ++string;", "        while (ascii_iswhite(*string))"], "readability/increment"]
["src/nvim/misc1.c", ["        ++string;", "        while (ascii_iswhite(*string))", "          ++string;"], "readability/braces"]
["src/nvim/misc1.c", ["        while (ascii_iswhite(*string))", "          ++string;", "        len2 = (int)STRLEN(string);"], "readability/increment"]
["src/nvim/misc1.c", ["        len2 = (int)STRLEN(string);", "        if (len2 == 0)", "          continue;"], "readability/braces"]
["src/nvim/misc1.c", ["", "        /* Now we have to verify whether string ends with a substring", "         * beginning the com_leader. */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["        for (off = (len2 > i ? i : len2); off > 0 && off + len1 > len2; ) {", "          --off;", "          if (!STRNCMP(string + off, com_leader, len2 - off)) {"], "readability/increment"]
["src/nvim/misc1.c", ["          if (!STRNCMP(string + off, com_leader, len2 - off)) {", "            if (i - off < lower_check_bound)", "              lower_check_bound = i - off;"], "readability/braces"]
["src/nvim/misc1.c", ["", "/*", " * Return the number of window lines occupied by buffer line \"lnum\"."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["{", "  /* Check for filler lines above this buffer line.  When folded the result", "   * is one line anyway. */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "/*", " * Return number of window lines physical line \"lnum\" will occupy in window"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "  s = ml_get_buf(wp->w_buffer, lnum, FALSE);", "  if (*s == NUL)                /* empty line */"], "readability/bool"]
["src/nvim/misc1.c", ["  s = ml_get_buf(wp->w_buffer, lnum, FALSE);", "  if (*s == NUL)                /* empty line */", "    return 1;"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["  s = ml_get_buf(wp->w_buffer, lnum, FALSE);", "  if (*s == NUL)                /* empty line */", "    return 1;"], "readability/braces"]
["src/nvim/misc1.c", ["", "  /*", "   * Add column offset for 'number', 'relativenumber' and 'foldcolumn'."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "/*", " * Like plines_win(), but only reports the number of physical screen lines"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "  if (!wp->w_p_wrap)", "    return lines + 1;"], "readability/braces"]
["src/nvim/misc1.c", ["  lines += 1;", "  if (col > width)", "    lines += (col - width) / (width + win_col_off2(wp)) + 1;"], "readability/braces"]
["src/nvim/misc1.c", ["", "/*", " * check_status: called when the status bars for the buffer 'buf'"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["    if (wp->w_buffer == buf && wp->w_status_height) {", "      wp->w_redr_status = TRUE;", "      if (must_redraw < VALID) {"], "readability/bool"]
["src/nvim/misc1.c", ["", "/*", " * Return TRUE if \"c\" is a mouse key."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "/*", " * Get a key stroke directly from the user."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["    ui_flush();", "    /* Leave some room for check_termcode() to insert a key code into (max", "     * 5 chars plus NUL).  And fix_input_buffer() can triple the number of"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "    /* First time: blocking wait.  Second time: wait up to 100ms for a", "     * terminal code to complete. */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["      waited = 0;", "    } else if (len > 0)", "      ++waited;             /* keep track of the waiting time */"], "readability/braces"]
["src/nvim/misc1.c", ["    } else if (len > 0)", "      ++waited;             /* keep track of the waiting time */", ""], "readability/old_style_comment"]
["src/nvim/misc1.c", ["    } else if (len > 0)", "      ++waited;             /* keep track of the waiting time */", ""], "readability/increment"]
["src/nvim/misc1.c", ["", "    /* Handle modifier and/or special key code. */", "    n = buf[0];"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["          ) {", "        if (buf[1] == KS_MODIFIER)", "          mod_mask = buf[2];"], "readability/braces"]
["src/nvim/misc1.c", ["        len -= 3;", "        if (len > 0)", "          memmove(buf, buf + 3, (size_t)len);"], "readability/braces"]
["src/nvim/misc1.c", ["", "/*", " * Get a number from the user."], "readability/old_style_comment"]
["src/nvim/misc1.c", [" */", "int ", "get_number ("], "whitespace/end_of_line"]
["src/nvim/misc1.c", ["int ", "get_number (", "    int colon,                              /* allow colon to abort */"], "whitespace/parens"]
["src/nvim/misc1.c", ["get_number (", "    int colon,                              /* allow colon to abort */", "    int *mouse_used"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "  if (mouse_used != NULL)", "    *mouse_used = FALSE;"], "readability/braces"]
["src/nvim/misc1.c", ["  if (mouse_used != NULL)", "    *mouse_used = FALSE;", ""], "readability/bool"]
["src/nvim/misc1.c", ["", "  /* When not printing messages, the user won't know what to type, return a", "   * zero (as if CR was hit). */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["   * zero (as if CR was hit). */", "  if (msg_silent != 0)", "    return 0;"], "readability/braces"]
["src/nvim/misc1.c", ["      msg_putchar(c);", "      ++typed;", "    } else if (c == K_DEL || c == K_KDEL || c == K_BS || c == Ctrl_H) {"], "readability/increment"]
["src/nvim/misc1.c", ["        MSG_PUTS(\"\\b \\b\");", "        --typed;", "      }"], "readability/increment"]
["src/nvim/misc1.c", ["    } else if (mouse_used != NULL && c == K_LEFTMOUSE) {", "      *mouse_used = TRUE;", "      n = mouse_row + 1;"], "readability/bool"]
["src/nvim/misc1.c", ["      stuffcharReadbuff(':');", "      if (!exmode_active)", "        cmdline_row = msg_row;"], "readability/braces"]
["src/nvim/misc1.c", ["        cmdline_row = msg_row;", "      skip_redraw = TRUE;           /* skip redraw once */", "      do_redraw = FALSE;"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["        cmdline_row = msg_row;", "      skip_redraw = TRUE;           /* skip redraw once */", "      do_redraw = FALSE;"], "readability/bool"]
["src/nvim/misc1.c", ["      skip_redraw = TRUE;           /* skip redraw once */", "      do_redraw = FALSE;", "      break;"], "readability/bool"]
["src/nvim/misc1.c", ["      break;", "    } else if (c == CAR || c == NL || c == Ctrl_C || c == ESC)", "      break;"], "readability/braces"]
["src/nvim/misc1.c", ["", "/*", " * Ask the user to enter a number."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "  /* When using \":silent\" assume that <CR> was entered. */", "  if (mouse_used != NULL)"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["  /* When using \":silent\" assume that <CR> was entered. */", "  if (mouse_used != NULL)", "    MSG_PUTS(_(\"Type number and <Enter> or click with mouse (empty cancels): \"));"], "readability/braces"]
["src/nvim/misc1.c", ["  if (mouse_used != NULL)", "    MSG_PUTS(_(\"Type number and <Enter> or click with mouse (empty cancels): \"));", "  else"], "whitespace/line_length"]
["src/nvim/misc1.c", ["    MSG_PUTS(_(\"Type number and <Enter> or click with mouse (empty cancels): \"));", "  else", "    MSG_PUTS(_(\"Type number and <Enter> (empty cancels): \"));"], "readability/braces"]
["src/nvim/misc1.c", ["", "  /* Set the state such that text can be selected/copied/pasted and we still", "   * get mouse events. */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "  i = get_number(TRUE, mouse_used);", "  if (KeyTyped) {"], "readability/bool"]
["src/nvim/misc1.c", ["", "  if (global_busy           /* no messages now, wait until global is finished */", "      || !messaging())        /* 'lazyredraw' set, don't do messages now */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "  if (global_busy           /* no messages now, wait until global is finished */", "      || !messaging())        /* 'lazyredraw' set, don't do messages now */"], "readability/braces"]
["src/nvim/misc1.c", ["  if (global_busy           /* no messages now, wait until global is finished */", "      || !messaging())        /* 'lazyredraw' set, don't do messages now */", "    return;"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "  /* We don't want to overwrite another important message, but do overwrite", "   * a previous \"more lines\" or \"fewer lines\" message, so that \"5dd\" and"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["   * then \"put\" reports the last action. */", "  if (keep_msg != NULL && !keep_msg_more)", "    return;"], "readability/braces"]
["src/nvim/misc1.c", ["", "  if (n > 0)", "    pn = n;"], "readability/braces"]
["src/nvim/misc1.c", ["    pn = n;", "  else", "    pn = -n;"], "readability/braces"]
["src/nvim/misc1.c", ["    if (pn == 1) {", "      if (n > 0)", "        STRLCPY(msg_buf, _(\"1 more line\"), MSG_BUF_LEN);"], "readability/braces"]
["src/nvim/misc1.c", ["        STRLCPY(msg_buf, _(\"1 more line\"), MSG_BUF_LEN);", "      else", "        STRLCPY(msg_buf, _(\"1 line less\"), MSG_BUF_LEN);"], "readability/braces"]
["src/nvim/misc1.c", ["    } else {", "      if (n > 0)", "        vim_snprintf((char *)msg_buf, MSG_BUF_LEN,"], "readability/braces"]
["src/nvim/misc1.c", ["        vim_snprintf((char *)msg_buf, MSG_BUF_LEN,", "            _(\"%\" PRId64 \" more lines\"), (int64_t)pn);", "      else"], "whitespace/alignment"]
["src/nvim/misc1.c", ["            _(\"%\" PRId64 \" more lines\"), (int64_t)pn);", "      else", "        vim_snprintf((char *)msg_buf, MSG_BUF_LEN,"], "readability/braces"]
["src/nvim/misc1.c", ["        vim_snprintf((char *)msg_buf, MSG_BUF_LEN,", "            _(\"%\" PRId64 \" fewer lines\"), (int64_t)pn);", "    }"], "whitespace/alignment"]
["src/nvim/misc1.c", ["      set_keep_msg(msg_buf, 0);", "      keep_msg_more = TRUE;", "    }"], "readability/bool"]
["src/nvim/misc1.c", ["", "/*", " * flush map and typeahead buffers and give a warning for an error"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "/*", " * Find all user names for user completion."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["{", "  static int lazy_init_done = FALSE;", ""], "readability/bool"]
["src/nvim/misc1.c", ["", "  lazy_init_done = TRUE;", "  "], "readability/bool"]
["src/nvim/misc1.c", ["  lazy_init_done = TRUE;", "  ", "  os_get_usernames(&ga_users);"], "whitespace/end_of_line"]
["src/nvim/misc1.c", ["", "/*", " * Function given to ExpandGeneric() to obtain an user names."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["  init_users();", "  if (idx < ga_users.ga_len)", "    return ((char_u **)ga_users.ga_data)[idx];"], "readability/braces"]
["src/nvim/misc1.c", ["", "/*", " * Check whether name matches a user name. Return:"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["  for (int i = 0; i < ga_users.ga_len; i++) {", "    if (STRCMP(((char_u **)ga_users.ga_data)[i], name) == 0)", "      return 2;       /* full match */"], "readability/braces"]
["src/nvim/misc1.c", ["    if (STRCMP(((char_u **)ga_users.ga_data)[i], name) == 0)", "      return 2;       /* full match */", "    if (STRNCMP(((char_u **)ga_users.ga_data)[i], name, n) == 0)"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["      return 2;       /* full match */", "    if (STRNCMP(((char_u **)ga_users.ga_data)[i], name, n) == 0)", "      result = 1;       /* partial match */"], "readability/braces"]
["src/nvim/misc1.c", ["    if (STRNCMP(((char_u **)ga_users.ga_data)[i], name, n) == 0)", "      result = 1;       /* partial match */", "  }"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "/*", " * Check for CTRL-C pressed, but only once in a while."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "/*", " * Like line_breakcheck() but check 10 times less often."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "  /*", "   * Call the shell to execute the command (errors are ignored)."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["   */", "  ++no_check_timestamps;", "  call_shell(command, kShellOptDoOut | kShellOptExpand | flags, NULL);"], "readability/increment"]
["src/nvim/misc1.c", ["  call_shell(command, kShellOptDoOut | kShellOptExpand | flags, NULL);", "  --no_check_timestamps;", ""], "readability/increment"]
["src/nvim/misc1.c", ["  } else if (ret_len == NULL) {", "    /* Change NUL into SOH, otherwise the string is truncated. */", "    for (i = 0; i < len; ++i)"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["    /* Change NUL into SOH, otherwise the string is truncated. */", "    for (i = 0; i < len; ++i)", "      if (buffer[i] == NUL)"], "readability/braces"]
["src/nvim/misc1.c", ["    /* Change NUL into SOH, otherwise the string is truncated. */", "    for (i = 0; i < len; ++i)", "      if (buffer[i] == NUL)"], "readability/increment"]
["src/nvim/misc1.c", ["    for (i = 0; i < len; ++i)", "      if (buffer[i] == NUL)", "        buffer[i] = 1;"], "readability/braces"]
["src/nvim/misc1.c", ["", "    buffer[len] = NUL;          /* make sure the buffer is terminated */", "  } else {"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "/*", " * Free the list of files returned by expand_wildcards() or other expansion"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["{", "  if (count <= 0 || files == NULL)", "    return;"], "readability/braces"]
["src/nvim/misc1.c", ["    return;", "  while (count--)", "    xfree(files[count]);"], "readability/braces"]
["src/nvim/misc1.c", ["", "/*", " * Return TRUE when need to go to Insert mode because of 'insertmode'."], "readability/old_style_comment"]
["src/nvim/misc1.h", ["", "/* flags for open_line() */", "#define OPENLINE_DELSPACES  1   /* delete spaces after cursor */"], "readability/old_style_comment"]
["src/nvim/misc1.h", ["/* flags for open_line() */", "#define OPENLINE_DELSPACES  1   /* delete spaces after cursor */", "#define OPENLINE_DO_COM     2   /* format comments */"], "readability/old_style_comment"]
["src/nvim/misc1.h", ["#define OPENLINE_DELSPACES  1   /* delete spaces after cursor */", "#define OPENLINE_DO_COM     2   /* format comments */", "#define OPENLINE_KEEPTRAIL  4   /* keep trailing spaces */"], "readability/old_style_comment"]
["src/nvim/misc1.h", ["#define OPENLINE_DO_COM     2   /* format comments */", "#define OPENLINE_KEEPTRAIL  4   /* keep trailing spaces */", "#define OPENLINE_MARKFIX    8   /* fix mark positions */"], "readability/old_style_comment"]
["src/nvim/misc1.h", ["#define OPENLINE_KEEPTRAIL  4   /* keep trailing spaces */", "#define OPENLINE_MARKFIX    8   /* fix mark positions */", "#define OPENLINE_COM_LIST  16   /* format comments with list/2nd line indent */"], "readability/old_style_comment"]
["src/nvim/misc1.h", ["#define OPENLINE_MARKFIX    8   /* fix mark positions */", "#define OPENLINE_COM_LIST  16   /* format comments with list/2nd line indent */", ""], "readability/old_style_comment"]
["src/nvim/mouse.c", ["    // status line and no dragging happened.", "    if (dragwin != NULL && !did_drag)", "      flags &= ~(MOUSE_FOCUS | MOUSE_DID_MOVE);"], "readability/braces"]
["src/nvim/mouse.c", ["", "  if (flags & MOUSE_SETPOS)", "    goto retnomove;                             // ugly goto..."], "readability/braces"]
["src/nvim/mouse.c", ["  if (!(flags & MOUSE_FOCUS)) {", "    if (row < 0 || col < 0)                     // check if it makes sense", "      return IN_UNKNOWN;"], "readability/braces"]
["src/nvim/mouse.c", ["    if (on_status_line && on_sep_line) {", "      if (stl_connected(wp))", "        on_sep_line = 0;"], "readability/braces"]
["src/nvim/mouse.c", ["        on_sep_line = 0;", "      else", "        on_status_line = 0;"], "readability/braces"]
["src/nvim/mouse.c", ["    // (MOUSE_FOCUS was set above if we dragged first).", "    if (dragwin == NULL || (flags & MOUSE_RELEASED))", "      win_enter(wp, true);                      // can make wp invalid!"], "readability/braces"]
["src/nvim/mouse.c", ["    // set topline, to be able to check for double click ourselves", "    if (curwin != old_curwin)", "      set_mouse_topline(curwin);"], "readability/braces"]
["src/nvim/mouse.c", ["      // Don't use start_arrow() if we're in the same window", "      if (curwin == old_curwin)", "        return IN_STATUS_LINE;"], "readability/braces"]
["src/nvim/mouse.c", ["        return IN_STATUS_LINE;", "      else", "        return IN_STATUS_LINE | CURSOR_MOVED;"], "readability/braces"]
["src/nvim/mouse.c", ["      // Don't use start_arrow() if we're in the same window", "      if (curwin == old_curwin)", "        return IN_SEP_LINE;"], "readability/braces"]
["src/nvim/mouse.c", ["        return IN_SEP_LINE;", "      else", "        return IN_SEP_LINE | CURSOR_MOVED;"], "readability/braces"]
["src/nvim/mouse.c", ["      for (first = true; curwin->w_topline > 1; ) {", "        if (curwin->w_topfill < diff_check(curwin, curwin->w_topline))", "          ++count;"], "readability/braces"]
["src/nvim/mouse.c", ["        if (curwin->w_topfill < diff_check(curwin, curwin->w_topline))", "          ++count;", "        else"], "readability/increment"]
["src/nvim/mouse.c", ["          ++count;", "        else", "          count += plines(curwin->w_topline - 1);"], "readability/braces"]
["src/nvim/mouse.c", ["          count += plines(curwin->w_topline - 1);", "        if (!first && count > -row)", "          break;"], "readability/braces"]
["src/nvim/mouse.c", ["        if (curwin->w_topfill < diff_check(curwin, curwin->w_topline)) {", "          ++curwin->w_topfill;", "        } else {"], "readability/increment"]
["src/nvim/mouse.c", ["        } else {", "          --curwin->w_topline;", "          curwin->w_topfill = 0;"], "readability/increment"]
["src/nvim/mouse.c", ["        if (curwin->w_topfill > 0) {", "          ++count;", "        } else {"], "readability/increment"]
["src/nvim/mouse.c", ["        if (curwin->w_topfill > 0) {", "          --curwin->w_topfill;", "        } else {"], "readability/increment"]
["src/nvim/mouse.c", ["        } else {", "          ++curwin->w_topline;", "          curwin->w_topfill ="], "readability/increment"]
["src/nvim/mouse.c", ["    row -= count;", "    ++lnum;", "  }"], "readability/increment"]
["src/nvim/mouse.c", ["    off = win_col_off(win) - win_col_off2(win);", "    if (col < off)", "      col = off;"], "readability/braces"]
["src/nvim/mouse.c", ["  for (;; ) {", "    if (fp->fr_layout == FR_LEAF)", "      break;"], "readability/braces"]
["src/nvim/mouse.c", ["      for (fp = fp->fr_child; fp->fr_next != NULL; fp = fp->fr_next) {", "        if (*colp < fp->fr_width)", "          break;"], "readability/braces"]
["src/nvim/mouse.c", ["      for (fp = fp->fr_child; fp->fr_next != NULL; fp = fp->fr_next) {", "        if (*rowp < fp->fr_height)", "          break;"], "readability/braces"]
["src/nvim/move.c", ["", "/*", " * move.c: Functions for moving the cursor and scrolling text."], "readability/old_style_comment"]
["src/nvim/move.c", ["typedef struct {", "  linenr_T lnum;                /* line number */", "  int fill;                     /* filler lines */"], "readability/old_style_comment"]
["src/nvim/move.c", ["  linenr_T lnum;                /* line number */", "  int fill;                     /* filler lines */", "  int height;                   /* height of added line */"], "readability/old_style_comment"]
["src/nvim/move.c", ["  int fill;                     /* filler lines */", "  int height;                   /* height of added line */", "} lineoff_T;"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Compute wp->w_botline for the current wp->w_topline.  Can be called after"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * If w_cline_row is valid, start there."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /* wp->w_botline is the line that is just below the window */", "  wp->w_botline = lnum;"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Update curwin->w_topline and redraw if necessary."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Update curwin->w_topline to move the cursor onto the screen."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "      /* If we weren't very close to begin with, we scroll to put the", "       * cursor in the middle of the window.  Otherwise put the cursor"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * If the cursor is below the bottom of the window, scroll the window"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "          /* Cursor is (a few lines) above botline, check if there are", "           * 'scrolloff' window lines below the cursor.  If not, need to"], "readability/old_style_comment"]
["src/nvim/move.c", ["        } else {", "          /* sufficient context, no need to scroll */", "          check_botline = false;"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * Need to redraw when topline changed."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Update win->w_topline to move the cursor onto the screen."], "readability/old_style_comment"]
["src/nvim/move.c", [" */", "void update_topline_win(win_T* win)", "{"], "whitespace/operators"]
["src/nvim/move.c", ["", "/*", " * Return the scrolljump value to use for the current window."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Return true when there are not 'scrolloff' lines above the cursor for the"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Check if the cursor has moved.  Set the w_valid flag accordingly."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Call this function when some window settings have changed, which require"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Set wp->w_topline to a certain number."], "readability/old_style_comment"]
["src/nvim/move.c", ["{", "  /* go to first of folded lines */", "  (void)hasFoldingWin(wp, lnum, &lnum, NULL, true, NULL);"], "readability/old_style_comment"]
["src/nvim/move.c", ["  (void)hasFoldingWin(wp, lnum, &lnum, NULL, true, NULL);", "  /* Approximate the value of w_botline */", "  wp->w_botline += lnum - wp->w_topline;"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Call this function when the length of the cursor line (in screen"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Call this function when the length of a line (in screen characters) above"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Make sure the value of curwin->w_botline is valid."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Mark curwin->w_botline as invalid (because of some change in the buffer)."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Return true if curwin->w_wrow and curwin->w_wcol are valid."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Validate cursor position.  Makes sure w_wrow and w_wcol are valid."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Compute wp->w_cline_row and wp->w_cline_height, based on the current value"], "readability/old_style_comment"]
["src/nvim/move.c", ["{", "  /* Check if wp->w_lines[].wl_size is invalid */", "  int all_invalid = (!redrawing()"], "readability/old_style_comment"]
["src/nvim/move.c", ["  wp->w_cline_row = 0;", "  for (linenr_T lnum = wp->w_topline; lnum < wp->w_cursor.lnum; ++i) {", "    bool valid = false;"], "readability/increment"]
["src/nvim/move.c", ["    if (!all_invalid && i < wp->w_lines_valid) {", "      if (wp->w_lines[i].wl_lnum < lnum || !wp->w_lines[i].wl_valid)", "        continue;                       /* skip changed or deleted lines */"], "readability/braces"]
["src/nvim/move.c", ["      if (wp->w_lines[i].wl_lnum < lnum || !wp->w_lines[i].wl_valid)", "        continue;                       /* skip changed or deleted lines */", "      if (wp->w_lines[i].wl_lnum == lnum) {"], "readability/old_style_comment"]
["src/nvim/move.c", ["      if (wp->w_lines[i].wl_lnum == lnum) {", "        /* Check for newly inserted lines below this row, in which", "         * case we need to check for folded lines. */"], "readability/old_style_comment"]
["src/nvim/move.c", ["         * case we need to check for folded lines. */", "        if (!wp->w_buffer->b_mod_set", "            || wp->w_lines[i].wl_lastlnum < wp->w_cursor.lnum"], "readability/braces"]
["src/nvim/move.c", ["            || wp->w_lines[i].wl_lastlnum < wp->w_cursor.lnum", "                                            || wp->w_buffer->b_mod_top", "                                            > wp->w_lines[i].wl_lastlnum + 1)"], "whitespace/alignment"]
["src/nvim/move.c", ["                                            || wp->w_buffer->b_mod_top", "                                            > wp->w_lines[i].wl_lastlnum + 1)", "          valid = true;"], "whitespace/alignment"]
["src/nvim/move.c", ["      } else if (wp->w_lines[i].wl_lnum > lnum) {", "        --i;                            /* hold at inserted lines */", "      }"], "readability/old_style_comment"]
["src/nvim/move.c", ["      } else if (wp->w_lines[i].wl_lnum > lnum) {", "        --i;                            /* hold at inserted lines */", "      }"], "readability/increment"]
["src/nvim/move.c", ["      lnum = wp->w_lines[i].wl_lastlnum + 1;", "      /* Cursor inside folded lines, don't count this row */", "      if (lnum > wp->w_cursor.lnum)"], "readability/old_style_comment"]
["src/nvim/move.c", ["      /* Cursor inside folded lines, don't count this row */", "      if (lnum > wp->w_cursor.lnum)", "        break;"], "readability/braces"]
["src/nvim/move.c", ["    } else if (i > wp->w_lines_valid) {", "      /* a line that is too long to fit on the last screen line */", "      wp->w_cline_height = 0;"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Validate curwin->w_virtcol only."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Validate wp->w_virtcol only."], "readability/old_style_comment"]
["src/nvim/move.c", ["    wp->w_valid |= VALID_VIRTCOL;", "    if (wp->w_p_cuc", "        && !pum_visible()"], "readability/braces"]
["src/nvim/move.c", ["", "/*", " * Validate curwin->w_cline_height only."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Validate w_wcol and w_virtcol only."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Compute offset of a window, occupied by absolute or relative line number,"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Return the difference in column offset for the second screen line of a"], "readability/old_style_comment"]
["src/nvim/move.c", ["{", "  if ((wp->w_p_nu || wp->w_p_rnu) && vim_strchr(p_cpo, CPO_NUMCOL) != NULL)", "    return number_width(wp) + 1;"], "readability/braces"]
["src/nvim/move.c", ["", "  /*", "   * First make sure that w_topline is valid (after moving the cursor)."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * Compute the number of virtual columns."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /* remove '$' from change command when cursor moves onto it */", "  if (startcol > dollar_vcol)"], "readability/old_style_comment"]
["src/nvim/move.c", ["  /* remove '$' from change command when cursor moves onto it */", "  if (startcol > dollar_vcol)", "    dollar_vcol = -1;"], "readability/braces"]
["src/nvim/move.c", ["", "      /* When cursor wraps to first char of next line in Insert", "       * mode, the 'showbreak' string isn't shown, backup to first"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "      /* When far off or not enough room on either side, put cursor in", "       * middle of window. */"], "readability/old_style_comment"]
["src/nvim/move.c", ["      }", "      if (new_leftcol < 0)", "        new_leftcol = 0;"], "readability/braces"]
["src/nvim/move.c", ["", "  /* Skip over filler lines.  At the top use w_topfill, there", "   * may be some filler lines above the window. */"], "readability/old_style_comment"]
["src/nvim/move.c", ["      ) {", "    /* Cursor past end of screen.  Happens with a single line that does", "     * not fit on screen.  Find a skipcol to show the text around the"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /* Make sure w_topline is at the first of a sequence of folded lines. */", "  (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);"], "readability/old_style_comment"]
["src/nvim/move.c", ["  (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);", "  validate_cursor();            /* w_wrow needs to be valid */", "  while (line_count-- > 0) {"], "readability/old_style_comment"]
["src/nvim/move.c", ["    } else {", "      if (curwin->w_topline == 1)", "        break;"], "readability/braces"]
["src/nvim/move.c", ["        break;", "      --curwin->w_topline;", "      curwin->w_topfill = 0;"], "readability/increment"]
["src/nvim/move.c", ["      curwin->w_topfill = 0;", "      /* A sequence of folded lines only counts for one logical line */", "      linenr_T first;"], "readability/old_style_comment"]
["src/nvim/move.c", ["      if (hasFolding(curwin->w_topline, &first, NULL)) {", "        ++done;", "        if (!byfold)"], "readability/increment"]
["src/nvim/move.c", ["        ++done;", "        if (!byfold)", "          line_count -= curwin->w_topline - first - 1;"], "readability/braces"]
["src/nvim/move.c", ["        curwin->w_topline = first;", "      } else", "        done += plines_nofill(curwin->w_topline);"], "readability/braces"]
["src/nvim/move.c", ["    }", "    --curwin->w_botline;                /* approximate w_botline */", "    invalidate_botline();"], "readability/old_style_comment"]
["src/nvim/move.c", ["    }", "    --curwin->w_botline;                /* approximate w_botline */", "    invalidate_botline();"], "readability/increment"]
["src/nvim/move.c", ["  }", "  curwin->w_wrow += done;               /* keep w_wrow updated */", "  curwin->w_cline_row += done;          /* keep w_cline_row updated */"], "readability/old_style_comment"]
["src/nvim/move.c", ["  curwin->w_wrow += done;               /* keep w_wrow updated */", "  curwin->w_cline_row += done;          /* keep w_cline_row updated */", ""], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  if (curwin->w_cursor.lnum == curwin->w_topline)", "    curwin->w_cline_row = 0;"], "readability/braces"]
["src/nvim/move.c", ["", "  /*", "   * Compute the row number of the last row of the cursor line"], "readability/old_style_comment"]
["src/nvim/move.c", ["    if (hasFolding(curwin->w_cursor.lnum, &first, NULL)) {", "      --wrow;", "      if (first == 1)"], "readability/increment"]
["src/nvim/move.c", ["      --wrow;", "      if (first == 1)", "        curwin->w_cursor.lnum = 1;"], "readability/braces"]
["src/nvim/move.c", ["        curwin->w_cursor.lnum = 1;", "      else", "        curwin->w_cursor.lnum = first - 1;"], "readability/braces"]
["src/nvim/move.c", ["        curwin->w_cursor.lnum = first - 1;", "    } else", "      wrow -= plines(curwin->w_cursor.lnum--);"], "readability/braces"]
["src/nvim/move.c", ["  if (moved) {", "    /* Move cursor to first line of closed fold. */", "    foldAdjustCursor();"], "readability/old_style_comment"]
["src/nvim/move.c", ["    while (line_count--) {", "      if (curwin->w_topfill > 0)", "        --curwin->w_topfill;"], "readability/braces"]
["src/nvim/move.c", ["      if (curwin->w_topfill > 0)", "        --curwin->w_topfill;", "      else {"], "readability/increment"]
["src/nvim/move.c", ["        --curwin->w_topfill;", "      else {", "        if (byfold)"], "readability/braces"]
["src/nvim/move.c", ["        --curwin->w_topfill;", "      else {", "        if (byfold)"], "readability/braces"]
["src/nvim/move.c", ["      else {", "        if (byfold)", "          (void)hasFolding(lnum, NULL, &lnum);"], "readability/braces"]
["src/nvim/move.c", ["          (void)hasFolding(lnum, NULL, &lnum);", "        if (lnum >= curbuf->b_ml.ml_line_count)", "          break;"], "readability/braces"]
["src/nvim/move.c", ["          break;", "        ++lnum;", "        curwin->w_topfill = diff_check_fill(curwin, lnum);"], "readability/increment"]
["src/nvim/move.c", ["    }", "    /* approximate w_botline */", "    curwin->w_botline += lnum - curwin->w_topline;"], "readability/old_style_comment"]
["src/nvim/move.c", ["    curwin->w_topline += line_count;", "    curwin->w_botline += line_count;            /* approximate w_botline */", "  }"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  if (curwin->w_topline > curbuf->b_ml.ml_line_count)", "    curwin->w_topline = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/move.c", ["    curwin->w_topline = curbuf->b_ml.ml_line_count;", "  if (curwin->w_botline > curbuf->b_ml.ml_line_count + 1)", "    curwin->w_botline = curbuf->b_ml.ml_line_count + 1;"], "readability/braces"]
["src/nvim/move.c", ["", "  if (hasAnyFolding(curwin))", "    /* Make sure w_topline is at the first of a sequence of folded lines. */"], "readability/braces"]
["src/nvim/move.c", ["  if (hasAnyFolding(curwin))", "    /* Make sure w_topline is at the first of a sequence of folded lines. */", "    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Don't end up with too many filler lines in the window."], "readability/old_style_comment"]
["src/nvim/move.c", [" */", "void ", "check_topfill ("], "whitespace/end_of_line"]
["src/nvim/move.c", ["void ", "check_topfill (", "    win_T *wp,"], "whitespace/parens"]
["src/nvim/move.c", ["    win_T *wp,", "    bool down              /* when true scroll down when not enough space */", ")"], "readability/old_style_comment"]
["src/nvim/move.c", ["      if (down && wp->w_topline > 1) {", "        --wp->w_topline;", "        wp->w_topfill = 0;"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Use as many filler lines as possible for w_topline.  Make sure w_topline"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Scroll the screen one line down, but don't do it if it would move the"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  if (curwin->w_topline <= 1", "      && !can_fill"], "readability/braces"]
["src/nvim/move.c", ["", "  validate_cursor();        /* w_wrow needs to be valid */", ""], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * Compute the row number of the last row of the cursor line"], "readability/old_style_comment"]
["src/nvim/move.c", ["  int end_row = curwin->w_wrow;", "  if (can_fill)", "    ++end_row;"], "readability/braces"]
["src/nvim/move.c", ["  if (can_fill)", "    ++end_row;", "  else"], "readability/increment"]
["src/nvim/move.c", ["    ++end_row;", "  else", "    end_row += plines_nofill(curwin->w_topline - 1);"], "readability/braces"]
["src/nvim/move.c", ["    if (can_fill) {", "      ++curwin->w_topfill;", "      check_topfill(curwin, true);"], "readability/increment"]
["src/nvim/move.c", ["    } else {", "      --curwin->w_topline;", "      curwin->w_topfill = 0;"], "readability/increment"]
["src/nvim/move.c", ["    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);", "    --curwin->w_botline;            /* approximate w_botline */", "    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);"], "readability/old_style_comment"]
["src/nvim/move.c", ["    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);", "    --curwin->w_botline;            /* approximate w_botline */", "    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Scroll the screen one line up, but don't do it if it would move the cursor"], "readability/old_style_comment"]
["src/nvim/move.c", ["{", "  if (curwin->w_topline == curbuf->b_ml.ml_line_count", "      && curwin->w_topfill == 0"], "readability/braces"]
["src/nvim/move.c", ["", "  validate_cursor();        /* w_wrow needs to be valid */", ""], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * Compute the row number of the first row of the cursor line"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Add one line above \"lp->lnum\".  This can be a filler line, a closed fold or"], "readability/old_style_comment"]
["src/nvim/move.c", ["  } else {", "    --lp->lnum;", "    lp->fill = 0;"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Add one line below \"lp->lnum\".  This can be a filler line, a closed fold or"], "readability/old_style_comment"]
["src/nvim/move.c", ["  } else {", "    ++lp->lnum;", "    lp->fill = 0;"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Switch from including filler lines below lp->lnum to including filler"], "readability/old_style_comment"]
["src/nvim/move.c", ["  if (lp->fill > 0) {", "    ++lp->lnum;", "    lp->fill = diff_check_fill(curwin, lp->lnum) - lp->fill + 1;"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Switch from including filler lines above lp->lnum to including filler"], "readability/old_style_comment"]
["src/nvim/move.c", ["    lp->fill = diff_check_fill(curwin, lp->lnum) - lp->fill + 1;", "    --lp->lnum;", "  }"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Recompute topline to put the cursor at the top of the window."], "readability/old_style_comment"]
["src/nvim/move.c", ["  int scrolled = 0;", "  linenr_T top;                 /* just above displayed lines */", "  linenr_T bot;                 /* just below displayed lines */"], "readability/old_style_comment"]
["src/nvim/move.c", ["  linenr_T top;                 /* just above displayed lines */", "  linenr_T bot;                 /* just below displayed lines */", "  linenr_T old_topline = curwin->w_topline;"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  if (mouse_dragging > 0)", "    off = mouse_dragging - 1;"], "readability/braces"]
["src/nvim/move.c", ["", "  /*", "   * Decrease topline until:"], "readability/old_style_comment"]
["src/nvim/move.c", ["  if (hasFolding(curwin->w_cursor.lnum, &top, &bot)) {", "    --top;", "    ++bot;"], "readability/increment"]
["src/nvim/move.c", ["    --top;", "    ++bot;", "  } else {"], "readability/increment"]
["src/nvim/move.c", ["", "  /*", "   * Check if the lines from \"top\" to \"bot\" fit in the window.  If they do,"], "readability/old_style_comment"]
["src/nvim/move.c", ["    if (extra + i <= off && bot < curbuf->b_ml.ml_line_count) {", "      if (hasFolding(bot, NULL, &bot))", "        /* count one logical line for a sequence of folded lines */"], "readability/braces"]
["src/nvim/move.c", ["      if (hasFolding(bot, NULL, &bot))", "        /* count one logical line for a sequence of folded lines */", "        ++used;"], "readability/old_style_comment"]
["src/nvim/move.c", ["        /* count one logical line for a sequence of folded lines */", "        ++used;", "      else"], "readability/increment"]
["src/nvim/move.c", ["        ++used;", "      else", "        used += plines(bot);"], "readability/braces"]
["src/nvim/move.c", ["", "    /*", "     * If scrolling is needed, scroll at least 'sj' lines."], "readability/old_style_comment"]
["src/nvim/move.c", ["     */", "    if ((new_topline >= curwin->w_topline || scrolled > min_scroll)", "        && extra >= off)"], "readability/braces"]
["src/nvim/move.c", ["    new_topline = top;", "    --top;", "    ++bot;"], "readability/increment"]
["src/nvim/move.c", ["    --top;", "    ++bot;", "  }"], "readability/increment"]
["src/nvim/move.c", ["", "  /*", "   * If we don't have enough space, put cursor in the middle."], "readability/old_style_comment"]
["src/nvim/move.c", ["  } else {", "    /*", "     * If \"always\" is false, only adjust topline to a lower value, higher"], "readability/old_style_comment"]
["src/nvim/move.c", ["     */", "    if (new_topline < curwin->w_topline || always)", "      curwin->w_topline = new_topline;"], "readability/braces"]
["src/nvim/move.c", ["      curwin->w_topline = new_topline;", "    if (curwin->w_topline > curwin->w_cursor.lnum)", "      curwin->w_topline = curwin->w_cursor.lnum;"], "readability/braces"]
["src/nvim/move.c", ["      curwin->w_topfill -= extra - off;", "      if (curwin->w_topfill < 0)", "        curwin->w_topfill = 0;"], "readability/braces"]
["src/nvim/move.c", ["    check_topfill(curwin, false);", "    if (curwin->w_topline != old_topline", "        || curwin->w_topfill != old_topfill"], "readability/braces"]
["src/nvim/move.c", ["", "/*", " * Set w_empty_rows and w_filler_rows for window \"wp\", having used up \"used\""], "readability/old_style_comment"]
["src/nvim/move.c", ["      wp->w_filler_rows = diff_check_fill(wp, wp->w_botline);", "      if (wp->w_empty_rows > wp->w_filler_rows)", "        wp->w_empty_rows -= wp->w_filler_rows;"], "readability/braces"]
["src/nvim/move.c", ["        wp->w_empty_rows -= wp->w_filler_rows;", "      else {", "        wp->w_filler_rows = wp->w_empty_rows;"], "readability/braces"]
["src/nvim/move.c", ["        wp->w_empty_rows -= wp->w_filler_rows;", "      else {", "        wp->w_filler_rows = wp->w_empty_rows;"], "readability/braces"]
["src/nvim/move.c", ["", "/*", " * Recompute topline to put the cursor at the bottom of the window."], "readability/old_style_comment"]
["src/nvim/move.c", ["    curwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;", "    if (curwin->w_topline != old_topline", "        || curwin->w_topfill != old_topfill"], "readability/braces"]
["src/nvim/move.c", ["", "  /* The lines of the cursor line itself are always used. */", "  used = plines_nofill(cln);"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /* If the cursor is below botline, we will at least scroll by the height", "   * of the cursor line.  Correct for empty lines, which are really part of"], "readability/old_style_comment"]
["src/nvim/move.c", ["    scrolled = used;", "    if (cln == curwin->w_botline)", "      scrolled -= curwin->w_empty_rows;"], "readability/braces"]
["src/nvim/move.c", ["", "  /*", "   * Stop counting lines to scroll when"], "readability/old_style_comment"]
["src/nvim/move.c", ["  while (loff.lnum > 1) {", "    /* Stop when scrolled nothing or at least \"min_scroll\", found \"extra\"", "     * context for 'scrolloff' and counted all lines below the window. */"], "readability/old_style_comment"]
["src/nvim/move.c", ["        ) {", "      /* Count screen lines that are below the window. */", "      scrolled += loff.height;"], "readability/old_style_comment"]
["src/nvim/move.c", ["            ) {", "          /* Count screen lines that are below the window. */", "          scrolled += boff.height;"], "readability/old_style_comment"]
["src/nvim/move.c", ["          scrolled += boff.height;", "          if (boff.lnum == curwin->w_botline", "              && boff.fill == 0"], "readability/braces"]
["src/nvim/move.c", ["      i += boff.height;", "      ++line_count;", "    }"], "readability/increment"]
["src/nvim/move.c", ["    }", "    if (i < scrolled)           /* below curwin->w_botline, don't scroll */", "      line_count = 9999;"], "readability/old_style_comment"]
["src/nvim/move.c", ["    }", "    if (i < scrolled)           /* below curwin->w_botline, don't scroll */", "      line_count = 9999;"], "readability/braces"]
["src/nvim/move.c", ["", "  /*", "   * Scroll up if the cursor is off the bottom of the screen a bit."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * If topline didn't change we need to restore w_botline and w_empty_rows"], "readability/old_style_comment"]
["src/nvim/move.c", ["  while (topline > 1) {", "    if (below <= above) {           /* add a line below the cursor first */", "      if (boff.lnum < curbuf->b_ml.ml_line_count) {"], "readability/old_style_comment"]
["src/nvim/move.c", ["      } else {", "        ++below;                    /* count a \"~\" line */", "        if (atend)"], "readability/old_style_comment"]
["src/nvim/move.c", ["      } else {", "        ++below;                    /* count a \"~\" line */", "        if (atend)"], "readability/increment"]
["src/nvim/move.c", ["        ++below;                    /* count a \"~\" line */", "        if (atend)", "          ++used;"], "readability/braces"]
["src/nvim/move.c", ["        if (atend)", "          ++used;", "      }"], "readability/increment"]
["src/nvim/move.c", ["  }", "  if (!hasFolding(topline, &curwin->w_topline, NULL))", "    curwin->w_topline = topline;"], "readability/braces"]
["src/nvim/move.c", ["", "/*", " * Correct the cursor position so that it is in a part of the screen at least"], "readability/old_style_comment"]
["src/nvim/move.c", ["{", "  /*", "   * How many lines we would like to have above/below the cursor depends on"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * If there are sufficient file-lines above and below the cursor, we can"], "readability/old_style_comment"]
["src/nvim/move.c", ["   */", "  linenr_T cln = curwin->w_cursor.lnum; /* Cursor Line Number */", "  if (cln >= curwin->w_topline + above_wanted"], "readability/old_style_comment"]
["src/nvim/move.c", ["  linenr_T cln = curwin->w_cursor.lnum; /* Cursor Line Number */", "  if (cln >= curwin->w_topline + above_wanted", "      && cln < curwin->w_botline - below_wanted"], "readability/braces"]
["src/nvim/move.c", ["", "  /*", "   * Narrow down the area where the cursor can be put by taking lines from"], "readability/old_style_comment"]
["src/nvim/move.c", ["  linenr_T botline = curwin->w_botline - 1;", "  /* count filler lines as context */", "  int above = curwin->w_topfill; /* screen lines above topline */"], "readability/old_style_comment"]
["src/nvim/move.c", ["  /* count filler lines as context */", "  int above = curwin->w_topfill; /* screen lines above topline */", "  int below = curwin->w_filler_rows; /* screen lines below botline */"], "readability/old_style_comment"]
["src/nvim/move.c", ["  int above = curwin->w_topfill; /* screen lines above topline */", "  int below = curwin->w_filler_rows; /* screen lines below botline */", "  while ((above < above_wanted || below < below_wanted) && topline < botline) {"], "readability/old_style_comment"]
["src/nvim/move.c", ["    if (below < below_wanted && (below <= above || above >= above_wanted)) {", "      if (hasFolding(botline, &botline, NULL))", "        ++below;"], "readability/braces"]
["src/nvim/move.c", ["      if (hasFolding(botline, &botline, NULL))", "        ++below;", "      else"], "readability/increment"]
["src/nvim/move.c", ["        ++below;", "      else", "        below += plines(botline);"], "readability/braces"]
["src/nvim/move.c", ["        below += plines(botline);", "      --botline;", "    }"], "readability/increment"]
["src/nvim/move.c", ["    if (above < above_wanted && (above < below || below >= below_wanted)) {", "      if (hasFolding(topline, NULL, &topline))", "        ++above;"], "readability/braces"]
["src/nvim/move.c", ["      if (hasFolding(topline, NULL, &topline))", "        ++above;", "      else"], "readability/increment"]
["src/nvim/move.c", ["        ++above;", "      else", "        above += plines_nofill(topline);"], "readability/braces"]
["src/nvim/move.c", ["", "      /* Count filler lines below this line as context. */", "      if (topline < botline)"], "readability/old_style_comment"]
["src/nvim/move.c", ["      /* Count filler lines below this line as context. */", "      if (topline < botline)", "        above += diff_check_fill(curwin, topline + 1);"], "readability/braces"]
["src/nvim/move.c", ["        above += diff_check_fill(curwin, topline + 1);", "      ++topline;", "    }"], "readability/increment"]
["src/nvim/move.c", ["  }", "  if (topline == botline || botline == 0)", "    curwin->w_cursor.lnum = topline;"], "readability/braces"]
["src/nvim/move.c", ["    curwin->w_cursor.lnum = topline;", "  else if (topline > botline)", "    curwin->w_cursor.lnum = botline;"], "readability/braces"]
["src/nvim/move.c", ["    curwin->w_cursor.lnum = botline;", "  else {", "    if (cln < topline && curwin->w_topline > 1) {"], "readability/braces"]
["src/nvim/move.c", ["    curwin->w_cursor.lnum = botline;", "  else {", "    if (cln < topline && curwin->w_topline > 1) {"], "readability/braces"]
["src/nvim/move.c", ["", "/*", " * move screen 'count' pages up or down and update screen"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  if (curbuf->b_ml.ml_line_count == 1) {    /* nothing to do */", "    beep_flush();"], "readability/old_style_comment"]
["src/nvim/move.c", ["           diff_check_fill(curwin, curwin->w_topline)", "           )) {", "      beep_flush();"], "whitespace/parens"]
["src/nvim/move.c", ["      if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1) {", "        /* Vi compatible scrolling */", "        if (p_window <= 2)"], "readability/old_style_comment"]
["src/nvim/move.c", ["        /* Vi compatible scrolling */", "        if (p_window <= 2)", "          ++curwin->w_topline;"], "readability/braces"]
["src/nvim/move.c", ["        if (p_window <= 2)", "          ++curwin->w_topline;", "        else"], "readability/increment"]
["src/nvim/move.c", ["          ++curwin->w_topline;", "        else", "          curwin->w_topline += p_window - 2;"], "readability/braces"]
["src/nvim/move.c", ["          curwin->w_topline += p_window - 2;", "        if (curwin->w_topline > curbuf->b_ml.ml_line_count)", "          curwin->w_topline = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/move.c", ["      } else if (curwin->w_botline > curbuf->b_ml.ml_line_count) {", "        /* at end of file */", "        curwin->w_topline = curbuf->b_ml.ml_line_count;"], "readability/old_style_comment"]
["src/nvim/move.c", ["      } else {", "        /* For the overlap, start with the line just below the window", "         * and go upwards. */"], "readability/old_style_comment"]
["src/nvim/move.c", ["      }", "    } else {  /* dir == BACKWARDS */", "      if (curwin->w_topline == 1) {"], "readability/old_style_comment"]
["src/nvim/move.c", ["      if (curwin->w_topline == 1) {", "        /* Include max number of filler lines */", "        max_topfill();"], "readability/old_style_comment"]
["src/nvim/move.c", ["      if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1) {", "        /* Vi compatible scrolling (sort of) */", "        if (p_window <= 2)"], "readability/old_style_comment"]
["src/nvim/move.c", ["        /* Vi compatible scrolling (sort of) */", "        if (p_window <= 2)", "          --curwin->w_topline;"], "readability/braces"]
["src/nvim/move.c", ["        if (p_window <= 2)", "          --curwin->w_topline;", "        else"], "readability/increment"]
["src/nvim/move.c", ["          --curwin->w_topline;", "        else", "          curwin->w_topline -= p_window - 2;"], "readability/braces"]
["src/nvim/move.c", ["          curwin->w_topline -= p_window - 2;", "        if (curwin->w_topline < 1)", "          curwin->w_topline = 1;"], "readability/braces"]
["src/nvim/move.c", ["        curwin->w_cursor.lnum = curwin->w_topline + p_window - 1;", "        if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)", "          curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/move.c", ["", "      /* Find the line at the top of the window that is going to be the", "       * line at the bottom of the window.  Make sure this results in"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "      /* Find the line just above the new topline to get the right line", "       * at the bottom of the window. */"], "readability/old_style_comment"]
["src/nvim/move.c", ["      }", "      if (loff.lnum < 1) {                      /* at begin of file */", "        curwin->w_topline = 1;"], "readability/old_style_comment"]
["src/nvim/move.c", ["      } else {", "        /* Go two lines forward again. */", "        topline_botline(&loff);"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "        /* Always scroll at least one line.  Avoid getting stuck on", "         * very long lines. */"], "readability/old_style_comment"]
["src/nvim/move.c", ["            ) {", "          /* First try using the maximum number of filler lines.  If", "           * that's not enough, backup one line. */"], "readability/old_style_comment"]
["src/nvim/move.c", ["          loff.fill = curwin->w_topfill;", "          if (curwin->w_topfill < diff_check_fill(curwin,", "                  curwin->w_topline))"], "readability/braces"]
["src/nvim/move.c", ["          if (curwin->w_topfill < diff_check_fill(curwin,", "                  curwin->w_topline))", "            max_topfill();"], "whitespace/alignment"]
["src/nvim/move.c", ["          if (curwin->w_topfill == loff.fill) {", "            --curwin->w_topline;", "            curwin->w_topfill = 0;"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Decide how much overlap to use for page-up or page-down scrolling."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  if (lp->fill > 0)", "    lp->height = 1;"], "readability/braces"]
["src/nvim/move.c", ["    lp->height = 1;", "  else", "    lp->height = plines_nofill(lp->lnum);"], "readability/braces"]
["src/nvim/move.c", ["  int h1 = lp->height;", "  if (h1 > min_height)", "    return;             /* no overlap */"], "readability/braces"]
["src/nvim/move.c", ["  if (h1 > min_height)", "    return;             /* no overlap */", ""], "readability/old_style_comment"]
["src/nvim/move.c", ["  if (h2 == MAXCOL || h2 + h1 > min_height) {", "    *lp = loff0;        /* no overlap */", "    return;"], "readability/old_style_comment"]
["src/nvim/move.c", ["  if (h3 == MAXCOL || h3 + h2 > min_height) {", "    *lp = loff0;        /* no overlap */", "    return;"], "readability/old_style_comment"]
["src/nvim/move.c", ["  int h4 = lp->height;", "  if (h4 == MAXCOL || h4 + h3 + h2 > min_height || h3 + h2 + h1 > min_height)", "    *lp = loff1;        /* 1 line overlap */"], "readability/braces"]
["src/nvim/move.c", ["  if (h4 == MAXCOL || h4 + h3 + h2 > min_height || h3 + h2 + h1 > min_height)", "    *lp = loff1;        /* 1 line overlap */", "  else"], "readability/old_style_comment"]
["src/nvim/move.c", ["    *lp = loff1;        /* 1 line overlap */", "  else", "    *lp = loff2;        /* 2 lines overlap */"], "readability/braces"]
["src/nvim/move.c", ["  else", "    *lp = loff2;        /* 2 lines overlap */", "  return;"], "readability/old_style_comment"]
["src/nvim/move.c", ["  if (flag) {", "    /*", "     * scroll the text up"], "readability/old_style_comment"]
["src/nvim/move.c", ["        n -= i;", "        if (n < 0 && scrolled > 0)", "          break;"], "readability/braces"]
["src/nvim/move.c", ["        (void)hasFolding(curwin->w_topline, NULL, &curwin->w_topline);", "        ++curwin->w_topline;", "        curwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);"], "readability/increment"]
["src/nvim/move.c", ["        if (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count) {", "          ++curwin->w_cursor.lnum;", "          curwin->w_valid &="], "readability/increment"]
["src/nvim/move.c", ["", "      /*", "       * Correct w_botline for changed w_topline."], "readability/old_style_comment"]
["src/nvim/move.c", ["       */", "      if (curwin->w_p_diff)", "        curwin->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);"], "readability/braces"]
["src/nvim/move.c", ["        curwin->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);", "      else {", "        room += i;"], "readability/braces"]
["src/nvim/move.c", ["        curwin->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);", "      else {", "        room += i;"], "readability/braces"]
["src/nvim/move.c", ["          i = plines(curwin->w_botline);", "          if (i > room)", "            break;"], "readability/braces"]
["src/nvim/move.c", ["          (void)hasFolding(curwin->w_botline, NULL,", "              &curwin->w_botline);", "          ++curwin->w_botline;"], "whitespace/alignment"]
["src/nvim/move.c", ["              &curwin->w_botline);", "          ++curwin->w_botline;", "          room -= i;"], "readability/increment"]
["src/nvim/move.c", ["          (void)hasFolding(curwin->w_cursor.lnum, NULL,", "              &curwin->w_cursor.lnum);", "          ++curwin->w_cursor.lnum;"], "whitespace/alignment"]
["src/nvim/move.c", ["              &curwin->w_cursor.lnum);", "          ++curwin->w_cursor.lnum;", "        }"], "readability/increment"]
["src/nvim/move.c", ["        }", "      } else", "        curwin->w_cursor.lnum += n;"], "readability/braces"]
["src/nvim/move.c", ["  } else {", "    /*", "     * scroll the text down"], "readability/old_style_comment"]
["src/nvim/move.c", ["        n -= i;", "        if (n < 0 && scrolled > 0)", "          break;"], "readability/braces"]
["src/nvim/move.c", ["          break;", "        --curwin->w_topline;", "        (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);"], "readability/increment"]
["src/nvim/move.c", ["      if (curwin->w_cursor.lnum > 1) {", "        --curwin->w_cursor.lnum;", "        curwin->w_valid &= ~(VALID_VIRTCOL|VALID_CHEIGHT|VALID_WCOL);"], "readability/increment"]
["src/nvim/move.c", ["    if (n > 0) {", "      if (curwin->w_cursor.lnum <= (linenr_T)n)", "        curwin->w_cursor.lnum = 1;"], "readability/braces"]
["src/nvim/move.c", ["        curwin->w_cursor.lnum = 1;", "      else if (hasAnyFolding(curwin)) {", "        while (--n >= 0 && curwin->w_cursor.lnum > 1) {"], "readability/braces"]
["src/nvim/move.c", ["        while (--n >= 0 && curwin->w_cursor.lnum > 1) {", "          --curwin->w_cursor.lnum;", "          (void)hasFolding(curwin->w_cursor.lnum,"], "readability/increment"]
["src/nvim/move.c", ["          (void)hasFolding(curwin->w_cursor.lnum,", "              &curwin->w_cursor.lnum, NULL);", "        }"], "whitespace/alignment"]
["src/nvim/move.c", ["        }", "      } else", "        curwin->w_cursor.lnum -= n;"], "readability/braces"]
["src/nvim/move.c", ["  }", "  /* Move cursor to first line of closed fold. */", "  foldAdjustCursor();"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * loop through the cursorbound windows"], "readability/old_style_comment"]
["src/nvim/move.c", ["    curbuf = curwin->w_buffer;", "    /* skip original window  and windows with 'noscrollbind' */", "    if (curwin != old_curwin && curwin->w_p_crb) {"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "      /* Make sure the cursor is in a valid position.  Temporarily set", "       * \"restart_edit\" to allow the cursor to be beyond the EOL. */"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * reset current-window"], "readability/old_style_comment"]
["src/nvim/msgpack_rpc/helpers.c", ["    if (!msgpack_rpc_to_string(&obj->via.map.ptr[i].key,", "          &arg->items[i].key)) {", "      return false;"], "whitespace/alignment"]
["src/nvim/msgpack_rpc/helpers.c", ["    if (!msgpack_rpc_to_object(&obj->via.map.ptr[i].val,", "          &arg->items[i].value)) {", "      return false;"], "whitespace/alignment"]
["src/nvim/msgpack_rpc/server.c", ["  snprintf(template, ADDRESS_MAX_SIZE,", "    \"\\\\\\\\.\\\\pipe\\\\nvim-%\" PRIu64 \"-%\" PRIu32, os_get_pid(), count++);", "  return xstrdup(template);"], "whitespace/alignment"]
["src/nvim/normal.c", ["#include \"nvim/ui.h\"", "#include \"nvim/mouse.h\"", "#include \"nvim/undo.h\""], "build/include"]
["src/nvim/normal.c", ["", "/*", " * The Visual area is remembered for reselection."], "readability/old_style_comment"]
["src/nvim/normal.c", [" */", "static int resel_VIsual_mode = NUL;             /* 'v', 'V', or Ctrl-V */", "static linenr_T resel_VIsual_line_count;        /* number of lines */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["static int resel_VIsual_mode = NUL;             /* 'v', 'V', or Ctrl-V */", "static linenr_T resel_VIsual_line_count;        /* number of lines */", "static colnr_T resel_VIsual_vcol;               /* nr of cols or end col */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["static linenr_T resel_VIsual_line_count;        /* number of lines */", "static colnr_T resel_VIsual_vcol;               /* nr of cols or end col */", "static int VIsual_mode_orig = NUL;              /* saved Visual mode */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["static colnr_T resel_VIsual_vcol;               /* nr of cols or end col */", "static int VIsual_mode_orig = NUL;              /* saved Visual mode */", ""], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * nv_*(): functions called to handle Normal and Visual mode commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Function to be called for a Normal or Visual mode command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/* Values for cmd_flags. */", "#define NV_NCH      0x01          /* may need to get a second char */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["/* Values for cmd_flags. */", "#define NV_NCH      0x01          /* may need to get a second char */", "#define NV_NCH_NOP  (0x02|NV_NCH) /* get second char when no operator pending */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["#define NV_NCH      0x01          /* may need to get a second char */", "#define NV_NCH_NOP  (0x02|NV_NCH) /* get second char when no operator pending */", "#define NV_NCH_ALW  (0x04|NV_NCH) /* always get a second char */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["#define NV_NCH_NOP  (0x02|NV_NCH) /* get second char when no operator pending */", "#define NV_NCH_ALW  (0x04|NV_NCH) /* always get a second char */", "#define NV_LANG     0x08        /* second char needs language adjustment */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["#define NV_NCH_ALW  (0x04|NV_NCH) /* always get a second char */", "#define NV_LANG     0x08        /* second char needs language adjustment */", ""], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "#define NV_SS       0x10        /* may start selection */", "#define NV_SSS      0x20        /* may start selection with shift modifier */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["#define NV_SS       0x10        /* may start selection */", "#define NV_SSS      0x20        /* may start selection with shift modifier */", "#define NV_STS      0x40        /* may stop selection without shift modif. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["#define NV_SSS      0x20        /* may start selection with shift modifier */", "#define NV_STS      0x40        /* may stop selection without shift modif. */", "#define NV_RL       0x80        /* 'rightleft' modifies command */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["#define NV_STS      0x40        /* may stop selection without shift modif. */", "#define NV_RL       0x80        /* 'rightleft' modifies command */", "#define NV_KEEPREG  0x100       /* don't clear regname */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["#define NV_RL       0x80        /* 'rightleft' modifies command */", "#define NV_KEEPREG  0x100       /* don't clear regname */", "#define NV_NCW      0x200       /* not allowed in command-line window */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["#define NV_KEEPREG  0x100       /* don't clear regname */", "#define NV_NCW      0x200       /* not allowed in command-line window */", ""], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Generally speaking, every Normal mode command should either clear any"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * This table contains one entry for every Normal or Visual mode command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["static const struct nv_cmd {", "  int cmd_char;                 /* (first) command character */", "  nv_func_T cmd_func;           /* function for this command */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  int cmd_char;                 /* (first) command character */", "  nv_func_T cmd_func;           /* function for this command */", "  uint16_t cmd_flags;           /* NV_ flags */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  nv_func_T cmd_func;           /* function for this command */", "  uint16_t cmd_flags;           /* NV_ flags */", "  short cmd_arg;                /* value for ca.arg */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  uint16_t cmd_flags;           /* NV_ flags */", "  short cmd_arg;                /* value for ca.arg */", "} nv_cmds[] ="], "readability/old_style_comment"]
["src/nvim/normal.c", ["  uint16_t cmd_flags;           /* NV_ flags */", "  short cmd_arg;                /* value for ca.arg */", "} nv_cmds[] ="], "runtime/int"]
["src/nvim/normal.c", ["", "/* Number of commands in nv_cmds[]. */", "#define NV_CMDS_SIZE ARRAY_SIZE(nv_cmds)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/* Sorted index of commands in nv_cmds[]. */", "static short nv_cmd_idx[NV_CMDS_SIZE];"], "readability/old_style_comment"]
["src/nvim/normal.c", ["/* Sorted index of commands in nv_cmds[]. */", "static short nv_cmd_idx[NV_CMDS_SIZE];", ""], "runtime/int"]
["src/nvim/normal.c", ["", "/* The highest index for which", " * nv_cmds[idx].cmd_char == nv_cmd_idx[nv_cmds[idx].cmd_char] */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Compare functions for qsort() below, that checks the command character"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* The commands are sorted on absolute value. */", "  c1 = nv_cmds[*(const short *)s1].cmd_char;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* The commands are sorted on absolute value. */", "  c1 = nv_cmds[*(const short *)s1].cmd_char;", "  c2 = nv_cmds[*(const short *)s2].cmd_char;"], "runtime/int"]
["src/nvim/normal.c", ["  c1 = nv_cmds[*(const short *)s1].cmd_char;", "  c2 = nv_cmds[*(const short *)s2].cmd_char;", "  if (c1 < 0)"], "runtime/int"]
["src/nvim/normal.c", ["  c2 = nv_cmds[*(const short *)s2].cmd_char;", "  if (c1 < 0)", "    c1 = -c1;"], "readability/braces"]
["src/nvim/normal.c", ["    c1 = -c1;", "  if (c2 < 0)", "    c2 = -c2;"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Initialize the nv_cmd_idx[] table."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* Fill the index table with a one to one relation. */", "  for (short int i = 0; i < (short int)NV_CMDS_SIZE; ++i) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* Fill the index table with a one to one relation. */", "  for (short int i = 0; i < (short int)NV_CMDS_SIZE; ++i) {", "    nv_cmd_idx[i] = i;"], "runtime/int"]
["src/nvim/normal.c", ["  /* Fill the index table with a one to one relation. */", "  for (short int i = 0; i < (short int)NV_CMDS_SIZE; ++i) {", "    nv_cmd_idx[i] = i;"], "readability/increment"]
["src/nvim/normal.c", ["", "  /* Sort the commands by the command character.  */", "  qsort(&nv_cmd_idx, NV_CMDS_SIZE, sizeof(short), nv_compare);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* Sort the commands by the command character.  */", "  qsort(&nv_cmd_idx, NV_CMDS_SIZE, sizeof(short), nv_compare);", ""], "runtime/int"]
["src/nvim/normal.c", ["", "  /* Find the first entry that can't be indexed by the command character. */", "  short int i;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* Find the first entry that can't be indexed by the command character. */", "  short int i;", "  for (i = 0; i < (short int)NV_CMDS_SIZE; ++i) {"], "runtime/int"]
["src/nvim/normal.c", ["  short int i;", "  for (i = 0; i < (short int)NV_CMDS_SIZE; ++i) {", "    if (i != nv_cmds[nv_cmd_idx[i]].cmd_char) {"], "runtime/int"]
["src/nvim/normal.c", ["  short int i;", "  for (i = 0; i < (short int)NV_CMDS_SIZE; ++i) {", "    if (i != nv_cmds[nv_cmd_idx[i]].cmd_char) {"], "readability/increment"]
["src/nvim/normal.c", ["", "/*", " * Search for a command in the commands table."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* A multi-byte character is never a command. */", "  if (cmdchar >= 0x100)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* A multi-byte character is never a command. */", "  if (cmdchar >= 0x100)", "    return -1;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* We use the absolute value of the character.  Special keys have a", "   * negative value, but are sorted on their absolute value. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   * negative value, but are sorted on their absolute value. */", "  if (cmdchar < 0)", "    cmdchar = -cmdchar;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* If the character is in the first part: The character is the index into", "   * nv_cmd_idx[]. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  assert(nv_max_linear < (int)NV_CMDS_SIZE);", "  if (cmdchar <= nv_max_linear)", "    return nv_cmd_idx[cmdchar];"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* Perform a binary search. */", "  bot = nv_max_linear + 1;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    c = nv_cmds[nv_cmd_idx[i]].cmd_char;", "    if (c < 0)", "      c = -c;"], "readability/braces"]
["src/nvim/normal.c", ["    }", "    if (cmdchar > c)", "      bot = i + 1;"], "readability/braces"]
["src/nvim/normal.c", ["      bot = i + 1;", "    else", "      top = i - 1;"], "readability/braces"]
["src/nvim/normal.c", ["      if (*cp == Ctrl_K && ((nv_cmds[s->idx].cmd_flags & NV_LANG)", "              || cp == &s->ca.extra_char)", "          && vim_strchr(p_cpo, CPO_DIGRAPH) == NULL) {"], "whitespace/alignment"]
["src/nvim/normal.c", ["    } else if ((s->ca.nchar == 'n' || s->ca.nchar == 'N')", "        && s->ca.cmdchar == 'g') {", "      s->ca.oap->op_type = get_op_type(*cp, NUL);"], "whitespace/alignment"]
["src/nvim/normal.c", ["      if (!utf_iscomposing(s->c)) {", "        vungetc(s->c);                   /* it wasn't, put it back */", "        break;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  while ((s->c >= '1' && s->c <= '9') || (s->ca.count0 != 0", "        && (s->c == K_DEL || s->c == K_KDEL || s->c == '0'))) {", "    if (s->c == K_DEL || s->c == K_KDEL) {"], "whitespace/alignment"]
["src/nvim/normal.c", ["", "    ++no_zero_mapping;                // don't map zero here", "    s->c = plain_vgetc();"], "readability/increment"]
["src/nvim/normal.c", ["    LANGMAP_ADJUST(s->c, true);", "    --no_zero_mapping;", "    if (s->ctrl_w) {"], "readability/increment"]
["src/nvim/normal.c", ["  if (s->oa.op_type == OP_NOP", "             && ((restart_edit != 0 && !VIsual_active && s->old_mapped_len == 0)", "                 || restart_VIsual_select == 1)"], "whitespace/alignment"]
["src/nvim/normal.c", ["                 || restart_VIsual_select == 1)", "             && !(s->ca.retval & CA_COMMAND_BUSY)", "             && stuff_empty()"], "whitespace/alignment"]
["src/nvim/normal.c", ["             && !(s->ca.retval & CA_COMMAND_BUSY)", "             && stuff_empty()", "             && s->oa.regname == 0) {"], "whitespace/alignment"]
["src/nvim/normal.c", ["             && stuff_empty()", "             && s->oa.regname == 0) {", "    if (restart_VIsual_select == 1) {"], "whitespace/alignment"]
["src/nvim/normal.c", ["  s->command_finished = false;", "  s->ctrl_w = false;                  /* got CTRL-W command */", "  s->old_col = curwin->w_curswant;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  } else if (s->old_mapped_len || (VIsual_active && s->mapped_len == 0", "        && typebuf_maplen() > 0)) {", "    s->old_mapped_len = typebuf_maplen();"], "whitespace/alignment"]
["src/nvim/normal.c", ["  if (VIsual_active && VIsual_select && (vim_isprintc(s->c)", "        || s->c == NL || s->c == CAR || s->c == K_KENTER)) {", "    // Fake a \"c\"hange command.  When \"restart_edit\" is set (e.g., because"], "whitespace/alignment"]
["src/nvim/normal.c", ["", "  while (normal_get_command_count(s)) continue;", ""], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Set v:count and v:count1 according to \"cap\"."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* multiply with cap->opcount the same way as above */", "  if (cap->opcount != 0)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* multiply with cap->opcount the same way as above */", "  if (cap->opcount != 0)", "    count = cap->opcount * (count == 0 ? 1 : count);"], "readability/braces"]
["src/nvim/normal.c", ["  set_vcount(count, count == 0 ? 1 : count, *set_prevcount);", "  *set_prevcount = false;    /* only set v:prevcount once */", "}"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * If an operation is pending, handle it..."], "readability/old_style_comment"]
["src/nvim/normal.c", ["      prep_redo(oap->regname, cap->count0,", "          get_op_char(oap->op_type), get_extra_op_char(oap->op_type),", "          oap->motion_force, cap->cmdchar, cap->nchar);"], "whitespace/alignment"]
["src/nvim/normal.c", ["          get_op_char(oap->op_type), get_extra_op_char(oap->op_type),", "          oap->motion_force, cap->cmdchar, cap->nchar);", "      if (cap->cmdchar == '/' || cap->cmdchar == '?') {     /* was a search */"], "whitespace/alignment"]
["src/nvim/normal.c", ["          oap->motion_force, cap->cmdchar, cap->nchar);", "      if (cap->cmdchar == '/' || cap->cmdchar == '?') {     /* was a search */", "        /*"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      if (cap->cmdchar == '/' || cap->cmdchar == '?') {     /* was a search */", "        /*", "         * If 'cpoptions' does not contain 'r', insert the search"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (redo_VIsual_busy) {", "      /* Redo of an operation on a Visual area. Use the same size from", "       * redo_VIsual_line_count and redo_VIsual_vcol. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      curwin->w_cursor.lnum += redo_VIsual_line_count - 1;", "      if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)", "        curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/normal.c", ["              curwin->w_virtcol + redo_VIsual_vcol - 1;", "          } else", "            curwin->w_curswant = redo_VIsual_vcol;"], "readability/braces"]
["src/nvim/normal.c", ["      if (!gui_yank) {", "        /* Save the current VIsual area for '< and '> marks, and \"gv\" */", "        curbuf->b_visual.vi_start = VIsual;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      }", "      /* If 'selection' is \"exclusive\", backup one character for", "       * charwise selections. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["       * charwise selections. */", "      else if (VIsual_mode == 'v') {", "        include_line_break ="], "whitespace/newline"]
["src/nvim/normal.c", ["", "    /*", "     * Set oap->start to the first position of the operated text, oap->end"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (lt(oap->start, curwin->w_cursor)) {", "      /* Include folded lines completely. */", "      if (!VIsual_active) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      if (!VIsual_active) {", "        if (hasFolding(oap->start.lnum, &oap->start.lnum, NULL))", "          oap->start.col = 0;"], "readability/braces"]
["src/nvim/normal.c", ["", "      /* w_virtcol may have been updated; if the cursor goes back to its", "       * previous position w_virtcol becomes invalid and isn't updated"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    /* Set \"virtual_op\" before resetting VIsual_active. */", "    virtual_op = virtual_active();"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      if (!redo_VIsual_busy && !gui_yank) {", "        /*", "         * Prepare to reselect and redo Visual: this is based on the"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        resel_VIsual_mode = VIsual_mode;", "        if (curwin->w_curswant == MAXCOL)", "          resel_VIsual_vcol = MAXCOL;"], "readability/braces"]
["src/nvim/normal.c", ["          resel_VIsual_vcol = MAXCOL;", "        else {", "          if (VIsual_mode != Ctrl_V)"], "readability/braces"]
["src/nvim/normal.c", ["          resel_VIsual_vcol = MAXCOL;", "        else {", "          if (VIsual_mode != Ctrl_V)"], "readability/braces"]
["src/nvim/normal.c", ["        else {", "          if (VIsual_mode != Ctrl_V)", "            getvvcol(curwin, &(oap->end),"], "readability/braces"]
["src/nvim/normal.c", ["            getvvcol(curwin, &(oap->end),", "                NULL, NULL, &oap->end_vcol);", "          if (VIsual_mode == Ctrl_V || oap->line_count <= 1) {"], "whitespace/alignment"]
["src/nvim/normal.c", ["          if (VIsual_mode == Ctrl_V || oap->line_count <= 1) {", "            if (VIsual_mode != Ctrl_V)", "              getvvcol(curwin, &(oap->start),"], "readability/braces"]
["src/nvim/normal.c", ["              getvvcol(curwin, &(oap->start),", "                  &oap->start_vcol, NULL, NULL);", "            resel_VIsual_vcol = oap->end_vcol - oap->start_vcol + 1;"], "whitespace/alignment"]
["src/nvim/normal.c", ["            resel_VIsual_vcol = oap->end_vcol - oap->start_vcol + 1;", "          } else", "            resel_VIsual_vcol = oap->end_vcol;"], "readability/braces"]
["src/nvim/normal.c", ["          ) {", "        /* Prepare for redoing.  Only use the nchar field for \"r\",", "         * otherwise it might be the second char of the operator. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "      /*", "       * Switch Visual off now, so screen updating does"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    /*", "     * oap->empty is set when start and end are the same.  The inclusive"], "readability/old_style_comment"]
["src/nvim/normal.c", ["                  && !(virtual_op && oap->start.coladd != oap->end.coladd)", "                  );", "    /*"], "whitespace/parens"]
["src/nvim/normal.c", ["                  );", "    /*", "     * For delete, change and yank, it's an error to operate on an"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    /* Force a redraw when operating on an empty Visual region, when", "     * 'modifiable is off or creating a fold. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["                           || oap->op_type == OP_FOLD", "                           )) {", "      curwin->w_p_lbr = lbr_saved;"], "whitespace/parens"]
["src/nvim/normal.c", ["", "    /*", "     * If the end of an operator is in column one while oap->motion_type"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        if (oap->end.col) {", "          --oap->end.col;", "          oap->inclusive = true;"], "readability/increment"]
["src/nvim/normal.c", ["      }", "    } else", "      oap->end_adjusted = false;"], "readability/braces"]
["src/nvim/normal.c", ["      op_shift(oap, true,", "          oap->is_VIsual ? (int)cap->count1 :", "          1);"], "whitespace/alignment"]
["src/nvim/normal.c", ["          oap->is_VIsual ? (int)cap->count1 :", "          1);", "      auto_format(false, true);"], "whitespace/alignment"]
["src/nvim/normal.c", ["    case OP_JOIN:", "      if (oap->line_count < 2)", "        oap->line_count = 2;"], "readability/braces"]
["src/nvim/normal.c", ["    case OP_DELETE:", "      VIsual_reselect = false;              /* don't reselect now */", "      if (empty_region_error) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    case OP_CHANGE:", "      VIsual_reselect = false;              /* don't reselect now */", "      if (empty_region_error) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      } else {", "        /* This is a new edit command, not a restart.  Need to", "         * remember it to make 'insertmode' work with mappings for"], "readability/old_style_comment"]
["src/nvim/normal.c", ["         * 'insertmode' isn't set. */", "        if (p_im || !KeyTyped)", "          restart_edit_save = restart_edit;"], "readability/braces"]
["src/nvim/normal.c", ["          restart_edit_save = restart_edit;", "        else", "          restart_edit_save = 0;"], "readability/braces"]
["src/nvim/normal.c", ["        finish_op = false;", "        if (op_change(oap))             /* will call edit() */", "          cap->retval |= CA_COMMAND_BUSY;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        finish_op = false;", "        if (op_change(oap))             /* will call edit() */", "          cap->retval |= CA_COMMAND_BUSY;"], "readability/braces"]
["src/nvim/normal.c", ["          cap->retval |= CA_COMMAND_BUSY;", "        if (restart_edit == 0)", "          restart_edit = restart_edit_save;"], "readability/braces"]
["src/nvim/normal.c", ["", "      /*", "       * If 'equalprg' is empty, do the indenting internally."], "readability/old_style_comment"]
["src/nvim/normal.c", ["        op_reindent(oap,", "            *curbuf->b_p_inde != NUL ? get_expr_indent :", "            get_c_indent);"], "whitespace/alignment"]
["src/nvim/normal.c", ["            *curbuf->b_p_inde != NUL ? get_expr_indent :", "            get_c_indent);", "        break;"], "whitespace/alignment"]
["src/nvim/normal.c", ["        CancelRedo();", "      } else", "        op_tilde(oap);"], "readability/braces"]
["src/nvim/normal.c", ["    case OP_FORMAT2:", "      op_format(oap, true);             /* use internal function */", "      break;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    case OP_APPEND:", "      VIsual_reselect = false;          /* don't reselect now */", "      if (empty_region_error) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      } else {", "        /* This is a new edit command, not a restart.  Need to", "         * remember it to make 'insertmode' work with mappings for"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "        /* TODO: when inserting in several lines, should format all", "         * the lines. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    case OP_REPLACE:", "      VIsual_reselect = false;          /* don't reselect now */", "      if (empty_region_error) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (!gui_yank) {", "      /*", "       * if 'sol' not set, go back to old column for some commands"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Handle indent and format operators and visual mode \":\"."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * do_cmdline() does the rest"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Handle the \"g@\" operator: call 'operatorfunc'."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (*p_opfunc == NUL)", "    EMSG(_(\"E774: 'operatorfunc' is empty\"));"], "readability/braces"]
["src/nvim/normal.c", ["    EMSG(_(\"E774: 'operatorfunc' is empty\"));", "  else {", "    /* Set '[ and '] marks to text to be operated on. */"], "readability/braces"]
["src/nvim/normal.c", ["    EMSG(_(\"E774: 'operatorfunc' is empty\"));", "  else {", "    /* Set '[ and '] marks to text to be operated on. */"], "readability/braces"]
["src/nvim/normal.c", ["  else {", "    /* Set '[ and '] marks to text to be operated on. */", "    curbuf->b_op_start = oap->start;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Do the appropriate action for the current mouse click in the current mode."], "readability/old_style_comment"]
["src/nvim/normal.c", ["bool", "do_mouse (", "    oparg_T *oap,               /* operator argument, can be NULL */"], "whitespace/parens"]
["src/nvim/normal.c", ["do_mouse (", "    oparg_T *oap,               /* operator argument, can be NULL */", "    int c,                          /* K_LEFTMOUSE, etc */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    oparg_T *oap,               /* operator argument, can be NULL */", "    int c,                          /* K_LEFTMOUSE, etc */", "    int dir,                        /* Direction to 'put' if necessary */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    int c,                          /* K_LEFTMOUSE, etc */", "    int dir,                        /* Direction to 'put' if necessary */", "    long count,"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    long count,", "    bool fixindent                  /* PUT_FIXINDENT if fixing indent necessary */", ")"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    long count,", "    bool fixindent                  /* PUT_FIXINDENT if fixing indent necessary */", ")"], "whitespace/line_length"]
["src/nvim/normal.c", ["{", "  static bool got_click = false;        /* got a click some time back */", ""], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  int which_button;             /* MOUSE_LEFT, _MIDDLE or _RIGHT */", "  bool is_click;                /* If false it's a drag or release event */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  int which_button;             /* MOUSE_LEFT, _MIDDLE or _RIGHT */", "  bool is_click;                /* If false it's a drag or release event */", "  bool is_drag;                 /* If true it's a drag event */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  bool is_click;                /* If false it's a drag or release event */", "  bool is_drag;                 /* If true it's a drag event */", "  int jump_flags = 0;           /* flags for jump_to_mouse() */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  bool is_drag;                 /* If true it's a drag event */", "  int jump_flags = 0;           /* flags for jump_to_mouse() */", "  pos_T start_visual;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  pos_T start_visual;", "  bool moved;                   /* Has cursor moved? */", "  bool in_status_line;          /* mouse in status line */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  bool moved;                   /* Has cursor moved? */", "  bool in_status_line;          /* mouse in status line */", "  static bool in_tab_line = false;   /* mouse clicked in tab line */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  bool in_status_line;          /* mouse in status line */", "  static bool in_tab_line = false;   /* mouse clicked in tab line */", "  bool in_sep_line;             /* mouse in vertical separator line */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  static bool in_tab_line = false;   /* mouse clicked in tab line */", "  bool in_sep_line;             /* mouse in vertical separator line */", "  int c1, c2;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (is_drag) {", "      /* If the next character is the same mouse event then use that", "       * one. Speeds up dragging the status line. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "        /* Need to get the character, peeking doesn't get the actual", "         * one. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        nc = safe_vgetc();", "        if (c == nc)", "          continue;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * Ignore drag and release events if we didn't get a click."], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  if (is_click)", "    got_click = true;"], "readability/braces"]
["src/nvim/normal.c", ["    got_click = true;", "  else {", "    if (!got_click)                     /* didn't get click, ignore */"], "readability/braces"]
["src/nvim/normal.c", ["    got_click = true;", "  else {", "    if (!got_click)                     /* didn't get click, ignore */"], "readability/braces"]
["src/nvim/normal.c", ["  else {", "    if (!got_click)                     /* didn't get click, ignore */", "      return false;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  else {", "    if (!got_click)                     /* didn't get click, ignore */", "      return false;"], "readability/braces"]
["src/nvim/normal.c", ["      return false;", "    if (!is_drag) {                     /* release, reset got_click */", "      got_click = false;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * CTRL right mouse button does CTRL-T"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (is_click && (mod_mask & MOD_MASK_CTRL) && which_button == MOUSE_RIGHT) {", "    if (State & INSERT)", "      stuffcharReadbuff(Ctrl_O);"], "readability/braces"]
["src/nvim/normal.c", ["      stuffcharReadbuff(Ctrl_O);", "    if (count > 1)", "      stuffnumReadbuff(count);"], "readability/braces"]
["src/nvim/normal.c", ["    stuffcharReadbuff(Ctrl_T);", "    got_click = false;                  /* ignore drag&release now */", "    return false;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * CTRL only works with left mouse button"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  if ((mod_mask & MOD_MASK_CTRL) && which_button != MOUSE_LEFT)", "    return false;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * When a modifier is down, ignore drag and release events, as well as"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  if ((mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT", "                   | MOD_MASK_META))"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * If the button press was used as the movement command for an operator"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  if (!is_click && which_button == MOUSE_MIDDLE)", "    return false;"], "readability/braces"]
["src/nvim/normal.c", ["", "  if (oap != NULL)", "    regname = oap->regname;"], "readability/braces"]
["src/nvim/normal.c", ["    regname = oap->regname;", "  else", "    regname = 0;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * Middle mouse button does a 'put' of the selected text"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (State == NORMAL) {", "      /*", "       * If an operator was pending, we don't know what the user wanted"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "      /*", "       * If visual was active, yank the highlighted text and put it"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      }", "      /*", "       * The rest is below jump_to_mouse()"], "readability/old_style_comment"]
["src/nvim/normal.c", ["       */", "    } else if ((State & INSERT) == 0)", "      return false;"], "readability/braces"]
["src/nvim/normal.c", ["", "    /*", "     * Middle click in insert mode doesn't move the mouse, just insert the"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "          /* Repeat it with CTRL-R CTRL-O r or CTRL-R CTRL-P r */", "          AppendCharToRedobuff(Ctrl_R);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* When dragging or button-up stay in the same window. */", "  if (!is_click)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* When dragging or button-up stay in the same window. */", "  if (!is_click)", "    jump_flags |= MOUSE_FOCUS | MOUSE_DID_MOVE;"], "readability/braces"]
["src/nvim/normal.c", ["", "    /* click in a tab selects that tab page */", "    if (is_click"], "readability/old_style_comment"]
["src/nvim/normal.c", ["              .vval = {", "                .v_number = (varnumber_T) tab_page_click_defs[mouse_col].tabnr", "              },"], "whitespace/cast"]
["src/nvim/normal.c", ["              .v_type = VAR_STRING,", "              .vval = { .v_string = (char_u *) (which_button == MOUSE_LEFT", "                                                ? \"l\""], "whitespace/cast"]
["src/nvim/normal.c", ["                .v_string = (char_u[]) {", "                  (char_u) (mod_mask & MOD_MASK_SHIFT ? 's' : ' '),", "                  (char_u) (mod_mask & MOD_MASK_CTRL ? 'c' : ' '),"], "whitespace/cast"]
["src/nvim/normal.c", ["                  (char_u) (mod_mask & MOD_MASK_SHIFT ? 's' : ' '),", "                  (char_u) (mod_mask & MOD_MASK_CTRL ? 'c' : ' '),", "                  (char_u) (mod_mask & MOD_MASK_ALT ? 'a' : ' '),"], "whitespace/cast"]
["src/nvim/normal.c", ["                  (char_u) (mod_mask & MOD_MASK_CTRL ? 'c' : ' '),", "                  (char_u) (mod_mask & MOD_MASK_ALT ? 'a' : ' '),", "                  (char_u) (mod_mask & MOD_MASK_META ? 'm' : ' '),"], "whitespace/cast"]
["src/nvim/normal.c", ["                  (char_u) (mod_mask & MOD_MASK_ALT ? 'a' : ' '),", "                  (char_u) (mod_mask & MOD_MASK_META ? 'm' : ' '),", "                  NUL"], "whitespace/cast"]
["src/nvim/normal.c", ["", "  /*", "   * When 'mousemodel' is \"popup\" or \"popup_setpos\", translate mouse events:"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        && !(mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))) {", "      /*", "       * NOTE: Ignore right button down and drag mouse events."], "readability/old_style_comment"]
["src/nvim/normal.c", ["      if (is_click) {", "        /* stop Visual mode for a left click in a window, but not when", "         * on a status line */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["         * on a status line */", "        if (VIsual_active)", "          jump_flags |= MOUSE_MAY_STOP_VIS;"], "readability/braces"]
["src/nvim/normal.c", ["      if (is_click && VIsual_active) {", "        /*", "         * Remember the start and end of visual before moving the"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * If an operator is pending, ignore all drags and releases until the"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* When releasing the button let jump_to_mouse() know. */", "  if (!is_click && !is_drag)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* When releasing the button let jump_to_mouse() know. */", "  if (!is_click && !is_drag)", "    jump_flags |= MOUSE_RELEASED;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * JUMP!"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* When jumping to another window, clear a pending operator.  That's a bit", "   * friendlier than beeping and not jumping to that window. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   * friendlier than beeping and not jumping to that window. */", "  if (curwin != old_curwin && oap != NULL && oap->op_type != OP_NOP)", "    clearop(oap);"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* Set global flag that we are extending the Visual area with mouse", "   * dragging; temporarily minimize 'scrolloff'. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* When dragging the mouse above the window, scroll down. */", "  if (is_drag && mouse_row < 0 && !in_status_line) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (start_visual.lnum) {              /* right click in visual mode */", "    /* When ALT is pressed make Visual mode blockwise. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (start_visual.lnum) {              /* right click in visual mode */", "    /* When ALT is pressed make Visual mode blockwise. */", "    if (mod_mask & MOD_MASK_ALT)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    /* When ALT is pressed make Visual mode blockwise. */", "    if (mod_mask & MOD_MASK_ALT)", "      VIsual_mode = Ctrl_V;"], "readability/braces"]
["src/nvim/normal.c", ["", "    /*", "     * In Visual-block mode, divide the area in four, pick up the corner"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      getvcols(curwin, &start_visual, &end_visual, &leftcol, &rightcol);", "      if (curwin->w_curswant > (leftcol + rightcol) / 2)", "        end_visual.col = leftcol;"], "readability/braces"]
["src/nvim/normal.c", ["        end_visual.col = leftcol;", "      else", "        end_visual.col = rightcol;"], "readability/braces"]
["src/nvim/normal.c", ["", "      /* move VIsual to the right column */", "      start_visual = curwin->w_cursor;              /* save the cursor pos */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      /* move VIsual to the right column */", "      start_visual = curwin->w_cursor;              /* save the cursor pos */", "      curwin->w_cursor = end_visual;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      VIsual = curwin->w_cursor;", "      curwin->w_cursor = start_visual;              /* restore the cursor */", "    } else {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    } else {", "      /*", "       * If the click is before the start of visual, change the start."], "readability/old_style_comment"]
["src/nvim/normal.c", ["       */", "      if (lt(curwin->w_cursor, start_visual))", "        VIsual = end_visual;"], "readability/braces"]
["src/nvim/normal.c", ["        VIsual = end_visual;", "      else if (lt(end_visual, curwin->w_cursor))", "        VIsual = start_visual;"], "readability/braces"]
["src/nvim/normal.c", ["        VIsual = start_visual;", "      else {", "        /* In the same line, compare column number */"], "readability/braces"]
["src/nvim/normal.c", ["        VIsual = start_visual;", "      else {", "        /* In the same line, compare column number */"], "readability/braces"]
["src/nvim/normal.c", ["      else {", "        /* In the same line, compare column number */", "        if (end_visual.lnum == start_visual.lnum) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        if (end_visual.lnum == start_visual.lnum) {", "          if (curwin->w_cursor.col - start_visual.col >", "              end_visual.col - curwin->w_cursor.col)"], "readability/braces"]
["src/nvim/normal.c", ["            VIsual = start_visual;", "          else", "            VIsual = end_visual;"], "readability/braces"]
["src/nvim/normal.c", ["        }", "        /* In different lines, compare line number */", "        else {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        /* In different lines, compare line number */", "        else {", "          diff = (curwin->w_cursor.lnum - start_visual.lnum) -"], "whitespace/newline"]
["src/nvim/normal.c", ["        /* In different lines, compare line number */", "        else {", "          diff = (curwin->w_cursor.lnum - start_visual.lnum) -"], "readability/braces"]
["src/nvim/normal.c", ["", "          if (diff > 0)                         /* closest to end */", "            VIsual = start_visual;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "          if (diff > 0)                         /* closest to end */", "            VIsual = start_visual;"], "readability/braces"]
["src/nvim/normal.c", ["            VIsual = start_visual;", "          else if (diff < 0)            /* closest to start */", "            VIsual = end_visual;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["            VIsual = start_visual;", "          else if (diff < 0)            /* closest to start */", "            VIsual = end_visual;"], "readability/braces"]
["src/nvim/normal.c", ["            VIsual = end_visual;", "          else {                                /* in the middle line */", "            if (curwin->w_cursor.col <"], "readability/old_style_comment"]
["src/nvim/normal.c", ["            VIsual = end_visual;", "          else {                                /* in the middle line */", "            if (curwin->w_cursor.col <"], "readability/braces"]
["src/nvim/normal.c", ["            VIsual = end_visual;", "          else {                                /* in the middle line */", "            if (curwin->w_cursor.col <"], "readability/braces"]
["src/nvim/normal.c", ["          else {                                /* in the middle line */", "            if (curwin->w_cursor.col <", "                (start_visual.col + end_visual.col) / 2)"], "readability/braces"]
["src/nvim/normal.c", ["              VIsual = end_visual;", "            else", "              VIsual = start_visual;"], "readability/braces"]
["src/nvim/normal.c", ["  }", "  /*", "   * If Visual mode started in insert mode, execute \"CTRL-O\""], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  else if ((State & INSERT) && VIsual_active)", "    stuffcharReadbuff(Ctrl_O);"], "whitespace/newline"]
["src/nvim/normal.c", ["", "  /*", "   * Middle mouse click: Put text before cursor."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (yank_register_mline(regname)) {", "      if (mouse_past_bottom)", "        dir = FORWARD;"], "readability/braces"]
["src/nvim/normal.c", ["        dir = FORWARD;", "    } else if (mouse_past_eol)", "      dir = FORWARD;"], "readability/braces"]
["src/nvim/normal.c", ["", "    /*", "     * Remember where the paste started, so in edit() Insstart can be set"], "readability/old_style_comment"]
["src/nvim/normal.c", ["     */", "    if (restart_edit != 0)", "      where_paste_started = curwin->w_cursor;"], "readability/braces"]
["src/nvim/normal.c", ["  }", "  /*", "   * Ctrl-Mouse click or double click in a quickfix window jumps to the"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  else if (((mod_mask & MOD_MASK_CTRL)", "            || (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)"], "whitespace/newline"]
["src/nvim/normal.c", ["  }", "  /*", "   * Ctrl-Mouse click (or double click in a help window) jumps to the tag"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  else if ((mod_mask & MOD_MASK_CTRL) || (curbuf->b_help", "                                          && (mod_mask &"], "whitespace/newline"]
["src/nvim/normal.c", ["                                          MOD_MASK_2CLICK)) {", "    if (State & INSERT)", "      stuffcharReadbuff(Ctrl_O);"], "readability/braces"]
["src/nvim/normal.c", ["    stuffcharReadbuff(Ctrl_RSB);", "    got_click = false;                  /* ignore drag&release now */", "  }"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  }", "  /*", "   * Shift-Mouse click searches for the next occurrence of the word under"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  else if ((mod_mask & MOD_MASK_SHIFT)) {", "    if (State & INSERT"], "whitespace/newline"]
["src/nvim/normal.c", ["  else if ((mod_mask & MOD_MASK_SHIFT)) {", "    if (State & INSERT", "        || (VIsual_active && VIsual_select)"], "readability/braces"]
["src/nvim/normal.c", ["      stuffcharReadbuff(Ctrl_O);", "    if (which_button == MOUSE_LEFT)", "      stuffcharReadbuff('*');"], "readability/braces"]
["src/nvim/normal.c", ["      stuffcharReadbuff('*');", "    else        /* MOUSE_RIGHT */", "      stuffcharReadbuff('#');"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      stuffcharReadbuff('*');", "    else        /* MOUSE_RIGHT */", "      stuffcharReadbuff('#');"], "readability/braces"]
["src/nvim/normal.c", ["  }", "  /* Handle double clicks, unless on status line */", "  else if (in_status_line) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* Handle double clicks, unless on status line */", "  else if (in_status_line) {", "  } else if (in_sep_line) {"], "whitespace/newline"]
["src/nvim/normal.c", ["        VIsual_reselect = true;", "        /* start Select mode if 'selectmode' contains \"mouse\" */", "        may_start_select('o');"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK) {", "        /* Double click with ALT pressed makes it blockwise. */", "        if (mod_mask & MOD_MASK_ALT)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        /* Double click with ALT pressed makes it blockwise. */", "        if (mod_mask & MOD_MASK_ALT)", "          VIsual_mode = Ctrl_V;"], "readability/braces"]
["src/nvim/normal.c", ["          VIsual_mode = Ctrl_V;", "        else", "          VIsual_mode = 'v';"], "readability/braces"]
["src/nvim/normal.c", ["          VIsual_mode = 'v';", "      } else if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_3CLICK)", "        VIsual_mode = 'V';"], "readability/braces"]
["src/nvim/normal.c", ["        VIsual_mode = 'V';", "      else if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_4CLICK)", "        VIsual_mode = Ctrl_V;"], "readability/braces"]
["src/nvim/normal.c", ["    }", "    /*", "     * A double click selects a word or a block."], "readability/old_style_comment"]
["src/nvim/normal.c", ["      if (is_click) {", "        /* If the character under the cursor (skipping white space) is", "         * not a word character, try finding a match and select a (),"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        end_visual = curwin->w_cursor;", "        while (gc = gchar_pos(&end_visual), ascii_iswhite(gc))", "          inc(&end_visual);"], "readability/braces"]
["src/nvim/normal.c", ["      if (pos == NULL && (is_click || is_drag)) {", "        /* When not found a match or when dragging: extend to include", "         * a word. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["          find_start_of_word(&VIsual);", "          if (*p_sel == 'e' && *get_cursor_pos_ptr() != NUL)", "            curwin->w_cursor.col +="], "readability/braces"]
["src/nvim/normal.c", ["    }", "    if (is_click)", "      redraw_curbuf_later(INVERTED);            /* update the inversion */"], "readability/braces"]
["src/nvim/normal.c", ["    if (is_click)", "      redraw_curbuf_later(INVERTED);            /* update the inversion */", "  } else if (VIsual_active && !old_active) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  } else if (VIsual_active && !old_active) {", "    if (mod_mask & MOD_MASK_ALT)", "      VIsual_mode = Ctrl_V;"], "readability/braces"]
["src/nvim/normal.c", ["      VIsual_mode = Ctrl_V;", "    else", "      VIsual_mode = 'v';"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* If Visual mode changed show it later. */", "  if ((!VIsual_active && old_active && mode_displayed)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* If Visual mode changed show it later. */", "  if ((!VIsual_active && old_active && mode_displayed)", "      || (VIsual_active && p_smd && msg_silent == 0"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Move \"pos\" back to the start of the word it's in."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Move \"pos\" forward to the end of the word it's in."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (get_mouse_class(line + col) != cclass) {", "      if (*p_sel == 'e')", "        pos->col = col;"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Get class of a character for selection: same class means same word."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * There are a few special cases where we want certain combinations of"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  if (c != NUL && vim_strchr((char_u *)\"-+*/%<>&|^!=\", c) != NULL)", "    return 1;"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * End Visual mode."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "", "  VIsual_active = false;"], "whitespace/blank_line"]
["src/nvim/normal.c", ["", "  /* Save the current VIsual area for '< and '> marks, and \"gv\" */", "  curbuf->b_visual.vi_mode = VIsual_mode;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  curbuf->b_visual_mode_eval = VIsual_mode;", "  if (!virtual_active())", "    curwin->w_cursor.coladd = 0;"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Reset VIsual_active and VIsual_reselect."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    end_visual_mode();", "    redraw_curbuf_later(INVERTED);      /* delete the inversion later */", "  }"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Reset VIsual_active and VIsual_reselect if it's set."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    end_visual_mode();", "    redraw_curbuf_later(INVERTED);      /* delete the inversion later */", "    VIsual_reselect = false;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Like find_ident_under_cursor(), but for any window and any position."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Prepare for redo of a normal command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  prep_redo(cap->oap->regname, cap->count0,", "      NUL, cap->cmdchar, NUL, NUL, cap->nchar);", "}"], "whitespace/alignment"]
["src/nvim/normal.c", ["", "/*", " * Prepare for redo of any command."], "readability/old_style_comment"]
["src/nvim/normal.c", [" */", "static void prep_redo(int regname, long num, int cmd1, int cmd2, int cmd3, int cmd4, int cmd5)", "{"], "whitespace/line_length"]
["src/nvim/normal.c", ["  ResetRedobuff();", "  if (regname != 0) {   /* yank from specified buffer */", "    AppendCharToRedobuff('\"');"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  }", "  if (num)", "    AppendNumberToRedobuff(num);"], "readability/braces"]
["src/nvim/normal.c", ["", "  if (cmd1 != NUL)", "    AppendCharToRedobuff(cmd1);"], "readability/braces"]
["src/nvim/normal.c", ["    AppendCharToRedobuff(cmd1);", "  if (cmd2 != NUL)", "    AppendCharToRedobuff(cmd2);"], "readability/braces"]
["src/nvim/normal.c", ["    AppendCharToRedobuff(cmd2);", "  if (cmd3 != NUL)", "    AppendCharToRedobuff(cmd3);"], "readability/braces"]
["src/nvim/normal.c", ["    AppendCharToRedobuff(cmd3);", "  if (cmd4 != NUL)", "    AppendCharToRedobuff(cmd4);"], "readability/braces"]
["src/nvim/normal.c", ["    AppendCharToRedobuff(cmd4);", "  if (cmd5 != NUL)", "    AppendCharToRedobuff(cmd5);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * check for operator active and clear it"], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (oap->op_type == OP_NOP)", "    return false;"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Check for operator or Visual active.  Clear active operator."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (oap->op_type == OP_NOP", "      && !VIsual_active"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Remove the shift modifier from a special key."], "readability/old_style_comment"]
["src/nvim/normal.c", ["static char_u showcmd_buf[SHOWCMD_BUFLEN];", "static char_u old_showcmd_buf[SHOWCMD_BUFLEN];    /* For push_showcmd() */", "static bool showcmd_is_clear = true;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (!p_sc)", "    return;"], "readability/braces"]
["src/nvim/normal.c", ["", "    /* Show the size of the Visual area. */", "    if (cursor_bot) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "      /* Make 'sbr' empty for a moment to get the correct size. */", "      p_sbr = empty_option;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        if (l == 0) {", "          ++bytes;", "          ++chars;"], "readability/increment"]
["src/nvim/normal.c", ["          ++bytes;", "          ++chars;", "          break;            /* end of line */"], "readability/increment"]
["src/nvim/normal.c", ["          ++chars;", "          break;            /* end of line */", "        }"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        bytes += l;", "        ++chars;", "        s += l;"], "readability/increment"]
["src/nvim/normal.c", ["      }", "      if (bytes == chars)", "        sprintf((char *)showcmd_buf, \"%d\", chars);"], "readability/braces"]
["src/nvim/normal.c", ["      if (bytes == chars)", "        sprintf((char *)showcmd_buf, \"%d\", chars);", "      else"], "runtime/printf"]
["src/nvim/normal.c", ["        sprintf((char *)showcmd_buf, \"%d\", chars);", "      else", "        sprintf((char *)showcmd_buf, \"%d-%d\", chars, bytes);"], "readability/braces"]
["src/nvim/normal.c", ["      else", "        sprintf((char *)showcmd_buf, \"%d-%d\", chars, bytes);", "    }"], "runtime/printf"]
["src/nvim/normal.c", ["", "    /* Don't actually display something if there is nothing to clear. */", "    if (showcmd_is_clear)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    /* Don't actually display something if there is nothing to clear. */", "    if (showcmd_is_clear)", "      return;"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Add 'c' to string of shown command chars."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  static int ignore[] =", "  {", "    K_IGNORE,"], "whitespace/braces"]
["src/nvim/normal.c", ["", "  if (!p_sc || msg_silent != 0)", "    return false;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* Ignore keys that are scrollbar updates and mouse clicks */", "  if (IS_SPECIAL(c))"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* Ignore keys that are scrollbar updates and mouse clicks */", "  if (IS_SPECIAL(c))", "    for (i = 0; ignore[i] != 0; ++i)"], "readability/braces"]
["src/nvim/normal.c", ["  if (IS_SPECIAL(c))", "    for (i = 0; ignore[i] != 0; ++i)", "      if (ignore[i] == c)"], "readability/braces"]
["src/nvim/normal.c", ["  if (IS_SPECIAL(c))", "    for (i = 0; ignore[i] != 0; ++i)", "      if (ignore[i] == c)"], "readability/increment"]
["src/nvim/normal.c", ["    for (i = 0; ignore[i] != 0; ++i)", "      if (ignore[i] == c)", "        return false;"], "readability/braces"]
["src/nvim/normal.c", ["  p = transchar(c);", "  if (*p == ' ')", "    STRCPY(p, \"<20>\");"], "readability/braces"]
["src/nvim/normal.c", ["", "  if (char_avail())", "    return false;"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Delete 'len' characters from the end of the shown command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (!p_sc)", "    return;"], "readability/braces"]
["src/nvim/normal.c", ["  old_len = (int)STRLEN(showcmd_buf);", "  if (len > old_len)", "    len = old_len;"], "readability/braces"]
["src/nvim/normal.c", ["", "  if (!char_avail())", "    display_showcmd();"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * push_showcmd() and pop_showcmd() are used when waiting for the user to type"], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (p_sc)", "    STRCPY(old_showcmd_buf, showcmd_buf);"], "readability/braces"]
["src/nvim/normal.c", ["{", "  if (!p_sc)", "    return;"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * When \"check\" is false, prepare for commands that scroll the window."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (check && curwin->w_p_scb) {", "    /* If a \":syncbind\" command was just used, don't scroll, only reset", "     * the values. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["     * the values. */", "    if (did_syncbind)", "      did_syncbind = false;"], "readability/braces"]
["src/nvim/normal.c", ["      did_syncbind = false;", "    else if (curwin == old_curwin) {", "      /*"], "readability/braces"]
["src/nvim/normal.c", ["    else if (curwin == old_curwin) {", "      /*", "       * Synchronize other windows, as necessary according to"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        check_scrollbind(curwin->w_topline - old_topline,", "            (long)(curwin->w_leftcol - old_leftcol));", "      }"], "whitespace/alignment"]
["src/nvim/normal.c", ["      }", "    } else if (vim_strchr(p_sbo, 'j')) { /* jump flag set in 'scrollopt' */", "      /*"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    } else if (vim_strchr(p_sbo, 'j')) { /* jump flag set in 'scrollopt' */", "      /*", "       * When switching between windows, make sure that the relative"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Synchronize any windows that have \"scrollbind\" set, based on the"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * check 'scrollopt' string for vertical and horizontal scroll options"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * loop through the scrollbound windows and scroll accordingly"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    curbuf = curwin->w_buffer;", "    /* skip original window  and windows with 'noscrollbind' */", "    if (curwin == old_curwin || !curwin->w_p_scb) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    }", "    /*", "     * do the vertical scroll"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        topline = curwin->w_scbind_pos;", "        if (topline > curbuf->b_ml.ml_line_count)", "          topline = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/normal.c", ["          topline = curbuf->b_ml.ml_line_count;", "        if (topline < 1)", "          topline = 1;"], "readability/braces"]
["src/nvim/normal.c", ["        y = topline - curwin->w_topline;", "        if (y > 0)", "          scrollup(y, false);"], "readability/braces"]
["src/nvim/normal.c", ["          scrollup(y, false);", "        else", "          scrolldown(-y, false);"], "readability/braces"]
["src/nvim/normal.c", ["", "    /*", "     * do the horizontal scroll"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * reset current-window"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Command character that's ignored."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  cap->retval |= CA_COMMAND_BUSY;       /* don't call edit() now */", "}"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Command character that doesn't do anything, but unlike nv_ignore() does"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Command character doesn't exist."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * <Help> and <F1> commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (!checkclearopq(cap->oap))", "    ex_help(NULL);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * CTRL-A and CTRL-X: Add or subtract from letter or number under cursor."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * CTRL-F, CTRL-B, etc: Scroll page up or down."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (mod_mask & MOD_MASK_CTRL) {", "      /* <C-PageUp>: tab page back; <C-PageDown>: tab page forward */", "      if (cap->arg == BACKWARD)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      /* <C-PageUp>: tab page back; <C-PageDown>: tab page forward */", "      if (cap->arg == BACKWARD)", "        goto_tabpage(-(int)cap->count1);"], "readability/braces"]
["src/nvim/normal.c", ["        goto_tabpage(-(int)cap->count1);", "      else", "        goto_tabpage((int)cap->count0);"], "readability/braces"]
["src/nvim/normal.c", ["        goto_tabpage((int)cap->count0);", "    } else", "      (void)onepage(cap->arg, cap->count1);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Implementation of \"gd\" and \"gD\" command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["static void", "nv_gd (", "    oparg_T *oap,"], "whitespace/parens"]
["src/nvim/normal.c", ["    int nchar,", "    int thisblock                  /* 1 for \"1gd\" and \"1gD\" */", ")"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Search for variable declaration of \"ptr[len]\"."], "readability/old_style_comment"]
["src/nvim/normal.c", ["bool", "find_decl (", "    char_u *ptr,"], "whitespace/parens"]
["src/nvim/normal.c", ["", "  /* Put \"\\V\" before the pattern to avoid that the special meaning of \".\"", "   * and \"~\" causes trouble. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  assert(len <= INT_MAX);", "  sprintf((char *)pat, vim_iswordp(ptr) ? \"\\\\V\\\\<%.*s\\\\>\" : \"\\\\V%.*s\",", "          (int)len, ptr);"], "runtime/printf"]
["src/nvim/normal.c", ["  save_p_scs = p_scs;", "  p_ws = false;         /* don't wrap around end of file now */", "  p_scs = false;        /* don't switch ignorecase off now */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  p_ws = false;         /* don't wrap around end of file now */", "  p_scs = false;        /* don't switch ignorecase off now */", ""], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * With \"gD\" go to line 1."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (!locally || !findpar(&incll, BACKWARD, 1L, '{', false)) {", "    setpcmark();                        /* Set in findpar() otherwise */", "    curwin->w_cursor.lnum = 1;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    par_pos = curwin->w_cursor;", "    while (curwin->w_cursor.lnum > 1", "           && *skipwhite(get_cursor_line_ptr()) != NUL)"], "readability/braces"]
["src/nvim/normal.c", ["           && *skipwhite(get_cursor_line_ptr()) != NUL)", "      --curwin->w_cursor.lnum;", "  }"], "readability/increment"]
["src/nvim/normal.c", ["", "  /* Search forward for the identifier, ignore comment lines. */", "  clearpos(&found_pos);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (t == false) {", "      /* If we previously found a valid position, use it. */", "      if (found_pos.lnum != 0) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (get_leader_len(get_cursor_line_ptr(), NULL, false, true) > 0) {", "      /* Ignore this line, continue at start of next line. */", "      ++curwin->w_cursor.lnum;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      /* Ignore this line, continue at start of next line. */", "      ++curwin->w_cursor.lnum;", "      curwin->w_cursor.col = 0;"], "readability/increment"]
["src/nvim/normal.c", ["    curwin->w_set_curswant = true;", "    /* \"n\" searches forward now */", "    reset_search_dir();"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Move 'dist' lines in direction 'dir', counting lines by *screen*"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  int n;", "  int col_off1;                 /* margin offset for first screen line */", "  int col_off2;                 /* margin offset for wrapped screen line */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  int col_off1;                 /* margin offset for first screen line */", "  int col_off2;                 /* margin offset for wrapped screen line */", "  int width1;                   /* text width for first screen line */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  int col_off2;                 /* margin offset for wrapped screen line */", "  int width1;                   /* text width for first screen line */", "  int width2;                   /* test width for wrapped screen line */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  int width1;                   /* text width for first screen line */", "  int width2;                   /* test width for wrapped screen line */", ""], "readability/old_style_comment"]
["src/nvim/normal.c", ["      validate_virtcol();", "      if (width1 <= 0)", "        curwin->w_curswant = 0;"], "readability/braces"]
["src/nvim/normal.c", ["        curwin->w_curswant = 0;", "      else {", "        curwin->w_curswant = width1 - 1;"], "readability/braces"]
["src/nvim/normal.c", ["        curwin->w_curswant = 0;", "      else {", "        curwin->w_curswant = width1 - 1;"], "readability/braces"]
["src/nvim/normal.c", ["        curwin->w_curswant = width1 - 1;", "        if (curwin->w_virtcol > curwin->w_curswant)", "          curwin->w_curswant += ((curwin->w_virtcol"], "readability/braces"]
["src/nvim/normal.c", ["    } else {", "      if (linelen > width1)", "        n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;"], "readability/braces"]
["src/nvim/normal.c", ["        n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;", "      else", "        n = width1;"], "readability/braces"]
["src/nvim/normal.c", ["        }", "      } else { /* dir == FORWARD */", "        if (linelen > width1)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      } else { /* dir == FORWARD */", "        if (linelen > width1)", "          n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;"], "readability/braces"]
["src/nvim/normal.c", ["          n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;", "        else", "          n = width1;"], "readability/braces"]
["src/nvim/normal.c", ["", "  if (virtual_active() && atend)", "    coladvance(MAXCOL);"], "readability/braces"]
["src/nvim/normal.c", ["    coladvance(MAXCOL);", "  else", "    coladvance(curwin->w_curswant);"], "readability/braces"]
["src/nvim/normal.c", ["  if (curwin->w_cursor.col > 0 && curwin->w_p_wrap) {", "    /*", "     * Check for landing on a character that got split at the end of the"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    colnr_T virtcol = curwin->w_virtcol;", "    if (virtcol > (colnr_T)width1 && *p_sbr != NUL)", "        virtcol -= vim_strsize(p_sbr);"], "readability/braces"]
["src/nvim/normal.c", ["", "    if (virtcol > curwin->w_curswant", "        && (curwin->w_curswant < (colnr_T)width1"], "readability/braces"]
["src/nvim/normal.c", ["               > (colnr_T)width2 / 2)))", "      --curwin->w_cursor.col;", "  }"], "readability/increment"]
["src/nvim/normal.c", ["", "  if (atend)", "    curwin->w_curswant = MAXCOL;            /* stick in the last column */"], "readability/braces"]
["src/nvim/normal.c", ["  if (atend)", "    curwin->w_curswant = MAXCOL;            /* stick in the last column */", ""], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Mouse scroll wheel: Default action is to scroll three lines, or one page"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Mouse clicks and drags."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Handle CTRL-E and CTRL-Y commands: scroll a line up or down."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (!checkclearop(cap->oap))", "    scroll_redraw(cap->arg, cap->count1);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Scroll \"count\" lines up or down, and redraw."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    /* If moved back to where we were, at least move the cursor, otherwise", "     * we get stuck at one position.  Don't move the cursor up if the"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      if (up) {", "        if (curwin->w_cursor.lnum > prev_lnum", "            || cursor_down(1L, false) == false)"], "readability/braces"]
["src/nvim/normal.c", ["      } else {", "        if (curwin->w_cursor.lnum < prev_lnum", "            || prev_topline == 1L"], "readability/braces"]
["src/nvim/normal.c", ["      }", "      /* Mark w_topline as valid, otherwise the screen jumps back at the", "       * end of the file. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Commands that start with \"z\"."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (ascii_isdigit(nchar)) {", "    /*", "     * \"z123{nchar}\": edit the count before obtaining {nchar}"], "readability/old_style_comment"]
["src/nvim/normal.c", ["     */", "    if (checkclearop(cap->oap))", "      return;"], "readability/braces"]
["src/nvim/normal.c", ["      (void)add_to_showcmd(nchar);", "      if (nchar == K_DEL || nchar == K_KDEL)", "        n /= 10;"], "readability/braces"]
["src/nvim/normal.c", ["        n /= 10;", "      else if (ascii_isdigit(nchar))", "        n = n * 10 + (nchar - '0');"], "readability/braces"]
["src/nvim/normal.c", ["        n = n * 10 + (nchar - '0');", "      else if (nchar == CAR) {", "        win_setheight(n);"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * For \"z+\", \"z<CR>\", \"zt\", \"z.\", \"zz\", \"z^\", \"z-\", \"zb\":"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    setpcmark();", "    if (cap->count0 > curbuf->b_ml.ml_line_count)", "      curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/normal.c", ["      curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;", "    else", "      curwin->w_cursor.lnum = cap->count0;"], "readability/braces"]
["src/nvim/normal.c", ["  switch (nchar) {", "  /* \"z+\", \"z<CR>\" and \"zt\": put cursor at top of screen */", "  case '+':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"z.\" and \"zz\": put cursor in middle of screen */", "  case '.':   beginline(BL_WHITE | BL_FIX);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      curwin->w_cursor.lnum = curwin->w_topline;", "    } else if (curwin->w_topline == 1)", "      curwin->w_cursor.lnum = 1;"], "readability/braces"]
["src/nvim/normal.c", ["      curwin->w_cursor.lnum = 1;", "    else", "      curwin->w_cursor.lnum = curwin->w_topline - 1;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* \"zH\" - scroll screen right half-page */", "  case 'H':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"zh\" - scroll screen to the right */", "  case 'h':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (!curwin->w_p_wrap) {", "      if ((colnr_T)cap->count1 > curwin->w_leftcol)", "        curwin->w_leftcol = 0;"], "readability/braces"]
["src/nvim/normal.c", ["        curwin->w_leftcol = 0;", "      else", "        curwin->w_leftcol -= (colnr_T)cap->count1;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* \"zl\" - scroll screen to the left */", "  case 'l':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (!curwin->w_p_wrap) {", "      /* scroll the window left */", "      curwin->w_leftcol += (colnr_T)cap->count1;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"zs\" - scroll screen, cursor at the start */", "  case 's':   if (!curwin->w_p_wrap) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case 's':   if (!curwin->w_p_wrap) {", "      if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))", "        col = 0;                        /* like the cursor is in col 0 */"], "readability/braces"]
["src/nvim/normal.c", ["      if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))", "        col = 0;                        /* like the cursor is in col 0 */", "      else"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        col = 0;                        /* like the cursor is in col 0 */", "      else", "        getvcol(curwin, &curwin->w_cursor, &col, NULL, NULL);"], "readability/braces"]
["src/nvim/normal.c", ["        getvcol(curwin, &curwin->w_cursor, &col, NULL, NULL);", "      if (col > l_p_siso)", "        col -= l_p_siso;"], "readability/braces"]
["src/nvim/normal.c", ["        col -= l_p_siso;", "      else", "        col = 0;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* \"ze\" - scroll screen, cursor at the end */", "  case 'e':   if (!curwin->w_p_wrap) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case 'e':   if (!curwin->w_p_wrap) {", "      if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))", "        col = 0;                        /* like the cursor is in col 0 */"], "readability/braces"]
["src/nvim/normal.c", ["      if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))", "        col = 0;                        /* like the cursor is in col 0 */", "      else"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        col = 0;                        /* like the cursor is in col 0 */", "      else", "        getvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* \"zF\": create fold command */", "  /* \"zf\": create fold operator */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* \"zF\": create fold command */", "  /* \"zf\": create fold operator */", "  case 'F':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "      /* \"zF\" is like \"zfzf\" */", "      if (nchar == 'F' && cap->oap->op_type == OP_FOLD) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      }", "  } else", "      clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* \"zd\": delete fold at cursor */", "  /* \"zD\": delete fold at cursor recursively */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* \"zd\": delete fold at cursor */", "  /* \"zD\": delete fold at cursor recursively */", "  case 'd':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"zE\": erase all folds */", "  case 'E':   if (foldmethodIsManual(curwin)) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"zn\": fold none: reset 'foldenable' */", "  case 'n':   curwin->w_p_fen = false;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"zN\": fold Normal: set 'foldenable' */", "  case 'N':   curwin->w_p_fen = true;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"zi\": invert folding: toggle 'foldenable' */", "  case 'i':   curwin->w_p_fen = !curwin->w_p_fen;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"zv\": open folds at the cursor */", "  case 'v':   foldOpenCursor();"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"zx\": re-apply 'foldlevel' and open folds at the cursor */", "  case 'x':   curwin->w_p_fen = true;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case 'x':   curwin->w_p_fen = true;", "    curwin->w_foldinvalid = true;               /* recompute folds */", "    newFoldLevel();                             /* update right now */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    curwin->w_foldinvalid = true;               /* recompute folds */", "    newFoldLevel();                             /* update right now */", "    foldOpenCursor();"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"zX\": undo manual opens/closes, re-apply 'foldlevel' */", "  case 'X':   curwin->w_p_fen = true;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case 'X':   curwin->w_p_fen = true;", "    curwin->w_foldinvalid = true;               /* recompute folds */", "    old_fdl = -1;                               /* force an update */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    curwin->w_foldinvalid = true;               /* recompute folds */", "    old_fdl = -1;                               /* force an update */", "    break;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"zm\": fold more */", "  case 'm':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    }", "    old_fdl = -1;                       /* force an update */", "    curwin->w_p_fen = true;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"zM\": close all folds */", "  case 'M':   curwin->w_p_fdl = 0;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case 'M':   curwin->w_p_fdl = 0;", "    old_fdl = -1;                       /* force an update */", "    curwin->w_p_fen = true;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"zr\": reduce folding */", "  case 'r':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  case 'j':     /* \"zj\" move to next fold downwards */", "  case 'k':     /* \"zk\" move to next fold upwards */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case 'j':     /* \"zj\" move to next fold downwards */", "  case 'k':     /* \"zk\" move to next fold upwards */", "    if (foldMoveTo(true, nchar == 'j' ? FORWARD : BACKWARD,"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case 'k':     /* \"zk\" move to next fold upwards */", "    if (foldMoveTo(true, nchar == 'j' ? FORWARD : BACKWARD,", "            cap->count1) == false)"], "readability/braces"]
["src/nvim/normal.c", ["    if (foldMoveTo(true, nchar == 'j' ? FORWARD : BACKWARD,", "            cap->count1) == false)", "      clearopbeep(cap->oap);"], "whitespace/alignment"]
["src/nvim/normal.c", ["", "  case 'g':     /* \"zg\": add good word to word list */", "  case 'w':     /* \"zw\": add wrong word to word list */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case 'g':     /* \"zg\": add good word to word list */", "  case 'w':     /* \"zw\": add wrong word to word list */", "  case 'G':     /* \"zG\": add good word to temp word list */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case 'w':     /* \"zw\": add wrong word to word list */", "  case 'G':     /* \"zG\": add good word to temp word list */", "  case 'W':     /* \"zW\": add wrong word to temp word list */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case 'G':     /* \"zG\": add good word to temp word list */", "  case 'W':     /* \"zW\": add wrong word to temp word list */", "  {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    if (checkclearop(cap->oap))", "      break;"], "readability/braces"]
["src/nvim/normal.c", ["      break;", "    if (VIsual_active && !get_visual_text(cap, &ptr, &len))", "      return;"], "readability/braces"]
["src/nvim/normal.c", ["", "      /* Find bad word under the cursor.  When 'spell' is", "       * off this fails and find_ident_under_cursor() is"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      emsg_off--;", "      if (len != 0 && curwin->w_cursor.col <= pos.col)", "        ptr = ml_get_pos(&curwin->w_cursor);"], "readability/braces"]
["src/nvim/normal.c", ["", "    if (ptr == NULL && (len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)", "      return;"], "readability/braces"]
["src/nvim/normal.c", ["", "  case '=':     /* \"z=\": suggestions for a badly spelled word  */", "    if (!checkclearop(cap->oap))"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case '=':     /* \"z=\": suggestions for a badly spelled word  */", "    if (!checkclearop(cap->oap))", "      spell_suggest((int)cap->count0);"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* Redraw when 'foldenable' changed */", "  if (old_fen != curwin->w_p_fen) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (foldmethodIsDiff(curwin) && curwin->w_p_scb) {", "      /* Adjust 'foldenable' in diff-synced windows. */", "      FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* Redraw when 'foldlevel' changed. */", "  if (old_fdl != curwin->w_p_fdl)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* Redraw when 'foldlevel' changed. */", "  if (old_fdl != curwin->w_p_fdl)", "    newFoldLevel();"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * \"Q\" command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  /*", "   * Ignore 'Q' in Visual mode, just give a beep."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    /* When typing, don't type below an old message */", "    if (KeyTyped)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    /* When typing, don't type below an old message */", "    if (KeyTyped)", "      compute_cmdrow();"], "readability/braces"]
["src/nvim/normal.c", ["", "    /* If 'insertmode' changed, enter or exit Insert mode */", "    if (p_im != old_p_im) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (p_im != old_p_im) {", "      if (p_im)", "        restart_edit = 'i';"], "readability/braces"]
["src/nvim/normal.c", ["        restart_edit = 'i';", "      else", "        restart_edit = 0;"], "readability/braces"]
["src/nvim/normal.c", ["", "    if (cmd_result == false)", "      /* The Ex command failed, do not execute the operator. */"], "readability/braces"]
["src/nvim/normal.c", ["    if (cmd_result == false)", "      /* The Ex command failed, do not execute the operator. */", "      clearop(cap->oap);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      clearop(cap->oap);", "    else if (cap->oap->op_type != OP_NOP", "             && (cap->oap->start.lnum > curbuf->b_ml.ml_line_count"], "readability/braces"]
["src/nvim/normal.c", ["                 || did_emsg", "                 ))", "      /* The start of the operator has become invalid by the Ex command."], "whitespace/parens"]
["src/nvim/normal.c", ["                 ))", "      /* The start of the operator has become invalid by the Ex command.", "       */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Handle CTRL-G command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (VIsual_active) {  /* toggle Selection/Visual mode */", "    VIsual_select = !VIsual_select;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    showmode();", "  } else if (!checkclearop(cap->oap))", "    /* print full name if count given or :cd used */"], "readability/braces"]
["src/nvim/normal.c", ["  } else if (!checkclearop(cap->oap))", "    /* print full name if count given or :cd used */", "    fileinfo((int)cap->count0, false, true);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Handle CTRL-H <Backspace> command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (VIsual_active && VIsual_select) {", "    cap->cmdchar = 'x';         /* BS key behaves like 'x' in Select mode */", "    v_visop(cap);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    v_visop(cap);", "  } else", "    nv_left(cap);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * CTRL-L: clear screen and redraw."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (!checkclearop(cap->oap)) {", "    /* Clear all syntax states to force resyncing. */", "    syn_stack_free_all(curwin->w_s);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * CTRL-O: In Select mode: switch to Visual mode for one command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    showmode();", "    restart_VIsual_select = 2;          /* restart Select mode later */", "  } else {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (!checkclearopq(cap->oap))", "    (void)buflist_getfile((int)cap->count0, (linenr_T)0,"], "readability/braces"]
["src/nvim/normal.c", ["    (void)buflist_getfile((int)cap->count0, (linenr_T)0,", "        GETF_SETMARK|GETF_ALT, false);", "}"], "whitespace/alignment"]
["src/nvim/normal.c", ["", "/*", " * \"Z\" commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    switch (cap->nchar) {", "    /* \"ZZ\": equivalent to \":x\". */", "    case 'Z':   do_cmdline_cmd(\"x\");"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    /* \"ZQ\": equivalent to \":q!\" (Elvis compatible). */", "    case 'Q':   do_cmdline_cmd(\"q!\");"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Call nv_ident() as if \"c1\" was used, with \"c2\" as next character."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Handle the commands that use the word under the cursor."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  char_u      *p;", "  size_t n = 0;                 /* init for GCC */", "  int cmdchar;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  int cmdchar;", "  bool g_cmd;                   /* \"g\" command */", "  bool tag_cmd = false;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (cap->cmdchar == 'g') {    /* \"g*\", \"g#\", \"g]\" and \"gCTRL-]\" */", "    cmdchar = cap->nchar;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (cmdchar == POUND)         /* the pound sign, '#' for English keyboards */", "    cmdchar = '#';"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (cmdchar == POUND)         /* the pound sign, '#' for English keyboards */", "    cmdchar = '#';"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * The \"]\", \"CTRL-]\" and \"K\" commands accept an argument in Visual mode."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (cmdchar == ']' || cmdchar == Ctrl_RSB || cmdchar == 'K') {", "    if (VIsual_active && get_visual_text(cap, &ptr, &n) == false)", "      return;"], "readability/braces"]
["src/nvim/normal.c", ["      return;", "    if (checkclearopq(cap->oap))", "      return;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* Allocate buffer to put the command in.  Inserting backslashes can", "   * double the length of the word.  p_kp / curbuf->b_p_kp could be added"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case '#':", "    /*", "     * Put cursor at start of word, makes search skip the word"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    setpcmark();", "    curwin->w_cursor.col = (colnr_T) (ptr - get_cursor_line_ptr());", ""], "whitespace/cast"]
["src/nvim/normal.c", ["", "    if (!g_cmd && vim_iswordp(ptr))", "      STRCPY(buf, \"\\\\<\");"], "readability/braces"]
["src/nvim/normal.c", ["      STRCPY(buf, \"\\\\<\");", "    no_smartcase = true;                /* don't use 'smartcase' now */", "    break;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    } else {", "      /* An external command will probably use an argument starting", "       * with \"-\" as an option.  To avoid trouble we skip the \"-\". */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      while (*ptr == '-' && n > 0) {", "        ++ptr;", "        --n;"], "readability/increment"]
["src/nvim/normal.c", ["        ++ptr;", "        --n;", "      }"], "readability/increment"]
["src/nvim/normal.c", ["      if (n == 0) {", "        EMSG(_(e_noident));              /* found dashes only */", "        xfree(buf);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "      /* When a count is given, turn it into a range.  Is this", "       * really what we want? */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        snprintf(buf + STRLEN(buf), buf_size - STRLEN(buf), \"%\" PRId64,", "            (int64_t)cap->count0);", "        STRCAT(buf, \" \");"], "whitespace/alignment"]
["src/nvim/normal.c", ["    tag_cmd = true;", "    if (p_cst)", "      STRCPY(buf, \"cstag \");"], "readability/braces"]
["src/nvim/normal.c", ["      STRCPY(buf, \"cstag \");", "    else", "      STRCPY(buf, \"ts \");"], "readability/braces"]
["src/nvim/normal.c", ["    tag_cmd = true;", "    if (curbuf->b_help)", "      STRCPY(buf, \"he! \");"], "readability/braces"]
["src/nvim/normal.c", ["      STRCPY(buf, \"he! \");", "    else {", "      if (g_cmd)"], "readability/braces"]
["src/nvim/normal.c", ["      STRCPY(buf, \"he! \");", "    else {", "      if (g_cmd)"], "readability/braces"]
["src/nvim/normal.c", ["    else {", "      if (g_cmd)", "        STRCPY(buf, \"tj \");"], "readability/braces"]
["src/nvim/normal.c", ["        STRCPY(buf, \"tj \");", "      else", "        snprintf(buf, buf_size, \"%\" PRId64 \"ta \", (int64_t)cap->count0);"], "readability/braces"]
["src/nvim/normal.c", ["  } else {", "    if (cmdchar == '*')", "      aux_ptr = (char_u *)(p_magic ? \"/.*~[^$\\\\\" : \"/^$\\\\\");"], "readability/braces"]
["src/nvim/normal.c", ["      aux_ptr = (char_u *)(p_magic ? \"/.*~[^$\\\\\" : \"/^$\\\\\");", "    else if (cmdchar == '#')", "      aux_ptr = (char_u *)(p_magic ? \"/?.*~[^$\\\\\" : \"/?^$\\\\\");"], "readability/braces"]
["src/nvim/normal.c", ["      aux_ptr = (char_u *)(p_magic ? \"/?.*~[^$\\\\\" : \"/?^$\\\\\");", "    else if (tag_cmd) {", "      if (curbuf->b_help)"], "readability/braces"]
["src/nvim/normal.c", ["    else if (tag_cmd) {", "      if (curbuf->b_help)", "        /* \":help\" handles unescaped argument */"], "readability/braces"]
["src/nvim/normal.c", ["      if (curbuf->b_help)", "        /* \":help\" handles unescaped argument */", "        aux_ptr = (char_u *)\"\";"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        aux_ptr = (char_u *)\"\";", "      else", "        aux_ptr = (char_u *)\"\\\\|\\\"\\n[\";"], "readability/braces"]
["src/nvim/normal.c", ["        aux_ptr = (char_u *)\"\\\\|\\\"\\n[\";", "    } else", "      aux_ptr = (char_u *)\"\\\\|\\\"\\n*?[\";"], "readability/braces"]
["src/nvim/normal.c", ["    while (n-- > 0) {", "      /* put a backslash before \\ and some others */", "      if (vim_strchr(aux_ptr, *ptr) != NULL)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      /* put a backslash before \\ and some others */", "      if (vim_strchr(aux_ptr, *ptr) != NULL)", "        *p++ = '\\\\';"], "readability/braces"]
["src/nvim/normal.c", ["        *p++ = '\\\\';", "      /* When current byte is a part of multibyte character, copy all", "       * bytes of that character. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * Execute the command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Get visually selected text, within one line only."], "readability/old_style_comment"]
["src/nvim/normal.c", ["bool", "get_visual_text (", "    cmdarg_T *cap,"], "whitespace/parens"]
["src/nvim/normal.c", ["    cmdarg_T *cap,", "    char_u **pp,           /* return: start of selected text */", "    size_t *lenp           /* return: length of selected text */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    char_u **pp,           /* return: start of selected text */", "    size_t *lenp           /* return: length of selected text */", ")"], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (VIsual_mode != 'V')", "    unadjust_for_sel();"], "readability/braces"]
["src/nvim/normal.c", ["  if (VIsual.lnum != curwin->w_cursor.lnum) {", "    if (cap != NULL)", "      clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * CTRL-T: backwards in tag stack"], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (!checkclearopq(cap->oap))", "    do_tag((char_u *)\"\", DT_POP, (int)cap->count1, false, true);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Handle scrolling command 'H', 'L' and 'M'."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    curwin->w_cursor.lnum = curwin->w_botline - 1;", "    if (cap->count1 - 1 >= curwin->w_cursor.lnum)", "      curwin->w_cursor.lnum = 1;"], "readability/braces"]
["src/nvim/normal.c", ["      curwin->w_cursor.lnum = 1;", "    else {", "      if (hasAnyFolding(curwin)) {"], "readability/braces"]
["src/nvim/normal.c", ["      curwin->w_cursor.lnum = 1;", "    else {", "      if (hasAnyFolding(curwin)) {"], "readability/braces"]
["src/nvim/normal.c", ["      if (hasAnyFolding(curwin)) {", "        /* Count a fold for one screen line. */", "        for (n = cap->count1 - 1; n > 0"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        for (n = cap->count1 - 1; n > 0", "             && curwin->w_cursor.lnum > curwin->w_topline; --n) {", "          (void)hasFolding(curwin->w_cursor.lnum,"], "readability/increment"]
["src/nvim/normal.c", ["          (void)hasFolding(curwin->w_cursor.lnum,", "              &curwin->w_cursor.lnum, NULL);", "          --curwin->w_cursor.lnum;"], "whitespace/alignment"]
["src/nvim/normal.c", ["              &curwin->w_cursor.lnum, NULL);", "          --curwin->w_cursor.lnum;", "        }"], "readability/increment"]
["src/nvim/normal.c", ["        }", "      } else", "        curwin->w_cursor.lnum -= cap->count1 - 1;"], "readability/braces"]
["src/nvim/normal.c", ["    if (cap->cmdchar == 'M') {", "      /* Don't count filler lines above the window. */", "      used -= diff_check_fill(curwin, curwin->w_topline)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        if (n > 0 && used + diff_check_fill(curwin, curwin->w_topline", "                + n) / 2 >= half) {", "          --n;"], "whitespace/alignment"]
["src/nvim/normal.c", ["                + n) / 2 >= half) {", "          --n;", "          break;"], "readability/increment"]
["src/nvim/normal.c", ["        used += plines(curwin->w_topline + n);", "        if (used >= half)", "          break;"], "readability/braces"]
["src/nvim/normal.c", ["          break;", "        if (hasFolding(curwin->w_topline + n, NULL, &lnum))", "          n = lnum - curwin->w_topline;"], "readability/braces"]
["src/nvim/normal.c", ["      if (hasAnyFolding(curwin)) {", "        /* Count a fold for one screen line. */", "        lnum = curwin->w_topline;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["          hasFolding(lnum, NULL, &lnum);", "          ++lnum;", "        }"], "readability/increment"]
["src/nvim/normal.c", ["    curwin->w_cursor.lnum = curwin->w_topline + n;", "    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)", "      curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Cursor right commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)) {", "    /* <C-Right> and <S-Right> move a word or WORD right */", "    if (mod_mask & MOD_MASK_CTRL)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    /* <C-Right> and <S-Right> move a word or WORD right */", "    if (mod_mask & MOD_MASK_CTRL)", "      cap->arg = true;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * In virtual mode, there's no such thing as \"PAST_LINE\", as lines are"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  if (virtual_active())", "    PAST_LINE = 0;"], "readability/braces"]
["src/nvim/normal.c", ["", "  for (n = cap->count1; n > 0; --n) {", "    if ((!PAST_LINE && oneright() == false)"], "readability/increment"]
["src/nvim/normal.c", ["        } else {", "          ++curwin->w_cursor.lnum;", "          curwin->w_cursor.col = 0;"], "readability/increment"]
["src/nvim/normal.c", ["  }", "  if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped", "      && cap->oap->op_type == OP_NOP)"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Cursor left commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)) {", "    /* <C-Left> and <S-Left> move a word or WORD left */", "    if (mod_mask & MOD_MASK_CTRL)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    /* <C-Left> and <S-Left> move a word or WORD left */", "    if (mod_mask & MOD_MASK_CTRL)", "      cap->arg = 1;"], "readability/braces"]
["src/nvim/normal.c", ["  cap->oap->inclusive = false;", "  for (n = cap->count1; n > 0; --n) {", "    if (oneleft() == false) {"], "readability/increment"]
["src/nvim/normal.c", ["    if (oneleft() == false) {", "      /* <BS> and <Del> wrap to previous line if 'whichwrap' has 'b'.", "       *\t\t 'h' wraps to previous line if 'whichwrap' has 'h'."], "readability/old_style_comment"]
["src/nvim/normal.c", ["      }", "      /* Only beep and flush if not moved at all */", "      else if (cap->oap->op_type == OP_NOP && n == cap->count1)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      /* Only beep and flush if not moved at all */", "      else if (cap->oap->op_type == OP_NOP && n == cap->count1)", "        beep_flush();"], "whitespace/newline"]
["src/nvim/normal.c", ["  }", "  if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped", "      && cap->oap->op_type == OP_NOP)"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Cursor up commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (mod_mask & MOD_MASK_SHIFT) {", "    /* <S-Up> is page up */", "    cap->arg = BACKWARD;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Cursor down commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (mod_mask & MOD_MASK_SHIFT) {", "    /* <S-Down> is page down */", "    cap->arg = FORWARD;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Grab the file name under the cursor and edit it."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    xfree(ptr);", "  } else", "    clearop(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * <End> command: to end of current line or last line."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (cap->arg || (mod_mask & MOD_MASK_CTRL)) { /* CTRL-END = goto last line */", "    cap->arg = true;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    nv_goto(cap);", "    cap->count1 = 1;                    /* to end of current line */", "  }"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Handle the \"$\" command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  cap->oap->inclusive = true;", "  /* In virtual mode when off the edge of a line and an operator", "   * is pending (whew!) keep the cursor where it is."], "readability/old_style_comment"]
["src/nvim/normal.c", ["   * Otherwise, send it to the end of the line. */", "  if (!virtual_active() || gchar_cursor() != NUL", "      || cap->oap->op_type == OP_NOP)"], "readability/braces"]
["src/nvim/normal.c", ["      || cap->oap->op_type == OP_NOP)", "    curwin->w_curswant = MAXCOL;        /* so we stay at the end */", "  if (cursor_down(cap->count1 - 1,"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    curwin->w_curswant = MAXCOL;        /* so we stay at the end */", "  if (cursor_down(cap->count1 - 1,", "          cap->oap->op_type == OP_NOP) == false)"], "readability/braces"]
["src/nvim/normal.c", ["  if (cursor_down(cap->count1 - 1,", "          cap->oap->op_type == OP_NOP) == false)", "    clearopbeep(cap->oap);"], "whitespace/alignment"]
["src/nvim/normal.c", ["    clearopbeep(cap->oap);", "  else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)", "    foldOpenCursor();"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Implementation of '?' and '/' commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (cap->cmdchar == '?' && cap->oap->op_type == OP_ROT13) {", "    /* Translate \"g??\" to \"g?g?\" */", "    cap->cmdchar = 'g';"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Handle \"N\" and \"n\" commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Search for \"pat\" in direction \"dir\" ('/' or '?', 0 for repeat)."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    curwin->w_cursor.coladd = 0;", "    if (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)", "      foldOpenCursor();"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* \"/$\" will put the cursor after the end of the line, may need to", "   * correct that here */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Character search commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (cap->cmdchar == 't' || cap->cmdchar == 'T')", "    t_cmd = true;"], "readability/braces"]
["src/nvim/normal.c", ["    t_cmd = true;", "  else", "    t_cmd = false;"], "readability/braces"]
["src/nvim/normal.c", ["    curwin->w_set_curswant = true;", "    /* Include a Tab for \"tx\" and for \"dfx\". */", "    if (gchar_cursor() == TAB && virtual_active() && cap->arg == FORWARD"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      curwin->w_cursor.coladd = ecol - scol;", "    } else", "      curwin->w_cursor.coladd = 0;"], "readability/braces"]
["src/nvim/normal.c", ["    adjust_for_sel(cap);", "    if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)", "      foldOpenCursor();"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * \"[\" and \"]\" commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  pos_T prev_pos;", "  pos_T       *pos = NULL;          /* init for GCC */", "  pos_T old_pos;                    /* cursor position before command */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  pos_T       *pos = NULL;          /* init for GCC */", "  pos_T old_pos;                    /* cursor position before command */", "  int flag;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  old_pos = curwin->w_cursor;", "  curwin->w_cursor.coladd = 0;              /* TODO: don't do this for an error. */", ""], "readability/old_style_comment"]
["src/nvim/normal.c", ["  old_pos = curwin->w_cursor;", "  curwin->w_cursor.coladd = 0;              /* TODO: don't do this for an error. */", ""], "whitespace/line_length"]
["src/nvim/normal.c", ["", "  /*", "   * \"[f\" or \"]f\" : Edit file under the cursor (same as \"gf\")"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  if (cap->nchar == 'f')", "    nv_gotofile(cap);"], "readability/braces"]
["src/nvim/normal.c", ["    nv_gotofile(cap);", "  else", "  /*"], "readability/braces"]
["src/nvim/normal.c", ["  else", "  /*", "   * Find the occurrence(s) of the identifier or define under cursor"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (vim_strchr((char_u *)", "          \"iI\\011dD\\004\",", "          cap->nchar) != NULL) {"], "whitespace/alignment"]
["src/nvim/normal.c", ["          \"iI\\011dD\\004\",", "          cap->nchar) != NULL) {", "    char_u  *ptr;"], "whitespace/alignment"]
["src/nvim/normal.c", ["", "    if ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)", "      clearop(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["      clearop(cap->oap);", "    else {", "      find_pattern_in_path(ptr, 0, len, true,"], "readability/braces"]
["src/nvim/normal.c", ["      clearop(cap->oap);", "    else {", "      find_pattern_in_path(ptr, 0, len, true,"], "readability/braces"]
["src/nvim/normal.c", ["    }", "  } else", "  /*"], "readability/braces"]
["src/nvim/normal.c", ["  } else", "  /*", "   * \"[{\", \"[(\", \"]}\" or \"])\": go to Nth unclosed '{', '(', '}' or ')'"], "readability/old_style_comment"]
["src/nvim/normal.c", ["         && vim_strchr((char_u *)\"{(*/#mM\", cap->nchar) != NULL)", "        || (cap->cmdchar == ']'", "            && vim_strchr((char_u *)\"})*/#mM\", cap->nchar) != NULL)) {"], "whitespace/alignment"]
["src/nvim/normal.c", ["            && vim_strchr((char_u *)\"})*/#mM\", cap->nchar) != NULL)) {", "    if (cap->nchar == '*')", "      cap->nchar = '/';"], "readability/braces"]
["src/nvim/normal.c", ["    if (cap->nchar == 'm' || cap->nchar == 'M') {", "      if (cap->cmdchar == '[')", "        findc = '{';"], "readability/braces"]
["src/nvim/normal.c", ["        findc = '{';", "      else", "        findc = '}';"], "readability/braces"]
["src/nvim/normal.c", ["    }", "    for (; n > 0; --n) {", "      if ((pos = findmatchlimit(cap->oap, findc,"], "readability/increment"]
["src/nvim/normal.c", ["      if ((pos = findmatchlimit(cap->oap, findc,", "               (cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD, 0)) == NULL) {", "        if (new_pos.lnum == 0) {        /* nothing found */"], "whitespace/alignment"]
["src/nvim/normal.c", ["               (cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD, 0)) == NULL) {", "        if (new_pos.lnum == 0) {        /* nothing found */", "          if (cap->nchar != 'm' && cap->nchar != 'M')"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        if (new_pos.lnum == 0) {        /* nothing found */", "          if (cap->nchar != 'm' && cap->nchar != 'M')", "            clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["            clearopbeep(cap->oap);", "        } else", "          pos = &new_pos;               /* use last one found */"], "readability/braces"]
["src/nvim/normal.c", ["        } else", "          pos = &new_pos;               /* use last one found */", "        break;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    /*", "     * Handle \"[m\", \"]m\", \"[M\" and \"[M\".  The findmatchlimit() only"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (cap->nchar == 'm' || cap->nchar == 'M') {", "      /* norm is true for \"]M\" and \"[m\" */", "      int norm = ((findc == '{') == (cap->nchar == 'm'));"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      n = cap->count1;", "      /* found a match: we were inside a method */", "      if (prev_pos.lnum != 0) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        curwin->w_cursor = prev_pos;", "        if (norm)", "          --n;"], "readability/braces"]
["src/nvim/normal.c", ["        if (norm)", "          --n;", "      } else"], "readability/increment"]
["src/nvim/normal.c", ["          --n;", "      } else", "        pos = NULL;"], "readability/braces"]
["src/nvim/normal.c", ["          if ((findc == '{' ? dec_cursor() : inc_cursor()) < 0) {", "            /* if not found anything, that's an error */", "            if (pos == NULL)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["            /* if not found anything, that's an error */", "            if (pos == NULL)", "              clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["          if (c == '{' || c == '}') {", "            /* Must have found end/start of class: use it.", "             * Or found the place to be at. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["            }", "            /* if no match found at all, we started outside of the", "             * class and we're inside now.  Just go on. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["             * class and we're inside now.  Just go on. */", "            else if (new_pos.lnum == 0) {", "              new_pos = curwin->w_cursor;"], "whitespace/newline"]
["src/nvim/normal.c", ["            }", "            /* found start/end of other method: go to match */", "            else if ((pos = findmatchlimit(cap->oap, findc,"], "readability/old_style_comment"]
["src/nvim/normal.c", ["            /* found start/end of other method: go to match */", "            else if ((pos = findmatchlimit(cap->oap, findc,", "                          (cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD,"], "whitespace/newline"]
["src/nvim/normal.c", ["            else if ((pos = findmatchlimit(cap->oap, findc,", "                          (cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD,", "                          0)) == NULL)"], "whitespace/alignment"]
["src/nvim/normal.c", ["                          (cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD,", "                          0)) == NULL)", "              n = 0;"], "whitespace/alignment"]
["src/nvim/normal.c", ["              n = 0;", "            else", "              curwin->w_cursor = *pos;"], "readability/braces"]
["src/nvim/normal.c", ["        }", "        --n;", "      }"], "readability/increment"]
["src/nvim/normal.c", ["      curwin->w_cursor = old_pos;", "      if (pos == NULL && new_pos.lnum != 0)", "        clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["      curwin->w_set_curswant = true;", "      if ((fdo_flags & FDO_BLOCK) && KeyTyped", "          && cap->oap->op_type == OP_NOP)"], "readability/braces"]
["src/nvim/normal.c", ["  }", "  /*", "   * \"[[\", \"[]\", \"]]\" and \"][\": move to start or end of function"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  else if (cap->nchar == '[' || cap->nchar == ']') {", "    if (cap->nchar == cap->cmdchar)                 /* \"]]\" or \"[[\" */"], "whitespace/newline"]
["src/nvim/normal.c", ["  else if (cap->nchar == '[' || cap->nchar == ']') {", "    if (cap->nchar == cap->cmdchar)                 /* \"]]\" or \"[[\" */", "      flag = '{';"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  else if (cap->nchar == '[' || cap->nchar == ']') {", "    if (cap->nchar == cap->cmdchar)                 /* \"]]\" or \"[[\" */", "      flag = '{';"], "readability/braces"]
["src/nvim/normal.c", ["      flag = '{';", "    else", "      flag = '}';                   /* \"][\" or \"[]\" */"], "readability/braces"]
["src/nvim/normal.c", ["    else", "      flag = '}';                   /* \"][\" or \"[]\" */", ""], "readability/old_style_comment"]
["src/nvim/normal.c", ["    curwin->w_set_curswant = true;", "    /*", "     * Imitate strange Vi behaviour: When using \"]]\" with an operator"], "readability/old_style_comment"]
["src/nvim/normal.c", ["     */", "    if (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, flag,", "            (cap->oap->op_type != OP_NOP"], "readability/braces"]
["src/nvim/normal.c", ["    if (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, flag,", "            (cap->oap->op_type != OP_NOP", "             && cap->arg == FORWARD && flag == '{')))"], "whitespace/alignment"]
["src/nvim/normal.c", ["      clearopbeep(cap->oap);", "    else {", "      if (cap->oap->op_type == OP_NOP)"], "readability/braces"]
["src/nvim/normal.c", ["      clearopbeep(cap->oap);", "    else {", "      if (cap->oap->op_type == OP_NOP)"], "readability/braces"]
["src/nvim/normal.c", ["    else {", "      if (cap->oap->op_type == OP_NOP)", "        beginline(BL_WHITE | BL_FIX);"], "readability/braces"]
["src/nvim/normal.c", ["        beginline(BL_WHITE | BL_FIX);", "      if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)", "        foldOpenCursor();"], "readability/braces"]
["src/nvim/normal.c", ["  }", "  /*", "   * \"['\", \"[`\", \"]'\" and \"]`\": jump to next mark"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  else if (cap->nchar == '\\'' || cap->nchar == '`') {", "    pos = &curwin->w_cursor;"], "whitespace/newline"]
["src/nvim/normal.c", ["    pos = &curwin->w_cursor;", "    for (n = cap->count1; n > 0; --n) {", "      prev_pos = *pos;"], "readability/increment"]
["src/nvim/normal.c", ["      pos = getnextmark(pos, cap->cmdchar == '[' ? BACKWARD : FORWARD,", "          cap->nchar == '\\'');", "      if (pos == NULL)"], "whitespace/alignment"]
["src/nvim/normal.c", ["          cap->nchar == '\\'');", "      if (pos == NULL)", "        break;"], "readability/braces"]
["src/nvim/normal.c", ["    }", "    if (pos == NULL)", "      pos = &prev_pos;"], "readability/braces"]
["src/nvim/normal.c", ["  }", "  /*", "   * [ or ] followed by a middle mouse click: put selected text with"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  else if (cap->nchar >= K_RIGHTRELEASE && cap->nchar <= K_LEFTMOUSE) {", "    (void)do_mouse(cap->oap, cap->nchar,"], "whitespace/newline"]
["src/nvim/normal.c", ["    (void)do_mouse(cap->oap, cap->nchar,", "        (cap->cmdchar == ']') ? FORWARD : BACKWARD,", "        cap->count1, PUT_FIXINDENT);"], "whitespace/alignment"]
["src/nvim/normal.c", ["        (cap->cmdchar == ']') ? FORWARD : BACKWARD,", "        cap->count1, PUT_FIXINDENT);", "  }"], "whitespace/alignment"]
["src/nvim/normal.c", ["  }", "  /*", "   * \"[z\" and \"]z\": move to start or end of open fold."], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  else if (cap->nchar == 'z') {", "    if (foldMoveTo(false, cap->cmdchar == ']' ? FORWARD : BACKWARD,"], "whitespace/newline"]
["src/nvim/normal.c", ["  else if (cap->nchar == 'z') {", "    if (foldMoveTo(false, cap->cmdchar == ']' ? FORWARD : BACKWARD,", "            cap->count1) == false)"], "readability/braces"]
["src/nvim/normal.c", ["    if (foldMoveTo(false, cap->cmdchar == ']' ? FORWARD : BACKWARD,", "            cap->count1) == false)", "      clearopbeep(cap->oap);"], "whitespace/alignment"]
["src/nvim/normal.c", ["  }", "  /*", "   * \"[c\" and \"]c\": move to next or previous diff-change."], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  else if (cap->nchar == 'c') {", "    if (diff_move_to(cap->cmdchar == ']' ? FORWARD : BACKWARD,"], "whitespace/newline"]
["src/nvim/normal.c", ["  else if (cap->nchar == 'c') {", "    if (diff_move_to(cap->cmdchar == ']' ? FORWARD : BACKWARD,", "            cap->count1) == false)"], "readability/braces"]
["src/nvim/normal.c", ["    if (diff_move_to(cap->cmdchar == ']' ? FORWARD : BACKWARD,", "            cap->count1) == false)", "      clearopbeep(cap->oap);"], "whitespace/alignment"]
["src/nvim/normal.c", ["  }", "  /*", "   * \"[s\", \"[S\", \"]s\" and \"]S\": move to next spell error."], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  else if (cap->nchar == 's' || cap->nchar == 'S') {", "    setpcmark();"], "whitespace/newline"]
["src/nvim/normal.c", ["    setpcmark();", "    for (n = 0; n < cap->count1; ++n)", "      if (spell_move_to(curwin, cap->cmdchar == ']' ? FORWARD : BACKWARD,"], "readability/braces"]
["src/nvim/normal.c", ["    setpcmark();", "    for (n = 0; n < cap->count1; ++n)", "      if (spell_move_to(curwin, cap->cmdchar == ']' ? FORWARD : BACKWARD,"], "readability/increment"]
["src/nvim/normal.c", ["      }", "    if (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)", "      foldOpenCursor();"], "readability/braces"]
["src/nvim/normal.c", ["  }", "  /* Not a valid cap->nchar. */", "  else"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* Not a valid cap->nchar. */", "  else", "    clearopbeep(cap->oap);"], "whitespace/newline"]
["src/nvim/normal.c", ["", "/*", " * Handle Normal mode \"%\" command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    cap->oap->use_reg_one = true;", "    if ((pos = findmatch(cap->oap, NUL)) == NULL)", "      clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["      clearopbeep(cap->oap);", "    else {", "      setpcmark();"], "readability/braces"]
["src/nvim/normal.c", ["      clearopbeep(cap->oap);", "    else {", "      setpcmark();"], "readability/braces"]
["src/nvim/normal.c", ["  }", "  if (cap->oap->op_type == OP_NOP", "      && lnum != curwin->w_cursor.lnum"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Handle \"(\" and \")\" commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  cap->oap->use_reg_one = true;", "  /* The motion used to be inclusive for \"(\", but that is not what Vi does. */", "  cap->oap->inclusive = false;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (findsent(cap->arg, cap->count1) == false)", "    clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["    clearopbeep(cap->oap);", "  else {", "    /* Don't leave the cursor on the NUL past end of line. */"], "readability/braces"]
["src/nvim/normal.c", ["    clearopbeep(cap->oap);", "  else {", "    /* Don't leave the cursor on the NUL past end of line. */"], "readability/braces"]
["src/nvim/normal.c", ["  else {", "    /* Don't leave the cursor on the NUL past end of line. */", "    adjust_cursor(cap->oap);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    curwin->w_cursor.coladd = 0;", "    if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)", "      foldOpenCursor();"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * \"m\" command: Mark a position."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (!checkclearop(cap->oap)) {", "    if (setmark(cap->nchar) == false)", "      clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * \"{\" and \"}\" commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  curwin->w_set_curswant = true;", "  if (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, NUL, false))", "    clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["    clearopbeep(cap->oap);", "  else {", "    curwin->w_cursor.coladd = 0;"], "readability/braces"]
["src/nvim/normal.c", ["    clearopbeep(cap->oap);", "  else {", "    curwin->w_cursor.coladd = 0;"], "readability/braces"]
["src/nvim/normal.c", ["    curwin->w_cursor.coladd = 0;", "    if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)", "      foldOpenCursor();"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * \"u\" command: Undo or make lower case."], "readability/old_style_comment"]
["src/nvim/normal.c", ["      ) {", "    /* translate \"<Visual>u\" to \"<Visual>gu\" and \"guu\" to \"gugu\" */", "    cap->cmdchar = 'g';"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    nv_operator(cap);", "  } else", "    nv_kundo(cap);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * <Undo> command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Handle the \"r\" command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* get another character */", "  if (cap->nchar == Ctrl_V) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    cap->nchar = get_literal();", "    /* Don't redo a multibyte character with CTRL-V. */", "    if (cap->nchar > DEL)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    /* Don't redo a multibyte character with CTRL-V. */", "    if (cap->nchar > DEL)", "      had_ctrl_v = NUL;"], "readability/braces"]
["src/nvim/normal.c", ["      had_ctrl_v = NUL;", "  } else", "    had_ctrl_v = NUL;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* Abort if the character is a special key. */", "  if (IS_SPECIAL(cap->nchar)) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* Visual mode \"r\" */", "  if (VIsual_active) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (VIsual_active) {", "    if (got_int)", "      reset_VIsual();"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* Break tabs, etc. */", "  if (virtual_active()) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (virtual_active()) {", "    if (u_save_cursor() == false)", "      return;"], "readability/braces"]
["src/nvim/normal.c", ["    if (gchar_cursor() == NUL) {", "      /* Add extra space and put the cursor on the first one. */", "      coladvance_force((colnr_T)(getviscol() + cap->count1));"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      curwin->w_cursor.col -= (colnr_T)cap->count1;", "    } else if (gchar_cursor() == TAB)", "      coladvance_force(getviscol());"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* Abort if not enough characters to replace. */", "  ptr = get_cursor_pos_ptr();"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* save line for undo */", "  if (u_save_cursor() == false)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* save line for undo */", "  if (u_save_cursor() == false)", "    return;"], "readability/braces"]
["src/nvim/normal.c", ["  if (had_ctrl_v != Ctrl_V && (cap->nchar == '\\r' || cap->nchar == '\\n')) {", "    /*", "     * Replace character(s) by a single newline."], "readability/old_style_comment"]
["src/nvim/normal.c", ["     */", "    (void)del_chars(cap->count1, false);        /* delete the characters */", "    stuffcharReadbuff('\\r');"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    /* Give 'r' to edit(), to get the redo command right. */", "    invoke_edit(cap, true, 'r', false);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    prep_redo(cap->oap->regname, cap->count1,", "        NUL, 'r', NUL, had_ctrl_v, cap->nchar);", ""], "whitespace/alignment"]
["src/nvim/normal.c", ["    }", "    --curwin->w_cursor.col;         /* cursor on the last replaced char */", "    /* if the character on the left of the current cursor is a multi-byte"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    }", "    --curwin->w_cursor.col;         /* cursor on the last replaced char */", "    /* if the character on the left of the current cursor is a multi-byte"], "readability/increment"]
["src/nvim/normal.c", ["    --curwin->w_cursor.col;         /* cursor on the last replaced char */", "    /* if the character on the left of the current cursor is a multi-byte", "     * character, move two characters left */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * 'o': Exchange start and end of Visual area."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    curwin->w_curswant = right;", "    /* 'selection \"exclusive\" and cursor at right-bottom corner: move it", "     * right one column */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["     * right one column */", "    if (old_cursor.lnum >= VIsual.lnum && *p_sel == 'e')", "      ++curwin->w_curswant;"], "readability/braces"]
["src/nvim/normal.c", ["    if (old_cursor.lnum >= VIsual.lnum && *p_sel == 'e')", "      ++curwin->w_curswant;", "    coladvance(curwin->w_curswant);"], "readability/increment"]
["src/nvim/normal.c", ["      curwin->w_cursor.lnum = VIsual.lnum;", "      if (old_cursor.lnum <= VIsual.lnum && *p_sel == 'e')", "        ++right;"], "readability/braces"]
["src/nvim/normal.c", ["      if (old_cursor.lnum <= VIsual.lnum && *p_sel == 'e')", "        ++right;", "      coladvance(right);"], "readability/increment"]
["src/nvim/normal.c", ["", "/*", " * \"R\" (cap->arg is false) and \"gR\" (cap->arg is true)."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (VIsual_active) {          /* \"R\" is replace lines */", "    cap->cmdchar = 'c';"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    cap->nchar = NUL;", "    VIsual_mode_orig = VIsual_mode;     /* remember original area for gv */", "    VIsual_mode = 'V';"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    } else {", "      if (virtual_active())", "        coladvance(getviscol());"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * \"gr\"."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    cap->nchar = cap->extra_char;", "    nv_replace(cap);            /* Do same as \"r\" in Visual mode for now */", "  } else if (!checkclearopq(cap->oap)) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    } else {", "      if (cap->extra_char == Ctrl_V)            /* get another character */", "        cap->extra_char = get_literal();"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    } else {", "      if (cap->extra_char == Ctrl_V)            /* get another character */", "        cap->extra_char = get_literal();"], "readability/braces"]
["src/nvim/normal.c", ["      stuffcharReadbuff(ESC);", "      if (virtual_active())", "        coladvance(getviscol());"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Swap case for \"~\" command, when it does not work like an operator."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (u_save_cursor() == false)", "    return;"], "readability/braces"]
["src/nvim/normal.c", ["  startpos = curwin->w_cursor;", "  for (n = cap->count1; n > 0; --n) {", "    did_change |= swapchar(cap->oap->op_type, &curwin->w_cursor);"], "readability/increment"]
["src/nvim/normal.c", ["          && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count) {", "        ++curwin->w_cursor.lnum;", "        curwin->w_cursor.col = 0;"], "readability/increment"]
["src/nvim/normal.c", ["        if (n > 1) {", "          if (u_savesub(curwin->w_cursor.lnum) == false)", "            break;"], "readability/braces"]
["src/nvim/normal.c", ["        }", "      } else", "        break;"], "readability/braces"]
["src/nvim/normal.c", ["    curbuf->b_op_end = curwin->w_cursor;", "    if (curbuf->b_op_end.col > 0)", "      --curbuf->b_op_end.col;"], "readability/braces"]
["src/nvim/normal.c", ["    if (curbuf->b_op_end.col > 0)", "      --curbuf->b_op_end.col;", "  }"], "readability/increment"]
["src/nvim/normal.c", ["", "/*", " * Move cursor to mark."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (check_mark(pos) == false)", "    clearop(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["    clearop(cap->oap);", "  else {", "    if (cap->cmdchar == '\\''"], "readability/braces"]
["src/nvim/normal.c", ["    clearop(cap->oap);", "  else {", "    if (cap->cmdchar == '\\''"], "readability/braces"]
["src/nvim/normal.c", ["  else {", "    if (cap->cmdchar == '\\''", "        || cap->cmdchar == '`'"], "readability/braces"]
["src/nvim/normal.c", ["    curwin->w_cursor = *pos;", "    if (flag)", "      beginline(BL_WHITE | BL_FIX);"], "readability/braces"]
["src/nvim/normal.c", ["      beginline(BL_WHITE | BL_FIX);", "    else", "      check_cursor();"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Handle commands that are operators in Visual mode."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* Uppercase means linewise, except in block mode, then \"D\" deletes till", "   * the end of the line, and \"C\" replaces till EOL */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      VIsual_mode = 'V';", "    } else if (cap->cmdchar == 'C' || cap->cmdchar == 'D')", "      curwin->w_curswant = MAXCOL;"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * \"s\" and \"S\" commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    nv_operator(cap);", "  } else", "    nv_optrans(cap);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Abbreviated commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (cap->cmdchar == K_DEL || cap->cmdchar == K_KDEL)", "    cap->cmdchar = 'x';                 /* DEL key behaves like 'x' */"], "readability/braces"]
["src/nvim/normal.c", ["  if (cap->cmdchar == K_DEL || cap->cmdchar == K_KDEL)", "    cap->cmdchar = 'x';                 /* DEL key behaves like 'x' */", ""], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* in Visual mode these commands are operators */", "  if (VIsual_active)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* in Visual mode these commands are operators */", "  if (VIsual_active)", "    v_visop(cap);"], "readability/braces"]
["src/nvim/normal.c", ["    v_visop(cap);", "  else", "    nv_optrans(cap);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Translate a command into another command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * \"'\" and \"`\" commands.  Also for \"g'\" and \"g`\"."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (cap->cmdchar == 'g')", "    c = cap->extra_char;"], "readability/braces"]
["src/nvim/normal.c", ["    c = cap->extra_char;", "  else", "    c = cap->nchar;"], "readability/braces"]
["src/nvim/normal.c", ["  pos = getmark(c, (cap->oap->op_type == OP_NOP));", "  if (pos == (pos_T *)-1) {         /* jumped to other file */", "    if (cap->arg) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      beginline(BL_WHITE | BL_FIX);", "    } else", "      check_cursor();"], "readability/braces"]
["src/nvim/normal.c", ["      check_cursor();", "  } else", "    nv_cursormark(cap, cap->arg, pos);"], "readability/braces"]
["src/nvim/normal.c", ["      check_cursor();", "    } else if (pos != NULL)                 /* can jump */", "      nv_cursormark(cap, false, pos);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      check_cursor();", "    } else if (pos != NULL)                 /* can jump */", "      nv_cursormark(cap, false, pos);"], "readability/braces"]
["src/nvim/normal.c", ["      nv_cursormark(cap, false, pos);", "    else if (cap->cmdchar == 'g') {", "      if (curbuf->b_changelistlen == 0)"], "readability/braces"]
["src/nvim/normal.c", ["    else if (cap->cmdchar == 'g') {", "      if (curbuf->b_changelistlen == 0)", "        EMSG(_(\"E664: changelist is empty\"));"], "readability/braces"]
["src/nvim/normal.c", ["        EMSG(_(\"E664: changelist is empty\"));", "      else if (cap->count1 < 0)", "        EMSG(_(\"E662: At start of changelist\"));"], "readability/braces"]
["src/nvim/normal.c", ["        EMSG(_(\"E662: At start of changelist\"));", "      else", "        EMSG(_(\"E663: At end of changelist\"));"], "readability/braces"]
["src/nvim/normal.c", ["        EMSG(_(\"E663: At end of changelist\"));", "    } else", "      clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["      clearopbeep(cap->oap);", "    if (cap->oap->op_type == OP_NOP", "        && (pos == (pos_T *)-1 || lnum != curwin->w_cursor.lnum)"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Handle '\"' command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (checkclearop(cap->oap))", "    return;"], "readability/braces"]
["src/nvim/normal.c", ["    return;", "  if (cap->nchar == '=')", "    cap->nchar = get_expr_register();"], "readability/braces"]
["src/nvim/normal.c", ["    cap->oap->regname = cap->nchar;", "    cap->opcount = cap->count0;         /* remember count before '\"' */", "    set_reg_var(cap->oap->regname);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    set_reg_var(cap->oap->regname);", "  } else", "    clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Handle \"v\", \"V\" and \"CTRL-V\" commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (cap->cmdchar == Ctrl_Q)", "    cap->cmdchar = Ctrl_V;"], "readability/braces"]
["src/nvim/normal.c", ["  VIsual_select = cap->arg;", "  if (VIsual_active) {      /* change Visual mode */", "    if (VIsual_mode == cap->cmdchar)        /* stop visual mode */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (VIsual_active) {      /* change Visual mode */", "    if (VIsual_mode == cap->cmdchar)        /* stop visual mode */", "      end_visual_mode();"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (VIsual_active) {      /* change Visual mode */", "    if (VIsual_mode == cap->cmdchar)        /* stop visual mode */", "      end_visual_mode();"], "readability/braces"]
["src/nvim/normal.c", ["      end_visual_mode();", "    else {                                  /* toggle char/block mode */", "                                            /*\t   or char/line mode */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      end_visual_mode();", "    else {                                  /* toggle char/block mode */", "                                            /*\t   or char/line mode */"], "readability/braces"]
["src/nvim/normal.c", ["      end_visual_mode();", "    else {                                  /* toggle char/block mode */", "                                            /*\t   or char/line mode */"], "readability/braces"]
["src/nvim/normal.c", ["    else {                                  /* toggle char/block mode */", "                                            /*\t   or char/line mode */", "      VIsual_mode = cap->cmdchar;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    else {                                  /* toggle char/block mode */", "                                            /*\t   or char/line mode */", "      VIsual_mode = cap->cmdchar;"], "whitespace/tab"]
["src/nvim/normal.c", ["    if (cap->count0 > 0 && resel_VIsual_mode != NUL) {", "      /* use previously selected part */", "      VIsual = curwin->w_cursor;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      VIsual_reselect = true;", "      if (!cap->arg)", "        /* start Select mode when 'selectmode' contains \"cmd\" */"], "readability/braces"]
["src/nvim/normal.c", ["      if (!cap->arg)", "        /* start Select mode when 'selectmode' contains \"cmd\" */", "        may_start_select('c');"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      setmouse();", "      if (p_smd && msg_silent == 0)", "        redraw_cmdline = true;              /* show visual mode later */"], "readability/braces"]
["src/nvim/normal.c", ["      if (p_smd && msg_silent == 0)", "        redraw_cmdline = true;              /* show visual mode later */", "      /*"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        redraw_cmdline = true;              /* show visual mode later */", "      /*", "       * For V and ^V, we multiply the number of lines even if there"], "readability/old_style_comment"]
["src/nvim/normal.c", ["          resel_VIsual_line_count * cap->count0 - 1;", "        if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)", "          curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/normal.c", ["                                + resel_VIsual_vcol * (int)cap->count0 - 1);", "        } else", "          curwin->w_curswant = resel_VIsual_vcol;"], "readability/braces"]
["src/nvim/normal.c", ["        coladvance(curwin->w_curswant);", "      } else", "        curwin->w_set_curswant = true;"], "readability/braces"]
["src/nvim/normal.c", ["        curwin->w_set_curswant = true;", "      redraw_curbuf_later(INVERTED);            /* show the inversion */", "    } else {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    } else {", "      if (!cap->arg)", "        /* start Select mode when 'selectmode' contains \"cmd\" */"], "readability/braces"]
["src/nvim/normal.c", ["      if (!cap->arg)", "        /* start Select mode when 'selectmode' contains \"cmd\" */", "        may_start_select('c');"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      n_start_visual_mode(cap->cmdchar);", "      if (VIsual_mode != 'V' && *p_sel == 'e')", "        ++cap->count1;          /* include one more char */"], "readability/braces"]
["src/nvim/normal.c", ["      if (VIsual_mode != 'V' && *p_sel == 'e')", "        ++cap->count1;          /* include one more char */", "      if (cap->count0 > 0 && --cap->count1 > 0) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      if (VIsual_mode != 'V' && *p_sel == 'e')", "        ++cap->count1;          /* include one more char */", "      if (cap->count0 > 0 && --cap->count1 > 0) {"], "readability/increment"]
["src/nvim/normal.c", ["      if (cap->count0 > 0 && --cap->count1 > 0) {", "        /* With a count select that many characters or lines. */", "        if (VIsual_mode == 'v' || VIsual_mode == Ctrl_V)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        /* With a count select that many characters or lines. */", "        if (VIsual_mode == 'v' || VIsual_mode == Ctrl_V)", "          nv_right(cap);"], "readability/braces"]
["src/nvim/normal.c", ["          nv_right(cap);", "        else if (VIsual_mode == 'V')", "          nv_down(cap);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Start selection for Shift-movement keys."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  /* if 'selectmode' contains \"key\", start Select mode */", "  may_start_select('k');"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Start Select mode, if \"c\" is in 'selectmode' and not in a mapping or menu."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Start Visual mode \"c\"."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  VIsual_reselect = true;", "  /* Corner case: the 0 position in a tab may change when going into", "   * virtualedit.  Recalculate curwin->w_cursor to avoid bad hilighting."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (p_smd && msg_silent == 0)", "    redraw_cmdline = true;      /* show visual mode later */"], "readability/braces"]
["src/nvim/normal.c", ["  if (p_smd && msg_silent == 0)", "    redraw_cmdline = true;      /* show visual mode later */", ""], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* Only need to redraw this line, unless still need to redraw an old", "   * Visual area (when 'lazyredraw' is set). */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * CTRL-W: Window commands"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * CTRL-Z: Suspend"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  clearop(cap->oap);", "  if (VIsual_active)", "    end_visual_mode();                  /* stop Visual mode */"], "readability/braces"]
["src/nvim/normal.c", ["  if (VIsual_active)", "    end_visual_mode();                  /* stop Visual mode */", "  do_cmdline_cmd(\"st\");"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Commands starting with \"g\"."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * \"gv\": Reselect the previous Visual area.  If Visual already active,"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case 'v':", "    if (checkclearop(oap))", "      break;"], "readability/braces"]
["src/nvim/normal.c", ["", "    if (       curbuf->b_visual.vi_start.lnum == 0", "               || curbuf->b_visual.vi_start.lnum > curbuf->b_ml.ml_line_count"], "readability/braces"]
["src/nvim/normal.c", ["    if (       curbuf->b_visual.vi_start.lnum == 0", "               || curbuf->b_visual.vi_start.lnum > curbuf->b_ml.ml_line_count", "               || curbuf->b_visual.vi_end.lnum == 0)"], "whitespace/alignment"]
["src/nvim/normal.c", ["               || curbuf->b_visual.vi_start.lnum > curbuf->b_ml.ml_line_count", "               || curbuf->b_visual.vi_end.lnum == 0)", "      beep_flush();"], "whitespace/alignment"]
["src/nvim/normal.c", ["      beep_flush();", "    else {", "      /* set w_cursor to the start of the Visual area, tpos to the end */"], "readability/braces"]
["src/nvim/normal.c", ["      beep_flush();", "    else {", "      /* set w_cursor to the start of the Visual area, tpos to the end */"], "readability/braces"]
["src/nvim/normal.c", ["    else {", "      /* set w_cursor to the start of the Visual area, tpos to the end */", "      if (VIsual_active) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "      /* Set Visual to the start and w_cursor to the end of the Visual", "       * area.  Make sure they are on an existing character. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    break;", "  /*", "   * \"gV\": Don't reselect the previous Visual area after a Select mode"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * \"gh\":  start Select mode."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"gn\", \"gN\" visually select next/previous search match", "   * \"gn\" selects next match"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case 'n':", "    if (!current_search(cap->count1, cap->nchar == 'n'))", "      clearopbeep(oap);"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * \"gj\" and \"gk\" two new funny movement keys -- up and down"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      i = cursor_down(cap->count1, oap->op_type == OP_NOP);", "    } else", "      i = nv_screengo(oap, FORWARD, cap->count1);"], "readability/braces"]
["src/nvim/normal.c", ["      i = nv_screengo(oap, FORWARD, cap->count1);", "    if (!i)", "      clearopbeep(oap);"], "readability/braces"]
["src/nvim/normal.c", ["      i = cursor_up(cap->count1, oap->op_type == OP_NOP);", "    } else", "      i = nv_screengo(oap, BACKWARD, cap->count1);"], "readability/braces"]
["src/nvim/normal.c", ["      i = nv_screengo(oap, BACKWARD, cap->count1);", "    if (!i)", "      clearopbeep(oap);"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * \"gJ\": join two lines without inserting a space."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * \"g0\", \"g^\" and \"g$\": Like \"0\", \"^\" and \"$\" but for screen lines."], "readability/old_style_comment"]
["src/nvim/normal.c", ["      i = 0;", "      if (curwin->w_virtcol >= (colnr_T)width1 && width2 > 0)", "        i = (curwin->w_virtcol - width1) / width2 * width2 + width1;"], "readability/braces"]
["src/nvim/normal.c", ["        i = (curwin->w_virtcol - width1) / width2 * width2 + width1;", "    } else", "      i = curwin->w_leftcol;"], "readability/braces"]
["src/nvim/normal.c", ["      i = curwin->w_leftcol;", "    /* Go to the middle of the screen line.  When 'number' or", "     * 'relativenumber' is on and lines are wrapping the middle can be more"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case '_':", "    /* \"g_\": to the last non-blank character in the line or <count> lines", "     * downward. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    curwin->w_curswant = MAXCOL;", "    if (cursor_down(cap->count1 - 1,", "            cap->oap->op_type == OP_NOP) == false)"], "readability/braces"]
["src/nvim/normal.c", ["    if (cursor_down(cap->count1 - 1,", "            cap->oap->op_type == OP_NOP) == false)", "      clearopbeep(cap->oap);"], "whitespace/alignment"]
["src/nvim/normal.c", ["      clearopbeep(cap->oap);", "    else {", "      char_u  *ptr = get_cursor_line_ptr();"], "readability/braces"]
["src/nvim/normal.c", ["      clearopbeep(cap->oap);", "    else {", "      char_u  *ptr = get_cursor_line_ptr();"], "readability/braces"]
["src/nvim/normal.c", ["", "      /* In Visual mode we may end up after the line. */", "      if (curwin->w_cursor.col > 0 && ptr[curwin->w_cursor.col] == NUL)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      /* In Visual mode we may end up after the line. */", "      if (curwin->w_cursor.col > 0 && ptr[curwin->w_cursor.col] == NUL)", "        --curwin->w_cursor.col;"], "readability/braces"]
["src/nvim/normal.c", ["      if (curwin->w_cursor.col > 0 && ptr[curwin->w_cursor.col] == NUL)", "        --curwin->w_cursor.col;", ""], "readability/increment"]
["src/nvim/normal.c", ["", "      /* Decrease the cursor column until it's on a non-blank. */", "      while (curwin->w_cursor.col > 0"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      /* Decrease the cursor column until it's on a non-blank. */", "      while (curwin->w_cursor.col > 0", "             && ascii_iswhite(ptr[curwin->w_cursor.col]))"], "readability/braces"]
["src/nvim/normal.c", ["             && ascii_iswhite(ptr[curwin->w_cursor.col]))", "        --curwin->w_cursor.col;", "      curwin->w_set_curswant = true;"], "readability/increment"]
["src/nvim/normal.c", ["        ) {", "      curwin->w_curswant = MAXCOL;              /* so we stay at the end */", "      if (cap->count1 == 1) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        i = width1 - 1;", "        if (curwin->w_virtcol >= (colnr_T)width1)", "          i += ((curwin->w_virtcol - width1) / width2 + 1)"], "readability/braces"]
["src/nvim/normal.c", ["", "        /* Make sure we stick in this column. */", "        validate_virtcol();"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        if (curwin->w_cursor.col > 0 && curwin->w_p_wrap) {", "          /*", "           * Check for landing on a character that got split at"], "readability/old_style_comment"]
["src/nvim/normal.c", ["           */", "          if (curwin->w_virtcol > (colnr_T)i)", "            --curwin->w_cursor.col;"], "readability/braces"]
["src/nvim/normal.c", ["          if (curwin->w_virtcol > (colnr_T)i)", "            --curwin->w_cursor.col;", "        }"], "readability/increment"]
["src/nvim/normal.c", ["        }", "      } else if (nv_screengo(oap, FORWARD, cap->count1 - 1) == false)", "        clearopbeep(oap);"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * \"g*\" and \"g#\", like \"*\" and \"#\" but without using \"\\<\" and \"\\>\""], "readability/old_style_comment"]
["src/nvim/normal.c", ["#if POUND != '#'", "  case POUND:           /* pound sign (sometimes equal to '#') */", "#endif"], "readability/old_style_comment"]
["src/nvim/normal.c", ["#endif", "  case Ctrl_RSB:                /* :tag or :tselect for current identifier */", "  case ']':                     /* :tselect for current identifier */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case Ctrl_RSB:                /* :tag or :tselect for current identifier */", "  case ']':                     /* :tselect for current identifier */", "    nv_ident(cap);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * ge and gE: go back to end of word"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    oap->inclusive = true;", "    if (bckend_word(cap->count1, cap->nchar == 'E', false) == false)", "      clearopbeep(oap);"], "readability/braces"]
["src/nvim/normal.c", ["      if (curwin->w_cursor.col > (colnr_T)i) {", "        if (virtual_active())", "          curwin->w_cursor.coladd += curwin->w_cursor.col - i;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * \"gI\": Start insert in column 1."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    beginline(0);", "    if (!checkclearopq(oap))", "      invoke_edit(cap, false, 'g', false);"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * \"gf\": goto file, edit file under cursor"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"g'm\" and \"g`m\": jump to mark without setting pcmark */", "  case '\\'':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * \"gs\": Goto sleep."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * \"ga\": Display the ascii value of the character under the"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * \"g8\": Display the bytes used for the UTF-8 character under the"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case '8':", "    if (cap->count0 == 8)", "      utf_find_illegal();"], "readability/braces"]
["src/nvim/normal.c", ["      utf_find_illegal();", "    else", "      show_utf8();"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * \"gg\": Goto the first line in file.  With a count it goes to"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   *\t Two-character operators:"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * \"gd\": Find first occurrence of pattern under the cursor in the"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * g<*Mouse> : <C-*mouse>"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * \"gP\" and \"gp\": same as \"P\" and \"p\" but leave cursor just after new text"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"go\": goto byte count from start of buffer */", "  case 'o':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"gQ\": improved Ex mode */", "  case 'Q':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    if (!checkclearopq(oap))", "      do_exmode(true);"], "readability/braces"]
["src/nvim/normal.c", ["  case 't':", "    if (!checkclearop(oap))", "      goto_tabpage((int)cap->count0);"], "readability/braces"]
["src/nvim/normal.c", ["  case 'T':", "    if (!checkclearop(oap))", "      goto_tabpage(-(int)cap->count1);"], "readability/braces"]
["src/nvim/normal.c", ["  case '+':", "  case '-':   /* \"g+\" and \"g-\": undo or redo along the timeline */", "    if (!checkclearopq(oap))"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case '-':   /* \"g+\" and \"g-\": undo or redo along the timeline */", "    if (!checkclearopq(oap))", "      undo_time(cap->nchar == '-' ? -cap->count1 : cap->count1,"], "readability/braces"]
["src/nvim/normal.c", ["      undo_time(cap->nchar == '-' ? -cap->count1 : cap->count1,", "          false, false, false);", "    break;"], "whitespace/alignment"]
["src/nvim/normal.c", ["", "/*", " * Handle \"o\" and \"O\" commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (!checkclearopq(cap->oap)) {", "    if (cap->cmdchar == 'O')", "      /* Open above the first line of a folded sequence of lines */"], "readability/braces"]
["src/nvim/normal.c", ["    if (cap->cmdchar == 'O')", "      /* Open above the first line of a folded sequence of lines */", "      (void)hasFolding(curwin->w_cursor.lnum,"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      (void)hasFolding(curwin->w_cursor.lnum,", "          &curwin->w_cursor.lnum, NULL);", "    else"], "whitespace/alignment"]
["src/nvim/normal.c", ["          &curwin->w_cursor.lnum, NULL);", "    else", "      /* Open below the last line of a folded sequence of lines */"], "readability/braces"]
["src/nvim/normal.c", ["    else", "      /* Open below the last line of a folded sequence of lines */", "      (void)hasFolding(curwin->w_cursor.lnum,"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      (void)hasFolding(curwin->w_cursor.lnum,", "          NULL, &curwin->w_cursor.lnum);", "    if (u_save((linenr_T)(curwin->w_cursor.lnum -"], "whitespace/alignment"]
["src/nvim/normal.c", ["                          (cap->cmdchar == 'O' ? 1 : 0)),", "            (linenr_T)(curwin->w_cursor.lnum +", "                       (cap->cmdchar == 'o' ? 1 : 0))"], "whitespace/alignment"]
["src/nvim/normal.c", ["                       (cap->cmdchar == 'o' ? 1 : 0))", "            )", "        && open_line(cap->cmdchar == 'O' ? BACKWARD : FORWARD,"], "whitespace/alignment"]
["src/nvim/normal.c", ["", "/*", " * \".\" command: redo last change."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (!checkclearopq(cap->oap)) {", "    /*", "     * If \"restart_edit\" is true, the last but one command is repeated"], "readability/old_style_comment"]
["src/nvim/normal.c", ["     */", "    if (start_redo(cap->count0, restart_edit != 0 && !arrow_used) == false)", "      clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * CTRL-R: undo undo"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Handle \"U\" command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  /* In Visual mode and typing \"gUU\" triggers an operator */", "  if (cap->oap->op_type == OP_UPPER"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      ) {", "    /* translate \"gUU\" to \"gUgU\" */", "    cap->cmdchar = 'g';"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * '~' command: If tilde is not an operator and Visual is off: swap case of a"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Handle an operator command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (op_type == cap->oap->op_type)         /* double operator works on lines */", "    nv_lineop(cap);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (op_type == cap->oap->op_type)         /* double operator works on lines */", "    nv_lineop(cap);"], "readability/braces"]
["src/nvim/normal.c", ["    nv_lineop(cap);", "  else if (!checkclearop(cap->oap)) {", "    cap->oap->start = curwin->w_cursor;"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Set v:operator to the characters for \"optype\"."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    assert(opchar0 >= 0 && opchar0 <= UCHAR_MAX);", "    opchars[0] = (char) opchar0;", ""], "whitespace/cast"]
["src/nvim/normal.c", ["    assert(opchar1 >= 0 && opchar1 <= UCHAR_MAX);", "    opchars[1] = (char) opchar1;", ""], "whitespace/cast"]
["src/nvim/normal.c", ["", "/*", " * Handle linewise operator \"dd\", \"yy\", etc."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * <Home> command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  /* CTRL-HOME is like \"gg\" */", "  if (mod_mask & MOD_MASK_CTRL)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* CTRL-HOME is like \"gg\" */", "  if (mod_mask & MOD_MASK_CTRL)", "    nv_goto(cap);"], "readability/braces"]
["src/nvim/normal.c", ["    nv_goto(cap);", "  else {", "    cap->count0 = 1;"], "readability/braces"]
["src/nvim/normal.c", ["    nv_goto(cap);", "  else {", "    cap->count0 = 1;"], "readability/braces"]
["src/nvim/normal.c", ["  }", "  ins_at_eol = false;       /* Don't move cursor past eol (only necessary in a", "                               one-character line). */"], "readability/multiline_comment"]
["src/nvim/normal.c", ["  }", "  ins_at_eol = false;       /* Don't move cursor past eol (only necessary in a", "                               one-character line). */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  }", "  ins_at_eol = false;       /* Don't move cursor past eol (only necessary in a", "                               one-character line). */"], "whitespace/parens"]
["src/nvim/normal.c", ["  ins_at_eol = false;       /* Don't move cursor past eol (only necessary in a", "                               one-character line). */", "}"], "whitespace/alignment"]
["src/nvim/normal.c", ["", "/*", " * \"|\" command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    curwin->w_curswant = (colnr_T)(cap->count0 - 1);", "  } else", "    curwin->w_curswant = 0;"], "readability/braces"]
["src/nvim/normal.c", ["    curwin->w_curswant = 0;", "  /* keep curswant at the column where we wanted to go, not where", "   * we ended; differs if line is too short */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Handle back-word command \"b\" and \"B\"."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  curwin->w_set_curswant = true;", "  if (bck_word(cap->count1, cap->arg, false) == false)", "    clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["    clearopbeep(cap->oap);", "  else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)", "    foldOpenCursor();"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Handle word motion commands \"e\", \"E\", \"w\" and \"W\"."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * Set inclusive for the \"E\" and \"e\" command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  if (cap->cmdchar == 'e' || cap->cmdchar == 'E')", "    word_end = true;"], "readability/braces"]
["src/nvim/normal.c", ["    word_end = true;", "  else", "    word_end = false;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * \"cw\" and \"cW\" are a special case."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  curwin->w_set_curswant = true;", "  if (word_end)", "    n = end_word(cap->count1, cap->arg, flag, false);"], "readability/braces"]
["src/nvim/normal.c", ["    n = end_word(cap->count1, cap->arg, flag, false);", "  else", "    n = fwd_word(cap->count1, cap->arg, cap->oap->op_type != OP_NOP);"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* Don't leave the cursor on the NUL past the end of line. Unless we", "   * didn't move it forward. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   * didn't move it forward. */", "  if (lt(startpos, curwin->w_cursor))", "    adjust_cursor(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["", "  if (n == false && cap->oap->op_type == OP_NOP)", "    clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["    clearopbeep(cap->oap);", "  else {", "    adjust_for_sel(cap);"], "readability/braces"]
["src/nvim/normal.c", ["    clearopbeep(cap->oap);", "  else {", "    adjust_for_sel(cap);"], "readability/braces"]
["src/nvim/normal.c", ["    adjust_for_sel(cap);", "    if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)", "      foldOpenCursor();"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Used after a movement command: If the cursor ends up on the NUL after the"], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  /* The cursor cannot remain on the NUL when:", "   * - the column is > 0"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * \"0\" and \"^\" commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  beginline(cap->arg);", "  if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)", "    foldOpenCursor();"], "readability/braces"]
["src/nvim/normal.c", ["    foldOpenCursor();", "  ins_at_eol = false;       /* Don't move cursor past eol (only necessary in a", "                               one-character line). */"], "readability/multiline_comment"]
["src/nvim/normal.c", ["    foldOpenCursor();", "  ins_at_eol = false;       /* Don't move cursor past eol (only necessary in a", "                               one-character line). */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    foldOpenCursor();", "  ins_at_eol = false;       /* Don't move cursor past eol (only necessary in a", "                               one-character line). */"], "whitespace/parens"]
["src/nvim/normal.c", ["  ins_at_eol = false;       /* Don't move cursor past eol (only necessary in a", "                               one-character line). */", "}"], "whitespace/alignment"]
["src/nvim/normal.c", ["", "/*", " * In exclusive Visual mode, may include the last character."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Exclude last character at end of Visual area for 'selection' == \"exclusive\"."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (*p_sel == 'e' && !equalpos(VIsual, curwin->w_cursor)) {", "    if (lt(VIsual, curwin->w_cursor))", "      pp = &curwin->w_cursor;"], "readability/braces"]
["src/nvim/normal.c", ["      pp = &curwin->w_cursor;", "    else", "      pp = &VIsual;"], "readability/braces"]
["src/nvim/normal.c", ["    } else if (pp->lnum > 1) {", "      --pp->lnum;", "      pp->col = (colnr_T)STRLEN(ml_get(pp->lnum));"], "readability/increment"]
["src/nvim/normal.c", ["", "/*", " * SELECT key in Normal or Visual mode: end of Select mode mapping."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (VIsual_active)", "    VIsual_select = true;"], "readability/braces"]
["src/nvim/normal.c", ["    VIsual_select = true;", "  else if (VIsual_reselect) {", "    cap->nchar = 'v';               /* fake \"gv\" command */"], "readability/braces"]
["src/nvim/normal.c", ["  else if (VIsual_reselect) {", "    cap->nchar = 'v';               /* fake \"gv\" command */", "    cap->arg = true;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * \"G\", \"gg\", CTRL-END, CTRL-HOME."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (cap->arg)", "    lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/normal.c", ["    lnum = curbuf->b_ml.ml_line_count;", "  else", "    lnum = 1L;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* When a count is given, use it instead of the default lnum */", "  if (cap->count0 != 0)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* When a count is given, use it instead of the default lnum */", "  if (cap->count0 != 0)", "    lnum = cap->count0;"], "readability/braces"]
["src/nvim/normal.c", ["    lnum = cap->count0;", "  if (lnum < 1L)", "    lnum = 1L;"], "readability/braces"]
["src/nvim/normal.c", ["    lnum = 1L;", "  else if (lnum > curbuf->b_ml.ml_line_count)", "    lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/normal.c", ["  beginline(BL_SOL | BL_FIX);", "  if ((fdo_flags & FDO_JUMP) && KeyTyped && cap->oap->op_type == OP_NOP)", "    foldOpenCursor();"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * CTRL-\\ in Normal mode."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    clearop(cap->oap);", "    if (restart_edit != 0 && mode_displayed)", "      clear_cmdline = true;                     /* unshow mode later */"], "readability/braces"]
["src/nvim/normal.c", ["    if (restart_edit != 0 && mode_displayed)", "      clear_cmdline = true;                     /* unshow mode later */", "    restart_edit = 0;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    restart_edit = 0;", "    if (cmdwin_type != 0)", "      cmdwin_result = Ctrl_C;"], "readability/braces"]
["src/nvim/normal.c", ["    if (VIsual_active) {", "      end_visual_mode();                /* stop Visual */", "      redraw_curbuf_later(INVERTED);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    }", "    /* CTRL-\\ CTRL-G restarts Insert mode when 'insertmode' is set. */", "    if (cap->nchar == Ctrl_G && p_im)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    /* CTRL-\\ CTRL-G restarts Insert mode when 'insertmode' is set. */", "    if (cap->nchar == Ctrl_G && p_im)", "      restart_edit = 'a';"], "readability/braces"]
["src/nvim/normal.c", ["      restart_edit = 'a';", "  } else", "    clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * ESC in Normal mode: beep, but don't flush buffers."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (cap->arg) {               /* true for CTRL-C */", "    if (restart_edit == 0"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    /* Don't reset \"restart_edit\" when 'insertmode' is set, it won't be", "     * set again below when halfway through a mapping. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["     * set again below when halfway through a mapping. */", "    if (!p_im)", "      restart_edit = 0;"], "readability/braces"]
["src/nvim/normal.c", ["      cmdwin_result = K_IGNORE;", "      got_int = false;          /* don't stop executing autocommands et al. */", "      return;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (VIsual_active) {", "    end_visual_mode();          /* stop Visual */", "    check_cursor_col();         /* make sure cursor is not beyond EOL */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    end_visual_mode();          /* stop Visual */", "    check_cursor_col();         /* make sure cursor is not beyond EOL */", "    curwin->w_set_curswant = true;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* A CTRL-C is often used at the start of a menu.  When 'insertmode' is", "   * set return to Insert mode afterwards. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   * set return to Insert mode afterwards. */", "  if (restart_edit == 0 && goto_im()", "      && ex_normal_busy == 0"], "readability/braces"]
["src/nvim/normal.c", ["", "    case 'I':           /* \"I\"nsert before the first non-blank */", "      beginline(BL_WHITE);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    case 'a':           /* \"a\"ppend is like \"i\"nsert on the next character. */", "      /* increment coladd when in virtual space, increment the"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    case 'a':           /* \"a\"ppend is like \"i\"nsert on the next character. */", "      /* increment coladd when in virtual space, increment the", "       * column otherwise, also to append after an unprintable char */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["       * column otherwise, also to append after an unprintable char */", "      if (virtual_active()", "          && (curwin->w_cursor.coladd > 0"], "readability/braces"]
["src/nvim/normal.c", ["        curwin->w_cursor.coladd++;", "      else if (*get_cursor_pos_ptr() != NUL)", "        inc_cursor();"], "readability/braces"]
["src/nvim/normal.c", ["", "      /* Pretend Insert mode here to allow the cursor on the", "       * character past the end of the line */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Invoke edit() and take care of \"restart_edit\" and the return value."], "readability/old_style_comment"]
["src/nvim/normal.c", ["static void", "invoke_edit (", "    cmdarg_T *cap,"], "whitespace/parens"]
["src/nvim/normal.c", ["    cmdarg_T *cap,", "    int repl,                       /* \"r\" or \"gr\" command */", "    int cmd,"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* Complicated: When the user types \"a<C-O>a\" we don't want to do Insert", "   * mode recursively.  But when doing \"a<C-O>.\" or \"a<C-O>rx\" we do allow"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   * it. */", "  if (repl || !stuff_empty())", "    restart_edit_save = restart_edit;"], "readability/braces"]
["src/nvim/normal.c", ["    restart_edit_save = restart_edit;", "  else", "    restart_edit_save = 0;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* Always reset \"restart_edit\", this is not a restarted edit. */", "  restart_edit = 0;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (edit(cmd, startln, cap->count1))", "    cap->retval |= CA_COMMAND_BUSY;"], "readability/braces"]
["src/nvim/normal.c", ["", "  if (restart_edit == 0)", "    restart_edit = restart_edit_save;"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * \"a\" or \"i\" while an operator is pending or in Visual mode: object motion."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (cap->cmdchar == 'i')", "    include = false;        /* \"ix\" = inner object: exclude white space */"], "readability/braces"]
["src/nvim/normal.c", ["  if (cap->cmdchar == 'i')", "    include = false;        /* \"ix\" = inner object: exclude white space */", "  else"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    include = false;        /* \"ix\" = inner object: exclude white space */", "  else", "    include = true;         /* \"ax\" = an object: include white space */"], "readability/braces"]
["src/nvim/normal.c", ["  else", "    include = true;         /* \"ax\" = an object: include white space */", ""], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* Make sure (), [], {} and <> are in 'matchpairs' */", "  mps_save = curbuf->b_p_mps;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  switch (cap->nchar) {", "  case 'w':       /* \"aw\" = a word */", "    flag = current_word(cap->oap, cap->count1, include, false);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    break;", "  case 'W':       /* \"aW\" = a WORD */", "    flag = current_word(cap->oap, cap->count1, include, true);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    break;", "  case 'b':       /* \"ab\" = a braces block */", "  case '(':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    break;", "  case 'B':       /* \"aB\" = a Brackets block */", "  case '{':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    break;", "  case '[':       /* \"a[\" = a [] block */", "  case ']':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    break;", "  case '<':       /* \"a<\" = a <> block */", "  case '>':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    break;", "  case 't':       /* \"at\" = a tag block (xml and html) */", "    // Do not adjust oap->end in do_pending_operator()"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    break;", "  case 'p':       /* \"ap\" = a paragraph */", "    flag = current_par(cap->oap, cap->count1, include, 'p');"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    break;", "  case 's':       /* \"as\" = a sentence */", "    flag = current_sent(cap->oap, cap->count1, include);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    break;", "  case '\"':       /* \"a\"\" = a double quoted string */", "  case '\\'':       /* \"a'\" = a single quoted string */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case '\"':       /* \"a\"\" = a double quoted string */", "  case '\\'':       /* \"a'\" = a single quoted string */", "  case '`':       /* \"a`\" = a backtick quoted string */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case '\\'':       /* \"a'\" = a single quoted string */", "  case '`':       /* \"a`\" = a backtick quoted string */", "    flag = current_quote(cap->oap, cap->count1, include,"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    flag = current_quote(cap->oap, cap->count1, include,", "        cap->nchar);", "    break;"], "whitespace/alignment"]
["src/nvim/normal.c", ["  curbuf->b_p_mps = mps_save;", "  if (!flag)", "    clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * \"q\" command: Start/stop recording."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (cap->oap->op_type == OP_FORMAT) {", "    /* \"gqq\" is the same as \"gqgq\": format line */", "    cap->cmdchar = 'g';"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Handle the \"@r\" command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (checkclearop(cap->oap))", "    return;"], "readability/braces"]
["src/nvim/normal.c", ["  if (cap->nchar == '=') {", "    if (get_expr_register() == NUL)", "      return;"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Handle the CTRL-U and CTRL-D commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if ((cap->cmdchar == Ctrl_U && curwin->w_cursor.lnum == 1)", "      || (cap->cmdchar == Ctrl_D"], "readability/braces"]
["src/nvim/normal.c", ["    clearopbeep(cap->oap);", "  else if (!checkclearop(cap->oap))", "    halfpage(cap->cmdchar == Ctrl_D, cap->count0);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Handle \"J\" or \"gJ\" command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * \"P\", \"gP\", \"p\" and \"gp\" commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (cap->oap->op_type != OP_NOP) {", "    /* \"dp\" is \":diffput\" */", "    if (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'p') {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (VIsual_active) {", "      /* Putting in Visual mode: The put text replaces the selected", "       * text.  First delete the selected text, then put the new text."], "readability/old_style_comment"]
["src/nvim/normal.c", ["      dir = BACKWARD;", "      if ((VIsual_mode != 'V'", "           && curwin->w_cursor.col < curbuf->b_op_start.col)"], "readability/braces"]
["src/nvim/normal.c", ["              && curwin->w_cursor.lnum < curbuf->b_op_start.lnum))", "        /* cursor is at the end of the line or end of file, put", "         * forward. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        dir = FORWARD;", "      /* May have been reset in do_put(). */", "      VIsual_active = true;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    /* What to reselect with \"gv\"?  Selecting the just put text seems to", "     * be the most useful, since the original text was removed. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    /* When all lines were selected and deleted do_put() leaves an empty", "     * line that needs to be deleted now. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "      /* If the cursor was in that line, move it to the end of the last", "       * line. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * \"o\" and \"O\" commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  /* \"do\" is \":diffget\" */", "  if (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'o') {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    for (curwin->w_cursor.lnum = oap->start.lnum;", "         curwin->w_cursor.lnum <= oap->end.lnum; ++curwin->w_cursor.lnum) {", "      getvvcol(curwin, &curwin->w_cursor, NULL, NULL, &end);"], "readability/increment"]
["src/nvim/normal.c", ["", "/*", " * Return TRUE when 'mousemodel' is set to \"popup\" or \"popup_setpos\"."], "readability/old_style_comment"]
["src/nvim/normal.h", ["", "/* Values for find_ident_under_cursor() */", "#define FIND_IDENT      1       /* find identifier (word) */"], "readability/old_style_comment"]
["src/nvim/normal.h", ["/* Values for find_ident_under_cursor() */", "#define FIND_IDENT      1       /* find identifier (word) */", "#define FIND_STRING     2       /* find any string (WORD) */"], "readability/old_style_comment"]
["src/nvim/normal.h", ["#define FIND_IDENT      1       /* find identifier (word) */", "#define FIND_STRING     2       /* find any string (WORD) */", "#define FIND_EVAL       4       /* include \"->\", \"[]\" and \".\" */"], "readability/old_style_comment"]
["src/nvim/normal.h", ["#define FIND_STRING     2       /* find any string (WORD) */", "#define FIND_EVAL       4       /* include \"->\", \"[]\" and \".\" */", ""], "readability/old_style_comment"]
["src/nvim/normal.h", ["", "/*", " * Arguments for operators."], "readability/old_style_comment"]
["src/nvim/normal.h", ["", "/*", " * Arguments for Normal mode commands."], "readability/old_style_comment"]
["src/nvim/normal.h", ["typedef struct cmdarg_S {", "  oparg_T     *oap;             /* Operator arguments */", "  int prechar;                  /* prefix character (optional, always 'g') */"], "readability/old_style_comment"]
["src/nvim/normal.h", ["  oparg_T     *oap;             /* Operator arguments */", "  int prechar;                  /* prefix character (optional, always 'g') */", "  int cmdchar;                  /* command character */"], "readability/old_style_comment"]
["src/nvim/normal.h", ["  int prechar;                  /* prefix character (optional, always 'g') */", "  int cmdchar;                  /* command character */", "  int nchar;                    /* next command character (optional) */"], "readability/old_style_comment"]
["src/nvim/normal.h", ["  int cmdchar;                  /* command character */", "  int nchar;                    /* next command character (optional) */", "  int ncharC1;                  /* first composing character (optional) */"], "readability/old_style_comment"]
["src/nvim/normal.h", ["  int nchar;                    /* next command character (optional) */", "  int ncharC1;                  /* first composing character (optional) */", "  int ncharC2;                  /* second composing character (optional) */"], "readability/old_style_comment"]
["src/nvim/normal.h", ["  int ncharC1;                  /* first composing character (optional) */", "  int ncharC2;                  /* second composing character (optional) */", "  int extra_char;               /* yet another character (optional) */"], "readability/old_style_comment"]
["src/nvim/normal.h", ["  int ncharC2;                  /* second composing character (optional) */", "  int extra_char;               /* yet another character (optional) */", "  long opcount;                 /* count before an operator */"], "readability/old_style_comment"]
["src/nvim/normal.h", ["  int extra_char;               /* yet another character (optional) */", "  long opcount;                 /* count before an operator */", "  long count0;                  /* count before command, default 0 */"], "readability/old_style_comment"]
["src/nvim/normal.h", ["  long opcount;                 /* count before an operator */", "  long count0;                  /* count before command, default 0 */", "  long count1;                  /* count before command, default 1 */"], "readability/old_style_comment"]
["src/nvim/normal.h", ["  long count0;                  /* count before command, default 0 */", "  long count1;                  /* count before command, default 1 */", "  int arg;                      /* extra argument from nv_cmds[] */"], "readability/old_style_comment"]
["src/nvim/normal.h", ["  long count1;                  /* count before command, default 1 */", "  int arg;                      /* extra argument from nv_cmds[] */", "  int retval;                   /* return: CA_* values */"], "readability/old_style_comment"]
["src/nvim/normal.h", ["  int arg;                      /* extra argument from nv_cmds[] */", "  int retval;                   /* return: CA_* values */", "  char_u      *searchbuf;       /* return: pointer to search pattern or NULL */"], "readability/old_style_comment"]
["src/nvim/normal.h", ["  int retval;                   /* return: CA_* values */", "  char_u      *searchbuf;       /* return: pointer to search pattern or NULL */", "} cmdarg_T;"], "readability/old_style_comment"]
["src/nvim/normal.h", ["", "/* values for retval: */", "#define CA_COMMAND_BUSY     1   /* skip restarting edit() once */"], "readability/old_style_comment"]
["src/nvim/normal.h", ["/* values for retval: */", "#define CA_COMMAND_BUSY     1   /* skip restarting edit() once */", "#define CA_NO_ADJ_OP_END    2   /* don't adjust operator end */"], "readability/old_style_comment"]
["src/nvim/normal.h", ["#define CA_COMMAND_BUSY     1   /* skip restarting edit() once */", "#define CA_NO_ADJ_OP_END    2   /* don't adjust operator end */", ""], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * ops.c: implementation of various operators: op_shift, op_delete, op_tilde,"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "static yankreg_T *y_previous = NULL; /* ptr to last written yankreg */", ""], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * structure used by block_prep, op_delete and op_yank for blockwise operators"], "readability/old_style_comment"]
["src/nvim/ops.c", ["struct block_def {", "  int startspaces;              /* 'extra' cols before first char */", "  int endspaces;                /* 'extra' cols after last char */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int startspaces;              /* 'extra' cols before first char */", "  int endspaces;                /* 'extra' cols after last char */", "  int textlen;                  /* chars in block */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int endspaces;                /* 'extra' cols after last char */", "  int textlen;                  /* chars in block */", "  char_u      *textstart;       /* pointer to 1st char (partially) in block */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int textlen;                  /* chars in block */", "  char_u      *textstart;       /* pointer to 1st char (partially) in block */", "  colnr_T textcol;              /* index of chars (partially) in block */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  char_u      *textstart;       /* pointer to 1st char (partially) in block */", "  colnr_T textcol;              /* index of chars (partially) in block */", "  colnr_T start_vcol;           /* start col of 1st char wholly inside block */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  colnr_T textcol;              /* index of chars (partially) in block */", "  colnr_T start_vcol;           /* start col of 1st char wholly inside block */", "  colnr_T end_vcol;             /* start col of 1st char wholly after block */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  colnr_T start_vcol;           /* start col of 1st char wholly inside block */", "  colnr_T end_vcol;             /* start col of 1st char wholly after block */", "  int is_short;                 /* TRUE if line is too short to fit in block */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  colnr_T end_vcol;             /* start col of 1st char wholly after block */", "  int is_short;                 /* TRUE if line is too short to fit in block */", "  int is_MAX;                   /* TRUE if curswant==MAXCOL when starting */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int is_short;                 /* TRUE if line is too short to fit in block */", "  int is_MAX;                   /* TRUE if curswant==MAXCOL when starting */", "  int is_oneChar;               /* TRUE if block within one character */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int is_MAX;                   /* TRUE if curswant==MAXCOL when starting */", "  int is_oneChar;               /* TRUE if block within one character */", "  int pre_whitesp;              /* screen cols of ws before block */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int is_oneChar;               /* TRUE if block within one character */", "  int pre_whitesp;              /* screen cols of ws before block */", "  int pre_whitesp_c;            /* chars of ws before block */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int pre_whitesp;              /* screen cols of ws before block */", "  int pre_whitesp_c;            /* chars of ws before block */", "  colnr_T end_char_vcols;       /* number of vcols of post-block char */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int pre_whitesp_c;            /* chars of ws before block */", "  colnr_T end_char_vcols;       /* number of vcols of post-block char */", "  colnr_T start_char_vcols;       /* number of vcols of pre-block char */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  colnr_T end_char_vcols;       /* number of vcols of post-block char */", "  colnr_T start_char_vcols;       /* number of vcols of pre-block char */", "};"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * The names of operators."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Translate a command name into an operator type."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Return TRUE if operator \"op\" always works on whole lines."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Get first operator command character."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Get second operator command character."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * op_shift - handle a shift operation"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (u_save((linenr_T)(oap->start.lnum - 1),", "          (linenr_T)(oap->end.lnum + 1)) == FAIL)"], "readability/braces"]
["src/nvim/ops.c", ["  if (u_save((linenr_T)(oap->start.lnum - 1),", "          (linenr_T)(oap->end.lnum + 1)) == FAIL)", "    return;"], "whitespace/alignment"]
["src/nvim/ops.c", ["    }", "    ++curwin->w_cursor.lnum;", "  }"], "readability/increment"]
["src/nvim/ops.c", ["    curwin->w_cursor.col = block_col;", "  } else if (curs_top) { /* put cursor on first line, for \">>\" */", "    curwin->w_cursor.lnum = oap->start.lnum;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    curwin->w_cursor.lnum = oap->start.lnum;", "    beginline(BL_SOL | BL_FIX);       /* shift_line() may have set cursor.col */", "  } else"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    beginline(BL_SOL | BL_FIX);       /* shift_line() may have set cursor.col */", "  } else", "    --curwin->w_cursor.lnum;            /* put cursor on last line, for \":>\" */"], "readability/braces"]
["src/nvim/ops.c", ["  } else", "    --curwin->w_cursor.lnum;            /* put cursor on last line, for \":>\" */", ""], "readability/old_style_comment"]
["src/nvim/ops.c", ["  } else", "    --curwin->w_cursor.lnum;            /* put cursor on last line, for \":>\" */", ""], "readability/increment"]
["src/nvim/ops.c", ["  if (oap->line_count > p_report) {", "    if (oap->op_type == OP_RSHIFT)", "      s = (char_u *)\">\";"], "readability/braces"]
["src/nvim/ops.c", ["      s = (char_u *)\">\";", "    else", "      s = (char_u *)\"<\";"], "readability/braces"]
["src/nvim/ops.c", ["    if (oap->line_count == 1) {", "      if (amount == 1)", "        sprintf((char *)IObuff, _(\"1 line %sed 1 time\"), s);"], "readability/braces"]
["src/nvim/ops.c", ["      if (amount == 1)", "        sprintf((char *)IObuff, _(\"1 line %sed 1 time\"), s);", "      else"], "runtime/printf"]
["src/nvim/ops.c", ["        sprintf((char *)IObuff, _(\"1 line %sed 1 time\"), s);", "      else", "        sprintf((char *)IObuff, _(\"1 line %sed %d times\"), s, amount);"], "readability/braces"]
["src/nvim/ops.c", ["      else", "        sprintf((char *)IObuff, _(\"1 line %sed %d times\"), s, amount);", "    } else {"], "runtime/printf"]
["src/nvim/ops.c", ["    } else {", "      if (amount == 1)", "        sprintf((char *)IObuff, _(\"%\" PRId64 \" lines %sed 1 time\"),"], "readability/braces"]
["src/nvim/ops.c", ["        sprintf((char *)IObuff, _(\"%\" PRId64 \" lines %sed 1 time\"),", "            (int64_t)oap->line_count, s);", "      else"], "whitespace/alignment"]
["src/nvim/ops.c", ["      if (amount == 1)", "        sprintf((char *)IObuff, _(\"%\" PRId64 \" lines %sed 1 time\"),", "            (int64_t)oap->line_count, s);"], "runtime/printf"]
["src/nvim/ops.c", ["            (int64_t)oap->line_count, s);", "      else", "        sprintf((char *)IObuff, _(\"%\" PRId64 \" lines %sed %d times\"),"], "readability/braces"]
["src/nvim/ops.c", ["        sprintf((char *)IObuff, _(\"%\" PRId64 \" lines %sed %d times\"),", "            (int64_t)oap->line_count, s, amount);", "    }"], "whitespace/alignment"]
["src/nvim/ops.c", ["      else", "        sprintf((char *)IObuff, _(\"%\" PRId64 \" lines %sed %d times\"),", "            (int64_t)oap->line_count, s, amount);"], "runtime/printf"]
["src/nvim/ops.c", ["", "  /*", "   * Set \"'[\" and \"']\" marks."], "readability/old_style_comment"]
["src/nvim/ops.c", ["      i -= amount;", "      if (i < 0)", "        i = 0;"], "readability/braces"]
["src/nvim/ops.c", ["        i = 0;", "    } else", "      i += amount;"], "readability/braces"]
["src/nvim/ops.c", ["      count -= p_sw * amount;", "      if (count < 0)", "        count = 0;"], "readability/braces"]
["src/nvim/ops.c", ["        count = 0;", "    } else", "      count += p_sw * amount;"], "readability/braces"]
["src/nvim/ops.c", ["", "/*", " * Shift one line of the current block one shiftwidth right or left."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  p_ri = 0;                     /* don't want revins in indent */", ""], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (!left) {", "    /*", "     *  1. Get start vcol"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    for (; ascii_iswhite(*bd.textstart); ) {", "      // TODO: is passing bd.textstart for start of the line OK?", "      incr = lbr_chartabsize_adv(bd.textstart, &bd.textstart, (colnr_T)(bd.start_vcol));"], "readability/todo"]
["src/nvim/ops.c", ["      // TODO: is passing bd.textstart for start of the line OK?", "      incr = lbr_chartabsize_adv(bd.textstart, &bd.textstart, (colnr_T)(bd.start_vcol));", "      total += incr;"], "whitespace/line_length"]
["src/nvim/ops.c", ["    }", "    /* OK, now total=all the VWS reqd, and textstart points at the 1st", "     * non-ws char in the block. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    memset(newp + bd.textcol + i, ' ', (size_t)j);", "    /* the end */", "    memmove(newp + bd.textcol + i + j, bd.textstart, (size_t)len);"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /*", "     * Firstly, let's find the first non-whitespace character that is"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /* If \"bd.startspaces\" is set, \"bd.textstart\" points to the character,", "     * the part of which is displayed at the block's beginning. Let's start"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /* Now let's find out how much of the beginning of the line we can", "     * reuse without modification.  */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /* If \"bd.startspaces\" is set, \"bd.textstart\" points to the character", "     * preceding the block. We have to subtract its width to obtain its"], "readability/old_style_comment"]
["src/nvim/ops.c", ["     * column number.  */", "    if (bd.startspaces)", "      verbatim_copy_width -= bd.start_char_vcols;"], "readability/braces"]
["src/nvim/ops.c", ["", "      // TODO: is passing verbatim_copy_end for start of the line OK?", "      incr = lbr_chartabsize(line, verbatim_copy_end, verbatim_copy_width);"], "readability/todo"]
["src/nvim/ops.c", ["      incr = lbr_chartabsize(line, verbatim_copy_end, verbatim_copy_width);", "      if (verbatim_copy_width + incr > destination_col)", "        break;"], "readability/braces"]
["src/nvim/ops.c", ["", "    /* If \"destination_col\" is different from the width of the initial", "    * part of the line that will be copied, it means we encountered a tab"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Insert string \"s\" (b_insert ? before : after) block :AKelly"], "readability/old_style_comment"]
["src/nvim/ops.c", [" */", "static void block_insert(oparg_T *oap, char_u *s, int b_insert, struct block_def *bdp)", "{"], "whitespace/line_length"]
["src/nvim/ops.c", ["      spaces = bdp->startspaces;", "      if (spaces != 0)", "        count = p_ts - 1;         /* we're cutting a TAB */"], "readability/braces"]
["src/nvim/ops.c", ["      if (spaces != 0)", "        count = p_ts - 1;         /* we're cutting a TAB */", "      offset = bdp->textcol;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      offset = bdp->textcol;", "    } else { /* append */", "      p_ts = bdp->end_char_vcols;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      p_ts = bdp->end_char_vcols;", "      if (!bdp->is_short) {     /* spaces = padding after block */", "        spaces = (bdp->endspaces ? p_ts - bdp->endspaces : 0);"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        spaces = (bdp->endspaces ? p_ts - bdp->endspaces : 0);", "        if (spaces != 0)", "          count = p_ts - 1;           /* we're cutting a TAB */"], "readability/braces"]
["src/nvim/ops.c", ["        if (spaces != 0)", "          count = p_ts - 1;           /* we're cutting a TAB */", "        offset = bdp->textcol + bdp->textlen - (spaces != 0);"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        offset = bdp->textcol + bdp->textlen - (spaces != 0);", "      } else { /* spaces = padding to block edge */", "                 /* if $ used, just append to EOL (ie spaces==0) */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      } else { /* spaces = padding to block edge */", "                 /* if $ used, just append to EOL (ie spaces==0) */", "        if (!bdp->is_MAX)"], "readability/old_style_comment"]
["src/nvim/ops.c", ["                 /* if $ used, just append to EOL (ie spaces==0) */", "        if (!bdp->is_MAX)", "          spaces = (oap->end_vcol - bdp->end_vcol) + 1;"], "readability/braces"]
["src/nvim/ops.c", ["", "    if (spaces > 0)", "      offset += count;"], "readability/braces"]
["src/nvim/ops.c", ["    if (lnum == oap->end.lnum) {", "      /* Set \"']\" mark to the end of the block instead of the end of", "       * the insert in the first line.  */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    }", "  }   /* for all lnum */", ""], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * op_reindent - handle reindenting a block of lines."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /* Don't even try when 'modifiable' is off. */", "  if (!MODIFIABLE(curbuf)) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  for (i = oap->line_count - 1; i >= 0 && !got_int; i--) {", "    /* it's a slow thing to do, so give feedback so there's no worry that", "     * the computer's just hung. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    if (i > 1", "        && (i % 50 == 0 || i == oap->line_count - 1)"], "readability/braces"]
["src/nvim/ops.c", ["", "    /*", "     * Be vi-compatible: For lisp indenting the first line is not"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      l = skipwhite(get_cursor_line_ptr());", "      if (*l == NUL)                        /* empty or blank line */", "        amount = 0;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      l = skipwhite(get_cursor_line_ptr());", "      if (*l == NUL)                        /* empty or blank line */", "        amount = 0;"], "readability/braces"]
["src/nvim/ops.c", ["        amount = 0;", "      else", "        amount = how();                     /* get the indent for this line */"], "readability/braces"]
["src/nvim/ops.c", ["      else", "        amount = how();                     /* get the indent for this line */", ""], "readability/old_style_comment"]
["src/nvim/ops.c", ["    }", "    ++curwin->w_cursor.lnum;", "    curwin->w_cursor.col = 0;      /* make sure it's valid */"], "readability/increment"]
["src/nvim/ops.c", ["    ++curwin->w_cursor.lnum;", "    curwin->w_cursor.col = 0;      /* make sure it's valid */", "  }"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /* put cursor on first non-blank of indented line */", "  curwin->w_cursor.lnum = start_lnum;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /* Mark changed lines so that they will be redrawn.  When Visual", "   * highlighting was present, need to continue until the last line.  When"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    i = oap->line_count - (i + 1);", "    if (i == 1)", "      MSG(_(\"1 line indented \"));"], "readability/braces"]
["src/nvim/ops.c", ["      MSG(_(\"1 line indented \"));", "    else", "      smsg(_(\"%\" PRId64 \" lines indented \"), (int64_t)i);"], "readability/braces"]
["src/nvim/ops.c", ["  }", "  /* set '[ and '] marks */", "  curbuf->b_op_start = oap->start;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Keep the last expression line here, for repeating."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Get an expression for the \"\\\"=expr1\" or \"CTRL-R =expr1\""], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Set the expression for the '=' register."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Get the result of the '=' register expression."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (expr_line == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/ops.c", ["", "  /* Make a copy of the expression, because evaluating it may cause it to be", "   * changed. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /* When we are invoked recursively limit the evaluation to 10 levels.", "   * Then return the string as-is. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["   * Then return the string as-is. */", "  if (nested >= 10)", "    return expr_copy;"], "readability/braces"]
["src/nvim/ops.c", ["", "  ++nested;", "  rv = eval_to_string(expr_copy, NULL, TRUE);"], "readability/increment"]
["src/nvim/ops.c", ["  ++nested;", "  rv = eval_to_string(expr_copy, NULL, TRUE);", "  --nested;"], "readability/bool"]
["src/nvim/ops.c", ["  rv = eval_to_string(expr_copy, NULL, TRUE);", "  --nested;", "  xfree(expr_copy);"], "readability/increment"]
["src/nvim/ops.c", ["", "/*", " * Get the '=' register expression itself, without evaluating it."], "readability/old_style_comment"]
["src/nvim/ops.c", ["{", "  if (expr_line == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/ops.c", ["  } else if (mode != YREG_YANK", "      && (regname == 0 || regname == '\"' || regname == '*' || regname == '+')", "      && y_previous != NULL) {"], "whitespace/alignment"]
["src/nvim/ops.c", ["      && (regname == 0 || regname == '\"' || regname == '*' || regname == '+')", "      && y_previous != NULL) {", "    // in case clipboard not available, paste from previous used register"], "whitespace/alignment"]
["src/nvim/ops.c", ["", "/*", " * Start or stop recording into a yank register."], "readability/old_style_comment"]
["src/nvim/ops.c", ["    }", "  } else {                        /* stop recording */", "    /*"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  } else {                        /* stop recording */", "    /*", "     * Get the recorded key hits.  K_SPECIAL and CSI will be escaped, this"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    p = get_recorded();", "    if (p == NULL)", "      retval = FAIL;"], "readability/braces"]
["src/nvim/ops.c", ["      retval = FAIL;", "    else {", "      /* Remove escaping for CSI and K_SPECIAL in multi-byte chars. */"], "readability/braces"]
["src/nvim/ops.c", ["      retval = FAIL;", "    else {", "      /* Remove escaping for CSI and K_SPECIAL in multi-byte chars. */"], "readability/braces"]
["src/nvim/ops.c", ["    else {", "      /* Remove escaping for CSI and K_SPECIAL in multi-byte chars. */", "      vim_unescape_csi(p);"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      /*", "       * We don't want to change the default register here, so save and"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Stuff string \"p\" into yank register \"regname\" as a single line (append if"], "readability/old_style_comment"]
["src/nvim/ops.c", ["{", "  /* check for read-only register */", "  if (regname != 0 && !valid_yank_reg(regname, true)) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  }", "  if (regname == '_') {             /* black hole: don't do anything */", "    xfree(p);"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    int regname,", "    int colon,                      /* insert ':' before each line */", "    int addcr,                      /* always add '\\n' to end of line */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    int colon,                      /* insert ':' before each line */", "    int addcr,                      /* always add '\\n' to end of line */", "    int silent                     /* set \"silent\" flag in typeahead buffer */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    int addcr,                      /* always add '\\n' to end of line */", "    int silent                     /* set \"silent\" flag in typeahead buffer */", ")"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (regname == '@') {                 /* repeat previous one */", "    if (execreg_lastc == NUL) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  }", "  /* check for valid regname */", "  if (regname == '%' || regname == '#' || !valid_yank_reg(regname, false)) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (regname == '_')                   /* black hole: don't stuff anything */", "    return OK;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (regname == '_')                   /* black hole: don't stuff anything */", "    return OK;"], "readability/braces"]
["src/nvim/ops.c", ["", "  if (regname == ':') {                 /* use last command line */", "    if (last_cmdline == NULL) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    p = get_expr_line();", "    if (p == NULL)", "      return FAIL;"], "readability/braces"]
["src/nvim/ops.c", ["    xfree(p);", "  } else if (regname == '.') {        /* use last inserted text */", "    p = get_last_insert_save();"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    yankreg_T *reg = get_yank_register(regname, YREG_PASTE);", "    if (reg->y_array == NULL)", "      return FAIL;"], "readability/braces"]
["src/nvim/ops.c", ["", "    /*", "     * Insert lines into typeahead buffer, from last one to first one."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * If \"restart_edit\" is not zero, put it in the typeahead buffer, so that it's"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Insert register contents \"s\" into the typeahead buffer, so that it will be"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Insert a yank register: copy it into the Read buffer."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * It is possible to get into an endless loop by having CTRL-R a in"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  os_breakcheck();", "  if (got_int)", "    return FAIL;"], "readability/braces"]
["src/nvim/ops.c", ["", "  /* check for valid regname */", "  if (regname != NUL && !valid_yank_reg(regname, false))"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  /* check for valid regname */", "  if (regname != NUL && !valid_yank_reg(regname, false))", "    return FAIL;"], "readability/braces"]
["src/nvim/ops.c", ["", "/*", " * Stuff a string into the typeahead buffer, such that edit() will insert it"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /* stuff a single special character */", "    if (*arg != NUL) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  switch (regname) {", "  case '%':                     /* file name */", "    if (errmsg)"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  case '%':                     /* file name */", "    if (errmsg)", "      check_fname();            /* will give emsg if not set */"], "readability/braces"]
["src/nvim/ops.c", ["    if (errmsg)", "      check_fname();            /* will give emsg if not set */", "    *argp = curbuf->b_fname;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  case '=':                     /* result of expression */", "    *argp = get_expr_line();"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  case ':':                     /* last command line */", "    if (last_cmdline == NULL && errmsg)"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  case ':':                     /* last command line */", "    if (last_cmdline == NULL && errmsg)", "      EMSG(_(e_nolastcmd));"], "readability/braces"]
["src/nvim/ops.c", ["", "  case '/':                     /* last search-pattern */", "    if (last_search_pat() == NULL && errmsg)"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  case '/':                     /* last search-pattern */", "    if (last_search_pat() == NULL && errmsg)", "      EMSG(_(e_noprevre));"], "readability/braces"]
["src/nvim/ops.c", ["", "  case '.':                     /* last inserted text */", "    *argp = get_last_insert_save();"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  case '_':                     /* black hole: always empty */", "    *argp = (char_u *)\"\";"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  yankreg_T *reg = get_yank_register(regname, YREG_PASTE);", "  if (reg->y_array == NULL)", "    return FAIL;"], "readability/braces"]
["src/nvim/ops.c", ["", "    /* Check for CTRL-C, in case someone tries to paste a few thousand", "     * lines and gets bored. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    os_breakcheck();", "    if (got_int)", "      return FAIL;"], "readability/braces"]
["src/nvim/ops.c", ["", "/*", " * Handle a delete operation."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Imitate the strange Vi behaviour: If the delete spans more than one"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    ptr = ml_get(oap->end.lnum) + oap->end.col;", "    if (*ptr != NUL)", "      ptr += oap->inclusive;"], "readability/braces"]
["src/nvim/ops.c", ["", "  /*", "   * Check for trying to delete (e.g. \"D\") in an empty line."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Do a yank of whatever we're about to delete."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /*", "     * Put deleted text into register 1 and shift number registers if the"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /* Yank into small delete register when no named register specified", "     * and the delete is within one line. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    }", "", "  }"], "whitespace/blank_line"]
["src/nvim/ops.c", ["", "  /*", "   * block mode delete"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      /* Adjust cursor position for tab replaced by spaces and 'lbr'. */", "      if (lnum == curwin->w_cursor.lnum) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        lnum = curwin->w_cursor.lnum;", "        ++curwin->w_cursor.lnum;", "        del_lines(oap->line_count - 1, TRUE);"], "readability/increment"]
["src/nvim/ops.c", ["        ++curwin->w_cursor.lnum;", "        del_lines(oap->line_count - 1, TRUE);", "        curwin->w_cursor.lnum = lnum;"], "readability/bool"]
["src/nvim/ops.c", ["      }", "      if (u_save_cursor() == FAIL)", "        return FAIL;"], "readability/braces"]
["src/nvim/ops.c", ["    } else {", "      del_lines(oap->line_count, TRUE);", "      beginline(BL_WHITE | BL_FIX);"], "readability/bool"]
["src/nvim/ops.c", ["      beginline(BL_WHITE | BL_FIX);", "      u_clearline();            /* \"U\" command not possible after \"dd\" */", "    }"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      /* For virtualedit: break the tabs that are partly included. */", "      if (gchar_pos(&oap->start) == '\\t') {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      if (gchar_pos(&oap->start) == '\\t') {", "        if (u_save_cursor() == FAIL)            /* save first line for undo */", "          return FAIL;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      if (gchar_pos(&oap->start) == '\\t') {", "        if (u_save_cursor() == FAIL)            /* save first line for undo */", "          return FAIL;"], "readability/braces"]
["src/nvim/ops.c", ["          return FAIL;", "        if (oap->line_count == 1)", "          endcol = getviscol2(oap->end.col, oap->end.coladd);"], "readability/braces"]
["src/nvim/ops.c", ["", "      /* Break a tab only when it's included in the area. */", "      if (gchar_pos(&oap->end) == '\\t'"], "readability/old_style_comment"]
["src/nvim/ops.c", ["          && oap->inclusive) {", "        /* save last line for undo */", "        if (u_save((linenr_T)(oap->end.lnum - 1),"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        /* save last line for undo */", "        if (u_save((linenr_T)(oap->end.lnum - 1),", "                (linenr_T)(oap->end.lnum + 1)) == FAIL)"], "readability/braces"]
["src/nvim/ops.c", ["        if (u_save((linenr_T)(oap->end.lnum - 1),", "                (linenr_T)(oap->end.lnum + 1)) == FAIL)", "          return FAIL;"], "whitespace/alignment"]
["src/nvim/ops.c", ["", "    if (oap->line_count == 1) {         /* delete characters within one line */", "      if (u_save_cursor() == FAIL)              /* save line for undo */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    if (oap->line_count == 1) {         /* delete characters within one line */", "      if (u_save_cursor() == FAIL)              /* save line for undo */", "        return FAIL;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    if (oap->line_count == 1) {         /* delete characters within one line */", "      if (u_save_cursor() == FAIL)              /* save line for undo */", "        return FAIL;"], "readability/braces"]
["src/nvim/ops.c", ["", "      /* if 'cpoptions' contains '$', display '$' at end of change */", "      if (           vim_strchr(p_cpo, CPO_DOLLAR) != NULL"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      /* if 'cpoptions' contains '$', display '$' at end of change */", "      if (           vim_strchr(p_cpo, CPO_DOLLAR) != NULL", "                     && oap->op_type == OP_CHANGE"], "readability/braces"]
["src/nvim/ops.c", ["      if (           vim_strchr(p_cpo, CPO_DOLLAR) != NULL", "                     && oap->op_type == OP_CHANGE", "                     && oap->end.lnum == curwin->w_cursor.lnum"], "whitespace/alignment"]
["src/nvim/ops.c", ["                     && oap->op_type == OP_CHANGE", "                     && oap->end.lnum == curwin->w_cursor.lnum", "                     && !oap->is_VIsual"], "whitespace/alignment"]
["src/nvim/ops.c", ["                     && oap->end.lnum == curwin->w_cursor.lnum", "                     && !oap->is_VIsual", "                     )"], "whitespace/alignment"]
["src/nvim/ops.c", ["                     && !oap->is_VIsual", "                     )", "        display_dollar(oap->end.col - !oap->inclusive);"], "whitespace/alignment"]
["src/nvim/ops.c", ["      if (virtual_op) {", "        /* fix up things for virtualedit-delete:", "         * break the tabs which are going to get in our way"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "        if (oap->end.coladd != 0", "            && (int)oap->end.col >= len - 1"], "readability/braces"]
["src/nvim/ops.c", ["          n++;", "        /* Delete at least one char (e.g, when on a control char). */", "        if (n == 0 && oap->start.coladd != oap->end.coladd)"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        /* Delete at least one char (e.g, when on a control char). */", "        if (n == 0 && oap->start.coladd != oap->end.coladd)", "          n = 1;"], "readability/braces"]
["src/nvim/ops.c", ["", "        /* When deleted a char in the line, reset coladd. */", "        if (gchar_cursor() != NUL)"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        /* When deleted a char in the line, reset coladd. */", "        if (gchar_cursor() != NUL)", "          curwin->w_cursor.coladd = 0;"], "readability/braces"]
["src/nvim/ops.c", ["", "      /* save deleted and changed lines for undo */", "      if (u_save((linenr_T)(curwin->w_cursor.lnum - 1),"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      /* save deleted and changed lines for undo */", "      if (u_save((linenr_T)(curwin->w_cursor.lnum - 1),", "              (linenr_T)(curwin->w_cursor.lnum + oap->line_count)) == FAIL)"], "readability/braces"]
["src/nvim/ops.c", ["      if (u_save((linenr_T)(curwin->w_cursor.lnum - 1),", "              (linenr_T)(curwin->w_cursor.lnum + oap->line_count)) == FAIL)", "        return FAIL;"], "whitespace/alignment"]
["src/nvim/ops.c", ["", "/*", " * Adjust end of operating area for ending on a multi-byte character."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Put character 'c' at position 'lp'"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Replace a whole area with one character."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if ((curbuf->b_ml.ml_flags & ML_EMPTY ) || oap->empty)", "    return OK;              /* nothing to do */"], "readability/braces"]
["src/nvim/ops.c", ["  if ((curbuf->b_ml.ml_flags & ML_EMPTY ) || oap->empty)", "    return OK;              /* nothing to do */", ""], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (u_save((linenr_T)(oap->start.lnum - 1),", "          (linenr_T)(oap->end.lnum + 1)) == FAIL)"], "readability/braces"]
["src/nvim/ops.c", ["  if (u_save((linenr_T)(oap->start.lnum - 1),", "          (linenr_T)(oap->end.lnum + 1)) == FAIL)", "    return FAIL;"], "whitespace/alignment"]
["src/nvim/ops.c", ["", "  /*", "   * block mode replace"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      /* n == number of extra chars required", "       * If we split a TAB, it may be replaced by several characters."], "readability/old_style_comment"]
["src/nvim/ops.c", ["       */", "      /* If the range starts in virtual space, count the initial", "       * coladd offset as part of \"startspaces\" */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        n = bd.startspaces;", "      } else", "        /* allow for pre spaces */"], "readability/braces"]
["src/nvim/ops.c", ["      } else", "        /* allow for pre spaces */", "        n = (bd.startspaces ? bd.start_char_vcols - 1 : 0);"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      /* allow for post spp */", "      n += (bd.endspaces"], "readability/old_style_comment"]
["src/nvim/ops.c", ["            && bd.end_char_vcols > 0) ? bd.end_char_vcols - 1 : 0;", "      /* Figure out how many characters to replace. */", "      numc = oap->end_vcol - oap->start_vcol + 1;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      numc = oap->end_vcol - oap->start_vcol + 1;", "      if (bd.is_short && (!virtual_op || bd.is_MAX))", "        numc -= (oap->end_vcol - bd.end_vcol) + 1;"], "readability/braces"]
["src/nvim/ops.c", ["", "      /* A double-wide character can be replaced only up to half the", "       * times. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        if ((numc & 1) && !bd.is_short) {", "          ++bd.endspaces;", "          ++n;"], "readability/increment"]
["src/nvim/ops.c", ["          ++bd.endspaces;", "          ++n;", "        }"], "readability/increment"]
["src/nvim/ops.c", ["", "      /* Compute bytes needed, move character count to num_chars. */", "      num_chars = numc;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      oap->end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));", "      if (oap->end.col)", "        --oap->end.col;"], "readability/braces"]
["src/nvim/ops.c", ["      if (oap->end.col)", "        --oap->end.col;", "    } else if (!oap->inclusive)"], "readability/increment"]
["src/nvim/ops.c", ["        --oap->end.col;", "    } else if (!oap->inclusive)", "      dec(&(oap->end));"], "readability/braces"]
["src/nvim/ops.c", ["        if ((*mb_char2len)(c) > 1 || (*mb_char2len)(n) > 1) {", "          /* This is slow, but it handles replacing a single-byte", "           * with a multi-byte and the other way around. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["           * with a multi-byte and the other way around. */", "          if (curwin->w_cursor.lnum == oap->end.lnum)", "            oap->end.col += (*mb_char2len)(c) - (*mb_char2len)(n);"], "readability/braces"]
["src/nvim/ops.c", ["            if (curwin->w_cursor.lnum == oap->end.lnum) {", "              /* oap->end has to be recalculated when", "               * the tab breaks */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["              end_vcol = getviscol2(oap->end.col,", "                  oap->end.coladd);", "            }"], "whitespace/alignment"]
["src/nvim/ops.c", ["            coladvance_force(getviscol());", "            if (curwin->w_cursor.lnum == oap->end.lnum)", "              getvpos(&oap->end, end_vcol);"], "readability/braces"]
["src/nvim/ops.c", ["", "        if (curwin->w_cursor.lnum == oap->start.lnum", "            && oap->start.col == oap->end.col && oap->start.coladd)"], "readability/braces"]
["src/nvim/ops.c", ["", "        /* oap->end has been trimmed so it's effectively inclusive;", "         * as a result an extra +1 must be counted so we don't"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      /* Advance to next character, stop at the end of the file. */", "      if (inc_cursor() == -1)"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      /* Advance to next character, stop at the end of the file. */", "      if (inc_cursor() == -1)", "        break;"], "readability/braces"]
["src/nvim/ops.c", ["", "  /* Set \"'[\" and \"']\" marks. */", "  curbuf->b_op_start = oap->start;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Handle the (non-standard vi) tilde operator.  Also for \"gu\", \"gU\" and \"g?\"."], "readability/old_style_comment"]
["src/nvim/ops.c", ["  struct block_def bd;", "  int did_change = FALSE;", ""], "readability/bool"]
["src/nvim/ops.c", ["", "  if (u_save((linenr_T)(oap->start.lnum - 1),", "          (linenr_T)(oap->end.lnum + 1)) == FAIL)"], "readability/braces"]
["src/nvim/ops.c", ["  if (u_save((linenr_T)(oap->start.lnum - 1),", "          (linenr_T)(oap->end.lnum + 1)) == FAIL)", "    return;"], "whitespace/alignment"]
["src/nvim/ops.c", ["      did_change |= one_change;", "", "    }"], "whitespace/blank_line"]
["src/nvim/ops.c", ["      oap->end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));", "      if (oap->end.col)", "        --oap->end.col;"], "readability/braces"]
["src/nvim/ops.c", ["      if (oap->end.col)", "        --oap->end.col;", "    } else if (!oap->inclusive)"], "readability/increment"]
["src/nvim/ops.c", ["        --oap->end.col;", "    } else if (!oap->inclusive)", "      dec(&(oap->end));"], "readability/braces"]
["src/nvim/ops.c", ["", "    if (pos.lnum == oap->end.lnum)", "      did_change = swapchars(oap->op_type, &pos,"], "readability/braces"]
["src/nvim/ops.c", ["      did_change = swapchars(oap->op_type, &pos,", "          oap->end.col - pos.col + 1);", "    else"], "whitespace/alignment"]
["src/nvim/ops.c", ["          oap->end.col - pos.col + 1);", "    else", "      for (;; ) {"], "readability/braces"]
["src/nvim/ops.c", ["        did_change |= swapchars(oap->op_type, &pos,", "            pos.lnum == oap->end.lnum ? oap->end.col + 1 :", "            (int)STRLEN(ml_get_pos(&pos)));"], "whitespace/alignment"]
["src/nvim/ops.c", ["            pos.lnum == oap->end.lnum ? oap->end.col + 1 :", "            (int)STRLEN(ml_get_pos(&pos)));", "        if (ltoreq(oap->end, pos) || inc(&pos) == -1)"], "whitespace/alignment"]
["src/nvim/ops.c", ["            (int)STRLEN(ml_get_pos(&pos)));", "        if (ltoreq(oap->end, pos) || inc(&pos) == -1)", "          break;"], "readability/braces"]
["src/nvim/ops.c", ["", "  if (!did_change && oap->is_VIsual)", "    /* No change: need to remove the Visual selection */"], "readability/braces"]
["src/nvim/ops.c", ["  if (!did_change && oap->is_VIsual)", "    /* No change: need to remove the Visual selection */", "    redraw_curbuf_later(INVERTED);"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Set '[ and '] marks."], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (oap->line_count > p_report) {", "    if (oap->line_count == 1)", "      MSG(_(\"1 line changed\"));"], "readability/braces"]
["src/nvim/ops.c", ["      MSG(_(\"1 line changed\"));", "    else", "      smsg(_(\"%\" PRId64 \" lines changed\"), (int64_t)oap->line_count);"], "readability/braces"]
["src/nvim/ops.c", ["", "/*", " * Invoke swapchar() on \"length\" bytes at position \"pos\"."], "readability/old_style_comment"]
["src/nvim/ops.c", ["    did_change |= swapchar(op_type, pos);", "    if (inc(pos) == -1)        /* at end of file */", "      break;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    did_change |= swapchar(op_type, pos);", "    if (inc(pos) == -1)        /* at end of file */", "      break;"], "readability/braces"]
["src/nvim/ops.c", ["", "    /* Special handling of German sharp s: change to \"SS\". */", "    curwin->w_cursor = *pos;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * op_insert - Insert and append operators for Visual mode."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /* edit() changes this - record it for OP_APPEND */", "  bd.is_MAX = (curwin->w_curswant == MAXCOL);"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /* vis block is still marked. Get rid of it now. */", "  curwin->w_cursor.lnum = oap->start.lnum;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      ve_flags = VE_ALL;", "      if (u_save_cursor() == FAIL)", "        return;"], "readability/braces"]
["src/nvim/ops.c", ["      coladvance_force(oap->op_type == OP_APPEND", "          ? oap->end_vcol + 1 : getviscol());", "      if (oap->op_type == OP_APPEND)"], "whitespace/alignment"]
["src/nvim/ops.c", ["          ? oap->end_vcol + 1 : getviscol());", "      if (oap->op_type == OP_APPEND)", "        --curwin->w_cursor.col;"], "readability/braces"]
["src/nvim/ops.c", ["      if (oap->op_type == OP_APPEND)", "        --curwin->w_cursor.col;", "      ve_flags = old_ve_flags;"], "readability/increment"]
["src/nvim/ops.c", ["        ) {", "      /* Move the cursor to the character right of the block. */", "      curwin->w_set_curswant = TRUE;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      /* Move the cursor to the character right of the block. */", "      curwin->w_set_curswant = TRUE;", "      while (*get_cursor_pos_ptr() != NUL"], "readability/bool"]
["src/nvim/ops.c", ["      curwin->w_set_curswant = TRUE;", "      while (*get_cursor_pos_ptr() != NUL", "             && (curwin->w_cursor.col < bd.textcol + bd.textlen))"], "readability/braces"]
["src/nvim/ops.c", ["             && (curwin->w_cursor.col < bd.textcol + bd.textlen))", "        ++curwin->w_cursor.col;", "      if (bd.is_short && !bd.is_MAX) {"], "readability/increment"]
["src/nvim/ops.c", ["      if (bd.is_short && !bd.is_MAX) {", "        /* First line was too short, make it longer and adjust the", "         * values in \"bd\". */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["         * values in \"bd\". */", "        if (u_save_cursor() == FAIL)", "          return;"], "readability/braces"]
["src/nvim/ops.c", ["", "  /* If user has moved off this line, we don't know what to do, so do", "   * nothing."], "readability/old_style_comment"]
["src/nvim/ops.c", ["   * Also don't repeat the insert when Insert mode ended with CTRL-C. */", "  if (curwin->w_cursor.lnum != oap->start.lnum || got_int)", "    return;"], "readability/braces"]
["src/nvim/ops.c", ["        oap->start.col = curbuf->b_op_start_orig.col;", "        /* reset pre_textlen to the value of OP_INSERT */", "        pre_textlen += bd.textlen;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /*", "     * Spaces and tabs in the indent may have changed to other spaces and"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        pre_textlen += bd2.textlen - bd.textlen;", "        if (bd2.endspaces)", "          --bd2.textlen;"], "readability/braces"]
["src/nvim/ops.c", ["        if (bd2.endspaces)", "          --bd2.textlen;", "      }"], "readability/increment"]
["src/nvim/ops.c", ["", "    /*", "     * Subsequent calls to ml_get() flush the firstline data - take a"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * op_change - handle a change operation"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    l = 0;", "    if (!p_paste && curbuf->b_p_si", "        && !curbuf->b_p_cin"], "readability/braces"]
["src/nvim/ops.c", ["", "  /* First delete the text in the region.  In an empty buffer only need to", "   * save for undo */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (curbuf->b_ml.ml_flags & ML_EMPTY) {", "    if (u_save_cursor() == FAIL)", "      return FALSE;"], "readability/braces"]
["src/nvim/ops.c", ["    if (u_save_cursor() == FAIL)", "      return FALSE;", "  } else if (op_delete(oap) == FAIL)"], "readability/bool"]
["src/nvim/ops.c", ["      return FALSE;", "  } else if (op_delete(oap) == FAIL)", "    return FALSE;"], "readability/braces"]
["src/nvim/ops.c", ["  } else if (op_delete(oap) == FAIL)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/ops.c", ["", "  retval = edit(NUL, FALSE, (linenr_T)1);", ""], "readability/bool"]
["src/nvim/ops.c", ["", "  /*", "   * In Visual block mode, handle copying the new text to all lines of the"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    if (ins_len > 0) {", "      /* Subsequent calls to ml_get() flush the firstline data - take a", "       * copy of the inserted text.  */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "          /* If the block starts in virtual space, count the", "           * initial coladd offset as part of \"startspaces\" */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * set all the yank registers to empty (called from main())"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", " /// Free contents of yankreg `reg`.", " /// Called for normal freeing and in case of error."], "whitespace/indent"]
["src/nvim/ops.c", [" /// Free contents of yankreg `reg`.", " /// Called for normal freeing and in case of error.", " /// `reg` must not be NULL (but `reg->y_array` might be)"], "whitespace/indent"]
["src/nvim/ops.c", [" /// Called for normal freeing and in case of error.", " /// `reg` must not be NULL (but `reg->y_array` might be)", "void free_register(yankreg_T *reg)"], "whitespace/indent"]
["src/nvim/ops.c", ["  if (oap->regname == '_') {", "    return true; // black hole: nothing to do", "  }"], "whitespace/comments"]
["src/nvim/ops.c", ["", "    if (curwin->w_curswant == MAXCOL && reg->y_width > 0)", "      reg->y_width--;"], "readability/braces"]
["src/nvim/ops.c", ["          if (ce != cs && oap->start.coladd > 0) {", "            /* Part of a tab selected -- but don't", "             * double-count it. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      }", "      if (endcol == MAXCOL)", "        endcol = (colnr_T)STRLEN(p);"], "readability/braces"]
["src/nvim/ops.c", ["", "  if (curr != reg) {      /* append the new block to the old block */", "    new_ptr = xmalloc(sizeof(char_u *) * (curr->y_size + reg->y_size));"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    new_ptr = xmalloc(sizeof(char_u *) * (curr->y_size + reg->y_size));", "    for (j = 0; j < curr->y_size; ++j)", "      new_ptr[j] = curr->y_array[j];"], "readability/braces"]
["src/nvim/ops.c", ["    new_ptr = xmalloc(sizeof(char_u *) * (curr->y_size + reg->y_size));", "    for (j = 0; j < curr->y_size; ++j)", "      new_ptr[j] = curr->y_array[j];"], "readability/increment"]
["src/nvim/ops.c", ["      y_idx = 1;", "    } else", "      y_idx = 0;"], "readability/braces"]
["src/nvim/ops.c", ["      y_idx = 0;", "    while (y_idx < reg->y_size)", "      curr->y_array[j++] = reg->y_array[y_idx++];"], "readability/braces"]
["src/nvim/ops.c", ["", "  /*", "   * Set \"'[\" and \"']\" marks."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Put contents of register \"regname\" into the text."], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int indent;", "  int orig_indent = 0;                  /* init for gcc */", "  int indent_diff = 0;                  /* init for gcc */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int orig_indent = 0;                  /* init for gcc */", "  int indent_diff = 0;                  /* init for gcc */", "  int first_indent = TRUE;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int indent_diff = 0;                  /* init for gcc */", "  int first_indent = TRUE;", "  int lendiff = 0;"], "readability/bool"]
["src/nvim/ops.c", ["", "  if (flags & PUT_FIXINDENT)", "    orig_indent = get_indent();"], "readability/braces"]
["src/nvim/ops.c", ["", "  curbuf->b_op_start = curwin->w_cursor;        /* default for '[ mark */", "  curbuf->b_op_end = curwin->w_cursor;          /* default for '] mark */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  curbuf->b_op_start = curwin->w_cursor;        /* default for '[ mark */", "  curbuf->b_op_end = curwin->w_cursor;          /* default for '] mark */", ""], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Using inserted text works differently, because the register includes"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * For special registers '%' (file name), '#' (alternate file name) and"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    if (regname == '=') {", "      /* For the = register we need to split the string at NL", "       * characters."], "readability/old_style_comment"]
["src/nvim/ops.c", ["        while (ptr != NULL) {", "          if (y_array != NULL)", "            y_array[y_size] = ptr;"], "readability/braces"]
["src/nvim/ops.c", ["            y_array[y_size] = ptr;", "          ++y_size;", "          ptr = vim_strchr(ptr, '\\n');"], "readability/increment"]
["src/nvim/ops.c", ["          if (ptr != NULL) {", "            if (y_array != NULL)", "              *ptr = NUL;"], "readability/braces"]
["src/nvim/ops.c", ["              *ptr = NUL;", "            ++ptr;", "            /* A trailing '\\n' makes the register linewise. */"], "readability/increment"]
["src/nvim/ops.c", ["            ++ptr;", "            /* A trailing '\\n' makes the register linewise. */", "            if (*ptr == NUL) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        }", "        if (y_array != NULL)", "          break;"], "readability/braces"]
["src/nvim/ops.c", ["    } else {", "      y_size = 1;               /* use fake one-line yank register */", "      y_array = &insert_string;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    if (flags & PUT_LINE_FORWARD) {", "      /* Must be \"p\" for a Visual block, put lines below the block. */", "      curwin->w_cursor = curbuf->b_visual.vi_end;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    }", "    curbuf->b_op_start = curwin->w_cursor;      /* default for '[ mark */", "    curbuf->b_op_end = curwin->w_cursor;        /* default for '] mark */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    curbuf->b_op_start = curwin->w_cursor;      /* default for '[ mark */", "    curbuf->b_op_end = curwin->w_cursor;        /* default for '] mark */", "  }"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    EMSG2(_(\"E353: Nothing in register %s\"),", "        regname == 0 ? (char_u *)\"\\\"\" : transchar(regname));", "    goto end;"], "whitespace/alignment"]
["src/nvim/ops.c", ["    if (gchar_cursor() == TAB) {", "      /* Don't need to insert spaces when \"p\" on the last position of a", "       * tab or \"P\" on the first position. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Block mode"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    if (dir == FORWARD && c != NUL) {", "      if (ve_flags == VE_ALL)", "        getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);"], "readability/braces"]
["src/nvim/ops.c", ["        getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);", "      else", "        getvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);"], "readability/braces"]
["src/nvim/ops.c", ["      if (c == TAB) {", "        if (dir == BACKWARD && curwin->w_cursor.col)", "          curwin->w_cursor.col--;"], "readability/braces"]
["src/nvim/ops.c", ["          curwin->w_cursor.col--;", "        if (dir == FORWARD && col - 1 == endcol2)", "          curwin->w_cursor.col++;"], "readability/braces"]
["src/nvim/ops.c", ["", "      /* add a new line */", "      if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      }", "      /* get the old line and advance to the position to insert at */", "      oldp = get_cursor_line_ptr();"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      for (ptr = oldp; vcol < col && *ptr; ) {", "        /* Count a tab for what it's worth (if list mode not on) */", "        incr = lbr_chartabsize_adv(oldp, &ptr, (colnr_T)vcol);"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      if (vcol < col)       /* line too short, padd with spaces */", "        bd.startspaces = col - vcol;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      if (vcol < col)       /* line too short, padd with spaces */", "        bd.startspaces = col - vcol;"], "readability/braces"]
["src/nvim/ops.c", ["        bd.startspaces = col - vcol;", "      else if (vcol > col) {", "        bd.endspaces = vcol - col;"], "readability/braces"]
["src/nvim/ops.c", ["        bd.startspaces = incr - bd.endspaces;", "        --bd.textcol;", "        delcount = 1;"], "readability/increment"]
["src/nvim/ops.c", ["        if (oldp[bd.textcol] != TAB) {", "          /* Only a Tab can be split into spaces.  Other", "           * characters will have to be moved to after the"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      ++curwin->w_cursor.lnum;", "      if (i == 0)"], "readability/increment"]
["src/nvim/ops.c", ["      ++curwin->w_cursor.lnum;", "      if (i == 0)", "        curwin->w_cursor.col += bd.startspaces;"], "readability/braces"]
["src/nvim/ops.c", ["", "    /* Set '[ mark. */", "    curbuf->b_op_start = curwin->w_cursor;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /* adjust '] mark */", "    curbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      /* in Insert mode we might be after the NUL, correct for that */", "      len = (colnr_T)STRLEN(get_cursor_line_ptr());"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      len = (colnr_T)STRLEN(get_cursor_line_ptr());", "      if (curwin->w_cursor.col > len)", "        curwin->w_cursor.col = len;"], "readability/braces"]
["src/nvim/ops.c", ["        curwin->w_cursor.col = len;", "    } else", "      curwin->w_cursor.lnum = lnum;"], "readability/braces"]
["src/nvim/ops.c", ["    }", "    /*", "     * Line mode: BACKWARD is the same as FORWARD on the previous line"], "readability/old_style_comment"]
["src/nvim/ops.c", ["     */", "    else if (dir == BACKWARD)", "      --lnum;"], "whitespace/newline"]
["src/nvim/ops.c", ["    else if (dir == BACKWARD)", "      --lnum;", "    new_cursor = curwin->w_cursor;"], "readability/increment"]
["src/nvim/ops.c", ["", "      if (VIsual_active) {  /* reset lnum to the last visual line */", "        lnum--;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      curbuf->b_op_end = curwin->w_cursor;", "      /* For \"CTRL-O p\" in Insert mode, put cursor after last char */", "      if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND)))"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      /* For \"CTRL-O p\" in Insert mode, put cursor after last char */", "      if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND)))", "        ++curwin->w_cursor.col;"], "readability/braces"]
["src/nvim/ops.c", ["      if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND)))", "        ++curwin->w_cursor.col;", "      changed_bytes(lnum, col);"], "readability/increment"]
["src/nvim/ops.c", ["          totlen = STRLEN(y_array[y_size - 1]);", "          newp = (char_u *) xmalloc((size_t)(STRLEN(ptr) + totlen + 1));", "          STRCPY(newp, y_array[y_size - 1]);"], "whitespace/cast"]
["src/nvim/ops.c", ["          lnum++;", "          ++nr_lines;", "          if (flags & PUT_FIXINDENT) {"], "readability/increment"]
["src/nvim/ops.c", ["            ptr = ml_get(lnum);", "            if (cnt == count && i == y_size - 1)", "              lendiff = (int)STRLEN(ptr);"], "readability/braces"]
["src/nvim/ops.c", ["              lendiff = (int)STRLEN(ptr);", "            if (*ptr == '#' && preprocs_left())", "              indent = 0;                   /* Leave # lines at start */"], "readability/braces"]
["src/nvim/ops.c", ["            if (*ptr == '#' && preprocs_left())", "              indent = 0;                   /* Leave # lines at start */", "            else if (*ptr == NUL)"], "readability/old_style_comment"]
["src/nvim/ops.c", ["              indent = 0;                   /* Leave # lines at start */", "            else if (*ptr == NUL)", "              indent = 0;                   /* Ignore empty lines */"], "readability/braces"]
["src/nvim/ops.c", ["            else if (*ptr == NUL)", "              indent = 0;                   /* Ignore empty lines */", "            else if (first_indent) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["              indent = 0;                   /* Ignore empty lines */", "            else if (first_indent) {", "              indent_diff = orig_indent - get_indent();"], "readability/braces"]
["src/nvim/ops.c", ["              indent = orig_indent;", "              first_indent = FALSE;", "            } else if ((indent = get_indent() + indent_diff) < 0)"], "readability/bool"]
["src/nvim/ops.c", ["              first_indent = FALSE;", "            } else if ((indent = get_indent() + indent_diff) < 0)", "              indent = 0;"], "readability/braces"]
["src/nvim/ops.c", ["            curwin->w_cursor = old_pos;", "            /* remember how many chars were removed */", "            if (cnt == count && i == y_size - 1)"], "readability/old_style_comment"]
["src/nvim/ops.c", ["            /* remember how many chars were removed */", "            if (cnt == count && i == y_size - 1)", "              lendiff -= (int)STRLEN(ml_get(lnum));"], "readability/braces"]
["src/nvim/ops.c", ["        curbuf->b_op_start.col = 0;", "        if (dir == FORWARD)", "          curbuf->b_op_start.lnum++;"], "readability/braces"]
["src/nvim/ops.c", ["", "      /* put '] mark at last inserted character */", "      curbuf->b_op_end.lnum = lnum;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      curbuf->b_op_end.lnum = lnum;", "      /* correct length for change in indent */", "      col = (colnr_T)STRLEN(y_array[y_size - 1]) - lendiff;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      col = (colnr_T)STRLEN(y_array[y_size - 1]) - lendiff;", "      if (col > 1)", "        curbuf->b_op_end.col = col - 1;"], "readability/braces"]
["src/nvim/ops.c", ["        curbuf->b_op_end.col = col - 1;", "      else", "        curbuf->b_op_end.col = 0;"], "readability/braces"]
["src/nvim/ops.c", ["      if (flags & PUT_CURSLINE) {", "        /* \":put\": put cursor on last inserted line */", "        curwin->w_cursor.lnum = lnum;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        curwin->w_cursor.col = 0;", "        if (dir == FORWARD)", "          ++curwin->w_cursor.lnum;"], "readability/braces"]
["src/nvim/ops.c", ["        if (dir == FORWARD)", "          ++curwin->w_cursor.lnum;", "        beginline(BL_WHITE | BL_FIX);"], "readability/increment"]
["src/nvim/ops.c", ["        beginline(BL_WHITE | BL_FIX);", "      } else            /* put cursor on first inserted character */", "        curwin->w_cursor = new_cursor;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        beginline(BL_WHITE | BL_FIX);", "      } else            /* put cursor on first inserted character */", "        curwin->w_cursor = new_cursor;"], "readability/braces"]
["src/nvim/ops.c", ["  msgmore(nr_lines);", "  curwin->w_set_curswant = TRUE;", ""], "readability/bool"]
["src/nvim/ops.c", ["end:", "  if (allocated)", "    xfree(insert_string);"], "readability/braces"]
["src/nvim/ops.c", ["    xfree(insert_string);", "  if (regname == '=')", "    xfree(y_array);"], "readability/braces"]
["src/nvim/ops.c", ["", "  VIsual_active = FALSE;", ""], "readability/bool"]
["src/nvim/ops.c", ["", "  /* If the cursor is past the end of the line put it at the end. */", "  adjust_cursor_eol();"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * When the cursor is on the NUL past the end of the line and it should not be"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      && !(restart_edit || (State & INSERT))) {", "    /* Put the cursor on the last character in the line. */", "    dec_cursor();"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      /* Coladd is set to the width of the last character. */", "      getvcol(curwin, &curwin->w_cursor, &scol, NULL, &ecol);"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Return TRUE if lines starting with '#' should be left aligned."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/* Return the character name of the register with the given number */", "int get_register_name(int num)"], "readability/old_style_comment"]
["src/nvim/ops.c", ["{", "  if (num == -1)", "    return '\"';"], "readability/braces"]
["src/nvim/ops.c", ["    return '\"';", "  else if (num < 10)", "    return num + '0';"], "readability/braces"]
["src/nvim/ops.c", ["    return num + '0';", "  else if (num == DELETION_REGISTER)", "    return '-';"], "readability/braces"]
["src/nvim/ops.c", ["    return '-';", "  else if (num == STAR_REGISTER)", "    return '*';"], "readability/braces"]
["src/nvim/ops.c", ["    return '*';", "  else if (num == PLUS_REGISTER)", "    return '+';"], "readability/braces"]
["src/nvim/ops.c", ["    return '+';", "  else {", "    return num + 'a' - 10;"], "readability/braces"]
["src/nvim/ops.c", ["    return '+';", "  else {", "    return num + 'a' - 10;"], "readability/braces"]
["src/nvim/ops.c", ["", "/*", " * \":dis\" and \":registers\": Display the contents of the yank registers."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (arg != NULL && *arg == NUL)", "    arg = NULL;"], "readability/braces"]
["src/nvim/ops.c", ["    if (arg != NULL && vim_strchr(arg, name) == NULL) {", "      continue;             /* did not ask for this register */", "    }"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    if (i == -1) {", "      if (y_previous != NULL)", "        yb = y_previous;"], "readability/braces"]
["src/nvim/ops.c", ["        yb = y_previous;", "      else", "        yb = &(y_regs[0]);"], "readability/braces"]
["src/nvim/ops.c", ["        yb = &(y_regs[0]);", "    } else", "      yb = &(y_regs[i]);"], "readability/braces"]
["src/nvim/ops.c", ["", "  /*", "   * display last inserted text"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * display last command line"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * display current file name"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * display alternate file name"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * display last search pattern"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * display last used expression"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * display a string for do_dis()"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      p += l;", "    } else", "      msg_outtrans_len(p++, 1);"], "readability/braces"]
["src/nvim/ops.c", ["  if (leader_offset != -1) {", "    /* Let's check whether the line ends with an unclosed comment.", "     * If the last comment leader has COM_END in flags, there's no comment."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (lead_len == 0)", "    return line;"], "readability/braces"]
["src/nvim/ops.c", ["", "  /* Find:", "   * - COM_END,"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    }", "    ++comment_flags;", "  }"], "readability/increment"]
["src/nvim/ops.c", ["", "  /* If we found a colon, it means that we are not processing a line", "   * starting with a closing part of a three-part comment. That's good,"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  char_u      *newp;", "  char_u      *spaces;          /* number of spaces inserted before a line */", "  int endcurr1 = NUL;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int endcurr2 = NUL;", "  int currsize = 0;             /* size of the current line */", "  int sumsize = 0;              /* size of the long new line */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int currsize = 0;             /* size of the current line */", "  int sumsize = 0;              /* size of the long new line */", "  linenr_T t;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int         *comments = NULL;", "  int remove_comments = (use_formatoptions == TRUE)", "                        && has_format_option(FO_REMOVE_COMS);"], "readability/bool"]
["src/nvim/ops.c", ["          ) {", "        /* don't add a space if the line is ending in a space */", "        if (endcurr1 == ' ')"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        /* don't add a space if the line is ending in a space */", "        if (endcurr1 == ' ')", "          endcurr1 = endcurr2;"], "readability/braces"]
["src/nvim/ops.c", ["          endcurr1 = endcurr2;", "        else", "          ++spaces[t];"], "readability/braces"]
["src/nvim/ops.c", ["        else", "          ++spaces[t];", "        // Extra space when 'joinspaces' set and line ends in '.', '?', or '!'."], "readability/increment"]
["src/nvim/ops.c", ["        if (p_js && (endcurr1 == '.' || endcurr1 == '?' || endcurr1 == '!')) {", "          ++spaces[t];", "        }"], "readability/increment"]
["src/nvim/ops.c", ["", "  /*", "   * Move affected lines to the new long one."], "readability/old_style_comment"]
["src/nvim/ops.c", ["    curr = curr_start = ml_get((linenr_T)(curwin->w_cursor.lnum + t - 1));", "    if (remove_comments)", "      curr += comments[t - 1];"], "readability/braces"]
["src/nvim/ops.c", ["      curr += comments[t - 1];", "    if (insert_space && t > 1)", "      curr = skipwhite(curr);"], "readability/braces"]
["src/nvim/ops.c", ["", "  /* Only report the change in the first line here, del_lines() will report", "   * the deleted line. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Delete following lines. To do this we move the cursor there"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Set the cursor column:"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  curwin->w_cursor.coladd = 0;", "  curwin->w_set_curswant = TRUE;", ""], "readability/bool"]
["src/nvim/ops.c", ["  xfree(spaces);", "  if (remove_comments)", "    xfree(comments);"], "readability/braces"]
["src/nvim/ops.c", ["", "/*", " * Return TRUE if the two comment leaders given are the same.  \"lnum\" is"], "readability/old_style_comment"]
["src/nvim/ops.c", [" */", "static int same_leader(linenr_T lnum, int leader1_len, char_u *leader1_flags, int leader2_len, char_u *leader2_flags)", "{"], "whitespace/line_length"]
["src/nvim/ops.c", ["", "  if (leader1_len == 0)", "    return leader2_len == 0;"], "readability/braces"]
["src/nvim/ops.c", ["", "  /*", "   * If first leader has 'f' flag, the lines can be joined only if the"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (leader1_flags != NULL) {", "    for (p = leader1_flags; *p && *p != ':'; ++p) {", "      if (*p == COM_FIRST)"], "readability/increment"]
["src/nvim/ops.c", ["    for (p = leader1_flags; *p && *p != ':'; ++p) {", "      if (*p == COM_FIRST)", "        return leader2_len == 0;"], "readability/braces"]
["src/nvim/ops.c", ["        return leader2_len == 0;", "      if (*p == COM_END)", "        return FALSE;"], "readability/braces"]
["src/nvim/ops.c", ["      if (*p == COM_END)", "        return FALSE;", "      if (*p == COM_START) {"], "readability/bool"]
["src/nvim/ops.c", ["      if (*p == COM_START) {", "        if (*(ml_get(lnum) + leader1_len) == NUL)", "          return FALSE;"], "readability/braces"]
["src/nvim/ops.c", ["        if (*(ml_get(lnum) + leader1_len) == NUL)", "          return FALSE;", "        if (leader2_flags == NULL || leader2_len == 0)"], "readability/bool"]
["src/nvim/ops.c", ["          return FALSE;", "        if (leader2_flags == NULL || leader2_len == 0)", "          return FALSE;"], "readability/braces"]
["src/nvim/ops.c", ["        if (leader2_flags == NULL || leader2_len == 0)", "          return FALSE;", "        for (p = leader2_flags; *p && *p != ':'; ++p)"], "readability/bool"]
["src/nvim/ops.c", ["          return FALSE;", "        for (p = leader2_flags; *p && *p != ':'; ++p)", "          if (*p == COM_MIDDLE)"], "readability/braces"]
["src/nvim/ops.c", ["          return FALSE;", "        for (p = leader2_flags; *p && *p != ':'; ++p)", "          if (*p == COM_MIDDLE)"], "readability/increment"]
["src/nvim/ops.c", ["        for (p = leader2_flags; *p && *p != ':'; ++p)", "          if (*p == COM_MIDDLE)", "            return TRUE;"], "readability/braces"]
["src/nvim/ops.c", ["          if (*p == COM_MIDDLE)", "            return TRUE;", "        return FALSE;"], "readability/bool"]
["src/nvim/ops.c", ["            return TRUE;", "        return FALSE;", "      }"], "readability/bool"]
["src/nvim/ops.c", ["", "  /*", "   * Get current line and next line, compare the leaders."], "readability/old_style_comment"]
["src/nvim/ops.c", ["  line1 = vim_strsave(ml_get(lnum));", "  for (idx1 = 0; ascii_iswhite(line1[idx1]); ++idx1)", "    ;"], "readability/braces"]
["src/nvim/ops.c", ["  line1 = vim_strsave(ml_get(lnum));", "  for (idx1 = 0; ascii_iswhite(line1[idx1]); ++idx1)", "    ;"], "readability/increment"]
["src/nvim/ops.c", ["  for (idx1 = 0; ascii_iswhite(line1[idx1]); ++idx1)", "    ;", "  line2 = ml_get(lnum + 1);"], "whitespace/semicolon"]
["src/nvim/ops.c", ["  line2 = ml_get(lnum + 1);", "  for (idx2 = 0; idx2 < leader2_len; ++idx2) {", "    if (!ascii_iswhite(line2[idx2])) {"], "readability/increment"]
["src/nvim/ops.c", ["    if (!ascii_iswhite(line2[idx2])) {", "      if (line1[idx1++] != line2[idx2])", "        break;"], "readability/braces"]
["src/nvim/ops.c", ["        break;", "    } else", "      while (ascii_iswhite(line1[idx1]))"], "readability/braces"]
["src/nvim/ops.c", ["    } else", "      while (ascii_iswhite(line1[idx1]))", "        ++idx1;"], "readability/braces"]
["src/nvim/ops.c", ["      while (ascii_iswhite(line1[idx1]))", "        ++idx1;", "  }"], "readability/increment"]
["src/nvim/ops.c", ["", "/*", " * Implementation of the format operator 'gq'."], "readability/old_style_comment"]
["src/nvim/ops.c", ["    oparg_T *oap,", "    int keep_cursor                        /* keep cursor on same text char */", ")"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /* Place the cursor where the \"gq\" or \"gw\" command was given, so that \"u\"", "   * can put it back there. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (u_save((linenr_T)(oap->start.lnum - 1),", "          (linenr_T)(oap->end.lnum + 1)) == FAIL)"], "readability/braces"]
["src/nvim/ops.c", ["  if (u_save((linenr_T)(oap->start.lnum - 1),", "          (linenr_T)(oap->end.lnum + 1)) == FAIL)", "    return;"], "whitespace/alignment"]
["src/nvim/ops.c", ["", "  if (oap->is_VIsual)", "    /* When there is no change: need to remove the Visual selection */"], "readability/braces"]
["src/nvim/ops.c", ["  if (oap->is_VIsual)", "    /* When there is no change: need to remove the Visual selection */", "    redraw_curbuf_later(INVERTED);"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /* Set '[ mark at the start of the formatted area */", "  curbuf->b_op_start = oap->start;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /* For \"gw\" remember the cursor position and put it back below (adjusted", "   * for joined and split lines). */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["   * for joined and split lines). */", "  if (keep_cursor)", "    saved_cursor = oap->cursor_start;"], "readability/braces"]
["src/nvim/ops.c", ["", "  /*", "   * Leave the cursor at the first non-blank of the last formatted line."], "readability/old_style_comment"]
["src/nvim/ops.c", ["   */", "  if (oap->end_adjusted && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)", "    ++curwin->w_cursor.lnum;"], "readability/braces"]
["src/nvim/ops.c", ["  if (oap->end_adjusted && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)", "    ++curwin->w_cursor.lnum;", "  beginline(BL_WHITE | BL_FIX);"], "readability/increment"]
["src/nvim/ops.c", ["", "  /* put '] mark on the end of the formatted area */", "  curbuf->b_op_end = curwin->w_cursor;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      if (wp->w_old_cursor_lnum != 0) {", "        /* When lines have been inserted or deleted, adjust the end of", "         * the Visual area to be redrawn. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Implementation of the format operator 'gq' for when using 'formatexpr'."], "readability/old_style_comment"]
["src/nvim/ops.c", ["{", "  if (oap->is_VIsual)", "    /* When there is no change: need to remove the Visual selection */"], "readability/braces"]
["src/nvim/ops.c", ["  if (oap->is_VIsual)", "    /* When there is no change: need to remove the Visual selection */", "    redraw_curbuf_later(INVERTED);"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (fex_format(oap->start.lnum, oap->line_count, NUL) != 0)", "    /* As documented: when 'formatexpr' returns non-zero fall back to"], "readability/braces"]
["src/nvim/ops.c", ["  if (fex_format(oap->start.lnum, oap->line_count, NUL) != 0)", "    /* As documented: when 'formatexpr' returns non-zero fall back to", "     * internal formatting. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["     * internal formatting. */", "    op_format(oap, FALSE);", "}"], "readability/bool"]
["src/nvim/ops.c", ["    long count,", "    int c                  /* character to be inserted */", ")"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Set v:lnum to the first line number and v:count to the number of lines."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Format \"line_count\" lines, starting at the cursor position."], "readability/old_style_comment"]
["src/nvim/ops.c", ["    linenr_T line_count,", "    int avoid_fex                          /* don't use 'formatexpr' */", ")"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  next_is_not_par = fmt_check_par(curwin->w_cursor.lnum", "      , &next_leader_len, &next_leader_flags, do_comments", "      );"], "whitespace/alignment"]
["src/nvim/ops.c", ["      , &next_leader_len, &next_leader_flags, do_comments", "      );", "  is_end_par = (is_not_par || next_is_not_par);"], "whitespace/alignment"]
["src/nvim/ops.c", ["      , &next_leader_len, &next_leader_flags, do_comments", "      );", "  is_end_par = (is_not_par || next_is_not_par);"], "whitespace/parens"]
["src/nvim/ops.c", ["  is_end_par = (is_not_par || next_is_not_par);", "  if (!is_end_par && do_trail_white)", "    is_end_par = !ends_in_white(curwin->w_cursor.lnum - 1);"], "readability/braces"]
["src/nvim/ops.c", ["  curwin->w_cursor.lnum--;", "  for (count = line_count; count != 0 && !got_int; --count) {", "    /*"], "readability/increment"]
["src/nvim/ops.c", ["  for (count = line_count; count != 0 && !got_int; --count) {", "    /*", "     * Advance to next paragraph."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /*", "     * The last line to be formatted."], "readability/old_style_comment"]
["src/nvim/ops.c", ["      next_is_not_par = fmt_check_par(curwin->w_cursor.lnum + 1", "          , &next_leader_len, &next_leader_flags, do_comments", "          );"], "whitespace/alignment"]
["src/nvim/ops.c", ["          , &next_leader_len, &next_leader_flags, do_comments", "          );", "      if (do_number_indent)"], "whitespace/alignment"]
["src/nvim/ops.c", ["          , &next_leader_len, &next_leader_flags, do_comments", "          );", "      if (do_number_indent)"], "whitespace/parens"]
["src/nvim/ops.c", ["          );", "      if (do_number_indent)", "        next_is_start_par ="], "readability/braces"]
["src/nvim/ops.c", ["    is_end_par = (is_not_par || next_is_not_par || next_is_start_par);", "    if (!is_end_par && do_trail_white)", "      is_end_par = !ends_in_white(curwin->w_cursor.lnum);"], "readability/braces"]
["src/nvim/ops.c", ["", "    /*", "     * Skip lines that are not in a paragraph."], "readability/old_style_comment"]
["src/nvim/ops.c", ["    if (is_not_par) {", "      if (line_count < 0)", "        break;"], "readability/braces"]
["src/nvim/ops.c", ["    } else {", "      /*", "       * For the first line of a paragraph, check indent of second line."], "readability/old_style_comment"]
["src/nvim/ops.c", ["          if (leader_len == 0 && next_leader_len == 0) {", "            /* no comment found */", "            second_indent ="], "readability/old_style_comment"]
["src/nvim/ops.c", ["          if (leader_len == 0 && next_leader_len == 0) {", "            /* no comment found */", "            second_indent ="], "readability/old_style_comment"]
["src/nvim/ops.c", ["          } else {", "            /* get_number_indent() is now \"comment aware\"... */", "            second_indent ="], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      /*", "       * When the comment leader changes, it's the end of the paragraph."], "readability/old_style_comment"]
["src/nvim/ops.c", ["       */", "      if (curwin->w_cursor.lnum >= curbuf->b_ml.ml_line_count", "          || !same_leader(curwin->w_cursor.lnum,"], "readability/braces"]
["src/nvim/ops.c", ["          || !same_leader(curwin->w_cursor.lnum,", "              leader_len, leader_flags,", "              next_leader_len, next_leader_flags)"], "whitespace/alignment"]
["src/nvim/ops.c", ["              leader_len, leader_flags,", "              next_leader_len, next_leader_flags)", "          )"], "whitespace/alignment"]
["src/nvim/ops.c", ["          || !same_leader(curwin->w_cursor.lnum,", "              leader_len, leader_flags,", "              next_leader_len, next_leader_flags)"], "whitespace/alignment"]
["src/nvim/ops.c", ["              leader_len, leader_flags,", "              next_leader_len, next_leader_flags)", "          )"], "whitespace/alignment"]
["src/nvim/ops.c", ["", "      /*", "       * If we have got to the end of a paragraph, or the line is"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      if (is_end_par || force_format) {", "        if (need_set_indent)", "          /* replace indent in first line with minimal number of"], "readability/braces"]
["src/nvim/ops.c", ["        if (need_set_indent)", "          /* replace indent in first line with minimal number of", "           * tabs and spaces, according to current options */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "        /* do the formatting, without 'showmode' */", "        State = INSERT;         /* for open_line() */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        /* do the formatting, without 'showmode' */", "        State = INSERT;         /* for open_line() */", "        smd_save = p_smd;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        smd_save = p_smd;", "        p_smd = FALSE;", "        insertchar(NUL, INSCHAR_FORMAT"], "readability/bool"]
["src/nvim/ops.c", ["        insertchar(NUL, INSCHAR_FORMAT", "            + (do_comments ? INSCHAR_DO_COM : 0)", "            + (do_comments && do_comments_list"], "whitespace/alignment"]
["src/nvim/ops.c", ["            + (do_comments ? INSCHAR_DO_COM : 0)", "            + (do_comments && do_comments_list", "               ? INSCHAR_COM_LIST : 0)"], "whitespace/alignment"]
["src/nvim/ops.c", ["               ? INSCHAR_COM_LIST : 0)", "            + (avoid_fex ? INSCHAR_NO_FEX : 0), second_indent);", "        State = old_State;"], "whitespace/alignment"]
["src/nvim/ops.c", ["        second_indent = -1;", "        /* at end of par.: need to set indent of next par. */", "        need_set_indent = is_end_par;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        if (is_end_par) {", "          /* When called with a negative line count, break at the", "           * end of the paragraph. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["           * end of the paragraph. */", "          if (line_count < 0)", "            break;"], "readability/braces"]
["src/nvim/ops.c", ["", "      /*", "       * When still in same paragraph, join the lines together.  But"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        curwin->w_cursor.col = 0;", "        if (line_count < 0 && u_save_cursor() == FAIL)", "          break;"], "readability/braces"]
["src/nvim/ops.c", ["        curwin->w_cursor.lnum--;", "        if (do_join(2, TRUE, FALSE, FALSE, false) == FAIL) {", "          beep_flush();"], "readability/bool"]
["src/nvim/ops.c", ["", "/*", " * Return TRUE if line \"lnum\" ends in a white character."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (*s == NUL)", "    return FALSE;"], "readability/braces"]
["src/nvim/ops.c", ["  if (*s == NUL)", "    return FALSE;", "  l = STRLEN(s) - 1;"], "readability/bool"]
["src/nvim/ops.c", ["", "/*", " * Blank lines, and lines containing only the comment leader, are left"], "readability/old_style_comment"]
["src/nvim/ops.c", [" */", "static int fmt_check_par(linenr_T lnum, int *leader_len, char_u **leader_flags, int do_comments)", "{"], "whitespace/line_length"]
["src/nvim/ops.c", ["{", "  char_u      *flags = NULL;        /* init for GCC */", "  char_u      *ptr;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  ptr = ml_get(lnum);", "  if (do_comments)", "    *leader_len = get_leader_len(ptr, leader_flags, FALSE, TRUE);"], "readability/braces"]
["src/nvim/ops.c", ["  if (do_comments)", "    *leader_len = get_leader_len(ptr, leader_flags, FALSE, TRUE);", "  else"], "readability/bool"]
["src/nvim/ops.c", ["    *leader_len = get_leader_len(ptr, leader_flags, FALSE, TRUE);", "  else", "    *leader_len = 0;"], "readability/braces"]
["src/nvim/ops.c", ["  if (*leader_len > 0) {", "    /*", "     * Search for 'e' flag in comment leader flags."], "readability/old_style_comment"]
["src/nvim/ops.c", ["    flags = *leader_flags;", "    while (*flags && *flags != ':' && *flags != COM_END)", "      ++flags;"], "readability/braces"]
["src/nvim/ops.c", ["    while (*flags && *flags != ':' && *flags != COM_END)", "      ++flags;", "  }"], "readability/increment"]
["src/nvim/ops.c", ["         || (*leader_len > 0 && *flags == COM_END)", "         || startPS(lnum, NUL, FALSE);", "}"], "readability/bool"]
["src/nvim/ops.c", ["", "/*", " * Return TRUE when a paragraph starts in line \"lnum\".  Return FALSE when the"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (lnum <= 1)", "    return TRUE;                /* start of the file */"], "readability/braces"]
["src/nvim/ops.c", ["  if (lnum <= 1)", "    return TRUE;                /* start of the file */", ""], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (lnum <= 1)", "    return TRUE;                /* start of the file */", ""], "readability/bool"]
["src/nvim/ops.c", ["  p = ml_get(lnum - 1);", "  if (*p == NUL)", "    return TRUE;                /* after empty line */"], "readability/braces"]
["src/nvim/ops.c", ["  if (*p == NUL)", "    return TRUE;                /* after empty line */", ""], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (*p == NUL)", "    return TRUE;                /* after empty line */", ""], "readability/bool"]
["src/nvim/ops.c", ["", "  if (has_format_option(FO_WHITE_PAR) && !ends_in_white(lnum - 1))", "    return TRUE;                /* missing trailing space in previous line. */"], "readability/braces"]
["src/nvim/ops.c", ["  if (has_format_option(FO_WHITE_PAR) && !ends_in_white(lnum - 1))", "    return TRUE;                /* missing trailing space in previous line. */", ""], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (has_format_option(FO_WHITE_PAR) && !ends_in_white(lnum - 1))", "    return TRUE;                /* missing trailing space in previous line. */", ""], "readability/bool"]
["src/nvim/ops.c", ["", "  if (has_format_option(FO_Q_NUMBER) && (get_number_indent(lnum) > 0))", "    return TRUE;                /* numbered item starts in \"lnum\". */"], "readability/braces"]
["src/nvim/ops.c", ["  if (has_format_option(FO_Q_NUMBER) && (get_number_indent(lnum) > 0))", "    return TRUE;                /* numbered item starts in \"lnum\". */", ""], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (has_format_option(FO_Q_NUMBER) && (get_number_indent(lnum) > 0))", "    return TRUE;                /* numbered item starts in \"lnum\". */", ""], "readability/bool"]
["src/nvim/ops.c", ["", "  if (!same_leader(lnum - 1, leader_len, leader_flags,", "          next_leader_len, next_leader_flags))"], "readability/braces"]
["src/nvim/ops.c", ["  if (!same_leader(lnum - 1, leader_len, leader_flags,", "          next_leader_len, next_leader_flags))", "    return TRUE;                /* change of comment leader. */"], "whitespace/alignment"]
["src/nvim/ops.c", ["          next_leader_len, next_leader_flags))", "    return TRUE;                /* change of comment leader. */", ""], "readability/old_style_comment"]
["src/nvim/ops.c", ["          next_leader_len, next_leader_flags))", "    return TRUE;                /* change of comment leader. */", ""], "readability/bool"]
["src/nvim/ops.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ops.c", ["", "/*", " * prepare a few things for block mode yank/delete/tilde"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  while (bdp->start_vcol < oap->start_vcol && *pstart) {", "    /* Count a tab for what it's worth (if list mode not on) */", "    incr = lbr_chartabsize(line, pstart, (colnr_T)bdp->start_vcol);"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  bdp->start_char_vcols = incr;", "  if (bdp->start_vcol < oap->start_vcol) {      /* line too short */", "    bdp->end_vcol = bdp->start_vcol;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  } else {", "    /* notice: this converts partly selected Multibyte characters to", "     * spaces, too. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    bdp->startspaces = bdp->start_vcol - oap->start_vcol;", "    if (is_del && bdp->startspaces)", "      bdp->startspaces = bdp->start_char_vcols - bdp->startspaces;"], "readability/braces"]
["src/nvim/ops.c", ["        if (is_del && oap->op_type != OP_LSHIFT) {", "          /* just putting the sum of those two into", "           * bdp->startspaces doesn't work for Visual replace,"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      while (bdp->end_vcol <= oap->end_vcol && *pend != NUL) {", "        /* Count a tab for what it's worth (if list mode not on) */", "        prev_pend = pend;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["          bdp->endspaces = incr - bdp->endspaces;", "          if (pend != pstart)", "            pend = prev_pend;"], "readability/braces"]
["src/nvim/ops.c", ["    bdp->end_char_vcols = incr;", "    if (is_del && bdp->startspaces)", "      pstart = prev_pstart;"], "readability/braces"]
["src/nvim/ops.c", ["  }", "  bdp->textcol = (colnr_T) (pstart - line);", "  bdp->textstart = pstart;"], "whitespace/cast"]
["src/nvim/ops.c", ["", "/*", " * Return the type of a register."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (regname == '@')       /* \"@@\" is used for unnamed register */", "    regname = '\"';"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (regname == '@')       /* \"@@\" is used for unnamed register */", "    regname = '\"';"], "readability/braces"]
["src/nvim/ops.c", ["", "  /* check for valid regname */", "  if (regname != NUL && !valid_yank_reg(regname, false))"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  /* check for valid regname */", "  if (regname != NUL && !valid_yank_reg(regname, false))", "    return NULL;"], "readability/braces"]
["src/nvim/ops.c", ["  yankreg_T *reg = get_yank_register(regname, YREG_PASTE);", "  if (reg->y_array == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/ops.c", ["", "  /*", "   * Compute length of resulting string."], "readability/old_style_comment"]
["src/nvim/ops.c", ["    len += STRLEN(reg->y_array[i]);", "    /*", "     * Insert a newline between lines and after last line if"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Copy the lines of the yank register into the string."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /*", "     * Insert a NL between lines and after the last line if y_type is"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "static yankreg_T *init_write_reg(int name, yankreg_T **old_y_previous, bool must_append)", "{"], "whitespace/line_length"]
["src/nvim/ops.c", ["", "static void finish_write_reg(int name, yankreg_T *reg, yankreg_T *old_y_previous)", "{"], "whitespace/line_length"]
["src/nvim/ops.c", ["  if (len < 0) {", "    len = (ssize_t) STRLEN(str);", "  }"], "whitespace/cast"]
["src/nvim/ops.c", ["", "  /* Special case: '/' search pattern */", "  if (name == '/') {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (name == '/') {", "    set_last_search_pat(str, RE_SEARCH, TRUE, TRUE);", "    return;"], "readability/bool"]
["src/nvim/ops.c", ["    size_t offset = 0;", "    size_t totlen = (size_t) len;", ""], "whitespace/cast"]
["src/nvim/ops.c", ["  if (str_list) {", "    for (char_u **ss = (char_u **) str; *ss != NULL; ++ss) {", "      newlines++;"], "whitespace/cast"]
["src/nvim/ops.c", ["  if (str_list) {", "    for (char_u **ss = (char_u **) str; *ss != NULL; ++ss) {", "      newlines++;"], "readability/increment"]
["src/nvim/ops.c", ["      extraline = 1;", "      ++newlines;         // count extra newline at the end", "    }"], "readability/increment"]
["src/nvim/ops.c", ["      append = true;", "      --newlines;         // uncount newline when appending first line", "    }"], "readability/increment"]
["src/nvim/ops.c", ["  if (str_list) {", "    for (char_u **ss = (char_u **) str; *ss != NULL; ++ss, ++lnum) {", "      size_t ss_len = STRLEN(*ss);"], "whitespace/cast"]
["src/nvim/ops.c", ["  if (str_list) {", "    for (char_u **ss = (char_u **) str; *ss != NULL; ++ss, ++lnum) {", "      size_t ss_len = STRLEN(*ss);"], "readability/increment"]
["src/nvim/ops.c", ["  if (yank_type == kMTBlockWise) {", "    y_ptr->y_width = (blocklen == -1 ? (colnr_T) maxlen - 1 : blocklen);", "  } else {"], "whitespace/cast"]
["src/nvim/ops.c", ["", "/*", " *  Count the number of bytes, characters and \"words\" in a line."], "readability/old_style_comment"]
["src/nvim/ops.c", ["      }", "    } else if (!ascii_isspace(line[i]))", "      is_word = 1;"], "readability/braces"]
["src/nvim/ops.c", ["      is_word = 1;", "    ++chars;", "    i += (*mb_ptr2len)(line + i);"], "readability/increment"]
["src/nvim/ops.c", ["", "  if (is_word)", "    words++;"], "readability/braces"]
["src/nvim/ops.c", ["", "  /* Add eol_size if the end of line was reached before hitting limit. */", "  if (i < limit && line[i] == NUL) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  } else {", "    if (get_fileformat(curbuf) == EOL_DOS)", "      eol_size = 2;"], "readability/braces"]
["src/nvim/ops.c", ["      eol_size = 2;", "    else", "      eol_size = 1;"], "readability/braces"]
["src/nvim/ops.c", ["      }", "      if (*p_sel == 'e' && max_pos.col > 0)", "        --max_pos.col;"], "readability/braces"]
["src/nvim/ops.c", ["      if (*p_sel == 'e' && max_pos.col > 0)", "        --max_pos.col;", ""], "readability/increment"]
["src/nvim/ops.c", ["", "        /* Make 'sbr' empty for a moment to get the correct size. */", "        p_sbr = empty_option;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        getvcols(curwin, &min_pos, &max_pos,", "            &oparg.start_vcol, &oparg.end_vcol);", "        p_sbr = saved_sbr;"], "whitespace/alignment"]
["src/nvim/ops.c", ["        p_sbr = saved_sbr;", "        if (curwin->w_curswant == MAXCOL)", "          oparg.end_vcol = MAXCOL;"], "readability/braces"]
["src/nvim/ops.c", ["          oparg.end_vcol = MAXCOL;", "        /* Swap the start, end vcol if needed */", "        if (oparg.end_vcol < oparg.start_vcol) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum) {", "      /* Check for a CTRL-C every 100000 characters. */"], "readability/increment"]
["src/nvim/ops.c", ["    for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum) {", "      /* Check for a CTRL-C every 100000 characters. */", "      if (byte_count > last_check) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        os_breakcheck();", "        if (got_int)", "          return;"], "readability/braces"]
["src/nvim/ops.c", ["", "      /* Do extra processing for VIsual mode. */", "      if (l_VIsual_active"], "readability/old_style_comment"]
["src/nvim/ops.c", ["          byte_count_cursor += line_count_info(s, &word_count_cursor,", "              &char_count_cursor, len, eol_size);", "          if (lnum == curbuf->b_ml.ml_line_count"], "whitespace/alignment"]
["src/nvim/ops.c", ["              &char_count_cursor, len, eol_size);", "          if (lnum == curbuf->b_ml.ml_line_count", "              && !curbuf->b_p_eol"], "readability/braces"]
["src/nvim/ops.c", ["      } else {", "        /* In non-visual mode, check for the line the cursor is on */", "        if (lnum == curwin->w_cursor.lnum) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["///", "/// @returns the name of of a clipboard register that should be used, or `NUL` if none.", "int get_default_register_name(void)"], "whitespace/line_length"]
["src/nvim/ops.c", ["", "  if (reg->y_size > 0 && strlen((char*)reg->y_array[reg->y_size-1]) == 0) {", "    // a known-to-be charwise yank might have a final linebreak"], "whitespace/operators"]
["src/nvim/ops.c", ["    if (!reg_empty(iter_reg)) {", "      return (void *) iter_reg;", "    }"], "whitespace/cast"]
["src/nvim/ops.h", ["#include \"nvim/os/time.h\"", "#include \"nvim/normal.h\" // for MotionType and oparg_T", "#include \"nvim/ex_cmds_defs.h\" // for exarg_T"], "whitespace/comments"]
["src/nvim/ops.h", ["#include \"nvim/normal.h\" // for MotionType and oparg_T", "#include \"nvim/ex_cmds_defs.h\" // for exarg_T", ""], "whitespace/comments"]
["src/nvim/ops.h", ["", "/* flags for do_put() */", "#define PUT_FIXINDENT    1      /* make indent look nice */"], "readability/old_style_comment"]
["src/nvim/ops.h", ["/* flags for do_put() */", "#define PUT_FIXINDENT    1      /* make indent look nice */", "#define PUT_CURSEND      2      /* leave cursor after end of new text */"], "readability/old_style_comment"]
["src/nvim/ops.h", ["#define PUT_FIXINDENT    1      /* make indent look nice */", "#define PUT_CURSEND      2      /* leave cursor after end of new text */", "#define PUT_CURSLINE     4      /* leave cursor on last line of new text */"], "readability/old_style_comment"]
["src/nvim/ops.h", ["#define PUT_CURSEND      2      /* leave cursor after end of new text */", "#define PUT_CURSLINE     4      /* leave cursor on last line of new text */", "#define PUT_LINE         8      /* put register as lines */"], "readability/old_style_comment"]
["src/nvim/ops.h", ["#define PUT_CURSLINE     4      /* leave cursor on last line of new text */", "#define PUT_LINE         8      /* put register as lines */", "#define PUT_LINE_SPLIT   16     /* split line for linewise register */"], "readability/old_style_comment"]
["src/nvim/ops.h", ["#define PUT_LINE         8      /* put register as lines */", "#define PUT_LINE_SPLIT   16     /* split line for linewise register */", "#define PUT_LINE_FORWARD 32     /* put linewise register below Visual sel. */"], "readability/old_style_comment"]
["src/nvim/ops.h", ["#define PUT_LINE_SPLIT   16     /* split line for linewise register */", "#define PUT_LINE_FORWARD 32     /* put linewise register below Visual sel. */", ""], "readability/old_style_comment"]
["src/nvim/ops.h", ["", "/*", " * Registers:"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "/*", " * The options that are local to a window or buffer have \"indir\" set to one of"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "/*", " * Options local to a window have a value local to a buffer and global to all"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "/*", " * These are the global values for options which are also local to a buffer."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "/*", " * Flags"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "/*", " * options[] is initialized here."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * Find default value for 'shell' option."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * Set the default for 'backupskip' to include environment variables for"], "readability/old_style_comment"]
["src/nvim/option.c", ["# ifdef UNIX", "    static char     *(names[4]) = {\"\", \"TMPDIR\", \"TEMP\", \"TMP\"};", "# else"], "whitespace/braces"]
["src/nvim/option.c", ["# ifdef UNIX", "    static char     *(names[4]) = {\"\", \"TMPDIR\", \"TEMP\", \"TMP\"};", "# else"], "whitespace/braces"]
["src/nvim/option.c", ["# else", "    static char     *(names[3]) = {\"TMPDIR\", \"TEMP\", \"TMP\"};", "# endif"], "whitespace/braces"]
["src/nvim/option.c", ["# else", "    static char     *(names[3]) = {\"TMPDIR\", \"TEMP\", \"TMP\"};", "# endif"], "whitespace/braces"]
["src/nvim/option.c", ["        mustfree = false;", "      } else", "# endif"], "readability/braces"]
["src/nvim/option.c", ["      }", "      if(mustfree) {", "        xfree(p);"], "whitespace/parens"]
["src/nvim/option.c", ["                     \"system(['lpr'] \"", "                            \"+ (empty(&printdevice)?[]:['-P', &printdevice]) \"", "                            \"+ [v:fname_in])\""], "whitespace/alignment"]
["src/nvim/option.c", ["                            \"+ (empty(&printdevice)?[]:['-P', &printdevice]) \"", "                            \"+ [v:fname_in])\"", "                     \". delete(v:fname_in)\""], "whitespace/alignment"]
["src/nvim/option.c", ["                     \"system(['copy', v:fname_in, \"", "                             \"empty(&printdevice)?'LPT1':&printdevice])\"", "                     \". delete(v:fname_in)\","], "whitespace/alignment"]
["src/nvim/option.c", ["", "  /*", "   * Set all the options (except the terminal options) to their default"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * Expand environment variables and things like \"~\" for the defaults."], "readability/old_style_comment"]
["src/nvim/option.c", ["    } else {", "      p = (char *) option_expand(opt_idx, NULL);", "    }"], "whitespace/cast"]
["src/nvim/option.c", ["      *(char **)options[opt_idx].var = p;", "      /* VIMEXP", "       * Defaults for all expanded options are currently the same for Vi"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /* Detect use of mlterm.", "   * Mlterm is a terminal emulator akin to xterm that has some special"], "readability/old_style_comment"]
["src/nvim/option.c", ["    if (flags & P_STRING) {", "      /* Use set_string_option_direct() for local options to handle", "       * freeing and allocating the value. */"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * 'window' is only for backwards compatibility with Vi."], "readability/old_style_comment"]
["src/nvim/option.c", ["    if (       fnamecmp(p, \"csh\") == 0", "               || fnamecmp(p, \"tcsh\") == 0", "               ) {"], "whitespace/alignment"]
["src/nvim/option.c", ["               || fnamecmp(p, \"tcsh\") == 0", "               ) {", "      if (do_sp) {"], "whitespace/alignment"]
["src/nvim/option.c", ["    } else if (       fnamecmp(p, \"sh\") == 0", "                      || fnamecmp(p, \"ksh\") == 0", "                      || fnamecmp(p, \"mksh\") == 0"], "whitespace/alignment"]
["src/nvim/option.c", ["                      || fnamecmp(p, \"ksh\") == 0", "                      || fnamecmp(p, \"mksh\") == 0", "                      || fnamecmp(p, \"pdksh\") == 0"], "whitespace/alignment"]
["src/nvim/option.c", ["                      || fnamecmp(p, \"mksh\") == 0", "                      || fnamecmp(p, \"pdksh\") == 0", "                      || fnamecmp(p, \"zsh\") == 0"], "whitespace/alignment"]
["src/nvim/option.c", ["                      || fnamecmp(p, \"pdksh\") == 0", "                      || fnamecmp(p, \"zsh\") == 0", "                      || fnamecmp(p, \"zsh-beta\") == 0"], "whitespace/alignment"]
["src/nvim/option.c", ["                      || fnamecmp(p, \"zsh\") == 0", "                      || fnamecmp(p, \"zsh-beta\") == 0", "                      || fnamecmp(p, \"bash\") == 0"], "whitespace/alignment"]
["src/nvim/option.c", ["                      || fnamecmp(p, \"zsh-beta\") == 0", "                      || fnamecmp(p, \"bash\") == 0", "                      || fnamecmp(p, \"fish\") == 0"], "whitespace/alignment"]
["src/nvim/option.c", ["                      || fnamecmp(p, \"bash\") == 0", "                      || fnamecmp(p, \"fish\") == 0", "                      ) {"], "whitespace/alignment"]
["src/nvim/option.c", ["                      || fnamecmp(p, \"fish\") == 0", "                      ) {", "      if (do_sp) {"], "whitespace/alignment"]
["src/nvim/option.c", ["", "  /*", "   * If GUI is (going to be) used, we can always set the window title and"], "readability/old_style_comment"]
["src/nvim/option.c", ["        && !(opt_flags & OPT_MODELINE)) {", "      /*", "       * \":set all\"  show all options."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "      /* Skip all options that are not window-local (used when showing", "       * an already loaded buffer in a window). */"], "readability/old_style_comment"]
["src/nvim/option.c", ["       * an already loaded buffer in a window). */", "      if ((opt_flags & OPT_WINONLY)", "          && (opt_idx < 0 || options[opt_idx].var != VAR_WIN))"], "readability/braces"]
["src/nvim/option.c", ["", "      /*", "       * allow '=' and ':' as MSDOS command.com allows only one"], "readability/old_style_comment"]
["src/nvim/option.c", ["              && !(flags & P_BOOL))) {", "        /*", "         * print value"], "readability/old_style_comment"]
["src/nvim/option.c", ["        }", "        if (nextchar != '?'", "            && nextchar != NUL && !ascii_iswhite(afterchar))"], "readability/braces"]
["src/nvim/option.c", ["", "          /*", "           * \":set opt!\": invert"], "readability/old_style_comment"]
["src/nvim/option.c", ["          } else {", "            /*", "             * \":set invopt\": invert"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "            /* When using \":set opt=val\" for a global option", "             * with a local value the local value will be"], "readability/old_style_comment"]
["src/nvim/option.c", ["             * reset, use the global value here. */", "            if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0", "                && ((int)options[opt_idx].indir & PV_BOTH))"], "readability/braces"]
["src/nvim/option.c", ["", "            /* The old value is kept until we are sure that the", "             * new value is valid. */"], "readability/old_style_comment"]
["src/nvim/option.c", ["              newval = options[opt_idx].def_val[", "                ((flags & P_VI_DEF) || cp_val)", "                ?  VI_DEFAULT : VIM_DEFAULT];"], "whitespace/indent"]
["src/nvim/option.c", ["                ((flags & P_VI_DEF) || cp_val)", "                ?  VI_DEFAULT : VIM_DEFAULT];", "              /* expand environment variables and ~ (since the"], "whitespace/indent"]
["src/nvim/option.c", ["                ?  VI_DEFAULT : VIM_DEFAULT];", "              /* expand environment variables and ~ (since the", "               * default value was already expanded, only"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "              /*", "               * Set 'keywordprg' to \":help\" if an empty"], "readability/old_style_comment"]
["src/nvim/option.c", ["              }", "              /*", "               * Convert 'backspace' number to string, for"], "readability/old_style_comment"]
["src/nvim/option.c", ["               */", "              else if (varp == (char_u *)&p_bs", "                       && ascii_isdigit(**(char_u **)varp)) {"], "whitespace/newline"]
["src/nvim/option.c", ["              }", "              /*", "               * Convert 'whichwrap' number to string, for"], "readability/old_style_comment"]
["src/nvim/option.c", ["               */", "              else if (varp == (char_u *)&p_ww", "                       && ascii_isdigit(*arg)) {"], "whitespace/newline"]
["src/nvim/option.c", ["              }", "              /*", "               * Remove '>' before 'dir' and 'bdir', for"], "readability/old_style_comment"]
["src/nvim/option.c", ["               */", "              else if (  *arg == '>'", "                         && (varp == (char_u *)&p_dir"], "whitespace/newline"]
["src/nvim/option.c", ["              else if (  *arg == '>'", "                         && (varp == (char_u *)&p_dir", "                             || varp == (char_u *)&p_bdir)) {"], "whitespace/alignment"]
["src/nvim/option.c", ["", "              /*", "               * Copy the new string into allocated memory."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "              /*", "               * Copy the string, skip over escaped chars."], "readability/old_style_comment"]
["src/nvim/option.c", ["              while (*arg && !ascii_iswhite(*arg)) {", "                if (*arg == '\\\\' && arg[1] != NUL", "#ifdef BACKSLASH_IN_FILENAME"], "readability/braces"]
["src/nvim/option.c", ["", "              /*", "               * Expand environment variables and ~."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "              /* locate newval[] in origval[] when removing it", "               * and when adding to avoid duplicates */"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "              /* concatenate the two strings; add a ',' if", "               * needed */"], "readability/old_style_comment"]
["src/nvim/option.c", ["                  memmove(newval + i + comma, newval,", "                      STRLEN(newval) + 1);", "                  memmove(newval, origval, (size_t)i);"], "whitespace/alignment"]
["src/nvim/option.c", ["", "              /* Remove newval[] from origval[]. (Note: \"i\" has", "               * been set above and is used here). */"], "readability/old_style_comment"]
["src/nvim/option.c", ["skip:", "      /*", "       * Advance to next argument."], "readability/old_style_comment"]
["src/nvim/option.c", ["  return OK;", "}", ""], "readability/fn_size"]
["src/nvim/option.c", ["", "  /* When an option is set in the sandbox, from a modeline or in secure mode", "   * set the P_INSECURE flag.  Otherwise, if a new value is stored reset the"], "readability/old_style_comment"]
["src/nvim/option.c", ["{", "  /*", "   * The option values that are changed when 'bin' changes are"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * Expanding this with NameBuff, expand_env() must not be passed IObuff."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  assert((void *) options[idx].var != (void *) &p_shada);", ""], "whitespace/cast"]
["src/nvim/option.c", ["", "    /* When setting both values of a global option with a local value,", "    * make the local value empty, so that the global value is used. */"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /* Get the global option to compare with, otherwise we would have to check", "   * two values for all local options. */"], "readability/old_style_comment"]
["src/nvim/option.c", ["      }", "    } else", "      errmsg = e_invarg;"], "readability/braces"]
["src/nvim/option.c", ["      ml_setflags(curbuf);", "      /* Redraw needed when switching to/from \"mac\": a CR in the text", "       * will be displayed differently. */"], "readability/old_style_comment"]
["src/nvim/option.c", ["            errmsg = errbuf;", "          } else", "            errmsg = (char_u *)\"\";"], "readability/braces"]
["src/nvim/option.c", ["    for (s = *varp; *s; ) {", "      while (*s == ',' || *s == ' ')", "        s++;"], "readability/braces"]
["src/nvim/option.c", ["            errmsg = errbuf;", "          } else", "            errmsg = (char_u *)\"\";"], "readability/braces"]
["src/nvim/option.c", ["", "  /*", "   * If error detected, restore the previous value."], "readability/old_style_comment"]
["src/nvim/option.c", ["    *varp = oldval;", "    /*", "     * When resetting some values, need to act on it."], "readability/old_style_comment"]
["src/nvim/option.c", ["        && ((int)options[opt_idx].indir & PV_BOTH)) {", "      /* global option with local value set to use global value; free", "       * the local value and make it empty */"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "    /*", "     * Trigger the autocommand only after setting the flags."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "      /*", "       * Source the spell/LANG.vim in 'runtimepath'."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  if (curwin->w_curswant != MAXCOL", "      && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0)"], "readability/braces"]
["src/nvim/option.c", ["    wp->w_p_cc_cols = xmalloc(sizeof(int) * (count + 1));", "    /* sort the columns for faster usage on screen redraw inside", "     * win_line() */"], "readability/old_style_comment"]
["src/nvim/option.c", ["      s++;", "      while (*s && ascii_isdigit(*s))", "        s++;"], "readability/braces"]
["src/nvim/option.c", ["      s++;", "      while (*s != '}' && *s)", "        s++;"], "readability/braces"]
["src/nvim/option.c", ["#ifdef BACKSLASH_IN_FILENAME", "  else if ((int *)varp == &p_ssl) {", "    if (p_ssl) {"], "readability/braces"]
["src/nvim/option.c", ["#endif", "  else if ((int *)varp == &curwin->w_p_wrap) {", "    // If 'wrap' is set, set w_leftcol to zero."], "readability/braces"]
["src/nvim/option.c", ["    if (curwin->w_p_arab) {", "      /*", "       * 'arabic' is set, handle various sub-settings."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "      /* Arabic requires a utf-8 encoding, inform the user if its not", "       * set. */"], "readability/old_style_comment"]
["src/nvim/option.c", ["    } else {", "      /*", "       * 'arabic' is reset, handle various sub-settings."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "        /* 'arabicshape' isn't reset, it is a global option and", "         * another window may still need it \"on\". */"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "      /* 'delcombine' isn't reset, it is a global option and another", "       * window may still want it \"on\". */"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * End of handling side effects for bool options."], "readability/old_style_comment"]
["src/nvim/option.c", ["    apply_autocmds(EVENT_OPTIONSET,", "                   (char_u *) options[opt_idx].fullname,", "                   NULL, false, NULL);"], "whitespace/cast"]
["src/nvim/option.c", ["      vim_snprintf((char *)errbuf, errbuflen,", "          _(\"E593: Need at least %d lines\"), min_rows());", "      errmsg = errbuf;"], "whitespace/alignment"]
["src/nvim/option.c", ["      vim_snprintf((char *)errbuf, errbuflen,", "          _(\"E594: Need at least %d columns\"), MIN_COLUMNS);", "      errmsg = errbuf;"], "whitespace/alignment"]
["src/nvim/option.c", ["    apply_autocmds(EVENT_OPTIONSET,", "                   (char_u *) options[opt_idx].fullname,", "                   NULL, false, NULL);"], "whitespace/cast"]
["src/nvim/option.c", ["    p = options[0].fullname;", "    for (short int i = 1; (s = options[i].fullname) != NULL; i++) {", "      if (s[0] != p[0]) {"], "runtime/int"]
["src/nvim/option.c", ["    } else if (p->flags & P_NUM) {", "      *numval = *(long *) varp;", "    } else {"], "whitespace/cast"]
["src/nvim/option.c", ["", "    /*", "     * display the items"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * Some options are never written:"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "        /* Do not store options like 'bufhidden' and 'syntax' in a vimrc", "         * file, they are always buffer-specific. */"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "        /* Round 1: fresh value for window-local options.", "         * Round 2: other values */"], "readability/old_style_comment"]
["src/nvim/option.c", ["  if (*valuep != NULL) {", "    /* Output 'pastetoggle' as key names.  For other", "     * options some characters have to be escaped with"], "readability/old_style_comment"]
["src/nvim/option.c", ["  switch ((int)p->indir)", "  {", "    // global option with local value: use local value if it's been set"], "whitespace/braces"]
["src/nvim/option.c", ["", "  /*", "   * Skip this when the option defaults have not been set yet.  Happens when"], "readability/old_style_comment"]
["src/nvim/option.c", ["    if (should_copy || (flags & BCO_ALWAYS)) {", "      /* Don't copy the options specific to a help buffer when", "      * BCO_NOHELP is given or the options were initialized already"], "readability/old_style_comment"]
["src/nvim/option.c", ["      buf->b_kmap_state |= KEYMAP_INIT;", "      /* This isn't really an option, but copying the langmap and IME", "      * state from the current buffer is better than resetting it. */"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "      /* options that are normally global but also have a local value", "       * are not copied, start using the global value */"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "      /*", "       * Don't copy the options set by ex_help(), use the saved values,"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "    /*", "     * When the options should be copied (ignoring BCO_ALWAYS), set the"], "readability/old_style_comment"]
["src/nvim/option.c", ["static int expand_option_idx = -1;", "static char_u expand_option_name[5] = {'t', '_', NUL, NUL, NUL};", "static int expand_option_flags = 0;"], "whitespace/braces"]
["src/nvim/option.c", ["static int expand_option_idx = -1;", "static char_u expand_option_name[5] = {'t', '_', NUL, NUL, NUL};", "static int expand_option_flags = 0;"], "whitespace/braces"]
["src/nvim/option.c", ["      xp->xp_context = EXPAND_DIRECTORIES;", "      if (p == (char_u *)&p_path", "          || p == (char_u *)&p_cdpath"], "readability/braces"]
["src/nvim/option.c", ["        xp->xp_backslash = XP_BS_THREE;", "      else", "        xp->xp_backslash = XP_BS_ONE;"], "readability/braces"]
["src/nvim/option.c", ["", "  /* For an option that is a list of file names, find the start of the", "   * last file name. */"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "int ExpandSettings(expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file)", "{"], "whitespace/line_length"]
["src/nvim/option.c", ["", "  /* do this loop twice:", "   * loop == 0: count the number of matching options"], "readability/old_style_comment"]
["src/nvim/option.c", ["    }", "    for (size_t opt_idx = 0; (str = (char_u *)options[opt_idx].fullname) != NULL;", "         opt_idx++) {"], "whitespace/line_length"]
["src/nvim/option.c", ["          num_normal++;", "        } else", "          (*file)[count++] = vim_strsave(str);"], "readability/braces"]
["src/nvim/option.c", ["", "  /*", "   * For a terminal key code expand_option_idx is < 0."], "readability/old_style_comment"]
["src/nvim/option.c", ["#ifdef BACKSLASH_IN_FILENAME", "  /* For MS-Windows et al. we don't double backslashes at the start and", "   * before a file name character. */"], "readability/old_style_comment"]
["src/nvim/option.c", ["               \"%\" PRId64,", "               (int64_t)*(long *)varp);", "    }"], "whitespace/operators"]
["src/nvim/option.c", ["        EMSG2(_(\"E357: 'langmap': Matching character missing for %s\"),", "            transchar(from));", "        return;"], "whitespace/alignment"]
["src/nvim/option.c", ["              EMSG2(_(", "                      \"E358: 'langmap': Extra characters after semicolon: %s\"),", "                  p);"], "whitespace/indent"]
["src/nvim/option.c", ["                      \"E358: 'langmap': Extra characters after semicolon: %s\"),", "                  p);", "              return;"], "whitespace/alignment"]
["src/nvim/option.c", ["  if (p_paste) {", "    /*", "     * Paste switched from off to on."], "readability/old_style_comment"]
["src/nvim/option.c", ["  char_u *p = wp->w_p_briopt;", "  while (*p != NUL)", "  {"], "readability/braces"]
["src/nvim/option.c", ["  while (*p != NUL)", "  {", "    if (STRNCMP(p, \"shift:\", 6) == 0"], "whitespace/braces"]
["src/nvim/option.c", ["  {", "    if (STRNCMP(p, \"shift:\", 6) == 0", "        && ((p[6] == '-' && ascii_isdigit(p[7])) || ascii_isdigit(p[6])))"], "readability/braces"]
["src/nvim/option.c", ["        && ((p[6] == '-' && ascii_isdigit(p[7])) || ascii_isdigit(p[6])))", "    {", "      p += 6;"], "whitespace/braces"]
["src/nvim/option.c", ["    }", "    else if (STRNCMP(p, \"min:\", 4) == 0 && ascii_isdigit(p[4]))", "    {"], "whitespace/newline"]
["src/nvim/option.c", ["    else if (STRNCMP(p, \"min:\", 4) == 0 && ascii_isdigit(p[4]))", "    {", "      p += 4;"], "whitespace/braces"]
["src/nvim/option.c", ["    }", "    else if (STRNCMP(p, \"sbr\", 3) == 0)", "    {"], "whitespace/newline"]
["src/nvim/option.c", ["    else if (STRNCMP(p, \"sbr\", 3) == 0)", "    {", "      p += 3;"], "whitespace/braces"]
["src/nvim/option.c", ["    } else {", "      type = \"\"; def = NIL;", "    }"], "whitespace/newline"]
["src/nvim/option.h", ["", "/* flags for buf_copy_options() */", "#define BCO_ENTER       1       /* going to enter the buffer */"], "readability/old_style_comment"]
["src/nvim/option.h", ["/* flags for buf_copy_options() */", "#define BCO_ENTER       1       /* going to enter the buffer */", "#define BCO_ALWAYS      2       /* always copy the options */"], "readability/old_style_comment"]
["src/nvim/option.h", ["#define BCO_ENTER       1       /* going to enter the buffer */", "#define BCO_ALWAYS      2       /* always copy the options */", "#define BCO_NOHELP      4       /* don't touch the help related options */"], "readability/old_style_comment"]
["src/nvim/option.h", ["#define BCO_ALWAYS      2       /* always copy the options */", "#define BCO_NOHELP      4       /* don't touch the help related options */", ""], "readability/old_style_comment"]
["src/nvim/option_defs.h", ["", "#endif // NVIM_OPTION_DEFS_H", ""], "build/header_guard"]
["src/nvim/option_defs.h", ["#ifdef WIN32", "# define DFLT_EFM \"%f(%l) \\\\=: %t%*\\\\D%n: %m,%*[^\\\"]\\\"%f\\\"%*\\\\D%l: %m,%f(%l) \\\\=: %m,%*[^ ] %f %l: %m,%f:%l:%c:%m,%f(%l):%m,%f:%l:%m,%f|%l| %m\"", "#else"], "whitespace/line_length"]
["src/nvim/option_defs.h", ["#else", "# define DFLT_EFM \"%*[^\\\"]\\\"%f\\\"%*\\\\D%l: %m,\\\"%f\\\"%*\\\\D%l: %m,%-G%f:%l: (Each undeclared identifier is reported only once,%-G%f:%l: for each function it appears in.),%-GIn file included from %f:%l:%c:,%-GIn file included from %f:%l:%c\\\\,,%-GIn file included from %f:%l:%c,%-GIn file included from %f:%l,%-G%*[ ]from %f:%l:%c,%-G%*[ ]from %f:%l:,%-G%*[ ]from %f:%l\\\\,,%-G%*[ ]from %f:%l,%f:%l:%c:%m,%f(%l):%m,%f:%l:%m,\\\"%f\\\"\\\\, line %l%*\\\\D%c%*[^ ] %m,%D%*\\\\a[%*\\\\d]: Entering directory %*[`']%f',%X%*\\\\a[%*\\\\d]: Leaving directory %*[`']%f',%D%*\\\\a: Entering directory %*[`']%f',%X%*\\\\a: Leaving directory %*[`']%f',%DMaking %*\\\\a in %f,%f|%l| %m\"", "#endif"], "whitespace/line_length"]
["src/nvim/option_defs.h", ["#define LISPWORD_VALUE \\", "  \"defun,define,defmacro,set!,lambda,if,case,let,flet,let*,letrec,do,do*,define-syntax,let-syntax,letrec-syntax,destructuring-bind,defpackage,defparameter,defstruct,deftype,defvar,do-all-symbols,do-external-symbols,do-symbols,dolist,dotimes,ecase,etypecase,eval-when,labels,macrolet,multiple-value-bind,multiple-value-call,multiple-value-prog1,multiple-value-setq,prog1,progv,typecase,unless,unwind-protect,when,with-input-from-string,with-open-file,with-open-stream,with-output-to-string,with-package-iterator,define-condition,handler-bind,handler-case,restart-bind,restart-case,with-simple-restart,store-value,use-value,muffle-warning,abort,continue,with-slots,with-slots*,with-accessors,with-accessors*,defclass,defmethod,print-unreadable-object\"", ""], "whitespace/line_length"]
["src/nvim/option_defs.h", ["", "/*", " * The following are actual variables for the options"], "readability/old_style_comment"]
["src/nvim/option_defs.h", ["static char *(p_bkc_values[]) =", "{\"yes\", \"auto\", \"no\", \"breaksymlink\", \"breakhardlink\", NULL};", "#endif"], "whitespace/braces"]
["src/nvim/option_defs.h", ["static char *(p_bkc_values[]) =", "{\"yes\", \"auto\", \"no\", \"breaksymlink\", \"breakhardlink\", NULL};", "#endif"], "whitespace/braces"]
["src/nvim/option_defs.h", ["# ifdef IN_OPTION_C", "static char *(p_bo_values[]) = {\"all\", \"backspace\", \"cursor\", \"complete\",", "  \"copy\", \"ctrlg\", \"error\", \"esc\", \"ex\","], "whitespace/braces"]
["src/nvim/option_defs.h", ["  \"showmatch\", \"operator\", \"register\", \"shell\",", "  \"spell\", \"wildmode\", NULL};", "# endif"], "whitespace/braces"]
["src/nvim/option_defs.h", ["# ifdef IN_OPTION_C", "static char *(p_cmp_values[]) = {\"internal\", \"keepascii\", NULL};", "# endif"], "whitespace/braces"]
["src/nvim/option_defs.h", ["# ifdef IN_OPTION_C", "static char *(p_cmp_values[]) = {\"internal\", \"keepascii\", NULL};", "# endif"], "whitespace/braces"]
["src/nvim/option_defs.h", ["#ifdef IN_OPTION_C", "static char *(p_cb_values[]) = {\"unnamed\", \"unnamedplus\", NULL};", "#endif"], "whitespace/braces"]
["src/nvim/option_defs.h", ["#ifdef IN_OPTION_C", "static char *(p_cb_values[]) = {\"unnamed\", \"unnamedplus\", NULL};", "#endif"], "whitespace/braces"]
["src/nvim/option_defs.h", ["# ifdef IN_OPTION_C", "static char *(p_fdo_values[]) = {\"all\", \"block\", \"hor\", \"mark\", \"percent\",", "                                 \"quickfix\", \"search\", \"tag\", \"insert\","], "whitespace/braces"]
["src/nvim/option_defs.h", ["                                 \"quickfix\", \"search\", \"tag\", \"insert\",", "                                 \"undo\", \"jump\", NULL};", "# endif"], "whitespace/braces"]
["src/nvim/option_defs.h", ["# ifdef IN_OPTION_C", "static char *(p_ve_values[]) = {\"block\", \"insert\", \"all\", \"onemore\", NULL};", "# endif"], "whitespace/braces"]
["src/nvim/option_defs.h", ["# ifdef IN_OPTION_C", "static char *(p_ve_values[]) = {\"block\", \"insert\", \"all\", \"onemore\", NULL};", "# endif"], "whitespace/braces"]
["src/nvim/option_defs.h", ["", "/*", " * \"indir\" values for buffer-local opions."], "readability/old_style_comment"]
["src/nvim/option_defs.h", ["", "/*", " * \"indir\" values for window-local options."], "readability/old_style_comment"]
["src/nvim/option_defs.h", ["", "#endif // NVIM_OPTION_DEFS_H", ""], "whitespace/comments"]
["src/nvim/os/dl.c", ["  gen_fn fn;", "  if (uv_dlsym(&lib, funcname, (void **) &fn)) {", "      EMSG2(_(\"dlerror = \\\"%s\\\"\"), uv_dlerror(&lib));"], "whitespace/cast"]
["src/nvim/os/dl.c", ["  if (str_out) {", "    str_str_fn sfn = (str_str_fn) fn;", "    int_str_fn ifn = (int_str_fn) fn;"], "whitespace/cast"]
["src/nvim/os/dl.c", ["    str_str_fn sfn = (str_str_fn) fn;", "    int_str_fn ifn = (int_str_fn) fn;", ""], "whitespace/cast"]
["src/nvim/os/dl.c", ["    // assume that ptr values of NULL, 1 or -1 are illegal", "    *str_out = (res && (intptr_t) res != 1 && (intptr_t) res != -1)", "        ? xstrdup(res) : NULL;"], "whitespace/cast"]
["src/nvim/os/dl.c", ["  } else {", "    str_int_fn sfn = (str_int_fn) fn;", "    int_int_fn ifn = (int_int_fn) fn;"], "whitespace/cast"]
["src/nvim/os/dl.c", ["    str_int_fn sfn = (str_int_fn) fn;", "    int_int_fn ifn = (int_int_fn) fn;", "    *int_out = argv ? sfn(argv) : ifn(argi);"], "whitespace/cast"]
["src/nvim/os/env.c", ["          var = ExpandOne(&xpc, dst, NULL,", "              WILD_ADD_SLASH|WILD_SILENT, WILD_EXPAND_FREE);", "          mustfree = true;"], "whitespace/alignment"]
["src/nvim/os/env.c", ["        // with it, skip a character", "        if (*var != NUL && after_pathsep((char *)dst, (char *)dst + c)", "#if defined(BACKSLASH_IN_FILENAME)"], "readability/braces"]
["src/nvim/os/env.c", ["            && vim_ispathsep(*tail))", "          ++tail;", "        dst += c;"], "readability/increment"]
["src/nvim/os/env.c", ["        *dst++ = *src++;", "        --dstlen;", "      } else if ((src[0] == ' ' || src[0] == ',') && !one) {"], "readability/increment"]
["src/nvim/os/env.c", ["{", "  const char *varval = (const char *) iter;", "  if (varval == NULL) {"], "whitespace/cast"]
["src/nvim/os/env.c", ["  } else {", "    *len = (size_t) (dirend - varval);", "    return dirend + 1;"], "whitespace/cast"]
["src/nvim/os/env.c", ["{", "  const char *varend = (const char *) iter;", "  if (varend == NULL) {"], "whitespace/cast"]
["src/nvim/os/env.c", ["    *dir = colon + 1;", "    *len = (size_t) (varend - colon);", "    return colon - 1;"], "whitespace/cast"]
["src/nvim/os/fs.c", ["  if (result == kLibuvSuccess) {", "    STRNCPY(path, request.path, TEMP_FILE_PATH_MAXLEN);", "  }"], "runtime/printf"]
["src/nvim/os/input.c", ["    // copy the character, escaping CSI and K_SPECIAL", "    if ((uint8_t)*ptr == CSI) {", "      rbuffer_write(input_buffer, (char *)&(uint8_t){K_SPECIAL}, 1);"], "whitespace/operators"]
["src/nvim/os/input.c", ["    if ((uint8_t)*ptr == CSI) {", "      rbuffer_write(input_buffer, (char *)&(uint8_t){K_SPECIAL}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KS_EXTRA}, 1);"], "whitespace/braces"]
["src/nvim/os/input.c", ["    if ((uint8_t)*ptr == CSI) {", "      rbuffer_write(input_buffer, (char *)&(uint8_t){K_SPECIAL}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KS_EXTRA}, 1);"], "whitespace/braces"]
["src/nvim/os/input.c", ["      rbuffer_write(input_buffer, (char *)&(uint8_t){K_SPECIAL}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KS_EXTRA}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KE_CSI}, 1);"], "whitespace/braces"]
["src/nvim/os/input.c", ["      rbuffer_write(input_buffer, (char *)&(uint8_t){K_SPECIAL}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KS_EXTRA}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KE_CSI}, 1);"], "whitespace/braces"]
["src/nvim/os/input.c", ["      rbuffer_write(input_buffer, (char *)&(uint8_t){KS_EXTRA}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KE_CSI}, 1);", "    } else if ((uint8_t)*ptr == K_SPECIAL) {"], "whitespace/braces"]
["src/nvim/os/input.c", ["      rbuffer_write(input_buffer, (char *)&(uint8_t){KS_EXTRA}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KE_CSI}, 1);", "    } else if ((uint8_t)*ptr == K_SPECIAL) {"], "whitespace/braces"]
["src/nvim/os/input.c", ["      rbuffer_write(input_buffer, (char *)&(uint8_t){KE_CSI}, 1);", "    } else if ((uint8_t)*ptr == K_SPECIAL) {", "      rbuffer_write(input_buffer, (char *)&(uint8_t){K_SPECIAL}, 1);"], "whitespace/operators"]
["src/nvim/os/input.c", ["    } else if ((uint8_t)*ptr == K_SPECIAL) {", "      rbuffer_write(input_buffer, (char *)&(uint8_t){K_SPECIAL}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KS_SPECIAL}, 1);"], "whitespace/braces"]
["src/nvim/os/input.c", ["    } else if ((uint8_t)*ptr == K_SPECIAL) {", "      rbuffer_write(input_buffer, (char *)&(uint8_t){K_SPECIAL}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KS_SPECIAL}, 1);"], "whitespace/braces"]
["src/nvim/os/input.c", ["      rbuffer_write(input_buffer, (char *)&(uint8_t){K_SPECIAL}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KS_SPECIAL}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KE_FILLER}, 1);"], "whitespace/braces"]
["src/nvim/os/input.c", ["      rbuffer_write(input_buffer, (char *)&(uint8_t){K_SPECIAL}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KS_SPECIAL}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KE_FILLER}, 1);"], "whitespace/braces"]
["src/nvim/os/input.c", ["      rbuffer_write(input_buffer, (char *)&(uint8_t){KS_SPECIAL}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KE_FILLER}, 1);", "    } else {"], "whitespace/braces"]
["src/nvim/os/input.c", ["      rbuffer_write(input_buffer, (char *)&(uint8_t){KS_SPECIAL}, 1);", "      rbuffer_write(input_buffer, (char *)&(uint8_t){KE_FILLER}, 1);", "    } else {"], "whitespace/braces"]
["src/nvim/os/input.c", ["      || !((mouse_code >= KE_LEFTMOUSE && mouse_code <= KE_RIGHTRELEASE)", "        || (mouse_code >= KE_MOUSEDOWN && mouse_code <= KE_MOUSERIGHT))) {", "    return bufsize;"], "whitespace/alignment"]
["src/nvim/os/input.c", ["      || !((mouse_code >= KE_LEFTMOUSE && mouse_code <= KE_RIGHTRELEASE)", "        || (mouse_code >= KE_MOUSEDOWN && mouse_code <= KE_MOUSERIGHT))) {", "    return bufsize;"], "whitespace/alignment"]
["src/nvim/os/shell.c", ["static void system_data_cb(Stream *stream, RBuffer *buf, size_t count,", "    void *data, bool eof)", "{"], "whitespace/alignment"]
["src/nvim/os/shell.c", ["static void out_data_cb(Stream *stream, RBuffer *buf, size_t count, void *data,", "    bool eof)", "{"], "whitespace/alignment"]
["src/nvim/os/shell.c", ["  size_t argc = 0;", "  const char *p = (const char *) str;", ""], "whitespace/cast"]
["src/nvim/os/shell.c", ["  while (*p != NUL) {", "    const size_t len = word_length((const char_u *) p);", ""], "whitespace/cast"]
["src/nvim/os/shell.c", ["    argc++;", "    p = (const char *) skipwhite((char_u *) (p + len));", "  }"], "whitespace/cast"]
["src/nvim/os/shell.c", ["      }", "      ++lnum;", "      if (lnum > curbuf->b_op_end.lnum) {"], "readability/increment"]
["src/nvim/os/time.c", ["{", "  return (Timestamp) time(NULL);", "}"], "whitespace/cast"]
["src/nvim/os_unix.c", ["{", "  if (aclent == NULL)", "    return;"], "readability/braces"]
["src/nvim/os_unix.c", ["{", "  if (aclent == NULL)", "    return;"], "readability/braces"]
["src/nvim/path.c", ["", "#define URL_SLASH       1               /* path_is_url() has found \"://\" */", "#define URL_BACKSLASH   2               /* path_is_url() has found \":\\\\\" */"], "readability/old_style_comment"]
["src/nvim/path.c", ["#define URL_SLASH       1               /* path_is_url() has found \"://\" */", "#define URL_BACKSLASH   2               /* path_is_url() has found \":\\\\\" */", ""], "readability/old_style_comment"]
["src/nvim/path.c", ["    if (checkname) {", "      vim_FullName((char *)exp1, (char *)full1, MAXPATHL, FALSE);", "      vim_FullName((char *)s2, (char *)full2, MAXPATHL, FALSE);"], "readability/bool"]
["src/nvim/path.c", ["      vim_FullName((char *)exp1, (char *)full1, MAXPATHL, FALSE);", "      vim_FullName((char *)s2, (char *)full2, MAXPATHL, FALSE);", "      if (fnamecmp(full1, full2) == 0) {"], "readability/bool"]
["src/nvim/path.c", ["///", "/// Takes care of \"c:/\" and \"//\". That means `path_tail_with_sep(\"dir///file.txt\")`", "/// will return a pointer to `\"///file.txt\"`."], "whitespace/line_length"]
["src/nvim/path.c", ["{", "  const char_u *tail = get_past_head((char_u *) invocation);", "  const char_u *p = tail;"], "whitespace/cast"]
["src/nvim/path.c", ["  while (vim_ispathsep(*retval)) {", "    ++retval;", "  }"], "readability/increment"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if 'c' is a path separator."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Like vim_ispathsep(c), but exclude the colon for MS-Windows."], "readability/old_style_comment"]
["src/nvim/path.c", ["#endif", "  ;", "}"], "whitespace/semicolon"]
["src/nvim/path.c", ["", "/*", " * return TRUE if 'c' is a path list separator."], "readability/old_style_comment"]
["src/nvim/path.c", ["#else", "  return c == ';';      /* might not be right for every system... */", "#endif"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Shorten the path of a file from \"~/foo/../.bar/fname\" to \"~/f/../.b/fname\""], "readability/old_style_comment"]
["src/nvim/path.c", ["  bool skip = false;", "  for (char_u *s = str;; ++s) {", "    if (s >= tail) {                /* copy the whole tail */"], "readability/increment"]
["src/nvim/path.c", ["  for (char_u *s = str;; ++s) {", "    if (s >= tail) {                /* copy the whole tail */", "      *d++ = *s;"], "readability/old_style_comment"]
["src/nvim/path.c", ["      *d++ = *s;", "      if (*s == NUL)", "        break;"], "readability/braces"]
["src/nvim/path.c", ["        break;", "    } else if (vim_ispathsep(*s)) {       /* copy '/' and next char */", "      *d++ = *s;"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if the directory of \"fname\" exists, FALSE otherwise."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Unix style wildcard expansion code."], "readability/old_style_comment"]
["src/nvim/path.c", ["#endif", "    if (vim_strchr((char_u *) wildcards, *p) != NULL) {", "      return true;"], "whitespace/cast"]
["src/nvim/path.c", ["", "  /* Expanding \"**\" may take a long time, check for CTRL-C. */", "  if (stardepth > 0) {"], "readability/old_style_comment"]
["src/nvim/path.c", ["    os_breakcheck();", "    if (got_int)", "      return 0;"], "readability/braces"]
["src/nvim/path.c", ["  while (*path_end != NUL) {", "    /* May ignore a wildcard that has a backslash before it; it will", "     * be removed by rem_backslash() or file_pat_to_reg_pat() below. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["#endif", "    )) {", "      e = p;"], "whitespace/alignment"]
["src/nvim/path.c", ["#endif", "    )) {", "      e = p;"], "whitespace/alignment"]
["src/nvim/path.c", ["#endif", "    )) {", "      e = p;"], "whitespace/parens"]
["src/nvim/path.c", ["", "  /* Now we have one wildcard component between \"s\" and \"e\". */", "  /* Remove backslashes between \"wildoff\" and the start of the wildcard"], "readability/old_style_comment"]
["src/nvim/path.c", ["  /* Now we have one wildcard component between \"s\" and \"e\". */", "  /* Remove backslashes between \"wildoff\" and the start of the wildcard", "   * component. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["   * component. */", "  for (p = buf + wildoff; p < s; ++p)", "    if (rem_backslash(p)) {"], "readability/braces"]
["src/nvim/path.c", ["   * component. */", "  for (p = buf + wildoff; p < s; ++p)", "    if (rem_backslash(p)) {"], "readability/increment"]
["src/nvim/path.c", ["      STRMOVE(p, p + 1);", "      --e;", "      --s;"], "readability/increment"]
["src/nvim/path.c", ["      --e;", "      --s;", "    }"], "readability/increment"]
["src/nvim/path.c", ["", "  /* Check for \"**\" between \"s\" and \"e\". */", "  for (p = s; p < e; ++p)"], "readability/old_style_comment"]
["src/nvim/path.c", ["  /* Check for \"**\" between \"s\" and \"e\". */", "  for (p = s; p < e; ++p)", "    if (p[0] == '*' && p[1] == '*')"], "readability/braces"]
["src/nvim/path.c", ["  /* Check for \"**\" between \"s\" and \"e\". */", "  for (p = s; p < e; ++p)", "    if (p[0] == '*' && p[1] == '*')"], "readability/increment"]
["src/nvim/path.c", ["  for (p = s; p < e; ++p)", "    if (p[0] == '*' && p[1] == '*')", "      starstar = true;"], "readability/braces"]
["src/nvim/path.c", ["#endif", "  if (flags & (EW_NOERROR | EW_NOTWILD))", "    ++emsg_silent;"], "readability/braces"]
["src/nvim/path.c", ["  if (flags & (EW_NOERROR | EW_NOTWILD))", "    ++emsg_silent;", "  regmatch.regprog = vim_regcomp(pat, RE_MAGIC);"], "readability/increment"]
["src/nvim/path.c", ["  regmatch.regprog = vim_regcomp(pat, RE_MAGIC);", "  if (flags & (EW_NOERROR | EW_NOTWILD))", "    --emsg_silent;"], "readability/braces"]
["src/nvim/path.c", ["  if (flags & (EW_NOERROR | EW_NOTWILD))", "    --emsg_silent;", "  xfree(pat);"], "readability/increment"]
["src/nvim/path.c", ["", "  /* If \"**\" is by itself, this is the first time we encounter it and more", "   * is following then find matches without any directory. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["        if (starstar && stardepth < 100) {", "          /* For \"**\" in the pattern first go deeper in the tree to", "           * find matches. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["           * find matches. */", "          STRCPY(buf + len, \"/**\");", "          STRCPY(buf + len + 3, path_end);"], "readability/old_style_comment"]
["src/nvim/path.c", ["          STRCPY(buf + len + 3, path_end);", "          ++stardepth;", "          (void)do_path_expand(gap, buf, len + 1, flags, true);"], "readability/increment"]
["src/nvim/path.c", ["          (void)do_path_expand(gap, buf, len + 1, flags, true);", "          --stardepth;", "        }"], "readability/increment"]
["src/nvim/path.c", ["        STRCPY(buf + len, path_end);", "        if (path_has_exp_wildcard(path_end)) {      /* handle more wildcards */", "          /* need to expand another component of the path */"], "readability/old_style_comment"]
["src/nvim/path.c", ["        if (path_has_exp_wildcard(path_end)) {      /* handle more wildcards */", "          /* need to expand another component of the path */", "          /* remove backslashes for the remaining components only */"], "readability/old_style_comment"]
["src/nvim/path.c", ["          /* need to expand another component of the path */", "          /* remove backslashes for the remaining components only */", "          (void)do_path_expand(gap, buf, len + 1, flags, false);"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Moves \"*psep\" back to the previous path separator in \"path\"."], "readability/old_style_comment"]
["src/nvim/path.c", ["{", "  /* skip the current separator */", "  if (*psep > path && vim_ispathsep(**psep))"], "readability/old_style_comment"]
["src/nvim/path.c", ["  /* skip the current separator */", "  if (*psep > path && vim_ispathsep(**psep))", "    --*psep;"], "readability/braces"]
["src/nvim/path.c", ["  if (*psep > path && vim_ispathsep(**psep))", "    --*psep;", ""], "readability/increment"]
["src/nvim/path.c", ["", "  /* find the previous separator */", "  while (*psep > path) {"], "readability/old_style_comment"]
["src/nvim/path.c", ["  while (*psep > path) {", "    if (vim_ispathsep(**psep))", "      return OK;"], "readability/braces"]
["src/nvim/path.c", ["", "/*", " * Returns TRUE if \"maybe_unique\" is unique wrt other_paths in \"gap\"."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Split the 'path' option into an array of strings in garray_T.  Relative"], "readability/old_style_comment"]
["src/nvim/path.c", ["    if (buf[0] == '.' && (buf[1] == NUL || vim_ispathsep(buf[1]))) {", "      /* Relative to current buffer:", "       * \"/path/file\" + \".\" -> \"/path/\""], "readability/old_style_comment"]
["src/nvim/path.c", ["       * \"/path/file\"  + \"./subdir\" -> \"/path/subdir\" */", "      if (curbuf->b_ffname == NULL)", "        continue;"], "readability/braces"]
["src/nvim/path.c", ["", "/*", " * Returns a pointer to the file or directory name in \"fname\" that matches the"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Sorts, removes duplicates and modifies all the fullpath names in \"gap\" so"], "readability/old_style_comment"]
["src/nvim/path.c", ["  xfree(file_pattern);", "  if (pat == NULL)", "    return;"], "readability/braces"]
["src/nvim/path.c", ["", "  regmatch.rm_ic = TRUE;                /* always ignore case */", "  regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "  regmatch.rm_ic = TRUE;                /* always ignore case */", "  regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);"], "readability/bool"]
["src/nvim/path.c", ["  xfree(pat);", "  if (regmatch.regprog == NULL)", "    return;"], "readability/braces"]
["src/nvim/path.c", ["                   && curdir[dir_end - path] == NUL;", "    if (is_in_curdir)", "      in_curdir[i] = vim_strsave(path);"], "readability/braces"]
["src/nvim/path.c", ["", "    /* Shorten the filename while maintaining its uniqueness */", "    path_cutoff = get_path_cutoff(path, &path_ga);"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "  /* Shorten filenames in /in/current/directory/{filename} */", "  for (int i = 0; i < gap->ga_len && !got_int; i++) {"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "    if (path == NULL)", "      continue;"], "readability/braces"]
["src/nvim/path.c", ["", "    /* If the {filename} is not unique, change it to ./{filename}.", "     * Else reduce it to {filename} */"], "readability/old_style_comment"]
["src/nvim/path.c", ["    short_name = path_shorten_fname(path, curdir);", "    if (short_name == NULL)", "      short_name = path;"], "readability/braces"]
["src/nvim/path.c", ["  xfree(curdir);", "  for (int i = 0; i < gap->ga_len; i++)", "    xfree(in_curdir[i]);"], "readability/braces"]
["src/nvim/path.c", ["", "  if (sort_again)", "    ga_remove_duplicate_strings(gap);"], "readability/braces"]
["src/nvim/path.c", ["    } else {", "      if (!look_for_sep)", "        dir_end = next_dir_end;"], "readability/braces"]
["src/nvim/path.c", ["", "/*", " * Calls globpath() with 'path' values for the given pattern and stores the"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if \"p\" contains what looks like an environment variable."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "  /*", "   * expand_env() is called to expand things like \"~user\".  If this fails,"], "readability/old_style_comment"]
["src/nvim/path.c", ["   */", "  if (recursive)", "#ifdef SPECIAL_WILDCHAR"], "readability/braces"]
["src/nvim/path.c", ["#ifdef SPECIAL_WILDCHAR", "  /*", "   * If there are any special wildcard characters which we cannot handle"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "  /*", "   * The matching file names are stored in a growarray.  Init it empty."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "  for (int i = 0; i < num_pat; ++i) {", "    add_pat = -1;"], "readability/increment"]
["src/nvim/path.c", ["        p = expand_env_save_opt(p, true);", "        if (p == NULL)", "          p = pat[i];"], "readability/braces"]
["src/nvim/path.c", ["#ifdef UNIX", "        /*", "         * On Unix, if expand_env() can't expand an environment"], "readability/old_style_comment"]
["src/nvim/path.c", ["         */", "        else if (has_env_var(p) || *p == '~') {", "          xfree(p);"], "readability/braces"]
["src/nvim/path.c", ["", "      /*", "       * If there are wildcards: Expand file names and add each match to"], "readability/old_style_comment"]
["src/nvim/path.c", ["            ) {", "          /* :find completion where 'path' is used.", "           * Recursiveness is OK here. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "      /* When EW_NOTFOUND is used, always add files and dirs.  Makes", "       * \"vim c:/\" work. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "    if (did_expand_in_path && !GA_EMPTY(&ga) && (flags & EW_PATH))", "      uniquefy_paths(&ga, p);"], "readability/braces"]
["src/nvim/path.c", ["      uniquefy_paths(&ga, p);", "    if (p != pat[i])", "      xfree(p);"], "readability/braces"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if we can expand this backtick thing here."], "readability/old_style_comment"]
["src/nvim/path.c", ["    char_u *pat,", "    int flags              /* EW_* flags */", ")"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "  if (*cmd == '=')          /* `={expr}`: Expand expression */", "    buffer = eval_to_string(cmd + 1, &p, TRUE);"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "  if (*cmd == '=')          /* `={expr}`: Expand expression */", "    buffer = eval_to_string(cmd + 1, &p, TRUE);"], "readability/braces"]
["src/nvim/path.c", ["  if (*cmd == '=')          /* `={expr}`: Expand expression */", "    buffer = eval_to_string(cmd + 1, &p, TRUE);", "  else"], "readability/bool"]
["src/nvim/path.c", ["    buffer = eval_to_string(cmd + 1, &p, TRUE);", "  else", "    buffer = get_cmd_output(cmd, NULL,"], "readability/braces"]
["src/nvim/path.c", ["    buffer = get_cmd_output(cmd, NULL,", "        (flags & EW_SILENT) ? kShellOptSilent : 0, NULL);", "  xfree(cmd);"], "whitespace/alignment"]
["src/nvim/path.c", ["  while (*cmd != NUL) {", "    cmd = skipwhite(cmd);               /* skip over white space */", "    p = cmd;"], "readability/old_style_comment"]
["src/nvim/path.c", ["    p = cmd;", "    while (*p != NUL && *p != '\\r' && *p != '\\n')     /* skip over entry */", "      ++p;"], "readability/old_style_comment"]
["src/nvim/path.c", ["    p = cmd;", "    while (*p != NUL && *p != '\\r' && *p != '\\n')     /* skip over entry */", "      ++p;"], "readability/braces"]
["src/nvim/path.c", ["    while (*p != NUL && *p != '\\r' && *p != '\\n')     /* skip over entry */", "      ++p;", "    /* add an entry if it is not empty */"], "readability/increment"]
["src/nvim/path.c", ["      ++p;", "    /* add an entry if it is not empty */", "    if (p > cmd) {"], "readability/old_style_comment"]
["src/nvim/path.c", ["      *p = i;", "      ++cnt;", "    }"], "readability/increment"]
["src/nvim/path.c", ["    cmd = p;", "    while (*cmd != NUL && (*cmd == '\\r' || *cmd == '\\n'))", "      ++cmd;"], "readability/braces"]
["src/nvim/path.c", ["    while (*cmd != NUL && (*cmd == '\\r' || *cmd == '\\n'))", "      ++cmd;", "  }"], "readability/increment"]
["src/nvim/path.c", ["    garray_T *gap,", "    char_u *f,         /* filename */", "    int flags"], "readability/old_style_comment"]
["src/nvim/path.c", ["#ifdef FNAME_ILLEGAL", "  /* if the file/dir contains illegal characters, don't add it */", "  if (vim_strpbrk(f, (char_u *)FNAME_ILLEGAL) != NULL)"], "readability/old_style_comment"]
["src/nvim/path.c", ["  /* if the file/dir contains illegal characters, don't add it */", "  if (vim_strpbrk(f, (char_u *)FNAME_ILLEGAL) != NULL)", "    return;"], "readability/braces"]
["src/nvim/path.c", ["  isdir = os_isdir(f);", "  if ((isdir && !(flags & EW_DIR)) || (!isdir && !(flags & EW_FILE)))", "    return;"], "readability/braces"]
["src/nvim/path.c", ["#endif", "  /*", "   * Append a slash or backslash after directory names if none is present."], "readability/old_style_comment"]
["src/nvim/path.c", ["   */", "  if (isdir && (flags & EW_ADDSLASH))", "    add_pathsep((char *)p);"], "readability/braces"]
["src/nvim/path.c", ["", "/*", " * Converts a file name into a canonical form. It simplifies a file name into"], "readability/old_style_comment"]
["src/nvim/path.c", ["#ifdef BACKSLASH_IN_FILENAME", "  if (p[1] == ':')          /* skip \"x:\" */", "    p += 2;"], "readability/old_style_comment"]
["src/nvim/path.c", ["#ifdef BACKSLASH_IN_FILENAME", "  if (p[1] == ':')          /* skip \"x:\" */", "    p += 2;"], "readability/braces"]
["src/nvim/path.c", ["    do", "      ++p;", "    while (vim_ispathsep(*p));"], "readability/increment"]
["src/nvim/path.c", ["      ++p;", "    while (vim_ispathsep(*p));", "  }"], "readability/braces"]
["src/nvim/path.c", ["      ++p;", "    while (vim_ispathsep(*p));", "  }"], "whitespace/empty_loop_body"]
["src/nvim/path.c", ["  }", "  start = p;        /* remember start after \"c:/\" or \"/\" or \"///\" */", ""], "readability/old_style_comment"]
["src/nvim/path.c", ["  do {", "    /* At this point \"p\" is pointing to the char following a single \"/\"", "     * or \"p\" is at the \"start\" of the (absolute or relative) path name. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["     * or \"p\" is at the \"start\" of the (absolute or relative) path name. */", "    if (vim_ispathsep(*p))", "      STRMOVE(p, p + 1);                /* remove duplicate \"/\" */"], "readability/braces"]
["src/nvim/path.c", ["    if (vim_ispathsep(*p))", "      STRMOVE(p, p + 1);                /* remove duplicate \"/\" */", "    else if (p[0] == '.' && (vim_ispathsep(p[1]) || p[1] == NUL)) {"], "readability/old_style_comment"]
["src/nvim/path.c", ["      STRMOVE(p, p + 1);                /* remove duplicate \"/\" */", "    else if (p[0] == '.' && (vim_ispathsep(p[1]) || p[1] == NUL)) {", "      if (p == start && relative)"], "readability/braces"]
["src/nvim/path.c", ["    else if (p[0] == '.' && (vim_ispathsep(p[1]) || p[1] == NUL)) {", "      if (p == start && relative)", "        p += 1 + (p[1] != NUL);         /* keep single \".\" or leading \"./\" */"], "readability/braces"]
["src/nvim/path.c", ["      if (p == start && relative)", "        p += 1 + (p[1] != NUL);         /* keep single \".\" or leading \"./\" */", "      else {"], "readability/old_style_comment"]
["src/nvim/path.c", ["        p += 1 + (p[1] != NUL);         /* keep single \".\" or leading \"./\" */", "      else {", "        /* Strip \"./\" or \".///\".  If we are at the end of the file name"], "readability/braces"]
["src/nvim/path.c", ["        p += 1 + (p[1] != NUL);         /* keep single \".\" or leading \"./\" */", "      else {", "        /* Strip \"./\" or \".///\".  If we are at the end of the file name"], "readability/braces"]
["src/nvim/path.c", ["      else {", "        /* Strip \"./\" or \".///\".  If we are at the end of the file name", "         * and there is no trailing path separator, either strip \"/.\" if"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "      if (components > 0) {             /* strip one preceding component */", "        bool do_strip = false;"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "        /* Don't strip for an erroneous file name. */", "        if (!stripping_disabled) {"], "readability/old_style_comment"]
["src/nvim/path.c", ["        if (!stripping_disabled) {", "          /* If the preceding component does not exist in the file", "           * system, we strip it.  On Unix, we don't accept a symbolic"], "readability/old_style_comment"]
["src/nvim/path.c", ["          if (!do_strip) {", "            /* If the component exists in the file system, check", "             * that stripping it won't change the meaning of the"], "readability/old_style_comment"]
["src/nvim/path.c", ["            if (do_strip) {", "              /* The check for the unstripped file name", "               * above works also for a symbolic link pointing to"], "readability/old_style_comment"]
["src/nvim/path.c", ["                do_strip = false;", "                /* We don't disable stripping of later", "                 * components since the unstripped path name is"], "readability/old_style_comment"]
["src/nvim/path.c", ["        if (!do_strip) {", "          /* Skip the \"..\" or \"../\" and reset the counter for the", "           * components that might be stripped later on. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["        } else {", "          /* Strip previous component.  If the result would get empty", "           * and there is no trailing path separator, leave a single"], "readability/old_style_comment"]
["src/nvim/path.c", ["          } else {", "            if (p > start && tail[-1] == '.')", "              --p;"], "readability/braces"]
["src/nvim/path.c", ["            if (p > start && tail[-1] == '.')", "              --p;", "            STRMOVE(p, tail);                   /* strip previous component */"], "readability/increment"]
["src/nvim/path.c", ["              --p;", "            STRMOVE(p, tail);                   /* strip previous component */", "          }"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "          --components;", "        }"], "readability/increment"]
["src/nvim/path.c", ["        }", "      } else if (p == start && !relative)       /* leading \"/..\" or \"/../\" */", "        STRMOVE(p, tail);                       /* strip \"..\" or \"../\" */"], "readability/old_style_comment"]
["src/nvim/path.c", ["        }", "      } else if (p == start && !relative)       /* leading \"/..\" or \"/../\" */", "        STRMOVE(p, tail);                       /* strip \"..\" or \"../\" */"], "readability/braces"]
["src/nvim/path.c", ["      } else if (p == start && !relative)       /* leading \"/..\" or \"/../\" */", "        STRMOVE(p, tail);                       /* strip \"..\" or \"../\" */", "      else {"], "readability/old_style_comment"]
["src/nvim/path.c", ["        STRMOVE(p, tail);                       /* strip \"..\" or \"../\" */", "      else {", "        if (p == start + 2 && p[-2] == '.') {           /* leading \"./../\" */"], "readability/braces"]
["src/nvim/path.c", ["        STRMOVE(p, tail);                       /* strip \"..\" or \"../\" */", "      else {", "        if (p == start + 2 && p[-2] == '.') {           /* leading \"./../\" */"], "readability/braces"]
["src/nvim/path.c", ["      else {", "        if (p == start + 2 && p[-2] == '.') {           /* leading \"./../\" */", "          STRMOVE(p - 2, p);                            /* strip leading \"./\" */"], "readability/old_style_comment"]
["src/nvim/path.c", ["        if (p == start + 2 && p[-2] == '.') {           /* leading \"./../\" */", "          STRMOVE(p - 2, p);                            /* strip leading \"./\" */", "          tail -= 2;"], "readability/old_style_comment"]
["src/nvim/path.c", ["        }", "        p = tail;                       /* skip to char after \"..\" or \"../\" */", "      }"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Return the name of the file ptr[len] in 'path'."], "readability/old_style_comment"]
["src/nvim/path.c", ["char_u *", "find_file_name_in_path (", "    char_u *ptr,"], "whitespace/parens"]
["src/nvim/path.c", ["    long count,", "    char_u *rel_fname         /* file we are searching relative to */", ")"], "readability/old_style_comment"]
["src/nvim/path.c", ["  if ((options & FNAME_INCL) && *curbuf->b_p_inex != NUL) {", "    tofree = (char_u *) eval_includeexpr((char *) ptr, len);", "    if (tofree != NULL) {"], "whitespace/cast"]
["src/nvim/path.c", ["", "    /*", "     * If the file could not be found in a normal way, try applying"], "readability/old_style_comment"]
["src/nvim/path.c", ["        && !(options & FNAME_INCL) && *curbuf->b_p_inex != NUL) {", "      tofree = (char_u *) eval_includeexpr((char *) ptr, len);", "      if (tofree != NULL) {"], "whitespace/cast"]
["src/nvim/path.c", ["        file_name = find_file_in_path(ptr, len, options & ~FNAME_MESS,", "                                      TRUE, rel_fname);", "      }"], "readability/bool"]
["src/nvim/path.c", ["", "    /* Repeat finding the file \"count\" times.  This matters when it", "     * appears several times in the path. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["      xfree(file_name);", "      file_name = find_file_in_path(ptr, len, options, FALSE, rel_fname);", "    }"], "readability/bool"]
["src/nvim/path.c", ["    }", "  } else", "    file_name = vim_strnsave(ptr, len);"], "readability/braces"]
["src/nvim/path.c", ["{", "  if (strncmp(p, \"://\", 3) == 0)", "    return URL_SLASH;"], "readability/braces"]
["src/nvim/path.c", ["    return URL_SLASH;", "  else if (strncmp(p, \":\\\\\\\\\", 3) == 0)", "    return URL_BACKSLASH;"], "readability/braces"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if \"name\" is a full (absolute) path name or URL."], "readability/old_style_comment"]
["src/nvim/path.c", ["#else", "  if (!vim_isAbsName((char_u *)fname)", "      || strstr(fname, \"..\") != NULL"], "readability/braces"]
["src/nvim/path.c", ["    *slash = NUL;", "    ok = os_scandir(&dir, (char *) name);", "    *slash = '/';"], "whitespace/cast"]
["src/nvim/path.c", ["  char_u *entry;", "  while ((entry = (char_u *) os_scandir_next(&dir))) {", "    // Only accept names that differ in case and are the same byte"], "whitespace/cast"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if \"p\" points to just after a path separator."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if file names \"f1\" and \"f2\" are in the same directory."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "  /* safety check */", "  if (f1 == NULL || f2 == NULL)"], "readability/old_style_comment"]
["src/nvim/path.c", ["  /* safety check */", "  if (f1 == NULL || f2 == NULL)", "    return false;"], "readability/braces"]
["src/nvim/path.c", ["", "  (void)vim_FullName((char *)f1, (char *)ffname, MAXPATHL, FALSE);", "  t1 = path_tail_with_sep(ffname);"], "readability/bool"]
["src/nvim/path.c", ["", "/*", " * Compare path \"p[]\" to \"q[]\"."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "    /* End of \"p\": check if \"q\" also ends or just has a slash. */", "    if (c1 == NUL) {"], "readability/old_style_comment"]
["src/nvim/path.c", ["    if (c1 == NUL) {", "      if (c2 == NUL)        /* full match */", "        return 0;"], "readability/old_style_comment"]
["src/nvim/path.c", ["    if (c1 == NUL) {", "      if (c2 == NUL)        /* full match */", "        return 0;"], "readability/braces"]
["src/nvim/path.c", ["", "    /* End of \"q\": check if \"p\" just has a slash. */", "    if (c2 == NUL) {"], "readability/old_style_comment"]
["src/nvim/path.c", ["#ifdef BACKSLASH_IN_FILENAME", "        /* consider '/' and '\\\\' to be equal */", "        && !((c1 == '/' && c2 == '\\\\')"], "readability/old_style_comment"]
["src/nvim/path.c", ["        ) {", "      if (vim_ispathsep(c1))", "        return -1;"], "readability/braces"]
["src/nvim/path.c", ["        return -1;", "      if (vim_ispathsep(c2))", "        return 1;"], "readability/braces"]
["src/nvim/path.c", ["  if (*exp_pat == '%' || *exp_pat == '#' || *exp_pat == '<') {", "    ++emsg_off;", "    eval_pat = eval_vars(exp_pat, exp_pat, &usedlen,"], "readability/increment"]
["src/nvim/path.c", ["    eval_pat = eval_vars(exp_pat, exp_pat, &usedlen,", "        NULL, &ignored_msg, NULL);", "    --emsg_off;"], "whitespace/alignment"]
["src/nvim/path.c", ["        NULL, &ignored_msg, NULL);", "    --emsg_off;", "    if (eval_pat != NULL)"], "readability/increment"]
["src/nvim/path.c", ["    --emsg_off;", "    if (eval_pat != NULL)", "      exp_pat = concat_str(eval_pat, exp_pat + usedlen);"], "readability/braces"]
["src/nvim/path.c", ["", "  if (exp_pat != NULL)", "    ret = expand_wildcards(1, &exp_pat, num_file, file, flags);"], "readability/braces"]
["src/nvim/path.c", ["  char_u      *p;", "  int non_suf_match;            /* number without matching suffix */", ""], "readability/old_style_comment"]
["src/nvim/path.c", ["", "  /* When keeping all matches, return here */", "  if ((flags & EW_KEEPALL) || retval == FAIL)"], "readability/old_style_comment"]
["src/nvim/path.c", ["  /* When keeping all matches, return here */", "  if ((flags & EW_KEEPALL) || retval == FAIL)", "    return retval;"], "readability/braces"]
["src/nvim/path.c", ["", "  /*", "   * Remove names that match 'wildignore'."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if \"fname\" matches with an entry in 'suffixes'."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "      /* empty entry: match name without a '.' */", "      if (vim_strchr(tail, '.') == NULL) {"], "readability/old_style_comment"]
["src/nvim/path.c", ["  if (STRLEN(directory) == 0) {", "    return os_dirname((char_u *) buffer, len);", "  }"], "whitespace/cast"]
["src/nvim/path.c", ["  // Get current directory name.", "  if (os_dirname((char_u *) old_dir, MAXPATHL) == FAIL) {", "    return FAIL;"], "whitespace/cast"]
["src/nvim/path.c", ["", "  if (retval == FAIL || os_dirname((char_u *) buffer, len) == FAIL) {", "    // Do not return immediately since we are in the wrong directory."], "whitespace/cast"]
["src/nvim/path.c", ["  char *relative_directory = xmalloc(len);", "  char *end_of_path = (char *) fname;", ""], "whitespace/cast"]
["src/nvim/path.c", ["      }", "      end_of_path = (char *) (p + 1);", "    } else {"], "whitespace/cast"]
["src/nvim/path.c", ["      relative_directory[0] = NUL;", "      end_of_path = (char *) fname;", "    }"], "whitespace/cast"]
["src/nvim/path.c", ["", "    if (FAIL == path_full_dir_name(relative_directory, (char *) buf, len)) {", "      xfree(relative_directory);"], "whitespace/cast"]
["src/nvim/path.h", ["#endif", "#endif", ""], "build/header_guard"]
["src/nvim/path.h", ["", "/* Flags for expand_wildcards() */", "#define EW_DIR          0x01    /* include directory names */"], "readability/old_style_comment"]
["src/nvim/path.h", ["/* Flags for expand_wildcards() */", "#define EW_DIR          0x01    /* include directory names */", "#define EW_FILE         0x02    /* include file names */"], "readability/old_style_comment"]
["src/nvim/path.h", ["#define EW_DIR          0x01    /* include directory names */", "#define EW_FILE         0x02    /* include file names */", "#define EW_NOTFOUND     0x04    /* include not found names */"], "readability/old_style_comment"]
["src/nvim/path.h", ["#define EW_FILE         0x02    /* include file names */", "#define EW_NOTFOUND     0x04    /* include not found names */", "#define EW_ADDSLASH     0x08    /* append slash to directory name */"], "readability/old_style_comment"]
["src/nvim/path.h", ["#define EW_NOTFOUND     0x04    /* include not found names */", "#define EW_ADDSLASH     0x08    /* append slash to directory name */", "#define EW_KEEPALL      0x10    /* keep all matches */"], "readability/old_style_comment"]
["src/nvim/path.h", ["#define EW_ADDSLASH     0x08    /* append slash to directory name */", "#define EW_KEEPALL      0x10    /* keep all matches */", "#define EW_SILENT       0x20    /* don't print \"1 returned\" from shell */"], "readability/old_style_comment"]
["src/nvim/path.h", ["#define EW_KEEPALL      0x10    /* keep all matches */", "#define EW_SILENT       0x20    /* don't print \"1 returned\" from shell */", "#define EW_EXEC         0x40    /* executable files */"], "readability/old_style_comment"]
["src/nvim/path.h", ["#define EW_SILENT       0x20    /* don't print \"1 returned\" from shell */", "#define EW_EXEC         0x40    /* executable files */", "#define EW_PATH         0x80    /* search in 'path' too */"], "readability/old_style_comment"]
["src/nvim/path.h", ["#define EW_EXEC         0x40    /* executable files */", "#define EW_PATH         0x80    /* search in 'path' too */", "#define EW_ICASE        0x100   /* ignore case */"], "readability/old_style_comment"]
["src/nvim/path.h", ["#define EW_PATH         0x80    /* search in 'path' too */", "#define EW_ICASE        0x100   /* ignore case */", "#define EW_NOERROR      0x200   /* no error for bad regexp */"], "readability/old_style_comment"]
["src/nvim/path.h", ["#define EW_ICASE        0x100   /* ignore case */", "#define EW_NOERROR      0x200   /* no error for bad regexp */", "#define EW_NOTWILD      0x400   /* add match with literal name if exists */"], "readability/old_style_comment"]
["src/nvim/path.h", ["#define EW_NOERROR      0x200   /* no error for bad regexp */", "#define EW_NOTWILD      0x400   /* add match with literal name if exists */", "#define EW_KEEPDOLLAR   0x800   /* do not escape $, $var is expanded */"], "readability/old_style_comment"]
["src/nvim/path.h", ["#define EW_NOTWILD      0x400   /* add match with literal name if exists */", "#define EW_KEEPDOLLAR   0x800   /* do not escape $, $var is expanded */", "/* Note: mostly EW_NOTFOUND and EW_SILENT are mutually exclusive: EW_NOTFOUND"], "readability/old_style_comment"]
["src/nvim/path.h", ["#define EW_KEEPDOLLAR   0x800   /* do not escape $, $var is expanded */", "/* Note: mostly EW_NOTFOUND and EW_SILENT are mutually exclusive: EW_NOTFOUND", "* is used when executing commands and EW_SILENT for interactive expanding. */"], "readability/old_style_comment"]
["src/nvim/popupmnu.c", ["", "static pumitem_T *pum_array = NULL; // items of displayed pum", "static int pum_size;                // nr of items in \"pum_array\""], "whitespace/comments"]
["src/nvim/popupmnu.c", ["", "  for (i = 0; i < pum_height; ++i) {", "    idx = i + pum_first;"], "readability/increment"]
["src/nvim/popupmnu.c", ["", "    for (round = 1; round <= 3; ++round) {", "      width = 0;"], "readability/increment"]
["src/nvim/popupmnu.c", ["{", "  int resized = FALSE;", "  int context = pum_height / 2;"], "readability/bool"]
["src/nvim/popupmnu.c", ["              win_setheight((int)lnum);", "              resized = TRUE;", "            }"], "readability/bool"]
["src/nvim/popupmnu.c", ["          curbuf->b_changed = false;", "          curbuf->b_p_ma = FALSE;", "          curwin->w_cursor.lnum = 1;"], "readability/bool"]
["src/nvim/popupmnu.c", ["            if (ins_compl_active() && !resized) {", "              curwin->w_redr_status = FALSE;", "            }"], "readability/bool"]
["src/nvim/pos.h", ["", "/*", " * position in file or buffer"], "readability/old_style_comment"]
["src/nvim/pos.h", ["typedef struct {", "  linenr_T lnum;        /* line number */", "  colnr_T col;          /* column number */"], "readability/old_style_comment"]
["src/nvim/pos.h", ["  linenr_T lnum;        /* line number */", "  colnr_T col;          /* column number */", "  colnr_T coladd;"], "readability/old_style_comment"]
["src/nvim/pos.h", ["", "/*", " * Same, but without coladd."], "readability/old_style_comment"]
["src/nvim/pos.h", ["typedef struct {", "  linenr_T lnum;        /* line number */", "  colnr_T col;          /* column number */"], "readability/old_style_comment"]
["src/nvim/pos.h", ["  linenr_T lnum;        /* line number */", "  colnr_T col;          /* column number */", "} lpos_T;"], "readability/old_style_comment"]
["src/nvim/profile.c", ["", "  return (proftime_T) round((double) tm / (double) count);", "}"], "whitespace/cast"]
["src/nvim/profile.h", ["#define TIME_MSG(s) do { \\", "    if (time_fd != NULL) time_msg(s, NULL); \\", "  } while (0)"], "readability/braces"]
["src/nvim/quickfix.c", ["    qi->qf_curlist = LISTCOUNT - 1;", "  } else", "    qi->qf_curlist = qi->qf_listcount++;"], "readability/braces"]
["src/nvim/quickfix.c", ["  qi = *pqi;", "  if (qi == NULL)", "    return;"], "readability/braces"]
["src/nvim/quickfix.c", ["      (*stackptr)->dirname = (char_u *)concat_fnames((char *)ds_new->dirname,", "          (char *)dirbuf, TRUE);", "      if (os_isdir((*stackptr)->dirname))"], "whitespace/alignment"]
["src/nvim/quickfix.c", ["      (*stackptr)->dirname = (char_u *)concat_fnames((char *)ds_new->dirname,", "          (char *)dirbuf, TRUE);", "      if (os_isdir((*stackptr)->dirname))"], "readability/bool"]
["src/nvim/quickfix.c", ["          (char *)dirbuf, TRUE);", "      if (os_isdir((*stackptr)->dirname))", "        break;"], "readability/braces"]
["src/nvim/quickfix.c", ["", "  if ((*stackptr)->dirname != NULL)", "    return (*stackptr)->dirname;"], "readability/braces"]
["src/nvim/quickfix.c", ["    return (*stackptr)->dirname;", "  else {", "    ds_ptr = *stackptr;"], "readability/braces"]
["src/nvim/quickfix.c", ["    return (*stackptr)->dirname;", "  else {", "    ds_ptr = *stackptr;"], "readability/braces"]
["src/nvim/quickfix.c", ["    xfree(fullname);", "    fullname = (char_u *)concat_fnames((char *)ds_ptr->dirname, (char *)filename, TRUE);", ""], "whitespace/line_length"]
["src/nvim/quickfix.c", ["    xfree(fullname);", "    fullname = (char_u *)concat_fnames((char *)ds_ptr->dirname, (char *)filename, TRUE);", ""], "readability/bool"]
["src/nvim/quickfix.c", ["  qfline_T *qf_ptr = qfl->qf_ptr;", "  int qf_idx = qfl->qf_index;;", ""], "whitespace/newline"]
["src/nvim/quickfix.c", ["", "  if (qi == NULL)", "    qi = &ql_info;"], "readability/braces"]
["src/nvim/quickfix.c", ["      swb_flags = old_swb_flags;", "    } else", "      free_string_option(old_swb);"], "readability/braces"]
["src/nvim/quickfix.c", ["", "  for (i = 0; *p != NUL && i < bufsize - 1; ++i) {", "    if (*p == '\\n') {"], "readability/increment"]
["src/nvim/quickfix.c", ["      buf[i] = ' ';", "      while (*++p != NUL)", "        if (!ascii_iswhite(*p) && *p != '\\n')"], "readability/braces"]
["src/nvim/quickfix.c", ["      while (*++p != NUL)", "        if (!ascii_iswhite(*p) && *p != '\\n')", "          break;"], "readability/braces"]
["src/nvim/quickfix.c", ["          break;", "    } else", "      buf[i] = *p++;"], "readability/braces"]
["src/nvim/quickfix.c", ["      }", "      --qi->qf_curlist;", "    } else {"], "readability/increment"]
["src/nvim/quickfix.c", ["      }", "      ++qi->qf_curlist;", "    }"], "readability/increment"]
["src/nvim/quickfix.c", ["          if (qfp->qf_lnum >= line1 && qfp->qf_lnum <= line2) {", "            if (amount == MAXLNUM)", "              qfp->qf_cleared = TRUE;"], "readability/braces"]
["src/nvim/quickfix.c", ["            if (amount == MAXLNUM)", "              qfp->qf_cleared = TRUE;", "            else"], "readability/bool"]
["src/nvim/quickfix.c", ["              qfp->qf_cleared = TRUE;", "            else", "              qfp->qf_lnum += amount;"], "readability/braces"]
["src/nvim/quickfix.c", ["              qfp->qf_lnum += amount;", "          } else if (amount_after && qfp->qf_lnum > line2)", "            qfp->qf_lnum += amount_after;"], "readability/braces"]
["src/nvim/quickfix.c", ["", "  if (nr <= 0)", "    return p;"], "readability/braces"]
["src/nvim/quickfix.c", ["", "  sprintf((char *)buf, \"%s %3d\", (char *)p, nr);", "  return buf;"], "runtime/printf"]
["src/nvim/quickfix.c", ["         && STRCMP(\"internal\",", "      *curbuf->b_p_gp == NUL ? p_gp : curbuf->b_p_gp) == 0;", "}"], "whitespace/alignment"]
["src/nvim/quickfix.c", ["  fname = get_mef_name();", "  if (fname == NULL)", "    return;"], "readability/braces"]
["src/nvim/quickfix.c", ["    name = vim_tempname();", "    if (name == NULL)", "      EMSG(_(e_notmp));"], "readability/braces"]
["src/nvim/quickfix.c", ["", "  for (p = p_mef; *p; ++p)", "    if (p[0] == '#' && p[1] == '#')"], "readability/braces"]
["src/nvim/quickfix.c", ["", "  for (p = p_mef; *p; ++p)", "    if (p[0] == '#' && p[1] == '#')"], "readability/increment"]
["src/nvim/quickfix.c", ["  for (p = p_mef; *p; ++p)", "    if (p[0] == '#' && p[1] == '#')", "      break;"], "readability/braces"]
["src/nvim/quickfix.c", ["", "  if (*p == NUL)", "    return vim_strsave(p_mef);"], "readability/braces"]
["src/nvim/quickfix.c", ["    STRCPY(name, p_mef);", "    sprintf((char *)name + (p - p_mef), \"%d%d\", start, off);", "    STRCAT(name, p + 2);"], "runtime/printf"]
["src/nvim/quickfix.c", ["  buf_T       *buf;", "  int duplicate_name = FALSE;", "  int using_dummy;"], "readability/bool"]
["src/nvim/quickfix.c", ["  int using_dummy;", "  int redraw_for_dummy = FALSE;", "  int found_match;"], "readability/bool"]
["src/nvim/quickfix.c", ["", "  if (eap->addr_count > 0)", "    tomatch = eap->line2;"], "readability/braces"]
["src/nvim/quickfix.c", ["    tomatch = eap->line2;", "  else", "    tomatch = MAXLNUM;"], "readability/braces"]
["src/nvim/quickfix.c", ["      duplicate_name = (buf != NULL);", "      using_dummy = TRUE;", "      redraw_for_dummy = TRUE;"], "readability/bool"]
["src/nvim/quickfix.c", ["      using_dummy = TRUE;", "      redraw_for_dummy = TRUE;", ""], "readability/bool"]
["src/nvim/quickfix.c", ["    if (buf == NULL) {", "      if (!got_int)", "        smsg(_(\"Cannot open file \\\"%s\\\"\"), fname);"], "readability/braces"]
["src/nvim/quickfix.c", ["      if (using_dummy) {", "        if (found_match && first_match_buf == NULL)", "          first_match_buf = buf;"], "readability/braces"]
["src/nvim/quickfix.c", ["          apply_autocmds(EVENT_FILETYPE, buf->b_p_ft,", "              buf->b_fname, TRUE, buf);", "          do_modelines(OPT_NOWIN);"], "whitespace/alignment"]
["src/nvim/quickfix.c", ["          apply_autocmds(EVENT_FILETYPE, buf->b_p_ft,", "              buf->b_fname, TRUE, buf);", "          do_modelines(OPT_NOWIN);"], "readability/bool"]
["src/nvim/quickfix.c", ["", "  if (au_name != NULL)", "    apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,"], "readability/braces"]
["src/nvim/quickfix.c", ["    apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,", "        curbuf->b_fname, TRUE, curbuf);", ""], "whitespace/alignment"]
["src/nvim/quickfix.c", ["    apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,", "        curbuf->b_fname, TRUE, curbuf);", ""], "readability/bool"]
["src/nvim/quickfix.c", ["    }", "  } else", "    EMSG2(_(e_nomatch2), s);"], "readability/braces"]
["src/nvim/quickfix.c", ["static buf_T *", "load_dummy_buffer (", "    char_u *fname,"], "whitespace/parens"]
["src/nvim/quickfix.c", ["        && !(curbuf->b_flags & BF_NEW)) {", "      failed = FALSE;", "      if (curbuf != newbuf) {"], "readability/bool"]
["src/nvim/quickfix.c", ["", "    wipe_buffer(buf, FALSE);", ""], "readability/bool"]
["src/nvim/quickfix.c", ["", "  if (*eap->arg == NUL)", "    buf = curbuf;"], "readability/braces"]
["src/nvim/quickfix.c", ["    buf = curbuf;", "  else if (*skipwhite(skipdigits(eap->arg)) == NUL)", "    buf = buflist_findnr(atoi((char *)eap->arg));"], "readability/braces"]
["src/nvim/quickfix.h", ["", "/* flags for skip_vimgrep_pat() */", "#define VGR_GLOBAL      1"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Handling of regular expressions: vim_regcomp(), vim_regexec(), vim_regsub()"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#ifdef REGEXP_DEBUG", "/* show/save debugging data when BT engine is used */", "# define BT_REGEXP_DUMP"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["# define BT_REGEXP_DUMP", "/* save the debugging data to a file instead of displaying it */", "# define BT_REGEXP_LOG"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * The \"internal use only\" fields in regexp_defs.h are present to pass info from"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Structure for regexp \"program\".  This is essentially a linear encoding"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * The opcodes are:"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/* definition\tnumber\t\t   opnd?    meaning */", "#define END             0       /*\tEnd of program or NOMATCH operand. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/* definition\tnumber\t\t   opnd?    meaning */", "#define END             0       /*\tEnd of program or NOMATCH operand. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["/* definition\tnumber\t\t   opnd?    meaning */", "#define END             0       /*\tEnd of program or NOMATCH operand. */", "#define BOL             1       /*\tMatch \"\" at beginning of line. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["/* definition\tnumber\t\t   opnd?    meaning */", "#define END             0       /*\tEnd of program or NOMATCH operand. */", "#define BOL             1       /*\tMatch \"\" at beginning of line. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define END             0       /*\tEnd of program or NOMATCH operand. */", "#define BOL             1       /*\tMatch \"\" at beginning of line. */", "#define EOL             2       /*\tMatch \"\" at end of line. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define END             0       /*\tEnd of program or NOMATCH operand. */", "#define BOL             1       /*\tMatch \"\" at beginning of line. */", "#define EOL             2       /*\tMatch \"\" at end of line. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define BOL             1       /*\tMatch \"\" at beginning of line. */", "#define EOL             2       /*\tMatch \"\" at end of line. */", "#define BRANCH          3       /* node Match this alternative, or the"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define BOL             1       /*\tMatch \"\" at beginning of line. */", "#define EOL             2       /*\tMatch \"\" at end of line. */", "#define BRANCH          3       /* node Match this alternative, or the"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define EOL             2       /*\tMatch \"\" at end of line. */", "#define BRANCH          3       /* node Match this alternative, or the", "                                 *\tnext... */"], "readability/multiline_comment"]
["src/nvim/regexp.c", ["#define EOL             2       /*\tMatch \"\" at end of line. */", "#define BRANCH          3       /* node Match this alternative, or the", "                                 *\tnext... */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define BRANCH          3       /* node Match this alternative, or the", "                                 *\tnext... */", "#define BACK            4       /*\tMatch \"\", \"next\" ptr points backward. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["                                 *\tnext... */", "#define BACK            4       /*\tMatch \"\", \"next\" ptr points backward. */", "#define EXACTLY         5       /* str\tMatch this string. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["                                 *\tnext... */", "#define BACK            4       /*\tMatch \"\", \"next\" ptr points backward. */", "#define EXACTLY         5       /* str\tMatch this string. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define BACK            4       /*\tMatch \"\", \"next\" ptr points backward. */", "#define EXACTLY         5       /* str\tMatch this string. */", "#define NOTHING         6       /*\tMatch empty string. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define BACK            4       /*\tMatch \"\", \"next\" ptr points backward. */", "#define EXACTLY         5       /* str\tMatch this string. */", "#define NOTHING         6       /*\tMatch empty string. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define EXACTLY         5       /* str\tMatch this string. */", "#define NOTHING         6       /*\tMatch empty string. */", "#define STAR            7       /* node Match this (simple) thing 0 or more"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define EXACTLY         5       /* str\tMatch this string. */", "#define NOTHING         6       /*\tMatch empty string. */", "#define STAR            7       /* node Match this (simple) thing 0 or more"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NOTHING         6       /*\tMatch empty string. */", "#define STAR            7       /* node Match this (simple) thing 0 or more", "                                 *\ttimes. */"], "readability/multiline_comment"]
["src/nvim/regexp.c", ["#define NOTHING         6       /*\tMatch empty string. */", "#define STAR            7       /* node Match this (simple) thing 0 or more", "                                 *\ttimes. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define STAR            7       /* node Match this (simple) thing 0 or more", "                                 *\ttimes. */", "#define PLUS            8       /* node Match this (simple) thing 1 or more"], "whitespace/tab"]
["src/nvim/regexp.c", ["                                 *\ttimes. */", "#define PLUS            8       /* node Match this (simple) thing 1 or more", "                                 *\ttimes. */"], "readability/multiline_comment"]
["src/nvim/regexp.c", ["                                 *\ttimes. */", "#define PLUS            8       /* node Match this (simple) thing 1 or more", "                                 *\ttimes. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define PLUS            8       /* node Match this (simple) thing 1 or more", "                                 *\ttimes. */", "#define MATCH           9       /* node match the operand zero-width */"], "whitespace/tab"]
["src/nvim/regexp.c", ["                                 *\ttimes. */", "#define MATCH           9       /* node match the operand zero-width */", "#define NOMATCH         10      /* node check for no match with operand */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define MATCH           9       /* node match the operand zero-width */", "#define NOMATCH         10      /* node check for no match with operand */", "#define BEHIND          11      /* node look behind for a match with operand */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define NOMATCH         10      /* node check for no match with operand */", "#define BEHIND          11      /* node look behind for a match with operand */", "#define NOBEHIND        12      /* node look behind for no match with operand */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define BEHIND          11      /* node look behind for a match with operand */", "#define NOBEHIND        12      /* node look behind for no match with operand */", "#define SUBPAT          13      /* node match the operand here */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define NOBEHIND        12      /* node look behind for no match with operand */", "#define SUBPAT          13      /* node match the operand here */", "#define BRACE_SIMPLE    14      /* node Match this (simple) thing between m and"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define SUBPAT          13      /* node match the operand here */", "#define BRACE_SIMPLE    14      /* node Match this (simple) thing between m and", "                                 *\tn times (\\{m,n\\}). */"], "readability/multiline_comment"]
["src/nvim/regexp.c", ["#define SUBPAT          13      /* node match the operand here */", "#define BRACE_SIMPLE    14      /* node Match this (simple) thing between m and", "                                 *\tn times (\\{m,n\\}). */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define BRACE_SIMPLE    14      /* node Match this (simple) thing between m and", "                                 *\tn times (\\{m,n\\}). */", "#define BOW             15      /*\tMatch \"\" after [^a-zA-Z0-9_] */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define BRACE_SIMPLE    14      /* node Match this (simple) thing between m and", "                                 *\tn times (\\{m,n\\}). */", "#define BOW             15      /*\tMatch \"\" after [^a-zA-Z0-9_] */"], "whitespace/comma"]
["src/nvim/regexp.c", ["#define BRACE_SIMPLE    14      /* node Match this (simple) thing between m and", "                                 *\tn times (\\{m,n\\}). */", "#define BOW             15      /*\tMatch \"\" after [^a-zA-Z0-9_] */"], "whitespace/parens"]
["src/nvim/regexp.c", ["#define BRACE_SIMPLE    14      /* node Match this (simple) thing between m and", "                                 *\tn times (\\{m,n\\}). */", "#define BOW             15      /*\tMatch \"\" after [^a-zA-Z0-9_] */"], "whitespace/braces"]
["src/nvim/regexp.c", ["#define BRACE_SIMPLE    14      /* node Match this (simple) thing between m and", "                                 *\tn times (\\{m,n\\}). */", "#define BOW             15      /*\tMatch \"\" after [^a-zA-Z0-9_] */"], "whitespace/braces"]
["src/nvim/regexp.c", ["                                 *\tn times (\\{m,n\\}). */", "#define BOW             15      /*\tMatch \"\" after [^a-zA-Z0-9_] */", "#define EOW             16      /*\tMatch \"\" at    [^a-zA-Z0-9_] */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["                                 *\tn times (\\{m,n\\}). */", "#define BOW             15      /*\tMatch \"\" after [^a-zA-Z0-9_] */", "#define EOW             16      /*\tMatch \"\" at    [^a-zA-Z0-9_] */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define BOW             15      /*\tMatch \"\" after [^a-zA-Z0-9_] */", "#define EOW             16      /*\tMatch \"\" at    [^a-zA-Z0-9_] */", "#define BRACE_LIMITS    17      /* nr nr  define the min & max for BRACE_SIMPLE"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define BOW             15      /*\tMatch \"\" after [^a-zA-Z0-9_] */", "#define EOW             16      /*\tMatch \"\" at    [^a-zA-Z0-9_] */", "#define BRACE_LIMITS    17      /* nr nr  define the min & max for BRACE_SIMPLE"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define EOW             16      /*\tMatch \"\" at    [^a-zA-Z0-9_] */", "#define BRACE_LIMITS    17      /* nr nr  define the min & max for BRACE_SIMPLE", "                                 *\tand BRACE_COMPLEX. */"], "readability/multiline_comment"]
["src/nvim/regexp.c", ["#define EOW             16      /*\tMatch \"\" at    [^a-zA-Z0-9_] */", "#define BRACE_LIMITS    17      /* nr nr  define the min & max for BRACE_SIMPLE", "                                 *\tand BRACE_COMPLEX. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define BRACE_LIMITS    17      /* nr nr  define the min & max for BRACE_SIMPLE", "                                 *\tand BRACE_COMPLEX. */", "#define NEWL            18      /*\tMatch line-break */"], "whitespace/tab"]
["src/nvim/regexp.c", ["                                 *\tand BRACE_COMPLEX. */", "#define NEWL            18      /*\tMatch line-break */", "#define BHPOS           19      /*\tEnd position for BEHIND or NOBEHIND */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["                                 *\tand BRACE_COMPLEX. */", "#define NEWL            18      /*\tMatch line-break */", "#define BHPOS           19      /*\tEnd position for BEHIND or NOBEHIND */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NEWL            18      /*\tMatch line-break */", "#define BHPOS           19      /*\tEnd position for BEHIND or NOBEHIND */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define NEWL            18      /*\tMatch line-break */", "#define BHPOS           19      /*\tEnd position for BEHIND or NOBEHIND */", ""], "whitespace/tab"]
["src/nvim/regexp.c", ["", "/* character classes: 20-48 normal, 50-78 include a line-break */", "#define ADD_NL          30"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define FIRST_NL        ANY + ADD_NL", "#define ANY             20      /*\tMatch any one character. */", "#define ANYOF           21      /* str\tMatch any character in this string. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define FIRST_NL        ANY + ADD_NL", "#define ANY             20      /*\tMatch any one character. */", "#define ANYOF           21      /* str\tMatch any character in this string. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define ANY             20      /*\tMatch any one character. */", "#define ANYOF           21      /* str\tMatch any character in this string. */", "#define ANYBUT          22      /* str\tMatch any character not in this"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define ANY             20      /*\tMatch any one character. */", "#define ANYOF           21      /* str\tMatch any character in this string. */", "#define ANYBUT          22      /* str\tMatch any character not in this"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define ANYOF           21      /* str\tMatch any character in this string. */", "#define ANYBUT          22      /* str\tMatch any character not in this", "                                 *\tstring. */"], "readability/multiline_comment"]
["src/nvim/regexp.c", ["#define ANYOF           21      /* str\tMatch any character in this string. */", "#define ANYBUT          22      /* str\tMatch any character not in this", "                                 *\tstring. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define ANYOF           21      /* str\tMatch any character in this string. */", "#define ANYBUT          22      /* str\tMatch any character not in this", "                                 *\tstring. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define ANYBUT          22      /* str\tMatch any character not in this", "                                 *\tstring. */", "#define IDENT           23      /*\tMatch identifier char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["                                 *\tstring. */", "#define IDENT           23      /*\tMatch identifier char */", "#define SIDENT          24      /*\tMatch identifier char but no digit */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["                                 *\tstring. */", "#define IDENT           23      /*\tMatch identifier char */", "#define SIDENT          24      /*\tMatch identifier char but no digit */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define IDENT           23      /*\tMatch identifier char */", "#define SIDENT          24      /*\tMatch identifier char but no digit */", "#define KWORD           25      /*\tMatch keyword char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define IDENT           23      /*\tMatch identifier char */", "#define SIDENT          24      /*\tMatch identifier char but no digit */", "#define KWORD           25      /*\tMatch keyword char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define SIDENT          24      /*\tMatch identifier char but no digit */", "#define KWORD           25      /*\tMatch keyword char */", "#define SKWORD          26      /*\tMatch word char but no digit */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define SIDENT          24      /*\tMatch identifier char but no digit */", "#define KWORD           25      /*\tMatch keyword char */", "#define SKWORD          26      /*\tMatch word char but no digit */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define KWORD           25      /*\tMatch keyword char */", "#define SKWORD          26      /*\tMatch word char but no digit */", "#define FNAME           27      /*\tMatch file name char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define KWORD           25      /*\tMatch keyword char */", "#define SKWORD          26      /*\tMatch word char but no digit */", "#define FNAME           27      /*\tMatch file name char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define SKWORD          26      /*\tMatch word char but no digit */", "#define FNAME           27      /*\tMatch file name char */", "#define SFNAME          28      /*\tMatch file name char but no digit */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define SKWORD          26      /*\tMatch word char but no digit */", "#define FNAME           27      /*\tMatch file name char */", "#define SFNAME          28      /*\tMatch file name char but no digit */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define FNAME           27      /*\tMatch file name char */", "#define SFNAME          28      /*\tMatch file name char but no digit */", "#define PRINT           29      /*\tMatch printable char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define FNAME           27      /*\tMatch file name char */", "#define SFNAME          28      /*\tMatch file name char but no digit */", "#define PRINT           29      /*\tMatch printable char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define SFNAME          28      /*\tMatch file name char but no digit */", "#define PRINT           29      /*\tMatch printable char */", "#define SPRINT          30      /*\tMatch printable char but no digit */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define SFNAME          28      /*\tMatch file name char but no digit */", "#define PRINT           29      /*\tMatch printable char */", "#define SPRINT          30      /*\tMatch printable char but no digit */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define PRINT           29      /*\tMatch printable char */", "#define SPRINT          30      /*\tMatch printable char but no digit */", "#define WHITE           31      /*\tMatch whitespace char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define PRINT           29      /*\tMatch printable char */", "#define SPRINT          30      /*\tMatch printable char but no digit */", "#define WHITE           31      /*\tMatch whitespace char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define SPRINT          30      /*\tMatch printable char but no digit */", "#define WHITE           31      /*\tMatch whitespace char */", "#define NWHITE          32      /*\tMatch non-whitespace char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define SPRINT          30      /*\tMatch printable char but no digit */", "#define WHITE           31      /*\tMatch whitespace char */", "#define NWHITE          32      /*\tMatch non-whitespace char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define WHITE           31      /*\tMatch whitespace char */", "#define NWHITE          32      /*\tMatch non-whitespace char */", "#define DIGIT           33      /*\tMatch digit char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define WHITE           31      /*\tMatch whitespace char */", "#define NWHITE          32      /*\tMatch non-whitespace char */", "#define DIGIT           33      /*\tMatch digit char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NWHITE          32      /*\tMatch non-whitespace char */", "#define DIGIT           33      /*\tMatch digit char */", "#define NDIGIT          34      /*\tMatch non-digit char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define NWHITE          32      /*\tMatch non-whitespace char */", "#define DIGIT           33      /*\tMatch digit char */", "#define NDIGIT          34      /*\tMatch non-digit char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define DIGIT           33      /*\tMatch digit char */", "#define NDIGIT          34      /*\tMatch non-digit char */", "#define HEX             35      /*\tMatch hex char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define DIGIT           33      /*\tMatch digit char */", "#define NDIGIT          34      /*\tMatch non-digit char */", "#define HEX             35      /*\tMatch hex char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NDIGIT          34      /*\tMatch non-digit char */", "#define HEX             35      /*\tMatch hex char */", "#define NHEX            36      /*\tMatch non-hex char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define NDIGIT          34      /*\tMatch non-digit char */", "#define HEX             35      /*\tMatch hex char */", "#define NHEX            36      /*\tMatch non-hex char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define HEX             35      /*\tMatch hex char */", "#define NHEX            36      /*\tMatch non-hex char */", "#define OCTAL           37      /*\tMatch octal char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define HEX             35      /*\tMatch hex char */", "#define NHEX            36      /*\tMatch non-hex char */", "#define OCTAL           37      /*\tMatch octal char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NHEX            36      /*\tMatch non-hex char */", "#define OCTAL           37      /*\tMatch octal char */", "#define NOCTAL          38      /*\tMatch non-octal char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define NHEX            36      /*\tMatch non-hex char */", "#define OCTAL           37      /*\tMatch octal char */", "#define NOCTAL          38      /*\tMatch non-octal char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define OCTAL           37      /*\tMatch octal char */", "#define NOCTAL          38      /*\tMatch non-octal char */", "#define WORD            39      /*\tMatch word char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define OCTAL           37      /*\tMatch octal char */", "#define NOCTAL          38      /*\tMatch non-octal char */", "#define WORD            39      /*\tMatch word char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NOCTAL          38      /*\tMatch non-octal char */", "#define WORD            39      /*\tMatch word char */", "#define NWORD           40      /*\tMatch non-word char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define NOCTAL          38      /*\tMatch non-octal char */", "#define WORD            39      /*\tMatch word char */", "#define NWORD           40      /*\tMatch non-word char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define WORD            39      /*\tMatch word char */", "#define NWORD           40      /*\tMatch non-word char */", "#define HEAD            41      /*\tMatch head char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define WORD            39      /*\tMatch word char */", "#define NWORD           40      /*\tMatch non-word char */", "#define HEAD            41      /*\tMatch head char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NWORD           40      /*\tMatch non-word char */", "#define HEAD            41      /*\tMatch head char */", "#define NHEAD           42      /*\tMatch non-head char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define NWORD           40      /*\tMatch non-word char */", "#define HEAD            41      /*\tMatch head char */", "#define NHEAD           42      /*\tMatch non-head char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define HEAD            41      /*\tMatch head char */", "#define NHEAD           42      /*\tMatch non-head char */", "#define ALPHA           43      /*\tMatch alpha char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define HEAD            41      /*\tMatch head char */", "#define NHEAD           42      /*\tMatch non-head char */", "#define ALPHA           43      /*\tMatch alpha char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NHEAD           42      /*\tMatch non-head char */", "#define ALPHA           43      /*\tMatch alpha char */", "#define NALPHA          44      /*\tMatch non-alpha char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define NHEAD           42      /*\tMatch non-head char */", "#define ALPHA           43      /*\tMatch alpha char */", "#define NALPHA          44      /*\tMatch non-alpha char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define ALPHA           43      /*\tMatch alpha char */", "#define NALPHA          44      /*\tMatch non-alpha char */", "#define LOWER           45      /*\tMatch lowercase char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define ALPHA           43      /*\tMatch alpha char */", "#define NALPHA          44      /*\tMatch non-alpha char */", "#define LOWER           45      /*\tMatch lowercase char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NALPHA          44      /*\tMatch non-alpha char */", "#define LOWER           45      /*\tMatch lowercase char */", "#define NLOWER          46      /*\tMatch non-lowercase char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define NALPHA          44      /*\tMatch non-alpha char */", "#define LOWER           45      /*\tMatch lowercase char */", "#define NLOWER          46      /*\tMatch non-lowercase char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define LOWER           45      /*\tMatch lowercase char */", "#define NLOWER          46      /*\tMatch non-lowercase char */", "#define UPPER           47      /*\tMatch uppercase char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define LOWER           45      /*\tMatch lowercase char */", "#define NLOWER          46      /*\tMatch non-lowercase char */", "#define UPPER           47      /*\tMatch uppercase char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NLOWER          46      /*\tMatch non-lowercase char */", "#define UPPER           47      /*\tMatch uppercase char */", "#define NUPPER          48      /*\tMatch non-uppercase char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define NLOWER          46      /*\tMatch non-lowercase char */", "#define UPPER           47      /*\tMatch uppercase char */", "#define NUPPER          48      /*\tMatch non-uppercase char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define UPPER           47      /*\tMatch uppercase char */", "#define NUPPER          48      /*\tMatch non-uppercase char */", "#define LAST_NL         NUPPER + ADD_NL"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define UPPER           47      /*\tMatch uppercase char */", "#define NUPPER          48      /*\tMatch non-uppercase char */", "#define LAST_NL         NUPPER + ADD_NL"], "whitespace/tab"]
["src/nvim/regexp.c", ["", "#define BRACE_COMPLEX   140 /* -149 node Match nodes between m & n times */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "#define MULTIBYTECODE   200     /* mbc\tMatch one multi-byte character */", "#define RE_BOF          201     /*\tMatch \"\" at beginning of file. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "#define MULTIBYTECODE   200     /* mbc\tMatch one multi-byte character */", "#define RE_BOF          201     /*\tMatch \"\" at beginning of file. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define MULTIBYTECODE   200     /* mbc\tMatch one multi-byte character */", "#define RE_BOF          201     /*\tMatch \"\" at beginning of file. */", "#define RE_EOF          202     /*\tMatch \"\" at end of file. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define MULTIBYTECODE   200     /* mbc\tMatch one multi-byte character */", "#define RE_BOF          201     /*\tMatch \"\" at beginning of file. */", "#define RE_EOF          202     /*\tMatch \"\" at end of file. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define RE_BOF          201     /*\tMatch \"\" at beginning of file. */", "#define RE_EOF          202     /*\tMatch \"\" at end of file. */", "#define CURSOR          203     /*\tMatch location of cursor. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define RE_BOF          201     /*\tMatch \"\" at beginning of file. */", "#define RE_EOF          202     /*\tMatch \"\" at end of file. */", "#define CURSOR          203     /*\tMatch location of cursor. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define RE_EOF          202     /*\tMatch \"\" at end of file. */", "#define CURSOR          203     /*\tMatch location of cursor. */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define RE_EOF          202     /*\tMatch \"\" at end of file. */", "#define CURSOR          203     /*\tMatch location of cursor. */", ""], "whitespace/tab"]
["src/nvim/regexp.c", ["", "#define RE_LNUM         204     /* nr cmp  Match line number */", "#define RE_COL          205     /* nr cmp  Match column number */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define RE_LNUM         204     /* nr cmp  Match line number */", "#define RE_COL          205     /* nr cmp  Match column number */", "#define RE_VCOL         206     /* nr cmp  Match virtual column number */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define RE_COL          205     /* nr cmp  Match column number */", "#define RE_VCOL         206     /* nr cmp  Match virtual column number */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "#define RE_MARK         207     /* mark cmp  Match mark position */", "#define RE_VISUAL       208     /*\tMatch Visual area */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define RE_MARK         207     /* mark cmp  Match mark position */", "#define RE_VISUAL       208     /*\tMatch Visual area */", "#define RE_COMPOSING    209     // any composing characters"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define RE_MARK         207     /* mark cmp  Match mark position */", "#define RE_VISUAL       208     /*\tMatch Visual area */", "#define RE_COMPOSING    209     // any composing characters"], "whitespace/tab"]
["src/nvim/regexp.c", ["", "/*", " * Magic characters have a special meaning, they don't match literally."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * We should define ftpr as a pointer to a function returning a pointer to"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Structure used to save the current input state, when it needs to be"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/* struct to save start/end pointer/position in for \\(\\) */", "typedef struct {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/* used for BEHIND and NOBEHIND matching */", "typedef struct regbehind_S {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/* Values for rs_state in regitem_T. */", "typedef enum regstate_E {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["typedef enum regstate_E {", "  RS_NOPEN = 0          /* NOPEN and NCLOSE */", "  , RS_MOPEN            /* MOPEN + [0-9] */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  RS_NOPEN = 0          /* NOPEN and NCLOSE */", "  , RS_MOPEN            /* MOPEN + [0-9] */", "  , RS_MCLOSE           /* MCLOSE + [0-9] */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  , RS_MOPEN            /* MOPEN + [0-9] */", "  , RS_MCLOSE           /* MCLOSE + [0-9] */", "  , RS_ZOPEN            /* ZOPEN + [0-9] */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  , RS_MCLOSE           /* MCLOSE + [0-9] */", "  , RS_ZOPEN            /* ZOPEN + [0-9] */", "  , RS_ZCLOSE           /* ZCLOSE + [0-9] */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  , RS_ZOPEN            /* ZOPEN + [0-9] */", "  , RS_ZCLOSE           /* ZCLOSE + [0-9] */", "  , RS_BRANCH           /* BRANCH */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  , RS_ZCLOSE           /* ZCLOSE + [0-9] */", "  , RS_BRANCH           /* BRANCH */", "  , RS_BRCPLX_MORE      /* BRACE_COMPLEX and trying one more match */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  , RS_BRANCH           /* BRANCH */", "  , RS_BRCPLX_MORE      /* BRACE_COMPLEX and trying one more match */", "  , RS_BRCPLX_LONG      /* BRACE_COMPLEX and trying longest match */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  , RS_BRCPLX_MORE      /* BRACE_COMPLEX and trying one more match */", "  , RS_BRCPLX_LONG      /* BRACE_COMPLEX and trying longest match */", "  , RS_BRCPLX_SHORT     /* BRACE_COMPLEX and trying shortest match */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  , RS_BRCPLX_LONG      /* BRACE_COMPLEX and trying longest match */", "  , RS_BRCPLX_SHORT     /* BRACE_COMPLEX and trying shortest match */", "  , RS_NOMATCH          /* NOMATCH */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  , RS_BRCPLX_SHORT     /* BRACE_COMPLEX and trying shortest match */", "  , RS_NOMATCH          /* NOMATCH */", "  , RS_BEHIND1          /* BEHIND / NOBEHIND matching rest */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  , RS_NOMATCH          /* NOMATCH */", "  , RS_BEHIND1          /* BEHIND / NOBEHIND matching rest */", "  , RS_BEHIND2          /* BEHIND / NOBEHIND matching behind part */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  , RS_BEHIND1          /* BEHIND / NOBEHIND matching rest */", "  , RS_BEHIND2          /* BEHIND / NOBEHIND matching behind part */", "  , RS_STAR_LONG        /* STAR/PLUS/BRACE_SIMPLE longest match */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  , RS_BEHIND2          /* BEHIND / NOBEHIND matching behind part */", "  , RS_STAR_LONG        /* STAR/PLUS/BRACE_SIMPLE longest match */", "  , RS_STAR_SHORT       /* STAR/PLUS/BRACE_SIMPLE shortest match */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  , RS_STAR_LONG        /* STAR/PLUS/BRACE_SIMPLE longest match */", "  , RS_STAR_SHORT       /* STAR/PLUS/BRACE_SIMPLE shortest match */", "} regstate_T;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * When there are alternatives a regstate_T is put on the regstack to remember"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/* used for STAR, PLUS and BRACE_SIMPLE matching */", "typedef struct regstar_S {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["typedef struct regstar_S {", "  int nextb;                    /* next byte */", "  int nextb_ic;                 /* next byte reverse case */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  int nextb;                    /* next byte */", "  int nextb_ic;                 /* next byte reverse case */", "  long count;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/* used to store input position when a BACK was encountered, so that we now if", " * we made any progress since the last time. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["typedef struct backpos_S {", "  char_u      *bp_scan;         /* \"scan\" where BACK was encountered */", "  regsave_T bp_pos;             /* last input position */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  char_u      *bp_scan;         /* \"scan\" where BACK was encountered */", "  regsave_T bp_pos;             /* last input position */", "} backpos_T;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["{", "  if (is_Magic(x))", "    return un_Magic(x);"], "readability/braces"]
["src/nvim/regexp.c", ["{", "  if (is_Magic(x))", "    return un_Magic(x);"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * The first byte of the regexp internal \"program\" is actually this magic"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Opcode notes:"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * A node is one char of opcode followed by two chars of \"next\" pointer."], "readability/old_style_comment"]
["src/nvim/regexp.c", [" */", "#define OP(p)           ((int)*(p))", "#define NEXT(p)         (((*((p) + 1) & 0377) << 8) + (*((p) + 2) & 0377))"], "whitespace/operators"]
["src/nvim/regexp.c", ["#define OPERAND(p)      ((p) + 3)", "/* Obtain an operand that was stored as four bytes, MSB first. */", "#define OPERAND_MIN(p)  (((long)(p)[3] << 24) + ((long)(p)[4] << 16) \\"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["                         + ((long)(p)[5] << 8) + (long)(p)[6])", "/* Obtain a second operand stored as four bytes. */", "#define OPERAND_MAX(p)  OPERAND_MIN((p) + 4)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define OPERAND_MAX(p)  OPERAND_MIN((p) + 4)", "/* Obtain a second single-byte operand stored after a four bytes operand. */", "#define OPERAND_CMP(p)  (p)[7]"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Utility definitions."], "readability/old_style_comment"]
["src/nvim/regexp.c", [" */", "#define UCHARAT(p)      ((int)*(char_u *)(p))", ""], "whitespace/operators"]
["src/nvim/regexp.c", ["", "/* Used for an error (down from) vim_regcomp(): give the error message, set", " * rc_did_emsg and return NULL */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define MULTI_MULT      2", "/*", " * Return NOT_MULTI if c is not a \"multi\" operator."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["{", "  if (c == Magic('@') || c == Magic('=') || c == Magic('?'))", "    return MULTI_ONE;"], "readability/braces"]
["src/nvim/regexp.c", ["    return MULTI_ONE;", "  if (c == Magic('*') || c == Magic('+') || c == Magic('{'))", "    return MULTI_MULT;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Flags to be passed up and down."], "readability/old_style_comment"]
["src/nvim/regexp.c", [" */", "#define HASWIDTH        0x1     /* Known never to match null string. */", "#define SIMPLE          0x2     /* Simple enough to be STAR/PLUS operand. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define HASWIDTH        0x1     /* Known never to match null string. */", "#define SIMPLE          0x2     /* Simple enough to be STAR/PLUS operand. */", "#define SPSTART         0x4     /* Starts with * or +. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define SIMPLE          0x2     /* Simple enough to be STAR/PLUS operand. */", "#define SPSTART         0x4     /* Starts with * or +. */", "#define HASNL           0x8     /* Contains some \\n. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define SPSTART         0x4     /* Starts with * or +. */", "#define HASNL           0x8     /* Contains some \\n. */", "#define HASLOOKBH       0x10    /* Contains \"\\@<=\" or \"\\@<!\". */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define HASNL           0x8     /* Contains some \\n. */", "#define HASLOOKBH       0x10    /* Contains \"\\@<=\" or \"\\@<!\". */", "#define WORST           0       /* Worst case. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define HASLOOKBH       0x10    /* Contains \"\\@<=\" or \"\\@<!\". */", "#define WORST           0       /* Worst case. */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * When regcode is set to this value, code is not emitted and size is computed"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * REGEXP_INRANGE contains all characters which are always special in a []"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Translate '\\x' to its control character, except \"\\n\", which is Magic."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Check for a character class name \"[:name:]\".  \"pp\" points to the '['."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  static const char *(class_names[]) =", "  {", "    \"alnum:]\","], "whitespace/braces"]
["src/nvim/regexp.c", ["  if ((*pp)[1] == ':') {", "    for (i = 0; i < (int)ARRAY_SIZE(class_names); ++i)", "      if (STRNCMP(*pp + 2, class_names[i], STRLEN(class_names[i])) == 0) {"], "readability/braces"]
["src/nvim/regexp.c", ["  if ((*pp)[1] == ':') {", "    for (i = 0; i < (int)ARRAY_SIZE(class_names); ++i)", "      if (STRNCMP(*pp + 2, class_names[i], STRLEN(class_names[i])) == 0) {"], "readability/increment"]
["src/nvim/regexp.c", ["", "/*", " * Specific version of character class functions."], "readability/old_style_comment"]
["src/nvim/regexp.c", [" */", "static short class_tab[256];", ""], "runtime/int"]
["src/nvim/regexp.c", ["", "  if (done)", "    return;"], "readability/braces"]
["src/nvim/regexp.c", ["", "  for (i = 0; i < 256; ++i) {", "    if (i >= '0' && i <= '7')"], "readability/increment"]
["src/nvim/regexp.c", ["  for (i = 0; i < 256; ++i) {", "    if (i >= '0' && i <= '7')", "      class_tab[i] = RI_DIGIT + RI_HEX + RI_OCTAL + RI_WORD;"], "readability/braces"]
["src/nvim/regexp.c", ["      class_tab[i] = RI_DIGIT + RI_HEX + RI_OCTAL + RI_WORD;", "    else if (i >= '8' && i <= '9')", "      class_tab[i] = RI_DIGIT + RI_HEX + RI_WORD;"], "readability/braces"]
["src/nvim/regexp.c", ["      class_tab[i] = RI_DIGIT + RI_HEX + RI_WORD;", "    else if (i >= 'a' && i <= 'f')", "      class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;"], "readability/braces"]
["src/nvim/regexp.c", ["      class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;", "    else if (i >= 'g' && i <= 'z')", "      class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;"], "readability/braces"]
["src/nvim/regexp.c", ["      class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;", "    else if (i >= 'A' && i <= 'F')", "      class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;"], "readability/braces"]
["src/nvim/regexp.c", ["      class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;", "    else if (i >= 'G' && i <= 'Z')", "      class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;"], "readability/braces"]
["src/nvim/regexp.c", ["      class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;", "    else if (i == '_')", "      class_tab[i] = RI_WORD + RI_HEAD;"], "readability/braces"]
["src/nvim/regexp.c", ["      class_tab[i] = RI_WORD + RI_HEAD;", "    else", "      class_tab[i] = 0;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/* flags for regflags */", "#define RF_ICASE    1   /* ignore case */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["/* flags for regflags */", "#define RF_ICASE    1   /* ignore case */", "#define RF_NOICASE  2   /* don't ignore case */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define RF_ICASE    1   /* ignore case */", "#define RF_NOICASE  2   /* don't ignore case */", "#define RF_HASNL    4   /* can match a NL */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define RF_NOICASE  2   /* don't ignore case */", "#define RF_HASNL    4   /* can match a NL */", "#define RF_ICOMBINE 8   /* ignore combining characters */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define RF_HASNL    4   /* can match a NL */", "#define RF_ICOMBINE 8   /* ignore combining characters */", "#define RF_LOOKBH   16  /* uses \"\\@<=\" or \"\\@<!\" */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define RF_ICOMBINE 8   /* ignore combining characters */", "#define RF_LOOKBH   16  /* uses \"\\@<=\" or \"\\@<!\" */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "static int reg_magic;           /* magicness of the pattern: */", "#define MAGIC_NONE      1       /* \"\\V\" very unmagic */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["static int reg_magic;           /* magicness of the pattern: */", "#define MAGIC_NONE      1       /* \"\\V\" very unmagic */", "#define MAGIC_OFF       2       /* \"\\M\" or 'magic' off */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define MAGIC_NONE      1       /* \"\\V\" very unmagic */", "#define MAGIC_OFF       2       /* \"\\M\" or 'magic' off */", "#define MAGIC_ON        3       /* \"\\m\" or 'magic' */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define MAGIC_OFF       2       /* \"\\M\" or 'magic' off */", "#define MAGIC_ON        3       /* \"\\m\" or 'magic' */", "#define MAGIC_ALL       4       /* \"\\v\" very magic */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define MAGIC_ON        3       /* \"\\m\" or 'magic' */", "#define MAGIC_ALL       4       /* \"\\v\" very magic */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "static int reg_string;          /* matching with a string instead of a buffer", "                                   line */"], "readability/multiline_comment"]
["src/nvim/regexp.c", ["", "static int reg_string;          /* matching with a string instead of a buffer", "                                   line */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["                                   line */", "static int reg_strict;          /* \"[abc\" is illegal */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * META contains all characters that may be magic, except '^' and '$'."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/* META[] is used often enough to justify turning it into a table. */", "static char_u META_flags[] = {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,", "  /*\t\t   %  &     (  )  *  +\t      .    */", "  0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0,"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,", "  /*\t\t   %  &     (  )  *  +\t      .    */", "  0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0,"], "whitespace/tab"]
["src/nvim/regexp.c", ["  0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0,", "  /*     1  2  3\t4  5  6  7  8  9\t<  =  >  ? */", "  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0,", "  /*     1  2  3\t4  5  6  7  8  9\t<  =  >  ? */", "  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,"], "whitespace/tab"]
["src/nvim/regexp.c", ["  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,", "  /*  @  A     C\tD     F     H  I     K\tL  M\t O */", "  1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1,"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,", "  /*  @  A     C\tD     F     H  I     K\tL  M\t O */", "  1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1,"], "whitespace/tab"]
["src/nvim/regexp.c", ["  1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1,", "  /*  P\t     S\t   U  V  W  X\t  Z  [\t\t _ */", "  1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1,"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1,", "  /*  P\t     S\t   U  V  W  X\t  Z  [\t\t _ */", "  1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1,"], "whitespace/tab"]
["src/nvim/regexp.c", ["  1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1,", "  /*     a     c\td     f     h  i     k\tl  m  n  o */", "  0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1,"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1,", "  /*     a     c\td     f     h  i     k\tl  m  n  o */", "  0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1,"], "whitespace/tab"]
["src/nvim/regexp.c", ["  0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1,", "  /*  p\t     s\t   u  v  w  x\t  z  {\t|     ~    */", "  1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1,", "  /*  p\t     s\t   u  v  w  x\t  z  {\t|     ~    */", "  1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1"], "whitespace/tab"]
["src/nvim/regexp.c", ["", "static int curchr;              /* currently parsed character */", "/* Previous character.  Note: prevchr is sometimes -1 when we are not at the"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["static int curchr;              /* currently parsed character */", "/* Previous character.  Note: prevchr is sometimes -1 when we are not at the", " * start, eg in /[ ^I]^ the pattern was never found even if it existed,"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["static int prevchr;", "static int prevprevchr;         /* previous-previous character */", "static int nextchr;             /* used for ungetchr() */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["static int prevprevchr;         /* previous-previous character */", "static int nextchr;             /* used for ungetchr() */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/* arguments for reg() */", "#define REG_NOPAREN     0       /* toplevel reg() */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["/* arguments for reg() */", "#define REG_NOPAREN     0       /* toplevel reg() */", "#define REG_PAREN       1       /* \\(\\) */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define REG_NOPAREN     0       /* toplevel reg() */", "#define REG_PAREN       1       /* \\(\\) */", "#define REG_ZPAREN      2       /* \\z(\\) */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define REG_PAREN       1       /* \\(\\) */", "#define REG_ZPAREN      2       /* \\z(\\) */", "#define REG_NPAREN      3       /* \\%(\\) */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define REG_ZPAREN      2       /* \\z(\\) */", "#define REG_NPAREN      3       /* \\%(\\) */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Forward declarations for vim_regcomp()'s friends."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Check for an equivalence class name \"[=a=]\".  \"pp\" points to the '['."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Produce the bytes for equivalence class \"c\"."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      CASEMBC(0x1de) CASEMBC(0x1e0) CASEMBC(0x1ea2)", "      regmbc('A'); regmbc(0xc0); regmbc(0xc1);", "      regmbc(0xc2); regmbc(0xc3); regmbc(0xc4);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('A'); regmbc(0xc0); regmbc(0xc1);", "      regmbc(0xc2); regmbc(0xc3); regmbc(0xc4);", "      regmbc(0xc5);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x106) CASEMBC(0x108) CASEMBC(0x10a) CASEMBC(0x10c)", "      regmbc('C'); regmbc(0xc7);", "      REGMBC(0x106) REGMBC(0x108) REGMBC(0x10a)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x11a) CASEMBC(0x1eba) CASEMBC(0x1ebc)", "      regmbc('E'); regmbc(0xc8); regmbc(0xc9);", "      regmbc(0xca); regmbc(0xcb);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('E'); regmbc(0xc8); regmbc(0xc9);", "      regmbc(0xca); regmbc(0xcb);", "      REGMBC(0x112) REGMBC(0x114) REGMBC(0x116)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x130) CASEMBC(0x1cf) CASEMBC(0x1ec8)", "      regmbc('I'); regmbc(0xcc); regmbc(0xcd);", "      regmbc(0xce); regmbc(0xcf);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('I'); regmbc(0xcc); regmbc(0xcd);", "      regmbc(0xce); regmbc(0xcf);", "      REGMBC(0x128) REGMBC(0x12a) REGMBC(0x12c)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1e48)", "      regmbc('N'); regmbc(0xd1);", "      REGMBC(0x143) REGMBC(0x145) REGMBC(0x147)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1d1) CASEMBC(0x1ea) CASEMBC(0x1ec) CASEMBC(0x1ece)", "      regmbc('O'); regmbc(0xd2); regmbc(0xd3);", "      regmbc(0xd4); regmbc(0xd5); regmbc(0xd6);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('O'); regmbc(0xd2); regmbc(0xd3);", "      regmbc(0xd4); regmbc(0xd5); regmbc(0xd6);", "      regmbc(0xd8);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1ee6)", "      regmbc('U'); regmbc(0xd9); regmbc(0xda);", "      regmbc(0xdb); regmbc(0xdc);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('U'); regmbc(0xd9); regmbc(0xda);", "      regmbc(0xdb); regmbc(0xdc);", "      REGMBC(0x168) REGMBC(0x16a) REGMBC(0x16c)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1ef6) CASEMBC(0x1ef8)", "      regmbc('Y'); regmbc(0xdd);", "      REGMBC(0x176) REGMBC(0x178) REGMBC(0x1e8e)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1df) CASEMBC(0x1e1) CASEMBC(0x1ea3)", "      regmbc('a'); regmbc(0xe0); regmbc(0xe1);", "      regmbc(0xe2); regmbc(0xe3); regmbc(0xe4);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('a'); regmbc(0xe0); regmbc(0xe1);", "      regmbc(0xe2); regmbc(0xe3); regmbc(0xe4);", "      regmbc(0xe5);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x107) CASEMBC(0x109) CASEMBC(0x10b) CASEMBC(0x10d)", "      regmbc('c'); regmbc(0xe7);", "      REGMBC(0x107) REGMBC(0x109) REGMBC(0x10b)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x11b) CASEMBC(0x1ebb) CASEMBC(0x1ebd)", "      regmbc('e'); regmbc(0xe8); regmbc(0xe9);", "      regmbc(0xea); regmbc(0xeb);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('e'); regmbc(0xe8); regmbc(0xe9);", "      regmbc(0xea); regmbc(0xeb);", "      REGMBC(0x113) REGMBC(0x115) REGMBC(0x117)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1d0) CASEMBC(0x1ec9)", "      regmbc('i'); regmbc(0xec); regmbc(0xed);", "      regmbc(0xee); regmbc(0xef);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('i'); regmbc(0xec); regmbc(0xed);", "      regmbc(0xee); regmbc(0xef);", "      REGMBC(0x129) REGMBC(0x12b) REGMBC(0x12d)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1e45) CASEMBC(0x1e49)", "      regmbc('n'); regmbc(0xf1);", "      REGMBC(0x144) REGMBC(0x146) REGMBC(0x148)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1d2) CASEMBC(0x1eb) CASEMBC(0x1ed) CASEMBC(0x1ecf)", "      regmbc('o'); regmbc(0xf2); regmbc(0xf3);", "      regmbc(0xf4); regmbc(0xf5); regmbc(0xf6);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('o'); regmbc(0xf2); regmbc(0xf3);", "      regmbc(0xf4); regmbc(0xf5); regmbc(0xf6);", "      regmbc(0xf8);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1ee7)", "      regmbc('u'); regmbc(0xf9); regmbc(0xfa);", "      regmbc(0xfb); regmbc(0xfc);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('u'); regmbc(0xf9); regmbc(0xfa);", "      regmbc(0xfb); regmbc(0xfc);", "      REGMBC(0x169) REGMBC(0x16b) REGMBC(0x16d)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1ef3) CASEMBC(0x1ef7) CASEMBC(0x1ef9)", "      regmbc('y'); regmbc(0xfd); regmbc(0xff);", "      REGMBC(0x177) REGMBC(0x1e8f) REGMBC(0x1e99)"], "whitespace/newline"]
["src/nvim/regexp.c", ["", "/*", " * Check for a collating element \"[.a.]\".  \"pp\" points to the '['."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "static int reg_cpo_lit; /* 'cpoptions' contains 'l' flag */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Skip over a \"[]\" range."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  if (*p == '^')        /* Complement of range. */", "    ++p;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  if (*p == '^')        /* Complement of range. */", "    ++p;"], "readability/braces"]
["src/nvim/regexp.c", ["  if (*p == '^')        /* Complement of range. */", "    ++p;", "  if (*p == ']' || *p == '-')"], "readability/increment"]
["src/nvim/regexp.c", ["    ++p;", "  if (*p == ']' || *p == '-')", "    ++p;"], "readability/braces"]
["src/nvim/regexp.c", ["  if (*p == ']' || *p == '-')", "    ++p;", "  while (*p != NUL && *p != ']') {"], "readability/increment"]
["src/nvim/regexp.c", ["", "/*", " * Skip past regular expression."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  if (magic)", "    mymagic = MAGIC_ON;"], "readability/braces"]
["src/nvim/regexp.c", ["    mymagic = MAGIC_ON;", "  else", "    mymagic = MAGIC_OFF;"], "readability/braces"]
["src/nvim/regexp.c", ["      p = skip_anyof(p + 1);", "      if (p[0] == NUL)", "        break;"], "readability/braces"]
["src/nvim/regexp.c", ["      if (dirc == '?' && newp != NULL && p[1] == '?') {", "        /* change \"\\?\" to \"?\", make a copy first. */", "        if (*newp == NULL) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        STRMOVE(p, p + 1);", "      } else", "        ++p;            /* skip next character */"], "readability/braces"]
["src/nvim/regexp.c", ["      } else", "        ++p;            /* skip next character */", "      if (*p == 'v')"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      } else", "        ++p;            /* skip next character */", "      if (*p == 'v')"], "readability/increment"]
["src/nvim/regexp.c", ["        ++p;            /* skip next character */", "      if (*p == 'v')", "        mymagic = MAGIC_ALL;"], "readability/braces"]
["src/nvim/regexp.c", ["        mymagic = MAGIC_ALL;", "      else if (*p == 'V')", "        mymagic = MAGIC_NONE;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * bt_regcomp() - compile a regular expression into internal code for the"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  /*", "   * First pass: determine size, legality."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  regc(REGMAGIC);", "  if (reg(REG_NOPAREN, &flags) == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["", "  /* Allocate space. */", "  bt_regprog_T *r = xmalloc(sizeof(bt_regprog_T) + regsize);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  /*", "   * Second pass: emit code."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    xfree(r);", "    if (reg_toolong)", "      EMSG_RET_NULL(_(\"E339: Pattern too long\"));"], "readability/braces"]
["src/nvim/regexp.c", ["", "  /* Dig out information for optimizations. */", "  r->regstart = NUL;            /* Worst-case defaults. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  /* Dig out information for optimizations. */", "  r->regstart = NUL;            /* Worst-case defaults. */", "  r->reganch = 0;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  r->regflags = regflags;", "  if (flags & HASNL)", "    r->regflags |= RF_HASNL;"], "readability/braces"]
["src/nvim/regexp.c", ["    r->regflags |= RF_HASNL;", "  if (flags & HASLOOKBH)", "    r->regflags |= RF_LOOKBH;"], "readability/braces"]
["src/nvim/regexp.c", ["    r->regflags |= RF_LOOKBH;", "  /* Remember whether this pattern has any \\z specials in it. */", "  r->reghasz = re_has_z;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  r->reghasz = re_has_z;", "  scan = r->program + 1;        /* First BRANCH. */", "  if (OP(regnext(scan)) == END) {   /* Only one top-level choice. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  scan = r->program + 1;        /* First BRANCH. */", "  if (OP(regnext(scan)) == END) {   /* Only one top-level choice. */", "    scan = OPERAND(scan);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "    /* Starting-point info. */", "    if (OP(scan) == BOL || OP(scan) == RE_BOF) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "    /*", "     * If there's something expensive in the r.e., find the longest"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["     */", "    /*", "     * When the r.e. starts with BOW, it is faster to look for a regmust"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      len = 0;", "      for (; scan != NULL; scan = regnext(scan))", "        if (OP(scan) == EXACTLY && STRLEN(OPERAND(scan)) >= (size_t)len) {"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Free a compiled regexp program, returned by bt_regcomp()."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Setup to parse the regexp.  Used once to get the length and once to do it."], "readability/old_style_comment"]
["src/nvim/regexp.c", [" */", "static void ", "regcomp_start ("], "whitespace/end_of_line"]
["src/nvim/regexp.c", ["static void ", "regcomp_start (", "    char_u *expr,"], "whitespace/parens"]
["src/nvim/regexp.c", ["    char_u *expr,", "    int re_flags                       /* see vim_regcomp() */", ")"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  initchr(expr);", "  if (re_flags & RE_MAGIC)", "    reg_magic = MAGIC_ON;"], "readability/braces"]
["src/nvim/regexp.c", ["    reg_magic = MAGIC_ON;", "  else", "    reg_magic = MAGIC_OFF;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Check if during the previous call to vim_regcomp the EOL item \"$\" has been"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Parse regular expression, i.e. main body or parenthesized thing."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["static char_u *", "reg (", "    int paren,              /* REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN */"], "whitespace/parens"]
["src/nvim/regexp.c", ["reg (", "    int paren,              /* REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN */", "    int *flagp"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["reg (", "    int paren,              /* REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN */", "    int *flagp"], "whitespace/line_length"]
["src/nvim/regexp.c", ["", "  *flagp = HASWIDTH;            /* Tentatively. */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  if (paren == REG_ZPAREN) {", "    /* Make a ZOPEN node. */", "    if (regnzpar >= NSUBEXP)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    /* Make a ZOPEN node. */", "    if (regnzpar >= NSUBEXP)", "      EMSG_RET_NULL(_(\"E50: Too many \\\\z(\"));"], "readability/braces"]
["src/nvim/regexp.c", ["  } else if (paren == REG_PAREN)    {", "    /* Make a MOPEN node. */", "    if (regnpar >= NSUBEXP)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    /* Make a MOPEN node. */", "    if (regnpar >= NSUBEXP)", "      EMSG2_RET_NULL(_(\"E51: Too many %s(\"), reg_magic == MAGIC_ALL);"], "readability/braces"]
["src/nvim/regexp.c", ["    parno = regnpar;", "    ++regnpar;", "    ret = regnode(MOPEN + parno);"], "readability/increment"]
["src/nvim/regexp.c", ["  } else if (paren == REG_NPAREN)   {", "    /* Make a NOPEN node. */", "    ret = regnode(NOPEN);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    ret = regnode(NOPEN);", "  } else", "    ret = NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["", "  /* Pick up the branches, linking them together. */", "  br = regbranch(&flags);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  br = regbranch(&flags);", "  if (br == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["    return NULL;", "  if (ret != NULL)", "    regtail(ret, br);           /* [MZ]OPEN -> first. */"], "readability/braces"]
["src/nvim/regexp.c", ["  if (ret != NULL)", "    regtail(ret, br);           /* [MZ]OPEN -> first. */", "  else"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    regtail(ret, br);           /* [MZ]OPEN -> first. */", "  else", "    ret = br;"], "readability/braces"]
["src/nvim/regexp.c", ["    ret = br;", "  /* If one of the branches can be zero-width, the whole thing can.", "   * If one of the branches has * at start or matches a line-break, the"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["   * whole thing can. */", "  if (!(flags & HASWIDTH))", "    *flagp &= ~HASWIDTH;"], "readability/braces"]
["src/nvim/regexp.c", ["    br = regbranch(&flags);", "    if (br == NULL || reg_toolong)", "      return NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["      return NULL;", "    regtail(ret, br);           /* BRANCH -> BRANCH. */", "    if (!(flags & HASWIDTH))"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    regtail(ret, br);           /* BRANCH -> BRANCH. */", "    if (!(flags & HASWIDTH))", "      *flagp &= ~HASWIDTH;"], "readability/braces"]
["src/nvim/regexp.c", ["", "  /* Make a closing node, and hook it on the end. */", "  ender = regnode("], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  /* Hook the tails of the branches to the closing node. */", "  for (br = ret; br != NULL; br = regnext(br))"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  /* Hook the tails of the branches to the closing node. */", "  for (br = ret; br != NULL; br = regnext(br))", "    regoptail(br, ender);"], "readability/braces"]
["src/nvim/regexp.c", ["", "  /* Check for proper termination. */", "  if (paren != REG_NOPAREN && getchr() != Magic(')')) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  if (paren != REG_NOPAREN && getchr() != Magic(')')) {", "    if (paren == REG_ZPAREN)", "      EMSG_RET_NULL(_(\"E52: Unmatched \\\\z(\"));"], "readability/braces"]
["src/nvim/regexp.c", ["      EMSG_RET_NULL(_(\"E52: Unmatched \\\\z(\"));", "    else if (paren == REG_NPAREN)", "      EMSG2_RET_NULL(_(e_unmatchedpp), reg_magic == MAGIC_ALL);"], "readability/braces"]
["src/nvim/regexp.c", ["      EMSG2_RET_NULL(_(e_unmatchedpp), reg_magic == MAGIC_ALL);", "    else", "      EMSG2_RET_NULL(_(e_unmatchedp), reg_magic == MAGIC_ALL);"], "readability/braces"]
["src/nvim/regexp.c", ["  } else if (paren == REG_NOPAREN && peekchr() != NUL) {", "    if (curchr == Magic(')'))", "      EMSG2_RET_NULL(_(e_unmatchedpar), reg_magic == MAGIC_ALL);"], "readability/braces"]
["src/nvim/regexp.c", ["      EMSG2_RET_NULL(_(e_unmatchedpar), reg_magic == MAGIC_ALL);", "    else", "      EMSG_RET_NULL(_(e_trailing));             /* \"Can't happen\". */"], "readability/braces"]
["src/nvim/regexp.c", ["    else", "      EMSG_RET_NULL(_(e_trailing));             /* \"Can't happen\". */", "    /* NOTREACHED */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      EMSG_RET_NULL(_(e_trailing));             /* \"Can't happen\". */", "    /* NOTREACHED */", "  }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Parse one alternative of an | operator."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  *flagp = WORST | HASNL;               /* Tentatively. */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    latest = regconcat(&flags);", "    if (latest == NULL)", "      return NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["      return NULL;", "    /* If one of the branches has width, the whole thing has.  If one of", "     * the branches anchors at start-of-line, the whole thing does."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    *flagp |= flags & (HASWIDTH | SPSTART | HASLOOKBH);", "    /* If one of the branches doesn't match a line-break, the whole thing", "     * doesn't. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    *flagp &= ~HASNL | (flags & HASNL);", "    if (chain != NULL)", "      regtail(chain, latest);"], "readability/braces"]
["src/nvim/regexp.c", ["      regtail(chain, latest);", "    if (peekchr() != Magic('&'))", "      break;"], "readability/braces"]
["src/nvim/regexp.c", ["    skipchr();", "    regtail(latest, regnode(END));     /* operand ends */", "    if (reg_toolong)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    regtail(latest, regnode(END));     /* operand ends */", "    if (reg_toolong)", "      break;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Parse one alternative of an | or & operator."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  *flagp = WORST;               /* Tentatively. */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      latest = regpiece(&flags);", "      if (latest == NULL || reg_toolong)", "        return NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["      *flagp |= flags & (HASWIDTH | HASNL | HASLOOKBH);", "      if (chain == NULL)                        /* First piece. */", "        *flagp |= flags & SPSTART;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      *flagp |= flags & (HASWIDTH | HASNL | HASLOOKBH);", "      if (chain == NULL)                        /* First piece. */", "        *flagp |= flags & SPSTART;"], "readability/braces"]
["src/nvim/regexp.c", ["        *flagp |= flags & SPSTART;", "      else", "        regtail(chain, latest);"], "readability/braces"]
["src/nvim/regexp.c", ["      chain = latest;", "      if (first == NULL)", "        first = latest;"], "readability/braces"]
["src/nvim/regexp.c", ["  }", "  if (first == NULL)            /* Loop ran zero times. */", "    first = regnode(NOTHING);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  }", "  if (first == NULL)            /* Loop ran zero times. */", "    first = regnode(NOTHING);"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Parse something followed by possible [*+=]."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  ret = regatom(&flags);", "  if (ret == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["  }", "  /* default flags */", "  *flagp = (WORST | SPSTART | (flags & (HASNL | HASLOOKBH)));"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case Magic('*'):", "    if (flags & SIMPLE)", "      reginsert(STAR, ret);"], "readability/braces"]
["src/nvim/regexp.c", ["      reginsert(STAR, ret);", "    else {", "      /* Emit x* as (x&|), where & means \"self\". */"], "readability/braces"]
["src/nvim/regexp.c", ["      reginsert(STAR, ret);", "    else {", "      /* Emit x* as (x&|), where & means \"self\". */"], "readability/braces"]
["src/nvim/regexp.c", ["    else {", "      /* Emit x* as (x&|), where & means \"self\". */", "      reginsert(BRANCH, ret);           /* Either x */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      /* Emit x* as (x&|), where & means \"self\". */", "      reginsert(BRANCH, ret);           /* Either x */", "      regoptail(ret, regnode(BACK));            /* and loop */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      reginsert(BRANCH, ret);           /* Either x */", "      regoptail(ret, regnode(BACK));            /* and loop */", "      regoptail(ret, ret);              /* back */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      regoptail(ret, regnode(BACK));            /* and loop */", "      regoptail(ret, ret);              /* back */", "      regtail(ret, regnode(BRANCH));            /* or */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      regoptail(ret, ret);              /* back */", "      regtail(ret, regnode(BRANCH));            /* or */", "      regtail(ret, regnode(NOTHING));           /* null. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      regtail(ret, regnode(BRANCH));            /* or */", "      regtail(ret, regnode(NOTHING));           /* null. */", "    }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case Magic('+'):", "    if (flags & SIMPLE)", "      reginsert(PLUS, ret);"], "readability/braces"]
["src/nvim/regexp.c", ["      reginsert(PLUS, ret);", "    else {", "      /* Emit x+ as x(&|), where & means \"self\". */"], "readability/braces"]
["src/nvim/regexp.c", ["      reginsert(PLUS, ret);", "    else {", "      /* Emit x+ as x(&|), where & means \"self\". */"], "readability/braces"]
["src/nvim/regexp.c", ["    else {", "      /* Emit x+ as x(&|), where & means \"self\". */", "      next = regnode(BRANCH);           /* Either */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      /* Emit x+ as x(&|), where & means \"self\". */", "      next = regnode(BRANCH);           /* Either */", "      regtail(ret, next);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      regtail(ret, next);", "      regtail(regnode(BACK), ret);              /* loop back */", "      regtail(next, regnode(BRANCH));           /* or */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      regtail(regnode(BACK), ret);              /* loop back */", "      regtail(next, regnode(BRANCH));           /* or */", "      regtail(ret, regnode(NOTHING));           /* null. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      regtail(next, regnode(BRANCH));           /* or */", "      regtail(ret, regnode(NOTHING));           /* null. */", "    }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    switch (no_Magic(getchr())) {", "    case '=': lop = MATCH; break;                                 /* \\@= */", "    case '!': lop = NOMATCH; break;                               /* \\@! */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    case '=': lop = MATCH; break;                                 /* \\@= */", "    case '!': lop = NOMATCH; break;                               /* \\@! */", "    case '>': lop = SUBPAT; break;                                /* \\@> */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    case '!': lop = NOMATCH; break;                               /* \\@! */", "    case '>': lop = SUBPAT; break;                                /* \\@> */", "    case '<': switch (no_Magic(getchr())) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    case '<': switch (no_Magic(getchr())) {", "      case '=': lop = BEHIND; break;                               /* \\@<= */", "      case '!': lop = NOBEHIND; break;                             /* \\@<! */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      case '=': lop = BEHIND; break;                               /* \\@<= */", "      case '!': lop = NOBEHIND; break;                             /* \\@<! */", "    }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    }", "    if (lop == END)", "      EMSG2_RET_NULL(_(\"E59: invalid character after %s@\"),"], "readability/braces"]
["src/nvim/regexp.c", ["      EMSG2_RET_NULL(_(\"E59: invalid character after %s@\"),", "          reg_magic == MAGIC_ALL);", "    /* Look behind must match with behind_pos. */"], "whitespace/alignment"]
["src/nvim/regexp.c", ["          reg_magic == MAGIC_ALL);", "    /* Look behind must match with behind_pos. */", "    if (lop == BEHIND || lop == NOBEHIND) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    }", "    regtail(ret, regnode(END));             /* operand ends */", "    if (lop == BEHIND || lop == NOBEHIND) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    if (lop == BEHIND || lop == NOBEHIND) {", "      if (nr < 0)", "        nr = 0;                 /* no limit is same as zero limit */"], "readability/braces"]
["src/nvim/regexp.c", ["      if (nr < 0)", "        nr = 0;                 /* no limit is same as zero limit */", "      reginsert_nr(lop, (uint32_t)nr, ret);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      reginsert_nr(lop, (uint32_t)nr, ret);", "    } else", "      reginsert(lop, ret);"], "readability/braces"]
["src/nvim/regexp.c", ["  case Magic('='):", "    /* Emit x= as (x|) */", "    reginsert(BRANCH, ret);                     /* Either x */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    /* Emit x= as (x|) */", "    reginsert(BRANCH, ret);                     /* Either x */", "    regtail(ret, regnode(BRANCH));              /* or */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    reginsert(BRANCH, ret);                     /* Either x */", "    regtail(ret, regnode(BRANCH));              /* or */", "    next = regnode(NOTHING);                    /* null. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    regtail(ret, regnode(BRANCH));              /* or */", "    next = regnode(NOTHING);                    /* null. */", "    regtail(ret, next);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case Magic('{'):", "    if (!read_limits(&minval, &maxval))", "      return NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["    } else {", "      if (num_complex_braces >= 10)", "        EMSG2_RET_NULL(_(\"E60: Too many complex %s{...}s\"),"], "readability/braces"]
["src/nvim/regexp.c", ["        EMSG2_RET_NULL(_(\"E60: Too many complex %s{...}s\"),", "            reg_magic == MAGIC_ALL);", "      reginsert(BRACE_COMPLEX + num_complex_braces, ret);"], "whitespace/alignment"]
["src/nvim/regexp.c", ["      reginsert_limits(BRACE_LIMITS, minval, maxval, ret);", "      ++num_complex_braces;", "    }"], "readability/increment"]
["src/nvim/regexp.c", ["    }", "    if (minval > 0 && maxval > 0)", "      *flagp = (HASWIDTH | (flags & (HASNL | HASLOOKBH)));"], "readability/braces"]
["src/nvim/regexp.c", ["  if (re_multi_type(peekchr()) != NOT_MULTI) {", "    /* Can't have a multi follow a multi. */", "    if (peekchr() == Magic('*'))"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    /* Can't have a multi follow a multi. */", "    if (peekchr() == Magic('*'))", "      sprintf((char *)IObuff, _(\"E61: Nested %s*\"),"], "readability/braces"]
["src/nvim/regexp.c", ["      sprintf((char *)IObuff, _(\"E61: Nested %s*\"),", "          reg_magic >= MAGIC_ON ? \"\" : \"\\\\\");", "    else"], "whitespace/alignment"]
["src/nvim/regexp.c", ["    if (peekchr() == Magic('*'))", "      sprintf((char *)IObuff, _(\"E61: Nested %s*\"),", "          reg_magic >= MAGIC_ON ? \"\" : \"\\\\\");"], "runtime/printf"]
["src/nvim/regexp.c", ["          reg_magic >= MAGIC_ON ? \"\" : \"\\\\\");", "    else", "      sprintf((char *)IObuff, _(\"E62: Nested %s%c\"),"], "readability/braces"]
["src/nvim/regexp.c", ["      sprintf((char *)IObuff, _(\"E62: Nested %s%c\"),", "          reg_magic == MAGIC_ALL ? \"\" : \"\\\\\", no_Magic(peekchr()));", "    EMSG_RET_NULL(IObuff);"], "whitespace/alignment"]
["src/nvim/regexp.c", ["    else", "      sprintf((char *)IObuff, _(\"E62: Nested %s%c\"),", "          reg_magic == MAGIC_ALL ? \"\" : \"\\\\\", no_Magic(peekchr()));"], "runtime/printf"]
["src/nvim/regexp.c", ["", "/* When making changes to classchars also change nfa_classcodes. */", "static char_u   *classchars = (char_u *)\".iIkKfFpPsSdDxXoOwWhHaAlLuU\";"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Parse the lowest level."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  *flagp = WORST;               /* Tentatively. */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    c = no_Magic(getchr());", "    if (c == '^') {             /* \"\\_^\" is start-of-line */", "      ret = regnode(BOL);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    }", "    if (c == '$') {             /* \"\\_$\" is end-of-line */", "      ret = regnode(EOL);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "    /* \"\\_[\" is character range plus newline */", "    if (c == '[')"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    /* \"\\_[\" is character range plus newline */", "    if (c == '[')", "      goto collection;"], "readability/braces"]
["src/nvim/regexp.c", ["", "  /*", "   * Character classes."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    p = vim_strchr(classchars, no_Magic(c));", "    if (p == NULL)", "      EMSG_RET_NULL(_(\"E63: invalid use of \\\\_\"));"], "readability/braces"]
["src/nvim/regexp.c", ["      EMSG_RET_NULL(_(\"E63: invalid use of \\\\_\"));", "    /* When '.' is followed by a composing char ignore the dot, so that", "     * the composing char is matched here. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    if (reg_string) {", "      /* In a string \"\\n\" matches a newline character. */", "      ret = regnode(EXACTLY);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    } else {", "      /* In buffer text \"\\n\" matches the end of a line. */", "      ret = regnode(NEWL);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case Magic('('):", "    if (one_exactly)", "      EMSG_ONE_RET_NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["    ret = reg(REG_PAREN, &flags);", "    if (ret == NULL)", "      return NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["  case Magic(')'):", "    if (one_exactly)", "      EMSG_ONE_RET_NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["    sprintf((char *)IObuff, _(\"E64: %s%c follows nothing\"),", "        (c == '*' ? reg_magic >= MAGIC_ON : reg_magic == MAGIC_ALL)", "        ? \"\" : \"\\\\\", c);"], "whitespace/alignment"]
["src/nvim/regexp.c", ["        (c == '*' ? reg_magic >= MAGIC_ON : reg_magic == MAGIC_ALL)", "        ? \"\" : \"\\\\\", c);", "    EMSG_RET_NULL(IObuff);"], "whitespace/alignment"]
["src/nvim/regexp.c", ["    c = no_Magic(c);", "    sprintf((char *)IObuff, _(\"E64: %s%c follows nothing\"),", "        (c == '*' ? reg_magic >= MAGIC_ON : reg_magic == MAGIC_ALL)"], "runtime/printf"]
["src/nvim/regexp.c", ["    EMSG_RET_NULL(IObuff);", "  /* NOTREACHED */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  case Magic('~'):              /* previous substitute pattern */", "    if (reg_prev_sub != NULL) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      lp = reg_prev_sub;", "      while (*lp != NUL)", "        regc(*lp++);"], "readability/braces"]
["src/nvim/regexp.c", ["        *flagp |= HASWIDTH;", "        if ((lp - reg_prev_sub) == 1)", "          *flagp |= SIMPLE;"], "readability/braces"]
["src/nvim/regexp.c", ["      }", "    } else", "      EMSG_RET_NULL(_(e_nopresub));"], "readability/braces"]
["src/nvim/regexp.c", ["        EMSG_RET_NULL(_(e_z_not_allowed));", "      if (one_exactly)", "        EMSG_ONE_RET_NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["      ret = reg(REG_ZPAREN, &flags);", "      if (ret == NULL)", "        return NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["    switch (c) {", "    /* () without a back reference */", "    case '(':"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    case '(':", "      if (one_exactly)", "        EMSG_ONE_RET_NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["      ret = reg(REG_NPAREN, &flags);", "      if (ret == NULL)", "        return NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["", "    /* Catch \\%^ and \\%$ regardless of where they appear in the", "     * pattern -- regardless of whether or not it makes sense. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "    /* \\%[abc]: Emit as a list of branches, all ending at the last", "     * branch which matches nothing. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    case '[':", "      if (one_exactly)                          /* doesn't nest */", "        EMSG_ONE_RET_NULL;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    case '[':", "      if (one_exactly)                          /* doesn't nest */", "        EMSG_ONE_RET_NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["        while ((c = getchr()) != ']') {", "          if (c == NUL)", "            EMSG2_RET_NULL(_(e_missing_sb),"], "readability/braces"]
["src/nvim/regexp.c", ["            EMSG2_RET_NULL(_(e_missing_sb),", "                reg_magic == MAGIC_ALL);", "          br = regnode(BRANCH);"], "whitespace/alignment"]
["src/nvim/regexp.c", ["        }", "        if (ret == NULL)", "          EMSG2_RET_NULL(_(e_empty_sb),"], "readability/braces"]
["src/nvim/regexp.c", ["          EMSG2_RET_NULL(_(e_empty_sb),", "              reg_magic == MAGIC_ALL);", "        lastbranch = regnode(BRANCH);"], "whitespace/alignment"]
["src/nvim/regexp.c", ["          regtail(lastbranch, br);", "          /* connect all branches to the NOTHING", "           * branch at the end */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              br = OPERAND(br);", "            } else", "              br = regnext(br);"], "readability/braces"]
["src/nvim/regexp.c", ["", "    case 'd':               /* %d123 decimal */", "    case 'o':               /* %o123 octal */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    case 'd':               /* %d123 decimal */", "    case 'o':               /* %o123 octal */", "    case 'x':               /* %xab hex 2 */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    case 'o':               /* %o123 octal */", "    case 'x':               /* %xab hex 2 */", "    case 'u':               /* %uabcd hex 4 */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    case 'x':               /* %xab hex 2 */", "    case 'u':               /* %uabcd hex 4 */", "    case 'U':               /* %U1234abcd hex 8 */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    case 'u':               /* %uabcd hex 4 */", "    case 'U':               /* %U1234abcd hex 8 */", "    {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        cmp = c;", "        if (cmp == '<' || cmp == '>')", "          c = getchr();"], "readability/braces"]
["src/nvim/regexp.c", ["        if (c == '\\'' && n == 0) {", "          /* \"\\%'m\", \"\\%<'m\" and \"\\%>'m\": Mark */", "          c = getchr();"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          ret = regnode(RE_MARK);", "          if (ret == JUST_CALC_SIZE)", "            regsize += 2;"], "readability/braces"]
["src/nvim/regexp.c", ["            regsize += 2;", "          else {", "            *regcode++ = c;"], "readability/braces"]
["src/nvim/regexp.c", ["            regsize += 2;", "          else {", "            *regcode++ = c;"], "readability/braces"]
["src/nvim/regexp.c", ["      EMSG2_RET_NULL(_(\"E71: Invalid character after %s%%\"),", "          reg_magic == MAGIC_ALL);", "    }"], "whitespace/alignment"]
["src/nvim/regexp.c", ["", "      /*", "       * If there is no matching ']', we assume the '[' is a normal"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      lp = skip_anyof(regparse);", "      if (*lp == ']') {         /* there is a matching ']' */", "        int startc = -1;                /* > 0 when next '-' is a range */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      if (*lp == ']') {         /* there is a matching ']' */", "        int startc = -1;                /* > 0 when next '-' is a range */", "        int endc;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "        /*", "         * In a character class, different parsing rules apply."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["         */", "        if (*regparse == '^') {             /* Complement of range. */", "          ret = regnode(ANYBUT + extra);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          regparse++;", "        } else", "          ret = regnode(ANYOF + extra);"], "readability/braces"]
["src/nvim/regexp.c", ["", "        /* At the start ']' and '-' mean the literal character. */", "        if (*regparse == ']' || *regparse == '-') {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          if (*regparse == '-') {", "            ++regparse;", "            /* The '-' is not used for a range at the end and"], "readability/increment"]
["src/nvim/regexp.c", ["            ++regparse;", "            /* The '-' is not used for a range at the end and", "             * after or before a '\\n'. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              regc('-');", "              startc = '-';                     /* [--x] is a range */", "            } else {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["            } else {", "              /* Also accept \"a-[.z.]\" */", "              endc = 0;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              endc = 0;", "              if (*regparse == '[')", "                endc = get_coll_element(&regparse);"], "readability/braces"]
["src/nvim/regexp.c", ["", "              /* Handle \\o40, \\x20 and \\u20AC style sequences */", "              if (endc == '\\\\' && !reg_cpo_lit)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              /* Handle \\o40, \\x20 and \\u20AC style sequences */", "              if (endc == '\\\\' && !reg_cpo_lit)", "                endc = coll_get_char();"], "readability/braces"]
["src/nvim/regexp.c", ["              } else {", "                while (++startc <= endc)", "                  regc(startc);"], "readability/braces"]
["src/nvim/regexp.c", ["          }", "          /*", "           * Only \"\\]\", \"\\^\", \"\\]\" and \"\\\\\" are special in Vi.  Vim"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["           */", "          else if (*regparse == '\\\\'", "                   && (vim_strchr(REGEXP_INRANGE, regparse[1]) != NULL"], "whitespace/newline"]
["src/nvim/regexp.c", ["                           && vim_strchr(REGEXP_ABBR,", "                               regparse[1]) != NULL))) {", "            regparse++;"], "whitespace/alignment"]
["src/nvim/regexp.c", ["                           && vim_strchr(REGEXP_ABBR,", "                               regparse[1]) != NULL))) {", "            regparse++;"], "whitespace/alignment"]
["src/nvim/regexp.c", ["                           && vim_strchr(REGEXP_ABBR,", "                               regparse[1]) != NULL))) {", "            regparse++;"], "whitespace/alignment"]
["src/nvim/regexp.c", ["                           && vim_strchr(REGEXP_ABBR,", "                               regparse[1]) != NULL))) {", "            regparse++;"], "whitespace/alignment"]
["src/nvim/regexp.c", ["            if (*regparse == 'n') {", "              /* '\\n' in range: also match NL */", "              if (ret != JUST_CALC_SIZE) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              if (ret != JUST_CALC_SIZE) {", "                /* Using \\n inside [^] does not change what", "                 * matches. \"[^\\n]\" is the same as \".\". */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["                }", "                /* else: must have had a \\n already */", "              }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              startc = coll_get_char();", "              if (startc == 0)", "                regc(0x0a);"], "readability/braces"]
["src/nvim/regexp.c", ["                regc(0x0a);", "              else", "                regmbc(startc);"], "readability/braces"]
["src/nvim/regexp.c", ["            startc = -1;", "            /* Characters assumed to be 8 bits! */", "            switch (c_class) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              if (c_class != 0) {", "                /* produce equivalence class */", "                reg_equi_class(c_class);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              } else if ((c_class =", "                            get_coll_element(&regparse)) != 0) {", "                /* produce a collating element */"], "whitespace/alignment"]
["src/nvim/regexp.c", ["                            get_coll_element(&regparse)) != 0) {", "                /* produce a collating element */", "                regmbc(c_class);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              } else {", "                /* literal '[', allow [[-x] as a range */", "                startc = *regparse++;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["            case CLASS_SPACE:", "              for (cu = 9; cu <= 13; cu++)", "                regc(cu);"], "readability/braces"]
["src/nvim/regexp.c", ["        regc(NUL);", "        prevchr_len = 1;                /* last char was the ']' */", "        if (*regparse != ']')"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        prevchr_len = 1;                /* last char was the ']' */", "        if (*regparse != ']')", "          EMSG_RET_NULL(_(e_toomsbra));                 /* Cannot happen? */"], "readability/braces"]
["src/nvim/regexp.c", ["        if (*regparse != ']')", "          EMSG_RET_NULL(_(e_toomsbra));                 /* Cannot happen? */", "        skipchr();                  /* let's be friends with the lexer again */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          EMSG_RET_NULL(_(e_toomsbra));                 /* Cannot happen? */", "        skipchr();                  /* let's be friends with the lexer again */", "        *flagp |= HASWIDTH | SIMPLE;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        break;", "      } else if (reg_strict)", "        EMSG2_RET_NULL(_(e_missingbracket), reg_magic > MAGIC_OFF);"], "readability/braces"]
["src/nvim/regexp.c", ["", "    /* A multi-byte character is handled as a separate atom if it's", "     * before a multi and when it's a composing char. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "    /*", "     * Append characters as long as:"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["                                   && !one_exactly", "                                   && !is_Magic(c))); ++len) {", "      c = no_Magic(c);"], "readability/increment"]
["src/nvim/regexp.c", ["", "          /* Need to get composing character too. */", "          for (;; ) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["            l = utf_ptr2len(regparse);", "            if (!UTF_COMPOSINGLIKE(regparse, regparse + l))", "              break;"], "readability/braces"]
["src/nvim/regexp.c", ["    *flagp |= HASWIDTH;", "    if (len == 1)", "      *flagp |= SIMPLE;"], "readability/braces"]
["src/nvim/regexp.c", ["  return ret;", "}", ""], "readability/fn_size"]
["src/nvim/regexp.c", ["", "/*", " * Emit a node."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  ret = regcode;", "  if (ret == JUST_CALC_SIZE)", "    regsize += 3;"], "readability/braces"]
["src/nvim/regexp.c", ["    regsize += 3;", "  else {", "    *regcode++ = op;"], "readability/braces"]
["src/nvim/regexp.c", ["    regsize += 3;", "  else {", "    *regcode++ = op;"], "readability/braces"]
["src/nvim/regexp.c", ["    *regcode++ = op;", "    *regcode++ = NUL;                   /* Null \"next\" pointer. */", "    *regcode++ = NUL;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Emit (if appropriate) a byte of code"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["{", "  if (regcode == JUST_CALC_SIZE)", "    regsize++;"], "readability/braces"]
["src/nvim/regexp.c", ["    regsize++;", "  else", "    *regcode++ = b;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Emit (if appropriate) a multi-byte character of code"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Insert an operator in front of already-emitted operand"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  dst = regcode;", "  while (src > opnd)", "    *--dst = *--src;"], "readability/braces"]
["src/nvim/regexp.c", ["", "  place = opnd;                 /* Op node, where operand used to be. */", "  *place++ = op;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Insert an operator in front of already-emitted operand."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  dst = regcode;", "  while (src > opnd)", "    *--dst = *--src;"], "readability/braces"]
["src/nvim/regexp.c", ["", "  place = opnd;                 /* Op node, where operand used to be. */", "  *place++ = op;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Insert an operator in front of already-emitted operand."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  dst = regcode;", "  while (src > opnd)", "    *--dst = *--src;"], "readability/braces"]
["src/nvim/regexp.c", ["", "  place = opnd;                 /* Op node, where operand used to be. */", "  *place++ = op;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Write a four bytes number at \"p\" and return pointer to the next char."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["{", "  *p++ = (char_u) ((val >> 24) & 0377);", "  *p++ = (char_u) ((val >> 16) & 0377);"], "whitespace/cast"]
["src/nvim/regexp.c", ["  *p++ = (char_u) ((val >> 24) & 0377);", "  *p++ = (char_u) ((val >> 16) & 0377);", "  *p++ = (char_u) ((val >> 8) & 0377);"], "whitespace/cast"]
["src/nvim/regexp.c", ["  *p++ = (char_u) ((val >> 16) & 0377);", "  *p++ = (char_u) ((val >> 8) & 0377);", "  *p++ = (char_u) (val & 0377);"], "whitespace/cast"]
["src/nvim/regexp.c", ["  *p++ = (char_u) ((val >> 8) & 0377);", "  *p++ = (char_u) (val & 0377);", "  return p;"], "whitespace/cast"]
["src/nvim/regexp.c", ["", "/*", " * Like regtail, on item after a BRANCH; nop if none."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["{", "  /* When op is neither BRANCH nor BRACE_COMPLEX0-9, it is \"operandless\" */", "  if (p == NULL || p == JUST_CALC_SIZE"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  /* When op is neither BRANCH nor BRACE_COMPLEX0-9, it is \"operandless\" */", "  if (p == NULL || p == JUST_CALC_SIZE", "      || (OP(p) != BRANCH"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Functions for getting characters from the regexp input."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Start parsing at \"str\"."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Save the current parse state, so that it can be restored and parsing"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Restore a previously saved parse state."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Get the next character without advancing."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case '~':", "    /* magic when 'magic' is on */", "    if (reg_magic >= MAGIC_ON)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    /* magic when 'magic' is on */", "    if (reg_magic >= MAGIC_ON)", "      curchr = Magic(curchr);"], "readability/braces"]
["src/nvim/regexp.c", ["  case '>':", "  case '#':           /* future ext. */", "  case '\"':           /* future ext. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case '#':           /* future ext. */", "  case '\"':           /* future ext. */", "  case '\\'':          /* future ext. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case '\"':           /* future ext. */", "  case '\\'':          /* future ext. */", "  case ',':           /* future ext. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case '\\'':          /* future ext. */", "  case ',':           /* future ext. */", "  case '-':           /* future ext. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case ',':           /* future ext. */", "  case '-':           /* future ext. */", "  case ':':           /* future ext. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case '-':           /* future ext. */", "  case ':':           /* future ext. */", "  case ';':           /* future ext. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case ':':           /* future ext. */", "  case ';':           /* future ext. */", "  case '`':           /* future ext. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case ';':           /* future ext. */", "  case '`':           /* future ext. */", "  case '/':           /* Can't be used in / command */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case '`':           /* future ext. */", "  case '/':           /* Can't be used in / command */", "    /* magic only after \"\\v\" */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case '/':           /* Can't be used in / command */", "    /* magic only after \"\\v\" */", "    if (reg_magic == MAGIC_ALL)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    /* magic only after \"\\v\" */", "    if (reg_magic == MAGIC_ALL)", "      curchr = Magic(curchr);"], "readability/braces"]
["src/nvim/regexp.c", ["  case '*':", "    /* * is not magic as the very first character, eg \"?*ptr\", when", "     * after '^', eg \"/^*ptr\" and when after \"\\(\", \"\\|\", \"\\&\".  But"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["     * \"\\(\\*\" is not magic, thus must be magic if \"after_slash\" */", "    if (reg_magic >= MAGIC_ON", "        && !at_start"], "readability/braces"]
["src/nvim/regexp.c", ["  case '^':", "    /* '^' is only magic as the very first character and if it's after", "     * \"\\(\", \"\\|\", \"\\&' or \"\\n\" */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case '$':", "    /* '$' is only magic as the very last char and if it's in front of", "     * either \"\\|\", \"\\)\", \"\\&\", or \"\\n\" */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "    if (c == NUL)", "      curchr = '\\\\';                  /* trailing '\\' */"], "readability/braces"]
["src/nvim/regexp.c", ["    if (c == NUL)", "      curchr = '\\\\';                  /* trailing '\\' */", "    else if ("], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      curchr = '\\\\';                  /* trailing '\\' */", "    else if (", "      c <= '~' && META_flags[c]"], "readability/braces"]
["src/nvim/regexp.c", ["    else if (", "      c <= '~' && META_flags[c]", "      ) {"], "whitespace/indent"]
["src/nvim/regexp.c", ["      c <= '~' && META_flags[c]", "      ) {", "      /*"], "whitespace/indent"]
["src/nvim/regexp.c", ["      ) {", "      /*", "       * META contains everything that may be magic sometimes,"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    } else if (vim_strchr(REGEXP_ABBR, c)) {", "      /*", "       * Handle abbreviations, like \"\\t\" for TAB -- webb"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      curchr = backslash_trans(c);", "    } else if (reg_magic == MAGIC_NONE && (c == '$' || c == '^'))", "      curchr = toggle_Magic(c);"], "readability/braces"]
["src/nvim/regexp.c", ["      curchr = toggle_Magic(c);", "    else {", "      /*"], "readability/braces"]
["src/nvim/regexp.c", ["      curchr = toggle_Magic(c);", "    else {", "      /*"], "readability/braces"]
["src/nvim/regexp.c", ["    else {", "      /*", "       * Next character can never be (made) magic?"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Eat one lexed character.  Do this in a way that we can undo it."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["{", "  /* peekchr() eats a backslash, do the same here */", "  if (*regparse == '\\\\')"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  /* peekchr() eats a backslash, do the same here */", "  if (*regparse == '\\\\')", "    prevchr_len = 1;"], "readability/braces"]
["src/nvim/regexp.c", ["    prevchr_len = 1;", "  else", "    prevchr_len = 0;"], "readability/braces"]
["src/nvim/regexp.c", ["  prevchr = curchr;", "  curchr = nextchr;         /* use previously unget char, or -1 */", "  nextchr = -1;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Skip a character while keeping the value of prev_at_start for at_start."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Get the next character from the pattern. We know about magic and such, so"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * put character back.  Works only once!"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  /* Backup regparse, so that it's at the same position as before the", "   * getchr(). */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Get and return the value of the hex string at the current position."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  for (i = 0; i < maxinputlen; ++i) {", "    c = regparse[0];"], "readability/increment"]
["src/nvim/regexp.c", ["    c = regparse[0];", "    if (!ascii_isxdigit(c))", "      break;"], "readability/braces"]
["src/nvim/regexp.c", ["    nr |= hex2nr(c);", "    ++regparse;", "  }"], "readability/increment"]
["src/nvim/regexp.c", ["", "  if (i == 0)", "    return -1;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Get and return the value of the decimal string immediately after the"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  for (i = 0;; ++i) {", "    c = regparse[0];"], "readability/increment"]
["src/nvim/regexp.c", ["    c = regparse[0];", "    if (c < '0' || c > '9')", "      break;"], "readability/braces"]
["src/nvim/regexp.c", ["    nr += c - '0';", "    ++regparse;", "    curchr = -1;     /* no longer valid */"], "readability/increment"]
["src/nvim/regexp.c", ["    ++regparse;", "    curchr = -1;     /* no longer valid */", "  }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  if (i == 0)", "    return -1;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * get and return the value of the octal string immediately after the current"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    c = regparse[0];", "    if (c < '0' || c > '7')", "      break;"], "readability/braces"]
["src/nvim/regexp.c", ["    nr |= hex2nr(c);", "    ++regparse;", "  }"], "readability/increment"]
["src/nvim/regexp.c", ["", "  if (i == 0)", "    return -1;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Get a number after a backslash that is inside []."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * read_limits - Read two integers to be taken as a minimum and maximum."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    sprintf((char *)IObuff, _(\"E554: Syntax error in %s{...}\"),", "        reg_magic == MAGIC_ALL ? \"\" : \"\\\\\");", "    EMSG_RET_FAIL(IObuff);"], "whitespace/alignment"]
["src/nvim/regexp.c", ["  if (*regparse != '}') {", "    sprintf((char *)IObuff, _(\"E554: Syntax error in %s{...}\"),", "        reg_magic == MAGIC_ALL ? \"\" : \"\\\\\");"], "runtime/printf"]
["src/nvim/regexp.c", ["", "  /*", "   * Reverse the range if there was a '-', or make sure it is in the right"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  }", "  skipchr();            /* let's be friends with the lexer again */", "  return OK;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * vim_regexec and friends"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Global work variables for vim_regexec()."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/* Save the sub-expressions before attempting a match. */", "#define save_se(savep, posp, pp) \\"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/* After a failed match restore the sub-expressions. */", "#define restore_se(savep, posp, pp) { \\"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define restore_se(savep, posp, pp) { \\", "    if (REG_MULTI) \\", "      *(posp) = (savep)->se_u.pos; \\"], "readability/braces"]
["src/nvim/regexp.c", ["      *(posp) = (savep)->se_u.pos; \\", "    else \\", "      *(pp) = (savep)->se_u.ptr; }"], "readability/braces"]
["src/nvim/regexp.c", ["      *(posp) = (savep)->se_u.pos; \\", "    else \\", "      *(pp) = (savep)->se_u.ptr; }"], "whitespace/newline"]
["src/nvim/regexp.c", ["", "/*", " * \"regstack\" and \"backpos\" are used by regmatch().  They are kept over calls"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Both for regstack and backpos tables we use the following strategy of"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Get pointer to the line \"lnum\", which is relative to \"reg_firstlnum\"."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "static char_u   *reg_startzp[NSUBEXP];  /* Workspace to mark beginning */", "static char_u   *reg_endzp[NSUBEXP];    /*   and end of \\z(...\\) matches */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["static char_u   *reg_startzp[NSUBEXP];  /* Workspace to mark beginning */", "static char_u   *reg_endzp[NSUBEXP];    /*   and end of \\z(...\\) matches */", "static lpos_T reg_startzpos[NSUBEXP];   /* idem, beginning pos */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["static char_u   *reg_endzp[NSUBEXP];    /*   and end of \\z(...\\) matches */", "static lpos_T reg_startzpos[NSUBEXP];   /* idem, beginning pos */", "static lpos_T reg_endzpos[NSUBEXP];     /* idem, end pos */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["static lpos_T reg_startzpos[NSUBEXP];   /* idem, beginning pos */", "static lpos_T reg_endzpos[NSUBEXP];     /* idem, end pos */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Match a regexp against a string."], "readability/old_style_comment"]
["src/nvim/regexp.c", [" */", "static int ", "bt_regexec_nl ("], "whitespace/end_of_line"]
["src/nvim/regexp.c", ["static int ", "bt_regexec_nl (", "    regmatch_T *rmp,"], "whitespace/parens"]
["src/nvim/regexp.c", ["    regmatch_T *rmp,", "    char_u *line,      /* string to match against */", "    colnr_T col,       /* column to start looking for match */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    char_u *line,      /* string to match against */", "    colnr_T col,       /* column to start looking for match */", "    bool line_lbr"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["/// Uses curbuf for line count and 'iskeyword'.", "/// ", "/// @param win Window in which to search or NULL"], "whitespace/end_of_line"]
["src/nvim/regexp.c", ["/// @param buf Buffer in which to search", "/// @param lnum Number of line to start looking for match ", "/// @param col Column to start looking for match"], "whitespace/end_of_line"]
["src/nvim/regexp.c", ["", "  /* Create \"regstack\" and \"backpos\" if they are not allocated yet.", "   * We allocate *_INITIAL amount of bytes first and then set the grow size"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  if (regstack.ga_data == NULL) {", "    /* Use an item size of 1 byte, since we push different things", "     * onto the regstack. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  /* Be paranoid... */", "  if (prog == NULL || line == NULL) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  /* Check validity of program. */", "  if (prog_magic_wrong())"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  /* Check validity of program. */", "  if (prog_magic_wrong())", "    goto theend;"], "readability/braces"]
["src/nvim/regexp.c", ["", "  /* If there is a \"must appear\" string, look for it. */", "  if (prog->regmust != NULL) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  /* Simplest case: Anchored match need be tried only once. */", "  if (prog->reganch) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    int tm_count = 0;", "    /* Messy cases:  unanchored match. */", "    while (!got_int) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["theend:", "  /* Free \"reg_tofree\" when it's a bit big.", "   * Free regstack and backpos if they are bigger than their initial size. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  }", "  if (regstack.ga_maxlen > REGSTACK_INITIAL)", "    ga_clear(&regstack);"], "readability/braces"]
["src/nvim/regexp.c", ["    ga_clear(&regstack);", "  if (backpos.ga_maxlen > BACKPOS_INITIAL)", "    ga_clear(&backpos);"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Create a new extmatch and mark it as referenced once."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Add a reference to an extmatch."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["{", "  if (em != NULL)", "    em->refcnt++;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Remove a reference to an extmatch.  If there are no references left, free"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  if (em != NULL && --em->refcnt <= 0) {", "    for (i = 0; i < NSUBEXP; ++i)", "      xfree(em->matches[i]);"], "readability/braces"]
["src/nvim/regexp.c", ["  if (em != NULL && --em->refcnt <= 0) {", "    for (i = 0; i < NSUBEXP; ++i)", "      xfree(em->matches[i]);"], "readability/increment"]
["src/nvim/regexp.c", ["  }", "  /* Package any found \\z(...\\) matches for export. Default is none. */", "  unref_extmatch(re_extmatch_out);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      if (REG_MULTI) {", "        /* Only accept single line matches. */", "        if (reg_startzpos[i].lnum >= 0"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      } else {", "        if (reg_startzp[i] != NULL && reg_endzp[i] != NULL)", "          re_extmatch_out->matches[i] ="], "readability/braces"]
["src/nvim/regexp.c", ["    getvvcol(wp, &bot, &start2, NULL, &end2);", "    if (start2 < start)", "      start = start2;"], "readability/braces"]
["src/nvim/regexp.c", ["      start = start2;", "    if (end2 > end)", "      end = end2;"], "readability/braces"]
["src/nvim/regexp.c", ["      end = end2;", "    if (top.col == MAXCOL || bot.col == MAXCOL)", "      end = MAXCOL;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * The arguments from BRACE_LIMITS are stored here.  They are actually local"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["{", "  char_u        *next;          /* Next node. */", "  int op;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  /*", "   * Repeat until \"regstack\" is empty."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  for (;; ) {", "    /* Some patterns may take a long time to match, e.g., \"\\([a-z]\\+\\)\\+Q\".", "     * Allow interrupting them with CTRL-C. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "    /*", "     * Repeat for items that can be matched sequentially, without using the"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["            mch_errmsg(\"    \\\"\");", "            if (re_extmatch_in->matches[i] != NULL)", "              mch_errmsg((char *)re_extmatch_in->matches[i]);"], "readability/braces"]
["src/nvim/regexp.c", ["        case RE_MARK:", "          /* Compare the mark position to the match position. */", "        {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        case RE_VISUAL:", "          if (!reg_match_visual())", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["        case IDENT:", "          if (!vim_isIDc(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case WHITE:", "          if (!ascii_iswhite(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case NWHITE:", "          if (c == NUL || ascii_iswhite(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case DIGIT:", "          if (!ri_digit(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case NDIGIT:", "          if (c == NUL || ri_digit(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case HEX:", "          if (!ri_hex(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case NHEX:", "          if (c == NUL || ri_hex(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case OCTAL:", "          if (!ri_octal(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case NOCTAL:", "          if (c == NUL || ri_octal(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case WORD:", "          if (!ri_word(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case NWORD:", "          if (c == NUL || ri_word(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case HEAD:", "          if (!ri_head(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case NHEAD:", "          if (c == NUL || ri_head(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case ALPHA:", "          if (!ri_alpha(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case NALPHA:", "          if (c == NUL || ri_alpha(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case LOWER:", "          if (!ri_lower(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case NLOWER:", "          if (c == NUL || ri_lower(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case UPPER:", "          if (!ri_upper(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case NUPPER:", "          if (c == NUL || ri_upper(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case ANYBUT:", "          if (c == NUL)", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else if ((cstrchr(OPERAND(scan), c) == NULL) == (op == ANYOF))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["", "          /*", "           * When we run into BACK we need to check if we don't keep"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          backpos_T *bp = (backpos_T *)backpos.ga_data;", "          for (i = 0; i < backpos.ga_len; ++i)", "            if (bp[i].bp_scan == scan)"], "readability/braces"]
["src/nvim/regexp.c", ["          backpos_T *bp = (backpos_T *)backpos.ga_data;", "          for (i = 0; i < backpos.ga_len; ++i)", "            if (bp[i].bp_scan == scan)"], "readability/increment"]
["src/nvim/regexp.c", ["          for (i = 0; i < backpos.ga_len; ++i)", "            if (bp[i].bp_scan == scan)", "              break;"], "readability/braces"]
["src/nvim/regexp.c", ["            p->bp_scan = scan;", "          } else if (reg_save_equal(&bp[i].bp_pos))", "            /* Still at same position as last time, fail. */"], "readability/braces"]
["src/nvim/regexp.c", ["          } else if (reg_save_equal(&bp[i].bp_pos))", "            /* Still at same position as last time, fail. */", "            status = RA_NOMATCH;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "        case MOPEN + 0:     /* Match start: \\zs */", "        case MOPEN + 1:     /* \\( */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        case MOPEN + 0:     /* Match start: \\zs */", "        case MOPEN + 1:     /* \\( */", "        case MOPEN + 2:"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          rp = regstack_push(RS_MOPEN, scan);", "          if (rp == NULL)", "            status = RA_FAIL;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_FAIL;", "          else {", "            rp->rs_no = no;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_FAIL;", "          else {", "            rp->rs_no = no;"], "readability/braces"]
["src/nvim/regexp.c", ["", "        case NOPEN:         /* \\%( */", "        case NCLOSE:        /* \\) after \\%( */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        case NOPEN:         /* \\%( */", "        case NCLOSE:        /* \\) after \\%( */", "          if (regstack_push(RS_NOPEN, scan) == NULL)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        case NCLOSE:        /* \\) after \\%( */", "          if (regstack_push(RS_NOPEN, scan) == NULL)", "            status = RA_FAIL;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_FAIL;", "          /* We simply continue and handle the result when done. */", "          break;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          rp = regstack_push(RS_ZOPEN, scan);", "          if (rp == NULL)", "            status = RA_FAIL;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_FAIL;", "          else {", "            rp->rs_no = no;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_FAIL;", "          else {", "            rp->rs_no = no;"], "readability/braces"]
["src/nvim/regexp.c", ["            save_se(&rp->rs_un.sesave, &reg_startzpos[no],", "                &reg_startzp[no]);", "            /* We simply continue and handle the result when done. */"], "whitespace/alignment"]
["src/nvim/regexp.c", ["                &reg_startzp[no]);", "            /* We simply continue and handle the result when done. */", "          }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "        case MCLOSE + 0:    /* Match end: \\ze */", "        case MCLOSE + 1:    /* \\) */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        case MCLOSE + 0:    /* Match end: \\ze */", "        case MCLOSE + 1:    /* \\) */", "        case MCLOSE + 2:"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "        case ZCLOSE + 1:    /* \\) after \\z( */", "        case ZCLOSE + 2:"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          rp = regstack_push(RS_ZCLOSE, scan);", "          if (rp == NULL)", "            status = RA_FAIL;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_FAIL;", "          else {", "            rp->rs_no = no;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_FAIL;", "          else {", "            rp->rs_no = no;"], "readability/braces"]
["src/nvim/regexp.c", ["            save_se(&rp->rs_un.sesave, &reg_endzpos[no],", "                &reg_endzp[no]);", "            /* We simply continue and handle the result when done. */"], "whitespace/alignment"]
["src/nvim/regexp.c", ["                &reg_endzp[no]);", "            /* We simply continue and handle the result when done. */", "          }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        {", "          if (OP(next) != BRANCH)       /* No choice. */", "            next = OPERAND(scan);               /* Avoid recursion. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        {", "          if (OP(next) != BRANCH)       /* No choice. */", "            next = OPERAND(scan);               /* Avoid recursion. */"], "readability/braces"]
["src/nvim/regexp.c", ["          if (OP(next) != BRANCH)       /* No choice. */", "            next = OPERAND(scan);               /* Avoid recursion. */", "          else {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["            next = OPERAND(scan);               /* Avoid recursion. */", "          else {", "            rp = regstack_push(RS_BRANCH, scan);"], "readability/braces"]
["src/nvim/regexp.c", ["            next = OPERAND(scan);               /* Avoid recursion. */", "          else {", "            rp = regstack_push(RS_BRANCH, scan);"], "readability/braces"]
["src/nvim/regexp.c", ["            rp = regstack_push(RS_BRANCH, scan);", "            if (rp == NULL)", "              status = RA_FAIL;"], "readability/braces"]
["src/nvim/regexp.c", ["              status = RA_FAIL;", "            else", "              status = RA_BREAK;                /* rest is below */"], "readability/braces"]
["src/nvim/regexp.c", ["            else", "              status = RA_BREAK;                /* rest is below */", "          }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          no = op - BRACE_COMPLEX;", "          ++brace_count[no];", ""], "readability/increment"]
["src/nvim/regexp.c", ["", "          /* If not matched enough times yet, try one more */", "          if (brace_count[no] <= (brace_min[no] <= brace_max[no]"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["            rp = regstack_push(RS_BRCPLX_MORE, scan);", "            if (rp == NULL)", "              status = RA_FAIL;"], "readability/braces"]
["src/nvim/regexp.c", ["              status = RA_FAIL;", "            else {", "              rp->rs_no = no;"], "readability/braces"]
["src/nvim/regexp.c", ["              status = RA_FAIL;", "            else {", "              rp->rs_no = no;"], "readability/braces"]
["src/nvim/regexp.c", ["              next = OPERAND(scan);", "              /* We continue and handle the result when done. */", "            }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "          /* If matched enough times, may try matching some more */", "          if (brace_min[no] <= brace_max[no]) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          if (brace_min[no] <= brace_max[no]) {", "            /* Range is the normal way around, use longest match */", "            if (brace_count[no] <= brace_max[no]) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              rp = regstack_push(RS_BRCPLX_LONG, scan);", "              if (rp == NULL)", "                status = RA_FAIL;"], "readability/braces"]
["src/nvim/regexp.c", ["                status = RA_FAIL;", "              else {", "                rp->rs_no = no;"], "readability/braces"]
["src/nvim/regexp.c", ["                status = RA_FAIL;", "              else {", "                rp->rs_no = no;"], "readability/braces"]
["src/nvim/regexp.c", ["                next = OPERAND(scan);", "                /* We continue and handle the result when done. */", "              }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          } else {", "            /* Range is backwards, use shortest match first */", "            if (brace_count[no] <= brace_min[no]) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              rp = regstack_push(RS_BRCPLX_SHORT, scan);", "              if (rp == NULL)", "                status = RA_FAIL;"], "readability/braces"]
["src/nvim/regexp.c", ["                status = RA_FAIL;", "              else {", "                reg_save(&rp->rs_un.regsave, &backpos);"], "readability/braces"]
["src/nvim/regexp.c", ["                status = RA_FAIL;", "              else {", "                reg_save(&rp->rs_un.regsave, &backpos);"], "readability/braces"]
["src/nvim/regexp.c", ["                reg_save(&rp->rs_un.regsave, &backpos);", "                /* We continue and handle the result when done. */", "              }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "          /*", "           * Lookahead to avoid useless match attempts when we know"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "          /*", "           * When maxval > minval, try matching as much as possible, up"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              ? rst.count >= rst.minval : rst.count >= rst.maxval) {", "            /* It could match.  Prepare for trying to match what", "             * follows.  The code is below.  Parameters are stored in"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              rp = regstack_push(rst.minval <= rst.maxval", "                  ? RS_STAR_LONG : RS_STAR_SHORT, scan);", "              if (rp == NULL)"], "whitespace/alignment"]
["src/nvim/regexp.c", ["                  ? RS_STAR_LONG : RS_STAR_SHORT, scan);", "              if (rp == NULL)", "                status = RA_FAIL;"], "readability/braces"]
["src/nvim/regexp.c", ["                status = RA_FAIL;", "              else {", "                *(((regstar_T *)rp) - 1) = rst;"], "readability/braces"]
["src/nvim/regexp.c", ["                status = RA_FAIL;", "              else {", "                *(((regstar_T *)rp) - 1) = rst;"], "readability/braces"]
["src/nvim/regexp.c", ["                *(((regstar_T *)rp) - 1) = rst;", "                status = RA_BREAK;                  /* skip the restore bits */", "              }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["            }", "          } else", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "", "        }"], "whitespace/blank_line"]
["src/nvim/regexp.c", ["          rp = regstack_push(RS_NOMATCH, scan);", "          if (rp == NULL)", "            status = RA_FAIL;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_FAIL;", "          else {", "            rp->rs_no = op;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_FAIL;", "          else {", "            rp->rs_no = op;"], "readability/braces"]
["src/nvim/regexp.c", ["            next = OPERAND(scan);", "            /* We continue and handle the result when done. */", "          }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        case NOBEHIND:", "          /* Need a bit of room to store extra positions. */", "          if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["            rp = regstack_push(RS_BEHIND1, scan);", "            if (rp == NULL)", "              status = RA_FAIL;"], "readability/braces"]
["src/nvim/regexp.c", ["              status = RA_FAIL;", "            else {", "              /* Need to save the subexpr to be able to restore them"], "readability/braces"]
["src/nvim/regexp.c", ["              status = RA_FAIL;", "            else {", "              /* Need to save the subexpr to be able to restore them"], "readability/braces"]
["src/nvim/regexp.c", ["            else {", "              /* Need to save the subexpr to be able to restore them", "               * when there is a match but we don't use it. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              reg_save(&rp->rs_un.regsave, &backpos);", "              /* First try if what follows matches.  If it does then we", "               * check the behind match by looping. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        case END:", "          status = RA_MATCH;    /* Success! */", "          break;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "      /* If we can't continue sequentially, break the inner loop. */", "      if (status != RA_CONT)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      /* If we can't continue sequentially, break the inner loop. */", "      if (status != RA_CONT)", "        break;"], "readability/braces"]
["src/nvim/regexp.c", ["", "      /* Continue in inner loop, advance to next item. */", "      scan = next;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      scan = next;", "", "    } /* end of inner loop */"], "whitespace/blank_line"]
["src/nvim/regexp.c", ["", "    } /* end of inner loop */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "    /*", "     * If there is something on the regstack execute the code for the state."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      case RS_NOPEN:", "        /* Result is passed on as-is, simply pop the state. */", "        regstack_pop(&scan);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      case RS_ZOPEN:", "        /* Pop the state.  Restore pointers when there is no match. */", "        if (status == RA_NOMATCH)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        /* Pop the state.  Restore pointers when there is no match. */", "        if (status == RA_NOMATCH)", "          restore_se(&rp->rs_un.sesave, &reg_startzpos[rp->rs_no],"], "readability/braces"]
["src/nvim/regexp.c", ["          restore_se(&rp->rs_un.sesave, &reg_startzpos[rp->rs_no],", "              &reg_startzp[rp->rs_no]);", "        regstack_pop(&scan);"], "whitespace/alignment"]
["src/nvim/regexp.c", ["      case RS_ZCLOSE:", "        /* Pop the state.  Restore pointers when there is no match. */", "        if (status == RA_NOMATCH)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        /* Pop the state.  Restore pointers when there is no match. */", "        if (status == RA_NOMATCH)", "          restore_se(&rp->rs_un.sesave, &reg_endzpos[rp->rs_no],"], "readability/braces"]
["src/nvim/regexp.c", ["          restore_se(&rp->rs_un.sesave, &reg_endzpos[rp->rs_no],", "              &reg_endzp[rp->rs_no]);", "        regstack_pop(&scan);"], "whitespace/alignment"]
["src/nvim/regexp.c", ["      case RS_BRANCH:", "        if (status == RA_MATCH)", "          /* this branch matched, use it */"], "readability/braces"]
["src/nvim/regexp.c", ["        if (status == RA_MATCH)", "          /* this branch matched, use it */", "          regstack_pop(&scan);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          regstack_pop(&scan);", "        else {", "          if (status != RA_BREAK) {"], "readability/braces"]
["src/nvim/regexp.c", ["          regstack_pop(&scan);", "        else {", "          if (status != RA_BREAK) {"], "readability/braces"]
["src/nvim/regexp.c", ["          if (status != RA_BREAK) {", "            /* After a non-matching branch: try next one. */", "            reg_restore(&rp->rs_un.regsave, &backpos);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          if (scan == NULL || OP(scan) != BRANCH) {", "            /* no more branches, didn't find a match */", "            status = RA_NOMATCH;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          } else {", "            /* Prepare to try a branch. */", "            rp->rs_scan = regnext(scan);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      case RS_BRCPLX_MORE:", "        /* Pop the state.  Restore pointers when there is no match. */", "        if (status == RA_NOMATCH) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          reg_restore(&rp->rs_un.regsave, &backpos);", "          --brace_count[rp->rs_no];             /* decrement match count */", "        }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          reg_restore(&rp->rs_un.regsave, &backpos);", "          --brace_count[rp->rs_no];             /* decrement match count */", "        }"], "readability/increment"]
["src/nvim/regexp.c", ["      case RS_BRCPLX_LONG:", "        /* Pop the state.  Restore pointers when there is no match. */", "        if (status == RA_NOMATCH) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        if (status == RA_NOMATCH) {", "          /* There was no match, but we did find enough matches. */", "          reg_restore(&rp->rs_un.regsave, &backpos);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          reg_restore(&rp->rs_un.regsave, &backpos);", "          --brace_count[rp->rs_no];", "          /* continue with the items after \"\\{}\" */"], "readability/increment"]
["src/nvim/regexp.c", ["          --brace_count[rp->rs_no];", "          /* continue with the items after \"\\{}\" */", "          status = RA_CONT;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        regstack_pop(&scan);", "        if (status == RA_CONT)", "          scan = regnext(scan);"], "readability/braces"]
["src/nvim/regexp.c", ["      case RS_BRCPLX_SHORT:", "        /* Pop the state.  Restore pointers when there is no match. */", "        if (status == RA_NOMATCH)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        /* Pop the state.  Restore pointers when there is no match. */", "        if (status == RA_NOMATCH)", "          /* There was no match, try to match one more item. */"], "readability/braces"]
["src/nvim/regexp.c", ["        if (status == RA_NOMATCH)", "          /* There was no match, try to match one more item. */", "          reg_restore(&rp->rs_un.regsave, &backpos);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      case RS_NOMATCH:", "        /* Pop the state.  If the operand matches for NOMATCH or", "        * doesn't match for MATCH/SUBPAT, we fail.  Otherwise backup,"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        * except for SUBPAT, and continue with the next item. */", "        if (status == (rp->rs_no == NOMATCH ? RA_MATCH : RA_NOMATCH))", "          status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["          status = RA_NOMATCH;", "        else {", "          status = RA_CONT;"], "readability/braces"]
["src/nvim/regexp.c", ["          status = RA_NOMATCH;", "        else {", "          status = RA_CONT;"], "readability/braces"]
["src/nvim/regexp.c", ["          status = RA_CONT;", "          if (rp->rs_no != SUBPAT)              /* zero-width */", "            reg_restore(&rp->rs_un.regsave, &backpos);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          status = RA_CONT;", "          if (rp->rs_no != SUBPAT)              /* zero-width */", "            reg_restore(&rp->rs_un.regsave, &backpos);"], "readability/braces"]
["src/nvim/regexp.c", ["        regstack_pop(&scan);", "        if (status == RA_CONT)", "          scan = regnext(scan);"], "readability/braces"]
["src/nvim/regexp.c", ["        } else {", "          /* The stuff after BEHIND/NOBEHIND matches.  Now try if", "           * the behind part does (not) match before the current"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "          /* save the position after the found match for next */", "          reg_save(&(((regbehind_T *)rp) - 1)->save_after, &backpos);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "          /* Start looking for a match with operand at the current", "           * position.  Go back one character until we find the"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      case RS_BEHIND2:", "        /*", "         * Looping for BEHIND / NOBEHIND match."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        if (status == RA_MATCH && reg_save_equal(&behind_pos)) {", "          /* found a match that ends where \"next\" started */", "          behind_pos = (((regbehind_T *)rp) - 1)->save_behind;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          behind_pos = (((regbehind_T *)rp) - 1)->save_behind;", "          if (rp->rs_no == BEHIND)", "            reg_restore(&(((regbehind_T *)rp) - 1)->save_after,"], "readability/braces"]
["src/nvim/regexp.c", ["            reg_restore(&(((regbehind_T *)rp) - 1)->save_after,", "                &backpos);", "          else {"], "whitespace/alignment"]
["src/nvim/regexp.c", ["                &backpos);", "          else {", "            /* But we didn't want a match.  Need to restore the"], "readability/braces"]
["src/nvim/regexp.c", ["                &backpos);", "          else {", "            /* But we didn't want a match.  Need to restore the"], "readability/braces"]
["src/nvim/regexp.c", ["          else {", "            /* But we didn't want a match.  Need to restore the", "             * subexpr, because what follows matched, so they have"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "          /* No match or a match that doesn't end where we want it: Go", "           * back one character.  May go to previous line once. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          if (REG_MULTI) {", "            if (limit > 0", "                && ((rp->rs_un.regsave.rs_u.pos.lnum"], "readability/braces"]
["src/nvim/regexp.c", ["              no = FAIL;", "            else if (rp->rs_un.regsave.rs_u.pos.col == 0) {", "              if (rp->rs_un.regsave.rs_u.pos.lnum"], "readability/braces"]
["src/nvim/regexp.c", ["            else if (rp->rs_un.regsave.rs_u.pos.col == 0) {", "              if (rp->rs_un.regsave.rs_u.pos.lnum", "                  < behind_pos.rs_u.pos.lnum"], "readability/braces"]
["src/nvim/regexp.c", ["                  || reg_getline(", "                      --rp->rs_un.regsave.rs_u.pos.lnum)", "                  == NULL)"], "readability/increment"]
["src/nvim/regexp.c", ["                no = FAIL;", "              else {", "                reg_restore(&rp->rs_un.regsave, &backpos);"], "readability/braces"]
["src/nvim/regexp.c", ["                no = FAIL;", "              else {", "                reg_restore(&rp->rs_un.regsave, &backpos);"], "readability/braces"]
["src/nvim/regexp.c", ["          if (no == OK) {", "            /* Advanced, prepare for finding match again. */", "            reg_restore(&rp->rs_un.regsave, &backpos);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["            if (status == RA_MATCH) {", "              /* We did match, so subexpr may have been changed,", "               * need to restore them for the next try. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          } else {", "            /* Can't advance.  For NOBEHIND that's a match. */", "            behind_pos = (((regbehind_T *)rp) - 1)->save_behind;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              reg_restore(&(((regbehind_T *)rp) - 1)->save_after,", "                  &backpos);", "              status = RA_MATCH;"], "whitespace/alignment"]
["src/nvim/regexp.c", ["            } else {", "              /* We do want a proper match.  Need to restore the", "               * subexpr if we had a match, because they may have"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "        /* Tried once already, restore input pointers. */", "        if (status != RA_BREAK)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        /* Tried once already, restore input pointers. */", "        if (status != RA_BREAK)", "          reg_restore(&rp->rs_un.regsave, &backpos);"], "readability/braces"]
["src/nvim/regexp.c", ["", "        /* Repeat until we found a position where it could match. */", "        for (;; ) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          if (status != RA_BREAK) {", "            /* Tried first position already, advance. */", "            if (rp->rs_state == RS_STAR_LONG) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["            if (rp->rs_state == RS_STAR_LONG) {", "              /* Trying for longest match, but couldn't or", "               * didn't match -- back up one char. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["               * didn't match -- back up one char. */", "              if (--rst->count < rst->minval)", "                break;"], "readability/braces"]
["src/nvim/regexp.c", ["            } else {", "              /* Range is backwards, use shortest match first.", "               * Careful: maxval and minval are exchanged!"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["               * char. */", "              if (rst->count == rst->minval", "                  || regrepeat(OPERAND(rp->rs_scan), 1L) == 0)"], "readability/braces"]
["src/nvim/regexp.c", ["                break;", "              ++rst->count;", "            }"], "readability/increment"]
["src/nvim/regexp.c", ["            }", "            if (got_int)", "              break;"], "readability/braces"]
["src/nvim/regexp.c", ["              break;", "          } else", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["        if (status != RA_CONT) {", "          /* Failed. */", "          regstack_pop(&scan);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "      /* If we want to continue the inner loop or didn't pop a state", "       * continue matching loop */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["       * continue matching loop */", "      if (status == RA_CONT || rp == (regitem_T *)", "          ((char *)regstack.ga_data + regstack.ga_len) - 1)"], "readability/braces"]
["src/nvim/regexp.c", ["", "    /* May need to continue with the inner loop, starting at \"scan\". */", "    if (status == RA_CONT)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    /* May need to continue with the inner loop, starting at \"scan\". */", "    if (status == RA_CONT)", "      continue;"], "readability/braces"]
["src/nvim/regexp.c", ["", "    /*", "     * If the regstack is empty or something failed we are done."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      if (scan == NULL) {", "        /*", "         * We get here only if there's trouble -- normally \"case END\" is"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    }", "", "  } /* End of loop until the regstack is empty. */"], "whitespace/blank_line"]
["src/nvim/regexp.c", ["", "  } /* End of loop until the regstack is empty. */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  /* NOTREACHED */", "}"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  /* NOTREACHED */", "}", ""], "readability/fn_size"]
["src/nvim/regexp.c", ["", "/*", " * Push an item onto the regstack."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Pop an item from the regstack."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * regrepeat - repeatedly match something simple, return how many."], "readability/old_style_comment"]
["src/nvim/regexp.c", [" */", "static int ", "regrepeat ("], "whitespace/end_of_line"]
["src/nvim/regexp.c", ["static int ", "regrepeat (", "    char_u *p,"], "whitespace/parens"]
["src/nvim/regexp.c", ["    char_u *p,", "    long maxcount              /* maximum number of matches allowed */", ")"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    while (count < maxcount) {", "      /* Matching anything means we continue until end-of-line (or", "       * end-of-file for ANY + ADD_NL), only limited by maxcount. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      }", "      ++count;", "    }"], "readability/increment"]
["src/nvim/regexp.c", ["      }", "      ++count;", "    }"], "readability/increment"]
["src/nvim/regexp.c", ["", "    /* Safety check (just in case 'encoding' was changed since", "     * compiling the program). */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      while (count < maxcount && (*mb_ptr2len)(scan) >= len) {", "        for (i = 0; i < len; ++i) {", "          if (opnd[i] != scan[i]) {"], "readability/increment"]
["src/nvim/regexp.c", ["        scan += len;", "        ++count;", "      }"], "readability/increment"]
["src/nvim/regexp.c", ["      } else {", "        if ((cstrchr(opnd, *scan) == NULL) == testval)", "          break;"], "readability/braces"]
["src/nvim/regexp.c", ["          break;", "        ++scan;", "      }"], "readability/increment"]
["src/nvim/regexp.c", ["      }", "      ++count;", "    }"], "readability/increment"]
["src/nvim/regexp.c", ["", "/*", " * regnext - dig the \"next\" pointer out of a node"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  if (p == JUST_CALC_SIZE || reg_toolong)", "    return NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["  offset = NEXT(p);", "  if (offset == 0)", "    return NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["", "  if (OP(p) == BACK)", "    return p - offset;"], "readability/braces"]
["src/nvim/regexp.c", ["    return p - offset;", "  else", "    return p + offset;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Check the regexp program for its magic number."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Cleanup the subexpressions, if this wasn't done yet."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    if (REG_MULTI) {", "      /* Use 0xff to set lnum to -1 */", "      memset(reg_startzpos, 0xff, sizeof(lpos_T) * NSUBEXP);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Tentatively set the sub-expression start to the current position (after"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Compare a number with the operand of RE_LNUM, RE_COL or RE_VCOL."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  if (OPERAND_CMP(scan) == '>')", "    return val > n;"], "readability/braces"]
["src/nvim/regexp.c", ["    return val > n;", "  if (OPERAND_CMP(scan) == '<')", "    return val < n;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Check whether a backreference matches."], "readability/old_style_comment"]
["src/nvim/regexp.c", [" */", "static int match_with_backref(linenr_T start_lnum, colnr_T start_col, linenr_T end_lnum, colnr_T end_col, int *bytelen)", "{"], "whitespace/line_length"]
["src/nvim/regexp.c", ["", "  if (bytelen != NULL)", "    *bytelen = 0;"], "readability/braces"]
["src/nvim/regexp.c", ["  for (;; ) {", "    /* Since getting one line may invalidate the other, need to make copy.", "     * Slow! */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      if (reg_tofree == NULL || len >= (int)reg_tofreelen) {", "        len += 50;              /* get some extra */", "        xfree(reg_tofree);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "    /* Get the line to compare with. */", "    p = reg_getline(clnum);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "    if (clnum == end_lnum)", "      len = end_col - ccol;"], "readability/braces"]
["src/nvim/regexp.c", ["      len = end_col - ccol;", "    else", "      len = (int)STRLEN(p + ccol);"], "readability/braces"]
["src/nvim/regexp.c", ["", "    /* Advance to next line. */", "    reg_nextline();"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    reg_nextline();", "    if (bytelen != NULL)", "      *bytelen = 0;"], "readability/braces"]
["src/nvim/regexp.c", ["      *bytelen = 0;", "    ++clnum;", "    ccol = 0;"], "readability/increment"]
["src/nvim/regexp.c", ["    ccol = 0;", "    if (got_int)", "      return RA_FAIL;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * regdump - dump a regexp onto stdout in vaguely comprehensible form"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  char_u  *s;", "  int op = EXACTLY;             /* Arbitrary non-END op. */", "  char_u  *next;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#endif", "  if (f == NULL)", "    return;"], "readability/braces"]
["src/nvim/regexp.c", ["  fprintf(f, \"-------------------------------------\\n\\r\\nregcomp(%s):\\r\\n\",", "      pattern);", ""], "whitespace/alignment"]
["src/nvim/regexp.c", ["  s = r->program + 1;", "  /*", "   * Loop until we find the END that isn't before a referred next (an END"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    op = OP(s);", "    fprintf(f, \"%2d%s\", (int)(s - r->program), regprop(s));     /* Where, what. */", "    next = regnext(s);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    op = OP(s);", "    fprintf(f, \"%2d%s\", (int)(s - r->program), regprop(s));     /* Where, what. */", "    next = regnext(s);"], "whitespace/line_length"]
["src/nvim/regexp.c", ["    next = regnext(s);", "    if (next == NULL)           /* Next ptr. */", "      fprintf(f, \"(0)\");"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    next = regnext(s);", "    if (next == NULL)           /* Next ptr. */", "      fprintf(f, \"(0)\");"], "readability/braces"]
["src/nvim/regexp.c", ["      fprintf(f, \"(0)\");", "    else", "      fprintf(f, \"(%d)\", (int)((s - r->program) + (next - s)));"], "readability/braces"]
["src/nvim/regexp.c", ["      fprintf(f, \"(%d)\", (int)((s - r->program) + (next - s)));", "    if (end < next)", "      end = next;"], "readability/braces"]
["src/nvim/regexp.c", ["    if (op == BRACE_LIMITS) {", "      /* Two ints */", "      fprintf(f, \" minval %\" PRId64 \", maxval %\" PRId64,"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    } else if (op == BEHIND || op == NOBEHIND) {", "      /* one int */", "      fprintf(f, \" count %\" PRId64, (int64_t)OPERAND_MIN(s));"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        || op == EXACTLY) {", "      /* Literal string, where present. */", "      fprintf(f, \"\\nxxxxxxxxx\\n\");"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      fprintf(f, \"\\nxxxxxxxxx\\n\");", "      while (*s != NUL)", "        fprintf(f, \"%c\", *s++);"], "readability/braces"]
["src/nvim/regexp.c", ["", "  /* Header fields of interest. */", "  if (r->regstart != NUL)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  /* Header fields of interest. */", "  if (r->regstart != NUL)", "    fprintf(f, \"start `%s' 0x%x; \", r->regstart < 256"], "readability/braces"]
["src/nvim/regexp.c", ["    fprintf(f, \"start `%s' 0x%x; \", r->regstart < 256", "        ? (char *)transchar(r->regstart)", "        : \"multibyte\", r->regstart);"], "whitespace/alignment"]
["src/nvim/regexp.c", ["        ? (char *)transchar(r->regstart)", "        : \"multibyte\", r->regstart);", "  if (r->reganch)"], "whitespace/alignment"]
["src/nvim/regexp.c", ["        : \"multibyte\", r->regstart);", "  if (r->reganch)", "    fprintf(f, \"anchored; \");"], "readability/braces"]
["src/nvim/regexp.c", ["    fprintf(f, \"anchored; \");", "  if (r->regmust != NULL)", "    fprintf(f, \"must have \\\"%s\\\"\", r->regmust);"], "readability/braces"]
["src/nvim/regexp.c", ["}", "#endif      /* BT_REGEXP_DUMP */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#ifdef REGEXP_DEBUG", "/*", " * regprop - printable representation of opcode"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  switch ((int) OP(op)) {", "  case BOL:"], "whitespace/cast"]
["src/nvim/regexp.c", ["  case MOPEN + 9:", "    sprintf(buf + STRLEN(buf), \"MOPEN%d\", OP(op) - MOPEN);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp.c", ["  case MCLOSE + 9:", "    sprintf(buf + STRLEN(buf), \"MCLOSE%d\", OP(op) - MCLOSE);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp.c", ["  case BACKREF + 9:", "    sprintf(buf + STRLEN(buf), \"BACKREF%d\", OP(op) - BACKREF);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp.c", ["  case ZOPEN + 9:", "    sprintf(buf + STRLEN(buf), \"ZOPEN%d\", OP(op) - ZOPEN);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp.c", ["  case ZCLOSE + 9:", "    sprintf(buf + STRLEN(buf), \"ZCLOSE%d\", OP(op) - ZCLOSE);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp.c", ["  case ZREF + 9:", "    sprintf(buf + STRLEN(buf), \"ZREF%d\", OP(op) - ZREF);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp.c", ["  case BRACE_COMPLEX + 9:", "    sprintf(buf + STRLEN(buf), \"BRACE_COMPLEX%d\", OP(op) - BRACE_COMPLEX);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp.c", ["  default:", "    sprintf(buf + STRLEN(buf), \"corrupt %d\", OP(op));", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp.c", ["  }", "  if (p != NULL)", "    STRCAT(buf, p);"], "readability/braces"]
["src/nvim/regexp.c", ["}", "#endif      /* REGEXP_DEBUG */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/* 0xfb20 - 0xfb4f */", "static decomp_T decomp_table[0xfb4f-0xfb20+1] ="], "readability/old_style_comment"]
["src/nvim/regexp.c", ["{", "  {0x5e2,0,0},                  /* 0xfb20\talt ayin */", "  {0x5d0,0,0},                  /* 0xfb21\talt alef */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["{", "  {0x5e2,0,0},                  /* 0xfb20\talt ayin */", "  {0x5d0,0,0},                  /* 0xfb21\talt alef */"], "whitespace/tab"]
["src/nvim/regexp.c", ["{", "  {0x5e2,0,0},                  /* 0xfb20\talt ayin */", "  {0x5d0,0,0},                  /* 0xfb21\talt alef */"], "whitespace/comma"]
["src/nvim/regexp.c", ["{", "  {0x5e2,0,0},                  /* 0xfb20\talt ayin */", "  {0x5d0,0,0},                  /* 0xfb21\talt alef */"], "whitespace/braces"]
["src/nvim/regexp.c", ["{", "  {0x5e2,0,0},                  /* 0xfb20\talt ayin */", "  {0x5d0,0,0},                  /* 0xfb21\talt alef */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e2,0,0},                  /* 0xfb20\talt ayin */", "  {0x5d0,0,0},                  /* 0xfb21\talt alef */", "  {0x5d3,0,0},                  /* 0xfb22\talt dalet */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e2,0,0},                  /* 0xfb20\talt ayin */", "  {0x5d0,0,0},                  /* 0xfb21\talt alef */", "  {0x5d3,0,0},                  /* 0xfb22\talt dalet */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e2,0,0},                  /* 0xfb20\talt ayin */", "  {0x5d0,0,0},                  /* 0xfb21\talt alef */", "  {0x5d3,0,0},                  /* 0xfb22\talt dalet */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0x5e2,0,0},                  /* 0xfb20\talt ayin */", "  {0x5d0,0,0},                  /* 0xfb21\talt alef */", "  {0x5d3,0,0},                  /* 0xfb22\talt dalet */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e2,0,0},                  /* 0xfb20\talt ayin */", "  {0x5d0,0,0},                  /* 0xfb21\talt alef */", "  {0x5d3,0,0},                  /* 0xfb22\talt dalet */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d0,0,0},                  /* 0xfb21\talt alef */", "  {0x5d3,0,0},                  /* 0xfb22\talt dalet */", "  {0x5d4,0,0},                  /* 0xfb23\talt he */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d0,0,0},                  /* 0xfb21\talt alef */", "  {0x5d3,0,0},                  /* 0xfb22\talt dalet */", "  {0x5d4,0,0},                  /* 0xfb23\talt he */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d0,0,0},                  /* 0xfb21\talt alef */", "  {0x5d3,0,0},                  /* 0xfb22\talt dalet */", "  {0x5d4,0,0},                  /* 0xfb23\talt he */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0x5d0,0,0},                  /* 0xfb21\talt alef */", "  {0x5d3,0,0},                  /* 0xfb22\talt dalet */", "  {0x5d4,0,0},                  /* 0xfb23\talt he */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d0,0,0},                  /* 0xfb21\talt alef */", "  {0x5d3,0,0},                  /* 0xfb22\talt dalet */", "  {0x5d4,0,0},                  /* 0xfb23\talt he */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d3,0,0},                  /* 0xfb22\talt dalet */", "  {0x5d4,0,0},                  /* 0xfb23\talt he */", "  {0x5db,0,0},                  /* 0xfb24\talt kaf */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d3,0,0},                  /* 0xfb22\talt dalet */", "  {0x5d4,0,0},                  /* 0xfb23\talt he */", "  {0x5db,0,0},                  /* 0xfb24\talt kaf */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d3,0,0},                  /* 0xfb22\talt dalet */", "  {0x5d4,0,0},                  /* 0xfb23\talt he */", "  {0x5db,0,0},                  /* 0xfb24\talt kaf */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0x5d3,0,0},                  /* 0xfb22\talt dalet */", "  {0x5d4,0,0},                  /* 0xfb23\talt he */", "  {0x5db,0,0},                  /* 0xfb24\talt kaf */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d3,0,0},                  /* 0xfb22\talt dalet */", "  {0x5d4,0,0},                  /* 0xfb23\talt he */", "  {0x5db,0,0},                  /* 0xfb24\talt kaf */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d4,0,0},                  /* 0xfb23\talt he */", "  {0x5db,0,0},                  /* 0xfb24\talt kaf */", "  {0x5dc,0,0},                  /* 0xfb25\talt lamed */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d4,0,0},                  /* 0xfb23\talt he */", "  {0x5db,0,0},                  /* 0xfb24\talt kaf */", "  {0x5dc,0,0},                  /* 0xfb25\talt lamed */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d4,0,0},                  /* 0xfb23\talt he */", "  {0x5db,0,0},                  /* 0xfb24\talt kaf */", "  {0x5dc,0,0},                  /* 0xfb25\talt lamed */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0x5d4,0,0},                  /* 0xfb23\talt he */", "  {0x5db,0,0},                  /* 0xfb24\talt kaf */", "  {0x5dc,0,0},                  /* 0xfb25\talt lamed */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d4,0,0},                  /* 0xfb23\talt he */", "  {0x5db,0,0},                  /* 0xfb24\talt kaf */", "  {0x5dc,0,0},                  /* 0xfb25\talt lamed */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5db,0,0},                  /* 0xfb24\talt kaf */", "  {0x5dc,0,0},                  /* 0xfb25\talt lamed */", "  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5db,0,0},                  /* 0xfb24\talt kaf */", "  {0x5dc,0,0},                  /* 0xfb25\talt lamed */", "  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5db,0,0},                  /* 0xfb24\talt kaf */", "  {0x5dc,0,0},                  /* 0xfb25\talt lamed */", "  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0x5db,0,0},                  /* 0xfb24\talt kaf */", "  {0x5dc,0,0},                  /* 0xfb25\talt lamed */", "  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5db,0,0},                  /* 0xfb24\talt kaf */", "  {0x5dc,0,0},                  /* 0xfb25\talt lamed */", "  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5dc,0,0},                  /* 0xfb25\talt lamed */", "  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */", "  {0x5e8,0,0},                  /* 0xfb27\talt resh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5dc,0,0},                  /* 0xfb25\talt lamed */", "  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */", "  {0x5e8,0,0},                  /* 0xfb27\talt resh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5dc,0,0},                  /* 0xfb25\talt lamed */", "  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */", "  {0x5e8,0,0},                  /* 0xfb27\talt resh */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0x5dc,0,0},                  /* 0xfb25\talt lamed */", "  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */", "  {0x5e8,0,0},                  /* 0xfb27\talt resh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5dc,0,0},                  /* 0xfb25\talt lamed */", "  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */", "  {0x5e8,0,0},                  /* 0xfb27\talt resh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */", "  {0x5e8,0,0},                  /* 0xfb27\talt resh */", "  {0x5ea,0,0},                  /* 0xfb28\talt tav */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */", "  {0x5e8,0,0},                  /* 0xfb27\talt resh */", "  {0x5ea,0,0},                  /* 0xfb28\talt tav */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */", "  {0x5e8,0,0},                  /* 0xfb27\talt resh */", "  {0x5ea,0,0},                  /* 0xfb28\talt tav */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */", "  {0x5e8,0,0},                  /* 0xfb27\talt resh */", "  {0x5ea,0,0},                  /* 0xfb28\talt tav */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */", "  {0x5e8,0,0},                  /* 0xfb27\talt resh */", "  {0x5ea,0,0},                  /* 0xfb28\talt tav */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e8,0,0},                  /* 0xfb27\talt resh */", "  {0x5ea,0,0},                  /* 0xfb28\talt tav */", "  {'+', 0, 0},                  /* 0xfb29\talt plus */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e8,0,0},                  /* 0xfb27\talt resh */", "  {0x5ea,0,0},                  /* 0xfb28\talt tav */", "  {'+', 0, 0},                  /* 0xfb29\talt plus */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e8,0,0},                  /* 0xfb27\talt resh */", "  {0x5ea,0,0},                  /* 0xfb28\talt tav */", "  {'+', 0, 0},                  /* 0xfb29\talt plus */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0x5e8,0,0},                  /* 0xfb27\talt resh */", "  {0x5ea,0,0},                  /* 0xfb28\talt tav */", "  {'+', 0, 0},                  /* 0xfb29\talt plus */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e8,0,0},                  /* 0xfb27\talt resh */", "  {0x5ea,0,0},                  /* 0xfb28\talt tav */", "  {'+', 0, 0},                  /* 0xfb29\talt plus */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5ea,0,0},                  /* 0xfb28\talt tav */", "  {'+', 0, 0},                  /* 0xfb29\talt plus */", "  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5ea,0,0},                  /* 0xfb28\talt tav */", "  {'+', 0, 0},                  /* 0xfb29\talt plus */", "  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5ea,0,0},                  /* 0xfb28\talt tav */", "  {'+', 0, 0},                  /* 0xfb29\talt plus */", "  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5ea,0,0},                  /* 0xfb28\talt tav */", "  {'+', 0, 0},                  /* 0xfb29\talt plus */", "  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {'+', 0, 0},                  /* 0xfb29\talt plus */", "  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */", "  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {'+', 0, 0},                  /* 0xfb29\talt plus */", "  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */", "  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {'+', 0, 0},                  /* 0xfb29\talt plus */", "  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */", "  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {'+', 0, 0},                  /* 0xfb29\talt plus */", "  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */", "  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */", "  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */", "  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */", "  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */", "  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */", "  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */", "  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */", "  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */", "  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */", "  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */", "  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */", "  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */", "  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */", "  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */", "  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */", "  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */", "  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */", "  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */", "  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */", "  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */", "  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */", "  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */", "  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */", "  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */", "  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */", "  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */", "  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */", "  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */", "  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */", "  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */", "  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */", "  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */", "  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */", "  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */", "  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */", "  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */", "  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */", "  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */", "  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */", "  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */", "  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */", "  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */", "  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */", "  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */", "  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */", "  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */", "  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */", "  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */", "  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */", "  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */", "  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */", "  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */", "  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */", "  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */", "  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */", "  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */", "  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */", "  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */", "  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */", "  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */", "  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */", "  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */", "  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */", "  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */", "  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */", "  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */", "  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */", "  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */", "  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */", "  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */", "  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */", "  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */", "  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */", "  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */", "  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */", "  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */", "  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */", "  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */", "  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */", "  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */", "  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */", "  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */", "  {0x5d6, 0x5bc, 0},            /* 0xfb36\tzayin+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */", "  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */", "  {0x5d6, 0x5bc, 0},            /* 0xfb36\tzayin+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */", "  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */", "  {0x5d6, 0x5bc, 0},            /* 0xfb36\tzayin+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */", "  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */", "  {0x5d6, 0x5bc, 0},            /* 0xfb36\tzayin+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */", "  {0x5d6, 0x5bc, 0},            /* 0xfb36\tzayin+dagesh */", "  {0xfb37, 0, 0},               /* 0xfb37 -- */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */", "  {0x5d6, 0x5bc, 0},            /* 0xfb36\tzayin+dagesh */", "  {0xfb37, 0, 0},               /* 0xfb37 -- */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */", "  {0x5d6, 0x5bc, 0},            /* 0xfb36\tzayin+dagesh */", "  {0xfb37, 0, 0},               /* 0xfb37 -- */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */", "  {0x5d6, 0x5bc, 0},            /* 0xfb36\tzayin+dagesh */", "  {0xfb37, 0, 0},               /* 0xfb37 -- */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d6, 0x5bc, 0},            /* 0xfb36\tzayin+dagesh */", "  {0xfb37, 0, 0},               /* 0xfb37 -- */", "  {0x5d8, 0x5bc, 0},            /* 0xfb38\ttet+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d6, 0x5bc, 0},            /* 0xfb36\tzayin+dagesh */", "  {0xfb37, 0, 0},               /* 0xfb37 -- */", "  {0x5d8, 0x5bc, 0},            /* 0xfb38\ttet+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d6, 0x5bc, 0},            /* 0xfb36\tzayin+dagesh */", "  {0xfb37, 0, 0},               /* 0xfb37 -- */", "  {0x5d8, 0x5bc, 0},            /* 0xfb38\ttet+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0xfb37, 0, 0},               /* 0xfb37 -- */", "  {0x5d8, 0x5bc, 0},            /* 0xfb38\ttet+dagesh */", "  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0xfb37, 0, 0},               /* 0xfb37 -- */", "  {0x5d8, 0x5bc, 0},            /* 0xfb38\ttet+dagesh */", "  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0xfb37, 0, 0},               /* 0xfb37 -- */", "  {0x5d8, 0x5bc, 0},            /* 0xfb38\ttet+dagesh */", "  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0xfb37, 0, 0},               /* 0xfb37 -- */", "  {0x5d8, 0x5bc, 0},            /* 0xfb38\ttet+dagesh */", "  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d8, 0x5bc, 0},            /* 0xfb38\ttet+dagesh */", "  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */", "  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d8, 0x5bc, 0},            /* 0xfb38\ttet+dagesh */", "  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */", "  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d8, 0x5bc, 0},            /* 0xfb38\ttet+dagesh */", "  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */", "  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d8, 0x5bc, 0},            /* 0xfb38\ttet+dagesh */", "  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */", "  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */", "  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */", "  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */", "  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */", "  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */", "  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */", "  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */", "  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */", "  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */", "  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */", "  {0x5dc, 0x5bc, 0},            /* 0xfb3c\tlamed+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */", "  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */", "  {0x5dc, 0x5bc, 0},            /* 0xfb3c\tlamed+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */", "  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */", "  {0x5dc, 0x5bc, 0},            /* 0xfb3c\tlamed+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */", "  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */", "  {0x5dc, 0x5bc, 0},            /* 0xfb3c\tlamed+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */", "  {0x5dc, 0x5bc, 0},            /* 0xfb3c\tlamed+dagesh */", "  {0xfb3d, 0, 0},               /* 0xfb3d -- */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */", "  {0x5dc, 0x5bc, 0},            /* 0xfb3c\tlamed+dagesh */", "  {0xfb3d, 0, 0},               /* 0xfb3d -- */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */", "  {0x5dc, 0x5bc, 0},            /* 0xfb3c\tlamed+dagesh */", "  {0xfb3d, 0, 0},               /* 0xfb3d -- */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */", "  {0x5dc, 0x5bc, 0},            /* 0xfb3c\tlamed+dagesh */", "  {0xfb3d, 0, 0},               /* 0xfb3d -- */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5dc, 0x5bc, 0},            /* 0xfb3c\tlamed+dagesh */", "  {0xfb3d, 0, 0},               /* 0xfb3d -- */", "  {0x5de, 0x5bc, 0},            /* 0xfb3e\tmem+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5dc, 0x5bc, 0},            /* 0xfb3c\tlamed+dagesh */", "  {0xfb3d, 0, 0},               /* 0xfb3d -- */", "  {0x5de, 0x5bc, 0},            /* 0xfb3e\tmem+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5dc, 0x5bc, 0},            /* 0xfb3c\tlamed+dagesh */", "  {0xfb3d, 0, 0},               /* 0xfb3d -- */", "  {0x5de, 0x5bc, 0},            /* 0xfb3e\tmem+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0xfb3d, 0, 0},               /* 0xfb3d -- */", "  {0x5de, 0x5bc, 0},            /* 0xfb3e\tmem+dagesh */", "  {0xfb3f, 0, 0},               /* 0xfb3f -- */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0xfb3d, 0, 0},               /* 0xfb3d -- */", "  {0x5de, 0x5bc, 0},            /* 0xfb3e\tmem+dagesh */", "  {0xfb3f, 0, 0},               /* 0xfb3f -- */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0xfb3d, 0, 0},               /* 0xfb3d -- */", "  {0x5de, 0x5bc, 0},            /* 0xfb3e\tmem+dagesh */", "  {0xfb3f, 0, 0},               /* 0xfb3f -- */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0xfb3d, 0, 0},               /* 0xfb3d -- */", "  {0x5de, 0x5bc, 0},            /* 0xfb3e\tmem+dagesh */", "  {0xfb3f, 0, 0},               /* 0xfb3f -- */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5de, 0x5bc, 0},            /* 0xfb3e\tmem+dagesh */", "  {0xfb3f, 0, 0},               /* 0xfb3f -- */", "  {0x5e0, 0x5bc, 0},            /* 0xfb40\tnun+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5de, 0x5bc, 0},            /* 0xfb3e\tmem+dagesh */", "  {0xfb3f, 0, 0},               /* 0xfb3f -- */", "  {0x5e0, 0x5bc, 0},            /* 0xfb40\tnun+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5de, 0x5bc, 0},            /* 0xfb3e\tmem+dagesh */", "  {0xfb3f, 0, 0},               /* 0xfb3f -- */", "  {0x5e0, 0x5bc, 0},            /* 0xfb40\tnun+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0xfb3f, 0, 0},               /* 0xfb3f -- */", "  {0x5e0, 0x5bc, 0},            /* 0xfb40\tnun+dagesh */", "  {0x5e1, 0x5bc, 0},            /* 0xfb41\tsamech+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0xfb3f, 0, 0},               /* 0xfb3f -- */", "  {0x5e0, 0x5bc, 0},            /* 0xfb40\tnun+dagesh */", "  {0x5e1, 0x5bc, 0},            /* 0xfb41\tsamech+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0xfb3f, 0, 0},               /* 0xfb3f -- */", "  {0x5e0, 0x5bc, 0},            /* 0xfb40\tnun+dagesh */", "  {0x5e1, 0x5bc, 0},            /* 0xfb41\tsamech+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0xfb3f, 0, 0},               /* 0xfb3f -- */", "  {0x5e0, 0x5bc, 0},            /* 0xfb40\tnun+dagesh */", "  {0x5e1, 0x5bc, 0},            /* 0xfb41\tsamech+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e0, 0x5bc, 0},            /* 0xfb40\tnun+dagesh */", "  {0x5e1, 0x5bc, 0},            /* 0xfb41\tsamech+dagesh */", "  {0xfb42, 0, 0},               /* 0xfb42 -- */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e0, 0x5bc, 0},            /* 0xfb40\tnun+dagesh */", "  {0x5e1, 0x5bc, 0},            /* 0xfb41\tsamech+dagesh */", "  {0xfb42, 0, 0},               /* 0xfb42 -- */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e0, 0x5bc, 0},            /* 0xfb40\tnun+dagesh */", "  {0x5e1, 0x5bc, 0},            /* 0xfb41\tsamech+dagesh */", "  {0xfb42, 0, 0},               /* 0xfb42 -- */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e0, 0x5bc, 0},            /* 0xfb40\tnun+dagesh */", "  {0x5e1, 0x5bc, 0},            /* 0xfb41\tsamech+dagesh */", "  {0xfb42, 0, 0},               /* 0xfb42 -- */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e1, 0x5bc, 0},            /* 0xfb41\tsamech+dagesh */", "  {0xfb42, 0, 0},               /* 0xfb42 -- */", "  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e1, 0x5bc, 0},            /* 0xfb41\tsamech+dagesh */", "  {0xfb42, 0, 0},               /* 0xfb42 -- */", "  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e1, 0x5bc, 0},            /* 0xfb41\tsamech+dagesh */", "  {0xfb42, 0, 0},               /* 0xfb42 -- */", "  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0xfb42, 0, 0},               /* 0xfb42 -- */", "  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */", "  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0xfb42, 0, 0},               /* 0xfb42 -- */", "  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */", "  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0xfb42, 0, 0},               /* 0xfb42 -- */", "  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */", "  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0xfb42, 0, 0},               /* 0xfb42 -- */", "  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */", "  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */", "  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */", "  {0xfb45, 0, 0},               /* 0xfb45 -- */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */", "  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */", "  {0xfb45, 0, 0},               /* 0xfb45 -- */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */", "  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */", "  {0xfb45, 0, 0},               /* 0xfb45 -- */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */", "  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */", "  {0xfb45, 0, 0},               /* 0xfb45 -- */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */", "  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */", "  {0xfb45, 0, 0},               /* 0xfb45 -- */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */", "  {0xfb45, 0, 0},               /* 0xfb45 -- */", "  {0x5e6, 0x5bc, 0},            /* 0xfb46\ttsadi+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */", "  {0xfb45, 0, 0},               /* 0xfb45 -- */", "  {0x5e6, 0x5bc, 0},            /* 0xfb46\ttsadi+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */", "  {0xfb45, 0, 0},               /* 0xfb45 -- */", "  {0x5e6, 0x5bc, 0},            /* 0xfb46\ttsadi+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0xfb45, 0, 0},               /* 0xfb45 -- */", "  {0x5e6, 0x5bc, 0},            /* 0xfb46\ttsadi+dagesh */", "  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0xfb45, 0, 0},               /* 0xfb45 -- */", "  {0x5e6, 0x5bc, 0},            /* 0xfb46\ttsadi+dagesh */", "  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0xfb45, 0, 0},               /* 0xfb45 -- */", "  {0x5e6, 0x5bc, 0},            /* 0xfb46\ttsadi+dagesh */", "  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0xfb45, 0, 0},               /* 0xfb45 -- */", "  {0x5e6, 0x5bc, 0},            /* 0xfb46\ttsadi+dagesh */", "  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e6, 0x5bc, 0},            /* 0xfb46\ttsadi+dagesh */", "  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */", "  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e6, 0x5bc, 0},            /* 0xfb46\ttsadi+dagesh */", "  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */", "  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e6, 0x5bc, 0},            /* 0xfb46\ttsadi+dagesh */", "  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */", "  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e6, 0x5bc, 0},            /* 0xfb46\ttsadi+dagesh */", "  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */", "  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */", "  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */", "  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */", "  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */", "  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */", "  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */", "  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */", "  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */", "  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */", "  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */", "  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */", "  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */", "  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */", "  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */", "  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */", "  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */", "  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */", "  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */", "  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */", "  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */", "  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */", "  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */", "  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */", "  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */", "  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */", "  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */", "  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */", "  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */", "  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */", "  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */", "  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */", "  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */", "  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */", "  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */", "  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */", "  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */", "  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */", "  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */", "  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */", "  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */", "  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */", "  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */", "  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */", "  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */", "  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */", "  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */", "  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */", "  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */", "  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */", "  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */", "  {0x5d0, 0x5dc, 0}             /* 0xfb4f\talef-lamed */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */", "  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */", "  {0x5d0, 0x5dc, 0}             /* 0xfb4f\talef-lamed */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */", "  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */", "  {0x5d0, 0x5dc, 0}             /* 0xfb4f\talef-lamed */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */", "  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */", "  {0x5d0, 0x5dc, 0}             /* 0xfb4f\talef-lamed */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */", "  {0x5d0, 0x5dc, 0}             /* 0xfb4f\talef-lamed */", "};"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */", "  {0x5d0, 0x5dc, 0}             /* 0xfb4f\talef-lamed */", "};"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */", "  {0x5d0, 0x5dc, 0}             /* 0xfb4f\talef-lamed */", "};"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */", "  {0x5d0, 0x5dc, 0}             /* 0xfb4f\talef-lamed */", "};"], "whitespace/braces"]
["src/nvim/regexp.c", ["    assert(*n >= 0);", "    result = mb_strnicmp(s1, s2, (size_t)*n);", "  }"], "whitespace/operators"]
["src/nvim/regexp.c", ["", "    /* we have to handle the strcmp ourselves, since it is necessary to", "     * deal with the composing characters by ignoring them: */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "      /* decompose the character if necessary, into 'base' characters", "       * because I don't care about Arabic, I will hard-code the Hebrew"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    result = c2 - c1;", "    if (result == 0)", "      *n = (int)(str2 - s2);"], "readability/braces"]
["src/nvim/regexp.c", ["", "/***************************************************************", "*\t\t      regsub stuff\t\t\t       *"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/* This stuff below really confuses cc on an SGI -- webb */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * regtilde(): Replace tildes in the pattern by the old pattern."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  for (p = newsub; *p; ++p) {", "    if ((*p == '~' && magic) || (*p == '\\\\' && *(p + 1) == '~' && !magic)) {"], "readability/increment"]
["src/nvim/regexp.c", ["      if (reg_prev_sub != NULL) {", "        /* length = len(newsub) - 1 + len(prev_sub) + 1 */", "        prevlen = (int)STRLEN(reg_prev_sub);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        tmpsub = xmalloc(STRLEN(newsub) + prevlen);", "        /* copy prefix */", "        len = (int)(p - newsub);              /* not including ~ */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        /* copy prefix */", "        len = (int)(p - newsub);              /* not including ~ */", "        memmove(tmpsub, newsub, (size_t)len);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        memmove(tmpsub, newsub, (size_t)len);", "        /* interpret tilde */", "        memmove(tmpsub + len, reg_prev_sub, (size_t)prevlen);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        memmove(tmpsub + len, reg_prev_sub, (size_t)prevlen);", "        /* copy postfix */", "        if (!magic)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        /* copy postfix */", "        if (!magic)", "          ++p;                                /* back off \\ */"], "readability/braces"]
["src/nvim/regexp.c", ["        if (!magic)", "          ++p;                                /* back off \\ */", "        STRCPY(tmpsub + len + prevlen, p + 1);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        if (!magic)", "          ++p;                                /* back off \\ */", "        STRCPY(tmpsub + len + prevlen, p + 1);"], "readability/increment"]
["src/nvim/regexp.c", ["", "        if (newsub != source)                 /* already allocated newsub */", "          xfree(newsub);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "        if (newsub != source)                 /* already allocated newsub */", "          xfree(newsub);"], "readability/braces"]
["src/nvim/regexp.c", ["        p = newsub + len + prevlen;", "      } else if (magic)", "        STRMOVE(p, p + 1);              /* remove '~' */"], "readability/braces"]
["src/nvim/regexp.c", ["      } else if (magic)", "        STRMOVE(p, p + 1);              /* remove '~' */", "      else"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        STRMOVE(p, p + 1);              /* remove '~' */", "      else", "        STRMOVE(p, p + 2);              /* remove '\\~' */"], "readability/braces"]
["src/nvim/regexp.c", ["      else", "        STRMOVE(p, p + 2);              /* remove '\\~' */", "      --p;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        STRMOVE(p, p + 2);              /* remove '\\~' */", "      --p;", "    } else {"], "readability/increment"]
["src/nvim/regexp.c", ["  xfree(reg_prev_sub);", "  if (newsub != source)         /* newsub was allocated, just keep it */", "    reg_prev_sub = newsub;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  xfree(reg_prev_sub);", "  if (newsub != source)         /* newsub was allocated, just keep it */", "    reg_prev_sub = newsub;"], "readability/braces"]
["src/nvim/regexp.c", ["    reg_prev_sub = newsub;", "  else                          /* no ~ found, need to save newsub  */", "    reg_prev_sub = vim_strsave(newsub);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    reg_prev_sub = newsub;", "  else                          /* no ~ found, need to save newsub  */", "    reg_prev_sub = vim_strsave(newsub);"], "readability/braces"]
["src/nvim/regexp.c", ["", "int vim_regsub_multi(regmmatch_T *rmp, linenr_T lnum, char_u *source, char_u *dest, int copy, int magic, int backslash)", "{"], "whitespace/line_length"]
["src/nvim/regexp.c", ["  fptr_T func_one = (fptr_T)NULL;", "  linenr_T clnum = 0;           /* init for GCC */", "  int len = 0;                  /* init for GCC */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  linenr_T clnum = 0;           /* init for GCC */", "  int len = 0;                  /* init for GCC */", "  static char_u *eval_result = NULL;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  }", "  if (prog_magic_wrong())", "    return 0;"], "readability/braces"]
["src/nvim/regexp.c", ["            s++;", "            /* Change NL to CR here too, so that this works:", "             * :s/abc\\\\\\ndef/\\=\"aaa\\\\\\nbbb\"/  on text:"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        if (had_backslash && backslash) {", "          /* Backslashes will be consumed, need to double them. */", "          s = vim_strsave_escaped(eval_result, (char_u *)\"\\\\\");"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    }", "  } else", "    while ((c = *src++) != NUL) {"], "readability/braces"]
["src/nvim/regexp.c", ["    while ((c = *src++) != NUL) {", "      if (c == '&' && magic)", "        no = 0;"], "readability/braces"]
["src/nvim/regexp.c", ["        no = 0;", "      else if (c == '\\\\' && *src != NUL) {", "        if (*src == '&' && !magic) {"], "readability/braces"]
["src/nvim/regexp.c", ["        if (*src == '&' && !magic) {", "          ++src;", "          no = 0;"], "readability/increment"]
["src/nvim/regexp.c", ["      }", "      if (no < 0) {           /* Ordinary character. */", "        if (c == K_SPECIAL && src[0] != NUL && src[1] != NUL) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        if (c == K_SPECIAL && src[0] != NUL && src[1] != NUL) {", "          /* Copy a special key as-is. */", "          if (copy) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              if (backslash && (*s == CAR || *s == '\\\\')) {", "                /*", "                 * Insert a backslash in front of a CR, otherwise"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "                if (func_one != (fptr_T)NULL)", "                  /* Turbo C complains without the typecast */"], "readability/braces"]
["src/nvim/regexp.c", ["                if (func_one != (fptr_T)NULL)", "                  /* Turbo C complains without the typecast */", "                  func_one = (fptr_T)(func_one(&cc, c));"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["                  func_one = (fptr_T)(func_one(&cc, c));", "                else if (func_all != (fptr_T)NULL)", "                  /* Turbo C complains without the typecast */"], "readability/braces"]
["src/nvim/regexp.c", ["                else if (func_all != (fptr_T)NULL)", "                  /* Turbo C complains without the typecast */", "                  func_all = (fptr_T)(func_all(&cc, c));"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["                  func_all = (fptr_T)(func_all(&cc, c));", "                else             /* just copy */", "                  cc = c;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["                  func_all = (fptr_T)(func_all(&cc, c));", "                else             /* just copy */", "                  cc = c;"], "readability/braces"]
["src/nvim/regexp.c", ["", "              ++s;", "              --len;"], "readability/increment"]
["src/nvim/regexp.c", ["              ++s;", "              --len;", "            }"], "readability/increment"]
["src/nvim/regexp.c", ["    }", "  if (copy)", "    *dst = NUL;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Call reg_getline() with the line numbers from the submatch.  If a"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Used for the submatch() function: get the string from the n'th submatch in"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  if (!can_f_submatch || no < 0)", "    return NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["", "    /*", "     * First round: compute the length and allocate memory."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          s = reg_getline_submatch(lnum++);", "          if (round == 2)", "            STRCPY(retval + len, s);"], "readability/braces"]
["src/nvim/regexp.c", ["          len += STRLEN(s);", "          if (round == 2)", "            retval[len] = '\\n';"], "readability/braces"]
["src/nvim/regexp.c", ["            retval[len] = '\\n';", "          ++len;", "        }"], "readability/increment"]
["src/nvim/regexp.c", ["        if (round == 2) {", "          STRNCPY(retval + len, reg_getline_submatch(lnum),", "                  rsm.sm_mmatch->endpos[no].col);"], "runtime/printf"]
["src/nvim/regexp.c", ["", "/* Which regexp engine to use? Needed for vim_regcomp().", " * Must match with 'regexpengine'. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Compile a regular expression into internal code."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  /* Check for prefix \"\\%#=\", that sets the regexp engine */", "  if (STRNCMP(expr, \"\\\\%#=\", 4) == 0) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      EMSG(_(", "              \"E864: \\\\%#= can only be followed by 0, 1, or 2. The automatic engine will be used \"));", "      regexp_engine = AUTOMATIC_ENGINE;"], "whitespace/indent"]
["src/nvim/regexp.c", ["      EMSG(_(", "              \"E864: \\\\%#= can only be followed by 0, 1, or 2. The automatic engine will be used \"));", "      regexp_engine = AUTOMATIC_ENGINE;"], "whitespace/line_length"]
["src/nvim/regexp.c", ["    prog = nfa_regengine.regcomp(expr,", "        re_flags + (regexp_engine == AUTOMATIC_ENGINE ? RE_AUTO : 0));", "  } else {"], "whitespace/alignment"]
["src/nvim/regexp.c", ["        fclose(f);", "      } else", "        EMSG2(\"(NFA) Could not open \\\"%s\\\" to write !!!\","], "readability/braces"]
["src/nvim/regexp.c", ["        EMSG2(\"(NFA) Could not open \\\"%s\\\" to write !!!\",", "            BT_REGEXP_DEBUG_LOG_NAME);", "    }"], "whitespace/alignment"]
["src/nvim/regexp.c", ["", "/*", " * Free a compiled regexp program, returned by vim_regcomp()."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["{", "  if (prog != NULL)", "    prog->engine->regfree(prog);"], "readability/braces"]
["src/nvim/regexp_defs.h", ["// marker so line numbers and indices both start at 1", "/*", " * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE"], "readability/old_style_comment"]
["src/nvim/regexp_defs.h", ["", "/*", " * The number of sub-matches is limited to 10."], "readability/old_style_comment"]
["src/nvim/regexp_defs.h", ["", "/*", " * In the NFA engine: how many braces are allowed."], "readability/old_style_comment"]
["src/nvim/regexp_defs.h", ["", "/*", " * Structure returned by vim_regcomp() to pass on to vim_regexec()."], "readability/old_style_comment"]
["src/nvim/regexp_defs.h", ["", "/*", " * Structure used by the back track matcher."], "readability/old_style_comment"]
["src/nvim/regexp_defs.h", ["", "/*", " * Structure used by the NFA matcher."], "readability/old_style_comment"]
["src/nvim/regexp_defs.h", ["", "/*", " * Structure to be used for single-line matching."], "readability/old_style_comment"]
["src/nvim/regexp_defs.h", ["", "/*", " * Structure used to store external references: \"\\z\\(\\)\" to \"\\z\\1\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * NFA regular expression implementation."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Logging of NFA engine."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/* Added to NFA_ANY - NFA_NUPPER_IC to include a NL. */", "#define NFA_ADD_NL              31"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_MATCH,", "  NFA_EMPTY,                        /* matches 0-length */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  NFA_START_COLL,                   /* [abc] start */", "  NFA_END_COLL,                     /* [abc] end */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_START_COLL,                   /* [abc] start */", "  NFA_END_COLL,                     /* [abc] end */", "  NFA_START_NEG_COLL,               /* [^abc] start */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_END_COLL,                     /* [abc] end */", "  NFA_START_NEG_COLL,               /* [^abc] start */", "  NFA_END_NEG_COLL,                 /* [^abc] end (postfix only) */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_START_NEG_COLL,               /* [^abc] start */", "  NFA_END_NEG_COLL,                 /* [^abc] end (postfix only) */", "  NFA_RANGE,                        /* range of the two previous items"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_END_NEG_COLL,                 /* [^abc] end (postfix only) */", "  NFA_RANGE,                        /* range of the two previous items", "                                     * (postfix only) */"], "readability/multiline_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_END_NEG_COLL,                 /* [^abc] end (postfix only) */", "  NFA_RANGE,                        /* range of the two previous items", "                                     * (postfix only) */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["                                     * (postfix only) */", "  NFA_RANGE_MIN,                    /* low end of a range  */", "  NFA_RANGE_MAX,                    /* high end of a range  */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_RANGE_MIN,                    /* low end of a range  */", "  NFA_RANGE_MAX,                    /* high end of a range  */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  NFA_BOL,                          /* ^    Begin line */", "  NFA_EOL,                          /* $    End line */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_BOL,                          /* ^    Begin line */", "  NFA_EOL,                          /* $    End line */", "  NFA_BOW,                          /* \\<   Begin word */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_EOL,                          /* $    End line */", "  NFA_BOW,                          /* \\<   Begin word */", "  NFA_EOW,                          /* \\>   End word */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_BOW,                          /* \\<   Begin word */", "  NFA_EOW,                          /* \\>   End word */", "  NFA_BOF,                          /* \\%^  Begin file */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_EOW,                          /* \\>   End word */", "  NFA_BOF,                          /* \\%^  Begin file */", "  NFA_EOF,                          /* \\%$  End file */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_BOF,                          /* \\%^  Begin file */", "  NFA_EOF,                          /* \\%$  End file */", "  NFA_NEWL,"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_NEWL,", "  NFA_ZSTART,                       /* Used for \\zs */", "  NFA_ZEND,                         /* Used for \\ze */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ZSTART,                       /* Used for \\zs */", "  NFA_ZEND,                         /* Used for \\ze */", "  NFA_NOPEN,                        /* Start of subexpression marked with \\%( */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ZEND,                         /* Used for \\ze */", "  NFA_NOPEN,                        /* Start of subexpression marked with \\%( */", "  NFA_NCLOSE,                       /* End of subexpr. marked with \\%( ... \\) */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_NOPEN,                        /* Start of subexpression marked with \\%( */", "  NFA_NCLOSE,                       /* End of subexpr. marked with \\%( ... \\) */", "  NFA_START_INVISIBLE,"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_END_PATTERN,", "  NFA_COMPOSING,                    /* Next nodes in NFA are part of the", "                                       composing multibyte char */"], "readability/multiline_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_END_PATTERN,", "  NFA_COMPOSING,                    /* Next nodes in NFA are part of the", "                                       composing multibyte char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["                                       composing multibyte char */", "  NFA_END_COMPOSING,                /* End of a composing char in the NFA */", "  NFA_ANY_COMPOSING,                // \\%C: Any composing characters."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ANY_COMPOSING,                // \\%C: Any composing characters.", "  NFA_OPT_CHARS,                    /* \\%[abc] */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* The following are used only in the postfix form, not in the NFA */", "  NFA_PREV_ATOM_NO_WIDTH,           /* Used for \\@= */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  /* The following are used only in the postfix form, not in the NFA */", "  NFA_PREV_ATOM_NO_WIDTH,           /* Used for \\@= */", "  NFA_PREV_ATOM_NO_WIDTH_NEG,       /* Used for \\@! */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_PREV_ATOM_NO_WIDTH,           /* Used for \\@= */", "  NFA_PREV_ATOM_NO_WIDTH_NEG,       /* Used for \\@! */", "  NFA_PREV_ATOM_JUST_BEFORE,        /* Used for \\@<= */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_PREV_ATOM_NO_WIDTH_NEG,       /* Used for \\@! */", "  NFA_PREV_ATOM_JUST_BEFORE,        /* Used for \\@<= */", "  NFA_PREV_ATOM_JUST_BEFORE_NEG,    /* Used for \\@<! */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_PREV_ATOM_JUST_BEFORE,        /* Used for \\@<= */", "  NFA_PREV_ATOM_JUST_BEFORE_NEG,    /* Used for \\@<! */", "  NFA_PREV_ATOM_LIKE_PATTERN,       /* Used for \\@> */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_PREV_ATOM_JUST_BEFORE_NEG,    /* Used for \\@<! */", "  NFA_PREV_ATOM_LIKE_PATTERN,       /* Used for \\@> */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  NFA_BACKREF1,                     /* \\1 */", "  NFA_BACKREF2,                     /* \\2 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_BACKREF1,                     /* \\1 */", "  NFA_BACKREF2,                     /* \\2 */", "  NFA_BACKREF3,                     /* \\3 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_BACKREF2,                     /* \\2 */", "  NFA_BACKREF3,                     /* \\3 */", "  NFA_BACKREF4,                     /* \\4 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_BACKREF3,                     /* \\3 */", "  NFA_BACKREF4,                     /* \\4 */", "  NFA_BACKREF5,                     /* \\5 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_BACKREF4,                     /* \\4 */", "  NFA_BACKREF5,                     /* \\5 */", "  NFA_BACKREF6,                     /* \\6 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_BACKREF5,                     /* \\5 */", "  NFA_BACKREF6,                     /* \\6 */", "  NFA_BACKREF7,                     /* \\7 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_BACKREF6,                     /* \\6 */", "  NFA_BACKREF7,                     /* \\7 */", "  NFA_BACKREF8,                     /* \\8 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_BACKREF7,                     /* \\7 */", "  NFA_BACKREF8,                     /* \\8 */", "  NFA_BACKREF9,                     /* \\9 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_BACKREF8,                     /* \\8 */", "  NFA_BACKREF9,                     /* \\9 */", "  NFA_ZREF1,                        /* \\z1 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_BACKREF9,                     /* \\9 */", "  NFA_ZREF1,                        /* \\z1 */", "  NFA_ZREF2,                        /* \\z2 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ZREF1,                        /* \\z1 */", "  NFA_ZREF2,                        /* \\z2 */", "  NFA_ZREF3,                        /* \\z3 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ZREF2,                        /* \\z2 */", "  NFA_ZREF3,                        /* \\z3 */", "  NFA_ZREF4,                        /* \\z4 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ZREF3,                        /* \\z3 */", "  NFA_ZREF4,                        /* \\z4 */", "  NFA_ZREF5,                        /* \\z5 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ZREF4,                        /* \\z4 */", "  NFA_ZREF5,                        /* \\z5 */", "  NFA_ZREF6,                        /* \\z6 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ZREF5,                        /* \\z5 */", "  NFA_ZREF6,                        /* \\z6 */", "  NFA_ZREF7,                        /* \\z7 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ZREF6,                        /* \\z6 */", "  NFA_ZREF7,                        /* \\z7 */", "  NFA_ZREF8,                        /* \\z8 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ZREF7,                        /* \\z7 */", "  NFA_ZREF8,                        /* \\z8 */", "  NFA_ZREF9,                        /* \\z9 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ZREF8,                        /* \\z8 */", "  NFA_ZREF9,                        /* \\z9 */", "  NFA_SKIP,                         /* Skip characters */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ZREF9,                        /* \\z9 */", "  NFA_SKIP,                         /* Skip characters */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* NFA_FIRST_NL */", "  NFA_ANY,              /*\tMatch any one character. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  /* NFA_FIRST_NL */", "  NFA_ANY,              /*\tMatch any one character. */", "  NFA_IDENT,            /*\tMatch identifier char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  /* NFA_FIRST_NL */", "  NFA_ANY,              /*\tMatch any one character. */", "  NFA_IDENT,            /*\tMatch identifier char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_ANY,              /*\tMatch any one character. */", "  NFA_IDENT,            /*\tMatch identifier char */", "  NFA_SIDENT,           /*\tMatch identifier char but no digit */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ANY,              /*\tMatch any one character. */", "  NFA_IDENT,            /*\tMatch identifier char */", "  NFA_SIDENT,           /*\tMatch identifier char but no digit */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_IDENT,            /*\tMatch identifier char */", "  NFA_SIDENT,           /*\tMatch identifier char but no digit */", "  NFA_KWORD,            /*\tMatch keyword char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_IDENT,            /*\tMatch identifier char */", "  NFA_SIDENT,           /*\tMatch identifier char but no digit */", "  NFA_KWORD,            /*\tMatch keyword char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_SIDENT,           /*\tMatch identifier char but no digit */", "  NFA_KWORD,            /*\tMatch keyword char */", "  NFA_SKWORD,           /*\tMatch word char but no digit */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_SIDENT,           /*\tMatch identifier char but no digit */", "  NFA_KWORD,            /*\tMatch keyword char */", "  NFA_SKWORD,           /*\tMatch word char but no digit */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_KWORD,            /*\tMatch keyword char */", "  NFA_SKWORD,           /*\tMatch word char but no digit */", "  NFA_FNAME,            /*\tMatch file name char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_KWORD,            /*\tMatch keyword char */", "  NFA_SKWORD,           /*\tMatch word char but no digit */", "  NFA_FNAME,            /*\tMatch file name char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_SKWORD,           /*\tMatch word char but no digit */", "  NFA_FNAME,            /*\tMatch file name char */", "  NFA_SFNAME,           /*\tMatch file name char but no digit */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_SKWORD,           /*\tMatch word char but no digit */", "  NFA_FNAME,            /*\tMatch file name char */", "  NFA_SFNAME,           /*\tMatch file name char but no digit */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_FNAME,            /*\tMatch file name char */", "  NFA_SFNAME,           /*\tMatch file name char but no digit */", "  NFA_PRINT,            /*\tMatch printable char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_FNAME,            /*\tMatch file name char */", "  NFA_SFNAME,           /*\tMatch file name char but no digit */", "  NFA_PRINT,            /*\tMatch printable char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_SFNAME,           /*\tMatch file name char but no digit */", "  NFA_PRINT,            /*\tMatch printable char */", "  NFA_SPRINT,           /*\tMatch printable char but no digit */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_SFNAME,           /*\tMatch file name char but no digit */", "  NFA_PRINT,            /*\tMatch printable char */", "  NFA_SPRINT,           /*\tMatch printable char but no digit */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_PRINT,            /*\tMatch printable char */", "  NFA_SPRINT,           /*\tMatch printable char but no digit */", "  NFA_WHITE,            /*\tMatch whitespace char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_PRINT,            /*\tMatch printable char */", "  NFA_SPRINT,           /*\tMatch printable char but no digit */", "  NFA_WHITE,            /*\tMatch whitespace char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_SPRINT,           /*\tMatch printable char but no digit */", "  NFA_WHITE,            /*\tMatch whitespace char */", "  NFA_NWHITE,           /*\tMatch non-whitespace char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_SPRINT,           /*\tMatch printable char but no digit */", "  NFA_WHITE,            /*\tMatch whitespace char */", "  NFA_NWHITE,           /*\tMatch non-whitespace char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_WHITE,            /*\tMatch whitespace char */", "  NFA_NWHITE,           /*\tMatch non-whitespace char */", "  NFA_DIGIT,            /*\tMatch digit char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_WHITE,            /*\tMatch whitespace char */", "  NFA_NWHITE,           /*\tMatch non-whitespace char */", "  NFA_DIGIT,            /*\tMatch digit char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NWHITE,           /*\tMatch non-whitespace char */", "  NFA_DIGIT,            /*\tMatch digit char */", "  NFA_NDIGIT,           /*\tMatch non-digit char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_NWHITE,           /*\tMatch non-whitespace char */", "  NFA_DIGIT,            /*\tMatch digit char */", "  NFA_NDIGIT,           /*\tMatch non-digit char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_DIGIT,            /*\tMatch digit char */", "  NFA_NDIGIT,           /*\tMatch non-digit char */", "  NFA_HEX,              /*\tMatch hex char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_DIGIT,            /*\tMatch digit char */", "  NFA_NDIGIT,           /*\tMatch non-digit char */", "  NFA_HEX,              /*\tMatch hex char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NDIGIT,           /*\tMatch non-digit char */", "  NFA_HEX,              /*\tMatch hex char */", "  NFA_NHEX,             /*\tMatch non-hex char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_NDIGIT,           /*\tMatch non-digit char */", "  NFA_HEX,              /*\tMatch hex char */", "  NFA_NHEX,             /*\tMatch non-hex char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_HEX,              /*\tMatch hex char */", "  NFA_NHEX,             /*\tMatch non-hex char */", "  NFA_OCTAL,            /*\tMatch octal char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_HEX,              /*\tMatch hex char */", "  NFA_NHEX,             /*\tMatch non-hex char */", "  NFA_OCTAL,            /*\tMatch octal char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NHEX,             /*\tMatch non-hex char */", "  NFA_OCTAL,            /*\tMatch octal char */", "  NFA_NOCTAL,           /*\tMatch non-octal char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_NHEX,             /*\tMatch non-hex char */", "  NFA_OCTAL,            /*\tMatch octal char */", "  NFA_NOCTAL,           /*\tMatch non-octal char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_OCTAL,            /*\tMatch octal char */", "  NFA_NOCTAL,           /*\tMatch non-octal char */", "  NFA_WORD,             /*\tMatch word char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_OCTAL,            /*\tMatch octal char */", "  NFA_NOCTAL,           /*\tMatch non-octal char */", "  NFA_WORD,             /*\tMatch word char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NOCTAL,           /*\tMatch non-octal char */", "  NFA_WORD,             /*\tMatch word char */", "  NFA_NWORD,            /*\tMatch non-word char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_NOCTAL,           /*\tMatch non-octal char */", "  NFA_WORD,             /*\tMatch word char */", "  NFA_NWORD,            /*\tMatch non-word char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_WORD,             /*\tMatch word char */", "  NFA_NWORD,            /*\tMatch non-word char */", "  NFA_HEAD,             /*\tMatch head char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_WORD,             /*\tMatch word char */", "  NFA_NWORD,            /*\tMatch non-word char */", "  NFA_HEAD,             /*\tMatch head char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NWORD,            /*\tMatch non-word char */", "  NFA_HEAD,             /*\tMatch head char */", "  NFA_NHEAD,            /*\tMatch non-head char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_NWORD,            /*\tMatch non-word char */", "  NFA_HEAD,             /*\tMatch head char */", "  NFA_NHEAD,            /*\tMatch non-head char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_HEAD,             /*\tMatch head char */", "  NFA_NHEAD,            /*\tMatch non-head char */", "  NFA_ALPHA,            /*\tMatch alpha char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_HEAD,             /*\tMatch head char */", "  NFA_NHEAD,            /*\tMatch non-head char */", "  NFA_ALPHA,            /*\tMatch alpha char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NHEAD,            /*\tMatch non-head char */", "  NFA_ALPHA,            /*\tMatch alpha char */", "  NFA_NALPHA,           /*\tMatch non-alpha char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_NHEAD,            /*\tMatch non-head char */", "  NFA_ALPHA,            /*\tMatch alpha char */", "  NFA_NALPHA,           /*\tMatch non-alpha char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_ALPHA,            /*\tMatch alpha char */", "  NFA_NALPHA,           /*\tMatch non-alpha char */", "  NFA_LOWER,            /*\tMatch lowercase char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ALPHA,            /*\tMatch alpha char */", "  NFA_NALPHA,           /*\tMatch non-alpha char */", "  NFA_LOWER,            /*\tMatch lowercase char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NALPHA,           /*\tMatch non-alpha char */", "  NFA_LOWER,            /*\tMatch lowercase char */", "  NFA_NLOWER,           /*\tMatch non-lowercase char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_NALPHA,           /*\tMatch non-alpha char */", "  NFA_LOWER,            /*\tMatch lowercase char */", "  NFA_NLOWER,           /*\tMatch non-lowercase char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_LOWER,            /*\tMatch lowercase char */", "  NFA_NLOWER,           /*\tMatch non-lowercase char */", "  NFA_UPPER,            /*\tMatch uppercase char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_LOWER,            /*\tMatch lowercase char */", "  NFA_NLOWER,           /*\tMatch non-lowercase char */", "  NFA_UPPER,            /*\tMatch uppercase char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NLOWER,           /*\tMatch non-lowercase char */", "  NFA_UPPER,            /*\tMatch uppercase char */", "  NFA_NUPPER,           /*\tMatch non-uppercase char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_NLOWER,           /*\tMatch non-lowercase char */", "  NFA_UPPER,            /*\tMatch uppercase char */", "  NFA_NUPPER,           /*\tMatch non-uppercase char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_UPPER,            /*\tMatch uppercase char */", "  NFA_NUPPER,           /*\tMatch non-uppercase char */", "  NFA_LOWER_IC,         /*\tMatch [a-z] */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_UPPER,            /*\tMatch uppercase char */", "  NFA_NUPPER,           /*\tMatch non-uppercase char */", "  NFA_LOWER_IC,         /*\tMatch [a-z] */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NUPPER,           /*\tMatch non-uppercase char */", "  NFA_LOWER_IC,         /*\tMatch [a-z] */", "  NFA_NLOWER_IC,        /*\tMatch [^a-z] */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_NUPPER,           /*\tMatch non-uppercase char */", "  NFA_LOWER_IC,         /*\tMatch [a-z] */", "  NFA_NLOWER_IC,        /*\tMatch [^a-z] */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_LOWER_IC,         /*\tMatch [a-z] */", "  NFA_NLOWER_IC,        /*\tMatch [^a-z] */", "  NFA_UPPER_IC,         /*\tMatch [A-Z] */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_LOWER_IC,         /*\tMatch [a-z] */", "  NFA_NLOWER_IC,        /*\tMatch [^a-z] */", "  NFA_UPPER_IC,         /*\tMatch [A-Z] */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NLOWER_IC,        /*\tMatch [^a-z] */", "  NFA_UPPER_IC,         /*\tMatch [A-Z] */", "  NFA_NUPPER_IC,        /*\tMatch [^A-Z] */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_NLOWER_IC,        /*\tMatch [^a-z] */", "  NFA_UPPER_IC,         /*\tMatch [A-Z] */", "  NFA_NUPPER_IC,        /*\tMatch [^A-Z] */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_UPPER_IC,         /*\tMatch [A-Z] */", "  NFA_NUPPER_IC,        /*\tMatch [^A-Z] */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_UPPER_IC,         /*\tMatch [A-Z] */", "  NFA_NUPPER_IC,        /*\tMatch [^A-Z] */", ""], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "  NFA_CURSOR,           /*\tMatch cursor pos */", "  NFA_LNUM,             /*\tMatch line number */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  NFA_CURSOR,           /*\tMatch cursor pos */", "  NFA_LNUM,             /*\tMatch line number */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_CURSOR,           /*\tMatch cursor pos */", "  NFA_LNUM,             /*\tMatch line number */", "  NFA_LNUM_GT,          /*\tMatch > line number */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_CURSOR,           /*\tMatch cursor pos */", "  NFA_LNUM,             /*\tMatch line number */", "  NFA_LNUM_GT,          /*\tMatch > line number */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_LNUM,             /*\tMatch line number */", "  NFA_LNUM_GT,          /*\tMatch > line number */", "  NFA_LNUM_LT,          /*\tMatch < line number */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_LNUM,             /*\tMatch line number */", "  NFA_LNUM_GT,          /*\tMatch > line number */", "  NFA_LNUM_LT,          /*\tMatch < line number */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_LNUM_GT,          /*\tMatch > line number */", "  NFA_LNUM_LT,          /*\tMatch < line number */", "  NFA_COL,              /*\tMatch cursor column */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_LNUM_GT,          /*\tMatch > line number */", "  NFA_LNUM_LT,          /*\tMatch < line number */", "  NFA_COL,              /*\tMatch cursor column */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_LNUM_LT,          /*\tMatch < line number */", "  NFA_COL,              /*\tMatch cursor column */", "  NFA_COL_GT,           /*\tMatch > cursor column */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_LNUM_LT,          /*\tMatch < line number */", "  NFA_COL,              /*\tMatch cursor column */", "  NFA_COL_GT,           /*\tMatch > cursor column */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_COL,              /*\tMatch cursor column */", "  NFA_COL_GT,           /*\tMatch > cursor column */", "  NFA_COL_LT,           /*\tMatch < cursor column */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_COL,              /*\tMatch cursor column */", "  NFA_COL_GT,           /*\tMatch > cursor column */", "  NFA_COL_LT,           /*\tMatch < cursor column */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_COL_GT,           /*\tMatch > cursor column */", "  NFA_COL_LT,           /*\tMatch < cursor column */", "  NFA_VCOL,             /*\tMatch cursor virtual column */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_COL_GT,           /*\tMatch > cursor column */", "  NFA_COL_LT,           /*\tMatch < cursor column */", "  NFA_VCOL,             /*\tMatch cursor virtual column */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_COL_LT,           /*\tMatch < cursor column */", "  NFA_VCOL,             /*\tMatch cursor virtual column */", "  NFA_VCOL_GT,          /*\tMatch > cursor virtual column */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_COL_LT,           /*\tMatch < cursor column */", "  NFA_VCOL,             /*\tMatch cursor virtual column */", "  NFA_VCOL_GT,          /*\tMatch > cursor virtual column */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_VCOL,             /*\tMatch cursor virtual column */", "  NFA_VCOL_GT,          /*\tMatch > cursor virtual column */", "  NFA_VCOL_LT,          /*\tMatch < cursor virtual column */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_VCOL,             /*\tMatch cursor virtual column */", "  NFA_VCOL_GT,          /*\tMatch > cursor virtual column */", "  NFA_VCOL_LT,          /*\tMatch < cursor virtual column */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_VCOL_GT,          /*\tMatch > cursor virtual column */", "  NFA_VCOL_LT,          /*\tMatch < cursor virtual column */", "  NFA_MARK,             /*\tMatch mark */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_VCOL_GT,          /*\tMatch > cursor virtual column */", "  NFA_VCOL_LT,          /*\tMatch < cursor virtual column */", "  NFA_MARK,             /*\tMatch mark */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_VCOL_LT,          /*\tMatch < cursor virtual column */", "  NFA_MARK,             /*\tMatch mark */", "  NFA_MARK_GT,          /*\tMatch > mark */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_VCOL_LT,          /*\tMatch < cursor virtual column */", "  NFA_MARK,             /*\tMatch mark */", "  NFA_MARK_GT,          /*\tMatch > mark */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_MARK,             /*\tMatch mark */", "  NFA_MARK_GT,          /*\tMatch > mark */", "  NFA_MARK_LT,          /*\tMatch < mark */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_MARK,             /*\tMatch mark */", "  NFA_MARK_GT,          /*\tMatch > mark */", "  NFA_MARK_LT,          /*\tMatch < mark */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_MARK_GT,          /*\tMatch > mark */", "  NFA_MARK_LT,          /*\tMatch < mark */", "  NFA_VISUAL,           /*\tMatch Visual area */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_MARK_GT,          /*\tMatch > mark */", "  NFA_MARK_LT,          /*\tMatch < mark */", "  NFA_VISUAL,           /*\tMatch Visual area */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_MARK_LT,          /*\tMatch < mark */", "  NFA_VISUAL,           /*\tMatch Visual area */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_MARK_LT,          /*\tMatch < mark */", "  NFA_VISUAL,           /*\tMatch Visual area */", ""], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "  /* Character classes [:alnum:] etc */", "  NFA_CLASS_ALNUM,"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/* Keep in sync with classchars. */", "static int nfa_classcodes[] = {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["static int nfa_classcodes[] = {", "  NFA_ANY, NFA_IDENT, NFA_SIDENT, NFA_KWORD,NFA_SKWORD,", "  NFA_FNAME, NFA_SFNAME, NFA_PRINT, NFA_SPRINT,"], "whitespace/comma"]
["src/nvim/regexp_nfa.c", ["", "/* Since the out pointers in the list are always", " * uninitialized, we use the pointers themselves"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["typedef struct {", "  regsub_T norm;      /* \\( .. \\) matches */", "  regsub_T synt;      /* \\z( .. \\) matches */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  regsub_T norm;      /* \\( .. \\) matches */", "  regsub_T synt;      /* \\z( .. \\) matches */", "} regsubs_T;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/* nfa_pim_T stores a Postponed Invisible Match. */", "typedef struct nfa_pim_S nfa_pim_T;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["struct nfa_pim_S {", "  int result;                   /* NFA_PIM_*, see below */", "  nfa_state_T *state;           /* the invisible match start state */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  int result;                   /* NFA_PIM_*, see below */", "  nfa_state_T *state;           /* the invisible match start state */", "  regsubs_T subs;               /* submatch info, only party used */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  nfa_state_T *state;           /* the invisible match start state */", "  regsubs_T subs;               /* submatch info, only party used */", "  union {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    char_u  *ptr;", "  } end;                        /* where the match must end */", "};"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/* nfa_thread_T contains execution information of a NFA state */", "typedef struct {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  int count;", "  nfa_pim_T pim;                /* if pim.result != NFA_PIM_UNUSED: postponed", "                                 * invisible match */"], "readability/multiline_comment"]
["src/nvim/regexp_nfa.c", ["  int count;", "  nfa_pim_T pim;                /* if pim.result != NFA_PIM_UNUSED: postponed", "                                 * invisible match */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["                                 * invisible match */", "  regsubs_T subs;               /* submatch info, only party used */", "} nfa_thread_T;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/* If not NULL match must end at this position */", "static save_se_T *nfa_endp = NULL;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/* 0 for first call to nfa_regmatch(), 1 for recursive call. */", "static int nfa_ll_index = 0;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Initialize internal variables before NFA compilation."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["static void", "nfa_regcomp_start (", "    char_u *expr,"], "whitespace/parens"]
["src/nvim/regexp_nfa.c", ["    char_u *expr,", "    int re_flags                       /* see vim_regcomp() */", ")"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  istate = 0;", "  /* A reasonable estimation for maximum size */", "  nstate_max = (STRLEN(expr) + 1) * 25;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* Some items blow up in size, such as [A-z].  Add more space for that.", "   * When it is still not enough realloc_post_list() will be used. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* Size for postfix representation of expr. */", "  postfix_size = sizeof(int) * nstate_max;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* shared with BT engine */", "  regcomp_start(expr, re_flags);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Figure out if the NFA state list starts with an anchor, must match at start"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  if (depth > 4)", "    return 0;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    case NFA_BOF:", "      return 1;           /* yes! */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    default:", "      return 0;           /* noooo */", "    }"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Figure out if the NFA state list starts with a character which must match"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  if (depth > 4)", "    return 0;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    switch (p->c) {", "    /* all kinds of zero-width matches */", "    case NFA_BOL:"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "      if (c1 == c2)", "        return c1;             /* yes! */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      if (c1 == c2)", "        return c1;             /* yes! */", "      return 0;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    default:", "      if (p->c > 0)", "        return p->c;             /* yes! */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      if (p->c > 0)", "        return p->c;             /* yes! */", "      return 0;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Figure out if the NFA state list contains just literal text and nothing"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  if (p->c != NFA_MOPEN)", "    return NULL;     /* just in case */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  if (p->c != NFA_MOPEN)", "    return NULL;     /* just in case */", "  p = p->out;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  }", "  if (p->c != NFA_MCLOSE || p->out->c != NFA_MATCH)", "    return NULL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  ret = xmalloc(len);", "  p = start->out->out;     /* skip first char, it goes into regstart */", "  s = ret;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Allocate more space for post_start.  Called when"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Search between \"start\" and \"end\" and try to recognize a"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  if (*end != ']')", "    return FAIL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      p++;", "    } else", "      return FAIL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      return FAIL;", "  }   /* while (p < end) */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  if (p != end)", "    return FAIL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Produce the bytes for equivalence class \"c\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["{", "#define EMIT2(c)   EMIT(c); EMIT(NFA_CONCAT);", "#define EMITMBC(c) EMIT(c); EMIT(NFA_CONCAT);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["#define EMIT2(c)   EMIT(c); EMIT(NFA_CONCAT);", "#define EMITMBC(c) EMIT(c); EMIT(NFA_CONCAT);", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x1ea2)", "      EMIT2('A'); EMIT2(A_grave); EMIT2(A_acute);", "      EMIT2(A_circumflex); EMIT2(A_virguilla);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2('A'); EMIT2(A_grave); EMIT2(A_acute);", "      EMIT2(A_circumflex); EMIT2(A_virguilla);", "      EMIT2(A_diaeresis); EMIT2(A_ring);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2(A_circumflex); EMIT2(A_virguilla);", "      EMIT2(A_diaeresis); EMIT2(A_ring);", "      EMITMBC(0x100) EMITMBC(0x102) EMITMBC(0x104)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x10c)", "      EMIT2('C'); EMIT2(C_cedilla); EMITMBC(0x106) EMITMBC(0x108)", "      EMITMBC(0x10a) EMITMBC(0x10c)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x1eba) CASEMBC(0x1ebc)", "      EMIT2('E'); EMIT2(E_grave); EMIT2(E_acute);", "      EMIT2(E_circumflex); EMIT2(E_diaeresis);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2('E'); EMIT2(E_grave); EMIT2(E_acute);", "      EMIT2(E_circumflex); EMIT2(E_diaeresis);", "      EMITMBC(0x112) EMITMBC(0x114) EMITMBC(0x116)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x1cf) CASEMBC(0x1ec8)", "      EMIT2('I'); EMIT2(I_grave); EMIT2(I_acute);", "      EMIT2(I_circumflex); EMIT2(I_diaeresis);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2('I'); EMIT2(I_grave); EMIT2(I_acute);", "      EMIT2(I_circumflex); EMIT2(I_diaeresis);", "      EMITMBC(0x128) EMITMBC(0x12a)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x147) CASEMBC(0x1e44) CASEMBC(0x1e48)", "      EMIT2('N'); EMIT2(N_virguilla);", "      EMITMBC(0x143) EMITMBC(0x145)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x1ec) CASEMBC(0x1ece)", "      EMIT2('O'); EMIT2(O_grave); EMIT2(O_acute);", "      EMIT2(O_circumflex); EMIT2(O_virguilla);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2('O'); EMIT2(O_grave); EMIT2(O_acute);", "      EMIT2(O_circumflex); EMIT2(O_virguilla);", "      EMIT2(O_diaeresis); EMIT2(O_slash);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2(O_circumflex); EMIT2(O_virguilla);", "      EMIT2(O_diaeresis); EMIT2(O_slash);", "      EMITMBC(0x14c) EMITMBC(0x14e) EMITMBC(0x150)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x1ee6)", "      EMIT2('U'); EMIT2(U_grave); EMIT2(U_acute);", "      EMIT2(U_diaeresis); EMIT2(U_circumflex);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2('U'); EMIT2(U_grave); EMIT2(U_acute);", "      EMIT2(U_diaeresis); EMIT2(U_circumflex);", "      EMITMBC(0x168) EMITMBC(0x16a)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x1ef8)", "      EMIT2('Y'); EMIT2(Y_acute);", "      EMITMBC(0x176) EMITMBC(0x178)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x1ea3)", "      EMIT2('a'); EMIT2(a_grave); EMIT2(a_acute);", "      EMIT2(a_circumflex); EMIT2(a_virguilla);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2('a'); EMIT2(a_grave); EMIT2(a_acute);", "      EMIT2(a_circumflex); EMIT2(a_virguilla);", "      EMIT2(a_diaeresis); EMIT2(a_ring);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2(a_circumflex); EMIT2(a_virguilla);", "      EMIT2(a_diaeresis); EMIT2(a_ring);", "      EMITMBC(0x101) EMITMBC(0x103) EMITMBC(0x105)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x10b) CASEMBC(0x10d)", "      EMIT2('c'); EMIT2(c_cedilla);", "      EMITMBC(0x107) EMITMBC(0x109)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x1ebb) CASEMBC(0x1ebd)", "      EMIT2('e'); EMIT2(e_grave); EMIT2(e_acute);", "      EMIT2(e_circumflex); EMIT2(e_diaeresis);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2('e'); EMIT2(e_grave); EMIT2(e_acute);", "      EMIT2(e_circumflex); EMIT2(e_diaeresis);", "      EMITMBC(0x113) EMITMBC(0x115)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x1ec9)", "      EMIT2('i'); EMIT2(i_grave); EMIT2(i_acute);", "      EMIT2(i_circumflex); EMIT2(i_diaeresis);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2('i'); EMIT2(i_grave); EMIT2(i_acute);", "      EMIT2(i_circumflex); EMIT2(i_diaeresis);", "      EMITMBC(0x129) EMITMBC(0x12b)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x1e49)", "      EMIT2('n'); EMIT2(n_virguilla);", "      EMITMBC(0x144) EMITMBC(0x146)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x1ed) CASEMBC(0x1ecf)", "      EMIT2('o'); EMIT2(o_grave); EMIT2(o_acute);", "      EMIT2(o_circumflex); EMIT2(o_virguilla);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2('o'); EMIT2(o_grave); EMIT2(o_acute);", "      EMIT2(o_circumflex); EMIT2(o_virguilla);", "      EMIT2(o_diaeresis); EMIT2(o_slash);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2(o_circumflex); EMIT2(o_virguilla);", "      EMIT2(o_diaeresis); EMIT2(o_slash);", "      EMITMBC(0x14d) EMITMBC(0x14f) EMITMBC(0x151)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x1ee7)", "      EMIT2('u'); EMIT2(u_grave); EMIT2(u_acute);", "      EMIT2(u_circumflex); EMIT2(u_diaeresis);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2('u'); EMIT2(u_grave); EMIT2(u_acute);", "      EMIT2(u_circumflex); EMIT2(u_diaeresis);", "      EMITMBC(0x169) EMITMBC(0x16b)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x1ef7) CASEMBC(0x1ef9)", "      EMIT2('y'); EMIT2(y_acute); EMIT2(y_diaeresis);", "      EMITMBC(0x177)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["", "      /* default: character itself */", "    }"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Code to parse regular expression."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Parse the lowest level."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    c = no_Magic(getchr());", "    if (c == NUL)", "      EMSG_RET_FAIL(_(e_nul_found));"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "    if (c == '^') {             /* \"\\_^\" is start-of-line */", "      EMIT(NFA_BOL);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    }", "    if (c == '$') {             /* \"\\_$\" is end-of-line */", "      EMIT(NFA_EOL);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "    /* \"\\_[\" is collection plus newline */", "    if (c == '[')"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    /* \"\\_[\" is collection plus newline */", "    if (c == '[')", "      goto collection;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "  /*", "   * Character classes."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      EMIT(PTR2CHAR(lp));", "      if (lp != reg_prev_sub)", "        EMIT(NFA_CONCAT);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    switch (c) {", "    /* () without a back reference */", "    case '(':"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    case '(':", "      if (nfa_reg(REG_NPAREN) == FAIL)", "        return FAIL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "    case 'd':               /* %d123 decimal */", "    case 'o':               /* %o123 octal */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    case 'd':               /* %d123 decimal */", "    case 'o':               /* %o123 octal */", "    case 'x':               /* %xab hex 2 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    case 'o':               /* %o123 octal */", "    case 'x':               /* %xab hex 2 */", "    case 'u':               /* %uabcd hex 4 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    case 'x':               /* %xab hex 2 */", "    case 'u':               /* %uabcd hex 4 */", "    case 'U':               /* %U1234abcd hex 8 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    case 'u':               /* %uabcd hex 4 */", "    case 'U':               /* %U1234abcd hex 8 */", "    {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "    /* Catch \\%^ and \\%$ regardless of where they appear in the", "     * pattern -- regardless of whether or not it makes sense. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "      /* \\%[abc] */", "      for (n = 0; (c = peekchr()) != ']'; ++n) {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      /* \\%[abc] */", "      for (n = 0; (c = peekchr()) != ']'; ++n) {", "        if (c == NUL)"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["      for (n = 0; (c = peekchr()) != ']'; ++n) {", "        if (c == NUL)", "          EMSG2_RET_FAIL(_(e_missing_sb),"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["          EMSG2_RET_FAIL(_(e_missing_sb),", "              reg_magic == MAGIC_ALL);", "        /* recursive call! */"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["              reg_magic == MAGIC_ALL);", "        /* recursive call! */", "        if (nfa_regatom() == FAIL)"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        /* recursive call! */", "        if (nfa_regatom() == FAIL)", "          return FAIL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      }", "      getchr();                    /* get the ] */", "      if (n == 0)"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      getchr();                    /* get the ] */", "      if (n == 0)", "        EMSG2_RET_FAIL(_(e_empty_sb),"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["        EMSG2_RET_FAIL(_(e_empty_sb),", "            reg_magic == MAGIC_ALL);", "      EMIT(NFA_OPT_CHARS);"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["", "      /* Emit as \"\\%(\\%[abc]\\)\" to be able to handle", "       * \"\\%[abc]*\" which would cause the empty string to be"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "      if (c == '<' || c == '>')", "        c = getchr();"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      } else if (c == '\\'' && n == 0) {", "        /* \\%'m  \\%<'m  \\%>'m  */", "        EMIT(cmp == '<' ? NFA_MARK_LT :"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        EMIT(cmp == '<' ? NFA_MARK_LT :", "            cmp == '>' ? NFA_MARK_GT : NFA_MARK);", "        EMIT(getchr());"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["collection:", "    /*", "     * [abc]  uses NFA_START_COLL - NFA_END_COLL"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    if (*endp == ']') {", "      /*", "       * Try to reverse engineer character classes. For example,"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["          EMIT(NFA_OR);", "        } else", "          EMIT(result);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      }", "      /*", "       * Failed to recognize a character class. Use the simple"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        EMIT(NFA_START_NEG_COLL);", "      } else", "        EMIT(NFA_START_COLL);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["        if (*regparse == '[') {", "          /* Check for [: :], [= =], [. .] */", "          equiclass = collclass = 0;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["            equiclass = get_equi_class(&regparse);", "            if (equiclass == 0)", "              collclass = get_coll_element(&regparse);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "          /* Character class like [:alpha:]  */", "          if (charclass != CLASS_NONE) {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["          }", "          /* Try equivalence class [=a=] and the like */", "          if (equiclass != 0) {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["          }", "          /* Try collating class like [. .]  */", "          if (collclass != 0) {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["          if (collclass != 0) {", "            startc = collclass;                  /* allow [.a.]-x as a range */", "            /* Will emit the proper atom at the end of the"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["            startc = collclass;                  /* allow [.a.]-x as a range */", "            /* Will emit the proper atom at the end of the", "             * while loop. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        }", "        /* Try a range like 'a-x' or '\\t-z'. Also allows '-' as a", "         * start character. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "        /* Now handle simple and escaped characters.", "         * Only \"\\]\", \"\\^\", \"\\]\" and \"\\\\\" are special in Vi.  Vim"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["          } else {", "            /* \\r,\\t,\\e,\\b */", "            startc = backslash_trans(*regparse);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "        /* Normal printable char */", "        if (startc == -1)"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        /* Normal printable char */", "        if (startc == -1)", "          startc = PTR2CHAR(regparse);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "        /* Previous char was '-', so this char is end of range. */", "        if (emit_range) {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["          if (endc > startc + 2) {", "            /* Emit a range instead of the sequence of", "             * individual characters. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["             * individual characters. */", "            if (startc == 0)", "              /* \\x00 is translated to \\x0a, start at \\x01. */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["            if (startc == 0)", "              /* \\x00 is translated to \\x0a, start at \\x01. */", "              EMIT(1);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["              EMIT(1);", "            else", "              --post_ptr;                   /* remove NFA_CONCAT */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["            else", "              --post_ptr;                   /* remove NFA_CONCAT */", "            EMIT(endc);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["            else", "              --post_ptr;                   /* remove NFA_CONCAT */", "            EMIT(endc);"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["          } else {", "            /* Emit the range. \"startc\" was already emitted, so", "             * skip it. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        } else {", "          /* This char (startc) is not part of a range. Just", "           * emit it."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["          if (startc == NFA_NEWL) {", "            /* Line break can't be matched as part of the", "             * collection, add an OR below. But not for negated"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["             * range. */", "            if (!negated)", "              extra = NFA_ADD_NL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "      /* skip the trailing ] */", "      regparse = endp;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      return OK;", "    }         /* if exists closing ] */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "    if (reg_strict)", "      EMSG_RET_FAIL(_(e_missingbracket));"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "      /* A base character plus composing characters, or just one", "       * or more composing characters."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        EMIT(c);", "        if (i > 0)", "          EMIT(NFA_CONCAT);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["          EMIT(NFA_CONCAT);", "        if ((i += utf_char2len(c)) >= plen)", "          break;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  return OK;", "}", ""], "readability/fn_size"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Parse something followed by possible [*+=]."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* Save the current parse state, so that we can use it if <atom>{m,n} is", "   * next. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* store current pos in the postfix form, for \\{m,n} involving 0s */", "  my_post_start = (int)(post_ptr - post_start);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  ret = nfa_regatom();", "  if (ret == FAIL)", "    return FAIL;            /* cascaded error */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  if (ret == FAIL)", "    return FAIL;            /* cascaded error */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  op = peekchr();", "  if (re_multi_type(op) == NOT_MULTI)", "    return OK;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  case Magic('+'):", "    /*", "     * Trick: Normally, (a*)\\+ would match the whole input \"aaa\".  The"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    curchr = -1;", "    if (nfa_regatom() == FAIL)", "      return FAIL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    EMIT(NFA_CONCAT);", "    skipchr();                  /* skip the \\+\t*/", "    break;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    EMIT(NFA_CONCAT);", "    skipchr();                  /* skip the \\+\t*/", "    break;"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["    i = 0;", "    switch(op) {", "    case '=':"], "whitespace/parens"]
["src/nvim/regexp_nfa.c", ["    case '=':", "      /* \\@= */", "      i = NFA_PREV_ATOM_NO_WIDTH;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    case '!':", "      /* \\@! */", "      i = NFA_PREV_ATOM_NO_WIDTH_NEG;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      op = no_Magic(getchr());", "      if (op == '=')", "        /* \\@<= */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      if (op == '=')", "        /* \\@<= */", "        i = NFA_PREV_ATOM_JUST_BEFORE;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        i = NFA_PREV_ATOM_JUST_BEFORE;", "      else if (op == '!')", "        /* \\@<! */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      else if (op == '!')", "        /* \\@<! */", "        i = NFA_PREV_ATOM_JUST_BEFORE_NEG;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    case '>':", "      /* \\@>  */", "      i = NFA_PREV_ATOM_LIKE_PATTERN;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    EMIT(i);", "    if (i == NFA_PREV_ATOM_JUST_BEFORE", "        || i == NFA_PREV_ATOM_JUST_BEFORE_NEG)"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  case Magic('{'):", "    /* a{2,5} will expand to 'aaa?a?a?'", "     * a{-1,3} will expand to 'aa??a??', where ?? is the nongreedy"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    }", "    if (!read_limits(&minval, &maxval))", "      EMSG_RET_FAIL(_(\"E870: (NFA regexp) Error reading repetition limits\"));"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "    /*  <atom>{0,inf}, <atom>{0,} and <atom>{}  are equivalent to", "     *  <atom>*  */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    if (minval == 0 && maxval == MAX_LIMIT) {", "      if (greedy)", "        /* \\{}, \\{0,} */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      if (greedy)", "        /* \\{}, \\{0,} */", "        EMIT(NFA_STAR);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        EMIT(NFA_STAR);", "      else", "        /* \\{-}, \\{-0,} */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      else", "        /* \\{-}, \\{-0,} */", "        EMIT(NFA_STAR_NONGREEDY);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "    /* Special case: x{0} or x{-0} */", "    if (maxval == 0) {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    if (maxval == 0) {", "      /* Ignore result of previous call to nfa_regatom() */", "      post_ptr = post_start + my_post_start;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      post_ptr = post_start + my_post_start;", "      /* NFA_EMPTY is 0-length and works everywhere */", "      EMIT(NFA_EMPTY);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "    /* Ignore previous call to nfa_regatom() */", "    post_ptr = post_start + my_post_start;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    post_ptr = post_start + my_post_start;", "    /* Save parse state after the repeated atom and the \\{} */", "    save_parse_state(&new_state);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    for (i = 0; i < maxval; i++) {", "      /* Goto beginning of the repeated atom */", "      restore_parse_state(&old_state);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      old_post_pos = (int)(post_ptr - post_start);", "      if (nfa_regatom() == FAIL)", "        return FAIL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["        return FAIL;", "      /* after \"minval\" times, atoms are optional */", "      if (i + 1 > minval) {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        if (maxval == MAX_LIMIT) {", "          if (greedy)", "            EMIT(NFA_STAR);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["            EMIT(NFA_STAR);", "          else", "            EMIT(NFA_STAR_NONGREEDY);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["            EMIT(NFA_STAR_NONGREEDY);", "        } else", "          EMIT(quest);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      }", "      if (old_post_pos != my_post_start)", "        EMIT(NFA_CONCAT);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["        EMIT(NFA_CONCAT);", "      if (i + 1 > minval && maxval == MAX_LIMIT)", "        break;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "    /* Go to just after the repeated atom and the \\{} */", "    restore_parse_state(&new_state);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    break;", "  }     /* end switch */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Parse one or more pieces, concatenated.  It matches a match for the"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Parse a branch, one or more concats, separated by \"\\&\".  It matches the"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* First branch, possibly the only one */", "  if (nfa_regconcat() == FAIL)"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  /* First branch, possibly the only one */", "  if (nfa_regconcat() == FAIL)", "    return FAIL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    old_post_pos = (int)(post_ptr - post_start);", "    if (nfa_regconcat() == FAIL)", "      return FAIL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      return FAIL;", "    /* if concat is empty do emit a node */", "    if (old_post_pos == (int)(post_ptr - post_start))"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    /* if concat is empty do emit a node */", "    if (old_post_pos == (int)(post_ptr - post_start))", "      EMIT(NFA_EMPTY);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "  /* if a branch is empty, emit one node for it */", "  if (old_post_pos == (int)(post_ptr - post_start))"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  /* if a branch is empty, emit one node for it */", "  if (old_post_pos == (int)(post_ptr - post_start))", "    EMIT(NFA_EMPTY);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "/*", " *  Parse a pattern, one or more branches, separated by \"\\|\".  It matches"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", [" */", "static int ", "nfa_reg ("], "whitespace/end_of_line"]
["src/nvim/regexp_nfa.c", ["static int ", "nfa_reg (", "    int paren              /* REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN */"], "whitespace/parens"]
["src/nvim/regexp_nfa.c", ["nfa_reg (", "    int paren              /* REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN */", ")"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["nfa_reg (", "    int paren              /* REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN */", ")"], "whitespace/line_length"]
["src/nvim/regexp_nfa.c", ["  if (paren == REG_PAREN) {", "    if (regnpar >= NSUBEXP)     /* Too many `(' */", "      EMSG_RET_FAIL(_(\"E872: (NFA regexp) Too many '('\"));"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  if (paren == REG_PAREN) {", "    if (regnpar >= NSUBEXP)     /* Too many `(' */", "      EMSG_RET_FAIL(_(\"E872: (NFA regexp) Too many '('\"));"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  } else if (paren == REG_ZPAREN) {", "    /* Make a ZOPEN node. */", "    if (regnzpar >= NSUBEXP)"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    /* Make a ZOPEN node. */", "    if (regnzpar >= NSUBEXP)", "      EMSG_RET_FAIL(_(\"E879: (NFA regexp) Too many \\\\z(\"));"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "  if (nfa_regbranch() == FAIL)", "    return FAIL;            /* cascaded error */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  if (nfa_regbranch() == FAIL)", "    return FAIL;            /* cascaded error */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    skipchr();", "    if (nfa_regbranch() == FAIL)", "      return FAIL;          /* cascaded error */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    if (nfa_regbranch() == FAIL)", "      return FAIL;          /* cascaded error */", "    EMIT(NFA_OR);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* Check for proper termination. */", "  if (paren != REG_NOPAREN && getchr() != Magic(')')) {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  if (paren != REG_NOPAREN && getchr() != Magic(')')) {", "    if (paren == REG_NPAREN)", "      EMSG2_RET_FAIL(_(e_unmatchedpp), reg_magic == MAGIC_ALL);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      EMSG2_RET_FAIL(_(e_unmatchedpp), reg_magic == MAGIC_ALL);", "    else", "      EMSG2_RET_FAIL(_(e_unmatchedp), reg_magic == MAGIC_ALL);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  } else if (paren == REG_NOPAREN && peekchr() != NUL) {", "    if (peekchr() == Magic(')'))", "      EMSG2_RET_FAIL(_(e_unmatchedpar), reg_magic == MAGIC_ALL);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      EMSG2_RET_FAIL(_(e_unmatchedpar), reg_magic == MAGIC_ALL);", "    else", "      EMSG_RET_FAIL(_(\"E873: (NFA regexp) proper termination error\"));"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  case NFA_PREV_ATOM_NO_WIDTH:", "    STRCPY(code, \"NFA_PREV_ATOM_NO_WIDTH\"); break;", "  case NFA_PREV_ATOM_NO_WIDTH_NEG:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_PREV_ATOM_NO_WIDTH_NEG:", "    STRCPY(code, \"NFA_PREV_ATOM_NO_WIDTH_NEG\"); break;", "  case NFA_PREV_ATOM_JUST_BEFORE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_PREV_ATOM_JUST_BEFORE:", "    STRCPY(code, \"NFA_PREV_ATOM_JUST_BEFORE\"); break;", "  case NFA_PREV_ATOM_JUST_BEFORE_NEG:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_PREV_ATOM_JUST_BEFORE_NEG:", "    STRCPY(code, \"NFA_PREV_ATOM_JUST_BEFORE_NEG\"); break;", "  case NFA_PREV_ATOM_LIKE_PATTERN:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_PREV_ATOM_LIKE_PATTERN:", "    STRCPY(code, \"NFA_PREV_ATOM_LIKE_PATTERN\"); break;", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_FIRST:", "    STRCPY(code, \"NFA_START_INVISIBLE_FIRST\"); break;", "  case NFA_START_INVISIBLE_NEG:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_NEG:", "    STRCPY(code, \"NFA_START_INVISIBLE_NEG\"); break;", "  case NFA_START_INVISIBLE_NEG_FIRST:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_NEG_FIRST:", "    STRCPY(code, \"NFA_START_INVISIBLE_NEG_FIRST\"); break;", "  case NFA_START_INVISIBLE_BEFORE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_BEFORE:", "    STRCPY(code, \"NFA_START_INVISIBLE_BEFORE\"); break;", "  case NFA_START_INVISIBLE_BEFORE_FIRST:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_BEFORE_FIRST:", "    STRCPY(code, \"NFA_START_INVISIBLE_BEFORE_FIRST\"); break;", "  case NFA_START_INVISIBLE_BEFORE_NEG:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_BEFORE_NEG:", "    STRCPY(code, \"NFA_START_INVISIBLE_BEFORE_NEG\"); break;", "  case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:", "    STRCPY(code, \"NFA_START_INVISIBLE_BEFORE_NEG_FIRST\"); break;", "  case NFA_START_PATTERN:   STRCPY(code, \"NFA_START_PATTERN\"); break;"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Print the postfix notation of the current regexp."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    fprintf(f, \"\\\"\\nPostfix notation (int): \");", "    for (p = post_start; *p && p < post_ptr; p++)", "      fprintf(f, \"%d \", *p);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Print the NFA starting with a root node \"state\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  if (state == NULL)", "    return;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "  /* Output indent */", "  p = (char_u *)indent->ga_data;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "    STRNCPY(save, &p[last], 2);", "    STRNCPY(&p[last], \"+-\", 2);"], "runtime/printf"]
["src/nvim/regexp_nfa.c", ["    STRNCPY(save, &p[last], 2);", "    STRNCPY(&p[last], \"+-\", 2);", "    fprintf(debugf, \" %s\", p);"], "runtime/printf"]
["src/nvim/regexp_nfa.c", ["    fprintf(debugf, \" %s\", p);", "    STRNCPY(&p[last], save, 2);", "  } else"], "runtime/printf"]
["src/nvim/regexp_nfa.c", ["    STRNCPY(&p[last], save, 2);", "  } else", "    fprintf(debugf, \" %s\", p);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  fprintf(debugf, \"%s (%d) (id=%d) val=%d\\n\",", "      code,", "      state->c,"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["      code,", "      state->c,", "      abs(state->id),"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["      state->c,", "      abs(state->id),", "      state->val);"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["      abs(state->id),", "      state->val);", "  if (state->id < 0)"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["      state->val);", "  if (state->id < 0)", "    return;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "  /* grow indent for state->out */", "  indent->ga_len -= 1;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  indent->ga_len -= 1;", "  if (state->out1)", "    ga_concat(indent, (char_u *)\"| \");"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    ga_concat(indent, (char_u *)\"| \");", "  else", "    ga_concat(indent, (char_u *)\"  \");"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "  /* replace last part of indent for state->out1 */", "  indent->ga_len -= 3;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* shrink indent */", "  indent->ga_len -= 3;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Print the NFA state machine."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "    if (prog->reganch)", "      fprintf(debugf, \"reganch: %d\\n\", prog->reganch);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      fprintf(debugf, \"reganch: %d\\n\", prog->reganch);", "    if (prog->regstart != NUL)", "      fprintf(debugf, \"regstart: %c (decimal: %d)\\n\","], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      fprintf(debugf, \"regstart: %c (decimal: %d)\\n\",", "          prog->regstart, prog->regstart);", "    if (prog->match_text != NULL)"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          prog->regstart, prog->regstart);", "    if (prog->match_text != NULL)", "      fprintf(debugf, \"match_text: \\\"%s\\\"\\n\", prog->match_text);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["}", "#endif      /* REGEXP_DEBUG */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Parse r.e. @expr and convert it into postfix form."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["{", "  if (nfa_reg(REG_NOPAREN) == FAIL)", "    return NULL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "/* NB. Some of the code below is inspired by Russ's. */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Represents an NFA state plus zero or one or two arrows exiting."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "static nfa_state_T      *state_ptr; /* points to nfa_prog->state */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Allocate and initialize nfa_state_T."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  if (istate >= nstate)", "    return NULL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "/*", " * A partially built NFA without the matching state filled in."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Initialize a Frag_T struct and return it."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Create singleton list containing just outp."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Patch the list of states at out to point to start."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Join the two lists l1 and l2, returning the combination."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  oldl1 = l1;", "  while (l1->next)", "    l1 = l1->next;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Stack used for transforming postfix form into NFA."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Push an item onto the stack."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  if (stackp >= stack_end)", "    return;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Pop an item from the stack."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  stackp = *p;", "  if (stackp < stack)", "    return empty;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Estimate the maximum byte length of anything matching \"state\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* detect looping in a NFA_SPLIT */", "  if (depth > 4)"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  /* detect looping in a NFA_SPLIT */", "  if (depth > 4)", "    return -1;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    case NFA_END_INVISIBLE_NEG:", "      /* the end, return what we have */", "      return len;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    case NFA_SPLIT:", "      /* two alternatives, use the maximum */", "      l = nfa_max_width(state->out, depth + 1);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      r = nfa_max_width(state->out1, depth + 1);", "      if (l < 0 || r < 0)", "        return -1;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    case NFA_OCTAL:", "      /* ascii */", "      ++len;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      /* ascii */", "      ++len;", "      break;"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["    case NFA_START_INVISIBLE_BEFORE_NEG:", "      /* zero-width, out1 points to the END state */", "      state = state->out1->out;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    case NFA_SKIP:", "      /* unknown width */", "      return -1;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    case NFA_END_COMPOSING:", "      /* zero-width */", "      break;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    default:", "      if (state->c < 0)", "        /* don't know what this is */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      if (state->c < 0)", "        /* don't know what this is */", "        return -1;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        return -1;", "      /* normal character */", "      len += MB_CHAR2LEN(state->c);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "    /* normal way to continue */", "    state = state->out;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* unrecognized, \"cannot happen\" */", "  return -1;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Convert a postfix form into its equivalent NFA."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  if (postfix == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "  for (p = postfix; p < end; ++p) {", "    switch (*p) {"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["      s = alloc_state(NFA_SPLIT, e1.start, e2.start);", "      if (s == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      s = alloc_state(NFA_SPLIT, e.start, NULL);", "      if (s == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      s = alloc_state(NFA_SPLIT, NULL, e.start);", "      if (s == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      s = alloc_state(NFA_SPLIT, e.start, NULL);", "      if (s == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      s = alloc_state(NFA_SPLIT, NULL, e.start);", "      if (s == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    case NFA_END_NEG_COLL:", "      /* On the stack is the sequence starting with NFA_START_COLL or", "       * NFA_START_NEG_COLL and all possible characters. Patch it to"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      s = alloc_state(NFA_END_COLL, NULL, NULL);", "      if (s == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      s = alloc_state(NFA_EMPTY, NULL, NULL);", "      if (s == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      }", "      s = NULL;       /* avoid compiler warning */", "      e1.out = NULL;       /* stores list with out1's */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      s = NULL;       /* avoid compiler warning */", "      e1.out = NULL;       /* stores list with out1's */", "      s1 = NULL;       /* previous NFA_SPLIT to connect to */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      e1.out = NULL;       /* stores list with out1's */", "      s1 = NULL;       /* previous NFA_SPLIT to connect to */", "      while (n-- > 0) {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      while (n-- > 0) {", "        e = POP();         /* get character */", "        s = alloc_state(NFA_SPLIT, e.start, NULL);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        s = alloc_state(NFA_SPLIT, e.start, NULL);", "        if (s == NULL)", "          goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["          goto theend;", "        if (e1.out == NULL)", "          e1 = e;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["        break;", "      default:           /* NFA_PREV_ATOM_LIKE_PATTERN: */", "        start_state = NFA_START_PATTERN;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "      if (before)", "        n = *++p;         /* get the count */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      if (before)", "        n = *++p;         /* get the count */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "      /* The \\@= operator: match the preceding atom with zero width.", "       * The \\@! operator: no match for the preceding atom."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      s1 = alloc_state(end_state, NULL, NULL);", "      if (s1 == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      s = alloc_state(start_state, e.start, s1);", "      if (s == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      if (pattern) {", "        /* NFA_ZEND -> NFA_END_PATTERN -> NFA_SKIP -> what follows. */", "        skip = alloc_state(NFA_SKIP, NULL, NULL);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        if (before) {", "          if (n <= 0)", "            /* See if we can guess the maximum width, it avoids a"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["          if (n <= 0)", "            /* See if we can guess the maximum width, it avoids a", "             * lot of pointless tries. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["            n = nfa_max_width(e.start, 0);", "          s->val = n;           /* store the count */", "        }"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "    case NFA_MOPEN:     /* \\( \\) Submatch */", "    case NFA_MOPEN1:"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    case NFA_MOPEN9:", "    case NFA_ZOPEN:     /* \\z( \\) Submatch */", "    case NFA_ZOPEN1:"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      default:", "        /* NFA_MOPEN, NFA_MOPEN1 .. NFA_MOPEN9 */", "        mclose = *p + NSUBEXP;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "      /* Allow \"NFA_MOPEN\" as a valid postfix representation for", "       * the empty regexp \"\". In this case, the NFA will be"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        s = alloc_state(mopen, NULL, NULL);", "        if (s == NULL)", "          goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["        s1 = alloc_state(mclose, NULL, NULL);", "        if (s1 == NULL)", "          goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "      /* At least one node was emitted before NFA_MOPEN, so", "       * at least one node will be between NFA_MOPEN and NFA_MCLOSE */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      e = POP();", "      s = alloc_state(mopen, e.start, NULL);         /* `(' */", "      if (s == NULL)"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      s = alloc_state(mopen, e.start, NULL);         /* `(' */", "      if (s == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "      s1 = alloc_state(mclose, NULL, NULL);         /* `)' */", "      if (s1 == NULL)"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      s1 = alloc_state(mclose, NULL, NULL);         /* `)' */", "      if (s1 == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "      if (mopen == NFA_COMPOSING)", "        /* COMPOSING->out1 = END_COMPOSING */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      if (mopen == NFA_COMPOSING)", "        /* COMPOSING->out1 = END_COMPOSING */", "        patch(list1(&s->out1), s1);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      s = alloc_state(*p, NULL, NULL);", "      if (s == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      s1 = alloc_state(NFA_SKIP, NULL, NULL);", "      if (s1 == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    {", "      int n = *++p;       /* lnum, col or mark name */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      s = alloc_state(p[-1], NULL, NULL);", "      if (s == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      s = alloc_state(*p, NULL, NULL);", "      if (s == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      break;", "", "    }     /* switch(*p) */"], "whitespace/blank_line"]
["src/nvim/regexp_nfa.c", ["", "    }     /* switch(*p) */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    }     /* switch(*p) */", "", "  }   /* for(p = postfix; *p; ++p) */"], "whitespace/blank_line"]
["src/nvim/regexp_nfa.c", ["", "  }   /* for(p = postfix; *p; ++p) */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    nstate++;", "    goto theend;        /* Return value when counting size is ignored anyway */", "  }"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  matchstate = &state_ptr[istate++];   /* the match state */", "  matchstate->c = NFA_MATCH;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * After building the NFA program, inspect it to add optimization hints."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  for (i = 0; i < prog->nstate; ++i) {", "    c = prog->state[i].c;"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["", "        /* Postpone when the invisible match is expensive or has a", "         * lower chance of failing. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["            || c == NFA_START_INVISIBLE_BEFORE_NEG) {", "          /* \"before\" matches are very expensive when", "           * unbounded, always prefer what follows then,"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        } else {", "          /* normal invisible, first do the one with the", "           * highest failure chance */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      }", "      if (directly)", "        /* switch to the _FIRST state */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      if (directly)", "        /* switch to the _FIRST state */", "        ++prog->state[i].c;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        /* switch to the _FIRST state */", "        ++prog->state[i].c;", "    }"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["", "/****************************************************************", "* NFA execution code."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/* Values for done in nfa_pim_T. */", "#define NFA_PIM_UNUSED   0      /* pim not used */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["/* Values for done in nfa_pim_T. */", "#define NFA_PIM_UNUSED   0      /* pim not used */", "#define NFA_PIM_TODO     1      /* pim not done yet */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["#define NFA_PIM_UNUSED   0      /* pim not used */", "#define NFA_PIM_TODO     1      /* pim not done yet */", "#define NFA_PIM_MATCH    2      /* pim executed, matches */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["#define NFA_PIM_TODO     1      /* pim not done yet */", "#define NFA_PIM_MATCH    2      /* pim executed, matches */", "#define NFA_PIM_NOMATCH  3      /* pim executed, no match */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["#define NFA_PIM_MATCH    2      /* pim executed, matches */", "#define NFA_PIM_NOMATCH  3      /* pim executed, no match */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  for (j = 0; j < sub->in_use; j++)", "    if (REG_MULTI)"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  for (j = 0; j < sub->in_use; j++)", "    if (REG_MULTI)", "      fprintf(log_fd, \"*** group %d, start: c=%d, l=%d, end: c=%d, l=%d\\n\","], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      fprintf(log_fd, \"*** group %d, start: c=%d, l=%d, end: c=%d, l=%d\\n\",", "          j,", "          sub->list.multi[j].start_col,"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          j,", "          sub->list.multi[j].start_col,", "          (int)sub->list.multi[j].start_lnum,"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          sub->list.multi[j].start_col,", "          (int)sub->list.multi[j].start_lnum,", "          sub->list.multi[j].end_col,"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          (int)sub->list.multi[j].start_lnum,", "          sub->list.multi[j].end_col,", "          (int)sub->list.multi[j].end_lnum);"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          sub->list.multi[j].end_col,", "          (int)sub->list.multi[j].end_lnum);", "    else {"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          (int)sub->list.multi[j].end_lnum);", "    else {", "      char *s = (char *)sub->list.line[j].start;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["          (int)sub->list.multi[j].end_lnum);", "    else {", "      char *s = (char *)sub->list.line[j].start;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      fprintf(log_fd, \"*** group %d, start: \\\"%s\\\", end: \\\"%s\\\"\\n\",", "          j,", "          s == NULL ? \"NULL\" : s,"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          j,", "          s == NULL ? \"NULL\" : s,", "          e == NULL ? \"NULL\" : e);"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          s == NULL ? \"NULL\" : s,", "          e == NULL ? \"NULL\" : e);", "    }"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Copy the submatches from \"from\" to \"to\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  if (from->in_use > 0) {", "    /* Copy the match start and end positions. */", "    if (REG_MULTI)"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    /* Copy the match start and end positions. */", "    if (REG_MULTI)", "      memmove(&to->list.multi[0],"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      memmove(&to->list.multi[0],", "          &from->list.multi[0],", "          sizeof(struct multipos) * from->in_use);"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          &from->list.multi[0],", "          sizeof(struct multipos) * from->in_use);", "    else"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          sizeof(struct multipos) * from->in_use);", "    else", "      memmove(&to->list.line[0],"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      memmove(&to->list.line[0],", "          &from->list.line[0],", "          sizeof(struct linepos) * from->in_use);"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          &from->list.line[0],", "          sizeof(struct linepos) * from->in_use);", "  }"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Like copy_sub() but exclude the main match."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["{", "  if (to->in_use < from->in_use)", "    to->in_use = from->in_use;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  if (from->in_use > 1) {", "    /* Copy the match start and end positions. */", "    if (REG_MULTI)"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    /* Copy the match start and end positions. */", "    if (REG_MULTI)", "      memmove(&to->list.multi[1],"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      memmove(&to->list.multi[1],", "          &from->list.multi[1],", "          sizeof(struct multipos) * (from->in_use - 1));"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          &from->list.multi[1],", "          sizeof(struct multipos) * (from->in_use - 1));", "    else"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          sizeof(struct multipos) * (from->in_use - 1));", "    else", "      memmove(&to->list.line[1],"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      memmove(&to->list.line[1],", "          &from->list.line[1],", "          sizeof(struct linepos) * (from->in_use - 1));"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          &from->list.line[1],", "          sizeof(struct linepos) * (from->in_use - 1));", "  }"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Like copy_sub() but only do the end of the main match if \\ze is present."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    if (REG_MULTI) {", "      if (from->list.multi[0].end_lnum >= 0){", "        to->list.multi[0].end_lnum = from->list.multi[0].end_lnum;"], "whitespace/braces"]
["src/nvim/regexp_nfa.c", ["    } else {", "      if (from->list.line[0].end != NULL)", "        to->list.line[0].end = from->list.line[0].end;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    int lid,", "    nfa_pim_T *pim) {", "  int col;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["static void report_state(char *action,", "    regsub_T *sub,", "    nfa_state_T *state,"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["    regsub_T *sub,", "    nfa_state_T *state,", "    int lid,"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["    nfa_state_T *state,", "    int lid,", "    nfa_pim_T *pim) {"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["    int lid,", "    nfa_pim_T *pim) {", "  int col;"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["    case NFA_COMPOSING:", "      /* skip ahead to next state */", "      state = state->out1->out;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  case NFA_EMPTY:", "    /* These nodes are not added themselves but their \"out\" and/or", "     * \"out1\" may be added below.  */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  case NFA_ZSTART:", "  /* These nodes need to be added so that we can bail out when it", "   * was added to this list before at the same position to avoid an"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    if (state->lastlist[nfa_ll_index] == l->id && state->c != NFA_SKIP) {", "      /* This state is already in the list, don't add it again,", "       * unless it is an MOPEN that is used for a backreference or"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["          && state->c != NFA_MATCH) {", "", "        /* When called from addstate_here() do insert before"], "whitespace/blank_line"]
["src/nvim/regexp_nfa.c", ["", "        /* When called from addstate_here() do insert before", "         * existing states. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        if (add_here) {", "          for (k = 0; k < l->n && k < listindex; ++k) {", "            if (l->t[k].state->id == state->id) {"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["          nfa_set_code(state->c);", "          fprintf(log_fd, \"> Not adding state %d to list %d. char %d: %s pim: %s has_pim: %d found: %d\\n\",", "                  abs(state->id), l->id, state->c, code,"], "whitespace/line_length"]
["src/nvim/regexp_nfa.c", ["", "      /* Do not add the state again when it exists with the same", "       * positions. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["       * positions. */", "      if (has_state_with_pos(l, state, subs, pim))", "        goto skip_add;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "    /* add the state to the list */", "    state->lastlist[nfa_ll_index] = l->id;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    thread->state = state;", "    if (pim == NULL)", "      thread->pim.result = NFA_PIM_UNUSED;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      thread->pim.result = NFA_PIM_UNUSED;", "    else {", "      copy_pim(&thread->pim, pim);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      thread->pim.result = NFA_PIM_UNUSED;", "    else {", "      copy_pim(&thread->pim, pim);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["#ifdef REGEXP_DEBUG", "  if (!did_print)", "    report_state(\"Processing\", &subs->norm, state, l->id, pim);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  case NFA_SPLIT:", "    /* order matters here */", "    subs = addstate(l, state->out, subs, pim, off_arg);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "    /* avoid compiler warnings */", "    save_ptr = NULL;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "    /* Set the position (with \"off\" added) in the subexpression.  Save", "     * and restore it when it was in use.  Otherwise fill any gap. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        save_in_use = sub->in_use;", "        for (i = sub->in_use; i < subidx; ++i) {", "          sub->list.multi[i].start_lnum = -1;"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["        save_in_use = sub->in_use;", "        for (i = sub->in_use; i < subidx; ++i) {", "          sub->list.line[i].start = NULL;"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["      }", "      else", "        sub->list.line[subidx].start = save_ptr;"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["        sub->list.line[subidx].start = save_ptr;", "    } else", "      sub->in_use = save_in_use;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "    /* We don't fill in gaps here, there must have been an MOPEN that", "     * has done that. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    save_in_use = sub->in_use;", "    if (sub->in_use <= subidx)", "      sub->in_use = subidx + 1;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      }", "      /* avoid compiler warnings */", "      save_ptr = NULL;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    }", "    else", "      sub->list.line[subidx].end = save_ptr;"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Like addstate(), but the new state(s) are put at position \"*ip\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* First add the state(s) at the end, so that we know how many there are.", "   * Pass the listidx as offset (avoids adding another argument to"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    if (l->n + count - 1 >= l->len) {", "      /* not enough space to move the new states, reallocate the list", "       * and move the states to the right position */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      memmove(&(newl[0]),", "          &(l->t[0]),", "          sizeof(nfa_thread_T) * listidx);"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          &(l->t[0]),", "          sizeof(nfa_thread_T) * listidx);", "      memmove(&(newl[listidx]),"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["      memmove(&(newl[listidx]),", "          &(l->t[l->n - count]),", "          sizeof(nfa_thread_T) * count);"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          &(l->t[l->n - count]),", "          sizeof(nfa_thread_T) * count);", "      memmove(&(newl[listidx + count]),"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["      memmove(&(newl[listidx + count]),", "          &(l->t[listidx + 1]),", "          sizeof(nfa_thread_T) * (l->n - count - listidx - 1));"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          &(l->t[listidx + 1]),", "          sizeof(nfa_thread_T) * (l->n - count - listidx - 1));", "      xfree(l->t);"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["    } else {", "      /* make space for new states, then move them from the", "       * end to the current position */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      memmove(&(l->t[listidx + count]),", "          &(l->t[listidx + 1]),", "          sizeof(nfa_thread_T) * (l->n - listidx - 1));"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          &(l->t[listidx + 1]),", "          sizeof(nfa_thread_T) * (l->n - listidx - 1));", "      memmove(&(l->t[listidx]),"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["      memmove(&(l->t[listidx]),", "          &(l->t[l->n - 1]),", "          sizeof(nfa_thread_T) * count);"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          &(l->t[l->n - 1]),", "          sizeof(nfa_thread_T) * count);", "    }"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["  }", "  --l->n;", "  *ip = listidx - 1;"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Check character class \"class\" against current character c."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_BLANK:", "    if (c == ' ' || c == '\\t')", "      return OK;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_DIGIT:", "    if (ascii_isdigit(c))", "      return OK;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_PRINT:", "    if (vim_isprintc(c))", "      return OK;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_SPACE:", "    if ((c >= 9 && c <= 13) || (c == ' '))", "      return OK;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_XDIGIT:", "    if (ascii_isxdigit(c))", "      return OK;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_TAB:", "    if (c == '\\t')", "      return OK;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_RETURN:", "    if (c == '\\r')", "      return OK;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_BACKSPACE:", "    if (c == '\\b')", "      return OK;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Check for a match with subexpression \"subidx\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", [" */", "static int ", "match_backref ("], "whitespace/end_of_line"]
["src/nvim/regexp_nfa.c", ["static int ", "match_backref (", "    regsub_T *sub,           /* pointers to subexpressions */"], "whitespace/parens"]
["src/nvim/regexp_nfa.c", ["match_backref (", "    regsub_T *sub,           /* pointers to subexpressions */", "    int subidx,"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    int subidx,", "    int *bytelen       /* out: length of match in bytes */", ")"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["retempty:", "    /* backref was not set, match an empty string */", "    *bytelen = 0;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  if (REG_MULTI) {", "    if (sub->list.multi[subidx].start_lnum < 0", "        || sub->list.multi[subidx].end_lnum < 0)"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  } else {", "    if (sub->list.line[subidx].start == NULL", "        || sub->list.line[subidx].end == NULL)"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Check for a match with \\z subexpression \"subidx\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", [" */", "static int ", "match_zref ("], "whitespace/end_of_line"]
["src/nvim/regexp_nfa.c", ["static int ", "match_zref (", "    int subidx,"], "whitespace/parens"]
["src/nvim/regexp_nfa.c", ["    int subidx,", "    int *bytelen       /* out: length of match in bytes */", ")"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  if (re_extmatch_in == NULL || re_extmatch_in->matches[subidx] == NULL) {", "    /* backref was not set, match an empty string */", "    *bytelen = 0;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Save list IDs for all NFA states of \"prog\" into \"list\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* Order in the list is reverse, it's a bit faster that way. */", "  p = &prog->state[0];"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    p->lastlist[1] = 0;", "    ++p;", "  }"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Restore list IDs from \"list\" to all NFA states."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    p->lastlist[1] = list[i];", "    ++p;", "  }"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["{", "  if (op == 1) return pos > val;", "  if (op == 2) return pos < val;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  if (op == 1) return pos > val;", "  if (op == 2) return pos < val;", "  return val == pos;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Recursively call nfa_regmatch()"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["#ifdef REGEXP_DEBUG", "  if (log_fd != stderr)", "    fclose(log_fd);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Estimate the chance of a match with \"state\" failing."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* detect looping */", "  if (depth > 4)"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  /* detect looping */", "  if (depth > 4)", "    return 1;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  case NFA_SPLIT:", "    if (state->out->c == NFA_SPLIT || state->out1->c == NFA_SPLIT)", "      /* avoid recursive stuff */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    if (state->out->c == NFA_SPLIT || state->out1->c == NFA_SPLIT)", "      /* avoid recursive stuff */", "      return 1;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      return 1;", "    /* two alternatives, use the lowest failure chance */", "    l = failure_chance(state->out, depth + 1);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  case NFA_ANY:", "    /* matches anything, unlikely to fail */", "    return 1;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  case NFA_ANY_COMPOSING:", "    /* empty match works always */", "    return 0;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_PATTERN:", "    /* recursive regmatch is expensive, use low failure chance */", "    return 5;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  case NFA_ZREF9:", "    /* backreferences don't match in many places */", "    return 94;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  case NFA_VISUAL:", "    /* before/after positions don't match very often */", "    return 85;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  case NFA_MARK:", "    /* specific positions rarely match */", "    return 98;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  default:", "    if (c > 0)", "      /* character match fails often */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    if (c > 0)", "      /* character match fails often */", "      return 95;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* something else, includes character classes */", "  return 50;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Skip until the char \"c\" we know a match must start with."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Check for a match with match_text."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    fprintf(log_fd, \" RUNNING nfa_regmatch() starting with state %d, code %s\\n\",", "        abs(start->id), code);", "    fprintf(log_fd, \"**********************************\\n\");"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["", "  /*", "   * Run for each character."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "    /* swap lists */", "    thislist = &list[flag];"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "      for (i = 0; i < thislist->n; i++)", "        fprintf(log_fd, \"%d  \", abs(thislist->t[i].state->id));"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["#endif", "    /*", "     * If the state lists are empty we can stop."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["     */", "    if (thislist->n == 0)", "      break;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "      /*", "       * Handle the possible codes of the current state."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        fprintf(log_fd, \"Failure chance invisible: %d, what follows: %d\\n\",", "            failure_chance(t->state->out, 0),", "            failure_chance(t->state->out1->out, 0));"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["            failure_chance(t->state->out, 0),", "            failure_chance(t->state->out1->out, 0));", "#endif"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["        } else if (state_in_list(nextlist,", "                       t->state->out1->out->out, &t->subs)) {", "          skip = t->state->out1->out->out;"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["        } else if (state_in_list(thislist,", "                       t->state->out1->out->out, &t->subs)) {", "          skip = t->state->out1->out->out;"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["              log_fd,", "              \"> Not trying to match pattern, output state %d is already in list %d. char %d: %s\\n\",", "              abs(skip->id), skip_lid, skip->c, code);"], "whitespace/line_length"]
["src/nvim/regexp_nfa.c", ["            len += mb_char2len(mc);", "            if (ccount == MAX_MCO)", "              break;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["          while (sta->c != NFA_END_COMPOSING) {", "            for (j = 0; j < ccount; ++j)", "              if (cchars[j] == sta->c)"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["          while (sta->c != NFA_END_COMPOSING) {", "            for (j = 0; j < ccount; ++j)", "              if (cchars[j] == sta->c)"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["            for (j = 0; j < ccount; ++j)", "              if (cchars[j] == sta->c)", "                break;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["          }", "        } else", "          result = FAIL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["            fprintf(log_fd, \"NFA_RANGE_MIN curc=%d c1=%d c2=%d\\n\",", "                curc, c1, c2);", "#endif"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["", "        if (t->pim.result == NFA_PIM_UNUSED)", "          pim = NULL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["          pim = NULL;", "        else", "          pim = &t->pim;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["                log_fd,", "                \"Using previous recursive nfa_regmatch() result, result == %d\\n\",", "                pim->result);"], "whitespace/line_length"]
["src/nvim/regexp_nfa.c", ["              fprintf(log_fd,", "                  \"  Skipping start state, regstart does not match\\n\");", "#endif"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["", "      for (i = 0; i < thislist->n; i++)", "        fprintf(log_fd, \"%d  \", abs(thislist->t[i].state->id));"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["#ifdef REGEXP_DEBUG", "  if (log_fd != stderr)", "    fclose(log_fd);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  return nfa_match;", "}", ""], "readability/fn_size"]
["src/nvim/regexp_nfa.c", ["    fprintf(f,", "        \"\\n\\n\\t=======================================================\\n\");", "#ifdef REGEXP_DEBUG"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["", "  /* Package any found \\z(...\\) matches for export. Default is none. */", "  unref_extmatch(re_extmatch_out);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "        if (lpos->start != NULL && lpos->end != NULL)", "          re_extmatch_out->matches[i] ="], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "  /* Be paranoid... */", "  if (prog == NULL || line == NULL) {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  if (prog->reganch && col > 0)", "    return 0L;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  if (prog->regstart != NUL) {", "    /* Skip ahead until a character we know the match must start with.", "     * When there is none there is no match. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["     * When there is none there is no match. */", "    if (skip_to_start(prog->regstart, &col) == FAIL)", "      return 0L;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Compile a regular expression into internal code for the NFA matcher."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  if (expr == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "  /*", "   * In order to build the NFA, we parse the input regexp twice:"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /*", "   * PASS 1"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* allocate the regprog with space for the compiled regexp */", "  size_t prog_size = sizeof(nfa_regprog_T) + sizeof(nfa_state_T) * (nstate - 1);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /*", "   * PASS 2"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["#endif", "  /* Remember whether this pattern has any \\z specials in it. */", "  prog->reghasz = re_has_z;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Free a compiled regexp program, returned by nfa_regcomp()."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Match a regexp against a string."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", [" */", "static int ", "nfa_regexec_nl ("], "whitespace/end_of_line"]
["src/nvim/regexp_nfa.c", ["static int ", "nfa_regexec_nl (", "    regmatch_T *rmp,"], "whitespace/parens"]
["src/nvim/regexp_nfa.c", ["    regmatch_T *rmp,", "    char_u *line,      /* string to match against */", "    colnr_T col,       /* column to start looking for match */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    char_u *line,      /* string to match against */", "    colnr_T col,       /* column to start looking for match */", "    bool line_lbr"], "readability/old_style_comment"]
["src/nvim/runtime.c", ["    if (vim_ispathsep_nocolon(*p)) {", "      p4 = p3; p3 = p2; p2 = p1; p1 = p;", "    }"], "whitespace/newline"]
["src/nvim/screen.c", ["", "#define MB_FILLER_CHAR '<'  /* character used when a double-width character", "                             * doesn't fit. */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["", "#define MB_FILLER_CHAR '<'  /* character used when a double-width character", "                             * doesn't fit. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "static match_T search_hl;       /* used for 'hlsearch' highlight matching */", ""], "readability/old_style_comment"]
["src/nvim/screen.c", ["    wp->w_redr_type = type;", "    if (type >= NOT_VALID)", "      wp->w_lines_valid = 0;"], "readability/braces"]
["src/nvim/screen.c", ["      wp->w_lines_valid = 0;", "    if (must_redraw < type)     /* must_redraw is the maximum of all windows */", "      must_redraw = type;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      wp->w_lines_valid = 0;", "    if (must_redraw < type)     /* must_redraw is the maximum of all windows */", "      must_redraw = type;"], "readability/braces"]
["src/nvim/screen.c", ["", "/*", " * Mark all windows to be redrawn later."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Mark all windows that are editing the current buffer to be updated later."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Changed something in the current window, at buffer line \"lnum\", that"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * update all windows that are editing the current buffer"], "readability/old_style_comment"]
["src/nvim/screen.c", ["{", "  static int did_intro = FALSE;", "  int did_one;"], "readability/bool"]
["src/nvim/screen.c", ["  if (must_redraw) {", "    if (type < must_redraw)         /* use maximal type */", "      type = must_redraw;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  if (must_redraw) {", "    if (type < must_redraw)         /* use maximal type */", "      type = must_redraw;"], "readability/braces"]
["src/nvim/screen.c", ["", "    /* must_redraw is reset here, so that when we run into some weird", "    * reason to redraw while busy redrawing (e.g., asynchronous"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* Need to update w_lines[]. */", "  if (curwin->w_lines_valid == 0 && type < NOT_VALID)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  /* Need to update w_lines[]. */", "  if (curwin->w_lines_valid == 0 && type < NOT_VALID)", "    type = NOT_VALID;"], "readability/braces"]
["src/nvim/screen.c", ["", "  /* Postpone the redrawing when it's not needed and when being called", "   * recursively. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                <= msg_scrolled) {", "              wp->w_redr_status = TRUE;", "            }"], "readability/bool"]
["src/nvim/screen.c", ["      }", "      redraw_cmdline = TRUE;", "      redraw_tabline = TRUE;"], "readability/bool"]
["src/nvim/screen.c", ["      redraw_cmdline = TRUE;", "      redraw_tabline = TRUE;", "    }"], "readability/bool"]
["src/nvim/screen.c", ["", "  /* reset cmdline_row now (may have been changed temporarily) */", "  compute_cmdrow();"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* Check for changed highlighting */", "  if (need_highlight_changed)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  /* Check for changed highlighting */", "  if (need_highlight_changed)", "    highlight_changed();"], "readability/braces"]
["src/nvim/screen.c", ["", "  if (clear_cmdline)            /* going to clear cmdline (done below) */", "    check_for_delay(FALSE);"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  if (clear_cmdline)            /* going to clear cmdline (done below) */", "    check_for_delay(FALSE);"], "readability/braces"]
["src/nvim/screen.c", ["  if (clear_cmdline)            /* going to clear cmdline (done below) */", "    check_for_delay(FALSE);", ""], "readability/bool"]
["src/nvim/screen.c", ["", "  /* Force redraw when width of 'number' or 'relativenumber' column", "   * changes. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["   * changes. */", "  if (curwin->w_redr_type < NOT_VALID", "      && curwin->w_nrwidth != ((curwin->w_p_nu || curwin->w_p_rnu)"], "readability/braces"]
["src/nvim/screen.c", ["", "  /*", "   * Only start redrawing if there is really something to do."], "readability/old_style_comment"]
["src/nvim/screen.c", ["   */", "  if (type == INVERTED)", "    update_curswant();"], "readability/braces"]
["src/nvim/screen.c", ["    update_curswant();", "  if (curwin->w_redr_type < type", "      && !((type == VALID"], "readability/braces"]
["src/nvim/screen.c", ["               && curwin->w_old_curswant == curwin->w_curswant)", "           ))", "    curwin->w_redr_type = type;"], "whitespace/parens"]
["src/nvim/screen.c", ["", "  /*", "   * Correct stored syntax highlighting info for changes in each displayed"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * Go from top to bottom through the windows, redrawing the ones that need"], "readability/old_style_comment"]
["src/nvim/screen.c", ["   */", "  did_one = FALSE;", "  search_hl.rm.regprog = NULL;"], "readability/bool"]
["src/nvim/screen.c", ["      if (!did_one) {", "        did_one = TRUE;", "        start_search_hl();"], "readability/bool"]
["src/nvim/screen.c", ["", "    /* redraw status line after the window to minimize cursor movement */", "    if (wp->w_redr_status) {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* Reset b_mod_set flags.  Going through all windows is probably faster", "   * than going through all buffers (there could be many buffers). */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* Clear or redraw the command line.  Done last, because scrolling may", "   * mess up the command line. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* May put up an introductory message when not editing a file */", "  if (!did_intro)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  /* May put up an introductory message when not editing a file */", "  if (!did_intro)", "    maybe_intro_message();"], "readability/braces"]
["src/nvim/screen.c", ["    maybe_intro_message();", "  did_intro = TRUE;", ""], "readability/bool"]
["src/nvim/screen.c", ["", "/*", " * Update a single window."], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int type;", "  int top_end = 0;              /* Below last row of the top area that needs", "                                   updating.  0 when no top area updating. */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["  int type;", "  int top_end = 0;              /* Below last row of the top area that needs", "                                   updating.  0 when no top area updating. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                                   updating.  0 when no top area updating. */", "  int mid_start = 999;          /* first row of the mid area that needs", "                                   updating.  999 when no mid area updating. */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["                                   updating.  0 when no top area updating. */", "  int mid_start = 999;          /* first row of the mid area that needs", "                                   updating.  999 when no mid area updating. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                                   updating.  999 when no mid area updating. */", "  int mid_end = 0;              /* Below last row of the mid area that needs", "                                   updating.  0 when no mid area updating. */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["                                   updating.  999 when no mid area updating. */", "  int mid_end = 0;              /* Below last row of the mid area that needs", "                                   updating.  0 when no mid area updating. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                                   updating.  0 when no mid area updating. */", "  int bot_start = 999;          /* first row of the bot area that needs", "                                   updating.  999 when no bot area updating */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["                                   updating.  0 when no mid area updating. */", "  int bot_start = 999;          /* first row of the bot area that needs", "                                   updating.  999 when no bot area updating */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                                   updating.  999 when no bot area updating */", "  int scrolled_down = FALSE;            /* TRUE when scrolled down when", "                                           w_topline got smaller a bit */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["                                   updating.  999 when no bot area updating */", "  int scrolled_down = FALSE;            /* TRUE when scrolled down when", "                                           w_topline got smaller a bit */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                                   updating.  999 when no bot area updating */", "  int scrolled_down = FALSE;            /* TRUE when scrolled down when", "                                           w_topline got smaller a bit */"], "readability/bool"]
["src/nvim/screen.c", ["", "  int row;                      /* current window row to display */", "  linenr_T lnum;                /* current buffer lnum to display */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int row;                      /* current window row to display */", "  linenr_T lnum;                /* current buffer lnum to display */", "  int idx;                      /* current index in w_lines[] */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  linenr_T lnum;                /* current buffer lnum to display */", "  int idx;                      /* current index in w_lines[] */", "  int srow;                     /* starting row of the current line */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int idx;                      /* current index in w_lines[] */", "  int srow;                     /* starting row of the current line */", ""], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  int eof = FALSE;              /* if TRUE, we hit the end of the file */", "  int didline = FALSE;           /* if TRUE, we finished the last line */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  int eof = FALSE;              /* if TRUE, we hit the end of the file */", "  int didline = FALSE;           /* if TRUE, we finished the last line */"], "readability/bool"]
["src/nvim/screen.c", ["  int eof = FALSE;              /* if TRUE, we hit the end of the file */", "  int didline = FALSE;           /* if TRUE, we finished the last line */", "  int i;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int eof = FALSE;              /* if TRUE, we hit the end of the file */", "  int didline = FALSE;           /* if TRUE, we finished the last line */", "  int i;"], "readability/bool"]
["src/nvim/screen.c", ["  int did_update = DID_NONE;", "  linenr_T syntax_last_parsed = 0;              /* last parsed text line */", "  linenr_T mod_top = 0;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* Force redraw when width of 'number' or 'relativenumber' column", "   * changes. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  } else {", "    /*", "     * Set mod_top to the first line that needs displaying because of"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    mod_top = wp->w_redraw_top;", "    if (wp->w_redraw_bot != 0)", "      mod_bot = wp->w_redraw_bot + 1;"], "readability/braces"]
["src/nvim/screen.c", ["      mod_bot = wp->w_redraw_bot + 1;", "    else", "      mod_bot = 0;"], "readability/braces"]
["src/nvim/screen.c", ["        mod_top = buf->b_mod_top;", "        /* Need to redraw lines above the change that may be included", "         * in a pattern match. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          mod_top -= buf->b_s.b_syn_sync_linebreaks;", "          if (mod_top < 1)", "            mod_top = 1;"], "readability/braces"]
["src/nvim/screen.c", ["      }", "      if (mod_bot == 0 || mod_bot < buf->b_mod_bot)", "        mod_bot = buf->b_mod_bot;"], "readability/braces"]
["src/nvim/screen.c", ["", "      /*", "       * A change in a line can cause lines above it to become folded or"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "      /* Find last valid w_lines[] entry above mod_top.  Set lnumt to", "       * the line below it.  If there is no valid entry, use w_topline."], "readability/old_style_comment"]
["src/nvim/screen.c", ["      lnumb = MAXLNUM;", "      for (i = 0; i < wp->w_lines_valid; ++i)", "        if (wp->w_lines[i].wl_valid) {"], "readability/braces"]
["src/nvim/screen.c", ["      lnumb = MAXLNUM;", "      for (i = 0; i < wp->w_lines_valid; ++i)", "        if (wp->w_lines[i].wl_valid) {"], "readability/increment"]
["src/nvim/screen.c", ["        if (wp->w_lines[i].wl_valid) {", "          if (wp->w_lines[i].wl_lastlnum < mod_top)", "            lnumt = wp->w_lines[i].wl_lastlnum + 1;"], "readability/braces"]
["src/nvim/screen.c", ["", "    /* When a change starts above w_topline and the end is below", "     * w_topline, start redrawing at w_topline."], "readability/old_style_comment"]
["src/nvim/screen.c", ["    if (mod_top != 0 && mod_top < wp->w_topline) {", "      if (mod_bot > wp->w_topline)", "        mod_top = wp->w_topline;"], "readability/braces"]
["src/nvim/screen.c", ["        mod_top = wp->w_topline;", "      else if (syntax_present(wp))", "        top_end = 1;"], "readability/braces"]
["src/nvim/screen.c", ["", "    /* When line numbers are displayed need to redraw all lines below", "     * inserted/deleted lines. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["     * inserted/deleted lines. */", "    if (mod_top != 0 && buf->b_mod_xlines != 0 && wp->w_p_nu)", "      mod_bot = MAXLNUM;"], "readability/braces"]
["src/nvim/screen.c", ["", "  /*", "   * When only displaying the lines at the top, set top_end.  Used when"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    j = 0;", "    for (i = 0; i < wp->w_lines_valid; ++i) {", "      j += wp->w_lines[i].wl_size;"], "readability/increment"]
["src/nvim/screen.c", ["    }", "    if (top_end == 0)", "      /* not found (cannot happen?): redraw everything */"], "readability/braces"]
["src/nvim/screen.c", ["    if (top_end == 0)", "      /* not found (cannot happen?): redraw everything */", "      type = NOT_VALID;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      type = NOT_VALID;", "    else", "      /* top area defined, the rest is VALID */"], "readability/braces"]
["src/nvim/screen.c", ["    else", "      /* top area defined, the rest is VALID */", "      type = VALID;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * If there are no changes on the screen that require a complete redraw,"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                       && wp->w_topfill > wp->w_old_topfill)", "                   )) {", "      /*"], "whitespace/parens"]
["src/nvim/screen.c", ["                   )) {", "      /*", "       * New topline is above old topline: May scroll down."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "        /* count the number of lines we are off, counting a sequence", "         * of folded lines as one */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        }", "      } else", "        j = wp->w_lines[0].wl_lnum - wp->w_topline;"], "readability/braces"]
["src/nvim/screen.c", ["        i = plines_m_win(wp, wp->w_topline, wp->w_lines[0].wl_lnum - 1);", "        /* insert extra lines for previously invisible filler lines */", "        if (wp->w_lines[0].wl_lnum != wp->w_topline)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        /* insert extra lines for previously invisible filler lines */", "        if (wp->w_lines[0].wl_lnum != wp->w_topline)", "          i += diff_check_fill(wp, wp->w_lines[0].wl_lnum)"], "readability/braces"]
["src/nvim/screen.c", ["    } else {", "      /*", "       * New topline is at or below old topline: May scroll up."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "      /* try to find wp->w_topline in wp->w_lines[].wl_lnum */", "      j = -1;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      if (j == -1) {", "        /* if wp->w_topline is not in wp->w_lines[].wl_lnum redraw all", "         * lines */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      } else {", "        /*", "         * Try to delete the correct number of lines."], "readability/old_style_comment"]
["src/nvim/screen.c", ["         */", "        /* If the topline didn't change, delete old filler lines,", "         * otherwise delete filler lines of the new topline... */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["         * otherwise delete filler lines of the new topline... */", "        if (wp->w_lines[0].wl_lnum == wp->w_topline)", "          row += wp->w_old_topfill;"], "readability/braces"]
["src/nvim/screen.c", ["          row += wp->w_old_topfill;", "        else", "          row += diff_check_fill(wp, wp->w_topline);"], "readability/braces"]
["src/nvim/screen.c", ["          row += diff_check_fill(wp, wp->w_topline);", "        /* ... but don't delete new filler lines. */", "        row -= wp->w_topfill;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        if ((row == 0 || bot_start < 999) && wp->w_lines_valid != 0) {", "          /*", "           * Skip the lines (below the deleted lines) that are still"], "readability/old_style_comment"]
["src/nvim/screen.c", ["            wp->w_lines[idx] = wp->w_lines[j];", "            /* stop at line that didn't fit, unless it is still", "             * valid (no lines deleted) */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "            /* stop at the last valid entry in w_lines[].wl_size */", "            if (++j >= wp->w_lines_valid) {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          }", "          /* Correct the first entry for filler lines at the top", "           * when it won't get updated below. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["           * when it won't get updated below. */", "          if (wp->w_p_diff && bot_start > 0)", "            wp->w_lines[0].wl_size ="], "readability/braces"]
["src/nvim/screen.c", ["  } else {", "    /* Not VALID or INVERTED: redraw all lines. */", "    mid_start = 0;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  if (type == SOME_VALID) {", "    /* SOME_VALID: redraw all lines. */", "    mid_start = 0;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* check if we are updating or removing the inverted part */", "  if ((VIsual_active && buf == curwin->w_buffer)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        }", "        /* redraw more when the cursor moved as well */", "        if (wp->w_old_cursor_lnum < from)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        /* redraw more when the cursor moved as well */", "        if (wp->w_old_cursor_lnum < from)", "          from = wp->w_old_cursor_lnum;"], "readability/braces"]
["src/nvim/screen.c", ["          from = wp->w_old_cursor_lnum;", "        if (wp->w_old_cursor_lnum > to)", "          to = wp->w_old_cursor_lnum;"], "readability/braces"]
["src/nvim/screen.c", ["          to = wp->w_old_cursor_lnum;", "        if (wp->w_old_visual_lnum < from)", "          from = wp->w_old_visual_lnum;"], "readability/braces"]
["src/nvim/screen.c", ["          from = wp->w_old_visual_lnum;", "        if (wp->w_old_visual_lnum > to)", "          to = wp->w_old_visual_lnum;"], "readability/braces"]
["src/nvim/screen.c", ["      } else {", "        /*", "         * Find the line numbers that need to be updated: The lines"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          to = curwin->w_cursor.lnum;", "          if (from == 0)                /* Visual mode just started */", "            from = to;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          to = curwin->w_cursor.lnum;", "          if (from == 0)                /* Visual mode just started */", "            from = to;"], "readability/braces"]
["src/nvim/screen.c", ["            || VIsual.col != wp->w_old_visual_col) {", "          if (wp->w_old_visual_lnum < from", "              && wp->w_old_visual_lnum != 0)"], "readability/braces"]
["src/nvim/screen.c", ["            from = wp->w_old_visual_lnum;", "          if (wp->w_old_visual_lnum > to)", "            to = wp->w_old_visual_lnum;"], "readability/braces"]
["src/nvim/screen.c", ["            to = wp->w_old_visual_lnum;", "          if (VIsual.lnum < from)", "            from = VIsual.lnum;"], "readability/braces"]
["src/nvim/screen.c", ["            from = VIsual.lnum;", "          if (VIsual.lnum > to)", "            to = VIsual.lnum;"], "readability/braces"]
["src/nvim/screen.c", ["", "      /*", "       * If in block mode and changed column or curwin->w_curswant:"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "        if (curwin->w_p_lbr)", "          ve_flags = VE_ALL;"], "readability/braces"]
["src/nvim/screen.c", ["        ve_flags = save_ve_flags;", "        ++toc;", "        if (curwin->w_curswant == MAXCOL)"], "readability/increment"]
["src/nvim/screen.c", ["        ++toc;", "        if (curwin->w_curswant == MAXCOL)", "          toc = MAXCOL;"], "readability/braces"]
["src/nvim/screen.c", ["            || toc != wp->w_old_cursor_lcol) {", "          if (from > VIsual.lnum)", "            from = VIsual.lnum;"], "readability/braces"]
["src/nvim/screen.c", ["            from = VIsual.lnum;", "          if (to < VIsual.lnum)", "            to = VIsual.lnum;"], "readability/braces"]
["src/nvim/screen.c", ["    } else {", "      /* Use the line numbers of the old Visual area. */", "      if (wp->w_old_cursor_lnum < wp->w_old_visual_lnum) {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /*", "     * There is no need to update lines above the top of the window."], "readability/old_style_comment"]
["src/nvim/screen.c", ["     */", "    if (from < wp->w_topline)", "      from = wp->w_topline;"], "readability/braces"]
["src/nvim/screen.c", ["", "    /*", "     * If we know the value of w_botline, use it to restrict the update to"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    if (wp->w_valid & VALID_BOTLINE) {", "      if (from >= wp->w_botline)", "        from = wp->w_botline - 1;"], "readability/braces"]
["src/nvim/screen.c", ["        from = wp->w_botline - 1;", "      if (to >= wp->w_botline)", "        to = wp->w_botline - 1;"], "readability/braces"]
["src/nvim/screen.c", ["", "    /*", "     * Find the minimal part to be updated."], "readability/old_style_comment"]
["src/nvim/screen.c", ["      srow = 0;", "      if (scrolled_down)", "        mid_start = top_end;"], "readability/braces"]
["src/nvim/screen.c", ["        mid_start = top_end;", "      else", "        mid_start = 0;"], "readability/braces"]
["src/nvim/screen.c", ["        mid_start = 0;", "      while (lnum < from && idx < wp->w_lines_valid) {          /* find start */", "        if (wp->w_lines[idx].wl_valid)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      while (lnum < from && idx < wp->w_lines_valid) {          /* find start */", "        if (wp->w_lines[idx].wl_valid)", "          mid_start += wp->w_lines[idx].wl_size;"], "readability/braces"]
["src/nvim/screen.c", ["          mid_start += wp->w_lines[idx].wl_size;", "        else if (!scrolled_down)", "          srow += wp->w_lines[idx].wl_size;"], "readability/braces"]
["src/nvim/screen.c", ["          srow += wp->w_lines[idx].wl_size;", "        ++idx;", "        if (idx < wp->w_lines_valid && wp->w_lines[idx].wl_valid)"], "readability/increment"]
["src/nvim/screen.c", ["        ++idx;", "        if (idx < wp->w_lines_valid && wp->w_lines[idx].wl_valid)", "          lnum = wp->w_lines[idx].wl_lnum;"], "readability/braces"]
["src/nvim/screen.c", ["          lnum = wp->w_lines[idx].wl_lnum;", "        else", "          ++lnum;"], "readability/braces"]
["src/nvim/screen.c", ["        else", "          ++lnum;", "      }"], "readability/increment"]
["src/nvim/screen.c", ["            && wp->w_lines[idx].wl_lnum >= to + 1) {", "          /* Only update until first row of this line */", "          mid_end = srow;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* reset got_int, otherwise regexp won't work */", "  save_got_int = got_int;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * Update all the window rows."], "readability/old_style_comment"]
["src/nvim/screen.c", ["   */", "  idx = 0;              /* first entry in w_lines[].wl_size */", "  row = 0;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  for (;; ) {", "    /* stop updating when reached the end of the window (check for _past_", "     * the end of the window is at the end of the loop) */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /* stop updating when hit the end of the file */", "    if (lnum > buf->b_ml.ml_line_count) {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    if (lnum > buf->b_ml.ml_line_count) {", "      eof = TRUE;", "      break;"], "readability/bool"]
["src/nvim/screen.c", ["", "    /* Remember the starting row of the line that is going to be dealt", "     * with.  It is used further down when the line doesn't fit. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "      /*", "       * When at start of changed lines: May scroll following lines"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "        /* Count the old number of window rows, using w_lines[], which", "         * should still contain the sizes for the lines as they are"], "readability/old_style_comment"]
["src/nvim/screen.c", ["         * currently displayed. */", "        for (i = idx; i < wp->w_lines_valid; ++i) {", "          /* Only valid lines have a meaningful wl_lnum.  Invalid"], "readability/increment"]
["src/nvim/screen.c", ["        for (i = idx; i < wp->w_lines_valid; ++i) {", "          /* Only valid lines have a meaningful wl_lnum.  Invalid", "           * lines are part of the changed area. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["           * lines are part of the changed area. */", "          if (wp->w_lines[i].wl_valid", "              && wp->w_lines[i].wl_lnum == mod_bot)"], "readability/braces"]
["src/nvim/screen.c", ["              && wp->w_lines[i].wl_lastlnum + 1 == mod_bot) {", "            /* Must have found the last valid entry above mod_bot.", "             * Add following invalid entries. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["             * Add following invalid entries. */", "            ++i;", "            while (i < wp->w_lines_valid"], "readability/increment"]
["src/nvim/screen.c", ["            ++i;", "            while (i < wp->w_lines_valid", "                   && !wp->w_lines[i].wl_valid)"], "readability/braces"]
["src/nvim/screen.c", ["        if (i >= wp->w_lines_valid) {", "          /* We can't find a valid line below the changed lines,", "           * need to redraw until the end of the window."], "readability/old_style_comment"]
["src/nvim/screen.c", ["        } else {", "          /* Able to count old number of rows: Count new window", "           * rows, and may insert/delete lines */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          if (xtra_rows < 0) {", "            /* May scroll text up.  If there is not enough", "             * remaining text or scrolling fails, must redraw the"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          } else if (xtra_rows > 0) {", "            /* May scroll text down.  If there is not enough", "             * remaining text of scrolling fails, must redraw the"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "          /* When not updating the rest, may need to move w_lines[]", "           * entries. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "              /* move entries in w_lines[] upwards */", "              for (;; ) {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["              for (;; ) {", "                /* stop at last valid entry in w_lines[] */", "                if (i >= wp->w_lines_valid) {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                wp->w_lines[j] = wp->w_lines[i];", "                /* stop at a line that won't fit */", "                if (x + (int)wp->w_lines[j].wl_size"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                x += wp->w_lines[j++].wl_size;", "                ++i;", "              }"], "readability/increment"]
["src/nvim/screen.c", ["              }", "              if (bot_start > x)", "                bot_start = x;"], "readability/braces"]
["src/nvim/screen.c", ["                bot_start = x;", "            } else {       /* j > i */", "                             /* move entries in w_lines[] downwards */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["            } else {       /* j > i */", "                             /* move entries in w_lines[] downwards */", "              j -= i;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "              /* The w_lines[] entries for inserted lines are", "               * now invalid, but wl_size may be used above."], "readability/old_style_comment"]
["src/nvim/screen.c", ["                wp->w_lines[i].wl_size = 0;", "                wp->w_lines[i--].wl_valid = FALSE;", "              }"], "readability/bool"]
["src/nvim/screen.c", ["", "      /*", "       * When lines are folded, display one line for all of them."], "readability/old_style_comment"]
["src/nvim/screen.c", ["        prepare_search_hl(wp, lnum);", "        /* Let the syntax stuff know we skipped a few lines. */", "        if (syntax_last_parsed != 0 && syntax_last_parsed + 1 < lnum"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        /* Let the syntax stuff know we skipped a few lines. */", "        if (syntax_last_parsed != 0 && syntax_last_parsed + 1 < lnum", "            && syntax_present(wp))"], "readability/braces"]
["src/nvim/screen.c", ["    if (lnum > buf->b_ml.ml_line_count) {", "      eof = TRUE;", "      break;"], "readability/bool"]
["src/nvim/screen.c", ["  }", "  /*", "   * End of loop over all window lines."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  if (idx > wp->w_lines_valid)", "    wp->w_lines_valid = idx;"], "readability/braces"]
["src/nvim/screen.c", ["", "  /*", "   * Let the syntax stuff know we stop parsing here."], "readability/old_style_comment"]
["src/nvim/screen.c", ["   */", "  if (syntax_last_parsed != 0 && syntax_present(wp))", "    syntax_end_parsing(syntax_last_parsed + 1);"], "readability/braces"]
["src/nvim/screen.c", ["", "  /*", "   * If we didn't hit the end of the file, and we didn't finish the last"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    if (lnum == wp->w_topline) {", "      /*", "       * Single line that does not fit!"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      }", "    } else if (dollar_vcol == -1)", "      wp->w_botline = lnum;"], "readability/braces"]
["src/nvim/screen.c", ["", "  /* Reset the type of redrawing required, the window has been updated. */", "  wp->w_redr_type = 0;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  if (dollar_vcol == -1) {", "    /*", "     * There is a trick with w_botline.  If we invalidate it on each"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* restore got_int, unless CTRL-C was hit while redrawing */", "  if (!got_int)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  /* restore got_int, unless CTRL-C was hit while redrawing */", "  if (!got_int)", "    got_int = save_got_int;"], "readability/braces"]
["src/nvim/screen.c", ["", "/*", " * Advance **color_cols and return TRUE when there are columns to draw."], "readability/old_style_comment"]
["src/nvim/screen.c", ["{", "  while (**color_cols >= 0 && vcol > **color_cols)", "    ++*color_cols;"], "readability/braces"]
["src/nvim/screen.c", ["  while (**color_cols >= 0 && vcol > **color_cols)", "    ++*color_cols;", "  return **color_cols >= 0;"], "readability/increment"]
["src/nvim/screen.c", ["", "  int n_attr = 0;                       /* chars with special attr */", "  int saved_attr2 = 0;                  /* char_attr saved for n_attr */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int n_attr = 0;                       /* chars with special attr */", "  int saved_attr2 = 0;                  /* char_attr saved for n_attr */", "  int n_attr3 = 0;                      /* chars with overruling special attr */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int saved_attr2 = 0;                  /* char_attr saved for n_attr */", "  int n_attr3 = 0;                      /* chars with overruling special attr */", "  int saved_attr3 = 0;                  /* char_attr saved for n_attr3 */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int n_attr3 = 0;                      /* chars with overruling special attr */", "  int saved_attr3 = 0;                  /* char_attr saved for n_attr3 */", ""], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  int n_skip = 0;                       /* nr of chars to skip for 'nowrap' */", ""], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  int char_attr = 0;                    /* attributes for next character */", "  int attr_pri = FALSE;                 /* char_attr has priority */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int char_attr = 0;                    /* attributes for next character */", "  int attr_pri = FALSE;                 /* char_attr has priority */", "  int area_highlighting = FALSE;           /* Visual or incsearch highlighting"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int char_attr = 0;                    /* attributes for next character */", "  int attr_pri = FALSE;                 /* char_attr has priority */", "  int area_highlighting = FALSE;           /* Visual or incsearch highlighting"], "readability/bool"]
["src/nvim/screen.c", ["  int attr_pri = FALSE;                 /* char_attr has priority */", "  int area_highlighting = FALSE;           /* Visual or incsearch highlighting", "                                              in this line */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["  int attr_pri = FALSE;                 /* char_attr has priority */", "  int area_highlighting = FALSE;           /* Visual or incsearch highlighting", "                                              in this line */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int attr_pri = FALSE;                 /* char_attr has priority */", "  int area_highlighting = FALSE;           /* Visual or incsearch highlighting", "                                              in this line */"], "readability/bool"]
["src/nvim/screen.c", ["                                              in this line */", "  int attr = 0;                         /* attributes for area highlighting */", "  int area_attr = 0;                    /* attributes desired by highlighting */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int attr = 0;                         /* attributes for area highlighting */", "  int area_attr = 0;                    /* attributes desired by highlighting */", "  int search_attr = 0;                  /* attributes desired by 'hlsearch' */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int area_attr = 0;                    /* attributes desired by highlighting */", "  int search_attr = 0;                  /* attributes desired by 'hlsearch' */", "  int vcol_save_attr = 0;               /* saved attr for 'cursorcolumn' */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int search_attr = 0;                  /* attributes desired by 'hlsearch' */", "  int vcol_save_attr = 0;               /* saved attr for 'cursorcolumn' */", "  int syntax_attr = 0;                  /* attributes desired by syntax */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int vcol_save_attr = 0;               /* saved attr for 'cursorcolumn' */", "  int syntax_attr = 0;                  /* attributes desired by syntax */", "  int has_syntax = FALSE;               /* this buffer has syntax highl. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int syntax_attr = 0;                  /* attributes desired by syntax */", "  int has_syntax = FALSE;               /* this buffer has syntax highl. */", "  int save_did_emsg;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int syntax_attr = 0;                  /* attributes desired by syntax */", "  int has_syntax = FALSE;               /* this buffer has syntax highl. */", "  int save_did_emsg;"], "readability/bool"]
["src/nvim/screen.c", ["# define SPWORDLEN 150", "  char_u nextline[SPWORDLEN * 2];       /* text with start of the next line */", "  int nextlinecol = 0;                  /* column where nextline[] starts */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  char_u nextline[SPWORDLEN * 2];       /* text with start of the next line */", "  int nextlinecol = 0;                  /* column where nextline[] starts */", "  int nextline_idx = 0;                 /* index in nextline[] where next line"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int nextlinecol = 0;                  /* column where nextline[] starts */", "  int nextline_idx = 0;                 /* index in nextline[] where next line", "                                           starts */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["  int nextlinecol = 0;                  /* column where nextline[] starts */", "  int nextline_idx = 0;                 /* index in nextline[] where next line", "                                           starts */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                                           starts */", "  int spell_attr = 0;                   /* attributes desired by spelling */", "  int word_end = 0;                     /* last byte with same spell_attr */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int spell_attr = 0;                   /* attributes desired by spelling */", "  int word_end = 0;                     /* last byte with same spell_attr */", "  static linenr_T checked_lnum = 0;     /* line number for \"checked_col\" */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int word_end = 0;                     /* last byte with same spell_attr */", "  static linenr_T checked_lnum = 0;     /* line number for \"checked_col\" */", "  static int checked_col = 0;           /* column in \"checked_lnum\" up to which"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  static linenr_T checked_lnum = 0;     /* line number for \"checked_col\" */", "  static int checked_col = 0;           /* column in \"checked_lnum\" up to which", "                                         * there are no spell errors */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["  static linenr_T checked_lnum = 0;     /* line number for \"checked_col\" */", "  static int checked_col = 0;           /* column in \"checked_lnum\" up to which", "                                         * there are no spell errors */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* draw_state: items that are drawn in sequence: */", "#define WL_START        0               /* nothing done yet */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  /* draw_state: items that are drawn in sequence: */", "#define WL_START        0               /* nothing done yet */", "# define WL_CMDLINE     WL_START + 1    /* cmdline window column */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["#define WL_START        0               /* nothing done yet */", "# define WL_CMDLINE     WL_START + 1    /* cmdline window column */", "# define WL_FOLD        WL_CMDLINE + 1  /* 'foldcolumn' */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["# define WL_CMDLINE     WL_START + 1    /* cmdline window column */", "# define WL_FOLD        WL_CMDLINE + 1  /* 'foldcolumn' */", "# define WL_SIGN        WL_FOLD + 1     /* column for signs */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["# define WL_FOLD        WL_CMDLINE + 1  /* 'foldcolumn' */", "# define WL_SIGN        WL_FOLD + 1     /* column for signs */", "#define WL_NR           WL_SIGN + 1     /* line number */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["# define WL_SIGN        WL_FOLD + 1     /* column for signs */", "#define WL_NR           WL_SIGN + 1     /* line number */", "# define WL_BRI         WL_NR + 1       /* 'breakindent' */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["#define WL_NR           WL_SIGN + 1     /* line number */", "# define WL_BRI         WL_NR + 1       /* 'breakindent' */", "# define WL_SBR         WL_BRI + 1       /* 'showbreak' or 'diff' */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["# define WL_BRI         WL_NR + 1       /* 'breakindent' */", "# define WL_SBR         WL_BRI + 1       /* 'showbreak' or 'diff' */", "#define WL_LINE         WL_SBR + 1      /* text in the line */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["# define WL_SBR         WL_BRI + 1       /* 'showbreak' or 'diff' */", "#define WL_LINE         WL_SBR + 1      /* text in the line */", "  int draw_state = WL_START;            /* what to draw next */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["#define WL_LINE         WL_SBR + 1      /* text in the line */", "  int draw_state = WL_START;            /* what to draw next */", ""], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  if (startrow > endrow)                /* past the end already! */", "    return startrow;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  if (startrow > endrow)                /* past the end already! */", "    return startrow;"], "readability/braces"]
["src/nvim/screen.c", ["    if (filler_lines == -1) {", "      if (diff_find_change(wp, lnum, &change_start, &change_end))", "        diff_hlf = HLF_ADD;             /* added line */"], "readability/braces"]
["src/nvim/screen.c", ["      if (diff_find_change(wp, lnum, &change_start, &change_end))", "        diff_hlf = HLF_ADD;             /* added line */", "      else if (change_start == 0)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        diff_hlf = HLF_ADD;             /* added line */", "      else if (change_start == 0)", "        diff_hlf = HLF_TXD;             /* changed text */"], "readability/braces"]
["src/nvim/screen.c", ["      else if (change_start == 0)", "        diff_hlf = HLF_TXD;             /* changed text */", "      else"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        diff_hlf = HLF_TXD;             /* changed text */", "      else", "        diff_hlf = HLF_CHD;             /* changed line */"], "readability/braces"]
["src/nvim/screen.c", ["      else", "        diff_hlf = HLF_CHD;             /* changed line */", "    } else"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        diff_hlf = HLF_CHD;             /* changed line */", "    } else", "      diff_hlf = HLF_ADD;               /* added line */"], "readability/braces"]
["src/nvim/screen.c", ["    } else", "      diff_hlf = HLF_ADD;               /* added line */", "    filler_lines = 0;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    filler_lines = 0;", "    area_highlighting = TRUE;", "  }"], "readability/bool"]
["src/nvim/screen.c", ["  }", "  if (lnum == wp->w_topline)", "    filler_lines = wp->w_topfill;"], "readability/braces"]
["src/nvim/screen.c", ["", "  line = ml_get_buf(wp->w_buffer, lnum, FALSE);", "  ptr = line;"], "readability/bool"]
["src/nvim/screen.c", ["", "    /* To be able to spell-check over line boundaries copy the end of the", "     * current line into nextline[].  Above the start of the next line was"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    if (nextline[SPWORDLEN] == NUL) {", "      /* No next line or it is empty. */", "      nextlinecol = MAXCOL;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      if (v < SPWORDLEN) {", "        /* Short line, use it completely and append the start of the", "         * next line. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      } else {", "        /* Long line, use only the last SPWORDLEN bytes. */", "        nextlinecol = v - SPWORDLEN;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      }", "      trailcol += (colnr_T) (ptr - line);", "    }"], "whitespace/cast"]
["src/nvim/screen.c", ["", "  /*", "   * 'nowrap' or 'wrap' and a single line that doesn't fit: Advance to the"], "readability/old_style_comment"]
["src/nvim/screen.c", ["   */", "  if (wp->w_p_wrap)", "    v = wp->w_skipcol;"], "readability/braces"]
["src/nvim/screen.c", ["    v = wp->w_skipcol;", "  else", "    v = wp->w_leftcol;"], "readability/braces"]
["src/nvim/screen.c", ["", "    /* Handle a character that's not completely on the screen: Put ptr at", "     * that character but skip the first few screen characters. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /*", "     * Adjust for when the inverted text is before the screen,"], "readability/old_style_comment"]
["src/nvim/screen.c", ["     */", "    if (tocol <= vcol)", "      fromcol = 0;"], "readability/braces"]
["src/nvim/screen.c", ["      fromcol = 0;", "    else if (fromcol >= 0 && fromcol < vcol)", "      fromcol = vcol;"], "readability/braces"]
["src/nvim/screen.c", ["      wp->w_cursor.col = linecol;", "      len = spell_move_to(wp, FORWARD, TRUE, TRUE, &spell_hlf);", ""], "readability/bool"]
["src/nvim/screen.c", ["", "      /* spell_move_to() may call ml_get() and make \"line\" invalid */", "      line = ml_get_buf(wp->w_buffer, lnum, FALSE);"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      /* spell_move_to() may call ml_get() and make \"line\" invalid */", "      line = ml_get_buf(wp->w_buffer, lnum, FALSE);", "      ptr = line + linecol;"], "readability/bool"]
["src/nvim/screen.c", ["      if (len == 0 || (int)wp->w_cursor.col > ptr - line) {", "        /* no bad word found at line start, don't check until end of a", "         * word */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      } else {", "        /* bad word found, use attributes until end of word */", "        assert(len <= INT_MAX);"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "        /* Turn index into actual attributes. */", "        if (spell_hlf != HLF_COUNT)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        /* Turn index into actual attributes. */", "        if (spell_hlf != HLF_COUNT)", "          spell_attr = highlight_attr[spell_hlf];"], "readability/braces"]
["src/nvim/screen.c", ["", "  /*", "   * Correct highlighting for cursor that can't be disabled."], "readability/old_style_comment"]
["src/nvim/screen.c", ["      if ((colnr_T)fromcol == wp->w_virtcol) {", "        /* highlighting starts at cursor, let it start just after the", "         * cursor */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        fromcol = -1;", "      } else if ((colnr_T)fromcol < wp->w_virtcol)", "        /* restart highlighting after the cursor */"], "readability/braces"]
["src/nvim/screen.c", ["      } else if ((colnr_T)fromcol < wp->w_virtcol)", "        /* restart highlighting after the cursor */", "        fromcol_prev = wp->w_virtcol;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    }", "    if (fromcol >= tocol)", "      fromcol = -1;"], "readability/braces"]
["src/nvim/screen.c", ["", "  /*", "   * Handle highlighting the last used search pattern and matches."], "readability/old_style_comment"]
["src/nvim/screen.c", ["      if (lnum == shl->lnum + shl->rm.endpos[0].lnum", "                  - shl->rm.startpos[0].lnum) {", "          shl->endcol = shl->rm.endpos[0].col;"], "whitespace/alignment"]
["src/nvim/screen.c", ["          } else {", "              ++shl->endcol;", "          }"], "readability/increment"]
["src/nvim/screen.c", ["    }", "    if (shl != &search_hl && cur != NULL)", "      cur = cur->next;"], "readability/braces"]
["src/nvim/screen.c", ["        if (cmdwin_type != 0 && wp == curwin) {", "          /* Draw the cmdline character. */", "          n_extra = 1;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          draw_state = WL_SIGN;", "          /* Show the sign column when there are any signs in this", "           * buffer or when using Netbeans. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        draw_state = WL_NR;", "        /* Display the absolute or relative line number. After the", "         * first fill with blanks when the 'n' flag isn't in 'cpo' */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        if (*p_sbr != NUL && need_showbreak) {", "          /* Draw 'showbreak' at the start of each broken line. */", "          p_extra = p_sbr;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          vcol_sbr = vcol + MB_CHARLEN(p_sbr);", "          /* Correct end of highlighted area for 'showbreak',", "           * required when 'linebreak' is also set. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["           * required when 'linebreak' is also set. */", "          if (tocol == vcol)", "            tocol += n_extra;"], "readability/braces"]
["src/nvim/screen.c", ["        if (saved_n_extra) {", "          /* Continue item from end of wrapped line. */", "          n_extra = saved_n_extra;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      if (!n_extra) {", "        /*", "         * Check for start/end of search pattern match."], "readability/old_style_comment"]
["src/nvim/screen.c", ["          }", "          bool pos_inprogress = true; // mark that a position match search is", "                                      // in progress"], "whitespace/comments"]
["src/nvim/screen.c", ["          while (shl->rm.regprog != NULL", "                                 || (cur != NULL && pos_inprogress)) {", "            if (shl->startcol != MAXCOL"], "whitespace/alignment"]
["src/nvim/screen.c", ["", "              /* Need to get the line again, a multi-line regexp", "               * may have made it invalid. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["               * may have made it invalid. */", "              line = ml_get_buf(wp->w_buffer, lnum, FALSE);", "              ptr = line + v;"], "readability/bool"]
["src/nvim/screen.c", ["                shl->startcol = shl->rm.startpos[0].col;", "                if (shl->rm.endpos[0].lnum == 0)", "                  shl->endcol = shl->rm.endpos[0].col;"], "readability/braces"]
["src/nvim/screen.c", ["                  shl->endcol = shl->rm.endpos[0].col;", "                else", "                  shl->endcol = MAXCOL;"], "readability/braces"]
["src/nvim/screen.c", ["          }", "          if (shl != &search_hl && cur != NULL)", "            cur = cur->next;"], "readability/braces"]
["src/nvim/screen.c", ["", "        /* Use attributes from match with highest priority among", "         * 'search_hl' and the match list. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          }", "          if (shl != &search_hl && cur != NULL)", "            cur = cur->next;"], "readability/braces"]
["src/nvim/screen.c", ["      // (area_attr may be 0 when \"noinvcur\" is set).", "      else if (line_attr != 0 && ((fromcol == -10 && tocol == MAXCOL)", "                                  || vcol < fromcol || vcol_prev < fromcol_prev"], "whitespace/newline"]
["src/nvim/screen.c", ["", "        /* Get syntax attribute, unless still at the start of the line", "         * (double-wide char that doesn't fit). */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        if (has_syntax && v > 0) {", "          /* Get the syntax attribute for the character.  If there", "           * is an error, disable syntax highlighting. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          save_did_emsg = did_emsg;", "          did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/screen.c", ["          if (did_emsg) {", "            wp->w_s->b_syn_error = TRUE;", "            has_syntax = FALSE;"], "readability/bool"]
["src/nvim/screen.c", ["            wp->w_s->b_syn_error = TRUE;", "            has_syntax = FALSE;", "          } else"], "readability/bool"]
["src/nvim/screen.c", ["            has_syntax = FALSE;", "          } else", "            did_emsg = save_did_emsg;"], "readability/braces"]
["src/nvim/screen.c", ["", "          /* Need to get the line again, a multi-line regexp may", "           * have made it invalid. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["           * have made it invalid. */", "          line = ml_get_buf(wp->w_buffer, lnum, FALSE);", "          ptr = line + v;"], "readability/bool"]
["src/nvim/screen.c", ["", "        /* Check spelling (unless at the end of the line).", "         * Only do this when there is no syntax highlighting, the"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "            /* Use nextline[] if possible, it has the start of the", "             * next line concatenated. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "            /* In Insert mode only highlight a word that", "             * doesn't touch the cursor. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                && (p - nextline) + len > nextline_idx) {", "              /* Remember that the good word continues at the", "               * start of the next line. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "            /* Turn index into actual attributes. */", "            if (spell_hlf != HLF_COUNT)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["            /* Turn index into actual attributes. */", "            if (spell_hlf != HLF_COUNT)", "              spell_attr = highlight_attr[spell_hlf];"], "readability/braces"]
["src/nvim/screen.c", ["                  && (p - nextline) + cap_col >= nextline_idx) {", "                /* Remember that the word in the next line", "                 * must start with a capital. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                                - nextline_idx);", "              } else", "                /* Compute the actual column. */"], "readability/braces"]
["src/nvim/screen.c", ["              } else", "                /* Compute the actual column. */", "                cap_col += (int)(prev_ptr - line);"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        if (spell_attr != 0) {", "          if (!attr_pri)", "            char_attr = hl_combine_attr(char_attr, spell_attr);"], "readability/braces"]
["src/nvim/screen.c", ["            char_attr = hl_combine_attr(char_attr, spell_attr);", "          else", "            char_attr = hl_combine_attr(spell_attr, char_attr);"], "readability/braces"]
["src/nvim/screen.c", ["          char_u *p = ptr - (mb_off + 1);", "          // TODO: is passing p for start of the line OK?", "          n_extra = win_lbr_chartabsize(wp, line, p, (colnr_T)vcol, NULL) - 1;"], "readability/todo"]
["src/nvim/screen.c", ["          if (ascii_iswhite(c)) {", "            if (c == TAB)", "              /* See \"Tab alignment\" below. */"], "readability/braces"]
["src/nvim/screen.c", ["            if (c == TAB)", "              /* See \"Tab alignment\" below. */", "              FIX_FOR_BOGUSCOLS;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "      /*", "       * Handling of non-printable characters."], "readability/old_style_comment"]
["src/nvim/screen.c", ["            if (wp->w_p_lbr) {", "              c_extra = NUL; /* using p_extra from above */", "            } else {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          }", "          if ((dy_flags & DY_UHEX) && wp->w_p_rl)", "            rl_mirror(p_extra);                 /* reverse \"<12>\" */"], "readability/braces"]
["src/nvim/screen.c", ["          if ((dy_flags & DY_UHEX) && wp->w_p_rl)", "            rl_mirror(p_extra);                 /* reverse \"<12>\" */", "          c_extra = NUL;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["            memset(p, ' ', n_extra);", "            STRNCPY(p, p_extra + 1, STRLEN(p_extra) - 1);", "            p[n_extra] = NUL;"], "runtime/printf"]
["src/nvim/screen.c", ["", "          if (n_extra > 0)", "            vcol_off += n_extra;"], "readability/braces"]
["src/nvim/screen.c", ["        } else if (n_skip == 0) {", "          is_concealing = TRUE;", "          n_skip = 1;"], "readability/bool"]
["src/nvim/screen.c", ["        prev_syntax_id = 0;", "        is_concealing = FALSE;", "      }"], "readability/bool"]
["src/nvim/screen.c", ["", "    /* In the cursor line and we may be concealing characters: correct", "     * the cursor column when we reach its position. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        if (wp->w_p_rl) {", "          if (col < 0)", "            n = 1;"], "readability/braces"]
["src/nvim/screen.c", ["        if (n != 0) {", "          /* At the window boundary, highlight the last character", "           * instead (better than nothing). */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        if (wp->w_p_rl) {", "          --col;", "          --off;"], "readability/increment"]
["src/nvim/screen.c", ["          --col;", "          --off;", "        } else {"], "readability/increment"]
["src/nvim/screen.c", ["        } else {", "          ++col;", "          ++off;"], "readability/increment"]
["src/nvim/screen.c", ["          ++col;", "          ++off;", "        }"], "readability/increment"]
["src/nvim/screen.c", ["        }", "        ++vcol;", "        eol_hl_off = 1;"], "readability/increment"]
["src/nvim/screen.c", ["", "      /* check if line ends before left margin */", "      if (vcol < v + col - win_col_off(wp))"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      /* check if line ends before left margin */", "      if (vcol < v + col - win_col_off(wp))", "        vcol = v + col - win_col_off(wp);"], "readability/braces"]
["src/nvim/screen.c", ["", "      if (draw_color_col)", "        draw_color_col = advance_color_col(VCOL_HLC, &color_cols);"], "readability/braces"]
["src/nvim/screen.c", ["", "      /*", "       * Update w_cline_height and w_cline_folded if the cursor line was"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        if (wp->w_p_rl) {", "          /* now it's time to backup one cell */", "          --off;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          /* now it's time to backup one cell */", "          --off;", "          --col;"], "readability/increment"]
["src/nvim/screen.c", ["          --off;", "          --col;", "        }"], "readability/increment"]
["src/nvim/screen.c", ["      if (wp->w_p_rl) {", "        --off;", "        --col;"], "readability/increment"]
["src/nvim/screen.c", ["        --off;", "        --col;", "      } else {"], "readability/increment"]
["src/nvim/screen.c", ["      } else {", "        ++off;", "        ++col;"], "readability/increment"]
["src/nvim/screen.c", ["        ++off;", "        ++col;", "      }"], "readability/increment"]
["src/nvim/screen.c", ["    } else if (wp->w_p_cole > 0 && is_concealing) {", "      --n_skip;", "      ++vcol_off;"], "readability/increment"]
["src/nvim/screen.c", ["      --n_skip;", "      ++vcol_off;", "      if (n_extra > 0)"], "readability/increment"]
["src/nvim/screen.c", ["      ++vcol_off;", "      if (n_extra > 0)", "        vcol_off += n_extra;"], "readability/braces"]
["src/nvim/screen.c", ["      if (wp->w_p_wrap) {", "        /*", "         * Special voodoo required if 'wrap' is on."], "readability/old_style_comment"]
["src/nvim/screen.c", ["          if (wp->w_p_rl) {", "            --boguscols;", "            --col;"], "readability/increment"]
["src/nvim/screen.c", ["            --boguscols;", "            --col;", "          } else {"], "readability/increment"]
["src/nvim/screen.c", ["          } else {", "            ++boguscols;", "            ++col;"], "readability/increment"]
["src/nvim/screen.c", ["            ++boguscols;", "            ++col;", "          }"], "readability/increment"]
["src/nvim/screen.c", ["        if (wp->w_p_rl) {", "          --boguscols;", "          --col;"], "readability/increment"]
["src/nvim/screen.c", ["          --boguscols;", "          --col;", "        } else {"], "readability/increment"]
["src/nvim/screen.c", ["        } else {", "          ++boguscols;", "          ++col;"], "readability/increment"]
["src/nvim/screen.c", ["          ++boguscols;", "          ++col;", "        }"], "readability/increment"]
["src/nvim/screen.c", ["      }", "", "    } else"], "whitespace/blank_line"]
["src/nvim/screen.c", ["", "    } else", "      --n_skip;"], "readability/braces"]
["src/nvim/screen.c", ["    } else", "      --n_skip;", ""], "readability/increment"]
["src/nvim/screen.c", ["", "    /* Only advance the \"vcol\" when after the 'number' or 'relativenumber'", "     * column. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["     * column. */", "    if (draw_state > WL_NR", "        && filler_todo <= 0"], "readability/braces"]
["src/nvim/screen.c", ["        )", "      ++vcol;", ""], "readability/increment"]
["src/nvim/screen.c", ["", "    if (vcol_save_attr >= 0)", "      char_attr = vcol_save_attr;"], "readability/braces"]
["src/nvim/screen.c", ["", "    /* restore attributes after \"predeces\" in 'listchars' */", "    if (draw_state > WL_NR && n_attr3 > 0 && --n_attr3 == 0)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    /* restore attributes after \"predeces\" in 'listchars' */", "    if (draw_state > WL_NR && n_attr3 > 0 && --n_attr3 == 0)", "      char_attr = saved_attr3;"], "readability/braces"]
["src/nvim/screen.c", ["", "    /* restore attributes after last 'listchars' or 'number' char */", "    if (n_attr > 0 && draw_state == WL_LINE && --n_attr == 0)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    /* restore attributes after last 'listchars' or 'number' char */", "    if (n_attr > 0 && draw_state == WL_LINE && --n_attr == 0)", "      char_attr = saved_attr2;"], "readability/braces"]
["src/nvim/screen.c", ["", "    /*", "     * At end of screen line and there is more to come: Display the line"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "      /* When not wrapping and finished diff lines, or when displayed", "       * '$' and highlighting until last column, break here. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["       * '$' and highlighting until last column, break here. */", "      if ((!wp->w_p_wrap", "           && filler_todo <= 0"], "readability/braces"]
["src/nvim/screen.c", ["           && filler_todo <= 0", "           ) || lcs_eol_one == -1)", "        break;"], "whitespace/parens"]
["src/nvim/screen.c", ["", "      /* When line got too long for screen break here. */", "      if (row == endrow) {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      if (row == endrow) {", "        ++row;", "        break;"], "readability/increment"]
["src/nvim/screen.c", ["", "      /* reset the drawing state for the start of a wrapped line */", "      draw_state = WL_START;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    }", "", "  }     /* for every character in the line */"], "whitespace/blank_line"]
["src/nvim/screen.c", ["", "  }     /* for every character in the line */", ""], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* After an empty line check first word for capital. */", "  if (*skipwhite(line) == NUL) {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  return row;", "}", ""], "readability/fn_size"]
["src/nvim/screen.c", ["", "/*", " * Check whether the given character needs redrawing:"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  if (rlflag) {", "    /* Clear rest first, because it's left of the text. */", "    if (clear_width > 0) {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["             ) {", "        ++off_to;", "        ++col;"], "readability/increment"]
["src/nvim/screen.c", ["        ++off_to;", "        ++col;", "      }"], "readability/increment"]
["src/nvim/screen.c", ["  if (clear_next) {", "    /* Clear the second half of a double-wide character of which the left", "     * half was overwritten with a single-wide character. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Mirror text \"str\" for right-left displaying."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  for (p1 = str, p2 = str + STRLEN(str) - 1; p1 < p2; ++p1, --p2) {", "    t = *p1;"], "readability/increment"]
["src/nvim/screen.c", ["", "/*", " * mark all status lines for redraw; used after first :cd"], "readability/old_style_comment"]
["src/nvim/screen.c", ["{", "", "  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {"], "whitespace/blank_line"]
["src/nvim/screen.c", ["", "/*", " * Redraw all status lines that need to be redrawn."], "readability/old_style_comment"]
["src/nvim/screen.c", ["  }", "  if (redraw_tabline)", "    draw_tabline();"], "readability/braces"]
["src/nvim/screen.c", ["", "/*", " * Redraw all status lines at the bottom of frame \"frp\"."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Draw the verticap separator right of window \"wp\" starting with line \"row\"."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Get the length of an item as it will be shown in the status line."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* Check for menu separators - replace with '|'. */", "  if (emenu && menu_is_separator(s))"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  /* Check for menu separators - replace with '|'. */", "  if (emenu && menu_is_separator(s))", "    return 1;"], "readability/braces"]
["src/nvim/screen.c", ["", "/*", " * Return the number of characters that should be skipped in a status match."], "readability/old_style_comment"]
["src/nvim/screen.c", ["#ifndef BACKSLASH_IN_FILENAME", "    if (xp->xp_shell && csh_like_shell() && s[1] == '\\\\' && s[2] == '!')", "      return 2;"], "readability/braces"]
["src/nvim/screen.c", ["", "/*", " * Show wildchar matches in the status line."], "readability/old_style_comment"]
["src/nvim/screen.c", ["void", "win_redr_status_matches (", "    expand_T *xp,"], "whitespace/parens"]
["src/nvim/screen.c", ["    int num_matches,", "    char_u **matches,          /* list of matches */", "    int match,"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int len;", "  int clen;                     /* length in screen cells */", "  int fillchar;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int i;", "  int highlight = TRUE;", "  char_u      *selstart = NULL;"], "readability/bool"]
["src/nvim/screen.c", ["  static int first_match = 0;", "  int add_left = FALSE;", "  char_u      *s;"], "readability/bool"]
["src/nvim/screen.c", ["", "  if (matches == NULL)          /* interrupted completion? */", "    return;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  if (matches == NULL)          /* interrupted completion? */", "    return;"], "readability/braces"]
["src/nvim/screen.c", ["", "  if (match == -1) {    /* don't show match but original text */", "    match = 0;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    match = 0;", "    highlight = FALSE;", "  }"], "readability/bool"]
["src/nvim/screen.c", ["  }", "  /* count 1 for the ending \">\" */", "  clen = status_match_len(xp, L_MATCH(match)) + 3;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  clen = status_match_len(xp, L_MATCH(match)) + 3;", "  if (match == 0)", "    first_match = 0;"], "readability/braces"]
["src/nvim/screen.c", ["    first_match = 0;", "  else if (match < first_match) {", "    /* jumping left, as far as we can go */"], "readability/braces"]
["src/nvim/screen.c", ["  else if (match < first_match) {", "    /* jumping left, as far as we can go */", "    first_match = match;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    first_match = match;", "    add_left = TRUE;", "  } else {"], "readability/bool"]
["src/nvim/screen.c", ["  } else {", "    /* check if match fits on the screen */", "    for (i = first_match; i < match; ++i)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    /* check if match fits on the screen */", "    for (i = first_match; i < match; ++i)", "      clen += status_match_len(xp, L_MATCH(i)) + 2;"], "readability/braces"]
["src/nvim/screen.c", ["    /* check if match fits on the screen */", "    for (i = first_match; i < match; ++i)", "      clen += status_match_len(xp, L_MATCH(i)) + 2;"], "readability/increment"]
["src/nvim/screen.c", ["      clen += status_match_len(xp, L_MATCH(i)) + 2;", "    if (first_match > 0)", "      clen += 2;"], "readability/braces"]
["src/nvim/screen.c", ["      first_match = match;", "      /* if showing the last match, we can add some on the left */", "      clen = 2;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      clen = 2;", "      for (i = match; i < num_matches; ++i) {", "        clen += status_match_len(xp, L_MATCH(i)) + 2;"], "readability/increment"]
["src/nvim/screen.c", ["      }", "      if (i == num_matches)", "        add_left = TRUE;"], "readability/braces"]
["src/nvim/screen.c", ["      if (i == num_matches)", "        add_left = TRUE;", "    }"], "readability/bool"]
["src/nvim/screen.c", ["  }", "  if (add_left)", "    while (first_match > 0) {"], "readability/braces"]
["src/nvim/screen.c", ["    s = L_MATCH(i);", "    /* Check for menu separators - replace with '|' */", "    emenu = (xp->xp_context == EXPAND_MENUS"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      clen += l;", "    } else", "      for (; *s != NUL; ++s) {"], "readability/braces"]
["src/nvim/screen.c", ["    } else", "      for (; *s != NUL; ++s) {", "        s += skip_status_match_char(xp, s);"], "readability/increment"]
["src/nvim/screen.c", ["      }", "    if (i == match)", "      selend = buf + len;"], "readability/braces"]
["src/nvim/screen.c", ["    clen += 2;", "    if (++i == num_matches)", "      break;"], "readability/braces"]
["src/nvim/screen.c", ["    *(buf + len++) = '>';", "    ++clen;", "  }"], "readability/increment"]
["src/nvim/screen.c", ["      if (msg_scrolled > 0) {", "        /* Put the wildmenu just above the command line.  If there is", "         * no room, scroll the screen one line up. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      } else {", "        /* Create status line if needed by setting 'laststatus' to 2.", "         * Set 'winminheight' to zero to avoid that the window is"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          p_wmh = 0;", "          last_status(FALSE);", "        }"], "readability/bool"]
["src/nvim/screen.c", ["  int this_ru_col;", "  static int busy = FALSE;", ""], "readability/bool"]
["src/nvim/screen.c", ["", "  wp->w_redr_status = FALSE;", "  if (wp->w_status_height == 0) {"], "readability/bool"]
["src/nvim/screen.c", ["  } else if (*p_stl != NUL || *wp->w_p_stl != NUL) {", "    /* redraw custom status line */", "    redraw_custom_statusline(wp);"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        *p = '<';", "        ++len;", "      }"], "readability/increment"]
["src/nvim/screen.c", ["", "    if (get_keymap_str(wp, (char_u *)\"<%s>\", NameBuff, MAXPATHL)", "        && this_ru_col - len > (int)(STRLEN(NameBuff) + 1))"], "readability/braces"]
["src/nvim/screen.c", ["", "    win_redr_ruler(wp, TRUE);", "  }"], "readability/bool"]
["src/nvim/screen.c", ["", "  /*", "   * May need to draw the character below the vertical separator."], "readability/old_style_comment"]
["src/nvim/screen.c", ["  }", "  busy = FALSE;", "}"], "readability/bool"]
["src/nvim/screen.c", ["", "/*", " * Redraw the status line according to 'statusline' and take care of any"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* When called recursively return.  This can happen when the statusline", "   * contains an expression that triggers a redraw. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["   * contains an expression that triggers a redraw. */", "  if (entered)", "    return;"], "readability/braces"]
["src/nvim/screen.c", ["    return;", "  entered = TRUE;", ""], "readability/bool"]
["src/nvim/screen.c", ["", "/*", " * Return TRUE if the status line of window \"wp\" is connected to the status"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    if (fr->fr_parent->fr_layout == FR_COL) {", "      if (fr->fr_next != NULL)", "        break;"], "readability/braces"]
["src/nvim/screen.c", ["    } else {", "      if (fr->fr_next != NULL)", "        return TRUE;"], "readability/braces"]
["src/nvim/screen.c", ["      if (fr->fr_next != NULL)", "        return TRUE;", "    }"], "readability/bool"]
["src/nvim/screen.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/screen.c", ["", "/*", " * Get the value to show for the language mappings, active 'keymap'."], "readability/old_style_comment"]
["src/nvim/screen.c", ["int", "get_keymap_str (", "    win_T *wp,"], "whitespace/parens"]
["src/nvim/screen.c", ["", "  if (wp->w_buffer->b_p_iminsert != B_IMODE_LMAP)", "    return FALSE;"], "readability/braces"]
["src/nvim/screen.c", ["  if (wp->w_buffer->b_p_iminsert != B_IMODE_LMAP)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/screen.c", ["    curwin = wp;", "    STRCPY(buf, \"b:keymap_name\");       /* must be writable */", "    ++emsg_skip;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    STRCPY(buf, \"b:keymap_name\");       /* must be writable */", "    ++emsg_skip;", "    s = p = eval_to_string(buf, NULL, FALSE);"], "readability/increment"]
["src/nvim/screen.c", ["    ++emsg_skip;", "    s = p = eval_to_string(buf, NULL, FALSE);", "    --emsg_skip;"], "readability/bool"]
["src/nvim/screen.c", ["    s = p = eval_to_string(buf, NULL, FALSE);", "    --emsg_skip;", "    curbuf = old_curbuf;"], "readability/increment"]
["src/nvim/screen.c", ["", "/*", " * Redraw the status line or ruler of window \"wp\"."], "readability/old_style_comment"]
["src/nvim/screen.c", ["static void", "win_redr_custom (", "    win_T *wp,"], "whitespace/parens"]
["src/nvim/screen.c", ["{", "  static int entered = FALSE;", "  int attr;"], "readability/bool"]
["src/nvim/screen.c", ["", "  /* There is a tiny chance that this gets called recursively: When", "   * redrawing a status line triggers redrawing the ruler or tabline."], "readability/old_style_comment"]
["src/nvim/screen.c", ["   * Avoid trouble by not allowing recursion. */", "  if (entered)", "    return;"], "readability/braces"]
["src/nvim/screen.c", ["    return;", "  entered = TRUE;", ""], "readability/bool"]
["src/nvim/screen.c", ["", "  /* setup environment for the task at hand */", "  if (wp == NULL) {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  if (wp == NULL) {", "    /* Use 'tabline'.  Always at the first line of the screen. */", "    stl = p_tal;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      stl = p_ruf;", "      /* advance past any leading group spec - implicit in ru_col */", "      if (*stl == '%') {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      if (*stl == '%') {", "        if (*++stl == '-')", "          stl++;"], "readability/braces"]
["src/nvim/screen.c", ["          stl++;", "        if (atoi((char *)stl))", "          while (ascii_isdigit(*stl))"], "readability/braces"]
["src/nvim/screen.c", ["        if (atoi((char *)stl))", "          while (ascii_isdigit(*stl))", "            stl++;"], "readability/braces"]
["src/nvim/screen.c", ["            stl++;", "        if (*stl++ != '(')", "          stl = p_ruf;"], "readability/braces"]
["src/nvim/screen.c", ["    } else {", "      if (*wp->w_p_stl != NUL)", "        stl = wp->w_p_stl;"], "readability/braces"]
["src/nvim/screen.c", ["        stl = wp->w_p_stl;", "      else", "        stl = p_stl;"], "readability/braces"]
["src/nvim/screen.c", ["", "  if (maxwidth <= 0)", "    goto theend;"], "readability/braces"]
["src/nvim/screen.c", ["", "  /* Temporarily reset 'cursorbind', we don't want a side effect from moving", "   * the cursor away and back. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  p_crb_save = ewp->w_p_crb;", "  ewp->w_p_crb = FALSE;", ""], "readability/bool"]
["src/nvim/screen.c", ["", "  /* Make a copy, because the statusline may include a function call that", "   * might change the option value and free the memory. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* fill up with \"fillchar\" */", "  while (width < maxwidth && len < (int)sizeof(buf) - 1) {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * Draw each snippet with the specified highlighting."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    if (hltab[n].userhl == 0)", "      curattr = attr;"], "readability/braces"]
["src/nvim/screen.c", ["      curattr = attr;", "    else if (hltab[n].userhl < 0)", "      curattr = syn_id2attr(-hltab[n].userhl);"], "readability/braces"]
["src/nvim/screen.c", ["      curattr = syn_id2attr(-hltab[n].userhl);", "    else if (wp != NULL && wp != curwin && wp->w_status_height != 0)", "      curattr = highlight_stlnc[hltab[n].userhl - 1];"], "readability/braces"]
["src/nvim/screen.c", ["      curattr = highlight_stlnc[hltab[n].userhl - 1];", "    else", "      curattr = highlight_user[hltab[n].userhl - 1];"], "readability/braces"]
["src/nvim/screen.c", ["    for (n = 0; tabtab[n].start != NULL; n++) {", "      len += vim_strnsize(p, (int)(tabtab[n].start - (char *) p));", "      while (col < len) {"], "whitespace/cast"]
["src/nvim/screen.c", ["      }", "      p = (char_u *) tabtab[n].start;", "      cur_click_def = tabtab[n].def;"], "whitespace/cast"]
["src/nvim/screen.c", ["theend:", "  entered = FALSE;", "}"], "readability/bool"]
["src/nvim/screen.c", ["  int u8cc[MAX_MCO];", "  int clear_next_cell = FALSE;", "  int prev_c = 0;                       /* previous Arabic character */"], "readability/bool"]
["src/nvim/screen.c", ["  int clear_next_cell = FALSE;", "  int prev_c = 0;                       /* previous Arabic character */", "  int pc, nc, nc1;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* When drawing over the right halve of a double-wide char clear out the", "   * left halve.  Only needed in a terminal. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Prepare for 'hlsearch' highlighting."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Clean up for 'hlsearch' highlighting."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Init for calling prepare_search_hl()."], "readability/old_style_comment"]
["src/nvim/screen.c", ["    cur->hl.rm = cur->match;", "    if (cur->hlg_id == 0)", "      cur->hl.attr = 0;"], "readability/braces"]
["src/nvim/screen.c", ["      cur->hl.attr = 0;", "    else", "      cur->hl.attr = syn_id2attr(cur->hlg_id);"], "readability/braces"]
["src/nvim/screen.c", ["", "/*", " * Advance to the match in window \"wp\" line \"lnum\" or past it."], "readability/old_style_comment"]
["src/nvim/screen.c", ["      }", "      bool pos_inprogress = true; // mark that a position match search is", "                                  // in progress"], "whitespace/comments"]
["src/nvim/screen.c", ["        } else {", "          ++shl->first_lnum;", "          n = 0;"], "readability/increment"]
["src/nvim/screen.c", ["    }", "    if (shl != &search_hl && cur != NULL)", "      cur = cur->next;"], "readability/braces"]
["src/nvim/screen.c", ["", "/*", " * Search for a next 'hlsearch' or match."], "readability/old_style_comment"]
["src/nvim/screen.c", ["static void", "next_search_hl (", "    win_T *win,"], "whitespace/parens"]
["src/nvim/screen.c", ["    win_T *win,", "    match_T *shl,               /* points to search_hl or a match */", "    linenr_T lnum,"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    linenr_T lnum,", "    colnr_T mincol,                /* minimal column for a match */", "    matchitem_T *cur               /* to retrieve match positions if any */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    colnr_T mincol,                /* minimal column for a match */", "    matchitem_T *cur               /* to retrieve match positions if any */", ")"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    l = shl->lnum + shl->rm.endpos[0].lnum - shl->rm.startpos[0].lnum;", "    if (lnum > l)", "      shl->lnum = 0;"], "readability/braces"]
["src/nvim/screen.c", ["      shl->lnum = 0;", "    else if (lnum < l || shl->rm.endpos[0].col > mincol)", "      return;"], "readability/braces"]
["src/nvim/screen.c", ["", "  /*", "   * Repeat searching for a match until one is found that includes \"mincol\""], "readability/old_style_comment"]
["src/nvim/screen.c", ["   */", "  called_emsg = FALSE;", "  for (;; ) {"], "readability/bool"]
["src/nvim/screen.c", ["    if (profile_passed_limit(shl->tm)) {", "      shl->lnum = 0;                    /* no match found in time */", "      break;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      matchcol = shl->rm.startpos[0].col;", "      ml = ml_get_buf(shl->buf, lnum, FALSE) + matchcol;", "      if (*ml == NUL) {"], "readability/bool"]
["src/nvim/screen.c", ["      if (*ml == NUL) {", "        ++matchcol;", "        shl->lnum = 0;"], "readability/increment"]
["src/nvim/screen.c", ["        shl->lnum = 0;", "        got_int = FALSE; // avoid the \"Type :quit to exit Vim\" message", "        break;"], "whitespace/comments"]
["src/nvim/screen.c", ["        shl->lnum = 0;", "        got_int = FALSE; // avoid the \"Type :quit to exit Vim\" message", "        break;"], "readability/bool"]
["src/nvim/screen.c", ["    linenr_T lnum,", "    posmatch_T *posmatch, // match positions", "    colnr_T mincol        // minimal column for a match"], "whitespace/comments"]
["src/nvim/screen.c", ["", "/*", " * Check if there should be a delay.  Used before clearing or redrawing the"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * Note that the window sizes are updated before reallocating the arrays,"], "readability/old_style_comment"]
["src/nvim/screen.c", ["   */", "  ++RedrawingDisabled;", ""], "readability/increment"]
["src/nvim/screen.c", ["", "  win_new_shellsize();      /* fit the windows in the new sized shell */", ""], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  comp_col();           /* recompute columns for shown command and ruler */", ""], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * Do not apply autocommands more than 3 times to avoid an endless loop"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  if (starting == 0 && ++retry_count <= 3) {", "    apply_autocmds(EVENT_VIMRESIZED, NULL, NULL, FALSE, curbuf);", "    /* In rare cases, autocommands may have altered Rows or Columns,"], "readability/bool"]
["src/nvim/screen.c", ["    apply_autocmds(EVENT_VIMRESIZED, NULL, NULL, FALSE, curbuf);", "    /* In rare cases, autocommands may have altered Rows or Columns,", "    * jump back to check if we need to allocate the screen again. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    }", "    memset(tpcd, 0, (size_t) tpcd_size * sizeof(tpcd[0]));", "  }"], "whitespace/cast"]
["src/nvim/screen.c", ["", "/*", " * Set cursor to its position in the current window."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * The rest of the routines in this file perform screen manipulations. The"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    if (!redrawing() || (char_avail() && !KeyTyped) || msg_silent != 0) {", "      redraw_cmdline = TRUE;                    /* show mode later */", "      return 0;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    if (!redrawing() || (char_avail() && !KeyTyped) || msg_silent != 0) {", "      redraw_cmdline = TRUE;                    /* show mode later */", "      return 0;"], "readability/bool"]
["src/nvim/screen.c", ["", "    /* wait a bit before overwriting an important message */", "    check_for_delay(FALSE);"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    /* wait a bit before overwriting an important message */", "    check_for_delay(FALSE);", ""], "readability/bool"]
["src/nvim/screen.c", ["", "    /* if the cmdline is more than one line high, erase top lines */", "    need_clear = clear_cmdline;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /* Position on the last line in the window, column 0 */", "    msg_pos_mode();"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        if (length > 0) {", "          if (edit_submode_pre != NULL)", "            length -= vim_strsize(edit_submode_pre);"], "readability/braces"]
["src/nvim/screen.c", ["          MSG_PUTS_ATTR(_(\" TERMINAL\"), attr);", "        } else if (State & VREPLACE_FLAG)", "          MSG_PUTS_ATTR(_(\" VREPLACE\"), attr);"], "readability/braces"]
["src/nvim/screen.c", ["          MSG_PUTS_ATTR(_(\" VREPLACE\"), attr);", "        else if (State & REPLACE_FLAG)", "          MSG_PUTS_ATTR(_(\" REPLACE\"), attr);"], "readability/braces"]
["src/nvim/screen.c", ["          MSG_PUTS_ATTR(_(\" REPLACE\"), attr);", "        else if (State & INSERT) {", "          if (p_ri)"], "readability/braces"]
["src/nvim/screen.c", ["        else if (State & INSERT) {", "          if (p_ri)", "            MSG_PUTS_ATTR(_(\" REVERSE\"), attr);"], "readability/braces"]
["src/nvim/screen.c", ["        }", "        if ((State & INSERT) && p_paste)", "          MSG_PUTS_ATTR(_(\" (paste)\"), attr);"], "readability/braces"]
["src/nvim/screen.c", ["", "          /* Don't concatenate separate words to avoid translation", "           * problems. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "      need_clear = TRUE;", "    }"], "readability/bool"]
["src/nvim/screen.c", ["", "    mode_displayed = TRUE;", "    if (need_clear || clear_cmdline)"], "readability/bool"]
["src/nvim/screen.c", ["    mode_displayed = TRUE;", "    if (need_clear || clear_cmdline)", "      msg_clr_eos();"], "readability/braces"]
["src/nvim/screen.c", ["      msg_clr_eos();", "    msg_didout = FALSE;                 /* overwrite this message */", "    length = msg_col;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      msg_clr_eos();", "    msg_didout = FALSE;                 /* overwrite this message */", "    length = msg_col;"], "readability/bool"]
["src/nvim/screen.c", ["", "  /* In Visual mode the size of the selected area must be redrawn. */", "  if (VIsual_active)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  /* In Visual mode the size of the selected area must be redrawn. */", "  if (VIsual_active)", "    clear_showcmd();"], "readability/braces"]
["src/nvim/screen.c", ["", "/*", " * Position for a mode message."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Draw the tab pages line at the top of the Vim window."], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int use_sep_chars = (t_colors < 8", "                       );", ""], "whitespace/parens"]
["src/nvim/screen.c", ["", "  if (tabline_height() < 1)", "    return;"], "readability/braces"]
["src/nvim/screen.c", ["", "  /* Use the 'tabline' option if it's set. */", "  if (*p_tal != NUL) {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    FOR_ALL_TABS(tp) {", "      ++tabcount;", "    }"], "readability/increment"]
["src/nvim/screen.c", ["      if (room > 0) {", "        /* Get buffer name in NameBuff[] */", "        get_trans_bufname(cwp->w_buffer);"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    if (use_sep_chars)", "      c = '_';"], "readability/braces"]
["src/nvim/screen.c", ["      c = '_';", "    else", "      c = ' ';"], "readability/braces"]
["src/nvim/screen.c", ["", "    /* Put an \"X\" for closing the current tab if there are several. */", "    if (first_tabpage->tp_next != NULL) {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* Reset the flag here again, in case evaluating 'tabline' causes it to be", "   * set. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["   * set. */", "  redraw_tabline = FALSE;", "}"], "readability/bool"]
["src/nvim/screen.c", ["", "/*", " * Get buffer name for \"buf\" into NameBuff[]."], "readability/old_style_comment"]
["src/nvim/screen.c", ["{", "  if (buf_spname(buf) != NULL)", "    STRLCPY(NameBuff, buf_spname(buf), MAXPATHL);"], "readability/braces"]
["src/nvim/screen.c", ["    STRLCPY(NameBuff, buf_spname(buf), MAXPATHL);", "  else", "    home_replace(buf, buf->b_fname, NameBuff, MAXPATHL, TRUE);"], "readability/braces"]
["src/nvim/screen.c", ["  else", "    home_replace(buf, buf->b_fname, NameBuff, MAXPATHL, TRUE);", "  trans_characters(NameBuff, MAXPATHL);"], "readability/bool"]
["src/nvim/screen.c", ["", "/*", " * Get the character to use in a status line.  Get its attributes in \"*attr\"."], "readability/old_style_comment"]
["src/nvim/screen.c", ["  }", "  /* Use fill when there is highlighting, and highlighting of current", "   * window differs, or the fillchars differ, or this is not the"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Get the character to use in a separator between vertically split windows."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Return TRUE if redrawing should currently be done."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Return TRUE if printing messages should currently be done."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Show current status info in ruler and various other places"], "readability/old_style_comment"]
["src/nvim/screen.c", ["{", "  if (!always && !redrawing())", "    return;"], "readability/braces"]
["src/nvim/screen.c", ["", "  if (need_maketitle", "      || (p_icon && (stl_syntax & STL_IN_ICON))"], "readability/braces"]
["src/nvim/screen.c", ["    maketitle();", "  /* Redraw the tab pages line if needed. */", "  if (redraw_tabline)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  /* Redraw the tab pages line if needed. */", "  if (redraw_tabline)", "    draw_tabline();"], "readability/braces"]
["src/nvim/screen.c", ["", "  /*", "   * Check if cursor.lnum is valid, since win_redr_ruler() may be called"], "readability/old_style_comment"]
["src/nvim/screen.c", ["   */", "  if (wp->w_cursor.lnum > wp->w_buffer->b_ml.ml_line_count)", "    return;"], "readability/braces"]
["src/nvim/screen.c", ["", "  /*", "   * Check if not in Insert mode and the line is empty (will show \"0-1\")."], "readability/old_style_comment"]
["src/nvim/screen.c", ["   */", "  int empty_line = FALSE;", "  if (!(State & INSERT)"], "readability/bool"]
["src/nvim/screen.c", ["  int empty_line = FALSE;", "  if (!(State & INSERT)", "      && *ml_get_buf(wp->w_buffer, wp->w_cursor.lnum, FALSE) == NUL)"], "readability/braces"]
["src/nvim/screen.c", ["  if (!(State & INSERT)", "      && *ml_get_buf(wp->w_buffer, wp->w_cursor.lnum, FALSE) == NUL)", "    empty_line = TRUE;"], "readability/bool"]
["src/nvim/screen.c", ["      && *ml_get_buf(wp->w_buffer, wp->w_cursor.lnum, FALSE) == NUL)", "    empty_line = TRUE;", ""], "readability/bool"]
["src/nvim/screen.c", ["", "  /*", "   * Only draw the ruler when something changed."], "readability/old_style_comment"]
["src/nvim/screen.c", ["  if (       redraw_cmdline", "             || always", "             || wp->w_cursor.lnum != wp->w_ru_cursor.lnum"], "whitespace/alignment"]
["src/nvim/screen.c", ["             || always", "             || wp->w_cursor.lnum != wp->w_ru_cursor.lnum", "             || wp->w_cursor.col != wp->w_ru_cursor.col"], "whitespace/alignment"]
["src/nvim/screen.c", ["             || wp->w_cursor.lnum != wp->w_ru_cursor.lnum", "             || wp->w_cursor.col != wp->w_ru_cursor.col", "             || wp->w_virtcol != wp->w_ru_virtcol"], "whitespace/alignment"]
["src/nvim/screen.c", ["             || wp->w_cursor.col != wp->w_ru_cursor.col", "             || wp->w_virtcol != wp->w_ru_virtcol", "             || wp->w_cursor.coladd != wp->w_ru_cursor.coladd"], "whitespace/alignment"]
["src/nvim/screen.c", ["             || wp->w_virtcol != wp->w_ru_virtcol", "             || wp->w_cursor.coladd != wp->w_ru_cursor.coladd", "             || wp->w_topline != wp->w_ru_topline"], "whitespace/alignment"]
["src/nvim/screen.c", ["             || wp->w_cursor.coladd != wp->w_ru_cursor.coladd", "             || wp->w_topline != wp->w_ru_topline", "             || wp->w_buffer->b_ml.ml_line_count != wp->w_ru_line_count"], "whitespace/alignment"]
["src/nvim/screen.c", ["             || wp->w_topline != wp->w_ru_topline", "             || wp->w_buffer->b_ml.ml_line_count != wp->w_ru_line_count", "             || wp->w_topfill != wp->w_ru_topfill"], "whitespace/alignment"]
["src/nvim/screen.c", ["             || wp->w_buffer->b_ml.ml_line_count != wp->w_ru_line_count", "             || wp->w_topfill != wp->w_ru_topfill", "             || empty_line != wp->w_ru_empty) {"], "whitespace/alignment"]
["src/nvim/screen.c", ["             || wp->w_topfill != wp->w_ru_topfill", "             || empty_line != wp->w_ru_empty) {", ""], "whitespace/alignment"]
["src/nvim/screen.c", ["             || empty_line != wp->w_ru_empty) {", "", "    int width;"], "whitespace/blank_line"]
["src/nvim/screen.c", ["", "    /*", "     * Some sprintfs return the length, some return a pointer."], "readability/old_style_comment"]
["src/nvim/screen.c", ["    vim_snprintf((char *)buffer, RULER_BUF_LEN, \"%\" PRId64 \",\",", "        (wp->w_buffer->b_ml.ml_flags & ML_EMPTY) ? (int64_t)0L", "                                                 : (int64_t)wp->w_cursor.lnum);"], "whitespace/alignment"]
["src/nvim/screen.c", ["        (wp->w_buffer->b_ml.ml_flags & ML_EMPTY) ? (int64_t)0L", "                                                 : (int64_t)wp->w_cursor.lnum);", "    size_t len = STRLEN(buffer);"], "whitespace/alignment"]
["src/nvim/screen.c", ["    col_print(buffer + len, RULER_BUF_LEN - len,", "        empty_line ? 0 : (int)wp->w_cursor.col + 1,", "        (int)virtcol + 1);"], "whitespace/alignment"]
["src/nvim/screen.c", ["        empty_line ? 0 : (int)wp->w_cursor.col + 1,", "        (int)virtcol + 1);", ""], "whitespace/alignment"]
["src/nvim/screen.c", ["", "    /*", "     * Add a \"50%\" if there is room for it."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Return the width of the 'number' and 'relativenumber' column."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  if (lnum == wp->w_nrwidth_line_count)", "    return wp->w_nrwidth_width;"], "readability/braces"]
["src/nvim/screen.c", ["    lnum /= 10;", "    ++n;", "  } while (lnum > 0);"], "readability/increment"]
["src/nvim/screen.c", ["{", "  static int busy = FALSE;", ""], "readability/bool"]
["src/nvim/screen.c", ["", "  if (width < 0 || height < 0)      /* just checking... */", "    return;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  if (width < 0 || height < 0)      /* just checking... */", "    return;"], "readability/braces"]
["src/nvim/screen.c", ["  if (State == HITRETURN || State == SETWSIZE) {", "    /* postpone the resizing */", "    State = SETWSIZE;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* curwin->w_buffer can be NULL when we are closing a window and the", "   * buffer has already been closed and removing a scrollbar causes a resize"], "readability/old_style_comment"]
["src/nvim/screen.c", ["   */", "  if (curwin->w_buffer == NULL)", "    return;"], "readability/braces"]
["src/nvim/screen.c", ["", "  ++busy;", ""], "readability/increment"]
["src/nvim/screen.c", ["", "  /* The window layout used to be adjusted here, but it now happens in", "   * screenalloc() (also invoked from screenclear()).  That is because the"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /*", "     * We only redraw when it's needed:"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    } else {", "      if (curwin->w_p_scb)", "        do_check_scrollbind(TRUE);"], "readability/braces"]
["src/nvim/screen.c", ["      if (curwin->w_p_scb)", "        do_check_scrollbind(TRUE);", "      if (State & CMDLINE) {"], "readability/bool"]
["src/nvim/screen.h", ["", "/*", " * flags for update_screen()"], "readability/old_style_comment"]
["src/nvim/screen.h", [" */", "#define VALID                   10  /* buffer not changed, or changes marked", "                                       with b_mod_* */"], "readability/multiline_comment"]
["src/nvim/screen.h", [" */", "#define VALID                   10  /* buffer not changed, or changes marked", "                                       with b_mod_* */"], "readability/old_style_comment"]
["src/nvim/screen.h", ["#define VALID                   10  /* buffer not changed, or changes marked", "                                       with b_mod_* */", "#define INVERTED                20  /* redisplay inverted part that changed */"], "whitespace/operators"]
["src/nvim/screen.h", ["                                       with b_mod_* */", "#define INVERTED                20  /* redisplay inverted part that changed */", "#define INVERTED_ALL            25  /* redisplay whole inverted part */"], "readability/old_style_comment"]
["src/nvim/screen.h", ["#define INVERTED                20  /* redisplay inverted part that changed */", "#define INVERTED_ALL            25  /* redisplay whole inverted part */", "#define REDRAW_TOP              30  /* display first w_upd_rows screen lines */"], "readability/old_style_comment"]
["src/nvim/screen.h", ["#define INVERTED_ALL            25  /* redisplay whole inverted part */", "#define REDRAW_TOP              30  /* display first w_upd_rows screen lines */", "#define SOME_VALID              35  /* like NOT_VALID but may scroll */"], "readability/old_style_comment"]
["src/nvim/screen.h", ["#define REDRAW_TOP              30  /* display first w_upd_rows screen lines */", "#define SOME_VALID              35  /* like NOT_VALID but may scroll */", "#define NOT_VALID               40  /* buffer needs complete redraw */"], "readability/old_style_comment"]
["src/nvim/screen.h", ["#define SOME_VALID              35  /* like NOT_VALID but may scroll */", "#define NOT_VALID               40  /* buffer needs complete redraw */", "#define CLEAR                   50  /* screen messed up, clear it */"], "readability/old_style_comment"]
["src/nvim/screen.h", ["#define NOT_VALID               40  /* buffer needs complete redraw */", "#define CLEAR                   50  /* screen messed up, clear it */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * search.c: code for normal mode searching commands"], "readability/old_style_comment"]
["src/nvim/search.c", ["#include <string.h>", "#include <limits.h>             /* for INT_MAX on MSVC */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["#endif", "/*", " * This file contains various searching-related routines. These fall into"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * String searches"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Two search patterns are remembered: One for the :substitute command and"], "readability/old_style_comment"]
["src/nvim/search.c", ["  // Last used search pattern", "  [0] = {NULL, true, false, 0, {'/', false, false, 0L}, NULL},", "  // Last used substitute pattern"], "whitespace/braces"]
["src/nvim/search.c", ["  // Last used search pattern", "  [0] = {NULL, true, false, 0, {'/', false, false, 0L}, NULL},", "  // Last used substitute pattern"], "whitespace/braces"]
["src/nvim/search.c", ["  // Last used substitute pattern", "  [1] = {NULL, true, false, 0, {'/', false, false, 0L}, NULL}", "};"], "whitespace/braces"]
["src/nvim/search.c", ["  // Last used substitute pattern", "  [1] = {NULL, true, false, 0, {'/', false, false, 0L}, NULL}", "};"], "whitespace/braces"]
["src/nvim/search.c", ["", "static int last_idx = 0;        /* index in spats[] for RE_LAST */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Type used by find_pattern_in_path() to remember which included files have"], "readability/old_style_comment"]
["src/nvim/search.c", ["typedef struct SearchedFile {", "  FILE        *fp;              /* File pointer */", "  char_u      *name;            /* Full name of file */"], "readability/old_style_comment"]
["src/nvim/search.c", ["  FILE        *fp;              /* File pointer */", "  char_u      *name;            /* Full name of file */", "  linenr_T lnum;                /* Line we were up to in file */"], "readability/old_style_comment"]
["src/nvim/search.c", ["  char_u      *name;            /* Full name of file */", "  linenr_T lnum;                /* Line we were up to in file */", "  int matched;                  /* Found a match in this file */"], "readability/old_style_comment"]
["src/nvim/search.c", ["  linenr_T lnum;                /* Line we were up to in file */", "  int matched;                  /* Found a match in this file */", "} SearchedFile;"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * translate search pattern for vim_regcomp()"], "readability/old_style_comment"]
["src/nvim/search.c", ["    int options,", "    regmmatch_T *regmatch          /* return: pattern and ignore-case flag */", ")"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  rc_did_emsg = FALSE;", "  magic = p_magic;"], "readability/bool"]
["src/nvim/search.c", ["", "  /*", "   * If no pattern given, use a previously defined pattern."], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (pat == NULL || *pat == NUL) {", "    if (pat_use == RE_LAST)", "      i = last_idx;"], "readability/braces"]
["src/nvim/search.c", ["      i = last_idx;", "    else", "      i = pat_use;"], "readability/braces"]
["src/nvim/search.c", ["      i = pat_use;", "    if (spats[i].pat == NULL) {         /* pattern was never defined */", "      if (pat_use == RE_SUBST)"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (spats[i].pat == NULL) {         /* pattern was never defined */", "      if (pat_use == RE_SUBST)", "        EMSG(_(e_nopresub));"], "readability/braces"]
["src/nvim/search.c", ["        EMSG(_(e_nopresub));", "      else", "        EMSG(_(e_noprevre));"], "readability/braces"]
["src/nvim/search.c", ["        EMSG(_(e_noprevre));", "      rc_did_emsg = TRUE;", "      return FAIL;"], "readability/bool"]
["src/nvim/search.c", ["    no_smartcase = spats[i].no_scs;", "  } else if (options & SEARCH_HIS)      /* put new pattern in history */", "    add_to_history(HIST_SEARCH, pat, TRUE, NUL);"], "readability/old_style_comment"]
["src/nvim/search.c", ["    no_smartcase = spats[i].no_scs;", "  } else if (options & SEARCH_HIS)      /* put new pattern in history */", "    add_to_history(HIST_SEARCH, pat, TRUE, NUL);"], "readability/braces"]
["src/nvim/search.c", ["  } else if (options & SEARCH_HIS)      /* put new pattern in history */", "    add_to_history(HIST_SEARCH, pat, TRUE, NUL);", ""], "readability/bool"]
["src/nvim/search.c", ["    xfree(mr_pattern);", "    mr_pattern_alloced = FALSE;", "  }"], "readability/bool"]
["src/nvim/search.c", ["    mr_pattern = reverse_text(pat);", "    mr_pattern_alloced = TRUE;", "  } else"], "readability/bool"]
["src/nvim/search.c", ["    mr_pattern_alloced = TRUE;", "  } else", "    mr_pattern = pat;"], "readability/braces"]
["src/nvim/search.c", ["", "  /*", "   * Save the currently used pattern in the appropriate place,"], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (!(options & SEARCH_KEEP) && !cmdmod.keeppatterns) {", "    /* search or global command */", "    if (pat_save == RE_SEARCH || pat_save == RE_BOTH)"], "readability/old_style_comment"]
["src/nvim/search.c", ["    /* search or global command */", "    if (pat_save == RE_SEARCH || pat_save == RE_BOTH)", "      save_re_pat(RE_SEARCH, pat, magic);"], "readability/braces"]
["src/nvim/search.c", ["      save_re_pat(RE_SEARCH, pat, magic);", "    /* substitute or global command */", "    if (pat_save == RE_SUBST || pat_save == RE_BOTH)"], "readability/old_style_comment"]
["src/nvim/search.c", ["    /* substitute or global command */", "    if (pat_save == RE_SUBST || pat_save == RE_BOTH)", "      save_re_pat(RE_SUBST, pat, magic);"], "readability/braces"]
["src/nvim/search.c", ["  regmatch->regprog = vim_regcomp(pat, magic ? RE_MAGIC : 0);", "  if (regmatch->regprog == NULL)", "    return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * Get search pattern used by search_regcomp()."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Reverse text into allocated memory."], "readability/old_style_comment"]
["src/nvim/search.c", ["{", "  /*", "   * Reverse the pattern."], "readability/old_style_comment"]
["src/nvim/search.c", ["    last_idx = idx;", "    /* If 'hlsearch' set and search pat changed: need redraw. */", "    if (p_hls)"], "readability/old_style_comment"]
["src/nvim/search.c", ["    /* If 'hlsearch' set and search pat changed: need redraw. */", "    if (p_hls)", "      redraw_all_later(SOME_VALID);"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * Save the search patterns, so they can be restored later."], "readability/old_style_comment"]
["src/nvim/search.c", ["    saved_spats[0] = spats[0];", "    if (spats[0].pat != NULL)", "      saved_spats[0].pat = vim_strsave(spats[0].pat);"], "readability/braces"]
["src/nvim/search.c", ["    saved_spats[1] = spats[1];", "    if (spats[1].pat != NULL)", "      saved_spats[1].pat = vim_strsave(spats[1].pat);"], "readability/braces"]
["src/nvim/search.c", ["    xfree(mr_pattern);", "    mr_pattern_alloced = FALSE;", "    mr_pattern = NULL;"], "readability/bool"]
["src/nvim/search.c", ["", "/*", " * Return TRUE when case should be ignored for search pattern \"pat\"."], "readability/old_style_comment"]
["src/nvim/search.c", ["{", "  return last_t_cmd == TRUE;", "}"], "readability/bool"]
["src/nvim/search.c", ["  lastc_bytelen = len;", "  if (len)", "    memcpy(lastc_bytes, s, len);"], "readability/braces"]
["src/nvim/search.c", ["    memcpy(lastc_bytes, s, len);", "  else", "    memset(lastc_bytes, 0, sizeof(lastc_bytes));"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * Reset search direction to forward.  For \"gd\" and \"gD\" commands."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Set the last search pattern.  For \":let @/ =\" and ShaDa file."], "readability/old_style_comment"]
["src/nvim/search.c", ["  free_spat(&spats[idx]);", "  /* An empty string means that nothing should be matched. */", "  if (*s == NUL)"], "readability/old_style_comment"]
["src/nvim/search.c", ["  /* An empty string means that nothing should be matched. */", "  if (*s == NUL)", "    spats[idx].pat = NULL;"], "readability/braces"]
["src/nvim/search.c", ["    spats[idx].pat = NULL;", "  else", "    spats[idx].pat = (char_u *) xstrdup((char *) s);"], "readability/braces"]
["src/nvim/search.c", ["  else", "    spats[idx].pat = (char_u *) xstrdup((char *) s);", "  spats[idx].timestamp = os_time();"], "whitespace/cast"]
["src/nvim/search.c", ["  spats[idx].magic = magic;", "  spats[idx].no_scs = FALSE;", "  spats[idx].off.dir = '/';"], "readability/bool"]
["src/nvim/search.c", ["  set_vv_searchforward();", "  spats[idx].off.line = FALSE;", "  spats[idx].off.end = FALSE;"], "readability/bool"]
["src/nvim/search.c", ["  spats[idx].off.line = FALSE;", "  spats[idx].off.end = FALSE;", "  spats[idx].off.off = 0;"], "readability/bool"]
["src/nvim/search.c", ["  spats[idx].off.off = 0;", "  if (setlast)", "    last_idx = idx;"], "readability/braces"]
["src/nvim/search.c", ["    saved_spats[idx] = spats[0];", "    if (spats[idx].pat == NULL)", "      saved_spats[idx].pat = NULL;"], "readability/braces"]
["src/nvim/search.c", ["      saved_spats[idx].pat = NULL;", "    else", "      saved_spats[idx].pat = vim_strsave(spats[idx].pat);"], "readability/braces"]
["src/nvim/search.c", ["  }", "  /* If 'hlsearch' set and search pat changed: need redraw. */", "  if (p_hls && idx == last_idx && !no_hlsearch)"], "readability/old_style_comment"]
["src/nvim/search.c", ["  /* If 'hlsearch' set and search pat changed: need redraw. */", "  if (p_hls && idx == last_idx && !no_hlsearch)", "    redraw_all_later(SOME_VALID);"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * Get a regexp program for the last used search pattern."], "readability/old_style_comment"]
["src/nvim/search.c", ["  }", "  ++emsg_off;           /* So it doesn't beep if bad expr */", "  (void)search_regcomp((char_u *)\"\", 0, last_idx, SEARCH_KEEP, regmatch);"], "readability/old_style_comment"]
["src/nvim/search.c", ["  }", "  ++emsg_off;           /* So it doesn't beep if bad expr */", "  (void)search_regcomp((char_u *)\"\", 0, last_idx, SEARCH_KEEP, regmatch);"], "readability/increment"]
["src/nvim/search.c", ["  (void)search_regcomp((char_u *)\"\", 0, last_idx, SEARCH_KEEP, regmatch);", "  --emsg_off;", "}"], "readability/increment"]
["src/nvim/search.c", ["  int found;", "  linenr_T lnum;                /* no init to shut up Apollo cc */", "  regmmatch_T regmatch;"], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (search_regcomp(pat, RE_SEARCH, pat_use,", "          (options & (SEARCH_HIS + SEARCH_KEEP)), &regmatch) == FAIL) {", "    if ((options & SEARCH_MSG) && !rc_did_emsg)"], "whitespace/alignment"]
["src/nvim/search.c", ["          (options & (SEARCH_HIS + SEARCH_KEEP)), &regmatch) == FAIL) {", "    if ((options & SEARCH_MSG) && !rc_did_emsg)", "      EMSG2(_(\"E383: Invalid search string: %s\"), mr_pattern);"], "readability/braces"]
["src/nvim/search.c", ["", "  /*", "   * find the string"], "readability/old_style_comment"]
["src/nvim/search.c", ["   */", "  called_emsg = FALSE;", "  do {  /* loop for count */"], "readability/bool"]
["src/nvim/search.c", ["  called_emsg = FALSE;", "  do {  /* loop for count */", "    // When not accepting a match at the start position set \"extra_col\" to a"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    start_pos = *pos;           /* remember start pos for detecting no match */", "    found = 0;                  /* default: not found */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    start_pos = *pos;           /* remember start pos for detecting no match */", "    found = 0;                  /* default: not found */", "    at_first_line = TRUE;       /* default: start in first line */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    found = 0;                  /* default: not found */", "    at_first_line = TRUE;       /* default: start in first line */", "    if (pos->lnum == 0) {       /* correct lnum for when starting in line 0 */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    found = 0;                  /* default: not found */", "    at_first_line = TRUE;       /* default: start in first line */", "    if (pos->lnum == 0) {       /* correct lnum for when starting in line 0 */"], "readability/bool"]
["src/nvim/search.c", ["    at_first_line = TRUE;       /* default: start in first line */", "    if (pos->lnum == 0) {       /* correct lnum for when starting in line 0 */", "      pos->lnum = 1;"], "readability/old_style_comment"]
["src/nvim/search.c", ["      pos->col = 0;", "      at_first_line = FALSE;        /* not in first line now */", "    }"], "readability/old_style_comment"]
["src/nvim/search.c", ["      pos->col = 0;", "      at_first_line = FALSE;        /* not in first line now */", "    }"], "readability/bool"]
["src/nvim/search.c", ["", "    /*", "     * Start searching in current line, unless searching backwards and"], "readability/old_style_comment"]
["src/nvim/search.c", ["      lnum = pos->lnum - 1;", "      at_first_line = FALSE;", "    } else"], "readability/bool"]
["src/nvim/search.c", ["      at_first_line = FALSE;", "    } else", "      lnum = pos->lnum;"], "readability/braces"]
["src/nvim/search.c", ["", "    for (loop = 0; loop <= 1; ++loop) {     /* loop twice if 'wrapscan' set */", "      for (; lnum > 0 && lnum <= buf->b_ml.ml_line_count;"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    for (loop = 0; loop <= 1; ++loop) {     /* loop twice if 'wrapscan' set */", "      for (; lnum > 0 && lnum <= buf->b_ml.ml_line_count;"], "readability/increment"]
["src/nvim/search.c", ["      for (; lnum > 0 && lnum <= buf->b_ml.ml_line_count;", "           lnum += dir, at_first_line = FALSE) {", "        /* Stop after checking \"stop_lnum\", if it's set. */"], "readability/bool"]
["src/nvim/search.c", ["           lnum += dir, at_first_line = FALSE) {", "        /* Stop after checking \"stop_lnum\", if it's set. */", "        if (stop_lnum != 0 && (dir == FORWARD"], "readability/old_style_comment"]
["src/nvim/search.c", ["        /* Stop after checking \"stop_lnum\", if it's set. */", "        if (stop_lnum != 0 && (dir == FORWARD", "                               ? lnum > stop_lnum : lnum < stop_lnum))"], "readability/braces"]
["src/nvim/search.c", ["          break;", "        /* Stop after passing the \"tm\" time limit. */", "        if (tm != NULL && profile_passed_limit(*tm))"], "readability/old_style_comment"]
["src/nvim/search.c", ["        /* Stop after passing the \"tm\" time limit. */", "        if (tm != NULL && profile_passed_limit(*tm))", "          break;"], "readability/braces"]
["src/nvim/search.c", ["        if (nmatched > 0) {", "          /* match may actually be in another line when using \\zs */", "          matchpos = regmatch.startpos[0];"], "readability/old_style_comment"]
["src/nvim/search.c", ["          submatch = first_submatch(&regmatch);", "          /* \"lnum\" may be past end of buffer for \"\\n\\zs\". */", "          if (lnum + matchpos.lnum > buf->b_ml.ml_line_count)"], "readability/old_style_comment"]
["src/nvim/search.c", ["          /* \"lnum\" may be past end of buffer for \"\\n\\zs\". */", "          if (lnum + matchpos.lnum > buf->b_ml.ml_line_count)", "            ptr = (char_u *)\"\";"], "readability/braces"]
["src/nvim/search.c", ["            ptr = (char_u *)\"\";", "          else", "            ptr = ml_get_buf(buf, lnum + matchpos.lnum, FALSE);"], "readability/braces"]
["src/nvim/search.c", ["          else", "            ptr = ml_get_buf(buf, lnum + matchpos.lnum, FALSE);", ""], "readability/bool"]
["src/nvim/search.c", ["", "          /*", "           * Forward search in the first line: match should be after"], "readability/old_style_comment"]
["src/nvim/search.c", ["          if (dir == FORWARD && at_first_line) {", "            match_ok = TRUE;", "            /*"], "readability/bool"]
["src/nvim/search.c", ["            match_ok = TRUE;", "            /*", "             * When the match starts in a next line it's certainly"], "readability/old_style_comment"]
["src/nvim/search.c", ["                          < (int)start_pos.col + extra_col))) {", "              /*", "               * If vi-compatible searching, continue at the end"], "readability/old_style_comment"]
["src/nvim/search.c", ["                if (nmatched > 1) {", "                  /* end is in next line, thus no match in", "                   * this line */"], "readability/old_style_comment"]
["src/nvim/search.c", ["                   * this line */", "                  match_ok = FALSE;", "                  break;"], "readability/bool"]
["src/nvim/search.c", ["            }", "            if (!match_ok)", "              continue;"], "readability/braces"]
["src/nvim/search.c", ["          if (dir == BACKWARD) {", "            /*", "             * Now, if there are multiple matches on this line,"], "readability/old_style_comment"]
["src/nvim/search.c", ["             */", "            match_ok = FALSE;", "            for (;; ) {"], "readability/bool"]
["src/nvim/search.c", ["            for (;; ) {", "              /* Remember a position that is before the start", "               * position, we use it if it's the last match in"], "readability/old_style_comment"]
["src/nvim/search.c", ["                submatch = first_submatch(&regmatch);", "              } else", "                break;"], "readability/braces"]
["src/nvim/search.c", ["", "            /*", "             * If there is only a match after the cursor, skip"], "readability/old_style_comment"]
["src/nvim/search.c", ["             */", "            if (!match_ok)", "              continue;"], "readability/braces"]
["src/nvim/search.c", ["", "          /* With the SEARCH_END option move to the last character", "           * of the match.  Don't do it for an empty match, end"], "readability/old_style_comment"]
["src/nvim/search.c", ["                   && matchpos.col == endpos.col)) {", "            /* For a match in the first column, set the position", "             * on the NUL in the previous line. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["            if (endpos.col == 0) {", "              if (pos->lnum > 1) {              /* just in case */", "                --pos->lnum;"], "readability/old_style_comment"]
["src/nvim/search.c", ["              if (pos->lnum > 1) {              /* just in case */", "                --pos->lnum;", "                pos->col = (colnr_T)STRLEN(ml_get_buf(buf,"], "readability/increment"]
["src/nvim/search.c", ["                pos->col = (colnr_T)STRLEN(ml_get_buf(buf,", "                        pos->lnum, FALSE));", "              }"], "whitespace/alignment"]
["src/nvim/search.c", ["                pos->col = (colnr_T)STRLEN(ml_get_buf(buf,", "                        pos->lnum, FALSE));", "              }"], "readability/bool"]
["src/nvim/search.c", ["", "          /* Set variables used for 'incsearch' highlighting. */", "          search_match_lines = endpos.lnum - matchpos.lnum;"], "readability/old_style_comment"]
["src/nvim/search.c", ["        }", "        line_breakcheck();              /* stop if ctrl-C typed */", "        if (got_int)"], "readability/old_style_comment"]
["src/nvim/search.c", ["        line_breakcheck();              /* stop if ctrl-C typed */", "        if (got_int)", "          break;"], "readability/braces"]
["src/nvim/search.c", ["", "        /* Cancel searching if a character was typed.  Used for", "         * 'incsearch'.  Don't check too often, that would slowdown"], "readability/old_style_comment"]
["src/nvim/search.c", ["            && char_avail()) {", "          break_loop = TRUE;", "          break;"], "readability/bool"]
["src/nvim/search.c", ["", "        if (loop && lnum == start_pos.lnum)", "          break;                    /* if second loop, stop where started */"], "readability/braces"]
["src/nvim/search.c", ["        if (loop && lnum == start_pos.lnum)", "          break;                    /* if second loop, stop where started */", "      }"], "readability/old_style_comment"]
["src/nvim/search.c", ["      }", "      at_first_line = FALSE;", ""], "readability/bool"]
["src/nvim/search.c", ["", "  if (!found) {             /* did not find it */", "    if (got_int)"], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (!found) {             /* did not find it */", "    if (got_int)", "      EMSG(_(e_interr));"], "readability/braces"]
["src/nvim/search.c", ["      EMSG(_(e_interr));", "    else if ((options & SEARCH_MSG) == SEARCH_MSG) {", "      if (p_ws)"], "readability/braces"]
["src/nvim/search.c", ["    else if ((options & SEARCH_MSG) == SEARCH_MSG) {", "      if (p_ws)", "        EMSG2(_(e_patnotf2), mr_pattern);"], "readability/braces"]
["src/nvim/search.c", ["        EMSG2(_(e_patnotf2), mr_pattern);", "      else if (lnum == 0)", "        EMSG2(_(\"E384: search hit TOP without match for: %s\"),"], "readability/braces"]
["src/nvim/search.c", ["        EMSG2(_(\"E384: search hit TOP without match for: %s\"),", "            mr_pattern);", "      else"], "whitespace/alignment"]
["src/nvim/search.c", ["            mr_pattern);", "      else", "        EMSG2(_(\"E385: search hit BOTTOM without match for: %s\"),"], "readability/braces"]
["src/nvim/search.c", ["        EMSG2(_(\"E385: search hit BOTTOM without match for: %s\"),", "            mr_pattern);", "    }"], "whitespace/alignment"]
["src/nvim/search.c", ["", "  /* A pattern like \"\\n\\zs\" may go past the last line. */", "  if (pos->lnum > buf->b_ml.ml_line_count) {"], "readability/old_style_comment"]
["src/nvim/search.c", ["    pos->lnum = buf->b_ml.ml_line_count;", "    pos->col = (int)STRLEN(ml_get_buf(buf, pos->lnum, FALSE));", "    if (pos->col > 0)"], "readability/bool"]
["src/nvim/search.c", ["    pos->col = (int)STRLEN(ml_get_buf(buf, pos->lnum, FALSE));", "    if (pos->col > 0)", "      --pos->col;"], "readability/braces"]
["src/nvim/search.c", ["    if (pos->col > 0)", "      --pos->col;", "  }"], "readability/increment"]
["src/nvim/search.c", ["", "  for (submatch = 1;; ++submatch) {", "    if (rp->startpos[submatch].lnum >= 0)"], "readability/increment"]
["src/nvim/search.c", ["  for (submatch = 1;; ++submatch) {", "    if (rp->startpos[submatch].lnum >= 0)", "      break;"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * Highest level string search function."], "readability/old_style_comment"]
["src/nvim/search.c", ["{", "  pos_T pos;                    /* position of the last match */", "  char_u          *searchstr;"], "readability/old_style_comment"]
["src/nvim/search.c", ["  struct soffset old_off;", "  int retval;                   /* Return value */", "  char_u          *p;"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * A line offset is not remembered, this is vi compatible."], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (spats[0].off.line && vim_strchr(p_cpo, CPO_LINEOFF) != NULL) {", "    spats[0].off.line = FALSE;", "    spats[0].off.off = 0;"], "readability/bool"]
["src/nvim/search.c", ["", "  /*", "   * Save the values for when (options & SEARCH_KEEP) is used."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  pos = curwin->w_cursor;       /* start searching at the cursor position */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * Find out the direction of the search."], "readability/old_style_comment"]
["src/nvim/search.c", ["   */", "  if (dirc == 0)", "    dirc = spats[0].off.dir;"], "readability/braces"]
["src/nvim/search.c", ["    dirc = spats[0].off.dir;", "  else {", "    spats[0].off.dir = dirc;"], "readability/braces"]
["src/nvim/search.c", ["    dirc = spats[0].off.dir;", "  else {", "    spats[0].off.dir = dirc;"], "readability/braces"]
["src/nvim/search.c", ["  if (options & SEARCH_REV) {", "    if (dirc == '/')", "      dirc = '?';"], "readability/braces"]
["src/nvim/search.c", ["      dirc = '?';", "    else", "      dirc = '/';"], "readability/braces"]
["src/nvim/search.c", ["", "  /* If the cursor is in a closed fold, don't find another match in the same", "   * fold. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (dirc == '/') {", "    if (hasFolding(pos.lnum, NULL, &pos.lnum))", "      pos.col = MAXCOL - 2;             /* avoid overflow when adding 1 */"], "readability/braces"]
["src/nvim/search.c", ["    if (hasFolding(pos.lnum, NULL, &pos.lnum))", "      pos.col = MAXCOL - 2;             /* avoid overflow when adding 1 */", "  } else {"], "readability/old_style_comment"]
["src/nvim/search.c", ["  } else {", "    if (hasFolding(pos.lnum, &pos.lnum, NULL))", "      pos.col = 0;"], "readability/braces"]
["src/nvim/search.c", ["", "  /*", "   * Turn 'hlsearch' highlighting back on."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * Repeat the search when pattern followed by ';', e.g. \"/foo/;?bar\"."], "readability/old_style_comment"]
["src/nvim/search.c", ["      } else {", "        /* make search_regcomp() use spats[RE_SEARCH].pat */", "        searchstr = (char_u *)\"\";"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    if (pat != NULL && *pat != NUL) {   /* look for (new) offset */", "      /*"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (pat != NULL && *pat != NUL) {   /* look for (new) offset */", "      /*", "       * Find end of regular expression."], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (strcopy != ps) {", "        /* made a copy of \"pat\" to change \"\\?\" to \"?\" */", "        searchcmdlen += (int)(STRLEN(pat) - STRLEN(strcopy));"], "readability/old_style_comment"]
["src/nvim/search.c", ["      }", "      spats[0].off.line = FALSE;", "      spats[0].off.end = FALSE;"], "readability/bool"]
["src/nvim/search.c", ["      spats[0].off.line = FALSE;", "      spats[0].off.end = FALSE;", "      spats[0].off.off = 0;"], "readability/bool"]
["src/nvim/search.c", ["      }", "      if (ascii_isdigit(*p) || *p == '+' || *p == '-') {      /* got an offset */", "        /* 'nr' or '+nr' or '-nr' */"], "readability/old_style_comment"]
["src/nvim/search.c", ["      }", "      if (ascii_isdigit(*p) || *p == '+' || *p == '-') {      /* got an offset */", "        /* 'nr' or '+nr' or '-nr' */"], "whitespace/line_length"]
["src/nvim/search.c", ["      if (ascii_isdigit(*p) || *p == '+' || *p == '-') {      /* got an offset */", "        /* 'nr' or '+nr' or '-nr' */", "        if (ascii_isdigit(*p) || ascii_isdigit(*(p + 1)))"], "readability/old_style_comment"]
["src/nvim/search.c", ["        /* 'nr' or '+nr' or '-nr' */", "        if (ascii_isdigit(*p) || ascii_isdigit(*(p + 1)))", "          spats[0].off.off = atol((char *)p);"], "readability/braces"]
["src/nvim/search.c", ["          spats[0].off.off = atol((char *)p);", "        else if (*p == '-')                 /* single '-' */", "          spats[0].off.off = -1;"], "readability/old_style_comment"]
["src/nvim/search.c", ["          spats[0].off.off = atol((char *)p);", "        else if (*p == '-')                 /* single '-' */", "          spats[0].off.off = -1;"], "readability/braces"]
["src/nvim/search.c", ["          spats[0].off.off = -1;", "        else                                /* single '+' */", "          spats[0].off.off = 1;"], "readability/old_style_comment"]
["src/nvim/search.c", ["          spats[0].off.off = -1;", "        else                                /* single '+' */", "          spats[0].off.off = 1;"], "readability/braces"]
["src/nvim/search.c", ["          spats[0].off.off = 1;", "        ++p;", "        while (ascii_isdigit(*p))           /* skip number */"], "readability/increment"]
["src/nvim/search.c", ["        ++p;", "        while (ascii_isdigit(*p))           /* skip number */", "          ++p;"], "readability/old_style_comment"]
["src/nvim/search.c", ["        ++p;", "        while (ascii_isdigit(*p))           /* skip number */", "          ++p;"], "readability/braces"]
["src/nvim/search.c", ["        while (ascii_isdigit(*p))           /* skip number */", "          ++p;", "      }"], "readability/increment"]
["src/nvim/search.c", ["", "      /* compute length of search command for get_address() */", "      searchcmdlen += (int)(p - pat);"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "      pat = p;                              /* put pat after search command */", "    }"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /*", "     * If there is a character offset, subtract it from the current"], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (spats[0].off.off > 0) {", "        for (c = spats[0].off.off; c; --c)", "          if (decl(&pos) == -1)"], "readability/braces"]
["src/nvim/search.c", ["      if (spats[0].off.off > 0) {", "        for (c = spats[0].off.off; c; --c)", "          if (decl(&pos) == -1)"], "readability/increment"]
["src/nvim/search.c", ["        for (c = spats[0].off.off; c; --c)", "          if (decl(&pos) == -1)", "            break;"], "readability/braces"]
["src/nvim/search.c", ["            break;", "        if (c) {                        /* at start of buffer */", "          pos.lnum = 0;                 /* allow lnum == 0 here */"], "readability/old_style_comment"]
["src/nvim/search.c", ["        if (c) {                        /* at start of buffer */", "          pos.lnum = 0;                 /* allow lnum == 0 here */", "          pos.col = MAXCOL;"], "readability/old_style_comment"]
["src/nvim/search.c", ["      } else {", "        for (c = spats[0].off.off; c; ++c)", "          if (incl(&pos) == -1)"], "readability/braces"]
["src/nvim/search.c", ["      } else {", "        for (c = spats[0].off.off; c; ++c)", "          if (incl(&pos) == -1)"], "readability/increment"]
["src/nvim/search.c", ["        for (c = spats[0].off.off; c; ++c)", "          if (incl(&pos) == -1)", "            break;"], "readability/braces"]
["src/nvim/search.c", ["            break;", "        if (c) {                        /* at end of buffer */", "          pos.lnum = curbuf->b_ml.ml_line_count + 1;"], "readability/old_style_comment"]
["src/nvim/search.c", ["    }", "    if (spats[0].off.end && oap != NULL)", "      oap->inclusive = true;        /* 'e' includes last character */"], "readability/braces"]
["src/nvim/search.c", ["    if (spats[0].off.end && oap != NULL)", "      oap->inclusive = true;        /* 'e' includes last character */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    retval = 1;                     /* pattern found */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /*", "     * Add character and/or line offset"], "readability/old_style_comment"]
["src/nvim/search.c", ["        c = pos.lnum + spats[0].off.off;", "        if (c < 1)", "          pos.lnum = 1;"], "readability/braces"]
["src/nvim/search.c", ["          pos.lnum = 1;", "        else if (c > curbuf->b_ml.ml_line_count)", "          pos.lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/search.c", ["          pos.lnum = curbuf->b_ml.ml_line_count;", "        else", "          pos.lnum = c;"], "readability/braces"]
["src/nvim/search.c", ["", "        retval = 2;                 /* pattern found, line offset added */", "      } else if (pos.col < MAXCOL - 2) {      /* just in case */"], "readability/old_style_comment"]
["src/nvim/search.c", ["        retval = 2;                 /* pattern found, line offset added */", "      } else if (pos.col < MAXCOL - 2) {      /* just in case */", "        /* to the right, check for end of file */"], "readability/old_style_comment"]
["src/nvim/search.c", ["      } else if (pos.col < MAXCOL - 2) {      /* just in case */", "        /* to the right, check for end of file */", "        c = spats[0].off.off;"], "readability/old_style_comment"]
["src/nvim/search.c", ["        if (c > 0) {", "          while (c-- > 0)", "            if (incl(&pos) == -1)"], "readability/braces"]
["src/nvim/search.c", ["          while (c-- > 0)", "            if (incl(&pos) == -1)", "              break;"], "readability/braces"]
["src/nvim/search.c", ["        }", "        /* to the left, check for start of file */", "        else {"], "readability/old_style_comment"]
["src/nvim/search.c", ["        /* to the left, check for start of file */", "        else {", "          while (c++ < 0)"], "whitespace/newline"]
["src/nvim/search.c", ["        /* to the left, check for start of file */", "        else {", "          while (c++ < 0)"], "readability/braces"]
["src/nvim/search.c", ["        else {", "          while (c++ < 0)", "            if (decl(&pos) == -1)"], "readability/braces"]
["src/nvim/search.c", ["          while (c++ < 0)", "            if (decl(&pos) == -1)", "              break;"], "readability/braces"]
["src/nvim/search.c", ["    }", "    ++pat;", "  }"], "readability/increment"]
["src/nvim/search.c", ["", "  if (options & SEARCH_MARK)", "    setpcmark();"], "readability/braces"]
["src/nvim/search.c", ["  curwin->w_cursor = pos;", "  curwin->w_set_curswant = TRUE;", ""], "readability/bool"]
["src/nvim/search.c", ["end_do_search:", "  if ((options & SEARCH_KEEP) || cmdmod.keeppatterns)", "    spats[0].off = old_off;"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * search_for_exact_line(buf, pos, dir, pat)"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  if (buf->b_ml.ml_line_count == 0)", "    return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["        pos->lnum = buf->b_ml.ml_line_count;", "        if (!shortmess(SHM_SEARCH))", "          give_warning((char_u *)_(top_bot_msg), true);"], "readability/braces"]
["src/nvim/search.c", ["        pos->lnum = 1;", "        if (!shortmess(SHM_SEARCH))", "          give_warning((char_u *)_(bot_top_msg), true);"], "readability/braces"]
["src/nvim/search.c", ["    }", "    if (pos->lnum == start)", "      break;"], "readability/braces"]
["src/nvim/search.c", ["      break;", "    if (start == 0)", "      start = pos->lnum;"], "readability/braces"]
["src/nvim/search.c", ["      start = pos->lnum;", "    ptr = ml_get_buf(buf, pos->lnum, FALSE);", "    p = skipwhite(ptr);"], "readability/bool"]
["src/nvim/search.c", ["    p = skipwhite(ptr);", "    pos->col = (colnr_T) (p - ptr);", ""], "whitespace/cast"]
["src/nvim/search.c", ["", "    /* when adding lines the matching line may be empty but it is not", "     * ignored because we are interested in the next line -- Acevedo */"], "readability/old_style_comment"]
["src/nvim/search.c", ["      assert(compl_length >= 0);", "      if ((p_ic ? mb_strnicmp(p, pat, (size_t)compl_length)", "           : STRNCMP(p, pat, compl_length)) == 0)"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * Character Searches"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Search for a character in a line.  If \"t_cmd\" is FALSE, move to the"], "readability/old_style_comment"]
["src/nvim/search.c", ["  int len;", "  int stop = TRUE;", ""], "readability/bool"]
["src/nvim/search.c", ["", "  if (c != NUL) {       /* normal search: remember args for repeat */", "    if (!KeyStuffed) {      /* don't remember when redoing */"], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (c != NUL) {       /* normal search: remember args for repeat */", "    if (!KeyStuffed) {      /* don't remember when redoing */", "      *lastc = c;"], "readability/old_style_comment"]
["src/nvim/search.c", ["    c = *lastc;", "    /* For multi-byte re-use last lastc_bytes[] and lastc_bytelen. */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /* Force a move of at least one char, so \";\" and \",\" will move the", "     * cursor, even if the cursor is right in front of char we are looking"], "readability/old_style_comment"]
["src/nvim/search.c", ["     * at. */", "    if (vim_strchr(p_cpo, CPO_SCOLON) == NULL && count == 1 && t_cmd)", "      stop = FALSE;"], "readability/braces"]
["src/nvim/search.c", ["    if (vim_strchr(p_cpo, CPO_SCOLON) == NULL && count == 1 && t_cmd)", "      stop = FALSE;", "  }"], "readability/bool"]
["src/nvim/search.c", ["", "  if (dir == BACKWARD)", "    cap->oap->inclusive = false;"], "readability/braces"]
["src/nvim/search.c", ["    cap->oap->inclusive = false;", "  else", "    cap->oap->inclusive = true;"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * \"Other\" Searches"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * findmatch - find the matching paren or brace"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Raw string start is found at linep[startpos.col - 1]."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * findmatchlimit -- find the matching paren or brace, if it exists within"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /* Direction to search when initc is '/', '*' or '#' */", "  if (flags & FM_BACKWARD)"], "readability/old_style_comment"]
["src/nvim/search.c", ["  /* Direction to search when initc is '/', '*' or '#' */", "  if (flags & FM_BACKWARD)", "    dir = BACKWARD;"], "readability/braces"]
["src/nvim/search.c", ["    dir = BACKWARD;", "  else if (flags & FM_FORWARD)", "    dir = FORWARD;"], "readability/braces"]
["src/nvim/search.c", ["    dir = FORWARD;", "  else", "    dir = 0;"], "readability/braces"]
["src/nvim/search.c", ["", "  /*", "   * if initc given, look in the table for the matching character"], "readability/old_style_comment"]
["src/nvim/search.c", ["    comment_dir = dir;", "    if (initc == '/')", "      ignore_cend = true;"], "readability/braces"]
["src/nvim/search.c", ["  } else {", "    /*", "     * Either initc is '#', or no initc was given and we need to look"], "readability/old_style_comment"]
["src/nvim/search.c", ["    } else {", "      /*", "       * initc was not given, must look for something to match under"], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (!cpo_match) {", "        /* Are we before or at #if, #else etc.? */", "        ptr = skipwhite(linep);"], "readability/old_style_comment"]
["src/nvim/search.c", ["          ptr = skipwhite(ptr + 1);", "          if (   STRNCMP(ptr, \"if\", 2) == 0", "                 || STRNCMP(ptr, \"endif\", 5) == 0"], "readability/braces"]
["src/nvim/search.c", ["          if (   STRNCMP(ptr, \"if\", 2) == 0", "                 || STRNCMP(ptr, \"endif\", 5) == 0", "                 || STRNCMP(ptr, \"el\", 2) == 0)"], "whitespace/alignment"]
["src/nvim/search.c", ["                 || STRNCMP(ptr, \"endif\", 5) == 0", "                 || STRNCMP(ptr, \"el\", 2) == 0)", "            hash_dir = 1;"], "whitespace/alignment"]
["src/nvim/search.c", ["        }", "        /* Are we on a comment? */", "        else if (linep[pos.col] == '/') {"], "readability/old_style_comment"]
["src/nvim/search.c", ["        /* Are we on a comment? */", "        else if (linep[pos.col] == '/') {", "          if (linep[pos.col + 1] == '*') {"], "whitespace/newline"]
["src/nvim/search.c", ["", "      /*", "       * If we are not on a comment or the # at the start of a line, then"], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (!hash_dir && !comment_dir) {", "        /*", "         * Find the brace under or after the cursor."], "readability/old_style_comment"]
["src/nvim/search.c", ["         */", "        if (linep[pos.col] == NUL && pos.col)", "          --pos.col;"], "readability/braces"]
["src/nvim/search.c", ["        if (linep[pos.col] == NUL && pos.col)", "          --pos.col;", "        for (;; ) {"], "readability/increment"]
["src/nvim/search.c", ["          initc = PTR2CHAR(linep + pos.col);", "          if (initc == NUL)", "            break;"], "readability/braces"]
["src/nvim/search.c", ["        if (!findc) {", "          /* no brace in the line, maybe use \"  #if\" then */", "          if (!cpo_match && *skipwhite(linep) == '#')"], "readability/old_style_comment"]
["src/nvim/search.c", ["          /* no brace in the line, maybe use \"  #if\" then */", "          if (!cpo_match && *skipwhite(linep) == '#')", "            hash_dir = 1;"], "readability/braces"]
["src/nvim/search.c", ["            hash_dir = 1;", "          else", "            return NULL;"], "readability/braces"]
["src/nvim/search.c", ["", "          /* Set \"match_escaped\" if there are an odd number of", "           * backslashes. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["           * backslashes. */", "          for (col = pos.col; check_prevcol(linep, col, '\\\\', &col); )", "            bslcnt++;"], "readability/braces"]
["src/nvim/search.c", ["    if (hash_dir) {", "      /*", "       * Look for matching #if, #else, #elif, or #endif"], "readability/old_style_comment"]
["src/nvim/search.c", ["        ptr = skipwhite(skipwhite(linep) + 1);", "        if (STRNCMP(ptr, \"if\", 2) == 0 || STRNCMP(ptr, \"el\", 2) == 0)", "          hash_dir = 1;"], "readability/braces"]
["src/nvim/search.c", ["          hash_dir = 1;", "        else if (STRNCMP(ptr, \"endif\", 5) == 0)", "          hash_dir = -1;"], "readability/braces"]
["src/nvim/search.c", ["          hash_dir = -1;", "        else", "          return NULL;"], "readability/braces"]
["src/nvim/search.c", ["        if (hash_dir > 0) {", "          if (pos.lnum == curbuf->b_ml.ml_line_count)", "            break;"], "readability/braces"]
["src/nvim/search.c", ["            break;", "        } else if (pos.lnum == 1)", "          break;"], "readability/braces"]
["src/nvim/search.c", ["        linep = ml_get(pos.lnum);", "        line_breakcheck();              /* check for CTRL-C typed */", "        ptr = skipwhite(linep);"], "readability/old_style_comment"]
["src/nvim/search.c", ["        ptr = skipwhite(linep);", "        if (*ptr != '#')", "          continue;"], "readability/braces"]
["src/nvim/search.c", ["          continue;", "        pos.col = (colnr_T) (ptr - linep);", "        ptr = skipwhite(ptr + 1);"], "whitespace/cast"]
["src/nvim/search.c", ["        if (hash_dir > 0) {", "          if (STRNCMP(ptr, \"if\", 2) == 0)", "            count++;"], "readability/braces"]
["src/nvim/search.c", ["            count++;", "          else if (STRNCMP(ptr, \"el\", 2) == 0) {", "            if (count == 0)"], "readability/braces"]
["src/nvim/search.c", ["          else if (STRNCMP(ptr, \"el\", 2) == 0) {", "            if (count == 0)", "              return &pos;"], "readability/braces"]
["src/nvim/search.c", ["          } else if (STRNCMP(ptr, \"endif\", 5) == 0) {", "            if (count == 0)", "              return &pos;"], "readability/braces"]
["src/nvim/search.c", ["          if (STRNCMP(ptr, \"if\", 2) == 0) {", "            if (count == 0)", "              return &pos;"], "readability/braces"]
["src/nvim/search.c", ["          } else if (initc == '#' && STRNCMP(ptr, \"el\", 2) == 0) {", "            if (count == 0)", "              return &pos;"], "readability/braces"]
["src/nvim/search.c", ["              return &pos;", "          } else if (STRNCMP(ptr, \"endif\", 5) == 0)", "            count++;"], "readability/braces"]
["src/nvim/search.c", ["", "  /* backward search: Check if this line contains a single-line comment */", "  if ((backwards && comment_dir)"], "readability/old_style_comment"]
["src/nvim/search.c", ["  /* backward search: Check if this line contains a single-line comment */", "  if ((backwards && comment_dir)", "      || lisp"], "readability/braces"]
["src/nvim/search.c", ["  while (!got_int) {", "    /*", "     * Go to the next position, forward or backward. We could use"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (backwards) {", "      /* char to match is inside of comment, don't search outside */", "      if (lispcomm && pos.col < (colnr_T)comment_col)"], "readability/old_style_comment"]
["src/nvim/search.c", ["      /* char to match is inside of comment, don't search outside */", "      if (lispcomm && pos.col < (colnr_T)comment_col)", "        break;"], "readability/braces"]
["src/nvim/search.c", ["        break;", "      if (pos.col == 0) {               /* at start of line, go to prev. one */", "        if (pos.lnum == 1)              /* start of file */"], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (pos.col == 0) {               /* at start of line, go to prev. one */", "        if (pos.lnum == 1)              /* start of file */", "          break;"], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (pos.col == 0) {               /* at start of line, go to prev. one */", "        if (pos.lnum == 1)              /* start of file */", "          break;"], "readability/braces"]
["src/nvim/search.c", ["          break;", "        --pos.lnum;", ""], "readability/increment"]
["src/nvim/search.c", ["", "        if (maxtravel > 0 && ++traveled > maxtravel)", "          break;"], "readability/braces"]
["src/nvim/search.c", ["        linep = ml_get(pos.lnum);", "        pos.col = (colnr_T)STRLEN(linep);         /* pos.col on trailing NUL */", "        do_quotes = -1;"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "        /* Check if this line contains a single-line comment */", "        if (comment_dir"], "readability/old_style_comment"]
["src/nvim/search.c", ["        /* Check if this line contains a single-line comment */", "        if (comment_dir", "            || lisp"], "readability/braces"]
["src/nvim/search.c", ["          comment_col = check_linecomment(linep);", "        /* skip comment */", "        if (lisp && comment_col != MAXCOL)"], "readability/old_style_comment"]
["src/nvim/search.c", ["        /* skip comment */", "        if (lisp && comment_col != MAXCOL)", "          pos.col = comment_col;"], "readability/braces"]
["src/nvim/search.c", ["      }", "    } else {                          /* forward search */", "      if (linep[pos.col] == NUL"], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (linep[pos.col] == NUL", "          /* at end of line, go to next one */", "          /* don't search for match in comment */"], "readability/old_style_comment"]
["src/nvim/search.c", ["          /* at end of line, go to next one */", "          /* don't search for match in comment */", "          || (lisp && comment_col != MAXCOL"], "readability/old_style_comment"]
["src/nvim/search.c", ["          ) {", "        if (pos.lnum == curbuf->b_ml.ml_line_count          /* end of file */", "            /* line is exhausted and comment with it,"], "readability/old_style_comment"]
["src/nvim/search.c", ["          ) {", "        if (pos.lnum == curbuf->b_ml.ml_line_count          /* end of file */", "            /* line is exhausted and comment with it,"], "readability/braces"]
["src/nvim/search.c", ["        if (pos.lnum == curbuf->b_ml.ml_line_count          /* end of file */", "            /* line is exhausted and comment with it,", "             * don't search for match in code */"], "readability/old_style_comment"]
["src/nvim/search.c", ["          break;", "        ++pos.lnum;", ""], "readability/increment"]
["src/nvim/search.c", ["", "        if (maxtravel && traveled++ > maxtravel)", "          break;"], "readability/braces"]
["src/nvim/search.c", ["        line_breakcheck();", "        if (lisp)           /* find comment pos in new line */", "          comment_col = check_linecomment(linep);"], "readability/old_style_comment"]
["src/nvim/search.c", ["        line_breakcheck();", "        if (lisp)           /* find comment pos in new line */", "          comment_col = check_linecomment(linep);"], "readability/braces"]
["src/nvim/search.c", ["    if (comment_dir) {", "      /* Note: comments do not nest, and we ignore quotes in them */", "      /* TODO: ignore comment brackets inside strings */"], "readability/old_style_comment"]
["src/nvim/search.c", ["      /* Note: comments do not nest, and we ignore quotes in them */", "      /* TODO: ignore comment brackets inside strings */", "      if (comment_dir == FORWARD) {"], "readability/old_style_comment"]
["src/nvim/search.c", ["        }", "      } else {    /* Searching backwards */", "        /*"], "readability/old_style_comment"]
["src/nvim/search.c", ["      } else {    /* Searching backwards */", "        /*", "         * A comment may contain / * or / /, it may also start or end"], "readability/old_style_comment"]
["src/nvim/search.c", ["         */", "        if (pos.col == 0)", "          continue;"], "readability/braces"]
["src/nvim/search.c", ["          continue;", "        else if (raw_string)", "        {"], "readability/braces"]
["src/nvim/search.c", ["        else if (raw_string)", "        {", "          if (linep[pos.col - 1] == 'R'"], "whitespace/braces"]
["src/nvim/search.c", ["        {", "          if (linep[pos.col - 1] == 'R'", "              && linep[pos.col] == '\"'"], "readability/braces"]
["src/nvim/search.c", ["              && vim_strchr(linep + pos.col + 1, '(') != NULL)", "          {", "            /* Possible start of raw string. Now that we have the"], "whitespace/braces"]
["src/nvim/search.c", ["          {", "            /* Possible start of raw string. Now that we have the", "             * delimiter we can check if it ends before where we"], "readability/old_style_comment"]
["src/nvim/search.c", ["             * raw string start. */", "            if (!find_rawstring_end(linep, &pos,", "                  count > 0 ? &match_pos : &curwin->w_cursor))"], "readability/braces"]
["src/nvim/search.c", ["            if (!find_rawstring_end(linep, &pos,", "                  count > 0 ? &match_pos : &curwin->w_cursor))", "            {"], "whitespace/alignment"]
["src/nvim/search.c", ["                  count > 0 ? &match_pos : &curwin->w_cursor))", "            {", "              count++;"], "whitespace/braces"]
["src/nvim/search.c", ["            }", "            linep = ml_get(pos.lnum); /* may have been released */", "          }"], "readability/old_style_comment"]
["src/nvim/search.c", ["        } else if (linep[pos.col - 1] == '*' && linep[pos.col] == '/') {", "          if (count > 0)", "            pos = match_pos;"], "readability/braces"]
["src/nvim/search.c", ["            pos = match_pos;", "          else if (pos.col > 1 && linep[pos.col - 2] == '/'", "                   && (int)pos.col <= comment_col)"], "readability/braces"]
["src/nvim/search.c", ["            pos.col -= 2;", "          else if (ignore_cend)", "            continue;"], "readability/braces"]
["src/nvim/search.c", ["            continue;", "          else", "            return NULL;"], "readability/braces"]
["src/nvim/search.c", ["", "    /*", "     * If smart matching ('cpoptions' does not contain '%'), braces inside"], "readability/old_style_comment"]
["src/nvim/search.c", ["     */", "    if (cpo_match)", "      do_quotes = 0;"], "readability/braces"]
["src/nvim/search.c", ["      do_quotes = 0;", "    else if (do_quotes == -1) {", "      /*"], "readability/braces"]
["src/nvim/search.c", ["    else if (do_quotes == -1) {", "      /*", "       * Count the number of quotes in the line, skipping \\\" and '\"'."], "readability/old_style_comment"]
["src/nvim/search.c", ["      at_start = do_quotes;", "      for (ptr = linep; *ptr; ++ptr) {", "        if (ptr == linep + pos.col + backwards)"], "readability/increment"]
["src/nvim/search.c", ["      for (ptr = linep; *ptr; ++ptr) {", "        if (ptr == linep + pos.col + backwards)", "          at_start = (do_quotes & 1);"], "readability/braces"]
["src/nvim/search.c", ["          at_start = (do_quotes & 1);", "        if (*ptr == '\"'", "            && (ptr == linep || ptr[-1] != '\\'' || ptr[1] != '\\''))"], "readability/braces"]
["src/nvim/search.c", ["            && (ptr == linep || ptr[-1] != '\\'' || ptr[1] != '\\''))", "          ++do_quotes;", "        if (*ptr == '\\\\' && ptr[1] != NUL)"], "readability/increment"]
["src/nvim/search.c", ["          ++do_quotes;", "        if (*ptr == '\\\\' && ptr[1] != NUL)", "          ++ptr;"], "readability/braces"]
["src/nvim/search.c", ["        if (*ptr == '\\\\' && ptr[1] != NUL)", "          ++ptr;", "      }"], "readability/increment"]
["src/nvim/search.c", ["      }", "      do_quotes &= 1;               /* result is 1 with even number of quotes */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["", "      /*", "       * If we find an uneven count, check current line and previous"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "          /* ml_get() only keeps one line, need to get linep again */", "          linep = ml_get(pos.lnum);"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /*", "     * If 'smartmatch' is set:"], "readability/old_style_comment"]
["src/nvim/search.c", ["    case NUL:", "      /* at end of line without trailing backslash, reset inquote */", "      if (pos.col == 0 || linep[pos.col - 1] != '\\\\') {"], "readability/old_style_comment"]
["src/nvim/search.c", ["    case '\"':", "      /* a quote that is preceded with an odd number of backslashes is", "       * ignored */"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "        for (col = pos.col - 1; col >= 0; --col)", "          if (linep[col] != '\\\\')"], "readability/braces"]
["src/nvim/search.c", ["", "        for (col = pos.col - 1; col >= 0; --col)", "          if (linep[col] != '\\\\')"], "readability/increment"]
["src/nvim/search.c", ["        for (col = pos.col - 1; col >= 0; --col)", "          if (linep[col] != '\\\\')", "            break;"], "readability/braces"]
["src/nvim/search.c", ["", "    /*", "     * If smart matching ('cpoptions' does not contain '%'):"], "readability/old_style_comment"]
["src/nvim/search.c", ["    default:", "      /*", "       * For Lisp skip over backslashed (), {} and []."], "readability/old_style_comment"]
["src/nvim/search.c", ["       */", "      if (curbuf->b_p_lisp", "          && vim_strchr((char_u *)\"(){}[]\", c) != NULL"], "readability/braces"]
["src/nvim/search.c", ["", "      /* Check for match outside of quotes, and inside of", "       * quotes when the start is also inside of quotes. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["        if (!cpo_bsl) {", "          for (col = pos.col; check_prevcol(linep, col, '\\\\', &col); )", "            bslcnt++;"], "readability/braces"]
["src/nvim/search.c", ["        }", "        /* Only accept a match when 'M' is in 'cpo' or when escaping", "         * is what we expect. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["        if (cpo_bsl || (bslcnt & 1) == match_escaped) {", "          if (c == initc)", "            count++;"], "readability/braces"]
["src/nvim/search.c", ["            count++;", "          else {", "            if (count == 0)"], "readability/braces"]
["src/nvim/search.c", ["            count++;", "          else {", "            if (count == 0)"], "readability/braces"]
["src/nvim/search.c", ["          else {", "            if (count == 0)", "              return &pos;"], "readability/braces"]
["src/nvim/search.c", ["  }", "  return (pos_T *)NULL;         /* never found it */", "}"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Check if line[] contains a / / comment."], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (curbuf->b_p_lisp) {", "    if (vim_strchr(p, ';') != NULL) {   /* there may be comments */", "      int in_str = FALSE;       /* inside of string */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (vim_strchr(p, ';') != NULL) {   /* there may be comments */", "      int in_str = FALSE;       /* inside of string */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (vim_strchr(p, ';') != NULL) {   /* there may be comments */", "      int in_str = FALSE;       /* inside of string */", ""], "readability/bool"]
["src/nvim/search.c", ["          if (in_str) {", "            if (*(p - 1) != '\\\\')             /* skip escaped quote */", "              in_str = FALSE;"], "readability/old_style_comment"]
["src/nvim/search.c", ["          if (in_str) {", "            if (*(p - 1) != '\\\\')             /* skip escaped quote */", "              in_str = FALSE;"], "readability/braces"]
["src/nvim/search.c", ["            if (*(p - 1) != '\\\\')             /* skip escaped quote */", "              in_str = FALSE;", "          } else if (p == line || ((p - line) >= 2"], "readability/bool"]
["src/nvim/search.c", ["              in_str = FALSE;", "          } else if (p == line || ((p - line) >= 2", "                                   /* skip #\\\" form */"], "readability/braces"]
["src/nvim/search.c", ["          } else if (p == line || ((p - line) >= 2", "                                   /* skip #\\\" form */", "                                   && *(p - 1) != '\\\\' && *(p - 2) != '#'))"], "readability/old_style_comment"]
["src/nvim/search.c", ["                                   && *(p - 1) != '\\\\' && *(p - 2) != '#'))", "            in_str = TRUE;", "        } else if (!in_str && ((p - line) < 2"], "readability/bool"]
["src/nvim/search.c", ["            in_str = TRUE;", "        } else if (!in_str && ((p - line) < 2", "                               || (*(p - 1) != '\\\\' && *(p - 2) != '#')))"], "readability/braces"]
["src/nvim/search.c", ["                               || (*(p - 1) != '\\\\' && *(p - 2) != '#')))", "          break;                /* found! */", "        ++p;"], "readability/old_style_comment"]
["src/nvim/search.c", ["          break;                /* found! */", "        ++p;", "      }"], "readability/increment"]
["src/nvim/search.c", ["      }", "    } else", "      p = NULL;"], "readability/braces"]
["src/nvim/search.c", ["      p = NULL;", "  } else", "    while ((p = vim_strchr(p, '/')) != NULL) {"], "readability/braces"]
["src/nvim/search.c", ["    while ((p = vim_strchr(p, '/')) != NULL) {", "      /* accept a double /, unless it's preceded with * and followed by *,", "       * because * / / * is an end and start of a C comment */"], "readability/old_style_comment"]
["src/nvim/search.c", ["       * because * / / * is an end and start of a C comment */", "      if (p[1] == '/' && (p == line || p[-1] != '*' || p[2] != '*'))", "        break;"], "readability/braces"]
["src/nvim/search.c", ["        break;", "      ++p;", "    }"], "readability/increment"]
["src/nvim/search.c", ["", "  if (p == NULL)", "    return MAXCOL;"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * Move cursor briefly to character matching the one under the cursor."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * Only show match for chars in the 'matchpairs' option."], "readability/old_style_comment"]
["src/nvim/search.c", ["   */", "  /* 'matchpairs' is \"x:y,x:y\" */", "  for (p = curbuf->b_p_mps; *p != NUL; ++p) {"], "readability/old_style_comment"]
["src/nvim/search.c", ["  /* 'matchpairs' is \"x:y,x:y\" */", "  for (p = curbuf->b_p_mps; *p != NUL; ++p) {", "    if (PTR2CHAR(p) == c && (curwin->w_p_rl ^ p_ri))"], "readability/increment"]
["src/nvim/search.c", ["  for (p = curbuf->b_p_mps; *p != NUL; ++p) {", "    if (PTR2CHAR(p) == c && (curwin->w_p_rl ^ p_ri))", "      break;"], "readability/braces"]
["src/nvim/search.c", ["  } else if (lpos->lnum >= curwin->w_topline", "      && lpos->lnum < curwin->w_botline) {", "    if (!curwin->w_p_wrap) {"], "whitespace/alignment"]
["src/nvim/search.c", ["      ui_flush();", "      /* Restore dollar_vcol(), because setcursor() may call curs_rows()", "       * which resets it if the matching position is in a previous line"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "      /*", "       * brief pause, unless 'm' is present in 'cpo' and a character is"], "readability/old_style_comment"]
["src/nvim/search.c", ["  pos = curwin->w_cursor;", "  if (dir == FORWARD)", "    func = incl;"], "readability/braces"]
["src/nvim/search.c", ["    func = incl;", "  else", "    func = decl;"], "readability/braces"]
["src/nvim/search.c", ["", "    for (;; ) {                 /* find end of sentence */", "      c = gchar_pos(&pos);"], "readability/old_style_comment"]
["src/nvim/search.c", ["      c = gchar_pos(&pos);", "      if (c == NUL || (pos.col == 0 && startPS(pos.lnum, NUL, FALSE))) {", "        if (dir == BACKWARD && pos.lnum != startlnum)"], "readability/bool"]
["src/nvim/search.c", ["      if (c == NUL || (pos.col == 0 && startPS(pos.lnum, NUL, FALSE))) {", "        if (dir == BACKWARD && pos.lnum != startlnum)", "          ++pos.lnum;"], "readability/braces"]
["src/nvim/search.c", ["        if (dir == BACKWARD && pos.lnum != startlnum)", "          ++pos.lnum;", "        break;"], "readability/increment"]
["src/nvim/search.c", ["        do", "          if ((c = inc(&tpos)) == -1)", "            break;"], "readability/braces"]
["src/nvim/search.c", ["            break;", "        while (vim_strchr((char_u *)\")]\\\"'\", c = gchar_pos(&tpos))", "               != NULL);"], "readability/braces"]
["src/nvim/search.c", ["        while (vim_strchr((char_u *)\")]\\\"'\", c = gchar_pos(&tpos))", "               != NULL);", "        if (c == -1  || (!cpo_J && (c == ' ' || c == '\\t')) || c == NUL"], "whitespace/empty_loop_body"]
["src/nvim/search.c", ["          pos = tpos;", "          if (gchar_pos(&pos) == NUL)           /* skip NUL at EOL */", "            inc(&pos);"], "readability/old_style_comment"]
["src/nvim/search.c", ["          pos = tpos;", "          if (gchar_pos(&pos) == NUL)           /* skip NUL at EOL */", "            inc(&pos);"], "readability/braces"]
["src/nvim/search.c", ["      if ((*func)(&pos) == -1) {", "        if (count)", "          return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["found:", "    /* skip white space */", "    while (!noskip && ((c = gchar_pos(&pos)) == ' ' || c == '\\t'))"], "readability/old_style_comment"]
["src/nvim/search.c", ["    /* skip white space */", "    while (!noskip && ((c = gchar_pos(&pos)) == ' ' || c == '\\t'))", "      if (incl(&pos) == -1)"], "readability/braces"]
["src/nvim/search.c", ["    while (!noskip && ((c = gchar_pos(&pos)) == ' ' || c == '\\t'))", "      if (incl(&pos) == -1)", "        break;"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * Find the next paragraph or section in direction 'dir'."], "readability/old_style_comment"]
["src/nvim/search.c", ["bool", "findpar (", "    bool *pincl,        /* Return: true if last char is to be included */"], "whitespace/parens"]
["src/nvim/search.c", ["findpar (", "    bool *pincl,        /* Return: true if last char is to be included */", "    int dir,"], "readability/old_style_comment"]
["src/nvim/search.c", ["  linenr_T curr;", "  bool did_skip;            /* true after separating lines have been skipped */", "  bool first;               /* true on first line */"], "readability/old_style_comment"]
["src/nvim/search.c", ["  bool did_skip;            /* true after separating lines have been skipped */", "  bool first;               /* true on first line */", "  linenr_T fold_first;      /* first line of a closed fold */"], "readability/old_style_comment"]
["src/nvim/search.c", ["  bool first;               /* true on first line */", "  linenr_T fold_first;      /* first line of a closed fold */", "  linenr_T fold_last;       /* last line of a closed fold */"], "readability/old_style_comment"]
["src/nvim/search.c", ["  linenr_T fold_first;      /* first line of a closed fold */", "  linenr_T fold_last;       /* last line of a closed fold */", "  bool fold_skipped;        /* true if a closed fold was skipped this"], "readability/old_style_comment"]
["src/nvim/search.c", ["  linenr_T fold_last;       /* last line of a closed fold */", "  bool fold_skipped;        /* true if a closed fold was skipped this", "                               iteration */"], "readability/multiline_comment"]
["src/nvim/search.c", ["  linenr_T fold_last;       /* last line of a closed fold */", "  bool fold_skipped;        /* true if a closed fold was skipped this", "                               iteration */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    for (first = true;; first = false) {", "      if (*ml_get(curr) != NUL)", "        did_skip = true;"], "readability/braces"]
["src/nvim/search.c", ["", "      /* skip folded lines */", "      fold_skipped = false;"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "      if (!first && did_skip && startPS(curr, what, both))", "        break;"], "readability/braces"]
["src/nvim/search.c", ["", "      if (fold_skipped)", "        curr -= dir;"], "readability/braces"]
["src/nvim/search.c", ["      if ((curr += dir) < 1 || curr > curbuf->b_ml.ml_line_count) {", "        if (count)", "          return false;"], "readability/braces"]
["src/nvim/search.c", ["  setpcmark();", "  if (both && *ml_get(curr) == '}')     /* include line with '}' */", "    ++curr;"], "readability/old_style_comment"]
["src/nvim/search.c", ["  setpcmark();", "  if (both && *ml_get(curr) == '}')     /* include line with '}' */", "    ++curr;"], "readability/braces"]
["src/nvim/search.c", ["  if (both && *ml_get(curr) == '}')     /* include line with '}' */", "    ++curr;", "  curwin->w_cursor.lnum = curr;"], "readability/increment"]
["src/nvim/search.c", ["    }", "  } else", "    curwin->w_cursor.col = 0;"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * check if the string 's' is a nroff macro that is in option 'opt'"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  for (macro = opt; macro[0]; ++macro) {", "    /* Accept two characters in the option being equal to two characters"], "readability/increment"]
["src/nvim/search.c", ["  for (macro = opt; macro[0]; ++macro) {", "    /* Accept two characters in the option being equal to two characters", "     * in the line.  A space in the option matches with a space in the"], "readability/old_style_comment"]
["src/nvim/search.c", ["     * line or the line having ended. */", "    if (       (macro[0] == s[0]", "                || (macro[0] == ' '"], "readability/braces"]
["src/nvim/search.c", ["                    && (s[0] == NUL || s[0] == ' ')))", "               && (macro[1] == s[1]", "                   || ((macro[1] == NUL || macro[1] == ' ')"], "whitespace/alignment"]
["src/nvim/search.c", ["      break;", "    ++macro;", "    if (macro[0] == NUL)"], "readability/increment"]
["src/nvim/search.c", ["    ++macro;", "    if (macro[0] == NUL)", "      break;"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * startPS: return TRUE if line 'lnum' is the start of a section or paragraph."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * The following routines do the word searches performed by the 'w', 'W',"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * To perform these searches, characters are placed into one of three"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "static int cls_bigword;         /* TRUE for \"W\", \"B\" or \"E\" */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * cls() - returns the class of character at curwin->w_cursor"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * fwd_word(count, type, eol) - move forward one word"], "readability/old_style_comment"]
["src/nvim/search.c", ["    long count,", "    int bigword,                /* \"W\", \"E\" or \"B\" */", "    int eol"], "readability/old_style_comment"]
["src/nvim/search.c", ["{", "  int sclass;               /* starting class */", "  int i;"], "readability/old_style_comment"]
["src/nvim/search.c", ["  while (--count >= 0) {", "    /* When inside a range of folded lines, move to the last char of the", "     * last line. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /*", "     * We always move at least one character, unless on the last"], "readability/old_style_comment"]
["src/nvim/search.c", ["    i = inc_cursor();", "    if (i == -1 || (i >= 1 && last_line))     /* started at last char in file */", "      return FAIL;"], "readability/old_style_comment"]
["src/nvim/search.c", ["    i = inc_cursor();", "    if (i == -1 || (i >= 1 && last_line))     /* started at last char in file */", "      return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["      return FAIL;", "    if (i >= 1 && eol && count == 0)          /* started at last char in line */", "      return OK;"], "readability/old_style_comment"]
["src/nvim/search.c", ["      return FAIL;", "    if (i >= 1 && eol && count == 0)          /* started at last char in line */", "      return OK;"], "readability/braces"]
["src/nvim/search.c", ["", "    /*", "     * Go one char past end of current word (if any)"], "readability/old_style_comment"]
["src/nvim/search.c", ["     */", "    if (sclass != 0)", "      while (cls() == sclass) {"], "readability/braces"]
["src/nvim/search.c", ["        i = inc_cursor();", "        if (i == -1 || (i >= 1 && eol && count == 0))", "          return OK;"], "readability/braces"]
["src/nvim/search.c", ["", "    /*", "     * go to next non-white"], "readability/old_style_comment"]
["src/nvim/search.c", ["    while (cls() == 0) {", "      /*", "       * We'll stop if we land on a blank line"], "readability/old_style_comment"]
["src/nvim/search.c", ["       */", "      if (curwin->w_cursor.col == 0 && *get_cursor_line_ptr() == NUL)", "        break;"], "readability/braces"]
["src/nvim/search.c", ["      i = inc_cursor();", "      if (i == -1 || (i >= 1 && eol && count == 0))", "        return OK;"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * bck_word() - move backward 'count' words"], "readability/old_style_comment"]
["src/nvim/search.c", ["{", "  int sclass;               /* starting class */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["  while (--count >= 0) {", "    /* When inside a range of folded lines, move to the first char of the", "     * first line. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["     * first line. */", "    if (hasFolding(curwin->w_cursor.lnum, &curwin->w_cursor.lnum, NULL))", "      curwin->w_cursor.col = 0;"], "readability/braces"]
["src/nvim/search.c", ["    sclass = cls();", "    if (dec_cursor() == -1)             /* started at start of file */", "      return FAIL;"], "readability/old_style_comment"]
["src/nvim/search.c", ["    sclass = cls();", "    if (dec_cursor() == -1)             /* started at start of file */", "      return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["    if (!stop || sclass == cls() || sclass == 0) {", "      /*", "       * Skip white space before the word."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "      /*", "       * Move backward to start of this word."], "readability/old_style_comment"]
["src/nvim/search.c", ["       */", "      if (skip_chars(cls(), BACKWARD))", "        return OK;"], "readability/braces"]
["src/nvim/search.c", ["", "    inc_cursor();                       /* overshot - forward one */", "finished:"], "readability/old_style_comment"]
["src/nvim/search.c", ["finished:", "    stop = FALSE;", "  }"], "readability/bool"]
["src/nvim/search.c", ["", "/*", " * end_word() - move to the end of the word"], "readability/old_style_comment"]
["src/nvim/search.c", ["{", "  int sclass;               /* starting class */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["  while (--count >= 0) {", "    /* When inside a range of folded lines, move to the last char of the", "     * last line. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    sclass = cls();", "    if (inc_cursor() == -1)", "      return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["", "    /*", "     * If we're in the middle of a word, we just have to move to the end"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (cls() == sclass && sclass != 0) {", "      /*", "       * Move forward to end of the current word"], "readability/old_style_comment"]
["src/nvim/search.c", ["       */", "      if (skip_chars(sclass, FORWARD))", "        return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["    } else if (!stop || sclass == 0) {", "      /*", "       * We were at the end of a word. Go to the end of the next word."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "      /*", "       * Move forward to the end of this word."], "readability/old_style_comment"]
["src/nvim/search.c", ["       */", "      if (skip_chars(cls(), FORWARD))", "        return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["    }", "    dec_cursor();                       /* overshot - one char backward */", "finished:"], "readability/old_style_comment"]
["src/nvim/search.c", ["finished:", "    stop = FALSE;                       /* we move only one word less */", "  }"], "readability/old_style_comment"]
["src/nvim/search.c", ["finished:", "    stop = FALSE;                       /* we move only one word less */", "  }"], "readability/bool"]
["src/nvim/search.c", ["", "/*", " * Move back to the end of the word."], "readability/old_style_comment"]
["src/nvim/search.c", ["    long count,", "    int bigword,                /* TRUE for \"B\" */", "    int eol                    /* TRUE: stop at end of line. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    int bigword,                /* TRUE for \"B\" */", "    int eol                    /* TRUE: stop at end of line. */", ")"], "readability/old_style_comment"]
["src/nvim/search.c", ["{", "  int sclass;               /* starting class */", "  int i;"], "readability/old_style_comment"]
["src/nvim/search.c", ["    sclass = cls();", "    if ((i = dec_cursor()) == -1)", "      return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["      return FAIL;", "    if (eol && i == 1)", "      return OK;"], "readability/braces"]
["src/nvim/search.c", ["", "    /*", "     * Move backward to before the start of this word."], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (sclass != 0) {", "      while (cls() == sclass)", "        if ((i = dec_cursor()) == -1 || (eol && i == 1))"], "readability/braces"]
["src/nvim/search.c", ["      while (cls() == sclass)", "        if ((i = dec_cursor()) == -1 || (eol && i == 1))", "          return OK;"], "readability/braces"]
["src/nvim/search.c", ["", "    /*", "     * Move backward to end of the previous word"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Skip a row of characters of the same class."], "readability/old_style_comment"]
["src/nvim/search.c", ["{", "  while (cls() == cclass)", "    if ((dir == FORWARD ? inc_cursor() : dec_cursor()) == -1)"], "readability/braces"]
["src/nvim/search.c", ["  while (cls() == cclass)", "    if ((dir == FORWARD ? inc_cursor() : dec_cursor()) == -1)", "      return TRUE;"], "readability/braces"]
["src/nvim/search.c", ["    if ((dir == FORWARD ? inc_cursor() : dec_cursor()) == -1)", "      return TRUE;", "  return FALSE;"], "readability/bool"]
["src/nvim/search.c", ["      return TRUE;", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/search.c", ["", "/*", " * Go back to the start of the word or the start of white space"], "readability/old_style_comment"]
["src/nvim/search.c", ["{", "  int sclass;                       /* starting class */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["  for (;; ) {", "    if (curwin->w_cursor.col == 0)          /* stop at start of line */", "      break;"], "readability/old_style_comment"]
["src/nvim/search.c", ["  for (;; ) {", "    if (curwin->w_cursor.col == 0)          /* stop at start of line */", "      break;"], "readability/braces"]
["src/nvim/search.c", ["    dec_cursor();", "    if (cls() != sclass) {                  /* stop at start of word */", "      inc_cursor();"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Skip count/2 sentences and count/2 separating white spaces."], "readability/old_style_comment"]
["src/nvim/search.c", ["    long count,", "    int at_start_sent              /* cursor is at start of sentence */", ")"], "readability/old_style_comment"]
["src/nvim/search.c", ["    findsent(FORWARD, 1L);", "    if (at_start_sent)", "      find_first_blank(&curwin->w_cursor);"], "readability/braces"]
["src/nvim/search.c", ["      find_first_blank(&curwin->w_cursor);", "    if (count == 0 || at_start_sent)", "      decl(&curwin->w_cursor);"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * Find word under cursor, cursor at end."], "readability/old_style_comment"]
["src/nvim/search.c", ["    long count,", "    int include,                    /* TRUE: include word and white space */", "    int bigword                    /* FALSE == word, TRUE == WORD */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    int include,                    /* TRUE: include word and white space */", "    int bigword                    /* FALSE == word, TRUE == WORD */", ")"], "readability/old_style_comment"]
["src/nvim/search.c", ["  bool inclusive = true;", "  int include_white = FALSE;", ""], "readability/bool"]
["src/nvim/search.c", ["", "  /* Correct cursor when 'selection' is exclusive */", "  if (VIsual_active && *p_sel == 'e' && lt(VIsual, curwin->w_cursor))"], "readability/old_style_comment"]
["src/nvim/search.c", ["  /* Correct cursor when 'selection' is exclusive */", "  if (VIsual_active && *p_sel == 'e' && lt(VIsual, curwin->w_cursor))", "    dec_cursor();"], "readability/braces"]
["src/nvim/search.c", ["", "  /*", "   * When Visual mode is not active, or when the VIsual area is only one"], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (!VIsual_active || equalpos(curwin->w_cursor, VIsual)) {", "    /*", "     * Go to start of current word or white space."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /*", "     * If the start is on white space, and white space should be included"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if ((cls() == 0) == include) {", "      if (end_word(1L, bigword, TRUE, TRUE) == FAIL)", "        return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["    if ((cls() == 0) == include) {", "      if (end_word(1L, bigword, TRUE, TRUE) == FAIL)", "        return FAIL;"], "readability/bool"]
["src/nvim/search.c", ["    } else {", "      /*", "       * If the start is not on white space, and white space should be"], "readability/old_style_comment"]
["src/nvim/search.c", ["       */", "      fwd_word(1L, bigword, TRUE);", "      if (curwin->w_cursor.col == 0)"], "readability/bool"]
["src/nvim/search.c", ["      fwd_word(1L, bigword, TRUE);", "      if (curwin->w_cursor.col == 0)", "        decl(&curwin->w_cursor);"], "readability/braces"]
["src/nvim/search.c", ["        decl(&curwin->w_cursor);", "      else", "        oneleft();"], "readability/braces"]
["src/nvim/search.c", ["", "      if (include)", "        include_white = TRUE;"], "readability/braces"]
["src/nvim/search.c", ["      if (include)", "        include_white = TRUE;", "    }"], "readability/bool"]
["src/nvim/search.c", ["    if (VIsual_active) {", "      /* should do something when inclusive == false ! */", "      VIsual = start_pos;"], "readability/old_style_comment"]
["src/nvim/search.c", ["      VIsual = start_pos;", "      redraw_curbuf_later(INVERTED);            /* update the inversion */", "    } else {"], "readability/old_style_comment"]
["src/nvim/search.c", ["    }", "    --count;", "  }"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * When count is still > 0, extend with more objects."], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (VIsual_active && lt(curwin->w_cursor, VIsual)) {", "      /*", "       * In Visual mode, with cursor at start: move cursor back."], "readability/old_style_comment"]
["src/nvim/search.c", ["       */", "      if (decl(&curwin->w_cursor) == -1)", "        return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["      if (include != (cls() != 0)) {", "        if (bck_word(1L, bigword, TRUE) == FAIL)", "          return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["      if (include != (cls() != 0)) {", "        if (bck_word(1L, bigword, TRUE) == FAIL)", "          return FAIL;"], "readability/bool"]
["src/nvim/search.c", ["      } else {", "        if (bckend_word(1L, bigword, TRUE) == FAIL)", "          return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["      } else {", "        if (bckend_word(1L, bigword, TRUE) == FAIL)", "          return FAIL;"], "readability/bool"]
["src/nvim/search.c", ["    } else {", "      /*", "       * Move cursor forward one word and/or white area."], "readability/old_style_comment"]
["src/nvim/search.c", ["       */", "      if (incl(&curwin->w_cursor) == -1)", "        return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["      if (include != (cls() == 0)) {", "        if (fwd_word(1L, bigword, TRUE) == FAIL && count > 1)", "          return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["      if (include != (cls() == 0)) {", "        if (fwd_word(1L, bigword, TRUE) == FAIL && count > 1)", "          return FAIL;"], "readability/bool"]
["src/nvim/search.c", ["          return FAIL;", "        /*", "         * If end is just past a new-line, we don't want to include"], "readability/old_style_comment"]
["src/nvim/search.c", ["         */", "        if (oneleft() == FAIL)", "          inclusive = false;"], "readability/braces"]
["src/nvim/search.c", ["      } else {", "        if (end_word(1L, bigword, TRUE, TRUE) == FAIL)", "          return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["      } else {", "        if (end_word(1L, bigword, TRUE, TRUE) == FAIL)", "          return FAIL;"], "readability/bool"]
["src/nvim/search.c", ["    }", "    --count;", "  }"], "readability/increment"]
["src/nvim/search.c", ["                        || (curwin->w_cursor.col == 0 && !inclusive))) {", "    /*", "     * If we don't include white space at the end, move the start"], "readability/old_style_comment"]
["src/nvim/search.c", ["     */", "    pos = curwin->w_cursor;     /* save cursor position */", "    curwin->w_cursor = start_pos;"], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (cls() == 0 && curwin->w_cursor.col > 0) {", "        if (VIsual_active)", "          VIsual = curwin->w_cursor;"], "readability/braces"]
["src/nvim/search.c", ["          VIsual = curwin->w_cursor;", "        else", "          oap->start = curwin->w_cursor;"], "readability/braces"]
["src/nvim/search.c", ["    }", "    curwin->w_cursor = pos;     /* put cursor back at end */", "  }"], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (VIsual_active) {", "    if (*p_sel == 'e' && inclusive && ltoreq(VIsual, curwin->w_cursor))", "      inc_cursor();"], "readability/braces"]
["src/nvim/search.c", ["      VIsual_mode = 'v';", "      redraw_cmdline = TRUE;                    /* show mode later */", "    }"], "readability/old_style_comment"]
["src/nvim/search.c", ["      VIsual_mode = 'v';", "      redraw_cmdline = TRUE;                    /* show mode later */", "    }"], "readability/bool"]
["src/nvim/search.c", ["    }", "  } else", "    oap->inclusive = inclusive;"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * Find sentence(s) under the cursor, cursor at end."], "readability/old_style_comment"]
["src/nvim/search.c", ["  pos = start_pos;", "  findsent(FORWARD, 1L);        /* Find start of next sentence. */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * When the Visual area is bigger than one character: Extend it."], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (lt(start_pos, VIsual)) {", "      /*", "       * Cursor at start of Visual area."], "readability/old_style_comment"]
["src/nvim/search.c", ["       */", "      at_start_sent = TRUE;", "      decl(&pos);"], "readability/bool"]
["src/nvim/search.c", ["        if (!ascii_iswhite(c)) {", "          at_start_sent = FALSE;", "          break;"], "readability/bool"]
["src/nvim/search.c", ["        findsent(BACKWARD, 1L);", "        if (equalpos(curwin->w_cursor, start_pos))", "          at_start_sent = TRUE;            /* exactly at start of sentence */"], "readability/braces"]
["src/nvim/search.c", ["        if (equalpos(curwin->w_cursor, start_pos))", "          at_start_sent = TRUE;            /* exactly at start of sentence */", "        else"], "readability/old_style_comment"]
["src/nvim/search.c", ["        if (equalpos(curwin->w_cursor, start_pos))", "          at_start_sent = TRUE;            /* exactly at start of sentence */", "        else"], "readability/bool"]
["src/nvim/search.c", ["          at_start_sent = TRUE;            /* exactly at start of sentence */", "        else", "          /* inside a sentence, go to its end (start of next) */"], "readability/braces"]
["src/nvim/search.c", ["        else", "          /* inside a sentence, go to its end (start of next) */", "          findsent(FORWARD, 1L);"], "readability/old_style_comment"]
["src/nvim/search.c", ["      }", "      if (include)              /* \"as\" gets twice as much as \"is\" */", "        count *= 2;"], "readability/old_style_comment"]
["src/nvim/search.c", ["      }", "      if (include)              /* \"as\" gets twice as much as \"is\" */", "        count *= 2;"], "readability/braces"]
["src/nvim/search.c", ["      while (count--) {", "        if (at_start_sent)", "          find_first_blank(&curwin->w_cursor);"], "readability/braces"]
["src/nvim/search.c", ["        c = gchar_cursor();", "        if (!at_start_sent || (!include && !ascii_iswhite(c)))", "          findsent(BACKWARD, 1L);"], "readability/braces"]
["src/nvim/search.c", ["    } else {", "      /*", "       * Cursor at end of Visual area."], "readability/old_style_comment"]
["src/nvim/search.c", ["      incl(&pos);", "      at_start_sent = TRUE;", "      if (!equalpos(pos, curwin->w_cursor)) {     /* not just before a sentence */"], "readability/bool"]
["src/nvim/search.c", ["      at_start_sent = TRUE;", "      if (!equalpos(pos, curwin->w_cursor)) {     /* not just before a sentence */", "        at_start_sent = FALSE;"], "readability/old_style_comment"]
["src/nvim/search.c", ["      at_start_sent = TRUE;", "      if (!equalpos(pos, curwin->w_cursor)) {     /* not just before a sentence */", "        at_start_sent = FALSE;"], "whitespace/line_length"]
["src/nvim/search.c", ["      if (!equalpos(pos, curwin->w_cursor)) {     /* not just before a sentence */", "        at_start_sent = FALSE;", "        while (lt(pos, curwin->w_cursor)) {"], "readability/bool"]
["src/nvim/search.c", ["          if (!ascii_iswhite(c)) {", "            at_start_sent = TRUE;", "            break;"], "readability/bool"]
["src/nvim/search.c", ["        }", "        if (at_start_sent)              /* in the sentence */", "          findsent(BACKWARD, 1L);"], "readability/old_style_comment"]
["src/nvim/search.c", ["        }", "        if (at_start_sent)              /* in the sentence */", "          findsent(BACKWARD, 1L);"], "readability/braces"]
["src/nvim/search.c", ["          findsent(BACKWARD, 1L);", "        else                    /* in/before white before a sentence */", "          curwin->w_cursor = start_pos;"], "readability/old_style_comment"]
["src/nvim/search.c", ["          findsent(BACKWARD, 1L);", "        else                    /* in/before white before a sentence */", "          curwin->w_cursor = start_pos;"], "readability/braces"]
["src/nvim/search.c", ["", "      if (include)              /* \"as\" gets twice as much as \"is\" */", "        count *= 2;"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "      if (include)              /* \"as\" gets twice as much as \"is\" */", "        count *= 2;"], "readability/braces"]
["src/nvim/search.c", ["      findsent_forward(count, at_start_sent);", "      if (*p_sel == 'e')", "        ++curwin->w_cursor.col;"], "readability/braces"]
["src/nvim/search.c", ["      if (*p_sel == 'e')", "        ++curwin->w_cursor.col;", "    }"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * If the cursor started on a blank, check if it is just before the start"], "readability/old_style_comment"]
["src/nvim/search.c", ["   */", "  while (c = gchar_pos(&pos), ascii_iswhite(c))", "    incl(&pos);"], "readability/braces"]
["src/nvim/search.c", ["  if (equalpos(pos, curwin->w_cursor)) {", "    start_blank = TRUE;", "    find_first_blank(&start_pos);       /* go back to first blank */"], "readability/bool"]
["src/nvim/search.c", ["    start_blank = TRUE;", "    find_first_blank(&start_pos);       /* go back to first blank */", "  } else {"], "readability/old_style_comment"]
["src/nvim/search.c", ["  } else {", "    start_blank = FALSE;", "    findsent(BACKWARD, 1L);"], "readability/bool"]
["src/nvim/search.c", ["  }", "  if (include)", "    ncount = count * 2;"], "readability/braces"]
["src/nvim/search.c", ["    ncount = count * 2;", "  else {", "    ncount = count;"], "readability/braces"]
["src/nvim/search.c", ["    ncount = count * 2;", "  else {", "    ncount = count;"], "readability/braces"]
["src/nvim/search.c", ["    ncount = count;", "    if (start_blank)", "      --ncount;"], "readability/braces"]
["src/nvim/search.c", ["    if (start_blank)", "      --ncount;", "  }"], "readability/increment"]
["src/nvim/search.c", ["  }", "  if (ncount > 0)", "    findsent_forward(ncount, TRUE);"], "readability/braces"]
["src/nvim/search.c", ["  if (ncount > 0)", "    findsent_forward(ncount, TRUE);", "  else"], "readability/bool"]
["src/nvim/search.c", ["    findsent_forward(ncount, TRUE);", "  else", "    decl(&curwin->w_cursor);"], "readability/braces"]
["src/nvim/search.c", ["  if (include) {", "    /*", "     * If the blank in front of the sentence is included, exclude the"], "readability/old_style_comment"]
["src/nvim/search.c", ["      c = gchar_pos(&curwin->w_cursor);", "      if (ascii_iswhite(c))", "        decl(&curwin->w_cursor);"], "readability/braces"]
["src/nvim/search.c", ["        decl(&curwin->w_cursor);", "    } else if (c = gchar_cursor(), !ascii_iswhite(c))", "      find_first_blank(&start_pos);"], "readability/braces"]
["src/nvim/search.c", ["  if (VIsual_active) {", "    /* Avoid getting stuck with \"is\" on a single space before a sentence. */", "    if (equalpos(start_pos, curwin->w_cursor))"], "readability/old_style_comment"]
["src/nvim/search.c", ["    /* Avoid getting stuck with \"is\" on a single space before a sentence. */", "    if (equalpos(start_pos, curwin->w_cursor))", "      goto extend;"], "readability/braces"]
["src/nvim/search.c", ["      goto extend;", "    if (*p_sel == 'e')", "      ++curwin->w_cursor.col;"], "readability/braces"]
["src/nvim/search.c", ["    if (*p_sel == 'e')", "      ++curwin->w_cursor.col;", "    VIsual = start_pos;"], "readability/increment"]
["src/nvim/search.c", ["  } else {", "    /* include a newline after the sentence, if there is one */", "    if (incl(&curwin->w_cursor) == -1)"], "readability/old_style_comment"]
["src/nvim/search.c", ["    /* include a newline after the sentence, if there is one */", "    if (incl(&curwin->w_cursor) == -1)", "      oap->inclusive = true;"], "readability/braces"]
["src/nvim/search.c", ["      oap->inclusive = true;", "    else", "      oap->inclusive = false;"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * Find block under the cursor, cursor at end."], "readability/old_style_comment"]
["src/nvim/search.c", ["    long count,", "    int include,                    /* TRUE == include white space */", "    int what,                       /* '(', '{', etc. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    int include,                    /* TRUE == include white space */", "    int what,                       /* '(', '{', etc. */", "    int other                      /* ')', '}', etc. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    int what,                       /* '(', '{', etc. */", "    int other                      /* ')', '}', etc. */", ")"], "readability/old_style_comment"]
["src/nvim/search.c", ["  char_u      *save_cpo;", "  int sol = FALSE;                      /* '{' at start of line */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["  char_u      *save_cpo;", "  int sol = FALSE;                      /* '{' at start of line */", ""], "readability/bool"]
["src/nvim/search.c", ["  old_pos = curwin->w_cursor;", "  old_end = curwin->w_cursor;           /* remember where we started */", "  old_start = old_end;"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * If we start on '(', '{', ')', '}', etc., use the whole block inclusive."], "readability/old_style_comment"]
["src/nvim/search.c", ["    setpcmark();", "    if (what == '{')                    /* ignore indent */", "      while (inindent(1))"], "readability/old_style_comment"]
["src/nvim/search.c", ["    setpcmark();", "    if (what == '{')                    /* ignore indent */", "      while (inindent(1))"], "readability/braces"]
["src/nvim/search.c", ["    if (what == '{')                    /* ignore indent */", "      while (inindent(1))", "        if (inc_cursor() != 0)"], "readability/braces"]
["src/nvim/search.c", ["      while (inindent(1))", "        if (inc_cursor() != 0)", "          break;"], "readability/braces"]
["src/nvim/search.c", ["          break;", "    if (gchar_cursor() == what)", "      /* cursor on '(' or '{', move cursor just after it */"], "readability/braces"]
["src/nvim/search.c", ["    if (gchar_cursor() == what)", "      /* cursor on '(' or '{', move cursor just after it */", "      ++curwin->w_cursor.col;"], "readability/old_style_comment"]
["src/nvim/search.c", ["      /* cursor on '(' or '{', move cursor just after it */", "      ++curwin->w_cursor.col;", "  } else if (lt(VIsual, curwin->w_cursor)) {"], "readability/increment"]
["src/nvim/search.c", ["    old_start = VIsual;", "    curwin->w_cursor = VIsual;              /* cursor at low end of Visual */", "  } else"], "readability/old_style_comment"]
["src/nvim/search.c", ["    curwin->w_cursor = VIsual;              /* cursor at low end of Visual */", "  } else", "    old_end = VIsual;"], "readability/braces"]
["src/nvim/search.c", ["", "  /*", "   * Search for matching ')', '}', etc."], "readability/old_style_comment"]
["src/nvim/search.c", ["    while (inindent(1)) {", "      sol = TRUE;", "      if (decl(&curwin->w_cursor) != 0) {"], "readability/bool"]
["src/nvim/search.c", ["", "    /*", "     * In Visual mode, when the resulting area is not bigger than what we"], "readability/old_style_comment"]
["src/nvim/search.c", ["      curwin->w_cursor = *end_pos;", "    } else", "      break;"], "readability/braces"]
["src/nvim/search.c", ["    VIsual_mode = 'v';", "    redraw_curbuf_later(INVERTED);      /* update the inversion */", "    showmode();"], "readability/old_style_comment"]
["src/nvim/search.c", ["    oap->inclusive = false;", "    if (sol)", "      incl(&curwin->w_cursor);"], "readability/braces"]
["src/nvim/search.c", ["      incl(&curwin->w_cursor);", "    else if (ltoreq(start_pos, curwin->w_cursor))", "      /* Include the character under the cursor. */"], "readability/braces"]
["src/nvim/search.c", ["    else if (ltoreq(start_pos, curwin->w_cursor))", "      /* Include the character under the cursor. */", "      oap->inclusive = true;"], "readability/old_style_comment"]
["src/nvim/search.c", ["      oap->inclusive = true;", "    else", "      /* End is before the start (no text in between <>, [], etc.): don't"], "readability/braces"]
["src/nvim/search.c", ["    else", "      /* End is before the start (no text in between <>, [], etc.): don't", "       * operate on any text. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Return TRUE if the cursor is on a \"<aaa>\" tag.  Ignore \"<aaa/>\"."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /* check that there is no '/' after the '<' */", "  if (*p == '/')"], "readability/old_style_comment"]
["src/nvim/search.c", ["  /* check that there is no '/' after the '<' */", "  if (*p == '/')", "    return FALSE;"], "readability/braces"]
["src/nvim/search.c", ["  if (*p == '/')", "    return FALSE;", ""], "readability/bool"]
["src/nvim/search.c", ["", "  /* check that the matching '>' is not preceded by '/' */", "  for (;; ) {"], "readability/old_style_comment"]
["src/nvim/search.c", ["  for (;; ) {", "    if (inc(&pos) < 0)", "      return FALSE;"], "readability/braces"]
["src/nvim/search.c", ["    if (inc(&pos) < 0)", "      return FALSE;", "    c = *ml_get_pos(&pos);"], "readability/bool"]
["src/nvim/search.c", ["    c = *ml_get_pos(&pos);", "    if (c == '>')", "      break;"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * Find tag block under the cursor, cursor at end."], "readability/old_style_comment"]
["src/nvim/search.c", ["  old_pos = curwin->w_cursor;", "  old_end = curwin->w_cursor;               /* remember where we started */", "  old_start = old_end;"], "readability/old_style_comment"]
["src/nvim/search.c", ["  old_start = old_end;", "  if (!VIsual_active || *p_sel == 'e')", "    decl(&old_end);                         /* old_end is inclusive */"], "readability/braces"]
["src/nvim/search.c", ["  if (!VIsual_active || *p_sel == 'e')", "    decl(&old_end);                         /* old_end is inclusive */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * If we start on \"<aaa>\" select that block."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /* ignore indent */", "    while (inindent(1))"], "readability/old_style_comment"]
["src/nvim/search.c", ["    /* ignore indent */", "    while (inindent(1))", "      if (inc_cursor() != 0)"], "readability/braces"]
["src/nvim/search.c", ["    while (inindent(1))", "      if (inc_cursor() != 0)", "        break;"], "readability/braces"]
["src/nvim/search.c", ["", "    if (in_html_tag(FALSE)) {", "      /* cursor on start tag, move to its '>' */"], "readability/bool"]
["src/nvim/search.c", ["    if (in_html_tag(FALSE)) {", "      /* cursor on start tag, move to its '>' */", "      while (*get_cursor_pos_ptr() != '>')"], "readability/old_style_comment"]
["src/nvim/search.c", ["      /* cursor on start tag, move to its '>' */", "      while (*get_cursor_pos_ptr() != '>')", "        if (inc_cursor() < 0)"], "readability/braces"]
["src/nvim/search.c", ["      while (*get_cursor_pos_ptr() != '>')", "        if (inc_cursor() < 0)", "          break;"], "readability/braces"]
["src/nvim/search.c", ["          break;", "    } else if (in_html_tag(TRUE)) {", "      /* cursor on end tag, move to just before it */"], "readability/bool"]
["src/nvim/search.c", ["    } else if (in_html_tag(TRUE)) {", "      /* cursor on end tag, move to just before it */", "      while (*get_cursor_pos_ptr() != '<')"], "readability/old_style_comment"]
["src/nvim/search.c", ["      /* cursor on end tag, move to just before it */", "      while (*get_cursor_pos_ptr() != '<')", "        if (dec_cursor() < 0)"], "readability/braces"]
["src/nvim/search.c", ["      while (*get_cursor_pos_ptr() != '<')", "        if (dec_cursor() < 0)", "          break;"], "readability/braces"]
["src/nvim/search.c", ["    old_start = VIsual;", "    curwin->w_cursor = VIsual;              /* cursor at low end of Visual */", "  } else"], "readability/old_style_comment"]
["src/nvim/search.c", ["    curwin->w_cursor = VIsual;              /* cursor at low end of Visual */", "  } else", "    old_end = VIsual;"], "readability/braces"]
["src/nvim/search.c", ["again:", "  /*", "   * Search backwards for unclosed \"<aaa>\"."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * Search for matching \"</aaa>\".  First isolate the \"aaa\"."], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (r < 1 || lt(curwin->w_cursor, old_end)) {", "    /* Can't find other end or it's before the previous end.  Could be a", "     * HTML tag that doesn't have a matching end.  Search backwards for"], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (!do_include) {", "    /* Exclude the start tag. */", "    curwin->w_cursor = start_pos;"], "readability/old_style_comment"]
["src/nvim/search.c", ["    curwin->w_cursor = start_pos;", "    while (inc_cursor() >= 0)", "      if (*get_cursor_pos_ptr() == '>') {"], "readability/braces"]
["src/nvim/search.c", ["  if (VIsual_active) {", "    /* If the end is before the start there is no text between tags, select", "     * the char under the cursor. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    VIsual_mode = 'v';", "    redraw_curbuf_later(INVERTED);      /* update the inversion */", "    showmode();"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (lt(end_pos, start_pos)) {", "      /* End is before the start: there is no text between tags; operate", "       * on an empty area. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    long count,", "    int include,                    /* TRUE == include white space */", "    int type                       /* 'p' for paragraph, 'S' for section */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    int include,                    /* TRUE == include white space */", "    int type                       /* 'p' for paragraph, 'S' for section */", ")"], "readability/old_style_comment"]
["src/nvim/search.c", ["  int retval = OK;", "  int do_white = FALSE;", "  int t;"], "readability/bool"]
["src/nvim/search.c", ["", "  if (type == 'S')          /* not implemented yet */", "    return FAIL;"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  if (type == 'S')          /* not implemented yet */", "    return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["", "  /*", "   * When visual area is more than one line: extend it."], "readability/old_style_comment"]
["src/nvim/search.c", ["extend:", "    if (start_lnum < VIsual.lnum)", "      dir = BACKWARD;"], "readability/braces"]
["src/nvim/search.c", ["      dir = BACKWARD;", "    else", "      dir = FORWARD;"], "readability/braces"]
["src/nvim/search.c", ["      prev_start_is_white = -1;", "      for (t = 0; t < 2; ++t) {", "        start_lnum += dir;"], "readability/increment"]
["src/nvim/search.c", ["        for (;; ) {", "          if (start_lnum == (dir == BACKWARD", "                             ? 1 : curbuf->b_ml.ml_line_count))"], "readability/braces"]
["src/nvim/search.c", ["            break;", "          if (start_is_white != linewhite(start_lnum + dir)", "              || (!start_is_white"], "readability/braces"]
["src/nvim/search.c", ["        }", "        if (!include)", "          break;"], "readability/braces"]
["src/nvim/search.c", ["          break;", "        if (start_lnum == (dir == BACKWARD", "                           ? 1 : curbuf->b_ml.ml_line_count))"], "readability/braces"]
["src/nvim/search.c", ["", "  /*", "   * First move back to the start_lnum of the paragraph or white lines"], "readability/old_style_comment"]
["src/nvim/search.c", ["  while (start_lnum > 1) {", "    if (white_in_front) {           /* stop at first white line */", "      if (!linewhite(start_lnum - 1))"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (white_in_front) {           /* stop at first white line */", "      if (!linewhite(start_lnum - 1))", "        break;"], "readability/braces"]
["src/nvim/search.c", ["        break;", "    } else {          /* stop at first non-white line of start of paragraph */", "      if (linewhite(start_lnum - 1) || startPS(start_lnum, 0, 0))"], "readability/old_style_comment"]
["src/nvim/search.c", ["    } else {          /* stop at first non-white line of start of paragraph */", "      if (linewhite(start_lnum - 1) || startPS(start_lnum, 0, 0))", "        break;"], "readability/braces"]
["src/nvim/search.c", ["    }", "    --start_lnum;", "  }"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * Move past the end of any white lines."], "readability/old_style_comment"]
["src/nvim/search.c", ["  end_lnum = start_lnum;", "  while (end_lnum <= curbuf->b_ml.ml_line_count && linewhite(end_lnum))", "    ++end_lnum;"], "readability/braces"]
["src/nvim/search.c", ["  while (end_lnum <= curbuf->b_ml.ml_line_count && linewhite(end_lnum))", "    ++end_lnum;", ""], "readability/increment"]
["src/nvim/search.c", ["", "  --end_lnum;", "  i = count;"], "readability/increment"]
["src/nvim/search.c", ["  i = count;", "  if (!include && white_in_front)", "    --i;"], "readability/braces"]
["src/nvim/search.c", ["  if (!include && white_in_front)", "    --i;", "  while (i--) {"], "readability/increment"]
["src/nvim/search.c", ["  while (i--) {", "    if (end_lnum == curbuf->b_ml.ml_line_count)", "      return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["", "    if (!include)", "      do_white = linewhite(end_lnum + 1);"], "readability/braces"]
["src/nvim/search.c", ["    if (include || !do_white) {", "      ++end_lnum;", "      /*"], "readability/increment"]
["src/nvim/search.c", ["      ++end_lnum;", "      /*", "       * skip to end of paragraph"], "readability/old_style_comment"]
["src/nvim/search.c", ["       */", "      while (end_lnum < curbuf->b_ml.ml_line_count", "             && !linewhite(end_lnum + 1)"], "readability/braces"]
["src/nvim/search.c", ["             && !startPS(end_lnum + 1, 0, 0))", "        ++end_lnum;", "    }"], "readability/increment"]
["src/nvim/search.c", ["", "    if (i == 0 && white_in_front && include)", "      break;"], "readability/braces"]
["src/nvim/search.c", ["", "    /*", "     * skip to end of white lines after paragraph"], "readability/old_style_comment"]
["src/nvim/search.c", ["     */", "    if (include || do_white)", "      while (end_lnum < curbuf->b_ml.ml_line_count"], "readability/braces"]
["src/nvim/search.c", ["    if (include || do_white)", "      while (end_lnum < curbuf->b_ml.ml_line_count", "             && linewhite(end_lnum + 1))"], "readability/braces"]
["src/nvim/search.c", ["             && linewhite(end_lnum + 1))", "        ++end_lnum;", "  }"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * If there are no empty lines at the end, try to find some empty lines at"], "readability/old_style_comment"]
["src/nvim/search.c", ["   */", "  if (!white_in_front && !linewhite(end_lnum) && include)", "    while (start_lnum > 1 && linewhite(start_lnum - 1))"], "readability/braces"]
["src/nvim/search.c", ["  if (!white_in_front && !linewhite(end_lnum) && include)", "    while (start_lnum > 1 && linewhite(start_lnum - 1))", "      --start_lnum;"], "readability/braces"]
["src/nvim/search.c", ["    while (start_lnum > 1 && linewhite(start_lnum - 1))", "      --start_lnum;", ""], "readability/increment"]
["src/nvim/search.c", ["    VIsual_mode = 'V';", "    redraw_curbuf_later(INVERTED);      /* update the inversion */", "    showmode();"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Search quote char from string line[col]."], "readability/old_style_comment"]
["src/nvim/search.c", ["    int quotechar,", "    char_u *escape            /* escape characters, can be NULL */", ")"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Search backwards in \"line\" from column \"col_start\" to find \"quotechar\"."], "readability/old_style_comment"]
["src/nvim/search.c", ["    int quotechar,", "    char_u *escape            /* escape characters, can be NULL */", ")"], "readability/old_style_comment"]
["src/nvim/search.c", ["    n = 0;", "    if (escape != NULL)", "      while (col_start - n > 0 && vim_strchr(escape,"], "readability/braces"]
["src/nvim/search.c", ["    if (escape != NULL)", "      while (col_start - n > 0 && vim_strchr(escape,", "                 line[col_start - n - 1]) != NULL)"], "readability/braces"]
["src/nvim/search.c", ["      while (col_start - n > 0 && vim_strchr(escape,", "                 line[col_start - n - 1]) != NULL)", "        ++n;"], "whitespace/alignment"]
["src/nvim/search.c", ["                 line[col_start - n - 1]) != NULL)", "        ++n;", "    if (n & 1)"], "readability/increment"]
["src/nvim/search.c", ["        ++n;", "    if (n & 1)", "      col_start -= n;           /* uneven number of escape chars, skip it */"], "readability/braces"]
["src/nvim/search.c", ["    if (n & 1)", "      col_start -= n;           /* uneven number of escape chars, skip it */", "    else if (line[col_start] == quotechar)"], "readability/old_style_comment"]
["src/nvim/search.c", ["      col_start -= n;           /* uneven number of escape chars, skip it */", "    else if (line[col_start] == quotechar)", "      break;"], "readability/braces"]
["src/nvim/search.c", ["  if (!vis_empty) {", "    /* Check if the existing selection exactly spans the text inside", "     * quotes. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /* Find out if we have a quote in the selection. */", "    while (i <= col_end)"], "readability/old_style_comment"]
["src/nvim/search.c", ["    /* Find out if we have a quote in the selection. */", "    while (i <= col_end)", "      if (line[i++] == quotechar) {"], "readability/braces"]
["src/nvim/search.c", ["  if (!vis_empty && line[col_start] == quotechar) {", "    /* Already selecting something and on a quote character.  Find the", "     * next quoted string. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (vis_bef_curs) {", "      /* Assume we are on a closing quote: move to after the next", "       * opening quote. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["      col_end = find_next_quote(line, col_start + 1, quotechar,", "          curbuf->b_p_qe);", "      if (col_end < 0) {"], "whitespace/alignment"]
["src/nvim/search.c", ["      if (col_end < 0) {", "        /* We were on a starting quote perhaps? */", "        col_end = col_start;"], "readability/old_style_comment"]
["src/nvim/search.c", ["      col_start = find_prev_quote(line, col_end, quotechar,", "          curbuf->b_p_qe);", "      if (line[col_start] != quotechar) {"], "whitespace/alignment"]
["src/nvim/search.c", ["      if (line[col_start] != quotechar) {", "        /* We were on an ending quote perhaps? */", "        col_start = col_end;"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (!vis_empty) {", "      if (vis_bef_curs)", "        first_col = find_next_quote(line, col_start, quotechar, NULL);"], "readability/braces"]
["src/nvim/search.c", ["        first_col = find_next_quote(line, col_start, quotechar, NULL);", "      else", "        first_col = find_prev_quote(line, col_start, quotechar, NULL);"], "readability/braces"]
["src/nvim/search.c", ["    }", "    /* The cursor is on a quote, we don't know if it's the opening or", "     * closing quote.  Search from the start of the line to find out."], "readability/old_style_comment"]
["src/nvim/search.c", ["    for (;; ) {", "      /* Find open quote character. */", "      col_start = find_next_quote(line, col_start, quotechar, NULL);"], "readability/old_style_comment"]
["src/nvim/search.c", ["      col_end = find_next_quote(line, col_start + 1, quotechar,", "          curbuf->b_p_qe);", "      if (col_end < 0) {"], "whitespace/alignment"]
["src/nvim/search.c", ["  } else {", "    /* Search backward for a starting quote. */", "    col_start = find_prev_quote(line, col_start, quotechar, curbuf->b_p_qe);"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (line[col_start] != quotechar) {", "      /* No quote before the cursor, look after the cursor. */", "      col_start = find_next_quote(line, col_start, quotechar, NULL);"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /* Find close quote character. */", "    col_end = find_next_quote(line, col_start + 1, quotechar,"], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (include) {", "    if (ascii_iswhite(line[col_end + 1]))", "      while (ascii_iswhite(line[col_end + 1]))"], "readability/braces"]
["src/nvim/search.c", ["    if (ascii_iswhite(line[col_end + 1]))", "      while (ascii_iswhite(line[col_end + 1]))", "        ++col_end;"], "readability/braces"]
["src/nvim/search.c", ["      while (ascii_iswhite(line[col_end + 1]))", "        ++col_end;", "    else"], "readability/increment"]
["src/nvim/search.c", ["        ++col_end;", "    else", "      while (col_start > 0 && ascii_iswhite(line[col_start - 1]))"], "readability/braces"]
["src/nvim/search.c", ["    else", "      while (col_start > 0 && ascii_iswhite(line[col_start - 1]))", "        --col_start;"], "readability/braces"]
["src/nvim/search.c", ["      while (col_start > 0 && ascii_iswhite(line[col_start - 1]))", "        --col_start;", "  }"], "readability/increment"]
["src/nvim/search.c", ["", "  /* Set start position.  After vi\" another i\" must include the \".", "   * For v2i\" include the quotes. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["   * For v2i\" include the quotes. */", "  if (!include && count < 2", "      && (vis_empty || !inside_quotes)"], "readability/braces"]
["src/nvim/search.c", ["      )", "    ++col_start;", "  curwin->w_cursor.col = col_start;"], "readability/increment"]
["src/nvim/search.c", ["  if (VIsual_active) {", "    /* Set the start of the Visual area when the Visual area was empty, we", "     * were just inside quotes or the Visual area didn't start at a quote"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /* Set end position. */", "  curwin->w_cursor.col = col_end;"], "readability/old_style_comment"]
["src/nvim/search.c", ["  curwin->w_cursor.col = col_end;", "  if ((include || count > 1", "       /* After vi\" another i\" must include the \". */"], "readability/braces"]
["src/nvim/search.c", ["  if ((include || count > 1", "       /* After vi\" another i\" must include the \". */", "       || (!vis_empty && inside_quotes)"], "readability/old_style_comment"]
["src/nvim/search.c", ["       || (!vis_empty && inside_quotes)", "       ) && inc_cursor() == 2)", "    inclusive = true;"], "whitespace/parens"]
["src/nvim/search.c", ["    } else {", "      /* Cursor is at start of Visual area.  Set the end of the Visual", "       * area when it was just inside quotes or it didn't end at a"], "readability/old_style_comment"]
["src/nvim/search.c", ["      VIsual_mode = 'v';", "      redraw_cmdline = TRUE;                    /* show mode later */", "    }"], "readability/old_style_comment"]
["src/nvim/search.c", ["      VIsual_mode = 'v';", "      redraw_cmdline = TRUE;                    /* show mode later */", "    }"], "readability/bool"]
["src/nvim/search.c", ["  } else {", "    /* Set inclusive and other oap's flags. */", "    oap->inclusive = inclusive;"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Find next search match under cursor, cursor at end."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /* Correct cursor when 'selection' is exclusive */", "  if (VIsual_active && *p_sel == 'e' && lt(VIsual, curwin->w_cursor))"], "readability/old_style_comment"]
["src/nvim/search.c", ["  /* Correct cursor when 'selection' is exclusive */", "  if (VIsual_active && *p_sel == 'e' && lt(VIsual, curwin->w_cursor))", "    dec_cursor();"], "readability/braces"]
["src/nvim/search.c", ["      curwin->w_cursor = orig_pos;", "      if (VIsual_active)", "        VIsual = save_VIsual;"], "readability/braces"]
["src/nvim/search.c", ["", "  if (search_regcomp(pattern, RE_SEARCH, RE_SEARCH,", "          SEARCH_KEEP, &regmatch) == FAIL)"], "readability/braces"]
["src/nvim/search.c", ["  if (search_regcomp(pattern, RE_SEARCH, RE_SEARCH,", "          SEARCH_KEEP, &regmatch) == FAIL)", "    return -1;"], "whitespace/alignment"]
["src/nvim/search.c", ["", "/*", " * return TRUE if line 'lnum' is empty or has white chars only."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Find identifiers or defines in included files."], "readability/old_style_comment"]
["src/nvim/search.c", ["{", "  SearchedFile *files;                  /* Stack of included files */", "  SearchedFile *bigger;                 /* When we need more space */"], "readability/old_style_comment"]
["src/nvim/search.c", ["  SearchedFile *files;                  /* Stack of included files */", "  SearchedFile *bigger;                 /* When we need more space */", "  int max_path_depth = 50;"], "readability/old_style_comment"]
["src/nvim/search.c", ["  int depth;", "  int depth_displayed;                  /* For type==CHECK_PATH */", "  int old_files;"], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (type != CHECK_PATH && type != FIND_DEFINE", "      /* when CONT_SOL is set compare \"ptr\" with the beginning of the line", "       * is faster than quote_meta/regcomp/regexec \"ptr\" -- Acevedo */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    assert(len <= INT_MAX);", "    sprintf((char *)pat, whole ? \"\\\\<%.*s\\\\>\" : \"%.*s\", (int)len, ptr);", "    /* ignore case according to p_ic, p_scs and pat */"], "runtime/printf"]
["src/nvim/search.c", ["    sprintf((char *)pat, whole ? \"\\\\<%.*s\\\\>\" : \"%.*s\", (int)len, ptr);", "    /* ignore case according to p_ic, p_scs and pat */", "    regmatch.rm_ic = ignorecase(pat);"], "readability/old_style_comment"]
["src/nvim/search.c", ["    xfree(pat);", "    if (regmatch.regprog == NULL)", "      goto fpip_end;"], "readability/braces"]
["src/nvim/search.c", ["    incl_regmatch.regprog = vim_regcomp(inc_opt, p_magic ? RE_MAGIC : 0);", "    if (incl_regmatch.regprog == NULL)", "      goto fpip_end;"], "readability/braces"]
["src/nvim/search.c", ["      goto fpip_end;", "    incl_regmatch.rm_ic = FALSE;        /* don't ignore case in incl. pat. */", "  }"], "readability/old_style_comment"]
["src/nvim/search.c", ["      goto fpip_end;", "    incl_regmatch.rm_ic = FALSE;        /* don't ignore case in incl. pat. */", "  }"], "readability/bool"]
["src/nvim/search.c", ["    def_regmatch.regprog = vim_regcomp(*curbuf->b_p_def == NUL", "        ? p_def : curbuf->b_p_def, p_magic ? RE_MAGIC : 0);", "    if (def_regmatch.regprog == NULL)"], "whitespace/alignment"]
["src/nvim/search.c", ["        ? p_def : curbuf->b_p_def, p_magic ? RE_MAGIC : 0);", "    if (def_regmatch.regprog == NULL)", "      goto fpip_end;"], "readability/braces"]
["src/nvim/search.c", ["      goto fpip_end;", "    def_regmatch.rm_ic = FALSE;         /* don't ignore case in define pat. */", "  }"], "readability/old_style_comment"]
["src/nvim/search.c", ["      goto fpip_end;", "    def_regmatch.rm_ic = FALSE;         /* don't ignore case in define pat. */", "  }"], "readability/bool"]
["src/nvim/search.c", ["  lnum = start_lnum;", "  if (end_lnum > curbuf->b_ml.ml_line_count)", "    end_lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/search.c", ["    end_lnum = curbuf->b_ml.ml_line_count;", "  if (lnum > end_lnum)                  /* do at least one line */", "    lnum = end_lnum;"], "readability/old_style_comment"]
["src/nvim/search.c", ["    end_lnum = curbuf->b_ml.ml_line_count;", "  if (lnum > end_lnum)                  /* do at least one line */", "    lnum = end_lnum;"], "readability/braces"]
["src/nvim/search.c", ["", "      if (inc_opt != NULL && strstr((char *)inc_opt, \"\\\\zs\") != NULL)", "        /* Use text from '\\zs' to '\\ze' (or end) of 'include'. */"], "readability/braces"]
["src/nvim/search.c", ["      if (inc_opt != NULL && strstr((char *)inc_opt, \"\\\\zs\") != NULL)", "        /* Use text from '\\zs' to '\\ze' (or end) of 'include'. */", "        new_fname = find_file_name_in_path(incl_regmatch.startp[0],"], "readability/old_style_comment"]
["src/nvim/search.c", ["                                           1L, p_fname);", "      else", "        /* Use text after match with 'include'. */"], "readability/braces"]
["src/nvim/search.c", ["      else", "        /* Use text after match with 'include'. */", "        new_fname = file_name_in_line(incl_regmatch.endp[0], 0,"], "readability/old_style_comment"]
["src/nvim/search.c", ["        new_fname = file_name_in_line(incl_regmatch.endp[0], 0,", "            FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname, NULL);", "      already_searched = FALSE;"], "whitespace/alignment"]
["src/nvim/search.c", ["            FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname, NULL);", "      already_searched = FALSE;", "      if (new_fname != NULL) {"], "readability/bool"]
["src/nvim/search.c", ["        while (depth_displayed < depth && !got_int) {", "          ++depth_displayed;", "          for (i = 0; i < depth_displayed; i++)"], "readability/increment"]
["src/nvim/search.c", ["          ++depth_displayed;", "          for (i = 0; i < depth_displayed; i++)", "            MSG_PUTS(\"  \");"], "readability/braces"]
["src/nvim/search.c", ["        }", "        if (!got_int) {                     /* don't display if 'q' typed", "                                               for \"--more--\" message */"], "readability/multiline_comment"]
["src/nvim/search.c", ["        }", "        if (!got_int) {                     /* don't display if 'q' typed", "                                               for \"--more--\" message */"], "readability/old_style_comment"]
["src/nvim/search.c", ["                                               for \"--more--\" message */", "          for (i = 0; i <= depth_displayed; i++)", "            MSG_PUTS(\"  \");"], "readability/braces"]
["src/nvim/search.c", ["          if (new_fname != NULL) {", "            /* using \"new_fname\" is more reliable, e.g., when", "             * 'includeexpr' is set. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["          } else {", "            /*", "             * Isolate the file name."], "readability/old_style_comment"]
["src/nvim/search.c", ["                && strstr((char *)inc_opt, \"\\\\zs\") != NULL) {", "              /* pattern contains \\zs, use the match */", "              p = incl_regmatch.startp[0];"], "readability/old_style_comment"]
["src/nvim/search.c", ["            } else {", "              /* find the file name after the end of the match */", "              for (p = incl_regmatch.endp[0];"], "readability/old_style_comment"]
["src/nvim/search.c", ["              /* find the file name after the end of the match */", "              for (p = incl_regmatch.endp[0];", "                   *p && !vim_isfilec(*p); p++)"], "readability/braces"]
["src/nvim/search.c", ["                   *p && !vim_isfilec(*p); p++)", "                ;", "              for (i = 0; vim_isfilec(p[i]); i++)"], "whitespace/semicolon"]
["src/nvim/search.c", ["                ;", "              for (i = 0; vim_isfilec(p[i]); i++)", "                ;"], "readability/braces"]
["src/nvim/search.c", ["              for (i = 0; vim_isfilec(p[i]); i++)", "                ;", "            }"], "whitespace/semicolon"]
["src/nvim/search.c", ["            if (i == 0) {", "              /* Nothing found, use the rest of the line. */", "              p = incl_regmatch.endp[0];"], "readability/old_style_comment"]
["src/nvim/search.c", ["            }", "            /* Avoid checking before the start of the line, can", "             * happen if \\zs appears in the regexp. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["             * happen if \\zs appears in the regexp. */", "            else if (p > line) {", "              if (p[-1] == '\"' || p[-1] == '<') {"], "whitespace/newline"]
["src/nvim/search.c", ["              if (p[-1] == '\"' || p[-1] == '<') {", "                --p;", "                ++i;"], "readability/increment"]
["src/nvim/search.c", ["                --p;", "                ++i;", "              }"], "readability/increment"]
["src/nvim/search.c", ["              }", "              if (p[i] == '\"' || p[i] == '>')", "                ++i;"], "readability/braces"]
["src/nvim/search.c", ["              if (p[i] == '\"' || p[i] == '>')", "                ++i;", "            }"], "readability/increment"]
["src/nvim/search.c", ["          if (new_fname == NULL && action == ACTION_SHOW_ALL) {", "            if (already_searched)", "              MSG_PUTS(_(\"  (Already listed)\"));"], "readability/braces"]
["src/nvim/search.c", ["              MSG_PUTS(_(\"  (Already listed)\"));", "            else", "              MSG_PUTS(_(\"  NOT FOUND\"));"], "readability/braces"]
["src/nvim/search.c", ["        }", "        ui_flush();                /* output each line directly */", "      }"], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (new_fname != NULL) {", "        /* Push the new file onto the file stack */", "        if (depth + 1 == old_files) {"], "readability/old_style_comment"]
["src/nvim/search.c", ["          bigger = xmalloc(max_path_depth * 2 * sizeof(SearchedFile));", "          for (i = 0; i <= depth; i++)", "            bigger[i] = files[i];"], "readability/braces"]
["src/nvim/search.c", ["            bigger[i].lnum = 0;", "            bigger[i].matched = FALSE;", "          }"], "readability/bool"]
["src/nvim/search.c", ["          }", "          for (i = old_files; i < max_path_depth; i++)", "            bigger[i + max_path_depth] = files[i];"], "readability/braces"]
["src/nvim/search.c", ["            xfree(files[old_files].name);", "            ++old_files;", "          }"], "readability/increment"]
["src/nvim/search.c", ["          files[depth].lnum = 0;", "          files[depth].matched = FALSE;", "          if (action == ACTION_EXPAND) {"], "readability/bool"]
["src/nvim/search.c", ["            smsg(_(\"Searching included file %s\"),", "                (char *)new_fname);", "            verbose_leave();"], "whitespace/alignment"]
["src/nvim/search.c", ["          }", "", "        }"], "whitespace/blank_line"]
["src/nvim/search.c", ["    } else {", "      /*", "       * Check if the line is a define (type == FIND_DEFINE)"], "readability/old_style_comment"]
["src/nvim/search.c", ["search_line:", "      define_matched = FALSE;", "      if (def_regmatch.regprog != NULL"], "readability/bool"]
["src/nvim/search.c", ["          && vim_regexec(&def_regmatch, line, (colnr_T)0)) {", "        /*", "         * Pattern must be first identifier after 'define', so skip"], "readability/old_style_comment"]
["src/nvim/search.c", ["        p = def_regmatch.endp[0];", "        while (*p && !vim_iswordc(*p))", "          p++;"], "readability/braces"]
["src/nvim/search.c", ["          p++;", "        define_matched = TRUE;", "      }"], "readability/bool"]
["src/nvim/search.c", ["", "      /*", "       * Look for a match.  Don't do this if we are looking for a"], "readability/old_style_comment"]
["src/nvim/search.c", ["            ) {", "          /* compare the first \"len\" chars from \"ptr\" */", "          startp = skipwhite(p);"], "readability/old_style_comment"]
["src/nvim/search.c", ["          }", "          else", "            matched = !STRNCMP(startp, ptr, len);"], "whitespace/newline"]
["src/nvim/search.c", ["            matched = !STRNCMP(startp, ptr, len);", "          if (matched && define_matched && whole", "              && vim_iswordc(startp[len]))"], "readability/braces"]
["src/nvim/search.c", ["", "            /*", "             * Also check for a \"/ *\" or \"/ /\" before the match."], "readability/old_style_comment"]
["src/nvim/search.c", ["            p = skipwhite(line);", "            if (matched", "                || (p[0] == '/' && p[1] == '*') || p[0] == '*')"], "readability/braces"]
["src/nvim/search.c", ["                || (p[0] == '/' && p[1] == '*') || p[0] == '*')", "              for (p = line; *p && p < startp; ++p) {", "                if (matched"], "readability/increment"]
["src/nvim/search.c", ["", "        if (depth == -1 && lnum == curwin->w_cursor.lnum)", "          break;"], "readability/braces"]
["src/nvim/search.c", ["          p += compl_length;", "          if (vim_iswordp(p))", "            goto exit_matched;"], "readability/braces"]
["src/nvim/search.c", ["        if ((compl_cont_status & CONT_ADDING) && i == compl_length) {", "          /* IOSIZE > compl_length, so the STRNCPY works */", "          STRNCPY(IObuff, aux, i);"], "readability/old_style_comment"]
["src/nvim/search.c", ["          /* IOSIZE > compl_length, so the STRNCPY works */", "          STRNCPY(IObuff, aux, i);", ""], "runtime/printf"]
["src/nvim/search.c", ["", "          /* Get the next line: when \"depth\" < 0  from the current", "           * buffer, otherwise from the included file.  Jump to"], "readability/old_style_comment"]
["src/nvim/search.c", ["          if (depth < 0) {", "            if (lnum >= end_lnum)", "              goto exit_matched;"], "readability/braces"]
["src/nvim/search.c", ["            line = ml_get(++lnum);", "          } else if (vim_fgets(line = file_line,", "                         LSIZE, files[depth].fp))"], "readability/braces"]
["src/nvim/search.c", ["          } else if (vim_fgets(line = file_line,", "                         LSIZE, files[depth].fp))", "            goto exit_matched;"], "whitespace/alignment"]
["src/nvim/search.c", ["", "          /* we read a line, set \"already\" to check this \"line\" later", "           * if depth >= 0 we'll increase files[depth].lnum far"], "readability/old_style_comment"]
["src/nvim/search.c", ["            if (*aux != ')' && IObuff[i-1] != TAB) {", "              if (IObuff[i-1] != ' ')", "                IObuff[i++] = ' ';"], "readability/braces"]
["src/nvim/search.c", ["                IObuff[i++] = ' ';", "              /* IObuf =~ \"\\(\\k\\|\\i\\).* \", thus i >= 2*/", "              if (p_js"], "readability/old_style_comment"]
["src/nvim/search.c", ["            }", "            /* copy as much as possible of the new word */", "            if (p - aux >= IOSIZE - i)"], "readability/old_style_comment"]
["src/nvim/search.c", ["            /* copy as much as possible of the new word */", "            if (p - aux >= IOSIZE - i)", "              p = aux + IOSIZE - i - 1;"], "readability/braces"]
["src/nvim/search.c", ["              p = aux + IOSIZE - i - 1;", "            STRNCPY(IObuff + i, aux, p - aux);", "            i += (int)(p - aux);"], "runtime/printf"]
["src/nvim/search.c", ["", "          if (i == compl_length)", "            goto exit_matched;"], "readability/braces"]
["src/nvim/search.c", ["        if (curr_fname != prev_fname) {", "          if (did_show)", "            msg_putchar('\\n');                  /* cursor below last one */"], "readability/braces"]
["src/nvim/search.c", ["          if (did_show)", "            msg_putchar('\\n');                  /* cursor below last one */", "          if (!got_int)                         /* don't display if 'q' typed"], "readability/old_style_comment"]
["src/nvim/search.c", ["            msg_putchar('\\n');                  /* cursor below last one */", "          if (!got_int)                         /* don't display if 'q' typed", "                                                    at \"--more--\" message */"], "readability/multiline_comment"]
["src/nvim/search.c", ["            msg_putchar('\\n');                  /* cursor below last one */", "          if (!got_int)                         /* don't display if 'q' typed", "                                                    at \"--more--\" message */"], "readability/old_style_comment"]
["src/nvim/search.c", ["            msg_putchar('\\n');                  /* cursor below last one */", "          if (!got_int)                         /* don't display if 'q' typed", "                                                    at \"--more--\" message */"], "readability/braces"]
["src/nvim/search.c", ["", "        /* Set matched flag for this file and all the ones that", "         * include it */"], "readability/old_style_comment"]
["src/nvim/search.c", ["         * include it */", "        for (i = 0; i <= depth; ++i)", "          files[i].matched = TRUE;"], "readability/braces"]
["src/nvim/search.c", ["         * include it */", "        for (i = 0; i <= depth; ++i)", "          files[i].matched = TRUE;"], "readability/increment"]
["src/nvim/search.c", ["        for (i = 0; i <= depth; ++i)", "          files[i].matched = TRUE;", "      } else if (--count <= 0) {"], "readability/bool"]
["src/nvim/search.c", ["        } else {", "          /* \":psearch\" uses the preview window */", "          if (l_g_do_tagpreview != 0) {"], "readability/old_style_comment"]
["src/nvim/search.c", ["          if (action == ACTION_SPLIT) {", "            if (win_split(0, 0) == FAIL)", "              break;"], "readability/braces"]
["src/nvim/search.c", ["          curwin->w_cursor.col = (colnr_T)(startp - line);", "          curwin->w_set_curswant = TRUE;", "        }"], "readability/bool"]
["src/nvim/search.c", ["            && curwin != curwin_save && win_valid(curwin_save)) {", "          /* Return cursor to where we were */", "          validate_cursor();"], "readability/old_style_comment"]
["src/nvim/search.c", ["    line_breakcheck();", "    if (action == ACTION_EXPAND)", "      ins_compl_check_keys(30, false);"], "readability/braces"]
["src/nvim/search.c", ["      ins_compl_check_keys(30, false);", "    if (got_int || compl_interrupted)", "      break;"], "readability/braces"]
["src/nvim/search.c", ["", "    /*", "     * Read the next line.  When reading an included file and encountering"], "readability/old_style_comment"]
["src/nvim/search.c", ["      fclose(files[depth].fp);", "      --old_files;", "      files[old_files].name = files[depth].name;"], "readability/increment"]
["src/nvim/search.c", ["      files[old_files].matched = files[depth].matched;", "      --depth;", "      curr_fname = (depth == -1) ? curbuf->b_fname"], "readability/increment"]
["src/nvim/search.c", ["                   : files[depth].name;", "      if (depth < depth_displayed)", "        depth_displayed = depth;"], "readability/braces"]
["src/nvim/search.c", ["    }", "    if (depth >= 0) {           /* we could read the line */", "      files[depth].lnum++;"], "readability/old_style_comment"]
["src/nvim/search.c", ["      files[depth].lnum++;", "      /* Remove any CR and LF from the line. */", "      i = (int)STRLEN(line);"], "readability/old_style_comment"]
["src/nvim/search.c", ["      i = (int)STRLEN(line);", "      if (i > 0 && line[i - 1] == '\\n')", "        line[--i] = NUL;"], "readability/braces"]
["src/nvim/search.c", ["        line[--i] = NUL;", "      if (i > 0 && line[i - 1] == '\\r')", "        line[--i] = NUL;"], "readability/braces"]
["src/nvim/search.c", ["    } else if (!already) {", "      if (++lnum > end_lnum)", "        break;"], "readability/braces"]
["src/nvim/search.c", ["  }", "  /* End of big for (;;) loop. */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /* Close any files that are still open. */", "  for (i = 0; i <= depth; i++) {"], "readability/old_style_comment"]
["src/nvim/search.c", ["  }", "  for (i = old_files; i < max_path_depth; i++)", "    xfree(files[i].name);"], "readability/braces"]
["src/nvim/search.c", ["    if (!did_show) {", "      if (action != ACTION_SHOW_ALL)", "        MSG(_(\"All included files were found\"));"], "readability/braces"]
["src/nvim/search.c", ["        MSG(_(\"All included files were found\"));", "      else", "        MSG(_(\"No included files\"));"], "readability/braces"]
["src/nvim/search.c", ["             ) {", "    if (got_int || compl_interrupted)", "      EMSG(_(e_interr));"], "readability/braces"]
["src/nvim/search.c", ["      EMSG(_(e_interr));", "    else if (type == FIND_DEFINE)", "      EMSG(_(\"E388: Couldn't find definition\"));"], "readability/braces"]
["src/nvim/search.c", ["      EMSG(_(\"E388: Couldn't find definition\"));", "    else", "      EMSG(_(\"E389: Couldn't find pattern\"));"], "readability/braces"]
["src/nvim/search.c", ["  }", "  if (action == ACTION_SHOW || action == ACTION_SHOW_ALL)", "    msg_end();"], "readability/braces"]
["src/nvim/search.c", ["    if (fp != NULL) {", "      /* We used fgets(), so get rid of newline at end */", "      if (p >= line && *p == '\\n')"], "readability/old_style_comment"]
["src/nvim/search.c", ["      /* We used fgets(), so get rid of newline at end */", "      if (p >= line && *p == '\\n')", "        --p;"], "readability/braces"]
["src/nvim/search.c", ["      if (p >= line && *p == '\\n')", "        --p;", "      if (p >= line && *p == '\\r')"], "readability/increment"]
["src/nvim/search.c", ["        --p;", "      if (p >= line && *p == '\\r')", "        --p;"], "readability/braces"]
["src/nvim/search.c", ["      if (p >= line && *p == '\\r')", "        --p;", "      *(p + 1) = NUL;"], "readability/increment"]
["src/nvim/search.c", ["    }", "    msg_prt_line(line, FALSE);", "    ui_flush();                        /* show one line at a time */"], "readability/bool"]
["src/nvim/search.c", ["    msg_prt_line(line, FALSE);", "    ui_flush();                        /* show one line at a time */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /* Definition continues until line that doesn't end with '\\' */", "    if (got_int || type != FIND_DEFINE || p < line || *p != '\\\\')"], "readability/old_style_comment"]
["src/nvim/search.c", ["    /* Definition continues until line that doesn't end with '\\' */", "    if (got_int || type != FIND_DEFINE || p < line || *p != '\\\\')", "      break;"], "readability/braces"]
["src/nvim/search.c", ["    if (fp != NULL) {", "      if (vim_fgets(line, LSIZE, fp))       /* end of file */", "        break;"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (fp != NULL) {", "      if (vim_fgets(line, LSIZE, fp))       /* end of file */", "        break;"], "readability/braces"]
["src/nvim/search.c", ["        break;", "      ++*lnum;", "    } else {"], "readability/increment"]
["src/nvim/search.c", ["    } else {", "      if (++*lnum > curbuf->b_ml.ml_line_count)", "        break;"], "readability/braces"]
["src/nvim/search.h", ["", "/* Values for the find_pattern_in_path() function args 'type' and 'action': */", "#define FIND_ANY        1"], "readability/old_style_comment"]
["src/nvim/search.h", ["", "/* Values for flags argument for findmatchlimit() */", "#define FM_BACKWARD     0x01    /* search backwards */"], "readability/old_style_comment"]
["src/nvim/search.h", ["/* Values for flags argument for findmatchlimit() */", "#define FM_BACKWARD     0x01    /* search backwards */", "#define FM_FORWARD      0x02    /* search forwards */"], "readability/old_style_comment"]
["src/nvim/search.h", ["#define FM_BACKWARD     0x01    /* search backwards */", "#define FM_FORWARD      0x02    /* search forwards */", "#define FM_BLOCKSTOP    0x04    /* stop at start/end of block */"], "readability/old_style_comment"]
["src/nvim/search.h", ["#define FM_FORWARD      0x02    /* search forwards */", "#define FM_BLOCKSTOP    0x04    /* stop at start/end of block */", "#define FM_SKIPCOMM     0x08    /* skip comments */"], "readability/old_style_comment"]
["src/nvim/search.h", ["#define FM_BLOCKSTOP    0x04    /* stop at start/end of block */", "#define FM_SKIPCOMM     0x08    /* skip comments */", ""], "readability/old_style_comment"]
["src/nvim/search.h", ["", "/* Values for sub_cmd and which_pat argument for search_regcomp() */", "/* Also used for which_pat argument for searchit() */"], "readability/old_style_comment"]
["src/nvim/search.h", ["/* Values for sub_cmd and which_pat argument for search_regcomp() */", "/* Also used for which_pat argument for searchit() */", "#define RE_SEARCH       0       /* save/use pat in/from search_pattern */"], "readability/old_style_comment"]
["src/nvim/search.h", ["/* Also used for which_pat argument for searchit() */", "#define RE_SEARCH       0       /* save/use pat in/from search_pattern */", "#define RE_SUBST        1       /* save/use pat in/from subst_pattern */"], "readability/old_style_comment"]
["src/nvim/search.h", ["#define RE_SEARCH       0       /* save/use pat in/from search_pattern */", "#define RE_SUBST        1       /* save/use pat in/from subst_pattern */", "#define RE_BOTH         2       /* save pat in both patterns */"], "readability/old_style_comment"]
["src/nvim/search.h", ["#define RE_SUBST        1       /* save/use pat in/from subst_pattern */", "#define RE_BOTH         2       /* save pat in both patterns */", "#define RE_LAST         2       /* use last used pattern if \"pat\" is NULL */"], "readability/old_style_comment"]
["src/nvim/search.h", ["#define RE_BOTH         2       /* save pat in both patterns */", "#define RE_LAST         2       /* use last used pattern if \"pat\" is NULL */", ""], "readability/old_style_comment"]
["src/nvim/sha256.c", ["  (W[t] = S1(W[t -  2]) + W[t -  7] + \\", "           S0(W[t - 15]) + W[t - 16])", ""], "whitespace/alignment"]
["src/nvim/sha256.c", ["  temp2 = S2(a) + F0(a, b, c); \\", "  d += temp1; h = temp1 + temp2; \\", "}"], "whitespace/newline"]
["src/nvim/sha256.c", ["", "  ctx->total[0] += (uint32_t) length;", "  ctx->total[0] &= 0xFFFFFFFF;"], "whitespace/cast"]
["src/nvim/shada.c", ["#define copy_option_part(src, dest, ...) \\", "    ((char *) copy_option_part((char_u **) src, (char_u *) dest, __VA_ARGS__))", "#define find_shada_parameter(...) \\"], "whitespace/cast"]
["src/nvim/shada.c", ["#define find_shada_parameter(...) \\", "    ((const char *) find_shada_parameter(__VA_ARGS__))", "#define home_replace_save(a, b) \\"], "whitespace/cast"]
["src/nvim/shada.c", ["  if (hmll->free_entry == NULL) {", "    assert((size_t) (hmll->last_free_entry - hmll->entries)", "           == hmll->num_entries);"], "whitespace/cast"]
["src/nvim/shada.c", ["  } else {", "    assert((size_t) (hmll->last_free_entry - hmll->entries) - 1", "           == hmll->num_entries);"], "whitespace/cast"]
["src/nvim/shada.c", ["  }", "  return (int) ret;", "}"], "whitespace/cast"]
["src/nvim/shada.c", ["              \"but file ended earlier\"),", "            (uint64_t) offset);", "      return kSDReadStatusNotShaDa;"], "whitespace/cast"]
["src/nvim/shada.c", ["{", "  return kh_get(bufset, set, (uintptr_t) buf) != kh_end(set);", "}"], "whitespace/cast"]
["src/nvim/shada.c", ["{", "  ShaDaWriteDef *const sd_writer = (ShaDaWriteDef *) data;", "  ptrdiff_t written_bytes = sd_writer->write(sd_writer, buf, len);"], "whitespace/cast"]
["src/nvim/shada.c", ["          .histtype = history_type,", "          .string = (char *) hist_he.hisstr,", "          .sep = (char) (history_type == HIST_SEARCH"], "whitespace/cast"]
["src/nvim/shada.c", ["          .string = (char *) hist_he.hisstr,", "          .sep = (char) (history_type == HIST_SEARCH", "                         ? (char) hist_he.hisstr[STRLEN(hist_he.hisstr) + 1]"], "whitespace/cast"]
["src/nvim/shada.c", ["          .sep = (char) (history_type == HIST_SEARCH", "                         ? (char) hist_he.hisstr[STRLEN(hist_he.hisstr) + 1]", "                         : 0),"], "whitespace/cast"]
["src/nvim/shada.c", ["    hist->timestamp = cur_entry->data.timestamp;", "    hist->hisnum = (int) (hist - hist_array) + 1;", "    hist->hisstr = (char_u *) cur_entry->data.data.history_item.string;"], "whitespace/cast"]
["src/nvim/shada.c", ["    hist->hisnum = (int) (hist - hist_array) + 1;", "    hist->hisstr = (char_u *) cur_entry->data.data.history_item.string;", "    hist->additional_elements ="], "whitespace/cast"]
["src/nvim/shada.c", ["  })", "  *new_hisnum = (int) (hist - hist_array);", "  *new_hisidx = *new_hisnum - 1;"], "whitespace/cast"]
["src/nvim/shada.c", ["  do { \\", "    const int jl_len = (int) jumps_size; \\", "    int i; \\"], "whitespace/cast"]
["src/nvim/shada.c", ["        if (i > 0) { \\", "          memmove(&jumps[0], &jumps[1], sizeof(jumps[1]) * (size_t) i); \\", "        } \\"], "whitespace/cast"]
["src/nvim/shada.c", ["        memmove(&jumps[i + 1], &jumps[i], \\", "                sizeof(jumps[0]) * (size_t) (jl_len - i)); \\", "      } \\"], "whitespace/cast"]
["src/nvim/shada.c", ["      } else if (jl_len > 0) { \\", "        memmove(&jumps[1], &jumps[0], sizeof(jumps[0]) * (size_t) jl_len); \\", "      } \\"], "whitespace/cast"]
["src/nvim/shada.c", ["  const bool want_marks = flags & kShaDaWantMarks;", "  const unsigned srni_flags = (unsigned) (", "      (flags & kShaDaWantInfo"], "whitespace/cast"]
["src/nvim/shada.c", ["    for (uint8_t i = 0; i < HIST_COUNT; i++) {", "      hms_init(&hms[i], i, (size_t) p_hi, true, true);", "    }"], "whitespace/cast"]
["src/nvim/shada.c", ["           },", "           .pat = (char_u *) cur_entry.data.search_pattern.pat,", "           .additional_data = cur_entry.data.search_pattern.additional_data,"], "whitespace/cast"]
["src/nvim/shada.c", ["        // regtilde. Vim was not calling this for some reason.", "        (void) regtilde(cur_entry.data.sub_string.sub, p_magic);", "        // Do not free shada entry: its allocated memory was saved above."], "whitespace/cast"]
["src/nvim/shada.c", ["          .y_type = cur_entry.data.reg.type,", "          .y_width = (colnr_T) cur_entry.data.reg.width,", "          .timestamp = cur_entry.timestamp,"], "whitespace/cast"]
["src/nvim/shada.c", ["        xfmark_T fm = (xfmark_T) {", "          .fname = (char_u *) (buf == NULL", "                               ? cur_entry.data.filemark.fname"], "whitespace/cast"]
["src/nvim/shada.c", ["          int kh_ret;", "          (void) kh_put(bufset, &cl_bufs, (uintptr_t) buf, &kh_ret);", "#define SDE_TO_FMARK(entry) fm"], "whitespace/cast"]
["src/nvim/shada.c", ["    FOR_ALL_TAB_WINDOWS(tp, wp) {", "      (void) tp;", "      if (in_bufset(&cl_bufs, wp->w_buffer)) {"], "whitespace/cast"]
["src/nvim/shada.c", ["  kh_foreach_key(&fname_bufs, key, {", "    xfree((void *) key);", "  })"], "whitespace/cast"]
["src/nvim/shada.c", ["      expand_env((char_u *)file, &(NameBuff[0]), MAXPATHL);", "      file = (const char *) &(NameBuff[0]);", "    }"], "whitespace/cast"]
["src/nvim/shada.c", ["#define ONE_IF_NOT_DEFAULT(entry, attr) \\", "  ((size_t) (!CHECK_DEFAULT(entry, attr)))", "  switch (entry.type) {"], "whitespace/cast"]
["src/nvim/shada.c", ["      if (spacker->callback(spacker->data, entry.data.unknown_item.contents,", "                            (unsigned) entry.data.unknown_item.size) == -1) {", "        goto shada_pack_entry_error;"], "whitespace/cast"]
["src/nvim/shada.c", ["    case kSDItemSearchPattern: {", "      const size_t map_size = (size_t) (", "          1  // Search pattern is always present"], "whitespace/cast"]
["src/nvim/shada.c", ["          // finally, additional data:", "          + (size_t) (", "              entry.data.search_pattern.additional_data"], "whitespace/cast"]
["src/nvim/shada.c", ["    case kSDItemJump: {", "      const size_t map_size = (size_t) (", "          1  // File name"], "whitespace/cast"]
["src/nvim/shada.c", ["          // Additional entries, if any:", "          + (size_t) (", "              entry.data.filemark.additional_data == NULL"], "whitespace/cast"]
["src/nvim/shada.c", ["        PACK_STATIC_STR(KEY_NAME_CHAR);", "        msgpack_pack_uint8(spacker, (uint8_t) entry.data.filemark.name);", "      }"], "whitespace/cast"]
["src/nvim/shada.c", ["    case kSDItemRegister: {", "      const size_t map_size = (size_t) (", "          2  // Register contents and name"], "whitespace/cast"]
["src/nvim/shada.c", ["          // Additional entries, if any:", "          + (size_t) (entry.data.reg.additional_data == NULL", "                      ? 0"], "whitespace/cast"]
["src/nvim/shada.c", ["        PACK_STATIC_STR(REG_KEY_WIDTH);", "        msgpack_pack_uint64(spacker, (uint64_t) entry.data.reg.width);", "      }"], "whitespace/cast"]
["src/nvim/shada.c", ["      for (size_t i = 0; i < entry.data.buffer_list.size; i++) {", "        const size_t map_size = (size_t) (", "            1  // Buffer name"], "whitespace/cast"]
["src/nvim/shada.c", ["            1  // Buffer name", "            + (size_t) (entry.data.buffer_list.buffers[i].pos.lnum", "                        != default_pos.lnum)"], "whitespace/cast"]
["src/nvim/shada.c", ["                        != default_pos.lnum)", "            + (size_t) (entry.data.buffer_list.buffers[i].pos.col", "                        != default_pos.col)"], "whitespace/cast"]
["src/nvim/shada.c", ["            // Additional entries, if any:", "            + (size_t) (", "                entry.data.buffer_list.buffers[i].additional_data == NULL"], "whitespace/cast"]
["src/nvim/shada.c", ["          msgpack_pack_uint64(", "              spacker, (uint64_t) entry.data.buffer_list.buffers[i].pos.lnum);", "        }"], "whitespace/cast"]
["src/nvim/shada.c", ["          msgpack_pack_uint64(", "              spacker, (uint64_t) entry.data.buffer_list.buffers[i].pos.col);", "        }"], "whitespace/cast"]
["src/nvim/shada.c", ["          case kObjectTypeInteger: {", "            msgpack_pack_int64(spacker, (int64_t) obj.data.integer);", "            break;"], "whitespace/cast"]
["src/nvim/shada.c", ["    } else {", "      if (msgpack_pack_uint64(packer, (uint64_t) entry.type) == -1) {", "        goto shada_pack_entry_error;"], "whitespace/cast"]
["src/nvim/shada.c", ["    }", "    if (msgpack_pack_uint64(packer, (uint64_t) entry.timestamp) == -1) {", "      goto shada_pack_entry_error;"], "whitespace/cast"]
["src/nvim/shada.c", ["    if (sbuf.size > 0) {", "      if ((msgpack_pack_uint64(packer, (uint64_t) sbuf.size) == -1)", "          || (packer->callback(packer->data, sbuf.data,"], "whitespace/cast"]
["src/nvim/shada.c", ["          || (packer->callback(packer->data, sbuf.data,", "                               (unsigned) sbuf.size) == -1)) {", "        goto shada_pack_entry_error;"], "whitespace/cast"]
["src/nvim/shada.c", ["              \"at position %\" PRIu64),", "            (uint64_t) initial_fpos);", "      ret = kSDReadStatusNotShaDa;"], "whitespace/cast"]
["src/nvim/shada.c", ["              \"at position %\" PRIu64),", "            (uint64_t) initial_fpos);", "      ret = kSDReadStatusNotShaDa;"], "whitespace/cast"]
["src/nvim/shada.c", ["              \"at position %\" PRIu64),", "            (uint64_t) initial_fpos);", "      ret = kSDReadStatusNotShaDa;"], "whitespace/cast"]
["src/nvim/shada.c", ["        }", "        const char *const fname = (const char *) entry.data.filemark.fname;", "        khiter_t k;"], "whitespace/cast"]
["src/nvim/shada.c", ["  khash_t(bufset) removable_bufs = KHASH_EMPTY_TABLE(bufset);", "  const size_t max_kbyte = (size_t) max_kbyte_i;", "  const size_t num_marked_files = (size_t) get_shada_parameter('\\'');"], "whitespace/cast"]
["src/nvim/shada.c", ["  const size_t max_kbyte = (size_t) max_kbyte_i;", "  const size_t num_marked_files = (size_t) get_shada_parameter('\\'');", "  const bool dump_global_marks = get_shada_parameter('f') != 0;"], "whitespace/cast"]
["src/nvim/shada.c", ["      dump_one_history[i] = true;", "      hms_init(&wms->hms[i], i, (size_t) num_saved, sd_reader != NULL, false);", "    } else {"], "whitespace/cast"]
["src/nvim/shada.c", ["", "  const unsigned srni_flags = (unsigned) (", "      kSDReadUndisableableData"], "whitespace/cast"]
["src/nvim/shada.c", ["          { STATIC_CSTR_AS_STRING(\"max_kbyte\"),", "            INTEGER_OBJ((Integer) max_kbyte) },", "          { STATIC_CSTR_AS_STRING(\"pid\"),"], "whitespace/cast"]
["src/nvim/shada.c", ["          { STATIC_CSTR_AS_STRING(\"pid\"),", "            INTEGER_OBJ((Integer) os_get_pid()) },", "          { STATIC_CSTR_AS_STRING(\"encoding\"),"], "whitespace/cast"]
["src/nvim/shada.c", ["          { STATIC_CSTR_AS_STRING(\"encoding\"),", "            STRING_OBJ(cstr_as_string((char *) p_enc)) },", "        }),"], "whitespace/cast"]
["src/nvim/shada.c", ["          .global_var = {", "            .name = (char *) name,", "            .value = tgttv,"], "whitespace/cast"]
["src/nvim/shada.c", ["        int kh_ret;", "        (void) kh_put(strset, &wms->dumped_variables, name, &kh_ret);", "      }"], "whitespace/cast"]
["src/nvim/shada.c", ["          .sub_string = {", "            .sub = (char *) sub.sub,", "            .additional_elements = sub.additional_elements,"], "whitespace/cast"]
["src/nvim/shada.c", ["        assert(fm.fname != NULL);", "        if (shada_removable((const char *) fm.fname)) {", "          continue;"], "whitespace/cast"]
["src/nvim/shada.c", ["        }", "        fname = (const char *) fm.fname;", "      } else {"], "whitespace/cast"]
["src/nvim/shada.c", ["        }", "        fname = (const char *) buf->b_ffname;", "      }"], "whitespace/cast"]
["src/nvim/shada.c", ["      const void *local_marks_iter = NULL;", "      const char *const fname = (const char *) buf->b_ffname;", "      khiter_t k;"], "whitespace/cast"]
["src/nvim/shada.c", ["                .name = name,", "                .fname = (char *) fname,", "                .additional_data = fm.additional_data,"], "whitespace/cast"]
["src/nvim/shada.c", ["                .mark = fm.mark,", "                .fname = (char *) fname,", "                .additional_data = fm.additional_data,"], "whitespace/cast"]
["src/nvim/shada.c", ["      }", "      filemarks->changes_size = (size_t) buf->b_changelistlen;", "    }"], "whitespace/cast"]
["src/nvim/shada.c", ["  }", "  qsort((void *) all_file_markss, file_markss_size, sizeof(*all_file_markss),", "        &compare_file_marks);"], "whitespace/cast"]
["src/nvim/shada.c", ["    // Save permissions from the original file, with modifications:", "    int perm = (int) os_getperm(fname);", "    perm = (perm >= 0) ? ((perm & 0777) | 0600) : 0600;"], "whitespace/cast"]
["src/nvim/shada.c", ["  // order.", "  uint8_t *buf = (uint8_t *) &big_endian_64_bits;", "  uint64_t ret = 0;"], "whitespace/cast"]
["src/nvim/shada.c", ["  for (size_t i = 8; i; i--) {", "    ret |= ((uint64_t) buf[i - 1]) << ((8 - i) * 8);", "  }"], "whitespace/cast"]
["src/nvim/shada.c", ["              \", but got nothing\"),", "            (uint64_t) fpos);", "      return kSDReadStatusNotShaDa;"], "whitespace/cast"]
["src/nvim/shada.c", ["    // Positive fixnum", "    *result = (uint64_t) ((uint8_t) first_char);", "  } else {"], "whitespace/cast"]
["src/nvim/shada.c", ["                \"expected positive integer at position %\" PRIu64),", "              (uint64_t) fpos);", "        return kSDReadStatusNotShaDa;"], "whitespace/cast"]
["src/nvim/shada.c", ["    uint64_t buf = 0;", "    char *buf_u8 = (char *) &buf;", "    ShaDaReadResult fl_ret;"], "whitespace/cast"]
["src/nvim/shada.c", ["              .map = { \\", "                .size = (uint32_t) ad_ga.ga_len, \\", "                .ptr = ad_ga.ga_data, \\"], "whitespace/cast"]
["src/nvim/shada.c", ["      do { \\", "        if ((src).size > (size_t) (src_maxsize)) { \\", "          msgpack_object obj = { \\"], "whitespace/cast"]
["src/nvim/shada.c", ["              .array = { \\", "                .size = ((src).size - (uint32_t) (src_maxsize)), \\", "                .ptr = (src).ptr + (src_maxsize), \\"], "whitespace/cast"]
["src/nvim/shada.c", ["  // This is needed to avoid both seeking and having to maintain a buffer.", "  uint64_t type_u64 = (uint64_t) kSDItemMissing;", "  uint64_t timestamp_u64;"], "whitespace/cast"]
["src/nvim/shada.c", ["", "  const uint64_t initial_fpos = (uint64_t) sd_reader->fpos;", "  const int first_char = read_char(sd_reader);"], "whitespace/cast"]
["src/nvim/shada.c", ["       ? !(flags & kSDReadUnknown)", "       : !((unsigned) (1 << type_u64) & flags))", "      || (max_kbyte && length > max_kbyte * 1024)) {"], "whitespace/cast"]
["src/nvim/shada.c", ["  entry->data = sd_default_values[type_u64].data;", "  switch ((ShadaEntryType) type_u64) {", "    case kSDItemHeader: {"], "whitespace/cast"]
["src/nvim/shada.c", ["      entry->data.history_item.histtype =", "          (uint8_t) unpacked.data.via.array.ptr[0].via.u64;", "      const bool is_hist_search ="], "whitespace/cast"]
["src/nvim/shada.c", ["        entry->data.history_item.sep =", "            (char) unpacked.data.via.array.ptr[2].via.u64;", "      }"], "whitespace/cast"]
["src/nvim/shada.c", ["  }", "  entry->type = (ShadaEntryType) type_u64;", "  ret = kSDReadStatusSuccess;"], "whitespace/cast"]
["src/nvim/shada.c", ["shada_read_next_item_error:", "  entry->type = (ShadaEntryType) type_u64;", "  shada_free_shada_entry(entry);"], "whitespace/cast"]
["src/nvim/shada.c", ["  char *new_name = home_replace_save(NULL, name);", "  for (p = (char *) p_shada; *p; ) {", "    (void) copy_option_part(&p, part, ARRAY_SIZE(part), \", \");"], "whitespace/cast"]
["src/nvim/shada.c", ["  for (p = (char *) p_shada; *p; ) {", "    (void) copy_option_part(&p, part, ARRAY_SIZE(part), \", \");", "    if (part[0] == 'r') {"], "whitespace/cast"]
["src/nvim/shada.c", ["    }", "    const char *const fname = (char *) (fm.fmark.fnum == 0", "                                        ? (fm.fname == NULL ? NULL : fm.fname)"], "whitespace/cast"]
["src/nvim/shada.c", ["            .mark = fm.fmark.mark,", "            .fname = (char *) fname,", "            .additional_data = fm.fmark.additional_data,"], "whitespace/cast"]
["src/nvim/sign_defs.h", ["", "#endif // NVIM_SIGN_DEFS_H", ""], "build/header_guard"]
["src/nvim/sign_defs.h", ["", "#endif // NVIM_SIGN_DEFS_H", ""], "whitespace/comments"]
["src/nvim/spell.c", ["", "/* for offsetof() */", "#include <stddef.h>"], "readability/old_style_comment"]
["src/nvim/spell.c", ["typedef struct {", "  short sft_score;              // lowest score used", "  char_u sft_word[1];           // soundfolded word, actually longer"], "runtime/int"]
["src/nvim/spell.c", ["    if (*ptr == '0' && (ptr[1] == 'b' || ptr[1] == 'B')) {", "      mi.mi_end = (char_u*) skipbin((char*) ptr + 2);", "    } else if (*ptr == '0' && (ptr[1] == 'x' || ptr[1] == 'X')) {"], "whitespace/operators"]
["src/nvim/spell.c", ["    if (*ptr == '0' && (ptr[1] == 'b' || ptr[1] == 'B')) {", "      mi.mi_end = (char_u*) skipbin((char*) ptr + 2);", "    } else if (*ptr == '0' && (ptr[1] == 'x' || ptr[1] == 'X')) {"], "whitespace/cast"]
["src/nvim/spell.c", ["  // language.", "  for (lpi = 0; lpi < wp->w_s->b_langp.ga_len; ++lpi) {", "    mi.mi_lp = LANGP_ENTRY(wp->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["      count_common_word(mi.mi_lp->lp_slang, ptr,", "          (int)(mi.mi_end - ptr), 1);", "      count_word = false;"], "whitespace/alignment"]
["src/nvim/spell.c", ["", "    if (mode == FIND_KEEPCOMPOUND)", "      // Skip over the previously found word(s)."], "readability/braces"]
["src/nvim/spell.c", ["    }", "", "  }"], "whitespace/blank_line"]
["src/nvim/spell.c", ["", "  if (byts == NULL)", "    return;                     // array is empty"], "readability/braces"]
["src/nvim/spell.c", ["  for (;; ) {", "    if (flen <= 0 && *mip->mi_fend != NUL)", "      flen = fold_more(mip);"], "readability/braces"]
["src/nvim/spell.c", ["      endidx[endidxcnt++] = arridx++;", "      --len;", ""], "readability/increment"]
["src/nvim/spell.c", ["      while (len > 0 && byts[arridx] == 0) {", "        ++arridx;", "        --len;"], "readability/increment"]
["src/nvim/spell.c", ["        ++arridx;", "        --len;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["      }", "      if (len == 0)", "        break;              // no children, word must end here"], "readability/braces"]
["src/nvim/spell.c", ["    // Stop looking at end of the line.", "    if (ptr[wlen] == NUL)", "      break;"], "readability/braces"]
["src/nvim/spell.c", ["    c = ptr[wlen];", "    if (c == TAB)           // <Tab> is handled like <Space>", "      c = ' ';"], "readability/braces"]
["src/nvim/spell.c", ["      idx_T m = (lo + hi) / 2;", "      if (byts[m] > c)", "        hi = m - 1;"], "readability/braces"]
["src/nvim/spell.c", ["        hi = m - 1;", "      else if (byts[m] < c)", "        lo = m + 1;"], "readability/braces"]
["src/nvim/spell.c", ["        lo = m + 1;", "      else {", "        lo = hi = m;"], "readability/braces"]
["src/nvim/spell.c", ["        lo = m + 1;", "      else {", "        lo = hi = m;"], "readability/braces"]
["src/nvim/spell.c", ["    // Stop if there is no matching byte.", "    if (hi < lo || byts[lo] != c)", "      break;"], "readability/braces"]
["src/nvim/spell.c", ["    arridx = idxs[lo];", "    ++wlen;", "    --flen;"], "readability/increment"]
["src/nvim/spell.c", ["    ++wlen;", "    --flen;", ""], "readability/increment"]
["src/nvim/spell.c", ["      for (;; ) {", "        if (flen <= 0 && *mip->mi_fend != NUL)", "          flen = fold_more(mip);"], "readability/braces"]
["src/nvim/spell.c", ["          flen = fold_more(mip);", "        if (ptr[wlen] != ' ' && ptr[wlen] != TAB)", "          break;"], "readability/braces"]
["src/nvim/spell.c", ["          break;", "        ++wlen;", "        --flen;"], "readability/increment"]
["src/nvim/spell.c", ["        ++wlen;", "        --flen;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["  while (endidxcnt > 0) {", "    --endidxcnt;", "    arridx = endidx[endidxcnt];"], "readability/increment"]
["src/nvim/spell.c", ["    if (spell_iswordp(ptr + wlen, mip->mi_win)) {", "      if (slang->sl_compprog == NULL && !slang->sl_nobreak)", "        continue;                   // next char is a word character"], "readability/braces"]
["src/nvim/spell.c", ["      word_ends = false;", "    } else", "      word_ends = true;"], "readability/braces"]
["src/nvim/spell.c", ["    for (len = byts[arridx - 1]; len > 0 && byts[arridx] == 0;", "         --len, ++arridx) {", "      uint32_t flags = idxs[arridx];"], "readability/increment"]
["src/nvim/spell.c", ["", "        if (mip->mi_capflags == WF_KEEPCAP", "            || !spell_valid_case(mip->mi_capflags, flags))"], "readability/braces"]
["src/nvim/spell.c", ["      // mip->mi_prefarridx that find_prefix() filled.", "      else if (mode == FIND_PREFIX && !prefix_found) {", "        c = valid_word_prefix(mip->mi_prefcnt, mip->mi_prefarridx,"], "whitespace/newline"]
["src/nvim/spell.c", ["        c = valid_word_prefix(mip->mi_prefcnt, mip->mi_prefarridx,", "            flags,", "            mip->mi_word + mip->mi_cprefixlen, slang,"], "whitespace/alignment"]
["src/nvim/spell.c", ["            flags,", "            mip->mi_word + mip->mi_cprefixlen, slang,", "            false);"], "whitespace/alignment"]
["src/nvim/spell.c", ["            mip->mi_word + mip->mi_cprefixlen, slang,", "            false);", "        if (c == 0)"], "whitespace/alignment"]
["src/nvim/spell.c", ["            false);", "        if (c == 0)", "          continue;"], "readability/braces"]
["src/nvim/spell.c", ["        // Use the WF_RARE flag for a rare prefix.", "        if (c & WF_RAREPFX)", "          flags |= WF_RARE;"], "readability/braces"]
["src/nvim/spell.c", ["        // anyway.", "        if (((unsigned)flags >> 24) == 0", "            || wlen - mip->mi_compoff < slang->sl_compminlen)"], "readability/braces"]
["src/nvim/spell.c", ["        // maximum for syllables is specified.", "        if (!word_ends && mip->mi_complen + mip->mi_compextra + 2", "            > slang->sl_compmax"], "readability/braces"]
["src/nvim/spell.c", ["        // unless COMPOUNDPERMITFLAG was used.", "        if (mip->mi_complen > 0 && (flags & WF_NOCOMPBEF))", "          continue;"], "readability/braces"]
["src/nvim/spell.c", ["          continue;", "        if (!word_ends && (flags & WF_NOCOMPAFT))", "          continue;"], "readability/braces"]
["src/nvim/spell.c", ["        // Quickly check if compounding is possible with this flag.", "        if (!byte_in_str(mip->mi_complen == 0", "                ? slang->sl_compstartflags"], "readability/braces"]
["src/nvim/spell.c", ["        if (!byte_in_str(mip->mi_complen == 0", "                ? slang->sl_compstartflags", "                : slang->sl_compallflags,"], "whitespace/alignment"]
["src/nvim/spell.c", ["                ? slang->sl_compstartflags", "                : slang->sl_compallflags,", "                ((unsigned)flags >> 24)))"], "whitespace/alignment"]
["src/nvim/spell.c", ["                : slang->sl_compallflags,", "                ((unsigned)flags >> 24)))", "          continue;"], "whitespace/alignment"]
["src/nvim/spell.c", ["        // discard the compound word.", "        if (match_checkcompoundpattern(ptr, wlen, &slang->sl_comppat))", "          continue;"], "readability/braces"]
["src/nvim/spell.c", ["          capflags = captype(p, mip->mi_word + wlen);", "          if (capflags == WF_KEEPCAP || (capflags == WF_ALLCAP", "                                         && (flags & WF_FIXCAP) != 0))"], "readability/braces"]
["src/nvim/spell.c", ["            // \"fword\" is only needed for checking syllables.", "            if (ptr == mip->mi_word)", "              (void)spell_casefold(ptr, wlen, fword, MAXWLEN);"], "readability/braces"]
["src/nvim/spell.c", ["              (void)spell_casefold(ptr, wlen, fword, MAXWLEN);", "            else", "              STRLCPY(fword, ptr, endlen[endidxcnt] + 1);"], "readability/braces"]
["src/nvim/spell.c", ["          }", "          if (!can_compound(slang, fword, mip->mi_compflags))", "            continue;"], "readability/braces"]
["src/nvim/spell.c", ["            continue;", "        } else if (slang->sl_comprules != NULL", "                   && !match_compoundrule(slang, mip->mi_compflags))"], "readability/braces"]
["src/nvim/spell.c", ["      // Check NEEDCOMPOUND: can't use word without compounding.", "      else if (flags & WF_NEEDCOMP)", "        continue;"], "whitespace/newline"]
["src/nvim/spell.c", ["        // Recursive!", "        if (slang->sl_nobreak)", "          mip->mi_result = SP_BAD;"], "readability/braces"]
["src/nvim/spell.c", ["#endif", "        ++mip->mi_complen;", "        if (flags & WF_COMPROOT)"], "readability/increment"]
["src/nvim/spell.c", ["        ++mip->mi_complen;", "        if (flags & WF_COMPROOT)", "          ++mip->mi_compextra;"], "readability/braces"]
["src/nvim/spell.c", ["        if (flags & WF_COMPROOT)", "          ++mip->mi_compextra;", ""], "readability/increment"]
["src/nvim/spell.c", ["        // to find the \".add\" file(s).", "        for (int lpi = 0; lpi < mip->mi_win->w_s->b_langp.ga_len; ++lpi) {", "          if (slang->sl_nobreak) {"], "readability/increment"]
["src/nvim/spell.c", ["            mip->mi_lp = LANGP_ENTRY(mip->mi_win->w_s->b_langp, lpi);", "            if (mip->mi_lp->lp_slang->sl_fidxs == NULL", "                || !mip->mi_lp->lp_slang->sl_nobreak)"], "readability/braces"]
["src/nvim/spell.c", ["", "          if (!slang->sl_nobreak)", "            break;"], "readability/braces"]
["src/nvim/spell.c", ["        }", "        --mip->mi_complen;", "        if (flags & WF_COMPROOT)"], "readability/increment"]
["src/nvim/spell.c", ["        --mip->mi_complen;", "        if (flags & WF_COMPROOT)", "          --mip->mi_compextra;"], "readability/braces"]
["src/nvim/spell.c", ["        if (flags & WF_COMPROOT)", "          --mip->mi_compextra;", "        mip->mi_lp = save_lp;"], "readability/increment"]
["src/nvim/spell.c", ["        } else {", "          if (mip->mi_result == SP_OK)", "            break;"], "readability/braces"]
["src/nvim/spell.c", ["      int res = SP_BAD;", "      if (flags & WF_BANNED)", "        res = SP_BANNED;"], "readability/braces"]
["src/nvim/spell.c", ["        res = SP_BANNED;", "      else if (flags & WF_REGION) {", "        // Check region."], "readability/braces"]
["src/nvim/spell.c", ["        // Check region.", "        if ((mip->mi_lp->lp_region & (flags >> 16)) != 0)", "          res = SP_OK;"], "readability/braces"]
["src/nvim/spell.c", ["          res = SP_OK;", "        else", "          res = SP_LOCAL;"], "readability/braces"]
["src/nvim/spell.c", ["          res = SP_LOCAL;", "      } else if (flags & WF_RARE)", "        res = SP_RARE;"], "readability/braces"]
["src/nvim/spell.c", ["        res = SP_RARE;", "      else", "        res = SP_OK;"], "readability/braces"]
["src/nvim/spell.c", ["          mip->mi_end2 = mip->mi_word + wlen;", "        } else if (mip->mi_result2 == res", "                   && mip->mi_end2 < mip->mi_word + wlen)"], "readability/braces"]
["src/nvim/spell.c", ["        mip->mi_end = mip->mi_word + wlen;", "      } else if (mip->mi_result == res && mip->mi_end < mip->mi_word + wlen)", "        mip->mi_end = mip->mi_word + wlen;"], "readability/braces"]
["src/nvim/spell.c", ["", "      if (mip->mi_result == SP_OK)", "        break;"], "readability/braces"]
["src/nvim/spell.c", ["", "    if (mip->mi_result == SP_OK)", "      break;"], "readability/braces"]
["src/nvim/spell.c", ["static bool", "match_checkcompoundpattern (", "    char_u *ptr,"], "whitespace/parens"]
["src/nvim/spell.c", ["      len = (int)STRLEN(p);", "      if (len <= wlen && STRNCMP(ptr + wlen - len, p, len) == 0)", "        return true;"], "readability/braces"]
["src/nvim/spell.c", ["  // COMPOUNDWORDMAX then compounding is not allowed.", "  if (slang->sl_compsylmax < MAXWLEN", "      && count_syllables(slang, word) > slang->sl_compsylmax)"], "readability/braces"]
["src/nvim/spell.c", ["// lines if they don't contain wildcards.", "static bool can_be_compound(trystate_T *sp, slang_T *slang, char_u *compflags, int flag)", "{"], "whitespace/line_length"]
["src/nvim/spell.c", ["  // then it can't possibly compound.", "  if (!byte_in_str(sp->ts_complen == sp->ts_compsplit", "          ? slang->sl_compstartflags : slang->sl_compallflags, flag))"], "readability/braces"]
["src/nvim/spell.c", ["  if (!byte_in_str(sp->ts_complen == sp->ts_compsplit", "          ? slang->sl_compstartflags : slang->sl_compallflags, flag))", "    return false;"], "whitespace/alignment"]
["src/nvim/spell.c", ["  // loop over all the COMPOUNDRULE entries", "  for (p = slang->sl_comprules; *p != NUL; ++p) {", "    // loop over the flags in the compound word we have made, match"], "readability/increment"]
["src/nvim/spell.c", ["    // them against the current rule entry", "    for (i = 0;; ++i) {", "      c = compflags[i];"], "readability/increment"]
["src/nvim/spell.c", ["      c = compflags[i];", "      if (c == NUL)", "        // found a rule that matches for the flags we have so far"], "readability/braces"]
["src/nvim/spell.c", ["        return true;", "      if (*p == '/' || *p == NUL)", "        break;          // end of rule, it's too short"], "readability/braces"]
["src/nvim/spell.c", ["        // compare against all the flags in []", "        ++p;", "        while (*p != ']' && *p != NUL)"], "readability/increment"]
["src/nvim/spell.c", ["        ++p;", "        while (*p != ']' && *p != NUL)", "          if (*p++ == c)"], "readability/braces"]
["src/nvim/spell.c", ["        while (*p != ']' && *p != NUL)", "          if (*p++ == c)", "            match = true;"], "readability/braces"]
["src/nvim/spell.c", ["            match = true;", "        if (!match)", "          break;            // none matches"], "readability/braces"]
["src/nvim/spell.c", ["          break;            // none matches", "      } else if (*p != c)", "        break;          // flag of word doesn't match flag in pattern"], "readability/braces"]
["src/nvim/spell.c", ["        break;          // flag of word doesn't match flag in pattern", "      ++p;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["    p = vim_strchr(p, '/');", "    if (p == NULL)", "      break;"], "readability/braces"]
["src/nvim/spell.c", ["static int", "valid_word_prefix (", "    int totprefcnt,                 // nr of prefix IDs"], "whitespace/parens"]
["src/nvim/spell.c", ["  prefid = (unsigned)flags >> 24;", "  for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt) {", "    pidx = slang->sl_pidxs[arridx + prefcnt];"], "readability/increment"]
["src/nvim/spell.c", ["    // Check the prefix ID.", "    if (prefid != (pidx & 0xff))", "      continue;"], "readability/braces"]
["src/nvim/spell.c", ["    // suffix.", "    if ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))", "      continue;"], "readability/braces"]
["src/nvim/spell.c", ["      }", "    } else if (cond_req)", "      continue;"], "readability/braces"]
["src/nvim/spell.c", ["  byts = slang->sl_pbyts;", "  if (byts == NULL)", "    return;                     // array is empty"], "readability/braces"]
["src/nvim/spell.c", ["  for (;; ) {", "    if (flen == 0 && *mip->mi_fend != NUL)", "      flen = fold_more(mip);"], "readability/braces"]
["src/nvim/spell.c", ["      while (len > 0 && byts[arridx] == 0) {", "        ++arridx;", "        --len;"], "readability/increment"]
["src/nvim/spell.c", ["        ++arridx;", "        --len;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["      mip->mi_prefixlen = wlen;", "      if (mode == FIND_COMPOUND)", "        // Skip over the previously found word(s)."], "readability/braces"]
["src/nvim/spell.c", ["", "      if (len == 0)", "        break;              // no children, word must end here"], "readability/braces"]
["src/nvim/spell.c", ["    // Stop looking at end of the line.", "    if (ptr[wlen] == NUL)", "      break;"], "readability/braces"]
["src/nvim/spell.c", ["      m = (lo + hi) / 2;", "      if (byts[m] > c)", "        hi = m - 1;"], "readability/braces"]
["src/nvim/spell.c", ["        hi = m - 1;", "      else if (byts[m] < c)", "        lo = m + 1;"], "readability/braces"]
["src/nvim/spell.c", ["        lo = m + 1;", "      else {", "        lo = hi = m;"], "readability/braces"]
["src/nvim/spell.c", ["        lo = m + 1;", "      else {", "        lo = hi = m;"], "readability/braces"]
["src/nvim/spell.c", ["    // Stop if there is no matching byte.", "    if (hi < lo || byts[lo] != c)", "      break;"], "readability/braces"]
["src/nvim/spell.c", ["    arridx = idxs[lo];", "    ++wlen;", "    --flen;"], "readability/increment"]
["src/nvim/spell.c", ["    ++wlen;", "    --flen;", "  }"], "readability/increment"]
["src/nvim/spell.c", ["  (void)spell_casefold(p, (int)(mip->mi_fend - p),", "      mip->mi_fword + mip->mi_fwordlen,", "      MAXWLEN - mip->mi_fwordlen);"], "whitespace/alignment"]
["src/nvim/spell.c", ["      mip->mi_fword + mip->mi_fwordlen,", "      MAXWLEN - mip->mi_fwordlen);", "  flen = (int)STRLEN(mip->mi_fword + mip->mi_fwordlen);"], "whitespace/alignment"]
["src/nvim/spell.c", ["size_t", "spell_move_to (", "    win_T *wp,"], "whitespace/parens"]
["src/nvim/spell.c", ["", "  if (no_spell_checking(wp))", "    return 0;"], "readability/braces"]
["src/nvim/spell.c", ["  while (!got_int) {", "    line = ml_get_buf(wp->w_buffer, lnum, FALSE);", ""], "readability/bool"]
["src/nvim/spell.c", ["    // In first line check first word for Capital.", "    if (lnum == 1)", "      capcol = 0;"], "readability/braces"]
["src/nvim/spell.c", ["      // one.", "      line = ml_get_buf(wp->w_buffer, lnum, FALSE);", "    }"], "readability/bool"]
["src/nvim/spell.c", ["    STRCPY(buf, line);", "    if (lnum < wp->w_buffer->b_ml.ml_line_count)", "      spell_cat_line(buf + STRLEN(buf),"], "readability/braces"]
["src/nvim/spell.c", ["      spell_cat_line(buf + STRLEN(buf),", "                     ml_get_buf(wp->w_buffer, lnum + 1, FALSE),", "                     MAXWLEN);"], "readability/bool"]
["src/nvim/spell.c", ["      // we wrapped around the end of the buffer.", "      if (dir == BACKWARD", "          && lnum == wp->w_cursor.lnum"], "readability/braces"]
["src/nvim/spell.c", ["              (void)syn_get_id(wp, lnum, (colnr_T)col,", "                  FALSE, &can_spell, FALSE);", "              if (!can_spell)"], "whitespace/alignment"]
["src/nvim/spell.c", ["              (void)syn_get_id(wp, lnum, (colnr_T)col,", "                  FALSE, &can_spell, FALSE);", "              if (!can_spell)"], "readability/bool"]
["src/nvim/spell.c", ["                  FALSE, &can_spell, FALSE);", "              if (!can_spell)", "                attr = HLF_COUNT;"], "readability/braces"]
["src/nvim/spell.c", ["                attr = HLF_COUNT;", "            } else", "              can_spell = true;"], "readability/braces"]
["src/nvim/spell.c", ["                xfree(buf);", "                if (attrp != NULL)", "                  *attrp = attr;"], "readability/braces"]
["src/nvim/spell.c", ["            }", "          } else", "            found_one = true;"], "readability/braces"]
["src/nvim/spell.c", ["        wrapped = true;", "        if (!shortmess(SHM_SEARCH))", "          give_warning((char_u *)_(top_bot_msg), true);"], "readability/braces"]
["src/nvim/spell.c", ["    } else {", "      if (lnum < wp->w_buffer->b_ml.ml_line_count)", "        ++lnum;"], "readability/braces"]
["src/nvim/spell.c", ["      if (lnum < wp->w_buffer->b_ml.ml_line_count)", "        ++lnum;", "      else if (!p_ws)"], "readability/increment"]
["src/nvim/spell.c", ["        ++lnum;", "      else if (!p_ws)", "        break;              // at first line and 'nowrapscan'"], "readability/braces"]
["src/nvim/spell.c", ["        break;              // at first line and 'nowrapscan'", "      else {", "        // Wrap around to the start of the buffer.  May search the"], "readability/braces"]
["src/nvim/spell.c", ["        break;              // at first line and 'nowrapscan'", "      else {", "        // Wrap around to the start of the buffer.  May search the"], "readability/braces"]
["src/nvim/spell.c", ["        wrapped = true;", "        if (!shortmess(SHM_SEARCH))", "          give_warning((char_u *)_(bot_top_msg), true);"], "readability/braces"]
["src/nvim/spell.c", ["      // included in a match crossing line boundaries.", "      if (attr == HLF_COUNT)", "        skip = (int)(p - endp);"], "readability/braces"]
["src/nvim/spell.c", ["        skip = (int)(p - endp);", "      else", "        skip = 0;"], "readability/braces"]
["src/nvim/spell.c", ["      // Capcol skips over the inserted space.", "      --capcol;", ""], "readability/increment"]
["src/nvim/spell.c", ["      // But after empty line check first word in next line", "      if (*skipwhite(line) == NUL)", "        capcol = 0;"], "readability/braces"]
["src/nvim/spell.c", ["  p = skipwhite(line);", "  while (vim_strchr((char_u *)\"*#/\\\"\\t\", *p) != NULL)", "    p = skipwhite(p + 1);"], "readability/braces"]
["src/nvim/spell.c", ["  // autocommand may load it then.", "  for (round = 1; round <= 2; ++round) {", "    // Find the first spell file for \"lang\" in 'runtimepath' and load it."], "readability/increment"]
["src/nvim/spell.c", ["", "      if (r == FAIL && *sl.sl_lang != NUL && round == 1", "          && apply_autocmds(EVENT_SPELLFILEMISSING, lang,"], "readability/braces"]
["src/nvim/spell.c", ["          && apply_autocmds(EVENT_SPELLFILEMISSING, lang,", "              curbuf->b_fname, FALSE, curbuf))", "        continue;"], "whitespace/alignment"]
["src/nvim/spell.c", ["          && apply_autocmds(EVENT_SPELLFILEMISSING, lang,", "              curbuf->b_fname, FALSE, curbuf))", "        continue;"], "whitespace/alignment"]
["src/nvim/spell.c", ["          && apply_autocmds(EVENT_SPELLFILEMISSING, lang,", "              curbuf->b_fname, FALSE, curbuf))", "        continue;"], "readability/bool"]
["src/nvim/spell.c", ["      smsg(", "        _(\"Warning: Cannot find word list \\\"%s.%s.spl\\\" or \\\"%s.ascii.spl\\\"\"),", "        lang, spell_enc(), lang);"], "whitespace/indent"]
["src/nvim/spell.c", ["        _(\"Warning: Cannot find word list \\\"%s.%s.spl\\\" or \\\"%s.ascii.spl\\\"\"),", "        lang, spell_enc(), lang);", "    }"], "whitespace/indent"]
["src/nvim/spell.c", ["{", "", "  if (STRLEN(p_enc) < 60 && STRCMP(p_enc, \"iso-8859-15\") != 0)"], "whitespace/blank_line"]
["src/nvim/spell.c", ["", "  if (STRLEN(p_enc) < 60 && STRCMP(p_enc, \"iso-8859-15\") != 0)", "    return p_enc;"], "readability/braces"]
["src/nvim/spell.c", ["  vim_snprintf((char *)fname, MAXPATHL, SPL_FNAME_TMPL,", "      int_wordlist, spell_enc());", "}"], "whitespace/alignment"]
["src/nvim/spell.c", ["", "  if (lang != NULL)", "    lp->sl_name = vim_strsave(lang);"], "readability/braces"]
["src/nvim/spell.c", ["/// Frees a salitem_T", "static void free_salitem(salitem_T *smp) {", "  xfree(smp->sm_lead);"], "readability/braces"]
["src/nvim/spell.c", ["/// Frees a fromto_T", "static void free_fromto(fromto_T *ftp) {", "  xfree(ftp->ft_from);"], "readability/braces"]
["src/nvim/spell.c", ["", "  for (int i = 0; i < lp->sl_prefixcnt; ++i) {", "    vim_regfree(lp->sl_prefprog[i]);"], "readability/increment"]
["src/nvim/spell.c", ["    // \".add\" files.", "    if (slp->sl_nobreak && slang->sl_add)", "      slang->sl_nobreak = true;"], "readability/braces"]
["src/nvim/spell.c", ["      slang->sl_nobreak = true;", "    else if (slang->sl_nobreak)", "      slp->sl_nobreak = true;"], "readability/braces"]
["src/nvim/spell.c", ["    wc = HI2WC(hi);", "    if ((wc->wc_count += count) < (unsigned)count)      // check for overflow", "      wc->wc_count = MAXWORDCOUNT;"], "readability/braces"]
["src/nvim/spell.c", ["static int", "score_wordcount_adj (", "    slang_T *slang,"], "whitespace/parens"]
["src/nvim/spell.c", ["    wc = HI2WC(hi);", "    if (wc->wc_count < SCORE_THRES2)", "      bonus = SCORE_COMMON1;"], "readability/braces"]
["src/nvim/spell.c", ["      bonus = SCORE_COMMON1;", "    else if (wc->wc_count < SCORE_THRES3)", "      bonus = SCORE_COMMON2;"], "readability/braces"]
["src/nvim/spell.c", ["      bonus = SCORE_COMMON2;", "    else", "      bonus = SCORE_COMMON3;"], "readability/braces"]
["src/nvim/spell.c", ["      bonus = SCORE_COMMON3;", "    if (split)", "      newscore = score - bonus / 2;"], "readability/braces"]
["src/nvim/spell.c", ["      newscore = score - bonus / 2;", "    else", "      newscore = score - bonus;"], "readability/braces"]
["src/nvim/spell.c", ["      newscore = score - bonus;", "    if (newscore < 0)", "      return 0;"], "readability/braces"]
["src/nvim/spell.c", ["", "  for (p = str; *p != NUL; ++p)", "    if (*p == n)"], "readability/braces"]
["src/nvim/spell.c", ["", "  for (p = str; *p != NUL; ++p)", "    if (*p == n)"], "readability/increment"]
["src/nvim/spell.c", ["  for (p = str; *p != NUL; ++p)", "    if (*p == n)", "      return true;"], "readability/braces"]
["src/nvim/spell.c", ["    *p++ = NUL;", "    if (*p == NUL)          // trailing slash", "      break;"], "readability/braces"]
["src/nvim/spell.c", ["    p = vim_strchr(p, '/');", "    if (p == NULL)", "      l = (int)STRLEN(s);"], "readability/braces"]
["src/nvim/spell.c", ["      l = (int)STRLEN(s);", "    else", "      l = (int)(p - s);"], "readability/braces"]
["src/nvim/spell.c", ["      l = (int)(p - s);", "    if (l >= SY_MAXLEN)", "      return SP_FORMERROR;"], "readability/braces"]
["src/nvim/spell.c", ["", "  if (slang->sl_syllable == NULL)", "    return 0;"], "readability/braces"]
["src/nvim/spell.c", ["    len = 0;", "    for (int i = 0; i < slang->sl_syl_items.ga_len; ++i) {", "      syl = ((syl_item_T *)slang->sl_syl_items.ga_data) + i;"], "readability/increment"]
["src/nvim/spell.c", ["      syl = ((syl_item_T *)slang->sl_syl_items.ga_data) + i;", "      if (syl->sy_len > len", "          && STRNCMP(p, syl->sy_chars, syl->sy_len) == 0)"], "readability/braces"]
["src/nvim/spell.c", ["    if (len != 0) {     // found a match, count syllable", "      ++cnt;", "      skip = false;"], "readability/increment"]
["src/nvim/spell.c", ["      len = (*mb_ptr2len)(p);", "      if (vim_strchr(slang->sl_syllable, c) == NULL)", "        skip = false;               // No, search for next syllable"], "readability/braces"]
["src/nvim/spell.c", ["        skip = false;               // No, search for next syllable", "      else if (!skip) {", "        ++cnt;                      // Yes, count it"], "readability/braces"]
["src/nvim/spell.c", ["      else if (!skip) {", "        ++cnt;                      // Yes, count it", "        skip = true;                // don't count following syllable chars"], "readability/increment"]
["src/nvim/spell.c", ["  // in which 'spell' is set.", "  if (recursive)", "    return NULL;"], "readability/braces"]
["src/nvim/spell.c", ["        region = region_cp;", "      } else", "        dont_use_region = true;"], "readability/braces"]
["src/nvim/spell.c", ["        lang[len - 3] = NUL;", "      } else", "        dont_use_region = true;"], "readability/braces"]
["src/nvim/spell.c", ["      // Check if we loaded this language before.", "      for (slang = first_lang; slang != NULL; slang = slang->sl_next)", "        if (STRICMP(lang, slang->sl_name) == 0)"], "readability/braces"]
["src/nvim/spell.c", ["      for (slang = first_lang; slang != NULL; slang = slang->sl_next)", "        if (STRICMP(lang, slang->sl_name) == 0)", "          break;"], "readability/braces"]
["src/nvim/spell.c", ["      // use it for 'spellfile'.", "      if (use_region != NULL && STRCMP(region, use_region) != 0)", "        dont_use_region = true;"], "readability/braces"]
["src/nvim/spell.c", ["    if (slang == NULL) {", "      if (filename)", "        (void)spell_load_file(lang, lang, NULL, false);"], "readability/braces"]
["src/nvim/spell.c", ["        (void)spell_load_file(lang, lang, NULL, false);", "      else {", "        spell_load_lang(lang);"], "readability/braces"]
["src/nvim/spell.c", ["        (void)spell_load_file(lang, lang, NULL, false);", "      else {", "        spell_load_lang(lang);"], "readability/braces"]
["src/nvim/spell.c", ["            if (slang->sl_add) {", "              if (*slang->sl_regions != NUL)", "                // This addition file is for other regions."], "readability/braces"]
["src/nvim/spell.c", ["                region_mask = 0;", "            } else", "              // This is probably an error.  Give a warning and"], "readability/braces"]
["src/nvim/spell.c", ["                   region);", "          } else", "            region_mask = 1 << c;"], "readability/braces"]
["src/nvim/spell.c", ["          use_midword(slang, wp);", "          if (slang->sl_nobreak)", "            nobreak = true;"], "readability/braces"]
["src/nvim/spell.c", ["  spf = curwin->w_s->b_p_spf;", "  for (round = 0; round == 0 || *spf != NUL; ++round) {", "    if (round == 0) {"], "readability/increment"]
["src/nvim/spell.c", ["      // Internal wordlist, if there is one.", "      if (int_wordlist == NULL)", "        continue;"], "readability/braces"]
["src/nvim/spell.c", ["      // If it was already found above then skip it.", "      for (c = 0; c < ga.ga_len; ++c) {", "        p = LANGP_ENTRY(ga, c)->lp_slang->sl_fname;"], "readability/increment"]
["src/nvim/spell.c", ["      }", "      if (c < ga.ga_len)", "        continue;"], "readability/braces"]
["src/nvim/spell.c", ["      // use an arbitrary name.", "      if (round == 0)", "        STRCPY(lang, \"internal wordlist\");"], "readability/braces"]
["src/nvim/spell.c", ["        STRCPY(lang, \"internal wordlist\");", "      else {", "        STRLCPY(lang, path_tail(spf_name), MAXWLEN + 1);"], "readability/braces"]
["src/nvim/spell.c", ["        STRCPY(lang, \"internal wordlist\");", "      else {", "        STRLCPY(lang, path_tail(spf_name), MAXWLEN + 1);"], "readability/braces"]
["src/nvim/spell.c", ["        p = vim_strchr(lang, '.');", "        if (p != NULL)", "          *p = NUL;             // truncate at \".encoding.add\""], "readability/braces"]
["src/nvim/spell.c", ["      // files also have this.", "      if (slang != NULL && nobreak)", "        slang->sl_nobreak = true;"], "readability/braces"]
["src/nvim/spell.c", ["        c = find_region(slang->sl_regions, use_region);", "        if (c != REGION_ALL)", "          region_mask = 1 << c;"], "readability/braces"]
["src/nvim/spell.c", ["          region_mask = 1 << c;", "        else if (*slang->sl_regions != NUL)", "          // This spell file is for other regions."], "readability/braces"]
["src/nvim/spell.c", ["  // with the same name.  E.g. for \"en-math\" use \"en\".", "  for (int i = 0; i < ga.ga_len; ++i) {", "    lp = LANGP_ENTRY(ga, i);"], "readability/increment"]
["src/nvim/spell.c", ["    // sound folding", "    if (!GA_EMPTY(&lp->lp_slang->sl_sal))", "      // language does sound folding itself"], "readability/braces"]
["src/nvim/spell.c", ["      lp->lp_sallang = lp->lp_slang;", "    else", "      // find first similar language that does sound folding"], "readability/braces"]
["src/nvim/spell.c", ["      // find first similar language that does sound folding", "      for (int j = 0; j < ga.ga_len; ++j) {", "        lp2 = LANGP_ENTRY(ga, j);"], "readability/increment"]
["src/nvim/spell.c", ["            && STRNCMP(lp->lp_slang->sl_name,", "                lp2->lp_slang->sl_name, 2) == 0) {", "          lp->lp_sallang = lp2->lp_slang;"], "whitespace/alignment"]
["src/nvim/spell.c", ["            && STRNCMP(lp->lp_slang->sl_name,", "                lp2->lp_slang->sl_name, 2) == 0) {", "          lp->lp_sallang = lp2->lp_slang;"], "whitespace/alignment"]
["src/nvim/spell.c", ["    // REP items", "    if (!GA_EMPTY(&lp->lp_slang->sl_rep))", "      // language has REP items itself"], "readability/braces"]
["src/nvim/spell.c", ["      lp->lp_replang = lp->lp_slang;", "    else", "      // find first similar language that has REP items"], "readability/braces"]
["src/nvim/spell.c", ["      // find first similar language that has REP items", "      for (int j = 0; j < ga.ga_len; ++j) {", "        lp2 = LANGP_ENTRY(ga, j);"], "readability/increment"]
["src/nvim/spell.c", ["            && STRNCMP(lp->lp_slang->sl_name,", "                lp2->lp_slang->sl_name, 2) == 0) {", "          lp->lp_replang = lp2->lp_slang;"], "whitespace/alignment"]
["src/nvim/spell.c", ["            && STRNCMP(lp->lp_slang->sl_name,", "                lp2->lp_slang->sl_name, 2) == 0) {", "          lp->lp_replang = lp2->lp_slang;"], "whitespace/alignment"]
["src/nvim/spell.c", ["  for (i = 0;; i += 2) {", "    if (rp[i] == NUL)", "      return REGION_ALL;"], "readability/braces"]
["src/nvim/spell.c", ["      return REGION_ALL;", "    if (rp[i] == region[0] && rp[i + 1] == region[1])", "      break;"], "readability/braces"]
["src/nvim/spell.c", ["", "  if (allcap)", "    return WF_ALLCAP;"], "readability/braces"]
["src/nvim/spell.c", ["    return WF_ALLCAP;", "  if (firstcap)", "    return WF_ONECAP;"], "readability/braces"]
["src/nvim/spell.c", ["      if (SPELL_ISUPPER(c)) {", "        ++u;", "        if (p == word)"], "readability/increment"]
["src/nvim/spell.c", ["        ++u;", "        if (p == word)", "          first = true;"], "readability/braces"]
["src/nvim/spell.c", ["          first = true;", "      } else", "        ++l;"], "readability/braces"]
["src/nvim/spell.c", ["      } else", "        ++l;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["    // require three upper case letters.", "    if (u > l && u > 2)", "      flags |= WF_ALLCAP;"], "readability/braces"]
["src/nvim/spell.c", ["      flags |= WF_ALLCAP;", "    else if (first)", "      flags |= WF_ONECAP;"], "readability/braces"]
["src/nvim/spell.c", ["", "    if (u >= 2 && l >= 2)       // maCARONI maCAroni", "      flags |= WF_MIXCAP;"], "readability/braces"]
["src/nvim/spell.c", ["{", "  char_u fname[MAXPATHL] = {0};", ""], "whitespace/braces"]
["src/nvim/spell.c", ["{", "  char_u fname[MAXPATHL] = {0};", ""], "whitespace/braces"]
["src/nvim/spell.c", ["  if (buf != NULL) {", "    ml_close(buf, TRUE);", "    xfree(buf);"], "readability/bool"]
["src/nvim/spell.c", ["", "  for (i = 0; i < 256; ++i) {", "    sp->st_fold[i] = i;"], "readability/increment"]
["src/nvim/spell.c", ["  // that is done separately.", "  for (i = '0'; i <= '9'; ++i)", "    sp->st_isw[i] = true;"], "readability/braces"]
["src/nvim/spell.c", ["  // that is done separately.", "  for (i = '0'; i <= '9'; ++i)", "    sp->st_isw[i] = true;"], "readability/increment"]
["src/nvim/spell.c", ["    sp->st_isw[i] = true;", "  for (i = 'A'; i <= 'Z'; ++i) {", "    sp->st_isw[i] = true;"], "readability/increment"]
["src/nvim/spell.c", ["  }", "  for (i = 'a'; i <= 'z'; ++i) {", "    sp->st_isw[i] = true;"], "readability/increment"]
["src/nvim/spell.c", ["{", "  if (wp->w_s->b_cjk)", "    // East Asian characters are not considered word characters."], "readability/braces"]
["src/nvim/spell.c", ["", "  if (*p < 256 ? wp->w_s->b_spell_ismw[*p]", "      : (wp->w_s->b_spell_ismw_mb != NULL"], "readability/braces"]
["src/nvim/spell.c", ["    s = p + 1;", "  else", "    s = p;"], "readability/braces"]
["src/nvim/spell.c", ["    }", "    if (f != 0)", "      sps_flags = f;"], "readability/braces"]
["src/nvim/spell.c", ["", "  if (sps_flags == 0)", "    sps_flags = SPS_BEST;"], "readability/braces"]
["src/nvim/spell.c", ["", "  if (no_spell_checking(curwin))", "    return;"], "readability/braces"]
["src/nvim/spell.c", ["    end_visual_mode();", "  } else", "  // Find the start of the badly spelled word."], "readability/braces"]
["src/nvim/spell.c", ["  // 'spellsuggest', whatever is smaller.", "  if (sps_limit > (int)Rows - 2)", "    limit = (int)Rows - 2;"], "readability/braces"]
["src/nvim/spell.c", ["    limit = (int)Rows - 2;", "  else", "    limit = sps_limit;"], "readability/braces"]
["src/nvim/spell.c", ["  spell_find_suggest(line + curwin->w_cursor.col, badlen, &sug, limit,", "      true, need_cap, true);", ""], "whitespace/alignment"]
["src/nvim/spell.c", ["", "  if (GA_EMPTY(&sug.su_ga))", "    MSG(_(\"Sorry, no suggestions\"));"], "readability/braces"]
["src/nvim/spell.c", ["    MSG(_(\"Sorry, no suggestions\"));", "  else if (count > 0) {", "    if (count > sug.su_ga.ga_len)"], "readability/braces"]
["src/nvim/spell.c", ["  else if (count > 0) {", "    if (count > sug.su_ga.ga_len)", "      smsg(_(\"Sorry, only %\" PRId64 \" suggestions\"),"], "readability/braces"]
["src/nvim/spell.c", ["    cmdmsg_rl = curwin->w_p_rl;", "    if (cmdmsg_rl)", "      msg_col = Columns - 1;"], "readability/braces"]
["src/nvim/spell.c", ["    vim_snprintf((char *)IObuff, IOSIZE, _(\"Change \\\"%.*s\\\" to:\"),", "        sug.su_badlen, sug.su_badptr);", "    if (cmdmsg_rl && STRNCMP(IObuff, \"Change\", 6) == 0) {"], "whitespace/alignment"]
["src/nvim/spell.c", ["      vim_snprintf((char *)IObuff, IOSIZE, \":ot \\\"%.*s\\\" egnahC\",", "          sug.su_badlen, sug.su_badptr);", "    }"], "whitespace/alignment"]
["src/nvim/spell.c", ["", "    msg_scroll = TRUE;", "    for (int i = 0; i < sug.su_ga.ga_len; ++i) {"], "readability/bool"]
["src/nvim/spell.c", ["    msg_scroll = TRUE;", "    for (int i = 0; i < sug.su_ga.ga_len; ++i) {", "      stp = &SUG(sug.su_ga, i);"], "readability/increment"]
["src/nvim/spell.c", ["      STRLCPY(wcopy, stp->st_word, MAXWLEN + 1);", "      if (sug.su_badlen > stp->st_orglen)", "        STRLCPY(wcopy + stp->st_wordlen,"], "readability/braces"]
["src/nvim/spell.c", ["        STRLCPY(wcopy + stp->st_wordlen,", "            sug.su_badptr + stp->st_orglen,", "            sug.su_badlen - stp->st_orglen + 1);"], "whitespace/alignment"]
["src/nvim/spell.c", ["            sug.su_badptr + stp->st_orglen,", "            sug.su_badlen - stp->st_orglen + 1);", "      vim_snprintf((char *)IObuff, IOSIZE, \"%2d\", i + 1);"], "whitespace/alignment"]
["src/nvim/spell.c", ["        // Add the score.", "        if (sps_flags & (SPS_DOUBLE | SPS_BEST))", "          vim_snprintf((char *)IObuff, IOSIZE, \" (%s%d - %d)\","], "readability/braces"]
["src/nvim/spell.c", ["          vim_snprintf((char *)IObuff, IOSIZE, \" (%s%d - %d)\",", "              stp->st_salscore ? \"s \" : \"\",", "              stp->st_score, stp->st_altscore);"], "whitespace/alignment"]
["src/nvim/spell.c", ["              stp->st_salscore ? \"s \" : \"\",", "              stp->st_score, stp->st_altscore);", "        else"], "whitespace/alignment"]
["src/nvim/spell.c", ["              stp->st_score, stp->st_altscore);", "        else", "          vim_snprintf((char *)IObuff, IOSIZE, \" (%d)\","], "readability/braces"]
["src/nvim/spell.c", ["          vim_snprintf((char *)IObuff, IOSIZE, \" (%d)\",", "              stp->st_score);", "        if (cmdmsg_rl)"], "whitespace/alignment"]
["src/nvim/spell.c", ["              stp->st_score);", "        if (cmdmsg_rl)", "          // Mirror the numbers, but keep the leading space."], "readability/braces"]
["src/nvim/spell.c", ["", "    cmdmsg_rl = FALSE;", "    msg_col = 0;"], "readability/bool"]
["src/nvim/spell.c", ["      vim_snprintf((char *)IObuff, IOSIZE, \"%s%.*s\", stp->st_word,", "          sug.su_badlen - stp->st_orglen,", "          sug.su_badptr + stp->st_orglen);"], "whitespace/alignment"]
["src/nvim/spell.c", ["          sug.su_badlen - stp->st_orglen,", "          sug.su_badptr + stp->st_orglen);", "      repl_to = vim_strsave(IObuff);"], "whitespace/alignment"]
["src/nvim/spell.c", ["    AppendToRedobuffLit(p + c,", "        stp->st_wordlen + sug.su_badlen - stp->st_orglen);", "    AppendCharToRedobuff(ESC);"], "whitespace/alignment"]
["src/nvim/spell.c", ["    changed_bytes(curwin->w_cursor.lnum, c);", "  } else", "    curwin->w_cursor = prev_cursor;"], "readability/braces"]
["src/nvim/spell.c", ["", "  if (curwin->w_s->b_cap_prog == NULL)", "    return false;"], "readability/braces"]
["src/nvim/spell.c", ["    // ends there.", "    if (lnum == 1)", "      need_cap = true;"], "readability/braces"]
["src/nvim/spell.c", ["      need_cap = true;", "    else {", "      line = ml_get(lnum - 1);"], "readability/braces"]
["src/nvim/spell.c", ["      need_cap = true;", "    else {", "      line = ml_get(lnum - 1);"], "readability/braces"]
["src/nvim/spell.c", ["      line = ml_get(lnum - 1);", "      if (*skipwhite(line) == NUL)", "        need_cap = true;"], "readability/braces"]
["src/nvim/spell.c", ["        need_cap = true;", "      else {", "        // Append a space in place of the line break."], "readability/braces"]
["src/nvim/spell.c", ["        need_cap = true;", "      else {", "        // Append a space in place of the line break."], "readability/braces"]
["src/nvim/spell.c", ["    regmatch.regprog = curwin->w_s->b_cap_prog;", "    regmatch.rm_ic = FALSE;", "    p = line + endcol;"], "readability/bool"]
["src/nvim/spell.c", ["  frompat = xmalloc(STRLEN(repl_from) + 7);", "  sprintf((char *)frompat, \"\\\\V\\\\<%s\\\\>\", repl_from);", "  p_ws = false;"], "runtime/printf"]
["src/nvim/spell.c", ["    if (addlen <= 0 || STRNCMP(line + curwin->w_cursor.col,", "            repl_to, STRLEN(repl_to)) != 0) {", "      p = xmalloc(STRLEN(line) + addlen + 1);"], "whitespace/alignment"]
["src/nvim/spell.c", ["      if (curwin->w_cursor.lnum != prev_lnum) {", "        ++sub_nlines;", "        prev_lnum = curwin->w_cursor.lnum;"], "readability/increment"]
["src/nvim/spell.c", ["      }", "      ++sub_nsubs;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["", "  if (sub_nsubs == 0)", "    EMSG2(_(\"E753: Not found: %s\"), repl_from);"], "readability/braces"]
["src/nvim/spell.c", ["    EMSG2(_(\"E753: Not found: %s\"), repl_from);", "  else", "    do_sub_msg(false);"], "readability/braces"]
["src/nvim/spell.c", ["void", "spell_suggest_list (", "    garray_T *gap,"], "whitespace/parens"]
["src/nvim/spell.c", ["  ga_grow(gap, sug.su_ga.ga_len);", "  for (int i = 0; i < sug.su_ga.ga_len; ++i) {", "    stp = &SUG(sug.su_ga, i);"], "readability/increment"]
["src/nvim/spell.c", ["static void", "spell_find_suggest (", "    char_u *badptr,"], "whitespace/parens"]
["src/nvim/spell.c", ["  ga_init(&su->su_sga, (int)sizeof(suggest_T), 10);", "  if (*badptr == NUL)", "    return;"], "readability/braces"]
["src/nvim/spell.c", ["  su->su_badptr = badptr;", "  if (badlen != 0)", "    su->su_badlen = badlen;"], "readability/braces"]
["src/nvim/spell.c", ["    su->su_badlen = badlen;", "  else {", "    size_t tmplen = spell_check(curwin, su->su_badptr, &attr, NULL, false);"], "readability/braces"]
["src/nvim/spell.c", ["    su->su_badlen = badlen;", "  else {", "    size_t tmplen = spell_check(curwin, su->su_badptr, &attr, NULL, false);"], "readability/braces"]
["src/nvim/spell.c", ["", "  if (su->su_badlen >= MAXWLEN)", "    su->su_badlen = MAXWLEN - 1;        // just in case"], "readability/braces"]
["src/nvim/spell.c", ["  su->su_badflags = badword_captype(su->su_badptr,", "      su->su_badptr + su->su_badlen);", "  if (need_cap)"], "whitespace/alignment"]
["src/nvim/spell.c", ["      su->su_badptr + su->su_badlen);", "  if (need_cap)", "    su->su_badflags |= WF_ONECAP;"], "readability/braces"]
["src/nvim/spell.c", ["  // languages (e.g., \"pl,en\").", "  for (int i = 0; i < curbuf->b_s.b_langp.ga_len; ++i) {", "    lp = LANGP_ENTRY(curbuf->b_s.b_langp, i);"], "readability/increment"]
["src/nvim/spell.c", ["  // have to do this many times.", "  if (su->su_sallang != NULL)", "    spell_soundfold(su->su_sallang, su->su_fbadword, true,"], "readability/braces"]
["src/nvim/spell.c", ["    spell_soundfold(su->su_sallang, su->su_fbadword, true,", "        su->su_sal_badword);", ""], "whitespace/alignment"]
["src/nvim/spell.c", ["    add_suggestion(su, &su->su_ga, buf, su->su_badlen, SCORE_ICASE,", "        0, true, su->su_sallang, false);", "  }"], "whitespace/alignment"]
["src/nvim/spell.c", ["  // Ban the bad word itself.  It may appear in another region.", "  if (banbadword)", "    add_banned(su, su->su_badword);"], "readability/braces"]
["src/nvim/spell.c", ["", "  if (do_combine)", "    // Combine the two list of suggestions.  This must be done last,"], "readability/braces"]
["src/nvim/spell.c", ["    p = vim_strchr(line, '/');", "    if (p == NULL)", "      continue;             // No Tab found, just skip the line."], "readability/braces"]
["src/nvim/spell.c", ["      // Match!  Isolate the good word, until CR or NL.", "      for (len = 0; p[len] >= ' '; ++len)", "        ;"], "readability/braces"]
["src/nvim/spell.c", ["      // Match!  Isolate the good word, until CR or NL.", "      for (len = 0; p[len] >= ' '; ++len)", "        ;"], "readability/increment"]
["src/nvim/spell.c", ["      for (len = 0; p[len] >= ' '; ++len)", "        ;", "      p[len] = NUL;"], "whitespace/semicolon"]
["src/nvim/spell.c", ["      add_suggestion(su, &su->su_ga, p, su->su_badlen,", "          SCORE_FILE, 0, true, su->su_sallang, false);", "    }"], "whitespace/alignment"]
["src/nvim/spell.c", ["  // For the resulting top-scorers compute the sound-a-like score.", "  if (sps_flags & SPS_DOUBLE)", "    score_comp_sal(su);"], "readability/braces"]
["src/nvim/spell.c", ["  if ((sps_flags & SPS_FAST) == 0) {", "    if (sps_flags & SPS_BEST)", "      // Adjust the word score for the suggestions found so far for how"], "readability/braces"]
["src/nvim/spell.c", ["    (void)vgetc();", "    got_int = FALSE;", "  }"], "readability/bool"]
["src/nvim/spell.c", ["  if ((sps_flags & SPS_DOUBLE) == 0 && su->su_ga.ga_len != 0) {", "    if (sps_flags & SPS_BEST)", "      // Adjust the word score for how it sounds like."], "readability/braces"]
["src/nvim/spell.c", ["      c = 'S';", "      if (d - wcopy >= MAXWLEN - 1)", "        break;"], "readability/braces"]
["src/nvim/spell.c", ["      *d++ = c;", "    } else", "      c = SPELL_TOUPPER(c);"], "readability/braces"]
["src/nvim/spell.c", ["    add_suggestion(su, &su->su_ga, word, su->su_badlen,", "        RESCORE(SCORE_REP, 0), 0, true, su->su_sallang, false);", "  }"], "whitespace/alignment"]
["src/nvim/spell.c", ["", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["    // everything has been cleared.", "    if (lp->lp_slang->sl_fbyts == NULL)", "      continue;"], "readability/braces"]
["src/nvim/spell.c", ["//      use \"slang->sl_repsal\" instead of \"lp->lp_replang->sl_rep\"", "static void suggest_trie_walk(suginfo_T *su, langp_T *lp, char_u *fword, bool soundfold)", "{"], "whitespace/line_length"]
["src/nvim/spell.c", ["        // Skip over the NUL bytes, we use them later.", "        for (n = 0; n < len && byts[arridx + n] == 0; ++n)", "          ;"], "readability/braces"]
["src/nvim/spell.c", ["        // Skip over the NUL bytes, we use them later.", "        for (n = 0; n < len && byts[arridx + n] == 0; ++n)", "          ;"], "readability/increment"]
["src/nvim/spell.c", ["        for (n = 0; n < len && byts[arridx + n] == 0; ++n)", "          ;", "        sp->ts_curi += n;"], "whitespace/semicolon"]
["src/nvim/spell.c", ["          su->su_badflags = badword_captype(su->su_badptr + n,", "              su->su_badptr + su->su_badlen);", "#ifdef DEBUG_TRIEWALK"], "whitespace/alignment"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "          sprintf(changename[depth], \"prefix\");", "#endif"], "runtime/printf"]
["src/nvim/spell.c", ["          go_deeper(stack, depth, 0);", "          ++depth;", "          sp = &stack[depth];"], "readability/increment"]
["src/nvim/spell.c", ["          make_case_word(tword + sp->ts_splitoff,", "              preword + sp->ts_prewordlen, flags);", "          sp->ts_prewordlen = (char_u)STRLEN(preword);"], "whitespace/alignment"]
["src/nvim/spell.c", ["      // End of word in tree.", "      ++sp->ts_curi;                    // eat one NUL byte", ""], "readability/increment"]
["src/nvim/spell.c", ["      // Skip words with the NOSUGGEST flag.", "      if (flags & WF_NOSUGGEST)", "        break;"], "readability/braces"]
["src/nvim/spell.c", ["        len = pbyts[n++];", "        for (c = 0; c < len && pbyts[n + c] == 0; ++c)", "          ;"], "readability/braces"]
["src/nvim/spell.c", ["        len = pbyts[n++];", "        for (c = 0; c < len && pbyts[n + c] == 0; ++c)", "          ;"], "readability/increment"]
["src/nvim/spell.c", ["        for (c = 0; c < len && pbyts[n + c] == 0; ++c)", "          ;", "        if (c > 0) {"], "whitespace/semicolon"]
["src/nvim/spell.c", ["          c = valid_word_prefix(c, n, flags,", "              tword + sp->ts_splitoff, slang, false);", "          if (c == 0)"], "whitespace/alignment"]
["src/nvim/spell.c", ["              tword + sp->ts_splitoff, slang, false);", "          if (c == 0)", "            break;"], "readability/braces"]
["src/nvim/spell.c", ["          // Use the WF_RARE flag for a rare prefix.", "          if (c & WF_RAREPFX)", "            flags |= WF_RARE;"], "readability/braces"]
["src/nvim/spell.c", ["      // appending another compound word below.", "      if (sp->ts_complen == sp->ts_compsplit && fword_ends", "          && (flags & WF_NEEDCOMP))"], "readability/braces"]
["src/nvim/spell.c", ["        goodword_ends = false;", "      else", "        goodword_ends = true;"], "readability/braces"]
["src/nvim/spell.c", ["              && STRNCMP(fword + sp->ts_splitfidx,", "                  tword + sp->ts_splitoff,", "                  sp->ts_fidx - sp->ts_splitfidx) == 0) {"], "whitespace/alignment"]
["src/nvim/spell.c", ["                  tword + sp->ts_splitoff,", "                  sp->ts_fidx - sp->ts_splitfidx) == 0) {", "            preword[sp->ts_prewordlen] = NUL;"], "whitespace/alignment"]
["src/nvim/spell.c", ["              && STRNCMP(fword + sp->ts_splitfidx,", "                  tword + sp->ts_splitoff,", "                  sp->ts_fidx - sp->ts_splitfidx) == 0) {"], "whitespace/alignment"]
["src/nvim/spell.c", ["                  tword + sp->ts_splitoff,", "                  sp->ts_fidx - sp->ts_splitfidx) == 0) {", "            preword[sp->ts_prewordlen] = NUL;"], "whitespace/alignment"]
["src/nvim/spell.c", ["            newscore = score_wordcount_adj(slang, sp->ts_score,", "                preword + sp->ts_prewordlen,", "                sp->ts_prewordlen > 0);"], "whitespace/alignment"]
["src/nvim/spell.c", ["                preword + sp->ts_prewordlen,", "                sp->ts_prewordlen > 0);", "            // Add the suggestion if the score isn't too bad."], "whitespace/alignment"]
["src/nvim/spell.c", ["            // Add the suggestion if the score isn't too bad.", "            if (newscore <= su->su_maxscore)", "              add_suggestion(su, &su->su_ga, preword,"], "readability/braces"]
["src/nvim/spell.c", ["              add_suggestion(su, &su->su_ga, preword,", "                  sp->ts_splitfidx - repextra,", "                  newscore, 0, false,"], "whitespace/alignment"]
["src/nvim/spell.c", ["                  sp->ts_splitfidx - repextra,", "                  newscore, 0, false,", "                  lp->lp_sallang, false);"], "whitespace/alignment"]
["src/nvim/spell.c", ["                  newscore, 0, false,", "                  lp->lp_sallang, false);", "            break;"], "whitespace/alignment"]
["src/nvim/spell.c", ["          STRLCPY(preword + sp->ts_prewordlen,", "              tword + sp->ts_splitoff,", "              sp->ts_twordlen - sp->ts_splitoff + 1);"], "whitespace/alignment"]
["src/nvim/spell.c", ["              tword + sp->ts_splitoff,", "              sp->ts_twordlen - sp->ts_splitoff + 1);", ""], "whitespace/alignment"]
["src/nvim/spell.c", ["          // Verify CHECKCOMPOUNDPATTERN  rules.", "          if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,", "                  &slang->sl_comppat))"], "readability/braces"]
["src/nvim/spell.c", ["          if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,", "                  &slang->sl_comppat))", "            compound_ok = false;"], "whitespace/alignment"]
["src/nvim/spell.c", ["            p = preword;", "            while (*skiptowhite(p) != NUL)", "              p = skipwhite(skiptowhite(p));"], "readability/braces"]
["src/nvim/spell.c", ["              p = skipwhite(skiptowhite(p));", "            if (fword_ends && !can_compound(slang, p,", "                    compflags + sp->ts_compsplit))"], "readability/braces"]
["src/nvim/spell.c", ["            if (fword_ends && !can_compound(slang, p,", "                    compflags + sp->ts_compsplit))", "              // Compound is not allowed.  But it may still be"], "whitespace/alignment"]
["src/nvim/spell.c", ["      // For the soundfold tree don't change the case, simply append.", "      if (soundfold)", "        STRCPY(preword + sp->ts_prewordlen, tword + sp->ts_splitoff);"], "readability/braces"]
["src/nvim/spell.c", ["        STRCPY(preword + sp->ts_prewordlen, tword + sp->ts_splitoff);", "      else if (flags & WF_KEEPCAP)", "        // Must find the word in the keep-case tree."], "readability/braces"]
["src/nvim/spell.c", ["        find_keepcap_word(slang, tword + sp->ts_splitoff,", "            preword + sp->ts_prewordlen);", "      else {"], "whitespace/alignment"]
["src/nvim/spell.c", ["            preword + sp->ts_prewordlen);", "      else {", "        // Include badflags: If the badword is onecap or allcap"], "readability/braces"]
["src/nvim/spell.c", ["            preword + sp->ts_prewordlen);", "      else {", "        // Include badflags: If the badword is onecap or allcap"], "readability/braces"]
["src/nvim/spell.c", ["        c = su->su_badflags;", "        if ((c & WF_ALLCAP)", "            && su->su_badlen == (*mb_ptr2len)(su->su_badptr)"], "readability/braces"]
["src/nvim/spell.c", ["        // use Onecap.", "        if (p != NULL && spell_iswordp_nmw(p, curwin))", "          c &= ~WF_ONECAP;"], "readability/braces"]
["src/nvim/spell.c", ["        make_case_word(tword + sp->ts_splitoff,", "            preword + sp->ts_prewordlen, c);", "      }"], "whitespace/alignment"]
["src/nvim/spell.c", ["            || WAS_BANNED(su, preword)) {", "          if (slang->sl_compprog == NULL)", "            break;"], "readability/braces"]
["src/nvim/spell.c", ["      if (!soundfold) {         // soundfold words don't have flags", "        if ((flags & WF_REGION)", "            && (((unsigned)flags >> 16) & lp->lp_region) == 0)"], "readability/braces"]
["src/nvim/spell.c", ["          newscore += SCORE_REGION;", "        if (flags & WF_RARE)", "          newscore += SCORE_RARE;"], "readability/braces"]
["src/nvim/spell.c", ["", "        if (!spell_valid_case(su->su_badflags,", "                captype(preword + sp->ts_prewordlen, NULL)))"], "readability/braces"]
["src/nvim/spell.c", ["        if (!spell_valid_case(su->su_badflags,", "                captype(preword + sp->ts_prewordlen, NULL)))", "          newscore += SCORE_ICASE;"], "whitespace/alignment"]
["src/nvim/spell.c", ["", "      // TODO: how about splitting in the soundfold tree?", "      if (fword_ends"], "readability/todo"]
["src/nvim/spell.c", ["          smsg(\"------ %s -------\", fword);", "          for (j = 0; j < depth; ++j)", "            smsg(\"%s\", changename[j]);"], "readability/braces"]
["src/nvim/spell.c", ["          smsg(\"------ %s -------\", fword);", "          for (j = 0; j < depth; ++j)", "            smsg(\"%s\", changename[j]);"], "readability/increment"]
["src/nvim/spell.c", ["          score = score_wordcount_adj(slang,", "              sp->ts_score + newscore,", "              preword + sp->ts_prewordlen,"], "whitespace/alignment"]
["src/nvim/spell.c", ["              sp->ts_score + newscore,", "              preword + sp->ts_prewordlen,", "              sp->ts_prewordlen > 0);"], "whitespace/alignment"]
["src/nvim/spell.c", ["              preword + sp->ts_prewordlen,", "              sp->ts_prewordlen > 0);", ""], "whitespace/alignment"]
["src/nvim/spell.c", ["            add_suggestion(su, &su->su_ga, preword,", "                sp->ts_fidx - repextra,", "                score, 0, false, lp->lp_sallang, false);"], "whitespace/alignment"]
["src/nvim/spell.c", ["                sp->ts_fidx - repextra,", "                score, 0, false, lp->lp_sallang, false);", ""], "whitespace/alignment"]
["src/nvim/spell.c", ["                make_case_word(tword + sp->ts_splitoff,", "                    preword + sp->ts_prewordlen,", "                    c == 0 ? WF_ALLCAP : 0);"], "whitespace/alignment"]
["src/nvim/spell.c", ["                    preword + sp->ts_prewordlen,", "                    c == 0 ? WF_ALLCAP : 0);", ""], "whitespace/alignment"]
["src/nvim/spell.c", ["                add_suggestion(su, &su->su_ga, preword,", "                    sp->ts_fidx - repextra,", "                    score + SCORE_ICASE, 0, false,"], "whitespace/alignment"]
["src/nvim/spell.c", ["                    sp->ts_fidx - repextra,", "                    score + SCORE_ICASE, 0, false,", "                    lp->lp_sallang, false);"], "whitespace/alignment"]
["src/nvim/spell.c", ["                    score + SCORE_ICASE, 0, false,", "                    lp->lp_sallang, false);", "              }"], "whitespace/alignment"]
["src/nvim/spell.c", ["        // different.  It's done like a split.", "        // TODO: word split for soundfold words", "        try_split = (sp->ts_fidx - repextra < su->su_badlen)"], "readability/todo"]
["src/nvim/spell.c", ["            && (can_be_compound(sp, slang,", "                    compflags, ((unsigned)flags >> 24)))) {", "          try_compound = true;"], "whitespace/alignment"]
["src/nvim/spell.c", ["            && (can_be_compound(sp, slang,", "                    compflags, ((unsigned)flags >> 24)))) {", "          try_compound = true;"], "whitespace/alignment"]
["src/nvim/spell.c", ["          sp->ts_flags |= TSF_DIDSPLIT;", "          --sp->ts_curi;                    // do the same NUL again", "          compflags[sp->ts_complen] = NUL;"], "readability/increment"]
["src/nvim/spell.c", ["            // flag.", "            if (sp->ts_complen == sp->ts_compsplit", "                && (flags & WF_NEEDCOMP))"], "readability/braces"]
["src/nvim/spell.c", ["            p = preword;", "            while (*skiptowhite(p) != NUL)", "              p = skipwhite(skiptowhite(p));"], "readability/braces"]
["src/nvim/spell.c", ["              p = skipwhite(skiptowhite(p));", "            if (sp->ts_complen > sp->ts_compsplit", "                && !can_compound(slang, p,"], "readability/braces"]
["src/nvim/spell.c", ["                && !can_compound(slang, p,", "                    compflags + sp->ts_compsplit))", "              break;"], "whitespace/alignment"]
["src/nvim/spell.c", ["                && !can_compound(slang, p,", "                    compflags + sp->ts_compsplit))", "              break;"], "whitespace/alignment"]
["src/nvim/spell.c", ["", "            if (slang->sl_nosplitsugs)", "              newscore += SCORE_SPLIT_NO;"], "readability/braces"]
["src/nvim/spell.c", ["              newscore += SCORE_SPLIT_NO;", "            else", "              newscore += SCORE_SPLIT;"], "readability/braces"]
["src/nvim/spell.c", ["            newscore = score_wordcount_adj(slang, newscore,", "                preword + sp->ts_prewordlen, true);", "          }"], "whitespace/alignment"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "            if (!try_compound && !fword_ends)", "              sprintf(changename[depth], \"%.*s-%s: split\","], "readability/braces"]
["src/nvim/spell.c", ["              sprintf(changename[depth], \"%.*s-%s: split\",", "                  sp->ts_twordlen, tword, fword + sp->ts_fidx);", "            else"], "whitespace/alignment"]
["src/nvim/spell.c", ["            if (!try_compound && !fword_ends)", "              sprintf(changename[depth], \"%.*s-%s: split\",", "                  sp->ts_twordlen, tword, fword + sp->ts_fidx);"], "runtime/printf"]
["src/nvim/spell.c", ["                  sp->ts_twordlen, tword, fword + sp->ts_fidx);", "            else", "              sprintf(changename[depth], \"%.*s-%s: compound\","], "readability/braces"]
["src/nvim/spell.c", ["              sprintf(changename[depth], \"%.*s-%s: compound\",", "                  sp->ts_twordlen, tword, fword + sp->ts_fidx);", "#endif"], "whitespace/alignment"]
["src/nvim/spell.c", ["            else", "              sprintf(changename[depth], \"%.*s-%s: compound\",", "                  sp->ts_twordlen, tword, fword + sp->ts_fidx);"], "runtime/printf"]
["src/nvim/spell.c", ["", "            ++depth;", "            sp = &stack[depth];"], "readability/increment"]
["src/nvim/spell.c", ["            // Append a space to preword when splitting.", "            if (!try_compound && !fword_ends)", "              STRCAT(preword, \" \");"], "readability/braces"]
["src/nvim/spell.c", ["            if (((!try_compound && !spell_iswordp_nmw(fword", "                      + sp->ts_fidx,", "                      curwin))"], "whitespace/alignment"]
["src/nvim/spell.c", ["                      + sp->ts_fidx,", "                      curwin))", "                 || fword_ends)"], "whitespace/alignment"]
["src/nvim/spell.c", ["                memmove(preword + sp->ts_prewordlen,", "                    fword + sp->ts_fidx, l);", "                sp->ts_prewordlen += l;"], "whitespace/alignment"]
["src/nvim/spell.c", ["                preword[sp->ts_prewordlen] = NUL;", "              } else", "                sp->ts_score -= SCORE_SPLIT - SCORE_SUBST;"], "readability/braces"]
["src/nvim/spell.c", ["            // may start compounding over again.", "            if (try_compound)", "              ++sp->ts_complen;"], "readability/braces"]
["src/nvim/spell.c", ["            if (try_compound)", "              ++sp->ts_complen;", "            else"], "readability/increment"]
["src/nvim/spell.c", ["              ++sp->ts_complen;", "            else", "              sp->ts_compsplit = sp->ts_complen;"], "readability/braces"]
["src/nvim/spell.c", ["            su->su_badflags = badword_captype(su->su_badptr + n,", "                su->su_badptr + su->su_badlen);", ""], "whitespace/alignment"]
["src/nvim/spell.c", ["        // delete + substitute.", "        if (c == fword[sp->ts_fidx]", "            || (sp->ts_tcharlen > 0 && sp->ts_isdiff != DIFF_NONE)"], "readability/braces"]
["src/nvim/spell.c", ["          newscore = 0;", "        else", "          newscore = SCORE_SUBST;"], "readability/braces"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "          if (newscore > 0)", "            sprintf(changename[depth], \"%.*s-%s: subst %c to %c\","], "readability/braces"]
["src/nvim/spell.c", ["            sprintf(changename[depth], \"%.*s-%s: subst %c to %c\",", "                sp->ts_twordlen, tword, fword + sp->ts_fidx,", "                fword[sp->ts_fidx], c);"], "whitespace/alignment"]
["src/nvim/spell.c", ["                sp->ts_twordlen, tword, fword + sp->ts_fidx,", "                fword[sp->ts_fidx], c);", "          else"], "whitespace/alignment"]
["src/nvim/spell.c", ["          if (newscore > 0)", "            sprintf(changename[depth], \"%.*s-%s: subst %c to %c\",", "                sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["                fword[sp->ts_fidx], c);", "          else", "            sprintf(changename[depth], \"%.*s-%s: accept %c\","], "readability/braces"]
["src/nvim/spell.c", ["            sprintf(changename[depth], \"%.*s-%s: accept %c\",", "                sp->ts_twordlen, tword, fword + sp->ts_fidx,", "                fword[sp->ts_fidx]);"], "whitespace/alignment"]
["src/nvim/spell.c", ["                sp->ts_twordlen, tword, fword + sp->ts_fidx,", "                fword[sp->ts_fidx]);", "#endif"], "whitespace/alignment"]
["src/nvim/spell.c", ["          else", "            sprintf(changename[depth], \"%.*s-%s: accept %c\",", "                sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["#endif", "          ++depth;", "          sp = &stack[depth];"], "readability/increment"]
["src/nvim/spell.c", ["          sp = &stack[depth];", "          ++sp->ts_fidx;", "          tword[sp->ts_twordlen++] = c;"], "readability/increment"]
["src/nvim/spell.c", ["      sp->ts_curi = 1;", "      if (soundfold && sp->ts_fidx == 0 && fword[sp->ts_fidx] == '*')", "        // Deleting a vowel at the start of a word counts less, see"], "readability/braces"]
["src/nvim/spell.c", ["        newscore = 2 * SCORE_DEL / 3;", "      else", "        newscore = SCORE_DEL;"], "readability/braces"]
["src/nvim/spell.c", ["        sprintf(changename[depth], \"%.*s-%s: delete %c\",", "            sp->ts_twordlen, tword, fword + sp->ts_fidx,", "            fword[sp->ts_fidx]);"], "whitespace/alignment"]
["src/nvim/spell.c", ["            sp->ts_twordlen, tword, fword + sp->ts_fidx,", "            fword[sp->ts_fidx]);", "#endif"], "whitespace/alignment"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "        sprintf(changename[depth], \"%.*s-%s: delete %c\",", "            sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["#endif", "        ++depth;", ""], "readability/increment"]
["src/nvim/spell.c", ["        }", "        ++sp->ts_curi;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["      c = byts[n];", "      if (soundfold && sp->ts_twordlen == 0 && c == '*')", "        // Inserting a vowel at the start of a word counts less,"], "readability/braces"]
["src/nvim/spell.c", ["        newscore = 2 * SCORE_INS / 3;", "      else", "        newscore = SCORE_INS;"], "readability/braces"]
["src/nvim/spell.c", ["        sprintf(changename[depth], \"%.*s-%s: insert %c\",", "            sp->ts_twordlen, tword, fword + sp->ts_fidx,", "            c);"], "whitespace/alignment"]
["src/nvim/spell.c", ["            sp->ts_twordlen, tword, fword + sp->ts_fidx,", "            c);", "#endif"], "whitespace/alignment"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "        sprintf(changename[depth], \"%.*s-%s: insert %c\",", "            sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["#endif", "        ++depth;", "        sp = &stack[depth];"], "readability/increment"]
["src/nvim/spell.c", ["          // score).", "          if (sp->ts_twordlen >= 2", "              && tword[sp->ts_twordlen - 2] == c)"], "readability/braces"]
["src/nvim/spell.c", ["        sprintf(changename[depth], \"%.*s-%s: swap3 %c and %c\",", "            sp->ts_twordlen, tword, fword + sp->ts_fidx,", "            c, c3);"], "whitespace/alignment"]
["src/nvim/spell.c", ["            sp->ts_twordlen, tword, fword + sp->ts_fidx,", "            c, c3);", "#endif"], "whitespace/alignment"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "        sprintf(changename[depth], \"%.*s-%s: swap3 %c and %c\",", "            sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["        sprintf(changename[depth], \"%.*s-%s: rotate left %c%c%c\",", "            sp->ts_twordlen, tword, fword + sp->ts_fidx,", "            p[0], p[1], p[2]);"], "whitespace/alignment"]
["src/nvim/spell.c", ["            sp->ts_twordlen, tword, fword + sp->ts_fidx,", "            p[0], p[1], p[2]);", "#endif"], "whitespace/alignment"]
["src/nvim/spell.c", ["        p = fword + sp->ts_fidx;", "        sprintf(changename[depth], \"%.*s-%s: rotate left %c%c%c\",", "            sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["        sp->ts_state = STATE_UNROT3L;", "        ++depth;", "        p = fword + sp->ts_fidx;"], "readability/increment"]
["src/nvim/spell.c", ["        sprintf(changename[depth], \"%.*s-%s: rotate right %c%c%c\",", "            sp->ts_twordlen, tword, fword + sp->ts_fidx,", "            p[0], p[1], p[2]);"], "whitespace/alignment"]
["src/nvim/spell.c", ["            sp->ts_twordlen, tword, fword + sp->ts_fidx,", "            p[0], p[1], p[2]);", "#endif"], "whitespace/alignment"]
["src/nvim/spell.c", ["        p = fword + sp->ts_fidx;", "        sprintf(changename[depth], \"%.*s-%s: rotate right %c%c%c\",", "            sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["        sp->ts_state = STATE_UNROT3R;", "        ++depth;", "        p = fword + sp->ts_fidx;"], "readability/increment"]
["src/nvim/spell.c", ["      // match.  If the index is -1 there is none.", "      if (soundfold)", "        sp->ts_curi = slang->sl_repsal_first[fword[sp->ts_fidx]];"], "readability/braces"]
["src/nvim/spell.c", ["        sp->ts_curi = slang->sl_repsal_first[fword[sp->ts_fidx]];", "      else", "        sp->ts_curi = lp->lp_replang->sl_rep_first[fword[sp->ts_fidx]];"], "readability/braces"]
["src/nvim/spell.c", ["", "      if (soundfold)", "        gap = &slang->sl_repsal;"], "readability/braces"]
["src/nvim/spell.c", ["        gap = &slang->sl_repsal;", "      else", "        gap = &lp->lp_replang->sl_rep;"], "readability/braces"]
["src/nvim/spell.c", ["          sprintf(changename[depth], \"%.*s-%s: replace %s with %s\",", "              sp->ts_twordlen, tword, fword + sp->ts_fidx,", "              ftp->ft_from, ftp->ft_to);"], "whitespace/alignment"]
["src/nvim/spell.c", ["              sp->ts_twordlen, tword, fword + sp->ts_fidx,", "              ftp->ft_from, ftp->ft_to);", "#endif"], "whitespace/alignment"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "          sprintf(changename[depth], \"%.*s-%s: replace %s with %s\",", "              sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["          // Change the \"from\" to the \"to\" string.", "          ++depth;", "          fl = (int)STRLEN(ftp->ft_from);"], "readability/increment"]
["src/nvim/spell.c", ["", "      if (sp->ts_curi >= gap->ga_len && sp->ts_state == STATE_REP)", "        // No (more) matches."], "readability/braces"]
["src/nvim/spell.c", ["      // Undo a REP replacement and continue with the next one.", "      if (soundfold)", "        gap = &slang->sl_repsal;"], "readability/braces"]
["src/nvim/spell.c", ["        gap = &slang->sl_repsal;", "      else", "        gap = &lp->lp_replang->sl_rep;"], "readability/braces"]
["src/nvim/spell.c", ["      // Did all possible states at this level, go up one level.", "      --depth;", ""], "readability/increment"]
["src/nvim/spell.c", ["  }", "}", ""], "readability/fn_size"]
["src/nvim/spell.c", ["      // kword is getting too long, continue one level up", "      --depth;", "    } else if (++round[depth] > 2)   {"], "readability/increment"]
["src/nvim/spell.c", ["      // level up", "      --depth;", "    } else {"], "readability/increment"]
["src/nvim/spell.c", ["", "      for (tryidx = arridx[depth]; l > 0; --l) {", "        // Perform a binary search in the list of accepted bytes."], "readability/increment"]
["src/nvim/spell.c", ["          m = (lo + hi) / 2;", "          if (byts[m] > c)", "            hi = m - 1;"], "readability/braces"]
["src/nvim/spell.c", ["            hi = m - 1;", "          else if (byts[m] < c)", "            lo = m + 1;"], "readability/braces"]
["src/nvim/spell.c", ["            lo = m + 1;", "          else {", "            lo = hi = m;"], "readability/braces"]
["src/nvim/spell.c", ["            lo = m + 1;", "          else {", "            lo = hi = m;"], "readability/braces"]
["src/nvim/spell.c", ["        // Stop if there is no matching byte.", "        if (hi < lo || byts[lo] != c)", "          break;"], "readability/braces"]
["src/nvim/spell.c", ["          STRNCPY(kword + kwordlen[depth], fword + fwordidx[depth],", "              flen);", "          kwordlen[depth + 1] = kwordlen[depth] + flen;"], "whitespace/alignment"]
["src/nvim/spell.c", ["        if (round[depth] == 1) {", "          STRNCPY(kword + kwordlen[depth], fword + fwordidx[depth],", "              flen);"], "runtime/printf"]
["src/nvim/spell.c", ["          STRNCPY(kword + kwordlen[depth], uword + uwordidx[depth],", "              ulen);", "          kwordlen[depth + 1] = kwordlen[depth] + ulen;"], "whitespace/alignment"]
["src/nvim/spell.c", ["        } else {", "          STRNCPY(kword + kwordlen[depth], uword + uwordidx[depth],", "              ulen);"], "runtime/printf"]
["src/nvim/spell.c", ["", "        ++depth;", "        arridx[depth] = tryidx;"], "readability/increment"]
["src/nvim/spell.c", ["  // Use the sound-folding of the first language that supports it.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["", "      for (i = 0; i < su->su_ga.ga_len; ++i) {", "        stp = &SUG(su->su_ga, i);"], "readability/increment"]
["src/nvim/spell.c", ["          sstp->st_orglen = stp->st_orglen;", "          ++su->su_sga.ga_len;", "        }"], "readability/increment"]
["src/nvim/spell.c", ["  // Add the alternate score to su_ga.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["", "      for (int i = 0; i < su->su_ga.ga_len; ++i) {", "        stp = &SUG(su->su_ga, i);"], "readability/increment"]
["src/nvim/spell.c", ["        stp->st_altscore = stp_sal_score(stp, su, slang, badsound);", "        if (stp->st_altscore == SCORE_MAXMAX)", "          stp->st_score = (stp->st_score * 3 + SCORE_BIG) / 4;"], "readability/braces"]
["src/nvim/spell.c", ["          stp->st_score = (stp->st_score * 3 + SCORE_BIG) / 4;", "        else", "          stp->st_score = (stp->st_score * 3"], "readability/braces"]
["src/nvim/spell.c", ["    (void)cleanup_suggestions(&su->su_ga, su->su_maxscore,", "        su->su_maxcount);", "    return;"], "whitespace/alignment"]
["src/nvim/spell.c", ["  // Add the alternate score to su_sga.", "  for (int i = 0; i < su->su_sga.ga_len; ++i) {", "    stp = &SUG(su->su_sga, i);"], "readability/increment"]
["src/nvim/spell.c", ["    stp->st_altscore = spell_edit_score(slang,", "        su->su_badword, stp->st_word);", "    if (stp->st_score == SCORE_MAXMAX)"], "whitespace/alignment"]
["src/nvim/spell.c", ["        su->su_badword, stp->st_word);", "    if (stp->st_score == SCORE_MAXMAX)", "      stp->st_score = (SCORE_BIG * 7 + stp->st_altscore) / 8;"], "readability/braces"]
["src/nvim/spell.c", ["      stp->st_score = (SCORE_BIG * 7 + stp->st_altscore) / 8;", "    else", "      stp->st_score = (stp->st_score * 7 + stp->st_altscore) / 8;"], "readability/braces"]
["src/nvim/spell.c", ["  stp = &SUG(ga, 0);", "  for (int i = 0; i < su->su_ga.ga_len || i < su->su_sga.ga_len; ++i) {", "    // round 1: get a suggestion from su_ga"], "readability/increment"]
["src/nvim/spell.c", ["    // round 2: get a suggestion from su_sga", "    for (round = 1; round <= 2; ++round) {", "      gap = round == 1 ? &su->su_ga : &su->su_sga;"], "readability/increment"]
["src/nvim/spell.c", ["        int j;", "        for (j = 0; j < ga.ga_len; ++j)", "          if (STRCMP(stp[j].st_word, p) == 0)"], "readability/braces"]
["src/nvim/spell.c", ["        int j;", "        for (j = 0; j < ga.ga_len; ++j)", "          if (STRCMP(stp[j].st_word, p) == 0)"], "readability/increment"]
["src/nvim/spell.c", ["        for (j = 0; j < ga.ga_len; ++j)", "          if (STRCMP(stp[j].st_word, p) == 0)", "            break;"], "readability/braces"]
["src/nvim/spell.c", ["            break;", "        if (j == ga.ga_len)", "          stp[ga.ga_len++] = SUG(*gap, i);"], "readability/braces"]
["src/nvim/spell.c", ["          stp[ga.ga_len++] = SUG(*gap, i);", "        else", "          xfree(p);"], "readability/braces"]
["src/nvim/spell.c", ["  if (ga.ga_len > su->su_maxcount) {", "    for (int i = su->su_maxcount; i < ga.ga_len; ++i) {", "      xfree(stp[i].st_word);"], "readability/increment"]
["src/nvim/spell.c", ["static int", "stp_sal_score (", "    suggest_T *stp,"], "whitespace/parens"]
["src/nvim/spell.c", ["  lendiff = su->su_badlen - stp->st_orglen;", "  if (lendiff >= 0)", "    pbad = badsound;"], "readability/braces"]
["src/nvim/spell.c", ["    pbad = badsound;", "  else {", "    // soundfold the bad word with more characters following"], "readability/braces"]
["src/nvim/spell.c", ["    pbad = badsound;", "  else {", "    // soundfold the bad word with more characters following"], "readability/braces"]
["src/nvim/spell.c", ["    // space.", "    if (ascii_iswhite(su->su_badptr[su->su_badlen])", "        && *skiptowhite(stp->st_word) == NUL)"], "readability/braces"]
["src/nvim/spell.c", ["        && *skiptowhite(stp->st_word) == NUL)", "      for (p = fword; *(p = skiptowhite(p)) != NUL; )", "        STRMOVE(p, p + 1);"], "readability/braces"]
["src/nvim/spell.c", ["    STRLCPY(goodword + stp->st_wordlen,", "        su->su_badptr + su->su_badlen - lendiff, lendiff + 1);", "    pgood = goodword;"], "whitespace/alignment"]
["src/nvim/spell.c", ["    pgood = goodword;", "  } else", "    pgood = stp->st_word;"], "readability/braces"]
["src/nvim/spell.c", ["  // .sug file has been loaded.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["    slang = lp->lp_slang;", "    if (!GA_EMPTY(&slang->sl_sal) && slang->sl_sbyts != NULL)", "      // prepare the hashtable used by add_sound_suggest()"], "readability/braces"]
["src/nvim/spell.c", ["  // .sug file has been loaded.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["      // try all kinds of inserts/deletes/swaps/etc.", "      // TODO: also soundfold the next words, so that we can try joining", "      // and splitting"], "readability/todo"]
["src/nvim/spell.c", ["  // .sug file has been loaded.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["      todo = (int)slang->sl_sounddone.ht_used;", "      for (hi = slang->sl_sounddone.ht_array; todo > 0; ++hi)", "        if (!HASHITEM_EMPTY(hi)) {"], "readability/braces"]
["src/nvim/spell.c", ["      todo = (int)slang->sl_sounddone.ht_used;", "      for (hi = slang->sl_sounddone.ht_array; todo > 0; ++hi)", "        if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/spell.c", ["          xfree(HI2SFT(hi));", "          --todo;", "        }"], "readability/increment"]
["src/nvim/spell.c", ["static void", "add_sound_suggest (", "    suginfo_T *su,"], "whitespace/parens"]
["src/nvim/spell.c", ["    sft = HI2SFT(hi);", "    if (score >= sft->sft_score)", "      return;"], "readability/braces"]
["src/nvim/spell.c", ["    wordcount = 0;", "    for (wlen = 0; wlen < MAXWLEN - 3; ++wlen) {", "      i = 1;"], "readability/increment"]
["src/nvim/spell.c", ["      i = 1;", "      if (wordcount == orgnr && byts[n + 1] == NUL)", "        break;          // found end of word"], "readability/braces"]
["src/nvim/spell.c", ["", "      if (byts[n + 1] == NUL)", "        ++wordcount;"], "readability/braces"]
["src/nvim/spell.c", ["      if (byts[n + 1] == NUL)", "        ++wordcount;", ""], "readability/increment"]
["src/nvim/spell.c", ["      // skip over the NUL bytes", "      for (; byts[n + i] == NUL; ++i)", "        if (i > byts[n]) {              // safety check"], "readability/braces"]
["src/nvim/spell.c", ["      // skip over the NUL bytes", "      for (; byts[n + i] == NUL; ++i)", "        if (i > byts[n]) {              // safety check"], "readability/increment"]
["src/nvim/spell.c", ["      // One of the siblings must have the word.", "      for (; i < byts[n]; ++i) {", "        wc = idxs[idxs[n + i]];         // nr of words under this byte"], "readability/increment"]
["src/nvim/spell.c", ["        wc = idxs[idxs[n + i]];         // nr of words under this byte", "        if (wordcount + wc > orgnr)", "          break;"], "readability/braces"]
["src/nvim/spell.c", ["    // Go over the possible flags and regions.", "    for (; i <= byts[n] && byts[n + i] == NUL; ++i) {", "      char_u cword[MAXWLEN];"], "readability/increment"]
["src/nvim/spell.c", ["      // Skip words with the NOSUGGEST flag", "      if (flags & WF_NOSUGGEST)", "        continue;"], "readability/braces"]
["src/nvim/spell.c", ["          p = cword;", "        } else", "          p = theword;"], "readability/braces"]
["src/nvim/spell.c", ["        // Add the suggestion if the score isn't too bad.", "        if (score <= su->su_maxscore)", "          add_suggestion(su, &su->su_sga, p, su->su_badlen,"], "readability/braces"]
["src/nvim/spell.c", ["          add_suggestion(su, &su->su_sga, p, su->su_badlen,", "              score, 0, false, slang, false);", "      } else {"], "whitespace/alignment"]
["src/nvim/spell.c", ["        // Add a penalty for words in another region.", "        if ((flags & WF_REGION)", "            && (((unsigned)flags >> 16) & lp->lp_region) == 0)"], "readability/braces"]
["src/nvim/spell.c", ["          goodscore = SCORE_REGION;", "        else", "          goodscore = 0;"], "readability/braces"]
["src/nvim/spell.c", ["          bc = PTR2CHAR(su->su_badword);", "          if (!SPELL_ISUPPER(bc)", "              && SPELL_TOFOLD(bc) != SPELL_TOFOLD(gc))"], "readability/braces"]
["src/nvim/spell.c", ["        limit = MAXSCORE(su->su_sfmaxscore - goodscore, score);", "        if (limit > SCORE_LIMITMAX)", "          goodscore += spell_edit_score(slang, su->su_badword, p);"], "readability/braces"]
["src/nvim/spell.c", ["          goodscore += spell_edit_score(slang, su->su_badword, p);", "        else", "          goodscore += spell_edit_score_limit(slang, su->su_badword,"], "readability/braces"]
["src/nvim/spell.c", ["          goodscore += spell_edit_score_limit(slang, su->su_badword,", "              p, limit);", ""], "whitespace/alignment"]
["src/nvim/spell.c", ["          goodscore = RESCORE(goodscore, score);", "          if (goodscore <= su->su_sfmaxscore)", "            add_suggestion(su, &su->su_ga, p, su->su_badlen,"], "readability/braces"]
["src/nvim/spell.c", ["            add_suggestion(su, &su->su_ga, p, su->su_badlen,", "                goodscore, score, true, slang, true);", "        }"], "whitespace/alignment"]
["src/nvim/spell.c", ["    if (byts[arridx] == NUL) {", "      if (c == NUL)", "        break;"], "readability/braces"]
["src/nvim/spell.c", ["      while (len > 0 && byts[arridx] == NUL) {", "        ++arridx;", "        --len;"], "readability/increment"]
["src/nvim/spell.c", ["        ++arridx;", "        --len;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["      }", "      if (len == 0)", "        return -1;            // no children, word should have ended here"], "readability/braces"]
["src/nvim/spell.c", ["        return -1;            // no children, word should have ended here", "      ++wordnr;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["    // If the word ends we didn't find it.", "    if (c == NUL)", "      return -1;"], "readability/braces"]
["src/nvim/spell.c", ["    // Perform a binary search in the list of accepted bytes.", "    if (c == TAB)           // <Tab> is handled like <Space>", "      c = ' ';"], "readability/braces"]
["src/nvim/spell.c", ["      wordnr += idxs[idxs[arridx]];", "      ++arridx;", "      if (--len == 0)           // end of the bytes, didn't find it"], "readability/increment"]
["src/nvim/spell.c", ["      ++arridx;", "      if (--len == 0)           // end of the bytes, didn't find it", "        return -1;"], "readability/braces"]
["src/nvim/spell.c", ["    }", "    if (byts[arridx] != c)      // didn't find the byte", "      return -1;"], "readability/braces"]
["src/nvim/spell.c", ["    arridx = idxs[arridx];", "    ++wlen;", ""], "readability/increment"]
["src/nvim/spell.c", ["    // checked word.", "    if (c == ' ')", "      while (ptr[wlen] == ' ' || ptr[wlen] == TAB)"], "readability/braces"]
["src/nvim/spell.c", ["    if (c == ' ')", "      while (ptr[wlen] == ' ' || ptr[wlen] == TAB)", "        ++wlen;"], "readability/braces"]
["src/nvim/spell.c", ["      while (ptr[wlen] == ' ' || ptr[wlen] == TAB)", "        ++wlen;", "  }"], "readability/increment"]
["src/nvim/spell.c", ["{", "  if (flags & WF_ALLCAP)", "    // Make it all upper-case"], "readability/braces"]
["src/nvim/spell.c", ["    allcap_copy(fword, cword);", "  else if (flags & WF_ONECAP)", "    // Make the first letter upper-case"], "readability/braces"]
["src/nvim/spell.c", ["    onecap_copy(fword, cword, true);", "  else", "    // Use goodword as-is."], "readability/braces"]
["src/nvim/spell.c", ["static void", "add_suggestion (", "    suginfo_T *su,"], "whitespace/parens"]
["src/nvim/spell.c", ["    badlen = (int)(pbad - su->su_badptr);", "    if (goodlen <= 0 || badlen <= 0)", "      break;"], "readability/braces"]
["src/nvim/spell.c", ["", "  if (badlen == 0 && goodlen == 0)", "    // goodword doesn't change anything; may happen for \"the the\" changing"], "readability/braces"]
["src/nvim/spell.c", ["        // Found it.  Remember the word with the lowest score.", "        if (stp->st_slang == NULL)", "          stp->st_slang = slang;"], "readability/braces"]
["src/nvim/spell.c", ["          // the soundalike score to zero.", "          if (had_bonus)", "            rescore_one(su, stp);"], "readability/braces"]
["src/nvim/spell.c", ["            rescore_one(su, stp);", "          else {", "            new_sug.st_word = stp->st_word;"], "readability/braces"]
["src/nvim/spell.c", ["            rescore_one(su, stp);", "          else {", "            new_sug.st_word = stp->st_word;"], "readability/braces"]
["src/nvim/spell.c", ["    if (gap->ga_len > SUG_MAX_COUNT(su)) {", "      if (maxsf)", "        su->su_sfmaxscore = cleanup_suggestions(gap,"], "readability/braces"]
["src/nvim/spell.c", ["        su->su_sfmaxscore = cleanup_suggestions(gap,", "            su->su_sfmaxscore, SUG_CLEAN_COUNT(su));", "      else"], "whitespace/alignment"]
["src/nvim/spell.c", ["            su->su_sfmaxscore, SUG_CLEAN_COUNT(su));", "      else", "        su->su_maxscore = cleanup_suggestions(gap,"], "readability/braces"]
["src/nvim/spell.c", ["        su->su_maxscore = cleanup_suggestions(gap,", "            su->su_maxscore, SUG_CLEAN_COUNT(su));", "    }"], "whitespace/alignment"]
["src/nvim/spell.c", ["static void", "check_suggestions (", "    suginfo_T *su,"], "whitespace/parens"]
["src/nvim/spell.c", ["  stp = &SUG(*gap, 0);", "  for (int i = gap->ga_len - 1; i >= 0; --i) {", "    // Need to append what follows to check for \"the the\"."], "readability/increment"]
["src/nvim/spell.c", ["    STRLCPY(longword + len, su->su_badptr + stp[i].st_orglen,", "        MAXWLEN - len + 1);", "    attr = HLF_COUNT;"], "whitespace/alignment"]
["src/nvim/spell.c", ["      xfree(stp[i].st_word);", "      --gap->ga_len;", "      if (i < gap->ga_len)"], "readability/increment"]
["src/nvim/spell.c", ["      --gap->ga_len;", "      if (i < gap->ga_len)", "        memmove(stp + i, stp + i + 1,"], "readability/braces"]
["src/nvim/spell.c", ["        memmove(stp + i, stp + i + 1,", "            sizeof(suggest_T) * (gap->ga_len - i));", "    }"], "whitespace/alignment"]
["src/nvim/spell.c", ["  if (su->su_sallang != NULL) {", "    for (int i = 0; i < su->su_ga.ga_len; ++i) {", "      rescore_one(su, &SUG(su->su_ga, i));"], "readability/increment"]
["src/nvim/spell.c", ["  if (slang != NULL && !GA_EMPTY(&slang->sl_sal) && !stp->st_had_bonus) {", "    if (slang == su->su_sallang)", "      p = su->su_sal_badword;"], "readability/braces"]
["src/nvim/spell.c", ["      p = su->su_sal_badword;", "    else {", "      spell_soundfold(slang, su->su_fbadword, true, sal_badword);"], "readability/braces"]
["src/nvim/spell.c", ["      p = su->su_sal_badword;", "    else {", "      spell_soundfold(slang, su->su_fbadword, true, sal_badword);"], "readability/braces"]
["src/nvim/spell.c", ["    stp->st_altscore = stp_sal_score(stp, su, slang, p);", "    if (stp->st_altscore == SCORE_MAXMAX)", "      stp->st_altscore = SCORE_BIG;"], "readability/braces"]
["src/nvim/spell.c", ["    n = p1->st_altscore - p2->st_altscore;", "    if (n == 0)", "      n = STRICMP(p1->st_word, p2->st_word);"], "readability/braces"]
["src/nvim/spell.c", ["static int", "cleanup_suggestions (", "    garray_T *gap,"], "whitespace/parens"]
["src/nvim/spell.c", ["", "  if (slang->sl_sofo)", "    // SOFOFROM and SOFOTO used"], "readability/braces"]
["src/nvim/spell.c", ["    spell_soundfold_sofo(slang, inword, res);", "  else {", "    // SAL items used.  Requires the word to be case-folded."], "readability/braces"]
["src/nvim/spell.c", ["    spell_soundfold_sofo(slang, inword, res);", "  else {", "    // SAL items used.  Requires the word to be case-folded."], "readability/braces"]
["src/nvim/spell.c", ["    // SAL items used.  Requires the word to be case-folded.", "    if (folded)", "      word = inword;"], "readability/braces"]
["src/nvim/spell.c", ["      word = inword;", "    else {", "      (void)spell_casefold(inword, (int)STRLEN(inword), fword, MAXWLEN);"], "readability/braces"]
["src/nvim/spell.c", ["      word = inword;", "    else {", "      (void)spell_casefold(inword, (int)STRLEN(inword), fword, MAXWLEN);"], "readability/braces"]
["src/nvim/spell.c", ["      for (; ((ws = smp[n].sm_lead_w)[0] & 0xff) == (c & 0xff)", "           && ws[0] != NUL; ++n) {", "        // Quickly skip entries that don't match the word.  Most"], "readability/increment"]
["src/nvim/spell.c", ["        // entries are less then three chars, optimize for that.", "        if (c != ws[0])", "          continue;"], "readability/braces"]
["src/nvim/spell.c", ["        if (k > 1) {", "          if (word[i + 1] != ws[1])", "            continue;"], "readability/braces"]
["src/nvim/spell.c", ["          if (k > 2) {", "            for (j = 2; j < k; ++j)", "              if (word[i + j] != ws[j])"], "readability/braces"]
["src/nvim/spell.c", ["          if (k > 2) {", "            for (j = 2; j < k; ++j)", "              if (word[i + j] != ws[j])"], "readability/increment"]
["src/nvim/spell.c", ["            for (j = 2; j < k; ++j)", "              if (word[i + j] != ws[j])", "                break;"], "readability/braces"]
["src/nvim/spell.c", ["                break;", "            if (j < k)", "              continue;"], "readability/braces"]
["src/nvim/spell.c", ["          // Check for match with one of the chars in \"sm_oneof\".", "          while (*pf != NUL && *pf != word[i + k])", "            ++pf;"], "readability/braces"]
["src/nvim/spell.c", ["          while (*pf != NUL && *pf != word[i + k])", "            ++pf;", "          if (*pf == NUL)"], "readability/increment"]
["src/nvim/spell.c", ["            ++pf;", "          if (*pf == NUL)", "            continue;"], "readability/braces"]
["src/nvim/spell.c", ["            continue;", "          ++k;", "        }"], "readability/increment"]
["src/nvim/spell.c", ["        }", "        if (*s == '<')", "          s++;"], "readability/braces"]
["src/nvim/spell.c", ["        }", "        if (*s == '^' && *(s + 1) == '^')", "          s++;"], "readability/braces"]
["src/nvim/spell.c", ["            for (; ((ws = smp[n0].sm_lead_w)[0] & 0xff)", "                 == (c0 & 0xff); ++n0) {", "              // Quickly skip entries that don't match the word."], "readability/increment"]
["src/nvim/spell.c", ["              // Quickly skip entries that don't match the word.", "              if (c0 != ws[0])", "                continue;"], "readability/braces"]
["src/nvim/spell.c", ["              if (k0 > 1) {", "                if (word[i + k] != ws[1])", "                  continue;"], "readability/braces"]
["src/nvim/spell.c", ["                  pf = word + i + k + 1;", "                  for (j = 2; j < k0; ++j)", "                    if (*pf++ != ws[j])"], "readability/braces"]
["src/nvim/spell.c", ["                  pf = word + i + k + 1;", "                  for (j = 2; j < k0; ++j)", "                    if (*pf++ != ws[j])"], "readability/increment"]
["src/nvim/spell.c", ["                  for (j = 2; j < k0; ++j)", "                    if (*pf++ != ws[j])", "                      break;"], "readability/braces"]
["src/nvim/spell.c", ["                      break;", "                  if (j < k0)", "                    continue;"], "readability/braces"]
["src/nvim/spell.c", ["                // \"sm_oneof\".", "                while (*pf != NUL && *pf != word[i + k0])", "                  ++pf;"], "readability/braces"]
["src/nvim/spell.c", ["                while (*pf != NUL && *pf != word[i + k0])", "                  ++pf;", "                if (*pf == NUL)"], "readability/increment"]
["src/nvim/spell.c", ["                  ++pf;", "                if (*pf == NUL)", "                  continue;"], "readability/braces"]
["src/nvim/spell.c", ["                  continue;", "                ++k0;", "              }"], "readability/increment"]
["src/nvim/spell.c", ["              }", "              if (*s == '<')", "                s++;"], "readability/braces"]
["src/nvim/spell.c", ["                      && !spell_iswordp_w(word + i + k0,", "                          curwin))) {", "                if (k0 == k)"], "whitespace/alignment"]
["src/nvim/spell.c", ["                      && !spell_iswordp_w(word + i + k0,", "                          curwin))) {", "                if (k0 == k)"], "whitespace/alignment"]
["src/nvim/spell.c", ["                      && !spell_iswordp_w(word + i + k0,", "                          curwin))) {", "                if (k0 == k)"], "whitespace/alignment"]
["src/nvim/spell.c", ["                          curwin))) {", "                if (k0 == k)", "                  // this is just a piece of the string"], "readability/braces"]
["src/nvim/spell.c", ["", "                if (p0 < pri)", "                  // priority too low"], "readability/braces"]
["src/nvim/spell.c", ["", "            if (p0 >= pri && (smp[n0].sm_lead_w[0] & 0xff)", "                == (c0 & 0xff))"], "readability/braces"]
["src/nvim/spell.c", ["            // rule with '<' is used", "            if (reslen > 0 && ws != NULL && *ws != NUL", "                && (wres[reslen - 1] == c"], "readability/braces"]
["src/nvim/spell.c", ["            k0 = 0;", "            if (ws != NULL)", "              while (*ws != NUL && word[i + k0] != NUL) {"], "readability/braces"]
["src/nvim/spell.c", ["              }", "            if (k > k0)", "              memmove(word + i + k0, word + i + k,"], "readability/braces"]
["src/nvim/spell.c", ["              memmove(word + i + k0, word + i + k,", "                  sizeof(int) * (wordlen - (i + k) + 1));", ""], "whitespace/alignment"]
["src/nvim/spell.c", ["            z = 0;", "            if (ws != NULL)", "              while (*ws != NUL && ws[1] != NUL"], "readability/braces"]
["src/nvim/spell.c", ["                     && reslen < MAXWLEN) {", "                if (reslen == 0 || wres[reslen - 1] != *ws)", "                  wres[reslen++] = *ws;"], "readability/braces"]
["src/nvim/spell.c", ["            // new \"actual letter\"", "            if (ws == NULL)", "              c = NUL;"], "readability/braces"]
["src/nvim/spell.c", ["              c = NUL;", "            else", "              c = *ws;"], "readability/braces"]
["src/nvim/spell.c", ["            if (strstr((char *)s, \"^^\") != NULL) {", "              if (c != NUL)", "                wres[reslen++] = c;"], "readability/braces"]
["src/nvim/spell.c", ["              memmove(word, word + i + 1,", "                  sizeof(int) * (wordlen - (i + 1) + 1));", "              i = 0;"], "whitespace/alignment"]
["src/nvim/spell.c", ["    if (z0 == 0) {", "      if (k && !p0 && reslen < MAXWLEN && c != NUL", "          && (!slang->sl_collapse || reslen == 0"], "readability/braces"]
["src/nvim/spell.c", ["static int", "soundalike_score (", "    char_u *goodstart,         // sound-folded good word"], "whitespace/parens"]
["src/nvim/spell.c", ["  if ((*badsound == '*' || *goodsound == '*') && *badsound != *goodsound) {", "    if ((badsound[0] == NUL && goodsound[1] == NUL)", "        || (goodsound[0] == NUL && badsound[1] == NUL))"], "readability/braces"]
["src/nvim/spell.c", ["      return SCORE_DEL;", "    if (badsound[0] == NUL || goodsound[0] == NUL)", "      // more than two changes"], "readability/braces"]
["src/nvim/spell.c", ["      score = 2 * SCORE_DEL / 3;", "      if (*badsound == '*')", "        ++badsound;"], "readability/braces"]
["src/nvim/spell.c", ["      if (*badsound == '*')", "        ++badsound;", "      else"], "readability/increment"]
["src/nvim/spell.c", ["        ++badsound;", "      else", "        ++goodsound;"], "readability/braces"]
["src/nvim/spell.c", ["      else", "        ++goodsound;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["  n = goodlen - badlen;", "  if (n < -2 || n > 2)", "    return SCORE_MAXMAX;"], "readability/braces"]
["src/nvim/spell.c", ["  while (*pl == *ps && *pl != NUL) {", "    ++pl;", "    ++ps;"], "readability/increment"]
["src/nvim/spell.c", ["    ++pl;", "    ++ps;", "  }"], "readability/increment"]
["src/nvim/spell.c", ["    // Must delete two characters from \"pl\".", "    ++pl;               // first delete", "    while (*pl == *ps) {"], "readability/increment"]
["src/nvim/spell.c", ["    while (*pl == *ps) {", "      ++pl;", "      ++ps;"], "readability/increment"]
["src/nvim/spell.c", ["      ++pl;", "      ++ps;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["    // strings must be equal after second delete", "    if (STRCMP(pl + 1, ps) == 0)", "      return score + SCORE_DEL * 2;"], "readability/braces"]
["src/nvim/spell.c", ["    while (*pl2 == *ps2) {", "      if (*pl2 == NUL)                  // reached the end", "        return score + SCORE_DEL;"], "readability/braces"]
["src/nvim/spell.c", ["        return score + SCORE_DEL;", "      ++pl2;", "      ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["      ++pl2;", "      ++ps2;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["    // 2: delete then swap, then rest must be equal", "    if (pl2[0] == ps2[1] && pl2[1] == ps2[0]", "        && STRCMP(pl2 + 2, ps2 + 2) == 0)"], "readability/braces"]
["src/nvim/spell.c", ["    // 3: delete then substitute, then the rest must be equal", "    if (STRCMP(pl2 + 1, ps2 + 1) == 0)", "      return score + SCORE_DEL + SCORE_SUBST;"], "readability/braces"]
["src/nvim/spell.c", ["      while (*pl2 == *ps2) {", "        ++pl2;", "        ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["        ++pl2;", "        ++ps2;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["      // delete a char and then strings must be equal", "      if (STRCMP(pl2 + 1, ps2) == 0)", "        return score + SCORE_SWAP + SCORE_DEL;"], "readability/braces"]
["src/nvim/spell.c", ["    while (*pl2 == *ps2) {", "      ++pl2;", "      ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["      ++pl2;", "      ++ps2;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["    // delete a char and then strings must be equal", "    if (STRCMP(pl2 + 1, ps2) == 0)", "      return score + SCORE_SUBST + SCORE_DEL;"], "readability/braces"]
["src/nvim/spell.c", ["    // 1: check if for identical strings", "    if (*pl == NUL)", "      return score;"], "readability/braces"]
["src/nvim/spell.c", ["      while (*pl2 == *ps2) {", "        if (*pl2 == NUL)                // reached the end", "          return score + SCORE_SWAP;"], "readability/braces"]
["src/nvim/spell.c", ["          return score + SCORE_SWAP;", "        ++pl2;", "        ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["        ++pl2;", "        ++ps2;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["      // 3: swap and swap again", "      if (pl2[0] == ps2[1] && pl2[1] == ps2[0]", "          && STRCMP(pl2 + 2, ps2 + 2) == 0)"], "readability/braces"]
["src/nvim/spell.c", ["      // 4: swap and substitute", "      if (STRCMP(pl2 + 1, ps2 + 1) == 0)", "        return score + SCORE_SWAP + SCORE_SUBST;"], "readability/braces"]
["src/nvim/spell.c", ["    while (*pl2 == *ps2) {", "      if (*pl2 == NUL)                  // reached the end", "        return score + SCORE_SUBST;"], "readability/braces"]
["src/nvim/spell.c", ["        return score + SCORE_SUBST;", "      ++pl2;", "      ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["      ++pl2;", "      ++ps2;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["    // 6: substitute and swap", "    if (pl2[0] == ps2[1] && pl2[1] == ps2[0]", "        && STRCMP(pl2 + 2, ps2 + 2) == 0)"], "readability/braces"]
["src/nvim/spell.c", ["    // 7: substitute and substitute", "    if (STRCMP(pl2 + 1, ps2 + 1) == 0)", "      return score + SCORE_SUBST + SCORE_SUBST;"], "readability/braces"]
["src/nvim/spell.c", ["    while (*pl2 == *ps2) {", "      ++pl2;", "      ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["      ++pl2;", "      ++ps2;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["    }", "    if (STRCMP(pl2 + 1, ps2) == 0)", "      return score + SCORE_INS + SCORE_DEL;"], "readability/braces"]
["src/nvim/spell.c", ["    while (*pl2 == *ps2) {", "      ++pl2;", "      ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["      ++pl2;", "      ++ps2;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["    }", "    if (STRCMP(pl2, ps2 + 1) == 0)", "      return score + SCORE_INS + SCORE_DEL;"], "readability/braces"]
["src/nvim/spell.c", ["  CNT(0, 0) = 0;", "  for (j = 1; j <= goodlen; ++j)", "    CNT(0, j) = CNT(0, j - 1) + SCORE_INS;"], "readability/braces"]
["src/nvim/spell.c", ["  CNT(0, 0) = 0;", "  for (j = 1; j <= goodlen; ++j)", "    CNT(0, j) = CNT(0, j - 1) + SCORE_INS;"], "readability/increment"]
["src/nvim/spell.c", ["", "  for (i = 1; i <= badlen; ++i) {", "    CNT(i, 0) = CNT(i - 1, 0) + SCORE_DEL;"], "readability/increment"]
["src/nvim/spell.c", ["        // Use a better score when there is only a case difference.", "        if (SPELL_TOFOLD(bc) == SPELL_TOFOLD(gc))", "          CNT(i, j) = SCORE_ICASE + CNT(i - 1, j - 1);"], "readability/braces"]
["src/nvim/spell.c", ["          CNT(i, j) = SCORE_ICASE + CNT(i - 1, j - 1);", "        else {", "          // For a similar character use SCORE_SIMILAR."], "readability/braces"]
["src/nvim/spell.c", ["          CNT(i, j) = SCORE_ICASE + CNT(i - 1, j - 1);", "        else {", "          // For a similar character use SCORE_SIMILAR."], "readability/braces"]
["src/nvim/spell.c", ["          // For a similar character use SCORE_SIMILAR.", "          if (slang != NULL", "              && slang->sl_has_map"], "readability/braces"]
["src/nvim/spell.c", ["            CNT(i, j) = SCORE_SIMILAR + CNT(i - 1, j - 1);", "          else", "            CNT(i, j) = SCORE_SUBST + CNT(i - 1, j - 1);"], "readability/braces"]
["src/nvim/spell.c", ["            t = SCORE_SWAP + CNT(i - 2, j - 2);", "            if (t < CNT(i, j))", "              CNT(i, j) = t;"], "readability/braces"]
["src/nvim/spell.c", ["        t = SCORE_DEL + CNT(i - 1, j);", "        if (t < CNT(i, j))", "          CNT(i, j) = t;"], "readability/braces"]
["src/nvim/spell.c", ["        t = SCORE_INS + CNT(i, j - 1);", "        if (t < CNT(i, j))", "          CNT(i, j) = t;"], "readability/braces"]
["src/nvim/spell.c", ["// for multi-byte characters.", "static int spell_edit_score_limit(slang_T *slang, char_u *badword, char_u *goodword, int limit)", "{"], "whitespace/line_length"]
["src/nvim/spell.c", ["// Keep it in sync with the above!", "static int spell_edit_score_limit_w(slang_T *slang, char_u *badword, char_u *goodword, int limit)", "{"], "whitespace/line_length"]
["src/nvim/spell.c", ["", "      if (bc != gc)             // stop at a char that's different", "        break;"], "readability/braces"]
["src/nvim/spell.c", ["      if (bc == NUL) {          // both words end", "        if (score < minscore)", "          minscore = score;"], "readability/braces"]
["src/nvim/spell.c", ["      }", "      ++bi;", "      ++gi;"], "readability/increment"]
["src/nvim/spell.c", ["      ++bi;", "      ++gi;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["      do {", "        if ((score += SCORE_DEL) >= minscore)", "          goto pop;                 // do next alternative"], "readability/braces"]
["src/nvim/spell.c", ["      minscore = score;", "    } else if (bc == NUL)   { // badword ends, insert badword chars", "      do {"], "whitespace/comments"]
["src/nvim/spell.c", ["      do {", "        if ((score += SCORE_INS) >= minscore)", "          goto pop;                 // do next alternative"], "readability/braces"]
["src/nvim/spell.c", ["      // round 1: try inserting a char in badword", "      for (round = 0; round <= 1; ++round) {", "        score_off = score + (round == 0 ? SCORE_DEL : SCORE_INS);"], "readability/increment"]
["src/nvim/spell.c", ["              }", "              ++bi2;", "              ++gi2;"], "readability/increment"]
["src/nvim/spell.c", ["              ++bi2;", "              ++gi2;", "            }"], "readability/increment"]
["src/nvim/spell.c", ["            stack[stackidx].score = score_off;", "            ++stackidx;", "          }"], "readability/increment"]
["src/nvim/spell.c", ["      // Use a better score when there is only a case difference.", "      if (SPELL_TOFOLD(bc) == SPELL_TOFOLD(gc))", "        score += SCORE_ICASE;"], "readability/braces"]
["src/nvim/spell.c", ["        score += SCORE_ICASE;", "      else {", "        // For a similar character use SCORE_SIMILAR."], "readability/braces"]
["src/nvim/spell.c", ["        score += SCORE_ICASE;", "      else {", "        // For a similar character use SCORE_SIMILAR."], "readability/braces"]
["src/nvim/spell.c", ["        // For a similar character use SCORE_SIMILAR.", "        if (slang != NULL", "            && slang->sl_has_map"], "readability/braces"]
["src/nvim/spell.c", ["          score += SCORE_SIMILAR;", "        else", "          score += SCORE_SUBST;"], "readability/braces"]
["src/nvim/spell.c", ["        // Do the substitution.", "        ++gi;", "        ++bi;"], "readability/increment"]
["src/nvim/spell.c", ["        ++gi;", "        ++bi;", "        continue;"], "readability/increment"]
["src/nvim/spell.c", ["    // Get here to try the next alternative, pop it from the stack.", "    if (stackidx == 0)                  // stack is empty, finished", "      break;"], "readability/braces"]
["src/nvim/spell.c", ["    // pop an item from the stack", "    --stackidx;", "    gi = stack[stackidx].goodi;"], "readability/increment"]
["src/nvim/spell.c", ["  // bonus.", "  if (minscore > limit)", "    return SCORE_MAXMAX;"], "readability/braces"]
["src/nvim/spell.c", ["void", "spell_dump_compl (", "    char_u *pat,           // leading part of the word"], "whitespace/parens"]
["src/nvim/spell.c", ["  if (pat != NULL) {", "    if (ic)", "      dumpflags |= DUMPFLAG_ICASE;"], "readability/braces"]
["src/nvim/spell.c", ["      dumpflags |= DUMPFLAG_ICASE;", "    else {", "      n = captype(pat, NULL);"], "readability/braces"]
["src/nvim/spell.c", ["      dumpflags |= DUMPFLAG_ICASE;", "    else {", "      n = captype(pat, NULL);"], "readability/braces"]
["src/nvim/spell.c", ["      n = captype(pat, NULL);", "      if (n == WF_ONECAP)", "        dumpflags |= DUMPFLAG_ONECAP;"], "readability/braces"]
["src/nvim/spell.c", ["        dumpflags |= DUMPFLAG_ONECAP;", "      else if (n == WF_ALLCAP", "               && (int)STRLEN(pat) > mb_ptr2len(pat)"], "readability/braces"]
["src/nvim/spell.c", ["  // regions or none at all.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["    if (p[0] != 0) {", "      if (region_names == NULL)             // first language with regions", "        region_names = p;"], "readability/braces"]
["src/nvim/spell.c", ["        region_names = p;", "      else if (STRCMP(region_names, p) != 0) {", "        do_region = false;                  // region names are different"], "readability/braces"]
["src/nvim/spell.c", ["    }", "  } else", "    do_region = false;"], "readability/braces"]
["src/nvim/spell.c", ["  // Loop over all files loaded for the entries in 'spelllang'.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["    slang = lp->lp_slang;", "    if (slang->sl_fbyts == NULL)            // reloading failed", "      continue;"], "readability/braces"]
["src/nvim/spell.c", ["    // parts of the tree that match \"pat\".", "    if (pat != NULL && slang->sl_pbyts == NULL)", "      patlen = (int)STRLEN(pat);"], "readability/braces"]
["src/nvim/spell.c", ["      patlen = (int)STRLEN(pat);", "    else", "      patlen = -1;"], "readability/braces"]
["src/nvim/spell.c", ["    // round 2: keep-case tree", "    for (round = 1; round <= 2; ++round) {", "      if (round == 1) {"], "readability/increment"]
["src/nvim/spell.c", ["      }", "      if (byts == NULL)", "        continue;                       // array is empty"], "readability/braces"]
["src/nvim/spell.c", ["          // Done all bytes at this node, go up one level.", "          --depth;", "          line_breakcheck();"], "readability/increment"]
["src/nvim/spell.c", ["          n = arridx[depth] + curi[depth];", "          ++curi[depth];", "          c = byts[n];"], "readability/increment"]
["src/nvim/spell.c", ["              word[depth] = NUL;", "              if (!do_region)", "                flags &= ~WF_REGION;"], "readability/braces"]
["src/nvim/spell.c", ["                dump_word(slang, word, pat, dir,", "                    dumpflags, flags, lnum);", "                if (pat == NULL)"], "whitespace/alignment"]
["src/nvim/spell.c", ["                    dumpflags, flags, lnum);", "                if (pat == NULL)", "                  ++lnum;"], "readability/braces"]
["src/nvim/spell.c", ["                if (pat == NULL)", "                  ++lnum;", "              }"], "readability/increment"]
["src/nvim/spell.c", ["              // Apply the prefix, if there is one.", "              if (c != 0)", "                lnum = dump_prefixes(slang, word, pat, dir,"], "readability/braces"]
["src/nvim/spell.c", ["                lnum = dump_prefixes(slang, word, pat, dir,", "                    dumpflags, flags, lnum);", "            }"], "whitespace/alignment"]
["src/nvim/spell.c", ["            assert(depth >= 0);", "            if (depth <= patlen", "                && mb_strnicmp(word, pat, (size_t)depth) != 0)"], "readability/braces"]
["src/nvim/spell.c", ["                && mb_strnicmp(word, pat, (size_t)depth) != 0)", "              --depth;", "          }"], "readability/increment"]
["src/nvim/spell.c", ["", "  if (dumpflags & DUMPFLAG_ONECAP)", "    flags |= WF_ONECAP;"], "readability/braces"]
["src/nvim/spell.c", ["    flags |= WF_ONECAP;", "  if (dumpflags & DUMPFLAG_ALLCAP)", "    flags |= WF_ALLCAP;"], "readability/braces"]
["src/nvim/spell.c", ["    p = word;", "    if ((dumpflags & DUMPFLAG_KEEPCASE)", "        && ((captype(word, NULL) & WF_KEEPCAP) == 0"], "readability/braces"]
["src/nvim/spell.c", ["        vim_snprintf((char *)IObuff, IOSIZE, \"%s\\t%d\",", "            tw, HI2WC(hi)->wc_count);", "        p = IObuff;"], "whitespace/alignment"]
["src/nvim/spell.c", ["static linenr_T", "dump_prefixes (", "    slang_T *slang,"], "whitespace/parens"]
["src/nvim/spell.c", ["        // Done all bytes at this node, go up one level.", "        --depth;", "        line_breakcheck();"], "readability/increment"]
["src/nvim/spell.c", ["        n += curi[depth];", "        ++curi[depth];", "        c = byts[n];"], "readability/increment"]
["src/nvim/spell.c", ["          // End of prefix, find out how many IDs there are.", "          for (i = 1; i < len; ++i)", "            if (byts[n + i] != 0)"], "readability/braces"]
["src/nvim/spell.c", ["          // End of prefix, find out how many IDs there are.", "          for (i = 1; i < len; ++i)", "            if (byts[n + i] != 0)"], "readability/increment"]
["src/nvim/spell.c", ["          for (i = 1; i < len; ++i)", "            if (byts[n + i] != 0)", "              break;"], "readability/braces"]
["src/nvim/spell.c", ["            dump_word(slang, prefix, pat, dir, dumpflags,", "                (c & WF_RAREPFX) ? (flags | WF_RARE)", "                : flags, lnum);"], "whitespace/alignment"]
["src/nvim/spell.c", ["                (c & WF_RAREPFX) ? (flags | WF_RARE)", "                : flags, lnum);", "            if (lnum != 0)"], "whitespace/alignment"]
["src/nvim/spell.c", ["                : flags, lnum);", "            if (lnum != 0)", "              ++lnum;"], "readability/braces"]
["src/nvim/spell.c", ["            if (lnum != 0)", "              ++lnum;", "          }"], "readability/increment"]
["src/nvim/spell.c", ["            c = valid_word_prefix(i, n, flags, word_up, slang,", "                true);", "            if (c != 0) {"], "whitespace/alignment"]
["src/nvim/spell.c", ["              dump_word(slang, prefix, pat, dir, dumpflags,", "                  (c & WF_RAREPFX) ? (flags | WF_RARE)", "                  : flags, lnum);"], "whitespace/alignment"]
["src/nvim/spell.c", ["                  (c & WF_RAREPFX) ? (flags | WF_RARE)", "                  : flags, lnum);", "              if (lnum != 0)"], "whitespace/alignment"]
["src/nvim/spell.c", ["                  : flags, lnum);", "              if (lnum != 0)", "                ++lnum;"], "readability/braces"]
["src/nvim/spell.c", ["              if (lnum != 0)", "                ++lnum;", "            }"], "readability/increment"]
["src/nvim/spell_defs.h", ["  idx_T ts_arridx;              // index in tree array, start of node", "  short ts_curi;                // index in list of child nodes", "  char_u ts_fidx;               // index in fword[], case-folded bad word"], "runtime/int"]
["src/nvim/spellfile.c", ["#ifndef UNIX            // it's in os/unix_defs.h for Unix", "# include <time.h>      // for time_t", "#endif"], "build/include_order"]
["src/nvim/spellfile.c", ["  uint16_t wn_flags;            // WF_ flags", "  short wn_region;              // region mask", ""], "runtime/int"]
["src/nvim/spellfile.c", ["  char buf[VIMSPELLMAGICL];", "  SPELL_READ_BYTES(buf, VIMSPELLMAGICL, fd, ;);", "  if (memcmp(buf, VIMSPELLMAGIC, VIMSPELLMAGICL) != 0) {"], "whitespace/newline"]
["src/nvim/spellfile.c", ["slang_T *", "spell_load_file (", "    char_u *fname,"], "whitespace/parens"]
["src/nvim/spellfile.c", ["  if (fd == NULL) {", "    if (!silent)", "      EMSG2(_(e_notopen), fname);"], "readability/braces"]
["src/nvim/spellfile.c", ["      EMSG2(_(e_notopen), fname);", "    else if (p_verbose > 2) {", "      verbose_enter();"], "readability/braces"]
["src/nvim/spellfile.c", ["    lp->sl_add = strstr((char *)path_tail(fname), SPL_FNAME_ADD) != NULL;", "  } else", "    lp = old_lp;"], "readability/braces"]
["src/nvim/spellfile.c", ["    n = getc(fd);                           // <sectionID> or <sectionend>", "    if (n == SN_END)", "      break;"], "readability/braces"]
["src/nvim/spellfile.c", ["    len = get4c(fd);                                    // <sectionlen>", "    if (len < 0)", "      goto truncerr;"], "readability/braces"]
["src/nvim/spellfile.c", ["      lp->sl_info = READ_STRING(fd, len);               // <infotext>", "      if (lp->sl_info == NULL)", "        goto endFAIL;"], "readability/braces"]
["src/nvim/spellfile.c", ["      lp->sl_midword = READ_STRING(fd, len);            // <midword>", "      if (lp->sl_midword == NULL)", "        goto endFAIL;"], "readability/braces"]
["src/nvim/spellfile.c", ["      p = READ_STRING(fd, len);                         // <mapstr>", "      if (p == NULL)", "        goto endFAIL;"], "readability/braces"]
["src/nvim/spellfile.c", ["      lp->sl_syllable = READ_STRING(fd, len);           // <syllable>", "      if (lp->sl_syllable == NULL)", "        goto endFAIL;"], "readability/braces"]
["src/nvim/spellfile.c", ["        goto endFAIL;", "      if (init_syl_tab(lp) == FAIL)", "        goto endFAIL;"], "readability/braces"]
["src/nvim/spellfile.c", ["      }", "      while (--len >= 0)", "        if (getc(fd) < 0)"], "readability/braces"]
["src/nvim/spellfile.c", ["      while (--len >= 0)", "        if (getc(fd) < 0)", "          goto truncerr;"], "readability/braces"]
["src/nvim/spellfile.c", ["    }", "    if (res == SP_OTHERERROR)", "      goto endFAIL;"], "readability/braces"]
["src/nvim/spellfile.c", ["endFAIL:", "  if (lang != NULL)", "    // truncating the name signals the error to spell_load_lang()"], "readability/braces"]
["src/nvim/spellfile.c", ["    *lang = NUL;", "  if (lp != NULL && old_lp == NULL)", "    slang_free(lp);"], "readability/braces"]
["src/nvim/spellfile.c", ["endOK:", "  if (fd != NULL)", "    fclose(fd);"], "readability/braces"]
["src/nvim/spellfile.c", ["      idxs[arridx[depth]] = wordcount[depth];", "      if (depth > 0)", "        wordcount[depth - 1] += wordcount[depth];"], "readability/braces"]
["src/nvim/spellfile.c", ["", "      --depth;", "      fast_breakcheck();"], "readability/increment"]
["src/nvim/spellfile.c", ["      n = arridx[depth] + curi[depth];", "      ++curi[depth];", ""], "readability/increment"]
["src/nvim/spellfile.c", ["        // End of word, count it.", "        ++wordcount[depth];", ""], "readability/increment"]
["src/nvim/spellfile.c", ["        while (byts[n + 1] == 0) {", "          ++n;", "          ++curi[depth];"], "readability/increment"]
["src/nvim/spellfile.c", ["          ++n;", "          ++curi[depth];", "        }"], "readability/increment"]
["src/nvim/spellfile.c", ["        // Normal char, go one level deeper to count the words.", "        ++depth;", "        arridx[depth] = idxs[n];"], "readability/increment"]
["src/nvim/spellfile.c", ["  // Do this for all languages that support sound folding.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spellfile.c", ["      // <SUGHEADER>: <fileID> <versionnr> <timestamp>", "      for (i = 0; i < VIMSUGMAGICL; ++i)", "        buf[i] = getc(fd);                              // <fileID>"], "readability/braces"]
["src/nvim/spellfile.c", ["      // <SUGHEADER>: <fileID> <versionnr> <timestamp>", "      for (i = 0; i < VIMSUGMAGICL; ++i)", "        buf[i] = getc(fd);                              // <fileID>"], "readability/increment"]
["src/nvim/spellfile.c", ["        EMSG2(_(\"E778: This does not look like a .sug file: %s\"),", "            slang->sl_fname);", "        goto nextone;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["        EMSG2(_(\"E779: Old .sug file, needs to be updated: %s\"),", "            slang->sl_fname);", "        goto nextone;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["        EMSG2(_(\"E780: .sug file is for newer version of Vim: %s\"),", "            slang->sl_fname);", "        goto nextone;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["        EMSG2(_(\"E781: .sug file doesn't match .spl file: %s\"),", "            slang->sl_fname);", "        goto nextone;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["        EMSG2(_(\"E782: error while reading .sug file: %s\"),", "            slang->sl_fname);", "        slang_clear_sug(slang);"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["      wcount = get4c(fd);", "      if (wcount < 0)", "        goto someerror;"], "readability/braces"]
["src/nvim/spellfile.c", ["      ga_init(&ga, 1, 100);", "      for (wordnr = 0; wordnr < wcount; ++wordnr) {", "        ga.ga_len = 0;"], "readability/increment"]
["src/nvim/spellfile.c", ["          GA_APPEND(char_u, &ga, c);", "          if (c == NUL)", "            break;"], "readability/braces"]
["src/nvim/spellfile.c", ["nextone:", "      if (fd != NULL)", "        fclose(fd);"], "readability/braces"]
["src/nvim/spellfile.c", ["  *cntp = cnt;", "  if (cnt == 0)", "    return NULL;            // nothing to read, return NULL"], "readability/braces"]
["src/nvim/spellfile.c", ["  str = READ_STRING(fd, cnt);", "  if (str == NULL)", "    *cntp = SP_OTHERERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["  }", "  SPELL_READ_NONNUL_BYTES((char *)lp->sl_regions, (size_t)len, fd, ;);", "  lp->sl_regions[len] = NUL;"], "whitespace/newline"]
["src/nvim/spellfile.c", ["  flags = read_cnt_string(fd, 1, &flagslen);", "  if (flagslen < 0)", "    return flagslen;"], "readability/braces"]
["src/nvim/spellfile.c", ["  // Set the word-char flags and fill SPELL_ISUPPER() table.", "  if (flags != NULL && fol != NULL)", "    set_spell_charflags(flags, flagslen, fol);"], "readability/braces"]
["src/nvim/spellfile.c", ["  // When <charflagslen> is zero then <fcharlen> must also be zero.", "  if ((flags == NULL) != (fol == NULL))", "    return SP_FORMERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["      buf[0] = '^';  // always match at one position only", "      SPELL_READ_NONNUL_BYTES(buf + 1, (size_t)n, fd, ;);", "      buf[n + 1] = NUL;"], "whitespace/newline"]
["src/nvim/spellfile.c", ["  cnt = get2c(fd);                                      // <repcount>", "  if (cnt < 0)", "    return SP_TRUNCERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["  // <rep> : <repfromlen> <repfrom> <reptolen> <repto>", "  for (; gap->ga_len < cnt; ++gap->ga_len) {", "    int c;"], "readability/increment"]
["src/nvim/spellfile.c", ["    ftp->ft_from = read_cnt_string(fd, 1, &c);", "    if (c < 0)", "      return c;"], "readability/braces"]
["src/nvim/spellfile.c", ["      return c;", "    if (c == 0)", "      return SP_FORMERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["      xfree(ftp->ft_from);", "      if (c < 0)", "        return c;"], "readability/braces"]
["src/nvim/spellfile.c", ["  // Fill the first-index table.", "  for (int i = 0; i < 256; ++i) {", "    first[i] = -1;"], "readability/increment"]
["src/nvim/spellfile.c", ["  }", "  for (int i = 0; i < gap->ga_len; ++i) {", "    ftp = &((fromto_T *)gap->ga_data)[i];"], "readability/increment"]
["src/nvim/spellfile.c", ["    ftp = &((fromto_T *)gap->ga_data)[i];", "    if (first[*ftp->ft_from] == -1)", "      first[*ftp->ft_from] = i;"], "readability/braces"]
["src/nvim/spellfile.c", ["  cnt = get2c(fd);                              // <salcount>", "  if (cnt < 0)", "    return SP_TRUNCERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["    ccnt = getc(fd);                            // <salfromlen>", "    if (ccnt < 0)", "      return SP_TRUNCERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["    int i = 0;", "    for (; i < ccnt; ++i) {", "      c = getc(fd);                             // <salfrom>"], "readability/increment"]
["src/nvim/spellfile.c", ["      c = getc(fd);                             // <salfrom>", "      if (vim_strchr((char_u *)\"0123456789(-<^$\", c) != NULL)", "        break;"], "readability/braces"]
["src/nvim/spellfile.c", ["      smp->sm_oneof = p;", "      for (++i; i < ccnt; ++i) {", "        c = getc(fd);                           // <salfrom>"], "readability/increment"]
["src/nvim/spellfile.c", ["        c = getc(fd);                           // <salfrom>", "        if (c == ')')", "          break;"], "readability/braces"]
["src/nvim/spellfile.c", ["      *p++ = NUL;", "      if (++i < ccnt)", "        c = getc(fd);"], "readability/braces"]
["src/nvim/spellfile.c", ["        c = getc(fd);", "    } else", "      smp->sm_oneof = NULL;"], "readability/braces"]
["src/nvim/spellfile.c", ["    // Read one word at a time.", "    for (i = 0;; ++i) {", "      c = getc(fd);"], "readability/increment"]
["src/nvim/spellfile.c", ["      c = getc(fd);", "      if (c == EOF)", "        return SP_TRUNCERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["      word[i] = c;", "      if (word[i] == NUL)", "        break;"], "readability/braces"]
["src/nvim/spellfile.c", ["        break;", "      if (i == MAXWLEN - 1)", "        return SP_FORMERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["  from = read_cnt_string(fd, 2, &cnt);", "  if (cnt < 0)", "    return cnt;"], "readability/braces"]
["src/nvim/spellfile.c", ["  // Store the info in slang->sl_sal and/or slang->sl_sal_first.", "  if (from != NULL && to != NULL)", "    res = set_sofo(slang, from, to);"], "readability/braces"]
["src/nvim/spellfile.c", ["    res = set_sofo(slang, from, to);", "  else if (from != NULL || to != NULL)", "    res = SP_FORMERROR;        // only one of two strings is an error"], "readability/braces"]
["src/nvim/spellfile.c", ["    res = SP_FORMERROR;        // only one of two strings is an error", "  else", "    res = 0;"], "readability/braces"]
["src/nvim/spellfile.c", ["", "  if (todo < 2)", "    return SP_FORMERROR;        // need at least two bytes"], "readability/braces"]
["src/nvim/spellfile.c", ["", "  --todo;", "  c = getc(fd);                                         // <compmax>"], "readability/increment"]
["src/nvim/spellfile.c", ["  c = getc(fd);                                         // <compmax>", "  if (c < 2)", "    c = MAXWLEN;"], "readability/braces"]
["src/nvim/spellfile.c", ["", "  --todo;", "  c = getc(fd);                                         // <compminlen>"], "readability/increment"]
["src/nvim/spellfile.c", ["  c = getc(fd);                                         // <compminlen>", "  if (c < 1)", "    c = 0;"], "readability/braces"]
["src/nvim/spellfile.c", ["", "  --todo;", "  c = getc(fd);                                         // <compsylmax>"], "readability/increment"]
["src/nvim/spellfile.c", ["  c = getc(fd);                                         // <compsylmax>", "  if (c < 1)", "    c = MAXWLEN;"], "readability/braces"]
["src/nvim/spellfile.c", ["  c = getc(fd);                                         // <compoptions>", "  if (c != 0)", "    ungetc(c, fd);          // be backwards compatible with Vim 7.0b"], "readability/braces"]
["src/nvim/spellfile.c", ["    ungetc(c, fd);          // be backwards compatible with Vim 7.0b", "  else {", "    --todo;"], "readability/braces"]
["src/nvim/spellfile.c", ["    ungetc(c, fd);          // be backwards compatible with Vim 7.0b", "  else {", "    --todo;"], "readability/braces"]
["src/nvim/spellfile.c", ["  else {", "    --todo;", "    c = getc(fd);           // only use the lower byte for now"], "readability/increment"]
["src/nvim/spellfile.c", ["    c = getc(fd);           // only use the lower byte for now", "    --todo;", "    slang->sl_compoptions = c;"], "readability/increment"]
["src/nvim/spellfile.c", ["      // <comppatlen> <comppattext>", "      if (cnt < 0)", "        return cnt;"], "readability/braces"]
["src/nvim/spellfile.c", ["  }", "  if (todo < 0)", "    return SP_FORMERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["      // [abc] item set \"atstart\" to 2 and copy up to the ']'.", "      if (c == '[')", "        atstart = 2;"], "readability/braces"]
["src/nvim/spellfile.c", ["        atstart = 2;", "      else if (c == ']')", "        atstart = 0;"], "readability/braces"]
["src/nvim/spellfile.c", ["        atstart = 0;", "      else {", "        if (!byte_in_str(slang->sl_compstartflags, c)) {"], "readability/braces"]
["src/nvim/spellfile.c", ["        atstart = 0;", "      else {", "        if (!byte_in_str(slang->sl_compstartflags, c)) {"], "readability/braces"]
["src/nvim/spellfile.c", ["        }", "        if (atstart == 1)", "          atstart = 0;"], "readability/braces"]
["src/nvim/spellfile.c", ["        crp = NULL;", "      } else", "        *crp++ = c;"], "readability/braces"]
["src/nvim/spellfile.c", ["", "  if (crp != NULL)", "    *crp = NUL;"], "readability/braces"]
["src/nvim/spellfile.c", ["  xfree(pat);", "  if (slang->sl_compprog == NULL)", "    return SP_FORMERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["  sfirst = lp->sl_sal_first;", "  for (int i = 0; i < 256; ++i) {", "    sfirst[i] = -1;"], "readability/increment"]
["src/nvim/spellfile.c", ["static int", "spell_read_tree (", "    FILE *fd,"], "whitespace/parens"]
["src/nvim/spellfile.c", ["    idx = read_tree_node(fd, bp, ip, len, 0, prefixtree, prefixcnt);", "    if (idx < 0)", "      return idx;"], "readability/braces"]
["src/nvim/spellfile.c", ["static idx_T", "read_tree_node (", "    FILE *fd,"], "whitespace/parens"]
["src/nvim/spellfile.c", ["  len = getc(fd);                                       // <siblingcount>", "  if (len <= 0)", "    return SP_TRUNCERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["", "  if (startidx + len >= maxidx)", "    return SP_FORMERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["  // Read the byte values, flag/region bytes and shared indexes.", "  for (i = 1; i <= len; ++i) {", "    c = getc(fd);                                       // <byte>"], "readability/increment"]
["src/nvim/spellfile.c", ["    c = getc(fd);                                       // <byte>", "    if (c < 0)", "      return SP_TRUNCERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["          // shifted up 24 bits.", "          if (c == BY_FLAGS)", "            c = getc(fd) << 24;                         // <pflags>"], "readability/braces"]
["src/nvim/spellfile.c", ["            c = getc(fd) << 24;                         // <pflags>", "          else", "            c = 0;"], "readability/braces"]
["src/nvim/spellfile.c", ["          n = get2c(fd);                                // <prefcondnr>", "          if (n >= maxprefcondnr)", "            return SP_FORMERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["          c = getc(fd);                                 // <flags>", "          if (c2 == BY_FLAGS2)", "            c = (getc(fd) << 8) + c;                    // <flags2>"], "readability/braces"]
["src/nvim/spellfile.c", ["            c = (getc(fd) << 8) + c;                    // <flags2>", "          if (c & WF_REGION)", "            c = (getc(fd) << 16) + c;                   // <region>"], "readability/braces"]
["src/nvim/spellfile.c", ["            c = (getc(fd) << 16) + c;                   // <region>", "          if (c & WF_AFX)", "            c = (getc(fd) << 24) + c;                   // <affixID>"], "readability/braces"]
["src/nvim/spellfile.c", ["        c = 0;", "      } else { // c == BY_INDEX", "        // <nodeidx>"], "whitespace/comments"]
["src/nvim/spellfile.c", ["        n = get3c(fd);", "        if (n < 0 || n >= maxidx)", "          return SP_FORMERROR;"], "readability/braces"]
["src/nvim/spellfile.c", ["  // remove SHARED_MASK)", "  for (i = 1; i <= len; ++i)", "    if (byts[startidx + i] != 0) {"], "readability/braces"]
["src/nvim/spellfile.c", ["  // remove SHARED_MASK)", "  for (i = 1; i <= len; ++i)", "    if (byts[startidx + i] != 0) {"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (byts[startidx + i] != 0) {", "      if (idxs[startidx + i] & SHARED_MASK)", "        idxs[startidx + i] &= ~SHARED_MASK;"], "readability/braces"]
["src/nvim/spellfile.c", ["        idxs[startidx + i] &= ~SHARED_MASK;", "      else {", "        idxs[startidx + i] = idx;"], "readability/braces"]
["src/nvim/spellfile.c", ["        idxs[startidx + i] &= ~SHARED_MASK;", "      else {", "        idxs[startidx + i] = idx;"], "readability/braces"]
["src/nvim/spellfile.c", ["        idx = read_tree_node(fd, byts, idxs, maxidx, idx,", "            prefixtree, maxprefcondnr);", "        if (idx < 0)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["            prefixtree, maxprefcondnr);", "        if (idx < 0)", "          break;"], "readability/braces"]
["src/nvim/spellfile.c", ["static void", "spell_reload_one (", "    char_u *fname,"], "whitespace/parens"]
["src/nvim/spellfile.c", ["      slang_clear(slang);", "      if (spell_load_file(fname, NULL, slang, false) == NULL)", "        // reloading failed, clear the language"], "readability/braces"]
["src/nvim/spellfile.c", ["  // 'spelllang' to load it now.", "  if (added_word && !didit)", "    did_set_spelllang(curwin);"], "readability/braces"]
["src/nvim/spellfile.c", ["", "  if (!ascii_isdigit(*p))", "    return FAIL;"], "readability/braces"]
["src/nvim/spellfile.c", ["#define PRINTSOME(l, depth, fmt, a1, a2) vim_snprintf(l + depth * PRINTWIDTH, \\", "    PRINTLINESIZE - PRINTWIDTH * depth, fmt, a1, a2)", ""], "whitespace/alignment"]
["src/nvim/spellfile.c", ["  for (np = node; np != NULL; np = np->wn_sibling) {", "    np->wn_u1.index = FALSE;", "    spell_clear_flags(np->wn_child);"], "readability/bool"]
["src/nvim/spellfile.c", ["  } else {", "    node->wn_u1.index = TRUE;", ""], "readability/bool"]
["src/nvim/spellfile.c", ["    if (node->wn_byte != NUL) {", "      if (node->wn_child != NULL)", "        PRINTSOME(line1, depth, \" %c -> \", node->wn_byte, 0);"], "readability/braces"]
["src/nvim/spellfile.c", ["        PRINTSOME(line1, depth, \" %c -> \", node->wn_byte, 0);", "      else", "        // Cannot happen?"], "readability/braces"]
["src/nvim/spellfile.c", ["        PRINTSOME(line1, depth, \" %c ???\", node->wn_byte, 0);", "    } else", "      PRINTSOME(line1, depth, \" $    \", 0, 0);"], "readability/braces"]
["src/nvim/spellfile.c", ["", "    if (node->wn_sibling != NULL)", "      PRINTSOME(line3, depth, \" |    \", 0, 0);"], "readability/braces"]
["src/nvim/spellfile.c", ["      PRINTSOME(line3, depth, \" |    \", 0, 0);", "    else", "      PRINTSOME(line3, depth, \"      \", 0, 0);"], "readability/braces"]
["src/nvim/spellfile.c", ["    // do the children", "    if (node->wn_byte != NUL && node->wn_child != NULL)", "      spell_print_node(node->wn_child, depth + 1);"], "readability/braces"]
["src/nvim/spellfile.c", ["", "#endif // SPELL_PRINTTREE", ""], "whitespace/comments"]
["src/nvim/spellfile.c", ["    line_breakcheck();", "    ++lnum;", ""], "readability/increment"]
["src/nvim/spellfile.c", ["    // Skip comment lines.", "    if (*rline == '#')", "      continue;"], "readability/braces"]
["src/nvim/spellfile.c", ["    for (p = line;; ) {", "      while (*p != NUL && *p <= ' ')        // skip white space and CR/NL", "        ++p;"], "readability/braces"]
["src/nvim/spellfile.c", ["      while (*p != NUL && *p <= ' ')        // skip white space and CR/NL", "        ++p;", "      if (*p == NUL)"], "readability/increment"]
["src/nvim/spellfile.c", ["        ++p;", "      if (*p == NUL)", "        break;"], "readability/braces"]
["src/nvim/spellfile.c", ["        break;", "      if (itemcnt == MAXITEMCNT)            // too many items", "        break;"], "readability/braces"]
["src/nvim/spellfile.c", ["      // A few items have arbitrary text argument, don't split them.", "      if (itemcnt == 2 && spell_info_item(items[0]))", "        while (*p >= ' ' || *p == TAB)            // skip until CR/NL"], "readability/braces"]
["src/nvim/spellfile.c", ["      if (itemcnt == 2 && spell_info_item(items[0]))", "        while (*p >= ' ' || *p == TAB)            // skip until CR/NL", "          ++p;"], "readability/braces"]
["src/nvim/spellfile.c", ["        while (*p >= ' ' || *p == TAB)            // skip until CR/NL", "          ++p;", "      else"], "readability/increment"]
["src/nvim/spellfile.c", ["          ++p;", "      else", "        while (*p > ' ')            // skip until white space or CR/NL"], "readability/braces"]
["src/nvim/spellfile.c", ["      else", "        while (*p > ' ')            // skip until white space or CR/NL", "          ++p;"], "readability/braces"]
["src/nvim/spellfile.c", ["        while (*p > ' ')            // skip until white space or CR/NL", "          ++p;", "      if (*p == NUL)"], "readability/increment"]
["src/nvim/spellfile.c", ["          ++p;", "      if (*p == NUL)", "        break;"], "readability/braces"]
["src/nvim/spellfile.c", ["        aff->af_enc = enc_canonize(items[1]);", "        if (!spin->si_ascii", "            && convert_setup(&spin->si_conv, aff->af_enc,"], "readability/braces"]
["src/nvim/spellfile.c", ["            && convert_setup(&spin->si_conv, aff->af_enc,", "                p_enc) == FAIL)", "          smsg(_(\"Conversion in %s not supported: from %s to %s\"),"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["            && convert_setup(&spin->si_conv, aff->af_enc,", "                p_enc) == FAIL)", "          smsg(_(\"Conversion in %s not supported: from %s to %s\"),"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                 && aff->af_flagtype == AFT_CHAR) {", "        if (STRCMP(items[1], \"long\") == 0)", "          aff->af_flagtype = AFT_LONG;"], "readability/braces"]
["src/nvim/spellfile.c", ["          aff->af_flagtype = AFT_LONG;", "        else if (STRCMP(items[1], \"num\") == 0)", "          aff->af_flagtype = AFT_NUM;"], "readability/braces"]
["src/nvim/spellfile.c", ["          aff->af_flagtype = AFT_NUM;", "        else if (STRCMP(items[1], \"caplong\") == 0)", "          aff->af_flagtype = AFT_CAPLONG;"], "readability/braces"]
["src/nvim/spellfile.c", ["          aff->af_flagtype = AFT_CAPLONG;", "        else", "          smsg(_(\"Invalid value for FLAG in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["               fname, lnum, items[1]);", "        if (aff->af_rare != 0", "            || aff->af_keepcase != 0"], "readability/braces"]
["src/nvim/spellfile.c", ["      }", "      // TODO: remove \"RAR\" later", "      else if ((is_aff_rule(items, itemcnt, \"RAR\", 2)"], "readability/todo"]
["src/nvim/spellfile.c", ["      // TODO: remove \"RAR\" later", "      else if ((is_aff_rule(items, itemcnt, \"RAR\", 2)", "                || is_aff_rule(items, itemcnt, \"RARE\", 2))"], "whitespace/newline"]
["src/nvim/spellfile.c", ["        aff->af_rare = affitem2flag(aff->af_flagtype, items[1],", "            fname, lnum);", "      }"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["      }", "      // TODO: remove \"KEP\" later", "      else if ((is_aff_rule(items, itemcnt, \"KEP\", 2)"], "readability/todo"]
["src/nvim/spellfile.c", ["      // TODO: remove \"KEP\" later", "      else if ((is_aff_rule(items, itemcnt, \"KEP\", 2)", "                || is_aff_rule(items, itemcnt, \"KEEPCASE\", 2))"], "whitespace/newline"]
["src/nvim/spellfile.c", ["        aff->af_keepcase = affitem2flag(aff->af_flagtype, items[1],", "            fname, lnum);", "      } else if ((is_aff_rule(items, itemcnt, \"BAD\", 2)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["        aff->af_bad = affitem2flag(aff->af_flagtype, items[1],", "            fname, lnum);", "      } else if (is_aff_rule(items, itemcnt, \"NEEDAFFIX\", 2)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["        aff->af_needaffix = affitem2flag(aff->af_flagtype, items[1],", "            fname, lnum);", "      } else if (is_aff_rule(items, itemcnt, \"CIRCUMFIX\", 2)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["        aff->af_circumfix = affitem2flag(aff->af_flagtype, items[1],", "            fname, lnum);", "      } else if (is_aff_rule(items, itemcnt, \"NOSUGGEST\", 2)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["        aff->af_nosuggest = affitem2flag(aff->af_flagtype, items[1],", "            fname, lnum);", "      } else if ((is_aff_rule(items, itemcnt, \"NEEDCOMPOUND\", 2)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["        aff->af_needcomp = affitem2flag(aff->af_flagtype, items[1],", "            fname, lnum);", "      } else if (is_aff_rule(items, itemcnt, \"COMPOUNDROOT\", 2)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["        aff->af_comproot = affitem2flag(aff->af_flagtype, items[1],", "            fname, lnum);", "      } else if (is_aff_rule(items, itemcnt, \"COMPOUNDFORBIDFLAG\", 2)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["        aff->af_compforbid = affitem2flag(aff->af_flagtype, items[1],", "            fname, lnum);", "        if (aff->af_pref.ht_used > 0)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["            fname, lnum);", "        if (aff->af_pref.ht_used > 0)", "          smsg(_(\"Defining COMPOUNDFORBIDFLAG after PFX item may give wrong results in %s line %d\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["        if (aff->af_pref.ht_used > 0)", "          smsg(_(\"Defining COMPOUNDFORBIDFLAG after PFX item may give wrong results in %s line %d\"),", "               fname, lnum);"], "whitespace/line_length"]
["src/nvim/spellfile.c", ["        aff->af_comppermit = affitem2flag(aff->af_flagtype, items[1],", "            fname, lnum);", "        if (aff->af_pref.ht_used > 0)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["            fname, lnum);", "        if (aff->af_pref.ht_used > 0)", "          smsg(_(\"Defining COMPOUNDPERMITFLAG after PFX item may give wrong results in %s line %d\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["        if (aff->af_pref.ht_used > 0)", "          smsg(_(\"Defining COMPOUNDPERMITFLAG after PFX item may give wrong results in %s line %d\"),", "               fname, lnum);"], "whitespace/line_length"]
["src/nvim/spellfile.c", ["        // not COMPOUNDRULE mistyped.", "        if (atoi((char *)items[1]) == 0)", "          smsg(_(\"Wrong COMPOUNDRULES value in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["          l = (int)STRLEN(items[1]) + 1;", "          if (compflags != NULL)", "            l += (int)STRLEN(compflags) + 1;"], "readability/braces"]
["src/nvim/spellfile.c", ["        compmax = atoi((char *)items[1]);", "        if (compmax == 0)", "          smsg(_(\"Wrong COMPOUNDWORDMAX value in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["        compminlen = atoi((char *)items[1]);", "        if (compminlen == 0)", "          smsg(_(\"Wrong COMPOUNDMIN value in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["        compsylmax = atoi((char *)items[1]);", "        if (compsylmax == 0)", "          smsg(_(\"Wrong COMPOUNDSYLMAX value in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["      } else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDPATTERN\", 2))   {", "        if (atoi((char *)items[1]) == 0)", "          smsg(_(\"Wrong CHECKCOMPOUNDPATTERN value in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["        // Only add the couple if it isn't already there.", "        for (i = 0; i < gap->ga_len - 1; i += 2)", "          if (STRCMP(((char_u **)(gap->ga_data))[i], items[1]) == 0"], "readability/braces"]
["src/nvim/spellfile.c", ["        for (i = 0; i < gap->ga_len - 1; i += 2)", "          if (STRCMP(((char_u **)(gap->ga_data))[i], items[1]) == 0", "              && STRCMP(((char_u **)(gap->ga_data))[i + 1],"], "readability/braces"]
["src/nvim/spellfile.c", ["              && STRCMP(((char_u **)(gap->ga_data))[i + 1],", "                  items[2]) == 0)", "            break;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["              && STRCMP(((char_u **)(gap->ga_data))[i + 1],", "                  items[2]) == 0)", "            break;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["", "        if (*items[0] == 'P')", "          tp = &aff->af_pref;"], "readability/braces"]
["src/nvim/spellfile.c", ["          tp = &aff->af_pref;", "        else", "          tp = &aff->af_suff;"], "readability/braces"]
["src/nvim/spellfile.c", ["          cur_aff = HI2AH(hi);", "          if (cur_aff->ah_combine != (*items[2] == 'Y'))", "            smsg(_(\"Different combining flag in continued affix block in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["          if (cur_aff->ah_combine != (*items[2] == 'Y'))", "            smsg(_(\"Different combining flag in continued affix block in %s line %d: %s\"),", "                 fname, lnum, items[1]);"], "whitespace/line_length"]
["src/nvim/spellfile.c", ["                 fname, lnum, items[1]);", "          if (!cur_aff->ah_follows)", "            smsg(_(\"Duplicate affix in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["        if (itemcnt > lasti && STRCMP(items[lasti], \"S\") == 0) {", "          ++lasti;", "          cur_aff->ah_follows = true;"], "readability/increment"]
["src/nvim/spellfile.c", ["          cur_aff->ah_follows = true;", "        } else", "          cur_aff->ah_follows = false;"], "readability/braces"]
["src/nvim/spellfile.c", ["        // unless IGNOREEXTRA is used.  Hunspell uses a \"-\" item.", "        if (itemcnt > lasti", "            && !aff->af_ignoreextra"], "readability/braces"]
["src/nvim/spellfile.c", ["", "        if (STRCMP(items[2], \"Y\") != 0 && STRCMP(items[2], \"N\") != 0)", "          smsg(_(\"Expected Y or N in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["          smsg(_(\"Expected Y or N in %s line %d: %s\"),", "              fname, lnum, items[2]);", ""], "whitespace/alignment"]
["src/nvim/spellfile.c", ["            did_postpone_prefix = false;", "          } else", "            // Did use the ID in a previous block."], "readability/braces"]
["src/nvim/spellfile.c", ["        // Hunspell uses a \"-\" item.", "        if (itemcnt > lasti && *items[lasti] != '#'", "            && (STRCMP(items[lasti], \"-\") != 0"], "readability/braces"]
["src/nvim/spellfile.c", ["", "        if (STRCMP(items[2], \"0\") != 0)", "          aff_entry->ae_chop = getroom_save(spin, items[2]);"], "readability/braces"]
["src/nvim/spellfile.c", ["            aff_entry->ae_cond = getroom_save(spin, items[4]);", "            if (*items[0] == 'P')", "              sprintf((char *)buf, \"^%s\", items[4]);"], "readability/braces"]
["src/nvim/spellfile.c", ["            if (*items[0] == 'P')", "              sprintf((char *)buf, \"^%s\", items[4]);", "            else"], "runtime/printf"]
["src/nvim/spellfile.c", ["              sprintf((char *)buf, \"^%s\", items[4]);", "            else", "              sprintf((char *)buf, \"%s$\", items[4]);"], "readability/braces"]
["src/nvim/spellfile.c", ["            else", "              sprintf((char *)buf, \"%s$\", items[4]);", "            aff_entry->ae_prog = vim_regcomp(buf,"], "runtime/printf"]
["src/nvim/spellfile.c", ["            aff_entry->ae_prog = vim_regcomp(buf,", "                RE_MAGIC + RE_STRING + RE_STRICT);", "            if (aff_entry->ae_prog == NULL)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                RE_MAGIC + RE_STRING + RE_STRICT);", "            if (aff_entry->ae_prog == NULL)", "              smsg(_(\"Broken condition in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["                && aff_entry->ae_chop[(*mb_ptr2len)(", "                                        aff_entry->ae_chop)] == NUL", "                ) {"], "whitespace/indent"]
["src/nvim/spellfile.c", ["                && aff_entry->ae_chop[(*mb_ptr2len)(", "                                        aff_entry->ae_chop)] == NUL", "                ) {"], "whitespace/indent"]
["src/nvim/spellfile.c", ["                      sprintf((char *)buf, \"^%s\",", "                          aff_entry->ae_cond);", "                      vim_regfree(aff_entry->ae_prog);"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                    if (aff_entry->ae_cond != NULL) {", "                      sprintf((char *)buf, \"^%s\",", "                          aff_entry->ae_cond);"], "runtime/printf"]
["src/nvim/spellfile.c", ["              for (idx = spin->si_prefcond.ga_len - 1; idx >= 0;", "                   --idx) {", "                p = ((char_u **)spin->si_prefcond.ga_data)[idx];"], "readability/increment"]
["src/nvim/spellfile.c", ["                p = ((char_u **)spin->si_prefcond.ga_data)[idx];", "                if (str_equal(p, aff_entry->ae_cond))", "                  break;"], "readability/braces"]
["src/nvim/spellfile.c", ["              // Add the prefix to the prefix tree.", "              if (aff_entry->ae_add == NULL)", "                p = (char_u *)\"\";"], "readability/braces"]
["src/nvim/spellfile.c", ["                p = (char_u *)\"\";", "              else", "                p = aff_entry->ae_add;"], "readability/braces"]
["src/nvim/spellfile.c", ["              n = PFX_FLAGS;", "              if (!cur_aff->ah_combine)", "                n |= WFP_NC;"], "readability/braces"]
["src/nvim/spellfile.c", ["                n |= WFP_NC;", "              if (upper)", "                n |= WFP_UP;"], "readability/braces"]
["src/nvim/spellfile.c", ["                n |= WFP_UP;", "              if (aff_entry->ae_comppermit)", "                n |= WFP_COMPPERMIT;"], "readability/braces"]
["src/nvim/spellfile.c", ["                n |= WFP_COMPPERMIT;", "              if (aff_entry->ae_compforbid)", "                n |= WFP_COMPFORBID;"], "readability/braces"]
["src/nvim/spellfile.c", ["              tree_add_word(spin, p, spin->si_prefroot, n,", "                  idx, cur_aff->ah_newID);", "              did_postpone_prefix = true;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["            if (aff_todo == 0 && !did_postpone_prefix) {", "              --spin->si_newprefID;", "              cur_aff->ah_newID = 0;"], "readability/increment"]
["src/nvim/spellfile.c", ["                 || is_aff_rule(items, itemcnt, \"REPSAL\", 2)) {", "        /* Ignore REP/REPSAL count */;", "        if (!isdigit(*items[1]))"], "readability/old_style_comment"]
["src/nvim/spellfile.c", ["                 || is_aff_rule(items, itemcnt, \"REPSAL\", 2)) {", "        /* Ignore REP/REPSAL count */;", "        if (!isdigit(*items[1]))"], "whitespace/semicolon"]
["src/nvim/spellfile.c", ["        /* Ignore REP/REPSAL count */;", "        if (!isdigit(*items[1]))", "          smsg(_(\"Expected REP(SAL) count in %s line %d\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["        // # to detect mistakes.", "        if (itemcnt > 3 && items[3][0] != '#')", "          smsg(_(e_afftrailing), fname, lnum, items[3]);"], "readability/braces"]
["src/nvim/spellfile.c", ["          add_fromto(spin, items[0][3] == 'S'", "              ? &spin->si_repsal", "              : &spin->si_rep, items[1], items[2]);"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["              ? &spin->si_repsal", "              : &spin->si_rep, items[1], items[2]);", "        }"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["          found_map = true;", "          if (!isdigit(*items[1]))", "            smsg(_(\"Expected MAP count in %s line %d\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["      // Accept \"SAL from to\" and \"SAL from to  #comment\".", "      else if (is_aff_rule(items, itemcnt, \"SAL\", 3)) {", "        if (do_sal) {"], "whitespace/newline"]
["src/nvim/spellfile.c", ["          // Either one of the known keys or a from-to pair.", "          if (STRCMP(items[1], \"followup\") == 0)", "            spin->si_followup = sal_to_bool(items[2]);"], "readability/braces"]
["src/nvim/spellfile.c", ["            spin->si_followup = sal_to_bool(items[2]);", "          else if (STRCMP(items[1], \"collapse_result\") == 0)", "            spin->si_collapse = sal_to_bool(items[2]);"], "readability/braces"]
["src/nvim/spellfile.c", ["            spin->si_collapse = sal_to_bool(items[2]);", "          else if (STRCMP(items[1], \"remove_accents\") == 0)", "            spin->si_rem_accents = sal_to_bool(items[2]);"], "readability/braces"]
["src/nvim/spellfile.c", ["            spin->si_rem_accents = sal_to_bool(items[2]);", "          else", "            // when \"to\" is \"_\" it means empty"], "readability/braces"]
["src/nvim/spellfile.c", ["            add_fromto(spin, &spin->si_sal, items[1],", "                STRCMP(items[2], \"_\") == 0 ? (char_u *)\"\"", "                : items[2]);"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                STRCMP(items[2], \"_\") == 0 ? (char_u *)\"\"", "                : items[2]);", "        }"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["", "        for (i = 1; i < itemcnt; ++i) {", "          if (HASHITEM_EMPTY(hash_find(&spin->si_commonwords,"], "readability/increment"]
["src/nvim/spellfile.c", ["          if (HASHITEM_EMPTY(hash_find(&spin->si_commonwords,", "                      items[i]))) {", "            p = vim_strsave(items[i]);"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["        }", "      } else", "        smsg(_(\"Unrecognized or duplicate item in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["", "  if (compflags != NULL)", "    process_compflags(spin, aff, compflags);"], "readability/braces"]
["src/nvim/spellfile.c", ["  if (spin->si_newcompID < spin->si_newprefID) {", "    if (spin->si_newcompID == 127 || spin->si_newcompID == 255)", "      MSG(_(\"Too many postponed prefixes\"));"], "readability/braces"]
["src/nvim/spellfile.c", ["      MSG(_(\"Too many postponed prefixes\"));", "    else if (spin->si_newprefID == 0 || spin->si_newprefID == 127)", "      MSG(_(\"Too many compound flags\"));"], "readability/braces"]
["src/nvim/spellfile.c", ["      MSG(_(\"Too many compound flags\"));", "    else", "      MSG(_(\"Too many postponed prefixes and/or compound flags\"));"], "readability/braces"]
["src/nvim/spellfile.c", ["  if (sofofrom != NULL || sofoto != NULL) {", "    if (sofofrom == NULL || sofoto == NULL)", "      smsg(_(\"Missing SOFO%s line in %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["           sofofrom == NULL ? \"FROM\" : \"TO\", fname);", "    else if (!GA_EMPTY(&spin->si_sal))", "      smsg(_(\"Both SAL and SOFO lines in %s\"), fname);"], "readability/braces"]
["src/nvim/spellfile.c", ["      smsg(_(\"Both SAL and SOFO lines in %s\"), fname);", "    else {", "      aff_check_string(spin->si_sofofr, sofofrom, \"SOFOFROM\");"], "readability/braces"]
["src/nvim/spellfile.c", ["      smsg(_(\"Both SAL and SOFO lines in %s\"), fname);", "    else {", "      aff_check_string(spin->si_sofofr, sofofrom, \"SOFOFROM\");"], "readability/braces"]
["src/nvim/spellfile.c", ["  return aff;", "}", ""], "readability/fn_size"]
["src/nvim/spellfile.c", ["// a comment is following after item \"mincount\".", "static bool is_aff_rule(char_u **items, int itemcnt, char *rulename, int mincount)", "{"], "whitespace/line_length"]
["src/nvim/spellfile.c", ["        p = prevp;", "        if (flag == affile->af_comppermit)", "          entry->ae_comppermit = true;"], "readability/braces"]
["src/nvim/spellfile.c", ["          entry->ae_comppermit = true;", "        else", "          entry->ae_compforbid = true;"], "readability/braces"]
["src/nvim/spellfile.c", ["      }", "      if (affile->af_flagtype == AFT_NUM && *p == ',')", "        ++p;"], "readability/braces"]
["src/nvim/spellfile.c", ["      if (affile->af_flagtype == AFT_NUM && *p == ',')", "        ++p;", "    }"], "readability/increment"]
["src/nvim/spellfile.c", ["    }", "    if (*entry->ae_flags == NUL)", "      entry->ae_flags = NULL;           // nothing left"], "readability/braces"]
["src/nvim/spellfile.c", ["// returns zero for failure.", "static unsigned affitem2flag(int flagtype, char_u *item, char_u *fname, int lnum)", "{"], "whitespace/line_length"]
["src/nvim/spellfile.c", ["  if (res == 0) {", "    if (flagtype == AFT_NUM)", "      smsg(_(\"Flag is not a number in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["           fname, lnum, item);", "    else", "      smsg(_(\"Illegal flag in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["    if (!ascii_isdigit(**pp)) {", "      ++*pp;            // always advance, avoid getting stuck", "      return 0;"], "readability/increment"]
["src/nvim/spellfile.c", ["                                 && res >= 'A' && res <= 'Z')) {", "      if (**pp == NUL)", "        return 0;"], "readability/braces"]
["src/nvim/spellfile.c", ["// they fit in one byte.", "static void process_compflags(spellinfo_T *spin, afffile_T *aff, char_u *compflags)", "{"], "whitespace/line_length"]
["src/nvim/spellfile.c", ["  len = (int)STRLEN(compflags) + 1;", "  if (spin->si_compflags != NULL)", "    len += (int)STRLEN(spin->si_compflags) + 1;"], "readability/braces"]
["src/nvim/spellfile.c", ["  for (p = compflags; *p != NUL; ) {", "    if (vim_strchr((char_u *)\"/?*+[]\", *p) != NULL)", "      // Copy non-flag characters directly."], "readability/braces"]
["src/nvim/spellfile.c", ["      *tp++ = *p++;", "    else {", "      // First get the flag number, also checks validity."], "readability/braces"]
["src/nvim/spellfile.c", ["      *tp++ = *p++;", "    else {", "      // First get the flag number, also checks validity."], "readability/braces"]
["src/nvim/spellfile.c", ["      }", "      if (aff->af_flagtype == AFT_NUM && *p == ',')", "        ++p;"], "readability/braces"]
["src/nvim/spellfile.c", ["      if (aff->af_flagtype == AFT_NUM && *p == ',')", "        ++p;", "    }"], "readability/increment"]
["src/nvim/spellfile.c", ["{", "  if (spinval != 0 && spinval != affval)", "    smsg(_(\"%s value differs from what is used in another .aff file\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["{", "  if (spinval != NULL && STRCMP(spinval, affval) != 0)", "    smsg(_(\"%s value differs from what is used in another .aff file\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["{", "  if (s1 == NULL || s2 == NULL)", "    return s1 == s2;"], "readability/braces"]
["src/nvim/spellfile.c", ["// They are stored case-folded.", "static void add_fromto(spellinfo_T *spin, garray_T *gap, char_u *from, char_u *to)", "{"], "whitespace/line_length"]
["src/nvim/spellfile.c", ["    todo = (int)ht->ht_used;", "    for (hi = ht->ht_array; todo > 0; ++hi) {", "      if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/spellfile.c", ["      if (!HASHITEM_EMPTY(hi)) {", "        --todo;", "        ah = HI2AH(hi);"], "readability/increment"]
["src/nvim/spellfile.c", ["        ah = HI2AH(hi);", "        for (ae = ah->ah_first; ae != NULL; ae = ae->ae_next)", "          vim_regfree(ae->ae_prog);"], "readability/braces"]
["src/nvim/spellfile.c", ["    }", "    if (ht == &aff->af_suff)", "      break;"], "readability/braces"]
["src/nvim/spellfile.c", ["    line_breakcheck();", "    ++lnum;", "    if (line[0] == '#' || line[0] == '/')"], "readability/increment"]
["src/nvim/spellfile.c", ["    ++lnum;", "    if (line[0] == '#' || line[0] == '/')", "      continue;         // comment line"], "readability/braces"]
["src/nvim/spellfile.c", ["    l = (int)STRLEN(line);", "    while (l > 0 && line[l - 1] <= ' ')", "      --l;"], "readability/braces"]
["src/nvim/spellfile.c", ["    while (l > 0 && line[l - 1] <= ' ')", "      --l;", "    if (l == 0)"], "readability/increment"]
["src/nvim/spellfile.c", ["      --l;", "    if (l == 0)", "      continue;         // empty line"], "readability/braces"]
["src/nvim/spellfile.c", ["    if (spin->si_ascii && has_non_ascii(w)) {", "      ++non_ascii;", "      xfree(pc);"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (!HASHITEM_EMPTY(hi)) {", "      if (p_verbose > 0)", "        smsg(_(\"Duplicate word in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["             fname, lnum, dw);", "      else if (duplicate == 0)", "        smsg(_(\"First duplicate word in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["             fname, lnum, dw);", "      ++duplicate;", "    } else"], "readability/increment"]
["src/nvim/spellfile.c", ["      ++duplicate;", "    } else", "      hash_add_item(&ht, hi, dw, hash);"], "readability/braces"]
["src/nvim/spellfile.c", ["", "      if (affile->af_needaffix != 0 && flag_in_afflist(", "              affile->af_flagtype, afflist, affile->af_needaffix))"], "readability/braces"]
["src/nvim/spellfile.c", ["      if (affile->af_needaffix != 0 && flag_in_afflist(", "              affile->af_flagtype, afflist, affile->af_needaffix))", "        need_affix = true;"], "whitespace/indent"]
["src/nvim/spellfile.c", ["", "      if (affile->af_pfxpostpone)", "        // Need to store the list of prefix IDs with the word."], "readability/braces"]
["src/nvim/spellfile.c", ["", "      if (spin->si_compflags != NULL)", "        // Need to store the list of compound flags with the word."], "readability/braces"]
["src/nvim/spellfile.c", ["    // Add the word to the word tree(s).", "    if (store_word(spin, dw, flags, spin->si_region,", "            store_afflist, need_affix) == FAIL)"], "readability/braces"]
["src/nvim/spellfile.c", ["    if (store_word(spin, dw, flags, spin->si_region,", "            store_afflist, need_affix) == FAIL)", "      retval = FAIL;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["      // Additionally do matching prefixes that combine.", "      if (store_aff_word(spin, dw, afflist, affile,", "              &affile->af_suff, &affile->af_pref,"], "readability/braces"]
["src/nvim/spellfile.c", ["      if (store_aff_word(spin, dw, afflist, affile,", "              &affile->af_suff, &affile->af_pref,", "              CONDIT_SUF, flags, store_afflist, pfxlen) == FAIL)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["              &affile->af_suff, &affile->af_pref,", "              CONDIT_SUF, flags, store_afflist, pfxlen) == FAIL)", "        retval = FAIL;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["      // Find all matching prefixes and add the resulting words.", "      if (store_aff_word(spin, dw, afflist, affile,", "              &affile->af_pref, NULL,"], "readability/braces"]
["src/nvim/spellfile.c", ["      if (store_aff_word(spin, dw, afflist, affile,", "              &affile->af_pref, NULL,", "              CONDIT_SUF, flags, store_afflist, pfxlen) == FAIL)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["              &affile->af_pref, NULL,", "              CONDIT_SUF, flags, store_afflist, pfxlen) == FAIL)", "        retval = FAIL;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["", "  if (duplicate > 0)", "    smsg(_(\"%d duplicate word(s) in %s\"), duplicate, fname);"], "readability/braces"]
["src/nvim/spellfile.c", ["    smsg(_(\"%d duplicate word(s) in %s\"), duplicate, fname);", "  if (spin->si_ascii && non_ascii > 0)", "    smsg(_(\"Ignored %d word(s) with non-ASCII characters in %s\"),"], "readability/braces"]
["src/nvim/spellfile.c", ["", "  if (affile->af_keepcase != 0 && flag_in_afflist(", "          affile->af_flagtype, afflist, affile->af_keepcase))"], "readability/braces"]
["src/nvim/spellfile.c", ["  if (affile->af_keepcase != 0 && flag_in_afflist(", "          affile->af_flagtype, afflist, affile->af_keepcase))", "    flags |= WF_KEEPCAP | WF_FIXCAP;"], "whitespace/indent"]
["src/nvim/spellfile.c", ["    flags |= WF_KEEPCAP | WF_FIXCAP;", "  if (affile->af_rare != 0 && flag_in_afflist(", "          affile->af_flagtype, afflist, affile->af_rare))"], "readability/braces"]
["src/nvim/spellfile.c", ["  if (affile->af_rare != 0 && flag_in_afflist(", "          affile->af_flagtype, afflist, affile->af_rare))", "    flags |= WF_RARE;"], "whitespace/indent"]
["src/nvim/spellfile.c", ["    flags |= WF_RARE;", "  if (affile->af_bad != 0 && flag_in_afflist(", "          affile->af_flagtype, afflist, affile->af_bad))"], "readability/braces"]
["src/nvim/spellfile.c", ["  if (affile->af_bad != 0 && flag_in_afflist(", "          affile->af_flagtype, afflist, affile->af_bad))", "    flags |= WF_BANNED;"], "whitespace/indent"]
["src/nvim/spellfile.c", ["    flags |= WF_BANNED;", "  if (affile->af_needcomp != 0 && flag_in_afflist(", "          affile->af_flagtype, afflist, affile->af_needcomp))"], "readability/braces"]
["src/nvim/spellfile.c", ["  if (affile->af_needcomp != 0 && flag_in_afflist(", "          affile->af_flagtype, afflist, affile->af_needcomp))", "    flags |= WF_NEEDCOMP;"], "whitespace/indent"]
["src/nvim/spellfile.c", ["    flags |= WF_NEEDCOMP;", "  if (affile->af_comproot != 0 && flag_in_afflist(", "          affile->af_flagtype, afflist, affile->af_comproot))"], "readability/braces"]
["src/nvim/spellfile.c", ["  if (affile->af_comproot != 0 && flag_in_afflist(", "          affile->af_flagtype, afflist, affile->af_comproot))", "    flags |= WF_COMPROOT;"], "whitespace/indent"]
["src/nvim/spellfile.c", ["    flags |= WF_COMPROOT;", "  if (affile->af_nosuggest != 0 && flag_in_afflist(", "          affile->af_flagtype, afflist, affile->af_nosuggest))"], "readability/braces"]
["src/nvim/spellfile.c", ["  if (affile->af_nosuggest != 0 && flag_in_afflist(", "          affile->af_flagtype, afflist, affile->af_nosuggest))", "    flags |= WF_NOSUGGEST;"], "whitespace/indent"]
["src/nvim/spellfile.c", ["// and return the number of affixes.", "static int get_pfxlist(afffile_T *affile, char_u *afflist, char_u *store_afflist)", "{"], "whitespace/line_length"]
["src/nvim/spellfile.c", ["        id = HI2AH(hi)->ah_newID;", "        if (id != 0)", "          store_afflist[cnt++] = id;"], "readability/braces"]
["src/nvim/spellfile.c", ["    }", "    if (affile->af_flagtype == AFT_NUM && *p == ',')", "      ++p;"], "readability/braces"]
["src/nvim/spellfile.c", ["    if (affile->af_flagtype == AFT_NUM && *p == ',')", "      ++p;", "  }"], "readability/increment"]
["src/nvim/spellfile.c", ["// Puts the flags in \"store_afflist[]\".", "static void get_compflags(afffile_T *affile, char_u *afflist, char_u *store_afflist)", "{"], "whitespace/line_length"]
["src/nvim/spellfile.c", ["      hi = hash_find(&affile->af_comp, key);", "      if (!HASHITEM_EMPTY(hi))", "        store_afflist[cnt++] = HI2CI(hi)->ci_newID;"], "readability/braces"]
["src/nvim/spellfile.c", ["    }", "    if (affile->af_flagtype == AFT_NUM && *p == ',')", "      ++p;"], "readability/braces"]
["src/nvim/spellfile.c", ["    if (affile->af_flagtype == AFT_NUM && *p == ',')", "      ++p;", "  }"], "readability/increment"]
["src/nvim/spellfile.c", ["static int", "store_aff_word (", "    spellinfo_T *spin,         // spell info"], "whitespace/parens"]
["src/nvim/spellfile.c", ["  todo = (int)ht->ht_used;", "  for (hi = ht->ht_array; todo > 0 && retval == OK; ++hi) {", "    if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (!HASHITEM_EMPTY(hi)) {", "      --todo;", "      ah = HI2AH(hi);"], "readability/increment"]
["src/nvim/spellfile.c", ["          && flag_in_afflist(affile->af_flagtype, afflist,", "              ah->ah_flag)) {", "        // Loop over all affix entries with this name."], "whitespace/alignment"]
["src/nvim/spellfile.c", ["          && flag_in_afflist(affile->af_flagtype, afflist,", "              ah->ah_flag)) {", "        // Loop over all affix entries with this name."], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                      || !flag_in_afflist(affile->af_flagtype,", "                          ae->ae_flags, affile->af_circumfix)))) {", "            // Match.  Remove the chop and add the affix."], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                      || !flag_in_afflist(affile->af_flagtype,", "                          ae->ae_flags, affile->af_circumfix)))) {", "            // Match.  Remove the chop and add the affix."], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                      || !flag_in_afflist(affile->af_flagtype,", "                          ae->ae_flags, affile->af_circumfix)))) {", "            // Match.  Remove the chop and add the affix."], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                      || !flag_in_afflist(affile->af_flagtype,", "                          ae->ae_flags, affile->af_circumfix)))) {", "            // Match.  Remove the chop and add the affix."], "whitespace/alignment"]
["src/nvim/spellfile.c", ["              }", "              if (ae->ae_add != NULL)", "                STRCAT(newword, ae->ae_add);"], "readability/braces"]
["src/nvim/spellfile.c", ["", "              if (affile->af_needaffix != 0 && flag_in_afflist(", "                      affile->af_flagtype, ae->ae_flags,"], "readability/braces"]
["src/nvim/spellfile.c", ["              if (affile->af_needaffix != 0 && flag_in_afflist(", "                      affile->af_flagtype, ae->ae_flags,", "                      affile->af_needaffix))"], "whitespace/indent"]
["src/nvim/spellfile.c", ["                      affile->af_flagtype, ae->ae_flags,", "                      affile->af_needaffix))", "                need_affix = true;"], "whitespace/indent"]
["src/nvim/spellfile.c", ["              if (affile->af_circumfix != 0 && flag_in_afflist(", "                      affile->af_flagtype, ae->ae_flags,", "                      affile->af_circumfix)) {"], "whitespace/indent"]
["src/nvim/spellfile.c", ["                      affile->af_flagtype, ae->ae_flags,", "                      affile->af_circumfix)) {", "                use_condit |= CONDIT_CFIX;"], "whitespace/indent"]
["src/nvim/spellfile.c", ["                use_condit |= CONDIT_CFIX;", "                if ((condit & CONDIT_CFIX) == 0)", "                  need_affix = true;"], "readability/braces"]
["src/nvim/spellfile.c", ["                  || spin->si_compflags != NULL) {", "                if (affile->af_pfxpostpone)", "                  // Get prefix IDS from the affix list."], "readability/braces"]
["src/nvim/spellfile.c", ["                  use_pfxlen = get_pfxlist(affile,", "                      ae->ae_flags, store_afflist);", "                else"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                      ae->ae_flags, store_afflist);", "                else", "                  use_pfxlen = 0;"], "readability/braces"]
["src/nvim/spellfile.c", ["                // same ID twice.", "                for (i = 0; i < pfxlen; ++i) {", "                  for (j = 0; j < use_pfxlen; ++j)"], "readability/increment"]
["src/nvim/spellfile.c", ["                for (i = 0; i < pfxlen; ++i) {", "                  for (j = 0; j < use_pfxlen; ++j)", "                    if (pfxlist[i] == use_pfxlist[j])"], "readability/braces"]
["src/nvim/spellfile.c", ["                for (i = 0; i < pfxlen; ++i) {", "                  for (j = 0; j < use_pfxlen; ++j)", "                    if (pfxlist[i] == use_pfxlist[j])"], "readability/increment"]
["src/nvim/spellfile.c", ["                  for (j = 0; j < use_pfxlen; ++j)", "                    if (pfxlist[i] == use_pfxlist[j])", "                      break;"], "readability/braces"]
["src/nvim/spellfile.c", ["                      break;", "                  if (j == use_pfxlen)", "                    use_pfxlist[use_pfxlen++] = pfxlist[i];"], "readability/braces"]
["src/nvim/spellfile.c", ["", "                if (spin->si_compflags != NULL)", "                  // Get compound IDS from the affix list."], "readability/braces"]
["src/nvim/spellfile.c", ["                  get_compflags(affile, ae->ae_flags,", "                      use_pfxlist + use_pfxlen);", "                else"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                      use_pfxlist + use_pfxlen);", "                else", "                  use_pfxlist[use_pfxlen] = NUL;"], "readability/braces"]
["src/nvim/spellfile.c", ["                // Avoid adding the same ID twice.", "                for (i = pfxlen; pfxlist[i] != NUL; ++i) {", "                  for (j = use_pfxlen;"], "readability/increment"]
["src/nvim/spellfile.c", ["                for (i = pfxlen; pfxlist[i] != NUL; ++i) {", "                  for (j = use_pfxlen;", "                       use_pfxlist[j] != NUL; ++j)"], "readability/braces"]
["src/nvim/spellfile.c", ["                  for (j = use_pfxlen;", "                       use_pfxlist[j] != NUL; ++j)", "                    if (pfxlist[i] == use_pfxlist[j])"], "readability/increment"]
["src/nvim/spellfile.c", ["                       use_pfxlist[j] != NUL; ++j)", "                    if (pfxlist[i] == use_pfxlist[j])", "                      break;"], "readability/braces"]
["src/nvim/spellfile.c", ["              // compound flags after them.", "              if (!ah->ah_combine && use_pfxlist != NULL)", "                use_pfxlist += use_pfxlen;"], "readability/braces"]
["src/nvim/spellfile.c", ["            if (spin->si_compflags != NULL && !ae->ae_comppermit) {", "              if (xht != NULL)", "                use_flags |= WF_NOCOMPAFT;"], "readability/braces"]
["src/nvim/spellfile.c", ["                use_flags |= WF_NOCOMPAFT;", "              else", "                use_flags |= WF_NOCOMPBEF;"], "readability/braces"]
["src/nvim/spellfile.c", ["            // Store the modified word.", "            if (store_word(spin, newword, use_flags,", "                    spin->si_region, use_pfxlist,"], "readability/braces"]
["src/nvim/spellfile.c", ["            if (store_word(spin, newword, use_flags,", "                    spin->si_region, use_pfxlist,", "                    need_affix) == FAIL)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                    spin->si_region, use_pfxlist,", "                    need_affix) == FAIL)", "              retval = FAIL;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["            // has flags may add a(nother) suffix.  RECURSIVE!", "            if ((condit & CONDIT_SUF) && ae->ae_flags != NULL)", "              if (store_aff_word(spin, newword, ae->ae_flags,"], "readability/braces"]
["src/nvim/spellfile.c", ["            if ((condit & CONDIT_SUF) && ae->ae_flags != NULL)", "              if (store_aff_word(spin, newword, ae->ae_flags,", "                      affile, &affile->af_suff, xht,"], "readability/braces"]
["src/nvim/spellfile.c", ["              if (store_aff_word(spin, newword, ae->ae_flags,", "                      affile, &affile->af_suff, xht,", "                      use_condit & (xht == NULL"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                      affile, &affile->af_suff, xht,", "                      use_condit & (xht == NULL", "                                    ? ~0 :  ~CONDIT_SUF),"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                                    ? ~0 :  ~CONDIT_SUF),", "                      use_flags, use_pfxlist, pfxlen) == FAIL)", "                retval = FAIL;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["            if (xht != NULL && ah->ah_combine) {", "              if (store_aff_word(spin, newword,", "                      afflist, affile,"], "readability/braces"]
["src/nvim/spellfile.c", ["              if (store_aff_word(spin, newword,", "                      afflist, affile,", "                      xht, NULL, use_condit,"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                      afflist, affile,", "                      xht, NULL, use_condit,", "                      use_flags, use_pfxlist,"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                      xht, NULL, use_condit,", "                      use_flags, use_pfxlist,", "                      pfxlen) == FAIL"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                      use_flags, use_pfxlist,", "                      pfxlen) == FAIL", "                  || (ae->ae_flags != NULL"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                      && store_aff_word(spin, newword,", "                          ae->ae_flags, affile,", "                          xht, NULL, use_condit,"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                          ae->ae_flags, affile,", "                          xht, NULL, use_condit,", "                          use_flags, use_pfxlist,"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                          xht, NULL, use_condit,", "                          use_flags, use_pfxlist,", "                          pfxlen) == FAIL))"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                          use_flags, use_pfxlist,", "                          pfxlen) == FAIL))", "                retval = FAIL;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                      && store_aff_word(spin, newword,", "                          ae->ae_flags, affile,", "                          xht, NULL, use_condit,"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                          ae->ae_flags, affile,", "                          xht, NULL, use_condit,", "                          use_flags, use_pfxlist,"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                          xht, NULL, use_condit,", "                          use_flags, use_pfxlist,", "                          pfxlen) == FAIL))"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                          use_flags, use_pfxlist,", "                          pfxlen) == FAIL))", "                retval = FAIL;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                      && store_aff_word(spin, newword,", "                          ae->ae_flags, affile,", "                          xht, NULL, use_condit,"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                          ae->ae_flags, affile,", "                          xht, NULL, use_condit,", "                          use_flags, use_pfxlist,"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                          xht, NULL, use_condit,", "                          use_flags, use_pfxlist,", "                          pfxlen) == FAIL))"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                          use_flags, use_pfxlist,", "                          pfxlen) == FAIL))", "                retval = FAIL;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["    line_breakcheck();", "    ++lnum;", ""], "readability/increment"]
["src/nvim/spellfile.c", ["    // Skip comment lines.", "    if (*rline == '#')", "      continue;"], "readability/braces"]
["src/nvim/spellfile.c", ["    l = (int)STRLEN(rline);", "    while (l > 0 && rline[l - 1] <= ' ')", "      --l;"], "readability/braces"]
["src/nvim/spellfile.c", ["    while (l > 0 && rline[l - 1] <= ' ')", "      --l;", "    if (l == 0)"], "readability/increment"]
["src/nvim/spellfile.c", ["      --l;", "    if (l == 0)", "      continue;         // empty or blank line"], "readability/braces"]
["src/nvim/spellfile.c", ["    if (*line == '/') {", "      ++line;", "      if (STRNCMP(line, \"encoding=\", 9) == 0) {"], "readability/increment"]
["src/nvim/spellfile.c", ["          enc = enc_canonize(line);", "          if (!spin->si_ascii", "              && convert_setup(&spin->si_conv, enc,"], "readability/braces"]
["src/nvim/spellfile.c", ["              && convert_setup(&spin->si_conv, enc,", "                  p_enc) == FAIL)", "            smsg(_(\"Conversion in %s not supported: from %s to %s\"),"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["              && convert_setup(&spin->si_conv, enc,", "                  p_enc) == FAIL)", "            smsg(_(\"Conversion in %s not supported: from %s to %s\"),"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["      while (*p != NUL) {", "        if (*p == '=')                  // keep-case word", "          flags |= WF_KEEPCAP | WF_FIXCAP;"], "readability/braces"]
["src/nvim/spellfile.c", ["          flags |= WF_KEEPCAP | WF_FIXCAP;", "        else if (*p == '!')             // Bad, bad, wicked word.", "          flags |= WF_BANNED;"], "readability/braces"]
["src/nvim/spellfile.c", ["          flags |= WF_BANNED;", "        else if (*p == '?')             // Rare word.", "          flags |= WF_RARE;"], "readability/braces"]
["src/nvim/spellfile.c", ["          flags |= WF_RARE;", "        else if (ascii_isdigit(*p)) {       // region number(s)", "          if ((flags & WF_REGION) == 0)             // first one"], "readability/braces"]
["src/nvim/spellfile.c", ["        else if (ascii_isdigit(*p)) {       // region number(s)", "          if ((flags & WF_REGION) == 0)             // first one", "            regionmask = 0;"], "readability/braces"]
["src/nvim/spellfile.c", ["        }", "        ++p;", "      }"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (spin->si_ascii && has_non_ascii(line)) {", "      ++non_ascii;", "      continue;"], "readability/increment"]
["src/nvim/spellfile.c", ["    vim_snprintf((char *)IObuff, IOSIZE,", "        _(\"Ignored %d words with non-ASCII characters\"), non_ascii);", "    spell_message(spin, IObuff);"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["  assert(len <= SBLOCKSIZE);", "  ", "  if (align && bl != NULL)"], "whitespace/end_of_line"]
["src/nvim/spellfile.c", ["  ", "  if (align && bl != NULL)", "    // Round size up for alignment.  On some systems structures need to be"], "readability/braces"]
["src/nvim/spellfile.c", ["    bl->sb_used = 0;", "    ++spin->si_blocks_cnt;", "  }"], "readability/increment"]
["src/nvim/spellfile.c", ["static int", "store_word (", "    spellinfo_T *spin,"], "whitespace/parens"]
["src/nvim/spellfile.c", ["  (void)spell_casefold(word, len, foldword, MAXWLEN);", "  for (p = pfxlist; res == OK; ++p) {", "    if (!need_affix || (p != NULL && *p != NUL))"], "readability/increment"]
["src/nvim/spellfile.c", ["  for (p = pfxlist; res == OK; ++p) {", "    if (!need_affix || (p != NULL && *p != NUL))", "      res = tree_add_word(spin, foldword, spin->si_foldroot, ct | flags,"], "readability/braces"]
["src/nvim/spellfile.c", ["      res = tree_add_word(spin, foldword, spin->si_foldroot, ct | flags,", "          region, p == NULL ? 0 : *p);", "    if (p == NULL || *p == NUL)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["          region, p == NULL ? 0 : *p);", "    if (p == NULL || *p == NUL)", "      break;"], "readability/braces"]
["src/nvim/spellfile.c", ["  }", "  ++spin->si_foldwcount;", ""], "readability/increment"]
["src/nvim/spellfile.c", ["  if (res == OK && (ct == WF_KEEPCAP || (flags & WF_KEEPCAP))) {", "    for (p = pfxlist; res == OK; ++p) {", "      if (!need_affix || (p != NULL && *p != NUL))"], "readability/increment"]
["src/nvim/spellfile.c", ["    for (p = pfxlist; res == OK; ++p) {", "      if (!need_affix || (p != NULL && *p != NUL))", "        res = tree_add_word(spin, word, spin->si_keeproot, flags,"], "readability/braces"]
["src/nvim/spellfile.c", ["        res = tree_add_word(spin, word, spin->si_keeproot, flags,", "            region, p == NULL ? 0 : *p);", "      if (p == NULL || *p == NUL)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["            region, p == NULL ? 0 : *p);", "      if (p == NULL || *p == NUL)", "        break;"], "readability/braces"]
["src/nvim/spellfile.c", ["    }", "    ++spin->si_keepwcount;", "  }"], "readability/increment"]
["src/nvim/spellfile.c", ["// Returns FAIL when out of memory.", "static int tree_add_word(spellinfo_T *spin, char_u *word, wordnode_T *root, int flags, int region, int affixID)", "{"], "whitespace/line_length"]
["src/nvim/spellfile.c", ["  // Add each byte of the word to the tree, including the NUL at the end.", "  for (i = 0;; ++i) {", "    // When there is more than one reference to this node we need to make"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (node != NULL && node->wn_refs > 1) {", "      --node->wn_refs;", "      copyprev = prev;"], "readability/increment"]
["src/nvim/spellfile.c", ["        np = get_wordnode(spin);", "        if (np == NULL)", "          return FAIL;"], "readability/braces"]
["src/nvim/spellfile.c", ["        np->wn_child = copyp->wn_child;", "        if (np->wn_child != NULL)", "          ++np->wn_child->wn_refs;              // child gets extra ref"], "readability/braces"]
["src/nvim/spellfile.c", ["        if (np->wn_child != NULL)", "          ++np->wn_child->wn_refs;              // child gets extra ref", "        np->wn_byte = copyp->wn_byte;"], "readability/increment"]
["src/nvim/spellfile.c", ["        np->wn_refs = 1;", "        if (copyprev != NULL)", "          *copyprev = np;"], "readability/braces"]
["src/nvim/spellfile.c", ["        // Let \"node\" point to the head of the copied list.", "        if (copyp == node)", "          node = np;"], "readability/braces"]
["src/nvim/spellfile.c", ["      np = get_wordnode(spin);", "      if (np == NULL)", "        return FAIL;"], "readability/braces"]
["src/nvim/spellfile.c", ["      // of the list of siblings).", "      if (node == NULL)", "        np->wn_refs = 1;"], "readability/braces"]
["src/nvim/spellfile.c", ["        np->wn_refs = 1;", "      else {", "        np->wn_refs = node->wn_refs;"], "readability/braces"]
["src/nvim/spellfile.c", ["        np->wn_refs = 1;", "      else {", "        np->wn_refs = node->wn_refs;"], "readability/braces"]
["src/nvim/spellfile.c", ["      }", "      if (prev != NULL)", "        *prev = np;"], "readability/braces"]
["src/nvim/spellfile.c", ["  // count nr of words added since last message", "  ++spin->si_msg_count;", ""], "readability/increment"]
["src/nvim/spellfile.c", ["      ? spin->si_free_count < MAXWLEN", "                              : spin->si_blocks_cnt >= compress_start)", "#endif"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["      msg_clr_eos();", "      msg_didout = FALSE;", "      msg_col = 0;"], "readability/bool"]
["src/nvim/spellfile.c", ["", "  if (spin->si_first_free == NULL)", "    n = (wordnode_T *)getroom(spin, sizeof(wordnode_T), true);"], "readability/braces"]
["src/nvim/spellfile.c", ["    n = (wordnode_T *)getroom(spin, sizeof(wordnode_T), true);", "  else {", "    n = spin->si_first_free;"], "readability/braces"]
["src/nvim/spellfile.c", ["    n = (wordnode_T *)getroom(spin, sizeof(wordnode_T), true);", "  else {", "    n = spin->si_first_free;"], "readability/braces"]
["src/nvim/spellfile.c", ["    memset(n, 0, sizeof(wordnode_T));", "    --spin->si_free_count;", "  }"], "readability/increment"]
["src/nvim/spellfile.c", ["#ifdef SPELL_PRINTTREE", "  if (n != NULL)", "    n->wn_nr = ++spin->si_wordnode_nr;"], "readability/braces"]
["src/nvim/spellfile.c", ["    for (np = node; np != NULL; np = np->wn_sibling) {", "      if (np->wn_child != NULL)", "        cnt += deref_wordnode(spin, np->wn_child);"], "readability/braces"]
["src/nvim/spellfile.c", ["      free_wordnode(spin, np);", "      ++cnt;", "    }"], "readability/increment"]
["src/nvim/spellfile.c", ["    }", "    ++cnt;          // length field", "  }"], "readability/increment"]
["src/nvim/spellfile.c", ["  spin->si_first_free = n;", "  ++spin->si_free_count;", "}"], "readability/increment"]
["src/nvim/spellfile.c", ["#ifndef SPELL_PRINTTREE", "    if (spin->si_verbose || p_verbose > 2)", "#endif"], "readability/braces"]
["src/nvim/spellfile.c", ["    {", "      if (tot > 1000000)", "        perc = (tot - n) / (tot / 100);"], "readability/braces"]
["src/nvim/spellfile.c", ["        perc = (tot - n) / (tot / 100);", "      else if (tot == 0)", "        perc = 0;"], "readability/braces"]
["src/nvim/spellfile.c", ["        perc = 0;", "      else", "        perc = (tot - n) * 100 / tot;"], "readability/braces"]
["src/nvim/spellfile.c", ["  for (np = node; np != NULL && !got_int; np = np->wn_sibling) {", "    ++len;", "    if ((child = np->wn_child) != NULL) {"], "readability/increment"]
["src/nvim/spellfile.c", ["        // that is really identical.", "        for (tp = HI2WN(hi); tp != NULL; tp = tp->wn_u2.next)", "          if (node_equal(child, tp)) {"], "readability/braces"]
["src/nvim/spellfile.c", ["            // its siblings is unlinked from the tree.", "            ++tp->wn_refs;", "            compressed += deref_wordnode(spin, child);"], "readability/increment"]
["src/nvim/spellfile.c", ["        }", "      } else", "        // No other child has this hash value, add it to the"], "readability/braces"]
["src/nvim/spellfile.c", ["  for (np = node; np != NULL; np = np->wn_sibling) {", "    if (np->wn_byte == NUL)", "      // end node: use wn_flags, wn_region and wn_affixID"], "readability/braces"]
["src/nvim/spellfile.c", ["      n = np->wn_flags + (np->wn_region << 8) + (np->wn_affixID << 16);", "    else", "      // byte node: use the byte value and the child pointer"], "readability/braces"]
["src/nvim/spellfile.c", ["", "  for (p1 = n1, p2 = n2; p1 != NULL && p2 != NULL;", "       p1 = p1->wn_sibling, p2 = p2->wn_sibling)"], "readability/braces"]
["src/nvim/spellfile.c", ["       p1 = p1->wn_sibling, p2 = p2->wn_sibling)", "    if (p1->wn_byte != p2->wn_byte", "        || (p1->wn_byte == NUL"], "readability/braces"]
["src/nvim/spellfile.c", ["  size_t fwv = fwrite(VIMSPELLMAGIC, VIMSPELLMAGICL, 1, fd);", "  if (fwv != (size_t)1)", "    // Catch first write error, don't try writing more."], "readability/braces"]
["src/nvim/spellfile.c", ["    regionmask = (1 << spin->si_region_count) - 1;", "  } else", "    regionmask = 0;"], "readability/braces"]
["src/nvim/spellfile.c", ["    fputc(128, fd);                                     // <charflagslen>", "    for (size_t i = 128; i < 256; ++i) {", "      flags = 0;"], "readability/increment"]
["src/nvim/spellfile.c", ["      flags = 0;", "      if (spelltab.st_isw[i])", "        flags |= CF_WORD;"], "readability/braces"]
["src/nvim/spellfile.c", ["        flags |= CF_WORD;", "      if (spelltab.st_isu[i])", "        flags |= CF_UPPER;"], "readability/braces"]
["src/nvim/spellfile.c", ["  // round 3: SN_REPSAL section", "  for (unsigned int round = 1; round <= 3; ++round) {", "    garray_T *gap;"], "readability/increment"]
["src/nvim/spellfile.c", ["    garray_T *gap;", "    if (round == 1)", "      gap = &spin->si_rep;"], "readability/braces"]
["src/nvim/spellfile.c", ["      gap = &spin->si_rep;", "    else if (round == 2) {", "      // Don't write SN_SAL when using a SN_SOFO section"], "readability/braces"]
["src/nvim/spellfile.c", ["      // Don't write SN_SAL when using a SN_SOFO section", "      if (spin->si_sofofr != NULL && spin->si_sofoto != NULL)", "        continue;"], "readability/braces"]
["src/nvim/spellfile.c", ["      gap = &spin->si_sal;", "    } else", "      gap = &spin->si_repsal;"], "readability/braces"]
["src/nvim/spellfile.c", ["    // Don't write the section if there are no items.", "    if (GA_EMPTY(gap))", "      continue;"], "readability/braces"]
["src/nvim/spellfile.c", ["    // Sort the REP/REPSAL items.", "    if (round != 2)", "      qsort(gap->ga_data, (size_t)gap->ga_len,"], "readability/braces"]
["src/nvim/spellfile.c", ["      qsort(gap->ga_data, (size_t)gap->ga_len,", "          sizeof(fromto_T), rep_compare);", ""], "whitespace/alignment"]
["src/nvim/spellfile.c", ["    assert(gap->ga_len >= 0);", "    for (size_t i = 0; i < (size_t)gap->ga_len; ++i) {", "      fromto_T *ftp = &((fromto_T *)gap->ga_data)[i];"], "readability/increment"]
["src/nvim/spellfile.c", ["    }", "    if (round == 2)", "      ++l;                            // count <salflags>"], "readability/braces"]
["src/nvim/spellfile.c", ["    if (round == 2)", "      ++l;                            // count <salflags>", "    put_bytes(fd, l, 4);                                // <sectionlen>"], "readability/increment"]
["src/nvim/spellfile.c", ["      int i = 0;", "      if (spin->si_followup)", "        i |= SAL_F0LLOWUP;"], "readability/braces"]
["src/nvim/spellfile.c", ["        i |= SAL_F0LLOWUP;", "      if (spin->si_collapse)", "        i |= SAL_COLLAPSE;"], "readability/braces"]
["src/nvim/spellfile.c", ["        i |= SAL_COLLAPSE;", "      if (spin->si_rem_accents)", "        i |= SAL_REM_ACCENTS;"], "readability/braces"]
["src/nvim/spellfile.c", ["    put_bytes(fd, (uintmax_t)gap->ga_len, 2);    // <repcount> or <salcount>", "    for (size_t i = 0; i < (size_t)gap->ga_len; ++i) {", "      // <rep> : <repfromlen> <repfrom> <reptolen> <repto>"], "readability/increment"]
["src/nvim/spellfile.c", ["      fromto_T *ftp = &((fromto_T *)gap->ga_data)[i];", "      for (unsigned int rr = 1; rr <= 2; ++rr) {", "        char_u *p = rr == 1 ? ftp->ft_from : ftp->ft_to;"], "readability/increment"]
["src/nvim/spellfile.c", ["        putc((int)l, fd);", "        if (l > 0)", "          fwv &= fwrite(p, l, 1, fd);"], "readability/braces"]
["src/nvim/spellfile.c", ["    }", "", "  }"], "whitespace/blank_line"]
["src/nvim/spellfile.c", ["    // round 2: write the bytes", "    for (unsigned int round = 1; round <= 2; ++round) {", "      size_t todo;"], "readability/increment"]
["src/nvim/spellfile.c", ["      todo = spin->si_commonwords.ht_used;", "      for (hi = spin->si_commonwords.ht_array; todo > 0; ++hi)", "        if (!HASHITEM_EMPTY(hi)) {"], "readability/braces"]
["src/nvim/spellfile.c", ["      todo = spin->si_commonwords.ht_used;", "      for (hi = spin->si_commonwords.ht_array; todo > 0; ++hi)", "        if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/spellfile.c", ["          len += l;", "          if (round == 2)                               // <word>", "            fwv &= fwrite(hi->hi_key, l, 1, fd);"], "readability/braces"]
["src/nvim/spellfile.c", ["            fwv &= fwrite(hi->hi_key, l, 1, fd);", "          --todo;", "        }"], "readability/increment"]
["src/nvim/spellfile.c", ["        }", "      if (round == 1)", "        put_bytes(fd, len, 4);                          // <sectionlen>"], "readability/braces"]
["src/nvim/spellfile.c", ["    assert(spin->si_comppat.ga_len >= 0);", "    for (size_t i = 0; i < (size_t)spin->si_comppat.ga_len; ++i) {", "      l += STRLEN(((char_u **)(spin->si_comppat.ga_data))[i]) + 1;"], "readability/increment"]
["src/nvim/spellfile.c", ["    put_bytes(fd, (uintmax_t)spin->si_comppat.ga_len, 2);  // <comppatcount>", "    for (size_t i = 0; i < (size_t)spin->si_comppat.ga_len; ++i) {", "      char_u *p = ((char_u **)(spin->si_comppat.ga_data))[i];"], "readability/increment"]
["src/nvim/spellfile.c", ["  spin->si_memtot = 0;", "  for (unsigned int round = 1; round <= 3; ++round) {", "    wordnode_T *tree;"], "readability/increment"]
["src/nvim/spellfile.c", ["    wordnode_T *tree;", "    if (round == 1)", "      tree = spin->si_foldroot->wn_sibling;"], "readability/braces"]
["src/nvim/spellfile.c", ["      tree = spin->si_foldroot->wn_sibling;", "    else if (round == 2)", "      tree = spin->si_keeproot->wn_sibling;"], "readability/braces"]
["src/nvim/spellfile.c", ["      tree = spin->si_keeproot->wn_sibling;", "    else", "      tree = spin->si_prefroot->wn_sibling;"], "readability/braces"]
["src/nvim/spellfile.c", ["  // Write another byte to check for errors (file system full).", "  if (putc(0, fd) == EOF)", "    retval = FAIL;"], "readability/braces"]
["src/nvim/spellfile.c", ["theend:", "  if (fclose(fd) == EOF)", "    retval = FAIL;"], "readability/braces"]
["src/nvim/spellfile.c", ["", "  if (fwv != (size_t)1)", "    retval = FAIL;"], "readability/braces"]
["src/nvim/spellfile.c", ["    retval = FAIL;", "  if (retval == FAIL)", "    EMSG(_(e_write));"], "readability/braces"]
["src/nvim/spellfile.c", ["", "  if (node != NULL)", "    for (np = node; np != NULL; np = np->wn_sibling) {"], "readability/braces"]
["src/nvim/spellfile.c", ["", "      if (np->wn_byte != NUL)", "        clear_node(np->wn_child);"], "readability/braces"]
["src/nvim/spellfile.c", ["static int", "put_node (", "    FILE *fd,                // NULL when only counting"], "whitespace/parens"]
["src/nvim/spellfile.c", ["  // If \"node\" is zero the tree is empty.", "  if (node == NULL)", "    return 0;"], "readability/braces"]
["src/nvim/spellfile.c", ["  int siblingcount = 0;", "  for (wordnode_T *np = node; np != NULL; np = np->wn_sibling)", "    ++siblingcount;"], "readability/braces"]
["src/nvim/spellfile.c", ["  for (wordnode_T *np = node; np != NULL; np = np->wn_sibling)", "    ++siblingcount;", ""], "readability/increment"]
["src/nvim/spellfile.c", ["  // Write the sibling count.", "  if (fd != NULL)", "    putc(siblingcount, fd);                             // <siblingcount>"], "readability/braces"]
["src/nvim/spellfile.c", ["          // combining\" flags", "          if (np->wn_flags == (uint16_t)PFX_FLAGS)", "            putc(BY_NOFLAGS, fd);                       // <byte>"], "readability/braces"]
["src/nvim/spellfile.c", ["            putc(BY_NOFLAGS, fd);                       // <byte>", "          else {", "            putc(BY_FLAGS, fd);                         // <byte>"], "readability/braces"]
["src/nvim/spellfile.c", ["            putc(BY_NOFLAGS, fd);                       // <byte>", "          else {", "            putc(BY_FLAGS, fd);                         // <byte>"], "readability/braces"]
["src/nvim/spellfile.c", ["          int flags = np->wn_flags;", "          if (regionmask != 0 && np->wn_region != regionmask)", "            flags |= WF_REGION;"], "readability/braces"]
["src/nvim/spellfile.c", ["            flags |= WF_REGION;", "          if (np->wn_affixID != 0)", "            flags |= WF_AFX;"], "readability/braces"]
["src/nvim/spellfile.c", ["            }", "            if (flags & WF_REGION)", "              putc(np->wn_region, fd);                          // <region>"], "readability/braces"]
["src/nvim/spellfile.c", ["              putc(np->wn_region, fd);                          // <region>", "            if (flags & WF_AFX)", "              putc(np->wn_affixID, fd);                         // <affixID>"], "readability/braces"]
["src/nvim/spellfile.c", ["        }", "      } else if (np->wn_child->wn_u2.wnode == NULL)", "        // We will write the child below and give it an index."], "readability/braces"]
["src/nvim/spellfile.c", ["", "      if (fd != NULL)", "        if (putc(np->wn_byte, fd) == EOF) {       // <byte> or <xbyte>"], "readability/braces"]
["src/nvim/spellfile.c", ["  // Recursively dump the children of each sibling.", "  for (wordnode_T *np = node; np != NULL; np = np->wn_sibling)", "    if (np->wn_byte != 0 && np->wn_child->wn_u2.wnode == node)"], "readability/braces"]
["src/nvim/spellfile.c", ["  for (wordnode_T *np = node; np != NULL; np = np->wn_sibling)", "    if (np->wn_byte != 0 && np->wn_child->wn_u2.wnode == node)", "      newindex = put_node(fd, np->wn_child, newindex, regionmask,"], "readability/braces"]
["src/nvim/spellfile.c", ["      newindex = put_node(fd, np->wn_child, newindex, regionmask,", "          prefixtree);", ""], "whitespace/alignment"]
["src/nvim/spellfile.c", ["    slang = spell_load_file(wfname, NULL, NULL, false);", "    if (slang == NULL)", "      return;"], "readability/braces"]
["src/nvim/spellfile.c", ["  spell_message(spin, (char_u *)_(\"Performing soundfolding...\"));", "  if (sug_filltree(spin, slang) == FAIL)", "    goto theend;"], "readability/braces"]
["src/nvim/spellfile.c", ["  // compression possible.", "  if (sug_maketable(spin) == FAIL)", "    goto theend;"], "readability/braces"]
["src/nvim/spellfile.c", ["  xfree(fname);", "  if (free_slang)", "    slang_free(slang);"], "readability/braces"]
["src/nvim/spellfile.c", ["      idxs[arridx[depth]] = wordcount[depth];", "      if (depth > 0)", "        wordcount[depth - 1] += wordcount[depth];"], "readability/braces"]
["src/nvim/spellfile.c", ["", "      --depth;", "      line_breakcheck();"], "readability/increment"]
["src/nvim/spellfile.c", ["    } else {", "", "      // Do one more byte at this node."], "whitespace/blank_line"]
["src/nvim/spellfile.c", ["      n = arridx[depth] + curi[depth];", "      ++curi[depth];", ""], "readability/increment"]
["src/nvim/spellfile.c", ["        // \"region\" for the LSB of the wordnr.", "        if (tree_add_word(spin, tsalword, spin->si_foldroot,", "                words_done >> 16, words_done & 0xffff,"], "readability/braces"]
["src/nvim/spellfile.c", ["        if (tree_add_word(spin, tsalword, spin->si_foldroot,", "                words_done >> 16, words_done & 0xffff,", "                0) == FAIL)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                words_done >> 16, words_done & 0xffff,", "                0) == FAIL)", "          return FAIL;"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["", "        ++words_done;", "        ++wordcount[depth];"], "readability/increment"]
["src/nvim/spellfile.c", ["        ++words_done;", "        ++wordcount[depth];", ""], "readability/increment"]
["src/nvim/spellfile.c", ["  // recursively go through the tree", "  if (sug_filltable(spin, spin->si_foldroot->wn_sibling, 0, &ga) == -1)", "    res = FAIL;"], "readability/braces"]
["src/nvim/spellfile.c", ["static int", "sug_filltable (", "    spellinfo_T *spin,"], "whitespace/parens"]
["src/nvim/spellfile.c", ["        gap->ga_len += offset2bytes(nr,", "            (char_u *)gap->ga_data + gap->ga_len);", "      }"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["      // bother freeing the nodes, the won't be reused anyway.", "      while (p->wn_sibling != NULL && p->wn_sibling->wn_byte == NUL)", "        p->wn_sibling = p->wn_sibling->wn_sibling;"], "readability/braces"]
["src/nvim/spellfile.c", ["      wordnr = sug_filltable(spin, p->wn_child, wordnr, gap);", "      if (wordnr == -1)", "        return -1;"], "readability/braces"]
["src/nvim/spellfile.c", ["  }", "  if (b3 > 1 || b2 > 0x3f ) {   // 3 bytes", "    buf[0] = 0xc0 + b3;"], "whitespace/parens"]
["src/nvim/spellfile.c", ["  }", "  if (b2 > 1 || b1 > 0x7f ) {   // 2 bytes", "    buf[0] = 0x80 + b2;"], "whitespace/parens"]
["src/nvim/spellfile.c", ["  // <SUGHEADER>: <fileID> <versionnr> <timestamp>", "  if (fwrite(VIMSUGMAGIC, VIMSUGMAGICL, (size_t)1, fd) != 1) { // <fileID>", "    EMSG(_(e_write));"], "whitespace/comments"]
["src/nvim/spellfile.c", ["", "  for (linenr_T lnum = 1; lnum <= wcount; ++lnum) {", "    // <sugline>: <sugnr> ... NUL"], "readability/increment"]
["src/nvim/spellfile.c", ["    // <sugline>: <sugnr> ... NUL", "    char_u *line = ml_get_buf(spin->si_spellbuf, lnum, FALSE);", "    size_t len = STRLEN(line) + 1;"], "readability/bool"]
["src/nvim/spellfile.c", ["  // Write another byte to check for errors.", "  if (putc(0, fd) == EOF)", "    EMSG(_(e_write));"], "readability/braces"]
["src/nvim/spellfile.c", ["  vim_snprintf((char *)IObuff, IOSIZE,", "      _(\"Estimated runtime memory use: %d bytes\"), spin->si_memtot);", "  spell_message(spin, IObuff);"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["static void", "mkspell (", "    int fcount,"], "whitespace/parens"]
["src/nvim/spellfile.c", ["      vim_snprintf((char *)wfname, MAXPATHL, SPL_FNAME_TMPL,", "          fnames[0], spin.si_ascii ? (char_u *)\"ascii\" : spell_enc());", "    } else if (len > 4 && STRCMP(fnames[0] + len - 4, \".spl\") == 0)   {"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["      STRLCPY(wfname, fnames[0], MAXPATHL);", "    } else", "      // Name should be language, make the file name from it."], "readability/braces"]
["src/nvim/spellfile.c", ["      vim_snprintf((char *)wfname, MAXPATHL, SPL_FNAME_TMPL,", "          fnames[0], spin.si_ascii ? (char_u *)\"ascii\" : spell_enc());", ""], "whitespace/alignment"]
["src/nvim/spellfile.c", ["    // Check for .ascii.spl.", "    if (strstr((char *)path_tail(wfname), SPL_FNAME_ASCII) != NULL)", "      spin.si_ascii = true;"], "readability/braces"]
["src/nvim/spellfile.c", ["    // Check for .add.spl.", "    if (strstr((char *)path_tail(wfname), SPL_FNAME_ADD) != NULL)", "      spin.si_add = true;"], "readability/braces"]
["src/nvim/spellfile.c", ["    // Get the region names if there are more than 2 arguments.", "    for (i = 0; i < incount; ++i) {", "      afile[i] = NULL;"], "readability/increment"]
["src/nvim/spellfile.c", ["    // previously loaded spell file.", "    if (!spin.si_add)", "      spin.si_clear_chartab = true;"], "readability/braces"]
["src/nvim/spellfile.c", ["    // Words are stored in the case-folded and keep-case trees.", "    for (i = 0; i < incount && !error; ++i) {", "      spin.si_conv.vc_type = CONV_NONE;"], "readability/increment"]
["src/nvim/spellfile.c", ["        afile[i] = spell_read_aff(&spin, fname);", "        if (afile[i] == NULL)", "          error = true;"], "readability/braces"]
["src/nvim/spellfile.c", ["          error = true;", "        else {", "          // Read the .dic file and store the words in the trees."], "readability/braces"]
["src/nvim/spellfile.c", ["          error = true;", "        else {", "          // Read the .dic file and store the words in the trees."], "readability/braces"]
["src/nvim/spellfile.c", ["          vim_snprintf((char *)fname, MAXPATHL, \"%s.dic\",", "              innames[i]);", "          if (spell_read_dic(&spin, fname, afile[i]) == FAIL)"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["              innames[i]);", "          if (spell_read_dic(&spin, fname, afile[i]) == FAIL)", "            error = true;"], "readability/braces"]
["src/nvim/spellfile.c", ["        // the words in the trees.", "        if (spell_read_wordfile(&spin, innames[i]) == FAIL)", "          error = true;"], "readability/braces"]
["src/nvim/spellfile.c", ["", "    if (spin.si_compflags != NULL && spin.si_nobreak)", "      MSG(_(\"Warning: both compounding and NOBREAK specified\"));"], "readability/braces"]
["src/nvim/spellfile.c", ["      vim_snprintf((char *)IObuff, IOSIZE,", "          _(\"Estimated runtime memory use: %d bytes\"), spin.si_memtot);", "      spell_message(&spin, IObuff);"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["      // If the file is loaded need to reload it.", "      if (!error)", "        spell_reload_one(wfname, added_word);"], "readability/braces"]
["src/nvim/spellfile.c", ["    // Free the .aff file structures.", "    for (i = 0; i < incount; ++i)", "      if (afile[i] != NULL)"], "readability/braces"]
["src/nvim/spellfile.c", ["    // Free the .aff file structures.", "    for (i = 0; i < incount; ++i)", "      if (afile[i] != NULL)"], "readability/increment"]
["src/nvim/spellfile.c", ["    for (i = 0; i < incount; ++i)", "      if (afile[i] != NULL)", "        spell_free_aff(afile[i]);"], "readability/braces"]
["src/nvim/spellfile.c", ["    // .sug file with the soundfolded word trie.", "    if (spin.si_sugtime != 0 && !error && !got_int)", "      spell_make_sugfile(&spin, wfname);"], "readability/braces"]
["src/nvim/spellfile.c", ["      spell_make_sugfile(&spin, wfname);", "", "  }"], "whitespace/blank_line"]
["src/nvim/spellfile.c", ["  if (spin->si_verbose || p_verbose > 2) {", "    if (!spin->si_verbose)", "      verbose_enter();"], "readability/braces"]
["src/nvim/spellfile.c", ["    ui_flush();", "    if (!spin->si_verbose)", "      verbose_leave();"], "readability/braces"]
["src/nvim/spellfile.c", ["  spell_add_word(eap->arg, (int)STRLEN(eap->arg), eap->cmdidx == CMD_spellwrong,", "      eap->forceit ? 0 : (int)eap->line2,", "      eap->cmdidx == CMD_spellundo);"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["      eap->forceit ? 0 : (int)eap->line2,", "      eap->cmdidx == CMD_spellundo);", "}"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["void", "spell_add_word (", "    char_u *word,"], "whitespace/parens"]
["src/nvim/spellfile.c", ["      int_wordlist = vim_tempname();", "      if (int_wordlist == NULL)", "        return;"], "readability/braces"]
["src/nvim/spellfile.c", ["", "    for (spf = curwin->w_s->b_p_spf, i = 1; *spf != NUL; ++i) {", "      copy_option_part(&spf, fnamebuf, MAXPATHL, \",\");"], "readability/increment"]
["src/nvim/spellfile.c", ["      copy_option_part(&spf, fnamebuf, MAXPATHL, \",\");", "      if (i == idx)", "        break;"], "readability/braces"]
["src/nvim/spellfile.c", ["    buf = buflist_findname_exp(fnamebuf);", "    if (buf != NULL && buf->b_ml.ml_mfp == NULL)", "      buf = NULL;"], "readability/braces"]
["src/nvim/spellfile.c", ["            if (undo) {", "              home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);", "              smsg(_(\"Word '%.*s' removed from %s\"),"], "readability/bool"]
["src/nvim/spellfile.c", ["      }", "      if (fd != NULL)", "        fclose(fd);"], "readability/braces"]
["src/nvim/spellfile.c", ["      // init_spellfile().", "      if (!dir_of_file_exists(fname) && (p = path_tail_with_sep(fname)) != fname) {", "        int c = *p;"], "whitespace/line_length"]
["src/nvim/spellfile.c", ["", "    if (fd == NULL)", "      EMSG2(_(e_notopen), fname);"], "readability/braces"]
["src/nvim/spellfile.c", ["      EMSG2(_(e_notopen), fname);", "    else {", "      if (bad)"], "readability/braces"]
["src/nvim/spellfile.c", ["      EMSG2(_(e_notopen), fname);", "    else {", "      if (bad)"], "readability/braces"]
["src/nvim/spellfile.c", ["    else {", "      if (bad)", "        fprintf(fd, \"%.*s/!\\n\", len, word);"], "readability/braces"]
["src/nvim/spellfile.c", ["        fprintf(fd, \"%.*s/!\\n\", len, word);", "      else", "        fprintf(fd, \"%.*s\\n\", len, word);"], "readability/braces"]
["src/nvim/spellfile.c", ["", "      home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);", "      smsg(_(\"Word '%.*s' added to %s\"), len, word, NameBuff);"], "readability/bool"]
["src/nvim/spellfile.c", ["    // If the .add file is edited somewhere, reload it.", "    if (buf != NULL)", "      buf_reload(buf, buf->b_orig_mode);"], "readability/braces"]
["src/nvim/spellfile.c", ["    // is a path separator remember the start of the tail.", "    for (lend = curwin->w_s->b_p_spl; *lend != NUL", "         && vim_strchr((char_u *)\",._\", *lend) == NULL; ++lend)"], "readability/braces"]
["src/nvim/spellfile.c", ["    for (lend = curwin->w_s->b_p_spl; *lend != NUL", "         && vim_strchr((char_u *)\",._\", *lend) == NULL; ++lend)", "      if (vim_ispathsep(*lend)) {"], "readability/increment"]
["src/nvim/spellfile.c", ["    while (*rtp != NUL) {", "      if (aspath)", "        // Use directory of an entry with path, e.g., for"], "readability/braces"]
["src/nvim/spellfile.c", ["        STRLCPY(buf, curbuf->b_s.b_p_spl,", "            lstart - curbuf->b_s.b_p_spl);", "      else"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["            lstart - curbuf->b_s.b_p_spl);", "      else", "        // Copy the path from 'runtimepath' to buf[]."], "readability/braces"]
["src/nvim/spellfile.c", ["        // encoding used in the first loaded .spl file.", "        if (aspath)", "          STRLCPY(buf, curbuf->b_s.b_p_spl,"], "readability/braces"]
["src/nvim/spellfile.c", ["          STRLCPY(buf, curbuf->b_s.b_p_spl,", "              lend - curbuf->b_s.b_p_spl + 1);", "        else {"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["              lend - curbuf->b_s.b_p_spl + 1);", "        else {", "          // Create the \"spell\" directory if it doesn't exist yet."], "readability/braces"]
["src/nvim/spellfile.c", ["              lend - curbuf->b_s.b_p_spl + 1);", "        else {", "          // Create the \"spell\" directory if it doesn't exist yet."], "readability/braces"]
["src/nvim/spellfile.c", ["          vim_snprintf((char *)buf + l, MAXPATHL - l,", "              \"/%.*s\", (int)(lend - lstart), lstart);", "        }"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["static void", "set_spell_charflags (", "    char_u *flags,"], "whitespace/parens"]
["src/nvim/spellfile.c", ["", "  for (i = 0; i < 128; ++i) {", "    if (i < cnt) {"], "readability/increment"]
["src/nvim/spellfile.c", ["      new_st.st_fold[i + 128] = c;", "      if (i + 128 != c && new_st.st_isu[i + 128] && c < 256)", "        new_st.st_upper[c] = i + 128;"], "readability/braces"]
["src/nvim/spellfile.c", ["    // check that it's the same table", "    for (i = 0; i < 256; ++i) {", "      if (spelltab.st_isw[i] != new_st->st_isw[i]"], "readability/increment"]
["src/nvim/spellfile.c", ["", "  if (fd != NULL)", "    put_bytes(fd, (uintmax_t)gap->ga_len, 2);           // <prefcondcnt>"], "readability/braces"]
["src/nvim/spellfile.c", ["  size_t x = 1;  // collect return value of fwrite()", "  for (int i = 0; i < gap->ga_len; ++i) {", "    // <prefcond> : <condlen> <condstr>"], "readability/increment"]
["src/nvim/spellfile.c", ["      totlen += len;", "    } else if (fd != NULL)", "      fputc(0, fd);"], "readability/braces"]
["src/nvim/spellfile.c", ["  // Init the array and hash tables empty.", "  for (i = 0; i < 256; ++i)", "    lp->sl_map_array[i] = 0;"], "readability/braces"]
["src/nvim/spellfile.c", ["  // Init the array and hash tables empty.", "  for (i = 0; i < 256; ++i)", "    lp->sl_map_array[i] = 0;"], "readability/increment"]
["src/nvim/spellfile.c", ["        }", "      } else", "        lp->sl_map_array[c] = headc;"], "readability/braces"]
["src/nvim/strings.c", ["#include \"nvim/fold.h\"", "#include \"nvim/func_attr.h\"", "#include \"nvim/getchar.h\""], "build/include"]
["src/nvim/strings.c", ["  // and expect the remainder to be zeroed out.", "  return (char_u *)strncpy(xmallocz(len), (char *)string, len);", "}"], "runtime/printf"]
["src/nvim/strings.c", ["", "/*", " * Same as vim_strsave(), but any characters found in esc_chars are preceded"], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "/*", " * Same as vim_strsave_escaped(), but when \"bsl\" is true also escape"], "readability/old_style_comment"]
["src/nvim/strings.c", ["{", "  /*", "   * First count the number of backslashes required."], "readability/old_style_comment"]
["src/nvim/strings.c", ["    }", "    if (vim_strchr(esc_chars, *p) != NULL || (bsl && rem_backslash(p)))", "      ++length;                         /* count a backslash */"], "readability/braces"]
["src/nvim/strings.c", ["    if (vim_strchr(esc_chars, *p) != NULL || (bsl && rem_backslash(p)))", "      ++length;                         /* count a backslash */", "    ++length;                           /* count an ordinary char */"], "readability/old_style_comment"]
["src/nvim/strings.c", ["    if (vim_strchr(esc_chars, *p) != NULL || (bsl && rem_backslash(p)))", "      ++length;                         /* count a backslash */", "    ++length;                           /* count an ordinary char */"], "readability/increment"]
["src/nvim/strings.c", ["      ++length;                         /* count a backslash */", "    ++length;                           /* count an ordinary char */", "  }"], "readability/old_style_comment"]
["src/nvim/strings.c", ["      ++length;                         /* count a backslash */", "    ++length;                           /* count an ordinary char */", "  }"], "readability/increment"]
["src/nvim/strings.c", ["      p2 += l;", "      p += l - 1;                     /* skip multibyte char  */", "      continue;"], "readability/old_style_comment"]
["src/nvim/strings.c", ["    }", "    if (vim_strchr(esc_chars, *p) != NULL || (bsl && rem_backslash(p)))", "      *p2++ = cc;"], "readability/braces"]
["src/nvim/strings.c", ["", "/*", " * Escape \"string\" for use as a shell argument with system()."], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "  /* Only csh and similar shells expand '!' within single quotes.  For sh and", "   * the like we must not put a backslash before it, it will be taken"], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "  /* First count the number of extra bytes required. */", "  size_t length = STRLEN(string) + 3;       // two quotes and a trailing NUL"], "readability/old_style_comment"]
["src/nvim/strings.c", ["      }", "    } else", "#endif"], "readability/braces"]
["src/nvim/strings.c", ["        || (*p == '!' && (csh_like || do_special))) {", "      ++length;                         /* insert backslash */", "      if (csh_like && do_special)"], "readability/old_style_comment"]
["src/nvim/strings.c", ["        || (*p == '!' && (csh_like || do_special))) {", "      ++length;                         /* insert backslash */", "      if (csh_like && do_special)"], "readability/increment"]
["src/nvim/strings.c", ["      ++length;                         /* insert backslash */", "      if (csh_like && do_special)", "        ++length;                       /* insert backslash */"], "readability/braces"]
["src/nvim/strings.c", ["      if (csh_like && do_special)", "        ++length;                       /* insert backslash */", "    }"], "readability/old_style_comment"]
["src/nvim/strings.c", ["      if (csh_like && do_special)", "        ++length;                       /* insert backslash */", "    }"], "readability/increment"]
["src/nvim/strings.c", ["    if (do_special && find_cmdline_var(p, &l) >= 0) {", "      ++length;                         /* insert backslash */", "      p += l - 1;"], "readability/old_style_comment"]
["src/nvim/strings.c", ["    if (do_special && find_cmdline_var(p, &l) >= 0) {", "      ++length;                         /* insert backslash */", "      p += l - 1;"], "readability/increment"]
["src/nvim/strings.c", ["", "  /* Allocate memory for the result and fill it. */", "  escaped_string = xmalloc(length);"], "readability/old_style_comment"]
["src/nvim/strings.c", ["    *d++ = '\"';", "  } else", "#endif"], "readability/braces"]
["src/nvim/strings.c", ["      }", "    } else", "#endif"], "readability/braces"]
["src/nvim/strings.c", ["      *d++ = '\\'';", "      ++p;", "      continue;"], "readability/increment"]
["src/nvim/strings.c", ["      *d++ = '\\\\';", "      if (csh_like && do_special)", "        *d++ = '\\\\';"], "readability/braces"]
["src/nvim/strings.c", ["    if (do_special && find_cmdline_var(p, &l) >= 0) {", "      *d++ = '\\\\';                    /* insert backslash */", "      while (--l != SIZE_MAX)                /* copy the var */"], "readability/old_style_comment"]
["src/nvim/strings.c", ["      *d++ = '\\\\';                    /* insert backslash */", "      while (--l != SIZE_MAX)                /* copy the var */", "        *d++ = *p++;"], "readability/old_style_comment"]
["src/nvim/strings.c", ["      *d++ = '\\\\';                    /* insert backslash */", "      while (--l != SIZE_MAX)                /* copy the var */", "        *d++ = *p++;"], "readability/braces"]
["src/nvim/strings.c", ["    *d++ = '\"';", "  } else", "# endif"], "readability/braces"]
["src/nvim/strings.c", ["", "/*", " * Like vim_strsave(), but make all characters uppercase."], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "/*", " * Like vim_strnsave(), but make all characters uppercase."], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "/*", " * ASCII lower-to-upper case translation, language independent."], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "/*", " * delete spaces at the end of a string"], "readability/old_style_comment"]
["src/nvim/strings.c", ["  q = ptr + STRLEN(ptr);", "  while (--q > ptr && ascii_iswhite(q[0]) && q[-1] != '\\\\' && q[-1] != Ctrl_V)", "    *q = NUL;"], "readability/braces"]
["src/nvim/strings.c", ["#if (!defined(HAVE_STRCASECMP) && !defined(HAVE_STRICMP))", "/*", " * Compare two strings, ignoring case, using current locale."], "readability/old_style_comment"]
["src/nvim/strings.c", ["    i = (int)TOLOWER_LOC(*s1) - (int)TOLOWER_LOC(*s2);", "    if (i != 0)", "      return i;                             /* this character different */"], "readability/braces"]
["src/nvim/strings.c", ["    if (i != 0)", "      return i;                             /* this character different */", "    if (*s1 == NUL)"], "readability/old_style_comment"]
["src/nvim/strings.c", ["      return i;                             /* this character different */", "    if (*s1 == NUL)", "      break;                                /* strings match until NUL */"], "readability/braces"]
["src/nvim/strings.c", ["    if (*s1 == NUL)", "      break;                                /* strings match until NUL */", "    ++s1;"], "readability/old_style_comment"]
["src/nvim/strings.c", ["      break;                                /* strings match until NUL */", "    ++s1;", "    ++s2;"], "readability/increment"]
["src/nvim/strings.c", ["    ++s1;", "    ++s2;", "  }"], "readability/increment"]
["src/nvim/strings.c", ["  }", "  return 0;                                 /* strings match */", "}"], "readability/old_style_comment"]
["src/nvim/strings.c", ["#if (!defined(HAVE_STRNCASECMP) && !defined(HAVE_STRNICMP))", "/*", " * Compare two strings, for length \"len\", ignoring case, using current locale."], "readability/old_style_comment"]
["src/nvim/strings.c", ["    i = (int)TOLOWER_LOC(*s1) - (int)TOLOWER_LOC(*s2);", "    if (i != 0)", "      return i;                             /* this character different */"], "readability/braces"]
["src/nvim/strings.c", ["    if (i != 0)", "      return i;                             /* this character different */", "    if (*s1 == NUL)"], "readability/old_style_comment"]
["src/nvim/strings.c", ["      return i;                             /* this character different */", "    if (*s1 == NUL)", "      break;                                /* strings match until NUL */"], "readability/braces"]
["src/nvim/strings.c", ["    if (*s1 == NUL)", "      break;                                /* strings match until NUL */", "    ++s1;"], "readability/old_style_comment"]
["src/nvim/strings.c", ["      break;                                /* strings match until NUL */", "    ++s1;", "    ++s2;"], "readability/increment"]
["src/nvim/strings.c", ["    ++s1;", "    ++s2;", "    --len;"], "readability/increment"]
["src/nvim/strings.c", ["    ++s2;", "    --len;", "  }"], "readability/increment"]
["src/nvim/strings.c", ["  }", "  return 0;                                 /* strings match */", "}"], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "/*", " * Sort an array of strings."], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "/*", " * Return true if string \"s\" contains a non-ASCII character (128 or higher)."], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "  if (s != NULL)", "    for (p = s; *p != NUL; ++p)"], "readability/braces"]
["src/nvim/strings.c", ["  if (s != NULL)", "    for (p = s; *p != NUL; ++p)", "      if (*p >= 128)"], "readability/braces"]
["src/nvim/strings.c", ["  if (s != NULL)", "    for (p = s; *p != NUL; ++p)", "      if (*p >= 128)"], "readability/increment"]
["src/nvim/strings.c", ["    for (p = s; *p != NUL; ++p)", "      if (*p >= 128)", "        return true;"], "readability/braces"]
["src/nvim/strings.c", ["    for (size_t i = 0; i < len; i++) {", "      if ((uint8_t) s[i] >= 128) {", "        return true;"], "whitespace/cast"]
["src/nvim/strings.c", ["", "/*", " * Concatenate two strings and return the result in allocated memory."], "readability/old_style_comment"]
["src/nvim/strings.c", ["        switch (*p) {", "          case '0': zero_padding = 1; p++; continue;", "          case '-': justify_left = 1; p++; continue;"], "whitespace/newline"]
["src/nvim/strings.c", ["          case '0': zero_padding = 1; p++; continue;", "          case '-': justify_left = 1; p++; continue;", "                    // if both '0' and '-' flags appear, '0' should be ignored"], "whitespace/newline"]
["src/nvim/strings.c", ["          case '#': alternate_form = 1; p++; continue;", "          case '\\'': p++; continue;", "          default: break;"], "whitespace/newline"]
["src/nvim/strings.c", ["  return (int)str_l;", "}", ""], "readability/fn_size"]
["src/nvim/syntax.c", ["", "/*", " * syntax.c: code for syntax highlighting"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "#define MAX_HL_ID       20000   /* maximum value for a highlight ID. */", ""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/* different types of offsets that are possible */", "#define SPO_MS_OFF      0       /* match  start offset */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["/* different types of offsets that are possible */", "#define SPO_MS_OFF      0       /* match  start offset */", "#define SPO_ME_OFF      1       /* match  end\toffset */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define SPO_MS_OFF      0       /* match  start offset */", "#define SPO_ME_OFF      1       /* match  end\toffset */", "#define SPO_HS_OFF      2       /* highl. start offset */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define SPO_MS_OFF      0       /* match  start offset */", "#define SPO_ME_OFF      1       /* match  end\toffset */", "#define SPO_HS_OFF      2       /* highl. start offset */"], "whitespace/tab"]
["src/nvim/syntax.c", ["#define SPO_ME_OFF      1       /* match  end\toffset */", "#define SPO_HS_OFF      2       /* highl. start offset */", "#define SPO_HE_OFF      3       /* highl. end\toffset */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define SPO_HS_OFF      2       /* highl. start offset */", "#define SPO_HE_OFF      3       /* highl. end\toffset */", "#define SPO_RS_OFF      4       /* region start offset */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define SPO_HS_OFF      2       /* highl. start offset */", "#define SPO_HE_OFF      3       /* highl. end\toffset */", "#define SPO_RS_OFF      4       /* region start offset */"], "whitespace/tab"]
["src/nvim/syntax.c", ["#define SPO_HE_OFF      3       /* highl. end\toffset */", "#define SPO_RS_OFF      4       /* region start offset */", "#define SPO_RE_OFF      5       /* region end\toffset */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define SPO_RS_OFF      4       /* region start offset */", "#define SPO_RE_OFF      5       /* region end\toffset */", "#define SPO_LC_OFF      6       /* leading context offset */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define SPO_RS_OFF      4       /* region start offset */", "#define SPO_RE_OFF      5       /* region end\toffset */", "#define SPO_LC_OFF      6       /* leading context offset */"], "whitespace/tab"]
["src/nvim/syntax.c", ["#define SPO_RE_OFF      5       /* region end\toffset */", "#define SPO_LC_OFF      6       /* leading context offset */", "#define SPO_COUNT       7"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/* Flags to indicate an additional string for highlight name completion. */", "static int include_none = 0;    /* when 1 include \"nvim/None\" */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["/* Flags to indicate an additional string for highlight name completion. */", "static int include_none = 0;    /* when 1 include \"nvim/None\" */", "static int include_default = 0; /* when 1 include \"nvim/default\" */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static int include_none = 0;    /* when 1 include \"nvim/None\" */", "static int include_default = 0; /* when 1 include \"nvim/default\" */", "static int include_link = 0;    /* when 2 include \"nvim/link\" and \"clear\" */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static int include_default = 0; /* when 1 include \"nvim/default\" */", "static int include_link = 0;    /* when 2 include \"nvim/link\" and \"clear\" */", ""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * For the current state we need to remember more than just the idx."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Struct to reduce the number of arguments to get_syn_options(), it's used"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static char *(spo_name_tab[SPO_COUNT]) =", "{\"ms=\", \"me=\", \"hs=\", \"he=\", \"rs=\", \"re=\", \"lc=\"};", ""], "whitespace/braces"]
["src/nvim/syntax.c", ["static char *(spo_name_tab[SPO_COUNT]) =", "{\"ms=\", \"me=\", \"hs=\", \"he=\", \"rs=\", \"re=\", \"lc=\"};", ""], "whitespace/braces"]
["src/nvim/syntax.c", ["", "/* The sp_off_flags are computed like this:", " * offset from the start of the matched text: (1 << SPO_XX_OFF)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "#define SPTYPE_MATCH    1       /* match keyword with this group ID */", "#define SPTYPE_START    2       /* match a regexp, start of item */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define SPTYPE_MATCH    1       /* match keyword with this group ID */", "#define SPTYPE_START    2       /* match a regexp, start of item */", "#define SPTYPE_END      3       /* match a regexp, end of item */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define SPTYPE_START    2       /* match a regexp, start of item */", "#define SPTYPE_END      3       /* match a regexp, end of item */", "#define SPTYPE_SKIP     4       /* match a regexp, skip within item */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define SPTYPE_END      3       /* match a regexp, end of item */", "#define SPTYPE_SKIP     4       /* match a regexp, skip within item */", ""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "#define NONE_IDX        -2      /* value of sp_sync_idx for \"NONE\" */", ""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Flags for b_syn_sync_flags:"], "readability/old_style_comment"]
["src/nvim/syntax.c", [" */", "#define SF_CCOMMENT     0x01    /* sync on a C-style comment */", "#define SF_MATCH        0x02    /* sync by matching a pattern */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define SF_CCOMMENT     0x01    /* sync on a C-style comment */", "#define SF_MATCH        0x02    /* sync by matching a pattern */", ""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "#define MAXKEYWLEN      80          /* maximum length of a keyword */", ""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * The attributes of the syntax item that has been recognized."], "readability/old_style_comment"]
["src/nvim/syntax.c", [" */", "static int current_attr = 0;        /* attr of current syntax word */", "static int current_id = 0;          /* ID of current char for syn_get_id() */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static int current_attr = 0;        /* attr of current syntax word */", "static int current_id = 0;          /* ID of current char for syn_get_id() */", "static int current_trans_id = 0;    /* idem, transparency removed */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static int current_id = 0;          /* ID of current char for syn_get_id() */", "static int current_trans_id = 0;    /* idem, transparency removed */", "static int current_flags = 0;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Methods of combining two clusters"], "readability/old_style_comment"]
["src/nvim/syntax.c", [" */", "#define CLUSTER_REPLACE     1   /* replace first list with second */", "#define CLUSTER_ADD         2   /* add second list to first */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define CLUSTER_REPLACE     1   /* replace first list with second */", "#define CLUSTER_ADD         2   /* add second list to first */", "#define CLUSTER_SUBTRACT    3   /* subtract second list from first */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define CLUSTER_ADD         2   /* add second list to first */", "#define CLUSTER_SUBTRACT    3   /* subtract second list from first */", ""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Syntax group IDs have different types:"], "readability/old_style_comment"]
["src/nvim/syntax.c", [" */", "#define SYNID_ALLBUT    MAX_HL_ID   /* syntax group ID for contains=ALLBUT */", "#define SYNID_TOP       21000       /* syntax group ID for contains=TOP */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define SYNID_ALLBUT    MAX_HL_ID   /* syntax group ID for contains=ALLBUT */", "#define SYNID_TOP       21000       /* syntax group ID for contains=TOP */", "#define SYNID_CONTAINED 22000       /* syntax group ID for contains=CONTAINED */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define SYNID_TOP       21000       /* syntax group ID for contains=TOP */", "#define SYNID_CONTAINED 22000       /* syntax group ID for contains=CONTAINED */", "#define SYNID_CLUSTER   23000       /* first syntax group ID for clusters */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define SYNID_CONTAINED 22000       /* syntax group ID for contains=CONTAINED */", "#define SYNID_CLUSTER   23000       /* first syntax group ID for clusters */", ""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "#define MAX_SYN_INC_TAG 999         /* maximum before the above overflow */", "#define MAX_CLUSTER_ID  (32767 - SYNID_CLUSTER)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Annoying Hack(TM):  \":syn include\" needs this pointer to pass to"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Another Annoying Hack(TM):  To prevent rules from other \":syn include\"'d"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * In a hashtable item \"hi_key\" points to \"keyword\" in a keyentry."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define KE2HIKEY(kp)  ((kp)->keyword)", "#define HIKEY2KE(p)   ((keyentry_T *)((p) - (dumkey.keyword - (char_u *)&dumkey)))", "#define HI2KE(hi)      HIKEY2KE((hi)->hi_key)"], "whitespace/line_length"]
["src/nvim/syntax.c", ["", "/*", " * To reduce the time spent in keepend(), remember at which level in the state"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "static int next_seqnr = 1;              /* value to use for si_seqnr */", ""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * The next possible match in the current line for any pattern is remembered,"], "readability/old_style_comment"]
["src/nvim/syntax.c", [" */", "static int next_match_col;              /* column for start of next match */", "static lpos_T next_match_m_endpos;      /* position for end of next match */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static int next_match_col;              /* column for start of next match */", "static lpos_T next_match_m_endpos;      /* position for end of next match */", "static lpos_T next_match_h_startpos;  /* pos. for highl. start of next match */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static lpos_T next_match_m_endpos;      /* position for end of next match */", "static lpos_T next_match_h_startpos;  /* pos. for highl. start of next match */", "static lpos_T next_match_h_endpos;      /* pos. for highl. end of next match */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static lpos_T next_match_h_startpos;  /* pos. for highl. start of next match */", "static lpos_T next_match_h_endpos;      /* pos. for highl. end of next match */", "static int next_match_idx;              /* index of matched item */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static lpos_T next_match_h_endpos;      /* pos. for highl. end of next match */", "static int next_match_idx;              /* index of matched item */", "static long next_match_flags;           /* flags for next match */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static int next_match_idx;              /* index of matched item */", "static long next_match_flags;           /* flags for next match */", "static lpos_T next_match_eos_pos;       /* end of start pattn (start region) */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static long next_match_flags;           /* flags for next match */", "static lpos_T next_match_eos_pos;       /* end of start pattn (start region) */", "static lpos_T next_match_eoe_pos;       /* pos. for end of end pattern */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static lpos_T next_match_eos_pos;       /* end of start pattn (start region) */", "static lpos_T next_match_eoe_pos;       /* pos. for end of end pattern */", "static int next_match_end_idx;          /* ID of group for end pattn or zero */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static lpos_T next_match_eoe_pos;       /* pos. for end of end pattern */", "static int next_match_end_idx;          /* ID of group for end pattn or zero */", "static reg_extmatch_T *next_match_extmatch = NULL;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * A state stack is an array of integers or stateitem_T, stored in a"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * The current state (within the line) of the recognition engine."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "static int syn_time_on = FALSE;", "# define IF_SYN_TIME(p) (p)"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Start the syntax recognition for a line.  This function is normally called"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  int dist;", "  static int changedtick = 0;           /* remember the last change ID */", ""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * After switching buffers, invalidate current_state."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Allocate syntax stack when needed."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  syn_stack_alloc();", "  if (syn_block->b_sst_array == NULL)", "    return;             /* out of memory */"], "readability/braces"]
["src/nvim/syntax.c", ["  if (syn_block->b_sst_array == NULL)", "    return;             /* out of memory */", "  syn_block->b_sst_lasttick = display_tick;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * If the state of the end of the previous line is useful, store it."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (!current_state_stored) {", "      ++current_lnum;", "      (void)store_current_state();"], "readability/increment"]
["src/nvim/syntax.c", ["", "    /*", "     * If the current_lnum is now the same as \"lnum\", keep the current"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["     */", "    if (current_lnum != lnum)", "      invalidate_current_state();"], "readability/braces"]
["src/nvim/syntax.c", ["      invalidate_current_state();", "  } else", "    invalidate_current_state();"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * Try to synchronize from a saved state in b_sst_array[]."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (INVALID_STATE(&current_state) && syn_block->b_sst_array != NULL) {", "    /* Find last valid saved state before start_lnum. */", "    for (p = syn_block->b_sst_first; p != NULL; p = p->sst_next) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        last_valid = p;", "        if (p->sst_lnum >= lnum - syn_block->b_syn_sync_minlines)", "          last_min_valid = p;"], "readability/braces"]
["src/nvim/syntax.c", ["    }", "    if (last_min_valid != NULL)", "      load_current_state(last_min_valid);"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * If \"lnum\" is before or far beyond a line with a saved state, need to"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    syn_sync(wp, lnum, last_valid);", "    if (current_lnum == 1)", "      /* First line is always valid, no matter \"minlines\". */"], "readability/braces"]
["src/nvim/syntax.c", ["    if (current_lnum == 1)", "      /* First line is always valid, no matter \"minlines\". */", "      first_stored = 1;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      first_stored = 1;", "    else", "      /* Need to parse \"minlines\" lines before state can be considered"], "readability/braces"]
["src/nvim/syntax.c", ["    else", "      /* Need to parse \"minlines\" lines before state can be considered", "       * valid to store. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      first_stored = current_lnum + syn_block->b_syn_sync_minlines;", "  } else", "    first_stored = current_lnum;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * Advance from the sync point or saved state until the current line."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  if (syn_block->b_sst_len <= Rows)", "    dist = 999999;"], "readability/braces"]
["src/nvim/syntax.c", ["    dist = 999999;", "  else", "    dist = syn_buf->b_ml.ml_line_count / (syn_block->b_sst_len - Rows) + 1;"], "readability/braces"]
["src/nvim/syntax.c", ["", "    /* If we parsed at least \"minlines\" lines or started at a valid", "     * state, the current state is considered valid. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (current_lnum >= first_stored) {", "      /* Check if the saved state entry is for the current line and is", "       * equal to the current state.  If so, then validate all saved"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["       * states that depended on a change before the parsed line. */", "      if (prev == NULL)", "        prev = syn_stack_find_entry(current_lnum - 1);"], "readability/braces"]
["src/nvim/syntax.c", ["        prev = syn_stack_find_entry(current_lnum - 1);", "      if (prev == NULL)", "        sp = syn_block->b_sst_first;"], "readability/braces"]
["src/nvim/syntax.c", ["        sp = syn_block->b_sst_first;", "      else", "        sp = prev;"], "readability/braces"]
["src/nvim/syntax.c", ["        sp = prev;", "      while (sp != NULL && sp->sst_lnum < current_lnum)", "        sp = sp->sst_next;"], "readability/braces"]
["src/nvim/syntax.c", ["        while (sp != NULL && sp->sst_change_lnum <= parsed_lnum) {", "          if (sp->sst_lnum <= lnum)", "            /* valid state before desired line, use this one */"], "readability/braces"]
["src/nvim/syntax.c", ["          if (sp->sst_lnum <= lnum)", "            /* valid state before desired line, use this one */", "            prev = sp;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["            prev = sp;", "          else if (sp->sst_change_lnum == 0)", "            /* past saved states depending on change, break here. */"], "readability/braces"]
["src/nvim/syntax.c", ["          else if (sp->sst_change_lnum == 0)", "            /* past saved states depending on change, break here. */", "            break;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      }", "      /* Store the state at this line when it's the first one, the line", "       * where we start parsing, or some distance from the previously"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["       * saved state.  But only when parsed at least 'minlines'. */", "      else if (prev == NULL", "               || current_lnum == lnum"], "whitespace/newline"]
["src/nvim/syntax.c", ["", "    /* This can take a long time: break when CTRL-C pressed.  The current", "     * state will be wrong then. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * We cannot simply discard growarrays full of state_items or buf_states; we"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Cleanup the current_state stack."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Try to find a synchronisation point for line \"lnum\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Clear any current state that might be hanging around."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Start at least \"minlines\" back.  Default starting point for parsing is"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  if (syn_block->b_syn_sync_minlines > start_lnum)", "    start_lnum = 1;"], "readability/braces"]
["src/nvim/syntax.c", ["    start_lnum = 1;", "  else {", "    if (syn_block->b_syn_sync_minlines == 1)"], "readability/braces"]
["src/nvim/syntax.c", ["    start_lnum = 1;", "  else {", "    if (syn_block->b_syn_sync_minlines == 1)"], "readability/braces"]
["src/nvim/syntax.c", ["  else {", "    if (syn_block->b_syn_sync_minlines == 1)", "      lnum = 1;"], "readability/braces"]
["src/nvim/syntax.c", ["      lnum = 1;", "    else if (syn_block->b_syn_sync_minlines < 10)", "      lnum = syn_block->b_syn_sync_minlines * 2;"], "readability/braces"]
["src/nvim/syntax.c", ["      lnum = syn_block->b_syn_sync_minlines * 2;", "    else", "      lnum = syn_block->b_syn_sync_minlines * 3 / 2;"], "readability/braces"]
["src/nvim/syntax.c", ["      lnum = syn_block->b_syn_sync_minlines * 3 / 2;", "    if (syn_block->b_syn_sync_maxlines != 0", "        && lnum > syn_block->b_syn_sync_maxlines)"], "readability/braces"]
["src/nvim/syntax.c", ["      lnum = syn_block->b_syn_sync_maxlines;", "    if (lnum >= start_lnum)", "      start_lnum = 1;"], "readability/braces"]
["src/nvim/syntax.c", ["      start_lnum = 1;", "    else", "      start_lnum -= lnum;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * 1. Search backwards for the end of a C-style comment."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (syn_block->b_syn_sync_flags & SF_CCOMMENT) {", "    /* Need to make syn_buf the current buffer for a moment, to be able to", "     * use find_start_comment(). */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * Skip lines that end in a backslash."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["     */", "    for (; start_lnum > 1; --start_lnum) {", "      line = ml_get(start_lnum - 1);"], "readability/increment"]
["src/nvim/syntax.c", ["      line = ml_get(start_lnum - 1);", "      if (*line == NUL || *(line + STRLEN(line) - 1) != '\\\\')", "        break;"], "readability/braces"]
["src/nvim/syntax.c", ["", "    /* set cursor to start of search */", "    cursor_save = wp->w_cursor;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * If the line is inside a comment, need to find the syntax item that"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (find_start_comment((int)syn_block->b_syn_sync_maxlines) != NULL) {", "      for (idx = syn_block->b_syn_patterns.ga_len; --idx >= 0; )", "        if (SYN_ITEMS(syn_block)[idx].sp_syn.id"], "readability/braces"]
["src/nvim/syntax.c", ["", "    /* restore cursor and buffer */", "    wp->w_cursor = cursor_save;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  }", "  /*", "   * 2. Search backwards for given sync patterns."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  else if (syn_block->b_syn_sync_flags & SF_MATCH) {", "    if (syn_block->b_syn_sync_maxlines != 0"], "whitespace/newline"]
["src/nvim/syntax.c", ["  else if (syn_block->b_syn_sync_flags & SF_MATCH) {", "    if (syn_block->b_syn_sync_maxlines != 0", "        && start_lnum > syn_block->b_syn_sync_maxlines)"], "readability/braces"]
["src/nvim/syntax.c", ["      break_lnum = start_lnum - syn_block->b_syn_sync_maxlines;", "    else", "      break_lnum = 0;"], "readability/braces"]
["src/nvim/syntax.c", ["    while (--lnum > break_lnum) {", "      /* This can take a long time: break when CTRL-C pressed. */", "      line_breakcheck();"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "      /* Check if we have run into a valid saved state stack now. */", "      if (last_valid != NULL && lnum == last_valid->sst_lnum) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "      /*", "       * Check if the previous line has the line-continuation pattern."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["       */", "      if (lnum > 1 && syn_match_linecont(lnum - 1))", "        continue;"], "readability/braces"]
["src/nvim/syntax.c", ["", "      /*", "       * Start with nothing on the state stack"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "      for (current_lnum = lnum; current_lnum < end_lnum; ++current_lnum) {", "        syn_start_line();"], "readability/increment"]
["src/nvim/syntax.c", ["            if (cur_si->si_m_endpos.lnum > start_lnum) {", "              /* ignore match that goes to after where started */", "              current_lnum = end_lnum;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["            if (cur_si->si_idx < 0) {", "              /* Cannot happen? */", "              found_flags = 0;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["            found_m_endpos = cur_si->si_m_endpos;", "            /*", "             * Continue after the match (be aware of a zero-length"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["              current_col = found_m_endpos.col;", "              if (current_lnum >= end_lnum)", "                break;"], "readability/braces"]
["src/nvim/syntax.c", ["                break;", "            } else if (found_m_endpos.col > current_col)", "              current_col = found_m_endpos.col;"], "readability/braces"]
["src/nvim/syntax.c", ["              current_col = found_m_endpos.col;", "            else", "              ++current_col;"], "readability/braces"]
["src/nvim/syntax.c", ["            else", "              ++current_col;", ""], "readability/increment"]
["src/nvim/syntax.c", ["", "            /* syn_current_attr() will have skipped the check for", "             * an item that ends here, need to do that now.  Be"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["            prev_current_col = current_col;", "            if (syn_getcurline()[current_col] != NUL)", "              ++current_col;"], "readability/braces"]
["src/nvim/syntax.c", ["            if (syn_getcurline()[current_col] != NUL)", "              ++current_col;", "            check_state_ends();"], "readability/increment"]
["src/nvim/syntax.c", ["            current_col = prev_current_col;", "          } else", "            break;"], "readability/braces"]
["src/nvim/syntax.c", ["", "      /*", "       * If a sync point was encountered, break here."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (found_flags) {", "        /*", "         * Put the item that was specified by the sync point on the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "        /*", "         * When using \"grouphere\", continue from the sync point"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["            cur_si->si_h_startpos.col = found_current_col;", "            update_si_end(cur_si, (int)current_col, TRUE);", "            check_keepend();"], "readability/bool"]
["src/nvim/syntax.c", ["", "    /* Ran into start of the file or exceeded maximum number of lines */", "    if (lnum <= break_lnum) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Return TRUE if the line-continuation pattern matches in line \"lnum\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Prepare the current state for the start of a line."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["{", "  current_finished = FALSE;", "  current_col = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /*", "   * Need to update the end of a start/skip/end that continues from the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (!GA_EMPTY(&current_state)) {", "    syn_update_ends(TRUE);", "    check_state_ends();"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Check for items in the stack that need their end updated."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (startofline) {", "    /* Check for a match carried over from a previous line with a", "     * contained region.  The match ends as soon as the region ends. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["     * contained region.  The match ends as soon as the region ends. */", "    for (int i = 0; i < current_state.ga_len; ++i) {", "      cur_si = &CUR_STATE(i);"], "readability/increment"]
["src/nvim/syntax.c", ["        cur_si->si_h_endpos = cur_si->si_m_endpos;", "        cur_si->si_ends = TRUE;", "      }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /*", "   * Need to update the end of a start/skip/end that continues from the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  int i = current_state.ga_len - 1;", "  if (keepend_level >= 0)", "    for (; i > keepend_level; --i)"], "readability/braces"]
["src/nvim/syntax.c", ["  if (keepend_level >= 0)", "    for (; i > keepend_level; --i)", "      if (CUR_STATE(i).si_flags & HL_EXTEND)"], "readability/braces"]
["src/nvim/syntax.c", ["  if (keepend_level >= 0)", "    for (; i > keepend_level; --i)", "      if (CUR_STATE(i).si_flags & HL_EXTEND)"], "readability/increment"]
["src/nvim/syntax.c", ["    for (; i > keepend_level; --i)", "      if (CUR_STATE(i).si_flags & HL_EXTEND)", "        break;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  seen_keepend = FALSE;", "  for (; i < current_state.ga_len; ++i) {"], "readability/bool"]
["src/nvim/syntax.c", ["  seen_keepend = FALSE;", "  for (; i < current_state.ga_len; ++i) {", "    cur_si = &CUR_STATE(i);"], "readability/increment"]
["src/nvim/syntax.c", ["        || (i == current_state.ga_len - 1 && startofline)) {", "      cur_si->si_h_startpos.col = 0;            /* start highl. in col 0 */", "      cur_si->si_h_startpos.lnum = current_lnum;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "      if (!(cur_si->si_flags & HL_MATCHCONT))", "        update_si_end(cur_si, (int)current_col, !startofline);"], "readability/braces"]
["src/nvim/syntax.c", ["", "      if (!startofline && (cur_si->si_flags & HL_KEEPEND))", "        seen_keepend = TRUE;"], "readability/braces"]
["src/nvim/syntax.c", ["      if (!startofline && (cur_si->si_flags & HL_KEEPEND))", "        seen_keepend = TRUE;", "    }"], "readability/bool"]
["src/nvim/syntax.c", ["", "/****************************************", " * Handling of the state stack cache."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * EXPLANATION OF THE SYNTAX STATE STACK CACHE"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["}", "/*", " * Free b_sst_array[] for buffer \"buf\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* When using \"syntax\" fold method, must update all folds. */", "  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Allocate the syntax state stack for syn_buf when needed."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  len = syn_buf->b_ml.ml_line_count / SST_DIST + Rows * 2;", "  if (len < SST_MIN_ENTRIES)", "    len = SST_MIN_ENTRIES;"], "readability/braces"]
["src/nvim/syntax.c", ["    len = SST_MIN_ENTRIES;", "  else if (len > SST_MAX_ENTRIES)", "    len = SST_MAX_ENTRIES;"], "readability/braces"]
["src/nvim/syntax.c", ["  if (syn_block->b_sst_len > len * 2 || syn_block->b_sst_len < len) {", "    /* Allocate 50% too much, to avoid reallocating too often. */", "    len = syn_buf->b_ml.ml_line_count;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    len = (len + len / 2) / SST_DIST + Rows * 2;", "    if (len < SST_MIN_ENTRIES)", "      len = SST_MIN_ENTRIES;"], "readability/braces"]
["src/nvim/syntax.c", ["      len = SST_MIN_ENTRIES;", "    else if (len > SST_MAX_ENTRIES)", "      len = SST_MAX_ENTRIES;"], "readability/braces"]
["src/nvim/syntax.c", ["    if (syn_block->b_sst_array != NULL) {", "      /* When shrinking the array, cleanup the existing stack.", "       * Make sure that all valid entries fit in the new array. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["       * Make sure that all valid entries fit in the new array. */", "      while (syn_block->b_sst_len - syn_block->b_sst_freecount + 2 > len", "             && syn_stack_cleanup())"], "readability/braces"]
["src/nvim/syntax.c", ["             && syn_stack_cleanup())", "        ;", "      if (len < syn_block->b_sst_len - syn_block->b_sst_freecount + 2)"], "whitespace/semicolon"]
["src/nvim/syntax.c", ["        ;", "      if (len < syn_block->b_sst_len - syn_block->b_sst_freecount + 2)", "        len = syn_block->b_sst_len - syn_block->b_sst_freecount + 2;"], "readability/braces"]
["src/nvim/syntax.c", ["    if (syn_block->b_sst_array != NULL) {", "      /* Move the states from the old array to the new one. */", "      for (from = syn_block->b_sst_first; from != NULL;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["           from = from->sst_next) {", "        ++to;", "        *to = *from;"], "readability/increment"]
["src/nvim/syntax.c", ["", "    /* Create the list of free entries. */", "    syn_block->b_sst_firstfree = to + 1;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    syn_block->b_sst_firstfree = to + 1;", "    while (++to < sstp + len)", "      to->sst_next = to + 1;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Check for changes in a buffer to affect stored syntax states.  Uses the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (n <= buf->b_mod_bot) {", "        /* this state is inside the changed area, remove it */", "        np = p->sst_next;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        np = p->sst_next;", "        if (prev == NULL)", "          block->b_sst_first = np;"], "readability/braces"]
["src/nvim/syntax.c", ["          block->b_sst_first = np;", "        else", "          prev->sst_next = np;"], "readability/braces"]
["src/nvim/syntax.c", ["      }", "      /* This state is below the changed area.  Remember the line", "       * that needs to be parsed before this entry can be made valid"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (p->sst_change_lnum != 0 && p->sst_change_lnum > buf->b_mod_top) {", "        if (p->sst_change_lnum + buf->b_mod_xlines > buf->b_mod_top)", "          p->sst_change_lnum += buf->b_mod_xlines;"], "readability/braces"]
["src/nvim/syntax.c", ["          p->sst_change_lnum += buf->b_mod_xlines;", "        else", "          p->sst_change_lnum = buf->b_mod_top;"], "readability/braces"]
["src/nvim/syntax.c", ["      }", "      if (p->sst_change_lnum == 0", "          || p->sst_change_lnum < buf->b_mod_bot)"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Reduce the number of entries in the state stack for syn_buf."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  int dist;", "  int retval = FALSE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["", "  /* Compute normal distance between non-displayed entries. */", "  if (syn_block->b_sst_len <= Rows)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  /* Compute normal distance between non-displayed entries. */", "  if (syn_block->b_sst_len <= Rows)", "    dist = 999999;"], "readability/braces"]
["src/nvim/syntax.c", ["    dist = 999999;", "  else", "    dist = syn_buf->b_ml.ml_line_count / (syn_block->b_sst_len - Rows) + 1;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * Go through the list to find the \"tick\" for the oldest entry that can"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  tick = syn_block->b_sst_lasttick;", "  above = FALSE;", "  prev = syn_block->b_sst_first;"], "readability/bool"]
["src/nvim/syntax.c", ["      if (p->sst_tick > syn_block->b_sst_lasttick) {", "        if (!above || p->sst_tick < tick)", "          tick = p->sst_tick;"], "readability/braces"]
["src/nvim/syntax.c", ["          tick = p->sst_tick;", "        above = TRUE;", "      } else if (!above && p->sst_tick < tick)"], "readability/bool"]
["src/nvim/syntax.c", ["        above = TRUE;", "      } else if (!above && p->sst_tick < tick)", "        tick = p->sst_tick;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * Go through the list to make the entries for the oldest tick at an"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (p->sst_tick == tick && prev->sst_lnum + dist > p->sst_lnum) {", "      /* Move this entry from used list to free list */", "      prev->sst_next = p->sst_next;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      p = prev;", "      retval = TRUE;", "    }"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Free the allocated memory for a syn_state item."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  block->b_sst_firstfree = p;", "  ++block->b_sst_freecount;", "}"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Find an entry in the list of state stacks at or before \"lnum\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  for (p = syn_block->b_sst_first; p != NULL; prev = p, p = p->sst_next) {", "    if (p->sst_lnum == lnum)", "      return p;"], "readability/braces"]
["src/nvim/syntax.c", ["      return p;", "    if (p->sst_lnum > lnum)", "      break;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Try saving the current state in b_sst_array[]."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * If the current state contains a start or end pattern that continues"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  for (i = current_state.ga_len - 1; i >= 0; --i) {", "    cur_si = &CUR_STATE(i);"], "readability/increment"]
["src/nvim/syntax.c", ["    cur_si = &CUR_STATE(i);", "    if (cur_si->si_h_startpos.lnum >= current_lnum", "        || cur_si->si_m_endpos.lnum >= current_lnum"], "readability/braces"]
["src/nvim/syntax.c", ["    if (sp != NULL) {", "      /* find \"sp\" in the list and remove it */", "      if (syn_block->b_sst_first == sp)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      /* find \"sp\" in the list and remove it */", "      if (syn_block->b_sst_first == sp)", "        /* it's the first entry */"], "readability/braces"]
["src/nvim/syntax.c", ["      if (syn_block->b_sst_first == sp)", "        /* it's the first entry */", "        syn_block->b_sst_first = sp->sst_next;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        syn_block->b_sst_first = sp->sst_next;", "      else {", "        /* find the entry just before this one to adjust sst_next */"], "readability/braces"]
["src/nvim/syntax.c", ["        syn_block->b_sst_first = sp->sst_next;", "      else {", "        /* find the entry just before this one to adjust sst_next */"], "readability/braces"]
["src/nvim/syntax.c", ["      else {", "        /* find the entry just before this one to adjust sst_next */", "        for (p = syn_block->b_sst_first; p != NULL; p = p->sst_next)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        /* find the entry just before this one to adjust sst_next */", "        for (p = syn_block->b_sst_first; p != NULL; p = p->sst_next)", "          if (p->sst_next == sp)"], "readability/braces"]
["src/nvim/syntax.c", ["        for (p = syn_block->b_sst_first; p != NULL; p = p->sst_next)", "          if (p->sst_next == sp)", "            break;"], "readability/braces"]
["src/nvim/syntax.c", ["            break;", "        if (p != NULL)          /* just in case */", "          p->sst_next = sp->sst_next;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["            break;", "        if (p != NULL)          /* just in case */", "          p->sst_next = sp->sst_next;"], "readability/braces"]
["src/nvim/syntax.c", ["  } else if (sp == NULL || sp->sst_lnum != current_lnum)   {", "    /*", "     * Add a new entry"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["     */", "    /* If no free items, cleanup the array first. */", "    if (syn_block->b_sst_freecount == 0) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      (void)syn_stack_cleanup();", "      /* \"sp\" may have been moved to the freelist now */", "      sp = syn_stack_find_entry(current_lnum);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    }", "    /* Still no free items?  Must be a strange problem... */", "    if (syn_block->b_sst_freecount == 0)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    /* Still no free items?  Must be a strange problem... */", "    if (syn_block->b_sst_freecount == 0)", "      sp = NULL;"], "readability/braces"]
["src/nvim/syntax.c", ["      sp = NULL;", "    else {", "      /* Take the first item from the free list and put it in the used"], "readability/braces"]
["src/nvim/syntax.c", ["      sp = NULL;", "    else {", "      /* Take the first item from the free list and put it in the used"], "readability/braces"]
["src/nvim/syntax.c", ["    else {", "      /* Take the first item from the free list and put it in the used", "       * list, after *sp */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      syn_block->b_sst_firstfree = p->sst_next;", "      --syn_block->b_sst_freecount;", "      if (sp == NULL) {"], "readability/increment"]
["src/nvim/syntax.c", ["      if (sp == NULL) {", "        /* Insert in front of the list */", "        p->sst_next = syn_block->b_sst_first;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      } else {", "        /* insert in list after *sp */", "        p->sst_next = sp->sst_next;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (sp != NULL) {", "    /* When overwriting an existing state stack, clear it first */", "    clear_syn_state(sp);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (current_state.ga_len > SST_FIX_STATES) {", "      /* Need to clear it, might be something remaining from when the", "       * length was less than SST_FIX_STATES. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      bp = SYN_STATE_P(&(sp->sst_union.sst_ga));", "    } else", "      bp = sp->sst_union.sst_stack;"], "readability/braces"]
["src/nvim/syntax.c", ["      bp = sp->sst_union.sst_stack;", "    for (i = 0; i < sp->sst_stacksize; ++i) {", "      bp[i].bs_idx = CUR_STATE(i).si_idx;"], "readability/increment"]
["src/nvim/syntax.c", ["  }", "  current_state_stored = TRUE;", "  return sp;"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Copy a state stack from \"from\" in b_sst_array[] to current_state;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    ga_grow(&current_state, from->sst_stacksize);", "    if (from->sst_stacksize > SST_FIX_STATES)", "      bp = SYN_STATE_P(&(from->sst_union.sst_ga));"], "readability/braces"]
["src/nvim/syntax.c", ["      bp = SYN_STATE_P(&(from->sst_union.sst_ga));", "    else", "      bp = from->sst_union.sst_stack;"], "readability/braces"]
["src/nvim/syntax.c", ["      bp = from->sst_union.sst_stack;", "    for (i = 0; i < from->sst_stacksize; ++i) {", "      CUR_STATE(i).si_idx = bp[i].bs_idx;"], "readability/increment"]
["src/nvim/syntax.c", ["      CUR_STATE(i).si_extmatch = ref_extmatch(bp[i].bs_extmatch);", "      if (keepend_level < 0 && (CUR_STATE(i).si_flags & HL_KEEPEND))", "        keepend_level = i;"], "readability/braces"]
["src/nvim/syntax.c", ["        keepend_level = i;", "      CUR_STATE(i).si_ends = FALSE;", "      CUR_STATE(i).si_m_lnum = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["      CUR_STATE(i).si_m_lnum = 0;", "      if (CUR_STATE(i).si_idx >= 0)", "        CUR_STATE(i).si_next_list ="], "readability/braces"]
["src/nvim/syntax.c", ["          (SYN_ITEMS(syn_block)[CUR_STATE(i).si_idx]).sp_next_list;", "      else", "        CUR_STATE(i).si_next_list = NULL;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Compare saved state stack \"*sp\" with the current state."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* First a quick check if the stacks have the same size end nextlist. */", "  if (sp->sst_stacksize != current_state.ga_len"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      || sp->sst_next_list != current_next_list) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /* Need to compare all states on both stacks. */", "  if (sp->sst_stacksize > SST_FIX_STATES)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  /* Need to compare all states on both stacks. */", "  if (sp->sst_stacksize > SST_FIX_STATES)", "    bp = SYN_STATE_P(&(sp->sst_union.sst_ga));"], "readability/braces"]
["src/nvim/syntax.c", ["    bp = SYN_STATE_P(&(sp->sst_union.sst_ga));", "  else", "    bp = sp->sst_union.sst_stack;"], "readability/braces"]
["src/nvim/syntax.c", ["  for (i = current_state.ga_len; --i >= 0; ) {", "    /* If the item has another index the state is different. */", "    if (bp[i].bs_idx != CUR_STATE(i).si_idx)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    /* If the item has another index the state is different. */", "    if (bp[i].bs_idx != CUR_STATE(i).si_idx)", "      break;"], "readability/braces"]
["src/nvim/syntax.c", ["    }", "    /* When the extmatch pointers are different, the strings in", "     * them can still be the same.  Check if the extmatch"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    six = CUR_STATE(i).si_extmatch;", "    /* If one of the extmatch pointers is NULL the states are", "     * different. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["     * different. */", "    if (bsx == NULL || six == NULL)", "      break;"], "readability/braces"]
["src/nvim/syntax.c", ["    int j;", "    for (j = 0; j < NSUBEXP; ++j) {", "      /* Check each referenced match string. They must all be"], "readability/increment"]
["src/nvim/syntax.c", ["    for (j = 0; j < NSUBEXP; ++j) {", "      /* Check each referenced match string. They must all be", "       * equal. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (bsx->matches[j] != six->matches[j]) {", "        /* If the pointer is different it can still be the", "         * same text.  Compare the strings, ignore case when"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    }", "    if (j != NSUBEXP)", "      break;"], "readability/braces"]
["src/nvim/syntax.c", ["  }", "  if (i < 0)", "    return TRUE;"], "readability/braces"]
["src/nvim/syntax.c", ["  if (i < 0)", "    return TRUE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * We stop parsing syntax above line \"lnum\".  If the stored state at or below"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  sp = syn_stack_find_entry(lnum);", "  if (sp != NULL && sp->sst_lnum < lnum)", "    sp = sp->sst_next;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  if (sp != NULL && sp->sst_change_lnum != 0)", "    sp->sst_change_lnum = lnum;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * End of handling of the state stack."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  clear_current_state();", "  current_state.ga_itemsize = 0;        /* mark current_state invalid */", "  current_next_list = NULL;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Return TRUE if the syntax at start of lnum changed since last time."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["{", "  int retval = TRUE;", "  synstate_T  *sp;"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /*", "   * Check the state stack when:"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (sp != NULL && sp->sst_lnum == lnum) {", "      /*", "       * finish the previous line (needed when not all of the line was"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "      /*", "       * Compare the current state with the previously saved state of"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["       */", "      if (syn_stack_equal(sp))", "        retval = FALSE;"], "readability/braces"]
["src/nvim/syntax.c", ["      if (syn_stack_equal(sp))", "        retval = FALSE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["", "      /*", "       * Store the current state in b_sst_array[] for later use."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["       */", "      ++current_lnum;", "      (void)store_current_state();"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Finish the current line."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Return highlight attributes for next character."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  if (can_spell != NULL)", "    /* Default: Only do spelling when there is no @Spell cluster or when"], "readability/braces"]
["src/nvim/syntax.c", ["  if (can_spell != NULL)", "    /* Default: Only do spelling when there is no @Spell cluster or when", "     * \":syn spell toplevel\" was used. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* check for out of memory situation */", "  if (syn_block->b_sst_array == NULL)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  /* check for out of memory situation */", "  if (syn_block->b_sst_array == NULL)", "    return 0;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /* After 'synmaxcol' the attribute is always zero. */", "  if (syn_buf->b_p_smc > 0 && col >= (colnr_T)syn_buf->b_p_smc) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* Make sure current_state is valid */", "  if (INVALID_STATE(&current_state))"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  /* Make sure current_state is valid */", "  if (INVALID_STATE(&current_state))", "    validate_current_state();"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * Skip from the current column to \"col\", get the attributes for \"col\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Get syntax attributes for current_lnum, current_col."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * No character, no attributes!  Past end of line?"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (line[current_col] == NUL && current_col != 0) {", "    /*", "     * If we found a match after the last column, use it."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    current_finished = TRUE;", "    current_state_stored = FALSE;"], "readability/bool"]
["src/nvim/syntax.c", ["    current_finished = TRUE;", "    current_state_stored = FALSE;", "    return 0;"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /* if the current or next character is NUL, we will finish the line now */", "  if (line[current_col] == NUL || line[current_col + 1] == NUL) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (line[current_col] == NUL || line[current_col + 1] == NUL) {", "    current_finished = TRUE;", "    current_state_stored = FALSE;"], "readability/bool"]
["src/nvim/syntax.c", ["    current_finished = TRUE;", "    current_state_stored = FALSE;", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /*", "   * When in the previous column there was a match but it could not be used"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* Init the list of zero-width matches with a nextlist.  This is used to", "   * avoid matching the same item in the same position twice. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Repeat matching keywords and patterns, to find contained items at the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * 1. Check for a current state."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["     */", "    if (current_state.ga_len)", "      cur_si = &CUR_STATE(current_state.ga_len - 1);"], "readability/braces"]
["src/nvim/syntax.c", ["      cur_si = &CUR_STATE(current_state.ga_len - 1);", "    else", "      cur_si = NULL;"], "readability/braces"]
["src/nvim/syntax.c", ["        || cur_si->si_cont_list != NULL) {", "      /*", "       * 2. Check for keywords, if on a keyword char after a non-keyword"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["              cur_si->si_h_startpos.lnum = current_lnum;", "              cur_si->si_h_startpos.col = 0;            /* starts right away */", "              cur_si->si_m_endpos.lnum = current_lnum;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["              cur_si->si_h_endpos.col = endcol;", "              cur_si->si_ends = TRUE;", "              cur_si->si_end_idx = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["              cur_si->si_cchar = cchar;", "              if (current_state.ga_len > 1)", "                cur_si->si_flags |="], "readability/braces"]
["src/nvim/syntax.c", ["", "      /*", "       * 3. Check for patterns (only if no keyword found)."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (syn_id == 0 && syn_block->b_syn_patterns.ga_len) {", "        /*", "         * If we didn't check for a match yet, or we are past it, check"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        if (next_match_idx < 0 || next_match_col < (int)current_col) {", "          /*", "           * Check all relevant patterns for a match at this"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["           */", "          next_match_idx = 0;                   /* no match in this line yet */", "          next_match_col = MAXCOL;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["            if (       spp->sp_syncing == syncing", "                       && (displaying || !(spp->sp_flags & HL_DISPLAY))", "                       && (spp->sp_type == SPTYPE_MATCH"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                       && (displaying || !(spp->sp_flags & HL_DISPLAY))", "                       && (spp->sp_type == SPTYPE_MATCH", "                           || spp->sp_type == SPTYPE_START)"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                           || spp->sp_type == SPTYPE_START)", "                       && (current_next_list != NULL", "                           ? in_id_list(NULL, current_next_list,"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                           ? in_id_list(NULL, current_next_list,", "                               &spp->sp_syn, 0)", "                           : (cur_si == NULL"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                              : in_id_list(cur_si,", "                                  cur_si->si_cont_list, &spp->sp_syn,", "                                  spp->sp_flags & HL_CONTAINED)))) {"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                                  cur_si->si_cont_list, &spp->sp_syn,", "                                  spp->sp_flags & HL_CONTAINED)))) {", "              /* If we already tried matching in this line, and"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                           ? in_id_list(NULL, current_next_list,", "                               &spp->sp_syn, 0)", "                           : (cur_si == NULL"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                              : in_id_list(cur_si,", "                                  cur_si->si_cont_list, &spp->sp_syn,", "                                  spp->sp_flags & HL_CONTAINED)))) {"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                                  cur_si->si_cont_list, &spp->sp_syn,", "                                  spp->sp_flags & HL_CONTAINED)))) {", "              /* If we already tried matching in this line, and"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                           ? in_id_list(NULL, current_next_list,", "                               &spp->sp_syn, 0)", "                           : (cur_si == NULL"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                              : in_id_list(cur_si,", "                                  cur_si->si_cont_list, &spp->sp_syn,", "                                  spp->sp_flags & HL_CONTAINED)))) {"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                                  cur_si->si_cont_list, &spp->sp_syn,", "                                  spp->sp_flags & HL_CONTAINED)))) {", "              /* If we already tried matching in this line, and"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                              : in_id_list(cur_si,", "                                  cur_si->si_cont_list, &spp->sp_syn,", "                                  spp->sp_flags & HL_CONTAINED)))) {"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                                  cur_si->si_cont_list, &spp->sp_syn,", "                                  spp->sp_flags & HL_CONTAINED)))) {", "              /* If we already tried matching in this line, and"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                                  spp->sp_flags & HL_CONTAINED)))) {", "              /* If we already tried matching in this line, and", "               * there isn't a match before next_match_col, skip"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["               * this item. */", "              if (spp->sp_line_id == current_line_id", "                  && spp->sp_startcol >= next_match_col)"], "readability/braces"]
["src/nvim/syntax.c", ["              if (!r) {", "                /* no match in this line, try another one */", "                spp->sp_startcol = MAXCOL;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "              /*", "               * Compute the first column of the match."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["              syn_add_start_off(&pos, &regmatch,", "                  spp, SPO_MS_OFF, -1);", "              if (pos.lnum > current_lnum) {"], "whitespace/alignment"]
["src/nvim/syntax.c", ["              if (pos.lnum > current_lnum) {", "                /* must have used end of match in a next line,", "                 * we can't handle that */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "              /* remember the next column where this pattern", "               * matches in the current line */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "              /*", "               * If a previously found match starts at a lower"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["               */", "              if (startcol >= next_match_col)", "                continue;"], "readability/braces"]
["src/nvim/syntax.c", ["", "              /*", "               * If we matched this pattern at this position"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "              /* Compute the highlight start. */", "              syn_add_start_off(&hl_startpos, &regmatch,"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["              syn_add_start_off(&hl_startpos, &regmatch,", "                  spp, SPO_HS_OFF, -1);", ""], "whitespace/alignment"]
["src/nvim/syntax.c", ["", "              /* Compute the region start. */", "              /* Default is to use the end of the match. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["              /* Compute the region start. */", "              /* Default is to use the end of the match. */", "              syn_add_end_off(&eos_pos, &regmatch,"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["              syn_add_end_off(&eos_pos, &regmatch,", "                  spp, SPO_RS_OFF, 0);", ""], "whitespace/alignment"]
["src/nvim/syntax.c", ["", "              /*", "               * Grab the external submatches before they get"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["              flags = 0;", "              eoe_pos.lnum = 0;                 /* avoid warning */", "              eoe_pos.col = 0;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "              /*", "               * For a \"oneline\" the end must be found in the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["                find_endpos(idx, &startpos, &endpos, &hl_endpos,", "                    &flags, &eoe_pos, &end_idx, cur_extmatch);", "                if (endpos.lnum == 0)"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                    &flags, &eoe_pos, &end_idx, cur_extmatch);", "                if (endpos.lnum == 0)", "                  continue;                         /* not found */"], "readability/braces"]
["src/nvim/syntax.c", ["                if (endpos.lnum == 0)", "                  continue;                         /* not found */", "              }"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["              }", "              /*", "               * For a \"match\" the size must be > 0 after the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["               */", "              else if (spp->sp_type == SPTYPE_MATCH) {", "                syn_add_end_off(&hl_endpos, &regmatch, spp,"], "whitespace/newline"]
["src/nvim/syntax.c", ["                syn_add_end_off(&hl_endpos, &regmatch, spp,", "                    SPO_HE_OFF, 0);", "                syn_add_end_off(&endpos, &regmatch, spp,"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                syn_add_end_off(&endpos, &regmatch, spp,", "                    SPO_ME_OFF, 0);", "                if (endpos.lnum == current_lnum"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                    && (int)endpos.col + syncing < startcol) {", "                  /*", "                   * If an empty string is matched, may need"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "              /*", "               * keep the best match so far in next_match_*"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["               */", "              /* Highlighting must start after startpos and end", "               * before endpos. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["               * before endpos. */", "              if (hl_startpos.lnum == current_lnum", "                  && (int)hl_startpos.col < startcol)"], "readability/braces"]
["src/nvim/syntax.c", ["", "        /*", "         * If we found a match at the current column, use it."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "          /* When a zero-width item matched which has a nextgroup,", "           * don't push the item but set nextgroup. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "            /* Add the index to a list, so that we can check", "             * later that we don't match it again (and cause an"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * Handle searching for nextgroup match."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (current_next_list != NULL && !keep_next_list) {", "      /*", "       * If a nextgroup was not found, continue looking for one if:"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        line = syn_getcurline();", "        if (((current_next_flags & HL_SKIPWHITE)", "             && ascii_iswhite(line[current_col]))"], "readability/braces"]
["src/nvim/syntax.c", ["", "      /*", "       * If a nextgroup was found: Use it, and continue looking for"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    }", "", "  } while (found_match);"], "whitespace/blank_line"]
["src/nvim/syntax.c", ["", "  /*", "   * Use attributes from the current state, if within its highlighting."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (cur_si != NULL) {", "    for (int idx = current_state.ga_len - 1; idx >= 0; --idx) {", "      sip = &CUR_STATE(idx);"], "readability/increment"]
["src/nvim/syntax.c", ["", "      /*", "       * set \"can_spell\" to TRUE if spell checking is supposed to be"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (syn_block->b_spell_cluster_id == 0) {", "        /* There is no @Spell cluster: Do spelling for items without", "         * @NoSpell cluster. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["         * @NoSpell cluster. */", "        if (syn_block->b_nospell_cluster_id == 0", "            || current_trans_id == 0)"], "readability/braces"]
["src/nvim/syntax.c", ["          *can_spell = (syn_block->b_syn_spell != SYNSPL_NOTOP);", "        else {", "          sps.inc_tag = 0;"], "readability/braces"]
["src/nvim/syntax.c", ["          *can_spell = (syn_block->b_syn_spell != SYNSPL_NOTOP);", "        else {", "          sps.inc_tag = 0;"], "readability/braces"]
["src/nvim/syntax.c", ["      } else {", "        /* The @Spell cluster is defined: Do spelling in items with", "         * the @Spell cluster.  But not when @NoSpell is also there."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["         * was used. */", "        if (current_trans_id == 0)", "          *can_spell = (syn_block->b_syn_spell == SYNSPL_TOP);"], "readability/braces"]
["src/nvim/syntax.c", ["          *can_spell = (syn_block->b_syn_spell == SYNSPL_TOP);", "        else {", "          sps.inc_tag = 0;"], "readability/braces"]
["src/nvim/syntax.c", ["          *can_spell = (syn_block->b_syn_spell == SYNSPL_TOP);", "        else {", "          sps.inc_tag = 0;"], "readability/braces"]
["src/nvim/syntax.c", ["            sps.id = syn_block->b_nospell_cluster_id;", "            if (in_id_list(sip, sip->si_cont_list, &sps, 0))", "              *can_spell = false;"], "readability/braces"]
["src/nvim/syntax.c", ["", "    /*", "     * Check for end of current state (and the states before it) at the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["          && syn_getcurline()[current_col] != NUL) {", "        ++current_col;", "        check_state_ends();"], "readability/increment"]
["src/nvim/syntax.c", ["        check_state_ends();", "        --current_col;", "      }"], "readability/increment"]
["src/nvim/syntax.c", ["    }", "  } else if (can_spell != NULL)", "    /* Default: Only do spelling when there is no @Spell cluster or when"], "readability/braces"]
["src/nvim/syntax.c", ["  } else if (can_spell != NULL)", "    /* Default: Only do spelling when there is no @Spell cluster or when", "     * \":syn spell toplevel\" was used. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* nextgroup ends at end of line, unless \"skipnl\" or \"skipempty\" present */", "  if (current_next_list != NULL"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  if (!GA_EMPTY(&zero_width_next_ga))", "    ga_clear(&zero_width_next_ga);"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /* No longer need external matches.  But keep next_match_extmatch. */", "  unref_extmatch(re_extmatch_out);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Check if we already matched pattern \"idx\" at the current column."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        && CUR_STATE(i).si_idx == idx) {", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /* Zero-width matches with a nextgroup argument are not put on the syntax", "   * stack, and can only be matched once anyway. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (((int *)(gap->ga_data))[i] == idx) {", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Push the next match onto the stack."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Push the item in current_state stack;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  {", "    /*", "     * If it's a start-skip-end type that crosses lines, figure out how"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    cur_si->si_cchar = spp->sp_cchar;", "    if (current_state.ga_len > 1)", "      cur_si->si_flags |="], "readability/braces"]
["src/nvim/syntax.c", ["    if (spp->sp_type == SPTYPE_START && !(spp->sp_flags & HL_ONELINE)) {", "      /* Try to find the end pattern in the current line */", "      update_si_end(cur_si, (int)(next_match_m_endpos.col), TRUE);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      /* Try to find the end pattern in the current line */", "      update_si_end(cur_si, (int)(next_match_m_endpos.col), TRUE);", "      check_keepend();"], "readability/bool"]
["src/nvim/syntax.c", ["      cur_si->si_h_endpos = next_match_h_endpos;", "      cur_si->si_ends = TRUE;", "      cur_si->si_flags |= next_match_flags;"], "readability/bool"]
["src/nvim/syntax.c", ["    }", "    if (keepend_level < 0 && (cur_si->si_flags & HL_KEEPEND))", "      keepend_level = current_state.ga_len - 1;"], "readability/braces"]
["src/nvim/syntax.c", ["    save_flags = cur_si->si_flags & (HL_CONCEAL | HL_CONCEALENDS);", "    /*", "     * If the start pattern has another highlight group, push another item"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      cur_si->si_h_endpos = next_match_eos_pos;", "      cur_si->si_ends = TRUE;", "      cur_si->si_end_idx = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["      cur_si->si_flags |= save_flags;", "      if (cur_si->si_flags & HL_CONCEALENDS)", "        cur_si->si_flags |= HL_CONCEAL;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  next_match_idx = -1;          /* try other match next time */", ""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Check for end of current state (and the states before it)."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["                && cur_si->si_m_endpos.col <= current_col))) {", "      /*", "       * If there is an end pattern group ID, highlight the end pattern"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        cur_si->si_seqnr = next_seqnr++;", "        if (cur_si->si_flags & HL_CONCEALENDS)", "          cur_si->si_flags |= HL_CONCEAL;"], "readability/braces"]
["src/nvim/syntax.c", ["", "        /* nextgroup= should not match in the end pattern */", "        current_next_list = NULL;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "        /* what matches next may be different now, clear it */", "        next_match_idx = 0;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      } else {", "        /* handle next_list, unless at end of line and no \"skipnl\" or", "         * \"skipempty\" */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        current_next_flags = cur_si->si_flags;", "        if (!(current_next_flags & (HL_SKIPNL | HL_SKIPEMPTY))", "            && syn_getcurline()[current_col] == NUL)"], "readability/braces"]
["src/nvim/syntax.c", ["", "        /* When the ended item has \"extend\", another item with", "         * \"keepend\" now needs to check for its end. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "        if (GA_EMPTY(&current_state))", "          break;"], "readability/braces"]
["src/nvim/syntax.c", ["        if (had_extend && keepend_level >= 0) {", "          syn_update_ends(FALSE);", "          if (GA_EMPTY(&current_state))"], "readability/bool"]
["src/nvim/syntax.c", ["          syn_update_ends(FALSE);", "          if (GA_EMPTY(&current_state))", "            break;"], "readability/braces"]
["src/nvim/syntax.c", ["", "        /*", "         * Only for a region the search for the end continues after"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["            && !(cur_si->si_flags & (HL_MATCH | HL_KEEPEND))) {", "          update_si_end(cur_si, (int)current_col, TRUE);", "          check_keepend();"], "readability/bool"]
["src/nvim/syntax.c", ["          check_keepend();", "          if ((current_next_flags & HL_HAS_EOL)", "              && keepend_level < 0"], "readability/braces"]
["src/nvim/syntax.c", ["      }", "    } else", "      break;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Update an entry in the current_state stack for a match or region.  This"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* This should not happen... */", "  if (sip->si_idx < 0)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  /* This should not happen... */", "  if (sip->si_idx < 0)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["  spp = &(SYN_ITEMS(syn_block)[sip->si_idx]);", "  if (sip->si_flags & HL_MATCH)", "    sip->si_id = spp->sp_syn_match_id;"], "readability/braces"]
["src/nvim/syntax.c", ["    sip->si_id = spp->sp_syn_match_id;", "  else", "    sip->si_id = spp->sp_syn.id;"], "readability/braces"]
["src/nvim/syntax.c", ["  sip->si_trans_id = sip->si_id;", "  if (sip->si_flags & HL_MATCH)", "    sip->si_cont_list = NULL;"], "readability/braces"]
["src/nvim/syntax.c", ["    sip->si_cont_list = NULL;", "  else", "    sip->si_cont_list = spp->sp_cont_list;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * For transparent items, take attr from outer item."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      sip->si_trans_id = 0;", "      if (sip->si_cont_list == NULL)", "        sip->si_cont_list = ID_LIST_ALL;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Check the current stack for patterns with \"keepend\" flag."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * This check can consume a lot of time; only do it from the level where"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  if (keepend_level < 0)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * Find the last index of an \"extend\" item.  \"keepend\" items before that"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  for (i = current_state.ga_len - 1; i > keepend_level; --i)", "    if (CUR_STATE(i).si_flags & HL_EXTEND)"], "readability/braces"]
["src/nvim/syntax.c", ["   */", "  for (i = current_state.ga_len - 1; i > keepend_level; --i)", "    if (CUR_STATE(i).si_flags & HL_EXTEND)"], "readability/increment"]
["src/nvim/syntax.c", ["  for (i = current_state.ga_len - 1; i > keepend_level; --i)", "    if (CUR_STATE(i).si_flags & HL_EXTEND)", "      break;"], "readability/braces"]
["src/nvim/syntax.c", ["  maxpos_h.col = 0;", "  for (; i < current_state.ga_len; ++i) {", "    sip = &CUR_STATE(i);"], "readability/increment"]
["src/nvim/syntax.c", ["      limit_pos_zero(&sip->si_eoe_pos, &maxpos);", "      sip->si_ends = TRUE;", "    }"], "readability/bool"]
["src/nvim/syntax.c", ["    if (sip->si_ends && (sip->si_flags & HL_KEEPEND)) {", "      if (maxpos.lnum == 0", "          || maxpos.lnum > sip->si_m_endpos.lnum"], "readability/braces"]
["src/nvim/syntax.c", ["        maxpos = sip->si_m_endpos;", "      if (maxpos_h.lnum == 0", "          || maxpos_h.lnum > sip->si_h_endpos.lnum"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Update an entry in the current_state stack for a start-skip-end pattern."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    stateitem_T *sip,", "    int startcol,               /* where to start searching for the end */", "    int force                  /* when TRUE overrule a previous end */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    int startcol,               /* where to start searching for the end */", "    int force                  /* when TRUE overrule a previous end */", ")"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* return quickly for a keyword */", "  if (sip->si_idx < 0)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  /* return quickly for a keyword */", "  if (sip->si_idx < 0)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /* Don't update when it's already done.  Can be a match of an end pattern", "   * that started in a previous line.  Watch out: can also be a \"keepend\""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   * from a containing item. */", "  if (!force && sip->si_m_endpos.lnum >= current_lnum)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * We need to find the end of the region.  It may continue in the next"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  find_endpos(sip->si_idx, &startpos, &endpos, &hl_endpos,", "      &(sip->si_flags), &end_endpos, &end_idx, sip->si_extmatch);", ""], "whitespace/alignment"]
["src/nvim/syntax.c", ["  if (endpos.lnum == 0) {", "    /* No end pattern matched. */", "    if (SYN_ITEMS(syn_block)[sip->si_idx].sp_flags & HL_ONELINE) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (SYN_ITEMS(syn_block)[sip->si_idx].sp_flags & HL_ONELINE) {", "      /* a \"oneline\" never continues in the next line */", "      sip->si_ends = TRUE;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      /* a \"oneline\" never continues in the next line */", "      sip->si_ends = TRUE;", "      sip->si_m_endpos.lnum = current_lnum;"], "readability/bool"]
["src/nvim/syntax.c", ["    } else {", "      /* continues in the next line */", "      sip->si_ends = FALSE;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      /* continues in the next line */", "      sip->si_ends = FALSE;", "      sip->si_m_endpos.lnum = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["  } else {", "    /* match within this line */", "    sip->si_m_endpos = endpos;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    sip->si_eoe_pos = end_endpos;", "    sip->si_ends = TRUE;", "    sip->si_end_idx = end_idx;"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Add a new state to the current state stack."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Remove a state from the current_state stack."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    unref_extmatch(CUR_STATE(current_state.ga_len - 1).si_extmatch);", "    --current_state.ga_len;", "  }"], "readability/increment"]
["src/nvim/syntax.c", ["  }", "  /* after the end of a pattern, try matching a keyword or pattern */", "  next_match_idx = -1;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* if first state with \"keepend\" is popped, reset keepend_level */", "  if (keepend_level >= current_state.ga_len)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  /* if first state with \"keepend\" is popped, reset keepend_level */", "  if (keepend_level >= current_state.ga_len)", "    keepend_level = -1;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Find the end of a start/skip/end syntax region after \"startpos\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  regmmatch_T regmatch;", "  regmmatch_T best_regmatch;        /* startpos/endpos of best match */", "  lpos_T pos;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* just in case we are invoked for a keyword */", "  if (idx < 0)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  /* just in case we are invoked for a keyword */", "  if (idx < 0)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * Check for being called with a START pattern."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Find the SKIP or first END pattern after the last START pattern."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    spp = &(SYN_ITEMS(syn_block)[idx]);", "    if (spp->sp_type != SPTYPE_START)", "      break;"], "readability/braces"]
["src/nvim/syntax.c", ["      break;", "    ++idx;", "  }"], "readability/increment"]
["src/nvim/syntax.c", ["", "  /*", "   *\tLookup the SKIP pattern (if present)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    spp_skip = spp;", "    ++idx;", "  } else"], "readability/increment"]
["src/nvim/syntax.c", ["    ++idx;", "  } else", "    spp_skip = NULL;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /* Setup external matches for syn_regexec(). */", "  unref_extmatch(re_extmatch_in);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  for (;; ) {", "    /*", "     * Find end pattern that matches first after \"matchcol\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    best_idx = -1;", "    for (idx = start_idx; idx < syn_block->b_syn_patterns.ga_len; ++idx) {", "      int lc_col = matchcol;"], "readability/increment"]
["src/nvim/syntax.c", ["      spp = &(SYN_ITEMS(syn_block)[idx]);", "      if (spp->sp_type != SPTYPE_END)           /* past last END pattern */", "        break;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      spp = &(SYN_ITEMS(syn_block)[idx]);", "      if (spp->sp_type != SPTYPE_END)           /* past last END pattern */", "        break;"], "readability/braces"]
["src/nvim/syntax.c", ["      lc_col -= spp->sp_offsets[SPO_LC_OFF];", "      if (lc_col < 0)", "        lc_col = 0;"], "readability/braces"]
["src/nvim/syntax.c", ["", "    /*", "     * If all end patterns have been tried, and there is no match, the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["     */", "    if (best_idx == -1)", "      break;"], "readability/braces"]
["src/nvim/syntax.c", ["", "    /*", "     * If the skip pattern matches before the end pattern,"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "      if (lc_col < 0)", "        lc_col = 0;"], "readability/braces"]
["src/nvim/syntax.c", ["", "    /*", "     * Match from start pattern to end pattern."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    syn_add_end_off(m_endpos, &best_regmatch, spp, SPO_ME_OFF, 1);", "    /* can't end before the start */", "    if (m_endpos->lnum == startpos->lnum && m_endpos->col < startpos->col)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    /* can't end before the start */", "    if (m_endpos->lnum == startpos->lnum && m_endpos->col < startpos->col)", "      m_endpos->col = startpos->col;"], "readability/braces"]
["src/nvim/syntax.c", ["    syn_add_end_off(end_endpos, &best_regmatch, spp, SPO_HE_OFF, 1);", "    /* can't end before the start */", "    if (end_endpos->lnum == startpos->lnum"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    /* can't end before the start */", "    if (end_endpos->lnum == startpos->lnum", "        && end_endpos->col < startpos->col)"], "readability/braces"]
["src/nvim/syntax.c", ["      end_endpos->col = startpos->col;", "    /* can't end after the match */", "    limit_pos(end_endpos, m_endpos);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * If the end group is highlighted differently, adjust the pointers."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "      /* can't end before the start */", "      if (hl_endpos->lnum == startpos->lnum"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      /* can't end before the start */", "      if (hl_endpos->lnum == startpos->lnum", "          && hl_endpos->col < startpos->col)"], "readability/braces"]
["src/nvim/syntax.c", ["", "      /* now the match ends where the highlighting ends, it is turned", "       * into the matchgroup for the end */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    had_match = TRUE;", "    break;"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /* no match for an END pattern in this line */", "  if (!had_match)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  /* no match for an END pattern in this line */", "  if (!had_match)", "    m_endpos->lnum = 0;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /* Remove external matches. */", "  unref_extmatch(re_extmatch_in);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Limit \"pos\" not to be after \"limit\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["{", "  if (pos->lnum > limit->lnum)", "    *pos = *limit;"], "readability/braces"]
["src/nvim/syntax.c", ["    *pos = *limit;", "  else if (pos->lnum == limit->lnum && pos->col > limit->col)", "    pos->col = limit->col;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Limit \"pos\" not to be after \"limit\", unless pos->lnum is zero."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["{", "  if (pos->lnum == 0)", "    *pos = *limit;"], "readability/braces"]
["src/nvim/syntax.c", ["    *pos = *limit;", "  else", "    limit_pos(pos, limit);"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Add offset to matched text for end of match or highlight."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  }", "  /* Don't go past the end of the line.  Matters for \"rs=e+2\" when there", "   * is a matchgroup. Watch out for match with last NL in the buffer. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   * is a matchgroup. Watch out for match with last NL in the buffer. */", "  if (result->lnum > syn_buf->b_ml.ml_line_count)", "    col = 0;"], "readability/braces"]
["src/nvim/syntax.c", ["    col = 0;", "  else if (off != 0) {", "    base = ml_get_buf(syn_buf, result->lnum, FALSE);"], "readability/braces"]
["src/nvim/syntax.c", ["  else if (off != 0) {", "    base = ml_get_buf(syn_buf, result->lnum, FALSE);", "    p = base + col;"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Add offset to matched text for start of match or highlight."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (result->lnum > syn_buf->b_ml.ml_line_count) {", "    /* a \"\\n\" at the end of the pattern may take us below the last line */", "    result->lnum = syn_buf->b_ml.ml_line_count;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    result->lnum = syn_buf->b_ml.ml_line_count;", "    col = (int)STRLEN(ml_get_buf(syn_buf, result->lnum, FALSE));", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["  if (off != 0) {", "    base = ml_get_buf(syn_buf, result->lnum, FALSE);", "    p = base + col;"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Get current line in syntax buffer."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["{", "  return ml_get_buf(syn_buf, current_lnum, FALSE);", "}"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Call vim_regexec() to find a match with \"rmp\" in \"syn_buf\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", [" */", "static int syn_regexec(regmmatch_T *rmp, linenr_T lnum, colnr_T col, syn_time_T *st)", "{"], "whitespace/line_length"]
["src/nvim/syntax.c", ["    }", "    ++st->count;", "    if (r > 0)"], "readability/increment"]
["src/nvim/syntax.c", ["    ++st->count;", "    if (r > 0)", "      ++st->match;"], "readability/braces"]
["src/nvim/syntax.c", ["    if (r > 0)", "      ++st->match;", "  }"], "readability/increment"]
["src/nvim/syntax.c", ["    rmp->endpos[0].lnum += lnum;", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Check one position in a line for a matching keyword."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  hashitem_T *hi = hash_find(ht, keyword);", "  if (!HASHITEM_EMPTY(hi))", "    for (keyentry_T *kp = HI2KE(hi); kp != NULL; kp = kp->ke_next) {"], "readability/braces"]
["src/nvim/syntax.c", ["          : (cur_si == NULL", "            ? !(kp->flags & HL_CONTAINED)", "            : in_id_list(cur_si, cur_si->si_cont_list,"], "whitespace/alignment"]
["src/nvim/syntax.c", ["            ? !(kp->flags & HL_CONTAINED)", "            : in_id_list(cur_si, cur_si->si_cont_list,", "                         &kp->k_syn, kp->flags & HL_CONTAINED))) {"], "whitespace/alignment"]
["src/nvim/syntax.c", ["          : (cur_si == NULL", "            ? !(kp->flags & HL_CONTAINED)", "            : in_id_list(cur_si, cur_si->si_cont_list,"], "whitespace/alignment"]
["src/nvim/syntax.c", ["            ? !(kp->flags & HL_CONTAINED)", "            : in_id_list(cur_si, cur_si->si_cont_list,", "                         &kp->k_syn, kp->flags & HL_CONTAINED))) {"], "whitespace/alignment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax conceal\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  eap->nextcmd = find_nextcmd(arg);", "  if (eap->skip)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax case\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  eap->nextcmd = find_nextcmd(arg);", "  if (eap->skip)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["  eap->nextcmd = find_nextcmd(arg);", "  if (eap->skip)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax spell\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  eap->nextcmd = find_nextcmd(arg);", "  if (eap->skip)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Clear all syntax info for one buffer."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* free the keywords */", "  clear_keywtab(&block->b_keywtab);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* free the syntax patterns */", "  for (int i = block->b_syn_patterns.ga_len; --i >= 0; ) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* free the syntax clusters */", "  for (int i = block->b_syn_clusters.ga_len; --i >= 0; ) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* free the stored states */", "  syn_stack_free_all(block);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* Reset the counter for \":syn include\" */", "  running_syn_inc_tag = 0;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Get rid of ownsyntax for window \"wp\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Clear syncing info for one buffer."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["{", "  /* free the syntax patterns */", "  for (int i = curwin->w_s->b_syn_patterns.ga_len; --i >= 0; ) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  syn_stack_free_all(curwin->w_s);              /* Need to recompute all syntax. */", "}"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  syn_stack_free_all(curwin->w_s);              /* Need to recompute all syntax. */", "}"], "whitespace/line_length"]
["src/nvim/syntax.c", ["", "/*", " * Remove one pattern from the buffer's pattern list."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  spp = &(SYN_ITEMS(block)[idx]);", "  if (spp->sp_flags & HL_FOLD)", "    --block->b_syn_folditems;"], "readability/braces"]
["src/nvim/syntax.c", ["  if (spp->sp_flags & HL_FOLD)", "    --block->b_syn_folditems;", "  syn_clear_pattern(block, idx);"], "readability/increment"]
["src/nvim/syntax.c", ["  memmove(spp, spp + 1,", "      sizeof(synpat_T) * (block->b_syn_patterns.ga_len - idx - 1));", "  --block->b_syn_patterns.ga_len;"], "whitespace/alignment"]
["src/nvim/syntax.c", ["      sizeof(synpat_T) * (block->b_syn_patterns.ga_len - idx - 1));", "  --block->b_syn_patterns.ga_len;", "}"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Clear and free one syntax pattern.  When clearing all, must be called from"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  vim_regfree(SYN_ITEMS(block)[i].sp_prog);", "  /* Only free sp_cont_list and sp_next_list of first start pattern */", "  if (i == 0 || SYN_ITEMS(block)[i - 1].sp_type != SPTYPE_START) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Clear and free one syntax cluster."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax clear\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  eap->nextcmd = find_nextcmd(arg);", "  if (eap->skip)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * We have to disable this within \":syn include @group filename\","], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  if (curwin->w_s->b_syn_topgrp != 0)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["  if (ends_excmd(*arg)) {", "    /*", "     * No argument: Clear all syntax items."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["     */", "    if (syncing)", "      syntax_sync_clear();"], "readability/braces"]
["src/nvim/syntax.c", ["      syntax_sync_clear();", "    else {", "      syntax_clear(curwin->w_s);"], "readability/braces"]
["src/nvim/syntax.c", ["      syntax_sync_clear();", "    else {", "      syntax_clear(curwin->w_s);"], "readability/braces"]
["src/nvim/syntax.c", ["  } else {", "    /*", "     * Clear the group IDs that are in the argument."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["          break;", "        } else", "          syn_clear_one(id, syncing);"], "readability/braces"]
["src/nvim/syntax.c", ["  redraw_curbuf_later(SOME_VALID);", "  syn_stack_free_all(curwin->w_s);              /* Need to recompute all syntax. */", "}"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  redraw_curbuf_later(SOME_VALID);", "  syn_stack_free_all(curwin->w_s);              /* Need to recompute all syntax. */", "}"], "whitespace/line_length"]
["src/nvim/syntax.c", ["", "/*", " * Clear one syntax group for the current buffer."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* Clear keywords only when not \":syn sync clear group-name\" */", "  if (!syncing) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* clear the patterns for \"id\" */", "  for (int idx = curwin->w_s->b_syn_patterns.ga_len; --idx >= 0; ) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    spp = &(SYN_ITEMS(curwin->w_s)[idx]);", "    if (spp->sp_syn.id != id || spp->sp_syncing != syncing)", "      continue;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax on\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax enable\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax reset\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax manual\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax off\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax [list]\" command: list current syntax words."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    exarg_T *eap,", "    int syncing                        /* when TRUE: list syncing items */", ")"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  eap->nextcmd = find_nextcmd(arg);", "  if (eap->skip)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["    }", "  } else", "    MSG_PUTS_TITLE(_(\"\\n--- Syntax items ---\"));"], "readability/braces"]
["src/nvim/syntax.c", ["  if (ends_excmd(*arg)) {", "    /*", "     * No argument: List all group IDs and all syntax clusters."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    }", "    for (int id = 0; id < curwin->w_s->b_syn_clusters.ga_len && !got_int; ++id) {", "      syn_list_cluster(id);"], "whitespace/line_length"]
["src/nvim/syntax.c", ["    }", "    for (int id = 0; id < curwin->w_s->b_syn_clusters.ga_len && !got_int; ++id) {", "      syn_list_cluster(id);"], "readability/increment"]
["src/nvim/syntax.c", ["  } else {", "    /*", "     * List the group IDs and syntax clusters that are in the argument."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        int id = syn_scl_namen2id(arg + 1, (int)(arg_end - arg - 1));", "        if (id == 0)", "          EMSG2(_(\"E392: No such syntax cluster: %s\"), arg);"], "readability/braces"]
["src/nvim/syntax.c", ["          EMSG2(_(\"E392: No such syntax cluster: %s\"), arg);", "        else", "          syn_list_cluster(id - SYNID_CLUSTER);"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * List one syntax item, for \":syntax\" or \"syntax list syntax_name\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  static struct name_list namelist1[] =", "  {", "    {HL_DISPLAY, \"display\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["  {", "    {HL_DISPLAY, \"display\"},", "    {HL_CONTAINED, \"contained\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["  {", "    {HL_DISPLAY, \"display\"},", "    {HL_CONTAINED, \"contained\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_DISPLAY, \"display\"},", "    {HL_CONTAINED, \"contained\"},", "    {HL_ONELINE, \"oneline\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_DISPLAY, \"display\"},", "    {HL_CONTAINED, \"contained\"},", "    {HL_ONELINE, \"oneline\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_CONTAINED, \"contained\"},", "    {HL_ONELINE, \"oneline\"},", "    {HL_KEEPEND, \"keepend\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_CONTAINED, \"contained\"},", "    {HL_ONELINE, \"oneline\"},", "    {HL_KEEPEND, \"keepend\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_ONELINE, \"oneline\"},", "    {HL_KEEPEND, \"keepend\"},", "    {HL_EXTEND, \"extend\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_ONELINE, \"oneline\"},", "    {HL_KEEPEND, \"keepend\"},", "    {HL_EXTEND, \"extend\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_KEEPEND, \"keepend\"},", "    {HL_EXTEND, \"extend\"},", "    {HL_EXCLUDENL, \"excludenl\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_KEEPEND, \"keepend\"},", "    {HL_EXTEND, \"extend\"},", "    {HL_EXCLUDENL, \"excludenl\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_EXTEND, \"extend\"},", "    {HL_EXCLUDENL, \"excludenl\"},", "    {HL_TRANSP, \"transparent\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_EXTEND, \"extend\"},", "    {HL_EXCLUDENL, \"excludenl\"},", "    {HL_TRANSP, \"transparent\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_EXCLUDENL, \"excludenl\"},", "    {HL_TRANSP, \"transparent\"},", "    {HL_FOLD, \"fold\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_EXCLUDENL, \"excludenl\"},", "    {HL_TRANSP, \"transparent\"},", "    {HL_FOLD, \"fold\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_TRANSP, \"transparent\"},", "    {HL_FOLD, \"fold\"},", "    {HL_CONCEAL, \"conceal\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_TRANSP, \"transparent\"},", "    {HL_FOLD, \"fold\"},", "    {HL_CONCEAL, \"conceal\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_FOLD, \"fold\"},", "    {HL_CONCEAL, \"conceal\"},", "    {HL_CONCEALENDS, \"concealends\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_FOLD, \"fold\"},", "    {HL_CONCEAL, \"conceal\"},", "    {HL_CONCEALENDS, \"concealends\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_CONCEAL, \"conceal\"},", "    {HL_CONCEALENDS, \"concealends\"},", "    {0, NULL}"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_CONCEAL, \"conceal\"},", "    {HL_CONCEALENDS, \"concealends\"},", "    {0, NULL}"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_CONCEALENDS, \"concealends\"},", "    {0, NULL}", "  };"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_CONCEALENDS, \"concealends\"},", "    {0, NULL}", "  };"], "whitespace/braces"]
["src/nvim/syntax.c", ["  static struct name_list namelist2[] =", "  {", "    {HL_SKIPWHITE, \"skipwhite\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["  {", "    {HL_SKIPWHITE, \"skipwhite\"},", "    {HL_SKIPNL, \"skipnl\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["  {", "    {HL_SKIPWHITE, \"skipwhite\"},", "    {HL_SKIPNL, \"skipnl\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_SKIPWHITE, \"skipwhite\"},", "    {HL_SKIPNL, \"skipnl\"},", "    {HL_SKIPEMPTY, \"skipempty\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_SKIPWHITE, \"skipwhite\"},", "    {HL_SKIPNL, \"skipnl\"},", "    {HL_SKIPEMPTY, \"skipempty\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_SKIPNL, \"skipnl\"},", "    {HL_SKIPEMPTY, \"skipempty\"},", "    {0, NULL}"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_SKIPNL, \"skipnl\"},", "    {HL_SKIPEMPTY, \"skipempty\"},", "    {0, NULL}"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_SKIPEMPTY, \"skipempty\"},", "    {0, NULL}", "  };"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_SKIPEMPTY, \"skipempty\"},", "    {0, NULL}", "  };"], "whitespace/braces"]
["src/nvim/syntax.c", ["    } else if (spp->sp_type == SPTYPE_START)   {", "      while (SYN_ITEMS(curwin->w_s)[idx].sp_type == SPTYPE_START)", "        put_pattern(\"start\", '=', &SYN_ITEMS(curwin->w_s)[idx++], attr);"], "readability/braces"]
["src/nvim/syntax.c", ["        put_pattern(\"start\", '=', &SYN_ITEMS(curwin->w_s)[idx++], attr);", "      if (SYN_ITEMS(curwin->w_s)[idx].sp_type == SPTYPE_SKIP)", "        put_pattern(\"skip\", '=', &SYN_ITEMS(curwin->w_s)[idx++], attr);"], "readability/braces"]
["src/nvim/syntax.c", ["        put_pattern(\"skip\", '=', &SYN_ITEMS(curwin->w_s)[idx++], attr);", "      while (idx < curwin->w_s->b_syn_patterns.ga_len", "             && SYN_ITEMS(curwin->w_s)[idx].sp_type == SPTYPE_END)"], "readability/braces"]
["src/nvim/syntax.c", ["        put_pattern(\"end\", '=', &SYN_ITEMS(curwin->w_s)[idx++], attr);", "      --idx;", "      msg_putchar(' ');"], "readability/increment"]
["src/nvim/syntax.c", ["      msg_putchar(' ');", "      if (spp->sp_sync_idx >= 0)", "        msg_outtrans(HL_TABLE()[SYN_ITEMS(curwin->w_s)"], "readability/braces"]
["src/nvim/syntax.c", ["                                [spp->sp_sync_idx].sp_syn.id - 1].sg_name);", "      else", "        MSG_PUTS(\"NONE\");"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /* list the link, if there is one */", "  if (HL_TABLE()[id - 1].sg_link && (did_header || link_only) && !got_int) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  for (i = 0; nlist[i].flag != 0; ++i)", "    if (flags & nlist[i].flag) {"], "readability/braces"]
["src/nvim/syntax.c", ["", "  for (i = 0; nlist[i].flag != 0; ++i)", "    if (flags & nlist[i].flag) {"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * List one syntax cluster, for \":syntax\" or \"syntax list syntax_name\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* slight hack:  roughly duplicate the guts of syn_list_header() */", "  msg_putchar('\\n');"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  if (msg_col >= endcol)        /* output at least one space */", "    endcol = msg_col + 1;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  if (msg_col >= endcol)        /* output at least one space */", "    endcol = msg_col + 1;"], "readability/braces"]
["src/nvim/syntax.c", ["    endcol = msg_col + 1;", "  if (Columns <= endcol)        /* avoid hang for tiny window */", "    endcol = Columns - 1;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    endcol = msg_col + 1;", "  if (Columns <= endcol)        /* avoid hang for tiny window */", "    endcol = Columns - 1;"], "readability/braces"]
["src/nvim/syntax.c", ["      msg_outtrans(SYN_CLSTR(curwin->w_s)[scl_id].scl_name);", "    } else", "      msg_outtrans(HL_TABLE()[*p - 1].sg_name);"], "readability/braces"]
["src/nvim/syntax.c", ["      msg_outtrans(HL_TABLE()[*p - 1].sg_name);", "    if (p[1])", "      msg_putchar(',');"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /* May have to write \"matchgroup=group\" */", "  if (last_matchgroup != spp->sp_syn_match_id) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    msg_putchar('=');", "    if (last_matchgroup == 0)", "      msg_outtrans((char_u *)\"NONE\");"], "readability/braces"]
["src/nvim/syntax.c", ["      msg_outtrans((char_u *)\"NONE\");", "    else", "      msg_outtrans(HL_TABLE()[last_matchgroup - 1].sg_name);"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /* output the pattern, in between a char that is not in the pattern */", "  for (i = 0; vim_strchr(spp->sp_pattern, sepchars[i]) != NULL; )"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  /* output the pattern, in between a char that is not in the pattern */", "  for (i = 0; vim_strchr(spp->sp_pattern, sepchars[i]) != NULL; )", "    if (sepchars[++i] == NUL) {"], "readability/braces"]
["src/nvim/syntax.c", ["    if (sepchars[++i] == NUL) {", "      i = 0;            /* no good char found, just use the first one */", "      break;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (i != SPO_LC_OFF) {", "      if (spp->sp_off_flags & mask)", "        msg_putchar('s');"], "readability/braces"]
["src/nvim/syntax.c", ["        msg_putchar('s');", "      else", "        msg_putchar('e');"], "readability/braces"]
["src/nvim/syntax.c", ["        msg_putchar('e');", "      if (n > 0)", "        msg_putchar('+');"], "readability/braces"]
["src/nvim/syntax.c", ["  todo = (int)ht->ht_used;", "  for (hi = ht->ht_array; todo > 0; ++hi) {", "    if (HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/syntax.c", ["    }", "    --todo;", "    kp_prev = NULL;"], "readability/increment"]
["src/nvim/syntax.c", ["        if (kp_prev == NULL) {", "          if (kp_next == NULL)", "            hash_remove(ht, hi);"], "readability/braces"]
["src/nvim/syntax.c", ["            hash_remove(ht, hi);", "          else", "            hi->hi_key = KE2HIKEY(kp_next);"], "readability/braces"]
["src/nvim/syntax.c", ["            hi->hi_key = KE2HIKEY(kp_next);", "        } else", "          kp_prev->ke_next = kp_next;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Clear a whole keyword table."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  todo = (int)ht->ht_used;", "  for (hi = ht->ht_array; todo > 0; ++hi) {", "    if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/syntax.c", ["    if (!HASHITEM_EMPTY(hi)) {", "      --todo;", "      for (kp = HI2KE(hi); kp != NULL; kp = kp_next) {"], "readability/increment"]
["src/nvim/syntax.c", ["  if (cont_in_list != NULL) {", "    curwin->w_s->b_syn_containedin = TRUE;", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Get the start and end of the group name argument."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static char_u *", "get_group_name (", "    char_u *arg,               /* start of the argument */"], "whitespace/parens"]
["src/nvim/syntax.c", ["get_group_name (", "    char_u *arg,               /* start of the argument */", "    char_u **name_end         /* pointer to end of the name */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    char_u *arg,               /* start of the argument */", "    char_u **name_end         /* pointer to end of the name */", ")"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Check if there are enough arguments.  The first argument may be a"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  if (ends_excmd(*arg) || *rest == NUL)", "    return NULL;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Check for syntax command option arguments."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    int flags;", "  } flagtab[] = { {\"cCoOnNtTaAiInNeEdD\",      0,      HL_CONTAINED},", "                  {\"oOnNeElLiInNeE\",          0,      HL_ONELINE},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    int flags;", "  } flagtab[] = { {\"cCoOnNtTaAiInNeEdD\",      0,      HL_CONTAINED},", "                  {\"oOnNeElLiInNeE\",          0,      HL_ONELINE},"], "whitespace/braces"]
["src/nvim/syntax.c", ["  } flagtab[] = { {\"cCoOnNtTaAiInNeEdD\",      0,      HL_CONTAINED},", "                  {\"oOnNeElLiInNeE\",          0,      HL_ONELINE},", "                  {\"kKeEeEpPeEnNdD\",          0,      HL_KEEPEND},"], "whitespace/braces"]
["src/nvim/syntax.c", ["  } flagtab[] = { {\"cCoOnNtTaAiInNeEdD\",      0,      HL_CONTAINED},", "                  {\"oOnNeElLiInNeE\",          0,      HL_ONELINE},", "                  {\"kKeEeEpPeEnNdD\",          0,      HL_KEEPEND},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"oOnNeElLiInNeE\",          0,      HL_ONELINE},", "                  {\"kKeEeEpPeEnNdD\",          0,      HL_KEEPEND},", "                  {\"eExXtTeEnNdD\",            0,      HL_EXTEND},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"oOnNeElLiInNeE\",          0,      HL_ONELINE},", "                  {\"kKeEeEpPeEnNdD\",          0,      HL_KEEPEND},", "                  {\"eExXtTeEnNdD\",            0,      HL_EXTEND},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"kKeEeEpPeEnNdD\",          0,      HL_KEEPEND},", "                  {\"eExXtTeEnNdD\",            0,      HL_EXTEND},", "                  {\"eExXcClLuUdDeEnNlL\",      0,      HL_EXCLUDENL},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"kKeEeEpPeEnNdD\",          0,      HL_KEEPEND},", "                  {\"eExXtTeEnNdD\",            0,      HL_EXTEND},", "                  {\"eExXcClLuUdDeEnNlL\",      0,      HL_EXCLUDENL},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"eExXtTeEnNdD\",            0,      HL_EXTEND},", "                  {\"eExXcClLuUdDeEnNlL\",      0,      HL_EXCLUDENL},", "                  {\"tTrRaAnNsSpPaArReEnNtT\",  0,      HL_TRANSP},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"eExXtTeEnNdD\",            0,      HL_EXTEND},", "                  {\"eExXcClLuUdDeEnNlL\",      0,      HL_EXCLUDENL},", "                  {\"tTrRaAnNsSpPaArReEnNtT\",  0,      HL_TRANSP},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"eExXcClLuUdDeEnNlL\",      0,      HL_EXCLUDENL},", "                  {\"tTrRaAnNsSpPaArReEnNtT\",  0,      HL_TRANSP},", "                  {\"sSkKiIpPnNlL\",            0,      HL_SKIPNL},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"eExXcClLuUdDeEnNlL\",      0,      HL_EXCLUDENL},", "                  {\"tTrRaAnNsSpPaArReEnNtT\",  0,      HL_TRANSP},", "                  {\"sSkKiIpPnNlL\",            0,      HL_SKIPNL},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"tTrRaAnNsSpPaArReEnNtT\",  0,      HL_TRANSP},", "                  {\"sSkKiIpPnNlL\",            0,      HL_SKIPNL},", "                  {\"sSkKiIpPwWhHiItTeE\",      0,      HL_SKIPWHITE},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"tTrRaAnNsSpPaArReEnNtT\",  0,      HL_TRANSP},", "                  {\"sSkKiIpPnNlL\",            0,      HL_SKIPNL},", "                  {\"sSkKiIpPwWhHiItTeE\",      0,      HL_SKIPWHITE},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"sSkKiIpPnNlL\",            0,      HL_SKIPNL},", "                  {\"sSkKiIpPwWhHiItTeE\",      0,      HL_SKIPWHITE},", "                  {\"sSkKiIpPeEmMpPtTyY\",      0,      HL_SKIPEMPTY},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"sSkKiIpPnNlL\",            0,      HL_SKIPNL},", "                  {\"sSkKiIpPwWhHiItTeE\",      0,      HL_SKIPWHITE},", "                  {\"sSkKiIpPeEmMpPtTyY\",      0,      HL_SKIPEMPTY},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"sSkKiIpPwWhHiItTeE\",      0,      HL_SKIPWHITE},", "                  {\"sSkKiIpPeEmMpPtTyY\",      0,      HL_SKIPEMPTY},", "                  {\"gGrRoOuUpPhHeErReE\",      0,      HL_SYNC_HERE},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"sSkKiIpPwWhHiItTeE\",      0,      HL_SKIPWHITE},", "                  {\"sSkKiIpPeEmMpPtTyY\",      0,      HL_SKIPEMPTY},", "                  {\"gGrRoOuUpPhHeErReE\",      0,      HL_SYNC_HERE},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"sSkKiIpPeEmMpPtTyY\",      0,      HL_SKIPEMPTY},", "                  {\"gGrRoOuUpPhHeErReE\",      0,      HL_SYNC_HERE},", "                  {\"gGrRoOuUpPtThHeErReE\",    0,      HL_SYNC_THERE},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"sSkKiIpPeEmMpPtTyY\",      0,      HL_SKIPEMPTY},", "                  {\"gGrRoOuUpPhHeErReE\",      0,      HL_SYNC_HERE},", "                  {\"gGrRoOuUpPtThHeErReE\",    0,      HL_SYNC_THERE},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"gGrRoOuUpPhHeErReE\",      0,      HL_SYNC_HERE},", "                  {\"gGrRoOuUpPtThHeErReE\",    0,      HL_SYNC_THERE},", "                  {\"dDiIsSpPlLaAyY\",          0,      HL_DISPLAY},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"gGrRoOuUpPhHeErReE\",      0,      HL_SYNC_HERE},", "                  {\"gGrRoOuUpPtThHeErReE\",    0,      HL_SYNC_THERE},", "                  {\"dDiIsSpPlLaAyY\",          0,      HL_DISPLAY},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"gGrRoOuUpPtThHeErReE\",    0,      HL_SYNC_THERE},", "                  {\"dDiIsSpPlLaAyY\",          0,      HL_DISPLAY},", "                  {\"fFoOlLdD\",                0,      HL_FOLD},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"gGrRoOuUpPtThHeErReE\",    0,      HL_SYNC_THERE},", "                  {\"dDiIsSpPlLaAyY\",          0,      HL_DISPLAY},", "                  {\"fFoOlLdD\",                0,      HL_FOLD},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"dDiIsSpPlLaAyY\",          0,      HL_DISPLAY},", "                  {\"fFoOlLdD\",                0,      HL_FOLD},", "                  {\"cCoOnNcCeEaAlL\",          0,      HL_CONCEAL},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"dDiIsSpPlLaAyY\",          0,      HL_DISPLAY},", "                  {\"fFoOlLdD\",                0,      HL_FOLD},", "                  {\"cCoOnNcCeEaAlL\",          0,      HL_CONCEAL},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"fFoOlLdD\",                0,      HL_FOLD},", "                  {\"cCoOnNcCeEaAlL\",          0,      HL_CONCEAL},", "                  {\"cCoOnNcCeEaAlLeEnNdDsS\",  0,      HL_CONCEALENDS},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"fFoOlLdD\",                0,      HL_FOLD},", "                  {\"cCoOnNcCeEaAlL\",          0,      HL_CONCEAL},", "                  {\"cCoOnNcCeEaAlLeEnNdDsS\",  0,      HL_CONCEALENDS},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"cCoOnNcCeEaAlL\",          0,      HL_CONCEAL},", "                  {\"cCoOnNcCeEaAlLeEnNdDsS\",  0,      HL_CONCEALENDS},", "                  {\"cCcChHaArR\",              11,     0},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"cCoOnNcCeEaAlL\",          0,      HL_CONCEAL},", "                  {\"cCoOnNcCeEaAlLeEnNdDsS\",  0,      HL_CONCEALENDS},", "                  {\"cCcChHaArR\",              11,     0},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"cCoOnNcCeEaAlLeEnNdDsS\",  0,      HL_CONCEALENDS},", "                  {\"cCcChHaArR\",              11,     0},", "                  {\"cCoOnNtTaAiInNsS\",        1,      0},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"cCoOnNcCeEaAlLeEnNdDsS\",  0,      HL_CONCEALENDS},", "                  {\"cCcChHaArR\",              11,     0},", "                  {\"cCoOnNtTaAiInNsS\",        1,      0},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"cCcChHaArR\",              11,     0},", "                  {\"cCoOnNtTaAiInNsS\",        1,      0},", "                  {\"cCoOnNtTaAiInNeEdDiInN\",  2,      0},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"cCcChHaArR\",              11,     0},", "                  {\"cCoOnNtTaAiInNsS\",        1,      0},", "                  {\"cCoOnNtTaAiInNeEdDiInN\",  2,      0},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"cCoOnNtTaAiInNsS\",        1,      0},", "                  {\"cCoOnNtTaAiInNeEdDiInN\",  2,      0},", "                  {\"nNeExXtTgGrRoOuUpP\",      3,      0},};"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"cCoOnNtTaAiInNsS\",        1,      0},", "                  {\"cCoOnNtTaAiInNeEdDiInN\",  2,      0},", "                  {\"nNeExXtTgGrRoOuUpP\",      3,      0},};"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"cCoOnNtTaAiInNeEdDiInN\",  2,      0},", "                  {\"nNeExXtTgGrRoOuUpP\",      3,      0},};", "  static const char *const first_letters = \"cCoOkKeEtTsSgGdDfFnN\";"], "whitespace/comma"]
["src/nvim/syntax.c", ["                  {\"cCoOnNtTaAiInNeEdDiInN\",  2,      0},", "                  {\"nNeExXtTgGrRoOuUpP\",      3,      0},};", "  static const char *const first_letters = \"cCoOkKeEtTsSgGdDfFnN\";"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"cCoOnNtTaAiInNeEdDiInN\",  2,      0},", "                  {\"nNeExXtTgGrRoOuUpP\",      3,      0},};", "  static const char *const first_letters = \"cCoOkKeEtTsSgGdDfFnN\";"], "whitespace/braces"]
["src/nvim/syntax.c", ["", "  if (arg == NULL)              /* already detected error */", "    return NULL;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  if (arg == NULL)              /* already detected error */", "    return NULL;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  if (curwin->w_s->b_syn_conceal)", "    opt->flags |= HL_CONCEAL;"], "readability/braces"]
["src/nvim/syntax.c", ["  for (;; ) {", "    /*", "     * This is used very often when a large number of keywords is defined."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["     */", "    if (strchr(first_letters, *arg) == NULL)", "      break;"], "readability/braces"]
["src/nvim/syntax.c", ["      for (i = 0, len = 0; p[i] != NUL; i += 2, ++len) {", "        if (arg[len] != p[i] && arg[len] != p[i + 1])", "          break;"], "readability/braces"]
["src/nvim/syntax.c", ["                              : ends_excmd(arg[len])))) {", "        if (opt->keyword", "            && (flagtab[fidx].flags == HL_DISPLAY"], "readability/braces"]
["src/nvim/syntax.c", ["                || flagtab[fidx].flags == HL_EXTEND))", "          /* treat \"display\", \"fold\" and \"extend\" as a keyword */", "          fidx = -1;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    }", "    if (fidx < 0)           /* no match found */", "      break;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    }", "    if (fidx < 0)           /* no match found */", "      break;"], "readability/braces"]
["src/nvim/syntax.c", ["        arg = skiptowhite(arg);", "        if (gname_start == arg)", "          return NULL;"], "readability/braces"]
["src/nvim/syntax.c", ["          int i;", "          for (i = curwin->w_s->b_syn_patterns.ga_len; --i >= 0; )", "            if (SYN_ITEMS(curwin->w_s)[i].sp_syn.id == syn_id"], "readability/braces"]
["src/nvim/syntax.c", ["        arg = skipwhite(arg);", "      } else if (flagtab[fidx].flags == HL_FOLD", "                 && foldmethodIsSyntax(curwin))"], "readability/braces"]
["src/nvim/syntax.c", ["                 && foldmethodIsSyntax(curwin))", "        /* Need to update folds later. */", "        foldUpdateAll(curwin);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Adjustments to syntax item when declared in a \":syn include\"'d file."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["{", "  if ((*flagsp & HL_CONTAINED) || curwin->w_s->b_syn_topgrp == 0)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["    syn_combine_list(&SYN_CLSTR(curwin->w_s)[tlg_id].scl_list, &grp_list,", "        CLUSTER_ADD);", "  }"], "whitespace/alignment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax include [@{group-name}] filename\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  int prev_syn_inc_tag;", "  int source = FALSE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["  eap->nextcmd = find_nextcmd(arg);", "  if (eap->skip)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["  if (arg[0] == '@') {", "    ++arg;", "    rest = get_group_name(arg, &group_name_end);"], "readability/increment"]
["src/nvim/syntax.c", ["    sgl_id = syn_check_cluster(arg, (int)(group_name_end - arg));", "    if (sgl_id == 0)", "      return;"], "readability/braces"]
["src/nvim/syntax.c", ["      return;", "    /* separate_nextcmd() and expand_filename() depend on this */", "    eap->arg = rest;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Everything that's left, up to the next command, should be the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (expand_filename(eap, syn_cmdlinep, &errormsg) == FAIL) {", "      if (errormsg != NULL)", "        EMSG(errormsg);"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * Save and restore the existing top-level grouplist id and \":syn"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax keyword {group-name} [{option}] keyword ..\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  if (rest != NULL)", "    eap->nextcmd = check_nextcmd(rest);"], "readability/braces"]
["src/nvim/syntax.c", ["    eap->nextcmd = check_nextcmd(rest);", "  else", "    EMSG2(_(e_invarg2), arg);"], "readability/braces"]
["src/nvim/syntax.c", ["  redraw_curbuf_later(SOME_VALID);", "  syn_stack_free_all(curwin->w_s);              /* Need to recompute all syntax. */", "}"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  redraw_curbuf_later(SOME_VALID);", "  syn_stack_free_all(curwin->w_s);              /* Need to recompute all syntax. */", "}"], "whitespace/line_length"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax match {name} [{options}] {pattern} [{options}]\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    exarg_T *eap,", "    int syncing                        /* TRUE for \":syntax sync match .. \" */", ")"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  char_u      *rest;", "  synpat_T item;                /* the item found in the line */", "  int syn_id;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* Isolate the group name, check for validity */", "  rest = get_group_name(arg, &group_name_end);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* Get options before the pattern */", "  syn_opt_arg.flags = 0;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* get the pattern. */", "  init_syn_patterns();"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  if (rest != NULL) {           /* all arguments are valid */", "    /*"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (rest != NULL) {           /* all arguments are valid */", "    /*", "     * Check for trailing command and illegal trailing arguments."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    eap->nextcmd = check_nextcmd(rest);", "    if (!ends_excmd(*rest) || eap->skip)", "      rest = NULL;"], "readability/braces"]
["src/nvim/syntax.c", ["      rest = NULL;", "    else {", "      if ((syn_id = syn_check_group(arg, (int)(group_name_end - arg))) != 0) {"], "readability/braces"]
["src/nvim/syntax.c", ["      rest = NULL;", "    else {", "      if ((syn_id = syn_check_group(arg, (int)(group_name_end - arg))) != 0) {"], "readability/braces"]
["src/nvim/syntax.c", ["        syn_incl_toplevel(syn_id, &syn_opt_arg.flags);", "        /*", "         * Store the pattern in the syn_items list"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        spp->sp_cchar = conceal_char;", "        if (syn_opt_arg.cont_in_list != NULL)", "          curwin->w_s->b_syn_containedin = TRUE;"], "readability/braces"]
["src/nvim/syntax.c", ["        if (syn_opt_arg.cont_in_list != NULL)", "          curwin->w_s->b_syn_containedin = TRUE;", "        spp->sp_next_list = syn_opt_arg.next_list;"], "readability/bool"]
["src/nvim/syntax.c", ["", "        /* remember that we found a match for syncing on */", "        if (syn_opt_arg.flags & (HL_SYNC_HERE|HL_SYNC_THERE))"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        /* remember that we found a match for syncing on */", "        if (syn_opt_arg.flags & (HL_SYNC_HERE|HL_SYNC_THERE))", "          curwin->w_s->b_syn_sync_flags |= SF_MATCH;"], "readability/braces"]
["src/nvim/syntax.c", ["          curwin->w_s->b_syn_sync_flags |= SF_MATCH;", "        if (syn_opt_arg.flags & HL_FOLD)", "          ++curwin->w_s->b_syn_folditems;"], "readability/braces"]
["src/nvim/syntax.c", ["        if (syn_opt_arg.flags & HL_FOLD)", "          ++curwin->w_s->b_syn_folditems;", ""], "readability/increment"]
["src/nvim/syntax.c", ["        redraw_curbuf_later(SOME_VALID);", "        syn_stack_free_all(curwin->w_s);          /* Need to recompute all syntax. */", "        return;           /* don't free the progs and patterns now */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        redraw_curbuf_later(SOME_VALID);", "        syn_stack_free_all(curwin->w_s);          /* Need to recompute all syntax. */", "        return;           /* don't free the progs and patterns now */"], "whitespace/line_length"]
["src/nvim/syntax.c", ["        syn_stack_free_all(curwin->w_s);          /* Need to recompute all syntax. */", "        return;           /* don't free the progs and patterns now */", "      }"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Something failed, free the allocated memory."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  if (rest == NULL)", "    EMSG2(_(e_invarg2), arg);"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax region {group-name} [matchgroup={group-name}]"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    exarg_T *eap,", "    int syncing                        /* TRUE for \":syntax sync region ..\" */", ")"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  char_u              *group_name_end;", "  char_u              *rest;                    /* next arg, NULL on error */", "  char_u              *key_end;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  struct pat_ptr {", "    synpat_T        *pp_synp;                   /* pointer to syn_pattern */", "    int pp_matchgroup_id;                       /* matchgroup ID */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    synpat_T        *pp_synp;                   /* pointer to syn_pattern */", "    int pp_matchgroup_id;                       /* matchgroup ID */", "    struct pat_ptr  *pp_next;                   /* pointer to next pat_ptr */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    int pp_matchgroup_id;                       /* matchgroup ID */", "    struct pat_ptr  *pp_next;                   /* pointer to next pat_ptr */", "  }                   *(pat_ptrs[3]);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  }                   *(pat_ptrs[3]);", "  /* patterns found in the line */", "  struct pat_ptr      *ppp;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  struct pat_ptr      *ppp_next;", "  int pat_count = 0;                            /* nr of syn_patterns found */", "  int syn_id;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  int matchgroup_id = 0;", "  int not_enough = FALSE;                       /* not enough arguments */", "  int illegal = FALSE;                          /* illegal arguments */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  int matchgroup_id = 0;", "  int not_enough = FALSE;                       /* not enough arguments */", "  int illegal = FALSE;                          /* illegal arguments */"], "readability/bool"]
["src/nvim/syntax.c", ["  int not_enough = FALSE;                       /* not enough arguments */", "  int illegal = FALSE;                          /* illegal arguments */", "  int success = FALSE;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  int not_enough = FALSE;                       /* not enough arguments */", "  int illegal = FALSE;                          /* illegal arguments */", "  int success = FALSE;"], "readability/bool"]
["src/nvim/syntax.c", ["  int illegal = FALSE;                          /* illegal arguments */", "  int success = FALSE;", "  syn_opt_arg_T syn_opt_arg;"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /* Isolate the group name, check for validity */", "  rest = get_group_name(arg, &group_name_end);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /* must be a pattern or matchgroup then */", "    key_end = rest;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    key_end = rest;", "    while (*key_end && !ascii_iswhite(*key_end) && *key_end != '=')", "      ++key_end;"], "readability/braces"]
["src/nvim/syntax.c", ["    while (*key_end && !ascii_iswhite(*key_end) && *key_end != '=')", "      ++key_end;", "    xfree(key);"], "readability/increment"]
["src/nvim/syntax.c", ["    if (*rest == NUL) {", "      not_enough = TRUE;", "      break;"], "readability/bool"]
["src/nvim/syntax.c", ["      p = skiptowhite(rest);", "      if ((p - rest == 4 && STRNCMP(rest, \"NONE\", 4) == 0) || eap->skip)", "        matchgroup_id = 0;"], "readability/braces"]
["src/nvim/syntax.c", ["        matchgroup_id = 0;", "      else {", "        matchgroup_id = syn_check_group(rest, (int)(p - rest));"], "readability/braces"]
["src/nvim/syntax.c", ["        matchgroup_id = 0;", "      else {", "        matchgroup_id = syn_check_group(rest, (int)(p - rest));"], "readability/braces"]
["src/nvim/syntax.c", ["        if (matchgroup_id == 0) {", "          illegal = TRUE;", "          break;"], "readability/bool"]
["src/nvim/syntax.c", ["    } else {", "      /*", "       * Allocate room for a syn_pattern, and link it in the list of"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  xfree(key);", "  if (illegal || not_enough)", "    rest = NULL;"], "readability/braces"]
["src/nvim/syntax.c", ["  if (rest != NULL) {", "    /*", "     * Check for trailing garbage or command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    eap->nextcmd = check_nextcmd(rest);", "    if (!ends_excmd(*rest) || eap->skip)", "      rest = NULL;"], "readability/braces"]
["src/nvim/syntax.c", ["      rest = NULL;", "    else {", "      ga_grow(&(curwin->w_s->b_syn_patterns), pat_count);"], "readability/braces"]
["src/nvim/syntax.c", ["      rest = NULL;", "    else {", "      ga_grow(&(curwin->w_s->b_syn_patterns), pat_count);"], "readability/braces"]
["src/nvim/syntax.c", ["        syn_incl_toplevel(syn_id, &syn_opt_arg.flags);", "        /*", "         * Store the start/skip/end in the syn_items list"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        int idx = curwin->w_s->b_syn_patterns.ga_len;", "        for (item = ITEM_START; item <= ITEM_END; ++item) {", "          for (ppp = pat_ptrs[item]; ppp != NULL; ppp = ppp->pp_next) {"], "readability/increment"]
["src/nvim/syntax.c", ["                syn_opt_arg.cont_in_list;", "              if (syn_opt_arg.cont_in_list != NULL)", "                curwin->w_s->b_syn_containedin = TRUE;"], "readability/braces"]
["src/nvim/syntax.c", ["              if (syn_opt_arg.cont_in_list != NULL)", "                curwin->w_s->b_syn_containedin = TRUE;", "              SYN_ITEMS(curwin->w_s)[idx].sp_next_list ="], "readability/bool"]
["src/nvim/syntax.c", ["            }", "            ++curwin->w_s->b_syn_patterns.ga_len;", "            ++idx;"], "readability/increment"]
["src/nvim/syntax.c", ["            ++curwin->w_s->b_syn_patterns.ga_len;", "            ++idx;", "            if (syn_opt_arg.flags & HL_FOLD)"], "readability/increment"]
["src/nvim/syntax.c", ["            ++idx;", "            if (syn_opt_arg.flags & HL_FOLD)", "              ++curwin->w_s->b_syn_folditems;"], "readability/braces"]
["src/nvim/syntax.c", ["            if (syn_opt_arg.flags & HL_FOLD)", "              ++curwin->w_s->b_syn_folditems;", "          }"], "readability/increment"]
["src/nvim/syntax.c", ["        redraw_curbuf_later(SOME_VALID);", "        syn_stack_free_all(curwin->w_s);          /* Need to recompute all syntax. */", "        success = TRUE;               /* don't free the progs and patterns now */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        redraw_curbuf_later(SOME_VALID);", "        syn_stack_free_all(curwin->w_s);          /* Need to recompute all syntax. */", "        success = TRUE;               /* don't free the progs and patterns now */"], "whitespace/line_length"]
["src/nvim/syntax.c", ["        syn_stack_free_all(curwin->w_s);          /* Need to recompute all syntax. */", "        success = TRUE;               /* don't free the progs and patterns now */", "      }"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        syn_stack_free_all(curwin->w_s);          /* Need to recompute all syntax. */", "        success = TRUE;               /* don't free the progs and patterns now */", "      }"], "whitespace/line_length"]
["src/nvim/syntax.c", ["        syn_stack_free_all(curwin->w_s);          /* Need to recompute all syntax. */", "        success = TRUE;               /* don't free the progs and patterns now */", "      }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /*", "   * Free the allocated memory."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  for (item = ITEM_START; item <= ITEM_END; ++item)", "    for (ppp = pat_ptrs[item]; ppp != NULL; ppp = ppp_next) {"], "readability/braces"]
["src/nvim/syntax.c", ["   */", "  for (item = ITEM_START; item <= ITEM_END; ++item)", "    for (ppp = pat_ptrs[item]; ppp != NULL; ppp = ppp_next) {"], "readability/increment"]
["src/nvim/syntax.c", ["    xfree(syn_opt_arg.next_list);", "    if (not_enough)", "      EMSG2(_(\"E399: Not enough arguments: syntax region %s\"), arg);"], "readability/braces"]
["src/nvim/syntax.c", ["      EMSG2(_(\"E399: Not enough arguments: syntax region %s\"), arg);", "    else if (illegal || rest == NULL)", "      EMSG2(_(e_invarg2), arg);"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * Handle degenerate cases."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  if (*clstr2 == NULL)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["  if (*clstr1 == NULL || list_op == CLUSTER_REPLACE) {", "    if (list_op == CLUSTER_REPLACE)", "      xfree(*clstr1);"], "readability/braces"]
["src/nvim/syntax.c", ["      xfree(*clstr1);", "    if (list_op == CLUSTER_REPLACE || list_op == CLUSTER_ADD)", "      *clstr1 = *clstr2;"], "readability/braces"]
["src/nvim/syntax.c", ["      *clstr1 = *clstr2;", "    else", "      xfree(*clstr2);"], "readability/braces"]
["src/nvim/syntax.c", ["", "    /*", "     * First, loop through the lists until one of them is empty."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    while (*g1 && *g2) {", "      /*", "       * We always want to add from the first list."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (*g1 < *g2) {", "        if (round == 2)", "          clstr[count] = *g1;"], "readability/braces"]
["src/nvim/syntax.c", ["      }", "      /*", "       * We only want to add from the second list if we're adding the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (list_op == CLUSTER_ADD) {", "        if (round == 2)", "          clstr[count] = *g2;"], "readability/braces"]
["src/nvim/syntax.c", ["      }", "      if (*g1 == *g2)", "        g1++;"], "readability/braces"]
["src/nvim/syntax.c", ["", "    /*", "     * Now add the leftovers from whichever list didn't get finished"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["     */", "    for (; *g1; g1++, count++)", "      if (round == 2)"], "readability/braces"]
["src/nvim/syntax.c", ["    for (; *g1; g1++, count++)", "      if (round == 2)", "        clstr[count] = *g1;"], "readability/braces"]
["src/nvim/syntax.c", ["        clstr[count] = *g1;", "    if (list_op == CLUSTER_ADD)", "      for (; *g2; g2++, count++)"], "readability/braces"]
["src/nvim/syntax.c", ["    if (list_op == CLUSTER_ADD)", "      for (; *g2; g2++, count++)", "        if (round == 2)"], "readability/braces"]
["src/nvim/syntax.c", ["      for (; *g2; g2++, count++)", "        if (round == 2)", "          clstr[count] = *g2;"], "readability/braces"]
["src/nvim/syntax.c", ["    if (round == 1) {", "      /*", "       * If the group ended up empty, we don't need to allocate any"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Finally, put the new list in place."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Like syn_scl_name2id(), but take a pointer + length argument."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  id = syn_scl_name2id(name);", "  if (id == 0)                          /* doesn't exist yet */", "    id = syn_add_cluster(name);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  id = syn_scl_name2id(name);", "  if (id == 0)                          /* doesn't exist yet */", "    id = syn_add_cluster(name);"], "readability/braces"]
["src/nvim/syntax.c", ["    id = syn_add_cluster(name);", "  else", "    xfree(name);"], "readability/braces"]
["src/nvim/syntax.c", ["{", "  /*", "   * First call for this growarray: init growing array."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  if (STRICMP(name, \"Spell\") == 0)", "    curwin->w_s->b_spell_cluster_id = len + SYNID_CLUSTER;"], "readability/braces"]
["src/nvim/syntax.c", ["    curwin->w_s->b_spell_cluster_id = len + SYNID_CLUSTER;", "  if (STRICMP(name, \"NoSpell\") == 0)", "    curwin->w_s->b_nospell_cluster_id = len + SYNID_CLUSTER;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax cluster {cluster-name} [contains={groupname},..]"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  eap->nextcmd = find_nextcmd(arg);", "  if (eap->skip)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["        list_op = CLUSTER_REPLACE;", "      } else", "        break;"], "readability/braces"]
["src/nvim/syntax.c", ["      redraw_curbuf_later(SOME_VALID);", "      syn_stack_free_all(curwin->w_s);          /* Need to recompute all. */", "    }"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  if (!got_clstr)", "    EMSG(_(\"E400: No cluster specified\"));"], "readability/braces"]
["src/nvim/syntax.c", ["    EMSG(_(\"E400: No cluster specified\"));", "  if (rest == NULL || !ends_excmd(*rest))", "    EMSG2(_(e_invarg2), arg);"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * On first call for current buffer: Init growing array."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Get one pattern for a \":syntax match\" or \":syntax region\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  end = skip_regexp(arg + 1, *arg, TRUE, NULL);", "  if (*end != *arg) {                       /* end delimiter not found */"], "readability/bool"]
["src/nvim/syntax.c", ["  end = skip_regexp(arg + 1, *arg, TRUE, NULL);", "  if (*end != *arg) {                       /* end delimiter not found */", "    EMSG2(_(\"E401: Pattern delimiter not found: %s\"), arg);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* Make 'cpoptions' empty, to avoid the 'l' flag */", "  cpo_save = p_cpo;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  if (ci->sp_prog == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * Check for a match, highlight or region offset."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  ++end;", "  do {"], "readability/increment"]
["src/nvim/syntax.c", ["  do {", "    for (idx = SPO_COUNT; --idx >= 0; )", "      if (STRNCMP(end, spo_name_tab[idx], 3) == 0)"], "readability/braces"]
["src/nvim/syntax.c", ["    for (idx = SPO_COUNT; --idx >= 0; )", "      if (STRNCMP(end, spo_name_tab[idx], 3) == 0)", "        break;"], "readability/braces"]
["src/nvim/syntax.c", ["      p = &(ci->sp_offsets[idx]);", "      if (idx != SPO_LC_OFF)", "        switch (end[3]) {"], "readability/braces"]
["src/nvim/syntax.c", ["        ci->sp_off_flags |= (1 << idx);", "        if (idx == SPO_LC_OFF) {            /* lc=99 */", "          end += 3;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "          /* \"lc=\" offset automatically sets \"ms=\" offset */", "          if (!(ci->sp_off_flags & (1 << SPO_MS_OFF))) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["          }", "        } else {                          /* yy=x+99 */", "          end += 4;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        }", "        if (*end != ',')", "          break;"], "readability/braces"]
["src/nvim/syntax.c", ["          break;", "        ++end;", "      }"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax sync ..\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  char_u      *next_arg;", "  int illegal = FALSE;", "  int finished = FALSE;"], "readability/bool"]
["src/nvim/syntax.c", ["  int illegal = FALSE;", "  int finished = FALSE;", "  long n;"], "readability/bool"]
["src/nvim/syntax.c", ["  if (ends_excmd(*arg_start)) {", "    syn_cmd_list(eap, TRUE);", "    return;"], "readability/bool"]
["src/nvim/syntax.c", ["    if (STRCMP(key, \"CCOMMENT\") == 0) {", "      if (!eap->skip)", "        curwin->w_s->b_syn_sync_flags |= SF_CCOMMENT;"], "readability/braces"]
["src/nvim/syntax.c", ["        arg_end = skiptowhite(next_arg);", "        if (!eap->skip)", "          curwin->w_s->b_syn_sync_id = syn_check_group(next_arg,"], "readability/braces"]
["src/nvim/syntax.c", ["          curwin->w_s->b_syn_sync_id = syn_check_group(next_arg,", "              (int)(arg_end - next_arg));", "        next_arg = skipwhite(arg_end);"], "whitespace/alignment"]
["src/nvim/syntax.c", ["        next_arg = skipwhite(arg_end);", "      } else if (!eap->skip)", "        curwin->w_s->b_syn_sync_id = syn_name2id((char_u *)\"Comment\");"], "readability/braces"]
["src/nvim/syntax.c", ["    } else if (  STRNCMP(key, \"LINES\", 5) == 0", "                 || STRNCMP(key, \"MINLINES\", 8) == 0", "                 || STRNCMP(key, \"MAXLINES\", 8) == 0"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                 || STRNCMP(key, \"MINLINES\", 8) == 0", "                 || STRNCMP(key, \"MAXLINES\", 8) == 0", "                 || STRNCMP(key, \"LINEBREAKS\", 10) == 0) {"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                 || STRNCMP(key, \"MAXLINES\", 8) == 0", "                 || STRNCMP(key, \"LINEBREAKS\", 10) == 0) {", "      if (key[4] == 'S')"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                 || STRNCMP(key, \"LINEBREAKS\", 10) == 0) {", "      if (key[4] == 'S')", "        arg_end = key + 6;"], "readability/braces"]
["src/nvim/syntax.c", ["        arg_end = key + 6;", "      else if (key[0] == 'L')", "        arg_end = key + 11;"], "readability/braces"]
["src/nvim/syntax.c", ["        arg_end = key + 11;", "      else", "        arg_end = key + 9;"], "readability/braces"]
["src/nvim/syntax.c", ["      if (arg_end[-1] != '=' || !ascii_isdigit(*arg_end)) {", "        illegal = TRUE;", "        break;"], "readability/bool"]
["src/nvim/syntax.c", ["      if (!eap->skip) {", "        if (key[4] == 'B')", "          curwin->w_s->b_syn_sync_linebreaks = n;"], "readability/braces"]
["src/nvim/syntax.c", ["          curwin->w_s->b_syn_sync_linebreaks = n;", "        else if (key[1] == 'A')", "          curwin->w_s->b_syn_sync_maxlines = n;"], "readability/braces"]
["src/nvim/syntax.c", ["          curwin->w_s->b_syn_sync_maxlines = n;", "        else", "          curwin->w_s->b_syn_sync_minlines = n;"], "readability/braces"]
["src/nvim/syntax.c", ["      if (curwin->w_s->b_syn_linecont_pat != NULL) {", "        EMSG(_(\"E403: syntax sync: line continuations pattern specified twice\"));", "        finished = TRUE;"], "whitespace/line_length"]
["src/nvim/syntax.c", ["        EMSG(_(\"E403: syntax sync: line continuations pattern specified twice\"));", "        finished = TRUE;", "        break;"], "readability/bool"]
["src/nvim/syntax.c", ["      }", "      arg_end = skip_regexp(next_arg + 1, *next_arg, TRUE, NULL);", "      if (*arg_end != *next_arg) {          /* end delimiter not found */"], "readability/bool"]
["src/nvim/syntax.c", ["      arg_end = skip_regexp(next_arg + 1, *next_arg, TRUE, NULL);", "      if (*arg_end != *next_arg) {          /* end delimiter not found */", "        illegal = TRUE;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (*arg_end != *next_arg) {          /* end delimiter not found */", "        illegal = TRUE;", "        break;"], "readability/bool"]
["src/nvim/syntax.c", ["      if (!eap->skip) {", "        /* store the pattern and compiled regexp program */", "        curwin->w_s->b_syn_linecont_pat ="], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "        /* Make 'cpoptions' empty, to avoid the 'l' flag */", "        cpo_save = p_cpo;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      eap->arg = next_arg;", "      if (STRCMP(key, \"MATCH\") == 0)", "        syn_cmd_match(eap, TRUE);"], "readability/braces"]
["src/nvim/syntax.c", ["      if (STRCMP(key, \"MATCH\") == 0)", "        syn_cmd_match(eap, TRUE);", "      else if (STRCMP(key, \"REGION\") == 0)"], "readability/bool"]
["src/nvim/syntax.c", ["        syn_cmd_match(eap, TRUE);", "      else if (STRCMP(key, \"REGION\") == 0)", "        syn_cmd_region(eap, TRUE);"], "readability/braces"]
["src/nvim/syntax.c", ["      else if (STRCMP(key, \"REGION\") == 0)", "        syn_cmd_region(eap, TRUE);", "      else if (STRCMP(key, \"CLEAR\") == 0)"], "readability/bool"]
["src/nvim/syntax.c", ["        syn_cmd_region(eap, TRUE);", "      else if (STRCMP(key, \"CLEAR\") == 0)", "        syn_cmd_clear(eap, TRUE);"], "readability/braces"]
["src/nvim/syntax.c", ["      else if (STRCMP(key, \"CLEAR\") == 0)", "        syn_cmd_clear(eap, TRUE);", "      else"], "readability/bool"]
["src/nvim/syntax.c", ["        syn_cmd_clear(eap, TRUE);", "      else", "        illegal = TRUE;"], "readability/braces"]
["src/nvim/syntax.c", ["      else", "        illegal = TRUE;", "      finished = TRUE;"], "readability/bool"]
["src/nvim/syntax.c", ["        illegal = TRUE;", "      finished = TRUE;", "      break;"], "readability/bool"]
["src/nvim/syntax.c", ["  xfree(key);", "  if (illegal)", "    EMSG2(_(\"E404: Illegal arguments: %s\"), arg_start);"], "readability/braces"]
["src/nvim/syntax.c", ["    EMSG2(_(\"E404: Illegal arguments: %s\"), arg_start);", "  else if (!finished) {", "    eap->nextcmd = check_nextcmd(arg_start);"], "readability/braces"]
["src/nvim/syntax.c", ["    redraw_curbuf_later(SOME_VALID);", "    syn_stack_free_all(curwin->w_s);            /* Need to recompute all syntax. */", "  }"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    redraw_curbuf_later(SOME_VALID);", "    syn_stack_free_all(curwin->w_s);            /* Need to recompute all syntax. */", "  }"], "whitespace/line_length"]
["src/nvim/syntax.c", ["", "/*", " * Convert a line of highlight group names into a list of group ID numbers."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (       STRCMP(name + 1, \"ALLBUT\") == 0", "                 || STRCMP(name + 1, \"ALL\") == 0", "                 || STRCMP(name + 1, \"TOP\") == 0"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                 || STRCMP(name + 1, \"ALL\") == 0", "                 || STRCMP(name + 1, \"TOP\") == 0", "                 || STRCMP(name + 1, \"CONTAINED\") == 0) {"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                 || STRCMP(name + 1, \"TOP\") == 0", "                 || STRCMP(name + 1, \"CONTAINED\") == 0) {", "        if (TOUPPER_ASC(**arg) != 'C') {"], "whitespace/alignment"]
["src/nvim/syntax.c", ["      } else {", "        /*", "         * Handle full group name."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "          regmatch.rm_ic = TRUE;", "          id = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["        }", "        ++count;", "      }"], "readability/increment"]
["src/nvim/syntax.c", ["      p = skipwhite(end);", "      if (*p != ',')", "        break;"], "readability/braces"]
["src/nvim/syntax.c", ["        break;", "      p = skipwhite(p + 1);             /* skip comma in between arguments */", "    } while (!ends_excmd(*p));"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    } while (!ends_excmd(*p));", "    if (failed)", "      break;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  if (*list == NULL)", "    *list = retval;"], "readability/braces"]
["src/nvim/syntax.c", ["    *list = retval;", "  else", "    xfree(retval);           /* list already found, don't overwrite it */"], "readability/braces"]
["src/nvim/syntax.c", ["  else", "    xfree(retval);           /* list already found, don't overwrite it */", ""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Make a copy of an ID list."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Check if syntax group \"ssp\" is in the ID list \"list\" of \"cur_si\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* If ssp has a \"containedin\" list and \"cur_si\" is in it, return TRUE. */", "  if (cur_si != NULL && ssp->cont_in_list != NULL"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      && !(cur_si->si_flags & HL_MATCH)) {", "    /* Ignore transparent items without a contains argument.  Double check", "     * that we don't go back past the first one. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["     * that we don't go back past the first one. */", "    while ((cur_si->si_flags & HL_TRANS_CONT)", "           && cur_si > (stateitem_T *)(current_state.ga_data))"], "readability/braces"]
["src/nvim/syntax.c", ["           && cur_si > (stateitem_T *)(current_state.ga_data))", "      --cur_si;", "    /* cur_si->si_idx is -1 for keywords, these never contain anything. */"], "readability/increment"]
["src/nvim/syntax.c", ["      --cur_si;", "    /* cur_si->si_idx is -1 for keywords, these never contain anything. */", "    if (cur_si->si_idx >= 0 && in_id_list(NULL, ssp->cont_in_list,"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    /* cur_si->si_idx is -1 for keywords, these never contain anything. */", "    if (cur_si->si_idx >= 0 && in_id_list(NULL, ssp->cont_in_list,", "            &(SYN_ITEMS(syn_block)[cur_si->si_idx].sp_syn),"], "readability/braces"]
["src/nvim/syntax.c", ["    if (cur_si->si_idx >= 0 && in_id_list(NULL, ssp->cont_in_list,", "            &(SYN_ITEMS(syn_block)[cur_si->si_idx].sp_syn),", "            SYN_ITEMS(syn_block)[cur_si->si_idx].sp_flags & HL_CONTAINED))"], "whitespace/alignment"]
["src/nvim/syntax.c", ["            &(SYN_ITEMS(syn_block)[cur_si->si_idx].sp_syn),", "            SYN_ITEMS(syn_block)[cur_si->si_idx].sp_flags & HL_CONTAINED))", "      return TRUE;"], "whitespace/alignment"]
["src/nvim/syntax.c", ["            SYN_ITEMS(syn_block)[cur_si->si_idx].sp_flags & HL_CONTAINED))", "      return TRUE;", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  if (list == NULL)", "    return FALSE;"], "readability/braces"]
["src/nvim/syntax.c", ["  if (list == NULL)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["", "  /*", "   * If list is ID_LIST_ALL, we are in a transparent item that isn't"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  if (list == ID_LIST_ALL)", "    return !contained;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * If the first item is \"ALLBUT\", return TRUE if \"id\" is NOT in the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (item < SYNID_TOP) {", "      /* ALL or ALLBUT: accept all groups in the same file */", "      if (item - SYNID_ALLBUT != ssp->inc_tag)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      /* ALL or ALLBUT: accept all groups in the same file */", "      if (item - SYNID_ALLBUT != ssp->inc_tag)", "        return FALSE;"], "readability/braces"]
["src/nvim/syntax.c", ["      if (item - SYNID_ALLBUT != ssp->inc_tag)", "        return FALSE;", "    } else if (item < SYNID_CONTAINED)   {"], "readability/bool"]
["src/nvim/syntax.c", ["    } else if (item < SYNID_CONTAINED)   {", "      /* TOP: accept all not-contained groups in the same file */", "      if (item - SYNID_TOP != ssp->inc_tag || contained)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      /* TOP: accept all not-contained groups in the same file */", "      if (item - SYNID_TOP != ssp->inc_tag || contained)", "        return FALSE;"], "readability/braces"]
["src/nvim/syntax.c", ["      if (item - SYNID_TOP != ssp->inc_tag || contained)", "        return FALSE;", "    } else {"], "readability/bool"]
["src/nvim/syntax.c", ["    } else {", "      /* CONTAINED: accept all contained groups in the same file */", "      if (item - SYNID_CONTAINED != ssp->inc_tag || !contained)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      /* CONTAINED: accept all contained groups in the same file */", "      if (item - SYNID_CONTAINED != ssp->inc_tag || !contained)", "        return FALSE;"], "readability/braces"]
["src/nvim/syntax.c", ["      if (item - SYNID_CONTAINED != ssp->inc_tag || !contained)", "        return FALSE;", "    }"], "readability/bool"]
["src/nvim/syntax.c", ["    item = *++list;", "    retval = FALSE;", "  } else"], "readability/bool"]
["src/nvim/syntax.c", ["    retval = FALSE;", "  } else", "    retval = TRUE;"], "readability/braces"]
["src/nvim/syntax.c", ["  } else", "    retval = TRUE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["", "  /*", "   * Return \"retval\" if id is in the contains list."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  while (item != 0) {", "    if (item == id)", "      return retval;"], "readability/braces"]
["src/nvim/syntax.c", ["      scl_list = SYN_CLSTR(syn_block)[item - SYNID_CLUSTER].scl_list;", "      /* restrict recursiveness to 30 to avoid an endless loop for a", "       * cluster that includes itself (indirectly) */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (scl_list != NULL && depth < 30) {", "        ++depth;", "        r = in_id_list(NULL, scl_list, ssp, contained);"], "readability/increment"]
["src/nvim/syntax.c", ["        r = in_id_list(NULL, scl_list, ssp, contained);", "        --depth;", "        if (r)"], "readability/increment"]
["src/nvim/syntax.c", ["        --depth;", "        if (r)", "          return retval;"], "readability/braces"]
["src/nvim/syntax.c", ["struct subcommand {", "  char    *name;                                /* subcommand name */", "  void    (*func)(exarg_T *, int);              /* function to call */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  char    *name;                                /* subcommand name */", "  void    (*func)(exarg_T *, int);              /* function to call */", "};"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * \":syntax\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      eap->arg = skipwhite(subcmd_end);", "      (subcommands[i].func)(eap, FALSE);", "      break;"], "readability/bool"]
["src/nvim/syntax.c", ["  xfree(subcmd_name);", "  if (eap->skip)", "    --emsg_skip;"], "readability/braces"]
["src/nvim/syntax.c", ["  if (eap->skip)", "    --emsg_skip;", "}"], "readability/increment"]
["src/nvim/syntax.c", ["", "  /* Apply the \"syntax\" autocommand event, this finds and loads the syntax", "   * file. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   * file. */", "  apply_autocmds(EVENT_SYNTAX, eap->arg, curbuf->b_fname, TRUE, curbuf);", ""], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Reset include_link, include_default, include_none to 0."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle command line completion for :match and :echohl command: Add \"None\""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle command line completion for :syntax command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* (part of) subcommand already typed */", "  if (*arg != NUL) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the list syntax names for"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Get extra information about the syntax item.  Must be called right after"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Return conceal substitution character"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Return the syntax ID at position \"i\" in the current stack."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (i >= current_state.ga_len) {", "    /* Need to invalidate the state, because we didn't properly finish it", "     * for the last character, \"keep_state\" was TRUE. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Function called to get folding level for line \"lnum\" in window \"wp\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    level = wp->w_p_fdn;", "    if (level < 0)", "      level = 0;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * \":syntime\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["{", "  if (STRCMP(eap->arg, \"on\") == 0)", "    syn_time_on = TRUE;"], "readability/braces"]
["src/nvim/syntax.c", ["  if (STRCMP(eap->arg, \"on\") == 0)", "    syn_time_on = TRUE;", "  else if (STRCMP(eap->arg, \"off\") == 0)"], "readability/bool"]
["src/nvim/syntax.c", ["    syn_time_on = TRUE;", "  else if (STRCMP(eap->arg, \"off\") == 0)", "    syn_time_on = FALSE;"], "readability/braces"]
["src/nvim/syntax.c", ["  else if (STRCMP(eap->arg, \"off\") == 0)", "    syn_time_on = FALSE;", "  else if (STRCMP(eap->arg, \"clear\") == 0)"], "readability/bool"]
["src/nvim/syntax.c", ["    syn_time_on = FALSE;", "  else if (STRCMP(eap->arg, \"clear\") == 0)", "    syntime_clear();"], "readability/braces"]
["src/nvim/syntax.c", ["    syntime_clear();", "  else if (STRCMP(eap->arg, \"report\") == 0)", "    syntime_report();"], "readability/braces"]
["src/nvim/syntax.c", ["    syntime_report();", "  else", "    EMSG2(_(e_invarg2), eap->arg);"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Clear the syntax timing for the current buffer."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  }", "  for (int idx = 0; idx < curwin->w_s->b_syn_patterns.ga_len; ++idx) {", "    spp = &(SYN_ITEMS(curwin->w_s)[idx]);"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the possible arguments of the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Clear the syntax timing for the current buffer."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  time_entry_T *p;", "  for (int idx = 0; idx < curwin->w_s->b_syn_patterns.ga_len; ++idx) {", "    synpat_T *spp = &(SYN_ITEMS(curwin->w_s)[idx]);"], "readability/increment"]
["src/nvim/syntax.c", ["  MSG_PUTS_TITLE(_(", "          \"  TOTAL      COUNT  MATCH   SLOWEST     AVERAGE   NAME               PATTERN\"));", "  MSG_PUTS(\"\\n\");"], "whitespace/indent"]
["src/nvim/syntax.c", ["  MSG_PUTS_TITLE(_(", "          \"  TOTAL      COUNT  MATCH   SLOWEST     AVERAGE   NAME               PATTERN\"));", "  MSG_PUTS(\"\\n\");"], "whitespace/line_length"]
["src/nvim/syntax.c", ["  MSG_PUTS(\"\\n\");", "  for (int idx = 0; idx < ga.ga_len && !got_int; ++idx) {", "    p = ((time_entry_T *)ga.ga_data) + idx;"], "readability/increment"]
["src/nvim/syntax.c", ["    MSG_PUTS(profile_msg(p->total));", "    MSG_PUTS(\" \");     /* make sure there is always a separating space */", "    msg_advance(13);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    int len;", "    if (Columns < 80)", "      len = 20;       /* will wrap anyway */"], "readability/braces"]
["src/nvim/syntax.c", ["    if (Columns < 80)", "      len = 20;       /* will wrap anyway */", "    else"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      len = 20;       /* will wrap anyway */", "    else", "      len = Columns - 70;"], "readability/braces"]
["src/nvim/syntax.c", ["      len = Columns - 70;", "    if (len > (int)STRLEN(p->pattern))", "      len = (int)STRLEN(p->pattern);"], "readability/braces"]
["src/nvim/syntax.c", ["", "/**************************************", "*  Highlighting stuff\t\t      *"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  \"DiffChange   ctermbg=LightMagenta guibg=LightMagenta\",", "  \"DiffDelete   ctermfg=Blue ctermbg=LightCyan gui=bold guifg=Blue guibg=LightCyan\",", "  \"Directory    ctermfg=DarkBlue guifg=Blue\","], "whitespace/line_length"]
["src/nvim/syntax.c", ["  \"SpellRare    ctermbg=LightMagenta guisp=Magenta gui=undercurl\",", "  \"TabLine      cterm=underline ctermfg=black ctermbg=LightGrey gui=underline guibg=LightGrey\",", "  \"Title        ctermfg=DarkMagenta gui=bold guifg=Magenta\","], "whitespace/line_length"]
["src/nvim/syntax.c", ["  \"DiffChange   ctermbg=DarkMagenta guibg=DarkMagenta\",", "  \"DiffDelete   ctermfg=Blue ctermbg=DarkCyan gui=bold guifg=Blue guibg=DarkCyan\",", "  \"Directory    ctermfg=LightCyan guifg=Cyan\","], "whitespace/line_length"]
["src/nvim/syntax.c", ["  \"SpellRare    ctermbg=Magenta guisp=Magenta gui=undercurl\",", "  \"TabLine      cterm=underline ctermfg=white ctermbg=DarkGrey gui=underline guibg=DarkGrey\",", "  \"Title        ctermfg=LightMagenta gui=bold guifg=Magenta\","], "whitespace/line_length"]
["src/nvim/syntax.c", ["", "  /*", "   * Didn't use a color file, use the compiled-in colors."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* Reverse looks ugly, but grey may not work for 8 colors.  Thus let it", "   * depend on the number of colors available."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * If syntax highlighting is enabled load the highlighting for it."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Load color file \"name\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  xfree(buf);", "  apply_autocmds(EVENT_COLORSCHEME, name, curbuf->b_fname, FALSE, curbuf);", ""], "readability/bool"]
["src/nvim/syntax.c", ["", "          /* When setting the foreground color, and previously the \"bold\"", "           * flag was set for a light color, reset it now */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["          } else if (STRICMP(arg, \"bg\") == 0)   {", "            if (cterm_normal_bg_color > 0)", "              color = cterm_normal_bg_color - 1;"], "readability/braces"]
["src/nvim/syntax.c", ["              color = cterm_normal_bg_color - 1;", "            else {", "              EMSG(_(\"E420: BG color unknown\"));"], "readability/braces"]
["src/nvim/syntax.c", ["              color = cterm_normal_bg_color - 1;", "            else {", "              EMSG(_(\"E420: BG color unknown\"));"], "readability/braces"]
["src/nvim/syntax.c", ["{", "  for (int i = 0; i < highlight_ga.ga_len; ++i) {", "    highlight_clear(i);"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Reset the cterm colors to what they were before Vim was started, if"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Return TRUE if highlight group \"idx\" has any settings."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Clear highlighting for one group."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  didh = highlight_list_arg(id, didh, LIST_ATTR,", "      sgp->sg_cterm, NULL, \"cterm\");", "  didh = highlight_list_arg(id, didh, LIST_INT,"], "whitespace/alignment"]
["src/nvim/syntax.c", ["  didh = highlight_list_arg(id, didh, LIST_INT,", "      sgp->sg_cterm_fg, NULL, \"ctermfg\");", "  didh = highlight_list_arg(id, didh, LIST_INT,"], "whitespace/alignment"]
["src/nvim/syntax.c", ["  didh = highlight_list_arg(id, didh, LIST_INT,", "      sgp->sg_cterm_bg, NULL, \"ctermbg\");", ""], "whitespace/alignment"]
["src/nvim/syntax.c", ["  didh = highlight_list_arg(id, didh, LIST_ATTR,", "      sgp->sg_gui, NULL, \"gui\");", "  didh = highlight_list_arg(id, didh, LIST_STRING,"], "whitespace/alignment"]
["src/nvim/syntax.c", ["  didh = highlight_list_arg(id, didh, LIST_STRING,", "      0, sgp->sg_rgb_fg_name, \"guifg\");", "  didh = highlight_list_arg(id, didh, LIST_STRING,"], "whitespace/alignment"]
["src/nvim/syntax.c", ["  didh = highlight_list_arg(id, didh, LIST_STRING,", "      0, sgp->sg_rgb_bg_name, \"guibg\");", "  didh = highlight_list_arg(id, didh, LIST_STRING,"], "whitespace/alignment"]
["src/nvim/syntax.c", ["        if (iarg & hl_attr_table[i]) {", "          if (buf[0] != NUL)", "            xstrlcat((char *)buf, \",\", 100);"], "readability/braces"]
["src/nvim/syntax.c", ["          xstrlcat((char *)buf, hl_name_table[i], 100);", "          iarg &= ~hl_attr_table[i];                /* don't want \"inverse\" */", "        }"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* Show \"xxx\" with the attributes. */", "  if (!did_header) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* Avoid using stricmp() too much, it's slow on some systems */", "  /* Avoid alloc()/free(), these are slow too.  ID names over 200 chars"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  /* Avoid using stricmp() too much, it's slow on some systems */", "  /* Avoid alloc()/free(), these are slow too.  ID names over 200 chars", "   * don't deserve to be found! */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  vim_strup(name_u);", "  for (i = highlight_ga.ga_len; --i >= 0; )", "    if (HL_TABLE()[i].sg_name_u != NULL"], "readability/braces"]
["src/nvim/syntax.c", ["  for (i = highlight_ga.ga_len; --i >= 0; )", "    if (HL_TABLE()[i].sg_name_u != NULL", "        && STRCMP(name_u, HL_TABLE()[i].sg_name_u) == 0)"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Return TRUE if highlight group \"name\" exists."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Return the name of highlight group \"id\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["{", "  if (id <= 0 || id > highlight_ga.ga_len)", "    return (char_u *)\"\";"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Like syn_name2id(), but take a pointer + length argument."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* Check that the name is ASCII letters, digits and underscore. */", "  for (p = name; *p != NUL; ++p) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  /* Check that the name is ASCII letters, digits and underscore. */", "  for (p = name; *p != NUL; ++p) {", "    if (!vim_isprintc(*p)) {"], "readability/increment"]
["src/nvim/syntax.c", ["    } else if (!ASCII_ISALNUM(*p) && *p != '_')   {", "      /* This is an error, but since there previously was no check only", "       * give a warning. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * First call for this growarray: init growing array."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  // Append another syntax_highlight entry.", "  struct hl_group* hlgp = GA_APPEND_VIA_PTR(struct hl_group, &highlight_ga);", "  memset(hlgp, 0, sizeof(*hlgp));"], "whitespace/operators"]
["src/nvim/syntax.c", ["", "  return highlight_ga.ga_len;               /* ID is index plus one */", "}"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Translate a group ID to the final group ID (following links)."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  if (hl_id > highlight_ga.ga_len || hl_id < 1)", "    return 0;                           /* Can be called from eval!! */"], "readability/braces"]
["src/nvim/syntax.c", ["  if (hl_id > highlight_ga.ga_len || hl_id < 1)", "    return 0;                           /* Can be called from eval!! */", ""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Follow links until there is no more."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  need_highlight_changed = FALSE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["  for (int i = 0; i < 9; i++) {", "    sprintf((char *)userhl, \"User%d\", i + 1);", "    id = syn_name2id(userhl);"], "runtime/printf"]
["src/nvim/syntax.c", ["", "/*", " * Handle command line completion for :highlight command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* (part of) subcommand already typed */", "  if (*arg != NUL) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      }", "      if (*p != NUL) {                          /* past group name */", "        include_link = 0;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * List highlighting matches in a nice way."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["{", "", "  if (name[0] == '#' && isxdigit(name[1]) && isxdigit(name[2])"], "whitespace/blank_line"]
["src/nvim/syntax.c", ["", "/**************************************", "*  End of Highlighting stuff\t      *"], "readability/old_style_comment"]
["src/nvim/syntax.h", ["", "#define HL_CONTAINED   0x01    /* not used on toplevel */", "#define HL_TRANSP      0x02    /* has no highlighting\t*/"], "readability/old_style_comment"]
["src/nvim/syntax.h", ["#define HL_CONTAINED   0x01    /* not used on toplevel */", "#define HL_TRANSP      0x02    /* has no highlighting\t*/", "#define HL_ONELINE     0x04    /* match within one line only */"], "readability/old_style_comment"]
["src/nvim/syntax.h", ["#define HL_CONTAINED   0x01    /* not used on toplevel */", "#define HL_TRANSP      0x02    /* has no highlighting\t*/", "#define HL_ONELINE     0x04    /* match within one line only */"], "whitespace/tab"]
["src/nvim/syntax.h", ["#define HL_TRANSP      0x02    /* has no highlighting\t*/", "#define HL_ONELINE     0x04    /* match within one line only */", "#define HL_HAS_EOL     0x08    /* end pattern that matches with $ */"], "readability/old_style_comment"]
["src/nvim/syntax.h", ["#define HL_ONELINE     0x04    /* match within one line only */", "#define HL_HAS_EOL     0x08    /* end pattern that matches with $ */", "#define HL_SYNC_HERE   0x10    /* sync point after this item (syncing only) */"], "readability/old_style_comment"]
["src/nvim/syntax.h", ["#define HL_HAS_EOL     0x08    /* end pattern that matches with $ */", "#define HL_SYNC_HERE   0x10    /* sync point after this item (syncing only) */", "#define HL_SYNC_THERE  0x20    /* sync point at current line (syncing only) */"], "readability/old_style_comment"]
["src/nvim/syntax.h", ["#define HL_SYNC_HERE   0x10    /* sync point after this item (syncing only) */", "#define HL_SYNC_THERE  0x20    /* sync point at current line (syncing only) */", "#define HL_MATCH       0x40    /* use match ID instead of item ID */"], "readability/old_style_comment"]
["src/nvim/syntax.h", ["#define HL_SYNC_THERE  0x20    /* sync point at current line (syncing only) */", "#define HL_MATCH       0x40    /* use match ID instead of item ID */", "#define HL_SKIPNL      0x80    /* nextgroup can skip newlines */"], "readability/old_style_comment"]
["src/nvim/syntax.h", ["#define HL_MATCH       0x40    /* use match ID instead of item ID */", "#define HL_SKIPNL      0x80    /* nextgroup can skip newlines */", "#define HL_SKIPWHITE   0x100   /* nextgroup can skip white space */"], "readability/old_style_comment"]
["src/nvim/syntax.h", ["#define HL_SKIPNL      0x80    /* nextgroup can skip newlines */", "#define HL_SKIPWHITE   0x100   /* nextgroup can skip white space */", "#define HL_SKIPEMPTY   0x200   /* nextgroup can skip empty lines */"], "readability/old_style_comment"]
["src/nvim/syntax.h", ["#define HL_SKIPWHITE   0x100   /* nextgroup can skip white space */", "#define HL_SKIPEMPTY   0x200   /* nextgroup can skip empty lines */", "#define HL_KEEPEND     0x400   /* end match always kept */"], "readability/old_style_comment"]
["src/nvim/syntax.h", ["#define HL_SKIPEMPTY   0x200   /* nextgroup can skip empty lines */", "#define HL_KEEPEND     0x400   /* end match always kept */", "#define HL_EXCLUDENL   0x800   /* exclude NL from match */"], "readability/old_style_comment"]
["src/nvim/syntax.h", ["#define HL_KEEPEND     0x400   /* end match always kept */", "#define HL_EXCLUDENL   0x800   /* exclude NL from match */", "#define HL_DISPLAY     0x1000  /* only used for displaying, not syncing */"], "readability/old_style_comment"]
["src/nvim/syntax.h", ["#define HL_EXCLUDENL   0x800   /* exclude NL from match */", "#define HL_DISPLAY     0x1000  /* only used for displaying, not syncing */", "#define HL_FOLD        0x2000  /* define fold */"], "readability/old_style_comment"]
["src/nvim/syntax.h", ["#define HL_DISPLAY     0x1000  /* only used for displaying, not syncing */", "#define HL_FOLD        0x2000  /* define fold */", "#define HL_EXTEND      0x4000  /* ignore a keepend */"], "readability/old_style_comment"]
["src/nvim/syntax.h", ["#define HL_FOLD        0x2000  /* define fold */", "#define HL_EXTEND      0x4000  /* ignore a keepend */", "#define HL_MATCHCONT   0x8000  /* match continued from previous line */"], "readability/old_style_comment"]
["src/nvim/syntax.h", ["#define HL_EXTEND      0x4000  /* ignore a keepend */", "#define HL_MATCHCONT   0x8000  /* match continued from previous line */", "#define HL_TRANS_CONT  0x10000 /* transparent item without contains arg */"], "readability/old_style_comment"]
["src/nvim/syntax.h", ["#define HL_MATCHCONT   0x8000  /* match continued from previous line */", "#define HL_TRANS_CONT  0x10000 /* transparent item without contains arg */", "#define HL_CONCEAL     0x20000 /* can be concealed */"], "readability/old_style_comment"]
["src/nvim/syntax.h", ["#define HL_TRANS_CONT  0x10000 /* transparent item without contains arg */", "#define HL_CONCEAL     0x20000 /* can be concealed */", "#define HL_CONCEALENDS 0x40000 /* can be concealed */"], "readability/old_style_comment"]
["src/nvim/syntax.h", ["#define HL_CONCEAL     0x20000 /* can be concealed */", "#define HL_CONCEALENDS 0x40000 /* can be concealed */", ""], "readability/old_style_comment"]
["src/nvim/syntax_defs.h", ["", "#endif // NVIM_SYNTAX_DEFS_H", ""], "build/header_guard"]
["src/nvim/syntax_defs.h", ["", "# define SST_MIN_ENTRIES 150    /* minimal size for state stack array */", "# define SST_MAX_ENTRIES 1000   /* maximal size for state stack array */"], "readability/old_style_comment"]
["src/nvim/syntax_defs.h", ["# define SST_MIN_ENTRIES 150    /* minimal size for state stack array */", "# define SST_MAX_ENTRIES 1000   /* maximal size for state stack array */", "# define SST_FIX_STATES  7      /* size of sst_stack[]. */"], "readability/old_style_comment"]
["src/nvim/syntax_defs.h", ["# define SST_MAX_ENTRIES 1000   /* maximal size for state stack array */", "# define SST_FIX_STATES  7      /* size of sst_stack[]. */", "# define SST_DIST        16     /* normal distance between entries */"], "readability/old_style_comment"]
["src/nvim/syntax_defs.h", ["# define SST_FIX_STATES  7      /* size of sst_stack[]. */", "# define SST_DIST        16     /* normal distance between entries */", "# define SST_INVALID    (synstate_T *)-1        /* invalid syn_state pointer */"], "readability/old_style_comment"]
["src/nvim/syntax_defs.h", ["# define SST_DIST        16     /* normal distance between entries */", "# define SST_INVALID    (synstate_T *)-1        /* invalid syn_state pointer */", ""], "readability/old_style_comment"]
["src/nvim/syntax_defs.h", ["", "/* struct passed to in_id_list() */", "struct sp_syn {"], "readability/old_style_comment"]
["src/nvim/syntax_defs.h", ["", "/*", " * Each keyword has one keyentry, which is linked in a hash list."], "readability/old_style_comment"]
["src/nvim/syntax_defs.h", ["", "/*", " * Struct used to store one state of the state stack."], "readability/old_style_comment"]
["src/nvim/syntax_defs.h", ["typedef struct buf_state {", "  int bs_idx;                    /* index of pattern */", "  int bs_flags;                  /* flags for pattern */"], "readability/old_style_comment"]
["src/nvim/syntax_defs.h", ["  int bs_idx;                    /* index of pattern */", "  int bs_flags;                  /* flags for pattern */", "  int bs_seqnr;                  /* stores si_seqnr */"], "readability/old_style_comment"]
["src/nvim/syntax_defs.h", ["  int bs_flags;                  /* flags for pattern */", "  int bs_seqnr;                  /* stores si_seqnr */", "  int bs_cchar;                  /* stores si_cchar */"], "readability/old_style_comment"]
["src/nvim/syntax_defs.h", ["  int bs_seqnr;                  /* stores si_seqnr */", "  int bs_cchar;                  /* stores si_cchar */", "  reg_extmatch_T *bs_extmatch;   /* external matches from start pattern */"], "readability/old_style_comment"]
["src/nvim/syntax_defs.h", ["  int bs_cchar;                  /* stores si_cchar */", "  reg_extmatch_T *bs_extmatch;   /* external matches from start pattern */", "} bufstate_T;"], "readability/old_style_comment"]
["src/nvim/syntax_defs.h", ["", "/*", " * syn_state contains the syntax state stack for the start of one line."], "readability/old_style_comment"]
["src/nvim/syntax_defs.h", ["struct syn_state {", "  synstate_T  *sst_next;        /* next entry in used or free list */", "  linenr_T sst_lnum;            /* line number for this state */"], "readability/old_style_comment"]
["src/nvim/syntax_defs.h", ["  synstate_T  *sst_next;        /* next entry in used or free list */", "  linenr_T sst_lnum;            /* line number for this state */", "  union {"], "readability/old_style_comment"]
["src/nvim/syntax_defs.h", ["  union {", "    bufstate_T sst_stack[SST_FIX_STATES];          /* short state stack */", "    garray_T sst_ga;            /* growarray for long state stack */"], "readability/old_style_comment"]
["src/nvim/syntax_defs.h", ["    bufstate_T sst_stack[SST_FIX_STATES];          /* short state stack */", "    garray_T sst_ga;            /* growarray for long state stack */", "  } sst_union;"], "readability/old_style_comment"]
["src/nvim/syntax_defs.h", ["", "#endif // NVIM_SYNTAX_DEFS_H", ""], "whitespace/comments"]
["src/nvim/tag.c", ["", "/*", " * Code to handle tags and the tag stack"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Structure to hold pointers to various items in a tag line."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Structure to hold info about the tag pattern being used."], "readability/old_style_comment"]
["src/nvim/tag.c", ["typedef struct {", "  char_u      *pat;             /* the pattern */", "  int len;                      /* length of pat[] */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  char_u      *pat;             /* the pattern */", "  int len;                      /* length of pat[] */", "  char_u      *head;            /* start of pattern head */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int len;                      /* length of pat[] */", "  char_u      *head;            /* start of pattern head */", "  int headlen;                  /* length of head[] */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  char_u      *head;            /* start of pattern head */", "  int headlen;                  /* length of head[] */", "  regmatch_T regmatch;          /* regexp program, may be NULL */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int headlen;                  /* length of head[] */", "  regmatch_T regmatch;          /* regexp program, may be NULL */", "} pat_T;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["static char     *mt_names[MT_COUNT/2] =", "{\"FSC\", \"F C\", \"F  \", \"FS \", \" SC\", \"  C\", \"   \", \" S \"};", ""], "whitespace/braces"]
["src/nvim/tag.c", ["static char     *mt_names[MT_COUNT/2] =", "{\"FSC\", \"F C\", \"F  \", \"FS \", \" SC\", \"  C\", \"   \", \" S \"};", ""], "whitespace/braces"]
["src/nvim/tag.c", ["", "#define NOTAGFILE       99              /* return value for jumpto_tag */", "static char_u   *nofile_fname = NULL;   /* fname for NOTAGFILE error */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["#define NOTAGFILE       99              /* return value for jumpto_tag */", "static char_u   *nofile_fname = NULL;   /* fname for NOTAGFILE error */", ""], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "static char_u   *tagmatchname = NULL;   /* name of last used tag */", ""], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Tag for preview window is remembered separately, to avoid messing up the"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Jump to tag; handling of tag commands and tag stack"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /* remember the matches for the last used tag */", "  static int num_matches = 0;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  static int num_matches = 0;", "  static int max_num_matches = 0;             /* limit used for match search */", "  static char_u       **matches = NULL;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  if (type == DT_FREE) {", "    /* remove the list of matches */", "    FreeWild(num_matches, matches);"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  clearpos(&saved_fmark.mark);          /* shutup gcc 4.0 */", "  saved_fmark.fnum = 0;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "    /* new pattern, add to the tag stack */", "    if (*tag != NUL"], "readability/old_style_comment"]
["src/nvim/tag.c", ["            || type == DT_CSCOPE", "            )) {", "      if (g_do_tagpreview != 0) {"], "whitespace/parens"]
["src/nvim/tag.c", ["            && STRCMP(ptag_entry.tagname, tag) == 0) {", "          /* Jumping to same tag: keep the current match, so that", "           * the CursorHold autocommand example works. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["      } else {", "        /*", "         * If the last used entry is not at the top, delete all tag"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "        /* if the tagstack is full: remove oldest entry */", "        if (++tagstacklen > TAGSTACKSIZE) {"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          }", "          /* We weren't at the bottom of the stack, so jump all the", "           * way to the bottom now."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "        /* Make a copy of the fmark, autocommands may invalidate the", "         * tagstack before it's used. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        if (saved_fmark.fnum != curbuf->b_fnum) {", "          /*", "           * Jump to other file. If this fails (e.g. because the"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          }", "          /* A BufReadPost autocommand may jump to the '\" mark, but", "           * we don't what that here. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        check_cursor();", "        if ((fdo_flags & FDO_TAG) && old_KeyTyped)", "          foldOpenCursor();"], "readability/braces"]
["src/nvim/tag.c", ["          if ((tagstackidx += count - 1) >= tagstacklen) {", "            /*", "             * Beyond the last one, just give an error message and"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        } else {", "          if (--tagstackidx < 0)", "            tagstackidx = 0;"], "readability/braces"]
["src/nvim/tag.c", ["        }", "        if (cur_match >= MAXCOL)", "          cur_match = MAXCOL - 1;"], "readability/braces"]
["src/nvim/tag.c", ["          cur_match = MAXCOL - 1;", "        else if (cur_match < 0) {", "          EMSG(_(\"E425: Cannot go before first matching tag\"));"], "readability/braces"]
["src/nvim/tag.c", ["    } else {", "      /*", "       * For \":tag [arg]\" or \":tselect\" remember position before the jump."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "      /* Curwin will change in the call to jumpto_tag() if \":stag\" was", "       * used or an autocommand jumps to another window; store value of"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /* When not using the current buffer get the name of buffer \"cur_fnum\".", "   * Makes sure that the tag order doesn't change when using a remembered"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "    if (buf != NULL)", "      buf_ffname = buf->b_ffname;"], "readability/braces"]
["src/nvim/tag.c", ["", "  /*", "   * Repeat searching for tags, when a file has not been found."], "readability/old_style_comment"]
["src/nvim/tag.c", ["        flags = TAG_REGEXP;", "        ++name;", "      } else"], "readability/increment"]
["src/nvim/tag.c", ["        ++name;", "      } else", "        flags = TAG_NOIC;"], "readability/braces"]
["src/nvim/tag.c", ["", "      /* If there already were some matches for the same name, move them", "       * to the start.  Avoids that the order changes when using"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          parse_match(matches[j], &tagp);", "          for (i = idx; i < new_num_matches; ++i) {", "            parse_match(new_matches[i], &tagp2);"], "readability/increment"]
["src/nvim/tag.c", ["    if (num_matches <= 0) {", "      if (verbose)", "        EMSG2(_(\"E426: tag not found: %s\"), name);"], "readability/braces"]
["src/nvim/tag.c", ["      if (cur_match >= num_matches) {", "        /* Avoid giving this error when a file wasn't found and we're", "         * looking for a match in another file, which wasn't found."], "readability/old_style_comment"]
["src/nvim/tag.c", ["            && nofile_fname == NULL) {", "          if (num_matches == 1)", "            EMSG(_(\"E427: There is only one matching tag\"));"], "readability/braces"]
["src/nvim/tag.c", ["            EMSG(_(\"E427: There is only one matching tag\"));", "          else", "            EMSG(_(\"E428: Cannot go beyond last matching tag\"));"], "readability/braces"]
["src/nvim/tag.c", ["", "      /*", "       * Only when going to try the next match, report that the previous"], "readability/old_style_comment"]
["src/nvim/tag.c", ["       */", "      if (nofile_fname != NULL && error_cur_match != cur_match)", "        smsg(_(\"File \\\"%s\\\" does not exist\"), nofile_fname);"], "readability/braces"]
["src/nvim/tag.c", ["      vim_snprintf((char *)IObuff, IOSIZE, \":ta %s\\r\", name);", "      set_vim_var_string(VV_SWAPCOMMAND, (char *) IObuff, -1);", ""], "whitespace/cast"]
["src/nvim/tag.c", ["", "      /*", "       * Jump to the desired match."], "readability/old_style_comment"]
["src/nvim/tag.c", ["          error_cur_match = cur_match;", "          if (use_tagstack)", "            --tagstackidx;"], "readability/braces"]
["src/nvim/tag.c", ["          if (use_tagstack)", "            --tagstackidx;", "          if (type == DT_PREV)"], "readability/increment"]
["src/nvim/tag.c", ["            --tagstackidx;", "          if (type == DT_PREV)", "            --cur_match;"], "readability/braces"]
["src/nvim/tag.c", ["          if (type == DT_PREV)", "            --cur_match;", "          else {"], "readability/increment"]
["src/nvim/tag.c", ["            --cur_match;", "          else {", "            type = DT_NEXT;"], "readability/braces"]
["src/nvim/tag.c", ["            --cur_match;", "          else {", "            type = DT_NEXT;"], "readability/braces"]
["src/nvim/tag.c", ["            type = DT_NEXT;", "            ++cur_match;", "          }"], "readability/increment"]
["src/nvim/tag.c", ["      } else {", "        /* We may have jumped to another window, check that", "         * tagstackidx is still valid. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["         * tagstackidx is still valid. */", "        if (use_tagstack && tagstackidx > curwin->w_tagstacklen)", "          tagstackidx = curwin->w_tagstackidx;"], "readability/braces"]
["src/nvim/tag.c", ["", "/*", " * Free cached tags."], "readability/old_style_comment"]
["src/nvim/tag.c", ["    msg_advance(24);", "  } else", "    msg_advance(13 + l);"], "readability/braces"]
["src/nvim/tag.c", ["", "/*", " * Print the tag stack"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /* Highlight title */", "  MSG_PUTS_TITLE(_(\"\\n  # TO tag         FROM line  in file/text\"));"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  MSG_PUTS_TITLE(_(\"\\n  # TO tag         FROM line  in file/text\"));", "  for (i = 0; i < tagstacklen; ++i) {", "    if (tagstack[i].tagname != NULL) {"], "readability/increment"]
["src/nvim/tag.c", ["      name = fm_getname(&(tagstack[i].fmark), 30);", "      if (name == NULL)             /* file name not available */", "        continue;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["      name = fm_getname(&(tagstack[i].fmark), 30);", "      if (name == NULL)             /* file name not available */", "        continue;"], "readability/braces"]
["src/nvim/tag.c", ["    }", "    ui_flush();                    /* show one line at a time */", "  }"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  }", "  if (tagstackidx == tagstacklen)       /* idx at top of stack */", "    MSG_PUTS(\"\\n>\");"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  }", "  if (tagstackidx == tagstacklen)       /* idx at top of stack */", "    MSG_PUTS(\"\\n>\");"], "readability/braces"]
["src/nvim/tag.c", ["", "/*", " * Compare two strings, for length \"len\", ignoring case the ASCII way."], "readability/old_style_comment"]
["src/nvim/tag.c", ["    i = TOUPPER_ASC(*s1) - TOUPPER_ASC(*s2);", "    if (i != 0)", "      return i;                         /* this character different */"], "readability/braces"]
["src/nvim/tag.c", ["    if (i != 0)", "      return i;                         /* this character different */", "    if (*s1 == NUL)"], "readability/old_style_comment"]
["src/nvim/tag.c", ["      return i;                         /* this character different */", "    if (*s1 == NUL)", "      break;                            /* strings match until NUL */"], "readability/braces"]
["src/nvim/tag.c", ["    if (*s1 == NUL)", "      break;                            /* strings match until NUL */", "    ++s1;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["      break;                            /* strings match until NUL */", "    ++s1;", "    ++s2;"], "readability/increment"]
["src/nvim/tag.c", ["    ++s1;", "    ++s2;", "    --len;"], "readability/increment"]
["src/nvim/tag.c", ["    ++s2;", "    --len;", "  }"], "readability/increment"]
["src/nvim/tag.c", ["  }", "  return 0;                             /* strings match */", "}"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Extract info from the tag search pattern \"pats->pat\"."], "readability/old_style_comment"]
["src/nvim/tag.c", ["  if (has_re) {", "    /* When the pattern starts with '^' or \"\\\\<\", binary searching can be", "     * used (much faster). */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["     * used (much faster). */", "    if (pats->pat[0] == '^')", "      pats->head = pats->pat + 1;"], "readability/braces"]
["src/nvim/tag.c", ["      pats->head = pats->pat + 1;", "    else if (pats->pat[0] == '\\\\' && pats->pat[1] == '<')", "      pats->head = pats->pat + 2;"], "readability/braces"]
["src/nvim/tag.c", ["      pats->head = pats->pat + 2;", "    if (pats->head == pats->pat)", "      pats->headlen = 0;"], "readability/braces"]
["src/nvim/tag.c", ["      pats->headlen = 0;", "    else", "      for (pats->headlen = 0; pats->head[pats->headlen] != NUL;"], "readability/braces"]
["src/nvim/tag.c", ["    else", "      for (pats->headlen = 0; pats->head[pats->headlen] != NUL;", "           ++pats->headlen)"], "readability/braces"]
["src/nvim/tag.c", ["      for (pats->headlen = 0; pats->head[pats->headlen] != NUL;", "           ++pats->headlen)", "        if (vim_strchr((char_u *)(p_magic ? \".[~*\\\\$\" : \"\\\\$\"),"], "readability/increment"]
["src/nvim/tag.c", ["           ++pats->headlen)", "        if (vim_strchr((char_u *)(p_magic ? \".[~*\\\\$\" : \"\\\\$\"),", "                pats->head[pats->headlen]) != NULL)"], "readability/braces"]
["src/nvim/tag.c", ["        if (vim_strchr((char_u *)(p_magic ? \".[~*\\\\$\" : \"\\\\$\"),", "                pats->head[pats->headlen]) != NULL)", "          break;"], "whitespace/alignment"]
["src/nvim/tag.c", ["          break;", "    if (p_tl != 0 && pats->headlen > p_tl)      /* adjust for 'taglength' */", "      pats->headlen = p_tl;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          break;", "    if (p_tl != 0 && pats->headlen > p_tl)      /* adjust for 'taglength' */", "      pats->headlen = p_tl;"], "readability/braces"]
["src/nvim/tag.c", ["", "  if (has_re)", "    pats->regmatch.regprog = vim_regcomp(pats->pat, p_magic ? RE_MAGIC : 0);"], "readability/braces"]
["src/nvim/tag.c", ["    pats->regmatch.regprog = vim_regcomp(pats->pat, p_magic ? RE_MAGIC : 0);", "  else", "    pats->regmatch.regprog = NULL;"], "readability/braces"]
["src/nvim/tag.c", ["", "/*", " * find_tags() - search for tags in tags files"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    int mincount,                           /*  MAXCOL: find all matches", "                                             other: minimal number of matches */", "    char_u *buf_ffname                /* name of buffer for priority */"], "whitespace/indent"]
["src/nvim/tag.c", ["    int flags,", "    int mincount,                           /*  MAXCOL: find all matches", "                                             other: minimal number of matches */"], "readability/multiline_comment"]
["src/nvim/tag.c", ["    int flags,", "    int mincount,                           /*  MAXCOL: find all matches", "                                             other: minimal number of matches */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["                                             other: minimal number of matches */", "    char_u *buf_ffname                /* name of buffer for priority */", ")"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  FILE       *fp;", "  char_u     *lbuf;                     /* line buffer */", "  int lbuf_size = LSIZE;                /* length of lbuf */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  char_u     *lbuf;                     /* line buffer */", "  int lbuf_size = LSIZE;                /* length of lbuf */", "  char_u     *tag_fname;                /* name of tag file */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int lbuf_size = LSIZE;                /* length of lbuf */", "  char_u     *tag_fname;                /* name of tag file */", "  tagname_T tn;                         /* info for get_tagfname() */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  char_u     *tag_fname;                /* name of tag file */", "  tagname_T tn;                         /* info for get_tagfname() */", "  int first_file;                       /* trying first tag file */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  tagname_T tn;                         /* info for get_tagfname() */", "  int first_file;                       /* trying first tag file */", "  tagptrs_T tagp;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  tagptrs_T tagp;", "  int did_open = FALSE;                 /* did open a tag file */", "  int stop_searching = FALSE;           /* stop when match found or error */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  tagptrs_T tagp;", "  int did_open = FALSE;                 /* did open a tag file */", "  int stop_searching = FALSE;           /* stop when match found or error */"], "readability/bool"]
["src/nvim/tag.c", ["  int did_open = FALSE;                 /* did open a tag file */", "  int stop_searching = FALSE;           /* stop when match found or error */", "  int retval = FAIL;                    /* return value */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int did_open = FALSE;                 /* did open a tag file */", "  int stop_searching = FALSE;           /* stop when match found or error */", "  int retval = FAIL;                    /* return value */"], "readability/bool"]
["src/nvim/tag.c", ["  int stop_searching = FALSE;           /* stop when match found or error */", "  int retval = FAIL;                    /* return value */", "  int is_static;                        /* current tag line is static */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int retval = FAIL;                    /* return value */", "  int is_static;                        /* current tag line is static */", "  int is_current;                       /* file name matches */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int is_static;                        /* current tag line is static */", "  int is_current;                       /* file name matches */", "  int eof = FALSE;                      /* found end-of-file */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int is_current;                       /* file name matches */", "  int eof = FALSE;                      /* found end-of-file */", "  char_u      *p;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int is_current;                       /* file name matches */", "  int eof = FALSE;                      /* found end-of-file */", "  char_u      *p;"], "readability/bool"]
["src/nvim/tag.c", ["  enum {", "    TS_START,                   /* at start of file */", "    TS_LINEAR                   /* linear searching forward, till EOF */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    TS_START,                   /* at start of file */", "    TS_LINEAR                   /* linear searching forward, till EOF */", "    , TS_BINARY,                /* binary searching */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    TS_LINEAR                   /* linear searching forward, till EOF */", "    , TS_BINARY,                /* binary searching */", "    TS_SKIP_BACK,               /* skipping backwards */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    , TS_BINARY,                /* binary searching */", "    TS_SKIP_BACK,               /* skipping backwards */", "    TS_STEP_FORWARD             /* stepping forwards */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    TS_SKIP_BACK,               /* skipping backwards */", "    TS_STEP_FORWARD             /* stepping forwards */", "  }   state;                    /* Current search state */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    TS_STEP_FORWARD             /* stepping forwards */", "  }   state;                    /* Current search state */", ""], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int cmplen;", "  int match;                    /* matches */", "  int match_no_ic = 0;          /* matches with rm_ic == FALSE */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int match;                    /* matches */", "  int match_no_ic = 0;          /* matches with rm_ic == FALSE */", "  int match_re;                 /* match with regexp */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int match_no_ic = 0;          /* matches with rm_ic == FALSE */", "  int match_re;                 /* match with regexp */", "  int matchoff = 0;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  pat_T orgpat;                         /* holds unconverted pattern info */", "  vimconv_T vimconv;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int findall = (mincount == MAXCOL || mincount == TAG_MANY);", "  /* find all matching tags */", "  int sort_error = FALSE;                       /* tags file not sorted */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  /* find all matching tags */", "  int sort_error = FALSE;                       /* tags file not sorted */", "  int linear;                                   /* do a linear search */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  /* find all matching tags */", "  int sort_error = FALSE;                       /* tags file not sorted */", "  int linear;                                   /* do a linear search */"], "readability/bool"]
["src/nvim/tag.c", ["  int sort_error = FALSE;                       /* tags file not sorted */", "  int linear;                                   /* do a linear search */", "  int sortic = FALSE;                           /* tag file sorted in nocase */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int linear;                                   /* do a linear search */", "  int sortic = FALSE;                           /* tag file sorted in nocase */", "  int line_error = FALSE;                       /* syntax error */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int linear;                                   /* do a linear search */", "  int sortic = FALSE;                           /* tag file sorted in nocase */", "  int line_error = FALSE;                       /* syntax error */"], "readability/bool"]
["src/nvim/tag.c", ["  int sortic = FALSE;                           /* tag file sorted in nocase */", "  int line_error = FALSE;                       /* syntax error */", "  int has_re = (flags & TAG_REGEXP);            /* regexp used */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int sortic = FALSE;                           /* tag file sorted in nocase */", "  int line_error = FALSE;                       /* syntax error */", "  int has_re = (flags & TAG_REGEXP);            /* regexp used */"], "readability/bool"]
["src/nvim/tag.c", ["  int line_error = FALSE;                       /* syntax error */", "  int has_re = (flags & TAG_REGEXP);            /* regexp used */", "  int help_only = (flags & TAG_HELP);"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int noic = (flags & TAG_NOIC);", "  int get_it_again = FALSE;", "  int use_cscope = (flags & TAG_CSCOPE);"], "readability/bool"]
["src/nvim/tag.c", ["", "  /*", "   * Allocate memory for the buffers that are used"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  STRCPY(tag_fname, \"from cscope\");             /* for error messages */", ""], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /*", "   * Initialize a few variables"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  if (curbuf->b_help) {", "    /* When \"@ab\" is specified use only the \"ab\" language, otherwise", "     * search all languages. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  }", "  if (p_tl != 0 && orgpat.len > p_tl)           /* adjust for 'taglength' */", "    orgpat.len = p_tl;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  }", "  if (p_tl != 0 && orgpat.len > p_tl)           /* adjust for 'taglength' */", "    orgpat.len = p_tl;"], "readability/braces"]
["src/nvim/tag.c", ["  save_emsg_off = emsg_off;", "  emsg_off = TRUE;    /* don't want error for invalid RE here */", "  prepare_pats(&orgpat, has_re);"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  save_emsg_off = emsg_off;", "  emsg_off = TRUE;    /* don't want error for invalid RE here */", "  prepare_pats(&orgpat, has_re);"], "readability/bool"]
["src/nvim/tag.c", ["  emsg_off = save_emsg_off;", "  if (has_re && orgpat.regmatch.regprog == NULL)", "    goto findtag_end;"], "readability/braces"]
["src/nvim/tag.c", ["", "  /*", "   * When finding a specified number of matches, first try with matching"], "readability/old_style_comment"]
["src/nvim/tag.c", ["                           && (findall || orgpat.headlen == 0 || !p_tbs));", "  for (round = 1; round <= 2; ++round) {", "    linear = (orgpat.headlen == 0 || !p_tbs || round == 2);"], "readability/increment"]
["src/nvim/tag.c", ["", "          /* When searching for a specific language skip tags files", "           * for other languages. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["           * for other languages. */", "          if (help_lang_find != NULL", "              && STRICMP(help_lang, help_lang_find) != 0)"], "readability/braces"]
["src/nvim/tag.c", ["", "          /* For CTRL-] in a help file prefer a match with the same", "           * language. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["           * language. */", "          if ((flags & TAG_KEEP_LANG)", "              && help_lang_find == NULL"], "readability/braces"]
["src/nvim/tag.c", ["            help_pri = 0;", "          else {", "            help_pri = 1;"], "readability/braces"]
["src/nvim/tag.c", ["            help_pri = 0;", "          else {", "            help_pri = 1;"], "readability/braces"]
["src/nvim/tag.c", ["            help_pri = 1;", "            for (s = p_hlg; *s != NUL; ++s) {", "              if (STRNICMP(s, help_lang, 2) == 0)"], "readability/increment"]
["src/nvim/tag.c", ["            for (s = p_hlg; *s != NUL; ++s) {", "              if (STRNICMP(s, help_lang, 2) == 0)", "                break;"], "readability/braces"]
["src/nvim/tag.c", ["                break;", "              ++help_pri;", "              if ((s = vim_strchr(s, ',')) == NULL)"], "readability/increment"]
["src/nvim/tag.c", ["              ++help_pri;", "              if ((s = vim_strchr(s, ',')) == NULL)", "                break;"], "readability/braces"]
["src/nvim/tag.c", ["            if (s == NULL || *s == NUL) {", "              /* Language not in 'helplang': use last, prefer English,", "               * unless found already. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["               * unless found already. */", "              ++help_pri;", "              if (STRICMP(help_lang, \"en\") != 0)"], "readability/increment"]
["src/nvim/tag.c", ["              ++help_pri;", "              if (STRICMP(help_lang, \"en\") != 0)", "                ++help_pri;"], "readability/braces"]
["src/nvim/tag.c", ["              if (STRICMP(help_lang, \"en\") != 0)", "                ++help_pri;", "            }"], "readability/increment"]
["src/nvim/tag.c", ["      }", "      did_open = TRUE;      /* remember that we found at least one file */", ""], "readability/old_style_comment"]
["src/nvim/tag.c", ["      }", "      did_open = TRUE;      /* remember that we found at least one file */", ""], "readability/bool"]
["src/nvim/tag.c", ["", "      state = TS_START;     /* we're at the start of the file */", ""], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "      /*", "       * Read and parse the lines in the file one by one"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        }", "        if ((flags & TAG_INS_COMP))     /* Double brackets for gcc */", "          ins_compl_check_keys(30, false);"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        }", "        if ((flags & TAG_INS_COMP))     /* Double brackets for gcc */", "          ins_compl_check_keys(30, false);"], "readability/braces"]
["src/nvim/tag.c", ["        if (got_int || compl_interrupted) {", "          stop_searching = TRUE;", "          break;"], "readability/bool"]
["src/nvim/tag.c", ["        }", "        /* When mincount is TAG_MANY, stop when enough matches have been", "         * found (for completion). */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        if (mincount == TAG_MANY && match_count >= TAG_MANY) {", "          stop_searching = TRUE;", "          retval = OK;"], "readability/bool"]
["src/nvim/tag.c", ["        }", "        if (get_it_again)", "          goto line_read_in;"], "readability/braces"]
["src/nvim/tag.c", ["          goto line_read_in;", "        /*", "         * For binary search: compute the next offset to use."], "readability/old_style_comment"]
["src/nvim/tag.c", ["                                              - search_info.low_offset) / 2);", "          if (offset == search_info.curr_offset)", "            break;              /* End the binary search without a match. */"], "readability/braces"]
["src/nvim/tag.c", ["          if (offset == search_info.curr_offset)", "            break;              /* End the binary search without a match. */", "          else"], "readability/old_style_comment"]
["src/nvim/tag.c", ["            break;              /* End the binary search without a match. */", "          else", "            search_info.curr_offset = offset;"], "readability/braces"]
["src/nvim/tag.c", ["", "        /*", "         * When jumping around in the file, first read a line to find the"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        if (state == TS_BINARY || state == TS_SKIP_BACK) {", "          /* Adjust the search file offset to the correct position */", "          search_info.curr_offset_used = search_info.curr_offset;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          if (!eof && search_info.curr_offset != 0) {", "            /* The explicit cast is to work around a bug in gcc 3.4.2", "             * (repeated below). */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          }", "          /* skip empty and blank lines */", "          while (!eof && vim_isblankline(lbuf)) {"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          if (eof) {", "            /* Hit end of file.  Skip backwards. */", "            state = TS_SKIP_BACK;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        }", "        /*", "         * Not jumping around in the file: Read the next line."], "readability/old_style_comment"]
["src/nvim/tag.c", ["         */", "        else {", "          /* skip empty and blank lines */"], "whitespace/newline"]
["src/nvim/tag.c", ["         */", "        else {", "          /* skip empty and blank lines */"], "readability/braces"]
["src/nvim/tag.c", ["        else {", "          /* skip empty and blank lines */", "          do {"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          if (eof) {", "            break;                                  /* end of file */", "          }"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "          /* Convert every line.  Converting the pattern from 'enc' to", "           * the tags file encoding doesn't work, because characters are"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          if (conv_line != NULL) {", "            /* Copy or swap lbuf and conv_line. */", "            len = (int)STRLEN(conv_line) + 1;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "        /*", "         * When still at the start of the file, check for Emacs tags file"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        if (state == TS_START) {", "          /* The header ends when the line sorts below \"!_TAG_\".  When", "           * case is folded lower case letters sort before \"_\". */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["              || (lbuf[0] == '!' && ASCII_ISLOWER(lbuf[1]))) {", "            if (STRNCMP(lbuf, \"!_TAG_\", 6) != 0)", "              /* Non-header item before the header, e.g. \"!\" itself."], "readability/braces"]
["src/nvim/tag.c", ["            if (STRNCMP(lbuf, \"!_TAG_\", 6) != 0)", "              /* Non-header item before the header, e.g. \"!\" itself.", "               */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "            /*", "             * Read header line."], "readability/old_style_comment"]
["src/nvim/tag.c", ["             */", "            if (STRNCMP(lbuf, \"!_TAG_FILE_SORTED\\t\", 18) == 0)", "              tag_file_sorted = lbuf[18];"], "readability/braces"]
["src/nvim/tag.c", ["            if (STRNCMP(lbuf, \"!_TAG_FILE_ENCODING\\t\", 20) == 0) {", "              /* Prepare to convert every line from the specified", "               * encoding to 'encoding'. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["               * encoding to 'encoding'. */", "              for (p = lbuf + 20; *p > ' ' && *p < 127; ++p)", "                ;"], "readability/braces"]
["src/nvim/tag.c", ["               * encoding to 'encoding'. */", "              for (p = lbuf + 20; *p > ' ' && *p < 127; ++p)", "                ;"], "readability/increment"]
["src/nvim/tag.c", ["              for (p = lbuf + 20; *p > ' ' && *p < 127; ++p)", "                ;", "              *p = NUL;"], "whitespace/semicolon"]
["src/nvim/tag.c", ["", "            /* Read the next line.  Unrecognized flags are ignored. */", "            continue;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "          /* Headers ends. */", ""], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "          /*", "           * When there is no tag head, or ignoring case, need to do a"], "readability/old_style_comment"]
["src/nvim/tag.c", ["           */", "          if (linear || use_cscope)", "            state = TS_LINEAR;"], "readability/braces"]
["src/nvim/tag.c", ["            state = TS_LINEAR;", "          else if (tag_file_sorted == NUL)", "            state = TS_BINARY;"], "readability/braces"]
["src/nvim/tag.c", ["            state = TS_BINARY;", "          else if (tag_file_sorted == '1')", "            state = TS_BINARY;"], "readability/braces"]
["src/nvim/tag.c", ["            state = TS_BINARY;", "          else if (tag_file_sorted == '2') {", "            state = TS_BINARY;"], "readability/braces"]
["src/nvim/tag.c", ["            state = TS_BINARY;", "            sortic = TRUE;", "            orgpat.regmatch.rm_ic = (p_ic || !noic);"], "readability/bool"]
["src/nvim/tag.c", ["            orgpat.regmatch.rm_ic = (p_ic || !noic);", "          } else", "            state = TS_LINEAR;"], "readability/braces"]
["src/nvim/tag.c", ["          if (state == TS_BINARY && orgpat.regmatch.rm_ic && !sortic) {", "            /* Binary search won't work for ignoring case, use linear", "             * search. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["             * search. */", "            linear = TRUE;", "            state = TS_LINEAR;"], "readability/bool"]
["src/nvim/tag.c", ["", "          /*", "           * Skip this line if the length of the tag is different and"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          cmplen = (int)(tagp.tagname_end - tagp.tagname);", "          if (p_tl != 0 && cmplen > p_tl)           /* adjust for 'taglength' */", "            cmplen = p_tl;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          cmplen = (int)(tagp.tagname_end - tagp.tagname);", "          if (p_tl != 0 && cmplen > p_tl)           /* adjust for 'taglength' */", "            cmplen = p_tl;"], "readability/braces"]
["src/nvim/tag.c", ["            cmplen = p_tl;", "          if (has_re && orgpat.headlen < cmplen)", "            cmplen = orgpat.headlen;"], "readability/braces"]
["src/nvim/tag.c", ["            cmplen = orgpat.headlen;", "          else if (state == TS_LINEAR && orgpat.headlen != cmplen)", "            continue;"], "readability/braces"]
["src/nvim/tag.c", ["          if (state == TS_BINARY) {", "            /*", "             * Simplistic check for unsorted tags file."], "readability/old_style_comment"]
["src/nvim/tag.c", ["            i = (int)tagp.tagname[0];", "            if (sortic)", "              i = TOUPPER_ASC(tagp.tagname[0]);"], "readability/braces"]
["src/nvim/tag.c", ["              i = TOUPPER_ASC(tagp.tagname[0]);", "            if (i < search_info.low_char || i > search_info.high_char)", "              sort_error = TRUE;"], "readability/braces"]
["src/nvim/tag.c", ["            if (i < search_info.low_char || i > search_info.high_char)", "              sort_error = TRUE;", ""], "readability/bool"]
["src/nvim/tag.c", ["", "            /*", "             * Compare the current tag with the searched tag."], "readability/old_style_comment"]
["src/nvim/tag.c", ["             */", "            if (sortic)", "              tagcmp = tag_strnicmp(tagp.tagname, orgpat.head,"], "readability/braces"]
["src/nvim/tag.c", ["              tagcmp = tag_strnicmp(tagp.tagname, orgpat.head,", "                  (size_t)cmplen);", "            else"], "whitespace/alignment"]
["src/nvim/tag.c", ["                  (size_t)cmplen);", "            else", "              tagcmp = STRNCMP(tagp.tagname, orgpat.head, cmplen);"], "readability/braces"]
["src/nvim/tag.c", ["", "            /*", "             * A match with a shorter tag means to search forward."], "readability/old_style_comment"]
["src/nvim/tag.c", ["            if (tagcmp == 0) {", "              if (cmplen < orgpat.headlen)", "                tagcmp = -1;"], "readability/braces"]
["src/nvim/tag.c", ["                tagcmp = -1;", "              else if (cmplen > orgpat.headlen)", "                tagcmp = 1;"], "readability/braces"]
["src/nvim/tag.c", ["            if (tagcmp == 0) {", "              /* We've located the tag, now skip back and search", "               * forward until the first matching tag is found."], "readability/old_style_comment"]
["src/nvim/tag.c", ["                search_info.low_offset = search_info.curr_offset;", "                if (sortic)", "                  search_info.low_char ="], "readability/braces"]
["src/nvim/tag.c", ["                    TOUPPER_ASC(tagp.tagname[0]);", "                else", "                  search_info.low_char = tagp.tagname[0];"], "readability/braces"]
["src/nvim/tag.c", ["              search_info.high_offset = search_info.curr_offset;", "              if (sortic)", "                search_info.high_char ="], "readability/braces"]
["src/nvim/tag.c", ["                  TOUPPER_ASC(tagp.tagname[0]);", "              else", "                search_info.high_char = tagp.tagname[0];"], "readability/braces"]
["src/nvim/tag.c", ["", "            /* No match yet and are at the end of the binary search. */", "            break;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["            assert(cmplen >= 0);", "            if (mb_strnicmp(tagp.tagname, orgpat.head, (size_t)cmplen) != 0)", "              state = TS_STEP_FORWARD;"], "readability/braces"]
["src/nvim/tag.c", ["              state = TS_STEP_FORWARD;", "            else", "              /* Have to skip back more.  Restore the curr_offset"], "readability/braces"]
["src/nvim/tag.c", ["            else", "              /* Have to skip back more.  Restore the curr_offset", "               * used, otherwise we get stuck at a long line. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["            }", "          } else", "          /* skip this match if it can't match */"], "readability/braces"]
["src/nvim/tag.c", ["          } else", "          /* skip this match if it can't match */", "          assert(cmplen >= 0);"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          assert(cmplen >= 0);", "          if (mb_strnicmp(tagp.tagname, orgpat.head, (size_t)cmplen) != 0)", "            continue;"], "readability/braces"]
["src/nvim/tag.c", ["          tagp.command = tagp.fname_end + 1;", "          if (tagp.fname_end == NULL)", "            i = FAIL;"], "readability/braces"]
["src/nvim/tag.c", ["            i = FAIL;", "          else", "            i = OK;"], "readability/braces"]
["src/nvim/tag.c", ["            i = OK;", "        } else", "          i = parse_tag_line(lbuf,"], "readability/braces"]
["src/nvim/tag.c", ["          i = parse_tag_line(lbuf,", "              &tagp);", "        if (i == FAIL) {"], "whitespace/alignment"]
["src/nvim/tag.c", ["        if (i == FAIL) {", "          line_error = TRUE;", "          break;"], "readability/bool"]
["src/nvim/tag.c", ["", "        /*", "         * First try matching with the pattern literally (also when it is"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        cmplen = (int)(tagp.tagname_end - tagp.tagname);", "        if (p_tl != 0 && cmplen > p_tl)             /* adjust for 'taglength' */", "          cmplen = p_tl;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        cmplen = (int)(tagp.tagname_end - tagp.tagname);", "        if (p_tl != 0 && cmplen > p_tl)             /* adjust for 'taglength' */", "          cmplen = p_tl;"], "readability/braces"]
["src/nvim/tag.c", ["          cmplen = p_tl;", "        /* if tag length does not match, don't try comparing */", "        if (orgpat.len != cmplen)"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        /* if tag length does not match, don't try comparing */", "        if (orgpat.len != cmplen)", "          match = FALSE;"], "readability/braces"]
["src/nvim/tag.c", ["        if (orgpat.len != cmplen)", "          match = FALSE;", "        else {"], "readability/bool"]
["src/nvim/tag.c", ["          match = FALSE;", "        else {", "          if (orgpat.regmatch.rm_ic) {"], "readability/braces"]
["src/nvim/tag.c", ["          match = FALSE;", "        else {", "          if (orgpat.regmatch.rm_ic) {"], "readability/braces"]
["src/nvim/tag.c", ["            match = mb_strnicmp(tagp.tagname, orgpat.pat, (size_t)cmplen) == 0;", "            if (match)", "              match_no_ic = (STRNCMP(tagp.tagname, orgpat.pat,"], "readability/braces"]
["src/nvim/tag.c", ["              match_no_ic = (STRNCMP(tagp.tagname, orgpat.pat,", "                                 cmplen) == 0);", "          } else"], "whitespace/alignment"]
["src/nvim/tag.c", ["                                 cmplen) == 0);", "          } else", "            match = (STRNCMP(tagp.tagname, orgpat.pat, cmplen) == 0);"], "readability/braces"]
["src/nvim/tag.c", ["", "        /*", "         * Has a regexp: Also find tags matching regexp."], "readability/old_style_comment"]
["src/nvim/tag.c", ["         */", "        match_re = FALSE;", "        if (!match && orgpat.regmatch.regprog != NULL) {"], "readability/bool"]
["src/nvim/tag.c", ["            if (orgpat.regmatch.rm_ic) {", "              orgpat.regmatch.rm_ic = FALSE;", "              match_no_ic = vim_regexec(&orgpat.regmatch, tagp.tagname,"], "readability/bool"]
["src/nvim/tag.c", ["              match_no_ic = vim_regexec(&orgpat.regmatch, tagp.tagname,", "                  (colnr_T)0);", "              orgpat.regmatch.rm_ic = TRUE;"], "whitespace/alignment"]
["src/nvim/tag.c", ["                  (colnr_T)0);", "              orgpat.regmatch.rm_ic = TRUE;", "            }"], "readability/bool"]
["src/nvim/tag.c", ["          *tagp.tagname_end = cc;", "          match_re = TRUE;", "        }"], "readability/bool"]
["src/nvim/tag.c", ["          if (use_cscope) {", "            /* Don't change the ordering, always use the same table. */", "            mtt = MT_GL_OTH;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["            if (is_static) {", "              if (is_current)", "                mtt = MT_ST_CUR;"], "readability/braces"]
["src/nvim/tag.c", ["                mtt = MT_ST_CUR;", "              else", "                mtt = MT_ST_OTH;"], "readability/braces"]
["src/nvim/tag.c", ["            } else {", "              if (is_current)", "                mtt = MT_GL_CUR;"], "readability/braces"]
["src/nvim/tag.c", ["                mtt = MT_GL_CUR;", "              else", "                mtt = MT_GL_OTH;"], "readability/braces"]
["src/nvim/tag.c", ["            }", "            if (orgpat.regmatch.rm_ic && !match_no_ic)", "              mtt += MT_IC_OFF;"], "readability/braces"]
["src/nvim/tag.c", ["              mtt += MT_IC_OFF;", "            if (match_re)", "              mtt += MT_RE_OFF;"], "readability/braces"]
["src/nvim/tag.c", ["            STRCPY(p + len + 1, help_lang);", "            snprintf((char *)p + len + 1 + ML_EXTRA, 10, \"%06d\",", "                     help_heuristic(tagp.tagname,"], "runtime/printf"]
["src/nvim/tag.c", ["        }", "        if (use_cscope && eof)", "          break;"], "readability/braces"]
["src/nvim/tag.c", ["          break;", "      }   /* forever */", ""], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "      if (!use_cscope)", "        fclose(fp);"], "readability/braces"]
["src/nvim/tag.c", ["        fclose(fp);", "      if (vimconv.vc_type != CONV_NONE)", "        convert_setup(&vimconv, NULL, NULL);"], "readability/braces"]
["src/nvim/tag.c", ["        EMSG2(_(\"E432: Tags file not sorted: %s\"), tag_fname);", "        sort_error = FALSE;", "      }"], "readability/bool"]
["src/nvim/tag.c", ["", "      /*", "       * Stop searching if sufficient tags have been found."], "readability/old_style_comment"]
["src/nvim/tag.c", ["        retval = OK;", "        stop_searching = TRUE;", "      }"], "readability/bool"]
["src/nvim/tag.c", ["", "      if (stop_searching || use_cscope)", "        break;"], "readability/braces"]
["src/nvim/tag.c", ["        break;", "", "    }   /* end of for-each-file loop */"], "whitespace/blank_line"]
["src/nvim/tag.c", ["", "    }   /* end of for-each-file loop */", ""], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "    if (!use_cscope)", "      tagname_free(&tn);"], "readability/braces"]
["src/nvim/tag.c", ["", "    /* stop searching when already did a linear search, or when TAG_NOIC", "     * used, and 'ignorecase' not set or already did case-ignore search */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["     * used, and 'ignorecase' not set or already did case-ignore search */", "    if (stop_searching || linear || (!p_ic && noic) || orgpat.regmatch.rm_ic)", "      break;"], "readability/braces"]
["src/nvim/tag.c", ["      break;", "    if (use_cscope)", "      break;"], "readability/braces"]
["src/nvim/tag.c", ["      break;", "    orgpat.regmatch.rm_ic = TRUE;       /* try another time while ignoring case */", "  }"], "readability/old_style_comment"]
["src/nvim/tag.c", ["      break;", "    orgpat.regmatch.rm_ic = TRUE;       /* try another time while ignoring case */", "  }"], "whitespace/line_length"]
["src/nvim/tag.c", ["      break;", "    orgpat.regmatch.rm_ic = TRUE;       /* try another time while ignoring case */", "  }"], "readability/bool"]
["src/nvim/tag.c", ["  if (!stop_searching) {", "    if (!did_open && verbose)           /* never opened any tags file */", "      EMSG(_(\"E433: No tags file\"));"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  if (!stop_searching) {", "    if (!did_open && verbose)           /* never opened any tags file */", "      EMSG(_(\"E433: No tags file\"));"], "readability/braces"]
["src/nvim/tag.c", ["      EMSG(_(\"E433: No tags file\"));", "    retval = OK;                /* It's OK even when no tag found */", "  }"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /*", "   * Move the matches from the ga_match[] arrays into one list of"], "readability/old_style_comment"]
["src/nvim/tag.c", ["   */", "  if (retval == FAIL)", "    match_count = 0;"], "readability/braces"]
["src/nvim/tag.c", ["", "  if (match_count > 0)", "    matches = xmalloc(match_count * sizeof(char_u *));"], "readability/braces"]
["src/nvim/tag.c", ["    matches = xmalloc(match_count * sizeof(char_u *));", "  else", "    matches = NULL;"], "readability/braces"]
["src/nvim/tag.c", ["  return retval;", "}", ""], "readability/fn_size"]
["src/nvim/tag.c", ["", "/*", " * Callback function for finding all \"tags\" and \"tags-??\" files in"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Get the next name of a tag file from the tag file list."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  if (first)", "    memset(tnp, 0, sizeof(tagname_T));"], "readability/braces"]
["src/nvim/tag.c", ["  if (curbuf->b_help) {", "    /*", "     * For help files it's done in a completely different way:"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    if (tnp->tn_hf_idx >= tag_fnames.ga_len) {", "      /* Not found in 'runtimepath', use 'helpfile', if it exists and", "       * wasn't used yet, replacing \"help.txt\" with \"tags\". */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["       * wasn't used yet, replacing \"help.txt\" with \"tags\". */", "      if (tnp->tn_hf_idx > tag_fnames.ga_len || *p_hf == NUL)", "        return FAIL;"], "readability/braces"]
["src/nvim/tag.c", ["        return FAIL;", "      ++tnp->tn_hf_idx;", "      STRCPY(buf, p_hf);"], "readability/increment"]
["src/nvim/tag.c", ["  if (first) {", "    /* Init.  We make a copy of 'tags', because autocommands may change", "     * the value without notifying us. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    tnp->tn_tags = vim_strsave((*curbuf->b_p_tags != NUL)", "        ? curbuf->b_p_tags : p_tags);", "    tnp->tn_np = tnp->tn_tags;"], "whitespace/alignment"]
["src/nvim/tag.c", ["", "  /*", "   * Loop until we have found a file name that can be used."], "readability/old_style_comment"]
["src/nvim/tag.c", ["      fname = vim_findfile(tnp->tn_search_ctx);", "      if (fname != NULL)", "        break;"], "readability/braces"]
["src/nvim/tag.c", ["", "      tnp->tn_did_filefind_init = FALSE;", "    } else {"], "readability/bool"]
["src/nvim/tag.c", ["", "      /* Stop when used all parts of 'tags'. */", "      if (*tnp->tn_np == NUL) {"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "      /*", "       * Copy next file name into buf."], "readability/old_style_comment"]
["src/nvim/tag.c", ["      r_ptr = vim_findfile_stopdir(buf);", "      /* move the filename one char forward and truncate the", "       * filepath with a NUL */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["      tnp->tn_search_ctx = vim_findfile_init(buf, filename,", "          r_ptr, 100,", "          FALSE,                   /* don't free visited list */"], "whitespace/alignment"]
["src/nvim/tag.c", ["          r_ptr, 100,", "          FALSE,                   /* don't free visited list */", "          FINDFILE_FILE,           /* we search for a file */"], "whitespace/alignment"]
["src/nvim/tag.c", ["          FALSE,                   /* don't free visited list */", "          FINDFILE_FILE,           /* we search for a file */", "          tnp->tn_search_ctx, TRUE, curbuf->b_ffname);"], "whitespace/alignment"]
["src/nvim/tag.c", ["          FINDFILE_FILE,           /* we search for a file */", "          tnp->tn_search_ctx, TRUE, curbuf->b_ffname);", "      if (tnp->tn_search_ctx != NULL)"], "whitespace/alignment"]
["src/nvim/tag.c", ["          r_ptr, 100,", "          FALSE,                   /* don't free visited list */", "          FINDFILE_FILE,           /* we search for a file */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          r_ptr, 100,", "          FALSE,                   /* don't free visited list */", "          FINDFILE_FILE,           /* we search for a file */"], "readability/bool"]
["src/nvim/tag.c", ["          FALSE,                   /* don't free visited list */", "          FINDFILE_FILE,           /* we search for a file */", "          tnp->tn_search_ctx, TRUE, curbuf->b_ffname);"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          FINDFILE_FILE,           /* we search for a file */", "          tnp->tn_search_ctx, TRUE, curbuf->b_ffname);", "      if (tnp->tn_search_ctx != NULL)"], "readability/bool"]
["src/nvim/tag.c", ["          tnp->tn_search_ctx, TRUE, curbuf->b_ffname);", "      if (tnp->tn_search_ctx != NULL)", "        tnp->tn_did_filefind_init = TRUE;"], "readability/braces"]
["src/nvim/tag.c", ["      if (tnp->tn_search_ctx != NULL)", "        tnp->tn_did_filefind_init = TRUE;", "    }"], "readability/bool"]
["src/nvim/tag.c", ["", "/*", " * Free the contents of a tagname_T that was filled by get_tagfname()."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Parse one line from the tags file. Find start/end of tag name, start/end of"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /* Isolate the tagname, from lbuf up to the first white */", "  tagp->tagname = lbuf;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  p = vim_strchr(lbuf, TAB);", "  if (p == NULL)", "    return FAIL;"], "readability/braces"]
["src/nvim/tag.c", ["", "  /* Isolate file name, from first to second white space */", "  if (*p != NUL)"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  /* Isolate file name, from first to second white space */", "  if (*p != NUL)", "    ++p;"], "readability/braces"]
["src/nvim/tag.c", ["  if (*p != NUL)", "    ++p;", "  tagp->fname = p;"], "readability/increment"]
["src/nvim/tag.c", ["  p = vim_strchr(p, TAB);", "  if (p == NULL)", "    return FAIL;"], "readability/braces"]
["src/nvim/tag.c", ["", "  /* find start of search command, after second white space */", "  if (*p != NUL)"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  /* find start of search command, after second white space */", "  if (*p != NUL)", "    ++p;"], "readability/braces"]
["src/nvim/tag.c", ["  if (*p != NUL)", "    ++p;", "  if (*p == NUL)"], "readability/increment"]
["src/nvim/tag.c", ["    ++p;", "  if (*p == NUL)", "    return FAIL;"], "readability/braces"]
["src/nvim/tag.c", ["", "/*", " * Check if tagname is a static tag"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  while ((p = vim_strchr(p, '\\t')) != NULL) {", "    ++p;", "    if (STRNCMP(p, \"file:\", 5) == 0)"], "readability/increment"]
["src/nvim/tag.c", ["    ++p;", "    if (STRNCMP(p, \"file:\", 5) == 0)", "      return TRUE;"], "readability/braces"]
["src/nvim/tag.c", ["    if (STRNCMP(p, \"file:\", 5) == 0)", "      return TRUE;", "  }"], "readability/bool"]
["src/nvim/tag.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/tag.c", ["", "/*", " * Parse a line from a matching tag.  Does not change the line itself."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /* Find search pattern and the file name for non-etags. */", "  retval = parse_tag_line(lbuf,"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  retval = parse_tag_line(lbuf,", "      tagp);", ""], "whitespace/alignment"]
["src/nvim/tag.c", ["  if (retval == OK) {", "    /* Try to find a kind field: \"kind:<kind>\" or just \"<kind>\"*/", "    p = tagp->command;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          }", "          if (pt == NULL)", "            break;"], "readability/braces"]
["src/nvim/tag.c", ["", "/*", " * Find out the actual file name of a tag.  Concatenate the tags file name"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Jump to a tag that has been found in one of the tag files"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  char_u      *str;", "  char_u      *pbuf;                    /* search pattern buffer */", "  char_u      *pbuf_end;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /* parse the match line into the tagp structure */", "  if (parse_match(lbuf, &tagp) == FAIL) {"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /* copy the command to pbuf[], remove trailing CR/NL */", "  str = tagp.command;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  {", "    /*", "     * Remove the \"<Tab>fieldname:value\" stuff; we don't need it here."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /*", "   * Expand file name, when needed (for environment variables)."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /*", "   * Check if the file with the tag exists before abandoning the current"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  ++RedrawingDisabled;", ""], "readability/increment"]
["src/nvim/tag.c", ["  if (l_g_do_tagpreview != 0) {", "    postponed_split = 0;        /* don't split again below */", "    curwin_save = curwin;       /* Save current window */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    postponed_split = 0;        /* don't split again below */", "    curwin_save = curwin;       /* Save current window */", ""], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "    /*", "     * If we are reusing a window, we may change dir when"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    if (!curwin->w_p_pvw) {", "      full_fname = (char_u *)FullName_save((char *)fname, FALSE);", "      fname = full_fname;"], "readability/bool"]
["src/nvim/tag.c", ["", "      /*", "       * Make the preview window the current window."], "readability/old_style_comment"]
["src/nvim/tag.c", ["  if (keep_help) {", "    /* A :ta from a help file will keep the b_help flag set.  For \":ptag\"", "     * we need to use the flag from the window where we came from. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["     * we need to use the flag from the window where we came from. */", "    if (l_g_do_tagpreview != 0)", "      keep_help_flag = curwin_save->w_buffer->b_help;"], "readability/braces"]
["src/nvim/tag.c", ["      keep_help_flag = curwin_save->w_buffer->b_help;", "    else", "      keep_help_flag = curbuf->b_help;"], "readability/braces"]
["src/nvim/tag.c", ["    secure = 1;", "    ++sandbox;", "    save_magic = p_magic;"], "readability/increment"]
["src/nvim/tag.c", ["", "    /*", "     * If 'cpoptions' contains 't', store the search pattern for the \"n\""], "readability/old_style_comment"]
["src/nvim/tag.c", ["     */", "    if (vim_strchr(p_cpo, CPO_TAGPAT) != NULL)", "      search_options = 0;"], "readability/braces"]
["src/nvim/tag.c", ["      search_options = 0;", "    else", "      search_options = SEARCH_KEEP;"], "readability/braces"]
["src/nvim/tag.c", ["", "    /*", "     * If the command is a search, try here."], "readability/old_style_comment"]
["src/nvim/tag.c", ["    str = pbuf;", "    if (pbuf[0] == '/' || pbuf[0] == '?')", "      str = skip_regexp(pbuf + 1, pbuf[0], FALSE, NULL) + 1;"], "readability/braces"]
["src/nvim/tag.c", ["    if (pbuf[0] == '/' || pbuf[0] == '?')", "      str = skip_regexp(pbuf + 1, pbuf[0], FALSE, NULL) + 1;", "    if (str > pbuf_end - 1) {   /* search command with nothing following */"], "readability/bool"]
["src/nvim/tag.c", ["      str = skip_regexp(pbuf + 1, pbuf[0], FALSE, NULL) + 1;", "    if (str > pbuf_end - 1) {   /* search command with nothing following */", "      save_p_ws = p_ws;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["      save_p_scs = p_scs;", "      p_ws = true;              /* need 'wrapscan' for backward searches */", "      p_ic = FALSE;             /* don't ignore case now */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["      p_ws = true;              /* need 'wrapscan' for backward searches */", "      p_ic = FALSE;             /* don't ignore case now */", "      p_scs = FALSE;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["      p_ws = true;              /* need 'wrapscan' for backward searches */", "      p_ic = FALSE;             /* don't ignore case now */", "      p_scs = FALSE;"], "readability/bool"]
["src/nvim/tag.c", ["      p_ic = FALSE;             /* don't ignore case now */", "      p_scs = FALSE;", "      save_lnum = curwin->w_cursor.lnum;"], "readability/bool"]
["src/nvim/tag.c", ["", "        /*", "         * try again, ignore case now"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        } else {", "          /*", "           * Only give a message when really guessed, not when 'ic'"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "      /* A search command may have positioned the cursor beyond the end", "       * of the line.  May need to correct that here. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    } else {", "      curwin->w_cursor.lnum = 1;                /* start command in line 1 */", "      do_cmdline_cmd((char *)pbuf);"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "    /*", "     * When the command has done something that is not allowed make sure"], "readability/old_style_comment"]
["src/nvim/tag.c", ["     */", "    if (secure == 2)", "      wait_return(TRUE);"], "readability/braces"]
["src/nvim/tag.c", ["    if (secure == 2)", "      wait_return(TRUE);", "    secure = save_secure;"], "readability/bool"]
["src/nvim/tag.c", ["    p_magic = save_magic;", "    --sandbox;", "    /* restore no_hlsearch when keeping the old search pattern */"], "readability/increment"]
["src/nvim/tag.c", ["    --sandbox;", "    /* restore no_hlsearch when keeping the old search pattern */", "    if (search_options) {"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    if (retval == OK) {", "      /*", "       * For a help buffer: Put the cursor line at the top of the window,"], "readability/old_style_comment"]
["src/nvim/tag.c", ["       */", "      if (curbuf->b_help)", "        set_topline(curwin, curwin->w_cursor.lnum);"], "readability/braces"]
["src/nvim/tag.c", ["        set_topline(curwin, curwin->w_cursor.lnum);", "      if ((fdo_flags & FDO_TAG) && old_KeyTyped)", "        foldOpenCursor();"], "readability/braces"]
["src/nvim/tag.c", ["        && curwin != curwin_save && win_valid(curwin_save)) {", "      /* Return cursor to where we were */", "      validate_cursor();"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /*", "   * Expand file name (for environment variables) when needed."], "readability/old_style_comment"]
["src/nvim/tag.c", ["    expanded_fname = ExpandOne(&xpc, fname, NULL,", "        WILD_LIST_NOTFOUND|WILD_SILENT, WILD_EXPAND_FREE);", "    if (expanded_fname != NULL)"], "whitespace/alignment"]
["src/nvim/tag.c", ["        WILD_LIST_NOTFOUND|WILD_SILENT, WILD_EXPAND_FREE);", "    if (expanded_fname != NULL)", "      fname = expanded_fname;"], "readability/braces"]
["src/nvim/tag.c", ["    STRLCPY(retval + (p - tag_fname), fname,", "        MAXPATHL - (p - tag_fname));", "    /*"], "whitespace/alignment"]
["src/nvim/tag.c", ["        MAXPATHL - (p - tag_fname));", "    /*", "     * Translate names like \"src/a/../b/file.c\" into \"src/b/file.c\"."], "readability/old_style_comment"]
["src/nvim/tag.c", ["    simplify_filename(retval);", "  } else", "    retval = vim_strsave(fname);"], "readability/braces"]
["src/nvim/tag.c", ["", "/*", " * Check if we have a tag for the buffer with name \"buf_ffname\"."], "readability/old_style_comment"]
["src/nvim/tag.c", [" */", "static int test_for_current(char_u *fname, char_u *fname_end, char_u *tag_fname, char_u *buf_ffname)", "{"], "whitespace/line_length"]
["src/nvim/tag.c", ["  int c;", "  int retval = FALSE;", "  char_u  *fullname;"], "readability/bool"]
["src/nvim/tag.c", ["", "  if (buf_ffname != NULL) {     /* if the buffer has a name */", "    {"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Find the end of the tagaddress."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "int ", "expand_tags ("], "whitespace/end_of_line"]
["src/nvim/tag.c", ["int ", "expand_tags (", "    int tagnames,                   /* expand tag names */"], "whitespace/parens"]
["src/nvim/tag.c", ["expand_tags (", "    int tagnames,                   /* expand tag names */", "    char_u *pat,"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  if (tagnames)", "    tagnmflag = TAG_NAMES;"], "readability/braces"]
["src/nvim/tag.c", ["    tagnmflag = TAG_NAMES;", "  else", "    tagnmflag = 0;"], "readability/braces"]
["src/nvim/tag.c", ["  if (ret == OK && !tagnames) {", "    /* Reorganize the tags for display and matching as strings of:", "     * \"<tagname>\\0<kind>\\0<filename>\\0\""], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Add a tag field to the dictionary \"dict\"."], "readability/old_style_comment"]
["src/nvim/tag.c", ["      end = start + STRLEN(start);", "      while (end > start && (end[-1] == '\\r' || end[-1] == '\\n'))", "        --end;"], "readability/braces"]
["src/nvim/tag.c", ["      while (end > start && (end[-1] == '\\r' || end[-1] == '\\n'))", "        --end;", "    }"], "readability/increment"]
["src/nvim/tag.c", ["    len = (int)(end - start);", "    if (len > MAXPATHL - 1)", "      len = MAXPATHL - 1;"], "readability/braces"]
["src/nvim/tag.c", ["  if (ret == OK && num_matches > 0) {", "    for (i = 0; i < num_matches; ++i) {", "      int parse_result = parse_match(matches[i], &tp);"], "readability/increment"]
["src/nvim/tag.c", ["      // Avoid an unused variable warning in release builds.", "      (void) parse_result;", "      assert(parse_result == OK);"], "whitespace/cast"]
["src/nvim/tag.c", ["", "            /* Add extra field as a dict entry.  Fields are", "             * separated by Tabs. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["            n = p;", "            while (*p != NUL && *p >= ' ' && *p < 127 && *p != ':')", "              ++p;"], "readability/braces"]
["src/nvim/tag.c", ["            while (*p != NUL && *p >= ' ' && *p < 127 && *p != ':')", "              ++p;", "            len = (int)(p - n);"], "readability/increment"]
["src/nvim/tag.c", ["              s = ++p;", "              while (*p != NUL && *p >= ' ')", "                ++p;"], "readability/braces"]
["src/nvim/tag.c", ["              while (*p != NUL && *p >= ' ')", "                ++p;", "              n[len] = NUL;"], "readability/increment"]
["src/nvim/tag.c", ["              n[len] = NUL;", "              if (add_tag_field(dict, (char *)n, s, p) == FAIL)", "                ret = FAIL;"], "readability/braces"]
["src/nvim/tag.c", ["              n[len] = ':';", "            } else", "              /* Skip field without colon. */"], "readability/braces"]
["src/nvim/tag.c", ["            } else", "              /* Skip field without colon. */", "              while (*p != NUL && *p >= ' ')"], "readability/old_style_comment"]
["src/nvim/tag.c", ["              /* Skip field without colon. */", "              while (*p != NUL && *p >= ' ')", "                ++p;"], "readability/braces"]
["src/nvim/tag.c", ["              while (*p != NUL && *p >= ' ')", "                ++p;", "            if (*p == NUL)"], "readability/increment"]
["src/nvim/tag.c", ["                ++p;", "            if (*p == NUL)", "              break;"], "readability/braces"]
["src/nvim/tag.h", ["", "/*", " * Values for do_tag()."], "readability/old_style_comment"]
["src/nvim/tag.h", [" */", "#define DT_TAG          1       /* jump to newer position or same tag again */", "#define DT_POP          2       /* jump to older position */"], "readability/old_style_comment"]
["src/nvim/tag.h", ["#define DT_TAG          1       /* jump to newer position or same tag again */", "#define DT_POP          2       /* jump to older position */", "#define DT_NEXT         3       /* jump to next match of same tag */"], "readability/old_style_comment"]
["src/nvim/tag.h", ["#define DT_POP          2       /* jump to older position */", "#define DT_NEXT         3       /* jump to next match of same tag */", "#define DT_PREV         4       /* jump to previous match of same tag */"], "readability/old_style_comment"]
["src/nvim/tag.h", ["#define DT_NEXT         3       /* jump to next match of same tag */", "#define DT_PREV         4       /* jump to previous match of same tag */", "#define DT_FIRST        5       /* jump to first match of same tag */"], "readability/old_style_comment"]
["src/nvim/tag.h", ["#define DT_PREV         4       /* jump to previous match of same tag */", "#define DT_FIRST        5       /* jump to first match of same tag */", "#define DT_LAST         6       /* jump to first match of same tag */"], "readability/old_style_comment"]
["src/nvim/tag.h", ["#define DT_FIRST        5       /* jump to first match of same tag */", "#define DT_LAST         6       /* jump to first match of same tag */", "#define DT_SELECT       7       /* jump to selection from list */"], "readability/old_style_comment"]
["src/nvim/tag.h", ["#define DT_LAST         6       /* jump to first match of same tag */", "#define DT_SELECT       7       /* jump to selection from list */", "#define DT_HELP         8       /* like DT_TAG, but no wildcards */"], "readability/old_style_comment"]
["src/nvim/tag.h", ["#define DT_SELECT       7       /* jump to selection from list */", "#define DT_HELP         8       /* like DT_TAG, but no wildcards */", "#define DT_JUMP         9       /* jump to new tag or selection from list */"], "readability/old_style_comment"]
["src/nvim/tag.h", ["#define DT_HELP         8       /* like DT_TAG, but no wildcards */", "#define DT_JUMP         9       /* jump to new tag or selection from list */", "#define DT_CSCOPE       10      /* cscope find command (like tjump) */"], "readability/old_style_comment"]
["src/nvim/tag.h", ["#define DT_JUMP         9       /* jump to new tag or selection from list */", "#define DT_CSCOPE       10      /* cscope find command (like tjump) */", "#define DT_LTAG         11      /* tag using location list */"], "readability/old_style_comment"]
["src/nvim/tag.h", ["#define DT_CSCOPE       10      /* cscope find command (like tjump) */", "#define DT_LTAG         11      /* tag using location list */", "#define DT_FREE         99      /* free cached matches */"], "readability/old_style_comment"]
["src/nvim/tag.h", ["#define DT_LTAG         11      /* tag using location list */", "#define DT_FREE         99      /* free cached matches */", ""], "readability/old_style_comment"]
["src/nvim/tag.h", ["", "/*", " * Structure used for get_tagfname()."], "readability/old_style_comment"]
["src/nvim/tag.h", ["typedef struct {", "  char_u      *tn_tags;         /* value of 'tags' when starting */", "  char_u      *tn_np;           /* current position in tn_tags */"], "readability/old_style_comment"]
["src/nvim/tag.h", ["  char_u      *tn_tags;         /* value of 'tags' when starting */", "  char_u      *tn_np;           /* current position in tn_tags */", "  int tn_did_filefind_init;"], "readability/old_style_comment"]
["src/nvim/terminal.c", ["  invalidate_terminal(data, MIN(dest.start_row, src.start_row),", "      MAX(dest.end_row, src.end_row));", "  return 1;"], "whitespace/alignment"]
["src/nvim/terminal.c", ["static int term_movecursor(VTermPos new, VTermPos old, int visible,", "    void *data)", "{"], "whitespace/alignment"]
["src/nvim/terminal.c", ["    memmove(term->sb_buffer + 1, term->sb_buffer,", "        sizeof(term->sb_buffer[0]) * (term->sb_current - 1));", ""], "whitespace/alignment"]
["src/nvim/terminal.c", ["    memmove(term->sb_buffer + 1, term->sb_buffer,", "        sizeof(term->sb_buffer[0]) * term->sb_current);", "  }"], "whitespace/alignment"]
["src/nvim/terminal.c", ["  memmove(term->sb_buffer, term->sb_buffer + 1,", "      sizeof(term->sb_buffer[0]) * (term->sb_current));", ""], "whitespace/alignment"]
["src/nvim/terminal.c", ["static void mouse_action(Terminal *term, int button, int row, int col,", "    bool drag, VTermModifier mod)", "{"], "whitespace/alignment"]
["src/nvim/terminal.c", ["    switch (c) {", "      case K_LEFTDRAG: drag = true;   FALLTHROUGH;", "      case K_LEFTMOUSE: button = 1; break;"], "whitespace/newline"]
["src/nvim/terminal.c", ["      case K_LEFTMOUSE: button = 1; break;", "      case K_MIDDLEDRAG: drag = true; FALLTHROUGH;", "      case K_MIDDLEMOUSE: button = 2; break;"], "whitespace/newline"]
["src/nvim/terminal.c", ["      case K_MIDDLEMOUSE: button = 2; break;", "      case K_RIGHTDRAG: drag = true;  FALLTHROUGH;", "      case K_RIGHTMOUSE: button = 3; break;"], "whitespace/newline"]
["src/nvim/terminal.c", ["        cell_len += utf_char2bytes((int)cell.chars[i],", "            (uint8_t *)ptr + cell_len);", "      }"], "whitespace/alignment"]
["src/nvim/terminal.c", ["    vterm_screen_get_cell(term->vts, (VTermPos){.row = row, .col = col},", "        cell);", "  }"], "whitespace/alignment"]
["src/nvim/terminal.c", ["  } else {", "    vterm_screen_get_cell(term->vts, (VTermPos){.row = row, .col = col},", "        cell);"], "whitespace/braces"]
["src/nvim/terminal.c", ["  } else {", "    vterm_screen_get_cell(term->vts, (VTermPos){.row = row, .col = col},", "        cell);"], "whitespace/braces"]
["src/nvim/terminal.c", ["  Terminal *term;", "  void *stub; (void)(stub);", "  // don't process autocommands while updating terminal buffers"], "whitespace/newline"]
["src/nvim/tui/input.c", ["", "  row--; col--;  // Termkey uses 1-based coordinates", "  buf[len++] = '<';"], "whitespace/newline"]
["src/nvim/tui/input.c", ["    termkey_push_bytes(input->tk, rbuffer_read_ptr(input->read_stream.buffer,", "          &rcnt), 1);", "    rbuffer_consumed(input->read_stream.buffer, 2);"], "whitespace/alignment"]
["src/nvim/tui/terminfo_defs.h", ["//  no_color_video#3,", "//  acs_chars=+^P\\054^Q-^X.^Y0\\333`^Da\\261f\\370g\\361h\\260j\\331k\\277l\\332m\\300n\\305o~p\\304q\\304r\\304s_t\\303u\\264v\\301w\\302x\\263y\\363z\\362{\\343|\\330}\\234~\\376,", "//  back_tab=\\E[Z,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  set_a_foreground=\\E[3%p1%dm,", "//  set_attributes=\\E[0;10%?%p1%t;7%;%?%p2%t;4%;%?%p3%t;7%;%?%p4%t;5%;%?%p6%t;1%;%?%p7%t;8%;%?%p9%t;11%;m,", "//  set_tab=\\EH,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  max_pairs#64,", "//  acs_chars=+^P\\054^Q-^X.^Y0\\333`^Da\\261f\\370g\\361h\\260j\\331k\\277l\\332m\\300n\\305o~p\\304q\\304r\\304s_t\\303u\\264v\\301w\\302x\\263y\\363z\\362{\\343|\\330}\\234~\\376,", "//  bell=^G,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  set_a_foreground=\\E[3%p1%dm,", "//  set_attributes=\\E[0;10%?%p1%t;7%;%?%p2%t;4%;%?%p3%t;7%;%?%p6%t;1%;%?%p7%t;8%;%?%p9%t;11%;m,", "//  tab=^I,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["", "// interix|opennt|opennt-25|ntconsole|ntconsole-25|OpenNT-term compatible with color,", "//  auto_right_margin,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  no_color_video#3,", "//  acs_chars=+^P\\054^Q-^X.^Y0\\333`^Da\\261f\\370g\\361h\\260j\\331k\\277l\\332m\\300n\\305o~p\\304q\\304r\\304s_t\\303u\\264v\\301w\\302x\\263y\\363z\\362{\\343|\\330}\\234~\\376,", "//  bell=^G,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  scroll_reverse=\\EM,", "//  set_a_background=\\E[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m,", "//  set_a_foreground=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  set_a_background=\\E[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m,", "//  set_a_foreground=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,", "//  set_attributes=\\E[0%?%p6%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;%?%p5%t;2%;m%?%p9%t^N%e^O%;,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  set_a_foreground=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,", "//  set_attributes=\\E[0%?%p6%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;%?%p5%t;2%;m%?%p9%t^N%e^O%;,", "//  set_tab=\\EH,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  no_color_video#18,", "//  acs_chars=++\\054\\054--..00__``aaffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}c~~,", "//  bell=^G,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  flash_screen=\\E[?5h$<200/>\\E[?5l,", "//  initialize_color=\\E]P%p1%x%p2%{255}%*%{1000}%/%02x%p3%{255}%*%{1000}%/%02x%p4%{255}%*%{1000}%/%02x,", "//  insert_character=\\E[@,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  set_a_foreground=\\E[3%p1%dm,", "//  set_attributes=\\E[0;10%?%p1%t;7%;%?%p2%t;4%;%?%p3%t;7%;%?%p4%t;5%;%?%p5%t;2%;%?%p6%t;1%;m%?%p9%t^N%e^O%;,", "//  set_tab=\\EH,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  dis_status_line=\\E]0;^G,", "//  display_pc_char=%?%p1%{8}%=%t\\E%%G\\342\\227\\230\\E%%@%e%p1%{10}%=%t\\E%%G\\342\\227\\231\\E%%@%e%p1%{12}%=%t\\E%%G\\342\\231\\0\\E%%@%e%p1%{13}%=%t\\E%%G\\342\\231\\252\\E%%@%e%p1%{14}%=%t\\E%%G\\342\\231\\253\\E%%@%e%p1%{15}%=%t\\E%%G\\342\\230\\274\\E%%@%e%p1%{27}%=%t\\E%%G\\342\\206\\220\\E%%@%e%p1%{155}%=%t\\E%%G\\340\\202\\242\\E%%@%e%p1%c%;,", "//  ena_acs=\\E(B\\E)0,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  set2_des_seq=\\E[12m,", "//  set_a_background=\\E[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m,", "//  set_a_foreground=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  set_a_background=\\E[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m,", "//  set_a_foreground=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,", "//  set_attributes=\\E[0%?%p1%p6%|%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;m%?%p9%t^N%e^O%;,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  set_a_foreground=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,", "//  set_attributes=\\E[0%?%p1%p6%|%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;m%?%p9%t^N%e^O%;,", "//  set_tab=\\EH,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  init_2string=\\E[r\\E[m\\E[2J\\E[H\\E[?7h\\E[?1;3;4;6l\\E[4l,", "//  initialize_color=\\E]4;%p1%d;rgb\\072%p2%{255}%*%{1000}%/%2.2X/%p3%{255}%*%{1000}%/%2.2X/%p4%{255}%*%{1000}%/%2.2X\\E\\,", "//  insert_character=\\E[@,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  set1_des_seq=\\E(0,", "//  set_a_background=\\E[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m,", "//  set_a_foreground=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  set_a_background=\\E[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m,", "//  set_a_foreground=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,", "//  set_attributes=\\E[0%?%p6%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;m%?%p9%t^N%e^O%;,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  set_a_foreground=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,", "//  set_attributes=\\E[0%?%p6%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;m%?%p9%t^N%e^O%;,", "//  set_tab=\\EH,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  max_pairs#0x10000,", "//  acs_chars=++\\054\\054--..00``aaffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,", "//  back_tab=\\E[Z,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  scroll_reverse=\\EM,", "//  set_a_background=\\E[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m,", "//  set_a_foreground=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  set_a_background=\\E[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m,", "//  set_a_foreground=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,", "//  set_attributes=\\E[0%?%p6%t;1%;%?%p1%t;3%;%?%p2%t;4%;%?%p3%t;7%;%?%p4%t;5%;%?%p5%t;2%;m%?%p9%t^N%e^O%;,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  set_a_foreground=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,", "//  set_attributes=\\E[0%?%p6%t;1%;%?%p1%t;3%;%?%p2%t;4%;%?%p3%t;7%;%?%p4%t;5%;%?%p5%t;2%;m%?%p9%t^N%e^O%;,", "//  set_tab=\\EH,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  max_pairs#0x10000,", "//  acs_chars=+C\\054D-A.B0E``aaffgghFiGjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,", "//  back_tab=\\E[Z,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  scroll_reverse=\\EM,", "//  set_a_background=\\E[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m,", "//  set_a_foreground=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  set_a_background=\\E[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m,", "//  set_a_foreground=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,", "//  set_attributes=%?%p9%t\\E(0%e\\E(B%;\\E[0%?%p6%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;%?%p5%t;2%;%?%p7%t;8%;m,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  set_a_foreground=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,", "//  set_attributes=%?%p9%t\\E(0%e\\E(B%;\\E[0%?%p6%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;%?%p5%t;2%;%?%p7%t;8%;m,", "//  set_tab=\\EH,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  max_pairs#0x10000,", "//  acs_chars=++\\054\\054--..00``aaffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,", "//  back_tab=\\E[Z,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  scroll_reverse=\\EM,", "//  set_a_background=\\E[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m,", "//  set_a_foreground=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  set_a_background=\\E[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m,", "//  set_a_foreground=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,", "//  set_attributes=\\E[0%?%p6%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;%?%p5%t;2%;%?%p7%t;8%;m%?%p9%t^N%e^O%;,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  set_a_foreground=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,", "//  set_attributes=\\E[0%?%p6%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;%?%p5%t;2%;%?%p7%t;8%;m%?%p9%t^N%e^O%;,", "//  set_tab=\\EH,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  init_2string=\\E[m\\E[?7h\\E[4l\\E>\\E7\\E[r\\E[?1;3;4;6l\\E8,", "//  initialize_color=\\E]4;%p1%d;rgb\\072%p2%{255}%*%{1000}%/%2.2X/%p3%{255}%*%{1000}%/%2.2X/%p4%{255}%*%{1000}%/%2.2X\\E\\,", "//  insert_line=\\E[L,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  reset_1string=\\Ec,", "//  reset_2string=\\E7\\E[r\\E8\\E[m\\E[?7h\\E[\\041p\\E[?1;3;4;6l\\E[4l\\E>\\E[?1000l\\E[?25h,", "//  restore_cursor=\\E8,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  scroll_reverse=\\EM,", "//  set_a_background=\\E[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m,", "//  set_a_foreground=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  set_a_background=\\E[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m,", "//  set_a_foreground=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,", "//  set_attributes=\\E[0%?%p6%t;1%;%?%p2%t;4%;%?%p5%t;2%;%?%p7%t;8%;%?%p1%p3%|%t;7%;m%?%p9%t^N%e^O%;,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  set_a_foreground=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,", "//  set_attributes=\\E[0%?%p6%t;1%;%?%p2%t;4%;%?%p5%t;2%;%?%p7%t;8%;%?%p1%p3%|%t;7%;m%?%p9%t^N%e^O%;,", "//  set_tab=\\EH,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  init_2string=\\E[\\041p\\E[?3l,", "//  initialize_color=\\E]4;%p1%d;rgb\\072%p2%{255}%*%{1000}%/%2.2X/%p3%{255}%*%{1000}%/%2.2X/%p4%{255}%*%{1000}%/%2.2X\\E,", "//  insert_line=\\E[L,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  scroll_reverse=\\EM,", "//  set_a_background=\\E[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m,", "//  set_a_foreground=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  set_a_background=\\E[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m,", "//  set_a_foreground=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,", "//  set_attributes=\\E[0%?%p1%p3%|%t;7%;%?%p2%t;4%;%?%p6%t;1%;m,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  init_2string=\\E[\\041p\\E[?3;4l\\E[4l\\E>,", "//  initialize_color=\\E]4;%p1%d;rgb\\072%p2%{255}%*%{1000}%/%2.2X/%p3%{255}%*%{1000}%/%2.2X/%p4%{255}%*%{1000}%/%2.2X\\E\\,", "//  insert_line=\\E[L,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  scroll_reverse=\\EM,", "//  set_a_background=\\E[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m,", "//  set_a_foreground=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  set_a_background=\\E[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m,", "//  set_a_foreground=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,", "//  set_attributes=%?%p9%t\\E(0%e\\E(B%;\\E[0%?%p6%t;1%;%?%p5%t;2%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;%?%p7%t;8%;m,"], "whitespace/line_length"]
["src/nvim/tui/terminfo_defs.h", ["//  set_a_foreground=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,", "//  set_attributes=%?%p9%t\\E(0%e\\E(B%;\\E[0%?%p6%t;1%;%?%p5%t;2%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;%?%p7%t;8%;m,", "//  set_tab=\\EH,"], "whitespace/line_length"]
["src/nvim/tui/tui.c", ["#define STARTS_WITH(str, prefix) (strlen(str) >= (sizeof(prefix) - 1) \\", "    && 0 == memcmp((str), (prefix), sizeof(prefix) - 1))", "#define TMUX_WRAP(is_tmux, seq) ((is_tmux) \\"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["static void unibi_set_if_empty(unibi_term *ut, enum unibi_string str,", "    const char *val)", "{"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["      data->unibi_ext.set_cursor_style = (int)unibi_add_ext_str(ut, \"Ss\",", "          \"\\x1b[?\"", "          \"%?\""], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["          \"\\x1b[?\"", "          \"%?\"", "          // The parameter passed to Ss is the DECSCUSR parameter, so the"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["          // possible to have a steady block (no steady underline)", "          \"%p1%{2}%<\" \"%t%{8}\"       // blink block", "          \"%e%p1%{2}%=\" \"%t%{112}\"   // steady block"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["          \"%p1%{2}%<\" \"%t%{8}\"       // blink block", "          \"%e%p1%{2}%=\" \"%t%{112}\"   // steady block", "          \"%e%p1%{3}%=\" \"%t%{4}\"     // blink underline (set to half block)"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["          \"%e%p1%{2}%=\" \"%t%{112}\"   // steady block", "          \"%e%p1%{3}%=\" \"%t%{4}\"     // blink underline (set to half block)", "          \"%e%p1%{4}%=\" \"%t%{4}\"     // steady underline"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["          \"%e%p1%{3}%=\" \"%t%{4}\"     // blink underline (set to half block)", "          \"%e%p1%{4}%=\" \"%t%{4}\"     // steady underline", "          \"%e%p1%{5}%=\" \"%t%{2}\"     // blink bar (set to underline)"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["          \"%e%p1%{4}%=\" \"%t%{4}\"     // steady underline", "          \"%e%p1%{5}%=\" \"%t%{2}\"     // blink bar (set to underline)", "          \"%e%p1%{6}%=\" \"%t%{2}\"     // steady bar"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["          \"%e%p1%{5}%=\" \"%t%{2}\"     // blink bar (set to underline)", "          \"%e%p1%{6}%=\" \"%t%{2}\"     // steady bar", "          \"%e%{0}\"                   // anything else"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["          \"%e%p1%{6}%=\" \"%t%{2}\"     // steady bar", "          \"%e%{0}\"                   // anything else", "          \"%;\" \"%dc\");"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["          \"%e%{0}\"                   // anything else", "          \"%;\" \"%dc\");", "      if (-1 == data->unibi_ext.reset_cursor_style) {"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["      data->unibi_ext.set_cursor_style = (int)unibi_add_ext_str(ut, \"Ss\",", "          TMUX_WRAP(tmux, \"\\x1b]50;CursorShape=%?\"", "          \"%p1%{3}%<\" \"%t%{0}\"    // block"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["          TMUX_WRAP(tmux, \"\\x1b]50;CursorShape=%?\"", "          \"%p1%{3}%<\" \"%t%{0}\"    // block", "          \"%e%p1%{5}%<\" \"%t%{2}\"  // underline"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["          \"%p1%{3}%<\" \"%t%{0}\"    // block", "          \"%e%p1%{5}%<\" \"%t%{2}\"  // underline", "          \"%e%{1}\"                // everything else is bar"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["          \"%e%p1%{5}%<\" \"%t%{2}\"  // underline", "          \"%e%{1}\"                // everything else is bar", "          \"%;%d;BlinkingCursorEnabled=%?\""], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["          \"%e%{1}\"                // everything else is bar", "          \"%;%d;BlinkingCursorEnabled=%?\"", "          \"%p1%{1}%<\" \"%t%{1}\"  // Fortunately if we exclude zero as special,"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["          \"%;%d;BlinkingCursorEnabled=%?\"", "          \"%p1%{1}%<\" \"%t%{1}\"  // Fortunately if we exclude zero as special,", "          \"%e%p1%{1}%&\"  // in all other cases we can treat bit #0 as a flag."], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["          \"%p1%{1}%<\" \"%t%{1}\"  // Fortunately if we exclude zero as special,", "          \"%e%p1%{1}%&\"  // in all other cases we can treat bit #0 as a flag.", "          \"%;%d\\x07\"));"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["          \"%e%p1%{1}%&\"  // in all other cases we can treat bit #0 as a flag.", "          \"%;%d\\x07\"));", "      if (-1 == data->unibi_ext.reset_cursor_style) {"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["          TMUX_WRAP(tmux, \"\\x1b]50;CursorShape=%?\"", "          \"%p1%{3}%<\" \"%t%{0}\"    // block", "          \"%e%p1%{5}%<\" \"%t%{2}\"  // underline"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["          \"%p1%{3}%<\" \"%t%{0}\"    // block", "          \"%e%p1%{5}%<\" \"%t%{2}\"  // underline", "          \"%e%{1}\"                // everything else is bar"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["          \"%e%p1%{5}%<\" \"%t%{2}\"  // underline", "          \"%e%{1}\"                // everything else is bar", "          \"%;%d;BlinkingCursorEnabled=%?\""], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["          \"%e%{1}\"                // everything else is bar", "          \"%;%d;BlinkingCursorEnabled=%?\"", "          \"%p1%{1}%<\" \"%t%{1}\"  // Fortunately if we exclude zero as special,"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["          \"%;%d;BlinkingCursorEnabled=%?\"", "          \"%p1%{1}%<\" \"%t%{1}\"  // Fortunately if we exclude zero as special,", "          \"%e%p1%{1}%&\"  // in all other cases we can treat bit #0 as a flag."], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["          \"%p1%{1}%<\" \"%t%{1}\"  // Fortunately if we exclude zero as special,", "          \"%e%p1%{1}%&\"  // in all other cases we can treat bit #0 as a flag.", "          \"%;%d\\x07\"));"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["          \"%e%p1%{1}%&\"  // in all other cases we can treat bit #0 as a flag.", "          \"%;%d\\x07\"));", "      if (-1 == data->unibi_ext.reset_cursor_style) {"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["      unibi_set_ext_str(ut, (size_t)data->unibi_ext.reset_cursor_style,", "          \"\\x1b]50;\\x07\");", "    }"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["    data->unibi_ext.resize_screen = (int)unibi_add_ext_str(ut,", "      \"ext.resize_screen\",", "      \"\\x1b[8;%p1%d;%p2%dt\");"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["      \"ext.resize_screen\",", "      \"\\x1b[8;%p1%d;%p2%dt\");", "  }"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["    data->unibi_ext.reset_scroll_region = (int)unibi_add_ext_str(ut,", "      \"ext.reset_scroll_region\",", "      \"\\x1b[r\");"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["      \"ext.reset_scroll_region\",", "      \"\\x1b[r\");", "  }"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["      data->unibi_ext.set_rgb_foreground = (int)unibi_add_ext_str(ut, \"setrgbf\",", "          \"\\x1b[38:2:%p1%d:%p2%d:%p3%dm\");", "    } else {"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["      data->unibi_ext.set_rgb_foreground = (int)unibi_add_ext_str(ut, \"setrgbf\",", "          \"\\x1b[38;2;%p1%d;%p2%d;%p3%dm\");", "    }"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["      data->unibi_ext.set_rgb_background = (int)unibi_add_ext_str(ut, \"setrgbb\",", "          \"\\x1b[48:2:%p1%d:%p2%d:%p3%dm\");", "    } else {"], "whitespace/alignment"]
["src/nvim/tui/tui.c", ["      data->unibi_ext.set_rgb_background = (int)unibi_add_ext_str(ut, \"setrgbb\",", "          \"\\x1b[48;2;%p1%d;%p2%d;%p3%dm\");", "    }"], "whitespace/alignment"]
["src/nvim/ui_bridge.h", ["typedef void(*ui_main_fn)(UIBridgeData *bridge, UI *ui);", "struct ui_bridge_data {", "  UI bridge;  // actual UI passed to ui_attach"], "readability/braces"]
["src/nvim/undo.c", ["", "/*", " * undo.c: multi level undo facility"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/* Uncomment the next line for including the u_check() function.  This warns", " * for errors in the debug information. */"], "readability/old_style_comment"]
["src/nvim/undo.c", [" * for errors in the debug information. */", "/* #define U_DEBUG 1 */", "#define UH_MAGIC 0x18dade       /* value for uh_magic when in use */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["/* #define U_DEBUG 1 */", "#define UH_MAGIC 0x18dade       /* value for uh_magic when in use */", "#define UE_MAGIC 0xabc123       /* value for ue_magic when in use */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["#define UH_MAGIC 0x18dade       /* value for uh_magic when in use */", "#define UE_MAGIC 0xabc123       /* value for ue_magic when in use */", ""], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/* used in undo_end() to report number of added and deleted lines */", "static long u_newcount, u_oldcount;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * When 'u' flag included in 'cpoptions', we behave like vi.  Need to remember"], "readability/old_style_comment"]
["src/nvim/undo.c", ["#if defined(U_DEBUG)", "/*", " * Check the undo structures for being valid.  Print a warning when something"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    u_header_T *exp_uh_next,", "    u_header_T *exp_uh_alt_prev) {", "  u_entry_T *uep;"], "readability/braces"]
["src/nvim/undo.c", ["static void u_check_tree(u_header_T *uhp,", "    u_header_T *exp_uh_next,", "    u_header_T *exp_uh_alt_prev) {"], "whitespace/alignment"]
["src/nvim/undo.c", ["    u_header_T *exp_uh_next,", "    u_header_T *exp_uh_alt_prev) {", "  u_entry_T *uep;"], "whitespace/alignment"]
["src/nvim/undo.c", ["", "  if (uhp == NULL)", "    return;"], "readability/braces"]
["src/nvim/undo.c", ["    return;", "  ++header_count;", "  if (uhp == curbuf->b_u_curhead && ++seen_b_u_curhead > 1) {"], "readability/increment"]
["src/nvim/undo.c", ["", "  if (uhp->uh_magic != UH_MAGIC)", "    EMSG(\"uh_magic wrong (may be using freed memory)\");"], "readability/braces"]
["src/nvim/undo.c", ["    EMSG(\"uh_magic wrong (may be using freed memory)\");", "  else {", "    /* Check pointers back are correct. */"], "readability/braces"]
["src/nvim/undo.c", ["    EMSG(\"uh_magic wrong (may be using freed memory)\");", "  else {", "    /* Check pointers back are correct. */"], "readability/braces"]
["src/nvim/undo.c", ["  else {", "    /* Check pointers back are correct. */", "    if (uhp->uh_next.ptr != exp_uh_next) {"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      smsg(\"expected: 0x%x, actual: 0x%x\",", "          exp_uh_next, uhp->uh_next.ptr);", "    }"], "whitespace/alignment"]
["src/nvim/undo.c", ["      smsg(\"expected: 0x%x, actual: 0x%x\",", "          exp_uh_alt_prev, uhp->uh_alt_prev.ptr);", "    }"], "whitespace/alignment"]
["src/nvim/undo.c", ["", "    /* Check the undo tree at this header. */", "    for (uep = uhp->uh_entry; uep != NULL; uep = uep->ue_next) {"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "    /* Check the next alt tree. */", "    u_check_tree(uhp->uh_alt_next.ptr, uhp->uh_next.ptr, uhp);"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "    /* Check the next header in this branch. */", "    u_check_tree(uhp->uh_prev.ptr, uhp, NULL);"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "static void u_check(int newhead_may_be_NULL)                 {", "  seen_b_u_newhead = 0;"], "readability/braces"]
["src/nvim/undo.c", ["", "  if (seen_b_u_newhead == 0 && curbuf->b_u_oldhead != NULL", "      && !(newhead_may_be_NULL && curbuf->b_u_newhead == NULL))"], "readability/braces"]
["src/nvim/undo.c", ["    EMSGN(\"b_u_newhead invalid: 0x%x\", curbuf->b_u_newhead);", "  if (curbuf->b_u_curhead != NULL && seen_b_u_curhead == 0)", "    EMSGN(\"b_u_curhead invalid: 0x%x\", curbuf->b_u_curhead);"], "readability/braces"]
["src/nvim/undo.c", ["    smsg(\"expected: %\" PRId64 \", actual: %\" PRId64,", "        (int64_t)header_count, (int64_t)curbuf->b_u_numhead);", "  }"], "whitespace/alignment"]
["src/nvim/undo.c", ["", "/*", " * Save the current line for both the \"u\" and \"U\" command."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Save the lines between \"top\" and \"bot\" for both the \"u\" and \"U\" command."], "readability/old_style_comment"]
["src/nvim/undo.c", ["  if (top >= bot || bot > (curbuf->b_ml.ml_line_count + 1)) {", "    return FAIL;        /* rely on caller to do error messages */", "  }"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  if (top + 2 == bot)", "    u_saveline((linenr_T)(top + 1));"], "readability/braces"]
["src/nvim/undo.c", ["", "  return u_savecommon(top, bot, (linenr_T)0, FALSE);", "}"], "readability/bool"]
["src/nvim/undo.c", ["", "/*", " * Save the line \"lnum\" (used by \":s\" and \"~\" command)."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * A new line is inserted before line \"lnum\" (used by :s command)."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Save the lines \"lnum\" - \"lnum\" + nlines (used by delete command)."], "readability/old_style_comment"]
["src/nvim/undo.c", ["  return u_savecommon(lnum - 1, lnum + nlines,", "      nlines == curbuf->b_ml.ml_line_count ? 2 : lnum, FALSE);", "}"], "whitespace/alignment"]
["src/nvim/undo.c", ["  return u_savecommon(lnum - 1, lnum + nlines,", "      nlines == curbuf->b_ml.ml_line_count ? 2 : lnum, FALSE);", "}"], "readability/bool"]
["src/nvim/undo.c", ["{", "  /* Don't allow changes when 'modifiable' is off.  */", "  if (!MODIFIABLE(curbuf)) {"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /* Don't allow changes in the buffer while editing the cmdline.  The", "   * caller of getcmdline() may get confused. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Common code for various ways to save text before a change."], "readability/old_style_comment"]
["src/nvim/undo.c", ["  if (!reload) {", "    /* When making changes is not allowed return FAIL.  It's a crude way", "     * to make all change commands fail. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["     * to make all change commands fail. */", "    if (!undo_allowed())", "      return FAIL;"], "readability/braces"]
["src/nvim/undo.c", ["", "    /*", "     * Saving text for undo means we are going to make a change.  Give a"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    if (bot > curbuf->b_ml.ml_line_count + 1) {", "      /* This happens when the FileChangedRO autocommand changes the", "       * file in a way it becomes shorter. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "  u_check(FALSE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["", "  /*", "   * If curbuf->b_u_synced == true make a new header."], "readability/old_style_comment"]
["src/nvim/undo.c", ["  if (curbuf->b_u_synced) {", "    /* Need to create new entry in b_changelist. */", "    curbuf->b_new_change = true;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    if (get_undolevel() >= 0) {", "      /*", "       * Make a new header entry.  Do this first so that we don't mess"], "readability/old_style_comment"]
["src/nvim/undo.c", ["#endif", "    } else", "      uhp = NULL;"], "readability/braces"]
["src/nvim/undo.c", ["", "    /*", "     * If we undid more than we redid, move the entry lists before and"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "    /*", "     * free headers to keep the size right"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "      if (uhfree == old_curhead)", "        /* Can't reconnect the branch, delete all of it. */"], "readability/braces"]
["src/nvim/undo.c", ["      if (uhfree == old_curhead)", "        /* Can't reconnect the branch, delete all of it. */", "        u_freebranch(curbuf, uhfree, &old_curhead);"], "readability/old_style_comment"]
["src/nvim/undo.c", ["        u_freebranch(curbuf, uhfree, &old_curhead);", "      else if (uhfree->uh_alt_next.ptr == NULL)", "        /* There is no branch, only free one header. */"], "readability/braces"]
["src/nvim/undo.c", ["      else if (uhfree->uh_alt_next.ptr == NULL)", "        /* There is no branch, only free one header. */", "        u_freeheader(curbuf, uhfree, &old_curhead);"], "readability/old_style_comment"]
["src/nvim/undo.c", ["        u_freeheader(curbuf, uhfree, &old_curhead);", "      else {", "        /* Free the oldest alternate branch as a whole. */"], "readability/braces"]
["src/nvim/undo.c", ["        u_freeheader(curbuf, uhfree, &old_curhead);", "      else {", "        /* Free the oldest alternate branch as a whole. */"], "readability/braces"]
["src/nvim/undo.c", ["      else {", "        /* Free the oldest alternate branch as a whole. */", "        while (uhfree->uh_alt_next.ptr != NULL)"], "readability/old_style_comment"]
["src/nvim/undo.c", ["        /* Free the oldest alternate branch as a whole. */", "        while (uhfree->uh_alt_next.ptr != NULL)", "          uhfree = uhfree->uh_alt_next.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "      u_check(TRUE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["", "    if (uhp == NULL) {                  /* no undo at all */", "      if (old_curhead != NULL)"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    if (uhp == NULL) {                  /* no undo at all */", "      if (old_curhead != NULL)", "        u_freebranch(curbuf, old_curhead, NULL);"], "readability/braces"]
["src/nvim/undo.c", ["      uhp->uh_alt_prev.ptr = old_curhead->uh_alt_prev.ptr;", "      if (uhp->uh_alt_prev.ptr != NULL)", "        uhp->uh_alt_prev.ptr->uh_alt_next.ptr = uhp;"], "readability/braces"]
["src/nvim/undo.c", ["      old_curhead->uh_alt_prev.ptr = uhp;", "      if (curbuf->b_u_oldhead == old_curhead)", "        curbuf->b_u_oldhead = uhp;"], "readability/braces"]
["src/nvim/undo.c", ["        curbuf->b_u_oldhead = uhp;", "    } else", "      uhp->uh_alt_prev.ptr = NULL;"], "readability/braces"]
["src/nvim/undo.c", ["      uhp->uh_alt_prev.ptr = NULL;", "    if (curbuf->b_u_newhead != NULL)", "      curbuf->b_u_newhead->uh_prev.ptr = uhp;"], "readability/braces"]
["src/nvim/undo.c", ["    uhp->uh_getbot_entry = NULL;", "    uhp->uh_cursor = curwin->w_cursor;          /* save cursor pos. for undo */", "    if (virtual_active() && curwin->w_cursor.coladd > 0)"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    uhp->uh_cursor = curwin->w_cursor;          /* save cursor pos. for undo */", "    if (virtual_active() && curwin->w_cursor.coladd > 0)", "      uhp->uh_cursor_vcol = getviscol();"], "readability/braces"]
["src/nvim/undo.c", ["      uhp->uh_cursor_vcol = getviscol();", "    else", "      uhp->uh_cursor_vcol = -1;"], "readability/braces"]
["src/nvim/undo.c", ["", "    /* save changed and buffer empty flag for undo */", "    uhp->uh_flags = (curbuf->b_changed ? UH_CHANGED : 0) +"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "    /* save named marks and Visual marks for undo */", "    zero_fmark_additional_data(curbuf->b_namedm);"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    curbuf->b_u_newhead = uhp;", "    if (curbuf->b_u_oldhead == NULL)", "      curbuf->b_u_oldhead = uhp;"], "readability/braces"]
["src/nvim/undo.c", ["      curbuf->b_u_oldhead = uhp;", "    ++curbuf->b_u_numhead;", "  } else {"], "readability/increment"]
["src/nvim/undo.c", ["  } else {", "    if (get_undolevel() < 0)            /* no undo at all */", "      return OK;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  } else {", "    if (get_undolevel() < 0)            /* no undo at all */", "      return OK;"], "readability/braces"]
["src/nvim/undo.c", ["", "    /*", "     * When saving a single line, and it has been saved just before, it"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      prev_uep = NULL;", "      for (i = 0; i < 10; ++i) {", "        if (uep == NULL)"], "readability/increment"]
["src/nvim/undo.c", ["      for (i = 0; i < 10; ++i) {", "        if (uep == NULL)", "          break;"], "readability/braces"]
["src/nvim/undo.c", ["", "        /* If lines have been inserted/deleted we give up.", "         * Also when the line was included in a multi-line save. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["         * Also when the line was included in a multi-line save. */", "        if ((curbuf->b_u_newhead->uh_getbot_entry != uep", "             ? (uep->ue_top + uep->ue_size + 1"], "readability/braces"]
["src/nvim/undo.c", ["", "        /* If it's the same line we can skip saving it again. */", "        if (uep->ue_size == 1 && uep->ue_top == top) {"], "readability/old_style_comment"]
["src/nvim/undo.c", ["          if (i > 0) {", "            /* It's not the last entry: get ue_bot for the last", "             * entry now.  Following deleted/inserted lines go to"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "            /* Move the found entry to become the last entry.  The", "             * order of undo/redo doesn't matter for the entries"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "          /* The executed command may change the line count. */", "          if (newbot != 0)"], "readability/old_style_comment"]
["src/nvim/undo.c", ["          /* The executed command may change the line count. */", "          if (newbot != 0)", "            uep->ue_bot = newbot;"], "readability/braces"]
["src/nvim/undo.c", ["            uep->ue_bot = newbot;", "          else if (bot > curbuf->b_ml.ml_line_count)", "            uep->ue_bot = 0;"], "readability/braces"]
["src/nvim/undo.c", ["            uep->ue_bot = 0;", "          else {", "            uep->ue_lcount = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/undo.c", ["            uep->ue_bot = 0;", "          else {", "            uep->ue_lcount = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/undo.c", ["", "    /* find line number for ue_bot for previous u_save() */", "    u_getbot();"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /*", "   * add lines in front of entry list"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  uep->ue_top = top;", "  if (newbot != 0)", "    uep->ue_bot = newbot;"], "readability/braces"]
["src/nvim/undo.c", ["    uep->ue_bot = newbot;", "  /*", "   * Use 0 for ue_bot if bot is below last line."], "readability/old_style_comment"]
["src/nvim/undo.c", ["   */", "  else if (bot > curbuf->b_ml.ml_line_count)", "    uep->ue_bot = 0;"], "readability/braces"]
["src/nvim/undo.c", ["    uep->ue_bot = 0;", "  else {", "    uep->ue_lcount = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/undo.c", ["    uep->ue_bot = 0;", "  else {", "    uep->ue_lcount = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/undo.c", ["    uep->ue_array = xmalloc(sizeof(char_u *) * (size_t)size);", "    for (i = 0, lnum = top + 1; i < size; ++i) {", "      fast_breakcheck();"], "readability/increment"]
["src/nvim/undo.c", ["    }", "  } else", "    uep->ue_array = NULL;"], "readability/braces"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "  u_check(FALSE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["", "/* extra fields for header */", "# define UF_LAST_SAVE_NR        1"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/* extra fields for uhp */", "# define UHP_SAVE_NR            1"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Compute the hash for the current buffer text into hash[UNDO_HASH_SIZE]."], "readability/old_style_comment"]
["src/nvim/undo.c", ["  sha256_start(&ctx);", "  for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum) {", "    p = ml_get(lnum);"], "readability/increment"]
["src/nvim/undo.c", ["  // When not reading use the first directory that exists or \".\".", "  dirp = (char *) p_udir;", "  while (*dirp != NUL) {"], "whitespace/cast"]
["src/nvim/undo.c", ["      memmove(undo_file_name, ffname, ffname_len + 1);", "      char *const tail = (char *) path_tail((char_u *) undo_file_name);", "      const size_t tail_len = strlen(tail);"], "whitespace/cast"]
["src/nvim/undo.c", ["  if (name == NULL) {", "    file_name = u_get_undo_file_name((char *) buf->b_ffname, false);", "    if (file_name == NULL) {"], "whitespace/cast"]
["src/nvim/undo.c", ["  } else {", "    file_name = (char *) name;", "  }"], "whitespace/cast"]
["src/nvim/undo.c", ["", "  /*", "   * Decide about the permission to use for the undo file.  If the buffer"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /* If the undo file already exists, verify that it actually is an undo", "   * file, and delete it. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    if (name == NULL || !forceit) {", "      /* Check we can read it and it's an undo file. */", "      fd = os_open(file_name, O_RDONLY, 0);"], "readability/old_style_comment"]
["src/nvim/undo.c", ["        if (name != NULL || p_verbose > 0) {", "          if (name == NULL)", "            verbose_enter();"], "readability/braces"]
["src/nvim/undo.c", ["               file_name);", "          if (name == NULL)", "            verbose_leave();"], "readability/braces"]
["src/nvim/undo.c", ["          if (name != NULL || p_verbose > 0) {", "            if (name == NULL)", "              verbose_enter();"], "readability/braces"]
["src/nvim/undo.c", ["                 file_name);", "            if (name == NULL)", "              verbose_leave();"], "readability/braces"]
["src/nvim/undo.c", ["", "  /* If there is no undo information at all, quit here after deleting any", "   * existing undo file. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "  /* Check there is no problem in undo info before writing. */", "  u_check(FALSE);"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  /* Check there is no problem in undo info before writing. */", "  u_check(FALSE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["#ifdef UNIX", "  /*", "   * Try to set the group of the undo file same as the original file. If"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /* Undo must be synced. */", "  u_sync(TRUE);"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  /* Undo must be synced. */", "  u_sync(TRUE);", ""], "readability/bool"]
["src/nvim/undo.c", ["", "  /*", "   * Write the header."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /*", "   * Iteratively serialize UHPs and their UEPs from the top down."], "readability/old_style_comment"]
["src/nvim/undo.c", ["  while (uhp != NULL) {", "    /* Serialize current UHP if we haven't seen it */", "    if (uhp->uh_walk != mark) {"], "readability/old_style_comment"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "      ++headers_written;", "#endif"], "readability/increment"]
["src/nvim/undo.c", ["", "    /* Now walk through the tree - algorithm from undo_time(). */", "    if (uhp->uh_prev.ptr != NULL && uhp->uh_prev.ptr->uh_walk != mark)"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    /* Now walk through the tree - algorithm from undo_time(). */", "    if (uhp->uh_prev.ptr != NULL && uhp->uh_prev.ptr->uh_walk != mark)", "      uhp = uhp->uh_prev.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["      uhp = uhp->uh_prev.ptr;", "    else if (uhp->uh_alt_next.ptr != NULL", "             && uhp->uh_alt_next.ptr->uh_walk != mark)"], "readability/braces"]
["src/nvim/undo.c", ["      uhp = uhp->uh_alt_next.ptr;", "    else if (uhp->uh_next.ptr != NULL && uhp->uh_alt_prev.ptr == NULL", "             && uhp->uh_next.ptr->uh_walk != mark)"], "readability/braces"]
["src/nvim/undo.c", ["      uhp = uhp->uh_next.ptr;", "    else if (uhp->uh_alt_prev.ptr != NULL)", "      uhp = uhp->uh_alt_prev.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["      uhp = uhp->uh_alt_prev.ptr;", "    else", "      uhp = uhp->uh_next.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["  fclose(fp);", "  if (!write_ok)", "    EMSG2(_(\"E829: write error in undo file: %s\"), file_name);"], "readability/braces"]
["src/nvim/undo.c", ["", "    /* For systems that support ACL: get the ACL from the original file. */", "    acl = mch_get_acl(buf->b_ffname);"], "readability/old_style_comment"]
["src/nvim/undo.c", ["theend:", "  if (file_name != name)", "    xfree(file_name);"], "readability/braces"]
["src/nvim/undo.c", ["  if (name == NULL) {", "    file_name = u_get_undo_file_name((char *) curbuf->b_ffname, true);", "    if (file_name == NULL) {"], "whitespace/cast"]
["src/nvim/undo.c", ["  } else {", "    file_name = (char *) name;", "  }"], "whitespace/cast"]
["src/nvim/undo.c", ["      give_warning((char_u *)", "          _(\"File contents changed, cannot use undo info\"), true);", "      if (name == NULL) {"], "whitespace/alignment"]
["src/nvim/undo.c", ["  memset(uhp_table_used, 0, amount);", "# define SET_FLAG(j) ++ uhp_table_used[j]", "#else"], "whitespace/operators"]
["src/nvim/undo.c", ["  // a pointer corresponding to the header with that sequence number.", "  short old_idx = -1, new_idx = -1, cur_idx = -1;", "  for (int i = 0; i < num_head; i++) {"], "runtime/int"]
["src/nvim/undo.c", ["      assert(i <= SHRT_MAX);", "      old_idx = (short)i;", "      SET_FLAG(i);"], "runtime/int"]
["src/nvim/undo.c", ["      assert(i <= SHRT_MAX);", "      new_idx = (short)i;", "      SET_FLAG(i);"], "runtime/int"]
["src/nvim/undo.c", ["      assert(i <= SHRT_MAX);", "      cur_idx = (short)i;", "      SET_FLAG(i);"], "runtime/int"]
["src/nvim/undo.c", ["  xfree(uhp_table_used);", "  u_check(TRUE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["  if (uhp_table != NULL) {", "    for (long i = 0; i < num_read_uhps; i++)", "      if (uhp_table[i] != NULL) {"], "readability/braces"]
["src/nvim/undo.c", ["", "/*", " * If 'cpoptions' contains 'u': Undo the previous undo or redo (vi compatible)."], "readability/old_style_comment"]
["src/nvim/undo.c", ["{", "  /*", "   * If we get an undo command while executing a macro, we behave like the"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  if (curbuf->b_u_synced == false) {", "    u_sync(TRUE);", "    count = 1;"], "readability/bool"]
["src/nvim/undo.c", ["", "/*", " * If 'cpoptions' contains 'u': Repeat the previous undo or redo."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  if (!undo_allowed())", "    return;"], "readability/braces"]
["src/nvim/undo.c", ["  u_oldcount = 0;", "  if (curbuf->b_ml.ml_flags & ML_EMPTY)", "    u_oldcount = -1;"], "readability/braces"]
["src/nvim/undo.c", ["  while (count--) {", "    /* Do the change warning now, so that it triggers FileChangedRO when", "     * needed.  This may cause the file to be reloaded, that must happen"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    if (undo_undoes) {", "      if (curbuf->b_u_curhead == NULL)                  /* first undo */", "        curbuf->b_u_curhead = curbuf->b_u_newhead;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    if (undo_undoes) {", "      if (curbuf->b_u_curhead == NULL)                  /* first undo */", "        curbuf->b_u_curhead = curbuf->b_u_newhead;"], "readability/braces"]
["src/nvim/undo.c", ["        curbuf->b_u_curhead = curbuf->b_u_newhead;", "      else if (get_undolevel() > 0)                     /* multi level undo */", "        /* get next undo */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["        curbuf->b_u_curhead = curbuf->b_u_newhead;", "      else if (get_undolevel() > 0)                     /* multi level undo */", "        /* get next undo */"], "readability/braces"]
["src/nvim/undo.c", ["      else if (get_undolevel() > 0)                     /* multi level undo */", "        /* get next undo */", "        curbuf->b_u_curhead = curbuf->b_u_curhead->uh_next.ptr;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["        curbuf->b_u_curhead = curbuf->b_u_curhead->uh_next.ptr;", "      /* nothing to undo */", "      if (curbuf->b_u_numhead == 0 || curbuf->b_u_curhead == NULL) {"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      if (curbuf->b_u_numhead == 0 || curbuf->b_u_curhead == NULL) {", "        /* stick curbuf->b_u_curhead at end */", "        curbuf->b_u_curhead = curbuf->b_u_oldhead;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      if (curbuf->b_u_curhead == NULL || get_undolevel() <= 0) {", "        beep_flush();           /* nothing to redo */", "        if (count == startcount - 1) {"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "      /* Advance for next redo.  Set \"newhead\" when at the end of the", "       * redoable changes. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["       * redoable changes. */", "      if (curbuf->b_u_curhead->uh_prev.ptr == NULL)", "        curbuf->b_u_newhead = curbuf->b_u_curhead;"], "readability/braces"]
["src/nvim/undo.c", ["", "  /* First make sure the current undoable change is synced. */", "  if (curbuf->b_u_synced == false)"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  /* First make sure the current undoable change is synced. */", "  if (curbuf->b_u_synced == false)", "    u_sync(TRUE);"], "readability/braces"]
["src/nvim/undo.c", ["  if (curbuf->b_u_synced == false)", "    u_sync(TRUE);", ""], "readability/bool"]
["src/nvim/undo.c", ["  u_oldcount = 0;", "  if (curbuf->b_ml.ml_flags & ML_EMPTY)", "    u_oldcount = -1;"], "readability/braces"]
["src/nvim/undo.c", ["", "  /* \"target\" is the node below which we want to be.", "   * Init \"closest\" to a value we can't reach. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      if (step < 0) {", "        /* Going back to a previous write. If there were changes after", "         * the last write, count that as moving one file-write, so"], "readability/old_style_comment"]
["src/nvim/undo.c", ["        uhp = curbuf->b_u_curhead;", "        if (uhp != NULL)", "          uhp = uhp->uh_next.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["          uhp = uhp->uh_next.ptr;", "        else", "          uhp = curbuf->b_u_newhead;"], "readability/braces"]
["src/nvim/undo.c", ["          uhp = curbuf->b_u_newhead;", "        if (uhp != NULL && uhp->uh_save_nr != 0)", "          /* \"uh_save_nr\" was set in the last block, that means"], "readability/braces"]
["src/nvim/undo.c", ["        if (uhp != NULL && uhp->uh_save_nr != 0)", "          /* \"uh_save_nr\" was set in the last block, that means", "           * there were no changes since the last write */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["          target = curbuf->b_u_save_nr_cur + step;", "        else", "          /* count the changes since the last write as one step */"], "readability/braces"]
["src/nvim/undo.c", ["        else", "          /* count the changes since the last write as one step */", "          target = curbuf->b_u_save_nr_cur + step + 1;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["          target = curbuf->b_u_save_nr_cur + step + 1;", "        if (target <= 0)", "          /* Go to before first write: before the oldest change. Use"], "readability/braces"]
["src/nvim/undo.c", ["        if (target <= 0)", "          /* Go to before first write: before the oldest change. Use", "           * the sequence number for that. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      } else {", "        /* Moving forward to a newer write. */", "        target = curbuf->b_u_save_nr_cur + step;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["        if (target > curbuf->b_u_save_nr_last) {", "          /* Go to after last write: after the latest change. Use", "           * the sequence number for that. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      }", "    } else", "      target = curbuf->b_u_seq_cur + step;"], "readability/braces"]
["src/nvim/undo.c", ["    if (step < 0) {", "      if (target < 0)", "        target = 0;"], "readability/braces"]
["src/nvim/undo.c", ["", "  /*", "   * May do this twice:"], "readability/old_style_comment"]
["src/nvim/undo.c", ["   */", "  for (round = 1; round <= 2; ++round) {", "    /* Find the path from the current state to where we want to go.  The"], "readability/increment"]
["src/nvim/undo.c", ["  for (round = 1; round <= 2; ++round) {", "    /* Find the path from the current state to where we want to go.  The", "     * desired state can be anywhere in the undo tree, need to go all over"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "    if (curbuf->b_u_curhead == NULL)            /* at leaf of the tree */", "      uhp = curbuf->b_u_newhead;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "    if (curbuf->b_u_curhead == NULL)            /* at leaf of the tree */", "      uhp = curbuf->b_u_newhead;"], "readability/braces"]
["src/nvim/undo.c", ["      uhp = curbuf->b_u_newhead;", "    else", "      uhp = curbuf->b_u_curhead;"], "readability/braces"]
["src/nvim/undo.c", ["      if (round == 1 && !(dofile && val == 0)) {", "        /* Remember the header that is closest to the target.", "         * It must be at least in the right direction (checked with"], "readability/old_style_comment"]
["src/nvim/undo.c", ["                   ? uhp->uh_seq < closest_seq", "                                   : uhp->uh_seq > closest_seq)", "                : closest == closest_start"], "whitespace/alignment"]
["src/nvim/undo.c", ["                   ? uhp->uh_seq < closest_seq", "                                   : uhp->uh_seq > closest_seq)", "                : closest == closest_start"], "whitespace/alignment"]
["src/nvim/undo.c", ["                   ? uhp->uh_seq < closest_seq", "                                   : uhp->uh_seq > closest_seq)", "                : closest == closest_start"], "whitespace/alignment"]
["src/nvim/undo.c", ["", "      /* Quit searching when we found a match.  But when searching for a", "       * time we need to continue looking for the best uh_seq. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "      /* go down in the tree if we haven't been there */", "      if (uhp->uh_prev.ptr != NULL && uhp->uh_prev.ptr->uh_walk != nomark"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      /* go down in the tree if we haven't been there */", "      if (uhp->uh_prev.ptr != NULL && uhp->uh_prev.ptr->uh_walk != nomark", "          && uhp->uh_prev.ptr->uh_walk != mark)"], "readability/braces"]
["src/nvim/undo.c", ["", "      /* go to alternate branch if we haven't been there */", "      else if (uhp->uh_alt_next.ptr != NULL"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      /* go to alternate branch if we haven't been there */", "      else if (uhp->uh_alt_next.ptr != NULL", "               && uhp->uh_alt_next.ptr->uh_walk != nomark"], "readability/braces"]
["src/nvim/undo.c", ["", "      /* go up in the tree if we haven't been there and we are at the", "       * start of alternate branches */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["       * start of alternate branches */", "      else if (uhp->uh_next.ptr != NULL && uhp->uh_alt_prev.ptr == NULL", "               && uhp->uh_next.ptr->uh_walk != nomark"], "readability/braces"]
["src/nvim/undo.c", ["               && uhp->uh_next.ptr->uh_walk != mark) {", "        /* If still at the start we don't go through this change. */", "        if (uhp == curbuf->b_u_curhead)"], "readability/old_style_comment"]
["src/nvim/undo.c", ["        /* If still at the start we don't go through this change. */", "        if (uhp == curbuf->b_u_curhead)", "          uhp->uh_walk = nomark;"], "readability/braces"]
["src/nvim/undo.c", ["      } else {", "        /* need to backtrack; mark this node as useless */", "        uhp->uh_walk = nomark;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["        uhp->uh_walk = nomark;", "        if (uhp->uh_alt_prev.ptr != NULL)", "          uhp = uhp->uh_alt_prev.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["          uhp = uhp->uh_alt_prev.ptr;", "        else", "          uhp = uhp->uh_next.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["", "    if (uhp != NULL)        /* found it */", "      break;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "    if (uhp != NULL)        /* found it */", "      break;"], "readability/braces"]
["src/nvim/undo.c", ["    if (closest == closest_start) {", "      if (step < 0)", "        MSG(_(\"Already at oldest change\"));"], "readability/braces"]
["src/nvim/undo.c", ["        MSG(_(\"Already at oldest change\"));", "      else", "        MSG(_(\"Already at newest change\"));"], "readability/braces"]
["src/nvim/undo.c", ["    while (!got_int) {", "      /* Do the change warning now, for the same reason as above. */", "      change_warning(0);"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      uhp = curbuf->b_u_curhead;", "      if (uhp == NULL)", "        uhp = curbuf->b_u_newhead;"], "readability/braces"]
["src/nvim/undo.c", ["        uhp = curbuf->b_u_newhead;", "      else", "        uhp = uhp->uh_next.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["", "  /* Don't want autocommands using the undo structures here, they are", "   * invalid till the end. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "  u_check(FALSE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["", "  /*", "   * save marks before undo/redo"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    bot = uep->ue_bot;", "    if (bot == 0)", "      bot = curbuf->b_ml.ml_line_count + 1;"], "readability/braces"]
["src/nvim/undo.c", ["", "    oldsize = bot - top - 1;        /* number of lines before undo */", "    newsize = uep->ue_size;         /* number of lines after undo */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    oldsize = bot - top - 1;        /* number of lines before undo */", "    newsize = uep->ue_size;         /* number of lines after undo */", ""], "readability/old_style_comment"]
["src/nvim/undo.c", ["    if (top < newlnum) {", "      /* If the saved cursor is somewhere in this undo block, move it to", "       * the remembered position.  Makes \"gwap\" put the cursor back"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      } else {", "        /* Use the first line that actually changed.  Avoids that", "         * undoing auto-formatting puts the cursor in the previous"], "readability/old_style_comment"]
["src/nvim/undo.c", ["         * line. */", "        for (i = 0; i < newsize && i < oldsize; ++i)", "          if (STRCMP(uep->ue_array[i], ml_get(top + 1 + i)) != 0)"], "readability/braces"]
["src/nvim/undo.c", ["         * line. */", "        for (i = 0; i < newsize && i < oldsize; ++i)", "          if (STRCMP(uep->ue_array[i], ml_get(top + 1 + i)) != 0)"], "readability/increment"]
["src/nvim/undo.c", ["        for (i = 0; i < newsize && i < oldsize; ++i)", "          if (STRCMP(uep->ue_array[i], ml_get(top + 1 + i)) != 0)", "            break;"], "readability/braces"]
["src/nvim/undo.c", ["", "    /* delete the lines between top and bot and save them in newarray */", "    if (oldsize > 0) {"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      newarray = xmalloc(sizeof(char_u *) * (size_t)oldsize);", "      /* delete backwards, it goes faster in most cases */", "      for (lnum = bot - 1, i = oldsize; --i >= 0; --lnum) {"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      for (lnum = bot - 1, i = oldsize; --i >= 0; --lnum) {", "        /* what can we do when we run out of memory? */", "        newarray[i] = u_save_line(lnum);"], "readability/old_style_comment"]
["src/nvim/undo.c", ["        newarray[i] = u_save_line(lnum);", "        /* remember we deleted the last line in the buffer, and a", "         * dummy empty line will be inserted */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      }", "    } else", "      newarray = NULL;"], "readability/braces"]
["src/nvim/undo.c", ["", "    /* insert the lines in u_array between top and bot */", "    if (newsize) {"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    if (newsize) {", "      for (lnum = top, i = 0; i < newsize; ++i, ++lnum) {", "        /*"], "readability/increment"]
["src/nvim/undo.c", ["      for (lnum = top, i = 0; i < newsize; ++i, ++lnum) {", "        /*", "         * If the file is empty, there is an empty line 1 that we"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "    /* set '[ and '] mark */", "    if (top + 1 < curbuf->b_op_start.lnum)"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    /* set '[ and '] mark */", "    if (top + 1 < curbuf->b_op_start.lnum)", "      curbuf->b_op_start.lnum = top + 1;"], "readability/braces"]
["src/nvim/undo.c", ["      curbuf->b_op_start.lnum = top + 1;", "    if (newsize == 0 && top + 1 > curbuf->b_op_end.lnum)", "      curbuf->b_op_end.lnum = top + 1;"], "readability/braces"]
["src/nvim/undo.c", ["      curbuf->b_op_end.lnum = top + 1;", "    else if (top + newsize > curbuf->b_op_end.lnum)", "      curbuf->b_op_end.lnum = top + newsize;"], "readability/braces"]
["src/nvim/undo.c", ["", "    /*", "     * insert this entry in front of the new entry list"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /*", "   * restore marks from before undo/redo"], "readability/old_style_comment"]
["src/nvim/undo.c", ["   */", "  for (i = 0; i < NMARKS; ++i) {", "    if (curhead->uh_namedm[i].mark.lnum != 0) {"], "readability/increment"]
["src/nvim/undo.c", ["", "  /*", "   * If the cursor is only off by one line, put it at the same position as"], "readability/old_style_comment"]
["src/nvim/undo.c", ["   */", "  if (curhead->uh_cursor.lnum + 1 == curwin->w_cursor.lnum", "      && curwin->w_cursor.lnum > 1)"], "readability/braces"]
["src/nvim/undo.c", ["      && curwin->w_cursor.lnum > 1)", "    --curwin->w_cursor.lnum;", "  if (curwin->w_cursor.lnum <= curbuf->b_ml.ml_line_count) {"], "readability/increment"]
["src/nvim/undo.c", ["      curwin->w_cursor.col = curhead->uh_cursor.col;", "      if (virtual_active() && curhead->uh_cursor_vcol >= 0)", "        coladvance((colnr_T)curhead->uh_cursor_vcol);"], "readability/braces"]
["src/nvim/undo.c", ["        coladvance((colnr_T)curhead->uh_cursor_vcol);", "      else", "        curwin->w_cursor.coladd = 0;"], "readability/braces"]
["src/nvim/undo.c", ["        curwin->w_cursor.coladd = 0;", "    } else", "      beginline(BL_SOL | BL_FIX);"], "readability/braces"]
["src/nvim/undo.c", ["  } else {", "    /* We get here with the current cursor line being past the end (eg", "     * after adding lines at the end of the file, and then undoing it)."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /* Make sure the cursor is on an existing line and column. */", "  check_cursor();"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /* Remember where we are for \"g-\" and \":earlier 10s\". */", "  curbuf->b_u_seq_cur = curhead->uh_seq;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  curbuf->b_u_seq_cur = curhead->uh_seq;", "  if (undo)", "    /* We are below the previous undo.  However, to make \":earlier 1s\""], "readability/braces"]
["src/nvim/undo.c", ["  if (undo)", "    /* We are below the previous undo.  However, to make \":earlier 1s\"", "     * work we compute this as being just above the just undone change. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /* Remember where we are for \":earlier 1f\" and \":later 1f\". */", "  if (curhead->uh_save_nr != 0) {"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  if (curhead->uh_save_nr != 0) {", "    if (undo)", "      curbuf->b_u_save_nr_cur = curhead->uh_save_nr - 1;"], "readability/braces"]
["src/nvim/undo.c", ["      curbuf->b_u_save_nr_cur = curhead->uh_save_nr - 1;", "    else", "      curbuf->b_u_save_nr_cur = curhead->uh_save_nr;"], "readability/braces"]
["src/nvim/undo.c", ["", "  /* The timestamp can be the same for multiple changes, just use the one of", "   * the undone/redone change. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "  u_check(FALSE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["", "  if ((fdo_flags & FDO_UNDO) && KeyTyped)", "    foldOpenCursor();"], "readability/braces"]
["src/nvim/undo.c", ["", "  if (curbuf->b_ml.ml_flags & ML_EMPTY)", "    --u_newcount;"], "readability/braces"]
["src/nvim/undo.c", ["  if (curbuf->b_ml.ml_flags & ML_EMPTY)", "    --u_newcount;", ""], "readability/increment"]
["src/nvim/undo.c", ["  u_oldcount -= u_newcount;", "  if (u_oldcount == -1)", "    msgstr = N_(\"more line\");"], "readability/braces"]
["src/nvim/undo.c", ["    msgstr = N_(\"more line\");", "  else if (u_oldcount < 0)", "    msgstr = N_(\"more lines\");"], "readability/braces"]
["src/nvim/undo.c", ["    msgstr = N_(\"more lines\");", "  else if (u_oldcount == 1)", "    msgstr = N_(\"line less\");"], "readability/braces"]
["src/nvim/undo.c", ["    msgstr = N_(\"line less\");", "  else if (u_oldcount > 1)", "    msgstr = N_(\"fewer lines\");"], "readability/braces"]
["src/nvim/undo.c", ["    msgstr = N_(\"fewer lines\");", "  else {", "    u_oldcount = u_newcount;"], "readability/braces"]
["src/nvim/undo.c", ["    msgstr = N_(\"fewer lines\");", "  else {", "    u_oldcount = u_newcount;"], "readability/braces"]
["src/nvim/undo.c", ["    u_oldcount = u_newcount;", "    if (u_newcount == 1)", "      msgstr = N_(\"change\");"], "readability/braces"]
["src/nvim/undo.c", ["      msgstr = N_(\"change\");", "    else", "      msgstr = N_(\"changes\");"], "readability/braces"]
["src/nvim/undo.c", ["  if (curbuf->b_u_curhead != NULL) {", "    /* For \":undo N\" we prefer a \"after #N\" message. */", "    if (absolute && curbuf->b_u_curhead->uh_next.ptr != NULL) {"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * u_sync: stop adding to the current entry list"], "readability/old_style_comment"]
["src/nvim/undo.c", ["{", "  /* Skip it when already synced or syncing is disabled. */", "  if (curbuf->b_u_synced || (!force && no_u_sync > 0))"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  /* Skip it when already synced or syncing is disabled. */", "  if (curbuf->b_u_synced || (!force && no_u_sync > 0))", "    return;"], "readability/braces"]
["src/nvim/undo.c", ["    return;", "  if (get_undolevel() < 0)", "    curbuf->b_u_synced = true;      /* no entries, nothing to do */"], "readability/braces"]
["src/nvim/undo.c", ["  if (get_undolevel() < 0)", "    curbuf->b_u_synced = true;      /* no entries, nothing to do */", "  else {"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    curbuf->b_u_synced = true;      /* no entries, nothing to do */", "  else {", "    u_getbot();                     /* compute ue_bot of previous u_save */"], "readability/braces"]
["src/nvim/undo.c", ["    curbuf->b_u_synced = true;      /* no entries, nothing to do */", "  else {", "    u_getbot();                     /* compute ue_bot of previous u_save */"], "readability/braces"]
["src/nvim/undo.c", ["  else {", "    u_getbot();                     /* compute ue_bot of previous u_save */", "    curbuf->b_u_curhead = NULL;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * \":undolist\": List the leafs of the undo tree"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /*", "   * 1: walk the tree to find all leafs, put the info in \"ga\"."], "readability/old_style_comment"]
["src/nvim/undo.c", ["      if (uhp->uh_save_nr > 0) {", "        while (STRLEN(IObuff) < 33)", "          STRCAT(IObuff, \" \");"], "readability/braces"]
["src/nvim/undo.c", ["        vim_snprintf_add((char *)IObuff, IOSIZE,", "            \"  %3ld\", uhp->uh_save_nr);", "      }"], "whitespace/alignment"]
["src/nvim/undo.c", ["", "    /* go down in the tree if we haven't been there */", "    if (uhp->uh_prev.ptr != NULL && uhp->uh_prev.ptr->uh_walk != nomark"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      uhp = uhp->uh_prev.ptr;", "      ++changes;", "    }"], "readability/increment"]
["src/nvim/undo.c", ["    }", "    /* go to alternate branch if we haven't been there */", "    else if (uhp->uh_alt_next.ptr != NULL"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    /* go to alternate branch if we haven't been there */", "    else if (uhp->uh_alt_next.ptr != NULL", "             && uhp->uh_alt_next.ptr->uh_walk != nomark"], "whitespace/newline"]
["src/nvim/undo.c", ["", "    /* go up in the tree if we haven't been there and we are at the", "     * start of alternate branches */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["     * start of alternate branches */", "    else if (uhp->uh_next.ptr != NULL && uhp->uh_alt_prev.ptr == NULL", "             && uhp->uh_next.ptr->uh_walk != nomark"], "readability/braces"]
["src/nvim/undo.c", ["      uhp = uhp->uh_next.ptr;", "      --changes;", "    } else {"], "readability/increment"]
["src/nvim/undo.c", ["    } else {", "      /* need to backtrack; mark this node as done */", "      uhp->uh_walk = nomark;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      uhp->uh_walk = nomark;", "      if (uhp->uh_alt_prev.ptr != NULL)", "        uhp = uhp->uh_alt_prev.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["        uhp = uhp->uh_alt_prev.ptr;", "      else {", "        uhp = uhp->uh_next.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["        uhp = uhp->uh_alt_prev.ptr;", "      else {", "        uhp = uhp->uh_next.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["        uhp = uhp->uh_next.ptr;", "        --changes;", "      }"], "readability/increment"]
["src/nvim/undo.c", ["", "  if (GA_EMPTY(&ga))", "    MSG(_(\"Nothing to undo\"));"], "readability/braces"]
["src/nvim/undo.c", ["    MSG(_(\"Nothing to undo\"));", "  else {", "    sort_strings((char_u **)ga.ga_data, ga.ga_len);"], "readability/braces"]
["src/nvim/undo.c", ["    MSG(_(\"Nothing to undo\"));", "  else {", "    sort_strings((char_u **)ga.ga_data, ga.ga_len);"], "readability/braces"]
["src/nvim/undo.c", ["", "/*", " * \":undojoin\": continue adding to the last entry list"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Called after writing or reloading the file and setting b_changed to FALSE."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * After reloading a buffer which was saved for 'undoreload': Find the first"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  if (curbuf->b_u_curhead != NULL || uhp == NULL)", "    return;      /* undid something in an autocmd? */"], "readability/braces"]
["src/nvim/undo.c", ["  if (curbuf->b_u_curhead != NULL || uhp == NULL)", "    return;      /* undid something in an autocmd? */", ""], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /* Check that the last undo block was for the whole file. */", "  uep = uhp->uh_entry;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  uep = uhp->uh_entry;", "  if (uep->ue_top != 0 || uep->ue_bot != 0)", "    return;"], "readability/braces"]
["src/nvim/undo.c", ["", "  for (lnum = 1; lnum < curbuf->b_ml.ml_line_count", "       && lnum <= uep->ue_size; ++lnum)"], "readability/braces"]
["src/nvim/undo.c", ["  for (lnum = 1; lnum < curbuf->b_ml.ml_line_count", "       && lnum <= uep->ue_size; ++lnum)", "    if (STRCMP(ml_get_buf(curbuf, lnum, FALSE),"], "readability/increment"]
["src/nvim/undo.c", ["    if (STRCMP(ml_get_buf(curbuf, lnum, FALSE),", "            uep->ue_array[lnum - 1]) != 0) {", "      clearpos(&(uhp->uh_cursor));"], "whitespace/alignment"]
["src/nvim/undo.c", ["       && lnum <= uep->ue_size; ++lnum)", "    if (STRCMP(ml_get_buf(curbuf, lnum, FALSE),", "            uep->ue_array[lnum - 1]) != 0) {"], "readability/bool"]
["src/nvim/undo.c", ["  if (curbuf->b_ml.ml_line_count != uep->ue_size) {", "    /* lines added or deleted at the end, put the cursor there */", "    clearpos(&(uhp->uh_cursor));"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Increase the write count, store it in the last undo header, what would be"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  ++buf->b_u_save_nr_last;", "  buf->b_u_save_nr_cur = buf->b_u_save_nr_last;"], "readability/increment"]
["src/nvim/undo.c", ["  uhp = buf->b_u_curhead;", "  if (uhp != NULL)", "    uhp = uhp->uh_next.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["    uhp = uhp->uh_next.ptr;", "  else", "    uhp = buf->b_u_newhead;"], "readability/braces"]
["src/nvim/undo.c", ["    uhp = buf->b_u_newhead;", "  if (uhp != NULL)", "    uhp->uh_save_nr = buf->b_u_save_nr_last;"], "readability/braces"]
["src/nvim/undo.c", ["    uh->uh_flags |= UH_CHANGED;", "    if (uh->uh_alt_next.ptr != NULL)", "      u_unch_branch(uh->uh_alt_next.ptr);           /* recursive */"], "readability/braces"]
["src/nvim/undo.c", ["    if (uh->uh_alt_next.ptr != NULL)", "      u_unch_branch(uh->uh_alt_next.ptr);           /* recursive */", "  }"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Get pointer to last added entry."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * u_getbot(): compute the line number of the previous u_save"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  uep = u_get_headentry();      /* check for corrupt undo list */", "  if (uep == NULL)"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  uep = u_get_headentry();      /* check for corrupt undo list */", "  if (uep == NULL)", "    return;"], "readability/braces"]
["src/nvim/undo.c", ["  if (uep != NULL) {", "    /*", "     * the new ue_bot is computed from the number of lines that has been"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Free one header \"uhp\" and its entry list and adjust the pointers."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /* When there is an alternate redo list free that branch completely,", "   * because we can never go there. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["   * because we can never go there. */", "  if (uhp->uh_alt_next.ptr != NULL)", "    u_freebranch(buf, uhp->uh_alt_next.ptr, uhpp);"], "readability/braces"]
["src/nvim/undo.c", ["", "  if (uhp->uh_alt_prev.ptr != NULL)", "    uhp->uh_alt_prev.ptr->uh_alt_next.ptr = NULL;"], "readability/braces"]
["src/nvim/undo.c", ["", "  /* Update the links in the list to remove the header. */", "  if (uhp->uh_next.ptr == NULL)"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  /* Update the links in the list to remove the header. */", "  if (uhp->uh_next.ptr == NULL)", "    buf->b_u_oldhead = uhp->uh_prev.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["    buf->b_u_oldhead = uhp->uh_prev.ptr;", "  else", "    uhp->uh_next.ptr->uh_prev.ptr = uhp->uh_prev.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["", "  if (uhp->uh_prev.ptr == NULL)", "    buf->b_u_newhead = uhp->uh_next.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["    buf->b_u_newhead = uhp->uh_next.ptr;", "  else", "    for (uhap = uhp->uh_prev.ptr; uhap != NULL;"], "readability/braces"]
["src/nvim/undo.c", ["  else", "    for (uhap = uhp->uh_prev.ptr; uhap != NULL;", "         uhap = uhap->uh_alt_next.ptr)"], "readability/braces"]
["src/nvim/undo.c", ["", "/*", " * Free an alternate branch and any following alternate branches."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /* If this is the top branch we may need to use u_freeheader() to update", "   * all the pointers. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  if (uhp == buf->b_u_oldhead) {", "    while (buf->b_u_oldhead != NULL)", "      u_freeheader(buf, buf->b_u_oldhead, uhpp);"], "readability/braces"]
["src/nvim/undo.c", ["", "  if (uhp->uh_alt_prev.ptr != NULL)", "    uhp->uh_alt_prev.ptr->uh_alt_next.ptr = NULL;"], "readability/braces"]
["src/nvim/undo.c", ["    tofree = next;", "    if (tofree->uh_alt_next.ptr != NULL)", "      u_freebranch(buf, tofree->uh_alt_next.ptr, uhpp);         /* recursive */"], "readability/braces"]
["src/nvim/undo.c", ["    if (tofree->uh_alt_next.ptr != NULL)", "      u_freebranch(buf, tofree->uh_alt_next.ptr, uhpp);         /* recursive */", "    next = tofree->uh_prev.ptr;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Free all the undo entries for one header and the header itself."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /* Check for pointers to the header that become invalid now. */", "  if (buf->b_u_curhead == uhp)"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  /* Check for pointers to the header that become invalid now. */", "  if (buf->b_u_curhead == uhp)", "    buf->b_u_curhead = NULL;"], "readability/braces"]
["src/nvim/undo.c", ["    buf->b_u_curhead = NULL;", "  if (buf->b_u_newhead == uhp)", "    buf->b_u_newhead = NULL;      /* freeing the newest entry */"], "readability/braces"]
["src/nvim/undo.c", ["  if (buf->b_u_newhead == uhp)", "    buf->b_u_newhead = NULL;      /* freeing the newest entry */", "  if (uhpp != NULL && uhp == *uhpp)"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    buf->b_u_newhead = NULL;      /* freeing the newest entry */", "  if (uhpp != NULL && uhp == *uhpp)", "    *uhpp = NULL;"], "readability/braces"]
["src/nvim/undo.c", ["  xfree((char_u *)uhp);", "  --buf->b_u_numhead;", "}"], "readability/increment"]
["src/nvim/undo.c", ["", "/*", " * free entry 'uep' and 'n' lines in uep->ue_array[]"], "readability/old_style_comment"]
["src/nvim/undo.c", ["{", "  while (n > 0)", "    xfree(uep->ue_array[--n]);"], "readability/braces"]
["src/nvim/undo.c", ["", "/*", " * invalidate the undo buffer; called when storage has already been released"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * save the line \"lnum\" for the \"U\" command"], "readability/old_style_comment"]
["src/nvim/undo.c", ["{", "  if (lnum == curbuf->b_u_line_lnum)        /* line is already saved */", "    return;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["{", "  if (lnum == curbuf->b_u_line_lnum)        /* line is already saved */", "    return;"], "readability/braces"]
["src/nvim/undo.c", ["    return;", "  if (lnum < 1 || lnum > curbuf->b_ml.ml_line_count)   /* should never happen */", "    return;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    return;", "  if (lnum < 1 || lnum > curbuf->b_ml.ml_line_count)   /* should never happen */", "    return;"], "readability/braces"]
["src/nvim/undo.c", ["  curbuf->b_u_line_lnum = lnum;", "  if (curwin->w_cursor.lnum == lnum)", "    curbuf->b_u_line_colnr = curwin->w_cursor.col;"], "readability/braces"]
["src/nvim/undo.c", ["    curbuf->b_u_line_colnr = curwin->w_cursor.col;", "  else", "    curbuf->b_u_line_colnr = 0;"], "readability/braces"]
["src/nvim/undo.c", ["", "/*", " * clear the line saved for the \"U\" command"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Implementation of the \"U\" command."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /* first save the line for the 'u' command */", "  if (u_savecommon(curbuf->b_u_line_lnum - 1,"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  /* first save the line for the 'u' command */", "  if (u_savecommon(curbuf->b_u_line_lnum - 1,", "          curbuf->b_u_line_lnum + 1, (linenr_T)0, FALSE) == FAIL)"], "readability/braces"]
["src/nvim/undo.c", ["  if (u_savecommon(curbuf->b_u_line_lnum - 1,", "          curbuf->b_u_line_lnum + 1, (linenr_T)0, FALSE) == FAIL)", "    return;"], "whitespace/alignment"]
["src/nvim/undo.c", ["  if (u_savecommon(curbuf->b_u_line_lnum - 1,", "          curbuf->b_u_line_lnum + 1, (linenr_T)0, FALSE) == FAIL)", "    return;"], "readability/bool"]
["src/nvim/undo.c", ["  t = curbuf->b_u_line_colnr;", "  if (curwin->w_cursor.lnum == curbuf->b_u_line_lnum)", "    curbuf->b_u_line_colnr = curwin->w_cursor.col;"], "readability/braces"]
["src/nvim/undo.c", ["", "/*", " * Free all allocated memory blocks for the buffer 'buf'."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * u_save_line(): allocate memory and copy line 'lnum' into it."], "readability/old_style_comment"]
["src/nvim/undo_defs.h", ["", "#endif // NVIM_UNDO_DEFS_H", ""], "build/header_guard"]
["src/nvim/undo_defs.h", ["", "/* Structure to store info about the Visual area. */", "typedef struct {"], "readability/old_style_comment"]
["src/nvim/undo_defs.h", ["typedef struct {", "  pos_T vi_start;               /* start pos of last VIsual */", "  pos_T vi_end;                 /* end position of last VIsual */"], "readability/old_style_comment"]
["src/nvim/undo_defs.h", ["  pos_T vi_start;               /* start pos of last VIsual */", "  pos_T vi_end;                 /* end position of last VIsual */", "  int vi_mode;                  /* VIsual_mode of last VIsual */"], "readability/old_style_comment"]
["src/nvim/undo_defs.h", ["  pos_T vi_end;                 /* end position of last VIsual */", "  int vi_mode;                  /* VIsual_mode of last VIsual */", "  colnr_T vi_curswant;          /* MAXCOL from w_curswant */"], "readability/old_style_comment"]
["src/nvim/undo_defs.h", ["  int vi_mode;                  /* VIsual_mode of last VIsual */", "  colnr_T vi_curswant;          /* MAXCOL from w_curswant */", "} visualinfo_T;"], "readability/old_style_comment"]
["src/nvim/undo_defs.h", ["struct u_entry {", "  u_entry_T   *ue_next;         /* pointer to next entry in list */", "  linenr_T ue_top;              /* number of line above undo block */"], "readability/old_style_comment"]
["src/nvim/undo_defs.h", ["  u_entry_T   *ue_next;         /* pointer to next entry in list */", "  linenr_T ue_top;              /* number of line above undo block */", "  linenr_T ue_bot;              /* number of line below undo block */"], "readability/old_style_comment"]
["src/nvim/undo_defs.h", ["  linenr_T ue_top;              /* number of line above undo block */", "  linenr_T ue_bot;              /* number of line below undo block */", "  linenr_T ue_lcount;           /* linecount when u_save called */"], "readability/old_style_comment"]
["src/nvim/undo_defs.h", ["  linenr_T ue_bot;              /* number of line below undo block */", "  linenr_T ue_lcount;           /* linecount when u_save called */", "  char_u      **ue_array;       /* array of lines in undo block */"], "readability/old_style_comment"]
["src/nvim/undo_defs.h", ["  linenr_T ue_lcount;           /* linecount when u_save called */", "  char_u      **ue_array;       /* array of lines in undo block */", "  long ue_size;                 /* number of lines in ue_array */"], "readability/old_style_comment"]
["src/nvim/undo_defs.h", ["  char_u      **ue_array;       /* array of lines in undo block */", "  long ue_size;                 /* number of lines in ue_array */", "#ifdef U_DEBUG"], "readability/old_style_comment"]
["src/nvim/undo_defs.h", ["#ifdef U_DEBUG", "  int ue_magic;                 /* magic number to check allocation */", "#endif"], "readability/old_style_comment"]
["src/nvim/undo_defs.h", ["struct u_header {", "  /* The following have a pointer and a number. The number is used when", "   * reading the undo file in u_read_undo() */"], "readability/old_style_comment"]
["src/nvim/undo_defs.h", ["  union {", "    u_header_T *ptr;            /* pointer to next undo header in list */", "    long seq;"], "readability/old_style_comment"]
["src/nvim/undo_defs.h", ["  union {", "    u_header_T *ptr;            /* pointer to previous header in list */", "    long seq;"], "readability/old_style_comment"]
["src/nvim/undo_defs.h", ["  union {", "    u_header_T *ptr;            /* pointer to next header for alt. redo */", "    long seq;"], "readability/old_style_comment"]
["src/nvim/undo_defs.h", ["  union {", "    u_header_T *ptr;            /* pointer to previous header for alt. redo */", "    long seq;"], "readability/old_style_comment"]
["src/nvim/undo_defs.h", ["  } uh_alt_prev;", "  long uh_seq;                  /* sequence number, higher == newer undo */", "  int uh_walk;                  /* used by undo_time() */"], "readability/old_style_comment"]
["src/nvim/undo_defs.h", ["  long uh_seq;                  /* sequence number, higher == newer undo */", "  int uh_walk;                  /* used by undo_time() */", "  u_entry_T   *uh_entry;        /* pointer to first entry */"], "readability/old_style_comment"]
["src/nvim/undo_defs.h", ["  int uh_walk;                  /* used by undo_time() */", "  u_entry_T   *uh_entry;        /* pointer to first entry */", "  u_entry_T   *uh_getbot_entry;   /* pointer to where ue_bot must be set */"], "readability/old_style_comment"]
["src/nvim/undo_defs.h", ["  u_entry_T   *uh_entry;        /* pointer to first entry */", "  u_entry_T   *uh_getbot_entry;   /* pointer to where ue_bot must be set */", "  pos_T uh_cursor;              /* cursor position before saving */"], "readability/old_style_comment"]
["src/nvim/undo_defs.h", ["  u_entry_T   *uh_getbot_entry;   /* pointer to where ue_bot must be set */", "  pos_T uh_cursor;              /* cursor position before saving */", "  long uh_cursor_vcol;"], "readability/old_style_comment"]
["src/nvim/undo_defs.h", ["", "#endif // NVIM_UNDO_DEFS_H", ""], "whitespace/comments"]
["src/nvim/version.c", ["", "Dictionary version_dict(void) {", "  Dictionary d = ARRAY_DICT_INIT;"], "readability/braces"]
["src/nvim/version.c", ["      && (vim_strchr(p_shm, SHM_INTRO) == NULL)) {", "    intro_message(FALSE);", "  }"], "readability/bool"]
["src/nvim/version.c", ["  if (((row >= 2) && (Columns >= 50)) || colon) {", "    for (i = 0; i < (int)ARRAY_SIZE(lines); ++i) {", "      p = lines[i];"], "readability/increment"]
["src/nvim/version.c", ["  screenclear();", "  intro_message(TRUE);", "  wait_return(TRUE);"], "readability/bool"]
["src/nvim/version.c", ["  intro_message(TRUE);", "  wait_return(TRUE);", "}"], "readability/bool"]
["src/nvim/version.h", ["// defined in version.c", "extern char* Version;", "extern char* longVersion;"], "whitespace/operators"]
["src/nvim/version.h", ["extern char* Version;", "extern char* longVersion;", ""], "whitespace/operators"]
["src/nvim/vim.h", ["", "#ifndef TRUE", "# define FALSE  0           // note: this is an int, not a long!"], "readability/bool"]
["src/nvim/vim.h", ["#ifndef TRUE", "# define FALSE  0           // note: this is an int, not a long!", "# define TRUE   1"], "readability/bool"]
["src/nvim/vim.h", ["# define FALSE  0           // note: this is an int, not a long!", "# define TRUE   1", "#endif"], "readability/bool"]
["src/nvim/vim.h", ["", "#define MAYBE   2           // sometimes used for a variant on TRUE", ""], "readability/bool"]
["src/nvim/vim.h", ["#define STRLEN(s)           strlen((char *)(s))", "#define STRCPY(d, s)        strcpy((char *)(d), (char *)(s))", "#define STRNCPY(d, s, n)    strncpy((char *)(d), (char *)(s), (size_t)(n))"], "runtime/printf"]
["src/nvim/vim.h", ["#define STRCPY(d, s)        strcpy((char *)(d), (char *)(s))", "#define STRNCPY(d, s, n)    strncpy((char *)(d), (char *)(s), (size_t)(n))", "#define STRLCPY(d, s, n)    xstrlcpy((char *)(d), (char *)(s), (size_t)(n))"], "runtime/printf"]
["src/nvim/vim.h", ["", "#define STRCAT(d, s)        strcat((char *)(d), (char *)(s))", "#define STRNCAT(d, s, n)    strncat((char *)(d), (char *)(s), (size_t)(n))"], "runtime/printf"]
["src/nvim/vim.h", ["#define STRCAT(d, s)        strcat((char *)(d), (char *)(s))", "#define STRNCAT(d, s, n)    strncat((char *)(d), (char *)(s), (size_t)(n))", "#define STRLCAT(d, s, n)    xstrlcat((char *)(d), (char *)(s), (size_t)(n))"], "runtime/printf"]
["src/nvim/window.c", ["", "#define NOWIN           (win_T *)-1     /* non-existing window */", ""], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * all CTRL-W window commands are handled here, called from normal_cmd()."], "readability/old_style_comment"]
["src/nvim/window.c", ["    long Prenum,", "    int xchar                  /* extra char from \":wincmd gx\" or NUL */", ")"], "readability/old_style_comment"]
["src/nvim/window.c", ["  switch (nchar) {", "  /* split current window in two parts, horizontally */", "  case 'S':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* split current window in two parts, vertically */", "  case Ctrl_V:"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* split current window and edit alternate file */", "  case Ctrl_HAT:"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* open new window */", "  case Ctrl_N:"], "readability/old_style_comment"]
["src/nvim/window.c", ["newwindow:", "    if (Prenum)", "      /* window height */"], "readability/braces"]
["src/nvim/window.c", ["    if (Prenum)", "      /* window height */", "      vim_snprintf(cbuf, sizeof(cbuf) - 5, \"%\" PRId64, (int64_t)Prenum);"], "readability/old_style_comment"]
["src/nvim/window.c", ["      vim_snprintf(cbuf, sizeof(cbuf) - 5, \"%\" PRId64, (int64_t)Prenum);", "    else", "      cbuf[0] = NUL;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* quit current window */", "  case Ctrl_Q:"], "readability/old_style_comment"]
["src/nvim/window.c", ["  case 'q':", "    reset_VIsual_and_resel();                   /* stop Visual mode */", "    cmd_with_count(\"quit\", (char_u *)cbuf, sizeof(cbuf), Prenum);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* close current window */", "  case Ctrl_C:"], "readability/old_style_comment"]
["src/nvim/window.c", ["  case 'c':", "    reset_VIsual_and_resel();                   /* stop Visual mode */", "    cmd_with_count(\"close\", (char_u *)cbuf, sizeof(cbuf), Prenum);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* close preview window */", "  case Ctrl_Z:"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* cursor to preview window */", "  case 'P':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* close all but current window */", "  case Ctrl_O:"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* cursor to next window with wrap around */", "  case Ctrl_W:"], "readability/old_style_comment"]
["src/nvim/window.c", ["  case 'w':", "  /* cursor to previous window with wrap around */", "  case 'W':"], "readability/old_style_comment"]
["src/nvim/window.c", ["        for (wp = firstwin; --Prenum > 0; ) {", "          if (wp->w_next == NULL)", "            break;"], "readability/braces"]
["src/nvim/window.c", ["            break;", "          else", "            wp = wp->w_next;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* cursor to window below */", "  case 'j':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* cursor to window above */", "  case 'k':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* cursor to left window */", "  case 'h':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* cursor to right window */", "  case 'l':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* move window to new tab page */", "  case 'T':"], "readability/old_style_comment"]
["src/nvim/window.c", ["  case 'T':", "    if (one_window())", "      MSG(_(m_onlyone));"], "readability/braces"]
["src/nvim/window.c", ["      MSG(_(m_onlyone));", "    else {", "      tabpage_T   *oldtab = curtab;"], "readability/braces"]
["src/nvim/window.c", ["      MSG(_(m_onlyone));", "    else {", "      tabpage_T   *oldtab = curtab;"], "readability/braces"]
["src/nvim/window.c", ["", "      /* First create a new tab with the window, then go back to", "       * the old tab and close the window there. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* cursor to top-left window */", "  case 't':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* cursor to bottom-right window */", "  case 'b':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* cursor to last accessed (previous) window */", "  case 'p':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* exchange current and next window */", "  case 'x':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* rotate windows downwards */", "  case Ctrl_R:"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* rotate windows upwards */", "  case 'R':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* move window to the very top/bottom/left/right */", "  case 'K':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* make all windows the same height */", "  case '=':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* increase current window height */", "  case '+':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* decrease current window height */", "  case '-':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* set current window height */", "  case Ctrl__:"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* increase current window width */", "  case '>':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* decrease current window width */", "  case '<':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* set current window width */", "  case '|':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* jump to tag and split window if tag exists (in preview window) */", "  case '}':"], "readability/old_style_comment"]
["src/nvim/window.c", ["    // Keep visual mode, can select words to use as a tag.", "    if (Prenum)", "      postponed_split = Prenum;"], "readability/braces"]
["src/nvim/window.c", ["      postponed_split = Prenum;", "    else", "      postponed_split = -1;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* edit file name under cursor in a new window */", "  case 'f':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Go to the first occurrence of the identifier under cursor along path in a", "   * new window -- webb"], "readability/old_style_comment"]
["src/nvim/window.c", ["   */", "  case 'i':                         /* Go to any match */", "  case Ctrl_I:"], "readability/old_style_comment"]
["src/nvim/window.c", ["                         type, Prenum1, ACTION_SPLIT, 1, MAXLNUM);", "    curwin->w_set_curswant = TRUE;", "    break;"], "readability/bool"]
["src/nvim/window.c", ["", "  /* CTRL-W g  extended commands */", "  case 'g':"], "readability/old_style_comment"]
["src/nvim/window.c", ["      xchar = Ctrl_RSB;", "      if (Prenum)", "        g_do_tagpreview = Prenum;"], "readability/braces"]
["src/nvim/window.c", ["        g_do_tagpreview = Prenum;", "      else", "        g_do_tagpreview = p_pvh;"], "readability/braces"]
["src/nvim/window.c", ["      // Keep visual mode, can select words to use as a tag.", "      if (Prenum)", "        postponed_split = Prenum;"], "readability/braces"]
["src/nvim/window.c", ["        postponed_split = Prenum;", "      else", "        postponed_split = -1;"], "readability/braces"]
["src/nvim/window.c", ["", "      /* Execute the command right here, required when", "       * \"wincmd g}\" was used in a function. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    case 'f':                       /* CTRL-W gf: \"gf\" in a new tab page */", "    case 'F':                       /* CTRL-W gF: \"gF\" in a new tab page */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    case 'f':                       /* CTRL-W gf: \"gf\" in a new tab page */", "    case 'F':                       /* CTRL-W gF: \"gF\" in a new tab page */", "      cmdmod.tab = tabpage_index(curtab) + 1;"], "readability/old_style_comment"]
["src/nvim/window.c", ["  }", "", "}"], "whitespace/blank_line"]
["src/nvim/window.c", ["", "/*", " * split the current window, implements CTRL-W s and :split"], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  /* When the \":tab\" modifier was used open a new tab page instead. */", "  if (may_open_tabpage() == OK)"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* When the \":tab\" modifier was used open a new tab page instead. */", "  if (may_open_tabpage() == OK)", "    return OK;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* Add flags from \":vertical\", \":topleft\" and \":botright\". */", "  flags |= cmdmod.split;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* When creating the help window make a snapshot of the window layout.", "   * Otherwise clear the snapshot, it's now invalid. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["   * Otherwise clear the snapshot, it's now invalid. */", "  if (flags & WSP_HELP)", "    make_snapshot(SNAP_HELP_IDX);"], "readability/braces"]
["src/nvim/window.c", ["    make_snapshot(SNAP_HELP_IDX);", "  else", "    clear_snapshot(curtab, SNAP_HELP_IDX);"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * When \"new_wp\" is NULL: split the current window in two."], "readability/old_style_comment"]
["src/nvim/window.c", ["  int need_status = 0;", "  int do_equal = FALSE;", "  int needed;"], "readability/bool"]
["src/nvim/window.c", ["", "    /*", "     * Check if we are able to split the current window and compute its"], "readability/old_style_comment"]
["src/nvim/window.c", ["    }", "    if (new_size == 0)", "      new_size = oldwin->w_width / 2;"], "readability/braces"]
["src/nvim/window.c", ["", "    /* if it doesn't fit in the current window, need win_equal() */", "    if (oldwin->w_width - new_size - 1 < p_wmw)"], "readability/old_style_comment"]
["src/nvim/window.c", ["    /* if it doesn't fit in the current window, need win_equal() */", "    if (oldwin->w_width - new_size - 1 < p_wmw)", "      do_equal = TRUE;"], "readability/braces"]
["src/nvim/window.c", ["    if (oldwin->w_width - new_size - 1 < p_wmw)", "      do_equal = TRUE;", ""], "readability/bool"]
["src/nvim/window.c", ["", "    /* Only make all windows the same width if one of them (except oldwin)", "     * is wider than one of the split windows. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["                || frp->fr_win->w_width > oldwin->w_width", "                                          - new_size - 1)) {", "          do_equal = TRUE;"], "whitespace/alignment"]
["src/nvim/window.c", ["                || frp->fr_win->w_width > oldwin->w_width", "                                          - new_size - 1)) {", "          do_equal = TRUE;"], "whitespace/alignment"]
["src/nvim/window.c", ["                                          - new_size - 1)) {", "          do_equal = TRUE;", "          break;"], "readability/bool"]
["src/nvim/window.c", ["", "    /*", "     * Check if we are able to split the current window and compute its"], "readability/old_style_comment"]
["src/nvim/window.c", ["    }", "    if (new_size == 0)", "      new_size = oldwin_height / 2;"], "readability/braces"]
["src/nvim/window.c", ["", "    /* if it doesn't fit in the current window, need win_equal() */", "    if (oldwin_height - new_size - STATUS_HEIGHT < p_wmh)"], "readability/old_style_comment"]
["src/nvim/window.c", ["    /* if it doesn't fit in the current window, need win_equal() */", "    if (oldwin_height - new_size - STATUS_HEIGHT < p_wmh)", "      do_equal = TRUE;"], "readability/braces"]
["src/nvim/window.c", ["    if (oldwin_height - new_size - STATUS_HEIGHT < p_wmh)", "      do_equal = TRUE;", ""], "readability/bool"]
["src/nvim/window.c", ["", "    /* We don't like to take lines for the new window from a", "     * 'winfixheight' window.  Take them from a window above or below"], "readability/old_style_comment"]
["src/nvim/window.c", ["      win_setheight_win(oldwin->w_height + new_size + STATUS_HEIGHT,", "          oldwin);", "      oldwin_height = oldwin->w_height;"], "whitespace/alignment"]
["src/nvim/window.c", ["      oldwin_height = oldwin->w_height;", "      if (need_status)", "        oldwin_height -= STATUS_HEIGHT;"], "readability/braces"]
["src/nvim/window.c", ["", "    /* Only make all windows the same height if one of them (except oldwin)", "     * is higher than one of the split windows. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["                - STATUS_HEIGHT)) {", "          do_equal = TRUE;", "          break;"], "readability/bool"]
["src/nvim/window.c", ["", "  /*", "   * allocate new window structure and link it in the window list"], "readability/old_style_comment"]
["src/nvim/window.c", ["              && (", "                (flags & WSP_VERT) ? p_spr :", "                p_sb)))) {"], "whitespace/indent"]
["src/nvim/window.c", ["                (flags & WSP_VERT) ? p_spr :", "                p_sb)))) {", "    /* new window below/right of current one */"], "whitespace/indent"]
["src/nvim/window.c", ["              && (", "                (flags & WSP_VERT) ? p_spr :", "                p_sb)))) {"], "whitespace/indent"]
["src/nvim/window.c", ["                (flags & WSP_VERT) ? p_spr :", "                p_sb)))) {", "    /* new window below/right of current one */"], "whitespace/indent"]
["src/nvim/window.c", ["              && (", "                (flags & WSP_VERT) ? p_spr :", "                p_sb)))) {"], "whitespace/indent"]
["src/nvim/window.c", ["                (flags & WSP_VERT) ? p_spr :", "                p_sb)))) {", "    /* new window below/right of current one */"], "whitespace/indent"]
["src/nvim/window.c", ["              && (", "                (flags & WSP_VERT) ? p_spr :", "                p_sb)))) {"], "whitespace/indent"]
["src/nvim/window.c", ["                (flags & WSP_VERT) ? p_spr :", "                p_sb)))) {", "    /* new window below/right of current one */"], "whitespace/indent"]
["src/nvim/window.c", ["                p_sb)))) {", "    /* new window below/right of current one */", "    if (new_wp == NULL)"], "readability/old_style_comment"]
["src/nvim/window.c", ["    /* new window below/right of current one */", "    if (new_wp == NULL)", "      wp = win_alloc(oldwin, FALSE);"], "readability/braces"]
["src/nvim/window.c", ["    if (new_wp == NULL)", "      wp = win_alloc(oldwin, FALSE);", "    else"], "readability/bool"]
["src/nvim/window.c", ["      wp = win_alloc(oldwin, FALSE);", "    else", "      win_append(oldwin, wp);"], "readability/braces"]
["src/nvim/window.c", ["  } else {", "    if (new_wp == NULL)", "      wp = win_alloc(oldwin->w_prev, FALSE);"], "readability/braces"]
["src/nvim/window.c", ["    if (new_wp == NULL)", "      wp = win_alloc(oldwin->w_prev, FALSE);", "    else"], "readability/bool"]
["src/nvim/window.c", ["      wp = win_alloc(oldwin->w_prev, FALSE);", "    else", "      win_append(oldwin->w_prev, wp);"], "readability/braces"]
["src/nvim/window.c", ["  if (new_wp == NULL) {", "    if (wp == NULL)", "      return FAIL;"], "readability/braces"]
["src/nvim/window.c", ["", "    /* make the contents of the new window the same as the current one */", "    win_init(wp, curwin, flags);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /*", "   * Reorganise the tree of frames to insert the new window."], "readability/old_style_comment"]
["src/nvim/window.c", ["      curfrp = topframe->fr_child;", "      if (flags & WSP_BOT)", "        while (curfrp->fr_next != NULL)"], "readability/braces"]
["src/nvim/window.c", ["      if (flags & WSP_BOT)", "        while (curfrp->fr_next != NULL)", "          curfrp = curfrp->fr_next;"], "readability/braces"]
["src/nvim/window.c", ["          curfrp = curfrp->fr_next;", "    } else", "      curfrp = topframe;"], "readability/braces"]
["src/nvim/window.c", ["    curfrp = oldwin->w_frame;", "    if (flags & WSP_BELOW)", "      before = FALSE;"], "readability/braces"]
["src/nvim/window.c", ["    if (flags & WSP_BELOW)", "      before = FALSE;", "    else if (flags & WSP_ABOVE)"], "readability/bool"]
["src/nvim/window.c", ["      before = FALSE;", "    else if (flags & WSP_ABOVE)", "      before = TRUE;"], "readability/braces"]
["src/nvim/window.c", ["    else if (flags & WSP_ABOVE)", "      before = TRUE;", "    else if (flags & WSP_VERT)"], "readability/bool"]
["src/nvim/window.c", ["      before = TRUE;", "    else if (flags & WSP_VERT)", "      before = !p_spr;"], "readability/braces"]
["src/nvim/window.c", ["      before = !p_spr;", "    else", "      before = !p_sb;"], "readability/braces"]
["src/nvim/window.c", ["  if (curfrp->fr_parent == NULL || curfrp->fr_parent->fr_layout != layout) {", "    /* Need to create a new frame in the tree to make a branch. */", "    frp = xcalloc(1, sizeof(frame_T));"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  if (new_wp == NULL)", "    frp = wp->w_frame;"], "readability/braces"]
["src/nvim/window.c", ["    frp = wp->w_frame;", "  else", "    frp = new_wp->w_frame;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* Insert the new frame at the right place in the frame list. */", "  if (before)"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* Insert the new frame at the right place in the frame list. */", "  if (before)", "    frame_insert(curfrp, frp);"], "readability/braces"]
["src/nvim/window.c", ["    frame_insert(curfrp, frp);", "  else", "    frame_append(curfrp, frp);"], "readability/braces"]
["src/nvim/window.c", ["", "  /* Set w_fraction now so that the cursor keeps the same relative", "   * vertical position. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (flags & (WSP_TOP | WSP_BOT)) {", "      /* set height and row of new window to full height */", "      wp->w_winrow = tabline_height();"], "readability/old_style_comment"]
["src/nvim/window.c", ["    } else {", "      /* height and row of new window is same as current window */", "      wp->w_winrow = oldwin->w_winrow;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /* \"new_size\" of the current window goes to the new window, use", "     * one column for the vertical separator */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    win_new_width(wp, new_size);", "    if (before)", "      wp->w_vsep_width = 1;"], "readability/braces"]
["src/nvim/window.c", ["      wp->w_vsep_width = 1;", "    else {", "      wp->w_vsep_width = oldwin->w_vsep_width;"], "readability/braces"]
["src/nvim/window.c", ["      wp->w_vsep_width = 1;", "    else {", "      wp->w_vsep_width = oldwin->w_vsep_width;"], "readability/braces"]
["src/nvim/window.c", ["    if (flags & (WSP_TOP | WSP_BOT)) {", "      if (flags & WSP_BOT)", "        frame_add_vsep(curfrp);"], "readability/braces"]
["src/nvim/window.c", ["        frame_add_vsep(curfrp);", "      /* Set width of neighbor frame */", "      frame_new_width(curfrp, curfrp->fr_width"], "readability/old_style_comment"]
["src/nvim/window.c", ["      frame_new_width(curfrp, curfrp->fr_width", "          - (new_size + ((flags & WSP_TOP) != 0)), flags & WSP_TOP,", "          FALSE);"], "whitespace/alignment"]
["src/nvim/window.c", ["          - (new_size + ((flags & WSP_TOP) != 0)), flags & WSP_TOP,", "          FALSE);", "    } else"], "whitespace/alignment"]
["src/nvim/window.c", ["          - (new_size + ((flags & WSP_TOP) != 0)), flags & WSP_TOP,", "          FALSE);", "    } else"], "readability/bool"]
["src/nvim/window.c", ["          FALSE);", "    } else", "      win_new_width(oldwin, oldwin->w_width - (new_size + 1));"], "readability/braces"]
["src/nvim/window.c", ["      win_new_width(oldwin, oldwin->w_width - (new_size + 1));", "    if (before) {       /* new window left of current one */", "      wp->w_wincol = oldwin->w_wincol;"], "readability/old_style_comment"]
["src/nvim/window.c", ["      oldwin->w_wincol += new_size + 1;", "    } else              /* new window right of current one */", "      wp->w_wincol = oldwin->w_wincol + oldwin->w_width + 1;"], "readability/old_style_comment"]
["src/nvim/window.c", ["      oldwin->w_wincol += new_size + 1;", "    } else              /* new window right of current one */", "      wp->w_wincol = oldwin->w_wincol + oldwin->w_width + 1;"], "readability/braces"]
["src/nvim/window.c", ["  } else {", "    /* width and column of new window is same as current window */", "    if (flags & (WSP_TOP | WSP_BOT)) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /* \"new_size\" of the current window goes to the new window, use", "     * one row for the status line */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    }", "    if (flags & WSP_BOT)", "      frame_add_statusline(curfrp);"], "readability/braces"]
["src/nvim/window.c", ["", "  if (flags & (WSP_TOP | WSP_BOT))", "    (void)win_comp_pos();"], "readability/braces"]
["src/nvim/window.c", ["    msg_col = sc_col;", "    msg_clr_eos_force();        /* Old command/ruler may still be there */", "    comp_col();"], "readability/old_style_comment"]
["src/nvim/window.c", ["    msg_row = Rows - 1;", "    msg_col = 0;        /* put position back at start of line */", "  }"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /*", "   * equalize the window sizes."], "readability/old_style_comment"]
["src/nvim/window.c", ["   */", "  if (do_equal || dir != 0)", "    win_equal(wp, true,"], "readability/braces"]
["src/nvim/window.c", ["    win_equal(wp, true,", "        (flags & WSP_VERT) ? (dir == 'v' ? 'b' : 'h')", "        : dir == 'h' ? 'b' :"], "whitespace/alignment"]
["src/nvim/window.c", ["        (flags & WSP_VERT) ? (dir == 'v' ? 'b' : 'h')", "        : dir == 'h' ? 'b' :", "        'v');"], "whitespace/alignment"]
["src/nvim/window.c", ["        : dir == 'h' ? 'b' :", "        'v');", ""], "whitespace/alignment"]
["src/nvim/window.c", ["", "  /* Don't change the window height/width to 'winheight' / 'winwidth' if a", "   * size was given. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    i = p_wiw;", "    if (size != 0)", "      p_wiw = size;"], "readability/braces"]
["src/nvim/window.c", ["    i = p_wh;", "    if (size != 0)", "      p_wh = size;"], "readability/braces"]
["src/nvim/window.c", ["", "  /*", "   * make the new window the current window"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Initialize window \"newp\" from window \"oldp\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (flags & WSP_NEWLOC) {", "    /* Don't copy the location list.  */", "    newp->w_llist = NULL;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* copy tagstack and folds */", "  for (i = 0; i < oldp->w_tagstacklen; i++) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Initialize window \"newp\" from window \"old\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  /* Use the same argument list. */", "  newp->w_alist = oldp->w_alist;"], "readability/old_style_comment"]
["src/nvim/window.c", ["  newp->w_alist = oldp->w_alist;", "  ++newp->w_alist->al_refcount;", "  newp->w_arg_idx = oldp->w_arg_idx;"], "readability/increment"]
["src/nvim/window.c", ["", "  /* copy options from existing window */", "  win_copy_options(oldp, newp);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Return the number of windows."], "readability/old_style_comment"]
["src/nvim/window.c", ["  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {", "    ++count;", "  }"], "readability/increment"]
["src/nvim/window.c", ["", "/*", " * Make \"count\" windows on the screen."], "readability/old_style_comment"]
["src/nvim/window.c", [" */", "int ", "make_windows ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["int ", "make_windows (", "    int count,"], "whitespace/parens"]
["src/nvim/window.c", ["    int count,", "    int vertical              /* split windows vertically if TRUE */", ")"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (vertical) {", "    /* Each windows needs at least 'winminwidth' lines and a separator", "     * column. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  if (maxcount < 2)", "    maxcount = 2;"], "readability/braces"]
["src/nvim/window.c", ["    maxcount = 2;", "  if (count > maxcount)", "    count = maxcount;"], "readability/braces"]
["src/nvim/window.c", ["", "  /*", "   * add status line now, otherwise first window will be too big"], "readability/old_style_comment"]
["src/nvim/window.c", ["   */", "  if (count > 1)", "    last_status(TRUE);"], "readability/braces"]
["src/nvim/window.c", ["  if (count > 1)", "    last_status(TRUE);", ""], "readability/bool"]
["src/nvim/window.c", ["", "  /*", "   * Don't execute autocommands while creating the windows.  Must do that"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* todo is number of windows left to create */", "  for (todo = count - 1; todo > 0; --todo)"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* todo is number of windows left to create */", "  for (todo = count - 1; todo > 0; --todo)", "    if (vertical) {"], "readability/braces"]
["src/nvim/window.c", ["  /* todo is number of windows left to create */", "  for (todo = count - 1; todo > 0; --todo)", "    if (vertical) {"], "readability/increment"]
["src/nvim/window.c", ["    if (vertical) {", "      if (win_split(curwin->w_width - (curwin->w_width - todo)", "              / (todo + 1) - 1, WSP_VERT | WSP_ABOVE) == FAIL)"], "readability/braces"]
["src/nvim/window.c", ["      if (win_split(curwin->w_width - (curwin->w_width - todo)", "              / (todo + 1) - 1, WSP_VERT | WSP_ABOVE) == FAIL)", "        break;"], "whitespace/alignment"]
["src/nvim/window.c", ["    } else {", "      if (win_split(curwin->w_height - (curwin->w_height - todo", "                                        * STATUS_HEIGHT) / (todo + 1)"], "readability/braces"]
["src/nvim/window.c", ["                                        * STATUS_HEIGHT) / (todo + 1)", "              - STATUS_HEIGHT, WSP_ABOVE) == FAIL)", "        break;"], "whitespace/alignment"]
["src/nvim/window.c", ["", "  /* return actual number of windows */", "  return count - todo;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Exchange current and next window"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /*", "   * find window to exchange with"], "readability/old_style_comment"]
["src/nvim/window.c", ["    frp = curwin->w_frame->fr_parent->fr_child;", "    while (frp != NULL && --Prenum > 0)", "      frp = frp->fr_next;"], "readability/braces"]
["src/nvim/window.c", ["      frp = frp->fr_next;", "  } else if (curwin->w_frame->fr_next != NULL)  /* Swap with next */", "    frp = curwin->w_frame->fr_next;"], "readability/old_style_comment"]
["src/nvim/window.c", ["      frp = frp->fr_next;", "  } else if (curwin->w_frame->fr_next != NULL)  /* Swap with next */", "    frp = curwin->w_frame->fr_next;"], "readability/braces"]
["src/nvim/window.c", ["    frp = curwin->w_frame->fr_next;", "  else      /* Swap last window in row/col with previous */", "    frp = curwin->w_frame->fr_prev;"], "readability/old_style_comment"]
["src/nvim/window.c", ["    frp = curwin->w_frame->fr_next;", "  else      /* Swap last window in row/col with previous */", "    frp = curwin->w_frame->fr_prev;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* We can only exchange a window with another window, not with a frame", "   * containing windows. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["   * containing windows. */", "  if (frp == NULL || frp->fr_win == NULL || frp->fr_win == curwin)", "    return;"], "readability/braces"]
["src/nvim/window.c", ["", "  /*", "   * 1. remove curwin from the list. Remember after which window it was in wp2"], "readability/old_style_comment"]
["src/nvim/window.c", ["    win_append(wp2, wp);", "    if (frp2 == NULL)", "      frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame);"], "readability/braces"]
["src/nvim/window.c", ["      frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame);", "    else", "      frame_append(frp2, wp->w_frame);"], "readability/braces"]
["src/nvim/window.c", ["", "  /* If the windows are not in the same frame, exchange the sizes to avoid", "   * messing up the window layout.  Otherwise fix the frame sizes. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  (void)win_comp_pos();                 /* recompute window positions */", ""], "readability/old_style_comment"]
["src/nvim/window.c", ["  while (count--) {", "    if (upwards) {              /* first window becomes last window */", "      /* remove first window/frame from the list */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (upwards) {              /* first window becomes last window */", "      /* remove first window/frame from the list */", "      frp = curwin->w_frame->fr_parent->fr_child;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "      /* find last frame and append removed window/frame after it */", "      for (; frp->fr_next != NULL; frp = frp->fr_next)"], "readability/old_style_comment"]
["src/nvim/window.c", ["      /* find last frame and append removed window/frame after it */", "      for (; frp->fr_next != NULL; frp = frp->fr_next)", "        ;"], "readability/braces"]
["src/nvim/window.c", ["      for (; frp->fr_next != NULL; frp = frp->fr_next)", "        ;", "      win_append(frp->fr_win, wp1);"], "whitespace/semicolon"]
["src/nvim/window.c", ["", "      wp2 = frp->fr_win;                /* previously last window */", "    } else {                  /* last window becomes first window */"], "readability/old_style_comment"]
["src/nvim/window.c", ["      wp2 = frp->fr_win;                /* previously last window */", "    } else {                  /* last window becomes first window */", "      /* find last window/frame in the list and remove it */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    } else {                  /* last window becomes first window */", "      /* find last window/frame in the list and remove it */", "      for (frp = curwin->w_frame; frp->fr_next != NULL;"], "readability/old_style_comment"]
["src/nvim/window.c", ["      /* find last window/frame in the list and remove it */", "      for (frp = curwin->w_frame; frp->fr_next != NULL;", "           frp = frp->fr_next)"], "readability/braces"]
["src/nvim/window.c", ["           frp = frp->fr_next)", "        ;", "      wp1 = frp->fr_win;"], "whitespace/semicolon"]
["src/nvim/window.c", ["      wp1 = frp->fr_win;", "      wp2 = wp1->w_prev;                    /* will become last window */", "      win_remove(wp1, NULL);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "      /* append the removed window/frame before the first in the list */", "      win_append(frp->fr_parent->fr_child->fr_win->w_prev, wp1);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /* exchange status height and vsep width of old and new last window */", "    n = wp2->w_status_height;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /* recompute w_winrow and w_wincol for all windows */", "    (void)win_comp_pos();"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Move the current window to the very top/bottom/left/right of the screen."], "readability/old_style_comment"]
["src/nvim/window.c", ["  win_remove(curwin, NULL);", "  last_status(FALSE);       /* may need to remove last status line */", "  (void)win_comp_pos();     /* recompute window positions */"], "readability/old_style_comment"]
["src/nvim/window.c", ["  win_remove(curwin, NULL);", "  last_status(FALSE);       /* may need to remove last status line */", "  (void)win_comp_pos();     /* recompute window positions */"], "readability/bool"]
["src/nvim/window.c", ["  last_status(FALSE);       /* may need to remove last status line */", "  (void)win_comp_pos();     /* recompute window positions */", ""], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Split a window on the desired side and put the window there. */", "  (void)win_split_ins(size, flags, curwin, dir);"], "readability/old_style_comment"]
["src/nvim/window.c", ["    win_setheight(height);", "    if (p_ea)", "      win_equal(curwin, true, 'v');"], "readability/braces"]
["src/nvim/window.c", ["  }", "", "}"], "whitespace/blank_line"]
["src/nvim/window.c", ["", "/*", " * Move window \"win1\" to below/right of \"win2\" and make \"win1\" the current"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* check if the arguments are reasonable */", "  if (win1 == win2)"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* check if the arguments are reasonable */", "  if (win1 == win2)", "    return;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* check if there is something to do */", "  if (win2->w_next != win1) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (win2->w_next != win1) {", "    /* may need move the status line/vertical separator of the last window", "     * */"], "readability/old_style_comment"]
["src/nvim/window.c", ["      if (win1->w_prev->w_vsep_width == 1) {", "        /* Remove the vertical separator from the last-but-one window,", "         * add it to the last window.  Adjust the frame widths. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["      if (win1->w_vsep_width == 1) {", "        /* Remove the vertical separator from win1, add it to the last", "         * window, win2.  Adjust the frame widths. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Make all windows the same height."], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  if (dir == 0)", "    dir = *p_ead;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Set a frame to a new position and height, spreading the available room"], "readability/old_style_comment"]
["src/nvim/window.c", ["static void win_equal_rec(", "    win_T *next_curwin,       /* pointer to current window to be or NULL */", "    bool current,                    /* do only frame with current window */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    win_T *next_curwin,       /* pointer to current window to be or NULL */", "    bool current,                    /* do only frame with current window */", "    frame_T *topfr,             /* frame to set size off */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    bool current,                    /* do only frame with current window */", "    frame_T *topfr,             /* frame to set size off */", "    int dir,                        /* 'v', 'h' or 'b', see win_equal() */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    frame_T *topfr,             /* frame to set size off */", "    int dir,                        /* 'v', 'h' or 'b', see win_equal() */", "    int col,                        /* horizontal position for frame */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    int dir,                        /* 'v', 'h' or 'b', see win_equal() */", "    int col,                        /* horizontal position for frame */", "    int row,                        /* vertical position for frame */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    int col,                        /* horizontal position for frame */", "    int row,                        /* vertical position for frame */", "    int width,                      /* new width of frame */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    int row,                        /* vertical position for frame */", "    int width,                      /* new width of frame */", "    int height                     /* new height of frame */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    int width,                      /* new width of frame */", "    int height                     /* new height of frame */", ")"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (topfr->fr_layout == FR_LEAF) {", "    /* Set the width/height of this frame.", "     * Redraw when size or position changes */"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    if (dir != 'v') {                   /* equalize frame widths */", "      /* Compute the maximum number of windows horizontally in this"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (dir != 'v') {                   /* equalize frame widths */", "      /* Compute the maximum number of windows horizontally in this", "       * frame. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["      n = frame_minwidth(topfr, NOWIN);", "      /* add one for the rightmost window, it doesn't have a separator */", "      if (col + width == Columns)"], "readability/old_style_comment"]
["src/nvim/window.c", ["      /* add one for the rightmost window, it doesn't have a separator */", "      if (col + width == Columns)", "        extra_sep = 1;"], "readability/braces"]
["src/nvim/window.c", ["        extra_sep = 1;", "      else", "        extra_sep = 0;"], "readability/braces"]
["src/nvim/window.c", ["", "      /*", "       * Compute width for \"next_curwin\" window and room available for"], "readability/old_style_comment"]
["src/nvim/window.c", ["            next_curwin_size = 0;", "            if (new_size < p_wiw)", "              new_size = p_wiw;"], "readability/braces"]
["src/nvim/window.c", ["              new_size = p_wiw;", "          } else", "            /* These windows don't use up room. */"], "readability/braces"]
["src/nvim/window.c", ["          } else", "            /* These windows don't use up room. */", "            totwincount -= (n + (fr->fr_next == NULL"], "readability/old_style_comment"]
["src/nvim/window.c", ["        if (next_curwin_size == -1) {", "          if (!has_next_curwin)", "            next_curwin_size = 0;"], "readability/braces"]
["src/nvim/window.c", ["            next_curwin_size = 0;", "          else if (totwincount > 1", "                   && (room + (totwincount - 2))"], "readability/braces"]
["src/nvim/window.c", ["                   / (totwincount - 1) > p_wiw) {", "            /* Can make all windows wider than 'winwidth', spread", "             * the room equally. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["            room -= next_curwin_size - p_wiw;", "          } else", "            next_curwin_size = p_wiw;"], "readability/braces"]
["src/nvim/window.c", ["", "      if (has_next_curwin)", "        --totwincount;                  /* don't count curwin */"], "readability/braces"]
["src/nvim/window.c", ["      if (has_next_curwin)", "        --totwincount;                  /* don't count curwin */", "    }"], "readability/old_style_comment"]
["src/nvim/window.c", ["      if (has_next_curwin)", "        --totwincount;                  /* don't count curwin */", "    }"], "readability/increment"]
["src/nvim/window.c", ["      wincount = 1;", "      if (fr->fr_next == NULL)", "        /* last frame gets all that remains (avoid roundoff error) */"], "readability/braces"]
["src/nvim/window.c", ["      if (fr->fr_next == NULL)", "        /* last frame gets all that remains (avoid roundoff error) */", "        new_size = width;"], "readability/old_style_comment"]
["src/nvim/window.c", ["        new_size = width;", "      else if (dir == 'v')", "        new_size = fr->fr_width;"], "readability/braces"]
["src/nvim/window.c", ["        new_size = fr->fr_width;", "      else if (frame_fixed_width(fr)) {", "        new_size = fr->fr_newwidth;"], "readability/braces"]
["src/nvim/window.c", ["        new_size = fr->fr_newwidth;", "        wincount = 0;               /* doesn't count as a sizeable window */", "      } else {"], "readability/old_style_comment"]
["src/nvim/window.c", ["      } else {", "        /* Compute the maximum number of windows horiz. in \"fr\". */", "        n = frame_minwidth(fr, NOWIN);"], "readability/old_style_comment"]
["src/nvim/window.c", ["        m = frame_minwidth(fr, next_curwin);", "        if (has_next_curwin)", "          hnc = frame_has_win(fr, next_curwin);"], "readability/braces"]
["src/nvim/window.c", ["          hnc = frame_has_win(fr, next_curwin);", "        else", "          hnc = FALSE;"], "readability/braces"]
["src/nvim/window.c", ["        else", "          hnc = FALSE;", "        if (hnc)                    /* don't count next_curwin */"], "readability/bool"]
["src/nvim/window.c", ["          hnc = FALSE;", "        if (hnc)                    /* don't count next_curwin */", "          --wincount;"], "readability/old_style_comment"]
["src/nvim/window.c", ["          hnc = FALSE;", "        if (hnc)                    /* don't count next_curwin */", "          --wincount;"], "readability/braces"]
["src/nvim/window.c", ["        if (hnc)                    /* don't count next_curwin */", "          --wincount;", "        if (totwincount == 0)"], "readability/increment"]
["src/nvim/window.c", ["          --wincount;", "        if (totwincount == 0)", "          new_size = room;"], "readability/braces"]
["src/nvim/window.c", ["          new_size = room;", "        else", "          new_size = (wincount * room + (totwincount / 2)) / totwincount;"], "readability/braces"]
["src/nvim/window.c", ["          new_size = (wincount * room + (totwincount / 2)) / totwincount;", "        if (hnc) {                  /* add next_curwin size */", "          next_curwin_size -= p_wiw - (m - n);"], "readability/old_style_comment"]
["src/nvim/window.c", ["          room -= new_size - next_curwin_size;", "        } else", "          room -= new_size;"], "readability/braces"]
["src/nvim/window.c", ["", "      /* Skip frame that is full width when splitting or closing a", "       * window, unless equalizing all frames. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["       * window, unless equalizing all frames. */", "      if (!current || dir != 'v' || topfr->fr_parent != NULL", "          || (new_size != fr->fr_width)"], "readability/braces"]
["src/nvim/window.c", ["        win_equal_rec(next_curwin, current, fr, dir, col, row,", "            new_size, height);", "      col += new_size;"], "whitespace/alignment"]
["src/nvim/window.c", ["    }", "  } else { /* topfr->fr_layout == FR_COL */", "    topfr->fr_width = width;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    if (dir != 'h') {                   /* equalize frame heights */", "      /* Compute maximum number of windows vertically in this frame. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (dir != 'h') {                   /* equalize frame heights */", "      /* Compute maximum number of windows vertically in this frame. */", "      n = frame_minheight(topfr, NOWIN);"], "readability/old_style_comment"]
["src/nvim/window.c", ["      n = frame_minheight(topfr, NOWIN);", "      /* add one for the bottom window if it doesn't have a statusline */", "      if (row + height == cmdline_row && p_ls == 0)"], "readability/old_style_comment"]
["src/nvim/window.c", ["      /* add one for the bottom window if it doesn't have a statusline */", "      if (row + height == cmdline_row && p_ls == 0)", "        extra_sep = 1;"], "readability/braces"]
["src/nvim/window.c", ["        extra_sep = 1;", "      else", "        extra_sep = 0;"], "readability/braces"]
["src/nvim/window.c", ["", "      /*", "       * Compute height for \"next_curwin\" window and room available for"], "readability/old_style_comment"]
["src/nvim/window.c", ["      if (room < 0) {", "        /* The room is less then 'winheight', use all space for the", "         * current window. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["            next_curwin_size = 0;", "            if (new_size < p_wh)", "              new_size = p_wh;"], "readability/braces"]
["src/nvim/window.c", ["              new_size = p_wh;", "          } else", "            /* These windows don't use up room. */"], "readability/braces"]
["src/nvim/window.c", ["          } else", "            /* These windows don't use up room. */", "            totwincount -= (n + (fr->fr_next == NULL"], "readability/old_style_comment"]
["src/nvim/window.c", ["        if (next_curwin_size == -1) {", "          if (!has_next_curwin)", "            next_curwin_size = 0;"], "readability/braces"]
["src/nvim/window.c", ["            next_curwin_size = 0;", "          else if (totwincount > 1", "                   && (room + (totwincount - 2))"], "readability/braces"]
["src/nvim/window.c", ["                   / (totwincount - 1) > p_wh) {", "            /* can make all windows higher than 'winheight',", "             * spread the room equally. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["            room -= next_curwin_size - p_wh;", "          } else", "            next_curwin_size = p_wh;"], "readability/braces"]
["src/nvim/window.c", ["", "      if (has_next_curwin)", "        --totwincount;                  /* don't count curwin */"], "readability/braces"]
["src/nvim/window.c", ["      if (has_next_curwin)", "        --totwincount;                  /* don't count curwin */", "    }"], "readability/old_style_comment"]
["src/nvim/window.c", ["      if (has_next_curwin)", "        --totwincount;                  /* don't count curwin */", "    }"], "readability/increment"]
["src/nvim/window.c", ["      wincount = 1;", "      if (fr->fr_next == NULL)", "        /* last frame gets all that remains (avoid roundoff error) */"], "readability/braces"]
["src/nvim/window.c", ["      if (fr->fr_next == NULL)", "        /* last frame gets all that remains (avoid roundoff error) */", "        new_size = height;"], "readability/old_style_comment"]
["src/nvim/window.c", ["        new_size = height;", "      else if (dir == 'h')", "        new_size = fr->fr_height;"], "readability/braces"]
["src/nvim/window.c", ["        new_size = fr->fr_height;", "      else if (frame_fixed_height(fr)) {", "        new_size = fr->fr_newheight;"], "readability/braces"]
["src/nvim/window.c", ["        new_size = fr->fr_newheight;", "        wincount = 0;               /* doesn't count as a sizeable window */", "      } else {"], "readability/old_style_comment"]
["src/nvim/window.c", ["      } else {", "        /* Compute the maximum number of windows vert. in \"fr\". */", "        n = frame_minheight(fr, NOWIN);"], "readability/old_style_comment"]
["src/nvim/window.c", ["        m = frame_minheight(fr, next_curwin);", "        if (has_next_curwin)", "          hnc = frame_has_win(fr, next_curwin);"], "readability/braces"]
["src/nvim/window.c", ["          hnc = frame_has_win(fr, next_curwin);", "        else", "          hnc = FALSE;"], "readability/braces"]
["src/nvim/window.c", ["        else", "          hnc = FALSE;", "        if (hnc)                    /* don't count next_curwin */"], "readability/bool"]
["src/nvim/window.c", ["          hnc = FALSE;", "        if (hnc)                    /* don't count next_curwin */", "          --wincount;"], "readability/old_style_comment"]
["src/nvim/window.c", ["          hnc = FALSE;", "        if (hnc)                    /* don't count next_curwin */", "          --wincount;"], "readability/braces"]
["src/nvim/window.c", ["        if (hnc)                    /* don't count next_curwin */", "          --wincount;", "        if (totwincount == 0)"], "readability/increment"]
["src/nvim/window.c", ["          --wincount;", "        if (totwincount == 0)", "          new_size = room;"], "readability/braces"]
["src/nvim/window.c", ["          new_size = room;", "        else", "          new_size = (wincount * room + (totwincount / 2)) / totwincount;"], "readability/braces"]
["src/nvim/window.c", ["          new_size = (wincount * room + (totwincount / 2)) / totwincount;", "        if (hnc) {                  /* add next_curwin size */", "          next_curwin_size -= p_wh - (m - n);"], "readability/old_style_comment"]
["src/nvim/window.c", ["          room -= new_size - next_curwin_size;", "        } else", "          room -= new_size;"], "readability/braces"]
["src/nvim/window.c", ["      }", "      /* Skip frame that is full width when splitting or closing a", "       * window, unless equalizing all frames. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["       * window, unless equalizing all frames. */", "      if (!current || dir != 'h' || topfr->fr_parent != NULL", "          || (new_size != fr->fr_height)"], "readability/braces"]
["src/nvim/window.c", ["        win_equal_rec(next_curwin, current, fr, dir, col, row,", "            width, new_size);", "      row += new_size;"], "whitespace/alignment"]
["src/nvim/window.c", ["", "  ++RedrawingDisabled;", ""], "readability/increment"]
["src/nvim/window.c", ["", "      /* Start all over, autocommands may change the window layout. */", "      wp = firstwin;"], "readability/old_style_comment"]
["src/nvim/window.c", ["      wp = firstwin;", "    } else", "      wp = wp->w_next;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* Also check windows in other tab pages. */", "  for (tp = first_tabpage; tp != NULL; tp = nexttp) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "          /* Start all over, the tab page may be closed and", "           * autocommands may change the window layout. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  --RedrawingDisabled;", ""], "readability/increment"]
["src/nvim/window.c", ["", "  /*", "   * Closing the last window in a tab page.  First go to another tab"], "readability/old_style_comment"]
["src/nvim/window.c", ["   */", "  goto_tabpage_tp(alt_tabpage(), FALSE, TRUE);", "  redraw_tabline = TRUE;"], "readability/bool"]
["src/nvim/window.c", ["  goto_tabpage_tp(alt_tabpage(), FALSE, TRUE);", "  redraw_tabline = TRUE;", ""], "readability/bool"]
["src/nvim/window.c", ["  char_u prev_idx[NUMBUFLEN];", "  sprintf((char *)prev_idx, \"%i\", tabpage_index(prev_curtab));", ""], "runtime/printf"]
["src/nvim/window.c", ["", "  /* Safety check: Autocommands may have closed the window when jumping", "   * to the other tab page. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    win_close_othertab(win, free_buf, prev_curtab);", "    if (h != tabline_height())", "      shell_new_rows();"], "readability/braces"]
["src/nvim/window.c", ["  win_T       *wp;", "  int other_buffer = FALSE;", "  int close_curwin = FALSE;"], "readability/bool"]
["src/nvim/window.c", ["  int other_buffer = FALSE;", "  int close_curwin = FALSE;", "  int dir;"], "readability/bool"]
["src/nvim/window.c", ["", "  /* When closing the last window in a tab page first go to another tab page", "   * and then close the window and the tab page to avoid that curwin and"], "readability/old_style_comment"]
["src/nvim/window.c", ["   * curtab are invalid while we are freeing memory. */", "  if (close_last_window_tabpage(win, free_buf, prev_curtab))", "    return FAIL;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* When closing the help window, try restoring a snapshot after closing", "   * the window.  Otherwise clear the snapshot, it's now invalid. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (win == curwin) {", "    /*", "     * Guess which window is going to be the new current window."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /*", "     * Be careful: If autocommands delete the window or cause this window"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (wp->w_buffer != curbuf) {", "      other_buffer = TRUE;", "      win->w_closing = true;"], "readability/bool"]
["src/nvim/window.c", ["      win->w_closing = true;", "      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);", "      if (!win_valid(win))"], "readability/bool"]
["src/nvim/window.c", ["      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);", "      if (!win_valid(win))", "        return FAIL;"], "readability/braces"]
["src/nvim/window.c", ["      win->w_closing = false;", "      if (last_window())", "        return FAIL;"], "readability/braces"]
["src/nvim/window.c", ["    win->w_closing = false;", "    if (last_window())", "      return FAIL;"], "readability/braces"]
["src/nvim/window.c", ["      return FAIL;", "    /* autocmds may abort script processing */", "    if (aborting())"], "readability/old_style_comment"]
["src/nvim/window.c", ["    /* autocmds may abort script processing */", "    if (aborting())", "      return FAIL;"], "readability/braces"]
["src/nvim/window.c", ["", "  /*", "   * Close the link to the buffer."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Make sure curwin isn't invalid.  It can cause severe trouble when", "   * printing an error message.  For win_equal() curbuf needs to be valid"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (wp->w_p_pvw || bt_quickfix(wp->w_buffer)) {", "      /*", "       * If the cursor goes to the preview or the quickfix window, try"], "readability/old_style_comment"]
["src/nvim/window.c", ["      for (;; ) {", "        if (wp->w_next == NULL)", "          wp = firstwin;"], "readability/braces"]
["src/nvim/window.c", ["          wp = firstwin;", "        else", "          wp = wp->w_next;"], "readability/braces"]
["src/nvim/window.c", ["          wp = wp->w_next;", "        if (wp == curwin)", "          break;"], "readability/braces"]
["src/nvim/window.c", ["    curbuf = curwin->w_buffer;", "    close_curwin = TRUE;", ""], "readability/bool"]
["src/nvim/window.c", ["", "  /*", "   * If last window has a status line now and we don't want one,"], "readability/old_style_comment"]
["src/nvim/window.c", ["   */", "  last_status(FALSE);", ""], "readability/bool"]
["src/nvim/window.c", ["", "  /* After closing the help window, try restoring the window layout from", "   * before it was opened. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["   * before it was opened. */", "  if (help_window)", "    restore_snapshot(SNAP_HELP_IDX, close_curwin);"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Close window \"win\" in tab page \"tp\", which is not the current tab page."], "readability/old_style_comment"]
["src/nvim/window.c", ["  tabpage_T   *ptp = NULL;", "  int free_tp = FALSE;", ""], "readability/bool"]
["src/nvim/window.c", ["", "  /* Careful: Autocommands may have closed the tab page or made it the", "   * current tab page.  */"], "readability/old_style_comment"]
["src/nvim/window.c", ["   * current tab page.  */", "  for (ptp = first_tabpage; ptp != NULL && ptp != tp; ptp = ptp->tp_next)", "    ;"], "readability/braces"]
["src/nvim/window.c", ["  for (ptp = first_tabpage; ptp != NULL && ptp != tp; ptp = ptp->tp_next)", "    ;", "  if (ptp == NULL || tp == curtab)"], "whitespace/semicolon"]
["src/nvim/window.c", ["    ;", "  if (ptp == NULL || tp == curtab)", "    return;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* Autocommands may have closed the window already. */", "  {"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* When closing the last window in a tab page remove the tab page. */", "  if (tp->tp_firstwin == tp->tp_lastwin) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Free the memory used for the window. */", "  win_free_mem(win, &dir, tp);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  if (free_tp)", "    free_tabpage(tp);"], "readability/braces"]
["src/nvim/window.c", ["", "  while (first_tabpage->tp_next != NULL)", "    tabpage_close(TRUE);"], "readability/braces"]
["src/nvim/window.c", ["  while (first_tabpage->tp_next != NULL)", "    tabpage_close(TRUE);", ""], "readability/bool"]
["src/nvim/window.c", ["", "  while (firstwin != NULL)", "    (void)win_free_mem(firstwin, &dummy, NULL);"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Remove a window and its frame from the tree of frames."], "readability/old_style_comment"]
["src/nvim/window.c", ["win_T *", "winframe_remove (", "    win_T *win,"], "whitespace/parens"]
["src/nvim/window.c", ["    win_T *win,", "    int *dirp,       /* set to 'v' or 'h' for direction if 'ea' */", "    tabpage_T *tp                /* tab page \"win\" is in, NULL for current */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    int *dirp,       /* set to 'v' or 'h' for direction if 'ea' */", "    tabpage_T *tp                /* tab page \"win\" is in, NULL for current */", ")"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /*", "   * If there is only one window there is nothing to remove."], "readability/old_style_comment"]
["src/nvim/window.c", ["   */", "  if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)", "    return NULL;"], "readability/braces"]
["src/nvim/window.c", ["", "  /*", "   * Remove the window from its frame."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Remove this frame from the list of frames. */", "  frame_remove(frp_close);"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (frp_close->fr_parent->fr_layout == FR_COL) {", "    /* When 'winfixheight' is set, try to find another frame in the column", "     * (as close to the closed frame as possible) to distribute the height"], "readability/old_style_comment"]
["src/nvim/window.c", ["    frame_new_height(frp2, frp2->fr_height + frp_close->fr_height,", "        frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);", "    *dirp = 'v';"], "whitespace/alignment"]
["src/nvim/window.c", ["    frame_new_height(frp2, frp2->fr_height + frp_close->fr_height,", "        frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);", "    *dirp = 'v';"], "readability/bool"]
["src/nvim/window.c", ["  } else {", "    /* When 'winfixwidth' is set, try to find another frame in the column", "     * (as close to the closed frame as possible) to distribute the width"], "readability/old_style_comment"]
["src/nvim/window.c", ["    frame_new_width(frp2, frp2->fr_width + frp_close->fr_width,", "        frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);", "    *dirp = 'h';"], "whitespace/alignment"]
["src/nvim/window.c", ["    frame_new_width(frp2, frp2->fr_width + frp_close->fr_width,", "        frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);", "    *dirp = 'h';"], "readability/bool"]
["src/nvim/window.c", ["", "  /* If rows/columns go to a window below/right its positions need to be", "   * updated.  Can only be done after the sizes have been updated. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (frp2->fr_next == NULL && frp2->fr_prev == NULL) {", "    /* There is no other frame in this list, move its info to the parent", "     * and remove it. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    frp2->fr_parent->fr_win = frp2->fr_win;", "    if (frp2->fr_win != NULL)", "      frp2->fr_win->w_frame = frp2->fr_parent;"], "readability/braces"]
["src/nvim/window.c", ["    if (frp2 != NULL && frp2->fr_layout == frp->fr_layout) {", "      /* The frame above the parent has the same layout, have to merge", "       * the frames into this list. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["       * the frames into this list. */", "      if (frp2->fr_child == frp)", "        frp2->fr_child = frp->fr_child;"], "readability/braces"]
["src/nvim/window.c", ["      frp->fr_child->fr_prev = frp->fr_prev;", "      if (frp->fr_prev != NULL)", "        frp->fr_prev->fr_next = frp->fr_child;"], "readability/braces"]
["src/nvim/window.c", ["          frp3->fr_next = frp->fr_next;", "          if (frp->fr_next != NULL)", "            frp->fr_next->fr_prev = frp3;"], "readability/braces"]
["src/nvim/window.c", ["static frame_T *", "win_altframe (", "    win_T *win,"], "whitespace/parens"]
["src/nvim/window.c", ["    win_T *win,", "    tabpage_T *tp                /* tab page \"win\" is in, NULL for current */", ")"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Return the tabpage that will be used if the current one is closed."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Use the next tab page if possible. */", "  if (curtab->tp_next != NULL)"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* Use the next tab page if possible. */", "  if (curtab->tp_next != NULL)", "    return curtab->tp_next;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* Find the last but one tab page. */", "  for (tp = first_tabpage; tp->tp_next != curtab; tp = tp->tp_next)"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* Find the last but one tab page. */", "  for (tp = first_tabpage; tp->tp_next != curtab; tp = tp->tp_next)", "    ;"], "readability/braces"]
["src/nvim/window.c", ["  for (tp = first_tabpage; tp->tp_next != curtab; tp = tp->tp_next)", "    ;", "  return tp;"], "whitespace/semicolon"]
["src/nvim/window.c", ["", "/*", " * Find the left-upper window in frame \"frp\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  while (frp->fr_win == NULL)", "    frp = frp->fr_child;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Set a new height for a frame.  Recursively sets the height for contained"], "readability/old_style_comment"]
["src/nvim/window.c", [" */", "static void ", "frame_new_height ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["static void ", "frame_new_height (", "    frame_T *topfrp,"], "whitespace/parens"]
["src/nvim/window.c", ["    int wfh                        /* obey 'winfixheight' when there is a choice;", "                                   may cause the height not to be set */", ")"], "whitespace/indent"]
["src/nvim/window.c", ["    int height,", "    int topfirst,                   /* resize topmost contained frame first */", "    int wfh                        /* obey 'winfixheight' when there is a choice;"], "readability/old_style_comment"]
["src/nvim/window.c", ["    int topfirst,                   /* resize topmost contained frame first */", "    int wfh                        /* obey 'winfixheight' when there is a choice;", "                                   may cause the height not to be set */"], "readability/multiline_comment"]
["src/nvim/window.c", ["    int topfirst,                   /* resize topmost contained frame first */", "    int wfh                        /* obey 'winfixheight' when there is a choice;", "                                   may cause the height not to be set */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    int topfirst,                   /* resize topmost contained frame first */", "    int wfh                        /* obey 'winfixheight' when there is a choice;", "                                   may cause the height not to be set */"], "whitespace/line_length"]
["src/nvim/window.c", ["        if (frp->fr_height > height) {", "          /* Could not fit the windows, make the whole row higher. */", "          height = frp->fr_height;"], "readability/old_style_comment"]
["src/nvim/window.c", ["    } while (frp != NULL);", "  } else { /* fr_layout == FR_COL */", "    /* Complicated case: Resize a column of frames.  Resize the bottom"], "readability/old_style_comment"]
["src/nvim/window.c", ["  } else { /* fr_layout == FR_COL */", "    /* Complicated case: Resize a column of frames.  Resize the bottom", "     * frame first, frames above that when needed. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    frp = topfrp->fr_child;", "    if (wfh)", "      /* Advance past frames with one window with 'wfh' set. */"], "readability/braces"]
["src/nvim/window.c", ["    if (wfh)", "      /* Advance past frames with one window with 'wfh' set. */", "      while (frame_fixed_height(frp)) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["        frp = frp->fr_next;", "        if (frp == NULL)", "          return;                   /* no frame without 'wfh', give up */"], "readability/braces"]
["src/nvim/window.c", ["        if (frp == NULL)", "          return;                   /* no frame without 'wfh', give up */", "      }"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (!topfirst) {", "      /* Find the bottom frame of this column */", "      while (frp->fr_next != NULL)"], "readability/old_style_comment"]
["src/nvim/window.c", ["      /* Find the bottom frame of this column */", "      while (frp->fr_next != NULL)", "        frp = frp->fr_next;"], "readability/braces"]
["src/nvim/window.c", ["        frp = frp->fr_next;", "      if (wfh)", "        /* Advance back for frames with one window with 'wfh' set. */"], "readability/braces"]
["src/nvim/window.c", ["      if (wfh)", "        /* Advance back for frames with one window with 'wfh' set. */", "        while (frame_fixed_height(frp))"], "readability/old_style_comment"]
["src/nvim/window.c", ["        /* Advance back for frames with one window with 'wfh' set. */", "        while (frame_fixed_height(frp))", "          frp = frp->fr_prev;"], "readability/braces"]
["src/nvim/window.c", ["    if (extra_lines < 0) {", "      /* reduce height of contained frames, bottom or top frame first */", "      while (frp != NULL) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["          frame_new_height(frp, frp->fr_height + extra_lines,", "              topfirst, wfh);", "          break;"], "whitespace/alignment"]
["src/nvim/window.c", ["            frp = frp->fr_next;", "          while (wfh && frp != NULL && frame_fixed_height(frp));", "        } else {"], "readability/braces"]
["src/nvim/window.c", ["            frp = frp->fr_next;", "          while (wfh && frp != NULL && frame_fixed_height(frp));", "        } else {"], "whitespace/empty_loop_body"]
["src/nvim/window.c", ["            frp = frp->fr_prev;", "          while (wfh && frp != NULL && frame_fixed_height(frp));", "        }"], "readability/braces"]
["src/nvim/window.c", ["            frp = frp->fr_prev;", "          while (wfh && frp != NULL && frame_fixed_height(frp));", "        }"], "whitespace/empty_loop_body"]
["src/nvim/window.c", ["        }", "        /* Increase \"height\" if we could not reduce enough frames. */", "        if (frp == NULL)"], "readability/old_style_comment"]
["src/nvim/window.c", ["        /* Increase \"height\" if we could not reduce enough frames. */", "        if (frp == NULL)", "          height -= extra_lines;"], "readability/braces"]
["src/nvim/window.c", ["    } else if (extra_lines > 0) {", "      /* increase height of bottom or top frame */", "      frame_new_height(frp, frp->fr_height + extra_lines, topfirst, wfh);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Add a status line to windows at the bottom of \"frp\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (wp->w_status_height == 0) {", "      if (wp->w_height > 0)             /* don't make it negative */", "        --wp->w_height;"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (wp->w_status_height == 0) {", "      if (wp->w_height > 0)             /* don't make it negative */", "        --wp->w_height;"], "readability/braces"]
["src/nvim/window.c", ["      if (wp->w_height > 0)             /* don't make it negative */", "        --wp->w_height;", "      wp->w_status_height = STATUS_HEIGHT;"], "readability/increment"]
["src/nvim/window.c", ["", "/*", " * Set width of a frame.  Handles recursively going through contained frames."], "readability/old_style_comment"]
["src/nvim/window.c", [" */", "static void ", "frame_new_width ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["static void ", "frame_new_width (", "    frame_T *topfrp,"], "whitespace/parens"]
["src/nvim/window.c", ["    int wfw                        /* obey 'winfixwidth' when there is a choice;", "                                   may cause the width not to be set */", ")"], "whitespace/indent"]
["src/nvim/window.c", ["    int width,", "    int leftfirst,                  /* resize leftmost contained frame first */", "    int wfw                        /* obey 'winfixwidth' when there is a choice;"], "readability/old_style_comment"]
["src/nvim/window.c", ["    int leftfirst,                  /* resize leftmost contained frame first */", "    int wfw                        /* obey 'winfixwidth' when there is a choice;", "                                   may cause the width not to be set */"], "readability/multiline_comment"]
["src/nvim/window.c", ["    int leftfirst,                  /* resize leftmost contained frame first */", "    int wfw                        /* obey 'winfixwidth' when there is a choice;", "                                   may cause the width not to be set */"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (topfrp->fr_layout == FR_LEAF) {", "    /* Simple case: just one window. */", "    wp = topfrp->fr_win;"], "readability/old_style_comment"]
["src/nvim/window.c", ["    wp = topfrp->fr_win;", "    /* Find out if there are any windows right of this one. */", "    for (frp = topfrp; frp->fr_parent != NULL; frp = frp->fr_parent)"], "readability/old_style_comment"]
["src/nvim/window.c", ["    /* Find out if there are any windows right of this one. */", "    for (frp = topfrp; frp->fr_parent != NULL; frp = frp->fr_parent)", "      if (frp->fr_parent->fr_layout == FR_ROW && frp->fr_next != NULL)"], "readability/braces"]
["src/nvim/window.c", ["    for (frp = topfrp; frp->fr_parent != NULL; frp = frp->fr_parent)", "      if (frp->fr_parent->fr_layout == FR_ROW && frp->fr_next != NULL)", "        break;"], "readability/braces"]
["src/nvim/window.c", ["        break;", "    if (frp->fr_parent == NULL)", "      wp->w_vsep_width = 0;"], "readability/braces"]
["src/nvim/window.c", ["        if (frp->fr_width > width) {", "          /* Could not fit the windows, make whole column wider. */", "          width = frp->fr_width;"], "readability/old_style_comment"]
["src/nvim/window.c", ["    } while (frp != NULL);", "  } else { /* fr_layout == FR_ROW */", "    /* Complicated case: Resize a row of frames.  Resize the rightmost"], "readability/old_style_comment"]
["src/nvim/window.c", ["  } else { /* fr_layout == FR_ROW */", "    /* Complicated case: Resize a row of frames.  Resize the rightmost", "     * frame first, frames left of it when needed. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    frp = topfrp->fr_child;", "    if (wfw)", "      /* Advance past frames with one window with 'wfw' set. */"], "readability/braces"]
["src/nvim/window.c", ["    if (wfw)", "      /* Advance past frames with one window with 'wfw' set. */", "      while (frame_fixed_width(frp)) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["        frp = frp->fr_next;", "        if (frp == NULL)", "          return;                   /* no frame without 'wfw', give up */"], "readability/braces"]
["src/nvim/window.c", ["        if (frp == NULL)", "          return;                   /* no frame without 'wfw', give up */", "      }"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (!leftfirst) {", "      /* Find the rightmost frame of this row */", "      while (frp->fr_next != NULL)"], "readability/old_style_comment"]
["src/nvim/window.c", ["      /* Find the rightmost frame of this row */", "      while (frp->fr_next != NULL)", "        frp = frp->fr_next;"], "readability/braces"]
["src/nvim/window.c", ["        frp = frp->fr_next;", "      if (wfw)", "        /* Advance back for frames with one window with 'wfw' set. */"], "readability/braces"]
["src/nvim/window.c", ["      if (wfw)", "        /* Advance back for frames with one window with 'wfw' set. */", "        while (frame_fixed_width(frp))"], "readability/old_style_comment"]
["src/nvim/window.c", ["        /* Advance back for frames with one window with 'wfw' set. */", "        while (frame_fixed_width(frp))", "          frp = frp->fr_prev;"], "readability/braces"]
["src/nvim/window.c", ["    if (extra_cols < 0) {", "      /* reduce frame width, rightmost frame first */", "      while (frp != NULL) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["          frame_new_width(frp, frp->fr_width + extra_cols,", "              leftfirst, wfw);", "          break;"], "whitespace/alignment"]
["src/nvim/window.c", ["            frp = frp->fr_next;", "          while (wfw && frp != NULL && frame_fixed_width(frp));", "        } else {"], "readability/braces"]
["src/nvim/window.c", ["            frp = frp->fr_next;", "          while (wfw && frp != NULL && frame_fixed_width(frp));", "        } else {"], "whitespace/empty_loop_body"]
["src/nvim/window.c", ["            frp = frp->fr_prev;", "          while (wfw && frp != NULL && frame_fixed_width(frp));", "        }"], "readability/braces"]
["src/nvim/window.c", ["            frp = frp->fr_prev;", "          while (wfw && frp != NULL && frame_fixed_width(frp));", "        }"], "whitespace/empty_loop_body"]
["src/nvim/window.c", ["        }", "        /* Increase \"width\" if we could not reduce enough frames. */", "        if (frp == NULL)"], "readability/old_style_comment"]
["src/nvim/window.c", ["        /* Increase \"width\" if we could not reduce enough frames. */", "        if (frp == NULL)", "          width -= extra_cols;"], "readability/braces"]
["src/nvim/window.c", ["    } else if (extra_cols > 0) {", "      /* increase width of rightmost frame */", "      frame_new_width(frp, frp->fr_width + extra_cols, leftfirst, wfw);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Add the vertical separator to windows at the right side of \"frp\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (wp->w_vsep_width == 0) {", "      if (wp->w_width > 0)              /* don't make it negative */", "        --wp->w_width;"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (wp->w_vsep_width == 0) {", "      if (wp->w_width > 0)              /* don't make it negative */", "        --wp->w_width;"], "readability/braces"]
["src/nvim/window.c", ["      if (wp->w_width > 0)              /* don't make it negative */", "        --wp->w_width;", "      wp->w_vsep_width = 1;"], "readability/increment"]
["src/nvim/window.c", ["    frp = frp->fr_child;", "    while (frp->fr_next != NULL)", "      frp = frp->fr_next;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Set frame width from the window it contains."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Set frame height from the window it contains."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Compute the minimal height for frame \"topfrp\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["  } else if (topfrp->fr_layout == FR_ROW) {", "    /* get the minimal height from each frame in this row */", "    m = 0;"], "readability/old_style_comment"]
["src/nvim/window.c", ["      n = frame_minheight(frp, next_curwin);", "      if (n > m)", "        m = n;"], "readability/braces"]
["src/nvim/window.c", ["  } else {", "    /* Add up the minimal heights for all frames in this column. */", "    m = 0;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Compute the minimal width for frame \"topfrp\"."], "readability/old_style_comment"]
["src/nvim/window.c", [" */", "static int ", "frame_minwidth ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["static int ", "frame_minwidth (", "    frame_T *topfrp,"], "whitespace/parens"]
["src/nvim/window.c", ["    frame_T *topfrp,", "    win_T *next_curwin       /* use p_wh and p_wiw for next_curwin */", ")"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (topfrp->fr_win != NULL) {", "    if (topfrp->fr_win == next_curwin)", "      m = p_wiw + topfrp->fr_win->w_vsep_width;"], "readability/braces"]
["src/nvim/window.c", ["      m = p_wiw + topfrp->fr_win->w_vsep_width;", "    else {", "      /* window: minimal width of the window plus separator column */"], "readability/braces"]
["src/nvim/window.c", ["      m = p_wiw + topfrp->fr_win->w_vsep_width;", "    else {", "      /* window: minimal width of the window plus separator column */"], "readability/braces"]
["src/nvim/window.c", ["    else {", "      /* window: minimal width of the window plus separator column */", "      m = p_wmw + topfrp->fr_win->w_vsep_width;"], "readability/old_style_comment"]
["src/nvim/window.c", ["      m = p_wmw + topfrp->fr_win->w_vsep_width;", "      /* Current window is minimal one column wide */", "      if (p_wmw == 0 && topfrp->fr_win == curwin && next_curwin == NULL)"], "readability/old_style_comment"]
["src/nvim/window.c", ["      /* Current window is minimal one column wide */", "      if (p_wmw == 0 && topfrp->fr_win == curwin && next_curwin == NULL)", "        ++m;"], "readability/braces"]
["src/nvim/window.c", ["      if (p_wmw == 0 && topfrp->fr_win == curwin && next_curwin == NULL)", "        ++m;", "    }"], "readability/increment"]
["src/nvim/window.c", ["  } else if (topfrp->fr_layout == FR_COL) {", "    /* get the minimal width from each frame in this column */", "    m = 0;"], "readability/old_style_comment"]
["src/nvim/window.c", ["      n = frame_minwidth(frp, next_curwin);", "      if (n > m)", "        m = n;"], "readability/braces"]
["src/nvim/window.c", ["  } else {", "    /* Add up the minimal widths for all frames in this row. */", "    m = 0;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Try to close all windows except current one."], "readability/old_style_comment"]
["src/nvim/window.c", [" */", "void ", "close_others ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["void ", "close_others (", "    int message,"], "whitespace/parens"]
["src/nvim/window.c", ["    int message,", "    int forceit                        /* always hide all other windows */", ")"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Be very careful here: autocommands may change the window layout. */", "  for (wp = firstwin; win_valid(wp); wp = nextwp) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["    nextwp = wp->w_next;", "    if (wp == curwin) {                 /* don't close current window */", "      continue;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /* Check if it's allowed to abandon this window */", "    r = can_abandon(wp->w_buffer, forceit);"], "readability/old_style_comment"]
["src/nvim/window.c", ["    r = can_abandon(wp->w_buffer, forceit);", "    if (!win_valid(wp)) {             /* autocommands messed wp up */", "      nextwp = firstwin;"], "readability/old_style_comment"]
["src/nvim/window.c", ["      }", "      if (bufIsChanged(wp->w_buffer))", "        continue;"], "readability/braces"]
["src/nvim/window.c", ["", "  if (message && !ONE_WINDOW)", "    EMSG(_(\"E445: Other window contains changes\"));"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Init the current window \"curwin\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["  wp->w_cursor.coladd = 0;", "  wp->w_pcmark.lnum = 1;        /* pcmark not cleared but set to line 1 */", "  wp->w_pcmark.col = 0;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Allocate the first window and put an empty buffer in it."], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  if (win_alloc_firstwin(NULL) == FAIL)", "    return FAIL;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Allocate the first window or the first window in a new tab page."], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  curwin = win_alloc(NULL, FALSE);", "  if (oldwin == NULL) {"], "readability/bool"]
["src/nvim/window.c", ["  if (oldwin == NULL) {", "    /* Very first window, need to create an empty buffer for it and", "     * initialize from scratch. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    curwin->w_s = &(curbuf->b_s);", "    curbuf->b_nwindows = 1;     /* there is one window */", "    curwin->w_alist = &global_alist;"], "readability/old_style_comment"]
["src/nvim/window.c", ["    curwin->w_alist = &global_alist;", "    curwin_init();              /* init current window */", "  } else {"], "readability/old_style_comment"]
["src/nvim/window.c", ["  } else {", "    /* First window in new tab page, initialize it from \"oldwin\". */", "    win_init(curwin, oldwin, 0);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /* We don't want cursor- and scroll-binding in the first window. */", "    RESET_BINDING(curwin);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Create a frame for window \"wp\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Initialize the window and frame size to the maximum."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Allocate a new tabpage_T and init the values."], "readability/old_style_comment"]
["src/nvim/window.c", ["  init_var_dict(tp->tp_vars, &tp->tp_winvar, VAR_SCOPE);", "  tp->tp_diff_invalid = TRUE;", "  tp->tp_ch_used = p_ch;"], "readability/bool"]
["src/nvim/window.c", ["  diff_clear(tp);", "  for (idx = 0; idx < SNAP_COUNT; ++idx)", "    clear_snapshot(tp, idx);"], "readability/braces"]
["src/nvim/window.c", ["  diff_clear(tp);", "  for (idx = 0; idx < SNAP_COUNT; ++idx)", "    clear_snapshot(tp, idx);"], "readability/increment"]
["src/nvim/window.c", ["    clear_snapshot(tp, idx);", "  vars_clear(&tp->tp_vars->dv_hashtab);         /* free all t: variables */", "  hash_init(&tp->tp_vars->dv_hashtab);"], "readability/old_style_comment"]
["src/nvim/window.c", ["        n = 2;", "        for (tp = first_tabpage; tp->tp_next != NULL", "             && n < after; tp = tp->tp_next)"], "readability/braces"]
["src/nvim/window.c", ["             && n < after; tp = tp->tp_next)", "          ++n;", "      }"], "readability/increment"]
["src/nvim/window.c", ["", "/*", " * Open a new tab page if \":tab cmd\" was used.  It will edit the same buffer,"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (n != 0) {", "    cmdmod.tab = 0;         /* reset it to avoid doing it twice */", "    postponed_split_tab = 0;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Create up to \"maxcount\" tabpages with empty windows."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Limit to 'tabpagemax' tabs. */", "  if (count > p_tpm)"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* Limit to 'tabpagemax' tabs. */", "  if (count > p_tpm)", "    count = p_tpm;"], "readability/braces"]
["src/nvim/window.c", ["", "  /*", "   * Don't execute autocommands while creating the tab pages.  Must do that"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  for (todo = count - 1; todo > 0; --todo) {", "    if (win_new_tabpage(0, NULL) == FAIL) {"], "readability/increment"]
["src/nvim/window.c", ["", "  /* return actual number of tab pages */", "  return count - todo;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Find tab page \"n\" (first one is 1).  Returns NULL when not found."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  for (tp = first_tabpage; tp != NULL && i != n; tp = tp->tp_next)", "    ++i;"], "readability/braces"]
["src/nvim/window.c", ["  for (tp = first_tabpage; tp != NULL && i != n; tp = tp->tp_next)", "    ++i;", "  return tp;"], "readability/increment"]
["src/nvim/window.c", ["", "/*", " * Get index of tab page \"tp\".  First one has index 1."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  for (tp = first_tabpage; tp != NULL && tp != ftp; tp = tp->tp_next)", "    ++i;"], "readability/braces"]
["src/nvim/window.c", ["  for (tp = first_tabpage; tp != NULL && tp != ftp; tp = tp->tp_next)", "    ++i;", "  return i;"], "readability/increment"]
["src/nvim/window.c", ["", "/*", " * Prepare for leaving the current tab page."], "readability/old_style_comment"]
["src/nvim/window.c", [" */", "static int ", "leave_tabpage ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["static int ", "leave_tabpage (", "    buf_T *new_curbuf,        /* what is going to be the new curbuf,"], "whitespace/parens"]
["src/nvim/window.c", ["    buf_T *new_curbuf,        /* what is going to be the new curbuf,", "                                          NULL if unknown */", "    int trigger_leave_autocmds"], "whitespace/indent"]
["src/nvim/window.c", ["leave_tabpage (", "    buf_T *new_curbuf,        /* what is going to be the new curbuf,", "                                          NULL if unknown */"], "readability/multiline_comment"]
["src/nvim/window.c", ["leave_tabpage (", "    buf_T *new_curbuf,        /* what is going to be the new curbuf,", "                                          NULL if unknown */"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  reset_VIsual_and_resel();     /* stop Visual mode */", "  if (trigger_leave_autocmds) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (new_curbuf != curbuf) {", "      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);", "      if (curtab != tp)"], "readability/bool"]
["src/nvim/window.c", ["      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);", "      if (curtab != tp)", "        return FAIL;"], "readability/braces"]
["src/nvim/window.c", ["    }", "    apply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);", "    if (curtab != tp)"], "readability/bool"]
["src/nvim/window.c", ["    apply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);", "    if (curtab != tp)", "      return FAIL;"], "readability/braces"]
["src/nvim/window.c", ["      return FAIL;", "    apply_autocmds(EVENT_TABLEAVE, NULL, NULL, FALSE, curbuf);", "    if (curtab != tp)"], "readability/bool"]
["src/nvim/window.c", ["    apply_autocmds(EVENT_TABLEAVE, NULL, NULL, FALSE, curbuf);", "    if (curtab != tp)", "      return FAIL;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Start using tab page \"tp\"."], "readability/old_style_comment"]
["src/nvim/window.c", [" */", "static void enter_tabpage(tabpage_T *tp, buf_T *old_curbuf, int trigger_enter_autocmds, int trigger_leave_autocmds)", "{"], "whitespace/line_length"]
["src/nvim/window.c", ["", "  /* We would like doing the TabEnter event first, but we don't have a", "   * valid current window yet, which may break some commands."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* The tabpage line may have appeared or disappeared, may need to resize", "   * the frames for that.  When the Vim window was resized need to update"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Apply autocommands after updating the display, when 'rows' and", "   * 'columns' have been set correctly. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (trigger_enter_autocmds) {", "    apply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);", "    if (old_curbuf != curbuf)"], "readability/bool"]
["src/nvim/window.c", ["    apply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);", "    if (old_curbuf != curbuf)", "      apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);"], "readability/braces"]
["src/nvim/window.c", ["    if (old_curbuf != curbuf)", "      apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);", "  }"], "readability/bool"]
["src/nvim/window.c", ["", "/*", " * Go to tab page \"n\".  For \":tab N\" and \"Ngt\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* If there is only one it can't work. */", "  if (first_tabpage->tp_next == NULL) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (first_tabpage->tp_next == NULL) {", "    if (n > 1)", "      beep_flush();"], "readability/braces"]
["src/nvim/window.c", ["  if (n == 0) {", "    /* No count, go to next tab page, wrap around end. */", "    if (curtab->tp_next == NULL)"], "readability/old_style_comment"]
["src/nvim/window.c", ["    /* No count, go to next tab page, wrap around end. */", "    if (curtab->tp_next == NULL)", "      tp = first_tabpage;"], "readability/braces"]
["src/nvim/window.c", ["      tp = first_tabpage;", "    else", "      tp = curtab->tp_next;"], "readability/braces"]
["src/nvim/window.c", ["  } else if (n < 0) {", "    /* \"gT\": go to previous tab page, wrap around end.  \"N gT\" repeats", "     * this N times. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    ttp = curtab;", "    for (i = n; i < 0; ++i) {", "      for (tp = first_tabpage; tp->tp_next != ttp && tp->tp_next != NULL;"], "readability/increment"]
["src/nvim/window.c", ["    for (i = n; i < 0; ++i) {", "      for (tp = first_tabpage; tp->tp_next != ttp && tp->tp_next != NULL;", "           tp = tp->tp_next)"], "readability/braces"]
["src/nvim/window.c", ["           tp = tp->tp_next)", "        ;", "      ttp = tp;"], "whitespace/semicolon"]
["src/nvim/window.c", ["  } else if (n == 9999) {", "    /* Go to last tab page. */", "    for (tp = first_tabpage; tp->tp_next != NULL; tp = tp->tp_next)"], "readability/old_style_comment"]
["src/nvim/window.c", ["    /* Go to last tab page. */", "    for (tp = first_tabpage; tp->tp_next != NULL; tp = tp->tp_next)", "      ;"], "readability/braces"]
["src/nvim/window.c", ["    for (tp = first_tabpage; tp->tp_next != NULL; tp = tp->tp_next)", "      ;", "  } else {"], "whitespace/semicolon"]
["src/nvim/window.c", ["  } else {", "    /* Go to tab page \"n\". */", "    tp = find_tabpage(n);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  goto_tabpage_tp(tp, TRUE, TRUE);", ""], "readability/bool"]
["src/nvim/window.c", ["  goto_tabpage_tp(tp, TRUE, TRUE);", "", "}"], "whitespace/blank_line"]
["src/nvim/window.c", ["", "/*", " * Go to tabpage \"tp\"."], "readability/old_style_comment"]
["src/nvim/window.c", [" */", "void goto_tabpage_tp(tabpage_T *tp, int trigger_enter_autocmds, int trigger_leave_autocmds)", "{"], "whitespace/line_length"]
["src/nvim/window.c", ["{", "  /* Don't repeat a message in another tab page. */", "  set_keep_msg(NULL, 0);"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (tp != curtab && leave_tabpage(tp->tp_curwin->w_buffer,", "          trigger_leave_autocmds) == OK) {", "    if (valid_tabpage(tp))"], "whitespace/alignment"]
["src/nvim/window.c", ["          trigger_leave_autocmds) == OK) {", "    if (valid_tabpage(tp))", "      enter_tabpage(tp, curbuf, trigger_enter_autocmds,"], "readability/braces"]
["src/nvim/window.c", ["      enter_tabpage(tp, curbuf, trigger_enter_autocmds,", "          trigger_leave_autocmds);", "    else"], "whitespace/alignment"]
["src/nvim/window.c", ["          trigger_leave_autocmds);", "    else", "      enter_tabpage(curtab, curbuf, trigger_enter_autocmds,"], "readability/braces"]
["src/nvim/window.c", ["      enter_tabpage(curtab, curbuf, trigger_enter_autocmds,", "          trigger_leave_autocmds);", "  }"], "whitespace/alignment"]
["src/nvim/window.c", ["", "/*", " * Enter window \"wp\" in tab page \"tp\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  goto_tabpage_tp(tp, TRUE, TRUE);", "  if (curtab == tp && win_valid(wp)) {"], "readability/bool"]
["src/nvim/window.c", ["  for (tp = first_tabpage; tp->tp_next != NULL && n < nr; tp = tp->tp_next) {", "    ++n;", "  }"], "readability/increment"]
["src/nvim/window.c", ["", "  /* Need to redraw the tabline.  Tab page contents doesn't change. */", "  redraw_tabline = TRUE;"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* Need to redraw the tabline.  Tab page contents doesn't change. */", "  redraw_tabline = TRUE;", "}"], "readability/bool"]
["src/nvim/window.c", ["", "/*", " * Go to another window."], "readability/old_style_comment"]
["src/nvim/window.c", ["  }", "  if (curbuf_locked())", "    return;"], "readability/braces"]
["src/nvim/window.c", ["", "  if (wp->w_buffer != curbuf)", "    reset_VIsual_and_resel();"], "readability/braces"]
["src/nvim/window.c", ["    reset_VIsual_and_resel();", "  else if (VIsual_active)", "    wp->w_cursor = curwin->w_cursor;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Find the tabpage for window \"win\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["  while (count--) {", "    /*", "     * First go upwards in the tree of frames until we find an upwards or"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /*", "     * Now go downwards to find the bottom or top frame in it."], "readability/old_style_comment"]
["src/nvim/window.c", ["      }", "      if (nfr->fr_layout == FR_COL && up)", "        while (fr->fr_next != NULL)"], "readability/braces"]
["src/nvim/window.c", ["      if (nfr->fr_layout == FR_COL && up)", "        while (fr->fr_next != NULL)", "          fr = fr->fr_next;"], "readability/braces"]
["src/nvim/window.c", ["  while (count--) {", "    /*", "     * First go upwards in the tree of frames until we find a left or"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /*", "     * Now go downwards to find the leftmost or rightmost frame in it."], "readability/old_style_comment"]
["src/nvim/window.c", ["      if (nfr->fr_layout == FR_COL) {", "        /* Find the frame at the cursor row. */", "        while (fr->fr_next != NULL"], "readability/old_style_comment"]
["src/nvim/window.c", ["        /* Find the frame at the cursor row. */", "        while (fr->fr_next != NULL", "               && frame2win(fr)->w_winrow + fr->fr_height"], "readability/braces"]
["src/nvim/window.c", ["      }", "      if (nfr->fr_layout == FR_ROW && left)", "        while (fr->fr_next != NULL)"], "readability/braces"]
["src/nvim/window.c", ["      if (nfr->fr_layout == FR_ROW && left)", "        while (fr->fr_next != NULL)", "          fr = fr->fr_next;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Make window wp the current window."], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  int other_buffer = FALSE;", ""], "readability/bool"]
["src/nvim/window.c", ["", "  if (wp == curwin && !curwin_invalid)          /* nothing to do */", "    return;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  if (wp == curwin && !curwin_invalid)          /* nothing to do */", "    return;"], "readability/braces"]
["src/nvim/window.c", ["  if (!curwin_invalid && trigger_leave_autocmds) {", "    /*", "     * Be careful: If autocommands delete the window, return now."], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (wp->w_buffer != curbuf) {", "      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);", "      other_buffer = TRUE;"], "readability/bool"]
["src/nvim/window.c", ["      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);", "      other_buffer = TRUE;", "      if (!win_valid(wp))"], "readability/bool"]
["src/nvim/window.c", ["      other_buffer = TRUE;", "      if (!win_valid(wp))", "        return;"], "readability/braces"]
["src/nvim/window.c", ["    }", "    apply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);", "    if (!win_valid(wp))"], "readability/bool"]
["src/nvim/window.c", ["    apply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);", "    if (!win_valid(wp))", "      return;"], "readability/braces"]
["src/nvim/window.c", ["      return;", "    /* autocmds may abort script processing */", "    if (aborting())"], "readability/old_style_comment"]
["src/nvim/window.c", ["    /* autocmds may abort script processing */", "    if (aborting())", "      return;"], "readability/braces"]
["src/nvim/window.c", ["  if (undo_sync && curbuf != wp->w_buffer) {", "    u_sync(FALSE);", "  }"], "readability/bool"]
["src/nvim/window.c", ["  if (!curwin_invalid) {", "    prevwin = curwin;           /* remember for CTRL-W p */", "    curwin->w_redr_status = TRUE;"], "readability/old_style_comment"]
["src/nvim/window.c", ["    prevwin = curwin;           /* remember for CTRL-W p */", "    curwin->w_redr_status = TRUE;", "  }"], "readability/bool"]
["src/nvim/window.c", ["  check_cursor();", "  if (!virtual_active())", "    curwin->w_cursor.coladd = 0;"], "readability/braces"]
["src/nvim/window.c", ["    curwin->w_cursor.coladd = 0;", "  changed_line_abv_curs();      /* assume cursor position needs updating */", ""], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  setmouse();                   /* in case jumped to/from help buffer */", ""], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Change directories when the 'acd' option is set. */", "  do_autochdir();"], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "", "  // First try the current tab page."], "whitespace/blank_line"]
["src/nvim/window.c", ["    win_T *wp = buf_jump_open_win(buf);", "    if (wp != NULL)", "      return wp;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Allocate a window structure and link it in the window list when \"hidden\" is"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Don't execute autocommands while the window is not properly", "   * initialized yet.  gui_create_scrollbar() may trigger a FocusGained"], "readability/old_style_comment"]
["src/nvim/window.c", ["  block_autocmds();", "  /*", "   * link the window in the window list"], "readability/old_style_comment"]
["src/nvim/window.c", ["   */", "  if (!hidden)", "    win_append(after, new_wp);"], "readability/braces"]
["src/nvim/window.c", ["", "  /* position the display and the cursor at the top of the file. */", "  new_wp->w_topline = 1;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* We won't calculate w_fraction until resizing the window */", "  new_wp->w_fraction = 0;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Remove window 'wp' from the window list and free the structure."], "readability/old_style_comment"]
["src/nvim/window.c", [" */", "static void ", "win_free ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["static void ", "win_free (", "    win_T *wp,"], "whitespace/parens"]
["src/nvim/window.c", ["    win_T *wp,", "    tabpage_T *tp                /* tab page \"win\" is in, NULL for current */", ")"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* reduce the reference count to the argument list. */", "  alist_unlink(wp->w_alist);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Don't execute autocommands while the window is halfway being deleted.", "   * gui_mch_destroy_scrollbar() may trigger a FocusGained event. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  vars_clear(&wp->w_vars->dv_hashtab);          /* free all w: variables */", "  hash_init(&wp->w_vars->dv_hashtab);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Remove the window from the b_wininfo lists, it may happen that the", "   * freed memory is re-used for another window. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["  FOR_ALL_BUFFERS(buf) {", "    for (wip = buf->b_wininfo; wip != NULL; wip = wip->wi_next)", "      if (wip->wi_win == wp)"], "readability/braces"]
["src/nvim/window.c", ["    for (wip = buf->b_wininfo; wip != NULL; wip = wip->wi_next)", "      if (wip->wi_win == wp)", "        wip->wi_win = NULL;"], "readability/braces"]
["src/nvim/window.c", ["", "  if (wp != aucmd_win)", "    win_remove(wp, tp);"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Append window \"wp\" in the window list after window \"after\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  if (after == NULL)        /* after NULL is in front of the first */", "    before = firstwin;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  if (after == NULL)        /* after NULL is in front of the first */", "    before = firstwin;"], "readability/braces"]
["src/nvim/window.c", ["    before = firstwin;", "  else", "    before = after->w_next;"], "readability/braces"]
["src/nvim/window.c", ["  wp->w_prev = after;", "  if (after == NULL)", "    firstwin = wp;"], "readability/braces"]
["src/nvim/window.c", ["    firstwin = wp;", "  else", "    after->w_next = wp;"], "readability/braces"]
["src/nvim/window.c", ["    after->w_next = wp;", "  if (before == NULL)", "    lastwin = wp;"], "readability/braces"]
["src/nvim/window.c", ["    lastwin = wp;", "  else", "    before->w_prev = wp;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Remove a window from the window list."], "readability/old_style_comment"]
["src/nvim/window.c", [" */", "void ", "win_remove ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["void ", "win_remove (", "    win_T *wp,"], "whitespace/parens"]
["src/nvim/window.c", ["    win_T *wp,", "    tabpage_T *tp                /* tab page \"win\" is in, NULL for current */", ")"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Append frame \"frp\" in a frame list after frame \"after\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["  after->fr_next = frp;", "  if (frp->fr_next != NULL)", "    frp->fr_next->fr_prev = frp;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Insert frame \"frp\" in a frame list before frame \"before\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["  before->fr_prev = frp;", "  if (frp->fr_prev != NULL)", "    frp->fr_prev->fr_next = frp;"], "readability/braces"]
["src/nvim/window.c", ["    frp->fr_prev->fr_next = frp;", "  else", "    frp->fr_parent->fr_child = frp;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Remove a frame from a frame list."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Called from win_new_shellsize() after Rows changed."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  if (firstwin == NULL)         /* not initialized yet */", "    return;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  if (firstwin == NULL)         /* not initialized yet */", "    return;"], "readability/braces"]
["src/nvim/window.c", ["    return;", "  if (h < frame_minheight(topframe, NULL))", "    h = frame_minheight(topframe, NULL);"], "readability/braces"]
["src/nvim/window.c", ["", "  /* First try setting the heights of windows with 'winfixheight'.  If", "   * that doesn't result in the right height, forget about that option. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["   * that doesn't result in the right height, forget about that option. */", "  frame_new_height(topframe, h, FALSE, TRUE);", "  if (!frame_check_height(topframe, h))"], "readability/bool"]
["src/nvim/window.c", ["  frame_new_height(topframe, h, FALSE, TRUE);", "  if (!frame_check_height(topframe, h))", "    frame_new_height(topframe, h, FALSE, FALSE);"], "readability/braces"]
["src/nvim/window.c", ["  if (!frame_check_height(topframe, h))", "    frame_new_height(topframe, h, FALSE, FALSE);", ""], "readability/bool"]
["src/nvim/window.c", ["  curtab->tp_ch_used = p_ch;", "", "}"], "whitespace/blank_line"]
["src/nvim/window.c", ["", "/*", " * Called from win_new_shellsize() after Columns changed."], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  if (firstwin == NULL)         /* not initialized yet */", "    return;"], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  if (firstwin == NULL)         /* not initialized yet */", "    return;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* First try setting the widths of windows with 'winfixwidth'.  If that", "   * doesn't result in the right width, forget about that option. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Save the size of all windows in \"gap\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["    }", "    /* recompute the window positions */", "    (void)win_comp_pos();"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Update the position for all windows, using the width and height of the"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Update the position of the windows in frame \"topfrp\", using the width and"], "readability/old_style_comment"]
["src/nvim/window.c", ["        ) {", "      /* position changed, redraw */", "      wp->w_winrow = *row;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Set current window height and take care of repositioning other windows to"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Set the window height of window \"win\" and take care of repositioning other"], "readability/old_style_comment"]
["src/nvim/window.c", ["  }", "", "}"], "whitespace/blank_line"]
["src/nvim/window.c", ["", "/*", " * Set the height of a frame to \"height\" and take care that all frames and"], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  int room;                     /* total number of lines available */", "  int take;                     /* number of lines taken from other windows */"], "readability/old_style_comment"]
["src/nvim/window.c", ["  int room;                     /* total number of lines available */", "  int take;                     /* number of lines taken from other windows */", "  int room_cmdline;             /* lines available from cmdline */"], "readability/old_style_comment"]
["src/nvim/window.c", ["  int take;                     /* number of lines taken from other windows */", "  int room_cmdline;             /* lines available from cmdline */", "  int run;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* If the height already is the desired value, nothing to do. */", "  if (curfrp->fr_height == height)"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* If the height already is the desired value, nothing to do. */", "  if (curfrp->fr_height == height)", "    return;"], "readability/braces"]
["src/nvim/window.c", ["  if (curfrp->fr_parent == NULL) {", "    /* topframe: can only change the command line */", "    if (height > ROWS_AVAIL)"], "readability/old_style_comment"]
["src/nvim/window.c", ["    /* topframe: can only change the command line */", "    if (height > ROWS_AVAIL)", "      height = ROWS_AVAIL;"], "readability/braces"]
["src/nvim/window.c", ["      height = ROWS_AVAIL;", "    if (height > 0)", "      frame_new_height(curfrp, height, FALSE, FALSE);"], "readability/braces"]
["src/nvim/window.c", ["    if (height > 0)", "      frame_new_height(curfrp, height, FALSE, FALSE);", "  } else if (curfrp->fr_parent->fr_layout == FR_ROW) {"], "readability/bool"]
["src/nvim/window.c", ["  } else if (curfrp->fr_parent->fr_layout == FR_ROW) {", "    /* Row of frames: Also need to resize frames left and right of this", "     * one.  First check for the minimal height of these. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    h = frame_minheight(curfrp->fr_parent, NULL);", "    if (height < h)", "      height = h;"], "readability/braces"]
["src/nvim/window.c", ["  } else {", "    /*", "     * Column of frames: try to change only frames in this column."], "readability/old_style_comment"]
["src/nvim/window.c", ["     */", "    /*", "     * Do this twice:"], "readability/old_style_comment"]
["src/nvim/window.c", ["     */", "    for (run = 1; run <= 2; ++run) {", "      room = 0;"], "readability/increment"]
["src/nvim/window.c", ["      frame_setheight(curfrp->fr_parent, height", "          + frame_minheight(curfrp->fr_parent, NOWIN) - (int)p_wmh - 1);", "      /*NOTREACHED*/"], "whitespace/alignment"]
["src/nvim/window.c", ["          + frame_minheight(curfrp->fr_parent, NOWIN) - (int)p_wmh - 1);", "      /*NOTREACHED*/", "    }"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /*", "     * Compute the number of lines we will take from others frames (can be"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /* If there is not enough room, also reduce the height of a window", "     * with 'winfixheight' set. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["     * with 'winfixheight' set. */", "    if (height > room + room_cmdline - room_reserved)", "      room_reserved = room + room_cmdline - height;"], "readability/braces"]
["src/nvim/window.c", ["      room_reserved = room + room_cmdline - height;", "    /* If there is only a 'winfixheight' window and making the", "    * window smaller, need to make the other window taller. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    * window smaller, need to make the other window taller. */", "    if (take < 0 && room - curfrp->fr_height < room_reserved)", "      room_reserved = 0;"], "readability/braces"]
["src/nvim/window.c", ["    if (take > 0 && room_cmdline > 0) {", "      /* use lines from cmdline first */", "      if (take < room_cmdline)"], "readability/old_style_comment"]
["src/nvim/window.c", ["      /* use lines from cmdline first */", "      if (take < room_cmdline)", "        room_cmdline = take;"], "readability/braces"]
["src/nvim/window.c", ["", "    /*", "     * set the current frame to the new height"], "readability/old_style_comment"]
["src/nvim/window.c", ["     */", "    frame_new_height(curfrp, height, FALSE, FALSE);", ""], "readability/bool"]
["src/nvim/window.c", ["", "    /*", "     * First take lines from the frames after the current frame.  If"], "readability/old_style_comment"]
["src/nvim/window.c", ["     */", "    for (run = 0; run < 2; ++run) {", "      if (run == 0)"], "readability/increment"]
["src/nvim/window.c", ["    for (run = 0; run < 2; ++run) {", "      if (run == 0)", "        frp = curfrp->fr_next;          /* 1st run: start with next window */"], "readability/braces"]
["src/nvim/window.c", ["      if (run == 0)", "        frp = curfrp->fr_next;          /* 1st run: start with next window */", "      else"], "readability/old_style_comment"]
["src/nvim/window.c", ["        frp = curfrp->fr_next;          /* 1st run: start with next window */", "      else", "        frp = curfrp->fr_prev;          /* 2nd run: start with prev window */"], "readability/braces"]
["src/nvim/window.c", ["      else", "        frp = curfrp->fr_prev;          /* 2nd run: start with prev window */", "      while (frp != NULL && take != 0) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["            && frp->fr_win->w_p_wfh) {", "          if (room_reserved >= frp->fr_height)", "            room_reserved -= frp->fr_height;"], "readability/braces"]
["src/nvim/window.c", ["            room_reserved -= frp->fr_height;", "          else {", "            if (frp->fr_height - room_reserved > take)"], "readability/braces"]
["src/nvim/window.c", ["            room_reserved -= frp->fr_height;", "          else {", "            if (frp->fr_height - room_reserved > take)"], "readability/braces"]
["src/nvim/window.c", ["          else {", "            if (frp->fr_height - room_reserved > take)", "              room_reserved = frp->fr_height - take;"], "readability/braces"]
["src/nvim/window.c", ["            take -= frp->fr_height - room_reserved;", "            frame_new_height(frp, room_reserved, FALSE, FALSE);", "            room_reserved = 0;"], "readability/bool"]
["src/nvim/window.c", ["            take -= frp->fr_height - h;", "            frame_new_height(frp, h, FALSE, FALSE);", "          } else {"], "readability/bool"]
["src/nvim/window.c", ["            frame_new_height(frp, frp->fr_height - take,", "                FALSE, FALSE);", "            take = 0;"], "whitespace/alignment"]
["src/nvim/window.c", ["            frame_new_height(frp, frp->fr_height - take,", "                FALSE, FALSE);", "            take = 0;"], "readability/bool"]
["src/nvim/window.c", ["        }", "        if (run == 0)", "          frp = frp->fr_next;"], "readability/braces"]
["src/nvim/window.c", ["          frp = frp->fr_next;", "        else", "          frp = frp->fr_prev;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Set current window width and take care of repositioning other windows to"], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  /* Always keep current window at least one column wide, even when", "   * 'winminwidth' is zero. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (wp == curwin) {", "    if (width < p_wmw)", "      width = p_wmw;"], "readability/braces"]
["src/nvim/window.c", ["      width = p_wmw;", "    if (width == 0)", "      width = 1;"], "readability/braces"]
["src/nvim/window.c", ["  }", "", "}"], "whitespace/blank_line"]
["src/nvim/window.c", ["", "/*", " * Set the width of a frame to \"width\" and take care that all frames and"], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  int room;                     /* total number of lines available */", "  int take;                     /* number of lines taken from other windows */"], "readability/old_style_comment"]
["src/nvim/window.c", ["  int room;                     /* total number of lines available */", "  int take;                     /* number of lines taken from other windows */", "  int run;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* If the width already is the desired value, nothing to do. */", "  if (curfrp->fr_width == width)"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* If the width already is the desired value, nothing to do. */", "  if (curfrp->fr_width == width)", "    return;"], "readability/braces"]
["src/nvim/window.c", ["", "  if (curfrp->fr_parent == NULL)", "    /* topframe: can't change width */"], "readability/braces"]
["src/nvim/window.c", ["  if (curfrp->fr_parent == NULL)", "    /* topframe: can't change width */", "    return;"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (curfrp->fr_parent->fr_layout == FR_COL) {", "    /* Column of frames: Also need to resize frames above and below of", "     * this one.  First check for the minimal width of these. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    w = frame_minwidth(curfrp->fr_parent, NULL);", "    if (width < w)", "      width = w;"], "readability/braces"]
["src/nvim/window.c", ["  } else {", "    /*", "     * Row of frames: try to change only frames in this row."], "readability/old_style_comment"]
["src/nvim/window.c", ["     */", "    for (run = 1; run <= 2; ++run) {", "      room = 0;"], "readability/increment"]
["src/nvim/window.c", ["", "      if (width <= room)", "        break;"], "readability/braces"]
["src/nvim/window.c", ["      frame_setwidth(curfrp->fr_parent, width", "          + frame_minwidth(curfrp->fr_parent, NOWIN) - (int)p_wmw - 1);", "    }"], "whitespace/alignment"]
["src/nvim/window.c", ["", "    /*", "     * Compute the number of lines we will take from others frames (can be"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /* If there is not enough room, also reduce the width of a window", "     * with 'winfixwidth' set. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["     * with 'winfixwidth' set. */", "    if (width > room - room_reserved)", "      room_reserved = room - width;"], "readability/braces"]
["src/nvim/window.c", ["      room_reserved = room - width;", "    /* If there is only a 'winfixwidth' window and making the", "     * window smaller, need to make the other window narrower. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["     * window smaller, need to make the other window narrower. */", "    if (take < 0 && room - curfrp->fr_width < room_reserved)", "      room_reserved = 0;"], "readability/braces"]
["src/nvim/window.c", ["", "    /*", "     * set the current frame to the new width"], "readability/old_style_comment"]
["src/nvim/window.c", ["     */", "    frame_new_width(curfrp, width, FALSE, FALSE);", ""], "readability/bool"]
["src/nvim/window.c", ["", "    /*", "     * First take lines from the frames right of the current frame.  If"], "readability/old_style_comment"]
["src/nvim/window.c", ["     */", "    for (run = 0; run < 2; ++run) {", "      if (run == 0)"], "readability/increment"]
["src/nvim/window.c", ["    for (run = 0; run < 2; ++run) {", "      if (run == 0)", "        frp = curfrp->fr_next;          /* 1st run: start with next window */"], "readability/braces"]
["src/nvim/window.c", ["      if (run == 0)", "        frp = curfrp->fr_next;          /* 1st run: start with next window */", "      else"], "readability/old_style_comment"]
["src/nvim/window.c", ["        frp = curfrp->fr_next;          /* 1st run: start with next window */", "      else", "        frp = curfrp->fr_prev;          /* 2nd run: start with prev window */"], "readability/braces"]
["src/nvim/window.c", ["      else", "        frp = curfrp->fr_prev;          /* 2nd run: start with prev window */", "      while (frp != NULL && take != 0) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["            && frp->fr_win->w_p_wfw) {", "          if (room_reserved >= frp->fr_width)", "            room_reserved -= frp->fr_width;"], "readability/braces"]
["src/nvim/window.c", ["            room_reserved -= frp->fr_width;", "          else {", "            if (frp->fr_width - room_reserved > take)"], "readability/braces"]
["src/nvim/window.c", ["            room_reserved -= frp->fr_width;", "          else {", "            if (frp->fr_width - room_reserved > take)"], "readability/braces"]
["src/nvim/window.c", ["          else {", "            if (frp->fr_width - room_reserved > take)", "              room_reserved = frp->fr_width - take;"], "readability/braces"]
["src/nvim/window.c", ["            take -= frp->fr_width - room_reserved;", "            frame_new_width(frp, room_reserved, FALSE, FALSE);", "            room_reserved = 0;"], "readability/bool"]
["src/nvim/window.c", ["            take -= frp->fr_width - w;", "            frame_new_width(frp, w, FALSE, FALSE);", "          } else {"], "readability/bool"]
["src/nvim/window.c", ["            frame_new_width(frp, frp->fr_width - take,", "                FALSE, FALSE);", "            take = 0;"], "whitespace/alignment"]
["src/nvim/window.c", ["            frame_new_width(frp, frp->fr_width - take,", "                FALSE, FALSE);", "            take = 0;"], "readability/bool"]
["src/nvim/window.c", ["        }", "        if (run == 0)", "          frp = frp->fr_next;"], "readability/braces"]
["src/nvim/window.c", ["          frp = frp->fr_next;", "        else", "          frp = frp->fr_prev;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Status line of dragwin is dragged \"offset\" lines down (negative is up)."], "readability/old_style_comment"]
["src/nvim/window.c", ["  int row;", "  int up;               /* if TRUE, drag status line up, otherwise down */", "  int n;"], "readability/old_style_comment"]
["src/nvim/window.c", ["  curfr = fr;", "  if (fr != topframe) {         /* more than one window */", "    fr = fr->fr_parent;"], "readability/old_style_comment"]
["src/nvim/window.c", ["    fr = fr->fr_parent;", "    /* When the parent frame is not a column of frames, its parent should", "     * be. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["      curfr = fr;", "      if (fr != topframe)       /* only a row of windows, may drag statusline */", "        fr = fr->fr_parent;"], "readability/old_style_comment"]
["src/nvim/window.c", ["      curfr = fr;", "      if (fr != topframe)       /* only a row of windows, may drag statusline */", "        fr = fr->fr_parent;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* If this is the last frame in a column, may want to resize the parent", "   * frame instead (go two up to skip a row of frames). */"], "readability/old_style_comment"]
["src/nvim/window.c", ["  while (curfr != topframe && curfr->fr_next == NULL) {", "    if (fr != topframe)", "      fr = fr->fr_parent;"], "readability/braces"]
["src/nvim/window.c", ["    curfr = fr;", "    if (fr != topframe)", "      fr = fr->fr_parent;"], "readability/braces"]
["src/nvim/window.c", ["", "  if (offset < 0) { /* drag up */", "    up = TRUE;"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (offset < 0) { /* drag up */", "    up = TRUE;", "    offset = -offset;"], "readability/bool"]
["src/nvim/window.c", ["    offset = -offset;", "    /* sum up the room of the current frame and above it */", "    if (fr == curfr) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (fr == curfr) {", "      /* only one window */", "      room = fr->fr_height - frame_minheight(fr, NULL);"], "readability/old_style_comment"]
["src/nvim/window.c", ["        room += fr->fr_height - frame_minheight(fr, NULL);", "        if (fr == curfr)", "          break;"], "readability/braces"]
["src/nvim/window.c", ["    }", "    fr = curfr->fr_next;                /* put fr at frame that grows */", "  } else { /* drag down */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    fr = curfr->fr_next;                /* put fr at frame that grows */", "  } else { /* drag down */", "    up = FALSE;"], "readability/old_style_comment"]
["src/nvim/window.c", ["  } else { /* drag down */", "    up = FALSE;", "    /*"], "readability/bool"]
["src/nvim/window.c", ["    up = FALSE;", "    /*", "     * Only dragging the last status line can reduce p_ch."], "readability/old_style_comment"]
["src/nvim/window.c", ["    room = Rows - cmdline_row;", "    if (curfr->fr_next == NULL)", "      room -= 1;"], "readability/braces"]
["src/nvim/window.c", ["      room -= 1;", "    else", "      room -= p_ch;"], "readability/braces"]
["src/nvim/window.c", ["      room -= p_ch;", "    if (room < 0)", "      room = 0;"], "readability/braces"]
["src/nvim/window.c", ["", "  if (room < offset)            /* Not enough room */", "    offset = room;              /* Move as far as we can */"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  if (room < offset)            /* Not enough room */", "    offset = room;              /* Move as far as we can */"], "readability/braces"]
["src/nvim/window.c", ["  if (room < offset)            /* Not enough room */", "    offset = room;              /* Move as far as we can */", "  if (offset <= 0)"], "readability/old_style_comment"]
["src/nvim/window.c", ["    offset = room;              /* Move as far as we can */", "  if (offset <= 0)", "    return;"], "readability/braces"]
["src/nvim/window.c", ["", "  /*", "   * Grow frame fr by \"offset\" lines."], "readability/old_style_comment"]
["src/nvim/window.c", ["   */", "  if (fr != NULL)", "    frame_new_height(fr, fr->fr_height + offset, up, FALSE);"], "readability/braces"]
["src/nvim/window.c", ["  if (fr != NULL)", "    frame_new_height(fr, fr->fr_height + offset, up, FALSE);", ""], "readability/bool"]
["src/nvim/window.c", ["", "  if (up)", "    fr = curfr;                 /* current frame gets smaller */"], "readability/braces"]
["src/nvim/window.c", ["  if (up)", "    fr = curfr;                 /* current frame gets smaller */", "  else"], "readability/old_style_comment"]
["src/nvim/window.c", ["    fr = curfr;                 /* current frame gets smaller */", "  else", "    fr = curfr->fr_next;        /* next frame gets smaller */"], "readability/braces"]
["src/nvim/window.c", ["  else", "    fr = curfr->fr_next;        /* next frame gets smaller */", ""], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /*", "   * Now make the other frames smaller."], "readability/old_style_comment"]
["src/nvim/window.c", ["      offset -= fr->fr_height - n;", "      frame_new_height(fr, n, !up, FALSE);", "    } else {"], "readability/bool"]
["src/nvim/window.c", ["    } else {", "      frame_new_height(fr, fr->fr_height - offset, !up, FALSE);", "      break;"], "readability/bool"]
["src/nvim/window.c", ["    }", "    if (up)", "      fr = fr->fr_prev;"], "readability/braces"]
["src/nvim/window.c", ["      fr = fr->fr_prev;", "    else", "      fr = fr->fr_next;"], "readability/braces"]
["src/nvim/window.c", ["  p_ch = Rows - cmdline_row;", "  if (p_ch < 1)", "    p_ch = 1;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Separator line of dragwin is dragged \"offset\" lines right (negative is left)."], "readability/old_style_comment"]
["src/nvim/window.c", ["  int room;", "  int left;             /* if TRUE, drag separator line left, otherwise right */", "  int n;"], "readability/old_style_comment"]
["src/nvim/window.c", ["  fr = dragwin->w_frame;", "  if (fr == topframe)           /* only one window (cannot happen?) */", "    return;"], "readability/old_style_comment"]
["src/nvim/window.c", ["  fr = dragwin->w_frame;", "  if (fr == topframe)           /* only one window (cannot happen?) */", "    return;"], "readability/braces"]
["src/nvim/window.c", ["  fr = fr->fr_parent;", "  /* When the parent frame is not a row of frames, its parent should be. */", "  if (fr->fr_layout != FR_ROW) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (fr->fr_layout != FR_ROW) {", "    if (fr == topframe)         /* only a column of windows (cannot happen?) */", "      return;"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (fr->fr_layout != FR_ROW) {", "    if (fr == topframe)         /* only a column of windows (cannot happen?) */", "      return;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* If this is the last frame in a row, may want to resize a parent", "   * frame instead. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["  while (curfr->fr_next == NULL) {", "    if (fr == topframe)", "      break;"], "readability/braces"]
["src/nvim/window.c", ["", "  if (offset < 0) { /* drag left */", "    left = TRUE;"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (offset < 0) { /* drag left */", "    left = TRUE;", "    offset = -offset;"], "readability/bool"]
["src/nvim/window.c", ["    offset = -offset;", "    /* sum up the room of the current frame and left of it */", "    room = 0;"], "readability/old_style_comment"]
["src/nvim/window.c", ["      room += fr->fr_width - frame_minwidth(fr, NULL);", "      if (fr == curfr)", "        break;"], "readability/braces"]
["src/nvim/window.c", ["    }", "    fr = curfr->fr_next;                /* put fr at frame that grows */", "  } else { /* drag right */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    fr = curfr->fr_next;                /* put fr at frame that grows */", "  } else { /* drag right */", "    left = FALSE;"], "readability/old_style_comment"]
["src/nvim/window.c", ["  } else { /* drag right */", "    left = FALSE;", "    /* sum up the room of frames right of the current one */"], "readability/bool"]
["src/nvim/window.c", ["    left = FALSE;", "    /* sum up the room of frames right of the current one */", "    room = 0;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* grow frame fr by offset lines */", "  frame_new_width(fr, fr->fr_width + offset, left, FALSE);"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* grow frame fr by offset lines */", "  frame_new_width(fr, fr->fr_width + offset, left, FALSE);", ""], "readability/bool"]
["src/nvim/window.c", ["", "  /* shrink other frames: current and at the left or at the right */", "  if (left)"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* shrink other frames: current and at the left or at the right */", "  if (left)", "    fr = curfr;                 /* current frame gets smaller */"], "readability/braces"]
["src/nvim/window.c", ["  if (left)", "    fr = curfr;                 /* current frame gets smaller */", "  else"], "readability/old_style_comment"]
["src/nvim/window.c", ["    fr = curfr;                 /* current frame gets smaller */", "  else", "    fr = curfr->fr_next;        /* next frame gets smaller */"], "readability/braces"]
["src/nvim/window.c", ["  else", "    fr = curfr->fr_next;        /* next frame gets smaller */", ""], "readability/old_style_comment"]
["src/nvim/window.c", ["      offset -= fr->fr_width - n;", "      frame_new_width(fr, n, !left, FALSE);", "    } else {"], "readability/bool"]
["src/nvim/window.c", ["    } else {", "      frame_new_width(fr, fr->fr_width - offset, !left, FALSE);", "      break;"], "readability/bool"]
["src/nvim/window.c", ["    }", "    if (left)", "      fr = fr->fr_prev;"], "readability/braces"]
["src/nvim/window.c", ["      fr = fr->fr_prev;", "    else", "      fr = fr->fr_next;"], "readability/braces"]
["src/nvim/window.c", ["      ) {", "    /*", "     * Find a value for w_topline that shows the cursor at the same"], "readability/old_style_comment"]
["src/nvim/window.c", ["    lnum = wp->w_cursor.lnum;", "    if (lnum < 1)               /* can happen when starting up */", "      lnum = 1;"], "readability/old_style_comment"]
["src/nvim/window.c", ["    lnum = wp->w_cursor.lnum;", "    if (lnum < 1)               /* can happen when starting up */", "      lnum = 1;"], "readability/braces"]
["src/nvim/window.c", ["    if (sline < 0) {", "      /*", "       * Cursor line would go off top of screen if w_wrow was this high."], "readability/old_style_comment"]
["src/nvim/window.c", ["        if (lnum == 1) {", "          /* first line in buffer is folded */", "          line_size = 1;"], "readability/old_style_comment"]
["src/nvim/window.c", ["          line_size = 1;", "          --sline;", "          break;"], "readability/increment"]
["src/nvim/window.c", ["      if (sline < 0) {", "        /*", "         * Line we want at top would go off top of screen.  Use next"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * command_height: called whenever p_ch has been changed"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Use the value of p_ch that we remembered.  This is needed for when the", "   * GUI starts up, we can't be sure in what order things happen.  And when"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Avoid changing the height of a window with 'winfixheight' set. */", "  while (frp->fr_prev != NULL && frp->fr_layout == FR_LEAF"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* Avoid changing the height of a window with 'winfixheight' set. */", "  while (frp->fr_prev != NULL && frp->fr_layout == FR_LEAF", "         && frp->fr_win->w_p_wfh)"], "readability/braces"]
["src/nvim/window.c", ["", "    if (p_ch > old_p_ch) {                  /* p_ch got bigger */", "      while (p_ch > old_p_ch) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["        h = frp->fr_height - frame_minheight(frp, NULL);", "        if (h > p_ch - old_p_ch)", "          h = p_ch - old_p_ch;"], "readability/braces"]
["src/nvim/window.c", ["", "      /* Recompute window positions. */", "      (void)win_comp_pos();"], "readability/old_style_comment"]
["src/nvim/window.c", ["      msg_row = cmdline_row;", "      redraw_cmdline = TRUE;", "      return;"], "readability/bool"]
["src/nvim/window.c", ["", "    if (msg_row < cmdline_row)", "      msg_row = cmdline_row;"], "readability/braces"]
["src/nvim/window.c", ["      msg_row = cmdline_row;", "    redraw_cmdline = TRUE;", "  }"], "readability/bool"]
["src/nvim/window.c", ["", "  /* Recompute window positions. */", "  if (frp != lastwin->w_frame)"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* Recompute window positions. */", "  if (frp != lastwin->w_frame)", "    (void)win_comp_pos();"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Resize frame \"frp\" to be \"n\" lines higher (negative for less high)."], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  frame_new_height(frp, frp->fr_height + n, FALSE, FALSE);", "  for (;; ) {"], "readability/bool"]
["src/nvim/window.c", ["    frp = frp->fr_parent;", "    if (frp == NULL)", "      break;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Get the file name at the cursor."], "readability/old_style_comment"]
["src/nvim/window.c", ["    char_u  *ptr;", "    if (get_visual_text(NULL, &ptr, &len) == FAIL)", "      return NULL;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Return the file name under or after the cursor."], "readability/old_style_comment"]
["src/nvim/window.c", ["  return file_name_in_line(get_cursor_line_ptr(),", "      curwin->w_cursor.col, options, count, curbuf->b_ffname,", "      file_lnum);"], "whitespace/alignment"]
["src/nvim/window.c", ["      curwin->w_cursor.col, options, count, curbuf->b_ffname,", "      file_lnum);", "}"], "whitespace/alignment"]
["src/nvim/window.c", ["", "/*", " * Return the name of the file under or after ptr[col]."], "readability/old_style_comment"]
["src/nvim/window.c", ["char_u *", "file_name_in_line (", "    char_u *line,"], "whitespace/parens"]
["src/nvim/window.c", ["    long count,", "    char_u *rel_fname,         /* file we are searching relative to */", "    linenr_T *file_lnum         /* line number after the file name */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    char_u *rel_fname,         /* file we are searching relative to */", "    linenr_T *file_lnum         /* line number after the file name */", ")"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /*", "   * search forward for what could be the start of a file name"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /*", "   * Search backward for first char of the file name."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /*", "   * Search forward for the last char of the file name."], "readability/old_style_comment"]
["src/nvim/window.c", ["      // Skip over the \"\\\" in \"\\ \".", "      ++len;", "    }"], "readability/increment"]
["src/nvim/window.c", ["", "  /*", "   * If there is trailing punctuation, remove it."], "readability/old_style_comment"]
["src/nvim/window.c", ["   */", "  if (len > 2 && vim_strchr((char_u *)\".,:;!\", ptr[len - 1]) != NULL", "      && ptr[len - 2] != '.')"], "readability/braces"]
["src/nvim/window.c", ["      && ptr[len - 2] != '.')", "    --len;", ""], "readability/increment"]
["src/nvim/window.c", ["", "/*", " * Add or remove a status line for the bottom window(s), according to the"], "readability/old_style_comment"]
["src/nvim/window.c", [" */", "void ", "last_status ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["void ", "last_status (", "    int morewin                    /* pretend there are two or more windows */"], "whitespace/parens"]
["src/nvim/window.c", ["last_status (", "    int morewin                    /* pretend there are two or more windows */", ")"], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  /* Don't make a difference between horizontal or vertical split. */", "  last_status_rec(topframe, (p_ls == 2"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (wp->w_status_height != 0 && !statusline) {", "      /* remove status line */", "      win_new_height(wp, wp->w_height + 1);"], "readability/old_style_comment"]
["src/nvim/window.c", ["    } else if (wp->w_status_height == 0 && statusline) {", "      /* Find a frame to take a line from. */", "      fp = fr;"], "readability/old_style_comment"]
["src/nvim/window.c", ["        }", "        /* In a column of frames: go to frame above.  If already at", "         * the top or in a row of frames: go to parent. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["         * the top or in a row of frames: go to parent. */", "        if (fp->fr_parent->fr_layout == FR_COL && fp->fr_prev != NULL)", "          fp = fp->fr_prev;"], "readability/braces"]
["src/nvim/window.c", ["          fp = fp->fr_prev;", "        else", "          fp = fp->fr_parent;"], "readability/braces"]
["src/nvim/window.c", ["      if (fp != fr) {", "        frame_new_height(fp, fp->fr_height - 1, FALSE, FALSE);", "        frame_fix_height(wp);"], "readability/bool"]
["src/nvim/window.c", ["        (void)win_comp_pos();", "      } else", "        win_new_height(wp, wp->w_height - 1);"], "readability/braces"]
["src/nvim/window.c", ["  } else {", "    /* horizontally split window, set status line for last one */", "    for (fp = fr->fr_child; fp->fr_next != NULL; fp = fp->fr_next)"], "readability/old_style_comment"]
["src/nvim/window.c", ["    /* horizontally split window, set status line for last one */", "    for (fp = fr->fr_child; fp->fr_next != NULL; fp = fp->fr_next)", "      ;"], "readability/braces"]
["src/nvim/window.c", ["    for (fp = fr->fr_child; fp->fr_next != NULL; fp = fp->fr_next)", "      ;", "    last_status_rec(fp, statusline);"], "whitespace/semicolon"]
["src/nvim/window.c", ["", "/*", " * Return the number of lines used by the tab page line."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Return the minimal number of rows that is needed on the screen to display"], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  if (firstwin == NULL)         /* not initialized yet */", "    return MIN_LINES;"], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  if (firstwin == NULL)         /* not initialized yet */", "    return MIN_LINES;"], "readability/braces"]
["src/nvim/window.c", ["  total += tabline_height();", "  total += 1;           /* count the room for the command line */", "  return total;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Correct the cursor line number in other windows.  Used after changing the"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * A snapshot of the window sizes, to restore them after closing the help"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Create a snapshot of the current frame sizes."], "readability/old_style_comment"]
["src/nvim/window.c", ["  (*frp)->fr_height = fr->fr_height;", "  if (fr->fr_next != NULL)", "    make_snapshot_rec(fr->fr_next, &((*frp)->fr_next));"], "readability/braces"]
["src/nvim/window.c", ["    make_snapshot_rec(fr->fr_next, &((*frp)->fr_next));", "  if (fr->fr_child != NULL)", "    make_snapshot_rec(fr->fr_child, &((*frp)->fr_child));"], "readability/braces"]
["src/nvim/window.c", ["    make_snapshot_rec(fr->fr_child, &((*frp)->fr_child));", "  if (fr->fr_layout == FR_LEAF && fr->fr_win == curwin)", "    (*frp)->fr_win = curwin;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Remove any existing snapshot."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Restore a previously created snapshot, if there is any."], "readability/old_style_comment"]
["src/nvim/window.c", [" */", "void ", "restore_snapshot ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["void ", "restore_snapshot (", "    int idx,"], "whitespace/parens"]
["src/nvim/window.c", ["    int idx,", "    int close_curwin                   /* closing current window */", ")"], "readability/old_style_comment"]
["src/nvim/window.c", ["    win_comp_pos();", "    if (wp != NULL && close_curwin)", "      win_goto(wp);"], "readability/braces"]
["src/nvim/window.c", ["{", "  if (sn->fr_layout != fr->fr_layout", "      || (sn->fr_next == NULL) != (fr->fr_next == NULL)"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Copy the size of snapshot frame \"sn\" to frame \"fr\".  Do the same for all"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (fr->fr_layout == FR_LEAF) {", "    frame_new_height(fr, fr->fr_height, FALSE, FALSE);", "    frame_new_width(fr, fr->fr_width, FALSE, FALSE);"], "readability/bool"]
["src/nvim/window.c", ["    frame_new_height(fr, fr->fr_height, FALSE, FALSE);", "    frame_new_width(fr, fr->fr_width, FALSE, FALSE);", "    wp = sn->fr_win;"], "readability/bool"]
["src/nvim/window.c", ["    wp2 = restore_snapshot_rec(sn->fr_next, fr->fr_next);", "    if (wp2 != NULL)", "      wp = wp2;"], "readability/braces"]
["src/nvim/window.c", ["    wp2 = restore_snapshot_rec(sn->fr_child, fr->fr_child);", "    if (wp2 != NULL)", "      wp = wp2;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Set \"win\" to be the curwin and \"tp\" to be the current tab page."], "readability/old_style_comment"]
["src/nvim/window.c", [" */", "int switch_win(win_T **save_curwin, tabpage_T **save_curtab, win_T *win, tabpage_T *tp, int no_display)", "{"], "whitespace/line_length"]
["src/nvim/window.c", ["      lastwin = curtab->tp_lastwin;", "    } else", "      goto_tabpage_tp(tp, FALSE, FALSE);"], "readability/braces"]
["src/nvim/window.c", ["    } else", "      goto_tabpage_tp(tp, FALSE, FALSE);", "  }"], "readability/bool"]
["src/nvim/window.c", ["      lastwin = curtab->tp_lastwin;", "    } else", "      goto_tabpage_tp(save_curtab, FALSE, FALSE);"], "readability/braces"]
["src/nvim/window.c", ["    } else", "      goto_tabpage_tp(save_curtab, FALSE, FALSE);", "  }"], "readability/bool"]
["src/nvim/window.c", ["    cur = wp->w_match_head;", "    while (cur != NULL && cur->id != wp->w_next_match_id)", "      cur = cur->next;"], "readability/braces"]
["src/nvim/window.c", ["      cur = cur->next;", "    if (cur == NULL)", "      id = wp->w_next_match_id;"], "readability/braces"]
["src/nvim/window.c", ["  m->match.regprog = regprog;", "  m->match.rmm_ic = FALSE;", "  m->match.rmm_maxcol = 0;"], "readability/bool"]
["src/nvim/window.c", ["", "    // Calculate top and bottom lines for redrawing area ", "    if (toplnum != 0){"], "whitespace/end_of_line"]
["src/nvim/window.c", ["    // Calculate top and bottom lines for redrawing area ", "    if (toplnum != 0){", "      if (wp->w_buffer->b_mod_set) {"], "whitespace/braces"]
["src/nvim/window.c", ["  }", "  if (cur == prev)", "    wp->w_match_head = m;"], "readability/braces"]
["src/nvim/window.c", ["    wp->w_match_head = m;", "  else", "    prev->next = m;"], "readability/braces"]
["src/nvim/window.c", ["  }", "  if (cur == prev)", "    wp->w_match_head = cur->next;"], "readability/braces"]
["src/nvim/window.c", ["    wp->w_match_head = cur->next;", "  else", "    prev->next = cur->next;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Delete all matches in the match list of window 'wp'."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Get match from ID 'id' in window 'wp'."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  while (cur != NULL && cur->id != id)", "    cur = cur->next;"], "readability/braces"]
["src/nvim/window.h", ["", "/* Values for file_name_in_line() */", "#define FNAME_MESS      1       /* give error message */"], "readability/old_style_comment"]
["src/nvim/window.h", ["/* Values for file_name_in_line() */", "#define FNAME_MESS      1       /* give error message */", "#define FNAME_EXP       2       /* expand to path */"], "readability/old_style_comment"]
["src/nvim/window.h", ["#define FNAME_MESS      1       /* give error message */", "#define FNAME_EXP       2       /* expand to path */", "#define FNAME_HYP       4       /* check for hypertext link */"], "readability/old_style_comment"]
["src/nvim/window.h", ["#define FNAME_EXP       2       /* expand to path */", "#define FNAME_HYP       4       /* check for hypertext link */", "#define FNAME_INCL      8       /* apply 'includeexpr' */"], "readability/old_style_comment"]
["src/nvim/window.h", ["#define FNAME_HYP       4       /* check for hypertext link */", "#define FNAME_INCL      8       /* apply 'includeexpr' */", "#define FNAME_REL       16      /* \"..\" and \"./\" are relative to the (current)"], "readability/old_style_comment"]
["src/nvim/window.h", ["#define FNAME_INCL      8       /* apply 'includeexpr' */", "#define FNAME_REL       16      /* \"..\" and \"./\" are relative to the (current)", "                                   file instead of the current directory */"], "readability/multiline_comment"]
["src/nvim/window.h", ["#define FNAME_INCL      8       /* apply 'includeexpr' */", "#define FNAME_REL       16      /* \"..\" and \"./\" are relative to the (current)", "                                   file instead of the current directory */"], "readability/old_style_comment"]
["src/nvim/window.h", ["", "/*", " * arguments for win_split()"], "readability/old_style_comment"]
["src/nvim/window.h", [" */", "#define WSP_ROOM        1       /* require enough room */", "#define WSP_VERT        2       /* split vertically */"], "readability/old_style_comment"]
["src/nvim/window.h", ["#define WSP_ROOM        1       /* require enough room */", "#define WSP_VERT        2       /* split vertically */", "#define WSP_TOP         4       /* window at top-left of shell */"], "readability/old_style_comment"]
["src/nvim/window.h", ["#define WSP_VERT        2       /* split vertically */", "#define WSP_TOP         4       /* window at top-left of shell */", "#define WSP_BOT         8       /* window at bottom-right of shell */"], "readability/old_style_comment"]
["src/nvim/window.h", ["#define WSP_TOP         4       /* window at top-left of shell */", "#define WSP_BOT         8       /* window at bottom-right of shell */", "#define WSP_HELP        16      /* creating the help window */"], "readability/old_style_comment"]
["src/nvim/window.h", ["#define WSP_BOT         8       /* window at bottom-right of shell */", "#define WSP_HELP        16      /* creating the help window */", "#define WSP_BELOW       32      /* put new window below/right */"], "readability/old_style_comment"]
["src/nvim/window.h", ["#define WSP_HELP        16      /* creating the help window */", "#define WSP_BELOW       32      /* put new window below/right */", "#define WSP_ABOVE       64      /* put new window above/left */"], "readability/old_style_comment"]
["src/nvim/window.h", ["#define WSP_BELOW       32      /* put new window below/right */", "#define WSP_ABOVE       64      /* put new window above/left */", "#define WSP_NEWLOC      128     /* don't copy location list */"], "readability/old_style_comment"]
["src/nvim/window.h", ["#define WSP_ABOVE       64      /* put new window above/left */", "#define WSP_NEWLOC      128     /* don't copy location list */", ""], "readability/old_style_comment"]
["src/nvim/window.h", ["", "/*", " * Minimum screen size"], "readability/old_style_comment"]
["src/nvim/window.h", [" */", "#define MIN_COLUMNS     12      /* minimal columns for screen */", "#define MIN_LINES       2       /* minimal lines for screen */"], "readability/old_style_comment"]
["src/nvim/window.h", ["#define MIN_COLUMNS     12      /* minimal columns for screen */", "#define MIN_LINES       2       /* minimal lines for screen */", ""], "readability/old_style_comment"]
