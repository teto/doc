["src/nvim/mark.c", ["", "/*", " * mark.c: functions for setting marks and jumping to them"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * This file contains routines to maintain and manipulate marks."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * If a named file mark's lnum is non-zero, it is valid."], "readability/old_style_comment"]
["src/nvim/mark.c", ["#endif", "/*", " * Set named mark \"c\" at current cursor position."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * Set named mark \"c\" to position \"pos\"."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* Check for a special key (may cause islower() to crash). */", "  if (c < 0)"], "readability/old_style_comment"]
["src/nvim/mark.c", ["  /* Check for a special key (may cause islower() to crash). */", "  if (c < 0)", "    return FAIL;"], "readability/braces"]
["src/nvim/mark.c", ["      setpcmark();", "      /* keep it even when the cursor doesn't move */", "      curwin->w_prev_pcmark = curwin->w_pcmark;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["      curwin->w_prev_pcmark = curwin->w_pcmark;", "    } else", "      curwin->w_pcmark = *pos;"], "readability/braces"]
["src/nvim/mark.c", ["", "  /* Allow setting '[ and '] for an autocommand that simulates reading a", "   * file. */"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * Set the previous context mark to the current position and add it to the"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* for :global the mark is set only once */", "  if (global_busy || listcmd_busy || cmdmod.keepjumps)"], "readability/old_style_comment"]
["src/nvim/mark.c", ["  /* for :global the mark is set only once */", "  if (global_busy || listcmd_busy || cmdmod.keepjumps)", "    return;"], "readability/braces"]
["src/nvim/mark.c", ["", "  /* If jumplist is full: remove oldest entry */", "  if (++curwin->w_jumplistlen > JUMPLISTSIZE) {"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * To change context, call setpcmark(), then move the current position to"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    curwin->w_pcmark = curwin->w_prev_pcmark;", "    curwin->w_prev_pcmark.lnum = 0;             /* Show it has been checked */", "  }"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * move \"count\" positions in the jump list (count may be negative)"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  if (curwin->w_jumplistlen == 0)           /* nothing to jump to */", "    return (pos_T *)NULL;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  if (curwin->w_jumplistlen == 0)           /* nothing to jump to */", "    return (pos_T *)NULL;"], "readability/braces"]
["src/nvim/mark.c", ["  for (;; ) {", "    if (curwin->w_jumplistidx + count < 0", "        || curwin->w_jumplistidx + count >= curwin->w_jumplistlen)"], "readability/braces"]
["src/nvim/mark.c", ["", "    /*", "     * if first CTRL-O or CTRL-I command after a jump, add cursor position"], "readability/old_style_comment"]
["src/nvim/mark.c", ["      setpcmark();", "      --curwin->w_jumplistidx;          /* skip the new entry */", "      if (curwin->w_jumplistidx + count < 0)"], "readability/old_style_comment"]
["src/nvim/mark.c", ["      setpcmark();", "      --curwin->w_jumplistidx;          /* skip the new entry */", "      if (curwin->w_jumplistidx + count < 0)"], "readability/increment"]
["src/nvim/mark.c", ["      --curwin->w_jumplistidx;          /* skip the new entry */", "      if (curwin->w_jumplistidx + count < 0)", "        return (pos_T *)NULL;"], "readability/braces"]
["src/nvim/mark.c", ["    jmp = curwin->w_jumplist + curwin->w_jumplistidx;", "    if (jmp->fmark.fnum == 0)", "      fname2fnum(jmp);"], "readability/braces"]
["src/nvim/mark.c", ["    if (jmp->fmark.fnum != curbuf->b_fnum) {", "      /* jump to other file */", "      if (buflist_findnr(jmp->fmark.fnum) == NULL) { /* Skip this one .. */"], "readability/old_style_comment"]
["src/nvim/mark.c", ["      /* jump to other file */", "      if (buflist_findnr(jmp->fmark.fnum) == NULL) { /* Skip this one .. */", "        count += count < 0 ? -1 : 1;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["      }", "      if (buflist_getfile(jmp->fmark.fnum, jmp->fmark.mark.lnum,", "              0, FALSE) == FAIL)"], "readability/braces"]
["src/nvim/mark.c", ["      if (buflist_getfile(jmp->fmark.fnum, jmp->fmark.mark.lnum,", "              0, FALSE) == FAIL)", "        return (pos_T *)NULL;"], "whitespace/alignment"]
["src/nvim/mark.c", ["      if (buflist_getfile(jmp->fmark.fnum, jmp->fmark.mark.lnum,", "              0, FALSE) == FAIL)", "        return (pos_T *)NULL;"], "readability/bool"]
["src/nvim/mark.c", ["        return (pos_T *)NULL;", "      /* Set lnum again, autocommands my have changed it */", "      curwin->w_cursor = jmp->fmark.mark;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["      pos = (pos_T *)-1;", "    } else", "      pos = &(jmp->fmark.mark);"], "readability/braces"]
["src/nvim/mark.c", ["", "/*", " * Move \"count\" positions in the changelist (count may be negative)."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  if (curbuf->b_changelistlen == 0)         /* nothing to jump to */", "    return (pos_T *)NULL;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  if (curbuf->b_changelistlen == 0)         /* nothing to jump to */", "    return (pos_T *)NULL;"], "readability/braces"]
["src/nvim/mark.c", ["  if (n + count < 0) {", "    if (n == 0)", "      return (pos_T *)NULL;"], "readability/braces"]
["src/nvim/mark.c", ["  } else if (n + count >= curbuf->b_changelistlen) {", "    if (n == curbuf->b_changelistlen - 1)", "      return (pos_T *)NULL;"], "readability/braces"]
["src/nvim/mark.c", ["    n = curbuf->b_changelistlen - 1;", "  } else", "    n += count;"], "readability/braces"]
["src/nvim/mark.c", ["", "/*", " * Find mark \"c\" in buffer pointed to by \"buf\"."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* Check for special key, can't be a mark name and might cause islower()", "   * to crash. */"], "readability/old_style_comment"]
["src/nvim/mark.c", ["   * to crash. */", "  if (c < 0)", "    return posp;"], "readability/braces"]
["src/nvim/mark.c", ["    pos = curwin->w_cursor;", "    listcmd_busy = TRUE;            /* avoid that '' is changed */", "    if (findpar(&oa.inclusive,"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    pos = curwin->w_cursor;", "    listcmd_busy = TRUE;            /* avoid that '' is changed */", "    if (findpar(&oa.inclusive,"], "readability/bool"]
["src/nvim/mark.c", ["    if (findpar(&oa.inclusive,", "            c == '}' ? FORWARD : BACKWARD, 1L, NUL, FALSE)) {", "      pos_copy = curwin->w_cursor;"], "whitespace/alignment"]
["src/nvim/mark.c", ["    if (findpar(&oa.inclusive,", "            c == '}' ? FORWARD : BACKWARD, 1L, NUL, FALSE)) {", "      pos_copy = curwin->w_cursor;"], "readability/bool"]
["src/nvim/mark.c", ["    listcmd_busy = slcb;", "  } else if (c == '(' || c == ')') {  /* to previous/next sentence */", "    pos_T pos;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    pos = curwin->w_cursor;", "    listcmd_busy = TRUE;            /* avoid that '' is changed */", "    if (findsent(c == ')' ? FORWARD : BACKWARD, 1L)) {"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    pos = curwin->w_cursor;", "    listcmd_busy = TRUE;            /* avoid that '' is changed */", "    if (findsent(c == ')' ? FORWARD : BACKWARD, 1L)) {"], "readability/bool"]
["src/nvim/mark.c", ["    listcmd_busy = slcb;", "  } else if (c == '<' || c == '>') {  /* start/end of visual area */", "    startp = &buf->b_visual.vi_start;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["      posp = &pos_copy;", "      if (c == '<')", "        pos_copy.col = 0;"], "readability/braces"]
["src/nvim/mark.c", ["        pos_copy.col = 0;", "      else", "        pos_copy.col = MAXCOL;"], "readability/braces"]
["src/nvim/mark.c", ["    }", "  } else if (ASCII_ISLOWER(c)) {      /* normal named mark */", "    posp = &(buf->b_namedm[c - 'a'].mark);"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    posp = &(buf->b_namedm[c - 'a'].mark);", "  } else if (ASCII_ISUPPER(c) || ascii_isdigit(c)) {    /* named file mark */", "    if (ascii_isdigit(c))"], "readability/old_style_comment"]
["src/nvim/mark.c", ["  } else if (ASCII_ISUPPER(c) || ascii_isdigit(c)) {    /* named file mark */", "    if (ascii_isdigit(c))", "      c = c - '0' + NMARKS;"], "readability/braces"]
["src/nvim/mark.c", ["      c = c - '0' + NMARKS;", "    else", "      c -= 'A';"], "readability/braces"]
["src/nvim/mark.c", ["", "    if (fnum != NULL)", "      *fnum = namedfm[c].fmark.fnum;"], "readability/braces"]
["src/nvim/mark.c", ["      *fnum = namedfm[c].fmark.fnum;", "    else if (namedfm[c].fmark.fnum != buf->b_fnum) {", "      /* mark is in another file */"], "readability/braces"]
["src/nvim/mark.c", ["    else if (namedfm[c].fmark.fnum != buf->b_fnum) {", "      /* mark is in another file */", "      posp = &pos_copy;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["        if (buflist_getfile(namedfm[c].fmark.fnum,", "                (linenr_T)1, GETF_SETMARK, FALSE) == OK) {", "          /* Set the lnum now, autocommands could have changed it */"], "whitespace/alignment"]
["src/nvim/mark.c", ["        if (buflist_getfile(namedfm[c].fmark.fnum,", "                (linenr_T)1, GETF_SETMARK, FALSE) == OK) {", "          /* Set the lnum now, autocommands could have changed it */"], "readability/bool"]
["src/nvim/mark.c", ["                (linenr_T)1, GETF_SETMARK, FALSE) == OK) {", "          /* Set the lnum now, autocommands could have changed it */", "          curwin->w_cursor = namedfm[c].fmark.mark;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["        }", "        pos_copy.lnum = -1;             /* can't get file */", "      } else"], "readability/old_style_comment"]
["src/nvim/mark.c", ["        pos_copy.lnum = -1;             /* can't get file */", "      } else", "        pos_copy.lnum = 0;              /* mark exists, but is not valid in"], "readability/braces"]
["src/nvim/mark.c", ["      } else", "        pos_copy.lnum = 0;              /* mark exists, but is not valid in", "                                           current buffer */"], "readability/multiline_comment"]
["src/nvim/mark.c", ["      } else", "        pos_copy.lnum = 0;              /* mark exists, but is not valid in", "                                           current buffer */"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * Search for the next named mark in the current file."], "readability/old_style_comment"]
["src/nvim/mark.c", ["pos_T *", "getnextmark (", "    pos_T *startpos,          /* where to start */"], "whitespace/parens"]
["src/nvim/mark.c", ["getnextmark (", "    pos_T *startpos,          /* where to start */", "    int dir,                /* direction for search */"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    pos_T *startpos,          /* where to start */", "    int dir,                /* direction for search */", "    int begin_line"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* When searching backward and leaving the cursor on the first non-blank,", "   * position must be in a previous line."], "readability/old_style_comment"]
["src/nvim/mark.c", ["   * position must be in a next line. */", "  if (dir == BACKWARD && begin_line)", "    pos.col = 0;"], "readability/braces"]
["src/nvim/mark.c", ["    pos.col = 0;", "  else if (dir == FORWARD && begin_line)", "    pos.col = MAXCOL;"], "readability/braces"]
["src/nvim/mark.c", ["      if (dir == FORWARD) {", "        if ((result == NULL || lt(curbuf->b_namedm[i].mark, *result))", "            && lt(pos, curbuf->b_namedm[i].mark))"], "readability/braces"]
["src/nvim/mark.c", ["      } else {", "        if ((result == NULL || lt(*result, curbuf->b_namedm[i].mark))", "            && lt(curbuf->b_namedm[i].mark, pos))"], "readability/braces"]
["src/nvim/mark.c", ["", "/*", " * For an xtended filemark: set the fnum from the fname."], "readability/old_style_comment"]
["src/nvim/mark.c", ["  if (fm->fname != NULL) {", "    /*", "     * First expand \"~/\" in the file name to the home directory."], "readability/old_style_comment"]
["src/nvim/mark.c", ["#endif", "                                )) {", "      int len;"], "whitespace/parens"]
["src/nvim/mark.c", ["      STRLCPY(NameBuff + len, fm->fname + 2, MAXPATHL - len);", "    } else", "      STRLCPY(NameBuff, fm->fname, MAXPATHL);"], "readability/braces"]
["src/nvim/mark.c", ["", "    /* Try to shorten the file name. */", "    os_dirname(IObuff, IOSIZE);"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * Check all file marks for a name that matches the file name in buf."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  if (buf->b_ffname == NULL)", "    return;"], "readability/braces"]
["src/nvim/mark.c", ["", "  for (i = 0; i < NGLOBALMARKS; ++i)", "    fmarks_check_one(&namedfm[i], name, buf);"], "readability/braces"]
["src/nvim/mark.c", ["", "  for (i = 0; i < NGLOBALMARKS; ++i)", "    fmarks_check_one(&namedfm[i], name, buf);"], "readability/increment"]
["src/nvim/mark.c", ["  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {", "    for (i = 0; i < wp->w_jumplistlen; ++i) {", "      fmarks_check_one(&wp->w_jumplist[i], name, buf);"], "readability/increment"]
["src/nvim/mark.c", ["", "/*", " * Check a if a position from a mark is valid."], "readability/old_style_comment"]
["src/nvim/mark.c", ["  if (pos->lnum <= 0) {", "    /* lnum is negative if mark is in another file can can't get that", "     * file, error message already give then. */"], "readability/old_style_comment"]
["src/nvim/mark.c", ["     * file, error message already give then. */", "    if (pos->lnum == 0)", "      EMSG(_(e_marknotset));"], "readability/braces"]
["src/nvim/mark.c", ["", "/*", " * Get name of file from a filemark."], "readability/old_style_comment"]
["src/nvim/mark.c", ["{", "  if (fmark->fnum == curbuf->b_fnum)                /* current buffer */", "    return mark_line(&(fmark->mark), lead_len);"], "readability/old_style_comment"]
["src/nvim/mark.c", ["{", "  if (fmark->fnum == curbuf->b_fnum)                /* current buffer */", "    return mark_line(&(fmark->mark), lead_len);"], "readability/braces"]
["src/nvim/mark.c", ["    return mark_line(&(fmark->mark), lead_len);", "  return buflist_nr2name(fmark->fnum, FALSE, TRUE);", "}"], "readability/bool"]
["src/nvim/mark.c", ["", "/*", " * Return the line at mark \"mp\".  Truncate to fit in window."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  if (mp->lnum == 0 || mp->lnum > curbuf->b_ml.ml_line_count)", "    return vim_strsave((char_u *)\"-invalid-\");"], "readability/braces"]
["src/nvim/mark.c", ["    len += ptr2cells(p);", "    if (len >= Columns - lead_len)", "      break;"], "readability/braces"]
["src/nvim/mark.c", ["", "/*", " * print the marks"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  if (arg != NULL && *arg == NUL)", "    arg = NULL;"], "readability/braces"]
["src/nvim/mark.c", ["  show_one_mark('\\'', arg, &curwin->w_pcmark, NULL, true);", "  for (i = 0; i < NMARKS; ++i)", "    show_one_mark(i + 'a', arg, &curbuf->b_namedm[i].mark, NULL, true);"], "readability/braces"]
["src/nvim/mark.c", ["  show_one_mark('\\'', arg, &curwin->w_pcmark, NULL, true);", "  for (i = 0; i < NMARKS; ++i)", "    show_one_mark(i + 'a', arg, &curbuf->b_namedm[i].mark, NULL, true);"], "readability/increment"]
["src/nvim/mark.c", ["    show_one_mark(i + 'a', arg, &curbuf->b_namedm[i].mark, NULL, true);", "  for (i = 0; i < NGLOBALMARKS; ++i) {", "    if (namedfm[i].fmark.fnum != 0)"], "readability/increment"]
["src/nvim/mark.c", ["  for (i = 0; i < NGLOBALMARKS; ++i) {", "    if (namedfm[i].fmark.fnum != 0)", "      name = fm_getname(&namedfm[i].fmark, 15);"], "readability/braces"]
["src/nvim/mark.c", ["      name = fm_getname(&namedfm[i].fmark, 15);", "    else", "      name = namedfm[i].fname;"], "readability/braces"]
["src/nvim/mark.c", ["      show_one_mark(i >= NMARKS ? i - NMARKS + '0' : i + 'A',", "          arg, &namedfm[i].fmark.mark, name,", "          namedfm[i].fmark.fnum == curbuf->b_fnum);"], "whitespace/alignment"]
["src/nvim/mark.c", ["          arg, &namedfm[i].fmark.mark, name,", "          namedfm[i].fmark.fnum == curbuf->b_fnum);", "      if (namedfm[i].fmark.fnum != 0)"], "whitespace/alignment"]
["src/nvim/mark.c", ["          namedfm[i].fmark.fnum == curbuf->b_fnum);", "      if (namedfm[i].fmark.fnum != 0)", "        xfree(name);"], "readability/braces"]
["src/nvim/mark.c", ["", "/*", " * \":delmarks[!] [marks]\""], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  if (*eap->arg == NUL && eap->forceit)", "    /* clear all marks */"], "readability/braces"]
["src/nvim/mark.c", ["  if (*eap->arg == NUL && eap->forceit)", "    /* clear all marks */", "    clrallmarks(curbuf);"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    clrallmarks(curbuf);", "  else if (eap->forceit)", "    EMSG(_(e_invarg));"], "readability/braces"]
["src/nvim/mark.c", ["    EMSG(_(e_invarg));", "  else if (*eap->arg == NUL)", "    EMSG(_(e_argreq));"], "readability/braces"]
["src/nvim/mark.c", ["    EMSG(_(e_argreq));", "  else {", "    /* clear specified marks only */"], "readability/braces"]
["src/nvim/mark.c", ["    EMSG(_(e_argreq));", "  else {", "    /* clear specified marks only */"], "readability/braces"]
["src/nvim/mark.c", ["  else {", "    /* clear specified marks only */", "    for (p = eap->arg; *p != NUL; ++p) {"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    /* clear specified marks only */", "    for (p = eap->arg; *p != NUL; ++p) {", "      lower = ASCII_ISLOWER(*p);"], "readability/increment"]
["src/nvim/mark.c", ["        if (p[1] == '-') {", "          /* clear range of marks */", "          from = *p;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["          p += 2;", "        } else", "          /* clear one lower case mark */"], "readability/braces"]
["src/nvim/mark.c", ["        } else", "          /* clear one lower case mark */", "          from = to = *p;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "        for (i = from; i <= to; ++i) {", "          if (lower) {"], "readability/increment"]
["src/nvim/mark.c", ["        }", "      } else", "        switch (*p) {"], "readability/braces"]
["src/nvim/mark.c", ["", "/*", " * print the jumplist"], "readability/old_style_comment"]
["src/nvim/mark.c", ["  MSG_PUTS_TITLE(_(\"\\n jump line  col file/text\"));", "  for (i = 0; i < curwin->w_jumplistlen && !got_int; ++i) {", "    if (curwin->w_jumplist[i].fmark.mark.lnum != 0) {"], "readability/increment"]
["src/nvim/mark.c", ["      sprintf((char *)IObuff, \"%c %2d %5ld %4d \",", "          i == curwin->w_jumplistidx ? '>' : ' ',", "          i > curwin->w_jumplistidx ? i - curwin->w_jumplistidx"], "whitespace/alignment"]
["src/nvim/mark.c", ["          i == curwin->w_jumplistidx ? '>' : ' ',", "          i > curwin->w_jumplistidx ? i - curwin->w_jumplistidx", "          : curwin->w_jumplistidx - i,"], "whitespace/alignment"]
["src/nvim/mark.c", ["          i > curwin->w_jumplistidx ? i - curwin->w_jumplistidx", "          : curwin->w_jumplistidx - i,", "          curwin->w_jumplist[i].fmark.mark.lnum,"], "whitespace/alignment"]
["src/nvim/mark.c", ["          : curwin->w_jumplistidx - i,", "          curwin->w_jumplist[i].fmark.mark.lnum,", "          curwin->w_jumplist[i].fmark.mark.col);"], "whitespace/alignment"]
["src/nvim/mark.c", ["          curwin->w_jumplist[i].fmark.mark.lnum,", "          curwin->w_jumplist[i].fmark.mark.col);", "      msg_outtrans(IObuff);"], "whitespace/alignment"]
["src/nvim/mark.c", ["      }", "      sprintf((char *)IObuff, \"%c %2d %5ld %4d \",", "          i == curwin->w_jumplistidx ? '>' : ' ',"], "runtime/printf"]
["src/nvim/mark.c", ["  }", "  if (curwin->w_jumplistidx == curwin->w_jumplistlen)", "    MSG_PUTS(\"\\n>\");"], "readability/braces"]
["src/nvim/mark.c", ["", "/*", " * print the changelist"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  for (i = 0; i < curbuf->b_changelistlen && !got_int; ++i) {", "    if (curbuf->b_changelist[i].mark.lnum != 0) {"], "readability/increment"]
["src/nvim/mark.c", ["      msg_putchar('\\n');", "      if (got_int)", "        break;"], "readability/braces"]
["src/nvim/mark.c", ["      sprintf((char *)IObuff, \"%c %3d %5ld %4d \",", "          i == curwin->w_changelistidx ? '>' : ' ',", "          i > curwin->w_changelistidx ? i - curwin->w_changelistidx"], "whitespace/alignment"]
["src/nvim/mark.c", ["          i == curwin->w_changelistidx ? '>' : ' ',", "          i > curwin->w_changelistidx ? i - curwin->w_changelistidx", "          : curwin->w_changelistidx - i,"], "whitespace/alignment"]
["src/nvim/mark.c", ["          i > curwin->w_changelistidx ? i - curwin->w_changelistidx", "          : curwin->w_changelistidx - i,", "          (long)curbuf->b_changelist[i].mark.lnum,"], "whitespace/alignment"]
["src/nvim/mark.c", ["          : curwin->w_changelistidx - i,", "          (long)curbuf->b_changelist[i].mark.lnum,", "          curbuf->b_changelist[i].mark.col);"], "whitespace/alignment"]
["src/nvim/mark.c", ["          (long)curbuf->b_changelist[i].mark.lnum,", "          curbuf->b_changelist[i].mark.col);", "      msg_outtrans(IObuff);"], "whitespace/alignment"]
["src/nvim/mark.c", ["        break;", "      sprintf((char *)IObuff, \"%c %3d %5ld %4d \",", "          i == curwin->w_changelistidx ? '>' : ' ',"], "runtime/printf"]
["src/nvim/mark.c", ["  }", "  if (curwin->w_changelistidx == curbuf->b_changelistlen)", "    MSG_PUTS(\"\\n>\");"], "readability/braces"]
["src/nvim/mark.c", ["    lp = add; \\", "    if (*lp >= line1 && *lp <= line2) \\", "    { \\"], "readability/braces"]
["src/nvim/mark.c", ["    { \\", "      if (amount == MAXLNUM) \\", "        *lp = 0; \\"], "readability/braces"]
["src/nvim/mark.c", ["        *lp = 0; \\", "      else \\", "        *lp += amount; \\"], "readability/braces"]
["src/nvim/mark.c", ["        *lp = 0; \\", "      else \\", "        *lp += amount; \\"], "whitespace/newline"]
["src/nvim/mark.c", ["    } \\", "    else if (amount_after && *lp > line2) \\", "      *lp += amount_after; \\"], "readability/braces"]
["src/nvim/mark.c", ["", "/* don't delete the line, just put at first deleted line */", "#define one_adjust_nodel(add) \\"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    lp = add; \\", "    if (*lp >= line1 && *lp <= line2) \\", "    { \\"], "readability/braces"]
["src/nvim/mark.c", ["    { \\", "      if (amount == MAXLNUM) \\", "        *lp = line1; \\"], "readability/braces"]
["src/nvim/mark.c", ["        *lp = line1; \\", "      else \\", "        *lp += amount; \\"], "readability/braces"]
["src/nvim/mark.c", ["        *lp = line1; \\", "      else \\", "        *lp += amount; \\"], "whitespace/newline"]
["src/nvim/mark.c", ["    } \\", "    else if (amount_after && *lp > line2) \\", "      *lp += amount_after; \\"], "readability/braces"]
["src/nvim/mark.c", ["", "/*", " * Adjust marks between line1 and line2 (inclusive) to move 'amount' lines."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  if (line2 < line1 && amount_after == 0L)          /* nothing to do */", "    return;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  if (line2 < line1 && amount_after == 0L)          /* nothing to do */", "    return;"], "readability/braces"]
["src/nvim/mark.c", ["  if (!cmdmod.lockmarks) {", "    /* named marks, lower case and upper case */", "    for (i = 0; i < NMARKS; i++) {"], "readability/old_style_comment"]
["src/nvim/mark.c", ["      one_adjust(&(curbuf->b_namedm[i].mark.lnum));", "      if (namedfm[i].fmark.fnum == fnum)", "        one_adjust_nodel(&(namedfm[i].fmark.mark.lnum));"], "readability/braces"]
["src/nvim/mark.c", ["    for (i = NMARKS; i < NGLOBALMARKS; i++) {", "      if (namedfm[i].fmark.fnum == fnum)", "        one_adjust_nodel(&(namedfm[i].fmark.mark.lnum));"], "readability/braces"]
["src/nvim/mark.c", ["", "    /* last Insert position */", "    one_adjust(&(curbuf->b_last_insert.mark.lnum));"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "    /* last change position */", "    one_adjust(&(curbuf->b_last_change.mark.lnum));"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "    /* last cursor position, if it was set */", "    if (!equalpos(curbuf->b_last_cursor.mark, initpos))"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    /* last cursor position, if it was set */", "    if (!equalpos(curbuf->b_last_cursor.mark, initpos))", "      one_adjust(&(curbuf->b_last_cursor.mark.lnum));"], "readability/braces"]
["src/nvim/mark.c", ["", "    /* list of change positions */", "    for (i = 0; i < curbuf->b_changelistlen; ++i)"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    /* list of change positions */", "    for (i = 0; i < curbuf->b_changelistlen; ++i)", "      one_adjust_nodel(&(curbuf->b_changelist[i].mark.lnum));"], "readability/braces"]
["src/nvim/mark.c", ["    /* list of change positions */", "    for (i = 0; i < curbuf->b_changelistlen; ++i)", "      one_adjust_nodel(&(curbuf->b_changelist[i].mark.lnum));"], "readability/increment"]
["src/nvim/mark.c", ["", "    /* Visual area */", "    one_adjust_nodel(&(curbuf->b_visual.vi_start.lnum));"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* previous context mark */", "  one_adjust(&(curwin->w_pcmark.lnum));"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* previous pcmark */", "  one_adjust(&(curwin->w_prev_pcmark.lnum));"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* saved cursor for formatting */", "  if (saved_cursor.lnum != 0)"], "readability/old_style_comment"]
["src/nvim/mark.c", ["  /* saved cursor for formatting */", "  if (saved_cursor.lnum != 0)", "    one_adjust_nodel(&(saved_cursor.lnum));"], "readability/braces"]
["src/nvim/mark.c", ["", "  /*", "   * Adjust items in all windows related to the current buffer."], "readability/old_style_comment"]
["src/nvim/mark.c", ["    if (!cmdmod.lockmarks) {", "      /* Marks in the jumplist.  When deleting lines, this may create", "       * duplicate marks in the jumplist, they will be removed later. */"], "readability/old_style_comment"]
["src/nvim/mark.c", ["       * duplicate marks in the jumplist, they will be removed later. */", "      for (i = 0; i < win->w_jumplistlen; ++i) {", "        if (win->w_jumplist[i].fmark.fnum == fnum) {"], "readability/increment"]
["src/nvim/mark.c", ["      if (!cmdmod.lockmarks) {", "        /* marks in the tag stack */", "        for (i = 0; i < win->w_tagstacklen; i++) {"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "      /* the displayed Visual area */", "      if (win->w_old_cursor_lnum != 0) {"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "      /* topline and cursor position for windows with the same buffer", "       * other than the current window */"], "readability/old_style_comment"]
["src/nvim/mark.c", ["        if (win->w_topline >= line1 && win->w_topline <= line2) {", "          if (amount == MAXLNUM) {                  /* topline is deleted */", "            if (line1 <= 1) {"], "readability/old_style_comment"]
["src/nvim/mark.c", ["            }", "          } else {                      /* keep topline on the same line */", "            win->w_topline += amount;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["        if (win->w_cursor.lnum >= line1 && win->w_cursor.lnum <= line2) {", "          if (amount == MAXLNUM) {         /* line with cursor is deleted */", "            if (line1 <= 1) {"], "readability/old_style_comment"]
["src/nvim/mark.c", ["            win->w_cursor.col = 0;", "          } else {                      /* keep cursor on the same line */", "            win->w_cursor.lnum += amount;"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* adjust diffs */", "  diff_mark_adjust(line1, line2, amount, amount_after);"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/* This code is used often, needs to be fast. */", "#define col_adjust(pp) \\"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    posp = pp; \\", "    if (posp->lnum == lnum && posp->col >= mincol) \\", "    { \\"], "readability/braces"]
["src/nvim/mark.c", ["", "  if ((col_amount == 0L && lnum_amount == 0L) || cmdmod.lockmarks)", "    return;     /* nothing to do */"], "readability/braces"]
["src/nvim/mark.c", ["  if ((col_amount == 0L && lnum_amount == 0L) || cmdmod.lockmarks)", "    return;     /* nothing to do */", ""], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* named marks, lower case and upper case */", "  for (i = 0; i < NMARKS; i++) {"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    col_adjust(&(curbuf->b_namedm[i].mark));", "    if (namedfm[i].fmark.fnum == fnum)", "      col_adjust(&(namedfm[i].fmark.mark));"], "readability/braces"]
["src/nvim/mark.c", ["  for (i = NMARKS; i < NGLOBALMARKS; i++) {", "    if (namedfm[i].fmark.fnum == fnum)", "      col_adjust(&(namedfm[i].fmark.mark));"], "readability/braces"]
["src/nvim/mark.c", ["", "  /* last Insert position */", "  col_adjust(&(curbuf->b_last_insert.mark));"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* last change position */", "  col_adjust(&(curbuf->b_last_change.mark));"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* list of change positions */", "  for (i = 0; i < curbuf->b_changelistlen; ++i)"], "readability/old_style_comment"]
["src/nvim/mark.c", ["  /* list of change positions */", "  for (i = 0; i < curbuf->b_changelistlen; ++i)", "    col_adjust(&(curbuf->b_changelist[i].mark));"], "readability/braces"]
["src/nvim/mark.c", ["  /* list of change positions */", "  for (i = 0; i < curbuf->b_changelistlen; ++i)", "    col_adjust(&(curbuf->b_changelist[i].mark));"], "readability/increment"]
["src/nvim/mark.c", ["", "  /* Visual area */", "  col_adjust(&(curbuf->b_visual.vi_start));"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* previous context mark */", "  col_adjust(&(curwin->w_pcmark));"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* previous pcmark */", "  col_adjust(&(curwin->w_prev_pcmark));"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /* saved cursor for formatting */", "  col_adjust(&saved_cursor);"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /*", "   * Adjust items in all windows related to the current buffer."], "readability/old_style_comment"]
["src/nvim/mark.c", ["  FOR_ALL_WINDOWS_IN_TAB(win, curtab) {", "    /* marks in the jumplist */", "    for (i = 0; i < win->w_jumplistlen; ++i) {"], "readability/old_style_comment"]
["src/nvim/mark.c", ["    /* marks in the jumplist */", "    for (i = 0; i < win->w_jumplistlen; ++i) {", "      if (win->w_jumplist[i].fmark.fnum == fnum) {"], "readability/increment"]
["src/nvim/mark.c", ["    if (win->w_buffer == curbuf) {", "      /* marks in the tag stack */", "      for (i = 0; i < win->w_tagstacklen; i++) {"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "      /* cursor position for other windows with the same buffer */", "      if (win != curwin) {"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * Copy the jumplist from window \"from\" to window \"to\"."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  for (i = 0; i < from->w_jumplistlen; ++i) {", "    to->w_jumplist[i] = from->w_jumplist[i];"], "readability/increment"]
["src/nvim/mark.c", ["    to->w_jumplist[i] = from->w_jumplist[i];", "    if (from->w_jumplist[i].fname != NULL)", "      to->w_jumplist[i].fname = vim_strsave(from->w_jumplist[i].fname);"], "readability/braces"]
["src/nvim/mark.c", ["  if (iter == NULL && win->w_jumplistlen == 0) {", "    *fm = (xfmark_T) {{{0, 0, 0}, 0, 0, NULL}, NULL};", "    return NULL;"], "whitespace/braces"]
["src/nvim/mark.c", ["  if (iter == NULL && win->w_jumplistlen == 0) {", "    *fm = (xfmark_T) {{{0, 0, 0}, 0, 0, NULL}, NULL};", "    return NULL;"], "whitespace/braces"]
["src/nvim/mark.c", ["       ? &(win->w_jumplist[0])", "       : (const xfmark_T *const) iter);", "  *fm = *iter_mark;"], "whitespace/cast"]
["src/nvim/mark.c", ["                               ? &(namedfm[0])", "                               : (const xfmark_T *const) iter);", "  while ((size_t) (iter_mark - &(namedfm[0])) < ARRAY_SIZE(namedfm)"], "whitespace/cast"]
["src/nvim/mark.c", ["                               : (const xfmark_T *const) iter);", "  while ((size_t) (iter_mark - &(namedfm[0])) < ARRAY_SIZE(namedfm)", "         && !iter_mark->fmark.mark.lnum) {"], "whitespace/cast"]
["src/nvim/mark.c", ["  }", "  if ((size_t) (iter_mark - &(namedfm[0])) == ARRAY_SIZE(namedfm)", "      || !iter_mark->fmark.mark.lnum) {"], "whitespace/cast"]
["src/nvim/mark.c", ["  }", "  size_t iter_off = (size_t) (iter_mark - &(namedfm[0]));", "  *name = (char) (iter_off < NMARKS"], "whitespace/cast"]
["src/nvim/mark.c", ["  size_t iter_off = (size_t) (iter_mark - &(namedfm[0]));", "  *name = (char) (iter_off < NMARKS", "                  ? 'A' + (char) iter_off"], "whitespace/cast"]
["src/nvim/mark.c", ["  *name = (char) (iter_off < NMARKS", "                  ? 'A' + (char) iter_off", "                  : '0' + (char) (iter_off - NMARKS));"], "whitespace/cast"]
["src/nvim/mark.c", ["                  ? 'A' + (char) iter_off", "                  : '0' + (char) (iter_off - NMARKS));", "  *fm = *iter_mark;"], "whitespace/cast"]
["src/nvim/mark.c", ["  *fm = *iter_mark;", "  while ((size_t) (++iter_mark - &(namedfm[0])) < ARRAY_SIZE(namedfm)) {", "    if (iter_mark->fmark.mark.lnum) {"], "whitespace/cast"]
["src/nvim/mark.c", ["    if (iter_mark->fmark.mark.lnum) {", "      return (const void *) iter_mark;", "    }"], "whitespace/cast"]
["src/nvim/mark.c", ["  *name = NUL;", "  char mark_name = (char) (iter == NULL", "                           ? NUL"], "whitespace/cast"]
["src/nvim/mark.c", ["                                    ? '.'", "                                    : 'a' + (char) ((const fmark_T *)iter", "                                                    - &(buf->b_namedm[0]))))));"], "whitespace/cast"]
["src/nvim/mark.c", ["  }", "  size_t iter_off = (size_t) (iter_mark - &(buf->b_namedm[0]));", "  if (mark_name) {"], "whitespace/cast"]
["src/nvim/mark.c", ["  } else {", "    *name = (char) ('a' + (char) iter_off);", "  }"], "whitespace/cast"]
["src/nvim/mark.c", ["  *fm = *iter_mark;", "  return (const void *) iter_mark;", "}"], "whitespace/cast"]
["src/nvim/mark.c", ["", "/*", " * Free items in the jumplist of window \"wp\"."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  for (i = 0; i < wp->w_jumplistlen; ++i) {", "    free_xfmark(wp->w_jumplist[i]);"], "readability/increment"]
