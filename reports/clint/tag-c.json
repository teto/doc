["src/nvim/tag.c", ["", "/*", " * Code to handle tags and the tag stack"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Structure to hold pointers to various items in a tag line."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Structure to hold info about the tag pattern being used."], "readability/old_style_comment"]
["src/nvim/tag.c", ["typedef struct {", "  char_u      *pat;             /* the pattern */", "  int len;                      /* length of pat[] */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  char_u      *pat;             /* the pattern */", "  int len;                      /* length of pat[] */", "  char_u      *head;            /* start of pattern head */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int len;                      /* length of pat[] */", "  char_u      *head;            /* start of pattern head */", "  int headlen;                  /* length of head[] */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  char_u      *head;            /* start of pattern head */", "  int headlen;                  /* length of head[] */", "  regmatch_T regmatch;          /* regexp program, may be NULL */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int headlen;                  /* length of head[] */", "  regmatch_T regmatch;          /* regexp program, may be NULL */", "} pat_T;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["static char     *mt_names[MT_COUNT/2] =", "{\"FSC\", \"F C\", \"F  \", \"FS \", \" SC\", \"  C\", \"   \", \" S \"};", ""], "whitespace/braces"]
["src/nvim/tag.c", ["static char     *mt_names[MT_COUNT/2] =", "{\"FSC\", \"F C\", \"F  \", \"FS \", \" SC\", \"  C\", \"   \", \" S \"};", ""], "whitespace/braces"]
["src/nvim/tag.c", ["", "#define NOTAGFILE       99              /* return value for jumpto_tag */", "static char_u   *nofile_fname = NULL;   /* fname for NOTAGFILE error */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["#define NOTAGFILE       99              /* return value for jumpto_tag */", "static char_u   *nofile_fname = NULL;   /* fname for NOTAGFILE error */", ""], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "static char_u   *tagmatchname = NULL;   /* name of last used tag */", ""], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Tag for preview window is remembered separately, to avoid messing up the"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Jump to tag; handling of tag commands and tag stack"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /* remember the matches for the last used tag */", "  static int num_matches = 0;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  static int num_matches = 0;", "  static int max_num_matches = 0;             /* limit used for match search */", "  static char_u       **matches = NULL;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  if (type == DT_FREE) {", "    /* remove the list of matches */", "    FreeWild(num_matches, matches);"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  clearpos(&saved_fmark.mark);          /* shutup gcc 4.0 */", "  saved_fmark.fnum = 0;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "    /* new pattern, add to the tag stack */", "    if (*tag != NUL"], "readability/old_style_comment"]
["src/nvim/tag.c", ["            || type == DT_CSCOPE", "            )) {", "      if (g_do_tagpreview != 0) {"], "whitespace/parens"]
["src/nvim/tag.c", ["            && STRCMP(ptag_entry.tagname, tag) == 0) {", "          /* Jumping to same tag: keep the current match, so that", "           * the CursorHold autocommand example works. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["      } else {", "        /*", "         * If the last used entry is not at the top, delete all tag"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "        /* if the tagstack is full: remove oldest entry */", "        if (++tagstacklen > TAGSTACKSIZE) {"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          }", "          /* We weren't at the bottom of the stack, so jump all the", "           * way to the bottom now."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "        /* Make a copy of the fmark, autocommands may invalidate the", "         * tagstack before it's used. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        if (saved_fmark.fnum != curbuf->b_fnum) {", "          /*", "           * Jump to other file. If this fails (e.g. because the"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          }", "          /* A BufReadPost autocommand may jump to the '\" mark, but", "           * we don't what that here. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        check_cursor();", "        if ((fdo_flags & FDO_TAG) && old_KeyTyped)", "          foldOpenCursor();"], "readability/braces"]
["src/nvim/tag.c", ["          if ((tagstackidx += count - 1) >= tagstacklen) {", "            /*", "             * Beyond the last one, just give an error message and"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        } else {", "          if (--tagstackidx < 0)", "            tagstackidx = 0;"], "readability/braces"]
["src/nvim/tag.c", ["        }", "        if (cur_match >= MAXCOL)", "          cur_match = MAXCOL - 1;"], "readability/braces"]
["src/nvim/tag.c", ["          cur_match = MAXCOL - 1;", "        else if (cur_match < 0) {", "          EMSG(_(\"E425: Cannot go before first matching tag\"));"], "readability/braces"]
["src/nvim/tag.c", ["    } else {", "      /*", "       * For \":tag [arg]\" or \":tselect\" remember position before the jump."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "      /* Curwin will change in the call to jumpto_tag() if \":stag\" was", "       * used or an autocommand jumps to another window; store value of"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /* When not using the current buffer get the name of buffer \"cur_fnum\".", "   * Makes sure that the tag order doesn't change when using a remembered"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "    if (buf != NULL)", "      buf_ffname = buf->b_ffname;"], "readability/braces"]
["src/nvim/tag.c", ["", "  /*", "   * Repeat searching for tags, when a file has not been found."], "readability/old_style_comment"]
["src/nvim/tag.c", ["        flags = TAG_REGEXP;", "        ++name;", "      } else"], "readability/increment"]
["src/nvim/tag.c", ["        ++name;", "      } else", "        flags = TAG_NOIC;"], "readability/braces"]
["src/nvim/tag.c", ["", "      /* If there already were some matches for the same name, move them", "       * to the start.  Avoids that the order changes when using"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          parse_match(matches[j], &tagp);", "          for (i = idx; i < new_num_matches; ++i) {", "            parse_match(new_matches[i], &tagp2);"], "readability/increment"]
["src/nvim/tag.c", ["    if (num_matches <= 0) {", "      if (verbose)", "        EMSG2(_(\"E426: tag not found: %s\"), name);"], "readability/braces"]
["src/nvim/tag.c", ["      if (cur_match >= num_matches) {", "        /* Avoid giving this error when a file wasn't found and we're", "         * looking for a match in another file, which wasn't found."], "readability/old_style_comment"]
["src/nvim/tag.c", ["            && nofile_fname == NULL) {", "          if (num_matches == 1)", "            EMSG(_(\"E427: There is only one matching tag\"));"], "readability/braces"]
["src/nvim/tag.c", ["            EMSG(_(\"E427: There is only one matching tag\"));", "          else", "            EMSG(_(\"E428: Cannot go beyond last matching tag\"));"], "readability/braces"]
["src/nvim/tag.c", ["", "      /*", "       * Only when going to try the next match, report that the previous"], "readability/old_style_comment"]
["src/nvim/tag.c", ["       */", "      if (nofile_fname != NULL && error_cur_match != cur_match)", "        smsg(_(\"File \\\"%s\\\" does not exist\"), nofile_fname);"], "readability/braces"]
["src/nvim/tag.c", ["      vim_snprintf((char *)IObuff, IOSIZE, \":ta %s\\r\", name);", "      set_vim_var_string(VV_SWAPCOMMAND, (char *) IObuff, -1);", ""], "whitespace/cast"]
["src/nvim/tag.c", ["", "      /*", "       * Jump to the desired match."], "readability/old_style_comment"]
["src/nvim/tag.c", ["          error_cur_match = cur_match;", "          if (use_tagstack)", "            --tagstackidx;"], "readability/braces"]
["src/nvim/tag.c", ["          if (use_tagstack)", "            --tagstackidx;", "          if (type == DT_PREV)"], "readability/increment"]
["src/nvim/tag.c", ["            --tagstackidx;", "          if (type == DT_PREV)", "            --cur_match;"], "readability/braces"]
["src/nvim/tag.c", ["          if (type == DT_PREV)", "            --cur_match;", "          else {"], "readability/increment"]
["src/nvim/tag.c", ["            --cur_match;", "          else {", "            type = DT_NEXT;"], "readability/braces"]
["src/nvim/tag.c", ["            --cur_match;", "          else {", "            type = DT_NEXT;"], "readability/braces"]
["src/nvim/tag.c", ["            type = DT_NEXT;", "            ++cur_match;", "          }"], "readability/increment"]
["src/nvim/tag.c", ["      } else {", "        /* We may have jumped to another window, check that", "         * tagstackidx is still valid. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["         * tagstackidx is still valid. */", "        if (use_tagstack && tagstackidx > curwin->w_tagstacklen)", "          tagstackidx = curwin->w_tagstackidx;"], "readability/braces"]
["src/nvim/tag.c", ["", "/*", " * Free cached tags."], "readability/old_style_comment"]
["src/nvim/tag.c", ["    msg_advance(24);", "  } else", "    msg_advance(13 + l);"], "readability/braces"]
["src/nvim/tag.c", ["", "/*", " * Print the tag stack"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /* Highlight title */", "  MSG_PUTS_TITLE(_(\"\\n  # TO tag         FROM line  in file/text\"));"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  MSG_PUTS_TITLE(_(\"\\n  # TO tag         FROM line  in file/text\"));", "  for (i = 0; i < tagstacklen; ++i) {", "    if (tagstack[i].tagname != NULL) {"], "readability/increment"]
["src/nvim/tag.c", ["      name = fm_getname(&(tagstack[i].fmark), 30);", "      if (name == NULL)             /* file name not available */", "        continue;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["      name = fm_getname(&(tagstack[i].fmark), 30);", "      if (name == NULL)             /* file name not available */", "        continue;"], "readability/braces"]
["src/nvim/tag.c", ["    }", "    ui_flush();                    /* show one line at a time */", "  }"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  }", "  if (tagstackidx == tagstacklen)       /* idx at top of stack */", "    MSG_PUTS(\"\\n>\");"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  }", "  if (tagstackidx == tagstacklen)       /* idx at top of stack */", "    MSG_PUTS(\"\\n>\");"], "readability/braces"]
["src/nvim/tag.c", ["", "/*", " * Compare two strings, for length \"len\", ignoring case the ASCII way."], "readability/old_style_comment"]
["src/nvim/tag.c", ["    i = TOUPPER_ASC(*s1) - TOUPPER_ASC(*s2);", "    if (i != 0)", "      return i;                         /* this character different */"], "readability/braces"]
["src/nvim/tag.c", ["    if (i != 0)", "      return i;                         /* this character different */", "    if (*s1 == NUL)"], "readability/old_style_comment"]
["src/nvim/tag.c", ["      return i;                         /* this character different */", "    if (*s1 == NUL)", "      break;                            /* strings match until NUL */"], "readability/braces"]
["src/nvim/tag.c", ["    if (*s1 == NUL)", "      break;                            /* strings match until NUL */", "    ++s1;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["      break;                            /* strings match until NUL */", "    ++s1;", "    ++s2;"], "readability/increment"]
["src/nvim/tag.c", ["    ++s1;", "    ++s2;", "    --len;"], "readability/increment"]
["src/nvim/tag.c", ["    ++s2;", "    --len;", "  }"], "readability/increment"]
["src/nvim/tag.c", ["  }", "  return 0;                             /* strings match */", "}"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Extract info from the tag search pattern \"pats->pat\"."], "readability/old_style_comment"]
["src/nvim/tag.c", ["  if (has_re) {", "    /* When the pattern starts with '^' or \"\\\\<\", binary searching can be", "     * used (much faster). */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["     * used (much faster). */", "    if (pats->pat[0] == '^')", "      pats->head = pats->pat + 1;"], "readability/braces"]
["src/nvim/tag.c", ["      pats->head = pats->pat + 1;", "    else if (pats->pat[0] == '\\\\' && pats->pat[1] == '<')", "      pats->head = pats->pat + 2;"], "readability/braces"]
["src/nvim/tag.c", ["      pats->head = pats->pat + 2;", "    if (pats->head == pats->pat)", "      pats->headlen = 0;"], "readability/braces"]
["src/nvim/tag.c", ["      pats->headlen = 0;", "    else", "      for (pats->headlen = 0; pats->head[pats->headlen] != NUL;"], "readability/braces"]
["src/nvim/tag.c", ["    else", "      for (pats->headlen = 0; pats->head[pats->headlen] != NUL;", "           ++pats->headlen)"], "readability/braces"]
["src/nvim/tag.c", ["      for (pats->headlen = 0; pats->head[pats->headlen] != NUL;", "           ++pats->headlen)", "        if (vim_strchr((char_u *)(p_magic ? \".[~*\\\\$\" : \"\\\\$\"),"], "readability/increment"]
["src/nvim/tag.c", ["           ++pats->headlen)", "        if (vim_strchr((char_u *)(p_magic ? \".[~*\\\\$\" : \"\\\\$\"),", "                pats->head[pats->headlen]) != NULL)"], "readability/braces"]
["src/nvim/tag.c", ["        if (vim_strchr((char_u *)(p_magic ? \".[~*\\\\$\" : \"\\\\$\"),", "                pats->head[pats->headlen]) != NULL)", "          break;"], "whitespace/alignment"]
["src/nvim/tag.c", ["          break;", "    if (p_tl != 0 && pats->headlen > p_tl)      /* adjust for 'taglength' */", "      pats->headlen = p_tl;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          break;", "    if (p_tl != 0 && pats->headlen > p_tl)      /* adjust for 'taglength' */", "      pats->headlen = p_tl;"], "readability/braces"]
["src/nvim/tag.c", ["", "  if (has_re)", "    pats->regmatch.regprog = vim_regcomp(pats->pat, p_magic ? RE_MAGIC : 0);"], "readability/braces"]
["src/nvim/tag.c", ["    pats->regmatch.regprog = vim_regcomp(pats->pat, p_magic ? RE_MAGIC : 0);", "  else", "    pats->regmatch.regprog = NULL;"], "readability/braces"]
["src/nvim/tag.c", ["", "/*", " * find_tags() - search for tags in tags files"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    int mincount,                           /*  MAXCOL: find all matches", "                                             other: minimal number of matches */", "    char_u *buf_ffname                /* name of buffer for priority */"], "whitespace/indent"]
["src/nvim/tag.c", ["    int flags,", "    int mincount,                           /*  MAXCOL: find all matches", "                                             other: minimal number of matches */"], "readability/multiline_comment"]
["src/nvim/tag.c", ["    int flags,", "    int mincount,                           /*  MAXCOL: find all matches", "                                             other: minimal number of matches */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["                                             other: minimal number of matches */", "    char_u *buf_ffname                /* name of buffer for priority */", ")"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  FILE       *fp;", "  char_u     *lbuf;                     /* line buffer */", "  int lbuf_size = LSIZE;                /* length of lbuf */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  char_u     *lbuf;                     /* line buffer */", "  int lbuf_size = LSIZE;                /* length of lbuf */", "  char_u     *tag_fname;                /* name of tag file */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int lbuf_size = LSIZE;                /* length of lbuf */", "  char_u     *tag_fname;                /* name of tag file */", "  tagname_T tn;                         /* info for get_tagfname() */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  char_u     *tag_fname;                /* name of tag file */", "  tagname_T tn;                         /* info for get_tagfname() */", "  int first_file;                       /* trying first tag file */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  tagname_T tn;                         /* info for get_tagfname() */", "  int first_file;                       /* trying first tag file */", "  tagptrs_T tagp;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  tagptrs_T tagp;", "  int did_open = FALSE;                 /* did open a tag file */", "  int stop_searching = FALSE;           /* stop when match found or error */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  tagptrs_T tagp;", "  int did_open = FALSE;                 /* did open a tag file */", "  int stop_searching = FALSE;           /* stop when match found or error */"], "readability/bool"]
["src/nvim/tag.c", ["  int did_open = FALSE;                 /* did open a tag file */", "  int stop_searching = FALSE;           /* stop when match found or error */", "  int retval = FAIL;                    /* return value */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int did_open = FALSE;                 /* did open a tag file */", "  int stop_searching = FALSE;           /* stop when match found or error */", "  int retval = FAIL;                    /* return value */"], "readability/bool"]
["src/nvim/tag.c", ["  int stop_searching = FALSE;           /* stop when match found or error */", "  int retval = FAIL;                    /* return value */", "  int is_static;                        /* current tag line is static */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int retval = FAIL;                    /* return value */", "  int is_static;                        /* current tag line is static */", "  int is_current;                       /* file name matches */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int is_static;                        /* current tag line is static */", "  int is_current;                       /* file name matches */", "  int eof = FALSE;                      /* found end-of-file */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int is_current;                       /* file name matches */", "  int eof = FALSE;                      /* found end-of-file */", "  char_u      *p;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int is_current;                       /* file name matches */", "  int eof = FALSE;                      /* found end-of-file */", "  char_u      *p;"], "readability/bool"]
["src/nvim/tag.c", ["  enum {", "    TS_START,                   /* at start of file */", "    TS_LINEAR                   /* linear searching forward, till EOF */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    TS_START,                   /* at start of file */", "    TS_LINEAR                   /* linear searching forward, till EOF */", "    , TS_BINARY,                /* binary searching */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    TS_LINEAR                   /* linear searching forward, till EOF */", "    , TS_BINARY,                /* binary searching */", "    TS_SKIP_BACK,               /* skipping backwards */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    , TS_BINARY,                /* binary searching */", "    TS_SKIP_BACK,               /* skipping backwards */", "    TS_STEP_FORWARD             /* stepping forwards */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    TS_SKIP_BACK,               /* skipping backwards */", "    TS_STEP_FORWARD             /* stepping forwards */", "  }   state;                    /* Current search state */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    TS_STEP_FORWARD             /* stepping forwards */", "  }   state;                    /* Current search state */", ""], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int cmplen;", "  int match;                    /* matches */", "  int match_no_ic = 0;          /* matches with rm_ic == FALSE */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int match;                    /* matches */", "  int match_no_ic = 0;          /* matches with rm_ic == FALSE */", "  int match_re;                 /* match with regexp */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int match_no_ic = 0;          /* matches with rm_ic == FALSE */", "  int match_re;                 /* match with regexp */", "  int matchoff = 0;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  pat_T orgpat;                         /* holds unconverted pattern info */", "  vimconv_T vimconv;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int findall = (mincount == MAXCOL || mincount == TAG_MANY);", "  /* find all matching tags */", "  int sort_error = FALSE;                       /* tags file not sorted */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  /* find all matching tags */", "  int sort_error = FALSE;                       /* tags file not sorted */", "  int linear;                                   /* do a linear search */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  /* find all matching tags */", "  int sort_error = FALSE;                       /* tags file not sorted */", "  int linear;                                   /* do a linear search */"], "readability/bool"]
["src/nvim/tag.c", ["  int sort_error = FALSE;                       /* tags file not sorted */", "  int linear;                                   /* do a linear search */", "  int sortic = FALSE;                           /* tag file sorted in nocase */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int linear;                                   /* do a linear search */", "  int sortic = FALSE;                           /* tag file sorted in nocase */", "  int line_error = FALSE;                       /* syntax error */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int linear;                                   /* do a linear search */", "  int sortic = FALSE;                           /* tag file sorted in nocase */", "  int line_error = FALSE;                       /* syntax error */"], "readability/bool"]
["src/nvim/tag.c", ["  int sortic = FALSE;                           /* tag file sorted in nocase */", "  int line_error = FALSE;                       /* syntax error */", "  int has_re = (flags & TAG_REGEXP);            /* regexp used */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int sortic = FALSE;                           /* tag file sorted in nocase */", "  int line_error = FALSE;                       /* syntax error */", "  int has_re = (flags & TAG_REGEXP);            /* regexp used */"], "readability/bool"]
["src/nvim/tag.c", ["  int line_error = FALSE;                       /* syntax error */", "  int has_re = (flags & TAG_REGEXP);            /* regexp used */", "  int help_only = (flags & TAG_HELP);"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int noic = (flags & TAG_NOIC);", "  int get_it_again = FALSE;", "  int use_cscope = (flags & TAG_CSCOPE);"], "readability/bool"]
["src/nvim/tag.c", ["", "  /*", "   * Allocate memory for the buffers that are used"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  STRCPY(tag_fname, \"from cscope\");             /* for error messages */", ""], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /*", "   * Initialize a few variables"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  if (curbuf->b_help) {", "    /* When \"@ab\" is specified use only the \"ab\" language, otherwise", "     * search all languages. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  }", "  if (p_tl != 0 && orgpat.len > p_tl)           /* adjust for 'taglength' */", "    orgpat.len = p_tl;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  }", "  if (p_tl != 0 && orgpat.len > p_tl)           /* adjust for 'taglength' */", "    orgpat.len = p_tl;"], "readability/braces"]
["src/nvim/tag.c", ["  save_emsg_off = emsg_off;", "  emsg_off = TRUE;    /* don't want error for invalid RE here */", "  prepare_pats(&orgpat, has_re);"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  save_emsg_off = emsg_off;", "  emsg_off = TRUE;    /* don't want error for invalid RE here */", "  prepare_pats(&orgpat, has_re);"], "readability/bool"]
["src/nvim/tag.c", ["  emsg_off = save_emsg_off;", "  if (has_re && orgpat.regmatch.regprog == NULL)", "    goto findtag_end;"], "readability/braces"]
["src/nvim/tag.c", ["", "  /*", "   * When finding a specified number of matches, first try with matching"], "readability/old_style_comment"]
["src/nvim/tag.c", ["                           && (findall || orgpat.headlen == 0 || !p_tbs));", "  for (round = 1; round <= 2; ++round) {", "    linear = (orgpat.headlen == 0 || !p_tbs || round == 2);"], "readability/increment"]
["src/nvim/tag.c", ["", "          /* When searching for a specific language skip tags files", "           * for other languages. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["           * for other languages. */", "          if (help_lang_find != NULL", "              && STRICMP(help_lang, help_lang_find) != 0)"], "readability/braces"]
["src/nvim/tag.c", ["", "          /* For CTRL-] in a help file prefer a match with the same", "           * language. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["           * language. */", "          if ((flags & TAG_KEEP_LANG)", "              && help_lang_find == NULL"], "readability/braces"]
["src/nvim/tag.c", ["            help_pri = 0;", "          else {", "            help_pri = 1;"], "readability/braces"]
["src/nvim/tag.c", ["            help_pri = 0;", "          else {", "            help_pri = 1;"], "readability/braces"]
["src/nvim/tag.c", ["            help_pri = 1;", "            for (s = p_hlg; *s != NUL; ++s) {", "              if (STRNICMP(s, help_lang, 2) == 0)"], "readability/increment"]
["src/nvim/tag.c", ["            for (s = p_hlg; *s != NUL; ++s) {", "              if (STRNICMP(s, help_lang, 2) == 0)", "                break;"], "readability/braces"]
["src/nvim/tag.c", ["                break;", "              ++help_pri;", "              if ((s = vim_strchr(s, ',')) == NULL)"], "readability/increment"]
["src/nvim/tag.c", ["              ++help_pri;", "              if ((s = vim_strchr(s, ',')) == NULL)", "                break;"], "readability/braces"]
["src/nvim/tag.c", ["            if (s == NULL || *s == NUL) {", "              /* Language not in 'helplang': use last, prefer English,", "               * unless found already. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["               * unless found already. */", "              ++help_pri;", "              if (STRICMP(help_lang, \"en\") != 0)"], "readability/increment"]
["src/nvim/tag.c", ["              ++help_pri;", "              if (STRICMP(help_lang, \"en\") != 0)", "                ++help_pri;"], "readability/braces"]
["src/nvim/tag.c", ["              if (STRICMP(help_lang, \"en\") != 0)", "                ++help_pri;", "            }"], "readability/increment"]
["src/nvim/tag.c", ["      }", "      did_open = TRUE;      /* remember that we found at least one file */", ""], "readability/old_style_comment"]
["src/nvim/tag.c", ["      }", "      did_open = TRUE;      /* remember that we found at least one file */", ""], "readability/bool"]
["src/nvim/tag.c", ["", "      state = TS_START;     /* we're at the start of the file */", ""], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "      /*", "       * Read and parse the lines in the file one by one"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        }", "        if ((flags & TAG_INS_COMP))     /* Double brackets for gcc */", "          ins_compl_check_keys(30, false);"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        }", "        if ((flags & TAG_INS_COMP))     /* Double brackets for gcc */", "          ins_compl_check_keys(30, false);"], "readability/braces"]
["src/nvim/tag.c", ["        if (got_int || compl_interrupted) {", "          stop_searching = TRUE;", "          break;"], "readability/bool"]
["src/nvim/tag.c", ["        }", "        /* When mincount is TAG_MANY, stop when enough matches have been", "         * found (for completion). */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        if (mincount == TAG_MANY && match_count >= TAG_MANY) {", "          stop_searching = TRUE;", "          retval = OK;"], "readability/bool"]
["src/nvim/tag.c", ["        }", "        if (get_it_again)", "          goto line_read_in;"], "readability/braces"]
["src/nvim/tag.c", ["          goto line_read_in;", "        /*", "         * For binary search: compute the next offset to use."], "readability/old_style_comment"]
["src/nvim/tag.c", ["                                              - search_info.low_offset) / 2);", "          if (offset == search_info.curr_offset)", "            break;              /* End the binary search without a match. */"], "readability/braces"]
["src/nvim/tag.c", ["          if (offset == search_info.curr_offset)", "            break;              /* End the binary search without a match. */", "          else"], "readability/old_style_comment"]
["src/nvim/tag.c", ["            break;              /* End the binary search without a match. */", "          else", "            search_info.curr_offset = offset;"], "readability/braces"]
["src/nvim/tag.c", ["", "        /*", "         * When jumping around in the file, first read a line to find the"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        if (state == TS_BINARY || state == TS_SKIP_BACK) {", "          /* Adjust the search file offset to the correct position */", "          search_info.curr_offset_used = search_info.curr_offset;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          if (!eof && search_info.curr_offset != 0) {", "            /* The explicit cast is to work around a bug in gcc 3.4.2", "             * (repeated below). */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          }", "          /* skip empty and blank lines */", "          while (!eof && vim_isblankline(lbuf)) {"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          if (eof) {", "            /* Hit end of file.  Skip backwards. */", "            state = TS_SKIP_BACK;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        }", "        /*", "         * Not jumping around in the file: Read the next line."], "readability/old_style_comment"]
["src/nvim/tag.c", ["         */", "        else {", "          /* skip empty and blank lines */"], "whitespace/newline"]
["src/nvim/tag.c", ["         */", "        else {", "          /* skip empty and blank lines */"], "readability/braces"]
["src/nvim/tag.c", ["        else {", "          /* skip empty and blank lines */", "          do {"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          if (eof) {", "            break;                                  /* end of file */", "          }"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "          /* Convert every line.  Converting the pattern from 'enc' to", "           * the tags file encoding doesn't work, because characters are"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          if (conv_line != NULL) {", "            /* Copy or swap lbuf and conv_line. */", "            len = (int)STRLEN(conv_line) + 1;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "        /*", "         * When still at the start of the file, check for Emacs tags file"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        if (state == TS_START) {", "          /* The header ends when the line sorts below \"!_TAG_\".  When", "           * case is folded lower case letters sort before \"_\". */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["              || (lbuf[0] == '!' && ASCII_ISLOWER(lbuf[1]))) {", "            if (STRNCMP(lbuf, \"!_TAG_\", 6) != 0)", "              /* Non-header item before the header, e.g. \"!\" itself."], "readability/braces"]
["src/nvim/tag.c", ["            if (STRNCMP(lbuf, \"!_TAG_\", 6) != 0)", "              /* Non-header item before the header, e.g. \"!\" itself.", "               */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "            /*", "             * Read header line."], "readability/old_style_comment"]
["src/nvim/tag.c", ["             */", "            if (STRNCMP(lbuf, \"!_TAG_FILE_SORTED\\t\", 18) == 0)", "              tag_file_sorted = lbuf[18];"], "readability/braces"]
["src/nvim/tag.c", ["            if (STRNCMP(lbuf, \"!_TAG_FILE_ENCODING\\t\", 20) == 0) {", "              /* Prepare to convert every line from the specified", "               * encoding to 'encoding'. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["               * encoding to 'encoding'. */", "              for (p = lbuf + 20; *p > ' ' && *p < 127; ++p)", "                ;"], "readability/braces"]
["src/nvim/tag.c", ["               * encoding to 'encoding'. */", "              for (p = lbuf + 20; *p > ' ' && *p < 127; ++p)", "                ;"], "readability/increment"]
["src/nvim/tag.c", ["              for (p = lbuf + 20; *p > ' ' && *p < 127; ++p)", "                ;", "              *p = NUL;"], "whitespace/semicolon"]
["src/nvim/tag.c", ["", "            /* Read the next line.  Unrecognized flags are ignored. */", "            continue;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "          /* Headers ends. */", ""], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "          /*", "           * When there is no tag head, or ignoring case, need to do a"], "readability/old_style_comment"]
["src/nvim/tag.c", ["           */", "          if (linear || use_cscope)", "            state = TS_LINEAR;"], "readability/braces"]
["src/nvim/tag.c", ["            state = TS_LINEAR;", "          else if (tag_file_sorted == NUL)", "            state = TS_BINARY;"], "readability/braces"]
["src/nvim/tag.c", ["            state = TS_BINARY;", "          else if (tag_file_sorted == '1')", "            state = TS_BINARY;"], "readability/braces"]
["src/nvim/tag.c", ["            state = TS_BINARY;", "          else if (tag_file_sorted == '2') {", "            state = TS_BINARY;"], "readability/braces"]
["src/nvim/tag.c", ["            state = TS_BINARY;", "            sortic = TRUE;", "            orgpat.regmatch.rm_ic = (p_ic || !noic);"], "readability/bool"]
["src/nvim/tag.c", ["            orgpat.regmatch.rm_ic = (p_ic || !noic);", "          } else", "            state = TS_LINEAR;"], "readability/braces"]
["src/nvim/tag.c", ["          if (state == TS_BINARY && orgpat.regmatch.rm_ic && !sortic) {", "            /* Binary search won't work for ignoring case, use linear", "             * search. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["             * search. */", "            linear = TRUE;", "            state = TS_LINEAR;"], "readability/bool"]
["src/nvim/tag.c", ["", "          /*", "           * Skip this line if the length of the tag is different and"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          cmplen = (int)(tagp.tagname_end - tagp.tagname);", "          if (p_tl != 0 && cmplen > p_tl)           /* adjust for 'taglength' */", "            cmplen = p_tl;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          cmplen = (int)(tagp.tagname_end - tagp.tagname);", "          if (p_tl != 0 && cmplen > p_tl)           /* adjust for 'taglength' */", "            cmplen = p_tl;"], "readability/braces"]
["src/nvim/tag.c", ["            cmplen = p_tl;", "          if (has_re && orgpat.headlen < cmplen)", "            cmplen = orgpat.headlen;"], "readability/braces"]
["src/nvim/tag.c", ["            cmplen = orgpat.headlen;", "          else if (state == TS_LINEAR && orgpat.headlen != cmplen)", "            continue;"], "readability/braces"]
["src/nvim/tag.c", ["          if (state == TS_BINARY) {", "            /*", "             * Simplistic check for unsorted tags file."], "readability/old_style_comment"]
["src/nvim/tag.c", ["            i = (int)tagp.tagname[0];", "            if (sortic)", "              i = TOUPPER_ASC(tagp.tagname[0]);"], "readability/braces"]
["src/nvim/tag.c", ["              i = TOUPPER_ASC(tagp.tagname[0]);", "            if (i < search_info.low_char || i > search_info.high_char)", "              sort_error = TRUE;"], "readability/braces"]
["src/nvim/tag.c", ["            if (i < search_info.low_char || i > search_info.high_char)", "              sort_error = TRUE;", ""], "readability/bool"]
["src/nvim/tag.c", ["", "            /*", "             * Compare the current tag with the searched tag."], "readability/old_style_comment"]
["src/nvim/tag.c", ["             */", "            if (sortic)", "              tagcmp = tag_strnicmp(tagp.tagname, orgpat.head,"], "readability/braces"]
["src/nvim/tag.c", ["              tagcmp = tag_strnicmp(tagp.tagname, orgpat.head,", "                  (size_t)cmplen);", "            else"], "whitespace/alignment"]
["src/nvim/tag.c", ["                  (size_t)cmplen);", "            else", "              tagcmp = STRNCMP(tagp.tagname, orgpat.head, cmplen);"], "readability/braces"]
["src/nvim/tag.c", ["", "            /*", "             * A match with a shorter tag means to search forward."], "readability/old_style_comment"]
["src/nvim/tag.c", ["            if (tagcmp == 0) {", "              if (cmplen < orgpat.headlen)", "                tagcmp = -1;"], "readability/braces"]
["src/nvim/tag.c", ["                tagcmp = -1;", "              else if (cmplen > orgpat.headlen)", "                tagcmp = 1;"], "readability/braces"]
["src/nvim/tag.c", ["            if (tagcmp == 0) {", "              /* We've located the tag, now skip back and search", "               * forward until the first matching tag is found."], "readability/old_style_comment"]
["src/nvim/tag.c", ["                search_info.low_offset = search_info.curr_offset;", "                if (sortic)", "                  search_info.low_char ="], "readability/braces"]
["src/nvim/tag.c", ["                    TOUPPER_ASC(tagp.tagname[0]);", "                else", "                  search_info.low_char = tagp.tagname[0];"], "readability/braces"]
["src/nvim/tag.c", ["              search_info.high_offset = search_info.curr_offset;", "              if (sortic)", "                search_info.high_char ="], "readability/braces"]
["src/nvim/tag.c", ["                  TOUPPER_ASC(tagp.tagname[0]);", "              else", "                search_info.high_char = tagp.tagname[0];"], "readability/braces"]
["src/nvim/tag.c", ["", "            /* No match yet and are at the end of the binary search. */", "            break;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["            assert(cmplen >= 0);", "            if (mb_strnicmp(tagp.tagname, orgpat.head, (size_t)cmplen) != 0)", "              state = TS_STEP_FORWARD;"], "readability/braces"]
["src/nvim/tag.c", ["              state = TS_STEP_FORWARD;", "            else", "              /* Have to skip back more.  Restore the curr_offset"], "readability/braces"]
["src/nvim/tag.c", ["            else", "              /* Have to skip back more.  Restore the curr_offset", "               * used, otherwise we get stuck at a long line. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["            }", "          } else", "          /* skip this match if it can't match */"], "readability/braces"]
["src/nvim/tag.c", ["          } else", "          /* skip this match if it can't match */", "          assert(cmplen >= 0);"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          assert(cmplen >= 0);", "          if (mb_strnicmp(tagp.tagname, orgpat.head, (size_t)cmplen) != 0)", "            continue;"], "readability/braces"]
["src/nvim/tag.c", ["          tagp.command = tagp.fname_end + 1;", "          if (tagp.fname_end == NULL)", "            i = FAIL;"], "readability/braces"]
["src/nvim/tag.c", ["            i = FAIL;", "          else", "            i = OK;"], "readability/braces"]
["src/nvim/tag.c", ["            i = OK;", "        } else", "          i = parse_tag_line(lbuf,"], "readability/braces"]
["src/nvim/tag.c", ["          i = parse_tag_line(lbuf,", "              &tagp);", "        if (i == FAIL) {"], "whitespace/alignment"]
["src/nvim/tag.c", ["        if (i == FAIL) {", "          line_error = TRUE;", "          break;"], "readability/bool"]
["src/nvim/tag.c", ["", "        /*", "         * First try matching with the pattern literally (also when it is"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        cmplen = (int)(tagp.tagname_end - tagp.tagname);", "        if (p_tl != 0 && cmplen > p_tl)             /* adjust for 'taglength' */", "          cmplen = p_tl;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        cmplen = (int)(tagp.tagname_end - tagp.tagname);", "        if (p_tl != 0 && cmplen > p_tl)             /* adjust for 'taglength' */", "          cmplen = p_tl;"], "readability/braces"]
["src/nvim/tag.c", ["          cmplen = p_tl;", "        /* if tag length does not match, don't try comparing */", "        if (orgpat.len != cmplen)"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        /* if tag length does not match, don't try comparing */", "        if (orgpat.len != cmplen)", "          match = FALSE;"], "readability/braces"]
["src/nvim/tag.c", ["        if (orgpat.len != cmplen)", "          match = FALSE;", "        else {"], "readability/bool"]
["src/nvim/tag.c", ["          match = FALSE;", "        else {", "          if (orgpat.regmatch.rm_ic) {"], "readability/braces"]
["src/nvim/tag.c", ["          match = FALSE;", "        else {", "          if (orgpat.regmatch.rm_ic) {"], "readability/braces"]
["src/nvim/tag.c", ["            match = mb_strnicmp(tagp.tagname, orgpat.pat, (size_t)cmplen) == 0;", "            if (match)", "              match_no_ic = (STRNCMP(tagp.tagname, orgpat.pat,"], "readability/braces"]
["src/nvim/tag.c", ["              match_no_ic = (STRNCMP(tagp.tagname, orgpat.pat,", "                                 cmplen) == 0);", "          } else"], "whitespace/alignment"]
["src/nvim/tag.c", ["                                 cmplen) == 0);", "          } else", "            match = (STRNCMP(tagp.tagname, orgpat.pat, cmplen) == 0);"], "readability/braces"]
["src/nvim/tag.c", ["", "        /*", "         * Has a regexp: Also find tags matching regexp."], "readability/old_style_comment"]
["src/nvim/tag.c", ["         */", "        match_re = FALSE;", "        if (!match && orgpat.regmatch.regprog != NULL) {"], "readability/bool"]
["src/nvim/tag.c", ["            if (orgpat.regmatch.rm_ic) {", "              orgpat.regmatch.rm_ic = FALSE;", "              match_no_ic = vim_regexec(&orgpat.regmatch, tagp.tagname,"], "readability/bool"]
["src/nvim/tag.c", ["              match_no_ic = vim_regexec(&orgpat.regmatch, tagp.tagname,", "                  (colnr_T)0);", "              orgpat.regmatch.rm_ic = TRUE;"], "whitespace/alignment"]
["src/nvim/tag.c", ["                  (colnr_T)0);", "              orgpat.regmatch.rm_ic = TRUE;", "            }"], "readability/bool"]
["src/nvim/tag.c", ["          *tagp.tagname_end = cc;", "          match_re = TRUE;", "        }"], "readability/bool"]
["src/nvim/tag.c", ["          if (use_cscope) {", "            /* Don't change the ordering, always use the same table. */", "            mtt = MT_GL_OTH;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["            if (is_static) {", "              if (is_current)", "                mtt = MT_ST_CUR;"], "readability/braces"]
["src/nvim/tag.c", ["                mtt = MT_ST_CUR;", "              else", "                mtt = MT_ST_OTH;"], "readability/braces"]
["src/nvim/tag.c", ["            } else {", "              if (is_current)", "                mtt = MT_GL_CUR;"], "readability/braces"]
["src/nvim/tag.c", ["                mtt = MT_GL_CUR;", "              else", "                mtt = MT_GL_OTH;"], "readability/braces"]
["src/nvim/tag.c", ["            }", "            if (orgpat.regmatch.rm_ic && !match_no_ic)", "              mtt += MT_IC_OFF;"], "readability/braces"]
["src/nvim/tag.c", ["              mtt += MT_IC_OFF;", "            if (match_re)", "              mtt += MT_RE_OFF;"], "readability/braces"]
["src/nvim/tag.c", ["            STRCPY(p + len + 1, help_lang);", "            snprintf((char *)p + len + 1 + ML_EXTRA, 10, \"%06d\",", "                     help_heuristic(tagp.tagname,"], "runtime/printf"]
["src/nvim/tag.c", ["        }", "        if (use_cscope && eof)", "          break;"], "readability/braces"]
["src/nvim/tag.c", ["          break;", "      }   /* forever */", ""], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "      if (!use_cscope)", "        fclose(fp);"], "readability/braces"]
["src/nvim/tag.c", ["        fclose(fp);", "      if (vimconv.vc_type != CONV_NONE)", "        convert_setup(&vimconv, NULL, NULL);"], "readability/braces"]
["src/nvim/tag.c", ["        EMSG2(_(\"E432: Tags file not sorted: %s\"), tag_fname);", "        sort_error = FALSE;", "      }"], "readability/bool"]
["src/nvim/tag.c", ["", "      /*", "       * Stop searching if sufficient tags have been found."], "readability/old_style_comment"]
["src/nvim/tag.c", ["        retval = OK;", "        stop_searching = TRUE;", "      }"], "readability/bool"]
["src/nvim/tag.c", ["", "      if (stop_searching || use_cscope)", "        break;"], "readability/braces"]
["src/nvim/tag.c", ["        break;", "", "    }   /* end of for-each-file loop */"], "whitespace/blank_line"]
["src/nvim/tag.c", ["", "    }   /* end of for-each-file loop */", ""], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "    if (!use_cscope)", "      tagname_free(&tn);"], "readability/braces"]
["src/nvim/tag.c", ["", "    /* stop searching when already did a linear search, or when TAG_NOIC", "     * used, and 'ignorecase' not set or already did case-ignore search */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["     * used, and 'ignorecase' not set or already did case-ignore search */", "    if (stop_searching || linear || (!p_ic && noic) || orgpat.regmatch.rm_ic)", "      break;"], "readability/braces"]
["src/nvim/tag.c", ["      break;", "    if (use_cscope)", "      break;"], "readability/braces"]
["src/nvim/tag.c", ["      break;", "    orgpat.regmatch.rm_ic = TRUE;       /* try another time while ignoring case */", "  }"], "readability/old_style_comment"]
["src/nvim/tag.c", ["      break;", "    orgpat.regmatch.rm_ic = TRUE;       /* try another time while ignoring case */", "  }"], "whitespace/line_length"]
["src/nvim/tag.c", ["      break;", "    orgpat.regmatch.rm_ic = TRUE;       /* try another time while ignoring case */", "  }"], "readability/bool"]
["src/nvim/tag.c", ["  if (!stop_searching) {", "    if (!did_open && verbose)           /* never opened any tags file */", "      EMSG(_(\"E433: No tags file\"));"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  if (!stop_searching) {", "    if (!did_open && verbose)           /* never opened any tags file */", "      EMSG(_(\"E433: No tags file\"));"], "readability/braces"]
["src/nvim/tag.c", ["      EMSG(_(\"E433: No tags file\"));", "    retval = OK;                /* It's OK even when no tag found */", "  }"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /*", "   * Move the matches from the ga_match[] arrays into one list of"], "readability/old_style_comment"]
["src/nvim/tag.c", ["   */", "  if (retval == FAIL)", "    match_count = 0;"], "readability/braces"]
["src/nvim/tag.c", ["", "  if (match_count > 0)", "    matches = xmalloc(match_count * sizeof(char_u *));"], "readability/braces"]
["src/nvim/tag.c", ["    matches = xmalloc(match_count * sizeof(char_u *));", "  else", "    matches = NULL;"], "readability/braces"]
["src/nvim/tag.c", ["  return retval;", "}", ""], "readability/fn_size"]
["src/nvim/tag.c", ["", "/*", " * Callback function for finding all \"tags\" and \"tags-??\" files in"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Get the next name of a tag file from the tag file list."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  if (first)", "    memset(tnp, 0, sizeof(tagname_T));"], "readability/braces"]
["src/nvim/tag.c", ["  if (curbuf->b_help) {", "    /*", "     * For help files it's done in a completely different way:"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    if (tnp->tn_hf_idx >= tag_fnames.ga_len) {", "      /* Not found in 'runtimepath', use 'helpfile', if it exists and", "       * wasn't used yet, replacing \"help.txt\" with \"tags\". */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["       * wasn't used yet, replacing \"help.txt\" with \"tags\". */", "      if (tnp->tn_hf_idx > tag_fnames.ga_len || *p_hf == NUL)", "        return FAIL;"], "readability/braces"]
["src/nvim/tag.c", ["        return FAIL;", "      ++tnp->tn_hf_idx;", "      STRCPY(buf, p_hf);"], "readability/increment"]
["src/nvim/tag.c", ["  if (first) {", "    /* Init.  We make a copy of 'tags', because autocommands may change", "     * the value without notifying us. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    tnp->tn_tags = vim_strsave((*curbuf->b_p_tags != NUL)", "        ? curbuf->b_p_tags : p_tags);", "    tnp->tn_np = tnp->tn_tags;"], "whitespace/alignment"]
["src/nvim/tag.c", ["", "  /*", "   * Loop until we have found a file name that can be used."], "readability/old_style_comment"]
["src/nvim/tag.c", ["      fname = vim_findfile(tnp->tn_search_ctx);", "      if (fname != NULL)", "        break;"], "readability/braces"]
["src/nvim/tag.c", ["", "      tnp->tn_did_filefind_init = FALSE;", "    } else {"], "readability/bool"]
["src/nvim/tag.c", ["", "      /* Stop when used all parts of 'tags'. */", "      if (*tnp->tn_np == NUL) {"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "      /*", "       * Copy next file name into buf."], "readability/old_style_comment"]
["src/nvim/tag.c", ["      r_ptr = vim_findfile_stopdir(buf);", "      /* move the filename one char forward and truncate the", "       * filepath with a NUL */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["      tnp->tn_search_ctx = vim_findfile_init(buf, filename,", "          r_ptr, 100,", "          FALSE,                   /* don't free visited list */"], "whitespace/alignment"]
["src/nvim/tag.c", ["          r_ptr, 100,", "          FALSE,                   /* don't free visited list */", "          FINDFILE_FILE,           /* we search for a file */"], "whitespace/alignment"]
["src/nvim/tag.c", ["          FALSE,                   /* don't free visited list */", "          FINDFILE_FILE,           /* we search for a file */", "          tnp->tn_search_ctx, TRUE, curbuf->b_ffname);"], "whitespace/alignment"]
["src/nvim/tag.c", ["          FINDFILE_FILE,           /* we search for a file */", "          tnp->tn_search_ctx, TRUE, curbuf->b_ffname);", "      if (tnp->tn_search_ctx != NULL)"], "whitespace/alignment"]
["src/nvim/tag.c", ["          r_ptr, 100,", "          FALSE,                   /* don't free visited list */", "          FINDFILE_FILE,           /* we search for a file */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          r_ptr, 100,", "          FALSE,                   /* don't free visited list */", "          FINDFILE_FILE,           /* we search for a file */"], "readability/bool"]
["src/nvim/tag.c", ["          FALSE,                   /* don't free visited list */", "          FINDFILE_FILE,           /* we search for a file */", "          tnp->tn_search_ctx, TRUE, curbuf->b_ffname);"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          FINDFILE_FILE,           /* we search for a file */", "          tnp->tn_search_ctx, TRUE, curbuf->b_ffname);", "      if (tnp->tn_search_ctx != NULL)"], "readability/bool"]
["src/nvim/tag.c", ["          tnp->tn_search_ctx, TRUE, curbuf->b_ffname);", "      if (tnp->tn_search_ctx != NULL)", "        tnp->tn_did_filefind_init = TRUE;"], "readability/braces"]
["src/nvim/tag.c", ["      if (tnp->tn_search_ctx != NULL)", "        tnp->tn_did_filefind_init = TRUE;", "    }"], "readability/bool"]
["src/nvim/tag.c", ["", "/*", " * Free the contents of a tagname_T that was filled by get_tagfname()."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Parse one line from the tags file. Find start/end of tag name, start/end of"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /* Isolate the tagname, from lbuf up to the first white */", "  tagp->tagname = lbuf;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  p = vim_strchr(lbuf, TAB);", "  if (p == NULL)", "    return FAIL;"], "readability/braces"]
["src/nvim/tag.c", ["", "  /* Isolate file name, from first to second white space */", "  if (*p != NUL)"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  /* Isolate file name, from first to second white space */", "  if (*p != NUL)", "    ++p;"], "readability/braces"]
["src/nvim/tag.c", ["  if (*p != NUL)", "    ++p;", "  tagp->fname = p;"], "readability/increment"]
["src/nvim/tag.c", ["  p = vim_strchr(p, TAB);", "  if (p == NULL)", "    return FAIL;"], "readability/braces"]
["src/nvim/tag.c", ["", "  /* find start of search command, after second white space */", "  if (*p != NUL)"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  /* find start of search command, after second white space */", "  if (*p != NUL)", "    ++p;"], "readability/braces"]
["src/nvim/tag.c", ["  if (*p != NUL)", "    ++p;", "  if (*p == NUL)"], "readability/increment"]
["src/nvim/tag.c", ["    ++p;", "  if (*p == NUL)", "    return FAIL;"], "readability/braces"]
["src/nvim/tag.c", ["", "/*", " * Check if tagname is a static tag"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  while ((p = vim_strchr(p, '\\t')) != NULL) {", "    ++p;", "    if (STRNCMP(p, \"file:\", 5) == 0)"], "readability/increment"]
["src/nvim/tag.c", ["    ++p;", "    if (STRNCMP(p, \"file:\", 5) == 0)", "      return TRUE;"], "readability/braces"]
["src/nvim/tag.c", ["    if (STRNCMP(p, \"file:\", 5) == 0)", "      return TRUE;", "  }"], "readability/bool"]
["src/nvim/tag.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/tag.c", ["", "/*", " * Parse a line from a matching tag.  Does not change the line itself."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /* Find search pattern and the file name for non-etags. */", "  retval = parse_tag_line(lbuf,"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  retval = parse_tag_line(lbuf,", "      tagp);", ""], "whitespace/alignment"]
["src/nvim/tag.c", ["  if (retval == OK) {", "    /* Try to find a kind field: \"kind:<kind>\" or just \"<kind>\"*/", "    p = tagp->command;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          }", "          if (pt == NULL)", "            break;"], "readability/braces"]
["src/nvim/tag.c", ["", "/*", " * Find out the actual file name of a tag.  Concatenate the tags file name"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Jump to a tag that has been found in one of the tag files"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  char_u      *str;", "  char_u      *pbuf;                    /* search pattern buffer */", "  char_u      *pbuf_end;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /* parse the match line into the tagp structure */", "  if (parse_match(lbuf, &tagp) == FAIL) {"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /* copy the command to pbuf[], remove trailing CR/NL */", "  str = tagp.command;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  {", "    /*", "     * Remove the \"<Tab>fieldname:value\" stuff; we don't need it here."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /*", "   * Expand file name, when needed (for environment variables)."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /*", "   * Check if the file with the tag exists before abandoning the current"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  ++RedrawingDisabled;", ""], "readability/increment"]
["src/nvim/tag.c", ["  if (l_g_do_tagpreview != 0) {", "    postponed_split = 0;        /* don't split again below */", "    curwin_save = curwin;       /* Save current window */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    postponed_split = 0;        /* don't split again below */", "    curwin_save = curwin;       /* Save current window */", ""], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "    /*", "     * If we are reusing a window, we may change dir when"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    if (!curwin->w_p_pvw) {", "      full_fname = (char_u *)FullName_save((char *)fname, FALSE);", "      fname = full_fname;"], "readability/bool"]
["src/nvim/tag.c", ["", "      /*", "       * Make the preview window the current window."], "readability/old_style_comment"]
["src/nvim/tag.c", ["  if (keep_help) {", "    /* A :ta from a help file will keep the b_help flag set.  For \":ptag\"", "     * we need to use the flag from the window where we came from. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["     * we need to use the flag from the window where we came from. */", "    if (l_g_do_tagpreview != 0)", "      keep_help_flag = curwin_save->w_buffer->b_help;"], "readability/braces"]
["src/nvim/tag.c", ["      keep_help_flag = curwin_save->w_buffer->b_help;", "    else", "      keep_help_flag = curbuf->b_help;"], "readability/braces"]
["src/nvim/tag.c", ["    secure = 1;", "    ++sandbox;", "    save_magic = p_magic;"], "readability/increment"]
["src/nvim/tag.c", ["", "    /*", "     * If 'cpoptions' contains 't', store the search pattern for the \"n\""], "readability/old_style_comment"]
["src/nvim/tag.c", ["     */", "    if (vim_strchr(p_cpo, CPO_TAGPAT) != NULL)", "      search_options = 0;"], "readability/braces"]
["src/nvim/tag.c", ["      search_options = 0;", "    else", "      search_options = SEARCH_KEEP;"], "readability/braces"]
["src/nvim/tag.c", ["", "    /*", "     * If the command is a search, try here."], "readability/old_style_comment"]
["src/nvim/tag.c", ["    str = pbuf;", "    if (pbuf[0] == '/' || pbuf[0] == '?')", "      str = skip_regexp(pbuf + 1, pbuf[0], FALSE, NULL) + 1;"], "readability/braces"]
["src/nvim/tag.c", ["    if (pbuf[0] == '/' || pbuf[0] == '?')", "      str = skip_regexp(pbuf + 1, pbuf[0], FALSE, NULL) + 1;", "    if (str > pbuf_end - 1) {   /* search command with nothing following */"], "readability/bool"]
["src/nvim/tag.c", ["      str = skip_regexp(pbuf + 1, pbuf[0], FALSE, NULL) + 1;", "    if (str > pbuf_end - 1) {   /* search command with nothing following */", "      save_p_ws = p_ws;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["      save_p_scs = p_scs;", "      p_ws = true;              /* need 'wrapscan' for backward searches */", "      p_ic = FALSE;             /* don't ignore case now */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["      p_ws = true;              /* need 'wrapscan' for backward searches */", "      p_ic = FALSE;             /* don't ignore case now */", "      p_scs = FALSE;"], "readability/old_style_comment"]
["src/nvim/tag.c", ["      p_ws = true;              /* need 'wrapscan' for backward searches */", "      p_ic = FALSE;             /* don't ignore case now */", "      p_scs = FALSE;"], "readability/bool"]
["src/nvim/tag.c", ["      p_ic = FALSE;             /* don't ignore case now */", "      p_scs = FALSE;", "      save_lnum = curwin->w_cursor.lnum;"], "readability/bool"]
["src/nvim/tag.c", ["", "        /*", "         * try again, ignore case now"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        } else {", "          /*", "           * Only give a message when really guessed, not when 'ic'"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "      /* A search command may have positioned the cursor beyond the end", "       * of the line.  May need to correct that here. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    } else {", "      curwin->w_cursor.lnum = 1;                /* start command in line 1 */", "      do_cmdline_cmd((char *)pbuf);"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "    /*", "     * When the command has done something that is not allowed make sure"], "readability/old_style_comment"]
["src/nvim/tag.c", ["     */", "    if (secure == 2)", "      wait_return(TRUE);"], "readability/braces"]
["src/nvim/tag.c", ["    if (secure == 2)", "      wait_return(TRUE);", "    secure = save_secure;"], "readability/bool"]
["src/nvim/tag.c", ["    p_magic = save_magic;", "    --sandbox;", "    /* restore no_hlsearch when keeping the old search pattern */"], "readability/increment"]
["src/nvim/tag.c", ["    --sandbox;", "    /* restore no_hlsearch when keeping the old search pattern */", "    if (search_options) {"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    if (retval == OK) {", "      /*", "       * For a help buffer: Put the cursor line at the top of the window,"], "readability/old_style_comment"]
["src/nvim/tag.c", ["       */", "      if (curbuf->b_help)", "        set_topline(curwin, curwin->w_cursor.lnum);"], "readability/braces"]
["src/nvim/tag.c", ["        set_topline(curwin, curwin->w_cursor.lnum);", "      if ((fdo_flags & FDO_TAG) && old_KeyTyped)", "        foldOpenCursor();"], "readability/braces"]
["src/nvim/tag.c", ["        && curwin != curwin_save && win_valid(curwin_save)) {", "      /* Return cursor to where we were */", "      validate_cursor();"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /*", "   * Expand file name (for environment variables) when needed."], "readability/old_style_comment"]
["src/nvim/tag.c", ["    expanded_fname = ExpandOne(&xpc, fname, NULL,", "        WILD_LIST_NOTFOUND|WILD_SILENT, WILD_EXPAND_FREE);", "    if (expanded_fname != NULL)"], "whitespace/alignment"]
["src/nvim/tag.c", ["        WILD_LIST_NOTFOUND|WILD_SILENT, WILD_EXPAND_FREE);", "    if (expanded_fname != NULL)", "      fname = expanded_fname;"], "readability/braces"]
["src/nvim/tag.c", ["    STRLCPY(retval + (p - tag_fname), fname,", "        MAXPATHL - (p - tag_fname));", "    /*"], "whitespace/alignment"]
["src/nvim/tag.c", ["        MAXPATHL - (p - tag_fname));", "    /*", "     * Translate names like \"src/a/../b/file.c\" into \"src/b/file.c\"."], "readability/old_style_comment"]
["src/nvim/tag.c", ["    simplify_filename(retval);", "  } else", "    retval = vim_strsave(fname);"], "readability/braces"]
["src/nvim/tag.c", ["", "/*", " * Check if we have a tag for the buffer with name \"buf_ffname\"."], "readability/old_style_comment"]
["src/nvim/tag.c", [" */", "static int test_for_current(char_u *fname, char_u *fname_end, char_u *tag_fname, char_u *buf_ffname)", "{"], "whitespace/line_length"]
["src/nvim/tag.c", ["  int c;", "  int retval = FALSE;", "  char_u  *fullname;"], "readability/bool"]
["src/nvim/tag.c", ["", "  if (buf_ffname != NULL) {     /* if the buffer has a name */", "    {"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Find the end of the tagaddress."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "int ", "expand_tags ("], "whitespace/end_of_line"]
["src/nvim/tag.c", ["int ", "expand_tags (", "    int tagnames,                   /* expand tag names */"], "whitespace/parens"]
["src/nvim/tag.c", ["expand_tags (", "    int tagnames,                   /* expand tag names */", "    char_u *pat,"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  if (tagnames)", "    tagnmflag = TAG_NAMES;"], "readability/braces"]
["src/nvim/tag.c", ["    tagnmflag = TAG_NAMES;", "  else", "    tagnmflag = 0;"], "readability/braces"]
["src/nvim/tag.c", ["  if (ret == OK && !tagnames) {", "    /* Reorganize the tags for display and matching as strings of:", "     * \"<tagname>\\0<kind>\\0<filename>\\0\""], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Add a tag field to the dictionary \"dict\"."], "readability/old_style_comment"]
["src/nvim/tag.c", ["      end = start + STRLEN(start);", "      while (end > start && (end[-1] == '\\r' || end[-1] == '\\n'))", "        --end;"], "readability/braces"]
["src/nvim/tag.c", ["      while (end > start && (end[-1] == '\\r' || end[-1] == '\\n'))", "        --end;", "    }"], "readability/increment"]
["src/nvim/tag.c", ["    len = (int)(end - start);", "    if (len > MAXPATHL - 1)", "      len = MAXPATHL - 1;"], "readability/braces"]
["src/nvim/tag.c", ["  if (ret == OK && num_matches > 0) {", "    for (i = 0; i < num_matches; ++i) {", "      int parse_result = parse_match(matches[i], &tp);"], "readability/increment"]
["src/nvim/tag.c", ["      // Avoid an unused variable warning in release builds.", "      (void) parse_result;", "      assert(parse_result == OK);"], "whitespace/cast"]
["src/nvim/tag.c", ["", "            /* Add extra field as a dict entry.  Fields are", "             * separated by Tabs. */"], "readability/old_style_comment"]
["src/nvim/tag.c", ["            n = p;", "            while (*p != NUL && *p >= ' ' && *p < 127 && *p != ':')", "              ++p;"], "readability/braces"]
["src/nvim/tag.c", ["            while (*p != NUL && *p >= ' ' && *p < 127 && *p != ':')", "              ++p;", "            len = (int)(p - n);"], "readability/increment"]
["src/nvim/tag.c", ["              s = ++p;", "              while (*p != NUL && *p >= ' ')", "                ++p;"], "readability/braces"]
["src/nvim/tag.c", ["              while (*p != NUL && *p >= ' ')", "                ++p;", "              n[len] = NUL;"], "readability/increment"]
["src/nvim/tag.c", ["              n[len] = NUL;", "              if (add_tag_field(dict, (char *)n, s, p) == FAIL)", "                ret = FAIL;"], "readability/braces"]
["src/nvim/tag.c", ["              n[len] = ':';", "            } else", "              /* Skip field without colon. */"], "readability/braces"]
["src/nvim/tag.c", ["            } else", "              /* Skip field without colon. */", "              while (*p != NUL && *p >= ' ')"], "readability/old_style_comment"]
["src/nvim/tag.c", ["              /* Skip field without colon. */", "              while (*p != NUL && *p >= ' ')", "                ++p;"], "readability/braces"]
["src/nvim/tag.c", ["              while (*p != NUL && *p >= ' ')", "                ++p;", "            if (*p == NUL)"], "readability/increment"]
["src/nvim/tag.c", ["                ++p;", "            if (*p == NUL)", "              break;"], "readability/braces"]
