["src/nvim/message.c", ["", "/*", " * message.c: functions for displaying messages on the command line"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * To be able to scroll back at the \"more\" and \"hit-enter\" prompts we need to"], "readability/old_style_comment"]
["src/nvim/message.c", ["  msgchunk_T  *sb_prev;", "  char sb_eol;                  /* TRUE when line ends after this text */", "  int sb_msg_col;               /* column in which text starts */"], "readability/old_style_comment"]
["src/nvim/message.c", ["  char sb_eol;                  /* TRUE when line ends after this text */", "  int sb_msg_col;               /* column in which text starts */", "  int sb_attr;                  /* text attributes */"], "readability/old_style_comment"]
["src/nvim/message.c", ["  int sb_msg_col;               /* column in which text starts */", "  int sb_attr;                  /* text attributes */", "  char_u sb_text[1];            /* text to be displayed, actually longer */"], "readability/old_style_comment"]
["src/nvim/message.c", ["  int sb_attr;                  /* text attributes */", "  char_u sb_text[1];            /* text to be displayed, actually longer */", "};"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/* Magic chars used in confirm dialog strings */", "#define DLG_BUTTON_SEP  '\\n'"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "static int confirm_msg_used = FALSE;            /* displaying confirm_msg */", "#ifdef INCLUDE_GENERATED_DECLARATIONS"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "static int confirm_msg_used = FALSE;            /* displaying confirm_msg */", "#ifdef INCLUDE_GENERATED_DECLARATIONS"], "readability/bool"]
["src/nvim/message.c", ["#endif", "static char_u   *confirm_msg = NULL;            /* \":confirm\" message */", "static char_u   *confirm_msg_tail;              /* tail of confirm_msg */"], "readability/old_style_comment"]
["src/nvim/message.c", ["static char_u   *confirm_msg = NULL;            /* \":confirm\" message */", "static char_u   *confirm_msg_tail;              /* tail of confirm_msg */", ""], "readability/old_style_comment"]
["src/nvim/message.c", ["static FILE *verbose_fd = NULL;", "static int verbose_did_open = FALSE;", ""], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * When writing messages to the screen, there are many different situations."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * msg(s) - displays the string 's' on the status line"], "readability/old_style_comment"]
["src/nvim/message.c", ["  if (attr == 0) {", "    set_vim_var_string(VV_STATUSMSG, (char *) s, -1);", "  }"], "whitespace/cast"]
["src/nvim/message.c", ["", "  /*", "   * It is possible that displaying a messages causes a problem (e.g.,"], "readability/old_style_comment"]
["src/nvim/message.c", ["   */", "  if (entered >= 3)", "    return TRUE;"], "readability/braces"]
["src/nvim/message.c", ["  if (entered >= 3)", "    return TRUE;", "  ++entered;"], "readability/bool"]
["src/nvim/message.c", ["    return TRUE;", "  ++entered;", ""], "readability/increment"]
["src/nvim/message.c", ["", "  /* Add message to history (unless it's a repeated kept message or a", "   * truncated message) */"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  /* Truncate the message if needed. */", "  msg_start();"], "readability/old_style_comment"]
["src/nvim/message.c", ["  msg_start();", "  buf = msg_strtrunc(s, FALSE);", "  if (buf != NULL)"], "readability/bool"]
["src/nvim/message.c", ["  buf = msg_strtrunc(s, FALSE);", "  if (buf != NULL)", "    s = buf;"], "readability/braces"]
["src/nvim/message.c", ["  xfree(buf);", "  --entered;", "  return retval;"], "readability/increment"]
["src/nvim/message.c", ["", "/*", " * Truncate a string such that it can be printed without causing a scroll."], "readability/old_style_comment"]
["src/nvim/message.c", ["char_u *", "msg_strtrunc (", "    char_u *s,"], "whitespace/parens"]
["src/nvim/message.c", ["    char_u *s,", "    int force                  /* always truncate */", ")"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  /* May truncate message to avoid a hit-return prompt */", "  if ((!msg_scroll && !need_wait_return && shortmess(SHM_TRUNCALL)"], "readability/old_style_comment"]
["src/nvim/message.c", ["    len = vim_strsize(s);", "    if (msg_scrolled != 0)", "      /* Use all the columns. */"], "readability/braces"]
["src/nvim/message.c", ["    if (msg_scrolled != 0)", "      /* Use all the columns. */", "      room = (int)(Rows - msg_row) * Columns - 1;"], "readability/old_style_comment"]
["src/nvim/message.c", ["      room = (int)(Rows - msg_row) * Columns - 1;", "    else", "      /* Use up to 'showcmd' column. */"], "readability/braces"]
["src/nvim/message.c", ["    else", "      /* Use up to 'showcmd' column. */", "      room = (int)(Rows - msg_row - 1) * Columns + sc_col - 1;"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Truncate a string \"s\" to \"buf\" with cell width \"room\"."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  /* First part: Start of the string. */", "  for (e = 0; len < half && e < buflen; ++e) {"], "readability/old_style_comment"]
["src/nvim/message.c", ["  /* First part: Start of the string. */", "  for (e = 0; len < half && e < buflen; ++e) {", "    if (s[e] == NUL) {"], "readability/increment"]
["src/nvim/message.c", ["    if (s[e] == NUL) {", "      /* text fits without truncating! */", "      buf[e] = NUL;"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Note: Caller of smgs() and smsg_attr() must check the resulting string is"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Remember the last sourcing name/lnum used in an error message, so that it"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Reset the last used sourcing name/lnum.  Makes sure it is displayed again"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Return TRUE if \"sourcing_name\" differs from \"last_sourcing_name\"."], "readability/old_style_comment"]
["src/nvim/message.c", ["  if (sourcing_name != NULL) {", "    if (last_sourcing_name != NULL)", "      return STRCMP(sourcing_name, last_sourcing_name) != 0;"], "readability/braces"]
["src/nvim/message.c", ["      return STRCMP(sourcing_name, last_sourcing_name) != 0;", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/message.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * Display name and line number for the source of an error."], "readability/old_style_comment"]
["src/nvim/message.c", ["    xfree(p);", "    last_sourcing_lnum = sourcing_lnum;      /* only once for each line */", "  }"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  /* remember the last sourcing name printed, also when it's empty */", "  if (sourcing_name == NULL || other_sourcing_name()) {"], "readability/old_style_comment"]
["src/nvim/message.c", ["    xfree(last_sourcing_name);", "    if (sourcing_name == NULL)", "      last_sourcing_name = NULL;"], "readability/braces"]
["src/nvim/message.c", ["      last_sourcing_name = NULL;", "    else", "      last_sourcing_name = vim_strsave(sourcing_name);"], "readability/braces"]
["src/nvim/message.c", ["  }", "  --no_wait_return;", "}"], "readability/increment"]
["src/nvim/message.c", ["", "/*", " * Return TRUE if not giving error messages right now:"], "readability/old_style_comment"]
["src/nvim/message.c", ["{", "  if ((emsg_off > 0 && vim_strchr(p_debug, 'm') == NULL", "       && vim_strchr(p_debug, 't') == NULL)"], "readability/braces"]
["src/nvim/message.c", ["      )", "    return TRUE;", "  return FALSE;"], "readability/bool"]
["src/nvim/message.c", ["    return TRUE;", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/message.c", ["  if (!emsg_off || vim_strchr(p_debug, 't') != NULL) {", "    /*", "     * Cause a throw of an error exception if appropriate.  Don't display"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "    /*", "     * When using \":silent! cmd\" ignore error messages."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  /*", "   * Display name and line number for the source of the error."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Like msg(), but truncate to a single line if p_shm contains 't', or when"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  if (n)", "    return s;"], "readability/braces"]
["src/nvim/message.c", ["", "/*", " * Check if message \"s\" should be truncated at the start (for filenames)."], "readability/old_style_comment"]
["src/nvim/message.c", ["{", "  if (msg_hist_off || msg_silent != 0)", "    return;"], "readability/braces"]
["src/nvim/message.c", ["", "  /* Don't let the message history get too big */", "  while (msg_hist_len > MAX_MSG_HIST_LEN)"], "readability/old_style_comment"]
["src/nvim/message.c", ["  /* Don't let the message history get too big */", "  while (msg_hist_len > MAX_MSG_HIST_LEN)", "    (void)delete_first_msg();"], "readability/braces"]
["src/nvim/message.c", ["", "  /* allocate an entry and add the message at the end of the history */", "  struct msg_hist *p = xmalloc(sizeof(struct msg_hist));"], "readability/old_style_comment"]
["src/nvim/message.c", ["  struct msg_hist *p = xmalloc(sizeof(struct msg_hist));", "  if (len < 0)", "    len = (int)STRLEN(s);"], "readability/braces"]
["src/nvim/message.c", ["    len = (int)STRLEN(s);", "  /* remove leading and trailing newlines */", "  while (len > 0 && *s == '\\n') {"], "readability/old_style_comment"]
["src/nvim/message.c", ["  while (len > 0 && *s == '\\n') {", "    ++s;", "    --len;"], "readability/increment"]
["src/nvim/message.c", ["    ++s;", "    --len;", "  }"], "readability/increment"]
["src/nvim/message.c", ["", "/*", " * Delete the first (oldest) message from the history."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  if (msg_hist_len <= 0)", "    return FAIL;"], "readability/braces"]
["src/nvim/message.c", ["  first_msg_hist = p->next;", "  if (first_msg_hist == NULL) {  /* history is becoming empty */", "    assert(msg_hist_len == 1);"], "readability/old_style_comment"]
["src/nvim/message.c", ["  xfree(p);", "  --msg_hist_len;", "  return OK;"], "readability/increment"]
["src/nvim/message.c", ["", "/*", " * Call this after prompting the user.  This will avoid a hit-return message"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  /* If using \":silent cmd\", don't wait for a return.  Also don't set", "   * need_wait_return to do it later. */"], "readability/old_style_comment"]
["src/nvim/message.c", ["   * need_wait_return to do it later. */", "  if (msg_silent != 0)", "    return;"], "readability/braces"]
["src/nvim/message.c", ["", "  /*", "   * When inside vgetc(), we can't wait for a typed character at all."], "readability/old_style_comment"]
["src/nvim/message.c", ["   */", "  if (vgetc_busy > 0)", "    return;"], "readability/braces"]
["src/nvim/message.c", ["    return;", "  need_wait_return = TRUE;", "  if (no_wait_return) {"], "readability/bool"]
["src/nvim/message.c", ["  if (no_wait_return) {", "    if (!exmode_active)", "      cmdline_row = msg_row;"], "readability/braces"]
["src/nvim/message.c", ["", "  redir_off = TRUE;             /* don't redirect this message */", "  oldState = State;"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  redir_off = TRUE;             /* don't redirect this message */", "  oldState = State;"], "readability/bool"]
["src/nvim/message.c", ["  if (quit_more) {", "    c = CAR;                    /* just pretend CR was hit */", "    quit_more = FALSE;"], "readability/old_style_comment"]
["src/nvim/message.c", ["    c = CAR;                    /* just pretend CR was hit */", "    quit_more = FALSE;", "    got_int = FALSE;"], "readability/bool"]
["src/nvim/message.c", ["    quit_more = FALSE;", "    got_int = FALSE;", "  } else if (exmode_active) {"], "readability/bool"]
["src/nvim/message.c", ["  } else if (exmode_active) {", "    MSG_PUTS(\" \");              /* make sure the cursor is on the right line */", "    c = CAR;                    /* no need for a return in ex mode */"], "readability/old_style_comment"]
["src/nvim/message.c", ["    MSG_PUTS(\" \");              /* make sure the cursor is on the right line */", "    c = CAR;                    /* no need for a return in ex mode */", "    got_int = FALSE;"], "readability/old_style_comment"]
["src/nvim/message.c", ["    c = CAR;                    /* no need for a return in ex mode */", "    got_int = FALSE;", "  } else {"], "readability/bool"]
["src/nvim/message.c", ["    do {", "      /* Remember \"got_int\", if it is set vgetc() probably returns a", "       * CTRL-C, but we need to loop then. */"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "      /*", "       * Allow scrolling back in the messages."], "readability/old_style_comment"]
["src/nvim/message.c", ["            || c == K_UP || c == K_PAGEUP) {", "          if (msg_scrolled > Rows)", "            /* scroll back to show older messages */"], "readability/braces"]
["src/nvim/message.c", ["          if (msg_scrolled > Rows)", "            /* scroll back to show older messages */", "            do_more_prompt(c);"], "readability/old_style_comment"]
["src/nvim/message.c", ["            do_more_prompt(c);", "          else {", "            msg_didout = FALSE;"], "readability/braces"]
["src/nvim/message.c", ["            do_more_prompt(c);", "          else {", "            msg_didout = FALSE;"], "readability/braces"]
["src/nvim/message.c", ["          else {", "            msg_didout = FALSE;", "            c = K_IGNORE;"], "readability/bool"]
["src/nvim/message.c", ["          if (quit_more) {", "            c = CAR;                            /* just pretend CR was hit */", "            quit_more = FALSE;"], "readability/old_style_comment"]
["src/nvim/message.c", ["            c = CAR;                            /* just pretend CR was hit */", "            quit_more = FALSE;", "            got_int = FALSE;"], "readability/bool"]
["src/nvim/message.c", ["            quit_more = FALSE;", "            got_int = FALSE;", "          } else if (c != K_IGNORE) {"], "readability/bool"]
["src/nvim/message.c", ["          }", "        } else if (msg_scrolled > Rows - 2", "                   && (c == 'j' || c == 'd' || c == 'f'"], "readability/braces"]
["src/nvim/message.c", ["    os_breakcheck();", "    /*", "     * Avoid that the mouse-up event causes visual mode to start."], "readability/old_style_comment"]
["src/nvim/message.c", ["     */", "    if (c == K_LEFTMOUSE || c == K_MIDDLEMOUSE || c == K_RIGHTMOUSE", "        || c == K_X1MOUSE || c == K_X2MOUSE)"], "readability/braces"]
["src/nvim/message.c", ["      (void)jump_to_mouse(MOUSE_SETPOS, NULL, 0);", "    else if (vim_strchr((char_u *)\"\\r\\n \", c) == NULL && c != Ctrl_C) {", "      /* Put the character back in the typeahead buffer.  Don't use the"], "readability/braces"]
["src/nvim/message.c", ["    else if (vim_strchr((char_u *)\"\\r\\n \", c) == NULL && c != Ctrl_C) {", "      /* Put the character back in the typeahead buffer.  Don't use the", "       * stuff buffer, because lmaps wouldn't work. */"], "readability/old_style_comment"]
["src/nvim/message.c", ["  if (c == ':' || c == '?' || c == '/') {", "    if (!exmode_active)", "      cmdline_row = msg_row;"], "readability/braces"]
["src/nvim/message.c", ["", "  if (tmpState == SETWSIZE) {       /* got resize event while in vgetc() */", "    ui_refresh();"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Write the hit-return prompt."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  p_more = FALSE;       /* don't want see this message when scrolling back */", "  if (msg_didout)       /* start on a new line */"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  p_more = FALSE;       /* don't want see this message when scrolling back */", "  if (msg_didout)       /* start on a new line */"], "readability/bool"]
["src/nvim/message.c", ["  p_more = FALSE;       /* don't want see this message when scrolling back */", "  if (msg_didout)       /* start on a new line */", "    msg_putchar('\\n');"], "readability/old_style_comment"]
["src/nvim/message.c", ["  p_more = FALSE;       /* don't want see this message when scrolling back */", "  if (msg_didout)       /* start on a new line */", "    msg_putchar('\\n');"], "readability/braces"]
["src/nvim/message.c", ["", "/*", " * Set \"keep_msg\" to \"s\".  Free the old value and check for NULL pointer."], "readability/old_style_comment"]
["src/nvim/message.c", ["  xfree(keep_msg);", "  if (s != NULL && msg_silent == 0)", "    keep_msg = vim_strsave(s);"], "readability/braces"]
["src/nvim/message.c", ["    keep_msg = vim_strsave(s);", "  else", "    keep_msg = NULL;"], "readability/braces"]
["src/nvim/message.c", ["    keep_msg = NULL;", "  keep_msg_more = FALSE;", "  keep_msg_attr = attr;"], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * Prepare for outputting characters in the command line."], "readability/old_style_comment"]
["src/nvim/message.c", ["    msg_putchar('\\n');", "    did_return = TRUE;", "    if (exmode_active != EXMODE_NORMAL)"], "readability/bool"]
["src/nvim/message.c", ["    did_return = TRUE;", "    if (exmode_active != EXMODE_NORMAL)", "      cmdline_row = msg_row;"], "readability/braces"]
["src/nvim/message.c", ["  }", "  if (!msg_didany || lines_left < 0)", "    msg_starthere();"], "readability/braces"]
["src/nvim/message.c", ["", "/*", " * Note that the current msg position is where messages start."], "readability/old_style_comment"]
["src/nvim/message.c", ["  lines_left = cmdline_row;", "  msg_didany = FALSE;", "}"], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * Output 'len' characters in 'str' (including NULs) with translation"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Output one character at \"p\".  Return pointer to the next character."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  /* if MSG_HIST flag set, add message to history */", "  if (attr & MSG_HIST) {"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  /*", "   * Go over the string.  Special characters are translated and printed."], "readability/old_style_comment"]
["src/nvim/message.c", ["  arg = skipwhite(arg);", "  for (i = 5; *arg && i >= 0; --i)", "    if (*arg++ != str[i])"], "readability/braces"]
["src/nvim/message.c", ["  arg = skipwhite(arg);", "  for (i = 5; *arg && i >= 0; --i)", "    if (*arg++ != str[i])"], "readability/increment"]
["src/nvim/message.c", ["  for (i = 5; *arg && i >= 0; --i)", "    if (*arg++ != str[i])", "      break;"], "readability/braces"]
["src/nvim/message.c", ["    msg_putchar('\\n');", "    for (i = 0; rs[i]; ++i)", "      msg_putchar(rs[i] - 3);"], "readability/braces"]
["src/nvim/message.c", ["    msg_putchar('\\n');", "    for (i = 0; rs[i]; ++i)", "      msg_putchar(rs[i] - 3);"], "readability/increment"]
["src/nvim/message.c", ["", "/*", " * print line for :print or :list command"], "readability/old_style_comment"]
["src/nvim/message.c", ["        c = *p_extra++;", "        /* Use special coloring to be able to distinguish <hex> from", "         * the same in plain text. */"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "    if (c == NUL)", "      break;"], "readability/braces"]
["src/nvim/message.c", ["      msg_col = Columns;", "      ++msg_row;", "    }"], "readability/increment"]
["src/nvim/message.c", ["      msg_col = 0;", "      ++msg_row;", "    }"], "readability/increment"]
["src/nvim/message.c", ["", "/*", " * Output a string to the screen at position msg_row, msg_col."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Show a message in such a way that it always fits in the line.  Cut out a"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Basic function for writing a message with highlight attributes."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * The display part of msg_puts_attr_len()."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "      /* When no more prompt and no more room, truncate here */", "      if (msg_no_more && lines_left == 0)"], "readability/old_style_comment"]
["src/nvim/message.c", ["      /* When no more prompt and no more room, truncate here */", "      if (msg_no_more && lines_left == 0)", "        break;"], "readability/braces"]
["src/nvim/message.c", ["      msg_row = Rows - 2;", "      if (msg_col >= Columns)           /* can happen after screen resize */", "        msg_col = Columns - 1;"], "readability/old_style_comment"]
["src/nvim/message.c", ["      msg_row = Rows - 2;", "      if (msg_col >= Columns)           /* can happen after screen resize */", "        msg_col = Columns - 1;"], "readability/braces"]
["src/nvim/message.c", ["", "      /*", "       * If screen is completely filled and 'more' is set then wait"], "readability/old_style_comment"]
["src/nvim/message.c", ["       */", "      if (lines_left > 0)", "        --lines_left;"], "readability/braces"]
["src/nvim/message.c", ["      if (lines_left > 0)", "        --lines_left;", "      if (p_more && lines_left == 0 && State != HITRETURN"], "readability/increment"]
["src/nvim/message.c", ["          && !msg_no_more && !exmode_active) {", "        if (do_more_prompt(NUL))", "          s = confirm_msg_tail;"], "readability/braces"]
["src/nvim/message.c", ["          s = confirm_msg_tail;", "        if (quit_more)", "          return;"], "readability/braces"]
["src/nvim/message.c", ["", "      /* When we displayed a char in last column need to check if there", "       * is still more. */"], "readability/old_style_comment"]
["src/nvim/message.c", ["       * is still more. */", "      if (did_last_char)", "        continue;"], "readability/braces"]
["src/nvim/message.c", ["               && msg_col + t_col >= Columns - 1)", "    ;", "    if (t_col > 0 && (wrap || *s == '\\r' || *s == '\\b'"], "whitespace/semicolon"]
["src/nvim/message.c", ["", "    if (*s == '\\n') {               /* go to next line */", "      msg_didout = FALSE;           /* remember that line is empty */"], "readability/old_style_comment"]
["src/nvim/message.c", ["    if (*s == '\\n') {               /* go to next line */", "      msg_didout = FALSE;           /* remember that line is empty */", "      if (cmdmsg_rl)"], "readability/old_style_comment"]
["src/nvim/message.c", ["    if (*s == '\\n') {               /* go to next line */", "      msg_didout = FALSE;           /* remember that line is empty */", "      if (cmdmsg_rl)"], "readability/bool"]
["src/nvim/message.c", ["      msg_didout = FALSE;           /* remember that line is empty */", "      if (cmdmsg_rl)", "        msg_col = Columns - 1;"], "readability/braces"]
["src/nvim/message.c", ["        msg_col = Columns - 1;", "      else", "        msg_col = 0;"], "readability/braces"]
["src/nvim/message.c", ["        msg_col = 0;", "      if (++msg_row >= Rows)        /* safety check */", "        msg_row = Rows - 1;"], "readability/old_style_comment"]
["src/nvim/message.c", ["        msg_col = 0;", "      if (++msg_row >= Rows)        /* safety check */", "        msg_row = Rows - 1;"], "readability/braces"]
["src/nvim/message.c", ["        msg_row = Rows - 1;", "    } else if (*s == '\\r') {      /* go to column 0 */", "      msg_col = 0;"], "readability/old_style_comment"]
["src/nvim/message.c", ["      msg_col = 0;", "    } else if (*s == '\\b') {      /* go to previous char */", "      if (msg_col)"], "readability/old_style_comment"]
["src/nvim/message.c", ["    } else if (*s == '\\b') {      /* go to previous char */", "      if (msg_col)", "        --msg_col;"], "readability/braces"]
["src/nvim/message.c", ["      if (msg_col)", "        --msg_col;", "    } else if (*s == TAB) {       /* translate Tab into spaces */"], "readability/increment"]
["src/nvim/message.c", ["        --msg_col;", "    } else if (*s == TAB) {       /* translate Tab into spaces */", "      do {"], "readability/old_style_comment"]
["src/nvim/message.c", ["      } else {", "        /* postpone this character until later */", "        if (t_col == 0)"], "readability/old_style_comment"]
["src/nvim/message.c", ["        /* postpone this character until later */", "        if (t_col == 0)", "          t_s = s;"], "readability/braces"]
["src/nvim/message.c", ["    }", "    ++s;", "  }"], "readability/increment"]
["src/nvim/message.c", ["", "/*", " * Increment \"msg_scrolled\"."], "readability/old_style_comment"]
["src/nvim/message.c", ["  if (*get_vim_var_str(VV_SCROLLSTART) == NUL) {", "    char *p = (char *) sourcing_name;", "    char *tofree = NULL;"], "whitespace/cast"]
["src/nvim/message.c", ["      vim_snprintf(tofree, len, _(\"%s line %\" PRId64),", "                   p, (int64_t) sourcing_lnum);", "      p = tofree;"], "whitespace/cast"]
["src/nvim/message.c", ["    mp->sb_next = NULL;", "  } else if (finish && last_msgchunk != NULL)", "    last_msgchunk->sb_eol = TRUE;"], "readability/braces"]
["src/nvim/message.c", ["  } else if (finish && last_msgchunk != NULL)", "    last_msgchunk->sb_eol = TRUE;", ""], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * Finished showing messages, clear the scroll-back text on the next message."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * \"g<\" command."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  /* Only show something if there is more than one line, otherwise it looks", "   * weird, typing a command without output results in one line. */"], "readability/old_style_comment"]
["src/nvim/message.c", ["    do_more_prompt('G');", "    wait_return(FALSE);", "  }"], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * Move to the start of screen line in already displayed text."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  while (mp != NULL && mp->sb_prev != NULL && !mp->sb_prev->sb_eol)", "    mp = mp->sb_prev;"], "readability/braces"]
["src/nvim/message.c", ["", "/*", " * Mark the last message chunk as finishing the line."], "readability/old_style_comment"]
["src/nvim/message.c", ["{", "  if (last_msgchunk != NULL)", "    last_msgchunk->sb_eol = TRUE;"], "readability/braces"]
["src/nvim/message.c", ["  if (last_msgchunk != NULL)", "    last_msgchunk->sb_eol = TRUE;", "}"], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * Display a screen line from previously displayed text at row \"row\"."], "readability/old_style_comment"]
["src/nvim/message.c", ["    p = mp->sb_text;", "    if (*p == '\\n')         /* don't display the line break */", "      ++p;"], "readability/old_style_comment"]
["src/nvim/message.c", ["    p = mp->sb_text;", "    if (*p == '\\n')         /* don't display the line break */", "      ++p;"], "readability/braces"]
["src/nvim/message.c", ["    if (*p == '\\n')         /* don't display the line break */", "      ++p;", "    msg_puts_display(p, -1, mp->sb_attr, TRUE);"], "readability/increment"]
["src/nvim/message.c", ["      ++p;", "    msg_puts_display(p, -1, mp->sb_attr, TRUE);", "    if (mp->sb_eol || mp->sb_next == NULL)"], "readability/bool"]
["src/nvim/message.c", ["    msg_puts_display(p, -1, mp->sb_attr, TRUE);", "    if (mp->sb_eol || mp->sb_next == NULL)", "      break;"], "readability/braces"]
["src/nvim/message.c", ["", "/*", " * Output any postponed text for msg_puts_attr_len()."], "readability/old_style_comment"]
["src/nvim/message.c", ["  *t_col = 0;", "  /* If the string starts with a composing character don't increment the", "   * column position for it. */"], "readability/old_style_comment"]
["src/nvim/message.c", ["    msg_col = 0;", "    ++msg_row;", "  }"], "readability/increment"]
["src/nvim/message.c", ["", "/*", " * Show the more-prompt and handle the user response."], "readability/old_style_comment"]
["src/nvim/message.c", ["  int c;", "  int retval = FALSE;", "  int toscroll;"], "readability/bool"]
["src/nvim/message.c", ["  if (typed_char == 'G') {", "    /* \"g<\": Find first line on the last page. */", "    mp_last = msg_sb_start(last_msgchunk);"], "readability/old_style_comment"]
["src/nvim/message.c", ["    mp_last = msg_sb_start(last_msgchunk);", "    for (i = 0; i < Rows - 2 && mp_last != NULL", "         && mp_last->sb_prev != NULL; ++i)"], "readability/braces"]
["src/nvim/message.c", ["    for (i = 0; i < Rows - 2 && mp_last != NULL", "         && mp_last->sb_prev != NULL; ++i)", "      mp_last = msg_sb_start(mp_last->sb_prev);"], "readability/increment"]
["src/nvim/message.c", ["  setmouse();", "  if (typed_char == NUL)", "    msg_moremsg(FALSE);"], "readability/braces"]
["src/nvim/message.c", ["  if (typed_char == NUL)", "    msg_moremsg(FALSE);", "  for (;; ) {"], "readability/bool"]
["src/nvim/message.c", ["  for (;; ) {", "    /*", "     * Get a typed character directly from the user."], "readability/old_style_comment"]
["src/nvim/message.c", ["    if (used_typed_char != NUL) {", "      c = used_typed_char;              /* was typed at hit-enter prompt */", "      used_typed_char = NUL;"], "readability/old_style_comment"]
["src/nvim/message.c", ["    switch (c) {", "    case BS:                    /* scroll one line back */", "    case K_BS:"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "    case CAR:                   /* one extra line */", "    case NL:"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "    case 'u':                   /* Up half a page */", "      toscroll = -(Rows / 2);"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "    case 'd':                   /* Down half a page */", "      toscroll = Rows / 2;"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "    case 'b':                   /* one page back */", "    case K_PAGEUP:"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "    case ' ':                   /* one extra page */", "    case 'f':"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "    case 'g':                   /* all the way back to the start */", "      toscroll = -999999;"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "    case 'G':                   /* all the way to the end */", "      toscroll = 999999;"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "    case ':':                   /* start new command line */", "      if (!confirm_msg_used) {"], "readability/old_style_comment"]
["src/nvim/message.c", ["      if (!confirm_msg_used) {", "        /* Since got_int is set all typeahead will be flushed, but we", "         * want to keep this ':', remember that in a special way. */"], "readability/old_style_comment"]
["src/nvim/message.c", ["        typeahead_noflush(':');", "        cmdline_row = Rows - 1;                 /* put ':' on this line */", "        skip_redraw = TRUE;                     /* skip redraw once */"], "readability/old_style_comment"]
["src/nvim/message.c", ["        cmdline_row = Rows - 1;                 /* put ':' on this line */", "        skip_redraw = TRUE;                     /* skip redraw once */", "        need_wait_return = FALSE;               /* don't wait in main() */"], "readability/old_style_comment"]
["src/nvim/message.c", ["        cmdline_row = Rows - 1;                 /* put ':' on this line */", "        skip_redraw = TRUE;                     /* skip redraw once */", "        need_wait_return = FALSE;               /* don't wait in main() */"], "readability/bool"]
["src/nvim/message.c", ["        skip_redraw = TRUE;                     /* skip redraw once */", "        need_wait_return = FALSE;               /* don't wait in main() */", "      }"], "readability/old_style_comment"]
["src/nvim/message.c", ["        skip_redraw = TRUE;                     /* skip redraw once */", "        need_wait_return = FALSE;               /* don't wait in main() */", "      }"], "readability/bool"]
["src/nvim/message.c", ["      if (confirm_msg_used) {", "        /* Jump to the choices of the dialog. */", "        retval = TRUE;"], "readability/old_style_comment"]
["src/nvim/message.c", ["        /* Jump to the choices of the dialog. */", "        retval = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/message.c", ["      } else {", "        got_int = TRUE;", "        quit_more = TRUE;"], "readability/bool"]
["src/nvim/message.c", ["        got_int = TRUE;", "        quit_more = TRUE;", "      }"], "readability/bool"]
["src/nvim/message.c", ["      }", "      /* When there is some more output (wrapping line) display that", "       * without another prompt. */"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "    default:                    /* no valid response */", "      msg_moremsg(TRUE);"], "readability/old_style_comment"]
["src/nvim/message.c", ["    default:                    /* no valid response */", "      msg_moremsg(TRUE);", "      continue;"], "readability/bool"]
["src/nvim/message.c", ["", "        /* go to start of line at top of the screen */", "        for (i = 0; i < Rows - 2 && mp != NULL && mp->sb_prev != NULL;"], "readability/old_style_comment"]
["src/nvim/message.c", ["        /* go to start of line at top of the screen */", "        for (i = 0; i < Rows - 2 && mp != NULL && mp->sb_prev != NULL;", "             ++i)"], "readability/braces"]
["src/nvim/message.c", ["        for (i = 0; i < Rows - 2 && mp != NULL && mp->sb_prev != NULL;", "             ++i)", "          mp = msg_sb_start(mp->sb_prev);"], "readability/increment"]
["src/nvim/message.c", ["            mp = msg_sb_start(mp->sb_prev);", "            if (mp_last == NULL)", "              mp_last = msg_sb_start(last_msgchunk);"], "readability/braces"]
["src/nvim/message.c", ["              mp_last = msg_sb_start(last_msgchunk);", "            else", "              mp_last = msg_sb_start(mp_last->sb_prev);"], "readability/braces"]
["src/nvim/message.c", ["              mp = disp_sb_line(i, mp);", "              ++msg_scrolled;", "            }"], "readability/increment"]
["src/nvim/message.c", ["      } else {", "        /* First display any text that we scrolled back. */", "        while (toscroll > 0 && mp_last != NULL) {"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "      /* display more text, return to caller */", "      lines_left = toscroll;"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Put a character on the screen at the current message position and advance"], "readability/old_style_comment"]
["src/nvim/message.c", ["      msg_col = Columns;", "      ++msg_row;", "    }"], "readability/increment"]
["src/nvim/message.c", ["      msg_col = 0;", "      ++msg_row;", "    }"], "readability/increment"]
["src/nvim/message.c", ["", "/*", " * Repeat the message for the current mode: ASKMORE, EXTERNCMD, CONFIRM or"], "readability/old_style_comment"]
["src/nvim/message.c", ["  if (State == ASKMORE) {", "    msg_moremsg(TRUE);          /* display --more-- message again */", "    msg_row = Rows - 1;"], "readability/old_style_comment"]
["src/nvim/message.c", ["  if (State == ASKMORE) {", "    msg_moremsg(TRUE);          /* display --more-- message again */", "    msg_row = Rows - 1;"], "readability/bool"]
["src/nvim/message.c", ["  } else if (State == CONFIRM) {", "    display_confirm_msg();      /* display \":confirm\" message again */", "    msg_row = Rows - 1;"], "readability/old_style_comment"]
["src/nvim/message.c", ["  } else if (State == EXTERNCMD) {", "    ui_cursor_goto(msg_row, msg_col);     /* put cursor back */", "  } else if (State == HITRETURN || State == SETWSIZE) {"], "readability/old_style_comment"]
["src/nvim/message.c", ["    if (msg_row == Rows - 1) {", "      /* Avoid drawing the \"hit-enter\" prompt below the previous one,", "       * overwrite it.  Esp. useful when regaining focus and a"], "readability/old_style_comment"]
["src/nvim/message.c", ["       * FocusGained autocmd exists but didn't draw anything. */", "      msg_didout = FALSE;", "      msg_col = 0;"], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * Clear from current message position to end of screen."], "readability/old_style_comment"]
["src/nvim/message.c", ["{", "  if (msg_silent == 0)", "    msg_clr_eos_force();"], "readability/braces"]
["src/nvim/message.c", ["", "/*", " * Clear from current message position to end of screen."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Clear the command line."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * end putting a message on the screen"], "readability/old_style_comment"]
["src/nvim/message.c", ["{", "  /*", "   * If the string is larger than the window,"], "readability/old_style_comment"]
["src/nvim/message.c", ["  if (!exiting && need_wait_return && !(State & CMDLINE)) {", "    wait_return(FALSE);", "    return FALSE;"], "readability/bool"]
["src/nvim/message.c", ["    wait_return(FALSE);", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * If the written message runs into the shown command or ruler, we have to"], "readability/old_style_comment"]
["src/nvim/message.c", ["  if (msg_row == Rows - 1 && msg_col >= sc_col) {", "    need_wait_return = TRUE;", "    redraw_cmdline = TRUE;"], "readability/bool"]
["src/nvim/message.c", ["    need_wait_return = TRUE;", "    redraw_cmdline = TRUE;", "  }"], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * May write a string to the redirection file."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  /* Don't do anything for displaying prompts and the like. */", "  if (redir_off)"], "readability/old_style_comment"]
["src/nvim/message.c", ["  /* Don't do anything for displaying prompts and the like. */", "  if (redir_off)", "    return;"], "readability/braces"]
["src/nvim/message.c", ["", "  /* If 'verbosefile' is set prepare for writing in that file. */", "  if (*p_vfile != NUL && verbose_fd == NULL)"], "readability/old_style_comment"]
["src/nvim/message.c", ["  /* If 'verbosefile' is set prepare for writing in that file. */", "  if (*p_vfile != NUL && verbose_fd == NULL)", "    verbose_open();"], "readability/braces"]
["src/nvim/message.c", ["  if (redirecting()) {", "    /* If the string doesn't start with CR or NL, go to msg_col */", "    if (*s != '\\n' && *s != '\\r') {"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "    if (msg_silent != 0)        /* should update msg_col */", "      msg_col = cur_col;"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "    if (msg_silent != 0)        /* should update msg_col */", "      msg_col = cur_col;"], "readability/braces"]
["src/nvim/message.c", ["", "/*", " * Before giving verbose message."], "readability/old_style_comment"]
["src/nvim/message.c", ["{", "  if (*p_vfile != NUL)", "    ++msg_silent;"], "readability/braces"]
["src/nvim/message.c", ["  if (*p_vfile != NUL)", "    ++msg_silent;", "}"], "readability/increment"]
["src/nvim/message.c", ["", "/*", " * After giving verbose message."], "readability/old_style_comment"]
["src/nvim/message.c", ["{", "  if (*p_vfile != NUL)", "    if (--msg_silent < 0)"], "readability/braces"]
["src/nvim/message.c", ["  if (*p_vfile != NUL)", "    if (--msg_silent < 0)", "      msg_silent = 0;"], "readability/braces"]
["src/nvim/message.c", ["", "/*", " * Like verbose_enter() and set msg_scroll when displaying the message."], "readability/old_style_comment"]
["src/nvim/message.c", ["{", "  if (*p_vfile != NUL)", "    ++msg_silent;"], "readability/braces"]
["src/nvim/message.c", ["  if (*p_vfile != NUL)", "    ++msg_silent;", "  else"], "readability/increment"]
["src/nvim/message.c", ["    ++msg_silent;", "  else", "    /* always scroll up, don't overwrite */"], "readability/braces"]
["src/nvim/message.c", ["  else", "    /* always scroll up, don't overwrite */", "    msg_scroll = TRUE;"], "readability/old_style_comment"]
["src/nvim/message.c", ["    /* always scroll up, don't overwrite */", "    msg_scroll = TRUE;", "}"], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * Like verbose_leave() and set cmdline_row when displaying the message."], "readability/old_style_comment"]
["src/nvim/message.c", ["  if (*p_vfile != NUL) {", "    if (--msg_silent < 0)", "      msg_silent = 0;"], "readability/braces"]
["src/nvim/message.c", ["      msg_silent = 0;", "  } else", "    cmdline_row = msg_row;"], "readability/braces"]
["src/nvim/message.c", ["", "/*", " * Called when 'verbosefile' is set: stop writing to the file."], "readability/old_style_comment"]
["src/nvim/message.c", ["  }", "  verbose_did_open = FALSE;", "}"], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * Open the file 'verbosefile'."], "readability/old_style_comment"]
["src/nvim/message.c", ["  if (verbose_fd == NULL && !verbose_did_open) {", "    /* Only give the error message once. */", "    verbose_did_open = TRUE;"], "readability/old_style_comment"]
["src/nvim/message.c", ["    /* Only give the error message once. */", "    verbose_did_open = TRUE;", ""], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * Give a warning message (for searching)."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Advance msg cursor to column \"col\"."], "readability/old_style_comment"]
["src/nvim/message.c", ["{", "  if (msg_silent != 0) {        /* nothing to advance to */", "    msg_col = col;              /* for redirection, may fill it up later */"], "readability/old_style_comment"]
["src/nvim/message.c", ["  if (msg_silent != 0) {        /* nothing to advance to */", "    msg_col = col;              /* for redirection, may fill it up later */", "    return;"], "readability/old_style_comment"]
["src/nvim/message.c", ["  }", "  if (col >= Columns)           /* not enough room */", "    col = Columns - 1;"], "readability/old_style_comment"]
["src/nvim/message.c", ["  }", "  if (col >= Columns)           /* not enough room */", "    col = Columns - 1;"], "readability/braces"]
["src/nvim/message.c", ["    col = Columns - 1;", "  if (cmdmsg_rl)", "    while (msg_col > Columns - col)"], "readability/braces"]
["src/nvim/message.c", ["  if (cmdmsg_rl)", "    while (msg_col > Columns - col)", "      msg_putchar(' ');"], "readability/braces"]
["src/nvim/message.c", ["      msg_putchar(' ');", "  else", "    while (msg_col < col)"], "readability/braces"]
["src/nvim/message.c", ["  else", "    while (msg_col < col)", "      msg_putchar(' ');"], "readability/braces"]
["src/nvim/message.c", ["", "/*", " * Used for \"confirm()\" function, and the :confirm command prefix."], "readability/old_style_comment"]
["src/nvim/message.c", ["int", "do_dialog (", "    int type,"], "whitespace/parens"]
["src/nvim/message.c", ["    char_u *textfield,          /* IObuff for inputdialog(), NULL", "                                           otherwise */", "    int ex_cmd                 /* when TRUE pressing : accepts default and starts"], "whitespace/indent"]
["src/nvim/message.c", ["    int ex_cmd                 /* when TRUE pressing : accepts default and starts", "                               Ex command */", ")"], "whitespace/indent"]
["src/nvim/message.c", ["    int dfltbutton,", "    char_u *textfield,          /* IObuff for inputdialog(), NULL", "                                           otherwise */"], "readability/multiline_comment"]
["src/nvim/message.c", ["    int dfltbutton,", "    char_u *textfield,          /* IObuff for inputdialog(), NULL", "                                           otherwise */"], "readability/old_style_comment"]
["src/nvim/message.c", ["                                           otherwise */", "    int ex_cmd                 /* when TRUE pressing : accepts default and starts", "                               Ex command */"], "readability/multiline_comment"]
["src/nvim/message.c", ["                                           otherwise */", "    int ex_cmd                 /* when TRUE pressing : accepts default and starts", "                               Ex command */"], "readability/old_style_comment"]
["src/nvim/message.c", ["                                           otherwise */", "    int ex_cmd                 /* when TRUE pressing : accepts default and starts", "                               Ex command */"], "whitespace/line_length"]
["src/nvim/message.c", ["                                           otherwise */", "    int ex_cmd                 /* when TRUE pressing : accepts default and starts", "                               Ex command */"], "readability/bool"]
["src/nvim/message.c", ["", "  /*", "   * Since we wait for a keypress, don't make the"], "readability/old_style_comment"]
["src/nvim/message.c", ["   */", "  ++no_wait_return;", "  hotkeys = msg_show_console_dialog(message, buttons, dfltbutton);"], "readability/increment"]
["src/nvim/message.c", ["    switch (c) {", "    case CAR:                 /* User accepts default option */", "    case NL:"], "readability/old_style_comment"]
["src/nvim/message.c", ["      break;", "    case Ctrl_C:              /* User aborts/cancels */", "    case ESC:"], "readability/old_style_comment"]
["src/nvim/message.c", ["      break;", "    default:                  /* Could be a hotkey? */", "      if (c < 0) {            /* special keys are ignored here */"], "readability/old_style_comment"]
["src/nvim/message.c", ["    default:                  /* Could be a hotkey? */", "      if (c < 0) {            /* special keys are ignored here */", "        continue;"], "readability/old_style_comment"]
["src/nvim/message.c", ["      }", "      if (hotkeys[i])", "        break;"], "readability/braces"]
["src/nvim/message.c", ["        break;", "      /* No hotkey match, so keep waiting */", "      continue;"], "readability/old_style_comment"]
["src/nvim/message.c", ["  setmouse();", "  --no_wait_return;", "  msg_end_prompt();"], "readability/increment"]
["src/nvim/message.c", ["", "/*", " * Copy one character from \"*from\" to \"*to\", taking care of multi-byte"], "readability/old_style_comment"]
["src/nvim/message.c", ["  len += (int)(STRLEN(message)", "                + 2                          // for the NL's", "                + STRLEN(buttons)"], "whitespace/alignment"]
["src/nvim/message.c", ["                + 2                          // for the NL's", "                + STRLEN(buttons)", "                + 3);                        // for the \": \" and NUL"], "whitespace/alignment"]
["src/nvim/message.c", ["                + STRLEN(buttons)", "                + 3);                        // for the \": \" and NUL", "  lenhotkey++;                               // for the NUL"], "whitespace/alignment"]
["src/nvim/message.c", ["", "/*", " * Format the dialog string, and display it at the bottom of"], "readability/old_style_comment"]
["src/nvim/message.c", [" */", "static char_u *msg_show_console_dialog(char_u *message, char_u *buttons, int dfltbutton)", "  FUNC_ATTR_NONNULL_RET"], "whitespace/line_length"]
["src/nvim/message.c", ["{", "  bool has_hotkey[HAS_HOTKEY_LEN] = {false};", "  char_u *hotk = console_dialog_alloc(message, buttons, has_hotkey);"], "whitespace/braces"]
["src/nvim/message.c", ["{", "  bool has_hotkey[HAS_HOTKEY_LEN] = {false};", "  char_u *hotk = console_dialog_alloc(message, buttons, has_hotkey);"], "whitespace/braces"]
["src/nvim/message.c", ["///                   has a hotkey", "/// @param[out] hotkeys_ptr Pointer to the memory location where hotkeys will be copied", "static void copy_hotkeys_and_msg(const char_u *message, char_u *buttons,"], "whitespace/line_length"]
["src/nvim/message.c", ["static void copy_hotkeys_and_msg(const char_u *message, char_u *buttons,", "                                 int default_button_idx, const bool has_hotkey[],", "                                 char_u *hotkeys_ptr)"], "whitespace/line_length"]
["src/nvim/message.c", ["      if (*r == DLG_HOTKEY_CHAR) {", "        ++r;", "      }"], "readability/increment"]
["src/nvim/message.c", ["", "/*", " * Display the \":confirm\" message.  Also called when screen resized."], "readability/old_style_comment"]
["src/nvim/message.c", ["{", "  if (do_dialog(type,", "          title == NULL ? (char_u *)_(\"Question\") : title,"], "readability/braces"]
["src/nvim/message.c", ["  if (do_dialog(type,", "          title == NULL ? (char_u *)_(\"Question\") : title,", "          message,"], "whitespace/alignment"]
["src/nvim/message.c", ["          title == NULL ? (char_u *)_(\"Question\") : title,", "          message,", "          (char_u *)_(\"&Yes\\n&No\"), dflt, NULL, FALSE) == 1)"], "whitespace/alignment"]
["src/nvim/message.c", ["          message,", "          (char_u *)_(\"&Yes\\n&No\"), dflt, NULL, FALSE) == 1)", "    return VIM_YES;"], "whitespace/alignment"]
["src/nvim/message.c", ["          message,", "          (char_u *)_(\"&Yes\\n&No\"), dflt, NULL, FALSE) == 1)", "    return VIM_YES;"], "readability/bool"]
["src/nvim/message.c", ["  switch (do_dialog(type,", "              title == NULL ? (char_u *)_(\"Question\") : title,", "              message,"], "whitespace/alignment"]
["src/nvim/message.c", ["              title == NULL ? (char_u *)_(\"Question\") : title,", "              message,", "              (char_u *)_(\"&Yes\\n&No\\n&Cancel\"), dflt, NULL, FALSE)) {"], "whitespace/alignment"]
["src/nvim/message.c", ["              message,", "              (char_u *)_(\"&Yes\\n&No\\n&Cancel\"), dflt, NULL, FALSE)) {", "  case 1: return VIM_YES;"], "whitespace/alignment"]
["src/nvim/message.c", ["              message,", "              (char_u *)_(\"&Yes\\n&No\\n&Cancel\"), dflt, NULL, FALSE)) {", "  case 1: return VIM_YES;"], "readability/bool"]
["src/nvim/message.c", ["", "int vim_dialog_yesnoallcancel(int type, char_u *title, char_u *message, int dflt)", "{"], "whitespace/line_length"]
["src/nvim/message.c", ["  switch (do_dialog(type,", "              title == NULL ? (char_u *)\"Question\" : title,", "              message,"], "whitespace/alignment"]
["src/nvim/message.c", ["              title == NULL ? (char_u *)\"Question\" : title,", "              message,", "              (char_u *)_(\"&Yes\\n&No\\nSave &All\\n&Discard All\\n&Cancel\"),"], "whitespace/alignment"]
["src/nvim/message.c", ["              message,", "              (char_u *)_(\"&Yes\\n&No\\nSave &All\\n&Discard All\\n&Cancel\"),", "              dflt, NULL, FALSE)) {"], "whitespace/alignment"]
["src/nvim/message.c", ["              (char_u *)_(\"&Yes\\n&No\\nSave &All\\n&Discard All\\n&Cancel\"),", "              dflt, NULL, FALSE)) {", "  case 1: return VIM_YES;"], "whitespace/alignment"]
["src/nvim/message.c", ["              (char_u *)_(\"&Yes\\n&No\\nSave &All\\n&Discard All\\n&Cancel\"),", "              dflt, NULL, FALSE)) {", "  case 1: return VIM_YES;"], "readability/bool"]
