["src/nvim/undo.c", ["", "/*", " * undo.c: multi level undo facility"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/* Uncomment the next line for including the u_check() function.  This warns", " * for errors in the debug information. */"], "readability/old_style_comment"]
["src/nvim/undo.c", [" * for errors in the debug information. */", "/* #define U_DEBUG 1 */", "#define UH_MAGIC 0x18dade       /* value for uh_magic when in use */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["/* #define U_DEBUG 1 */", "#define UH_MAGIC 0x18dade       /* value for uh_magic when in use */", "#define UE_MAGIC 0xabc123       /* value for ue_magic when in use */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["#define UH_MAGIC 0x18dade       /* value for uh_magic when in use */", "#define UE_MAGIC 0xabc123       /* value for ue_magic when in use */", ""], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/* used in undo_end() to report number of added and deleted lines */", "static long u_newcount, u_oldcount;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * When 'u' flag included in 'cpoptions', we behave like vi.  Need to remember"], "readability/old_style_comment"]
["src/nvim/undo.c", ["#if defined(U_DEBUG)", "/*", " * Check the undo structures for being valid.  Print a warning when something"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    u_header_T *exp_uh_next,", "    u_header_T *exp_uh_alt_prev) {", "  u_entry_T *uep;"], "readability/braces"]
["src/nvim/undo.c", ["static void u_check_tree(u_header_T *uhp,", "    u_header_T *exp_uh_next,", "    u_header_T *exp_uh_alt_prev) {"], "whitespace/alignment"]
["src/nvim/undo.c", ["    u_header_T *exp_uh_next,", "    u_header_T *exp_uh_alt_prev) {", "  u_entry_T *uep;"], "whitespace/alignment"]
["src/nvim/undo.c", ["", "  if (uhp == NULL)", "    return;"], "readability/braces"]
["src/nvim/undo.c", ["    return;", "  ++header_count;", "  if (uhp == curbuf->b_u_curhead && ++seen_b_u_curhead > 1) {"], "readability/increment"]
["src/nvim/undo.c", ["", "  if (uhp->uh_magic != UH_MAGIC)", "    EMSG(\"uh_magic wrong (may be using freed memory)\");"], "readability/braces"]
["src/nvim/undo.c", ["    EMSG(\"uh_magic wrong (may be using freed memory)\");", "  else {", "    /* Check pointers back are correct. */"], "readability/braces"]
["src/nvim/undo.c", ["    EMSG(\"uh_magic wrong (may be using freed memory)\");", "  else {", "    /* Check pointers back are correct. */"], "readability/braces"]
["src/nvim/undo.c", ["  else {", "    /* Check pointers back are correct. */", "    if (uhp->uh_next.ptr != exp_uh_next) {"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      smsg(\"expected: 0x%x, actual: 0x%x\",", "          exp_uh_next, uhp->uh_next.ptr);", "    }"], "whitespace/alignment"]
["src/nvim/undo.c", ["      smsg(\"expected: 0x%x, actual: 0x%x\",", "          exp_uh_alt_prev, uhp->uh_alt_prev.ptr);", "    }"], "whitespace/alignment"]
["src/nvim/undo.c", ["", "    /* Check the undo tree at this header. */", "    for (uep = uhp->uh_entry; uep != NULL; uep = uep->ue_next) {"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "    /* Check the next alt tree. */", "    u_check_tree(uhp->uh_alt_next.ptr, uhp->uh_next.ptr, uhp);"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "    /* Check the next header in this branch. */", "    u_check_tree(uhp->uh_prev.ptr, uhp, NULL);"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "static void u_check(int newhead_may_be_NULL)                 {", "  seen_b_u_newhead = 0;"], "readability/braces"]
["src/nvim/undo.c", ["", "  if (seen_b_u_newhead == 0 && curbuf->b_u_oldhead != NULL", "      && !(newhead_may_be_NULL && curbuf->b_u_newhead == NULL))"], "readability/braces"]
["src/nvim/undo.c", ["    EMSGN(\"b_u_newhead invalid: 0x%x\", curbuf->b_u_newhead);", "  if (curbuf->b_u_curhead != NULL && seen_b_u_curhead == 0)", "    EMSGN(\"b_u_curhead invalid: 0x%x\", curbuf->b_u_curhead);"], "readability/braces"]
["src/nvim/undo.c", ["    smsg(\"expected: %\" PRId64 \", actual: %\" PRId64,", "        (int64_t)header_count, (int64_t)curbuf->b_u_numhead);", "  }"], "whitespace/alignment"]
["src/nvim/undo.c", ["", "/*", " * Save the current line for both the \"u\" and \"U\" command."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Save the lines between \"top\" and \"bot\" for both the \"u\" and \"U\" command."], "readability/old_style_comment"]
["src/nvim/undo.c", ["  if (top >= bot || bot > (curbuf->b_ml.ml_line_count + 1)) {", "    return FAIL;        /* rely on caller to do error messages */", "  }"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  if (top + 2 == bot)", "    u_saveline((linenr_T)(top + 1));"], "readability/braces"]
["src/nvim/undo.c", ["", "  return u_savecommon(top, bot, (linenr_T)0, FALSE);", "}"], "readability/bool"]
["src/nvim/undo.c", ["", "/*", " * Save the line \"lnum\" (used by \":s\" and \"~\" command)."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * A new line is inserted before line \"lnum\" (used by :s command)."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Save the lines \"lnum\" - \"lnum\" + nlines (used by delete command)."], "readability/old_style_comment"]
["src/nvim/undo.c", ["  return u_savecommon(lnum - 1, lnum + nlines,", "      nlines == curbuf->b_ml.ml_line_count ? 2 : lnum, FALSE);", "}"], "whitespace/alignment"]
["src/nvim/undo.c", ["  return u_savecommon(lnum - 1, lnum + nlines,", "      nlines == curbuf->b_ml.ml_line_count ? 2 : lnum, FALSE);", "}"], "readability/bool"]
["src/nvim/undo.c", ["{", "  /* Don't allow changes when 'modifiable' is off.  */", "  if (!MODIFIABLE(curbuf)) {"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /* Don't allow changes in the buffer while editing the cmdline.  The", "   * caller of getcmdline() may get confused. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Common code for various ways to save text before a change."], "readability/old_style_comment"]
["src/nvim/undo.c", ["  if (!reload) {", "    /* When making changes is not allowed return FAIL.  It's a crude way", "     * to make all change commands fail. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["     * to make all change commands fail. */", "    if (!undo_allowed())", "      return FAIL;"], "readability/braces"]
["src/nvim/undo.c", ["", "    /*", "     * Saving text for undo means we are going to make a change.  Give a"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    if (bot > curbuf->b_ml.ml_line_count + 1) {", "      /* This happens when the FileChangedRO autocommand changes the", "       * file in a way it becomes shorter. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "  u_check(FALSE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["", "  /*", "   * If curbuf->b_u_synced == true make a new header."], "readability/old_style_comment"]
["src/nvim/undo.c", ["  if (curbuf->b_u_synced) {", "    /* Need to create new entry in b_changelist. */", "    curbuf->b_new_change = true;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    if (get_undolevel() >= 0) {", "      /*", "       * Make a new header entry.  Do this first so that we don't mess"], "readability/old_style_comment"]
["src/nvim/undo.c", ["#endif", "    } else", "      uhp = NULL;"], "readability/braces"]
["src/nvim/undo.c", ["", "    /*", "     * If we undid more than we redid, move the entry lists before and"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "    /*", "     * free headers to keep the size right"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "      if (uhfree == old_curhead)", "        /* Can't reconnect the branch, delete all of it. */"], "readability/braces"]
["src/nvim/undo.c", ["      if (uhfree == old_curhead)", "        /* Can't reconnect the branch, delete all of it. */", "        u_freebranch(curbuf, uhfree, &old_curhead);"], "readability/old_style_comment"]
["src/nvim/undo.c", ["        u_freebranch(curbuf, uhfree, &old_curhead);", "      else if (uhfree->uh_alt_next.ptr == NULL)", "        /* There is no branch, only free one header. */"], "readability/braces"]
["src/nvim/undo.c", ["      else if (uhfree->uh_alt_next.ptr == NULL)", "        /* There is no branch, only free one header. */", "        u_freeheader(curbuf, uhfree, &old_curhead);"], "readability/old_style_comment"]
["src/nvim/undo.c", ["        u_freeheader(curbuf, uhfree, &old_curhead);", "      else {", "        /* Free the oldest alternate branch as a whole. */"], "readability/braces"]
["src/nvim/undo.c", ["        u_freeheader(curbuf, uhfree, &old_curhead);", "      else {", "        /* Free the oldest alternate branch as a whole. */"], "readability/braces"]
["src/nvim/undo.c", ["      else {", "        /* Free the oldest alternate branch as a whole. */", "        while (uhfree->uh_alt_next.ptr != NULL)"], "readability/old_style_comment"]
["src/nvim/undo.c", ["        /* Free the oldest alternate branch as a whole. */", "        while (uhfree->uh_alt_next.ptr != NULL)", "          uhfree = uhfree->uh_alt_next.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "      u_check(TRUE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["", "    if (uhp == NULL) {                  /* no undo at all */", "      if (old_curhead != NULL)"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    if (uhp == NULL) {                  /* no undo at all */", "      if (old_curhead != NULL)", "        u_freebranch(curbuf, old_curhead, NULL);"], "readability/braces"]
["src/nvim/undo.c", ["      uhp->uh_alt_prev.ptr = old_curhead->uh_alt_prev.ptr;", "      if (uhp->uh_alt_prev.ptr != NULL)", "        uhp->uh_alt_prev.ptr->uh_alt_next.ptr = uhp;"], "readability/braces"]
["src/nvim/undo.c", ["      old_curhead->uh_alt_prev.ptr = uhp;", "      if (curbuf->b_u_oldhead == old_curhead)", "        curbuf->b_u_oldhead = uhp;"], "readability/braces"]
["src/nvim/undo.c", ["        curbuf->b_u_oldhead = uhp;", "    } else", "      uhp->uh_alt_prev.ptr = NULL;"], "readability/braces"]
["src/nvim/undo.c", ["      uhp->uh_alt_prev.ptr = NULL;", "    if (curbuf->b_u_newhead != NULL)", "      curbuf->b_u_newhead->uh_prev.ptr = uhp;"], "readability/braces"]
["src/nvim/undo.c", ["    uhp->uh_getbot_entry = NULL;", "    uhp->uh_cursor = curwin->w_cursor;          /* save cursor pos. for undo */", "    if (virtual_active() && curwin->w_cursor.coladd > 0)"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    uhp->uh_cursor = curwin->w_cursor;          /* save cursor pos. for undo */", "    if (virtual_active() && curwin->w_cursor.coladd > 0)", "      uhp->uh_cursor_vcol = getviscol();"], "readability/braces"]
["src/nvim/undo.c", ["      uhp->uh_cursor_vcol = getviscol();", "    else", "      uhp->uh_cursor_vcol = -1;"], "readability/braces"]
["src/nvim/undo.c", ["", "    /* save changed and buffer empty flag for undo */", "    uhp->uh_flags = (curbuf->b_changed ? UH_CHANGED : 0) +"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "    /* save named marks and Visual marks for undo */", "    zero_fmark_additional_data(curbuf->b_namedm);"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    curbuf->b_u_newhead = uhp;", "    if (curbuf->b_u_oldhead == NULL)", "      curbuf->b_u_oldhead = uhp;"], "readability/braces"]
["src/nvim/undo.c", ["      curbuf->b_u_oldhead = uhp;", "    ++curbuf->b_u_numhead;", "  } else {"], "readability/increment"]
["src/nvim/undo.c", ["  } else {", "    if (get_undolevel() < 0)            /* no undo at all */", "      return OK;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  } else {", "    if (get_undolevel() < 0)            /* no undo at all */", "      return OK;"], "readability/braces"]
["src/nvim/undo.c", ["", "    /*", "     * When saving a single line, and it has been saved just before, it"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      prev_uep = NULL;", "      for (i = 0; i < 10; ++i) {", "        if (uep == NULL)"], "readability/increment"]
["src/nvim/undo.c", ["      for (i = 0; i < 10; ++i) {", "        if (uep == NULL)", "          break;"], "readability/braces"]
["src/nvim/undo.c", ["", "        /* If lines have been inserted/deleted we give up.", "         * Also when the line was included in a multi-line save. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["         * Also when the line was included in a multi-line save. */", "        if ((curbuf->b_u_newhead->uh_getbot_entry != uep", "             ? (uep->ue_top + uep->ue_size + 1"], "readability/braces"]
["src/nvim/undo.c", ["", "        /* If it's the same line we can skip saving it again. */", "        if (uep->ue_size == 1 && uep->ue_top == top) {"], "readability/old_style_comment"]
["src/nvim/undo.c", ["          if (i > 0) {", "            /* It's not the last entry: get ue_bot for the last", "             * entry now.  Following deleted/inserted lines go to"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "            /* Move the found entry to become the last entry.  The", "             * order of undo/redo doesn't matter for the entries"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "          /* The executed command may change the line count. */", "          if (newbot != 0)"], "readability/old_style_comment"]
["src/nvim/undo.c", ["          /* The executed command may change the line count. */", "          if (newbot != 0)", "            uep->ue_bot = newbot;"], "readability/braces"]
["src/nvim/undo.c", ["            uep->ue_bot = newbot;", "          else if (bot > curbuf->b_ml.ml_line_count)", "            uep->ue_bot = 0;"], "readability/braces"]
["src/nvim/undo.c", ["            uep->ue_bot = 0;", "          else {", "            uep->ue_lcount = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/undo.c", ["            uep->ue_bot = 0;", "          else {", "            uep->ue_lcount = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/undo.c", ["", "    /* find line number for ue_bot for previous u_save() */", "    u_getbot();"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /*", "   * add lines in front of entry list"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  uep->ue_top = top;", "  if (newbot != 0)", "    uep->ue_bot = newbot;"], "readability/braces"]
["src/nvim/undo.c", ["    uep->ue_bot = newbot;", "  /*", "   * Use 0 for ue_bot if bot is below last line."], "readability/old_style_comment"]
["src/nvim/undo.c", ["   */", "  else if (bot > curbuf->b_ml.ml_line_count)", "    uep->ue_bot = 0;"], "readability/braces"]
["src/nvim/undo.c", ["    uep->ue_bot = 0;", "  else {", "    uep->ue_lcount = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/undo.c", ["    uep->ue_bot = 0;", "  else {", "    uep->ue_lcount = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/undo.c", ["    uep->ue_array = xmalloc(sizeof(char_u *) * (size_t)size);", "    for (i = 0, lnum = top + 1; i < size; ++i) {", "      fast_breakcheck();"], "readability/increment"]
["src/nvim/undo.c", ["    }", "  } else", "    uep->ue_array = NULL;"], "readability/braces"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "  u_check(FALSE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["", "/* extra fields for header */", "# define UF_LAST_SAVE_NR        1"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/* extra fields for uhp */", "# define UHP_SAVE_NR            1"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Compute the hash for the current buffer text into hash[UNDO_HASH_SIZE]."], "readability/old_style_comment"]
["src/nvim/undo.c", ["  sha256_start(&ctx);", "  for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum) {", "    p = ml_get(lnum);"], "readability/increment"]
["src/nvim/undo.c", ["  // When not reading use the first directory that exists or \".\".", "  dirp = (char *) p_udir;", "  while (*dirp != NUL) {"], "whitespace/cast"]
["src/nvim/undo.c", ["      memmove(undo_file_name, ffname, ffname_len + 1);", "      char *const tail = (char *) path_tail((char_u *) undo_file_name);", "      const size_t tail_len = strlen(tail);"], "whitespace/cast"]
["src/nvim/undo.c", ["  if (name == NULL) {", "    file_name = u_get_undo_file_name((char *) buf->b_ffname, false);", "    if (file_name == NULL) {"], "whitespace/cast"]
["src/nvim/undo.c", ["  } else {", "    file_name = (char *) name;", "  }"], "whitespace/cast"]
["src/nvim/undo.c", ["", "  /*", "   * Decide about the permission to use for the undo file.  If the buffer"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /* If the undo file already exists, verify that it actually is an undo", "   * file, and delete it. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    if (name == NULL || !forceit) {", "      /* Check we can read it and it's an undo file. */", "      fd = os_open(file_name, O_RDONLY, 0);"], "readability/old_style_comment"]
["src/nvim/undo.c", ["        if (name != NULL || p_verbose > 0) {", "          if (name == NULL)", "            verbose_enter();"], "readability/braces"]
["src/nvim/undo.c", ["               file_name);", "          if (name == NULL)", "            verbose_leave();"], "readability/braces"]
["src/nvim/undo.c", ["          if (name != NULL || p_verbose > 0) {", "            if (name == NULL)", "              verbose_enter();"], "readability/braces"]
["src/nvim/undo.c", ["                 file_name);", "            if (name == NULL)", "              verbose_leave();"], "readability/braces"]
["src/nvim/undo.c", ["", "  /* If there is no undo information at all, quit here after deleting any", "   * existing undo file. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "  /* Check there is no problem in undo info before writing. */", "  u_check(FALSE);"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  /* Check there is no problem in undo info before writing. */", "  u_check(FALSE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["#ifdef UNIX", "  /*", "   * Try to set the group of the undo file same as the original file. If"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /* Undo must be synced. */", "  u_sync(TRUE);"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  /* Undo must be synced. */", "  u_sync(TRUE);", ""], "readability/bool"]
["src/nvim/undo.c", ["", "  /*", "   * Write the header."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /*", "   * Iteratively serialize UHPs and their UEPs from the top down."], "readability/old_style_comment"]
["src/nvim/undo.c", ["  while (uhp != NULL) {", "    /* Serialize current UHP if we haven't seen it */", "    if (uhp->uh_walk != mark) {"], "readability/old_style_comment"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "      ++headers_written;", "#endif"], "readability/increment"]
["src/nvim/undo.c", ["", "    /* Now walk through the tree - algorithm from undo_time(). */", "    if (uhp->uh_prev.ptr != NULL && uhp->uh_prev.ptr->uh_walk != mark)"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    /* Now walk through the tree - algorithm from undo_time(). */", "    if (uhp->uh_prev.ptr != NULL && uhp->uh_prev.ptr->uh_walk != mark)", "      uhp = uhp->uh_prev.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["      uhp = uhp->uh_prev.ptr;", "    else if (uhp->uh_alt_next.ptr != NULL", "             && uhp->uh_alt_next.ptr->uh_walk != mark)"], "readability/braces"]
["src/nvim/undo.c", ["      uhp = uhp->uh_alt_next.ptr;", "    else if (uhp->uh_next.ptr != NULL && uhp->uh_alt_prev.ptr == NULL", "             && uhp->uh_next.ptr->uh_walk != mark)"], "readability/braces"]
["src/nvim/undo.c", ["      uhp = uhp->uh_next.ptr;", "    else if (uhp->uh_alt_prev.ptr != NULL)", "      uhp = uhp->uh_alt_prev.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["      uhp = uhp->uh_alt_prev.ptr;", "    else", "      uhp = uhp->uh_next.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["  fclose(fp);", "  if (!write_ok)", "    EMSG2(_(\"E829: write error in undo file: %s\"), file_name);"], "readability/braces"]
["src/nvim/undo.c", ["", "    /* For systems that support ACL: get the ACL from the original file. */", "    acl = mch_get_acl(buf->b_ffname);"], "readability/old_style_comment"]
["src/nvim/undo.c", ["theend:", "  if (file_name != name)", "    xfree(file_name);"], "readability/braces"]
["src/nvim/undo.c", ["  if (name == NULL) {", "    file_name = u_get_undo_file_name((char *) curbuf->b_ffname, true);", "    if (file_name == NULL) {"], "whitespace/cast"]
["src/nvim/undo.c", ["  } else {", "    file_name = (char *) name;", "  }"], "whitespace/cast"]
["src/nvim/undo.c", ["      give_warning((char_u *)", "          _(\"File contents changed, cannot use undo info\"), true);", "      if (name == NULL) {"], "whitespace/alignment"]
["src/nvim/undo.c", ["  memset(uhp_table_used, 0, amount);", "# define SET_FLAG(j) ++ uhp_table_used[j]", "#else"], "whitespace/operators"]
["src/nvim/undo.c", ["  // a pointer corresponding to the header with that sequence number.", "  short old_idx = -1, new_idx = -1, cur_idx = -1;", "  for (int i = 0; i < num_head; i++) {"], "runtime/int"]
["src/nvim/undo.c", ["      assert(i <= SHRT_MAX);", "      old_idx = (short)i;", "      SET_FLAG(i);"], "runtime/int"]
["src/nvim/undo.c", ["      assert(i <= SHRT_MAX);", "      new_idx = (short)i;", "      SET_FLAG(i);"], "runtime/int"]
["src/nvim/undo.c", ["      assert(i <= SHRT_MAX);", "      cur_idx = (short)i;", "      SET_FLAG(i);"], "runtime/int"]
["src/nvim/undo.c", ["  xfree(uhp_table_used);", "  u_check(TRUE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["  if (uhp_table != NULL) {", "    for (long i = 0; i < num_read_uhps; i++)", "      if (uhp_table[i] != NULL) {"], "readability/braces"]
["src/nvim/undo.c", ["", "/*", " * If 'cpoptions' contains 'u': Undo the previous undo or redo (vi compatible)."], "readability/old_style_comment"]
["src/nvim/undo.c", ["{", "  /*", "   * If we get an undo command while executing a macro, we behave like the"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  if (curbuf->b_u_synced == false) {", "    u_sync(TRUE);", "    count = 1;"], "readability/bool"]
["src/nvim/undo.c", ["", "/*", " * If 'cpoptions' contains 'u': Repeat the previous undo or redo."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  if (!undo_allowed())", "    return;"], "readability/braces"]
["src/nvim/undo.c", ["  u_oldcount = 0;", "  if (curbuf->b_ml.ml_flags & ML_EMPTY)", "    u_oldcount = -1;"], "readability/braces"]
["src/nvim/undo.c", ["  while (count--) {", "    /* Do the change warning now, so that it triggers FileChangedRO when", "     * needed.  This may cause the file to be reloaded, that must happen"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    if (undo_undoes) {", "      if (curbuf->b_u_curhead == NULL)                  /* first undo */", "        curbuf->b_u_curhead = curbuf->b_u_newhead;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    if (undo_undoes) {", "      if (curbuf->b_u_curhead == NULL)                  /* first undo */", "        curbuf->b_u_curhead = curbuf->b_u_newhead;"], "readability/braces"]
["src/nvim/undo.c", ["        curbuf->b_u_curhead = curbuf->b_u_newhead;", "      else if (get_undolevel() > 0)                     /* multi level undo */", "        /* get next undo */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["        curbuf->b_u_curhead = curbuf->b_u_newhead;", "      else if (get_undolevel() > 0)                     /* multi level undo */", "        /* get next undo */"], "readability/braces"]
["src/nvim/undo.c", ["      else if (get_undolevel() > 0)                     /* multi level undo */", "        /* get next undo */", "        curbuf->b_u_curhead = curbuf->b_u_curhead->uh_next.ptr;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["        curbuf->b_u_curhead = curbuf->b_u_curhead->uh_next.ptr;", "      /* nothing to undo */", "      if (curbuf->b_u_numhead == 0 || curbuf->b_u_curhead == NULL) {"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      if (curbuf->b_u_numhead == 0 || curbuf->b_u_curhead == NULL) {", "        /* stick curbuf->b_u_curhead at end */", "        curbuf->b_u_curhead = curbuf->b_u_oldhead;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      if (curbuf->b_u_curhead == NULL || get_undolevel() <= 0) {", "        beep_flush();           /* nothing to redo */", "        if (count == startcount - 1) {"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "      /* Advance for next redo.  Set \"newhead\" when at the end of the", "       * redoable changes. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["       * redoable changes. */", "      if (curbuf->b_u_curhead->uh_prev.ptr == NULL)", "        curbuf->b_u_newhead = curbuf->b_u_curhead;"], "readability/braces"]
["src/nvim/undo.c", ["", "  /* First make sure the current undoable change is synced. */", "  if (curbuf->b_u_synced == false)"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  /* First make sure the current undoable change is synced. */", "  if (curbuf->b_u_synced == false)", "    u_sync(TRUE);"], "readability/braces"]
["src/nvim/undo.c", ["  if (curbuf->b_u_synced == false)", "    u_sync(TRUE);", ""], "readability/bool"]
["src/nvim/undo.c", ["  u_oldcount = 0;", "  if (curbuf->b_ml.ml_flags & ML_EMPTY)", "    u_oldcount = -1;"], "readability/braces"]
["src/nvim/undo.c", ["", "  /* \"target\" is the node below which we want to be.", "   * Init \"closest\" to a value we can't reach. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      if (step < 0) {", "        /* Going back to a previous write. If there were changes after", "         * the last write, count that as moving one file-write, so"], "readability/old_style_comment"]
["src/nvim/undo.c", ["        uhp = curbuf->b_u_curhead;", "        if (uhp != NULL)", "          uhp = uhp->uh_next.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["          uhp = uhp->uh_next.ptr;", "        else", "          uhp = curbuf->b_u_newhead;"], "readability/braces"]
["src/nvim/undo.c", ["          uhp = curbuf->b_u_newhead;", "        if (uhp != NULL && uhp->uh_save_nr != 0)", "          /* \"uh_save_nr\" was set in the last block, that means"], "readability/braces"]
["src/nvim/undo.c", ["        if (uhp != NULL && uhp->uh_save_nr != 0)", "          /* \"uh_save_nr\" was set in the last block, that means", "           * there were no changes since the last write */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["          target = curbuf->b_u_save_nr_cur + step;", "        else", "          /* count the changes since the last write as one step */"], "readability/braces"]
["src/nvim/undo.c", ["        else", "          /* count the changes since the last write as one step */", "          target = curbuf->b_u_save_nr_cur + step + 1;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["          target = curbuf->b_u_save_nr_cur + step + 1;", "        if (target <= 0)", "          /* Go to before first write: before the oldest change. Use"], "readability/braces"]
["src/nvim/undo.c", ["        if (target <= 0)", "          /* Go to before first write: before the oldest change. Use", "           * the sequence number for that. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      } else {", "        /* Moving forward to a newer write. */", "        target = curbuf->b_u_save_nr_cur + step;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["        if (target > curbuf->b_u_save_nr_last) {", "          /* Go to after last write: after the latest change. Use", "           * the sequence number for that. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      }", "    } else", "      target = curbuf->b_u_seq_cur + step;"], "readability/braces"]
["src/nvim/undo.c", ["    if (step < 0) {", "      if (target < 0)", "        target = 0;"], "readability/braces"]
["src/nvim/undo.c", ["", "  /*", "   * May do this twice:"], "readability/old_style_comment"]
["src/nvim/undo.c", ["   */", "  for (round = 1; round <= 2; ++round) {", "    /* Find the path from the current state to where we want to go.  The"], "readability/increment"]
["src/nvim/undo.c", ["  for (round = 1; round <= 2; ++round) {", "    /* Find the path from the current state to where we want to go.  The", "     * desired state can be anywhere in the undo tree, need to go all over"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "    if (curbuf->b_u_curhead == NULL)            /* at leaf of the tree */", "      uhp = curbuf->b_u_newhead;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "    if (curbuf->b_u_curhead == NULL)            /* at leaf of the tree */", "      uhp = curbuf->b_u_newhead;"], "readability/braces"]
["src/nvim/undo.c", ["      uhp = curbuf->b_u_newhead;", "    else", "      uhp = curbuf->b_u_curhead;"], "readability/braces"]
["src/nvim/undo.c", ["      if (round == 1 && !(dofile && val == 0)) {", "        /* Remember the header that is closest to the target.", "         * It must be at least in the right direction (checked with"], "readability/old_style_comment"]
["src/nvim/undo.c", ["                   ? uhp->uh_seq < closest_seq", "                                   : uhp->uh_seq > closest_seq)", "                : closest == closest_start"], "whitespace/alignment"]
["src/nvim/undo.c", ["                   ? uhp->uh_seq < closest_seq", "                                   : uhp->uh_seq > closest_seq)", "                : closest == closest_start"], "whitespace/alignment"]
["src/nvim/undo.c", ["                   ? uhp->uh_seq < closest_seq", "                                   : uhp->uh_seq > closest_seq)", "                : closest == closest_start"], "whitespace/alignment"]
["src/nvim/undo.c", ["", "      /* Quit searching when we found a match.  But when searching for a", "       * time we need to continue looking for the best uh_seq. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "      /* go down in the tree if we haven't been there */", "      if (uhp->uh_prev.ptr != NULL && uhp->uh_prev.ptr->uh_walk != nomark"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      /* go down in the tree if we haven't been there */", "      if (uhp->uh_prev.ptr != NULL && uhp->uh_prev.ptr->uh_walk != nomark", "          && uhp->uh_prev.ptr->uh_walk != mark)"], "readability/braces"]
["src/nvim/undo.c", ["", "      /* go to alternate branch if we haven't been there */", "      else if (uhp->uh_alt_next.ptr != NULL"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      /* go to alternate branch if we haven't been there */", "      else if (uhp->uh_alt_next.ptr != NULL", "               && uhp->uh_alt_next.ptr->uh_walk != nomark"], "readability/braces"]
["src/nvim/undo.c", ["", "      /* go up in the tree if we haven't been there and we are at the", "       * start of alternate branches */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["       * start of alternate branches */", "      else if (uhp->uh_next.ptr != NULL && uhp->uh_alt_prev.ptr == NULL", "               && uhp->uh_next.ptr->uh_walk != nomark"], "readability/braces"]
["src/nvim/undo.c", ["               && uhp->uh_next.ptr->uh_walk != mark) {", "        /* If still at the start we don't go through this change. */", "        if (uhp == curbuf->b_u_curhead)"], "readability/old_style_comment"]
["src/nvim/undo.c", ["        /* If still at the start we don't go through this change. */", "        if (uhp == curbuf->b_u_curhead)", "          uhp->uh_walk = nomark;"], "readability/braces"]
["src/nvim/undo.c", ["      } else {", "        /* need to backtrack; mark this node as useless */", "        uhp->uh_walk = nomark;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["        uhp->uh_walk = nomark;", "        if (uhp->uh_alt_prev.ptr != NULL)", "          uhp = uhp->uh_alt_prev.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["          uhp = uhp->uh_alt_prev.ptr;", "        else", "          uhp = uhp->uh_next.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["", "    if (uhp != NULL)        /* found it */", "      break;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "    if (uhp != NULL)        /* found it */", "      break;"], "readability/braces"]
["src/nvim/undo.c", ["    if (closest == closest_start) {", "      if (step < 0)", "        MSG(_(\"Already at oldest change\"));"], "readability/braces"]
["src/nvim/undo.c", ["        MSG(_(\"Already at oldest change\"));", "      else", "        MSG(_(\"Already at newest change\"));"], "readability/braces"]
["src/nvim/undo.c", ["    while (!got_int) {", "      /* Do the change warning now, for the same reason as above. */", "      change_warning(0);"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      uhp = curbuf->b_u_curhead;", "      if (uhp == NULL)", "        uhp = curbuf->b_u_newhead;"], "readability/braces"]
["src/nvim/undo.c", ["        uhp = curbuf->b_u_newhead;", "      else", "        uhp = uhp->uh_next.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["", "  /* Don't want autocommands using the undo structures here, they are", "   * invalid till the end. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "  u_check(FALSE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["", "  /*", "   * save marks before undo/redo"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    bot = uep->ue_bot;", "    if (bot == 0)", "      bot = curbuf->b_ml.ml_line_count + 1;"], "readability/braces"]
["src/nvim/undo.c", ["", "    oldsize = bot - top - 1;        /* number of lines before undo */", "    newsize = uep->ue_size;         /* number of lines after undo */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    oldsize = bot - top - 1;        /* number of lines before undo */", "    newsize = uep->ue_size;         /* number of lines after undo */", ""], "readability/old_style_comment"]
["src/nvim/undo.c", ["    if (top < newlnum) {", "      /* If the saved cursor is somewhere in this undo block, move it to", "       * the remembered position.  Makes \"gwap\" put the cursor back"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      } else {", "        /* Use the first line that actually changed.  Avoids that", "         * undoing auto-formatting puts the cursor in the previous"], "readability/old_style_comment"]
["src/nvim/undo.c", ["         * line. */", "        for (i = 0; i < newsize && i < oldsize; ++i)", "          if (STRCMP(uep->ue_array[i], ml_get(top + 1 + i)) != 0)"], "readability/braces"]
["src/nvim/undo.c", ["         * line. */", "        for (i = 0; i < newsize && i < oldsize; ++i)", "          if (STRCMP(uep->ue_array[i], ml_get(top + 1 + i)) != 0)"], "readability/increment"]
["src/nvim/undo.c", ["        for (i = 0; i < newsize && i < oldsize; ++i)", "          if (STRCMP(uep->ue_array[i], ml_get(top + 1 + i)) != 0)", "            break;"], "readability/braces"]
["src/nvim/undo.c", ["", "    /* delete the lines between top and bot and save them in newarray */", "    if (oldsize > 0) {"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      newarray = xmalloc(sizeof(char_u *) * (size_t)oldsize);", "      /* delete backwards, it goes faster in most cases */", "      for (lnum = bot - 1, i = oldsize; --i >= 0; --lnum) {"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      for (lnum = bot - 1, i = oldsize; --i >= 0; --lnum) {", "        /* what can we do when we run out of memory? */", "        newarray[i] = u_save_line(lnum);"], "readability/old_style_comment"]
["src/nvim/undo.c", ["        newarray[i] = u_save_line(lnum);", "        /* remember we deleted the last line in the buffer, and a", "         * dummy empty line will be inserted */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      }", "    } else", "      newarray = NULL;"], "readability/braces"]
["src/nvim/undo.c", ["", "    /* insert the lines in u_array between top and bot */", "    if (newsize) {"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    if (newsize) {", "      for (lnum = top, i = 0; i < newsize; ++i, ++lnum) {", "        /*"], "readability/increment"]
["src/nvim/undo.c", ["      for (lnum = top, i = 0; i < newsize; ++i, ++lnum) {", "        /*", "         * If the file is empty, there is an empty line 1 that we"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "    /* set '[ and '] mark */", "    if (top + 1 < curbuf->b_op_start.lnum)"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    /* set '[ and '] mark */", "    if (top + 1 < curbuf->b_op_start.lnum)", "      curbuf->b_op_start.lnum = top + 1;"], "readability/braces"]
["src/nvim/undo.c", ["      curbuf->b_op_start.lnum = top + 1;", "    if (newsize == 0 && top + 1 > curbuf->b_op_end.lnum)", "      curbuf->b_op_end.lnum = top + 1;"], "readability/braces"]
["src/nvim/undo.c", ["      curbuf->b_op_end.lnum = top + 1;", "    else if (top + newsize > curbuf->b_op_end.lnum)", "      curbuf->b_op_end.lnum = top + newsize;"], "readability/braces"]
["src/nvim/undo.c", ["", "    /*", "     * insert this entry in front of the new entry list"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /*", "   * restore marks from before undo/redo"], "readability/old_style_comment"]
["src/nvim/undo.c", ["   */", "  for (i = 0; i < NMARKS; ++i) {", "    if (curhead->uh_namedm[i].mark.lnum != 0) {"], "readability/increment"]
["src/nvim/undo.c", ["", "  /*", "   * If the cursor is only off by one line, put it at the same position as"], "readability/old_style_comment"]
["src/nvim/undo.c", ["   */", "  if (curhead->uh_cursor.lnum + 1 == curwin->w_cursor.lnum", "      && curwin->w_cursor.lnum > 1)"], "readability/braces"]
["src/nvim/undo.c", ["      && curwin->w_cursor.lnum > 1)", "    --curwin->w_cursor.lnum;", "  if (curwin->w_cursor.lnum <= curbuf->b_ml.ml_line_count) {"], "readability/increment"]
["src/nvim/undo.c", ["      curwin->w_cursor.col = curhead->uh_cursor.col;", "      if (virtual_active() && curhead->uh_cursor_vcol >= 0)", "        coladvance((colnr_T)curhead->uh_cursor_vcol);"], "readability/braces"]
["src/nvim/undo.c", ["        coladvance((colnr_T)curhead->uh_cursor_vcol);", "      else", "        curwin->w_cursor.coladd = 0;"], "readability/braces"]
["src/nvim/undo.c", ["        curwin->w_cursor.coladd = 0;", "    } else", "      beginline(BL_SOL | BL_FIX);"], "readability/braces"]
["src/nvim/undo.c", ["  } else {", "    /* We get here with the current cursor line being past the end (eg", "     * after adding lines at the end of the file, and then undoing it)."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /* Make sure the cursor is on an existing line and column. */", "  check_cursor();"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /* Remember where we are for \"g-\" and \":earlier 10s\". */", "  curbuf->b_u_seq_cur = curhead->uh_seq;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  curbuf->b_u_seq_cur = curhead->uh_seq;", "  if (undo)", "    /* We are below the previous undo.  However, to make \":earlier 1s\""], "readability/braces"]
["src/nvim/undo.c", ["  if (undo)", "    /* We are below the previous undo.  However, to make \":earlier 1s\"", "     * work we compute this as being just above the just undone change. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /* Remember where we are for \":earlier 1f\" and \":later 1f\". */", "  if (curhead->uh_save_nr != 0) {"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  if (curhead->uh_save_nr != 0) {", "    if (undo)", "      curbuf->b_u_save_nr_cur = curhead->uh_save_nr - 1;"], "readability/braces"]
["src/nvim/undo.c", ["      curbuf->b_u_save_nr_cur = curhead->uh_save_nr - 1;", "    else", "      curbuf->b_u_save_nr_cur = curhead->uh_save_nr;"], "readability/braces"]
["src/nvim/undo.c", ["", "  /* The timestamp can be the same for multiple changes, just use the one of", "   * the undone/redone change. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "  u_check(FALSE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["", "  if ((fdo_flags & FDO_UNDO) && KeyTyped)", "    foldOpenCursor();"], "readability/braces"]
["src/nvim/undo.c", ["", "  if (curbuf->b_ml.ml_flags & ML_EMPTY)", "    --u_newcount;"], "readability/braces"]
["src/nvim/undo.c", ["  if (curbuf->b_ml.ml_flags & ML_EMPTY)", "    --u_newcount;", ""], "readability/increment"]
["src/nvim/undo.c", ["  u_oldcount -= u_newcount;", "  if (u_oldcount == -1)", "    msgstr = N_(\"more line\");"], "readability/braces"]
["src/nvim/undo.c", ["    msgstr = N_(\"more line\");", "  else if (u_oldcount < 0)", "    msgstr = N_(\"more lines\");"], "readability/braces"]
["src/nvim/undo.c", ["    msgstr = N_(\"more lines\");", "  else if (u_oldcount == 1)", "    msgstr = N_(\"line less\");"], "readability/braces"]
["src/nvim/undo.c", ["    msgstr = N_(\"line less\");", "  else if (u_oldcount > 1)", "    msgstr = N_(\"fewer lines\");"], "readability/braces"]
["src/nvim/undo.c", ["    msgstr = N_(\"fewer lines\");", "  else {", "    u_oldcount = u_newcount;"], "readability/braces"]
["src/nvim/undo.c", ["    msgstr = N_(\"fewer lines\");", "  else {", "    u_oldcount = u_newcount;"], "readability/braces"]
["src/nvim/undo.c", ["    u_oldcount = u_newcount;", "    if (u_newcount == 1)", "      msgstr = N_(\"change\");"], "readability/braces"]
["src/nvim/undo.c", ["      msgstr = N_(\"change\");", "    else", "      msgstr = N_(\"changes\");"], "readability/braces"]
["src/nvim/undo.c", ["  if (curbuf->b_u_curhead != NULL) {", "    /* For \":undo N\" we prefer a \"after #N\" message. */", "    if (absolute && curbuf->b_u_curhead->uh_next.ptr != NULL) {"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * u_sync: stop adding to the current entry list"], "readability/old_style_comment"]
["src/nvim/undo.c", ["{", "  /* Skip it when already synced or syncing is disabled. */", "  if (curbuf->b_u_synced || (!force && no_u_sync > 0))"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  /* Skip it when already synced or syncing is disabled. */", "  if (curbuf->b_u_synced || (!force && no_u_sync > 0))", "    return;"], "readability/braces"]
["src/nvim/undo.c", ["    return;", "  if (get_undolevel() < 0)", "    curbuf->b_u_synced = true;      /* no entries, nothing to do */"], "readability/braces"]
["src/nvim/undo.c", ["  if (get_undolevel() < 0)", "    curbuf->b_u_synced = true;      /* no entries, nothing to do */", "  else {"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    curbuf->b_u_synced = true;      /* no entries, nothing to do */", "  else {", "    u_getbot();                     /* compute ue_bot of previous u_save */"], "readability/braces"]
["src/nvim/undo.c", ["    curbuf->b_u_synced = true;      /* no entries, nothing to do */", "  else {", "    u_getbot();                     /* compute ue_bot of previous u_save */"], "readability/braces"]
["src/nvim/undo.c", ["  else {", "    u_getbot();                     /* compute ue_bot of previous u_save */", "    curbuf->b_u_curhead = NULL;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * \":undolist\": List the leafs of the undo tree"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /*", "   * 1: walk the tree to find all leafs, put the info in \"ga\"."], "readability/old_style_comment"]
["src/nvim/undo.c", ["      if (uhp->uh_save_nr > 0) {", "        while (STRLEN(IObuff) < 33)", "          STRCAT(IObuff, \" \");"], "readability/braces"]
["src/nvim/undo.c", ["        vim_snprintf_add((char *)IObuff, IOSIZE,", "            \"  %3ld\", uhp->uh_save_nr);", "      }"], "whitespace/alignment"]
["src/nvim/undo.c", ["", "    /* go down in the tree if we haven't been there */", "    if (uhp->uh_prev.ptr != NULL && uhp->uh_prev.ptr->uh_walk != nomark"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      uhp = uhp->uh_prev.ptr;", "      ++changes;", "    }"], "readability/increment"]
["src/nvim/undo.c", ["    }", "    /* go to alternate branch if we haven't been there */", "    else if (uhp->uh_alt_next.ptr != NULL"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    /* go to alternate branch if we haven't been there */", "    else if (uhp->uh_alt_next.ptr != NULL", "             && uhp->uh_alt_next.ptr->uh_walk != nomark"], "whitespace/newline"]
["src/nvim/undo.c", ["", "    /* go up in the tree if we haven't been there and we are at the", "     * start of alternate branches */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["     * start of alternate branches */", "    else if (uhp->uh_next.ptr != NULL && uhp->uh_alt_prev.ptr == NULL", "             && uhp->uh_next.ptr->uh_walk != nomark"], "readability/braces"]
["src/nvim/undo.c", ["      uhp = uhp->uh_next.ptr;", "      --changes;", "    } else {"], "readability/increment"]
["src/nvim/undo.c", ["    } else {", "      /* need to backtrack; mark this node as done */", "      uhp->uh_walk = nomark;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      uhp->uh_walk = nomark;", "      if (uhp->uh_alt_prev.ptr != NULL)", "        uhp = uhp->uh_alt_prev.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["        uhp = uhp->uh_alt_prev.ptr;", "      else {", "        uhp = uhp->uh_next.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["        uhp = uhp->uh_alt_prev.ptr;", "      else {", "        uhp = uhp->uh_next.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["        uhp = uhp->uh_next.ptr;", "        --changes;", "      }"], "readability/increment"]
["src/nvim/undo.c", ["", "  if (GA_EMPTY(&ga))", "    MSG(_(\"Nothing to undo\"));"], "readability/braces"]
["src/nvim/undo.c", ["    MSG(_(\"Nothing to undo\"));", "  else {", "    sort_strings((char_u **)ga.ga_data, ga.ga_len);"], "readability/braces"]
["src/nvim/undo.c", ["    MSG(_(\"Nothing to undo\"));", "  else {", "    sort_strings((char_u **)ga.ga_data, ga.ga_len);"], "readability/braces"]
["src/nvim/undo.c", ["", "/*", " * \":undojoin\": continue adding to the last entry list"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Called after writing or reloading the file and setting b_changed to FALSE."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * After reloading a buffer which was saved for 'undoreload': Find the first"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  if (curbuf->b_u_curhead != NULL || uhp == NULL)", "    return;      /* undid something in an autocmd? */"], "readability/braces"]
["src/nvim/undo.c", ["  if (curbuf->b_u_curhead != NULL || uhp == NULL)", "    return;      /* undid something in an autocmd? */", ""], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /* Check that the last undo block was for the whole file. */", "  uep = uhp->uh_entry;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  uep = uhp->uh_entry;", "  if (uep->ue_top != 0 || uep->ue_bot != 0)", "    return;"], "readability/braces"]
["src/nvim/undo.c", ["", "  for (lnum = 1; lnum < curbuf->b_ml.ml_line_count", "       && lnum <= uep->ue_size; ++lnum)"], "readability/braces"]
["src/nvim/undo.c", ["  for (lnum = 1; lnum < curbuf->b_ml.ml_line_count", "       && lnum <= uep->ue_size; ++lnum)", "    if (STRCMP(ml_get_buf(curbuf, lnum, FALSE),"], "readability/increment"]
["src/nvim/undo.c", ["    if (STRCMP(ml_get_buf(curbuf, lnum, FALSE),", "            uep->ue_array[lnum - 1]) != 0) {", "      clearpos(&(uhp->uh_cursor));"], "whitespace/alignment"]
["src/nvim/undo.c", ["       && lnum <= uep->ue_size; ++lnum)", "    if (STRCMP(ml_get_buf(curbuf, lnum, FALSE),", "            uep->ue_array[lnum - 1]) != 0) {"], "readability/bool"]
["src/nvim/undo.c", ["  if (curbuf->b_ml.ml_line_count != uep->ue_size) {", "    /* lines added or deleted at the end, put the cursor there */", "    clearpos(&(uhp->uh_cursor));"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Increase the write count, store it in the last undo header, what would be"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  ++buf->b_u_save_nr_last;", "  buf->b_u_save_nr_cur = buf->b_u_save_nr_last;"], "readability/increment"]
["src/nvim/undo.c", ["  uhp = buf->b_u_curhead;", "  if (uhp != NULL)", "    uhp = uhp->uh_next.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["    uhp = uhp->uh_next.ptr;", "  else", "    uhp = buf->b_u_newhead;"], "readability/braces"]
["src/nvim/undo.c", ["    uhp = buf->b_u_newhead;", "  if (uhp != NULL)", "    uhp->uh_save_nr = buf->b_u_save_nr_last;"], "readability/braces"]
["src/nvim/undo.c", ["    uh->uh_flags |= UH_CHANGED;", "    if (uh->uh_alt_next.ptr != NULL)", "      u_unch_branch(uh->uh_alt_next.ptr);           /* recursive */"], "readability/braces"]
["src/nvim/undo.c", ["    if (uh->uh_alt_next.ptr != NULL)", "      u_unch_branch(uh->uh_alt_next.ptr);           /* recursive */", "  }"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Get pointer to last added entry."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * u_getbot(): compute the line number of the previous u_save"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  uep = u_get_headentry();      /* check for corrupt undo list */", "  if (uep == NULL)"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  uep = u_get_headentry();      /* check for corrupt undo list */", "  if (uep == NULL)", "    return;"], "readability/braces"]
["src/nvim/undo.c", ["  if (uep != NULL) {", "    /*", "     * the new ue_bot is computed from the number of lines that has been"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Free one header \"uhp\" and its entry list and adjust the pointers."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /* When there is an alternate redo list free that branch completely,", "   * because we can never go there. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["   * because we can never go there. */", "  if (uhp->uh_alt_next.ptr != NULL)", "    u_freebranch(buf, uhp->uh_alt_next.ptr, uhpp);"], "readability/braces"]
["src/nvim/undo.c", ["", "  if (uhp->uh_alt_prev.ptr != NULL)", "    uhp->uh_alt_prev.ptr->uh_alt_next.ptr = NULL;"], "readability/braces"]
["src/nvim/undo.c", ["", "  /* Update the links in the list to remove the header. */", "  if (uhp->uh_next.ptr == NULL)"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  /* Update the links in the list to remove the header. */", "  if (uhp->uh_next.ptr == NULL)", "    buf->b_u_oldhead = uhp->uh_prev.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["    buf->b_u_oldhead = uhp->uh_prev.ptr;", "  else", "    uhp->uh_next.ptr->uh_prev.ptr = uhp->uh_prev.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["", "  if (uhp->uh_prev.ptr == NULL)", "    buf->b_u_newhead = uhp->uh_next.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["    buf->b_u_newhead = uhp->uh_next.ptr;", "  else", "    for (uhap = uhp->uh_prev.ptr; uhap != NULL;"], "readability/braces"]
["src/nvim/undo.c", ["  else", "    for (uhap = uhp->uh_prev.ptr; uhap != NULL;", "         uhap = uhap->uh_alt_next.ptr)"], "readability/braces"]
["src/nvim/undo.c", ["", "/*", " * Free an alternate branch and any following alternate branches."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /* If this is the top branch we may need to use u_freeheader() to update", "   * all the pointers. */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  if (uhp == buf->b_u_oldhead) {", "    while (buf->b_u_oldhead != NULL)", "      u_freeheader(buf, buf->b_u_oldhead, uhpp);"], "readability/braces"]
["src/nvim/undo.c", ["", "  if (uhp->uh_alt_prev.ptr != NULL)", "    uhp->uh_alt_prev.ptr->uh_alt_next.ptr = NULL;"], "readability/braces"]
["src/nvim/undo.c", ["    tofree = next;", "    if (tofree->uh_alt_next.ptr != NULL)", "      u_freebranch(buf, tofree->uh_alt_next.ptr, uhpp);         /* recursive */"], "readability/braces"]
["src/nvim/undo.c", ["    if (tofree->uh_alt_next.ptr != NULL)", "      u_freebranch(buf, tofree->uh_alt_next.ptr, uhpp);         /* recursive */", "    next = tofree->uh_prev.ptr;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Free all the undo entries for one header and the header itself."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /* Check for pointers to the header that become invalid now. */", "  if (buf->b_u_curhead == uhp)"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  /* Check for pointers to the header that become invalid now. */", "  if (buf->b_u_curhead == uhp)", "    buf->b_u_curhead = NULL;"], "readability/braces"]
["src/nvim/undo.c", ["    buf->b_u_curhead = NULL;", "  if (buf->b_u_newhead == uhp)", "    buf->b_u_newhead = NULL;      /* freeing the newest entry */"], "readability/braces"]
["src/nvim/undo.c", ["  if (buf->b_u_newhead == uhp)", "    buf->b_u_newhead = NULL;      /* freeing the newest entry */", "  if (uhpp != NULL && uhp == *uhpp)"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    buf->b_u_newhead = NULL;      /* freeing the newest entry */", "  if (uhpp != NULL && uhp == *uhpp)", "    *uhpp = NULL;"], "readability/braces"]
["src/nvim/undo.c", ["  xfree((char_u *)uhp);", "  --buf->b_u_numhead;", "}"], "readability/increment"]
["src/nvim/undo.c", ["", "/*", " * free entry 'uep' and 'n' lines in uep->ue_array[]"], "readability/old_style_comment"]
["src/nvim/undo.c", ["{", "  while (n > 0)", "    xfree(uep->ue_array[--n]);"], "readability/braces"]
["src/nvim/undo.c", ["", "/*", " * invalidate the undo buffer; called when storage has already been released"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * save the line \"lnum\" for the \"U\" command"], "readability/old_style_comment"]
["src/nvim/undo.c", ["{", "  if (lnum == curbuf->b_u_line_lnum)        /* line is already saved */", "    return;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["{", "  if (lnum == curbuf->b_u_line_lnum)        /* line is already saved */", "    return;"], "readability/braces"]
["src/nvim/undo.c", ["    return;", "  if (lnum < 1 || lnum > curbuf->b_ml.ml_line_count)   /* should never happen */", "    return;"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    return;", "  if (lnum < 1 || lnum > curbuf->b_ml.ml_line_count)   /* should never happen */", "    return;"], "readability/braces"]
["src/nvim/undo.c", ["  curbuf->b_u_line_lnum = lnum;", "  if (curwin->w_cursor.lnum == lnum)", "    curbuf->b_u_line_colnr = curwin->w_cursor.col;"], "readability/braces"]
["src/nvim/undo.c", ["    curbuf->b_u_line_colnr = curwin->w_cursor.col;", "  else", "    curbuf->b_u_line_colnr = 0;"], "readability/braces"]
["src/nvim/undo.c", ["", "/*", " * clear the line saved for the \"U\" command"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Implementation of the \"U\" command."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /* first save the line for the 'u' command */", "  if (u_savecommon(curbuf->b_u_line_lnum - 1,"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  /* first save the line for the 'u' command */", "  if (u_savecommon(curbuf->b_u_line_lnum - 1,", "          curbuf->b_u_line_lnum + 1, (linenr_T)0, FALSE) == FAIL)"], "readability/braces"]
["src/nvim/undo.c", ["  if (u_savecommon(curbuf->b_u_line_lnum - 1,", "          curbuf->b_u_line_lnum + 1, (linenr_T)0, FALSE) == FAIL)", "    return;"], "whitespace/alignment"]
["src/nvim/undo.c", ["  if (u_savecommon(curbuf->b_u_line_lnum - 1,", "          curbuf->b_u_line_lnum + 1, (linenr_T)0, FALSE) == FAIL)", "    return;"], "readability/bool"]
["src/nvim/undo.c", ["  t = curbuf->b_u_line_colnr;", "  if (curwin->w_cursor.lnum == curbuf->b_u_line_lnum)", "    curbuf->b_u_line_colnr = curwin->w_cursor.col;"], "readability/braces"]
["src/nvim/undo.c", ["", "/*", " * Free all allocated memory blocks for the buffer 'buf'."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * u_save_line(): allocate memory and copy line 'lnum' into it."], "readability/old_style_comment"]
