["src/nvim/screen.c", ["", "#define MB_FILLER_CHAR '<'  /* character used when a double-width character", "                             * doesn't fit. */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["", "#define MB_FILLER_CHAR '<'  /* character used when a double-width character", "                             * doesn't fit. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "static match_T search_hl;       /* used for 'hlsearch' highlight matching */", ""], "readability/old_style_comment"]
["src/nvim/screen.c", ["    wp->w_redr_type = type;", "    if (type >= NOT_VALID)", "      wp->w_lines_valid = 0;"], "readability/braces"]
["src/nvim/screen.c", ["      wp->w_lines_valid = 0;", "    if (must_redraw < type)     /* must_redraw is the maximum of all windows */", "      must_redraw = type;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      wp->w_lines_valid = 0;", "    if (must_redraw < type)     /* must_redraw is the maximum of all windows */", "      must_redraw = type;"], "readability/braces"]
["src/nvim/screen.c", ["", "/*", " * Mark all windows to be redrawn later."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Mark all windows that are editing the current buffer to be updated later."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Changed something in the current window, at buffer line \"lnum\", that"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * update all windows that are editing the current buffer"], "readability/old_style_comment"]
["src/nvim/screen.c", ["{", "  static int did_intro = FALSE;", "  int did_one;"], "readability/bool"]
["src/nvim/screen.c", ["  if (must_redraw) {", "    if (type < must_redraw)         /* use maximal type */", "      type = must_redraw;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  if (must_redraw) {", "    if (type < must_redraw)         /* use maximal type */", "      type = must_redraw;"], "readability/braces"]
["src/nvim/screen.c", ["", "    /* must_redraw is reset here, so that when we run into some weird", "    * reason to redraw while busy redrawing (e.g., asynchronous"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* Need to update w_lines[]. */", "  if (curwin->w_lines_valid == 0 && type < NOT_VALID)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  /* Need to update w_lines[]. */", "  if (curwin->w_lines_valid == 0 && type < NOT_VALID)", "    type = NOT_VALID;"], "readability/braces"]
["src/nvim/screen.c", ["", "  /* Postpone the redrawing when it's not needed and when being called", "   * recursively. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                <= msg_scrolled) {", "              wp->w_redr_status = TRUE;", "            }"], "readability/bool"]
["src/nvim/screen.c", ["      }", "      redraw_cmdline = TRUE;", "      redraw_tabline = TRUE;"], "readability/bool"]
["src/nvim/screen.c", ["      redraw_cmdline = TRUE;", "      redraw_tabline = TRUE;", "    }"], "readability/bool"]
["src/nvim/screen.c", ["", "  /* reset cmdline_row now (may have been changed temporarily) */", "  compute_cmdrow();"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* Check for changed highlighting */", "  if (need_highlight_changed)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  /* Check for changed highlighting */", "  if (need_highlight_changed)", "    highlight_changed();"], "readability/braces"]
["src/nvim/screen.c", ["", "  if (clear_cmdline)            /* going to clear cmdline (done below) */", "    check_for_delay(FALSE);"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  if (clear_cmdline)            /* going to clear cmdline (done below) */", "    check_for_delay(FALSE);"], "readability/braces"]
["src/nvim/screen.c", ["  if (clear_cmdline)            /* going to clear cmdline (done below) */", "    check_for_delay(FALSE);", ""], "readability/bool"]
["src/nvim/screen.c", ["", "  /* Force redraw when width of 'number' or 'relativenumber' column", "   * changes. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["   * changes. */", "  if (curwin->w_redr_type < NOT_VALID", "      && curwin->w_nrwidth != ((curwin->w_p_nu || curwin->w_p_rnu)"], "readability/braces"]
["src/nvim/screen.c", ["", "  /*", "   * Only start redrawing if there is really something to do."], "readability/old_style_comment"]
["src/nvim/screen.c", ["   */", "  if (type == INVERTED)", "    update_curswant();"], "readability/braces"]
["src/nvim/screen.c", ["    update_curswant();", "  if (curwin->w_redr_type < type", "      && !((type == VALID"], "readability/braces"]
["src/nvim/screen.c", ["               && curwin->w_old_curswant == curwin->w_curswant)", "           ))", "    curwin->w_redr_type = type;"], "whitespace/parens"]
["src/nvim/screen.c", ["", "  /*", "   * Correct stored syntax highlighting info for changes in each displayed"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * Go from top to bottom through the windows, redrawing the ones that need"], "readability/old_style_comment"]
["src/nvim/screen.c", ["   */", "  did_one = FALSE;", "  search_hl.rm.regprog = NULL;"], "readability/bool"]
["src/nvim/screen.c", ["      if (!did_one) {", "        did_one = TRUE;", "        start_search_hl();"], "readability/bool"]
["src/nvim/screen.c", ["", "    /* redraw status line after the window to minimize cursor movement */", "    if (wp->w_redr_status) {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* Reset b_mod_set flags.  Going through all windows is probably faster", "   * than going through all buffers (there could be many buffers). */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* Clear or redraw the command line.  Done last, because scrolling may", "   * mess up the command line. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* May put up an introductory message when not editing a file */", "  if (!did_intro)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  /* May put up an introductory message when not editing a file */", "  if (!did_intro)", "    maybe_intro_message();"], "readability/braces"]
["src/nvim/screen.c", ["    maybe_intro_message();", "  did_intro = TRUE;", ""], "readability/bool"]
["src/nvim/screen.c", ["", "/*", " * Update a single window."], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int type;", "  int top_end = 0;              /* Below last row of the top area that needs", "                                   updating.  0 when no top area updating. */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["  int type;", "  int top_end = 0;              /* Below last row of the top area that needs", "                                   updating.  0 when no top area updating. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                                   updating.  0 when no top area updating. */", "  int mid_start = 999;          /* first row of the mid area that needs", "                                   updating.  999 when no mid area updating. */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["                                   updating.  0 when no top area updating. */", "  int mid_start = 999;          /* first row of the mid area that needs", "                                   updating.  999 when no mid area updating. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                                   updating.  999 when no mid area updating. */", "  int mid_end = 0;              /* Below last row of the mid area that needs", "                                   updating.  0 when no mid area updating. */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["                                   updating.  999 when no mid area updating. */", "  int mid_end = 0;              /* Below last row of the mid area that needs", "                                   updating.  0 when no mid area updating. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                                   updating.  0 when no mid area updating. */", "  int bot_start = 999;          /* first row of the bot area that needs", "                                   updating.  999 when no bot area updating */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["                                   updating.  0 when no mid area updating. */", "  int bot_start = 999;          /* first row of the bot area that needs", "                                   updating.  999 when no bot area updating */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                                   updating.  999 when no bot area updating */", "  int scrolled_down = FALSE;            /* TRUE when scrolled down when", "                                           w_topline got smaller a bit */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["                                   updating.  999 when no bot area updating */", "  int scrolled_down = FALSE;            /* TRUE when scrolled down when", "                                           w_topline got smaller a bit */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                                   updating.  999 when no bot area updating */", "  int scrolled_down = FALSE;            /* TRUE when scrolled down when", "                                           w_topline got smaller a bit */"], "readability/bool"]
["src/nvim/screen.c", ["", "  int row;                      /* current window row to display */", "  linenr_T lnum;                /* current buffer lnum to display */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int row;                      /* current window row to display */", "  linenr_T lnum;                /* current buffer lnum to display */", "  int idx;                      /* current index in w_lines[] */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  linenr_T lnum;                /* current buffer lnum to display */", "  int idx;                      /* current index in w_lines[] */", "  int srow;                     /* starting row of the current line */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int idx;                      /* current index in w_lines[] */", "  int srow;                     /* starting row of the current line */", ""], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  int eof = FALSE;              /* if TRUE, we hit the end of the file */", "  int didline = FALSE;           /* if TRUE, we finished the last line */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  int eof = FALSE;              /* if TRUE, we hit the end of the file */", "  int didline = FALSE;           /* if TRUE, we finished the last line */"], "readability/bool"]
["src/nvim/screen.c", ["  int eof = FALSE;              /* if TRUE, we hit the end of the file */", "  int didline = FALSE;           /* if TRUE, we finished the last line */", "  int i;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int eof = FALSE;              /* if TRUE, we hit the end of the file */", "  int didline = FALSE;           /* if TRUE, we finished the last line */", "  int i;"], "readability/bool"]
["src/nvim/screen.c", ["  int did_update = DID_NONE;", "  linenr_T syntax_last_parsed = 0;              /* last parsed text line */", "  linenr_T mod_top = 0;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* Force redraw when width of 'number' or 'relativenumber' column", "   * changes. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  } else {", "    /*", "     * Set mod_top to the first line that needs displaying because of"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    mod_top = wp->w_redraw_top;", "    if (wp->w_redraw_bot != 0)", "      mod_bot = wp->w_redraw_bot + 1;"], "readability/braces"]
["src/nvim/screen.c", ["      mod_bot = wp->w_redraw_bot + 1;", "    else", "      mod_bot = 0;"], "readability/braces"]
["src/nvim/screen.c", ["        mod_top = buf->b_mod_top;", "        /* Need to redraw lines above the change that may be included", "         * in a pattern match. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          mod_top -= buf->b_s.b_syn_sync_linebreaks;", "          if (mod_top < 1)", "            mod_top = 1;"], "readability/braces"]
["src/nvim/screen.c", ["      }", "      if (mod_bot == 0 || mod_bot < buf->b_mod_bot)", "        mod_bot = buf->b_mod_bot;"], "readability/braces"]
["src/nvim/screen.c", ["", "      /*", "       * A change in a line can cause lines above it to become folded or"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "      /* Find last valid w_lines[] entry above mod_top.  Set lnumt to", "       * the line below it.  If there is no valid entry, use w_topline."], "readability/old_style_comment"]
["src/nvim/screen.c", ["      lnumb = MAXLNUM;", "      for (i = 0; i < wp->w_lines_valid; ++i)", "        if (wp->w_lines[i].wl_valid) {"], "readability/braces"]
["src/nvim/screen.c", ["      lnumb = MAXLNUM;", "      for (i = 0; i < wp->w_lines_valid; ++i)", "        if (wp->w_lines[i].wl_valid) {"], "readability/increment"]
["src/nvim/screen.c", ["        if (wp->w_lines[i].wl_valid) {", "          if (wp->w_lines[i].wl_lastlnum < mod_top)", "            lnumt = wp->w_lines[i].wl_lastlnum + 1;"], "readability/braces"]
["src/nvim/screen.c", ["", "    /* When a change starts above w_topline and the end is below", "     * w_topline, start redrawing at w_topline."], "readability/old_style_comment"]
["src/nvim/screen.c", ["    if (mod_top != 0 && mod_top < wp->w_topline) {", "      if (mod_bot > wp->w_topline)", "        mod_top = wp->w_topline;"], "readability/braces"]
["src/nvim/screen.c", ["        mod_top = wp->w_topline;", "      else if (syntax_present(wp))", "        top_end = 1;"], "readability/braces"]
["src/nvim/screen.c", ["", "    /* When line numbers are displayed need to redraw all lines below", "     * inserted/deleted lines. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["     * inserted/deleted lines. */", "    if (mod_top != 0 && buf->b_mod_xlines != 0 && wp->w_p_nu)", "      mod_bot = MAXLNUM;"], "readability/braces"]
["src/nvim/screen.c", ["", "  /*", "   * When only displaying the lines at the top, set top_end.  Used when"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    j = 0;", "    for (i = 0; i < wp->w_lines_valid; ++i) {", "      j += wp->w_lines[i].wl_size;"], "readability/increment"]
["src/nvim/screen.c", ["    }", "    if (top_end == 0)", "      /* not found (cannot happen?): redraw everything */"], "readability/braces"]
["src/nvim/screen.c", ["    if (top_end == 0)", "      /* not found (cannot happen?): redraw everything */", "      type = NOT_VALID;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      type = NOT_VALID;", "    else", "      /* top area defined, the rest is VALID */"], "readability/braces"]
["src/nvim/screen.c", ["    else", "      /* top area defined, the rest is VALID */", "      type = VALID;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * If there are no changes on the screen that require a complete redraw,"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                       && wp->w_topfill > wp->w_old_topfill)", "                   )) {", "      /*"], "whitespace/parens"]
["src/nvim/screen.c", ["                   )) {", "      /*", "       * New topline is above old topline: May scroll down."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "        /* count the number of lines we are off, counting a sequence", "         * of folded lines as one */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        }", "      } else", "        j = wp->w_lines[0].wl_lnum - wp->w_topline;"], "readability/braces"]
["src/nvim/screen.c", ["        i = plines_m_win(wp, wp->w_topline, wp->w_lines[0].wl_lnum - 1);", "        /* insert extra lines for previously invisible filler lines */", "        if (wp->w_lines[0].wl_lnum != wp->w_topline)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        /* insert extra lines for previously invisible filler lines */", "        if (wp->w_lines[0].wl_lnum != wp->w_topline)", "          i += diff_check_fill(wp, wp->w_lines[0].wl_lnum)"], "readability/braces"]
["src/nvim/screen.c", ["    } else {", "      /*", "       * New topline is at or below old topline: May scroll up."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "      /* try to find wp->w_topline in wp->w_lines[].wl_lnum */", "      j = -1;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      if (j == -1) {", "        /* if wp->w_topline is not in wp->w_lines[].wl_lnum redraw all", "         * lines */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      } else {", "        /*", "         * Try to delete the correct number of lines."], "readability/old_style_comment"]
["src/nvim/screen.c", ["         */", "        /* If the topline didn't change, delete old filler lines,", "         * otherwise delete filler lines of the new topline... */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["         * otherwise delete filler lines of the new topline... */", "        if (wp->w_lines[0].wl_lnum == wp->w_topline)", "          row += wp->w_old_topfill;"], "readability/braces"]
["src/nvim/screen.c", ["          row += wp->w_old_topfill;", "        else", "          row += diff_check_fill(wp, wp->w_topline);"], "readability/braces"]
["src/nvim/screen.c", ["          row += diff_check_fill(wp, wp->w_topline);", "        /* ... but don't delete new filler lines. */", "        row -= wp->w_topfill;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        if ((row == 0 || bot_start < 999) && wp->w_lines_valid != 0) {", "          /*", "           * Skip the lines (below the deleted lines) that are still"], "readability/old_style_comment"]
["src/nvim/screen.c", ["            wp->w_lines[idx] = wp->w_lines[j];", "            /* stop at line that didn't fit, unless it is still", "             * valid (no lines deleted) */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "            /* stop at the last valid entry in w_lines[].wl_size */", "            if (++j >= wp->w_lines_valid) {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          }", "          /* Correct the first entry for filler lines at the top", "           * when it won't get updated below. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["           * when it won't get updated below. */", "          if (wp->w_p_diff && bot_start > 0)", "            wp->w_lines[0].wl_size ="], "readability/braces"]
["src/nvim/screen.c", ["  } else {", "    /* Not VALID or INVERTED: redraw all lines. */", "    mid_start = 0;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  if (type == SOME_VALID) {", "    /* SOME_VALID: redraw all lines. */", "    mid_start = 0;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* check if we are updating or removing the inverted part */", "  if ((VIsual_active && buf == curwin->w_buffer)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        }", "        /* redraw more when the cursor moved as well */", "        if (wp->w_old_cursor_lnum < from)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        /* redraw more when the cursor moved as well */", "        if (wp->w_old_cursor_lnum < from)", "          from = wp->w_old_cursor_lnum;"], "readability/braces"]
["src/nvim/screen.c", ["          from = wp->w_old_cursor_lnum;", "        if (wp->w_old_cursor_lnum > to)", "          to = wp->w_old_cursor_lnum;"], "readability/braces"]
["src/nvim/screen.c", ["          to = wp->w_old_cursor_lnum;", "        if (wp->w_old_visual_lnum < from)", "          from = wp->w_old_visual_lnum;"], "readability/braces"]
["src/nvim/screen.c", ["          from = wp->w_old_visual_lnum;", "        if (wp->w_old_visual_lnum > to)", "          to = wp->w_old_visual_lnum;"], "readability/braces"]
["src/nvim/screen.c", ["      } else {", "        /*", "         * Find the line numbers that need to be updated: The lines"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          to = curwin->w_cursor.lnum;", "          if (from == 0)                /* Visual mode just started */", "            from = to;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          to = curwin->w_cursor.lnum;", "          if (from == 0)                /* Visual mode just started */", "            from = to;"], "readability/braces"]
["src/nvim/screen.c", ["            || VIsual.col != wp->w_old_visual_col) {", "          if (wp->w_old_visual_lnum < from", "              && wp->w_old_visual_lnum != 0)"], "readability/braces"]
["src/nvim/screen.c", ["            from = wp->w_old_visual_lnum;", "          if (wp->w_old_visual_lnum > to)", "            to = wp->w_old_visual_lnum;"], "readability/braces"]
["src/nvim/screen.c", ["            to = wp->w_old_visual_lnum;", "          if (VIsual.lnum < from)", "            from = VIsual.lnum;"], "readability/braces"]
["src/nvim/screen.c", ["            from = VIsual.lnum;", "          if (VIsual.lnum > to)", "            to = VIsual.lnum;"], "readability/braces"]
["src/nvim/screen.c", ["", "      /*", "       * If in block mode and changed column or curwin->w_curswant:"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "        if (curwin->w_p_lbr)", "          ve_flags = VE_ALL;"], "readability/braces"]
["src/nvim/screen.c", ["        ve_flags = save_ve_flags;", "        ++toc;", "        if (curwin->w_curswant == MAXCOL)"], "readability/increment"]
["src/nvim/screen.c", ["        ++toc;", "        if (curwin->w_curswant == MAXCOL)", "          toc = MAXCOL;"], "readability/braces"]
["src/nvim/screen.c", ["            || toc != wp->w_old_cursor_lcol) {", "          if (from > VIsual.lnum)", "            from = VIsual.lnum;"], "readability/braces"]
["src/nvim/screen.c", ["            from = VIsual.lnum;", "          if (to < VIsual.lnum)", "            to = VIsual.lnum;"], "readability/braces"]
["src/nvim/screen.c", ["    } else {", "      /* Use the line numbers of the old Visual area. */", "      if (wp->w_old_cursor_lnum < wp->w_old_visual_lnum) {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /*", "     * There is no need to update lines above the top of the window."], "readability/old_style_comment"]
["src/nvim/screen.c", ["     */", "    if (from < wp->w_topline)", "      from = wp->w_topline;"], "readability/braces"]
["src/nvim/screen.c", ["", "    /*", "     * If we know the value of w_botline, use it to restrict the update to"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    if (wp->w_valid & VALID_BOTLINE) {", "      if (from >= wp->w_botline)", "        from = wp->w_botline - 1;"], "readability/braces"]
["src/nvim/screen.c", ["        from = wp->w_botline - 1;", "      if (to >= wp->w_botline)", "        to = wp->w_botline - 1;"], "readability/braces"]
["src/nvim/screen.c", ["", "    /*", "     * Find the minimal part to be updated."], "readability/old_style_comment"]
["src/nvim/screen.c", ["      srow = 0;", "      if (scrolled_down)", "        mid_start = top_end;"], "readability/braces"]
["src/nvim/screen.c", ["        mid_start = top_end;", "      else", "        mid_start = 0;"], "readability/braces"]
["src/nvim/screen.c", ["        mid_start = 0;", "      while (lnum < from && idx < wp->w_lines_valid) {          /* find start */", "        if (wp->w_lines[idx].wl_valid)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      while (lnum < from && idx < wp->w_lines_valid) {          /* find start */", "        if (wp->w_lines[idx].wl_valid)", "          mid_start += wp->w_lines[idx].wl_size;"], "readability/braces"]
["src/nvim/screen.c", ["          mid_start += wp->w_lines[idx].wl_size;", "        else if (!scrolled_down)", "          srow += wp->w_lines[idx].wl_size;"], "readability/braces"]
["src/nvim/screen.c", ["          srow += wp->w_lines[idx].wl_size;", "        ++idx;", "        if (idx < wp->w_lines_valid && wp->w_lines[idx].wl_valid)"], "readability/increment"]
["src/nvim/screen.c", ["        ++idx;", "        if (idx < wp->w_lines_valid && wp->w_lines[idx].wl_valid)", "          lnum = wp->w_lines[idx].wl_lnum;"], "readability/braces"]
["src/nvim/screen.c", ["          lnum = wp->w_lines[idx].wl_lnum;", "        else", "          ++lnum;"], "readability/braces"]
["src/nvim/screen.c", ["        else", "          ++lnum;", "      }"], "readability/increment"]
["src/nvim/screen.c", ["            && wp->w_lines[idx].wl_lnum >= to + 1) {", "          /* Only update until first row of this line */", "          mid_end = srow;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* reset got_int, otherwise regexp won't work */", "  save_got_int = got_int;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * Update all the window rows."], "readability/old_style_comment"]
["src/nvim/screen.c", ["   */", "  idx = 0;              /* first entry in w_lines[].wl_size */", "  row = 0;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  for (;; ) {", "    /* stop updating when reached the end of the window (check for _past_", "     * the end of the window is at the end of the loop) */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /* stop updating when hit the end of the file */", "    if (lnum > buf->b_ml.ml_line_count) {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    if (lnum > buf->b_ml.ml_line_count) {", "      eof = TRUE;", "      break;"], "readability/bool"]
["src/nvim/screen.c", ["", "    /* Remember the starting row of the line that is going to be dealt", "     * with.  It is used further down when the line doesn't fit. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "      /*", "       * When at start of changed lines: May scroll following lines"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "        /* Count the old number of window rows, using w_lines[], which", "         * should still contain the sizes for the lines as they are"], "readability/old_style_comment"]
["src/nvim/screen.c", ["         * currently displayed. */", "        for (i = idx; i < wp->w_lines_valid; ++i) {", "          /* Only valid lines have a meaningful wl_lnum.  Invalid"], "readability/increment"]
["src/nvim/screen.c", ["        for (i = idx; i < wp->w_lines_valid; ++i) {", "          /* Only valid lines have a meaningful wl_lnum.  Invalid", "           * lines are part of the changed area. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["           * lines are part of the changed area. */", "          if (wp->w_lines[i].wl_valid", "              && wp->w_lines[i].wl_lnum == mod_bot)"], "readability/braces"]
["src/nvim/screen.c", ["              && wp->w_lines[i].wl_lastlnum + 1 == mod_bot) {", "            /* Must have found the last valid entry above mod_bot.", "             * Add following invalid entries. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["             * Add following invalid entries. */", "            ++i;", "            while (i < wp->w_lines_valid"], "readability/increment"]
["src/nvim/screen.c", ["            ++i;", "            while (i < wp->w_lines_valid", "                   && !wp->w_lines[i].wl_valid)"], "readability/braces"]
["src/nvim/screen.c", ["        if (i >= wp->w_lines_valid) {", "          /* We can't find a valid line below the changed lines,", "           * need to redraw until the end of the window."], "readability/old_style_comment"]
["src/nvim/screen.c", ["        } else {", "          /* Able to count old number of rows: Count new window", "           * rows, and may insert/delete lines */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          if (xtra_rows < 0) {", "            /* May scroll text up.  If there is not enough", "             * remaining text or scrolling fails, must redraw the"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          } else if (xtra_rows > 0) {", "            /* May scroll text down.  If there is not enough", "             * remaining text of scrolling fails, must redraw the"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "          /* When not updating the rest, may need to move w_lines[]", "           * entries. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "              /* move entries in w_lines[] upwards */", "              for (;; ) {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["              for (;; ) {", "                /* stop at last valid entry in w_lines[] */", "                if (i >= wp->w_lines_valid) {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                wp->w_lines[j] = wp->w_lines[i];", "                /* stop at a line that won't fit */", "                if (x + (int)wp->w_lines[j].wl_size"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                x += wp->w_lines[j++].wl_size;", "                ++i;", "              }"], "readability/increment"]
["src/nvim/screen.c", ["              }", "              if (bot_start > x)", "                bot_start = x;"], "readability/braces"]
["src/nvim/screen.c", ["                bot_start = x;", "            } else {       /* j > i */", "                             /* move entries in w_lines[] downwards */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["            } else {       /* j > i */", "                             /* move entries in w_lines[] downwards */", "              j -= i;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "              /* The w_lines[] entries for inserted lines are", "               * now invalid, but wl_size may be used above."], "readability/old_style_comment"]
["src/nvim/screen.c", ["                wp->w_lines[i].wl_size = 0;", "                wp->w_lines[i--].wl_valid = FALSE;", "              }"], "readability/bool"]
["src/nvim/screen.c", ["", "      /*", "       * When lines are folded, display one line for all of them."], "readability/old_style_comment"]
["src/nvim/screen.c", ["        prepare_search_hl(wp, lnum);", "        /* Let the syntax stuff know we skipped a few lines. */", "        if (syntax_last_parsed != 0 && syntax_last_parsed + 1 < lnum"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        /* Let the syntax stuff know we skipped a few lines. */", "        if (syntax_last_parsed != 0 && syntax_last_parsed + 1 < lnum", "            && syntax_present(wp))"], "readability/braces"]
["src/nvim/screen.c", ["    if (lnum > buf->b_ml.ml_line_count) {", "      eof = TRUE;", "      break;"], "readability/bool"]
["src/nvim/screen.c", ["  }", "  /*", "   * End of loop over all window lines."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  if (idx > wp->w_lines_valid)", "    wp->w_lines_valid = idx;"], "readability/braces"]
["src/nvim/screen.c", ["", "  /*", "   * Let the syntax stuff know we stop parsing here."], "readability/old_style_comment"]
["src/nvim/screen.c", ["   */", "  if (syntax_last_parsed != 0 && syntax_present(wp))", "    syntax_end_parsing(syntax_last_parsed + 1);"], "readability/braces"]
["src/nvim/screen.c", ["", "  /*", "   * If we didn't hit the end of the file, and we didn't finish the last"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    if (lnum == wp->w_topline) {", "      /*", "       * Single line that does not fit!"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      }", "    } else if (dollar_vcol == -1)", "      wp->w_botline = lnum;"], "readability/braces"]
["src/nvim/screen.c", ["", "  /* Reset the type of redrawing required, the window has been updated. */", "  wp->w_redr_type = 0;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  if (dollar_vcol == -1) {", "    /*", "     * There is a trick with w_botline.  If we invalidate it on each"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* restore got_int, unless CTRL-C was hit while redrawing */", "  if (!got_int)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  /* restore got_int, unless CTRL-C was hit while redrawing */", "  if (!got_int)", "    got_int = save_got_int;"], "readability/braces"]
["src/nvim/screen.c", ["", "/*", " * Advance **color_cols and return TRUE when there are columns to draw."], "readability/old_style_comment"]
["src/nvim/screen.c", ["{", "  while (**color_cols >= 0 && vcol > **color_cols)", "    ++*color_cols;"], "readability/braces"]
["src/nvim/screen.c", ["  while (**color_cols >= 0 && vcol > **color_cols)", "    ++*color_cols;", "  return **color_cols >= 0;"], "readability/increment"]
["src/nvim/screen.c", ["", "  int n_attr = 0;                       /* chars with special attr */", "  int saved_attr2 = 0;                  /* char_attr saved for n_attr */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int n_attr = 0;                       /* chars with special attr */", "  int saved_attr2 = 0;                  /* char_attr saved for n_attr */", "  int n_attr3 = 0;                      /* chars with overruling special attr */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int saved_attr2 = 0;                  /* char_attr saved for n_attr */", "  int n_attr3 = 0;                      /* chars with overruling special attr */", "  int saved_attr3 = 0;                  /* char_attr saved for n_attr3 */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int n_attr3 = 0;                      /* chars with overruling special attr */", "  int saved_attr3 = 0;                  /* char_attr saved for n_attr3 */", ""], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  int n_skip = 0;                       /* nr of chars to skip for 'nowrap' */", ""], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  int char_attr = 0;                    /* attributes for next character */", "  int attr_pri = FALSE;                 /* char_attr has priority */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int char_attr = 0;                    /* attributes for next character */", "  int attr_pri = FALSE;                 /* char_attr has priority */", "  int area_highlighting = FALSE;           /* Visual or incsearch highlighting"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int char_attr = 0;                    /* attributes for next character */", "  int attr_pri = FALSE;                 /* char_attr has priority */", "  int area_highlighting = FALSE;           /* Visual or incsearch highlighting"], "readability/bool"]
["src/nvim/screen.c", ["  int attr_pri = FALSE;                 /* char_attr has priority */", "  int area_highlighting = FALSE;           /* Visual or incsearch highlighting", "                                              in this line */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["  int attr_pri = FALSE;                 /* char_attr has priority */", "  int area_highlighting = FALSE;           /* Visual or incsearch highlighting", "                                              in this line */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int attr_pri = FALSE;                 /* char_attr has priority */", "  int area_highlighting = FALSE;           /* Visual or incsearch highlighting", "                                              in this line */"], "readability/bool"]
["src/nvim/screen.c", ["                                              in this line */", "  int attr = 0;                         /* attributes for area highlighting */", "  int area_attr = 0;                    /* attributes desired by highlighting */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int attr = 0;                         /* attributes for area highlighting */", "  int area_attr = 0;                    /* attributes desired by highlighting */", "  int search_attr = 0;                  /* attributes desired by 'hlsearch' */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int area_attr = 0;                    /* attributes desired by highlighting */", "  int search_attr = 0;                  /* attributes desired by 'hlsearch' */", "  int vcol_save_attr = 0;               /* saved attr for 'cursorcolumn' */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int search_attr = 0;                  /* attributes desired by 'hlsearch' */", "  int vcol_save_attr = 0;               /* saved attr for 'cursorcolumn' */", "  int syntax_attr = 0;                  /* attributes desired by syntax */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int vcol_save_attr = 0;               /* saved attr for 'cursorcolumn' */", "  int syntax_attr = 0;                  /* attributes desired by syntax */", "  int has_syntax = FALSE;               /* this buffer has syntax highl. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int syntax_attr = 0;                  /* attributes desired by syntax */", "  int has_syntax = FALSE;               /* this buffer has syntax highl. */", "  int save_did_emsg;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int syntax_attr = 0;                  /* attributes desired by syntax */", "  int has_syntax = FALSE;               /* this buffer has syntax highl. */", "  int save_did_emsg;"], "readability/bool"]
["src/nvim/screen.c", ["# define SPWORDLEN 150", "  char_u nextline[SPWORDLEN * 2];       /* text with start of the next line */", "  int nextlinecol = 0;                  /* column where nextline[] starts */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  char_u nextline[SPWORDLEN * 2];       /* text with start of the next line */", "  int nextlinecol = 0;                  /* column where nextline[] starts */", "  int nextline_idx = 0;                 /* index in nextline[] where next line"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int nextlinecol = 0;                  /* column where nextline[] starts */", "  int nextline_idx = 0;                 /* index in nextline[] where next line", "                                           starts */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["  int nextlinecol = 0;                  /* column where nextline[] starts */", "  int nextline_idx = 0;                 /* index in nextline[] where next line", "                                           starts */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                                           starts */", "  int spell_attr = 0;                   /* attributes desired by spelling */", "  int word_end = 0;                     /* last byte with same spell_attr */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int spell_attr = 0;                   /* attributes desired by spelling */", "  int word_end = 0;                     /* last byte with same spell_attr */", "  static linenr_T checked_lnum = 0;     /* line number for \"checked_col\" */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int word_end = 0;                     /* last byte with same spell_attr */", "  static linenr_T checked_lnum = 0;     /* line number for \"checked_col\" */", "  static int checked_col = 0;           /* column in \"checked_lnum\" up to which"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  static linenr_T checked_lnum = 0;     /* line number for \"checked_col\" */", "  static int checked_col = 0;           /* column in \"checked_lnum\" up to which", "                                         * there are no spell errors */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["  static linenr_T checked_lnum = 0;     /* line number for \"checked_col\" */", "  static int checked_col = 0;           /* column in \"checked_lnum\" up to which", "                                         * there are no spell errors */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* draw_state: items that are drawn in sequence: */", "#define WL_START        0               /* nothing done yet */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  /* draw_state: items that are drawn in sequence: */", "#define WL_START        0               /* nothing done yet */", "# define WL_CMDLINE     WL_START + 1    /* cmdline window column */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["#define WL_START        0               /* nothing done yet */", "# define WL_CMDLINE     WL_START + 1    /* cmdline window column */", "# define WL_FOLD        WL_CMDLINE + 1  /* 'foldcolumn' */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["# define WL_CMDLINE     WL_START + 1    /* cmdline window column */", "# define WL_FOLD        WL_CMDLINE + 1  /* 'foldcolumn' */", "# define WL_SIGN        WL_FOLD + 1     /* column for signs */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["# define WL_FOLD        WL_CMDLINE + 1  /* 'foldcolumn' */", "# define WL_SIGN        WL_FOLD + 1     /* column for signs */", "#define WL_NR           WL_SIGN + 1     /* line number */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["# define WL_SIGN        WL_FOLD + 1     /* column for signs */", "#define WL_NR           WL_SIGN + 1     /* line number */", "# define WL_BRI         WL_NR + 1       /* 'breakindent' */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["#define WL_NR           WL_SIGN + 1     /* line number */", "# define WL_BRI         WL_NR + 1       /* 'breakindent' */", "# define WL_SBR         WL_BRI + 1       /* 'showbreak' or 'diff' */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["# define WL_BRI         WL_NR + 1       /* 'breakindent' */", "# define WL_SBR         WL_BRI + 1       /* 'showbreak' or 'diff' */", "#define WL_LINE         WL_SBR + 1      /* text in the line */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["# define WL_SBR         WL_BRI + 1       /* 'showbreak' or 'diff' */", "#define WL_LINE         WL_SBR + 1      /* text in the line */", "  int draw_state = WL_START;            /* what to draw next */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["#define WL_LINE         WL_SBR + 1      /* text in the line */", "  int draw_state = WL_START;            /* what to draw next */", ""], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  if (startrow > endrow)                /* past the end already! */", "    return startrow;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  if (startrow > endrow)                /* past the end already! */", "    return startrow;"], "readability/braces"]
["src/nvim/screen.c", ["    if (filler_lines == -1) {", "      if (diff_find_change(wp, lnum, &change_start, &change_end))", "        diff_hlf = HLF_ADD;             /* added line */"], "readability/braces"]
["src/nvim/screen.c", ["      if (diff_find_change(wp, lnum, &change_start, &change_end))", "        diff_hlf = HLF_ADD;             /* added line */", "      else if (change_start == 0)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        diff_hlf = HLF_ADD;             /* added line */", "      else if (change_start == 0)", "        diff_hlf = HLF_TXD;             /* changed text */"], "readability/braces"]
["src/nvim/screen.c", ["      else if (change_start == 0)", "        diff_hlf = HLF_TXD;             /* changed text */", "      else"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        diff_hlf = HLF_TXD;             /* changed text */", "      else", "        diff_hlf = HLF_CHD;             /* changed line */"], "readability/braces"]
["src/nvim/screen.c", ["      else", "        diff_hlf = HLF_CHD;             /* changed line */", "    } else"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        diff_hlf = HLF_CHD;             /* changed line */", "    } else", "      diff_hlf = HLF_ADD;               /* added line */"], "readability/braces"]
["src/nvim/screen.c", ["    } else", "      diff_hlf = HLF_ADD;               /* added line */", "    filler_lines = 0;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    filler_lines = 0;", "    area_highlighting = TRUE;", "  }"], "readability/bool"]
["src/nvim/screen.c", ["  }", "  if (lnum == wp->w_topline)", "    filler_lines = wp->w_topfill;"], "readability/braces"]
["src/nvim/screen.c", ["", "  line = ml_get_buf(wp->w_buffer, lnum, FALSE);", "  ptr = line;"], "readability/bool"]
["src/nvim/screen.c", ["", "    /* To be able to spell-check over line boundaries copy the end of the", "     * current line into nextline[].  Above the start of the next line was"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    if (nextline[SPWORDLEN] == NUL) {", "      /* No next line or it is empty. */", "      nextlinecol = MAXCOL;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      if (v < SPWORDLEN) {", "        /* Short line, use it completely and append the start of the", "         * next line. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      } else {", "        /* Long line, use only the last SPWORDLEN bytes. */", "        nextlinecol = v - SPWORDLEN;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      }", "      trailcol += (colnr_T) (ptr - line);", "    }"], "whitespace/cast"]
["src/nvim/screen.c", ["", "  /*", "   * 'nowrap' or 'wrap' and a single line that doesn't fit: Advance to the"], "readability/old_style_comment"]
["src/nvim/screen.c", ["   */", "  if (wp->w_p_wrap)", "    v = wp->w_skipcol;"], "readability/braces"]
["src/nvim/screen.c", ["    v = wp->w_skipcol;", "  else", "    v = wp->w_leftcol;"], "readability/braces"]
["src/nvim/screen.c", ["", "    /* Handle a character that's not completely on the screen: Put ptr at", "     * that character but skip the first few screen characters. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /*", "     * Adjust for when the inverted text is before the screen,"], "readability/old_style_comment"]
["src/nvim/screen.c", ["     */", "    if (tocol <= vcol)", "      fromcol = 0;"], "readability/braces"]
["src/nvim/screen.c", ["      fromcol = 0;", "    else if (fromcol >= 0 && fromcol < vcol)", "      fromcol = vcol;"], "readability/braces"]
["src/nvim/screen.c", ["      wp->w_cursor.col = linecol;", "      len = spell_move_to(wp, FORWARD, TRUE, TRUE, &spell_hlf);", ""], "readability/bool"]
["src/nvim/screen.c", ["", "      /* spell_move_to() may call ml_get() and make \"line\" invalid */", "      line = ml_get_buf(wp->w_buffer, lnum, FALSE);"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      /* spell_move_to() may call ml_get() and make \"line\" invalid */", "      line = ml_get_buf(wp->w_buffer, lnum, FALSE);", "      ptr = line + linecol;"], "readability/bool"]
["src/nvim/screen.c", ["      if (len == 0 || (int)wp->w_cursor.col > ptr - line) {", "        /* no bad word found at line start, don't check until end of a", "         * word */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      } else {", "        /* bad word found, use attributes until end of word */", "        assert(len <= INT_MAX);"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "        /* Turn index into actual attributes. */", "        if (spell_hlf != HLF_COUNT)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        /* Turn index into actual attributes. */", "        if (spell_hlf != HLF_COUNT)", "          spell_attr = highlight_attr[spell_hlf];"], "readability/braces"]
["src/nvim/screen.c", ["", "  /*", "   * Correct highlighting for cursor that can't be disabled."], "readability/old_style_comment"]
["src/nvim/screen.c", ["      if ((colnr_T)fromcol == wp->w_virtcol) {", "        /* highlighting starts at cursor, let it start just after the", "         * cursor */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        fromcol = -1;", "      } else if ((colnr_T)fromcol < wp->w_virtcol)", "        /* restart highlighting after the cursor */"], "readability/braces"]
["src/nvim/screen.c", ["      } else if ((colnr_T)fromcol < wp->w_virtcol)", "        /* restart highlighting after the cursor */", "        fromcol_prev = wp->w_virtcol;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    }", "    if (fromcol >= tocol)", "      fromcol = -1;"], "readability/braces"]
["src/nvim/screen.c", ["", "  /*", "   * Handle highlighting the last used search pattern and matches."], "readability/old_style_comment"]
["src/nvim/screen.c", ["      if (lnum == shl->lnum + shl->rm.endpos[0].lnum", "                  - shl->rm.startpos[0].lnum) {", "          shl->endcol = shl->rm.endpos[0].col;"], "whitespace/alignment"]
["src/nvim/screen.c", ["          } else {", "              ++shl->endcol;", "          }"], "readability/increment"]
["src/nvim/screen.c", ["    }", "    if (shl != &search_hl && cur != NULL)", "      cur = cur->next;"], "readability/braces"]
["src/nvim/screen.c", ["        if (cmdwin_type != 0 && wp == curwin) {", "          /* Draw the cmdline character. */", "          n_extra = 1;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          draw_state = WL_SIGN;", "          /* Show the sign column when there are any signs in this", "           * buffer or when using Netbeans. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        draw_state = WL_NR;", "        /* Display the absolute or relative line number. After the", "         * first fill with blanks when the 'n' flag isn't in 'cpo' */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        if (*p_sbr != NUL && need_showbreak) {", "          /* Draw 'showbreak' at the start of each broken line. */", "          p_extra = p_sbr;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          vcol_sbr = vcol + MB_CHARLEN(p_sbr);", "          /* Correct end of highlighted area for 'showbreak',", "           * required when 'linebreak' is also set. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["           * required when 'linebreak' is also set. */", "          if (tocol == vcol)", "            tocol += n_extra;"], "readability/braces"]
["src/nvim/screen.c", ["        if (saved_n_extra) {", "          /* Continue item from end of wrapped line. */", "          n_extra = saved_n_extra;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      if (!n_extra) {", "        /*", "         * Check for start/end of search pattern match."], "readability/old_style_comment"]
["src/nvim/screen.c", ["          }", "          bool pos_inprogress = true; // mark that a position match search is", "                                      // in progress"], "whitespace/comments"]
["src/nvim/screen.c", ["          while (shl->rm.regprog != NULL", "                                 || (cur != NULL && pos_inprogress)) {", "            if (shl->startcol != MAXCOL"], "whitespace/alignment"]
["src/nvim/screen.c", ["", "              /* Need to get the line again, a multi-line regexp", "               * may have made it invalid. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["               * may have made it invalid. */", "              line = ml_get_buf(wp->w_buffer, lnum, FALSE);", "              ptr = line + v;"], "readability/bool"]
["src/nvim/screen.c", ["                shl->startcol = shl->rm.startpos[0].col;", "                if (shl->rm.endpos[0].lnum == 0)", "                  shl->endcol = shl->rm.endpos[0].col;"], "readability/braces"]
["src/nvim/screen.c", ["                  shl->endcol = shl->rm.endpos[0].col;", "                else", "                  shl->endcol = MAXCOL;"], "readability/braces"]
["src/nvim/screen.c", ["          }", "          if (shl != &search_hl && cur != NULL)", "            cur = cur->next;"], "readability/braces"]
["src/nvim/screen.c", ["", "        /* Use attributes from match with highest priority among", "         * 'search_hl' and the match list. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          }", "          if (shl != &search_hl && cur != NULL)", "            cur = cur->next;"], "readability/braces"]
["src/nvim/screen.c", ["      // (area_attr may be 0 when \"noinvcur\" is set).", "      else if (line_attr != 0 && ((fromcol == -10 && tocol == MAXCOL)", "                                  || vcol < fromcol || vcol_prev < fromcol_prev"], "whitespace/newline"]
["src/nvim/screen.c", ["", "        /* Get syntax attribute, unless still at the start of the line", "         * (double-wide char that doesn't fit). */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        if (has_syntax && v > 0) {", "          /* Get the syntax attribute for the character.  If there", "           * is an error, disable syntax highlighting. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          save_did_emsg = did_emsg;", "          did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/screen.c", ["          if (did_emsg) {", "            wp->w_s->b_syn_error = TRUE;", "            has_syntax = FALSE;"], "readability/bool"]
["src/nvim/screen.c", ["            wp->w_s->b_syn_error = TRUE;", "            has_syntax = FALSE;", "          } else"], "readability/bool"]
["src/nvim/screen.c", ["            has_syntax = FALSE;", "          } else", "            did_emsg = save_did_emsg;"], "readability/braces"]
["src/nvim/screen.c", ["", "          /* Need to get the line again, a multi-line regexp may", "           * have made it invalid. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["           * have made it invalid. */", "          line = ml_get_buf(wp->w_buffer, lnum, FALSE);", "          ptr = line + v;"], "readability/bool"]
["src/nvim/screen.c", ["", "        /* Check spelling (unless at the end of the line).", "         * Only do this when there is no syntax highlighting, the"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "            /* Use nextline[] if possible, it has the start of the", "             * next line concatenated. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "            /* In Insert mode only highlight a word that", "             * doesn't touch the cursor. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                && (p - nextline) + len > nextline_idx) {", "              /* Remember that the good word continues at the", "               * start of the next line. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "            /* Turn index into actual attributes. */", "            if (spell_hlf != HLF_COUNT)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["            /* Turn index into actual attributes. */", "            if (spell_hlf != HLF_COUNT)", "              spell_attr = highlight_attr[spell_hlf];"], "readability/braces"]
["src/nvim/screen.c", ["                  && (p - nextline) + cap_col >= nextline_idx) {", "                /* Remember that the word in the next line", "                 * must start with a capital. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                                - nextline_idx);", "              } else", "                /* Compute the actual column. */"], "readability/braces"]
["src/nvim/screen.c", ["              } else", "                /* Compute the actual column. */", "                cap_col += (int)(prev_ptr - line);"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        if (spell_attr != 0) {", "          if (!attr_pri)", "            char_attr = hl_combine_attr(char_attr, spell_attr);"], "readability/braces"]
["src/nvim/screen.c", ["            char_attr = hl_combine_attr(char_attr, spell_attr);", "          else", "            char_attr = hl_combine_attr(spell_attr, char_attr);"], "readability/braces"]
["src/nvim/screen.c", ["          char_u *p = ptr - (mb_off + 1);", "          // TODO: is passing p for start of the line OK?", "          n_extra = win_lbr_chartabsize(wp, line, p, (colnr_T)vcol, NULL) - 1;"], "readability/todo"]
["src/nvim/screen.c", ["          if (ascii_iswhite(c)) {", "            if (c == TAB)", "              /* See \"Tab alignment\" below. */"], "readability/braces"]
["src/nvim/screen.c", ["            if (c == TAB)", "              /* See \"Tab alignment\" below. */", "              FIX_FOR_BOGUSCOLS;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "      /*", "       * Handling of non-printable characters."], "readability/old_style_comment"]
["src/nvim/screen.c", ["            if (wp->w_p_lbr) {", "              c_extra = NUL; /* using p_extra from above */", "            } else {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          }", "          if ((dy_flags & DY_UHEX) && wp->w_p_rl)", "            rl_mirror(p_extra);                 /* reverse \"<12>\" */"], "readability/braces"]
["src/nvim/screen.c", ["          if ((dy_flags & DY_UHEX) && wp->w_p_rl)", "            rl_mirror(p_extra);                 /* reverse \"<12>\" */", "          c_extra = NUL;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["            memset(p, ' ', n_extra);", "            STRNCPY(p, p_extra + 1, STRLEN(p_extra) - 1);", "            p[n_extra] = NUL;"], "runtime/printf"]
["src/nvim/screen.c", ["", "          if (n_extra > 0)", "            vcol_off += n_extra;"], "readability/braces"]
["src/nvim/screen.c", ["        } else if (n_skip == 0) {", "          is_concealing = TRUE;", "          n_skip = 1;"], "readability/bool"]
["src/nvim/screen.c", ["        prev_syntax_id = 0;", "        is_concealing = FALSE;", "      }"], "readability/bool"]
["src/nvim/screen.c", ["", "    /* In the cursor line and we may be concealing characters: correct", "     * the cursor column when we reach its position. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        if (wp->w_p_rl) {", "          if (col < 0)", "            n = 1;"], "readability/braces"]
["src/nvim/screen.c", ["        if (n != 0) {", "          /* At the window boundary, highlight the last character", "           * instead (better than nothing). */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        if (wp->w_p_rl) {", "          --col;", "          --off;"], "readability/increment"]
["src/nvim/screen.c", ["          --col;", "          --off;", "        } else {"], "readability/increment"]
["src/nvim/screen.c", ["        } else {", "          ++col;", "          ++off;"], "readability/increment"]
["src/nvim/screen.c", ["          ++col;", "          ++off;", "        }"], "readability/increment"]
["src/nvim/screen.c", ["        }", "        ++vcol;", "        eol_hl_off = 1;"], "readability/increment"]
["src/nvim/screen.c", ["", "      /* check if line ends before left margin */", "      if (vcol < v + col - win_col_off(wp))"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      /* check if line ends before left margin */", "      if (vcol < v + col - win_col_off(wp))", "        vcol = v + col - win_col_off(wp);"], "readability/braces"]
["src/nvim/screen.c", ["", "      if (draw_color_col)", "        draw_color_col = advance_color_col(VCOL_HLC, &color_cols);"], "readability/braces"]
["src/nvim/screen.c", ["", "      /*", "       * Update w_cline_height and w_cline_folded if the cursor line was"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        if (wp->w_p_rl) {", "          /* now it's time to backup one cell */", "          --off;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          /* now it's time to backup one cell */", "          --off;", "          --col;"], "readability/increment"]
["src/nvim/screen.c", ["          --off;", "          --col;", "        }"], "readability/increment"]
["src/nvim/screen.c", ["      if (wp->w_p_rl) {", "        --off;", "        --col;"], "readability/increment"]
["src/nvim/screen.c", ["        --off;", "        --col;", "      } else {"], "readability/increment"]
["src/nvim/screen.c", ["      } else {", "        ++off;", "        ++col;"], "readability/increment"]
["src/nvim/screen.c", ["        ++off;", "        ++col;", "      }"], "readability/increment"]
["src/nvim/screen.c", ["    } else if (wp->w_p_cole > 0 && is_concealing) {", "      --n_skip;", "      ++vcol_off;"], "readability/increment"]
["src/nvim/screen.c", ["      --n_skip;", "      ++vcol_off;", "      if (n_extra > 0)"], "readability/increment"]
["src/nvim/screen.c", ["      ++vcol_off;", "      if (n_extra > 0)", "        vcol_off += n_extra;"], "readability/braces"]
["src/nvim/screen.c", ["      if (wp->w_p_wrap) {", "        /*", "         * Special voodoo required if 'wrap' is on."], "readability/old_style_comment"]
["src/nvim/screen.c", ["          if (wp->w_p_rl) {", "            --boguscols;", "            --col;"], "readability/increment"]
["src/nvim/screen.c", ["            --boguscols;", "            --col;", "          } else {"], "readability/increment"]
["src/nvim/screen.c", ["          } else {", "            ++boguscols;", "            ++col;"], "readability/increment"]
["src/nvim/screen.c", ["            ++boguscols;", "            ++col;", "          }"], "readability/increment"]
["src/nvim/screen.c", ["        if (wp->w_p_rl) {", "          --boguscols;", "          --col;"], "readability/increment"]
["src/nvim/screen.c", ["          --boguscols;", "          --col;", "        } else {"], "readability/increment"]
["src/nvim/screen.c", ["        } else {", "          ++boguscols;", "          ++col;"], "readability/increment"]
["src/nvim/screen.c", ["          ++boguscols;", "          ++col;", "        }"], "readability/increment"]
["src/nvim/screen.c", ["      }", "", "    } else"], "whitespace/blank_line"]
["src/nvim/screen.c", ["", "    } else", "      --n_skip;"], "readability/braces"]
["src/nvim/screen.c", ["    } else", "      --n_skip;", ""], "readability/increment"]
["src/nvim/screen.c", ["", "    /* Only advance the \"vcol\" when after the 'number' or 'relativenumber'", "     * column. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["     * column. */", "    if (draw_state > WL_NR", "        && filler_todo <= 0"], "readability/braces"]
["src/nvim/screen.c", ["        )", "      ++vcol;", ""], "readability/increment"]
["src/nvim/screen.c", ["", "    if (vcol_save_attr >= 0)", "      char_attr = vcol_save_attr;"], "readability/braces"]
["src/nvim/screen.c", ["", "    /* restore attributes after \"predeces\" in 'listchars' */", "    if (draw_state > WL_NR && n_attr3 > 0 && --n_attr3 == 0)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    /* restore attributes after \"predeces\" in 'listchars' */", "    if (draw_state > WL_NR && n_attr3 > 0 && --n_attr3 == 0)", "      char_attr = saved_attr3;"], "readability/braces"]
["src/nvim/screen.c", ["", "    /* restore attributes after last 'listchars' or 'number' char */", "    if (n_attr > 0 && draw_state == WL_LINE && --n_attr == 0)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    /* restore attributes after last 'listchars' or 'number' char */", "    if (n_attr > 0 && draw_state == WL_LINE && --n_attr == 0)", "      char_attr = saved_attr2;"], "readability/braces"]
["src/nvim/screen.c", ["", "    /*", "     * At end of screen line and there is more to come: Display the line"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "      /* When not wrapping and finished diff lines, or when displayed", "       * '$' and highlighting until last column, break here. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["       * '$' and highlighting until last column, break here. */", "      if ((!wp->w_p_wrap", "           && filler_todo <= 0"], "readability/braces"]
["src/nvim/screen.c", ["           && filler_todo <= 0", "           ) || lcs_eol_one == -1)", "        break;"], "whitespace/parens"]
["src/nvim/screen.c", ["", "      /* When line got too long for screen break here. */", "      if (row == endrow) {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      if (row == endrow) {", "        ++row;", "        break;"], "readability/increment"]
["src/nvim/screen.c", ["", "      /* reset the drawing state for the start of a wrapped line */", "      draw_state = WL_START;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    }", "", "  }     /* for every character in the line */"], "whitespace/blank_line"]
["src/nvim/screen.c", ["", "  }     /* for every character in the line */", ""], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* After an empty line check first word for capital. */", "  if (*skipwhite(line) == NUL) {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  return row;", "}", ""], "readability/fn_size"]
["src/nvim/screen.c", ["", "/*", " * Check whether the given character needs redrawing:"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  if (rlflag) {", "    /* Clear rest first, because it's left of the text. */", "    if (clear_width > 0) {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["             ) {", "        ++off_to;", "        ++col;"], "readability/increment"]
["src/nvim/screen.c", ["        ++off_to;", "        ++col;", "      }"], "readability/increment"]
["src/nvim/screen.c", ["  if (clear_next) {", "    /* Clear the second half of a double-wide character of which the left", "     * half was overwritten with a single-wide character. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Mirror text \"str\" for right-left displaying."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  for (p1 = str, p2 = str + STRLEN(str) - 1; p1 < p2; ++p1, --p2) {", "    t = *p1;"], "readability/increment"]
["src/nvim/screen.c", ["", "/*", " * mark all status lines for redraw; used after first :cd"], "readability/old_style_comment"]
["src/nvim/screen.c", ["{", "", "  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {"], "whitespace/blank_line"]
["src/nvim/screen.c", ["", "/*", " * Redraw all status lines that need to be redrawn."], "readability/old_style_comment"]
["src/nvim/screen.c", ["  }", "  if (redraw_tabline)", "    draw_tabline();"], "readability/braces"]
["src/nvim/screen.c", ["", "/*", " * Redraw all status lines at the bottom of frame \"frp\"."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Draw the verticap separator right of window \"wp\" starting with line \"row\"."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Get the length of an item as it will be shown in the status line."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* Check for menu separators - replace with '|'. */", "  if (emenu && menu_is_separator(s))"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  /* Check for menu separators - replace with '|'. */", "  if (emenu && menu_is_separator(s))", "    return 1;"], "readability/braces"]
["src/nvim/screen.c", ["", "/*", " * Return the number of characters that should be skipped in a status match."], "readability/old_style_comment"]
["src/nvim/screen.c", ["#ifndef BACKSLASH_IN_FILENAME", "    if (xp->xp_shell && csh_like_shell() && s[1] == '\\\\' && s[2] == '!')", "      return 2;"], "readability/braces"]
["src/nvim/screen.c", ["", "/*", " * Show wildchar matches in the status line."], "readability/old_style_comment"]
["src/nvim/screen.c", ["void", "win_redr_status_matches (", "    expand_T *xp,"], "whitespace/parens"]
["src/nvim/screen.c", ["    int num_matches,", "    char_u **matches,          /* list of matches */", "    int match,"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int len;", "  int clen;                     /* length in screen cells */", "  int fillchar;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int i;", "  int highlight = TRUE;", "  char_u      *selstart = NULL;"], "readability/bool"]
["src/nvim/screen.c", ["  static int first_match = 0;", "  int add_left = FALSE;", "  char_u      *s;"], "readability/bool"]
["src/nvim/screen.c", ["", "  if (matches == NULL)          /* interrupted completion? */", "    return;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  if (matches == NULL)          /* interrupted completion? */", "    return;"], "readability/braces"]
["src/nvim/screen.c", ["", "  if (match == -1) {    /* don't show match but original text */", "    match = 0;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    match = 0;", "    highlight = FALSE;", "  }"], "readability/bool"]
["src/nvim/screen.c", ["  }", "  /* count 1 for the ending \">\" */", "  clen = status_match_len(xp, L_MATCH(match)) + 3;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  clen = status_match_len(xp, L_MATCH(match)) + 3;", "  if (match == 0)", "    first_match = 0;"], "readability/braces"]
["src/nvim/screen.c", ["    first_match = 0;", "  else if (match < first_match) {", "    /* jumping left, as far as we can go */"], "readability/braces"]
["src/nvim/screen.c", ["  else if (match < first_match) {", "    /* jumping left, as far as we can go */", "    first_match = match;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    first_match = match;", "    add_left = TRUE;", "  } else {"], "readability/bool"]
["src/nvim/screen.c", ["  } else {", "    /* check if match fits on the screen */", "    for (i = first_match; i < match; ++i)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    /* check if match fits on the screen */", "    for (i = first_match; i < match; ++i)", "      clen += status_match_len(xp, L_MATCH(i)) + 2;"], "readability/braces"]
["src/nvim/screen.c", ["    /* check if match fits on the screen */", "    for (i = first_match; i < match; ++i)", "      clen += status_match_len(xp, L_MATCH(i)) + 2;"], "readability/increment"]
["src/nvim/screen.c", ["      clen += status_match_len(xp, L_MATCH(i)) + 2;", "    if (first_match > 0)", "      clen += 2;"], "readability/braces"]
["src/nvim/screen.c", ["      first_match = match;", "      /* if showing the last match, we can add some on the left */", "      clen = 2;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      clen = 2;", "      for (i = match; i < num_matches; ++i) {", "        clen += status_match_len(xp, L_MATCH(i)) + 2;"], "readability/increment"]
["src/nvim/screen.c", ["      }", "      if (i == num_matches)", "        add_left = TRUE;"], "readability/braces"]
["src/nvim/screen.c", ["      if (i == num_matches)", "        add_left = TRUE;", "    }"], "readability/bool"]
["src/nvim/screen.c", ["  }", "  if (add_left)", "    while (first_match > 0) {"], "readability/braces"]
["src/nvim/screen.c", ["    s = L_MATCH(i);", "    /* Check for menu separators - replace with '|' */", "    emenu = (xp->xp_context == EXPAND_MENUS"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      clen += l;", "    } else", "      for (; *s != NUL; ++s) {"], "readability/braces"]
["src/nvim/screen.c", ["    } else", "      for (; *s != NUL; ++s) {", "        s += skip_status_match_char(xp, s);"], "readability/increment"]
["src/nvim/screen.c", ["      }", "    if (i == match)", "      selend = buf + len;"], "readability/braces"]
["src/nvim/screen.c", ["    clen += 2;", "    if (++i == num_matches)", "      break;"], "readability/braces"]
["src/nvim/screen.c", ["    *(buf + len++) = '>';", "    ++clen;", "  }"], "readability/increment"]
["src/nvim/screen.c", ["      if (msg_scrolled > 0) {", "        /* Put the wildmenu just above the command line.  If there is", "         * no room, scroll the screen one line up. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      } else {", "        /* Create status line if needed by setting 'laststatus' to 2.", "         * Set 'winminheight' to zero to avoid that the window is"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          p_wmh = 0;", "          last_status(FALSE);", "        }"], "readability/bool"]
["src/nvim/screen.c", ["  int this_ru_col;", "  static int busy = FALSE;", ""], "readability/bool"]
["src/nvim/screen.c", ["", "  wp->w_redr_status = FALSE;", "  if (wp->w_status_height == 0) {"], "readability/bool"]
["src/nvim/screen.c", ["  } else if (*p_stl != NUL || *wp->w_p_stl != NUL) {", "    /* redraw custom status line */", "    redraw_custom_statusline(wp);"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        *p = '<';", "        ++len;", "      }"], "readability/increment"]
["src/nvim/screen.c", ["", "    if (get_keymap_str(wp, (char_u *)\"<%s>\", NameBuff, MAXPATHL)", "        && this_ru_col - len > (int)(STRLEN(NameBuff) + 1))"], "readability/braces"]
["src/nvim/screen.c", ["", "    win_redr_ruler(wp, TRUE);", "  }"], "readability/bool"]
["src/nvim/screen.c", ["", "  /*", "   * May need to draw the character below the vertical separator."], "readability/old_style_comment"]
["src/nvim/screen.c", ["  }", "  busy = FALSE;", "}"], "readability/bool"]
["src/nvim/screen.c", ["", "/*", " * Redraw the status line according to 'statusline' and take care of any"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* When called recursively return.  This can happen when the statusline", "   * contains an expression that triggers a redraw. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["   * contains an expression that triggers a redraw. */", "  if (entered)", "    return;"], "readability/braces"]
["src/nvim/screen.c", ["    return;", "  entered = TRUE;", ""], "readability/bool"]
["src/nvim/screen.c", ["", "/*", " * Return TRUE if the status line of window \"wp\" is connected to the status"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    if (fr->fr_parent->fr_layout == FR_COL) {", "      if (fr->fr_next != NULL)", "        break;"], "readability/braces"]
["src/nvim/screen.c", ["    } else {", "      if (fr->fr_next != NULL)", "        return TRUE;"], "readability/braces"]
["src/nvim/screen.c", ["      if (fr->fr_next != NULL)", "        return TRUE;", "    }"], "readability/bool"]
["src/nvim/screen.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/screen.c", ["", "/*", " * Get the value to show for the language mappings, active 'keymap'."], "readability/old_style_comment"]
["src/nvim/screen.c", ["int", "get_keymap_str (", "    win_T *wp,"], "whitespace/parens"]
["src/nvim/screen.c", ["", "  if (wp->w_buffer->b_p_iminsert != B_IMODE_LMAP)", "    return FALSE;"], "readability/braces"]
["src/nvim/screen.c", ["  if (wp->w_buffer->b_p_iminsert != B_IMODE_LMAP)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/screen.c", ["    curwin = wp;", "    STRCPY(buf, \"b:keymap_name\");       /* must be writable */", "    ++emsg_skip;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    STRCPY(buf, \"b:keymap_name\");       /* must be writable */", "    ++emsg_skip;", "    s = p = eval_to_string(buf, NULL, FALSE);"], "readability/increment"]
["src/nvim/screen.c", ["    ++emsg_skip;", "    s = p = eval_to_string(buf, NULL, FALSE);", "    --emsg_skip;"], "readability/bool"]
["src/nvim/screen.c", ["    s = p = eval_to_string(buf, NULL, FALSE);", "    --emsg_skip;", "    curbuf = old_curbuf;"], "readability/increment"]
["src/nvim/screen.c", ["", "/*", " * Redraw the status line or ruler of window \"wp\"."], "readability/old_style_comment"]
["src/nvim/screen.c", ["static void", "win_redr_custom (", "    win_T *wp,"], "whitespace/parens"]
["src/nvim/screen.c", ["{", "  static int entered = FALSE;", "  int attr;"], "readability/bool"]
["src/nvim/screen.c", ["", "  /* There is a tiny chance that this gets called recursively: When", "   * redrawing a status line triggers redrawing the ruler or tabline."], "readability/old_style_comment"]
["src/nvim/screen.c", ["   * Avoid trouble by not allowing recursion. */", "  if (entered)", "    return;"], "readability/braces"]
["src/nvim/screen.c", ["    return;", "  entered = TRUE;", ""], "readability/bool"]
["src/nvim/screen.c", ["", "  /* setup environment for the task at hand */", "  if (wp == NULL) {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  if (wp == NULL) {", "    /* Use 'tabline'.  Always at the first line of the screen. */", "    stl = p_tal;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      stl = p_ruf;", "      /* advance past any leading group spec - implicit in ru_col */", "      if (*stl == '%') {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      if (*stl == '%') {", "        if (*++stl == '-')", "          stl++;"], "readability/braces"]
["src/nvim/screen.c", ["          stl++;", "        if (atoi((char *)stl))", "          while (ascii_isdigit(*stl))"], "readability/braces"]
["src/nvim/screen.c", ["        if (atoi((char *)stl))", "          while (ascii_isdigit(*stl))", "            stl++;"], "readability/braces"]
["src/nvim/screen.c", ["            stl++;", "        if (*stl++ != '(')", "          stl = p_ruf;"], "readability/braces"]
["src/nvim/screen.c", ["    } else {", "      if (*wp->w_p_stl != NUL)", "        stl = wp->w_p_stl;"], "readability/braces"]
["src/nvim/screen.c", ["        stl = wp->w_p_stl;", "      else", "        stl = p_stl;"], "readability/braces"]
["src/nvim/screen.c", ["", "  if (maxwidth <= 0)", "    goto theend;"], "readability/braces"]
["src/nvim/screen.c", ["", "  /* Temporarily reset 'cursorbind', we don't want a side effect from moving", "   * the cursor away and back. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  p_crb_save = ewp->w_p_crb;", "  ewp->w_p_crb = FALSE;", ""], "readability/bool"]
["src/nvim/screen.c", ["", "  /* Make a copy, because the statusline may include a function call that", "   * might change the option value and free the memory. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* fill up with \"fillchar\" */", "  while (width < maxwidth && len < (int)sizeof(buf) - 1) {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * Draw each snippet with the specified highlighting."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    if (hltab[n].userhl == 0)", "      curattr = attr;"], "readability/braces"]
["src/nvim/screen.c", ["      curattr = attr;", "    else if (hltab[n].userhl < 0)", "      curattr = syn_id2attr(-hltab[n].userhl);"], "readability/braces"]
["src/nvim/screen.c", ["      curattr = syn_id2attr(-hltab[n].userhl);", "    else if (wp != NULL && wp != curwin && wp->w_status_height != 0)", "      curattr = highlight_stlnc[hltab[n].userhl - 1];"], "readability/braces"]
["src/nvim/screen.c", ["      curattr = highlight_stlnc[hltab[n].userhl - 1];", "    else", "      curattr = highlight_user[hltab[n].userhl - 1];"], "readability/braces"]
["src/nvim/screen.c", ["    for (n = 0; tabtab[n].start != NULL; n++) {", "      len += vim_strnsize(p, (int)(tabtab[n].start - (char *) p));", "      while (col < len) {"], "whitespace/cast"]
["src/nvim/screen.c", ["      }", "      p = (char_u *) tabtab[n].start;", "      cur_click_def = tabtab[n].def;"], "whitespace/cast"]
["src/nvim/screen.c", ["theend:", "  entered = FALSE;", "}"], "readability/bool"]
["src/nvim/screen.c", ["  int u8cc[MAX_MCO];", "  int clear_next_cell = FALSE;", "  int prev_c = 0;                       /* previous Arabic character */"], "readability/bool"]
["src/nvim/screen.c", ["  int clear_next_cell = FALSE;", "  int prev_c = 0;                       /* previous Arabic character */", "  int pc, nc, nc1;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* When drawing over the right halve of a double-wide char clear out the", "   * left halve.  Only needed in a terminal. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Prepare for 'hlsearch' highlighting."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Clean up for 'hlsearch' highlighting."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Init for calling prepare_search_hl()."], "readability/old_style_comment"]
["src/nvim/screen.c", ["    cur->hl.rm = cur->match;", "    if (cur->hlg_id == 0)", "      cur->hl.attr = 0;"], "readability/braces"]
["src/nvim/screen.c", ["      cur->hl.attr = 0;", "    else", "      cur->hl.attr = syn_id2attr(cur->hlg_id);"], "readability/braces"]
["src/nvim/screen.c", ["", "/*", " * Advance to the match in window \"wp\" line \"lnum\" or past it."], "readability/old_style_comment"]
["src/nvim/screen.c", ["      }", "      bool pos_inprogress = true; // mark that a position match search is", "                                  // in progress"], "whitespace/comments"]
["src/nvim/screen.c", ["        } else {", "          ++shl->first_lnum;", "          n = 0;"], "readability/increment"]
["src/nvim/screen.c", ["    }", "    if (shl != &search_hl && cur != NULL)", "      cur = cur->next;"], "readability/braces"]
["src/nvim/screen.c", ["", "/*", " * Search for a next 'hlsearch' or match."], "readability/old_style_comment"]
["src/nvim/screen.c", ["static void", "next_search_hl (", "    win_T *win,"], "whitespace/parens"]
["src/nvim/screen.c", ["    win_T *win,", "    match_T *shl,               /* points to search_hl or a match */", "    linenr_T lnum,"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    linenr_T lnum,", "    colnr_T mincol,                /* minimal column for a match */", "    matchitem_T *cur               /* to retrieve match positions if any */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    colnr_T mincol,                /* minimal column for a match */", "    matchitem_T *cur               /* to retrieve match positions if any */", ")"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    l = shl->lnum + shl->rm.endpos[0].lnum - shl->rm.startpos[0].lnum;", "    if (lnum > l)", "      shl->lnum = 0;"], "readability/braces"]
["src/nvim/screen.c", ["      shl->lnum = 0;", "    else if (lnum < l || shl->rm.endpos[0].col > mincol)", "      return;"], "readability/braces"]
["src/nvim/screen.c", ["", "  /*", "   * Repeat searching for a match until one is found that includes \"mincol\""], "readability/old_style_comment"]
["src/nvim/screen.c", ["   */", "  called_emsg = FALSE;", "  for (;; ) {"], "readability/bool"]
["src/nvim/screen.c", ["    if (profile_passed_limit(shl->tm)) {", "      shl->lnum = 0;                    /* no match found in time */", "      break;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      matchcol = shl->rm.startpos[0].col;", "      ml = ml_get_buf(shl->buf, lnum, FALSE) + matchcol;", "      if (*ml == NUL) {"], "readability/bool"]
["src/nvim/screen.c", ["      if (*ml == NUL) {", "        ++matchcol;", "        shl->lnum = 0;"], "readability/increment"]
["src/nvim/screen.c", ["        shl->lnum = 0;", "        got_int = FALSE; // avoid the \"Type :quit to exit Vim\" message", "        break;"], "whitespace/comments"]
["src/nvim/screen.c", ["        shl->lnum = 0;", "        got_int = FALSE; // avoid the \"Type :quit to exit Vim\" message", "        break;"], "readability/bool"]
["src/nvim/screen.c", ["    linenr_T lnum,", "    posmatch_T *posmatch, // match positions", "    colnr_T mincol        // minimal column for a match"], "whitespace/comments"]
["src/nvim/screen.c", ["", "/*", " * Check if there should be a delay.  Used before clearing or redrawing the"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * Note that the window sizes are updated before reallocating the arrays,"], "readability/old_style_comment"]
["src/nvim/screen.c", ["   */", "  ++RedrawingDisabled;", ""], "readability/increment"]
["src/nvim/screen.c", ["", "  win_new_shellsize();      /* fit the windows in the new sized shell */", ""], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  comp_col();           /* recompute columns for shown command and ruler */", ""], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * Do not apply autocommands more than 3 times to avoid an endless loop"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  if (starting == 0 && ++retry_count <= 3) {", "    apply_autocmds(EVENT_VIMRESIZED, NULL, NULL, FALSE, curbuf);", "    /* In rare cases, autocommands may have altered Rows or Columns,"], "readability/bool"]
["src/nvim/screen.c", ["    apply_autocmds(EVENT_VIMRESIZED, NULL, NULL, FALSE, curbuf);", "    /* In rare cases, autocommands may have altered Rows or Columns,", "    * jump back to check if we need to allocate the screen again. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    }", "    memset(tpcd, 0, (size_t) tpcd_size * sizeof(tpcd[0]));", "  }"], "whitespace/cast"]
["src/nvim/screen.c", ["", "/*", " * Set cursor to its position in the current window."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * The rest of the routines in this file perform screen manipulations. The"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    if (!redrawing() || (char_avail() && !KeyTyped) || msg_silent != 0) {", "      redraw_cmdline = TRUE;                    /* show mode later */", "      return 0;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    if (!redrawing() || (char_avail() && !KeyTyped) || msg_silent != 0) {", "      redraw_cmdline = TRUE;                    /* show mode later */", "      return 0;"], "readability/bool"]
["src/nvim/screen.c", ["", "    /* wait a bit before overwriting an important message */", "    check_for_delay(FALSE);"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    /* wait a bit before overwriting an important message */", "    check_for_delay(FALSE);", ""], "readability/bool"]
["src/nvim/screen.c", ["", "    /* if the cmdline is more than one line high, erase top lines */", "    need_clear = clear_cmdline;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /* Position on the last line in the window, column 0 */", "    msg_pos_mode();"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        if (length > 0) {", "          if (edit_submode_pre != NULL)", "            length -= vim_strsize(edit_submode_pre);"], "readability/braces"]
["src/nvim/screen.c", ["          MSG_PUTS_ATTR(_(\" TERMINAL\"), attr);", "        } else if (State & VREPLACE_FLAG)", "          MSG_PUTS_ATTR(_(\" VREPLACE\"), attr);"], "readability/braces"]
["src/nvim/screen.c", ["          MSG_PUTS_ATTR(_(\" VREPLACE\"), attr);", "        else if (State & REPLACE_FLAG)", "          MSG_PUTS_ATTR(_(\" REPLACE\"), attr);"], "readability/braces"]
["src/nvim/screen.c", ["          MSG_PUTS_ATTR(_(\" REPLACE\"), attr);", "        else if (State & INSERT) {", "          if (p_ri)"], "readability/braces"]
["src/nvim/screen.c", ["        else if (State & INSERT) {", "          if (p_ri)", "            MSG_PUTS_ATTR(_(\" REVERSE\"), attr);"], "readability/braces"]
["src/nvim/screen.c", ["        }", "        if ((State & INSERT) && p_paste)", "          MSG_PUTS_ATTR(_(\" (paste)\"), attr);"], "readability/braces"]
["src/nvim/screen.c", ["", "          /* Don't concatenate separate words to avoid translation", "           * problems. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "      need_clear = TRUE;", "    }"], "readability/bool"]
["src/nvim/screen.c", ["", "    mode_displayed = TRUE;", "    if (need_clear || clear_cmdline)"], "readability/bool"]
["src/nvim/screen.c", ["    mode_displayed = TRUE;", "    if (need_clear || clear_cmdline)", "      msg_clr_eos();"], "readability/braces"]
["src/nvim/screen.c", ["      msg_clr_eos();", "    msg_didout = FALSE;                 /* overwrite this message */", "    length = msg_col;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      msg_clr_eos();", "    msg_didout = FALSE;                 /* overwrite this message */", "    length = msg_col;"], "readability/bool"]
["src/nvim/screen.c", ["", "  /* In Visual mode the size of the selected area must be redrawn. */", "  if (VIsual_active)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  /* In Visual mode the size of the selected area must be redrawn. */", "  if (VIsual_active)", "    clear_showcmd();"], "readability/braces"]
["src/nvim/screen.c", ["", "/*", " * Position for a mode message."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Draw the tab pages line at the top of the Vim window."], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int use_sep_chars = (t_colors < 8", "                       );", ""], "whitespace/parens"]
["src/nvim/screen.c", ["", "  if (tabline_height() < 1)", "    return;"], "readability/braces"]
["src/nvim/screen.c", ["", "  /* Use the 'tabline' option if it's set. */", "  if (*p_tal != NUL) {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    FOR_ALL_TABS(tp) {", "      ++tabcount;", "    }"], "readability/increment"]
["src/nvim/screen.c", ["      if (room > 0) {", "        /* Get buffer name in NameBuff[] */", "        get_trans_bufname(cwp->w_buffer);"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    if (use_sep_chars)", "      c = '_';"], "readability/braces"]
["src/nvim/screen.c", ["      c = '_';", "    else", "      c = ' ';"], "readability/braces"]
["src/nvim/screen.c", ["", "    /* Put an \"X\" for closing the current tab if there are several. */", "    if (first_tabpage->tp_next != NULL) {"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* Reset the flag here again, in case evaluating 'tabline' causes it to be", "   * set. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["   * set. */", "  redraw_tabline = FALSE;", "}"], "readability/bool"]
["src/nvim/screen.c", ["", "/*", " * Get buffer name for \"buf\" into NameBuff[]."], "readability/old_style_comment"]
["src/nvim/screen.c", ["{", "  if (buf_spname(buf) != NULL)", "    STRLCPY(NameBuff, buf_spname(buf), MAXPATHL);"], "readability/braces"]
["src/nvim/screen.c", ["    STRLCPY(NameBuff, buf_spname(buf), MAXPATHL);", "  else", "    home_replace(buf, buf->b_fname, NameBuff, MAXPATHL, TRUE);"], "readability/braces"]
["src/nvim/screen.c", ["  else", "    home_replace(buf, buf->b_fname, NameBuff, MAXPATHL, TRUE);", "  trans_characters(NameBuff, MAXPATHL);"], "readability/bool"]
["src/nvim/screen.c", ["", "/*", " * Get the character to use in a status line.  Get its attributes in \"*attr\"."], "readability/old_style_comment"]
["src/nvim/screen.c", ["  }", "  /* Use fill when there is highlighting, and highlighting of current", "   * window differs, or the fillchars differ, or this is not the"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Get the character to use in a separator between vertically split windows."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Return TRUE if redrawing should currently be done."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Return TRUE if printing messages should currently be done."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Show current status info in ruler and various other places"], "readability/old_style_comment"]
["src/nvim/screen.c", ["{", "  if (!always && !redrawing())", "    return;"], "readability/braces"]
["src/nvim/screen.c", ["", "  if (need_maketitle", "      || (p_icon && (stl_syntax & STL_IN_ICON))"], "readability/braces"]
["src/nvim/screen.c", ["    maketitle();", "  /* Redraw the tab pages line if needed. */", "  if (redraw_tabline)"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  /* Redraw the tab pages line if needed. */", "  if (redraw_tabline)", "    draw_tabline();"], "readability/braces"]
["src/nvim/screen.c", ["", "  /*", "   * Check if cursor.lnum is valid, since win_redr_ruler() may be called"], "readability/old_style_comment"]
["src/nvim/screen.c", ["   */", "  if (wp->w_cursor.lnum > wp->w_buffer->b_ml.ml_line_count)", "    return;"], "readability/braces"]
["src/nvim/screen.c", ["", "  /*", "   * Check if not in Insert mode and the line is empty (will show \"0-1\")."], "readability/old_style_comment"]
["src/nvim/screen.c", ["   */", "  int empty_line = FALSE;", "  if (!(State & INSERT)"], "readability/bool"]
["src/nvim/screen.c", ["  int empty_line = FALSE;", "  if (!(State & INSERT)", "      && *ml_get_buf(wp->w_buffer, wp->w_cursor.lnum, FALSE) == NUL)"], "readability/braces"]
["src/nvim/screen.c", ["  if (!(State & INSERT)", "      && *ml_get_buf(wp->w_buffer, wp->w_cursor.lnum, FALSE) == NUL)", "    empty_line = TRUE;"], "readability/bool"]
["src/nvim/screen.c", ["      && *ml_get_buf(wp->w_buffer, wp->w_cursor.lnum, FALSE) == NUL)", "    empty_line = TRUE;", ""], "readability/bool"]
["src/nvim/screen.c", ["", "  /*", "   * Only draw the ruler when something changed."], "readability/old_style_comment"]
["src/nvim/screen.c", ["  if (       redraw_cmdline", "             || always", "             || wp->w_cursor.lnum != wp->w_ru_cursor.lnum"], "whitespace/alignment"]
["src/nvim/screen.c", ["             || always", "             || wp->w_cursor.lnum != wp->w_ru_cursor.lnum", "             || wp->w_cursor.col != wp->w_ru_cursor.col"], "whitespace/alignment"]
["src/nvim/screen.c", ["             || wp->w_cursor.lnum != wp->w_ru_cursor.lnum", "             || wp->w_cursor.col != wp->w_ru_cursor.col", "             || wp->w_virtcol != wp->w_ru_virtcol"], "whitespace/alignment"]
["src/nvim/screen.c", ["             || wp->w_cursor.col != wp->w_ru_cursor.col", "             || wp->w_virtcol != wp->w_ru_virtcol", "             || wp->w_cursor.coladd != wp->w_ru_cursor.coladd"], "whitespace/alignment"]
["src/nvim/screen.c", ["             || wp->w_virtcol != wp->w_ru_virtcol", "             || wp->w_cursor.coladd != wp->w_ru_cursor.coladd", "             || wp->w_topline != wp->w_ru_topline"], "whitespace/alignment"]
["src/nvim/screen.c", ["             || wp->w_cursor.coladd != wp->w_ru_cursor.coladd", "             || wp->w_topline != wp->w_ru_topline", "             || wp->w_buffer->b_ml.ml_line_count != wp->w_ru_line_count"], "whitespace/alignment"]
["src/nvim/screen.c", ["             || wp->w_topline != wp->w_ru_topline", "             || wp->w_buffer->b_ml.ml_line_count != wp->w_ru_line_count", "             || wp->w_topfill != wp->w_ru_topfill"], "whitespace/alignment"]
["src/nvim/screen.c", ["             || wp->w_buffer->b_ml.ml_line_count != wp->w_ru_line_count", "             || wp->w_topfill != wp->w_ru_topfill", "             || empty_line != wp->w_ru_empty) {"], "whitespace/alignment"]
["src/nvim/screen.c", ["             || wp->w_topfill != wp->w_ru_topfill", "             || empty_line != wp->w_ru_empty) {", ""], "whitespace/alignment"]
["src/nvim/screen.c", ["             || empty_line != wp->w_ru_empty) {", "", "    int width;"], "whitespace/blank_line"]
["src/nvim/screen.c", ["", "    /*", "     * Some sprintfs return the length, some return a pointer."], "readability/old_style_comment"]
["src/nvim/screen.c", ["    vim_snprintf((char *)buffer, RULER_BUF_LEN, \"%\" PRId64 \",\",", "        (wp->w_buffer->b_ml.ml_flags & ML_EMPTY) ? (int64_t)0L", "                                                 : (int64_t)wp->w_cursor.lnum);"], "whitespace/alignment"]
["src/nvim/screen.c", ["        (wp->w_buffer->b_ml.ml_flags & ML_EMPTY) ? (int64_t)0L", "                                                 : (int64_t)wp->w_cursor.lnum);", "    size_t len = STRLEN(buffer);"], "whitespace/alignment"]
["src/nvim/screen.c", ["    col_print(buffer + len, RULER_BUF_LEN - len,", "        empty_line ? 0 : (int)wp->w_cursor.col + 1,", "        (int)virtcol + 1);"], "whitespace/alignment"]
["src/nvim/screen.c", ["        empty_line ? 0 : (int)wp->w_cursor.col + 1,", "        (int)virtcol + 1);", ""], "whitespace/alignment"]
["src/nvim/screen.c", ["", "    /*", "     * Add a \"50%\" if there is room for it."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Return the width of the 'number' and 'relativenumber' column."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  if (lnum == wp->w_nrwidth_line_count)", "    return wp->w_nrwidth_width;"], "readability/braces"]
["src/nvim/screen.c", ["    lnum /= 10;", "    ++n;", "  } while (lnum > 0);"], "readability/increment"]
["src/nvim/screen.c", ["{", "  static int busy = FALSE;", ""], "readability/bool"]
["src/nvim/screen.c", ["", "  if (width < 0 || height < 0)      /* just checking... */", "    return;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  if (width < 0 || height < 0)      /* just checking... */", "    return;"], "readability/braces"]
["src/nvim/screen.c", ["  if (State == HITRETURN || State == SETWSIZE) {", "    /* postpone the resizing */", "    State = SETWSIZE;"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* curwin->w_buffer can be NULL when we are closing a window and the", "   * buffer has already been closed and removing a scrollbar causes a resize"], "readability/old_style_comment"]
["src/nvim/screen.c", ["   */", "  if (curwin->w_buffer == NULL)", "    return;"], "readability/braces"]
["src/nvim/screen.c", ["", "  ++busy;", ""], "readability/increment"]
["src/nvim/screen.c", ["", "  /* The window layout used to be adjusted here, but it now happens in", "   * screenalloc() (also invoked from screenclear()).  That is because the"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /*", "     * We only redraw when it's needed:"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    } else {", "      if (curwin->w_p_scb)", "        do_check_scrollbind(TRUE);"], "readability/braces"]
["src/nvim/screen.c", ["      if (curwin->w_p_scb)", "        do_check_scrollbind(TRUE);", "      if (State & CMDLINE) {"], "readability/bool"]
