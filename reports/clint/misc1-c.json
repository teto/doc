["src/nvim/misc1.c", ["", "/*", " * misc1.c: functions that didn't seem to fit elsewhere"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "/*", " * get_leader_len() returns the length in bytes of the prefix of the given"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["  int result;", "  int got_com = FALSE;", "  int found_one;"], "readability/bool"]
["src/nvim/misc1.c", ["  int found_one;", "  char_u part_buf[COM_MAX_LEN];         /* buffer for one option part */", "  char_u      *string;                  /* pointer to comment string */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["  char_u part_buf[COM_MAX_LEN];         /* buffer for one option part */", "  char_u      *string;                  /* pointer to comment string */", "  char_u      *list;"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["  result = i = 0;", "  while (ascii_iswhite(line[i]))      /* leading white space is ignored */", "    ++i;"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["  result = i = 0;", "  while (ascii_iswhite(line[i]))      /* leading white space is ignored */", "    ++i;"], "readability/braces"]
["src/nvim/misc1.c", ["  while (ascii_iswhite(line[i]))      /* leading white space is ignored */", "    ++i;", ""], "readability/increment"]
["src/nvim/misc1.c", ["", "  /*", "   * Repeat to match several nested comment strings."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["  while (line[i] != NUL) {", "    /*", "     * scan through the 'comments' option for a match"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["     */", "    found_one = FALSE;", "    for (list = curbuf->b_p_com; *list; ) {"], "readability/bool"]
["src/nvim/misc1.c", ["    for (list = curbuf->b_p_com; *list; ) {", "      /* Get one option part into part_buf[].  Advance \"list\" to next", "       * one.  Put \"string\" at start of string.  */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["       * one.  Put \"string\" at start of string.  */", "      if (!got_com && flags != NULL)", "        *flags = list;              /* remember where flags started */"], "readability/braces"]
["src/nvim/misc1.c", ["      if (!got_com && flags != NULL)", "        *flags = list;              /* remember where flags started */", "      prev_list = list;"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["      string = vim_strchr(part_buf, ':');", "      if (string == NULL)           /* missing ':', ignore this part */", "        continue;"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["      string = vim_strchr(part_buf, ':');", "      if (string == NULL)           /* missing ':', ignore this part */", "        continue;"], "readability/braces"]
["src/nvim/misc1.c", ["        continue;", "      *string++ = NUL;              /* isolate flags from string */", ""], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "      /* If we found a middle match previously, use that match when this", "       * is not a middle or end. */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["       * is not a middle or end. */", "      if (middle_match_len != 0", "          && vim_strchr(part_buf, COM_MIDDLE) == NULL"], "readability/braces"]
["src/nvim/misc1.c", ["", "      /* When we already found a nested comment, only accept further", "       * nested comments. */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["       * nested comments. */", "      if (got_com && vim_strchr(part_buf, COM_NEST) == NULL)", "        continue;"], "readability/braces"]
["src/nvim/misc1.c", ["", "      /* When 'O' flag present and using \"O\" command skip this one. */", "      if (backward && vim_strchr(part_buf, COM_NOBACK) != NULL)"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["      /* When 'O' flag present and using \"O\" command skip this one. */", "      if (backward && vim_strchr(part_buf, COM_NOBACK) != NULL)", "        continue;"], "readability/braces"]
["src/nvim/misc1.c", ["", "      /* Line contents and string must match.", "       * When string starts with white space, must have some white space"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["      if (ascii_iswhite(string[0])) {", "        if (i == 0 || !ascii_iswhite(line[i - 1]))", "          continue;            /* missing white space */"], "readability/braces"]
["src/nvim/misc1.c", ["        if (i == 0 || !ascii_iswhite(line[i - 1]))", "          continue;            /* missing white space */", "        while (ascii_iswhite(string[0]))"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["          continue;            /* missing white space */", "        while (ascii_iswhite(string[0]))", "          ++string;"], "readability/braces"]
["src/nvim/misc1.c", ["        while (ascii_iswhite(string[0]))", "          ++string;", "      }"], "readability/increment"]
["src/nvim/misc1.c", ["      }", "      for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)", "        ;"], "readability/braces"]
["src/nvim/misc1.c", ["      }", "      for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)", "        ;"], "readability/increment"]
["src/nvim/misc1.c", ["      for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)", "        ;", "      if (string[j] != NUL)"], "whitespace/semicolon"]
["src/nvim/misc1.c", ["        ;", "      if (string[j] != NUL)", "        continue;          /* string doesn't match */"], "readability/braces"]
["src/nvim/misc1.c", ["      if (string[j] != NUL)", "        continue;          /* string doesn't match */", ""], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "      /* When 'b' flag used, there must be white space or an", "       * end-of-line after the string in the line. */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["       * end-of-line after the string in the line. */", "      if (vim_strchr(part_buf, COM_BLANK) != NULL", "          && !ascii_iswhite(line[i + j]) && line[i + j] != NUL)"], "readability/braces"]
["src/nvim/misc1.c", ["", "      /* We have found a match, stop searching unless this is a middle", "       * comment. The middle comment can be a substring of the end"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["      }", "      if (middle_match_len != 0 && j > middle_match_len)", "        /* Use this match instead of the middle match, since it's a"], "readability/braces"]
["src/nvim/misc1.c", ["      if (middle_match_len != 0 && j > middle_match_len)", "        /* Use this match instead of the middle match, since it's a", "         * longer thus better match. */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "      if (middle_match_len == 0)", "        i += j;"], "readability/braces"]
["src/nvim/misc1.c", ["        i += j;", "      found_one = TRUE;", "      break;"], "readability/bool"]
["src/nvim/misc1.c", ["    if (middle_match_len != 0) {", "      /* Use the previously found middle match after failing to find a", "       * match with an end. */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["       * match with an end. */", "      if (!got_com && flags != NULL)", "        *flags = saved_flags;"], "readability/braces"]
["src/nvim/misc1.c", ["      i += middle_match_len;", "      found_one = TRUE;", "    }"], "readability/bool"]
["src/nvim/misc1.c", ["", "    /* No match found, stop scanning. */", "    if (!found_one)"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["    /* No match found, stop scanning. */", "    if (!found_one)", "      break;"], "readability/braces"]
["src/nvim/misc1.c", ["", "    /* Include any trailing white space. */", "    while (ascii_iswhite(line[i]))"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["    /* Include any trailing white space. */", "    while (ascii_iswhite(line[i]))", "      ++i;"], "readability/braces"]
["src/nvim/misc1.c", ["    while (ascii_iswhite(line[i]))", "      ++i;", ""], "readability/increment"]
["src/nvim/misc1.c", ["", "    if (include_space)", "      result = i;"], "readability/braces"]
["src/nvim/misc1.c", ["", "    /* If this comment doesn't nest, stop here. */", "    got_com = TRUE;"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["    /* If this comment doesn't nest, stop here. */", "    got_com = TRUE;", "    if (vim_strchr(part_buf, COM_NEST) == NULL)"], "readability/bool"]
["src/nvim/misc1.c", ["    got_com = TRUE;", "    if (vim_strchr(part_buf, COM_NEST) == NULL)", "      break;"], "readability/braces"]
["src/nvim/misc1.c", ["", "/*", " * Return the offset at which the last comment in line starts. If there is no"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["  int found_one;", "  char_u part_buf[COM_MAX_LEN];         /* buffer for one option part */", ""], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "  /*", "   * Repeat to match several nested comment strings."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["  while (--i >= lower_check_bound) {", "    /*", "     * scan through the 'comments' option for a match"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["     */", "    found_one = FALSE;", "    for (list = curbuf->b_p_com; *list; ) {"], "readability/bool"]
["src/nvim/misc1.c", ["", "      /*", "       * Get one option part into part_buf[].  Advance list to next one."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["      string = vim_strchr(part_buf, ':');", "      if (string == NULL) {     /* If everything is fine, this cannot actually", "                                 * happen. */"], "readability/multiline_comment"]
["src/nvim/misc1.c", ["      string = vim_strchr(part_buf, ':');", "      if (string == NULL) {     /* If everything is fine, this cannot actually", "                                 * happen. */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["      }", "      *string++ = NUL;          /* Isolate flags from string. */", "      com_leader = string;"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "      /*", "       * Line contents and string must match."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["      if (ascii_iswhite(string[0])) {", "        if (i == 0 || !ascii_iswhite(line[i - 1]))", "          continue;"], "readability/braces"]
["src/nvim/misc1.c", ["      }", "      for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)", "        /* do nothing */;"], "readability/braces"]
["src/nvim/misc1.c", ["      }", "      for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)", "        /* do nothing */;"], "readability/increment"]
["src/nvim/misc1.c", ["      for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)", "        /* do nothing */;", "      if (string[j] != NUL)"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["      for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)", "        /* do nothing */;", "      if (string[j] != NUL)"], "whitespace/semicolon"]
["src/nvim/misc1.c", ["        /* do nothing */;", "      if (string[j] != NUL)", "        continue;"], "readability/braces"]
["src/nvim/misc1.c", ["", "      /*", "       * When 'b' flag used, there must be white space or an"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "      /*", "       * We have found a match, stop searching."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["       */", "      found_one = TRUE;", ""], "readability/bool"]
["src/nvim/misc1.c", ["", "      if (flags)", "        *flags = flags_save;"], "readability/braces"]
["src/nvim/misc1.c", ["    if (found_one) {", "      char_u part_buf2[COM_MAX_LEN];            /* buffer for one option part */", "      int len1, len2, off;"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["      result = i;", "      /*", "       * If this comment nests, continue searching."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["       */", "      if (vim_strchr(part_buf, COM_NEST) != NULL)", "        continue;"], "readability/braces"]
["src/nvim/misc1.c", ["", "      /* Let's verify whether the comment leader found is a substring", "       * of other comment leaders. If it is, let's adjust the"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "      while (ascii_iswhite(*com_leader))", "        ++com_leader;"], "readability/braces"]
["src/nvim/misc1.c", ["      while (ascii_iswhite(*com_leader))", "        ++com_leader;", "      len1 = (int)STRLEN(com_leader);"], "readability/increment"]
["src/nvim/misc1.c", ["        (void)copy_option_part(&list, part_buf2, COM_MAX_LEN, \",\");", "        if (flags_save == com_flags)", "          continue;"], "readability/braces"]
["src/nvim/misc1.c", ["        string = vim_strchr(part_buf2, ':');", "        ++string;", "        while (ascii_iswhite(*string))"], "readability/increment"]
["src/nvim/misc1.c", ["        ++string;", "        while (ascii_iswhite(*string))", "          ++string;"], "readability/braces"]
["src/nvim/misc1.c", ["        while (ascii_iswhite(*string))", "          ++string;", "        len2 = (int)STRLEN(string);"], "readability/increment"]
["src/nvim/misc1.c", ["        len2 = (int)STRLEN(string);", "        if (len2 == 0)", "          continue;"], "readability/braces"]
["src/nvim/misc1.c", ["", "        /* Now we have to verify whether string ends with a substring", "         * beginning the com_leader. */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["        for (off = (len2 > i ? i : len2); off > 0 && off + len1 > len2; ) {", "          --off;", "          if (!STRNCMP(string + off, com_leader, len2 - off)) {"], "readability/increment"]
["src/nvim/misc1.c", ["          if (!STRNCMP(string + off, com_leader, len2 - off)) {", "            if (i - off < lower_check_bound)", "              lower_check_bound = i - off;"], "readability/braces"]
["src/nvim/misc1.c", ["", "/*", " * Return the number of window lines occupied by buffer line \"lnum\"."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["{", "  /* Check for filler lines above this buffer line.  When folded the result", "   * is one line anyway. */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "/*", " * Return number of window lines physical line \"lnum\" will occupy in window"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "  s = ml_get_buf(wp->w_buffer, lnum, FALSE);", "  if (*s == NUL)                /* empty line */"], "readability/bool"]
["src/nvim/misc1.c", ["  s = ml_get_buf(wp->w_buffer, lnum, FALSE);", "  if (*s == NUL)                /* empty line */", "    return 1;"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["  s = ml_get_buf(wp->w_buffer, lnum, FALSE);", "  if (*s == NUL)                /* empty line */", "    return 1;"], "readability/braces"]
["src/nvim/misc1.c", ["", "  /*", "   * Add column offset for 'number', 'relativenumber' and 'foldcolumn'."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "/*", " * Like plines_win(), but only reports the number of physical screen lines"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "  if (!wp->w_p_wrap)", "    return lines + 1;"], "readability/braces"]
["src/nvim/misc1.c", ["  lines += 1;", "  if (col > width)", "    lines += (col - width) / (width + win_col_off2(wp)) + 1;"], "readability/braces"]
["src/nvim/misc1.c", ["", "/*", " * check_status: called when the status bars for the buffer 'buf'"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["    if (wp->w_buffer == buf && wp->w_status_height) {", "      wp->w_redr_status = TRUE;", "      if (must_redraw < VALID) {"], "readability/bool"]
["src/nvim/misc1.c", ["", "/*", " * Return TRUE if \"c\" is a mouse key."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "/*", " * Get a key stroke directly from the user."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["    ui_flush();", "    /* Leave some room for check_termcode() to insert a key code into (max", "     * 5 chars plus NUL).  And fix_input_buffer() can triple the number of"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "    /* First time: blocking wait.  Second time: wait up to 100ms for a", "     * terminal code to complete. */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["      waited = 0;", "    } else if (len > 0)", "      ++waited;             /* keep track of the waiting time */"], "readability/braces"]
["src/nvim/misc1.c", ["    } else if (len > 0)", "      ++waited;             /* keep track of the waiting time */", ""], "readability/old_style_comment"]
["src/nvim/misc1.c", ["    } else if (len > 0)", "      ++waited;             /* keep track of the waiting time */", ""], "readability/increment"]
["src/nvim/misc1.c", ["", "    /* Handle modifier and/or special key code. */", "    n = buf[0];"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["          ) {", "        if (buf[1] == KS_MODIFIER)", "          mod_mask = buf[2];"], "readability/braces"]
["src/nvim/misc1.c", ["        len -= 3;", "        if (len > 0)", "          memmove(buf, buf + 3, (size_t)len);"], "readability/braces"]
["src/nvim/misc1.c", ["", "/*", " * Get a number from the user."], "readability/old_style_comment"]
["src/nvim/misc1.c", [" */", "int ", "get_number ("], "whitespace/end_of_line"]
["src/nvim/misc1.c", ["int ", "get_number (", "    int colon,                              /* allow colon to abort */"], "whitespace/parens"]
["src/nvim/misc1.c", ["get_number (", "    int colon,                              /* allow colon to abort */", "    int *mouse_used"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "  if (mouse_used != NULL)", "    *mouse_used = FALSE;"], "readability/braces"]
["src/nvim/misc1.c", ["  if (mouse_used != NULL)", "    *mouse_used = FALSE;", ""], "readability/bool"]
["src/nvim/misc1.c", ["", "  /* When not printing messages, the user won't know what to type, return a", "   * zero (as if CR was hit). */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["   * zero (as if CR was hit). */", "  if (msg_silent != 0)", "    return 0;"], "readability/braces"]
["src/nvim/misc1.c", ["      msg_putchar(c);", "      ++typed;", "    } else if (c == K_DEL || c == K_KDEL || c == K_BS || c == Ctrl_H) {"], "readability/increment"]
["src/nvim/misc1.c", ["        MSG_PUTS(\"\\b \\b\");", "        --typed;", "      }"], "readability/increment"]
["src/nvim/misc1.c", ["    } else if (mouse_used != NULL && c == K_LEFTMOUSE) {", "      *mouse_used = TRUE;", "      n = mouse_row + 1;"], "readability/bool"]
["src/nvim/misc1.c", ["      stuffcharReadbuff(':');", "      if (!exmode_active)", "        cmdline_row = msg_row;"], "readability/braces"]
["src/nvim/misc1.c", ["        cmdline_row = msg_row;", "      skip_redraw = TRUE;           /* skip redraw once */", "      do_redraw = FALSE;"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["        cmdline_row = msg_row;", "      skip_redraw = TRUE;           /* skip redraw once */", "      do_redraw = FALSE;"], "readability/bool"]
["src/nvim/misc1.c", ["      skip_redraw = TRUE;           /* skip redraw once */", "      do_redraw = FALSE;", "      break;"], "readability/bool"]
["src/nvim/misc1.c", ["      break;", "    } else if (c == CAR || c == NL || c == Ctrl_C || c == ESC)", "      break;"], "readability/braces"]
["src/nvim/misc1.c", ["", "/*", " * Ask the user to enter a number."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "  /* When using \":silent\" assume that <CR> was entered. */", "  if (mouse_used != NULL)"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["  /* When using \":silent\" assume that <CR> was entered. */", "  if (mouse_used != NULL)", "    MSG_PUTS(_(\"Type number and <Enter> or click with mouse (empty cancels): \"));"], "readability/braces"]
["src/nvim/misc1.c", ["  if (mouse_used != NULL)", "    MSG_PUTS(_(\"Type number and <Enter> or click with mouse (empty cancels): \"));", "  else"], "whitespace/line_length"]
["src/nvim/misc1.c", ["    MSG_PUTS(_(\"Type number and <Enter> or click with mouse (empty cancels): \"));", "  else", "    MSG_PUTS(_(\"Type number and <Enter> (empty cancels): \"));"], "readability/braces"]
["src/nvim/misc1.c", ["", "  /* Set the state such that text can be selected/copied/pasted and we still", "   * get mouse events. */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "  i = get_number(TRUE, mouse_used);", "  if (KeyTyped) {"], "readability/bool"]
["src/nvim/misc1.c", ["", "  if (global_busy           /* no messages now, wait until global is finished */", "      || !messaging())        /* 'lazyredraw' set, don't do messages now */"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "  if (global_busy           /* no messages now, wait until global is finished */", "      || !messaging())        /* 'lazyredraw' set, don't do messages now */"], "readability/braces"]
["src/nvim/misc1.c", ["  if (global_busy           /* no messages now, wait until global is finished */", "      || !messaging())        /* 'lazyredraw' set, don't do messages now */", "    return;"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "  /* We don't want to overwrite another important message, but do overwrite", "   * a previous \"more lines\" or \"fewer lines\" message, so that \"5dd\" and"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["   * then \"put\" reports the last action. */", "  if (keep_msg != NULL && !keep_msg_more)", "    return;"], "readability/braces"]
["src/nvim/misc1.c", ["", "  if (n > 0)", "    pn = n;"], "readability/braces"]
["src/nvim/misc1.c", ["    pn = n;", "  else", "    pn = -n;"], "readability/braces"]
["src/nvim/misc1.c", ["    if (pn == 1) {", "      if (n > 0)", "        STRLCPY(msg_buf, _(\"1 more line\"), MSG_BUF_LEN);"], "readability/braces"]
["src/nvim/misc1.c", ["        STRLCPY(msg_buf, _(\"1 more line\"), MSG_BUF_LEN);", "      else", "        STRLCPY(msg_buf, _(\"1 line less\"), MSG_BUF_LEN);"], "readability/braces"]
["src/nvim/misc1.c", ["    } else {", "      if (n > 0)", "        vim_snprintf((char *)msg_buf, MSG_BUF_LEN,"], "readability/braces"]
["src/nvim/misc1.c", ["        vim_snprintf((char *)msg_buf, MSG_BUF_LEN,", "            _(\"%\" PRId64 \" more lines\"), (int64_t)pn);", "      else"], "whitespace/alignment"]
["src/nvim/misc1.c", ["            _(\"%\" PRId64 \" more lines\"), (int64_t)pn);", "      else", "        vim_snprintf((char *)msg_buf, MSG_BUF_LEN,"], "readability/braces"]
["src/nvim/misc1.c", ["        vim_snprintf((char *)msg_buf, MSG_BUF_LEN,", "            _(\"%\" PRId64 \" fewer lines\"), (int64_t)pn);", "    }"], "whitespace/alignment"]
["src/nvim/misc1.c", ["      set_keep_msg(msg_buf, 0);", "      keep_msg_more = TRUE;", "    }"], "readability/bool"]
["src/nvim/misc1.c", ["", "/*", " * flush map and typeahead buffers and give a warning for an error"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "/*", " * Find all user names for user completion."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["{", "  static int lazy_init_done = FALSE;", ""], "readability/bool"]
["src/nvim/misc1.c", ["", "  lazy_init_done = TRUE;", "  "], "readability/bool"]
["src/nvim/misc1.c", ["  lazy_init_done = TRUE;", "  ", "  os_get_usernames(&ga_users);"], "whitespace/end_of_line"]
["src/nvim/misc1.c", ["", "/*", " * Function given to ExpandGeneric() to obtain an user names."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["  init_users();", "  if (idx < ga_users.ga_len)", "    return ((char_u **)ga_users.ga_data)[idx];"], "readability/braces"]
["src/nvim/misc1.c", ["", "/*", " * Check whether name matches a user name. Return:"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["  for (int i = 0; i < ga_users.ga_len; i++) {", "    if (STRCMP(((char_u **)ga_users.ga_data)[i], name) == 0)", "      return 2;       /* full match */"], "readability/braces"]
["src/nvim/misc1.c", ["    if (STRCMP(((char_u **)ga_users.ga_data)[i], name) == 0)", "      return 2;       /* full match */", "    if (STRNCMP(((char_u **)ga_users.ga_data)[i], name, n) == 0)"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["      return 2;       /* full match */", "    if (STRNCMP(((char_u **)ga_users.ga_data)[i], name, n) == 0)", "      result = 1;       /* partial match */"], "readability/braces"]
["src/nvim/misc1.c", ["    if (STRNCMP(((char_u **)ga_users.ga_data)[i], name, n) == 0)", "      result = 1;       /* partial match */", "  }"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "/*", " * Check for CTRL-C pressed, but only once in a while."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "/*", " * Like line_breakcheck() but check 10 times less often."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "  /*", "   * Call the shell to execute the command (errors are ignored)."], "readability/old_style_comment"]
["src/nvim/misc1.c", ["   */", "  ++no_check_timestamps;", "  call_shell(command, kShellOptDoOut | kShellOptExpand | flags, NULL);"], "readability/increment"]
["src/nvim/misc1.c", ["  call_shell(command, kShellOptDoOut | kShellOptExpand | flags, NULL);", "  --no_check_timestamps;", ""], "readability/increment"]
["src/nvim/misc1.c", ["  } else if (ret_len == NULL) {", "    /* Change NUL into SOH, otherwise the string is truncated. */", "    for (i = 0; i < len; ++i)"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["    /* Change NUL into SOH, otherwise the string is truncated. */", "    for (i = 0; i < len; ++i)", "      if (buffer[i] == NUL)"], "readability/braces"]
["src/nvim/misc1.c", ["    /* Change NUL into SOH, otherwise the string is truncated. */", "    for (i = 0; i < len; ++i)", "      if (buffer[i] == NUL)"], "readability/increment"]
["src/nvim/misc1.c", ["    for (i = 0; i < len; ++i)", "      if (buffer[i] == NUL)", "        buffer[i] = 1;"], "readability/braces"]
["src/nvim/misc1.c", ["", "    buffer[len] = NUL;          /* make sure the buffer is terminated */", "  } else {"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["", "/*", " * Free the list of files returned by expand_wildcards() or other expansion"], "readability/old_style_comment"]
["src/nvim/misc1.c", ["{", "  if (count <= 0 || files == NULL)", "    return;"], "readability/braces"]
["src/nvim/misc1.c", ["    return;", "  while (count--)", "    xfree(files[count]);"], "readability/braces"]
["src/nvim/misc1.c", ["", "/*", " * Return TRUE when need to go to Insert mode because of 'insertmode'."], "readability/old_style_comment"]
