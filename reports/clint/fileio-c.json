["src/nvim/fileio.c", ["", "#define BUFSIZE         8192    /* size of normal write buffer */", "#define SMBUFSIZE       256     /* size of emergency write buffer */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#define BUFSIZE         8192    /* size of normal write buffer */", "#define SMBUFSIZE       256     /* size of emergency write buffer */", ""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#define HAS_BW_FLAGS", "#define FIO_LATIN1     0x01    /* convert Latin1 */", "#define FIO_UTF8       0x02    /* convert UTF-8 */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#define FIO_LATIN1     0x01    /* convert Latin1 */", "#define FIO_UTF8       0x02    /* convert UTF-8 */", "#define FIO_UCS2       0x04    /* convert UCS-2 */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#define FIO_UTF8       0x02    /* convert UTF-8 */", "#define FIO_UCS2       0x04    /* convert UCS-2 */", "#define FIO_UCS4       0x08    /* convert UCS-4 */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#define FIO_UCS2       0x04    /* convert UCS-2 */", "#define FIO_UCS4       0x08    /* convert UCS-4 */", "#define FIO_UTF16      0x10    /* convert UTF-16 */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#define FIO_UCS4       0x08    /* convert UCS-4 */", "#define FIO_UTF16      0x10    /* convert UTF-16 */", "#define FIO_ENDIAN_L   0x80    /* little endian */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#define FIO_UTF16      0x10    /* convert UTF-16 */", "#define FIO_ENDIAN_L   0x80    /* little endian */", "#define FIO_NOCONVERT  0x2000  /* skip encoding conversion */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#define FIO_ENDIAN_L   0x80    /* little endian */", "#define FIO_NOCONVERT  0x2000  /* skip encoding conversion */", "#define FIO_UCSBOM     0x4000  /* check for BOM at start of file */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#define FIO_NOCONVERT  0x2000  /* skip encoding conversion */", "#define FIO_UCSBOM     0x4000  /* check for BOM at start of file */", "#define FIO_ALL        -1      /* allow all formats */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#define FIO_UCSBOM     0x4000  /* check for BOM at start of file */", "#define FIO_ALL        -1      /* allow all formats */", ""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/* When converting, a read() or write() may leave some bytes to be converted", " * for the next call.  The value is guessed... */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/* We have to guess how much a sequence of bytes may expand when converting", " * with iconv() to be able to allocate a buffer. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/*", " * Structure to pass arguments from buf_write() to buf_write_bytes()."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  msg_scroll_save = msg_scroll;", "  if (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0)", "    msg_scroll = FALSE;"], "readability/braces"]
["src/nvim/fileio.c", ["  if (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0)", "    msg_scroll = FALSE;", "  if (!msg_scroll)      /* wait a bit when overwriting an error msg */"], "readability/bool"]
["src/nvim/fileio.c", ["    msg_scroll = FALSE;", "  if (!msg_scroll)      /* wait a bit when overwriting an error msg */", "    check_for_delay(FALSE);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    msg_scroll = FALSE;", "  if (!msg_scroll)      /* wait a bit when overwriting an error msg */", "    check_for_delay(FALSE);"], "readability/braces"]
["src/nvim/fileio.c", ["  if (!msg_scroll)      /* wait a bit when overwriting an error msg */", "    check_for_delay(FALSE);", "  msg_start();"], "readability/bool"]
["src/nvim/fileio.c", ["  msg_scroll = msg_scroll_save;", "  msg_scrolled_ign = TRUE;", "  /* may truncate the message to avoid a hit-return prompt */"], "readability/bool"]
["src/nvim/fileio.c", ["  msg_scrolled_ign = TRUE;", "  /* may truncate the message to avoid a hit-return prompt */", "  msg_outtrans_attr(msg_may_trunc(FALSE, IObuff), attr);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  /* may truncate the message to avoid a hit-return prompt */", "  msg_outtrans_attr(msg_may_trunc(FALSE, IObuff), attr);", "  msg_clr_eos();"], "readability/bool"]
["src/nvim/fileio.c", ["  ui_flush();", "  msg_scrolled_ign = FALSE;", "}"], "readability/bool"]
["src/nvim/fileio.c", ["", "/*", " * Read lines from file \"fname\" into the buffer after line \"from\"."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["                    || (eap != NULL && eap->read_edit);", "  linenr_T read_buf_lnum = 1;           /* next line to read from curbuf */", "  colnr_T read_buf_col = 0;             /* next char to read from this line */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  linenr_T read_buf_lnum = 1;           /* next line to read from curbuf */", "  colnr_T read_buf_col = 0;             /* next char to read from this line */", "  char_u c;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  linenr_T lnum = from;", "  char_u      *ptr = NULL;              /* pointer into read buffer */", "  char_u      *buffer = NULL;           /* read buffer */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  char_u      *ptr = NULL;              /* pointer into read buffer */", "  char_u      *buffer = NULL;           /* read buffer */", "  char_u      *new_buffer = NULL;       /* init to shut up gcc */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  char_u      *buffer = NULL;           /* read buffer */", "  char_u      *new_buffer = NULL;       /* init to shut up gcc */", "  char_u      *line_start = NULL;       /* init to shut up gcc */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  char_u      *new_buffer = NULL;       /* init to shut up gcc */", "  char_u      *line_start = NULL;       /* init to shut up gcc */", "  int wasempty;                         /* buffer was empty before reading */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  char_u      *line_start = NULL;       /* init to shut up gcc */", "  int wasempty;                         /* buffer was empty before reading */", "  colnr_T len;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  linenr_T linecnt;", "  int error = FALSE;                    /* errors encountered */", "  int ff_error = EOL_UNKNOWN;           /* file format with errors */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  linenr_T linecnt;", "  int error = FALSE;                    /* errors encountered */", "  int ff_error = EOL_UNKNOWN;           /* file format with errors */"], "readability/bool"]
["src/nvim/fileio.c", ["  int error = FALSE;                    /* errors encountered */", "  int ff_error = EOL_UNKNOWN;           /* file format with errors */", "  long linerest = 0;                    /* remaining chars in line */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  int ff_error = EOL_UNKNOWN;           /* file format with errors */", "  long linerest = 0;                    /* remaining chars in line */", "  int perm = 0;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#ifdef UNIX", "  int swap_mode = -1;                   /* protection bits for swap file */", "#endif"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  int bad_char_behavior = BAD_REPLACE;", "  /* BAD_KEEP, BAD_DROP or character to", "   * replace with */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["   * replace with */", "  char_u      *tmpname = NULL;          /* name of 'charconvert' output file */", "  int fio_flags = 0;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["# endif", "  int converted = FALSE;                /* TRUE if conversion done */", "  int notconverted = FALSE;             /* TRUE if conversion wanted but it"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["# endif", "  int converted = FALSE;                /* TRUE if conversion done */", "  int notconverted = FALSE;             /* TRUE if conversion wanted but it"], "readability/bool"]
["src/nvim/fileio.c", ["  int converted = FALSE;                /* TRUE if conversion done */", "  int notconverted = FALSE;             /* TRUE if conversion wanted but it", "                                           wasn't possible */"], "readability/multiline_comment"]
["src/nvim/fileio.c", ["  int converted = FALSE;                /* TRUE if conversion done */", "  int notconverted = FALSE;             /* TRUE if conversion wanted but it", "                                           wasn't possible */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  int converted = FALSE;                /* TRUE if conversion done */", "  int notconverted = FALSE;             /* TRUE if conversion wanted but it", "                                           wasn't possible */"], "readability/bool"]
["src/nvim/fileio.c", ["  char_u conv_rest[CONV_RESTLEN];", "  int conv_restlen = 0;                 /* nr of bytes in conv_rest[] */", "  buf_T       *old_curbuf;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  curbuf->b_no_eol_lnum = 0;    /* in case it was set by the previous read */", ""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * If there is no file name yet, use the one for the read file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      && !(flags & READ_DUMMY)) {", "    if (set_rw_fname(fname, sfname) == FAIL)", "      return FAIL;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /* Remember the initial values of curbuf, curbuf->b_ffname and", "   * curbuf->b_fname to detect whether they are altered as a result of"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* After reading a file the cursor line changes but we don't want to", "   * display the line. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["   * display the line. */", "  ex_no_reprint = TRUE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  /* don't display the file info for another buffer now */", "  need_fileinfo = FALSE;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  /* don't display the file info for another buffer now */", "  need_fileinfo = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * The BufReadCmd and FileReadCmd events intercept the reading process by"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /* Set '[ mark to the line above where the lines go (line 1 if zero). */", "    curbuf->b_op_start.lnum = ((from == 0) ? 1 : from);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  if ((shortmess(SHM_OVER) || curbuf->b_help) && p_verbose == 0)", "    msg_scroll = FALSE;         /* overwrite previous file message */"], "readability/braces"]
["src/nvim/fileio.c", ["  if ((shortmess(SHM_OVER) || curbuf->b_help) && p_verbose == 0)", "    msg_scroll = FALSE;         /* overwrite previous file message */", "  else"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if ((shortmess(SHM_OVER) || curbuf->b_help) && p_verbose == 0)", "    msg_scroll = FALSE;         /* overwrite previous file message */", "  else"], "readability/bool"]
["src/nvim/fileio.c", ["    msg_scroll = FALSE;         /* overwrite previous file message */", "  else", "    msg_scroll = TRUE;          /* don't overwrite previous file message */"], "readability/braces"]
["src/nvim/fileio.c", ["  else", "    msg_scroll = TRUE;          /* don't overwrite previous file message */", ""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  else", "    msg_scroll = TRUE;          /* don't overwrite previous file message */", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  /* Set default or forced 'fileformat' and 'binary'. */", "  set_file_options(set_options, eap);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * When opening a new file we take the readonly flag from the file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  check_readonly = (newfile && (curbuf->b_flags & BF_CHECK_RO));", "  if (check_readonly && !readonlymode)", "    curbuf->b_p_ro = FALSE;"], "readability/braces"]
["src/nvim/fileio.c", ["  if (check_readonly && !readonlymode)", "    curbuf->b_p_ro = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["#ifdef UNIX", "      /*", "       * Use the protection bits of the original file for the swap file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /* Reset the \"new file\" flag.  It will be set again below when the", "     * file doesn't exist. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "      /* Create a swap file now, so that other Vims are warned", "       * that we are editing this file.  Don't do this for a"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        check_need_swap(newfile);", "        /* SwapExists autocommand may mess things up */", "        if (curbuf != old_curbuf"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "      if (aborting())               /* autocmds may abort script processing */", "        return FAIL;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "      if (aborting())               /* autocmds may abort script processing */", "        return FAIL;"], "readability/braces"]
["src/nvim/fileio.c", ["        return FAIL;", "      return OK;                  /* a new file is not an error */", "    } else {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      filemess(curbuf, sfname, (char_u *)(", "            (fd == UV_EFBIG) ? _(\"[File too big]\") :", "# if defined(UNIX) && defined(EOVERFLOW)"], "whitespace/indent"]
["src/nvim/fileio.c", ["            // set EOVERFLOW", "            (fd == -EOVERFLOW) ? _(\"[File too big]\") :", "# endif"], "whitespace/indent"]
["src/nvim/fileio.c", ["# endif", "            _(\"[Permission Denied]\")), 0);", "      curbuf->b_p_ro = TRUE;                  /* must use \"w!\" now */"], "whitespace/indent"]
["src/nvim/fileio.c", ["            _(\"[Permission Denied]\")), 0);", "      curbuf->b_p_ro = TRUE;                  /* must use \"w!\" now */", "    }"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            _(\"[Permission Denied]\")), 0);", "      curbuf->b_p_ro = TRUE;                  /* must use \"w!\" now */", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * Only set the 'ro' flag for readonly files the first time they are"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["   */", "  if ((check_readonly && file_readonly) || curbuf->b_help)", "    curbuf->b_p_ro = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["  if ((check_readonly && file_readonly) || curbuf->b_help)", "    curbuf->b_p_ro = TRUE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["  if (set_options) {", "    /* Don't change 'eol' if reading from buffer as it will already be", "     * correctly set when reading stdin. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (!read_buffer) {", "      curbuf->b_p_eol = TRUE;", "      curbuf->b_start_eol = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["      curbuf->b_p_eol = TRUE;", "      curbuf->b_start_eol = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["    }", "    curbuf->b_p_bomb = FALSE;", "    curbuf->b_start_bomb = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    curbuf->b_p_bomb = FALSE;", "    curbuf->b_start_bomb = FALSE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /* Create a swap file now, so that other Vims are warned that we are", "   * editing this file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (swap_exists_action == SEA_QUIT) {", "    if (!read_buffer && !read_stdin)", "      close(fd);"], "readability/braces"]
["src/nvim/fileio.c", ["", "  ++no_wait_return;         /* don't wait for return yet */", ""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  ++no_wait_return;         /* don't wait for return yet */", ""], "readability/increment"]
["src/nvim/fileio.c", ["", "  /*", "   * Set '[ mark to the line above where the lines go (line 1 if zero)."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    if (aborting()) {       /* autocmds may abort script processing */", "      --no_wait_return;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (aborting()) {       /* autocmds may abort script processing */", "      --no_wait_return;", "      msg_scroll = msg_save;"], "readability/increment"]
["src/nvim/fileio.c", ["      msg_scroll = msg_save;", "      curbuf->b_p_ro = TRUE;            /* must use \"w!\" now */", "      return FAIL;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      msg_scroll = msg_save;", "      curbuf->b_p_ro = TRUE;            /* must use \"w!\" now */", "      return FAIL;"], "readability/bool"]
["src/nvim/fileio.c", ["    }", "    /*", "     * Don't allow the autocommands to change the current buffer."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (!read_stdin && (curbuf != old_curbuf", "                        || (using_b_ffname && (old_b_ffname != curbuf->b_ffname))", "                        || (using_b_fname && (old_b_fname != curbuf->b_fname))"], "whitespace/line_length"]
["src/nvim/fileio.c", ["                        || (fd = os_open((char *)fname, O_RDONLY, 0)) < 0)) {", "      --no_wait_return;", "      msg_scroll = msg_save;"], "readability/increment"]
["src/nvim/fileio.c", ["      msg_scroll = msg_save;", "      if (fd < 0)", "        EMSG(_(\"E200: *ReadPre autocommands made the file unreadable\"));"], "readability/braces"]
["src/nvim/fileio.c", ["        EMSG(_(\"E200: *ReadPre autocommands made the file unreadable\"));", "      else", "        EMSG(_(\"E201: *ReadPre autocommands must not change current buffer\"));"], "readability/braces"]
["src/nvim/fileio.c", ["        EMSG(_(\"E201: *ReadPre autocommands must not change current buffer\"));", "      curbuf->b_p_ro = TRUE;            /* must use \"w!\" now */", "      return FAIL;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        EMSG(_(\"E201: *ReadPre autocommands must not change current buffer\"));", "      curbuf->b_p_ro = TRUE;            /* must use \"w!\" now */", "      return FAIL;"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /* Autocommands may add lines to the file, need to check if it is empty */", "  wasempty = (curbuf->b_ml.ml_flags & ML_EMPTY);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  msg_scroll = FALSE;                   /* overwrite the file message */", ""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  msg_scroll = FALSE;                   /* overwrite the file message */", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * Set linecnt now, before the \"retry\" caused by a wrong guess for"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* \"++bad=\" argument. */", "  if (eap != NULL && eap->bad_char != 0) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    bad_char_behavior = eap->bad_char;", "    if (set_options)", "      curbuf->b_bad_char = eap->bad_char;"], "readability/braces"]
["src/nvim/fileio.c", ["      curbuf->b_bad_char = eap->bad_char;", "  } else", "    curbuf->b_bad_char = 0;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /*", "   * Decide which 'encoding' to use or use first."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Jump back here to retry reading the file in different ways."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (set_options) {", "      curbuf->b_p_bomb = FALSE;", "      curbuf->b_start_bomb = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["      curbuf->b_p_bomb = FALSE;", "      curbuf->b_start_bomb = FALSE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * When retrying with another \"fenc\" and the first time \"fileformat\""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      fileformat = get_fileformat_force(curbuf, eap);", "      try_unix = try_dos = try_mac = FALSE;", "    } else if (curbuf->b_p_bin)"], "readability/bool"]
["src/nvim/fileio.c", ["      try_unix = try_dos = try_mac = FALSE;", "    } else if (curbuf->b_p_bin)", "      fileformat = EOL_UNIX;                    /* binary: use Unix format */"], "readability/braces"]
["src/nvim/fileio.c", ["    } else if (curbuf->b_p_bin)", "      fileformat = EOL_UNIX;                    /* binary: use Unix format */", "    else if (*p_ffs == NUL)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      fileformat = EOL_UNIX;                    /* binary: use Unix format */", "    else if (*p_ffs == NUL)", "      fileformat = get_fileformat(curbuf);      /* use format from buffer */"], "readability/braces"]
["src/nvim/fileio.c", ["    else if (*p_ffs == NUL)", "      fileformat = get_fileformat(curbuf);      /* use format from buffer */", "    else"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      fileformat = get_fileformat(curbuf);      /* use format from buffer */", "    else", "      fileformat = EOL_UNKNOWN;                 /* detect from file */"], "readability/braces"]
["src/nvim/fileio.c", ["    else", "      fileformat = EOL_UNKNOWN;                 /* detect from file */", "  }"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (iconv_fd != (iconv_t)-1) {", "    /* aborted conversion with iconv(), close the descriptor */", "    iconv_close(iconv_fd);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (advance_fenc) {", "    /*", "     * Try the next entry in 'fileencodings'."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (eap != NULL && eap->force_enc != 0) {", "      /* Conversion given with \"++cc=\" wasn't possible, read", "       * without conversion. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["       * without conversion. */", "      notconverted = TRUE;", "      conv_error = 0;"], "readability/bool"]
["src/nvim/fileio.c", ["      conv_error = 0;", "      if (fenc_alloced)", "        xfree(fenc);"], "readability/braces"]
["src/nvim/fileio.c", ["    } else {", "      if (fenc_alloced)", "        xfree(fenc);"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /*", "   * Conversion may be required when the encoding of the file is different"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (converted) {", "", "    /* \"ucs-bom\" means we need to check the first bytes of the file"], "whitespace/blank_line"]
["src/nvim/fileio.c", ["", "    /* \"ucs-bom\" means we need to check the first bytes of the file", "     * for a BOM. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * Use the 'charconvert' expression when conversion is required"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#  endif", "      /* Skip conversion when it's already done (retry for wrong", "       * \"fileformat\"). */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          if (fd < 0) {", "            /* Re-opening the original file failed! */", "            EMSG(_(\"E202: Conversion made file unreadable!\"));"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            EMSG(_(\"E202: Conversion made file unreadable!\"));", "            error = TRUE;", "            goto failed;"], "readability/bool"]
["src/nvim/fileio.c", ["          ) {", "        /* Conversion wanted but we can't.", "         * Try the next conversion in 'fileencodings' */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* Set \"can_retry\" when it's possible to rewind the file and try with", "   * another \"fenc\" value.  It's FALSE when no other \"fenc\" to try, reading"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["                      && !read_buffer);", "    if (read_undo_file)", "      sha256_start(&sha_ctx);"], "readability/braces"]
["src/nvim/fileio.c", ["  while (!error && !got_int) {", "    /*", "     * We allocate as much space for the file as we can get, plus"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (new_buffer == NULL) {", "          error = TRUE;", "          break;"], "readability/bool"]
["src/nvim/fileio.c", ["        }", "        if (linerest)           /* copy characters from the previous buffer */", "          memmove(new_buffer, ptr - linerest, (size_t)linerest);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        }", "        if (linerest)           /* copy characters from the previous buffer */", "          memmove(new_buffer, ptr - linerest, (size_t)linerest);"], "readability/braces"]
["src/nvim/fileio.c", ["", "        /* May need room to translate into.", "         * For iconv() we don't really know the required space, use a"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (read_buffer) {", "          /*", "           * Read bytes from curbuf.  Used for converting text read"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["           */", "          if (read_buf_lnum > from)", "            size = 0;"], "readability/braces"]
["src/nvim/fileio.c", ["            size = 0;", "          else {", "            int n, ni;"], "readability/braces"]
["src/nvim/fileio.c", ["            size = 0;", "          else {", "            int n, ni;"], "readability/braces"]
["src/nvim/fileio.c", ["              if ((int)tlen + n + 1 > size) {", "                /* Filled up to \"size\", append partial line.", "                 * Change NL to NUL to reverse the effect done"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["                n = (int)(size - tlen);", "                for (ni = 0; ni < n; ++ni) {", "                  if (p[ni] == NL)"], "readability/increment"]
["src/nvim/fileio.c", ["                for (ni = 0; ni < n; ++ni) {", "                  if (p[ni] == NL)", "                    ptr[tlen++] = NUL;"], "readability/braces"]
["src/nvim/fileio.c", ["                    ptr[tlen++] = NUL;", "                  else", "                    ptr[tlen++] = p[ni];"], "readability/braces"]
["src/nvim/fileio.c", ["              } else {", "                /* Append whole line and new-line.  Change NL", "                * to NUL to reverse the effect done below. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["                * to NUL to reverse the effect done below. */", "                for (ni = 0; ni < n; ++ni) {", "                  if (p[ni] == NL)"], "readability/increment"]
["src/nvim/fileio.c", ["                for (ni = 0; ni < n; ++ni) {", "                  if (p[ni] == NL)", "                    ptr[tlen++] = NUL;"], "readability/braces"]
["src/nvim/fileio.c", ["                    ptr[tlen++] = NUL;", "                  else", "                    ptr[tlen++] = p[ni];"], "readability/braces"]
["src/nvim/fileio.c", ["                if (++read_buf_lnum > from) {", "                  /* When the last line didn't have an", "                   * end-of-line don't add it now either. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["                   * end-of-line don't add it now either. */", "                  if (!curbuf->b_p_eol)", "                    --tlen;"], "readability/braces"]
["src/nvim/fileio.c", ["                  if (!curbuf->b_p_eol)", "                    --tlen;", "                  size = tlen;"], "readability/increment"]
["src/nvim/fileio.c", ["        } else {", "          /*", "           * Read bytes from the file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (size <= 0) {", "          if (size < 0)                             /* read error */", "            error = TRUE;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (size <= 0) {", "          if (size < 0)                             /* read error */", "            error = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["          if (size < 0)                             /* read error */", "            error = TRUE;", "          else if (conv_restlen > 0) {"], "readability/bool"]
["src/nvim/fileio.c", ["            error = TRUE;", "          else if (conv_restlen > 0) {", "            /*"], "readability/braces"]
["src/nvim/fileio.c", ["          else if (conv_restlen > 0) {", "            /*", "             * Reached end-of-file but some trailing bytes could"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "            /* When we did a conversion report an error. */", "            if (fio_flags != 0"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["                ) {", "              if (can_retry)", "                goto rewind_retry;"], "readability/braces"]
["src/nvim/fileio.c", ["                goto rewind_retry;", "              if (conv_error == 0)", "                conv_error = curbuf->b_ml.ml_line_count"], "readability/braces"]
["src/nvim/fileio.c", ["            }", "            /* Remember the first linenr with an illegal byte */", "            else if (illegal_byte == 0)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            /* Remember the first linenr with an illegal byte */", "            else if (illegal_byte == 0)", "              illegal_byte = curbuf->b_ml.ml_line_count"], "whitespace/newline"]
["src/nvim/fileio.c", ["            } else {", "              /* Replace the trailing bytes with the replacement", "               * character if we were converting; if we weren't,"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["# endif", "                                                    )) {", "                while (conv_restlen > 0) {"], "whitespace/parens"]
["src/nvim/fileio.c", ["                  *(--ptr) = bad_char_behavior;", "                  --conv_restlen;", "                }"], "readability/increment"]
["src/nvim/fileio.c", ["", "      skip_read = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "      /*", "       * At start of file: Check for BOM."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "        /* no BOM detection in a short file or in binary mode */", "        if (size < 2 || curbuf->b_p_bin)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        /* no BOM detection in a short file or in binary mode */", "        if (size < 2 || curbuf->b_p_bin)", "          ccname = NULL;"], "readability/braces"]
["src/nvim/fileio.c", ["          ccname = NULL;", "        else", "          ccname = check_for_bom(ptr, size, &blen,"], "readability/braces"]
["src/nvim/fileio.c", ["          ccname = check_for_bom(ptr, size, &blen,", "              fio_flags == FIO_UCSBOM ? FIO_ALL : get_fio_flags(fenc));", "        if (ccname != NULL) {"], "whitespace/alignment"]
["src/nvim/fileio.c", ["        if (ccname != NULL) {", "          /* Remove BOM from the text */", "          filesize += blen;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          if (set_options) {", "            curbuf->b_p_bomb = TRUE;", "            curbuf->b_start_bomb = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["            curbuf->b_p_bomb = TRUE;", "            curbuf->b_start_bomb = TRUE;", "          }"], "readability/bool"]
["src/nvim/fileio.c", ["          } else {", "            /* BOM detected: set \"fenc\" and jump back */", "            if (fenc_alloced)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            /* BOM detected: set \"fenc\" and jump back */", "            if (fenc_alloced)", "              xfree(fenc);"], "readability/braces"]
["src/nvim/fileio.c", ["          }", "          /* retry reading without getting new bytes or rewinding */", "          skip_read = TRUE;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          /* retry reading without getting new bytes or rewinding */", "          skip_read = TRUE;", "          goto retry;"], "readability/bool"]
["src/nvim/fileio.c", ["", "      /* Include not converted bytes. */", "      ptr -= conv_restlen;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      conv_restlen = 0;", "      /*", "       * Break here for a read error or end-of-file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["       */", "      if (size <= 0)", "        break;"], "readability/braces"]
["src/nvim/fileio.c", ["      if (iconv_fd != (iconv_t)-1) {", "        /*", "         * Attempt conversion of the read bytes to 'encoding' using"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "        /*", "         * If there is conversion error or not enough room try using"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        while ((iconv(iconv_fd, (void *)&fromp, &from_size,", "                    &top, &to_size)", "                == (size_t)-1 && ICONV_ERRNO != ICONV_EINVAL)"], "whitespace/alignment"]
["src/nvim/fileio.c", ["               || from_size > CONV_RESTLEN) {", "          if (can_retry)", "            goto rewind_retry;"], "readability/braces"]
["src/nvim/fileio.c", ["            goto rewind_retry;", "          if (conv_error == 0)", "            conv_error = readfile_linenr(linecnt,"], "readability/braces"]
["src/nvim/fileio.c", ["            conv_error = readfile_linenr(linecnt,", "                ptr, (char_u *)top);", ""], "whitespace/alignment"]
["src/nvim/fileio.c", ["", "          /* Deal with a bad byte and continue with the next. */", "          ++fromp;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          /* Deal with a bad byte and continue with the next. */", "          ++fromp;", "          --from_size;"], "readability/increment"]
["src/nvim/fileio.c", ["          ++fromp;", "          --from_size;", "          if (bad_char_behavior == BAD_KEEP) {"], "readability/increment"]
["src/nvim/fileio.c", ["            *top++ = *(fromp - 1);", "            --to_size;", "          } else if (bad_char_behavior != BAD_DROP) {"], "readability/increment"]
["src/nvim/fileio.c", ["            *top++ = bad_char_behavior;", "            --to_size;", "          }"], "readability/increment"]
["src/nvim/fileio.c", ["        if (from_size > 0) {", "          /* Some remaining characters, keep them for the next", "           * round. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "        /* move the linerest to before the converted characters */", "        line_start = ptr - linerest;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          if (fio_flags == FIO_UTF8) {", "            /* Check for a trailing incomplete UTF-8 sequence */", "            tail = ptr + size - 1;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            tail = ptr + size - 1;", "            while (tail > ptr && (*tail & 0xc0) == 0x80)", "              --tail;"], "readability/braces"]
["src/nvim/fileio.c", ["            while (tail > ptr && (*tail & 0xc0) == 0x80)", "              --tail;", "            if (tail + utf_byte2len(*tail) <= ptr + size)"], "readability/increment"]
["src/nvim/fileio.c", ["              --tail;", "            if (tail + utf_byte2len(*tail) <= ptr + size)", "              tail = NULL;"], "readability/braces"]
["src/nvim/fileio.c", ["              tail = NULL;", "            else", "              p = tail;"], "readability/braces"]
["src/nvim/fileio.c", ["        } else if (fio_flags & (FIO_UCS2 | FIO_UTF16)) {", "          /* Check for a trailing byte */", "          p = ptr + (size & ~1);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          p = ptr + (size & ~1);", "          if (size & 1)", "            tail = p;"], "readability/braces"]
["src/nvim/fileio.c", ["          if ((fio_flags & FIO_UTF16) && p > ptr) {", "            /* Check for a trailing leading word */", "            if (fio_flags & FIO_ENDIAN_L) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            }", "            if (u8c >= 0xd800 && u8c <= 0xdbff)", "              tail = p;"], "readability/braces"]
["src/nvim/fileio.c", ["              tail = p;", "            else", "              p += 2;"], "readability/braces"]
["src/nvim/fileio.c", ["          }", "        } else {   /*  FIO_UCS4 */", "                     /* Check for trailing 1, 2 or 3 bytes */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        } else {   /*  FIO_UCS4 */", "                     /* Check for trailing 1, 2 or 3 bytes */", "          p = ptr + (size & ~3);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          p = ptr + (size & ~3);", "          if (size & 3)", "            tail = p;"], "readability/braces"]
["src/nvim/fileio.c", ["", "        /* If there is a trailing incomplete sequence move it to", "         * conv_rest[]. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        while (p > ptr) {", "          if (fio_flags & FIO_LATIN1)", "            u8c = *--p;"], "readability/braces"]
["src/nvim/fileio.c", ["            u8c = *--p;", "          else if (fio_flags & (FIO_UCS2 | FIO_UTF16)) {", "            if (fio_flags & FIO_ENDIAN_L) {"], "readability/braces"]
["src/nvim/fileio.c", ["              if (p == ptr) {", "                /* Missing leading word. */", "                if (can_retry)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["                /* Missing leading word. */", "                if (can_retry)", "                  goto rewind_retry;"], "readability/braces"]
["src/nvim/fileio.c", ["                  goto rewind_retry;", "                if (conv_error == 0)", "                  conv_error = readfile_linenr(linecnt,"], "readability/braces"]
["src/nvim/fileio.c", ["                  conv_error = readfile_linenr(linecnt,", "                      ptr, p);", "                if (bad_char_behavior == BAD_DROP)"], "whitespace/alignment"]
["src/nvim/fileio.c", ["                      ptr, p);", "                if (bad_char_behavior == BAD_DROP)", "                  continue;"], "readability/braces"]
["src/nvim/fileio.c", ["                  continue;", "                if (bad_char_behavior != BAD_KEEP)", "                  u8c = bad_char_behavior;"], "readability/braces"]
["src/nvim/fileio.c", ["", "              /* found second word of double-word, get the first", "               * word and compute the resulting character */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "              /* Check if the word is indeed a leading word. */", "              if (u16c < 0xd800 || u16c > 0xdbff) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["              if (u16c < 0xd800 || u16c > 0xdbff) {", "                if (can_retry)", "                  goto rewind_retry;"], "readability/braces"]
["src/nvim/fileio.c", ["                  goto rewind_retry;", "                if (conv_error == 0)", "                  conv_error = readfile_linenr(linecnt,"], "readability/braces"]
["src/nvim/fileio.c", ["                  conv_error = readfile_linenr(linecnt,", "                      ptr, p);", "                if (bad_char_behavior == BAD_DROP)"], "whitespace/alignment"]
["src/nvim/fileio.c", ["                      ptr, p);", "                if (bad_char_behavior == BAD_DROP)", "                  continue;"], "readability/braces"]
["src/nvim/fileio.c", ["                  continue;", "                if (bad_char_behavior != BAD_KEEP)", "                  u8c = bad_char_behavior;"], "readability/braces"]
["src/nvim/fileio.c", ["              u8c += *--p;", "            } else {          /* big endian */", "              u8c = *--p;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            }", "          } else {        /* UTF-8 */", "            if (*--p < 0x80)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          } else {        /* UTF-8 */", "            if (*--p < 0x80)", "              u8c = *p;"], "readability/braces"]
["src/nvim/fileio.c", ["              u8c = *p;", "            else {", "              len = utf_head_off(ptr, p);"], "readability/braces"]
["src/nvim/fileio.c", ["              u8c = *p;", "            else {", "              len = utf_head_off(ptr, p);"], "readability/braces"]
["src/nvim/fileio.c", ["              if (len == 0) {", "                /* Not a valid UTF-8 character, retry with", "                 * another fenc when possible, otherwise just"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["                 * report the error. */", "                if (can_retry)", "                  goto rewind_retry;"], "readability/braces"]
["src/nvim/fileio.c", ["                  goto rewind_retry;", "                if (conv_error == 0)", "                  conv_error = readfile_linenr(linecnt,"], "readability/braces"]
["src/nvim/fileio.c", ["                  conv_error = readfile_linenr(linecnt,", "                      ptr, p);", "                if (bad_char_behavior == BAD_DROP)"], "whitespace/alignment"]
["src/nvim/fileio.c", ["                      ptr, p);", "                if (bad_char_behavior == BAD_DROP)", "                  continue;"], "readability/braces"]
["src/nvim/fileio.c", ["                  continue;", "                if (bad_char_behavior != BAD_KEEP)", "                  u8c = bad_char_behavior;"], "readability/braces"]
["src/nvim/fileio.c", ["            if (l == 1 || l > todo) {", "              /* Illegal byte.  If we can try another encoding", "               * do that, unless at EOF where a truncated"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["               * file is more likely than a conversion error. */", "              if (can_retry && !incomplete_tail)", "                break;"], "readability/braces"]
["src/nvim/fileio.c", ["# endif", "              /* Remember the first linenr with an illegal byte */", "              if (conv_error == 0 && illegal_byte == 0)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["              /* Remember the first linenr with an illegal byte */", "              if (conv_error == 0 && illegal_byte == 0)", "                illegal_byte = readfile_linenr(linecnt, ptr, p);"], "readability/braces"]
["src/nvim/fileio.c", ["", "              /* Drop, keep or replace the bad byte. */", "              if (bad_char_behavior == BAD_DROP) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["                memmove(p, p + 1, todo - 1);", "                --p;", "                --size;"], "readability/increment"]
["src/nvim/fileio.c", ["                --p;", "                --size;", "              } else if (bad_char_behavior != BAD_KEEP)"], "readability/increment"]
["src/nvim/fileio.c", ["                --size;", "              } else if (bad_char_behavior != BAD_KEEP)", "                *p = bad_char_behavior;"], "readability/braces"]
["src/nvim/fileio.c", ["                *p = bad_char_behavior;", "            } else", "              p += l - 1;"], "readability/braces"]
["src/nvim/fileio.c", ["        if (p < ptr + size && !incomplete_tail) {", "          /* Detected a UTF-8 error. */", "rewind_retry:"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "      /* count the number of characters (after conversion!) */", "      filesize += size;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "      /*", "       * when reading the first part of a file: guess EOL type"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      if (fileformat == EOL_UNKNOWN) {", "        /* First try finding a NL, for Dos and Unix */", "        if (try_dos || try_unix) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "          for (p = ptr; p < ptr + size; ++p) {", "            if (*p == NL) {"], "readability/increment"]
["src/nvim/fileio.c", ["            if (*p == NL) {", "              if (!try_unix", "                  || (try_dos && p > ptr && p[-1] == CAR))"], "readability/braces"]
["src/nvim/fileio.c", ["                fileformat = EOL_DOS;", "              else", "                fileformat = EOL_UNIX;"], "readability/braces"]
["src/nvim/fileio.c", ["", "          /* Don't give in to EOL_UNIX if EOL_MAC is more likely */", "          if (fileformat == EOL_UNIX && try_mac) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          if (fileformat == EOL_UNIX && try_mac) {", "            /* Need to reset the counters when retrying fenc. */", "            try_mac = 1;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            try_unix = 1;", "            for (; p >= ptr && *p != CAR; p--)", "              ;"], "readability/braces"]
["src/nvim/fileio.c", ["            for (; p >= ptr && *p != CAR; p--)", "              ;", "            if (p >= ptr) {"], "whitespace/semicolon"]
["src/nvim/fileio.c", ["            if (p >= ptr) {", "              for (p = ptr; p < ptr + size; ++p) {", "                if (*p == NL)"], "readability/increment"]
["src/nvim/fileio.c", ["              for (p = ptr; p < ptr + size; ++p) {", "                if (*p == NL)", "                  try_unix++;"], "readability/braces"]
["src/nvim/fileio.c", ["                  try_unix++;", "                else if (*p == CAR)", "                  try_mac++;"], "readability/braces"]
["src/nvim/fileio.c", ["              }", "              if (try_mac > try_unix)", "                fileformat = EOL_MAC;"], "readability/braces"]
["src/nvim/fileio.c", ["", "        /* No NL found: may use Mac format */", "        if (fileformat == EOL_UNKNOWN && try_mac)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        /* No NL found: may use Mac format */", "        if (fileformat == EOL_UNKNOWN && try_mac)", "          fileformat = EOL_MAC;"], "readability/braces"]
["src/nvim/fileio.c", ["", "        /* Still nothing found?  Use first format in 'ffs' */", "        if (fileformat == EOL_UNKNOWN)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        /* Still nothing found?  Use first format in 'ffs' */", "        if (fileformat == EOL_UNKNOWN)", "          fileformat = default_fileformat();"], "readability/braces"]
["src/nvim/fileio.c", ["", "    /*", "     * This loop is executed once for every character read."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (fileformat == EOL_MAC) {", "      --ptr;", "      while (++ptr, --size >= 0) {"], "readability/increment"]
["src/nvim/fileio.c", ["      while (++ptr, --size >= 0) {", "        /* catch most common case first */", "        if ((c = *ptr) != NUL && c != CAR && c != NL)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        /* catch most common case first */", "        if ((c = *ptr) != NUL && c != CAR && c != NL)", "          continue;"], "readability/braces"]
["src/nvim/fileio.c", ["          continue;", "        if (c == NUL)", "          *ptr = NL;            /* NULs are replaced by newlines! */"], "readability/braces"]
["src/nvim/fileio.c", ["        if (c == NUL)", "          *ptr = NL;            /* NULs are replaced by newlines! */", "        else if (c == NL)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          *ptr = NL;            /* NULs are replaced by newlines! */", "        else if (c == NL)", "          *ptr = CAR;           /* NLs are replaced by CRs! */"], "readability/braces"]
["src/nvim/fileio.c", ["        else if (c == NL)", "          *ptr = CAR;           /* NLs are replaced by CRs! */", "        else {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          *ptr = CAR;           /* NLs are replaced by CRs! */", "        else {", "          if (skip_count == 0) {"], "readability/braces"]
["src/nvim/fileio.c", ["          *ptr = CAR;           /* NLs are replaced by CRs! */", "        else {", "          if (skip_count == 0) {"], "readability/braces"]
["src/nvim/fileio.c", ["          if (skip_count == 0) {", "            *ptr = NUL;                     /* end of line */", "            len = (colnr_T) (ptr - line_start + 1);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            *ptr = NUL;                     /* end of line */", "            len = (colnr_T) (ptr - line_start + 1);", "            if (ml_append(lnum, line_start, len, newfile) == FAIL) {"], "whitespace/cast"]
["src/nvim/fileio.c", ["            if (ml_append(lnum, line_start, len, newfile) == FAIL) {", "              error = TRUE;", "              break;"], "readability/bool"]
["src/nvim/fileio.c", ["            }", "            if (read_undo_file)", "              sha256_update(&sha_ctx, line_start, len);"], "readability/braces"]
["src/nvim/fileio.c", ["              sha256_update(&sha_ctx, line_start, len);", "            ++lnum;", "            if (--read_count == 0) {"], "readability/increment"]
["src/nvim/fileio.c", ["            if (--read_count == 0) {", "              error = TRUE;                     /* break loop */", "              line_start = ptr;                 /* nothing left to write */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            if (--read_count == 0) {", "              error = TRUE;                     /* break loop */", "              line_start = ptr;                 /* nothing left to write */"], "readability/bool"]
["src/nvim/fileio.c", ["              error = TRUE;                     /* break loop */", "              line_start = ptr;                 /* nothing left to write */", "              break;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            }", "          } else", "            --skip_count;"], "readability/braces"]
["src/nvim/fileio.c", ["          } else", "            --skip_count;", "          line_start = ptr + 1;"], "readability/increment"]
["src/nvim/fileio.c", ["    } else {", "      --ptr;", "      while (++ptr, --size >= 0) {"], "readability/increment"]
["src/nvim/fileio.c", ["      while (++ptr, --size >= 0) {", "        if ((c = *ptr) != NUL && c != NL)          /* catch most common case */", "          continue;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      while (++ptr, --size >= 0) {", "        if ((c = *ptr) != NUL && c != NL)          /* catch most common case */", "          continue;"], "readability/braces"]
["src/nvim/fileio.c", ["          continue;", "        if (c == NUL)", "          *ptr = NL;            /* NULs are replaced by newlines! */"], "readability/braces"]
["src/nvim/fileio.c", ["        if (c == NUL)", "          *ptr = NL;            /* NULs are replaced by newlines! */", "        else {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          *ptr = NL;            /* NULs are replaced by newlines! */", "        else {", "          if (skip_count == 0) {"], "readability/braces"]
["src/nvim/fileio.c", ["          *ptr = NL;            /* NULs are replaced by newlines! */", "        else {", "          if (skip_count == 0) {"], "readability/braces"]
["src/nvim/fileio.c", ["          if (skip_count == 0) {", "            *ptr = NUL;                         /* end of line */", "            len = (colnr_T)(ptr - line_start + 1);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["                  fileformat = EOL_UNIX;", "                  if (set_options)", "                    set_fileformat(EOL_UNIX, OPT_LOCAL);"], "readability/braces"]
["src/nvim/fileio.c", ["            if (ml_append(lnum, line_start, len, newfile) == FAIL) {", "              error = TRUE;", "              break;"], "readability/bool"]
["src/nvim/fileio.c", ["            }", "            if (read_undo_file)", "              sha256_update(&sha_ctx, line_start, len);"], "readability/braces"]
["src/nvim/fileio.c", ["              sha256_update(&sha_ctx, line_start, len);", "            ++lnum;", "            if (--read_count == 0) {"], "readability/increment"]
["src/nvim/fileio.c", ["            if (--read_count == 0) {", "              error = TRUE;                         /* break loop */", "              line_start = ptr;                 /* nothing left to write */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            if (--read_count == 0) {", "              error = TRUE;                         /* break loop */", "              line_start = ptr;                 /* nothing left to write */"], "readability/bool"]
["src/nvim/fileio.c", ["              error = TRUE;                         /* break loop */", "              line_start = ptr;                 /* nothing left to write */", "              break;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            }", "          } else", "            --skip_count;"], "readability/braces"]
["src/nvim/fileio.c", ["          } else", "            --skip_count;", "          line_start = ptr + 1;"], "readability/increment"]
["src/nvim/fileio.c", ["failed:", "  /* not an error, max. number of lines reached */", "  if (error && read_count == 0)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  /* not an error, max. number of lines reached */", "  if (error && read_count == 0)", "    error = FALSE;"], "readability/braces"]
["src/nvim/fileio.c", ["  if (error && read_count == 0)", "    error = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * If we get EOF in the middle of a line, note the fact and"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["           && ptr == line_start + 1)) {", "    /* remember for when writing */", "    if (set_options)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    /* remember for when writing */", "    if (set_options)", "      curbuf->b_p_eol = FALSE;"], "readability/braces"]
["src/nvim/fileio.c", ["    if (set_options)", "      curbuf->b_p_eol = FALSE;", "    *ptr = NUL;"], "readability/bool"]
["src/nvim/fileio.c", ["    len = (colnr_T)(ptr - line_start + 1);", "    if (ml_append(lnum, line_start, len, newfile) == FAIL)", "      error = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["    if (ml_append(lnum, line_start, len, newfile) == FAIL)", "      error = TRUE;", "    else {"], "readability/bool"]
["src/nvim/fileio.c", ["      error = TRUE;", "    else {", "      if (read_undo_file)"], "readability/braces"]
["src/nvim/fileio.c", ["      error = TRUE;", "    else {", "      if (read_undo_file)"], "readability/braces"]
["src/nvim/fileio.c", ["    else {", "      if (read_undo_file)", "        sha256_update(&sha_ctx, line_start, len);"], "readability/braces"]
["src/nvim/fileio.c", ["  }", "  if (fenc_alloced)", "    xfree(fenc);"], "readability/braces"]
["src/nvim/fileio.c", ["  }", "  --no_wait_return;                     /* may wait for return now */", ""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  }", "  --no_wait_return;                     /* may wait for return now */", ""], "readability/increment"]
["src/nvim/fileio.c", ["", "  /*", "   * In recovery mode everything but autocommands is skipped."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (!recoverymode) {", "    /* need to delete the last line, which comes from the empty buffer */", "    if (newfile && wasempty && !(curbuf->b_ml.ml_flags & ML_EMPTY)) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    linecnt = curbuf->b_ml.ml_line_count - linecnt;", "    if (filesize == 0)", "      linecnt = 0;"], "readability/braces"]
["src/nvim/fileio.c", ["      redraw_curbuf_later(NOT_VALID);", "      /* After reading the text into the buffer the diff info needs to", "       * be updated. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      diff_invalidate(curbuf);", "      /* All folds in the window are invalid now.  Mark them for update", "       * before triggering autocommands. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      foldUpdateAll(curwin);", "    } else if (linecnt)                 /* appended at least one line */", "      appended_lines_mark(from, linecnt);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      foldUpdateAll(curwin);", "    } else if (linecnt)                 /* appended at least one line */", "      appended_lines_mark(from, linecnt);"], "readability/braces"]
["src/nvim/fileio.c", ["", "    /*", "     * If we were reading from the same terminal as where messages go,"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        filemess(curbuf, sfname, (char_u *)_(e_interr), 0);", "        if (newfile)", "          curbuf->b_p_ro = TRUE;                /* must use \"w!\" now */"], "readability/braces"]
["src/nvim/fileio.c", ["        if (newfile)", "          curbuf->b_p_ro = TRUE;                /* must use \"w!\" now */", "      }"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (newfile)", "          curbuf->b_p_ro = TRUE;                /* must use \"w!\" now */", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["      check_marks_read();", "      return OK;                /* an interrupt isn't really an error */", "    }"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[fifo]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[socket]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["# ifdef OPEN_CHR_FILES", "      if (S_ISCHR(perm)) {                          /* or character special */", "        STRCAT(IObuff, _(\"[character special]\"));"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[character special]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, shortmess(SHM_RO) ? _(\"[RO]\") : _(\"[readonly]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        msg_add_eol();", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[CR missing]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[NOT converted]\"));", "        c = TRUE;", "      } else if (converted) {"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[converted]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        sprintf((char *)IObuff + STRLEN(IObuff),", "            _(\"[CONVERSION ERROR in line %\" PRId64 \"]\"), (int64_t)conv_error);", "        c = TRUE;"], "whitespace/alignment"]
["src/nvim/fileio.c", ["      if (conv_error != 0) {", "        sprintf((char *)IObuff + STRLEN(IObuff),", "            _(\"[CONVERSION ERROR in line %\" PRId64 \"]\"), (int64_t)conv_error);"], "runtime/printf"]
["src/nvim/fileio.c", ["            _(\"[CONVERSION ERROR in line %\" PRId64 \"]\"), (int64_t)conv_error);", "        c = TRUE;", "      } else if (illegal_byte > 0) {"], "readability/bool"]
["src/nvim/fileio.c", ["        sprintf((char *)IObuff + STRLEN(IObuff),", "            _(\"[ILLEGAL BYTE in line %\" PRId64 \"]\"), (int64_t)illegal_byte);", "        c = TRUE;"], "whitespace/alignment"]
["src/nvim/fileio.c", ["      } else if (illegal_byte > 0) {", "        sprintf((char *)IObuff + STRLEN(IObuff),", "            _(\"[ILLEGAL BYTE in line %\" PRId64 \"]\"), (int64_t)illegal_byte);"], "runtime/printf"]
["src/nvim/fileio.c", ["            _(\"[ILLEGAL BYTE in line %\" PRId64 \"]\"), (int64_t)illegal_byte);", "        c = TRUE;", "      } else if (error)  {"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[READ ERRORS]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["      }", "      if (msg_add_fileformat(fileformat))", "        c = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["      if (msg_add_fileformat(fileformat))", "        c = TRUE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["      p = NULL;", "      msg_scrolled_ign = TRUE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["      if (!read_stdin && !read_buffer) {", "        p = msg_trunc_attr(IObuff, FALSE, 0);", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["      }", "      msg_scrolled_ign = FALSE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["", "    /* with errors writing the file requires \":w!\" */", "    if (newfile && (error"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    /* with errors writing the file requires \":w!\" */", "    if (newfile && (error", "                    || conv_error != 0"], "readability/braces"]
["src/nvim/fileio.c", ["                    || (illegal_byte > 0 && bad_char_behavior != BAD_KEEP)", "                    ))", "      curbuf->b_p_ro = TRUE;"], "whitespace/parens"]
["src/nvim/fileio.c", ["                    ))", "      curbuf->b_p_ro = TRUE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "    u_clearline();          /* cannot use \"U\" command after adding lines */", ""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * In Ex mode: cursor at last new line."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["     */", "    if (exmode_active)", "      curwin->w_cursor.lnum = from + linecnt;"], "readability/braces"]
["src/nvim/fileio.c", ["      curwin->w_cursor.lnum = from + linecnt;", "    else", "      curwin->w_cursor.lnum = from + 1;"], "readability/braces"]
["src/nvim/fileio.c", ["    check_cursor_lnum();", "    beginline(BL_WHITE | BL_FIX);           /* on first non-blank */", ""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * Set '[ and '] marks to the newly read lines."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    curbuf->b_op_end.col = 0;", "", "  }"], "whitespace/blank_line"]
["src/nvim/fileio.c", ["", "  /*", "   * Get the marks before executing autocommands, so they can be used there."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * We remember if the last line of the read didn't have"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* When reloading a buffer put the cursor at the first line that is", "   * different. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["   * different. */", "  if (flags & READ_KEEP_UNDO)", "    u_find_first_changed();"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /*", "   * When opening a new file locate undo info and read it."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /* Save the fileformat now, otherwise the buffer will be considered", "     * modified if the format/encoding was automatically detected. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["     * modified if the format/encoding was automatically detected. */", "    if (set_options)", "      save_file_ff(curbuf);"], "readability/braces"]
["src/nvim/fileio.c", ["", "    /*", "     * The output from the autocommands should not overwrite anything and"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  if (recoverymode && error)", "    return FAIL;"], "readability/braces"]
["src/nvim/fileio.c", ["  return OK;", "}", ""], "readability/fn_size"]
["src/nvim/fileio.c", ["", "/*", " * From the current line count and characters read after that, estimate the"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  lnum = curbuf->b_ml.ml_line_count - linecnt + 1;", "  for (s = p; s < endp; ++s)", "    if (*s == '\\n')"], "readability/braces"]
["src/nvim/fileio.c", ["  lnum = curbuf->b_ml.ml_line_count - linecnt + 1;", "  for (s = p; s < endp; ++s)", "    if (*s == '\\n')"], "readability/increment"]
["src/nvim/fileio.c", ["  for (s = p; s < endp; ++s)", "    if (*s == '\\n')", "      ++lnum;"], "readability/braces"]
["src/nvim/fileio.c", ["    if (*s == '\\n')", "      ++lnum;", "  return lnum;"], "readability/increment"]
["src/nvim/fileio.c", ["", "/*", " * Fill \"*eap\" to force the 'fileencoding', 'fileformat' and 'binary to be"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  eap->force_bin = buf->b_p_bin ? FORCE_BIN : FORCE_NOBIN;", "  eap->read_edit = FALSE;", "  eap->forceit = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["  eap->read_edit = FALSE;", "  eap->forceit = FALSE;", "}"], "readability/bool"]
["src/nvim/fileio.c", ["", "/*", " * Set default or forced 'fileformat' and 'binary'."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["{", "  /* set default 'fileformat' */", "  if (set_options) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (set_options) {", "    if (eap != NULL && eap->force_ff != 0)", "      set_fileformat(get_fileformat_force(curbuf, eap), OPT_LOCAL);"], "readability/braces"]
["src/nvim/fileio.c", ["      set_fileformat(get_fileformat_force(curbuf, eap), OPT_LOCAL);", "    else if (*p_ffs != NUL)", "      set_fileformat(default_fileformat(), OPT_LOCAL);"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /* set or reset 'binary' */", "  if (eap != NULL && eap->force_bin != 0) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/*", " * Set forced 'fileencoding'."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/*", " * Convert a file with the 'charconvert' expression."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["static char_u *", "readfile_charconvert (", "    char_u *fname,             /* name of input file */"], "whitespace/parens"]
["src/nvim/fileio.c", ["readfile_charconvert (", "    char_u *fname,             /* name of input file */", "    char_u *fenc,              /* converted from */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    char_u *fname,             /* name of input file */", "    char_u *fenc,              /* converted from */", "    int *fdp               /* in/out: file descriptor of file */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    char_u *fenc,              /* converted from */", "    int *fdp               /* in/out: file descriptor of file */", ")"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  tmpname = vim_tempname();", "  if (tmpname == NULL)", "    errmsg = (char_u *)_(\"Can't find temp file for conversion\");"], "readability/braces"]
["src/nvim/fileio.c", ["    errmsg = (char_u *)_(\"Can't find temp file for conversion\");", "  else {", "    close(*fdp);                /* close the input file, ignore errors */"], "readability/braces"]
["src/nvim/fileio.c", ["    errmsg = (char_u *)_(\"Can't find temp file for conversion\");", "  else {", "    close(*fdp);                /* close the input file, ignore errors */"], "readability/braces"]
["src/nvim/fileio.c", ["  else {", "    close(*fdp);                /* close the input file, ignore errors */", "    *fdp = -1;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (errmsg != NULL) {", "    /* Don't use emsg(), it breaks mappings, the retry with", "     * another type of conversion might still work. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* If the input file is closed, open it (caller should check for error). */", "  if (*fdp < 0) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/*", " * Read marks for the current buffer from the ShaDa file, when we support"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* Always set b_marks_read; needed when 'shada' is changed to include", "   * the ' parameter after opening a buffer. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/*", " * buf_write() - write to file \"fname\" lines \"start\" through \"end\""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    exarg_T *eap,                   /* for forced 'ff' and 'fenc', can be", "                                           NULL! */", "    int append,                             /* append to the file */"], "whitespace/indent"]
["src/nvim/fileio.c", ["    linenr_T end,", "    exarg_T *eap,                   /* for forced 'ff' and 'fenc', can be", "                                           NULL! */"], "readability/multiline_comment"]
["src/nvim/fileio.c", ["    linenr_T end,", "    exarg_T *eap,                   /* for forced 'ff' and 'fenc', can be", "                                           NULL! */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    exarg_T *eap,                   /* for forced 'ff' and 'fenc', can be", "                                           NULL! */", "    int append,                             /* append to the file */"], "whitespace/operators"]
["src/nvim/fileio.c", ["                                           NULL! */", "    int append,                             /* append to the file */", "    int forceit,"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  char_u          *backup = NULL;", "  int backup_copy = FALSE;               /* copy the original file? */", "  int dobackup;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  char_u          *backup = NULL;", "  int backup_copy = FALSE;               /* copy the original file? */", "  int dobackup;"], "readability/bool"]
["src/nvim/fileio.c", ["  char_u          *ffname;", "  char_u          *wfname = NULL;       /* name of file to write to */", "  char_u          *s;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#if defined(UNIX)", "  int made_writable = FALSE;                /* 'w' bit has been set */", "#endif"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#if defined(UNIX)", "  int made_writable = FALSE;                /* 'w' bit has been set */", "#endif"], "readability/bool"]
["src/nvim/fileio.c", ["#endif", "  /* writing everything */", "  int whole = (start == 1 && end == buf->b_ml.ml_line_count);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  int write_bin;", "  struct bw_info write_info;            /* info for buf_write_bytes() */", "  int converted = FALSE;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  struct bw_info write_info;            /* info for buf_write_bytes() */", "  int converted = FALSE;", "  int notconverted = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["  int converted = FALSE;", "  int notconverted = FALSE;", "  char_u          *fenc;                /* effective 'fileencoding' */"], "readability/bool"]
["src/nvim/fileio.c", ["  int notconverted = FALSE;", "  char_u          *fenc;                /* effective 'fileencoding' */", "  char_u          *fenc_tofree = NULL;   /* allocated \"fenc\" */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  char_u          *fenc;                /* effective 'fileencoding' */", "  char_u          *fenc_tofree = NULL;   /* allocated \"fenc\" */", "#ifdef HAS_BW_FLAGS"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#ifdef HAVE_ACL", "  vim_acl_T acl = NULL;                 /* ACL copied from original file to", "                                           backup or new file */"], "readability/multiline_comment"]
["src/nvim/fileio.c", ["#ifdef HAVE_ACL", "  vim_acl_T acl = NULL;                 /* ACL copied from original file to", "                                           backup or new file */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#endif", "  int write_undo_file = FALSE;", "  context_sha256_T sha_ctx;"], "readability/bool"]
["src/nvim/fileio.c", ["", "  if (fname == NULL || *fname == NUL)   /* safety check */", "    return FAIL;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  if (fname == NULL || *fname == NUL)   /* safety check */", "    return FAIL;"], "readability/braces"]
["src/nvim/fileio.c", ["  if (buf->b_ml.ml_mfp == NULL) {", "    /* This can happen during startup when there is a stray \"w\" in the", "     * vimrc file. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Disallow writing from .exrc and .vimrc in current directory for"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["   */", "  if (check_secure())", "    return FAIL;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /* Avoid a crash for a long name. */", "  if (STRLEN(fname) >= MAXPATHL) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* must init bw_conv_buf and bw_iconv_fd before jumping to \"fail\" */", "  write_info.bw_conv_buf = NULL;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  write_info.bw_conv_buf = NULL;", "  write_info.bw_conv_error = FALSE;", "  write_info.bw_conv_error_lnum = 0;"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /* After writing a file changedtick changes but we don't want to display", "   * the line. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["   * the line. */", "  ex_no_reprint = TRUE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * If there is no file name yet, use the one for the written file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      && vim_strchr(p_cpo, CPO_FNAMEW) != NULL) {", "    if (set_rw_fname(fname, sfname) == FAIL)", "      return FAIL;"], "readability/braces"]
["src/nvim/fileio.c", ["      return FAIL;", "    buf = curbuf;           /* just in case autocmds made \"buf\" invalid */", "  }"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  if (sfname == NULL)", "    sfname = fname;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  if (buf->b_ffname != NULL && fnamecmp(ffname, buf->b_ffname) == 0)", "    overwriting = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["  if (buf->b_ffname != NULL && fnamecmp(ffname, buf->b_ffname) == 0)", "    overwriting = TRUE;", "  else"], "readability/bool"]
["src/nvim/fileio.c", ["    overwriting = TRUE;", "  else", "    overwriting = FALSE;"], "readability/braces"]
["src/nvim/fileio.c", ["  else", "    overwriting = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  ++no_wait_return;                 /* don't wait for return yet */", ""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  ++no_wait_return;                 /* don't wait for return yet */", ""], "readability/increment"]
["src/nvim/fileio.c", ["", "  /*", "   * Set '[ and '] marks to the lines to be written."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    aco_save_T aco;", "    int buf_ffname = FALSE;", "    int buf_sfname = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    int buf_ffname = FALSE;", "    int buf_sfname = FALSE;", "    int buf_fname_f = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    int buf_sfname = FALSE;", "    int buf_fname_f = FALSE;", "    int buf_fname_s = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    int buf_fname_f = FALSE;", "    int buf_fname_s = FALSE;", "    int did_cmd = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    int buf_fname_s = FALSE;", "    int did_cmd = FALSE;", "    int nofile_err = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    int did_cmd = FALSE;", "    int nofile_err = FALSE;", "    int empty_memline = (buf->b_ml.ml_mfp == NULL);"], "readability/bool"]
["src/nvim/fileio.c", ["", "    /*", "     * Apply PRE autocommands."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["     */", "    if (ffname == buf->b_ffname)", "      buf_ffname = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["    if (ffname == buf->b_ffname)", "      buf_ffname = TRUE;", "    if (sfname == buf->b_sfname)"], "readability/bool"]
["src/nvim/fileio.c", ["      buf_ffname = TRUE;", "    if (sfname == buf->b_sfname)", "      buf_sfname = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["    if (sfname == buf->b_sfname)", "      buf_sfname = TRUE;", "    if (fname == buf->b_ffname)"], "readability/bool"]
["src/nvim/fileio.c", ["      buf_sfname = TRUE;", "    if (fname == buf->b_ffname)", "      buf_fname_f = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["    if (fname == buf->b_ffname)", "      buf_fname_f = TRUE;", "    if (fname == buf->b_sfname)"], "readability/bool"]
["src/nvim/fileio.c", ["      buf_fname_f = TRUE;", "    if (fname == buf->b_sfname)", "      buf_fname_s = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["    if (fname == buf->b_sfname)", "      buf_fname_s = TRUE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["      if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEAPPENDCMD,", "                sfname, sfname, FALSE, curbuf, eap))) {", "        if (overwriting && bt_nofile(curbuf))"], "whitespace/alignment"]
["src/nvim/fileio.c", ["      if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEAPPENDCMD,", "                sfname, sfname, FALSE, curbuf, eap))) {", "        if (overwriting && bt_nofile(curbuf))"], "readability/bool"]
["src/nvim/fileio.c", ["                sfname, sfname, FALSE, curbuf, eap))) {", "        if (overwriting && bt_nofile(curbuf))", "          nofile_err = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["        if (overwriting && bt_nofile(curbuf))", "          nofile_err = TRUE;", "        else"], "readability/bool"]
["src/nvim/fileio.c", ["          nofile_err = TRUE;", "        else", "          apply_autocmds_exarg(EVENT_FILEAPPENDPRE,"], "readability/braces"]
["src/nvim/fileio.c", ["          apply_autocmds_exarg(EVENT_FILEAPPENDPRE,", "              sfname, sfname, FALSE, curbuf, eap);", "      }"], "whitespace/alignment"]
["src/nvim/fileio.c", ["          apply_autocmds_exarg(EVENT_FILEAPPENDPRE,", "              sfname, sfname, FALSE, curbuf, eap);", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILTERWRITEPRE,", "          NULL, sfname, FALSE, curbuf, eap);", "    } else if (reset_changed && whole)   {"], "whitespace/alignment"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILTERWRITEPRE,", "          NULL, sfname, FALSE, curbuf, eap);", "    } else if (reset_changed && whole)   {"], "readability/bool"]
["src/nvim/fileio.c", ["      did_cmd = apply_autocmds_exarg(EVENT_BUFWRITECMD,", "          sfname, sfname, FALSE, curbuf, eap);", "      if (did_cmd) {"], "whitespace/alignment"]
["src/nvim/fileio.c", ["      did_cmd = apply_autocmds_exarg(EVENT_BUFWRITECMD,", "          sfname, sfname, FALSE, curbuf, eap);", "      if (did_cmd) {"], "readability/bool"]
["src/nvim/fileio.c", ["        if (was_changed && !curbufIsChanged()) {", "          /* Written everything correctly and BufWriteCmd has reset", "           * 'modified': Correct the undo information so that an"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      } else {", "        if (overwriting && bt_nofile(curbuf))", "          nofile_err = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["        if (overwriting && bt_nofile(curbuf))", "          nofile_err = TRUE;", "        else"], "readability/bool"]
["src/nvim/fileio.c", ["          nofile_err = TRUE;", "        else", "          apply_autocmds_exarg(EVENT_BUFWRITEPRE,"], "readability/braces"]
["src/nvim/fileio.c", ["          apply_autocmds_exarg(EVENT_BUFWRITEPRE,", "              sfname, sfname, FALSE, curbuf, eap);", "      }"], "whitespace/alignment"]
["src/nvim/fileio.c", ["          apply_autocmds_exarg(EVENT_BUFWRITEPRE,", "              sfname, sfname, FALSE, curbuf, eap);", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["      if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEWRITECMD,", "                sfname, sfname, FALSE, curbuf, eap))) {", "        if (overwriting && bt_nofile(curbuf))"], "whitespace/alignment"]
["src/nvim/fileio.c", ["      if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEWRITECMD,", "                sfname, sfname, FALSE, curbuf, eap))) {", "        if (overwriting && bt_nofile(curbuf))"], "readability/bool"]
["src/nvim/fileio.c", ["                sfname, sfname, FALSE, curbuf, eap))) {", "        if (overwriting && bt_nofile(curbuf))", "          nofile_err = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["        if (overwriting && bt_nofile(curbuf))", "          nofile_err = TRUE;", "        else"], "readability/bool"]
["src/nvim/fileio.c", ["          nofile_err = TRUE;", "        else", "          apply_autocmds_exarg(EVENT_FILEWRITEPRE,"], "readability/braces"]
["src/nvim/fileio.c", ["          apply_autocmds_exarg(EVENT_FILEWRITEPRE,", "              sfname, sfname, FALSE, curbuf, eap);", "      }"], "whitespace/alignment"]
["src/nvim/fileio.c", ["          apply_autocmds_exarg(EVENT_FILEWRITEPRE,", "              sfname, sfname, FALSE, curbuf, eap);", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["", "    /* restore curwin/curbuf and a few other things */", "    aucmd_restbuf(&aco);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        ) {", "      --no_wait_return;", "      msg_scroll = msg_save;"], "readability/increment"]
["src/nvim/fileio.c", ["      msg_scroll = msg_save;", "      if (nofile_err)", "        EMSG(_(\"E676: No matching autocommands for acwrite buffer\"));"], "readability/braces"]
["src/nvim/fileio.c", ["", "      if (nofile_err", "          || aborting()"], "readability/braces"]
["src/nvim/fileio.c", ["          )", "        /* An aborting error, interrupt or exception in the", "         * autocommands. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      if (did_cmd) {", "        if (buf == NULL)", "          /* The buffer was deleted.  We assume it was written"], "readability/braces"]
["src/nvim/fileio.c", ["        if (buf == NULL)", "          /* The buffer was deleted.  We assume it was written", "           * (can't retry anyway). */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (overwriting) {", "          /* Assume the buffer was written, update the timestamp. */", "          ml_timestamp(buf);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          ml_timestamp(buf);", "          if (append)", "            buf->b_flags &= ~BF_NEW;"], "readability/braces"]
["src/nvim/fileio.c", ["            buf->b_flags &= ~BF_NEW;", "          else", "            buf->b_flags &= ~BF_WRITE_MASK;"], "readability/braces"]
["src/nvim/fileio.c", ["        }", "        if (reset_changed && buf->b_changed && !append", "            && (overwriting || vim_strchr(p_cpo, CPO_PLUS) != NULL))"], "readability/braces"]
["src/nvim/fileio.c", ["            && (overwriting || vim_strchr(p_cpo, CPO_PLUS) != NULL))", "          /* Buffer still changed, the autocommands didn't work", "           * properly. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      }", "      if (!aborting())", "        EMSG(_(\"E203: Autocommands deleted or unloaded buffer to be written\"));"], "readability/braces"]
["src/nvim/fileio.c", ["", "    /*", "     * The autocommands may have changed the number of lines in the file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (buf->b_ml.ml_line_count != old_line_count) {", "      if (whole)                                                /* write all */", "        end = buf->b_ml.ml_line_count;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (buf->b_ml.ml_line_count != old_line_count) {", "      if (whole)                                                /* write all */", "        end = buf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/fileio.c", ["        end = buf->b_ml.ml_line_count;", "      else if (buf->b_ml.ml_line_count > old_line_count)        /* more lines */", "        end += buf->b_ml.ml_line_count - old_line_count;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        end = buf->b_ml.ml_line_count;", "      else if (buf->b_ml.ml_line_count > old_line_count)        /* more lines */", "        end += buf->b_ml.ml_line_count - old_line_count;"], "readability/braces"]
["src/nvim/fileio.c", ["        end += buf->b_ml.ml_line_count - old_line_count;", "      else {                                                    /* less lines */", "        end -= old_line_count - buf->b_ml.ml_line_count;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        end += buf->b_ml.ml_line_count - old_line_count;", "      else {                                                    /* less lines */", "        end -= old_line_count - buf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/fileio.c", ["        end += buf->b_ml.ml_line_count - old_line_count;", "      else {                                                    /* less lines */", "        end -= old_line_count - buf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/fileio.c", ["        if (end < start) {", "          --no_wait_return;", "          msg_scroll = msg_save;"], "readability/increment"]
["src/nvim/fileio.c", ["          msg_scroll = msg_save;", "          EMSG(_(\"E204: Autocommand changed number of lines in unexpected way\"));", "          return FAIL;"], "whitespace/line_length"]
["src/nvim/fileio.c", ["", "    /*", "     * The autocommands may have changed the name of the buffer, which may"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["     */", "    if (buf_ffname)", "      ffname = buf->b_ffname;"], "readability/braces"]
["src/nvim/fileio.c", ["      ffname = buf->b_ffname;", "    if (buf_sfname)", "      sfname = buf->b_sfname;"], "readability/braces"]
["src/nvim/fileio.c", ["      sfname = buf->b_sfname;", "    if (buf_fname_f)", "      fname = buf->b_ffname;"], "readability/braces"]
["src/nvim/fileio.c", ["      fname = buf->b_ffname;", "    if (buf_fname_s)", "      fname = buf->b_sfname;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  if (shortmess(SHM_OVER) && !exiting)", "    msg_scroll = FALSE;             /* overwrite previous file message */"], "readability/braces"]
["src/nvim/fileio.c", ["  if (shortmess(SHM_OVER) && !exiting)", "    msg_scroll = FALSE;             /* overwrite previous file message */", "  else"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (shortmess(SHM_OVER) && !exiting)", "    msg_scroll = FALSE;             /* overwrite previous file message */", "  else"], "readability/bool"]
["src/nvim/fileio.c", ["    msg_scroll = FALSE;             /* overwrite previous file message */", "  else", "    msg_scroll = TRUE;              /* don't overwrite previous file message */"], "readability/braces"]
["src/nvim/fileio.c", ["  else", "    msg_scroll = TRUE;              /* don't overwrite previous file message */", "  if (!filtering)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  else", "    msg_scroll = TRUE;              /* don't overwrite previous file message */", "  if (!filtering)"], "readability/bool"]
["src/nvim/fileio.c", ["    msg_scroll = TRUE;              /* don't overwrite previous file message */", "  if (!filtering)", "    filemess(buf,"], "readability/braces"]
["src/nvim/fileio.c", ["#ifndef UNIX", "        sfname,", "#else"], "whitespace/alignment"]
["src/nvim/fileio.c", ["#else", "        fname,", "#endif"], "whitespace/alignment"]
["src/nvim/fileio.c", ["#endif", "        (char_u *)\"\", 0);               /* show that we are busy */", "  msg_scroll = FALSE;               /* always overwrite the file message now */"], "whitespace/alignment"]
["src/nvim/fileio.c", ["#endif", "        (char_u *)\"\", 0);               /* show that we are busy */", "  msg_scroll = FALSE;               /* always overwrite the file message now */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        (char_u *)\"\", 0);               /* show that we are busy */", "  msg_scroll = FALSE;               /* always overwrite the file message now */", ""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        (char_u *)\"\", 0);               /* show that we are busy */", "  msg_scroll = FALSE;               /* always overwrite the file message now */", ""], "readability/bool"]
["src/nvim/fileio.c", ["    bufsize = SMBUFSIZE;", "  } else", "    bufsize = BUFSIZE;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /*", "   * Get information about original file (if there is one)."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (!os_fileinfo((char *)fname, &file_info_old)) {", "    newfile = TRUE;", "  } else {"], "readability/bool"]
["src/nvim/fileio.c", ["    perm = file_info_old.stat.st_mode;", "    if (!S_ISREG(file_info_old.stat.st_mode)) {             /* not a file */", "      if (S_ISDIR(file_info_old.stat.st_mode)) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      }", "      /* It's a device of some kind (or a fifo) which we can write to", "       * but for which we can't make a backup. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["       * but for which we can't make a backup. */", "      device = TRUE;", "      newfile = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["      device = TRUE;", "      newfile = TRUE;", "      perm = -1;"], "readability/bool"]
["src/nvim/fileio.c", ["  if (c == NODE_WRITABLE) {", "    device = TRUE;", "    newfile = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["    device = TRUE;", "    newfile = TRUE;", "    perm = -1;"], "readability/bool"]
["src/nvim/fileio.c", ["  if (!device && !newfile) {", "    /*", "     * Check if the file is really writable (when renaming the file to"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * Check if the timestamp hasn't changed since reading the file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      retval = check_mtime(buf, &file_info_old);", "      if (retval == FAIL)", "        goto fail;"], "readability/braces"]
["src/nvim/fileio.c", ["#ifdef HAVE_ACL", "  /*", "   * For systems that support ACL: get the ACL from the original file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["   */", "  if (!newfile)", "    acl = mch_get_acl(fname);"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /*", "   * If 'backupskip' is not empty, don't make a backup for some files."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  dobackup = (p_wb || p_bk || *p_pm != NUL);", "  if (dobackup && *p_bsk != NUL && match_file_list(p_bsk, sfname, ffname))", "    dobackup = FALSE;"], "readability/braces"]
["src/nvim/fileio.c", ["  if (dobackup && *p_bsk != NUL && match_file_list(p_bsk, sfname, ffname))", "    dobackup = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * Save the value of got_int and reset it.  We don't want a previous"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  prev_got_int = got_int;", "  got_int = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  /* Mark the buffer as 'being saved' to prevent changed buffer warnings */", "  buf->b_saving = true;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * If we are not appending or filtering, the file exists, and the"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    if ((bkc & BKC_YES) || append) {       /* \"yes\" */", "      backup_copy = TRUE;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if ((bkc & BKC_YES) || append) {       /* \"yes\" */", "      backup_copy = TRUE;", "    } else if ((bkc & BKC_AUTO)) {          /* \"auto\" */"], "readability/bool"]
["src/nvim/fileio.c", ["      backup_copy = TRUE;", "    } else if ((bkc & BKC_AUTO)) {          /* \"auto\" */", "      int i;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "      /*", "       * Don't rename the file when:"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          || !os_fileinfo_id_equal(&file_info, &file_info_old)) {", "        backup_copy = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/fileio.c", ["      } else {", "        /*", "         * Check if we can create a file and set the owner/group to"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        for (i = 4913;; i += 123) {", "          sprintf((char *)path_tail(IObuff), \"%d\", i);", "          if (!os_fileinfo_link((char *)IObuff, &file_info)) {"], "runtime/printf"]
["src/nvim/fileio.c", ["        fd = os_open((char *)IObuff,", "            O_CREAT|O_WRONLY|O_EXCL|O_NOFOLLOW, perm);", "        if (fd < 0)             /* can't write in directory */"], "whitespace/alignment"]
["src/nvim/fileio.c", ["            O_CREAT|O_WRONLY|O_EXCL|O_NOFOLLOW, perm);", "        if (fd < 0)             /* can't write in directory */", "          backup_copy = TRUE;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            O_CREAT|O_WRONLY|O_EXCL|O_NOFOLLOW, perm);", "        if (fd < 0)             /* can't write in directory */", "          backup_copy = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["        if (fd < 0)             /* can't write in directory */", "          backup_copy = TRUE;", "        else {"], "readability/bool"]
["src/nvim/fileio.c", ["          backup_copy = TRUE;", "        else {", "# ifdef UNIX"], "readability/braces"]
["src/nvim/fileio.c", ["          backup_copy = TRUE;", "        else {", "# ifdef UNIX"], "readability/braces"]
["src/nvim/fileio.c", ["              || (long)file_info.stat.st_mode != perm) {", "            backup_copy = TRUE;", "          }"], "readability/bool"]
["src/nvim/fileio.c", ["# endif", "          /* Close the file before removing it, on MS-Windows we", "           * can't delete an open file. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * Break symlinks and/or hardlinks if we've been asked to."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "      /* Symlinks. */", "      if ((bkc & BKC_BREAKSYMLINK)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          && !os_fileinfo_id_equal(&file_info, &file_info_old)) {", "        backup_copy = FALSE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["", "      /* Hardlinks. */", "      if ((bkc & BKC_BREAKHARDLINK)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["              || os_fileinfo_id_equal(&file_info, &file_info_old))) {", "        backup_copy = FALSE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["", "    /* make sure we have a valid backup extension to use */", "    if (*p_bex == NUL)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    /* make sure we have a valid backup extension to use */", "    if (*p_bex == NUL)", "      backup_ext = (char_u *)\".bak\";"], "readability/braces"]
["src/nvim/fileio.c", ["      backup_ext = (char_u *)\".bak\";", "    else", "      backup_ext = p_bex;"], "readability/braces"]
["src/nvim/fileio.c", ["", "      /*", "       * Try to make the backup in each directory in the 'bdir' option."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      while (*dirp) {", "        /*", "         * Isolate one directory name, using an entry in 'bdir'."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (rootname == NULL) {", "          some_error = TRUE;                /* out of memory */", "          goto nobackup;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (rootname == NULL) {", "          some_error = TRUE;                /* out of memory */", "          goto nobackup;"], "readability/bool"]
["src/nvim/fileio.c", ["            xfree(rootname);", "            some_error = TRUE;                          /* out of memory */", "            goto nobackup;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            xfree(rootname);", "            some_error = TRUE;                          /* out of memory */", "            goto nobackup;"], "readability/bool"]
["src/nvim/fileio.c", ["", "          /*", "           * Check if backup file already exists."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["                     && os_fileinfo((char *)backup, &file_info_new)) {", "                --*wp;", "              }"], "readability/increment"]
["src/nvim/fileio.c", ["", "        /*", "         * Try to create the backup file"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (backup != NULL) {", "          /* remove old backup, if present */", "          os_remove((char *)backup);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "      /*", "       * Make a backup by renaming the original file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["       */", "      /*", "       * If 'cpoptions' includes the \"W\" flag, we don't want to"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "      /*", "       *"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      while (*dirp) {", "        /*", "         * Isolate one directory name and make the backup file name."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (backup != NULL) {", "          /*", "           * If we are not going to keep the backup file, don't"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            p = backup + STRLEN(backup) - 1 - STRLEN(backup_ext);", "            if (p < backup)             /* empty file name ??? */", "              p = backup;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            p = backup + STRLEN(backup) - 1 - STRLEN(backup_ext);", "            if (p < backup)             /* empty file name ??? */", "              p = backup;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  if (end > buf->b_ml.ml_line_count)", "    end = buf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/fileio.c", ["    end = buf->b_ml.ml_line_count;", "  if (buf->b_ml.ml_flags & ML_EMPTY)", "    start = end + 1;"], "readability/braces"]
["src/nvim/fileio.c", ["    if (write_info.bw_iconv_fd != (iconv_t)-1) {", "      /* We're going to use iconv(), allocate a buffer to convert in. */", "      write_info.bw_conv_buflen = bufsize * ICONV_MULT;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      }", "      write_info.bw_first = TRUE;", "    } else"], "readability/bool"]
["src/nvim/fileio.c", ["      write_info.bw_first = TRUE;", "    } else", "#  endif"], "readability/braces"]
["src/nvim/fileio.c", ["", "    /*", "     * When the file needs to be converted with 'charconvert' after"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    }", "    notconverted = TRUE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["", "  lnum -= start;            /* compute number of written lines */", "  --no_wait_return;         /* may wait for return now */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  lnum -= start;            /* compute number of written lines */", "  --no_wait_return;         /* may wait for return now */", ""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  lnum -= start;            /* compute number of written lines */", "  --no_wait_return;         /* may wait for return now */", ""], "readability/increment"]
["src/nvim/fileio.c", ["#if !defined(UNIX)", "  fname = sfname;           /* use shortname now, for the messages */", "#endif"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      STRCAT(IObuff, _(\" CONVERSION ERROR\"));", "      c = TRUE;", "      if (write_info.bw_conv_error_lnum != 0)"], "readability/bool"]
["src/nvim/fileio.c", ["      c = TRUE;", "      if (write_info.bw_conv_error_lnum != 0)", "        vim_snprintf_add((char *)IObuff, IOSIZE, _(\" in line %\" PRId64 \";\"),"], "readability/braces"]
["src/nvim/fileio.c", ["        vim_snprintf_add((char *)IObuff, IOSIZE, _(\" in line %\" PRId64 \";\"),", "            (int64_t)write_info.bw_conv_error_lnum);", "    } else if (notconverted) {"], "whitespace/alignment"]
["src/nvim/fileio.c", ["      STRCAT(IObuff, _(\"[NOT converted]\"));", "      c = TRUE;", "    } else if (converted) {"], "readability/bool"]
["src/nvim/fileio.c", ["      STRCAT(IObuff, _(\"[converted]\"));", "      c = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["      STRCAT(IObuff, _(\"[Device]\"));", "      c = TRUE;", "    } else if (newfile) {"], "readability/bool"]
["src/nvim/fileio.c", ["      msg_add_eol();", "      c = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["    }", "    /* may add [unix/dos/mac] */", "    if (msg_add_fileformat(fileformat))"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    /* may add [unix/dos/mac] */", "    if (msg_add_fileformat(fileformat))", "      c = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["    if (msg_add_fileformat(fileformat))", "      c = TRUE;", "    msg_add_lines(c, (long)lnum, nchars);       /* add line/char count */"], "readability/bool"]
["src/nvim/fileio.c", ["      c = TRUE;", "    msg_add_lines(c, (long)lnum, nchars);       /* add line/char count */", "    if (!shortmess(SHM_WRITE)) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (!shortmess(SHM_WRITE)) {", "      if (append)", "        STRCAT(IObuff, shortmess(SHM_WRI) ? _(\" [a]\") : _(\" appended\"));"], "readability/braces"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, shortmess(SHM_WRI) ? _(\" [a]\") : _(\" appended\"));", "      else", "        STRCAT(IObuff, shortmess(SHM_WRI) ? _(\" [w]\") : _(\" written\"));"], "readability/braces"]
["src/nvim/fileio.c", ["", "    set_keep_msg(msg_trunc_attr(IObuff, FALSE, 0), 0);", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /* When written everything correctly: reset 'modified'.  Unless not", "   * writing to the original file and '+' is not in 'cpoptions'. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * If written to the current file, update the timestamp of the swap file"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    ml_timestamp(buf);", "    if (append)", "      buf->b_flags &= ~BF_NEW;"], "readability/braces"]
["src/nvim/fileio.c", ["      buf->b_flags &= ~BF_NEW;", "    else", "      buf->b_flags &= ~BF_WRITE_MASK;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /*", "   * If we kept a backup until now, and we are in patch mode, then we make"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (backup != NULL) {", "      /*", "       * If the original file does not exist yet"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    }", "    /*", "     * If there is no backup file, remember that a (new) file was"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["     */", "    else {", "      int empty_fd;"], "whitespace/newline"]
["src/nvim/fileio.c", ["     */", "    else {", "      int empty_fd;"], "readability/braces"]
["src/nvim/fileio.c", ["", "      if (org == NULL", "          || (empty_fd = os_open(org,"], "readability/braces"]
["src/nvim/fileio.c", ["          || (empty_fd = os_open(org,", "                  O_CREAT | O_EXCL | O_NOFOLLOW,", "                  perm < 0 ? 0666 : (perm & 0777))) < 0)"], "whitespace/alignment"]
["src/nvim/fileio.c", ["                  O_CREAT | O_EXCL | O_NOFOLLOW,", "                  perm < 0 ? 0666 : (perm & 0777))) < 0)", "        EMSG(_(\"E206: patchmode: can't touch empty original file\"));"], "whitespace/alignment"]
["src/nvim/fileio.c", ["          || (empty_fd = os_open(org,", "                  O_CREAT | O_EXCL | O_NOFOLLOW,", "                  perm < 0 ? 0666 : (perm & 0777))) < 0)"], "whitespace/alignment"]
["src/nvim/fileio.c", ["                  O_CREAT | O_EXCL | O_NOFOLLOW,", "                  perm < 0 ? 0666 : (perm & 0777))) < 0)", "        EMSG(_(\"E206: patchmode: can't touch empty original file\"));"], "whitespace/alignment"]
["src/nvim/fileio.c", ["        EMSG(_(\"E206: patchmode: can't touch empty original file\"));", "      else", "        close(empty_fd);"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /*", "   * Remove the backup unless 'backup' option is set"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Finish up.  We get here either after failure or success."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["fail:", "  --no_wait_return;             /* may wait for return now */", "nofail:"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["fail:", "  --no_wait_return;             /* may wait for return now */", "nofail:"], "readability/increment"]
["src/nvim/fileio.c", ["", "  /* Done saving, we accept changed buffer warnings again */", "  buf->b_saving = false;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  xfree(backup);", "  if (buffer != smallbuf)", "    xfree(buffer);"], "readability/braces"]
["src/nvim/fileio.c", ["      MSG_PUTS_ATTR(_(", "              \"don't quit the editor until the file is successfully written!\"),", "          attr | MSG_HIST);"], "whitespace/indent"]
["src/nvim/fileio.c", ["              \"don't quit the editor until the file is successfully written!\"),", "          attr | MSG_HIST);", ""], "whitespace/alignment"]
["src/nvim/fileio.c", ["", "      /* Update the timestamp to avoid an \"overwrite changed file\"", "       * prompt when writing again. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * When writing the whole file and 'undofile' is set, also write the undo"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    sha256_finish(&sha_ctx, hash);", "    u_write_undo(NULL, FALSE, buf, hash);", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["", "    curbuf->b_no_eol_lnum = 0;      /* in case it was set by the previous read */", ""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    curbuf->b_no_eol_lnum = 0;      /* in case it was set by the previous read */", ""], "whitespace/line_length"]
["src/nvim/fileio.c", ["", "    /*", "     * Apply POST autocommands."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    if (append)", "      apply_autocmds_exarg(EVENT_FILEAPPENDPOST, fname, fname,"], "readability/braces"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILEAPPENDPOST, fname, fname,", "          FALSE, curbuf, eap);", "    else if (filtering)"], "whitespace/alignment"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILEAPPENDPOST, fname, fname,", "          FALSE, curbuf, eap);", "    else if (filtering)"], "readability/bool"]
["src/nvim/fileio.c", ["          FALSE, curbuf, eap);", "    else if (filtering)", "      apply_autocmds_exarg(EVENT_FILTERWRITEPOST, NULL, fname,"], "readability/braces"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILTERWRITEPOST, NULL, fname,", "          FALSE, curbuf, eap);", "    else if (reset_changed && whole)"], "whitespace/alignment"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILTERWRITEPOST, NULL, fname,", "          FALSE, curbuf, eap);", "    else if (reset_changed && whole)"], "readability/bool"]
["src/nvim/fileio.c", ["          FALSE, curbuf, eap);", "    else if (reset_changed && whole)", "      apply_autocmds_exarg(EVENT_BUFWRITEPOST, fname, fname,"], "readability/braces"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_BUFWRITEPOST, fname, fname,", "          FALSE, curbuf, eap);", "    else"], "whitespace/alignment"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_BUFWRITEPOST, fname, fname,", "          FALSE, curbuf, eap);", "    else"], "readability/bool"]
["src/nvim/fileio.c", ["          FALSE, curbuf, eap);", "    else", "      apply_autocmds_exarg(EVENT_FILEWRITEPOST, fname, fname,"], "readability/braces"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILEWRITEPOST, fname, fname,", "          FALSE, curbuf, eap);", ""], "whitespace/alignment"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILEWRITEPOST, fname, fname,", "          FALSE, curbuf, eap);", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "    /* restore curwin/curbuf and a few other things */", "    aucmd_restbuf(&aco);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    if (aborting())         /* autocmds may abort script processing */", "      retval = FALSE;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    if (aborting())         /* autocmds may abort script processing */", "      retval = FALSE;"], "readability/braces"]
["src/nvim/fileio.c", ["    if (aborting())         /* autocmds may abort script processing */", "      retval = FALSE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["#undef SET_ERRMSG_NUM", "}", ""], "readability/fn_size"]
["src/nvim/fileio.c", ["", "/*", " * Set the name of the current buffer.  Use when the buffer doesn't have a"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* It's like the unnamed buffer is deleted.... */", "  if (curbuf->b_p_bl)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  /* It's like the unnamed buffer is deleted.... */", "  if (curbuf->b_p_bl)", "    apply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);"], "readability/braces"]
["src/nvim/fileio.c", ["  if (curbuf->b_p_bl)", "    apply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);", "  apply_autocmds(EVENT_BUFWIPEOUT, NULL, NULL, FALSE, curbuf);"], "readability/bool"]
["src/nvim/fileio.c", ["    apply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);", "  apply_autocmds(EVENT_BUFWIPEOUT, NULL, NULL, FALSE, curbuf);", "  if (aborting())           /* autocmds may abort script processing */"], "readability/bool"]
["src/nvim/fileio.c", ["  apply_autocmds(EVENT_BUFWIPEOUT, NULL, NULL, FALSE, curbuf);", "  if (aborting())           /* autocmds may abort script processing */", "    return FAIL;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  apply_autocmds(EVENT_BUFWIPEOUT, NULL, NULL, FALSE, curbuf);", "  if (aborting())           /* autocmds may abort script processing */", "    return FAIL;"], "readability/braces"]
["src/nvim/fileio.c", ["  if (curbuf != buf) {", "    /* We are in another buffer now, don't do the renaming. */", "    EMSG(_(e_auchangedbuf));"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* ....and a new named one is created */", "  apply_autocmds(EVENT_BUFNEW, NULL, NULL, FALSE, curbuf);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  /* ....and a new named one is created */", "  apply_autocmds(EVENT_BUFNEW, NULL, NULL, FALSE, curbuf);", "  if (curbuf->b_p_bl)"], "readability/bool"]
["src/nvim/fileio.c", ["  apply_autocmds(EVENT_BUFNEW, NULL, NULL, FALSE, curbuf);", "  if (curbuf->b_p_bl)", "    apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, curbuf);"], "readability/braces"]
["src/nvim/fileio.c", ["  if (curbuf->b_p_bl)", "    apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, curbuf);", "  if (aborting())           /* autocmds may abort script processing */"], "readability/bool"]
["src/nvim/fileio.c", ["    apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, curbuf);", "  if (aborting())           /* autocmds may abort script processing */", "    return FAIL;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, curbuf);", "  if (aborting())           /* autocmds may abort script processing */", "    return FAIL;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /* Do filetype detection now if 'filetype' is empty. */", "  if (*curbuf->b_p_ft == NUL) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/*", " * Append line and character count to IObuff."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  if (insert_space)", "    *p++ = ' ';"], "readability/braces"]
["src/nvim/fileio.c", ["  if (shortmess(SHM_LINES)) {", "     sprintf((char *)p, \"%\" PRId64 \"L, %\" PRId64 \"C\",", "             (int64_t)lnum, (int64_t)nchars);"], "runtime/printf"]
["src/nvim/fileio.c", ["  }", "  else {", "    if (lnum == 1)"], "whitespace/newline"]
["src/nvim/fileio.c", ["  }", "  else {", "    if (lnum == 1)"], "readability/braces"]
["src/nvim/fileio.c", ["  else {", "    if (lnum == 1)", "      STRCPY(p, _(\"1 line, \"));"], "readability/braces"]
["src/nvim/fileio.c", ["      STRCPY(p, _(\"1 line, \"));", "    else", "      sprintf((char *)p, _(\"%\" PRId64 \" lines, \"), (int64_t)lnum);"], "readability/braces"]
["src/nvim/fileio.c", ["    else", "      sprintf((char *)p, _(\"%\" PRId64 \" lines, \"), (int64_t)lnum);", "    p += STRLEN(p);"], "runtime/printf"]
["src/nvim/fileio.c", ["    p += STRLEN(p);", "    if (nchars == 1)", "      STRCPY(p, _(\"1 character\"));"], "readability/braces"]
["src/nvim/fileio.c", ["      STRCPY(p, _(\"1 character\"));", "    else {", "      sprintf((char *)p, _(\"%\" PRId64 \" characters\"), (int64_t)nchars);"], "readability/braces"]
["src/nvim/fileio.c", ["      STRCPY(p, _(\"1 character\"));", "    else {", "      sprintf((char *)p, _(\"%\" PRId64 \" characters\"), (int64_t)nchars);"], "readability/braces"]
["src/nvim/fileio.c", ["    else {", "      sprintf((char *)p, _(\"%\" PRId64 \" characters\"), (int64_t)nchars);", "    }"], "runtime/printf"]
["src/nvim/fileio.c", ["", "/*", " * Append message for missing line separator to IObuff."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  STRCAT(IObuff,", "      shortmess(SHM_LAST) ? _(\"[noeol]\") : _(\"[Incomplete last line]\"));", "}"], "whitespace/alignment"]
["src/nvim/fileio.c", ["", "/*", " * Check modification time of file, before writing to it."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#if defined(__linux__) || defined(MSWIN)", "  /* On a FAT filesystem, esp. under Linux, there are only 5 bits to store", "   * the seconds.  Since the roundoff is done when flushing the inode, the"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/*", " * Call write() to write a number of bytes to the file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  int wlen;", "  char_u      *buf = ip->bw_buf;        /* data to write */", "  int len = ip->bw_len;                 /* length of data */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  char_u      *buf = ip->bw_buf;        /* data to write */", "  int len = ip->bw_len;                 /* length of data */", "#ifdef HAS_BW_FLAGS"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#ifdef HAS_BW_FLAGS", "  int flags = ip->bw_flags;             /* extra flags */", "#endif"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Skip conversion when writing the BOM."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (flags & FIO_UTF8) {", "      /*", "       * Convert latin1 in the buffer to UTF-8 in the file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["       */", "      p = ip->bw_conv_buf;              /* translate to buffer */", "      for (wlen = 0; wlen < len; ++wlen)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      p = ip->bw_conv_buf;              /* translate to buffer */", "      for (wlen = 0; wlen < len; ++wlen)", "        p += utf_char2bytes(buf[wlen], p);"], "readability/braces"]
["src/nvim/fileio.c", ["      p = ip->bw_conv_buf;              /* translate to buffer */", "      for (wlen = 0; wlen < len; ++wlen)", "        p += utf_char2bytes(buf[wlen], p);"], "readability/increment"]
["src/nvim/fileio.c", ["    } else if (flags & (FIO_UCS4 | FIO_UTF16 | FIO_UCS2 | FIO_LATIN1)) {", "      /*", "       * Convert UTF-8 bytes in the buffer to UCS-2, UCS-4, UTF-16 or"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["       */", "      if (flags & FIO_LATIN1)", "        p = buf;                /* translate in-place (can only get shorter) */"], "readability/braces"]
["src/nvim/fileio.c", ["      if (flags & FIO_LATIN1)", "        p = buf;                /* translate in-place (can only get shorter) */", "      else"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        p = buf;                /* translate in-place (can only get shorter) */", "      else", "        p = ip->bw_conv_buf;            /* translate to buffer */"], "readability/braces"]
["src/nvim/fileio.c", ["      else", "        p = ip->bw_conv_buf;            /* translate to buffer */", "      for (wlen = 0; wlen < len; wlen += n) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "          /* Use remainder of previous call.  Append the start of", "           * buf[] to get a full sequence.  Might still be too"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          l = CONV_RESTLEN - ip->bw_restlen;", "          if (l > len)", "            l = len;"], "readability/braces"]
["src/nvim/fileio.c", ["          if (n > ip->bw_restlen + len) {", "            /* We have an incomplete byte sequence at the end to", "             * be written.  We can't convert it without the"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["             * remaining bytes.  Keep them for the next call. */", "            if (ip->bw_restlen + len > CONV_RESTLEN)", "              return FAIL;"], "readability/braces"]
["src/nvim/fileio.c", ["          }", "          if (n > 1)", "            c = utf_ptr2char(ip->bw_rest);"], "readability/braces"]
["src/nvim/fileio.c", ["            c = utf_ptr2char(ip->bw_rest);", "          else", "            c = ip->bw_rest[0];"], "readability/braces"]
["src/nvim/fileio.c", ["            memmove(ip->bw_rest, ip->bw_rest + n,", "                (size_t)ip->bw_restlen);", "            n = 0;"], "whitespace/alignment"]
["src/nvim/fileio.c", ["          if (n > len - wlen) {", "            /* We have an incomplete byte sequence at the end to", "             * be written.  We can't convert it without the"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["             * remaining bytes.  Keep them for the next call. */", "            if (len - wlen > CONV_RESTLEN)", "              return FAIL;"], "readability/braces"]
["src/nvim/fileio.c", ["            memmove(ip->bw_rest, buf + wlen,", "                (size_t)ip->bw_restlen);", "            break;"], "whitespace/alignment"]
["src/nvim/fileio.c", ["          }", "          if (n > 1)", "            c = utf_ptr2char(buf + wlen);"], "readability/braces"]
["src/nvim/fileio.c", ["            c = utf_ptr2char(buf + wlen);", "          else", "            c = buf[wlen];"], "readability/braces"]
["src/nvim/fileio.c", ["        if (ucs2bytes(c, &p, flags) && !ip->bw_conv_error) {", "          ip->bw_conv_error = TRUE;", "          ip->bw_conv_error_lnum = ip->bw_start_lnum;"], "readability/bool"]
["src/nvim/fileio.c", ["        }", "        if (c == NL)", "          ++ip->bw_start_lnum;"], "readability/braces"]
["src/nvim/fileio.c", ["        if (c == NL)", "          ++ip->bw_start_lnum;", "      }"], "readability/increment"]
["src/nvim/fileio.c", ["      }", "      if (flags & FIO_LATIN1)", "        len = (int)(p - buf);"], "readability/braces"]
["src/nvim/fileio.c", ["        len = (int)(p - buf);", "      else {", "        buf = ip->bw_conv_buf;"], "readability/braces"]
["src/nvim/fileio.c", ["        len = (int)(p - buf);", "      else {", "        buf = ip->bw_conv_buf;"], "readability/braces"]
["src/nvim/fileio.c", ["", "      /* Convert with iconv(). */", "      if (ip->bw_restlen > 0) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "        /* Need to concatenate the remainder of the previous call and", "         * the bytes of the current call.  Use the end of the"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "        /* output the initial shift state sequence */", "        (void)iconv(ip->bw_iconv_fd, NULL, NULL, &to, &tolen);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "        /* There is a bug in iconv() on Linux (which appears to be", "         * wide-spread) which sets \"to\" to NULL and messes up \"tolen\"."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        }", "        ip->bw_first = FALSE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["", "      /*", "       * If iconv() has an error or there is not enough room, fail."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          || fromlen > CONV_RESTLEN) {", "        ip->bw_conv_error = TRUE;", "        return FAIL;"], "readability/bool"]
["src/nvim/fileio.c", ["", "      /* copy remainder to ip->bw_rest[] to be used for the next call. */", "      if (fromlen > 0)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      /* copy remainder to ip->bw_rest[] to be used for the next call. */", "      if (fromlen > 0)", "        memmove(ip->bw_rest, (void *)from, fromlen);"], "readability/braces"]
["src/nvim/fileio.c", ["      if (flags & FIO_UTF16) {", "        /* Make two words, ten bits of the character in each.  First", "         * word is 0xd800 - 0xdbff, second one 0xdc00 - 0xdfff */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    }", "  } else { /* Latin1 */", "    if (c >= 0x100) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      *p++ = 0xBF;", "    } else", "      *p++ = c;"], "readability/braces"]
["src/nvim/fileio.c", ["  if (*fenc == NUL || STRCMP(p_enc, fenc) == 0) {", "    same_encoding = TRUE;", "    fenc_flags = 0;"], "readability/bool"]
["src/nvim/fileio.c", ["  } else {", "    /* Ignore difference between \"ansi\" and \"latin1\", \"ucs-4\" and", "     * \"ucs-4be\", etc. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* Encodings differ.  However, conversion is not needed when 'enc' is any", "   * Unicode encoding and the file is UTF-8. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (prop & ENC_2BYTE) {", "      if (prop & ENC_ENDIAN_L)", "        return FIO_UCS2 | FIO_ENDIAN_L;"], "readability/braces"]
["src/nvim/fileio.c", ["    if (prop & ENC_4BYTE) {", "      if (prop & ENC_ENDIAN_L)", "        return FIO_UCS4 | FIO_ENDIAN_L;"], "readability/braces"]
["src/nvim/fileio.c", ["    if (prop & ENC_2WORD) {", "      if (prop & ENC_ENDIAN_L)", "        return FIO_UTF16 | FIO_ENDIAN_L;"], "readability/braces"]
["src/nvim/fileio.c", ["  }", "  if (prop & ENC_LATIN1)", "    return FIO_LATIN1;"], "readability/braces"]
["src/nvim/fileio.c", ["    return FIO_LATIN1;", "  /* must be ENC_DBCS, requires iconv() */", "  return 0;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/*", " * Check for a Unicode BOM (Byte Order Mark) at the start of p[size]."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      && (flags == FIO_ALL || flags == FIO_UTF8 || flags == 0)) {", "    name = \"utf-8\";             /* EF BB BF */", "    len = 3;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        && (flags == FIO_ALL || flags == (FIO_UCS4 | FIO_ENDIAN_L))) {", "      name = \"ucs-4le\";         /* FF FE 00 00 */", "      len = 4;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      len = 4;", "    } else if (flags == (FIO_UCS2 | FIO_ENDIAN_L))", "      name = \"ucs-2le\";         /* FF FE */"], "readability/braces"]
["src/nvim/fileio.c", ["    } else if (flags == (FIO_UCS2 | FIO_ENDIAN_L))", "      name = \"ucs-2le\";         /* FF FE */", "    else if (flags == FIO_ALL || flags == (FIO_UTF16 | FIO_ENDIAN_L))"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      name = \"ucs-2le\";         /* FF FE */", "    else if (flags == FIO_ALL || flags == (FIO_UTF16 | FIO_ENDIAN_L))", "      /* utf-16le is preferred, it also works for ucs-2le text */"], "readability/braces"]
["src/nvim/fileio.c", ["    else if (flags == FIO_ALL || flags == (FIO_UTF16 | FIO_ENDIAN_L))", "      /* utf-16le is preferred, it also works for ucs-2le text */", "      name = \"utf-16le\";        /* FF FE */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      /* utf-16le is preferred, it also works for ucs-2le text */", "      name = \"utf-16le\";        /* FF FE */", "  } else if (p[0] == 0xfe && p[1] == 0xff"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["                 FIO_UTF16)) {", "    /* Default to utf-16, it works also for ucs-2 text. */", "    if (flags == FIO_UCS2)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    /* Default to utf-16, it works also for ucs-2 text. */", "    if (flags == FIO_UCS2)", "      name = \"ucs-2\";           /* FE FF */"], "readability/braces"]
["src/nvim/fileio.c", ["    if (flags == FIO_UCS2)", "      name = \"ucs-2\";           /* FE FF */", "    else"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      name = \"ucs-2\";           /* FE FF */", "    else", "      name = \"utf-16\";          /* FE FF */"], "readability/braces"]
["src/nvim/fileio.c", ["    else", "      name = \"utf-16\";          /* FE FF */", "  } else if (size >= 4 && p[0] == 0 && p[1] == 0 && p[2] == 0xfe"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["             && p[3] == 0xff && (flags == FIO_ALL || flags == FIO_UCS4)) {", "    name = \"ucs-4\";             /* 00 00 FE FF */", "    len = 4;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/*", " * Generate a BOM in \"buf[4]\" for encoding \"name\"."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* Can't put a BOM in a non-Unicode file. */", "  if (flags == FIO_LATIN1 || flags == 0)"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  /* Can't put a BOM in a non-Unicode file. */", "  if (flags == FIO_LATIN1 || flags == 0)", "    return 0;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  if (flags == FIO_UTF8) {      /* UTF-8 */", "    buf[0] = 0xef;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  status_redraw_all();", "  redraw_tabline = TRUE;", "}"], "readability/bool"]
["src/nvim/fileio.c", ["    fnamelen = strlen(retval);", "    prepend_dot = FALSE;  // nothing to prepend a dot to", "  } else {"], "readability/bool"]
["src/nvim/fileio.c", ["    retval = xmalloc(fnamelen + extlen + 3);", "    strcpy(retval, fname);", "  }"], "runtime/printf"]
["src/nvim/fileio.c", ["  // ext can start with '.' and cannot exceed 3 more characters.", "  strcpy(s, ext);", ""], "runtime/printf"]
["src/nvim/fileio.c", ["#ifdef HAVE_ACL", "  vim_acl_T acl;                /* ACL from original file */", "#endif"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * When the names are identical, there is nothing to do.  When they refer"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * Find a name that doesn't exist and is in the same directory."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["     */", "    if (STRLEN(from) >= MAXPATHL - 5)", "      return -1;"], "readability/braces"]
["src/nvim/fileio.c", ["        if (os_rename(from, tempname) == OK) {", "          if (os_rename(tempname, to) == OK)", "            return 0;"], "readability/braces"]
["src/nvim/fileio.c", ["            return 0;", "          /* Strange, the second step failed.  Try moving the", "           * file back and return failure. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        }", "        /* If it fails for one temp name it will most likely fail", "         * for any temp name, give up. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Delete the \"to\" file, this is required on some systems to make the"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * First try a normal rename, return if it works."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["   */", "  if (os_rename(from, to) == OK)", "    return 0;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /*", "   * Rename() failed, try copying the file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* Create the new file with same permissions as the original. */", "  fd_out = os_open((char *)to,"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  fd_out = os_open((char *)to,", "      O_CREAT|O_EXCL|O_WRONLY|O_NOFOLLOW, (int)perm);", "  if (fd_out < 0) {"], "whitespace/alignment"]
["src/nvim/fileio.c", ["", "  while ((n = read_eintr(fd_in, buffer, BUFSIZE)) > 0)", "    if (write_eintr(fd_out, buffer, n) != n) {"], "readability/braces"]
["src/nvim/fileio.c", ["  close(fd_in);", "  if (close(fd_out) < 0)", "    errmsg = _(\"E209: Error closing \\\"%s\\\"\");"], "readability/braces"]
["src/nvim/fileio.c", ["", "static int already_warned = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  /* Don't check timestamps while system() or another low-level function may", "   * cause us to lose and gain focus. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["   * cause us to lose and gain focus. */", "  if (no_check_timestamps > 0)", "    return FALSE;"], "readability/braces"]
["src/nvim/fileio.c", ["  if (no_check_timestamps > 0)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  /* Avoid doing a check twice.  The OK/Reload dialog can cause a focus", "   * event and we would keep on checking if the file is steadily growing."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (focus && did_check_timestamps) {", "    need_check_timestamps = TRUE;", "    return FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    need_check_timestamps = TRUE;", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["    }", "    --no_wait_return;", "    need_check_timestamps = FALSE;"], "readability/increment"]
["src/nvim/fileio.c", ["    --no_wait_return;", "    need_check_timestamps = FALSE;", "    if (need_wait_return && didit == 2) {"], "readability/bool"]
["src/nvim/fileio.c", ["", "/*", " * Move all the lines from buffer \"frombuf\" to buffer \"tobuf\"."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* Copy the lines in \"frombuf\" to \"tobuf\". */", "  curbuf = tobuf;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* Delete all the lines in \"frombuf\". */", "  if (retval != FAIL) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/*", " * Check if buffer \"buf\" has been changed."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  // recursively: ignore this buffer.", "  if (buf->terminal", "      || buf->b_ffname == NULL"], "readability/braces"]
["src/nvim/fileio.c", ["", "    /* Don't do anything for a directory.  Might contain the file", "     * explorer. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            mesg = _(", "                \"W12: Warning: File \\\"%s\\\" has changed and the buffer was changed in Vim as well\");", "            mesg2 = _(\"See \\\":help W12\\\" for more info.\");"], "whitespace/line_length"]
["src/nvim/fileio.c", ["            mesg = _(", "                \"W16: Warning: Mode of file \\\"%s\\\" has changed since editing started\");", "            mesg2 = _(\"See \\\":help W16\\\" for more info.\");"], "whitespace/line_length"]
["src/nvim/fileio.c", ["            mesg2 = _(\"See \\\":help W16\\\" for more info.\");", "          } else", "            /* Only timestamp changed, store it to avoid a warning"], "readability/braces"]
["src/nvim/fileio.c", ["          } else", "            /* Only timestamp changed, store it to avoid a warning", "             * in check_mtime() later. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    retval = 1;", "    mesg = _(\"W13: Warning: File \\\"%s\\\" has been created after editing started\");", "    buf->b_flags |= BF_NEW_W;"], "whitespace/line_length"]
["src/nvim/fileio.c", ["      }", "      if (do_dialog(VIM_WARNING, (char_u *) _(\"Warning\"), (char_u *) tbuf,", "                    (char_u *) _(\"&OK\\n&Load File\"), 1, NULL, true) == 2) {"], "whitespace/cast"]
["src/nvim/fileio.c", ["      if (do_dialog(VIM_WARNING, (char_u *) _(\"Warning\"), (char_u *) tbuf,", "                    (char_u *) _(\"&OK\\n&Load File\"), 1, NULL, true) == 2) {", "        reload = true;"], "whitespace/cast"]
["src/nvim/fileio.c", ["      }", "      already_warned = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["  if (reload) {", "    /* Reload the buffer. */", "    buf_reload(buf, orig_mode);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "      /* Any existing undo file is unusable, write it now. */", "      curbuf = buf;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      u_compute_hash(hash);", "      u_write_undo(NULL, FALSE, buf, hash);", "      curbuf = save_curbuf;"], "readability/bool"]
["src/nvim/fileio.c", ["", "/*", " * Reload a buffer that is already loaded."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* set curwin/curbuf for \"buf\" and save some things */", "  aucmd_prepbuf(&aco, buf);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (p_ur < 0 || curbuf->b_ml.ml_line_count <= p_ur) {", "    /* Save all the text, so that the reload can be undone.", "     * Sync first so that this is a separate undo-able action. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["     * Sync first so that this is a separate undo-able action. */", "    u_sync(FALSE);", "    saved = u_savecommon(0, curbuf->b_ml.ml_line_count + 1, 0, TRUE);"], "readability/bool"]
["src/nvim/fileio.c", ["    u_sync(FALSE);", "    saved = u_savecommon(0, curbuf->b_ml.ml_line_count + 1, 0, TRUE);", "    flags |= READ_KEEP_UNDO;"], "readability/bool"]
["src/nvim/fileio.c", ["    if (savebuf != NULL && buf == curbuf) {", "      /* Open the memline. */", "      curbuf = savebuf;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      EMSG2(_(\"E462: Could not prepare for reloading \\\"%s\\\"\"),", "          buf->b_fname);", "      saved = FAIL;"], "whitespace/alignment"]
["src/nvim/fileio.c", ["", "  /* Invalidate diff info if necessary. */", "  diff_invalidate(curbuf);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* Restore the topline and cursor position and check it (lines may", "   * have been removed). */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["   * have been removed). */", "  if (old_topline > curbuf->b_ml.ml_line_count)", "    curwin->w_topline = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/fileio.c", ["    curwin->w_topline = curbuf->b_ml.ml_line_count;", "  else", "    curwin->w_topline = old_topline;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /* Update folds unless they are defined manually. */", "  FOR_ALL_TAB_WINDOWS(tp, wp) {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* If the mode didn't change and 'readonly' was set, keep the old", "   * value; the user probably used the \":view\" command.  But don't"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["   * reset it, might have had a read error. */", "  if (orig_mode == curbuf->b_orig_mode)", "    curbuf->b_p_ro |= old_ro;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /* Modelines must override settings done by autocommands. */", "  do_modelines(0);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* restore curwin/curbuf and a few other things */", "  aucmd_restbuf(&aco);"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  aucmd_restbuf(&aco);", "  /* Careful: autocommands may have made \"buf\" invalid! */", "}"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/*", " * Adjust the line with missing eol, used for the next write."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["{", "  if (curbuf->b_no_eol_lnum != 0)       /* only if there is a missing eol */", "    curbuf->b_no_eol_lnum += offset;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["{", "  if (curbuf->b_no_eol_lnum != 0)       /* only if there is a missing eol */", "    curbuf->b_no_eol_lnum += offset;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  regmatch.rm_ic = p_fic;   /* ignore case if 'fileignorecase' is set */", "  {"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  {", "    if (prog != NULL)", "      regmatch.regprog = *prog;"], "readability/braces"]
["src/nvim/fileio.c", ["      regmatch.regprog = *prog;", "    else", "      regmatch.regprog = vim_regcomp(pattern, RE_MAGIC);"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /*", "   * Try for a match with the pattern with:"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  int nested = 0;", "  int add_dollar = TRUE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  if (allow_dirs != NULL)", "    *allow_dirs = FALSE;"], "readability/braces"]
["src/nvim/fileio.c", ["  if (allow_dirs != NULL)", "    *allow_dirs = FALSE;", "  if (pat_end == NULL)"], "readability/bool"]
["src/nvim/fileio.c", ["    *allow_dirs = FALSE;", "  if (pat_end == NULL)", "    pat_end = pat + STRLEN(pat);"], "readability/braces"]
["src/nvim/fileio.c", ["    case '~':", "      size += 2;                /* extra backslash */", "      break;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    case '/':", "      size += 4;                /* could become \"[\\/]\" */", "      break;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  if (pat[0] == '*')", "    while (pat[0] == '*' && pat < pat_end - 1)"], "readability/braces"]
["src/nvim/fileio.c", ["  if (pat[0] == '*')", "    while (pat[0] == '*' && pat < pat_end - 1)", "      pat++;"], "readability/braces"]
["src/nvim/fileio.c", ["      pat++;", "  else", "    reg_pat[i++] = '^';"], "readability/braces"]
["src/nvim/fileio.c", ["      reg_pat[i++] = '*';", "      while (p[1] == '*')               /* \"**\" matches like \"*\" */", "        ++p;"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      reg_pat[i++] = '*';", "      while (p[1] == '*')               /* \"**\" matches like \"*\" */", "        ++p;"], "readability/braces"]
["src/nvim/fileio.c", ["      while (p[1] == '*')               /* \"**\" matches like \"*\" */", "        ++p;", "      break;"], "readability/increment"]
["src/nvim/fileio.c", ["    case '\\\\':", "      if (p[1] == NUL)", "        break;"], "readability/braces"]
["src/nvim/fileio.c", ["      if (!no_bslash) {", "        /* translate:", "         * \"\\x\" to \"\\\\x\"  e.g., \"dir\\file\""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          reg_pat[i++] = ']';", "          if (allow_dirs != NULL)", "            *allow_dirs = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["          if (allow_dirs != NULL)", "            *allow_dirs = TRUE;", "          break;"], "readability/bool"]
["src/nvim/fileio.c", ["#endif", "      /* Undo escaping from ExpandEscape():", "       * foo\\?bar -> foo?bar"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      } else {", "        if (allow_dirs != NULL && vim_ispathsep(*p)", "#ifdef BACKSLASH_IN_FILENAME"], "readability/braces"]
["src/nvim/fileio.c", ["            )", "          *allow_dirs = TRUE;", "        reg_pat[i++] = '\\\\';"], "readability/bool"]
["src/nvim/fileio.c", ["      reg_pat[i++] = ']';", "      if (allow_dirs != NULL)", "        *allow_dirs = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["      if (allow_dirs != NULL)", "        *allow_dirs = TRUE;", "      break;"], "readability/bool"]
["src/nvim/fileio.c", ["      reg_pat[i++] = ')';", "      --nested;", "      break;"], "readability/increment"]
["src/nvim/fileio.c", ["        reg_pat[i++] = '|';", "      } else", "        reg_pat[i++] = ',';"], "readability/braces"]
["src/nvim/fileio.c", ["  }", "  if (add_dollar)", "    reg_pat[i++] = '$';"], "readability/braces"]
["src/nvim/fileio.c", ["#if defined(EINTR)", "/*", " * Version of read() that retries when interrupted by EINTR (possibly"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    ret = read(fd, buf, bufsize);", "    if (ret >= 0 || errno != EINTR)", "      break;"], "readability/braces"]
["src/nvim/fileio.c", ["", "/*", " * Version of write() that retries when interrupted by EINTR (possibly"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /* Repeat the write() so long it didn't fail, other than being interrupted", "   * by a signal. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (wlen < 0) {", "      if (errno != EINTR)", "        break;"], "readability/braces"]
["src/nvim/fileio.c", ["        break;", "    } else", "      ret += wlen;"], "readability/braces"]
