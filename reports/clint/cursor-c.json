["src/nvim/cursor.c", ["", "/*", " * Get the screen position of the cursor."], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "/*", " * Get the screen position of character col with a coladd in the cursor line."], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "/*", " * Go to column \"wcol\", and add/insert white space as necessary to get the"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["  } else {", "    /* Virtcol is valid */", "    curwin->w_valid |= VALID_VIRTCOL;"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "/*", " * Try to advance the Cursor to the specified screen column."], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "  if (wcol == MAXCOL || rc == FAIL)", "    curwin->w_valid &= ~VALID_VIRTCOL;"], "readability/braces"]
["src/nvim/cursor.c", ["    curwin->w_valid &= ~VALID_VIRTCOL;", "  else if (*get_cursor_pos_ptr() != TAB) {", "    /* Virtcol is valid when not on a TAB */"], "readability/braces"]
["src/nvim/cursor.c", ["  else if (*get_cursor_pos_ptr() != TAB) {", "    /* Virtcol is valid when not on a TAB */", "    curwin->w_valid |= VALID_VIRTCOL;"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["      curwin->w_curswant = linetabsize(line) + one_more;", "      if (curwin->w_curswant > 0)", "        --curwin->w_curswant;"], "readability/braces"]
["src/nvim/cursor.c", ["      if (curwin->w_curswant > 0)", "        --curwin->w_curswant;", "    }"], "readability/increment"]
["src/nvim/cursor.c", ["      csize = linetabsize(line);", "      if (csize > 0)", "        csize--;"], "readability/braces"]
["src/nvim/cursor.c", ["          && ((State & INSERT) == 0 || (int)wcol > csize + 1)) {", "        /* In case of line wrapping don't move the cursor beyond the", "         * right screen edge.  In Insert mode allow going just beyond"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["    while (col <= wcol && *ptr != NUL) {", "      /* Count a tab for what it's worth (if list mode not on) */", "      csize = win_lbr_chartabsize(curwin, line, ptr, col, &head);"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["    idx = (int)(ptr - line);", "    /*", "     * Handle all the special cases.  The virtual_active() check"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["      idx -= 1;", "      /* Don't count the chars from 'showbreak'. */", "      csize -= head;"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["        && ((col != wcol && col != wcol + 1) || csize > 1)) {", "      /* 'virtualedit' is set: The difference between wcol and col is", "       * filled with spaces. */"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["      if (line[idx] == NUL) {", "        /* Append spaces */", "        int correct = wcol - col;"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["      } else {", "        /* Break a tab */", "        int linelen = (int)STRLEN(line);"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["        int linelen = (int)STRLEN(line);", "        int correct = wcol - col - csize + 1;             /* negative!! */", "        char_u  *newline;"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "        if (-correct > csize)", "          return FAIL;"], "readability/braces"]
["src/nvim/cursor.c", ["", "  if (idx < 0)", "    pos->col = 0;"], "readability/braces"]
["src/nvim/cursor.c", ["    pos->col = 0;", "  else", "    pos->col = idx;"], "readability/braces"]
["src/nvim/cursor.c", ["    if (wcol == MAXCOL) {", "      /* The width of the last character is used to set coladd. */", "      if (!one_more) {"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "/*", " * Return in \"pos\" the position of the cursor advanced to screen column \"wcol\"."], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "/*", " * Increment the cursor position.  See inc() for return values."], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "/*", " * dec(p)"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "/*", " * Make sure curwin->w_cursor.lnum is valid."], "readability/old_style_comment"]
["src/nvim/cursor.c", ["  if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count) {", "    /* If there is a closed fold at the end of the file, put the cursor in", "     * its first line.  Otherwise in the last line. */"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["     * its first line.  Otherwise in the last line. */", "    if (!hasFolding(curbuf->b_ml.ml_line_count,", "            &curwin->w_cursor.lnum, NULL))"], "readability/braces"]
["src/nvim/cursor.c", ["    if (!hasFolding(curbuf->b_ml.ml_line_count,", "            &curwin->w_cursor.lnum, NULL))", "      curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;"], "whitespace/alignment"]
["src/nvim/cursor.c", ["  }", "  if (curwin->w_cursor.lnum <= 0)", "    curwin->w_cursor.lnum = 1;"], "readability/braces"]
["src/nvim/cursor.c", ["", "/*", " * Make sure curwin->w_cursor.col is valid."], "readability/old_style_comment"]
["src/nvim/cursor.c", ["  } else if (win->w_cursor.col >= len) {", "    /* Allow cursor past end-of-line when:", "     * - in Insert mode or restarting Insert mode"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "/*", " * make sure curwin->w_cursor in on a valid character"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "/*", " * Make sure curwin->w_cursor is not on the NUL at the end of the line."], "readability/old_style_comment"]
["src/nvim/cursor.c", ["{", "  if (curwin->w_cursor.col > 0", "      && (!VIsual_active || *p_sel == 'o')"], "readability/braces"]
["src/nvim/cursor.c", ["      && gchar_cursor() == NUL)", "    --curwin->w_cursor.col;", "}"], "readability/increment"]
["src/nvim/cursor.c", ["", "/*", " * When curwin->w_leftcol has changed, adjust the cursor position."], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "  /*", "   * If the cursor is right or left of the screen, move it to last or first"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "  /*", "   * If the start of the character under the cursor is not on the screen,"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["    retval = true;", "    if (coladvance(e + 1) == FAIL) {    /* there isn't another character */", "      curwin->w_leftcol = s;            /* adjust w_leftcol instead */"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["    if (coladvance(e + 1) == FAIL) {    /* there isn't another character */", "      curwin->w_leftcol = s;            /* adjust w_leftcol instead */", "      changed_cline_bef_curs();"], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "  if (retval)", "    curwin->w_set_curswant = true;"], "readability/braces"]
["src/nvim/cursor.c", ["", "/*", " * Write a character at the current cursor position."], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "/*", " * Return pointer to cursor line."], "readability/old_style_comment"]
["src/nvim/cursor.c", ["", "/*", " * Return pointer to cursor position."], "readability/old_style_comment"]
