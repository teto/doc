["src/nvim/charset.c", ["        tilde = true;", "        ++p;", "      }"], "readability/increment"]
["src/nvim/charset.c", ["      if ((*p == '-') && (p[1] != NUL)) {", "        ++p;", ""], "readability/increment"]
["src/nvim/charset.c", ["        }", "        ++c;", "      }"], "readability/increment"]
["src/nvim/charset.c", ["      memmove(buf, trs, (size_t)trs_len);", "      --len;", "    }"], "readability/increment"]
["src/nvim/charset.c", ["/// Otherwise, put the result in buf, limited by buflen, and return buf.", "char_u* str_foldcase(char_u *str, int orglen, char_u *buf, int buflen)", "  FUNC_ATTR_NONNULL_RET"], "whitespace/operators"]
["src/nvim/charset.c", ["  colnr_T col = startcol;", "  char_u *line = s; /* pointer to start of line, for breakindent */", ""], "readability/old_style_comment"]
["src/nvim/charset.c", ["/// @return The number of characters taken up on the screen.", "int win_lbr_chartabsize(win_T *wp, char_u *line, char_u *s, colnr_T col, int *headp)", "{"], "whitespace/line_length"]
["src/nvim/charset.c", ["  colnr_T col2;", "  colnr_T col_adj = 0; /* col + screen size of tab */", "  colnr_T colmax;"], "readability/old_style_comment"]
["src/nvim/charset.c", ["", "      if (col2 >= colmax) { /* doesn't fit */", "        size = colmax - col + col_adj;"], "readability/old_style_comment"]
["src/nvim/charset.c", ["    // Count the \">\" in the last column.", "    ++size;", "    mb_added = 1;"], "readability/increment"]
["src/nvim/charset.c", ["", "      if (wp->w_p_bri)", "        added += get_breakindent_win(wp, line);"], "readability/braces"]
["src/nvim/charset.c", ["  char_u *ptr;    // points to current char", "  char_u *posptr; // points to char at pos->col", "  char_u *line;   // start of the line"], "whitespace/comments"]
["src/nvim/charset.c", ["/// @return Pointer to the character after the skipped digits.", "const char* skipbin(const char *q)", "  FUNC_ATTR_PURE"], "whitespace/operators"]
["src/nvim/charset.c", ["///         characters.", "char_u* skiphex(char_u *q)", "{"], "whitespace/operators"]
["src/nvim/charset.c", ["/// @return Pointer to the digit or (NUL after the string).", "char_u* skiptodigit(char_u *q)", "{"], "whitespace/operators"]
["src/nvim/charset.c", ["/// @return Pointer to the binary character or (NUL after the string).", "const char* skiptobin(const char *q)", "  FUNC_ATTR_PURE"], "whitespace/operators"]
["src/nvim/charset.c", ["/// @return Pointer to the hex character or (NUL after the string).", "char_u* skiptohex(char_u *q)", "{"], "whitespace/operators"]
["src/nvim/charset.c", ["/// @return Pointer to the next whitespace character.", "char_u* skiptowhite_esc(char_u *p) {", "  while (*p != ' ' && *p != '\\t' && *p != NUL) {"], "readability/braces"]
["src/nvim/charset.c", ["/// @return Pointer to the next whitespace character.", "char_u* skiptowhite_esc(char_u *p) {", "  while (*p != ' ' && *p != '\\t' && *p != NUL) {"], "whitespace/operators"]
["src/nvim/charset.c", ["    if (((*p == '\\\\') || (*p == Ctrl_V)) && (*(p + 1) != NUL)) {", "      ++p;", "    }"], "readability/increment"]
["src/nvim/charset.c", ["    }", "    ++p;", "  }"], "readability/increment"]
["src/nvim/charset.c", ["{", "  for (; *p; ++p) {", "    if (rem_backslash(p)) {"], "readability/increment"]
