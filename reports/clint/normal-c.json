["src/nvim/normal.c", ["#include \"nvim/ui.h\"", "#include \"nvim/mouse.h\"", "#include \"nvim/undo.h\""], "build/include"]
["src/nvim/normal.c", ["", "/*", " * The Visual area is remembered for reselection."], "readability/old_style_comment"]
["src/nvim/normal.c", [" */", "static int resel_VIsual_mode = NUL;             /* 'v', 'V', or Ctrl-V */", "static linenr_T resel_VIsual_line_count;        /* number of lines */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["static int resel_VIsual_mode = NUL;             /* 'v', 'V', or Ctrl-V */", "static linenr_T resel_VIsual_line_count;        /* number of lines */", "static colnr_T resel_VIsual_vcol;               /* nr of cols or end col */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["static linenr_T resel_VIsual_line_count;        /* number of lines */", "static colnr_T resel_VIsual_vcol;               /* nr of cols or end col */", "static int VIsual_mode_orig = NUL;              /* saved Visual mode */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["static colnr_T resel_VIsual_vcol;               /* nr of cols or end col */", "static int VIsual_mode_orig = NUL;              /* saved Visual mode */", ""], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * nv_*(): functions called to handle Normal and Visual mode commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Function to be called for a Normal or Visual mode command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/* Values for cmd_flags. */", "#define NV_NCH      0x01          /* may need to get a second char */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["/* Values for cmd_flags. */", "#define NV_NCH      0x01          /* may need to get a second char */", "#define NV_NCH_NOP  (0x02|NV_NCH) /* get second char when no operator pending */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["#define NV_NCH      0x01          /* may need to get a second char */", "#define NV_NCH_NOP  (0x02|NV_NCH) /* get second char when no operator pending */", "#define NV_NCH_ALW  (0x04|NV_NCH) /* always get a second char */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["#define NV_NCH_NOP  (0x02|NV_NCH) /* get second char when no operator pending */", "#define NV_NCH_ALW  (0x04|NV_NCH) /* always get a second char */", "#define NV_LANG     0x08        /* second char needs language adjustment */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["#define NV_NCH_ALW  (0x04|NV_NCH) /* always get a second char */", "#define NV_LANG     0x08        /* second char needs language adjustment */", ""], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "#define NV_SS       0x10        /* may start selection */", "#define NV_SSS      0x20        /* may start selection with shift modifier */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["#define NV_SS       0x10        /* may start selection */", "#define NV_SSS      0x20        /* may start selection with shift modifier */", "#define NV_STS      0x40        /* may stop selection without shift modif. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["#define NV_SSS      0x20        /* may start selection with shift modifier */", "#define NV_STS      0x40        /* may stop selection without shift modif. */", "#define NV_RL       0x80        /* 'rightleft' modifies command */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["#define NV_STS      0x40        /* may stop selection without shift modif. */", "#define NV_RL       0x80        /* 'rightleft' modifies command */", "#define NV_KEEPREG  0x100       /* don't clear regname */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["#define NV_RL       0x80        /* 'rightleft' modifies command */", "#define NV_KEEPREG  0x100       /* don't clear regname */", "#define NV_NCW      0x200       /* not allowed in command-line window */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["#define NV_KEEPREG  0x100       /* don't clear regname */", "#define NV_NCW      0x200       /* not allowed in command-line window */", ""], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Generally speaking, every Normal mode command should either clear any"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * This table contains one entry for every Normal or Visual mode command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["static const struct nv_cmd {", "  int cmd_char;                 /* (first) command character */", "  nv_func_T cmd_func;           /* function for this command */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  int cmd_char;                 /* (first) command character */", "  nv_func_T cmd_func;           /* function for this command */", "  uint16_t cmd_flags;           /* NV_ flags */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  nv_func_T cmd_func;           /* function for this command */", "  uint16_t cmd_flags;           /* NV_ flags */", "  short cmd_arg;                /* value for ca.arg */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  uint16_t cmd_flags;           /* NV_ flags */", "  short cmd_arg;                /* value for ca.arg */", "} nv_cmds[] ="], "readability/old_style_comment"]
["src/nvim/normal.c", ["  uint16_t cmd_flags;           /* NV_ flags */", "  short cmd_arg;                /* value for ca.arg */", "} nv_cmds[] ="], "runtime/int"]
["src/nvim/normal.c", ["", "/* Number of commands in nv_cmds[]. */", "#define NV_CMDS_SIZE ARRAY_SIZE(nv_cmds)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/* Sorted index of commands in nv_cmds[]. */", "static short nv_cmd_idx[NV_CMDS_SIZE];"], "readability/old_style_comment"]
["src/nvim/normal.c", ["/* Sorted index of commands in nv_cmds[]. */", "static short nv_cmd_idx[NV_CMDS_SIZE];", ""], "runtime/int"]
["src/nvim/normal.c", ["", "/* The highest index for which", " * nv_cmds[idx].cmd_char == nv_cmd_idx[nv_cmds[idx].cmd_char] */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Compare functions for qsort() below, that checks the command character"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* The commands are sorted on absolute value. */", "  c1 = nv_cmds[*(const short *)s1].cmd_char;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* The commands are sorted on absolute value. */", "  c1 = nv_cmds[*(const short *)s1].cmd_char;", "  c2 = nv_cmds[*(const short *)s2].cmd_char;"], "runtime/int"]
["src/nvim/normal.c", ["  c1 = nv_cmds[*(const short *)s1].cmd_char;", "  c2 = nv_cmds[*(const short *)s2].cmd_char;", "  if (c1 < 0)"], "runtime/int"]
["src/nvim/normal.c", ["  c2 = nv_cmds[*(const short *)s2].cmd_char;", "  if (c1 < 0)", "    c1 = -c1;"], "readability/braces"]
["src/nvim/normal.c", ["    c1 = -c1;", "  if (c2 < 0)", "    c2 = -c2;"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Initialize the nv_cmd_idx[] table."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* Fill the index table with a one to one relation. */", "  for (short int i = 0; i < (short int)NV_CMDS_SIZE; ++i) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* Fill the index table with a one to one relation. */", "  for (short int i = 0; i < (short int)NV_CMDS_SIZE; ++i) {", "    nv_cmd_idx[i] = i;"], "runtime/int"]
["src/nvim/normal.c", ["  /* Fill the index table with a one to one relation. */", "  for (short int i = 0; i < (short int)NV_CMDS_SIZE; ++i) {", "    nv_cmd_idx[i] = i;"], "readability/increment"]
["src/nvim/normal.c", ["", "  /* Sort the commands by the command character.  */", "  qsort(&nv_cmd_idx, NV_CMDS_SIZE, sizeof(short), nv_compare);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* Sort the commands by the command character.  */", "  qsort(&nv_cmd_idx, NV_CMDS_SIZE, sizeof(short), nv_compare);", ""], "runtime/int"]
["src/nvim/normal.c", ["", "  /* Find the first entry that can't be indexed by the command character. */", "  short int i;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* Find the first entry that can't be indexed by the command character. */", "  short int i;", "  for (i = 0; i < (short int)NV_CMDS_SIZE; ++i) {"], "runtime/int"]
["src/nvim/normal.c", ["  short int i;", "  for (i = 0; i < (short int)NV_CMDS_SIZE; ++i) {", "    if (i != nv_cmds[nv_cmd_idx[i]].cmd_char) {"], "runtime/int"]
["src/nvim/normal.c", ["  short int i;", "  for (i = 0; i < (short int)NV_CMDS_SIZE; ++i) {", "    if (i != nv_cmds[nv_cmd_idx[i]].cmd_char) {"], "readability/increment"]
["src/nvim/normal.c", ["", "/*", " * Search for a command in the commands table."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* A multi-byte character is never a command. */", "  if (cmdchar >= 0x100)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* A multi-byte character is never a command. */", "  if (cmdchar >= 0x100)", "    return -1;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* We use the absolute value of the character.  Special keys have a", "   * negative value, but are sorted on their absolute value. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   * negative value, but are sorted on their absolute value. */", "  if (cmdchar < 0)", "    cmdchar = -cmdchar;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* If the character is in the first part: The character is the index into", "   * nv_cmd_idx[]. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  assert(nv_max_linear < (int)NV_CMDS_SIZE);", "  if (cmdchar <= nv_max_linear)", "    return nv_cmd_idx[cmdchar];"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* Perform a binary search. */", "  bot = nv_max_linear + 1;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    c = nv_cmds[nv_cmd_idx[i]].cmd_char;", "    if (c < 0)", "      c = -c;"], "readability/braces"]
["src/nvim/normal.c", ["    }", "    if (cmdchar > c)", "      bot = i + 1;"], "readability/braces"]
["src/nvim/normal.c", ["      bot = i + 1;", "    else", "      top = i - 1;"], "readability/braces"]
["src/nvim/normal.c", ["      if (*cp == Ctrl_K && ((nv_cmds[s->idx].cmd_flags & NV_LANG)", "              || cp == &s->ca.extra_char)", "          && vim_strchr(p_cpo, CPO_DIGRAPH) == NULL) {"], "whitespace/alignment"]
["src/nvim/normal.c", ["    } else if ((s->ca.nchar == 'n' || s->ca.nchar == 'N')", "        && s->ca.cmdchar == 'g') {", "      s->ca.oap->op_type = get_op_type(*cp, NUL);"], "whitespace/alignment"]
["src/nvim/normal.c", ["      if (!utf_iscomposing(s->c)) {", "        vungetc(s->c);                   /* it wasn't, put it back */", "        break;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  while ((s->c >= '1' && s->c <= '9') || (s->ca.count0 != 0", "        && (s->c == K_DEL || s->c == K_KDEL || s->c == '0'))) {", "    if (s->c == K_DEL || s->c == K_KDEL) {"], "whitespace/alignment"]
["src/nvim/normal.c", ["", "    ++no_zero_mapping;                // don't map zero here", "    s->c = plain_vgetc();"], "readability/increment"]
["src/nvim/normal.c", ["    LANGMAP_ADJUST(s->c, true);", "    --no_zero_mapping;", "    if (s->ctrl_w) {"], "readability/increment"]
["src/nvim/normal.c", ["  if (s->oa.op_type == OP_NOP", "             && ((restart_edit != 0 && !VIsual_active && s->old_mapped_len == 0)", "                 || restart_VIsual_select == 1)"], "whitespace/alignment"]
["src/nvim/normal.c", ["                 || restart_VIsual_select == 1)", "             && !(s->ca.retval & CA_COMMAND_BUSY)", "             && stuff_empty()"], "whitespace/alignment"]
["src/nvim/normal.c", ["             && !(s->ca.retval & CA_COMMAND_BUSY)", "             && stuff_empty()", "             && s->oa.regname == 0) {"], "whitespace/alignment"]
["src/nvim/normal.c", ["             && stuff_empty()", "             && s->oa.regname == 0) {", "    if (restart_VIsual_select == 1) {"], "whitespace/alignment"]
["src/nvim/normal.c", ["  s->command_finished = false;", "  s->ctrl_w = false;                  /* got CTRL-W command */", "  s->old_col = curwin->w_curswant;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  } else if (s->old_mapped_len || (VIsual_active && s->mapped_len == 0", "        && typebuf_maplen() > 0)) {", "    s->old_mapped_len = typebuf_maplen();"], "whitespace/alignment"]
["src/nvim/normal.c", ["  if (VIsual_active && VIsual_select && (vim_isprintc(s->c)", "        || s->c == NL || s->c == CAR || s->c == K_KENTER)) {", "    // Fake a \"c\"hange command.  When \"restart_edit\" is set (e.g., because"], "whitespace/alignment"]
["src/nvim/normal.c", ["", "  while (normal_get_command_count(s)) continue;", ""], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Set v:count and v:count1 according to \"cap\"."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* multiply with cap->opcount the same way as above */", "  if (cap->opcount != 0)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* multiply with cap->opcount the same way as above */", "  if (cap->opcount != 0)", "    count = cap->opcount * (count == 0 ? 1 : count);"], "readability/braces"]
["src/nvim/normal.c", ["  set_vcount(count, count == 0 ? 1 : count, *set_prevcount);", "  *set_prevcount = false;    /* only set v:prevcount once */", "}"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * If an operation is pending, handle it..."], "readability/old_style_comment"]
["src/nvim/normal.c", ["      prep_redo(oap->regname, cap->count0,", "          get_op_char(oap->op_type), get_extra_op_char(oap->op_type),", "          oap->motion_force, cap->cmdchar, cap->nchar);"], "whitespace/alignment"]
["src/nvim/normal.c", ["          get_op_char(oap->op_type), get_extra_op_char(oap->op_type),", "          oap->motion_force, cap->cmdchar, cap->nchar);", "      if (cap->cmdchar == '/' || cap->cmdchar == '?') {     /* was a search */"], "whitespace/alignment"]
["src/nvim/normal.c", ["          oap->motion_force, cap->cmdchar, cap->nchar);", "      if (cap->cmdchar == '/' || cap->cmdchar == '?') {     /* was a search */", "        /*"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      if (cap->cmdchar == '/' || cap->cmdchar == '?') {     /* was a search */", "        /*", "         * If 'cpoptions' does not contain 'r', insert the search"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (redo_VIsual_busy) {", "      /* Redo of an operation on a Visual area. Use the same size from", "       * redo_VIsual_line_count and redo_VIsual_vcol. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      curwin->w_cursor.lnum += redo_VIsual_line_count - 1;", "      if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)", "        curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/normal.c", ["              curwin->w_virtcol + redo_VIsual_vcol - 1;", "          } else", "            curwin->w_curswant = redo_VIsual_vcol;"], "readability/braces"]
["src/nvim/normal.c", ["      if (!gui_yank) {", "        /* Save the current VIsual area for '< and '> marks, and \"gv\" */", "        curbuf->b_visual.vi_start = VIsual;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      }", "      /* If 'selection' is \"exclusive\", backup one character for", "       * charwise selections. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["       * charwise selections. */", "      else if (VIsual_mode == 'v') {", "        include_line_break ="], "whitespace/newline"]
["src/nvim/normal.c", ["", "    /*", "     * Set oap->start to the first position of the operated text, oap->end"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (lt(oap->start, curwin->w_cursor)) {", "      /* Include folded lines completely. */", "      if (!VIsual_active) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      if (!VIsual_active) {", "        if (hasFolding(oap->start.lnum, &oap->start.lnum, NULL))", "          oap->start.col = 0;"], "readability/braces"]
["src/nvim/normal.c", ["", "      /* w_virtcol may have been updated; if the cursor goes back to its", "       * previous position w_virtcol becomes invalid and isn't updated"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    /* Set \"virtual_op\" before resetting VIsual_active. */", "    virtual_op = virtual_active();"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      if (!redo_VIsual_busy && !gui_yank) {", "        /*", "         * Prepare to reselect and redo Visual: this is based on the"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        resel_VIsual_mode = VIsual_mode;", "        if (curwin->w_curswant == MAXCOL)", "          resel_VIsual_vcol = MAXCOL;"], "readability/braces"]
["src/nvim/normal.c", ["          resel_VIsual_vcol = MAXCOL;", "        else {", "          if (VIsual_mode != Ctrl_V)"], "readability/braces"]
["src/nvim/normal.c", ["          resel_VIsual_vcol = MAXCOL;", "        else {", "          if (VIsual_mode != Ctrl_V)"], "readability/braces"]
["src/nvim/normal.c", ["        else {", "          if (VIsual_mode != Ctrl_V)", "            getvvcol(curwin, &(oap->end),"], "readability/braces"]
["src/nvim/normal.c", ["            getvvcol(curwin, &(oap->end),", "                NULL, NULL, &oap->end_vcol);", "          if (VIsual_mode == Ctrl_V || oap->line_count <= 1) {"], "whitespace/alignment"]
["src/nvim/normal.c", ["          if (VIsual_mode == Ctrl_V || oap->line_count <= 1) {", "            if (VIsual_mode != Ctrl_V)", "              getvvcol(curwin, &(oap->start),"], "readability/braces"]
["src/nvim/normal.c", ["              getvvcol(curwin, &(oap->start),", "                  &oap->start_vcol, NULL, NULL);", "            resel_VIsual_vcol = oap->end_vcol - oap->start_vcol + 1;"], "whitespace/alignment"]
["src/nvim/normal.c", ["            resel_VIsual_vcol = oap->end_vcol - oap->start_vcol + 1;", "          } else", "            resel_VIsual_vcol = oap->end_vcol;"], "readability/braces"]
["src/nvim/normal.c", ["          ) {", "        /* Prepare for redoing.  Only use the nchar field for \"r\",", "         * otherwise it might be the second char of the operator. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "      /*", "       * Switch Visual off now, so screen updating does"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    /*", "     * oap->empty is set when start and end are the same.  The inclusive"], "readability/old_style_comment"]
["src/nvim/normal.c", ["                  && !(virtual_op && oap->start.coladd != oap->end.coladd)", "                  );", "    /*"], "whitespace/parens"]
["src/nvim/normal.c", ["                  );", "    /*", "     * For delete, change and yank, it's an error to operate on an"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    /* Force a redraw when operating on an empty Visual region, when", "     * 'modifiable is off or creating a fold. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["                           || oap->op_type == OP_FOLD", "                           )) {", "      curwin->w_p_lbr = lbr_saved;"], "whitespace/parens"]
["src/nvim/normal.c", ["", "    /*", "     * If the end of an operator is in column one while oap->motion_type"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        if (oap->end.col) {", "          --oap->end.col;", "          oap->inclusive = true;"], "readability/increment"]
["src/nvim/normal.c", ["      }", "    } else", "      oap->end_adjusted = false;"], "readability/braces"]
["src/nvim/normal.c", ["      op_shift(oap, true,", "          oap->is_VIsual ? (int)cap->count1 :", "          1);"], "whitespace/alignment"]
["src/nvim/normal.c", ["          oap->is_VIsual ? (int)cap->count1 :", "          1);", "      auto_format(false, true);"], "whitespace/alignment"]
["src/nvim/normal.c", ["    case OP_JOIN:", "      if (oap->line_count < 2)", "        oap->line_count = 2;"], "readability/braces"]
["src/nvim/normal.c", ["    case OP_DELETE:", "      VIsual_reselect = false;              /* don't reselect now */", "      if (empty_region_error) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    case OP_CHANGE:", "      VIsual_reselect = false;              /* don't reselect now */", "      if (empty_region_error) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      } else {", "        /* This is a new edit command, not a restart.  Need to", "         * remember it to make 'insertmode' work with mappings for"], "readability/old_style_comment"]
["src/nvim/normal.c", ["         * 'insertmode' isn't set. */", "        if (p_im || !KeyTyped)", "          restart_edit_save = restart_edit;"], "readability/braces"]
["src/nvim/normal.c", ["          restart_edit_save = restart_edit;", "        else", "          restart_edit_save = 0;"], "readability/braces"]
["src/nvim/normal.c", ["        finish_op = false;", "        if (op_change(oap))             /* will call edit() */", "          cap->retval |= CA_COMMAND_BUSY;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        finish_op = false;", "        if (op_change(oap))             /* will call edit() */", "          cap->retval |= CA_COMMAND_BUSY;"], "readability/braces"]
["src/nvim/normal.c", ["          cap->retval |= CA_COMMAND_BUSY;", "        if (restart_edit == 0)", "          restart_edit = restart_edit_save;"], "readability/braces"]
["src/nvim/normal.c", ["", "      /*", "       * If 'equalprg' is empty, do the indenting internally."], "readability/old_style_comment"]
["src/nvim/normal.c", ["        op_reindent(oap,", "            *curbuf->b_p_inde != NUL ? get_expr_indent :", "            get_c_indent);"], "whitespace/alignment"]
["src/nvim/normal.c", ["            *curbuf->b_p_inde != NUL ? get_expr_indent :", "            get_c_indent);", "        break;"], "whitespace/alignment"]
["src/nvim/normal.c", ["        CancelRedo();", "      } else", "        op_tilde(oap);"], "readability/braces"]
["src/nvim/normal.c", ["    case OP_FORMAT2:", "      op_format(oap, true);             /* use internal function */", "      break;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    case OP_APPEND:", "      VIsual_reselect = false;          /* don't reselect now */", "      if (empty_region_error) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      } else {", "        /* This is a new edit command, not a restart.  Need to", "         * remember it to make 'insertmode' work with mappings for"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "        /* TODO: when inserting in several lines, should format all", "         * the lines. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    case OP_REPLACE:", "      VIsual_reselect = false;          /* don't reselect now */", "      if (empty_region_error) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (!gui_yank) {", "      /*", "       * if 'sol' not set, go back to old column for some commands"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Handle indent and format operators and visual mode \":\"."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * do_cmdline() does the rest"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Handle the \"g@\" operator: call 'operatorfunc'."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (*p_opfunc == NUL)", "    EMSG(_(\"E774: 'operatorfunc' is empty\"));"], "readability/braces"]
["src/nvim/normal.c", ["    EMSG(_(\"E774: 'operatorfunc' is empty\"));", "  else {", "    /* Set '[ and '] marks to text to be operated on. */"], "readability/braces"]
["src/nvim/normal.c", ["    EMSG(_(\"E774: 'operatorfunc' is empty\"));", "  else {", "    /* Set '[ and '] marks to text to be operated on. */"], "readability/braces"]
["src/nvim/normal.c", ["  else {", "    /* Set '[ and '] marks to text to be operated on. */", "    curbuf->b_op_start = oap->start;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Do the appropriate action for the current mouse click in the current mode."], "readability/old_style_comment"]
["src/nvim/normal.c", ["bool", "do_mouse (", "    oparg_T *oap,               /* operator argument, can be NULL */"], "whitespace/parens"]
["src/nvim/normal.c", ["do_mouse (", "    oparg_T *oap,               /* operator argument, can be NULL */", "    int c,                          /* K_LEFTMOUSE, etc */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    oparg_T *oap,               /* operator argument, can be NULL */", "    int c,                          /* K_LEFTMOUSE, etc */", "    int dir,                        /* Direction to 'put' if necessary */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    int c,                          /* K_LEFTMOUSE, etc */", "    int dir,                        /* Direction to 'put' if necessary */", "    long count,"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    long count,", "    bool fixindent                  /* PUT_FIXINDENT if fixing indent necessary */", ")"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    long count,", "    bool fixindent                  /* PUT_FIXINDENT if fixing indent necessary */", ")"], "whitespace/line_length"]
["src/nvim/normal.c", ["{", "  static bool got_click = false;        /* got a click some time back */", ""], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  int which_button;             /* MOUSE_LEFT, _MIDDLE or _RIGHT */", "  bool is_click;                /* If false it's a drag or release event */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  int which_button;             /* MOUSE_LEFT, _MIDDLE or _RIGHT */", "  bool is_click;                /* If false it's a drag or release event */", "  bool is_drag;                 /* If true it's a drag event */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  bool is_click;                /* If false it's a drag or release event */", "  bool is_drag;                 /* If true it's a drag event */", "  int jump_flags = 0;           /* flags for jump_to_mouse() */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  bool is_drag;                 /* If true it's a drag event */", "  int jump_flags = 0;           /* flags for jump_to_mouse() */", "  pos_T start_visual;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  pos_T start_visual;", "  bool moved;                   /* Has cursor moved? */", "  bool in_status_line;          /* mouse in status line */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  bool moved;                   /* Has cursor moved? */", "  bool in_status_line;          /* mouse in status line */", "  static bool in_tab_line = false;   /* mouse clicked in tab line */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  bool in_status_line;          /* mouse in status line */", "  static bool in_tab_line = false;   /* mouse clicked in tab line */", "  bool in_sep_line;             /* mouse in vertical separator line */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  static bool in_tab_line = false;   /* mouse clicked in tab line */", "  bool in_sep_line;             /* mouse in vertical separator line */", "  int c1, c2;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (is_drag) {", "      /* If the next character is the same mouse event then use that", "       * one. Speeds up dragging the status line. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "        /* Need to get the character, peeking doesn't get the actual", "         * one. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        nc = safe_vgetc();", "        if (c == nc)", "          continue;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * Ignore drag and release events if we didn't get a click."], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  if (is_click)", "    got_click = true;"], "readability/braces"]
["src/nvim/normal.c", ["    got_click = true;", "  else {", "    if (!got_click)                     /* didn't get click, ignore */"], "readability/braces"]
["src/nvim/normal.c", ["    got_click = true;", "  else {", "    if (!got_click)                     /* didn't get click, ignore */"], "readability/braces"]
["src/nvim/normal.c", ["  else {", "    if (!got_click)                     /* didn't get click, ignore */", "      return false;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  else {", "    if (!got_click)                     /* didn't get click, ignore */", "      return false;"], "readability/braces"]
["src/nvim/normal.c", ["      return false;", "    if (!is_drag) {                     /* release, reset got_click */", "      got_click = false;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * CTRL right mouse button does CTRL-T"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (is_click && (mod_mask & MOD_MASK_CTRL) && which_button == MOUSE_RIGHT) {", "    if (State & INSERT)", "      stuffcharReadbuff(Ctrl_O);"], "readability/braces"]
["src/nvim/normal.c", ["      stuffcharReadbuff(Ctrl_O);", "    if (count > 1)", "      stuffnumReadbuff(count);"], "readability/braces"]
["src/nvim/normal.c", ["    stuffcharReadbuff(Ctrl_T);", "    got_click = false;                  /* ignore drag&release now */", "    return false;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * CTRL only works with left mouse button"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  if ((mod_mask & MOD_MASK_CTRL) && which_button != MOUSE_LEFT)", "    return false;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * When a modifier is down, ignore drag and release events, as well as"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  if ((mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT", "                   | MOD_MASK_META))"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * If the button press was used as the movement command for an operator"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  if (!is_click && which_button == MOUSE_MIDDLE)", "    return false;"], "readability/braces"]
["src/nvim/normal.c", ["", "  if (oap != NULL)", "    regname = oap->regname;"], "readability/braces"]
["src/nvim/normal.c", ["    regname = oap->regname;", "  else", "    regname = 0;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * Middle mouse button does a 'put' of the selected text"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (State == NORMAL) {", "      /*", "       * If an operator was pending, we don't know what the user wanted"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "      /*", "       * If visual was active, yank the highlighted text and put it"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      }", "      /*", "       * The rest is below jump_to_mouse()"], "readability/old_style_comment"]
["src/nvim/normal.c", ["       */", "    } else if ((State & INSERT) == 0)", "      return false;"], "readability/braces"]
["src/nvim/normal.c", ["", "    /*", "     * Middle click in insert mode doesn't move the mouse, just insert the"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "          /* Repeat it with CTRL-R CTRL-O r or CTRL-R CTRL-P r */", "          AppendCharToRedobuff(Ctrl_R);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* When dragging or button-up stay in the same window. */", "  if (!is_click)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* When dragging or button-up stay in the same window. */", "  if (!is_click)", "    jump_flags |= MOUSE_FOCUS | MOUSE_DID_MOVE;"], "readability/braces"]
["src/nvim/normal.c", ["", "    /* click in a tab selects that tab page */", "    if (is_click"], "readability/old_style_comment"]
["src/nvim/normal.c", ["              .vval = {", "                .v_number = (varnumber_T) tab_page_click_defs[mouse_col].tabnr", "              },"], "whitespace/cast"]
["src/nvim/normal.c", ["              .v_type = VAR_STRING,", "              .vval = { .v_string = (char_u *) (which_button == MOUSE_LEFT", "                                                ? \"l\""], "whitespace/cast"]
["src/nvim/normal.c", ["                .v_string = (char_u[]) {", "                  (char_u) (mod_mask & MOD_MASK_SHIFT ? 's' : ' '),", "                  (char_u) (mod_mask & MOD_MASK_CTRL ? 'c' : ' '),"], "whitespace/cast"]
["src/nvim/normal.c", ["                  (char_u) (mod_mask & MOD_MASK_SHIFT ? 's' : ' '),", "                  (char_u) (mod_mask & MOD_MASK_CTRL ? 'c' : ' '),", "                  (char_u) (mod_mask & MOD_MASK_ALT ? 'a' : ' '),"], "whitespace/cast"]
["src/nvim/normal.c", ["                  (char_u) (mod_mask & MOD_MASK_CTRL ? 'c' : ' '),", "                  (char_u) (mod_mask & MOD_MASK_ALT ? 'a' : ' '),", "                  (char_u) (mod_mask & MOD_MASK_META ? 'm' : ' '),"], "whitespace/cast"]
["src/nvim/normal.c", ["                  (char_u) (mod_mask & MOD_MASK_ALT ? 'a' : ' '),", "                  (char_u) (mod_mask & MOD_MASK_META ? 'm' : ' '),", "                  NUL"], "whitespace/cast"]
["src/nvim/normal.c", ["", "  /*", "   * When 'mousemodel' is \"popup\" or \"popup_setpos\", translate mouse events:"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        && !(mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))) {", "      /*", "       * NOTE: Ignore right button down and drag mouse events."], "readability/old_style_comment"]
["src/nvim/normal.c", ["      if (is_click) {", "        /* stop Visual mode for a left click in a window, but not when", "         * on a status line */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["         * on a status line */", "        if (VIsual_active)", "          jump_flags |= MOUSE_MAY_STOP_VIS;"], "readability/braces"]
["src/nvim/normal.c", ["      if (is_click && VIsual_active) {", "        /*", "         * Remember the start and end of visual before moving the"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * If an operator is pending, ignore all drags and releases until the"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* When releasing the button let jump_to_mouse() know. */", "  if (!is_click && !is_drag)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* When releasing the button let jump_to_mouse() know. */", "  if (!is_click && !is_drag)", "    jump_flags |= MOUSE_RELEASED;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * JUMP!"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* When jumping to another window, clear a pending operator.  That's a bit", "   * friendlier than beeping and not jumping to that window. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   * friendlier than beeping and not jumping to that window. */", "  if (curwin != old_curwin && oap != NULL && oap->op_type != OP_NOP)", "    clearop(oap);"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* Set global flag that we are extending the Visual area with mouse", "   * dragging; temporarily minimize 'scrolloff'. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* When dragging the mouse above the window, scroll down. */", "  if (is_drag && mouse_row < 0 && !in_status_line) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (start_visual.lnum) {              /* right click in visual mode */", "    /* When ALT is pressed make Visual mode blockwise. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (start_visual.lnum) {              /* right click in visual mode */", "    /* When ALT is pressed make Visual mode blockwise. */", "    if (mod_mask & MOD_MASK_ALT)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    /* When ALT is pressed make Visual mode blockwise. */", "    if (mod_mask & MOD_MASK_ALT)", "      VIsual_mode = Ctrl_V;"], "readability/braces"]
["src/nvim/normal.c", ["", "    /*", "     * In Visual-block mode, divide the area in four, pick up the corner"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      getvcols(curwin, &start_visual, &end_visual, &leftcol, &rightcol);", "      if (curwin->w_curswant > (leftcol + rightcol) / 2)", "        end_visual.col = leftcol;"], "readability/braces"]
["src/nvim/normal.c", ["        end_visual.col = leftcol;", "      else", "        end_visual.col = rightcol;"], "readability/braces"]
["src/nvim/normal.c", ["", "      /* move VIsual to the right column */", "      start_visual = curwin->w_cursor;              /* save the cursor pos */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      /* move VIsual to the right column */", "      start_visual = curwin->w_cursor;              /* save the cursor pos */", "      curwin->w_cursor = end_visual;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      VIsual = curwin->w_cursor;", "      curwin->w_cursor = start_visual;              /* restore the cursor */", "    } else {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    } else {", "      /*", "       * If the click is before the start of visual, change the start."], "readability/old_style_comment"]
["src/nvim/normal.c", ["       */", "      if (lt(curwin->w_cursor, start_visual))", "        VIsual = end_visual;"], "readability/braces"]
["src/nvim/normal.c", ["        VIsual = end_visual;", "      else if (lt(end_visual, curwin->w_cursor))", "        VIsual = start_visual;"], "readability/braces"]
["src/nvim/normal.c", ["        VIsual = start_visual;", "      else {", "        /* In the same line, compare column number */"], "readability/braces"]
["src/nvim/normal.c", ["        VIsual = start_visual;", "      else {", "        /* In the same line, compare column number */"], "readability/braces"]
["src/nvim/normal.c", ["      else {", "        /* In the same line, compare column number */", "        if (end_visual.lnum == start_visual.lnum) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        if (end_visual.lnum == start_visual.lnum) {", "          if (curwin->w_cursor.col - start_visual.col >", "              end_visual.col - curwin->w_cursor.col)"], "readability/braces"]
["src/nvim/normal.c", ["            VIsual = start_visual;", "          else", "            VIsual = end_visual;"], "readability/braces"]
["src/nvim/normal.c", ["        }", "        /* In different lines, compare line number */", "        else {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        /* In different lines, compare line number */", "        else {", "          diff = (curwin->w_cursor.lnum - start_visual.lnum) -"], "whitespace/newline"]
["src/nvim/normal.c", ["        /* In different lines, compare line number */", "        else {", "          diff = (curwin->w_cursor.lnum - start_visual.lnum) -"], "readability/braces"]
["src/nvim/normal.c", ["", "          if (diff > 0)                         /* closest to end */", "            VIsual = start_visual;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "          if (diff > 0)                         /* closest to end */", "            VIsual = start_visual;"], "readability/braces"]
["src/nvim/normal.c", ["            VIsual = start_visual;", "          else if (diff < 0)            /* closest to start */", "            VIsual = end_visual;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["            VIsual = start_visual;", "          else if (diff < 0)            /* closest to start */", "            VIsual = end_visual;"], "readability/braces"]
["src/nvim/normal.c", ["            VIsual = end_visual;", "          else {                                /* in the middle line */", "            if (curwin->w_cursor.col <"], "readability/old_style_comment"]
["src/nvim/normal.c", ["            VIsual = end_visual;", "          else {                                /* in the middle line */", "            if (curwin->w_cursor.col <"], "readability/braces"]
["src/nvim/normal.c", ["            VIsual = end_visual;", "          else {                                /* in the middle line */", "            if (curwin->w_cursor.col <"], "readability/braces"]
["src/nvim/normal.c", ["          else {                                /* in the middle line */", "            if (curwin->w_cursor.col <", "                (start_visual.col + end_visual.col) / 2)"], "readability/braces"]
["src/nvim/normal.c", ["              VIsual = end_visual;", "            else", "              VIsual = start_visual;"], "readability/braces"]
["src/nvim/normal.c", ["  }", "  /*", "   * If Visual mode started in insert mode, execute \"CTRL-O\""], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  else if ((State & INSERT) && VIsual_active)", "    stuffcharReadbuff(Ctrl_O);"], "whitespace/newline"]
["src/nvim/normal.c", ["", "  /*", "   * Middle mouse click: Put text before cursor."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (yank_register_mline(regname)) {", "      if (mouse_past_bottom)", "        dir = FORWARD;"], "readability/braces"]
["src/nvim/normal.c", ["        dir = FORWARD;", "    } else if (mouse_past_eol)", "      dir = FORWARD;"], "readability/braces"]
["src/nvim/normal.c", ["", "    /*", "     * Remember where the paste started, so in edit() Insstart can be set"], "readability/old_style_comment"]
["src/nvim/normal.c", ["     */", "    if (restart_edit != 0)", "      where_paste_started = curwin->w_cursor;"], "readability/braces"]
["src/nvim/normal.c", ["  }", "  /*", "   * Ctrl-Mouse click or double click in a quickfix window jumps to the"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  else if (((mod_mask & MOD_MASK_CTRL)", "            || (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)"], "whitespace/newline"]
["src/nvim/normal.c", ["  }", "  /*", "   * Ctrl-Mouse click (or double click in a help window) jumps to the tag"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  else if ((mod_mask & MOD_MASK_CTRL) || (curbuf->b_help", "                                          && (mod_mask &"], "whitespace/newline"]
["src/nvim/normal.c", ["                                          MOD_MASK_2CLICK)) {", "    if (State & INSERT)", "      stuffcharReadbuff(Ctrl_O);"], "readability/braces"]
["src/nvim/normal.c", ["    stuffcharReadbuff(Ctrl_RSB);", "    got_click = false;                  /* ignore drag&release now */", "  }"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  }", "  /*", "   * Shift-Mouse click searches for the next occurrence of the word under"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  else if ((mod_mask & MOD_MASK_SHIFT)) {", "    if (State & INSERT"], "whitespace/newline"]
["src/nvim/normal.c", ["  else if ((mod_mask & MOD_MASK_SHIFT)) {", "    if (State & INSERT", "        || (VIsual_active && VIsual_select)"], "readability/braces"]
["src/nvim/normal.c", ["      stuffcharReadbuff(Ctrl_O);", "    if (which_button == MOUSE_LEFT)", "      stuffcharReadbuff('*');"], "readability/braces"]
["src/nvim/normal.c", ["      stuffcharReadbuff('*');", "    else        /* MOUSE_RIGHT */", "      stuffcharReadbuff('#');"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      stuffcharReadbuff('*');", "    else        /* MOUSE_RIGHT */", "      stuffcharReadbuff('#');"], "readability/braces"]
["src/nvim/normal.c", ["  }", "  /* Handle double clicks, unless on status line */", "  else if (in_status_line) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* Handle double clicks, unless on status line */", "  else if (in_status_line) {", "  } else if (in_sep_line) {"], "whitespace/newline"]
["src/nvim/normal.c", ["        VIsual_reselect = true;", "        /* start Select mode if 'selectmode' contains \"mouse\" */", "        may_start_select('o');"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK) {", "        /* Double click with ALT pressed makes it blockwise. */", "        if (mod_mask & MOD_MASK_ALT)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        /* Double click with ALT pressed makes it blockwise. */", "        if (mod_mask & MOD_MASK_ALT)", "          VIsual_mode = Ctrl_V;"], "readability/braces"]
["src/nvim/normal.c", ["          VIsual_mode = Ctrl_V;", "        else", "          VIsual_mode = 'v';"], "readability/braces"]
["src/nvim/normal.c", ["          VIsual_mode = 'v';", "      } else if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_3CLICK)", "        VIsual_mode = 'V';"], "readability/braces"]
["src/nvim/normal.c", ["        VIsual_mode = 'V';", "      else if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_4CLICK)", "        VIsual_mode = Ctrl_V;"], "readability/braces"]
["src/nvim/normal.c", ["    }", "    /*", "     * A double click selects a word or a block."], "readability/old_style_comment"]
["src/nvim/normal.c", ["      if (is_click) {", "        /* If the character under the cursor (skipping white space) is", "         * not a word character, try finding a match and select a (),"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        end_visual = curwin->w_cursor;", "        while (gc = gchar_pos(&end_visual), ascii_iswhite(gc))", "          inc(&end_visual);"], "readability/braces"]
["src/nvim/normal.c", ["      if (pos == NULL && (is_click || is_drag)) {", "        /* When not found a match or when dragging: extend to include", "         * a word. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["          find_start_of_word(&VIsual);", "          if (*p_sel == 'e' && *get_cursor_pos_ptr() != NUL)", "            curwin->w_cursor.col +="], "readability/braces"]
["src/nvim/normal.c", ["    }", "    if (is_click)", "      redraw_curbuf_later(INVERTED);            /* update the inversion */"], "readability/braces"]
["src/nvim/normal.c", ["    if (is_click)", "      redraw_curbuf_later(INVERTED);            /* update the inversion */", "  } else if (VIsual_active && !old_active) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  } else if (VIsual_active && !old_active) {", "    if (mod_mask & MOD_MASK_ALT)", "      VIsual_mode = Ctrl_V;"], "readability/braces"]
["src/nvim/normal.c", ["      VIsual_mode = Ctrl_V;", "    else", "      VIsual_mode = 'v';"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* If Visual mode changed show it later. */", "  if ((!VIsual_active && old_active && mode_displayed)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* If Visual mode changed show it later. */", "  if ((!VIsual_active && old_active && mode_displayed)", "      || (VIsual_active && p_smd && msg_silent == 0"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Move \"pos\" back to the start of the word it's in."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Move \"pos\" forward to the end of the word it's in."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (get_mouse_class(line + col) != cclass) {", "      if (*p_sel == 'e')", "        pos->col = col;"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Get class of a character for selection: same class means same word."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * There are a few special cases where we want certain combinations of"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  if (c != NUL && vim_strchr((char_u *)\"-+*/%<>&|^!=\", c) != NULL)", "    return 1;"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * End Visual mode."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "", "  VIsual_active = false;"], "whitespace/blank_line"]
["src/nvim/normal.c", ["", "  /* Save the current VIsual area for '< and '> marks, and \"gv\" */", "  curbuf->b_visual.vi_mode = VIsual_mode;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  curbuf->b_visual_mode_eval = VIsual_mode;", "  if (!virtual_active())", "    curwin->w_cursor.coladd = 0;"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Reset VIsual_active and VIsual_reselect."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    end_visual_mode();", "    redraw_curbuf_later(INVERTED);      /* delete the inversion later */", "  }"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Reset VIsual_active and VIsual_reselect if it's set."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    end_visual_mode();", "    redraw_curbuf_later(INVERTED);      /* delete the inversion later */", "    VIsual_reselect = false;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Like find_ident_under_cursor(), but for any window and any position."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Prepare for redo of a normal command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  prep_redo(cap->oap->regname, cap->count0,", "      NUL, cap->cmdchar, NUL, NUL, cap->nchar);", "}"], "whitespace/alignment"]
["src/nvim/normal.c", ["", "/*", " * Prepare for redo of any command."], "readability/old_style_comment"]
["src/nvim/normal.c", [" */", "static void prep_redo(int regname, long num, int cmd1, int cmd2, int cmd3, int cmd4, int cmd5)", "{"], "whitespace/line_length"]
["src/nvim/normal.c", ["  ResetRedobuff();", "  if (regname != 0) {   /* yank from specified buffer */", "    AppendCharToRedobuff('\"');"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  }", "  if (num)", "    AppendNumberToRedobuff(num);"], "readability/braces"]
["src/nvim/normal.c", ["", "  if (cmd1 != NUL)", "    AppendCharToRedobuff(cmd1);"], "readability/braces"]
["src/nvim/normal.c", ["    AppendCharToRedobuff(cmd1);", "  if (cmd2 != NUL)", "    AppendCharToRedobuff(cmd2);"], "readability/braces"]
["src/nvim/normal.c", ["    AppendCharToRedobuff(cmd2);", "  if (cmd3 != NUL)", "    AppendCharToRedobuff(cmd3);"], "readability/braces"]
["src/nvim/normal.c", ["    AppendCharToRedobuff(cmd3);", "  if (cmd4 != NUL)", "    AppendCharToRedobuff(cmd4);"], "readability/braces"]
["src/nvim/normal.c", ["    AppendCharToRedobuff(cmd4);", "  if (cmd5 != NUL)", "    AppendCharToRedobuff(cmd5);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * check for operator active and clear it"], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (oap->op_type == OP_NOP)", "    return false;"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Check for operator or Visual active.  Clear active operator."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (oap->op_type == OP_NOP", "      && !VIsual_active"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Remove the shift modifier from a special key."], "readability/old_style_comment"]
["src/nvim/normal.c", ["static char_u showcmd_buf[SHOWCMD_BUFLEN];", "static char_u old_showcmd_buf[SHOWCMD_BUFLEN];    /* For push_showcmd() */", "static bool showcmd_is_clear = true;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (!p_sc)", "    return;"], "readability/braces"]
["src/nvim/normal.c", ["", "    /* Show the size of the Visual area. */", "    if (cursor_bot) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "      /* Make 'sbr' empty for a moment to get the correct size. */", "      p_sbr = empty_option;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        if (l == 0) {", "          ++bytes;", "          ++chars;"], "readability/increment"]
["src/nvim/normal.c", ["          ++bytes;", "          ++chars;", "          break;            /* end of line */"], "readability/increment"]
["src/nvim/normal.c", ["          ++chars;", "          break;            /* end of line */", "        }"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        bytes += l;", "        ++chars;", "        s += l;"], "readability/increment"]
["src/nvim/normal.c", ["      }", "      if (bytes == chars)", "        sprintf((char *)showcmd_buf, \"%d\", chars);"], "readability/braces"]
["src/nvim/normal.c", ["      if (bytes == chars)", "        sprintf((char *)showcmd_buf, \"%d\", chars);", "      else"], "runtime/printf"]
["src/nvim/normal.c", ["        sprintf((char *)showcmd_buf, \"%d\", chars);", "      else", "        sprintf((char *)showcmd_buf, \"%d-%d\", chars, bytes);"], "readability/braces"]
["src/nvim/normal.c", ["      else", "        sprintf((char *)showcmd_buf, \"%d-%d\", chars, bytes);", "    }"], "runtime/printf"]
["src/nvim/normal.c", ["", "    /* Don't actually display something if there is nothing to clear. */", "    if (showcmd_is_clear)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    /* Don't actually display something if there is nothing to clear. */", "    if (showcmd_is_clear)", "      return;"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Add 'c' to string of shown command chars."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  static int ignore[] =", "  {", "    K_IGNORE,"], "whitespace/braces"]
["src/nvim/normal.c", ["", "  if (!p_sc || msg_silent != 0)", "    return false;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* Ignore keys that are scrollbar updates and mouse clicks */", "  if (IS_SPECIAL(c))"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* Ignore keys that are scrollbar updates and mouse clicks */", "  if (IS_SPECIAL(c))", "    for (i = 0; ignore[i] != 0; ++i)"], "readability/braces"]
["src/nvim/normal.c", ["  if (IS_SPECIAL(c))", "    for (i = 0; ignore[i] != 0; ++i)", "      if (ignore[i] == c)"], "readability/braces"]
["src/nvim/normal.c", ["  if (IS_SPECIAL(c))", "    for (i = 0; ignore[i] != 0; ++i)", "      if (ignore[i] == c)"], "readability/increment"]
["src/nvim/normal.c", ["    for (i = 0; ignore[i] != 0; ++i)", "      if (ignore[i] == c)", "        return false;"], "readability/braces"]
["src/nvim/normal.c", ["  p = transchar(c);", "  if (*p == ' ')", "    STRCPY(p, \"<20>\");"], "readability/braces"]
["src/nvim/normal.c", ["", "  if (char_avail())", "    return false;"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Delete 'len' characters from the end of the shown command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (!p_sc)", "    return;"], "readability/braces"]
["src/nvim/normal.c", ["  old_len = (int)STRLEN(showcmd_buf);", "  if (len > old_len)", "    len = old_len;"], "readability/braces"]
["src/nvim/normal.c", ["", "  if (!char_avail())", "    display_showcmd();"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * push_showcmd() and pop_showcmd() are used when waiting for the user to type"], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (p_sc)", "    STRCPY(old_showcmd_buf, showcmd_buf);"], "readability/braces"]
["src/nvim/normal.c", ["{", "  if (!p_sc)", "    return;"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * When \"check\" is false, prepare for commands that scroll the window."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (check && curwin->w_p_scb) {", "    /* If a \":syncbind\" command was just used, don't scroll, only reset", "     * the values. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["     * the values. */", "    if (did_syncbind)", "      did_syncbind = false;"], "readability/braces"]
["src/nvim/normal.c", ["      did_syncbind = false;", "    else if (curwin == old_curwin) {", "      /*"], "readability/braces"]
["src/nvim/normal.c", ["    else if (curwin == old_curwin) {", "      /*", "       * Synchronize other windows, as necessary according to"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        check_scrollbind(curwin->w_topline - old_topline,", "            (long)(curwin->w_leftcol - old_leftcol));", "      }"], "whitespace/alignment"]
["src/nvim/normal.c", ["      }", "    } else if (vim_strchr(p_sbo, 'j')) { /* jump flag set in 'scrollopt' */", "      /*"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    } else if (vim_strchr(p_sbo, 'j')) { /* jump flag set in 'scrollopt' */", "      /*", "       * When switching between windows, make sure that the relative"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Synchronize any windows that have \"scrollbind\" set, based on the"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * check 'scrollopt' string for vertical and horizontal scroll options"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * loop through the scrollbound windows and scroll accordingly"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    curbuf = curwin->w_buffer;", "    /* skip original window  and windows with 'noscrollbind' */", "    if (curwin == old_curwin || !curwin->w_p_scb) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    }", "    /*", "     * do the vertical scroll"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        topline = curwin->w_scbind_pos;", "        if (topline > curbuf->b_ml.ml_line_count)", "          topline = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/normal.c", ["          topline = curbuf->b_ml.ml_line_count;", "        if (topline < 1)", "          topline = 1;"], "readability/braces"]
["src/nvim/normal.c", ["        y = topline - curwin->w_topline;", "        if (y > 0)", "          scrollup(y, false);"], "readability/braces"]
["src/nvim/normal.c", ["          scrollup(y, false);", "        else", "          scrolldown(-y, false);"], "readability/braces"]
["src/nvim/normal.c", ["", "    /*", "     * do the horizontal scroll"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * reset current-window"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Command character that's ignored."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  cap->retval |= CA_COMMAND_BUSY;       /* don't call edit() now */", "}"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Command character that doesn't do anything, but unlike nv_ignore() does"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Command character doesn't exist."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * <Help> and <F1> commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (!checkclearopq(cap->oap))", "    ex_help(NULL);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * CTRL-A and CTRL-X: Add or subtract from letter or number under cursor."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * CTRL-F, CTRL-B, etc: Scroll page up or down."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (mod_mask & MOD_MASK_CTRL) {", "      /* <C-PageUp>: tab page back; <C-PageDown>: tab page forward */", "      if (cap->arg == BACKWARD)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      /* <C-PageUp>: tab page back; <C-PageDown>: tab page forward */", "      if (cap->arg == BACKWARD)", "        goto_tabpage(-(int)cap->count1);"], "readability/braces"]
["src/nvim/normal.c", ["        goto_tabpage(-(int)cap->count1);", "      else", "        goto_tabpage((int)cap->count0);"], "readability/braces"]
["src/nvim/normal.c", ["        goto_tabpage((int)cap->count0);", "    } else", "      (void)onepage(cap->arg, cap->count1);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Implementation of \"gd\" and \"gD\" command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["static void", "nv_gd (", "    oparg_T *oap,"], "whitespace/parens"]
["src/nvim/normal.c", ["    int nchar,", "    int thisblock                  /* 1 for \"1gd\" and \"1gD\" */", ")"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Search for variable declaration of \"ptr[len]\"."], "readability/old_style_comment"]
["src/nvim/normal.c", ["bool", "find_decl (", "    char_u *ptr,"], "whitespace/parens"]
["src/nvim/normal.c", ["", "  /* Put \"\\V\" before the pattern to avoid that the special meaning of \".\"", "   * and \"~\" causes trouble. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  assert(len <= INT_MAX);", "  sprintf((char *)pat, vim_iswordp(ptr) ? \"\\\\V\\\\<%.*s\\\\>\" : \"\\\\V%.*s\",", "          (int)len, ptr);"], "runtime/printf"]
["src/nvim/normal.c", ["  save_p_scs = p_scs;", "  p_ws = false;         /* don't wrap around end of file now */", "  p_scs = false;        /* don't switch ignorecase off now */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  p_ws = false;         /* don't wrap around end of file now */", "  p_scs = false;        /* don't switch ignorecase off now */", ""], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * With \"gD\" go to line 1."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (!locally || !findpar(&incll, BACKWARD, 1L, '{', false)) {", "    setpcmark();                        /* Set in findpar() otherwise */", "    curwin->w_cursor.lnum = 1;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    par_pos = curwin->w_cursor;", "    while (curwin->w_cursor.lnum > 1", "           && *skipwhite(get_cursor_line_ptr()) != NUL)"], "readability/braces"]
["src/nvim/normal.c", ["           && *skipwhite(get_cursor_line_ptr()) != NUL)", "      --curwin->w_cursor.lnum;", "  }"], "readability/increment"]
["src/nvim/normal.c", ["", "  /* Search forward for the identifier, ignore comment lines. */", "  clearpos(&found_pos);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (t == false) {", "      /* If we previously found a valid position, use it. */", "      if (found_pos.lnum != 0) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (get_leader_len(get_cursor_line_ptr(), NULL, false, true) > 0) {", "      /* Ignore this line, continue at start of next line. */", "      ++curwin->w_cursor.lnum;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      /* Ignore this line, continue at start of next line. */", "      ++curwin->w_cursor.lnum;", "      curwin->w_cursor.col = 0;"], "readability/increment"]
["src/nvim/normal.c", ["    curwin->w_set_curswant = true;", "    /* \"n\" searches forward now */", "    reset_search_dir();"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Move 'dist' lines in direction 'dir', counting lines by *screen*"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  int n;", "  int col_off1;                 /* margin offset for first screen line */", "  int col_off2;                 /* margin offset for wrapped screen line */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  int col_off1;                 /* margin offset for first screen line */", "  int col_off2;                 /* margin offset for wrapped screen line */", "  int width1;                   /* text width for first screen line */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  int col_off2;                 /* margin offset for wrapped screen line */", "  int width1;                   /* text width for first screen line */", "  int width2;                   /* test width for wrapped screen line */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  int width1;                   /* text width for first screen line */", "  int width2;                   /* test width for wrapped screen line */", ""], "readability/old_style_comment"]
["src/nvim/normal.c", ["      validate_virtcol();", "      if (width1 <= 0)", "        curwin->w_curswant = 0;"], "readability/braces"]
["src/nvim/normal.c", ["        curwin->w_curswant = 0;", "      else {", "        curwin->w_curswant = width1 - 1;"], "readability/braces"]
["src/nvim/normal.c", ["        curwin->w_curswant = 0;", "      else {", "        curwin->w_curswant = width1 - 1;"], "readability/braces"]
["src/nvim/normal.c", ["        curwin->w_curswant = width1 - 1;", "        if (curwin->w_virtcol > curwin->w_curswant)", "          curwin->w_curswant += ((curwin->w_virtcol"], "readability/braces"]
["src/nvim/normal.c", ["    } else {", "      if (linelen > width1)", "        n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;"], "readability/braces"]
["src/nvim/normal.c", ["        n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;", "      else", "        n = width1;"], "readability/braces"]
["src/nvim/normal.c", ["        }", "      } else { /* dir == FORWARD */", "        if (linelen > width1)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      } else { /* dir == FORWARD */", "        if (linelen > width1)", "          n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;"], "readability/braces"]
["src/nvim/normal.c", ["          n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;", "        else", "          n = width1;"], "readability/braces"]
["src/nvim/normal.c", ["", "  if (virtual_active() && atend)", "    coladvance(MAXCOL);"], "readability/braces"]
["src/nvim/normal.c", ["    coladvance(MAXCOL);", "  else", "    coladvance(curwin->w_curswant);"], "readability/braces"]
["src/nvim/normal.c", ["  if (curwin->w_cursor.col > 0 && curwin->w_p_wrap) {", "    /*", "     * Check for landing on a character that got split at the end of the"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    colnr_T virtcol = curwin->w_virtcol;", "    if (virtcol > (colnr_T)width1 && *p_sbr != NUL)", "        virtcol -= vim_strsize(p_sbr);"], "readability/braces"]
["src/nvim/normal.c", ["", "    if (virtcol > curwin->w_curswant", "        && (curwin->w_curswant < (colnr_T)width1"], "readability/braces"]
["src/nvim/normal.c", ["               > (colnr_T)width2 / 2)))", "      --curwin->w_cursor.col;", "  }"], "readability/increment"]
["src/nvim/normal.c", ["", "  if (atend)", "    curwin->w_curswant = MAXCOL;            /* stick in the last column */"], "readability/braces"]
["src/nvim/normal.c", ["  if (atend)", "    curwin->w_curswant = MAXCOL;            /* stick in the last column */", ""], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Mouse scroll wheel: Default action is to scroll three lines, or one page"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Mouse clicks and drags."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Handle CTRL-E and CTRL-Y commands: scroll a line up or down."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (!checkclearop(cap->oap))", "    scroll_redraw(cap->arg, cap->count1);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Scroll \"count\" lines up or down, and redraw."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    /* If moved back to where we were, at least move the cursor, otherwise", "     * we get stuck at one position.  Don't move the cursor up if the"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      if (up) {", "        if (curwin->w_cursor.lnum > prev_lnum", "            || cursor_down(1L, false) == false)"], "readability/braces"]
["src/nvim/normal.c", ["      } else {", "        if (curwin->w_cursor.lnum < prev_lnum", "            || prev_topline == 1L"], "readability/braces"]
["src/nvim/normal.c", ["      }", "      /* Mark w_topline as valid, otherwise the screen jumps back at the", "       * end of the file. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Commands that start with \"z\"."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (ascii_isdigit(nchar)) {", "    /*", "     * \"z123{nchar}\": edit the count before obtaining {nchar}"], "readability/old_style_comment"]
["src/nvim/normal.c", ["     */", "    if (checkclearop(cap->oap))", "      return;"], "readability/braces"]
["src/nvim/normal.c", ["      (void)add_to_showcmd(nchar);", "      if (nchar == K_DEL || nchar == K_KDEL)", "        n /= 10;"], "readability/braces"]
["src/nvim/normal.c", ["        n /= 10;", "      else if (ascii_isdigit(nchar))", "        n = n * 10 + (nchar - '0');"], "readability/braces"]
["src/nvim/normal.c", ["        n = n * 10 + (nchar - '0');", "      else if (nchar == CAR) {", "        win_setheight(n);"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * For \"z+\", \"z<CR>\", \"zt\", \"z.\", \"zz\", \"z^\", \"z-\", \"zb\":"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    setpcmark();", "    if (cap->count0 > curbuf->b_ml.ml_line_count)", "      curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/normal.c", ["      curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;", "    else", "      curwin->w_cursor.lnum = cap->count0;"], "readability/braces"]
["src/nvim/normal.c", ["  switch (nchar) {", "  /* \"z+\", \"z<CR>\" and \"zt\": put cursor at top of screen */", "  case '+':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"z.\" and \"zz\": put cursor in middle of screen */", "  case '.':   beginline(BL_WHITE | BL_FIX);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      curwin->w_cursor.lnum = curwin->w_topline;", "    } else if (curwin->w_topline == 1)", "      curwin->w_cursor.lnum = 1;"], "readability/braces"]
["src/nvim/normal.c", ["      curwin->w_cursor.lnum = 1;", "    else", "      curwin->w_cursor.lnum = curwin->w_topline - 1;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* \"zH\" - scroll screen right half-page */", "  case 'H':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"zh\" - scroll screen to the right */", "  case 'h':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (!curwin->w_p_wrap) {", "      if ((colnr_T)cap->count1 > curwin->w_leftcol)", "        curwin->w_leftcol = 0;"], "readability/braces"]
["src/nvim/normal.c", ["        curwin->w_leftcol = 0;", "      else", "        curwin->w_leftcol -= (colnr_T)cap->count1;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* \"zl\" - scroll screen to the left */", "  case 'l':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (!curwin->w_p_wrap) {", "      /* scroll the window left */", "      curwin->w_leftcol += (colnr_T)cap->count1;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"zs\" - scroll screen, cursor at the start */", "  case 's':   if (!curwin->w_p_wrap) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case 's':   if (!curwin->w_p_wrap) {", "      if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))", "        col = 0;                        /* like the cursor is in col 0 */"], "readability/braces"]
["src/nvim/normal.c", ["      if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))", "        col = 0;                        /* like the cursor is in col 0 */", "      else"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        col = 0;                        /* like the cursor is in col 0 */", "      else", "        getvcol(curwin, &curwin->w_cursor, &col, NULL, NULL);"], "readability/braces"]
["src/nvim/normal.c", ["        getvcol(curwin, &curwin->w_cursor, &col, NULL, NULL);", "      if (col > l_p_siso)", "        col -= l_p_siso;"], "readability/braces"]
["src/nvim/normal.c", ["        col -= l_p_siso;", "      else", "        col = 0;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* \"ze\" - scroll screen, cursor at the end */", "  case 'e':   if (!curwin->w_p_wrap) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case 'e':   if (!curwin->w_p_wrap) {", "      if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))", "        col = 0;                        /* like the cursor is in col 0 */"], "readability/braces"]
["src/nvim/normal.c", ["      if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))", "        col = 0;                        /* like the cursor is in col 0 */", "      else"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        col = 0;                        /* like the cursor is in col 0 */", "      else", "        getvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* \"zF\": create fold command */", "  /* \"zf\": create fold operator */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* \"zF\": create fold command */", "  /* \"zf\": create fold operator */", "  case 'F':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "      /* \"zF\" is like \"zfzf\" */", "      if (nchar == 'F' && cap->oap->op_type == OP_FOLD) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      }", "  } else", "      clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* \"zd\": delete fold at cursor */", "  /* \"zD\": delete fold at cursor recursively */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* \"zd\": delete fold at cursor */", "  /* \"zD\": delete fold at cursor recursively */", "  case 'd':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"zE\": erase all folds */", "  case 'E':   if (foldmethodIsManual(curwin)) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"zn\": fold none: reset 'foldenable' */", "  case 'n':   curwin->w_p_fen = false;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"zN\": fold Normal: set 'foldenable' */", "  case 'N':   curwin->w_p_fen = true;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"zi\": invert folding: toggle 'foldenable' */", "  case 'i':   curwin->w_p_fen = !curwin->w_p_fen;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"zv\": open folds at the cursor */", "  case 'v':   foldOpenCursor();"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"zx\": re-apply 'foldlevel' and open folds at the cursor */", "  case 'x':   curwin->w_p_fen = true;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case 'x':   curwin->w_p_fen = true;", "    curwin->w_foldinvalid = true;               /* recompute folds */", "    newFoldLevel();                             /* update right now */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    curwin->w_foldinvalid = true;               /* recompute folds */", "    newFoldLevel();                             /* update right now */", "    foldOpenCursor();"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"zX\": undo manual opens/closes, re-apply 'foldlevel' */", "  case 'X':   curwin->w_p_fen = true;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case 'X':   curwin->w_p_fen = true;", "    curwin->w_foldinvalid = true;               /* recompute folds */", "    old_fdl = -1;                               /* force an update */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    curwin->w_foldinvalid = true;               /* recompute folds */", "    old_fdl = -1;                               /* force an update */", "    break;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"zm\": fold more */", "  case 'm':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    }", "    old_fdl = -1;                       /* force an update */", "    curwin->w_p_fen = true;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"zM\": close all folds */", "  case 'M':   curwin->w_p_fdl = 0;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case 'M':   curwin->w_p_fdl = 0;", "    old_fdl = -1;                       /* force an update */", "    curwin->w_p_fen = true;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"zr\": reduce folding */", "  case 'r':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  case 'j':     /* \"zj\" move to next fold downwards */", "  case 'k':     /* \"zk\" move to next fold upwards */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case 'j':     /* \"zj\" move to next fold downwards */", "  case 'k':     /* \"zk\" move to next fold upwards */", "    if (foldMoveTo(true, nchar == 'j' ? FORWARD : BACKWARD,"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case 'k':     /* \"zk\" move to next fold upwards */", "    if (foldMoveTo(true, nchar == 'j' ? FORWARD : BACKWARD,", "            cap->count1) == false)"], "readability/braces"]
["src/nvim/normal.c", ["    if (foldMoveTo(true, nchar == 'j' ? FORWARD : BACKWARD,", "            cap->count1) == false)", "      clearopbeep(cap->oap);"], "whitespace/alignment"]
["src/nvim/normal.c", ["", "  case 'g':     /* \"zg\": add good word to word list */", "  case 'w':     /* \"zw\": add wrong word to word list */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case 'g':     /* \"zg\": add good word to word list */", "  case 'w':     /* \"zw\": add wrong word to word list */", "  case 'G':     /* \"zG\": add good word to temp word list */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case 'w':     /* \"zw\": add wrong word to word list */", "  case 'G':     /* \"zG\": add good word to temp word list */", "  case 'W':     /* \"zW\": add wrong word to temp word list */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case 'G':     /* \"zG\": add good word to temp word list */", "  case 'W':     /* \"zW\": add wrong word to temp word list */", "  {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    if (checkclearop(cap->oap))", "      break;"], "readability/braces"]
["src/nvim/normal.c", ["      break;", "    if (VIsual_active && !get_visual_text(cap, &ptr, &len))", "      return;"], "readability/braces"]
["src/nvim/normal.c", ["", "      /* Find bad word under the cursor.  When 'spell' is", "       * off this fails and find_ident_under_cursor() is"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      emsg_off--;", "      if (len != 0 && curwin->w_cursor.col <= pos.col)", "        ptr = ml_get_pos(&curwin->w_cursor);"], "readability/braces"]
["src/nvim/normal.c", ["", "    if (ptr == NULL && (len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)", "      return;"], "readability/braces"]
["src/nvim/normal.c", ["", "  case '=':     /* \"z=\": suggestions for a badly spelled word  */", "    if (!checkclearop(cap->oap))"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case '=':     /* \"z=\": suggestions for a badly spelled word  */", "    if (!checkclearop(cap->oap))", "      spell_suggest((int)cap->count0);"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* Redraw when 'foldenable' changed */", "  if (old_fen != curwin->w_p_fen) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (foldmethodIsDiff(curwin) && curwin->w_p_scb) {", "      /* Adjust 'foldenable' in diff-synced windows. */", "      FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* Redraw when 'foldlevel' changed. */", "  if (old_fdl != curwin->w_p_fdl)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* Redraw when 'foldlevel' changed. */", "  if (old_fdl != curwin->w_p_fdl)", "    newFoldLevel();"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * \"Q\" command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  /*", "   * Ignore 'Q' in Visual mode, just give a beep."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    /* When typing, don't type below an old message */", "    if (KeyTyped)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    /* When typing, don't type below an old message */", "    if (KeyTyped)", "      compute_cmdrow();"], "readability/braces"]
["src/nvim/normal.c", ["", "    /* If 'insertmode' changed, enter or exit Insert mode */", "    if (p_im != old_p_im) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (p_im != old_p_im) {", "      if (p_im)", "        restart_edit = 'i';"], "readability/braces"]
["src/nvim/normal.c", ["        restart_edit = 'i';", "      else", "        restart_edit = 0;"], "readability/braces"]
["src/nvim/normal.c", ["", "    if (cmd_result == false)", "      /* The Ex command failed, do not execute the operator. */"], "readability/braces"]
["src/nvim/normal.c", ["    if (cmd_result == false)", "      /* The Ex command failed, do not execute the operator. */", "      clearop(cap->oap);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      clearop(cap->oap);", "    else if (cap->oap->op_type != OP_NOP", "             && (cap->oap->start.lnum > curbuf->b_ml.ml_line_count"], "readability/braces"]
["src/nvim/normal.c", ["                 || did_emsg", "                 ))", "      /* The start of the operator has become invalid by the Ex command."], "whitespace/parens"]
["src/nvim/normal.c", ["                 ))", "      /* The start of the operator has become invalid by the Ex command.", "       */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Handle CTRL-G command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (VIsual_active) {  /* toggle Selection/Visual mode */", "    VIsual_select = !VIsual_select;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    showmode();", "  } else if (!checkclearop(cap->oap))", "    /* print full name if count given or :cd used */"], "readability/braces"]
["src/nvim/normal.c", ["  } else if (!checkclearop(cap->oap))", "    /* print full name if count given or :cd used */", "    fileinfo((int)cap->count0, false, true);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Handle CTRL-H <Backspace> command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (VIsual_active && VIsual_select) {", "    cap->cmdchar = 'x';         /* BS key behaves like 'x' in Select mode */", "    v_visop(cap);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    v_visop(cap);", "  } else", "    nv_left(cap);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * CTRL-L: clear screen and redraw."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (!checkclearop(cap->oap)) {", "    /* Clear all syntax states to force resyncing. */", "    syn_stack_free_all(curwin->w_s);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * CTRL-O: In Select mode: switch to Visual mode for one command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    showmode();", "    restart_VIsual_select = 2;          /* restart Select mode later */", "  } else {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (!checkclearopq(cap->oap))", "    (void)buflist_getfile((int)cap->count0, (linenr_T)0,"], "readability/braces"]
["src/nvim/normal.c", ["    (void)buflist_getfile((int)cap->count0, (linenr_T)0,", "        GETF_SETMARK|GETF_ALT, false);", "}"], "whitespace/alignment"]
["src/nvim/normal.c", ["", "/*", " * \"Z\" commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    switch (cap->nchar) {", "    /* \"ZZ\": equivalent to \":x\". */", "    case 'Z':   do_cmdline_cmd(\"x\");"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    /* \"ZQ\": equivalent to \":q!\" (Elvis compatible). */", "    case 'Q':   do_cmdline_cmd(\"q!\");"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Call nv_ident() as if \"c1\" was used, with \"c2\" as next character."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Handle the commands that use the word under the cursor."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  char_u      *p;", "  size_t n = 0;                 /* init for GCC */", "  int cmdchar;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  int cmdchar;", "  bool g_cmd;                   /* \"g\" command */", "  bool tag_cmd = false;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (cap->cmdchar == 'g') {    /* \"g*\", \"g#\", \"g]\" and \"gCTRL-]\" */", "    cmdchar = cap->nchar;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (cmdchar == POUND)         /* the pound sign, '#' for English keyboards */", "    cmdchar = '#';"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (cmdchar == POUND)         /* the pound sign, '#' for English keyboards */", "    cmdchar = '#';"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * The \"]\", \"CTRL-]\" and \"K\" commands accept an argument in Visual mode."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (cmdchar == ']' || cmdchar == Ctrl_RSB || cmdchar == 'K') {", "    if (VIsual_active && get_visual_text(cap, &ptr, &n) == false)", "      return;"], "readability/braces"]
["src/nvim/normal.c", ["      return;", "    if (checkclearopq(cap->oap))", "      return;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* Allocate buffer to put the command in.  Inserting backslashes can", "   * double the length of the word.  p_kp / curbuf->b_p_kp could be added"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case '#':", "    /*", "     * Put cursor at start of word, makes search skip the word"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    setpcmark();", "    curwin->w_cursor.col = (colnr_T) (ptr - get_cursor_line_ptr());", ""], "whitespace/cast"]
["src/nvim/normal.c", ["", "    if (!g_cmd && vim_iswordp(ptr))", "      STRCPY(buf, \"\\\\<\");"], "readability/braces"]
["src/nvim/normal.c", ["      STRCPY(buf, \"\\\\<\");", "    no_smartcase = true;                /* don't use 'smartcase' now */", "    break;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    } else {", "      /* An external command will probably use an argument starting", "       * with \"-\" as an option.  To avoid trouble we skip the \"-\". */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      while (*ptr == '-' && n > 0) {", "        ++ptr;", "        --n;"], "readability/increment"]
["src/nvim/normal.c", ["        ++ptr;", "        --n;", "      }"], "readability/increment"]
["src/nvim/normal.c", ["      if (n == 0) {", "        EMSG(_(e_noident));              /* found dashes only */", "        xfree(buf);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "      /* When a count is given, turn it into a range.  Is this", "       * really what we want? */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        snprintf(buf + STRLEN(buf), buf_size - STRLEN(buf), \"%\" PRId64,", "            (int64_t)cap->count0);", "        STRCAT(buf, \" \");"], "whitespace/alignment"]
["src/nvim/normal.c", ["    tag_cmd = true;", "    if (p_cst)", "      STRCPY(buf, \"cstag \");"], "readability/braces"]
["src/nvim/normal.c", ["      STRCPY(buf, \"cstag \");", "    else", "      STRCPY(buf, \"ts \");"], "readability/braces"]
["src/nvim/normal.c", ["    tag_cmd = true;", "    if (curbuf->b_help)", "      STRCPY(buf, \"he! \");"], "readability/braces"]
["src/nvim/normal.c", ["      STRCPY(buf, \"he! \");", "    else {", "      if (g_cmd)"], "readability/braces"]
["src/nvim/normal.c", ["      STRCPY(buf, \"he! \");", "    else {", "      if (g_cmd)"], "readability/braces"]
["src/nvim/normal.c", ["    else {", "      if (g_cmd)", "        STRCPY(buf, \"tj \");"], "readability/braces"]
["src/nvim/normal.c", ["        STRCPY(buf, \"tj \");", "      else", "        snprintf(buf, buf_size, \"%\" PRId64 \"ta \", (int64_t)cap->count0);"], "readability/braces"]
["src/nvim/normal.c", ["  } else {", "    if (cmdchar == '*')", "      aux_ptr = (char_u *)(p_magic ? \"/.*~[^$\\\\\" : \"/^$\\\\\");"], "readability/braces"]
["src/nvim/normal.c", ["      aux_ptr = (char_u *)(p_magic ? \"/.*~[^$\\\\\" : \"/^$\\\\\");", "    else if (cmdchar == '#')", "      aux_ptr = (char_u *)(p_magic ? \"/?.*~[^$\\\\\" : \"/?^$\\\\\");"], "readability/braces"]
["src/nvim/normal.c", ["      aux_ptr = (char_u *)(p_magic ? \"/?.*~[^$\\\\\" : \"/?^$\\\\\");", "    else if (tag_cmd) {", "      if (curbuf->b_help)"], "readability/braces"]
["src/nvim/normal.c", ["    else if (tag_cmd) {", "      if (curbuf->b_help)", "        /* \":help\" handles unescaped argument */"], "readability/braces"]
["src/nvim/normal.c", ["      if (curbuf->b_help)", "        /* \":help\" handles unescaped argument */", "        aux_ptr = (char_u *)\"\";"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        aux_ptr = (char_u *)\"\";", "      else", "        aux_ptr = (char_u *)\"\\\\|\\\"\\n[\";"], "readability/braces"]
["src/nvim/normal.c", ["        aux_ptr = (char_u *)\"\\\\|\\\"\\n[\";", "    } else", "      aux_ptr = (char_u *)\"\\\\|\\\"\\n*?[\";"], "readability/braces"]
["src/nvim/normal.c", ["    while (n-- > 0) {", "      /* put a backslash before \\ and some others */", "      if (vim_strchr(aux_ptr, *ptr) != NULL)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      /* put a backslash before \\ and some others */", "      if (vim_strchr(aux_ptr, *ptr) != NULL)", "        *p++ = '\\\\';"], "readability/braces"]
["src/nvim/normal.c", ["        *p++ = '\\\\';", "      /* When current byte is a part of multibyte character, copy all", "       * bytes of that character. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * Execute the command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Get visually selected text, within one line only."], "readability/old_style_comment"]
["src/nvim/normal.c", ["bool", "get_visual_text (", "    cmdarg_T *cap,"], "whitespace/parens"]
["src/nvim/normal.c", ["    cmdarg_T *cap,", "    char_u **pp,           /* return: start of selected text */", "    size_t *lenp           /* return: length of selected text */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    char_u **pp,           /* return: start of selected text */", "    size_t *lenp           /* return: length of selected text */", ")"], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (VIsual_mode != 'V')", "    unadjust_for_sel();"], "readability/braces"]
["src/nvim/normal.c", ["  if (VIsual.lnum != curwin->w_cursor.lnum) {", "    if (cap != NULL)", "      clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * CTRL-T: backwards in tag stack"], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (!checkclearopq(cap->oap))", "    do_tag((char_u *)\"\", DT_POP, (int)cap->count1, false, true);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Handle scrolling command 'H', 'L' and 'M'."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    curwin->w_cursor.lnum = curwin->w_botline - 1;", "    if (cap->count1 - 1 >= curwin->w_cursor.lnum)", "      curwin->w_cursor.lnum = 1;"], "readability/braces"]
["src/nvim/normal.c", ["      curwin->w_cursor.lnum = 1;", "    else {", "      if (hasAnyFolding(curwin)) {"], "readability/braces"]
["src/nvim/normal.c", ["      curwin->w_cursor.lnum = 1;", "    else {", "      if (hasAnyFolding(curwin)) {"], "readability/braces"]
["src/nvim/normal.c", ["      if (hasAnyFolding(curwin)) {", "        /* Count a fold for one screen line. */", "        for (n = cap->count1 - 1; n > 0"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        for (n = cap->count1 - 1; n > 0", "             && curwin->w_cursor.lnum > curwin->w_topline; --n) {", "          (void)hasFolding(curwin->w_cursor.lnum,"], "readability/increment"]
["src/nvim/normal.c", ["          (void)hasFolding(curwin->w_cursor.lnum,", "              &curwin->w_cursor.lnum, NULL);", "          --curwin->w_cursor.lnum;"], "whitespace/alignment"]
["src/nvim/normal.c", ["              &curwin->w_cursor.lnum, NULL);", "          --curwin->w_cursor.lnum;", "        }"], "readability/increment"]
["src/nvim/normal.c", ["        }", "      } else", "        curwin->w_cursor.lnum -= cap->count1 - 1;"], "readability/braces"]
["src/nvim/normal.c", ["    if (cap->cmdchar == 'M') {", "      /* Don't count filler lines above the window. */", "      used -= diff_check_fill(curwin, curwin->w_topline)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        if (n > 0 && used + diff_check_fill(curwin, curwin->w_topline", "                + n) / 2 >= half) {", "          --n;"], "whitespace/alignment"]
["src/nvim/normal.c", ["                + n) / 2 >= half) {", "          --n;", "          break;"], "readability/increment"]
["src/nvim/normal.c", ["        used += plines(curwin->w_topline + n);", "        if (used >= half)", "          break;"], "readability/braces"]
["src/nvim/normal.c", ["          break;", "        if (hasFolding(curwin->w_topline + n, NULL, &lnum))", "          n = lnum - curwin->w_topline;"], "readability/braces"]
["src/nvim/normal.c", ["      if (hasAnyFolding(curwin)) {", "        /* Count a fold for one screen line. */", "        lnum = curwin->w_topline;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["          hasFolding(lnum, NULL, &lnum);", "          ++lnum;", "        }"], "readability/increment"]
["src/nvim/normal.c", ["    curwin->w_cursor.lnum = curwin->w_topline + n;", "    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)", "      curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Cursor right commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)) {", "    /* <C-Right> and <S-Right> move a word or WORD right */", "    if (mod_mask & MOD_MASK_CTRL)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    /* <C-Right> and <S-Right> move a word or WORD right */", "    if (mod_mask & MOD_MASK_CTRL)", "      cap->arg = true;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * In virtual mode, there's no such thing as \"PAST_LINE\", as lines are"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  if (virtual_active())", "    PAST_LINE = 0;"], "readability/braces"]
["src/nvim/normal.c", ["", "  for (n = cap->count1; n > 0; --n) {", "    if ((!PAST_LINE && oneright() == false)"], "readability/increment"]
["src/nvim/normal.c", ["        } else {", "          ++curwin->w_cursor.lnum;", "          curwin->w_cursor.col = 0;"], "readability/increment"]
["src/nvim/normal.c", ["  }", "  if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped", "      && cap->oap->op_type == OP_NOP)"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Cursor left commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)) {", "    /* <C-Left> and <S-Left> move a word or WORD left */", "    if (mod_mask & MOD_MASK_CTRL)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    /* <C-Left> and <S-Left> move a word or WORD left */", "    if (mod_mask & MOD_MASK_CTRL)", "      cap->arg = 1;"], "readability/braces"]
["src/nvim/normal.c", ["  cap->oap->inclusive = false;", "  for (n = cap->count1; n > 0; --n) {", "    if (oneleft() == false) {"], "readability/increment"]
["src/nvim/normal.c", ["    if (oneleft() == false) {", "      /* <BS> and <Del> wrap to previous line if 'whichwrap' has 'b'.", "       *\t\t 'h' wraps to previous line if 'whichwrap' has 'h'."], "readability/old_style_comment"]
["src/nvim/normal.c", ["      }", "      /* Only beep and flush if not moved at all */", "      else if (cap->oap->op_type == OP_NOP && n == cap->count1)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      /* Only beep and flush if not moved at all */", "      else if (cap->oap->op_type == OP_NOP && n == cap->count1)", "        beep_flush();"], "whitespace/newline"]
["src/nvim/normal.c", ["  }", "  if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped", "      && cap->oap->op_type == OP_NOP)"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Cursor up commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (mod_mask & MOD_MASK_SHIFT) {", "    /* <S-Up> is page up */", "    cap->arg = BACKWARD;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Cursor down commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (mod_mask & MOD_MASK_SHIFT) {", "    /* <S-Down> is page down */", "    cap->arg = FORWARD;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Grab the file name under the cursor and edit it."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    xfree(ptr);", "  } else", "    clearop(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * <End> command: to end of current line or last line."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (cap->arg || (mod_mask & MOD_MASK_CTRL)) { /* CTRL-END = goto last line */", "    cap->arg = true;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    nv_goto(cap);", "    cap->count1 = 1;                    /* to end of current line */", "  }"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Handle the \"$\" command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  cap->oap->inclusive = true;", "  /* In virtual mode when off the edge of a line and an operator", "   * is pending (whew!) keep the cursor where it is."], "readability/old_style_comment"]
["src/nvim/normal.c", ["   * Otherwise, send it to the end of the line. */", "  if (!virtual_active() || gchar_cursor() != NUL", "      || cap->oap->op_type == OP_NOP)"], "readability/braces"]
["src/nvim/normal.c", ["      || cap->oap->op_type == OP_NOP)", "    curwin->w_curswant = MAXCOL;        /* so we stay at the end */", "  if (cursor_down(cap->count1 - 1,"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    curwin->w_curswant = MAXCOL;        /* so we stay at the end */", "  if (cursor_down(cap->count1 - 1,", "          cap->oap->op_type == OP_NOP) == false)"], "readability/braces"]
["src/nvim/normal.c", ["  if (cursor_down(cap->count1 - 1,", "          cap->oap->op_type == OP_NOP) == false)", "    clearopbeep(cap->oap);"], "whitespace/alignment"]
["src/nvim/normal.c", ["    clearopbeep(cap->oap);", "  else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)", "    foldOpenCursor();"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Implementation of '?' and '/' commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (cap->cmdchar == '?' && cap->oap->op_type == OP_ROT13) {", "    /* Translate \"g??\" to \"g?g?\" */", "    cap->cmdchar = 'g';"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Handle \"N\" and \"n\" commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Search for \"pat\" in direction \"dir\" ('/' or '?', 0 for repeat)."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    curwin->w_cursor.coladd = 0;", "    if (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)", "      foldOpenCursor();"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* \"/$\" will put the cursor after the end of the line, may need to", "   * correct that here */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Character search commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (cap->cmdchar == 't' || cap->cmdchar == 'T')", "    t_cmd = true;"], "readability/braces"]
["src/nvim/normal.c", ["    t_cmd = true;", "  else", "    t_cmd = false;"], "readability/braces"]
["src/nvim/normal.c", ["    curwin->w_set_curswant = true;", "    /* Include a Tab for \"tx\" and for \"dfx\". */", "    if (gchar_cursor() == TAB && virtual_active() && cap->arg == FORWARD"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      curwin->w_cursor.coladd = ecol - scol;", "    } else", "      curwin->w_cursor.coladd = 0;"], "readability/braces"]
["src/nvim/normal.c", ["    adjust_for_sel(cap);", "    if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)", "      foldOpenCursor();"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * \"[\" and \"]\" commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  pos_T prev_pos;", "  pos_T       *pos = NULL;          /* init for GCC */", "  pos_T old_pos;                    /* cursor position before command */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  pos_T       *pos = NULL;          /* init for GCC */", "  pos_T old_pos;                    /* cursor position before command */", "  int flag;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  old_pos = curwin->w_cursor;", "  curwin->w_cursor.coladd = 0;              /* TODO: don't do this for an error. */", ""], "readability/old_style_comment"]
["src/nvim/normal.c", ["  old_pos = curwin->w_cursor;", "  curwin->w_cursor.coladd = 0;              /* TODO: don't do this for an error. */", ""], "whitespace/line_length"]
["src/nvim/normal.c", ["", "  /*", "   * \"[f\" or \"]f\" : Edit file under the cursor (same as \"gf\")"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  if (cap->nchar == 'f')", "    nv_gotofile(cap);"], "readability/braces"]
["src/nvim/normal.c", ["    nv_gotofile(cap);", "  else", "  /*"], "readability/braces"]
["src/nvim/normal.c", ["  else", "  /*", "   * Find the occurrence(s) of the identifier or define under cursor"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (vim_strchr((char_u *)", "          \"iI\\011dD\\004\",", "          cap->nchar) != NULL) {"], "whitespace/alignment"]
["src/nvim/normal.c", ["          \"iI\\011dD\\004\",", "          cap->nchar) != NULL) {", "    char_u  *ptr;"], "whitespace/alignment"]
["src/nvim/normal.c", ["", "    if ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)", "      clearop(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["      clearop(cap->oap);", "    else {", "      find_pattern_in_path(ptr, 0, len, true,"], "readability/braces"]
["src/nvim/normal.c", ["      clearop(cap->oap);", "    else {", "      find_pattern_in_path(ptr, 0, len, true,"], "readability/braces"]
["src/nvim/normal.c", ["    }", "  } else", "  /*"], "readability/braces"]
["src/nvim/normal.c", ["  } else", "  /*", "   * \"[{\", \"[(\", \"]}\" or \"])\": go to Nth unclosed '{', '(', '}' or ')'"], "readability/old_style_comment"]
["src/nvim/normal.c", ["         && vim_strchr((char_u *)\"{(*/#mM\", cap->nchar) != NULL)", "        || (cap->cmdchar == ']'", "            && vim_strchr((char_u *)\"})*/#mM\", cap->nchar) != NULL)) {"], "whitespace/alignment"]
["src/nvim/normal.c", ["            && vim_strchr((char_u *)\"})*/#mM\", cap->nchar) != NULL)) {", "    if (cap->nchar == '*')", "      cap->nchar = '/';"], "readability/braces"]
["src/nvim/normal.c", ["    if (cap->nchar == 'm' || cap->nchar == 'M') {", "      if (cap->cmdchar == '[')", "        findc = '{';"], "readability/braces"]
["src/nvim/normal.c", ["        findc = '{';", "      else", "        findc = '}';"], "readability/braces"]
["src/nvim/normal.c", ["    }", "    for (; n > 0; --n) {", "      if ((pos = findmatchlimit(cap->oap, findc,"], "readability/increment"]
["src/nvim/normal.c", ["      if ((pos = findmatchlimit(cap->oap, findc,", "               (cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD, 0)) == NULL) {", "        if (new_pos.lnum == 0) {        /* nothing found */"], "whitespace/alignment"]
["src/nvim/normal.c", ["               (cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD, 0)) == NULL) {", "        if (new_pos.lnum == 0) {        /* nothing found */", "          if (cap->nchar != 'm' && cap->nchar != 'M')"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        if (new_pos.lnum == 0) {        /* nothing found */", "          if (cap->nchar != 'm' && cap->nchar != 'M')", "            clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["            clearopbeep(cap->oap);", "        } else", "          pos = &new_pos;               /* use last one found */"], "readability/braces"]
["src/nvim/normal.c", ["        } else", "          pos = &new_pos;               /* use last one found */", "        break;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    /*", "     * Handle \"[m\", \"]m\", \"[M\" and \"[M\".  The findmatchlimit() only"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (cap->nchar == 'm' || cap->nchar == 'M') {", "      /* norm is true for \"]M\" and \"[m\" */", "      int norm = ((findc == '{') == (cap->nchar == 'm'));"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      n = cap->count1;", "      /* found a match: we were inside a method */", "      if (prev_pos.lnum != 0) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        curwin->w_cursor = prev_pos;", "        if (norm)", "          --n;"], "readability/braces"]
["src/nvim/normal.c", ["        if (norm)", "          --n;", "      } else"], "readability/increment"]
["src/nvim/normal.c", ["          --n;", "      } else", "        pos = NULL;"], "readability/braces"]
["src/nvim/normal.c", ["          if ((findc == '{' ? dec_cursor() : inc_cursor()) < 0) {", "            /* if not found anything, that's an error */", "            if (pos == NULL)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["            /* if not found anything, that's an error */", "            if (pos == NULL)", "              clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["          if (c == '{' || c == '}') {", "            /* Must have found end/start of class: use it.", "             * Or found the place to be at. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["            }", "            /* if no match found at all, we started outside of the", "             * class and we're inside now.  Just go on. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["             * class and we're inside now.  Just go on. */", "            else if (new_pos.lnum == 0) {", "              new_pos = curwin->w_cursor;"], "whitespace/newline"]
["src/nvim/normal.c", ["            }", "            /* found start/end of other method: go to match */", "            else if ((pos = findmatchlimit(cap->oap, findc,"], "readability/old_style_comment"]
["src/nvim/normal.c", ["            /* found start/end of other method: go to match */", "            else if ((pos = findmatchlimit(cap->oap, findc,", "                          (cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD,"], "whitespace/newline"]
["src/nvim/normal.c", ["            else if ((pos = findmatchlimit(cap->oap, findc,", "                          (cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD,", "                          0)) == NULL)"], "whitespace/alignment"]
["src/nvim/normal.c", ["                          (cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD,", "                          0)) == NULL)", "              n = 0;"], "whitespace/alignment"]
["src/nvim/normal.c", ["              n = 0;", "            else", "              curwin->w_cursor = *pos;"], "readability/braces"]
["src/nvim/normal.c", ["        }", "        --n;", "      }"], "readability/increment"]
["src/nvim/normal.c", ["      curwin->w_cursor = old_pos;", "      if (pos == NULL && new_pos.lnum != 0)", "        clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["      curwin->w_set_curswant = true;", "      if ((fdo_flags & FDO_BLOCK) && KeyTyped", "          && cap->oap->op_type == OP_NOP)"], "readability/braces"]
["src/nvim/normal.c", ["  }", "  /*", "   * \"[[\", \"[]\", \"]]\" and \"][\": move to start or end of function"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  else if (cap->nchar == '[' || cap->nchar == ']') {", "    if (cap->nchar == cap->cmdchar)                 /* \"]]\" or \"[[\" */"], "whitespace/newline"]
["src/nvim/normal.c", ["  else if (cap->nchar == '[' || cap->nchar == ']') {", "    if (cap->nchar == cap->cmdchar)                 /* \"]]\" or \"[[\" */", "      flag = '{';"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  else if (cap->nchar == '[' || cap->nchar == ']') {", "    if (cap->nchar == cap->cmdchar)                 /* \"]]\" or \"[[\" */", "      flag = '{';"], "readability/braces"]
["src/nvim/normal.c", ["      flag = '{';", "    else", "      flag = '}';                   /* \"][\" or \"[]\" */"], "readability/braces"]
["src/nvim/normal.c", ["    else", "      flag = '}';                   /* \"][\" or \"[]\" */", ""], "readability/old_style_comment"]
["src/nvim/normal.c", ["    curwin->w_set_curswant = true;", "    /*", "     * Imitate strange Vi behaviour: When using \"]]\" with an operator"], "readability/old_style_comment"]
["src/nvim/normal.c", ["     */", "    if (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, flag,", "            (cap->oap->op_type != OP_NOP"], "readability/braces"]
["src/nvim/normal.c", ["    if (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, flag,", "            (cap->oap->op_type != OP_NOP", "             && cap->arg == FORWARD && flag == '{')))"], "whitespace/alignment"]
["src/nvim/normal.c", ["      clearopbeep(cap->oap);", "    else {", "      if (cap->oap->op_type == OP_NOP)"], "readability/braces"]
["src/nvim/normal.c", ["      clearopbeep(cap->oap);", "    else {", "      if (cap->oap->op_type == OP_NOP)"], "readability/braces"]
["src/nvim/normal.c", ["    else {", "      if (cap->oap->op_type == OP_NOP)", "        beginline(BL_WHITE | BL_FIX);"], "readability/braces"]
["src/nvim/normal.c", ["        beginline(BL_WHITE | BL_FIX);", "      if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)", "        foldOpenCursor();"], "readability/braces"]
["src/nvim/normal.c", ["  }", "  /*", "   * \"['\", \"[`\", \"]'\" and \"]`\": jump to next mark"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  else if (cap->nchar == '\\'' || cap->nchar == '`') {", "    pos = &curwin->w_cursor;"], "whitespace/newline"]
["src/nvim/normal.c", ["    pos = &curwin->w_cursor;", "    for (n = cap->count1; n > 0; --n) {", "      prev_pos = *pos;"], "readability/increment"]
["src/nvim/normal.c", ["      pos = getnextmark(pos, cap->cmdchar == '[' ? BACKWARD : FORWARD,", "          cap->nchar == '\\'');", "      if (pos == NULL)"], "whitespace/alignment"]
["src/nvim/normal.c", ["          cap->nchar == '\\'');", "      if (pos == NULL)", "        break;"], "readability/braces"]
["src/nvim/normal.c", ["    }", "    if (pos == NULL)", "      pos = &prev_pos;"], "readability/braces"]
["src/nvim/normal.c", ["  }", "  /*", "   * [ or ] followed by a middle mouse click: put selected text with"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  else if (cap->nchar >= K_RIGHTRELEASE && cap->nchar <= K_LEFTMOUSE) {", "    (void)do_mouse(cap->oap, cap->nchar,"], "whitespace/newline"]
["src/nvim/normal.c", ["    (void)do_mouse(cap->oap, cap->nchar,", "        (cap->cmdchar == ']') ? FORWARD : BACKWARD,", "        cap->count1, PUT_FIXINDENT);"], "whitespace/alignment"]
["src/nvim/normal.c", ["        (cap->cmdchar == ']') ? FORWARD : BACKWARD,", "        cap->count1, PUT_FIXINDENT);", "  }"], "whitespace/alignment"]
["src/nvim/normal.c", ["  }", "  /*", "   * \"[z\" and \"]z\": move to start or end of open fold."], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  else if (cap->nchar == 'z') {", "    if (foldMoveTo(false, cap->cmdchar == ']' ? FORWARD : BACKWARD,"], "whitespace/newline"]
["src/nvim/normal.c", ["  else if (cap->nchar == 'z') {", "    if (foldMoveTo(false, cap->cmdchar == ']' ? FORWARD : BACKWARD,", "            cap->count1) == false)"], "readability/braces"]
["src/nvim/normal.c", ["    if (foldMoveTo(false, cap->cmdchar == ']' ? FORWARD : BACKWARD,", "            cap->count1) == false)", "      clearopbeep(cap->oap);"], "whitespace/alignment"]
["src/nvim/normal.c", ["  }", "  /*", "   * \"[c\" and \"]c\": move to next or previous diff-change."], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  else if (cap->nchar == 'c') {", "    if (diff_move_to(cap->cmdchar == ']' ? FORWARD : BACKWARD,"], "whitespace/newline"]
["src/nvim/normal.c", ["  else if (cap->nchar == 'c') {", "    if (diff_move_to(cap->cmdchar == ']' ? FORWARD : BACKWARD,", "            cap->count1) == false)"], "readability/braces"]
["src/nvim/normal.c", ["    if (diff_move_to(cap->cmdchar == ']' ? FORWARD : BACKWARD,", "            cap->count1) == false)", "      clearopbeep(cap->oap);"], "whitespace/alignment"]
["src/nvim/normal.c", ["  }", "  /*", "   * \"[s\", \"[S\", \"]s\" and \"]S\": move to next spell error."], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  else if (cap->nchar == 's' || cap->nchar == 'S') {", "    setpcmark();"], "whitespace/newline"]
["src/nvim/normal.c", ["    setpcmark();", "    for (n = 0; n < cap->count1; ++n)", "      if (spell_move_to(curwin, cap->cmdchar == ']' ? FORWARD : BACKWARD,"], "readability/braces"]
["src/nvim/normal.c", ["    setpcmark();", "    for (n = 0; n < cap->count1; ++n)", "      if (spell_move_to(curwin, cap->cmdchar == ']' ? FORWARD : BACKWARD,"], "readability/increment"]
["src/nvim/normal.c", ["      }", "    if (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)", "      foldOpenCursor();"], "readability/braces"]
["src/nvim/normal.c", ["  }", "  /* Not a valid cap->nchar. */", "  else"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* Not a valid cap->nchar. */", "  else", "    clearopbeep(cap->oap);"], "whitespace/newline"]
["src/nvim/normal.c", ["", "/*", " * Handle Normal mode \"%\" command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    cap->oap->use_reg_one = true;", "    if ((pos = findmatch(cap->oap, NUL)) == NULL)", "      clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["      clearopbeep(cap->oap);", "    else {", "      setpcmark();"], "readability/braces"]
["src/nvim/normal.c", ["      clearopbeep(cap->oap);", "    else {", "      setpcmark();"], "readability/braces"]
["src/nvim/normal.c", ["  }", "  if (cap->oap->op_type == OP_NOP", "      && lnum != curwin->w_cursor.lnum"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Handle \"(\" and \")\" commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  cap->oap->use_reg_one = true;", "  /* The motion used to be inclusive for \"(\", but that is not what Vi does. */", "  cap->oap->inclusive = false;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (findsent(cap->arg, cap->count1) == false)", "    clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["    clearopbeep(cap->oap);", "  else {", "    /* Don't leave the cursor on the NUL past end of line. */"], "readability/braces"]
["src/nvim/normal.c", ["    clearopbeep(cap->oap);", "  else {", "    /* Don't leave the cursor on the NUL past end of line. */"], "readability/braces"]
["src/nvim/normal.c", ["  else {", "    /* Don't leave the cursor on the NUL past end of line. */", "    adjust_cursor(cap->oap);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    curwin->w_cursor.coladd = 0;", "    if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)", "      foldOpenCursor();"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * \"m\" command: Mark a position."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (!checkclearop(cap->oap)) {", "    if (setmark(cap->nchar) == false)", "      clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * \"{\" and \"}\" commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  curwin->w_set_curswant = true;", "  if (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, NUL, false))", "    clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["    clearopbeep(cap->oap);", "  else {", "    curwin->w_cursor.coladd = 0;"], "readability/braces"]
["src/nvim/normal.c", ["    clearopbeep(cap->oap);", "  else {", "    curwin->w_cursor.coladd = 0;"], "readability/braces"]
["src/nvim/normal.c", ["    curwin->w_cursor.coladd = 0;", "    if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)", "      foldOpenCursor();"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * \"u\" command: Undo or make lower case."], "readability/old_style_comment"]
["src/nvim/normal.c", ["      ) {", "    /* translate \"<Visual>u\" to \"<Visual>gu\" and \"guu\" to \"gugu\" */", "    cap->cmdchar = 'g';"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    nv_operator(cap);", "  } else", "    nv_kundo(cap);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * <Undo> command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Handle the \"r\" command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* get another character */", "  if (cap->nchar == Ctrl_V) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    cap->nchar = get_literal();", "    /* Don't redo a multibyte character with CTRL-V. */", "    if (cap->nchar > DEL)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    /* Don't redo a multibyte character with CTRL-V. */", "    if (cap->nchar > DEL)", "      had_ctrl_v = NUL;"], "readability/braces"]
["src/nvim/normal.c", ["      had_ctrl_v = NUL;", "  } else", "    had_ctrl_v = NUL;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* Abort if the character is a special key. */", "  if (IS_SPECIAL(cap->nchar)) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* Visual mode \"r\" */", "  if (VIsual_active) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (VIsual_active) {", "    if (got_int)", "      reset_VIsual();"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* Break tabs, etc. */", "  if (virtual_active()) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (virtual_active()) {", "    if (u_save_cursor() == false)", "      return;"], "readability/braces"]
["src/nvim/normal.c", ["    if (gchar_cursor() == NUL) {", "      /* Add extra space and put the cursor on the first one. */", "      coladvance_force((colnr_T)(getviscol() + cap->count1));"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      curwin->w_cursor.col -= (colnr_T)cap->count1;", "    } else if (gchar_cursor() == TAB)", "      coladvance_force(getviscol());"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* Abort if not enough characters to replace. */", "  ptr = get_cursor_pos_ptr();"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* save line for undo */", "  if (u_save_cursor() == false)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* save line for undo */", "  if (u_save_cursor() == false)", "    return;"], "readability/braces"]
["src/nvim/normal.c", ["  if (had_ctrl_v != Ctrl_V && (cap->nchar == '\\r' || cap->nchar == '\\n')) {", "    /*", "     * Replace character(s) by a single newline."], "readability/old_style_comment"]
["src/nvim/normal.c", ["     */", "    (void)del_chars(cap->count1, false);        /* delete the characters */", "    stuffcharReadbuff('\\r');"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    /* Give 'r' to edit(), to get the redo command right. */", "    invoke_edit(cap, true, 'r', false);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    prep_redo(cap->oap->regname, cap->count1,", "        NUL, 'r', NUL, had_ctrl_v, cap->nchar);", ""], "whitespace/alignment"]
["src/nvim/normal.c", ["    }", "    --curwin->w_cursor.col;         /* cursor on the last replaced char */", "    /* if the character on the left of the current cursor is a multi-byte"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    }", "    --curwin->w_cursor.col;         /* cursor on the last replaced char */", "    /* if the character on the left of the current cursor is a multi-byte"], "readability/increment"]
["src/nvim/normal.c", ["    --curwin->w_cursor.col;         /* cursor on the last replaced char */", "    /* if the character on the left of the current cursor is a multi-byte", "     * character, move two characters left */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * 'o': Exchange start and end of Visual area."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    curwin->w_curswant = right;", "    /* 'selection \"exclusive\" and cursor at right-bottom corner: move it", "     * right one column */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["     * right one column */", "    if (old_cursor.lnum >= VIsual.lnum && *p_sel == 'e')", "      ++curwin->w_curswant;"], "readability/braces"]
["src/nvim/normal.c", ["    if (old_cursor.lnum >= VIsual.lnum && *p_sel == 'e')", "      ++curwin->w_curswant;", "    coladvance(curwin->w_curswant);"], "readability/increment"]
["src/nvim/normal.c", ["      curwin->w_cursor.lnum = VIsual.lnum;", "      if (old_cursor.lnum <= VIsual.lnum && *p_sel == 'e')", "        ++right;"], "readability/braces"]
["src/nvim/normal.c", ["      if (old_cursor.lnum <= VIsual.lnum && *p_sel == 'e')", "        ++right;", "      coladvance(right);"], "readability/increment"]
["src/nvim/normal.c", ["", "/*", " * \"R\" (cap->arg is false) and \"gR\" (cap->arg is true)."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (VIsual_active) {          /* \"R\" is replace lines */", "    cap->cmdchar = 'c';"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    cap->nchar = NUL;", "    VIsual_mode_orig = VIsual_mode;     /* remember original area for gv */", "    VIsual_mode = 'V';"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    } else {", "      if (virtual_active())", "        coladvance(getviscol());"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * \"gr\"."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    cap->nchar = cap->extra_char;", "    nv_replace(cap);            /* Do same as \"r\" in Visual mode for now */", "  } else if (!checkclearopq(cap->oap)) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    } else {", "      if (cap->extra_char == Ctrl_V)            /* get another character */", "        cap->extra_char = get_literal();"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    } else {", "      if (cap->extra_char == Ctrl_V)            /* get another character */", "        cap->extra_char = get_literal();"], "readability/braces"]
["src/nvim/normal.c", ["      stuffcharReadbuff(ESC);", "      if (virtual_active())", "        coladvance(getviscol());"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Swap case for \"~\" command, when it does not work like an operator."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (u_save_cursor() == false)", "    return;"], "readability/braces"]
["src/nvim/normal.c", ["  startpos = curwin->w_cursor;", "  for (n = cap->count1; n > 0; --n) {", "    did_change |= swapchar(cap->oap->op_type, &curwin->w_cursor);"], "readability/increment"]
["src/nvim/normal.c", ["          && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count) {", "        ++curwin->w_cursor.lnum;", "        curwin->w_cursor.col = 0;"], "readability/increment"]
["src/nvim/normal.c", ["        if (n > 1) {", "          if (u_savesub(curwin->w_cursor.lnum) == false)", "            break;"], "readability/braces"]
["src/nvim/normal.c", ["        }", "      } else", "        break;"], "readability/braces"]
["src/nvim/normal.c", ["    curbuf->b_op_end = curwin->w_cursor;", "    if (curbuf->b_op_end.col > 0)", "      --curbuf->b_op_end.col;"], "readability/braces"]
["src/nvim/normal.c", ["    if (curbuf->b_op_end.col > 0)", "      --curbuf->b_op_end.col;", "  }"], "readability/increment"]
["src/nvim/normal.c", ["", "/*", " * Move cursor to mark."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (check_mark(pos) == false)", "    clearop(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["    clearop(cap->oap);", "  else {", "    if (cap->cmdchar == '\\''"], "readability/braces"]
["src/nvim/normal.c", ["    clearop(cap->oap);", "  else {", "    if (cap->cmdchar == '\\''"], "readability/braces"]
["src/nvim/normal.c", ["  else {", "    if (cap->cmdchar == '\\''", "        || cap->cmdchar == '`'"], "readability/braces"]
["src/nvim/normal.c", ["    curwin->w_cursor = *pos;", "    if (flag)", "      beginline(BL_WHITE | BL_FIX);"], "readability/braces"]
["src/nvim/normal.c", ["      beginline(BL_WHITE | BL_FIX);", "    else", "      check_cursor();"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Handle commands that are operators in Visual mode."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* Uppercase means linewise, except in block mode, then \"D\" deletes till", "   * the end of the line, and \"C\" replaces till EOL */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      VIsual_mode = 'V';", "    } else if (cap->cmdchar == 'C' || cap->cmdchar == 'D')", "      curwin->w_curswant = MAXCOL;"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * \"s\" and \"S\" commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    nv_operator(cap);", "  } else", "    nv_optrans(cap);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Abbreviated commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (cap->cmdchar == K_DEL || cap->cmdchar == K_KDEL)", "    cap->cmdchar = 'x';                 /* DEL key behaves like 'x' */"], "readability/braces"]
["src/nvim/normal.c", ["  if (cap->cmdchar == K_DEL || cap->cmdchar == K_KDEL)", "    cap->cmdchar = 'x';                 /* DEL key behaves like 'x' */", ""], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* in Visual mode these commands are operators */", "  if (VIsual_active)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* in Visual mode these commands are operators */", "  if (VIsual_active)", "    v_visop(cap);"], "readability/braces"]
["src/nvim/normal.c", ["    v_visop(cap);", "  else", "    nv_optrans(cap);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Translate a command into another command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * \"'\" and \"`\" commands.  Also for \"g'\" and \"g`\"."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (cap->cmdchar == 'g')", "    c = cap->extra_char;"], "readability/braces"]
["src/nvim/normal.c", ["    c = cap->extra_char;", "  else", "    c = cap->nchar;"], "readability/braces"]
["src/nvim/normal.c", ["  pos = getmark(c, (cap->oap->op_type == OP_NOP));", "  if (pos == (pos_T *)-1) {         /* jumped to other file */", "    if (cap->arg) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      beginline(BL_WHITE | BL_FIX);", "    } else", "      check_cursor();"], "readability/braces"]
["src/nvim/normal.c", ["      check_cursor();", "  } else", "    nv_cursormark(cap, cap->arg, pos);"], "readability/braces"]
["src/nvim/normal.c", ["      check_cursor();", "    } else if (pos != NULL)                 /* can jump */", "      nv_cursormark(cap, false, pos);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      check_cursor();", "    } else if (pos != NULL)                 /* can jump */", "      nv_cursormark(cap, false, pos);"], "readability/braces"]
["src/nvim/normal.c", ["      nv_cursormark(cap, false, pos);", "    else if (cap->cmdchar == 'g') {", "      if (curbuf->b_changelistlen == 0)"], "readability/braces"]
["src/nvim/normal.c", ["    else if (cap->cmdchar == 'g') {", "      if (curbuf->b_changelistlen == 0)", "        EMSG(_(\"E664: changelist is empty\"));"], "readability/braces"]
["src/nvim/normal.c", ["        EMSG(_(\"E664: changelist is empty\"));", "      else if (cap->count1 < 0)", "        EMSG(_(\"E662: At start of changelist\"));"], "readability/braces"]
["src/nvim/normal.c", ["        EMSG(_(\"E662: At start of changelist\"));", "      else", "        EMSG(_(\"E663: At end of changelist\"));"], "readability/braces"]
["src/nvim/normal.c", ["        EMSG(_(\"E663: At end of changelist\"));", "    } else", "      clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["      clearopbeep(cap->oap);", "    if (cap->oap->op_type == OP_NOP", "        && (pos == (pos_T *)-1 || lnum != curwin->w_cursor.lnum)"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Handle '\"' command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (checkclearop(cap->oap))", "    return;"], "readability/braces"]
["src/nvim/normal.c", ["    return;", "  if (cap->nchar == '=')", "    cap->nchar = get_expr_register();"], "readability/braces"]
["src/nvim/normal.c", ["    cap->oap->regname = cap->nchar;", "    cap->opcount = cap->count0;         /* remember count before '\"' */", "    set_reg_var(cap->oap->regname);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    set_reg_var(cap->oap->regname);", "  } else", "    clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Handle \"v\", \"V\" and \"CTRL-V\" commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (cap->cmdchar == Ctrl_Q)", "    cap->cmdchar = Ctrl_V;"], "readability/braces"]
["src/nvim/normal.c", ["  VIsual_select = cap->arg;", "  if (VIsual_active) {      /* change Visual mode */", "    if (VIsual_mode == cap->cmdchar)        /* stop visual mode */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (VIsual_active) {      /* change Visual mode */", "    if (VIsual_mode == cap->cmdchar)        /* stop visual mode */", "      end_visual_mode();"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (VIsual_active) {      /* change Visual mode */", "    if (VIsual_mode == cap->cmdchar)        /* stop visual mode */", "      end_visual_mode();"], "readability/braces"]
["src/nvim/normal.c", ["      end_visual_mode();", "    else {                                  /* toggle char/block mode */", "                                            /*\t   or char/line mode */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      end_visual_mode();", "    else {                                  /* toggle char/block mode */", "                                            /*\t   or char/line mode */"], "readability/braces"]
["src/nvim/normal.c", ["      end_visual_mode();", "    else {                                  /* toggle char/block mode */", "                                            /*\t   or char/line mode */"], "readability/braces"]
["src/nvim/normal.c", ["    else {                                  /* toggle char/block mode */", "                                            /*\t   or char/line mode */", "      VIsual_mode = cap->cmdchar;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    else {                                  /* toggle char/block mode */", "                                            /*\t   or char/line mode */", "      VIsual_mode = cap->cmdchar;"], "whitespace/tab"]
["src/nvim/normal.c", ["    if (cap->count0 > 0 && resel_VIsual_mode != NUL) {", "      /* use previously selected part */", "      VIsual = curwin->w_cursor;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      VIsual_reselect = true;", "      if (!cap->arg)", "        /* start Select mode when 'selectmode' contains \"cmd\" */"], "readability/braces"]
["src/nvim/normal.c", ["      if (!cap->arg)", "        /* start Select mode when 'selectmode' contains \"cmd\" */", "        may_start_select('c');"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      setmouse();", "      if (p_smd && msg_silent == 0)", "        redraw_cmdline = true;              /* show visual mode later */"], "readability/braces"]
["src/nvim/normal.c", ["      if (p_smd && msg_silent == 0)", "        redraw_cmdline = true;              /* show visual mode later */", "      /*"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        redraw_cmdline = true;              /* show visual mode later */", "      /*", "       * For V and ^V, we multiply the number of lines even if there"], "readability/old_style_comment"]
["src/nvim/normal.c", ["          resel_VIsual_line_count * cap->count0 - 1;", "        if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)", "          curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/normal.c", ["                                + resel_VIsual_vcol * (int)cap->count0 - 1);", "        } else", "          curwin->w_curswant = resel_VIsual_vcol;"], "readability/braces"]
["src/nvim/normal.c", ["        coladvance(curwin->w_curswant);", "      } else", "        curwin->w_set_curswant = true;"], "readability/braces"]
["src/nvim/normal.c", ["        curwin->w_set_curswant = true;", "      redraw_curbuf_later(INVERTED);            /* show the inversion */", "    } else {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    } else {", "      if (!cap->arg)", "        /* start Select mode when 'selectmode' contains \"cmd\" */"], "readability/braces"]
["src/nvim/normal.c", ["      if (!cap->arg)", "        /* start Select mode when 'selectmode' contains \"cmd\" */", "        may_start_select('c');"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      n_start_visual_mode(cap->cmdchar);", "      if (VIsual_mode != 'V' && *p_sel == 'e')", "        ++cap->count1;          /* include one more char */"], "readability/braces"]
["src/nvim/normal.c", ["      if (VIsual_mode != 'V' && *p_sel == 'e')", "        ++cap->count1;          /* include one more char */", "      if (cap->count0 > 0 && --cap->count1 > 0) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      if (VIsual_mode != 'V' && *p_sel == 'e')", "        ++cap->count1;          /* include one more char */", "      if (cap->count0 > 0 && --cap->count1 > 0) {"], "readability/increment"]
["src/nvim/normal.c", ["      if (cap->count0 > 0 && --cap->count1 > 0) {", "        /* With a count select that many characters or lines. */", "        if (VIsual_mode == 'v' || VIsual_mode == Ctrl_V)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        /* With a count select that many characters or lines. */", "        if (VIsual_mode == 'v' || VIsual_mode == Ctrl_V)", "          nv_right(cap);"], "readability/braces"]
["src/nvim/normal.c", ["          nv_right(cap);", "        else if (VIsual_mode == 'V')", "          nv_down(cap);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Start selection for Shift-movement keys."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  /* if 'selectmode' contains \"key\", start Select mode */", "  may_start_select('k');"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Start Select mode, if \"c\" is in 'selectmode' and not in a mapping or menu."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Start Visual mode \"c\"."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  VIsual_reselect = true;", "  /* Corner case: the 0 position in a tab may change when going into", "   * virtualedit.  Recalculate curwin->w_cursor to avoid bad hilighting."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (p_smd && msg_silent == 0)", "    redraw_cmdline = true;      /* show visual mode later */"], "readability/braces"]
["src/nvim/normal.c", ["  if (p_smd && msg_silent == 0)", "    redraw_cmdline = true;      /* show visual mode later */", ""], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* Only need to redraw this line, unless still need to redraw an old", "   * Visual area (when 'lazyredraw' is set). */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * CTRL-W: Window commands"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * CTRL-Z: Suspend"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  clearop(cap->oap);", "  if (VIsual_active)", "    end_visual_mode();                  /* stop Visual mode */"], "readability/braces"]
["src/nvim/normal.c", ["  if (VIsual_active)", "    end_visual_mode();                  /* stop Visual mode */", "  do_cmdline_cmd(\"st\");"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Commands starting with \"g\"."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * \"gv\": Reselect the previous Visual area.  If Visual already active,"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case 'v':", "    if (checkclearop(oap))", "      break;"], "readability/braces"]
["src/nvim/normal.c", ["", "    if (       curbuf->b_visual.vi_start.lnum == 0", "               || curbuf->b_visual.vi_start.lnum > curbuf->b_ml.ml_line_count"], "readability/braces"]
["src/nvim/normal.c", ["    if (       curbuf->b_visual.vi_start.lnum == 0", "               || curbuf->b_visual.vi_start.lnum > curbuf->b_ml.ml_line_count", "               || curbuf->b_visual.vi_end.lnum == 0)"], "whitespace/alignment"]
["src/nvim/normal.c", ["               || curbuf->b_visual.vi_start.lnum > curbuf->b_ml.ml_line_count", "               || curbuf->b_visual.vi_end.lnum == 0)", "      beep_flush();"], "whitespace/alignment"]
["src/nvim/normal.c", ["      beep_flush();", "    else {", "      /* set w_cursor to the start of the Visual area, tpos to the end */"], "readability/braces"]
["src/nvim/normal.c", ["      beep_flush();", "    else {", "      /* set w_cursor to the start of the Visual area, tpos to the end */"], "readability/braces"]
["src/nvim/normal.c", ["    else {", "      /* set w_cursor to the start of the Visual area, tpos to the end */", "      if (VIsual_active) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "      /* Set Visual to the start and w_cursor to the end of the Visual", "       * area.  Make sure they are on an existing character. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    break;", "  /*", "   * \"gV\": Don't reselect the previous Visual area after a Select mode"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * \"gh\":  start Select mode."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"gn\", \"gN\" visually select next/previous search match", "   * \"gn\" selects next match"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case 'n':", "    if (!current_search(cap->count1, cap->nchar == 'n'))", "      clearopbeep(oap);"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * \"gj\" and \"gk\" two new funny movement keys -- up and down"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      i = cursor_down(cap->count1, oap->op_type == OP_NOP);", "    } else", "      i = nv_screengo(oap, FORWARD, cap->count1);"], "readability/braces"]
["src/nvim/normal.c", ["      i = nv_screengo(oap, FORWARD, cap->count1);", "    if (!i)", "      clearopbeep(oap);"], "readability/braces"]
["src/nvim/normal.c", ["      i = cursor_up(cap->count1, oap->op_type == OP_NOP);", "    } else", "      i = nv_screengo(oap, BACKWARD, cap->count1);"], "readability/braces"]
["src/nvim/normal.c", ["      i = nv_screengo(oap, BACKWARD, cap->count1);", "    if (!i)", "      clearopbeep(oap);"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * \"gJ\": join two lines without inserting a space."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * \"g0\", \"g^\" and \"g$\": Like \"0\", \"^\" and \"$\" but for screen lines."], "readability/old_style_comment"]
["src/nvim/normal.c", ["      i = 0;", "      if (curwin->w_virtcol >= (colnr_T)width1 && width2 > 0)", "        i = (curwin->w_virtcol - width1) / width2 * width2 + width1;"], "readability/braces"]
["src/nvim/normal.c", ["        i = (curwin->w_virtcol - width1) / width2 * width2 + width1;", "    } else", "      i = curwin->w_leftcol;"], "readability/braces"]
["src/nvim/normal.c", ["      i = curwin->w_leftcol;", "    /* Go to the middle of the screen line.  When 'number' or", "     * 'relativenumber' is on and lines are wrapping the middle can be more"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case '_':", "    /* \"g_\": to the last non-blank character in the line or <count> lines", "     * downward. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    curwin->w_curswant = MAXCOL;", "    if (cursor_down(cap->count1 - 1,", "            cap->oap->op_type == OP_NOP) == false)"], "readability/braces"]
["src/nvim/normal.c", ["    if (cursor_down(cap->count1 - 1,", "            cap->oap->op_type == OP_NOP) == false)", "      clearopbeep(cap->oap);"], "whitespace/alignment"]
["src/nvim/normal.c", ["      clearopbeep(cap->oap);", "    else {", "      char_u  *ptr = get_cursor_line_ptr();"], "readability/braces"]
["src/nvim/normal.c", ["      clearopbeep(cap->oap);", "    else {", "      char_u  *ptr = get_cursor_line_ptr();"], "readability/braces"]
["src/nvim/normal.c", ["", "      /* In Visual mode we may end up after the line. */", "      if (curwin->w_cursor.col > 0 && ptr[curwin->w_cursor.col] == NUL)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      /* In Visual mode we may end up after the line. */", "      if (curwin->w_cursor.col > 0 && ptr[curwin->w_cursor.col] == NUL)", "        --curwin->w_cursor.col;"], "readability/braces"]
["src/nvim/normal.c", ["      if (curwin->w_cursor.col > 0 && ptr[curwin->w_cursor.col] == NUL)", "        --curwin->w_cursor.col;", ""], "readability/increment"]
["src/nvim/normal.c", ["", "      /* Decrease the cursor column until it's on a non-blank. */", "      while (curwin->w_cursor.col > 0"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      /* Decrease the cursor column until it's on a non-blank. */", "      while (curwin->w_cursor.col > 0", "             && ascii_iswhite(ptr[curwin->w_cursor.col]))"], "readability/braces"]
["src/nvim/normal.c", ["             && ascii_iswhite(ptr[curwin->w_cursor.col]))", "        --curwin->w_cursor.col;", "      curwin->w_set_curswant = true;"], "readability/increment"]
["src/nvim/normal.c", ["        ) {", "      curwin->w_curswant = MAXCOL;              /* so we stay at the end */", "      if (cap->count1 == 1) {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        i = width1 - 1;", "        if (curwin->w_virtcol >= (colnr_T)width1)", "          i += ((curwin->w_virtcol - width1) / width2 + 1)"], "readability/braces"]
["src/nvim/normal.c", ["", "        /* Make sure we stick in this column. */", "        validate_virtcol();"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        if (curwin->w_cursor.col > 0 && curwin->w_p_wrap) {", "          /*", "           * Check for landing on a character that got split at"], "readability/old_style_comment"]
["src/nvim/normal.c", ["           */", "          if (curwin->w_virtcol > (colnr_T)i)", "            --curwin->w_cursor.col;"], "readability/braces"]
["src/nvim/normal.c", ["          if (curwin->w_virtcol > (colnr_T)i)", "            --curwin->w_cursor.col;", "        }"], "readability/increment"]
["src/nvim/normal.c", ["        }", "      } else if (nv_screengo(oap, FORWARD, cap->count1 - 1) == false)", "        clearopbeep(oap);"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * \"g*\" and \"g#\", like \"*\" and \"#\" but without using \"\\<\" and \"\\>\""], "readability/old_style_comment"]
["src/nvim/normal.c", ["#if POUND != '#'", "  case POUND:           /* pound sign (sometimes equal to '#') */", "#endif"], "readability/old_style_comment"]
["src/nvim/normal.c", ["#endif", "  case Ctrl_RSB:                /* :tag or :tselect for current identifier */", "  case ']':                     /* :tselect for current identifier */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case Ctrl_RSB:                /* :tag or :tselect for current identifier */", "  case ']':                     /* :tselect for current identifier */", "    nv_ident(cap);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * ge and gE: go back to end of word"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    oap->inclusive = true;", "    if (bckend_word(cap->count1, cap->nchar == 'E', false) == false)", "      clearopbeep(oap);"], "readability/braces"]
["src/nvim/normal.c", ["      if (curwin->w_cursor.col > (colnr_T)i) {", "        if (virtual_active())", "          curwin->w_cursor.coladd += curwin->w_cursor.col - i;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * \"gI\": Start insert in column 1."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    beginline(0);", "    if (!checkclearopq(oap))", "      invoke_edit(cap, false, 'g', false);"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * \"gf\": goto file, edit file under cursor"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"g'm\" and \"g`m\": jump to mark without setting pcmark */", "  case '\\'':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * \"gs\": Goto sleep."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * \"ga\": Display the ascii value of the character under the"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * \"g8\": Display the bytes used for the UTF-8 character under the"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case '8':", "    if (cap->count0 == 8)", "      utf_find_illegal();"], "readability/braces"]
["src/nvim/normal.c", ["      utf_find_illegal();", "    else", "      show_utf8();"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * \"gg\": Goto the first line in file.  With a count it goes to"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   *\t Two-character operators:"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * \"gd\": Find first occurrence of pattern under the cursor in the"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * g<*Mouse> : <C-*mouse>"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * \"gP\" and \"gp\": same as \"P\" and \"p\" but leave cursor just after new text"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"go\": goto byte count from start of buffer */", "  case 'o':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* \"gQ\": improved Ex mode */", "  case 'Q':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    if (!checkclearopq(oap))", "      do_exmode(true);"], "readability/braces"]
["src/nvim/normal.c", ["  case 't':", "    if (!checkclearop(oap))", "      goto_tabpage((int)cap->count0);"], "readability/braces"]
["src/nvim/normal.c", ["  case 'T':", "    if (!checkclearop(oap))", "      goto_tabpage(-(int)cap->count1);"], "readability/braces"]
["src/nvim/normal.c", ["  case '+':", "  case '-':   /* \"g+\" and \"g-\": undo or redo along the timeline */", "    if (!checkclearopq(oap))"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case '-':   /* \"g+\" and \"g-\": undo or redo along the timeline */", "    if (!checkclearopq(oap))", "      undo_time(cap->nchar == '-' ? -cap->count1 : cap->count1,"], "readability/braces"]
["src/nvim/normal.c", ["      undo_time(cap->nchar == '-' ? -cap->count1 : cap->count1,", "          false, false, false);", "    break;"], "whitespace/alignment"]
["src/nvim/normal.c", ["", "/*", " * Handle \"o\" and \"O\" commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (!checkclearopq(cap->oap)) {", "    if (cap->cmdchar == 'O')", "      /* Open above the first line of a folded sequence of lines */"], "readability/braces"]
["src/nvim/normal.c", ["    if (cap->cmdchar == 'O')", "      /* Open above the first line of a folded sequence of lines */", "      (void)hasFolding(curwin->w_cursor.lnum,"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      (void)hasFolding(curwin->w_cursor.lnum,", "          &curwin->w_cursor.lnum, NULL);", "    else"], "whitespace/alignment"]
["src/nvim/normal.c", ["          &curwin->w_cursor.lnum, NULL);", "    else", "      /* Open below the last line of a folded sequence of lines */"], "readability/braces"]
["src/nvim/normal.c", ["    else", "      /* Open below the last line of a folded sequence of lines */", "      (void)hasFolding(curwin->w_cursor.lnum,"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      (void)hasFolding(curwin->w_cursor.lnum,", "          NULL, &curwin->w_cursor.lnum);", "    if (u_save((linenr_T)(curwin->w_cursor.lnum -"], "whitespace/alignment"]
["src/nvim/normal.c", ["                          (cap->cmdchar == 'O' ? 1 : 0)),", "            (linenr_T)(curwin->w_cursor.lnum +", "                       (cap->cmdchar == 'o' ? 1 : 0))"], "whitespace/alignment"]
["src/nvim/normal.c", ["                       (cap->cmdchar == 'o' ? 1 : 0))", "            )", "        && open_line(cap->cmdchar == 'O' ? BACKWARD : FORWARD,"], "whitespace/alignment"]
["src/nvim/normal.c", ["", "/*", " * \".\" command: redo last change."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (!checkclearopq(cap->oap)) {", "    /*", "     * If \"restart_edit\" is true, the last but one command is repeated"], "readability/old_style_comment"]
["src/nvim/normal.c", ["     */", "    if (start_redo(cap->count0, restart_edit != 0 && !arrow_used) == false)", "      clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * CTRL-R: undo undo"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Handle \"U\" command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  /* In Visual mode and typing \"gUU\" triggers an operator */", "  if (cap->oap->op_type == OP_UPPER"], "readability/old_style_comment"]
["src/nvim/normal.c", ["      ) {", "    /* translate \"gUU\" to \"gUgU\" */", "    cap->cmdchar = 'g';"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * '~' command: If tilde is not an operator and Visual is off: swap case of a"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Handle an operator command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (op_type == cap->oap->op_type)         /* double operator works on lines */", "    nv_lineop(cap);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (op_type == cap->oap->op_type)         /* double operator works on lines */", "    nv_lineop(cap);"], "readability/braces"]
["src/nvim/normal.c", ["    nv_lineop(cap);", "  else if (!checkclearop(cap->oap)) {", "    cap->oap->start = curwin->w_cursor;"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Set v:operator to the characters for \"optype\"."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    assert(opchar0 >= 0 && opchar0 <= UCHAR_MAX);", "    opchars[0] = (char) opchar0;", ""], "whitespace/cast"]
["src/nvim/normal.c", ["    assert(opchar1 >= 0 && opchar1 <= UCHAR_MAX);", "    opchars[1] = (char) opchar1;", ""], "whitespace/cast"]
["src/nvim/normal.c", ["", "/*", " * Handle linewise operator \"dd\", \"yy\", etc."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * <Home> command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  /* CTRL-HOME is like \"gg\" */", "  if (mod_mask & MOD_MASK_CTRL)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* CTRL-HOME is like \"gg\" */", "  if (mod_mask & MOD_MASK_CTRL)", "    nv_goto(cap);"], "readability/braces"]
["src/nvim/normal.c", ["    nv_goto(cap);", "  else {", "    cap->count0 = 1;"], "readability/braces"]
["src/nvim/normal.c", ["    nv_goto(cap);", "  else {", "    cap->count0 = 1;"], "readability/braces"]
["src/nvim/normal.c", ["  }", "  ins_at_eol = false;       /* Don't move cursor past eol (only necessary in a", "                               one-character line). */"], "readability/multiline_comment"]
["src/nvim/normal.c", ["  }", "  ins_at_eol = false;       /* Don't move cursor past eol (only necessary in a", "                               one-character line). */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  }", "  ins_at_eol = false;       /* Don't move cursor past eol (only necessary in a", "                               one-character line). */"], "whitespace/parens"]
["src/nvim/normal.c", ["  ins_at_eol = false;       /* Don't move cursor past eol (only necessary in a", "                               one-character line). */", "}"], "whitespace/alignment"]
["src/nvim/normal.c", ["", "/*", " * \"|\" command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    curwin->w_curswant = (colnr_T)(cap->count0 - 1);", "  } else", "    curwin->w_curswant = 0;"], "readability/braces"]
["src/nvim/normal.c", ["    curwin->w_curswant = 0;", "  /* keep curswant at the column where we wanted to go, not where", "   * we ended; differs if line is too short */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Handle back-word command \"b\" and \"B\"."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  curwin->w_set_curswant = true;", "  if (bck_word(cap->count1, cap->arg, false) == false)", "    clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["    clearopbeep(cap->oap);", "  else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)", "    foldOpenCursor();"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Handle word motion commands \"e\", \"E\", \"w\" and \"W\"."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /*", "   * Set inclusive for the \"E\" and \"e\" command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["   */", "  if (cap->cmdchar == 'e' || cap->cmdchar == 'E')", "    word_end = true;"], "readability/braces"]
["src/nvim/normal.c", ["    word_end = true;", "  else", "    word_end = false;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /*", "   * \"cw\" and \"cW\" are a special case."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  curwin->w_set_curswant = true;", "  if (word_end)", "    n = end_word(cap->count1, cap->arg, flag, false);"], "readability/braces"]
["src/nvim/normal.c", ["    n = end_word(cap->count1, cap->arg, flag, false);", "  else", "    n = fwd_word(cap->count1, cap->arg, cap->oap->op_type != OP_NOP);"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* Don't leave the cursor on the NUL past the end of line. Unless we", "   * didn't move it forward. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   * didn't move it forward. */", "  if (lt(startpos, curwin->w_cursor))", "    adjust_cursor(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["", "  if (n == false && cap->oap->op_type == OP_NOP)", "    clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["    clearopbeep(cap->oap);", "  else {", "    adjust_for_sel(cap);"], "readability/braces"]
["src/nvim/normal.c", ["    clearopbeep(cap->oap);", "  else {", "    adjust_for_sel(cap);"], "readability/braces"]
["src/nvim/normal.c", ["    adjust_for_sel(cap);", "    if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)", "      foldOpenCursor();"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Used after a movement command: If the cursor ends up on the NUL after the"], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  /* The cursor cannot remain on the NUL when:", "   * - the column is > 0"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * \"0\" and \"^\" commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  beginline(cap->arg);", "  if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)", "    foldOpenCursor();"], "readability/braces"]
["src/nvim/normal.c", ["    foldOpenCursor();", "  ins_at_eol = false;       /* Don't move cursor past eol (only necessary in a", "                               one-character line). */"], "readability/multiline_comment"]
["src/nvim/normal.c", ["    foldOpenCursor();", "  ins_at_eol = false;       /* Don't move cursor past eol (only necessary in a", "                               one-character line). */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    foldOpenCursor();", "  ins_at_eol = false;       /* Don't move cursor past eol (only necessary in a", "                               one-character line). */"], "whitespace/parens"]
["src/nvim/normal.c", ["  ins_at_eol = false;       /* Don't move cursor past eol (only necessary in a", "                               one-character line). */", "}"], "whitespace/alignment"]
["src/nvim/normal.c", ["", "/*", " * In exclusive Visual mode, may include the last character."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Exclude last character at end of Visual area for 'selection' == \"exclusive\"."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (*p_sel == 'e' && !equalpos(VIsual, curwin->w_cursor)) {", "    if (lt(VIsual, curwin->w_cursor))", "      pp = &curwin->w_cursor;"], "readability/braces"]
["src/nvim/normal.c", ["      pp = &curwin->w_cursor;", "    else", "      pp = &VIsual;"], "readability/braces"]
["src/nvim/normal.c", ["    } else if (pp->lnum > 1) {", "      --pp->lnum;", "      pp->col = (colnr_T)STRLEN(ml_get(pp->lnum));"], "readability/increment"]
["src/nvim/normal.c", ["", "/*", " * SELECT key in Normal or Visual mode: end of Select mode mapping."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (VIsual_active)", "    VIsual_select = true;"], "readability/braces"]
["src/nvim/normal.c", ["    VIsual_select = true;", "  else if (VIsual_reselect) {", "    cap->nchar = 'v';               /* fake \"gv\" command */"], "readability/braces"]
["src/nvim/normal.c", ["  else if (VIsual_reselect) {", "    cap->nchar = 'v';               /* fake \"gv\" command */", "    cap->arg = true;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * \"G\", \"gg\", CTRL-END, CTRL-HOME."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (cap->arg)", "    lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/normal.c", ["    lnum = curbuf->b_ml.ml_line_count;", "  else", "    lnum = 1L;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* When a count is given, use it instead of the default lnum */", "  if (cap->count0 != 0)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  /* When a count is given, use it instead of the default lnum */", "  if (cap->count0 != 0)", "    lnum = cap->count0;"], "readability/braces"]
["src/nvim/normal.c", ["    lnum = cap->count0;", "  if (lnum < 1L)", "    lnum = 1L;"], "readability/braces"]
["src/nvim/normal.c", ["    lnum = 1L;", "  else if (lnum > curbuf->b_ml.ml_line_count)", "    lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/normal.c", ["  beginline(BL_SOL | BL_FIX);", "  if ((fdo_flags & FDO_JUMP) && KeyTyped && cap->oap->op_type == OP_NOP)", "    foldOpenCursor();"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * CTRL-\\ in Normal mode."], "readability/old_style_comment"]
["src/nvim/normal.c", ["    clearop(cap->oap);", "    if (restart_edit != 0 && mode_displayed)", "      clear_cmdline = true;                     /* unshow mode later */"], "readability/braces"]
["src/nvim/normal.c", ["    if (restart_edit != 0 && mode_displayed)", "      clear_cmdline = true;                     /* unshow mode later */", "    restart_edit = 0;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    restart_edit = 0;", "    if (cmdwin_type != 0)", "      cmdwin_result = Ctrl_C;"], "readability/braces"]
["src/nvim/normal.c", ["    if (VIsual_active) {", "      end_visual_mode();                /* stop Visual */", "      redraw_curbuf_later(INVERTED);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    }", "    /* CTRL-\\ CTRL-G restarts Insert mode when 'insertmode' is set. */", "    if (cap->nchar == Ctrl_G && p_im)"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    /* CTRL-\\ CTRL-G restarts Insert mode when 'insertmode' is set. */", "    if (cap->nchar == Ctrl_G && p_im)", "      restart_edit = 'a';"], "readability/braces"]
["src/nvim/normal.c", ["      restart_edit = 'a';", "  } else", "    clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * ESC in Normal mode: beep, but don't flush buffers."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (cap->arg) {               /* true for CTRL-C */", "    if (restart_edit == 0"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    /* Don't reset \"restart_edit\" when 'insertmode' is set, it won't be", "     * set again below when halfway through a mapping. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["     * set again below when halfway through a mapping. */", "    if (!p_im)", "      restart_edit = 0;"], "readability/braces"]
["src/nvim/normal.c", ["      cmdwin_result = K_IGNORE;", "      got_int = false;          /* don't stop executing autocommands et al. */", "      return;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (VIsual_active) {", "    end_visual_mode();          /* stop Visual */", "    check_cursor_col();         /* make sure cursor is not beyond EOL */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    end_visual_mode();          /* stop Visual */", "    check_cursor_col();         /* make sure cursor is not beyond EOL */", "    curwin->w_set_curswant = true;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* A CTRL-C is often used at the start of a menu.  When 'insertmode' is", "   * set return to Insert mode afterwards. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   * set return to Insert mode afterwards. */", "  if (restart_edit == 0 && goto_im()", "      && ex_normal_busy == 0"], "readability/braces"]
["src/nvim/normal.c", ["", "    case 'I':           /* \"I\"nsert before the first non-blank */", "      beginline(BL_WHITE);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    case 'a':           /* \"a\"ppend is like \"i\"nsert on the next character. */", "      /* increment coladd when in virtual space, increment the"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    case 'a':           /* \"a\"ppend is like \"i\"nsert on the next character. */", "      /* increment coladd when in virtual space, increment the", "       * column otherwise, also to append after an unprintable char */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["       * column otherwise, also to append after an unprintable char */", "      if (virtual_active()", "          && (curwin->w_cursor.coladd > 0"], "readability/braces"]
["src/nvim/normal.c", ["        curwin->w_cursor.coladd++;", "      else if (*get_cursor_pos_ptr() != NUL)", "        inc_cursor();"], "readability/braces"]
["src/nvim/normal.c", ["", "      /* Pretend Insert mode here to allow the cursor on the", "       * character past the end of the line */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Invoke edit() and take care of \"restart_edit\" and the return value."], "readability/old_style_comment"]
["src/nvim/normal.c", ["static void", "invoke_edit (", "    cmdarg_T *cap,"], "whitespace/parens"]
["src/nvim/normal.c", ["    cmdarg_T *cap,", "    int repl,                       /* \"r\" or \"gr\" command */", "    int cmd,"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* Complicated: When the user types \"a<C-O>a\" we don't want to do Insert", "   * mode recursively.  But when doing \"a<C-O>.\" or \"a<C-O>rx\" we do allow"], "readability/old_style_comment"]
["src/nvim/normal.c", ["   * it. */", "  if (repl || !stuff_empty())", "    restart_edit_save = restart_edit;"], "readability/braces"]
["src/nvim/normal.c", ["    restart_edit_save = restart_edit;", "  else", "    restart_edit_save = 0;"], "readability/braces"]
["src/nvim/normal.c", ["", "  /* Always reset \"restart_edit\", this is not a restarted edit. */", "  restart_edit = 0;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (edit(cmd, startln, cap->count1))", "    cap->retval |= CA_COMMAND_BUSY;"], "readability/braces"]
["src/nvim/normal.c", ["", "  if (restart_edit == 0)", "    restart_edit = restart_edit_save;"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * \"a\" or \"i\" while an operator is pending or in Visual mode: object motion."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  if (cap->cmdchar == 'i')", "    include = false;        /* \"ix\" = inner object: exclude white space */"], "readability/braces"]
["src/nvim/normal.c", ["  if (cap->cmdchar == 'i')", "    include = false;        /* \"ix\" = inner object: exclude white space */", "  else"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    include = false;        /* \"ix\" = inner object: exclude white space */", "  else", "    include = true;         /* \"ax\" = an object: include white space */"], "readability/braces"]
["src/nvim/normal.c", ["  else", "    include = true;         /* \"ax\" = an object: include white space */", ""], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "  /* Make sure (), [], {} and <> are in 'matchpairs' */", "  mps_save = curbuf->b_p_mps;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  switch (cap->nchar) {", "  case 'w':       /* \"aw\" = a word */", "    flag = current_word(cap->oap, cap->count1, include, false);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    break;", "  case 'W':       /* \"aW\" = a WORD */", "    flag = current_word(cap->oap, cap->count1, include, true);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    break;", "  case 'b':       /* \"ab\" = a braces block */", "  case '(':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    break;", "  case 'B':       /* \"aB\" = a Brackets block */", "  case '{':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    break;", "  case '[':       /* \"a[\" = a [] block */", "  case ']':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    break;", "  case '<':       /* \"a<\" = a <> block */", "  case '>':"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    break;", "  case 't':       /* \"at\" = a tag block (xml and html) */", "    // Do not adjust oap->end in do_pending_operator()"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    break;", "  case 'p':       /* \"ap\" = a paragraph */", "    flag = current_par(cap->oap, cap->count1, include, 'p');"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    break;", "  case 's':       /* \"as\" = a sentence */", "    flag = current_sent(cap->oap, cap->count1, include);"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    break;", "  case '\"':       /* \"a\"\" = a double quoted string */", "  case '\\'':       /* \"a'\" = a single quoted string */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case '\"':       /* \"a\"\" = a double quoted string */", "  case '\\'':       /* \"a'\" = a single quoted string */", "  case '`':       /* \"a`\" = a backtick quoted string */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["  case '\\'':       /* \"a'\" = a single quoted string */", "  case '`':       /* \"a`\" = a backtick quoted string */", "    flag = current_quote(cap->oap, cap->count1, include,"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    flag = current_quote(cap->oap, cap->count1, include,", "        cap->nchar);", "    break;"], "whitespace/alignment"]
["src/nvim/normal.c", ["  curbuf->b_p_mps = mps_save;", "  if (!flag)", "    clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * \"q\" command: Start/stop recording."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (cap->oap->op_type == OP_FORMAT) {", "    /* \"gqq\" is the same as \"gqgq\": format line */", "    cap->cmdchar = 'g';"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * Handle the \"@r\" command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if (checkclearop(cap->oap))", "    return;"], "readability/braces"]
["src/nvim/normal.c", ["  if (cap->nchar == '=') {", "    if (get_expr_register() == NUL)", "      return;"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Handle the CTRL-U and CTRL-D commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  if ((cap->cmdchar == Ctrl_U && curwin->w_cursor.lnum == 1)", "      || (cap->cmdchar == Ctrl_D"], "readability/braces"]
["src/nvim/normal.c", ["    clearopbeep(cap->oap);", "  else if (!checkclearop(cap->oap))", "    halfpage(cap->cmdchar == Ctrl_D, cap->count0);"], "readability/braces"]
["src/nvim/normal.c", ["", "/*", " * Handle \"J\" or \"gJ\" command."], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * \"P\", \"gP\", \"p\" and \"gp\" commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["  if (cap->oap->op_type != OP_NOP) {", "    /* \"dp\" is \":diffput\" */", "    if (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'p') {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    if (VIsual_active) {", "      /* Putting in Visual mode: The put text replaces the selected", "       * text.  First delete the selected text, then put the new text."], "readability/old_style_comment"]
["src/nvim/normal.c", ["      dir = BACKWARD;", "      if ((VIsual_mode != 'V'", "           && curwin->w_cursor.col < curbuf->b_op_start.col)"], "readability/braces"]
["src/nvim/normal.c", ["              && curwin->w_cursor.lnum < curbuf->b_op_start.lnum))", "        /* cursor is at the end of the line or end of file, put", "         * forward. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["        dir = FORWARD;", "      /* May have been reset in do_put(). */", "      VIsual_active = true;"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    /* What to reselect with \"gv\"?  Selecting the just put text seems to", "     * be the most useful, since the original text was removed. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "    /* When all lines were selected and deleted do_put() leaves an empty", "     * line that needs to be deleted now. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "      /* If the cursor was in that line, move it to the end of the last", "       * line. */"], "readability/old_style_comment"]
["src/nvim/normal.c", ["", "/*", " * \"o\" and \"O\" commands."], "readability/old_style_comment"]
["src/nvim/normal.c", ["{", "  /* \"do\" is \":diffget\" */", "  if (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'o') {"], "readability/old_style_comment"]
["src/nvim/normal.c", ["    for (curwin->w_cursor.lnum = oap->start.lnum;", "         curwin->w_cursor.lnum <= oap->end.lnum; ++curwin->w_cursor.lnum) {", "      getvvcol(curwin, &curwin->w_cursor, NULL, NULL, &end);"], "readability/increment"]
["src/nvim/normal.c", ["", "/*", " * Return TRUE when 'mousemodel' is set to \"popup\" or \"popup_setpos\"."], "readability/old_style_comment"]
