["src/nvim/spell.c", ["", "/* for offsetof() */", "#include <stddef.h>"], "readability/old_style_comment"]
["src/nvim/spell.c", ["typedef struct {", "  short sft_score;              // lowest score used", "  char_u sft_word[1];           // soundfolded word, actually longer"], "runtime/int"]
["src/nvim/spell.c", ["    if (*ptr == '0' && (ptr[1] == 'b' || ptr[1] == 'B')) {", "      mi.mi_end = (char_u*) skipbin((char*) ptr + 2);", "    } else if (*ptr == '0' && (ptr[1] == 'x' || ptr[1] == 'X')) {"], "whitespace/operators"]
["src/nvim/spell.c", ["    if (*ptr == '0' && (ptr[1] == 'b' || ptr[1] == 'B')) {", "      mi.mi_end = (char_u*) skipbin((char*) ptr + 2);", "    } else if (*ptr == '0' && (ptr[1] == 'x' || ptr[1] == 'X')) {"], "whitespace/cast"]
["src/nvim/spell.c", ["  // language.", "  for (lpi = 0; lpi < wp->w_s->b_langp.ga_len; ++lpi) {", "    mi.mi_lp = LANGP_ENTRY(wp->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["      count_common_word(mi.mi_lp->lp_slang, ptr,", "          (int)(mi.mi_end - ptr), 1);", "      count_word = false;"], "whitespace/alignment"]
["src/nvim/spell.c", ["", "    if (mode == FIND_KEEPCOMPOUND)", "      // Skip over the previously found word(s)."], "readability/braces"]
["src/nvim/spell.c", ["    }", "", "  }"], "whitespace/blank_line"]
["src/nvim/spell.c", ["", "  if (byts == NULL)", "    return;                     // array is empty"], "readability/braces"]
["src/nvim/spell.c", ["  for (;; ) {", "    if (flen <= 0 && *mip->mi_fend != NUL)", "      flen = fold_more(mip);"], "readability/braces"]
["src/nvim/spell.c", ["      endidx[endidxcnt++] = arridx++;", "      --len;", ""], "readability/increment"]
["src/nvim/spell.c", ["      while (len > 0 && byts[arridx] == 0) {", "        ++arridx;", "        --len;"], "readability/increment"]
["src/nvim/spell.c", ["        ++arridx;", "        --len;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["      }", "      if (len == 0)", "        break;              // no children, word must end here"], "readability/braces"]
["src/nvim/spell.c", ["    // Stop looking at end of the line.", "    if (ptr[wlen] == NUL)", "      break;"], "readability/braces"]
["src/nvim/spell.c", ["    c = ptr[wlen];", "    if (c == TAB)           // <Tab> is handled like <Space>", "      c = ' ';"], "readability/braces"]
["src/nvim/spell.c", ["      idx_T m = (lo + hi) / 2;", "      if (byts[m] > c)", "        hi = m - 1;"], "readability/braces"]
["src/nvim/spell.c", ["        hi = m - 1;", "      else if (byts[m] < c)", "        lo = m + 1;"], "readability/braces"]
["src/nvim/spell.c", ["        lo = m + 1;", "      else {", "        lo = hi = m;"], "readability/braces"]
["src/nvim/spell.c", ["        lo = m + 1;", "      else {", "        lo = hi = m;"], "readability/braces"]
["src/nvim/spell.c", ["    // Stop if there is no matching byte.", "    if (hi < lo || byts[lo] != c)", "      break;"], "readability/braces"]
["src/nvim/spell.c", ["    arridx = idxs[lo];", "    ++wlen;", "    --flen;"], "readability/increment"]
["src/nvim/spell.c", ["    ++wlen;", "    --flen;", ""], "readability/increment"]
["src/nvim/spell.c", ["      for (;; ) {", "        if (flen <= 0 && *mip->mi_fend != NUL)", "          flen = fold_more(mip);"], "readability/braces"]
["src/nvim/spell.c", ["          flen = fold_more(mip);", "        if (ptr[wlen] != ' ' && ptr[wlen] != TAB)", "          break;"], "readability/braces"]
["src/nvim/spell.c", ["          break;", "        ++wlen;", "        --flen;"], "readability/increment"]
["src/nvim/spell.c", ["        ++wlen;", "        --flen;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["  while (endidxcnt > 0) {", "    --endidxcnt;", "    arridx = endidx[endidxcnt];"], "readability/increment"]
["src/nvim/spell.c", ["    if (spell_iswordp(ptr + wlen, mip->mi_win)) {", "      if (slang->sl_compprog == NULL && !slang->sl_nobreak)", "        continue;                   // next char is a word character"], "readability/braces"]
["src/nvim/spell.c", ["      word_ends = false;", "    } else", "      word_ends = true;"], "readability/braces"]
["src/nvim/spell.c", ["    for (len = byts[arridx - 1]; len > 0 && byts[arridx] == 0;", "         --len, ++arridx) {", "      uint32_t flags = idxs[arridx];"], "readability/increment"]
["src/nvim/spell.c", ["", "        if (mip->mi_capflags == WF_KEEPCAP", "            || !spell_valid_case(mip->mi_capflags, flags))"], "readability/braces"]
["src/nvim/spell.c", ["      // mip->mi_prefarridx that find_prefix() filled.", "      else if (mode == FIND_PREFIX && !prefix_found) {", "        c = valid_word_prefix(mip->mi_prefcnt, mip->mi_prefarridx,"], "whitespace/newline"]
["src/nvim/spell.c", ["        c = valid_word_prefix(mip->mi_prefcnt, mip->mi_prefarridx,", "            flags,", "            mip->mi_word + mip->mi_cprefixlen, slang,"], "whitespace/alignment"]
["src/nvim/spell.c", ["            flags,", "            mip->mi_word + mip->mi_cprefixlen, slang,", "            false);"], "whitespace/alignment"]
["src/nvim/spell.c", ["            mip->mi_word + mip->mi_cprefixlen, slang,", "            false);", "        if (c == 0)"], "whitespace/alignment"]
["src/nvim/spell.c", ["            false);", "        if (c == 0)", "          continue;"], "readability/braces"]
["src/nvim/spell.c", ["        // Use the WF_RARE flag for a rare prefix.", "        if (c & WF_RAREPFX)", "          flags |= WF_RARE;"], "readability/braces"]
["src/nvim/spell.c", ["        // anyway.", "        if (((unsigned)flags >> 24) == 0", "            || wlen - mip->mi_compoff < slang->sl_compminlen)"], "readability/braces"]
["src/nvim/spell.c", ["        // maximum for syllables is specified.", "        if (!word_ends && mip->mi_complen + mip->mi_compextra + 2", "            > slang->sl_compmax"], "readability/braces"]
["src/nvim/spell.c", ["        // unless COMPOUNDPERMITFLAG was used.", "        if (mip->mi_complen > 0 && (flags & WF_NOCOMPBEF))", "          continue;"], "readability/braces"]
["src/nvim/spell.c", ["          continue;", "        if (!word_ends && (flags & WF_NOCOMPAFT))", "          continue;"], "readability/braces"]
["src/nvim/spell.c", ["        // Quickly check if compounding is possible with this flag.", "        if (!byte_in_str(mip->mi_complen == 0", "                ? slang->sl_compstartflags"], "readability/braces"]
["src/nvim/spell.c", ["        if (!byte_in_str(mip->mi_complen == 0", "                ? slang->sl_compstartflags", "                : slang->sl_compallflags,"], "whitespace/alignment"]
["src/nvim/spell.c", ["                ? slang->sl_compstartflags", "                : slang->sl_compallflags,", "                ((unsigned)flags >> 24)))"], "whitespace/alignment"]
["src/nvim/spell.c", ["                : slang->sl_compallflags,", "                ((unsigned)flags >> 24)))", "          continue;"], "whitespace/alignment"]
["src/nvim/spell.c", ["        // discard the compound word.", "        if (match_checkcompoundpattern(ptr, wlen, &slang->sl_comppat))", "          continue;"], "readability/braces"]
["src/nvim/spell.c", ["          capflags = captype(p, mip->mi_word + wlen);", "          if (capflags == WF_KEEPCAP || (capflags == WF_ALLCAP", "                                         && (flags & WF_FIXCAP) != 0))"], "readability/braces"]
["src/nvim/spell.c", ["            // \"fword\" is only needed for checking syllables.", "            if (ptr == mip->mi_word)", "              (void)spell_casefold(ptr, wlen, fword, MAXWLEN);"], "readability/braces"]
["src/nvim/spell.c", ["              (void)spell_casefold(ptr, wlen, fword, MAXWLEN);", "            else", "              STRLCPY(fword, ptr, endlen[endidxcnt] + 1);"], "readability/braces"]
["src/nvim/spell.c", ["          }", "          if (!can_compound(slang, fword, mip->mi_compflags))", "            continue;"], "readability/braces"]
["src/nvim/spell.c", ["            continue;", "        } else if (slang->sl_comprules != NULL", "                   && !match_compoundrule(slang, mip->mi_compflags))"], "readability/braces"]
["src/nvim/spell.c", ["      // Check NEEDCOMPOUND: can't use word without compounding.", "      else if (flags & WF_NEEDCOMP)", "        continue;"], "whitespace/newline"]
["src/nvim/spell.c", ["        // Recursive!", "        if (slang->sl_nobreak)", "          mip->mi_result = SP_BAD;"], "readability/braces"]
["src/nvim/spell.c", ["#endif", "        ++mip->mi_complen;", "        if (flags & WF_COMPROOT)"], "readability/increment"]
["src/nvim/spell.c", ["        ++mip->mi_complen;", "        if (flags & WF_COMPROOT)", "          ++mip->mi_compextra;"], "readability/braces"]
["src/nvim/spell.c", ["        if (flags & WF_COMPROOT)", "          ++mip->mi_compextra;", ""], "readability/increment"]
["src/nvim/spell.c", ["        // to find the \".add\" file(s).", "        for (int lpi = 0; lpi < mip->mi_win->w_s->b_langp.ga_len; ++lpi) {", "          if (slang->sl_nobreak) {"], "readability/increment"]
["src/nvim/spell.c", ["            mip->mi_lp = LANGP_ENTRY(mip->mi_win->w_s->b_langp, lpi);", "            if (mip->mi_lp->lp_slang->sl_fidxs == NULL", "                || !mip->mi_lp->lp_slang->sl_nobreak)"], "readability/braces"]
["src/nvim/spell.c", ["", "          if (!slang->sl_nobreak)", "            break;"], "readability/braces"]
["src/nvim/spell.c", ["        }", "        --mip->mi_complen;", "        if (flags & WF_COMPROOT)"], "readability/increment"]
["src/nvim/spell.c", ["        --mip->mi_complen;", "        if (flags & WF_COMPROOT)", "          --mip->mi_compextra;"], "readability/braces"]
["src/nvim/spell.c", ["        if (flags & WF_COMPROOT)", "          --mip->mi_compextra;", "        mip->mi_lp = save_lp;"], "readability/increment"]
["src/nvim/spell.c", ["        } else {", "          if (mip->mi_result == SP_OK)", "            break;"], "readability/braces"]
["src/nvim/spell.c", ["      int res = SP_BAD;", "      if (flags & WF_BANNED)", "        res = SP_BANNED;"], "readability/braces"]
["src/nvim/spell.c", ["        res = SP_BANNED;", "      else if (flags & WF_REGION) {", "        // Check region."], "readability/braces"]
["src/nvim/spell.c", ["        // Check region.", "        if ((mip->mi_lp->lp_region & (flags >> 16)) != 0)", "          res = SP_OK;"], "readability/braces"]
["src/nvim/spell.c", ["          res = SP_OK;", "        else", "          res = SP_LOCAL;"], "readability/braces"]
["src/nvim/spell.c", ["          res = SP_LOCAL;", "      } else if (flags & WF_RARE)", "        res = SP_RARE;"], "readability/braces"]
["src/nvim/spell.c", ["        res = SP_RARE;", "      else", "        res = SP_OK;"], "readability/braces"]
["src/nvim/spell.c", ["          mip->mi_end2 = mip->mi_word + wlen;", "        } else if (mip->mi_result2 == res", "                   && mip->mi_end2 < mip->mi_word + wlen)"], "readability/braces"]
["src/nvim/spell.c", ["        mip->mi_end = mip->mi_word + wlen;", "      } else if (mip->mi_result == res && mip->mi_end < mip->mi_word + wlen)", "        mip->mi_end = mip->mi_word + wlen;"], "readability/braces"]
["src/nvim/spell.c", ["", "      if (mip->mi_result == SP_OK)", "        break;"], "readability/braces"]
["src/nvim/spell.c", ["", "    if (mip->mi_result == SP_OK)", "      break;"], "readability/braces"]
["src/nvim/spell.c", ["static bool", "match_checkcompoundpattern (", "    char_u *ptr,"], "whitespace/parens"]
["src/nvim/spell.c", ["      len = (int)STRLEN(p);", "      if (len <= wlen && STRNCMP(ptr + wlen - len, p, len) == 0)", "        return true;"], "readability/braces"]
["src/nvim/spell.c", ["  // COMPOUNDWORDMAX then compounding is not allowed.", "  if (slang->sl_compsylmax < MAXWLEN", "      && count_syllables(slang, word) > slang->sl_compsylmax)"], "readability/braces"]
["src/nvim/spell.c", ["// lines if they don't contain wildcards.", "static bool can_be_compound(trystate_T *sp, slang_T *slang, char_u *compflags, int flag)", "{"], "whitespace/line_length"]
["src/nvim/spell.c", ["  // then it can't possibly compound.", "  if (!byte_in_str(sp->ts_complen == sp->ts_compsplit", "          ? slang->sl_compstartflags : slang->sl_compallflags, flag))"], "readability/braces"]
["src/nvim/spell.c", ["  if (!byte_in_str(sp->ts_complen == sp->ts_compsplit", "          ? slang->sl_compstartflags : slang->sl_compallflags, flag))", "    return false;"], "whitespace/alignment"]
["src/nvim/spell.c", ["  // loop over all the COMPOUNDRULE entries", "  for (p = slang->sl_comprules; *p != NUL; ++p) {", "    // loop over the flags in the compound word we have made, match"], "readability/increment"]
["src/nvim/spell.c", ["    // them against the current rule entry", "    for (i = 0;; ++i) {", "      c = compflags[i];"], "readability/increment"]
["src/nvim/spell.c", ["      c = compflags[i];", "      if (c == NUL)", "        // found a rule that matches for the flags we have so far"], "readability/braces"]
["src/nvim/spell.c", ["        return true;", "      if (*p == '/' || *p == NUL)", "        break;          // end of rule, it's too short"], "readability/braces"]
["src/nvim/spell.c", ["        // compare against all the flags in []", "        ++p;", "        while (*p != ']' && *p != NUL)"], "readability/increment"]
["src/nvim/spell.c", ["        ++p;", "        while (*p != ']' && *p != NUL)", "          if (*p++ == c)"], "readability/braces"]
["src/nvim/spell.c", ["        while (*p != ']' && *p != NUL)", "          if (*p++ == c)", "            match = true;"], "readability/braces"]
["src/nvim/spell.c", ["            match = true;", "        if (!match)", "          break;            // none matches"], "readability/braces"]
["src/nvim/spell.c", ["          break;            // none matches", "      } else if (*p != c)", "        break;          // flag of word doesn't match flag in pattern"], "readability/braces"]
["src/nvim/spell.c", ["        break;          // flag of word doesn't match flag in pattern", "      ++p;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["    p = vim_strchr(p, '/');", "    if (p == NULL)", "      break;"], "readability/braces"]
["src/nvim/spell.c", ["static int", "valid_word_prefix (", "    int totprefcnt,                 // nr of prefix IDs"], "whitespace/parens"]
["src/nvim/spell.c", ["  prefid = (unsigned)flags >> 24;", "  for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt) {", "    pidx = slang->sl_pidxs[arridx + prefcnt];"], "readability/increment"]
["src/nvim/spell.c", ["    // Check the prefix ID.", "    if (prefid != (pidx & 0xff))", "      continue;"], "readability/braces"]
["src/nvim/spell.c", ["    // suffix.", "    if ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))", "      continue;"], "readability/braces"]
["src/nvim/spell.c", ["      }", "    } else if (cond_req)", "      continue;"], "readability/braces"]
["src/nvim/spell.c", ["  byts = slang->sl_pbyts;", "  if (byts == NULL)", "    return;                     // array is empty"], "readability/braces"]
["src/nvim/spell.c", ["  for (;; ) {", "    if (flen == 0 && *mip->mi_fend != NUL)", "      flen = fold_more(mip);"], "readability/braces"]
["src/nvim/spell.c", ["      while (len > 0 && byts[arridx] == 0) {", "        ++arridx;", "        --len;"], "readability/increment"]
["src/nvim/spell.c", ["        ++arridx;", "        --len;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["      mip->mi_prefixlen = wlen;", "      if (mode == FIND_COMPOUND)", "        // Skip over the previously found word(s)."], "readability/braces"]
["src/nvim/spell.c", ["", "      if (len == 0)", "        break;              // no children, word must end here"], "readability/braces"]
["src/nvim/spell.c", ["    // Stop looking at end of the line.", "    if (ptr[wlen] == NUL)", "      break;"], "readability/braces"]
["src/nvim/spell.c", ["      m = (lo + hi) / 2;", "      if (byts[m] > c)", "        hi = m - 1;"], "readability/braces"]
["src/nvim/spell.c", ["        hi = m - 1;", "      else if (byts[m] < c)", "        lo = m + 1;"], "readability/braces"]
["src/nvim/spell.c", ["        lo = m + 1;", "      else {", "        lo = hi = m;"], "readability/braces"]
["src/nvim/spell.c", ["        lo = m + 1;", "      else {", "        lo = hi = m;"], "readability/braces"]
["src/nvim/spell.c", ["    // Stop if there is no matching byte.", "    if (hi < lo || byts[lo] != c)", "      break;"], "readability/braces"]
["src/nvim/spell.c", ["    arridx = idxs[lo];", "    ++wlen;", "    --flen;"], "readability/increment"]
["src/nvim/spell.c", ["    ++wlen;", "    --flen;", "  }"], "readability/increment"]
["src/nvim/spell.c", ["  (void)spell_casefold(p, (int)(mip->mi_fend - p),", "      mip->mi_fword + mip->mi_fwordlen,", "      MAXWLEN - mip->mi_fwordlen);"], "whitespace/alignment"]
["src/nvim/spell.c", ["      mip->mi_fword + mip->mi_fwordlen,", "      MAXWLEN - mip->mi_fwordlen);", "  flen = (int)STRLEN(mip->mi_fword + mip->mi_fwordlen);"], "whitespace/alignment"]
["src/nvim/spell.c", ["size_t", "spell_move_to (", "    win_T *wp,"], "whitespace/parens"]
["src/nvim/spell.c", ["", "  if (no_spell_checking(wp))", "    return 0;"], "readability/braces"]
["src/nvim/spell.c", ["  while (!got_int) {", "    line = ml_get_buf(wp->w_buffer, lnum, FALSE);", ""], "readability/bool"]
["src/nvim/spell.c", ["    // In first line check first word for Capital.", "    if (lnum == 1)", "      capcol = 0;"], "readability/braces"]
["src/nvim/spell.c", ["      // one.", "      line = ml_get_buf(wp->w_buffer, lnum, FALSE);", "    }"], "readability/bool"]
["src/nvim/spell.c", ["    STRCPY(buf, line);", "    if (lnum < wp->w_buffer->b_ml.ml_line_count)", "      spell_cat_line(buf + STRLEN(buf),"], "readability/braces"]
["src/nvim/spell.c", ["      spell_cat_line(buf + STRLEN(buf),", "                     ml_get_buf(wp->w_buffer, lnum + 1, FALSE),", "                     MAXWLEN);"], "readability/bool"]
["src/nvim/spell.c", ["      // we wrapped around the end of the buffer.", "      if (dir == BACKWARD", "          && lnum == wp->w_cursor.lnum"], "readability/braces"]
["src/nvim/spell.c", ["              (void)syn_get_id(wp, lnum, (colnr_T)col,", "                  FALSE, &can_spell, FALSE);", "              if (!can_spell)"], "whitespace/alignment"]
["src/nvim/spell.c", ["              (void)syn_get_id(wp, lnum, (colnr_T)col,", "                  FALSE, &can_spell, FALSE);", "              if (!can_spell)"], "readability/bool"]
["src/nvim/spell.c", ["                  FALSE, &can_spell, FALSE);", "              if (!can_spell)", "                attr = HLF_COUNT;"], "readability/braces"]
["src/nvim/spell.c", ["                attr = HLF_COUNT;", "            } else", "              can_spell = true;"], "readability/braces"]
["src/nvim/spell.c", ["                xfree(buf);", "                if (attrp != NULL)", "                  *attrp = attr;"], "readability/braces"]
["src/nvim/spell.c", ["            }", "          } else", "            found_one = true;"], "readability/braces"]
["src/nvim/spell.c", ["        wrapped = true;", "        if (!shortmess(SHM_SEARCH))", "          give_warning((char_u *)_(top_bot_msg), true);"], "readability/braces"]
["src/nvim/spell.c", ["    } else {", "      if (lnum < wp->w_buffer->b_ml.ml_line_count)", "        ++lnum;"], "readability/braces"]
["src/nvim/spell.c", ["      if (lnum < wp->w_buffer->b_ml.ml_line_count)", "        ++lnum;", "      else if (!p_ws)"], "readability/increment"]
["src/nvim/spell.c", ["        ++lnum;", "      else if (!p_ws)", "        break;              // at first line and 'nowrapscan'"], "readability/braces"]
["src/nvim/spell.c", ["        break;              // at first line and 'nowrapscan'", "      else {", "        // Wrap around to the start of the buffer.  May search the"], "readability/braces"]
["src/nvim/spell.c", ["        break;              // at first line and 'nowrapscan'", "      else {", "        // Wrap around to the start of the buffer.  May search the"], "readability/braces"]
["src/nvim/spell.c", ["        wrapped = true;", "        if (!shortmess(SHM_SEARCH))", "          give_warning((char_u *)_(bot_top_msg), true);"], "readability/braces"]
["src/nvim/spell.c", ["      // included in a match crossing line boundaries.", "      if (attr == HLF_COUNT)", "        skip = (int)(p - endp);"], "readability/braces"]
["src/nvim/spell.c", ["        skip = (int)(p - endp);", "      else", "        skip = 0;"], "readability/braces"]
["src/nvim/spell.c", ["      // Capcol skips over the inserted space.", "      --capcol;", ""], "readability/increment"]
["src/nvim/spell.c", ["      // But after empty line check first word in next line", "      if (*skipwhite(line) == NUL)", "        capcol = 0;"], "readability/braces"]
["src/nvim/spell.c", ["  p = skipwhite(line);", "  while (vim_strchr((char_u *)\"*#/\\\"\\t\", *p) != NULL)", "    p = skipwhite(p + 1);"], "readability/braces"]
["src/nvim/spell.c", ["  // autocommand may load it then.", "  for (round = 1; round <= 2; ++round) {", "    // Find the first spell file for \"lang\" in 'runtimepath' and load it."], "readability/increment"]
["src/nvim/spell.c", ["", "      if (r == FAIL && *sl.sl_lang != NUL && round == 1", "          && apply_autocmds(EVENT_SPELLFILEMISSING, lang,"], "readability/braces"]
["src/nvim/spell.c", ["          && apply_autocmds(EVENT_SPELLFILEMISSING, lang,", "              curbuf->b_fname, FALSE, curbuf))", "        continue;"], "whitespace/alignment"]
["src/nvim/spell.c", ["          && apply_autocmds(EVENT_SPELLFILEMISSING, lang,", "              curbuf->b_fname, FALSE, curbuf))", "        continue;"], "whitespace/alignment"]
["src/nvim/spell.c", ["          && apply_autocmds(EVENT_SPELLFILEMISSING, lang,", "              curbuf->b_fname, FALSE, curbuf))", "        continue;"], "readability/bool"]
["src/nvim/spell.c", ["      smsg(", "        _(\"Warning: Cannot find word list \\\"%s.%s.spl\\\" or \\\"%s.ascii.spl\\\"\"),", "        lang, spell_enc(), lang);"], "whitespace/indent"]
["src/nvim/spell.c", ["        _(\"Warning: Cannot find word list \\\"%s.%s.spl\\\" or \\\"%s.ascii.spl\\\"\"),", "        lang, spell_enc(), lang);", "    }"], "whitespace/indent"]
["src/nvim/spell.c", ["{", "", "  if (STRLEN(p_enc) < 60 && STRCMP(p_enc, \"iso-8859-15\") != 0)"], "whitespace/blank_line"]
["src/nvim/spell.c", ["", "  if (STRLEN(p_enc) < 60 && STRCMP(p_enc, \"iso-8859-15\") != 0)", "    return p_enc;"], "readability/braces"]
["src/nvim/spell.c", ["  vim_snprintf((char *)fname, MAXPATHL, SPL_FNAME_TMPL,", "      int_wordlist, spell_enc());", "}"], "whitespace/alignment"]
["src/nvim/spell.c", ["", "  if (lang != NULL)", "    lp->sl_name = vim_strsave(lang);"], "readability/braces"]
["src/nvim/spell.c", ["/// Frees a salitem_T", "static void free_salitem(salitem_T *smp) {", "  xfree(smp->sm_lead);"], "readability/braces"]
["src/nvim/spell.c", ["/// Frees a fromto_T", "static void free_fromto(fromto_T *ftp) {", "  xfree(ftp->ft_from);"], "readability/braces"]
["src/nvim/spell.c", ["", "  for (int i = 0; i < lp->sl_prefixcnt; ++i) {", "    vim_regfree(lp->sl_prefprog[i]);"], "readability/increment"]
["src/nvim/spell.c", ["    // \".add\" files.", "    if (slp->sl_nobreak && slang->sl_add)", "      slang->sl_nobreak = true;"], "readability/braces"]
["src/nvim/spell.c", ["      slang->sl_nobreak = true;", "    else if (slang->sl_nobreak)", "      slp->sl_nobreak = true;"], "readability/braces"]
["src/nvim/spell.c", ["    wc = HI2WC(hi);", "    if ((wc->wc_count += count) < (unsigned)count)      // check for overflow", "      wc->wc_count = MAXWORDCOUNT;"], "readability/braces"]
["src/nvim/spell.c", ["static int", "score_wordcount_adj (", "    slang_T *slang,"], "whitespace/parens"]
["src/nvim/spell.c", ["    wc = HI2WC(hi);", "    if (wc->wc_count < SCORE_THRES2)", "      bonus = SCORE_COMMON1;"], "readability/braces"]
["src/nvim/spell.c", ["      bonus = SCORE_COMMON1;", "    else if (wc->wc_count < SCORE_THRES3)", "      bonus = SCORE_COMMON2;"], "readability/braces"]
["src/nvim/spell.c", ["      bonus = SCORE_COMMON2;", "    else", "      bonus = SCORE_COMMON3;"], "readability/braces"]
["src/nvim/spell.c", ["      bonus = SCORE_COMMON3;", "    if (split)", "      newscore = score - bonus / 2;"], "readability/braces"]
["src/nvim/spell.c", ["      newscore = score - bonus / 2;", "    else", "      newscore = score - bonus;"], "readability/braces"]
["src/nvim/spell.c", ["      newscore = score - bonus;", "    if (newscore < 0)", "      return 0;"], "readability/braces"]
["src/nvim/spell.c", ["", "  for (p = str; *p != NUL; ++p)", "    if (*p == n)"], "readability/braces"]
["src/nvim/spell.c", ["", "  for (p = str; *p != NUL; ++p)", "    if (*p == n)"], "readability/increment"]
["src/nvim/spell.c", ["  for (p = str; *p != NUL; ++p)", "    if (*p == n)", "      return true;"], "readability/braces"]
["src/nvim/spell.c", ["    *p++ = NUL;", "    if (*p == NUL)          // trailing slash", "      break;"], "readability/braces"]
["src/nvim/spell.c", ["    p = vim_strchr(p, '/');", "    if (p == NULL)", "      l = (int)STRLEN(s);"], "readability/braces"]
["src/nvim/spell.c", ["      l = (int)STRLEN(s);", "    else", "      l = (int)(p - s);"], "readability/braces"]
["src/nvim/spell.c", ["      l = (int)(p - s);", "    if (l >= SY_MAXLEN)", "      return SP_FORMERROR;"], "readability/braces"]
["src/nvim/spell.c", ["", "  if (slang->sl_syllable == NULL)", "    return 0;"], "readability/braces"]
["src/nvim/spell.c", ["    len = 0;", "    for (int i = 0; i < slang->sl_syl_items.ga_len; ++i) {", "      syl = ((syl_item_T *)slang->sl_syl_items.ga_data) + i;"], "readability/increment"]
["src/nvim/spell.c", ["      syl = ((syl_item_T *)slang->sl_syl_items.ga_data) + i;", "      if (syl->sy_len > len", "          && STRNCMP(p, syl->sy_chars, syl->sy_len) == 0)"], "readability/braces"]
["src/nvim/spell.c", ["    if (len != 0) {     // found a match, count syllable", "      ++cnt;", "      skip = false;"], "readability/increment"]
["src/nvim/spell.c", ["      len = (*mb_ptr2len)(p);", "      if (vim_strchr(slang->sl_syllable, c) == NULL)", "        skip = false;               // No, search for next syllable"], "readability/braces"]
["src/nvim/spell.c", ["        skip = false;               // No, search for next syllable", "      else if (!skip) {", "        ++cnt;                      // Yes, count it"], "readability/braces"]
["src/nvim/spell.c", ["      else if (!skip) {", "        ++cnt;                      // Yes, count it", "        skip = true;                // don't count following syllable chars"], "readability/increment"]
["src/nvim/spell.c", ["  // in which 'spell' is set.", "  if (recursive)", "    return NULL;"], "readability/braces"]
["src/nvim/spell.c", ["        region = region_cp;", "      } else", "        dont_use_region = true;"], "readability/braces"]
["src/nvim/spell.c", ["        lang[len - 3] = NUL;", "      } else", "        dont_use_region = true;"], "readability/braces"]
["src/nvim/spell.c", ["      // Check if we loaded this language before.", "      for (slang = first_lang; slang != NULL; slang = slang->sl_next)", "        if (STRICMP(lang, slang->sl_name) == 0)"], "readability/braces"]
["src/nvim/spell.c", ["      for (slang = first_lang; slang != NULL; slang = slang->sl_next)", "        if (STRICMP(lang, slang->sl_name) == 0)", "          break;"], "readability/braces"]
["src/nvim/spell.c", ["      // use it for 'spellfile'.", "      if (use_region != NULL && STRCMP(region, use_region) != 0)", "        dont_use_region = true;"], "readability/braces"]
["src/nvim/spell.c", ["    if (slang == NULL) {", "      if (filename)", "        (void)spell_load_file(lang, lang, NULL, false);"], "readability/braces"]
["src/nvim/spell.c", ["        (void)spell_load_file(lang, lang, NULL, false);", "      else {", "        spell_load_lang(lang);"], "readability/braces"]
["src/nvim/spell.c", ["        (void)spell_load_file(lang, lang, NULL, false);", "      else {", "        spell_load_lang(lang);"], "readability/braces"]
["src/nvim/spell.c", ["            if (slang->sl_add) {", "              if (*slang->sl_regions != NUL)", "                // This addition file is for other regions."], "readability/braces"]
["src/nvim/spell.c", ["                region_mask = 0;", "            } else", "              // This is probably an error.  Give a warning and"], "readability/braces"]
["src/nvim/spell.c", ["                   region);", "          } else", "            region_mask = 1 << c;"], "readability/braces"]
["src/nvim/spell.c", ["          use_midword(slang, wp);", "          if (slang->sl_nobreak)", "            nobreak = true;"], "readability/braces"]
["src/nvim/spell.c", ["  spf = curwin->w_s->b_p_spf;", "  for (round = 0; round == 0 || *spf != NUL; ++round) {", "    if (round == 0) {"], "readability/increment"]
["src/nvim/spell.c", ["      // Internal wordlist, if there is one.", "      if (int_wordlist == NULL)", "        continue;"], "readability/braces"]
["src/nvim/spell.c", ["      // If it was already found above then skip it.", "      for (c = 0; c < ga.ga_len; ++c) {", "        p = LANGP_ENTRY(ga, c)->lp_slang->sl_fname;"], "readability/increment"]
["src/nvim/spell.c", ["      }", "      if (c < ga.ga_len)", "        continue;"], "readability/braces"]
["src/nvim/spell.c", ["      // use an arbitrary name.", "      if (round == 0)", "        STRCPY(lang, \"internal wordlist\");"], "readability/braces"]
["src/nvim/spell.c", ["        STRCPY(lang, \"internal wordlist\");", "      else {", "        STRLCPY(lang, path_tail(spf_name), MAXWLEN + 1);"], "readability/braces"]
["src/nvim/spell.c", ["        STRCPY(lang, \"internal wordlist\");", "      else {", "        STRLCPY(lang, path_tail(spf_name), MAXWLEN + 1);"], "readability/braces"]
["src/nvim/spell.c", ["        p = vim_strchr(lang, '.');", "        if (p != NULL)", "          *p = NUL;             // truncate at \".encoding.add\""], "readability/braces"]
["src/nvim/spell.c", ["      // files also have this.", "      if (slang != NULL && nobreak)", "        slang->sl_nobreak = true;"], "readability/braces"]
["src/nvim/spell.c", ["        c = find_region(slang->sl_regions, use_region);", "        if (c != REGION_ALL)", "          region_mask = 1 << c;"], "readability/braces"]
["src/nvim/spell.c", ["          region_mask = 1 << c;", "        else if (*slang->sl_regions != NUL)", "          // This spell file is for other regions."], "readability/braces"]
["src/nvim/spell.c", ["  // with the same name.  E.g. for \"en-math\" use \"en\".", "  for (int i = 0; i < ga.ga_len; ++i) {", "    lp = LANGP_ENTRY(ga, i);"], "readability/increment"]
["src/nvim/spell.c", ["    // sound folding", "    if (!GA_EMPTY(&lp->lp_slang->sl_sal))", "      // language does sound folding itself"], "readability/braces"]
["src/nvim/spell.c", ["      lp->lp_sallang = lp->lp_slang;", "    else", "      // find first similar language that does sound folding"], "readability/braces"]
["src/nvim/spell.c", ["      // find first similar language that does sound folding", "      for (int j = 0; j < ga.ga_len; ++j) {", "        lp2 = LANGP_ENTRY(ga, j);"], "readability/increment"]
["src/nvim/spell.c", ["            && STRNCMP(lp->lp_slang->sl_name,", "                lp2->lp_slang->sl_name, 2) == 0) {", "          lp->lp_sallang = lp2->lp_slang;"], "whitespace/alignment"]
["src/nvim/spell.c", ["            && STRNCMP(lp->lp_slang->sl_name,", "                lp2->lp_slang->sl_name, 2) == 0) {", "          lp->lp_sallang = lp2->lp_slang;"], "whitespace/alignment"]
["src/nvim/spell.c", ["    // REP items", "    if (!GA_EMPTY(&lp->lp_slang->sl_rep))", "      // language has REP items itself"], "readability/braces"]
["src/nvim/spell.c", ["      lp->lp_replang = lp->lp_slang;", "    else", "      // find first similar language that has REP items"], "readability/braces"]
["src/nvim/spell.c", ["      // find first similar language that has REP items", "      for (int j = 0; j < ga.ga_len; ++j) {", "        lp2 = LANGP_ENTRY(ga, j);"], "readability/increment"]
["src/nvim/spell.c", ["            && STRNCMP(lp->lp_slang->sl_name,", "                lp2->lp_slang->sl_name, 2) == 0) {", "          lp->lp_replang = lp2->lp_slang;"], "whitespace/alignment"]
["src/nvim/spell.c", ["            && STRNCMP(lp->lp_slang->sl_name,", "                lp2->lp_slang->sl_name, 2) == 0) {", "          lp->lp_replang = lp2->lp_slang;"], "whitespace/alignment"]
["src/nvim/spell.c", ["  for (i = 0;; i += 2) {", "    if (rp[i] == NUL)", "      return REGION_ALL;"], "readability/braces"]
["src/nvim/spell.c", ["      return REGION_ALL;", "    if (rp[i] == region[0] && rp[i + 1] == region[1])", "      break;"], "readability/braces"]
["src/nvim/spell.c", ["", "  if (allcap)", "    return WF_ALLCAP;"], "readability/braces"]
["src/nvim/spell.c", ["    return WF_ALLCAP;", "  if (firstcap)", "    return WF_ONECAP;"], "readability/braces"]
["src/nvim/spell.c", ["      if (SPELL_ISUPPER(c)) {", "        ++u;", "        if (p == word)"], "readability/increment"]
["src/nvim/spell.c", ["        ++u;", "        if (p == word)", "          first = true;"], "readability/braces"]
["src/nvim/spell.c", ["          first = true;", "      } else", "        ++l;"], "readability/braces"]
["src/nvim/spell.c", ["      } else", "        ++l;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["    // require three upper case letters.", "    if (u > l && u > 2)", "      flags |= WF_ALLCAP;"], "readability/braces"]
["src/nvim/spell.c", ["      flags |= WF_ALLCAP;", "    else if (first)", "      flags |= WF_ONECAP;"], "readability/braces"]
["src/nvim/spell.c", ["", "    if (u >= 2 && l >= 2)       // maCARONI maCAroni", "      flags |= WF_MIXCAP;"], "readability/braces"]
["src/nvim/spell.c", ["{", "  char_u fname[MAXPATHL] = {0};", ""], "whitespace/braces"]
["src/nvim/spell.c", ["{", "  char_u fname[MAXPATHL] = {0};", ""], "whitespace/braces"]
["src/nvim/spell.c", ["  if (buf != NULL) {", "    ml_close(buf, TRUE);", "    xfree(buf);"], "readability/bool"]
["src/nvim/spell.c", ["", "  for (i = 0; i < 256; ++i) {", "    sp->st_fold[i] = i;"], "readability/increment"]
["src/nvim/spell.c", ["  // that is done separately.", "  for (i = '0'; i <= '9'; ++i)", "    sp->st_isw[i] = true;"], "readability/braces"]
["src/nvim/spell.c", ["  // that is done separately.", "  for (i = '0'; i <= '9'; ++i)", "    sp->st_isw[i] = true;"], "readability/increment"]
["src/nvim/spell.c", ["    sp->st_isw[i] = true;", "  for (i = 'A'; i <= 'Z'; ++i) {", "    sp->st_isw[i] = true;"], "readability/increment"]
["src/nvim/spell.c", ["  }", "  for (i = 'a'; i <= 'z'; ++i) {", "    sp->st_isw[i] = true;"], "readability/increment"]
["src/nvim/spell.c", ["{", "  if (wp->w_s->b_cjk)", "    // East Asian characters are not considered word characters."], "readability/braces"]
["src/nvim/spell.c", ["", "  if (*p < 256 ? wp->w_s->b_spell_ismw[*p]", "      : (wp->w_s->b_spell_ismw_mb != NULL"], "readability/braces"]
["src/nvim/spell.c", ["    s = p + 1;", "  else", "    s = p;"], "readability/braces"]
["src/nvim/spell.c", ["    }", "    if (f != 0)", "      sps_flags = f;"], "readability/braces"]
["src/nvim/spell.c", ["", "  if (sps_flags == 0)", "    sps_flags = SPS_BEST;"], "readability/braces"]
["src/nvim/spell.c", ["", "  if (no_spell_checking(curwin))", "    return;"], "readability/braces"]
["src/nvim/spell.c", ["    end_visual_mode();", "  } else", "  // Find the start of the badly spelled word."], "readability/braces"]
["src/nvim/spell.c", ["  // 'spellsuggest', whatever is smaller.", "  if (sps_limit > (int)Rows - 2)", "    limit = (int)Rows - 2;"], "readability/braces"]
["src/nvim/spell.c", ["    limit = (int)Rows - 2;", "  else", "    limit = sps_limit;"], "readability/braces"]
["src/nvim/spell.c", ["  spell_find_suggest(line + curwin->w_cursor.col, badlen, &sug, limit,", "      true, need_cap, true);", ""], "whitespace/alignment"]
["src/nvim/spell.c", ["", "  if (GA_EMPTY(&sug.su_ga))", "    MSG(_(\"Sorry, no suggestions\"));"], "readability/braces"]
["src/nvim/spell.c", ["    MSG(_(\"Sorry, no suggestions\"));", "  else if (count > 0) {", "    if (count > sug.su_ga.ga_len)"], "readability/braces"]
["src/nvim/spell.c", ["  else if (count > 0) {", "    if (count > sug.su_ga.ga_len)", "      smsg(_(\"Sorry, only %\" PRId64 \" suggestions\"),"], "readability/braces"]
["src/nvim/spell.c", ["    cmdmsg_rl = curwin->w_p_rl;", "    if (cmdmsg_rl)", "      msg_col = Columns - 1;"], "readability/braces"]
["src/nvim/spell.c", ["    vim_snprintf((char *)IObuff, IOSIZE, _(\"Change \\\"%.*s\\\" to:\"),", "        sug.su_badlen, sug.su_badptr);", "    if (cmdmsg_rl && STRNCMP(IObuff, \"Change\", 6) == 0) {"], "whitespace/alignment"]
["src/nvim/spell.c", ["      vim_snprintf((char *)IObuff, IOSIZE, \":ot \\\"%.*s\\\" egnahC\",", "          sug.su_badlen, sug.su_badptr);", "    }"], "whitespace/alignment"]
["src/nvim/spell.c", ["", "    msg_scroll = TRUE;", "    for (int i = 0; i < sug.su_ga.ga_len; ++i) {"], "readability/bool"]
["src/nvim/spell.c", ["    msg_scroll = TRUE;", "    for (int i = 0; i < sug.su_ga.ga_len; ++i) {", "      stp = &SUG(sug.su_ga, i);"], "readability/increment"]
["src/nvim/spell.c", ["      STRLCPY(wcopy, stp->st_word, MAXWLEN + 1);", "      if (sug.su_badlen > stp->st_orglen)", "        STRLCPY(wcopy + stp->st_wordlen,"], "readability/braces"]
["src/nvim/spell.c", ["        STRLCPY(wcopy + stp->st_wordlen,", "            sug.su_badptr + stp->st_orglen,", "            sug.su_badlen - stp->st_orglen + 1);"], "whitespace/alignment"]
["src/nvim/spell.c", ["            sug.su_badptr + stp->st_orglen,", "            sug.su_badlen - stp->st_orglen + 1);", "      vim_snprintf((char *)IObuff, IOSIZE, \"%2d\", i + 1);"], "whitespace/alignment"]
["src/nvim/spell.c", ["        // Add the score.", "        if (sps_flags & (SPS_DOUBLE | SPS_BEST))", "          vim_snprintf((char *)IObuff, IOSIZE, \" (%s%d - %d)\","], "readability/braces"]
["src/nvim/spell.c", ["          vim_snprintf((char *)IObuff, IOSIZE, \" (%s%d - %d)\",", "              stp->st_salscore ? \"s \" : \"\",", "              stp->st_score, stp->st_altscore);"], "whitespace/alignment"]
["src/nvim/spell.c", ["              stp->st_salscore ? \"s \" : \"\",", "              stp->st_score, stp->st_altscore);", "        else"], "whitespace/alignment"]
["src/nvim/spell.c", ["              stp->st_score, stp->st_altscore);", "        else", "          vim_snprintf((char *)IObuff, IOSIZE, \" (%d)\","], "readability/braces"]
["src/nvim/spell.c", ["          vim_snprintf((char *)IObuff, IOSIZE, \" (%d)\",", "              stp->st_score);", "        if (cmdmsg_rl)"], "whitespace/alignment"]
["src/nvim/spell.c", ["              stp->st_score);", "        if (cmdmsg_rl)", "          // Mirror the numbers, but keep the leading space."], "readability/braces"]
["src/nvim/spell.c", ["", "    cmdmsg_rl = FALSE;", "    msg_col = 0;"], "readability/bool"]
["src/nvim/spell.c", ["      vim_snprintf((char *)IObuff, IOSIZE, \"%s%.*s\", stp->st_word,", "          sug.su_badlen - stp->st_orglen,", "          sug.su_badptr + stp->st_orglen);"], "whitespace/alignment"]
["src/nvim/spell.c", ["          sug.su_badlen - stp->st_orglen,", "          sug.su_badptr + stp->st_orglen);", "      repl_to = vim_strsave(IObuff);"], "whitespace/alignment"]
["src/nvim/spell.c", ["    AppendToRedobuffLit(p + c,", "        stp->st_wordlen + sug.su_badlen - stp->st_orglen);", "    AppendCharToRedobuff(ESC);"], "whitespace/alignment"]
["src/nvim/spell.c", ["    changed_bytes(curwin->w_cursor.lnum, c);", "  } else", "    curwin->w_cursor = prev_cursor;"], "readability/braces"]
["src/nvim/spell.c", ["", "  if (curwin->w_s->b_cap_prog == NULL)", "    return false;"], "readability/braces"]
["src/nvim/spell.c", ["    // ends there.", "    if (lnum == 1)", "      need_cap = true;"], "readability/braces"]
["src/nvim/spell.c", ["      need_cap = true;", "    else {", "      line = ml_get(lnum - 1);"], "readability/braces"]
["src/nvim/spell.c", ["      need_cap = true;", "    else {", "      line = ml_get(lnum - 1);"], "readability/braces"]
["src/nvim/spell.c", ["      line = ml_get(lnum - 1);", "      if (*skipwhite(line) == NUL)", "        need_cap = true;"], "readability/braces"]
["src/nvim/spell.c", ["        need_cap = true;", "      else {", "        // Append a space in place of the line break."], "readability/braces"]
["src/nvim/spell.c", ["        need_cap = true;", "      else {", "        // Append a space in place of the line break."], "readability/braces"]
["src/nvim/spell.c", ["    regmatch.regprog = curwin->w_s->b_cap_prog;", "    regmatch.rm_ic = FALSE;", "    p = line + endcol;"], "readability/bool"]
["src/nvim/spell.c", ["  frompat = xmalloc(STRLEN(repl_from) + 7);", "  sprintf((char *)frompat, \"\\\\V\\\\<%s\\\\>\", repl_from);", "  p_ws = false;"], "runtime/printf"]
["src/nvim/spell.c", ["    if (addlen <= 0 || STRNCMP(line + curwin->w_cursor.col,", "            repl_to, STRLEN(repl_to)) != 0) {", "      p = xmalloc(STRLEN(line) + addlen + 1);"], "whitespace/alignment"]
["src/nvim/spell.c", ["      if (curwin->w_cursor.lnum != prev_lnum) {", "        ++sub_nlines;", "        prev_lnum = curwin->w_cursor.lnum;"], "readability/increment"]
["src/nvim/spell.c", ["      }", "      ++sub_nsubs;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["", "  if (sub_nsubs == 0)", "    EMSG2(_(\"E753: Not found: %s\"), repl_from);"], "readability/braces"]
["src/nvim/spell.c", ["    EMSG2(_(\"E753: Not found: %s\"), repl_from);", "  else", "    do_sub_msg(false);"], "readability/braces"]
["src/nvim/spell.c", ["void", "spell_suggest_list (", "    garray_T *gap,"], "whitespace/parens"]
["src/nvim/spell.c", ["  ga_grow(gap, sug.su_ga.ga_len);", "  for (int i = 0; i < sug.su_ga.ga_len; ++i) {", "    stp = &SUG(sug.su_ga, i);"], "readability/increment"]
["src/nvim/spell.c", ["static void", "spell_find_suggest (", "    char_u *badptr,"], "whitespace/parens"]
["src/nvim/spell.c", ["  ga_init(&su->su_sga, (int)sizeof(suggest_T), 10);", "  if (*badptr == NUL)", "    return;"], "readability/braces"]
["src/nvim/spell.c", ["  su->su_badptr = badptr;", "  if (badlen != 0)", "    su->su_badlen = badlen;"], "readability/braces"]
["src/nvim/spell.c", ["    su->su_badlen = badlen;", "  else {", "    size_t tmplen = spell_check(curwin, su->su_badptr, &attr, NULL, false);"], "readability/braces"]
["src/nvim/spell.c", ["    su->su_badlen = badlen;", "  else {", "    size_t tmplen = spell_check(curwin, su->su_badptr, &attr, NULL, false);"], "readability/braces"]
["src/nvim/spell.c", ["", "  if (su->su_badlen >= MAXWLEN)", "    su->su_badlen = MAXWLEN - 1;        // just in case"], "readability/braces"]
["src/nvim/spell.c", ["  su->su_badflags = badword_captype(su->su_badptr,", "      su->su_badptr + su->su_badlen);", "  if (need_cap)"], "whitespace/alignment"]
["src/nvim/spell.c", ["      su->su_badptr + su->su_badlen);", "  if (need_cap)", "    su->su_badflags |= WF_ONECAP;"], "readability/braces"]
["src/nvim/spell.c", ["  // languages (e.g., \"pl,en\").", "  for (int i = 0; i < curbuf->b_s.b_langp.ga_len; ++i) {", "    lp = LANGP_ENTRY(curbuf->b_s.b_langp, i);"], "readability/increment"]
["src/nvim/spell.c", ["  // have to do this many times.", "  if (su->su_sallang != NULL)", "    spell_soundfold(su->su_sallang, su->su_fbadword, true,"], "readability/braces"]
["src/nvim/spell.c", ["    spell_soundfold(su->su_sallang, su->su_fbadword, true,", "        su->su_sal_badword);", ""], "whitespace/alignment"]
["src/nvim/spell.c", ["    add_suggestion(su, &su->su_ga, buf, su->su_badlen, SCORE_ICASE,", "        0, true, su->su_sallang, false);", "  }"], "whitespace/alignment"]
["src/nvim/spell.c", ["  // Ban the bad word itself.  It may appear in another region.", "  if (banbadword)", "    add_banned(su, su->su_badword);"], "readability/braces"]
["src/nvim/spell.c", ["", "  if (do_combine)", "    // Combine the two list of suggestions.  This must be done last,"], "readability/braces"]
["src/nvim/spell.c", ["    p = vim_strchr(line, '/');", "    if (p == NULL)", "      continue;             // No Tab found, just skip the line."], "readability/braces"]
["src/nvim/spell.c", ["      // Match!  Isolate the good word, until CR or NL.", "      for (len = 0; p[len] >= ' '; ++len)", "        ;"], "readability/braces"]
["src/nvim/spell.c", ["      // Match!  Isolate the good word, until CR or NL.", "      for (len = 0; p[len] >= ' '; ++len)", "        ;"], "readability/increment"]
["src/nvim/spell.c", ["      for (len = 0; p[len] >= ' '; ++len)", "        ;", "      p[len] = NUL;"], "whitespace/semicolon"]
["src/nvim/spell.c", ["      add_suggestion(su, &su->su_ga, p, su->su_badlen,", "          SCORE_FILE, 0, true, su->su_sallang, false);", "    }"], "whitespace/alignment"]
["src/nvim/spell.c", ["  // For the resulting top-scorers compute the sound-a-like score.", "  if (sps_flags & SPS_DOUBLE)", "    score_comp_sal(su);"], "readability/braces"]
["src/nvim/spell.c", ["  if ((sps_flags & SPS_FAST) == 0) {", "    if (sps_flags & SPS_BEST)", "      // Adjust the word score for the suggestions found so far for how"], "readability/braces"]
["src/nvim/spell.c", ["    (void)vgetc();", "    got_int = FALSE;", "  }"], "readability/bool"]
["src/nvim/spell.c", ["  if ((sps_flags & SPS_DOUBLE) == 0 && su->su_ga.ga_len != 0) {", "    if (sps_flags & SPS_BEST)", "      // Adjust the word score for how it sounds like."], "readability/braces"]
["src/nvim/spell.c", ["      c = 'S';", "      if (d - wcopy >= MAXWLEN - 1)", "        break;"], "readability/braces"]
["src/nvim/spell.c", ["      *d++ = c;", "    } else", "      c = SPELL_TOUPPER(c);"], "readability/braces"]
["src/nvim/spell.c", ["    add_suggestion(su, &su->su_ga, word, su->su_badlen,", "        RESCORE(SCORE_REP, 0), 0, true, su->su_sallang, false);", "  }"], "whitespace/alignment"]
["src/nvim/spell.c", ["", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["    // everything has been cleared.", "    if (lp->lp_slang->sl_fbyts == NULL)", "      continue;"], "readability/braces"]
["src/nvim/spell.c", ["//      use \"slang->sl_repsal\" instead of \"lp->lp_replang->sl_rep\"", "static void suggest_trie_walk(suginfo_T *su, langp_T *lp, char_u *fword, bool soundfold)", "{"], "whitespace/line_length"]
["src/nvim/spell.c", ["        // Skip over the NUL bytes, we use them later.", "        for (n = 0; n < len && byts[arridx + n] == 0; ++n)", "          ;"], "readability/braces"]
["src/nvim/spell.c", ["        // Skip over the NUL bytes, we use them later.", "        for (n = 0; n < len && byts[arridx + n] == 0; ++n)", "          ;"], "readability/increment"]
["src/nvim/spell.c", ["        for (n = 0; n < len && byts[arridx + n] == 0; ++n)", "          ;", "        sp->ts_curi += n;"], "whitespace/semicolon"]
["src/nvim/spell.c", ["          su->su_badflags = badword_captype(su->su_badptr + n,", "              su->su_badptr + su->su_badlen);", "#ifdef DEBUG_TRIEWALK"], "whitespace/alignment"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "          sprintf(changename[depth], \"prefix\");", "#endif"], "runtime/printf"]
["src/nvim/spell.c", ["          go_deeper(stack, depth, 0);", "          ++depth;", "          sp = &stack[depth];"], "readability/increment"]
["src/nvim/spell.c", ["          make_case_word(tword + sp->ts_splitoff,", "              preword + sp->ts_prewordlen, flags);", "          sp->ts_prewordlen = (char_u)STRLEN(preword);"], "whitespace/alignment"]
["src/nvim/spell.c", ["      // End of word in tree.", "      ++sp->ts_curi;                    // eat one NUL byte", ""], "readability/increment"]
["src/nvim/spell.c", ["      // Skip words with the NOSUGGEST flag.", "      if (flags & WF_NOSUGGEST)", "        break;"], "readability/braces"]
["src/nvim/spell.c", ["        len = pbyts[n++];", "        for (c = 0; c < len && pbyts[n + c] == 0; ++c)", "          ;"], "readability/braces"]
["src/nvim/spell.c", ["        len = pbyts[n++];", "        for (c = 0; c < len && pbyts[n + c] == 0; ++c)", "          ;"], "readability/increment"]
["src/nvim/spell.c", ["        for (c = 0; c < len && pbyts[n + c] == 0; ++c)", "          ;", "        if (c > 0) {"], "whitespace/semicolon"]
["src/nvim/spell.c", ["          c = valid_word_prefix(c, n, flags,", "              tword + sp->ts_splitoff, slang, false);", "          if (c == 0)"], "whitespace/alignment"]
["src/nvim/spell.c", ["              tword + sp->ts_splitoff, slang, false);", "          if (c == 0)", "            break;"], "readability/braces"]
["src/nvim/spell.c", ["          // Use the WF_RARE flag for a rare prefix.", "          if (c & WF_RAREPFX)", "            flags |= WF_RARE;"], "readability/braces"]
["src/nvim/spell.c", ["      // appending another compound word below.", "      if (sp->ts_complen == sp->ts_compsplit && fword_ends", "          && (flags & WF_NEEDCOMP))"], "readability/braces"]
["src/nvim/spell.c", ["        goodword_ends = false;", "      else", "        goodword_ends = true;"], "readability/braces"]
["src/nvim/spell.c", ["              && STRNCMP(fword + sp->ts_splitfidx,", "                  tword + sp->ts_splitoff,", "                  sp->ts_fidx - sp->ts_splitfidx) == 0) {"], "whitespace/alignment"]
["src/nvim/spell.c", ["                  tword + sp->ts_splitoff,", "                  sp->ts_fidx - sp->ts_splitfidx) == 0) {", "            preword[sp->ts_prewordlen] = NUL;"], "whitespace/alignment"]
["src/nvim/spell.c", ["              && STRNCMP(fword + sp->ts_splitfidx,", "                  tword + sp->ts_splitoff,", "                  sp->ts_fidx - sp->ts_splitfidx) == 0) {"], "whitespace/alignment"]
["src/nvim/spell.c", ["                  tword + sp->ts_splitoff,", "                  sp->ts_fidx - sp->ts_splitfidx) == 0) {", "            preword[sp->ts_prewordlen] = NUL;"], "whitespace/alignment"]
["src/nvim/spell.c", ["            newscore = score_wordcount_adj(slang, sp->ts_score,", "                preword + sp->ts_prewordlen,", "                sp->ts_prewordlen > 0);"], "whitespace/alignment"]
["src/nvim/spell.c", ["                preword + sp->ts_prewordlen,", "                sp->ts_prewordlen > 0);", "            // Add the suggestion if the score isn't too bad."], "whitespace/alignment"]
["src/nvim/spell.c", ["            // Add the suggestion if the score isn't too bad.", "            if (newscore <= su->su_maxscore)", "              add_suggestion(su, &su->su_ga, preword,"], "readability/braces"]
["src/nvim/spell.c", ["              add_suggestion(su, &su->su_ga, preword,", "                  sp->ts_splitfidx - repextra,", "                  newscore, 0, false,"], "whitespace/alignment"]
["src/nvim/spell.c", ["                  sp->ts_splitfidx - repextra,", "                  newscore, 0, false,", "                  lp->lp_sallang, false);"], "whitespace/alignment"]
["src/nvim/spell.c", ["                  newscore, 0, false,", "                  lp->lp_sallang, false);", "            break;"], "whitespace/alignment"]
["src/nvim/spell.c", ["          STRLCPY(preword + sp->ts_prewordlen,", "              tword + sp->ts_splitoff,", "              sp->ts_twordlen - sp->ts_splitoff + 1);"], "whitespace/alignment"]
["src/nvim/spell.c", ["              tword + sp->ts_splitoff,", "              sp->ts_twordlen - sp->ts_splitoff + 1);", ""], "whitespace/alignment"]
["src/nvim/spell.c", ["          // Verify CHECKCOMPOUNDPATTERN  rules.", "          if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,", "                  &slang->sl_comppat))"], "readability/braces"]
["src/nvim/spell.c", ["          if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,", "                  &slang->sl_comppat))", "            compound_ok = false;"], "whitespace/alignment"]
["src/nvim/spell.c", ["            p = preword;", "            while (*skiptowhite(p) != NUL)", "              p = skipwhite(skiptowhite(p));"], "readability/braces"]
["src/nvim/spell.c", ["              p = skipwhite(skiptowhite(p));", "            if (fword_ends && !can_compound(slang, p,", "                    compflags + sp->ts_compsplit))"], "readability/braces"]
["src/nvim/spell.c", ["            if (fword_ends && !can_compound(slang, p,", "                    compflags + sp->ts_compsplit))", "              // Compound is not allowed.  But it may still be"], "whitespace/alignment"]
["src/nvim/spell.c", ["      // For the soundfold tree don't change the case, simply append.", "      if (soundfold)", "        STRCPY(preword + sp->ts_prewordlen, tword + sp->ts_splitoff);"], "readability/braces"]
["src/nvim/spell.c", ["        STRCPY(preword + sp->ts_prewordlen, tword + sp->ts_splitoff);", "      else if (flags & WF_KEEPCAP)", "        // Must find the word in the keep-case tree."], "readability/braces"]
["src/nvim/spell.c", ["        find_keepcap_word(slang, tword + sp->ts_splitoff,", "            preword + sp->ts_prewordlen);", "      else {"], "whitespace/alignment"]
["src/nvim/spell.c", ["            preword + sp->ts_prewordlen);", "      else {", "        // Include badflags: If the badword is onecap or allcap"], "readability/braces"]
["src/nvim/spell.c", ["            preword + sp->ts_prewordlen);", "      else {", "        // Include badflags: If the badword is onecap or allcap"], "readability/braces"]
["src/nvim/spell.c", ["        c = su->su_badflags;", "        if ((c & WF_ALLCAP)", "            && su->su_badlen == (*mb_ptr2len)(su->su_badptr)"], "readability/braces"]
["src/nvim/spell.c", ["        // use Onecap.", "        if (p != NULL && spell_iswordp_nmw(p, curwin))", "          c &= ~WF_ONECAP;"], "readability/braces"]
["src/nvim/spell.c", ["        make_case_word(tword + sp->ts_splitoff,", "            preword + sp->ts_prewordlen, c);", "      }"], "whitespace/alignment"]
["src/nvim/spell.c", ["            || WAS_BANNED(su, preword)) {", "          if (slang->sl_compprog == NULL)", "            break;"], "readability/braces"]
["src/nvim/spell.c", ["      if (!soundfold) {         // soundfold words don't have flags", "        if ((flags & WF_REGION)", "            && (((unsigned)flags >> 16) & lp->lp_region) == 0)"], "readability/braces"]
["src/nvim/spell.c", ["          newscore += SCORE_REGION;", "        if (flags & WF_RARE)", "          newscore += SCORE_RARE;"], "readability/braces"]
["src/nvim/spell.c", ["", "        if (!spell_valid_case(su->su_badflags,", "                captype(preword + sp->ts_prewordlen, NULL)))"], "readability/braces"]
["src/nvim/spell.c", ["        if (!spell_valid_case(su->su_badflags,", "                captype(preword + sp->ts_prewordlen, NULL)))", "          newscore += SCORE_ICASE;"], "whitespace/alignment"]
["src/nvim/spell.c", ["", "      // TODO: how about splitting in the soundfold tree?", "      if (fword_ends"], "readability/todo"]
["src/nvim/spell.c", ["          smsg(\"------ %s -------\", fword);", "          for (j = 0; j < depth; ++j)", "            smsg(\"%s\", changename[j]);"], "readability/braces"]
["src/nvim/spell.c", ["          smsg(\"------ %s -------\", fword);", "          for (j = 0; j < depth; ++j)", "            smsg(\"%s\", changename[j]);"], "readability/increment"]
["src/nvim/spell.c", ["          score = score_wordcount_adj(slang,", "              sp->ts_score + newscore,", "              preword + sp->ts_prewordlen,"], "whitespace/alignment"]
["src/nvim/spell.c", ["              sp->ts_score + newscore,", "              preword + sp->ts_prewordlen,", "              sp->ts_prewordlen > 0);"], "whitespace/alignment"]
["src/nvim/spell.c", ["              preword + sp->ts_prewordlen,", "              sp->ts_prewordlen > 0);", ""], "whitespace/alignment"]
["src/nvim/spell.c", ["            add_suggestion(su, &su->su_ga, preword,", "                sp->ts_fidx - repextra,", "                score, 0, false, lp->lp_sallang, false);"], "whitespace/alignment"]
["src/nvim/spell.c", ["                sp->ts_fidx - repextra,", "                score, 0, false, lp->lp_sallang, false);", ""], "whitespace/alignment"]
["src/nvim/spell.c", ["                make_case_word(tword + sp->ts_splitoff,", "                    preword + sp->ts_prewordlen,", "                    c == 0 ? WF_ALLCAP : 0);"], "whitespace/alignment"]
["src/nvim/spell.c", ["                    preword + sp->ts_prewordlen,", "                    c == 0 ? WF_ALLCAP : 0);", ""], "whitespace/alignment"]
["src/nvim/spell.c", ["                add_suggestion(su, &su->su_ga, preword,", "                    sp->ts_fidx - repextra,", "                    score + SCORE_ICASE, 0, false,"], "whitespace/alignment"]
["src/nvim/spell.c", ["                    sp->ts_fidx - repextra,", "                    score + SCORE_ICASE, 0, false,", "                    lp->lp_sallang, false);"], "whitespace/alignment"]
["src/nvim/spell.c", ["                    score + SCORE_ICASE, 0, false,", "                    lp->lp_sallang, false);", "              }"], "whitespace/alignment"]
["src/nvim/spell.c", ["        // different.  It's done like a split.", "        // TODO: word split for soundfold words", "        try_split = (sp->ts_fidx - repextra < su->su_badlen)"], "readability/todo"]
["src/nvim/spell.c", ["            && (can_be_compound(sp, slang,", "                    compflags, ((unsigned)flags >> 24)))) {", "          try_compound = true;"], "whitespace/alignment"]
["src/nvim/spell.c", ["            && (can_be_compound(sp, slang,", "                    compflags, ((unsigned)flags >> 24)))) {", "          try_compound = true;"], "whitespace/alignment"]
["src/nvim/spell.c", ["          sp->ts_flags |= TSF_DIDSPLIT;", "          --sp->ts_curi;                    // do the same NUL again", "          compflags[sp->ts_complen] = NUL;"], "readability/increment"]
["src/nvim/spell.c", ["            // flag.", "            if (sp->ts_complen == sp->ts_compsplit", "                && (flags & WF_NEEDCOMP))"], "readability/braces"]
["src/nvim/spell.c", ["            p = preword;", "            while (*skiptowhite(p) != NUL)", "              p = skipwhite(skiptowhite(p));"], "readability/braces"]
["src/nvim/spell.c", ["              p = skipwhite(skiptowhite(p));", "            if (sp->ts_complen > sp->ts_compsplit", "                && !can_compound(slang, p,"], "readability/braces"]
["src/nvim/spell.c", ["                && !can_compound(slang, p,", "                    compflags + sp->ts_compsplit))", "              break;"], "whitespace/alignment"]
["src/nvim/spell.c", ["                && !can_compound(slang, p,", "                    compflags + sp->ts_compsplit))", "              break;"], "whitespace/alignment"]
["src/nvim/spell.c", ["", "            if (slang->sl_nosplitsugs)", "              newscore += SCORE_SPLIT_NO;"], "readability/braces"]
["src/nvim/spell.c", ["              newscore += SCORE_SPLIT_NO;", "            else", "              newscore += SCORE_SPLIT;"], "readability/braces"]
["src/nvim/spell.c", ["            newscore = score_wordcount_adj(slang, newscore,", "                preword + sp->ts_prewordlen, true);", "          }"], "whitespace/alignment"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "            if (!try_compound && !fword_ends)", "              sprintf(changename[depth], \"%.*s-%s: split\","], "readability/braces"]
["src/nvim/spell.c", ["              sprintf(changename[depth], \"%.*s-%s: split\",", "                  sp->ts_twordlen, tword, fword + sp->ts_fidx);", "            else"], "whitespace/alignment"]
["src/nvim/spell.c", ["            if (!try_compound && !fword_ends)", "              sprintf(changename[depth], \"%.*s-%s: split\",", "                  sp->ts_twordlen, tword, fword + sp->ts_fidx);"], "runtime/printf"]
["src/nvim/spell.c", ["                  sp->ts_twordlen, tword, fword + sp->ts_fidx);", "            else", "              sprintf(changename[depth], \"%.*s-%s: compound\","], "readability/braces"]
["src/nvim/spell.c", ["              sprintf(changename[depth], \"%.*s-%s: compound\",", "                  sp->ts_twordlen, tword, fword + sp->ts_fidx);", "#endif"], "whitespace/alignment"]
["src/nvim/spell.c", ["            else", "              sprintf(changename[depth], \"%.*s-%s: compound\",", "                  sp->ts_twordlen, tword, fword + sp->ts_fidx);"], "runtime/printf"]
["src/nvim/spell.c", ["", "            ++depth;", "            sp = &stack[depth];"], "readability/increment"]
["src/nvim/spell.c", ["            // Append a space to preword when splitting.", "            if (!try_compound && !fword_ends)", "              STRCAT(preword, \" \");"], "readability/braces"]
["src/nvim/spell.c", ["            if (((!try_compound && !spell_iswordp_nmw(fword", "                      + sp->ts_fidx,", "                      curwin))"], "whitespace/alignment"]
["src/nvim/spell.c", ["                      + sp->ts_fidx,", "                      curwin))", "                 || fword_ends)"], "whitespace/alignment"]
["src/nvim/spell.c", ["                memmove(preword + sp->ts_prewordlen,", "                    fword + sp->ts_fidx, l);", "                sp->ts_prewordlen += l;"], "whitespace/alignment"]
["src/nvim/spell.c", ["                preword[sp->ts_prewordlen] = NUL;", "              } else", "                sp->ts_score -= SCORE_SPLIT - SCORE_SUBST;"], "readability/braces"]
["src/nvim/spell.c", ["            // may start compounding over again.", "            if (try_compound)", "              ++sp->ts_complen;"], "readability/braces"]
["src/nvim/spell.c", ["            if (try_compound)", "              ++sp->ts_complen;", "            else"], "readability/increment"]
["src/nvim/spell.c", ["              ++sp->ts_complen;", "            else", "              sp->ts_compsplit = sp->ts_complen;"], "readability/braces"]
["src/nvim/spell.c", ["            su->su_badflags = badword_captype(su->su_badptr + n,", "                su->su_badptr + su->su_badlen);", ""], "whitespace/alignment"]
["src/nvim/spell.c", ["        // delete + substitute.", "        if (c == fword[sp->ts_fidx]", "            || (sp->ts_tcharlen > 0 && sp->ts_isdiff != DIFF_NONE)"], "readability/braces"]
["src/nvim/spell.c", ["          newscore = 0;", "        else", "          newscore = SCORE_SUBST;"], "readability/braces"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "          if (newscore > 0)", "            sprintf(changename[depth], \"%.*s-%s: subst %c to %c\","], "readability/braces"]
["src/nvim/spell.c", ["            sprintf(changename[depth], \"%.*s-%s: subst %c to %c\",", "                sp->ts_twordlen, tword, fword + sp->ts_fidx,", "                fword[sp->ts_fidx], c);"], "whitespace/alignment"]
["src/nvim/spell.c", ["                sp->ts_twordlen, tword, fword + sp->ts_fidx,", "                fword[sp->ts_fidx], c);", "          else"], "whitespace/alignment"]
["src/nvim/spell.c", ["          if (newscore > 0)", "            sprintf(changename[depth], \"%.*s-%s: subst %c to %c\",", "                sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["                fword[sp->ts_fidx], c);", "          else", "            sprintf(changename[depth], \"%.*s-%s: accept %c\","], "readability/braces"]
["src/nvim/spell.c", ["            sprintf(changename[depth], \"%.*s-%s: accept %c\",", "                sp->ts_twordlen, tword, fword + sp->ts_fidx,", "                fword[sp->ts_fidx]);"], "whitespace/alignment"]
["src/nvim/spell.c", ["                sp->ts_twordlen, tword, fword + sp->ts_fidx,", "                fword[sp->ts_fidx]);", "#endif"], "whitespace/alignment"]
["src/nvim/spell.c", ["          else", "            sprintf(changename[depth], \"%.*s-%s: accept %c\",", "                sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["#endif", "          ++depth;", "          sp = &stack[depth];"], "readability/increment"]
["src/nvim/spell.c", ["          sp = &stack[depth];", "          ++sp->ts_fidx;", "          tword[sp->ts_twordlen++] = c;"], "readability/increment"]
["src/nvim/spell.c", ["      sp->ts_curi = 1;", "      if (soundfold && sp->ts_fidx == 0 && fword[sp->ts_fidx] == '*')", "        // Deleting a vowel at the start of a word counts less, see"], "readability/braces"]
["src/nvim/spell.c", ["        newscore = 2 * SCORE_DEL / 3;", "      else", "        newscore = SCORE_DEL;"], "readability/braces"]
["src/nvim/spell.c", ["        sprintf(changename[depth], \"%.*s-%s: delete %c\",", "            sp->ts_twordlen, tword, fword + sp->ts_fidx,", "            fword[sp->ts_fidx]);"], "whitespace/alignment"]
["src/nvim/spell.c", ["            sp->ts_twordlen, tword, fword + sp->ts_fidx,", "            fword[sp->ts_fidx]);", "#endif"], "whitespace/alignment"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "        sprintf(changename[depth], \"%.*s-%s: delete %c\",", "            sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["#endif", "        ++depth;", ""], "readability/increment"]
["src/nvim/spell.c", ["        }", "        ++sp->ts_curi;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["      c = byts[n];", "      if (soundfold && sp->ts_twordlen == 0 && c == '*')", "        // Inserting a vowel at the start of a word counts less,"], "readability/braces"]
["src/nvim/spell.c", ["        newscore = 2 * SCORE_INS / 3;", "      else", "        newscore = SCORE_INS;"], "readability/braces"]
["src/nvim/spell.c", ["        sprintf(changename[depth], \"%.*s-%s: insert %c\",", "            sp->ts_twordlen, tword, fword + sp->ts_fidx,", "            c);"], "whitespace/alignment"]
["src/nvim/spell.c", ["            sp->ts_twordlen, tword, fword + sp->ts_fidx,", "            c);", "#endif"], "whitespace/alignment"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "        sprintf(changename[depth], \"%.*s-%s: insert %c\",", "            sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["#endif", "        ++depth;", "        sp = &stack[depth];"], "readability/increment"]
["src/nvim/spell.c", ["          // score).", "          if (sp->ts_twordlen >= 2", "              && tword[sp->ts_twordlen - 2] == c)"], "readability/braces"]
["src/nvim/spell.c", ["        sprintf(changename[depth], \"%.*s-%s: swap3 %c and %c\",", "            sp->ts_twordlen, tword, fword + sp->ts_fidx,", "            c, c3);"], "whitespace/alignment"]
["src/nvim/spell.c", ["            sp->ts_twordlen, tword, fword + sp->ts_fidx,", "            c, c3);", "#endif"], "whitespace/alignment"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "        sprintf(changename[depth], \"%.*s-%s: swap3 %c and %c\",", "            sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["        sprintf(changename[depth], \"%.*s-%s: rotate left %c%c%c\",", "            sp->ts_twordlen, tword, fword + sp->ts_fidx,", "            p[0], p[1], p[2]);"], "whitespace/alignment"]
["src/nvim/spell.c", ["            sp->ts_twordlen, tword, fword + sp->ts_fidx,", "            p[0], p[1], p[2]);", "#endif"], "whitespace/alignment"]
["src/nvim/spell.c", ["        p = fword + sp->ts_fidx;", "        sprintf(changename[depth], \"%.*s-%s: rotate left %c%c%c\",", "            sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["        sp->ts_state = STATE_UNROT3L;", "        ++depth;", "        p = fword + sp->ts_fidx;"], "readability/increment"]
["src/nvim/spell.c", ["        sprintf(changename[depth], \"%.*s-%s: rotate right %c%c%c\",", "            sp->ts_twordlen, tword, fword + sp->ts_fidx,", "            p[0], p[1], p[2]);"], "whitespace/alignment"]
["src/nvim/spell.c", ["            sp->ts_twordlen, tword, fword + sp->ts_fidx,", "            p[0], p[1], p[2]);", "#endif"], "whitespace/alignment"]
["src/nvim/spell.c", ["        p = fword + sp->ts_fidx;", "        sprintf(changename[depth], \"%.*s-%s: rotate right %c%c%c\",", "            sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["        sp->ts_state = STATE_UNROT3R;", "        ++depth;", "        p = fword + sp->ts_fidx;"], "readability/increment"]
["src/nvim/spell.c", ["      // match.  If the index is -1 there is none.", "      if (soundfold)", "        sp->ts_curi = slang->sl_repsal_first[fword[sp->ts_fidx]];"], "readability/braces"]
["src/nvim/spell.c", ["        sp->ts_curi = slang->sl_repsal_first[fword[sp->ts_fidx]];", "      else", "        sp->ts_curi = lp->lp_replang->sl_rep_first[fword[sp->ts_fidx]];"], "readability/braces"]
["src/nvim/spell.c", ["", "      if (soundfold)", "        gap = &slang->sl_repsal;"], "readability/braces"]
["src/nvim/spell.c", ["        gap = &slang->sl_repsal;", "      else", "        gap = &lp->lp_replang->sl_rep;"], "readability/braces"]
["src/nvim/spell.c", ["          sprintf(changename[depth], \"%.*s-%s: replace %s with %s\",", "              sp->ts_twordlen, tword, fword + sp->ts_fidx,", "              ftp->ft_from, ftp->ft_to);"], "whitespace/alignment"]
["src/nvim/spell.c", ["              sp->ts_twordlen, tword, fword + sp->ts_fidx,", "              ftp->ft_from, ftp->ft_to);", "#endif"], "whitespace/alignment"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "          sprintf(changename[depth], \"%.*s-%s: replace %s with %s\",", "              sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["          // Change the \"from\" to the \"to\" string.", "          ++depth;", "          fl = (int)STRLEN(ftp->ft_from);"], "readability/increment"]
["src/nvim/spell.c", ["", "      if (sp->ts_curi >= gap->ga_len && sp->ts_state == STATE_REP)", "        // No (more) matches."], "readability/braces"]
["src/nvim/spell.c", ["      // Undo a REP replacement and continue with the next one.", "      if (soundfold)", "        gap = &slang->sl_repsal;"], "readability/braces"]
["src/nvim/spell.c", ["        gap = &slang->sl_repsal;", "      else", "        gap = &lp->lp_replang->sl_rep;"], "readability/braces"]
["src/nvim/spell.c", ["      // Did all possible states at this level, go up one level.", "      --depth;", ""], "readability/increment"]
["src/nvim/spell.c", ["  }", "}", ""], "readability/fn_size"]
["src/nvim/spell.c", ["      // kword is getting too long, continue one level up", "      --depth;", "    } else if (++round[depth] > 2)   {"], "readability/increment"]
["src/nvim/spell.c", ["      // level up", "      --depth;", "    } else {"], "readability/increment"]
["src/nvim/spell.c", ["", "      for (tryidx = arridx[depth]; l > 0; --l) {", "        // Perform a binary search in the list of accepted bytes."], "readability/increment"]
["src/nvim/spell.c", ["          m = (lo + hi) / 2;", "          if (byts[m] > c)", "            hi = m - 1;"], "readability/braces"]
["src/nvim/spell.c", ["            hi = m - 1;", "          else if (byts[m] < c)", "            lo = m + 1;"], "readability/braces"]
["src/nvim/spell.c", ["            lo = m + 1;", "          else {", "            lo = hi = m;"], "readability/braces"]
["src/nvim/spell.c", ["            lo = m + 1;", "          else {", "            lo = hi = m;"], "readability/braces"]
["src/nvim/spell.c", ["        // Stop if there is no matching byte.", "        if (hi < lo || byts[lo] != c)", "          break;"], "readability/braces"]
["src/nvim/spell.c", ["          STRNCPY(kword + kwordlen[depth], fword + fwordidx[depth],", "              flen);", "          kwordlen[depth + 1] = kwordlen[depth] + flen;"], "whitespace/alignment"]
["src/nvim/spell.c", ["        if (round[depth] == 1) {", "          STRNCPY(kword + kwordlen[depth], fword + fwordidx[depth],", "              flen);"], "runtime/printf"]
["src/nvim/spell.c", ["          STRNCPY(kword + kwordlen[depth], uword + uwordidx[depth],", "              ulen);", "          kwordlen[depth + 1] = kwordlen[depth] + ulen;"], "whitespace/alignment"]
["src/nvim/spell.c", ["        } else {", "          STRNCPY(kword + kwordlen[depth], uword + uwordidx[depth],", "              ulen);"], "runtime/printf"]
["src/nvim/spell.c", ["", "        ++depth;", "        arridx[depth] = tryidx;"], "readability/increment"]
["src/nvim/spell.c", ["  // Use the sound-folding of the first language that supports it.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["", "      for (i = 0; i < su->su_ga.ga_len; ++i) {", "        stp = &SUG(su->su_ga, i);"], "readability/increment"]
["src/nvim/spell.c", ["          sstp->st_orglen = stp->st_orglen;", "          ++su->su_sga.ga_len;", "        }"], "readability/increment"]
["src/nvim/spell.c", ["  // Add the alternate score to su_ga.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["", "      for (int i = 0; i < su->su_ga.ga_len; ++i) {", "        stp = &SUG(su->su_ga, i);"], "readability/increment"]
["src/nvim/spell.c", ["        stp->st_altscore = stp_sal_score(stp, su, slang, badsound);", "        if (stp->st_altscore == SCORE_MAXMAX)", "          stp->st_score = (stp->st_score * 3 + SCORE_BIG) / 4;"], "readability/braces"]
["src/nvim/spell.c", ["          stp->st_score = (stp->st_score * 3 + SCORE_BIG) / 4;", "        else", "          stp->st_score = (stp->st_score * 3"], "readability/braces"]
["src/nvim/spell.c", ["    (void)cleanup_suggestions(&su->su_ga, su->su_maxscore,", "        su->su_maxcount);", "    return;"], "whitespace/alignment"]
["src/nvim/spell.c", ["  // Add the alternate score to su_sga.", "  for (int i = 0; i < su->su_sga.ga_len; ++i) {", "    stp = &SUG(su->su_sga, i);"], "readability/increment"]
["src/nvim/spell.c", ["    stp->st_altscore = spell_edit_score(slang,", "        su->su_badword, stp->st_word);", "    if (stp->st_score == SCORE_MAXMAX)"], "whitespace/alignment"]
["src/nvim/spell.c", ["        su->su_badword, stp->st_word);", "    if (stp->st_score == SCORE_MAXMAX)", "      stp->st_score = (SCORE_BIG * 7 + stp->st_altscore) / 8;"], "readability/braces"]
["src/nvim/spell.c", ["      stp->st_score = (SCORE_BIG * 7 + stp->st_altscore) / 8;", "    else", "      stp->st_score = (stp->st_score * 7 + stp->st_altscore) / 8;"], "readability/braces"]
["src/nvim/spell.c", ["  stp = &SUG(ga, 0);", "  for (int i = 0; i < su->su_ga.ga_len || i < su->su_sga.ga_len; ++i) {", "    // round 1: get a suggestion from su_ga"], "readability/increment"]
["src/nvim/spell.c", ["    // round 2: get a suggestion from su_sga", "    for (round = 1; round <= 2; ++round) {", "      gap = round == 1 ? &su->su_ga : &su->su_sga;"], "readability/increment"]
["src/nvim/spell.c", ["        int j;", "        for (j = 0; j < ga.ga_len; ++j)", "          if (STRCMP(stp[j].st_word, p) == 0)"], "readability/braces"]
["src/nvim/spell.c", ["        int j;", "        for (j = 0; j < ga.ga_len; ++j)", "          if (STRCMP(stp[j].st_word, p) == 0)"], "readability/increment"]
["src/nvim/spell.c", ["        for (j = 0; j < ga.ga_len; ++j)", "          if (STRCMP(stp[j].st_word, p) == 0)", "            break;"], "readability/braces"]
["src/nvim/spell.c", ["            break;", "        if (j == ga.ga_len)", "          stp[ga.ga_len++] = SUG(*gap, i);"], "readability/braces"]
["src/nvim/spell.c", ["          stp[ga.ga_len++] = SUG(*gap, i);", "        else", "          xfree(p);"], "readability/braces"]
["src/nvim/spell.c", ["  if (ga.ga_len > su->su_maxcount) {", "    for (int i = su->su_maxcount; i < ga.ga_len; ++i) {", "      xfree(stp[i].st_word);"], "readability/increment"]
["src/nvim/spell.c", ["static int", "stp_sal_score (", "    suggest_T *stp,"], "whitespace/parens"]
["src/nvim/spell.c", ["  lendiff = su->su_badlen - stp->st_orglen;", "  if (lendiff >= 0)", "    pbad = badsound;"], "readability/braces"]
["src/nvim/spell.c", ["    pbad = badsound;", "  else {", "    // soundfold the bad word with more characters following"], "readability/braces"]
["src/nvim/spell.c", ["    pbad = badsound;", "  else {", "    // soundfold the bad word with more characters following"], "readability/braces"]
["src/nvim/spell.c", ["    // space.", "    if (ascii_iswhite(su->su_badptr[su->su_badlen])", "        && *skiptowhite(stp->st_word) == NUL)"], "readability/braces"]
["src/nvim/spell.c", ["        && *skiptowhite(stp->st_word) == NUL)", "      for (p = fword; *(p = skiptowhite(p)) != NUL; )", "        STRMOVE(p, p + 1);"], "readability/braces"]
["src/nvim/spell.c", ["    STRLCPY(goodword + stp->st_wordlen,", "        su->su_badptr + su->su_badlen - lendiff, lendiff + 1);", "    pgood = goodword;"], "whitespace/alignment"]
["src/nvim/spell.c", ["    pgood = goodword;", "  } else", "    pgood = stp->st_word;"], "readability/braces"]
["src/nvim/spell.c", ["  // .sug file has been loaded.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["    slang = lp->lp_slang;", "    if (!GA_EMPTY(&slang->sl_sal) && slang->sl_sbyts != NULL)", "      // prepare the hashtable used by add_sound_suggest()"], "readability/braces"]
["src/nvim/spell.c", ["  // .sug file has been loaded.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["      // try all kinds of inserts/deletes/swaps/etc.", "      // TODO: also soundfold the next words, so that we can try joining", "      // and splitting"], "readability/todo"]
["src/nvim/spell.c", ["  // .sug file has been loaded.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["      todo = (int)slang->sl_sounddone.ht_used;", "      for (hi = slang->sl_sounddone.ht_array; todo > 0; ++hi)", "        if (!HASHITEM_EMPTY(hi)) {"], "readability/braces"]
["src/nvim/spell.c", ["      todo = (int)slang->sl_sounddone.ht_used;", "      for (hi = slang->sl_sounddone.ht_array; todo > 0; ++hi)", "        if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/spell.c", ["          xfree(HI2SFT(hi));", "          --todo;", "        }"], "readability/increment"]
["src/nvim/spell.c", ["static void", "add_sound_suggest (", "    suginfo_T *su,"], "whitespace/parens"]
["src/nvim/spell.c", ["    sft = HI2SFT(hi);", "    if (score >= sft->sft_score)", "      return;"], "readability/braces"]
["src/nvim/spell.c", ["    wordcount = 0;", "    for (wlen = 0; wlen < MAXWLEN - 3; ++wlen) {", "      i = 1;"], "readability/increment"]
["src/nvim/spell.c", ["      i = 1;", "      if (wordcount == orgnr && byts[n + 1] == NUL)", "        break;          // found end of word"], "readability/braces"]
["src/nvim/spell.c", ["", "      if (byts[n + 1] == NUL)", "        ++wordcount;"], "readability/braces"]
["src/nvim/spell.c", ["      if (byts[n + 1] == NUL)", "        ++wordcount;", ""], "readability/increment"]
["src/nvim/spell.c", ["      // skip over the NUL bytes", "      for (; byts[n + i] == NUL; ++i)", "        if (i > byts[n]) {              // safety check"], "readability/braces"]
["src/nvim/spell.c", ["      // skip over the NUL bytes", "      for (; byts[n + i] == NUL; ++i)", "        if (i > byts[n]) {              // safety check"], "readability/increment"]
["src/nvim/spell.c", ["      // One of the siblings must have the word.", "      for (; i < byts[n]; ++i) {", "        wc = idxs[idxs[n + i]];         // nr of words under this byte"], "readability/increment"]
["src/nvim/spell.c", ["        wc = idxs[idxs[n + i]];         // nr of words under this byte", "        if (wordcount + wc > orgnr)", "          break;"], "readability/braces"]
["src/nvim/spell.c", ["    // Go over the possible flags and regions.", "    for (; i <= byts[n] && byts[n + i] == NUL; ++i) {", "      char_u cword[MAXWLEN];"], "readability/increment"]
["src/nvim/spell.c", ["      // Skip words with the NOSUGGEST flag", "      if (flags & WF_NOSUGGEST)", "        continue;"], "readability/braces"]
["src/nvim/spell.c", ["          p = cword;", "        } else", "          p = theword;"], "readability/braces"]
["src/nvim/spell.c", ["        // Add the suggestion if the score isn't too bad.", "        if (score <= su->su_maxscore)", "          add_suggestion(su, &su->su_sga, p, su->su_badlen,"], "readability/braces"]
["src/nvim/spell.c", ["          add_suggestion(su, &su->su_sga, p, su->su_badlen,", "              score, 0, false, slang, false);", "      } else {"], "whitespace/alignment"]
["src/nvim/spell.c", ["        // Add a penalty for words in another region.", "        if ((flags & WF_REGION)", "            && (((unsigned)flags >> 16) & lp->lp_region) == 0)"], "readability/braces"]
["src/nvim/spell.c", ["          goodscore = SCORE_REGION;", "        else", "          goodscore = 0;"], "readability/braces"]
["src/nvim/spell.c", ["          bc = PTR2CHAR(su->su_badword);", "          if (!SPELL_ISUPPER(bc)", "              && SPELL_TOFOLD(bc) != SPELL_TOFOLD(gc))"], "readability/braces"]
["src/nvim/spell.c", ["        limit = MAXSCORE(su->su_sfmaxscore - goodscore, score);", "        if (limit > SCORE_LIMITMAX)", "          goodscore += spell_edit_score(slang, su->su_badword, p);"], "readability/braces"]
["src/nvim/spell.c", ["          goodscore += spell_edit_score(slang, su->su_badword, p);", "        else", "          goodscore += spell_edit_score_limit(slang, su->su_badword,"], "readability/braces"]
["src/nvim/spell.c", ["          goodscore += spell_edit_score_limit(slang, su->su_badword,", "              p, limit);", ""], "whitespace/alignment"]
["src/nvim/spell.c", ["          goodscore = RESCORE(goodscore, score);", "          if (goodscore <= su->su_sfmaxscore)", "            add_suggestion(su, &su->su_ga, p, su->su_badlen,"], "readability/braces"]
["src/nvim/spell.c", ["            add_suggestion(su, &su->su_ga, p, su->su_badlen,", "                goodscore, score, true, slang, true);", "        }"], "whitespace/alignment"]
["src/nvim/spell.c", ["    if (byts[arridx] == NUL) {", "      if (c == NUL)", "        break;"], "readability/braces"]
["src/nvim/spell.c", ["      while (len > 0 && byts[arridx] == NUL) {", "        ++arridx;", "        --len;"], "readability/increment"]
["src/nvim/spell.c", ["        ++arridx;", "        --len;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["      }", "      if (len == 0)", "        return -1;            // no children, word should have ended here"], "readability/braces"]
["src/nvim/spell.c", ["        return -1;            // no children, word should have ended here", "      ++wordnr;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["    // If the word ends we didn't find it.", "    if (c == NUL)", "      return -1;"], "readability/braces"]
["src/nvim/spell.c", ["    // Perform a binary search in the list of accepted bytes.", "    if (c == TAB)           // <Tab> is handled like <Space>", "      c = ' ';"], "readability/braces"]
["src/nvim/spell.c", ["      wordnr += idxs[idxs[arridx]];", "      ++arridx;", "      if (--len == 0)           // end of the bytes, didn't find it"], "readability/increment"]
["src/nvim/spell.c", ["      ++arridx;", "      if (--len == 0)           // end of the bytes, didn't find it", "        return -1;"], "readability/braces"]
["src/nvim/spell.c", ["    }", "    if (byts[arridx] != c)      // didn't find the byte", "      return -1;"], "readability/braces"]
["src/nvim/spell.c", ["    arridx = idxs[arridx];", "    ++wlen;", ""], "readability/increment"]
["src/nvim/spell.c", ["    // checked word.", "    if (c == ' ')", "      while (ptr[wlen] == ' ' || ptr[wlen] == TAB)"], "readability/braces"]
["src/nvim/spell.c", ["    if (c == ' ')", "      while (ptr[wlen] == ' ' || ptr[wlen] == TAB)", "        ++wlen;"], "readability/braces"]
["src/nvim/spell.c", ["      while (ptr[wlen] == ' ' || ptr[wlen] == TAB)", "        ++wlen;", "  }"], "readability/increment"]
["src/nvim/spell.c", ["{", "  if (flags & WF_ALLCAP)", "    // Make it all upper-case"], "readability/braces"]
["src/nvim/spell.c", ["    allcap_copy(fword, cword);", "  else if (flags & WF_ONECAP)", "    // Make the first letter upper-case"], "readability/braces"]
["src/nvim/spell.c", ["    onecap_copy(fword, cword, true);", "  else", "    // Use goodword as-is."], "readability/braces"]
["src/nvim/spell.c", ["static void", "add_suggestion (", "    suginfo_T *su,"], "whitespace/parens"]
["src/nvim/spell.c", ["    badlen = (int)(pbad - su->su_badptr);", "    if (goodlen <= 0 || badlen <= 0)", "      break;"], "readability/braces"]
["src/nvim/spell.c", ["", "  if (badlen == 0 && goodlen == 0)", "    // goodword doesn't change anything; may happen for \"the the\" changing"], "readability/braces"]
["src/nvim/spell.c", ["        // Found it.  Remember the word with the lowest score.", "        if (stp->st_slang == NULL)", "          stp->st_slang = slang;"], "readability/braces"]
["src/nvim/spell.c", ["          // the soundalike score to zero.", "          if (had_bonus)", "            rescore_one(su, stp);"], "readability/braces"]
["src/nvim/spell.c", ["            rescore_one(su, stp);", "          else {", "            new_sug.st_word = stp->st_word;"], "readability/braces"]
["src/nvim/spell.c", ["            rescore_one(su, stp);", "          else {", "            new_sug.st_word = stp->st_word;"], "readability/braces"]
["src/nvim/spell.c", ["    if (gap->ga_len > SUG_MAX_COUNT(su)) {", "      if (maxsf)", "        su->su_sfmaxscore = cleanup_suggestions(gap,"], "readability/braces"]
["src/nvim/spell.c", ["        su->su_sfmaxscore = cleanup_suggestions(gap,", "            su->su_sfmaxscore, SUG_CLEAN_COUNT(su));", "      else"], "whitespace/alignment"]
["src/nvim/spell.c", ["            su->su_sfmaxscore, SUG_CLEAN_COUNT(su));", "      else", "        su->su_maxscore = cleanup_suggestions(gap,"], "readability/braces"]
["src/nvim/spell.c", ["        su->su_maxscore = cleanup_suggestions(gap,", "            su->su_maxscore, SUG_CLEAN_COUNT(su));", "    }"], "whitespace/alignment"]
["src/nvim/spell.c", ["static void", "check_suggestions (", "    suginfo_T *su,"], "whitespace/parens"]
["src/nvim/spell.c", ["  stp = &SUG(*gap, 0);", "  for (int i = gap->ga_len - 1; i >= 0; --i) {", "    // Need to append what follows to check for \"the the\"."], "readability/increment"]
["src/nvim/spell.c", ["    STRLCPY(longword + len, su->su_badptr + stp[i].st_orglen,", "        MAXWLEN - len + 1);", "    attr = HLF_COUNT;"], "whitespace/alignment"]
["src/nvim/spell.c", ["      xfree(stp[i].st_word);", "      --gap->ga_len;", "      if (i < gap->ga_len)"], "readability/increment"]
["src/nvim/spell.c", ["      --gap->ga_len;", "      if (i < gap->ga_len)", "        memmove(stp + i, stp + i + 1,"], "readability/braces"]
["src/nvim/spell.c", ["        memmove(stp + i, stp + i + 1,", "            sizeof(suggest_T) * (gap->ga_len - i));", "    }"], "whitespace/alignment"]
["src/nvim/spell.c", ["  if (su->su_sallang != NULL) {", "    for (int i = 0; i < su->su_ga.ga_len; ++i) {", "      rescore_one(su, &SUG(su->su_ga, i));"], "readability/increment"]
["src/nvim/spell.c", ["  if (slang != NULL && !GA_EMPTY(&slang->sl_sal) && !stp->st_had_bonus) {", "    if (slang == su->su_sallang)", "      p = su->su_sal_badword;"], "readability/braces"]
["src/nvim/spell.c", ["      p = su->su_sal_badword;", "    else {", "      spell_soundfold(slang, su->su_fbadword, true, sal_badword);"], "readability/braces"]
["src/nvim/spell.c", ["      p = su->su_sal_badword;", "    else {", "      spell_soundfold(slang, su->su_fbadword, true, sal_badword);"], "readability/braces"]
["src/nvim/spell.c", ["    stp->st_altscore = stp_sal_score(stp, su, slang, p);", "    if (stp->st_altscore == SCORE_MAXMAX)", "      stp->st_altscore = SCORE_BIG;"], "readability/braces"]
["src/nvim/spell.c", ["    n = p1->st_altscore - p2->st_altscore;", "    if (n == 0)", "      n = STRICMP(p1->st_word, p2->st_word);"], "readability/braces"]
["src/nvim/spell.c", ["static int", "cleanup_suggestions (", "    garray_T *gap,"], "whitespace/parens"]
["src/nvim/spell.c", ["", "  if (slang->sl_sofo)", "    // SOFOFROM and SOFOTO used"], "readability/braces"]
["src/nvim/spell.c", ["    spell_soundfold_sofo(slang, inword, res);", "  else {", "    // SAL items used.  Requires the word to be case-folded."], "readability/braces"]
["src/nvim/spell.c", ["    spell_soundfold_sofo(slang, inword, res);", "  else {", "    // SAL items used.  Requires the word to be case-folded."], "readability/braces"]
["src/nvim/spell.c", ["    // SAL items used.  Requires the word to be case-folded.", "    if (folded)", "      word = inword;"], "readability/braces"]
["src/nvim/spell.c", ["      word = inword;", "    else {", "      (void)spell_casefold(inword, (int)STRLEN(inword), fword, MAXWLEN);"], "readability/braces"]
["src/nvim/spell.c", ["      word = inword;", "    else {", "      (void)spell_casefold(inword, (int)STRLEN(inword), fword, MAXWLEN);"], "readability/braces"]
["src/nvim/spell.c", ["      for (; ((ws = smp[n].sm_lead_w)[0] & 0xff) == (c & 0xff)", "           && ws[0] != NUL; ++n) {", "        // Quickly skip entries that don't match the word.  Most"], "readability/increment"]
["src/nvim/spell.c", ["        // entries are less then three chars, optimize for that.", "        if (c != ws[0])", "          continue;"], "readability/braces"]
["src/nvim/spell.c", ["        if (k > 1) {", "          if (word[i + 1] != ws[1])", "            continue;"], "readability/braces"]
["src/nvim/spell.c", ["          if (k > 2) {", "            for (j = 2; j < k; ++j)", "              if (word[i + j] != ws[j])"], "readability/braces"]
["src/nvim/spell.c", ["          if (k > 2) {", "            for (j = 2; j < k; ++j)", "              if (word[i + j] != ws[j])"], "readability/increment"]
["src/nvim/spell.c", ["            for (j = 2; j < k; ++j)", "              if (word[i + j] != ws[j])", "                break;"], "readability/braces"]
["src/nvim/spell.c", ["                break;", "            if (j < k)", "              continue;"], "readability/braces"]
["src/nvim/spell.c", ["          // Check for match with one of the chars in \"sm_oneof\".", "          while (*pf != NUL && *pf != word[i + k])", "            ++pf;"], "readability/braces"]
["src/nvim/spell.c", ["          while (*pf != NUL && *pf != word[i + k])", "            ++pf;", "          if (*pf == NUL)"], "readability/increment"]
["src/nvim/spell.c", ["            ++pf;", "          if (*pf == NUL)", "            continue;"], "readability/braces"]
["src/nvim/spell.c", ["            continue;", "          ++k;", "        }"], "readability/increment"]
["src/nvim/spell.c", ["        }", "        if (*s == '<')", "          s++;"], "readability/braces"]
["src/nvim/spell.c", ["        }", "        if (*s == '^' && *(s + 1) == '^')", "          s++;"], "readability/braces"]
["src/nvim/spell.c", ["            for (; ((ws = smp[n0].sm_lead_w)[0] & 0xff)", "                 == (c0 & 0xff); ++n0) {", "              // Quickly skip entries that don't match the word."], "readability/increment"]
["src/nvim/spell.c", ["              // Quickly skip entries that don't match the word.", "              if (c0 != ws[0])", "                continue;"], "readability/braces"]
["src/nvim/spell.c", ["              if (k0 > 1) {", "                if (word[i + k] != ws[1])", "                  continue;"], "readability/braces"]
["src/nvim/spell.c", ["                  pf = word + i + k + 1;", "                  for (j = 2; j < k0; ++j)", "                    if (*pf++ != ws[j])"], "readability/braces"]
["src/nvim/spell.c", ["                  pf = word + i + k + 1;", "                  for (j = 2; j < k0; ++j)", "                    if (*pf++ != ws[j])"], "readability/increment"]
["src/nvim/spell.c", ["                  for (j = 2; j < k0; ++j)", "                    if (*pf++ != ws[j])", "                      break;"], "readability/braces"]
["src/nvim/spell.c", ["                      break;", "                  if (j < k0)", "                    continue;"], "readability/braces"]
["src/nvim/spell.c", ["                // \"sm_oneof\".", "                while (*pf != NUL && *pf != word[i + k0])", "                  ++pf;"], "readability/braces"]
["src/nvim/spell.c", ["                while (*pf != NUL && *pf != word[i + k0])", "                  ++pf;", "                if (*pf == NUL)"], "readability/increment"]
["src/nvim/spell.c", ["                  ++pf;", "                if (*pf == NUL)", "                  continue;"], "readability/braces"]
["src/nvim/spell.c", ["                  continue;", "                ++k0;", "              }"], "readability/increment"]
["src/nvim/spell.c", ["              }", "              if (*s == '<')", "                s++;"], "readability/braces"]
["src/nvim/spell.c", ["                      && !spell_iswordp_w(word + i + k0,", "                          curwin))) {", "                if (k0 == k)"], "whitespace/alignment"]
["src/nvim/spell.c", ["                      && !spell_iswordp_w(word + i + k0,", "                          curwin))) {", "                if (k0 == k)"], "whitespace/alignment"]
["src/nvim/spell.c", ["                      && !spell_iswordp_w(word + i + k0,", "                          curwin))) {", "                if (k0 == k)"], "whitespace/alignment"]
["src/nvim/spell.c", ["                          curwin))) {", "                if (k0 == k)", "                  // this is just a piece of the string"], "readability/braces"]
["src/nvim/spell.c", ["", "                if (p0 < pri)", "                  // priority too low"], "readability/braces"]
["src/nvim/spell.c", ["", "            if (p0 >= pri && (smp[n0].sm_lead_w[0] & 0xff)", "                == (c0 & 0xff))"], "readability/braces"]
["src/nvim/spell.c", ["            // rule with '<' is used", "            if (reslen > 0 && ws != NULL && *ws != NUL", "                && (wres[reslen - 1] == c"], "readability/braces"]
["src/nvim/spell.c", ["            k0 = 0;", "            if (ws != NULL)", "              while (*ws != NUL && word[i + k0] != NUL) {"], "readability/braces"]
["src/nvim/spell.c", ["              }", "            if (k > k0)", "              memmove(word + i + k0, word + i + k,"], "readability/braces"]
["src/nvim/spell.c", ["              memmove(word + i + k0, word + i + k,", "                  sizeof(int) * (wordlen - (i + k) + 1));", ""], "whitespace/alignment"]
["src/nvim/spell.c", ["            z = 0;", "            if (ws != NULL)", "              while (*ws != NUL && ws[1] != NUL"], "readability/braces"]
["src/nvim/spell.c", ["                     && reslen < MAXWLEN) {", "                if (reslen == 0 || wres[reslen - 1] != *ws)", "                  wres[reslen++] = *ws;"], "readability/braces"]
["src/nvim/spell.c", ["            // new \"actual letter\"", "            if (ws == NULL)", "              c = NUL;"], "readability/braces"]
["src/nvim/spell.c", ["              c = NUL;", "            else", "              c = *ws;"], "readability/braces"]
["src/nvim/spell.c", ["            if (strstr((char *)s, \"^^\") != NULL) {", "              if (c != NUL)", "                wres[reslen++] = c;"], "readability/braces"]
["src/nvim/spell.c", ["              memmove(word, word + i + 1,", "                  sizeof(int) * (wordlen - (i + 1) + 1));", "              i = 0;"], "whitespace/alignment"]
["src/nvim/spell.c", ["    if (z0 == 0) {", "      if (k && !p0 && reslen < MAXWLEN && c != NUL", "          && (!slang->sl_collapse || reslen == 0"], "readability/braces"]
["src/nvim/spell.c", ["static int", "soundalike_score (", "    char_u *goodstart,         // sound-folded good word"], "whitespace/parens"]
["src/nvim/spell.c", ["  if ((*badsound == '*' || *goodsound == '*') && *badsound != *goodsound) {", "    if ((badsound[0] == NUL && goodsound[1] == NUL)", "        || (goodsound[0] == NUL && badsound[1] == NUL))"], "readability/braces"]
["src/nvim/spell.c", ["      return SCORE_DEL;", "    if (badsound[0] == NUL || goodsound[0] == NUL)", "      // more than two changes"], "readability/braces"]
["src/nvim/spell.c", ["      score = 2 * SCORE_DEL / 3;", "      if (*badsound == '*')", "        ++badsound;"], "readability/braces"]
["src/nvim/spell.c", ["      if (*badsound == '*')", "        ++badsound;", "      else"], "readability/increment"]
["src/nvim/spell.c", ["        ++badsound;", "      else", "        ++goodsound;"], "readability/braces"]
["src/nvim/spell.c", ["      else", "        ++goodsound;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["  n = goodlen - badlen;", "  if (n < -2 || n > 2)", "    return SCORE_MAXMAX;"], "readability/braces"]
["src/nvim/spell.c", ["  while (*pl == *ps && *pl != NUL) {", "    ++pl;", "    ++ps;"], "readability/increment"]
["src/nvim/spell.c", ["    ++pl;", "    ++ps;", "  }"], "readability/increment"]
["src/nvim/spell.c", ["    // Must delete two characters from \"pl\".", "    ++pl;               // first delete", "    while (*pl == *ps) {"], "readability/increment"]
["src/nvim/spell.c", ["    while (*pl == *ps) {", "      ++pl;", "      ++ps;"], "readability/increment"]
["src/nvim/spell.c", ["      ++pl;", "      ++ps;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["    // strings must be equal after second delete", "    if (STRCMP(pl + 1, ps) == 0)", "      return score + SCORE_DEL * 2;"], "readability/braces"]
["src/nvim/spell.c", ["    while (*pl2 == *ps2) {", "      if (*pl2 == NUL)                  // reached the end", "        return score + SCORE_DEL;"], "readability/braces"]
["src/nvim/spell.c", ["        return score + SCORE_DEL;", "      ++pl2;", "      ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["      ++pl2;", "      ++ps2;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["    // 2: delete then swap, then rest must be equal", "    if (pl2[0] == ps2[1] && pl2[1] == ps2[0]", "        && STRCMP(pl2 + 2, ps2 + 2) == 0)"], "readability/braces"]
["src/nvim/spell.c", ["    // 3: delete then substitute, then the rest must be equal", "    if (STRCMP(pl2 + 1, ps2 + 1) == 0)", "      return score + SCORE_DEL + SCORE_SUBST;"], "readability/braces"]
["src/nvim/spell.c", ["      while (*pl2 == *ps2) {", "        ++pl2;", "        ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["        ++pl2;", "        ++ps2;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["      // delete a char and then strings must be equal", "      if (STRCMP(pl2 + 1, ps2) == 0)", "        return score + SCORE_SWAP + SCORE_DEL;"], "readability/braces"]
["src/nvim/spell.c", ["    while (*pl2 == *ps2) {", "      ++pl2;", "      ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["      ++pl2;", "      ++ps2;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["    // delete a char and then strings must be equal", "    if (STRCMP(pl2 + 1, ps2) == 0)", "      return score + SCORE_SUBST + SCORE_DEL;"], "readability/braces"]
["src/nvim/spell.c", ["    // 1: check if for identical strings", "    if (*pl == NUL)", "      return score;"], "readability/braces"]
["src/nvim/spell.c", ["      while (*pl2 == *ps2) {", "        if (*pl2 == NUL)                // reached the end", "          return score + SCORE_SWAP;"], "readability/braces"]
["src/nvim/spell.c", ["          return score + SCORE_SWAP;", "        ++pl2;", "        ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["        ++pl2;", "        ++ps2;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["      // 3: swap and swap again", "      if (pl2[0] == ps2[1] && pl2[1] == ps2[0]", "          && STRCMP(pl2 + 2, ps2 + 2) == 0)"], "readability/braces"]
["src/nvim/spell.c", ["      // 4: swap and substitute", "      if (STRCMP(pl2 + 1, ps2 + 1) == 0)", "        return score + SCORE_SWAP + SCORE_SUBST;"], "readability/braces"]
["src/nvim/spell.c", ["    while (*pl2 == *ps2) {", "      if (*pl2 == NUL)                  // reached the end", "        return score + SCORE_SUBST;"], "readability/braces"]
["src/nvim/spell.c", ["        return score + SCORE_SUBST;", "      ++pl2;", "      ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["      ++pl2;", "      ++ps2;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["    // 6: substitute and swap", "    if (pl2[0] == ps2[1] && pl2[1] == ps2[0]", "        && STRCMP(pl2 + 2, ps2 + 2) == 0)"], "readability/braces"]
["src/nvim/spell.c", ["    // 7: substitute and substitute", "    if (STRCMP(pl2 + 1, ps2 + 1) == 0)", "      return score + SCORE_SUBST + SCORE_SUBST;"], "readability/braces"]
["src/nvim/spell.c", ["    while (*pl2 == *ps2) {", "      ++pl2;", "      ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["      ++pl2;", "      ++ps2;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["    }", "    if (STRCMP(pl2 + 1, ps2) == 0)", "      return score + SCORE_INS + SCORE_DEL;"], "readability/braces"]
["src/nvim/spell.c", ["    while (*pl2 == *ps2) {", "      ++pl2;", "      ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["      ++pl2;", "      ++ps2;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["    }", "    if (STRCMP(pl2, ps2 + 1) == 0)", "      return score + SCORE_INS + SCORE_DEL;"], "readability/braces"]
["src/nvim/spell.c", ["  CNT(0, 0) = 0;", "  for (j = 1; j <= goodlen; ++j)", "    CNT(0, j) = CNT(0, j - 1) + SCORE_INS;"], "readability/braces"]
["src/nvim/spell.c", ["  CNT(0, 0) = 0;", "  for (j = 1; j <= goodlen; ++j)", "    CNT(0, j) = CNT(0, j - 1) + SCORE_INS;"], "readability/increment"]
["src/nvim/spell.c", ["", "  for (i = 1; i <= badlen; ++i) {", "    CNT(i, 0) = CNT(i - 1, 0) + SCORE_DEL;"], "readability/increment"]
["src/nvim/spell.c", ["        // Use a better score when there is only a case difference.", "        if (SPELL_TOFOLD(bc) == SPELL_TOFOLD(gc))", "          CNT(i, j) = SCORE_ICASE + CNT(i - 1, j - 1);"], "readability/braces"]
["src/nvim/spell.c", ["          CNT(i, j) = SCORE_ICASE + CNT(i - 1, j - 1);", "        else {", "          // For a similar character use SCORE_SIMILAR."], "readability/braces"]
["src/nvim/spell.c", ["          CNT(i, j) = SCORE_ICASE + CNT(i - 1, j - 1);", "        else {", "          // For a similar character use SCORE_SIMILAR."], "readability/braces"]
["src/nvim/spell.c", ["          // For a similar character use SCORE_SIMILAR.", "          if (slang != NULL", "              && slang->sl_has_map"], "readability/braces"]
["src/nvim/spell.c", ["            CNT(i, j) = SCORE_SIMILAR + CNT(i - 1, j - 1);", "          else", "            CNT(i, j) = SCORE_SUBST + CNT(i - 1, j - 1);"], "readability/braces"]
["src/nvim/spell.c", ["            t = SCORE_SWAP + CNT(i - 2, j - 2);", "            if (t < CNT(i, j))", "              CNT(i, j) = t;"], "readability/braces"]
["src/nvim/spell.c", ["        t = SCORE_DEL + CNT(i - 1, j);", "        if (t < CNT(i, j))", "          CNT(i, j) = t;"], "readability/braces"]
["src/nvim/spell.c", ["        t = SCORE_INS + CNT(i, j - 1);", "        if (t < CNT(i, j))", "          CNT(i, j) = t;"], "readability/braces"]
["src/nvim/spell.c", ["// for multi-byte characters.", "static int spell_edit_score_limit(slang_T *slang, char_u *badword, char_u *goodword, int limit)", "{"], "whitespace/line_length"]
["src/nvim/spell.c", ["// Keep it in sync with the above!", "static int spell_edit_score_limit_w(slang_T *slang, char_u *badword, char_u *goodword, int limit)", "{"], "whitespace/line_length"]
["src/nvim/spell.c", ["", "      if (bc != gc)             // stop at a char that's different", "        break;"], "readability/braces"]
["src/nvim/spell.c", ["      if (bc == NUL) {          // both words end", "        if (score < minscore)", "          minscore = score;"], "readability/braces"]
["src/nvim/spell.c", ["      }", "      ++bi;", "      ++gi;"], "readability/increment"]
["src/nvim/spell.c", ["      ++bi;", "      ++gi;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["      do {", "        if ((score += SCORE_DEL) >= minscore)", "          goto pop;                 // do next alternative"], "readability/braces"]
["src/nvim/spell.c", ["      minscore = score;", "    } else if (bc == NUL)   { // badword ends, insert badword chars", "      do {"], "whitespace/comments"]
["src/nvim/spell.c", ["      do {", "        if ((score += SCORE_INS) >= minscore)", "          goto pop;                 // do next alternative"], "readability/braces"]
["src/nvim/spell.c", ["      // round 1: try inserting a char in badword", "      for (round = 0; round <= 1; ++round) {", "        score_off = score + (round == 0 ? SCORE_DEL : SCORE_INS);"], "readability/increment"]
["src/nvim/spell.c", ["              }", "              ++bi2;", "              ++gi2;"], "readability/increment"]
["src/nvim/spell.c", ["              ++bi2;", "              ++gi2;", "            }"], "readability/increment"]
["src/nvim/spell.c", ["            stack[stackidx].score = score_off;", "            ++stackidx;", "          }"], "readability/increment"]
["src/nvim/spell.c", ["      // Use a better score when there is only a case difference.", "      if (SPELL_TOFOLD(bc) == SPELL_TOFOLD(gc))", "        score += SCORE_ICASE;"], "readability/braces"]
["src/nvim/spell.c", ["        score += SCORE_ICASE;", "      else {", "        // For a similar character use SCORE_SIMILAR."], "readability/braces"]
["src/nvim/spell.c", ["        score += SCORE_ICASE;", "      else {", "        // For a similar character use SCORE_SIMILAR."], "readability/braces"]
["src/nvim/spell.c", ["        // For a similar character use SCORE_SIMILAR.", "        if (slang != NULL", "            && slang->sl_has_map"], "readability/braces"]
["src/nvim/spell.c", ["          score += SCORE_SIMILAR;", "        else", "          score += SCORE_SUBST;"], "readability/braces"]
["src/nvim/spell.c", ["        // Do the substitution.", "        ++gi;", "        ++bi;"], "readability/increment"]
["src/nvim/spell.c", ["        ++gi;", "        ++bi;", "        continue;"], "readability/increment"]
["src/nvim/spell.c", ["    // Get here to try the next alternative, pop it from the stack.", "    if (stackidx == 0)                  // stack is empty, finished", "      break;"], "readability/braces"]
["src/nvim/spell.c", ["    // pop an item from the stack", "    --stackidx;", "    gi = stack[stackidx].goodi;"], "readability/increment"]
["src/nvim/spell.c", ["  // bonus.", "  if (minscore > limit)", "    return SCORE_MAXMAX;"], "readability/braces"]
["src/nvim/spell.c", ["void", "spell_dump_compl (", "    char_u *pat,           // leading part of the word"], "whitespace/parens"]
["src/nvim/spell.c", ["  if (pat != NULL) {", "    if (ic)", "      dumpflags |= DUMPFLAG_ICASE;"], "readability/braces"]
["src/nvim/spell.c", ["      dumpflags |= DUMPFLAG_ICASE;", "    else {", "      n = captype(pat, NULL);"], "readability/braces"]
["src/nvim/spell.c", ["      dumpflags |= DUMPFLAG_ICASE;", "    else {", "      n = captype(pat, NULL);"], "readability/braces"]
["src/nvim/spell.c", ["      n = captype(pat, NULL);", "      if (n == WF_ONECAP)", "        dumpflags |= DUMPFLAG_ONECAP;"], "readability/braces"]
["src/nvim/spell.c", ["        dumpflags |= DUMPFLAG_ONECAP;", "      else if (n == WF_ALLCAP", "               && (int)STRLEN(pat) > mb_ptr2len(pat)"], "readability/braces"]
["src/nvim/spell.c", ["  // regions or none at all.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["    if (p[0] != 0) {", "      if (region_names == NULL)             // first language with regions", "        region_names = p;"], "readability/braces"]
["src/nvim/spell.c", ["        region_names = p;", "      else if (STRCMP(region_names, p) != 0) {", "        do_region = false;                  // region names are different"], "readability/braces"]
["src/nvim/spell.c", ["    }", "  } else", "    do_region = false;"], "readability/braces"]
["src/nvim/spell.c", ["  // Loop over all files loaded for the entries in 'spelllang'.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["    slang = lp->lp_slang;", "    if (slang->sl_fbyts == NULL)            // reloading failed", "      continue;"], "readability/braces"]
["src/nvim/spell.c", ["    // parts of the tree that match \"pat\".", "    if (pat != NULL && slang->sl_pbyts == NULL)", "      patlen = (int)STRLEN(pat);"], "readability/braces"]
["src/nvim/spell.c", ["      patlen = (int)STRLEN(pat);", "    else", "      patlen = -1;"], "readability/braces"]
["src/nvim/spell.c", ["    // round 2: keep-case tree", "    for (round = 1; round <= 2; ++round) {", "      if (round == 1) {"], "readability/increment"]
["src/nvim/spell.c", ["      }", "      if (byts == NULL)", "        continue;                       // array is empty"], "readability/braces"]
["src/nvim/spell.c", ["          // Done all bytes at this node, go up one level.", "          --depth;", "          line_breakcheck();"], "readability/increment"]
["src/nvim/spell.c", ["          n = arridx[depth] + curi[depth];", "          ++curi[depth];", "          c = byts[n];"], "readability/increment"]
["src/nvim/spell.c", ["              word[depth] = NUL;", "              if (!do_region)", "                flags &= ~WF_REGION;"], "readability/braces"]
["src/nvim/spell.c", ["                dump_word(slang, word, pat, dir,", "                    dumpflags, flags, lnum);", "                if (pat == NULL)"], "whitespace/alignment"]
["src/nvim/spell.c", ["                    dumpflags, flags, lnum);", "                if (pat == NULL)", "                  ++lnum;"], "readability/braces"]
["src/nvim/spell.c", ["                if (pat == NULL)", "                  ++lnum;", "              }"], "readability/increment"]
["src/nvim/spell.c", ["              // Apply the prefix, if there is one.", "              if (c != 0)", "                lnum = dump_prefixes(slang, word, pat, dir,"], "readability/braces"]
["src/nvim/spell.c", ["                lnum = dump_prefixes(slang, word, pat, dir,", "                    dumpflags, flags, lnum);", "            }"], "whitespace/alignment"]
["src/nvim/spell.c", ["            assert(depth >= 0);", "            if (depth <= patlen", "                && mb_strnicmp(word, pat, (size_t)depth) != 0)"], "readability/braces"]
["src/nvim/spell.c", ["                && mb_strnicmp(word, pat, (size_t)depth) != 0)", "              --depth;", "          }"], "readability/increment"]
["src/nvim/spell.c", ["", "  if (dumpflags & DUMPFLAG_ONECAP)", "    flags |= WF_ONECAP;"], "readability/braces"]
["src/nvim/spell.c", ["    flags |= WF_ONECAP;", "  if (dumpflags & DUMPFLAG_ALLCAP)", "    flags |= WF_ALLCAP;"], "readability/braces"]
["src/nvim/spell.c", ["    p = word;", "    if ((dumpflags & DUMPFLAG_KEEPCASE)", "        && ((captype(word, NULL) & WF_KEEPCAP) == 0"], "readability/braces"]
["src/nvim/spell.c", ["        vim_snprintf((char *)IObuff, IOSIZE, \"%s\\t%d\",", "            tw, HI2WC(hi)->wc_count);", "        p = IObuff;"], "whitespace/alignment"]
["src/nvim/spell.c", ["static linenr_T", "dump_prefixes (", "    slang_T *slang,"], "whitespace/parens"]
["src/nvim/spell.c", ["        // Done all bytes at this node, go up one level.", "        --depth;", "        line_breakcheck();"], "readability/increment"]
["src/nvim/spell.c", ["        n += curi[depth];", "        ++curi[depth];", "        c = byts[n];"], "readability/increment"]
["src/nvim/spell.c", ["          // End of prefix, find out how many IDs there are.", "          for (i = 1; i < len; ++i)", "            if (byts[n + i] != 0)"], "readability/braces"]
["src/nvim/spell.c", ["          // End of prefix, find out how many IDs there are.", "          for (i = 1; i < len; ++i)", "            if (byts[n + i] != 0)"], "readability/increment"]
["src/nvim/spell.c", ["          for (i = 1; i < len; ++i)", "            if (byts[n + i] != 0)", "              break;"], "readability/braces"]
["src/nvim/spell.c", ["            dump_word(slang, prefix, pat, dir, dumpflags,", "                (c & WF_RAREPFX) ? (flags | WF_RARE)", "                : flags, lnum);"], "whitespace/alignment"]
["src/nvim/spell.c", ["                (c & WF_RAREPFX) ? (flags | WF_RARE)", "                : flags, lnum);", "            if (lnum != 0)"], "whitespace/alignment"]
["src/nvim/spell.c", ["                : flags, lnum);", "            if (lnum != 0)", "              ++lnum;"], "readability/braces"]
["src/nvim/spell.c", ["            if (lnum != 0)", "              ++lnum;", "          }"], "readability/increment"]
["src/nvim/spell.c", ["            c = valid_word_prefix(i, n, flags, word_up, slang,", "                true);", "            if (c != 0) {"], "whitespace/alignment"]
["src/nvim/spell.c", ["              dump_word(slang, prefix, pat, dir, dumpflags,", "                  (c & WF_RAREPFX) ? (flags | WF_RARE)", "                  : flags, lnum);"], "whitespace/alignment"]
["src/nvim/spell.c", ["                  (c & WF_RAREPFX) ? (flags | WF_RARE)", "                  : flags, lnum);", "              if (lnum != 0)"], "whitespace/alignment"]
["src/nvim/spell.c", ["                  : flags, lnum);", "              if (lnum != 0)", "                ++lnum;"], "readability/braces"]
["src/nvim/spell.c", ["              if (lnum != 0)", "                ++lnum;", "            }"], "readability/increment"]
