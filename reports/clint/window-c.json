["src/nvim/window.c", ["", "#define NOWIN           (win_T *)-1     /* non-existing window */", ""], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * all CTRL-W window commands are handled here, called from normal_cmd()."], "readability/old_style_comment"]
["src/nvim/window.c", ["    long Prenum,", "    int xchar                  /* extra char from \":wincmd gx\" or NUL */", ")"], "readability/old_style_comment"]
["src/nvim/window.c", ["  switch (nchar) {", "  /* split current window in two parts, horizontally */", "  case 'S':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* split current window in two parts, vertically */", "  case Ctrl_V:"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* split current window and edit alternate file */", "  case Ctrl_HAT:"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* open new window */", "  case Ctrl_N:"], "readability/old_style_comment"]
["src/nvim/window.c", ["newwindow:", "    if (Prenum)", "      /* window height */"], "readability/braces"]
["src/nvim/window.c", ["    if (Prenum)", "      /* window height */", "      vim_snprintf(cbuf, sizeof(cbuf) - 5, \"%\" PRId64, (int64_t)Prenum);"], "readability/old_style_comment"]
["src/nvim/window.c", ["      vim_snprintf(cbuf, sizeof(cbuf) - 5, \"%\" PRId64, (int64_t)Prenum);", "    else", "      cbuf[0] = NUL;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* quit current window */", "  case Ctrl_Q:"], "readability/old_style_comment"]
["src/nvim/window.c", ["  case 'q':", "    reset_VIsual_and_resel();                   /* stop Visual mode */", "    cmd_with_count(\"quit\", (char_u *)cbuf, sizeof(cbuf), Prenum);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* close current window */", "  case Ctrl_C:"], "readability/old_style_comment"]
["src/nvim/window.c", ["  case 'c':", "    reset_VIsual_and_resel();                   /* stop Visual mode */", "    cmd_with_count(\"close\", (char_u *)cbuf, sizeof(cbuf), Prenum);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* close preview window */", "  case Ctrl_Z:"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* cursor to preview window */", "  case 'P':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* close all but current window */", "  case Ctrl_O:"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* cursor to next window with wrap around */", "  case Ctrl_W:"], "readability/old_style_comment"]
["src/nvim/window.c", ["  case 'w':", "  /* cursor to previous window with wrap around */", "  case 'W':"], "readability/old_style_comment"]
["src/nvim/window.c", ["        for (wp = firstwin; --Prenum > 0; ) {", "          if (wp->w_next == NULL)", "            break;"], "readability/braces"]
["src/nvim/window.c", ["            break;", "          else", "            wp = wp->w_next;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* cursor to window below */", "  case 'j':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* cursor to window above */", "  case 'k':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* cursor to left window */", "  case 'h':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* cursor to right window */", "  case 'l':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* move window to new tab page */", "  case 'T':"], "readability/old_style_comment"]
["src/nvim/window.c", ["  case 'T':", "    if (one_window())", "      MSG(_(m_onlyone));"], "readability/braces"]
["src/nvim/window.c", ["      MSG(_(m_onlyone));", "    else {", "      tabpage_T   *oldtab = curtab;"], "readability/braces"]
["src/nvim/window.c", ["      MSG(_(m_onlyone));", "    else {", "      tabpage_T   *oldtab = curtab;"], "readability/braces"]
["src/nvim/window.c", ["", "      /* First create a new tab with the window, then go back to", "       * the old tab and close the window there. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* cursor to top-left window */", "  case 't':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* cursor to bottom-right window */", "  case 'b':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* cursor to last accessed (previous) window */", "  case 'p':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* exchange current and next window */", "  case 'x':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* rotate windows downwards */", "  case Ctrl_R:"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* rotate windows upwards */", "  case 'R':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* move window to the very top/bottom/left/right */", "  case 'K':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* make all windows the same height */", "  case '=':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* increase current window height */", "  case '+':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* decrease current window height */", "  case '-':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* set current window height */", "  case Ctrl__:"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* increase current window width */", "  case '>':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* decrease current window width */", "  case '<':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* set current window width */", "  case '|':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* jump to tag and split window if tag exists (in preview window) */", "  case '}':"], "readability/old_style_comment"]
["src/nvim/window.c", ["    // Keep visual mode, can select words to use as a tag.", "    if (Prenum)", "      postponed_split = Prenum;"], "readability/braces"]
["src/nvim/window.c", ["      postponed_split = Prenum;", "    else", "      postponed_split = -1;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* edit file name under cursor in a new window */", "  case 'f':"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Go to the first occurrence of the identifier under cursor along path in a", "   * new window -- webb"], "readability/old_style_comment"]
["src/nvim/window.c", ["   */", "  case 'i':                         /* Go to any match */", "  case Ctrl_I:"], "readability/old_style_comment"]
["src/nvim/window.c", ["                         type, Prenum1, ACTION_SPLIT, 1, MAXLNUM);", "    curwin->w_set_curswant = TRUE;", "    break;"], "readability/bool"]
["src/nvim/window.c", ["", "  /* CTRL-W g  extended commands */", "  case 'g':"], "readability/old_style_comment"]
["src/nvim/window.c", ["      xchar = Ctrl_RSB;", "      if (Prenum)", "        g_do_tagpreview = Prenum;"], "readability/braces"]
["src/nvim/window.c", ["        g_do_tagpreview = Prenum;", "      else", "        g_do_tagpreview = p_pvh;"], "readability/braces"]
["src/nvim/window.c", ["      // Keep visual mode, can select words to use as a tag.", "      if (Prenum)", "        postponed_split = Prenum;"], "readability/braces"]
["src/nvim/window.c", ["        postponed_split = Prenum;", "      else", "        postponed_split = -1;"], "readability/braces"]
["src/nvim/window.c", ["", "      /* Execute the command right here, required when", "       * \"wincmd g}\" was used in a function. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    case 'f':                       /* CTRL-W gf: \"gf\" in a new tab page */", "    case 'F':                       /* CTRL-W gF: \"gF\" in a new tab page */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    case 'f':                       /* CTRL-W gf: \"gf\" in a new tab page */", "    case 'F':                       /* CTRL-W gF: \"gF\" in a new tab page */", "      cmdmod.tab = tabpage_index(curtab) + 1;"], "readability/old_style_comment"]
["src/nvim/window.c", ["  }", "", "}"], "whitespace/blank_line"]
["src/nvim/window.c", ["", "/*", " * split the current window, implements CTRL-W s and :split"], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  /* When the \":tab\" modifier was used open a new tab page instead. */", "  if (may_open_tabpage() == OK)"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* When the \":tab\" modifier was used open a new tab page instead. */", "  if (may_open_tabpage() == OK)", "    return OK;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* Add flags from \":vertical\", \":topleft\" and \":botright\". */", "  flags |= cmdmod.split;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* When creating the help window make a snapshot of the window layout.", "   * Otherwise clear the snapshot, it's now invalid. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["   * Otherwise clear the snapshot, it's now invalid. */", "  if (flags & WSP_HELP)", "    make_snapshot(SNAP_HELP_IDX);"], "readability/braces"]
["src/nvim/window.c", ["    make_snapshot(SNAP_HELP_IDX);", "  else", "    clear_snapshot(curtab, SNAP_HELP_IDX);"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * When \"new_wp\" is NULL: split the current window in two."], "readability/old_style_comment"]
["src/nvim/window.c", ["  int need_status = 0;", "  int do_equal = FALSE;", "  int needed;"], "readability/bool"]
["src/nvim/window.c", ["", "    /*", "     * Check if we are able to split the current window and compute its"], "readability/old_style_comment"]
["src/nvim/window.c", ["    }", "    if (new_size == 0)", "      new_size = oldwin->w_width / 2;"], "readability/braces"]
["src/nvim/window.c", ["", "    /* if it doesn't fit in the current window, need win_equal() */", "    if (oldwin->w_width - new_size - 1 < p_wmw)"], "readability/old_style_comment"]
["src/nvim/window.c", ["    /* if it doesn't fit in the current window, need win_equal() */", "    if (oldwin->w_width - new_size - 1 < p_wmw)", "      do_equal = TRUE;"], "readability/braces"]
["src/nvim/window.c", ["    if (oldwin->w_width - new_size - 1 < p_wmw)", "      do_equal = TRUE;", ""], "readability/bool"]
["src/nvim/window.c", ["", "    /* Only make all windows the same width if one of them (except oldwin)", "     * is wider than one of the split windows. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["                || frp->fr_win->w_width > oldwin->w_width", "                                          - new_size - 1)) {", "          do_equal = TRUE;"], "whitespace/alignment"]
["src/nvim/window.c", ["                || frp->fr_win->w_width > oldwin->w_width", "                                          - new_size - 1)) {", "          do_equal = TRUE;"], "whitespace/alignment"]
["src/nvim/window.c", ["                                          - new_size - 1)) {", "          do_equal = TRUE;", "          break;"], "readability/bool"]
["src/nvim/window.c", ["", "    /*", "     * Check if we are able to split the current window and compute its"], "readability/old_style_comment"]
["src/nvim/window.c", ["    }", "    if (new_size == 0)", "      new_size = oldwin_height / 2;"], "readability/braces"]
["src/nvim/window.c", ["", "    /* if it doesn't fit in the current window, need win_equal() */", "    if (oldwin_height - new_size - STATUS_HEIGHT < p_wmh)"], "readability/old_style_comment"]
["src/nvim/window.c", ["    /* if it doesn't fit in the current window, need win_equal() */", "    if (oldwin_height - new_size - STATUS_HEIGHT < p_wmh)", "      do_equal = TRUE;"], "readability/braces"]
["src/nvim/window.c", ["    if (oldwin_height - new_size - STATUS_HEIGHT < p_wmh)", "      do_equal = TRUE;", ""], "readability/bool"]
["src/nvim/window.c", ["", "    /* We don't like to take lines for the new window from a", "     * 'winfixheight' window.  Take them from a window above or below"], "readability/old_style_comment"]
["src/nvim/window.c", ["      win_setheight_win(oldwin->w_height + new_size + STATUS_HEIGHT,", "          oldwin);", "      oldwin_height = oldwin->w_height;"], "whitespace/alignment"]
["src/nvim/window.c", ["      oldwin_height = oldwin->w_height;", "      if (need_status)", "        oldwin_height -= STATUS_HEIGHT;"], "readability/braces"]
["src/nvim/window.c", ["", "    /* Only make all windows the same height if one of them (except oldwin)", "     * is higher than one of the split windows. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["                - STATUS_HEIGHT)) {", "          do_equal = TRUE;", "          break;"], "readability/bool"]
["src/nvim/window.c", ["", "  /*", "   * allocate new window structure and link it in the window list"], "readability/old_style_comment"]
["src/nvim/window.c", ["              && (", "                (flags & WSP_VERT) ? p_spr :", "                p_sb)))) {"], "whitespace/indent"]
["src/nvim/window.c", ["                (flags & WSP_VERT) ? p_spr :", "                p_sb)))) {", "    /* new window below/right of current one */"], "whitespace/indent"]
["src/nvim/window.c", ["              && (", "                (flags & WSP_VERT) ? p_spr :", "                p_sb)))) {"], "whitespace/indent"]
["src/nvim/window.c", ["                (flags & WSP_VERT) ? p_spr :", "                p_sb)))) {", "    /* new window below/right of current one */"], "whitespace/indent"]
["src/nvim/window.c", ["              && (", "                (flags & WSP_VERT) ? p_spr :", "                p_sb)))) {"], "whitespace/indent"]
["src/nvim/window.c", ["                (flags & WSP_VERT) ? p_spr :", "                p_sb)))) {", "    /* new window below/right of current one */"], "whitespace/indent"]
["src/nvim/window.c", ["              && (", "                (flags & WSP_VERT) ? p_spr :", "                p_sb)))) {"], "whitespace/indent"]
["src/nvim/window.c", ["                (flags & WSP_VERT) ? p_spr :", "                p_sb)))) {", "    /* new window below/right of current one */"], "whitespace/indent"]
["src/nvim/window.c", ["                p_sb)))) {", "    /* new window below/right of current one */", "    if (new_wp == NULL)"], "readability/old_style_comment"]
["src/nvim/window.c", ["    /* new window below/right of current one */", "    if (new_wp == NULL)", "      wp = win_alloc(oldwin, FALSE);"], "readability/braces"]
["src/nvim/window.c", ["    if (new_wp == NULL)", "      wp = win_alloc(oldwin, FALSE);", "    else"], "readability/bool"]
["src/nvim/window.c", ["      wp = win_alloc(oldwin, FALSE);", "    else", "      win_append(oldwin, wp);"], "readability/braces"]
["src/nvim/window.c", ["  } else {", "    if (new_wp == NULL)", "      wp = win_alloc(oldwin->w_prev, FALSE);"], "readability/braces"]
["src/nvim/window.c", ["    if (new_wp == NULL)", "      wp = win_alloc(oldwin->w_prev, FALSE);", "    else"], "readability/bool"]
["src/nvim/window.c", ["      wp = win_alloc(oldwin->w_prev, FALSE);", "    else", "      win_append(oldwin->w_prev, wp);"], "readability/braces"]
["src/nvim/window.c", ["  if (new_wp == NULL) {", "    if (wp == NULL)", "      return FAIL;"], "readability/braces"]
["src/nvim/window.c", ["", "    /* make the contents of the new window the same as the current one */", "    win_init(wp, curwin, flags);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /*", "   * Reorganise the tree of frames to insert the new window."], "readability/old_style_comment"]
["src/nvim/window.c", ["      curfrp = topframe->fr_child;", "      if (flags & WSP_BOT)", "        while (curfrp->fr_next != NULL)"], "readability/braces"]
["src/nvim/window.c", ["      if (flags & WSP_BOT)", "        while (curfrp->fr_next != NULL)", "          curfrp = curfrp->fr_next;"], "readability/braces"]
["src/nvim/window.c", ["          curfrp = curfrp->fr_next;", "    } else", "      curfrp = topframe;"], "readability/braces"]
["src/nvim/window.c", ["    curfrp = oldwin->w_frame;", "    if (flags & WSP_BELOW)", "      before = FALSE;"], "readability/braces"]
["src/nvim/window.c", ["    if (flags & WSP_BELOW)", "      before = FALSE;", "    else if (flags & WSP_ABOVE)"], "readability/bool"]
["src/nvim/window.c", ["      before = FALSE;", "    else if (flags & WSP_ABOVE)", "      before = TRUE;"], "readability/braces"]
["src/nvim/window.c", ["    else if (flags & WSP_ABOVE)", "      before = TRUE;", "    else if (flags & WSP_VERT)"], "readability/bool"]
["src/nvim/window.c", ["      before = TRUE;", "    else if (flags & WSP_VERT)", "      before = !p_spr;"], "readability/braces"]
["src/nvim/window.c", ["      before = !p_spr;", "    else", "      before = !p_sb;"], "readability/braces"]
["src/nvim/window.c", ["  if (curfrp->fr_parent == NULL || curfrp->fr_parent->fr_layout != layout) {", "    /* Need to create a new frame in the tree to make a branch. */", "    frp = xcalloc(1, sizeof(frame_T));"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  if (new_wp == NULL)", "    frp = wp->w_frame;"], "readability/braces"]
["src/nvim/window.c", ["    frp = wp->w_frame;", "  else", "    frp = new_wp->w_frame;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* Insert the new frame at the right place in the frame list. */", "  if (before)"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* Insert the new frame at the right place in the frame list. */", "  if (before)", "    frame_insert(curfrp, frp);"], "readability/braces"]
["src/nvim/window.c", ["    frame_insert(curfrp, frp);", "  else", "    frame_append(curfrp, frp);"], "readability/braces"]
["src/nvim/window.c", ["", "  /* Set w_fraction now so that the cursor keeps the same relative", "   * vertical position. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (flags & (WSP_TOP | WSP_BOT)) {", "      /* set height and row of new window to full height */", "      wp->w_winrow = tabline_height();"], "readability/old_style_comment"]
["src/nvim/window.c", ["    } else {", "      /* height and row of new window is same as current window */", "      wp->w_winrow = oldwin->w_winrow;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /* \"new_size\" of the current window goes to the new window, use", "     * one column for the vertical separator */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    win_new_width(wp, new_size);", "    if (before)", "      wp->w_vsep_width = 1;"], "readability/braces"]
["src/nvim/window.c", ["      wp->w_vsep_width = 1;", "    else {", "      wp->w_vsep_width = oldwin->w_vsep_width;"], "readability/braces"]
["src/nvim/window.c", ["      wp->w_vsep_width = 1;", "    else {", "      wp->w_vsep_width = oldwin->w_vsep_width;"], "readability/braces"]
["src/nvim/window.c", ["    if (flags & (WSP_TOP | WSP_BOT)) {", "      if (flags & WSP_BOT)", "        frame_add_vsep(curfrp);"], "readability/braces"]
["src/nvim/window.c", ["        frame_add_vsep(curfrp);", "      /* Set width of neighbor frame */", "      frame_new_width(curfrp, curfrp->fr_width"], "readability/old_style_comment"]
["src/nvim/window.c", ["      frame_new_width(curfrp, curfrp->fr_width", "          - (new_size + ((flags & WSP_TOP) != 0)), flags & WSP_TOP,", "          FALSE);"], "whitespace/alignment"]
["src/nvim/window.c", ["          - (new_size + ((flags & WSP_TOP) != 0)), flags & WSP_TOP,", "          FALSE);", "    } else"], "whitespace/alignment"]
["src/nvim/window.c", ["          - (new_size + ((flags & WSP_TOP) != 0)), flags & WSP_TOP,", "          FALSE);", "    } else"], "readability/bool"]
["src/nvim/window.c", ["          FALSE);", "    } else", "      win_new_width(oldwin, oldwin->w_width - (new_size + 1));"], "readability/braces"]
["src/nvim/window.c", ["      win_new_width(oldwin, oldwin->w_width - (new_size + 1));", "    if (before) {       /* new window left of current one */", "      wp->w_wincol = oldwin->w_wincol;"], "readability/old_style_comment"]
["src/nvim/window.c", ["      oldwin->w_wincol += new_size + 1;", "    } else              /* new window right of current one */", "      wp->w_wincol = oldwin->w_wincol + oldwin->w_width + 1;"], "readability/old_style_comment"]
["src/nvim/window.c", ["      oldwin->w_wincol += new_size + 1;", "    } else              /* new window right of current one */", "      wp->w_wincol = oldwin->w_wincol + oldwin->w_width + 1;"], "readability/braces"]
["src/nvim/window.c", ["  } else {", "    /* width and column of new window is same as current window */", "    if (flags & (WSP_TOP | WSP_BOT)) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /* \"new_size\" of the current window goes to the new window, use", "     * one row for the status line */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    }", "    if (flags & WSP_BOT)", "      frame_add_statusline(curfrp);"], "readability/braces"]
["src/nvim/window.c", ["", "  if (flags & (WSP_TOP | WSP_BOT))", "    (void)win_comp_pos();"], "readability/braces"]
["src/nvim/window.c", ["    msg_col = sc_col;", "    msg_clr_eos_force();        /* Old command/ruler may still be there */", "    comp_col();"], "readability/old_style_comment"]
["src/nvim/window.c", ["    msg_row = Rows - 1;", "    msg_col = 0;        /* put position back at start of line */", "  }"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /*", "   * equalize the window sizes."], "readability/old_style_comment"]
["src/nvim/window.c", ["   */", "  if (do_equal || dir != 0)", "    win_equal(wp, true,"], "readability/braces"]
["src/nvim/window.c", ["    win_equal(wp, true,", "        (flags & WSP_VERT) ? (dir == 'v' ? 'b' : 'h')", "        : dir == 'h' ? 'b' :"], "whitespace/alignment"]
["src/nvim/window.c", ["        (flags & WSP_VERT) ? (dir == 'v' ? 'b' : 'h')", "        : dir == 'h' ? 'b' :", "        'v');"], "whitespace/alignment"]
["src/nvim/window.c", ["        : dir == 'h' ? 'b' :", "        'v');", ""], "whitespace/alignment"]
["src/nvim/window.c", ["", "  /* Don't change the window height/width to 'winheight' / 'winwidth' if a", "   * size was given. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    i = p_wiw;", "    if (size != 0)", "      p_wiw = size;"], "readability/braces"]
["src/nvim/window.c", ["    i = p_wh;", "    if (size != 0)", "      p_wh = size;"], "readability/braces"]
["src/nvim/window.c", ["", "  /*", "   * make the new window the current window"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Initialize window \"newp\" from window \"oldp\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (flags & WSP_NEWLOC) {", "    /* Don't copy the location list.  */", "    newp->w_llist = NULL;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* copy tagstack and folds */", "  for (i = 0; i < oldp->w_tagstacklen; i++) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Initialize window \"newp\" from window \"old\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  /* Use the same argument list. */", "  newp->w_alist = oldp->w_alist;"], "readability/old_style_comment"]
["src/nvim/window.c", ["  newp->w_alist = oldp->w_alist;", "  ++newp->w_alist->al_refcount;", "  newp->w_arg_idx = oldp->w_arg_idx;"], "readability/increment"]
["src/nvim/window.c", ["", "  /* copy options from existing window */", "  win_copy_options(oldp, newp);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Return the number of windows."], "readability/old_style_comment"]
["src/nvim/window.c", ["  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {", "    ++count;", "  }"], "readability/increment"]
["src/nvim/window.c", ["", "/*", " * Make \"count\" windows on the screen."], "readability/old_style_comment"]
["src/nvim/window.c", [" */", "int ", "make_windows ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["int ", "make_windows (", "    int count,"], "whitespace/parens"]
["src/nvim/window.c", ["    int count,", "    int vertical              /* split windows vertically if TRUE */", ")"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (vertical) {", "    /* Each windows needs at least 'winminwidth' lines and a separator", "     * column. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  if (maxcount < 2)", "    maxcount = 2;"], "readability/braces"]
["src/nvim/window.c", ["    maxcount = 2;", "  if (count > maxcount)", "    count = maxcount;"], "readability/braces"]
["src/nvim/window.c", ["", "  /*", "   * add status line now, otherwise first window will be too big"], "readability/old_style_comment"]
["src/nvim/window.c", ["   */", "  if (count > 1)", "    last_status(TRUE);"], "readability/braces"]
["src/nvim/window.c", ["  if (count > 1)", "    last_status(TRUE);", ""], "readability/bool"]
["src/nvim/window.c", ["", "  /*", "   * Don't execute autocommands while creating the windows.  Must do that"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* todo is number of windows left to create */", "  for (todo = count - 1; todo > 0; --todo)"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* todo is number of windows left to create */", "  for (todo = count - 1; todo > 0; --todo)", "    if (vertical) {"], "readability/braces"]
["src/nvim/window.c", ["  /* todo is number of windows left to create */", "  for (todo = count - 1; todo > 0; --todo)", "    if (vertical) {"], "readability/increment"]
["src/nvim/window.c", ["    if (vertical) {", "      if (win_split(curwin->w_width - (curwin->w_width - todo)", "              / (todo + 1) - 1, WSP_VERT | WSP_ABOVE) == FAIL)"], "readability/braces"]
["src/nvim/window.c", ["      if (win_split(curwin->w_width - (curwin->w_width - todo)", "              / (todo + 1) - 1, WSP_VERT | WSP_ABOVE) == FAIL)", "        break;"], "whitespace/alignment"]
["src/nvim/window.c", ["    } else {", "      if (win_split(curwin->w_height - (curwin->w_height - todo", "                                        * STATUS_HEIGHT) / (todo + 1)"], "readability/braces"]
["src/nvim/window.c", ["                                        * STATUS_HEIGHT) / (todo + 1)", "              - STATUS_HEIGHT, WSP_ABOVE) == FAIL)", "        break;"], "whitespace/alignment"]
["src/nvim/window.c", ["", "  /* return actual number of windows */", "  return count - todo;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Exchange current and next window"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /*", "   * find window to exchange with"], "readability/old_style_comment"]
["src/nvim/window.c", ["    frp = curwin->w_frame->fr_parent->fr_child;", "    while (frp != NULL && --Prenum > 0)", "      frp = frp->fr_next;"], "readability/braces"]
["src/nvim/window.c", ["      frp = frp->fr_next;", "  } else if (curwin->w_frame->fr_next != NULL)  /* Swap with next */", "    frp = curwin->w_frame->fr_next;"], "readability/old_style_comment"]
["src/nvim/window.c", ["      frp = frp->fr_next;", "  } else if (curwin->w_frame->fr_next != NULL)  /* Swap with next */", "    frp = curwin->w_frame->fr_next;"], "readability/braces"]
["src/nvim/window.c", ["    frp = curwin->w_frame->fr_next;", "  else      /* Swap last window in row/col with previous */", "    frp = curwin->w_frame->fr_prev;"], "readability/old_style_comment"]
["src/nvim/window.c", ["    frp = curwin->w_frame->fr_next;", "  else      /* Swap last window in row/col with previous */", "    frp = curwin->w_frame->fr_prev;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* We can only exchange a window with another window, not with a frame", "   * containing windows. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["   * containing windows. */", "  if (frp == NULL || frp->fr_win == NULL || frp->fr_win == curwin)", "    return;"], "readability/braces"]
["src/nvim/window.c", ["", "  /*", "   * 1. remove curwin from the list. Remember after which window it was in wp2"], "readability/old_style_comment"]
["src/nvim/window.c", ["    win_append(wp2, wp);", "    if (frp2 == NULL)", "      frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame);"], "readability/braces"]
["src/nvim/window.c", ["      frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame);", "    else", "      frame_append(frp2, wp->w_frame);"], "readability/braces"]
["src/nvim/window.c", ["", "  /* If the windows are not in the same frame, exchange the sizes to avoid", "   * messing up the window layout.  Otherwise fix the frame sizes. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  (void)win_comp_pos();                 /* recompute window positions */", ""], "readability/old_style_comment"]
["src/nvim/window.c", ["  while (count--) {", "    if (upwards) {              /* first window becomes last window */", "      /* remove first window/frame from the list */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (upwards) {              /* first window becomes last window */", "      /* remove first window/frame from the list */", "      frp = curwin->w_frame->fr_parent->fr_child;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "      /* find last frame and append removed window/frame after it */", "      for (; frp->fr_next != NULL; frp = frp->fr_next)"], "readability/old_style_comment"]
["src/nvim/window.c", ["      /* find last frame and append removed window/frame after it */", "      for (; frp->fr_next != NULL; frp = frp->fr_next)", "        ;"], "readability/braces"]
["src/nvim/window.c", ["      for (; frp->fr_next != NULL; frp = frp->fr_next)", "        ;", "      win_append(frp->fr_win, wp1);"], "whitespace/semicolon"]
["src/nvim/window.c", ["", "      wp2 = frp->fr_win;                /* previously last window */", "    } else {                  /* last window becomes first window */"], "readability/old_style_comment"]
["src/nvim/window.c", ["      wp2 = frp->fr_win;                /* previously last window */", "    } else {                  /* last window becomes first window */", "      /* find last window/frame in the list and remove it */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    } else {                  /* last window becomes first window */", "      /* find last window/frame in the list and remove it */", "      for (frp = curwin->w_frame; frp->fr_next != NULL;"], "readability/old_style_comment"]
["src/nvim/window.c", ["      /* find last window/frame in the list and remove it */", "      for (frp = curwin->w_frame; frp->fr_next != NULL;", "           frp = frp->fr_next)"], "readability/braces"]
["src/nvim/window.c", ["           frp = frp->fr_next)", "        ;", "      wp1 = frp->fr_win;"], "whitespace/semicolon"]
["src/nvim/window.c", ["      wp1 = frp->fr_win;", "      wp2 = wp1->w_prev;                    /* will become last window */", "      win_remove(wp1, NULL);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "      /* append the removed window/frame before the first in the list */", "      win_append(frp->fr_parent->fr_child->fr_win->w_prev, wp1);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /* exchange status height and vsep width of old and new last window */", "    n = wp2->w_status_height;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /* recompute w_winrow and w_wincol for all windows */", "    (void)win_comp_pos();"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Move the current window to the very top/bottom/left/right of the screen."], "readability/old_style_comment"]
["src/nvim/window.c", ["  win_remove(curwin, NULL);", "  last_status(FALSE);       /* may need to remove last status line */", "  (void)win_comp_pos();     /* recompute window positions */"], "readability/old_style_comment"]
["src/nvim/window.c", ["  win_remove(curwin, NULL);", "  last_status(FALSE);       /* may need to remove last status line */", "  (void)win_comp_pos();     /* recompute window positions */"], "readability/bool"]
["src/nvim/window.c", ["  last_status(FALSE);       /* may need to remove last status line */", "  (void)win_comp_pos();     /* recompute window positions */", ""], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Split a window on the desired side and put the window there. */", "  (void)win_split_ins(size, flags, curwin, dir);"], "readability/old_style_comment"]
["src/nvim/window.c", ["    win_setheight(height);", "    if (p_ea)", "      win_equal(curwin, true, 'v');"], "readability/braces"]
["src/nvim/window.c", ["  }", "", "}"], "whitespace/blank_line"]
["src/nvim/window.c", ["", "/*", " * Move window \"win1\" to below/right of \"win2\" and make \"win1\" the current"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* check if the arguments are reasonable */", "  if (win1 == win2)"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* check if the arguments are reasonable */", "  if (win1 == win2)", "    return;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* check if there is something to do */", "  if (win2->w_next != win1) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (win2->w_next != win1) {", "    /* may need move the status line/vertical separator of the last window", "     * */"], "readability/old_style_comment"]
["src/nvim/window.c", ["      if (win1->w_prev->w_vsep_width == 1) {", "        /* Remove the vertical separator from the last-but-one window,", "         * add it to the last window.  Adjust the frame widths. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["      if (win1->w_vsep_width == 1) {", "        /* Remove the vertical separator from win1, add it to the last", "         * window, win2.  Adjust the frame widths. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Make all windows the same height."], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  if (dir == 0)", "    dir = *p_ead;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Set a frame to a new position and height, spreading the available room"], "readability/old_style_comment"]
["src/nvim/window.c", ["static void win_equal_rec(", "    win_T *next_curwin,       /* pointer to current window to be or NULL */", "    bool current,                    /* do only frame with current window */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    win_T *next_curwin,       /* pointer to current window to be or NULL */", "    bool current,                    /* do only frame with current window */", "    frame_T *topfr,             /* frame to set size off */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    bool current,                    /* do only frame with current window */", "    frame_T *topfr,             /* frame to set size off */", "    int dir,                        /* 'v', 'h' or 'b', see win_equal() */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    frame_T *topfr,             /* frame to set size off */", "    int dir,                        /* 'v', 'h' or 'b', see win_equal() */", "    int col,                        /* horizontal position for frame */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    int dir,                        /* 'v', 'h' or 'b', see win_equal() */", "    int col,                        /* horizontal position for frame */", "    int row,                        /* vertical position for frame */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    int col,                        /* horizontal position for frame */", "    int row,                        /* vertical position for frame */", "    int width,                      /* new width of frame */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    int row,                        /* vertical position for frame */", "    int width,                      /* new width of frame */", "    int height                     /* new height of frame */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    int width,                      /* new width of frame */", "    int height                     /* new height of frame */", ")"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (topfr->fr_layout == FR_LEAF) {", "    /* Set the width/height of this frame.", "     * Redraw when size or position changes */"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    if (dir != 'v') {                   /* equalize frame widths */", "      /* Compute the maximum number of windows horizontally in this"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (dir != 'v') {                   /* equalize frame widths */", "      /* Compute the maximum number of windows horizontally in this", "       * frame. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["      n = frame_minwidth(topfr, NOWIN);", "      /* add one for the rightmost window, it doesn't have a separator */", "      if (col + width == Columns)"], "readability/old_style_comment"]
["src/nvim/window.c", ["      /* add one for the rightmost window, it doesn't have a separator */", "      if (col + width == Columns)", "        extra_sep = 1;"], "readability/braces"]
["src/nvim/window.c", ["        extra_sep = 1;", "      else", "        extra_sep = 0;"], "readability/braces"]
["src/nvim/window.c", ["", "      /*", "       * Compute width for \"next_curwin\" window and room available for"], "readability/old_style_comment"]
["src/nvim/window.c", ["            next_curwin_size = 0;", "            if (new_size < p_wiw)", "              new_size = p_wiw;"], "readability/braces"]
["src/nvim/window.c", ["              new_size = p_wiw;", "          } else", "            /* These windows don't use up room. */"], "readability/braces"]
["src/nvim/window.c", ["          } else", "            /* These windows don't use up room. */", "            totwincount -= (n + (fr->fr_next == NULL"], "readability/old_style_comment"]
["src/nvim/window.c", ["        if (next_curwin_size == -1) {", "          if (!has_next_curwin)", "            next_curwin_size = 0;"], "readability/braces"]
["src/nvim/window.c", ["            next_curwin_size = 0;", "          else if (totwincount > 1", "                   && (room + (totwincount - 2))"], "readability/braces"]
["src/nvim/window.c", ["                   / (totwincount - 1) > p_wiw) {", "            /* Can make all windows wider than 'winwidth', spread", "             * the room equally. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["            room -= next_curwin_size - p_wiw;", "          } else", "            next_curwin_size = p_wiw;"], "readability/braces"]
["src/nvim/window.c", ["", "      if (has_next_curwin)", "        --totwincount;                  /* don't count curwin */"], "readability/braces"]
["src/nvim/window.c", ["      if (has_next_curwin)", "        --totwincount;                  /* don't count curwin */", "    }"], "readability/old_style_comment"]
["src/nvim/window.c", ["      if (has_next_curwin)", "        --totwincount;                  /* don't count curwin */", "    }"], "readability/increment"]
["src/nvim/window.c", ["      wincount = 1;", "      if (fr->fr_next == NULL)", "        /* last frame gets all that remains (avoid roundoff error) */"], "readability/braces"]
["src/nvim/window.c", ["      if (fr->fr_next == NULL)", "        /* last frame gets all that remains (avoid roundoff error) */", "        new_size = width;"], "readability/old_style_comment"]
["src/nvim/window.c", ["        new_size = width;", "      else if (dir == 'v')", "        new_size = fr->fr_width;"], "readability/braces"]
["src/nvim/window.c", ["        new_size = fr->fr_width;", "      else if (frame_fixed_width(fr)) {", "        new_size = fr->fr_newwidth;"], "readability/braces"]
["src/nvim/window.c", ["        new_size = fr->fr_newwidth;", "        wincount = 0;               /* doesn't count as a sizeable window */", "      } else {"], "readability/old_style_comment"]
["src/nvim/window.c", ["      } else {", "        /* Compute the maximum number of windows horiz. in \"fr\". */", "        n = frame_minwidth(fr, NOWIN);"], "readability/old_style_comment"]
["src/nvim/window.c", ["        m = frame_minwidth(fr, next_curwin);", "        if (has_next_curwin)", "          hnc = frame_has_win(fr, next_curwin);"], "readability/braces"]
["src/nvim/window.c", ["          hnc = frame_has_win(fr, next_curwin);", "        else", "          hnc = FALSE;"], "readability/braces"]
["src/nvim/window.c", ["        else", "          hnc = FALSE;", "        if (hnc)                    /* don't count next_curwin */"], "readability/bool"]
["src/nvim/window.c", ["          hnc = FALSE;", "        if (hnc)                    /* don't count next_curwin */", "          --wincount;"], "readability/old_style_comment"]
["src/nvim/window.c", ["          hnc = FALSE;", "        if (hnc)                    /* don't count next_curwin */", "          --wincount;"], "readability/braces"]
["src/nvim/window.c", ["        if (hnc)                    /* don't count next_curwin */", "          --wincount;", "        if (totwincount == 0)"], "readability/increment"]
["src/nvim/window.c", ["          --wincount;", "        if (totwincount == 0)", "          new_size = room;"], "readability/braces"]
["src/nvim/window.c", ["          new_size = room;", "        else", "          new_size = (wincount * room + (totwincount / 2)) / totwincount;"], "readability/braces"]
["src/nvim/window.c", ["          new_size = (wincount * room + (totwincount / 2)) / totwincount;", "        if (hnc) {                  /* add next_curwin size */", "          next_curwin_size -= p_wiw - (m - n);"], "readability/old_style_comment"]
["src/nvim/window.c", ["          room -= new_size - next_curwin_size;", "        } else", "          room -= new_size;"], "readability/braces"]
["src/nvim/window.c", ["", "      /* Skip frame that is full width when splitting or closing a", "       * window, unless equalizing all frames. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["       * window, unless equalizing all frames. */", "      if (!current || dir != 'v' || topfr->fr_parent != NULL", "          || (new_size != fr->fr_width)"], "readability/braces"]
["src/nvim/window.c", ["        win_equal_rec(next_curwin, current, fr, dir, col, row,", "            new_size, height);", "      col += new_size;"], "whitespace/alignment"]
["src/nvim/window.c", ["    }", "  } else { /* topfr->fr_layout == FR_COL */", "    topfr->fr_width = width;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    if (dir != 'h') {                   /* equalize frame heights */", "      /* Compute maximum number of windows vertically in this frame. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (dir != 'h') {                   /* equalize frame heights */", "      /* Compute maximum number of windows vertically in this frame. */", "      n = frame_minheight(topfr, NOWIN);"], "readability/old_style_comment"]
["src/nvim/window.c", ["      n = frame_minheight(topfr, NOWIN);", "      /* add one for the bottom window if it doesn't have a statusline */", "      if (row + height == cmdline_row && p_ls == 0)"], "readability/old_style_comment"]
["src/nvim/window.c", ["      /* add one for the bottom window if it doesn't have a statusline */", "      if (row + height == cmdline_row && p_ls == 0)", "        extra_sep = 1;"], "readability/braces"]
["src/nvim/window.c", ["        extra_sep = 1;", "      else", "        extra_sep = 0;"], "readability/braces"]
["src/nvim/window.c", ["", "      /*", "       * Compute height for \"next_curwin\" window and room available for"], "readability/old_style_comment"]
["src/nvim/window.c", ["      if (room < 0) {", "        /* The room is less then 'winheight', use all space for the", "         * current window. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["            next_curwin_size = 0;", "            if (new_size < p_wh)", "              new_size = p_wh;"], "readability/braces"]
["src/nvim/window.c", ["              new_size = p_wh;", "          } else", "            /* These windows don't use up room. */"], "readability/braces"]
["src/nvim/window.c", ["          } else", "            /* These windows don't use up room. */", "            totwincount -= (n + (fr->fr_next == NULL"], "readability/old_style_comment"]
["src/nvim/window.c", ["        if (next_curwin_size == -1) {", "          if (!has_next_curwin)", "            next_curwin_size = 0;"], "readability/braces"]
["src/nvim/window.c", ["            next_curwin_size = 0;", "          else if (totwincount > 1", "                   && (room + (totwincount - 2))"], "readability/braces"]
["src/nvim/window.c", ["                   / (totwincount - 1) > p_wh) {", "            /* can make all windows higher than 'winheight',", "             * spread the room equally. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["            room -= next_curwin_size - p_wh;", "          } else", "            next_curwin_size = p_wh;"], "readability/braces"]
["src/nvim/window.c", ["", "      if (has_next_curwin)", "        --totwincount;                  /* don't count curwin */"], "readability/braces"]
["src/nvim/window.c", ["      if (has_next_curwin)", "        --totwincount;                  /* don't count curwin */", "    }"], "readability/old_style_comment"]
["src/nvim/window.c", ["      if (has_next_curwin)", "        --totwincount;                  /* don't count curwin */", "    }"], "readability/increment"]
["src/nvim/window.c", ["      wincount = 1;", "      if (fr->fr_next == NULL)", "        /* last frame gets all that remains (avoid roundoff error) */"], "readability/braces"]
["src/nvim/window.c", ["      if (fr->fr_next == NULL)", "        /* last frame gets all that remains (avoid roundoff error) */", "        new_size = height;"], "readability/old_style_comment"]
["src/nvim/window.c", ["        new_size = height;", "      else if (dir == 'h')", "        new_size = fr->fr_height;"], "readability/braces"]
["src/nvim/window.c", ["        new_size = fr->fr_height;", "      else if (frame_fixed_height(fr)) {", "        new_size = fr->fr_newheight;"], "readability/braces"]
["src/nvim/window.c", ["        new_size = fr->fr_newheight;", "        wincount = 0;               /* doesn't count as a sizeable window */", "      } else {"], "readability/old_style_comment"]
["src/nvim/window.c", ["      } else {", "        /* Compute the maximum number of windows vert. in \"fr\". */", "        n = frame_minheight(fr, NOWIN);"], "readability/old_style_comment"]
["src/nvim/window.c", ["        m = frame_minheight(fr, next_curwin);", "        if (has_next_curwin)", "          hnc = frame_has_win(fr, next_curwin);"], "readability/braces"]
["src/nvim/window.c", ["          hnc = frame_has_win(fr, next_curwin);", "        else", "          hnc = FALSE;"], "readability/braces"]
["src/nvim/window.c", ["        else", "          hnc = FALSE;", "        if (hnc)                    /* don't count next_curwin */"], "readability/bool"]
["src/nvim/window.c", ["          hnc = FALSE;", "        if (hnc)                    /* don't count next_curwin */", "          --wincount;"], "readability/old_style_comment"]
["src/nvim/window.c", ["          hnc = FALSE;", "        if (hnc)                    /* don't count next_curwin */", "          --wincount;"], "readability/braces"]
["src/nvim/window.c", ["        if (hnc)                    /* don't count next_curwin */", "          --wincount;", "        if (totwincount == 0)"], "readability/increment"]
["src/nvim/window.c", ["          --wincount;", "        if (totwincount == 0)", "          new_size = room;"], "readability/braces"]
["src/nvim/window.c", ["          new_size = room;", "        else", "          new_size = (wincount * room + (totwincount / 2)) / totwincount;"], "readability/braces"]
["src/nvim/window.c", ["          new_size = (wincount * room + (totwincount / 2)) / totwincount;", "        if (hnc) {                  /* add next_curwin size */", "          next_curwin_size -= p_wh - (m - n);"], "readability/old_style_comment"]
["src/nvim/window.c", ["          room -= new_size - next_curwin_size;", "        } else", "          room -= new_size;"], "readability/braces"]
["src/nvim/window.c", ["      }", "      /* Skip frame that is full width when splitting or closing a", "       * window, unless equalizing all frames. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["       * window, unless equalizing all frames. */", "      if (!current || dir != 'h' || topfr->fr_parent != NULL", "          || (new_size != fr->fr_height)"], "readability/braces"]
["src/nvim/window.c", ["        win_equal_rec(next_curwin, current, fr, dir, col, row,", "            width, new_size);", "      row += new_size;"], "whitespace/alignment"]
["src/nvim/window.c", ["", "  ++RedrawingDisabled;", ""], "readability/increment"]
["src/nvim/window.c", ["", "      /* Start all over, autocommands may change the window layout. */", "      wp = firstwin;"], "readability/old_style_comment"]
["src/nvim/window.c", ["      wp = firstwin;", "    } else", "      wp = wp->w_next;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* Also check windows in other tab pages. */", "  for (tp = first_tabpage; tp != NULL; tp = nexttp) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "          /* Start all over, the tab page may be closed and", "           * autocommands may change the window layout. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  --RedrawingDisabled;", ""], "readability/increment"]
["src/nvim/window.c", ["", "  /*", "   * Closing the last window in a tab page.  First go to another tab"], "readability/old_style_comment"]
["src/nvim/window.c", ["   */", "  goto_tabpage_tp(alt_tabpage(), FALSE, TRUE);", "  redraw_tabline = TRUE;"], "readability/bool"]
["src/nvim/window.c", ["  goto_tabpage_tp(alt_tabpage(), FALSE, TRUE);", "  redraw_tabline = TRUE;", ""], "readability/bool"]
["src/nvim/window.c", ["  char_u prev_idx[NUMBUFLEN];", "  sprintf((char *)prev_idx, \"%i\", tabpage_index(prev_curtab));", ""], "runtime/printf"]
["src/nvim/window.c", ["", "  /* Safety check: Autocommands may have closed the window when jumping", "   * to the other tab page. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    win_close_othertab(win, free_buf, prev_curtab);", "    if (h != tabline_height())", "      shell_new_rows();"], "readability/braces"]
["src/nvim/window.c", ["  win_T       *wp;", "  int other_buffer = FALSE;", "  int close_curwin = FALSE;"], "readability/bool"]
["src/nvim/window.c", ["  int other_buffer = FALSE;", "  int close_curwin = FALSE;", "  int dir;"], "readability/bool"]
["src/nvim/window.c", ["", "  /* When closing the last window in a tab page first go to another tab page", "   * and then close the window and the tab page to avoid that curwin and"], "readability/old_style_comment"]
["src/nvim/window.c", ["   * curtab are invalid while we are freeing memory. */", "  if (close_last_window_tabpage(win, free_buf, prev_curtab))", "    return FAIL;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* When closing the help window, try restoring a snapshot after closing", "   * the window.  Otherwise clear the snapshot, it's now invalid. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (win == curwin) {", "    /*", "     * Guess which window is going to be the new current window."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /*", "     * Be careful: If autocommands delete the window or cause this window"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (wp->w_buffer != curbuf) {", "      other_buffer = TRUE;", "      win->w_closing = true;"], "readability/bool"]
["src/nvim/window.c", ["      win->w_closing = true;", "      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);", "      if (!win_valid(win))"], "readability/bool"]
["src/nvim/window.c", ["      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);", "      if (!win_valid(win))", "        return FAIL;"], "readability/braces"]
["src/nvim/window.c", ["      win->w_closing = false;", "      if (last_window())", "        return FAIL;"], "readability/braces"]
["src/nvim/window.c", ["    win->w_closing = false;", "    if (last_window())", "      return FAIL;"], "readability/braces"]
["src/nvim/window.c", ["      return FAIL;", "    /* autocmds may abort script processing */", "    if (aborting())"], "readability/old_style_comment"]
["src/nvim/window.c", ["    /* autocmds may abort script processing */", "    if (aborting())", "      return FAIL;"], "readability/braces"]
["src/nvim/window.c", ["", "  /*", "   * Close the link to the buffer."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Make sure curwin isn't invalid.  It can cause severe trouble when", "   * printing an error message.  For win_equal() curbuf needs to be valid"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (wp->w_p_pvw || bt_quickfix(wp->w_buffer)) {", "      /*", "       * If the cursor goes to the preview or the quickfix window, try"], "readability/old_style_comment"]
["src/nvim/window.c", ["      for (;; ) {", "        if (wp->w_next == NULL)", "          wp = firstwin;"], "readability/braces"]
["src/nvim/window.c", ["          wp = firstwin;", "        else", "          wp = wp->w_next;"], "readability/braces"]
["src/nvim/window.c", ["          wp = wp->w_next;", "        if (wp == curwin)", "          break;"], "readability/braces"]
["src/nvim/window.c", ["    curbuf = curwin->w_buffer;", "    close_curwin = TRUE;", ""], "readability/bool"]
["src/nvim/window.c", ["", "  /*", "   * If last window has a status line now and we don't want one,"], "readability/old_style_comment"]
["src/nvim/window.c", ["   */", "  last_status(FALSE);", ""], "readability/bool"]
["src/nvim/window.c", ["", "  /* After closing the help window, try restoring the window layout from", "   * before it was opened. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["   * before it was opened. */", "  if (help_window)", "    restore_snapshot(SNAP_HELP_IDX, close_curwin);"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Close window \"win\" in tab page \"tp\", which is not the current tab page."], "readability/old_style_comment"]
["src/nvim/window.c", ["  tabpage_T   *ptp = NULL;", "  int free_tp = FALSE;", ""], "readability/bool"]
["src/nvim/window.c", ["", "  /* Careful: Autocommands may have closed the tab page or made it the", "   * current tab page.  */"], "readability/old_style_comment"]
["src/nvim/window.c", ["   * current tab page.  */", "  for (ptp = first_tabpage; ptp != NULL && ptp != tp; ptp = ptp->tp_next)", "    ;"], "readability/braces"]
["src/nvim/window.c", ["  for (ptp = first_tabpage; ptp != NULL && ptp != tp; ptp = ptp->tp_next)", "    ;", "  if (ptp == NULL || tp == curtab)"], "whitespace/semicolon"]
["src/nvim/window.c", ["    ;", "  if (ptp == NULL || tp == curtab)", "    return;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* Autocommands may have closed the window already. */", "  {"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* When closing the last window in a tab page remove the tab page. */", "  if (tp->tp_firstwin == tp->tp_lastwin) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Free the memory used for the window. */", "  win_free_mem(win, &dir, tp);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  if (free_tp)", "    free_tabpage(tp);"], "readability/braces"]
["src/nvim/window.c", ["", "  while (first_tabpage->tp_next != NULL)", "    tabpage_close(TRUE);"], "readability/braces"]
["src/nvim/window.c", ["  while (first_tabpage->tp_next != NULL)", "    tabpage_close(TRUE);", ""], "readability/bool"]
["src/nvim/window.c", ["", "  while (firstwin != NULL)", "    (void)win_free_mem(firstwin, &dummy, NULL);"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Remove a window and its frame from the tree of frames."], "readability/old_style_comment"]
["src/nvim/window.c", ["win_T *", "winframe_remove (", "    win_T *win,"], "whitespace/parens"]
["src/nvim/window.c", ["    win_T *win,", "    int *dirp,       /* set to 'v' or 'h' for direction if 'ea' */", "    tabpage_T *tp                /* tab page \"win\" is in, NULL for current */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    int *dirp,       /* set to 'v' or 'h' for direction if 'ea' */", "    tabpage_T *tp                /* tab page \"win\" is in, NULL for current */", ")"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /*", "   * If there is only one window there is nothing to remove."], "readability/old_style_comment"]
["src/nvim/window.c", ["   */", "  if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)", "    return NULL;"], "readability/braces"]
["src/nvim/window.c", ["", "  /*", "   * Remove the window from its frame."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Remove this frame from the list of frames. */", "  frame_remove(frp_close);"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (frp_close->fr_parent->fr_layout == FR_COL) {", "    /* When 'winfixheight' is set, try to find another frame in the column", "     * (as close to the closed frame as possible) to distribute the height"], "readability/old_style_comment"]
["src/nvim/window.c", ["    frame_new_height(frp2, frp2->fr_height + frp_close->fr_height,", "        frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);", "    *dirp = 'v';"], "whitespace/alignment"]
["src/nvim/window.c", ["    frame_new_height(frp2, frp2->fr_height + frp_close->fr_height,", "        frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);", "    *dirp = 'v';"], "readability/bool"]
["src/nvim/window.c", ["  } else {", "    /* When 'winfixwidth' is set, try to find another frame in the column", "     * (as close to the closed frame as possible) to distribute the width"], "readability/old_style_comment"]
["src/nvim/window.c", ["    frame_new_width(frp2, frp2->fr_width + frp_close->fr_width,", "        frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);", "    *dirp = 'h';"], "whitespace/alignment"]
["src/nvim/window.c", ["    frame_new_width(frp2, frp2->fr_width + frp_close->fr_width,", "        frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);", "    *dirp = 'h';"], "readability/bool"]
["src/nvim/window.c", ["", "  /* If rows/columns go to a window below/right its positions need to be", "   * updated.  Can only be done after the sizes have been updated. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (frp2->fr_next == NULL && frp2->fr_prev == NULL) {", "    /* There is no other frame in this list, move its info to the parent", "     * and remove it. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    frp2->fr_parent->fr_win = frp2->fr_win;", "    if (frp2->fr_win != NULL)", "      frp2->fr_win->w_frame = frp2->fr_parent;"], "readability/braces"]
["src/nvim/window.c", ["    if (frp2 != NULL && frp2->fr_layout == frp->fr_layout) {", "      /* The frame above the parent has the same layout, have to merge", "       * the frames into this list. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["       * the frames into this list. */", "      if (frp2->fr_child == frp)", "        frp2->fr_child = frp->fr_child;"], "readability/braces"]
["src/nvim/window.c", ["      frp->fr_child->fr_prev = frp->fr_prev;", "      if (frp->fr_prev != NULL)", "        frp->fr_prev->fr_next = frp->fr_child;"], "readability/braces"]
["src/nvim/window.c", ["          frp3->fr_next = frp->fr_next;", "          if (frp->fr_next != NULL)", "            frp->fr_next->fr_prev = frp3;"], "readability/braces"]
["src/nvim/window.c", ["static frame_T *", "win_altframe (", "    win_T *win,"], "whitespace/parens"]
["src/nvim/window.c", ["    win_T *win,", "    tabpage_T *tp                /* tab page \"win\" is in, NULL for current */", ")"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Return the tabpage that will be used if the current one is closed."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Use the next tab page if possible. */", "  if (curtab->tp_next != NULL)"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* Use the next tab page if possible. */", "  if (curtab->tp_next != NULL)", "    return curtab->tp_next;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* Find the last but one tab page. */", "  for (tp = first_tabpage; tp->tp_next != curtab; tp = tp->tp_next)"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* Find the last but one tab page. */", "  for (tp = first_tabpage; tp->tp_next != curtab; tp = tp->tp_next)", "    ;"], "readability/braces"]
["src/nvim/window.c", ["  for (tp = first_tabpage; tp->tp_next != curtab; tp = tp->tp_next)", "    ;", "  return tp;"], "whitespace/semicolon"]
["src/nvim/window.c", ["", "/*", " * Find the left-upper window in frame \"frp\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  while (frp->fr_win == NULL)", "    frp = frp->fr_child;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Set a new height for a frame.  Recursively sets the height for contained"], "readability/old_style_comment"]
["src/nvim/window.c", [" */", "static void ", "frame_new_height ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["static void ", "frame_new_height (", "    frame_T *topfrp,"], "whitespace/parens"]
["src/nvim/window.c", ["    int wfh                        /* obey 'winfixheight' when there is a choice;", "                                   may cause the height not to be set */", ")"], "whitespace/indent"]
["src/nvim/window.c", ["    int height,", "    int topfirst,                   /* resize topmost contained frame first */", "    int wfh                        /* obey 'winfixheight' when there is a choice;"], "readability/old_style_comment"]
["src/nvim/window.c", ["    int topfirst,                   /* resize topmost contained frame first */", "    int wfh                        /* obey 'winfixheight' when there is a choice;", "                                   may cause the height not to be set */"], "readability/multiline_comment"]
["src/nvim/window.c", ["    int topfirst,                   /* resize topmost contained frame first */", "    int wfh                        /* obey 'winfixheight' when there is a choice;", "                                   may cause the height not to be set */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    int topfirst,                   /* resize topmost contained frame first */", "    int wfh                        /* obey 'winfixheight' when there is a choice;", "                                   may cause the height not to be set */"], "whitespace/line_length"]
["src/nvim/window.c", ["        if (frp->fr_height > height) {", "          /* Could not fit the windows, make the whole row higher. */", "          height = frp->fr_height;"], "readability/old_style_comment"]
["src/nvim/window.c", ["    } while (frp != NULL);", "  } else { /* fr_layout == FR_COL */", "    /* Complicated case: Resize a column of frames.  Resize the bottom"], "readability/old_style_comment"]
["src/nvim/window.c", ["  } else { /* fr_layout == FR_COL */", "    /* Complicated case: Resize a column of frames.  Resize the bottom", "     * frame first, frames above that when needed. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    frp = topfrp->fr_child;", "    if (wfh)", "      /* Advance past frames with one window with 'wfh' set. */"], "readability/braces"]
["src/nvim/window.c", ["    if (wfh)", "      /* Advance past frames with one window with 'wfh' set. */", "      while (frame_fixed_height(frp)) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["        frp = frp->fr_next;", "        if (frp == NULL)", "          return;                   /* no frame without 'wfh', give up */"], "readability/braces"]
["src/nvim/window.c", ["        if (frp == NULL)", "          return;                   /* no frame without 'wfh', give up */", "      }"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (!topfirst) {", "      /* Find the bottom frame of this column */", "      while (frp->fr_next != NULL)"], "readability/old_style_comment"]
["src/nvim/window.c", ["      /* Find the bottom frame of this column */", "      while (frp->fr_next != NULL)", "        frp = frp->fr_next;"], "readability/braces"]
["src/nvim/window.c", ["        frp = frp->fr_next;", "      if (wfh)", "        /* Advance back for frames with one window with 'wfh' set. */"], "readability/braces"]
["src/nvim/window.c", ["      if (wfh)", "        /* Advance back for frames with one window with 'wfh' set. */", "        while (frame_fixed_height(frp))"], "readability/old_style_comment"]
["src/nvim/window.c", ["        /* Advance back for frames with one window with 'wfh' set. */", "        while (frame_fixed_height(frp))", "          frp = frp->fr_prev;"], "readability/braces"]
["src/nvim/window.c", ["    if (extra_lines < 0) {", "      /* reduce height of contained frames, bottom or top frame first */", "      while (frp != NULL) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["          frame_new_height(frp, frp->fr_height + extra_lines,", "              topfirst, wfh);", "          break;"], "whitespace/alignment"]
["src/nvim/window.c", ["            frp = frp->fr_next;", "          while (wfh && frp != NULL && frame_fixed_height(frp));", "        } else {"], "readability/braces"]
["src/nvim/window.c", ["            frp = frp->fr_next;", "          while (wfh && frp != NULL && frame_fixed_height(frp));", "        } else {"], "whitespace/empty_loop_body"]
["src/nvim/window.c", ["            frp = frp->fr_prev;", "          while (wfh && frp != NULL && frame_fixed_height(frp));", "        }"], "readability/braces"]
["src/nvim/window.c", ["            frp = frp->fr_prev;", "          while (wfh && frp != NULL && frame_fixed_height(frp));", "        }"], "whitespace/empty_loop_body"]
["src/nvim/window.c", ["        }", "        /* Increase \"height\" if we could not reduce enough frames. */", "        if (frp == NULL)"], "readability/old_style_comment"]
["src/nvim/window.c", ["        /* Increase \"height\" if we could not reduce enough frames. */", "        if (frp == NULL)", "          height -= extra_lines;"], "readability/braces"]
["src/nvim/window.c", ["    } else if (extra_lines > 0) {", "      /* increase height of bottom or top frame */", "      frame_new_height(frp, frp->fr_height + extra_lines, topfirst, wfh);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Add a status line to windows at the bottom of \"frp\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (wp->w_status_height == 0) {", "      if (wp->w_height > 0)             /* don't make it negative */", "        --wp->w_height;"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (wp->w_status_height == 0) {", "      if (wp->w_height > 0)             /* don't make it negative */", "        --wp->w_height;"], "readability/braces"]
["src/nvim/window.c", ["      if (wp->w_height > 0)             /* don't make it negative */", "        --wp->w_height;", "      wp->w_status_height = STATUS_HEIGHT;"], "readability/increment"]
["src/nvim/window.c", ["", "/*", " * Set width of a frame.  Handles recursively going through contained frames."], "readability/old_style_comment"]
["src/nvim/window.c", [" */", "static void ", "frame_new_width ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["static void ", "frame_new_width (", "    frame_T *topfrp,"], "whitespace/parens"]
["src/nvim/window.c", ["    int wfw                        /* obey 'winfixwidth' when there is a choice;", "                                   may cause the width not to be set */", ")"], "whitespace/indent"]
["src/nvim/window.c", ["    int width,", "    int leftfirst,                  /* resize leftmost contained frame first */", "    int wfw                        /* obey 'winfixwidth' when there is a choice;"], "readability/old_style_comment"]
["src/nvim/window.c", ["    int leftfirst,                  /* resize leftmost contained frame first */", "    int wfw                        /* obey 'winfixwidth' when there is a choice;", "                                   may cause the width not to be set */"], "readability/multiline_comment"]
["src/nvim/window.c", ["    int leftfirst,                  /* resize leftmost contained frame first */", "    int wfw                        /* obey 'winfixwidth' when there is a choice;", "                                   may cause the width not to be set */"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (topfrp->fr_layout == FR_LEAF) {", "    /* Simple case: just one window. */", "    wp = topfrp->fr_win;"], "readability/old_style_comment"]
["src/nvim/window.c", ["    wp = topfrp->fr_win;", "    /* Find out if there are any windows right of this one. */", "    for (frp = topfrp; frp->fr_parent != NULL; frp = frp->fr_parent)"], "readability/old_style_comment"]
["src/nvim/window.c", ["    /* Find out if there are any windows right of this one. */", "    for (frp = topfrp; frp->fr_parent != NULL; frp = frp->fr_parent)", "      if (frp->fr_parent->fr_layout == FR_ROW && frp->fr_next != NULL)"], "readability/braces"]
["src/nvim/window.c", ["    for (frp = topfrp; frp->fr_parent != NULL; frp = frp->fr_parent)", "      if (frp->fr_parent->fr_layout == FR_ROW && frp->fr_next != NULL)", "        break;"], "readability/braces"]
["src/nvim/window.c", ["        break;", "    if (frp->fr_parent == NULL)", "      wp->w_vsep_width = 0;"], "readability/braces"]
["src/nvim/window.c", ["        if (frp->fr_width > width) {", "          /* Could not fit the windows, make whole column wider. */", "          width = frp->fr_width;"], "readability/old_style_comment"]
["src/nvim/window.c", ["    } while (frp != NULL);", "  } else { /* fr_layout == FR_ROW */", "    /* Complicated case: Resize a row of frames.  Resize the rightmost"], "readability/old_style_comment"]
["src/nvim/window.c", ["  } else { /* fr_layout == FR_ROW */", "    /* Complicated case: Resize a row of frames.  Resize the rightmost", "     * frame first, frames left of it when needed. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    frp = topfrp->fr_child;", "    if (wfw)", "      /* Advance past frames with one window with 'wfw' set. */"], "readability/braces"]
["src/nvim/window.c", ["    if (wfw)", "      /* Advance past frames with one window with 'wfw' set. */", "      while (frame_fixed_width(frp)) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["        frp = frp->fr_next;", "        if (frp == NULL)", "          return;                   /* no frame without 'wfw', give up */"], "readability/braces"]
["src/nvim/window.c", ["        if (frp == NULL)", "          return;                   /* no frame without 'wfw', give up */", "      }"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (!leftfirst) {", "      /* Find the rightmost frame of this row */", "      while (frp->fr_next != NULL)"], "readability/old_style_comment"]
["src/nvim/window.c", ["      /* Find the rightmost frame of this row */", "      while (frp->fr_next != NULL)", "        frp = frp->fr_next;"], "readability/braces"]
["src/nvim/window.c", ["        frp = frp->fr_next;", "      if (wfw)", "        /* Advance back for frames with one window with 'wfw' set. */"], "readability/braces"]
["src/nvim/window.c", ["      if (wfw)", "        /* Advance back for frames with one window with 'wfw' set. */", "        while (frame_fixed_width(frp))"], "readability/old_style_comment"]
["src/nvim/window.c", ["        /* Advance back for frames with one window with 'wfw' set. */", "        while (frame_fixed_width(frp))", "          frp = frp->fr_prev;"], "readability/braces"]
["src/nvim/window.c", ["    if (extra_cols < 0) {", "      /* reduce frame width, rightmost frame first */", "      while (frp != NULL) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["          frame_new_width(frp, frp->fr_width + extra_cols,", "              leftfirst, wfw);", "          break;"], "whitespace/alignment"]
["src/nvim/window.c", ["            frp = frp->fr_next;", "          while (wfw && frp != NULL && frame_fixed_width(frp));", "        } else {"], "readability/braces"]
["src/nvim/window.c", ["            frp = frp->fr_next;", "          while (wfw && frp != NULL && frame_fixed_width(frp));", "        } else {"], "whitespace/empty_loop_body"]
["src/nvim/window.c", ["            frp = frp->fr_prev;", "          while (wfw && frp != NULL && frame_fixed_width(frp));", "        }"], "readability/braces"]
["src/nvim/window.c", ["            frp = frp->fr_prev;", "          while (wfw && frp != NULL && frame_fixed_width(frp));", "        }"], "whitespace/empty_loop_body"]
["src/nvim/window.c", ["        }", "        /* Increase \"width\" if we could not reduce enough frames. */", "        if (frp == NULL)"], "readability/old_style_comment"]
["src/nvim/window.c", ["        /* Increase \"width\" if we could not reduce enough frames. */", "        if (frp == NULL)", "          width -= extra_cols;"], "readability/braces"]
["src/nvim/window.c", ["    } else if (extra_cols > 0) {", "      /* increase width of rightmost frame */", "      frame_new_width(frp, frp->fr_width + extra_cols, leftfirst, wfw);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Add the vertical separator to windows at the right side of \"frp\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (wp->w_vsep_width == 0) {", "      if (wp->w_width > 0)              /* don't make it negative */", "        --wp->w_width;"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (wp->w_vsep_width == 0) {", "      if (wp->w_width > 0)              /* don't make it negative */", "        --wp->w_width;"], "readability/braces"]
["src/nvim/window.c", ["      if (wp->w_width > 0)              /* don't make it negative */", "        --wp->w_width;", "      wp->w_vsep_width = 1;"], "readability/increment"]
["src/nvim/window.c", ["    frp = frp->fr_child;", "    while (frp->fr_next != NULL)", "      frp = frp->fr_next;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Set frame width from the window it contains."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Set frame height from the window it contains."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Compute the minimal height for frame \"topfrp\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["  } else if (topfrp->fr_layout == FR_ROW) {", "    /* get the minimal height from each frame in this row */", "    m = 0;"], "readability/old_style_comment"]
["src/nvim/window.c", ["      n = frame_minheight(frp, next_curwin);", "      if (n > m)", "        m = n;"], "readability/braces"]
["src/nvim/window.c", ["  } else {", "    /* Add up the minimal heights for all frames in this column. */", "    m = 0;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Compute the minimal width for frame \"topfrp\"."], "readability/old_style_comment"]
["src/nvim/window.c", [" */", "static int ", "frame_minwidth ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["static int ", "frame_minwidth (", "    frame_T *topfrp,"], "whitespace/parens"]
["src/nvim/window.c", ["    frame_T *topfrp,", "    win_T *next_curwin       /* use p_wh and p_wiw for next_curwin */", ")"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (topfrp->fr_win != NULL) {", "    if (topfrp->fr_win == next_curwin)", "      m = p_wiw + topfrp->fr_win->w_vsep_width;"], "readability/braces"]
["src/nvim/window.c", ["      m = p_wiw + topfrp->fr_win->w_vsep_width;", "    else {", "      /* window: minimal width of the window plus separator column */"], "readability/braces"]
["src/nvim/window.c", ["      m = p_wiw + topfrp->fr_win->w_vsep_width;", "    else {", "      /* window: minimal width of the window plus separator column */"], "readability/braces"]
["src/nvim/window.c", ["    else {", "      /* window: minimal width of the window plus separator column */", "      m = p_wmw + topfrp->fr_win->w_vsep_width;"], "readability/old_style_comment"]
["src/nvim/window.c", ["      m = p_wmw + topfrp->fr_win->w_vsep_width;", "      /* Current window is minimal one column wide */", "      if (p_wmw == 0 && topfrp->fr_win == curwin && next_curwin == NULL)"], "readability/old_style_comment"]
["src/nvim/window.c", ["      /* Current window is minimal one column wide */", "      if (p_wmw == 0 && topfrp->fr_win == curwin && next_curwin == NULL)", "        ++m;"], "readability/braces"]
["src/nvim/window.c", ["      if (p_wmw == 0 && topfrp->fr_win == curwin && next_curwin == NULL)", "        ++m;", "    }"], "readability/increment"]
["src/nvim/window.c", ["  } else if (topfrp->fr_layout == FR_COL) {", "    /* get the minimal width from each frame in this column */", "    m = 0;"], "readability/old_style_comment"]
["src/nvim/window.c", ["      n = frame_minwidth(frp, next_curwin);", "      if (n > m)", "        m = n;"], "readability/braces"]
["src/nvim/window.c", ["  } else {", "    /* Add up the minimal widths for all frames in this row. */", "    m = 0;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Try to close all windows except current one."], "readability/old_style_comment"]
["src/nvim/window.c", [" */", "void ", "close_others ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["void ", "close_others (", "    int message,"], "whitespace/parens"]
["src/nvim/window.c", ["    int message,", "    int forceit                        /* always hide all other windows */", ")"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Be very careful here: autocommands may change the window layout. */", "  for (wp = firstwin; win_valid(wp); wp = nextwp) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["    nextwp = wp->w_next;", "    if (wp == curwin) {                 /* don't close current window */", "      continue;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /* Check if it's allowed to abandon this window */", "    r = can_abandon(wp->w_buffer, forceit);"], "readability/old_style_comment"]
["src/nvim/window.c", ["    r = can_abandon(wp->w_buffer, forceit);", "    if (!win_valid(wp)) {             /* autocommands messed wp up */", "      nextwp = firstwin;"], "readability/old_style_comment"]
["src/nvim/window.c", ["      }", "      if (bufIsChanged(wp->w_buffer))", "        continue;"], "readability/braces"]
["src/nvim/window.c", ["", "  if (message && !ONE_WINDOW)", "    EMSG(_(\"E445: Other window contains changes\"));"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Init the current window \"curwin\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["  wp->w_cursor.coladd = 0;", "  wp->w_pcmark.lnum = 1;        /* pcmark not cleared but set to line 1 */", "  wp->w_pcmark.col = 0;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Allocate the first window and put an empty buffer in it."], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  if (win_alloc_firstwin(NULL) == FAIL)", "    return FAIL;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Allocate the first window or the first window in a new tab page."], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  curwin = win_alloc(NULL, FALSE);", "  if (oldwin == NULL) {"], "readability/bool"]
["src/nvim/window.c", ["  if (oldwin == NULL) {", "    /* Very first window, need to create an empty buffer for it and", "     * initialize from scratch. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    curwin->w_s = &(curbuf->b_s);", "    curbuf->b_nwindows = 1;     /* there is one window */", "    curwin->w_alist = &global_alist;"], "readability/old_style_comment"]
["src/nvim/window.c", ["    curwin->w_alist = &global_alist;", "    curwin_init();              /* init current window */", "  } else {"], "readability/old_style_comment"]
["src/nvim/window.c", ["  } else {", "    /* First window in new tab page, initialize it from \"oldwin\". */", "    win_init(curwin, oldwin, 0);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /* We don't want cursor- and scroll-binding in the first window. */", "    RESET_BINDING(curwin);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Create a frame for window \"wp\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Initialize the window and frame size to the maximum."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Allocate a new tabpage_T and init the values."], "readability/old_style_comment"]
["src/nvim/window.c", ["  init_var_dict(tp->tp_vars, &tp->tp_winvar, VAR_SCOPE);", "  tp->tp_diff_invalid = TRUE;", "  tp->tp_ch_used = p_ch;"], "readability/bool"]
["src/nvim/window.c", ["  diff_clear(tp);", "  for (idx = 0; idx < SNAP_COUNT; ++idx)", "    clear_snapshot(tp, idx);"], "readability/braces"]
["src/nvim/window.c", ["  diff_clear(tp);", "  for (idx = 0; idx < SNAP_COUNT; ++idx)", "    clear_snapshot(tp, idx);"], "readability/increment"]
["src/nvim/window.c", ["    clear_snapshot(tp, idx);", "  vars_clear(&tp->tp_vars->dv_hashtab);         /* free all t: variables */", "  hash_init(&tp->tp_vars->dv_hashtab);"], "readability/old_style_comment"]
["src/nvim/window.c", ["        n = 2;", "        for (tp = first_tabpage; tp->tp_next != NULL", "             && n < after; tp = tp->tp_next)"], "readability/braces"]
["src/nvim/window.c", ["             && n < after; tp = tp->tp_next)", "          ++n;", "      }"], "readability/increment"]
["src/nvim/window.c", ["", "/*", " * Open a new tab page if \":tab cmd\" was used.  It will edit the same buffer,"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (n != 0) {", "    cmdmod.tab = 0;         /* reset it to avoid doing it twice */", "    postponed_split_tab = 0;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Create up to \"maxcount\" tabpages with empty windows."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Limit to 'tabpagemax' tabs. */", "  if (count > p_tpm)"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* Limit to 'tabpagemax' tabs. */", "  if (count > p_tpm)", "    count = p_tpm;"], "readability/braces"]
["src/nvim/window.c", ["", "  /*", "   * Don't execute autocommands while creating the tab pages.  Must do that"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  for (todo = count - 1; todo > 0; --todo) {", "    if (win_new_tabpage(0, NULL) == FAIL) {"], "readability/increment"]
["src/nvim/window.c", ["", "  /* return actual number of tab pages */", "  return count - todo;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Find tab page \"n\" (first one is 1).  Returns NULL when not found."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  for (tp = first_tabpage; tp != NULL && i != n; tp = tp->tp_next)", "    ++i;"], "readability/braces"]
["src/nvim/window.c", ["  for (tp = first_tabpage; tp != NULL && i != n; tp = tp->tp_next)", "    ++i;", "  return tp;"], "readability/increment"]
["src/nvim/window.c", ["", "/*", " * Get index of tab page \"tp\".  First one has index 1."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  for (tp = first_tabpage; tp != NULL && tp != ftp; tp = tp->tp_next)", "    ++i;"], "readability/braces"]
["src/nvim/window.c", ["  for (tp = first_tabpage; tp != NULL && tp != ftp; tp = tp->tp_next)", "    ++i;", "  return i;"], "readability/increment"]
["src/nvim/window.c", ["", "/*", " * Prepare for leaving the current tab page."], "readability/old_style_comment"]
["src/nvim/window.c", [" */", "static int ", "leave_tabpage ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["static int ", "leave_tabpage (", "    buf_T *new_curbuf,        /* what is going to be the new curbuf,"], "whitespace/parens"]
["src/nvim/window.c", ["    buf_T *new_curbuf,        /* what is going to be the new curbuf,", "                                          NULL if unknown */", "    int trigger_leave_autocmds"], "whitespace/indent"]
["src/nvim/window.c", ["leave_tabpage (", "    buf_T *new_curbuf,        /* what is going to be the new curbuf,", "                                          NULL if unknown */"], "readability/multiline_comment"]
["src/nvim/window.c", ["leave_tabpage (", "    buf_T *new_curbuf,        /* what is going to be the new curbuf,", "                                          NULL if unknown */"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  reset_VIsual_and_resel();     /* stop Visual mode */", "  if (trigger_leave_autocmds) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (new_curbuf != curbuf) {", "      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);", "      if (curtab != tp)"], "readability/bool"]
["src/nvim/window.c", ["      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);", "      if (curtab != tp)", "        return FAIL;"], "readability/braces"]
["src/nvim/window.c", ["    }", "    apply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);", "    if (curtab != tp)"], "readability/bool"]
["src/nvim/window.c", ["    apply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);", "    if (curtab != tp)", "      return FAIL;"], "readability/braces"]
["src/nvim/window.c", ["      return FAIL;", "    apply_autocmds(EVENT_TABLEAVE, NULL, NULL, FALSE, curbuf);", "    if (curtab != tp)"], "readability/bool"]
["src/nvim/window.c", ["    apply_autocmds(EVENT_TABLEAVE, NULL, NULL, FALSE, curbuf);", "    if (curtab != tp)", "      return FAIL;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Start using tab page \"tp\"."], "readability/old_style_comment"]
["src/nvim/window.c", [" */", "static void enter_tabpage(tabpage_T *tp, buf_T *old_curbuf, int trigger_enter_autocmds, int trigger_leave_autocmds)", "{"], "whitespace/line_length"]
["src/nvim/window.c", ["", "  /* We would like doing the TabEnter event first, but we don't have a", "   * valid current window yet, which may break some commands."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* The tabpage line may have appeared or disappeared, may need to resize", "   * the frames for that.  When the Vim window was resized need to update"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Apply autocommands after updating the display, when 'rows' and", "   * 'columns' have been set correctly. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (trigger_enter_autocmds) {", "    apply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);", "    if (old_curbuf != curbuf)"], "readability/bool"]
["src/nvim/window.c", ["    apply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);", "    if (old_curbuf != curbuf)", "      apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);"], "readability/braces"]
["src/nvim/window.c", ["    if (old_curbuf != curbuf)", "      apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);", "  }"], "readability/bool"]
["src/nvim/window.c", ["", "/*", " * Go to tab page \"n\".  For \":tab N\" and \"Ngt\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* If there is only one it can't work. */", "  if (first_tabpage->tp_next == NULL) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (first_tabpage->tp_next == NULL) {", "    if (n > 1)", "      beep_flush();"], "readability/braces"]
["src/nvim/window.c", ["  if (n == 0) {", "    /* No count, go to next tab page, wrap around end. */", "    if (curtab->tp_next == NULL)"], "readability/old_style_comment"]
["src/nvim/window.c", ["    /* No count, go to next tab page, wrap around end. */", "    if (curtab->tp_next == NULL)", "      tp = first_tabpage;"], "readability/braces"]
["src/nvim/window.c", ["      tp = first_tabpage;", "    else", "      tp = curtab->tp_next;"], "readability/braces"]
["src/nvim/window.c", ["  } else if (n < 0) {", "    /* \"gT\": go to previous tab page, wrap around end.  \"N gT\" repeats", "     * this N times. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    ttp = curtab;", "    for (i = n; i < 0; ++i) {", "      for (tp = first_tabpage; tp->tp_next != ttp && tp->tp_next != NULL;"], "readability/increment"]
["src/nvim/window.c", ["    for (i = n; i < 0; ++i) {", "      for (tp = first_tabpage; tp->tp_next != ttp && tp->tp_next != NULL;", "           tp = tp->tp_next)"], "readability/braces"]
["src/nvim/window.c", ["           tp = tp->tp_next)", "        ;", "      ttp = tp;"], "whitespace/semicolon"]
["src/nvim/window.c", ["  } else if (n == 9999) {", "    /* Go to last tab page. */", "    for (tp = first_tabpage; tp->tp_next != NULL; tp = tp->tp_next)"], "readability/old_style_comment"]
["src/nvim/window.c", ["    /* Go to last tab page. */", "    for (tp = first_tabpage; tp->tp_next != NULL; tp = tp->tp_next)", "      ;"], "readability/braces"]
["src/nvim/window.c", ["    for (tp = first_tabpage; tp->tp_next != NULL; tp = tp->tp_next)", "      ;", "  } else {"], "whitespace/semicolon"]
["src/nvim/window.c", ["  } else {", "    /* Go to tab page \"n\". */", "    tp = find_tabpage(n);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  goto_tabpage_tp(tp, TRUE, TRUE);", ""], "readability/bool"]
["src/nvim/window.c", ["  goto_tabpage_tp(tp, TRUE, TRUE);", "", "}"], "whitespace/blank_line"]
["src/nvim/window.c", ["", "/*", " * Go to tabpage \"tp\"."], "readability/old_style_comment"]
["src/nvim/window.c", [" */", "void goto_tabpage_tp(tabpage_T *tp, int trigger_enter_autocmds, int trigger_leave_autocmds)", "{"], "whitespace/line_length"]
["src/nvim/window.c", ["{", "  /* Don't repeat a message in another tab page. */", "  set_keep_msg(NULL, 0);"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (tp != curtab && leave_tabpage(tp->tp_curwin->w_buffer,", "          trigger_leave_autocmds) == OK) {", "    if (valid_tabpage(tp))"], "whitespace/alignment"]
["src/nvim/window.c", ["          trigger_leave_autocmds) == OK) {", "    if (valid_tabpage(tp))", "      enter_tabpage(tp, curbuf, trigger_enter_autocmds,"], "readability/braces"]
["src/nvim/window.c", ["      enter_tabpage(tp, curbuf, trigger_enter_autocmds,", "          trigger_leave_autocmds);", "    else"], "whitespace/alignment"]
["src/nvim/window.c", ["          trigger_leave_autocmds);", "    else", "      enter_tabpage(curtab, curbuf, trigger_enter_autocmds,"], "readability/braces"]
["src/nvim/window.c", ["      enter_tabpage(curtab, curbuf, trigger_enter_autocmds,", "          trigger_leave_autocmds);", "  }"], "whitespace/alignment"]
["src/nvim/window.c", ["", "/*", " * Enter window \"wp\" in tab page \"tp\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  goto_tabpage_tp(tp, TRUE, TRUE);", "  if (curtab == tp && win_valid(wp)) {"], "readability/bool"]
["src/nvim/window.c", ["  for (tp = first_tabpage; tp->tp_next != NULL && n < nr; tp = tp->tp_next) {", "    ++n;", "  }"], "readability/increment"]
["src/nvim/window.c", ["", "  /* Need to redraw the tabline.  Tab page contents doesn't change. */", "  redraw_tabline = TRUE;"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* Need to redraw the tabline.  Tab page contents doesn't change. */", "  redraw_tabline = TRUE;", "}"], "readability/bool"]
["src/nvim/window.c", ["", "/*", " * Go to another window."], "readability/old_style_comment"]
["src/nvim/window.c", ["  }", "  if (curbuf_locked())", "    return;"], "readability/braces"]
["src/nvim/window.c", ["", "  if (wp->w_buffer != curbuf)", "    reset_VIsual_and_resel();"], "readability/braces"]
["src/nvim/window.c", ["    reset_VIsual_and_resel();", "  else if (VIsual_active)", "    wp->w_cursor = curwin->w_cursor;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Find the tabpage for window \"win\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["  while (count--) {", "    /*", "     * First go upwards in the tree of frames until we find an upwards or"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /*", "     * Now go downwards to find the bottom or top frame in it."], "readability/old_style_comment"]
["src/nvim/window.c", ["      }", "      if (nfr->fr_layout == FR_COL && up)", "        while (fr->fr_next != NULL)"], "readability/braces"]
["src/nvim/window.c", ["      if (nfr->fr_layout == FR_COL && up)", "        while (fr->fr_next != NULL)", "          fr = fr->fr_next;"], "readability/braces"]
["src/nvim/window.c", ["  while (count--) {", "    /*", "     * First go upwards in the tree of frames until we find a left or"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /*", "     * Now go downwards to find the leftmost or rightmost frame in it."], "readability/old_style_comment"]
["src/nvim/window.c", ["      if (nfr->fr_layout == FR_COL) {", "        /* Find the frame at the cursor row. */", "        while (fr->fr_next != NULL"], "readability/old_style_comment"]
["src/nvim/window.c", ["        /* Find the frame at the cursor row. */", "        while (fr->fr_next != NULL", "               && frame2win(fr)->w_winrow + fr->fr_height"], "readability/braces"]
["src/nvim/window.c", ["      }", "      if (nfr->fr_layout == FR_ROW && left)", "        while (fr->fr_next != NULL)"], "readability/braces"]
["src/nvim/window.c", ["      if (nfr->fr_layout == FR_ROW && left)", "        while (fr->fr_next != NULL)", "          fr = fr->fr_next;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Make window wp the current window."], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  int other_buffer = FALSE;", ""], "readability/bool"]
["src/nvim/window.c", ["", "  if (wp == curwin && !curwin_invalid)          /* nothing to do */", "    return;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  if (wp == curwin && !curwin_invalid)          /* nothing to do */", "    return;"], "readability/braces"]
["src/nvim/window.c", ["  if (!curwin_invalid && trigger_leave_autocmds) {", "    /*", "     * Be careful: If autocommands delete the window, return now."], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (wp->w_buffer != curbuf) {", "      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);", "      other_buffer = TRUE;"], "readability/bool"]
["src/nvim/window.c", ["      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);", "      other_buffer = TRUE;", "      if (!win_valid(wp))"], "readability/bool"]
["src/nvim/window.c", ["      other_buffer = TRUE;", "      if (!win_valid(wp))", "        return;"], "readability/braces"]
["src/nvim/window.c", ["    }", "    apply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);", "    if (!win_valid(wp))"], "readability/bool"]
["src/nvim/window.c", ["    apply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);", "    if (!win_valid(wp))", "      return;"], "readability/braces"]
["src/nvim/window.c", ["      return;", "    /* autocmds may abort script processing */", "    if (aborting())"], "readability/old_style_comment"]
["src/nvim/window.c", ["    /* autocmds may abort script processing */", "    if (aborting())", "      return;"], "readability/braces"]
["src/nvim/window.c", ["  if (undo_sync && curbuf != wp->w_buffer) {", "    u_sync(FALSE);", "  }"], "readability/bool"]
["src/nvim/window.c", ["  if (!curwin_invalid) {", "    prevwin = curwin;           /* remember for CTRL-W p */", "    curwin->w_redr_status = TRUE;"], "readability/old_style_comment"]
["src/nvim/window.c", ["    prevwin = curwin;           /* remember for CTRL-W p */", "    curwin->w_redr_status = TRUE;", "  }"], "readability/bool"]
["src/nvim/window.c", ["  check_cursor();", "  if (!virtual_active())", "    curwin->w_cursor.coladd = 0;"], "readability/braces"]
["src/nvim/window.c", ["    curwin->w_cursor.coladd = 0;", "  changed_line_abv_curs();      /* assume cursor position needs updating */", ""], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  setmouse();                   /* in case jumped to/from help buffer */", ""], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Change directories when the 'acd' option is set. */", "  do_autochdir();"], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "", "  // First try the current tab page."], "whitespace/blank_line"]
["src/nvim/window.c", ["    win_T *wp = buf_jump_open_win(buf);", "    if (wp != NULL)", "      return wp;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Allocate a window structure and link it in the window list when \"hidden\" is"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Don't execute autocommands while the window is not properly", "   * initialized yet.  gui_create_scrollbar() may trigger a FocusGained"], "readability/old_style_comment"]
["src/nvim/window.c", ["  block_autocmds();", "  /*", "   * link the window in the window list"], "readability/old_style_comment"]
["src/nvim/window.c", ["   */", "  if (!hidden)", "    win_append(after, new_wp);"], "readability/braces"]
["src/nvim/window.c", ["", "  /* position the display and the cursor at the top of the file. */", "  new_wp->w_topline = 1;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* We won't calculate w_fraction until resizing the window */", "  new_wp->w_fraction = 0;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Remove window 'wp' from the window list and free the structure."], "readability/old_style_comment"]
["src/nvim/window.c", [" */", "static void ", "win_free ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["static void ", "win_free (", "    win_T *wp,"], "whitespace/parens"]
["src/nvim/window.c", ["    win_T *wp,", "    tabpage_T *tp                /* tab page \"win\" is in, NULL for current */", ")"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* reduce the reference count to the argument list. */", "  alist_unlink(wp->w_alist);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Don't execute autocommands while the window is halfway being deleted.", "   * gui_mch_destroy_scrollbar() may trigger a FocusGained event. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  vars_clear(&wp->w_vars->dv_hashtab);          /* free all w: variables */", "  hash_init(&wp->w_vars->dv_hashtab);"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Remove the window from the b_wininfo lists, it may happen that the", "   * freed memory is re-used for another window. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["  FOR_ALL_BUFFERS(buf) {", "    for (wip = buf->b_wininfo; wip != NULL; wip = wip->wi_next)", "      if (wip->wi_win == wp)"], "readability/braces"]
["src/nvim/window.c", ["    for (wip = buf->b_wininfo; wip != NULL; wip = wip->wi_next)", "      if (wip->wi_win == wp)", "        wip->wi_win = NULL;"], "readability/braces"]
["src/nvim/window.c", ["", "  if (wp != aucmd_win)", "    win_remove(wp, tp);"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Append window \"wp\" in the window list after window \"after\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  if (after == NULL)        /* after NULL is in front of the first */", "    before = firstwin;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  if (after == NULL)        /* after NULL is in front of the first */", "    before = firstwin;"], "readability/braces"]
["src/nvim/window.c", ["    before = firstwin;", "  else", "    before = after->w_next;"], "readability/braces"]
["src/nvim/window.c", ["  wp->w_prev = after;", "  if (after == NULL)", "    firstwin = wp;"], "readability/braces"]
["src/nvim/window.c", ["    firstwin = wp;", "  else", "    after->w_next = wp;"], "readability/braces"]
["src/nvim/window.c", ["    after->w_next = wp;", "  if (before == NULL)", "    lastwin = wp;"], "readability/braces"]
["src/nvim/window.c", ["    lastwin = wp;", "  else", "    before->w_prev = wp;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Remove a window from the window list."], "readability/old_style_comment"]
["src/nvim/window.c", [" */", "void ", "win_remove ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["void ", "win_remove (", "    win_T *wp,"], "whitespace/parens"]
["src/nvim/window.c", ["    win_T *wp,", "    tabpage_T *tp                /* tab page \"win\" is in, NULL for current */", ")"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Append frame \"frp\" in a frame list after frame \"after\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["  after->fr_next = frp;", "  if (frp->fr_next != NULL)", "    frp->fr_next->fr_prev = frp;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Insert frame \"frp\" in a frame list before frame \"before\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["  before->fr_prev = frp;", "  if (frp->fr_prev != NULL)", "    frp->fr_prev->fr_next = frp;"], "readability/braces"]
["src/nvim/window.c", ["    frp->fr_prev->fr_next = frp;", "  else", "    frp->fr_parent->fr_child = frp;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Remove a frame from a frame list."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Called from win_new_shellsize() after Rows changed."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  if (firstwin == NULL)         /* not initialized yet */", "    return;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  if (firstwin == NULL)         /* not initialized yet */", "    return;"], "readability/braces"]
["src/nvim/window.c", ["    return;", "  if (h < frame_minheight(topframe, NULL))", "    h = frame_minheight(topframe, NULL);"], "readability/braces"]
["src/nvim/window.c", ["", "  /* First try setting the heights of windows with 'winfixheight'.  If", "   * that doesn't result in the right height, forget about that option. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["   * that doesn't result in the right height, forget about that option. */", "  frame_new_height(topframe, h, FALSE, TRUE);", "  if (!frame_check_height(topframe, h))"], "readability/bool"]
["src/nvim/window.c", ["  frame_new_height(topframe, h, FALSE, TRUE);", "  if (!frame_check_height(topframe, h))", "    frame_new_height(topframe, h, FALSE, FALSE);"], "readability/braces"]
["src/nvim/window.c", ["  if (!frame_check_height(topframe, h))", "    frame_new_height(topframe, h, FALSE, FALSE);", ""], "readability/bool"]
["src/nvim/window.c", ["  curtab->tp_ch_used = p_ch;", "", "}"], "whitespace/blank_line"]
["src/nvim/window.c", ["", "/*", " * Called from win_new_shellsize() after Columns changed."], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  if (firstwin == NULL)         /* not initialized yet */", "    return;"], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  if (firstwin == NULL)         /* not initialized yet */", "    return;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* First try setting the widths of windows with 'winfixwidth'.  If that", "   * doesn't result in the right width, forget about that option. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Save the size of all windows in \"gap\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["    }", "    /* recompute the window positions */", "    (void)win_comp_pos();"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Update the position for all windows, using the width and height of the"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Update the position of the windows in frame \"topfrp\", using the width and"], "readability/old_style_comment"]
["src/nvim/window.c", ["        ) {", "      /* position changed, redraw */", "      wp->w_winrow = *row;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Set current window height and take care of repositioning other windows to"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Set the window height of window \"win\" and take care of repositioning other"], "readability/old_style_comment"]
["src/nvim/window.c", ["  }", "", "}"], "whitespace/blank_line"]
["src/nvim/window.c", ["", "/*", " * Set the height of a frame to \"height\" and take care that all frames and"], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  int room;                     /* total number of lines available */", "  int take;                     /* number of lines taken from other windows */"], "readability/old_style_comment"]
["src/nvim/window.c", ["  int room;                     /* total number of lines available */", "  int take;                     /* number of lines taken from other windows */", "  int room_cmdline;             /* lines available from cmdline */"], "readability/old_style_comment"]
["src/nvim/window.c", ["  int take;                     /* number of lines taken from other windows */", "  int room_cmdline;             /* lines available from cmdline */", "  int run;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* If the height already is the desired value, nothing to do. */", "  if (curfrp->fr_height == height)"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* If the height already is the desired value, nothing to do. */", "  if (curfrp->fr_height == height)", "    return;"], "readability/braces"]
["src/nvim/window.c", ["  if (curfrp->fr_parent == NULL) {", "    /* topframe: can only change the command line */", "    if (height > ROWS_AVAIL)"], "readability/old_style_comment"]
["src/nvim/window.c", ["    /* topframe: can only change the command line */", "    if (height > ROWS_AVAIL)", "      height = ROWS_AVAIL;"], "readability/braces"]
["src/nvim/window.c", ["      height = ROWS_AVAIL;", "    if (height > 0)", "      frame_new_height(curfrp, height, FALSE, FALSE);"], "readability/braces"]
["src/nvim/window.c", ["    if (height > 0)", "      frame_new_height(curfrp, height, FALSE, FALSE);", "  } else if (curfrp->fr_parent->fr_layout == FR_ROW) {"], "readability/bool"]
["src/nvim/window.c", ["  } else if (curfrp->fr_parent->fr_layout == FR_ROW) {", "    /* Row of frames: Also need to resize frames left and right of this", "     * one.  First check for the minimal height of these. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    h = frame_minheight(curfrp->fr_parent, NULL);", "    if (height < h)", "      height = h;"], "readability/braces"]
["src/nvim/window.c", ["  } else {", "    /*", "     * Column of frames: try to change only frames in this column."], "readability/old_style_comment"]
["src/nvim/window.c", ["     */", "    /*", "     * Do this twice:"], "readability/old_style_comment"]
["src/nvim/window.c", ["     */", "    for (run = 1; run <= 2; ++run) {", "      room = 0;"], "readability/increment"]
["src/nvim/window.c", ["      frame_setheight(curfrp->fr_parent, height", "          + frame_minheight(curfrp->fr_parent, NOWIN) - (int)p_wmh - 1);", "      /*NOTREACHED*/"], "whitespace/alignment"]
["src/nvim/window.c", ["          + frame_minheight(curfrp->fr_parent, NOWIN) - (int)p_wmh - 1);", "      /*NOTREACHED*/", "    }"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /*", "     * Compute the number of lines we will take from others frames (can be"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /* If there is not enough room, also reduce the height of a window", "     * with 'winfixheight' set. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["     * with 'winfixheight' set. */", "    if (height > room + room_cmdline - room_reserved)", "      room_reserved = room + room_cmdline - height;"], "readability/braces"]
["src/nvim/window.c", ["      room_reserved = room + room_cmdline - height;", "    /* If there is only a 'winfixheight' window and making the", "    * window smaller, need to make the other window taller. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    * window smaller, need to make the other window taller. */", "    if (take < 0 && room - curfrp->fr_height < room_reserved)", "      room_reserved = 0;"], "readability/braces"]
["src/nvim/window.c", ["    if (take > 0 && room_cmdline > 0) {", "      /* use lines from cmdline first */", "      if (take < room_cmdline)"], "readability/old_style_comment"]
["src/nvim/window.c", ["      /* use lines from cmdline first */", "      if (take < room_cmdline)", "        room_cmdline = take;"], "readability/braces"]
["src/nvim/window.c", ["", "    /*", "     * set the current frame to the new height"], "readability/old_style_comment"]
["src/nvim/window.c", ["     */", "    frame_new_height(curfrp, height, FALSE, FALSE);", ""], "readability/bool"]
["src/nvim/window.c", ["", "    /*", "     * First take lines from the frames after the current frame.  If"], "readability/old_style_comment"]
["src/nvim/window.c", ["     */", "    for (run = 0; run < 2; ++run) {", "      if (run == 0)"], "readability/increment"]
["src/nvim/window.c", ["    for (run = 0; run < 2; ++run) {", "      if (run == 0)", "        frp = curfrp->fr_next;          /* 1st run: start with next window */"], "readability/braces"]
["src/nvim/window.c", ["      if (run == 0)", "        frp = curfrp->fr_next;          /* 1st run: start with next window */", "      else"], "readability/old_style_comment"]
["src/nvim/window.c", ["        frp = curfrp->fr_next;          /* 1st run: start with next window */", "      else", "        frp = curfrp->fr_prev;          /* 2nd run: start with prev window */"], "readability/braces"]
["src/nvim/window.c", ["      else", "        frp = curfrp->fr_prev;          /* 2nd run: start with prev window */", "      while (frp != NULL && take != 0) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["            && frp->fr_win->w_p_wfh) {", "          if (room_reserved >= frp->fr_height)", "            room_reserved -= frp->fr_height;"], "readability/braces"]
["src/nvim/window.c", ["            room_reserved -= frp->fr_height;", "          else {", "            if (frp->fr_height - room_reserved > take)"], "readability/braces"]
["src/nvim/window.c", ["            room_reserved -= frp->fr_height;", "          else {", "            if (frp->fr_height - room_reserved > take)"], "readability/braces"]
["src/nvim/window.c", ["          else {", "            if (frp->fr_height - room_reserved > take)", "              room_reserved = frp->fr_height - take;"], "readability/braces"]
["src/nvim/window.c", ["            take -= frp->fr_height - room_reserved;", "            frame_new_height(frp, room_reserved, FALSE, FALSE);", "            room_reserved = 0;"], "readability/bool"]
["src/nvim/window.c", ["            take -= frp->fr_height - h;", "            frame_new_height(frp, h, FALSE, FALSE);", "          } else {"], "readability/bool"]
["src/nvim/window.c", ["            frame_new_height(frp, frp->fr_height - take,", "                FALSE, FALSE);", "            take = 0;"], "whitespace/alignment"]
["src/nvim/window.c", ["            frame_new_height(frp, frp->fr_height - take,", "                FALSE, FALSE);", "            take = 0;"], "readability/bool"]
["src/nvim/window.c", ["        }", "        if (run == 0)", "          frp = frp->fr_next;"], "readability/braces"]
["src/nvim/window.c", ["          frp = frp->fr_next;", "        else", "          frp = frp->fr_prev;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Set current window width and take care of repositioning other windows to"], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  /* Always keep current window at least one column wide, even when", "   * 'winminwidth' is zero. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (wp == curwin) {", "    if (width < p_wmw)", "      width = p_wmw;"], "readability/braces"]
["src/nvim/window.c", ["      width = p_wmw;", "    if (width == 0)", "      width = 1;"], "readability/braces"]
["src/nvim/window.c", ["  }", "", "}"], "whitespace/blank_line"]
["src/nvim/window.c", ["", "/*", " * Set the width of a frame to \"width\" and take care that all frames and"], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  int room;                     /* total number of lines available */", "  int take;                     /* number of lines taken from other windows */"], "readability/old_style_comment"]
["src/nvim/window.c", ["  int room;                     /* total number of lines available */", "  int take;                     /* number of lines taken from other windows */", "  int run;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* If the width already is the desired value, nothing to do. */", "  if (curfrp->fr_width == width)"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* If the width already is the desired value, nothing to do. */", "  if (curfrp->fr_width == width)", "    return;"], "readability/braces"]
["src/nvim/window.c", ["", "  if (curfrp->fr_parent == NULL)", "    /* topframe: can't change width */"], "readability/braces"]
["src/nvim/window.c", ["  if (curfrp->fr_parent == NULL)", "    /* topframe: can't change width */", "    return;"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (curfrp->fr_parent->fr_layout == FR_COL) {", "    /* Column of frames: Also need to resize frames above and below of", "     * this one.  First check for the minimal width of these. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    w = frame_minwidth(curfrp->fr_parent, NULL);", "    if (width < w)", "      width = w;"], "readability/braces"]
["src/nvim/window.c", ["  } else {", "    /*", "     * Row of frames: try to change only frames in this row."], "readability/old_style_comment"]
["src/nvim/window.c", ["     */", "    for (run = 1; run <= 2; ++run) {", "      room = 0;"], "readability/increment"]
["src/nvim/window.c", ["", "      if (width <= room)", "        break;"], "readability/braces"]
["src/nvim/window.c", ["      frame_setwidth(curfrp->fr_parent, width", "          + frame_minwidth(curfrp->fr_parent, NOWIN) - (int)p_wmw - 1);", "    }"], "whitespace/alignment"]
["src/nvim/window.c", ["", "    /*", "     * Compute the number of lines we will take from others frames (can be"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /* If there is not enough room, also reduce the width of a window", "     * with 'winfixwidth' set. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["     * with 'winfixwidth' set. */", "    if (width > room - room_reserved)", "      room_reserved = room - width;"], "readability/braces"]
["src/nvim/window.c", ["      room_reserved = room - width;", "    /* If there is only a 'winfixwidth' window and making the", "     * window smaller, need to make the other window narrower. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["     * window smaller, need to make the other window narrower. */", "    if (take < 0 && room - curfrp->fr_width < room_reserved)", "      room_reserved = 0;"], "readability/braces"]
["src/nvim/window.c", ["", "    /*", "     * set the current frame to the new width"], "readability/old_style_comment"]
["src/nvim/window.c", ["     */", "    frame_new_width(curfrp, width, FALSE, FALSE);", ""], "readability/bool"]
["src/nvim/window.c", ["", "    /*", "     * First take lines from the frames right of the current frame.  If"], "readability/old_style_comment"]
["src/nvim/window.c", ["     */", "    for (run = 0; run < 2; ++run) {", "      if (run == 0)"], "readability/increment"]
["src/nvim/window.c", ["    for (run = 0; run < 2; ++run) {", "      if (run == 0)", "        frp = curfrp->fr_next;          /* 1st run: start with next window */"], "readability/braces"]
["src/nvim/window.c", ["      if (run == 0)", "        frp = curfrp->fr_next;          /* 1st run: start with next window */", "      else"], "readability/old_style_comment"]
["src/nvim/window.c", ["        frp = curfrp->fr_next;          /* 1st run: start with next window */", "      else", "        frp = curfrp->fr_prev;          /* 2nd run: start with prev window */"], "readability/braces"]
["src/nvim/window.c", ["      else", "        frp = curfrp->fr_prev;          /* 2nd run: start with prev window */", "      while (frp != NULL && take != 0) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["            && frp->fr_win->w_p_wfw) {", "          if (room_reserved >= frp->fr_width)", "            room_reserved -= frp->fr_width;"], "readability/braces"]
["src/nvim/window.c", ["            room_reserved -= frp->fr_width;", "          else {", "            if (frp->fr_width - room_reserved > take)"], "readability/braces"]
["src/nvim/window.c", ["            room_reserved -= frp->fr_width;", "          else {", "            if (frp->fr_width - room_reserved > take)"], "readability/braces"]
["src/nvim/window.c", ["          else {", "            if (frp->fr_width - room_reserved > take)", "              room_reserved = frp->fr_width - take;"], "readability/braces"]
["src/nvim/window.c", ["            take -= frp->fr_width - room_reserved;", "            frame_new_width(frp, room_reserved, FALSE, FALSE);", "            room_reserved = 0;"], "readability/bool"]
["src/nvim/window.c", ["            take -= frp->fr_width - w;", "            frame_new_width(frp, w, FALSE, FALSE);", "          } else {"], "readability/bool"]
["src/nvim/window.c", ["            frame_new_width(frp, frp->fr_width - take,", "                FALSE, FALSE);", "            take = 0;"], "whitespace/alignment"]
["src/nvim/window.c", ["            frame_new_width(frp, frp->fr_width - take,", "                FALSE, FALSE);", "            take = 0;"], "readability/bool"]
["src/nvim/window.c", ["        }", "        if (run == 0)", "          frp = frp->fr_next;"], "readability/braces"]
["src/nvim/window.c", ["          frp = frp->fr_next;", "        else", "          frp = frp->fr_prev;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Status line of dragwin is dragged \"offset\" lines down (negative is up)."], "readability/old_style_comment"]
["src/nvim/window.c", ["  int row;", "  int up;               /* if TRUE, drag status line up, otherwise down */", "  int n;"], "readability/old_style_comment"]
["src/nvim/window.c", ["  curfr = fr;", "  if (fr != topframe) {         /* more than one window */", "    fr = fr->fr_parent;"], "readability/old_style_comment"]
["src/nvim/window.c", ["    fr = fr->fr_parent;", "    /* When the parent frame is not a column of frames, its parent should", "     * be. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["      curfr = fr;", "      if (fr != topframe)       /* only a row of windows, may drag statusline */", "        fr = fr->fr_parent;"], "readability/old_style_comment"]
["src/nvim/window.c", ["      curfr = fr;", "      if (fr != topframe)       /* only a row of windows, may drag statusline */", "        fr = fr->fr_parent;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* If this is the last frame in a column, may want to resize the parent", "   * frame instead (go two up to skip a row of frames). */"], "readability/old_style_comment"]
["src/nvim/window.c", ["  while (curfr != topframe && curfr->fr_next == NULL) {", "    if (fr != topframe)", "      fr = fr->fr_parent;"], "readability/braces"]
["src/nvim/window.c", ["    curfr = fr;", "    if (fr != topframe)", "      fr = fr->fr_parent;"], "readability/braces"]
["src/nvim/window.c", ["", "  if (offset < 0) { /* drag up */", "    up = TRUE;"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (offset < 0) { /* drag up */", "    up = TRUE;", "    offset = -offset;"], "readability/bool"]
["src/nvim/window.c", ["    offset = -offset;", "    /* sum up the room of the current frame and above it */", "    if (fr == curfr) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (fr == curfr) {", "      /* only one window */", "      room = fr->fr_height - frame_minheight(fr, NULL);"], "readability/old_style_comment"]
["src/nvim/window.c", ["        room += fr->fr_height - frame_minheight(fr, NULL);", "        if (fr == curfr)", "          break;"], "readability/braces"]
["src/nvim/window.c", ["    }", "    fr = curfr->fr_next;                /* put fr at frame that grows */", "  } else { /* drag down */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    fr = curfr->fr_next;                /* put fr at frame that grows */", "  } else { /* drag down */", "    up = FALSE;"], "readability/old_style_comment"]
["src/nvim/window.c", ["  } else { /* drag down */", "    up = FALSE;", "    /*"], "readability/bool"]
["src/nvim/window.c", ["    up = FALSE;", "    /*", "     * Only dragging the last status line can reduce p_ch."], "readability/old_style_comment"]
["src/nvim/window.c", ["    room = Rows - cmdline_row;", "    if (curfr->fr_next == NULL)", "      room -= 1;"], "readability/braces"]
["src/nvim/window.c", ["      room -= 1;", "    else", "      room -= p_ch;"], "readability/braces"]
["src/nvim/window.c", ["      room -= p_ch;", "    if (room < 0)", "      room = 0;"], "readability/braces"]
["src/nvim/window.c", ["", "  if (room < offset)            /* Not enough room */", "    offset = room;              /* Move as far as we can */"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  if (room < offset)            /* Not enough room */", "    offset = room;              /* Move as far as we can */"], "readability/braces"]
["src/nvim/window.c", ["  if (room < offset)            /* Not enough room */", "    offset = room;              /* Move as far as we can */", "  if (offset <= 0)"], "readability/old_style_comment"]
["src/nvim/window.c", ["    offset = room;              /* Move as far as we can */", "  if (offset <= 0)", "    return;"], "readability/braces"]
["src/nvim/window.c", ["", "  /*", "   * Grow frame fr by \"offset\" lines."], "readability/old_style_comment"]
["src/nvim/window.c", ["   */", "  if (fr != NULL)", "    frame_new_height(fr, fr->fr_height + offset, up, FALSE);"], "readability/braces"]
["src/nvim/window.c", ["  if (fr != NULL)", "    frame_new_height(fr, fr->fr_height + offset, up, FALSE);", ""], "readability/bool"]
["src/nvim/window.c", ["", "  if (up)", "    fr = curfr;                 /* current frame gets smaller */"], "readability/braces"]
["src/nvim/window.c", ["  if (up)", "    fr = curfr;                 /* current frame gets smaller */", "  else"], "readability/old_style_comment"]
["src/nvim/window.c", ["    fr = curfr;                 /* current frame gets smaller */", "  else", "    fr = curfr->fr_next;        /* next frame gets smaller */"], "readability/braces"]
["src/nvim/window.c", ["  else", "    fr = curfr->fr_next;        /* next frame gets smaller */", ""], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /*", "   * Now make the other frames smaller."], "readability/old_style_comment"]
["src/nvim/window.c", ["      offset -= fr->fr_height - n;", "      frame_new_height(fr, n, !up, FALSE);", "    } else {"], "readability/bool"]
["src/nvim/window.c", ["    } else {", "      frame_new_height(fr, fr->fr_height - offset, !up, FALSE);", "      break;"], "readability/bool"]
["src/nvim/window.c", ["    }", "    if (up)", "      fr = fr->fr_prev;"], "readability/braces"]
["src/nvim/window.c", ["      fr = fr->fr_prev;", "    else", "      fr = fr->fr_next;"], "readability/braces"]
["src/nvim/window.c", ["  p_ch = Rows - cmdline_row;", "  if (p_ch < 1)", "    p_ch = 1;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Separator line of dragwin is dragged \"offset\" lines right (negative is left)."], "readability/old_style_comment"]
["src/nvim/window.c", ["  int room;", "  int left;             /* if TRUE, drag separator line left, otherwise right */", "  int n;"], "readability/old_style_comment"]
["src/nvim/window.c", ["  fr = dragwin->w_frame;", "  if (fr == topframe)           /* only one window (cannot happen?) */", "    return;"], "readability/old_style_comment"]
["src/nvim/window.c", ["  fr = dragwin->w_frame;", "  if (fr == topframe)           /* only one window (cannot happen?) */", "    return;"], "readability/braces"]
["src/nvim/window.c", ["  fr = fr->fr_parent;", "  /* When the parent frame is not a row of frames, its parent should be. */", "  if (fr->fr_layout != FR_ROW) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (fr->fr_layout != FR_ROW) {", "    if (fr == topframe)         /* only a column of windows (cannot happen?) */", "      return;"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (fr->fr_layout != FR_ROW) {", "    if (fr == topframe)         /* only a column of windows (cannot happen?) */", "      return;"], "readability/braces"]
["src/nvim/window.c", ["", "  /* If this is the last frame in a row, may want to resize a parent", "   * frame instead. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["  while (curfr->fr_next == NULL) {", "    if (fr == topframe)", "      break;"], "readability/braces"]
["src/nvim/window.c", ["", "  if (offset < 0) { /* drag left */", "    left = TRUE;"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (offset < 0) { /* drag left */", "    left = TRUE;", "    offset = -offset;"], "readability/bool"]
["src/nvim/window.c", ["    offset = -offset;", "    /* sum up the room of the current frame and left of it */", "    room = 0;"], "readability/old_style_comment"]
["src/nvim/window.c", ["      room += fr->fr_width - frame_minwidth(fr, NULL);", "      if (fr == curfr)", "        break;"], "readability/braces"]
["src/nvim/window.c", ["    }", "    fr = curfr->fr_next;                /* put fr at frame that grows */", "  } else { /* drag right */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    fr = curfr->fr_next;                /* put fr at frame that grows */", "  } else { /* drag right */", "    left = FALSE;"], "readability/old_style_comment"]
["src/nvim/window.c", ["  } else { /* drag right */", "    left = FALSE;", "    /* sum up the room of frames right of the current one */"], "readability/bool"]
["src/nvim/window.c", ["    left = FALSE;", "    /* sum up the room of frames right of the current one */", "    room = 0;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* grow frame fr by offset lines */", "  frame_new_width(fr, fr->fr_width + offset, left, FALSE);"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* grow frame fr by offset lines */", "  frame_new_width(fr, fr->fr_width + offset, left, FALSE);", ""], "readability/bool"]
["src/nvim/window.c", ["", "  /* shrink other frames: current and at the left or at the right */", "  if (left)"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* shrink other frames: current and at the left or at the right */", "  if (left)", "    fr = curfr;                 /* current frame gets smaller */"], "readability/braces"]
["src/nvim/window.c", ["  if (left)", "    fr = curfr;                 /* current frame gets smaller */", "  else"], "readability/old_style_comment"]
["src/nvim/window.c", ["    fr = curfr;                 /* current frame gets smaller */", "  else", "    fr = curfr->fr_next;        /* next frame gets smaller */"], "readability/braces"]
["src/nvim/window.c", ["  else", "    fr = curfr->fr_next;        /* next frame gets smaller */", ""], "readability/old_style_comment"]
["src/nvim/window.c", ["      offset -= fr->fr_width - n;", "      frame_new_width(fr, n, !left, FALSE);", "    } else {"], "readability/bool"]
["src/nvim/window.c", ["    } else {", "      frame_new_width(fr, fr->fr_width - offset, !left, FALSE);", "      break;"], "readability/bool"]
["src/nvim/window.c", ["    }", "    if (left)", "      fr = fr->fr_prev;"], "readability/braces"]
["src/nvim/window.c", ["      fr = fr->fr_prev;", "    else", "      fr = fr->fr_next;"], "readability/braces"]
["src/nvim/window.c", ["      ) {", "    /*", "     * Find a value for w_topline that shows the cursor at the same"], "readability/old_style_comment"]
["src/nvim/window.c", ["    lnum = wp->w_cursor.lnum;", "    if (lnum < 1)               /* can happen when starting up */", "      lnum = 1;"], "readability/old_style_comment"]
["src/nvim/window.c", ["    lnum = wp->w_cursor.lnum;", "    if (lnum < 1)               /* can happen when starting up */", "      lnum = 1;"], "readability/braces"]
["src/nvim/window.c", ["    if (sline < 0) {", "      /*", "       * Cursor line would go off top of screen if w_wrow was this high."], "readability/old_style_comment"]
["src/nvim/window.c", ["        if (lnum == 1) {", "          /* first line in buffer is folded */", "          line_size = 1;"], "readability/old_style_comment"]
["src/nvim/window.c", ["          line_size = 1;", "          --sline;", "          break;"], "readability/increment"]
["src/nvim/window.c", ["      if (sline < 0) {", "        /*", "         * Line we want at top would go off top of screen.  Use next"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * command_height: called whenever p_ch has been changed"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Use the value of p_ch that we remembered.  This is needed for when the", "   * GUI starts up, we can't be sure in what order things happen.  And when"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /* Avoid changing the height of a window with 'winfixheight' set. */", "  while (frp->fr_prev != NULL && frp->fr_layout == FR_LEAF"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* Avoid changing the height of a window with 'winfixheight' set. */", "  while (frp->fr_prev != NULL && frp->fr_layout == FR_LEAF", "         && frp->fr_win->w_p_wfh)"], "readability/braces"]
["src/nvim/window.c", ["", "    if (p_ch > old_p_ch) {                  /* p_ch got bigger */", "      while (p_ch > old_p_ch) {"], "readability/old_style_comment"]
["src/nvim/window.c", ["        h = frp->fr_height - frame_minheight(frp, NULL);", "        if (h > p_ch - old_p_ch)", "          h = p_ch - old_p_ch;"], "readability/braces"]
["src/nvim/window.c", ["", "      /* Recompute window positions. */", "      (void)win_comp_pos();"], "readability/old_style_comment"]
["src/nvim/window.c", ["      msg_row = cmdline_row;", "      redraw_cmdline = TRUE;", "      return;"], "readability/bool"]
["src/nvim/window.c", ["", "    if (msg_row < cmdline_row)", "      msg_row = cmdline_row;"], "readability/braces"]
["src/nvim/window.c", ["      msg_row = cmdline_row;", "    redraw_cmdline = TRUE;", "  }"], "readability/bool"]
["src/nvim/window.c", ["", "  /* Recompute window positions. */", "  if (frp != lastwin->w_frame)"], "readability/old_style_comment"]
["src/nvim/window.c", ["  /* Recompute window positions. */", "  if (frp != lastwin->w_frame)", "    (void)win_comp_pos();"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Resize frame \"frp\" to be \"n\" lines higher (negative for less high)."], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  frame_new_height(frp, frp->fr_height + n, FALSE, FALSE);", "  for (;; ) {"], "readability/bool"]
["src/nvim/window.c", ["    frp = frp->fr_parent;", "    if (frp == NULL)", "      break;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Get the file name at the cursor."], "readability/old_style_comment"]
["src/nvim/window.c", ["    char_u  *ptr;", "    if (get_visual_text(NULL, &ptr, &len) == FAIL)", "      return NULL;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Return the file name under or after the cursor."], "readability/old_style_comment"]
["src/nvim/window.c", ["  return file_name_in_line(get_cursor_line_ptr(),", "      curwin->w_cursor.col, options, count, curbuf->b_ffname,", "      file_lnum);"], "whitespace/alignment"]
["src/nvim/window.c", ["      curwin->w_cursor.col, options, count, curbuf->b_ffname,", "      file_lnum);", "}"], "whitespace/alignment"]
["src/nvim/window.c", ["", "/*", " * Return the name of the file under or after ptr[col]."], "readability/old_style_comment"]
["src/nvim/window.c", ["char_u *", "file_name_in_line (", "    char_u *line,"], "whitespace/parens"]
["src/nvim/window.c", ["    long count,", "    char_u *rel_fname,         /* file we are searching relative to */", "    linenr_T *file_lnum         /* line number after the file name */"], "readability/old_style_comment"]
["src/nvim/window.c", ["    char_u *rel_fname,         /* file we are searching relative to */", "    linenr_T *file_lnum         /* line number after the file name */", ")"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /*", "   * search forward for what could be the start of a file name"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /*", "   * Search backward for first char of the file name."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /*", "   * Search forward for the last char of the file name."], "readability/old_style_comment"]
["src/nvim/window.c", ["      // Skip over the \"\\\" in \"\\ \".", "      ++len;", "    }"], "readability/increment"]
["src/nvim/window.c", ["", "  /*", "   * If there is trailing punctuation, remove it."], "readability/old_style_comment"]
["src/nvim/window.c", ["   */", "  if (len > 2 && vim_strchr((char_u *)\".,:;!\", ptr[len - 1]) != NULL", "      && ptr[len - 2] != '.')"], "readability/braces"]
["src/nvim/window.c", ["      && ptr[len - 2] != '.')", "    --len;", ""], "readability/increment"]
["src/nvim/window.c", ["", "/*", " * Add or remove a status line for the bottom window(s), according to the"], "readability/old_style_comment"]
["src/nvim/window.c", [" */", "void ", "last_status ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["void ", "last_status (", "    int morewin                    /* pretend there are two or more windows */"], "whitespace/parens"]
["src/nvim/window.c", ["last_status (", "    int morewin                    /* pretend there are two or more windows */", ")"], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  /* Don't make a difference between horizontal or vertical split. */", "  last_status_rec(topframe, (p_ls == 2"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (wp->w_status_height != 0 && !statusline) {", "      /* remove status line */", "      win_new_height(wp, wp->w_height + 1);"], "readability/old_style_comment"]
["src/nvim/window.c", ["    } else if (wp->w_status_height == 0 && statusline) {", "      /* Find a frame to take a line from. */", "      fp = fr;"], "readability/old_style_comment"]
["src/nvim/window.c", ["        }", "        /* In a column of frames: go to frame above.  If already at", "         * the top or in a row of frames: go to parent. */"], "readability/old_style_comment"]
["src/nvim/window.c", ["         * the top or in a row of frames: go to parent. */", "        if (fp->fr_parent->fr_layout == FR_COL && fp->fr_prev != NULL)", "          fp = fp->fr_prev;"], "readability/braces"]
["src/nvim/window.c", ["          fp = fp->fr_prev;", "        else", "          fp = fp->fr_parent;"], "readability/braces"]
["src/nvim/window.c", ["      if (fp != fr) {", "        frame_new_height(fp, fp->fr_height - 1, FALSE, FALSE);", "        frame_fix_height(wp);"], "readability/bool"]
["src/nvim/window.c", ["        (void)win_comp_pos();", "      } else", "        win_new_height(wp, wp->w_height - 1);"], "readability/braces"]
["src/nvim/window.c", ["  } else {", "    /* horizontally split window, set status line for last one */", "    for (fp = fr->fr_child; fp->fr_next != NULL; fp = fp->fr_next)"], "readability/old_style_comment"]
["src/nvim/window.c", ["    /* horizontally split window, set status line for last one */", "    for (fp = fr->fr_child; fp->fr_next != NULL; fp = fp->fr_next)", "      ;"], "readability/braces"]
["src/nvim/window.c", ["    for (fp = fr->fr_child; fp->fr_next != NULL; fp = fp->fr_next)", "      ;", "    last_status_rec(fp, statusline);"], "whitespace/semicolon"]
["src/nvim/window.c", ["", "/*", " * Return the number of lines used by the tab page line."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Return the minimal number of rows that is needed on the screen to display"], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  if (firstwin == NULL)         /* not initialized yet */", "    return MIN_LINES;"], "readability/old_style_comment"]
["src/nvim/window.c", ["{", "  if (firstwin == NULL)         /* not initialized yet */", "    return MIN_LINES;"], "readability/braces"]
["src/nvim/window.c", ["  total += tabline_height();", "  total += 1;           /* count the room for the command line */", "  return total;"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Correct the cursor line number in other windows.  Used after changing the"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * A snapshot of the window sizes, to restore them after closing the help"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Create a snapshot of the current frame sizes."], "readability/old_style_comment"]
["src/nvim/window.c", ["  (*frp)->fr_height = fr->fr_height;", "  if (fr->fr_next != NULL)", "    make_snapshot_rec(fr->fr_next, &((*frp)->fr_next));"], "readability/braces"]
["src/nvim/window.c", ["    make_snapshot_rec(fr->fr_next, &((*frp)->fr_next));", "  if (fr->fr_child != NULL)", "    make_snapshot_rec(fr->fr_child, &((*frp)->fr_child));"], "readability/braces"]
["src/nvim/window.c", ["    make_snapshot_rec(fr->fr_child, &((*frp)->fr_child));", "  if (fr->fr_layout == FR_LEAF && fr->fr_win == curwin)", "    (*frp)->fr_win = curwin;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Remove any existing snapshot."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Restore a previously created snapshot, if there is any."], "readability/old_style_comment"]
["src/nvim/window.c", [" */", "void ", "restore_snapshot ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["void ", "restore_snapshot (", "    int idx,"], "whitespace/parens"]
["src/nvim/window.c", ["    int idx,", "    int close_curwin                   /* closing current window */", ")"], "readability/old_style_comment"]
["src/nvim/window.c", ["    win_comp_pos();", "    if (wp != NULL && close_curwin)", "      win_goto(wp);"], "readability/braces"]
["src/nvim/window.c", ["{", "  if (sn->fr_layout != fr->fr_layout", "      || (sn->fr_next == NULL) != (fr->fr_next == NULL)"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Copy the size of snapshot frame \"sn\" to frame \"fr\".  Do the same for all"], "readability/old_style_comment"]
["src/nvim/window.c", ["  if (fr->fr_layout == FR_LEAF) {", "    frame_new_height(fr, fr->fr_height, FALSE, FALSE);", "    frame_new_width(fr, fr->fr_width, FALSE, FALSE);"], "readability/bool"]
["src/nvim/window.c", ["    frame_new_height(fr, fr->fr_height, FALSE, FALSE);", "    frame_new_width(fr, fr->fr_width, FALSE, FALSE);", "    wp = sn->fr_win;"], "readability/bool"]
["src/nvim/window.c", ["    wp2 = restore_snapshot_rec(sn->fr_next, fr->fr_next);", "    if (wp2 != NULL)", "      wp = wp2;"], "readability/braces"]
["src/nvim/window.c", ["    wp2 = restore_snapshot_rec(sn->fr_child, fr->fr_child);", "    if (wp2 != NULL)", "      wp = wp2;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Set \"win\" to be the curwin and \"tp\" to be the current tab page."], "readability/old_style_comment"]
["src/nvim/window.c", [" */", "int switch_win(win_T **save_curwin, tabpage_T **save_curtab, win_T *win, tabpage_T *tp, int no_display)", "{"], "whitespace/line_length"]
["src/nvim/window.c", ["      lastwin = curtab->tp_lastwin;", "    } else", "      goto_tabpage_tp(tp, FALSE, FALSE);"], "readability/braces"]
["src/nvim/window.c", ["    } else", "      goto_tabpage_tp(tp, FALSE, FALSE);", "  }"], "readability/bool"]
["src/nvim/window.c", ["      lastwin = curtab->tp_lastwin;", "    } else", "      goto_tabpage_tp(save_curtab, FALSE, FALSE);"], "readability/braces"]
["src/nvim/window.c", ["    } else", "      goto_tabpage_tp(save_curtab, FALSE, FALSE);", "  }"], "readability/bool"]
["src/nvim/window.c", ["    cur = wp->w_match_head;", "    while (cur != NULL && cur->id != wp->w_next_match_id)", "      cur = cur->next;"], "readability/braces"]
["src/nvim/window.c", ["      cur = cur->next;", "    if (cur == NULL)", "      id = wp->w_next_match_id;"], "readability/braces"]
["src/nvim/window.c", ["  m->match.regprog = regprog;", "  m->match.rmm_ic = FALSE;", "  m->match.rmm_maxcol = 0;"], "readability/bool"]
["src/nvim/window.c", ["", "    // Calculate top and bottom lines for redrawing area ", "    if (toplnum != 0){"], "whitespace/end_of_line"]
["src/nvim/window.c", ["    // Calculate top and bottom lines for redrawing area ", "    if (toplnum != 0){", "      if (wp->w_buffer->b_mod_set) {"], "whitespace/braces"]
["src/nvim/window.c", ["  }", "  if (cur == prev)", "    wp->w_match_head = m;"], "readability/braces"]
["src/nvim/window.c", ["    wp->w_match_head = m;", "  else", "    prev->next = m;"], "readability/braces"]
["src/nvim/window.c", ["  }", "  if (cur == prev)", "    wp->w_match_head = cur->next;"], "readability/braces"]
["src/nvim/window.c", ["    wp->w_match_head = cur->next;", "  else", "    prev->next = cur->next;"], "readability/braces"]
["src/nvim/window.c", ["", "/*", " * Delete all matches in the match list of window 'wp'."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Get match from ID 'id' in window 'wp'."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  while (cur != NULL && cur->id != id)", "    cur = cur->next;"], "readability/braces"]
