["src/nvim/eval/userfunc.c", ["#include \"nvim/ex_getln.h\"", "#include \"nvim/ex_getln.h\"", "#include \"nvim/fileio.h\""], "build/include"]
["src/nvim/eval/userfunc.c", ["char_u *deref_func_name(const char *name, int *lenp,", "                               partial_T **const partialp, bool no_autoload)", "  FUNC_ATTR_NONNULL_ARG(1, 2)"], "whitespace/alignment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Allocate a variable for the result of a function."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  int ret = OK;", "  typval_T argvars[MAX_FUNC_ARGS + 1];          /* vars for arguments */", "  int argcount = 0;                     /* number of arguments found */"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  typval_T argvars[MAX_FUNC_ARGS + 1];          /* vars for arguments */", "  int argcount = 0;                     /* number of arguments found */", ""], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "  /*", "   * Get the arguments."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["    }", "    ++argcount;", "    if (*argp != ',')"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["    ++argcount;", "    if (*argp != ',')", "      break;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["  }", "  if (*argp == ')')", "    ++argp;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["  if (*argp == ')')", "    ++argp;", "  else"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["    ++argp;", "  else", "    ret = FAIL;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["  hi = hash_find(&func_hashtab, name);", "  if (!HASHITEM_EMPTY(hi))", "    return HI2UF(hi);"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Copy the function name of \"fp\" to buffer \"buf\"."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["    STRCAT(buf, fp->uf_name + 3);", "  } else", "    STRCPY(buf, fp->uf_name);"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Add a number variable \"name\" to dict \"dp\" with value \"nr\"."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  }", "  ++depth;", "  // Save search patterns and redo buffer."], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  }", "  ++fp->uf_calls;", "  // check for CTRL-C hit"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["    v->di_tv.vval.v_dict = selfdict;", "    ++selfdict->dv_refcount;", "  }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["    if (p_verbose >= 12) {", "      ++no_wait_return;", "      verbose_enter_scroll();"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["      verbose_leave_scroll();", "      --no_wait_return;", "    }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  if (func_or_func_caller_profiling) {", "    ++fp->uf_tm_count;", "    call_start = profile_start();"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  save_did_emsg = did_emsg;", "  did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/eval/userfunc.c", ["", "  --RedrawingDisabled;", ""], "readability/increment"]
["src/nvim/eval/userfunc.c", ["    fp->uf_tm_self = profile_self(fp->uf_tm_self, call_start,", "        fp->uf_tm_children);", "    if (fc->caller != NULL && fc->caller->func->uf_profiling) {"], "whitespace/alignment"]
["src/nvim/eval/userfunc.c", ["  if (p_verbose >= 12) {", "    ++no_wait_return;", "    verbose_enter_scroll();"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["", "    if (aborting())", "      smsg(_(\"%s aborted\"), sourcing_name);"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["      smsg(_(\"%s aborted\"), sourcing_name);", "    else if (fc->rettv->v_type == VAR_NUMBER)", "      smsg(_(\"%s returning #%\" PRId64 \"\"),"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["           sourcing_name, (int64_t)fc->rettv->vval.v_number);", "    else {", "      char_u buf[MSG_BUF_LEN];"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["           sourcing_name, (int64_t)fc->rettv->vval.v_number);", "    else {", "      char_u buf[MSG_BUF_LEN];"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["      emsg_off++;", "      char_u *s = (char_u *) encode_tv2string(fc->rettv, NULL);", "      char_u *tofree = s;"], "whitespace/cast"]
["src/nvim/eval/userfunc.c", ["    verbose_leave_scroll();", "    --no_wait_return;", "  }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  if (p_verbose >= 12 && sourcing_name != NULL) {", "    ++no_wait_return;", "    verbose_enter_scroll();"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["    verbose_leave_scroll();", "    --no_wait_return;", "  }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["      emsg_funcname(N_(\"E119: Not enough arguments for function: %s\"),", "          name);", "      break;"], "whitespace/alignment"]
["src/nvim/eval/userfunc.c", ["      emsg_funcname(N_(\"E120: Using <SID> not in a script context: %s\"),", "          name);", "      break;"], "whitespace/alignment"]
["src/nvim/eval/userfunc.c", ["      emsg_funcname(N_(\"E725: Calling dict function without Dictionary: %s\"),", "          name);", "      break;"], "whitespace/alignment"]
["src/nvim/eval/userfunc.c", ["      if (fp == NULL", "          && apply_autocmds(EVENT_FUNCUNDEFINED, rfname, rfname, TRUE, NULL)", "          && !aborting()) {"], "readability/bool"]
["src/nvim/eval/userfunc.c", ["    }", "    /*", "     * The function call (or \"FuncUndefined\" autocommand sequence) might"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  }", "  if (error == ERROR_NONE)", "    ret = OK;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["  msg_start();", "  if (indent)", "    MSG_PUTS(\"   \");"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "  if (fdp != NULL)", "    memset(fdp, 0, sizeof(funcdict_T));"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "  /* Check for hard coded <SNR>: already translated function ID (from a user", "   * command). */"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "  /* A name starting with \"<SID>\" or \"<SNR>\" is local to a script.  But", "   * don't skip over \"s:\", get_lval() needs it for \"s:dict.func\". */"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  if (end == start) {", "    if (!skip)", "      EMSG(_(\"E129: Function name required\"));"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["  if (end == NULL || (lv.ll_tv != NULL && (lead > 2 || lv.ll_range))) {", "    /*", "     * Report an invalid expression in braces, unless the expression"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "  /* Check if the name is a Funcref.  If so, use the value. */", "  if (lv.ll_exp_name != NULL) {"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * \":function\""], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "  /*", "   * \":function\" without argument: list functions."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["      todo = (int)func_hashtab.ht_used;", "      for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi) {", "        if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["        if (!HASHITEM_EMPTY(hi)) {", "          --todo;", "          fp = HI2UF(hi);"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["", "  /*", "   * \":function /pat\": list functions matching pattern."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  if (*eap->arg == '/') {", "    p = skip_regexp(eap->arg + 1, '/', TRUE, NULL);", "    if (!eap->skip) {"], "readability/bool"]
["src/nvim/eval/userfunc.c", ["        todo = (int)func_hashtab.ht_used;", "        for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi) {", "          if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["          if (!HASHITEM_EMPTY(hi)) {", "            --todo;", "            fp = HI2UF(hi);"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["            fp = HI2UF(hi);", "            if (!isdigit(*fp->uf_name)", "                && vim_regexec(&regmatch, fp->uf_name, 0))"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["    }", "    if (*p == '/')", "      ++p;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["    if (*p == '/')", "      ++p;", "    eap->nextcmd = check_nextcmd(p);"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  if (name == NULL && (fudi.fd_dict == NULL || !paren) && !eap->skip) {", "    /*", "     * Return on an invalid expression in braces, unless the expression"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["      return;", "    } else", "      eap->skip = TRUE;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["    } else", "      eap->skip = TRUE;", "  }"], "readability/bool"]
["src/nvim/eval/userfunc.c", ["", "  /* An error in a function call during evaluation of an expression in magic", "   * braces should not cause the function not to be defined. */"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  saved_did_emsg = did_emsg;", "  did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/eval/userfunc.c", ["    eap->nextcmd = check_nextcmd(p);", "    if (eap->nextcmd != NULL)", "      *p = NUL;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["        }", "      } else", "        emsg_funcname(N_(\"E123: Undefined function: %s\"), name);"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "  /*", "   * \":function name(arg1, arg2)\" Define function."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  if (!eap->skip) {", "    /* Check the name of the function.  Unless it's a dictionary function", "     * (that we are overwriting). */"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["     * (that we are overwriting). */", "    if (name != NULL)", "      arg = name;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["      arg = name;", "    else", "      arg = fudi.fd_newkey;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["      int j = (*arg == K_SPECIAL) ? 3 : 0;", "      while (arg[j] != NUL && (j == 0 ? eval_isnamec1(arg[j])", "                               : eval_isnamec(arg[j])))"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["                               : eval_isnamec(arg[j])))", "        ++j;", "      if (arg[j] != NUL)"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["        ++j;", "      if (arg[j] != NUL)", "        emsg_funcname((char *)e_invarg2, arg);"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "  /* When there is a line break use what follows for the function body.", "   * Makes 'exe \"func Test()\\n...\\nendfunc\"' work. */"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "  /*", "   * Read the body of the function, until \":endfunction\" is found."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  if (KeyTyped) {", "    /* Check if the function already exists, don't let the user type the", "     * whole function before telling him it doesn't work!  For a script we"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["    if (!eap->skip && !eap->forceit) {", "      if (fudi.fd_dict != NULL && fudi.fd_newkey == NULL)", "        EMSG(_(e_funcdict));"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["        EMSG(_(e_funcdict));", "      else if (name != NULL && find_func(name) != NULL)", "        emsg_funcname(e_funcexts, name);"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "    if (!eap->skip && did_emsg)", "      goto erret;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["      p = vim_strchr(theline, '\\n');", "      if (p == NULL)", "        line_arg += STRLEN(line_arg);"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["        line_arg += STRLEN(line_arg);", "      else {", "        *p = NUL;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["        line_arg += STRLEN(line_arg);", "      else {", "        *p = NUL;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "      /* Increase indent inside \"if\", \"while\", \"for\" and \"try\", decrease", "       * at \"end\". */"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["       * at \"end\". */", "      if (indent > 2 && STRNCMP(p, \"end\", 3) == 0)", "        indent -= 2;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["        indent -= 2;", "      else if (STRNCMP(p, \"if\", 2) == 0", "               || STRNCMP(p, \"wh\", 2) == 0"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["        p = skipwhite(arg + 2);", "        if (*p == NUL)", "          skip_until = vim_strsave((char_u *)\".\");"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["          skip_until = vim_strsave((char_u *)\".\");", "        else", "          skip_until = vim_strsave(p);"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "    /* Copy the line to newly allocated memory.  get_one_sourceline()", "     * allocates 250 bytes per line, this saves 80% on average.  The cost"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "    /* Add NULL lines for continuation lines, so that the line count is", "     * equal to the index in the growarray.   */"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["     * equal to the index in the growarray.   */", "    while (sourcing_lnum_off-- > 0)", "      ((char_u **)(newlines.ga_data))[newlines.ga_len++] = NULL;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "  /* Don't define the function when skipping commands or when an error was", "   * detected. */"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["   * detected. */", "  if (eap->skip || did_emsg)", "    goto erret;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "  /*", "   * If there are no errors, add the function"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["      emsg_funcname(N_(\"E707: Function name conflicts with variable: %s\"),", "          name);", "      goto erret;"], "whitespace/alignment"]
["src/nvim/eval/userfunc.c", ["        emsg_funcname(N_(\"E127: Cannot redefine function %s: It is in use\"),", "            name);", "        goto erret;"], "whitespace/alignment"]
["src/nvim/eval/userfunc.c", ["", "    /* Give the function a sequential number.  Can only be used with a", "     * Funcref! */"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["    xfree(name);", "    sprintf(numbuf, \"%d\", ++func_nr);", "    name = vim_strsave((char_u *)numbuf);"], "runtime/printf"]
["src/nvim/eval/userfunc.c", ["        slen = (int)STRLEN(sourcing_name);", "        if (slen > plen && fnamecmp(p,", "                sourcing_name + slen - plen) == 0)"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["        if (slen > plen && fnamecmp(p,", "                sourcing_name + slen - plen) == 0)", "          j = OK;"], "whitespace/alignment"]
["src/nvim/eval/userfunc.c", ["        EMSG2(_(", "                \"E746: Function name does not match script file name: %s\"),", "            name);"], "whitespace/indent"]
["src/nvim/eval/userfunc.c", ["                \"E746: Function name does not match script file name: %s\"),", "            name);", "        goto erret;"], "whitespace/alignment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Return 5 if \"p\" starts with \"<SID>\" or \"<SNR>\" (ignoring case)."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "  /* Only accept \"funcname\", \"funcname \", \"funcname (...\" and", "   * \"funcname(...\", not \"funcname!...\". */"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the list of user defined"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  if (done < func_hashtab.ht_used) {", "    if (done++ > 0)", "      ++hi;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["    if (done++ > 0)", "      ++hi;", "    while (HASHITEM_EMPTY(hi))"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["      ++hi;", "    while (HASHITEM_EMPTY(hi))", "      ++hi;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["    while (HASHITEM_EMPTY(hi))", "      ++hi;", "    fp = HI2UF(hi);"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["      STRCAT(IObuff, \"(\");", "      if (!fp->uf_varargs && GA_EMPTY(&fp->uf_args))", "        STRCAT(IObuff, \")\");"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["  if (name == NULL) {", "    if (fudi.fd_dict != NULL && !eap->skip)", "      EMSG(_(e_funcref));"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["  eap->nextcmd = check_nextcmd(p);", "  if (eap->nextcmd != NULL)", "    *p = NUL;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "  if (!eap->skip)", "    fp = find_func(name);"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["      EMSG2(_(\"Cannot delete function %s: It is being used internally\"),", "          eap->arg);", "      return;"], "whitespace/alignment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Unreference a Function: decrement the reference count and free it when it"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * \":return [expr]\""], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  typval_T rettv;", "  int returning = FALSE;", ""], "readability/bool"]
["src/nvim/eval/userfunc.c", ["", "  if (eap->skip)", "    ++emsg_skip;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["  if (eap->skip)", "    ++emsg_skip;", ""], "readability/increment"]
["src/nvim/eval/userfunc.c", ["", "  /* When skipping or the return gets pending, advance to the next command", "   * in this line (!returning).  Otherwise, ignore the rest of the line."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "  if (eap->skip)", "    --emsg_skip;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["  if (eap->skip)", "    --emsg_skip;", "}"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * \":1,25call func(arg1, arg2)\"\tfunction call."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Return from a function.  Possibly makes the return pending.  Also called"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "  /*", "   * Cleanup (and inactivate) conditionals, but stop when a try conditional"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["   */", "  idx = cleanup_conditionals(eap->cstack, 0, TRUE);", "  if (idx >= 0) {"], "readability/bool"]
["src/nvim/eval/userfunc.c", ["", "    if (!is_cmd && !reanimate)", "      /* A pending return again gets pending.  \"rettv\" points to an"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["    if (!is_cmd && !reanimate)", "      /* A pending return again gets pending.  \"rettv\" points to an", "       * allocated variable with the rettv of the original \":return\"'s"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["      cstack->cs_rettv[idx] = rettv;", "    else {", "      /* When undoing a return in order to make it pending, get the stored"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["      cstack->cs_rettv[idx] = rettv;", "    else {", "      /* When undoing a return in order to make it pending, get the stored"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["    else {", "      /* When undoing a return in order to make it pending, get the stored", "       * return rettv. */"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["        *(typval_T *)cstack->cs_rettv[idx] = *(typval_T *)rettv;", "      } else", "        cstack->cs_rettv[idx] = NULL;"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["      if (reanimate) {", "        /* The pending return value could be overwritten by a \":return\"", "         * without argument in a finally clause; reset the default"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  } else {", "    current_funccal->returned = TRUE;", ""], "readability/bool"]
["src/nvim/eval/userfunc.c", ["", "    /* If the return is carried out now, store the return value.  For", "     * a return immediately after reanimation, the value is already"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["      *current_funccal->rettv = *(typval_T *)rettv;", "      if (!is_cmd)", "        xfree(rettv);"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Generate a return command for producing the value of \"rettv\".  The result"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  if (rettv != NULL) {", "    tofree = s = (char_u *) encode_tv2echo((typval_T *) rettv, NULL);", "  }"], "whitespace/cast"]
["src/nvim/eval/userfunc.c", ["  STRLCPY(IObuff + 8, s, IOSIZE - 8);", "  if (STRLEN(s) + 8 >= IOSIZE)", "    STRCPY(IObuff + IOSIZE - 4, \"...\");"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Get next function line."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["    fcp->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name,", "        sourcing_lnum);", "    fcp->dbg_tick = debug_tick;"], "whitespace/alignment"]
["src/nvim/eval/userfunc.c", ["  if (fcp->dbg_tick != debug_tick) {", "    fcp->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name,", "        sourcing_lnum);"], "readability/bool"]
["src/nvim/eval/userfunc.c", ["  }", "  if (do_profiling == PROF_YES)", "    func_line_end(cookie);"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["      sourcing_lnum = fcp->linenr;", "      if (do_profiling == PROF_YES)", "        func_line_start(cookie);"], "readability/braces"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Return TRUE if the currently active function should be ended, because a"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "  /* Ignore the \"abort\" flag if the abortion behavior has been changed due to", "   * an error inside a try conditional. */"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * return TRUE if cookie indicates a function which \"abort\"s on errors."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Return the name of the executed function."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Return the address holding the next breakpoint line for a funccall cookie."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Return the address holding the debug tick for a funccall cookie."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Return the nesting level for a funccall cookie."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * Return TRUE when a function was ended by a \":return\" command."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "/*", " * List function variables, if there is a function."], "readability/old_style_comment"]
