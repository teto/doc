["src/nvim/option.c", ["", "/*", " * The options that are local to a window or buffer have \"indir\" set to one of"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "/*", " * Options local to a window have a value local to a buffer and global to all"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "/*", " * These are the global values for options which are also local to a buffer."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "/*", " * Flags"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "/*", " * options[] is initialized here."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * Find default value for 'shell' option."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * Set the default for 'backupskip' to include environment variables for"], "readability/old_style_comment"]
["src/nvim/option.c", ["# ifdef UNIX", "    static char     *(names[4]) = {\"\", \"TMPDIR\", \"TEMP\", \"TMP\"};", "# else"], "whitespace/braces"]
["src/nvim/option.c", ["# ifdef UNIX", "    static char     *(names[4]) = {\"\", \"TMPDIR\", \"TEMP\", \"TMP\"};", "# else"], "whitespace/braces"]
["src/nvim/option.c", ["# else", "    static char     *(names[3]) = {\"TMPDIR\", \"TEMP\", \"TMP\"};", "# endif"], "whitespace/braces"]
["src/nvim/option.c", ["# else", "    static char     *(names[3]) = {\"TMPDIR\", \"TEMP\", \"TMP\"};", "# endif"], "whitespace/braces"]
["src/nvim/option.c", ["        mustfree = false;", "      } else", "# endif"], "readability/braces"]
["src/nvim/option.c", ["      }", "      if(mustfree) {", "        xfree(p);"], "whitespace/parens"]
["src/nvim/option.c", ["                     \"system(['lpr'] \"", "                            \"+ (empty(&printdevice)?[]:['-P', &printdevice]) \"", "                            \"+ [v:fname_in])\""], "whitespace/alignment"]
["src/nvim/option.c", ["                            \"+ (empty(&printdevice)?[]:['-P', &printdevice]) \"", "                            \"+ [v:fname_in])\"", "                     \". delete(v:fname_in)\""], "whitespace/alignment"]
["src/nvim/option.c", ["                     \"system(['copy', v:fname_in, \"", "                             \"empty(&printdevice)?'LPT1':&printdevice])\"", "                     \". delete(v:fname_in)\","], "whitespace/alignment"]
["src/nvim/option.c", ["", "  /*", "   * Set all the options (except the terminal options) to their default"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * Expand environment variables and things like \"~\" for the defaults."], "readability/old_style_comment"]
["src/nvim/option.c", ["    } else {", "      p = (char *) option_expand(opt_idx, NULL);", "    }"], "whitespace/cast"]
["src/nvim/option.c", ["      *(char **)options[opt_idx].var = p;", "      /* VIMEXP", "       * Defaults for all expanded options are currently the same for Vi"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /* Detect use of mlterm.", "   * Mlterm is a terminal emulator akin to xterm that has some special"], "readability/old_style_comment"]
["src/nvim/option.c", ["    if (flags & P_STRING) {", "      /* Use set_string_option_direct() for local options to handle", "       * freeing and allocating the value. */"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * 'window' is only for backwards compatibility with Vi."], "readability/old_style_comment"]
["src/nvim/option.c", ["    if (       fnamecmp(p, \"csh\") == 0", "               || fnamecmp(p, \"tcsh\") == 0", "               ) {"], "whitespace/alignment"]
["src/nvim/option.c", ["               || fnamecmp(p, \"tcsh\") == 0", "               ) {", "      if (do_sp) {"], "whitespace/alignment"]
["src/nvim/option.c", ["    } else if (       fnamecmp(p, \"sh\") == 0", "                      || fnamecmp(p, \"ksh\") == 0", "                      || fnamecmp(p, \"mksh\") == 0"], "whitespace/alignment"]
["src/nvim/option.c", ["                      || fnamecmp(p, \"ksh\") == 0", "                      || fnamecmp(p, \"mksh\") == 0", "                      || fnamecmp(p, \"pdksh\") == 0"], "whitespace/alignment"]
["src/nvim/option.c", ["                      || fnamecmp(p, \"mksh\") == 0", "                      || fnamecmp(p, \"pdksh\") == 0", "                      || fnamecmp(p, \"zsh\") == 0"], "whitespace/alignment"]
["src/nvim/option.c", ["                      || fnamecmp(p, \"pdksh\") == 0", "                      || fnamecmp(p, \"zsh\") == 0", "                      || fnamecmp(p, \"zsh-beta\") == 0"], "whitespace/alignment"]
["src/nvim/option.c", ["                      || fnamecmp(p, \"zsh\") == 0", "                      || fnamecmp(p, \"zsh-beta\") == 0", "                      || fnamecmp(p, \"bash\") == 0"], "whitespace/alignment"]
["src/nvim/option.c", ["                      || fnamecmp(p, \"zsh-beta\") == 0", "                      || fnamecmp(p, \"bash\") == 0", "                      || fnamecmp(p, \"fish\") == 0"], "whitespace/alignment"]
["src/nvim/option.c", ["                      || fnamecmp(p, \"bash\") == 0", "                      || fnamecmp(p, \"fish\") == 0", "                      ) {"], "whitespace/alignment"]
["src/nvim/option.c", ["                      || fnamecmp(p, \"fish\") == 0", "                      ) {", "      if (do_sp) {"], "whitespace/alignment"]
["src/nvim/option.c", ["", "  /*", "   * If GUI is (going to be) used, we can always set the window title and"], "readability/old_style_comment"]
["src/nvim/option.c", ["        && !(opt_flags & OPT_MODELINE)) {", "      /*", "       * \":set all\"  show all options."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "      /* Skip all options that are not window-local (used when showing", "       * an already loaded buffer in a window). */"], "readability/old_style_comment"]
["src/nvim/option.c", ["       * an already loaded buffer in a window). */", "      if ((opt_flags & OPT_WINONLY)", "          && (opt_idx < 0 || options[opt_idx].var != VAR_WIN))"], "readability/braces"]
["src/nvim/option.c", ["", "      /*", "       * allow '=' and ':' as MSDOS command.com allows only one"], "readability/old_style_comment"]
["src/nvim/option.c", ["              && !(flags & P_BOOL))) {", "        /*", "         * print value"], "readability/old_style_comment"]
["src/nvim/option.c", ["        }", "        if (nextchar != '?'", "            && nextchar != NUL && !ascii_iswhite(afterchar))"], "readability/braces"]
["src/nvim/option.c", ["", "          /*", "           * \":set opt!\": invert"], "readability/old_style_comment"]
["src/nvim/option.c", ["          } else {", "            /*", "             * \":set invopt\": invert"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "            /* When using \":set opt=val\" for a global option", "             * with a local value the local value will be"], "readability/old_style_comment"]
["src/nvim/option.c", ["             * reset, use the global value here. */", "            if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0", "                && ((int)options[opt_idx].indir & PV_BOTH))"], "readability/braces"]
["src/nvim/option.c", ["", "            /* The old value is kept until we are sure that the", "             * new value is valid. */"], "readability/old_style_comment"]
["src/nvim/option.c", ["              newval = options[opt_idx].def_val[", "                ((flags & P_VI_DEF) || cp_val)", "                ?  VI_DEFAULT : VIM_DEFAULT];"], "whitespace/indent"]
["src/nvim/option.c", ["                ((flags & P_VI_DEF) || cp_val)", "                ?  VI_DEFAULT : VIM_DEFAULT];", "              /* expand environment variables and ~ (since the"], "whitespace/indent"]
["src/nvim/option.c", ["                ?  VI_DEFAULT : VIM_DEFAULT];", "              /* expand environment variables and ~ (since the", "               * default value was already expanded, only"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "              /*", "               * Set 'keywordprg' to \":help\" if an empty"], "readability/old_style_comment"]
["src/nvim/option.c", ["              }", "              /*", "               * Convert 'backspace' number to string, for"], "readability/old_style_comment"]
["src/nvim/option.c", ["               */", "              else if (varp == (char_u *)&p_bs", "                       && ascii_isdigit(**(char_u **)varp)) {"], "whitespace/newline"]
["src/nvim/option.c", ["              }", "              /*", "               * Convert 'whichwrap' number to string, for"], "readability/old_style_comment"]
["src/nvim/option.c", ["               */", "              else if (varp == (char_u *)&p_ww", "                       && ascii_isdigit(*arg)) {"], "whitespace/newline"]
["src/nvim/option.c", ["              }", "              /*", "               * Remove '>' before 'dir' and 'bdir', for"], "readability/old_style_comment"]
["src/nvim/option.c", ["               */", "              else if (  *arg == '>'", "                         && (varp == (char_u *)&p_dir"], "whitespace/newline"]
["src/nvim/option.c", ["              else if (  *arg == '>'", "                         && (varp == (char_u *)&p_dir", "                             || varp == (char_u *)&p_bdir)) {"], "whitespace/alignment"]
["src/nvim/option.c", ["", "              /*", "               * Copy the new string into allocated memory."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "              /*", "               * Copy the string, skip over escaped chars."], "readability/old_style_comment"]
["src/nvim/option.c", ["              while (*arg && !ascii_iswhite(*arg)) {", "                if (*arg == '\\\\' && arg[1] != NUL", "#ifdef BACKSLASH_IN_FILENAME"], "readability/braces"]
["src/nvim/option.c", ["", "              /*", "               * Expand environment variables and ~."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "              /* locate newval[] in origval[] when removing it", "               * and when adding to avoid duplicates */"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "              /* concatenate the two strings; add a ',' if", "               * needed */"], "readability/old_style_comment"]
["src/nvim/option.c", ["                  memmove(newval + i + comma, newval,", "                      STRLEN(newval) + 1);", "                  memmove(newval, origval, (size_t)i);"], "whitespace/alignment"]
["src/nvim/option.c", ["", "              /* Remove newval[] from origval[]. (Note: \"i\" has", "               * been set above and is used here). */"], "readability/old_style_comment"]
["src/nvim/option.c", ["skip:", "      /*", "       * Advance to next argument."], "readability/old_style_comment"]
["src/nvim/option.c", ["  return OK;", "}", ""], "readability/fn_size"]
["src/nvim/option.c", ["", "  /* When an option is set in the sandbox, from a modeline or in secure mode", "   * set the P_INSECURE flag.  Otherwise, if a new value is stored reset the"], "readability/old_style_comment"]
["src/nvim/option.c", ["{", "  /*", "   * The option values that are changed when 'bin' changes are"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * Expanding this with NameBuff, expand_env() must not be passed IObuff."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  assert((void *) options[idx].var != (void *) &p_shada);", ""], "whitespace/cast"]
["src/nvim/option.c", ["", "    /* When setting both values of a global option with a local value,", "    * make the local value empty, so that the global value is used. */"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /* Get the global option to compare with, otherwise we would have to check", "   * two values for all local options. */"], "readability/old_style_comment"]
["src/nvim/option.c", ["      }", "    } else", "      errmsg = e_invarg;"], "readability/braces"]
["src/nvim/option.c", ["      ml_setflags(curbuf);", "      /* Redraw needed when switching to/from \"mac\": a CR in the text", "       * will be displayed differently. */"], "readability/old_style_comment"]
["src/nvim/option.c", ["            errmsg = errbuf;", "          } else", "            errmsg = (char_u *)\"\";"], "readability/braces"]
["src/nvim/option.c", ["    for (s = *varp; *s; ) {", "      while (*s == ',' || *s == ' ')", "        s++;"], "readability/braces"]
["src/nvim/option.c", ["            errmsg = errbuf;", "          } else", "            errmsg = (char_u *)\"\";"], "readability/braces"]
["src/nvim/option.c", ["", "  /*", "   * If error detected, restore the previous value."], "readability/old_style_comment"]
["src/nvim/option.c", ["    *varp = oldval;", "    /*", "     * When resetting some values, need to act on it."], "readability/old_style_comment"]
["src/nvim/option.c", ["        && ((int)options[opt_idx].indir & PV_BOTH)) {", "      /* global option with local value set to use global value; free", "       * the local value and make it empty */"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "    /*", "     * Trigger the autocommand only after setting the flags."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "      /*", "       * Source the spell/LANG.vim in 'runtimepath'."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  if (curwin->w_curswant != MAXCOL", "      && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0)"], "readability/braces"]
["src/nvim/option.c", ["    wp->w_p_cc_cols = xmalloc(sizeof(int) * (count + 1));", "    /* sort the columns for faster usage on screen redraw inside", "     * win_line() */"], "readability/old_style_comment"]
["src/nvim/option.c", ["      s++;", "      while (*s && ascii_isdigit(*s))", "        s++;"], "readability/braces"]
["src/nvim/option.c", ["      s++;", "      while (*s != '}' && *s)", "        s++;"], "readability/braces"]
["src/nvim/option.c", ["#ifdef BACKSLASH_IN_FILENAME", "  else if ((int *)varp == &p_ssl) {", "    if (p_ssl) {"], "readability/braces"]
["src/nvim/option.c", ["#endif", "  else if ((int *)varp == &curwin->w_p_wrap) {", "    // If 'wrap' is set, set w_leftcol to zero."], "readability/braces"]
["src/nvim/option.c", ["    if (curwin->w_p_arab) {", "      /*", "       * 'arabic' is set, handle various sub-settings."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "      /* Arabic requires a utf-8 encoding, inform the user if its not", "       * set. */"], "readability/old_style_comment"]
["src/nvim/option.c", ["    } else {", "      /*", "       * 'arabic' is reset, handle various sub-settings."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "        /* 'arabicshape' isn't reset, it is a global option and", "         * another window may still need it \"on\". */"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "      /* 'delcombine' isn't reset, it is a global option and another", "       * window may still want it \"on\". */"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * End of handling side effects for bool options."], "readability/old_style_comment"]
["src/nvim/option.c", ["    apply_autocmds(EVENT_OPTIONSET,", "                   (char_u *) options[opt_idx].fullname,", "                   NULL, false, NULL);"], "whitespace/cast"]
["src/nvim/option.c", ["      vim_snprintf((char *)errbuf, errbuflen,", "          _(\"E593: Need at least %d lines\"), min_rows());", "      errmsg = errbuf;"], "whitespace/alignment"]
["src/nvim/option.c", ["      vim_snprintf((char *)errbuf, errbuflen,", "          _(\"E594: Need at least %d columns\"), MIN_COLUMNS);", "      errmsg = errbuf;"], "whitespace/alignment"]
["src/nvim/option.c", ["    apply_autocmds(EVENT_OPTIONSET,", "                   (char_u *) options[opt_idx].fullname,", "                   NULL, false, NULL);"], "whitespace/cast"]
["src/nvim/option.c", ["    p = options[0].fullname;", "    for (short int i = 1; (s = options[i].fullname) != NULL; i++) {", "      if (s[0] != p[0]) {"], "runtime/int"]
["src/nvim/option.c", ["    } else if (p->flags & P_NUM) {", "      *numval = *(long *) varp;", "    } else {"], "whitespace/cast"]
["src/nvim/option.c", ["", "    /*", "     * display the items"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * Some options are never written:"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "        /* Do not store options like 'bufhidden' and 'syntax' in a vimrc", "         * file, they are always buffer-specific. */"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "        /* Round 1: fresh value for window-local options.", "         * Round 2: other values */"], "readability/old_style_comment"]
["src/nvim/option.c", ["  if (*valuep != NULL) {", "    /* Output 'pastetoggle' as key names.  For other", "     * options some characters have to be escaped with"], "readability/old_style_comment"]
["src/nvim/option.c", ["  switch ((int)p->indir)", "  {", "    // global option with local value: use local value if it's been set"], "whitespace/braces"]
["src/nvim/option.c", ["", "  /*", "   * Skip this when the option defaults have not been set yet.  Happens when"], "readability/old_style_comment"]
["src/nvim/option.c", ["    if (should_copy || (flags & BCO_ALWAYS)) {", "      /* Don't copy the options specific to a help buffer when", "      * BCO_NOHELP is given or the options were initialized already"], "readability/old_style_comment"]
["src/nvim/option.c", ["      buf->b_kmap_state |= KEYMAP_INIT;", "      /* This isn't really an option, but copying the langmap and IME", "      * state from the current buffer is better than resetting it. */"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "      /* options that are normally global but also have a local value", "       * are not copied, start using the global value */"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "      /*", "       * Don't copy the options set by ex_help(), use the saved values,"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "    /*", "     * When the options should be copied (ignoring BCO_ALWAYS), set the"], "readability/old_style_comment"]
["src/nvim/option.c", ["static int expand_option_idx = -1;", "static char_u expand_option_name[5] = {'t', '_', NUL, NUL, NUL};", "static int expand_option_flags = 0;"], "whitespace/braces"]
["src/nvim/option.c", ["static int expand_option_idx = -1;", "static char_u expand_option_name[5] = {'t', '_', NUL, NUL, NUL};", "static int expand_option_flags = 0;"], "whitespace/braces"]
["src/nvim/option.c", ["      xp->xp_context = EXPAND_DIRECTORIES;", "      if (p == (char_u *)&p_path", "          || p == (char_u *)&p_cdpath"], "readability/braces"]
["src/nvim/option.c", ["        xp->xp_backslash = XP_BS_THREE;", "      else", "        xp->xp_backslash = XP_BS_ONE;"], "readability/braces"]
["src/nvim/option.c", ["", "  /* For an option that is a list of file names, find the start of the", "   * last file name. */"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "int ExpandSettings(expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file)", "{"], "whitespace/line_length"]
["src/nvim/option.c", ["", "  /* do this loop twice:", "   * loop == 0: count the number of matching options"], "readability/old_style_comment"]
["src/nvim/option.c", ["    }", "    for (size_t opt_idx = 0; (str = (char_u *)options[opt_idx].fullname) != NULL;", "         opt_idx++) {"], "whitespace/line_length"]
["src/nvim/option.c", ["          num_normal++;", "        } else", "          (*file)[count++] = vim_strsave(str);"], "readability/braces"]
["src/nvim/option.c", ["", "  /*", "   * For a terminal key code expand_option_idx is < 0."], "readability/old_style_comment"]
["src/nvim/option.c", ["#ifdef BACKSLASH_IN_FILENAME", "  /* For MS-Windows et al. we don't double backslashes at the start and", "   * before a file name character. */"], "readability/old_style_comment"]
["src/nvim/option.c", ["               \"%\" PRId64,", "               (int64_t)*(long *)varp);", "    }"], "whitespace/operators"]
["src/nvim/option.c", ["        EMSG2(_(\"E357: 'langmap': Matching character missing for %s\"),", "            transchar(from));", "        return;"], "whitespace/alignment"]
["src/nvim/option.c", ["              EMSG2(_(", "                      \"E358: 'langmap': Extra characters after semicolon: %s\"),", "                  p);"], "whitespace/indent"]
["src/nvim/option.c", ["                      \"E358: 'langmap': Extra characters after semicolon: %s\"),", "                  p);", "              return;"], "whitespace/alignment"]
["src/nvim/option.c", ["  if (p_paste) {", "    /*", "     * Paste switched from off to on."], "readability/old_style_comment"]
["src/nvim/option.c", ["  char_u *p = wp->w_p_briopt;", "  while (*p != NUL)", "  {"], "readability/braces"]
["src/nvim/option.c", ["  while (*p != NUL)", "  {", "    if (STRNCMP(p, \"shift:\", 6) == 0"], "whitespace/braces"]
["src/nvim/option.c", ["  {", "    if (STRNCMP(p, \"shift:\", 6) == 0", "        && ((p[6] == '-' && ascii_isdigit(p[7])) || ascii_isdigit(p[6])))"], "readability/braces"]
["src/nvim/option.c", ["        && ((p[6] == '-' && ascii_isdigit(p[7])) || ascii_isdigit(p[6])))", "    {", "      p += 6;"], "whitespace/braces"]
["src/nvim/option.c", ["    }", "    else if (STRNCMP(p, \"min:\", 4) == 0 && ascii_isdigit(p[4]))", "    {"], "whitespace/newline"]
["src/nvim/option.c", ["    else if (STRNCMP(p, \"min:\", 4) == 0 && ascii_isdigit(p[4]))", "    {", "      p += 4;"], "whitespace/braces"]
["src/nvim/option.c", ["    }", "    else if (STRNCMP(p, \"sbr\", 3) == 0)", "    {"], "whitespace/newline"]
["src/nvim/option.c", ["    else if (STRNCMP(p, \"sbr\", 3) == 0)", "    {", "      p += 3;"], "whitespace/braces"]
["src/nvim/option.c", ["    } else {", "      type = \"\"; def = NIL;", "    }"], "whitespace/newline"]
