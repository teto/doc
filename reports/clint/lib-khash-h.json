["src/nvim/lib/khash.h", ["// marker so line numbers and indices both start at 1", "/* The MIT License", ""], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*", "  Example:"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*", "  2013-05-02 (0.2.8):"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*!", "  @header"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/* compiler specific configuration */", ""], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["#else", "typedef unsigned long long khint64_t;", "#endif"], "runtime/int"]
["src/nvim/lib/khash.h", ["", "#define __ac_isempty(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&2)", "#define __ac_isdel(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&1)"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_isempty(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&2)", "#define __ac_isdel(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&1)", "#define __ac_iseither(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&3)"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_isdel(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&1)", "#define __ac_iseither(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&3)", "#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(khint_t)(1ul<<((i&0xfU)<<1)))"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_iseither(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&3)", "#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(khint_t)(1ul<<((i&0xfU)<<1)))", "#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(khint_t)(2ul<<((i&0xfU)<<1)))"], "whitespace/line_length"]
["src/nvim/lib/khash.h", ["#define __ac_iseither(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&3)", "#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(khint_t)(1ul<<((i&0xfU)<<1)))", "#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(khint_t)(2ul<<((i&0xfU)<<1)))"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(khint_t)(1ul<<((i&0xfU)<<1)))", "#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(khint_t)(2ul<<((i&0xfU)<<1)))", "#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(khint_t)(3ul<<((i&0xfU)<<1)))"], "whitespace/line_length"]
["src/nvim/lib/khash.h", ["#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(khint_t)(1ul<<((i&0xfU)<<1)))", "#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(khint_t)(2ul<<((i&0xfU)<<1)))", "#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(khint_t)(3ul<<((i&0xfU)<<1)))"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(khint_t)(2ul<<((i&0xfU)<<1)))", "#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(khint_t)(3ul<<((i&0xfU)<<1)))", "#define __ac_set_isdel_true(flag, i) (flag[i>>4]|=(khint_t)1ul<<((i&0xfU)<<1))"], "whitespace/line_length"]
["src/nvim/lib/khash.h", ["#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(khint_t)(2ul<<((i&0xfU)<<1)))", "#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(khint_t)(3ul<<((i&0xfU)<<1)))", "#define __ac_set_isdel_true(flag, i) (flag[i>>4]|=(khint_t)1ul<<((i&0xfU)<<1))"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(khint_t)(3ul<<((i&0xfU)<<1)))", "#define __ac_set_isdel_true(flag, i) (flag[i>>4]|=(khint_t)1ul<<((i&0xfU)<<1))", ""], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#ifndef kroundup32", "#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))", "#endif"], "whitespace/line_length"]
["src/nvim/lib/khash.h", ["#ifndef kcalloc", "#define kcalloc(N,Z) xcalloc(N,Z)", "#endif"], "whitespace/comma"]
["src/nvim/lib/khash.h", ["#ifndef krealloc", "#define krealloc(P,Z) xrealloc(P,Z)", "#endif"], "whitespace/comma"]
["src/nvim/lib/khash.h", ["#define __KHASH_TYPE(name, khkey_t, khval_t) \\", "\ttypedef struct { \\", "\t\tkhint_t n_buckets, size, n_occupied, upper_bound; \\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\ttypedef struct { \\", "\t\tkhint_t n_buckets, size, n_occupied, upper_bound; \\", "\t\tkhint32_t *flags; \\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t\tkhint_t n_buckets, size, n_occupied, upper_bound; \\", "\t\tkhint32_t *flags; \\", "\t\tkhkey_t *keys; \\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t\tkhint32_t *flags; \\", "\t\tkhkey_t *keys; \\", "\t\tkhval_t *vals; \\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t\tkhkey_t *keys; \\", "\t\tkhval_t *vals; \\", "\t} kh_##name##_t;"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t\tkhval_t *vals; \\", "\t} kh_##name##_t;", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["  SCOPE kh_##name##_t *kh_init_##name(void) { \\", "    return (kh_##name##_t*)kcalloc(1, sizeof(kh_##name##_t)); \\", "  } \\"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["      mask = h->n_buckets - 1; \\", "      k = __hash_func(key); i = k & mask; \\", "      last = i; \\"], "whitespace/newline"]
["src/nvim/lib/khash.h", ["      } else { /* hash table size to be changed (shrink or expand); rehash */ \\", "        new_flags = (khint32_t*)kmalloc(__ac_fsize(new_n_buckets) \\", "                                        * sizeof(khint32_t)); \\"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["        if (h->n_buckets < new_n_buckets) { /* expand */ \\", "          khkey_t *new_keys = (khkey_t*)krealloc( \\", "              (void *)h->keys, new_n_buckets * sizeof(khkey_t)); \\"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["          if (kh_is_map) { \\", "            khval_t *new_vals = (khval_t*)krealloc( \\", "                (void *)h->vals, new_n_buckets * sizeof(khval_t)); \\"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["    if (j) { /* rehashing is needed */ \\", "      for (j = 0; j != h->n_buckets; ++j) { \\", "        if (__ac_iseither(h->flags, j) == 0) { \\"], "readability/increment"]
["src/nvim/lib/khash.h", ["      if (h->n_buckets > new_n_buckets) { /* shrink the hash table */ \\", "        h->keys = (khkey_t*)krealloc((void *)h->keys, \\", "                                     new_n_buckets * sizeof(khkey_t)); \\"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["        if (kh_is_map) { \\", "          h->vals = (khval_t*)krealloc((void *)h->vals, \\", "                                       new_n_buckets * sizeof(khval_t)); \\"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["      __ac_set_isdel_true(h->flags, x); \\", "      --h->size; \\", "    } \\"], "readability/increment"]
["src/nvim/lib/khash.h", ["", "#define KHASH_DECLARE(name, khkey_t, khval_t)\t\t \t\t\t\t\t\\", "\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define KHASH_DECLARE(name, khkey_t, khval_t)\t\t \t\t\t\t\t\\", "\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\", "\t__KHASH_PROTOTYPES(name, khkey_t, khval_t)"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\", "\t__KHASH_PROTOTYPES(name, khkey_t, khval_t)", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["", "#define KHASH_INIT2(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \\", "\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\"], "whitespace/line_length"]
["src/nvim/lib/khash.h", ["#define KHASH_INIT2(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \\", "\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\", "\t__KHASH_IMPL(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\", "\t__KHASH_IMPL(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\", "\t__KHASH_IMPL(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)", ""], "whitespace/line_length"]
["src/nvim/lib/khash.h", ["", "#define KHASH_INIT(name, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \\", "\tKHASH_INIT2(name, static kh_inline, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)"], "whitespace/line_length"]
["src/nvim/lib/khash.h", ["#define KHASH_INIT(name, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \\", "\tKHASH_INIT2(name, static kh_inline, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define KHASH_INIT(name, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \\", "\tKHASH_INIT2(name, static kh_inline, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)", ""], "whitespace/line_length"]
["src/nvim/lib/khash.h", ["", "/* --- BEGIN OF HASH FUNCTIONS --- */", ""], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Integer hash function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["#define kh_int_hash_func(key) (khint32_t)(key)", "/*! @function", "  @abstract     Integer comparison function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["#define kh_int_hash_equal(a, b) ((a) == (b))", "/*! @function", "  @abstract     64-bit integer hash function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", [" */", "#define kh_int64_hash_func(key) (khint32_t)((key)>>33^(key)^(key)<<11)", "/*! @function"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define kh_int64_hash_func(key) (khint32_t)((key)>>33^(key)^(key)<<11)", "/*! @function", "  @abstract     64-bit integer comparison function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["#define kh_int64_hash_equal(a, b) ((a) == (b))", "/*! @function", "  @abstract     const char* hash function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["{", "\tkhint_t h = (khint_t)*s;", "\tif (h) for (++s ; *s; ++s) h = (h << 5) - h + (uint8_t)*s;"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["{", "\tkhint_t h = (khint_t)*s;", "\tif (h) for (++s ; *s; ++s) h = (h << 5) - h + (uint8_t)*s;"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["\tkhint_t h = (khint_t)*s;", "\tif (h) for (++s ; *s; ++s) h = (h << 5) - h + (uint8_t)*s;", "\treturn h;"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\tkhint_t h = (khint_t)*s;", "\tif (h) for (++s ; *s; ++s) h = (h << 5) - h + (uint8_t)*s;", "\treturn h;"], "readability/braces"]
["src/nvim/lib/khash.h", ["\tkhint_t h = (khint_t)*s;", "\tif (h) for (++s ; *s; ++s) h = (h << 5) - h + (uint8_t)*s;", "\treturn h;"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["\tkhint_t h = (khint_t)*s;", "\tif (h) for (++s ; *s; ++s) h = (h << 5) - h + (uint8_t)*s;", "\treturn h;"], "readability/increment"]
["src/nvim/lib/khash.h", ["\tif (h) for (++s ; *s; ++s) h = (h << 5) - h + (uint8_t)*s;", "\treturn h;", "}"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["}", "/*! @function", "  @abstract     Another interface to const char* hash function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["#define kh_str_hash_func(key) __ac_X31_hash_string(key)", "/*! @function", "  @abstract     Const char* comparison function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/* --- END OF HASH FUNCTIONS --- */", ""], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/* Other convenient macros... */", ""], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*!", "  @abstract Type of the hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Initiate a hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Destroy a hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Free memory referenced directly inside a hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Reset a hash table without deallocating memory."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Resize a hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Insert a key to the hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Retrieve a key from the hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Remove a key from the hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Test whether a bucket contains data."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Get key given an iterator"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Get value given an iterator"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Alias of kh_val()"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Get the start iterator"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Get the end iterator"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Get the number of elements in the hash table"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Get the number of buckets in the hash table"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Iterate over the entries in the hash table"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", [" */", "#define kh_foreach(h, kvar, vvar, code) { khint_t __i;\t\t\\", "\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define kh_foreach(h, kvar, vvar, code) { khint_t __i;\t\t\\", "\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\", "\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define kh_foreach(h, kvar, vvar, code) { khint_t __i;\t\t\\", "\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\", "\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\"], "readability/increment"]
["src/nvim/lib/khash.h", ["\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\", "\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(kvar) = kh_key(h,__i);\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\", "\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(kvar) = kh_key(h,__i);\t\t\t\t\t\t\t\t\\"], "readability/braces"]
["src/nvim/lib/khash.h", ["\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\", "\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(kvar) = kh_key(h,__i);\t\t\t\t\t\t\t\t\\"], "whitespace/comma"]
["src/nvim/lib/khash.h", ["\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(kvar) = kh_key(h,__i);\t\t\t\t\t\t\t\t\\", "\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(kvar) = kh_key(h,__i);\t\t\t\t\t\t\t\t\\", "\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\"], "whitespace/comma"]
["src/nvim/lib/khash.h", ["\t\t(kvar) = kh_key(h,__i);\t\t\t\t\t\t\t\t\\", "\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\", "\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t\t(kvar) = kh_key(h,__i);\t\t\t\t\t\t\t\t\\", "\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\", "\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/comma"]
["src/nvim/lib/khash.h", ["\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\", "\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t} }"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t} }", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Iterate over the values in the hash table"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", [" */", "#define kh_foreach_value(h, vvar, code) { khint_t __i;\t\t\\", "\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define kh_foreach_value(h, vvar, code) { khint_t __i;\t\t\\", "\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\", "\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define kh_foreach_value(h, vvar, code) { khint_t __i;\t\t\\", "\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\", "\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\"], "readability/increment"]
["src/nvim/lib/khash.h", ["\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\", "\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\", "\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\"], "readability/braces"]
["src/nvim/lib/khash.h", ["\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\", "\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\"], "whitespace/comma"]
["src/nvim/lib/khash.h", ["\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\", "\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\", "\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/comma"]
["src/nvim/lib/khash.h", ["\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\", "\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t} }"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t} }", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Iterate over the keys in the hash table"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/* More conenient interfaces */", ""], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Instantiate a hash set containing integer keys"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", [" */", "#define KHASH_SET_INIT_INT(name)\t\t\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, khint32_t, char, 0, kh_int_hash_func, kh_int_hash_equal)"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define KHASH_SET_INIT_INT(name)\t\t\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, khint32_t, char, 0, kh_int_hash_func, kh_int_hash_equal)", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Instantiate a hash map containing integer keys"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", [" */", "#define KHASH_MAP_INIT_INT(name, khval_t)\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, khint32_t, khval_t, 1, kh_int_hash_func, kh_int_hash_equal)"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define KHASH_MAP_INIT_INT(name, khval_t)\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, khint32_t, khval_t, 1, kh_int_hash_func, kh_int_hash_equal)", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Instantiate a hash map containing 64-bit integer keys"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", [" */", "#define KHASH_SET_INIT_INT64(name)\t\t\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, khint64_t, char, 0, kh_int64_hash_func, kh_int64_hash_equal)"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define KHASH_SET_INIT_INT64(name)\t\t\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, khint64_t, char, 0, kh_int64_hash_func, kh_int64_hash_equal)", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Instantiate a hash map containing 64-bit integer keys"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", [" */", "#define KHASH_MAP_INIT_INT64(name, khval_t)\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, khint64_t, khval_t, 1, kh_int64_hash_func, kh_int64_hash_equal)"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define KHASH_MAP_INIT_INT64(name, khval_t)\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, khint64_t, khval_t, 1, kh_int64_hash_func, kh_int64_hash_equal)", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define KHASH_MAP_INIT_INT64(name, khval_t)\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, khint64_t, khval_t, 1, kh_int64_hash_func, kh_int64_hash_equal)", ""], "whitespace/line_length"]
["src/nvim/lib/khash.h", ["typedef const char *kh_cstr_t;", "/*! @function", "  @abstract     Instantiate a hash map containing const char* keys"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", [" */", "#define KHASH_SET_INIT_STR(name)\t\t\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, kh_cstr_t, char, 0, kh_str_hash_func, kh_str_hash_equal)"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define KHASH_SET_INIT_STR(name)\t\t\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, kh_cstr_t, char, 0, kh_str_hash_func, kh_str_hash_equal)", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Instantiate a hash map containing const char* keys"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "  @abstract     Return a literal for an empty hash table."], "readability/old_style_comment"]
