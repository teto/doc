["src/nvim/memfile.c", ["  // check block number exists", "  if (nr >= mfp->mf_blocknr_max || nr <= mfp->mf_blocknr_min)", "    return NULL;"], "readability/braces"]
["src/nvim/memfile.c", ["  if (hp == NULL) {                             // not in the hash list", "    if (nr < 0 || nr >= mfp->mf_infile_count)   // can't be in the file", "      return NULL;"], "readability/braces"]
["src/nvim/memfile.c", ["  hp->bh_flags = flags;", "  if (infile)", "    mf_trans_add(mfp, hp);      // may translate negative in positive nr"], "readability/braces"]
["src/nvim/memfile.c", ["  bhdr_T *hp;", "  for (hp = mfp->mf_used_last; hp != NULL; hp = hp->bh_prev)", "    if (((flags & MFS_ALL) || hp->bh_bnum >= 0)"], "readability/braces"]
["src/nvim/memfile.c", ["                             && hp->bh_bnum < mfp->mf_infile_count))) {", "      if ((flags & MFS_ZERO) && hp->bh_bnum != 0)", "        continue;"], "readability/braces"]
["src/nvim/memfile.c", ["      if (mf_write(mfp, hp) == FAIL) {", "        if (status == FAIL)     // double error: quit syncing", "          break;"], "readability/braces"]
["src/nvim/memfile.c", ["      if (flags & MFS_STOP) {   // Stop when char available now.", "        if (os_char_avail())", "          break;"], "readability/braces"]
["src/nvim/memfile.c", ["      }", "      if (got_int)", "        break;"], "readability/braces"]
["src/nvim/memfile.c", ["  // In case of an error, dirty flag is also set, to avoid trying all the time.", "  if (hp == NULL || status == FAIL)", "    mfp->mf_dirty = false;"], "readability/braces"]
["src/nvim/memfile.c", ["{", "  if (hp->bh_next == NULL)                 // last block in used list", "    mfp->mf_used_last = hp->bh_prev;"], "readability/braces"]
["src/nvim/memfile.c", ["    mfp->mf_used_last = hp->bh_prev;", "  else", "    hp->bh_next->bh_prev = hp->bh_prev;"], "readability/braces"]
["src/nvim/memfile.c", ["", "  if (hp->bh_prev == NULL)                 // first block in used list", "    mfp->mf_used_first = hp->bh_next;"], "readability/braces"]
["src/nvim/memfile.c", ["    mfp->mf_used_first = hp->bh_next;", "  else", "    hp->bh_prev->bh_next = hp->bh_next;"], "readability/braces"]
["src/nvim/memfile.c", ["{", "  if (mfp->mf_fd < 0)       // there is no file, can't read", "    return FAIL;"], "readability/braces"]
["src/nvim/memfile.c", ["", "  if (mfp->mf_fd < 0)       // there is no file, can't write", "    return FAIL;"], "readability/braces"]
["src/nvim/memfile.c", ["", "  if (hp->bh_bnum < 0)      // must assign file block number", "    if (mf_trans_add(mfp, hp) == FAIL)"], "readability/braces"]
["src/nvim/memfile.c", ["  if (hp->bh_bnum < 0)      // must assign file block number", "    if (mf_trans_add(mfp, hp) == FAIL)", "      return FAIL;"], "readability/braces"]
["src/nvim/memfile.c", ["    }", "    if (hp2 == NULL)                // freed block, fill with dummy data", "      page_count = 1;"], "readability/braces"]
["src/nvim/memfile.c", ["      page_count = 1;", "    else", "      page_count = hp2->bh_page_count;"], "readability/braces"]
["src/nvim/memfile.c", ["      /// space becomes available.", "      if (!did_swapwrite_msg)", "        EMSG(_(\"E297: Write error in swap file\"));"], "readability/braces"]
["src/nvim/memfile.c", ["    did_swapwrite_msg = false;", "    if (hp2 != NULL)                               // written a non-dummy block", "      hp2->bh_flags &= ~BH_DIRTY;"], "readability/braces"]
["src/nvim/memfile.c", ["      hp2->bh_flags &= ~BH_DIRTY;", "    if (nr + (blocknr_T)page_count > mfp->mf_infile_count)  // appended to file", "      mfp->mf_infile_count = nr + page_count;"], "readability/braces"]
["src/nvim/memfile.c", ["      mfp->mf_infile_count = nr + page_count;", "    if (nr == hp->bh_bnum)                         // written the desired block", "      break;"], "readability/braces"]
["src/nvim/memfile.c", ["{", "  if (hp->bh_bnum >= 0)                     // it's already positive", "    return OK;"], "readability/braces"]
["src/nvim/memfile.c", ["", "  if (np == NULL)    // not found", "    return old_nr;"], "readability/braces"]
["src/nvim/memfile.c", ["  mf_hashitem_T *mhi = mht->mht_buckets[(size_t)key & mht->mht_mask];", "  while (mhi != NULL && mhi->mhi_key != key)", "    mhi = mhi->mhi_next;"], "readability/braces"]
["src/nvim/memfile.c", ["  mhi->mhi_prev = NULL;", "  if (mhi->mhi_next != NULL)", "    mhi->mhi_next->mhi_prev = mhi;"], "readability/braces"]
["src/nvim/memfile.c", ["{", "  if (mhi->mhi_prev == NULL)", "    mht->mht_buckets[(size_t)mhi->mhi_key & mht->mht_mask] ="], "readability/braces"]
["src/nvim/memfile.c", ["      mhi->mhi_next;", "  else", "    mhi->mhi_prev->mhi_next = mhi->mhi_next;"], "readability/braces"]
["src/nvim/memfile.c", ["", "  if (mhi->mhi_next != NULL)", "    mhi->mhi_next->mhi_prev = mhi->mhi_prev;"], "readability/braces"]
["src/nvim/memfile.c", ["  int shift = 0;", "  while ((mht->mht_mask >> shift) != 0)", "    shift++;"], "readability/braces"]
["src/nvim/memfile.c", ["", "    for (size_t j = 0; j < MHT_GROWTH_FACTOR; j++)", "      if (tails[j] != NULL)"], "readability/braces"]
["src/nvim/memfile.c", ["    for (size_t j = 0; j < MHT_GROWTH_FACTOR; j++)", "      if (tails[j] != NULL)", "        tails[j]->mhi_next = NULL;"], "readability/braces"]
["src/nvim/memfile.c", ["", "  if (mht->mht_buckets != mht->mht_small_buckets)", "    xfree(mht->mht_buckets);"], "readability/braces"]
