["src/nvim/ops.c", ["", "/*", " * ops.c: implementation of various operators: op_shift, op_delete, op_tilde,"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "static yankreg_T *y_previous = NULL; /* ptr to last written yankreg */", ""], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * structure used by block_prep, op_delete and op_yank for blockwise operators"], "readability/old_style_comment"]
["src/nvim/ops.c", ["struct block_def {", "  int startspaces;              /* 'extra' cols before first char */", "  int endspaces;                /* 'extra' cols after last char */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int startspaces;              /* 'extra' cols before first char */", "  int endspaces;                /* 'extra' cols after last char */", "  int textlen;                  /* chars in block */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int endspaces;                /* 'extra' cols after last char */", "  int textlen;                  /* chars in block */", "  char_u      *textstart;       /* pointer to 1st char (partially) in block */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int textlen;                  /* chars in block */", "  char_u      *textstart;       /* pointer to 1st char (partially) in block */", "  colnr_T textcol;              /* index of chars (partially) in block */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  char_u      *textstart;       /* pointer to 1st char (partially) in block */", "  colnr_T textcol;              /* index of chars (partially) in block */", "  colnr_T start_vcol;           /* start col of 1st char wholly inside block */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  colnr_T textcol;              /* index of chars (partially) in block */", "  colnr_T start_vcol;           /* start col of 1st char wholly inside block */", "  colnr_T end_vcol;             /* start col of 1st char wholly after block */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  colnr_T start_vcol;           /* start col of 1st char wholly inside block */", "  colnr_T end_vcol;             /* start col of 1st char wholly after block */", "  int is_short;                 /* TRUE if line is too short to fit in block */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  colnr_T end_vcol;             /* start col of 1st char wholly after block */", "  int is_short;                 /* TRUE if line is too short to fit in block */", "  int is_MAX;                   /* TRUE if curswant==MAXCOL when starting */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int is_short;                 /* TRUE if line is too short to fit in block */", "  int is_MAX;                   /* TRUE if curswant==MAXCOL when starting */", "  int is_oneChar;               /* TRUE if block within one character */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int is_MAX;                   /* TRUE if curswant==MAXCOL when starting */", "  int is_oneChar;               /* TRUE if block within one character */", "  int pre_whitesp;              /* screen cols of ws before block */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int is_oneChar;               /* TRUE if block within one character */", "  int pre_whitesp;              /* screen cols of ws before block */", "  int pre_whitesp_c;            /* chars of ws before block */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int pre_whitesp;              /* screen cols of ws before block */", "  int pre_whitesp_c;            /* chars of ws before block */", "  colnr_T end_char_vcols;       /* number of vcols of post-block char */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int pre_whitesp_c;            /* chars of ws before block */", "  colnr_T end_char_vcols;       /* number of vcols of post-block char */", "  colnr_T start_char_vcols;       /* number of vcols of pre-block char */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  colnr_T end_char_vcols;       /* number of vcols of post-block char */", "  colnr_T start_char_vcols;       /* number of vcols of pre-block char */", "};"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * The names of operators."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Translate a command name into an operator type."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Return TRUE if operator \"op\" always works on whole lines."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Get first operator command character."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Get second operator command character."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * op_shift - handle a shift operation"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (u_save((linenr_T)(oap->start.lnum - 1),", "          (linenr_T)(oap->end.lnum + 1)) == FAIL)"], "readability/braces"]
["src/nvim/ops.c", ["  if (u_save((linenr_T)(oap->start.lnum - 1),", "          (linenr_T)(oap->end.lnum + 1)) == FAIL)", "    return;"], "whitespace/alignment"]
["src/nvim/ops.c", ["    }", "    ++curwin->w_cursor.lnum;", "  }"], "readability/increment"]
["src/nvim/ops.c", ["    curwin->w_cursor.col = block_col;", "  } else if (curs_top) { /* put cursor on first line, for \">>\" */", "    curwin->w_cursor.lnum = oap->start.lnum;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    curwin->w_cursor.lnum = oap->start.lnum;", "    beginline(BL_SOL | BL_FIX);       /* shift_line() may have set cursor.col */", "  } else"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    beginline(BL_SOL | BL_FIX);       /* shift_line() may have set cursor.col */", "  } else", "    --curwin->w_cursor.lnum;            /* put cursor on last line, for \":>\" */"], "readability/braces"]
["src/nvim/ops.c", ["  } else", "    --curwin->w_cursor.lnum;            /* put cursor on last line, for \":>\" */", ""], "readability/old_style_comment"]
["src/nvim/ops.c", ["  } else", "    --curwin->w_cursor.lnum;            /* put cursor on last line, for \":>\" */", ""], "readability/increment"]
["src/nvim/ops.c", ["  if (oap->line_count > p_report) {", "    if (oap->op_type == OP_RSHIFT)", "      s = (char_u *)\">\";"], "readability/braces"]
["src/nvim/ops.c", ["      s = (char_u *)\">\";", "    else", "      s = (char_u *)\"<\";"], "readability/braces"]
["src/nvim/ops.c", ["    if (oap->line_count == 1) {", "      if (amount == 1)", "        sprintf((char *)IObuff, _(\"1 line %sed 1 time\"), s);"], "readability/braces"]
["src/nvim/ops.c", ["      if (amount == 1)", "        sprintf((char *)IObuff, _(\"1 line %sed 1 time\"), s);", "      else"], "runtime/printf"]
["src/nvim/ops.c", ["        sprintf((char *)IObuff, _(\"1 line %sed 1 time\"), s);", "      else", "        sprintf((char *)IObuff, _(\"1 line %sed %d times\"), s, amount);"], "readability/braces"]
["src/nvim/ops.c", ["      else", "        sprintf((char *)IObuff, _(\"1 line %sed %d times\"), s, amount);", "    } else {"], "runtime/printf"]
["src/nvim/ops.c", ["    } else {", "      if (amount == 1)", "        sprintf((char *)IObuff, _(\"%\" PRId64 \" lines %sed 1 time\"),"], "readability/braces"]
["src/nvim/ops.c", ["        sprintf((char *)IObuff, _(\"%\" PRId64 \" lines %sed 1 time\"),", "            (int64_t)oap->line_count, s);", "      else"], "whitespace/alignment"]
["src/nvim/ops.c", ["      if (amount == 1)", "        sprintf((char *)IObuff, _(\"%\" PRId64 \" lines %sed 1 time\"),", "            (int64_t)oap->line_count, s);"], "runtime/printf"]
["src/nvim/ops.c", ["            (int64_t)oap->line_count, s);", "      else", "        sprintf((char *)IObuff, _(\"%\" PRId64 \" lines %sed %d times\"),"], "readability/braces"]
["src/nvim/ops.c", ["        sprintf((char *)IObuff, _(\"%\" PRId64 \" lines %sed %d times\"),", "            (int64_t)oap->line_count, s, amount);", "    }"], "whitespace/alignment"]
["src/nvim/ops.c", ["      else", "        sprintf((char *)IObuff, _(\"%\" PRId64 \" lines %sed %d times\"),", "            (int64_t)oap->line_count, s, amount);"], "runtime/printf"]
["src/nvim/ops.c", ["", "  /*", "   * Set \"'[\" and \"']\" marks."], "readability/old_style_comment"]
["src/nvim/ops.c", ["      i -= amount;", "      if (i < 0)", "        i = 0;"], "readability/braces"]
["src/nvim/ops.c", ["        i = 0;", "    } else", "      i += amount;"], "readability/braces"]
["src/nvim/ops.c", ["      count -= p_sw * amount;", "      if (count < 0)", "        count = 0;"], "readability/braces"]
["src/nvim/ops.c", ["        count = 0;", "    } else", "      count += p_sw * amount;"], "readability/braces"]
["src/nvim/ops.c", ["", "/*", " * Shift one line of the current block one shiftwidth right or left."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  p_ri = 0;                     /* don't want revins in indent */", ""], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (!left) {", "    /*", "     *  1. Get start vcol"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    for (; ascii_iswhite(*bd.textstart); ) {", "      // TODO: is passing bd.textstart for start of the line OK?", "      incr = lbr_chartabsize_adv(bd.textstart, &bd.textstart, (colnr_T)(bd.start_vcol));"], "readability/todo"]
["src/nvim/ops.c", ["      // TODO: is passing bd.textstart for start of the line OK?", "      incr = lbr_chartabsize_adv(bd.textstart, &bd.textstart, (colnr_T)(bd.start_vcol));", "      total += incr;"], "whitespace/line_length"]
["src/nvim/ops.c", ["    }", "    /* OK, now total=all the VWS reqd, and textstart points at the 1st", "     * non-ws char in the block. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    memset(newp + bd.textcol + i, ' ', (size_t)j);", "    /* the end */", "    memmove(newp + bd.textcol + i + j, bd.textstart, (size_t)len);"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /*", "     * Firstly, let's find the first non-whitespace character that is"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /* If \"bd.startspaces\" is set, \"bd.textstart\" points to the character,", "     * the part of which is displayed at the block's beginning. Let's start"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /* Now let's find out how much of the beginning of the line we can", "     * reuse without modification.  */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /* If \"bd.startspaces\" is set, \"bd.textstart\" points to the character", "     * preceding the block. We have to subtract its width to obtain its"], "readability/old_style_comment"]
["src/nvim/ops.c", ["     * column number.  */", "    if (bd.startspaces)", "      verbatim_copy_width -= bd.start_char_vcols;"], "readability/braces"]
["src/nvim/ops.c", ["", "      // TODO: is passing verbatim_copy_end for start of the line OK?", "      incr = lbr_chartabsize(line, verbatim_copy_end, verbatim_copy_width);"], "readability/todo"]
["src/nvim/ops.c", ["      incr = lbr_chartabsize(line, verbatim_copy_end, verbatim_copy_width);", "      if (verbatim_copy_width + incr > destination_col)", "        break;"], "readability/braces"]
["src/nvim/ops.c", ["", "    /* If \"destination_col\" is different from the width of the initial", "    * part of the line that will be copied, it means we encountered a tab"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Insert string \"s\" (b_insert ? before : after) block :AKelly"], "readability/old_style_comment"]
["src/nvim/ops.c", [" */", "static void block_insert(oparg_T *oap, char_u *s, int b_insert, struct block_def *bdp)", "{"], "whitespace/line_length"]
["src/nvim/ops.c", ["      spaces = bdp->startspaces;", "      if (spaces != 0)", "        count = p_ts - 1;         /* we're cutting a TAB */"], "readability/braces"]
["src/nvim/ops.c", ["      if (spaces != 0)", "        count = p_ts - 1;         /* we're cutting a TAB */", "      offset = bdp->textcol;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      offset = bdp->textcol;", "    } else { /* append */", "      p_ts = bdp->end_char_vcols;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      p_ts = bdp->end_char_vcols;", "      if (!bdp->is_short) {     /* spaces = padding after block */", "        spaces = (bdp->endspaces ? p_ts - bdp->endspaces : 0);"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        spaces = (bdp->endspaces ? p_ts - bdp->endspaces : 0);", "        if (spaces != 0)", "          count = p_ts - 1;           /* we're cutting a TAB */"], "readability/braces"]
["src/nvim/ops.c", ["        if (spaces != 0)", "          count = p_ts - 1;           /* we're cutting a TAB */", "        offset = bdp->textcol + bdp->textlen - (spaces != 0);"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        offset = bdp->textcol + bdp->textlen - (spaces != 0);", "      } else { /* spaces = padding to block edge */", "                 /* if $ used, just append to EOL (ie spaces==0) */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      } else { /* spaces = padding to block edge */", "                 /* if $ used, just append to EOL (ie spaces==0) */", "        if (!bdp->is_MAX)"], "readability/old_style_comment"]
["src/nvim/ops.c", ["                 /* if $ used, just append to EOL (ie spaces==0) */", "        if (!bdp->is_MAX)", "          spaces = (oap->end_vcol - bdp->end_vcol) + 1;"], "readability/braces"]
["src/nvim/ops.c", ["", "    if (spaces > 0)", "      offset += count;"], "readability/braces"]
["src/nvim/ops.c", ["    if (lnum == oap->end.lnum) {", "      /* Set \"']\" mark to the end of the block instead of the end of", "       * the insert in the first line.  */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    }", "  }   /* for all lnum */", ""], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * op_reindent - handle reindenting a block of lines."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /* Don't even try when 'modifiable' is off. */", "  if (!MODIFIABLE(curbuf)) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  for (i = oap->line_count - 1; i >= 0 && !got_int; i--) {", "    /* it's a slow thing to do, so give feedback so there's no worry that", "     * the computer's just hung. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    if (i > 1", "        && (i % 50 == 0 || i == oap->line_count - 1)"], "readability/braces"]
["src/nvim/ops.c", ["", "    /*", "     * Be vi-compatible: For lisp indenting the first line is not"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      l = skipwhite(get_cursor_line_ptr());", "      if (*l == NUL)                        /* empty or blank line */", "        amount = 0;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      l = skipwhite(get_cursor_line_ptr());", "      if (*l == NUL)                        /* empty or blank line */", "        amount = 0;"], "readability/braces"]
["src/nvim/ops.c", ["        amount = 0;", "      else", "        amount = how();                     /* get the indent for this line */"], "readability/braces"]
["src/nvim/ops.c", ["      else", "        amount = how();                     /* get the indent for this line */", ""], "readability/old_style_comment"]
["src/nvim/ops.c", ["    }", "    ++curwin->w_cursor.lnum;", "    curwin->w_cursor.col = 0;      /* make sure it's valid */"], "readability/increment"]
["src/nvim/ops.c", ["    ++curwin->w_cursor.lnum;", "    curwin->w_cursor.col = 0;      /* make sure it's valid */", "  }"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /* put cursor on first non-blank of indented line */", "  curwin->w_cursor.lnum = start_lnum;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /* Mark changed lines so that they will be redrawn.  When Visual", "   * highlighting was present, need to continue until the last line.  When"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    i = oap->line_count - (i + 1);", "    if (i == 1)", "      MSG(_(\"1 line indented \"));"], "readability/braces"]
["src/nvim/ops.c", ["      MSG(_(\"1 line indented \"));", "    else", "      smsg(_(\"%\" PRId64 \" lines indented \"), (int64_t)i);"], "readability/braces"]
["src/nvim/ops.c", ["  }", "  /* set '[ and '] marks */", "  curbuf->b_op_start = oap->start;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Keep the last expression line here, for repeating."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Get an expression for the \"\\\"=expr1\" or \"CTRL-R =expr1\""], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Set the expression for the '=' register."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Get the result of the '=' register expression."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (expr_line == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/ops.c", ["", "  /* Make a copy of the expression, because evaluating it may cause it to be", "   * changed. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /* When we are invoked recursively limit the evaluation to 10 levels.", "   * Then return the string as-is. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["   * Then return the string as-is. */", "  if (nested >= 10)", "    return expr_copy;"], "readability/braces"]
["src/nvim/ops.c", ["", "  ++nested;", "  rv = eval_to_string(expr_copy, NULL, TRUE);"], "readability/increment"]
["src/nvim/ops.c", ["  ++nested;", "  rv = eval_to_string(expr_copy, NULL, TRUE);", "  --nested;"], "readability/bool"]
["src/nvim/ops.c", ["  rv = eval_to_string(expr_copy, NULL, TRUE);", "  --nested;", "  xfree(expr_copy);"], "readability/increment"]
["src/nvim/ops.c", ["", "/*", " * Get the '=' register expression itself, without evaluating it."], "readability/old_style_comment"]
["src/nvim/ops.c", ["{", "  if (expr_line == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/ops.c", ["  } else if (mode != YREG_YANK", "      && (regname == 0 || regname == '\"' || regname == '*' || regname == '+')", "      && y_previous != NULL) {"], "whitespace/alignment"]
["src/nvim/ops.c", ["      && (regname == 0 || regname == '\"' || regname == '*' || regname == '+')", "      && y_previous != NULL) {", "    // in case clipboard not available, paste from previous used register"], "whitespace/alignment"]
["src/nvim/ops.c", ["", "/*", " * Start or stop recording into a yank register."], "readability/old_style_comment"]
["src/nvim/ops.c", ["    }", "  } else {                        /* stop recording */", "    /*"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  } else {                        /* stop recording */", "    /*", "     * Get the recorded key hits.  K_SPECIAL and CSI will be escaped, this"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    p = get_recorded();", "    if (p == NULL)", "      retval = FAIL;"], "readability/braces"]
["src/nvim/ops.c", ["      retval = FAIL;", "    else {", "      /* Remove escaping for CSI and K_SPECIAL in multi-byte chars. */"], "readability/braces"]
["src/nvim/ops.c", ["      retval = FAIL;", "    else {", "      /* Remove escaping for CSI and K_SPECIAL in multi-byte chars. */"], "readability/braces"]
["src/nvim/ops.c", ["    else {", "      /* Remove escaping for CSI and K_SPECIAL in multi-byte chars. */", "      vim_unescape_csi(p);"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      /*", "       * We don't want to change the default register here, so save and"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Stuff string \"p\" into yank register \"regname\" as a single line (append if"], "readability/old_style_comment"]
["src/nvim/ops.c", ["{", "  /* check for read-only register */", "  if (regname != 0 && !valid_yank_reg(regname, true)) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  }", "  if (regname == '_') {             /* black hole: don't do anything */", "    xfree(p);"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    int regname,", "    int colon,                      /* insert ':' before each line */", "    int addcr,                      /* always add '\\n' to end of line */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    int colon,                      /* insert ':' before each line */", "    int addcr,                      /* always add '\\n' to end of line */", "    int silent                     /* set \"silent\" flag in typeahead buffer */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    int addcr,                      /* always add '\\n' to end of line */", "    int silent                     /* set \"silent\" flag in typeahead buffer */", ")"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (regname == '@') {                 /* repeat previous one */", "    if (execreg_lastc == NUL) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  }", "  /* check for valid regname */", "  if (regname == '%' || regname == '#' || !valid_yank_reg(regname, false)) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (regname == '_')                   /* black hole: don't stuff anything */", "    return OK;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (regname == '_')                   /* black hole: don't stuff anything */", "    return OK;"], "readability/braces"]
["src/nvim/ops.c", ["", "  if (regname == ':') {                 /* use last command line */", "    if (last_cmdline == NULL) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    p = get_expr_line();", "    if (p == NULL)", "      return FAIL;"], "readability/braces"]
["src/nvim/ops.c", ["    xfree(p);", "  } else if (regname == '.') {        /* use last inserted text */", "    p = get_last_insert_save();"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    yankreg_T *reg = get_yank_register(regname, YREG_PASTE);", "    if (reg->y_array == NULL)", "      return FAIL;"], "readability/braces"]
["src/nvim/ops.c", ["", "    /*", "     * Insert lines into typeahead buffer, from last one to first one."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * If \"restart_edit\" is not zero, put it in the typeahead buffer, so that it's"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Insert register contents \"s\" into the typeahead buffer, so that it will be"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Insert a yank register: copy it into the Read buffer."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * It is possible to get into an endless loop by having CTRL-R a in"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  os_breakcheck();", "  if (got_int)", "    return FAIL;"], "readability/braces"]
["src/nvim/ops.c", ["", "  /* check for valid regname */", "  if (regname != NUL && !valid_yank_reg(regname, false))"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  /* check for valid regname */", "  if (regname != NUL && !valid_yank_reg(regname, false))", "    return FAIL;"], "readability/braces"]
["src/nvim/ops.c", ["", "/*", " * Stuff a string into the typeahead buffer, such that edit() will insert it"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /* stuff a single special character */", "    if (*arg != NUL) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  switch (regname) {", "  case '%':                     /* file name */", "    if (errmsg)"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  case '%':                     /* file name */", "    if (errmsg)", "      check_fname();            /* will give emsg if not set */"], "readability/braces"]
["src/nvim/ops.c", ["    if (errmsg)", "      check_fname();            /* will give emsg if not set */", "    *argp = curbuf->b_fname;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  case '=':                     /* result of expression */", "    *argp = get_expr_line();"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  case ':':                     /* last command line */", "    if (last_cmdline == NULL && errmsg)"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  case ':':                     /* last command line */", "    if (last_cmdline == NULL && errmsg)", "      EMSG(_(e_nolastcmd));"], "readability/braces"]
["src/nvim/ops.c", ["", "  case '/':                     /* last search-pattern */", "    if (last_search_pat() == NULL && errmsg)"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  case '/':                     /* last search-pattern */", "    if (last_search_pat() == NULL && errmsg)", "      EMSG(_(e_noprevre));"], "readability/braces"]
["src/nvim/ops.c", ["", "  case '.':                     /* last inserted text */", "    *argp = get_last_insert_save();"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  case '_':                     /* black hole: always empty */", "    *argp = (char_u *)\"\";"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  yankreg_T *reg = get_yank_register(regname, YREG_PASTE);", "  if (reg->y_array == NULL)", "    return FAIL;"], "readability/braces"]
["src/nvim/ops.c", ["", "    /* Check for CTRL-C, in case someone tries to paste a few thousand", "     * lines and gets bored. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    os_breakcheck();", "    if (got_int)", "      return FAIL;"], "readability/braces"]
["src/nvim/ops.c", ["", "/*", " * Handle a delete operation."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Imitate the strange Vi behaviour: If the delete spans more than one"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    ptr = ml_get(oap->end.lnum) + oap->end.col;", "    if (*ptr != NUL)", "      ptr += oap->inclusive;"], "readability/braces"]
["src/nvim/ops.c", ["", "  /*", "   * Check for trying to delete (e.g. \"D\") in an empty line."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Do a yank of whatever we're about to delete."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /*", "     * Put deleted text into register 1 and shift number registers if the"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /* Yank into small delete register when no named register specified", "     * and the delete is within one line. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    }", "", "  }"], "whitespace/blank_line"]
["src/nvim/ops.c", ["", "  /*", "   * block mode delete"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      /* Adjust cursor position for tab replaced by spaces and 'lbr'. */", "      if (lnum == curwin->w_cursor.lnum) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        lnum = curwin->w_cursor.lnum;", "        ++curwin->w_cursor.lnum;", "        del_lines(oap->line_count - 1, TRUE);"], "readability/increment"]
["src/nvim/ops.c", ["        ++curwin->w_cursor.lnum;", "        del_lines(oap->line_count - 1, TRUE);", "        curwin->w_cursor.lnum = lnum;"], "readability/bool"]
["src/nvim/ops.c", ["      }", "      if (u_save_cursor() == FAIL)", "        return FAIL;"], "readability/braces"]
["src/nvim/ops.c", ["    } else {", "      del_lines(oap->line_count, TRUE);", "      beginline(BL_WHITE | BL_FIX);"], "readability/bool"]
["src/nvim/ops.c", ["      beginline(BL_WHITE | BL_FIX);", "      u_clearline();            /* \"U\" command not possible after \"dd\" */", "    }"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      /* For virtualedit: break the tabs that are partly included. */", "      if (gchar_pos(&oap->start) == '\\t') {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      if (gchar_pos(&oap->start) == '\\t') {", "        if (u_save_cursor() == FAIL)            /* save first line for undo */", "          return FAIL;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      if (gchar_pos(&oap->start) == '\\t') {", "        if (u_save_cursor() == FAIL)            /* save first line for undo */", "          return FAIL;"], "readability/braces"]
["src/nvim/ops.c", ["          return FAIL;", "        if (oap->line_count == 1)", "          endcol = getviscol2(oap->end.col, oap->end.coladd);"], "readability/braces"]
["src/nvim/ops.c", ["", "      /* Break a tab only when it's included in the area. */", "      if (gchar_pos(&oap->end) == '\\t'"], "readability/old_style_comment"]
["src/nvim/ops.c", ["          && oap->inclusive) {", "        /* save last line for undo */", "        if (u_save((linenr_T)(oap->end.lnum - 1),"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        /* save last line for undo */", "        if (u_save((linenr_T)(oap->end.lnum - 1),", "                (linenr_T)(oap->end.lnum + 1)) == FAIL)"], "readability/braces"]
["src/nvim/ops.c", ["        if (u_save((linenr_T)(oap->end.lnum - 1),", "                (linenr_T)(oap->end.lnum + 1)) == FAIL)", "          return FAIL;"], "whitespace/alignment"]
["src/nvim/ops.c", ["", "    if (oap->line_count == 1) {         /* delete characters within one line */", "      if (u_save_cursor() == FAIL)              /* save line for undo */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    if (oap->line_count == 1) {         /* delete characters within one line */", "      if (u_save_cursor() == FAIL)              /* save line for undo */", "        return FAIL;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    if (oap->line_count == 1) {         /* delete characters within one line */", "      if (u_save_cursor() == FAIL)              /* save line for undo */", "        return FAIL;"], "readability/braces"]
["src/nvim/ops.c", ["", "      /* if 'cpoptions' contains '$', display '$' at end of change */", "      if (           vim_strchr(p_cpo, CPO_DOLLAR) != NULL"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      /* if 'cpoptions' contains '$', display '$' at end of change */", "      if (           vim_strchr(p_cpo, CPO_DOLLAR) != NULL", "                     && oap->op_type == OP_CHANGE"], "readability/braces"]
["src/nvim/ops.c", ["      if (           vim_strchr(p_cpo, CPO_DOLLAR) != NULL", "                     && oap->op_type == OP_CHANGE", "                     && oap->end.lnum == curwin->w_cursor.lnum"], "whitespace/alignment"]
["src/nvim/ops.c", ["                     && oap->op_type == OP_CHANGE", "                     && oap->end.lnum == curwin->w_cursor.lnum", "                     && !oap->is_VIsual"], "whitespace/alignment"]
["src/nvim/ops.c", ["                     && oap->end.lnum == curwin->w_cursor.lnum", "                     && !oap->is_VIsual", "                     )"], "whitespace/alignment"]
["src/nvim/ops.c", ["                     && !oap->is_VIsual", "                     )", "        display_dollar(oap->end.col - !oap->inclusive);"], "whitespace/alignment"]
["src/nvim/ops.c", ["      if (virtual_op) {", "        /* fix up things for virtualedit-delete:", "         * break the tabs which are going to get in our way"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "        if (oap->end.coladd != 0", "            && (int)oap->end.col >= len - 1"], "readability/braces"]
["src/nvim/ops.c", ["          n++;", "        /* Delete at least one char (e.g, when on a control char). */", "        if (n == 0 && oap->start.coladd != oap->end.coladd)"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        /* Delete at least one char (e.g, when on a control char). */", "        if (n == 0 && oap->start.coladd != oap->end.coladd)", "          n = 1;"], "readability/braces"]
["src/nvim/ops.c", ["", "        /* When deleted a char in the line, reset coladd. */", "        if (gchar_cursor() != NUL)"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        /* When deleted a char in the line, reset coladd. */", "        if (gchar_cursor() != NUL)", "          curwin->w_cursor.coladd = 0;"], "readability/braces"]
["src/nvim/ops.c", ["", "      /* save deleted and changed lines for undo */", "      if (u_save((linenr_T)(curwin->w_cursor.lnum - 1),"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      /* save deleted and changed lines for undo */", "      if (u_save((linenr_T)(curwin->w_cursor.lnum - 1),", "              (linenr_T)(curwin->w_cursor.lnum + oap->line_count)) == FAIL)"], "readability/braces"]
["src/nvim/ops.c", ["      if (u_save((linenr_T)(curwin->w_cursor.lnum - 1),", "              (linenr_T)(curwin->w_cursor.lnum + oap->line_count)) == FAIL)", "        return FAIL;"], "whitespace/alignment"]
["src/nvim/ops.c", ["", "/*", " * Adjust end of operating area for ending on a multi-byte character."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Put character 'c' at position 'lp'"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Replace a whole area with one character."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if ((curbuf->b_ml.ml_flags & ML_EMPTY ) || oap->empty)", "    return OK;              /* nothing to do */"], "readability/braces"]
["src/nvim/ops.c", ["  if ((curbuf->b_ml.ml_flags & ML_EMPTY ) || oap->empty)", "    return OK;              /* nothing to do */", ""], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (u_save((linenr_T)(oap->start.lnum - 1),", "          (linenr_T)(oap->end.lnum + 1)) == FAIL)"], "readability/braces"]
["src/nvim/ops.c", ["  if (u_save((linenr_T)(oap->start.lnum - 1),", "          (linenr_T)(oap->end.lnum + 1)) == FAIL)", "    return FAIL;"], "whitespace/alignment"]
["src/nvim/ops.c", ["", "  /*", "   * block mode replace"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      /* n == number of extra chars required", "       * If we split a TAB, it may be replaced by several characters."], "readability/old_style_comment"]
["src/nvim/ops.c", ["       */", "      /* If the range starts in virtual space, count the initial", "       * coladd offset as part of \"startspaces\" */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        n = bd.startspaces;", "      } else", "        /* allow for pre spaces */"], "readability/braces"]
["src/nvim/ops.c", ["      } else", "        /* allow for pre spaces */", "        n = (bd.startspaces ? bd.start_char_vcols - 1 : 0);"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      /* allow for post spp */", "      n += (bd.endspaces"], "readability/old_style_comment"]
["src/nvim/ops.c", ["            && bd.end_char_vcols > 0) ? bd.end_char_vcols - 1 : 0;", "      /* Figure out how many characters to replace. */", "      numc = oap->end_vcol - oap->start_vcol + 1;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      numc = oap->end_vcol - oap->start_vcol + 1;", "      if (bd.is_short && (!virtual_op || bd.is_MAX))", "        numc -= (oap->end_vcol - bd.end_vcol) + 1;"], "readability/braces"]
["src/nvim/ops.c", ["", "      /* A double-wide character can be replaced only up to half the", "       * times. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        if ((numc & 1) && !bd.is_short) {", "          ++bd.endspaces;", "          ++n;"], "readability/increment"]
["src/nvim/ops.c", ["          ++bd.endspaces;", "          ++n;", "        }"], "readability/increment"]
["src/nvim/ops.c", ["", "      /* Compute bytes needed, move character count to num_chars. */", "      num_chars = numc;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      oap->end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));", "      if (oap->end.col)", "        --oap->end.col;"], "readability/braces"]
["src/nvim/ops.c", ["      if (oap->end.col)", "        --oap->end.col;", "    } else if (!oap->inclusive)"], "readability/increment"]
["src/nvim/ops.c", ["        --oap->end.col;", "    } else if (!oap->inclusive)", "      dec(&(oap->end));"], "readability/braces"]
["src/nvim/ops.c", ["        if ((*mb_char2len)(c) > 1 || (*mb_char2len)(n) > 1) {", "          /* This is slow, but it handles replacing a single-byte", "           * with a multi-byte and the other way around. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["           * with a multi-byte and the other way around. */", "          if (curwin->w_cursor.lnum == oap->end.lnum)", "            oap->end.col += (*mb_char2len)(c) - (*mb_char2len)(n);"], "readability/braces"]
["src/nvim/ops.c", ["            if (curwin->w_cursor.lnum == oap->end.lnum) {", "              /* oap->end has to be recalculated when", "               * the tab breaks */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["              end_vcol = getviscol2(oap->end.col,", "                  oap->end.coladd);", "            }"], "whitespace/alignment"]
["src/nvim/ops.c", ["            coladvance_force(getviscol());", "            if (curwin->w_cursor.lnum == oap->end.lnum)", "              getvpos(&oap->end, end_vcol);"], "readability/braces"]
["src/nvim/ops.c", ["", "        if (curwin->w_cursor.lnum == oap->start.lnum", "            && oap->start.col == oap->end.col && oap->start.coladd)"], "readability/braces"]
["src/nvim/ops.c", ["", "        /* oap->end has been trimmed so it's effectively inclusive;", "         * as a result an extra +1 must be counted so we don't"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      /* Advance to next character, stop at the end of the file. */", "      if (inc_cursor() == -1)"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      /* Advance to next character, stop at the end of the file. */", "      if (inc_cursor() == -1)", "        break;"], "readability/braces"]
["src/nvim/ops.c", ["", "  /* Set \"'[\" and \"']\" marks. */", "  curbuf->b_op_start = oap->start;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Handle the (non-standard vi) tilde operator.  Also for \"gu\", \"gU\" and \"g?\"."], "readability/old_style_comment"]
["src/nvim/ops.c", ["  struct block_def bd;", "  int did_change = FALSE;", ""], "readability/bool"]
["src/nvim/ops.c", ["", "  if (u_save((linenr_T)(oap->start.lnum - 1),", "          (linenr_T)(oap->end.lnum + 1)) == FAIL)"], "readability/braces"]
["src/nvim/ops.c", ["  if (u_save((linenr_T)(oap->start.lnum - 1),", "          (linenr_T)(oap->end.lnum + 1)) == FAIL)", "    return;"], "whitespace/alignment"]
["src/nvim/ops.c", ["      did_change |= one_change;", "", "    }"], "whitespace/blank_line"]
["src/nvim/ops.c", ["      oap->end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));", "      if (oap->end.col)", "        --oap->end.col;"], "readability/braces"]
["src/nvim/ops.c", ["      if (oap->end.col)", "        --oap->end.col;", "    } else if (!oap->inclusive)"], "readability/increment"]
["src/nvim/ops.c", ["        --oap->end.col;", "    } else if (!oap->inclusive)", "      dec(&(oap->end));"], "readability/braces"]
["src/nvim/ops.c", ["", "    if (pos.lnum == oap->end.lnum)", "      did_change = swapchars(oap->op_type, &pos,"], "readability/braces"]
["src/nvim/ops.c", ["      did_change = swapchars(oap->op_type, &pos,", "          oap->end.col - pos.col + 1);", "    else"], "whitespace/alignment"]
["src/nvim/ops.c", ["          oap->end.col - pos.col + 1);", "    else", "      for (;; ) {"], "readability/braces"]
["src/nvim/ops.c", ["        did_change |= swapchars(oap->op_type, &pos,", "            pos.lnum == oap->end.lnum ? oap->end.col + 1 :", "            (int)STRLEN(ml_get_pos(&pos)));"], "whitespace/alignment"]
["src/nvim/ops.c", ["            pos.lnum == oap->end.lnum ? oap->end.col + 1 :", "            (int)STRLEN(ml_get_pos(&pos)));", "        if (ltoreq(oap->end, pos) || inc(&pos) == -1)"], "whitespace/alignment"]
["src/nvim/ops.c", ["            (int)STRLEN(ml_get_pos(&pos)));", "        if (ltoreq(oap->end, pos) || inc(&pos) == -1)", "          break;"], "readability/braces"]
["src/nvim/ops.c", ["", "  if (!did_change && oap->is_VIsual)", "    /* No change: need to remove the Visual selection */"], "readability/braces"]
["src/nvim/ops.c", ["  if (!did_change && oap->is_VIsual)", "    /* No change: need to remove the Visual selection */", "    redraw_curbuf_later(INVERTED);"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Set '[ and '] marks."], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (oap->line_count > p_report) {", "    if (oap->line_count == 1)", "      MSG(_(\"1 line changed\"));"], "readability/braces"]
["src/nvim/ops.c", ["      MSG(_(\"1 line changed\"));", "    else", "      smsg(_(\"%\" PRId64 \" lines changed\"), (int64_t)oap->line_count);"], "readability/braces"]
["src/nvim/ops.c", ["", "/*", " * Invoke swapchar() on \"length\" bytes at position \"pos\"."], "readability/old_style_comment"]
["src/nvim/ops.c", ["    did_change |= swapchar(op_type, pos);", "    if (inc(pos) == -1)        /* at end of file */", "      break;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    did_change |= swapchar(op_type, pos);", "    if (inc(pos) == -1)        /* at end of file */", "      break;"], "readability/braces"]
["src/nvim/ops.c", ["", "    /* Special handling of German sharp s: change to \"SS\". */", "    curwin->w_cursor = *pos;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * op_insert - Insert and append operators for Visual mode."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /* edit() changes this - record it for OP_APPEND */", "  bd.is_MAX = (curwin->w_curswant == MAXCOL);"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /* vis block is still marked. Get rid of it now. */", "  curwin->w_cursor.lnum = oap->start.lnum;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      ve_flags = VE_ALL;", "      if (u_save_cursor() == FAIL)", "        return;"], "readability/braces"]
["src/nvim/ops.c", ["      coladvance_force(oap->op_type == OP_APPEND", "          ? oap->end_vcol + 1 : getviscol());", "      if (oap->op_type == OP_APPEND)"], "whitespace/alignment"]
["src/nvim/ops.c", ["          ? oap->end_vcol + 1 : getviscol());", "      if (oap->op_type == OP_APPEND)", "        --curwin->w_cursor.col;"], "readability/braces"]
["src/nvim/ops.c", ["      if (oap->op_type == OP_APPEND)", "        --curwin->w_cursor.col;", "      ve_flags = old_ve_flags;"], "readability/increment"]
["src/nvim/ops.c", ["        ) {", "      /* Move the cursor to the character right of the block. */", "      curwin->w_set_curswant = TRUE;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      /* Move the cursor to the character right of the block. */", "      curwin->w_set_curswant = TRUE;", "      while (*get_cursor_pos_ptr() != NUL"], "readability/bool"]
["src/nvim/ops.c", ["      curwin->w_set_curswant = TRUE;", "      while (*get_cursor_pos_ptr() != NUL", "             && (curwin->w_cursor.col < bd.textcol + bd.textlen))"], "readability/braces"]
["src/nvim/ops.c", ["             && (curwin->w_cursor.col < bd.textcol + bd.textlen))", "        ++curwin->w_cursor.col;", "      if (bd.is_short && !bd.is_MAX) {"], "readability/increment"]
["src/nvim/ops.c", ["      if (bd.is_short && !bd.is_MAX) {", "        /* First line was too short, make it longer and adjust the", "         * values in \"bd\". */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["         * values in \"bd\". */", "        if (u_save_cursor() == FAIL)", "          return;"], "readability/braces"]
["src/nvim/ops.c", ["", "  /* If user has moved off this line, we don't know what to do, so do", "   * nothing."], "readability/old_style_comment"]
["src/nvim/ops.c", ["   * Also don't repeat the insert when Insert mode ended with CTRL-C. */", "  if (curwin->w_cursor.lnum != oap->start.lnum || got_int)", "    return;"], "readability/braces"]
["src/nvim/ops.c", ["        oap->start.col = curbuf->b_op_start_orig.col;", "        /* reset pre_textlen to the value of OP_INSERT */", "        pre_textlen += bd.textlen;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /*", "     * Spaces and tabs in the indent may have changed to other spaces and"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        pre_textlen += bd2.textlen - bd.textlen;", "        if (bd2.endspaces)", "          --bd2.textlen;"], "readability/braces"]
["src/nvim/ops.c", ["        if (bd2.endspaces)", "          --bd2.textlen;", "      }"], "readability/increment"]
["src/nvim/ops.c", ["", "    /*", "     * Subsequent calls to ml_get() flush the firstline data - take a"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * op_change - handle a change operation"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    l = 0;", "    if (!p_paste && curbuf->b_p_si", "        && !curbuf->b_p_cin"], "readability/braces"]
["src/nvim/ops.c", ["", "  /* First delete the text in the region.  In an empty buffer only need to", "   * save for undo */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (curbuf->b_ml.ml_flags & ML_EMPTY) {", "    if (u_save_cursor() == FAIL)", "      return FALSE;"], "readability/braces"]
["src/nvim/ops.c", ["    if (u_save_cursor() == FAIL)", "      return FALSE;", "  } else if (op_delete(oap) == FAIL)"], "readability/bool"]
["src/nvim/ops.c", ["      return FALSE;", "  } else if (op_delete(oap) == FAIL)", "    return FALSE;"], "readability/braces"]
["src/nvim/ops.c", ["  } else if (op_delete(oap) == FAIL)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/ops.c", ["", "  retval = edit(NUL, FALSE, (linenr_T)1);", ""], "readability/bool"]
["src/nvim/ops.c", ["", "  /*", "   * In Visual block mode, handle copying the new text to all lines of the"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    if (ins_len > 0) {", "      /* Subsequent calls to ml_get() flush the firstline data - take a", "       * copy of the inserted text.  */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "          /* If the block starts in virtual space, count the", "           * initial coladd offset as part of \"startspaces\" */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * set all the yank registers to empty (called from main())"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", " /// Free contents of yankreg `reg`.", " /// Called for normal freeing and in case of error."], "whitespace/indent"]
["src/nvim/ops.c", [" /// Free contents of yankreg `reg`.", " /// Called for normal freeing and in case of error.", " /// `reg` must not be NULL (but `reg->y_array` might be)"], "whitespace/indent"]
["src/nvim/ops.c", [" /// Called for normal freeing and in case of error.", " /// `reg` must not be NULL (but `reg->y_array` might be)", "void free_register(yankreg_T *reg)"], "whitespace/indent"]
["src/nvim/ops.c", ["  if (oap->regname == '_') {", "    return true; // black hole: nothing to do", "  }"], "whitespace/comments"]
["src/nvim/ops.c", ["", "    if (curwin->w_curswant == MAXCOL && reg->y_width > 0)", "      reg->y_width--;"], "readability/braces"]
["src/nvim/ops.c", ["          if (ce != cs && oap->start.coladd > 0) {", "            /* Part of a tab selected -- but don't", "             * double-count it. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      }", "      if (endcol == MAXCOL)", "        endcol = (colnr_T)STRLEN(p);"], "readability/braces"]
["src/nvim/ops.c", ["", "  if (curr != reg) {      /* append the new block to the old block */", "    new_ptr = xmalloc(sizeof(char_u *) * (curr->y_size + reg->y_size));"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    new_ptr = xmalloc(sizeof(char_u *) * (curr->y_size + reg->y_size));", "    for (j = 0; j < curr->y_size; ++j)", "      new_ptr[j] = curr->y_array[j];"], "readability/braces"]
["src/nvim/ops.c", ["    new_ptr = xmalloc(sizeof(char_u *) * (curr->y_size + reg->y_size));", "    for (j = 0; j < curr->y_size; ++j)", "      new_ptr[j] = curr->y_array[j];"], "readability/increment"]
["src/nvim/ops.c", ["      y_idx = 1;", "    } else", "      y_idx = 0;"], "readability/braces"]
["src/nvim/ops.c", ["      y_idx = 0;", "    while (y_idx < reg->y_size)", "      curr->y_array[j++] = reg->y_array[y_idx++];"], "readability/braces"]
["src/nvim/ops.c", ["", "  /*", "   * Set \"'[\" and \"']\" marks."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Put contents of register \"regname\" into the text."], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int indent;", "  int orig_indent = 0;                  /* init for gcc */", "  int indent_diff = 0;                  /* init for gcc */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int orig_indent = 0;                  /* init for gcc */", "  int indent_diff = 0;                  /* init for gcc */", "  int first_indent = TRUE;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int indent_diff = 0;                  /* init for gcc */", "  int first_indent = TRUE;", "  int lendiff = 0;"], "readability/bool"]
["src/nvim/ops.c", ["", "  if (flags & PUT_FIXINDENT)", "    orig_indent = get_indent();"], "readability/braces"]
["src/nvim/ops.c", ["", "  curbuf->b_op_start = curwin->w_cursor;        /* default for '[ mark */", "  curbuf->b_op_end = curwin->w_cursor;          /* default for '] mark */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  curbuf->b_op_start = curwin->w_cursor;        /* default for '[ mark */", "  curbuf->b_op_end = curwin->w_cursor;          /* default for '] mark */", ""], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Using inserted text works differently, because the register includes"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * For special registers '%' (file name), '#' (alternate file name) and"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    if (regname == '=') {", "      /* For the = register we need to split the string at NL", "       * characters."], "readability/old_style_comment"]
["src/nvim/ops.c", ["        while (ptr != NULL) {", "          if (y_array != NULL)", "            y_array[y_size] = ptr;"], "readability/braces"]
["src/nvim/ops.c", ["            y_array[y_size] = ptr;", "          ++y_size;", "          ptr = vim_strchr(ptr, '\\n');"], "readability/increment"]
["src/nvim/ops.c", ["          if (ptr != NULL) {", "            if (y_array != NULL)", "              *ptr = NUL;"], "readability/braces"]
["src/nvim/ops.c", ["              *ptr = NUL;", "            ++ptr;", "            /* A trailing '\\n' makes the register linewise. */"], "readability/increment"]
["src/nvim/ops.c", ["            ++ptr;", "            /* A trailing '\\n' makes the register linewise. */", "            if (*ptr == NUL) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        }", "        if (y_array != NULL)", "          break;"], "readability/braces"]
["src/nvim/ops.c", ["    } else {", "      y_size = 1;               /* use fake one-line yank register */", "      y_array = &insert_string;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    if (flags & PUT_LINE_FORWARD) {", "      /* Must be \"p\" for a Visual block, put lines below the block. */", "      curwin->w_cursor = curbuf->b_visual.vi_end;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    }", "    curbuf->b_op_start = curwin->w_cursor;      /* default for '[ mark */", "    curbuf->b_op_end = curwin->w_cursor;        /* default for '] mark */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    curbuf->b_op_start = curwin->w_cursor;      /* default for '[ mark */", "    curbuf->b_op_end = curwin->w_cursor;        /* default for '] mark */", "  }"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    EMSG2(_(\"E353: Nothing in register %s\"),", "        regname == 0 ? (char_u *)\"\\\"\" : transchar(regname));", "    goto end;"], "whitespace/alignment"]
["src/nvim/ops.c", ["    if (gchar_cursor() == TAB) {", "      /* Don't need to insert spaces when \"p\" on the last position of a", "       * tab or \"P\" on the first position. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Block mode"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    if (dir == FORWARD && c != NUL) {", "      if (ve_flags == VE_ALL)", "        getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);"], "readability/braces"]
["src/nvim/ops.c", ["        getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);", "      else", "        getvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);"], "readability/braces"]
["src/nvim/ops.c", ["      if (c == TAB) {", "        if (dir == BACKWARD && curwin->w_cursor.col)", "          curwin->w_cursor.col--;"], "readability/braces"]
["src/nvim/ops.c", ["          curwin->w_cursor.col--;", "        if (dir == FORWARD && col - 1 == endcol2)", "          curwin->w_cursor.col++;"], "readability/braces"]
["src/nvim/ops.c", ["", "      /* add a new line */", "      if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      }", "      /* get the old line and advance to the position to insert at */", "      oldp = get_cursor_line_ptr();"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      for (ptr = oldp; vcol < col && *ptr; ) {", "        /* Count a tab for what it's worth (if list mode not on) */", "        incr = lbr_chartabsize_adv(oldp, &ptr, (colnr_T)vcol);"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      if (vcol < col)       /* line too short, padd with spaces */", "        bd.startspaces = col - vcol;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      if (vcol < col)       /* line too short, padd with spaces */", "        bd.startspaces = col - vcol;"], "readability/braces"]
["src/nvim/ops.c", ["        bd.startspaces = col - vcol;", "      else if (vcol > col) {", "        bd.endspaces = vcol - col;"], "readability/braces"]
["src/nvim/ops.c", ["        bd.startspaces = incr - bd.endspaces;", "        --bd.textcol;", "        delcount = 1;"], "readability/increment"]
["src/nvim/ops.c", ["        if (oldp[bd.textcol] != TAB) {", "          /* Only a Tab can be split into spaces.  Other", "           * characters will have to be moved to after the"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      ++curwin->w_cursor.lnum;", "      if (i == 0)"], "readability/increment"]
["src/nvim/ops.c", ["      ++curwin->w_cursor.lnum;", "      if (i == 0)", "        curwin->w_cursor.col += bd.startspaces;"], "readability/braces"]
["src/nvim/ops.c", ["", "    /* Set '[ mark. */", "    curbuf->b_op_start = curwin->w_cursor;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /* adjust '] mark */", "    curbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      /* in Insert mode we might be after the NUL, correct for that */", "      len = (colnr_T)STRLEN(get_cursor_line_ptr());"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      len = (colnr_T)STRLEN(get_cursor_line_ptr());", "      if (curwin->w_cursor.col > len)", "        curwin->w_cursor.col = len;"], "readability/braces"]
["src/nvim/ops.c", ["        curwin->w_cursor.col = len;", "    } else", "      curwin->w_cursor.lnum = lnum;"], "readability/braces"]
["src/nvim/ops.c", ["    }", "    /*", "     * Line mode: BACKWARD is the same as FORWARD on the previous line"], "readability/old_style_comment"]
["src/nvim/ops.c", ["     */", "    else if (dir == BACKWARD)", "      --lnum;"], "whitespace/newline"]
["src/nvim/ops.c", ["    else if (dir == BACKWARD)", "      --lnum;", "    new_cursor = curwin->w_cursor;"], "readability/increment"]
["src/nvim/ops.c", ["", "      if (VIsual_active) {  /* reset lnum to the last visual line */", "        lnum--;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      curbuf->b_op_end = curwin->w_cursor;", "      /* For \"CTRL-O p\" in Insert mode, put cursor after last char */", "      if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND)))"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      /* For \"CTRL-O p\" in Insert mode, put cursor after last char */", "      if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND)))", "        ++curwin->w_cursor.col;"], "readability/braces"]
["src/nvim/ops.c", ["      if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND)))", "        ++curwin->w_cursor.col;", "      changed_bytes(lnum, col);"], "readability/increment"]
["src/nvim/ops.c", ["          totlen = STRLEN(y_array[y_size - 1]);", "          newp = (char_u *) xmalloc((size_t)(STRLEN(ptr) + totlen + 1));", "          STRCPY(newp, y_array[y_size - 1]);"], "whitespace/cast"]
["src/nvim/ops.c", ["          lnum++;", "          ++nr_lines;", "          if (flags & PUT_FIXINDENT) {"], "readability/increment"]
["src/nvim/ops.c", ["            ptr = ml_get(lnum);", "            if (cnt == count && i == y_size - 1)", "              lendiff = (int)STRLEN(ptr);"], "readability/braces"]
["src/nvim/ops.c", ["              lendiff = (int)STRLEN(ptr);", "            if (*ptr == '#' && preprocs_left())", "              indent = 0;                   /* Leave # lines at start */"], "readability/braces"]
["src/nvim/ops.c", ["            if (*ptr == '#' && preprocs_left())", "              indent = 0;                   /* Leave # lines at start */", "            else if (*ptr == NUL)"], "readability/old_style_comment"]
["src/nvim/ops.c", ["              indent = 0;                   /* Leave # lines at start */", "            else if (*ptr == NUL)", "              indent = 0;                   /* Ignore empty lines */"], "readability/braces"]
["src/nvim/ops.c", ["            else if (*ptr == NUL)", "              indent = 0;                   /* Ignore empty lines */", "            else if (first_indent) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["              indent = 0;                   /* Ignore empty lines */", "            else if (first_indent) {", "              indent_diff = orig_indent - get_indent();"], "readability/braces"]
["src/nvim/ops.c", ["              indent = orig_indent;", "              first_indent = FALSE;", "            } else if ((indent = get_indent() + indent_diff) < 0)"], "readability/bool"]
["src/nvim/ops.c", ["              first_indent = FALSE;", "            } else if ((indent = get_indent() + indent_diff) < 0)", "              indent = 0;"], "readability/braces"]
["src/nvim/ops.c", ["            curwin->w_cursor = old_pos;", "            /* remember how many chars were removed */", "            if (cnt == count && i == y_size - 1)"], "readability/old_style_comment"]
["src/nvim/ops.c", ["            /* remember how many chars were removed */", "            if (cnt == count && i == y_size - 1)", "              lendiff -= (int)STRLEN(ml_get(lnum));"], "readability/braces"]
["src/nvim/ops.c", ["        curbuf->b_op_start.col = 0;", "        if (dir == FORWARD)", "          curbuf->b_op_start.lnum++;"], "readability/braces"]
["src/nvim/ops.c", ["", "      /* put '] mark at last inserted character */", "      curbuf->b_op_end.lnum = lnum;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      curbuf->b_op_end.lnum = lnum;", "      /* correct length for change in indent */", "      col = (colnr_T)STRLEN(y_array[y_size - 1]) - lendiff;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      col = (colnr_T)STRLEN(y_array[y_size - 1]) - lendiff;", "      if (col > 1)", "        curbuf->b_op_end.col = col - 1;"], "readability/braces"]
["src/nvim/ops.c", ["        curbuf->b_op_end.col = col - 1;", "      else", "        curbuf->b_op_end.col = 0;"], "readability/braces"]
["src/nvim/ops.c", ["      if (flags & PUT_CURSLINE) {", "        /* \":put\": put cursor on last inserted line */", "        curwin->w_cursor.lnum = lnum;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        curwin->w_cursor.col = 0;", "        if (dir == FORWARD)", "          ++curwin->w_cursor.lnum;"], "readability/braces"]
["src/nvim/ops.c", ["        if (dir == FORWARD)", "          ++curwin->w_cursor.lnum;", "        beginline(BL_WHITE | BL_FIX);"], "readability/increment"]
["src/nvim/ops.c", ["        beginline(BL_WHITE | BL_FIX);", "      } else            /* put cursor on first inserted character */", "        curwin->w_cursor = new_cursor;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        beginline(BL_WHITE | BL_FIX);", "      } else            /* put cursor on first inserted character */", "        curwin->w_cursor = new_cursor;"], "readability/braces"]
["src/nvim/ops.c", ["  msgmore(nr_lines);", "  curwin->w_set_curswant = TRUE;", ""], "readability/bool"]
["src/nvim/ops.c", ["end:", "  if (allocated)", "    xfree(insert_string);"], "readability/braces"]
["src/nvim/ops.c", ["    xfree(insert_string);", "  if (regname == '=')", "    xfree(y_array);"], "readability/braces"]
["src/nvim/ops.c", ["", "  VIsual_active = FALSE;", ""], "readability/bool"]
["src/nvim/ops.c", ["", "  /* If the cursor is past the end of the line put it at the end. */", "  adjust_cursor_eol();"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * When the cursor is on the NUL past the end of the line and it should not be"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      && !(restart_edit || (State & INSERT))) {", "    /* Put the cursor on the last character in the line. */", "    dec_cursor();"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      /* Coladd is set to the width of the last character. */", "      getvcol(curwin, &curwin->w_cursor, &scol, NULL, &ecol);"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Return TRUE if lines starting with '#' should be left aligned."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/* Return the character name of the register with the given number */", "int get_register_name(int num)"], "readability/old_style_comment"]
["src/nvim/ops.c", ["{", "  if (num == -1)", "    return '\"';"], "readability/braces"]
["src/nvim/ops.c", ["    return '\"';", "  else if (num < 10)", "    return num + '0';"], "readability/braces"]
["src/nvim/ops.c", ["    return num + '0';", "  else if (num == DELETION_REGISTER)", "    return '-';"], "readability/braces"]
["src/nvim/ops.c", ["    return '-';", "  else if (num == STAR_REGISTER)", "    return '*';"], "readability/braces"]
["src/nvim/ops.c", ["    return '*';", "  else if (num == PLUS_REGISTER)", "    return '+';"], "readability/braces"]
["src/nvim/ops.c", ["    return '+';", "  else {", "    return num + 'a' - 10;"], "readability/braces"]
["src/nvim/ops.c", ["    return '+';", "  else {", "    return num + 'a' - 10;"], "readability/braces"]
["src/nvim/ops.c", ["", "/*", " * \":dis\" and \":registers\": Display the contents of the yank registers."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (arg != NULL && *arg == NUL)", "    arg = NULL;"], "readability/braces"]
["src/nvim/ops.c", ["    if (arg != NULL && vim_strchr(arg, name) == NULL) {", "      continue;             /* did not ask for this register */", "    }"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    if (i == -1) {", "      if (y_previous != NULL)", "        yb = y_previous;"], "readability/braces"]
["src/nvim/ops.c", ["        yb = y_previous;", "      else", "        yb = &(y_regs[0]);"], "readability/braces"]
["src/nvim/ops.c", ["        yb = &(y_regs[0]);", "    } else", "      yb = &(y_regs[i]);"], "readability/braces"]
["src/nvim/ops.c", ["", "  /*", "   * display last inserted text"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * display last command line"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * display current file name"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * display alternate file name"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * display last search pattern"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * display last used expression"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * display a string for do_dis()"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      p += l;", "    } else", "      msg_outtrans_len(p++, 1);"], "readability/braces"]
["src/nvim/ops.c", ["  if (leader_offset != -1) {", "    /* Let's check whether the line ends with an unclosed comment.", "     * If the last comment leader has COM_END in flags, there's no comment."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (lead_len == 0)", "    return line;"], "readability/braces"]
["src/nvim/ops.c", ["", "  /* Find:", "   * - COM_END,"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    }", "    ++comment_flags;", "  }"], "readability/increment"]
["src/nvim/ops.c", ["", "  /* If we found a colon, it means that we are not processing a line", "   * starting with a closing part of a three-part comment. That's good,"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  char_u      *newp;", "  char_u      *spaces;          /* number of spaces inserted before a line */", "  int endcurr1 = NUL;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int endcurr2 = NUL;", "  int currsize = 0;             /* size of the current line */", "  int sumsize = 0;              /* size of the long new line */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int currsize = 0;             /* size of the current line */", "  int sumsize = 0;              /* size of the long new line */", "  linenr_T t;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  int         *comments = NULL;", "  int remove_comments = (use_formatoptions == TRUE)", "                        && has_format_option(FO_REMOVE_COMS);"], "readability/bool"]
["src/nvim/ops.c", ["          ) {", "        /* don't add a space if the line is ending in a space */", "        if (endcurr1 == ' ')"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        /* don't add a space if the line is ending in a space */", "        if (endcurr1 == ' ')", "          endcurr1 = endcurr2;"], "readability/braces"]
["src/nvim/ops.c", ["          endcurr1 = endcurr2;", "        else", "          ++spaces[t];"], "readability/braces"]
["src/nvim/ops.c", ["        else", "          ++spaces[t];", "        // Extra space when 'joinspaces' set and line ends in '.', '?', or '!'."], "readability/increment"]
["src/nvim/ops.c", ["        if (p_js && (endcurr1 == '.' || endcurr1 == '?' || endcurr1 == '!')) {", "          ++spaces[t];", "        }"], "readability/increment"]
["src/nvim/ops.c", ["", "  /*", "   * Move affected lines to the new long one."], "readability/old_style_comment"]
["src/nvim/ops.c", ["    curr = curr_start = ml_get((linenr_T)(curwin->w_cursor.lnum + t - 1));", "    if (remove_comments)", "      curr += comments[t - 1];"], "readability/braces"]
["src/nvim/ops.c", ["      curr += comments[t - 1];", "    if (insert_space && t > 1)", "      curr = skipwhite(curr);"], "readability/braces"]
["src/nvim/ops.c", ["", "  /* Only report the change in the first line here, del_lines() will report", "   * the deleted line. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Delete following lines. To do this we move the cursor there"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Set the cursor column:"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  curwin->w_cursor.coladd = 0;", "  curwin->w_set_curswant = TRUE;", ""], "readability/bool"]
["src/nvim/ops.c", ["  xfree(spaces);", "  if (remove_comments)", "    xfree(comments);"], "readability/braces"]
["src/nvim/ops.c", ["", "/*", " * Return TRUE if the two comment leaders given are the same.  \"lnum\" is"], "readability/old_style_comment"]
["src/nvim/ops.c", [" */", "static int same_leader(linenr_T lnum, int leader1_len, char_u *leader1_flags, int leader2_len, char_u *leader2_flags)", "{"], "whitespace/line_length"]
["src/nvim/ops.c", ["", "  if (leader1_len == 0)", "    return leader2_len == 0;"], "readability/braces"]
["src/nvim/ops.c", ["", "  /*", "   * If first leader has 'f' flag, the lines can be joined only if the"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (leader1_flags != NULL) {", "    for (p = leader1_flags; *p && *p != ':'; ++p) {", "      if (*p == COM_FIRST)"], "readability/increment"]
["src/nvim/ops.c", ["    for (p = leader1_flags; *p && *p != ':'; ++p) {", "      if (*p == COM_FIRST)", "        return leader2_len == 0;"], "readability/braces"]
["src/nvim/ops.c", ["        return leader2_len == 0;", "      if (*p == COM_END)", "        return FALSE;"], "readability/braces"]
["src/nvim/ops.c", ["      if (*p == COM_END)", "        return FALSE;", "      if (*p == COM_START) {"], "readability/bool"]
["src/nvim/ops.c", ["      if (*p == COM_START) {", "        if (*(ml_get(lnum) + leader1_len) == NUL)", "          return FALSE;"], "readability/braces"]
["src/nvim/ops.c", ["        if (*(ml_get(lnum) + leader1_len) == NUL)", "          return FALSE;", "        if (leader2_flags == NULL || leader2_len == 0)"], "readability/bool"]
["src/nvim/ops.c", ["          return FALSE;", "        if (leader2_flags == NULL || leader2_len == 0)", "          return FALSE;"], "readability/braces"]
["src/nvim/ops.c", ["        if (leader2_flags == NULL || leader2_len == 0)", "          return FALSE;", "        for (p = leader2_flags; *p && *p != ':'; ++p)"], "readability/bool"]
["src/nvim/ops.c", ["          return FALSE;", "        for (p = leader2_flags; *p && *p != ':'; ++p)", "          if (*p == COM_MIDDLE)"], "readability/braces"]
["src/nvim/ops.c", ["          return FALSE;", "        for (p = leader2_flags; *p && *p != ':'; ++p)", "          if (*p == COM_MIDDLE)"], "readability/increment"]
["src/nvim/ops.c", ["        for (p = leader2_flags; *p && *p != ':'; ++p)", "          if (*p == COM_MIDDLE)", "            return TRUE;"], "readability/braces"]
["src/nvim/ops.c", ["          if (*p == COM_MIDDLE)", "            return TRUE;", "        return FALSE;"], "readability/bool"]
["src/nvim/ops.c", ["            return TRUE;", "        return FALSE;", "      }"], "readability/bool"]
["src/nvim/ops.c", ["", "  /*", "   * Get current line and next line, compare the leaders."], "readability/old_style_comment"]
["src/nvim/ops.c", ["  line1 = vim_strsave(ml_get(lnum));", "  for (idx1 = 0; ascii_iswhite(line1[idx1]); ++idx1)", "    ;"], "readability/braces"]
["src/nvim/ops.c", ["  line1 = vim_strsave(ml_get(lnum));", "  for (idx1 = 0; ascii_iswhite(line1[idx1]); ++idx1)", "    ;"], "readability/increment"]
["src/nvim/ops.c", ["  for (idx1 = 0; ascii_iswhite(line1[idx1]); ++idx1)", "    ;", "  line2 = ml_get(lnum + 1);"], "whitespace/semicolon"]
["src/nvim/ops.c", ["  line2 = ml_get(lnum + 1);", "  for (idx2 = 0; idx2 < leader2_len; ++idx2) {", "    if (!ascii_iswhite(line2[idx2])) {"], "readability/increment"]
["src/nvim/ops.c", ["    if (!ascii_iswhite(line2[idx2])) {", "      if (line1[idx1++] != line2[idx2])", "        break;"], "readability/braces"]
["src/nvim/ops.c", ["        break;", "    } else", "      while (ascii_iswhite(line1[idx1]))"], "readability/braces"]
["src/nvim/ops.c", ["    } else", "      while (ascii_iswhite(line1[idx1]))", "        ++idx1;"], "readability/braces"]
["src/nvim/ops.c", ["      while (ascii_iswhite(line1[idx1]))", "        ++idx1;", "  }"], "readability/increment"]
["src/nvim/ops.c", ["", "/*", " * Implementation of the format operator 'gq'."], "readability/old_style_comment"]
["src/nvim/ops.c", ["    oparg_T *oap,", "    int keep_cursor                        /* keep cursor on same text char */", ")"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /* Place the cursor where the \"gq\" or \"gw\" command was given, so that \"u\"", "   * can put it back there. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (u_save((linenr_T)(oap->start.lnum - 1),", "          (linenr_T)(oap->end.lnum + 1)) == FAIL)"], "readability/braces"]
["src/nvim/ops.c", ["  if (u_save((linenr_T)(oap->start.lnum - 1),", "          (linenr_T)(oap->end.lnum + 1)) == FAIL)", "    return;"], "whitespace/alignment"]
["src/nvim/ops.c", ["", "  if (oap->is_VIsual)", "    /* When there is no change: need to remove the Visual selection */"], "readability/braces"]
["src/nvim/ops.c", ["  if (oap->is_VIsual)", "    /* When there is no change: need to remove the Visual selection */", "    redraw_curbuf_later(INVERTED);"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /* Set '[ mark at the start of the formatted area */", "  curbuf->b_op_start = oap->start;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /* For \"gw\" remember the cursor position and put it back below (adjusted", "   * for joined and split lines). */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["   * for joined and split lines). */", "  if (keep_cursor)", "    saved_cursor = oap->cursor_start;"], "readability/braces"]
["src/nvim/ops.c", ["", "  /*", "   * Leave the cursor at the first non-blank of the last formatted line."], "readability/old_style_comment"]
["src/nvim/ops.c", ["   */", "  if (oap->end_adjusted && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)", "    ++curwin->w_cursor.lnum;"], "readability/braces"]
["src/nvim/ops.c", ["  if (oap->end_adjusted && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)", "    ++curwin->w_cursor.lnum;", "  beginline(BL_WHITE | BL_FIX);"], "readability/increment"]
["src/nvim/ops.c", ["", "  /* put '] mark on the end of the formatted area */", "  curbuf->b_op_end = curwin->w_cursor;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      if (wp->w_old_cursor_lnum != 0) {", "        /* When lines have been inserted or deleted, adjust the end of", "         * the Visual area to be redrawn. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Implementation of the format operator 'gq' for when using 'formatexpr'."], "readability/old_style_comment"]
["src/nvim/ops.c", ["{", "  if (oap->is_VIsual)", "    /* When there is no change: need to remove the Visual selection */"], "readability/braces"]
["src/nvim/ops.c", ["  if (oap->is_VIsual)", "    /* When there is no change: need to remove the Visual selection */", "    redraw_curbuf_later(INVERTED);"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (fex_format(oap->start.lnum, oap->line_count, NUL) != 0)", "    /* As documented: when 'formatexpr' returns non-zero fall back to"], "readability/braces"]
["src/nvim/ops.c", ["  if (fex_format(oap->start.lnum, oap->line_count, NUL) != 0)", "    /* As documented: when 'formatexpr' returns non-zero fall back to", "     * internal formatting. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["     * internal formatting. */", "    op_format(oap, FALSE);", "}"], "readability/bool"]
["src/nvim/ops.c", ["    long count,", "    int c                  /* character to be inserted */", ")"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Set v:lnum to the first line number and v:count to the number of lines."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Format \"line_count\" lines, starting at the cursor position."], "readability/old_style_comment"]
["src/nvim/ops.c", ["    linenr_T line_count,", "    int avoid_fex                          /* don't use 'formatexpr' */", ")"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  next_is_not_par = fmt_check_par(curwin->w_cursor.lnum", "      , &next_leader_len, &next_leader_flags, do_comments", "      );"], "whitespace/alignment"]
["src/nvim/ops.c", ["      , &next_leader_len, &next_leader_flags, do_comments", "      );", "  is_end_par = (is_not_par || next_is_not_par);"], "whitespace/alignment"]
["src/nvim/ops.c", ["      , &next_leader_len, &next_leader_flags, do_comments", "      );", "  is_end_par = (is_not_par || next_is_not_par);"], "whitespace/parens"]
["src/nvim/ops.c", ["  is_end_par = (is_not_par || next_is_not_par);", "  if (!is_end_par && do_trail_white)", "    is_end_par = !ends_in_white(curwin->w_cursor.lnum - 1);"], "readability/braces"]
["src/nvim/ops.c", ["  curwin->w_cursor.lnum--;", "  for (count = line_count; count != 0 && !got_int; --count) {", "    /*"], "readability/increment"]
["src/nvim/ops.c", ["  for (count = line_count; count != 0 && !got_int; --count) {", "    /*", "     * Advance to next paragraph."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /*", "     * The last line to be formatted."], "readability/old_style_comment"]
["src/nvim/ops.c", ["      next_is_not_par = fmt_check_par(curwin->w_cursor.lnum + 1", "          , &next_leader_len, &next_leader_flags, do_comments", "          );"], "whitespace/alignment"]
["src/nvim/ops.c", ["          , &next_leader_len, &next_leader_flags, do_comments", "          );", "      if (do_number_indent)"], "whitespace/alignment"]
["src/nvim/ops.c", ["          , &next_leader_len, &next_leader_flags, do_comments", "          );", "      if (do_number_indent)"], "whitespace/parens"]
["src/nvim/ops.c", ["          );", "      if (do_number_indent)", "        next_is_start_par ="], "readability/braces"]
["src/nvim/ops.c", ["    is_end_par = (is_not_par || next_is_not_par || next_is_start_par);", "    if (!is_end_par && do_trail_white)", "      is_end_par = !ends_in_white(curwin->w_cursor.lnum);"], "readability/braces"]
["src/nvim/ops.c", ["", "    /*", "     * Skip lines that are not in a paragraph."], "readability/old_style_comment"]
["src/nvim/ops.c", ["    if (is_not_par) {", "      if (line_count < 0)", "        break;"], "readability/braces"]
["src/nvim/ops.c", ["    } else {", "      /*", "       * For the first line of a paragraph, check indent of second line."], "readability/old_style_comment"]
["src/nvim/ops.c", ["          if (leader_len == 0 && next_leader_len == 0) {", "            /* no comment found */", "            second_indent ="], "readability/old_style_comment"]
["src/nvim/ops.c", ["          if (leader_len == 0 && next_leader_len == 0) {", "            /* no comment found */", "            second_indent ="], "readability/old_style_comment"]
["src/nvim/ops.c", ["          } else {", "            /* get_number_indent() is now \"comment aware\"... */", "            second_indent ="], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      /*", "       * When the comment leader changes, it's the end of the paragraph."], "readability/old_style_comment"]
["src/nvim/ops.c", ["       */", "      if (curwin->w_cursor.lnum >= curbuf->b_ml.ml_line_count", "          || !same_leader(curwin->w_cursor.lnum,"], "readability/braces"]
["src/nvim/ops.c", ["          || !same_leader(curwin->w_cursor.lnum,", "              leader_len, leader_flags,", "              next_leader_len, next_leader_flags)"], "whitespace/alignment"]
["src/nvim/ops.c", ["              leader_len, leader_flags,", "              next_leader_len, next_leader_flags)", "          )"], "whitespace/alignment"]
["src/nvim/ops.c", ["          || !same_leader(curwin->w_cursor.lnum,", "              leader_len, leader_flags,", "              next_leader_len, next_leader_flags)"], "whitespace/alignment"]
["src/nvim/ops.c", ["              leader_len, leader_flags,", "              next_leader_len, next_leader_flags)", "          )"], "whitespace/alignment"]
["src/nvim/ops.c", ["", "      /*", "       * If we have got to the end of a paragraph, or the line is"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      if (is_end_par || force_format) {", "        if (need_set_indent)", "          /* replace indent in first line with minimal number of"], "readability/braces"]
["src/nvim/ops.c", ["        if (need_set_indent)", "          /* replace indent in first line with minimal number of", "           * tabs and spaces, according to current options */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "        /* do the formatting, without 'showmode' */", "        State = INSERT;         /* for open_line() */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        /* do the formatting, without 'showmode' */", "        State = INSERT;         /* for open_line() */", "        smd_save = p_smd;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        smd_save = p_smd;", "        p_smd = FALSE;", "        insertchar(NUL, INSCHAR_FORMAT"], "readability/bool"]
["src/nvim/ops.c", ["        insertchar(NUL, INSCHAR_FORMAT", "            + (do_comments ? INSCHAR_DO_COM : 0)", "            + (do_comments && do_comments_list"], "whitespace/alignment"]
["src/nvim/ops.c", ["            + (do_comments ? INSCHAR_DO_COM : 0)", "            + (do_comments && do_comments_list", "               ? INSCHAR_COM_LIST : 0)"], "whitespace/alignment"]
["src/nvim/ops.c", ["               ? INSCHAR_COM_LIST : 0)", "            + (avoid_fex ? INSCHAR_NO_FEX : 0), second_indent);", "        State = old_State;"], "whitespace/alignment"]
["src/nvim/ops.c", ["        second_indent = -1;", "        /* at end of par.: need to set indent of next par. */", "        need_set_indent = is_end_par;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        if (is_end_par) {", "          /* When called with a negative line count, break at the", "           * end of the paragraph. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["           * end of the paragraph. */", "          if (line_count < 0)", "            break;"], "readability/braces"]
["src/nvim/ops.c", ["", "      /*", "       * When still in same paragraph, join the lines together.  But"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        curwin->w_cursor.col = 0;", "        if (line_count < 0 && u_save_cursor() == FAIL)", "          break;"], "readability/braces"]
["src/nvim/ops.c", ["        curwin->w_cursor.lnum--;", "        if (do_join(2, TRUE, FALSE, FALSE, false) == FAIL) {", "          beep_flush();"], "readability/bool"]
["src/nvim/ops.c", ["", "/*", " * Return TRUE if line \"lnum\" ends in a white character."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (*s == NUL)", "    return FALSE;"], "readability/braces"]
["src/nvim/ops.c", ["  if (*s == NUL)", "    return FALSE;", "  l = STRLEN(s) - 1;"], "readability/bool"]
["src/nvim/ops.c", ["", "/*", " * Blank lines, and lines containing only the comment leader, are left"], "readability/old_style_comment"]
["src/nvim/ops.c", [" */", "static int fmt_check_par(linenr_T lnum, int *leader_len, char_u **leader_flags, int do_comments)", "{"], "whitespace/line_length"]
["src/nvim/ops.c", ["{", "  char_u      *flags = NULL;        /* init for GCC */", "  char_u      *ptr;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  ptr = ml_get(lnum);", "  if (do_comments)", "    *leader_len = get_leader_len(ptr, leader_flags, FALSE, TRUE);"], "readability/braces"]
["src/nvim/ops.c", ["  if (do_comments)", "    *leader_len = get_leader_len(ptr, leader_flags, FALSE, TRUE);", "  else"], "readability/bool"]
["src/nvim/ops.c", ["    *leader_len = get_leader_len(ptr, leader_flags, FALSE, TRUE);", "  else", "    *leader_len = 0;"], "readability/braces"]
["src/nvim/ops.c", ["  if (*leader_len > 0) {", "    /*", "     * Search for 'e' flag in comment leader flags."], "readability/old_style_comment"]
["src/nvim/ops.c", ["    flags = *leader_flags;", "    while (*flags && *flags != ':' && *flags != COM_END)", "      ++flags;"], "readability/braces"]
["src/nvim/ops.c", ["    while (*flags && *flags != ':' && *flags != COM_END)", "      ++flags;", "  }"], "readability/increment"]
["src/nvim/ops.c", ["         || (*leader_len > 0 && *flags == COM_END)", "         || startPS(lnum, NUL, FALSE);", "}"], "readability/bool"]
["src/nvim/ops.c", ["", "/*", " * Return TRUE when a paragraph starts in line \"lnum\".  Return FALSE when the"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (lnum <= 1)", "    return TRUE;                /* start of the file */"], "readability/braces"]
["src/nvim/ops.c", ["  if (lnum <= 1)", "    return TRUE;                /* start of the file */", ""], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (lnum <= 1)", "    return TRUE;                /* start of the file */", ""], "readability/bool"]
["src/nvim/ops.c", ["  p = ml_get(lnum - 1);", "  if (*p == NUL)", "    return TRUE;                /* after empty line */"], "readability/braces"]
["src/nvim/ops.c", ["  if (*p == NUL)", "    return TRUE;                /* after empty line */", ""], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (*p == NUL)", "    return TRUE;                /* after empty line */", ""], "readability/bool"]
["src/nvim/ops.c", ["", "  if (has_format_option(FO_WHITE_PAR) && !ends_in_white(lnum - 1))", "    return TRUE;                /* missing trailing space in previous line. */"], "readability/braces"]
["src/nvim/ops.c", ["  if (has_format_option(FO_WHITE_PAR) && !ends_in_white(lnum - 1))", "    return TRUE;                /* missing trailing space in previous line. */", ""], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (has_format_option(FO_WHITE_PAR) && !ends_in_white(lnum - 1))", "    return TRUE;                /* missing trailing space in previous line. */", ""], "readability/bool"]
["src/nvim/ops.c", ["", "  if (has_format_option(FO_Q_NUMBER) && (get_number_indent(lnum) > 0))", "    return TRUE;                /* numbered item starts in \"lnum\". */"], "readability/braces"]
["src/nvim/ops.c", ["  if (has_format_option(FO_Q_NUMBER) && (get_number_indent(lnum) > 0))", "    return TRUE;                /* numbered item starts in \"lnum\". */", ""], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (has_format_option(FO_Q_NUMBER) && (get_number_indent(lnum) > 0))", "    return TRUE;                /* numbered item starts in \"lnum\". */", ""], "readability/bool"]
["src/nvim/ops.c", ["", "  if (!same_leader(lnum - 1, leader_len, leader_flags,", "          next_leader_len, next_leader_flags))"], "readability/braces"]
["src/nvim/ops.c", ["  if (!same_leader(lnum - 1, leader_len, leader_flags,", "          next_leader_len, next_leader_flags))", "    return TRUE;                /* change of comment leader. */"], "whitespace/alignment"]
["src/nvim/ops.c", ["          next_leader_len, next_leader_flags))", "    return TRUE;                /* change of comment leader. */", ""], "readability/old_style_comment"]
["src/nvim/ops.c", ["          next_leader_len, next_leader_flags))", "    return TRUE;                /* change of comment leader. */", ""], "readability/bool"]
["src/nvim/ops.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ops.c", ["", "/*", " * prepare a few things for block mode yank/delete/tilde"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  while (bdp->start_vcol < oap->start_vcol && *pstart) {", "    /* Count a tab for what it's worth (if list mode not on) */", "    incr = lbr_chartabsize(line, pstart, (colnr_T)bdp->start_vcol);"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  bdp->start_char_vcols = incr;", "  if (bdp->start_vcol < oap->start_vcol) {      /* line too short */", "    bdp->end_vcol = bdp->start_vcol;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  } else {", "    /* notice: this converts partly selected Multibyte characters to", "     * spaces, too. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    bdp->startspaces = bdp->start_vcol - oap->start_vcol;", "    if (is_del && bdp->startspaces)", "      bdp->startspaces = bdp->start_char_vcols - bdp->startspaces;"], "readability/braces"]
["src/nvim/ops.c", ["        if (is_del && oap->op_type != OP_LSHIFT) {", "          /* just putting the sum of those two into", "           * bdp->startspaces doesn't work for Visual replace,"], "readability/old_style_comment"]
["src/nvim/ops.c", ["      while (bdp->end_vcol <= oap->end_vcol && *pend != NUL) {", "        /* Count a tab for what it's worth (if list mode not on) */", "        prev_pend = pend;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["          bdp->endspaces = incr - bdp->endspaces;", "          if (pend != pstart)", "            pend = prev_pend;"], "readability/braces"]
["src/nvim/ops.c", ["    bdp->end_char_vcols = incr;", "    if (is_del && bdp->startspaces)", "      pstart = prev_pstart;"], "readability/braces"]
["src/nvim/ops.c", ["  }", "  bdp->textcol = (colnr_T) (pstart - line);", "  bdp->textstart = pstart;"], "whitespace/cast"]
["src/nvim/ops.c", ["", "/*", " * Return the type of a register."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (regname == '@')       /* \"@@\" is used for unnamed register */", "    regname = '\"';"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  if (regname == '@')       /* \"@@\" is used for unnamed register */", "    regname = '\"';"], "readability/braces"]
["src/nvim/ops.c", ["", "  /* check for valid regname */", "  if (regname != NUL && !valid_yank_reg(regname, false))"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  /* check for valid regname */", "  if (regname != NUL && !valid_yank_reg(regname, false))", "    return NULL;"], "readability/braces"]
["src/nvim/ops.c", ["  yankreg_T *reg = get_yank_register(regname, YREG_PASTE);", "  if (reg->y_array == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/ops.c", ["", "  /*", "   * Compute length of resulting string."], "readability/old_style_comment"]
["src/nvim/ops.c", ["    len += STRLEN(reg->y_array[i]);", "    /*", "     * Insert a newline between lines and after last line if"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Copy the lines of the yank register into the string."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /*", "     * Insert a NL between lines and after the last line if y_type is"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "static yankreg_T *init_write_reg(int name, yankreg_T **old_y_previous, bool must_append)", "{"], "whitespace/line_length"]
["src/nvim/ops.c", ["", "static void finish_write_reg(int name, yankreg_T *reg, yankreg_T *old_y_previous)", "{"], "whitespace/line_length"]
["src/nvim/ops.c", ["  if (len < 0) {", "    len = (ssize_t) STRLEN(str);", "  }"], "whitespace/cast"]
["src/nvim/ops.c", ["", "  /* Special case: '/' search pattern */", "  if (name == '/') {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (name == '/') {", "    set_last_search_pat(str, RE_SEARCH, TRUE, TRUE);", "    return;"], "readability/bool"]
["src/nvim/ops.c", ["    size_t offset = 0;", "    size_t totlen = (size_t) len;", ""], "whitespace/cast"]
["src/nvim/ops.c", ["  if (str_list) {", "    for (char_u **ss = (char_u **) str; *ss != NULL; ++ss) {", "      newlines++;"], "whitespace/cast"]
["src/nvim/ops.c", ["  if (str_list) {", "    for (char_u **ss = (char_u **) str; *ss != NULL; ++ss) {", "      newlines++;"], "readability/increment"]
["src/nvim/ops.c", ["      extraline = 1;", "      ++newlines;         // count extra newline at the end", "    }"], "readability/increment"]
["src/nvim/ops.c", ["      append = true;", "      --newlines;         // uncount newline when appending first line", "    }"], "readability/increment"]
["src/nvim/ops.c", ["  if (str_list) {", "    for (char_u **ss = (char_u **) str; *ss != NULL; ++ss, ++lnum) {", "      size_t ss_len = STRLEN(*ss);"], "whitespace/cast"]
["src/nvim/ops.c", ["  if (str_list) {", "    for (char_u **ss = (char_u **) str; *ss != NULL; ++ss, ++lnum) {", "      size_t ss_len = STRLEN(*ss);"], "readability/increment"]
["src/nvim/ops.c", ["  if (yank_type == kMTBlockWise) {", "    y_ptr->y_width = (blocklen == -1 ? (colnr_T) maxlen - 1 : blocklen);", "  } else {"], "whitespace/cast"]
["src/nvim/ops.c", ["", "/*", " *  Count the number of bytes, characters and \"words\" in a line."], "readability/old_style_comment"]
["src/nvim/ops.c", ["      }", "    } else if (!ascii_isspace(line[i]))", "      is_word = 1;"], "readability/braces"]
["src/nvim/ops.c", ["      is_word = 1;", "    ++chars;", "    i += (*mb_ptr2len)(line + i);"], "readability/increment"]
["src/nvim/ops.c", ["", "  if (is_word)", "    words++;"], "readability/braces"]
["src/nvim/ops.c", ["", "  /* Add eol_size if the end of line was reached before hitting limit. */", "  if (i < limit && line[i] == NUL) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  } else {", "    if (get_fileformat(curbuf) == EOL_DOS)", "      eol_size = 2;"], "readability/braces"]
["src/nvim/ops.c", ["      eol_size = 2;", "    else", "      eol_size = 1;"], "readability/braces"]
["src/nvim/ops.c", ["      }", "      if (*p_sel == 'e' && max_pos.col > 0)", "        --max_pos.col;"], "readability/braces"]
["src/nvim/ops.c", ["      if (*p_sel == 'e' && max_pos.col > 0)", "        --max_pos.col;", ""], "readability/increment"]
["src/nvim/ops.c", ["", "        /* Make 'sbr' empty for a moment to get the correct size. */", "        p_sbr = empty_option;"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        getvcols(curwin, &min_pos, &max_pos,", "            &oparg.start_vcol, &oparg.end_vcol);", "        p_sbr = saved_sbr;"], "whitespace/alignment"]
["src/nvim/ops.c", ["        p_sbr = saved_sbr;", "        if (curwin->w_curswant == MAXCOL)", "          oparg.end_vcol = MAXCOL;"], "readability/braces"]
["src/nvim/ops.c", ["          oparg.end_vcol = MAXCOL;", "        /* Swap the start, end vcol if needed */", "        if (oparg.end_vcol < oparg.start_vcol) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum) {", "      /* Check for a CTRL-C every 100000 characters. */"], "readability/increment"]
["src/nvim/ops.c", ["    for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum) {", "      /* Check for a CTRL-C every 100000 characters. */", "      if (byte_count > last_check) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        os_breakcheck();", "        if (got_int)", "          return;"], "readability/braces"]
["src/nvim/ops.c", ["", "      /* Do extra processing for VIsual mode. */", "      if (l_VIsual_active"], "readability/old_style_comment"]
["src/nvim/ops.c", ["          byte_count_cursor += line_count_info(s, &word_count_cursor,", "              &char_count_cursor, len, eol_size);", "          if (lnum == curbuf->b_ml.ml_line_count"], "whitespace/alignment"]
["src/nvim/ops.c", ["              &char_count_cursor, len, eol_size);", "          if (lnum == curbuf->b_ml.ml_line_count", "              && !curbuf->b_p_eol"], "readability/braces"]
["src/nvim/ops.c", ["      } else {", "        /* In non-visual mode, check for the line the cursor is on */", "        if (lnum == curwin->w_cursor.lnum) {"], "readability/old_style_comment"]
["src/nvim/ops.c", ["///", "/// @returns the name of of a clipboard register that should be used, or `NUL` if none.", "int get_default_register_name(void)"], "whitespace/line_length"]
["src/nvim/ops.c", ["", "  if (reg->y_size > 0 && strlen((char*)reg->y_array[reg->y_size-1]) == 0) {", "    // a known-to-be charwise yank might have a final linebreak"], "whitespace/operators"]
["src/nvim/ops.c", ["    if (!reg_empty(iter_reg)) {", "      return (void *) iter_reg;", "    }"], "whitespace/cast"]
