["src/nvim/regexp_nfa.c", ["", "/*", " * NFA regular expression implementation."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Logging of NFA engine."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/* Added to NFA_ANY - NFA_NUPPER_IC to include a NL. */", "#define NFA_ADD_NL              31"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_MATCH,", "  NFA_EMPTY,                        /* matches 0-length */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  NFA_START_COLL,                   /* [abc] start */", "  NFA_END_COLL,                     /* [abc] end */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_START_COLL,                   /* [abc] start */", "  NFA_END_COLL,                     /* [abc] end */", "  NFA_START_NEG_COLL,               /* [^abc] start */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_END_COLL,                     /* [abc] end */", "  NFA_START_NEG_COLL,               /* [^abc] start */", "  NFA_END_NEG_COLL,                 /* [^abc] end (postfix only) */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_START_NEG_COLL,               /* [^abc] start */", "  NFA_END_NEG_COLL,                 /* [^abc] end (postfix only) */", "  NFA_RANGE,                        /* range of the two previous items"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_END_NEG_COLL,                 /* [^abc] end (postfix only) */", "  NFA_RANGE,                        /* range of the two previous items", "                                     * (postfix only) */"], "readability/multiline_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_END_NEG_COLL,                 /* [^abc] end (postfix only) */", "  NFA_RANGE,                        /* range of the two previous items", "                                     * (postfix only) */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["                                     * (postfix only) */", "  NFA_RANGE_MIN,                    /* low end of a range  */", "  NFA_RANGE_MAX,                    /* high end of a range  */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_RANGE_MIN,                    /* low end of a range  */", "  NFA_RANGE_MAX,                    /* high end of a range  */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  NFA_BOL,                          /* ^    Begin line */", "  NFA_EOL,                          /* $    End line */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_BOL,                          /* ^    Begin line */", "  NFA_EOL,                          /* $    End line */", "  NFA_BOW,                          /* \\<   Begin word */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_EOL,                          /* $    End line */", "  NFA_BOW,                          /* \\<   Begin word */", "  NFA_EOW,                          /* \\>   End word */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_BOW,                          /* \\<   Begin word */", "  NFA_EOW,                          /* \\>   End word */", "  NFA_BOF,                          /* \\%^  Begin file */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_EOW,                          /* \\>   End word */", "  NFA_BOF,                          /* \\%^  Begin file */", "  NFA_EOF,                          /* \\%$  End file */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_BOF,                          /* \\%^  Begin file */", "  NFA_EOF,                          /* \\%$  End file */", "  NFA_NEWL,"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_NEWL,", "  NFA_ZSTART,                       /* Used for \\zs */", "  NFA_ZEND,                         /* Used for \\ze */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ZSTART,                       /* Used for \\zs */", "  NFA_ZEND,                         /* Used for \\ze */", "  NFA_NOPEN,                        /* Start of subexpression marked with \\%( */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ZEND,                         /* Used for \\ze */", "  NFA_NOPEN,                        /* Start of subexpression marked with \\%( */", "  NFA_NCLOSE,                       /* End of subexpr. marked with \\%( ... \\) */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_NOPEN,                        /* Start of subexpression marked with \\%( */", "  NFA_NCLOSE,                       /* End of subexpr. marked with \\%( ... \\) */", "  NFA_START_INVISIBLE,"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_END_PATTERN,", "  NFA_COMPOSING,                    /* Next nodes in NFA are part of the", "                                       composing multibyte char */"], "readability/multiline_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_END_PATTERN,", "  NFA_COMPOSING,                    /* Next nodes in NFA are part of the", "                                       composing multibyte char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["                                       composing multibyte char */", "  NFA_END_COMPOSING,                /* End of a composing char in the NFA */", "  NFA_ANY_COMPOSING,                // \\%C: Any composing characters."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ANY_COMPOSING,                // \\%C: Any composing characters.", "  NFA_OPT_CHARS,                    /* \\%[abc] */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* The following are used only in the postfix form, not in the NFA */", "  NFA_PREV_ATOM_NO_WIDTH,           /* Used for \\@= */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  /* The following are used only in the postfix form, not in the NFA */", "  NFA_PREV_ATOM_NO_WIDTH,           /* Used for \\@= */", "  NFA_PREV_ATOM_NO_WIDTH_NEG,       /* Used for \\@! */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_PREV_ATOM_NO_WIDTH,           /* Used for \\@= */", "  NFA_PREV_ATOM_NO_WIDTH_NEG,       /* Used for \\@! */", "  NFA_PREV_ATOM_JUST_BEFORE,        /* Used for \\@<= */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_PREV_ATOM_NO_WIDTH_NEG,       /* Used for \\@! */", "  NFA_PREV_ATOM_JUST_BEFORE,        /* Used for \\@<= */", "  NFA_PREV_ATOM_JUST_BEFORE_NEG,    /* Used for \\@<! */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_PREV_ATOM_JUST_BEFORE,        /* Used for \\@<= */", "  NFA_PREV_ATOM_JUST_BEFORE_NEG,    /* Used for \\@<! */", "  NFA_PREV_ATOM_LIKE_PATTERN,       /* Used for \\@> */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_PREV_ATOM_JUST_BEFORE_NEG,    /* Used for \\@<! */", "  NFA_PREV_ATOM_LIKE_PATTERN,       /* Used for \\@> */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  NFA_BACKREF1,                     /* \\1 */", "  NFA_BACKREF2,                     /* \\2 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_BACKREF1,                     /* \\1 */", "  NFA_BACKREF2,                     /* \\2 */", "  NFA_BACKREF3,                     /* \\3 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_BACKREF2,                     /* \\2 */", "  NFA_BACKREF3,                     /* \\3 */", "  NFA_BACKREF4,                     /* \\4 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_BACKREF3,                     /* \\3 */", "  NFA_BACKREF4,                     /* \\4 */", "  NFA_BACKREF5,                     /* \\5 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_BACKREF4,                     /* \\4 */", "  NFA_BACKREF5,                     /* \\5 */", "  NFA_BACKREF6,                     /* \\6 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_BACKREF5,                     /* \\5 */", "  NFA_BACKREF6,                     /* \\6 */", "  NFA_BACKREF7,                     /* \\7 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_BACKREF6,                     /* \\6 */", "  NFA_BACKREF7,                     /* \\7 */", "  NFA_BACKREF8,                     /* \\8 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_BACKREF7,                     /* \\7 */", "  NFA_BACKREF8,                     /* \\8 */", "  NFA_BACKREF9,                     /* \\9 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_BACKREF8,                     /* \\8 */", "  NFA_BACKREF9,                     /* \\9 */", "  NFA_ZREF1,                        /* \\z1 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_BACKREF9,                     /* \\9 */", "  NFA_ZREF1,                        /* \\z1 */", "  NFA_ZREF2,                        /* \\z2 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ZREF1,                        /* \\z1 */", "  NFA_ZREF2,                        /* \\z2 */", "  NFA_ZREF3,                        /* \\z3 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ZREF2,                        /* \\z2 */", "  NFA_ZREF3,                        /* \\z3 */", "  NFA_ZREF4,                        /* \\z4 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ZREF3,                        /* \\z3 */", "  NFA_ZREF4,                        /* \\z4 */", "  NFA_ZREF5,                        /* \\z5 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ZREF4,                        /* \\z4 */", "  NFA_ZREF5,                        /* \\z5 */", "  NFA_ZREF6,                        /* \\z6 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ZREF5,                        /* \\z5 */", "  NFA_ZREF6,                        /* \\z6 */", "  NFA_ZREF7,                        /* \\z7 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ZREF6,                        /* \\z6 */", "  NFA_ZREF7,                        /* \\z7 */", "  NFA_ZREF8,                        /* \\z8 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ZREF7,                        /* \\z7 */", "  NFA_ZREF8,                        /* \\z8 */", "  NFA_ZREF9,                        /* \\z9 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ZREF8,                        /* \\z8 */", "  NFA_ZREF9,                        /* \\z9 */", "  NFA_SKIP,                         /* Skip characters */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ZREF9,                        /* \\z9 */", "  NFA_SKIP,                         /* Skip characters */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* NFA_FIRST_NL */", "  NFA_ANY,              /*\tMatch any one character. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  /* NFA_FIRST_NL */", "  NFA_ANY,              /*\tMatch any one character. */", "  NFA_IDENT,            /*\tMatch identifier char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  /* NFA_FIRST_NL */", "  NFA_ANY,              /*\tMatch any one character. */", "  NFA_IDENT,            /*\tMatch identifier char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_ANY,              /*\tMatch any one character. */", "  NFA_IDENT,            /*\tMatch identifier char */", "  NFA_SIDENT,           /*\tMatch identifier char but no digit */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ANY,              /*\tMatch any one character. */", "  NFA_IDENT,            /*\tMatch identifier char */", "  NFA_SIDENT,           /*\tMatch identifier char but no digit */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_IDENT,            /*\tMatch identifier char */", "  NFA_SIDENT,           /*\tMatch identifier char but no digit */", "  NFA_KWORD,            /*\tMatch keyword char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_IDENT,            /*\tMatch identifier char */", "  NFA_SIDENT,           /*\tMatch identifier char but no digit */", "  NFA_KWORD,            /*\tMatch keyword char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_SIDENT,           /*\tMatch identifier char but no digit */", "  NFA_KWORD,            /*\tMatch keyword char */", "  NFA_SKWORD,           /*\tMatch word char but no digit */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_SIDENT,           /*\tMatch identifier char but no digit */", "  NFA_KWORD,            /*\tMatch keyword char */", "  NFA_SKWORD,           /*\tMatch word char but no digit */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_KWORD,            /*\tMatch keyword char */", "  NFA_SKWORD,           /*\tMatch word char but no digit */", "  NFA_FNAME,            /*\tMatch file name char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_KWORD,            /*\tMatch keyword char */", "  NFA_SKWORD,           /*\tMatch word char but no digit */", "  NFA_FNAME,            /*\tMatch file name char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_SKWORD,           /*\tMatch word char but no digit */", "  NFA_FNAME,            /*\tMatch file name char */", "  NFA_SFNAME,           /*\tMatch file name char but no digit */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_SKWORD,           /*\tMatch word char but no digit */", "  NFA_FNAME,            /*\tMatch file name char */", "  NFA_SFNAME,           /*\tMatch file name char but no digit */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_FNAME,            /*\tMatch file name char */", "  NFA_SFNAME,           /*\tMatch file name char but no digit */", "  NFA_PRINT,            /*\tMatch printable char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_FNAME,            /*\tMatch file name char */", "  NFA_SFNAME,           /*\tMatch file name char but no digit */", "  NFA_PRINT,            /*\tMatch printable char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_SFNAME,           /*\tMatch file name char but no digit */", "  NFA_PRINT,            /*\tMatch printable char */", "  NFA_SPRINT,           /*\tMatch printable char but no digit */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_SFNAME,           /*\tMatch file name char but no digit */", "  NFA_PRINT,            /*\tMatch printable char */", "  NFA_SPRINT,           /*\tMatch printable char but no digit */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_PRINT,            /*\tMatch printable char */", "  NFA_SPRINT,           /*\tMatch printable char but no digit */", "  NFA_WHITE,            /*\tMatch whitespace char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_PRINT,            /*\tMatch printable char */", "  NFA_SPRINT,           /*\tMatch printable char but no digit */", "  NFA_WHITE,            /*\tMatch whitespace char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_SPRINT,           /*\tMatch printable char but no digit */", "  NFA_WHITE,            /*\tMatch whitespace char */", "  NFA_NWHITE,           /*\tMatch non-whitespace char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_SPRINT,           /*\tMatch printable char but no digit */", "  NFA_WHITE,            /*\tMatch whitespace char */", "  NFA_NWHITE,           /*\tMatch non-whitespace char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_WHITE,            /*\tMatch whitespace char */", "  NFA_NWHITE,           /*\tMatch non-whitespace char */", "  NFA_DIGIT,            /*\tMatch digit char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_WHITE,            /*\tMatch whitespace char */", "  NFA_NWHITE,           /*\tMatch non-whitespace char */", "  NFA_DIGIT,            /*\tMatch digit char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NWHITE,           /*\tMatch non-whitespace char */", "  NFA_DIGIT,            /*\tMatch digit char */", "  NFA_NDIGIT,           /*\tMatch non-digit char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_NWHITE,           /*\tMatch non-whitespace char */", "  NFA_DIGIT,            /*\tMatch digit char */", "  NFA_NDIGIT,           /*\tMatch non-digit char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_DIGIT,            /*\tMatch digit char */", "  NFA_NDIGIT,           /*\tMatch non-digit char */", "  NFA_HEX,              /*\tMatch hex char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_DIGIT,            /*\tMatch digit char */", "  NFA_NDIGIT,           /*\tMatch non-digit char */", "  NFA_HEX,              /*\tMatch hex char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NDIGIT,           /*\tMatch non-digit char */", "  NFA_HEX,              /*\tMatch hex char */", "  NFA_NHEX,             /*\tMatch non-hex char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_NDIGIT,           /*\tMatch non-digit char */", "  NFA_HEX,              /*\tMatch hex char */", "  NFA_NHEX,             /*\tMatch non-hex char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_HEX,              /*\tMatch hex char */", "  NFA_NHEX,             /*\tMatch non-hex char */", "  NFA_OCTAL,            /*\tMatch octal char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_HEX,              /*\tMatch hex char */", "  NFA_NHEX,             /*\tMatch non-hex char */", "  NFA_OCTAL,            /*\tMatch octal char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NHEX,             /*\tMatch non-hex char */", "  NFA_OCTAL,            /*\tMatch octal char */", "  NFA_NOCTAL,           /*\tMatch non-octal char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_NHEX,             /*\tMatch non-hex char */", "  NFA_OCTAL,            /*\tMatch octal char */", "  NFA_NOCTAL,           /*\tMatch non-octal char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_OCTAL,            /*\tMatch octal char */", "  NFA_NOCTAL,           /*\tMatch non-octal char */", "  NFA_WORD,             /*\tMatch word char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_OCTAL,            /*\tMatch octal char */", "  NFA_NOCTAL,           /*\tMatch non-octal char */", "  NFA_WORD,             /*\tMatch word char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NOCTAL,           /*\tMatch non-octal char */", "  NFA_WORD,             /*\tMatch word char */", "  NFA_NWORD,            /*\tMatch non-word char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_NOCTAL,           /*\tMatch non-octal char */", "  NFA_WORD,             /*\tMatch word char */", "  NFA_NWORD,            /*\tMatch non-word char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_WORD,             /*\tMatch word char */", "  NFA_NWORD,            /*\tMatch non-word char */", "  NFA_HEAD,             /*\tMatch head char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_WORD,             /*\tMatch word char */", "  NFA_NWORD,            /*\tMatch non-word char */", "  NFA_HEAD,             /*\tMatch head char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NWORD,            /*\tMatch non-word char */", "  NFA_HEAD,             /*\tMatch head char */", "  NFA_NHEAD,            /*\tMatch non-head char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_NWORD,            /*\tMatch non-word char */", "  NFA_HEAD,             /*\tMatch head char */", "  NFA_NHEAD,            /*\tMatch non-head char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_HEAD,             /*\tMatch head char */", "  NFA_NHEAD,            /*\tMatch non-head char */", "  NFA_ALPHA,            /*\tMatch alpha char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_HEAD,             /*\tMatch head char */", "  NFA_NHEAD,            /*\tMatch non-head char */", "  NFA_ALPHA,            /*\tMatch alpha char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NHEAD,            /*\tMatch non-head char */", "  NFA_ALPHA,            /*\tMatch alpha char */", "  NFA_NALPHA,           /*\tMatch non-alpha char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_NHEAD,            /*\tMatch non-head char */", "  NFA_ALPHA,            /*\tMatch alpha char */", "  NFA_NALPHA,           /*\tMatch non-alpha char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_ALPHA,            /*\tMatch alpha char */", "  NFA_NALPHA,           /*\tMatch non-alpha char */", "  NFA_LOWER,            /*\tMatch lowercase char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_ALPHA,            /*\tMatch alpha char */", "  NFA_NALPHA,           /*\tMatch non-alpha char */", "  NFA_LOWER,            /*\tMatch lowercase char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NALPHA,           /*\tMatch non-alpha char */", "  NFA_LOWER,            /*\tMatch lowercase char */", "  NFA_NLOWER,           /*\tMatch non-lowercase char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_NALPHA,           /*\tMatch non-alpha char */", "  NFA_LOWER,            /*\tMatch lowercase char */", "  NFA_NLOWER,           /*\tMatch non-lowercase char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_LOWER,            /*\tMatch lowercase char */", "  NFA_NLOWER,           /*\tMatch non-lowercase char */", "  NFA_UPPER,            /*\tMatch uppercase char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_LOWER,            /*\tMatch lowercase char */", "  NFA_NLOWER,           /*\tMatch non-lowercase char */", "  NFA_UPPER,            /*\tMatch uppercase char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NLOWER,           /*\tMatch non-lowercase char */", "  NFA_UPPER,            /*\tMatch uppercase char */", "  NFA_NUPPER,           /*\tMatch non-uppercase char */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_NLOWER,           /*\tMatch non-lowercase char */", "  NFA_UPPER,            /*\tMatch uppercase char */", "  NFA_NUPPER,           /*\tMatch non-uppercase char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_UPPER,            /*\tMatch uppercase char */", "  NFA_NUPPER,           /*\tMatch non-uppercase char */", "  NFA_LOWER_IC,         /*\tMatch [a-z] */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_UPPER,            /*\tMatch uppercase char */", "  NFA_NUPPER,           /*\tMatch non-uppercase char */", "  NFA_LOWER_IC,         /*\tMatch [a-z] */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NUPPER,           /*\tMatch non-uppercase char */", "  NFA_LOWER_IC,         /*\tMatch [a-z] */", "  NFA_NLOWER_IC,        /*\tMatch [^a-z] */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_NUPPER,           /*\tMatch non-uppercase char */", "  NFA_LOWER_IC,         /*\tMatch [a-z] */", "  NFA_NLOWER_IC,        /*\tMatch [^a-z] */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_LOWER_IC,         /*\tMatch [a-z] */", "  NFA_NLOWER_IC,        /*\tMatch [^a-z] */", "  NFA_UPPER_IC,         /*\tMatch [A-Z] */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_LOWER_IC,         /*\tMatch [a-z] */", "  NFA_NLOWER_IC,        /*\tMatch [^a-z] */", "  NFA_UPPER_IC,         /*\tMatch [A-Z] */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NLOWER_IC,        /*\tMatch [^a-z] */", "  NFA_UPPER_IC,         /*\tMatch [A-Z] */", "  NFA_NUPPER_IC,        /*\tMatch [^A-Z] */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_NLOWER_IC,        /*\tMatch [^a-z] */", "  NFA_UPPER_IC,         /*\tMatch [A-Z] */", "  NFA_NUPPER_IC,        /*\tMatch [^A-Z] */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_UPPER_IC,         /*\tMatch [A-Z] */", "  NFA_NUPPER_IC,        /*\tMatch [^A-Z] */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_UPPER_IC,         /*\tMatch [A-Z] */", "  NFA_NUPPER_IC,        /*\tMatch [^A-Z] */", ""], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "  NFA_CURSOR,           /*\tMatch cursor pos */", "  NFA_LNUM,             /*\tMatch line number */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  NFA_CURSOR,           /*\tMatch cursor pos */", "  NFA_LNUM,             /*\tMatch line number */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_CURSOR,           /*\tMatch cursor pos */", "  NFA_LNUM,             /*\tMatch line number */", "  NFA_LNUM_GT,          /*\tMatch > line number */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_CURSOR,           /*\tMatch cursor pos */", "  NFA_LNUM,             /*\tMatch line number */", "  NFA_LNUM_GT,          /*\tMatch > line number */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_LNUM,             /*\tMatch line number */", "  NFA_LNUM_GT,          /*\tMatch > line number */", "  NFA_LNUM_LT,          /*\tMatch < line number */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_LNUM,             /*\tMatch line number */", "  NFA_LNUM_GT,          /*\tMatch > line number */", "  NFA_LNUM_LT,          /*\tMatch < line number */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_LNUM_GT,          /*\tMatch > line number */", "  NFA_LNUM_LT,          /*\tMatch < line number */", "  NFA_COL,              /*\tMatch cursor column */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_LNUM_GT,          /*\tMatch > line number */", "  NFA_LNUM_LT,          /*\tMatch < line number */", "  NFA_COL,              /*\tMatch cursor column */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_LNUM_LT,          /*\tMatch < line number */", "  NFA_COL,              /*\tMatch cursor column */", "  NFA_COL_GT,           /*\tMatch > cursor column */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_LNUM_LT,          /*\tMatch < line number */", "  NFA_COL,              /*\tMatch cursor column */", "  NFA_COL_GT,           /*\tMatch > cursor column */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_COL,              /*\tMatch cursor column */", "  NFA_COL_GT,           /*\tMatch > cursor column */", "  NFA_COL_LT,           /*\tMatch < cursor column */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_COL,              /*\tMatch cursor column */", "  NFA_COL_GT,           /*\tMatch > cursor column */", "  NFA_COL_LT,           /*\tMatch < cursor column */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_COL_GT,           /*\tMatch > cursor column */", "  NFA_COL_LT,           /*\tMatch < cursor column */", "  NFA_VCOL,             /*\tMatch cursor virtual column */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_COL_GT,           /*\tMatch > cursor column */", "  NFA_COL_LT,           /*\tMatch < cursor column */", "  NFA_VCOL,             /*\tMatch cursor virtual column */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_COL_LT,           /*\tMatch < cursor column */", "  NFA_VCOL,             /*\tMatch cursor virtual column */", "  NFA_VCOL_GT,          /*\tMatch > cursor virtual column */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_COL_LT,           /*\tMatch < cursor column */", "  NFA_VCOL,             /*\tMatch cursor virtual column */", "  NFA_VCOL_GT,          /*\tMatch > cursor virtual column */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_VCOL,             /*\tMatch cursor virtual column */", "  NFA_VCOL_GT,          /*\tMatch > cursor virtual column */", "  NFA_VCOL_LT,          /*\tMatch < cursor virtual column */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_VCOL,             /*\tMatch cursor virtual column */", "  NFA_VCOL_GT,          /*\tMatch > cursor virtual column */", "  NFA_VCOL_LT,          /*\tMatch < cursor virtual column */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_VCOL_GT,          /*\tMatch > cursor virtual column */", "  NFA_VCOL_LT,          /*\tMatch < cursor virtual column */", "  NFA_MARK,             /*\tMatch mark */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_VCOL_GT,          /*\tMatch > cursor virtual column */", "  NFA_VCOL_LT,          /*\tMatch < cursor virtual column */", "  NFA_MARK,             /*\tMatch mark */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_VCOL_LT,          /*\tMatch < cursor virtual column */", "  NFA_MARK,             /*\tMatch mark */", "  NFA_MARK_GT,          /*\tMatch > mark */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_VCOL_LT,          /*\tMatch < cursor virtual column */", "  NFA_MARK,             /*\tMatch mark */", "  NFA_MARK_GT,          /*\tMatch > mark */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_MARK,             /*\tMatch mark */", "  NFA_MARK_GT,          /*\tMatch > mark */", "  NFA_MARK_LT,          /*\tMatch < mark */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_MARK,             /*\tMatch mark */", "  NFA_MARK_GT,          /*\tMatch > mark */", "  NFA_MARK_LT,          /*\tMatch < mark */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_MARK_GT,          /*\tMatch > mark */", "  NFA_MARK_LT,          /*\tMatch < mark */", "  NFA_VISUAL,           /*\tMatch Visual area */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_MARK_GT,          /*\tMatch > mark */", "  NFA_MARK_LT,          /*\tMatch < mark */", "  NFA_VISUAL,           /*\tMatch Visual area */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_MARK_LT,          /*\tMatch < mark */", "  NFA_VISUAL,           /*\tMatch Visual area */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  NFA_MARK_LT,          /*\tMatch < mark */", "  NFA_VISUAL,           /*\tMatch Visual area */", ""], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "  /* Character classes [:alnum:] etc */", "  NFA_CLASS_ALNUM,"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/* Keep in sync with classchars. */", "static int nfa_classcodes[] = {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["static int nfa_classcodes[] = {", "  NFA_ANY, NFA_IDENT, NFA_SIDENT, NFA_KWORD,NFA_SKWORD,", "  NFA_FNAME, NFA_SFNAME, NFA_PRINT, NFA_SPRINT,"], "whitespace/comma"]
["src/nvim/regexp_nfa.c", ["", "/* Since the out pointers in the list are always", " * uninitialized, we use the pointers themselves"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["typedef struct {", "  regsub_T norm;      /* \\( .. \\) matches */", "  regsub_T synt;      /* \\z( .. \\) matches */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  regsub_T norm;      /* \\( .. \\) matches */", "  regsub_T synt;      /* \\z( .. \\) matches */", "} regsubs_T;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/* nfa_pim_T stores a Postponed Invisible Match. */", "typedef struct nfa_pim_S nfa_pim_T;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["struct nfa_pim_S {", "  int result;                   /* NFA_PIM_*, see below */", "  nfa_state_T *state;           /* the invisible match start state */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  int result;                   /* NFA_PIM_*, see below */", "  nfa_state_T *state;           /* the invisible match start state */", "  regsubs_T subs;               /* submatch info, only party used */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  nfa_state_T *state;           /* the invisible match start state */", "  regsubs_T subs;               /* submatch info, only party used */", "  union {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    char_u  *ptr;", "  } end;                        /* where the match must end */", "};"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/* nfa_thread_T contains execution information of a NFA state */", "typedef struct {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  int count;", "  nfa_pim_T pim;                /* if pim.result != NFA_PIM_UNUSED: postponed", "                                 * invisible match */"], "readability/multiline_comment"]
["src/nvim/regexp_nfa.c", ["  int count;", "  nfa_pim_T pim;                /* if pim.result != NFA_PIM_UNUSED: postponed", "                                 * invisible match */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["                                 * invisible match */", "  regsubs_T subs;               /* submatch info, only party used */", "} nfa_thread_T;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/* If not NULL match must end at this position */", "static save_se_T *nfa_endp = NULL;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/* 0 for first call to nfa_regmatch(), 1 for recursive call. */", "static int nfa_ll_index = 0;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Initialize internal variables before NFA compilation."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["static void", "nfa_regcomp_start (", "    char_u *expr,"], "whitespace/parens"]
["src/nvim/regexp_nfa.c", ["    char_u *expr,", "    int re_flags                       /* see vim_regcomp() */", ")"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  istate = 0;", "  /* A reasonable estimation for maximum size */", "  nstate_max = (STRLEN(expr) + 1) * 25;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* Some items blow up in size, such as [A-z].  Add more space for that.", "   * When it is still not enough realloc_post_list() will be used. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* Size for postfix representation of expr. */", "  postfix_size = sizeof(int) * nstate_max;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* shared with BT engine */", "  regcomp_start(expr, re_flags);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Figure out if the NFA state list starts with an anchor, must match at start"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  if (depth > 4)", "    return 0;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    case NFA_BOF:", "      return 1;           /* yes! */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    default:", "      return 0;           /* noooo */", "    }"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Figure out if the NFA state list starts with a character which must match"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  if (depth > 4)", "    return 0;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    switch (p->c) {", "    /* all kinds of zero-width matches */", "    case NFA_BOL:"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "      if (c1 == c2)", "        return c1;             /* yes! */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      if (c1 == c2)", "        return c1;             /* yes! */", "      return 0;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    default:", "      if (p->c > 0)", "        return p->c;             /* yes! */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      if (p->c > 0)", "        return p->c;             /* yes! */", "      return 0;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Figure out if the NFA state list contains just literal text and nothing"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  if (p->c != NFA_MOPEN)", "    return NULL;     /* just in case */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  if (p->c != NFA_MOPEN)", "    return NULL;     /* just in case */", "  p = p->out;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  }", "  if (p->c != NFA_MCLOSE || p->out->c != NFA_MATCH)", "    return NULL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  ret = xmalloc(len);", "  p = start->out->out;     /* skip first char, it goes into regstart */", "  s = ret;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Allocate more space for post_start.  Called when"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Search between \"start\" and \"end\" and try to recognize a"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  if (*end != ']')", "    return FAIL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      p++;", "    } else", "      return FAIL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      return FAIL;", "  }   /* while (p < end) */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  if (p != end)", "    return FAIL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Produce the bytes for equivalence class \"c\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["{", "#define EMIT2(c)   EMIT(c); EMIT(NFA_CONCAT);", "#define EMITMBC(c) EMIT(c); EMIT(NFA_CONCAT);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["#define EMIT2(c)   EMIT(c); EMIT(NFA_CONCAT);", "#define EMITMBC(c) EMIT(c); EMIT(NFA_CONCAT);", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x1ea2)", "      EMIT2('A'); EMIT2(A_grave); EMIT2(A_acute);", "      EMIT2(A_circumflex); EMIT2(A_virguilla);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2('A'); EMIT2(A_grave); EMIT2(A_acute);", "      EMIT2(A_circumflex); EMIT2(A_virguilla);", "      EMIT2(A_diaeresis); EMIT2(A_ring);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2(A_circumflex); EMIT2(A_virguilla);", "      EMIT2(A_diaeresis); EMIT2(A_ring);", "      EMITMBC(0x100) EMITMBC(0x102) EMITMBC(0x104)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x10c)", "      EMIT2('C'); EMIT2(C_cedilla); EMITMBC(0x106) EMITMBC(0x108)", "      EMITMBC(0x10a) EMITMBC(0x10c)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x1eba) CASEMBC(0x1ebc)", "      EMIT2('E'); EMIT2(E_grave); EMIT2(E_acute);", "      EMIT2(E_circumflex); EMIT2(E_diaeresis);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2('E'); EMIT2(E_grave); EMIT2(E_acute);", "      EMIT2(E_circumflex); EMIT2(E_diaeresis);", "      EMITMBC(0x112) EMITMBC(0x114) EMITMBC(0x116)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x1cf) CASEMBC(0x1ec8)", "      EMIT2('I'); EMIT2(I_grave); EMIT2(I_acute);", "      EMIT2(I_circumflex); EMIT2(I_diaeresis);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2('I'); EMIT2(I_grave); EMIT2(I_acute);", "      EMIT2(I_circumflex); EMIT2(I_diaeresis);", "      EMITMBC(0x128) EMITMBC(0x12a)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x147) CASEMBC(0x1e44) CASEMBC(0x1e48)", "      EMIT2('N'); EMIT2(N_virguilla);", "      EMITMBC(0x143) EMITMBC(0x145)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x1ec) CASEMBC(0x1ece)", "      EMIT2('O'); EMIT2(O_grave); EMIT2(O_acute);", "      EMIT2(O_circumflex); EMIT2(O_virguilla);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2('O'); EMIT2(O_grave); EMIT2(O_acute);", "      EMIT2(O_circumflex); EMIT2(O_virguilla);", "      EMIT2(O_diaeresis); EMIT2(O_slash);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2(O_circumflex); EMIT2(O_virguilla);", "      EMIT2(O_diaeresis); EMIT2(O_slash);", "      EMITMBC(0x14c) EMITMBC(0x14e) EMITMBC(0x150)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x1ee6)", "      EMIT2('U'); EMIT2(U_grave); EMIT2(U_acute);", "      EMIT2(U_diaeresis); EMIT2(U_circumflex);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2('U'); EMIT2(U_grave); EMIT2(U_acute);", "      EMIT2(U_diaeresis); EMIT2(U_circumflex);", "      EMITMBC(0x168) EMITMBC(0x16a)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x1ef8)", "      EMIT2('Y'); EMIT2(Y_acute);", "      EMITMBC(0x176) EMITMBC(0x178)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x1ea3)", "      EMIT2('a'); EMIT2(a_grave); EMIT2(a_acute);", "      EMIT2(a_circumflex); EMIT2(a_virguilla);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2('a'); EMIT2(a_grave); EMIT2(a_acute);", "      EMIT2(a_circumflex); EMIT2(a_virguilla);", "      EMIT2(a_diaeresis); EMIT2(a_ring);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2(a_circumflex); EMIT2(a_virguilla);", "      EMIT2(a_diaeresis); EMIT2(a_ring);", "      EMITMBC(0x101) EMITMBC(0x103) EMITMBC(0x105)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x10b) CASEMBC(0x10d)", "      EMIT2('c'); EMIT2(c_cedilla);", "      EMITMBC(0x107) EMITMBC(0x109)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x1ebb) CASEMBC(0x1ebd)", "      EMIT2('e'); EMIT2(e_grave); EMIT2(e_acute);", "      EMIT2(e_circumflex); EMIT2(e_diaeresis);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2('e'); EMIT2(e_grave); EMIT2(e_acute);", "      EMIT2(e_circumflex); EMIT2(e_diaeresis);", "      EMITMBC(0x113) EMITMBC(0x115)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x1ec9)", "      EMIT2('i'); EMIT2(i_grave); EMIT2(i_acute);", "      EMIT2(i_circumflex); EMIT2(i_diaeresis);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2('i'); EMIT2(i_grave); EMIT2(i_acute);", "      EMIT2(i_circumflex); EMIT2(i_diaeresis);", "      EMITMBC(0x129) EMITMBC(0x12b)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x1e49)", "      EMIT2('n'); EMIT2(n_virguilla);", "      EMITMBC(0x144) EMITMBC(0x146)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x1ed) CASEMBC(0x1ecf)", "      EMIT2('o'); EMIT2(o_grave); EMIT2(o_acute);", "      EMIT2(o_circumflex); EMIT2(o_virguilla);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2('o'); EMIT2(o_grave); EMIT2(o_acute);", "      EMIT2(o_circumflex); EMIT2(o_virguilla);", "      EMIT2(o_diaeresis); EMIT2(o_slash);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2(o_circumflex); EMIT2(o_virguilla);", "      EMIT2(o_diaeresis); EMIT2(o_slash);", "      EMITMBC(0x14d) EMITMBC(0x14f) EMITMBC(0x151)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x1ee7)", "      EMIT2('u'); EMIT2(u_grave); EMIT2(u_acute);", "      EMIT2(u_circumflex); EMIT2(u_diaeresis);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2('u'); EMIT2(u_grave); EMIT2(u_acute);", "      EMIT2(u_circumflex); EMIT2(u_diaeresis);", "      EMITMBC(0x169) EMITMBC(0x16b)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["              CASEMBC(0x1ef7) CASEMBC(0x1ef9)", "      EMIT2('y'); EMIT2(y_acute); EMIT2(y_diaeresis);", "      EMITMBC(0x177)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["", "      /* default: character itself */", "    }"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Code to parse regular expression."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Parse the lowest level."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    c = no_Magic(getchr());", "    if (c == NUL)", "      EMSG_RET_FAIL(_(e_nul_found));"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "    if (c == '^') {             /* \"\\_^\" is start-of-line */", "      EMIT(NFA_BOL);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    }", "    if (c == '$') {             /* \"\\_$\" is end-of-line */", "      EMIT(NFA_EOL);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "    /* \"\\_[\" is collection plus newline */", "    if (c == '[')"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    /* \"\\_[\" is collection plus newline */", "    if (c == '[')", "      goto collection;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "  /*", "   * Character classes."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      EMIT(PTR2CHAR(lp));", "      if (lp != reg_prev_sub)", "        EMIT(NFA_CONCAT);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    switch (c) {", "    /* () without a back reference */", "    case '(':"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    case '(':", "      if (nfa_reg(REG_NPAREN) == FAIL)", "        return FAIL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "    case 'd':               /* %d123 decimal */", "    case 'o':               /* %o123 octal */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    case 'd':               /* %d123 decimal */", "    case 'o':               /* %o123 octal */", "    case 'x':               /* %xab hex 2 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    case 'o':               /* %o123 octal */", "    case 'x':               /* %xab hex 2 */", "    case 'u':               /* %uabcd hex 4 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    case 'x':               /* %xab hex 2 */", "    case 'u':               /* %uabcd hex 4 */", "    case 'U':               /* %U1234abcd hex 8 */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    case 'u':               /* %uabcd hex 4 */", "    case 'U':               /* %U1234abcd hex 8 */", "    {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "    /* Catch \\%^ and \\%$ regardless of where they appear in the", "     * pattern -- regardless of whether or not it makes sense. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "      /* \\%[abc] */", "      for (n = 0; (c = peekchr()) != ']'; ++n) {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      /* \\%[abc] */", "      for (n = 0; (c = peekchr()) != ']'; ++n) {", "        if (c == NUL)"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["      for (n = 0; (c = peekchr()) != ']'; ++n) {", "        if (c == NUL)", "          EMSG2_RET_FAIL(_(e_missing_sb),"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["          EMSG2_RET_FAIL(_(e_missing_sb),", "              reg_magic == MAGIC_ALL);", "        /* recursive call! */"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["              reg_magic == MAGIC_ALL);", "        /* recursive call! */", "        if (nfa_regatom() == FAIL)"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        /* recursive call! */", "        if (nfa_regatom() == FAIL)", "          return FAIL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      }", "      getchr();                    /* get the ] */", "      if (n == 0)"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      getchr();                    /* get the ] */", "      if (n == 0)", "        EMSG2_RET_FAIL(_(e_empty_sb),"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["        EMSG2_RET_FAIL(_(e_empty_sb),", "            reg_magic == MAGIC_ALL);", "      EMIT(NFA_OPT_CHARS);"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["", "      /* Emit as \"\\%(\\%[abc]\\)\" to be able to handle", "       * \"\\%[abc]*\" which would cause the empty string to be"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "      if (c == '<' || c == '>')", "        c = getchr();"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      } else if (c == '\\'' && n == 0) {", "        /* \\%'m  \\%<'m  \\%>'m  */", "        EMIT(cmp == '<' ? NFA_MARK_LT :"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        EMIT(cmp == '<' ? NFA_MARK_LT :", "            cmp == '>' ? NFA_MARK_GT : NFA_MARK);", "        EMIT(getchr());"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["collection:", "    /*", "     * [abc]  uses NFA_START_COLL - NFA_END_COLL"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    if (*endp == ']') {", "      /*", "       * Try to reverse engineer character classes. For example,"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["          EMIT(NFA_OR);", "        } else", "          EMIT(result);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      }", "      /*", "       * Failed to recognize a character class. Use the simple"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        EMIT(NFA_START_NEG_COLL);", "      } else", "        EMIT(NFA_START_COLL);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["        if (*regparse == '[') {", "          /* Check for [: :], [= =], [. .] */", "          equiclass = collclass = 0;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["            equiclass = get_equi_class(&regparse);", "            if (equiclass == 0)", "              collclass = get_coll_element(&regparse);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "          /* Character class like [:alpha:]  */", "          if (charclass != CLASS_NONE) {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["          }", "          /* Try equivalence class [=a=] and the like */", "          if (equiclass != 0) {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["          }", "          /* Try collating class like [. .]  */", "          if (collclass != 0) {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["          if (collclass != 0) {", "            startc = collclass;                  /* allow [.a.]-x as a range */", "            /* Will emit the proper atom at the end of the"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["            startc = collclass;                  /* allow [.a.]-x as a range */", "            /* Will emit the proper atom at the end of the", "             * while loop. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        }", "        /* Try a range like 'a-x' or '\\t-z'. Also allows '-' as a", "         * start character. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "        /* Now handle simple and escaped characters.", "         * Only \"\\]\", \"\\^\", \"\\]\" and \"\\\\\" are special in Vi.  Vim"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["          } else {", "            /* \\r,\\t,\\e,\\b */", "            startc = backslash_trans(*regparse);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "        /* Normal printable char */", "        if (startc == -1)"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        /* Normal printable char */", "        if (startc == -1)", "          startc = PTR2CHAR(regparse);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "        /* Previous char was '-', so this char is end of range. */", "        if (emit_range) {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["          if (endc > startc + 2) {", "            /* Emit a range instead of the sequence of", "             * individual characters. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["             * individual characters. */", "            if (startc == 0)", "              /* \\x00 is translated to \\x0a, start at \\x01. */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["            if (startc == 0)", "              /* \\x00 is translated to \\x0a, start at \\x01. */", "              EMIT(1);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["              EMIT(1);", "            else", "              --post_ptr;                   /* remove NFA_CONCAT */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["            else", "              --post_ptr;                   /* remove NFA_CONCAT */", "            EMIT(endc);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["            else", "              --post_ptr;                   /* remove NFA_CONCAT */", "            EMIT(endc);"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["          } else {", "            /* Emit the range. \"startc\" was already emitted, so", "             * skip it. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        } else {", "          /* This char (startc) is not part of a range. Just", "           * emit it."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["          if (startc == NFA_NEWL) {", "            /* Line break can't be matched as part of the", "             * collection, add an OR below. But not for negated"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["             * range. */", "            if (!negated)", "              extra = NFA_ADD_NL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "      /* skip the trailing ] */", "      regparse = endp;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      return OK;", "    }         /* if exists closing ] */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "    if (reg_strict)", "      EMSG_RET_FAIL(_(e_missingbracket));"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "      /* A base character plus composing characters, or just one", "       * or more composing characters."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        EMIT(c);", "        if (i > 0)", "          EMIT(NFA_CONCAT);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["          EMIT(NFA_CONCAT);", "        if ((i += utf_char2len(c)) >= plen)", "          break;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  return OK;", "}", ""], "readability/fn_size"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Parse something followed by possible [*+=]."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* Save the current parse state, so that we can use it if <atom>{m,n} is", "   * next. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* store current pos in the postfix form, for \\{m,n} involving 0s */", "  my_post_start = (int)(post_ptr - post_start);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  ret = nfa_regatom();", "  if (ret == FAIL)", "    return FAIL;            /* cascaded error */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  if (ret == FAIL)", "    return FAIL;            /* cascaded error */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  op = peekchr();", "  if (re_multi_type(op) == NOT_MULTI)", "    return OK;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  case Magic('+'):", "    /*", "     * Trick: Normally, (a*)\\+ would match the whole input \"aaa\".  The"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    curchr = -1;", "    if (nfa_regatom() == FAIL)", "      return FAIL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    EMIT(NFA_CONCAT);", "    skipchr();                  /* skip the \\+\t*/", "    break;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    EMIT(NFA_CONCAT);", "    skipchr();                  /* skip the \\+\t*/", "    break;"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["    i = 0;", "    switch(op) {", "    case '=':"], "whitespace/parens"]
["src/nvim/regexp_nfa.c", ["    case '=':", "      /* \\@= */", "      i = NFA_PREV_ATOM_NO_WIDTH;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    case '!':", "      /* \\@! */", "      i = NFA_PREV_ATOM_NO_WIDTH_NEG;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      op = no_Magic(getchr());", "      if (op == '=')", "        /* \\@<= */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      if (op == '=')", "        /* \\@<= */", "        i = NFA_PREV_ATOM_JUST_BEFORE;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        i = NFA_PREV_ATOM_JUST_BEFORE;", "      else if (op == '!')", "        /* \\@<! */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      else if (op == '!')", "        /* \\@<! */", "        i = NFA_PREV_ATOM_JUST_BEFORE_NEG;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    case '>':", "      /* \\@>  */", "      i = NFA_PREV_ATOM_LIKE_PATTERN;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    EMIT(i);", "    if (i == NFA_PREV_ATOM_JUST_BEFORE", "        || i == NFA_PREV_ATOM_JUST_BEFORE_NEG)"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  case Magic('{'):", "    /* a{2,5} will expand to 'aaa?a?a?'", "     * a{-1,3} will expand to 'aa??a??', where ?? is the nongreedy"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    }", "    if (!read_limits(&minval, &maxval))", "      EMSG_RET_FAIL(_(\"E870: (NFA regexp) Error reading repetition limits\"));"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "    /*  <atom>{0,inf}, <atom>{0,} and <atom>{}  are equivalent to", "     *  <atom>*  */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    if (minval == 0 && maxval == MAX_LIMIT) {", "      if (greedy)", "        /* \\{}, \\{0,} */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      if (greedy)", "        /* \\{}, \\{0,} */", "        EMIT(NFA_STAR);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        EMIT(NFA_STAR);", "      else", "        /* \\{-}, \\{-0,} */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      else", "        /* \\{-}, \\{-0,} */", "        EMIT(NFA_STAR_NONGREEDY);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "    /* Special case: x{0} or x{-0} */", "    if (maxval == 0) {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    if (maxval == 0) {", "      /* Ignore result of previous call to nfa_regatom() */", "      post_ptr = post_start + my_post_start;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      post_ptr = post_start + my_post_start;", "      /* NFA_EMPTY is 0-length and works everywhere */", "      EMIT(NFA_EMPTY);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "    /* Ignore previous call to nfa_regatom() */", "    post_ptr = post_start + my_post_start;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    post_ptr = post_start + my_post_start;", "    /* Save parse state after the repeated atom and the \\{} */", "    save_parse_state(&new_state);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    for (i = 0; i < maxval; i++) {", "      /* Goto beginning of the repeated atom */", "      restore_parse_state(&old_state);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      old_post_pos = (int)(post_ptr - post_start);", "      if (nfa_regatom() == FAIL)", "        return FAIL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["        return FAIL;", "      /* after \"minval\" times, atoms are optional */", "      if (i + 1 > minval) {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        if (maxval == MAX_LIMIT) {", "          if (greedy)", "            EMIT(NFA_STAR);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["            EMIT(NFA_STAR);", "          else", "            EMIT(NFA_STAR_NONGREEDY);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["            EMIT(NFA_STAR_NONGREEDY);", "        } else", "          EMIT(quest);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      }", "      if (old_post_pos != my_post_start)", "        EMIT(NFA_CONCAT);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["        EMIT(NFA_CONCAT);", "      if (i + 1 > minval && maxval == MAX_LIMIT)", "        break;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "    /* Go to just after the repeated atom and the \\{} */", "    restore_parse_state(&new_state);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    break;", "  }     /* end switch */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Parse one or more pieces, concatenated.  It matches a match for the"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Parse a branch, one or more concats, separated by \"\\&\".  It matches the"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* First branch, possibly the only one */", "  if (nfa_regconcat() == FAIL)"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  /* First branch, possibly the only one */", "  if (nfa_regconcat() == FAIL)", "    return FAIL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    old_post_pos = (int)(post_ptr - post_start);", "    if (nfa_regconcat() == FAIL)", "      return FAIL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      return FAIL;", "    /* if concat is empty do emit a node */", "    if (old_post_pos == (int)(post_ptr - post_start))"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    /* if concat is empty do emit a node */", "    if (old_post_pos == (int)(post_ptr - post_start))", "      EMIT(NFA_EMPTY);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "  /* if a branch is empty, emit one node for it */", "  if (old_post_pos == (int)(post_ptr - post_start))"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  /* if a branch is empty, emit one node for it */", "  if (old_post_pos == (int)(post_ptr - post_start))", "    EMIT(NFA_EMPTY);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "/*", " *  Parse a pattern, one or more branches, separated by \"\\|\".  It matches"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", [" */", "static int ", "nfa_reg ("], "whitespace/end_of_line"]
["src/nvim/regexp_nfa.c", ["static int ", "nfa_reg (", "    int paren              /* REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN */"], "whitespace/parens"]
["src/nvim/regexp_nfa.c", ["nfa_reg (", "    int paren              /* REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN */", ")"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["nfa_reg (", "    int paren              /* REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN */", ")"], "whitespace/line_length"]
["src/nvim/regexp_nfa.c", ["  if (paren == REG_PAREN) {", "    if (regnpar >= NSUBEXP)     /* Too many `(' */", "      EMSG_RET_FAIL(_(\"E872: (NFA regexp) Too many '('\"));"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  if (paren == REG_PAREN) {", "    if (regnpar >= NSUBEXP)     /* Too many `(' */", "      EMSG_RET_FAIL(_(\"E872: (NFA regexp) Too many '('\"));"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  } else if (paren == REG_ZPAREN) {", "    /* Make a ZOPEN node. */", "    if (regnzpar >= NSUBEXP)"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    /* Make a ZOPEN node. */", "    if (regnzpar >= NSUBEXP)", "      EMSG_RET_FAIL(_(\"E879: (NFA regexp) Too many \\\\z(\"));"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "  if (nfa_regbranch() == FAIL)", "    return FAIL;            /* cascaded error */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  if (nfa_regbranch() == FAIL)", "    return FAIL;            /* cascaded error */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    skipchr();", "    if (nfa_regbranch() == FAIL)", "      return FAIL;          /* cascaded error */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    if (nfa_regbranch() == FAIL)", "      return FAIL;          /* cascaded error */", "    EMIT(NFA_OR);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* Check for proper termination. */", "  if (paren != REG_NOPAREN && getchr() != Magic(')')) {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  if (paren != REG_NOPAREN && getchr() != Magic(')')) {", "    if (paren == REG_NPAREN)", "      EMSG2_RET_FAIL(_(e_unmatchedpp), reg_magic == MAGIC_ALL);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      EMSG2_RET_FAIL(_(e_unmatchedpp), reg_magic == MAGIC_ALL);", "    else", "      EMSG2_RET_FAIL(_(e_unmatchedp), reg_magic == MAGIC_ALL);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  } else if (paren == REG_NOPAREN && peekchr() != NUL) {", "    if (peekchr() == Magic(')'))", "      EMSG2_RET_FAIL(_(e_unmatchedpar), reg_magic == MAGIC_ALL);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      EMSG2_RET_FAIL(_(e_unmatchedpar), reg_magic == MAGIC_ALL);", "    else", "      EMSG_RET_FAIL(_(\"E873: (NFA regexp) proper termination error\"));"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  case NFA_PREV_ATOM_NO_WIDTH:", "    STRCPY(code, \"NFA_PREV_ATOM_NO_WIDTH\"); break;", "  case NFA_PREV_ATOM_NO_WIDTH_NEG:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_PREV_ATOM_NO_WIDTH_NEG:", "    STRCPY(code, \"NFA_PREV_ATOM_NO_WIDTH_NEG\"); break;", "  case NFA_PREV_ATOM_JUST_BEFORE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_PREV_ATOM_JUST_BEFORE:", "    STRCPY(code, \"NFA_PREV_ATOM_JUST_BEFORE\"); break;", "  case NFA_PREV_ATOM_JUST_BEFORE_NEG:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_PREV_ATOM_JUST_BEFORE_NEG:", "    STRCPY(code, \"NFA_PREV_ATOM_JUST_BEFORE_NEG\"); break;", "  case NFA_PREV_ATOM_LIKE_PATTERN:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_PREV_ATOM_LIKE_PATTERN:", "    STRCPY(code, \"NFA_PREV_ATOM_LIKE_PATTERN\"); break;", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_FIRST:", "    STRCPY(code, \"NFA_START_INVISIBLE_FIRST\"); break;", "  case NFA_START_INVISIBLE_NEG:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_NEG:", "    STRCPY(code, \"NFA_START_INVISIBLE_NEG\"); break;", "  case NFA_START_INVISIBLE_NEG_FIRST:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_NEG_FIRST:", "    STRCPY(code, \"NFA_START_INVISIBLE_NEG_FIRST\"); break;", "  case NFA_START_INVISIBLE_BEFORE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_BEFORE:", "    STRCPY(code, \"NFA_START_INVISIBLE_BEFORE\"); break;", "  case NFA_START_INVISIBLE_BEFORE_FIRST:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_BEFORE_FIRST:", "    STRCPY(code, \"NFA_START_INVISIBLE_BEFORE_FIRST\"); break;", "  case NFA_START_INVISIBLE_BEFORE_NEG:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_BEFORE_NEG:", "    STRCPY(code, \"NFA_START_INVISIBLE_BEFORE_NEG\"); break;", "  case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:", "    STRCPY(code, \"NFA_START_INVISIBLE_BEFORE_NEG_FIRST\"); break;", "  case NFA_START_PATTERN:   STRCPY(code, \"NFA_START_PATTERN\"); break;"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Print the postfix notation of the current regexp."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    fprintf(f, \"\\\"\\nPostfix notation (int): \");", "    for (p = post_start; *p && p < post_ptr; p++)", "      fprintf(f, \"%d \", *p);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Print the NFA starting with a root node \"state\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  if (state == NULL)", "    return;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "  /* Output indent */", "  p = (char_u *)indent->ga_data;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "    STRNCPY(save, &p[last], 2);", "    STRNCPY(&p[last], \"+-\", 2);"], "runtime/printf"]
["src/nvim/regexp_nfa.c", ["    STRNCPY(save, &p[last], 2);", "    STRNCPY(&p[last], \"+-\", 2);", "    fprintf(debugf, \" %s\", p);"], "runtime/printf"]
["src/nvim/regexp_nfa.c", ["    fprintf(debugf, \" %s\", p);", "    STRNCPY(&p[last], save, 2);", "  } else"], "runtime/printf"]
["src/nvim/regexp_nfa.c", ["    STRNCPY(&p[last], save, 2);", "  } else", "    fprintf(debugf, \" %s\", p);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  fprintf(debugf, \"%s (%d) (id=%d) val=%d\\n\",", "      code,", "      state->c,"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["      code,", "      state->c,", "      abs(state->id),"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["      state->c,", "      abs(state->id),", "      state->val);"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["      abs(state->id),", "      state->val);", "  if (state->id < 0)"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["      state->val);", "  if (state->id < 0)", "    return;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "  /* grow indent for state->out */", "  indent->ga_len -= 1;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  indent->ga_len -= 1;", "  if (state->out1)", "    ga_concat(indent, (char_u *)\"| \");"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    ga_concat(indent, (char_u *)\"| \");", "  else", "    ga_concat(indent, (char_u *)\"  \");"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "  /* replace last part of indent for state->out1 */", "  indent->ga_len -= 3;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* shrink indent */", "  indent->ga_len -= 3;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Print the NFA state machine."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "    if (prog->reganch)", "      fprintf(debugf, \"reganch: %d\\n\", prog->reganch);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      fprintf(debugf, \"reganch: %d\\n\", prog->reganch);", "    if (prog->regstart != NUL)", "      fprintf(debugf, \"regstart: %c (decimal: %d)\\n\","], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      fprintf(debugf, \"regstart: %c (decimal: %d)\\n\",", "          prog->regstart, prog->regstart);", "    if (prog->match_text != NULL)"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          prog->regstart, prog->regstart);", "    if (prog->match_text != NULL)", "      fprintf(debugf, \"match_text: \\\"%s\\\"\\n\", prog->match_text);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["}", "#endif      /* REGEXP_DEBUG */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Parse r.e. @expr and convert it into postfix form."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["{", "  if (nfa_reg(REG_NOPAREN) == FAIL)", "    return NULL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "/* NB. Some of the code below is inspired by Russ's. */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Represents an NFA state plus zero or one or two arrows exiting."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "static nfa_state_T      *state_ptr; /* points to nfa_prog->state */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Allocate and initialize nfa_state_T."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  if (istate >= nstate)", "    return NULL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "/*", " * A partially built NFA without the matching state filled in."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Initialize a Frag_T struct and return it."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Create singleton list containing just outp."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Patch the list of states at out to point to start."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Join the two lists l1 and l2, returning the combination."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  oldl1 = l1;", "  while (l1->next)", "    l1 = l1->next;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Stack used for transforming postfix form into NFA."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Push an item onto the stack."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  if (stackp >= stack_end)", "    return;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Pop an item from the stack."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  stackp = *p;", "  if (stackp < stack)", "    return empty;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Estimate the maximum byte length of anything matching \"state\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* detect looping in a NFA_SPLIT */", "  if (depth > 4)"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  /* detect looping in a NFA_SPLIT */", "  if (depth > 4)", "    return -1;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    case NFA_END_INVISIBLE_NEG:", "      /* the end, return what we have */", "      return len;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    case NFA_SPLIT:", "      /* two alternatives, use the maximum */", "      l = nfa_max_width(state->out, depth + 1);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      r = nfa_max_width(state->out1, depth + 1);", "      if (l < 0 || r < 0)", "        return -1;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    case NFA_OCTAL:", "      /* ascii */", "      ++len;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      /* ascii */", "      ++len;", "      break;"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["    case NFA_START_INVISIBLE_BEFORE_NEG:", "      /* zero-width, out1 points to the END state */", "      state = state->out1->out;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    case NFA_SKIP:", "      /* unknown width */", "      return -1;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    case NFA_END_COMPOSING:", "      /* zero-width */", "      break;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    default:", "      if (state->c < 0)", "        /* don't know what this is */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      if (state->c < 0)", "        /* don't know what this is */", "        return -1;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        return -1;", "      /* normal character */", "      len += MB_CHAR2LEN(state->c);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "    /* normal way to continue */", "    state = state->out;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* unrecognized, \"cannot happen\" */", "  return -1;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Convert a postfix form into its equivalent NFA."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  if (postfix == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "  for (p = postfix; p < end; ++p) {", "    switch (*p) {"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["      s = alloc_state(NFA_SPLIT, e1.start, e2.start);", "      if (s == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      s = alloc_state(NFA_SPLIT, e.start, NULL);", "      if (s == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      s = alloc_state(NFA_SPLIT, NULL, e.start);", "      if (s == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      s = alloc_state(NFA_SPLIT, e.start, NULL);", "      if (s == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      s = alloc_state(NFA_SPLIT, NULL, e.start);", "      if (s == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    case NFA_END_NEG_COLL:", "      /* On the stack is the sequence starting with NFA_START_COLL or", "       * NFA_START_NEG_COLL and all possible characters. Patch it to"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      s = alloc_state(NFA_END_COLL, NULL, NULL);", "      if (s == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      s = alloc_state(NFA_EMPTY, NULL, NULL);", "      if (s == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      }", "      s = NULL;       /* avoid compiler warning */", "      e1.out = NULL;       /* stores list with out1's */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      s = NULL;       /* avoid compiler warning */", "      e1.out = NULL;       /* stores list with out1's */", "      s1 = NULL;       /* previous NFA_SPLIT to connect to */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      e1.out = NULL;       /* stores list with out1's */", "      s1 = NULL;       /* previous NFA_SPLIT to connect to */", "      while (n-- > 0) {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      while (n-- > 0) {", "        e = POP();         /* get character */", "        s = alloc_state(NFA_SPLIT, e.start, NULL);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        s = alloc_state(NFA_SPLIT, e.start, NULL);", "        if (s == NULL)", "          goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["          goto theend;", "        if (e1.out == NULL)", "          e1 = e;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["        break;", "      default:           /* NFA_PREV_ATOM_LIKE_PATTERN: */", "        start_state = NFA_START_PATTERN;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "      if (before)", "        n = *++p;         /* get the count */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      if (before)", "        n = *++p;         /* get the count */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "      /* The \\@= operator: match the preceding atom with zero width.", "       * The \\@! operator: no match for the preceding atom."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      s1 = alloc_state(end_state, NULL, NULL);", "      if (s1 == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      s = alloc_state(start_state, e.start, s1);", "      if (s == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      if (pattern) {", "        /* NFA_ZEND -> NFA_END_PATTERN -> NFA_SKIP -> what follows. */", "        skip = alloc_state(NFA_SKIP, NULL, NULL);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        if (before) {", "          if (n <= 0)", "            /* See if we can guess the maximum width, it avoids a"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["          if (n <= 0)", "            /* See if we can guess the maximum width, it avoids a", "             * lot of pointless tries. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["            n = nfa_max_width(e.start, 0);", "          s->val = n;           /* store the count */", "        }"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "    case NFA_MOPEN:     /* \\( \\) Submatch */", "    case NFA_MOPEN1:"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    case NFA_MOPEN9:", "    case NFA_ZOPEN:     /* \\z( \\) Submatch */", "    case NFA_ZOPEN1:"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      default:", "        /* NFA_MOPEN, NFA_MOPEN1 .. NFA_MOPEN9 */", "        mclose = *p + NSUBEXP;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "      /* Allow \"NFA_MOPEN\" as a valid postfix representation for", "       * the empty regexp \"\". In this case, the NFA will be"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        s = alloc_state(mopen, NULL, NULL);", "        if (s == NULL)", "          goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["        s1 = alloc_state(mclose, NULL, NULL);", "        if (s1 == NULL)", "          goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "      /* At least one node was emitted before NFA_MOPEN, so", "       * at least one node will be between NFA_MOPEN and NFA_MCLOSE */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      e = POP();", "      s = alloc_state(mopen, e.start, NULL);         /* `(' */", "      if (s == NULL)"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      s = alloc_state(mopen, e.start, NULL);         /* `(' */", "      if (s == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "      s1 = alloc_state(mclose, NULL, NULL);         /* `)' */", "      if (s1 == NULL)"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      s1 = alloc_state(mclose, NULL, NULL);         /* `)' */", "      if (s1 == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "      if (mopen == NFA_COMPOSING)", "        /* COMPOSING->out1 = END_COMPOSING */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      if (mopen == NFA_COMPOSING)", "        /* COMPOSING->out1 = END_COMPOSING */", "        patch(list1(&s->out1), s1);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      s = alloc_state(*p, NULL, NULL);", "      if (s == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      s1 = alloc_state(NFA_SKIP, NULL, NULL);", "      if (s1 == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    {", "      int n = *++p;       /* lnum, col or mark name */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      s = alloc_state(p[-1], NULL, NULL);", "      if (s == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      s = alloc_state(*p, NULL, NULL);", "      if (s == NULL)", "        goto theend;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      break;", "", "    }     /* switch(*p) */"], "whitespace/blank_line"]
["src/nvim/regexp_nfa.c", ["", "    }     /* switch(*p) */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    }     /* switch(*p) */", "", "  }   /* for(p = postfix; *p; ++p) */"], "whitespace/blank_line"]
["src/nvim/regexp_nfa.c", ["", "  }   /* for(p = postfix; *p; ++p) */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    nstate++;", "    goto theend;        /* Return value when counting size is ignored anyway */", "  }"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  matchstate = &state_ptr[istate++];   /* the match state */", "  matchstate->c = NFA_MATCH;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * After building the NFA program, inspect it to add optimization hints."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  for (i = 0; i < prog->nstate; ++i) {", "    c = prog->state[i].c;"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["", "        /* Postpone when the invisible match is expensive or has a", "         * lower chance of failing. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["            || c == NFA_START_INVISIBLE_BEFORE_NEG) {", "          /* \"before\" matches are very expensive when", "           * unbounded, always prefer what follows then,"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        } else {", "          /* normal invisible, first do the one with the", "           * highest failure chance */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      }", "      if (directly)", "        /* switch to the _FIRST state */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      if (directly)", "        /* switch to the _FIRST state */", "        ++prog->state[i].c;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        /* switch to the _FIRST state */", "        ++prog->state[i].c;", "    }"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["", "/****************************************************************", "* NFA execution code."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/* Values for done in nfa_pim_T. */", "#define NFA_PIM_UNUSED   0      /* pim not used */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["/* Values for done in nfa_pim_T. */", "#define NFA_PIM_UNUSED   0      /* pim not used */", "#define NFA_PIM_TODO     1      /* pim not done yet */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["#define NFA_PIM_UNUSED   0      /* pim not used */", "#define NFA_PIM_TODO     1      /* pim not done yet */", "#define NFA_PIM_MATCH    2      /* pim executed, matches */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["#define NFA_PIM_TODO     1      /* pim not done yet */", "#define NFA_PIM_MATCH    2      /* pim executed, matches */", "#define NFA_PIM_NOMATCH  3      /* pim executed, no match */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["#define NFA_PIM_MATCH    2      /* pim executed, matches */", "#define NFA_PIM_NOMATCH  3      /* pim executed, no match */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  for (j = 0; j < sub->in_use; j++)", "    if (REG_MULTI)"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  for (j = 0; j < sub->in_use; j++)", "    if (REG_MULTI)", "      fprintf(log_fd, \"*** group %d, start: c=%d, l=%d, end: c=%d, l=%d\\n\","], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      fprintf(log_fd, \"*** group %d, start: c=%d, l=%d, end: c=%d, l=%d\\n\",", "          j,", "          sub->list.multi[j].start_col,"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          j,", "          sub->list.multi[j].start_col,", "          (int)sub->list.multi[j].start_lnum,"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          sub->list.multi[j].start_col,", "          (int)sub->list.multi[j].start_lnum,", "          sub->list.multi[j].end_col,"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          (int)sub->list.multi[j].start_lnum,", "          sub->list.multi[j].end_col,", "          (int)sub->list.multi[j].end_lnum);"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          sub->list.multi[j].end_col,", "          (int)sub->list.multi[j].end_lnum);", "    else {"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          (int)sub->list.multi[j].end_lnum);", "    else {", "      char *s = (char *)sub->list.line[j].start;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["          (int)sub->list.multi[j].end_lnum);", "    else {", "      char *s = (char *)sub->list.line[j].start;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      fprintf(log_fd, \"*** group %d, start: \\\"%s\\\", end: \\\"%s\\\"\\n\",", "          j,", "          s == NULL ? \"NULL\" : s,"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          j,", "          s == NULL ? \"NULL\" : s,", "          e == NULL ? \"NULL\" : e);"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          s == NULL ? \"NULL\" : s,", "          e == NULL ? \"NULL\" : e);", "    }"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Copy the submatches from \"from\" to \"to\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  if (from->in_use > 0) {", "    /* Copy the match start and end positions. */", "    if (REG_MULTI)"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    /* Copy the match start and end positions. */", "    if (REG_MULTI)", "      memmove(&to->list.multi[0],"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      memmove(&to->list.multi[0],", "          &from->list.multi[0],", "          sizeof(struct multipos) * from->in_use);"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          &from->list.multi[0],", "          sizeof(struct multipos) * from->in_use);", "    else"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          sizeof(struct multipos) * from->in_use);", "    else", "      memmove(&to->list.line[0],"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      memmove(&to->list.line[0],", "          &from->list.line[0],", "          sizeof(struct linepos) * from->in_use);"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          &from->list.line[0],", "          sizeof(struct linepos) * from->in_use);", "  }"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Like copy_sub() but exclude the main match."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["{", "  if (to->in_use < from->in_use)", "    to->in_use = from->in_use;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  if (from->in_use > 1) {", "    /* Copy the match start and end positions. */", "    if (REG_MULTI)"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    /* Copy the match start and end positions. */", "    if (REG_MULTI)", "      memmove(&to->list.multi[1],"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      memmove(&to->list.multi[1],", "          &from->list.multi[1],", "          sizeof(struct multipos) * (from->in_use - 1));"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          &from->list.multi[1],", "          sizeof(struct multipos) * (from->in_use - 1));", "    else"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          sizeof(struct multipos) * (from->in_use - 1));", "    else", "      memmove(&to->list.line[1],"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      memmove(&to->list.line[1],", "          &from->list.line[1],", "          sizeof(struct linepos) * (from->in_use - 1));"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          &from->list.line[1],", "          sizeof(struct linepos) * (from->in_use - 1));", "  }"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Like copy_sub() but only do the end of the main match if \\ze is present."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    if (REG_MULTI) {", "      if (from->list.multi[0].end_lnum >= 0){", "        to->list.multi[0].end_lnum = from->list.multi[0].end_lnum;"], "whitespace/braces"]
["src/nvim/regexp_nfa.c", ["    } else {", "      if (from->list.line[0].end != NULL)", "        to->list.line[0].end = from->list.line[0].end;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    int lid,", "    nfa_pim_T *pim) {", "  int col;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["static void report_state(char *action,", "    regsub_T *sub,", "    nfa_state_T *state,"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["    regsub_T *sub,", "    nfa_state_T *state,", "    int lid,"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["    nfa_state_T *state,", "    int lid,", "    nfa_pim_T *pim) {"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["    int lid,", "    nfa_pim_T *pim) {", "  int col;"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["    case NFA_COMPOSING:", "      /* skip ahead to next state */", "      state = state->out1->out;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  case NFA_EMPTY:", "    /* These nodes are not added themselves but their \"out\" and/or", "     * \"out1\" may be added below.  */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  case NFA_ZSTART:", "  /* These nodes need to be added so that we can bail out when it", "   * was added to this list before at the same position to avoid an"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    if (state->lastlist[nfa_ll_index] == l->id && state->c != NFA_SKIP) {", "      /* This state is already in the list, don't add it again,", "       * unless it is an MOPEN that is used for a backreference or"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["          && state->c != NFA_MATCH) {", "", "        /* When called from addstate_here() do insert before"], "whitespace/blank_line"]
["src/nvim/regexp_nfa.c", ["", "        /* When called from addstate_here() do insert before", "         * existing states. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        if (add_here) {", "          for (k = 0; k < l->n && k < listindex; ++k) {", "            if (l->t[k].state->id == state->id) {"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["          nfa_set_code(state->c);", "          fprintf(log_fd, \"> Not adding state %d to list %d. char %d: %s pim: %s has_pim: %d found: %d\\n\",", "                  abs(state->id), l->id, state->c, code,"], "whitespace/line_length"]
["src/nvim/regexp_nfa.c", ["", "      /* Do not add the state again when it exists with the same", "       * positions. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["       * positions. */", "      if (has_state_with_pos(l, state, subs, pim))", "        goto skip_add;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "    /* add the state to the list */", "    state->lastlist[nfa_ll_index] = l->id;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    thread->state = state;", "    if (pim == NULL)", "      thread->pim.result = NFA_PIM_UNUSED;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      thread->pim.result = NFA_PIM_UNUSED;", "    else {", "      copy_pim(&thread->pim, pim);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      thread->pim.result = NFA_PIM_UNUSED;", "    else {", "      copy_pim(&thread->pim, pim);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["#ifdef REGEXP_DEBUG", "  if (!did_print)", "    report_state(\"Processing\", &subs->norm, state, l->id, pim);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  case NFA_SPLIT:", "    /* order matters here */", "    subs = addstate(l, state->out, subs, pim, off_arg);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "    /* avoid compiler warnings */", "    save_ptr = NULL;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "    /* Set the position (with \"off\" added) in the subexpression.  Save", "     * and restore it when it was in use.  Otherwise fill any gap. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        save_in_use = sub->in_use;", "        for (i = sub->in_use; i < subidx; ++i) {", "          sub->list.multi[i].start_lnum = -1;"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["        save_in_use = sub->in_use;", "        for (i = sub->in_use; i < subidx; ++i) {", "          sub->list.line[i].start = NULL;"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["      }", "      else", "        sub->list.line[subidx].start = save_ptr;"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["        sub->list.line[subidx].start = save_ptr;", "    } else", "      sub->in_use = save_in_use;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "    /* We don't fill in gaps here, there must have been an MOPEN that", "     * has done that. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    save_in_use = sub->in_use;", "    if (sub->in_use <= subidx)", "      sub->in_use = subidx + 1;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      }", "      /* avoid compiler warnings */", "      save_ptr = NULL;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    }", "    else", "      sub->list.line[subidx].end = save_ptr;"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Like addstate(), but the new state(s) are put at position \"*ip\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* First add the state(s) at the end, so that we know how many there are.", "   * Pass the listidx as offset (avoids adding another argument to"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    if (l->n + count - 1 >= l->len) {", "      /* not enough space to move the new states, reallocate the list", "       * and move the states to the right position */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      memmove(&(newl[0]),", "          &(l->t[0]),", "          sizeof(nfa_thread_T) * listidx);"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          &(l->t[0]),", "          sizeof(nfa_thread_T) * listidx);", "      memmove(&(newl[listidx]),"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["      memmove(&(newl[listidx]),", "          &(l->t[l->n - count]),", "          sizeof(nfa_thread_T) * count);"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          &(l->t[l->n - count]),", "          sizeof(nfa_thread_T) * count);", "      memmove(&(newl[listidx + count]),"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["      memmove(&(newl[listidx + count]),", "          &(l->t[listidx + 1]),", "          sizeof(nfa_thread_T) * (l->n - count - listidx - 1));"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          &(l->t[listidx + 1]),", "          sizeof(nfa_thread_T) * (l->n - count - listidx - 1));", "      xfree(l->t);"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["    } else {", "      /* make space for new states, then move them from the", "       * end to the current position */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      memmove(&(l->t[listidx + count]),", "          &(l->t[listidx + 1]),", "          sizeof(nfa_thread_T) * (l->n - listidx - 1));"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          &(l->t[listidx + 1]),", "          sizeof(nfa_thread_T) * (l->n - listidx - 1));", "      memmove(&(l->t[listidx]),"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["      memmove(&(l->t[listidx]),", "          &(l->t[l->n - 1]),", "          sizeof(nfa_thread_T) * count);"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["          &(l->t[l->n - 1]),", "          sizeof(nfa_thread_T) * count);", "    }"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["  }", "  --l->n;", "  *ip = listidx - 1;"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Check character class \"class\" against current character c."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_BLANK:", "    if (c == ' ' || c == '\\t')", "      return OK;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_DIGIT:", "    if (ascii_isdigit(c))", "      return OK;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_PRINT:", "    if (vim_isprintc(c))", "      return OK;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_SPACE:", "    if ((c >= 9 && c <= 13) || (c == ' '))", "      return OK;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_XDIGIT:", "    if (ascii_isxdigit(c))", "      return OK;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_TAB:", "    if (c == '\\t')", "      return OK;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_RETURN:", "    if (c == '\\r')", "      return OK;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_BACKSPACE:", "    if (c == '\\b')", "      return OK;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Check for a match with subexpression \"subidx\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", [" */", "static int ", "match_backref ("], "whitespace/end_of_line"]
["src/nvim/regexp_nfa.c", ["static int ", "match_backref (", "    regsub_T *sub,           /* pointers to subexpressions */"], "whitespace/parens"]
["src/nvim/regexp_nfa.c", ["match_backref (", "    regsub_T *sub,           /* pointers to subexpressions */", "    int subidx,"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    int subidx,", "    int *bytelen       /* out: length of match in bytes */", ")"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["retempty:", "    /* backref was not set, match an empty string */", "    *bytelen = 0;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  if (REG_MULTI) {", "    if (sub->list.multi[subidx].start_lnum < 0", "        || sub->list.multi[subidx].end_lnum < 0)"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  } else {", "    if (sub->list.line[subidx].start == NULL", "        || sub->list.line[subidx].end == NULL)"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Check for a match with \\z subexpression \"subidx\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", [" */", "static int ", "match_zref ("], "whitespace/end_of_line"]
["src/nvim/regexp_nfa.c", ["static int ", "match_zref (", "    int subidx,"], "whitespace/parens"]
["src/nvim/regexp_nfa.c", ["    int subidx,", "    int *bytelen       /* out: length of match in bytes */", ")"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  if (re_extmatch_in == NULL || re_extmatch_in->matches[subidx] == NULL) {", "    /* backref was not set, match an empty string */", "    *bytelen = 0;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Save list IDs for all NFA states of \"prog\" into \"list\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* Order in the list is reverse, it's a bit faster that way. */", "  p = &prog->state[0];"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    p->lastlist[1] = 0;", "    ++p;", "  }"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Restore list IDs from \"list\" to all NFA states."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    p->lastlist[1] = list[i];", "    ++p;", "  }"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["{", "  if (op == 1) return pos > val;", "  if (op == 2) return pos < val;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  if (op == 1) return pos > val;", "  if (op == 2) return pos < val;", "  return val == pos;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Recursively call nfa_regmatch()"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["#ifdef REGEXP_DEBUG", "  if (log_fd != stderr)", "    fclose(log_fd);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Estimate the chance of a match with \"state\" failing."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* detect looping */", "  if (depth > 4)"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  /* detect looping */", "  if (depth > 4)", "    return 1;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  case NFA_SPLIT:", "    if (state->out->c == NFA_SPLIT || state->out1->c == NFA_SPLIT)", "      /* avoid recursive stuff */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    if (state->out->c == NFA_SPLIT || state->out1->c == NFA_SPLIT)", "      /* avoid recursive stuff */", "      return 1;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      return 1;", "    /* two alternatives, use the lowest failure chance */", "    l = failure_chance(state->out, depth + 1);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  case NFA_ANY:", "    /* matches anything, unlikely to fail */", "    return 1;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  case NFA_ANY_COMPOSING:", "    /* empty match works always */", "    return 0;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_PATTERN:", "    /* recursive regmatch is expensive, use low failure chance */", "    return 5;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  case NFA_ZREF9:", "    /* backreferences don't match in many places */", "    return 94;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  case NFA_VISUAL:", "    /* before/after positions don't match very often */", "    return 85;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  case NFA_MARK:", "    /* specific positions rarely match */", "    return 98;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  default:", "    if (c > 0)", "      /* character match fails often */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    if (c > 0)", "      /* character match fails often */", "      return 95;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* something else, includes character classes */", "  return 50;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Skip until the char \"c\" we know a match must start with."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Check for a match with match_text."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    fprintf(log_fd, \" RUNNING nfa_regmatch() starting with state %d, code %s\\n\",", "        abs(start->id), code);", "    fprintf(log_fd, \"**********************************\\n\");"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["", "  /*", "   * Run for each character."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "    /* swap lists */", "    thislist = &list[flag];"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "      for (i = 0; i < thislist->n; i++)", "        fprintf(log_fd, \"%d  \", abs(thislist->t[i].state->id));"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["#endif", "    /*", "     * If the state lists are empty we can stop."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["     */", "    if (thislist->n == 0)", "      break;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "      /*", "       * Handle the possible codes of the current state."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        fprintf(log_fd, \"Failure chance invisible: %d, what follows: %d\\n\",", "            failure_chance(t->state->out, 0),", "            failure_chance(t->state->out1->out, 0));"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["            failure_chance(t->state->out, 0),", "            failure_chance(t->state->out1->out, 0));", "#endif"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["        } else if (state_in_list(nextlist,", "                       t->state->out1->out->out, &t->subs)) {", "          skip = t->state->out1->out->out;"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["        } else if (state_in_list(thislist,", "                       t->state->out1->out->out, &t->subs)) {", "          skip = t->state->out1->out->out;"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["              log_fd,", "              \"> Not trying to match pattern, output state %d is already in list %d. char %d: %s\\n\",", "              abs(skip->id), skip_lid, skip->c, code);"], "whitespace/line_length"]
["src/nvim/regexp_nfa.c", ["            len += mb_char2len(mc);", "            if (ccount == MAX_MCO)", "              break;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["          while (sta->c != NFA_END_COMPOSING) {", "            for (j = 0; j < ccount; ++j)", "              if (cchars[j] == sta->c)"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["          while (sta->c != NFA_END_COMPOSING) {", "            for (j = 0; j < ccount; ++j)", "              if (cchars[j] == sta->c)"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["            for (j = 0; j < ccount; ++j)", "              if (cchars[j] == sta->c)", "                break;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["          }", "        } else", "          result = FAIL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["            fprintf(log_fd, \"NFA_RANGE_MIN curc=%d c1=%d c2=%d\\n\",", "                curc, c1, c2);", "#endif"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["", "        if (t->pim.result == NFA_PIM_UNUSED)", "          pim = NULL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["          pim = NULL;", "        else", "          pim = &t->pim;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["                log_fd,", "                \"Using previous recursive nfa_regmatch() result, result == %d\\n\",", "                pim->result);"], "whitespace/line_length"]
["src/nvim/regexp_nfa.c", ["              fprintf(log_fd,", "                  \"  Skipping start state, regstart does not match\\n\");", "#endif"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["", "      for (i = 0; i < thislist->n; i++)", "        fprintf(log_fd, \"%d  \", abs(thislist->t[i].state->id));"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["#ifdef REGEXP_DEBUG", "  if (log_fd != stderr)", "    fclose(log_fd);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  return nfa_match;", "}", ""], "readability/fn_size"]
["src/nvim/regexp_nfa.c", ["    fprintf(f,", "        \"\\n\\n\\t=======================================================\\n\");", "#ifdef REGEXP_DEBUG"], "whitespace/alignment"]
["src/nvim/regexp_nfa.c", ["", "  /* Package any found \\z(...\\) matches for export. Default is none. */", "  unref_extmatch(re_extmatch_out);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "        if (lpos->start != NULL && lpos->end != NULL)", "          re_extmatch_out->matches[i] ="], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "  /* Be paranoid... */", "  if (prog == NULL || line == NULL) {"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  if (prog->reganch && col > 0)", "    return 0L;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  if (prog->regstart != NUL) {", "    /* Skip ahead until a character we know the match must start with.", "     * When there is none there is no match. */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["     * When there is none there is no match. */", "    if (skip_to_start(prog->regstart, &col) == FAIL)", "      return 0L;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Compile a regular expression into internal code for the NFA matcher."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  if (expr == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "  /*", "   * In order to build the NFA, we parse the input regexp twice:"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /*", "   * PASS 1"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /* allocate the regprog with space for the compiled regexp */", "  size_t prog_size = sizeof(nfa_regprog_T) + sizeof(nfa_state_T) * (nstate - 1);"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /*", "   * PASS 2"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["#endif", "  /* Remember whether this pattern has any \\z specials in it. */", "  prog->reghasz = re_has_z;"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Free a compiled regexp program, returned by nfa_regcomp()."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Match a regexp against a string."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", [" */", "static int ", "nfa_regexec_nl ("], "whitespace/end_of_line"]
["src/nvim/regexp_nfa.c", ["static int ", "nfa_regexec_nl (", "    regmatch_T *rmp,"], "whitespace/parens"]
["src/nvim/regexp_nfa.c", ["    regmatch_T *rmp,", "    char_u *line,      /* string to match against */", "    colnr_T col,       /* column to start looking for match */"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    char_u *line,      /* string to match against */", "    colnr_T col,       /* column to start looking for match */", "    bool line_lbr"], "readability/old_style_comment"]
