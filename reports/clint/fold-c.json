["src/nvim/fold.c", ["", "/*", " * fold.c: code for folding"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* local declarations. {{{1 */", "/* typedef fold_T {{{2 */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* local declarations. {{{1 */", "/* typedef fold_T {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* typedef fold_T {{{2 */", "/*", " * The toplevel folds for each window are stored in the w_folds growarray."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "#define FD_OPEN         0       /* fold is open (nested ones can be closed) */", "#define FD_CLOSED       1       /* fold is closed */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["#define FD_OPEN         0       /* fold is open (nested ones can be closed) */", "#define FD_CLOSED       1       /* fold is closed */", "#define FD_LEVEL        2       /* depends on 'foldlevel' (nested folds too) */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["#define FD_CLOSED       1       /* fold is closed */", "#define FD_LEVEL        2       /* depends on 'foldlevel' (nested folds too) */", ""], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "#define MAX_LEVEL       20      /* maximum fold depth */", ""], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* Define \"fline_T\", passed to get fold level for a line. {{{2 */", "typedef struct {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["typedef struct {", "  win_T       *wp;              /* window */", "  linenr_T lnum;                /* current line number */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  win_T       *wp;              /* window */", "  linenr_T lnum;                /* current line number */", "  linenr_T off;                 /* offset between lnum and real line number */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  linenr_T lnum;                /* current line number */", "  linenr_T off;                 /* offset between lnum and real line number */", "  linenr_T lnum_save;           /* line nr used by foldUpdateIEMSRecurse() */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  linenr_T off;                 /* offset between lnum and real line number */", "  linenr_T lnum_save;           /* line nr used by foldUpdateIEMSRecurse() */", "  int lvl;                      /* current level (-1 for undefined) */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  linenr_T lnum_save;           /* line nr used by foldUpdateIEMSRecurse() */", "  int lvl;                      /* current level (-1 for undefined) */", "  int lvl_next;                 /* level used for next line */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  int lvl;                      /* current level (-1 for undefined) */", "  int lvl_next;                 /* level used for next line */", "  int start;                    /* number of folds that are forced to start at"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  int lvl_next;                 /* level used for next line */", "  int start;                    /* number of folds that are forced to start at", "                                   this line. */"], "readability/multiline_comment"]
["src/nvim/fold.c", ["  int lvl_next;                 /* level used for next line */", "  int start;                    /* number of folds that are forced to start at", "                                   this line. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["                                   this line. */", "  int end;                      /* level of fold that is forced to end below", "                                   this line */"], "readability/multiline_comment"]
["src/nvim/fold.c", ["                                   this line. */", "  int end;                      /* level of fold that is forced to end below", "                                   this line */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["                                   this line */", "  int had_end;                  /* level of fold that is forced to end above", "                                   this line (copy of \"end\" of prev. line) */"], "readability/multiline_comment"]
["src/nvim/fold.c", ["                                   this line */", "  int had_end;                  /* level of fold that is forced to end above", "                                   this line (copy of \"end\" of prev. line) */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  int had_end;                  /* level of fold that is forced to end above", "                                   this line (copy of \"end\" of prev. line) */", "} fline_T;"], "whitespace/parens"]
["src/nvim/fold.c", ["", "/* Function used by foldUpdateIEMSRecurse */", "typedef void (*LevelGetter)(fline_T *);"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* static functions {{{2 */", ""], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/*", " * While updating the folds lines between invalid_top and invalid_bot have an"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/*", " * When using 'foldexpr' we sometimes get the level of the next line, which"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* Flags used for \"done\" argument of setManualFold. */", "#define DONE_NOTHING    0"], "readability/old_style_comment"]
["src/nvim/fold.c", ["#define DONE_NOTHING    0", "#define DONE_ACTION     1       /* did close or open a fold */", "#define DONE_FOLD       2       /* did find a fold */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["#define DONE_ACTION     1       /* did close or open a fold */", "#define DONE_FOLD       2       /* did find a fold */", ""], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* Exported folding functions. {{{1 */", "/* copyFoldingState() {{{2 */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* Exported folding functions. {{{1 */", "/* copyFoldingState() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* copyFoldingState() {{{2 */", "/*", " * Copy that folding state from window \"wp_from\" to window \"wp_to\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* hasAnyFolding() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* hasAnyFolding() {{{2 */", "/*", " * Return TRUE if there may be folded lines in the current window."], "readability/old_style_comment"]
["src/nvim/fold.c", ["{", "  /* very simple now, but can become more complex later */", "  return !win->w_buffer->terminal && win->w_p_fen"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* hasFolding() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* hasFolding() {{{2 */", "/*", " * Return TRUE if line \"lnum\" in the current window is part of a closed"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  if (!hasAnyFolding(win)) {", "    if (infop != NULL)", "      infop->fi_level = 0;"], "readability/braces"]
["src/nvim/fold.c", ["  if (cache) {", "    /*", "     * First look in cached info for displayed lines.  This is probably"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  if (first == 0) {", "    /*", "     * Recursively search for a fold that contains \"lnum\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["    for (;; ) {", "      if (!foldFind(gap, lnum_rel, &fp))", "        break;"], "readability/braces"]
["src/nvim/fold.c", ["", "      /* Remember lowest level of fold that starts in \"lnum\". */", "      if (lnum_rel == fp->fd_top && low_level == 0)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      /* Remember lowest level of fold that starts in \"lnum\". */", "      if (lnum_rel == fp->fd_top && low_level == 0)", "        low_level = level + 1;"], "readability/braces"]
["src/nvim/fold.c", ["", "      /* is this fold closed? */", "      had_folded = check_closed(win, fp, &use_level, level,"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      had_folded = check_closed(win, fp, &use_level, level,", "          &maybe_small, lnum - lnum_rel);", "      if (had_folded) {"], "whitespace/alignment"]
["src/nvim/fold.c", ["      if (had_folded) {", "        /* Fold closed: Set last and quit loop. */", "        last += fp->fd_len - 1;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "      /* Fold found, but it's open: Check nested folds.  Line number is", "       * relative to containing fold. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      lnum_rel -= fp->fd_top;", "      ++level;", "    }"], "readability/increment"]
["src/nvim/fold.c", ["  }", "  if (lastp != NULL)", "    *lastp = last;"], "readability/braces"]
["src/nvim/fold.c", ["    *lastp = last;", "  if (firstp != NULL)", "    *firstp = first;"], "readability/braces"]
["src/nvim/fold.c", ["", "/* foldLevel() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldLevel() {{{2 */", "/*", " * Return fold level at line number \"lnum\" in the current window."], "readability/old_style_comment"]
["src/nvim/fold.c", ["{", "  /* While updating the folds lines between invalid_top and invalid_bot have", "   * an undefined fold level.  Otherwise update the folds first. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["   * an undefined fold level.  Otherwise update the folds first. */", "  if (invalid_top == (linenr_T)0)", "    checkupdate(curwin);"], "readability/braces"]
["src/nvim/fold.c", ["    checkupdate(curwin);", "  else if (lnum == prev_lnum && prev_lnum_lvl >= 0)", "    return prev_lnum_lvl;"], "readability/braces"]
["src/nvim/fold.c", ["    return prev_lnum_lvl;", "  else if (lnum >= invalid_top && lnum <= invalid_bot)", "    return -1;"], "readability/braces"]
["src/nvim/fold.c", ["", "  /* Return quickly when there is no folding at all in this window. */", "  if (!hasAnyFolding(curwin))"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  /* Return quickly when there is no folding at all in this window. */", "  if (!hasAnyFolding(curwin))", "    return 0;"], "readability/braces"]
["src/nvim/fold.c", ["", "/* foldmethodIsManual() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldmethodIsManual() {{{2 */", "/*", " * Return TRUE if 'foldmethod' is \"manual\""], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldmethodIsIndent() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldmethodIsIndent() {{{2 */", "/*", " * Return TRUE if 'foldmethod' is \"indent\""], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldmethodIsExpr() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldmethodIsExpr() {{{2 */", "/*", " * Return TRUE if 'foldmethod' is \"expr\""], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldmethodIsMarker() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldmethodIsMarker() {{{2 */", "/*", " * Return TRUE if 'foldmethod' is \"marker\""], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldmethodIsSyntax() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldmethodIsSyntax() {{{2 */", "/*", " * Return TRUE if 'foldmethod' is \"syntax\""], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldmethodIsDiff() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldmethodIsDiff() {{{2 */", "/*", " * Return TRUE if 'foldmethod' is \"diff\""], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* closeFoldRecurse() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* closeFoldRecurse() {{{2 */", "/*", " * Close fold for current window at line \"lnum\" recursively."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* opFoldRange() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* opFoldRange() {{{2 */", "/*", " * Open or Close folds for current window in lines \"first\" to \"last\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["    lnum_next = lnum;", "    /* Opening one level only: next fold to open is after the one going to", "     * be opened. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["     * be opened. */", "    if (opening && !recurse)", "      (void)hasFolding(lnum, NULL, &lnum_next);"], "readability/braces"]
["src/nvim/fold.c", ["  }", "  if (done == DONE_NOTHING)", "    EMSG(_(e_nofold));"], "readability/braces"]
["src/nvim/fold.c", ["    EMSG(_(e_nofold));", "  /* Force a redraw to remove the Visual highlighting. */", "  if (had_visual)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  /* Force a redraw to remove the Visual highlighting. */", "  if (had_visual)", "    redraw_curbuf_later(INVERTED);"], "readability/braces"]
["src/nvim/fold.c", ["", "/* openFold() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* openFold() {{{2 */", "/*", " * Open fold for current window at line \"lnum\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* openFoldRecurse() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* openFoldRecurse() {{{2 */", "/*", " * Open fold for current window at line \"lnum\" recursively."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldOpenCursor() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldOpenCursor() {{{2 */", "/*", " * Open folds until the cursor line is not in a closed fold."], "readability/old_style_comment"]
["src/nvim/fold.c", ["  checkupdate(curwin);", "  if (hasAnyFolding(curwin))", "    for (;; ) {"], "readability/braces"]
["src/nvim/fold.c", ["", "/* newFoldLevel() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* newFoldLevel() {{{2 */", "/*", " * Set new foldlevel for current window."], "readability/old_style_comment"]
["src/nvim/fold.c", ["  if (foldmethodIsDiff(curwin) && curwin->w_p_scb) {", "    /*", "     * Set the same foldlevel in other windows in diff mode."], "readability/old_style_comment"]
["src/nvim/fold.c", ["  if (wp->w_fold_manual) {", "    /* Set all flags for the first level of folds to FD_LEVEL.  Following", "     * manual open/close will then change the flags to FD_OPEN or"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    fp = (fold_T *)wp->w_folds.ga_data;", "    for (int i = 0; i < wp->w_folds.ga_len; ++i)", "      fp[i].fd_flags = FD_LEVEL;"], "readability/braces"]
["src/nvim/fold.c", ["    fp = (fold_T *)wp->w_folds.ga_data;", "    for (int i = 0; i < wp->w_folds.ga_len; ++i)", "      fp[i].fd_flags = FD_LEVEL;"], "readability/increment"]
["src/nvim/fold.c", ["", "/* foldCheckClose() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldCheckClose() {{{2 */", "/*", " * Apply 'foldlevel' to all folds that don't contain the cursor."], "readability/old_style_comment"]
["src/nvim/fold.c", ["{", "  if (*p_fcl != NUL) {  /* can only be \"all\" right now */", "    checkupdate(curwin);"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    checkupdate(curwin);", "    if (checkCloseRec(&curwin->w_folds, curwin->w_cursor.lnum,", "            (int)curwin->w_p_fdl))"], "readability/braces"]
["src/nvim/fold.c", ["    if (checkCloseRec(&curwin->w_folds, curwin->w_cursor.lnum,", "            (int)curwin->w_p_fdl))", "      changed_window_setting();"], "whitespace/alignment"]
["src/nvim/fold.c", ["", "/* checkCloseRec() {{{2 */", "static int checkCloseRec(garray_T *gap, linenr_T lnum, int level)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  fold_T      *fp;", "  int retval = FALSE;", ""], "readability/bool"]
["src/nvim/fold.c", ["  fp = (fold_T *)gap->ga_data;", "  for (int i = 0; i < gap->ga_len; ++i) {", "    /* Only manually opened folds may need to be closed. */"], "readability/increment"]
["src/nvim/fold.c", ["  for (int i = 0; i < gap->ga_len; ++i) {", "    /* Only manually opened folds may need to be closed. */", "    if (fp[i].fd_flags == FD_OPEN) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["        fp[i].fd_flags = FD_LEVEL;", "        retval = TRUE;", "      } else"], "readability/bool"]
["src/nvim/fold.c", ["        retval = TRUE;", "      } else", "        retval |= checkCloseRec(&fp[i].fd_nested, lnum - fp[i].fd_top,"], "readability/braces"]
["src/nvim/fold.c", ["        retval |= checkCloseRec(&fp[i].fd_nested, lnum - fp[i].fd_top,", "            level - 1);", "    }"], "whitespace/alignment"]
["src/nvim/fold.c", ["", "/* foldCreateAllowed() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldCreateAllowed() {{{2 */", "/*", " * Return TRUE if it's allowed to manually create or delete a fold."], "readability/old_style_comment"]
["src/nvim/fold.c", ["{", "  if (foldmethodIsManual(curwin) || foldmethodIsMarker(curwin))", "    return TRUE;"], "readability/braces"]
["src/nvim/fold.c", ["  if (foldmethodIsManual(curwin) || foldmethodIsMarker(curwin))", "    return TRUE;", "  if (create)"], "readability/bool"]
["src/nvim/fold.c", ["    return TRUE;", "  if (create)", "    EMSG(_(\"E350: Cannot create fold with current 'foldmethod'\"));"], "readability/braces"]
["src/nvim/fold.c", ["    EMSG(_(\"E350: Cannot create fold with current 'foldmethod'\"));", "  else", "    EMSG(_(\"E351: Cannot delete fold with current 'foldmethod'\"));"], "readability/braces"]
["src/nvim/fold.c", ["    EMSG(_(\"E351: Cannot delete fold with current 'foldmethod'\"));", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/fold.c", ["  int cont;", "  int use_level = FALSE;", "  int closed = FALSE;"], "readability/bool"]
["src/nvim/fold.c", ["  int use_level = FALSE;", "  int closed = FALSE;", "  int level = 0;"], "readability/bool"]
["src/nvim/fold.c", ["      ga_grow(&fold_ga, cont);", "      /* If the first fold starts before the new fold, let the new fold", "       * start there.  Otherwise the existing fold would change. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "      /* Adjust line numbers in contained folds to be relative to the", "       * new fold. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    }", "    /* Move remaining entries to after the new fold. */", "    if (i < gap->ga_len)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    /* Move remaining entries to after the new fold. */", "    if (i < gap->ga_len)", "      memmove(fp + 1, (fold_T *)gap->ga_data + i,"], "readability/braces"]
["src/nvim/fold.c", ["", "    /* insert new fold */", "    fp->fd_nested = fold_ga;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "    /* We want the new fold to be closed.  If it would remain open because", "     * of using 'foldlevel', need to adjust fd_flags of containing folds."], "readability/old_style_comment"]
["src/nvim/fold.c", ["    for (;; ) {", "      if (!foldFind(gap, lnum - lnum_off, &fp))", "        break;"], "readability/braces"]
["src/nvim/fold.c", ["        break;", "      /* lnum is inside this fold, remember info */", "      found_ga = gap;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "      /* check nested folds */", "      gap = &fp->fd_nested;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      lnum_off += fp->fd_top;", "      ++level;", "    }"], "readability/increment"]
["src/nvim/fold.c", ["    if (found_ga == NULL) {", "      ++lnum;", "    } else {"], "readability/increment"]
["src/nvim/fold.c", ["", "/* clearFolding() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* clearFolding() {{{2 */", "/*", " * Remove all folding for window \"win\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldUpdate() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldUpdate() {{{2 */", "/*", " * Update folds for changes in the buffer of a window."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "    /* reset got_int here, otherwise it won't work */", "    got_int = FALSE;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    /* reset got_int here, otherwise it won't work */", "    got_int = FALSE;", "    foldUpdateIEMS(wp, top, bot);"], "readability/bool"]
["src/nvim/fold.c", ["", "/* foldUpdateAll() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldUpdateAll() {{{2 */", "/*", " * Update all lines in a window for folding."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "        /* When moving up, consider a fold above the cursor; when", "         * moving down consider a fold below the cursor. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["        if (dir == FORWARD) {", "          if (fp - (fold_T *)gap->ga_data >= gap->ga_len)", "            break;"], "readability/braces"]
["src/nvim/fold.c", ["            break;", "          --fp;", "        } else {"], "readability/increment"]
["src/nvim/fold.c", ["        } else {", "          if (fp == (fold_T *)gap->ga_data)", "            break;"], "readability/braces"]
["src/nvim/fold.c", ["        }", "        /* don't look for contained folds, they will always move", "         * the cursor too far. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      if (!last) {", "        /* Check if this fold is closed. */", "        if (check_closed(curwin, fp, &use_level, level,"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "        /* \"[z\" and \"]z\" stop at closed fold */", "        if (last && !updown)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["        /* \"[z\" and \"]z\" stop at closed fold */", "        if (last && !updown)", "          break;"], "readability/braces"]
["src/nvim/fold.c", ["        if (dir == FORWARD) {", "          /* to start of next fold if there is one */", "          if (fp + 1 - (fold_T *)gap->ga_data < gap->ga_len) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["            lnum = fp[1].fd_top + lnum_off;", "            if (lnum > curwin->w_cursor.lnum)", "              lnum_found = lnum;"], "readability/braces"]
["src/nvim/fold.c", ["        } else {", "          /* to end of previous fold if there is one */", "          if (fp > (fold_T *)gap->ga_data) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["            lnum = fp[-1].fd_top + lnum_off + fp[-1].fd_len - 1;", "            if (lnum < curwin->w_cursor.lnum)", "              lnum_found = lnum;"], "readability/braces"]
["src/nvim/fold.c", ["      } else {", "        /* Open fold found, set cursor to its start/end and then check", "         * nested folds. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["          lnum = fp->fd_top + lnum_off + fp->fd_len - 1;", "          if (lnum > curwin->w_cursor.lnum)", "            lnum_found = lnum;"], "readability/braces"]
["src/nvim/fold.c", ["          lnum = fp->fd_top + lnum_off;", "          if (lnum < curwin->w_cursor.lnum)", "            lnum_found = lnum;"], "readability/braces"]
["src/nvim/fold.c", ["", "      if (last)", "        break;"], "readability/braces"]
["src/nvim/fold.c", ["", "      /* Check nested folds (if any). */", "      gap = &fp->fd_nested;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      lnum_off += fp->fd_top;", "      ++level;", "    }"], "readability/increment"]
["src/nvim/fold.c", ["    if (lnum_found != curwin->w_cursor.lnum) {", "      if (retval == FAIL)", "        setpcmark();"], "readability/braces"]
["src/nvim/fold.c", ["      retval = OK;", "    } else", "      break;"], "readability/braces"]
["src/nvim/fold.c", ["", "/* foldInitWin() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldInitWin() {{{2 */", "/*", " * Init the fold info in a new window."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* find_wl_entry() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* find_wl_entry() {{{2 */", "/*", " * Find an entry in the win->w_lines[] array for buffer line \"lnum\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  for (i = 0; i < win->w_lines_valid; ++i)", "    if (win->w_lines[i].wl_valid) {"], "readability/braces"]
["src/nvim/fold.c", ["", "  for (i = 0; i < win->w_lines_valid; ++i)", "    if (win->w_lines[i].wl_valid) {"], "readability/increment"]
["src/nvim/fold.c", ["    if (win->w_lines[i].wl_valid) {", "      if (lnum < win->w_lines[i].wl_lnum)", "        return -1;"], "readability/braces"]
["src/nvim/fold.c", ["        return -1;", "      if (lnum <= win->w_lines[i].wl_lastlnum)", "        return i;"], "readability/braces"]
["src/nvim/fold.c", ["", "/* foldAdjustVisual() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldAdjustVisual() {{{2 */", "/*", " * Adjust the Visual area to include any fold at the start or end completely."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  if (!VIsual_active || !hasAnyFolding(curwin))", "    return;"], "readability/braces"]
["src/nvim/fold.c", ["  }", "  if (hasFolding(start->lnum, &start->lnum, NULL))", "    start->col = 0;"], "readability/braces"]
["src/nvim/fold.c", ["", "/* cursor_foldstart() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* cursor_foldstart() {{{2 */", "/*", " * Move the cursor to the first line of a closed fold."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* Internal functions for \"fold_T\" {{{1 */", "/* cloneFoldGrowArray() {{{2 */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* Internal functions for \"fold_T\" {{{1 */", "/* cloneFoldGrowArray() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* cloneFoldGrowArray() {{{2 */", "/*", " * Will \"clone\" (i.e deep copy) a garray_T of folds."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  if (GA_EMPTY(from))", "    return;"], "readability/braces"]
["src/nvim/fold.c", ["    cloneFoldGrowArray(&from_p->fd_nested, &to_p->fd_nested);", "    ++to->ga_len;", "    ++from_p;"], "readability/increment"]
["src/nvim/fold.c", ["    ++to->ga_len;", "    ++from_p;", "    ++to_p;"], "readability/increment"]
["src/nvim/fold.c", ["    ++from_p;", "    ++to_p;", "  }"], "readability/increment"]
["src/nvim/fold.c", ["", "/* foldFind() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldFind() {{{2 */", "/*", " * Search for line \"lnum\" in folds of growarray \"gap\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /*", "   * Perform a binary search."], "readability/old_style_comment"]
["src/nvim/fold.c", ["    linenr_T i = (low + high) / 2;", "    if (fp[i].fd_top > lnum)", "      /* fold below lnum, adjust high */"], "readability/braces"]
["src/nvim/fold.c", ["    if (fp[i].fd_top > lnum)", "      /* fold below lnum, adjust high */", "      high = i - 1;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      high = i - 1;", "    else if (fp[i].fd_top + fp[i].fd_len <= lnum)", "      /* fold above lnum, adjust low */"], "readability/braces"]
["src/nvim/fold.c", ["    else if (fp[i].fd_top + fp[i].fd_len <= lnum)", "      /* fold above lnum, adjust low */", "      low = i + 1;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      low = i + 1;", "    else {", "      /* lnum is inside this fold */"], "readability/braces"]
["src/nvim/fold.c", ["      low = i + 1;", "    else {", "      /* lnum is inside this fold */"], "readability/braces"]
["src/nvim/fold.c", ["    else {", "      /* lnum is inside this fold */", "      *fpp = fp + i;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      *fpp = fp + i;", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/fold.c", ["", "/* foldLevelWin() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldLevelWin() {{{2 */", "/*", " * Return fold level at line number \"lnum\" in window \"wp\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* Recursively search for a fold that contains \"lnum\". */", "  gap = &wp->w_folds;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  for (;; ) {", "    if (!foldFind(gap, lnum_rel, &fp))", "      break;"], "readability/braces"]
["src/nvim/fold.c", ["      break;", "    /* Check nested folds.  Line number is relative to containing fold. */", "    gap = &fp->fd_nested;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    lnum_rel -= fp->fd_top;", "    ++level;", "  }"], "readability/increment"]
["src/nvim/fold.c", ["", "/* checkupdate() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* checkupdate() {{{2 */", "/*", " * Check if the folds in window \"wp\" are invalid and update them if needed."], "readability/old_style_comment"]
["src/nvim/fold.c", ["  if (wp->w_foldinvalid) {", "    foldUpdate(wp, (linenr_T)1, (linenr_T)MAXLNUM);     /* will update all */", "    wp->w_foldinvalid = false;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* setFoldRepeat() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* setFoldRepeat() {{{2 */", "/*", " * Open or close fold for current window at line \"lnum\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  for (n = 0; n < count; ++n) {", "    done = DONE_NOTHING;"], "readability/increment"]
["src/nvim/fold.c", ["    if (!(done & DONE_ACTION)) {", "      /* Only give an error message when no fold could be opened. */", "      if (n == 0 && !(done & DONE_FOLD))"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      /* Only give an error message when no fold could be opened. */", "      if (n == 0 && !(done & DONE_FOLD))", "        EMSG(_(e_nofold));"], "readability/braces"]
["src/nvim/fold.c", ["", "/* setManualFold() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* setManualFold() {{{2 */", "/*", " * Open or close the fold in the current window which contains \"lnum\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "    /*", "     * Do the same operation in other windows in diff mode.  Calculate the"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* setManualFoldWin() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* setManualFoldWin() {{{2 */", "/*", " * Open or close the fold in window \"wp\" which contains \"lnum\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["  int level = 0;", "  int use_level = FALSE;", "  int found_fold = FALSE;"], "readability/bool"]
["src/nvim/fold.c", ["  int use_level = FALSE;", "  int found_fold = FALSE;", "  garray_T    *gap;"], "readability/bool"]
["src/nvim/fold.c", ["", "  /*", "   * Find the fold, open or close it."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "    /* lnum is inside this fold */", "    found_fold = TRUE;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    /* lnum is inside this fold */", "    found_fold = TRUE;", ""], "readability/bool"]
["src/nvim/fold.c", ["", "    /* If there is a following fold, continue there next time. */", "    if (fp + 1 < (fold_T *)gap->ga_data + gap->ga_len)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    /* If there is a following fold, continue there next time. */", "    if (fp + 1 < (fold_T *)gap->ga_data + gap->ga_len)", "      next = fp[1].fd_top + off;"], "readability/braces"]
["src/nvim/fold.c", ["", "    /* Change from level-dependent folding to manual. */", "    if (use_level || fp->fd_flags == FD_LEVEL) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    if (use_level || fp->fd_flags == FD_LEVEL) {", "      use_level = TRUE;", "      if (level >= wp->w_p_fdl)"], "readability/bool"]
["src/nvim/fold.c", ["      use_level = TRUE;", "      if (level >= wp->w_p_fdl)", "        fp->fd_flags = FD_CLOSED;"], "readability/braces"]
["src/nvim/fold.c", ["        fp->fd_flags = FD_CLOSED;", "      else", "        fp->fd_flags = FD_OPEN;"], "readability/braces"]
["src/nvim/fold.c", ["      fp2 = (fold_T *)fp->fd_nested.ga_data;", "      for (j = 0; j < fp->fd_nested.ga_len; ++j)", "        fp2[j].fd_flags = FD_LEVEL;"], "readability/braces"]
["src/nvim/fold.c", ["      fp2 = (fold_T *)fp->fd_nested.ga_data;", "      for (j = 0; j < fp->fd_nested.ga_len; ++j)", "        fp2[j].fd_flags = FD_LEVEL;"], "readability/increment"]
["src/nvim/fold.c", ["", "    /* Simple case: Close recursively means closing the fold. */", "    if (!opening && recurse) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    } else if (fp->fd_flags == FD_CLOSED) {", "      /* When opening, open topmost closed fold. */", "      if (opening) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["        done |= DONE_ACTION;", "        if (recurse)", "          foldOpenNested(fp);"], "readability/braces"]
["src/nvim/fold.c", ["", "    /* fold is open, check nested folds */", "    found = fp;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    off += fp->fd_top;", "    ++level;", "  }"], "readability/increment"]
["src/nvim/fold.c", ["  if (found_fold) {", "    /* When closing and not recurse, close deepest open fold. */", "    if (!opening && found != NULL) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    wp->w_fold_manual = true;", "    if (done & DONE_ACTION)", "      changed_window_setting_win(wp);"], "readability/braces"]
["src/nvim/fold.c", ["    done |= DONE_FOLD;", "  } else if (donep == NULL && wp == curwin)", "    EMSG(_(e_nofold));"], "readability/braces"]
["src/nvim/fold.c", ["", "  if (donep != NULL)", "    *donep |= done;"], "readability/braces"]
["src/nvim/fold.c", ["", "/* foldOpenNested() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldOpenNested() {{{2 */", "/*", " * Open all nested folds in fold \"fpr\" recursively."], "readability/old_style_comment"]
["src/nvim/fold.c", ["  fp = (fold_T *)fpr->fd_nested.ga_data;", "  for (int i = 0; i < fpr->fd_nested.ga_len; ++i) {", "    foldOpenNested(&fp[i]);"], "readability/increment"]
["src/nvim/fold.c", ["  } else {", "    /* Move nested folds one level up, to overwrite the fold that is", "     * deleted. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    {", "      /* Get \"fp\" again, the array may have been reallocated. */", "      fp = (fold_T *)gap->ga_data + idx;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["        nfp[i].fd_top += fp->fd_top;", "        if (fp->fd_flags == FD_LEVEL)", "          nfp[i].fd_flags = FD_LEVEL;"], "readability/braces"]
["src/nvim/fold.c", ["", "/* deleteFoldRecurse() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* deleteFoldRecurse() {{{2 */", "/*", " * Delete nested folds in a fold."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldMarkAdjust() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldMarkAdjust() {{{2 */", "/*", " * Update line numbers of folds for inserted/deleted lines."], "readability/old_style_comment"]
["src/nvim/fold.c", [" */", "void foldMarkAdjust(win_T *wp, linenr_T line1, linenr_T line2, long amount, long amount_after)", "{"], "whitespace/line_length"]
["src/nvim/fold.c", ["{", "  /* If deleting marks from line1 to line2, but not deleting all those", "   * lines, set line2 so that only deleted lines have their folds removed. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["   * lines, set line2 so that only deleted lines have their folds removed. */", "  if (amount == MAXLNUM && line2 >= line1 && line2 - line1 >= -amount_after)", "    line2 = line1 - amount_after - 1;"], "readability/braces"]
["src/nvim/fold.c", ["    line2 = line1 - amount_after - 1;", "  /* If appending a line in Insert mode, it should be included in the fold", "   * just above the line. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* In Insert mode an inserted line at the top of a fold is considered part", "   * of the fold, otherwise it isn't. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["   * of the fold, otherwise it isn't. */", "  if ((State & INSERT) && amount == (linenr_T)1 && line2 == MAXLNUM)", "    top = line1 + 1;"], "readability/braces"]
["src/nvim/fold.c", ["    top = line1 + 1;", "  else", "    top = line1;"], "readability/braces"]
["src/nvim/fold.c", ["", "  /* Find the fold containing or just below \"line1\". */", "  (void)foldFind(gap, line1, &fp);"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /*", "   * Adjust all folds below \"line1\" that are affected."], "readability/old_style_comment"]
["src/nvim/fold.c", ["   */", "  for (int i = (int)(fp - (fold_T *)gap->ga_data); i < gap->ga_len; ++i, ++fp) {", "    /*"], "readability/increment"]
["src/nvim/fold.c", ["  for (int i = (int)(fp - (fold_T *)gap->ga_data); i < gap->ga_len; ++i, ++fp) {", "    /*", "     * Check for these situations:"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "    last = fp->fd_top + fp->fd_len - 1;     /* last line of fold */", ""], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "    /* 1. fold completely above line1: nothing to do */", "    if (last < line1)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    /* 1. fold completely above line1: nothing to do */", "    if (last < line1)", "      continue;"], "readability/braces"]
["src/nvim/fold.c", ["", "    /* 6. fold below line2: only adjust for amount_after */", "    if (fp->fd_top > line2) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    if (fp->fd_top > line2) {", "      if (amount_after == 0)", "        break;"], "readability/braces"]
["src/nvim/fold.c", ["          if (last <= line2) {", "            /* 2. fold contains line1, line2 is below fold */", "            if (amount == MAXLNUM)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["            /* 2. fold contains line1, line2 is below fold */", "            if (amount == MAXLNUM)", "              fp->fd_len = line1 - fp->fd_top;"], "readability/braces"]
["src/nvim/fold.c", ["              fp->fd_len = line1 - fp->fd_top;", "            else", "              fp->fd_len += amount;"], "readability/braces"]
["src/nvim/fold.c", ["          } else {", "            /* 3. fold contains line1 and line2 */", "            fp->fd_len += amount_after;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["        } else {", "          /* 5. fold is below line1 and contains line2; need to", "           * correct nested folds too */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* getDeepestNesting() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* getDeepestNesting() {{{2 */", "/*", " * Get the lowest 'foldlevel' value that makes the deepest nested fold in the"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  fp = (fold_T *)gap->ga_data;", "  for (int i = 0; i < gap->ga_len; ++i) {", "    level = getDeepestNestingRecurse(&fp[i].fd_nested) + 1;"], "readability/increment"]
["src/nvim/fold.c", ["    level = getDeepestNestingRecurse(&fp[i].fd_nested) + 1;", "    if (level > maxlevel)", "      maxlevel = level;"], "readability/braces"]
["src/nvim/fold.c", ["", "  /* Check if this fold is closed.  If the flag is FD_LEVEL this", "   * fold and all folds it contains depend on 'foldlevel'. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldCreateMarkers() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldCreateMarkers() {{{2 */", "/*", " * Create a fold from line \"start\" to line \"end\" (inclusive) in the current"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* Update both changes here, to avoid all folds after the start are", "   * changed when the start marker is inserted and the end isn't. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldAddMarker() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldAddMarker() {{{2 */", "/*", " * Add \"marker[markerlen]\" in 'commentstring' to line \"lnum\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* deleteFoldMarkers() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* deleteFoldMarkers() {{{2 */", "/*", " * Delete the markers for a fold, causing it to be deleted."], "readability/old_style_comment"]
["src/nvim/fold.c", ["    }", "    /* Found the marker, include a digit if it's there. */", "    size_t len = markerlen;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    size_t len = markerlen;", "    if (ascii_isdigit(p[len]))", "      ++len;"], "readability/braces"]
["src/nvim/fold.c", ["    if (ascii_isdigit(p[len]))", "      ++len;", "    if (*cms != NUL) {"], "readability/increment"]
["src/nvim/fold.c", ["    if (*cms != NUL) {", "      /* Also delete 'commentstring' if it matches. */", "      cms2 = (char_u *)strstr((char *)cms, \"%s\");"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    if (u_save(lnum - 1, lnum + 1) == OK) {", "      /* Make new line: text-before-marker + text-after-marker */", "      newline = xmalloc(STRLEN(line) - len + 1);"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  char_u      *text = NULL;", "  /* an error occurred when evaluating 'fdt' setting */", "  static int got_fdt_error = FALSE;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  /* an error occurred when evaluating 'fdt' setting */", "  static int got_fdt_error = FALSE;", "  int save_did_emsg = did_emsg;"], "readability/bool"]
["src/nvim/fold.c", ["", "  if (last_wp == NULL || last_wp != wp || last_lnum > lnum || last_lnum == 0)", "    /* window changed, try evaluating foldtext setting once again */"], "readability/braces"]
["src/nvim/fold.c", ["  if (last_wp == NULL || last_wp != wp || last_lnum > lnum || last_lnum == 0)", "    /* window changed, try evaluating foldtext setting once again */", "    got_fdt_error = FALSE;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    /* window changed, try evaluating foldtext setting once again */", "    got_fdt_error = FALSE;", ""], "readability/bool"]
["src/nvim/fold.c", ["", "  if (!got_fdt_error)", "    /* a previous error should not abort evaluating 'foldexpr' */"], "readability/braces"]
["src/nvim/fold.c", ["  if (!got_fdt_error)", "    /* a previous error should not abort evaluating 'foldexpr' */", "    did_emsg = FALSE;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    /* a previous error should not abort evaluating 'foldexpr' */", "    did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/fold.c", ["    // Set \"v:foldstart\" and \"v:foldend\".", "    set_vim_var_nr(VV_FOLDSTART, (varnumber_T) lnum);", "    set_vim_var_nr(VV_FOLDEND, (varnumber_T) lnume);"], "whitespace/cast"]
["src/nvim/fold.c", ["    set_vim_var_nr(VV_FOLDSTART, (varnumber_T) lnum);", "    set_vim_var_nr(VV_FOLDEND, (varnumber_T) lnume);", ""], "whitespace/cast"]
["src/nvim/fold.c", ["    set_vim_var_string(VV_FOLDDASHES, dashes, -1);", "    set_vim_var_nr(VV_FOLDLEVEL, (varnumber_T) level);", ""], "whitespace/cast"]
["src/nvim/fold.c", ["", "    /* skip evaluating foldtext on errors */", "    if (!got_fdt_error) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "      if (text == NULL || did_emsg)", "        got_fdt_error = TRUE;"], "readability/braces"]
["src/nvim/fold.c", ["      if (text == NULL || did_emsg)", "        got_fdt_error = TRUE;", ""], "readability/bool"]
["src/nvim/fold.c", ["", "    if (!did_emsg && save_did_emsg)", "      did_emsg = save_did_emsg;"], "readability/braces"]
["src/nvim/fold.c", ["    if (text != NULL) {", "      /* Replace unprintable characters, if there are any.  But", "       * replace a TAB with a space. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["          p += len - 1;", "        } else if (*p == TAB)", "          *p = ' ';"], "readability/braces"]
["src/nvim/fold.c", ["          *p = ' ';", "        else if (ptr2cells(p) > 1)", "          break;"], "readability/braces"]
["src/nvim/fold.c", ["", "/* foldtext_cleanup() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldtext_cleanup() {{{2 */", "/*", " * Remove 'foldmarker' and 'commentstring' from \"str\" (in-place)."], "readability/old_style_comment"]
["src/nvim/fold.c", ["  char_u      *p;", "  int did1 = FALSE;", "  int did2 = FALSE;"], "readability/bool"]
["src/nvim/fold.c", ["  int did1 = FALSE;", "  int did2 = FALSE;", ""], "readability/bool"]
["src/nvim/fold.c", ["", "  /* Ignore leading and trailing white space in 'commentstring'. */", "  char_u *cms_start = skipwhite(curbuf->b_p_cms);"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  size_t cms_slen = STRLEN(cms_start);", "  while (cms_slen > 0 && ascii_iswhite(cms_start[cms_slen - 1]))", "    --cms_slen;"], "readability/braces"]
["src/nvim/fold.c", ["  while (cms_slen > 0 && ascii_iswhite(cms_start[cms_slen - 1]))", "    --cms_slen;", ""], "readability/increment"]
["src/nvim/fold.c", ["", "  /* locate \"%s\" in 'commentstring', use the part before and after it. */", "  char_u *cms_end = (char_u *)strstr((char *)cms_start, \"%s\");"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "    /* exclude white space before \"%s\" */", "    while (cms_slen > 0 && ascii_iswhite(cms_start[cms_slen - 1]))"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    /* exclude white space before \"%s\" */", "    while (cms_slen > 0 && ascii_iswhite(cms_start[cms_slen - 1]))", "      --cms_slen;"], "readability/braces"]
["src/nvim/fold.c", ["    while (cms_slen > 0 && ascii_iswhite(cms_start[cms_slen - 1]))", "      --cms_slen;", ""], "readability/increment"]
["src/nvim/fold.c", ["", "    /* skip \"%s\" and white space after it */", "    s = skipwhite(cms_end + 2);"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    size_t len = 0;", "    if (STRNCMP(s, curwin->w_p_fmr, foldstartmarkerlen) == 0)", "      len = foldstartmarkerlen;"], "readability/braces"]
["src/nvim/fold.c", ["      len = foldstartmarkerlen;", "    else if (STRNCMP(s, foldendmarker, foldendmarkerlen) == 0)", "      len = foldendmarkerlen;"], "readability/braces"]
["src/nvim/fold.c", ["    if (len > 0) {", "      if (ascii_isdigit(s[len]))", "        ++len;"], "readability/braces"]
["src/nvim/fold.c", ["      if (ascii_isdigit(s[len]))", "        ++len;", ""], "readability/increment"]
["src/nvim/fold.c", ["", "      /* May remove 'commentstring' start.  Useful when it's a double", "       * quote and we already removed a double quote. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["       * quote and we already removed a double quote. */", "      for (p = s; p > str && ascii_iswhite(p[-1]); --p)", "        ;"], "readability/braces"]
["src/nvim/fold.c", ["       * quote and we already removed a double quote. */", "      for (p = s; p > str && ascii_iswhite(p[-1]); --p)", "        ;"], "readability/increment"]
["src/nvim/fold.c", ["      for (p = s; p > str && ascii_iswhite(p[-1]); --p)", "        ;", "      if (p >= str + cms_slen"], "whitespace/semicolon"]
["src/nvim/fold.c", ["        len = cms_slen;", "        did1 = TRUE;", "      } else if (!did2 && cms_elen > 0"], "readability/bool"]
["src/nvim/fold.c", ["        len = cms_elen;", "        did2 = TRUE;", "      }"], "readability/bool"]
["src/nvim/fold.c", ["    if (len != 0) {", "      while (ascii_iswhite(s[len]))", "        ++len;"], "readability/braces"]
["src/nvim/fold.c", ["      while (ascii_iswhite(s[len]))", "        ++len;", "      STRMOVE(s, s + len);"], "readability/increment"]
["src/nvim/fold.c", ["", "/* Folding by indent, expr, marker and syntax. {{{1 */", "/* Function declarations. {{{2 */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* Folding by indent, expr, marker and syntax. {{{1 */", "/* Function declarations. {{{2 */", ""], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldUpdateIEMS() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldUpdateIEMS() {{{2 */", "/*", " * Update the folding for window \"wp\", at least from lines \"top\" to \"bot\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* Avoid problems when being called recursively. */", "  if (invalid_top != (linenr_T)0)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  /* Avoid problems when being called recursively. */", "  if (invalid_top != (linenr_T)0)", "    return;"], "readability/braces"]
["src/nvim/fold.c", ["  if (wp->w_foldinvalid) {", "    /* Need to update all folds. */", "    top = 1;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "    /* Mark all folds a maybe-small. */", "    setSmallMaybe(&wp->w_folds);"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* add the context for \"diff\" folding */", "  if (foldmethodIsDiff(wp)) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  if (foldmethodIsDiff(wp)) {", "    if (top > diff_context)", "      top -= diff_context;"], "readability/braces"]
["src/nvim/fold.c", ["      top -= diff_context;", "    else", "      top = 1;"], "readability/braces"]
["src/nvim/fold.c", ["", "    /* Init marker variables to speed up foldlevelMarker(). */", "    parseMarker(wp);"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "    /* Need to get the level of the line above top, it is used if there is", "     * no marker at the top. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "      /* The fold may end just above the top, check for that. */", "      fline.lnum = top - 1;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "      /* If a fold started here, we already had the level, if it stops", "       * here, we need to use lvl_next.  Could also start and end a fold"], "readability/old_style_comment"]
["src/nvim/fold.c", ["       * in the same line. */", "      if (fline.lvl > level)", "        fline.lvl = level - (fline.lvl - fline.lvl_next);"], "readability/braces"]
["src/nvim/fold.c", ["        fline.lvl = level - (fline.lvl - fline.lvl_next);", "      else", "        fline.lvl = fline.lvl_next;"], "readability/braces"]
["src/nvim/fold.c", ["      getlevel = foldlevelExpr;", "      /* start one line back, because a \"<1\" may indicate the end of a", "       * fold in the topline */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["       * fold in the topline */", "      if (top > 1)", "        --fline.lnum;"], "readability/braces"]
["src/nvim/fold.c", ["      if (top > 1)", "        --fline.lnum;", "    } else if (foldmethodIsSyntax(wp))"], "readability/increment"]
["src/nvim/fold.c", ["        --fline.lnum;", "    } else if (foldmethodIsSyntax(wp))", "      getlevel = foldlevelSyntax;"], "readability/braces"]
["src/nvim/fold.c", ["      getlevel = foldlevelSyntax;", "    else if (foldmethodIsDiff(wp))", "      getlevel = foldlevelDiff;"], "readability/braces"]
["src/nvim/fold.c", ["      getlevel = foldlevelDiff;", "    else", "      getlevel = foldlevelIndent;"], "readability/braces"]
["src/nvim/fold.c", ["", "    /* Backup to a line for which the fold level is defined.  Since it's", "     * always defined for line one, we will stop there. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    fline.lvl = -1;", "    for (; !got_int; --fline.lnum) {", "      /* Reset lvl_next each time, because it will be set to a value for"], "readability/increment"]
["src/nvim/fold.c", ["    for (; !got_int; --fline.lnum) {", "      /* Reset lvl_next each time, because it will be set to a value for", "       * the next line, but we search backwards here. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      getlevel(&fline);", "      if (fline.lvl >= 0)", "        break;"], "readability/braces"]
["src/nvim/fold.c", ["", "  /*", "   * If folding is defined by the syntax, it is possible that a change in"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    while (current_fdl < fline.lvl) {", "      if (!foldFind(gap, lnum_rel, &fpn))", "        break;"], "readability/braces"]
["src/nvim/fold.c", ["        break;", "      ++current_fdl;", ""], "readability/increment"]
["src/nvim/fold.c", ["", "      if (fold_end_lnum > bot)", "        bot = fold_end_lnum;"], "readability/braces"]
["src/nvim/fold.c", ["  while (!got_int) {", "    /* Always stop at the end of the file (\"end\" can be past the end of", "     * the file). */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["     * the file). */", "    if (fline.lnum > wp->w_buffer->b_ml.ml_line_count)", "      break;"], "readability/braces"]
["src/nvim/fold.c", ["    if (fline.lnum > end) {", "      /* For \"marker\", \"expr\"  and \"syntax\"  methods: If a change caused", "       * a fold to be removed, we need to continue at least until where"], "readability/old_style_comment"]
["src/nvim/fold.c", ["       * it ended. */", "      if (getlevel != foldlevelMarker", "          && getlevel != foldlevelSyntax"], "readability/braces"]
["src/nvim/fold.c", ["        break;", "      if ((start <= end", "           && foldFind(&wp->w_folds, end, &fp)"], "readability/braces"]
["src/nvim/fold.c", ["        end = fp->fd_top + fp->fd_len - 1;", "      else if (getlevel == foldlevelSyntax", "               && foldLevelWin(wp, fline.lnum) != fline.lvl)"], "readability/braces"]
["src/nvim/fold.c", ["               && foldLevelWin(wp, fline.lnum) != fline.lvl)", "        /* For \"syntax\" method: Compare the foldlevel that the syntax", "         * tells us to the foldlevel from the existing folds.  If they"], "readability/old_style_comment"]
["src/nvim/fold.c", ["        end = fline.lnum;", "      else", "        break;"], "readability/braces"]
["src/nvim/fold.c", ["", "    /* A level 1 fold starts at a line with foldlevel > 0. */", "    if (fline.lvl > 0) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    } else {", "      if (fline.lnum == wp->w_buffer->b_ml.ml_line_count)", "        break;"], "readability/braces"]
["src/nvim/fold.c", ["        break;", "      ++fline.lnum;", "      fline.lvl = fline.lvl_next;"], "readability/increment"]
["src/nvim/fold.c", ["", "  /* If some fold changed, need to redraw and position cursor. */", "  if (fold_changed && wp->w_p_fen)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  /* If some fold changed, need to redraw and position cursor. */", "  if (fold_changed && wp->w_p_fen)", "    changed_window_setting_win(wp);"], "readability/braces"]
["src/nvim/fold.c", ["", "  /* If we updated folds past \"bot\", need to redraw more lines.  Don't do", "   * this in other situations, the changed lines will be redrawn anyway and"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  if (end != bot) {", "    if (wp->w_redraw_top == 0 || wp->w_redraw_top > top)", "      wp->w_redraw_top = top;"], "readability/braces"]
["src/nvim/fold.c", ["      wp->w_redraw_top = top;", "    if (wp->w_redraw_bot < end)", "      wp->w_redraw_bot = end;"], "readability/braces"]
["src/nvim/fold.c", ["", "/* foldUpdateIEMSRecurse() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldUpdateIEMSRecurse() {{{2 */", "/*", " * Update a fold that starts at \"flp->lnum\".  At this line there is always a"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /*", "   * If using the marker method, the start line is not the start of a fold"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /*", "   * Loop over all lines in this fold, or until \"bot\" is hit."], "readability/old_style_comment"]
["src/nvim/fold.c", ["  while (!got_int) {", "    /* Updating folds can be slow, check for CTRL-C. */", "    line_breakcheck();"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "    /* Set \"lvl\" to the level of line \"flp->lnum\".  When flp->start is set", "     * and after the first line of the fold, set the level to zero to"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    lvl = flp->lvl;", "    if (lvl > MAX_LEVEL)", "      lvl = MAX_LEVEL;"], "readability/braces"]
["src/nvim/fold.c", ["      lvl = MAX_LEVEL;", "    if (flp->lnum > firstlnum", "        && (level > lvl - flp->start || level >= flp->had_end))"], "readability/braces"]
["src/nvim/fold.c", ["    if (flp->lnum > bot && !finish && fp != NULL) {", "      /* For \"marker\" and \"syntax\" methods:", "       * - If a change caused a nested fold to be removed, we need to"], "readability/old_style_comment"]
["src/nvim/fold.c", ["       */", "      if (getlevel != foldlevelMarker", "          && getlevel != foldlevelExpr"], "readability/braces"]
["src/nvim/fold.c", ["      if (lvl >= level) {", "        /* Compute how deep the folds currently are, if it's deeper", "         * than \"lvl\" then some must be deleted, need to update"], "readability/old_style_comment"]
["src/nvim/fold.c", ["        while (foldFind(&fp2->fd_nested, ll, &fp2)) {", "          ++i;", "          ll -= fp2->fd_top;"], "readability/increment"]
["src/nvim/fold.c", ["", "    /* At the start of the first nested fold and at the end of the current", "     * fold: check if existing folds at this level, before the current"], "readability/old_style_comment"]
["src/nvim/fold.c", ["            || flp->lnum == linecount)) {", "      /*", "       * Remove or update folds that have lines between startlnum and"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      while (!got_int) {", "        /* set concat to 1 if it's allowed to concatenated this fold", "         * with a previous one that touches it. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["         * with a previous one that touches it. */", "        if (flp->start != 0 || flp->had_end <= MAX_LEVEL)", "          concat = 0;"], "readability/braces"]
["src/nvim/fold.c", ["          concat = 0;", "        else", "          concat = 1;"], "readability/braces"]
["src/nvim/fold.c", ["", "        /* Find an existing fold to re-use.  Preferably one that", "         * includes startlnum, otherwise one that ends just before"], "readability/old_style_comment"]
["src/nvim/fold.c", ["          if (fp->fd_top + fp->fd_len + concat > firstlnum) {", "            /* Use existing fold for the new fold.  If it starts", "             * before where we started looking, extend it.  If it"], "readability/old_style_comment"]
["src/nvim/fold.c", ["              fp = (fold_T *)gap->ga_data + i + 1;", "              /* If using the \"marker\" or \"syntax\" method, we", "               * need to continue until the end of the fold is"], "readability/old_style_comment"]
["src/nvim/fold.c", ["          } else {", "            /* A fold has some lines above startlnum, truncate it", "             * to stop just above startlnum.  */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["        } else {", "          /* Insert new fold.  Careful: ga_data may be NULL and it", "           * may change! */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["          fp = (fold_T *)gap->ga_data + i;", "          /* The new fold continues until bot, unless we find the", "           * end earlier. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["          fp->fd_len = bot - firstlnum + 1;", "          /* When the containing fold is open, the new fold is open.", "           * The new fold is closed if the fold above it is closed."], "readability/old_style_comment"]
["src/nvim/fold.c", ["            fp->fd_flags = topflags;", "            if (topflags != FD_LEVEL)", "              flp->wp->w_fold_manual = true;"], "readability/braces"]
["src/nvim/fold.c", ["              flp->wp->w_fold_manual = true;", "          } else", "            fp->fd_flags = (fp - 1)->fd_flags;"], "readability/braces"]
["src/nvim/fold.c", ["    if (lvl < level || flp->lnum > linecount) {", "      /*", "       * Found a line with a lower foldlevel, this fold ends just above"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "    /*", "     * The fold includes the line \"flp->lnum\" and \"flp->lnum_save\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "      /* Line numbers in the nested fold are relative to the start of", "       * this fold. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "      /* This fold may end at the same line, don't incr. flp->lnum. */", "    } else {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    } else {", "      /*", "       * Get the level of the next line, then continue the loop to check"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      while (!got_int) {", "        /* Make the previous level available to foldlevel(). */", "        prev_lnum = flp->lnum;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "        if (++flp->lnum > linecount)", "          break;"], "readability/braces"]
["src/nvim/fold.c", ["        getlevel(flp);", "        if (flp->lvl >= 0 || flp->had_end <= MAX_LEVEL)", "          break;"], "readability/braces"]
["src/nvim/fold.c", ["      prev_lnum = 0;", "      if (flp->lnum > linecount)", "        break;"], "readability/braces"]
["src/nvim/fold.c", ["", "      /* leave flp->lnum_save to lnum of the line that was used to get", "       * the level, flp->lnum to the lnum of the next line. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  if (fp == NULL)       /* only happens when got_int is set */", "    return bot;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  if (fp == NULL)       /* only happens when got_int is set */", "    return bot;"], "readability/braces"]
["src/nvim/fold.c", ["", "  /*", "   * Get here when:"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* delete following folds that end before the current line */", "  for (;; ) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    fp2 = fp + 1;", "    if (fp2 >= (fold_T *)gap->ga_data + gap->ga_len", "        || fp2->fd_top > flp->lnum)"], "readability/braces"]
["src/nvim/fold.c", ["", "  /* Need to redraw the lines we inspected, which might be further down than", "   * was asked for. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["   * was asked for. */", "  if (bot < flp->lnum - 1)", "    bot = flp->lnum - 1;"], "readability/braces"]
["src/nvim/fold.c", ["", "/* foldInsert() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldInsert() {{{2 */", "/*", " * Insert a new fold in \"gap\" at position \"i\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldSplit() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldSplit() {{{2 */", "/*", " * Split the \"i\"th fold in \"gap\", which starts before \"top\" and ends below"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* The fold continues below bot, need to split it. */", "  foldInsert(gap, i + 1);"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* Move nested folds below bot to new fold.  There can't be", "   * any between top and bot, they have been removed by the caller. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldRemove() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldRemove() {{{2 */", "/*", " * Remove folds within the range \"top\" to and including \"bot\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldMerge() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldMerge() {{{2 */", "/*", " * Merge two adjacent folds (and the nested ones in them)."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* If the last nested fold in fp1 touches the first nested fold in fp2,", "   * merge them recursively. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* Move nested folds in fp2 to the end of fp1. */", "  if (!GA_EMPTY(gap2)) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    ga_grow(gap1, gap2->ga_len);", "    for (idx = 0; idx < gap2->ga_len; ++idx) {", "      ((fold_T *)gap1->ga_data)[gap1->ga_len]"], "readability/increment"]
["src/nvim/fold.c", ["      ((fold_T *)gap1->ga_data)[gap1->ga_len].fd_top += fp1->fd_len;", "      ++gap1->ga_len;", "    }"], "readability/increment"]
["src/nvim/fold.c", ["", "/* foldlevelIndent() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldlevelIndent() {{{2 */", "/*", " * Low level function to get the foldlevel for the \"indent\" method."], "readability/old_style_comment"]
["src/nvim/fold.c", ["  buf = flp->wp->w_buffer;", "  s = skipwhite(ml_get_buf(buf, lnum, FALSE));", ""], "readability/bool"]
["src/nvim/fold.c", ["", "  /* empty line or lines starting with a character in 'foldignore': level", "   * depends on surrounding lines */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  if (*s == NUL || vim_strchr(flp->wp->w_p_fdi, *s) != NULL) {", "    /* first and last line can't be undefined, use level 0 */", "    if (lnum == 1 || lnum == buf->b_ml.ml_line_count)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    /* first and last line can't be undefined, use level 0 */", "    if (lnum == 1 || lnum == buf->b_ml.ml_line_count)", "      flp->lvl = 0;"], "readability/braces"]
["src/nvim/fold.c", ["      flp->lvl = 0;", "    else", "      flp->lvl = -1;"], "readability/braces"]
["src/nvim/fold.c", ["  if (flp->lvl > flp->wp->w_p_fdn) {", "    flp->lvl = (int) MAX(0, flp->wp->w_p_fdn);", "  }"], "whitespace/cast"]
["src/nvim/fold.c", ["", "/* foldlevelDiff() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldlevelDiff() {{{2 */", "/*", " * Low level function to get the foldlevel for the \"diff\" method."], "readability/old_style_comment"]
["src/nvim/fold.c", ["{", "  if (diff_infold(flp->wp, flp->lnum + flp->off))", "    flp->lvl = 1;"], "readability/braces"]
["src/nvim/fold.c", ["    flp->lvl = 1;", "  else", "    flp->lvl = 0;"], "readability/braces"]
["src/nvim/fold.c", ["", "/* foldlevelExpr() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldlevelExpr() {{{2 */", "/*", " * Low level function to get the foldlevel for the \"expr\" method."], "readability/old_style_comment"]
["src/nvim/fold.c", ["  curbuf = flp->wp->w_buffer;", "  set_vim_var_nr(VV_LNUM, (varnumber_T) lnum);", ""], "whitespace/cast"]
["src/nvim/fold.c", ["  flp->end = MAX_LEVEL + 1;", "  if (lnum <= 1)", "    flp->lvl = 0;"], "readability/braces"]
["src/nvim/fold.c", ["", "  /* KeyTyped may be reset to 0 when calling a function which invokes", "   * do_cmdline().  To make 'foldopen' work correctly restore KeyTyped. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  switch (c) {", "  /* \"a1\", \"a2\", .. : add to the fold level */", "  case 'a': if (flp->lvl >= 0) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* \"s1\", \"s2\", .. : subtract from the fold level */", "  case 's': if (flp->lvl >= 0) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  case 's': if (flp->lvl >= 0) {", "      if (n > flp->lvl)", "        flp->lvl_next = 0;"], "readability/braces"]
["src/nvim/fold.c", ["        flp->lvl_next = 0;", "      else", "        flp->lvl_next = flp->lvl - n;"], "readability/braces"]
["src/nvim/fold.c", ["", "  /* \">1\", \">2\", .. : start a fold with a certain level */", "  case '>': flp->lvl = n;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* \"<1\", \"<2\", .. : end a fold with a certain level */", "  case '<': flp->lvl_next = n - 1;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* \"=\": No change in level */", "  case '=': flp->lvl_next = flp->lvl;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* \"-1\", \"0\", \"1\", ..: set fold level */", "  default:  if (n < 0)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  default:  if (n < 0)", "      /* Use the current level for the next line, so that \"a1\"", "       * will work there. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      flp->lvl_next = flp->lvl;", "    else", "      flp->lvl_next = n;"], "readability/braces"]
["src/nvim/fold.c", ["", "  /* If the level is unknown for the first or the last line in the file, use", "   * level 0. */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    }", "    if (lnum == curbuf->b_ml.ml_line_count)", "      flp->lvl_next = 0;"], "readability/braces"]
["src/nvim/fold.c", ["", "/* parseMarker() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* parseMarker() {{{2 */", "/*", " * Parse 'foldmarker' and set \"foldendmarker\", \"foldstartmarkerlen\" and"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* foldlevelMarker() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldlevelMarker() {{{2 */", "/*", " * Low level function to get the foldlevel for the \"marker\" method."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* cache a few values for speed */", "  startmarker = flp->wp->w_p_fmr;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  cstart = *startmarker;", "  ++startmarker;", "  cend = *foldendmarker;"], "readability/increment"]
["src/nvim/fold.c", ["", "  /* Default: no start found, next level is same as current level */", "  flp->start = 0;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  s = ml_get_buf(flp->wp->w_buffer, flp->lnum + flp->off, FALSE);", "  while (*s) {"], "readability/bool"]
["src/nvim/fold.c", ["        && STRNCMP(s + 1, startmarker, foldstartmarkerlen - 1) == 0) {", "      /* found startmarker: set flp->lvl */", "      s += foldstartmarkerlen;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["          flp->lvl_next = n;", "          if (n <= start_lvl)", "            flp->start = 1;"], "readability/braces"]
["src/nvim/fold.c", ["            flp->start = 1;", "          else", "            flp->start = n - start_lvl;"], "readability/braces"]
["src/nvim/fold.c", ["      } else {", "        ++flp->lvl;", "        ++flp->lvl_next;"], "readability/increment"]
["src/nvim/fold.c", ["        ++flp->lvl;", "        ++flp->lvl_next;", "        ++flp->start;"], "readability/increment"]
["src/nvim/fold.c", ["        ++flp->lvl_next;", "        ++flp->start;", "      }"], "readability/increment"]
["src/nvim/fold.c", ["                                     foldendmarkerlen - 1) == 0) {", "      /* found endmarker: set flp->lvl_next */", "      s += foldendmarkerlen;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["          flp->lvl_next = n - 1;", "          /* never start a fold with an end marker */", "          if (flp->lvl_next > start_lvl)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["          /* never start a fold with an end marker */", "          if (flp->lvl_next > start_lvl)", "            flp->lvl_next = start_lvl;"], "readability/braces"]
["src/nvim/fold.c", ["", "  /* The level can't go negative, must be missing a start marker. */", "  if (flp->lvl_next < 0)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  /* The level can't go negative, must be missing a start marker. */", "  if (flp->lvl_next < 0)", "    flp->lvl_next = 0;"], "readability/braces"]
["src/nvim/fold.c", ["", "/* foldlevelSyntax() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* foldlevelSyntax() {{{2 */", "/*", " * Low level function to get the foldlevel for the \"syntax\" method."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* Use the maximum fold level at the start of this line and the next. */", "  flp->lvl = syn_get_foldlevel(flp->wp, lnum);"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    if (n > flp->lvl) {", "      flp->start = n - flp->lvl;        /* fold(s) start here */", "      flp->lvl = n;"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/* functions for storing the fold state in a View {{{1 */", "/* put_folds() {{{2 */"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* functions for storing the fold state in a View {{{1 */", "/* put_folds() {{{2 */", ""], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/*", " * Write commands to \"fd\" to restore the manual folds in window \"wp\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /* If some folds are manually opened/closed, need to restore that. */", "  if (wp->w_fold_manual)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  /* If some folds are manually opened/closed, need to restore that. */", "  if (wp->w_fold_manual)", "    return put_foldopen_recurse(fd, wp, &wp->w_folds, (linenr_T)0);"], "readability/braces"]
["src/nvim/fold.c", ["", "/* put_folds_recurse() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* put_folds_recurse() {{{2 */", "/*", " * Write commands to \"fd\" to recreate manually created folds."], "readability/old_style_comment"]
["src/nvim/fold.c", ["  for (int i = 0; i < gap->ga_len; i++) {", "    /* Do nested folds first, they will be created closed. */", "    if (put_folds_recurse(fd, &fp->fd_nested, off + fp->fd_top) == FAIL)"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    /* Do nested folds first, they will be created closed. */", "    if (put_folds_recurse(fd, &fp->fd_nested, off + fp->fd_top) == FAIL)", "      return FAIL;"], "readability/braces"]
["src/nvim/fold.c", ["      return FAIL;", "    if (fprintf(fd, \"%\" PRId64 \",%\" PRId64 \"fold\",", "                (int64_t)(fp->fd_top + off),"], "readability/braces"]
["src/nvim/fold.c", ["      return FAIL;", "    ++fp;", "  }"], "readability/increment"]
["src/nvim/fold.c", ["", "/* put_foldopen_recurse() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* put_foldopen_recurse() {{{2 */", "/*", " * Write commands to \"fd\" to open and close manually opened/closed folds."], "readability/old_style_comment"]
["src/nvim/fold.c", [" */", "static int put_foldopen_recurse(FILE *fd, win_T *wp, garray_T *gap, linenr_T off)", "{"], "whitespace/line_length"]
["src/nvim/fold.c", ["      if (!GA_EMPTY(&fp->fd_nested)) {", "        /* open nested folds while this fold is open */", "        if (fprintf(fd, \"%\" PRId64, (int64_t)(fp->fd_top + off)) < 0"], "readability/old_style_comment"]
["src/nvim/fold.c", ["        /* open nested folds while this fold is open */", "        if (fprintf(fd, \"%\" PRId64, (int64_t)(fp->fd_top + off)) < 0", "            || put_eol(fd) == FAIL"], "readability/braces"]
["src/nvim/fold.c", ["          return FAIL;", "        if (put_foldopen_recurse(fd, wp, &fp->fd_nested,", "                off + fp->fd_top)"], "readability/braces"]
["src/nvim/fold.c", ["        if (put_foldopen_recurse(fd, wp, &fp->fd_nested,", "                off + fp->fd_top)", "            == FAIL)"], "whitespace/alignment"]
["src/nvim/fold.c", ["          return FAIL;", "        /* close the parent when needed */", "        if (fp->fd_flags == FD_CLOSED) {"], "readability/old_style_comment"]
["src/nvim/fold.c", ["        if (fp->fd_flags == FD_CLOSED) {", "          if (put_fold_open_close(fd, fp, off) == FAIL)", "            return FAIL;"], "readability/braces"]
["src/nvim/fold.c", ["      } else {", "        /* Open or close the leaf according to the window foldlevel.", "         * Do not close a leaf that is already closed, as it will close"], "readability/old_style_comment"]
["src/nvim/fold.c", ["        level = foldLevelWin(wp, off + fp->fd_top);", "        if ((fp->fd_flags == FD_CLOSED && wp->w_p_fdl >= level)", "            || (fp->fd_flags != FD_CLOSED && wp->w_p_fdl < level))"], "readability/braces"]
["src/nvim/fold.c", ["            || (fp->fd_flags != FD_CLOSED && wp->w_p_fdl < level))", "          if (put_fold_open_close(fd, fp, off) == FAIL)", "            return FAIL;"], "readability/braces"]
["src/nvim/fold.c", ["    }", "    ++fp;", "  }"], "readability/increment"]
["src/nvim/fold.c", ["", "/* put_fold_open_close() {{{2 */", "/*"], "readability/old_style_comment"]
["src/nvim/fold.c", ["/* put_fold_open_close() {{{2 */", "/*", " * Write the open or close command to \"fd\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["{", "  if (fprintf(fd, \"%\" PRId64, (int64_t)(fp->fd_top + off)) < 0", "      || put_eol(fd) == FAIL"], "readability/braces"]
["src/nvim/fold.c", ["      || fprintf(fd, \"normal! z%c\",", "          fp->fd_flags == FD_CLOSED ? 'c' : 'o') < 0", "      || put_eol(fd) == FAIL)"], "whitespace/alignment"]
["src/nvim/fold.c", ["      || fprintf(fd, \"normal! z%c\",", "          fp->fd_flags == FD_CLOSED ? 'c' : 'o') < 0", "      || put_eol(fd) == FAIL)"], "whitespace/alignment"]
["src/nvim/fold.c", ["", "/* }}}1 */", ""], "readability/old_style_comment"]
