["src/nvim/ex_cmds.c", ["", "/*", " * ex_cmds.c: some functions for command line commands"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":left\", \":center\" and \":right\": align text."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (curwin->w_p_rl) {", "    /* switch left and right aligning */", "    if (eap->cmdidx == CMD_right)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    /* switch left and right aligning */", "    if (eap->cmdidx == CMD_right)", "      eap->cmdidx = CMD_left;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      eap->cmdidx = CMD_left;", "    else if (eap->cmdidx == CMD_left)", "      eap->cmdidx = CMD_right;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  save_curpos = curwin->w_cursor;", "  if (eap->cmdidx == CMD_left) {    /* width is used for new indent */", "    if (width >= 0)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (eap->cmdidx == CMD_left) {    /* width is used for new indent */", "    if (width >= 0)", "      indent = width;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  } else {", "    /*", "     * if 'textwidth' set, use it"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["     */", "    if (width <= 0)", "      width = curbuf->b_p_tw;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  if (u_save((linenr_T)(eap->line1 - 1), (linenr_T)(eap->line2 + 1)) == FAIL)", "    return;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  for (curwin->w_cursor.lnum = eap->line1;", "       curwin->w_cursor.lnum <= eap->line2; ++curwin->w_cursor.lnum) {", "    if (eap->cmdidx == CMD_left)                /* left align */"], "readability/increment"]
["src/nvim/ex_cmds.c", ["       curwin->w_cursor.lnum <= eap->line2; ++curwin->w_cursor.lnum) {", "    if (eap->cmdidx == CMD_left)                /* left align */", "      new_indent = indent;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["       curwin->w_cursor.lnum <= eap->line2; ++curwin->w_cursor.lnum) {", "    if (eap->cmdidx == CMD_left)                /* left align */", "      new_indent = indent;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      new_indent = indent;", "    else {", "      has_tab = FALSE;          /* avoid uninit warnings */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      new_indent = indent;", "    else {", "      has_tab = FALSE;          /* avoid uninit warnings */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    else {", "      has_tab = FALSE;          /* avoid uninit warnings */", "      len = linelen(eap->cmdidx == CMD_right ? &has_tab"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    else {", "      has_tab = FALSE;          /* avoid uninit warnings */", "      len = linelen(eap->cmdidx == CMD_right ? &has_tab"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      len = linelen(eap->cmdidx == CMD_right ? &has_tab", "          : NULL) - get_indent();", ""], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["", "      if (len <= 0)                             /* skip blank lines */", "        continue;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "      if (len <= 0)                             /* skip blank lines */", "        continue;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "      if (eap->cmdidx == CMD_center)", "        new_indent = (width - len) / 2;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["        new_indent = (width - len) / 2;", "      else {", "        new_indent = width - len;               /* right align */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["        new_indent = (width - len) / 2;", "      else {", "        new_indent = width - len;               /* right align */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      else {", "        new_indent = width - len;               /* right align */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "        /*", "         * Make sure that embedded TABs don't make the text go too far"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["         */", "        if (has_tab)", "          while (new_indent > 0) {"], "readability/braces"]
["src/nvim/ex_cmds.c", ["            if (linelen(NULL) <= width) {", "              /*", "               * Now try to move the line as much as possible to"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["                (void)set_indent(++new_indent, 0);", "              while (linelen(NULL) <= width);", "              --new_indent;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["                (void)set_indent(++new_indent, 0);", "              while (linelen(NULL) <= width);", "              --new_indent;"], "whitespace/empty_loop_body"]
["src/nvim/ex_cmds.c", ["              while (linelen(NULL) <= width);", "              --new_indent;", "              break;"], "readability/increment"]
["src/nvim/ex_cmds.c", ["            }", "            --new_indent;", "          }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    }", "    if (new_indent < 0)", "      new_indent = 0;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      new_indent = 0;", "    (void)set_indent(new_indent, 0);                    /* set indent */", "  }"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * Get the length of the current line, excluding trailing white space."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/* Buffer for two lines used during sorting.  They are allocated to", " * contain the longest line being sorted. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /* If the user interrupts, there's no way to stop qsort() immediately, but", "   * if we return 0 every time, qsort will assume it's done sorting and"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["   * exit. */", "  if (sort_abort)", "    return 0;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  fast_breakcheck();", "  if (got_int)", "    sort_abort = TRUE;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (got_int)", "    sort_abort = TRUE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /* If two lines have the same value, preserve the original line order. */", "  if (result == 0)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  /* If two lines have the same value, preserve the original line order. */", "  if (result == 0)", "    return (int)(l1.lnum - l2.lnum);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  for (p = eap->arg; *p != NUL; ++p) {", "    if (ascii_iswhite(*p)) {"], "readability/increment"]
["src/nvim/ex_cmds.c", ["  // Also get the longest line length for allocating \"sortbuf\".", "  for (lnum = eap->line1; lnum <= eap->line2; ++lnum) {", "    s = ml_get(lnum);"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "    if (regmatch.regprog != NULL)", "      fast_breakcheck();"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      fast_breakcheck();", "    if (got_int)", "      goto sortend;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  if (sort_abort)", "    goto sortend;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    fast_breakcheck();", "    if (got_int)", "      goto sortend;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (i == count) {", "    for (i = 0; i < count; ++i) {", "      ml_delete(eap->line1, false);"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":retab\"."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  linenr_T lnum;", "  int got_tab = FALSE;", "  long num_spaces = 0;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  int save_list;", "  linenr_T first_line = 0;              /* first changed line */", "  linenr_T last_line = 0;               /* last changed line */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  linenr_T first_line = 0;              /* first changed line */", "  linenr_T last_line = 0;               /* last changed line */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  save_list = curwin->w_p_list;", "  curwin->w_p_list = 0;             /* don't want list mode here */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    vcol = 0;", "    did_undo = FALSE;", "    for (;; ) {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        if (!got_tab && num_spaces == 0) {", "          /* First consecutive white-space */", "          start_vcol = vcol;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        }", "        if (ptr[col] == ' ')", "          num_spaces++;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["          num_spaces++;", "        else", "          got_tab = TRUE;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["        else", "          got_tab = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        if (got_tab || (eap->forceit && num_spaces > 1)) {", "          /* Retabulate this string of white-space */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "          /* len is virtual length of white string */", "          len = num_spaces = vcol - start_vcol;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "            /* len is actual number of white characters used */", "            len = num_spaces + num_tabs;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "            if (start_col > 0)", "              memmove(new_line, ptr, (size_t)start_col);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["            memmove(new_line + start_col + len,", "                ptr + col, (size_t)(old_len - col + 1));", "            ptr = new_line + start_col;"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["        }", "        got_tab = FALSE;", "        num_spaces = 0;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      }", "      if (ptr[col] == NUL)", "        break;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    }", "    if (new_line == NULL)                   /* out of memory */", "      break;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    }", "    if (new_line == NULL)                   /* out of memory */", "      break;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  }", "  if (got_int)", "    EMSG(_(e_interr));"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  curwin->w_p_list = save_list;         /* restore 'list' */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * :move command - move lines line1-line2 to line dest"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * First we copy the old text to its new location -- webb"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["   */", "  if (u_save(dest, dest + 1) == FAIL)", "    return FAIL;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    xfree(str);", "    if (dest < line1)", "      extra++;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Now we must be careful adjusting our marks so that we don't overlap our"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Now we delete the original text -- webb"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["   */", "  if (u_save(line1 + extra - 1, line2 + extra + 1) == FAIL)", "    return FAIL;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (!global_busy && num_lines > p_report) {", "    if (num_lines == 1)", "      MSG(_(\"1 line moved\"));"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      MSG(_(\"1 line moved\"));", "    else", "      smsg(_(\"%\" PRId64 \" lines moved\"), (int64_t)num_lines);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Leave the cursor on the last of the moved lines."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["   */", "  if (dest >= line1)", "    curwin->w_cursor.lnum = dest;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    curwin->w_cursor.lnum = dest;", "  else", "    curwin->w_cursor.lnum = dest + (line2 - line1) + 1;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    last_line = curbuf->b_ml.ml_line_count;", "    if (dest > last_line + 1)", "      dest = last_line + 1;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":copy\""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * there are three situations:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["   */", "  if (u_save(n, n + 1) == FAIL)", "    return;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  while (line1 <= line2) {", "    /* need to use vim_strsave() because the line will be unlocked within", "     * ml_append() */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "    /* situation 2: skip already copied lines */", "    if (line1 == n)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    /* situation 2: skip already copied lines */", "    if (line1 == n)", "      line1 = curwin->w_cursor.lnum;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      line1 = curwin->w_cursor.lnum;", "    ++line1;", "    if (curwin->w_cursor.lnum < line1)"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    ++line1;", "    if (curwin->w_cursor.lnum < line1)", "      ++line1;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (curwin->w_cursor.lnum < line1)", "      ++line1;", "    if (curwin->w_cursor.lnum < line2)"], "readability/increment"]
["src/nvim/ex_cmds.c", ["      ++line1;", "    if (curwin->w_cursor.lnum < line2)", "      ++line2;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (curwin->w_cursor.lnum < line2)", "      ++line2;", "    ++curwin->w_cursor.lnum;"], "readability/increment"]
["src/nvim/ex_cmds.c", ["      ++line2;", "    ++curwin->w_cursor.lnum;", "  }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "static char_u   *prevcmd = NULL;        /* the previous command */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * Handle the \":!cmd\" command.\tAlso for \":r !cmd\" and \":w !cmd\""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  if (addr_count == 0) {                /* :! */", "    msg_scroll = FALSE;             /* don't scroll here */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (addr_count == 0) {                /* :! */", "    msg_scroll = FALSE;             /* don't scroll here */", "    autowrite_all();"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (addr_count == 0) {                /* :! */", "    msg_scroll = FALSE;             /* don't scroll here */", "    autowrite_all();"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Try to find an embedded bang, like in :!<cmd> ! [args]"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    len = (int)STRLEN(trailarg) + 1;", "    if (newcmd != NULL)", "      len += (int)STRLEN(newcmd);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    *t = NUL;", "    if (newcmd != NULL)", "      STRCAT(t, newcmd);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      STRCAT(t, newcmd);", "    if (ins_prevcmd)", "      STRCAT(t, prevcmd);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "    /*", "     * Scan the rest of the argument for '!', which is replaced by the"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      if (*p == '!') {", "        if (p > newcmd && p[-1] == '\\\\')", "          STRMOVE(p - 1, p);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["          STRMOVE(p - 1, p);", "        else {", "          trailarg = p;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["          STRMOVE(p - 1, p);", "        else {", "          trailarg = p;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      }", "      ++p;", "    }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "  if (bangredo) { /* put cmd in redo buffer for ! command */", "    /* If % or # appears in the command, it must have been escaped."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (bangredo) { /* put cmd in redo buffer for ! command */", "    /* If % or # appears in the command, it must have been escaped.", "     * Reescape them, so that redoing them does not substitute them by the"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  }", "  /*", "   * Add quotes around the command, for shells that need them."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  }", "  if (addr_count == 0) {                /* :! */", "    /* echo the command */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (addr_count == 0) {                /* :! */", "    /* echo the command */", "    msg_start();"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    do_shell(newcmd, 0);", "  } else {                            /* :range! */", "    /* Careful: This may recursively call do_bang() again! (because of"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  } else {                            /* :range! */", "    /* Careful: This may recursively call do_bang() again! (because of", "     * autocommands) */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    do_filter(line1, line2, eap, newcmd, do_in, do_out);", "    apply_autocmds(EVENT_SHELLFILTERPOST, NULL, NULL, FALSE, curbuf);", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  }", "  if (free_newcmd)", "    xfree(newcmd);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    linenr_T line2,", "    exarg_T *eap,               /* for forced 'ff' and 'fenc' */", "    char_u *cmd,"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  if (*cmd == NUL)          /* no filter command */", "    return;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  if (*cmd == NUL)          /* no filter command */", "    return;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * When using temp files:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  if (do_out)", "    shell_flags |= kShellOptDoOut;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  } else if ((do_in && (itmp = vim_tempname()) == NULL)", "      || (do_out && (otmp = vim_tempname()) == NULL)) {", "    EMSG(_(e_notmp));"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * The writing and reading of temp files will not be shown."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["   */", "  ++no_wait_return;             /* don't call wait_return() while busy */", "  if (itmp != NULL && buf_write(curbuf, itmp, NULL, line1, line2, eap,"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["   */", "  ++no_wait_return;             /* don't call wait_return() while busy */", "  if (itmp != NULL && buf_write(curbuf, itmp, NULL, line1, line2, eap,"], "readability/increment"]
["src/nvim/ex_cmds.c", ["  }", "  if (curbuf != old_curbuf)", "    goto filterend;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  if (!do_out)", "    msg_putchar('\\n');"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /* Create the shell command in allocated memory. */", "  cmd_buf = make_filter_cmd(cmd, itmp, otmp);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  did_check_timestamps = FALSE;", "  need_check_timestamps = TRUE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  did_check_timestamps = FALSE;", "  need_check_timestamps = TRUE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /* When interrupting the shell command, it may still have produced some", "   * useful output.  Reset got_int here, so that readfile() won't cancel"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  os_breakcheck();", "  got_int = FALSE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["      }", "      if (curbuf != old_curbuf)", "        goto filterend;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "      /*", "       * Put cursor on first filtered line for \":range!cmd\"."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      curwin->w_cursor.lnum = line1;", "      del_lines(linecount, TRUE);", "      curbuf->b_op_start.lnum -= linecount;             /* adjust '[ */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      del_lines(linecount, TRUE);", "      curbuf->b_op_start.lnum -= linecount;             /* adjust '[ */", "      curbuf->b_op_end.lnum -= linecount;               /* adjust '] */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      curbuf->b_op_start.lnum -= linecount;             /* adjust '[ */", "      curbuf->b_op_end.lnum -= linecount;               /* adjust '] */", "      write_lnum_adjust(-linecount);                    /* adjust last line"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      curbuf->b_op_end.lnum -= linecount;               /* adjust '] */", "      write_lnum_adjust(-linecount);                    /* adjust last line", "                                                           for next write */"], "readability/multiline_comment"]
["src/nvim/ex_cmds.c", ["      curbuf->b_op_end.lnum -= linecount;               /* adjust '] */", "      write_lnum_adjust(-linecount);                    /* adjust last line", "                                                           for next write */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    } else {", "      /*", "       * Put cursor on last new line for \":r !cmd\"."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "    beginline(BL_WHITE | BL_FIX);           /* cursor on first non-blank */", "    --no_wait_return;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    beginline(BL_WHITE | BL_FIX);           /* cursor on first non-blank */", "    --no_wait_return;", ""], "readability/increment"]
["src/nvim/ex_cmds.c", ["        vim_snprintf((char *)msg_buf, sizeof(msg_buf),", "            _(\"%\" PRId64 \" lines filtered\"), (int64_t)linecount);", "        if (msg(msg_buf) && !msg_scroll)"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["            _(\"%\" PRId64 \" lines filtered\"), (int64_t)linecount);", "        if (msg(msg_buf) && !msg_scroll)", "          /* save message to display it after redraw */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["        if (msg(msg_buf) && !msg_scroll)", "          /* save message to display it after redraw */", "          set_keep_msg(msg_buf, 0);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          set_keep_msg(msg_buf, 0);", "      } else", "        msgmore((long)linecount);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["error:", "    /* put cursor back in same position for \":w !cmd\" */", "    curwin->w_cursor = cursor_save;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    curwin->w_cursor = cursor_save;", "    --no_wait_return;", "    wait_return(FALSE);"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    --no_wait_return;", "    wait_return(FALSE);", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  if (curbuf != old_curbuf) {", "    --no_wait_return;", "    EMSG(_(\"E135: *Filter* Autocommands must not change current buffer\"));"], "readability/increment"]
["src/nvim/ex_cmds.c", ["  }", "  if (itmp != NULL)", "    os_remove((char *)itmp);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    os_remove((char *)itmp);", "  if (otmp != NULL)", "    os_remove((char *)otmp);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * For autocommands we want to get the output on the current screen, to"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  // This ui_cursor_goto is required for when the '\\n' resulted in a \"delete line", "  // 1\" command to the terminal."], "whitespace/line_length"]
["src/nvim/ex_cmds.c", ["", "  apply_autocmds(EVENT_SHELLCMDPOST, NULL, NULL, FALSE, curbuf);", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  if (otmp != NULL) {", "    append_redir(buf, len, (char *) p_srr, (char *) otmp);", "  }"], "whitespace/cast"]
["src/nvim/ex_cmds.c", ["  }", "  return (char_u *) buf;", "}"], "whitespace/cast"]
["src/nvim/ex_cmds.c", ["    *end = ' ';  // not really needed? Not with sh, ksh or bash", "    vim_snprintf(end + 1, (size_t) (buflen - (end + 1 - buf)), opt, fname);", "  } else {"], "whitespace/cast"]
["src/nvim/ex_cmds.c", ["  } else {", "    vim_snprintf(end, (size_t) (buflen - (end - buf)), \" %s %s\", opt, fname);", "  }"], "whitespace/cast"]
["src/nvim/ex_cmds.c", ["", "/*", " * Print a text line.  Also in silent mode (\"ex -s\")."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  msg_start();", "  silent_mode = FALSE;", "  info_message = TRUE;          /* use mch_msg(), not mch_errmsg() */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  silent_mode = FALSE;", "  info_message = TRUE;          /* use mch_msg(), not mch_errmsg() */", "  print_line_no_prefix(lnum, use_number, list);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  silent_mode = FALSE;", "  info_message = TRUE;          /* use mch_msg(), not mch_errmsg() */", "  print_line_no_prefix(lnum, use_number, list);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  }", "  info_message = FALSE;", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  buf = curbuf;", "  apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);", "  /* buffer changed, don't change name now */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);", "  /* buffer changed, don't change name now */", "  if (buf != curbuf)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  /* buffer changed, don't change name now */", "  if (buf != curbuf)", "    return FAIL;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    return FAIL;", "  if (aborting())           /* autocmds may abort script processing */", "    return FAIL;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    return FAIL;", "  if (aborting())           /* autocmds may abort script processing */", "    return FAIL;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    return FAIL;", "  /*", "   * The name of the current buffer will be changed."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  xfree(sfname);", "  apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);", "  /* Change directories when the 'acd' option is set. */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);", "  /* Change directories when the 'acd' option is set. */", "  do_autochdir();"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":file[!] [fname]\"."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["{", "  /* \":0file\" removes the file name.  Check for illegal uses \":3file\",", "   * \"0file name\", etc. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":update\"."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["{", "  if (curbufIsChanged())", "    (void)do_write(eap);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":write\" and \":saveas\"."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * write current buffer to file 'eap->arg'"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  int other;", "  char_u      *fname = NULL;            /* init to shut up gcc */", "  char_u      *ffname;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  if (not_writing())            /* check 'write' option */", "    return FAIL;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  if (not_writing())            /* check 'write' option */", "    return FAIL;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    }", "    other = FALSE;", "  } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    free_fname = (char_u *)fix_fname((char *)ffname);", "    /*", "     * When out-of-memory, keep unexpanded file name, because we MUST be"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["     */", "    if (free_fname != NULL)", "      ffname = free_fname;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * If we have a new file, put its name in the list of alternate file names."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (other) {", "    if (vim_strchr(p_cpo, CPO_ALTWRITE) != NULL", "        || eap->cmdidx == CMD_saveas)"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      alt_buf = setaltfname(ffname, fname, (linenr_T)1);", "    else", "      alt_buf = buflist_findname(ffname);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (alt_buf != NULL && alt_buf->b_ml.ml_mfp != NULL) {", "      /* Overwriting a file that is loaded in another buffer is not a", "       * good idea. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    fname = curbuf->b_fname;", "    /*", "     * Not writing the whole file is only allowed with '!'."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["                || eap->line2 != curbuf->b_ml.ml_line_count)", "               && !eap->forceit", "               && !eap->append"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["               && !eap->forceit", "               && !eap->append", "               && !p_wa) {"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["               && !eap->append", "               && !p_wa) {", "      if (p_confirm || cmdmod.confirm) {"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["      if (p_confirm || cmdmod.confirm) {", "        if (vim_dialog_yesno(VIM_QUESTION, NULL,", "                (char_u *)_(\"Write partial file?\"), 2) != VIM_YES)"], "readability/braces"]
["src/nvim/ex_cmds.c", ["        if (vim_dialog_yesno(VIM_QUESTION, NULL,", "                (char_u *)_(\"Write partial file?\"), 2) != VIM_YES)", "          goto theend;"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["          goto theend;", "        eap->forceit = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "      apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);", "      apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, alt_buf);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);", "      apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, alt_buf);", "      if (curbuf != was_curbuf || aborting()) {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      if (curbuf != was_curbuf || aborting()) {", "        /* buffer changed, don't change name now */", "        retval = FAIL;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      }", "      /* Exchange the file names for the current and the alternate", "       * buffer.  This makes it look like we are now editing the buffer"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      buf_name_changed(curbuf);", "      apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);", "      apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, alt_buf);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);", "      apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, alt_buf);", "      if (!alt_buf->b_p_bl) {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      if (!alt_buf->b_p_bl) {", "        alt_buf->b_p_bl = TRUE;", "        apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, alt_buf);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        alt_buf->b_p_bl = TRUE;", "        apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, alt_buf);", "      }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      if (curbuf != was_curbuf || aborting()) {", "        /* buffer changed, don't write the file */", "        retval = FAIL;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "      /* Autocommands may have changed buffer names, esp. when", "       * 'autochdir' is set. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    retval = buf_write(curbuf, ffname, fname, eap->line1, eap->line2,", "        eap, eap->append, eap->forceit, TRUE, FALSE);", ""], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["    retval = buf_write(curbuf, ffname, fname, eap->line1, eap->line2,", "        eap, eap->append, eap->forceit, TRUE, FALSE);", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "    /* After \":saveas fname\" reset 'readonly'. */", "    if (eap->cmdidx == CMD_saveas) {"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      if (retval == OK) {", "        curbuf->b_p_ro = FALSE;", "        redraw_tabline = TRUE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        curbuf->b_p_ro = FALSE;", "        redraw_tabline = TRUE;", "      }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "/*", " * Check if it is allowed to overwrite a file.  If b_flags has BF_NOTEDITED,"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["{", "  /*", "   * write to other file or b_flags set or not writing the whole file:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        dialog_msg(buff, _(\"Overwrite existing file \\\"%s\\\"?\"), fname);", "        if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) != VIM_YES)", "          return FAIL;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["          return FAIL;", "        eap->forceit = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "    /* For \":w! filename\" check that no swap file exists for \"filename\". */", "    if (other && !emsg_silent) {"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "      /* We only try the first entry in 'directory', without checking if", "       * it's writable.  If the \".\" directory is not writable the write"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          dialog_msg(buff,", "              _(\"Swap file \\\"%s\\\" exists, overwrite anyway?\"),", "              swapname);"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["              _(\"Swap file \\\"%s\\\" exists, overwrite anyway?\"),", "              swapname);", "          if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2)"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["          }", "          eap->forceit = TRUE;", "        } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["          EMSG2(_(\"E768: Swap file exists: %s (:silent! overrides)\"),", "              swapname);", "          xfree(swapname);"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["", "/*", " * Handle \":wnext\", \":wNext\" and \":wprevious\" commands."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  if (eap->cmd[1] == 'n')", "    i = curwin->w_arg_idx + (int)eap->line2;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    i = curwin->w_arg_idx + (int)eap->line2;", "  else", "    i = curwin->w_arg_idx - (int)eap->line2;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  eap->line2 = curbuf->b_ml.ml_line_count;", "  if (do_write(eap) != FAIL)", "    do_argfile(eap, i);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":wall\", \":wqall\" and \":xall\": Write all changed files (and exit)."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    }", "    /*", "     * Check if there is a reason the buffer cannot be written:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    if (not_writing()) {", "      ++error;", "      break;"], "readability/increment"]
["src/nvim/ex_cmds.c", ["      EMSGN(_(\"E141: No file name for buffer %\" PRId64), buf->b_fnum);", "      ++error;", "    } else if (check_readonly(&eap->forceit, buf)"], "readability/increment"]
["src/nvim/ex_cmds.c", ["               || check_overwrite(eap, buf, buf->b_fname, buf->b_ffname,", "                   FALSE) == FAIL) {", "      ++error;"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["               || check_overwrite(eap, buf, buf->b_fname, buf->b_ffname,", "                   FALSE) == FAIL) {", "      ++error;"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["               || check_overwrite(eap, buf, buf->b_fname, buf->b_ffname,", "                   FALSE) == FAIL) {", "      ++error;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["                   FALSE) == FAIL) {", "      ++error;", "    } else {"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    }", "    eap->forceit = save_forceit;          /* check_overwrite() may set it */", "  }"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (exiting) {", "    if (!error)", "      getout(0);                /* exit Vim */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (!error)", "      getout(0);                /* exit Vim */", "    not_exiting();"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * Check the 'write' option."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["{", "  if (p_write)", "    return FALSE;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (p_write)", "    return FALSE;", "  EMSG(_(\"E142: File not written: Writing is disabled by 'write' option\"));"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  EMSG(_(\"E142: File not written: Writing is disabled by 'write' option\"));", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "/*", " * Check if a buffer is read-only (either 'readonly' option is set or file is"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["{", "  /* Handle a file being readonly when the 'readonly' option is set or when", "   * the file exists and permissions are read-only. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "      if (buf->b_p_ro)", "        dialog_msg(buff,"], "readability/braces"]
["src/nvim/ex_cmds.c", ["        dialog_msg(buff,", "            _(", "                \"'readonly' option is set for \\\"%s\\\".\\nDo you wish to write anyway?\"),"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                \"'readonly' option is set for \\\"%s\\\".\\nDo you wish to write anyway?\"),", "            buf->b_fname);", "      else"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["            _(", "                \"'readonly' option is set for \\\"%s\\\".\\nDo you wish to write anyway?\"),", "            buf->b_fname);"], "whitespace/line_length"]
["src/nvim/ex_cmds.c", ["            buf->b_fname);", "      else", "        dialog_msg(buff,"], "readability/braces"]
["src/nvim/ex_cmds.c", ["        dialog_msg(buff,", "            _(", "                \"File permissions of \\\"%s\\\" are read-only.\\nIt may still be possible to write it.\\nDo you wish to try?\"),"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                \"File permissions of \\\"%s\\\" are read-only.\\nIt may still be possible to write it.\\nDo you wish to try?\"),", "            buf->b_fname);", ""], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["            _(", "                \"File permissions of \\\"%s\\\" are read-only.\\nIt may still be possible to write it.\\nDo you wish to try?\"),", "            buf->b_fname);"], "whitespace/line_length"]
["src/nvim/ex_cmds.c", ["      if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) == VIM_YES) {", "        /* Set forceit, to force the writing of a readonly file */", "        *forceit = TRUE;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        /* Set forceit, to force the writing of a readonly file */", "        *forceit = TRUE;", "        return FALSE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        *forceit = TRUE;", "        return FALSE;", "      } else"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        return FALSE;", "      } else", "        return TRUE;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      } else", "        return TRUE;", "    } else if (buf->b_p_ro)"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        return TRUE;", "    } else if (buf->b_p_ro)", "      EMSG(_(e_readonly));"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      EMSG(_(e_readonly));", "    else", "      EMSG2(_(\"E505: \\\"%s\\\" is read-only (add ! to override)\"),"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      EMSG2(_(\"E505: \\\"%s\\\" is read-only (add ! to override)\"),", "          buf->b_fname);", "    return TRUE;"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["          buf->b_fname);", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  if (fnum == 0) {", "    /* make ffname full path, set sfname */", "    fname_expand(curbuf, &ffname, &sfname);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    other = otherfile(ffname);", "    free_me = ffname;                   /* has been allocated, free() later */", "  } else"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    free_me = ffname;                   /* has been allocated, free() later */", "  } else", "    other = (fnum != curbuf->b_fnum);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  }", "  if (other)", "    --no_wait_return;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (other)", "    --no_wait_return;", "  if (setpm)"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    --no_wait_return;", "  if (setpm)", "    setpcmark();"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    char_u *sfname,", "    exarg_T *eap,                       /* can be NULL! */", "    linenr_T newlnum,"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["{", "  int other_file;                       /* TRUE if editing another file */", "  int oldbuf;                           /* TRUE if using existing buffer */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  int other_file;                       /* TRUE if editing another file */", "  int oldbuf;                           /* TRUE if using existing buffer */", "  int auto_buf = FALSE;                 /* TRUE if autocommands brought us"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  int oldbuf;                           /* TRUE if using existing buffer */", "  int auto_buf = FALSE;                 /* TRUE if autocommands brought us", "                                           into the buffer unexpectedly */"], "readability/multiline_comment"]
["src/nvim/ex_cmds.c", ["  int oldbuf;                           /* TRUE if using existing buffer */", "  int auto_buf = FALSE;                 /* TRUE if autocommands brought us", "                                           into the buffer unexpectedly */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  int oldbuf;                           /* TRUE if using existing buffer */", "  int auto_buf = FALSE;                 /* TRUE if autocommands brought us", "                                           into the buffer unexpectedly */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  char_u      *new_name = NULL;", "  int did_set_swapcommand = FALSE;", "  buf_T       *buf;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  char_u      *command = NULL;", "  int did_get_winopts = FALSE;", "  int readfile_flags = 0;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  if (eap != NULL)", "    command = eap->do_ecmd_cmd;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (fnum != 0) {", "    if (fnum == curbuf->b_fnum)         /* file is already being edited */", "      return OK;                        /* nothing to do */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (fnum != 0) {", "    if (fnum == curbuf->b_fnum)         /* file is already being edited */", "      return OK;                        /* nothing to do */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (fnum == curbuf->b_fnum)         /* file is already being edited */", "      return OK;                        /* nothing to do */", "    other_file = TRUE;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      return OK;                        /* nothing to do */", "    other_file = TRUE;", "  } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  } else {", "    /* if no short name given, use ffname for short name */", "    if (sfname == NULL)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    /* if no short name given, use ffname for short name */", "    if (sfname == NULL)", "      sfname = ffname;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["#ifdef USE_FNAME_CASE", "    if (sfname != NULL)", "      path_fix_case(sfname);             // set correct case for sfname"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "    if (ffname == NULL)", "      other_file = TRUE;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (ffname == NULL)", "      other_file = TRUE;", "    /* there is no file name */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      other_file = TRUE;", "    /* there is no file name */", "    else if (*ffname == NUL && curbuf->b_ffname == NULL)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    /* there is no file name */", "    else if (*ffname == NUL && curbuf->b_ffname == NULL)", "      other_file = FALSE;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    else if (*ffname == NUL && curbuf->b_ffname == NULL)", "      other_file = FALSE;", "    else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      other_file = FALSE;", "    else {", "      if (*ffname == NUL) {                 /* re-edit with same file name */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      other_file = FALSE;", "    else {", "      if (*ffname == NUL) {                 /* re-edit with same file name */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    else {", "      if (*ffname == NUL) {                 /* re-edit with same file name */", "        ffname = curbuf->b_ffname;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      }", "      free_fname = (char_u *)fix_fname((char *)ffname);       /* may expand to full path name */", "      if (free_fname != NULL)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      }", "      free_fname = (char_u *)fix_fname((char *)ffname);       /* may expand to full path name */", "      if (free_fname != NULL)"], "whitespace/line_length"]
["src/nvim/ex_cmds.c", ["      free_fname = (char_u *)fix_fname((char *)ffname);       /* may expand to full path name */", "      if (free_fname != NULL)", "        ffname = free_fname;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * End Visual mode before switching to another buffer, so the text can be"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    set_vim_var_string(VV_SWAPCOMMAND, p, -1);", "    did_set_swapcommand = TRUE;", "    xfree(p);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * If we are starting to edit another file, open a (new) buffer."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          tlnum = atol((char *)command);", "          if (tlnum <= 0)", "            tlnum = 1L;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    }", "    if (buf == NULL)", "      goto theend;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "    /* May jump to last used line number for a loaded buffer or when asked", "     * for explicitly */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "    /*", "     * Make the (new) buffer the one used by the current window."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    if (buf != curbuf) {", "      /*", "       * Be careful: The autocommands may delete any buffer and change"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      }", "      if (aborting()) {             /* autocmds may abort script processing */", "        xfree(new_name);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          curbuf = buf;", "          ++curbuf->b_nwindows;", ""], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "          /* Set 'fileformat', 'binary' and 'fenc' when forced. */", "          if (!oldbuf && eap != NULL) {"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          if (!oldbuf && eap != NULL) {", "            set_file_options(TRUE, eap);", "            set_forced_fenc(eap);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "        /* May get the window options from the last time this buffer", "         * was in this window (or another window).  If not used"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        get_winopts(curbuf);", "        did_get_winopts = TRUE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["        did_get_winopts = TRUE;", "", "      }"], "whitespace/blank_line"]
["src/nvim/ex_cmds.c", ["    // CTRL-O to go back to a help file.", "    set_buflisted(TRUE);", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /* If autocommands change buffers under our fingers, forget about", "   * editing the file. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["   * editing the file. */", "  if (buf != curbuf)", "    goto theend;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    goto theend;", "  if (aborting())           /* autocmds may abort script processing */", "    goto theend;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    goto theend;", "  if (aborting())           /* autocmds may abort script processing */", "    goto theend;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /* Since we are starting to edit a file, consider the filetype to be", "   * unset.  Helps for when an autocommand changes files and expects syntax"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["   * highlighting to work in the other file. */", "  did_filetype = FALSE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * other_file\toldbuf"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["   */", "  if (!other_file && !oldbuf) {         /* re-use the buffer */", "    set_last_cursor(curwin);            /* may set b_last_cursor */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (!other_file && !oldbuf) {         /* re-use the buffer */", "    set_last_cursor(curwin);            /* may set b_last_cursor */", "    if (newlnum == ECMD_LAST || newlnum == ECMD_LASTL) {"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "    /* If autocommands change buffers under our fingers, forget about", "     * re-editing the file.  Should do the buf_clear_file(), but perhaps"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["     * the autocommands changed the buffer... */", "    if (buf != curbuf)", "      goto theend;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      goto theend;", "    if (aborting())         /* autocmds may abort script processing */", "      goto theend;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      goto theend;", "    if (aborting())         /* autocmds may abort script processing */", "      goto theend;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    buf_clear_file(curbuf);", "    curbuf->b_op_start.lnum = 0;        /* clear '[ and '] marks */", "    curbuf->b_op_end.lnum = 0;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * If we get here we are sure to start editing"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /* Assume success now */", "  retval = OK;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Check if we are editing the w_arg_idx file in the argument list."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (!auto_buf) {", "    /*", "     * Set cursor and init window before reading the file and executing"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "    /* It's possible that all lines in the buffer changed.  Need to update", "     * automatic folding for all windows where it's used. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "    /* Change directories when the 'acd' option is set. */", "    do_autochdir();"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "    /*", "     * Careful: open_buffer() and apply_autocmds() may change the current"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    topline = curwin->w_topline;", "    if (!oldbuf) {                          /* need to read the file */", "      swap_exists_action = SEA_DIALOG;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      swap_exists_action = SEA_DIALOG;", "      curbuf->b_flags |= BF_CHECK_RO;       /* set/reset 'ro' flag */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "      /*", "       * Open the buffer and read the file."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["       */", "      if (should_abort(open_buffer(FALSE, eap, readfile_flags)))", "        retval = FAIL;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["       */", "      if (should_abort(open_buffer(FALSE, eap, readfile_flags)))", "        retval = FAIL;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "      if (swap_exists_action == SEA_QUIT)", "        retval = FAIL;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    } else {", "      /* Read the modelines, but only to set window-local options.  Any", "       * buffer-local options have already been set and may have been"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf,", "          &retval);", "      apply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf,"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["", "      apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf,", "          &retval);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      apply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf,", "          &retval);", "    }"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["          &retval);", "      apply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf,", "          &retval);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    }", "    if (curwin->w_topline == topline)", "      topline = 0;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "    /* Even when cursor didn't move we need to recompute topline. */", "    changed_line_abv_curs();"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /* Tell the diff stuff that this buffer is new and/or needs updating.", "   * Also needed when re-editing the same buffer, because unloading will"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /* If the window options were changed may need to set the spell language.", "   * Can only do this after the buffer has been properly setup. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["   * Can only do this after the buffer has been properly setup. */", "  if (did_get_winopts && curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)", "    (void)did_set_spelllang(curwin);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (command == NULL) {", "    if (newcol >= 0) {          /* position set by autocommands */", "      curwin->w_cursor.lnum = newlnum;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      check_cursor();", "    } else if (newlnum > 0) { /* line number from caller or old position */", "      curwin->w_cursor.lnum = newlnum;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      if (solcol >= 0 && !p_sol) {", "        /* 'sol' is off: Use last known column. */", "        curwin->w_cursor.col = solcol;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        curwin->w_cursor.coladd = 0;", "        curwin->w_set_curswant = TRUE;", "      } else"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        curwin->w_set_curswant = TRUE;", "      } else", "        beginline(BL_SOL | BL_FIX);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["        beginline(BL_SOL | BL_FIX);", "    } else {                  /* no line number, go to last line in Ex mode */", "      if (exmode_active)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    } else {                  /* no line number, go to last line in Ex mode */", "      if (exmode_active)", "        curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /* Check if cursors in other windows on the same buffer are still valid */", "  check_lnums(FALSE);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  /* Check if cursors in other windows on the same buffer are still valid */", "  check_lnums(FALSE);", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Did not read the file, need to show some info about the file."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "    /* Obey the 'O' flag in 'cpoptions': overwrite any previous file", "     * message. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["     * message. */", "    if (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0)", "      msg_scroll = FALSE;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0)", "      msg_scroll = FALSE;", "    if (!msg_scroll)            /* wait a bit when overwriting an error msg */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      msg_scroll = FALSE;", "    if (!msg_scroll)            /* wait a bit when overwriting an error msg */", "      check_for_delay(FALSE);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      msg_scroll = FALSE;", "    if (!msg_scroll)            /* wait a bit when overwriting an error msg */", "      check_for_delay(FALSE);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (!msg_scroll)            /* wait a bit when overwriting an error msg */", "      check_for_delay(FALSE);", "    msg_start();"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    msg_scroll = msg_scroll_save;", "    msg_scrolled_ign = TRUE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "    msg_scrolled_ign = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  if (command != NULL)", "    do_cmdline(command, NULL, NULL, DOCMD_VERBOSE);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  if (curbuf->b_kmap_state & KEYMAP_INIT)", "    (void)keymap_init();"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  if (p_im)", "    need_start_insertmode = TRUE;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (p_im)", "    need_start_insertmode = TRUE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /* Change directories when the 'acd' option is set. */", "  do_autochdir();"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  EMSG2(_(\"E143: Autocommands unexpectedly deleted new buffer %s\"),", "      name == NULL ? (char_u *)\"\" : name);", "  xfree(name);"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["", "static int append_indent = 0;       /* autoindent for first line */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":insert\" and \":append\", also used by \":change\""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /* the ! flag toggles autoindent */", "  if (eap->forceit)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  /* the ! flag toggles autoindent */", "  if (eap->forceit)", "    curbuf->b_p_ai = !curbuf->b_p_ai;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /* First autoindent comes from the line we start on */", "  if (eap->cmdidx != CMD_change && curbuf->b_p_ai && lnum > 0)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  /* First autoindent comes from the line we start on */", "  if (eap->cmdidx != CMD_change && curbuf->b_p_ai && lnum > 0)", "    append_indent = get_indent_lnum(lnum);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  if (eap->cmdidx != CMD_append)", "    --lnum;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (eap->cmdidx != CMD_append)", "    --lnum;", ""], "readability/increment"]
["src/nvim/ex_cmds.c", ["  // when the buffer is empty need to delete the dummy line", "  if (empty && lnum == 1)", "    lnum = 0;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  State = INSERT;                   /* behave like in Insert mode */", "  if (curbuf->b_p_iminsert == B_IMODE_LMAP)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  State = INSERT;                   /* behave like in Insert mode */", "  if (curbuf->b_p_iminsert == B_IMODE_LMAP)", "    State |= LANGMAP;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  for (;; ) {", "    msg_scroll = TRUE;", "    need_wait_return = FALSE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    msg_scroll = TRUE;", "    need_wait_return = FALSE;", "    if (curbuf->b_p_ai) {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        append_indent = -1;", "      } else if (lnum > 0)", "        indent = get_indent_lnum(lnum);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    }", "    ex_keep_indent = FALSE;", "    if (eap->getline == NULL) {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    if (eap->getline == NULL) {", "      /* No getline() function, use the lines that follow. This ends", "       * when there is no more. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["       * when there is no more. */", "      if (eap->nextcmd == NULL || *eap->nextcmd == NUL)", "        break;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      p = vim_strchr(eap->nextcmd, NL);", "      if (p == NULL)", "        p = eap->nextcmd + STRLEN(eap->nextcmd);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    lines_left = Rows - 1;", "    if (theline == NULL)", "      break;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "    /* Using ^ CTRL-D in getexmodeline() makes us repeat the indent. */", "    if (ex_keep_indent)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    /* Using ^ CTRL-D in getexmodeline() makes us repeat the indent. */", "    if (ex_keep_indent)", "      append_indent = indent;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "    /* Look for the \".\" after automatic indent. */", "    vcol = 0;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    vcol = 0;", "    for (p = theline; indent > vcol; ++p) {", "      if (*p == ' ')"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    for (p = theline; indent > vcol; ++p) {", "      if (*p == ' ')", "        ++vcol;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      if (*p == ' ')", "        ++vcol;", "      else if (*p == TAB)"], "readability/increment"]
["src/nvim/ex_cmds.c", ["        ++vcol;", "      else if (*p == TAB)", "        vcol += 8 - vcol % 8;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["        vcol += 8 - vcol % 8;", "      else", "        break;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "    /* don't use autoindent if nothing was typed. */", "    if (p[0] == NUL)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    /* don't use autoindent if nothing was typed. */", "    if (p[0] == NUL)", "      theline[0] = NUL;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    xfree(theline);", "    ++lnum;", ""], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "  if (eap->forceit)", "    curbuf->b_p_ai = !curbuf->b_p_ai;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /* \"start\" is set to eap->line2+1 unless that position is invalid (when", "   * eap->line2 pointed to the end of the buffer and nothing was appended)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["                            eap->line2 + 1 : curbuf->b_ml.ml_line_count;", "  if (eap->cmdidx != CMD_append)", "    --curbuf->b_op_start.lnum;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (eap->cmdidx != CMD_append)", "    --curbuf->b_op_start.lnum;", "  curbuf->b_op_end.lnum = (eap->line2 < lnum)"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "  need_wait_return = FALSE;     /* don't use wait_return() now */", "  ex_no_reprint = TRUE;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  need_wait_return = FALSE;     /* don't use wait_return() now */", "  ex_no_reprint = TRUE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  need_wait_return = FALSE;     /* don't use wait_return() now */", "  ex_no_reprint = TRUE;", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":change\""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  if (eap->line2 >= eap->line1", "      && u_save(eap->line1 - 1, eap->line2 + 1) == FAIL)"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /* the ! flag toggles autoindent */", "  if (eap->forceit ? !curbuf->b_p_ai : curbuf->b_p_ai)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  /* the ! flag toggles autoindent */", "  if (eap->forceit ? !curbuf->b_p_ai : curbuf->b_p_ai)", "    append_indent = get_indent_lnum(eap->line1);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  for (lnum = eap->line2; lnum >= eap->line1; --lnum) {", "    if (curbuf->b_ml.ml_flags & ML_EMPTY)           /* nothing to delete */"], "readability/increment"]
["src/nvim/ex_cmds.c", ["  for (lnum = eap->line2; lnum >= eap->line1; --lnum) {", "    if (curbuf->b_ml.ml_flags & ML_EMPTY)           /* nothing to delete */", "      break;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  for (lnum = eap->line2; lnum >= eap->line1; --lnum) {", "    if (curbuf->b_ml.ml_flags & ML_EMPTY)           /* nothing to delete */", "      break;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /* make sure the cursor is not beyond the end of the file now */", "  check_cursor_lnum();"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /* \":append\" on the line above the deleted lines. */", "  eap->line2 = eap->line1;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  kind = x;", "  if (*kind == '-' || *kind == '+' || *kind == '='", "      || *kind == '^' || *kind == '.')"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      || *kind == '^' || *kind == '.')", "    ++x;", "  while (*x == '-' || *x == '+')"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    ++x;", "  while (*x == '-' || *x == '+')", "    ++x;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  while (*x == '-' || *x == '+')", "    ++x;", ""], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "  /* the number of '-' and '+' multiplies the distance */", "  if (*kind == '-' || *kind == '+')"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  /* the number of '-' and '+' multiplies the distance */", "  if (*kind == '-' || *kind == '+')", "    for (x = kind + 1; *x == *kind; ++x)"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (*kind == '-' || *kind == '+')", "    for (x = kind + 1; *x == *kind; ++x)", "      ;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (*kind == '-' || *kind == '+')", "    for (x = kind + 1; *x == *kind; ++x)", "      ;"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    for (x = kind + 1; *x == *kind; ++x)", "      ;", ""], "whitespace/semicolon"]
["src/nvim/ex_cmds.c", ["", "  default:        /* '+' */", "    start = lnum;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    start = lnum;", "    if (*kind == '+')", "      start += bigness * (linenr_T)(x - kind - 1) + 1;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      start += bigness * (linenr_T)(x - kind - 1) + 1;", "    else if (eap->addr_count == 0)", "      ++start;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    else if (eap->addr_count == 0)", "      ++start;", "    end = start + bigness - 1;"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "  if (start < 1)", "    start = 1;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  if (end > curbuf->b_ml.ml_line_count)", "    end = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "      for (j = 1; j < Columns; j++)", "        msg_putchar('-');"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "      for (j = 1; j < Columns; j++)", "        msg_putchar('-');"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "/*", " * Check if the secure flag is set (.exrc or .vimrc in current directory)."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    EMSG(_(e_curdir));", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    EMSG(_(e_sandbox));", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", ["/// Previous substitute replacement string", "static SubReplacementString old_sub = {NULL, 0, NULL};", ""], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["/// Previous substitute replacement string", "static SubReplacementString old_sub = {NULL, 0, NULL};", ""], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["    if (joined_lines_count > 1) {", "      do_join(joined_lines_count, FALSE, TRUE, FALSE, true);", "      sub_nsubs = joined_lines_count - 1;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  if (eap->cmdidx == CMD_tilde)", "    which_pat = RE_LAST;        /* use last used regexp */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (eap->cmdidx == CMD_tilde)", "    which_pat = RE_LAST;        /* use last used regexp */", "  else"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    which_pat = RE_LAST;        /* use last used regexp */", "  else", "    which_pat = RE_SUBST;       /* use last substitute regexp */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  else", "    which_pat = RE_SUBST;       /* use last substitute regexp */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /* new pattern and substitution */", "  if (eap->cmd[0] == 's' && *cmd != NUL && !ascii_iswhite(*cmd)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      && vim_strchr((char_u *)\"0123456789cegriIp|\\\"\", *cmd) == NULL) {", "    /* don't accept alphanumeric for separator */", "    if (isalpha(*cmd)) {"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    }", "    /*", "     * undocumented vi feature:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    if (*cmd == '\\\\') {", "      ++cmd;", "      if (vim_strchr((char_u *)\"/?&\", *cmd) == NULL) {"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "    /*", "     * Small incompatibility: vi sees '\\n' as end of the command, but in"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["     */", "    sub = cmd;              /* remember the start of the substitution */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    while (cmd[0]) {", "      if (cmd[0] == delimiter) {                /* end delimiter found */", "        *cmd++ = NUL;                           /* replace it with a NUL */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      if (cmd[0] == delimiter) {                /* end delimiter found */", "        *cmd++ = NUL;                           /* replace it with a NUL */", "        break;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      sub_set_replacement((SubReplacementString) {", "        .sub = xstrdup((char *) sub),", "        .timestamp = os_time(),"], "whitespace/cast"]
["src/nvim/ex_cmds.c", ["    }", "  } else if (!eap->skip) {    /* use previous pattern and substitution */", "    if (old_sub.sub == NULL) {      /* there is no previous command */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  } else if (!eap->skip) {    /* use previous pattern and substitution */", "    if (old_sub.sub == NULL) {      /* there is no previous command */", "      EMSG(_(e_nopresub));"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    }", "    pat = NULL;                 /* search_regcomp() will use previous pattern */", "    sub = (char_u *) old_sub.sub;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    pat = NULL;                 /* search_regcomp() will use previous pattern */", "    sub = (char_u *) old_sub.sub;", ""], "whitespace/cast"]
["src/nvim/ex_cmds.c", ["", "    /* Vi compatibility quirk: repeating with \":s\" keeps the cursor in the", "     * last column after using \"$\". */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    eap->line2 += i - 1;", "    if (eap->line2 > curbuf->b_ml.ml_line_count)", "      eap->line2 = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * check for trailing command or garbage"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  cmd = skipwhite(cmd);", "  if (*cmd && *cmd != '\"') {        /* if not end-of-line or comment */", "    eap->nextcmd = check_nextcmd(cmd);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      char_u      *p1;", "      int did_sub = FALSE;", "      int lastone;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "      /*", "       * The new text is build up step by step, to avoid too much"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "      /* At first match, remember current cursor position. */", "      if (!got_match) {"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        setpcmark();", "        got_match = TRUE;", "      }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "      /*", "       * Loop until nothing more to replace in this line."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "        /* Save the line number of the last change for the final", "         * cursor position (just like Vi). */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        curwin->w_cursor.lnum = lnum;", "        do_again = FALSE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "        /*", "         * 1. Match empty string does not count, except for first"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "        /* Normally we continue searching for a match just after the", "         * previous match. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          sub_nsubs++;", "          did_sub = TRUE;", "          /* Skip the substitution, unless an expression is used,"], "readability/bool"]
["src/nvim/ex_cmds.c", ["          did_sub = TRUE;", "          /* Skip the substitution, unless an expression is used,", "           * then it is evaluated in the sandbox. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["           * then it is evaluated in the sandbox. */", "          if (!(sub[0] == '\\\\' && sub[1] == '='))", "            goto skip;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "          /* change State to CONFIRM, so that the mouse works", "           * properly */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          State = CONFIRM;", "          setmouse();                   /* disable mouse in xterm */", "          curwin->w_cursor.col = regmatch.startpos[0].col;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "          /* When 'cpoptions' contains \"u\" don't sync undo when", "           * asking for confirmation. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["           * asking for confirmation. */", "          if (vim_strchr(p_cpo, CPO_UNDO) != NULL)", "            ++no_u_sync;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["          if (vim_strchr(p_cpo, CPO_UNDO) != NULL)", "            ++no_u_sync;", ""], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "          /*", "           * Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["              msg_start();", "              for (i = 0; i < (long)sc; ++i)", "                msg_putchar(' ');"], "readability/braces"]
["src/nvim/ex_cmds.c", ["              msg_start();", "              for (i = 0; i < (long)sc; ++i)", "                msg_putchar(' ');"], "readability/increment"]
["src/nvim/ex_cmds.c", ["                msg_putchar(' ');", "              for (; i <= (long)ec; ++i)", "                msg_putchar('^');"], "readability/braces"]
["src/nvim/ex_cmds.c", ["                msg_putchar(' ');", "              for (; i <= (long)ec; ++i)", "                msg_putchar('^');"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "              curwin->w_p_fen = FALSE;", "              /* Invert the matched string."], "readability/bool"]
["src/nvim/ex_cmds.c", ["              curwin->w_p_fen = FALSE;", "              /* Invert the matched string.", "               * Remove the inversion afterwards. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["              if (new_start != NULL) {", "                /* There already was a substitution, we would", "                 * like to show this to the user.  We cannot"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["                orig_line = vim_strsave(ml_get(lnum));", "                char_u *new_line = concat_str(new_start, sub_firstline + copycol);", ""], "whitespace/line_length"]
["src/nvim/ex_cmds.c", ["                                    + len_change;", "              highlight_match = TRUE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["              curwin->w_p_fen = save_p_fen;", "              if (msg_row == Rows - 1)", "                msg_didout = FALSE;                     /* avoid a scroll-up */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["              if (msg_row == Rows - 1)", "                msg_didout = FALSE;                     /* avoid a scroll-up */", "              msg_starthere();"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["              if (msg_row == Rows - 1)", "                msg_didout = FALSE;                     /* avoid a scroll-up */", "              msg_starthere();"], "readability/bool"]
["src/nvim/ex_cmds.c", ["              i = msg_scroll;", "              msg_scroll = 0;                           /* truncate msg when", "                                                           needed */"], "readability/multiline_comment"]
["src/nvim/ex_cmds.c", ["              i = msg_scroll;", "              msg_scroll = 0;                           /* truncate msg when", "                                                           needed */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["                        _(\"replace with %s (y/n/a/q/l/^E/^Y)?\"), sub);", "              msg_no_more = FALSE;", "              msg_scroll = i;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["              msg_scroll = i;", "              showruler(TRUE);", "              ui_cursor_goto(msg_row, msg_col);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "              /* clear the question */", "              msg_didout = FALSE;               /* don't scroll up */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["              /* clear the question */", "              msg_didout = FALSE;               /* don't scroll up */", "              msg_col = 0;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["              /* clear the question */", "              msg_didout = FALSE;               /* don't scroll up */", "              msg_col = 0;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["            }", "            if (typed == 'n')", "              break;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["              break;", "            if (typed == 'y')", "              break;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["            }", "            if (typed == Ctrl_E)", "              scrollup_clamp();"], "readability/braces"]
["src/nvim/ex_cmds.c", ["              scrollup_clamp();", "            else if (typed == Ctrl_Y)", "              scrolldown_clamp();"], "readability/braces"]
["src/nvim/ex_cmds.c", ["          setmouse();", "          if (vim_strchr(p_cpo, CPO_UNDO) != NULL)", "            --no_u_sync;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["          if (vim_strchr(p_cpo, CPO_UNDO) != NULL)", "            --no_u_sync;", ""], "readability/increment"]
["src/nvim/ex_cmds.c", ["          if (typed == 'n') {", "            /* For a multi-line match, put matchcol at the NUL at", "             * the end of the line and set nmatch to one, so that"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          }", "          if (got_quit)", "            goto skip;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "        /* Move the cursor to the start of the match, so that we can", "         * use \"\\=col(\".\"). */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["skip:", "        /* We already know that we did the last subst when we are at", "         * the end of the line, except that a pattern like"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "        /*", "         * Replace the line in the buffer when needed.  This is"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          if (new_start != NULL) {", "            /*", "             * Copy the rest of the line, that didn't match."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["            if (nmatch_tl > 0) {", "              /*", "               * Matched lines have now been substituted and are"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["               */", "              ++lnum;", "              if (u_savedel(lnum, nmatch_tl) != OK)"], "readability/increment"]
["src/nvim/ex_cmds.c", ["              ++lnum;", "              if (u_savedel(lnum, nmatch_tl) != OK)", "                break;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "            /* When asking, undo is saved each time, must also set", "             * changed flag each time. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["            sub_firstlnum = lnum;", "            xfree(sub_firstline);                /* free the temp buffer */", "            sub_firstline = new_start;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          }", "          if (nmatch == -1 && !lastone)", "            nmatch = vim_regexec_multi(&regmatch, curwin, curbuf,"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "          /*", "           * 5. break if there isn't another match in this line"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          if (nmatch <= 0) {", "            /* If the match found didn't start where we were", "             * searching, do the next search in the line where we"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["             * found the match. */", "            if (nmatch == -1)", "              lnum -= regmatch.startpos[0].lnum;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (first_line != 0) {", "    /* Need to subtract the number of added lines from \"last_line\" to get", "     * the line number before the change (same as adding the number of"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  xfree(sub_firstline);   /* may have to free allocated copy of the line */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (sub_nsubs > start_nsubs) {", "    /* Set the '[ and '] marks. */", "    curbuf->b_op_start.lnum = eap->line1;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * Give message for number of substitutions."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["bool", "do_sub_msg (", "    bool count_only                /* used 'n' flag for \":s\" */"], "whitespace/parens"]
["src/nvim/ex_cmds.c", ["do_sub_msg (", "    bool count_only                /* used 'n' flag for \":s\" */", ")"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["{", "  /*", "   * Only report substitutions when:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      && messaging()) {", "    if (got_int)", "      STRCPY(msg_buf, _(\"(Interrupted) \"));"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      STRCPY(msg_buf, _(\"(Interrupted) \"));", "    else", "      *msg_buf = NUL;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      *msg_buf = NUL;", "    if (sub_nsubs == 1)", "      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),", "          \"%s\", count_only ? _(\"1 match\") : _(\"1 substitution\"));", "    else"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["          \"%s\", count_only ? _(\"1 match\") : _(\"1 substitution\"));", "    else", "      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),", "          count_only ? _(\"%\" PRId64 \" matches\")", "                     : _(\"%\" PRId64 \" substitutions\"),"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["          count_only ? _(\"%\" PRId64 \" matches\")", "                     : _(\"%\" PRId64 \" substitutions\"),", "          (int64_t)sub_nsubs);"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                     : _(\"%\" PRId64 \" substitutions\"),", "          (int64_t)sub_nsubs);", "    if (sub_nlines == 1)"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["          (int64_t)sub_nsubs);", "    if (sub_nlines == 1)", "      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),", "          \"%s\", _(\" on 1 line\"));", "    else"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["          \"%s\", _(\" on 1 line\"));", "    else", "      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),", "          _(\" on %\" PRId64 \" lines\"), (int64_t)sub_nlines);", "    if (msg(msg_buf))"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["          _(\" on %\" PRId64 \" lines\"), (int64_t)sub_nlines);", "    if (msg(msg_buf))", "      /* save message to display it after redraw */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (msg(msg_buf))", "      /* save message to display it after redraw */", "      set_keep_msg(msg_buf, 0);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * Execute a global command of the form:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["{", "  linenr_T lnum;                /* line number according to old situation */", "  int ndone = 0;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  int ndone = 0;", "  int type;                     /* first char of cmd: 'v' or 'g' */", "  char_u      *cmd;             /* command argument */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  int type;                     /* first char of cmd: 'v' or 'g' */", "  char_u      *cmd;             /* command argument */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  char_u delim;                 /* delimiter, normally '/' */", "  char_u      *pat;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  if (eap->forceit)                 /* \":global!\" is like \":vglobal\" */", "    type = 'v';"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  if (eap->forceit)                 /* \":global!\" is like \":vglobal\" */", "    type = 'v';"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    type = 'v';", "  else", "    type = *eap->cmd;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  cmd = eap->arg;", "  which_pat = RE_LAST;              /* default: use last used regexp */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * undocumented vi feature:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (*cmd == '\\\\') {", "    ++cmd;", "    if (vim_strchr((char_u *)\"/?&\", *cmd) == NULL) {"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    }", "    if (*cmd == '&')", "      which_pat = RE_SUBST;             /* use previous substitute pattern */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (*cmd == '&')", "      which_pat = RE_SUBST;             /* use previous substitute pattern */", "    else"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      which_pat = RE_SUBST;             /* use previous substitute pattern */", "    else", "      which_pat = RE_SEARCH;            /* use previous search pattern */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    else", "      which_pat = RE_SEARCH;            /* use previous search pattern */", "    ++cmd;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      which_pat = RE_SEARCH;            /* use previous search pattern */", "    ++cmd;", "    pat = (char_u *)\"\";"], "readability/increment"]
["src/nvim/ex_cmds.c", ["  } else {", "    delim = *cmd;               /* get the delimiter */", "    if (delim)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    delim = *cmd;               /* get the delimiter */", "    if (delim)", "      ++cmd;                    /* skip delimiter if there is one */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (delim)", "      ++cmd;                    /* skip delimiter if there is one */", "    pat = cmd;                  /* remember start of pattern */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    if (delim)", "      ++cmd;                    /* skip delimiter if there is one */", "    pat = cmd;                  /* remember start of pattern */"], "readability/increment"]
["src/nvim/ex_cmds.c", ["      ++cmd;                    /* skip delimiter if there is one */", "    pat = cmd;                  /* remember start of pattern */", "    cmd = skip_regexp(cmd, delim, p_magic, &eap->arg);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    cmd = skip_regexp(cmd, delim, p_magic, &eap->arg);", "    if (cmd[0] == delim)                    /* end delimiter found */", "      *cmd++ = NUL;                         /* replace it with a NUL */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    cmd = skip_regexp(cmd, delim, p_magic, &eap->arg);", "    if (cmd[0] == delim)                    /* end delimiter found */", "      *cmd++ = NUL;                         /* replace it with a NUL */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (cmd[0] == delim)                    /* end delimiter found */", "      *cmd++ = NUL;                         /* replace it with a NUL */", "  }"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["{", "  sub_set_replacement((SubReplacementString) {NULL, 0, NULL});", "}"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["{", "  sub_set_replacement((SubReplacementString) {NULL, 0, NULL});", "}"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["", "/*", " * Set up for a tagpreview."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["bool", "prepare_tagpreview (", "    bool undo_sync                  /* sync undo when leaving the window */"], "whitespace/parens"]
["src/nvim/ex_cmds.c", ["prepare_tagpreview (", "    bool undo_sync                  /* sync undo when leaving the window */", ")"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["{", "  /*", "   * If there is already a preview window open, use that one."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    if (!found_win) {", "      /*", "       * There is no preview window open yet.  Create one."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["       */", "      if (win_split(g_do_tagpreview > 0 ? g_do_tagpreview : 0, 0)", "          == FAIL)"], "readability/braces"]
["src/nvim/ex_cmds.c", ["        return false;", "      curwin->w_p_pvw = TRUE;", "      curwin->w_p_wfh = TRUE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      curwin->w_p_pvw = TRUE;", "      curwin->w_p_wfh = TRUE;", "      RESET_BINDING(curwin);                /* don't take over 'scrollbind'"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      curwin->w_p_wfh = TRUE;", "      RESET_BINDING(curwin);                /* don't take over 'scrollbind'", "                                               and 'cursorbind' */"], "readability/multiline_comment"]
["src/nvim/ex_cmds.c", ["      curwin->w_p_wfh = TRUE;", "      RESET_BINDING(curwin);                /* don't take over 'scrollbind'", "                                               and 'cursorbind' */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":help\": open a read-only window on a help file"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  char_u      *tag;", "  FILE        *helpfd;          /* file descriptor of help file */", "  int n;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (eap != NULL) {", "    /*", "     * A \":help\" command ends at the first LF, or at a '|' that is"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["     */", "    for (arg = eap->arg; *arg; ++arg) {", "      if (*arg == '\\n' || *arg == '\\r'"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "    if (eap->skip)          /* not executing commands */", "      return;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "    if (eap->skip)          /* not executing commands */", "      return;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      return;", "  } else", "    arg = (char_u *)\"\";"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /* remove trailing blanks */", "  p = arg + STRLEN(arg) - 1;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  p = arg + STRLEN(arg) - 1;", "  while (p > arg && ascii_iswhite(*p) && p[-1] != '\\\\')", "    *p-- = NUL;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /* Check for a specified language */", "  lang = check_help_lang(arg);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /* When no argument given go to the index. */", "  if (*arg == NUL)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  /* When no argument given go to the index. */", "  if (*arg == NUL)", "    arg = (char_u *)\"help.txt\";"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Check if there is a match for the argument."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  n = find_help_tags(arg, &num_matches, &matches,", "      eap != NULL && eap->forceit);", ""], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["  i = 0;", "  if (n != FAIL && lang != NULL)", "    /* Find first item with the requested language. */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (n != FAIL && lang != NULL)", "    /* Find first item with the requested language. */", "    for (i = 0; i < num_matches; ++i) {"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    /* Find first item with the requested language. */", "    for (i = 0; i < num_matches; ++i) {", "      len = (int)STRLEN(matches[i]);"], "readability/increment"]
["src/nvim/ex_cmds.c", ["      len = (int)STRLEN(matches[i]);", "      if (len > 3 && matches[i][len - 3] == '@'", "          && STRICMP(matches[i] + len - 2, lang) == 0)"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (i >= num_matches || n == FAIL) {", "    if (lang != NULL)", "      EMSG3(_(\"E661: Sorry, no '%s' help for %s\"), lang, arg);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      EMSG3(_(\"E661: Sorry, no '%s' help for %s\"), lang, arg);", "    else", "      EMSG2(_(\"E149: Sorry, no help for %s\"), arg);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      EMSG2(_(\"E149: Sorry, no help for %s\"), arg);", "    if (n != FAIL)", "      FreeWild(num_matches, matches);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /* The first match (in the requested language) is the best match. */", "  tag = vim_strsave(matches[i]);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Re-use an existing help window or open a new one."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "      /* Split off help window; put it at far top if no position", "       * specified, the current window is vertically split and"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      n = WSP_HELP;", "      if (cmdmod.split == 0 && curwin->w_width != Columns", "          && curwin->w_width < 80)"], "readability/braces"]
["src/nvim/ex_cmds.c", ["        n |= WSP_TOP;", "      if (win_split(0, n) == FAIL)", "        goto erret;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "      if (curwin->w_height < p_hh)", "        win_setheight((int)p_hh);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "      /*", "       * Open help file (do_ecmd() will set b_help flag, readfile() will"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      (void)do_ecmd(0, NULL, NULL, NULL, ECMD_LASTL,", "          ECMD_HIDE + ECMD_SET_HELP,", "          NULL                  /* buffer is still open, don't store info */"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["          ECMD_HIDE + ECMD_SET_HELP,", "          NULL                  /* buffer is still open, don't store info */", "          );"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["          NULL                  /* buffer is still open, don't store info */", "          );", "      if (!cmdmod.keepalt)"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["          ECMD_HIDE + ECMD_SET_HELP,", "          NULL                  /* buffer is still open, don't store info */", "          );"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          NULL                  /* buffer is still open, don't store info */", "          );", "      if (!cmdmod.keepalt)"], "whitespace/parens"]
["src/nvim/ex_cmds.c", ["          );", "      if (!cmdmod.keepalt)", "        curwin->w_alt_fnum = alt_fnum;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  if (!p_im)", "    restart_edit = 0;               /* don't want insert mode in help file */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (!p_im)", "    restart_edit = 0;               /* don't want insert mode in help file */", ""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /* Restore KeyTyped, setting 'filetype=help' may reset it.", "   * It is needed for do_tag top open folds under the cursor. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  do_tag(tag, DT_HELP, 1, FALSE, TRUE);", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /* Delete the empty buffer if we're not using it.  Careful: autocommands", "   * may have jumped to another window, check that the buffer is not in a"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    buf = buflist_findnr(empty_fnum);", "    if (buf != NULL && buf->b_nwindows == 0)", "      wipe_buffer(buf, TRUE);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (buf != NULL && buf->b_nwindows == 0)", "      wipe_buffer(buf, TRUE);", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /* keep the previous alternate file */", "  if (alt_fnum != 0 && curwin->w_alt_fnum == empty_fnum && !cmdmod.keepalt)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  /* keep the previous alternate file */", "  if (alt_fnum != 0 && curwin->w_alt_fnum == empty_fnum && !cmdmod.keepalt)", "    curwin->w_alt_fnum = alt_fnum;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "/*", " * In an argument search for a language specifiers in the form \"@xx\"."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      && ASCII_ISALPHA(arg[len - 1])) {", "    arg[len - 3] = NUL;                 /* remove the '@' */", "    return arg + len - 2;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * Return a heuristic indicating how well the given string matches.  The"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  num_letters = 0;", "  for (p = matched_string; *p; p++)", "    if (ASCII_ISALNUM(*p))"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  for (p = matched_string; *p; p++)", "    if (ASCII_ISALNUM(*p))", "      num_letters++;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Multiply the number of letters by 100 to give it a much bigger"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * Compare functions for qsort() below, that checks the help heuristics number"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      \"*\", \"g*\", \"[*\", \"]*\",", "      \"/*\", \"/\\\\*\", \"\\\"*\", \"**\",", "      \"/\\\\(\\\\)\", \"/\\\\%(\\\\)\","], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  if (i < 0) {  /* no match in table */", "    /* Replace \"\\S\" with \"/\\\\S\", etc.  Otherwise every tag is matched."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (i < 0) {  /* no match in table */", "    /* Replace \"\\S\" with \"/\\\\S\", etc.  Otherwise every tag is matched.", "     * Also replace \"\\%^\" and \"\\%(\", they match every tag too."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      STRCPY(d + 3, arg + 1);", "      /* Check for \"/\\\\_$\", should be \"/\\\\_\\$\" */", "      if (d[3] == '_' && d[4] == '$')"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      /* Check for \"/\\\\_$\", should be \"/\\\\_\\$\" */", "      if (d[3] == '_' && d[4] == '$')", "        STRCPY(d + 4, \"\\\\$\");"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    } else {", "      /* Replace:", "       * \"[:...:]\" with \"\\[:...:]\""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["       */", "      if ((arg[0] == '[' && (arg[1] == ':'", "                             || (arg[1] == '+' && arg[2] == '+')))"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "        /*", "         * Replace \"^x\" by \"CTRL-X\". Don't do this for \"^_\" to make"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["                                               || vim_strchr((char_u *)", "                                                   \"?@[\\\\]^\",", "                                                   s[1]) != NULL))) {"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                                                   \"?@[\\\\]^\",", "                                                   s[1]) != NULL))) {", "          if (d > IObuff && d[-1] != '_' && d[-1] != '\\\\')"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                                               || vim_strchr((char_u *)", "                                                   \"?@[\\\\]^\",", "                                                   s[1]) != NULL))) {"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                                                   \"?@[\\\\]^\",", "                                                   s[1]) != NULL))) {", "          if (d > IObuff && d[-1] != '_' && d[-1] != '\\\\')"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                                                   s[1]) != NULL))) {", "          if (d > IObuff && d[-1] != '_' && d[-1] != '\\\\')", "            *d++ = '_';                 /* prepend a '_' to make x_CTRL-x */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["          if (d > IObuff && d[-1] != '_' && d[-1] != '\\\\')", "            *d++ = '_';                 /* prepend a '_' to make x_CTRL-x */", "          STRCPY(d, \"CTRL-\");"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["            *d++ = *s + '@';", "            if (d[-1] == '\\\\')", "              *d++ = '\\\\';              /* double a backslash */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["            if (d[-1] == '\\\\')", "              *d++ = '\\\\';              /* double a backslash */", "          } else"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["              *d++ = '\\\\';              /* double a backslash */", "          } else", "            *d++ = *++s;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["            *d++ = *++s;", "          if (s[1] != NUL && s[1] != '_')", "            *d++ = '_';                 /* append a '_' */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["          if (s[1] != NUL && s[1] != '_')", "            *d++ = '_';                 /* append a '_' */", "          continue;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          continue;", "        } else if (*s == '^')           /* \"^\" or \"CTRL-^\" or \"^_\" */", "          *d++ = '\\\\';"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          continue;", "        } else if (*s == '^')           /* \"^\" or \"CTRL-^\" or \"^_\" */", "          *d++ = '\\\\';"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "        /*", "         * Insert a backslash before a backslash after a slash, for search"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["         */", "        else if (s[0] == '\\\\' && s[1] != '\\\\'", "                 && *arg == '/' && s == arg + 1)"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "        /* \"CTRL-\\_\" -> \"CTRL-\\\\_\" to avoid the special meaning of \"\\_\" in", "         * \"CTRL-\\_CTRL-N\" */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        if (d > IObuff + 2 && d[-1] == '`') {", "          /* remove the backticks from `command` */", "          memmove(IObuff, IObuff + 1, STRLEN(IObuff));"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        } else if (d > IObuff + 3 && d[-2] == '`' && d[-1] == ',') {", "          /* remove the backticks and comma from `command`, */", "          memmove(IObuff, IObuff + 1, STRLEN(IObuff));"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["                   && d[-2] == '\\\\' && d[-1] == '.') {", "          /* remove the backticks and dot from `command`\\. */", "          memmove(IObuff, IObuff + 1, STRLEN(IObuff));"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      && *num_matches > 0) {", "    /* Sort the matches found on the heuristic number that is after the", "     * tag name. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["     * tag name. */", "    qsort((void *)*matches, (size_t)*num_matches,", "        sizeof(char_u *), help_compare);"], "whitespace/operators"]
["src/nvim/ex_cmds.c", ["    qsort((void *)*matches, (size_t)*num_matches,", "        sizeof(char_u *), help_compare);", "    /* Delete more than TAG_MANY to reduce the size of the listing. */"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["        sizeof(char_u *), help_compare);", "    /* Delete more than TAG_MANY to reduce the size of the listing. */", "    while (*num_matches > TAG_MANY)"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    /* Delete more than TAG_MANY to reduce the size of the listing. */", "    while (*num_matches > TAG_MANY)", "      xfree((*matches)[--*num_matches]);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    check_buf_options(curbuf);", "    (void)buf_init_chartab(curbuf, FALSE);", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curbuf->b_p_ts = 8;         // 'tabstop' is 8.", "  curwin->w_p_list = FALSE;   // No list mode.", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  curbuf->b_p_ma = FALSE;     // Not modifiable.", "  curbuf->b_p_bin = FALSE;    // Reset 'bin' before reading file."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curbuf->b_p_ma = FALSE;     // Not modifiable.", "  curbuf->b_p_bin = FALSE;    // Reset 'bin' before reading file.", "  curwin->w_p_nu = 0;         // No line numbers."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  RESET_BINDING(curwin);      // No scroll or cursor binding.", "  curwin->w_p_arab = FALSE;   // No arabic mode.", "  curwin->w_p_rl  = FALSE;    // Help window is left-to-right."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curwin->w_p_arab = FALSE;   // No arabic mode.", "  curwin->w_p_rl  = FALSE;    // Help window is left-to-right.", "  curwin->w_p_fen = FALSE;    // No folding in the help window."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curwin->w_p_rl  = FALSE;    // Help window is left-to-right.", "  curwin->w_p_fen = FALSE;    // No folding in the help window.", "  curwin->w_p_diff = FALSE;   // No 'diff'."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curwin->w_p_fen = FALSE;    // No folding in the help window.", "  curwin->w_p_diff = FALSE;   // No 'diff'.", "  curwin->w_p_spell = FALSE;  // No spell checking."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curwin->w_p_diff = FALSE;   // No 'diff'.", "  curwin->w_p_spell = FALSE;  // No spell checking.", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  set_buflisted(FALSE);", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "/*", " * After reading a help file: May cleanup a help buffer when syntax"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      if (in_example && len > 0 && !ascii_iswhite(line[0])) {", "        /* End of example: non-white or '<' in first column. */", "        if (line[0] == '<') {"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        if (line[0] == '<') {", "          /* blank-out a '<' in the first column */", "          line = ml_get_buf(curbuf, lnum, TRUE);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          /* blank-out a '<' in the first column */", "          line = ml_get_buf(curbuf, lnum, TRUE);", "          line[0] = ' ';"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        if (line[len - 1] == '>' && (len == 1 || line[len - 2] == ' ')) {", "          /* blank-out a '>' in the last column (start of example) */", "          line = ml_get_buf(curbuf, lnum, TRUE);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          /* blank-out a '>' in the last column (start of example) */", "          line = ml_get_buf(curbuf, lnum, TRUE);", "          line[len - 1] = ' ';"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        } else if (line[len - 1] == '~') {", "          /* blank-out a '~' at the end of line (header marker) */", "          line = ml_get_buf(curbuf, lnum, TRUE);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          /* blank-out a '~' at the end of line (header marker) */", "          line = ml_get_buf(curbuf, lnum, TRUE);", "          line[len - 1] = ' ';"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * In the \"help.txt\" and \"help.abx\" file, add the locally added help"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      ) {", "    for (lnum = 1; lnum < curbuf->b_ml.ml_line_count; ++lnum) {", "      line = ml_get_buf(curbuf, lnum, FALSE);"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    for (lnum = 1; lnum < curbuf->b_ml.ml_line_count; ++lnum) {", "      line = ml_get_buf(curbuf, lnum, FALSE);", "      if (strstr((char *)line, \"*local-additions*\") == NULL)"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      line = ml_get_buf(curbuf, lnum, FALSE);", "      if (strstr((char *)line, \"*local-additions*\") == NULL)", "        continue;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "      /* Go through all directories in 'runtimepath', skipping", "       * $VIMRUNTIME. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          if (!add_pathsep((char *)NameBuff)", "              || STRLCAT(NameBuff, \"doc/*.??[tx]\",", "                         sizeof(NameBuff)) >= MAXPATHL) {"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "          // Note: We cannot just do `&NameBuff` because it is a statically sized array", "          //       so `NameBuff == &NameBuff` according to C semantics."], "whitespace/line_length"]
["src/nvim/ex_cmds.c", ["          //       so `NameBuff == &NameBuff` according to C semantics.", "          char_u *buff_list[1] = {NameBuff};", "          if (gen_expand_wildcards(1, buff_list, &fcount,"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["          //       so `NameBuff == &NameBuff` according to C semantics.", "          char_u *buff_list[1] = {NameBuff};", "          if (gen_expand_wildcards(1, buff_list, &fcount,"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["          if (gen_expand_wildcards(1, buff_list, &fcount,", "                  &fnames, EW_FILE|EW_SILENT) == OK", "              && fcount > 0) {"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                while (*s != NUL) {", "                  if (*s == '\\r' || *s == '\\n')", "                    *s = NUL;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["                    *s = NUL;", "                  /* The text is utf-8 when a byte", "                   * above 127 is found and no"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["                  }", "                  ++s;", "                }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["                }", "                /* The help file is latin1 or utf-8;", "                 * conversion to the current"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":exusage\""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":viusage\""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  //       so `NameBuff == &NameBuff` according to C semantics.", "  char_u *buff_list[1] = {NameBuff};", "  if (gen_expand_wildcards(1, buff_list, &filecount, &files,"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["  //       so `NameBuff == &NameBuff` according to C semantics.", "  char_u *buff_list[1] = {NameBuff};", "  if (gen_expand_wildcards(1, buff_list, &filecount, &files,"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["  if (gen_expand_wildcards(1, buff_list, &filecount, &files,", "          EW_FILE|EW_SILENT) == FAIL", "      || filecount == 0) {"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["    s = xmalloc(18 + STRLEN(tagfname));", "    sprintf((char *)s, \"help-tags\\t%s\\t1\\n\", tagfname);", "    GA_APPEND(char_u *, &ga, s);"], "runtime/printf"]
["src/nvim/ex_cmds.c", ["          EMSG2(_(", "                  \"E670: Mix of help file encodings within a language: %s\"),", "              files[fi]);"], "whitespace/indent"]
["src/nvim/ex_cmds.c", ["                  \"E670: Mix of help file encodings within a language: %s\"),", "              files[fi]);", "          mix = !got_int;"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["          mix = !got_int;", "          got_int = TRUE;", "        }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["            *p2 = '\\0';", "            ++p1;", "            s = xmalloc((p2 - p1) + STRLEN(fname) + 2);"], "readability/increment"]
["src/nvim/ex_cmds.c", ["            GA_APPEND(char_u *, &ga, s);", "            sprintf((char *)s, \"%s\\t%s\", p1, fname);", ""], "runtime/printf"]
["src/nvim/ex_cmds.c", ["          vim_snprintf((char *)NameBuff, MAXPATHL,", "              _(\"E154: Duplicate tag \\\"%s\\\" in file %s/%s\"),", "              ((char_u **)ga.ga_data)[i], dir, p2 + 1);"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["              _(\"E154: Duplicate tag \\\"%s\\\" in file %s/%s\"),", "              ((char_u **)ga.ga_data)[i], dir, p2 + 1);", "          EMSG(NameBuff);"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["        }", "        ++p1;", "        ++p2;"], "readability/increment"]
["src/nvim/ex_cmds.c", ["        ++p1;", "        ++p2;", "      }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["  //       so `NameBuff == &NameBuff` according to C semantics.", "  char_u *buff_list[1] = {NameBuff};", "  if (gen_expand_wildcards(1, buff_list, &filecount, &files,"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["  //       so `NameBuff == &NameBuff` according to C semantics.", "  char_u *buff_list[1] = {NameBuff};", "  if (gen_expand_wildcards(1, buff_list, &filecount, &files,"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["", "  /* Go over all files in the directory to find out what languages are", "   * present. */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    if (STRICMP(files[i] + len - 4, \".txt\") == 0) {", "      /* \".txt\" -> language \"en\" */", "      lang[0] = 'e';"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["               && TOLOWER_ASC(files[i][len - 1]) == 'x') {", "      /* \".abx\" -> language \"ab\" */", "      lang[0] = TOLOWER_ASC(files[i][len - 3]);"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      lang[1] = TOLOWER_ASC(files[i][len - 2]);", "    } else", "      continue;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Loop over the found languages to generate a tags file for each one."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    if (fname[5] == 'e' && fname[6] == 'n') {", "      /* English is an exception: use \".txt\" and \"tags\". */", "      fname[4] = NUL;"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    } else {", "      /* Language \"ab\" uses \".abx\" and \"tags-ab\". */", "      STRCPY(ext, \".xxx\");"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":helptags\""], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /* Check for \":helptags ++t {dir}\". */", "  if (STRNCMP(eap->arg, \"++t\", 3) == 0 && ascii_iswhite(eap->arg[3])) {"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "/*", " * \":helpclose\": Close one help window"], "readability/old_style_comment"]
