["src/nvim/syntax.c", ["", "/*", " * syntax.c: code for syntax highlighting"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "#define MAX_HL_ID       20000   /* maximum value for a highlight ID. */", ""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/* different types of offsets that are possible */", "#define SPO_MS_OFF      0       /* match  start offset */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["/* different types of offsets that are possible */", "#define SPO_MS_OFF      0       /* match  start offset */", "#define SPO_ME_OFF      1       /* match  end\toffset */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define SPO_MS_OFF      0       /* match  start offset */", "#define SPO_ME_OFF      1       /* match  end\toffset */", "#define SPO_HS_OFF      2       /* highl. start offset */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define SPO_MS_OFF      0       /* match  start offset */", "#define SPO_ME_OFF      1       /* match  end\toffset */", "#define SPO_HS_OFF      2       /* highl. start offset */"], "whitespace/tab"]
["src/nvim/syntax.c", ["#define SPO_ME_OFF      1       /* match  end\toffset */", "#define SPO_HS_OFF      2       /* highl. start offset */", "#define SPO_HE_OFF      3       /* highl. end\toffset */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define SPO_HS_OFF      2       /* highl. start offset */", "#define SPO_HE_OFF      3       /* highl. end\toffset */", "#define SPO_RS_OFF      4       /* region start offset */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define SPO_HS_OFF      2       /* highl. start offset */", "#define SPO_HE_OFF      3       /* highl. end\toffset */", "#define SPO_RS_OFF      4       /* region start offset */"], "whitespace/tab"]
["src/nvim/syntax.c", ["#define SPO_HE_OFF      3       /* highl. end\toffset */", "#define SPO_RS_OFF      4       /* region start offset */", "#define SPO_RE_OFF      5       /* region end\toffset */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define SPO_RS_OFF      4       /* region start offset */", "#define SPO_RE_OFF      5       /* region end\toffset */", "#define SPO_LC_OFF      6       /* leading context offset */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define SPO_RS_OFF      4       /* region start offset */", "#define SPO_RE_OFF      5       /* region end\toffset */", "#define SPO_LC_OFF      6       /* leading context offset */"], "whitespace/tab"]
["src/nvim/syntax.c", ["#define SPO_RE_OFF      5       /* region end\toffset */", "#define SPO_LC_OFF      6       /* leading context offset */", "#define SPO_COUNT       7"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/* Flags to indicate an additional string for highlight name completion. */", "static int include_none = 0;    /* when 1 include \"nvim/None\" */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["/* Flags to indicate an additional string for highlight name completion. */", "static int include_none = 0;    /* when 1 include \"nvim/None\" */", "static int include_default = 0; /* when 1 include \"nvim/default\" */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static int include_none = 0;    /* when 1 include \"nvim/None\" */", "static int include_default = 0; /* when 1 include \"nvim/default\" */", "static int include_link = 0;    /* when 2 include \"nvim/link\" and \"clear\" */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static int include_default = 0; /* when 1 include \"nvim/default\" */", "static int include_link = 0;    /* when 2 include \"nvim/link\" and \"clear\" */", ""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * For the current state we need to remember more than just the idx."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Struct to reduce the number of arguments to get_syn_options(), it's used"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static char *(spo_name_tab[SPO_COUNT]) =", "{\"ms=\", \"me=\", \"hs=\", \"he=\", \"rs=\", \"re=\", \"lc=\"};", ""], "whitespace/braces"]
["src/nvim/syntax.c", ["static char *(spo_name_tab[SPO_COUNT]) =", "{\"ms=\", \"me=\", \"hs=\", \"he=\", \"rs=\", \"re=\", \"lc=\"};", ""], "whitespace/braces"]
["src/nvim/syntax.c", ["", "/* The sp_off_flags are computed like this:", " * offset from the start of the matched text: (1 << SPO_XX_OFF)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "#define SPTYPE_MATCH    1       /* match keyword with this group ID */", "#define SPTYPE_START    2       /* match a regexp, start of item */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define SPTYPE_MATCH    1       /* match keyword with this group ID */", "#define SPTYPE_START    2       /* match a regexp, start of item */", "#define SPTYPE_END      3       /* match a regexp, end of item */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define SPTYPE_START    2       /* match a regexp, start of item */", "#define SPTYPE_END      3       /* match a regexp, end of item */", "#define SPTYPE_SKIP     4       /* match a regexp, skip within item */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define SPTYPE_END      3       /* match a regexp, end of item */", "#define SPTYPE_SKIP     4       /* match a regexp, skip within item */", ""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "#define NONE_IDX        -2      /* value of sp_sync_idx for \"NONE\" */", ""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Flags for b_syn_sync_flags:"], "readability/old_style_comment"]
["src/nvim/syntax.c", [" */", "#define SF_CCOMMENT     0x01    /* sync on a C-style comment */", "#define SF_MATCH        0x02    /* sync by matching a pattern */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define SF_CCOMMENT     0x01    /* sync on a C-style comment */", "#define SF_MATCH        0x02    /* sync by matching a pattern */", ""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "#define MAXKEYWLEN      80          /* maximum length of a keyword */", ""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * The attributes of the syntax item that has been recognized."], "readability/old_style_comment"]
["src/nvim/syntax.c", [" */", "static int current_attr = 0;        /* attr of current syntax word */", "static int current_id = 0;          /* ID of current char for syn_get_id() */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static int current_attr = 0;        /* attr of current syntax word */", "static int current_id = 0;          /* ID of current char for syn_get_id() */", "static int current_trans_id = 0;    /* idem, transparency removed */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static int current_id = 0;          /* ID of current char for syn_get_id() */", "static int current_trans_id = 0;    /* idem, transparency removed */", "static int current_flags = 0;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Methods of combining two clusters"], "readability/old_style_comment"]
["src/nvim/syntax.c", [" */", "#define CLUSTER_REPLACE     1   /* replace first list with second */", "#define CLUSTER_ADD         2   /* add second list to first */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define CLUSTER_REPLACE     1   /* replace first list with second */", "#define CLUSTER_ADD         2   /* add second list to first */", "#define CLUSTER_SUBTRACT    3   /* subtract second list from first */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define CLUSTER_ADD         2   /* add second list to first */", "#define CLUSTER_SUBTRACT    3   /* subtract second list from first */", ""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Syntax group IDs have different types:"], "readability/old_style_comment"]
["src/nvim/syntax.c", [" */", "#define SYNID_ALLBUT    MAX_HL_ID   /* syntax group ID for contains=ALLBUT */", "#define SYNID_TOP       21000       /* syntax group ID for contains=TOP */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define SYNID_ALLBUT    MAX_HL_ID   /* syntax group ID for contains=ALLBUT */", "#define SYNID_TOP       21000       /* syntax group ID for contains=TOP */", "#define SYNID_CONTAINED 22000       /* syntax group ID for contains=CONTAINED */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define SYNID_TOP       21000       /* syntax group ID for contains=TOP */", "#define SYNID_CONTAINED 22000       /* syntax group ID for contains=CONTAINED */", "#define SYNID_CLUSTER   23000       /* first syntax group ID for clusters */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define SYNID_CONTAINED 22000       /* syntax group ID for contains=CONTAINED */", "#define SYNID_CLUSTER   23000       /* first syntax group ID for clusters */", ""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "#define MAX_SYN_INC_TAG 999         /* maximum before the above overflow */", "#define MAX_CLUSTER_ID  (32767 - SYNID_CLUSTER)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Annoying Hack(TM):  \":syn include\" needs this pointer to pass to"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Another Annoying Hack(TM):  To prevent rules from other \":syn include\"'d"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * In a hashtable item \"hi_key\" points to \"keyword\" in a keyentry."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["#define KE2HIKEY(kp)  ((kp)->keyword)", "#define HIKEY2KE(p)   ((keyentry_T *)((p) - (dumkey.keyword - (char_u *)&dumkey)))", "#define HI2KE(hi)      HIKEY2KE((hi)->hi_key)"], "whitespace/line_length"]
["src/nvim/syntax.c", ["", "/*", " * To reduce the time spent in keepend(), remember at which level in the state"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "static int next_seqnr = 1;              /* value to use for si_seqnr */", ""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * The next possible match in the current line for any pattern is remembered,"], "readability/old_style_comment"]
["src/nvim/syntax.c", [" */", "static int next_match_col;              /* column for start of next match */", "static lpos_T next_match_m_endpos;      /* position for end of next match */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static int next_match_col;              /* column for start of next match */", "static lpos_T next_match_m_endpos;      /* position for end of next match */", "static lpos_T next_match_h_startpos;  /* pos. for highl. start of next match */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static lpos_T next_match_m_endpos;      /* position for end of next match */", "static lpos_T next_match_h_startpos;  /* pos. for highl. start of next match */", "static lpos_T next_match_h_endpos;      /* pos. for highl. end of next match */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static lpos_T next_match_h_startpos;  /* pos. for highl. start of next match */", "static lpos_T next_match_h_endpos;      /* pos. for highl. end of next match */", "static int next_match_idx;              /* index of matched item */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static lpos_T next_match_h_endpos;      /* pos. for highl. end of next match */", "static int next_match_idx;              /* index of matched item */", "static long next_match_flags;           /* flags for next match */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static int next_match_idx;              /* index of matched item */", "static long next_match_flags;           /* flags for next match */", "static lpos_T next_match_eos_pos;       /* end of start pattn (start region) */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static long next_match_flags;           /* flags for next match */", "static lpos_T next_match_eos_pos;       /* end of start pattn (start region) */", "static lpos_T next_match_eoe_pos;       /* pos. for end of end pattern */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static lpos_T next_match_eos_pos;       /* end of start pattn (start region) */", "static lpos_T next_match_eoe_pos;       /* pos. for end of end pattern */", "static int next_match_end_idx;          /* ID of group for end pattn or zero */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static lpos_T next_match_eoe_pos;       /* pos. for end of end pattern */", "static int next_match_end_idx;          /* ID of group for end pattn or zero */", "static reg_extmatch_T *next_match_extmatch = NULL;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * A state stack is an array of integers or stateitem_T, stored in a"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * The current state (within the line) of the recognition engine."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "static int syn_time_on = FALSE;", "# define IF_SYN_TIME(p) (p)"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Start the syntax recognition for a line.  This function is normally called"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  int dist;", "  static int changedtick = 0;           /* remember the last change ID */", ""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * After switching buffers, invalidate current_state."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Allocate syntax stack when needed."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  syn_stack_alloc();", "  if (syn_block->b_sst_array == NULL)", "    return;             /* out of memory */"], "readability/braces"]
["src/nvim/syntax.c", ["  if (syn_block->b_sst_array == NULL)", "    return;             /* out of memory */", "  syn_block->b_sst_lasttick = display_tick;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * If the state of the end of the previous line is useful, store it."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (!current_state_stored) {", "      ++current_lnum;", "      (void)store_current_state();"], "readability/increment"]
["src/nvim/syntax.c", ["", "    /*", "     * If the current_lnum is now the same as \"lnum\", keep the current"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["     */", "    if (current_lnum != lnum)", "      invalidate_current_state();"], "readability/braces"]
["src/nvim/syntax.c", ["      invalidate_current_state();", "  } else", "    invalidate_current_state();"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * Try to synchronize from a saved state in b_sst_array[]."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (INVALID_STATE(&current_state) && syn_block->b_sst_array != NULL) {", "    /* Find last valid saved state before start_lnum. */", "    for (p = syn_block->b_sst_first; p != NULL; p = p->sst_next) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        last_valid = p;", "        if (p->sst_lnum >= lnum - syn_block->b_syn_sync_minlines)", "          last_min_valid = p;"], "readability/braces"]
["src/nvim/syntax.c", ["    }", "    if (last_min_valid != NULL)", "      load_current_state(last_min_valid);"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * If \"lnum\" is before or far beyond a line with a saved state, need to"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    syn_sync(wp, lnum, last_valid);", "    if (current_lnum == 1)", "      /* First line is always valid, no matter \"minlines\". */"], "readability/braces"]
["src/nvim/syntax.c", ["    if (current_lnum == 1)", "      /* First line is always valid, no matter \"minlines\". */", "      first_stored = 1;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      first_stored = 1;", "    else", "      /* Need to parse \"minlines\" lines before state can be considered"], "readability/braces"]
["src/nvim/syntax.c", ["    else", "      /* Need to parse \"minlines\" lines before state can be considered", "       * valid to store. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      first_stored = current_lnum + syn_block->b_syn_sync_minlines;", "  } else", "    first_stored = current_lnum;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * Advance from the sync point or saved state until the current line."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  if (syn_block->b_sst_len <= Rows)", "    dist = 999999;"], "readability/braces"]
["src/nvim/syntax.c", ["    dist = 999999;", "  else", "    dist = syn_buf->b_ml.ml_line_count / (syn_block->b_sst_len - Rows) + 1;"], "readability/braces"]
["src/nvim/syntax.c", ["", "    /* If we parsed at least \"minlines\" lines or started at a valid", "     * state, the current state is considered valid. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (current_lnum >= first_stored) {", "      /* Check if the saved state entry is for the current line and is", "       * equal to the current state.  If so, then validate all saved"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["       * states that depended on a change before the parsed line. */", "      if (prev == NULL)", "        prev = syn_stack_find_entry(current_lnum - 1);"], "readability/braces"]
["src/nvim/syntax.c", ["        prev = syn_stack_find_entry(current_lnum - 1);", "      if (prev == NULL)", "        sp = syn_block->b_sst_first;"], "readability/braces"]
["src/nvim/syntax.c", ["        sp = syn_block->b_sst_first;", "      else", "        sp = prev;"], "readability/braces"]
["src/nvim/syntax.c", ["        sp = prev;", "      while (sp != NULL && sp->sst_lnum < current_lnum)", "        sp = sp->sst_next;"], "readability/braces"]
["src/nvim/syntax.c", ["        while (sp != NULL && sp->sst_change_lnum <= parsed_lnum) {", "          if (sp->sst_lnum <= lnum)", "            /* valid state before desired line, use this one */"], "readability/braces"]
["src/nvim/syntax.c", ["          if (sp->sst_lnum <= lnum)", "            /* valid state before desired line, use this one */", "            prev = sp;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["            prev = sp;", "          else if (sp->sst_change_lnum == 0)", "            /* past saved states depending on change, break here. */"], "readability/braces"]
["src/nvim/syntax.c", ["          else if (sp->sst_change_lnum == 0)", "            /* past saved states depending on change, break here. */", "            break;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      }", "      /* Store the state at this line when it's the first one, the line", "       * where we start parsing, or some distance from the previously"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["       * saved state.  But only when parsed at least 'minlines'. */", "      else if (prev == NULL", "               || current_lnum == lnum"], "whitespace/newline"]
["src/nvim/syntax.c", ["", "    /* This can take a long time: break when CTRL-C pressed.  The current", "     * state will be wrong then. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * We cannot simply discard growarrays full of state_items or buf_states; we"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Cleanup the current_state stack."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Try to find a synchronisation point for line \"lnum\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Clear any current state that might be hanging around."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Start at least \"minlines\" back.  Default starting point for parsing is"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  if (syn_block->b_syn_sync_minlines > start_lnum)", "    start_lnum = 1;"], "readability/braces"]
["src/nvim/syntax.c", ["    start_lnum = 1;", "  else {", "    if (syn_block->b_syn_sync_minlines == 1)"], "readability/braces"]
["src/nvim/syntax.c", ["    start_lnum = 1;", "  else {", "    if (syn_block->b_syn_sync_minlines == 1)"], "readability/braces"]
["src/nvim/syntax.c", ["  else {", "    if (syn_block->b_syn_sync_minlines == 1)", "      lnum = 1;"], "readability/braces"]
["src/nvim/syntax.c", ["      lnum = 1;", "    else if (syn_block->b_syn_sync_minlines < 10)", "      lnum = syn_block->b_syn_sync_minlines * 2;"], "readability/braces"]
["src/nvim/syntax.c", ["      lnum = syn_block->b_syn_sync_minlines * 2;", "    else", "      lnum = syn_block->b_syn_sync_minlines * 3 / 2;"], "readability/braces"]
["src/nvim/syntax.c", ["      lnum = syn_block->b_syn_sync_minlines * 3 / 2;", "    if (syn_block->b_syn_sync_maxlines != 0", "        && lnum > syn_block->b_syn_sync_maxlines)"], "readability/braces"]
["src/nvim/syntax.c", ["      lnum = syn_block->b_syn_sync_maxlines;", "    if (lnum >= start_lnum)", "      start_lnum = 1;"], "readability/braces"]
["src/nvim/syntax.c", ["      start_lnum = 1;", "    else", "      start_lnum -= lnum;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * 1. Search backwards for the end of a C-style comment."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (syn_block->b_syn_sync_flags & SF_CCOMMENT) {", "    /* Need to make syn_buf the current buffer for a moment, to be able to", "     * use find_start_comment(). */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * Skip lines that end in a backslash."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["     */", "    for (; start_lnum > 1; --start_lnum) {", "      line = ml_get(start_lnum - 1);"], "readability/increment"]
["src/nvim/syntax.c", ["      line = ml_get(start_lnum - 1);", "      if (*line == NUL || *(line + STRLEN(line) - 1) != '\\\\')", "        break;"], "readability/braces"]
["src/nvim/syntax.c", ["", "    /* set cursor to start of search */", "    cursor_save = wp->w_cursor;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * If the line is inside a comment, need to find the syntax item that"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (find_start_comment((int)syn_block->b_syn_sync_maxlines) != NULL) {", "      for (idx = syn_block->b_syn_patterns.ga_len; --idx >= 0; )", "        if (SYN_ITEMS(syn_block)[idx].sp_syn.id"], "readability/braces"]
["src/nvim/syntax.c", ["", "    /* restore cursor and buffer */", "    wp->w_cursor = cursor_save;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  }", "  /*", "   * 2. Search backwards for given sync patterns."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  else if (syn_block->b_syn_sync_flags & SF_MATCH) {", "    if (syn_block->b_syn_sync_maxlines != 0"], "whitespace/newline"]
["src/nvim/syntax.c", ["  else if (syn_block->b_syn_sync_flags & SF_MATCH) {", "    if (syn_block->b_syn_sync_maxlines != 0", "        && start_lnum > syn_block->b_syn_sync_maxlines)"], "readability/braces"]
["src/nvim/syntax.c", ["      break_lnum = start_lnum - syn_block->b_syn_sync_maxlines;", "    else", "      break_lnum = 0;"], "readability/braces"]
["src/nvim/syntax.c", ["    while (--lnum > break_lnum) {", "      /* This can take a long time: break when CTRL-C pressed. */", "      line_breakcheck();"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "      /* Check if we have run into a valid saved state stack now. */", "      if (last_valid != NULL && lnum == last_valid->sst_lnum) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "      /*", "       * Check if the previous line has the line-continuation pattern."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["       */", "      if (lnum > 1 && syn_match_linecont(lnum - 1))", "        continue;"], "readability/braces"]
["src/nvim/syntax.c", ["", "      /*", "       * Start with nothing on the state stack"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "      for (current_lnum = lnum; current_lnum < end_lnum; ++current_lnum) {", "        syn_start_line();"], "readability/increment"]
["src/nvim/syntax.c", ["            if (cur_si->si_m_endpos.lnum > start_lnum) {", "              /* ignore match that goes to after where started */", "              current_lnum = end_lnum;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["            if (cur_si->si_idx < 0) {", "              /* Cannot happen? */", "              found_flags = 0;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["            found_m_endpos = cur_si->si_m_endpos;", "            /*", "             * Continue after the match (be aware of a zero-length"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["              current_col = found_m_endpos.col;", "              if (current_lnum >= end_lnum)", "                break;"], "readability/braces"]
["src/nvim/syntax.c", ["                break;", "            } else if (found_m_endpos.col > current_col)", "              current_col = found_m_endpos.col;"], "readability/braces"]
["src/nvim/syntax.c", ["              current_col = found_m_endpos.col;", "            else", "              ++current_col;"], "readability/braces"]
["src/nvim/syntax.c", ["            else", "              ++current_col;", ""], "readability/increment"]
["src/nvim/syntax.c", ["", "            /* syn_current_attr() will have skipped the check for", "             * an item that ends here, need to do that now.  Be"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["            prev_current_col = current_col;", "            if (syn_getcurline()[current_col] != NUL)", "              ++current_col;"], "readability/braces"]
["src/nvim/syntax.c", ["            if (syn_getcurline()[current_col] != NUL)", "              ++current_col;", "            check_state_ends();"], "readability/increment"]
["src/nvim/syntax.c", ["            current_col = prev_current_col;", "          } else", "            break;"], "readability/braces"]
["src/nvim/syntax.c", ["", "      /*", "       * If a sync point was encountered, break here."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (found_flags) {", "        /*", "         * Put the item that was specified by the sync point on the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "        /*", "         * When using \"grouphere\", continue from the sync point"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["            cur_si->si_h_startpos.col = found_current_col;", "            update_si_end(cur_si, (int)current_col, TRUE);", "            check_keepend();"], "readability/bool"]
["src/nvim/syntax.c", ["", "    /* Ran into start of the file or exceeded maximum number of lines */", "    if (lnum <= break_lnum) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Return TRUE if the line-continuation pattern matches in line \"lnum\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Prepare the current state for the start of a line."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["{", "  current_finished = FALSE;", "  current_col = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /*", "   * Need to update the end of a start/skip/end that continues from the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (!GA_EMPTY(&current_state)) {", "    syn_update_ends(TRUE);", "    check_state_ends();"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Check for items in the stack that need their end updated."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (startofline) {", "    /* Check for a match carried over from a previous line with a", "     * contained region.  The match ends as soon as the region ends. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["     * contained region.  The match ends as soon as the region ends. */", "    for (int i = 0; i < current_state.ga_len; ++i) {", "      cur_si = &CUR_STATE(i);"], "readability/increment"]
["src/nvim/syntax.c", ["        cur_si->si_h_endpos = cur_si->si_m_endpos;", "        cur_si->si_ends = TRUE;", "      }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /*", "   * Need to update the end of a start/skip/end that continues from the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  int i = current_state.ga_len - 1;", "  if (keepend_level >= 0)", "    for (; i > keepend_level; --i)"], "readability/braces"]
["src/nvim/syntax.c", ["  if (keepend_level >= 0)", "    for (; i > keepend_level; --i)", "      if (CUR_STATE(i).si_flags & HL_EXTEND)"], "readability/braces"]
["src/nvim/syntax.c", ["  if (keepend_level >= 0)", "    for (; i > keepend_level; --i)", "      if (CUR_STATE(i).si_flags & HL_EXTEND)"], "readability/increment"]
["src/nvim/syntax.c", ["    for (; i > keepend_level; --i)", "      if (CUR_STATE(i).si_flags & HL_EXTEND)", "        break;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  seen_keepend = FALSE;", "  for (; i < current_state.ga_len; ++i) {"], "readability/bool"]
["src/nvim/syntax.c", ["  seen_keepend = FALSE;", "  for (; i < current_state.ga_len; ++i) {", "    cur_si = &CUR_STATE(i);"], "readability/increment"]
["src/nvim/syntax.c", ["        || (i == current_state.ga_len - 1 && startofline)) {", "      cur_si->si_h_startpos.col = 0;            /* start highl. in col 0 */", "      cur_si->si_h_startpos.lnum = current_lnum;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "      if (!(cur_si->si_flags & HL_MATCHCONT))", "        update_si_end(cur_si, (int)current_col, !startofline);"], "readability/braces"]
["src/nvim/syntax.c", ["", "      if (!startofline && (cur_si->si_flags & HL_KEEPEND))", "        seen_keepend = TRUE;"], "readability/braces"]
["src/nvim/syntax.c", ["      if (!startofline && (cur_si->si_flags & HL_KEEPEND))", "        seen_keepend = TRUE;", "    }"], "readability/bool"]
["src/nvim/syntax.c", ["", "/****************************************", " * Handling of the state stack cache."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * EXPLANATION OF THE SYNTAX STATE STACK CACHE"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["}", "/*", " * Free b_sst_array[] for buffer \"buf\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* When using \"syntax\" fold method, must update all folds. */", "  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Allocate the syntax state stack for syn_buf when needed."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  len = syn_buf->b_ml.ml_line_count / SST_DIST + Rows * 2;", "  if (len < SST_MIN_ENTRIES)", "    len = SST_MIN_ENTRIES;"], "readability/braces"]
["src/nvim/syntax.c", ["    len = SST_MIN_ENTRIES;", "  else if (len > SST_MAX_ENTRIES)", "    len = SST_MAX_ENTRIES;"], "readability/braces"]
["src/nvim/syntax.c", ["  if (syn_block->b_sst_len > len * 2 || syn_block->b_sst_len < len) {", "    /* Allocate 50% too much, to avoid reallocating too often. */", "    len = syn_buf->b_ml.ml_line_count;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    len = (len + len / 2) / SST_DIST + Rows * 2;", "    if (len < SST_MIN_ENTRIES)", "      len = SST_MIN_ENTRIES;"], "readability/braces"]
["src/nvim/syntax.c", ["      len = SST_MIN_ENTRIES;", "    else if (len > SST_MAX_ENTRIES)", "      len = SST_MAX_ENTRIES;"], "readability/braces"]
["src/nvim/syntax.c", ["    if (syn_block->b_sst_array != NULL) {", "      /* When shrinking the array, cleanup the existing stack.", "       * Make sure that all valid entries fit in the new array. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["       * Make sure that all valid entries fit in the new array. */", "      while (syn_block->b_sst_len - syn_block->b_sst_freecount + 2 > len", "             && syn_stack_cleanup())"], "readability/braces"]
["src/nvim/syntax.c", ["             && syn_stack_cleanup())", "        ;", "      if (len < syn_block->b_sst_len - syn_block->b_sst_freecount + 2)"], "whitespace/semicolon"]
["src/nvim/syntax.c", ["        ;", "      if (len < syn_block->b_sst_len - syn_block->b_sst_freecount + 2)", "        len = syn_block->b_sst_len - syn_block->b_sst_freecount + 2;"], "readability/braces"]
["src/nvim/syntax.c", ["    if (syn_block->b_sst_array != NULL) {", "      /* Move the states from the old array to the new one. */", "      for (from = syn_block->b_sst_first; from != NULL;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["           from = from->sst_next) {", "        ++to;", "        *to = *from;"], "readability/increment"]
["src/nvim/syntax.c", ["", "    /* Create the list of free entries. */", "    syn_block->b_sst_firstfree = to + 1;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    syn_block->b_sst_firstfree = to + 1;", "    while (++to < sstp + len)", "      to->sst_next = to + 1;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Check for changes in a buffer to affect stored syntax states.  Uses the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (n <= buf->b_mod_bot) {", "        /* this state is inside the changed area, remove it */", "        np = p->sst_next;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        np = p->sst_next;", "        if (prev == NULL)", "          block->b_sst_first = np;"], "readability/braces"]
["src/nvim/syntax.c", ["          block->b_sst_first = np;", "        else", "          prev->sst_next = np;"], "readability/braces"]
["src/nvim/syntax.c", ["      }", "      /* This state is below the changed area.  Remember the line", "       * that needs to be parsed before this entry can be made valid"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (p->sst_change_lnum != 0 && p->sst_change_lnum > buf->b_mod_top) {", "        if (p->sst_change_lnum + buf->b_mod_xlines > buf->b_mod_top)", "          p->sst_change_lnum += buf->b_mod_xlines;"], "readability/braces"]
["src/nvim/syntax.c", ["          p->sst_change_lnum += buf->b_mod_xlines;", "        else", "          p->sst_change_lnum = buf->b_mod_top;"], "readability/braces"]
["src/nvim/syntax.c", ["      }", "      if (p->sst_change_lnum == 0", "          || p->sst_change_lnum < buf->b_mod_bot)"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Reduce the number of entries in the state stack for syn_buf."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  int dist;", "  int retval = FALSE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["", "  /* Compute normal distance between non-displayed entries. */", "  if (syn_block->b_sst_len <= Rows)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  /* Compute normal distance between non-displayed entries. */", "  if (syn_block->b_sst_len <= Rows)", "    dist = 999999;"], "readability/braces"]
["src/nvim/syntax.c", ["    dist = 999999;", "  else", "    dist = syn_buf->b_ml.ml_line_count / (syn_block->b_sst_len - Rows) + 1;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * Go through the list to find the \"tick\" for the oldest entry that can"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  tick = syn_block->b_sst_lasttick;", "  above = FALSE;", "  prev = syn_block->b_sst_first;"], "readability/bool"]
["src/nvim/syntax.c", ["      if (p->sst_tick > syn_block->b_sst_lasttick) {", "        if (!above || p->sst_tick < tick)", "          tick = p->sst_tick;"], "readability/braces"]
["src/nvim/syntax.c", ["          tick = p->sst_tick;", "        above = TRUE;", "      } else if (!above && p->sst_tick < tick)"], "readability/bool"]
["src/nvim/syntax.c", ["        above = TRUE;", "      } else if (!above && p->sst_tick < tick)", "        tick = p->sst_tick;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * Go through the list to make the entries for the oldest tick at an"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (p->sst_tick == tick && prev->sst_lnum + dist > p->sst_lnum) {", "      /* Move this entry from used list to free list */", "      prev->sst_next = p->sst_next;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      p = prev;", "      retval = TRUE;", "    }"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Free the allocated memory for a syn_state item."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  block->b_sst_firstfree = p;", "  ++block->b_sst_freecount;", "}"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Find an entry in the list of state stacks at or before \"lnum\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  for (p = syn_block->b_sst_first; p != NULL; prev = p, p = p->sst_next) {", "    if (p->sst_lnum == lnum)", "      return p;"], "readability/braces"]
["src/nvim/syntax.c", ["      return p;", "    if (p->sst_lnum > lnum)", "      break;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Try saving the current state in b_sst_array[]."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * If the current state contains a start or end pattern that continues"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  for (i = current_state.ga_len - 1; i >= 0; --i) {", "    cur_si = &CUR_STATE(i);"], "readability/increment"]
["src/nvim/syntax.c", ["    cur_si = &CUR_STATE(i);", "    if (cur_si->si_h_startpos.lnum >= current_lnum", "        || cur_si->si_m_endpos.lnum >= current_lnum"], "readability/braces"]
["src/nvim/syntax.c", ["    if (sp != NULL) {", "      /* find \"sp\" in the list and remove it */", "      if (syn_block->b_sst_first == sp)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      /* find \"sp\" in the list and remove it */", "      if (syn_block->b_sst_first == sp)", "        /* it's the first entry */"], "readability/braces"]
["src/nvim/syntax.c", ["      if (syn_block->b_sst_first == sp)", "        /* it's the first entry */", "        syn_block->b_sst_first = sp->sst_next;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        syn_block->b_sst_first = sp->sst_next;", "      else {", "        /* find the entry just before this one to adjust sst_next */"], "readability/braces"]
["src/nvim/syntax.c", ["        syn_block->b_sst_first = sp->sst_next;", "      else {", "        /* find the entry just before this one to adjust sst_next */"], "readability/braces"]
["src/nvim/syntax.c", ["      else {", "        /* find the entry just before this one to adjust sst_next */", "        for (p = syn_block->b_sst_first; p != NULL; p = p->sst_next)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        /* find the entry just before this one to adjust sst_next */", "        for (p = syn_block->b_sst_first; p != NULL; p = p->sst_next)", "          if (p->sst_next == sp)"], "readability/braces"]
["src/nvim/syntax.c", ["        for (p = syn_block->b_sst_first; p != NULL; p = p->sst_next)", "          if (p->sst_next == sp)", "            break;"], "readability/braces"]
["src/nvim/syntax.c", ["            break;", "        if (p != NULL)          /* just in case */", "          p->sst_next = sp->sst_next;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["            break;", "        if (p != NULL)          /* just in case */", "          p->sst_next = sp->sst_next;"], "readability/braces"]
["src/nvim/syntax.c", ["  } else if (sp == NULL || sp->sst_lnum != current_lnum)   {", "    /*", "     * Add a new entry"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["     */", "    /* If no free items, cleanup the array first. */", "    if (syn_block->b_sst_freecount == 0) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      (void)syn_stack_cleanup();", "      /* \"sp\" may have been moved to the freelist now */", "      sp = syn_stack_find_entry(current_lnum);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    }", "    /* Still no free items?  Must be a strange problem... */", "    if (syn_block->b_sst_freecount == 0)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    /* Still no free items?  Must be a strange problem... */", "    if (syn_block->b_sst_freecount == 0)", "      sp = NULL;"], "readability/braces"]
["src/nvim/syntax.c", ["      sp = NULL;", "    else {", "      /* Take the first item from the free list and put it in the used"], "readability/braces"]
["src/nvim/syntax.c", ["      sp = NULL;", "    else {", "      /* Take the first item from the free list and put it in the used"], "readability/braces"]
["src/nvim/syntax.c", ["    else {", "      /* Take the first item from the free list and put it in the used", "       * list, after *sp */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      syn_block->b_sst_firstfree = p->sst_next;", "      --syn_block->b_sst_freecount;", "      if (sp == NULL) {"], "readability/increment"]
["src/nvim/syntax.c", ["      if (sp == NULL) {", "        /* Insert in front of the list */", "        p->sst_next = syn_block->b_sst_first;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      } else {", "        /* insert in list after *sp */", "        p->sst_next = sp->sst_next;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (sp != NULL) {", "    /* When overwriting an existing state stack, clear it first */", "    clear_syn_state(sp);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (current_state.ga_len > SST_FIX_STATES) {", "      /* Need to clear it, might be something remaining from when the", "       * length was less than SST_FIX_STATES. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      bp = SYN_STATE_P(&(sp->sst_union.sst_ga));", "    } else", "      bp = sp->sst_union.sst_stack;"], "readability/braces"]
["src/nvim/syntax.c", ["      bp = sp->sst_union.sst_stack;", "    for (i = 0; i < sp->sst_stacksize; ++i) {", "      bp[i].bs_idx = CUR_STATE(i).si_idx;"], "readability/increment"]
["src/nvim/syntax.c", ["  }", "  current_state_stored = TRUE;", "  return sp;"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Copy a state stack from \"from\" in b_sst_array[] to current_state;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    ga_grow(&current_state, from->sst_stacksize);", "    if (from->sst_stacksize > SST_FIX_STATES)", "      bp = SYN_STATE_P(&(from->sst_union.sst_ga));"], "readability/braces"]
["src/nvim/syntax.c", ["      bp = SYN_STATE_P(&(from->sst_union.sst_ga));", "    else", "      bp = from->sst_union.sst_stack;"], "readability/braces"]
["src/nvim/syntax.c", ["      bp = from->sst_union.sst_stack;", "    for (i = 0; i < from->sst_stacksize; ++i) {", "      CUR_STATE(i).si_idx = bp[i].bs_idx;"], "readability/increment"]
["src/nvim/syntax.c", ["      CUR_STATE(i).si_extmatch = ref_extmatch(bp[i].bs_extmatch);", "      if (keepend_level < 0 && (CUR_STATE(i).si_flags & HL_KEEPEND))", "        keepend_level = i;"], "readability/braces"]
["src/nvim/syntax.c", ["        keepend_level = i;", "      CUR_STATE(i).si_ends = FALSE;", "      CUR_STATE(i).si_m_lnum = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["      CUR_STATE(i).si_m_lnum = 0;", "      if (CUR_STATE(i).si_idx >= 0)", "        CUR_STATE(i).si_next_list ="], "readability/braces"]
["src/nvim/syntax.c", ["          (SYN_ITEMS(syn_block)[CUR_STATE(i).si_idx]).sp_next_list;", "      else", "        CUR_STATE(i).si_next_list = NULL;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Compare saved state stack \"*sp\" with the current state."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* First a quick check if the stacks have the same size end nextlist. */", "  if (sp->sst_stacksize != current_state.ga_len"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      || sp->sst_next_list != current_next_list) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /* Need to compare all states on both stacks. */", "  if (sp->sst_stacksize > SST_FIX_STATES)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  /* Need to compare all states on both stacks. */", "  if (sp->sst_stacksize > SST_FIX_STATES)", "    bp = SYN_STATE_P(&(sp->sst_union.sst_ga));"], "readability/braces"]
["src/nvim/syntax.c", ["    bp = SYN_STATE_P(&(sp->sst_union.sst_ga));", "  else", "    bp = sp->sst_union.sst_stack;"], "readability/braces"]
["src/nvim/syntax.c", ["  for (i = current_state.ga_len; --i >= 0; ) {", "    /* If the item has another index the state is different. */", "    if (bp[i].bs_idx != CUR_STATE(i).si_idx)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    /* If the item has another index the state is different. */", "    if (bp[i].bs_idx != CUR_STATE(i).si_idx)", "      break;"], "readability/braces"]
["src/nvim/syntax.c", ["    }", "    /* When the extmatch pointers are different, the strings in", "     * them can still be the same.  Check if the extmatch"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    six = CUR_STATE(i).si_extmatch;", "    /* If one of the extmatch pointers is NULL the states are", "     * different. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["     * different. */", "    if (bsx == NULL || six == NULL)", "      break;"], "readability/braces"]
["src/nvim/syntax.c", ["    int j;", "    for (j = 0; j < NSUBEXP; ++j) {", "      /* Check each referenced match string. They must all be"], "readability/increment"]
["src/nvim/syntax.c", ["    for (j = 0; j < NSUBEXP; ++j) {", "      /* Check each referenced match string. They must all be", "       * equal. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (bsx->matches[j] != six->matches[j]) {", "        /* If the pointer is different it can still be the", "         * same text.  Compare the strings, ignore case when"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    }", "    if (j != NSUBEXP)", "      break;"], "readability/braces"]
["src/nvim/syntax.c", ["  }", "  if (i < 0)", "    return TRUE;"], "readability/braces"]
["src/nvim/syntax.c", ["  if (i < 0)", "    return TRUE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * We stop parsing syntax above line \"lnum\".  If the stored state at or below"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  sp = syn_stack_find_entry(lnum);", "  if (sp != NULL && sp->sst_lnum < lnum)", "    sp = sp->sst_next;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  if (sp != NULL && sp->sst_change_lnum != 0)", "    sp->sst_change_lnum = lnum;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * End of handling of the state stack."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  clear_current_state();", "  current_state.ga_itemsize = 0;        /* mark current_state invalid */", "  current_next_list = NULL;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Return TRUE if the syntax at start of lnum changed since last time."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["{", "  int retval = TRUE;", "  synstate_T  *sp;"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /*", "   * Check the state stack when:"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (sp != NULL && sp->sst_lnum == lnum) {", "      /*", "       * finish the previous line (needed when not all of the line was"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "      /*", "       * Compare the current state with the previously saved state of"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["       */", "      if (syn_stack_equal(sp))", "        retval = FALSE;"], "readability/braces"]
["src/nvim/syntax.c", ["      if (syn_stack_equal(sp))", "        retval = FALSE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["", "      /*", "       * Store the current state in b_sst_array[] for later use."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["       */", "      ++current_lnum;", "      (void)store_current_state();"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Finish the current line."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Return highlight attributes for next character."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  if (can_spell != NULL)", "    /* Default: Only do spelling when there is no @Spell cluster or when"], "readability/braces"]
["src/nvim/syntax.c", ["  if (can_spell != NULL)", "    /* Default: Only do spelling when there is no @Spell cluster or when", "     * \":syn spell toplevel\" was used. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* check for out of memory situation */", "  if (syn_block->b_sst_array == NULL)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  /* check for out of memory situation */", "  if (syn_block->b_sst_array == NULL)", "    return 0;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /* After 'synmaxcol' the attribute is always zero. */", "  if (syn_buf->b_p_smc > 0 && col >= (colnr_T)syn_buf->b_p_smc) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* Make sure current_state is valid */", "  if (INVALID_STATE(&current_state))"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  /* Make sure current_state is valid */", "  if (INVALID_STATE(&current_state))", "    validate_current_state();"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * Skip from the current column to \"col\", get the attributes for \"col\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Get syntax attributes for current_lnum, current_col."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * No character, no attributes!  Past end of line?"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (line[current_col] == NUL && current_col != 0) {", "    /*", "     * If we found a match after the last column, use it."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    current_finished = TRUE;", "    current_state_stored = FALSE;"], "readability/bool"]
["src/nvim/syntax.c", ["    current_finished = TRUE;", "    current_state_stored = FALSE;", "    return 0;"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /* if the current or next character is NUL, we will finish the line now */", "  if (line[current_col] == NUL || line[current_col + 1] == NUL) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (line[current_col] == NUL || line[current_col + 1] == NUL) {", "    current_finished = TRUE;", "    current_state_stored = FALSE;"], "readability/bool"]
["src/nvim/syntax.c", ["    current_finished = TRUE;", "    current_state_stored = FALSE;", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /*", "   * When in the previous column there was a match but it could not be used"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* Init the list of zero-width matches with a nextlist.  This is used to", "   * avoid matching the same item in the same position twice. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Repeat matching keywords and patterns, to find contained items at the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * 1. Check for a current state."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["     */", "    if (current_state.ga_len)", "      cur_si = &CUR_STATE(current_state.ga_len - 1);"], "readability/braces"]
["src/nvim/syntax.c", ["      cur_si = &CUR_STATE(current_state.ga_len - 1);", "    else", "      cur_si = NULL;"], "readability/braces"]
["src/nvim/syntax.c", ["        || cur_si->si_cont_list != NULL) {", "      /*", "       * 2. Check for keywords, if on a keyword char after a non-keyword"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["              cur_si->si_h_startpos.lnum = current_lnum;", "              cur_si->si_h_startpos.col = 0;            /* starts right away */", "              cur_si->si_m_endpos.lnum = current_lnum;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["              cur_si->si_h_endpos.col = endcol;", "              cur_si->si_ends = TRUE;", "              cur_si->si_end_idx = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["              cur_si->si_cchar = cchar;", "              if (current_state.ga_len > 1)", "                cur_si->si_flags |="], "readability/braces"]
["src/nvim/syntax.c", ["", "      /*", "       * 3. Check for patterns (only if no keyword found)."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (syn_id == 0 && syn_block->b_syn_patterns.ga_len) {", "        /*", "         * If we didn't check for a match yet, or we are past it, check"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        if (next_match_idx < 0 || next_match_col < (int)current_col) {", "          /*", "           * Check all relevant patterns for a match at this"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["           */", "          next_match_idx = 0;                   /* no match in this line yet */", "          next_match_col = MAXCOL;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["            if (       spp->sp_syncing == syncing", "                       && (displaying || !(spp->sp_flags & HL_DISPLAY))", "                       && (spp->sp_type == SPTYPE_MATCH"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                       && (displaying || !(spp->sp_flags & HL_DISPLAY))", "                       && (spp->sp_type == SPTYPE_MATCH", "                           || spp->sp_type == SPTYPE_START)"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                           || spp->sp_type == SPTYPE_START)", "                       && (current_next_list != NULL", "                           ? in_id_list(NULL, current_next_list,"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                           ? in_id_list(NULL, current_next_list,", "                               &spp->sp_syn, 0)", "                           : (cur_si == NULL"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                              : in_id_list(cur_si,", "                                  cur_si->si_cont_list, &spp->sp_syn,", "                                  spp->sp_flags & HL_CONTAINED)))) {"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                                  cur_si->si_cont_list, &spp->sp_syn,", "                                  spp->sp_flags & HL_CONTAINED)))) {", "              /* If we already tried matching in this line, and"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                           ? in_id_list(NULL, current_next_list,", "                               &spp->sp_syn, 0)", "                           : (cur_si == NULL"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                              : in_id_list(cur_si,", "                                  cur_si->si_cont_list, &spp->sp_syn,", "                                  spp->sp_flags & HL_CONTAINED)))) {"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                                  cur_si->si_cont_list, &spp->sp_syn,", "                                  spp->sp_flags & HL_CONTAINED)))) {", "              /* If we already tried matching in this line, and"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                           ? in_id_list(NULL, current_next_list,", "                               &spp->sp_syn, 0)", "                           : (cur_si == NULL"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                              : in_id_list(cur_si,", "                                  cur_si->si_cont_list, &spp->sp_syn,", "                                  spp->sp_flags & HL_CONTAINED)))) {"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                                  cur_si->si_cont_list, &spp->sp_syn,", "                                  spp->sp_flags & HL_CONTAINED)))) {", "              /* If we already tried matching in this line, and"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                              : in_id_list(cur_si,", "                                  cur_si->si_cont_list, &spp->sp_syn,", "                                  spp->sp_flags & HL_CONTAINED)))) {"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                                  cur_si->si_cont_list, &spp->sp_syn,", "                                  spp->sp_flags & HL_CONTAINED)))) {", "              /* If we already tried matching in this line, and"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                                  spp->sp_flags & HL_CONTAINED)))) {", "              /* If we already tried matching in this line, and", "               * there isn't a match before next_match_col, skip"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["               * this item. */", "              if (spp->sp_line_id == current_line_id", "                  && spp->sp_startcol >= next_match_col)"], "readability/braces"]
["src/nvim/syntax.c", ["              if (!r) {", "                /* no match in this line, try another one */", "                spp->sp_startcol = MAXCOL;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "              /*", "               * Compute the first column of the match."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["              syn_add_start_off(&pos, &regmatch,", "                  spp, SPO_MS_OFF, -1);", "              if (pos.lnum > current_lnum) {"], "whitespace/alignment"]
["src/nvim/syntax.c", ["              if (pos.lnum > current_lnum) {", "                /* must have used end of match in a next line,", "                 * we can't handle that */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "              /* remember the next column where this pattern", "               * matches in the current line */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "              /*", "               * If a previously found match starts at a lower"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["               */", "              if (startcol >= next_match_col)", "                continue;"], "readability/braces"]
["src/nvim/syntax.c", ["", "              /*", "               * If we matched this pattern at this position"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "              /* Compute the highlight start. */", "              syn_add_start_off(&hl_startpos, &regmatch,"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["              syn_add_start_off(&hl_startpos, &regmatch,", "                  spp, SPO_HS_OFF, -1);", ""], "whitespace/alignment"]
["src/nvim/syntax.c", ["", "              /* Compute the region start. */", "              /* Default is to use the end of the match. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["              /* Compute the region start. */", "              /* Default is to use the end of the match. */", "              syn_add_end_off(&eos_pos, &regmatch,"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["              syn_add_end_off(&eos_pos, &regmatch,", "                  spp, SPO_RS_OFF, 0);", ""], "whitespace/alignment"]
["src/nvim/syntax.c", ["", "              /*", "               * Grab the external submatches before they get"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["              flags = 0;", "              eoe_pos.lnum = 0;                 /* avoid warning */", "              eoe_pos.col = 0;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "              /*", "               * For a \"oneline\" the end must be found in the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["                find_endpos(idx, &startpos, &endpos, &hl_endpos,", "                    &flags, &eoe_pos, &end_idx, cur_extmatch);", "                if (endpos.lnum == 0)"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                    &flags, &eoe_pos, &end_idx, cur_extmatch);", "                if (endpos.lnum == 0)", "                  continue;                         /* not found */"], "readability/braces"]
["src/nvim/syntax.c", ["                if (endpos.lnum == 0)", "                  continue;                         /* not found */", "              }"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["              }", "              /*", "               * For a \"match\" the size must be > 0 after the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["               */", "              else if (spp->sp_type == SPTYPE_MATCH) {", "                syn_add_end_off(&hl_endpos, &regmatch, spp,"], "whitespace/newline"]
["src/nvim/syntax.c", ["                syn_add_end_off(&hl_endpos, &regmatch, spp,", "                    SPO_HE_OFF, 0);", "                syn_add_end_off(&endpos, &regmatch, spp,"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                syn_add_end_off(&endpos, &regmatch, spp,", "                    SPO_ME_OFF, 0);", "                if (endpos.lnum == current_lnum"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                    && (int)endpos.col + syncing < startcol) {", "                  /*", "                   * If an empty string is matched, may need"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "              /*", "               * keep the best match so far in next_match_*"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["               */", "              /* Highlighting must start after startpos and end", "               * before endpos. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["               * before endpos. */", "              if (hl_startpos.lnum == current_lnum", "                  && (int)hl_startpos.col < startcol)"], "readability/braces"]
["src/nvim/syntax.c", ["", "        /*", "         * If we found a match at the current column, use it."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "          /* When a zero-width item matched which has a nextgroup,", "           * don't push the item but set nextgroup. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "            /* Add the index to a list, so that we can check", "             * later that we don't match it again (and cause an"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * Handle searching for nextgroup match."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (current_next_list != NULL && !keep_next_list) {", "      /*", "       * If a nextgroup was not found, continue looking for one if:"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        line = syn_getcurline();", "        if (((current_next_flags & HL_SKIPWHITE)", "             && ascii_iswhite(line[current_col]))"], "readability/braces"]
["src/nvim/syntax.c", ["", "      /*", "       * If a nextgroup was found: Use it, and continue looking for"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    }", "", "  } while (found_match);"], "whitespace/blank_line"]
["src/nvim/syntax.c", ["", "  /*", "   * Use attributes from the current state, if within its highlighting."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (cur_si != NULL) {", "    for (int idx = current_state.ga_len - 1; idx >= 0; --idx) {", "      sip = &CUR_STATE(idx);"], "readability/increment"]
["src/nvim/syntax.c", ["", "      /*", "       * set \"can_spell\" to TRUE if spell checking is supposed to be"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (syn_block->b_spell_cluster_id == 0) {", "        /* There is no @Spell cluster: Do spelling for items without", "         * @NoSpell cluster. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["         * @NoSpell cluster. */", "        if (syn_block->b_nospell_cluster_id == 0", "            || current_trans_id == 0)"], "readability/braces"]
["src/nvim/syntax.c", ["          *can_spell = (syn_block->b_syn_spell != SYNSPL_NOTOP);", "        else {", "          sps.inc_tag = 0;"], "readability/braces"]
["src/nvim/syntax.c", ["          *can_spell = (syn_block->b_syn_spell != SYNSPL_NOTOP);", "        else {", "          sps.inc_tag = 0;"], "readability/braces"]
["src/nvim/syntax.c", ["      } else {", "        /* The @Spell cluster is defined: Do spelling in items with", "         * the @Spell cluster.  But not when @NoSpell is also there."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["         * was used. */", "        if (current_trans_id == 0)", "          *can_spell = (syn_block->b_syn_spell == SYNSPL_TOP);"], "readability/braces"]
["src/nvim/syntax.c", ["          *can_spell = (syn_block->b_syn_spell == SYNSPL_TOP);", "        else {", "          sps.inc_tag = 0;"], "readability/braces"]
["src/nvim/syntax.c", ["          *can_spell = (syn_block->b_syn_spell == SYNSPL_TOP);", "        else {", "          sps.inc_tag = 0;"], "readability/braces"]
["src/nvim/syntax.c", ["            sps.id = syn_block->b_nospell_cluster_id;", "            if (in_id_list(sip, sip->si_cont_list, &sps, 0))", "              *can_spell = false;"], "readability/braces"]
["src/nvim/syntax.c", ["", "    /*", "     * Check for end of current state (and the states before it) at the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["          && syn_getcurline()[current_col] != NUL) {", "        ++current_col;", "        check_state_ends();"], "readability/increment"]
["src/nvim/syntax.c", ["        check_state_ends();", "        --current_col;", "      }"], "readability/increment"]
["src/nvim/syntax.c", ["    }", "  } else if (can_spell != NULL)", "    /* Default: Only do spelling when there is no @Spell cluster or when"], "readability/braces"]
["src/nvim/syntax.c", ["  } else if (can_spell != NULL)", "    /* Default: Only do spelling when there is no @Spell cluster or when", "     * \":syn spell toplevel\" was used. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* nextgroup ends at end of line, unless \"skipnl\" or \"skipempty\" present */", "  if (current_next_list != NULL"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  if (!GA_EMPTY(&zero_width_next_ga))", "    ga_clear(&zero_width_next_ga);"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /* No longer need external matches.  But keep next_match_extmatch. */", "  unref_extmatch(re_extmatch_out);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Check if we already matched pattern \"idx\" at the current column."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        && CUR_STATE(i).si_idx == idx) {", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /* Zero-width matches with a nextgroup argument are not put on the syntax", "   * stack, and can only be matched once anyway. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (((int *)(gap->ga_data))[i] == idx) {", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Push the next match onto the stack."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Push the item in current_state stack;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  {", "    /*", "     * If it's a start-skip-end type that crosses lines, figure out how"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    cur_si->si_cchar = spp->sp_cchar;", "    if (current_state.ga_len > 1)", "      cur_si->si_flags |="], "readability/braces"]
["src/nvim/syntax.c", ["    if (spp->sp_type == SPTYPE_START && !(spp->sp_flags & HL_ONELINE)) {", "      /* Try to find the end pattern in the current line */", "      update_si_end(cur_si, (int)(next_match_m_endpos.col), TRUE);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      /* Try to find the end pattern in the current line */", "      update_si_end(cur_si, (int)(next_match_m_endpos.col), TRUE);", "      check_keepend();"], "readability/bool"]
["src/nvim/syntax.c", ["      cur_si->si_h_endpos = next_match_h_endpos;", "      cur_si->si_ends = TRUE;", "      cur_si->si_flags |= next_match_flags;"], "readability/bool"]
["src/nvim/syntax.c", ["    }", "    if (keepend_level < 0 && (cur_si->si_flags & HL_KEEPEND))", "      keepend_level = current_state.ga_len - 1;"], "readability/braces"]
["src/nvim/syntax.c", ["    save_flags = cur_si->si_flags & (HL_CONCEAL | HL_CONCEALENDS);", "    /*", "     * If the start pattern has another highlight group, push another item"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      cur_si->si_h_endpos = next_match_eos_pos;", "      cur_si->si_ends = TRUE;", "      cur_si->si_end_idx = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["      cur_si->si_flags |= save_flags;", "      if (cur_si->si_flags & HL_CONCEALENDS)", "        cur_si->si_flags |= HL_CONCEAL;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  next_match_idx = -1;          /* try other match next time */", ""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Check for end of current state (and the states before it)."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["                && cur_si->si_m_endpos.col <= current_col))) {", "      /*", "       * If there is an end pattern group ID, highlight the end pattern"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        cur_si->si_seqnr = next_seqnr++;", "        if (cur_si->si_flags & HL_CONCEALENDS)", "          cur_si->si_flags |= HL_CONCEAL;"], "readability/braces"]
["src/nvim/syntax.c", ["", "        /* nextgroup= should not match in the end pattern */", "        current_next_list = NULL;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "        /* what matches next may be different now, clear it */", "        next_match_idx = 0;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      } else {", "        /* handle next_list, unless at end of line and no \"skipnl\" or", "         * \"skipempty\" */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        current_next_flags = cur_si->si_flags;", "        if (!(current_next_flags & (HL_SKIPNL | HL_SKIPEMPTY))", "            && syn_getcurline()[current_col] == NUL)"], "readability/braces"]
["src/nvim/syntax.c", ["", "        /* When the ended item has \"extend\", another item with", "         * \"keepend\" now needs to check for its end. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "        if (GA_EMPTY(&current_state))", "          break;"], "readability/braces"]
["src/nvim/syntax.c", ["        if (had_extend && keepend_level >= 0) {", "          syn_update_ends(FALSE);", "          if (GA_EMPTY(&current_state))"], "readability/bool"]
["src/nvim/syntax.c", ["          syn_update_ends(FALSE);", "          if (GA_EMPTY(&current_state))", "            break;"], "readability/braces"]
["src/nvim/syntax.c", ["", "        /*", "         * Only for a region the search for the end continues after"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["            && !(cur_si->si_flags & (HL_MATCH | HL_KEEPEND))) {", "          update_si_end(cur_si, (int)current_col, TRUE);", "          check_keepend();"], "readability/bool"]
["src/nvim/syntax.c", ["          check_keepend();", "          if ((current_next_flags & HL_HAS_EOL)", "              && keepend_level < 0"], "readability/braces"]
["src/nvim/syntax.c", ["      }", "    } else", "      break;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Update an entry in the current_state stack for a match or region.  This"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* This should not happen... */", "  if (sip->si_idx < 0)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  /* This should not happen... */", "  if (sip->si_idx < 0)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["  spp = &(SYN_ITEMS(syn_block)[sip->si_idx]);", "  if (sip->si_flags & HL_MATCH)", "    sip->si_id = spp->sp_syn_match_id;"], "readability/braces"]
["src/nvim/syntax.c", ["    sip->si_id = spp->sp_syn_match_id;", "  else", "    sip->si_id = spp->sp_syn.id;"], "readability/braces"]
["src/nvim/syntax.c", ["  sip->si_trans_id = sip->si_id;", "  if (sip->si_flags & HL_MATCH)", "    sip->si_cont_list = NULL;"], "readability/braces"]
["src/nvim/syntax.c", ["    sip->si_cont_list = NULL;", "  else", "    sip->si_cont_list = spp->sp_cont_list;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * For transparent items, take attr from outer item."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      sip->si_trans_id = 0;", "      if (sip->si_cont_list == NULL)", "        sip->si_cont_list = ID_LIST_ALL;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Check the current stack for patterns with \"keepend\" flag."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * This check can consume a lot of time; only do it from the level where"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  if (keepend_level < 0)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * Find the last index of an \"extend\" item.  \"keepend\" items before that"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  for (i = current_state.ga_len - 1; i > keepend_level; --i)", "    if (CUR_STATE(i).si_flags & HL_EXTEND)"], "readability/braces"]
["src/nvim/syntax.c", ["   */", "  for (i = current_state.ga_len - 1; i > keepend_level; --i)", "    if (CUR_STATE(i).si_flags & HL_EXTEND)"], "readability/increment"]
["src/nvim/syntax.c", ["  for (i = current_state.ga_len - 1; i > keepend_level; --i)", "    if (CUR_STATE(i).si_flags & HL_EXTEND)", "      break;"], "readability/braces"]
["src/nvim/syntax.c", ["  maxpos_h.col = 0;", "  for (; i < current_state.ga_len; ++i) {", "    sip = &CUR_STATE(i);"], "readability/increment"]
["src/nvim/syntax.c", ["      limit_pos_zero(&sip->si_eoe_pos, &maxpos);", "      sip->si_ends = TRUE;", "    }"], "readability/bool"]
["src/nvim/syntax.c", ["    if (sip->si_ends && (sip->si_flags & HL_KEEPEND)) {", "      if (maxpos.lnum == 0", "          || maxpos.lnum > sip->si_m_endpos.lnum"], "readability/braces"]
["src/nvim/syntax.c", ["        maxpos = sip->si_m_endpos;", "      if (maxpos_h.lnum == 0", "          || maxpos_h.lnum > sip->si_h_endpos.lnum"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Update an entry in the current_state stack for a start-skip-end pattern."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    stateitem_T *sip,", "    int startcol,               /* where to start searching for the end */", "    int force                  /* when TRUE overrule a previous end */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    int startcol,               /* where to start searching for the end */", "    int force                  /* when TRUE overrule a previous end */", ")"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* return quickly for a keyword */", "  if (sip->si_idx < 0)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  /* return quickly for a keyword */", "  if (sip->si_idx < 0)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /* Don't update when it's already done.  Can be a match of an end pattern", "   * that started in a previous line.  Watch out: can also be a \"keepend\""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   * from a containing item. */", "  if (!force && sip->si_m_endpos.lnum >= current_lnum)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * We need to find the end of the region.  It may continue in the next"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  find_endpos(sip->si_idx, &startpos, &endpos, &hl_endpos,", "      &(sip->si_flags), &end_endpos, &end_idx, sip->si_extmatch);", ""], "whitespace/alignment"]
["src/nvim/syntax.c", ["  if (endpos.lnum == 0) {", "    /* No end pattern matched. */", "    if (SYN_ITEMS(syn_block)[sip->si_idx].sp_flags & HL_ONELINE) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (SYN_ITEMS(syn_block)[sip->si_idx].sp_flags & HL_ONELINE) {", "      /* a \"oneline\" never continues in the next line */", "      sip->si_ends = TRUE;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      /* a \"oneline\" never continues in the next line */", "      sip->si_ends = TRUE;", "      sip->si_m_endpos.lnum = current_lnum;"], "readability/bool"]
["src/nvim/syntax.c", ["    } else {", "      /* continues in the next line */", "      sip->si_ends = FALSE;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      /* continues in the next line */", "      sip->si_ends = FALSE;", "      sip->si_m_endpos.lnum = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["  } else {", "    /* match within this line */", "    sip->si_m_endpos = endpos;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    sip->si_eoe_pos = end_endpos;", "    sip->si_ends = TRUE;", "    sip->si_end_idx = end_idx;"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Add a new state to the current state stack."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Remove a state from the current_state stack."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    unref_extmatch(CUR_STATE(current_state.ga_len - 1).si_extmatch);", "    --current_state.ga_len;", "  }"], "readability/increment"]
["src/nvim/syntax.c", ["  }", "  /* after the end of a pattern, try matching a keyword or pattern */", "  next_match_idx = -1;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* if first state with \"keepend\" is popped, reset keepend_level */", "  if (keepend_level >= current_state.ga_len)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  /* if first state with \"keepend\" is popped, reset keepend_level */", "  if (keepend_level >= current_state.ga_len)", "    keepend_level = -1;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Find the end of a start/skip/end syntax region after \"startpos\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  regmmatch_T regmatch;", "  regmmatch_T best_regmatch;        /* startpos/endpos of best match */", "  lpos_T pos;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* just in case we are invoked for a keyword */", "  if (idx < 0)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  /* just in case we are invoked for a keyword */", "  if (idx < 0)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * Check for being called with a START pattern."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Find the SKIP or first END pattern after the last START pattern."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    spp = &(SYN_ITEMS(syn_block)[idx]);", "    if (spp->sp_type != SPTYPE_START)", "      break;"], "readability/braces"]
["src/nvim/syntax.c", ["      break;", "    ++idx;", "  }"], "readability/increment"]
["src/nvim/syntax.c", ["", "  /*", "   *\tLookup the SKIP pattern (if present)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    spp_skip = spp;", "    ++idx;", "  } else"], "readability/increment"]
["src/nvim/syntax.c", ["    ++idx;", "  } else", "    spp_skip = NULL;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /* Setup external matches for syn_regexec(). */", "  unref_extmatch(re_extmatch_in);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  for (;; ) {", "    /*", "     * Find end pattern that matches first after \"matchcol\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    best_idx = -1;", "    for (idx = start_idx; idx < syn_block->b_syn_patterns.ga_len; ++idx) {", "      int lc_col = matchcol;"], "readability/increment"]
["src/nvim/syntax.c", ["      spp = &(SYN_ITEMS(syn_block)[idx]);", "      if (spp->sp_type != SPTYPE_END)           /* past last END pattern */", "        break;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      spp = &(SYN_ITEMS(syn_block)[idx]);", "      if (spp->sp_type != SPTYPE_END)           /* past last END pattern */", "        break;"], "readability/braces"]
["src/nvim/syntax.c", ["      lc_col -= spp->sp_offsets[SPO_LC_OFF];", "      if (lc_col < 0)", "        lc_col = 0;"], "readability/braces"]
["src/nvim/syntax.c", ["", "    /*", "     * If all end patterns have been tried, and there is no match, the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["     */", "    if (best_idx == -1)", "      break;"], "readability/braces"]
["src/nvim/syntax.c", ["", "    /*", "     * If the skip pattern matches before the end pattern,"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "      if (lc_col < 0)", "        lc_col = 0;"], "readability/braces"]
["src/nvim/syntax.c", ["", "    /*", "     * Match from start pattern to end pattern."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    syn_add_end_off(m_endpos, &best_regmatch, spp, SPO_ME_OFF, 1);", "    /* can't end before the start */", "    if (m_endpos->lnum == startpos->lnum && m_endpos->col < startpos->col)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    /* can't end before the start */", "    if (m_endpos->lnum == startpos->lnum && m_endpos->col < startpos->col)", "      m_endpos->col = startpos->col;"], "readability/braces"]
["src/nvim/syntax.c", ["    syn_add_end_off(end_endpos, &best_regmatch, spp, SPO_HE_OFF, 1);", "    /* can't end before the start */", "    if (end_endpos->lnum == startpos->lnum"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    /* can't end before the start */", "    if (end_endpos->lnum == startpos->lnum", "        && end_endpos->col < startpos->col)"], "readability/braces"]
["src/nvim/syntax.c", ["      end_endpos->col = startpos->col;", "    /* can't end after the match */", "    limit_pos(end_endpos, m_endpos);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * If the end group is highlighted differently, adjust the pointers."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "      /* can't end before the start */", "      if (hl_endpos->lnum == startpos->lnum"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      /* can't end before the start */", "      if (hl_endpos->lnum == startpos->lnum", "          && hl_endpos->col < startpos->col)"], "readability/braces"]
["src/nvim/syntax.c", ["", "      /* now the match ends where the highlighting ends, it is turned", "       * into the matchgroup for the end */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    had_match = TRUE;", "    break;"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /* no match for an END pattern in this line */", "  if (!had_match)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  /* no match for an END pattern in this line */", "  if (!had_match)", "    m_endpos->lnum = 0;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /* Remove external matches. */", "  unref_extmatch(re_extmatch_in);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Limit \"pos\" not to be after \"limit\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["{", "  if (pos->lnum > limit->lnum)", "    *pos = *limit;"], "readability/braces"]
["src/nvim/syntax.c", ["    *pos = *limit;", "  else if (pos->lnum == limit->lnum && pos->col > limit->col)", "    pos->col = limit->col;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Limit \"pos\" not to be after \"limit\", unless pos->lnum is zero."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["{", "  if (pos->lnum == 0)", "    *pos = *limit;"], "readability/braces"]
["src/nvim/syntax.c", ["    *pos = *limit;", "  else", "    limit_pos(pos, limit);"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Add offset to matched text for end of match or highlight."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  }", "  /* Don't go past the end of the line.  Matters for \"rs=e+2\" when there", "   * is a matchgroup. Watch out for match with last NL in the buffer. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   * is a matchgroup. Watch out for match with last NL in the buffer. */", "  if (result->lnum > syn_buf->b_ml.ml_line_count)", "    col = 0;"], "readability/braces"]
["src/nvim/syntax.c", ["    col = 0;", "  else if (off != 0) {", "    base = ml_get_buf(syn_buf, result->lnum, FALSE);"], "readability/braces"]
["src/nvim/syntax.c", ["  else if (off != 0) {", "    base = ml_get_buf(syn_buf, result->lnum, FALSE);", "    p = base + col;"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Add offset to matched text for start of match or highlight."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (result->lnum > syn_buf->b_ml.ml_line_count) {", "    /* a \"\\n\" at the end of the pattern may take us below the last line */", "    result->lnum = syn_buf->b_ml.ml_line_count;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    result->lnum = syn_buf->b_ml.ml_line_count;", "    col = (int)STRLEN(ml_get_buf(syn_buf, result->lnum, FALSE));", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["  if (off != 0) {", "    base = ml_get_buf(syn_buf, result->lnum, FALSE);", "    p = base + col;"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Get current line in syntax buffer."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["{", "  return ml_get_buf(syn_buf, current_lnum, FALSE);", "}"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Call vim_regexec() to find a match with \"rmp\" in \"syn_buf\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", [" */", "static int syn_regexec(regmmatch_T *rmp, linenr_T lnum, colnr_T col, syn_time_T *st)", "{"], "whitespace/line_length"]
["src/nvim/syntax.c", ["    }", "    ++st->count;", "    if (r > 0)"], "readability/increment"]
["src/nvim/syntax.c", ["    ++st->count;", "    if (r > 0)", "      ++st->match;"], "readability/braces"]
["src/nvim/syntax.c", ["    if (r > 0)", "      ++st->match;", "  }"], "readability/increment"]
["src/nvim/syntax.c", ["    rmp->endpos[0].lnum += lnum;", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Check one position in a line for a matching keyword."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  hashitem_T *hi = hash_find(ht, keyword);", "  if (!HASHITEM_EMPTY(hi))", "    for (keyentry_T *kp = HI2KE(hi); kp != NULL; kp = kp->ke_next) {"], "readability/braces"]
["src/nvim/syntax.c", ["          : (cur_si == NULL", "            ? !(kp->flags & HL_CONTAINED)", "            : in_id_list(cur_si, cur_si->si_cont_list,"], "whitespace/alignment"]
["src/nvim/syntax.c", ["            ? !(kp->flags & HL_CONTAINED)", "            : in_id_list(cur_si, cur_si->si_cont_list,", "                         &kp->k_syn, kp->flags & HL_CONTAINED))) {"], "whitespace/alignment"]
["src/nvim/syntax.c", ["          : (cur_si == NULL", "            ? !(kp->flags & HL_CONTAINED)", "            : in_id_list(cur_si, cur_si->si_cont_list,"], "whitespace/alignment"]
["src/nvim/syntax.c", ["            ? !(kp->flags & HL_CONTAINED)", "            : in_id_list(cur_si, cur_si->si_cont_list,", "                         &kp->k_syn, kp->flags & HL_CONTAINED))) {"], "whitespace/alignment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax conceal\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  eap->nextcmd = find_nextcmd(arg);", "  if (eap->skip)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax case\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  eap->nextcmd = find_nextcmd(arg);", "  if (eap->skip)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["  eap->nextcmd = find_nextcmd(arg);", "  if (eap->skip)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax spell\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  eap->nextcmd = find_nextcmd(arg);", "  if (eap->skip)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Clear all syntax info for one buffer."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* free the keywords */", "  clear_keywtab(&block->b_keywtab);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* free the syntax patterns */", "  for (int i = block->b_syn_patterns.ga_len; --i >= 0; ) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* free the syntax clusters */", "  for (int i = block->b_syn_clusters.ga_len; --i >= 0; ) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* free the stored states */", "  syn_stack_free_all(block);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* Reset the counter for \":syn include\" */", "  running_syn_inc_tag = 0;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Get rid of ownsyntax for window \"wp\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Clear syncing info for one buffer."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["{", "  /* free the syntax patterns */", "  for (int i = curwin->w_s->b_syn_patterns.ga_len; --i >= 0; ) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  syn_stack_free_all(curwin->w_s);              /* Need to recompute all syntax. */", "}"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  syn_stack_free_all(curwin->w_s);              /* Need to recompute all syntax. */", "}"], "whitespace/line_length"]
["src/nvim/syntax.c", ["", "/*", " * Remove one pattern from the buffer's pattern list."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  spp = &(SYN_ITEMS(block)[idx]);", "  if (spp->sp_flags & HL_FOLD)", "    --block->b_syn_folditems;"], "readability/braces"]
["src/nvim/syntax.c", ["  if (spp->sp_flags & HL_FOLD)", "    --block->b_syn_folditems;", "  syn_clear_pattern(block, idx);"], "readability/increment"]
["src/nvim/syntax.c", ["  memmove(spp, spp + 1,", "      sizeof(synpat_T) * (block->b_syn_patterns.ga_len - idx - 1));", "  --block->b_syn_patterns.ga_len;"], "whitespace/alignment"]
["src/nvim/syntax.c", ["      sizeof(synpat_T) * (block->b_syn_patterns.ga_len - idx - 1));", "  --block->b_syn_patterns.ga_len;", "}"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Clear and free one syntax pattern.  When clearing all, must be called from"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  vim_regfree(SYN_ITEMS(block)[i].sp_prog);", "  /* Only free sp_cont_list and sp_next_list of first start pattern */", "  if (i == 0 || SYN_ITEMS(block)[i - 1].sp_type != SPTYPE_START) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Clear and free one syntax cluster."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax clear\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  eap->nextcmd = find_nextcmd(arg);", "  if (eap->skip)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * We have to disable this within \":syn include @group filename\","], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  if (curwin->w_s->b_syn_topgrp != 0)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["  if (ends_excmd(*arg)) {", "    /*", "     * No argument: Clear all syntax items."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["     */", "    if (syncing)", "      syntax_sync_clear();"], "readability/braces"]
["src/nvim/syntax.c", ["      syntax_sync_clear();", "    else {", "      syntax_clear(curwin->w_s);"], "readability/braces"]
["src/nvim/syntax.c", ["      syntax_sync_clear();", "    else {", "      syntax_clear(curwin->w_s);"], "readability/braces"]
["src/nvim/syntax.c", ["  } else {", "    /*", "     * Clear the group IDs that are in the argument."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["          break;", "        } else", "          syn_clear_one(id, syncing);"], "readability/braces"]
["src/nvim/syntax.c", ["  redraw_curbuf_later(SOME_VALID);", "  syn_stack_free_all(curwin->w_s);              /* Need to recompute all syntax. */", "}"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  redraw_curbuf_later(SOME_VALID);", "  syn_stack_free_all(curwin->w_s);              /* Need to recompute all syntax. */", "}"], "whitespace/line_length"]
["src/nvim/syntax.c", ["", "/*", " * Clear one syntax group for the current buffer."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* Clear keywords only when not \":syn sync clear group-name\" */", "  if (!syncing) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* clear the patterns for \"id\" */", "  for (int idx = curwin->w_s->b_syn_patterns.ga_len; --idx >= 0; ) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    spp = &(SYN_ITEMS(curwin->w_s)[idx]);", "    if (spp->sp_syn.id != id || spp->sp_syncing != syncing)", "      continue;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax on\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax enable\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax reset\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax manual\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax off\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax [list]\" command: list current syntax words."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    exarg_T *eap,", "    int syncing                        /* when TRUE: list syncing items */", ")"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  eap->nextcmd = find_nextcmd(arg);", "  if (eap->skip)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["    }", "  } else", "    MSG_PUTS_TITLE(_(\"\\n--- Syntax items ---\"));"], "readability/braces"]
["src/nvim/syntax.c", ["  if (ends_excmd(*arg)) {", "    /*", "     * No argument: List all group IDs and all syntax clusters."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    }", "    for (int id = 0; id < curwin->w_s->b_syn_clusters.ga_len && !got_int; ++id) {", "      syn_list_cluster(id);"], "whitespace/line_length"]
["src/nvim/syntax.c", ["    }", "    for (int id = 0; id < curwin->w_s->b_syn_clusters.ga_len && !got_int; ++id) {", "      syn_list_cluster(id);"], "readability/increment"]
["src/nvim/syntax.c", ["  } else {", "    /*", "     * List the group IDs and syntax clusters that are in the argument."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        int id = syn_scl_namen2id(arg + 1, (int)(arg_end - arg - 1));", "        if (id == 0)", "          EMSG2(_(\"E392: No such syntax cluster: %s\"), arg);"], "readability/braces"]
["src/nvim/syntax.c", ["          EMSG2(_(\"E392: No such syntax cluster: %s\"), arg);", "        else", "          syn_list_cluster(id - SYNID_CLUSTER);"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * List one syntax item, for \":syntax\" or \"syntax list syntax_name\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  static struct name_list namelist1[] =", "  {", "    {HL_DISPLAY, \"display\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["  {", "    {HL_DISPLAY, \"display\"},", "    {HL_CONTAINED, \"contained\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["  {", "    {HL_DISPLAY, \"display\"},", "    {HL_CONTAINED, \"contained\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_DISPLAY, \"display\"},", "    {HL_CONTAINED, \"contained\"},", "    {HL_ONELINE, \"oneline\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_DISPLAY, \"display\"},", "    {HL_CONTAINED, \"contained\"},", "    {HL_ONELINE, \"oneline\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_CONTAINED, \"contained\"},", "    {HL_ONELINE, \"oneline\"},", "    {HL_KEEPEND, \"keepend\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_CONTAINED, \"contained\"},", "    {HL_ONELINE, \"oneline\"},", "    {HL_KEEPEND, \"keepend\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_ONELINE, \"oneline\"},", "    {HL_KEEPEND, \"keepend\"},", "    {HL_EXTEND, \"extend\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_ONELINE, \"oneline\"},", "    {HL_KEEPEND, \"keepend\"},", "    {HL_EXTEND, \"extend\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_KEEPEND, \"keepend\"},", "    {HL_EXTEND, \"extend\"},", "    {HL_EXCLUDENL, \"excludenl\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_KEEPEND, \"keepend\"},", "    {HL_EXTEND, \"extend\"},", "    {HL_EXCLUDENL, \"excludenl\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_EXTEND, \"extend\"},", "    {HL_EXCLUDENL, \"excludenl\"},", "    {HL_TRANSP, \"transparent\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_EXTEND, \"extend\"},", "    {HL_EXCLUDENL, \"excludenl\"},", "    {HL_TRANSP, \"transparent\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_EXCLUDENL, \"excludenl\"},", "    {HL_TRANSP, \"transparent\"},", "    {HL_FOLD, \"fold\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_EXCLUDENL, \"excludenl\"},", "    {HL_TRANSP, \"transparent\"},", "    {HL_FOLD, \"fold\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_TRANSP, \"transparent\"},", "    {HL_FOLD, \"fold\"},", "    {HL_CONCEAL, \"conceal\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_TRANSP, \"transparent\"},", "    {HL_FOLD, \"fold\"},", "    {HL_CONCEAL, \"conceal\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_FOLD, \"fold\"},", "    {HL_CONCEAL, \"conceal\"},", "    {HL_CONCEALENDS, \"concealends\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_FOLD, \"fold\"},", "    {HL_CONCEAL, \"conceal\"},", "    {HL_CONCEALENDS, \"concealends\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_CONCEAL, \"conceal\"},", "    {HL_CONCEALENDS, \"concealends\"},", "    {0, NULL}"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_CONCEAL, \"conceal\"},", "    {HL_CONCEALENDS, \"concealends\"},", "    {0, NULL}"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_CONCEALENDS, \"concealends\"},", "    {0, NULL}", "  };"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_CONCEALENDS, \"concealends\"},", "    {0, NULL}", "  };"], "whitespace/braces"]
["src/nvim/syntax.c", ["  static struct name_list namelist2[] =", "  {", "    {HL_SKIPWHITE, \"skipwhite\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["  {", "    {HL_SKIPWHITE, \"skipwhite\"},", "    {HL_SKIPNL, \"skipnl\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["  {", "    {HL_SKIPWHITE, \"skipwhite\"},", "    {HL_SKIPNL, \"skipnl\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_SKIPWHITE, \"skipwhite\"},", "    {HL_SKIPNL, \"skipnl\"},", "    {HL_SKIPEMPTY, \"skipempty\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_SKIPWHITE, \"skipwhite\"},", "    {HL_SKIPNL, \"skipnl\"},", "    {HL_SKIPEMPTY, \"skipempty\"},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_SKIPNL, \"skipnl\"},", "    {HL_SKIPEMPTY, \"skipempty\"},", "    {0, NULL}"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_SKIPNL, \"skipnl\"},", "    {HL_SKIPEMPTY, \"skipempty\"},", "    {0, NULL}"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_SKIPEMPTY, \"skipempty\"},", "    {0, NULL}", "  };"], "whitespace/braces"]
["src/nvim/syntax.c", ["    {HL_SKIPEMPTY, \"skipempty\"},", "    {0, NULL}", "  };"], "whitespace/braces"]
["src/nvim/syntax.c", ["    } else if (spp->sp_type == SPTYPE_START)   {", "      while (SYN_ITEMS(curwin->w_s)[idx].sp_type == SPTYPE_START)", "        put_pattern(\"start\", '=', &SYN_ITEMS(curwin->w_s)[idx++], attr);"], "readability/braces"]
["src/nvim/syntax.c", ["        put_pattern(\"start\", '=', &SYN_ITEMS(curwin->w_s)[idx++], attr);", "      if (SYN_ITEMS(curwin->w_s)[idx].sp_type == SPTYPE_SKIP)", "        put_pattern(\"skip\", '=', &SYN_ITEMS(curwin->w_s)[idx++], attr);"], "readability/braces"]
["src/nvim/syntax.c", ["        put_pattern(\"skip\", '=', &SYN_ITEMS(curwin->w_s)[idx++], attr);", "      while (idx < curwin->w_s->b_syn_patterns.ga_len", "             && SYN_ITEMS(curwin->w_s)[idx].sp_type == SPTYPE_END)"], "readability/braces"]
["src/nvim/syntax.c", ["        put_pattern(\"end\", '=', &SYN_ITEMS(curwin->w_s)[idx++], attr);", "      --idx;", "      msg_putchar(' ');"], "readability/increment"]
["src/nvim/syntax.c", ["      msg_putchar(' ');", "      if (spp->sp_sync_idx >= 0)", "        msg_outtrans(HL_TABLE()[SYN_ITEMS(curwin->w_s)"], "readability/braces"]
["src/nvim/syntax.c", ["                                [spp->sp_sync_idx].sp_syn.id - 1].sg_name);", "      else", "        MSG_PUTS(\"NONE\");"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /* list the link, if there is one */", "  if (HL_TABLE()[id - 1].sg_link && (did_header || link_only) && !got_int) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  for (i = 0; nlist[i].flag != 0; ++i)", "    if (flags & nlist[i].flag) {"], "readability/braces"]
["src/nvim/syntax.c", ["", "  for (i = 0; nlist[i].flag != 0; ++i)", "    if (flags & nlist[i].flag) {"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * List one syntax cluster, for \":syntax\" or \"syntax list syntax_name\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* slight hack:  roughly duplicate the guts of syn_list_header() */", "  msg_putchar('\\n');"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  if (msg_col >= endcol)        /* output at least one space */", "    endcol = msg_col + 1;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  if (msg_col >= endcol)        /* output at least one space */", "    endcol = msg_col + 1;"], "readability/braces"]
["src/nvim/syntax.c", ["    endcol = msg_col + 1;", "  if (Columns <= endcol)        /* avoid hang for tiny window */", "    endcol = Columns - 1;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    endcol = msg_col + 1;", "  if (Columns <= endcol)        /* avoid hang for tiny window */", "    endcol = Columns - 1;"], "readability/braces"]
["src/nvim/syntax.c", ["      msg_outtrans(SYN_CLSTR(curwin->w_s)[scl_id].scl_name);", "    } else", "      msg_outtrans(HL_TABLE()[*p - 1].sg_name);"], "readability/braces"]
["src/nvim/syntax.c", ["      msg_outtrans(HL_TABLE()[*p - 1].sg_name);", "    if (p[1])", "      msg_putchar(',');"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /* May have to write \"matchgroup=group\" */", "  if (last_matchgroup != spp->sp_syn_match_id) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    msg_putchar('=');", "    if (last_matchgroup == 0)", "      msg_outtrans((char_u *)\"NONE\");"], "readability/braces"]
["src/nvim/syntax.c", ["      msg_outtrans((char_u *)\"NONE\");", "    else", "      msg_outtrans(HL_TABLE()[last_matchgroup - 1].sg_name);"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /* output the pattern, in between a char that is not in the pattern */", "  for (i = 0; vim_strchr(spp->sp_pattern, sepchars[i]) != NULL; )"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  /* output the pattern, in between a char that is not in the pattern */", "  for (i = 0; vim_strchr(spp->sp_pattern, sepchars[i]) != NULL; )", "    if (sepchars[++i] == NUL) {"], "readability/braces"]
["src/nvim/syntax.c", ["    if (sepchars[++i] == NUL) {", "      i = 0;            /* no good char found, just use the first one */", "      break;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (i != SPO_LC_OFF) {", "      if (spp->sp_off_flags & mask)", "        msg_putchar('s');"], "readability/braces"]
["src/nvim/syntax.c", ["        msg_putchar('s');", "      else", "        msg_putchar('e');"], "readability/braces"]
["src/nvim/syntax.c", ["        msg_putchar('e');", "      if (n > 0)", "        msg_putchar('+');"], "readability/braces"]
["src/nvim/syntax.c", ["  todo = (int)ht->ht_used;", "  for (hi = ht->ht_array; todo > 0; ++hi) {", "    if (HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/syntax.c", ["    }", "    --todo;", "    kp_prev = NULL;"], "readability/increment"]
["src/nvim/syntax.c", ["        if (kp_prev == NULL) {", "          if (kp_next == NULL)", "            hash_remove(ht, hi);"], "readability/braces"]
["src/nvim/syntax.c", ["            hash_remove(ht, hi);", "          else", "            hi->hi_key = KE2HIKEY(kp_next);"], "readability/braces"]
["src/nvim/syntax.c", ["            hi->hi_key = KE2HIKEY(kp_next);", "        } else", "          kp_prev->ke_next = kp_next;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Clear a whole keyword table."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  todo = (int)ht->ht_used;", "  for (hi = ht->ht_array; todo > 0; ++hi) {", "    if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/syntax.c", ["    if (!HASHITEM_EMPTY(hi)) {", "      --todo;", "      for (kp = HI2KE(hi); kp != NULL; kp = kp_next) {"], "readability/increment"]
["src/nvim/syntax.c", ["  if (cont_in_list != NULL) {", "    curwin->w_s->b_syn_containedin = TRUE;", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Get the start and end of the group name argument."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["static char_u *", "get_group_name (", "    char_u *arg,               /* start of the argument */"], "whitespace/parens"]
["src/nvim/syntax.c", ["get_group_name (", "    char_u *arg,               /* start of the argument */", "    char_u **name_end         /* pointer to end of the name */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    char_u *arg,               /* start of the argument */", "    char_u **name_end         /* pointer to end of the name */", ")"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Check if there are enough arguments.  The first argument may be a"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  if (ends_excmd(*arg) || *rest == NUL)", "    return NULL;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Check for syntax command option arguments."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    int flags;", "  } flagtab[] = { {\"cCoOnNtTaAiInNeEdD\",      0,      HL_CONTAINED},", "                  {\"oOnNeElLiInNeE\",          0,      HL_ONELINE},"], "whitespace/braces"]
["src/nvim/syntax.c", ["    int flags;", "  } flagtab[] = { {\"cCoOnNtTaAiInNeEdD\",      0,      HL_CONTAINED},", "                  {\"oOnNeElLiInNeE\",          0,      HL_ONELINE},"], "whitespace/braces"]
["src/nvim/syntax.c", ["  } flagtab[] = { {\"cCoOnNtTaAiInNeEdD\",      0,      HL_CONTAINED},", "                  {\"oOnNeElLiInNeE\",          0,      HL_ONELINE},", "                  {\"kKeEeEpPeEnNdD\",          0,      HL_KEEPEND},"], "whitespace/braces"]
["src/nvim/syntax.c", ["  } flagtab[] = { {\"cCoOnNtTaAiInNeEdD\",      0,      HL_CONTAINED},", "                  {\"oOnNeElLiInNeE\",          0,      HL_ONELINE},", "                  {\"kKeEeEpPeEnNdD\",          0,      HL_KEEPEND},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"oOnNeElLiInNeE\",          0,      HL_ONELINE},", "                  {\"kKeEeEpPeEnNdD\",          0,      HL_KEEPEND},", "                  {\"eExXtTeEnNdD\",            0,      HL_EXTEND},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"oOnNeElLiInNeE\",          0,      HL_ONELINE},", "                  {\"kKeEeEpPeEnNdD\",          0,      HL_KEEPEND},", "                  {\"eExXtTeEnNdD\",            0,      HL_EXTEND},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"kKeEeEpPeEnNdD\",          0,      HL_KEEPEND},", "                  {\"eExXtTeEnNdD\",            0,      HL_EXTEND},", "                  {\"eExXcClLuUdDeEnNlL\",      0,      HL_EXCLUDENL},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"kKeEeEpPeEnNdD\",          0,      HL_KEEPEND},", "                  {\"eExXtTeEnNdD\",            0,      HL_EXTEND},", "                  {\"eExXcClLuUdDeEnNlL\",      0,      HL_EXCLUDENL},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"eExXtTeEnNdD\",            0,      HL_EXTEND},", "                  {\"eExXcClLuUdDeEnNlL\",      0,      HL_EXCLUDENL},", "                  {\"tTrRaAnNsSpPaArReEnNtT\",  0,      HL_TRANSP},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"eExXtTeEnNdD\",            0,      HL_EXTEND},", "                  {\"eExXcClLuUdDeEnNlL\",      0,      HL_EXCLUDENL},", "                  {\"tTrRaAnNsSpPaArReEnNtT\",  0,      HL_TRANSP},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"eExXcClLuUdDeEnNlL\",      0,      HL_EXCLUDENL},", "                  {\"tTrRaAnNsSpPaArReEnNtT\",  0,      HL_TRANSP},", "                  {\"sSkKiIpPnNlL\",            0,      HL_SKIPNL},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"eExXcClLuUdDeEnNlL\",      0,      HL_EXCLUDENL},", "                  {\"tTrRaAnNsSpPaArReEnNtT\",  0,      HL_TRANSP},", "                  {\"sSkKiIpPnNlL\",            0,      HL_SKIPNL},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"tTrRaAnNsSpPaArReEnNtT\",  0,      HL_TRANSP},", "                  {\"sSkKiIpPnNlL\",            0,      HL_SKIPNL},", "                  {\"sSkKiIpPwWhHiItTeE\",      0,      HL_SKIPWHITE},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"tTrRaAnNsSpPaArReEnNtT\",  0,      HL_TRANSP},", "                  {\"sSkKiIpPnNlL\",            0,      HL_SKIPNL},", "                  {\"sSkKiIpPwWhHiItTeE\",      0,      HL_SKIPWHITE},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"sSkKiIpPnNlL\",            0,      HL_SKIPNL},", "                  {\"sSkKiIpPwWhHiItTeE\",      0,      HL_SKIPWHITE},", "                  {\"sSkKiIpPeEmMpPtTyY\",      0,      HL_SKIPEMPTY},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"sSkKiIpPnNlL\",            0,      HL_SKIPNL},", "                  {\"sSkKiIpPwWhHiItTeE\",      0,      HL_SKIPWHITE},", "                  {\"sSkKiIpPeEmMpPtTyY\",      0,      HL_SKIPEMPTY},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"sSkKiIpPwWhHiItTeE\",      0,      HL_SKIPWHITE},", "                  {\"sSkKiIpPeEmMpPtTyY\",      0,      HL_SKIPEMPTY},", "                  {\"gGrRoOuUpPhHeErReE\",      0,      HL_SYNC_HERE},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"sSkKiIpPwWhHiItTeE\",      0,      HL_SKIPWHITE},", "                  {\"sSkKiIpPeEmMpPtTyY\",      0,      HL_SKIPEMPTY},", "                  {\"gGrRoOuUpPhHeErReE\",      0,      HL_SYNC_HERE},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"sSkKiIpPeEmMpPtTyY\",      0,      HL_SKIPEMPTY},", "                  {\"gGrRoOuUpPhHeErReE\",      0,      HL_SYNC_HERE},", "                  {\"gGrRoOuUpPtThHeErReE\",    0,      HL_SYNC_THERE},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"sSkKiIpPeEmMpPtTyY\",      0,      HL_SKIPEMPTY},", "                  {\"gGrRoOuUpPhHeErReE\",      0,      HL_SYNC_HERE},", "                  {\"gGrRoOuUpPtThHeErReE\",    0,      HL_SYNC_THERE},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"gGrRoOuUpPhHeErReE\",      0,      HL_SYNC_HERE},", "                  {\"gGrRoOuUpPtThHeErReE\",    0,      HL_SYNC_THERE},", "                  {\"dDiIsSpPlLaAyY\",          0,      HL_DISPLAY},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"gGrRoOuUpPhHeErReE\",      0,      HL_SYNC_HERE},", "                  {\"gGrRoOuUpPtThHeErReE\",    0,      HL_SYNC_THERE},", "                  {\"dDiIsSpPlLaAyY\",          0,      HL_DISPLAY},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"gGrRoOuUpPtThHeErReE\",    0,      HL_SYNC_THERE},", "                  {\"dDiIsSpPlLaAyY\",          0,      HL_DISPLAY},", "                  {\"fFoOlLdD\",                0,      HL_FOLD},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"gGrRoOuUpPtThHeErReE\",    0,      HL_SYNC_THERE},", "                  {\"dDiIsSpPlLaAyY\",          0,      HL_DISPLAY},", "                  {\"fFoOlLdD\",                0,      HL_FOLD},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"dDiIsSpPlLaAyY\",          0,      HL_DISPLAY},", "                  {\"fFoOlLdD\",                0,      HL_FOLD},", "                  {\"cCoOnNcCeEaAlL\",          0,      HL_CONCEAL},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"dDiIsSpPlLaAyY\",          0,      HL_DISPLAY},", "                  {\"fFoOlLdD\",                0,      HL_FOLD},", "                  {\"cCoOnNcCeEaAlL\",          0,      HL_CONCEAL},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"fFoOlLdD\",                0,      HL_FOLD},", "                  {\"cCoOnNcCeEaAlL\",          0,      HL_CONCEAL},", "                  {\"cCoOnNcCeEaAlLeEnNdDsS\",  0,      HL_CONCEALENDS},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"fFoOlLdD\",                0,      HL_FOLD},", "                  {\"cCoOnNcCeEaAlL\",          0,      HL_CONCEAL},", "                  {\"cCoOnNcCeEaAlLeEnNdDsS\",  0,      HL_CONCEALENDS},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"cCoOnNcCeEaAlL\",          0,      HL_CONCEAL},", "                  {\"cCoOnNcCeEaAlLeEnNdDsS\",  0,      HL_CONCEALENDS},", "                  {\"cCcChHaArR\",              11,     0},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"cCoOnNcCeEaAlL\",          0,      HL_CONCEAL},", "                  {\"cCoOnNcCeEaAlLeEnNdDsS\",  0,      HL_CONCEALENDS},", "                  {\"cCcChHaArR\",              11,     0},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"cCoOnNcCeEaAlLeEnNdDsS\",  0,      HL_CONCEALENDS},", "                  {\"cCcChHaArR\",              11,     0},", "                  {\"cCoOnNtTaAiInNsS\",        1,      0},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"cCoOnNcCeEaAlLeEnNdDsS\",  0,      HL_CONCEALENDS},", "                  {\"cCcChHaArR\",              11,     0},", "                  {\"cCoOnNtTaAiInNsS\",        1,      0},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"cCcChHaArR\",              11,     0},", "                  {\"cCoOnNtTaAiInNsS\",        1,      0},", "                  {\"cCoOnNtTaAiInNeEdDiInN\",  2,      0},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"cCcChHaArR\",              11,     0},", "                  {\"cCoOnNtTaAiInNsS\",        1,      0},", "                  {\"cCoOnNtTaAiInNeEdDiInN\",  2,      0},"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"cCoOnNtTaAiInNsS\",        1,      0},", "                  {\"cCoOnNtTaAiInNeEdDiInN\",  2,      0},", "                  {\"nNeExXtTgGrRoOuUpP\",      3,      0},};"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"cCoOnNtTaAiInNsS\",        1,      0},", "                  {\"cCoOnNtTaAiInNeEdDiInN\",  2,      0},", "                  {\"nNeExXtTgGrRoOuUpP\",      3,      0},};"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"cCoOnNtTaAiInNeEdDiInN\",  2,      0},", "                  {\"nNeExXtTgGrRoOuUpP\",      3,      0},};", "  static const char *const first_letters = \"cCoOkKeEtTsSgGdDfFnN\";"], "whitespace/comma"]
["src/nvim/syntax.c", ["                  {\"cCoOnNtTaAiInNeEdDiInN\",  2,      0},", "                  {\"nNeExXtTgGrRoOuUpP\",      3,      0},};", "  static const char *const first_letters = \"cCoOkKeEtTsSgGdDfFnN\";"], "whitespace/braces"]
["src/nvim/syntax.c", ["                  {\"cCoOnNtTaAiInNeEdDiInN\",  2,      0},", "                  {\"nNeExXtTgGrRoOuUpP\",      3,      0},};", "  static const char *const first_letters = \"cCoOkKeEtTsSgGdDfFnN\";"], "whitespace/braces"]
["src/nvim/syntax.c", ["", "  if (arg == NULL)              /* already detected error */", "    return NULL;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  if (arg == NULL)              /* already detected error */", "    return NULL;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  if (curwin->w_s->b_syn_conceal)", "    opt->flags |= HL_CONCEAL;"], "readability/braces"]
["src/nvim/syntax.c", ["  for (;; ) {", "    /*", "     * This is used very often when a large number of keywords is defined."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["     */", "    if (strchr(first_letters, *arg) == NULL)", "      break;"], "readability/braces"]
["src/nvim/syntax.c", ["      for (i = 0, len = 0; p[i] != NUL; i += 2, ++len) {", "        if (arg[len] != p[i] && arg[len] != p[i + 1])", "          break;"], "readability/braces"]
["src/nvim/syntax.c", ["                              : ends_excmd(arg[len])))) {", "        if (opt->keyword", "            && (flagtab[fidx].flags == HL_DISPLAY"], "readability/braces"]
["src/nvim/syntax.c", ["                || flagtab[fidx].flags == HL_EXTEND))", "          /* treat \"display\", \"fold\" and \"extend\" as a keyword */", "          fidx = -1;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    }", "    if (fidx < 0)           /* no match found */", "      break;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    }", "    if (fidx < 0)           /* no match found */", "      break;"], "readability/braces"]
["src/nvim/syntax.c", ["        arg = skiptowhite(arg);", "        if (gname_start == arg)", "          return NULL;"], "readability/braces"]
["src/nvim/syntax.c", ["          int i;", "          for (i = curwin->w_s->b_syn_patterns.ga_len; --i >= 0; )", "            if (SYN_ITEMS(curwin->w_s)[i].sp_syn.id == syn_id"], "readability/braces"]
["src/nvim/syntax.c", ["        arg = skipwhite(arg);", "      } else if (flagtab[fidx].flags == HL_FOLD", "                 && foldmethodIsSyntax(curwin))"], "readability/braces"]
["src/nvim/syntax.c", ["                 && foldmethodIsSyntax(curwin))", "        /* Need to update folds later. */", "        foldUpdateAll(curwin);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Adjustments to syntax item when declared in a \":syn include\"'d file."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["{", "  if ((*flagsp & HL_CONTAINED) || curwin->w_s->b_syn_topgrp == 0)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["    syn_combine_list(&SYN_CLSTR(curwin->w_s)[tlg_id].scl_list, &grp_list,", "        CLUSTER_ADD);", "  }"], "whitespace/alignment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax include [@{group-name}] filename\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  int prev_syn_inc_tag;", "  int source = FALSE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["  eap->nextcmd = find_nextcmd(arg);", "  if (eap->skip)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["  if (arg[0] == '@') {", "    ++arg;", "    rest = get_group_name(arg, &group_name_end);"], "readability/increment"]
["src/nvim/syntax.c", ["    sgl_id = syn_check_cluster(arg, (int)(group_name_end - arg));", "    if (sgl_id == 0)", "      return;"], "readability/braces"]
["src/nvim/syntax.c", ["      return;", "    /* separate_nextcmd() and expand_filename() depend on this */", "    eap->arg = rest;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Everything that's left, up to the next command, should be the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (expand_filename(eap, syn_cmdlinep, &errormsg) == FAIL) {", "      if (errormsg != NULL)", "        EMSG(errormsg);"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * Save and restore the existing top-level grouplist id and \":syn"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax keyword {group-name} [{option}] keyword ..\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  if (rest != NULL)", "    eap->nextcmd = check_nextcmd(rest);"], "readability/braces"]
["src/nvim/syntax.c", ["    eap->nextcmd = check_nextcmd(rest);", "  else", "    EMSG2(_(e_invarg2), arg);"], "readability/braces"]
["src/nvim/syntax.c", ["  redraw_curbuf_later(SOME_VALID);", "  syn_stack_free_all(curwin->w_s);              /* Need to recompute all syntax. */", "}"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  redraw_curbuf_later(SOME_VALID);", "  syn_stack_free_all(curwin->w_s);              /* Need to recompute all syntax. */", "}"], "whitespace/line_length"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax match {name} [{options}] {pattern} [{options}]\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    exarg_T *eap,", "    int syncing                        /* TRUE for \":syntax sync match .. \" */", ")"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  char_u      *rest;", "  synpat_T item;                /* the item found in the line */", "  int syn_id;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* Isolate the group name, check for validity */", "  rest = get_group_name(arg, &group_name_end);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* Get options before the pattern */", "  syn_opt_arg.flags = 0;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* get the pattern. */", "  init_syn_patterns();"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  if (rest != NULL) {           /* all arguments are valid */", "    /*"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (rest != NULL) {           /* all arguments are valid */", "    /*", "     * Check for trailing command and illegal trailing arguments."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    eap->nextcmd = check_nextcmd(rest);", "    if (!ends_excmd(*rest) || eap->skip)", "      rest = NULL;"], "readability/braces"]
["src/nvim/syntax.c", ["      rest = NULL;", "    else {", "      if ((syn_id = syn_check_group(arg, (int)(group_name_end - arg))) != 0) {"], "readability/braces"]
["src/nvim/syntax.c", ["      rest = NULL;", "    else {", "      if ((syn_id = syn_check_group(arg, (int)(group_name_end - arg))) != 0) {"], "readability/braces"]
["src/nvim/syntax.c", ["        syn_incl_toplevel(syn_id, &syn_opt_arg.flags);", "        /*", "         * Store the pattern in the syn_items list"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        spp->sp_cchar = conceal_char;", "        if (syn_opt_arg.cont_in_list != NULL)", "          curwin->w_s->b_syn_containedin = TRUE;"], "readability/braces"]
["src/nvim/syntax.c", ["        if (syn_opt_arg.cont_in_list != NULL)", "          curwin->w_s->b_syn_containedin = TRUE;", "        spp->sp_next_list = syn_opt_arg.next_list;"], "readability/bool"]
["src/nvim/syntax.c", ["", "        /* remember that we found a match for syncing on */", "        if (syn_opt_arg.flags & (HL_SYNC_HERE|HL_SYNC_THERE))"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        /* remember that we found a match for syncing on */", "        if (syn_opt_arg.flags & (HL_SYNC_HERE|HL_SYNC_THERE))", "          curwin->w_s->b_syn_sync_flags |= SF_MATCH;"], "readability/braces"]
["src/nvim/syntax.c", ["          curwin->w_s->b_syn_sync_flags |= SF_MATCH;", "        if (syn_opt_arg.flags & HL_FOLD)", "          ++curwin->w_s->b_syn_folditems;"], "readability/braces"]
["src/nvim/syntax.c", ["        if (syn_opt_arg.flags & HL_FOLD)", "          ++curwin->w_s->b_syn_folditems;", ""], "readability/increment"]
["src/nvim/syntax.c", ["        redraw_curbuf_later(SOME_VALID);", "        syn_stack_free_all(curwin->w_s);          /* Need to recompute all syntax. */", "        return;           /* don't free the progs and patterns now */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        redraw_curbuf_later(SOME_VALID);", "        syn_stack_free_all(curwin->w_s);          /* Need to recompute all syntax. */", "        return;           /* don't free the progs and patterns now */"], "whitespace/line_length"]
["src/nvim/syntax.c", ["        syn_stack_free_all(curwin->w_s);          /* Need to recompute all syntax. */", "        return;           /* don't free the progs and patterns now */", "      }"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Something failed, free the allocated memory."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  if (rest == NULL)", "    EMSG2(_(e_invarg2), arg);"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax region {group-name} [matchgroup={group-name}]"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    exarg_T *eap,", "    int syncing                        /* TRUE for \":syntax sync region ..\" */", ")"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  char_u              *group_name_end;", "  char_u              *rest;                    /* next arg, NULL on error */", "  char_u              *key_end;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  struct pat_ptr {", "    synpat_T        *pp_synp;                   /* pointer to syn_pattern */", "    int pp_matchgroup_id;                       /* matchgroup ID */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    synpat_T        *pp_synp;                   /* pointer to syn_pattern */", "    int pp_matchgroup_id;                       /* matchgroup ID */", "    struct pat_ptr  *pp_next;                   /* pointer to next pat_ptr */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    int pp_matchgroup_id;                       /* matchgroup ID */", "    struct pat_ptr  *pp_next;                   /* pointer to next pat_ptr */", "  }                   *(pat_ptrs[3]);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  }                   *(pat_ptrs[3]);", "  /* patterns found in the line */", "  struct pat_ptr      *ppp;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  struct pat_ptr      *ppp_next;", "  int pat_count = 0;                            /* nr of syn_patterns found */", "  int syn_id;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  int matchgroup_id = 0;", "  int not_enough = FALSE;                       /* not enough arguments */", "  int illegal = FALSE;                          /* illegal arguments */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  int matchgroup_id = 0;", "  int not_enough = FALSE;                       /* not enough arguments */", "  int illegal = FALSE;                          /* illegal arguments */"], "readability/bool"]
["src/nvim/syntax.c", ["  int not_enough = FALSE;                       /* not enough arguments */", "  int illegal = FALSE;                          /* illegal arguments */", "  int success = FALSE;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  int not_enough = FALSE;                       /* not enough arguments */", "  int illegal = FALSE;                          /* illegal arguments */", "  int success = FALSE;"], "readability/bool"]
["src/nvim/syntax.c", ["  int illegal = FALSE;                          /* illegal arguments */", "  int success = FALSE;", "  syn_opt_arg_T syn_opt_arg;"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /* Isolate the group name, check for validity */", "  rest = get_group_name(arg, &group_name_end);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /* must be a pattern or matchgroup then */", "    key_end = rest;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    key_end = rest;", "    while (*key_end && !ascii_iswhite(*key_end) && *key_end != '=')", "      ++key_end;"], "readability/braces"]
["src/nvim/syntax.c", ["    while (*key_end && !ascii_iswhite(*key_end) && *key_end != '=')", "      ++key_end;", "    xfree(key);"], "readability/increment"]
["src/nvim/syntax.c", ["    if (*rest == NUL) {", "      not_enough = TRUE;", "      break;"], "readability/bool"]
["src/nvim/syntax.c", ["      p = skiptowhite(rest);", "      if ((p - rest == 4 && STRNCMP(rest, \"NONE\", 4) == 0) || eap->skip)", "        matchgroup_id = 0;"], "readability/braces"]
["src/nvim/syntax.c", ["        matchgroup_id = 0;", "      else {", "        matchgroup_id = syn_check_group(rest, (int)(p - rest));"], "readability/braces"]
["src/nvim/syntax.c", ["        matchgroup_id = 0;", "      else {", "        matchgroup_id = syn_check_group(rest, (int)(p - rest));"], "readability/braces"]
["src/nvim/syntax.c", ["        if (matchgroup_id == 0) {", "          illegal = TRUE;", "          break;"], "readability/bool"]
["src/nvim/syntax.c", ["    } else {", "      /*", "       * Allocate room for a syn_pattern, and link it in the list of"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  xfree(key);", "  if (illegal || not_enough)", "    rest = NULL;"], "readability/braces"]
["src/nvim/syntax.c", ["  if (rest != NULL) {", "    /*", "     * Check for trailing garbage or command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    eap->nextcmd = check_nextcmd(rest);", "    if (!ends_excmd(*rest) || eap->skip)", "      rest = NULL;"], "readability/braces"]
["src/nvim/syntax.c", ["      rest = NULL;", "    else {", "      ga_grow(&(curwin->w_s->b_syn_patterns), pat_count);"], "readability/braces"]
["src/nvim/syntax.c", ["      rest = NULL;", "    else {", "      ga_grow(&(curwin->w_s->b_syn_patterns), pat_count);"], "readability/braces"]
["src/nvim/syntax.c", ["        syn_incl_toplevel(syn_id, &syn_opt_arg.flags);", "        /*", "         * Store the start/skip/end in the syn_items list"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        int idx = curwin->w_s->b_syn_patterns.ga_len;", "        for (item = ITEM_START; item <= ITEM_END; ++item) {", "          for (ppp = pat_ptrs[item]; ppp != NULL; ppp = ppp->pp_next) {"], "readability/increment"]
["src/nvim/syntax.c", ["                syn_opt_arg.cont_in_list;", "              if (syn_opt_arg.cont_in_list != NULL)", "                curwin->w_s->b_syn_containedin = TRUE;"], "readability/braces"]
["src/nvim/syntax.c", ["              if (syn_opt_arg.cont_in_list != NULL)", "                curwin->w_s->b_syn_containedin = TRUE;", "              SYN_ITEMS(curwin->w_s)[idx].sp_next_list ="], "readability/bool"]
["src/nvim/syntax.c", ["            }", "            ++curwin->w_s->b_syn_patterns.ga_len;", "            ++idx;"], "readability/increment"]
["src/nvim/syntax.c", ["            ++curwin->w_s->b_syn_patterns.ga_len;", "            ++idx;", "            if (syn_opt_arg.flags & HL_FOLD)"], "readability/increment"]
["src/nvim/syntax.c", ["            ++idx;", "            if (syn_opt_arg.flags & HL_FOLD)", "              ++curwin->w_s->b_syn_folditems;"], "readability/braces"]
["src/nvim/syntax.c", ["            if (syn_opt_arg.flags & HL_FOLD)", "              ++curwin->w_s->b_syn_folditems;", "          }"], "readability/increment"]
["src/nvim/syntax.c", ["        redraw_curbuf_later(SOME_VALID);", "        syn_stack_free_all(curwin->w_s);          /* Need to recompute all syntax. */", "        success = TRUE;               /* don't free the progs and patterns now */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        redraw_curbuf_later(SOME_VALID);", "        syn_stack_free_all(curwin->w_s);          /* Need to recompute all syntax. */", "        success = TRUE;               /* don't free the progs and patterns now */"], "whitespace/line_length"]
["src/nvim/syntax.c", ["        syn_stack_free_all(curwin->w_s);          /* Need to recompute all syntax. */", "        success = TRUE;               /* don't free the progs and patterns now */", "      }"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        syn_stack_free_all(curwin->w_s);          /* Need to recompute all syntax. */", "        success = TRUE;               /* don't free the progs and patterns now */", "      }"], "whitespace/line_length"]
["src/nvim/syntax.c", ["        syn_stack_free_all(curwin->w_s);          /* Need to recompute all syntax. */", "        success = TRUE;               /* don't free the progs and patterns now */", "      }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /*", "   * Free the allocated memory."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  for (item = ITEM_START; item <= ITEM_END; ++item)", "    for (ppp = pat_ptrs[item]; ppp != NULL; ppp = ppp_next) {"], "readability/braces"]
["src/nvim/syntax.c", ["   */", "  for (item = ITEM_START; item <= ITEM_END; ++item)", "    for (ppp = pat_ptrs[item]; ppp != NULL; ppp = ppp_next) {"], "readability/increment"]
["src/nvim/syntax.c", ["    xfree(syn_opt_arg.next_list);", "    if (not_enough)", "      EMSG2(_(\"E399: Not enough arguments: syntax region %s\"), arg);"], "readability/braces"]
["src/nvim/syntax.c", ["      EMSG2(_(\"E399: Not enough arguments: syntax region %s\"), arg);", "    else if (illegal || rest == NULL)", "      EMSG2(_(e_invarg2), arg);"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * Handle degenerate cases."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  if (*clstr2 == NULL)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["  if (*clstr1 == NULL || list_op == CLUSTER_REPLACE) {", "    if (list_op == CLUSTER_REPLACE)", "      xfree(*clstr1);"], "readability/braces"]
["src/nvim/syntax.c", ["      xfree(*clstr1);", "    if (list_op == CLUSTER_REPLACE || list_op == CLUSTER_ADD)", "      *clstr1 = *clstr2;"], "readability/braces"]
["src/nvim/syntax.c", ["      *clstr1 = *clstr2;", "    else", "      xfree(*clstr2);"], "readability/braces"]
["src/nvim/syntax.c", ["", "    /*", "     * First, loop through the lists until one of them is empty."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    while (*g1 && *g2) {", "      /*", "       * We always want to add from the first list."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (*g1 < *g2) {", "        if (round == 2)", "          clstr[count] = *g1;"], "readability/braces"]
["src/nvim/syntax.c", ["      }", "      /*", "       * We only want to add from the second list if we're adding the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (list_op == CLUSTER_ADD) {", "        if (round == 2)", "          clstr[count] = *g2;"], "readability/braces"]
["src/nvim/syntax.c", ["      }", "      if (*g1 == *g2)", "        g1++;"], "readability/braces"]
["src/nvim/syntax.c", ["", "    /*", "     * Now add the leftovers from whichever list didn't get finished"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["     */", "    for (; *g1; g1++, count++)", "      if (round == 2)"], "readability/braces"]
["src/nvim/syntax.c", ["    for (; *g1; g1++, count++)", "      if (round == 2)", "        clstr[count] = *g1;"], "readability/braces"]
["src/nvim/syntax.c", ["        clstr[count] = *g1;", "    if (list_op == CLUSTER_ADD)", "      for (; *g2; g2++, count++)"], "readability/braces"]
["src/nvim/syntax.c", ["    if (list_op == CLUSTER_ADD)", "      for (; *g2; g2++, count++)", "        if (round == 2)"], "readability/braces"]
["src/nvim/syntax.c", ["      for (; *g2; g2++, count++)", "        if (round == 2)", "          clstr[count] = *g2;"], "readability/braces"]
["src/nvim/syntax.c", ["    if (round == 1) {", "      /*", "       * If the group ended up empty, we don't need to allocate any"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Finally, put the new list in place."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Like syn_scl_name2id(), but take a pointer + length argument."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  id = syn_scl_name2id(name);", "  if (id == 0)                          /* doesn't exist yet */", "    id = syn_add_cluster(name);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  id = syn_scl_name2id(name);", "  if (id == 0)                          /* doesn't exist yet */", "    id = syn_add_cluster(name);"], "readability/braces"]
["src/nvim/syntax.c", ["    id = syn_add_cluster(name);", "  else", "    xfree(name);"], "readability/braces"]
["src/nvim/syntax.c", ["{", "  /*", "   * First call for this growarray: init growing array."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  if (STRICMP(name, \"Spell\") == 0)", "    curwin->w_s->b_spell_cluster_id = len + SYNID_CLUSTER;"], "readability/braces"]
["src/nvim/syntax.c", ["    curwin->w_s->b_spell_cluster_id = len + SYNID_CLUSTER;", "  if (STRICMP(name, \"NoSpell\") == 0)", "    curwin->w_s->b_nospell_cluster_id = len + SYNID_CLUSTER;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax cluster {cluster-name} [contains={groupname},..]"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  eap->nextcmd = find_nextcmd(arg);", "  if (eap->skip)", "    return;"], "readability/braces"]
["src/nvim/syntax.c", ["        list_op = CLUSTER_REPLACE;", "      } else", "        break;"], "readability/braces"]
["src/nvim/syntax.c", ["      redraw_curbuf_later(SOME_VALID);", "      syn_stack_free_all(curwin->w_s);          /* Need to recompute all. */", "    }"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  if (!got_clstr)", "    EMSG(_(\"E400: No cluster specified\"));"], "readability/braces"]
["src/nvim/syntax.c", ["    EMSG(_(\"E400: No cluster specified\"));", "  if (rest == NULL || !ends_excmd(*rest))", "    EMSG2(_(e_invarg2), arg);"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * On first call for current buffer: Init growing array."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Get one pattern for a \":syntax match\" or \":syntax region\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  end = skip_regexp(arg + 1, *arg, TRUE, NULL);", "  if (*end != *arg) {                       /* end delimiter not found */"], "readability/bool"]
["src/nvim/syntax.c", ["  end = skip_regexp(arg + 1, *arg, TRUE, NULL);", "  if (*end != *arg) {                       /* end delimiter not found */", "    EMSG2(_(\"E401: Pattern delimiter not found: %s\"), arg);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* Make 'cpoptions' empty, to avoid the 'l' flag */", "  cpo_save = p_cpo;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  if (ci->sp_prog == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * Check for a match, highlight or region offset."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  ++end;", "  do {"], "readability/increment"]
["src/nvim/syntax.c", ["  do {", "    for (idx = SPO_COUNT; --idx >= 0; )", "      if (STRNCMP(end, spo_name_tab[idx], 3) == 0)"], "readability/braces"]
["src/nvim/syntax.c", ["    for (idx = SPO_COUNT; --idx >= 0; )", "      if (STRNCMP(end, spo_name_tab[idx], 3) == 0)", "        break;"], "readability/braces"]
["src/nvim/syntax.c", ["      p = &(ci->sp_offsets[idx]);", "      if (idx != SPO_LC_OFF)", "        switch (end[3]) {"], "readability/braces"]
["src/nvim/syntax.c", ["        ci->sp_off_flags |= (1 << idx);", "        if (idx == SPO_LC_OFF) {            /* lc=99 */", "          end += 3;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "          /* \"lc=\" offset automatically sets \"ms=\" offset */", "          if (!(ci->sp_off_flags & (1 << SPO_MS_OFF))) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["          }", "        } else {                          /* yy=x+99 */", "          end += 4;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        }", "        if (*end != ',')", "          break;"], "readability/braces"]
["src/nvim/syntax.c", ["          break;", "        ++end;", "      }"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax sync ..\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  char_u      *next_arg;", "  int illegal = FALSE;", "  int finished = FALSE;"], "readability/bool"]
["src/nvim/syntax.c", ["  int illegal = FALSE;", "  int finished = FALSE;", "  long n;"], "readability/bool"]
["src/nvim/syntax.c", ["  if (ends_excmd(*arg_start)) {", "    syn_cmd_list(eap, TRUE);", "    return;"], "readability/bool"]
["src/nvim/syntax.c", ["    if (STRCMP(key, \"CCOMMENT\") == 0) {", "      if (!eap->skip)", "        curwin->w_s->b_syn_sync_flags |= SF_CCOMMENT;"], "readability/braces"]
["src/nvim/syntax.c", ["        arg_end = skiptowhite(next_arg);", "        if (!eap->skip)", "          curwin->w_s->b_syn_sync_id = syn_check_group(next_arg,"], "readability/braces"]
["src/nvim/syntax.c", ["          curwin->w_s->b_syn_sync_id = syn_check_group(next_arg,", "              (int)(arg_end - next_arg));", "        next_arg = skipwhite(arg_end);"], "whitespace/alignment"]
["src/nvim/syntax.c", ["        next_arg = skipwhite(arg_end);", "      } else if (!eap->skip)", "        curwin->w_s->b_syn_sync_id = syn_name2id((char_u *)\"Comment\");"], "readability/braces"]
["src/nvim/syntax.c", ["    } else if (  STRNCMP(key, \"LINES\", 5) == 0", "                 || STRNCMP(key, \"MINLINES\", 8) == 0", "                 || STRNCMP(key, \"MAXLINES\", 8) == 0"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                 || STRNCMP(key, \"MINLINES\", 8) == 0", "                 || STRNCMP(key, \"MAXLINES\", 8) == 0", "                 || STRNCMP(key, \"LINEBREAKS\", 10) == 0) {"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                 || STRNCMP(key, \"MAXLINES\", 8) == 0", "                 || STRNCMP(key, \"LINEBREAKS\", 10) == 0) {", "      if (key[4] == 'S')"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                 || STRNCMP(key, \"LINEBREAKS\", 10) == 0) {", "      if (key[4] == 'S')", "        arg_end = key + 6;"], "readability/braces"]
["src/nvim/syntax.c", ["        arg_end = key + 6;", "      else if (key[0] == 'L')", "        arg_end = key + 11;"], "readability/braces"]
["src/nvim/syntax.c", ["        arg_end = key + 11;", "      else", "        arg_end = key + 9;"], "readability/braces"]
["src/nvim/syntax.c", ["      if (arg_end[-1] != '=' || !ascii_isdigit(*arg_end)) {", "        illegal = TRUE;", "        break;"], "readability/bool"]
["src/nvim/syntax.c", ["      if (!eap->skip) {", "        if (key[4] == 'B')", "          curwin->w_s->b_syn_sync_linebreaks = n;"], "readability/braces"]
["src/nvim/syntax.c", ["          curwin->w_s->b_syn_sync_linebreaks = n;", "        else if (key[1] == 'A')", "          curwin->w_s->b_syn_sync_maxlines = n;"], "readability/braces"]
["src/nvim/syntax.c", ["          curwin->w_s->b_syn_sync_maxlines = n;", "        else", "          curwin->w_s->b_syn_sync_minlines = n;"], "readability/braces"]
["src/nvim/syntax.c", ["      if (curwin->w_s->b_syn_linecont_pat != NULL) {", "        EMSG(_(\"E403: syntax sync: line continuations pattern specified twice\"));", "        finished = TRUE;"], "whitespace/line_length"]
["src/nvim/syntax.c", ["        EMSG(_(\"E403: syntax sync: line continuations pattern specified twice\"));", "        finished = TRUE;", "        break;"], "readability/bool"]
["src/nvim/syntax.c", ["      }", "      arg_end = skip_regexp(next_arg + 1, *next_arg, TRUE, NULL);", "      if (*arg_end != *next_arg) {          /* end delimiter not found */"], "readability/bool"]
["src/nvim/syntax.c", ["      arg_end = skip_regexp(next_arg + 1, *next_arg, TRUE, NULL);", "      if (*arg_end != *next_arg) {          /* end delimiter not found */", "        illegal = TRUE;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (*arg_end != *next_arg) {          /* end delimiter not found */", "        illegal = TRUE;", "        break;"], "readability/bool"]
["src/nvim/syntax.c", ["      if (!eap->skip) {", "        /* store the pattern and compiled regexp program */", "        curwin->w_s->b_syn_linecont_pat ="], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "        /* Make 'cpoptions' empty, to avoid the 'l' flag */", "        cpo_save = p_cpo;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      eap->arg = next_arg;", "      if (STRCMP(key, \"MATCH\") == 0)", "        syn_cmd_match(eap, TRUE);"], "readability/braces"]
["src/nvim/syntax.c", ["      if (STRCMP(key, \"MATCH\") == 0)", "        syn_cmd_match(eap, TRUE);", "      else if (STRCMP(key, \"REGION\") == 0)"], "readability/bool"]
["src/nvim/syntax.c", ["        syn_cmd_match(eap, TRUE);", "      else if (STRCMP(key, \"REGION\") == 0)", "        syn_cmd_region(eap, TRUE);"], "readability/braces"]
["src/nvim/syntax.c", ["      else if (STRCMP(key, \"REGION\") == 0)", "        syn_cmd_region(eap, TRUE);", "      else if (STRCMP(key, \"CLEAR\") == 0)"], "readability/bool"]
["src/nvim/syntax.c", ["        syn_cmd_region(eap, TRUE);", "      else if (STRCMP(key, \"CLEAR\") == 0)", "        syn_cmd_clear(eap, TRUE);"], "readability/braces"]
["src/nvim/syntax.c", ["      else if (STRCMP(key, \"CLEAR\") == 0)", "        syn_cmd_clear(eap, TRUE);", "      else"], "readability/bool"]
["src/nvim/syntax.c", ["        syn_cmd_clear(eap, TRUE);", "      else", "        illegal = TRUE;"], "readability/braces"]
["src/nvim/syntax.c", ["      else", "        illegal = TRUE;", "      finished = TRUE;"], "readability/bool"]
["src/nvim/syntax.c", ["        illegal = TRUE;", "      finished = TRUE;", "      break;"], "readability/bool"]
["src/nvim/syntax.c", ["  xfree(key);", "  if (illegal)", "    EMSG2(_(\"E404: Illegal arguments: %s\"), arg_start);"], "readability/braces"]
["src/nvim/syntax.c", ["    EMSG2(_(\"E404: Illegal arguments: %s\"), arg_start);", "  else if (!finished) {", "    eap->nextcmd = check_nextcmd(arg_start);"], "readability/braces"]
["src/nvim/syntax.c", ["    redraw_curbuf_later(SOME_VALID);", "    syn_stack_free_all(curwin->w_s);            /* Need to recompute all syntax. */", "  }"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    redraw_curbuf_later(SOME_VALID);", "    syn_stack_free_all(curwin->w_s);            /* Need to recompute all syntax. */", "  }"], "whitespace/line_length"]
["src/nvim/syntax.c", ["", "/*", " * Convert a line of highlight group names into a list of group ID numbers."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (       STRCMP(name + 1, \"ALLBUT\") == 0", "                 || STRCMP(name + 1, \"ALL\") == 0", "                 || STRCMP(name + 1, \"TOP\") == 0"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                 || STRCMP(name + 1, \"ALL\") == 0", "                 || STRCMP(name + 1, \"TOP\") == 0", "                 || STRCMP(name + 1, \"CONTAINED\") == 0) {"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                 || STRCMP(name + 1, \"TOP\") == 0", "                 || STRCMP(name + 1, \"CONTAINED\") == 0) {", "        if (TOUPPER_ASC(**arg) != 'C') {"], "whitespace/alignment"]
["src/nvim/syntax.c", ["      } else {", "        /*", "         * Handle full group name."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "          regmatch.rm_ic = TRUE;", "          id = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["        }", "        ++count;", "      }"], "readability/increment"]
["src/nvim/syntax.c", ["      p = skipwhite(end);", "      if (*p != ',')", "        break;"], "readability/braces"]
["src/nvim/syntax.c", ["        break;", "      p = skipwhite(p + 1);             /* skip comma in between arguments */", "    } while (!ends_excmd(*p));"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    } while (!ends_excmd(*p));", "    if (failed)", "      break;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  if (*list == NULL)", "    *list = retval;"], "readability/braces"]
["src/nvim/syntax.c", ["    *list = retval;", "  else", "    xfree(retval);           /* list already found, don't overwrite it */"], "readability/braces"]
["src/nvim/syntax.c", ["  else", "    xfree(retval);           /* list already found, don't overwrite it */", ""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Make a copy of an ID list."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Check if syntax group \"ssp\" is in the ID list \"list\" of \"cur_si\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* If ssp has a \"containedin\" list and \"cur_si\" is in it, return TRUE. */", "  if (cur_si != NULL && ssp->cont_in_list != NULL"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      && !(cur_si->si_flags & HL_MATCH)) {", "    /* Ignore transparent items without a contains argument.  Double check", "     * that we don't go back past the first one. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["     * that we don't go back past the first one. */", "    while ((cur_si->si_flags & HL_TRANS_CONT)", "           && cur_si > (stateitem_T *)(current_state.ga_data))"], "readability/braces"]
["src/nvim/syntax.c", ["           && cur_si > (stateitem_T *)(current_state.ga_data))", "      --cur_si;", "    /* cur_si->si_idx is -1 for keywords, these never contain anything. */"], "readability/increment"]
["src/nvim/syntax.c", ["      --cur_si;", "    /* cur_si->si_idx is -1 for keywords, these never contain anything. */", "    if (cur_si->si_idx >= 0 && in_id_list(NULL, ssp->cont_in_list,"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    /* cur_si->si_idx is -1 for keywords, these never contain anything. */", "    if (cur_si->si_idx >= 0 && in_id_list(NULL, ssp->cont_in_list,", "            &(SYN_ITEMS(syn_block)[cur_si->si_idx].sp_syn),"], "readability/braces"]
["src/nvim/syntax.c", ["    if (cur_si->si_idx >= 0 && in_id_list(NULL, ssp->cont_in_list,", "            &(SYN_ITEMS(syn_block)[cur_si->si_idx].sp_syn),", "            SYN_ITEMS(syn_block)[cur_si->si_idx].sp_flags & HL_CONTAINED))"], "whitespace/alignment"]
["src/nvim/syntax.c", ["            &(SYN_ITEMS(syn_block)[cur_si->si_idx].sp_syn),", "            SYN_ITEMS(syn_block)[cur_si->si_idx].sp_flags & HL_CONTAINED))", "      return TRUE;"], "whitespace/alignment"]
["src/nvim/syntax.c", ["            SYN_ITEMS(syn_block)[cur_si->si_idx].sp_flags & HL_CONTAINED))", "      return TRUE;", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  if (list == NULL)", "    return FALSE;"], "readability/braces"]
["src/nvim/syntax.c", ["  if (list == NULL)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["", "  /*", "   * If list is ID_LIST_ALL, we are in a transparent item that isn't"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  if (list == ID_LIST_ALL)", "    return !contained;"], "readability/braces"]
["src/nvim/syntax.c", ["", "  /*", "   * If the first item is \"ALLBUT\", return TRUE if \"id\" is NOT in the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (item < SYNID_TOP) {", "      /* ALL or ALLBUT: accept all groups in the same file */", "      if (item - SYNID_ALLBUT != ssp->inc_tag)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      /* ALL or ALLBUT: accept all groups in the same file */", "      if (item - SYNID_ALLBUT != ssp->inc_tag)", "        return FALSE;"], "readability/braces"]
["src/nvim/syntax.c", ["      if (item - SYNID_ALLBUT != ssp->inc_tag)", "        return FALSE;", "    } else if (item < SYNID_CONTAINED)   {"], "readability/bool"]
["src/nvim/syntax.c", ["    } else if (item < SYNID_CONTAINED)   {", "      /* TOP: accept all not-contained groups in the same file */", "      if (item - SYNID_TOP != ssp->inc_tag || contained)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      /* TOP: accept all not-contained groups in the same file */", "      if (item - SYNID_TOP != ssp->inc_tag || contained)", "        return FALSE;"], "readability/braces"]
["src/nvim/syntax.c", ["      if (item - SYNID_TOP != ssp->inc_tag || contained)", "        return FALSE;", "    } else {"], "readability/bool"]
["src/nvim/syntax.c", ["    } else {", "      /* CONTAINED: accept all contained groups in the same file */", "      if (item - SYNID_CONTAINED != ssp->inc_tag || !contained)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      /* CONTAINED: accept all contained groups in the same file */", "      if (item - SYNID_CONTAINED != ssp->inc_tag || !contained)", "        return FALSE;"], "readability/braces"]
["src/nvim/syntax.c", ["      if (item - SYNID_CONTAINED != ssp->inc_tag || !contained)", "        return FALSE;", "    }"], "readability/bool"]
["src/nvim/syntax.c", ["    item = *++list;", "    retval = FALSE;", "  } else"], "readability/bool"]
["src/nvim/syntax.c", ["    retval = FALSE;", "  } else", "    retval = TRUE;"], "readability/braces"]
["src/nvim/syntax.c", ["  } else", "    retval = TRUE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["", "  /*", "   * Return \"retval\" if id is in the contains list."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  while (item != 0) {", "    if (item == id)", "      return retval;"], "readability/braces"]
["src/nvim/syntax.c", ["      scl_list = SYN_CLSTR(syn_block)[item - SYNID_CLUSTER].scl_list;", "      /* restrict recursiveness to 30 to avoid an endless loop for a", "       * cluster that includes itself (indirectly) */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (scl_list != NULL && depth < 30) {", "        ++depth;", "        r = in_id_list(NULL, scl_list, ssp, contained);"], "readability/increment"]
["src/nvim/syntax.c", ["        r = in_id_list(NULL, scl_list, ssp, contained);", "        --depth;", "        if (r)"], "readability/increment"]
["src/nvim/syntax.c", ["        --depth;", "        if (r)", "          return retval;"], "readability/braces"]
["src/nvim/syntax.c", ["struct subcommand {", "  char    *name;                                /* subcommand name */", "  void    (*func)(exarg_T *, int);              /* function to call */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  char    *name;                                /* subcommand name */", "  void    (*func)(exarg_T *, int);              /* function to call */", "};"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * \":syntax\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      eap->arg = skipwhite(subcmd_end);", "      (subcommands[i].func)(eap, FALSE);", "      break;"], "readability/bool"]
["src/nvim/syntax.c", ["  xfree(subcmd_name);", "  if (eap->skip)", "    --emsg_skip;"], "readability/braces"]
["src/nvim/syntax.c", ["  if (eap->skip)", "    --emsg_skip;", "}"], "readability/increment"]
["src/nvim/syntax.c", ["", "  /* Apply the \"syntax\" autocommand event, this finds and loads the syntax", "   * file. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   * file. */", "  apply_autocmds(EVENT_SYNTAX, eap->arg, curbuf->b_fname, TRUE, curbuf);", ""], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Reset include_link, include_default, include_none to 0."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle command line completion for :match and :echohl command: Add \"None\""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle command line completion for :syntax command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* (part of) subcommand already typed */", "  if (*arg != NUL) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the list syntax names for"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Get extra information about the syntax item.  Must be called right after"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Return conceal substitution character"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Return the syntax ID at position \"i\" in the current stack."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (i >= current_state.ga_len) {", "    /* Need to invalidate the state, because we didn't properly finish it", "     * for the last character, \"keep_state\" was TRUE. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Function called to get folding level for line \"lnum\" in window \"wp\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    level = wp->w_p_fdn;", "    if (level < 0)", "      level = 0;"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * \":syntime\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["{", "  if (STRCMP(eap->arg, \"on\") == 0)", "    syn_time_on = TRUE;"], "readability/braces"]
["src/nvim/syntax.c", ["  if (STRCMP(eap->arg, \"on\") == 0)", "    syn_time_on = TRUE;", "  else if (STRCMP(eap->arg, \"off\") == 0)"], "readability/bool"]
["src/nvim/syntax.c", ["    syn_time_on = TRUE;", "  else if (STRCMP(eap->arg, \"off\") == 0)", "    syn_time_on = FALSE;"], "readability/braces"]
["src/nvim/syntax.c", ["  else if (STRCMP(eap->arg, \"off\") == 0)", "    syn_time_on = FALSE;", "  else if (STRCMP(eap->arg, \"clear\") == 0)"], "readability/bool"]
["src/nvim/syntax.c", ["    syn_time_on = FALSE;", "  else if (STRCMP(eap->arg, \"clear\") == 0)", "    syntime_clear();"], "readability/braces"]
["src/nvim/syntax.c", ["    syntime_clear();", "  else if (STRCMP(eap->arg, \"report\") == 0)", "    syntime_report();"], "readability/braces"]
["src/nvim/syntax.c", ["    syntime_report();", "  else", "    EMSG2(_(e_invarg2), eap->arg);"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Clear the syntax timing for the current buffer."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  }", "  for (int idx = 0; idx < curwin->w_s->b_syn_patterns.ga_len; ++idx) {", "    spp = &(SYN_ITEMS(curwin->w_s)[idx]);"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the possible arguments of the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Clear the syntax timing for the current buffer."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  time_entry_T *p;", "  for (int idx = 0; idx < curwin->w_s->b_syn_patterns.ga_len; ++idx) {", "    synpat_T *spp = &(SYN_ITEMS(curwin->w_s)[idx]);"], "readability/increment"]
["src/nvim/syntax.c", ["  MSG_PUTS_TITLE(_(", "          \"  TOTAL      COUNT  MATCH   SLOWEST     AVERAGE   NAME               PATTERN\"));", "  MSG_PUTS(\"\\n\");"], "whitespace/indent"]
["src/nvim/syntax.c", ["  MSG_PUTS_TITLE(_(", "          \"  TOTAL      COUNT  MATCH   SLOWEST     AVERAGE   NAME               PATTERN\"));", "  MSG_PUTS(\"\\n\");"], "whitespace/line_length"]
["src/nvim/syntax.c", ["  MSG_PUTS(\"\\n\");", "  for (int idx = 0; idx < ga.ga_len && !got_int; ++idx) {", "    p = ((time_entry_T *)ga.ga_data) + idx;"], "readability/increment"]
["src/nvim/syntax.c", ["    MSG_PUTS(profile_msg(p->total));", "    MSG_PUTS(\" \");     /* make sure there is always a separating space */", "    msg_advance(13);"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    int len;", "    if (Columns < 80)", "      len = 20;       /* will wrap anyway */"], "readability/braces"]
["src/nvim/syntax.c", ["    if (Columns < 80)", "      len = 20;       /* will wrap anyway */", "    else"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      len = 20;       /* will wrap anyway */", "    else", "      len = Columns - 70;"], "readability/braces"]
["src/nvim/syntax.c", ["      len = Columns - 70;", "    if (len > (int)STRLEN(p->pattern))", "      len = (int)STRLEN(p->pattern);"], "readability/braces"]
["src/nvim/syntax.c", ["", "/**************************************", "*  Highlighting stuff\t\t      *"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  \"DiffChange   ctermbg=LightMagenta guibg=LightMagenta\",", "  \"DiffDelete   ctermfg=Blue ctermbg=LightCyan gui=bold guifg=Blue guibg=LightCyan\",", "  \"Directory    ctermfg=DarkBlue guifg=Blue\","], "whitespace/line_length"]
["src/nvim/syntax.c", ["  \"SpellRare    ctermbg=LightMagenta guisp=Magenta gui=undercurl\",", "  \"TabLine      cterm=underline ctermfg=black ctermbg=LightGrey gui=underline guibg=LightGrey\",", "  \"Title        ctermfg=DarkMagenta gui=bold guifg=Magenta\","], "whitespace/line_length"]
["src/nvim/syntax.c", ["  \"DiffChange   ctermbg=DarkMagenta guibg=DarkMagenta\",", "  \"DiffDelete   ctermfg=Blue ctermbg=DarkCyan gui=bold guifg=Blue guibg=DarkCyan\",", "  \"Directory    ctermfg=LightCyan guifg=Cyan\","], "whitespace/line_length"]
["src/nvim/syntax.c", ["  \"SpellRare    ctermbg=Magenta guisp=Magenta gui=undercurl\",", "  \"TabLine      cterm=underline ctermfg=white ctermbg=DarkGrey gui=underline guibg=DarkGrey\",", "  \"Title        ctermfg=LightMagenta gui=bold guifg=Magenta\","], "whitespace/line_length"]
["src/nvim/syntax.c", ["", "  /*", "   * Didn't use a color file, use the compiled-in colors."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* Reverse looks ugly, but grey may not work for 8 colors.  Thus let it", "   * depend on the number of colors available."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * If syntax highlighting is enabled load the highlighting for it."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Load color file \"name\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  xfree(buf);", "  apply_autocmds(EVENT_COLORSCHEME, name, curbuf->b_fname, FALSE, curbuf);", ""], "readability/bool"]
["src/nvim/syntax.c", ["", "          /* When setting the foreground color, and previously the \"bold\"", "           * flag was set for a light color, reset it now */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["          } else if (STRICMP(arg, \"bg\") == 0)   {", "            if (cterm_normal_bg_color > 0)", "              color = cterm_normal_bg_color - 1;"], "readability/braces"]
["src/nvim/syntax.c", ["              color = cterm_normal_bg_color - 1;", "            else {", "              EMSG(_(\"E420: BG color unknown\"));"], "readability/braces"]
["src/nvim/syntax.c", ["              color = cterm_normal_bg_color - 1;", "            else {", "              EMSG(_(\"E420: BG color unknown\"));"], "readability/braces"]
["src/nvim/syntax.c", ["{", "  for (int i = 0; i < highlight_ga.ga_len; ++i) {", "    highlight_clear(i);"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Reset the cterm colors to what they were before Vim was started, if"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Return TRUE if highlight group \"idx\" has any settings."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Clear highlighting for one group."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  didh = highlight_list_arg(id, didh, LIST_ATTR,", "      sgp->sg_cterm, NULL, \"cterm\");", "  didh = highlight_list_arg(id, didh, LIST_INT,"], "whitespace/alignment"]
["src/nvim/syntax.c", ["  didh = highlight_list_arg(id, didh, LIST_INT,", "      sgp->sg_cterm_fg, NULL, \"ctermfg\");", "  didh = highlight_list_arg(id, didh, LIST_INT,"], "whitespace/alignment"]
["src/nvim/syntax.c", ["  didh = highlight_list_arg(id, didh, LIST_INT,", "      sgp->sg_cterm_bg, NULL, \"ctermbg\");", ""], "whitespace/alignment"]
["src/nvim/syntax.c", ["  didh = highlight_list_arg(id, didh, LIST_ATTR,", "      sgp->sg_gui, NULL, \"gui\");", "  didh = highlight_list_arg(id, didh, LIST_STRING,"], "whitespace/alignment"]
["src/nvim/syntax.c", ["  didh = highlight_list_arg(id, didh, LIST_STRING,", "      0, sgp->sg_rgb_fg_name, \"guifg\");", "  didh = highlight_list_arg(id, didh, LIST_STRING,"], "whitespace/alignment"]
["src/nvim/syntax.c", ["  didh = highlight_list_arg(id, didh, LIST_STRING,", "      0, sgp->sg_rgb_bg_name, \"guibg\");", "  didh = highlight_list_arg(id, didh, LIST_STRING,"], "whitespace/alignment"]
["src/nvim/syntax.c", ["        if (iarg & hl_attr_table[i]) {", "          if (buf[0] != NUL)", "            xstrlcat((char *)buf, \",\", 100);"], "readability/braces"]
["src/nvim/syntax.c", ["          xstrlcat((char *)buf, hl_name_table[i], 100);", "          iarg &= ~hl_attr_table[i];                /* don't want \"inverse\" */", "        }"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* Show \"xxx\" with the attributes. */", "  if (!did_header) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* Avoid using stricmp() too much, it's slow on some systems */", "  /* Avoid alloc()/free(), these are slow too.  ID names over 200 chars"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  /* Avoid using stricmp() too much, it's slow on some systems */", "  /* Avoid alloc()/free(), these are slow too.  ID names over 200 chars", "   * don't deserve to be found! */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  vim_strup(name_u);", "  for (i = highlight_ga.ga_len; --i >= 0; )", "    if (HL_TABLE()[i].sg_name_u != NULL"], "readability/braces"]
["src/nvim/syntax.c", ["  for (i = highlight_ga.ga_len; --i >= 0; )", "    if (HL_TABLE()[i].sg_name_u != NULL", "        && STRCMP(name_u, HL_TABLE()[i].sg_name_u) == 0)"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Return TRUE if highlight group \"name\" exists."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Return the name of highlight group \"id\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["{", "  if (id <= 0 || id > highlight_ga.ga_len)", "    return (char_u *)\"\";"], "readability/braces"]
["src/nvim/syntax.c", ["", "/*", " * Like syn_name2id(), but take a pointer + length argument."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* Check that the name is ASCII letters, digits and underscore. */", "  for (p = name; *p != NUL; ++p) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  /* Check that the name is ASCII letters, digits and underscore. */", "  for (p = name; *p != NUL; ++p) {", "    if (!vim_isprintc(*p)) {"], "readability/increment"]
["src/nvim/syntax.c", ["    } else if (!ASCII_ISALNUM(*p) && *p != '_')   {", "      /* This is an error, but since there previously was no check only", "       * give a warning. */"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * First call for this growarray: init growing array."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  // Append another syntax_highlight entry.", "  struct hl_group* hlgp = GA_APPEND_VIA_PTR(struct hl_group, &highlight_ga);", "  memset(hlgp, 0, sizeof(*hlgp));"], "whitespace/operators"]
["src/nvim/syntax.c", ["", "  return highlight_ga.ga_len;               /* ID is index plus one */", "}"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Translate a group ID to the final group ID (following links)."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  if (hl_id > highlight_ga.ga_len || hl_id < 1)", "    return 0;                           /* Can be called from eval!! */"], "readability/braces"]
["src/nvim/syntax.c", ["  if (hl_id > highlight_ga.ga_len || hl_id < 1)", "    return 0;                           /* Can be called from eval!! */", ""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Follow links until there is no more."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  need_highlight_changed = FALSE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["  for (int i = 0; i < 9; i++) {", "    sprintf((char *)userhl, \"User%d\", i + 1);", "    id = syn_name2id(userhl);"], "runtime/printf"]
["src/nvim/syntax.c", ["", "/*", " * Handle command line completion for :highlight command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /* (part of) subcommand already typed */", "  if (*arg != NUL) {"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      }", "      if (*p != NUL) {                          /* past group name */", "        include_link = 0;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * List highlighting matches in a nice way."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["{", "", "  if (name[0] == '#' && isxdigit(name[1]) && isxdigit(name[2])"], "whitespace/blank_line"]
["src/nvim/syntax.c", ["", "/**************************************", "*  End of Highlighting stuff\t      *"], "readability/old_style_comment"]
