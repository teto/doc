["src/nvim/main.c", ["", "  if (params.diff_mode && params.window_count == -1)", "    params.window_count = 0;            /* open up to 3 windows */"], "readability/braces"]
["src/nvim/main.c", ["  if (params.diff_mode && params.window_count == -1)", "    params.window_count = 0;            /* open up to 3 windows */", ""], "readability/old_style_comment"]
["src/nvim/main.c", ["", "  apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);", "  TIME_MSG(\"BufEnter autocommands\");"], "readability/bool"]
["src/nvim/main.c", ["  if (params.edit_type == EDIT_QF) {", "    qf_jump(NULL, 0, 0, FALSE);", "    TIME_MSG(\"jump to first error\");"], "readability/bool"]
["src/nvim/main.c", ["    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {", "      diff_win_options(wp, TRUE);", "    }"], "readability/bool"]
["src/nvim/main.c", ["", "  /* When running in Ex mode an error causes us to exit with a non-zero exit", "   * code.  POSIX requires this, although it's not 100% clear from the"], "readability/old_style_comment"]
["src/nvim/main.c", ["   * standard. */", "  if (exmode_active)", "    exitval += ex_exitval;"], "readability/braces"]
["src/nvim/main.c", ["", "  /* Optionally print hashtable efficiency. */", "  hash_debug_results();"], "readability/old_style_comment"]
["src/nvim/main.c", ["        if (wp->w_buffer == NULL) {", "          /* Autocmd must have close the buffer already, skip. */", "          continue;"], "readability/old_style_comment"]
["src/nvim/main.c", ["", "    /* Trigger BufUnload for buffers that are loaded */", "    FOR_ALL_BUFFERS(buf) {"], "readability/old_style_comment"]
["src/nvim/main.c", ["  if (did_emsg", "     ) {", "    /* give the user a chance to read the (error) message */"], "whitespace/alignment"]
["src/nvim/main.c", ["     ) {", "    /* give the user a chance to read the (error) message */", "    no_wait_return = FALSE;"], "readability/old_style_comment"]
["src/nvim/main.c", ["    /* give the user a chance to read the (error) message */", "    no_wait_return = FALSE;", "    wait_return(FALSE);"], "readability/bool"]
["src/nvim/main.c", ["    no_wait_return = FALSE;", "    wait_return(FALSE);", "  }"], "readability/bool"]
["src/nvim/main.c", ["# ifdef LC_NUMERIC", "  /* Make sure strtod() uses a decimal point, not a comma. */", "  setlocale(LC_NUMERIC, \"C\");"], "readability/old_style_comment"]
["src/nvim/main.c", ["          } else {", "            if (argv[0][argv_idx])", "              mainerr(err_opt_unknown, argv[0]);"], "readability/braces"]
["src/nvim/main.c", ["                a = SESSION_FILE;", "                ++argc;", "                --argv;"], "readability/increment"]
["src/nvim/main.c", ["                ++argc;", "                --argv;", "              } else {"], "readability/increment"]
["src/nvim/main.c", ["        char_u *r = (char_u *)concat_fnames((char *)p,", "            (char *)path_tail(alist_name(&GARGLIST[0])), true);", "        xfree(p);"], "whitespace/alignment"]
["src/nvim/main.c", ["", "/*", " * Many variables are in \"params\" so that we can pass them to invoked"], "readability/old_style_comment"]
["src/nvim/main.c", ["", "/*", " * Decide about window layout for diff mode after reading vimrc."], "readability/old_style_comment"]
["src/nvim/main.c", ["  if (paramp->diff_mode && paramp->window_layout == 0) {", "    if (diffopt_horizontal())", "      paramp->window_layout = WIN_HOR;             /* use horizontal split */"], "readability/braces"]
["src/nvim/main.c", ["    if (diffopt_horizontal())", "      paramp->window_layout = WIN_HOR;             /* use horizontal split */", "    else"], "readability/old_style_comment"]
["src/nvim/main.c", ["      paramp->window_layout = WIN_HOR;             /* use horizontal split */", "    else", "      paramp->window_layout = WIN_VER;             /* use vertical split */"], "readability/braces"]
["src/nvim/main.c", ["    else", "      paramp->window_layout = WIN_VER;             /* use vertical split */", "  }"], "readability/old_style_comment"]
["src/nvim/main.c", ["", "/*", " * Read all the plugin files."], "readability/old_style_comment"]
["src/nvim/main.c", ["", "/*", " * \"-q errorfile\": Load the error file now."], "readability/old_style_comment"]
["src/nvim/main.c", ["", "/*", " * Need to jump to the tag before executing the '-c command'."], "readability/old_style_comment"]
["src/nvim/main.c", ["  if (tagname != NULL) {", "    swap_exists_did_quit = FALSE;", ""], "readability/bool"]
["src/nvim/main.c", ["", "    /* If the user doesn't want to edit the file then we quit here. */", "    if (swap_exists_did_quit)"], "readability/old_style_comment"]
["src/nvim/main.c", ["    /* If the user doesn't want to edit the file then we quit here. */", "    if (swap_exists_did_quit)", "      getout(1);"], "readability/braces"]
["src/nvim/main.c", ["", "/*", " * Create the requested number of windows and edit buffers in them."], "readability/old_style_comment"]
["src/nvim/main.c", ["", "  /*", "   * Create the number of windows that was requested."], "readability/old_style_comment"]
["src/nvim/main.c", ["   */", "  if (parmp->window_count == -1)        /* was not set */", "    parmp->window_count = 1;"], "readability/old_style_comment"]
["src/nvim/main.c", ["   */", "  if (parmp->window_count == -1)        /* was not set */", "    parmp->window_count = 1;"], "readability/braces"]
["src/nvim/main.c", ["    parmp->window_count = 1;", "  if (parmp->window_count == 0)", "    parmp->window_count = GARGCOUNT;"], "readability/braces"]
["src/nvim/main.c", ["    // already split some windows", "    if (parmp->window_layout == 0)", "      parmp->window_layout = WIN_HOR;"], "readability/braces"]
["src/nvim/main.c", ["      parmp->window_count = make_windows(parmp->window_count,", "          parmp->window_layout == WIN_VER);", "      TIME_MSG(\"making windows\");"], "whitespace/alignment"]
["src/nvim/main.c", ["      TIME_MSG(\"making windows\");", "    } else", "      parmp->window_count = win_count();"], "readability/braces"]
["src/nvim/main.c", ["      parmp->window_count = win_count();", "  } else", "    parmp->window_count = 1;"], "readability/braces"]
["src/nvim/main.c", ["    // Don't execute Win/Buf Enter/Leave autocommands here", "    ++autocmd_no_enter;", "    ++autocmd_no_leave;"], "readability/increment"]
["src/nvim/main.c", ["    ++autocmd_no_enter;", "    ++autocmd_no_leave;", "    dorewind = TRUE;"], "readability/increment"]
["src/nvim/main.c", ["    ++autocmd_no_leave;", "    dorewind = TRUE;", "    while (done++ < 1000) {"], "readability/bool"]
["src/nvim/main.c", ["      if (dorewind) {", "        if (parmp->window_layout == WIN_TABS)", "          goto_tabpage(1);"], "readability/braces"]
["src/nvim/main.c", ["          goto_tabpage(1);", "        else", "          curwin = firstwin;"], "readability/braces"]
["src/nvim/main.c", ["      } else if (parmp->window_layout == WIN_TABS) {", "        if (curtab->tp_next == NULL)", "          break;"], "readability/braces"]
["src/nvim/main.c", ["      } else {", "        if (curwin->w_next == NULL)", "          break;"], "readability/braces"]
["src/nvim/main.c", ["      }", "      dorewind = FALSE;", "      curbuf = curwin->w_buffer;"], "readability/bool"]
["src/nvim/main.c", ["        swap_exists_action = SEA_DIALOG;", "        set_buflisted(TRUE);", ""], "readability/bool"]
["src/nvim/main.c", ["", "        /* create memfile, read file */", "        (void)open_buffer(FALSE, NULL, 0);"], "readability/old_style_comment"]
["src/nvim/main.c", ["        /* create memfile, read file */", "        (void)open_buffer(FALSE, NULL, 0);", ""], "readability/bool"]
["src/nvim/main.c", ["          if (got_int || only_one_window()) {", "            /* abort selected or quit and only one window */", "            did_emsg = FALSE;               /* avoid hit-enter prompt */"], "readability/old_style_comment"]
["src/nvim/main.c", ["            /* abort selected or quit and only one window */", "            did_emsg = FALSE;               /* avoid hit-enter prompt */", "            getout(1);"], "readability/old_style_comment"]
["src/nvim/main.c", ["            /* abort selected or quit and only one window */", "            did_emsg = FALSE;               /* avoid hit-enter prompt */", "            getout(1);"], "readability/bool"]
["src/nvim/main.c", ["          }", "          /* We can't close the window, it would disturb what", "           * happens next.  Clear the file name and set the arg"], "readability/old_style_comment"]
["src/nvim/main.c", ["          swap_exists_action = SEA_NONE;", "        } else", "          handle_swap_exists(NULL);"], "readability/braces"]
["src/nvim/main.c", ["          handle_swap_exists(NULL);", "        dorewind = TRUE;                        /* start again */", "      }"], "readability/old_style_comment"]
["src/nvim/main.c", ["          handle_swap_exists(NULL);", "        dorewind = TRUE;                        /* start again */", "      }"], "readability/bool"]
["src/nvim/main.c", ["      if (got_int) {", "        (void)vgetc();          /* only break the file loading, not the rest */", "        break;"], "readability/old_style_comment"]
["src/nvim/main.c", ["    }", "    if (parmp->window_layout == WIN_TABS)", "      goto_tabpage(1);"], "readability/braces"]
["src/nvim/main.c", ["      goto_tabpage(1);", "    else", "      curwin = firstwin;"], "readability/braces"]
["src/nvim/main.c", ["    curbuf = curwin->w_buffer;", "    --autocmd_no_enter;", "    --autocmd_no_leave;"], "readability/increment"]
["src/nvim/main.c", ["    --autocmd_no_enter;", "    --autocmd_no_leave;", "  }"], "readability/increment"]
["src/nvim/main.c", ["{", "  int arg_idx;                          /* index in argument list */", "  int i;"], "readability/old_style_comment"]
["src/nvim/main.c", ["", "  /*", "   * Don't execute Win/Buf Enter/Leave autocommands here"], "readability/old_style_comment"]
["src/nvim/main.c", ["   */", "  ++autocmd_no_enter;", "  ++autocmd_no_leave;"], "readability/increment"]
["src/nvim/main.c", ["  ++autocmd_no_enter;", "  ++autocmd_no_leave;", ""], "readability/increment"]
["src/nvim/main.c", ["", "  /* When w_arg_idx is -1 remove the window (see create_windows()). */", "  if (curwin->w_arg_idx == -1) {"], "readability/old_style_comment"]
["src/nvim/main.c", ["  arg_idx = 1;", "  for (i = 1; i < parmp->window_count; ++i) {", "    if (cwd != NULL) {"], "readability/increment"]
["src/nvim/main.c", ["      if (parmp->window_layout == WIN_TABS) {", "        if (curtab->tp_next == NULL)            /* just checking */", "          break;"], "readability/old_style_comment"]
["src/nvim/main.c", ["      if (parmp->window_layout == WIN_TABS) {", "        if (curtab->tp_next == NULL)            /* just checking */", "          break;"], "readability/braces"]
["src/nvim/main.c", ["      } else {", "        if (curwin->w_next == NULL)             /* just checking */", "          break;"], "readability/old_style_comment"]
["src/nvim/main.c", ["      } else {", "        if (curwin->w_next == NULL)             /* just checking */", "          break;"], "readability/braces"]
["src/nvim/main.c", ["      curwin->w_arg_idx = arg_idx;", "      /* Edit file from arg list, if there is one.  When \"Quit\" selected", "       * at the ATTENTION prompt close the window. */"], "readability/old_style_comment"]
["src/nvim/main.c", ["       * at the ATTENTION prompt close the window. */", "      swap_exists_did_quit = FALSE;", "      (void)do_ecmd(0, arg_idx < GARGCOUNT"], "readability/bool"]
["src/nvim/main.c", ["      (void)do_ecmd(0, arg_idx < GARGCOUNT", "          ? alist_name(&GARGLIST[arg_idx]) : NULL,", "          NULL, NULL, ECMD_LASTL, ECMD_HIDE, curwin);"], "whitespace/alignment"]
["src/nvim/main.c", ["          ? alist_name(&GARGLIST[arg_idx]) : NULL,", "          NULL, NULL, ECMD_LASTL, ECMD_HIDE, curwin);", "      if (swap_exists_did_quit) {"], "whitespace/alignment"]
["src/nvim/main.c", ["      if (swap_exists_did_quit) {", "        /* abort or quit selected */", "        if (got_int || only_one_window()) {"], "readability/old_style_comment"]
["src/nvim/main.c", ["        if (got_int || only_one_window()) {", "          /* abort selected and only one window */", "          did_emsg = FALSE;             /* avoid hit-enter prompt */"], "readability/old_style_comment"]
["src/nvim/main.c", ["          /* abort selected and only one window */", "          did_emsg = FALSE;             /* avoid hit-enter prompt */", "          getout(1);"], "readability/old_style_comment"]
["src/nvim/main.c", ["          /* abort selected and only one window */", "          did_emsg = FALSE;             /* avoid hit-enter prompt */", "          getout(1);"], "readability/bool"]
["src/nvim/main.c", ["    if (got_int) {", "      (void)vgetc();            /* only break the file loading, not the rest */", "      break;"], "readability/old_style_comment"]
["src/nvim/main.c", ["", "  if (parmp->window_layout == WIN_TABS)", "    goto_tabpage(1);"], "readability/braces"]
["src/nvim/main.c", ["    goto_tabpage(1);", "  --autocmd_no_enter;", ""], "readability/increment"]
["src/nvim/main.c", ["", "  /* make the first window the current window */", "  win = firstwin;"], "readability/old_style_comment"]
["src/nvim/main.c", ["  win = firstwin;", "  /* Avoid making a preview window the current window. */", "  while (win->w_p_pvw) {"], "readability/old_style_comment"]
["src/nvim/main.c", ["", "  --autocmd_no_leave;", "  TIME_MSG(\"editing files in windows\");"], "readability/increment"]
["src/nvim/main.c", ["  TIME_MSG(\"editing files in windows\");", "  if (parmp->window_count > 1 && parmp->window_layout != WIN_TABS)", "    win_equal(curwin, false, 'b');      /* adjust heights */"], "readability/braces"]
["src/nvim/main.c", ["  if (parmp->window_count > 1 && parmp->window_layout != WIN_TABS)", "    win_equal(curwin, false, 'b');      /* adjust heights */", "}"], "readability/old_style_comment"]
["src/nvim/main.c", ["", "/*", " * Execute the commands from --cmd arguments \"cmds[cnt]\"."], "readability/old_style_comment"]
["src/nvim/main.c", ["  if (cnt > 0) {", "    curwin->w_cursor.lnum = 0;     /* just in case.. */", "    sourcing_name = (char_u *)_(\"pre-vimrc command line\");"], "readability/old_style_comment"]
["src/nvim/main.c", ["", "/*", " * Execute \"+\", \"-c\" and \"-S\" arguments."], "readability/old_style_comment"]
["src/nvim/main.c", ["", "  /*", "   * We start commands on line 0, make \"vim +/pat file\" match a"], "readability/old_style_comment"]
["src/nvim/main.c", ["   */", "  msg_scroll = TRUE;", "  if (parmp->tagname == NULL && curwin->w_cursor.lnum <= 1)"], "readability/bool"]
["src/nvim/main.c", ["  msg_scroll = TRUE;", "  if (parmp->tagname == NULL && curwin->w_cursor.lnum <= 1)", "    curwin->w_cursor.lnum = 0;"], "readability/braces"]
["src/nvim/main.c", ["    do_cmdline_cmd(parmp->commands[i]);", "    if (parmp->cmds_tofree[i])", "      xfree(parmp->commands[i]);"], "readability/braces"]
["src/nvim/main.c", ["", "  if (!exmode_active)", "    msg_scroll = FALSE;"], "readability/braces"]
["src/nvim/main.c", ["  if (!exmode_active)", "    msg_scroll = FALSE;", ""], "readability/bool"]
["src/nvim/main.c", ["", "  /* When started with \"-q errorfile\" jump to first error again. */", "  if (parmp->edit_type == EDIT_QF)"], "readability/old_style_comment"]
["src/nvim/main.c", ["  /* When started with \"-q errorfile\" jump to first error again. */", "  if (parmp->edit_type == EDIT_QF)", "    qf_jump(NULL, 0, 0, FALSE);"], "readability/braces"]
["src/nvim/main.c", ["  if (parmp->edit_type == EDIT_QF)", "    qf_jump(NULL, 0, 0, FALSE);", "  TIME_MSG(\"executing command arguments\");"], "readability/bool"]
["src/nvim/main.c", ["      memmove(vimrc + dir_len + 1, path_tail, sizeof(path_tail));", "      if (do_source((char_u *) vimrc, true, DOSO_VIMRC) != FAIL) {", "        do_exrc = p_exrc;"], "whitespace/cast"]
["src/nvim/main.c", ["      // If vimrc file is not owned by user, set 'secure' mode.", "      if (!file_owned(VIMRC_FILE))", "#endif"], "readability/braces"]
["src/nvim/main.c", ["{", "  info_message = TRUE;  // use mch_msg(), not mch_errmsg()", "  list_version();"], "readability/bool"]
["src/nvim/main.c", ["  msg_putchar('\\n');", "  msg_didout = FALSE;", "}"], "readability/bool"]
["src/nvim/main.c", ["  mch_msg(_(\"  nvim [options] [file ...]      Edit file(s)\\n\"));", "  mch_msg(_(\"  nvim [options] -t <tag>        Edit file where tag is defined\\n\"));", "  mch_msg(_(\"  nvim [options] -q [errorfile]  Edit file with first error\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  --cmd <cmd>           Execute <cmd> before any config\\n\"));", "  mch_msg(_(\"  +<cmd>, -c <cmd>      Execute <cmd> after config and first file\\n\"));", "  mch_msg(\"\\n\");"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  -i <shada>            Use this shada file\\n\"));", "  mch_msg(_(\"  -m                    Modifications (writing files) not allowed\\n\"));", "  mch_msg(_(\"  -M                    Modifications in text not allowed\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  -n                    No swap file, use memory only\\n\"));", "  mch_msg(_(\"  -o[N]                 Open N windows (default: one per file)\\n\"));", "  mch_msg(_(\"  -O[N]                 Open N vertical windows (default: one per file)\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  -o[N]                 Open N windows (default: one per file)\\n\"));", "  mch_msg(_(\"  -O[N]                 Open N vertical windows (default: one per file)\\n\"));", "  mch_msg(_(\"  -p[N]                 Open N tab pages (default: one per file)\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  -O[N]                 Open N vertical windows (default: one per file)\\n\"));", "  mch_msg(_(\"  -p[N]                 Open N tab pages (default: one per file)\\n\"));", "  mch_msg(_(\"  -r, -L                List swap files\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  -R                    Read-only mode\\n\"));", "  mch_msg(_(\"  -S <session>          Source <session> after loading the first file\\n\"));", "  mch_msg(_(\"  -s <scriptin>         Read Normal mode commands from <scriptin>\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  -S <session>          Source <session> after loading the first file\\n\"));", "  mch_msg(_(\"  -s <scriptin>         Read Normal mode commands from <scriptin>\\n\"));", "  mch_msg(_(\"  -u <config>           Use this config file\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(\"\\n\");", "  mch_msg(_(\"  --api-info            Write msgpack-encoded API metadata to stdout\\n\"));", "  mch_msg(_(\"  --embed               Use stdin/stdout as a msgpack-rpc channel\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  --api-info            Write msgpack-encoded API metadata to stdout\\n\"));", "  mch_msg(_(\"  --embed               Use stdin/stdout as a msgpack-rpc channel\\n\"));", "  mch_msg(_(\"  --headless            Don't start a user interface\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  --noplugin            Don't load plugins\\n\"));", "  mch_msg(_(\"  --startuptime <file>  Write startup timing messages to <file>\\n\"));", "  mch_msg(_(\"\\nSee \\\":help startup-options\\\" for all options.\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["", "/*", " * Check the result of the ATTENTION dialog:"], "readability/old_style_comment"]
["src/nvim/main.c", ["{", "  if (swap_exists_action == SEA_QUIT)", "    getout(1);"], "readability/braces"]
