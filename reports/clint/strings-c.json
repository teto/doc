["src/nvim/strings.c", ["#include \"nvim/fold.h\"", "#include \"nvim/func_attr.h\"", "#include \"nvim/getchar.h\""], "build/include"]
["src/nvim/strings.c", ["  // and expect the remainder to be zeroed out.", "  return (char_u *)strncpy(xmallocz(len), (char *)string, len);", "}"], "runtime/printf"]
["src/nvim/strings.c", ["", "/*", " * Same as vim_strsave(), but any characters found in esc_chars are preceded"], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "/*", " * Same as vim_strsave_escaped(), but when \"bsl\" is true also escape"], "readability/old_style_comment"]
["src/nvim/strings.c", ["{", "  /*", "   * First count the number of backslashes required."], "readability/old_style_comment"]
["src/nvim/strings.c", ["    }", "    if (vim_strchr(esc_chars, *p) != NULL || (bsl && rem_backslash(p)))", "      ++length;                         /* count a backslash */"], "readability/braces"]
["src/nvim/strings.c", ["    if (vim_strchr(esc_chars, *p) != NULL || (bsl && rem_backslash(p)))", "      ++length;                         /* count a backslash */", "    ++length;                           /* count an ordinary char */"], "readability/old_style_comment"]
["src/nvim/strings.c", ["    if (vim_strchr(esc_chars, *p) != NULL || (bsl && rem_backslash(p)))", "      ++length;                         /* count a backslash */", "    ++length;                           /* count an ordinary char */"], "readability/increment"]
["src/nvim/strings.c", ["      ++length;                         /* count a backslash */", "    ++length;                           /* count an ordinary char */", "  }"], "readability/old_style_comment"]
["src/nvim/strings.c", ["      ++length;                         /* count a backslash */", "    ++length;                           /* count an ordinary char */", "  }"], "readability/increment"]
["src/nvim/strings.c", ["      p2 += l;", "      p += l - 1;                     /* skip multibyte char  */", "      continue;"], "readability/old_style_comment"]
["src/nvim/strings.c", ["    }", "    if (vim_strchr(esc_chars, *p) != NULL || (bsl && rem_backslash(p)))", "      *p2++ = cc;"], "readability/braces"]
["src/nvim/strings.c", ["", "/*", " * Escape \"string\" for use as a shell argument with system()."], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "  /* Only csh and similar shells expand '!' within single quotes.  For sh and", "   * the like we must not put a backslash before it, it will be taken"], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "  /* First count the number of extra bytes required. */", "  size_t length = STRLEN(string) + 3;       // two quotes and a trailing NUL"], "readability/old_style_comment"]
["src/nvim/strings.c", ["      }", "    } else", "#endif"], "readability/braces"]
["src/nvim/strings.c", ["        || (*p == '!' && (csh_like || do_special))) {", "      ++length;                         /* insert backslash */", "      if (csh_like && do_special)"], "readability/old_style_comment"]
["src/nvim/strings.c", ["        || (*p == '!' && (csh_like || do_special))) {", "      ++length;                         /* insert backslash */", "      if (csh_like && do_special)"], "readability/increment"]
["src/nvim/strings.c", ["      ++length;                         /* insert backslash */", "      if (csh_like && do_special)", "        ++length;                       /* insert backslash */"], "readability/braces"]
["src/nvim/strings.c", ["      if (csh_like && do_special)", "        ++length;                       /* insert backslash */", "    }"], "readability/old_style_comment"]
["src/nvim/strings.c", ["      if (csh_like && do_special)", "        ++length;                       /* insert backslash */", "    }"], "readability/increment"]
["src/nvim/strings.c", ["    if (do_special && find_cmdline_var(p, &l) >= 0) {", "      ++length;                         /* insert backslash */", "      p += l - 1;"], "readability/old_style_comment"]
["src/nvim/strings.c", ["    if (do_special && find_cmdline_var(p, &l) >= 0) {", "      ++length;                         /* insert backslash */", "      p += l - 1;"], "readability/increment"]
["src/nvim/strings.c", ["", "  /* Allocate memory for the result and fill it. */", "  escaped_string = xmalloc(length);"], "readability/old_style_comment"]
["src/nvim/strings.c", ["    *d++ = '\"';", "  } else", "#endif"], "readability/braces"]
["src/nvim/strings.c", ["      }", "    } else", "#endif"], "readability/braces"]
["src/nvim/strings.c", ["      *d++ = '\\'';", "      ++p;", "      continue;"], "readability/increment"]
["src/nvim/strings.c", ["      *d++ = '\\\\';", "      if (csh_like && do_special)", "        *d++ = '\\\\';"], "readability/braces"]
["src/nvim/strings.c", ["    if (do_special && find_cmdline_var(p, &l) >= 0) {", "      *d++ = '\\\\';                    /* insert backslash */", "      while (--l != SIZE_MAX)                /* copy the var */"], "readability/old_style_comment"]
["src/nvim/strings.c", ["      *d++ = '\\\\';                    /* insert backslash */", "      while (--l != SIZE_MAX)                /* copy the var */", "        *d++ = *p++;"], "readability/old_style_comment"]
["src/nvim/strings.c", ["      *d++ = '\\\\';                    /* insert backslash */", "      while (--l != SIZE_MAX)                /* copy the var */", "        *d++ = *p++;"], "readability/braces"]
["src/nvim/strings.c", ["    *d++ = '\"';", "  } else", "# endif"], "readability/braces"]
["src/nvim/strings.c", ["", "/*", " * Like vim_strsave(), but make all characters uppercase."], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "/*", " * Like vim_strnsave(), but make all characters uppercase."], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "/*", " * ASCII lower-to-upper case translation, language independent."], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "/*", " * delete spaces at the end of a string"], "readability/old_style_comment"]
["src/nvim/strings.c", ["  q = ptr + STRLEN(ptr);", "  while (--q > ptr && ascii_iswhite(q[0]) && q[-1] != '\\\\' && q[-1] != Ctrl_V)", "    *q = NUL;"], "readability/braces"]
["src/nvim/strings.c", ["#if (!defined(HAVE_STRCASECMP) && !defined(HAVE_STRICMP))", "/*", " * Compare two strings, ignoring case, using current locale."], "readability/old_style_comment"]
["src/nvim/strings.c", ["    i = (int)TOLOWER_LOC(*s1) - (int)TOLOWER_LOC(*s2);", "    if (i != 0)", "      return i;                             /* this character different */"], "readability/braces"]
["src/nvim/strings.c", ["    if (i != 0)", "      return i;                             /* this character different */", "    if (*s1 == NUL)"], "readability/old_style_comment"]
["src/nvim/strings.c", ["      return i;                             /* this character different */", "    if (*s1 == NUL)", "      break;                                /* strings match until NUL */"], "readability/braces"]
["src/nvim/strings.c", ["    if (*s1 == NUL)", "      break;                                /* strings match until NUL */", "    ++s1;"], "readability/old_style_comment"]
["src/nvim/strings.c", ["      break;                                /* strings match until NUL */", "    ++s1;", "    ++s2;"], "readability/increment"]
["src/nvim/strings.c", ["    ++s1;", "    ++s2;", "  }"], "readability/increment"]
["src/nvim/strings.c", ["  }", "  return 0;                                 /* strings match */", "}"], "readability/old_style_comment"]
["src/nvim/strings.c", ["#if (!defined(HAVE_STRNCASECMP) && !defined(HAVE_STRNICMP))", "/*", " * Compare two strings, for length \"len\", ignoring case, using current locale."], "readability/old_style_comment"]
["src/nvim/strings.c", ["    i = (int)TOLOWER_LOC(*s1) - (int)TOLOWER_LOC(*s2);", "    if (i != 0)", "      return i;                             /* this character different */"], "readability/braces"]
["src/nvim/strings.c", ["    if (i != 0)", "      return i;                             /* this character different */", "    if (*s1 == NUL)"], "readability/old_style_comment"]
["src/nvim/strings.c", ["      return i;                             /* this character different */", "    if (*s1 == NUL)", "      break;                                /* strings match until NUL */"], "readability/braces"]
["src/nvim/strings.c", ["    if (*s1 == NUL)", "      break;                                /* strings match until NUL */", "    ++s1;"], "readability/old_style_comment"]
["src/nvim/strings.c", ["      break;                                /* strings match until NUL */", "    ++s1;", "    ++s2;"], "readability/increment"]
["src/nvim/strings.c", ["    ++s1;", "    ++s2;", "    --len;"], "readability/increment"]
["src/nvim/strings.c", ["    ++s2;", "    --len;", "  }"], "readability/increment"]
["src/nvim/strings.c", ["  }", "  return 0;                                 /* strings match */", "}"], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "/*", " * Sort an array of strings."], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "/*", " * Return true if string \"s\" contains a non-ASCII character (128 or higher)."], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "  if (s != NULL)", "    for (p = s; *p != NUL; ++p)"], "readability/braces"]
["src/nvim/strings.c", ["  if (s != NULL)", "    for (p = s; *p != NUL; ++p)", "      if (*p >= 128)"], "readability/braces"]
["src/nvim/strings.c", ["  if (s != NULL)", "    for (p = s; *p != NUL; ++p)", "      if (*p >= 128)"], "readability/increment"]
["src/nvim/strings.c", ["    for (p = s; *p != NUL; ++p)", "      if (*p >= 128)", "        return true;"], "readability/braces"]
["src/nvim/strings.c", ["    for (size_t i = 0; i < len; i++) {", "      if ((uint8_t) s[i] >= 128) {", "        return true;"], "whitespace/cast"]
["src/nvim/strings.c", ["", "/*", " * Concatenate two strings and return the result in allocated memory."], "readability/old_style_comment"]
["src/nvim/strings.c", ["        switch (*p) {", "          case '0': zero_padding = 1; p++; continue;", "          case '-': justify_left = 1; p++; continue;"], "whitespace/newline"]
["src/nvim/strings.c", ["          case '0': zero_padding = 1; p++; continue;", "          case '-': justify_left = 1; p++; continue;", "                    // if both '0' and '-' flags appear, '0' should be ignored"], "whitespace/newline"]
["src/nvim/strings.c", ["          case '#': alternate_form = 1; p++; continue;", "          case '\\'': p++; continue;", "          default: break;"], "whitespace/newline"]
["src/nvim/strings.c", ["  return (int)str_l;", "}", ""], "readability/fn_size"]
