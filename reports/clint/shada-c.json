["src/nvim/shada.c", ["#define copy_option_part(src, dest, ...) \\", "    ((char *) copy_option_part((char_u **) src, (char_u *) dest, __VA_ARGS__))", "#define find_shada_parameter(...) \\"], "whitespace/cast"]
["src/nvim/shada.c", ["#define find_shada_parameter(...) \\", "    ((const char *) find_shada_parameter(__VA_ARGS__))", "#define home_replace_save(a, b) \\"], "whitespace/cast"]
["src/nvim/shada.c", ["  if (hmll->free_entry == NULL) {", "    assert((size_t) (hmll->last_free_entry - hmll->entries)", "           == hmll->num_entries);"], "whitespace/cast"]
["src/nvim/shada.c", ["  } else {", "    assert((size_t) (hmll->last_free_entry - hmll->entries) - 1", "           == hmll->num_entries);"], "whitespace/cast"]
["src/nvim/shada.c", ["  }", "  return (int) ret;", "}"], "whitespace/cast"]
["src/nvim/shada.c", ["              \"but file ended earlier\"),", "            (uint64_t) offset);", "      return kSDReadStatusNotShaDa;"], "whitespace/cast"]
["src/nvim/shada.c", ["{", "  return kh_get(bufset, set, (uintptr_t) buf) != kh_end(set);", "}"], "whitespace/cast"]
["src/nvim/shada.c", ["{", "  ShaDaWriteDef *const sd_writer = (ShaDaWriteDef *) data;", "  ptrdiff_t written_bytes = sd_writer->write(sd_writer, buf, len);"], "whitespace/cast"]
["src/nvim/shada.c", ["          .histtype = history_type,", "          .string = (char *) hist_he.hisstr,", "          .sep = (char) (history_type == HIST_SEARCH"], "whitespace/cast"]
["src/nvim/shada.c", ["          .string = (char *) hist_he.hisstr,", "          .sep = (char) (history_type == HIST_SEARCH", "                         ? (char) hist_he.hisstr[STRLEN(hist_he.hisstr) + 1]"], "whitespace/cast"]
["src/nvim/shada.c", ["          .sep = (char) (history_type == HIST_SEARCH", "                         ? (char) hist_he.hisstr[STRLEN(hist_he.hisstr) + 1]", "                         : 0),"], "whitespace/cast"]
["src/nvim/shada.c", ["    hist->timestamp = cur_entry->data.timestamp;", "    hist->hisnum = (int) (hist - hist_array) + 1;", "    hist->hisstr = (char_u *) cur_entry->data.data.history_item.string;"], "whitespace/cast"]
["src/nvim/shada.c", ["    hist->hisnum = (int) (hist - hist_array) + 1;", "    hist->hisstr = (char_u *) cur_entry->data.data.history_item.string;", "    hist->additional_elements ="], "whitespace/cast"]
["src/nvim/shada.c", ["  })", "  *new_hisnum = (int) (hist - hist_array);", "  *new_hisidx = *new_hisnum - 1;"], "whitespace/cast"]
["src/nvim/shada.c", ["  do { \\", "    const int jl_len = (int) jumps_size; \\", "    int i; \\"], "whitespace/cast"]
["src/nvim/shada.c", ["        if (i > 0) { \\", "          memmove(&jumps[0], &jumps[1], sizeof(jumps[1]) * (size_t) i); \\", "        } \\"], "whitespace/cast"]
["src/nvim/shada.c", ["        memmove(&jumps[i + 1], &jumps[i], \\", "                sizeof(jumps[0]) * (size_t) (jl_len - i)); \\", "      } \\"], "whitespace/cast"]
["src/nvim/shada.c", ["      } else if (jl_len > 0) { \\", "        memmove(&jumps[1], &jumps[0], sizeof(jumps[0]) * (size_t) jl_len); \\", "      } \\"], "whitespace/cast"]
["src/nvim/shada.c", ["  const bool want_marks = flags & kShaDaWantMarks;", "  const unsigned srni_flags = (unsigned) (", "      (flags & kShaDaWantInfo"], "whitespace/cast"]
["src/nvim/shada.c", ["    for (uint8_t i = 0; i < HIST_COUNT; i++) {", "      hms_init(&hms[i], i, (size_t) p_hi, true, true);", "    }"], "whitespace/cast"]
["src/nvim/shada.c", ["           },", "           .pat = (char_u *) cur_entry.data.search_pattern.pat,", "           .additional_data = cur_entry.data.search_pattern.additional_data,"], "whitespace/cast"]
["src/nvim/shada.c", ["        // regtilde. Vim was not calling this for some reason.", "        (void) regtilde(cur_entry.data.sub_string.sub, p_magic);", "        // Do not free shada entry: its allocated memory was saved above."], "whitespace/cast"]
["src/nvim/shada.c", ["          .y_type = cur_entry.data.reg.type,", "          .y_width = (colnr_T) cur_entry.data.reg.width,", "          .timestamp = cur_entry.timestamp,"], "whitespace/cast"]
["src/nvim/shada.c", ["        xfmark_T fm = (xfmark_T) {", "          .fname = (char_u *) (buf == NULL", "                               ? cur_entry.data.filemark.fname"], "whitespace/cast"]
["src/nvim/shada.c", ["          int kh_ret;", "          (void) kh_put(bufset, &cl_bufs, (uintptr_t) buf, &kh_ret);", "#define SDE_TO_FMARK(entry) fm"], "whitespace/cast"]
["src/nvim/shada.c", ["    FOR_ALL_TAB_WINDOWS(tp, wp) {", "      (void) tp;", "      if (in_bufset(&cl_bufs, wp->w_buffer)) {"], "whitespace/cast"]
["src/nvim/shada.c", ["  kh_foreach_key(&fname_bufs, key, {", "    xfree((void *) key);", "  })"], "whitespace/cast"]
["src/nvim/shada.c", ["      expand_env((char_u *)file, &(NameBuff[0]), MAXPATHL);", "      file = (const char *) &(NameBuff[0]);", "    }"], "whitespace/cast"]
["src/nvim/shada.c", ["#define ONE_IF_NOT_DEFAULT(entry, attr) \\", "  ((size_t) (!CHECK_DEFAULT(entry, attr)))", "  switch (entry.type) {"], "whitespace/cast"]
["src/nvim/shada.c", ["      if (spacker->callback(spacker->data, entry.data.unknown_item.contents,", "                            (unsigned) entry.data.unknown_item.size) == -1) {", "        goto shada_pack_entry_error;"], "whitespace/cast"]
["src/nvim/shada.c", ["    case kSDItemSearchPattern: {", "      const size_t map_size = (size_t) (", "          1  // Search pattern is always present"], "whitespace/cast"]
["src/nvim/shada.c", ["          // finally, additional data:", "          + (size_t) (", "              entry.data.search_pattern.additional_data"], "whitespace/cast"]
["src/nvim/shada.c", ["    case kSDItemJump: {", "      const size_t map_size = (size_t) (", "          1  // File name"], "whitespace/cast"]
["src/nvim/shada.c", ["          // Additional entries, if any:", "          + (size_t) (", "              entry.data.filemark.additional_data == NULL"], "whitespace/cast"]
["src/nvim/shada.c", ["        PACK_STATIC_STR(KEY_NAME_CHAR);", "        msgpack_pack_uint8(spacker, (uint8_t) entry.data.filemark.name);", "      }"], "whitespace/cast"]
["src/nvim/shada.c", ["    case kSDItemRegister: {", "      const size_t map_size = (size_t) (", "          2  // Register contents and name"], "whitespace/cast"]
["src/nvim/shada.c", ["          // Additional entries, if any:", "          + (size_t) (entry.data.reg.additional_data == NULL", "                      ? 0"], "whitespace/cast"]
["src/nvim/shada.c", ["        PACK_STATIC_STR(REG_KEY_WIDTH);", "        msgpack_pack_uint64(spacker, (uint64_t) entry.data.reg.width);", "      }"], "whitespace/cast"]
["src/nvim/shada.c", ["      for (size_t i = 0; i < entry.data.buffer_list.size; i++) {", "        const size_t map_size = (size_t) (", "            1  // Buffer name"], "whitespace/cast"]
["src/nvim/shada.c", ["            1  // Buffer name", "            + (size_t) (entry.data.buffer_list.buffers[i].pos.lnum", "                        != default_pos.lnum)"], "whitespace/cast"]
["src/nvim/shada.c", ["                        != default_pos.lnum)", "            + (size_t) (entry.data.buffer_list.buffers[i].pos.col", "                        != default_pos.col)"], "whitespace/cast"]
["src/nvim/shada.c", ["            // Additional entries, if any:", "            + (size_t) (", "                entry.data.buffer_list.buffers[i].additional_data == NULL"], "whitespace/cast"]
["src/nvim/shada.c", ["          msgpack_pack_uint64(", "              spacker, (uint64_t) entry.data.buffer_list.buffers[i].pos.lnum);", "        }"], "whitespace/cast"]
["src/nvim/shada.c", ["          msgpack_pack_uint64(", "              spacker, (uint64_t) entry.data.buffer_list.buffers[i].pos.col);", "        }"], "whitespace/cast"]
["src/nvim/shada.c", ["          case kObjectTypeInteger: {", "            msgpack_pack_int64(spacker, (int64_t) obj.data.integer);", "            break;"], "whitespace/cast"]
["src/nvim/shada.c", ["    } else {", "      if (msgpack_pack_uint64(packer, (uint64_t) entry.type) == -1) {", "        goto shada_pack_entry_error;"], "whitespace/cast"]
["src/nvim/shada.c", ["    }", "    if (msgpack_pack_uint64(packer, (uint64_t) entry.timestamp) == -1) {", "      goto shada_pack_entry_error;"], "whitespace/cast"]
["src/nvim/shada.c", ["    if (sbuf.size > 0) {", "      if ((msgpack_pack_uint64(packer, (uint64_t) sbuf.size) == -1)", "          || (packer->callback(packer->data, sbuf.data,"], "whitespace/cast"]
["src/nvim/shada.c", ["          || (packer->callback(packer->data, sbuf.data,", "                               (unsigned) sbuf.size) == -1)) {", "        goto shada_pack_entry_error;"], "whitespace/cast"]
["src/nvim/shada.c", ["              \"at position %\" PRIu64),", "            (uint64_t) initial_fpos);", "      ret = kSDReadStatusNotShaDa;"], "whitespace/cast"]
["src/nvim/shada.c", ["              \"at position %\" PRIu64),", "            (uint64_t) initial_fpos);", "      ret = kSDReadStatusNotShaDa;"], "whitespace/cast"]
["src/nvim/shada.c", ["              \"at position %\" PRIu64),", "            (uint64_t) initial_fpos);", "      ret = kSDReadStatusNotShaDa;"], "whitespace/cast"]
["src/nvim/shada.c", ["        }", "        const char *const fname = (const char *) entry.data.filemark.fname;", "        khiter_t k;"], "whitespace/cast"]
["src/nvim/shada.c", ["  khash_t(bufset) removable_bufs = KHASH_EMPTY_TABLE(bufset);", "  const size_t max_kbyte = (size_t) max_kbyte_i;", "  const size_t num_marked_files = (size_t) get_shada_parameter('\\'');"], "whitespace/cast"]
["src/nvim/shada.c", ["  const size_t max_kbyte = (size_t) max_kbyte_i;", "  const size_t num_marked_files = (size_t) get_shada_parameter('\\'');", "  const bool dump_global_marks = get_shada_parameter('f') != 0;"], "whitespace/cast"]
["src/nvim/shada.c", ["      dump_one_history[i] = true;", "      hms_init(&wms->hms[i], i, (size_t) num_saved, sd_reader != NULL, false);", "    } else {"], "whitespace/cast"]
["src/nvim/shada.c", ["", "  const unsigned srni_flags = (unsigned) (", "      kSDReadUndisableableData"], "whitespace/cast"]
["src/nvim/shada.c", ["          { STATIC_CSTR_AS_STRING(\"max_kbyte\"),", "            INTEGER_OBJ((Integer) max_kbyte) },", "          { STATIC_CSTR_AS_STRING(\"pid\"),"], "whitespace/cast"]
["src/nvim/shada.c", ["          { STATIC_CSTR_AS_STRING(\"pid\"),", "            INTEGER_OBJ((Integer) os_get_pid()) },", "          { STATIC_CSTR_AS_STRING(\"encoding\"),"], "whitespace/cast"]
["src/nvim/shada.c", ["          { STATIC_CSTR_AS_STRING(\"encoding\"),", "            STRING_OBJ(cstr_as_string((char *) p_enc)) },", "        }),"], "whitespace/cast"]
["src/nvim/shada.c", ["          .global_var = {", "            .name = (char *) name,", "            .value = tgttv,"], "whitespace/cast"]
["src/nvim/shada.c", ["        int kh_ret;", "        (void) kh_put(strset, &wms->dumped_variables, name, &kh_ret);", "      }"], "whitespace/cast"]
["src/nvim/shada.c", ["          .sub_string = {", "            .sub = (char *) sub.sub,", "            .additional_elements = sub.additional_elements,"], "whitespace/cast"]
["src/nvim/shada.c", ["        assert(fm.fname != NULL);", "        if (shada_removable((const char *) fm.fname)) {", "          continue;"], "whitespace/cast"]
["src/nvim/shada.c", ["        }", "        fname = (const char *) fm.fname;", "      } else {"], "whitespace/cast"]
["src/nvim/shada.c", ["        }", "        fname = (const char *) buf->b_ffname;", "      }"], "whitespace/cast"]
["src/nvim/shada.c", ["      const void *local_marks_iter = NULL;", "      const char *const fname = (const char *) buf->b_ffname;", "      khiter_t k;"], "whitespace/cast"]
["src/nvim/shada.c", ["                .name = name,", "                .fname = (char *) fname,", "                .additional_data = fm.additional_data,"], "whitespace/cast"]
["src/nvim/shada.c", ["                .mark = fm.mark,", "                .fname = (char *) fname,", "                .additional_data = fm.additional_data,"], "whitespace/cast"]
["src/nvim/shada.c", ["      }", "      filemarks->changes_size = (size_t) buf->b_changelistlen;", "    }"], "whitespace/cast"]
["src/nvim/shada.c", ["  }", "  qsort((void *) all_file_markss, file_markss_size, sizeof(*all_file_markss),", "        &compare_file_marks);"], "whitespace/cast"]
["src/nvim/shada.c", ["    // Save permissions from the original file, with modifications:", "    int perm = (int) os_getperm(fname);", "    perm = (perm >= 0) ? ((perm & 0777) | 0600) : 0600;"], "whitespace/cast"]
["src/nvim/shada.c", ["  // order.", "  uint8_t *buf = (uint8_t *) &big_endian_64_bits;", "  uint64_t ret = 0;"], "whitespace/cast"]
["src/nvim/shada.c", ["  for (size_t i = 8; i; i--) {", "    ret |= ((uint64_t) buf[i - 1]) << ((8 - i) * 8);", "  }"], "whitespace/cast"]
["src/nvim/shada.c", ["              \", but got nothing\"),", "            (uint64_t) fpos);", "      return kSDReadStatusNotShaDa;"], "whitespace/cast"]
["src/nvim/shada.c", ["    // Positive fixnum", "    *result = (uint64_t) ((uint8_t) first_char);", "  } else {"], "whitespace/cast"]
["src/nvim/shada.c", ["                \"expected positive integer at position %\" PRIu64),", "              (uint64_t) fpos);", "        return kSDReadStatusNotShaDa;"], "whitespace/cast"]
["src/nvim/shada.c", ["    uint64_t buf = 0;", "    char *buf_u8 = (char *) &buf;", "    ShaDaReadResult fl_ret;"], "whitespace/cast"]
["src/nvim/shada.c", ["              .map = { \\", "                .size = (uint32_t) ad_ga.ga_len, \\", "                .ptr = ad_ga.ga_data, \\"], "whitespace/cast"]
["src/nvim/shada.c", ["      do { \\", "        if ((src).size > (size_t) (src_maxsize)) { \\", "          msgpack_object obj = { \\"], "whitespace/cast"]
["src/nvim/shada.c", ["              .array = { \\", "                .size = ((src).size - (uint32_t) (src_maxsize)), \\", "                .ptr = (src).ptr + (src_maxsize), \\"], "whitespace/cast"]
["src/nvim/shada.c", ["  // This is needed to avoid both seeking and having to maintain a buffer.", "  uint64_t type_u64 = (uint64_t) kSDItemMissing;", "  uint64_t timestamp_u64;"], "whitespace/cast"]
["src/nvim/shada.c", ["", "  const uint64_t initial_fpos = (uint64_t) sd_reader->fpos;", "  const int first_char = read_char(sd_reader);"], "whitespace/cast"]
["src/nvim/shada.c", ["       ? !(flags & kSDReadUnknown)", "       : !((unsigned) (1 << type_u64) & flags))", "      || (max_kbyte && length > max_kbyte * 1024)) {"], "whitespace/cast"]
["src/nvim/shada.c", ["  entry->data = sd_default_values[type_u64].data;", "  switch ((ShadaEntryType) type_u64) {", "    case kSDItemHeader: {"], "whitespace/cast"]
["src/nvim/shada.c", ["      entry->data.history_item.histtype =", "          (uint8_t) unpacked.data.via.array.ptr[0].via.u64;", "      const bool is_hist_search ="], "whitespace/cast"]
["src/nvim/shada.c", ["        entry->data.history_item.sep =", "            (char) unpacked.data.via.array.ptr[2].via.u64;", "      }"], "whitespace/cast"]
["src/nvim/shada.c", ["  }", "  entry->type = (ShadaEntryType) type_u64;", "  ret = kSDReadStatusSuccess;"], "whitespace/cast"]
["src/nvim/shada.c", ["shada_read_next_item_error:", "  entry->type = (ShadaEntryType) type_u64;", "  shada_free_shada_entry(entry);"], "whitespace/cast"]
["src/nvim/shada.c", ["  char *new_name = home_replace_save(NULL, name);", "  for (p = (char *) p_shada; *p; ) {", "    (void) copy_option_part(&p, part, ARRAY_SIZE(part), \", \");"], "whitespace/cast"]
["src/nvim/shada.c", ["  for (p = (char *) p_shada; *p; ) {", "    (void) copy_option_part(&p, part, ARRAY_SIZE(part), \", \");", "    if (part[0] == 'r') {"], "whitespace/cast"]
["src/nvim/shada.c", ["    }", "    const char *const fname = (char *) (fm.fmark.fnum == 0", "                                        ? (fm.fname == NULL ? NULL : fm.fname)"], "whitespace/cast"]
["src/nvim/shada.c", ["            .mark = fm.fmark.mark,", "            .fname = (char *) fname,", "            .additional_data = fm.fmark.additional_data,"], "whitespace/cast"]
