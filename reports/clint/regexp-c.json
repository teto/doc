["src/nvim/regexp.c", ["", "/*", " * Handling of regular expressions: vim_regcomp(), vim_regexec(), vim_regsub()"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#ifdef REGEXP_DEBUG", "/* show/save debugging data when BT engine is used */", "# define BT_REGEXP_DUMP"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["# define BT_REGEXP_DUMP", "/* save the debugging data to a file instead of displaying it */", "# define BT_REGEXP_LOG"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * The \"internal use only\" fields in regexp_defs.h are present to pass info from"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Structure for regexp \"program\".  This is essentially a linear encoding"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * The opcodes are:"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/* definition\tnumber\t\t   opnd?    meaning */", "#define END             0       /*\tEnd of program or NOMATCH operand. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/* definition\tnumber\t\t   opnd?    meaning */", "#define END             0       /*\tEnd of program or NOMATCH operand. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["/* definition\tnumber\t\t   opnd?    meaning */", "#define END             0       /*\tEnd of program or NOMATCH operand. */", "#define BOL             1       /*\tMatch \"\" at beginning of line. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["/* definition\tnumber\t\t   opnd?    meaning */", "#define END             0       /*\tEnd of program or NOMATCH operand. */", "#define BOL             1       /*\tMatch \"\" at beginning of line. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define END             0       /*\tEnd of program or NOMATCH operand. */", "#define BOL             1       /*\tMatch \"\" at beginning of line. */", "#define EOL             2       /*\tMatch \"\" at end of line. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define END             0       /*\tEnd of program or NOMATCH operand. */", "#define BOL             1       /*\tMatch \"\" at beginning of line. */", "#define EOL             2       /*\tMatch \"\" at end of line. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define BOL             1       /*\tMatch \"\" at beginning of line. */", "#define EOL             2       /*\tMatch \"\" at end of line. */", "#define BRANCH          3       /* node Match this alternative, or the"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define BOL             1       /*\tMatch \"\" at beginning of line. */", "#define EOL             2       /*\tMatch \"\" at end of line. */", "#define BRANCH          3       /* node Match this alternative, or the"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define EOL             2       /*\tMatch \"\" at end of line. */", "#define BRANCH          3       /* node Match this alternative, or the", "                                 *\tnext... */"], "readability/multiline_comment"]
["src/nvim/regexp.c", ["#define EOL             2       /*\tMatch \"\" at end of line. */", "#define BRANCH          3       /* node Match this alternative, or the", "                                 *\tnext... */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define BRANCH          3       /* node Match this alternative, or the", "                                 *\tnext... */", "#define BACK            4       /*\tMatch \"\", \"next\" ptr points backward. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["                                 *\tnext... */", "#define BACK            4       /*\tMatch \"\", \"next\" ptr points backward. */", "#define EXACTLY         5       /* str\tMatch this string. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["                                 *\tnext... */", "#define BACK            4       /*\tMatch \"\", \"next\" ptr points backward. */", "#define EXACTLY         5       /* str\tMatch this string. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define BACK            4       /*\tMatch \"\", \"next\" ptr points backward. */", "#define EXACTLY         5       /* str\tMatch this string. */", "#define NOTHING         6       /*\tMatch empty string. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define BACK            4       /*\tMatch \"\", \"next\" ptr points backward. */", "#define EXACTLY         5       /* str\tMatch this string. */", "#define NOTHING         6       /*\tMatch empty string. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define EXACTLY         5       /* str\tMatch this string. */", "#define NOTHING         6       /*\tMatch empty string. */", "#define STAR            7       /* node Match this (simple) thing 0 or more"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define EXACTLY         5       /* str\tMatch this string. */", "#define NOTHING         6       /*\tMatch empty string. */", "#define STAR            7       /* node Match this (simple) thing 0 or more"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NOTHING         6       /*\tMatch empty string. */", "#define STAR            7       /* node Match this (simple) thing 0 or more", "                                 *\ttimes. */"], "readability/multiline_comment"]
["src/nvim/regexp.c", ["#define NOTHING         6       /*\tMatch empty string. */", "#define STAR            7       /* node Match this (simple) thing 0 or more", "                                 *\ttimes. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define STAR            7       /* node Match this (simple) thing 0 or more", "                                 *\ttimes. */", "#define PLUS            8       /* node Match this (simple) thing 1 or more"], "whitespace/tab"]
["src/nvim/regexp.c", ["                                 *\ttimes. */", "#define PLUS            8       /* node Match this (simple) thing 1 or more", "                                 *\ttimes. */"], "readability/multiline_comment"]
["src/nvim/regexp.c", ["                                 *\ttimes. */", "#define PLUS            8       /* node Match this (simple) thing 1 or more", "                                 *\ttimes. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define PLUS            8       /* node Match this (simple) thing 1 or more", "                                 *\ttimes. */", "#define MATCH           9       /* node match the operand zero-width */"], "whitespace/tab"]
["src/nvim/regexp.c", ["                                 *\ttimes. */", "#define MATCH           9       /* node match the operand zero-width */", "#define NOMATCH         10      /* node check for no match with operand */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define MATCH           9       /* node match the operand zero-width */", "#define NOMATCH         10      /* node check for no match with operand */", "#define BEHIND          11      /* node look behind for a match with operand */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define NOMATCH         10      /* node check for no match with operand */", "#define BEHIND          11      /* node look behind for a match with operand */", "#define NOBEHIND        12      /* node look behind for no match with operand */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define BEHIND          11      /* node look behind for a match with operand */", "#define NOBEHIND        12      /* node look behind for no match with operand */", "#define SUBPAT          13      /* node match the operand here */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define NOBEHIND        12      /* node look behind for no match with operand */", "#define SUBPAT          13      /* node match the operand here */", "#define BRACE_SIMPLE    14      /* node Match this (simple) thing between m and"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define SUBPAT          13      /* node match the operand here */", "#define BRACE_SIMPLE    14      /* node Match this (simple) thing between m and", "                                 *\tn times (\\{m,n\\}). */"], "readability/multiline_comment"]
["src/nvim/regexp.c", ["#define SUBPAT          13      /* node match the operand here */", "#define BRACE_SIMPLE    14      /* node Match this (simple) thing between m and", "                                 *\tn times (\\{m,n\\}). */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define BRACE_SIMPLE    14      /* node Match this (simple) thing between m and", "                                 *\tn times (\\{m,n\\}). */", "#define BOW             15      /*\tMatch \"\" after [^a-zA-Z0-9_] */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define BRACE_SIMPLE    14      /* node Match this (simple) thing between m and", "                                 *\tn times (\\{m,n\\}). */", "#define BOW             15      /*\tMatch \"\" after [^a-zA-Z0-9_] */"], "whitespace/comma"]
["src/nvim/regexp.c", ["#define BRACE_SIMPLE    14      /* node Match this (simple) thing between m and", "                                 *\tn times (\\{m,n\\}). */", "#define BOW             15      /*\tMatch \"\" after [^a-zA-Z0-9_] */"], "whitespace/parens"]
["src/nvim/regexp.c", ["#define BRACE_SIMPLE    14      /* node Match this (simple) thing between m and", "                                 *\tn times (\\{m,n\\}). */", "#define BOW             15      /*\tMatch \"\" after [^a-zA-Z0-9_] */"], "whitespace/braces"]
["src/nvim/regexp.c", ["#define BRACE_SIMPLE    14      /* node Match this (simple) thing between m and", "                                 *\tn times (\\{m,n\\}). */", "#define BOW             15      /*\tMatch \"\" after [^a-zA-Z0-9_] */"], "whitespace/braces"]
["src/nvim/regexp.c", ["                                 *\tn times (\\{m,n\\}). */", "#define BOW             15      /*\tMatch \"\" after [^a-zA-Z0-9_] */", "#define EOW             16      /*\tMatch \"\" at    [^a-zA-Z0-9_] */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["                                 *\tn times (\\{m,n\\}). */", "#define BOW             15      /*\tMatch \"\" after [^a-zA-Z0-9_] */", "#define EOW             16      /*\tMatch \"\" at    [^a-zA-Z0-9_] */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define BOW             15      /*\tMatch \"\" after [^a-zA-Z0-9_] */", "#define EOW             16      /*\tMatch \"\" at    [^a-zA-Z0-9_] */", "#define BRACE_LIMITS    17      /* nr nr  define the min & max for BRACE_SIMPLE"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define BOW             15      /*\tMatch \"\" after [^a-zA-Z0-9_] */", "#define EOW             16      /*\tMatch \"\" at    [^a-zA-Z0-9_] */", "#define BRACE_LIMITS    17      /* nr nr  define the min & max for BRACE_SIMPLE"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define EOW             16      /*\tMatch \"\" at    [^a-zA-Z0-9_] */", "#define BRACE_LIMITS    17      /* nr nr  define the min & max for BRACE_SIMPLE", "                                 *\tand BRACE_COMPLEX. */"], "readability/multiline_comment"]
["src/nvim/regexp.c", ["#define EOW             16      /*\tMatch \"\" at    [^a-zA-Z0-9_] */", "#define BRACE_LIMITS    17      /* nr nr  define the min & max for BRACE_SIMPLE", "                                 *\tand BRACE_COMPLEX. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define BRACE_LIMITS    17      /* nr nr  define the min & max for BRACE_SIMPLE", "                                 *\tand BRACE_COMPLEX. */", "#define NEWL            18      /*\tMatch line-break */"], "whitespace/tab"]
["src/nvim/regexp.c", ["                                 *\tand BRACE_COMPLEX. */", "#define NEWL            18      /*\tMatch line-break */", "#define BHPOS           19      /*\tEnd position for BEHIND or NOBEHIND */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["                                 *\tand BRACE_COMPLEX. */", "#define NEWL            18      /*\tMatch line-break */", "#define BHPOS           19      /*\tEnd position for BEHIND or NOBEHIND */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NEWL            18      /*\tMatch line-break */", "#define BHPOS           19      /*\tEnd position for BEHIND or NOBEHIND */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define NEWL            18      /*\tMatch line-break */", "#define BHPOS           19      /*\tEnd position for BEHIND or NOBEHIND */", ""], "whitespace/tab"]
["src/nvim/regexp.c", ["", "/* character classes: 20-48 normal, 50-78 include a line-break */", "#define ADD_NL          30"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define FIRST_NL        ANY + ADD_NL", "#define ANY             20      /*\tMatch any one character. */", "#define ANYOF           21      /* str\tMatch any character in this string. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define FIRST_NL        ANY + ADD_NL", "#define ANY             20      /*\tMatch any one character. */", "#define ANYOF           21      /* str\tMatch any character in this string. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define ANY             20      /*\tMatch any one character. */", "#define ANYOF           21      /* str\tMatch any character in this string. */", "#define ANYBUT          22      /* str\tMatch any character not in this"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define ANY             20      /*\tMatch any one character. */", "#define ANYOF           21      /* str\tMatch any character in this string. */", "#define ANYBUT          22      /* str\tMatch any character not in this"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define ANYOF           21      /* str\tMatch any character in this string. */", "#define ANYBUT          22      /* str\tMatch any character not in this", "                                 *\tstring. */"], "readability/multiline_comment"]
["src/nvim/regexp.c", ["#define ANYOF           21      /* str\tMatch any character in this string. */", "#define ANYBUT          22      /* str\tMatch any character not in this", "                                 *\tstring. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define ANYOF           21      /* str\tMatch any character in this string. */", "#define ANYBUT          22      /* str\tMatch any character not in this", "                                 *\tstring. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define ANYBUT          22      /* str\tMatch any character not in this", "                                 *\tstring. */", "#define IDENT           23      /*\tMatch identifier char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["                                 *\tstring. */", "#define IDENT           23      /*\tMatch identifier char */", "#define SIDENT          24      /*\tMatch identifier char but no digit */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["                                 *\tstring. */", "#define IDENT           23      /*\tMatch identifier char */", "#define SIDENT          24      /*\tMatch identifier char but no digit */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define IDENT           23      /*\tMatch identifier char */", "#define SIDENT          24      /*\tMatch identifier char but no digit */", "#define KWORD           25      /*\tMatch keyword char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define IDENT           23      /*\tMatch identifier char */", "#define SIDENT          24      /*\tMatch identifier char but no digit */", "#define KWORD           25      /*\tMatch keyword char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define SIDENT          24      /*\tMatch identifier char but no digit */", "#define KWORD           25      /*\tMatch keyword char */", "#define SKWORD          26      /*\tMatch word char but no digit */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define SIDENT          24      /*\tMatch identifier char but no digit */", "#define KWORD           25      /*\tMatch keyword char */", "#define SKWORD          26      /*\tMatch word char but no digit */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define KWORD           25      /*\tMatch keyword char */", "#define SKWORD          26      /*\tMatch word char but no digit */", "#define FNAME           27      /*\tMatch file name char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define KWORD           25      /*\tMatch keyword char */", "#define SKWORD          26      /*\tMatch word char but no digit */", "#define FNAME           27      /*\tMatch file name char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define SKWORD          26      /*\tMatch word char but no digit */", "#define FNAME           27      /*\tMatch file name char */", "#define SFNAME          28      /*\tMatch file name char but no digit */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define SKWORD          26      /*\tMatch word char but no digit */", "#define FNAME           27      /*\tMatch file name char */", "#define SFNAME          28      /*\tMatch file name char but no digit */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define FNAME           27      /*\tMatch file name char */", "#define SFNAME          28      /*\tMatch file name char but no digit */", "#define PRINT           29      /*\tMatch printable char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define FNAME           27      /*\tMatch file name char */", "#define SFNAME          28      /*\tMatch file name char but no digit */", "#define PRINT           29      /*\tMatch printable char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define SFNAME          28      /*\tMatch file name char but no digit */", "#define PRINT           29      /*\tMatch printable char */", "#define SPRINT          30      /*\tMatch printable char but no digit */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define SFNAME          28      /*\tMatch file name char but no digit */", "#define PRINT           29      /*\tMatch printable char */", "#define SPRINT          30      /*\tMatch printable char but no digit */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define PRINT           29      /*\tMatch printable char */", "#define SPRINT          30      /*\tMatch printable char but no digit */", "#define WHITE           31      /*\tMatch whitespace char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define PRINT           29      /*\tMatch printable char */", "#define SPRINT          30      /*\tMatch printable char but no digit */", "#define WHITE           31      /*\tMatch whitespace char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define SPRINT          30      /*\tMatch printable char but no digit */", "#define WHITE           31      /*\tMatch whitespace char */", "#define NWHITE          32      /*\tMatch non-whitespace char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define SPRINT          30      /*\tMatch printable char but no digit */", "#define WHITE           31      /*\tMatch whitespace char */", "#define NWHITE          32      /*\tMatch non-whitespace char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define WHITE           31      /*\tMatch whitespace char */", "#define NWHITE          32      /*\tMatch non-whitespace char */", "#define DIGIT           33      /*\tMatch digit char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define WHITE           31      /*\tMatch whitespace char */", "#define NWHITE          32      /*\tMatch non-whitespace char */", "#define DIGIT           33      /*\tMatch digit char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NWHITE          32      /*\tMatch non-whitespace char */", "#define DIGIT           33      /*\tMatch digit char */", "#define NDIGIT          34      /*\tMatch non-digit char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define NWHITE          32      /*\tMatch non-whitespace char */", "#define DIGIT           33      /*\tMatch digit char */", "#define NDIGIT          34      /*\tMatch non-digit char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define DIGIT           33      /*\tMatch digit char */", "#define NDIGIT          34      /*\tMatch non-digit char */", "#define HEX             35      /*\tMatch hex char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define DIGIT           33      /*\tMatch digit char */", "#define NDIGIT          34      /*\tMatch non-digit char */", "#define HEX             35      /*\tMatch hex char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NDIGIT          34      /*\tMatch non-digit char */", "#define HEX             35      /*\tMatch hex char */", "#define NHEX            36      /*\tMatch non-hex char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define NDIGIT          34      /*\tMatch non-digit char */", "#define HEX             35      /*\tMatch hex char */", "#define NHEX            36      /*\tMatch non-hex char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define HEX             35      /*\tMatch hex char */", "#define NHEX            36      /*\tMatch non-hex char */", "#define OCTAL           37      /*\tMatch octal char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define HEX             35      /*\tMatch hex char */", "#define NHEX            36      /*\tMatch non-hex char */", "#define OCTAL           37      /*\tMatch octal char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NHEX            36      /*\tMatch non-hex char */", "#define OCTAL           37      /*\tMatch octal char */", "#define NOCTAL          38      /*\tMatch non-octal char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define NHEX            36      /*\tMatch non-hex char */", "#define OCTAL           37      /*\tMatch octal char */", "#define NOCTAL          38      /*\tMatch non-octal char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define OCTAL           37      /*\tMatch octal char */", "#define NOCTAL          38      /*\tMatch non-octal char */", "#define WORD            39      /*\tMatch word char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define OCTAL           37      /*\tMatch octal char */", "#define NOCTAL          38      /*\tMatch non-octal char */", "#define WORD            39      /*\tMatch word char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NOCTAL          38      /*\tMatch non-octal char */", "#define WORD            39      /*\tMatch word char */", "#define NWORD           40      /*\tMatch non-word char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define NOCTAL          38      /*\tMatch non-octal char */", "#define WORD            39      /*\tMatch word char */", "#define NWORD           40      /*\tMatch non-word char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define WORD            39      /*\tMatch word char */", "#define NWORD           40      /*\tMatch non-word char */", "#define HEAD            41      /*\tMatch head char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define WORD            39      /*\tMatch word char */", "#define NWORD           40      /*\tMatch non-word char */", "#define HEAD            41      /*\tMatch head char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NWORD           40      /*\tMatch non-word char */", "#define HEAD            41      /*\tMatch head char */", "#define NHEAD           42      /*\tMatch non-head char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define NWORD           40      /*\tMatch non-word char */", "#define HEAD            41      /*\tMatch head char */", "#define NHEAD           42      /*\tMatch non-head char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define HEAD            41      /*\tMatch head char */", "#define NHEAD           42      /*\tMatch non-head char */", "#define ALPHA           43      /*\tMatch alpha char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define HEAD            41      /*\tMatch head char */", "#define NHEAD           42      /*\tMatch non-head char */", "#define ALPHA           43      /*\tMatch alpha char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NHEAD           42      /*\tMatch non-head char */", "#define ALPHA           43      /*\tMatch alpha char */", "#define NALPHA          44      /*\tMatch non-alpha char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define NHEAD           42      /*\tMatch non-head char */", "#define ALPHA           43      /*\tMatch alpha char */", "#define NALPHA          44      /*\tMatch non-alpha char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define ALPHA           43      /*\tMatch alpha char */", "#define NALPHA          44      /*\tMatch non-alpha char */", "#define LOWER           45      /*\tMatch lowercase char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define ALPHA           43      /*\tMatch alpha char */", "#define NALPHA          44      /*\tMatch non-alpha char */", "#define LOWER           45      /*\tMatch lowercase char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NALPHA          44      /*\tMatch non-alpha char */", "#define LOWER           45      /*\tMatch lowercase char */", "#define NLOWER          46      /*\tMatch non-lowercase char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define NALPHA          44      /*\tMatch non-alpha char */", "#define LOWER           45      /*\tMatch lowercase char */", "#define NLOWER          46      /*\tMatch non-lowercase char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define LOWER           45      /*\tMatch lowercase char */", "#define NLOWER          46      /*\tMatch non-lowercase char */", "#define UPPER           47      /*\tMatch uppercase char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define LOWER           45      /*\tMatch lowercase char */", "#define NLOWER          46      /*\tMatch non-lowercase char */", "#define UPPER           47      /*\tMatch uppercase char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NLOWER          46      /*\tMatch non-lowercase char */", "#define UPPER           47      /*\tMatch uppercase char */", "#define NUPPER          48      /*\tMatch non-uppercase char */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define NLOWER          46      /*\tMatch non-lowercase char */", "#define UPPER           47      /*\tMatch uppercase char */", "#define NUPPER          48      /*\tMatch non-uppercase char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define UPPER           47      /*\tMatch uppercase char */", "#define NUPPER          48      /*\tMatch non-uppercase char */", "#define LAST_NL         NUPPER + ADD_NL"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define UPPER           47      /*\tMatch uppercase char */", "#define NUPPER          48      /*\tMatch non-uppercase char */", "#define LAST_NL         NUPPER + ADD_NL"], "whitespace/tab"]
["src/nvim/regexp.c", ["", "#define BRACE_COMPLEX   140 /* -149 node Match nodes between m & n times */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "#define MULTIBYTECODE   200     /* mbc\tMatch one multi-byte character */", "#define RE_BOF          201     /*\tMatch \"\" at beginning of file. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "#define MULTIBYTECODE   200     /* mbc\tMatch one multi-byte character */", "#define RE_BOF          201     /*\tMatch \"\" at beginning of file. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define MULTIBYTECODE   200     /* mbc\tMatch one multi-byte character */", "#define RE_BOF          201     /*\tMatch \"\" at beginning of file. */", "#define RE_EOF          202     /*\tMatch \"\" at end of file. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define MULTIBYTECODE   200     /* mbc\tMatch one multi-byte character */", "#define RE_BOF          201     /*\tMatch \"\" at beginning of file. */", "#define RE_EOF          202     /*\tMatch \"\" at end of file. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define RE_BOF          201     /*\tMatch \"\" at beginning of file. */", "#define RE_EOF          202     /*\tMatch \"\" at end of file. */", "#define CURSOR          203     /*\tMatch location of cursor. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define RE_BOF          201     /*\tMatch \"\" at beginning of file. */", "#define RE_EOF          202     /*\tMatch \"\" at end of file. */", "#define CURSOR          203     /*\tMatch location of cursor. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define RE_EOF          202     /*\tMatch \"\" at end of file. */", "#define CURSOR          203     /*\tMatch location of cursor. */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define RE_EOF          202     /*\tMatch \"\" at end of file. */", "#define CURSOR          203     /*\tMatch location of cursor. */", ""], "whitespace/tab"]
["src/nvim/regexp.c", ["", "#define RE_LNUM         204     /* nr cmp  Match line number */", "#define RE_COL          205     /* nr cmp  Match column number */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define RE_LNUM         204     /* nr cmp  Match line number */", "#define RE_COL          205     /* nr cmp  Match column number */", "#define RE_VCOL         206     /* nr cmp  Match virtual column number */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define RE_COL          205     /* nr cmp  Match column number */", "#define RE_VCOL         206     /* nr cmp  Match virtual column number */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "#define RE_MARK         207     /* mark cmp  Match mark position */", "#define RE_VISUAL       208     /*\tMatch Visual area */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define RE_MARK         207     /* mark cmp  Match mark position */", "#define RE_VISUAL       208     /*\tMatch Visual area */", "#define RE_COMPOSING    209     // any composing characters"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define RE_MARK         207     /* mark cmp  Match mark position */", "#define RE_VISUAL       208     /*\tMatch Visual area */", "#define RE_COMPOSING    209     // any composing characters"], "whitespace/tab"]
["src/nvim/regexp.c", ["", "/*", " * Magic characters have a special meaning, they don't match literally."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * We should define ftpr as a pointer to a function returning a pointer to"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Structure used to save the current input state, when it needs to be"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/* struct to save start/end pointer/position in for \\(\\) */", "typedef struct {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/* used for BEHIND and NOBEHIND matching */", "typedef struct regbehind_S {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/* Values for rs_state in regitem_T. */", "typedef enum regstate_E {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["typedef enum regstate_E {", "  RS_NOPEN = 0          /* NOPEN and NCLOSE */", "  , RS_MOPEN            /* MOPEN + [0-9] */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  RS_NOPEN = 0          /* NOPEN and NCLOSE */", "  , RS_MOPEN            /* MOPEN + [0-9] */", "  , RS_MCLOSE           /* MCLOSE + [0-9] */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  , RS_MOPEN            /* MOPEN + [0-9] */", "  , RS_MCLOSE           /* MCLOSE + [0-9] */", "  , RS_ZOPEN            /* ZOPEN + [0-9] */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  , RS_MCLOSE           /* MCLOSE + [0-9] */", "  , RS_ZOPEN            /* ZOPEN + [0-9] */", "  , RS_ZCLOSE           /* ZCLOSE + [0-9] */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  , RS_ZOPEN            /* ZOPEN + [0-9] */", "  , RS_ZCLOSE           /* ZCLOSE + [0-9] */", "  , RS_BRANCH           /* BRANCH */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  , RS_ZCLOSE           /* ZCLOSE + [0-9] */", "  , RS_BRANCH           /* BRANCH */", "  , RS_BRCPLX_MORE      /* BRACE_COMPLEX and trying one more match */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  , RS_BRANCH           /* BRANCH */", "  , RS_BRCPLX_MORE      /* BRACE_COMPLEX and trying one more match */", "  , RS_BRCPLX_LONG      /* BRACE_COMPLEX and trying longest match */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  , RS_BRCPLX_MORE      /* BRACE_COMPLEX and trying one more match */", "  , RS_BRCPLX_LONG      /* BRACE_COMPLEX and trying longest match */", "  , RS_BRCPLX_SHORT     /* BRACE_COMPLEX and trying shortest match */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  , RS_BRCPLX_LONG      /* BRACE_COMPLEX and trying longest match */", "  , RS_BRCPLX_SHORT     /* BRACE_COMPLEX and trying shortest match */", "  , RS_NOMATCH          /* NOMATCH */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  , RS_BRCPLX_SHORT     /* BRACE_COMPLEX and trying shortest match */", "  , RS_NOMATCH          /* NOMATCH */", "  , RS_BEHIND1          /* BEHIND / NOBEHIND matching rest */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  , RS_NOMATCH          /* NOMATCH */", "  , RS_BEHIND1          /* BEHIND / NOBEHIND matching rest */", "  , RS_BEHIND2          /* BEHIND / NOBEHIND matching behind part */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  , RS_BEHIND1          /* BEHIND / NOBEHIND matching rest */", "  , RS_BEHIND2          /* BEHIND / NOBEHIND matching behind part */", "  , RS_STAR_LONG        /* STAR/PLUS/BRACE_SIMPLE longest match */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  , RS_BEHIND2          /* BEHIND / NOBEHIND matching behind part */", "  , RS_STAR_LONG        /* STAR/PLUS/BRACE_SIMPLE longest match */", "  , RS_STAR_SHORT       /* STAR/PLUS/BRACE_SIMPLE shortest match */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  , RS_STAR_LONG        /* STAR/PLUS/BRACE_SIMPLE longest match */", "  , RS_STAR_SHORT       /* STAR/PLUS/BRACE_SIMPLE shortest match */", "} regstate_T;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * When there are alternatives a regstate_T is put on the regstack to remember"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/* used for STAR, PLUS and BRACE_SIMPLE matching */", "typedef struct regstar_S {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["typedef struct regstar_S {", "  int nextb;                    /* next byte */", "  int nextb_ic;                 /* next byte reverse case */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  int nextb;                    /* next byte */", "  int nextb_ic;                 /* next byte reverse case */", "  long count;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/* used to store input position when a BACK was encountered, so that we now if", " * we made any progress since the last time. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["typedef struct backpos_S {", "  char_u      *bp_scan;         /* \"scan\" where BACK was encountered */", "  regsave_T bp_pos;             /* last input position */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  char_u      *bp_scan;         /* \"scan\" where BACK was encountered */", "  regsave_T bp_pos;             /* last input position */", "} backpos_T;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["{", "  if (is_Magic(x))", "    return un_Magic(x);"], "readability/braces"]
["src/nvim/regexp.c", ["{", "  if (is_Magic(x))", "    return un_Magic(x);"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * The first byte of the regexp internal \"program\" is actually this magic"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Opcode notes:"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * A node is one char of opcode followed by two chars of \"next\" pointer."], "readability/old_style_comment"]
["src/nvim/regexp.c", [" */", "#define OP(p)           ((int)*(p))", "#define NEXT(p)         (((*((p) + 1) & 0377) << 8) + (*((p) + 2) & 0377))"], "whitespace/operators"]
["src/nvim/regexp.c", ["#define OPERAND(p)      ((p) + 3)", "/* Obtain an operand that was stored as four bytes, MSB first. */", "#define OPERAND_MIN(p)  (((long)(p)[3] << 24) + ((long)(p)[4] << 16) \\"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["                         + ((long)(p)[5] << 8) + (long)(p)[6])", "/* Obtain a second operand stored as four bytes. */", "#define OPERAND_MAX(p)  OPERAND_MIN((p) + 4)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define OPERAND_MAX(p)  OPERAND_MIN((p) + 4)", "/* Obtain a second single-byte operand stored after a four bytes operand. */", "#define OPERAND_CMP(p)  (p)[7]"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Utility definitions."], "readability/old_style_comment"]
["src/nvim/regexp.c", [" */", "#define UCHARAT(p)      ((int)*(char_u *)(p))", ""], "whitespace/operators"]
["src/nvim/regexp.c", ["", "/* Used for an error (down from) vim_regcomp(): give the error message, set", " * rc_did_emsg and return NULL */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define MULTI_MULT      2", "/*", " * Return NOT_MULTI if c is not a \"multi\" operator."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["{", "  if (c == Magic('@') || c == Magic('=') || c == Magic('?'))", "    return MULTI_ONE;"], "readability/braces"]
["src/nvim/regexp.c", ["    return MULTI_ONE;", "  if (c == Magic('*') || c == Magic('+') || c == Magic('{'))", "    return MULTI_MULT;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Flags to be passed up and down."], "readability/old_style_comment"]
["src/nvim/regexp.c", [" */", "#define HASWIDTH        0x1     /* Known never to match null string. */", "#define SIMPLE          0x2     /* Simple enough to be STAR/PLUS operand. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define HASWIDTH        0x1     /* Known never to match null string. */", "#define SIMPLE          0x2     /* Simple enough to be STAR/PLUS operand. */", "#define SPSTART         0x4     /* Starts with * or +. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define SIMPLE          0x2     /* Simple enough to be STAR/PLUS operand. */", "#define SPSTART         0x4     /* Starts with * or +. */", "#define HASNL           0x8     /* Contains some \\n. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define SPSTART         0x4     /* Starts with * or +. */", "#define HASNL           0x8     /* Contains some \\n. */", "#define HASLOOKBH       0x10    /* Contains \"\\@<=\" or \"\\@<!\". */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define HASNL           0x8     /* Contains some \\n. */", "#define HASLOOKBH       0x10    /* Contains \"\\@<=\" or \"\\@<!\". */", "#define WORST           0       /* Worst case. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define HASLOOKBH       0x10    /* Contains \"\\@<=\" or \"\\@<!\". */", "#define WORST           0       /* Worst case. */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * When regcode is set to this value, code is not emitted and size is computed"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * REGEXP_INRANGE contains all characters which are always special in a []"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Translate '\\x' to its control character, except \"\\n\", which is Magic."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Check for a character class name \"[:name:]\".  \"pp\" points to the '['."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  static const char *(class_names[]) =", "  {", "    \"alnum:]\","], "whitespace/braces"]
["src/nvim/regexp.c", ["  if ((*pp)[1] == ':') {", "    for (i = 0; i < (int)ARRAY_SIZE(class_names); ++i)", "      if (STRNCMP(*pp + 2, class_names[i], STRLEN(class_names[i])) == 0) {"], "readability/braces"]
["src/nvim/regexp.c", ["  if ((*pp)[1] == ':') {", "    for (i = 0; i < (int)ARRAY_SIZE(class_names); ++i)", "      if (STRNCMP(*pp + 2, class_names[i], STRLEN(class_names[i])) == 0) {"], "readability/increment"]
["src/nvim/regexp.c", ["", "/*", " * Specific version of character class functions."], "readability/old_style_comment"]
["src/nvim/regexp.c", [" */", "static short class_tab[256];", ""], "runtime/int"]
["src/nvim/regexp.c", ["", "  if (done)", "    return;"], "readability/braces"]
["src/nvim/regexp.c", ["", "  for (i = 0; i < 256; ++i) {", "    if (i >= '0' && i <= '7')"], "readability/increment"]
["src/nvim/regexp.c", ["  for (i = 0; i < 256; ++i) {", "    if (i >= '0' && i <= '7')", "      class_tab[i] = RI_DIGIT + RI_HEX + RI_OCTAL + RI_WORD;"], "readability/braces"]
["src/nvim/regexp.c", ["      class_tab[i] = RI_DIGIT + RI_HEX + RI_OCTAL + RI_WORD;", "    else if (i >= '8' && i <= '9')", "      class_tab[i] = RI_DIGIT + RI_HEX + RI_WORD;"], "readability/braces"]
["src/nvim/regexp.c", ["      class_tab[i] = RI_DIGIT + RI_HEX + RI_WORD;", "    else if (i >= 'a' && i <= 'f')", "      class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;"], "readability/braces"]
["src/nvim/regexp.c", ["      class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;", "    else if (i >= 'g' && i <= 'z')", "      class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;"], "readability/braces"]
["src/nvim/regexp.c", ["      class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;", "    else if (i >= 'A' && i <= 'F')", "      class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;"], "readability/braces"]
["src/nvim/regexp.c", ["      class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;", "    else if (i >= 'G' && i <= 'Z')", "      class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;"], "readability/braces"]
["src/nvim/regexp.c", ["      class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;", "    else if (i == '_')", "      class_tab[i] = RI_WORD + RI_HEAD;"], "readability/braces"]
["src/nvim/regexp.c", ["      class_tab[i] = RI_WORD + RI_HEAD;", "    else", "      class_tab[i] = 0;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/* flags for regflags */", "#define RF_ICASE    1   /* ignore case */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["/* flags for regflags */", "#define RF_ICASE    1   /* ignore case */", "#define RF_NOICASE  2   /* don't ignore case */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define RF_ICASE    1   /* ignore case */", "#define RF_NOICASE  2   /* don't ignore case */", "#define RF_HASNL    4   /* can match a NL */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define RF_NOICASE  2   /* don't ignore case */", "#define RF_HASNL    4   /* can match a NL */", "#define RF_ICOMBINE 8   /* ignore combining characters */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define RF_HASNL    4   /* can match a NL */", "#define RF_ICOMBINE 8   /* ignore combining characters */", "#define RF_LOOKBH   16  /* uses \"\\@<=\" or \"\\@<!\" */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define RF_ICOMBINE 8   /* ignore combining characters */", "#define RF_LOOKBH   16  /* uses \"\\@<=\" or \"\\@<!\" */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "static int reg_magic;           /* magicness of the pattern: */", "#define MAGIC_NONE      1       /* \"\\V\" very unmagic */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["static int reg_magic;           /* magicness of the pattern: */", "#define MAGIC_NONE      1       /* \"\\V\" very unmagic */", "#define MAGIC_OFF       2       /* \"\\M\" or 'magic' off */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define MAGIC_NONE      1       /* \"\\V\" very unmagic */", "#define MAGIC_OFF       2       /* \"\\M\" or 'magic' off */", "#define MAGIC_ON        3       /* \"\\m\" or 'magic' */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define MAGIC_OFF       2       /* \"\\M\" or 'magic' off */", "#define MAGIC_ON        3       /* \"\\m\" or 'magic' */", "#define MAGIC_ALL       4       /* \"\\v\" very magic */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define MAGIC_ON        3       /* \"\\m\" or 'magic' */", "#define MAGIC_ALL       4       /* \"\\v\" very magic */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "static int reg_string;          /* matching with a string instead of a buffer", "                                   line */"], "readability/multiline_comment"]
["src/nvim/regexp.c", ["", "static int reg_string;          /* matching with a string instead of a buffer", "                                   line */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["                                   line */", "static int reg_strict;          /* \"[abc\" is illegal */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * META contains all characters that may be magic, except '^' and '$'."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/* META[] is used often enough to justify turning it into a table. */", "static char_u META_flags[] = {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,", "  /*\t\t   %  &     (  )  *  +\t      .    */", "  0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0,"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,", "  /*\t\t   %  &     (  )  *  +\t      .    */", "  0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0,"], "whitespace/tab"]
["src/nvim/regexp.c", ["  0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0,", "  /*     1  2  3\t4  5  6  7  8  9\t<  =  >  ? */", "  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0,", "  /*     1  2  3\t4  5  6  7  8  9\t<  =  >  ? */", "  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,"], "whitespace/tab"]
["src/nvim/regexp.c", ["  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,", "  /*  @  A     C\tD     F     H  I     K\tL  M\t O */", "  1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1,"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,", "  /*  @  A     C\tD     F     H  I     K\tL  M\t O */", "  1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1,"], "whitespace/tab"]
["src/nvim/regexp.c", ["  1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1,", "  /*  P\t     S\t   U  V  W  X\t  Z  [\t\t _ */", "  1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1,"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1,", "  /*  P\t     S\t   U  V  W  X\t  Z  [\t\t _ */", "  1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1,"], "whitespace/tab"]
["src/nvim/regexp.c", ["  1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1,", "  /*     a     c\td     f     h  i     k\tl  m  n  o */", "  0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1,"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1,", "  /*     a     c\td     f     h  i     k\tl  m  n  o */", "  0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1,"], "whitespace/tab"]
["src/nvim/regexp.c", ["  0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1,", "  /*  p\t     s\t   u  v  w  x\t  z  {\t|     ~    */", "  1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1,", "  /*  p\t     s\t   u  v  w  x\t  z  {\t|     ~    */", "  1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1"], "whitespace/tab"]
["src/nvim/regexp.c", ["", "static int curchr;              /* currently parsed character */", "/* Previous character.  Note: prevchr is sometimes -1 when we are not at the"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["static int curchr;              /* currently parsed character */", "/* Previous character.  Note: prevchr is sometimes -1 when we are not at the", " * start, eg in /[ ^I]^ the pattern was never found even if it existed,"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["static int prevchr;", "static int prevprevchr;         /* previous-previous character */", "static int nextchr;             /* used for ungetchr() */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["static int prevprevchr;         /* previous-previous character */", "static int nextchr;             /* used for ungetchr() */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/* arguments for reg() */", "#define REG_NOPAREN     0       /* toplevel reg() */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["/* arguments for reg() */", "#define REG_NOPAREN     0       /* toplevel reg() */", "#define REG_PAREN       1       /* \\(\\) */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define REG_NOPAREN     0       /* toplevel reg() */", "#define REG_PAREN       1       /* \\(\\) */", "#define REG_ZPAREN      2       /* \\z(\\) */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define REG_PAREN       1       /* \\(\\) */", "#define REG_ZPAREN      2       /* \\z(\\) */", "#define REG_NPAREN      3       /* \\%(\\) */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define REG_ZPAREN      2       /* \\z(\\) */", "#define REG_NPAREN      3       /* \\%(\\) */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Forward declarations for vim_regcomp()'s friends."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Check for an equivalence class name \"[=a=]\".  \"pp\" points to the '['."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Produce the bytes for equivalence class \"c\"."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      CASEMBC(0x1de) CASEMBC(0x1e0) CASEMBC(0x1ea2)", "      regmbc('A'); regmbc(0xc0); regmbc(0xc1);", "      regmbc(0xc2); regmbc(0xc3); regmbc(0xc4);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('A'); regmbc(0xc0); regmbc(0xc1);", "      regmbc(0xc2); regmbc(0xc3); regmbc(0xc4);", "      regmbc(0xc5);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x106) CASEMBC(0x108) CASEMBC(0x10a) CASEMBC(0x10c)", "      regmbc('C'); regmbc(0xc7);", "      REGMBC(0x106) REGMBC(0x108) REGMBC(0x10a)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x11a) CASEMBC(0x1eba) CASEMBC(0x1ebc)", "      regmbc('E'); regmbc(0xc8); regmbc(0xc9);", "      regmbc(0xca); regmbc(0xcb);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('E'); regmbc(0xc8); regmbc(0xc9);", "      regmbc(0xca); regmbc(0xcb);", "      REGMBC(0x112) REGMBC(0x114) REGMBC(0x116)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x130) CASEMBC(0x1cf) CASEMBC(0x1ec8)", "      regmbc('I'); regmbc(0xcc); regmbc(0xcd);", "      regmbc(0xce); regmbc(0xcf);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('I'); regmbc(0xcc); regmbc(0xcd);", "      regmbc(0xce); regmbc(0xcf);", "      REGMBC(0x128) REGMBC(0x12a) REGMBC(0x12c)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1e48)", "      regmbc('N'); regmbc(0xd1);", "      REGMBC(0x143) REGMBC(0x145) REGMBC(0x147)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1d1) CASEMBC(0x1ea) CASEMBC(0x1ec) CASEMBC(0x1ece)", "      regmbc('O'); regmbc(0xd2); regmbc(0xd3);", "      regmbc(0xd4); regmbc(0xd5); regmbc(0xd6);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('O'); regmbc(0xd2); regmbc(0xd3);", "      regmbc(0xd4); regmbc(0xd5); regmbc(0xd6);", "      regmbc(0xd8);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1ee6)", "      regmbc('U'); regmbc(0xd9); regmbc(0xda);", "      regmbc(0xdb); regmbc(0xdc);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('U'); regmbc(0xd9); regmbc(0xda);", "      regmbc(0xdb); regmbc(0xdc);", "      REGMBC(0x168) REGMBC(0x16a) REGMBC(0x16c)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1ef6) CASEMBC(0x1ef8)", "      regmbc('Y'); regmbc(0xdd);", "      REGMBC(0x176) REGMBC(0x178) REGMBC(0x1e8e)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1df) CASEMBC(0x1e1) CASEMBC(0x1ea3)", "      regmbc('a'); regmbc(0xe0); regmbc(0xe1);", "      regmbc(0xe2); regmbc(0xe3); regmbc(0xe4);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('a'); regmbc(0xe0); regmbc(0xe1);", "      regmbc(0xe2); regmbc(0xe3); regmbc(0xe4);", "      regmbc(0xe5);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x107) CASEMBC(0x109) CASEMBC(0x10b) CASEMBC(0x10d)", "      regmbc('c'); regmbc(0xe7);", "      REGMBC(0x107) REGMBC(0x109) REGMBC(0x10b)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x11b) CASEMBC(0x1ebb) CASEMBC(0x1ebd)", "      regmbc('e'); regmbc(0xe8); regmbc(0xe9);", "      regmbc(0xea); regmbc(0xeb);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('e'); regmbc(0xe8); regmbc(0xe9);", "      regmbc(0xea); regmbc(0xeb);", "      REGMBC(0x113) REGMBC(0x115) REGMBC(0x117)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1d0) CASEMBC(0x1ec9)", "      regmbc('i'); regmbc(0xec); regmbc(0xed);", "      regmbc(0xee); regmbc(0xef);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('i'); regmbc(0xec); regmbc(0xed);", "      regmbc(0xee); regmbc(0xef);", "      REGMBC(0x129) REGMBC(0x12b) REGMBC(0x12d)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1e45) CASEMBC(0x1e49)", "      regmbc('n'); regmbc(0xf1);", "      REGMBC(0x144) REGMBC(0x146) REGMBC(0x148)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1d2) CASEMBC(0x1eb) CASEMBC(0x1ed) CASEMBC(0x1ecf)", "      regmbc('o'); regmbc(0xf2); regmbc(0xf3);", "      regmbc(0xf4); regmbc(0xf5); regmbc(0xf6);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('o'); regmbc(0xf2); regmbc(0xf3);", "      regmbc(0xf4); regmbc(0xf5); regmbc(0xf6);", "      regmbc(0xf8);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1ee7)", "      regmbc('u'); regmbc(0xf9); regmbc(0xfa);", "      regmbc(0xfb); regmbc(0xfc);"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('u'); regmbc(0xf9); regmbc(0xfa);", "      regmbc(0xfb); regmbc(0xfc);", "      REGMBC(0x169) REGMBC(0x16b) REGMBC(0x16d)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1ef3) CASEMBC(0x1ef7) CASEMBC(0x1ef9)", "      regmbc('y'); regmbc(0xfd); regmbc(0xff);", "      REGMBC(0x177) REGMBC(0x1e8f) REGMBC(0x1e99)"], "whitespace/newline"]
["src/nvim/regexp.c", ["", "/*", " * Check for a collating element \"[.a.]\".  \"pp\" points to the '['."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "static int reg_cpo_lit; /* 'cpoptions' contains 'l' flag */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Skip over a \"[]\" range."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  if (*p == '^')        /* Complement of range. */", "    ++p;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  if (*p == '^')        /* Complement of range. */", "    ++p;"], "readability/braces"]
["src/nvim/regexp.c", ["  if (*p == '^')        /* Complement of range. */", "    ++p;", "  if (*p == ']' || *p == '-')"], "readability/increment"]
["src/nvim/regexp.c", ["    ++p;", "  if (*p == ']' || *p == '-')", "    ++p;"], "readability/braces"]
["src/nvim/regexp.c", ["  if (*p == ']' || *p == '-')", "    ++p;", "  while (*p != NUL && *p != ']') {"], "readability/increment"]
["src/nvim/regexp.c", ["", "/*", " * Skip past regular expression."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  if (magic)", "    mymagic = MAGIC_ON;"], "readability/braces"]
["src/nvim/regexp.c", ["    mymagic = MAGIC_ON;", "  else", "    mymagic = MAGIC_OFF;"], "readability/braces"]
["src/nvim/regexp.c", ["      p = skip_anyof(p + 1);", "      if (p[0] == NUL)", "        break;"], "readability/braces"]
["src/nvim/regexp.c", ["      if (dirc == '?' && newp != NULL && p[1] == '?') {", "        /* change \"\\?\" to \"?\", make a copy first. */", "        if (*newp == NULL) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        STRMOVE(p, p + 1);", "      } else", "        ++p;            /* skip next character */"], "readability/braces"]
["src/nvim/regexp.c", ["      } else", "        ++p;            /* skip next character */", "      if (*p == 'v')"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      } else", "        ++p;            /* skip next character */", "      if (*p == 'v')"], "readability/increment"]
["src/nvim/regexp.c", ["        ++p;            /* skip next character */", "      if (*p == 'v')", "        mymagic = MAGIC_ALL;"], "readability/braces"]
["src/nvim/regexp.c", ["        mymagic = MAGIC_ALL;", "      else if (*p == 'V')", "        mymagic = MAGIC_NONE;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * bt_regcomp() - compile a regular expression into internal code for the"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  /*", "   * First pass: determine size, legality."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  regc(REGMAGIC);", "  if (reg(REG_NOPAREN, &flags) == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["", "  /* Allocate space. */", "  bt_regprog_T *r = xmalloc(sizeof(bt_regprog_T) + regsize);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  /*", "   * Second pass: emit code."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    xfree(r);", "    if (reg_toolong)", "      EMSG_RET_NULL(_(\"E339: Pattern too long\"));"], "readability/braces"]
["src/nvim/regexp.c", ["", "  /* Dig out information for optimizations. */", "  r->regstart = NUL;            /* Worst-case defaults. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  /* Dig out information for optimizations. */", "  r->regstart = NUL;            /* Worst-case defaults. */", "  r->reganch = 0;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  r->regflags = regflags;", "  if (flags & HASNL)", "    r->regflags |= RF_HASNL;"], "readability/braces"]
["src/nvim/regexp.c", ["    r->regflags |= RF_HASNL;", "  if (flags & HASLOOKBH)", "    r->regflags |= RF_LOOKBH;"], "readability/braces"]
["src/nvim/regexp.c", ["    r->regflags |= RF_LOOKBH;", "  /* Remember whether this pattern has any \\z specials in it. */", "  r->reghasz = re_has_z;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  r->reghasz = re_has_z;", "  scan = r->program + 1;        /* First BRANCH. */", "  if (OP(regnext(scan)) == END) {   /* Only one top-level choice. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  scan = r->program + 1;        /* First BRANCH. */", "  if (OP(regnext(scan)) == END) {   /* Only one top-level choice. */", "    scan = OPERAND(scan);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "    /* Starting-point info. */", "    if (OP(scan) == BOL || OP(scan) == RE_BOF) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "    /*", "     * If there's something expensive in the r.e., find the longest"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["     */", "    /*", "     * When the r.e. starts with BOW, it is faster to look for a regmust"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      len = 0;", "      for (; scan != NULL; scan = regnext(scan))", "        if (OP(scan) == EXACTLY && STRLEN(OPERAND(scan)) >= (size_t)len) {"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Free a compiled regexp program, returned by bt_regcomp()."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Setup to parse the regexp.  Used once to get the length and once to do it."], "readability/old_style_comment"]
["src/nvim/regexp.c", [" */", "static void ", "regcomp_start ("], "whitespace/end_of_line"]
["src/nvim/regexp.c", ["static void ", "regcomp_start (", "    char_u *expr,"], "whitespace/parens"]
["src/nvim/regexp.c", ["    char_u *expr,", "    int re_flags                       /* see vim_regcomp() */", ")"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  initchr(expr);", "  if (re_flags & RE_MAGIC)", "    reg_magic = MAGIC_ON;"], "readability/braces"]
["src/nvim/regexp.c", ["    reg_magic = MAGIC_ON;", "  else", "    reg_magic = MAGIC_OFF;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Check if during the previous call to vim_regcomp the EOL item \"$\" has been"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Parse regular expression, i.e. main body or parenthesized thing."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["static char_u *", "reg (", "    int paren,              /* REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN */"], "whitespace/parens"]
["src/nvim/regexp.c", ["reg (", "    int paren,              /* REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN */", "    int *flagp"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["reg (", "    int paren,              /* REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN */", "    int *flagp"], "whitespace/line_length"]
["src/nvim/regexp.c", ["", "  *flagp = HASWIDTH;            /* Tentatively. */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  if (paren == REG_ZPAREN) {", "    /* Make a ZOPEN node. */", "    if (regnzpar >= NSUBEXP)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    /* Make a ZOPEN node. */", "    if (regnzpar >= NSUBEXP)", "      EMSG_RET_NULL(_(\"E50: Too many \\\\z(\"));"], "readability/braces"]
["src/nvim/regexp.c", ["  } else if (paren == REG_PAREN)    {", "    /* Make a MOPEN node. */", "    if (regnpar >= NSUBEXP)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    /* Make a MOPEN node. */", "    if (regnpar >= NSUBEXP)", "      EMSG2_RET_NULL(_(\"E51: Too many %s(\"), reg_magic == MAGIC_ALL);"], "readability/braces"]
["src/nvim/regexp.c", ["    parno = regnpar;", "    ++regnpar;", "    ret = regnode(MOPEN + parno);"], "readability/increment"]
["src/nvim/regexp.c", ["  } else if (paren == REG_NPAREN)   {", "    /* Make a NOPEN node. */", "    ret = regnode(NOPEN);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    ret = regnode(NOPEN);", "  } else", "    ret = NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["", "  /* Pick up the branches, linking them together. */", "  br = regbranch(&flags);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  br = regbranch(&flags);", "  if (br == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["    return NULL;", "  if (ret != NULL)", "    regtail(ret, br);           /* [MZ]OPEN -> first. */"], "readability/braces"]
["src/nvim/regexp.c", ["  if (ret != NULL)", "    regtail(ret, br);           /* [MZ]OPEN -> first. */", "  else"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    regtail(ret, br);           /* [MZ]OPEN -> first. */", "  else", "    ret = br;"], "readability/braces"]
["src/nvim/regexp.c", ["    ret = br;", "  /* If one of the branches can be zero-width, the whole thing can.", "   * If one of the branches has * at start or matches a line-break, the"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["   * whole thing can. */", "  if (!(flags & HASWIDTH))", "    *flagp &= ~HASWIDTH;"], "readability/braces"]
["src/nvim/regexp.c", ["    br = regbranch(&flags);", "    if (br == NULL || reg_toolong)", "      return NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["      return NULL;", "    regtail(ret, br);           /* BRANCH -> BRANCH. */", "    if (!(flags & HASWIDTH))"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    regtail(ret, br);           /* BRANCH -> BRANCH. */", "    if (!(flags & HASWIDTH))", "      *flagp &= ~HASWIDTH;"], "readability/braces"]
["src/nvim/regexp.c", ["", "  /* Make a closing node, and hook it on the end. */", "  ender = regnode("], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  /* Hook the tails of the branches to the closing node. */", "  for (br = ret; br != NULL; br = regnext(br))"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  /* Hook the tails of the branches to the closing node. */", "  for (br = ret; br != NULL; br = regnext(br))", "    regoptail(br, ender);"], "readability/braces"]
["src/nvim/regexp.c", ["", "  /* Check for proper termination. */", "  if (paren != REG_NOPAREN && getchr() != Magic(')')) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  if (paren != REG_NOPAREN && getchr() != Magic(')')) {", "    if (paren == REG_ZPAREN)", "      EMSG_RET_NULL(_(\"E52: Unmatched \\\\z(\"));"], "readability/braces"]
["src/nvim/regexp.c", ["      EMSG_RET_NULL(_(\"E52: Unmatched \\\\z(\"));", "    else if (paren == REG_NPAREN)", "      EMSG2_RET_NULL(_(e_unmatchedpp), reg_magic == MAGIC_ALL);"], "readability/braces"]
["src/nvim/regexp.c", ["      EMSG2_RET_NULL(_(e_unmatchedpp), reg_magic == MAGIC_ALL);", "    else", "      EMSG2_RET_NULL(_(e_unmatchedp), reg_magic == MAGIC_ALL);"], "readability/braces"]
["src/nvim/regexp.c", ["  } else if (paren == REG_NOPAREN && peekchr() != NUL) {", "    if (curchr == Magic(')'))", "      EMSG2_RET_NULL(_(e_unmatchedpar), reg_magic == MAGIC_ALL);"], "readability/braces"]
["src/nvim/regexp.c", ["      EMSG2_RET_NULL(_(e_unmatchedpar), reg_magic == MAGIC_ALL);", "    else", "      EMSG_RET_NULL(_(e_trailing));             /* \"Can't happen\". */"], "readability/braces"]
["src/nvim/regexp.c", ["    else", "      EMSG_RET_NULL(_(e_trailing));             /* \"Can't happen\". */", "    /* NOTREACHED */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      EMSG_RET_NULL(_(e_trailing));             /* \"Can't happen\". */", "    /* NOTREACHED */", "  }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Parse one alternative of an | operator."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  *flagp = WORST | HASNL;               /* Tentatively. */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    latest = regconcat(&flags);", "    if (latest == NULL)", "      return NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["      return NULL;", "    /* If one of the branches has width, the whole thing has.  If one of", "     * the branches anchors at start-of-line, the whole thing does."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    *flagp |= flags & (HASWIDTH | SPSTART | HASLOOKBH);", "    /* If one of the branches doesn't match a line-break, the whole thing", "     * doesn't. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    *flagp &= ~HASNL | (flags & HASNL);", "    if (chain != NULL)", "      regtail(chain, latest);"], "readability/braces"]
["src/nvim/regexp.c", ["      regtail(chain, latest);", "    if (peekchr() != Magic('&'))", "      break;"], "readability/braces"]
["src/nvim/regexp.c", ["    skipchr();", "    regtail(latest, regnode(END));     /* operand ends */", "    if (reg_toolong)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    regtail(latest, regnode(END));     /* operand ends */", "    if (reg_toolong)", "      break;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Parse one alternative of an | or & operator."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  *flagp = WORST;               /* Tentatively. */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      latest = regpiece(&flags);", "      if (latest == NULL || reg_toolong)", "        return NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["      *flagp |= flags & (HASWIDTH | HASNL | HASLOOKBH);", "      if (chain == NULL)                        /* First piece. */", "        *flagp |= flags & SPSTART;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      *flagp |= flags & (HASWIDTH | HASNL | HASLOOKBH);", "      if (chain == NULL)                        /* First piece. */", "        *flagp |= flags & SPSTART;"], "readability/braces"]
["src/nvim/regexp.c", ["        *flagp |= flags & SPSTART;", "      else", "        regtail(chain, latest);"], "readability/braces"]
["src/nvim/regexp.c", ["      chain = latest;", "      if (first == NULL)", "        first = latest;"], "readability/braces"]
["src/nvim/regexp.c", ["  }", "  if (first == NULL)            /* Loop ran zero times. */", "    first = regnode(NOTHING);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  }", "  if (first == NULL)            /* Loop ran zero times. */", "    first = regnode(NOTHING);"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Parse something followed by possible [*+=]."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  ret = regatom(&flags);", "  if (ret == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["  }", "  /* default flags */", "  *flagp = (WORST | SPSTART | (flags & (HASNL | HASLOOKBH)));"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case Magic('*'):", "    if (flags & SIMPLE)", "      reginsert(STAR, ret);"], "readability/braces"]
["src/nvim/regexp.c", ["      reginsert(STAR, ret);", "    else {", "      /* Emit x* as (x&|), where & means \"self\". */"], "readability/braces"]
["src/nvim/regexp.c", ["      reginsert(STAR, ret);", "    else {", "      /* Emit x* as (x&|), where & means \"self\". */"], "readability/braces"]
["src/nvim/regexp.c", ["    else {", "      /* Emit x* as (x&|), where & means \"self\". */", "      reginsert(BRANCH, ret);           /* Either x */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      /* Emit x* as (x&|), where & means \"self\". */", "      reginsert(BRANCH, ret);           /* Either x */", "      regoptail(ret, regnode(BACK));            /* and loop */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      reginsert(BRANCH, ret);           /* Either x */", "      regoptail(ret, regnode(BACK));            /* and loop */", "      regoptail(ret, ret);              /* back */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      regoptail(ret, regnode(BACK));            /* and loop */", "      regoptail(ret, ret);              /* back */", "      regtail(ret, regnode(BRANCH));            /* or */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      regoptail(ret, ret);              /* back */", "      regtail(ret, regnode(BRANCH));            /* or */", "      regtail(ret, regnode(NOTHING));           /* null. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      regtail(ret, regnode(BRANCH));            /* or */", "      regtail(ret, regnode(NOTHING));           /* null. */", "    }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case Magic('+'):", "    if (flags & SIMPLE)", "      reginsert(PLUS, ret);"], "readability/braces"]
["src/nvim/regexp.c", ["      reginsert(PLUS, ret);", "    else {", "      /* Emit x+ as x(&|), where & means \"self\". */"], "readability/braces"]
["src/nvim/regexp.c", ["      reginsert(PLUS, ret);", "    else {", "      /* Emit x+ as x(&|), where & means \"self\". */"], "readability/braces"]
["src/nvim/regexp.c", ["    else {", "      /* Emit x+ as x(&|), where & means \"self\". */", "      next = regnode(BRANCH);           /* Either */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      /* Emit x+ as x(&|), where & means \"self\". */", "      next = regnode(BRANCH);           /* Either */", "      regtail(ret, next);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      regtail(ret, next);", "      regtail(regnode(BACK), ret);              /* loop back */", "      regtail(next, regnode(BRANCH));           /* or */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      regtail(regnode(BACK), ret);              /* loop back */", "      regtail(next, regnode(BRANCH));           /* or */", "      regtail(ret, regnode(NOTHING));           /* null. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      regtail(next, regnode(BRANCH));           /* or */", "      regtail(ret, regnode(NOTHING));           /* null. */", "    }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    switch (no_Magic(getchr())) {", "    case '=': lop = MATCH; break;                                 /* \\@= */", "    case '!': lop = NOMATCH; break;                               /* \\@! */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    case '=': lop = MATCH; break;                                 /* \\@= */", "    case '!': lop = NOMATCH; break;                               /* \\@! */", "    case '>': lop = SUBPAT; break;                                /* \\@> */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    case '!': lop = NOMATCH; break;                               /* \\@! */", "    case '>': lop = SUBPAT; break;                                /* \\@> */", "    case '<': switch (no_Magic(getchr())) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    case '<': switch (no_Magic(getchr())) {", "      case '=': lop = BEHIND; break;                               /* \\@<= */", "      case '!': lop = NOBEHIND; break;                             /* \\@<! */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      case '=': lop = BEHIND; break;                               /* \\@<= */", "      case '!': lop = NOBEHIND; break;                             /* \\@<! */", "    }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    }", "    if (lop == END)", "      EMSG2_RET_NULL(_(\"E59: invalid character after %s@\"),"], "readability/braces"]
["src/nvim/regexp.c", ["      EMSG2_RET_NULL(_(\"E59: invalid character after %s@\"),", "          reg_magic == MAGIC_ALL);", "    /* Look behind must match with behind_pos. */"], "whitespace/alignment"]
["src/nvim/regexp.c", ["          reg_magic == MAGIC_ALL);", "    /* Look behind must match with behind_pos. */", "    if (lop == BEHIND || lop == NOBEHIND) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    }", "    regtail(ret, regnode(END));             /* operand ends */", "    if (lop == BEHIND || lop == NOBEHIND) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    if (lop == BEHIND || lop == NOBEHIND) {", "      if (nr < 0)", "        nr = 0;                 /* no limit is same as zero limit */"], "readability/braces"]
["src/nvim/regexp.c", ["      if (nr < 0)", "        nr = 0;                 /* no limit is same as zero limit */", "      reginsert_nr(lop, (uint32_t)nr, ret);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      reginsert_nr(lop, (uint32_t)nr, ret);", "    } else", "      reginsert(lop, ret);"], "readability/braces"]
["src/nvim/regexp.c", ["  case Magic('='):", "    /* Emit x= as (x|) */", "    reginsert(BRANCH, ret);                     /* Either x */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    /* Emit x= as (x|) */", "    reginsert(BRANCH, ret);                     /* Either x */", "    regtail(ret, regnode(BRANCH));              /* or */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    reginsert(BRANCH, ret);                     /* Either x */", "    regtail(ret, regnode(BRANCH));              /* or */", "    next = regnode(NOTHING);                    /* null. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    regtail(ret, regnode(BRANCH));              /* or */", "    next = regnode(NOTHING);                    /* null. */", "    regtail(ret, next);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case Magic('{'):", "    if (!read_limits(&minval, &maxval))", "      return NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["    } else {", "      if (num_complex_braces >= 10)", "        EMSG2_RET_NULL(_(\"E60: Too many complex %s{...}s\"),"], "readability/braces"]
["src/nvim/regexp.c", ["        EMSG2_RET_NULL(_(\"E60: Too many complex %s{...}s\"),", "            reg_magic == MAGIC_ALL);", "      reginsert(BRACE_COMPLEX + num_complex_braces, ret);"], "whitespace/alignment"]
["src/nvim/regexp.c", ["      reginsert_limits(BRACE_LIMITS, minval, maxval, ret);", "      ++num_complex_braces;", "    }"], "readability/increment"]
["src/nvim/regexp.c", ["    }", "    if (minval > 0 && maxval > 0)", "      *flagp = (HASWIDTH | (flags & (HASNL | HASLOOKBH)));"], "readability/braces"]
["src/nvim/regexp.c", ["  if (re_multi_type(peekchr()) != NOT_MULTI) {", "    /* Can't have a multi follow a multi. */", "    if (peekchr() == Magic('*'))"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    /* Can't have a multi follow a multi. */", "    if (peekchr() == Magic('*'))", "      sprintf((char *)IObuff, _(\"E61: Nested %s*\"),"], "readability/braces"]
["src/nvim/regexp.c", ["      sprintf((char *)IObuff, _(\"E61: Nested %s*\"),", "          reg_magic >= MAGIC_ON ? \"\" : \"\\\\\");", "    else"], "whitespace/alignment"]
["src/nvim/regexp.c", ["    if (peekchr() == Magic('*'))", "      sprintf((char *)IObuff, _(\"E61: Nested %s*\"),", "          reg_magic >= MAGIC_ON ? \"\" : \"\\\\\");"], "runtime/printf"]
["src/nvim/regexp.c", ["          reg_magic >= MAGIC_ON ? \"\" : \"\\\\\");", "    else", "      sprintf((char *)IObuff, _(\"E62: Nested %s%c\"),"], "readability/braces"]
["src/nvim/regexp.c", ["      sprintf((char *)IObuff, _(\"E62: Nested %s%c\"),", "          reg_magic == MAGIC_ALL ? \"\" : \"\\\\\", no_Magic(peekchr()));", "    EMSG_RET_NULL(IObuff);"], "whitespace/alignment"]
["src/nvim/regexp.c", ["    else", "      sprintf((char *)IObuff, _(\"E62: Nested %s%c\"),", "          reg_magic == MAGIC_ALL ? \"\" : \"\\\\\", no_Magic(peekchr()));"], "runtime/printf"]
["src/nvim/regexp.c", ["", "/* When making changes to classchars also change nfa_classcodes. */", "static char_u   *classchars = (char_u *)\".iIkKfFpPsSdDxXoOwWhHaAlLuU\";"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Parse the lowest level."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  *flagp = WORST;               /* Tentatively. */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    c = no_Magic(getchr());", "    if (c == '^') {             /* \"\\_^\" is start-of-line */", "      ret = regnode(BOL);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    }", "    if (c == '$') {             /* \"\\_$\" is end-of-line */", "      ret = regnode(EOL);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "    /* \"\\_[\" is character range plus newline */", "    if (c == '[')"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    /* \"\\_[\" is character range plus newline */", "    if (c == '[')", "      goto collection;"], "readability/braces"]
["src/nvim/regexp.c", ["", "  /*", "   * Character classes."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    p = vim_strchr(classchars, no_Magic(c));", "    if (p == NULL)", "      EMSG_RET_NULL(_(\"E63: invalid use of \\\\_\"));"], "readability/braces"]
["src/nvim/regexp.c", ["      EMSG_RET_NULL(_(\"E63: invalid use of \\\\_\"));", "    /* When '.' is followed by a composing char ignore the dot, so that", "     * the composing char is matched here. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    if (reg_string) {", "      /* In a string \"\\n\" matches a newline character. */", "      ret = regnode(EXACTLY);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    } else {", "      /* In buffer text \"\\n\" matches the end of a line. */", "      ret = regnode(NEWL);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case Magic('('):", "    if (one_exactly)", "      EMSG_ONE_RET_NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["    ret = reg(REG_PAREN, &flags);", "    if (ret == NULL)", "      return NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["  case Magic(')'):", "    if (one_exactly)", "      EMSG_ONE_RET_NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["    sprintf((char *)IObuff, _(\"E64: %s%c follows nothing\"),", "        (c == '*' ? reg_magic >= MAGIC_ON : reg_magic == MAGIC_ALL)", "        ? \"\" : \"\\\\\", c);"], "whitespace/alignment"]
["src/nvim/regexp.c", ["        (c == '*' ? reg_magic >= MAGIC_ON : reg_magic == MAGIC_ALL)", "        ? \"\" : \"\\\\\", c);", "    EMSG_RET_NULL(IObuff);"], "whitespace/alignment"]
["src/nvim/regexp.c", ["    c = no_Magic(c);", "    sprintf((char *)IObuff, _(\"E64: %s%c follows nothing\"),", "        (c == '*' ? reg_magic >= MAGIC_ON : reg_magic == MAGIC_ALL)"], "runtime/printf"]
["src/nvim/regexp.c", ["    EMSG_RET_NULL(IObuff);", "  /* NOTREACHED */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  case Magic('~'):              /* previous substitute pattern */", "    if (reg_prev_sub != NULL) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      lp = reg_prev_sub;", "      while (*lp != NUL)", "        regc(*lp++);"], "readability/braces"]
["src/nvim/regexp.c", ["        *flagp |= HASWIDTH;", "        if ((lp - reg_prev_sub) == 1)", "          *flagp |= SIMPLE;"], "readability/braces"]
["src/nvim/regexp.c", ["      }", "    } else", "      EMSG_RET_NULL(_(e_nopresub));"], "readability/braces"]
["src/nvim/regexp.c", ["        EMSG_RET_NULL(_(e_z_not_allowed));", "      if (one_exactly)", "        EMSG_ONE_RET_NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["      ret = reg(REG_ZPAREN, &flags);", "      if (ret == NULL)", "        return NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["    switch (c) {", "    /* () without a back reference */", "    case '(':"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    case '(':", "      if (one_exactly)", "        EMSG_ONE_RET_NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["      ret = reg(REG_NPAREN, &flags);", "      if (ret == NULL)", "        return NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["", "    /* Catch \\%^ and \\%$ regardless of where they appear in the", "     * pattern -- regardless of whether or not it makes sense. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "    /* \\%[abc]: Emit as a list of branches, all ending at the last", "     * branch which matches nothing. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    case '[':", "      if (one_exactly)                          /* doesn't nest */", "        EMSG_ONE_RET_NULL;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    case '[':", "      if (one_exactly)                          /* doesn't nest */", "        EMSG_ONE_RET_NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["        while ((c = getchr()) != ']') {", "          if (c == NUL)", "            EMSG2_RET_NULL(_(e_missing_sb),"], "readability/braces"]
["src/nvim/regexp.c", ["            EMSG2_RET_NULL(_(e_missing_sb),", "                reg_magic == MAGIC_ALL);", "          br = regnode(BRANCH);"], "whitespace/alignment"]
["src/nvim/regexp.c", ["        }", "        if (ret == NULL)", "          EMSG2_RET_NULL(_(e_empty_sb),"], "readability/braces"]
["src/nvim/regexp.c", ["          EMSG2_RET_NULL(_(e_empty_sb),", "              reg_magic == MAGIC_ALL);", "        lastbranch = regnode(BRANCH);"], "whitespace/alignment"]
["src/nvim/regexp.c", ["          regtail(lastbranch, br);", "          /* connect all branches to the NOTHING", "           * branch at the end */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              br = OPERAND(br);", "            } else", "              br = regnext(br);"], "readability/braces"]
["src/nvim/regexp.c", ["", "    case 'd':               /* %d123 decimal */", "    case 'o':               /* %o123 octal */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    case 'd':               /* %d123 decimal */", "    case 'o':               /* %o123 octal */", "    case 'x':               /* %xab hex 2 */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    case 'o':               /* %o123 octal */", "    case 'x':               /* %xab hex 2 */", "    case 'u':               /* %uabcd hex 4 */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    case 'x':               /* %xab hex 2 */", "    case 'u':               /* %uabcd hex 4 */", "    case 'U':               /* %U1234abcd hex 8 */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    case 'u':               /* %uabcd hex 4 */", "    case 'U':               /* %U1234abcd hex 8 */", "    {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        cmp = c;", "        if (cmp == '<' || cmp == '>')", "          c = getchr();"], "readability/braces"]
["src/nvim/regexp.c", ["        if (c == '\\'' && n == 0) {", "          /* \"\\%'m\", \"\\%<'m\" and \"\\%>'m\": Mark */", "          c = getchr();"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          ret = regnode(RE_MARK);", "          if (ret == JUST_CALC_SIZE)", "            regsize += 2;"], "readability/braces"]
["src/nvim/regexp.c", ["            regsize += 2;", "          else {", "            *regcode++ = c;"], "readability/braces"]
["src/nvim/regexp.c", ["            regsize += 2;", "          else {", "            *regcode++ = c;"], "readability/braces"]
["src/nvim/regexp.c", ["      EMSG2_RET_NULL(_(\"E71: Invalid character after %s%%\"),", "          reg_magic == MAGIC_ALL);", "    }"], "whitespace/alignment"]
["src/nvim/regexp.c", ["", "      /*", "       * If there is no matching ']', we assume the '[' is a normal"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      lp = skip_anyof(regparse);", "      if (*lp == ']') {         /* there is a matching ']' */", "        int startc = -1;                /* > 0 when next '-' is a range */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      if (*lp == ']') {         /* there is a matching ']' */", "        int startc = -1;                /* > 0 when next '-' is a range */", "        int endc;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "        /*", "         * In a character class, different parsing rules apply."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["         */", "        if (*regparse == '^') {             /* Complement of range. */", "          ret = regnode(ANYBUT + extra);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          regparse++;", "        } else", "          ret = regnode(ANYOF + extra);"], "readability/braces"]
["src/nvim/regexp.c", ["", "        /* At the start ']' and '-' mean the literal character. */", "        if (*regparse == ']' || *regparse == '-') {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          if (*regparse == '-') {", "            ++regparse;", "            /* The '-' is not used for a range at the end and"], "readability/increment"]
["src/nvim/regexp.c", ["            ++regparse;", "            /* The '-' is not used for a range at the end and", "             * after or before a '\\n'. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              regc('-');", "              startc = '-';                     /* [--x] is a range */", "            } else {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["            } else {", "              /* Also accept \"a-[.z.]\" */", "              endc = 0;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              endc = 0;", "              if (*regparse == '[')", "                endc = get_coll_element(&regparse);"], "readability/braces"]
["src/nvim/regexp.c", ["", "              /* Handle \\o40, \\x20 and \\u20AC style sequences */", "              if (endc == '\\\\' && !reg_cpo_lit)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              /* Handle \\o40, \\x20 and \\u20AC style sequences */", "              if (endc == '\\\\' && !reg_cpo_lit)", "                endc = coll_get_char();"], "readability/braces"]
["src/nvim/regexp.c", ["              } else {", "                while (++startc <= endc)", "                  regc(startc);"], "readability/braces"]
["src/nvim/regexp.c", ["          }", "          /*", "           * Only \"\\]\", \"\\^\", \"\\]\" and \"\\\\\" are special in Vi.  Vim"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["           */", "          else if (*regparse == '\\\\'", "                   && (vim_strchr(REGEXP_INRANGE, regparse[1]) != NULL"], "whitespace/newline"]
["src/nvim/regexp.c", ["                           && vim_strchr(REGEXP_ABBR,", "                               regparse[1]) != NULL))) {", "            regparse++;"], "whitespace/alignment"]
["src/nvim/regexp.c", ["                           && vim_strchr(REGEXP_ABBR,", "                               regparse[1]) != NULL))) {", "            regparse++;"], "whitespace/alignment"]
["src/nvim/regexp.c", ["                           && vim_strchr(REGEXP_ABBR,", "                               regparse[1]) != NULL))) {", "            regparse++;"], "whitespace/alignment"]
["src/nvim/regexp.c", ["                           && vim_strchr(REGEXP_ABBR,", "                               regparse[1]) != NULL))) {", "            regparse++;"], "whitespace/alignment"]
["src/nvim/regexp.c", ["            if (*regparse == 'n') {", "              /* '\\n' in range: also match NL */", "              if (ret != JUST_CALC_SIZE) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              if (ret != JUST_CALC_SIZE) {", "                /* Using \\n inside [^] does not change what", "                 * matches. \"[^\\n]\" is the same as \".\". */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["                }", "                /* else: must have had a \\n already */", "              }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              startc = coll_get_char();", "              if (startc == 0)", "                regc(0x0a);"], "readability/braces"]
["src/nvim/regexp.c", ["                regc(0x0a);", "              else", "                regmbc(startc);"], "readability/braces"]
["src/nvim/regexp.c", ["            startc = -1;", "            /* Characters assumed to be 8 bits! */", "            switch (c_class) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              if (c_class != 0) {", "                /* produce equivalence class */", "                reg_equi_class(c_class);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              } else if ((c_class =", "                            get_coll_element(&regparse)) != 0) {", "                /* produce a collating element */"], "whitespace/alignment"]
["src/nvim/regexp.c", ["                            get_coll_element(&regparse)) != 0) {", "                /* produce a collating element */", "                regmbc(c_class);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              } else {", "                /* literal '[', allow [[-x] as a range */", "                startc = *regparse++;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["            case CLASS_SPACE:", "              for (cu = 9; cu <= 13; cu++)", "                regc(cu);"], "readability/braces"]
["src/nvim/regexp.c", ["        regc(NUL);", "        prevchr_len = 1;                /* last char was the ']' */", "        if (*regparse != ']')"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        prevchr_len = 1;                /* last char was the ']' */", "        if (*regparse != ']')", "          EMSG_RET_NULL(_(e_toomsbra));                 /* Cannot happen? */"], "readability/braces"]
["src/nvim/regexp.c", ["        if (*regparse != ']')", "          EMSG_RET_NULL(_(e_toomsbra));                 /* Cannot happen? */", "        skipchr();                  /* let's be friends with the lexer again */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          EMSG_RET_NULL(_(e_toomsbra));                 /* Cannot happen? */", "        skipchr();                  /* let's be friends with the lexer again */", "        *flagp |= HASWIDTH | SIMPLE;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        break;", "      } else if (reg_strict)", "        EMSG2_RET_NULL(_(e_missingbracket), reg_magic > MAGIC_OFF);"], "readability/braces"]
["src/nvim/regexp.c", ["", "    /* A multi-byte character is handled as a separate atom if it's", "     * before a multi and when it's a composing char. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "    /*", "     * Append characters as long as:"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["                                   && !one_exactly", "                                   && !is_Magic(c))); ++len) {", "      c = no_Magic(c);"], "readability/increment"]
["src/nvim/regexp.c", ["", "          /* Need to get composing character too. */", "          for (;; ) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["            l = utf_ptr2len(regparse);", "            if (!UTF_COMPOSINGLIKE(regparse, regparse + l))", "              break;"], "readability/braces"]
["src/nvim/regexp.c", ["    *flagp |= HASWIDTH;", "    if (len == 1)", "      *flagp |= SIMPLE;"], "readability/braces"]
["src/nvim/regexp.c", ["  return ret;", "}", ""], "readability/fn_size"]
["src/nvim/regexp.c", ["", "/*", " * Emit a node."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  ret = regcode;", "  if (ret == JUST_CALC_SIZE)", "    regsize += 3;"], "readability/braces"]
["src/nvim/regexp.c", ["    regsize += 3;", "  else {", "    *regcode++ = op;"], "readability/braces"]
["src/nvim/regexp.c", ["    regsize += 3;", "  else {", "    *regcode++ = op;"], "readability/braces"]
["src/nvim/regexp.c", ["    *regcode++ = op;", "    *regcode++ = NUL;                   /* Null \"next\" pointer. */", "    *regcode++ = NUL;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Emit (if appropriate) a byte of code"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["{", "  if (regcode == JUST_CALC_SIZE)", "    regsize++;"], "readability/braces"]
["src/nvim/regexp.c", ["    regsize++;", "  else", "    *regcode++ = b;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Emit (if appropriate) a multi-byte character of code"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Insert an operator in front of already-emitted operand"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  dst = regcode;", "  while (src > opnd)", "    *--dst = *--src;"], "readability/braces"]
["src/nvim/regexp.c", ["", "  place = opnd;                 /* Op node, where operand used to be. */", "  *place++ = op;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Insert an operator in front of already-emitted operand."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  dst = regcode;", "  while (src > opnd)", "    *--dst = *--src;"], "readability/braces"]
["src/nvim/regexp.c", ["", "  place = opnd;                 /* Op node, where operand used to be. */", "  *place++ = op;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Insert an operator in front of already-emitted operand."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  dst = regcode;", "  while (src > opnd)", "    *--dst = *--src;"], "readability/braces"]
["src/nvim/regexp.c", ["", "  place = opnd;                 /* Op node, where operand used to be. */", "  *place++ = op;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Write a four bytes number at \"p\" and return pointer to the next char."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["{", "  *p++ = (char_u) ((val >> 24) & 0377);", "  *p++ = (char_u) ((val >> 16) & 0377);"], "whitespace/cast"]
["src/nvim/regexp.c", ["  *p++ = (char_u) ((val >> 24) & 0377);", "  *p++ = (char_u) ((val >> 16) & 0377);", "  *p++ = (char_u) ((val >> 8) & 0377);"], "whitespace/cast"]
["src/nvim/regexp.c", ["  *p++ = (char_u) ((val >> 16) & 0377);", "  *p++ = (char_u) ((val >> 8) & 0377);", "  *p++ = (char_u) (val & 0377);"], "whitespace/cast"]
["src/nvim/regexp.c", ["  *p++ = (char_u) ((val >> 8) & 0377);", "  *p++ = (char_u) (val & 0377);", "  return p;"], "whitespace/cast"]
["src/nvim/regexp.c", ["", "/*", " * Like regtail, on item after a BRANCH; nop if none."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["{", "  /* When op is neither BRANCH nor BRACE_COMPLEX0-9, it is \"operandless\" */", "  if (p == NULL || p == JUST_CALC_SIZE"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  /* When op is neither BRANCH nor BRACE_COMPLEX0-9, it is \"operandless\" */", "  if (p == NULL || p == JUST_CALC_SIZE", "      || (OP(p) != BRANCH"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Functions for getting characters from the regexp input."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Start parsing at \"str\"."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Save the current parse state, so that it can be restored and parsing"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Restore a previously saved parse state."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Get the next character without advancing."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case '~':", "    /* magic when 'magic' is on */", "    if (reg_magic >= MAGIC_ON)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    /* magic when 'magic' is on */", "    if (reg_magic >= MAGIC_ON)", "      curchr = Magic(curchr);"], "readability/braces"]
["src/nvim/regexp.c", ["  case '>':", "  case '#':           /* future ext. */", "  case '\"':           /* future ext. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case '#':           /* future ext. */", "  case '\"':           /* future ext. */", "  case '\\'':          /* future ext. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case '\"':           /* future ext. */", "  case '\\'':          /* future ext. */", "  case ',':           /* future ext. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case '\\'':          /* future ext. */", "  case ',':           /* future ext. */", "  case '-':           /* future ext. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case ',':           /* future ext. */", "  case '-':           /* future ext. */", "  case ':':           /* future ext. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case '-':           /* future ext. */", "  case ':':           /* future ext. */", "  case ';':           /* future ext. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case ':':           /* future ext. */", "  case ';':           /* future ext. */", "  case '`':           /* future ext. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case ';':           /* future ext. */", "  case '`':           /* future ext. */", "  case '/':           /* Can't be used in / command */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case '`':           /* future ext. */", "  case '/':           /* Can't be used in / command */", "    /* magic only after \"\\v\" */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case '/':           /* Can't be used in / command */", "    /* magic only after \"\\v\" */", "    if (reg_magic == MAGIC_ALL)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    /* magic only after \"\\v\" */", "    if (reg_magic == MAGIC_ALL)", "      curchr = Magic(curchr);"], "readability/braces"]
["src/nvim/regexp.c", ["  case '*':", "    /* * is not magic as the very first character, eg \"?*ptr\", when", "     * after '^', eg \"/^*ptr\" and when after \"\\(\", \"\\|\", \"\\&\".  But"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["     * \"\\(\\*\" is not magic, thus must be magic if \"after_slash\" */", "    if (reg_magic >= MAGIC_ON", "        && !at_start"], "readability/braces"]
["src/nvim/regexp.c", ["  case '^':", "    /* '^' is only magic as the very first character and if it's after", "     * \"\\(\", \"\\|\", \"\\&' or \"\\n\" */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  case '$':", "    /* '$' is only magic as the very last char and if it's in front of", "     * either \"\\|\", \"\\)\", \"\\&\", or \"\\n\" */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "    if (c == NUL)", "      curchr = '\\\\';                  /* trailing '\\' */"], "readability/braces"]
["src/nvim/regexp.c", ["    if (c == NUL)", "      curchr = '\\\\';                  /* trailing '\\' */", "    else if ("], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      curchr = '\\\\';                  /* trailing '\\' */", "    else if (", "      c <= '~' && META_flags[c]"], "readability/braces"]
["src/nvim/regexp.c", ["    else if (", "      c <= '~' && META_flags[c]", "      ) {"], "whitespace/indent"]
["src/nvim/regexp.c", ["      c <= '~' && META_flags[c]", "      ) {", "      /*"], "whitespace/indent"]
["src/nvim/regexp.c", ["      ) {", "      /*", "       * META contains everything that may be magic sometimes,"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    } else if (vim_strchr(REGEXP_ABBR, c)) {", "      /*", "       * Handle abbreviations, like \"\\t\" for TAB -- webb"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      curchr = backslash_trans(c);", "    } else if (reg_magic == MAGIC_NONE && (c == '$' || c == '^'))", "      curchr = toggle_Magic(c);"], "readability/braces"]
["src/nvim/regexp.c", ["      curchr = toggle_Magic(c);", "    else {", "      /*"], "readability/braces"]
["src/nvim/regexp.c", ["      curchr = toggle_Magic(c);", "    else {", "      /*"], "readability/braces"]
["src/nvim/regexp.c", ["    else {", "      /*", "       * Next character can never be (made) magic?"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Eat one lexed character.  Do this in a way that we can undo it."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["{", "  /* peekchr() eats a backslash, do the same here */", "  if (*regparse == '\\\\')"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  /* peekchr() eats a backslash, do the same here */", "  if (*regparse == '\\\\')", "    prevchr_len = 1;"], "readability/braces"]
["src/nvim/regexp.c", ["    prevchr_len = 1;", "  else", "    prevchr_len = 0;"], "readability/braces"]
["src/nvim/regexp.c", ["  prevchr = curchr;", "  curchr = nextchr;         /* use previously unget char, or -1 */", "  nextchr = -1;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Skip a character while keeping the value of prev_at_start for at_start."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Get the next character from the pattern. We know about magic and such, so"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * put character back.  Works only once!"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  /* Backup regparse, so that it's at the same position as before the", "   * getchr(). */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Get and return the value of the hex string at the current position."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  for (i = 0; i < maxinputlen; ++i) {", "    c = regparse[0];"], "readability/increment"]
["src/nvim/regexp.c", ["    c = regparse[0];", "    if (!ascii_isxdigit(c))", "      break;"], "readability/braces"]
["src/nvim/regexp.c", ["    nr |= hex2nr(c);", "    ++regparse;", "  }"], "readability/increment"]
["src/nvim/regexp.c", ["", "  if (i == 0)", "    return -1;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Get and return the value of the decimal string immediately after the"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  for (i = 0;; ++i) {", "    c = regparse[0];"], "readability/increment"]
["src/nvim/regexp.c", ["    c = regparse[0];", "    if (c < '0' || c > '9')", "      break;"], "readability/braces"]
["src/nvim/regexp.c", ["    nr += c - '0';", "    ++regparse;", "    curchr = -1;     /* no longer valid */"], "readability/increment"]
["src/nvim/regexp.c", ["    ++regparse;", "    curchr = -1;     /* no longer valid */", "  }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  if (i == 0)", "    return -1;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * get and return the value of the octal string immediately after the current"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    c = regparse[0];", "    if (c < '0' || c > '7')", "      break;"], "readability/braces"]
["src/nvim/regexp.c", ["    nr |= hex2nr(c);", "    ++regparse;", "  }"], "readability/increment"]
["src/nvim/regexp.c", ["", "  if (i == 0)", "    return -1;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Get a number after a backslash that is inside []."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * read_limits - Read two integers to be taken as a minimum and maximum."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    sprintf((char *)IObuff, _(\"E554: Syntax error in %s{...}\"),", "        reg_magic == MAGIC_ALL ? \"\" : \"\\\\\");", "    EMSG_RET_FAIL(IObuff);"], "whitespace/alignment"]
["src/nvim/regexp.c", ["  if (*regparse != '}') {", "    sprintf((char *)IObuff, _(\"E554: Syntax error in %s{...}\"),", "        reg_magic == MAGIC_ALL ? \"\" : \"\\\\\");"], "runtime/printf"]
["src/nvim/regexp.c", ["", "  /*", "   * Reverse the range if there was a '-', or make sure it is in the right"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  }", "  skipchr();            /* let's be friends with the lexer again */", "  return OK;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * vim_regexec and friends"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Global work variables for vim_regexec()."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/* Save the sub-expressions before attempting a match. */", "#define save_se(savep, posp, pp) \\"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/* After a failed match restore the sub-expressions. */", "#define restore_se(savep, posp, pp) { \\"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#define restore_se(savep, posp, pp) { \\", "    if (REG_MULTI) \\", "      *(posp) = (savep)->se_u.pos; \\"], "readability/braces"]
["src/nvim/regexp.c", ["      *(posp) = (savep)->se_u.pos; \\", "    else \\", "      *(pp) = (savep)->se_u.ptr; }"], "readability/braces"]
["src/nvim/regexp.c", ["      *(posp) = (savep)->se_u.pos; \\", "    else \\", "      *(pp) = (savep)->se_u.ptr; }"], "whitespace/newline"]
["src/nvim/regexp.c", ["", "/*", " * \"regstack\" and \"backpos\" are used by regmatch().  They are kept over calls"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Both for regstack and backpos tables we use the following strategy of"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Get pointer to the line \"lnum\", which is relative to \"reg_firstlnum\"."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "static char_u   *reg_startzp[NSUBEXP];  /* Workspace to mark beginning */", "static char_u   *reg_endzp[NSUBEXP];    /*   and end of \\z(...\\) matches */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["static char_u   *reg_startzp[NSUBEXP];  /* Workspace to mark beginning */", "static char_u   *reg_endzp[NSUBEXP];    /*   and end of \\z(...\\) matches */", "static lpos_T reg_startzpos[NSUBEXP];   /* idem, beginning pos */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["static char_u   *reg_endzp[NSUBEXP];    /*   and end of \\z(...\\) matches */", "static lpos_T reg_startzpos[NSUBEXP];   /* idem, beginning pos */", "static lpos_T reg_endzpos[NSUBEXP];     /* idem, end pos */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["static lpos_T reg_startzpos[NSUBEXP];   /* idem, beginning pos */", "static lpos_T reg_endzpos[NSUBEXP];     /* idem, end pos */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Match a regexp against a string."], "readability/old_style_comment"]
["src/nvim/regexp.c", [" */", "static int ", "bt_regexec_nl ("], "whitespace/end_of_line"]
["src/nvim/regexp.c", ["static int ", "bt_regexec_nl (", "    regmatch_T *rmp,"], "whitespace/parens"]
["src/nvim/regexp.c", ["    regmatch_T *rmp,", "    char_u *line,      /* string to match against */", "    colnr_T col,       /* column to start looking for match */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    char_u *line,      /* string to match against */", "    colnr_T col,       /* column to start looking for match */", "    bool line_lbr"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["/// Uses curbuf for line count and 'iskeyword'.", "/// ", "/// @param win Window in which to search or NULL"], "whitespace/end_of_line"]
["src/nvim/regexp.c", ["/// @param buf Buffer in which to search", "/// @param lnum Number of line to start looking for match ", "/// @param col Column to start looking for match"], "whitespace/end_of_line"]
["src/nvim/regexp.c", ["", "  /* Create \"regstack\" and \"backpos\" if they are not allocated yet.", "   * We allocate *_INITIAL amount of bytes first and then set the grow size"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  if (regstack.ga_data == NULL) {", "    /* Use an item size of 1 byte, since we push different things", "     * onto the regstack. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  /* Be paranoid... */", "  if (prog == NULL || line == NULL) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  /* Check validity of program. */", "  if (prog_magic_wrong())"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  /* Check validity of program. */", "  if (prog_magic_wrong())", "    goto theend;"], "readability/braces"]
["src/nvim/regexp.c", ["", "  /* If there is a \"must appear\" string, look for it. */", "  if (prog->regmust != NULL) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  /* Simplest case: Anchored match need be tried only once. */", "  if (prog->reganch) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    int tm_count = 0;", "    /* Messy cases:  unanchored match. */", "    while (!got_int) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["theend:", "  /* Free \"reg_tofree\" when it's a bit big.", "   * Free regstack and backpos if they are bigger than their initial size. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  }", "  if (regstack.ga_maxlen > REGSTACK_INITIAL)", "    ga_clear(&regstack);"], "readability/braces"]
["src/nvim/regexp.c", ["    ga_clear(&regstack);", "  if (backpos.ga_maxlen > BACKPOS_INITIAL)", "    ga_clear(&backpos);"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Create a new extmatch and mark it as referenced once."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Add a reference to an extmatch."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["{", "  if (em != NULL)", "    em->refcnt++;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Remove a reference to an extmatch.  If there are no references left, free"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  if (em != NULL && --em->refcnt <= 0) {", "    for (i = 0; i < NSUBEXP; ++i)", "      xfree(em->matches[i]);"], "readability/braces"]
["src/nvim/regexp.c", ["  if (em != NULL && --em->refcnt <= 0) {", "    for (i = 0; i < NSUBEXP; ++i)", "      xfree(em->matches[i]);"], "readability/increment"]
["src/nvim/regexp.c", ["  }", "  /* Package any found \\z(...\\) matches for export. Default is none. */", "  unref_extmatch(re_extmatch_out);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      if (REG_MULTI) {", "        /* Only accept single line matches. */", "        if (reg_startzpos[i].lnum >= 0"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      } else {", "        if (reg_startzp[i] != NULL && reg_endzp[i] != NULL)", "          re_extmatch_out->matches[i] ="], "readability/braces"]
["src/nvim/regexp.c", ["    getvvcol(wp, &bot, &start2, NULL, &end2);", "    if (start2 < start)", "      start = start2;"], "readability/braces"]
["src/nvim/regexp.c", ["      start = start2;", "    if (end2 > end)", "      end = end2;"], "readability/braces"]
["src/nvim/regexp.c", ["      end = end2;", "    if (top.col == MAXCOL || bot.col == MAXCOL)", "      end = MAXCOL;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * The arguments from BRACE_LIMITS are stored here.  They are actually local"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["{", "  char_u        *next;          /* Next node. */", "  int op;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  /*", "   * Repeat until \"regstack\" is empty."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  for (;; ) {", "    /* Some patterns may take a long time to match, e.g., \"\\([a-z]\\+\\)\\+Q\".", "     * Allow interrupting them with CTRL-C. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "    /*", "     * Repeat for items that can be matched sequentially, without using the"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["            mch_errmsg(\"    \\\"\");", "            if (re_extmatch_in->matches[i] != NULL)", "              mch_errmsg((char *)re_extmatch_in->matches[i]);"], "readability/braces"]
["src/nvim/regexp.c", ["        case RE_MARK:", "          /* Compare the mark position to the match position. */", "        {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        case RE_VISUAL:", "          if (!reg_match_visual())", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["        case IDENT:", "          if (!vim_isIDc(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case WHITE:", "          if (!ascii_iswhite(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case NWHITE:", "          if (c == NUL || ascii_iswhite(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case DIGIT:", "          if (!ri_digit(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case NDIGIT:", "          if (c == NUL || ri_digit(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case HEX:", "          if (!ri_hex(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case NHEX:", "          if (c == NUL || ri_hex(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case OCTAL:", "          if (!ri_octal(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case NOCTAL:", "          if (c == NUL || ri_octal(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case WORD:", "          if (!ri_word(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case NWORD:", "          if (c == NUL || ri_word(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case HEAD:", "          if (!ri_head(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case NHEAD:", "          if (c == NUL || ri_head(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case ALPHA:", "          if (!ri_alpha(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case NALPHA:", "          if (c == NUL || ri_alpha(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case LOWER:", "          if (!ri_lower(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case NLOWER:", "          if (c == NUL || ri_lower(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case UPPER:", "          if (!ri_upper(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case NUPPER:", "          if (c == NUL || ri_upper(c))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["        case ANYBUT:", "          if (c == NUL)", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else if ((cstrchr(OPERAND(scan), c) == NULL) == (op == ANYOF))", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "          else", "            ADVANCE_REGINPUT();"], "readability/braces"]
["src/nvim/regexp.c", ["", "          /*", "           * When we run into BACK we need to check if we don't keep"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          backpos_T *bp = (backpos_T *)backpos.ga_data;", "          for (i = 0; i < backpos.ga_len; ++i)", "            if (bp[i].bp_scan == scan)"], "readability/braces"]
["src/nvim/regexp.c", ["          backpos_T *bp = (backpos_T *)backpos.ga_data;", "          for (i = 0; i < backpos.ga_len; ++i)", "            if (bp[i].bp_scan == scan)"], "readability/increment"]
["src/nvim/regexp.c", ["          for (i = 0; i < backpos.ga_len; ++i)", "            if (bp[i].bp_scan == scan)", "              break;"], "readability/braces"]
["src/nvim/regexp.c", ["            p->bp_scan = scan;", "          } else if (reg_save_equal(&bp[i].bp_pos))", "            /* Still at same position as last time, fail. */"], "readability/braces"]
["src/nvim/regexp.c", ["          } else if (reg_save_equal(&bp[i].bp_pos))", "            /* Still at same position as last time, fail. */", "            status = RA_NOMATCH;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "        case MOPEN + 0:     /* Match start: \\zs */", "        case MOPEN + 1:     /* \\( */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        case MOPEN + 0:     /* Match start: \\zs */", "        case MOPEN + 1:     /* \\( */", "        case MOPEN + 2:"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          rp = regstack_push(RS_MOPEN, scan);", "          if (rp == NULL)", "            status = RA_FAIL;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_FAIL;", "          else {", "            rp->rs_no = no;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_FAIL;", "          else {", "            rp->rs_no = no;"], "readability/braces"]
["src/nvim/regexp.c", ["", "        case NOPEN:         /* \\%( */", "        case NCLOSE:        /* \\) after \\%( */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        case NOPEN:         /* \\%( */", "        case NCLOSE:        /* \\) after \\%( */", "          if (regstack_push(RS_NOPEN, scan) == NULL)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        case NCLOSE:        /* \\) after \\%( */", "          if (regstack_push(RS_NOPEN, scan) == NULL)", "            status = RA_FAIL;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_FAIL;", "          /* We simply continue and handle the result when done. */", "          break;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          rp = regstack_push(RS_ZOPEN, scan);", "          if (rp == NULL)", "            status = RA_FAIL;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_FAIL;", "          else {", "            rp->rs_no = no;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_FAIL;", "          else {", "            rp->rs_no = no;"], "readability/braces"]
["src/nvim/regexp.c", ["            save_se(&rp->rs_un.sesave, &reg_startzpos[no],", "                &reg_startzp[no]);", "            /* We simply continue and handle the result when done. */"], "whitespace/alignment"]
["src/nvim/regexp.c", ["                &reg_startzp[no]);", "            /* We simply continue and handle the result when done. */", "          }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "        case MCLOSE + 0:    /* Match end: \\ze */", "        case MCLOSE + 1:    /* \\) */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        case MCLOSE + 0:    /* Match end: \\ze */", "        case MCLOSE + 1:    /* \\) */", "        case MCLOSE + 2:"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "        case ZCLOSE + 1:    /* \\) after \\z( */", "        case ZCLOSE + 2:"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          rp = regstack_push(RS_ZCLOSE, scan);", "          if (rp == NULL)", "            status = RA_FAIL;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_FAIL;", "          else {", "            rp->rs_no = no;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_FAIL;", "          else {", "            rp->rs_no = no;"], "readability/braces"]
["src/nvim/regexp.c", ["            save_se(&rp->rs_un.sesave, &reg_endzpos[no],", "                &reg_endzp[no]);", "            /* We simply continue and handle the result when done. */"], "whitespace/alignment"]
["src/nvim/regexp.c", ["                &reg_endzp[no]);", "            /* We simply continue and handle the result when done. */", "          }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        {", "          if (OP(next) != BRANCH)       /* No choice. */", "            next = OPERAND(scan);               /* Avoid recursion. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        {", "          if (OP(next) != BRANCH)       /* No choice. */", "            next = OPERAND(scan);               /* Avoid recursion. */"], "readability/braces"]
["src/nvim/regexp.c", ["          if (OP(next) != BRANCH)       /* No choice. */", "            next = OPERAND(scan);               /* Avoid recursion. */", "          else {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["            next = OPERAND(scan);               /* Avoid recursion. */", "          else {", "            rp = regstack_push(RS_BRANCH, scan);"], "readability/braces"]
["src/nvim/regexp.c", ["            next = OPERAND(scan);               /* Avoid recursion. */", "          else {", "            rp = regstack_push(RS_BRANCH, scan);"], "readability/braces"]
["src/nvim/regexp.c", ["            rp = regstack_push(RS_BRANCH, scan);", "            if (rp == NULL)", "              status = RA_FAIL;"], "readability/braces"]
["src/nvim/regexp.c", ["              status = RA_FAIL;", "            else", "              status = RA_BREAK;                /* rest is below */"], "readability/braces"]
["src/nvim/regexp.c", ["            else", "              status = RA_BREAK;                /* rest is below */", "          }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          no = op - BRACE_COMPLEX;", "          ++brace_count[no];", ""], "readability/increment"]
["src/nvim/regexp.c", ["", "          /* If not matched enough times yet, try one more */", "          if (brace_count[no] <= (brace_min[no] <= brace_max[no]"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["            rp = regstack_push(RS_BRCPLX_MORE, scan);", "            if (rp == NULL)", "              status = RA_FAIL;"], "readability/braces"]
["src/nvim/regexp.c", ["              status = RA_FAIL;", "            else {", "              rp->rs_no = no;"], "readability/braces"]
["src/nvim/regexp.c", ["              status = RA_FAIL;", "            else {", "              rp->rs_no = no;"], "readability/braces"]
["src/nvim/regexp.c", ["              next = OPERAND(scan);", "              /* We continue and handle the result when done. */", "            }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "          /* If matched enough times, may try matching some more */", "          if (brace_min[no] <= brace_max[no]) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          if (brace_min[no] <= brace_max[no]) {", "            /* Range is the normal way around, use longest match */", "            if (brace_count[no] <= brace_max[no]) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              rp = regstack_push(RS_BRCPLX_LONG, scan);", "              if (rp == NULL)", "                status = RA_FAIL;"], "readability/braces"]
["src/nvim/regexp.c", ["                status = RA_FAIL;", "              else {", "                rp->rs_no = no;"], "readability/braces"]
["src/nvim/regexp.c", ["                status = RA_FAIL;", "              else {", "                rp->rs_no = no;"], "readability/braces"]
["src/nvim/regexp.c", ["                next = OPERAND(scan);", "                /* We continue and handle the result when done. */", "              }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          } else {", "            /* Range is backwards, use shortest match first */", "            if (brace_count[no] <= brace_min[no]) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              rp = regstack_push(RS_BRCPLX_SHORT, scan);", "              if (rp == NULL)", "                status = RA_FAIL;"], "readability/braces"]
["src/nvim/regexp.c", ["                status = RA_FAIL;", "              else {", "                reg_save(&rp->rs_un.regsave, &backpos);"], "readability/braces"]
["src/nvim/regexp.c", ["                status = RA_FAIL;", "              else {", "                reg_save(&rp->rs_un.regsave, &backpos);"], "readability/braces"]
["src/nvim/regexp.c", ["                reg_save(&rp->rs_un.regsave, &backpos);", "                /* We continue and handle the result when done. */", "              }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "          /*", "           * Lookahead to avoid useless match attempts when we know"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "          /*", "           * When maxval > minval, try matching as much as possible, up"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              ? rst.count >= rst.minval : rst.count >= rst.maxval) {", "            /* It could match.  Prepare for trying to match what", "             * follows.  The code is below.  Parameters are stored in"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              rp = regstack_push(rst.minval <= rst.maxval", "                  ? RS_STAR_LONG : RS_STAR_SHORT, scan);", "              if (rp == NULL)"], "whitespace/alignment"]
["src/nvim/regexp.c", ["                  ? RS_STAR_LONG : RS_STAR_SHORT, scan);", "              if (rp == NULL)", "                status = RA_FAIL;"], "readability/braces"]
["src/nvim/regexp.c", ["                status = RA_FAIL;", "              else {", "                *(((regstar_T *)rp) - 1) = rst;"], "readability/braces"]
["src/nvim/regexp.c", ["                status = RA_FAIL;", "              else {", "                *(((regstar_T *)rp) - 1) = rst;"], "readability/braces"]
["src/nvim/regexp.c", ["                *(((regstar_T *)rp) - 1) = rst;", "                status = RA_BREAK;                  /* skip the restore bits */", "              }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["            }", "          } else", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "", "        }"], "whitespace/blank_line"]
["src/nvim/regexp.c", ["          rp = regstack_push(RS_NOMATCH, scan);", "          if (rp == NULL)", "            status = RA_FAIL;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_FAIL;", "          else {", "            rp->rs_no = op;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_FAIL;", "          else {", "            rp->rs_no = op;"], "readability/braces"]
["src/nvim/regexp.c", ["            next = OPERAND(scan);", "            /* We continue and handle the result when done. */", "          }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        case NOBEHIND:", "          /* Need a bit of room to store extra positions. */", "          if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["            rp = regstack_push(RS_BEHIND1, scan);", "            if (rp == NULL)", "              status = RA_FAIL;"], "readability/braces"]
["src/nvim/regexp.c", ["              status = RA_FAIL;", "            else {", "              /* Need to save the subexpr to be able to restore them"], "readability/braces"]
["src/nvim/regexp.c", ["              status = RA_FAIL;", "            else {", "              /* Need to save the subexpr to be able to restore them"], "readability/braces"]
["src/nvim/regexp.c", ["            else {", "              /* Need to save the subexpr to be able to restore them", "               * when there is a match but we don't use it. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              reg_save(&rp->rs_un.regsave, &backpos);", "              /* First try if what follows matches.  If it does then we", "               * check the behind match by looping. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        case END:", "          status = RA_MATCH;    /* Success! */", "          break;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "      /* If we can't continue sequentially, break the inner loop. */", "      if (status != RA_CONT)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      /* If we can't continue sequentially, break the inner loop. */", "      if (status != RA_CONT)", "        break;"], "readability/braces"]
["src/nvim/regexp.c", ["", "      /* Continue in inner loop, advance to next item. */", "      scan = next;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      scan = next;", "", "    } /* end of inner loop */"], "whitespace/blank_line"]
["src/nvim/regexp.c", ["", "    } /* end of inner loop */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "    /*", "     * If there is something on the regstack execute the code for the state."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      case RS_NOPEN:", "        /* Result is passed on as-is, simply pop the state. */", "        regstack_pop(&scan);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      case RS_ZOPEN:", "        /* Pop the state.  Restore pointers when there is no match. */", "        if (status == RA_NOMATCH)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        /* Pop the state.  Restore pointers when there is no match. */", "        if (status == RA_NOMATCH)", "          restore_se(&rp->rs_un.sesave, &reg_startzpos[rp->rs_no],"], "readability/braces"]
["src/nvim/regexp.c", ["          restore_se(&rp->rs_un.sesave, &reg_startzpos[rp->rs_no],", "              &reg_startzp[rp->rs_no]);", "        regstack_pop(&scan);"], "whitespace/alignment"]
["src/nvim/regexp.c", ["      case RS_ZCLOSE:", "        /* Pop the state.  Restore pointers when there is no match. */", "        if (status == RA_NOMATCH)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        /* Pop the state.  Restore pointers when there is no match. */", "        if (status == RA_NOMATCH)", "          restore_se(&rp->rs_un.sesave, &reg_endzpos[rp->rs_no],"], "readability/braces"]
["src/nvim/regexp.c", ["          restore_se(&rp->rs_un.sesave, &reg_endzpos[rp->rs_no],", "              &reg_endzp[rp->rs_no]);", "        regstack_pop(&scan);"], "whitespace/alignment"]
["src/nvim/regexp.c", ["      case RS_BRANCH:", "        if (status == RA_MATCH)", "          /* this branch matched, use it */"], "readability/braces"]
["src/nvim/regexp.c", ["        if (status == RA_MATCH)", "          /* this branch matched, use it */", "          regstack_pop(&scan);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          regstack_pop(&scan);", "        else {", "          if (status != RA_BREAK) {"], "readability/braces"]
["src/nvim/regexp.c", ["          regstack_pop(&scan);", "        else {", "          if (status != RA_BREAK) {"], "readability/braces"]
["src/nvim/regexp.c", ["          if (status != RA_BREAK) {", "            /* After a non-matching branch: try next one. */", "            reg_restore(&rp->rs_un.regsave, &backpos);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          if (scan == NULL || OP(scan) != BRANCH) {", "            /* no more branches, didn't find a match */", "            status = RA_NOMATCH;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          } else {", "            /* Prepare to try a branch. */", "            rp->rs_scan = regnext(scan);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      case RS_BRCPLX_MORE:", "        /* Pop the state.  Restore pointers when there is no match. */", "        if (status == RA_NOMATCH) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          reg_restore(&rp->rs_un.regsave, &backpos);", "          --brace_count[rp->rs_no];             /* decrement match count */", "        }"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          reg_restore(&rp->rs_un.regsave, &backpos);", "          --brace_count[rp->rs_no];             /* decrement match count */", "        }"], "readability/increment"]
["src/nvim/regexp.c", ["      case RS_BRCPLX_LONG:", "        /* Pop the state.  Restore pointers when there is no match. */", "        if (status == RA_NOMATCH) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        if (status == RA_NOMATCH) {", "          /* There was no match, but we did find enough matches. */", "          reg_restore(&rp->rs_un.regsave, &backpos);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          reg_restore(&rp->rs_un.regsave, &backpos);", "          --brace_count[rp->rs_no];", "          /* continue with the items after \"\\{}\" */"], "readability/increment"]
["src/nvim/regexp.c", ["          --brace_count[rp->rs_no];", "          /* continue with the items after \"\\{}\" */", "          status = RA_CONT;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        regstack_pop(&scan);", "        if (status == RA_CONT)", "          scan = regnext(scan);"], "readability/braces"]
["src/nvim/regexp.c", ["      case RS_BRCPLX_SHORT:", "        /* Pop the state.  Restore pointers when there is no match. */", "        if (status == RA_NOMATCH)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        /* Pop the state.  Restore pointers when there is no match. */", "        if (status == RA_NOMATCH)", "          /* There was no match, try to match one more item. */"], "readability/braces"]
["src/nvim/regexp.c", ["        if (status == RA_NOMATCH)", "          /* There was no match, try to match one more item. */", "          reg_restore(&rp->rs_un.regsave, &backpos);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      case RS_NOMATCH:", "        /* Pop the state.  If the operand matches for NOMATCH or", "        * doesn't match for MATCH/SUBPAT, we fail.  Otherwise backup,"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        * except for SUBPAT, and continue with the next item. */", "        if (status == (rp->rs_no == NOMATCH ? RA_MATCH : RA_NOMATCH))", "          status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["          status = RA_NOMATCH;", "        else {", "          status = RA_CONT;"], "readability/braces"]
["src/nvim/regexp.c", ["          status = RA_NOMATCH;", "        else {", "          status = RA_CONT;"], "readability/braces"]
["src/nvim/regexp.c", ["          status = RA_CONT;", "          if (rp->rs_no != SUBPAT)              /* zero-width */", "            reg_restore(&rp->rs_un.regsave, &backpos);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          status = RA_CONT;", "          if (rp->rs_no != SUBPAT)              /* zero-width */", "            reg_restore(&rp->rs_un.regsave, &backpos);"], "readability/braces"]
["src/nvim/regexp.c", ["        regstack_pop(&scan);", "        if (status == RA_CONT)", "          scan = regnext(scan);"], "readability/braces"]
["src/nvim/regexp.c", ["        } else {", "          /* The stuff after BEHIND/NOBEHIND matches.  Now try if", "           * the behind part does (not) match before the current"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "          /* save the position after the found match for next */", "          reg_save(&(((regbehind_T *)rp) - 1)->save_after, &backpos);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "          /* Start looking for a match with operand at the current", "           * position.  Go back one character until we find the"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      case RS_BEHIND2:", "        /*", "         * Looping for BEHIND / NOBEHIND match."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        if (status == RA_MATCH && reg_save_equal(&behind_pos)) {", "          /* found a match that ends where \"next\" started */", "          behind_pos = (((regbehind_T *)rp) - 1)->save_behind;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          behind_pos = (((regbehind_T *)rp) - 1)->save_behind;", "          if (rp->rs_no == BEHIND)", "            reg_restore(&(((regbehind_T *)rp) - 1)->save_after,"], "readability/braces"]
["src/nvim/regexp.c", ["            reg_restore(&(((regbehind_T *)rp) - 1)->save_after,", "                &backpos);", "          else {"], "whitespace/alignment"]
["src/nvim/regexp.c", ["                &backpos);", "          else {", "            /* But we didn't want a match.  Need to restore the"], "readability/braces"]
["src/nvim/regexp.c", ["                &backpos);", "          else {", "            /* But we didn't want a match.  Need to restore the"], "readability/braces"]
["src/nvim/regexp.c", ["          else {", "            /* But we didn't want a match.  Need to restore the", "             * subexpr, because what follows matched, so they have"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "          /* No match or a match that doesn't end where we want it: Go", "           * back one character.  May go to previous line once. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          if (REG_MULTI) {", "            if (limit > 0", "                && ((rp->rs_un.regsave.rs_u.pos.lnum"], "readability/braces"]
["src/nvim/regexp.c", ["              no = FAIL;", "            else if (rp->rs_un.regsave.rs_u.pos.col == 0) {", "              if (rp->rs_un.regsave.rs_u.pos.lnum"], "readability/braces"]
["src/nvim/regexp.c", ["            else if (rp->rs_un.regsave.rs_u.pos.col == 0) {", "              if (rp->rs_un.regsave.rs_u.pos.lnum", "                  < behind_pos.rs_u.pos.lnum"], "readability/braces"]
["src/nvim/regexp.c", ["                  || reg_getline(", "                      --rp->rs_un.regsave.rs_u.pos.lnum)", "                  == NULL)"], "readability/increment"]
["src/nvim/regexp.c", ["                no = FAIL;", "              else {", "                reg_restore(&rp->rs_un.regsave, &backpos);"], "readability/braces"]
["src/nvim/regexp.c", ["                no = FAIL;", "              else {", "                reg_restore(&rp->rs_un.regsave, &backpos);"], "readability/braces"]
["src/nvim/regexp.c", ["          if (no == OK) {", "            /* Advanced, prepare for finding match again. */", "            reg_restore(&rp->rs_un.regsave, &backpos);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["            if (status == RA_MATCH) {", "              /* We did match, so subexpr may have been changed,", "               * need to restore them for the next try. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          } else {", "            /* Can't advance.  For NOBEHIND that's a match. */", "            behind_pos = (((regbehind_T *)rp) - 1)->save_behind;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              reg_restore(&(((regbehind_T *)rp) - 1)->save_after,", "                  &backpos);", "              status = RA_MATCH;"], "whitespace/alignment"]
["src/nvim/regexp.c", ["            } else {", "              /* We do want a proper match.  Need to restore the", "               * subexpr if we had a match, because they may have"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "        /* Tried once already, restore input pointers. */", "        if (status != RA_BREAK)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        /* Tried once already, restore input pointers. */", "        if (status != RA_BREAK)", "          reg_restore(&rp->rs_un.regsave, &backpos);"], "readability/braces"]
["src/nvim/regexp.c", ["", "        /* Repeat until we found a position where it could match. */", "        for (;; ) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          if (status != RA_BREAK) {", "            /* Tried first position already, advance. */", "            if (rp->rs_state == RS_STAR_LONG) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["            if (rp->rs_state == RS_STAR_LONG) {", "              /* Trying for longest match, but couldn't or", "               * didn't match -- back up one char. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["               * didn't match -- back up one char. */", "              if (--rst->count < rst->minval)", "                break;"], "readability/braces"]
["src/nvim/regexp.c", ["            } else {", "              /* Range is backwards, use shortest match first.", "               * Careful: maxval and minval are exchanged!"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["               * char. */", "              if (rst->count == rst->minval", "                  || regrepeat(OPERAND(rp->rs_scan), 1L) == 0)"], "readability/braces"]
["src/nvim/regexp.c", ["                break;", "              ++rst->count;", "            }"], "readability/increment"]
["src/nvim/regexp.c", ["            }", "            if (got_int)", "              break;"], "readability/braces"]
["src/nvim/regexp.c", ["              break;", "          } else", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["        if (status != RA_CONT) {", "          /* Failed. */", "          regstack_pop(&scan);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "      /* If we want to continue the inner loop or didn't pop a state", "       * continue matching loop */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["       * continue matching loop */", "      if (status == RA_CONT || rp == (regitem_T *)", "          ((char *)regstack.ga_data + regstack.ga_len) - 1)"], "readability/braces"]
["src/nvim/regexp.c", ["", "    /* May need to continue with the inner loop, starting at \"scan\". */", "    if (status == RA_CONT)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    /* May need to continue with the inner loop, starting at \"scan\". */", "    if (status == RA_CONT)", "      continue;"], "readability/braces"]
["src/nvim/regexp.c", ["", "    /*", "     * If the regstack is empty or something failed we are done."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      if (scan == NULL) {", "        /*", "         * We get here only if there's trouble -- normally \"case END\" is"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    }", "", "  } /* End of loop until the regstack is empty. */"], "whitespace/blank_line"]
["src/nvim/regexp.c", ["", "  } /* End of loop until the regstack is empty. */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  /* NOTREACHED */", "}"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  /* NOTREACHED */", "}", ""], "readability/fn_size"]
["src/nvim/regexp.c", ["", "/*", " * Push an item onto the regstack."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Pop an item from the regstack."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * regrepeat - repeatedly match something simple, return how many."], "readability/old_style_comment"]
["src/nvim/regexp.c", [" */", "static int ", "regrepeat ("], "whitespace/end_of_line"]
["src/nvim/regexp.c", ["static int ", "regrepeat (", "    char_u *p,"], "whitespace/parens"]
["src/nvim/regexp.c", ["    char_u *p,", "    long maxcount              /* maximum number of matches allowed */", ")"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    while (count < maxcount) {", "      /* Matching anything means we continue until end-of-line (or", "       * end-of-file for ANY + ADD_NL), only limited by maxcount. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      }", "      ++count;", "    }"], "readability/increment"]
["src/nvim/regexp.c", ["      }", "      ++count;", "    }"], "readability/increment"]
["src/nvim/regexp.c", ["", "    /* Safety check (just in case 'encoding' was changed since", "     * compiling the program). */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      while (count < maxcount && (*mb_ptr2len)(scan) >= len) {", "        for (i = 0; i < len; ++i) {", "          if (opnd[i] != scan[i]) {"], "readability/increment"]
["src/nvim/regexp.c", ["        scan += len;", "        ++count;", "      }"], "readability/increment"]
["src/nvim/regexp.c", ["      } else {", "        if ((cstrchr(opnd, *scan) == NULL) == testval)", "          break;"], "readability/braces"]
["src/nvim/regexp.c", ["          break;", "        ++scan;", "      }"], "readability/increment"]
["src/nvim/regexp.c", ["      }", "      ++count;", "    }"], "readability/increment"]
["src/nvim/regexp.c", ["", "/*", " * regnext - dig the \"next\" pointer out of a node"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  if (p == JUST_CALC_SIZE || reg_toolong)", "    return NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["  offset = NEXT(p);", "  if (offset == 0)", "    return NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["", "  if (OP(p) == BACK)", "    return p - offset;"], "readability/braces"]
["src/nvim/regexp.c", ["    return p - offset;", "  else", "    return p + offset;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Check the regexp program for its magic number."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Cleanup the subexpressions, if this wasn't done yet."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    if (REG_MULTI) {", "      /* Use 0xff to set lnum to -1 */", "      memset(reg_startzpos, 0xff, sizeof(lpos_T) * NSUBEXP);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Tentatively set the sub-expression start to the current position (after"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Compare a number with the operand of RE_LNUM, RE_COL or RE_VCOL."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  if (OPERAND_CMP(scan) == '>')", "    return val > n;"], "readability/braces"]
["src/nvim/regexp.c", ["    return val > n;", "  if (OPERAND_CMP(scan) == '<')", "    return val < n;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Check whether a backreference matches."], "readability/old_style_comment"]
["src/nvim/regexp.c", [" */", "static int match_with_backref(linenr_T start_lnum, colnr_T start_col, linenr_T end_lnum, colnr_T end_col, int *bytelen)", "{"], "whitespace/line_length"]
["src/nvim/regexp.c", ["", "  if (bytelen != NULL)", "    *bytelen = 0;"], "readability/braces"]
["src/nvim/regexp.c", ["  for (;; ) {", "    /* Since getting one line may invalidate the other, need to make copy.", "     * Slow! */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      if (reg_tofree == NULL || len >= (int)reg_tofreelen) {", "        len += 50;              /* get some extra */", "        xfree(reg_tofree);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "    /* Get the line to compare with. */", "    p = reg_getline(clnum);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "    if (clnum == end_lnum)", "      len = end_col - ccol;"], "readability/braces"]
["src/nvim/regexp.c", ["      len = end_col - ccol;", "    else", "      len = (int)STRLEN(p + ccol);"], "readability/braces"]
["src/nvim/regexp.c", ["", "    /* Advance to next line. */", "    reg_nextline();"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    reg_nextline();", "    if (bytelen != NULL)", "      *bytelen = 0;"], "readability/braces"]
["src/nvim/regexp.c", ["      *bytelen = 0;", "    ++clnum;", "    ccol = 0;"], "readability/increment"]
["src/nvim/regexp.c", ["    ccol = 0;", "    if (got_int)", "      return RA_FAIL;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * regdump - dump a regexp onto stdout in vaguely comprehensible form"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  char_u  *s;", "  int op = EXACTLY;             /* Arbitrary non-END op. */", "  char_u  *next;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#endif", "  if (f == NULL)", "    return;"], "readability/braces"]
["src/nvim/regexp.c", ["  fprintf(f, \"-------------------------------------\\n\\r\\nregcomp(%s):\\r\\n\",", "      pattern);", ""], "whitespace/alignment"]
["src/nvim/regexp.c", ["  s = r->program + 1;", "  /*", "   * Loop until we find the END that isn't before a referred next (an END"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    op = OP(s);", "    fprintf(f, \"%2d%s\", (int)(s - r->program), regprop(s));     /* Where, what. */", "    next = regnext(s);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    op = OP(s);", "    fprintf(f, \"%2d%s\", (int)(s - r->program), regprop(s));     /* Where, what. */", "    next = regnext(s);"], "whitespace/line_length"]
["src/nvim/regexp.c", ["    next = regnext(s);", "    if (next == NULL)           /* Next ptr. */", "      fprintf(f, \"(0)\");"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    next = regnext(s);", "    if (next == NULL)           /* Next ptr. */", "      fprintf(f, \"(0)\");"], "readability/braces"]
["src/nvim/regexp.c", ["      fprintf(f, \"(0)\");", "    else", "      fprintf(f, \"(%d)\", (int)((s - r->program) + (next - s)));"], "readability/braces"]
["src/nvim/regexp.c", ["      fprintf(f, \"(%d)\", (int)((s - r->program) + (next - s)));", "    if (end < next)", "      end = next;"], "readability/braces"]
["src/nvim/regexp.c", ["    if (op == BRACE_LIMITS) {", "      /* Two ints */", "      fprintf(f, \" minval %\" PRId64 \", maxval %\" PRId64,"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    } else if (op == BEHIND || op == NOBEHIND) {", "      /* one int */", "      fprintf(f, \" count %\" PRId64, (int64_t)OPERAND_MIN(s));"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        || op == EXACTLY) {", "      /* Literal string, where present. */", "      fprintf(f, \"\\nxxxxxxxxx\\n\");"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      fprintf(f, \"\\nxxxxxxxxx\\n\");", "      while (*s != NUL)", "        fprintf(f, \"%c\", *s++);"], "readability/braces"]
["src/nvim/regexp.c", ["", "  /* Header fields of interest. */", "  if (r->regstart != NUL)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  /* Header fields of interest. */", "  if (r->regstart != NUL)", "    fprintf(f, \"start `%s' 0x%x; \", r->regstart < 256"], "readability/braces"]
["src/nvim/regexp.c", ["    fprintf(f, \"start `%s' 0x%x; \", r->regstart < 256", "        ? (char *)transchar(r->regstart)", "        : \"multibyte\", r->regstart);"], "whitespace/alignment"]
["src/nvim/regexp.c", ["        ? (char *)transchar(r->regstart)", "        : \"multibyte\", r->regstart);", "  if (r->reganch)"], "whitespace/alignment"]
["src/nvim/regexp.c", ["        : \"multibyte\", r->regstart);", "  if (r->reganch)", "    fprintf(f, \"anchored; \");"], "readability/braces"]
["src/nvim/regexp.c", ["    fprintf(f, \"anchored; \");", "  if (r->regmust != NULL)", "    fprintf(f, \"must have \\\"%s\\\"\", r->regmust);"], "readability/braces"]
["src/nvim/regexp.c", ["}", "#endif      /* BT_REGEXP_DUMP */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["#ifdef REGEXP_DEBUG", "/*", " * regprop - printable representation of opcode"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  switch ((int) OP(op)) {", "  case BOL:"], "whitespace/cast"]
["src/nvim/regexp.c", ["  case MOPEN + 9:", "    sprintf(buf + STRLEN(buf), \"MOPEN%d\", OP(op) - MOPEN);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp.c", ["  case MCLOSE + 9:", "    sprintf(buf + STRLEN(buf), \"MCLOSE%d\", OP(op) - MCLOSE);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp.c", ["  case BACKREF + 9:", "    sprintf(buf + STRLEN(buf), \"BACKREF%d\", OP(op) - BACKREF);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp.c", ["  case ZOPEN + 9:", "    sprintf(buf + STRLEN(buf), \"ZOPEN%d\", OP(op) - ZOPEN);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp.c", ["  case ZCLOSE + 9:", "    sprintf(buf + STRLEN(buf), \"ZCLOSE%d\", OP(op) - ZCLOSE);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp.c", ["  case ZREF + 9:", "    sprintf(buf + STRLEN(buf), \"ZREF%d\", OP(op) - ZREF);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp.c", ["  case BRACE_COMPLEX + 9:", "    sprintf(buf + STRLEN(buf), \"BRACE_COMPLEX%d\", OP(op) - BRACE_COMPLEX);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp.c", ["  default:", "    sprintf(buf + STRLEN(buf), \"corrupt %d\", OP(op));", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp.c", ["  }", "  if (p != NULL)", "    STRCAT(buf, p);"], "readability/braces"]
["src/nvim/regexp.c", ["}", "#endif      /* REGEXP_DEBUG */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/* 0xfb20 - 0xfb4f */", "static decomp_T decomp_table[0xfb4f-0xfb20+1] ="], "readability/old_style_comment"]
["src/nvim/regexp.c", ["{", "  {0x5e2,0,0},                  /* 0xfb20\talt ayin */", "  {0x5d0,0,0},                  /* 0xfb21\talt alef */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["{", "  {0x5e2,0,0},                  /* 0xfb20\talt ayin */", "  {0x5d0,0,0},                  /* 0xfb21\talt alef */"], "whitespace/tab"]
["src/nvim/regexp.c", ["{", "  {0x5e2,0,0},                  /* 0xfb20\talt ayin */", "  {0x5d0,0,0},                  /* 0xfb21\talt alef */"], "whitespace/comma"]
["src/nvim/regexp.c", ["{", "  {0x5e2,0,0},                  /* 0xfb20\talt ayin */", "  {0x5d0,0,0},                  /* 0xfb21\talt alef */"], "whitespace/braces"]
["src/nvim/regexp.c", ["{", "  {0x5e2,0,0},                  /* 0xfb20\talt ayin */", "  {0x5d0,0,0},                  /* 0xfb21\talt alef */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e2,0,0},                  /* 0xfb20\talt ayin */", "  {0x5d0,0,0},                  /* 0xfb21\talt alef */", "  {0x5d3,0,0},                  /* 0xfb22\talt dalet */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e2,0,0},                  /* 0xfb20\talt ayin */", "  {0x5d0,0,0},                  /* 0xfb21\talt alef */", "  {0x5d3,0,0},                  /* 0xfb22\talt dalet */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e2,0,0},                  /* 0xfb20\talt ayin */", "  {0x5d0,0,0},                  /* 0xfb21\talt alef */", "  {0x5d3,0,0},                  /* 0xfb22\talt dalet */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0x5e2,0,0},                  /* 0xfb20\talt ayin */", "  {0x5d0,0,0},                  /* 0xfb21\talt alef */", "  {0x5d3,0,0},                  /* 0xfb22\talt dalet */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e2,0,0},                  /* 0xfb20\talt ayin */", "  {0x5d0,0,0},                  /* 0xfb21\talt alef */", "  {0x5d3,0,0},                  /* 0xfb22\talt dalet */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d0,0,0},                  /* 0xfb21\talt alef */", "  {0x5d3,0,0},                  /* 0xfb22\talt dalet */", "  {0x5d4,0,0},                  /* 0xfb23\talt he */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d0,0,0},                  /* 0xfb21\talt alef */", "  {0x5d3,0,0},                  /* 0xfb22\talt dalet */", "  {0x5d4,0,0},                  /* 0xfb23\talt he */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d0,0,0},                  /* 0xfb21\talt alef */", "  {0x5d3,0,0},                  /* 0xfb22\talt dalet */", "  {0x5d4,0,0},                  /* 0xfb23\talt he */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0x5d0,0,0},                  /* 0xfb21\talt alef */", "  {0x5d3,0,0},                  /* 0xfb22\talt dalet */", "  {0x5d4,0,0},                  /* 0xfb23\talt he */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d0,0,0},                  /* 0xfb21\talt alef */", "  {0x5d3,0,0},                  /* 0xfb22\talt dalet */", "  {0x5d4,0,0},                  /* 0xfb23\talt he */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d3,0,0},                  /* 0xfb22\talt dalet */", "  {0x5d4,0,0},                  /* 0xfb23\talt he */", "  {0x5db,0,0},                  /* 0xfb24\talt kaf */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d3,0,0},                  /* 0xfb22\talt dalet */", "  {0x5d4,0,0},                  /* 0xfb23\talt he */", "  {0x5db,0,0},                  /* 0xfb24\talt kaf */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d3,0,0},                  /* 0xfb22\talt dalet */", "  {0x5d4,0,0},                  /* 0xfb23\talt he */", "  {0x5db,0,0},                  /* 0xfb24\talt kaf */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0x5d3,0,0},                  /* 0xfb22\talt dalet */", "  {0x5d4,0,0},                  /* 0xfb23\talt he */", "  {0x5db,0,0},                  /* 0xfb24\talt kaf */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d3,0,0},                  /* 0xfb22\talt dalet */", "  {0x5d4,0,0},                  /* 0xfb23\talt he */", "  {0x5db,0,0},                  /* 0xfb24\talt kaf */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d4,0,0},                  /* 0xfb23\talt he */", "  {0x5db,0,0},                  /* 0xfb24\talt kaf */", "  {0x5dc,0,0},                  /* 0xfb25\talt lamed */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d4,0,0},                  /* 0xfb23\talt he */", "  {0x5db,0,0},                  /* 0xfb24\talt kaf */", "  {0x5dc,0,0},                  /* 0xfb25\talt lamed */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d4,0,0},                  /* 0xfb23\talt he */", "  {0x5db,0,0},                  /* 0xfb24\talt kaf */", "  {0x5dc,0,0},                  /* 0xfb25\talt lamed */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0x5d4,0,0},                  /* 0xfb23\talt he */", "  {0x5db,0,0},                  /* 0xfb24\talt kaf */", "  {0x5dc,0,0},                  /* 0xfb25\talt lamed */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d4,0,0},                  /* 0xfb23\talt he */", "  {0x5db,0,0},                  /* 0xfb24\talt kaf */", "  {0x5dc,0,0},                  /* 0xfb25\talt lamed */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5db,0,0},                  /* 0xfb24\talt kaf */", "  {0x5dc,0,0},                  /* 0xfb25\talt lamed */", "  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5db,0,0},                  /* 0xfb24\talt kaf */", "  {0x5dc,0,0},                  /* 0xfb25\talt lamed */", "  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5db,0,0},                  /* 0xfb24\talt kaf */", "  {0x5dc,0,0},                  /* 0xfb25\talt lamed */", "  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0x5db,0,0},                  /* 0xfb24\talt kaf */", "  {0x5dc,0,0},                  /* 0xfb25\talt lamed */", "  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5db,0,0},                  /* 0xfb24\talt kaf */", "  {0x5dc,0,0},                  /* 0xfb25\talt lamed */", "  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5dc,0,0},                  /* 0xfb25\talt lamed */", "  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */", "  {0x5e8,0,0},                  /* 0xfb27\talt resh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5dc,0,0},                  /* 0xfb25\talt lamed */", "  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */", "  {0x5e8,0,0},                  /* 0xfb27\talt resh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5dc,0,0},                  /* 0xfb25\talt lamed */", "  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */", "  {0x5e8,0,0},                  /* 0xfb27\talt resh */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0x5dc,0,0},                  /* 0xfb25\talt lamed */", "  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */", "  {0x5e8,0,0},                  /* 0xfb27\talt resh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5dc,0,0},                  /* 0xfb25\talt lamed */", "  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */", "  {0x5e8,0,0},                  /* 0xfb27\talt resh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */", "  {0x5e8,0,0},                  /* 0xfb27\talt resh */", "  {0x5ea,0,0},                  /* 0xfb28\talt tav */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */", "  {0x5e8,0,0},                  /* 0xfb27\talt resh */", "  {0x5ea,0,0},                  /* 0xfb28\talt tav */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */", "  {0x5e8,0,0},                  /* 0xfb27\talt resh */", "  {0x5ea,0,0},                  /* 0xfb28\talt tav */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */", "  {0x5e8,0,0},                  /* 0xfb27\talt resh */", "  {0x5ea,0,0},                  /* 0xfb28\talt tav */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */", "  {0x5e8,0,0},                  /* 0xfb27\talt resh */", "  {0x5ea,0,0},                  /* 0xfb28\talt tav */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e8,0,0},                  /* 0xfb27\talt resh */", "  {0x5ea,0,0},                  /* 0xfb28\talt tav */", "  {'+', 0, 0},                  /* 0xfb29\talt plus */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e8,0,0},                  /* 0xfb27\talt resh */", "  {0x5ea,0,0},                  /* 0xfb28\talt tav */", "  {'+', 0, 0},                  /* 0xfb29\talt plus */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e8,0,0},                  /* 0xfb27\talt resh */", "  {0x5ea,0,0},                  /* 0xfb28\talt tav */", "  {'+', 0, 0},                  /* 0xfb29\talt plus */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0x5e8,0,0},                  /* 0xfb27\talt resh */", "  {0x5ea,0,0},                  /* 0xfb28\talt tav */", "  {'+', 0, 0},                  /* 0xfb29\talt plus */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e8,0,0},                  /* 0xfb27\talt resh */", "  {0x5ea,0,0},                  /* 0xfb28\talt tav */", "  {'+', 0, 0},                  /* 0xfb29\talt plus */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5ea,0,0},                  /* 0xfb28\talt tav */", "  {'+', 0, 0},                  /* 0xfb29\talt plus */", "  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5ea,0,0},                  /* 0xfb28\talt tav */", "  {'+', 0, 0},                  /* 0xfb29\talt plus */", "  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5ea,0,0},                  /* 0xfb28\talt tav */", "  {'+', 0, 0},                  /* 0xfb29\talt plus */", "  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5ea,0,0},                  /* 0xfb28\talt tav */", "  {'+', 0, 0},                  /* 0xfb29\talt plus */", "  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {'+', 0, 0},                  /* 0xfb29\talt plus */", "  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */", "  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {'+', 0, 0},                  /* 0xfb29\talt plus */", "  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */", "  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {'+', 0, 0},                  /* 0xfb29\talt plus */", "  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */", "  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {'+', 0, 0},                  /* 0xfb29\talt plus */", "  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */", "  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */", "  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */", "  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */", "  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */", "  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */", "  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */", "  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */", "  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */", "  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */", "  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */", "  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */", "  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */", "  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */", "  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */", "  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */", "  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */", "  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */", "  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */", "  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */", "  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */", "  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */", "  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */", "  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */", "  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */", "  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */", "  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */", "  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */", "  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */", "  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */", "  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */", "  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */", "  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */", "  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */", "  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */", "  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */", "  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */", "  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */", "  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */", "  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */", "  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */", "  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */", "  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */", "  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */", "  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */", "  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */", "  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */", "  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */", "  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */", "  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */", "  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */", "  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */", "  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */", "  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */", "  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */", "  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */", "  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */", "  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */", "  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */", "  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */", "  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */", "  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */", "  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */", "  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */", "  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */", "  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */", "  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */", "  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */", "  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */", "  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */", "  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */", "  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */", "  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */", "  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */", "  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */", "  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */", "  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */", "  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */", "  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */", "  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */", "  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */", "  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */", "  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */", "  {0x5d6, 0x5bc, 0},            /* 0xfb36\tzayin+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */", "  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */", "  {0x5d6, 0x5bc, 0},            /* 0xfb36\tzayin+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */", "  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */", "  {0x5d6, 0x5bc, 0},            /* 0xfb36\tzayin+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */", "  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */", "  {0x5d6, 0x5bc, 0},            /* 0xfb36\tzayin+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */", "  {0x5d6, 0x5bc, 0},            /* 0xfb36\tzayin+dagesh */", "  {0xfb37, 0, 0},               /* 0xfb37 -- */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */", "  {0x5d6, 0x5bc, 0},            /* 0xfb36\tzayin+dagesh */", "  {0xfb37, 0, 0},               /* 0xfb37 -- */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */", "  {0x5d6, 0x5bc, 0},            /* 0xfb36\tzayin+dagesh */", "  {0xfb37, 0, 0},               /* 0xfb37 -- */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */", "  {0x5d6, 0x5bc, 0},            /* 0xfb36\tzayin+dagesh */", "  {0xfb37, 0, 0},               /* 0xfb37 -- */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d6, 0x5bc, 0},            /* 0xfb36\tzayin+dagesh */", "  {0xfb37, 0, 0},               /* 0xfb37 -- */", "  {0x5d8, 0x5bc, 0},            /* 0xfb38\ttet+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d6, 0x5bc, 0},            /* 0xfb36\tzayin+dagesh */", "  {0xfb37, 0, 0},               /* 0xfb37 -- */", "  {0x5d8, 0x5bc, 0},            /* 0xfb38\ttet+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d6, 0x5bc, 0},            /* 0xfb36\tzayin+dagesh */", "  {0xfb37, 0, 0},               /* 0xfb37 -- */", "  {0x5d8, 0x5bc, 0},            /* 0xfb38\ttet+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0xfb37, 0, 0},               /* 0xfb37 -- */", "  {0x5d8, 0x5bc, 0},            /* 0xfb38\ttet+dagesh */", "  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0xfb37, 0, 0},               /* 0xfb37 -- */", "  {0x5d8, 0x5bc, 0},            /* 0xfb38\ttet+dagesh */", "  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0xfb37, 0, 0},               /* 0xfb37 -- */", "  {0x5d8, 0x5bc, 0},            /* 0xfb38\ttet+dagesh */", "  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0xfb37, 0, 0},               /* 0xfb37 -- */", "  {0x5d8, 0x5bc, 0},            /* 0xfb38\ttet+dagesh */", "  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d8, 0x5bc, 0},            /* 0xfb38\ttet+dagesh */", "  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */", "  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d8, 0x5bc, 0},            /* 0xfb38\ttet+dagesh */", "  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */", "  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d8, 0x5bc, 0},            /* 0xfb38\ttet+dagesh */", "  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */", "  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d8, 0x5bc, 0},            /* 0xfb38\ttet+dagesh */", "  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */", "  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */", "  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */", "  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */", "  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */", "  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */", "  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */", "  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */", "  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */", "  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */", "  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */", "  {0x5dc, 0x5bc, 0},            /* 0xfb3c\tlamed+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */", "  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */", "  {0x5dc, 0x5bc, 0},            /* 0xfb3c\tlamed+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */", "  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */", "  {0x5dc, 0x5bc, 0},            /* 0xfb3c\tlamed+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */", "  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */", "  {0x5dc, 0x5bc, 0},            /* 0xfb3c\tlamed+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */", "  {0x5dc, 0x5bc, 0},            /* 0xfb3c\tlamed+dagesh */", "  {0xfb3d, 0, 0},               /* 0xfb3d -- */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */", "  {0x5dc, 0x5bc, 0},            /* 0xfb3c\tlamed+dagesh */", "  {0xfb3d, 0, 0},               /* 0xfb3d -- */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */", "  {0x5dc, 0x5bc, 0},            /* 0xfb3c\tlamed+dagesh */", "  {0xfb3d, 0, 0},               /* 0xfb3d -- */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */", "  {0x5dc, 0x5bc, 0},            /* 0xfb3c\tlamed+dagesh */", "  {0xfb3d, 0, 0},               /* 0xfb3d -- */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5dc, 0x5bc, 0},            /* 0xfb3c\tlamed+dagesh */", "  {0xfb3d, 0, 0},               /* 0xfb3d -- */", "  {0x5de, 0x5bc, 0},            /* 0xfb3e\tmem+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5dc, 0x5bc, 0},            /* 0xfb3c\tlamed+dagesh */", "  {0xfb3d, 0, 0},               /* 0xfb3d -- */", "  {0x5de, 0x5bc, 0},            /* 0xfb3e\tmem+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5dc, 0x5bc, 0},            /* 0xfb3c\tlamed+dagesh */", "  {0xfb3d, 0, 0},               /* 0xfb3d -- */", "  {0x5de, 0x5bc, 0},            /* 0xfb3e\tmem+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0xfb3d, 0, 0},               /* 0xfb3d -- */", "  {0x5de, 0x5bc, 0},            /* 0xfb3e\tmem+dagesh */", "  {0xfb3f, 0, 0},               /* 0xfb3f -- */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0xfb3d, 0, 0},               /* 0xfb3d -- */", "  {0x5de, 0x5bc, 0},            /* 0xfb3e\tmem+dagesh */", "  {0xfb3f, 0, 0},               /* 0xfb3f -- */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0xfb3d, 0, 0},               /* 0xfb3d -- */", "  {0x5de, 0x5bc, 0},            /* 0xfb3e\tmem+dagesh */", "  {0xfb3f, 0, 0},               /* 0xfb3f -- */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0xfb3d, 0, 0},               /* 0xfb3d -- */", "  {0x5de, 0x5bc, 0},            /* 0xfb3e\tmem+dagesh */", "  {0xfb3f, 0, 0},               /* 0xfb3f -- */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5de, 0x5bc, 0},            /* 0xfb3e\tmem+dagesh */", "  {0xfb3f, 0, 0},               /* 0xfb3f -- */", "  {0x5e0, 0x5bc, 0},            /* 0xfb40\tnun+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5de, 0x5bc, 0},            /* 0xfb3e\tmem+dagesh */", "  {0xfb3f, 0, 0},               /* 0xfb3f -- */", "  {0x5e0, 0x5bc, 0},            /* 0xfb40\tnun+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5de, 0x5bc, 0},            /* 0xfb3e\tmem+dagesh */", "  {0xfb3f, 0, 0},               /* 0xfb3f -- */", "  {0x5e0, 0x5bc, 0},            /* 0xfb40\tnun+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0xfb3f, 0, 0},               /* 0xfb3f -- */", "  {0x5e0, 0x5bc, 0},            /* 0xfb40\tnun+dagesh */", "  {0x5e1, 0x5bc, 0},            /* 0xfb41\tsamech+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0xfb3f, 0, 0},               /* 0xfb3f -- */", "  {0x5e0, 0x5bc, 0},            /* 0xfb40\tnun+dagesh */", "  {0x5e1, 0x5bc, 0},            /* 0xfb41\tsamech+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0xfb3f, 0, 0},               /* 0xfb3f -- */", "  {0x5e0, 0x5bc, 0},            /* 0xfb40\tnun+dagesh */", "  {0x5e1, 0x5bc, 0},            /* 0xfb41\tsamech+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0xfb3f, 0, 0},               /* 0xfb3f -- */", "  {0x5e0, 0x5bc, 0},            /* 0xfb40\tnun+dagesh */", "  {0x5e1, 0x5bc, 0},            /* 0xfb41\tsamech+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e0, 0x5bc, 0},            /* 0xfb40\tnun+dagesh */", "  {0x5e1, 0x5bc, 0},            /* 0xfb41\tsamech+dagesh */", "  {0xfb42, 0, 0},               /* 0xfb42 -- */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e0, 0x5bc, 0},            /* 0xfb40\tnun+dagesh */", "  {0x5e1, 0x5bc, 0},            /* 0xfb41\tsamech+dagesh */", "  {0xfb42, 0, 0},               /* 0xfb42 -- */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e0, 0x5bc, 0},            /* 0xfb40\tnun+dagesh */", "  {0x5e1, 0x5bc, 0},            /* 0xfb41\tsamech+dagesh */", "  {0xfb42, 0, 0},               /* 0xfb42 -- */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e0, 0x5bc, 0},            /* 0xfb40\tnun+dagesh */", "  {0x5e1, 0x5bc, 0},            /* 0xfb41\tsamech+dagesh */", "  {0xfb42, 0, 0},               /* 0xfb42 -- */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e1, 0x5bc, 0},            /* 0xfb41\tsamech+dagesh */", "  {0xfb42, 0, 0},               /* 0xfb42 -- */", "  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e1, 0x5bc, 0},            /* 0xfb41\tsamech+dagesh */", "  {0xfb42, 0, 0},               /* 0xfb42 -- */", "  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e1, 0x5bc, 0},            /* 0xfb41\tsamech+dagesh */", "  {0xfb42, 0, 0},               /* 0xfb42 -- */", "  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0xfb42, 0, 0},               /* 0xfb42 -- */", "  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */", "  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0xfb42, 0, 0},               /* 0xfb42 -- */", "  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */", "  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0xfb42, 0, 0},               /* 0xfb42 -- */", "  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */", "  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0xfb42, 0, 0},               /* 0xfb42 -- */", "  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */", "  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */", "  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */", "  {0xfb45, 0, 0},               /* 0xfb45 -- */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */", "  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */", "  {0xfb45, 0, 0},               /* 0xfb45 -- */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */", "  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */", "  {0xfb45, 0, 0},               /* 0xfb45 -- */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */", "  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */", "  {0xfb45, 0, 0},               /* 0xfb45 -- */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */", "  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */", "  {0xfb45, 0, 0},               /* 0xfb45 -- */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */", "  {0xfb45, 0, 0},               /* 0xfb45 -- */", "  {0x5e6, 0x5bc, 0},            /* 0xfb46\ttsadi+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */", "  {0xfb45, 0, 0},               /* 0xfb45 -- */", "  {0x5e6, 0x5bc, 0},            /* 0xfb46\ttsadi+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */", "  {0xfb45, 0, 0},               /* 0xfb45 -- */", "  {0x5e6, 0x5bc, 0},            /* 0xfb46\ttsadi+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0xfb45, 0, 0},               /* 0xfb45 -- */", "  {0x5e6, 0x5bc, 0},            /* 0xfb46\ttsadi+dagesh */", "  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0xfb45, 0, 0},               /* 0xfb45 -- */", "  {0x5e6, 0x5bc, 0},            /* 0xfb46\ttsadi+dagesh */", "  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0xfb45, 0, 0},               /* 0xfb45 -- */", "  {0x5e6, 0x5bc, 0},            /* 0xfb46\ttsadi+dagesh */", "  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0xfb45, 0, 0},               /* 0xfb45 -- */", "  {0x5e6, 0x5bc, 0},            /* 0xfb46\ttsadi+dagesh */", "  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e6, 0x5bc, 0},            /* 0xfb46\ttsadi+dagesh */", "  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */", "  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e6, 0x5bc, 0},            /* 0xfb46\ttsadi+dagesh */", "  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */", "  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e6, 0x5bc, 0},            /* 0xfb46\ttsadi+dagesh */", "  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */", "  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e6, 0x5bc, 0},            /* 0xfb46\ttsadi+dagesh */", "  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */", "  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */", "  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */", "  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */", "  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */", "  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */", "  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */", "  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */", "  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */", "  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */", "  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */", "  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */", "  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */", "  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */", "  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */", "  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */", "  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */", "  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */", "  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */", "  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */", "  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */", "  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */", "  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */", "  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */", "  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */", "  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */", "  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */", "  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */", "  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */", "  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */", "  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */", "  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */", "  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */", "  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */", "  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */", "  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */", "  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */", "  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */", "  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */", "  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */", "  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */", "  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */", "  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */", "  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */", "  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */", "  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */", "  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */", "  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */", "  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */", "  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */", "  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */", "  {0x5d0, 0x5dc, 0}             /* 0xfb4f\talef-lamed */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */", "  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */", "  {0x5d0, 0x5dc, 0}             /* 0xfb4f\talef-lamed */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */", "  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */", "  {0x5d0, 0x5dc, 0}             /* 0xfb4f\talef-lamed */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */", "  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */", "  {0x5d0, 0x5dc, 0}             /* 0xfb4f\talef-lamed */"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */", "  {0x5d0, 0x5dc, 0}             /* 0xfb4f\talef-lamed */", "};"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */", "  {0x5d0, 0x5dc, 0}             /* 0xfb4f\talef-lamed */", "};"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */", "  {0x5d0, 0x5dc, 0}             /* 0xfb4f\talef-lamed */", "};"], "whitespace/braces"]
["src/nvim/regexp.c", ["  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */", "  {0x5d0, 0x5dc, 0}             /* 0xfb4f\talef-lamed */", "};"], "whitespace/braces"]
["src/nvim/regexp.c", ["    assert(*n >= 0);", "    result = mb_strnicmp(s1, s2, (size_t)*n);", "  }"], "whitespace/operators"]
["src/nvim/regexp.c", ["", "    /* we have to handle the strcmp ourselves, since it is necessary to", "     * deal with the composing characters by ignoring them: */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "      /* decompose the character if necessary, into 'base' characters", "       * because I don't care about Arabic, I will hard-code the Hebrew"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    result = c2 - c1;", "    if (result == 0)", "      *n = (int)(str2 - s2);"], "readability/braces"]
["src/nvim/regexp.c", ["", "/***************************************************************", "*\t\t      regsub stuff\t\t\t       *"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/* This stuff below really confuses cc on an SGI -- webb */", ""], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * regtilde(): Replace tildes in the pattern by the old pattern."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  for (p = newsub; *p; ++p) {", "    if ((*p == '~' && magic) || (*p == '\\\\' && *(p + 1) == '~' && !magic)) {"], "readability/increment"]
["src/nvim/regexp.c", ["      if (reg_prev_sub != NULL) {", "        /* length = len(newsub) - 1 + len(prev_sub) + 1 */", "        prevlen = (int)STRLEN(reg_prev_sub);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        tmpsub = xmalloc(STRLEN(newsub) + prevlen);", "        /* copy prefix */", "        len = (int)(p - newsub);              /* not including ~ */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        /* copy prefix */", "        len = (int)(p - newsub);              /* not including ~ */", "        memmove(tmpsub, newsub, (size_t)len);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        memmove(tmpsub, newsub, (size_t)len);", "        /* interpret tilde */", "        memmove(tmpsub + len, reg_prev_sub, (size_t)prevlen);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        memmove(tmpsub + len, reg_prev_sub, (size_t)prevlen);", "        /* copy postfix */", "        if (!magic)"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        /* copy postfix */", "        if (!magic)", "          ++p;                                /* back off \\ */"], "readability/braces"]
["src/nvim/regexp.c", ["        if (!magic)", "          ++p;                                /* back off \\ */", "        STRCPY(tmpsub + len + prevlen, p + 1);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        if (!magic)", "          ++p;                                /* back off \\ */", "        STRCPY(tmpsub + len + prevlen, p + 1);"], "readability/increment"]
["src/nvim/regexp.c", ["", "        if (newsub != source)                 /* already allocated newsub */", "          xfree(newsub);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "        if (newsub != source)                 /* already allocated newsub */", "          xfree(newsub);"], "readability/braces"]
["src/nvim/regexp.c", ["        p = newsub + len + prevlen;", "      } else if (magic)", "        STRMOVE(p, p + 1);              /* remove '~' */"], "readability/braces"]
["src/nvim/regexp.c", ["      } else if (magic)", "        STRMOVE(p, p + 1);              /* remove '~' */", "      else"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        STRMOVE(p, p + 1);              /* remove '~' */", "      else", "        STRMOVE(p, p + 2);              /* remove '\\~' */"], "readability/braces"]
["src/nvim/regexp.c", ["      else", "        STRMOVE(p, p + 2);              /* remove '\\~' */", "      --p;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        STRMOVE(p, p + 2);              /* remove '\\~' */", "      --p;", "    } else {"], "readability/increment"]
["src/nvim/regexp.c", ["  xfree(reg_prev_sub);", "  if (newsub != source)         /* newsub was allocated, just keep it */", "    reg_prev_sub = newsub;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  xfree(reg_prev_sub);", "  if (newsub != source)         /* newsub was allocated, just keep it */", "    reg_prev_sub = newsub;"], "readability/braces"]
["src/nvim/regexp.c", ["    reg_prev_sub = newsub;", "  else                          /* no ~ found, need to save newsub  */", "    reg_prev_sub = vim_strsave(newsub);"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    reg_prev_sub = newsub;", "  else                          /* no ~ found, need to save newsub  */", "    reg_prev_sub = vim_strsave(newsub);"], "readability/braces"]
["src/nvim/regexp.c", ["", "int vim_regsub_multi(regmmatch_T *rmp, linenr_T lnum, char_u *source, char_u *dest, int copy, int magic, int backslash)", "{"], "whitespace/line_length"]
["src/nvim/regexp.c", ["  fptr_T func_one = (fptr_T)NULL;", "  linenr_T clnum = 0;           /* init for GCC */", "  int len = 0;                  /* init for GCC */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  linenr_T clnum = 0;           /* init for GCC */", "  int len = 0;                  /* init for GCC */", "  static char_u *eval_result = NULL;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  }", "  if (prog_magic_wrong())", "    return 0;"], "readability/braces"]
["src/nvim/regexp.c", ["            s++;", "            /* Change NL to CR here too, so that this works:", "             * :s/abc\\\\\\ndef/\\=\"aaa\\\\\\nbbb\"/  on text:"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        if (had_backslash && backslash) {", "          /* Backslashes will be consumed, need to double them. */", "          s = vim_strsave_escaped(eval_result, (char_u *)\"\\\\\");"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    }", "  } else", "    while ((c = *src++) != NUL) {"], "readability/braces"]
["src/nvim/regexp.c", ["    while ((c = *src++) != NUL) {", "      if (c == '&' && magic)", "        no = 0;"], "readability/braces"]
["src/nvim/regexp.c", ["        no = 0;", "      else if (c == '\\\\' && *src != NUL) {", "        if (*src == '&' && !magic) {"], "readability/braces"]
["src/nvim/regexp.c", ["        if (*src == '&' && !magic) {", "          ++src;", "          no = 0;"], "readability/increment"]
["src/nvim/regexp.c", ["      }", "      if (no < 0) {           /* Ordinary character. */", "        if (c == K_SPECIAL && src[0] != NUL && src[1] != NUL) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        if (c == K_SPECIAL && src[0] != NUL && src[1] != NUL) {", "          /* Copy a special key as-is. */", "          if (copy) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["              if (backslash && (*s == CAR || *s == '\\\\')) {", "                /*", "                 * Insert a backslash in front of a CR, otherwise"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "                if (func_one != (fptr_T)NULL)", "                  /* Turbo C complains without the typecast */"], "readability/braces"]
["src/nvim/regexp.c", ["                if (func_one != (fptr_T)NULL)", "                  /* Turbo C complains without the typecast */", "                  func_one = (fptr_T)(func_one(&cc, c));"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["                  func_one = (fptr_T)(func_one(&cc, c));", "                else if (func_all != (fptr_T)NULL)", "                  /* Turbo C complains without the typecast */"], "readability/braces"]
["src/nvim/regexp.c", ["                else if (func_all != (fptr_T)NULL)", "                  /* Turbo C complains without the typecast */", "                  func_all = (fptr_T)(func_all(&cc, c));"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["                  func_all = (fptr_T)(func_all(&cc, c));", "                else             /* just copy */", "                  cc = c;"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["                  func_all = (fptr_T)(func_all(&cc, c));", "                else             /* just copy */", "                  cc = c;"], "readability/braces"]
["src/nvim/regexp.c", ["", "              ++s;", "              --len;"], "readability/increment"]
["src/nvim/regexp.c", ["              ++s;", "              --len;", "            }"], "readability/increment"]
["src/nvim/regexp.c", ["    }", "  if (copy)", "    *dst = NUL;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Call reg_getline() with the line numbers from the submatch.  If a"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Used for the submatch() function: get the string from the n'th submatch in"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  if (!can_f_submatch || no < 0)", "    return NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["", "    /*", "     * First round: compute the length and allocate memory."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          s = reg_getline_submatch(lnum++);", "          if (round == 2)", "            STRCPY(retval + len, s);"], "readability/braces"]
["src/nvim/regexp.c", ["          len += STRLEN(s);", "          if (round == 2)", "            retval[len] = '\\n';"], "readability/braces"]
["src/nvim/regexp.c", ["            retval[len] = '\\n';", "          ++len;", "        }"], "readability/increment"]
["src/nvim/regexp.c", ["        if (round == 2) {", "          STRNCPY(retval + len, reg_getline_submatch(lnum),", "                  rsm.sm_mmatch->endpos[no].col);"], "runtime/printf"]
["src/nvim/regexp.c", ["", "/* Which regexp engine to use? Needed for vim_regcomp().", " * Must match with 'regexpengine'. */"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Compile a regular expression into internal code."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  /* Check for prefix \"\\%#=\", that sets the regexp engine */", "  if (STRNCMP(expr, \"\\\\%#=\", 4) == 0) {"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["      EMSG(_(", "              \"E864: \\\\%#= can only be followed by 0, 1, or 2. The automatic engine will be used \"));", "      regexp_engine = AUTOMATIC_ENGINE;"], "whitespace/indent"]
["src/nvim/regexp.c", ["      EMSG(_(", "              \"E864: \\\\%#= can only be followed by 0, 1, or 2. The automatic engine will be used \"));", "      regexp_engine = AUTOMATIC_ENGINE;"], "whitespace/line_length"]
["src/nvim/regexp.c", ["    prog = nfa_regengine.regcomp(expr,", "        re_flags + (regexp_engine == AUTOMATIC_ENGINE ? RE_AUTO : 0));", "  } else {"], "whitespace/alignment"]
["src/nvim/regexp.c", ["        fclose(f);", "      } else", "        EMSG2(\"(NFA) Could not open \\\"%s\\\" to write !!!\","], "readability/braces"]
["src/nvim/regexp.c", ["        EMSG2(\"(NFA) Could not open \\\"%s\\\" to write !!!\",", "            BT_REGEXP_DEBUG_LOG_NAME);", "    }"], "whitespace/alignment"]
["src/nvim/regexp.c", ["", "/*", " * Free a compiled regexp program, returned by vim_regcomp()."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["{", "  if (prog != NULL)", "    prog->engine->regfree(prog);"], "readability/braces"]
