["src/nvim/memline.c", ["", "/*", " * memline.c: Contains the functions for appending, deleting and changing the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "#ifndef UNIX            /* it's in os/unix_defs.h for Unix */", "# include <time.h>"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#ifndef UNIX            /* it's in os/unix_defs.h for Unix */", "# include <time.h>", "#endif"], "build/include_order"]
["src/nvim/memline.c", ["", "typedef struct block0 ZERO_BL;              /* contents of the first block */", "typedef struct pointer_block PTR_BL;        /* contents of a pointer block */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["typedef struct block0 ZERO_BL;              /* contents of the first block */", "typedef struct pointer_block PTR_BL;        /* contents of a pointer block */", "typedef struct data_block DATA_BL;          /* contents of a data block */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["typedef struct pointer_block PTR_BL;        /* contents of a pointer block */", "typedef struct data_block DATA_BL;          /* contents of a data block */", "typedef struct pointer_entry PTR_EN;        /* block/line-count pair */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["typedef struct data_block DATA_BL;          /* contents of a data block */", "typedef struct pointer_entry PTR_EN;        /* block/line-count pair */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "#define DATA_ID        (('d' << 8) + 'a')   /* data block id */", "#define PTR_ID         (('p' << 8) + 't')   /* pointer block id */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define DATA_ID        (('d' << 8) + 'a')   /* data block id */", "#define PTR_ID         (('p' << 8) + 't')   /* pointer block id */", "#define BLOCK0_ID0     'b'                  /* block 0 id 0 */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define PTR_ID         (('p' << 8) + 't')   /* pointer block id */", "#define BLOCK0_ID0     'b'                  /* block 0 id 0 */", "#define BLOCK0_ID1     '0'                  /* block 0 id 1 */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define BLOCK0_ID0     'b'                  /* block 0 id 0 */", "#define BLOCK0_ID1     '0'                  /* block 0 id 1 */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * pointer to a block, used in a pointer block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["struct pointer_entry {", "  blocknr_T pe_bnum;            /* block number */", "  linenr_T pe_line_count;       /* number of lines in this branch */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  blocknr_T pe_bnum;            /* block number */", "  linenr_T pe_line_count;       /* number of lines in this branch */", "  linenr_T pe_old_lnum;         /* lnum for this block (for recovery) */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  linenr_T pe_line_count;       /* number of lines in this branch */", "  linenr_T pe_old_lnum;         /* lnum for this block (for recovery) */", "  int pe_page_count;            /* number of pages in block pe_bnum */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  linenr_T pe_old_lnum;         /* lnum for this block (for recovery) */", "  int pe_page_count;            /* number of pages in block pe_bnum */", "};"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * A pointer block contains a list of branches in the tree."], "readability/old_style_comment"]
["src/nvim/memline.c", ["struct pointer_block {", "  uint16_t pb_id;               /* ID for pointer block: PTR_ID */", "  uint16_t pb_count;            /* number of pointers in this block */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  uint16_t pb_id;               /* ID for pointer block: PTR_ID */", "  uint16_t pb_count;            /* number of pointers in this block */", "  uint16_t pb_count_max;        /* maximum value for pb_count */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  uint16_t pb_count;            /* number of pointers in this block */", "  uint16_t pb_count_max;        /* maximum value for pb_count */", "  PTR_EN pb_pointer[1];         /* list of pointers to blocks (actually longer)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  uint16_t pb_count_max;        /* maximum value for pb_count */", "  PTR_EN pb_pointer[1];         /* list of pointers to blocks (actually longer)", "                                 * followed by empty space until end of page */"], "readability/multiline_comment"]
["src/nvim/memline.c", ["  uint16_t pb_count_max;        /* maximum value for pb_count */", "  PTR_EN pb_pointer[1];         /* list of pointers to blocks (actually longer)", "                                 * followed by empty space until end of page */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  uint16_t pb_count_max;        /* maximum value for pb_count */", "  PTR_EN pb_pointer[1];         /* list of pointers to blocks (actually longer)", "                                 * followed by empty space until end of page */"], "whitespace/parens"]
["src/nvim/memline.c", ["", "/*", " * A data block is a leaf in the tree."], "readability/old_style_comment"]
["src/nvim/memline.c", ["struct data_block {", "  uint16_t db_id;               /* ID for data block: DATA_ID */", "  unsigned db_free;             /* free space available */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  uint16_t db_id;               /* ID for data block: DATA_ID */", "  unsigned db_free;             /* free space available */", "  unsigned db_txt_start;        /* byte where text starts */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  unsigned db_free;             /* free space available */", "  unsigned db_txt_start;        /* byte where text starts */", "  unsigned db_txt_end;          /* byte just after data block */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  unsigned db_txt_start;        /* byte where text starts */", "  unsigned db_txt_end;          /* byte just after data block */", "  linenr_T db_line_count;       /* number of lines in this block */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  unsigned db_txt_end;          /* byte just after data block */", "  linenr_T db_line_count;       /* number of lines in this block */", "  unsigned db_index[1];         /* index for start of line (actually bigger)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  linenr_T db_line_count;       /* number of lines in this block */", "  unsigned db_index[1];         /* index for start of line (actually bigger)", "                                 * followed by empty space upto db_txt_start"], "readability/multiline_comment"]
["src/nvim/memline.c", ["  linenr_T db_line_count;       /* number of lines in this block */", "  unsigned db_index[1];         /* index for start of line (actually bigger)", "                                 * followed by empty space upto db_txt_start"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * The low bits of db_index hold the actual index. The topmost bit is"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "#define INDEX_SIZE  (sizeof(unsigned))      /* size of one db_index entry */", "#define HEADER_SIZE (sizeof(DATA_BL) - INDEX_SIZE)  /* size of data block header */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define INDEX_SIZE  (sizeof(unsigned))      /* size of one db_index entry */", "#define HEADER_SIZE (sizeof(DATA_BL) - INDEX_SIZE)  /* size of data block header */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define INDEX_SIZE  (sizeof(unsigned))      /* size of one db_index entry */", "#define HEADER_SIZE (sizeof(DATA_BL) - INDEX_SIZE)  /* size of data block header */", ""], "whitespace/line_length"]
["src/nvim/memline.c", ["", "#define B0_FNAME_SIZE_ORG       900     /* what it was in older versions */", "#define B0_FNAME_SIZE_NOCRYPT   898     /* 2 bytes used for other things */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define B0_FNAME_SIZE_ORG       900     /* what it was in older versions */", "#define B0_FNAME_SIZE_NOCRYPT   898     /* 2 bytes used for other things */", "#define B0_FNAME_SIZE_CRYPT     890     /* 10 bytes used for other things */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define B0_FNAME_SIZE_NOCRYPT   898     /* 2 bytes used for other things */", "#define B0_FNAME_SIZE_CRYPT     890     /* 10 bytes used for other things */", "#define B0_UNAME_SIZE           40"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define B0_HNAME_SIZE           40", "/*", " * Restrict the numbers to 32 bits, otherwise most compilers will complain."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Block zero holds all info about the swap file."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  char_u b0_id[2];              ///< ID for block 0: BLOCK0_ID0 and BLOCK0_ID1.", "  char_u b0_version[10];        /* Vim version string */", "  char_u b0_page_size[4];       /* number of bytes per page */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  char_u b0_version[10];        /* Vim version string */", "  char_u b0_page_size[4];       /* number of bytes per page */", "  char_u b0_mtime[4];           /* last modification time of file */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  char_u b0_page_size[4];       /* number of bytes per page */", "  char_u b0_mtime[4];           /* last modification time of file */", "  char_u b0_ino[4];             /* inode of b0_fname */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  char_u b0_mtime[4];           /* last modification time of file */", "  char_u b0_ino[4];             /* inode of b0_fname */", "  char_u b0_pid[4];             /* process id of creator (or 0) */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  char_u b0_ino[4];             /* inode of b0_fname */", "  char_u b0_pid[4];             /* process id of creator (or 0) */", "  char_u b0_uname[B0_UNAME_SIZE];        /* name of user (uid if no name) */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  char_u b0_pid[4];             /* process id of creator (or 0) */", "  char_u b0_uname[B0_UNAME_SIZE];        /* name of user (uid if no name) */", "  char_u b0_hname[B0_HNAME_SIZE];        /* host name (if it has a name) */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  char_u b0_uname[B0_UNAME_SIZE];        /* name of user (uid if no name) */", "  char_u b0_hname[B0_HNAME_SIZE];        /* host name (if it has a name) */", "  char_u b0_fname[B0_FNAME_SIZE_ORG];        /* name of file being edited */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  char_u b0_hname[B0_HNAME_SIZE];        /* host name (if it has a name) */", "  char_u b0_fname[B0_FNAME_SIZE_ORG];        /* name of file being edited */", "  long b0_magic_long;           /* check for byte order of long */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  char_u b0_fname[B0_FNAME_SIZE_ORG];        /* name of file being edited */", "  long b0_magic_long;           /* check for byte order of long */", "  int b0_magic_int;             /* check for byte order of int */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  long b0_magic_long;           /* check for byte order of long */", "  int b0_magic_int;             /* check for byte order of int */", "  short b0_magic_short;         /* check for byte order of short */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  int b0_magic_int;             /* check for byte order of int */", "  short b0_magic_short;         /* check for byte order of short */", "  char_u b0_magic_char;         /* check for last char */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  int b0_magic_int;             /* check for byte order of int */", "  short b0_magic_short;         /* check for byte order of short */", "  char_u b0_magic_char;         /* check for last char */"], "runtime/int"]
["src/nvim/memline.c", ["  short b0_magic_short;         /* check for byte order of short */", "  char_u b0_magic_char;         /* check for last char */", "};"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Note: b0_dirty and b0_flags are put at the end of the file name.  For very"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * The b0_flags field is new in Vim 7.0."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/* The lowest two bits contain the fileformat.  Zero means it's not set", " * (compatible with Vim 6.x), otherwise it's EOL_UNIX + 1, EOL_DOS + 1 or"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/* Swap file is in directory of edited file.  Used to find the file from", " * different mount points. */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/* The 'fileencoding' is at the end of b0_fname[], with a NUL in front of it.", " * When empty there is only the NUL. */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "#define STACK_INCR      5       /* nr of entries added to ml_stack at a time */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * The line number where the first mark may be is remembered."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * arguments for ml_find_line()"], "readability/old_style_comment"]
["src/nvim/memline.c", [" */", "#define ML_DELETE       0x11        /* delete line */", "#define ML_INSERT       0x12        /* insert line */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define ML_DELETE       0x11        /* delete line */", "#define ML_INSERT       0x12        /* insert line */", "#define ML_FIND         0x13        /* just find the line */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define ML_INSERT       0x12        /* insert line */", "#define ML_FIND         0x13        /* just find the line */", "#define ML_FLUSH        0x02        /* flush locked block */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define ML_FIND         0x13        /* just find the line */", "#define ML_FLUSH        0x02        /* flush locked block */", "#define ML_SIMPLE(x)    (x & 0x10)  /* DEL, INS or FIND */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define ML_FLUSH        0x02        /* flush locked block */", "#define ML_SIMPLE(x)    (x & 0x10)  /* DEL, INS or FIND */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/* argument for ml_upd_block0() */", "typedef enum {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["typedef enum {", "  UB_FNAME = 0          /* update timestamp and filename */", "  , UB_SAME_DIR         /* update the B0_SAME_DIR flag */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  UB_FNAME = 0          /* update timestamp and filename */", "  , UB_SAME_DIR         /* update the B0_SAME_DIR flag */", "} upd_block0_T;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Open a new memline for \"buf\"."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * init fields in memline struct"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * When 'updatecount' is non-zero swap file may be opened later."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * fill block0 struct and write page 0"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  b0p->b0_magic_int = (int)B0_MAGIC_INT;", "  b0p->b0_magic_short = (short)B0_MAGIC_SHORT;", "  b0p->b0_magic_char = B0_MAGIC_CHAR;"], "runtime/int"]
["src/nvim/memline.c", ["  b0p->b0_magic_char = B0_MAGIC_CHAR;", "  xstrlcpy(xstpcpy((char *) b0p->b0_version, \"VIM \"), Version, 6);", "  long_to_char((long)mfp->mf_page_size, b0p->b0_page_size);"], "whitespace/cast"]
["src/nvim/memline.c", ["", "  /*", "   * Always sync block number 0 to disk, so we can check the file name in"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  mf_put(mfp, hp, true, false);", "  if (!buf->b_help && !B_SPELL(buf))", "    (void)mf_sync(mfp, 0);"], "readability/braces"]
["src/nvim/memline.c", ["", "  /*", "   * Fill in root pointer block and write page 1."], "readability/old_style_comment"]
["src/nvim/memline.c", ["   */", "  if ((hp = ml_new_ptr(mfp)) == NULL)", "    goto error;"], "readability/braces"]
["src/nvim/memline.c", ["  pp->pb_pointer[0].pe_old_lnum = 1;", "  pp->pb_pointer[0].pe_line_count = 1;      /* line count after insertion */", "  mf_put(mfp, hp, true, false);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Allocate first data block and create an empty line 1."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  dp = hp->bh_data;", "  dp->db_index[0] = --dp->db_txt_start;         /* at end of block */", "  dp->db_free -= 1 + INDEX_SIZE;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  dp->db_line_count = 1;", "  *((char_u *)dp + dp->db_txt_start) = NUL;     /* empty line */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * ml_setname() is called when the file name of \"buf\" has been changed."], "readability/old_style_comment"]
["src/nvim/memline.c", ["{", "  int success = FALSE;", "  memfile_T   *mfp;"], "readability/bool"]
["src/nvim/memline.c", ["  mfp = buf->b_ml.ml_mfp;", "  if (mfp->mf_fd < 0) {             /* there is no swap file yet */", "    /*"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if (mfp->mf_fd < 0) {             /* there is no swap file yet */", "    /*", "     * When 'updatecount' is 0 and 'noswapfile' there is no swap file."], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (p_uc != 0 && !cmdmod.noswapfile) {", "      ml_open_file(buf); /* create a swap file */", "    }"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Try all directories in the 'directory' option."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  for (;; ) {", "    if (*dirp == NUL)               /* tried all directories, fail */", "      break;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  for (;; ) {", "    if (*dirp == NUL)               /* tried all directories, fail */", "      break;"], "readability/braces"]
["src/nvim/memline.c", ["                                   &found_existing_dir);", "    /* alloc's fname */", "    if (dirp == NULL)               /* out of memory */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    /* alloc's fname */", "    if (dirp == NULL)               /* out of memory */", "      break;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    /* alloc's fname */", "    if (dirp == NULL)               /* out of memory */", "      break;"], "readability/braces"]
["src/nvim/memline.c", ["      break;", "    if (fname == NULL)              /* no file name found for this dir */", "      continue;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      break;", "    if (fname == NULL)              /* no file name found for this dir */", "      continue;"], "readability/braces"]
["src/nvim/memline.c", ["", "    /* if the file name is the same we don't have to do anything */", "    if (fnamecmp(fname, mfp->mf_fname) == 0) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      xfree(fname);", "      success = TRUE;", "      break;"], "readability/bool"]
["src/nvim/memline.c", ["    }", "    /* need to close the swap file before renaming */", "    if (mfp->mf_fd >= 0) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /* try to rename the swap file */", "    if (vim_rename(mfp->mf_fname, fname) == 0) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (vim_rename(mfp->mf_fname, fname) == 0) {", "      success = TRUE;", "      mf_free_fnames(mfp);"], "readability/bool"]
["src/nvim/memline.c", ["    }", "    xfree(fname);                /* this fname didn't work, try another */", "  }"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (mfp->mf_fd == -1) {           /* need to (re)open the swap file */", "    mfp->mf_fd = os_open((char *)mfp->mf_fname, O_RDWR, 0);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (mfp->mf_fd < 0) {", "      /* could not (re)open the swap file, what can we do???? */", "      EMSG(_(\"E301: Oops, lost the swap file!!!\"));"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  }", "  if (!success)", "    EMSG(_(\"E302: Could not rename swap file\"));"], "readability/braces"]
["src/nvim/memline.c", ["", "/*", " * Open a file for the memfile for all buffers that are not readonly or have"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Open a swap file for an existing memfile, if there is no swap file yet."], "readability/old_style_comment"]
["src/nvim/memline.c", ["      || buf->terminal) {", "    return; /* nothing to do */", "  }"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /* For a spell buffer use a temp file name. */", "  if (buf->b_spell) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    fname = vim_tempname();", "    if (fname != NULL)", "      (void)mf_open_file(mfp, fname);           /* consumes fname! */"], "readability/braces"]
["src/nvim/memline.c", ["    if (fname != NULL)", "      (void)mf_open_file(mfp, fname);           /* consumes fname! */", "    buf->b_may_swap = false;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Try all directories in 'directory' option."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  for (;; ) {", "    if (*dirp == NUL)", "      break;"], "readability/braces"]
["src/nvim/memline.c", ["                                   &found_existing_dir);", "    if (dirp == NULL)", "      break;        /* out of memory */"], "readability/braces"]
["src/nvim/memline.c", ["    if (dirp == NULL)", "      break;        /* out of memory */", "    if (fname == NULL)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      break;        /* out of memory */", "    if (fname == NULL)", "      continue;"], "readability/braces"]
["src/nvim/memline.c", ["      continue;", "    if (mf_open_file(mfp, fname) == OK) {       /* consumes fname! */", "      ml_upd_block0(buf, UB_SAME_DIR);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "      /* Flush block zero, so others can read it */", "      if (mf_sync(mfp, MFS_ZERO) == OK) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      if (mf_sync(mfp, MFS_ZERO) == OK) {", "        /* Mark all blocks that should be in the swapfile as dirty.", "         * Needed for when the 'swapfile' option was reset, so that"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      }", "      /* Writing block 0 failed: close the file and try another dir */", "      mf_close_file(buf, false);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    (void)EMSG2(_(", "            \"E303: Unable to open swap file for \\\"%s\\\", recovery impossible\"),", "        buf_spname(buf) != NULL ? buf_spname(buf) : buf->b_fname);"], "whitespace/indent"]
["src/nvim/memline.c", ["            \"E303: Unable to open swap file for \\\"%s\\\", recovery impossible\"),", "        buf_spname(buf) != NULL ? buf_spname(buf) : buf->b_fname);", "    --no_wait_return;"], "whitespace/alignment"]
["src/nvim/memline.c", ["        buf_spname(buf) != NULL ? buf_spname(buf) : buf->b_fname);", "    --no_wait_return;", "  }"], "readability/increment"]
["src/nvim/memline.c", ["", "  /* don't try to open a swap file again */", "  buf->b_may_swap = false;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Close memline for buffer 'buf'."], "readability/old_style_comment"]
["src/nvim/memline.c", ["{", "  if (buf->b_ml.ml_mfp == NULL)                 /* not open */", "    return;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["{", "  if (buf->b_ml.ml_mfp == NULL)                 /* not open */", "    return;"], "readability/braces"]
["src/nvim/memline.c", ["    return;", "  mf_close(buf->b_ml.ml_mfp, del_file);       /* close the .swp file */", "  if (buf->b_ml.ml_line_lnum != 0 && (buf->b_ml.ml_flags & ML_LINE_DIRTY))"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  mf_close(buf->b_ml.ml_mfp, del_file);       /* close the .swp file */", "  if (buf->b_ml.ml_line_lnum != 0 && (buf->b_ml.ml_flags & ML_LINE_DIRTY))", "    xfree(buf->b_ml.ml_line_ptr);"], "readability/braces"]
["src/nvim/memline.c", ["", "  /* Reset the \"recovered\" flag, give the ATTENTION prompt the next time", "   * this buffer is loaded. */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Close all existing memlines and memfiles."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  }", "  spell_delete_wordlist();      /* delete the internal wordlist */", "  vim_deltempdir();             /* delete created temp directory */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  spell_delete_wordlist();      /* delete the internal wordlist */", "  vim_deltempdir();             /* delete created temp directory */", "}"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Close all memfiles for not modified buffers."], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (!bufIsChanged(buf)) {", "      ml_close(buf, TRUE);          /* close all not-modified buffers */", "    }"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (!bufIsChanged(buf)) {", "      ml_close(buf, TRUE);          /* close all not-modified buffers */", "    }"], "readability/bool"]
["src/nvim/memline.c", ["", "/*", " * Update the timestamp in the .swp file."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Update the timestamp or the B0_SAME_DIR flag of the .swp file."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  mfp = buf->b_ml.ml_mfp;", "  if (mfp == NULL || (hp = mf_get(mfp, 0, 1)) == NULL)", "    return;"], "readability/braces"]
["src/nvim/memline.c", ["", "/*", " * Write file name and timestamp into block 0 of a swap file."], "readability/old_style_comment"]
["src/nvim/memline.c", ["{", "  if (buf->b_ffname == NULL)", "    b0p->b0_fname[0] = NUL;"], "readability/braces"]
["src/nvim/memline.c", ["    b0p->b0_fname[0] = NUL;", "  else {", "    char uname[B0_UNAME_SIZE];"], "readability/braces"]
["src/nvim/memline.c", ["    b0p->b0_fname[0] = NUL;", "  else {", "    char uname[B0_UNAME_SIZE];"], "readability/braces"]
["src/nvim/memline.c", ["", "    /*", "     * For a file under the home directory of the current user, we try to"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    home_replace(NULL, buf->b_ffname, b0p->b0_fname,", "        B0_FNAME_SIZE_CRYPT, TRUE);", "    if (b0p->b0_fname[0] == '~') {"], "whitespace/alignment"]
["src/nvim/memline.c", ["    home_replace(NULL, buf->b_ffname, b0p->b0_fname,", "        B0_FNAME_SIZE_CRYPT, TRUE);", "    if (b0p->b0_fname[0] == '~') {"], "readability/bool"]
["src/nvim/memline.c", ["    if (b0p->b0_fname[0] == '~') {", "      /* If there is no user name or it is too long, don't use \"~/\" */", "      int retval = os_get_user_name(uname, B0_UNAME_SIZE);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /* Also add the 'fileencoding' if there is room. */", "  add_b0_fenc(b0p, curbuf);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Update the B0_SAME_DIR flag of the swap file.  It's set if the file and the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["{", "  if (same_directory(buf->b_ml.ml_mfp->mf_fname, buf->b_ffname))", "    b0p->b0_flags |= B0_SAME_DIR;"], "readability/braces"]
["src/nvim/memline.c", ["    b0p->b0_flags |= B0_SAME_DIR;", "  else", "    b0p->b0_flags &= ~B0_SAME_DIR;"], "readability/braces"]
["src/nvim/memline.c", ["", "/*", " * When there is room, add the 'fileencoding' to block zero."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  n = (int)STRLEN(buf->b_p_fenc);", "  if ((int)STRLEN(b0p->b0_fname) + n + 1 > size)", "    b0p->b0_flags &= ~B0_HAS_FENC;"], "readability/braces"]
["src/nvim/memline.c", ["    b0p->b0_flags &= ~B0_HAS_FENC;", "  else {", "    memmove((char *)b0p->b0_fname + size - n,"], "readability/braces"]
["src/nvim/memline.c", ["    b0p->b0_flags &= ~B0_HAS_FENC;", "  else {", "    memmove((char *)b0p->b0_fname + size - n,"], "readability/braces"]
["src/nvim/memline.c", ["    memmove((char *)b0p->b0_fname + size - n,", "        (char *)buf->b_p_fenc, (size_t)n);", "    *(b0p->b0_fname + size - n - 1) = NUL;"], "whitespace/alignment"]
["src/nvim/memline.c", ["  int called_from_main;", "  int serious_error = TRUE;", "  long mtime;"], "readability/bool"]
["src/nvim/memline.c", ["", "  recoverymode = TRUE;", "  called_from_main = (curbuf->b_ml.ml_mfp == NULL);"], "readability/bool"]
["src/nvim/memline.c", ["  fname = curbuf->b_fname;", "  if (fname == NULL)                /* When there is no file name */", "    fname = (char_u *)\"\";"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  fname = curbuf->b_fname;", "  if (fname == NULL)                /* When there is no file name */", "    fname = (char_u *)\"\";"], "readability/braces"]
["src/nvim/memline.c", ["      && ASCII_ISALPHA(fname[len - 1])) {", "    directly = TRUE;", "    fname_used = vim_strsave(fname);     /* make a copy for mf_open() */"], "readability/bool"]
["src/nvim/memline.c", ["    directly = TRUE;", "    fname_used = vim_strsave(fname);     /* make a copy for mf_open() */", "  } else {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  } else {", "    directly = FALSE;", ""], "readability/bool"]
["src/nvim/memline.c", ["", "    /* count the number of matching swap files */", "    len = recover_names(fname, FALSE, 0, NULL);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    /* count the number of matching swap files */", "    len = recover_names(fname, FALSE, 0, NULL);", "    if (len == 0) {                 /* no swap files found */"], "readability/bool"]
["src/nvim/memline.c", ["    len = recover_names(fname, FALSE, 0, NULL);", "    if (len == 0) {                 /* no swap files found */", "      EMSG2(_(\"E305: No swap file found for %s\"), fname);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    }", "    if (len == 1)                   /* one swap file found, use it */", "      i = 1;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    }", "    if (len == 1)                   /* one swap file found, use it */", "      i = 1;"], "readability/braces"]
["src/nvim/memline.c", ["      i = 1;", "    else {                          /* several swap files found, choose */", "      /* list the names of the swap files */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      i = 1;", "    else {                          /* several swap files found, choose */", "      /* list the names of the swap files */"], "readability/braces"]
["src/nvim/memline.c", ["      i = 1;", "    else {                          /* several swap files found, choose */", "      /* list the names of the swap files */"], "readability/braces"]
["src/nvim/memline.c", ["    else {                          /* several swap files found, choose */", "      /* list the names of the swap files */", "      (void)recover_names(fname, TRUE, 0, NULL);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      /* list the names of the swap files */", "      (void)recover_names(fname, TRUE, 0, NULL);", "      msg_putchar('\\n');"], "readability/bool"]
["src/nvim/memline.c", ["      MSG_PUTS(_(\"Enter number of swap file to use (0 to quit): \"));", "      i = get_number(FALSE, NULL);", "      if (i < 1 || i > len)"], "readability/bool"]
["src/nvim/memline.c", ["      i = get_number(FALSE, NULL);", "      if (i < 1 || i > len)", "        goto theend;"], "readability/braces"]
["src/nvim/memline.c", ["    }", "    /* get the swap file name that will be used */", "    (void)recover_names(fname, FALSE, i, &fname_used);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    /* get the swap file name that will be used */", "    (void)recover_names(fname, FALSE, i, &fname_used);", "  }"], "readability/bool"]
["src/nvim/memline.c", ["  }", "  if (fname_used == NULL)", "    goto theend;  // user chose invalid number."], "readability/braces"]
["src/nvim/memline.c", ["", "  /* When called from main() still need to initialize storage structure */", "  if (called_from_main && ml_open(curbuf) == FAIL)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  /* When called from main() still need to initialize storage structure */", "  if (called_from_main && ml_open(curbuf) == FAIL)", "    getout(1);"], "readability/braces"]
["src/nvim/memline.c", ["", "  /*", "   * Allocate a buffer structure for the swap file that is used for recovery."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * init fields in memline struct"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * open the memfile from the old swap file"], "readability/old_style_comment"]
["src/nvim/memline.c", ["   */", "  p = vim_strsave(fname_used);   /* save \"fname_used\" for the message:", "                                    mf_open() will consume \"fname_used\"! */"], "readability/multiline_comment"]
["src/nvim/memline.c", ["   */", "  p = vim_strsave(fname_used);   /* save \"fname_used\" for the message:", "                                    mf_open() will consume \"fname_used\"! */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  p = vim_strsave(fname_used);   /* save \"fname_used\" for the message:", "                                    mf_open() will consume \"fname_used\"! */", "  mfp = mf_open(fname_used, O_RDONLY);"], "whitespace/operators"]
["src/nvim/memline.c", ["", "  /*", "   * The page size set in mf_open() might be different from the page size"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * try to read block 0"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    MSG_PUTS_ATTR(_(", "            \"\\nMaybe no changes were made or Vim did not update the swap file.\"),", "        attr | MSG_HIST);"], "whitespace/indent"]
["src/nvim/memline.c", ["            \"\\nMaybe no changes were made or Vim did not update the swap file.\"),", "        attr | MSG_HIST);", "    msg_end();"], "whitespace/alignment"]
["src/nvim/memline.c", ["    MSG_PUTS_ATTR(_(", "            \"\\nMaybe no changes were made or Vim did not update the swap file.\"),", "        attr | MSG_HIST);"], "whitespace/line_length"]
["src/nvim/memline.c", ["    MSG_PUTS_ATTR(_(\" cannot be used with this version of Vim.\\n\"),", "        MSG_HIST);", "    MSG_PUTS_ATTR(_(\"Use Vim version 3.0.\\n\"), MSG_HIST);"], "whitespace/alignment"]
["src/nvim/memline.c", ["    MSG_PUTS_ATTR(_(\" cannot be used on this computer.\\n\"),", "        attr | MSG_HIST);", "    MSG_PUTS_ATTR(_(\"The file was created on \"), attr | MSG_HIST);"], "whitespace/alignment"]
["src/nvim/memline.c", ["    MSG_PUTS_ATTR(_(\"The file was created on \"), attr | MSG_HIST);", "    /* avoid going past the end of a corrupted hostname */", "    b0p->b0_fname[0] = NUL;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * If we guessed the wrong page size, we have to recalculate the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      MSG_PUTS_ATTR(_(", "              \" has been damaged (page size is smaller than minimum value).\\n\"),", "          attr | MSG_HIST);"], "whitespace/indent"]
["src/nvim/memline.c", ["              \" has been damaged (page size is smaller than minimum value).\\n\"),", "          attr | MSG_HIST);", "      msg_end();"], "whitespace/alignment"]
["src/nvim/memline.c", ["", "    /* need to reallocate the memory used to store the data */", "    p = xmalloc(mfp->mf_page_size);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * If .swp file name given directly, use name from swap file for buffer."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  home_replace(NULL, mfp->mf_fname, NameBuff, MAXPATHL, TRUE);", "  smsg(_(\"Using swap file \\\"%s\\\"\"), NameBuff);"], "readability/bool"]
["src/nvim/memline.c", ["", "  if (buf_spname(curbuf) != NULL)", "    STRLCPY(NameBuff, buf_spname(curbuf), MAXPATHL);"], "readability/braces"]
["src/nvim/memline.c", ["    STRLCPY(NameBuff, buf_spname(curbuf), MAXPATHL);", "  else", "    home_replace(NULL, curbuf->b_ffname, NameBuff, MAXPATHL, TRUE);"], "readability/braces"]
["src/nvim/memline.c", ["  else", "    home_replace(NULL, curbuf->b_ffname, NameBuff, MAXPATHL, TRUE);", "  smsg(_(\"Original file \\\"%s\\\"\"), NameBuff);"], "readability/bool"]
["src/nvim/memline.c", ["", "  /*", "   * check date of swap file and original file"], "readability/old_style_comment"]
["src/nvim/memline.c", ["           && org_file_info.stat.st_mtim.tv_sec", "              > swp_file_info.stat.st_mtim.tv_sec)", "          || org_file_info.stat.st_mtim.tv_sec != mtime)) {"], "whitespace/alignment"]
["src/nvim/memline.c", ["           && org_file_info.stat.st_mtim.tv_sec", "              > swp_file_info.stat.st_mtim.tv_sec)", "          || org_file_info.stat.st_mtim.tv_sec != mtime)) {"], "whitespace/alignment"]
["src/nvim/memline.c", ["", "  /* Get the 'fileformat' and 'fileencoding' from block zero. */", "  b0_ff = (b0p->b0_flags & B0_FF_MASK);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  mf_put(mfp, hp, false, false);        /* release block 0 */", "  hp = NULL;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Now that we are sure that the file is going to be recovered, clear the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Try reading the original file to obtain the values of 'fileformat',"], "readability/old_style_comment"]
["src/nvim/memline.c", ["   */", "  if (curbuf->b_ffname != NULL)", "    orig_file_status = readfile(curbuf->b_ffname, NULL, (linenr_T)0,"], "readability/braces"]
["src/nvim/memline.c", ["    orig_file_status = readfile(curbuf->b_ffname, NULL, (linenr_T)0,", "        (linenr_T)0, (linenr_T)MAXLNUM, NULL, READ_NEW);", ""], "whitespace/alignment"]
["src/nvim/memline.c", ["", "  /* Use the 'fileformat' and 'fileencoding' as stored in the swap file. */", "  if (b0_ff != 0)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  /* Use the 'fileformat' and 'fileencoding' as stored in the swap file. */", "  if (b0_ff != 0)", "    set_fileformat(b0_ff - 1, OPT_LOCAL);"], "readability/braces"]
["src/nvim/memline.c", ["", "  bnum = 1;             /* start with block 1 */", "  page_count = 1;       /* which is 1 page */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  bnum = 1;             /* start with block 1 */", "  page_count = 1;       /* which is 1 page */", "  lnum = 0;             /* append after line 0 in curbuf */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  page_count = 1;       /* which is 1 page */", "  lnum = 0;             /* append after line 0 in curbuf */", "  line_count = 0;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  line_count = 0;", "  idx = 0;              /* start with first index in block 1 */", "  error = 0;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  buf->b_ml.ml_stack = NULL;", "  buf->b_ml.ml_stack_size = 0;          /* no stack yet */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (curbuf->b_ffname == NULL)", "    cannot_open = TRUE;"], "readability/braces"]
["src/nvim/memline.c", ["  if (curbuf->b_ffname == NULL)", "    cannot_open = TRUE;", "  else"], "readability/bool"]
["src/nvim/memline.c", ["    cannot_open = TRUE;", "  else", "    cannot_open = FALSE;"], "readability/braces"]
["src/nvim/memline.c", ["  else", "    cannot_open = FALSE;", ""], "readability/bool"]
["src/nvim/memline.c", ["", "  serious_error = FALSE;", "  for (; !got_int; line_breakcheck()) {"], "readability/bool"]
["src/nvim/memline.c", ["  for (; !got_int; line_breakcheck()) {", "    if (hp != NULL)", "      mf_put(mfp, hp, false, false);            /* release previous block */"], "readability/braces"]
["src/nvim/memline.c", ["    if (hp != NULL)", "      mf_put(mfp, hp, false, false);            /* release previous block */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * get block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      }", "      ++error;", "      ml_append(lnum++, (char_u *)_(\"???MANY LINES MISSING\"),"], "readability/increment"]
["src/nvim/memline.c", ["      pp = hp->bh_data;", "      if (pp->pb_id == PTR_ID) {                /* it is a pointer block */", "        /* check line count when using pointer block first time */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      if (pp->pb_id == PTR_ID) {                /* it is a pointer block */", "        /* check line count when using pointer block first time */", "        if (idx == 0 && line_count != 0) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        if (idx == 0 && line_count != 0) {", "          for (i = 0; i < (int)pp->pb_count; ++i)", "            line_count -= pp->pb_pointer[i].pe_line_count;"], "readability/braces"]
["src/nvim/memline.c", ["        if (idx == 0 && line_count != 0) {", "          for (i = 0; i < (int)pp->pb_count; ++i)", "            line_count -= pp->pb_pointer[i].pe_line_count;"], "readability/increment"]
["src/nvim/memline.c", ["          if (line_count != 0) {", "            ++error;", "            ml_append(lnum++, (char_u *)_(\"???LINE COUNT WRONG\"),"], "readability/increment"]
["src/nvim/memline.c", ["          if (pp->pb_pointer[idx].pe_bnum < 0) {", "            /*", "             * Data block with negative block number."], "readability/old_style_comment"]
["src/nvim/memline.c", ["            if (cannot_open) {", "              ++error;", "              ml_append(lnum++, (char_u *)_(\"???LINES MISSING\"),"], "readability/increment"]
["src/nvim/memline.c", ["            }", "            ++idx;                  /* get same block again for next index */", "            continue;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["            }", "            ++idx;                  /* get same block again for next index */", "            continue;"], "readability/increment"]
["src/nvim/memline.c", ["", "          /*", "           * going one block deeper in the tree"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        }", "      } else {            /* not a pointer block */", "        dp = hp->bh_data;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        dp = hp->bh_data;", "        if (dp->db_id != DATA_ID) {             /* block id wrong */", "          if (bnum == 1) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["            EMSG2(_(\"E310: Block 1 ID wrong (%s not a .swp file?)\"),", "                mfp->mf_fname);", "            goto theend;"], "whitespace/alignment"]
["src/nvim/memline.c", ["          }", "          ++error;", "          ml_append(lnum++, (char_u *)_(\"???BLOCK MISSING\"),"], "readability/increment"]
["src/nvim/memline.c", ["", "          /* make sure there is a NUL at the end of the block */", "          *((char_u *)dp + dp->db_txt_end - 1) = NUL;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "          /*", "           * check number of lines in block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "          for (i = 0; i < dp->db_line_count; ++i) {", "            txt_start = (dp->db_index[i] & DB_INDEX_MASK);"], "readability/increment"]
["src/nvim/memline.c", ["              p = (char_u *)\"???\";", "              ++error;", "            } else"], "readability/increment"]
["src/nvim/memline.c", ["              ++error;", "            } else", "              p = (char_u *)dp + txt_start;"], "readability/braces"]
["src/nvim/memline.c", ["", "    if (buf->b_ml.ml_stack_top == 0)            /* finished */", "      break;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    if (buf->b_ml.ml_stack_top == 0)            /* finished */", "      break;"], "readability/braces"]
["src/nvim/memline.c", ["", "    /*", "     * go one block up in the tree"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    bnum = ip->ip_bnum;", "    idx = ip->ip_index + 1;         /* go to next index */", "    page_count = 1;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Compare the buffer contents with the original file.  When they differ"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if (orig_file_status != OK || curbuf->b_ml.ml_line_count != lnum * 2 + 1) {", "    /* Recovering an empty file results in two lines and the first line is", "     * empty.  Don't set the modified flag then. */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  } else {", "    for (idx = 1; idx <= lnum; ++idx) {", "      /* Need to copy one line, fetching the other one may flush it. */"], "readability/increment"]
["src/nvim/memline.c", ["    for (idx = 1; idx <= lnum; ++idx) {", "      /* Need to copy one line, fetching the other one may flush it. */", "      p = vim_strsave(ml_get(idx));"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Delete the lines from the original file and the dummy line from the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["   */", "  while (curbuf->b_ml.ml_line_count > lnum", "         && !(curbuf->b_ml.ml_flags & ML_EMPTY))"], "readability/braces"]
["src/nvim/memline.c", ["", "  recoverymode = FALSE;", "  if (got_int)"], "readability/bool"]
["src/nvim/memline.c", ["  recoverymode = FALSE;", "  if (got_int)", "    EMSG(_(\"E311: Recovery Interrupted\"));"], "readability/braces"]
["src/nvim/memline.c", ["    EMSG(_(\"E311: Recovery Interrupted\"));", "  else if (error) {", "    ++no_wait_return;"], "readability/braces"]
["src/nvim/memline.c", ["  else if (error) {", "    ++no_wait_return;", "    MSG(\">>>>>>>>>>>>>\");"], "readability/increment"]
["src/nvim/memline.c", ["    EMSG(_(", "            \"E312: Errors detected while recovering; look for lines starting with ???\"));", "    --no_wait_return;"], "whitespace/indent"]
["src/nvim/memline.c", ["    EMSG(_(", "            \"E312: Errors detected while recovering; look for lines starting with ???\"));", "    --no_wait_return;"], "whitespace/line_length"]
["src/nvim/memline.c", ["            \"E312: Errors detected while recovering; look for lines starting with ???\"));", "    --no_wait_return;", "    MSG(_(\"See \\\":help E312\\\" for more information.\"));"], "readability/increment"]
["src/nvim/memline.c", ["      MSG_PUTS(_(", "              \"\\n(You might want to write out this file under another name\\n\"));", "      MSG_PUTS(_(\"and run diff with the original file to check for changes)\"));"], "whitespace/indent"]
["src/nvim/memline.c", ["      MSG_PUTS(_(\"and run diff with the original file to check for changes)\"));", "    } else", "      MSG(_(\"Recovery completed. Buffer contents equals file contents.\"));"], "readability/braces"]
["src/nvim/memline.c", ["  xfree(fname_used);", "  recoverymode = FALSE;", "  if (mfp != NULL) {"], "readability/bool"]
["src/nvim/memline.c", ["  if (mfp != NULL) {", "    if (hp != NULL)", "      mf_put(mfp, hp, false, false);"], "readability/braces"]
["src/nvim/memline.c", ["      mf_put(mfp, hp, false, false);", "    mf_close(mfp, false);           /* will also xfree(mfp->mf_fname) */", "  }"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  }", "  if (buf != NULL) {  //may be NULL if swap file not found.", "    xfree(buf->b_ml.ml_stack);"], "whitespace/comments"]
["src/nvim/memline.c", ["  }", "  if (serious_error && called_from_main)", "    ml_close(curbuf, TRUE);"], "readability/braces"]
["src/nvim/memline.c", ["  if (serious_error && called_from_main)", "    ml_close(curbuf, TRUE);", "  else {"], "readability/bool"]
["src/nvim/memline.c", ["    ml_close(curbuf, TRUE);", "  else {", "    apply_autocmds(EVENT_BUFREADPOST, NULL, curbuf->b_fname, FALSE, curbuf);"], "readability/braces"]
["src/nvim/memline.c", ["    ml_close(curbuf, TRUE);", "  else {", "    apply_autocmds(EVENT_BUFREADPOST, NULL, curbuf->b_fname, FALSE, curbuf);"], "readability/braces"]
["src/nvim/memline.c", ["  else {", "    apply_autocmds(EVENT_BUFREADPOST, NULL, curbuf->b_fname, FALSE, curbuf);", "    apply_autocmds(EVENT_BUFWINENTER, NULL, curbuf->b_fname, FALSE, curbuf);"], "readability/bool"]
["src/nvim/memline.c", ["    apply_autocmds(EVENT_BUFREADPOST, NULL, curbuf->b_fname, FALSE, curbuf);", "    apply_autocmds(EVENT_BUFWINENTER, NULL, curbuf->b_fname, FALSE, curbuf);", "  }"], "readability/bool"]
["src/nvim/memline.c", ["", "/*", " * Find the names of swap files in current directory and the directory given"], "readability/old_style_comment"]
["src/nvim/memline.c", [" */", "int ", "recover_names ("], "whitespace/end_of_line"]
["src/nvim/memline.c", ["int ", "recover_names (", "    char_u *fname,             /* base for swap file name */"], "whitespace/parens"]
["src/nvim/memline.c", ["recover_names (", "    char_u *fname,             /* base for swap file name */", "    int list,                       /* when TRUE, list the swap file names */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    char_u *fname,             /* base for swap file name */", "    int list,                       /* when TRUE, list the swap file names */", "    int nr,                         /* when non-zero, return nr'th swap file name */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    int list,                       /* when TRUE, list the swap file names */", "    int nr,                         /* when non-zero, return nr'th swap file name */", "    char_u **fname_out        /* result when \"nr\" > 0 */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    int list,                       /* when TRUE, list the swap file names */", "    int nr,                         /* when non-zero, return nr'th swap file name */", "    char_u **fname_out        /* result when \"nr\" > 0 */"], "whitespace/line_length"]
["src/nvim/memline.c", ["    int nr,                         /* when non-zero, return nr'th swap file name */", "    char_u **fname_out        /* result when \"nr\" > 0 */", ")"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#ifdef HAVE_READLINK", "    /* Expand symlink in the file name, because the swap file is created", "     * with the actual file instead of with the symlink. */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["     * with the actual file instead of with the symlink. */", "    if (resolve_symlink(fname, fname_buf) == OK)", "      fname_res = fname_buf;"], "readability/braces"]
["src/nvim/memline.c", ["      fname_res = fname_buf;", "    else", "#endif"], "readability/braces"]
["src/nvim/memline.c", ["  if (list) {", "    /* use msg() to start the scrolling properly */", "    msg((char_u *)_(\"Swap files found:\"));"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    if (dir_name[0] == '.' && dir_name[1] == NUL) {     /* check current dir */", "      if (fname == NULL) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        names[0] = vim_strsave((char_u *)\"*.sw?\");", "        /* For Unix names starting with a dot are special.  MS-Windows", "         * supports this too, on some file systems. */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        num_names = 3;", "      } else", "        num_names = recov_file_names(names, fname_res, TRUE);"], "readability/braces"]
["src/nvim/memline.c", ["      } else", "        num_names = recov_file_names(names, fname_res, TRUE);", "    } else {                      /* check directory dir_name */"], "readability/bool"]
["src/nvim/memline.c", ["        num_names = recov_file_names(names, fname_res, TRUE);", "    } else {                      /* check directory dir_name */", "      if (fname == NULL) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      if (fname == NULL) {", "        names[0] = (char_u *)concat_fnames((char *)dir_name, \"*.sw?\", TRUE);", "        /* For Unix names starting with a dot are special.  MS-Windows"], "readability/bool"]
["src/nvim/memline.c", ["        names[0] = (char_u *)concat_fnames((char *)dir_name, \"*.sw?\", TRUE);", "        /* For Unix names starting with a dot are special.  MS-Windows", "         * supports this too, on some file systems. */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["         * supports this too, on some file systems. */", "        names[1] = (char_u *)concat_fnames((char *)dir_name, \".*.sw?\", TRUE);", "        names[2] = (char_u *)concat_fnames((char *)dir_name, \".sw?\", TRUE);"], "readability/bool"]
["src/nvim/memline.c", ["        names[1] = (char_u *)concat_fnames((char *)dir_name, \".*.sw?\", TRUE);", "        names[2] = (char_u *)concat_fnames((char *)dir_name, \".sw?\", TRUE);", "        num_names = 3;"], "readability/bool"]
["src/nvim/memline.c", ["          tail = path_tail(fname_res);", "          tail = (char_u *)concat_fnames((char *)dir_name, (char *)tail, TRUE);", "        }"], "readability/bool"]
["src/nvim/memline.c", ["        }", "        num_names = recov_file_names(names, tail, FALSE);", "        xfree(tail);"], "readability/bool"]
["src/nvim/memline.c", ["", "    if (num_names == 0)", "      num_files = 0;"], "readability/braces"]
["src/nvim/memline.c", ["      num_files = 0;", "    else if (expand_wildcards(num_names, names, &num_files, &files,", "                 EW_KEEPALL|EW_FILE|EW_SILENT) == FAIL)"], "readability/braces"]
["src/nvim/memline.c", ["    else if (expand_wildcards(num_names, names, &num_files, &files,", "                 EW_KEEPALL|EW_FILE|EW_SILENT) == FAIL)", "      num_files = 0;"], "whitespace/alignment"]
["src/nvim/memline.c", ["", "    /*", "     * When no swap file found, wildcard expansion might have failed (e.g."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * remove swapfile name of the current buffer, it must be ignored"], "readability/old_style_comment"]
["src/nvim/memline.c", ["          xfree(files[i]);", "          if (--num_files == 0)", "            xfree(files);"], "readability/braces"]
["src/nvim/memline.c", ["            xfree(files);", "          else", "            for (; i < num_files; ++i)"], "readability/braces"]
["src/nvim/memline.c", ["          else", "            for (; i < num_files; ++i)", "              files[i] = files[i + 1];"], "readability/braces"]
["src/nvim/memline.c", ["          else", "            for (; i < num_files; ++i)", "              files[i] = files[i + 1];"], "readability/increment"]
["src/nvim/memline.c", ["            files[nr - 1 + num_files - file_count]);", "        dirp = (char_u *)\"\";                        /* stop searching */", "      }"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      if (dir_name[0] == '.' && dir_name[1] == NUL) {", "        if (fname == NULL)", "          MSG_PUTS(_(\"   In current directory:\\n\"));"], "readability/braces"]
["src/nvim/memline.c", ["          MSG_PUTS(_(\"   In current directory:\\n\"));", "        else", "          MSG_PUTS(_(\"   Using specified name:\\n\"));"], "readability/braces"]
["src/nvim/memline.c", ["      if (num_files) {", "        for (int i = 0; i < num_files; ++i) {", "          /* print the swap file name */"], "readability/increment"]
["src/nvim/memline.c", ["        for (int i = 0; i < num_files; ++i) {", "          /* print the swap file name */", "          msg_outnum((long)++file_count);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        }", "      } else", "        MSG_PUTS(_(\"      -- none --\\n\"));"], "readability/braces"]
["src/nvim/memline.c", ["      ui_flush();", "    } else", "      file_count += num_files;"], "readability/braces"]
["src/nvim/memline.c", ["", "    for (int i = 0; i < num_names; ++i)", "      xfree(names[i]);"], "readability/braces"]
["src/nvim/memline.c", ["", "    for (int i = 0; i < num_names; ++i)", "      xfree(names[i]);"], "readability/increment"]
["src/nvim/memline.c", ["      xfree(names[i]);", "    if (num_files > 0)", "      FreeWild(num_files, files);"], "readability/braces"]
["src/nvim/memline.c", ["", "/*", " * Append the full path to name with path separators made into percent"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    }", "    d = concat_fnames(dir, s, TRUE);", "    xfree(s);"], "readability/bool"]
["src/nvim/memline.c", ["      MSG_PUTS(_(\"   dated: \"));", "    } else", "#endif"], "readability/braces"]
["src/nvim/memline.c", ["", "  /*", "   * print the original file name"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        MSG_PUTS(_(\"         file name: \"));", "        if (b0.b0_fname[0] == NUL)", "          MSG_PUTS(_(\"[No Name]\"));"], "readability/braces"]
["src/nvim/memline.c", ["          MSG_PUTS(_(\"[No Name]\"));", "        else", "          msg_outtrans(b0.b0_fname);"], "readability/braces"]
["src/nvim/memline.c", ["        if (*(b0.b0_hname) != NUL) {", "          if (*(b0.b0_uname) != NUL)", "            MSG_PUTS(_(\"   host name: \"));"], "readability/braces"]
["src/nvim/memline.c", ["            MSG_PUTS(_(\"   host name: \"));", "          else", "            MSG_PUTS(_(\"\\n         host name: \"));"], "readability/braces"]
["src/nvim/memline.c", ["      }", "    } else", "      MSG_PUTS(_(\"         [cannot be read]\"));"], "readability/braces"]
["src/nvim/memline.c", ["    close(fd);", "  } else", "    MSG_PUTS(_(\"         [cannot be opened]\"));"], "readability/braces"]
["src/nvim/memline.c", ["  // Form the normal swap file name pattern by appending \".sw?\".", "  names[num_names] = (char_u *)concat_fnames((char *)path, \".sw?\", FALSE);", "  if (num_names >= 1) {     /* check if we have the same name twice */"], "readability/bool"]
["src/nvim/memline.c", ["  names[num_names] = (char_u *)concat_fnames((char *)path, \".sw?\", FALSE);", "  if (num_names >= 1) {     /* check if we have the same name twice */", "    char_u *p = names[num_names - 1];"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    int i = (int)STRLEN(names[num_names - 1]) - (int)STRLEN(names[num_names]);", "    if (i > 0)", "      p += i;               /* file name has been expanded to full path */"], "readability/braces"]
["src/nvim/memline.c", ["    if (i > 0)", "      p += i;               /* file name has been expanded to full path */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    if (STRCMP(p, names[num_names]) != 0)", "      ++num_names;"], "readability/braces"]
["src/nvim/memline.c", ["    if (STRCMP(p, names[num_names]) != 0)", "      ++num_names;", "    else"], "readability/increment"]
["src/nvim/memline.c", ["      ++num_names;", "    else", "      xfree(names[num_names]);"], "readability/braces"]
["src/nvim/memline.c", ["      xfree(names[num_names]);", "  } else", "    ++num_names;"], "readability/braces"]
["src/nvim/memline.c", ["  } else", "    ++num_names;", ""], "readability/increment"]
["src/nvim/memline.c", ["", "/*", " * sync all memlines"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  FOR_ALL_BUFFERS(buf) {", "    if (buf->b_ml.ml_mfp == NULL || buf->b_ml.ml_mfp->mf_fname == NULL)", "      continue;                             /* no file */"], "readability/braces"]
["src/nvim/memline.c", ["    if (buf->b_ml.ml_mfp == NULL || buf->b_ml.ml_mfp->mf_fname == NULL)", "      continue;                             /* no file */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    ml_flush_line(buf);                     /* flush buffered line */", "                                            /* flush locked block */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    ml_flush_line(buf);                     /* flush buffered line */", "                                            /* flush locked block */", "    (void)ml_find_line(buf, (linenr_T)0, ML_FLUSH);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        && buf->b_ffname != NULL) {", "      /*", "       * If the original file does not exist anymore or has been changed"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * sync one buffer, including negative blocks"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if (mfp == NULL || mfp->mf_fname == NULL) {", "    if (message)", "      EMSG(_(\"E313: Cannot preserve, there is no swap file\"));"], "readability/braces"]
["src/nvim/memline.c", ["", "  /* We only want to stop when interrupted here, not when interrupted", "   * before. */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["   * before. */", "  got_int = FALSE;", ""], "readability/bool"]
["src/nvim/memline.c", ["", "  /* stack is invalid after mf_sync(.., MFS_ALL) */", "  buf->b_ml.ml_stack_top = 0;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Some of the data blocks may have been changed from negative to"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if (message) {", "    if (status == OK)", "      MSG(_(\"File preserved\"));"], "readability/braces"]
["src/nvim/memline.c", ["      MSG(_(\"File preserved\"));", "    else", "      EMSG(_(\"E314: Preserve failed\"));"], "readability/braces"]
["src/nvim/memline.c", ["", "/*", " * NOTE: The pointer returned by the ml_get_*() functions only remains valid"], "readability/old_style_comment"]
["src/nvim/memline.c", [" */", "/*", " * Return a pointer to a (read-only copy of a) line."], "readability/old_style_comment"]
["src/nvim/memline.c", ["{", "  return ml_get_buf(curbuf, lnum, FALSE);", "}"], "readability/bool"]
["src/nvim/memline.c", ["", "/*", " * Return pointer to position \"pos\"."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Return a pointer to a line in a specific buffer"], "readability/old_style_comment"]
["src/nvim/memline.c", ["char_u *", "ml_get_buf (", "    buf_T *buf,"], "whitespace/parens"]
["src/nvim/memline.c", ["", "  if (lnum > buf->b_ml.ml_line_count) { /* invalid line number */", "    if (recursive == 0) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  }", "  if (lnum <= 0)                        /* pretend line 0 is line 1 */", "    lnum = 1;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  }", "  if (lnum <= 0)                        /* pretend line 0 is line 1 */", "    lnum = 1;"], "readability/braces"]
["src/nvim/memline.c", ["", "  if (buf->b_ml.ml_mfp == NULL)         /* there are no lines */", "    return (char_u *)\"\";"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (buf->b_ml.ml_mfp == NULL)         /* there are no lines */", "    return (char_u *)\"\";"], "readability/braces"]
["src/nvim/memline.c", ["", "  /*", "   * See if it is the same line as requested last time."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * Find the data block containing the line."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Check if a line that was just obtained by a call to ml_get"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Append a line after lnum (may be 0 to insert a line in front of the file)."], "readability/old_style_comment"]
["src/nvim/memline.c", ["{", "  /* When starting up, we might still need to create the memfile */", "  if (curbuf->b_ml.ml_mfp == NULL && open_buffer(FALSE, NULL, 0) == FAIL)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  /* When starting up, we might still need to create the memfile */", "  if (curbuf->b_ml.ml_mfp == NULL && open_buffer(FALSE, NULL, 0) == FAIL)", "    return FAIL;"], "readability/braces"]
["src/nvim/memline.c", ["  /* When starting up, we might still need to create the memfile */", "  if (curbuf->b_ml.ml_mfp == NULL && open_buffer(FALSE, NULL, 0) == FAIL)", "    return FAIL;"], "readability/bool"]
["src/nvim/memline.c", ["", "  if (curbuf->b_ml.ml_line_lnum != 0)", "    ml_flush_line(curbuf);"], "readability/braces"]
["src/nvim/memline.c", ["    ml_flush_line(curbuf);", "  return ml_append_int(curbuf, lnum, line, len, newfile, FALSE);", "}"], "readability/bool"]
["src/nvim/memline.c", ["", "/*", " * Like ml_append() but for an arbitrary buffer.  The buffer must already have"], "readability/old_style_comment"]
["src/nvim/memline.c", ["{", "  if (buf->b_ml.ml_mfp == NULL)", "    return FAIL;"], "readability/braces"]
["src/nvim/memline.c", ["", "  if (buf->b_ml.ml_line_lnum != 0)", "    ml_flush_line(buf);"], "readability/braces"]
["src/nvim/memline.c", ["    ml_flush_line(buf);", "  return ml_append_int(buf, lnum, line, len, newfile, FALSE);", "}"], "readability/bool"]
["src/nvim/memline.c", ["  int i;", "  int line_count;               /* number of indexes in current block */", "  int offset;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  int from, to;", "  int space_needed;             /* space needed for new line */", "  int page_size;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  int page_count;", "  int db_idx;                   /* index for lnum in data block */", "  bhdr_T      *hp;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /* lnum out of range */", "  if (lnum > buf->b_ml.ml_line_count || buf->b_ml.ml_mfp == NULL)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  /* lnum out of range */", "  if (lnum > buf->b_ml.ml_line_count || buf->b_ml.ml_mfp == NULL)", "    return FAIL;"], "readability/braces"]
["src/nvim/memline.c", ["", "  if (lowest_marked && lowest_marked > lnum)", "    lowest_marked = lnum + 1;"], "readability/braces"]
["src/nvim/memline.c", ["", "  if (len == 0)", "    len = (colnr_T)STRLEN(line) + 1;            /* space needed for the text */"], "readability/braces"]
["src/nvim/memline.c", ["  if (len == 0)", "    len = (colnr_T)STRLEN(line) + 1;            /* space needed for the text */", "  space_needed = len + INDEX_SIZE;      /* space needed for text + index */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    len = (colnr_T)STRLEN(line) + 1;            /* space needed for the text */", "  space_needed = len + INDEX_SIZE;      /* space needed for text + index */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * find the data block containing the previous line"], "readability/old_style_comment"]
["src/nvim/memline.c", ["   */", "  if ((hp = ml_find_line(buf, lnum == 0 ? (linenr_T)1 : lnum,", "           ML_INSERT)) == NULL)"], "readability/braces"]
["src/nvim/memline.c", ["  if ((hp = ml_find_line(buf, lnum == 0 ? (linenr_T)1 : lnum,", "           ML_INSERT)) == NULL)", "    return FAIL;"], "whitespace/alignment"]
["src/nvim/memline.c", ["", "  if (lnum == 0)                /* got line one instead, correct db_idx */", "    db_idx = -1;                /* careful, it is negative! */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (lnum == 0)                /* got line one instead, correct db_idx */", "    db_idx = -1;                /* careful, it is negative! */"], "readability/braces"]
["src/nvim/memline.c", ["  if (lnum == 0)                /* got line one instead, correct db_idx */", "    db_idx = -1;                /* careful, it is negative! */", "  else"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    db_idx = -1;                /* careful, it is negative! */", "  else", "    db_idx = lnum - buf->b_ml.ml_locked_low;"], "readability/braces"]
["src/nvim/memline.c", ["    db_idx = lnum - buf->b_ml.ml_locked_low;", "  /* get line count before the insertion */", "  line_count = buf->b_ml.ml_locked_high - buf->b_ml.ml_locked_low;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * If"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      && lnum < buf->b_ml.ml_line_count) {", "    /*", "     * Now that the line is not going to be inserted in the block that we"], "readability/old_style_comment"]
["src/nvim/memline.c", ["     */", "    --(buf->b_ml.ml_locked_lineadd);", "    --(buf->b_ml.ml_locked_high);"], "readability/increment"]
["src/nvim/memline.c", ["    --(buf->b_ml.ml_locked_lineadd);", "    --(buf->b_ml.ml_locked_high);", "    if ((hp = ml_find_line(buf, lnum + 1, ML_INSERT)) == NULL)"], "readability/increment"]
["src/nvim/memline.c", ["    --(buf->b_ml.ml_locked_high);", "    if ((hp = ml_find_line(buf, lnum + 1, ML_INSERT)) == NULL)", "      return FAIL;"], "readability/braces"]
["src/nvim/memline.c", ["", "    db_idx = -1;                    /* careful, it is negative! */", "    /* get line count before the insertion */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    db_idx = -1;                    /* careful, it is negative! */", "    /* get line count before the insertion */", "    line_count = buf->b_ml.ml_locked_high - buf->b_ml.ml_locked_low;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  ++buf->b_ml.ml_line_count;", ""], "readability/increment"]
["src/nvim/memline.c", ["", "  if ((int)dp->db_free >= space_needed) {       /* enough room in data block */", "    /*"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if ((int)dp->db_free >= space_needed) {       /* enough room in data block */", "    /*", "     * Insert new line in existing data block, or in data block allocated above."], "readability/old_style_comment"]
["src/nvim/memline.c", ["    dp->db_free -= space_needed;", "    ++(dp->db_line_count);", ""], "readability/increment"]
["src/nvim/memline.c", ["", "    /*", "     * move the text of the lines that follow to the front"], "readability/old_style_comment"]
["src/nvim/memline.c", ["     */", "    if (line_count > db_idx + 1) {          /* if there are following lines */", "      /*"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (line_count > db_idx + 1) {          /* if there are following lines */", "      /*", "       * Offset is the start of the previous line."], "readability/old_style_comment"]
["src/nvim/memline.c", ["       */", "      if (db_idx < 0)", "        offset = dp->db_txt_end;"], "readability/braces"]
["src/nvim/memline.c", ["        offset = dp->db_txt_end;", "      else", "        offset = ((dp->db_index[db_idx]) & DB_INDEX_MASK);"], "readability/braces"]
["src/nvim/memline.c", ["      memmove((char *)dp + dp->db_txt_start,", "          (char *)dp + dp->db_txt_start + len,", "          (size_t)(offset - (dp->db_txt_start + len)));"], "whitespace/alignment"]
["src/nvim/memline.c", ["          (char *)dp + dp->db_txt_start + len,", "          (size_t)(offset - (dp->db_txt_start + len)));", "      for (i = line_count - 1; i > db_idx; --i)"], "whitespace/alignment"]
["src/nvim/memline.c", ["          (size_t)(offset - (dp->db_txt_start + len)));", "      for (i = line_count - 1; i > db_idx; --i)", "        dp->db_index[i + 1] = dp->db_index[i] - len;"], "readability/braces"]
["src/nvim/memline.c", ["          (size_t)(offset - (dp->db_txt_start + len)));", "      for (i = line_count - 1; i > db_idx; --i)", "        dp->db_index[i + 1] = dp->db_index[i] - len;"], "readability/increment"]
["src/nvim/memline.c", ["      dp->db_index[db_idx + 1] = offset - len;", "    } else                                  /* add line at the end */", "      dp->db_index[db_idx + 1] = dp->db_txt_start;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      dp->db_index[db_idx + 1] = offset - len;", "    } else                                  /* add line at the end */", "      dp->db_index[db_idx + 1] = dp->db_txt_start;"], "readability/braces"]
["src/nvim/memline.c", ["", "    /*", "     * copy the text into the block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    memmove((char *)dp + dp->db_index[db_idx + 1], line, (size_t)len);", "    if (mark)", "      dp->db_index[db_idx + 1] |= DB_MARKED;"], "readability/braces"]
["src/nvim/memline.c", ["", "    /*", "     * Mark the block dirty."], "readability/old_style_comment"]
["src/nvim/memline.c", ["    buf->b_ml.ml_flags |= ML_LOCKED_DIRTY;", "    if (!newfile)", "      buf->b_ml.ml_flags |= ML_LOCKED_POS;"], "readability/braces"]
["src/nvim/memline.c", ["      buf->b_ml.ml_flags |= ML_LOCKED_POS;", "  } else {        /* not enough space in data block */", "    /*"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  } else {        /* not enough space in data block */", "    /*", "     * If there is not enough room we have to create a new data block and copy some"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    int lines_moved;", "    int data_moved = 0;                     /* init to shut up gcc */", "    int total_moved = 0;                    /* init to shut up gcc */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    int data_moved = 0;                     /* init to shut up gcc */", "    int total_moved = 0;                    /* init to shut up gcc */", "    DATA_BL     *dp_right, *dp_left;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * We are going to allocate a new data block. Depending on the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["     */", "    if (db_idx < 0) {           /* left block is new, right block is existing */", "      lines_moved = 0;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      lines_moved = 0;", "      in_left = TRUE;", "      /* space_needed does not change */"], "readability/bool"]
["src/nvim/memline.c", ["      in_left = TRUE;", "      /* space_needed does not change */", "    } else {                  /* left block is existing, right block is new */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      /* space_needed does not change */", "    } else {                  /* left block is existing, right block is new */", "      lines_moved = line_count - db_idx - 1;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      lines_moved = line_count - db_idx - 1;", "      if (lines_moved == 0)", "        in_left = FALSE;                /* put new line in right block */"], "readability/braces"]
["src/nvim/memline.c", ["      if (lines_moved == 0)", "        in_left = FALSE;                /* put new line in right block */", "                                        /* space_needed does not change */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      if (lines_moved == 0)", "        in_left = FALSE;                /* put new line in right block */", "                                        /* space_needed does not change */"], "readability/bool"]
["src/nvim/memline.c", ["        in_left = FALSE;                /* put new line in right block */", "                                        /* space_needed does not change */", "      else {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["                                        /* space_needed does not change */", "      else {", "        data_moved = ((dp->db_index[db_idx]) & DB_INDEX_MASK) -"], "readability/braces"]
["src/nvim/memline.c", ["                                        /* space_needed does not change */", "      else {", "        data_moved = ((dp->db_index[db_idx]) & DB_INDEX_MASK) -"], "readability/braces"]
["src/nvim/memline.c", ["        if ((int)dp->db_free + total_moved >= space_needed) {", "          in_left = TRUE;               /* put new line in left block */", "          space_needed = total_moved;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        if ((int)dp->db_free + total_moved >= space_needed) {", "          in_left = TRUE;               /* put new line in left block */", "          space_needed = total_moved;"], "readability/bool"]
["src/nvim/memline.c", ["        } else {", "          in_left = FALSE;                  /* put new line in right block */", "          space_needed += total_moved;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        } else {", "          in_left = FALSE;                  /* put new line in right block */", "          space_needed += total_moved;"], "readability/bool"]
["src/nvim/memline.c", ["    hp_new = ml_new_data(mfp, newfile, page_count);", "    if (db_idx < 0) {           /* left block is new */", "      hp_left = hp_new;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      line_count_right = line_count;", "    } else {                  /* right block is new */", "      hp_left = hp;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * May move the new line into the right/new block."], "readability/old_style_comment"]
["src/nvim/memline.c", ["      dp_right->db_index[0] = dp_right->db_txt_start;", "      if (mark)", "        dp_right->db_index[0] |= DB_MARKED;"], "readability/braces"]
["src/nvim/memline.c", ["      memmove((char *)dp_right + dp_right->db_txt_start,", "          line, (size_t)len);", "      ++line_count_right;"], "whitespace/alignment"]
["src/nvim/memline.c", ["          line, (size_t)len);", "      ++line_count_right;", "    }"], "readability/increment"]
["src/nvim/memline.c", ["    }", "    /*", "     * may move lines from the left/old block to the right/new one."], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (lines_moved) {", "      /*", "       */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      memmove((char *)dp_right + dp_right->db_txt_start,", "          (char *)dp_left + dp_left->db_txt_start,", "          (size_t)data_moved);"], "whitespace/alignment"]
["src/nvim/memline.c", ["          (char *)dp_left + dp_left->db_txt_start,", "          (size_t)data_moved);", "      offset = dp_right->db_txt_start - dp_left->db_txt_start;"], "whitespace/alignment"]
["src/nvim/memline.c", ["", "      /*", "       * update indexes in the new block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["       */", "      for (to = line_count_right, from = db_idx + 1;", "           from < line_count_left; ++from, ++to)"], "readability/braces"]
["src/nvim/memline.c", ["      for (to = line_count_right, from = db_idx + 1;", "           from < line_count_left; ++from, ++to)", "        dp_right->db_index[to] = dp->db_index[from] + offset;"], "readability/increment"]
["src/nvim/memline.c", ["", "    /*", "     * May move the new line into the left (old or new) block."], "readability/old_style_comment"]
["src/nvim/memline.c", ["      dp_left->db_index[line_count_left] = dp_left->db_txt_start;", "      if (mark)", "        dp_left->db_index[line_count_left] |= DB_MARKED;"], "readability/braces"]
["src/nvim/memline.c", ["      memmove((char *)dp_left + dp_left->db_txt_start,", "          line, (size_t)len);", "      ++line_count_left;"], "whitespace/alignment"]
["src/nvim/memline.c", ["          line, (size_t)len);", "      ++line_count_left;", "    }"], "readability/increment"]
["src/nvim/memline.c", ["", "    if (db_idx < 0) {           /* left block is new */", "      lnum_left = lnum + 1;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      lnum_right = 0;", "    } else {                  /* right block is new */", "      lnum_left = 0;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      lnum_left = 0;", "      if (in_left)", "        lnum_right = lnum + 2;"], "readability/braces"]
["src/nvim/memline.c", ["        lnum_right = lnum + 2;", "      else", "        lnum_right = lnum + 1;"], "readability/braces"]
["src/nvim/memline.c", ["", "    /*", "     * release the two data blocks"], "readability/old_style_comment"]
["src/nvim/memline.c", ["     */", "    if (lines_moved || in_left)", "      buf->b_ml.ml_flags |= ML_LOCKED_DIRTY;"], "readability/braces"]
["src/nvim/memline.c", ["      buf->b_ml.ml_flags |= ML_LOCKED_DIRTY;", "    if (!newfile && db_idx >= 0 && in_left)", "      buf->b_ml.ml_flags |= ML_LOCKED_POS;"], "readability/braces"]
["src/nvim/memline.c", ["", "    /*", "     * flush the old data block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    buf->b_ml.ml_locked_lineadd = 0;", "    ml_find_line(buf, (linenr_T)0, ML_FLUSH);       /* flush data block */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * update pointer blocks for the new data block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    for (stack_idx = buf->b_ml.ml_stack_top - 1; stack_idx >= 0;", "         --stack_idx) {", "      ip = &(buf->b_ml.ml_stack[stack_idx]);"], "readability/increment"]
["src/nvim/memline.c", ["      pb_idx = ip->ip_index;", "      if ((hp = mf_get(mfp, ip->ip_bnum, 1)) == NULL)", "        return FAIL;"], "readability/braces"]
["src/nvim/memline.c", ["        return FAIL;", "      pp = hp->bh_data;         /* must be pointer block */", "      if (pp->pb_id != PTR_ID) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      }", "      /*", "       * TODO: If the pointer block is full and we are adding at the end"], "readability/old_style_comment"]
["src/nvim/memline.c", ["       */", "      /* block not full, add one entry */", "      if (pp->pb_count < pp->pb_count_max) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      if (pp->pb_count < pp->pb_count_max) {", "        if (pb_idx + 1 < (int)pp->pb_count)", "          memmove(&pp->pb_pointer[pb_idx + 2],"], "readability/braces"]
["src/nvim/memline.c", ["          memmove(&pp->pb_pointer[pb_idx + 2],", "              &pp->pb_pointer[pb_idx + 1],", "              (size_t)(pp->pb_count - pb_idx - 1) * sizeof(PTR_EN));"], "whitespace/alignment"]
["src/nvim/memline.c", ["              &pp->pb_pointer[pb_idx + 1],", "              (size_t)(pp->pb_count - pb_idx - 1) * sizeof(PTR_EN));", "        ++pp->pb_count;"], "whitespace/alignment"]
["src/nvim/memline.c", ["              (size_t)(pp->pb_count - pb_idx - 1) * sizeof(PTR_EN));", "        ++pp->pb_count;", "        pp->pb_pointer[pb_idx].pe_line_count = line_count_left;"], "readability/increment"]
["src/nvim/memline.c", ["", "        if (lnum_left != 0)", "          pp->pb_pointer[pb_idx].pe_old_lnum = lnum_left;"], "readability/braces"]
["src/nvim/memline.c", ["          pp->pb_pointer[pb_idx].pe_old_lnum = lnum_left;", "        if (lnum_right != 0)", "          pp->pb_pointer[pb_idx + 1].pe_old_lnum = lnum_right;"], "readability/braces"]
["src/nvim/memline.c", ["        mf_put(mfp, hp, true, false);", "        buf->b_ml.ml_stack_top = stack_idx + 1;             /* truncate stack */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["        if (lineadd) {", "          --(buf->b_ml.ml_stack_top);", "          /* fix line count for rest of blocks in the stack */"], "readability/increment"]
["src/nvim/memline.c", ["          --(buf->b_ml.ml_stack_top);", "          /* fix line count for rest of blocks in the stack */", "          ml_lineadd(buf, lineadd);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["          ml_lineadd(buf, lineadd);", "          /* fix stack itself */", "          buf->b_ml.ml_stack[buf->b_ml.ml_stack_top].ip_high +="], "readability/old_style_comment"]
["src/nvim/memline.c", ["            lineadd;", "          ++(buf->b_ml.ml_stack_top);", "        }"], "readability/increment"]
["src/nvim/memline.c", ["", "        /*", "         * We are finished, break the loop here."], "readability/old_style_comment"]
["src/nvim/memline.c", ["        break;", "      } else {                        /* pointer block full */", "        /*"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      } else {                        /* pointer block full */", "        /*", "         * split the pointer block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["         */", "        for (;; ) {             /* do this twice when splitting block 1 */", "          hp_new = ml_new_ptr(mfp);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["          hp_new = ml_new_ptr(mfp);", "          if (hp_new == NULL)               /* TODO: try to fix tree */", "            return FAIL;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["          hp_new = ml_new_ptr(mfp);", "          if (hp_new == NULL)               /* TODO: try to fix tree */", "            return FAIL;"], "readability/braces"]
["src/nvim/memline.c", ["", "          if (hp->bh_bnum != 1)", "            break;"], "readability/braces"]
["src/nvim/memline.c", ["", "          /*", "           * if block 1 becomes full the tree is given an extra level"], "readability/old_style_comment"]
["src/nvim/memline.c", ["          pp->pb_pointer[0].pe_page_count = 1;", "          mf_put(mfp, hp, true, false);             /* release block 1 */", "          hp = hp_new;                          /* new block is to be split */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["          mf_put(mfp, hp, true, false);             /* release block 1 */", "          hp = hp_new;                          /* new block is to be split */", "          pp = pp_new;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["          ip->ip_index = 0;", "          ++stack_idx;                  /* do block 1 again later */", "        }"], "readability/old_style_comment"]
["src/nvim/memline.c", ["          ip->ip_index = 0;", "          ++stack_idx;                  /* do block 1 again later */", "        }"], "readability/increment"]
["src/nvim/memline.c", ["        }", "        /*", "         * move the pointers after the current one to the new block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["          memmove(&pp_new->pb_pointer[0],", "              &pp->pb_pointer[pb_idx + 1],", "              (size_t)(total_moved) * sizeof(PTR_EN));"], "whitespace/alignment"]
["src/nvim/memline.c", ["              &pp->pb_pointer[pb_idx + 1],", "              (size_t)(total_moved) * sizeof(PTR_EN));", "          pp_new->pb_count = total_moved;"], "whitespace/alignment"]
["src/nvim/memline.c", ["          pp->pb_pointer[pb_idx + 1].pe_page_count = page_count_right;", "          if (lnum_right)", "            pp->pb_pointer[pb_idx + 1].pe_old_lnum = lnum_right;"], "readability/braces"]
["src/nvim/memline.c", ["        pp->pb_pointer[pb_idx].pe_page_count = page_count_left;", "        if (lnum_left)", "          pp->pb_pointer[pb_idx].pe_old_lnum = lnum_left;"], "readability/braces"]
["src/nvim/memline.c", ["", "        /*", "         * recompute line counts"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        line_count_right = 0;", "        for (i = 0; i < (int)pp_new->pb_count; ++i)", "          line_count_right += pp_new->pb_pointer[i].pe_line_count;"], "readability/braces"]
["src/nvim/memline.c", ["        line_count_right = 0;", "        for (i = 0; i < (int)pp_new->pb_count; ++i)", "          line_count_right += pp_new->pb_pointer[i].pe_line_count;"], "readability/increment"]
["src/nvim/memline.c", ["        line_count_left = 0;", "        for (i = 0; i < (int)pp->pb_count; ++i)", "          line_count_left += pp->pb_pointer[i].pe_line_count;"], "readability/braces"]
["src/nvim/memline.c", ["        line_count_left = 0;", "        for (i = 0; i < (int)pp->pb_count; ++i)", "          line_count_left += pp->pb_pointer[i].pe_line_count;"], "readability/increment"]
["src/nvim/memline.c", ["", "    /*", "     * Safety check: fallen out of for loop?"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /* The line was inserted below 'lnum' */", "  ml_updatechunk(buf, lnum + 1, (long)len, ML_CHNK_ADDLINE);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["{", "  if (line == NULL)             /* just checking... */", "    return FAIL;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["{", "  if (line == NULL)             /* just checking... */", "    return FAIL;"], "readability/braces"]
["src/nvim/memline.c", ["  infoptr_T   *ip;", "  int count;                /* number of entries in block */", "  int idx;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (lnum < 1 || lnum > buf->b_ml.ml_line_count)", "    return FAIL;"], "readability/braces"]
["src/nvim/memline.c", ["", "  if (lowest_marked && lowest_marked > lnum)", "    lowest_marked--;"], "readability/braces"]
["src/nvim/memline.c", ["", "  /*", "   * If the file becomes empty the last line is replaced by an empty line."], "readability/old_style_comment"]
["src/nvim/memline.c", ["   */", "  if (buf->b_ml.ml_line_count == 1) {       /* file becomes empty */", "    if (message"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if (buf->b_ml.ml_line_count == 1) {       /* file becomes empty */", "    if (message", "        )"], "readability/braces"]
["src/nvim/memline.c", ["", "  /*", "   * find the data block containing the line"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  mfp = buf->b_ml.ml_mfp;", "  if (mfp == NULL)", "    return FAIL;"], "readability/braces"]
["src/nvim/memline.c", ["", "  if ((hp = ml_find_line(buf, lnum, ML_DELETE)) == NULL)", "    return FAIL;"], "readability/braces"]
["src/nvim/memline.c", ["  dp = hp->bh_data;", "  /* compute line count before the delete */", "  count = (long)(buf->b_ml.ml_locked_high)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  --buf->b_ml.ml_line_count;", ""], "readability/increment"]
["src/nvim/memline.c", ["  line_start = ((dp->db_index[idx]) & DB_INDEX_MASK);", "  if (idx == 0)                 /* first line in block, text at the end */", "    line_size = dp->db_txt_end - line_start;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  line_start = ((dp->db_index[idx]) & DB_INDEX_MASK);", "  if (idx == 0)                 /* first line in block, text at the end */", "    line_size = dp->db_txt_end - line_start;"], "readability/braces"]
["src/nvim/memline.c", ["    line_size = dp->db_txt_end - line_start;", "  else", "    line_size = ((dp->db_index[idx - 1]) & DB_INDEX_MASK) - line_start;"], "readability/braces"]
["src/nvim/memline.c", ["", "  /*", "   * special case: If there is only one line in the data block it becomes empty."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if (count == 1) {", "    mf_free(mfp, hp);           /* free the data block */", "    buf->b_ml.ml_locked = NULL;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    for (stack_idx = buf->b_ml.ml_stack_top - 1; stack_idx >= 0;", "         --stack_idx) {", "      buf->b_ml.ml_stack_top = 0;           /* stack is invalid when failing */"], "readability/increment"]
["src/nvim/memline.c", ["         --stack_idx) {", "      buf->b_ml.ml_stack_top = 0;           /* stack is invalid when failing */", "      ip = &(buf->b_ml.ml_stack[stack_idx]);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      idx = ip->ip_index;", "      if ((hp = mf_get(mfp, ip->ip_bnum, 1)) == NULL)", "        return FAIL;"], "readability/braces"]
["src/nvim/memline.c", ["        return FAIL;", "      pp = hp->bh_data;         /* must be pointer block */", "      if (pp->pb_id != PTR_ID) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      count = --(pp->pb_count);", "      if (count == 0)               /* the pointer block becomes empty! */", "        mf_free(mfp, hp);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      count = --(pp->pb_count);", "      if (count == 0)               /* the pointer block becomes empty! */", "        mf_free(mfp, hp);"], "readability/braces"]
["src/nvim/memline.c", ["        mf_free(mfp, hp);", "      else {", "        if (count != idx)               /* move entries after the deleted one */"], "readability/braces"]
["src/nvim/memline.c", ["        mf_free(mfp, hp);", "      else {", "        if (count != idx)               /* move entries after the deleted one */"], "readability/braces"]
["src/nvim/memline.c", ["      else {", "        if (count != idx)               /* move entries after the deleted one */", "          memmove(&pp->pb_pointer[idx], &pp->pb_pointer[idx + 1],"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      else {", "        if (count != idx)               /* move entries after the deleted one */", "          memmove(&pp->pb_pointer[idx], &pp->pb_pointer[idx + 1],"], "readability/braces"]
["src/nvim/memline.c", ["          memmove(&pp->pb_pointer[idx], &pp->pb_pointer[idx + 1],", "              (size_t)(count - idx) * sizeof(PTR_EN));", "        mf_put(mfp, hp, true, false);"], "whitespace/alignment"]
["src/nvim/memline.c", ["", "        buf->b_ml.ml_stack_top = stack_idx;             /* truncate stack */", "        /* fix line count for rest of blocks in the stack */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        buf->b_ml.ml_stack_top = stack_idx;             /* truncate stack */", "        /* fix line count for rest of blocks in the stack */", "        if (buf->b_ml.ml_locked_lineadd != 0) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        }", "        ++(buf->b_ml.ml_stack_top);", ""], "readability/increment"]
["src/nvim/memline.c", ["  } else {", "    /*", "     * delete the text by moving the next lines forwards"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    memmove((char *)dp + text_start + line_size,", "        (char *)dp + text_start, (size_t)(line_start - text_start));", ""], "whitespace/alignment"]
["src/nvim/memline.c", ["", "    /*", "     * delete the index by moving the next indexes backwards"], "readability/old_style_comment"]
["src/nvim/memline.c", ["     */", "    for (i = idx; i < count - 1; ++i)", "      dp->db_index[i] = dp->db_index[i + 1] + line_size;"], "readability/braces"]
["src/nvim/memline.c", ["     */", "    for (i = idx; i < count - 1; ++i)", "      dp->db_index[i] = dp->db_index[i + 1] + line_size;"], "readability/increment"]
["src/nvim/memline.c", ["    dp->db_txt_start += line_size;", "    --(dp->db_line_count);", ""], "readability/increment"]
["src/nvim/memline.c", ["", "    /*", "     * mark the block dirty and make sure it is in the file (for recovery)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * set the B_MARKED flag for line 'lnum'"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  DATA_BL *dp;", "  /* invalid line number */", "  if (lnum < 1 || lnum > curbuf->b_ml.ml_line_count"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  /* invalid line number */", "  if (lnum < 1 || lnum > curbuf->b_ml.ml_line_count", "      || curbuf->b_ml.ml_mfp == NULL)"], "readability/braces"]
["src/nvim/memline.c", ["      || curbuf->b_ml.ml_mfp == NULL)", "    return;                         /* give error message? */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (lowest_marked == 0 || lowest_marked > lnum)", "    lowest_marked = lnum;"], "readability/braces"]
["src/nvim/memline.c", ["", "  /*", "   * find the data block containing the line"], "readability/old_style_comment"]
["src/nvim/memline.c", ["   */", "  if ((hp = ml_find_line(curbuf, lnum, ML_FIND)) == NULL)", "    return;                 /* give error message? */"], "readability/braces"]
["src/nvim/memline.c", ["  if ((hp = ml_find_line(curbuf, lnum, ML_FIND)) == NULL)", "    return;                 /* give error message? */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * find the first line with its B_MARKED flag set"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (curbuf->b_ml.ml_mfp == NULL)", "    return (linenr_T) 0;"], "readability/braces"]
["src/nvim/memline.c", ["  if (curbuf->b_ml.ml_mfp == NULL)", "    return (linenr_T) 0;", ""], "whitespace/cast"]
["src/nvim/memline.c", ["", "  /*", "   * The search starts with lowest_marked line. This is the last line where"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  for (lnum = lowest_marked; lnum <= curbuf->b_ml.ml_line_count; ) {", "    /*", "     * Find the data block containing the line."], "readability/old_style_comment"]
["src/nvim/memline.c", ["     */", "    if ((hp = ml_find_line(curbuf, lnum, ML_FIND)) == NULL)", "      return (linenr_T)0;                   /* give error message? */"], "readability/braces"]
["src/nvim/memline.c", ["    if ((hp = ml_find_line(curbuf, lnum, ML_FIND)) == NULL)", "      return (linenr_T)0;                   /* give error message? */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    for (i = lnum - curbuf->b_ml.ml_locked_low;", "         lnum <= curbuf->b_ml.ml_locked_high; ++i, ++lnum)"], "readability/braces"]
["src/nvim/memline.c", ["    for (i = lnum - curbuf->b_ml.ml_locked_low;", "         lnum <= curbuf->b_ml.ml_locked_high; ++i, ++lnum)", "      if ((dp->db_index[i]) & DB_MARKED) {"], "readability/increment"]
["src/nvim/memline.c", ["", "  return (linenr_T) 0;", "}"], "whitespace/cast"]
["src/nvim/memline.c", ["", "/*", " * clear all DB_MARKED flags"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (curbuf->b_ml.ml_mfp == NULL)          /* nothing to do */", "    return;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (curbuf->b_ml.ml_mfp == NULL)          /* nothing to do */", "    return;"], "readability/braces"]
["src/nvim/memline.c", ["", "  /*", "   * The search starts with line lowest_marked."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  for (lnum = lowest_marked; lnum <= curbuf->b_ml.ml_line_count; ) {", "    /*", "     * Find the data block containing the line."], "readability/old_style_comment"]
["src/nvim/memline.c", ["     */", "    if ((hp = ml_find_line(curbuf, lnum, ML_FIND)) == NULL)", "      return;                   /* give error message? */"], "readability/braces"]
["src/nvim/memline.c", ["    if ((hp = ml_find_line(curbuf, lnum, ML_FIND)) == NULL)", "      return;                   /* give error message? */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    for (i = lnum - curbuf->b_ml.ml_locked_low;", "         lnum <= curbuf->b_ml.ml_locked_high; ++i, ++lnum)"], "readability/braces"]
["src/nvim/memline.c", ["    for (i = lnum - curbuf->b_ml.ml_locked_low;", "         lnum <= curbuf->b_ml.ml_locked_high; ++i, ++lnum)", "      if ((dp->db_index[i]) & DB_MARKED) {"], "readability/increment"]
["src/nvim/memline.c", ["", "/*", " * flush ml_line if necessary"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  int i;", "  static int entered = FALSE;", ""], "readability/bool"]
["src/nvim/memline.c", ["", "  if (buf->b_ml.ml_line_lnum == 0 || buf->b_ml.ml_mfp == NULL)", "    return;             /* nothing to do */"], "readability/braces"]
["src/nvim/memline.c", ["  if (buf->b_ml.ml_line_lnum == 0 || buf->b_ml.ml_mfp == NULL)", "    return;             /* nothing to do */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if (buf->b_ml.ml_flags & ML_LINE_DIRTY) {", "    /* This code doesn't work recursively. */", "    if (entered)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    /* This code doesn't work recursively. */", "    if (entered)", "      return;"], "readability/braces"]
["src/nvim/memline.c", ["      return;", "    entered = TRUE;", ""], "readability/bool"]
["src/nvim/memline.c", ["      old_line = (char_u *)dp + start;", "      if (idx == 0)             /* line is last in block */", "        old_len = dp->db_txt_end - start;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      old_line = (char_u *)dp + start;", "      if (idx == 0)             /* line is last in block */", "        old_len = dp->db_txt_end - start;"], "readability/braces"]
["src/nvim/memline.c", ["        old_len = dp->db_txt_end - start;", "      else                      /* text of previous line follows */", "        old_len = (dp->db_index[idx - 1] & DB_INDEX_MASK) - start;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        old_len = dp->db_txt_end - start;", "      else                      /* text of previous line follows */", "        old_len = (dp->db_index[idx - 1] & DB_INDEX_MASK) - start;"], "readability/braces"]
["src/nvim/memline.c", ["      new_len = (colnr_T)STRLEN(new_line) + 1;", "      extra = new_len - old_len;            /* negative if lines gets smaller */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "      /*", "       * if new line fits in data block, replace directly"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      if ((int)dp->db_free >= extra) {", "        /* if the length changes and there are following lines */", "        count = buf->b_ml.ml_locked_high - buf->b_ml.ml_locked_low + 1;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        if (extra != 0 && idx < count - 1) {", "          /* move text of following lines */", "          memmove((char *)dp + dp->db_txt_start - extra,"], "readability/old_style_comment"]
["src/nvim/memline.c", ["          memmove((char *)dp + dp->db_txt_start - extra,", "              (char *)dp + dp->db_txt_start,", "              (size_t)(start - dp->db_txt_start));"], "whitespace/alignment"]
["src/nvim/memline.c", ["              (char *)dp + dp->db_txt_start,", "              (size_t)(start - dp->db_txt_start));", ""], "whitespace/alignment"]
["src/nvim/memline.c", ["", "          /* adjust pointers of this and following lines */", "          for (i = idx + 1; i < count; ++i)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["          /* adjust pointers of this and following lines */", "          for (i = idx + 1; i < count; ++i)", "            dp->db_index[i] -= extra;"], "readability/braces"]
["src/nvim/memline.c", ["          /* adjust pointers of this and following lines */", "          for (i = idx + 1; i < count; ++i)", "            dp->db_index[i] -= extra;"], "readability/increment"]
["src/nvim/memline.c", ["", "        /* adjust free space */", "        dp->db_free -= extra;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "        /* copy new line into the data block */", "        memmove(old_line - extra, new_line, (size_t)new_len);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        buf->b_ml.ml_flags |= (ML_LOCKED_DIRTY | ML_LOCKED_POS);", "        /* The else case is already covered by the insert and delete */", "        ml_updatechunk(buf, lnum, (long)extra, ML_CHNK_UPDLINE);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    entered = FALSE;", "  }"], "readability/bool"]
["src/nvim/memline.c", ["", "/*", " * create a new, empty, data block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * create a new, empty, pointer block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * lookup line 'lnum' in a memline"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * If there is a locked block check if the wanted line is in it."], "readability/old_style_comment"]
["src/nvim/memline.c", ["      if (action == ML_INSERT) {", "        ++(buf->b_ml.ml_locked_lineadd);", "        ++(buf->b_ml.ml_locked_high);"], "readability/increment"]
["src/nvim/memline.c", ["        ++(buf->b_ml.ml_locked_lineadd);", "        ++(buf->b_ml.ml_locked_high);", "      } else if (action == ML_DELETE) {"], "readability/increment"]
["src/nvim/memline.c", ["      } else if (action == ML_DELETE) {", "        --(buf->b_ml.ml_locked_lineadd);", "        --(buf->b_ml.ml_locked_high);"], "readability/increment"]
["src/nvim/memline.c", ["        --(buf->b_ml.ml_locked_lineadd);", "        --(buf->b_ml.ml_locked_high);", "      }"], "readability/increment"]
["src/nvim/memline.c", ["    mf_put(mfp, buf->b_ml.ml_locked, buf->b_ml.ml_flags & ML_LOCKED_DIRTY,", "        buf->b_ml.ml_flags & ML_LOCKED_POS);", "    buf->b_ml.ml_locked = NULL;"], "whitespace/alignment"]
["src/nvim/memline.c", ["", "    /*", "     * If lines have been added or deleted in the locked block, need to"], "readability/old_style_comment"]
["src/nvim/memline.c", ["     */", "    if (buf->b_ml.ml_locked_lineadd != 0)", "      ml_lineadd(buf, buf->b_ml.ml_locked_lineadd);"], "readability/braces"]
["src/nvim/memline.c", ["", "  if (action == ML_FLUSH)           /* nothing else to do */", "    return NULL;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (action == ML_FLUSH)           /* nothing else to do */", "    return NULL;"], "readability/braces"]
["src/nvim/memline.c", ["", "  bnum = 1;                         /* start at the root of the tree */", "  page_count = 1;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (action == ML_FIND) {      /* first try stack entries */", "    for (top = buf->b_ml.ml_stack_top - 1; top >= 0; --top) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if (action == ML_FIND) {      /* first try stack entries */", "    for (top = buf->b_ml.ml_stack_top - 1; top >= 0; --top) {", "      ip = &(buf->b_ml.ml_stack[top]);"], "readability/increment"]
["src/nvim/memline.c", ["        high = ip->ip_high;", "        buf->b_ml.ml_stack_top = top;           /* truncate stack at prev entry */", "        break;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        high = ip->ip_high;", "        buf->b_ml.ml_stack_top = top;           /* truncate stack at prev entry */", "        break;"], "whitespace/line_length"]
["src/nvim/memline.c", ["    }", "    if (top < 0)", "      buf->b_ml.ml_stack_top = 0;               /* not found, start at the root */"], "readability/braces"]
["src/nvim/memline.c", ["    if (top < 0)", "      buf->b_ml.ml_stack_top = 0;               /* not found, start at the root */", "  } else        /* ML_DELETE or ML_INSERT */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (top < 0)", "      buf->b_ml.ml_stack_top = 0;               /* not found, start at the root */", "  } else        /* ML_DELETE or ML_INSERT */"], "whitespace/line_length"]
["src/nvim/memline.c", ["      buf->b_ml.ml_stack_top = 0;               /* not found, start at the root */", "  } else        /* ML_DELETE or ML_INSERT */", "    buf->b_ml.ml_stack_top = 0;         /* start at the root */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      buf->b_ml.ml_stack_top = 0;               /* not found, start at the root */", "  } else        /* ML_DELETE or ML_INSERT */", "    buf->b_ml.ml_stack_top = 0;         /* start at the root */"], "readability/braces"]
["src/nvim/memline.c", ["  } else        /* ML_DELETE or ML_INSERT */", "    buf->b_ml.ml_stack_top = 0;         /* start at the root */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * search downwards in the tree until a data block is found"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  for (;; ) {", "    if ((hp = mf_get(mfp, bnum, page_count)) == NULL)", "      goto error_noblock;"], "readability/braces"]
["src/nvim/memline.c", ["", "    /*", "     * update high for insert/delete"], "readability/old_style_comment"]
["src/nvim/memline.c", ["     */", "    if (action == ML_INSERT)", "      ++high;"], "readability/braces"]
["src/nvim/memline.c", ["    if (action == ML_INSERT)", "      ++high;", "    else if (action == ML_DELETE)"], "readability/increment"]
["src/nvim/memline.c", ["      ++high;", "    else if (action == ML_DELETE)", "      --high;"], "readability/braces"]
["src/nvim/memline.c", ["    else if (action == ML_DELETE)", "      --high;", ""], "readability/increment"]
["src/nvim/memline.c", ["    dp = hp->bh_data;", "    if (dp->db_id == DATA_ID) {         /* data block */", "      buf->b_ml.ml_locked = hp;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    pp = (PTR_BL *)(dp);                /* must be pointer block */", "    if (pp->pb_id != PTR_ID) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    ip->ip_high = high;", "    ip->ip_index = -1;                  /* index not known yet */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    dirty = FALSE;", "    for (idx = 0; idx < (int)pp->pb_count; ++idx) {"], "readability/bool"]
["src/nvim/memline.c", ["    dirty = FALSE;", "    for (idx = 0; idx < (int)pp->pb_count; ++idx) {", "      t = pp->pb_pointer[idx].pe_line_count;"], "readability/increment"]
["src/nvim/memline.c", ["", "        /*", "         * a negative block number may have been changed"], "readability/old_style_comment"]
["src/nvim/memline.c", ["            pp->pb_pointer[idx].pe_bnum = bnum;", "            dirty = TRUE;", "          }"], "readability/bool"]
["src/nvim/memline.c", ["      pp->pb_pointer[idx].pe_line_count--;", "      dirty = TRUE;", "    } else if (action == ML_INSERT) {"], "readability/bool"]
["src/nvim/memline.c", ["      pp->pb_pointer[idx].pe_line_count++;", "      dirty = TRUE;", "    }"], "readability/bool"]
["src/nvim/memline.c", ["error_noblock:", "  /*", "   * If action is ML_DELETE or ML_INSERT we have to correct the tree for"], "readability/old_style_comment"]
["src/nvim/memline.c", ["   */", "  if (action == ML_DELETE)", "    ml_lineadd(buf, 1);"], "readability/braces"]
["src/nvim/memline.c", ["    ml_lineadd(buf, 1);", "  else if (action == ML_INSERT)", "    ml_lineadd(buf, -1);"], "readability/braces"]
["src/nvim/memline.c", ["", "/*", " * add an entry to the info pointer stack"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /* may have to increase the stack size */", "  if (top == buf->b_ml.ml_stack_size) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if (top == buf->b_ml.ml_stack_size) {", "    CHECK(top > 0, _(\"Stack size increases\"));     /* more than 5 levels??? */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Update the pointer blocks on the stack for inserted/deleted lines."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  for (idx = buf->b_ml.ml_stack_top - 1; idx >= 0; --idx) {", "    ip = &(buf->b_ml.ml_stack[idx]);"], "readability/increment"]
["src/nvim/memline.c", ["    ip = &(buf->b_ml.ml_stack[idx]);", "    if ((hp = mf_get(mfp, ip->ip_bnum, 1)) == NULL)", "      break;"], "readability/braces"]
["src/nvim/memline.c", ["      break;", "    pp = hp->bh_data;       /* must be pointer block */", "    if (pp->pb_id != PTR_ID) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#if defined(HAVE_READLINK)", "/*", " * Resolve a symlink in the last component of a file name."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (fname == NULL)", "    return FAIL;"], "readability/braces"]
["src/nvim/memline.c", ["", "  /* Put the result so far in tmp[], starting with the original name. */", "  STRLCPY(tmp, fname, MAXPATHL);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  for (;; ) {", "    /* Limit symlink depth to 100, catch recursive loops. */", "    if (++depth == 100) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      if (errno == EINVAL || errno == ENOENT) {", "        /* Found non-symlink or not existing file, stop here.", "         * When at the first level use the unmodified name, skip the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["         * call to vim_FullName(). */", "        if (depth == 1)", "          return FAIL;"], "readability/braces"]
["src/nvim/memline.c", ["", "        /* Use the resolved name in tmp[]. */", "        break;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "      /* There must be some error reading links, use original name. */", "      return FAIL;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Try to resolve the full name of the file so that the swapfile name will"], "readability/old_style_comment"]
["src/nvim/memline.c", ["   */", "  return vim_FullName((char *)tmp, (char *)buf, MAXPATHL, TRUE);", "}"], "readability/bool"]
["src/nvim/memline.c", ["", "/*", " * Make swap file name out of the file name and a directory name."], "readability/old_style_comment"]
["src/nvim/memline.c", [" */", "char_u *makeswapname(char_u *fname, char_u *ffname, buf_T *buf, char_u *dir_name)", "{"], "whitespace/line_length"]
["src/nvim/memline.c", ["  r = (char_u *)modname((char *)fname_res, \".swp\",", "              dir_name[0] == '.' && dir_name[1] == NUL);", "  if (r == NULL)            /* out of memory */"], "whitespace/alignment"]
["src/nvim/memline.c", ["              dir_name[0] == '.' && dir_name[1] == NUL);", "  if (r == NULL)            /* out of memory */", "    return NULL;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["              dir_name[0] == '.' && dir_name[1] == NUL);", "  if (r == NULL)            /* out of memory */", "    return NULL;"], "readability/braces"]
["src/nvim/memline.c", ["", "/*", " * Get file name to use for swap file or backup file."], "readability/old_style_comment"]
["src/nvim/memline.c", ["char_u *", "get_file_in_dir (", "    char_u *fname,"], "whitespace/parens"]
["src/nvim/memline.c", ["    char_u *fname,", "    char_u *dname         /* don't use \"dirname\", it is a global for Alpha */", ")"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (dname[0] == '.' && dname[1] == NUL)", "    retval = vim_strsave(fname);"], "readability/braces"]
["src/nvim/memline.c", ["    retval = vim_strsave(fname);", "  else if (dname[0] == '.' && vim_ispathsep(dname[1])) {", "    if (tail == fname)              /* no path before file name */"], "readability/braces"]
["src/nvim/memline.c", ["  else if (dname[0] == '.' && vim_ispathsep(dname[1])) {", "    if (tail == fname)              /* no path before file name */", "      retval = (char_u *)concat_fnames((char *)dname + 2, (char *)tail, TRUE);"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  else if (dname[0] == '.' && vim_ispathsep(dname[1])) {", "    if (tail == fname)              /* no path before file name */", "      retval = (char_u *)concat_fnames((char *)dname + 2, (char *)tail, TRUE);"], "readability/braces"]
["src/nvim/memline.c", ["    if (tail == fname)              /* no path before file name */", "      retval = (char_u *)concat_fnames((char *)dname + 2, (char *)tail, TRUE);", "    else {"], "readability/bool"]
["src/nvim/memline.c", ["      retval = (char_u *)concat_fnames((char *)dname + 2, (char *)tail, TRUE);", "    else {", "      save_char = *tail;"], "readability/braces"]
["src/nvim/memline.c", ["      retval = (char_u *)concat_fnames((char *)dname + 2, (char *)tail, TRUE);", "    else {", "      save_char = *tail;"], "readability/braces"]
["src/nvim/memline.c", ["      *tail = NUL;", "      t = (char_u *)concat_fnames((char *)fname, (char *)dname + 2, TRUE);", "      *tail = save_char;"], "readability/bool"]
["src/nvim/memline.c", ["      *tail = save_char;", "      retval = (char_u *)concat_fnames((char *)t, (char *)tail, TRUE);", "      xfree(t);"], "readability/bool"]
["src/nvim/memline.c", ["  } else {", "    retval = (char_u *)concat_fnames((char *)dname, (char *)tail, TRUE);", "  }"], "readability/bool"]
["src/nvim/memline.c", ["", "/*", " * Print the ATTENTION message: info about an existing swap file."], "readability/old_style_comment"]
["src/nvim/memline.c", [" */", "static void ", "attention_message ("], "whitespace/end_of_line"]
["src/nvim/memline.c", ["static void ", "attention_message (", "    buf_T *buf,           /* buffer being edited */"], "whitespace/parens"]
["src/nvim/memline.c", ["attention_message (", "    buf_T *buf,           /* buffer being edited */", "    char_u *fname         /* swap file name */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    buf_T *buf,           /* buffer being edited */", "    char_u *fname         /* swap file name */", ")"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  ++no_wait_return;", "  (void)EMSG(_(\"E325: ATTENTION\"));"], "readability/increment"]
["src/nvim/memline.c", ["  }", "  /* Some of these messages are long to allow translation to", "   * other languages. */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  cmdline_row = msg_row;", "  --no_wait_return;", "}"], "readability/increment"]
["src/nvim/memline.c", ["", "/*", " * Trigger the SwapExists autocommands."], "readability/old_style_comment"]
["src/nvim/memline.c", ["{", "  set_vim_var_string(VV_SWAPNAME, (char *) fname, -1);", "  set_vim_var_string(VV_SWAPCHOICE, NULL, -1);"], "whitespace/cast"]
["src/nvim/memline.c", ["", "  /* Trigger SwapExists autocommands with <afile> set to the file being", "   * edited.  Disallow changing directory here. */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["   * edited.  Disallow changing directory here. */", "  ++allbuf_lock;", "  apply_autocmds(EVENT_SWAPEXISTS, buf->b_fname, NULL, FALSE, NULL);"], "readability/increment"]
["src/nvim/memline.c", ["  ++allbuf_lock;", "  apply_autocmds(EVENT_SWAPEXISTS, buf->b_fname, NULL, FALSE, NULL);", "  --allbuf_lock;"], "readability/bool"]
["src/nvim/memline.c", ["  apply_autocmds(EVENT_SWAPEXISTS, buf->b_fname, NULL, FALSE, NULL);", "  --allbuf_lock;", ""], "readability/increment"]
["src/nvim/memline.c", ["  char *dir_name;", "  char *buf_fname = (char *) buf->b_fname;", ""], "whitespace/cast"]
["src/nvim/memline.c", ["", "  /*", "   * Isolate a directory name from *dirp and put it in dir_name."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  dir_name = xmalloc(dir_len);", "  (void)copy_option_part((char_u **) dirp, (char_u *) dir_name, dir_len, \",\");", ""], "whitespace/cast"]
["src/nvim/memline.c", ["", "  /*", "   * we try different names until we find one that does not exist yet"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        struct block0 b0;", "        int differ = FALSE;", ""], "readability/bool"]
["src/nvim/memline.c", ["                if (fnamecmp_ino(buf->b_ffname, NameBuff,", "                    char_to_long(b0.b0_ino))) {", "                  differ = TRUE;"], "whitespace/alignment"]
["src/nvim/memline.c", ["                    char_to_long(b0.b0_ino))) {", "                  differ = TRUE;", "                }"], "readability/bool"]
["src/nvim/memline.c", ["              if (fnamecmp_ino(buf->b_ffname, NameBuff,", "                  char_to_long(b0.b0_ino))) {", "                differ = TRUE;"], "whitespace/alignment"]
["src/nvim/memline.c", ["                  char_to_long(b0.b0_ino))) {", "                differ = TRUE;", "              }"], "readability/bool"]
["src/nvim/memline.c", ["            case 1:", "              buf->b_p_ro = TRUE;", "              break;"], "readability/bool"]
["src/nvim/memline.c", ["              swap_exists_action = SEA_QUIT;", "              got_int = TRUE;", "              break;"], "readability/bool"]
["src/nvim/memline.c", ["            MSG_PUTS(\"\\n\");", "            if (msg_silent == 0)", "              /* call wait_return() later */"], "readability/braces"]
["src/nvim/memline.c", ["            if (msg_silent == 0)", "              /* call wait_return() later */", "              need_wait_return = TRUE;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["              /* call wait_return() later */", "              need_wait_return = TRUE;", "          }"], "readability/bool"]
["src/nvim/memline.c", ["          }", "", "        }"], "whitespace/blank_line"]
["src/nvim/memline.c", ["", "    /*", "     * Change the \".swp\" extension to find another file that can be used."], "readability/old_style_comment"]
["src/nvim/memline.c", ["     */", "    if (fname[n - 1] == 'a') {          /* \".s?a\" */", "      if (fname[n - 2] == 'a') {        /* \".saa\": tried enough, give up */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (fname[n - 1] == 'a') {          /* \".s?a\" */", "      if (fname[n - 2] == 'a') {        /* \".saa\": tried enough, give up */", "        EMSG(_(\"E326: Too many swap files found\"));"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      }", "      --fname[n - 2];                   /* \".svz\", \".suz\", etc. */", "      fname[n - 1] = 'z' + 1;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      }", "      --fname[n - 2];                   /* \".svz\", \".suz\", etc. */", "      fname[n - 1] = 'z' + 1;"], "readability/increment"]
["src/nvim/memline.c", ["    }", "    --fname[n - 1];                     /* \".swo\", \".swn\", etc. */", "  }"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    }", "    --fname[n - 1];                     /* \".swo\", \".swn\", etc. */", "  }"], "readability/increment"]
["src/nvim/memline.c", ["", "  if (os_isdir((char_u *) dir_name)) {", "    *found_existing_dir = true;"], "whitespace/cast"]
["src/nvim/memline.c", ["         || b0p->b0_magic_int != (int)B0_MAGIC_INT", "         || b0p->b0_magic_short != (short)B0_MAGIC_SHORT", "         || b0p->b0_magic_char != B0_MAGIC_CHAR;"], "runtime/int"]
["src/nvim/memline.c", ["", "/*", " * Compare current file name with file name from swap file."], "readability/old_style_comment"]
["src/nvim/memline.c", ["{", "  uint64_t ino_c = 0;               /* ino of current file */", "  uint64_t ino_s;                   /* ino of file from swap file */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  uint64_t ino_c = 0;               /* ino of current file */", "  uint64_t ino_s;                   /* ino of file from swap file */", "  char_u buf_c[MAXPATHL];           /* full path of fname_c */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  uint64_t ino_s;                   /* ino of file from swap file */", "  char_u buf_c[MAXPATHL];           /* full path of fname_c */", "  char_u buf_s[MAXPATHL];           /* full path of fname_s */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  char_u buf_c[MAXPATHL];           /* full path of fname_c */", "  char_u buf_s[MAXPATHL];           /* full path of fname_s */", "  int retval_c;                     /* flag: buf_c valid */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  char_u buf_s[MAXPATHL];           /* full path of fname_s */", "  int retval_c;                     /* flag: buf_c valid */", "  int retval_s;                     /* flag: buf_s valid */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  int retval_c;                     /* flag: buf_c valid */", "  int retval_s;                     /* flag: buf_s valid */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * First we try to get the inode from the file name, because the inode in"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (ino_c && ino_s)", "    return ino_c != ino_s;"], "readability/braces"]
["src/nvim/memline.c", ["", "  /*", "   * One of the inode numbers is unknown, try a forced vim_FullName() and"], "readability/old_style_comment"]
["src/nvim/memline.c", ["   */", "  retval_c = vim_FullName((char *)fname_c, (char *)buf_c, MAXPATHL, TRUE);", "  retval_s = vim_FullName((char *)fname_s, (char *)buf_s, MAXPATHL, TRUE);"], "readability/bool"]
["src/nvim/memline.c", ["  retval_c = vim_FullName((char *)fname_c, (char *)buf_c, MAXPATHL, TRUE);", "  retval_s = vim_FullName((char *)fname_s, (char *)buf_s, MAXPATHL, TRUE);", "  if (retval_c == OK && retval_s == OK)"], "readability/bool"]
["src/nvim/memline.c", ["  retval_s = vim_FullName((char *)fname_s, (char *)buf_s, MAXPATHL, TRUE);", "  if (retval_c == OK && retval_s == OK)", "    return STRCMP(buf_c, buf_s) != 0;"], "readability/braces"]
["src/nvim/memline.c", ["", "  /*", "   * Can't compare inodes or file names, guess that the files are different,"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Move a long integer into a four byte character array."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Set the flags in the first block of the swap file:"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (!buf->b_ml.ml_mfp)", "    return;"], "readability/braces"]
["src/nvim/memline.c", ["", "#define MLCS_MAXL 800   /* max no of lines in chunk */", "#define MLCS_MINL 400   /* should be half of MLCS_MAXL */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define MLCS_MAXL 800   /* max no of lines in chunk */", "#define MLCS_MINL 400   /* should be half of MLCS_MAXL */", ""], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Keep information for finding byte offset of a line, updtype may be one of:"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (buf->b_ml.ml_usedchunks == -1 || len == 0)", "    return;"], "readability/braces"]
["src/nvim/memline.c", ["  if (updtype == ML_CHNK_UPDLINE && buf->b_ml.ml_line_count == 1) {", "    /*", "     * First line in empty buffer from ml_flush_line() -- reset"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Find chunk that our line belongs to, curline will be at start of the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["         curix < buf->b_ml.ml_usedchunks - 1", "                 && line >= curline +", "                             buf->b_ml.ml_chunksize[curix].mlcs_numlines;"], "whitespace/alignment"]
["src/nvim/memline.c", ["                 && line >= curline +", "                             buf->b_ml.ml_chunksize[curix].mlcs_numlines;", "         curix++) {"], "whitespace/alignment"]
["src/nvim/memline.c", ["", "  if (updtype == ML_CHNK_DELLINE)", "    len = -len;"], "readability/braces"]
["src/nvim/memline.c", ["", "    /* May resize here so we don't have to do it in both cases below */", "    if (buf->b_ml.ml_usedchunks + 1 >= buf->b_ml.ml_numchunks) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (buf->b_ml.ml_chunksize[curix].mlcs_numlines >= MLCS_MAXL) {", "      int count;                    /* number of entries in block */", "      int idx;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      memmove(buf->b_ml.ml_chunksize + curix + 1,", "          buf->b_ml.ml_chunksize + curix,", "          (buf->b_ml.ml_usedchunks - curix) *"], "whitespace/alignment"]
["src/nvim/memline.c", ["          buf->b_ml.ml_chunksize + curix,", "          (buf->b_ml.ml_usedchunks - curix) *", "          sizeof(chunksize_T));"], "whitespace/alignment"]
["src/nvim/memline.c", ["          (buf->b_ml.ml_usedchunks - curix) *", "          sizeof(chunksize_T));", "      /* Compute length of first half of lines in the split chunk */"], "whitespace/alignment"]
["src/nvim/memline.c", ["          sizeof(chunksize_T));", "      /* Compute length of first half of lines in the split chunk */", "      size = 0;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        curline = buf->b_ml.ml_locked_high + 1;", "        if (idx == 0)        /* first line in block, text at the end */", "          text_end = dp->db_txt_end;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        curline = buf->b_ml.ml_locked_high + 1;", "        if (idx == 0)        /* first line in block, text at the end */", "          text_end = dp->db_txt_end;"], "readability/braces"]
["src/nvim/memline.c", ["          text_end = dp->db_txt_end;", "        else", "          text_end = ((dp->db_index[idx - 1]) & DB_INDEX_MASK);"], "readability/braces"]
["src/nvim/memline.c", ["          text_end = ((dp->db_index[idx - 1]) & DB_INDEX_MASK);", "        /* Compute index of last line to use in this MEMLINE */", "        rest = count - idx;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      buf->b_ml.ml_usedchunks++;", "      ml_upd_lastbuf = NULL;         /* Force recalc of curix & curline */", "      return;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["               && buf->b_ml.ml_line_count - line <= 1) {", "      /*", "       * We are in the last chunk and it is cheap to crate a new one"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      } else {", "        /*", "         * Line is just prior to last, move count for last"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        dp = hp->bh_data;", "        if (dp->db_line_count == 1)", "          rest = dp->db_txt_end - dp->db_txt_start;"], "readability/braces"]
["src/nvim/memline.c", ["          rest = dp->db_txt_end - dp->db_txt_start;", "        else", "          rest ="], "readability/braces"]
["src/nvim/memline.c", ["    curchnk->mlcs_numlines--;", "    ml_upd_lastbuf = NULL;       /* Force recalc of curix & curline */", "    if (curix < (buf->b_ml.ml_usedchunks - 1)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      memmove(buf->b_ml.ml_chunksize, buf->b_ml.ml_chunksize + 1,", "          buf->b_ml.ml_usedchunks * sizeof(chunksize_T));", "      return;"], "whitespace/alignment"]
["src/nvim/memline.c", ["", "    /* Collapse chunks */", "    curchnk[-1].mlcs_numlines += curchnk->mlcs_numlines;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      memmove(buf->b_ml.ml_chunksize + curix,", "          buf->b_ml.ml_chunksize + curix + 1,", "          (buf->b_ml.ml_usedchunks - curix) *"], "whitespace/alignment"]
["src/nvim/memline.c", ["          buf->b_ml.ml_chunksize + curix + 1,", "          (buf->b_ml.ml_usedchunks - curix) *", "          sizeof(chunksize_T));"], "whitespace/alignment"]
["src/nvim/memline.c", ["          (buf->b_ml.ml_usedchunks - curix) *", "          sizeof(chunksize_T));", "    }"], "whitespace/alignment"]
["src/nvim/memline.c", ["  DATA_BL     *dp;", "  int count;                    /* number of entries in block */", "  int idx;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  if (buf->b_ml.ml_usedchunks == -1", "      || buf->b_ml.ml_chunksize == NULL"], "readability/braces"]
["src/nvim/memline.c", ["", "  if (offp == NULL)", "    offset = 0;"], "readability/braces"]
["src/nvim/memline.c", ["    offset = 0;", "  else", "    offset = *offp;"], "readability/braces"]
["src/nvim/memline.c", ["    offset = *offp;", "  if (lnum == 0 && offset <= 0)", "    return 1;       /* Not a \"find offset\" and offset 0 _must_ be in line 1 */"], "readability/braces"]
["src/nvim/memline.c", ["  if (lnum == 0 && offset <= 0)", "    return 1;       /* Not a \"find offset\" and offset 0 _must_ be in line 1 */", "  /*"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    return 1;       /* Not a \"find offset\" and offset 0 _must_ be in line 1 */", "  /*", "   * Find the last chunk before the one containing our line. Last chunk is"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    size += buf->b_ml.ml_chunksize[curix].mlcs_totalsize;", "    if (offset && ffdos)", "      size += buf->b_ml.ml_chunksize[curix].mlcs_numlines;"], "readability/braces"]
["src/nvim/memline.c", ["  while ((lnum != 0 && curline < lnum) || (offset != 0 && size < offset)) {", "    if (curline > buf->b_ml.ml_line_count", "        || (hp = ml_find_line(buf, curline, ML_FIND)) == NULL)"], "readability/braces"]
["src/nvim/memline.c", ["    start_idx = idx = curline - buf->b_ml.ml_locked_low;", "    if (idx == 0)    /* first line in block, text at the end */", "      text_end = dp->db_txt_end;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    start_idx = idx = curline - buf->b_ml.ml_locked_low;", "    if (idx == 0)    /* first line in block, text at the end */", "      text_end = dp->db_txt_end;"], "readability/braces"]
["src/nvim/memline.c", ["      text_end = dp->db_txt_end;", "    else", "      text_end = ((dp->db_index[idx - 1]) & DB_INDEX_MASK);"], "readability/braces"]
["src/nvim/memline.c", ["      text_end = ((dp->db_index[idx - 1]) & DB_INDEX_MASK);", "    /* Compute index of last line to use in this MEMLINE */", "    if (lnum != 0) {"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (lnum != 0) {", "      if (curline + (count - idx) >= lnum)", "        idx += lnum - curline - 1;"], "readability/braces"]
["src/nvim/memline.c", ["        idx += lnum - curline - 1;", "      else", "        idx = count - 1;"], "readability/braces"]
["src/nvim/memline.c", ["             + ffdos) {", "        if (ffdos)", "          size++;"], "readability/braces"]
["src/nvim/memline.c", ["    if (offset != 0 && size >= offset) {", "      if (size + ffdos == offset)", "        *offp = 0;"], "readability/braces"]
["src/nvim/memline.c", ["        *offp = 0;", "      else if (idx == start_idx)", "        *offp = offset - size + len;"], "readability/braces"]
["src/nvim/memline.c", ["        *offp = offset - size + len;", "      else", "        *offp = offset - size + len"], "readability/braces"]
["src/nvim/memline.c", ["      curline += idx - start_idx + extra;", "      if (curline > buf->b_ml.ml_line_count)", "        return -1;              /* exactly one byte beyond the end */"], "readability/braces"]
["src/nvim/memline.c", ["      if (curline > buf->b_ml.ml_line_count)", "        return -1;              /* exactly one byte beyond the end */", "      return curline;"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if (lnum != 0) {", "    /* Count extra CR characters. */", "    if (ffdos)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    /* Count extra CR characters. */", "    if (ffdos)", "      size += lnum - 1;"], "readability/braces"]
["src/nvim/memline.c", ["", "    /* Don't count the last line break if 'noeol' and ('bin' or", "     * 'nofixeol'). */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    curwin->w_cursor.coladd = 0;", "    curwin->w_set_curswant = TRUE;", "  }"], "readability/bool"]
