["src/nvim/menu.c", ["", "/*", " * Code for menus.  Used for the GUI and 'wildmenu'."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "#define MENUDEPTH   10          /* maximum depth of menus */", ""], "readability/old_style_comment"]
["src/nvim/menu.c", ["    while (*arg != NUL && *arg != ' ') {", "      if (*arg == '\\\\')", "        STRMOVE(arg, arg + 1);"], "readability/braces"]
["src/nvim/menu.c", ["    i = 1;", "  } else", "    i = 0;"], "readability/braces"]
["src/nvim/menu.c", ["    i = 0;", "  while (i < MENUDEPTH)", "    pri_tab[i++] = 500;"], "readability/braces"]
["src/nvim/menu.c", ["    pri_tab[i++] = 500;", "  pri_tab[MENUDEPTH] = -1;              /* mark end of the table */", ""], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /*", "   * Check for \"disable\" or \"enable\" argument."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /*", "   * If there is no argument, display all menus."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /*", "   * If there is only a menu name, display menus with that name."], "readability/old_style_comment"]
["src/nvim/menu.c", ["    if (menu_is_popup(menu_path)) {", "      for (i = 0; i < MENU_INDEX_TIP; ++i)", "        if (modes & (1 << i)) {"], "readability/braces"]
["src/nvim/menu.c", ["    if (menu_is_popup(menu_path)) {", "      for (i = 0; i < MENU_INDEX_TIP; ++i)", "        if (modes & (1 << i)) {"], "readability/increment"]
["src/nvim/menu.c", ["  } else if (unmenu) {", "    /*", "     * Delete menu(s)."], "readability/old_style_comment"]
["src/nvim/menu.c", ["     */", "    if (STRCMP(menu_path, \"*\") == 0)            /* meaning: remove all menus */", "      menu_path = (char_u *)\"\";"], "readability/old_style_comment"]
["src/nvim/menu.c", ["     */", "    if (STRCMP(menu_path, \"*\") == 0)            /* meaning: remove all menus */", "      menu_path = (char_u *)\"\";"], "readability/braces"]
["src/nvim/menu.c", ["", "    /*", "     * For the PopUp menu, remove a menu for each mode separately."], "readability/old_style_comment"]
["src/nvim/menu.c", ["    if (menu_is_popup(menu_path)) {", "      for (i = 0; i < MENU_INDEX_TIP; ++i)", "        if (modes & (1 << i)) {"], "readability/braces"]
["src/nvim/menu.c", ["    if (menu_is_popup(menu_path)) {", "      for (i = 0; i < MENU_INDEX_TIP; ++i)", "        if (modes & (1 << i)) {"], "readability/increment"]
["src/nvim/menu.c", ["  } else {", "    /*", "     * Add menu(s)."], "readability/old_style_comment"]
["src/nvim/menu.c", ["     */", "    if (STRICMP(map_to, \"<nop>\") == 0) {        /* \"<Nop>\" means nothing */", "      map_to = (char_u *)\"\";"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "    /*", "     * For the PopUp menu, add a menu for each mode separately."], "readability/old_style_comment"]
["src/nvim/menu.c", ["    if (menu_is_popup(menu_path)) {", "      for (i = 0; i < MENU_INDEX_TIP; ++i)", "        if (modes & (1 << i)) {"], "readability/braces"]
["src/nvim/menu.c", ["    if (menu_is_popup(menu_path)) {", "      for (i = 0; i < MENU_INDEX_TIP; ++i)", "        if (modes & (1 << i)) {"], "readability/increment"]
["src/nvim/menu.c", ["theend:", "  ;", "}"], "whitespace/semicolon"]
["src/nvim/menu.c", ["", "  /* Make a copy so we can stuff around with it, since it could be const */", "  path_name = vim_strsave(menu_path);"], "readability/old_style_comment"]
["src/nvim/menu.c", ["  while (*name) {", "    /* Get name of this element in the menu hierarchy, and the simplified", "     * name (without mnemonic and accelerator text). */"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    if (*dname == NUL) {", "      /* Only a mnemonic or accelerator is not valid. */", "      EMSG(_(\"E792: Empty menu name\"));"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "    /* See if it's already there */", "    lower_pri = menup;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "      /* Count menus, to find where this one needs to be inserted.", "       * Ignore menus that are not in the menubar (PopUp and Toolbar) */"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "      /* Not already there, so lets add it */", "      menu = xcalloc(1, sizeof(vimmenu_T));"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "      /*", "       * If this menu option was previously only available in other"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /*", "   * Only add system menu items which have not been defined yet."], "readability/old_style_comment"]
["src/nvim/menu.c", ["           (MENU_NORMAL_MODE | MENU_INSERT_MODE));", "  if (sys_menu)", "    modes &= ~old_modes;"], "readability/braces"]
["src/nvim/menu.c", ["", "    /* loop over all modes, may add more than one */", "    for (i = 0; i < MENU_MODES; ++i) {"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    /* loop over all modes, may add more than one */", "    for (i = 0; i < MENU_MODES; ++i) {", "      if (modes & (1 << i)) {"], "readability/increment"]
["src/nvim/menu.c", ["      if (modes & (1 << i)) {", "        /* free any old menu */", "        free_menu_string(menu, i);"], "readability/old_style_comment"]
["src/nvim/menu.c", ["        if (c != 0) {", "          menu->strings[i] = xmalloc(STRLEN(call_data) + 5 );", "          menu->strings[i][0] = c;"], "whitespace/parens"]
["src/nvim/menu.c", ["", "            /* Append CTRL-\\ CTRL-G to obey 'insertmode'. */", "            menu->strings[i][len] = Ctrl_BSL;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /* Delete any empty submenu we added before discovering the error.  Repeat", "   * for higher levels. */"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "/*", " * Set the (sub)menu with the given name to enabled or disabled."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  if (menu == NULL)", "    return OK;                  /* Got to bottom of hierarchy */"], "readability/braces"]
["src/nvim/menu.c", ["  if (menu == NULL)", "    return OK;                  /* Got to bottom of hierarchy */", ""], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /* Get name of this element in the menu hierarchy */", "  p = menu_name_skip(name);"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /* Find the menu */", "  while (menu != NULL) {"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "      /*", "       * When name is empty, we are doing all menu items for the given"], "readability/old_style_comment"]
["src/nvim/menu.c", ["       */", "      if (*name != NUL && *name != '*')", "        break;"], "readability/braces"]
["src/nvim/menu.c", ["", "/*", " * Remove the (sub)menu with the given name from the menu hierarchy"], "readability/old_style_comment"]
["src/nvim/menu.c", [" */", "static int ", "remove_menu ("], "whitespace/end_of_line"]
["src/nvim/menu.c", ["static int ", "remove_menu (", "    vimmenu_T **menup,"], "whitespace/parens"]
["src/nvim/menu.c", ["    int modes,", "    bool silent                     /* don't give error messages */", ")"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  if (*menup == NULL)", "    return OK;                  /* Got to bottom of hierarchy */"], "readability/braces"]
["src/nvim/menu.c", ["  if (*menup == NULL)", "    return OK;                  /* Got to bottom of hierarchy */", ""], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /* Get name of this element in the menu hierarchy */", "  p = menu_name_skip(name);"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /* Find the menu */", "  while ((menu = *menup) != NULL) {"], "readability/old_style_comment"]
["src/nvim/menu.c", ["      if (*p != NUL && menu->children == NULL) {", "        if (!silent)", "          EMSG(_(e_notsubmenu));"], "readability/braces"]
["src/nvim/menu.c", ["      if ((menu->modes & modes) != 0x0) {", "        if (remove_menu(&menu->children, p, modes, silent) == FAIL)", "          return FAIL;"], "readability/braces"]
["src/nvim/menu.c", ["      } else if (*name != NUL) {", "        if (!silent)", "          EMSG(_(e_othermode));"], "readability/braces"]
["src/nvim/menu.c", ["", "      /*", "       * When name is empty, we are removing all menu items for the given"], "readability/old_style_comment"]
["src/nvim/menu.c", ["       */", "      if (*name != NUL)", "        break;"], "readability/braces"]
["src/nvim/menu.c", ["", "      /* Remove the menu item for the given mode[s].  If the menu item", "       * is no longer valid in ANY mode, delete it */"], "readability/old_style_comment"]
["src/nvim/menu.c", ["      menu->modes &= ~modes;", "      if (modes & MENU_TIP_MODE)", "        free_menu_string(menu, MENU_INDEX_TIP);"], "readability/braces"]
["src/nvim/menu.c", ["        free_menu_string(menu, MENU_INDEX_TIP);", "      if ((menu->modes & MENU_ALL_MODES) == 0)", "        free_menu(menup);"], "readability/braces"]
["src/nvim/menu.c", ["        free_menu(menup);", "      else", "        menup = &menu->next;"], "readability/braces"]
["src/nvim/menu.c", ["        menup = &menu->next;", "    } else", "      menup = &menu->next;"], "readability/braces"]
["src/nvim/menu.c", ["    if (menu == NULL) {", "      if (!silent)", "        EMSG2(_(e_nomenu), name);"], "readability/braces"]
["src/nvim/menu.c", ["", "    /* Recalculate modes for menu based on the new updated children */", "    menu->modes &= ~modes;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    child = menu->children;", "    for (; child != NULL; child = child->next)", "      menu->modes |= child->modes;"], "readability/braces"]
["src/nvim/menu.c", ["    if ((menu->modes & MENU_ALL_MODES) == 0) {", "      /* The menu item is no longer valid in ANY mode, so delete it */", "      *menup = menu;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "/*", " * Free the given menu structure and remove it from the linked list."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /* Don't change *menup until after calling gui_mch_destroy_menu(). The", "   * MacOS code needs the original structure to properly delete the menu. */"], "readability/old_style_comment"]
["src/nvim/menu.c", ["  xfree(menu->actext);", "  for (i = 0; i < MENU_MODES; i++)", "    free_menu_string(menu, i);"], "readability/braces"]
["src/nvim/menu.c", ["  xfree(menu);", "", "}"], "whitespace/blank_line"]
["src/nvim/menu.c", ["", "/*", " * Free the menu->string with the given index."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  for (i = 0; i < MENU_MODES; i++)", "    if (menu->strings[i] == menu->strings[idx])"], "readability/braces"]
["src/nvim/menu.c", ["  for (i = 0; i < MENU_MODES; i++)", "    if (menu->strings[i] == menu->strings[idx])", "      count++;"], "readability/braces"]
["src/nvim/menu.c", ["      count++;", "  if (count == 1)", "    xfree(menu->strings[idx]);"], "readability/braces"]
["src/nvim/menu.c", ["", "  /* Now we have found the matching menu, and we list the mappings */", "  /* Highlight title */"], "readability/old_style_comment"]
["src/nvim/menu.c", ["  /* Now we have found the matching menu, and we list the mappings */", "  /* Highlight title */", "  MSG_PUTS_TITLE(_(\"\\n--- Menus ---\"));"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  if (menu != NULL && (menu->modes & modes) == 0x0)", "    return;"], "readability/braces"]
["src/nvim/menu.c", ["    msg_putchar('\\n');", "    if (got_int)                /* \"q\" hit for \"--more--\" */", "      return;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    msg_putchar('\\n');", "    if (got_int)                /* \"q\" hit for \"--more--\" */", "      return;"], "readability/braces"]
["src/nvim/menu.c", ["      return;", "    for (i = 0; i < depth; i++)", "      MSG_PUTS(\"  \");"], "readability/braces"]
["src/nvim/menu.c", ["  if (menu != NULL && menu->children == NULL) {", "    for (bit = 0; bit < MENU_MODES; bit++)", "      if ((menu->modes & modes & (1 << bit)) != 0) {"], "readability/braces"]
["src/nvim/menu.c", ["        msg_putchar('\\n');", "        if (got_int)                    /* \"q\" hit for \"--more--\" */", "          return;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["        msg_putchar('\\n');", "        if (got_int)                    /* \"q\" hit for \"--more--\" */", "          return;"], "readability/braces"]
["src/nvim/menu.c", ["          return;", "        for (i = 0; i < depth + 2; i++)", "          MSG_PUTS(\"  \");"], "readability/braces"]
["src/nvim/menu.c", ["        msg_putchar(menu_mode_chars[bit]);", "        if (menu->noremap[bit] == REMAP_NONE)", "          msg_putchar('*');"], "readability/braces"]
["src/nvim/menu.c", ["          msg_putchar('*');", "        else if (menu->noremap[bit] == REMAP_SCRIPT)", "          msg_putchar('&');"], "readability/braces"]
["src/nvim/menu.c", ["          msg_putchar('&');", "        else", "          msg_putchar(' ');"], "readability/braces"]
["src/nvim/menu.c", ["          msg_putchar(' ');", "        if (menu->silent[bit])", "          msg_putchar('s');"], "readability/braces"]
["src/nvim/menu.c", ["          msg_putchar('s');", "        else", "          msg_putchar(' ');"], "readability/braces"]
["src/nvim/menu.c", ["          msg_putchar(' ');", "        if ((menu->modes & menu->enabled & (1 << bit)) == 0)", "          msg_putchar('-');"], "readability/braces"]
["src/nvim/menu.c", ["          msg_putchar('-');", "        else", "          msg_putchar(' ');"], "readability/braces"]
["src/nvim/menu.c", ["      depth--;", "    } else", "      menu = menu->children;"], "readability/braces"]
["src/nvim/menu.c", ["", "    /* recursively show all children.  Skip PopUp[nvoci]. */", "    for (; menu != NULL && !got_int; menu = menu->next)"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    /* recursively show all children.  Skip PopUp[nvoci]. */", "    for (; menu != NULL && !got_int; menu = menu->next)", "      if (!menu_is_hidden(menu->dname))"], "readability/braces"]
["src/nvim/menu.c", ["    for (; menu != NULL && !got_int; menu = menu->next)", "      if (!menu_is_hidden(menu->dname))", "        show_menus_recursive(menu, modes, depth + 1);"], "readability/braces"]
["src/nvim/menu.c", ["", "/*", " * Used when expanding menu names."], "readability/old_style_comment"]
["src/nvim/menu.c", ["static int expand_modes = 0x0;", "static int expand_emenu;                /* TRUE for \":emenu\" command */", ""], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "/*", " * Work out what to complete when doing command line completion of menu names."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /* Check for priority numbers, enable and disable */", "  for (p = arg; *p; ++p)"], "readability/old_style_comment"]
["src/nvim/menu.c", ["  /* Check for priority numbers, enable and disable */", "  for (p = arg; *p; ++p)", "    if (!ascii_isdigit(*p) && *p != '.')"], "readability/braces"]
["src/nvim/menu.c", ["  /* Check for priority numbers, enable and disable */", "  for (p = arg; *p; ++p)", "    if (!ascii_isdigit(*p) && *p != '.')"], "readability/increment"]
["src/nvim/menu.c", ["  for (p = arg; *p; ++p)", "    if (!ascii_isdigit(*p) && *p != '.')", "      break;"], "readability/braces"]
["src/nvim/menu.c", ["  if (!ascii_iswhite(*p)) {", "    if (STRNCMP(arg, \"enable\", 6) == 0", "        && (arg[6] == NUL ||  ascii_iswhite(arg[6])))"], "readability/braces"]
["src/nvim/menu.c", ["      p = arg + 6;", "    else if (STRNCMP(arg, \"disable\", 7) == 0", "             && (arg[7] == NUL || ascii_iswhite(arg[7])))"], "readability/braces"]
["src/nvim/menu.c", ["      p = arg + 7;", "    else", "      p = arg;"], "readability/braces"]
["src/nvim/menu.c", ["", "  while (*p != NUL && ascii_iswhite(*p))", "    ++p;"], "readability/braces"]
["src/nvim/menu.c", ["  while (*p != NUL && ascii_iswhite(*p))", "    ++p;", ""], "readability/increment"]
["src/nvim/menu.c", ["", "  for (; *p && !ascii_iswhite(*p); ++p) {", "    if ((*p == '\\\\' || *p == Ctrl_V) && p[1] != NUL)"], "readability/increment"]
["src/nvim/menu.c", ["  for (; *p && !ascii_iswhite(*p); ++p) {", "    if ((*p == '\\\\' || *p == Ctrl_V) && p[1] != NUL)", "      p++;"], "readability/braces"]
["src/nvim/menu.c", ["      p++;", "    else if (*p == '.')", "      after_dot = p + 1;"], "readability/braces"]
["src/nvim/menu.c", ["    expand_modes = get_menu_cmd_modes(cmd, forceit, NULL, &unmenu);", "    if (!unmenu)", "      expand_modes = MENU_ALL_MODES;"], "readability/braces"]
["src/nvim/menu.c", ["    if (after_dot > arg) {", "      size_t path_len = (size_t) (after_dot - arg);", "      path_name = xmalloc(path_len);"], "whitespace/cast"]
["src/nvim/menu.c", ["        if (menu_name_equal(name, menu)) {", "          /* Found menu */", "          if ((*p != NUL && menu->children == NULL)"], "readability/old_style_comment"]
["src/nvim/menu.c", ["              || ((menu->modes & expand_modes) == 0x0)) {", "            /*", "             * Menu path continues, but we have reached a leaf."], "readability/old_style_comment"]
["src/nvim/menu.c", ["      if (menu == NULL) {", "        /* No menu found with the name we were looking for */", "        xfree(path_name);"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the list of (sub)menus (not"], "readability/old_style_comment"]
["src/nvim/menu.c", ["  char_u              *str;", "  static int should_advance = FALSE;", ""], "readability/bool"]
["src/nvim/menu.c", ["", "  if (idx == 0) {           /* first call: start at first item */", "    menu = expand_menu;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /* Skip PopUp[nvoci]. */", "  while (menu != NULL && (menu_is_hidden(menu->dname)"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  if (menu == NULL)         /* at end of linked list */", "    return NULL;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  if (menu == NULL)         /* at end of linked list */", "    return NULL;"], "readability/braces"]
["src/nvim/menu.c", ["", "  if (menu->modes & expand_modes)", "    if (should_advance)"], "readability/braces"]
["src/nvim/menu.c", ["  if (menu->modes & expand_modes)", "    if (should_advance)", "      str = menu->en_dname;"], "readability/braces"]
["src/nvim/menu.c", ["      str = menu->en_dname;", "    else {", "      str = menu->dname;"], "readability/braces"]
["src/nvim/menu.c", ["      str = menu->en_dname;", "    else {", "      str = menu->dname;"], "readability/braces"]
["src/nvim/menu.c", ["      str = menu->dname;", "      if (menu->en_dname == NULL)", "        should_advance = TRUE;"], "readability/braces"]
["src/nvim/menu.c", ["      if (menu->en_dname == NULL)", "        should_advance = TRUE;", "    }"], "readability/bool"]
["src/nvim/menu.c", ["    }", "  else", "    str = (char_u *)\"\";"], "whitespace/newline"]
["src/nvim/menu.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the list of menus and menu"], "readability/old_style_comment"]
["src/nvim/menu.c", ["#define TBUFFER_LEN 256", "  static char_u tbuffer[TBUFFER_LEN];         /*hack*/", "  char_u              *str;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["  char_u              *str;", "  static int should_advance = FALSE;", ""], "readability/bool"]
["src/nvim/menu.c", ["", "  if (idx == 0) {           /* first call: start at first item */", "    menu = expand_menu;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /* Skip Browse-style entries, popup menus and separators. */", "  while (menu != NULL"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  if (menu == NULL)         /* at end of linked list */", "    return NULL;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  if (menu == NULL)         /* at end of linked list */", "    return NULL;"], "readability/braces"]
["src/nvim/menu.c", ["    if (menu->children != NULL) {", "      if (should_advance)", "        STRLCPY(tbuffer, menu->en_dname, TBUFFER_LEN - 1);"], "readability/braces"]
["src/nvim/menu.c", ["        STRLCPY(tbuffer, menu->en_dname, TBUFFER_LEN - 1);", "      else {", "        STRLCPY(tbuffer, menu->dname,  TBUFFER_LEN - 1);"], "readability/braces"]
["src/nvim/menu.c", ["        STRLCPY(tbuffer, menu->en_dname, TBUFFER_LEN - 1);", "      else {", "        STRLCPY(tbuffer, menu->dname,  TBUFFER_LEN - 1);"], "readability/braces"]
["src/nvim/menu.c", ["        STRLCPY(tbuffer, menu->dname,  TBUFFER_LEN - 1);", "        if (menu->en_dname == NULL)", "          should_advance = TRUE;"], "readability/braces"]
["src/nvim/menu.c", ["        if (menu->en_dname == NULL)", "          should_advance = TRUE;", "      }"], "readability/bool"]
["src/nvim/menu.c", ["      }", "      /* hack on menu separators:  use a 'magic' char for the separator", "       * so that '.' in names gets escaped properly */"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    } else {", "      if (should_advance)", "        str = menu->en_dname;"], "readability/braces"]
["src/nvim/menu.c", ["        str = menu->en_dname;", "      else {", "        str = menu->dname;"], "readability/braces"]
["src/nvim/menu.c", ["        str = menu->en_dname;", "      else {", "        str = menu->dname;"], "readability/braces"]
["src/nvim/menu.c", ["        str = menu->dname;", "        if (menu->en_dname == NULL)", "          should_advance = TRUE;"], "readability/braces"]
["src/nvim/menu.c", ["        if (menu->en_dname == NULL)", "          should_advance = TRUE;", "      }"], "readability/bool"]
["src/nvim/menu.c", ["    }", "  } else", "    str = (char_u *)\"\";"], "readability/braces"]
["src/nvim/menu.c", ["      STRMOVE(p, p + 1);", "      if (*p == NUL)", "        break;"], "readability/braces"]
["src/nvim/menu.c", ["  }", "  if (*p)", "    *p++ = NUL;"], "readability/braces"]
["src/nvim/menu.c", ["", "/*", " * Return TRUE when \"name\" matches with menu \"menu\".  The name is compared in"], "readability/old_style_comment"]
["src/nvim/menu.c", ["{", "  if (menu->en_name != NULL", "      && (menu_namecmp(name, menu->en_name)"], "readability/braces"]
["src/nvim/menu.c", ["", "  for (i = 0; name[i] != NUL && name[i] != TAB; ++i)", "    if (name[i] != mname[i])"], "readability/braces"]
["src/nvim/menu.c", ["", "  for (i = 0; name[i] != NUL && name[i] != TAB; ++i)", "    if (name[i] != mname[i])"], "readability/increment"]
["src/nvim/menu.c", ["  for (i = 0; name[i] != NUL && name[i] != TAB; ++i)", "    if (name[i] != mname[i])", "      break;"], "readability/braces"]
["src/nvim/menu.c", ["  switch (*cmd++) {", "  case 'v':                             /* vmenu, vunmenu, vnoremenu */", "    modes = MENU_VISUAL_MODE | MENU_SELECT_MODE;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    break;", "  case 'x':                             /* xmenu, xunmenu, xnoremenu */", "    modes = MENU_VISUAL_MODE;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    break;", "  case 's':                             /* smenu, sunmenu, snoremenu */", "    modes = MENU_SELECT_MODE;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    break;", "  case 'o':                             /* omenu */", "    modes = MENU_OP_PENDING_MODE;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    break;", "  case 'i':                             /* imenu */", "    modes = MENU_INSERT_MODE;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["  case 't':", "    modes = MENU_TIP_MODE;              /* tmenu */", "    break;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    break;", "  case 'c':                             /* cmenu */", "    modes = MENU_CMDLINE_MODE;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    break;", "  case 'a':                             /* amenu */", "    modes = MENU_INSERT_MODE | MENU_CMDLINE_MODE | MENU_NORMAL_MODE"], "readability/old_style_comment"]
["src/nvim/menu.c", ["  case 'n':", "    if (*cmd != 'o') {                  /* nmenu, not noremenu */", "      modes = MENU_NORMAL_MODE;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  if (noremap != NULL)", "    *noremap = (*cmd == 'n' ? REMAP_NONE : REMAP_YES);"], "readability/braces"]
["src/nvim/menu.c", ["    *noremap = (*cmd == 'n' ? REMAP_NONE : REMAP_YES);", "  if (unmenu != NULL)", "    *unmenu = (*cmd == 'u');"], "readability/braces"]
["src/nvim/menu.c", ["", "/*", " * Modify a menu name starting with \"PopUp\" to include the mode character."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /* Locate accelerator text, after the first TAB */", "  p = vim_strchr(str, TAB);"], "readability/old_style_comment"]
["src/nvim/menu.c", ["  if (p != NULL) {", "    if (actext != NULL)", "      *actext = vim_strsave(p + 1);"], "readability/braces"]
["src/nvim/menu.c", ["    text = vim_strnsave(str, (size_t)(p - str));", "  } else", "    text = vim_strsave(str);"], "readability/braces"]
["src/nvim/menu.c", ["", "  /* Find mnemonic characters \"&a\" and reduce \"&&\" to \"&\". */", "  for (p = text; p != NULL; ) {"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    if (p != NULL) {", "      if (p[1] == NUL)              /* trailing \"&\" */", "        break;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    if (p != NULL) {", "      if (p[1] == NUL)              /* trailing \"&\" */", "        break;"], "readability/braces"]
["src/nvim/menu.c", ["        break;", "      if (mnemonic != NULL && p[1] != '&')", "        *mnemonic = p[1];"], "readability/braces"]
["src/nvim/menu.c", ["", "/*", " * Return TRUE if the name is a menu separator identifier: Starts and ends"], "readability/old_style_comment"]
["src/nvim/menu.c", ["  } else if (get_real_state() & VISUAL) {", "    /* Detect real visual mode -- if we are really in visual mode we", "     * don't need to do any guesswork to figure out what the selection"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "    /* GEDDES: This is not perfect - but it is a", "     * quick way of detecting whether we are doing this from a"], "readability/old_style_comment"]
["src/nvim/menu.c", ["        && (curbuf->b_visual.vi_end.lnum) == eap->line2) {", "      /* Set it up for visual mode - equivalent to gv.  */", "      VIsual_mode = curbuf->b_visual.vi_mode;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    } else {", "      /* Set it up for line-wise visual mode */", "      VIsual_mode = 'V';"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "    /* Activate visual mode */", "    VIsual_active = TRUE;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    /* Activate visual mode */", "    VIsual_active = TRUE;", "    VIsual_reselect = TRUE;"], "readability/bool"]
["src/nvim/menu.c", ["    VIsual_active = TRUE;", "    VIsual_reselect = TRUE;", "    check_cursor();"], "readability/bool"]
["src/nvim/menu.c", ["", "    /* Adjust the cursor to make sure it is in the correct pos", "     * for exclusive mode */"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "/*", " * Translation of menu names.  Just a simple lookup table."], "readability/old_style_comment"]
["src/nvim/menu.c", ["typedef struct {", "  char_u      *from;            /* English name */", "  char_u      *from_noamp;      /* same, without '&' */"], "readability/old_style_comment"]
["src/nvim/menu.c", ["  char_u      *from;            /* English name */", "  char_u      *from_noamp;      /* same, without '&' */", "  char_u      *to;              /* translated name */"], "readability/old_style_comment"]
["src/nvim/menu.c", ["  char_u      *from_noamp;      /* same, without '&' */", "  char_u      *to;              /* translated name */", "} menutrans_T;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["#define FREE_MENUTRANS(mt) \\", "  menutrans_T* _mt = (mt); \\", "  xfree(_mt->from); \\"], "whitespace/operators"]
["src/nvim/menu.c", ["", "/*", " * \":menutrans\"."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  if (menutrans_ga.ga_itemsize == 0)", "    ga_init(&menutrans_ga, (int)sizeof(menutrans_T), 5);"], "readability/braces"]
["src/nvim/menu.c", ["", "  /*", "   * \":menutrans clear\": clear all translations."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "    /* Delete all \"menutrans_\" global variables. */", "    del_menutrans_vars();"], "readability/old_style_comment"]
["src/nvim/menu.c", ["  } else {", "    /* \":menutrans from to\": add translation */", "    from = arg;"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    arg = menu_skip_part(to);", "    if (arg == to)", "      EMSG(_(e_invarg));"], "readability/braces"]
["src/nvim/menu.c", ["      EMSG(_(e_invarg));", "    else {", "      from = vim_strsave(from);"], "readability/braces"]
["src/nvim/menu.c", ["      EMSG(_(e_invarg));", "    else {", "      from = vim_strsave(from);"], "readability/braces"]
["src/nvim/menu.c", ["      menu_unescape_name(to);", "      menutrans_T* tp = GA_APPEND_VIA_PTR(menutrans_T, &menutrans_ga);", "      tp->from = from;"], "whitespace/operators"]
["src/nvim/menu.c", ["", "/*", " * Find the character just after one part of a menu name."], "readability/old_style_comment"]
["src/nvim/menu.c", ["  while (*p != NUL && *p != '.' && !ascii_iswhite(*p)) {", "    if ((*p == '\\\\' || *p == Ctrl_V) && p[1] != NUL)", "      ++p;"], "readability/braces"]
["src/nvim/menu.c", ["    if ((*p == '\\\\' || *p == Ctrl_V) && p[1] != NUL)", "      ++p;", "    ++p;"], "readability/increment"]
["src/nvim/menu.c", ["      ++p;", "    ++p;", "  }"], "readability/increment"]
["src/nvim/menu.c", ["", "/*", " * Lookup part of a menu name in the translations."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /* Now try again while ignoring '&' characters. */", "  char_u c = name[len];"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "/*", " * Unescape the name in the translate dictionary table."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "/*", " * Isolate the menu name."], "readability/old_style_comment"]
["src/nvim/menu.c", ["  while (*arg && !ascii_iswhite(*arg)) {", "    if ((*arg == '\\\\' || *arg == Ctrl_V) && arg[1] != NUL)", "      arg++;"], "readability/braces"]
["src/nvim/menu.c", ["      arg++;", "    else if (STRNICMP(arg, \"<TAB>\", 5) == 0) {", "      *arg = TAB;"], "readability/braces"]
["src/nvim/menu.c", ["  }", "  if (*arg != NUL)", "    *arg++ = NUL;"], "readability/braces"]
