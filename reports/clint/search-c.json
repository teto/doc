["src/nvim/search.c", ["", "/*", " * search.c: code for normal mode searching commands"], "readability/old_style_comment"]
["src/nvim/search.c", ["#include <string.h>", "#include <limits.h>             /* for INT_MAX on MSVC */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["#endif", "/*", " * This file contains various searching-related routines. These fall into"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * String searches"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Two search patterns are remembered: One for the :substitute command and"], "readability/old_style_comment"]
["src/nvim/search.c", ["  // Last used search pattern", "  [0] = {NULL, true, false, 0, {'/', false, false, 0L}, NULL},", "  // Last used substitute pattern"], "whitespace/braces"]
["src/nvim/search.c", ["  // Last used search pattern", "  [0] = {NULL, true, false, 0, {'/', false, false, 0L}, NULL},", "  // Last used substitute pattern"], "whitespace/braces"]
["src/nvim/search.c", ["  // Last used substitute pattern", "  [1] = {NULL, true, false, 0, {'/', false, false, 0L}, NULL}", "};"], "whitespace/braces"]
["src/nvim/search.c", ["  // Last used substitute pattern", "  [1] = {NULL, true, false, 0, {'/', false, false, 0L}, NULL}", "};"], "whitespace/braces"]
["src/nvim/search.c", ["", "static int last_idx = 0;        /* index in spats[] for RE_LAST */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Type used by find_pattern_in_path() to remember which included files have"], "readability/old_style_comment"]
["src/nvim/search.c", ["typedef struct SearchedFile {", "  FILE        *fp;              /* File pointer */", "  char_u      *name;            /* Full name of file */"], "readability/old_style_comment"]
["src/nvim/search.c", ["  FILE        *fp;              /* File pointer */", "  char_u      *name;            /* Full name of file */", "  linenr_T lnum;                /* Line we were up to in file */"], "readability/old_style_comment"]
["src/nvim/search.c", ["  char_u      *name;            /* Full name of file */", "  linenr_T lnum;                /* Line we were up to in file */", "  int matched;                  /* Found a match in this file */"], "readability/old_style_comment"]
["src/nvim/search.c", ["  linenr_T lnum;                /* Line we were up to in file */", "  int matched;                  /* Found a match in this file */", "} SearchedFile;"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * translate search pattern for vim_regcomp()"], "readability/old_style_comment"]
["src/nvim/search.c", ["    int options,", "    regmmatch_T *regmatch          /* return: pattern and ignore-case flag */", ")"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  rc_did_emsg = FALSE;", "  magic = p_magic;"], "readability/bool"]
["src/nvim/search.c", ["", "  /*", "   * If no pattern given, use a previously defined pattern."], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (pat == NULL || *pat == NUL) {", "    if (pat_use == RE_LAST)", "      i = last_idx;"], "readability/braces"]
["src/nvim/search.c", ["      i = last_idx;", "    else", "      i = pat_use;"], "readability/braces"]
["src/nvim/search.c", ["      i = pat_use;", "    if (spats[i].pat == NULL) {         /* pattern was never defined */", "      if (pat_use == RE_SUBST)"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (spats[i].pat == NULL) {         /* pattern was never defined */", "      if (pat_use == RE_SUBST)", "        EMSG(_(e_nopresub));"], "readability/braces"]
["src/nvim/search.c", ["        EMSG(_(e_nopresub));", "      else", "        EMSG(_(e_noprevre));"], "readability/braces"]
["src/nvim/search.c", ["        EMSG(_(e_noprevre));", "      rc_did_emsg = TRUE;", "      return FAIL;"], "readability/bool"]
["src/nvim/search.c", ["    no_smartcase = spats[i].no_scs;", "  } else if (options & SEARCH_HIS)      /* put new pattern in history */", "    add_to_history(HIST_SEARCH, pat, TRUE, NUL);"], "readability/old_style_comment"]
["src/nvim/search.c", ["    no_smartcase = spats[i].no_scs;", "  } else if (options & SEARCH_HIS)      /* put new pattern in history */", "    add_to_history(HIST_SEARCH, pat, TRUE, NUL);"], "readability/braces"]
["src/nvim/search.c", ["  } else if (options & SEARCH_HIS)      /* put new pattern in history */", "    add_to_history(HIST_SEARCH, pat, TRUE, NUL);", ""], "readability/bool"]
["src/nvim/search.c", ["    xfree(mr_pattern);", "    mr_pattern_alloced = FALSE;", "  }"], "readability/bool"]
["src/nvim/search.c", ["    mr_pattern = reverse_text(pat);", "    mr_pattern_alloced = TRUE;", "  } else"], "readability/bool"]
["src/nvim/search.c", ["    mr_pattern_alloced = TRUE;", "  } else", "    mr_pattern = pat;"], "readability/braces"]
["src/nvim/search.c", ["", "  /*", "   * Save the currently used pattern in the appropriate place,"], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (!(options & SEARCH_KEEP) && !cmdmod.keeppatterns) {", "    /* search or global command */", "    if (pat_save == RE_SEARCH || pat_save == RE_BOTH)"], "readability/old_style_comment"]
["src/nvim/search.c", ["    /* search or global command */", "    if (pat_save == RE_SEARCH || pat_save == RE_BOTH)", "      save_re_pat(RE_SEARCH, pat, magic);"], "readability/braces"]
["src/nvim/search.c", ["      save_re_pat(RE_SEARCH, pat, magic);", "    /* substitute or global command */", "    if (pat_save == RE_SUBST || pat_save == RE_BOTH)"], "readability/old_style_comment"]
["src/nvim/search.c", ["    /* substitute or global command */", "    if (pat_save == RE_SUBST || pat_save == RE_BOTH)", "      save_re_pat(RE_SUBST, pat, magic);"], "readability/braces"]
["src/nvim/search.c", ["  regmatch->regprog = vim_regcomp(pat, magic ? RE_MAGIC : 0);", "  if (regmatch->regprog == NULL)", "    return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * Get search pattern used by search_regcomp()."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Reverse text into allocated memory."], "readability/old_style_comment"]
["src/nvim/search.c", ["{", "  /*", "   * Reverse the pattern."], "readability/old_style_comment"]
["src/nvim/search.c", ["    last_idx = idx;", "    /* If 'hlsearch' set and search pat changed: need redraw. */", "    if (p_hls)"], "readability/old_style_comment"]
["src/nvim/search.c", ["    /* If 'hlsearch' set and search pat changed: need redraw. */", "    if (p_hls)", "      redraw_all_later(SOME_VALID);"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * Save the search patterns, so they can be restored later."], "readability/old_style_comment"]
["src/nvim/search.c", ["    saved_spats[0] = spats[0];", "    if (spats[0].pat != NULL)", "      saved_spats[0].pat = vim_strsave(spats[0].pat);"], "readability/braces"]
["src/nvim/search.c", ["    saved_spats[1] = spats[1];", "    if (spats[1].pat != NULL)", "      saved_spats[1].pat = vim_strsave(spats[1].pat);"], "readability/braces"]
["src/nvim/search.c", ["    xfree(mr_pattern);", "    mr_pattern_alloced = FALSE;", "    mr_pattern = NULL;"], "readability/bool"]
["src/nvim/search.c", ["", "/*", " * Return TRUE when case should be ignored for search pattern \"pat\"."], "readability/old_style_comment"]
["src/nvim/search.c", ["{", "  return last_t_cmd == TRUE;", "}"], "readability/bool"]
["src/nvim/search.c", ["  lastc_bytelen = len;", "  if (len)", "    memcpy(lastc_bytes, s, len);"], "readability/braces"]
["src/nvim/search.c", ["    memcpy(lastc_bytes, s, len);", "  else", "    memset(lastc_bytes, 0, sizeof(lastc_bytes));"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * Reset search direction to forward.  For \"gd\" and \"gD\" commands."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Set the last search pattern.  For \":let @/ =\" and ShaDa file."], "readability/old_style_comment"]
["src/nvim/search.c", ["  free_spat(&spats[idx]);", "  /* An empty string means that nothing should be matched. */", "  if (*s == NUL)"], "readability/old_style_comment"]
["src/nvim/search.c", ["  /* An empty string means that nothing should be matched. */", "  if (*s == NUL)", "    spats[idx].pat = NULL;"], "readability/braces"]
["src/nvim/search.c", ["    spats[idx].pat = NULL;", "  else", "    spats[idx].pat = (char_u *) xstrdup((char *) s);"], "readability/braces"]
["src/nvim/search.c", ["  else", "    spats[idx].pat = (char_u *) xstrdup((char *) s);", "  spats[idx].timestamp = os_time();"], "whitespace/cast"]
["src/nvim/search.c", ["  spats[idx].magic = magic;", "  spats[idx].no_scs = FALSE;", "  spats[idx].off.dir = '/';"], "readability/bool"]
["src/nvim/search.c", ["  set_vv_searchforward();", "  spats[idx].off.line = FALSE;", "  spats[idx].off.end = FALSE;"], "readability/bool"]
["src/nvim/search.c", ["  spats[idx].off.line = FALSE;", "  spats[idx].off.end = FALSE;", "  spats[idx].off.off = 0;"], "readability/bool"]
["src/nvim/search.c", ["  spats[idx].off.off = 0;", "  if (setlast)", "    last_idx = idx;"], "readability/braces"]
["src/nvim/search.c", ["    saved_spats[idx] = spats[0];", "    if (spats[idx].pat == NULL)", "      saved_spats[idx].pat = NULL;"], "readability/braces"]
["src/nvim/search.c", ["      saved_spats[idx].pat = NULL;", "    else", "      saved_spats[idx].pat = vim_strsave(spats[idx].pat);"], "readability/braces"]
["src/nvim/search.c", ["  }", "  /* If 'hlsearch' set and search pat changed: need redraw. */", "  if (p_hls && idx == last_idx && !no_hlsearch)"], "readability/old_style_comment"]
["src/nvim/search.c", ["  /* If 'hlsearch' set and search pat changed: need redraw. */", "  if (p_hls && idx == last_idx && !no_hlsearch)", "    redraw_all_later(SOME_VALID);"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * Get a regexp program for the last used search pattern."], "readability/old_style_comment"]
["src/nvim/search.c", ["  }", "  ++emsg_off;           /* So it doesn't beep if bad expr */", "  (void)search_regcomp((char_u *)\"\", 0, last_idx, SEARCH_KEEP, regmatch);"], "readability/old_style_comment"]
["src/nvim/search.c", ["  }", "  ++emsg_off;           /* So it doesn't beep if bad expr */", "  (void)search_regcomp((char_u *)\"\", 0, last_idx, SEARCH_KEEP, regmatch);"], "readability/increment"]
["src/nvim/search.c", ["  (void)search_regcomp((char_u *)\"\", 0, last_idx, SEARCH_KEEP, regmatch);", "  --emsg_off;", "}"], "readability/increment"]
["src/nvim/search.c", ["  int found;", "  linenr_T lnum;                /* no init to shut up Apollo cc */", "  regmmatch_T regmatch;"], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (search_regcomp(pat, RE_SEARCH, pat_use,", "          (options & (SEARCH_HIS + SEARCH_KEEP)), &regmatch) == FAIL) {", "    if ((options & SEARCH_MSG) && !rc_did_emsg)"], "whitespace/alignment"]
["src/nvim/search.c", ["          (options & (SEARCH_HIS + SEARCH_KEEP)), &regmatch) == FAIL) {", "    if ((options & SEARCH_MSG) && !rc_did_emsg)", "      EMSG2(_(\"E383: Invalid search string: %s\"), mr_pattern);"], "readability/braces"]
["src/nvim/search.c", ["", "  /*", "   * find the string"], "readability/old_style_comment"]
["src/nvim/search.c", ["   */", "  called_emsg = FALSE;", "  do {  /* loop for count */"], "readability/bool"]
["src/nvim/search.c", ["  called_emsg = FALSE;", "  do {  /* loop for count */", "    // When not accepting a match at the start position set \"extra_col\" to a"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    start_pos = *pos;           /* remember start pos for detecting no match */", "    found = 0;                  /* default: not found */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    start_pos = *pos;           /* remember start pos for detecting no match */", "    found = 0;                  /* default: not found */", "    at_first_line = TRUE;       /* default: start in first line */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    found = 0;                  /* default: not found */", "    at_first_line = TRUE;       /* default: start in first line */", "    if (pos->lnum == 0) {       /* correct lnum for when starting in line 0 */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    found = 0;                  /* default: not found */", "    at_first_line = TRUE;       /* default: start in first line */", "    if (pos->lnum == 0) {       /* correct lnum for when starting in line 0 */"], "readability/bool"]
["src/nvim/search.c", ["    at_first_line = TRUE;       /* default: start in first line */", "    if (pos->lnum == 0) {       /* correct lnum for when starting in line 0 */", "      pos->lnum = 1;"], "readability/old_style_comment"]
["src/nvim/search.c", ["      pos->col = 0;", "      at_first_line = FALSE;        /* not in first line now */", "    }"], "readability/old_style_comment"]
["src/nvim/search.c", ["      pos->col = 0;", "      at_first_line = FALSE;        /* not in first line now */", "    }"], "readability/bool"]
["src/nvim/search.c", ["", "    /*", "     * Start searching in current line, unless searching backwards and"], "readability/old_style_comment"]
["src/nvim/search.c", ["      lnum = pos->lnum - 1;", "      at_first_line = FALSE;", "    } else"], "readability/bool"]
["src/nvim/search.c", ["      at_first_line = FALSE;", "    } else", "      lnum = pos->lnum;"], "readability/braces"]
["src/nvim/search.c", ["", "    for (loop = 0; loop <= 1; ++loop) {     /* loop twice if 'wrapscan' set */", "      for (; lnum > 0 && lnum <= buf->b_ml.ml_line_count;"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    for (loop = 0; loop <= 1; ++loop) {     /* loop twice if 'wrapscan' set */", "      for (; lnum > 0 && lnum <= buf->b_ml.ml_line_count;"], "readability/increment"]
["src/nvim/search.c", ["      for (; lnum > 0 && lnum <= buf->b_ml.ml_line_count;", "           lnum += dir, at_first_line = FALSE) {", "        /* Stop after checking \"stop_lnum\", if it's set. */"], "readability/bool"]
["src/nvim/search.c", ["           lnum += dir, at_first_line = FALSE) {", "        /* Stop after checking \"stop_lnum\", if it's set. */", "        if (stop_lnum != 0 && (dir == FORWARD"], "readability/old_style_comment"]
["src/nvim/search.c", ["        /* Stop after checking \"stop_lnum\", if it's set. */", "        if (stop_lnum != 0 && (dir == FORWARD", "                               ? lnum > stop_lnum : lnum < stop_lnum))"], "readability/braces"]
["src/nvim/search.c", ["          break;", "        /* Stop after passing the \"tm\" time limit. */", "        if (tm != NULL && profile_passed_limit(*tm))"], "readability/old_style_comment"]
["src/nvim/search.c", ["        /* Stop after passing the \"tm\" time limit. */", "        if (tm != NULL && profile_passed_limit(*tm))", "          break;"], "readability/braces"]
["src/nvim/search.c", ["        if (nmatched > 0) {", "          /* match may actually be in another line when using \\zs */", "          matchpos = regmatch.startpos[0];"], "readability/old_style_comment"]
["src/nvim/search.c", ["          submatch = first_submatch(&regmatch);", "          /* \"lnum\" may be past end of buffer for \"\\n\\zs\". */", "          if (lnum + matchpos.lnum > buf->b_ml.ml_line_count)"], "readability/old_style_comment"]
["src/nvim/search.c", ["          /* \"lnum\" may be past end of buffer for \"\\n\\zs\". */", "          if (lnum + matchpos.lnum > buf->b_ml.ml_line_count)", "            ptr = (char_u *)\"\";"], "readability/braces"]
["src/nvim/search.c", ["            ptr = (char_u *)\"\";", "          else", "            ptr = ml_get_buf(buf, lnum + matchpos.lnum, FALSE);"], "readability/braces"]
["src/nvim/search.c", ["          else", "            ptr = ml_get_buf(buf, lnum + matchpos.lnum, FALSE);", ""], "readability/bool"]
["src/nvim/search.c", ["", "          /*", "           * Forward search in the first line: match should be after"], "readability/old_style_comment"]
["src/nvim/search.c", ["          if (dir == FORWARD && at_first_line) {", "            match_ok = TRUE;", "            /*"], "readability/bool"]
["src/nvim/search.c", ["            match_ok = TRUE;", "            /*", "             * When the match starts in a next line it's certainly"], "readability/old_style_comment"]
["src/nvim/search.c", ["                          < (int)start_pos.col + extra_col))) {", "              /*", "               * If vi-compatible searching, continue at the end"], "readability/old_style_comment"]
["src/nvim/search.c", ["                if (nmatched > 1) {", "                  /* end is in next line, thus no match in", "                   * this line */"], "readability/old_style_comment"]
["src/nvim/search.c", ["                   * this line */", "                  match_ok = FALSE;", "                  break;"], "readability/bool"]
["src/nvim/search.c", ["            }", "            if (!match_ok)", "              continue;"], "readability/braces"]
["src/nvim/search.c", ["          if (dir == BACKWARD) {", "            /*", "             * Now, if there are multiple matches on this line,"], "readability/old_style_comment"]
["src/nvim/search.c", ["             */", "            match_ok = FALSE;", "            for (;; ) {"], "readability/bool"]
["src/nvim/search.c", ["            for (;; ) {", "              /* Remember a position that is before the start", "               * position, we use it if it's the last match in"], "readability/old_style_comment"]
["src/nvim/search.c", ["                submatch = first_submatch(&regmatch);", "              } else", "                break;"], "readability/braces"]
["src/nvim/search.c", ["", "            /*", "             * If there is only a match after the cursor, skip"], "readability/old_style_comment"]
["src/nvim/search.c", ["             */", "            if (!match_ok)", "              continue;"], "readability/braces"]
["src/nvim/search.c", ["", "          /* With the SEARCH_END option move to the last character", "           * of the match.  Don't do it for an empty match, end"], "readability/old_style_comment"]
["src/nvim/search.c", ["                   && matchpos.col == endpos.col)) {", "            /* For a match in the first column, set the position", "             * on the NUL in the previous line. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["            if (endpos.col == 0) {", "              if (pos->lnum > 1) {              /* just in case */", "                --pos->lnum;"], "readability/old_style_comment"]
["src/nvim/search.c", ["              if (pos->lnum > 1) {              /* just in case */", "                --pos->lnum;", "                pos->col = (colnr_T)STRLEN(ml_get_buf(buf,"], "readability/increment"]
["src/nvim/search.c", ["                pos->col = (colnr_T)STRLEN(ml_get_buf(buf,", "                        pos->lnum, FALSE));", "              }"], "whitespace/alignment"]
["src/nvim/search.c", ["                pos->col = (colnr_T)STRLEN(ml_get_buf(buf,", "                        pos->lnum, FALSE));", "              }"], "readability/bool"]
["src/nvim/search.c", ["", "          /* Set variables used for 'incsearch' highlighting. */", "          search_match_lines = endpos.lnum - matchpos.lnum;"], "readability/old_style_comment"]
["src/nvim/search.c", ["        }", "        line_breakcheck();              /* stop if ctrl-C typed */", "        if (got_int)"], "readability/old_style_comment"]
["src/nvim/search.c", ["        line_breakcheck();              /* stop if ctrl-C typed */", "        if (got_int)", "          break;"], "readability/braces"]
["src/nvim/search.c", ["", "        /* Cancel searching if a character was typed.  Used for", "         * 'incsearch'.  Don't check too often, that would slowdown"], "readability/old_style_comment"]
["src/nvim/search.c", ["            && char_avail()) {", "          break_loop = TRUE;", "          break;"], "readability/bool"]
["src/nvim/search.c", ["", "        if (loop && lnum == start_pos.lnum)", "          break;                    /* if second loop, stop where started */"], "readability/braces"]
["src/nvim/search.c", ["        if (loop && lnum == start_pos.lnum)", "          break;                    /* if second loop, stop where started */", "      }"], "readability/old_style_comment"]
["src/nvim/search.c", ["      }", "      at_first_line = FALSE;", ""], "readability/bool"]
["src/nvim/search.c", ["", "  if (!found) {             /* did not find it */", "    if (got_int)"], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (!found) {             /* did not find it */", "    if (got_int)", "      EMSG(_(e_interr));"], "readability/braces"]
["src/nvim/search.c", ["      EMSG(_(e_interr));", "    else if ((options & SEARCH_MSG) == SEARCH_MSG) {", "      if (p_ws)"], "readability/braces"]
["src/nvim/search.c", ["    else if ((options & SEARCH_MSG) == SEARCH_MSG) {", "      if (p_ws)", "        EMSG2(_(e_patnotf2), mr_pattern);"], "readability/braces"]
["src/nvim/search.c", ["        EMSG2(_(e_patnotf2), mr_pattern);", "      else if (lnum == 0)", "        EMSG2(_(\"E384: search hit TOP without match for: %s\"),"], "readability/braces"]
["src/nvim/search.c", ["        EMSG2(_(\"E384: search hit TOP without match for: %s\"),", "            mr_pattern);", "      else"], "whitespace/alignment"]
["src/nvim/search.c", ["            mr_pattern);", "      else", "        EMSG2(_(\"E385: search hit BOTTOM without match for: %s\"),"], "readability/braces"]
["src/nvim/search.c", ["        EMSG2(_(\"E385: search hit BOTTOM without match for: %s\"),", "            mr_pattern);", "    }"], "whitespace/alignment"]
["src/nvim/search.c", ["", "  /* A pattern like \"\\n\\zs\" may go past the last line. */", "  if (pos->lnum > buf->b_ml.ml_line_count) {"], "readability/old_style_comment"]
["src/nvim/search.c", ["    pos->lnum = buf->b_ml.ml_line_count;", "    pos->col = (int)STRLEN(ml_get_buf(buf, pos->lnum, FALSE));", "    if (pos->col > 0)"], "readability/bool"]
["src/nvim/search.c", ["    pos->col = (int)STRLEN(ml_get_buf(buf, pos->lnum, FALSE));", "    if (pos->col > 0)", "      --pos->col;"], "readability/braces"]
["src/nvim/search.c", ["    if (pos->col > 0)", "      --pos->col;", "  }"], "readability/increment"]
["src/nvim/search.c", ["", "  for (submatch = 1;; ++submatch) {", "    if (rp->startpos[submatch].lnum >= 0)"], "readability/increment"]
["src/nvim/search.c", ["  for (submatch = 1;; ++submatch) {", "    if (rp->startpos[submatch].lnum >= 0)", "      break;"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * Highest level string search function."], "readability/old_style_comment"]
["src/nvim/search.c", ["{", "  pos_T pos;                    /* position of the last match */", "  char_u          *searchstr;"], "readability/old_style_comment"]
["src/nvim/search.c", ["  struct soffset old_off;", "  int retval;                   /* Return value */", "  char_u          *p;"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * A line offset is not remembered, this is vi compatible."], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (spats[0].off.line && vim_strchr(p_cpo, CPO_LINEOFF) != NULL) {", "    spats[0].off.line = FALSE;", "    spats[0].off.off = 0;"], "readability/bool"]
["src/nvim/search.c", ["", "  /*", "   * Save the values for when (options & SEARCH_KEEP) is used."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  pos = curwin->w_cursor;       /* start searching at the cursor position */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * Find out the direction of the search."], "readability/old_style_comment"]
["src/nvim/search.c", ["   */", "  if (dirc == 0)", "    dirc = spats[0].off.dir;"], "readability/braces"]
["src/nvim/search.c", ["    dirc = spats[0].off.dir;", "  else {", "    spats[0].off.dir = dirc;"], "readability/braces"]
["src/nvim/search.c", ["    dirc = spats[0].off.dir;", "  else {", "    spats[0].off.dir = dirc;"], "readability/braces"]
["src/nvim/search.c", ["  if (options & SEARCH_REV) {", "    if (dirc == '/')", "      dirc = '?';"], "readability/braces"]
["src/nvim/search.c", ["      dirc = '?';", "    else", "      dirc = '/';"], "readability/braces"]
["src/nvim/search.c", ["", "  /* If the cursor is in a closed fold, don't find another match in the same", "   * fold. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (dirc == '/') {", "    if (hasFolding(pos.lnum, NULL, &pos.lnum))", "      pos.col = MAXCOL - 2;             /* avoid overflow when adding 1 */"], "readability/braces"]
["src/nvim/search.c", ["    if (hasFolding(pos.lnum, NULL, &pos.lnum))", "      pos.col = MAXCOL - 2;             /* avoid overflow when adding 1 */", "  } else {"], "readability/old_style_comment"]
["src/nvim/search.c", ["  } else {", "    if (hasFolding(pos.lnum, &pos.lnum, NULL))", "      pos.col = 0;"], "readability/braces"]
["src/nvim/search.c", ["", "  /*", "   * Turn 'hlsearch' highlighting back on."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * Repeat the search when pattern followed by ';', e.g. \"/foo/;?bar\"."], "readability/old_style_comment"]
["src/nvim/search.c", ["      } else {", "        /* make search_regcomp() use spats[RE_SEARCH].pat */", "        searchstr = (char_u *)\"\";"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    if (pat != NULL && *pat != NUL) {   /* look for (new) offset */", "      /*"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (pat != NULL && *pat != NUL) {   /* look for (new) offset */", "      /*", "       * Find end of regular expression."], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (strcopy != ps) {", "        /* made a copy of \"pat\" to change \"\\?\" to \"?\" */", "        searchcmdlen += (int)(STRLEN(pat) - STRLEN(strcopy));"], "readability/old_style_comment"]
["src/nvim/search.c", ["      }", "      spats[0].off.line = FALSE;", "      spats[0].off.end = FALSE;"], "readability/bool"]
["src/nvim/search.c", ["      spats[0].off.line = FALSE;", "      spats[0].off.end = FALSE;", "      spats[0].off.off = 0;"], "readability/bool"]
["src/nvim/search.c", ["      }", "      if (ascii_isdigit(*p) || *p == '+' || *p == '-') {      /* got an offset */", "        /* 'nr' or '+nr' or '-nr' */"], "readability/old_style_comment"]
["src/nvim/search.c", ["      }", "      if (ascii_isdigit(*p) || *p == '+' || *p == '-') {      /* got an offset */", "        /* 'nr' or '+nr' or '-nr' */"], "whitespace/line_length"]
["src/nvim/search.c", ["      if (ascii_isdigit(*p) || *p == '+' || *p == '-') {      /* got an offset */", "        /* 'nr' or '+nr' or '-nr' */", "        if (ascii_isdigit(*p) || ascii_isdigit(*(p + 1)))"], "readability/old_style_comment"]
["src/nvim/search.c", ["        /* 'nr' or '+nr' or '-nr' */", "        if (ascii_isdigit(*p) || ascii_isdigit(*(p + 1)))", "          spats[0].off.off = atol((char *)p);"], "readability/braces"]
["src/nvim/search.c", ["          spats[0].off.off = atol((char *)p);", "        else if (*p == '-')                 /* single '-' */", "          spats[0].off.off = -1;"], "readability/old_style_comment"]
["src/nvim/search.c", ["          spats[0].off.off = atol((char *)p);", "        else if (*p == '-')                 /* single '-' */", "          spats[0].off.off = -1;"], "readability/braces"]
["src/nvim/search.c", ["          spats[0].off.off = -1;", "        else                                /* single '+' */", "          spats[0].off.off = 1;"], "readability/old_style_comment"]
["src/nvim/search.c", ["          spats[0].off.off = -1;", "        else                                /* single '+' */", "          spats[0].off.off = 1;"], "readability/braces"]
["src/nvim/search.c", ["          spats[0].off.off = 1;", "        ++p;", "        while (ascii_isdigit(*p))           /* skip number */"], "readability/increment"]
["src/nvim/search.c", ["        ++p;", "        while (ascii_isdigit(*p))           /* skip number */", "          ++p;"], "readability/old_style_comment"]
["src/nvim/search.c", ["        ++p;", "        while (ascii_isdigit(*p))           /* skip number */", "          ++p;"], "readability/braces"]
["src/nvim/search.c", ["        while (ascii_isdigit(*p))           /* skip number */", "          ++p;", "      }"], "readability/increment"]
["src/nvim/search.c", ["", "      /* compute length of search command for get_address() */", "      searchcmdlen += (int)(p - pat);"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "      pat = p;                              /* put pat after search command */", "    }"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /*", "     * If there is a character offset, subtract it from the current"], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (spats[0].off.off > 0) {", "        for (c = spats[0].off.off; c; --c)", "          if (decl(&pos) == -1)"], "readability/braces"]
["src/nvim/search.c", ["      if (spats[0].off.off > 0) {", "        for (c = spats[0].off.off; c; --c)", "          if (decl(&pos) == -1)"], "readability/increment"]
["src/nvim/search.c", ["        for (c = spats[0].off.off; c; --c)", "          if (decl(&pos) == -1)", "            break;"], "readability/braces"]
["src/nvim/search.c", ["            break;", "        if (c) {                        /* at start of buffer */", "          pos.lnum = 0;                 /* allow lnum == 0 here */"], "readability/old_style_comment"]
["src/nvim/search.c", ["        if (c) {                        /* at start of buffer */", "          pos.lnum = 0;                 /* allow lnum == 0 here */", "          pos.col = MAXCOL;"], "readability/old_style_comment"]
["src/nvim/search.c", ["      } else {", "        for (c = spats[0].off.off; c; ++c)", "          if (incl(&pos) == -1)"], "readability/braces"]
["src/nvim/search.c", ["      } else {", "        for (c = spats[0].off.off; c; ++c)", "          if (incl(&pos) == -1)"], "readability/increment"]
["src/nvim/search.c", ["        for (c = spats[0].off.off; c; ++c)", "          if (incl(&pos) == -1)", "            break;"], "readability/braces"]
["src/nvim/search.c", ["            break;", "        if (c) {                        /* at end of buffer */", "          pos.lnum = curbuf->b_ml.ml_line_count + 1;"], "readability/old_style_comment"]
["src/nvim/search.c", ["    }", "    if (spats[0].off.end && oap != NULL)", "      oap->inclusive = true;        /* 'e' includes last character */"], "readability/braces"]
["src/nvim/search.c", ["    if (spats[0].off.end && oap != NULL)", "      oap->inclusive = true;        /* 'e' includes last character */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    retval = 1;                     /* pattern found */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /*", "     * Add character and/or line offset"], "readability/old_style_comment"]
["src/nvim/search.c", ["        c = pos.lnum + spats[0].off.off;", "        if (c < 1)", "          pos.lnum = 1;"], "readability/braces"]
["src/nvim/search.c", ["          pos.lnum = 1;", "        else if (c > curbuf->b_ml.ml_line_count)", "          pos.lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/search.c", ["          pos.lnum = curbuf->b_ml.ml_line_count;", "        else", "          pos.lnum = c;"], "readability/braces"]
["src/nvim/search.c", ["", "        retval = 2;                 /* pattern found, line offset added */", "      } else if (pos.col < MAXCOL - 2) {      /* just in case */"], "readability/old_style_comment"]
["src/nvim/search.c", ["        retval = 2;                 /* pattern found, line offset added */", "      } else if (pos.col < MAXCOL - 2) {      /* just in case */", "        /* to the right, check for end of file */"], "readability/old_style_comment"]
["src/nvim/search.c", ["      } else if (pos.col < MAXCOL - 2) {      /* just in case */", "        /* to the right, check for end of file */", "        c = spats[0].off.off;"], "readability/old_style_comment"]
["src/nvim/search.c", ["        if (c > 0) {", "          while (c-- > 0)", "            if (incl(&pos) == -1)"], "readability/braces"]
["src/nvim/search.c", ["          while (c-- > 0)", "            if (incl(&pos) == -1)", "              break;"], "readability/braces"]
["src/nvim/search.c", ["        }", "        /* to the left, check for start of file */", "        else {"], "readability/old_style_comment"]
["src/nvim/search.c", ["        /* to the left, check for start of file */", "        else {", "          while (c++ < 0)"], "whitespace/newline"]
["src/nvim/search.c", ["        /* to the left, check for start of file */", "        else {", "          while (c++ < 0)"], "readability/braces"]
["src/nvim/search.c", ["        else {", "          while (c++ < 0)", "            if (decl(&pos) == -1)"], "readability/braces"]
["src/nvim/search.c", ["          while (c++ < 0)", "            if (decl(&pos) == -1)", "              break;"], "readability/braces"]
["src/nvim/search.c", ["    }", "    ++pat;", "  }"], "readability/increment"]
["src/nvim/search.c", ["", "  if (options & SEARCH_MARK)", "    setpcmark();"], "readability/braces"]
["src/nvim/search.c", ["  curwin->w_cursor = pos;", "  curwin->w_set_curswant = TRUE;", ""], "readability/bool"]
["src/nvim/search.c", ["end_do_search:", "  if ((options & SEARCH_KEEP) || cmdmod.keeppatterns)", "    spats[0].off = old_off;"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * search_for_exact_line(buf, pos, dir, pat)"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  if (buf->b_ml.ml_line_count == 0)", "    return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["        pos->lnum = buf->b_ml.ml_line_count;", "        if (!shortmess(SHM_SEARCH))", "          give_warning((char_u *)_(top_bot_msg), true);"], "readability/braces"]
["src/nvim/search.c", ["        pos->lnum = 1;", "        if (!shortmess(SHM_SEARCH))", "          give_warning((char_u *)_(bot_top_msg), true);"], "readability/braces"]
["src/nvim/search.c", ["    }", "    if (pos->lnum == start)", "      break;"], "readability/braces"]
["src/nvim/search.c", ["      break;", "    if (start == 0)", "      start = pos->lnum;"], "readability/braces"]
["src/nvim/search.c", ["      start = pos->lnum;", "    ptr = ml_get_buf(buf, pos->lnum, FALSE);", "    p = skipwhite(ptr);"], "readability/bool"]
["src/nvim/search.c", ["    p = skipwhite(ptr);", "    pos->col = (colnr_T) (p - ptr);", ""], "whitespace/cast"]
["src/nvim/search.c", ["", "    /* when adding lines the matching line may be empty but it is not", "     * ignored because we are interested in the next line -- Acevedo */"], "readability/old_style_comment"]
["src/nvim/search.c", ["      assert(compl_length >= 0);", "      if ((p_ic ? mb_strnicmp(p, pat, (size_t)compl_length)", "           : STRNCMP(p, pat, compl_length)) == 0)"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * Character Searches"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Search for a character in a line.  If \"t_cmd\" is FALSE, move to the"], "readability/old_style_comment"]
["src/nvim/search.c", ["  int len;", "  int stop = TRUE;", ""], "readability/bool"]
["src/nvim/search.c", ["", "  if (c != NUL) {       /* normal search: remember args for repeat */", "    if (!KeyStuffed) {      /* don't remember when redoing */"], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (c != NUL) {       /* normal search: remember args for repeat */", "    if (!KeyStuffed) {      /* don't remember when redoing */", "      *lastc = c;"], "readability/old_style_comment"]
["src/nvim/search.c", ["    c = *lastc;", "    /* For multi-byte re-use last lastc_bytes[] and lastc_bytelen. */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /* Force a move of at least one char, so \";\" and \",\" will move the", "     * cursor, even if the cursor is right in front of char we are looking"], "readability/old_style_comment"]
["src/nvim/search.c", ["     * at. */", "    if (vim_strchr(p_cpo, CPO_SCOLON) == NULL && count == 1 && t_cmd)", "      stop = FALSE;"], "readability/braces"]
["src/nvim/search.c", ["    if (vim_strchr(p_cpo, CPO_SCOLON) == NULL && count == 1 && t_cmd)", "      stop = FALSE;", "  }"], "readability/bool"]
["src/nvim/search.c", ["", "  if (dir == BACKWARD)", "    cap->oap->inclusive = false;"], "readability/braces"]
["src/nvim/search.c", ["    cap->oap->inclusive = false;", "  else", "    cap->oap->inclusive = true;"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * \"Other\" Searches"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * findmatch - find the matching paren or brace"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Raw string start is found at linep[startpos.col - 1]."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * findmatchlimit -- find the matching paren or brace, if it exists within"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /* Direction to search when initc is '/', '*' or '#' */", "  if (flags & FM_BACKWARD)"], "readability/old_style_comment"]
["src/nvim/search.c", ["  /* Direction to search when initc is '/', '*' or '#' */", "  if (flags & FM_BACKWARD)", "    dir = BACKWARD;"], "readability/braces"]
["src/nvim/search.c", ["    dir = BACKWARD;", "  else if (flags & FM_FORWARD)", "    dir = FORWARD;"], "readability/braces"]
["src/nvim/search.c", ["    dir = FORWARD;", "  else", "    dir = 0;"], "readability/braces"]
["src/nvim/search.c", ["", "  /*", "   * if initc given, look in the table for the matching character"], "readability/old_style_comment"]
["src/nvim/search.c", ["    comment_dir = dir;", "    if (initc == '/')", "      ignore_cend = true;"], "readability/braces"]
["src/nvim/search.c", ["  } else {", "    /*", "     * Either initc is '#', or no initc was given and we need to look"], "readability/old_style_comment"]
["src/nvim/search.c", ["    } else {", "      /*", "       * initc was not given, must look for something to match under"], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (!cpo_match) {", "        /* Are we before or at #if, #else etc.? */", "        ptr = skipwhite(linep);"], "readability/old_style_comment"]
["src/nvim/search.c", ["          ptr = skipwhite(ptr + 1);", "          if (   STRNCMP(ptr, \"if\", 2) == 0", "                 || STRNCMP(ptr, \"endif\", 5) == 0"], "readability/braces"]
["src/nvim/search.c", ["          if (   STRNCMP(ptr, \"if\", 2) == 0", "                 || STRNCMP(ptr, \"endif\", 5) == 0", "                 || STRNCMP(ptr, \"el\", 2) == 0)"], "whitespace/alignment"]
["src/nvim/search.c", ["                 || STRNCMP(ptr, \"endif\", 5) == 0", "                 || STRNCMP(ptr, \"el\", 2) == 0)", "            hash_dir = 1;"], "whitespace/alignment"]
["src/nvim/search.c", ["        }", "        /* Are we on a comment? */", "        else if (linep[pos.col] == '/') {"], "readability/old_style_comment"]
["src/nvim/search.c", ["        /* Are we on a comment? */", "        else if (linep[pos.col] == '/') {", "          if (linep[pos.col + 1] == '*') {"], "whitespace/newline"]
["src/nvim/search.c", ["", "      /*", "       * If we are not on a comment or the # at the start of a line, then"], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (!hash_dir && !comment_dir) {", "        /*", "         * Find the brace under or after the cursor."], "readability/old_style_comment"]
["src/nvim/search.c", ["         */", "        if (linep[pos.col] == NUL && pos.col)", "          --pos.col;"], "readability/braces"]
["src/nvim/search.c", ["        if (linep[pos.col] == NUL && pos.col)", "          --pos.col;", "        for (;; ) {"], "readability/increment"]
["src/nvim/search.c", ["          initc = PTR2CHAR(linep + pos.col);", "          if (initc == NUL)", "            break;"], "readability/braces"]
["src/nvim/search.c", ["        if (!findc) {", "          /* no brace in the line, maybe use \"  #if\" then */", "          if (!cpo_match && *skipwhite(linep) == '#')"], "readability/old_style_comment"]
["src/nvim/search.c", ["          /* no brace in the line, maybe use \"  #if\" then */", "          if (!cpo_match && *skipwhite(linep) == '#')", "            hash_dir = 1;"], "readability/braces"]
["src/nvim/search.c", ["            hash_dir = 1;", "          else", "            return NULL;"], "readability/braces"]
["src/nvim/search.c", ["", "          /* Set \"match_escaped\" if there are an odd number of", "           * backslashes. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["           * backslashes. */", "          for (col = pos.col; check_prevcol(linep, col, '\\\\', &col); )", "            bslcnt++;"], "readability/braces"]
["src/nvim/search.c", ["    if (hash_dir) {", "      /*", "       * Look for matching #if, #else, #elif, or #endif"], "readability/old_style_comment"]
["src/nvim/search.c", ["        ptr = skipwhite(skipwhite(linep) + 1);", "        if (STRNCMP(ptr, \"if\", 2) == 0 || STRNCMP(ptr, \"el\", 2) == 0)", "          hash_dir = 1;"], "readability/braces"]
["src/nvim/search.c", ["          hash_dir = 1;", "        else if (STRNCMP(ptr, \"endif\", 5) == 0)", "          hash_dir = -1;"], "readability/braces"]
["src/nvim/search.c", ["          hash_dir = -1;", "        else", "          return NULL;"], "readability/braces"]
["src/nvim/search.c", ["        if (hash_dir > 0) {", "          if (pos.lnum == curbuf->b_ml.ml_line_count)", "            break;"], "readability/braces"]
["src/nvim/search.c", ["            break;", "        } else if (pos.lnum == 1)", "          break;"], "readability/braces"]
["src/nvim/search.c", ["        linep = ml_get(pos.lnum);", "        line_breakcheck();              /* check for CTRL-C typed */", "        ptr = skipwhite(linep);"], "readability/old_style_comment"]
["src/nvim/search.c", ["        ptr = skipwhite(linep);", "        if (*ptr != '#')", "          continue;"], "readability/braces"]
["src/nvim/search.c", ["          continue;", "        pos.col = (colnr_T) (ptr - linep);", "        ptr = skipwhite(ptr + 1);"], "whitespace/cast"]
["src/nvim/search.c", ["        if (hash_dir > 0) {", "          if (STRNCMP(ptr, \"if\", 2) == 0)", "            count++;"], "readability/braces"]
["src/nvim/search.c", ["            count++;", "          else if (STRNCMP(ptr, \"el\", 2) == 0) {", "            if (count == 0)"], "readability/braces"]
["src/nvim/search.c", ["          else if (STRNCMP(ptr, \"el\", 2) == 0) {", "            if (count == 0)", "              return &pos;"], "readability/braces"]
["src/nvim/search.c", ["          } else if (STRNCMP(ptr, \"endif\", 5) == 0) {", "            if (count == 0)", "              return &pos;"], "readability/braces"]
["src/nvim/search.c", ["          if (STRNCMP(ptr, \"if\", 2) == 0) {", "            if (count == 0)", "              return &pos;"], "readability/braces"]
["src/nvim/search.c", ["          } else if (initc == '#' && STRNCMP(ptr, \"el\", 2) == 0) {", "            if (count == 0)", "              return &pos;"], "readability/braces"]
["src/nvim/search.c", ["              return &pos;", "          } else if (STRNCMP(ptr, \"endif\", 5) == 0)", "            count++;"], "readability/braces"]
["src/nvim/search.c", ["", "  /* backward search: Check if this line contains a single-line comment */", "  if ((backwards && comment_dir)"], "readability/old_style_comment"]
["src/nvim/search.c", ["  /* backward search: Check if this line contains a single-line comment */", "  if ((backwards && comment_dir)", "      || lisp"], "readability/braces"]
["src/nvim/search.c", ["  while (!got_int) {", "    /*", "     * Go to the next position, forward or backward. We could use"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (backwards) {", "      /* char to match is inside of comment, don't search outside */", "      if (lispcomm && pos.col < (colnr_T)comment_col)"], "readability/old_style_comment"]
["src/nvim/search.c", ["      /* char to match is inside of comment, don't search outside */", "      if (lispcomm && pos.col < (colnr_T)comment_col)", "        break;"], "readability/braces"]
["src/nvim/search.c", ["        break;", "      if (pos.col == 0) {               /* at start of line, go to prev. one */", "        if (pos.lnum == 1)              /* start of file */"], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (pos.col == 0) {               /* at start of line, go to prev. one */", "        if (pos.lnum == 1)              /* start of file */", "          break;"], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (pos.col == 0) {               /* at start of line, go to prev. one */", "        if (pos.lnum == 1)              /* start of file */", "          break;"], "readability/braces"]
["src/nvim/search.c", ["          break;", "        --pos.lnum;", ""], "readability/increment"]
["src/nvim/search.c", ["", "        if (maxtravel > 0 && ++traveled > maxtravel)", "          break;"], "readability/braces"]
["src/nvim/search.c", ["        linep = ml_get(pos.lnum);", "        pos.col = (colnr_T)STRLEN(linep);         /* pos.col on trailing NUL */", "        do_quotes = -1;"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "        /* Check if this line contains a single-line comment */", "        if (comment_dir"], "readability/old_style_comment"]
["src/nvim/search.c", ["        /* Check if this line contains a single-line comment */", "        if (comment_dir", "            || lisp"], "readability/braces"]
["src/nvim/search.c", ["          comment_col = check_linecomment(linep);", "        /* skip comment */", "        if (lisp && comment_col != MAXCOL)"], "readability/old_style_comment"]
["src/nvim/search.c", ["        /* skip comment */", "        if (lisp && comment_col != MAXCOL)", "          pos.col = comment_col;"], "readability/braces"]
["src/nvim/search.c", ["      }", "    } else {                          /* forward search */", "      if (linep[pos.col] == NUL"], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (linep[pos.col] == NUL", "          /* at end of line, go to next one */", "          /* don't search for match in comment */"], "readability/old_style_comment"]
["src/nvim/search.c", ["          /* at end of line, go to next one */", "          /* don't search for match in comment */", "          || (lisp && comment_col != MAXCOL"], "readability/old_style_comment"]
["src/nvim/search.c", ["          ) {", "        if (pos.lnum == curbuf->b_ml.ml_line_count          /* end of file */", "            /* line is exhausted and comment with it,"], "readability/old_style_comment"]
["src/nvim/search.c", ["          ) {", "        if (pos.lnum == curbuf->b_ml.ml_line_count          /* end of file */", "            /* line is exhausted and comment with it,"], "readability/braces"]
["src/nvim/search.c", ["        if (pos.lnum == curbuf->b_ml.ml_line_count          /* end of file */", "            /* line is exhausted and comment with it,", "             * don't search for match in code */"], "readability/old_style_comment"]
["src/nvim/search.c", ["          break;", "        ++pos.lnum;", ""], "readability/increment"]
["src/nvim/search.c", ["", "        if (maxtravel && traveled++ > maxtravel)", "          break;"], "readability/braces"]
["src/nvim/search.c", ["        line_breakcheck();", "        if (lisp)           /* find comment pos in new line */", "          comment_col = check_linecomment(linep);"], "readability/old_style_comment"]
["src/nvim/search.c", ["        line_breakcheck();", "        if (lisp)           /* find comment pos in new line */", "          comment_col = check_linecomment(linep);"], "readability/braces"]
["src/nvim/search.c", ["    if (comment_dir) {", "      /* Note: comments do not nest, and we ignore quotes in them */", "      /* TODO: ignore comment brackets inside strings */"], "readability/old_style_comment"]
["src/nvim/search.c", ["      /* Note: comments do not nest, and we ignore quotes in them */", "      /* TODO: ignore comment brackets inside strings */", "      if (comment_dir == FORWARD) {"], "readability/old_style_comment"]
["src/nvim/search.c", ["        }", "      } else {    /* Searching backwards */", "        /*"], "readability/old_style_comment"]
["src/nvim/search.c", ["      } else {    /* Searching backwards */", "        /*", "         * A comment may contain / * or / /, it may also start or end"], "readability/old_style_comment"]
["src/nvim/search.c", ["         */", "        if (pos.col == 0)", "          continue;"], "readability/braces"]
["src/nvim/search.c", ["          continue;", "        else if (raw_string)", "        {"], "readability/braces"]
["src/nvim/search.c", ["        else if (raw_string)", "        {", "          if (linep[pos.col - 1] == 'R'"], "whitespace/braces"]
["src/nvim/search.c", ["        {", "          if (linep[pos.col - 1] == 'R'", "              && linep[pos.col] == '\"'"], "readability/braces"]
["src/nvim/search.c", ["              && vim_strchr(linep + pos.col + 1, '(') != NULL)", "          {", "            /* Possible start of raw string. Now that we have the"], "whitespace/braces"]
["src/nvim/search.c", ["          {", "            /* Possible start of raw string. Now that we have the", "             * delimiter we can check if it ends before where we"], "readability/old_style_comment"]
["src/nvim/search.c", ["             * raw string start. */", "            if (!find_rawstring_end(linep, &pos,", "                  count > 0 ? &match_pos : &curwin->w_cursor))"], "readability/braces"]
["src/nvim/search.c", ["            if (!find_rawstring_end(linep, &pos,", "                  count > 0 ? &match_pos : &curwin->w_cursor))", "            {"], "whitespace/alignment"]
["src/nvim/search.c", ["                  count > 0 ? &match_pos : &curwin->w_cursor))", "            {", "              count++;"], "whitespace/braces"]
["src/nvim/search.c", ["            }", "            linep = ml_get(pos.lnum); /* may have been released */", "          }"], "readability/old_style_comment"]
["src/nvim/search.c", ["        } else if (linep[pos.col - 1] == '*' && linep[pos.col] == '/') {", "          if (count > 0)", "            pos = match_pos;"], "readability/braces"]
["src/nvim/search.c", ["            pos = match_pos;", "          else if (pos.col > 1 && linep[pos.col - 2] == '/'", "                   && (int)pos.col <= comment_col)"], "readability/braces"]
["src/nvim/search.c", ["            pos.col -= 2;", "          else if (ignore_cend)", "            continue;"], "readability/braces"]
["src/nvim/search.c", ["            continue;", "          else", "            return NULL;"], "readability/braces"]
["src/nvim/search.c", ["", "    /*", "     * If smart matching ('cpoptions' does not contain '%'), braces inside"], "readability/old_style_comment"]
["src/nvim/search.c", ["     */", "    if (cpo_match)", "      do_quotes = 0;"], "readability/braces"]
["src/nvim/search.c", ["      do_quotes = 0;", "    else if (do_quotes == -1) {", "      /*"], "readability/braces"]
["src/nvim/search.c", ["    else if (do_quotes == -1) {", "      /*", "       * Count the number of quotes in the line, skipping \\\" and '\"'."], "readability/old_style_comment"]
["src/nvim/search.c", ["      at_start = do_quotes;", "      for (ptr = linep; *ptr; ++ptr) {", "        if (ptr == linep + pos.col + backwards)"], "readability/increment"]
["src/nvim/search.c", ["      for (ptr = linep; *ptr; ++ptr) {", "        if (ptr == linep + pos.col + backwards)", "          at_start = (do_quotes & 1);"], "readability/braces"]
["src/nvim/search.c", ["          at_start = (do_quotes & 1);", "        if (*ptr == '\"'", "            && (ptr == linep || ptr[-1] != '\\'' || ptr[1] != '\\''))"], "readability/braces"]
["src/nvim/search.c", ["            && (ptr == linep || ptr[-1] != '\\'' || ptr[1] != '\\''))", "          ++do_quotes;", "        if (*ptr == '\\\\' && ptr[1] != NUL)"], "readability/increment"]
["src/nvim/search.c", ["          ++do_quotes;", "        if (*ptr == '\\\\' && ptr[1] != NUL)", "          ++ptr;"], "readability/braces"]
["src/nvim/search.c", ["        if (*ptr == '\\\\' && ptr[1] != NUL)", "          ++ptr;", "      }"], "readability/increment"]
["src/nvim/search.c", ["      }", "      do_quotes &= 1;               /* result is 1 with even number of quotes */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["", "      /*", "       * If we find an uneven count, check current line and previous"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "          /* ml_get() only keeps one line, need to get linep again */", "          linep = ml_get(pos.lnum);"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /*", "     * If 'smartmatch' is set:"], "readability/old_style_comment"]
["src/nvim/search.c", ["    case NUL:", "      /* at end of line without trailing backslash, reset inquote */", "      if (pos.col == 0 || linep[pos.col - 1] != '\\\\') {"], "readability/old_style_comment"]
["src/nvim/search.c", ["    case '\"':", "      /* a quote that is preceded with an odd number of backslashes is", "       * ignored */"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "        for (col = pos.col - 1; col >= 0; --col)", "          if (linep[col] != '\\\\')"], "readability/braces"]
["src/nvim/search.c", ["", "        for (col = pos.col - 1; col >= 0; --col)", "          if (linep[col] != '\\\\')"], "readability/increment"]
["src/nvim/search.c", ["        for (col = pos.col - 1; col >= 0; --col)", "          if (linep[col] != '\\\\')", "            break;"], "readability/braces"]
["src/nvim/search.c", ["", "    /*", "     * If smart matching ('cpoptions' does not contain '%'):"], "readability/old_style_comment"]
["src/nvim/search.c", ["    default:", "      /*", "       * For Lisp skip over backslashed (), {} and []."], "readability/old_style_comment"]
["src/nvim/search.c", ["       */", "      if (curbuf->b_p_lisp", "          && vim_strchr((char_u *)\"(){}[]\", c) != NULL"], "readability/braces"]
["src/nvim/search.c", ["", "      /* Check for match outside of quotes, and inside of", "       * quotes when the start is also inside of quotes. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["        if (!cpo_bsl) {", "          for (col = pos.col; check_prevcol(linep, col, '\\\\', &col); )", "            bslcnt++;"], "readability/braces"]
["src/nvim/search.c", ["        }", "        /* Only accept a match when 'M' is in 'cpo' or when escaping", "         * is what we expect. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["        if (cpo_bsl || (bslcnt & 1) == match_escaped) {", "          if (c == initc)", "            count++;"], "readability/braces"]
["src/nvim/search.c", ["            count++;", "          else {", "            if (count == 0)"], "readability/braces"]
["src/nvim/search.c", ["            count++;", "          else {", "            if (count == 0)"], "readability/braces"]
["src/nvim/search.c", ["          else {", "            if (count == 0)", "              return &pos;"], "readability/braces"]
["src/nvim/search.c", ["  }", "  return (pos_T *)NULL;         /* never found it */", "}"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Check if line[] contains a / / comment."], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (curbuf->b_p_lisp) {", "    if (vim_strchr(p, ';') != NULL) {   /* there may be comments */", "      int in_str = FALSE;       /* inside of string */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (vim_strchr(p, ';') != NULL) {   /* there may be comments */", "      int in_str = FALSE;       /* inside of string */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (vim_strchr(p, ';') != NULL) {   /* there may be comments */", "      int in_str = FALSE;       /* inside of string */", ""], "readability/bool"]
["src/nvim/search.c", ["          if (in_str) {", "            if (*(p - 1) != '\\\\')             /* skip escaped quote */", "              in_str = FALSE;"], "readability/old_style_comment"]
["src/nvim/search.c", ["          if (in_str) {", "            if (*(p - 1) != '\\\\')             /* skip escaped quote */", "              in_str = FALSE;"], "readability/braces"]
["src/nvim/search.c", ["            if (*(p - 1) != '\\\\')             /* skip escaped quote */", "              in_str = FALSE;", "          } else if (p == line || ((p - line) >= 2"], "readability/bool"]
["src/nvim/search.c", ["              in_str = FALSE;", "          } else if (p == line || ((p - line) >= 2", "                                   /* skip #\\\" form */"], "readability/braces"]
["src/nvim/search.c", ["          } else if (p == line || ((p - line) >= 2", "                                   /* skip #\\\" form */", "                                   && *(p - 1) != '\\\\' && *(p - 2) != '#'))"], "readability/old_style_comment"]
["src/nvim/search.c", ["                                   && *(p - 1) != '\\\\' && *(p - 2) != '#'))", "            in_str = TRUE;", "        } else if (!in_str && ((p - line) < 2"], "readability/bool"]
["src/nvim/search.c", ["            in_str = TRUE;", "        } else if (!in_str && ((p - line) < 2", "                               || (*(p - 1) != '\\\\' && *(p - 2) != '#')))"], "readability/braces"]
["src/nvim/search.c", ["                               || (*(p - 1) != '\\\\' && *(p - 2) != '#')))", "          break;                /* found! */", "        ++p;"], "readability/old_style_comment"]
["src/nvim/search.c", ["          break;                /* found! */", "        ++p;", "      }"], "readability/increment"]
["src/nvim/search.c", ["      }", "    } else", "      p = NULL;"], "readability/braces"]
["src/nvim/search.c", ["      p = NULL;", "  } else", "    while ((p = vim_strchr(p, '/')) != NULL) {"], "readability/braces"]
["src/nvim/search.c", ["    while ((p = vim_strchr(p, '/')) != NULL) {", "      /* accept a double /, unless it's preceded with * and followed by *,", "       * because * / / * is an end and start of a C comment */"], "readability/old_style_comment"]
["src/nvim/search.c", ["       * because * / / * is an end and start of a C comment */", "      if (p[1] == '/' && (p == line || p[-1] != '*' || p[2] != '*'))", "        break;"], "readability/braces"]
["src/nvim/search.c", ["        break;", "      ++p;", "    }"], "readability/increment"]
["src/nvim/search.c", ["", "  if (p == NULL)", "    return MAXCOL;"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * Move cursor briefly to character matching the one under the cursor."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * Only show match for chars in the 'matchpairs' option."], "readability/old_style_comment"]
["src/nvim/search.c", ["   */", "  /* 'matchpairs' is \"x:y,x:y\" */", "  for (p = curbuf->b_p_mps; *p != NUL; ++p) {"], "readability/old_style_comment"]
["src/nvim/search.c", ["  /* 'matchpairs' is \"x:y,x:y\" */", "  for (p = curbuf->b_p_mps; *p != NUL; ++p) {", "    if (PTR2CHAR(p) == c && (curwin->w_p_rl ^ p_ri))"], "readability/increment"]
["src/nvim/search.c", ["  for (p = curbuf->b_p_mps; *p != NUL; ++p) {", "    if (PTR2CHAR(p) == c && (curwin->w_p_rl ^ p_ri))", "      break;"], "readability/braces"]
["src/nvim/search.c", ["  } else if (lpos->lnum >= curwin->w_topline", "      && lpos->lnum < curwin->w_botline) {", "    if (!curwin->w_p_wrap) {"], "whitespace/alignment"]
["src/nvim/search.c", ["      ui_flush();", "      /* Restore dollar_vcol(), because setcursor() may call curs_rows()", "       * which resets it if the matching position is in a previous line"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "      /*", "       * brief pause, unless 'm' is present in 'cpo' and a character is"], "readability/old_style_comment"]
["src/nvim/search.c", ["  pos = curwin->w_cursor;", "  if (dir == FORWARD)", "    func = incl;"], "readability/braces"]
["src/nvim/search.c", ["    func = incl;", "  else", "    func = decl;"], "readability/braces"]
["src/nvim/search.c", ["", "    for (;; ) {                 /* find end of sentence */", "      c = gchar_pos(&pos);"], "readability/old_style_comment"]
["src/nvim/search.c", ["      c = gchar_pos(&pos);", "      if (c == NUL || (pos.col == 0 && startPS(pos.lnum, NUL, FALSE))) {", "        if (dir == BACKWARD && pos.lnum != startlnum)"], "readability/bool"]
["src/nvim/search.c", ["      if (c == NUL || (pos.col == 0 && startPS(pos.lnum, NUL, FALSE))) {", "        if (dir == BACKWARD && pos.lnum != startlnum)", "          ++pos.lnum;"], "readability/braces"]
["src/nvim/search.c", ["        if (dir == BACKWARD && pos.lnum != startlnum)", "          ++pos.lnum;", "        break;"], "readability/increment"]
["src/nvim/search.c", ["        do", "          if ((c = inc(&tpos)) == -1)", "            break;"], "readability/braces"]
["src/nvim/search.c", ["            break;", "        while (vim_strchr((char_u *)\")]\\\"'\", c = gchar_pos(&tpos))", "               != NULL);"], "readability/braces"]
["src/nvim/search.c", ["        while (vim_strchr((char_u *)\")]\\\"'\", c = gchar_pos(&tpos))", "               != NULL);", "        if (c == -1  || (!cpo_J && (c == ' ' || c == '\\t')) || c == NUL"], "whitespace/empty_loop_body"]
["src/nvim/search.c", ["          pos = tpos;", "          if (gchar_pos(&pos) == NUL)           /* skip NUL at EOL */", "            inc(&pos);"], "readability/old_style_comment"]
["src/nvim/search.c", ["          pos = tpos;", "          if (gchar_pos(&pos) == NUL)           /* skip NUL at EOL */", "            inc(&pos);"], "readability/braces"]
["src/nvim/search.c", ["      if ((*func)(&pos) == -1) {", "        if (count)", "          return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["found:", "    /* skip white space */", "    while (!noskip && ((c = gchar_pos(&pos)) == ' ' || c == '\\t'))"], "readability/old_style_comment"]
["src/nvim/search.c", ["    /* skip white space */", "    while (!noskip && ((c = gchar_pos(&pos)) == ' ' || c == '\\t'))", "      if (incl(&pos) == -1)"], "readability/braces"]
["src/nvim/search.c", ["    while (!noskip && ((c = gchar_pos(&pos)) == ' ' || c == '\\t'))", "      if (incl(&pos) == -1)", "        break;"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * Find the next paragraph or section in direction 'dir'."], "readability/old_style_comment"]
["src/nvim/search.c", ["bool", "findpar (", "    bool *pincl,        /* Return: true if last char is to be included */"], "whitespace/parens"]
["src/nvim/search.c", ["findpar (", "    bool *pincl,        /* Return: true if last char is to be included */", "    int dir,"], "readability/old_style_comment"]
["src/nvim/search.c", ["  linenr_T curr;", "  bool did_skip;            /* true after separating lines have been skipped */", "  bool first;               /* true on first line */"], "readability/old_style_comment"]
["src/nvim/search.c", ["  bool did_skip;            /* true after separating lines have been skipped */", "  bool first;               /* true on first line */", "  linenr_T fold_first;      /* first line of a closed fold */"], "readability/old_style_comment"]
["src/nvim/search.c", ["  bool first;               /* true on first line */", "  linenr_T fold_first;      /* first line of a closed fold */", "  linenr_T fold_last;       /* last line of a closed fold */"], "readability/old_style_comment"]
["src/nvim/search.c", ["  linenr_T fold_first;      /* first line of a closed fold */", "  linenr_T fold_last;       /* last line of a closed fold */", "  bool fold_skipped;        /* true if a closed fold was skipped this"], "readability/old_style_comment"]
["src/nvim/search.c", ["  linenr_T fold_last;       /* last line of a closed fold */", "  bool fold_skipped;        /* true if a closed fold was skipped this", "                               iteration */"], "readability/multiline_comment"]
["src/nvim/search.c", ["  linenr_T fold_last;       /* last line of a closed fold */", "  bool fold_skipped;        /* true if a closed fold was skipped this", "                               iteration */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    for (first = true;; first = false) {", "      if (*ml_get(curr) != NUL)", "        did_skip = true;"], "readability/braces"]
["src/nvim/search.c", ["", "      /* skip folded lines */", "      fold_skipped = false;"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "      if (!first && did_skip && startPS(curr, what, both))", "        break;"], "readability/braces"]
["src/nvim/search.c", ["", "      if (fold_skipped)", "        curr -= dir;"], "readability/braces"]
["src/nvim/search.c", ["      if ((curr += dir) < 1 || curr > curbuf->b_ml.ml_line_count) {", "        if (count)", "          return false;"], "readability/braces"]
["src/nvim/search.c", ["  setpcmark();", "  if (both && *ml_get(curr) == '}')     /* include line with '}' */", "    ++curr;"], "readability/old_style_comment"]
["src/nvim/search.c", ["  setpcmark();", "  if (both && *ml_get(curr) == '}')     /* include line with '}' */", "    ++curr;"], "readability/braces"]
["src/nvim/search.c", ["  if (both && *ml_get(curr) == '}')     /* include line with '}' */", "    ++curr;", "  curwin->w_cursor.lnum = curr;"], "readability/increment"]
["src/nvim/search.c", ["    }", "  } else", "    curwin->w_cursor.col = 0;"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * check if the string 's' is a nroff macro that is in option 'opt'"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  for (macro = opt; macro[0]; ++macro) {", "    /* Accept two characters in the option being equal to two characters"], "readability/increment"]
["src/nvim/search.c", ["  for (macro = opt; macro[0]; ++macro) {", "    /* Accept two characters in the option being equal to two characters", "     * in the line.  A space in the option matches with a space in the"], "readability/old_style_comment"]
["src/nvim/search.c", ["     * line or the line having ended. */", "    if (       (macro[0] == s[0]", "                || (macro[0] == ' '"], "readability/braces"]
["src/nvim/search.c", ["                    && (s[0] == NUL || s[0] == ' ')))", "               && (macro[1] == s[1]", "                   || ((macro[1] == NUL || macro[1] == ' ')"], "whitespace/alignment"]
["src/nvim/search.c", ["      break;", "    ++macro;", "    if (macro[0] == NUL)"], "readability/increment"]
["src/nvim/search.c", ["    ++macro;", "    if (macro[0] == NUL)", "      break;"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * startPS: return TRUE if line 'lnum' is the start of a section or paragraph."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * The following routines do the word searches performed by the 'w', 'W',"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * To perform these searches, characters are placed into one of three"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "static int cls_bigword;         /* TRUE for \"W\", \"B\" or \"E\" */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * cls() - returns the class of character at curwin->w_cursor"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * fwd_word(count, type, eol) - move forward one word"], "readability/old_style_comment"]
["src/nvim/search.c", ["    long count,", "    int bigword,                /* \"W\", \"E\" or \"B\" */", "    int eol"], "readability/old_style_comment"]
["src/nvim/search.c", ["{", "  int sclass;               /* starting class */", "  int i;"], "readability/old_style_comment"]
["src/nvim/search.c", ["  while (--count >= 0) {", "    /* When inside a range of folded lines, move to the last char of the", "     * last line. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /*", "     * We always move at least one character, unless on the last"], "readability/old_style_comment"]
["src/nvim/search.c", ["    i = inc_cursor();", "    if (i == -1 || (i >= 1 && last_line))     /* started at last char in file */", "      return FAIL;"], "readability/old_style_comment"]
["src/nvim/search.c", ["    i = inc_cursor();", "    if (i == -1 || (i >= 1 && last_line))     /* started at last char in file */", "      return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["      return FAIL;", "    if (i >= 1 && eol && count == 0)          /* started at last char in line */", "      return OK;"], "readability/old_style_comment"]
["src/nvim/search.c", ["      return FAIL;", "    if (i >= 1 && eol && count == 0)          /* started at last char in line */", "      return OK;"], "readability/braces"]
["src/nvim/search.c", ["", "    /*", "     * Go one char past end of current word (if any)"], "readability/old_style_comment"]
["src/nvim/search.c", ["     */", "    if (sclass != 0)", "      while (cls() == sclass) {"], "readability/braces"]
["src/nvim/search.c", ["        i = inc_cursor();", "        if (i == -1 || (i >= 1 && eol && count == 0))", "          return OK;"], "readability/braces"]
["src/nvim/search.c", ["", "    /*", "     * go to next non-white"], "readability/old_style_comment"]
["src/nvim/search.c", ["    while (cls() == 0) {", "      /*", "       * We'll stop if we land on a blank line"], "readability/old_style_comment"]
["src/nvim/search.c", ["       */", "      if (curwin->w_cursor.col == 0 && *get_cursor_line_ptr() == NUL)", "        break;"], "readability/braces"]
["src/nvim/search.c", ["      i = inc_cursor();", "      if (i == -1 || (i >= 1 && eol && count == 0))", "        return OK;"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * bck_word() - move backward 'count' words"], "readability/old_style_comment"]
["src/nvim/search.c", ["{", "  int sclass;               /* starting class */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["  while (--count >= 0) {", "    /* When inside a range of folded lines, move to the first char of the", "     * first line. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["     * first line. */", "    if (hasFolding(curwin->w_cursor.lnum, &curwin->w_cursor.lnum, NULL))", "      curwin->w_cursor.col = 0;"], "readability/braces"]
["src/nvim/search.c", ["    sclass = cls();", "    if (dec_cursor() == -1)             /* started at start of file */", "      return FAIL;"], "readability/old_style_comment"]
["src/nvim/search.c", ["    sclass = cls();", "    if (dec_cursor() == -1)             /* started at start of file */", "      return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["    if (!stop || sclass == cls() || sclass == 0) {", "      /*", "       * Skip white space before the word."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "      /*", "       * Move backward to start of this word."], "readability/old_style_comment"]
["src/nvim/search.c", ["       */", "      if (skip_chars(cls(), BACKWARD))", "        return OK;"], "readability/braces"]
["src/nvim/search.c", ["", "    inc_cursor();                       /* overshot - forward one */", "finished:"], "readability/old_style_comment"]
["src/nvim/search.c", ["finished:", "    stop = FALSE;", "  }"], "readability/bool"]
["src/nvim/search.c", ["", "/*", " * end_word() - move to the end of the word"], "readability/old_style_comment"]
["src/nvim/search.c", ["{", "  int sclass;               /* starting class */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["  while (--count >= 0) {", "    /* When inside a range of folded lines, move to the last char of the", "     * last line. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    sclass = cls();", "    if (inc_cursor() == -1)", "      return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["", "    /*", "     * If we're in the middle of a word, we just have to move to the end"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (cls() == sclass && sclass != 0) {", "      /*", "       * Move forward to end of the current word"], "readability/old_style_comment"]
["src/nvim/search.c", ["       */", "      if (skip_chars(sclass, FORWARD))", "        return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["    } else if (!stop || sclass == 0) {", "      /*", "       * We were at the end of a word. Go to the end of the next word."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "      /*", "       * Move forward to the end of this word."], "readability/old_style_comment"]
["src/nvim/search.c", ["       */", "      if (skip_chars(cls(), FORWARD))", "        return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["    }", "    dec_cursor();                       /* overshot - one char backward */", "finished:"], "readability/old_style_comment"]
["src/nvim/search.c", ["finished:", "    stop = FALSE;                       /* we move only one word less */", "  }"], "readability/old_style_comment"]
["src/nvim/search.c", ["finished:", "    stop = FALSE;                       /* we move only one word less */", "  }"], "readability/bool"]
["src/nvim/search.c", ["", "/*", " * Move back to the end of the word."], "readability/old_style_comment"]
["src/nvim/search.c", ["    long count,", "    int bigword,                /* TRUE for \"B\" */", "    int eol                    /* TRUE: stop at end of line. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    int bigword,                /* TRUE for \"B\" */", "    int eol                    /* TRUE: stop at end of line. */", ")"], "readability/old_style_comment"]
["src/nvim/search.c", ["{", "  int sclass;               /* starting class */", "  int i;"], "readability/old_style_comment"]
["src/nvim/search.c", ["    sclass = cls();", "    if ((i = dec_cursor()) == -1)", "      return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["      return FAIL;", "    if (eol && i == 1)", "      return OK;"], "readability/braces"]
["src/nvim/search.c", ["", "    /*", "     * Move backward to before the start of this word."], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (sclass != 0) {", "      while (cls() == sclass)", "        if ((i = dec_cursor()) == -1 || (eol && i == 1))"], "readability/braces"]
["src/nvim/search.c", ["      while (cls() == sclass)", "        if ((i = dec_cursor()) == -1 || (eol && i == 1))", "          return OK;"], "readability/braces"]
["src/nvim/search.c", ["", "    /*", "     * Move backward to end of the previous word"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Skip a row of characters of the same class."], "readability/old_style_comment"]
["src/nvim/search.c", ["{", "  while (cls() == cclass)", "    if ((dir == FORWARD ? inc_cursor() : dec_cursor()) == -1)"], "readability/braces"]
["src/nvim/search.c", ["  while (cls() == cclass)", "    if ((dir == FORWARD ? inc_cursor() : dec_cursor()) == -1)", "      return TRUE;"], "readability/braces"]
["src/nvim/search.c", ["    if ((dir == FORWARD ? inc_cursor() : dec_cursor()) == -1)", "      return TRUE;", "  return FALSE;"], "readability/bool"]
["src/nvim/search.c", ["      return TRUE;", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/search.c", ["", "/*", " * Go back to the start of the word or the start of white space"], "readability/old_style_comment"]
["src/nvim/search.c", ["{", "  int sclass;                       /* starting class */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["  for (;; ) {", "    if (curwin->w_cursor.col == 0)          /* stop at start of line */", "      break;"], "readability/old_style_comment"]
["src/nvim/search.c", ["  for (;; ) {", "    if (curwin->w_cursor.col == 0)          /* stop at start of line */", "      break;"], "readability/braces"]
["src/nvim/search.c", ["    dec_cursor();", "    if (cls() != sclass) {                  /* stop at start of word */", "      inc_cursor();"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Skip count/2 sentences and count/2 separating white spaces."], "readability/old_style_comment"]
["src/nvim/search.c", ["    long count,", "    int at_start_sent              /* cursor is at start of sentence */", ")"], "readability/old_style_comment"]
["src/nvim/search.c", ["    findsent(FORWARD, 1L);", "    if (at_start_sent)", "      find_first_blank(&curwin->w_cursor);"], "readability/braces"]
["src/nvim/search.c", ["      find_first_blank(&curwin->w_cursor);", "    if (count == 0 || at_start_sent)", "      decl(&curwin->w_cursor);"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * Find word under cursor, cursor at end."], "readability/old_style_comment"]
["src/nvim/search.c", ["    long count,", "    int include,                    /* TRUE: include word and white space */", "    int bigword                    /* FALSE == word, TRUE == WORD */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    int include,                    /* TRUE: include word and white space */", "    int bigword                    /* FALSE == word, TRUE == WORD */", ")"], "readability/old_style_comment"]
["src/nvim/search.c", ["  bool inclusive = true;", "  int include_white = FALSE;", ""], "readability/bool"]
["src/nvim/search.c", ["", "  /* Correct cursor when 'selection' is exclusive */", "  if (VIsual_active && *p_sel == 'e' && lt(VIsual, curwin->w_cursor))"], "readability/old_style_comment"]
["src/nvim/search.c", ["  /* Correct cursor when 'selection' is exclusive */", "  if (VIsual_active && *p_sel == 'e' && lt(VIsual, curwin->w_cursor))", "    dec_cursor();"], "readability/braces"]
["src/nvim/search.c", ["", "  /*", "   * When Visual mode is not active, or when the VIsual area is only one"], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (!VIsual_active || equalpos(curwin->w_cursor, VIsual)) {", "    /*", "     * Go to start of current word or white space."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /*", "     * If the start is on white space, and white space should be included"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if ((cls() == 0) == include) {", "      if (end_word(1L, bigword, TRUE, TRUE) == FAIL)", "        return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["    if ((cls() == 0) == include) {", "      if (end_word(1L, bigword, TRUE, TRUE) == FAIL)", "        return FAIL;"], "readability/bool"]
["src/nvim/search.c", ["    } else {", "      /*", "       * If the start is not on white space, and white space should be"], "readability/old_style_comment"]
["src/nvim/search.c", ["       */", "      fwd_word(1L, bigword, TRUE);", "      if (curwin->w_cursor.col == 0)"], "readability/bool"]
["src/nvim/search.c", ["      fwd_word(1L, bigword, TRUE);", "      if (curwin->w_cursor.col == 0)", "        decl(&curwin->w_cursor);"], "readability/braces"]
["src/nvim/search.c", ["        decl(&curwin->w_cursor);", "      else", "        oneleft();"], "readability/braces"]
["src/nvim/search.c", ["", "      if (include)", "        include_white = TRUE;"], "readability/braces"]
["src/nvim/search.c", ["      if (include)", "        include_white = TRUE;", "    }"], "readability/bool"]
["src/nvim/search.c", ["    if (VIsual_active) {", "      /* should do something when inclusive == false ! */", "      VIsual = start_pos;"], "readability/old_style_comment"]
["src/nvim/search.c", ["      VIsual = start_pos;", "      redraw_curbuf_later(INVERTED);            /* update the inversion */", "    } else {"], "readability/old_style_comment"]
["src/nvim/search.c", ["    }", "    --count;", "  }"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * When count is still > 0, extend with more objects."], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (VIsual_active && lt(curwin->w_cursor, VIsual)) {", "      /*", "       * In Visual mode, with cursor at start: move cursor back."], "readability/old_style_comment"]
["src/nvim/search.c", ["       */", "      if (decl(&curwin->w_cursor) == -1)", "        return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["      if (include != (cls() != 0)) {", "        if (bck_word(1L, bigword, TRUE) == FAIL)", "          return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["      if (include != (cls() != 0)) {", "        if (bck_word(1L, bigword, TRUE) == FAIL)", "          return FAIL;"], "readability/bool"]
["src/nvim/search.c", ["      } else {", "        if (bckend_word(1L, bigword, TRUE) == FAIL)", "          return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["      } else {", "        if (bckend_word(1L, bigword, TRUE) == FAIL)", "          return FAIL;"], "readability/bool"]
["src/nvim/search.c", ["    } else {", "      /*", "       * Move cursor forward one word and/or white area."], "readability/old_style_comment"]
["src/nvim/search.c", ["       */", "      if (incl(&curwin->w_cursor) == -1)", "        return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["      if (include != (cls() == 0)) {", "        if (fwd_word(1L, bigword, TRUE) == FAIL && count > 1)", "          return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["      if (include != (cls() == 0)) {", "        if (fwd_word(1L, bigword, TRUE) == FAIL && count > 1)", "          return FAIL;"], "readability/bool"]
["src/nvim/search.c", ["          return FAIL;", "        /*", "         * If end is just past a new-line, we don't want to include"], "readability/old_style_comment"]
["src/nvim/search.c", ["         */", "        if (oneleft() == FAIL)", "          inclusive = false;"], "readability/braces"]
["src/nvim/search.c", ["      } else {", "        if (end_word(1L, bigword, TRUE, TRUE) == FAIL)", "          return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["      } else {", "        if (end_word(1L, bigword, TRUE, TRUE) == FAIL)", "          return FAIL;"], "readability/bool"]
["src/nvim/search.c", ["    }", "    --count;", "  }"], "readability/increment"]
["src/nvim/search.c", ["                        || (curwin->w_cursor.col == 0 && !inclusive))) {", "    /*", "     * If we don't include white space at the end, move the start"], "readability/old_style_comment"]
["src/nvim/search.c", ["     */", "    pos = curwin->w_cursor;     /* save cursor position */", "    curwin->w_cursor = start_pos;"], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (cls() == 0 && curwin->w_cursor.col > 0) {", "        if (VIsual_active)", "          VIsual = curwin->w_cursor;"], "readability/braces"]
["src/nvim/search.c", ["          VIsual = curwin->w_cursor;", "        else", "          oap->start = curwin->w_cursor;"], "readability/braces"]
["src/nvim/search.c", ["    }", "    curwin->w_cursor = pos;     /* put cursor back at end */", "  }"], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (VIsual_active) {", "    if (*p_sel == 'e' && inclusive && ltoreq(VIsual, curwin->w_cursor))", "      inc_cursor();"], "readability/braces"]
["src/nvim/search.c", ["      VIsual_mode = 'v';", "      redraw_cmdline = TRUE;                    /* show mode later */", "    }"], "readability/old_style_comment"]
["src/nvim/search.c", ["      VIsual_mode = 'v';", "      redraw_cmdline = TRUE;                    /* show mode later */", "    }"], "readability/bool"]
["src/nvim/search.c", ["    }", "  } else", "    oap->inclusive = inclusive;"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * Find sentence(s) under the cursor, cursor at end."], "readability/old_style_comment"]
["src/nvim/search.c", ["  pos = start_pos;", "  findsent(FORWARD, 1L);        /* Find start of next sentence. */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * When the Visual area is bigger than one character: Extend it."], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (lt(start_pos, VIsual)) {", "      /*", "       * Cursor at start of Visual area."], "readability/old_style_comment"]
["src/nvim/search.c", ["       */", "      at_start_sent = TRUE;", "      decl(&pos);"], "readability/bool"]
["src/nvim/search.c", ["        if (!ascii_iswhite(c)) {", "          at_start_sent = FALSE;", "          break;"], "readability/bool"]
["src/nvim/search.c", ["        findsent(BACKWARD, 1L);", "        if (equalpos(curwin->w_cursor, start_pos))", "          at_start_sent = TRUE;            /* exactly at start of sentence */"], "readability/braces"]
["src/nvim/search.c", ["        if (equalpos(curwin->w_cursor, start_pos))", "          at_start_sent = TRUE;            /* exactly at start of sentence */", "        else"], "readability/old_style_comment"]
["src/nvim/search.c", ["        if (equalpos(curwin->w_cursor, start_pos))", "          at_start_sent = TRUE;            /* exactly at start of sentence */", "        else"], "readability/bool"]
["src/nvim/search.c", ["          at_start_sent = TRUE;            /* exactly at start of sentence */", "        else", "          /* inside a sentence, go to its end (start of next) */"], "readability/braces"]
["src/nvim/search.c", ["        else", "          /* inside a sentence, go to its end (start of next) */", "          findsent(FORWARD, 1L);"], "readability/old_style_comment"]
["src/nvim/search.c", ["      }", "      if (include)              /* \"as\" gets twice as much as \"is\" */", "        count *= 2;"], "readability/old_style_comment"]
["src/nvim/search.c", ["      }", "      if (include)              /* \"as\" gets twice as much as \"is\" */", "        count *= 2;"], "readability/braces"]
["src/nvim/search.c", ["      while (count--) {", "        if (at_start_sent)", "          find_first_blank(&curwin->w_cursor);"], "readability/braces"]
["src/nvim/search.c", ["        c = gchar_cursor();", "        if (!at_start_sent || (!include && !ascii_iswhite(c)))", "          findsent(BACKWARD, 1L);"], "readability/braces"]
["src/nvim/search.c", ["    } else {", "      /*", "       * Cursor at end of Visual area."], "readability/old_style_comment"]
["src/nvim/search.c", ["      incl(&pos);", "      at_start_sent = TRUE;", "      if (!equalpos(pos, curwin->w_cursor)) {     /* not just before a sentence */"], "readability/bool"]
["src/nvim/search.c", ["      at_start_sent = TRUE;", "      if (!equalpos(pos, curwin->w_cursor)) {     /* not just before a sentence */", "        at_start_sent = FALSE;"], "readability/old_style_comment"]
["src/nvim/search.c", ["      at_start_sent = TRUE;", "      if (!equalpos(pos, curwin->w_cursor)) {     /* not just before a sentence */", "        at_start_sent = FALSE;"], "whitespace/line_length"]
["src/nvim/search.c", ["      if (!equalpos(pos, curwin->w_cursor)) {     /* not just before a sentence */", "        at_start_sent = FALSE;", "        while (lt(pos, curwin->w_cursor)) {"], "readability/bool"]
["src/nvim/search.c", ["          if (!ascii_iswhite(c)) {", "            at_start_sent = TRUE;", "            break;"], "readability/bool"]
["src/nvim/search.c", ["        }", "        if (at_start_sent)              /* in the sentence */", "          findsent(BACKWARD, 1L);"], "readability/old_style_comment"]
["src/nvim/search.c", ["        }", "        if (at_start_sent)              /* in the sentence */", "          findsent(BACKWARD, 1L);"], "readability/braces"]
["src/nvim/search.c", ["          findsent(BACKWARD, 1L);", "        else                    /* in/before white before a sentence */", "          curwin->w_cursor = start_pos;"], "readability/old_style_comment"]
["src/nvim/search.c", ["          findsent(BACKWARD, 1L);", "        else                    /* in/before white before a sentence */", "          curwin->w_cursor = start_pos;"], "readability/braces"]
["src/nvim/search.c", ["", "      if (include)              /* \"as\" gets twice as much as \"is\" */", "        count *= 2;"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "      if (include)              /* \"as\" gets twice as much as \"is\" */", "        count *= 2;"], "readability/braces"]
["src/nvim/search.c", ["      findsent_forward(count, at_start_sent);", "      if (*p_sel == 'e')", "        ++curwin->w_cursor.col;"], "readability/braces"]
["src/nvim/search.c", ["      if (*p_sel == 'e')", "        ++curwin->w_cursor.col;", "    }"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * If the cursor started on a blank, check if it is just before the start"], "readability/old_style_comment"]
["src/nvim/search.c", ["   */", "  while (c = gchar_pos(&pos), ascii_iswhite(c))", "    incl(&pos);"], "readability/braces"]
["src/nvim/search.c", ["  if (equalpos(pos, curwin->w_cursor)) {", "    start_blank = TRUE;", "    find_first_blank(&start_pos);       /* go back to first blank */"], "readability/bool"]
["src/nvim/search.c", ["    start_blank = TRUE;", "    find_first_blank(&start_pos);       /* go back to first blank */", "  } else {"], "readability/old_style_comment"]
["src/nvim/search.c", ["  } else {", "    start_blank = FALSE;", "    findsent(BACKWARD, 1L);"], "readability/bool"]
["src/nvim/search.c", ["  }", "  if (include)", "    ncount = count * 2;"], "readability/braces"]
["src/nvim/search.c", ["    ncount = count * 2;", "  else {", "    ncount = count;"], "readability/braces"]
["src/nvim/search.c", ["    ncount = count * 2;", "  else {", "    ncount = count;"], "readability/braces"]
["src/nvim/search.c", ["    ncount = count;", "    if (start_blank)", "      --ncount;"], "readability/braces"]
["src/nvim/search.c", ["    if (start_blank)", "      --ncount;", "  }"], "readability/increment"]
["src/nvim/search.c", ["  }", "  if (ncount > 0)", "    findsent_forward(ncount, TRUE);"], "readability/braces"]
["src/nvim/search.c", ["  if (ncount > 0)", "    findsent_forward(ncount, TRUE);", "  else"], "readability/bool"]
["src/nvim/search.c", ["    findsent_forward(ncount, TRUE);", "  else", "    decl(&curwin->w_cursor);"], "readability/braces"]
["src/nvim/search.c", ["  if (include) {", "    /*", "     * If the blank in front of the sentence is included, exclude the"], "readability/old_style_comment"]
["src/nvim/search.c", ["      c = gchar_pos(&curwin->w_cursor);", "      if (ascii_iswhite(c))", "        decl(&curwin->w_cursor);"], "readability/braces"]
["src/nvim/search.c", ["        decl(&curwin->w_cursor);", "    } else if (c = gchar_cursor(), !ascii_iswhite(c))", "      find_first_blank(&start_pos);"], "readability/braces"]
["src/nvim/search.c", ["  if (VIsual_active) {", "    /* Avoid getting stuck with \"is\" on a single space before a sentence. */", "    if (equalpos(start_pos, curwin->w_cursor))"], "readability/old_style_comment"]
["src/nvim/search.c", ["    /* Avoid getting stuck with \"is\" on a single space before a sentence. */", "    if (equalpos(start_pos, curwin->w_cursor))", "      goto extend;"], "readability/braces"]
["src/nvim/search.c", ["      goto extend;", "    if (*p_sel == 'e')", "      ++curwin->w_cursor.col;"], "readability/braces"]
["src/nvim/search.c", ["    if (*p_sel == 'e')", "      ++curwin->w_cursor.col;", "    VIsual = start_pos;"], "readability/increment"]
["src/nvim/search.c", ["  } else {", "    /* include a newline after the sentence, if there is one */", "    if (incl(&curwin->w_cursor) == -1)"], "readability/old_style_comment"]
["src/nvim/search.c", ["    /* include a newline after the sentence, if there is one */", "    if (incl(&curwin->w_cursor) == -1)", "      oap->inclusive = true;"], "readability/braces"]
["src/nvim/search.c", ["      oap->inclusive = true;", "    else", "      oap->inclusive = false;"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * Find block under the cursor, cursor at end."], "readability/old_style_comment"]
["src/nvim/search.c", ["    long count,", "    int include,                    /* TRUE == include white space */", "    int what,                       /* '(', '{', etc. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    int include,                    /* TRUE == include white space */", "    int what,                       /* '(', '{', etc. */", "    int other                      /* ')', '}', etc. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    int what,                       /* '(', '{', etc. */", "    int other                      /* ')', '}', etc. */", ")"], "readability/old_style_comment"]
["src/nvim/search.c", ["  char_u      *save_cpo;", "  int sol = FALSE;                      /* '{' at start of line */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["  char_u      *save_cpo;", "  int sol = FALSE;                      /* '{' at start of line */", ""], "readability/bool"]
["src/nvim/search.c", ["  old_pos = curwin->w_cursor;", "  old_end = curwin->w_cursor;           /* remember where we started */", "  old_start = old_end;"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * If we start on '(', '{', ')', '}', etc., use the whole block inclusive."], "readability/old_style_comment"]
["src/nvim/search.c", ["    setpcmark();", "    if (what == '{')                    /* ignore indent */", "      while (inindent(1))"], "readability/old_style_comment"]
["src/nvim/search.c", ["    setpcmark();", "    if (what == '{')                    /* ignore indent */", "      while (inindent(1))"], "readability/braces"]
["src/nvim/search.c", ["    if (what == '{')                    /* ignore indent */", "      while (inindent(1))", "        if (inc_cursor() != 0)"], "readability/braces"]
["src/nvim/search.c", ["      while (inindent(1))", "        if (inc_cursor() != 0)", "          break;"], "readability/braces"]
["src/nvim/search.c", ["          break;", "    if (gchar_cursor() == what)", "      /* cursor on '(' or '{', move cursor just after it */"], "readability/braces"]
["src/nvim/search.c", ["    if (gchar_cursor() == what)", "      /* cursor on '(' or '{', move cursor just after it */", "      ++curwin->w_cursor.col;"], "readability/old_style_comment"]
["src/nvim/search.c", ["      /* cursor on '(' or '{', move cursor just after it */", "      ++curwin->w_cursor.col;", "  } else if (lt(VIsual, curwin->w_cursor)) {"], "readability/increment"]
["src/nvim/search.c", ["    old_start = VIsual;", "    curwin->w_cursor = VIsual;              /* cursor at low end of Visual */", "  } else"], "readability/old_style_comment"]
["src/nvim/search.c", ["    curwin->w_cursor = VIsual;              /* cursor at low end of Visual */", "  } else", "    old_end = VIsual;"], "readability/braces"]
["src/nvim/search.c", ["", "  /*", "   * Search for matching ')', '}', etc."], "readability/old_style_comment"]
["src/nvim/search.c", ["    while (inindent(1)) {", "      sol = TRUE;", "      if (decl(&curwin->w_cursor) != 0) {"], "readability/bool"]
["src/nvim/search.c", ["", "    /*", "     * In Visual mode, when the resulting area is not bigger than what we"], "readability/old_style_comment"]
["src/nvim/search.c", ["      curwin->w_cursor = *end_pos;", "    } else", "      break;"], "readability/braces"]
["src/nvim/search.c", ["    VIsual_mode = 'v';", "    redraw_curbuf_later(INVERTED);      /* update the inversion */", "    showmode();"], "readability/old_style_comment"]
["src/nvim/search.c", ["    oap->inclusive = false;", "    if (sol)", "      incl(&curwin->w_cursor);"], "readability/braces"]
["src/nvim/search.c", ["      incl(&curwin->w_cursor);", "    else if (ltoreq(start_pos, curwin->w_cursor))", "      /* Include the character under the cursor. */"], "readability/braces"]
["src/nvim/search.c", ["    else if (ltoreq(start_pos, curwin->w_cursor))", "      /* Include the character under the cursor. */", "      oap->inclusive = true;"], "readability/old_style_comment"]
["src/nvim/search.c", ["      oap->inclusive = true;", "    else", "      /* End is before the start (no text in between <>, [], etc.): don't"], "readability/braces"]
["src/nvim/search.c", ["    else", "      /* End is before the start (no text in between <>, [], etc.): don't", "       * operate on any text. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Return TRUE if the cursor is on a \"<aaa>\" tag.  Ignore \"<aaa/>\"."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /* check that there is no '/' after the '<' */", "  if (*p == '/')"], "readability/old_style_comment"]
["src/nvim/search.c", ["  /* check that there is no '/' after the '<' */", "  if (*p == '/')", "    return FALSE;"], "readability/braces"]
["src/nvim/search.c", ["  if (*p == '/')", "    return FALSE;", ""], "readability/bool"]
["src/nvim/search.c", ["", "  /* check that the matching '>' is not preceded by '/' */", "  for (;; ) {"], "readability/old_style_comment"]
["src/nvim/search.c", ["  for (;; ) {", "    if (inc(&pos) < 0)", "      return FALSE;"], "readability/braces"]
["src/nvim/search.c", ["    if (inc(&pos) < 0)", "      return FALSE;", "    c = *ml_get_pos(&pos);"], "readability/bool"]
["src/nvim/search.c", ["    c = *ml_get_pos(&pos);", "    if (c == '>')", "      break;"], "readability/braces"]
["src/nvim/search.c", ["", "/*", " * Find tag block under the cursor, cursor at end."], "readability/old_style_comment"]
["src/nvim/search.c", ["  old_pos = curwin->w_cursor;", "  old_end = curwin->w_cursor;               /* remember where we started */", "  old_start = old_end;"], "readability/old_style_comment"]
["src/nvim/search.c", ["  old_start = old_end;", "  if (!VIsual_active || *p_sel == 'e')", "    decl(&old_end);                         /* old_end is inclusive */"], "readability/braces"]
["src/nvim/search.c", ["  if (!VIsual_active || *p_sel == 'e')", "    decl(&old_end);                         /* old_end is inclusive */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * If we start on \"<aaa>\" select that block."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /* ignore indent */", "    while (inindent(1))"], "readability/old_style_comment"]
["src/nvim/search.c", ["    /* ignore indent */", "    while (inindent(1))", "      if (inc_cursor() != 0)"], "readability/braces"]
["src/nvim/search.c", ["    while (inindent(1))", "      if (inc_cursor() != 0)", "        break;"], "readability/braces"]
["src/nvim/search.c", ["", "    if (in_html_tag(FALSE)) {", "      /* cursor on start tag, move to its '>' */"], "readability/bool"]
["src/nvim/search.c", ["    if (in_html_tag(FALSE)) {", "      /* cursor on start tag, move to its '>' */", "      while (*get_cursor_pos_ptr() != '>')"], "readability/old_style_comment"]
["src/nvim/search.c", ["      /* cursor on start tag, move to its '>' */", "      while (*get_cursor_pos_ptr() != '>')", "        if (inc_cursor() < 0)"], "readability/braces"]
["src/nvim/search.c", ["      while (*get_cursor_pos_ptr() != '>')", "        if (inc_cursor() < 0)", "          break;"], "readability/braces"]
["src/nvim/search.c", ["          break;", "    } else if (in_html_tag(TRUE)) {", "      /* cursor on end tag, move to just before it */"], "readability/bool"]
["src/nvim/search.c", ["    } else if (in_html_tag(TRUE)) {", "      /* cursor on end tag, move to just before it */", "      while (*get_cursor_pos_ptr() != '<')"], "readability/old_style_comment"]
["src/nvim/search.c", ["      /* cursor on end tag, move to just before it */", "      while (*get_cursor_pos_ptr() != '<')", "        if (dec_cursor() < 0)"], "readability/braces"]
["src/nvim/search.c", ["      while (*get_cursor_pos_ptr() != '<')", "        if (dec_cursor() < 0)", "          break;"], "readability/braces"]
["src/nvim/search.c", ["    old_start = VIsual;", "    curwin->w_cursor = VIsual;              /* cursor at low end of Visual */", "  } else"], "readability/old_style_comment"]
["src/nvim/search.c", ["    curwin->w_cursor = VIsual;              /* cursor at low end of Visual */", "  } else", "    old_end = VIsual;"], "readability/braces"]
["src/nvim/search.c", ["again:", "  /*", "   * Search backwards for unclosed \"<aaa>\"."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * Search for matching \"</aaa>\".  First isolate the \"aaa\"."], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (r < 1 || lt(curwin->w_cursor, old_end)) {", "    /* Can't find other end or it's before the previous end.  Could be a", "     * HTML tag that doesn't have a matching end.  Search backwards for"], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (!do_include) {", "    /* Exclude the start tag. */", "    curwin->w_cursor = start_pos;"], "readability/old_style_comment"]
["src/nvim/search.c", ["    curwin->w_cursor = start_pos;", "    while (inc_cursor() >= 0)", "      if (*get_cursor_pos_ptr() == '>') {"], "readability/braces"]
["src/nvim/search.c", ["  if (VIsual_active) {", "    /* If the end is before the start there is no text between tags, select", "     * the char under the cursor. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    VIsual_mode = 'v';", "    redraw_curbuf_later(INVERTED);      /* update the inversion */", "    showmode();"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (lt(end_pos, start_pos)) {", "      /* End is before the start: there is no text between tags; operate", "       * on an empty area. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    long count,", "    int include,                    /* TRUE == include white space */", "    int type                       /* 'p' for paragraph, 'S' for section */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    int include,                    /* TRUE == include white space */", "    int type                       /* 'p' for paragraph, 'S' for section */", ")"], "readability/old_style_comment"]
["src/nvim/search.c", ["  int retval = OK;", "  int do_white = FALSE;", "  int t;"], "readability/bool"]
["src/nvim/search.c", ["", "  if (type == 'S')          /* not implemented yet */", "    return FAIL;"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  if (type == 'S')          /* not implemented yet */", "    return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["", "  /*", "   * When visual area is more than one line: extend it."], "readability/old_style_comment"]
["src/nvim/search.c", ["extend:", "    if (start_lnum < VIsual.lnum)", "      dir = BACKWARD;"], "readability/braces"]
["src/nvim/search.c", ["      dir = BACKWARD;", "    else", "      dir = FORWARD;"], "readability/braces"]
["src/nvim/search.c", ["      prev_start_is_white = -1;", "      for (t = 0; t < 2; ++t) {", "        start_lnum += dir;"], "readability/increment"]
["src/nvim/search.c", ["        for (;; ) {", "          if (start_lnum == (dir == BACKWARD", "                             ? 1 : curbuf->b_ml.ml_line_count))"], "readability/braces"]
["src/nvim/search.c", ["            break;", "          if (start_is_white != linewhite(start_lnum + dir)", "              || (!start_is_white"], "readability/braces"]
["src/nvim/search.c", ["        }", "        if (!include)", "          break;"], "readability/braces"]
["src/nvim/search.c", ["          break;", "        if (start_lnum == (dir == BACKWARD", "                           ? 1 : curbuf->b_ml.ml_line_count))"], "readability/braces"]
["src/nvim/search.c", ["", "  /*", "   * First move back to the start_lnum of the paragraph or white lines"], "readability/old_style_comment"]
["src/nvim/search.c", ["  while (start_lnum > 1) {", "    if (white_in_front) {           /* stop at first white line */", "      if (!linewhite(start_lnum - 1))"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (white_in_front) {           /* stop at first white line */", "      if (!linewhite(start_lnum - 1))", "        break;"], "readability/braces"]
["src/nvim/search.c", ["        break;", "    } else {          /* stop at first non-white line of start of paragraph */", "      if (linewhite(start_lnum - 1) || startPS(start_lnum, 0, 0))"], "readability/old_style_comment"]
["src/nvim/search.c", ["    } else {          /* stop at first non-white line of start of paragraph */", "      if (linewhite(start_lnum - 1) || startPS(start_lnum, 0, 0))", "        break;"], "readability/braces"]
["src/nvim/search.c", ["    }", "    --start_lnum;", "  }"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * Move past the end of any white lines."], "readability/old_style_comment"]
["src/nvim/search.c", ["  end_lnum = start_lnum;", "  while (end_lnum <= curbuf->b_ml.ml_line_count && linewhite(end_lnum))", "    ++end_lnum;"], "readability/braces"]
["src/nvim/search.c", ["  while (end_lnum <= curbuf->b_ml.ml_line_count && linewhite(end_lnum))", "    ++end_lnum;", ""], "readability/increment"]
["src/nvim/search.c", ["", "  --end_lnum;", "  i = count;"], "readability/increment"]
["src/nvim/search.c", ["  i = count;", "  if (!include && white_in_front)", "    --i;"], "readability/braces"]
["src/nvim/search.c", ["  if (!include && white_in_front)", "    --i;", "  while (i--) {"], "readability/increment"]
["src/nvim/search.c", ["  while (i--) {", "    if (end_lnum == curbuf->b_ml.ml_line_count)", "      return FAIL;"], "readability/braces"]
["src/nvim/search.c", ["", "    if (!include)", "      do_white = linewhite(end_lnum + 1);"], "readability/braces"]
["src/nvim/search.c", ["    if (include || !do_white) {", "      ++end_lnum;", "      /*"], "readability/increment"]
["src/nvim/search.c", ["      ++end_lnum;", "      /*", "       * skip to end of paragraph"], "readability/old_style_comment"]
["src/nvim/search.c", ["       */", "      while (end_lnum < curbuf->b_ml.ml_line_count", "             && !linewhite(end_lnum + 1)"], "readability/braces"]
["src/nvim/search.c", ["             && !startPS(end_lnum + 1, 0, 0))", "        ++end_lnum;", "    }"], "readability/increment"]
["src/nvim/search.c", ["", "    if (i == 0 && white_in_front && include)", "      break;"], "readability/braces"]
["src/nvim/search.c", ["", "    /*", "     * skip to end of white lines after paragraph"], "readability/old_style_comment"]
["src/nvim/search.c", ["     */", "    if (include || do_white)", "      while (end_lnum < curbuf->b_ml.ml_line_count"], "readability/braces"]
["src/nvim/search.c", ["    if (include || do_white)", "      while (end_lnum < curbuf->b_ml.ml_line_count", "             && linewhite(end_lnum + 1))"], "readability/braces"]
["src/nvim/search.c", ["             && linewhite(end_lnum + 1))", "        ++end_lnum;", "  }"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * If there are no empty lines at the end, try to find some empty lines at"], "readability/old_style_comment"]
["src/nvim/search.c", ["   */", "  if (!white_in_front && !linewhite(end_lnum) && include)", "    while (start_lnum > 1 && linewhite(start_lnum - 1))"], "readability/braces"]
["src/nvim/search.c", ["  if (!white_in_front && !linewhite(end_lnum) && include)", "    while (start_lnum > 1 && linewhite(start_lnum - 1))", "      --start_lnum;"], "readability/braces"]
["src/nvim/search.c", ["    while (start_lnum > 1 && linewhite(start_lnum - 1))", "      --start_lnum;", ""], "readability/increment"]
["src/nvim/search.c", ["    VIsual_mode = 'V';", "    redraw_curbuf_later(INVERTED);      /* update the inversion */", "    showmode();"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Search quote char from string line[col]."], "readability/old_style_comment"]
["src/nvim/search.c", ["    int quotechar,", "    char_u *escape            /* escape characters, can be NULL */", ")"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Search backwards in \"line\" from column \"col_start\" to find \"quotechar\"."], "readability/old_style_comment"]
["src/nvim/search.c", ["    int quotechar,", "    char_u *escape            /* escape characters, can be NULL */", ")"], "readability/old_style_comment"]
["src/nvim/search.c", ["    n = 0;", "    if (escape != NULL)", "      while (col_start - n > 0 && vim_strchr(escape,"], "readability/braces"]
["src/nvim/search.c", ["    if (escape != NULL)", "      while (col_start - n > 0 && vim_strchr(escape,", "                 line[col_start - n - 1]) != NULL)"], "readability/braces"]
["src/nvim/search.c", ["      while (col_start - n > 0 && vim_strchr(escape,", "                 line[col_start - n - 1]) != NULL)", "        ++n;"], "whitespace/alignment"]
["src/nvim/search.c", ["                 line[col_start - n - 1]) != NULL)", "        ++n;", "    if (n & 1)"], "readability/increment"]
["src/nvim/search.c", ["        ++n;", "    if (n & 1)", "      col_start -= n;           /* uneven number of escape chars, skip it */"], "readability/braces"]
["src/nvim/search.c", ["    if (n & 1)", "      col_start -= n;           /* uneven number of escape chars, skip it */", "    else if (line[col_start] == quotechar)"], "readability/old_style_comment"]
["src/nvim/search.c", ["      col_start -= n;           /* uneven number of escape chars, skip it */", "    else if (line[col_start] == quotechar)", "      break;"], "readability/braces"]
["src/nvim/search.c", ["  if (!vis_empty) {", "    /* Check if the existing selection exactly spans the text inside", "     * quotes. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /* Find out if we have a quote in the selection. */", "    while (i <= col_end)"], "readability/old_style_comment"]
["src/nvim/search.c", ["    /* Find out if we have a quote in the selection. */", "    while (i <= col_end)", "      if (line[i++] == quotechar) {"], "readability/braces"]
["src/nvim/search.c", ["  if (!vis_empty && line[col_start] == quotechar) {", "    /* Already selecting something and on a quote character.  Find the", "     * next quoted string. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (vis_bef_curs) {", "      /* Assume we are on a closing quote: move to after the next", "       * opening quote. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["      col_end = find_next_quote(line, col_start + 1, quotechar,", "          curbuf->b_p_qe);", "      if (col_end < 0) {"], "whitespace/alignment"]
["src/nvim/search.c", ["      if (col_end < 0) {", "        /* We were on a starting quote perhaps? */", "        col_end = col_start;"], "readability/old_style_comment"]
["src/nvim/search.c", ["      col_start = find_prev_quote(line, col_end, quotechar,", "          curbuf->b_p_qe);", "      if (line[col_start] != quotechar) {"], "whitespace/alignment"]
["src/nvim/search.c", ["      if (line[col_start] != quotechar) {", "        /* We were on an ending quote perhaps? */", "        col_start = col_end;"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (!vis_empty) {", "      if (vis_bef_curs)", "        first_col = find_next_quote(line, col_start, quotechar, NULL);"], "readability/braces"]
["src/nvim/search.c", ["        first_col = find_next_quote(line, col_start, quotechar, NULL);", "      else", "        first_col = find_prev_quote(line, col_start, quotechar, NULL);"], "readability/braces"]
["src/nvim/search.c", ["    }", "    /* The cursor is on a quote, we don't know if it's the opening or", "     * closing quote.  Search from the start of the line to find out."], "readability/old_style_comment"]
["src/nvim/search.c", ["    for (;; ) {", "      /* Find open quote character. */", "      col_start = find_next_quote(line, col_start, quotechar, NULL);"], "readability/old_style_comment"]
["src/nvim/search.c", ["      col_end = find_next_quote(line, col_start + 1, quotechar,", "          curbuf->b_p_qe);", "      if (col_end < 0) {"], "whitespace/alignment"]
["src/nvim/search.c", ["  } else {", "    /* Search backward for a starting quote. */", "    col_start = find_prev_quote(line, col_start, quotechar, curbuf->b_p_qe);"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (line[col_start] != quotechar) {", "      /* No quote before the cursor, look after the cursor. */", "      col_start = find_next_quote(line, col_start, quotechar, NULL);"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /* Find close quote character. */", "    col_end = find_next_quote(line, col_start + 1, quotechar,"], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (include) {", "    if (ascii_iswhite(line[col_end + 1]))", "      while (ascii_iswhite(line[col_end + 1]))"], "readability/braces"]
["src/nvim/search.c", ["    if (ascii_iswhite(line[col_end + 1]))", "      while (ascii_iswhite(line[col_end + 1]))", "        ++col_end;"], "readability/braces"]
["src/nvim/search.c", ["      while (ascii_iswhite(line[col_end + 1]))", "        ++col_end;", "    else"], "readability/increment"]
["src/nvim/search.c", ["        ++col_end;", "    else", "      while (col_start > 0 && ascii_iswhite(line[col_start - 1]))"], "readability/braces"]
["src/nvim/search.c", ["    else", "      while (col_start > 0 && ascii_iswhite(line[col_start - 1]))", "        --col_start;"], "readability/braces"]
["src/nvim/search.c", ["      while (col_start > 0 && ascii_iswhite(line[col_start - 1]))", "        --col_start;", "  }"], "readability/increment"]
["src/nvim/search.c", ["", "  /* Set start position.  After vi\" another i\" must include the \".", "   * For v2i\" include the quotes. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["   * For v2i\" include the quotes. */", "  if (!include && count < 2", "      && (vis_empty || !inside_quotes)"], "readability/braces"]
["src/nvim/search.c", ["      )", "    ++col_start;", "  curwin->w_cursor.col = col_start;"], "readability/increment"]
["src/nvim/search.c", ["  if (VIsual_active) {", "    /* Set the start of the Visual area when the Visual area was empty, we", "     * were just inside quotes or the Visual area didn't start at a quote"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /* Set end position. */", "  curwin->w_cursor.col = col_end;"], "readability/old_style_comment"]
["src/nvim/search.c", ["  curwin->w_cursor.col = col_end;", "  if ((include || count > 1", "       /* After vi\" another i\" must include the \". */"], "readability/braces"]
["src/nvim/search.c", ["  if ((include || count > 1", "       /* After vi\" another i\" must include the \". */", "       || (!vis_empty && inside_quotes)"], "readability/old_style_comment"]
["src/nvim/search.c", ["       || (!vis_empty && inside_quotes)", "       ) && inc_cursor() == 2)", "    inclusive = true;"], "whitespace/parens"]
["src/nvim/search.c", ["    } else {", "      /* Cursor is at start of Visual area.  Set the end of the Visual", "       * area when it was just inside quotes or it didn't end at a"], "readability/old_style_comment"]
["src/nvim/search.c", ["      VIsual_mode = 'v';", "      redraw_cmdline = TRUE;                    /* show mode later */", "    }"], "readability/old_style_comment"]
["src/nvim/search.c", ["      VIsual_mode = 'v';", "      redraw_cmdline = TRUE;                    /* show mode later */", "    }"], "readability/bool"]
["src/nvim/search.c", ["  } else {", "    /* Set inclusive and other oap's flags. */", "    oap->inclusive = inclusive;"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Find next search match under cursor, cursor at end."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /* Correct cursor when 'selection' is exclusive */", "  if (VIsual_active && *p_sel == 'e' && lt(VIsual, curwin->w_cursor))"], "readability/old_style_comment"]
["src/nvim/search.c", ["  /* Correct cursor when 'selection' is exclusive */", "  if (VIsual_active && *p_sel == 'e' && lt(VIsual, curwin->w_cursor))", "    dec_cursor();"], "readability/braces"]
["src/nvim/search.c", ["      curwin->w_cursor = orig_pos;", "      if (VIsual_active)", "        VIsual = save_VIsual;"], "readability/braces"]
["src/nvim/search.c", ["", "  if (search_regcomp(pattern, RE_SEARCH, RE_SEARCH,", "          SEARCH_KEEP, &regmatch) == FAIL)"], "readability/braces"]
["src/nvim/search.c", ["  if (search_regcomp(pattern, RE_SEARCH, RE_SEARCH,", "          SEARCH_KEEP, &regmatch) == FAIL)", "    return -1;"], "whitespace/alignment"]
["src/nvim/search.c", ["", "/*", " * return TRUE if line 'lnum' is empty or has white chars only."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Find identifiers or defines in included files."], "readability/old_style_comment"]
["src/nvim/search.c", ["{", "  SearchedFile *files;                  /* Stack of included files */", "  SearchedFile *bigger;                 /* When we need more space */"], "readability/old_style_comment"]
["src/nvim/search.c", ["  SearchedFile *files;                  /* Stack of included files */", "  SearchedFile *bigger;                 /* When we need more space */", "  int max_path_depth = 50;"], "readability/old_style_comment"]
["src/nvim/search.c", ["  int depth;", "  int depth_displayed;                  /* For type==CHECK_PATH */", "  int old_files;"], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (type != CHECK_PATH && type != FIND_DEFINE", "      /* when CONT_SOL is set compare \"ptr\" with the beginning of the line", "       * is faster than quote_meta/regcomp/regexec \"ptr\" -- Acevedo */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    assert(len <= INT_MAX);", "    sprintf((char *)pat, whole ? \"\\\\<%.*s\\\\>\" : \"%.*s\", (int)len, ptr);", "    /* ignore case according to p_ic, p_scs and pat */"], "runtime/printf"]
["src/nvim/search.c", ["    sprintf((char *)pat, whole ? \"\\\\<%.*s\\\\>\" : \"%.*s\", (int)len, ptr);", "    /* ignore case according to p_ic, p_scs and pat */", "    regmatch.rm_ic = ignorecase(pat);"], "readability/old_style_comment"]
["src/nvim/search.c", ["    xfree(pat);", "    if (regmatch.regprog == NULL)", "      goto fpip_end;"], "readability/braces"]
["src/nvim/search.c", ["    incl_regmatch.regprog = vim_regcomp(inc_opt, p_magic ? RE_MAGIC : 0);", "    if (incl_regmatch.regprog == NULL)", "      goto fpip_end;"], "readability/braces"]
["src/nvim/search.c", ["      goto fpip_end;", "    incl_regmatch.rm_ic = FALSE;        /* don't ignore case in incl. pat. */", "  }"], "readability/old_style_comment"]
["src/nvim/search.c", ["      goto fpip_end;", "    incl_regmatch.rm_ic = FALSE;        /* don't ignore case in incl. pat. */", "  }"], "readability/bool"]
["src/nvim/search.c", ["    def_regmatch.regprog = vim_regcomp(*curbuf->b_p_def == NUL", "        ? p_def : curbuf->b_p_def, p_magic ? RE_MAGIC : 0);", "    if (def_regmatch.regprog == NULL)"], "whitespace/alignment"]
["src/nvim/search.c", ["        ? p_def : curbuf->b_p_def, p_magic ? RE_MAGIC : 0);", "    if (def_regmatch.regprog == NULL)", "      goto fpip_end;"], "readability/braces"]
["src/nvim/search.c", ["      goto fpip_end;", "    def_regmatch.rm_ic = FALSE;         /* don't ignore case in define pat. */", "  }"], "readability/old_style_comment"]
["src/nvim/search.c", ["      goto fpip_end;", "    def_regmatch.rm_ic = FALSE;         /* don't ignore case in define pat. */", "  }"], "readability/bool"]
["src/nvim/search.c", ["  lnum = start_lnum;", "  if (end_lnum > curbuf->b_ml.ml_line_count)", "    end_lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/search.c", ["    end_lnum = curbuf->b_ml.ml_line_count;", "  if (lnum > end_lnum)                  /* do at least one line */", "    lnum = end_lnum;"], "readability/old_style_comment"]
["src/nvim/search.c", ["    end_lnum = curbuf->b_ml.ml_line_count;", "  if (lnum > end_lnum)                  /* do at least one line */", "    lnum = end_lnum;"], "readability/braces"]
["src/nvim/search.c", ["", "      if (inc_opt != NULL && strstr((char *)inc_opt, \"\\\\zs\") != NULL)", "        /* Use text from '\\zs' to '\\ze' (or end) of 'include'. */"], "readability/braces"]
["src/nvim/search.c", ["      if (inc_opt != NULL && strstr((char *)inc_opt, \"\\\\zs\") != NULL)", "        /* Use text from '\\zs' to '\\ze' (or end) of 'include'. */", "        new_fname = find_file_name_in_path(incl_regmatch.startp[0],"], "readability/old_style_comment"]
["src/nvim/search.c", ["                                           1L, p_fname);", "      else", "        /* Use text after match with 'include'. */"], "readability/braces"]
["src/nvim/search.c", ["      else", "        /* Use text after match with 'include'. */", "        new_fname = file_name_in_line(incl_regmatch.endp[0], 0,"], "readability/old_style_comment"]
["src/nvim/search.c", ["        new_fname = file_name_in_line(incl_regmatch.endp[0], 0,", "            FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname, NULL);", "      already_searched = FALSE;"], "whitespace/alignment"]
["src/nvim/search.c", ["            FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname, NULL);", "      already_searched = FALSE;", "      if (new_fname != NULL) {"], "readability/bool"]
["src/nvim/search.c", ["        while (depth_displayed < depth && !got_int) {", "          ++depth_displayed;", "          for (i = 0; i < depth_displayed; i++)"], "readability/increment"]
["src/nvim/search.c", ["          ++depth_displayed;", "          for (i = 0; i < depth_displayed; i++)", "            MSG_PUTS(\"  \");"], "readability/braces"]
["src/nvim/search.c", ["        }", "        if (!got_int) {                     /* don't display if 'q' typed", "                                               for \"--more--\" message */"], "readability/multiline_comment"]
["src/nvim/search.c", ["        }", "        if (!got_int) {                     /* don't display if 'q' typed", "                                               for \"--more--\" message */"], "readability/old_style_comment"]
["src/nvim/search.c", ["                                               for \"--more--\" message */", "          for (i = 0; i <= depth_displayed; i++)", "            MSG_PUTS(\"  \");"], "readability/braces"]
["src/nvim/search.c", ["          if (new_fname != NULL) {", "            /* using \"new_fname\" is more reliable, e.g., when", "             * 'includeexpr' is set. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["          } else {", "            /*", "             * Isolate the file name."], "readability/old_style_comment"]
["src/nvim/search.c", ["                && strstr((char *)inc_opt, \"\\\\zs\") != NULL) {", "              /* pattern contains \\zs, use the match */", "              p = incl_regmatch.startp[0];"], "readability/old_style_comment"]
["src/nvim/search.c", ["            } else {", "              /* find the file name after the end of the match */", "              for (p = incl_regmatch.endp[0];"], "readability/old_style_comment"]
["src/nvim/search.c", ["              /* find the file name after the end of the match */", "              for (p = incl_regmatch.endp[0];", "                   *p && !vim_isfilec(*p); p++)"], "readability/braces"]
["src/nvim/search.c", ["                   *p && !vim_isfilec(*p); p++)", "                ;", "              for (i = 0; vim_isfilec(p[i]); i++)"], "whitespace/semicolon"]
["src/nvim/search.c", ["                ;", "              for (i = 0; vim_isfilec(p[i]); i++)", "                ;"], "readability/braces"]
["src/nvim/search.c", ["              for (i = 0; vim_isfilec(p[i]); i++)", "                ;", "            }"], "whitespace/semicolon"]
["src/nvim/search.c", ["            if (i == 0) {", "              /* Nothing found, use the rest of the line. */", "              p = incl_regmatch.endp[0];"], "readability/old_style_comment"]
["src/nvim/search.c", ["            }", "            /* Avoid checking before the start of the line, can", "             * happen if \\zs appears in the regexp. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["             * happen if \\zs appears in the regexp. */", "            else if (p > line) {", "              if (p[-1] == '\"' || p[-1] == '<') {"], "whitespace/newline"]
["src/nvim/search.c", ["              if (p[-1] == '\"' || p[-1] == '<') {", "                --p;", "                ++i;"], "readability/increment"]
["src/nvim/search.c", ["                --p;", "                ++i;", "              }"], "readability/increment"]
["src/nvim/search.c", ["              }", "              if (p[i] == '\"' || p[i] == '>')", "                ++i;"], "readability/braces"]
["src/nvim/search.c", ["              if (p[i] == '\"' || p[i] == '>')", "                ++i;", "            }"], "readability/increment"]
["src/nvim/search.c", ["          if (new_fname == NULL && action == ACTION_SHOW_ALL) {", "            if (already_searched)", "              MSG_PUTS(_(\"  (Already listed)\"));"], "readability/braces"]
["src/nvim/search.c", ["              MSG_PUTS(_(\"  (Already listed)\"));", "            else", "              MSG_PUTS(_(\"  NOT FOUND\"));"], "readability/braces"]
["src/nvim/search.c", ["        }", "        ui_flush();                /* output each line directly */", "      }"], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (new_fname != NULL) {", "        /* Push the new file onto the file stack */", "        if (depth + 1 == old_files) {"], "readability/old_style_comment"]
["src/nvim/search.c", ["          bigger = xmalloc(max_path_depth * 2 * sizeof(SearchedFile));", "          for (i = 0; i <= depth; i++)", "            bigger[i] = files[i];"], "readability/braces"]
["src/nvim/search.c", ["            bigger[i].lnum = 0;", "            bigger[i].matched = FALSE;", "          }"], "readability/bool"]
["src/nvim/search.c", ["          }", "          for (i = old_files; i < max_path_depth; i++)", "            bigger[i + max_path_depth] = files[i];"], "readability/braces"]
["src/nvim/search.c", ["            xfree(files[old_files].name);", "            ++old_files;", "          }"], "readability/increment"]
["src/nvim/search.c", ["          files[depth].lnum = 0;", "          files[depth].matched = FALSE;", "          if (action == ACTION_EXPAND) {"], "readability/bool"]
["src/nvim/search.c", ["            smsg(_(\"Searching included file %s\"),", "                (char *)new_fname);", "            verbose_leave();"], "whitespace/alignment"]
["src/nvim/search.c", ["          }", "", "        }"], "whitespace/blank_line"]
["src/nvim/search.c", ["    } else {", "      /*", "       * Check if the line is a define (type == FIND_DEFINE)"], "readability/old_style_comment"]
["src/nvim/search.c", ["search_line:", "      define_matched = FALSE;", "      if (def_regmatch.regprog != NULL"], "readability/bool"]
["src/nvim/search.c", ["          && vim_regexec(&def_regmatch, line, (colnr_T)0)) {", "        /*", "         * Pattern must be first identifier after 'define', so skip"], "readability/old_style_comment"]
["src/nvim/search.c", ["        p = def_regmatch.endp[0];", "        while (*p && !vim_iswordc(*p))", "          p++;"], "readability/braces"]
["src/nvim/search.c", ["          p++;", "        define_matched = TRUE;", "      }"], "readability/bool"]
["src/nvim/search.c", ["", "      /*", "       * Look for a match.  Don't do this if we are looking for a"], "readability/old_style_comment"]
["src/nvim/search.c", ["            ) {", "          /* compare the first \"len\" chars from \"ptr\" */", "          startp = skipwhite(p);"], "readability/old_style_comment"]
["src/nvim/search.c", ["          }", "          else", "            matched = !STRNCMP(startp, ptr, len);"], "whitespace/newline"]
["src/nvim/search.c", ["            matched = !STRNCMP(startp, ptr, len);", "          if (matched && define_matched && whole", "              && vim_iswordc(startp[len]))"], "readability/braces"]
["src/nvim/search.c", ["", "            /*", "             * Also check for a \"/ *\" or \"/ /\" before the match."], "readability/old_style_comment"]
["src/nvim/search.c", ["            p = skipwhite(line);", "            if (matched", "                || (p[0] == '/' && p[1] == '*') || p[0] == '*')"], "readability/braces"]
["src/nvim/search.c", ["                || (p[0] == '/' && p[1] == '*') || p[0] == '*')", "              for (p = line; *p && p < startp; ++p) {", "                if (matched"], "readability/increment"]
["src/nvim/search.c", ["", "        if (depth == -1 && lnum == curwin->w_cursor.lnum)", "          break;"], "readability/braces"]
["src/nvim/search.c", ["          p += compl_length;", "          if (vim_iswordp(p))", "            goto exit_matched;"], "readability/braces"]
["src/nvim/search.c", ["        if ((compl_cont_status & CONT_ADDING) && i == compl_length) {", "          /* IOSIZE > compl_length, so the STRNCPY works */", "          STRNCPY(IObuff, aux, i);"], "readability/old_style_comment"]
["src/nvim/search.c", ["          /* IOSIZE > compl_length, so the STRNCPY works */", "          STRNCPY(IObuff, aux, i);", ""], "runtime/printf"]
["src/nvim/search.c", ["", "          /* Get the next line: when \"depth\" < 0  from the current", "           * buffer, otherwise from the included file.  Jump to"], "readability/old_style_comment"]
["src/nvim/search.c", ["          if (depth < 0) {", "            if (lnum >= end_lnum)", "              goto exit_matched;"], "readability/braces"]
["src/nvim/search.c", ["            line = ml_get(++lnum);", "          } else if (vim_fgets(line = file_line,", "                         LSIZE, files[depth].fp))"], "readability/braces"]
["src/nvim/search.c", ["          } else if (vim_fgets(line = file_line,", "                         LSIZE, files[depth].fp))", "            goto exit_matched;"], "whitespace/alignment"]
["src/nvim/search.c", ["", "          /* we read a line, set \"already\" to check this \"line\" later", "           * if depth >= 0 we'll increase files[depth].lnum far"], "readability/old_style_comment"]
["src/nvim/search.c", ["            if (*aux != ')' && IObuff[i-1] != TAB) {", "              if (IObuff[i-1] != ' ')", "                IObuff[i++] = ' ';"], "readability/braces"]
["src/nvim/search.c", ["                IObuff[i++] = ' ';", "              /* IObuf =~ \"\\(\\k\\|\\i\\).* \", thus i >= 2*/", "              if (p_js"], "readability/old_style_comment"]
["src/nvim/search.c", ["            }", "            /* copy as much as possible of the new word */", "            if (p - aux >= IOSIZE - i)"], "readability/old_style_comment"]
["src/nvim/search.c", ["            /* copy as much as possible of the new word */", "            if (p - aux >= IOSIZE - i)", "              p = aux + IOSIZE - i - 1;"], "readability/braces"]
["src/nvim/search.c", ["              p = aux + IOSIZE - i - 1;", "            STRNCPY(IObuff + i, aux, p - aux);", "            i += (int)(p - aux);"], "runtime/printf"]
["src/nvim/search.c", ["", "          if (i == compl_length)", "            goto exit_matched;"], "readability/braces"]
["src/nvim/search.c", ["        if (curr_fname != prev_fname) {", "          if (did_show)", "            msg_putchar('\\n');                  /* cursor below last one */"], "readability/braces"]
["src/nvim/search.c", ["          if (did_show)", "            msg_putchar('\\n');                  /* cursor below last one */", "          if (!got_int)                         /* don't display if 'q' typed"], "readability/old_style_comment"]
["src/nvim/search.c", ["            msg_putchar('\\n');                  /* cursor below last one */", "          if (!got_int)                         /* don't display if 'q' typed", "                                                    at \"--more--\" message */"], "readability/multiline_comment"]
["src/nvim/search.c", ["            msg_putchar('\\n');                  /* cursor below last one */", "          if (!got_int)                         /* don't display if 'q' typed", "                                                    at \"--more--\" message */"], "readability/old_style_comment"]
["src/nvim/search.c", ["            msg_putchar('\\n');                  /* cursor below last one */", "          if (!got_int)                         /* don't display if 'q' typed", "                                                    at \"--more--\" message */"], "readability/braces"]
["src/nvim/search.c", ["", "        /* Set matched flag for this file and all the ones that", "         * include it */"], "readability/old_style_comment"]
["src/nvim/search.c", ["         * include it */", "        for (i = 0; i <= depth; ++i)", "          files[i].matched = TRUE;"], "readability/braces"]
["src/nvim/search.c", ["         * include it */", "        for (i = 0; i <= depth; ++i)", "          files[i].matched = TRUE;"], "readability/increment"]
["src/nvim/search.c", ["        for (i = 0; i <= depth; ++i)", "          files[i].matched = TRUE;", "      } else if (--count <= 0) {"], "readability/bool"]
["src/nvim/search.c", ["        } else {", "          /* \":psearch\" uses the preview window */", "          if (l_g_do_tagpreview != 0) {"], "readability/old_style_comment"]
["src/nvim/search.c", ["          if (action == ACTION_SPLIT) {", "            if (win_split(0, 0) == FAIL)", "              break;"], "readability/braces"]
["src/nvim/search.c", ["          curwin->w_cursor.col = (colnr_T)(startp - line);", "          curwin->w_set_curswant = TRUE;", "        }"], "readability/bool"]
["src/nvim/search.c", ["            && curwin != curwin_save && win_valid(curwin_save)) {", "          /* Return cursor to where we were */", "          validate_cursor();"], "readability/old_style_comment"]
["src/nvim/search.c", ["    line_breakcheck();", "    if (action == ACTION_EXPAND)", "      ins_compl_check_keys(30, false);"], "readability/braces"]
["src/nvim/search.c", ["      ins_compl_check_keys(30, false);", "    if (got_int || compl_interrupted)", "      break;"], "readability/braces"]
["src/nvim/search.c", ["", "    /*", "     * Read the next line.  When reading an included file and encountering"], "readability/old_style_comment"]
["src/nvim/search.c", ["      fclose(files[depth].fp);", "      --old_files;", "      files[old_files].name = files[depth].name;"], "readability/increment"]
["src/nvim/search.c", ["      files[old_files].matched = files[depth].matched;", "      --depth;", "      curr_fname = (depth == -1) ? curbuf->b_fname"], "readability/increment"]
["src/nvim/search.c", ["                   : files[depth].name;", "      if (depth < depth_displayed)", "        depth_displayed = depth;"], "readability/braces"]
["src/nvim/search.c", ["    }", "    if (depth >= 0) {           /* we could read the line */", "      files[depth].lnum++;"], "readability/old_style_comment"]
["src/nvim/search.c", ["      files[depth].lnum++;", "      /* Remove any CR and LF from the line. */", "      i = (int)STRLEN(line);"], "readability/old_style_comment"]
["src/nvim/search.c", ["      i = (int)STRLEN(line);", "      if (i > 0 && line[i - 1] == '\\n')", "        line[--i] = NUL;"], "readability/braces"]
["src/nvim/search.c", ["        line[--i] = NUL;", "      if (i > 0 && line[i - 1] == '\\r')", "        line[--i] = NUL;"], "readability/braces"]
["src/nvim/search.c", ["    } else if (!already) {", "      if (++lnum > end_lnum)", "        break;"], "readability/braces"]
["src/nvim/search.c", ["  }", "  /* End of big for (;;) loop. */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /* Close any files that are still open. */", "  for (i = 0; i <= depth; i++) {"], "readability/old_style_comment"]
["src/nvim/search.c", ["  }", "  for (i = old_files; i < max_path_depth; i++)", "    xfree(files[i].name);"], "readability/braces"]
["src/nvim/search.c", ["    if (!did_show) {", "      if (action != ACTION_SHOW_ALL)", "        MSG(_(\"All included files were found\"));"], "readability/braces"]
["src/nvim/search.c", ["        MSG(_(\"All included files were found\"));", "      else", "        MSG(_(\"No included files\"));"], "readability/braces"]
["src/nvim/search.c", ["             ) {", "    if (got_int || compl_interrupted)", "      EMSG(_(e_interr));"], "readability/braces"]
["src/nvim/search.c", ["      EMSG(_(e_interr));", "    else if (type == FIND_DEFINE)", "      EMSG(_(\"E388: Couldn't find definition\"));"], "readability/braces"]
["src/nvim/search.c", ["      EMSG(_(\"E388: Couldn't find definition\"));", "    else", "      EMSG(_(\"E389: Couldn't find pattern\"));"], "readability/braces"]
["src/nvim/search.c", ["  }", "  if (action == ACTION_SHOW || action == ACTION_SHOW_ALL)", "    msg_end();"], "readability/braces"]
["src/nvim/search.c", ["    if (fp != NULL) {", "      /* We used fgets(), so get rid of newline at end */", "      if (p >= line && *p == '\\n')"], "readability/old_style_comment"]
["src/nvim/search.c", ["      /* We used fgets(), so get rid of newline at end */", "      if (p >= line && *p == '\\n')", "        --p;"], "readability/braces"]
["src/nvim/search.c", ["      if (p >= line && *p == '\\n')", "        --p;", "      if (p >= line && *p == '\\r')"], "readability/increment"]
["src/nvim/search.c", ["        --p;", "      if (p >= line && *p == '\\r')", "        --p;"], "readability/braces"]
["src/nvim/search.c", ["      if (p >= line && *p == '\\r')", "        --p;", "      *(p + 1) = NUL;"], "readability/increment"]
["src/nvim/search.c", ["    }", "    msg_prt_line(line, FALSE);", "    ui_flush();                        /* show one line at a time */"], "readability/bool"]
["src/nvim/search.c", ["    msg_prt_line(line, FALSE);", "    ui_flush();                        /* show one line at a time */", ""], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /* Definition continues until line that doesn't end with '\\' */", "    if (got_int || type != FIND_DEFINE || p < line || *p != '\\\\')"], "readability/old_style_comment"]
["src/nvim/search.c", ["    /* Definition continues until line that doesn't end with '\\' */", "    if (got_int || type != FIND_DEFINE || p < line || *p != '\\\\')", "      break;"], "readability/braces"]
["src/nvim/search.c", ["    if (fp != NULL) {", "      if (vim_fgets(line, LSIZE, fp))       /* end of file */", "        break;"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (fp != NULL) {", "      if (vim_fgets(line, LSIZE, fp))       /* end of file */", "        break;"], "readability/braces"]
["src/nvim/search.c", ["        break;", "      ++*lnum;", "    } else {"], "readability/increment"]
["src/nvim/search.c", ["    } else {", "      if (++*lnum > curbuf->b_ml.ml_line_count)", "        break;"], "readability/braces"]
