["src/nvim/file_search.c", ["", "static char_u   *ff_expand_buffer = NULL; /* used for expanding filenames */", ""], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * type for the directory search stack"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* the fix part (no wildcards) and the part containing the wildcards", "   * of the search path"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* files/dirs found in the above directory, matched by the first wildcard", "   * of wc_part"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  int ffs_filearray_size;", "  char_u ffs_filearray_cur;                  /* needed for partly handled dirs */", ""], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  int ffs_filearray_size;", "  char_u ffs_filearray_cur;                  /* needed for partly handled dirs */", ""], "whitespace/line_length"]
["src/nvim/file_search.c", ["", "  /* to store status of partly handled directories", "   * 0: we work on this directory for the first time"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* How deep are we in the directory tree?", "   * Counts backward from value of level parameter to vim_findfile_init"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* Did we already expand '**' to an empty string? */", "  int ffs_star_star_empty;"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * type for already visited directories or files."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* Visited directories are different if the wildcard string are", "   * different. So we have to save it."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  FileID file_id;", "  /* The memory for this struct is allocated according to the length of", "   * ffv_fname."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["   */", "  char_u ffv_fname[1];                  /* actually longer */", "} ff_visited_T;"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * We might have to manage several visited lists during a search."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* the filename the attached visited list is for */", "  char_u                      *ffvl_filename;"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  ff_visited_T                *ffvl_visited_list;", "", "} ff_visited_list_hdr_T;"], "whitespace/blank_line"]
["src/nvim/file_search.c", ["", "/*", " * '**' can be expanded to several directory levels."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * The search context:"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/* locally needed functions */", ""], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * Initialization routine for vim_findfile()."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["void *", "vim_findfile_init (", "    char_u *path,"], "whitespace/parens"]
["src/nvim/file_search.c", ["    void *search_ctx_arg,", "    int tagfile,                    /* expanding names of tags files */", "    char_u *rel_fname         /* file name to use for \".\" */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    int tagfile,                    /* expanding names of tags files */", "    char_u *rel_fname         /* file name to use for \".\" */", ")"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* If a search context is given by the caller, reuse it, else allocate a", "   * new one."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["   */", "  if (search_ctx_arg != NULL)", "    search_ctx = search_ctx_arg;"], "readability/braces"]
["src/nvim/file_search.c", ["    search_ctx = search_ctx_arg;", "  else {", "    search_ctx = xcalloc(1, sizeof(ff_search_ctx_T));"], "readability/braces"]
["src/nvim/file_search.c", ["    search_ctx = search_ctx_arg;", "  else {", "    search_ctx = xcalloc(1, sizeof(ff_search_ctx_T));"], "readability/braces"]
["src/nvim/file_search.c", ["", "  /* clear the search context, but NOT the visited lists */", "  ff_clear(search_ctx);"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* clear visited list if wanted */", "  if (free_visited == TRUE)"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  /* clear visited list if wanted */", "  if (free_visited == TRUE)", "    vim_findfile_free_visited(search_ctx);"], "readability/braces"]
["src/nvim/file_search.c", ["  /* clear visited list if wanted */", "  if (free_visited == TRUE)", "    vim_findfile_free_visited(search_ctx);"], "readability/bool"]
["src/nvim/file_search.c", ["    vim_findfile_free_visited(search_ctx);", "  else {", "    /* Reuse old visited lists. Get the visited list for the given"], "readability/braces"]
["src/nvim/file_search.c", ["    vim_findfile_free_visited(search_ctx);", "  else {", "    /* Reuse old visited lists. Get the visited list for the given"], "readability/braces"]
["src/nvim/file_search.c", ["  else {", "    /* Reuse old visited lists. Get the visited list for the given", "     * filename. If no list for the current filename exists, creates a new"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    search_ctx->ffsc_visited_list = ff_get_visited_list(filename,", "        &search_ctx->ffsc_visited_lists_list);", "    if (search_ctx->ffsc_visited_list == NULL)"], "whitespace/alignment"]
["src/nvim/file_search.c", ["        &search_ctx->ffsc_visited_lists_list);", "    if (search_ctx->ffsc_visited_list == NULL)", "      goto error_return;"], "readability/braces"]
["src/nvim/file_search.c", ["    search_ctx->ffsc_dir_visited_list = ff_get_visited_list(filename,", "        &search_ctx->ffsc_dir_visited_lists_list);", "    if (search_ctx->ffsc_dir_visited_list == NULL)"], "whitespace/alignment"]
["src/nvim/file_search.c", ["        &search_ctx->ffsc_dir_visited_lists_list);", "    if (search_ctx->ffsc_dir_visited_list == NULL)", "      goto error_return;"], "readability/braces"]
["src/nvim/file_search.c", ["", "  /* Store information on starting dir now if path is relative.", "   * If path is absolute, we do that later.  */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    if (!vim_isAbsName(rel_fname) && len + 1 < MAXPATHL) {", "      /* Make the start dir an absolute path name. */", "      STRLCPY(ff_expand_buffer, rel_fname, len + 1);"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["      STRLCPY(ff_expand_buffer, rel_fname, len + 1);", "      search_ctx->ffsc_start_dir = (char_u *)FullName_save((char *)ff_expand_buffer, FALSE);", "    } else"], "whitespace/line_length"]
["src/nvim/file_search.c", ["      STRLCPY(ff_expand_buffer, rel_fname, len + 1);", "      search_ctx->ffsc_start_dir = (char_u *)FullName_save((char *)ff_expand_buffer, FALSE);", "    } else"], "readability/bool"]
["src/nvim/file_search.c", ["      search_ctx->ffsc_start_dir = (char_u *)FullName_save((char *)ff_expand_buffer, FALSE);", "    } else", "      search_ctx->ffsc_start_dir = vim_strnsave(rel_fname, len);"], "readability/braces"]
["src/nvim/file_search.c", ["      search_ctx->ffsc_start_dir = vim_strnsave(rel_fname, len);", "    if (*++path != NUL)", "      ++path;"], "readability/braces"]
["src/nvim/file_search.c", ["    if (*++path != NUL)", "      ++path;", "  } else if (*path == NUL || !vim_isAbsName(path)) {"], "readability/increment"]
["src/nvim/file_search.c", ["#ifdef BACKSLASH_IN_FILENAME", "    /* \"c:dir\" needs \"c:\" to be expanded, otherwise use current dir */", "    if (*path != NUL && path[1] == ':') {"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["      path += 2;", "    } else", "#endif"], "readability/braces"]
["src/nvim/file_search.c", ["#endif", "    if (os_dirname(ff_expand_buffer, MAXPATHL) == FAIL)", "      goto error_return;"], "readability/braces"]
["src/nvim/file_search.c", ["#ifdef BACKSLASH_IN_FILENAME", "    /* A path that starts with \"/dir\" is relative to the drive, not to the", "     * directory (but not for \"//machine/dir\").  Only use the drive name. */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["     * directory (but not for \"//machine/dir\").  Only use the drive name. */", "    if ((*path == '/' || *path == '\\\\')", "        && path[1] != path[0]"], "readability/braces"]
["src/nvim/file_search.c", ["", "  /*", "   * If stopdirs are given, split them into an array of pointers."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "    while (*walker == ';')", "      walker++;"], "readability/braces"]
["src/nvim/file_search.c", ["      ptr = xrealloc(search_ctx->ffsc_stopdirs_v,", "          (dircount + 1) * sizeof(char_u *));", "      search_ctx->ffsc_stopdirs_v = ptr;"], "whitespace/alignment"]
["src/nvim/file_search.c", ["        walker++;", "      } else", "        /* this might be \"\", which means ascent till top"], "readability/braces"]
["src/nvim/file_search.c", ["      } else", "        /* this might be \"\", which means ascent till top", "         * of directory tree."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["      dircount++;", "", "    } while (walker != NULL);"], "whitespace/blank_line"]
["src/nvim/file_search.c", ["", "  /* split into:", "   *  -fix path"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "    /* save the fix part of the path */", "    assert(wc_part - path >= 0);"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "    /*", "     * copy wc_path and add restricts to the '**' wildcard."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["        llevel = strtol((char *)wc_part, &errpt, 10);", "        if ((char_u *)errpt != wc_part && llevel > 0 && llevel < 255)", "          ff_expand_buffer[len++] = (char_u)llevel;"], "readability/braces"]
["src/nvim/file_search.c", ["          ff_expand_buffer[len++] = (char_u)llevel;", "        else if ((char_u *)errpt != wc_part && llevel == 0)", "          /* restrict is 0 -> remove already added '**' */"], "readability/braces"]
["src/nvim/file_search.c", ["        else if ((char_u *)errpt != wc_part && llevel == 0)", "          /* restrict is 0 -> remove already added '**' */", "          len -= 2;"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["          len -= 2;", "        else", "          ff_expand_buffer[len++] = FF_MAX_STAR_STAR_EXPAND;"], "readability/braces"]
["src/nvim/file_search.c", ["          EMSG2(_(", "                  \"E343: Invalid path: '**[number]' must be at the end of the path or be followed by '%s'.\"),", "              PATHSEPSTR);"], "whitespace/indent"]
["src/nvim/file_search.c", ["                  \"E343: Invalid path: '**[number]' must be at the end of the path or be followed by '%s'.\"),", "              PATHSEPSTR);", "          goto error_return;"], "whitespace/alignment"]
["src/nvim/file_search.c", ["          EMSG2(_(", "                  \"E343: Invalid path: '**[number]' must be at the end of the path or be followed by '%s'.\"),", "              PATHSEPSTR);"], "whitespace/line_length"]
["src/nvim/file_search.c", ["        }", "      } else", "        ff_expand_buffer[len++] = *wc_part++;"], "readability/braces"]
["src/nvim/file_search.c", ["    search_ctx->ffsc_wc_path = vim_strsave(ff_expand_buffer);", "  } else", "    search_ctx->ffsc_fix_path = vim_strsave(path);"], "readability/braces"]
["src/nvim/file_search.c", ["  if (search_ctx->ffsc_start_dir == NULL) {", "    /* store the fix part as startdir.", "     * This is needed if the parameter path is fully qualified."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* create an absolute path */", "  if (STRLEN(search_ctx->ffsc_start_dir)"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["        len = (int)(p - search_ctx->ffsc_fix_path) - 1;", "        STRNCAT(ff_expand_buffer, search_ctx->ffsc_fix_path, len);", "        add_pathsep((char *)ff_expand_buffer);"], "runtime/printf"]
["src/nvim/file_search.c", ["  sptr = ff_create_stack_element(ff_expand_buffer,", "      search_ctx->ffsc_wc_path,", "      level, 0);"], "whitespace/alignment"]
["src/nvim/file_search.c", ["      search_ctx->ffsc_wc_path,", "      level, 0);", ""], "whitespace/alignment"]
["src/nvim/file_search.c", ["error_return:", "  /*", "   * We clear the search context now!"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * Get the stopdir string.  Check that ';' is not escaped."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    if (r_ptr[0] == '\\\\' && r_ptr[1] == ';') {", "      /* Overwrite the escape char,", "       * use STRLEN(r_ptr) to move the trailing '\\0'. */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    r_ptr++;", "  } else if (*r_ptr == NUL)", "    r_ptr = NULL;"], "readability/braces"]
["src/nvim/file_search.c", ["", "/*", " * Clean up the given search context. Can handle a NULL pointer."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["{", "  if (ctx == NULL)", "    return;"], "readability/braces"]
["src/nvim/file_search.c", ["", "/*", " * Find a file in a search context."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  if (search_ctx_arg == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/file_search.c", ["", "  /*", "   * filepath is used as buffer for various actions and as the storage to"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* store the end of the start dir -- needed for upward search */", "  if (search_ctx->ffsc_start_dir != NULL)"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  /* store the end of the start dir -- needed for upward search */", "  if (search_ctx->ffsc_start_dir != NULL)", "    path_end = &search_ctx->ffsc_start_dir["], "readability/braces"]
["src/nvim/file_search.c", ["    path_end = &search_ctx->ffsc_start_dir[", "      STRLEN(search_ctx->ffsc_start_dir)];", ""], "whitespace/indent"]
["src/nvim/file_search.c", ["", "  /* upward search loop */", "  for (;; ) {"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  for (;; ) {", "    /* downward search loop */", "    for (;; ) {"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    for (;; ) {", "      /* check if user user wants to stop the search*/", "      os_breakcheck();"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["      os_breakcheck();", "      if (got_int)", "        break;"], "readability/braces"]
["src/nvim/file_search.c", ["", "      /* get directory to work on from stack */", "      stackp = ff_pop(search_ctx);"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["      stackp = ff_pop(search_ctx);", "      if (stackp == NULL)", "        break;"], "readability/braces"]
["src/nvim/file_search.c", ["", "      /*", "       * TODO: decide if we leave this test in"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["          && ff_check_visited(&search_ctx->ffsc_dir_visited_list", "              ->ffvl_visited_list,", "              stackp->ffs_fix_path"], "whitespace/alignment"]
["src/nvim/file_search.c", ["              ->ffvl_visited_list,", "              stackp->ffs_fix_path", "              , stackp->ffs_wc_path"], "whitespace/alignment"]
["src/nvim/file_search.c", ["              stackp->ffs_fix_path", "              , stackp->ffs_wc_path", "              ) == FAIL) {"], "whitespace/alignment"]
["src/nvim/file_search.c", ["              , stackp->ffs_wc_path", "              ) == FAIL) {", "#ifdef FF_VERBOSE"], "whitespace/alignment"]
["src/nvim/file_search.c", ["          && ff_check_visited(&search_ctx->ffsc_dir_visited_list", "              ->ffvl_visited_list,", "              stackp->ffs_fix_path"], "whitespace/alignment"]
["src/nvim/file_search.c", ["              ->ffvl_visited_list,", "              stackp->ffs_fix_path", "              , stackp->ffs_wc_path"], "whitespace/alignment"]
["src/nvim/file_search.c", ["              stackp->ffs_fix_path", "              , stackp->ffs_wc_path", "              ) == FAIL) {"], "whitespace/alignment"]
["src/nvim/file_search.c", ["              , stackp->ffs_wc_path", "              ) == FAIL) {", "#ifdef FF_VERBOSE"], "whitespace/alignment"]
["src/nvim/file_search.c", ["              , stackp->ffs_wc_path", "              ) == FAIL) {", "#ifdef FF_VERBOSE"], "whitespace/parens"]
["src/nvim/file_search.c", ["#ifdef FF_VERBOSE", "      else if (p_verbose >= 5) {", "        verbose_enter_scroll();"], "readability/braces"]
["src/nvim/file_search.c", ["", "      /* check depth */", "      if (stackp->ffs_level <= 0) {"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "      /*", "       * If no filearray till now expand wildcards"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "        /* we use filepath to build the path expand_wildcards() should", "         * expand."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["            if (*p == 0) {", "              /* remove '**<numb> from wildcards */", "              STRMOVE(rest_of_wildcards, rest_of_wildcards + 3);"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["              STRMOVE(rest_of_wildcards, rest_of_wildcards + 3);", "            } else", "              rest_of_wildcards += 3;"], "readability/braces"]
["src/nvim/file_search.c", ["            if (stackp->ffs_star_star_empty == 0) {", "              /* if not done before, expand '**' to empty */", "              stackp->ffs_star_star_empty = 1;"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "          /*", "           * Here we copy until the next path separator or the end of"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["          file_path[len] = NUL;", "          if (vim_ispathsep(*rest_of_wildcards))", "            rest_of_wildcards++;"], "readability/braces"]
["src/nvim/file_search.c", ["", "        /*", "         * Expand wildcards like \"*\" and \"$VAR\"."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["          stackp->ffs_filearray_size = 1;", "        } else", "          /* Add EW_NOTWILD because the expanded path may contain"], "readability/braces"]
["src/nvim/file_search.c", ["        } else", "          /* Add EW_NOTWILD because the expanded path may contain", "           * wildcard characters that are to be taken literally."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["          expand_wildcards((dirptrs[1] == NULL) ? 1 : 2, dirptrs,", "              &stackp->ffs_filearray_size,", "              &stackp->ffs_filearray,"], "whitespace/alignment"]
["src/nvim/file_search.c", ["              &stackp->ffs_filearray_size,", "              &stackp->ffs_filearray,", "              EW_DIR|EW_ADDSLASH|EW_SILENT|EW_NOTWILD);"], "whitespace/alignment"]
["src/nvim/file_search.c", ["              &stackp->ffs_filearray,", "              EW_DIR|EW_ADDSLASH|EW_SILENT|EW_NOTWILD);", ""], "whitespace/alignment"]
["src/nvim/file_search.c", ["        stackp->ffs_stage = 0;", "      } else", "        rest_of_wildcards = &stackp->ffs_wc_path["], "readability/braces"]
["src/nvim/file_search.c", ["        rest_of_wildcards = &stackp->ffs_wc_path[", "          STRLEN(stackp->ffs_wc_path)];", ""], "whitespace/indent"]
["src/nvim/file_search.c", ["      if (stackp->ffs_stage == 0) {", "        /* this is the first time we work on this directory */", "        if (*rest_of_wildcards == NUL) {"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["        if (*rest_of_wildcards == NUL) {", "          /*", "           * We don't have further wildcards to expand, so we have to"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["          for (int i = stackp->ffs_filearray_cur;", "               i < stackp->ffs_filearray_size; ++i) {", "            if (!path_with_url((char *)stackp->ffs_filearray[i])"], "readability/increment"]
["src/nvim/file_search.c", ["               i < stackp->ffs_filearray_size; ++i) {", "            if (!path_with_url((char *)stackp->ffs_filearray[i])", "                && !os_isdir(stackp->ffs_filearray[i]))"], "readability/braces"]
["src/nvim/file_search.c", ["                && !os_isdir(stackp->ffs_filearray[i]))", "              continue;                 /* not a directory */", ""], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "            /*", "             * Try without extra suffix and then with suffixes"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["            len = STRLEN(file_path);", "            if (search_ctx->ffsc_tagfile)", "              suf = (char_u *)\"\";"], "readability/braces"]
["src/nvim/file_search.c", ["              suf = (char_u *)\"\";", "            else", "              suf = curbuf->b_p_sua;"], "readability/braces"]
["src/nvim/file_search.c", ["            for (;; ) {", "              /* if file exists and we didn't already find it */", "              if ((path_with_url((char *)file_path)"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["                  && (ff_check_visited(", "                          &search_ctx->ffsc_visited_list->ffvl_visited_list,", "                          file_path"], "whitespace/indent"]
["src/nvim/file_search.c", ["                          &search_ctx->ffsc_visited_list->ffvl_visited_list,", "                          file_path", "                          , (char_u *)\"\""], "whitespace/indent"]
["src/nvim/file_search.c", ["                          file_path", "                          , (char_u *)\"\"", "                          ) == OK)"], "whitespace/indent"]
["src/nvim/file_search.c", ["                          , (char_u *)\"\"", "                          ) == OK)", "#endif"], "whitespace/indent"]
["src/nvim/file_search.c", ["                  && (ff_check_visited(", "                          &search_ctx->ffsc_visited_list->ffvl_visited_list,", "                          file_path"], "whitespace/indent"]
["src/nvim/file_search.c", ["                          &search_ctx->ffsc_visited_list->ffvl_visited_list,", "                          file_path", "                          , (char_u *)\"\""], "whitespace/indent"]
["src/nvim/file_search.c", ["                          file_path", "                          , (char_u *)\"\"", "                          ) == OK)"], "whitespace/indent"]
["src/nvim/file_search.c", ["                          , (char_u *)\"\"", "                          ) == OK)", "#endif"], "whitespace/indent"]
["src/nvim/file_search.c", ["                          , (char_u *)\"\"", "                          ) == OK)", "#endif"], "whitespace/parens"]
["src/nvim/file_search.c", ["                if (ff_check_visited(", "                        &search_ctx->ffsc_visited_list->ffvl_visited_list,", "                        file_path"], "whitespace/indent"]
["src/nvim/file_search.c", ["                        &search_ctx->ffsc_visited_list->ffvl_visited_list,", "                        file_path", "                        , (char_u *)\"\""], "whitespace/indent"]
["src/nvim/file_search.c", ["                        file_path", "                        , (char_u *)\"\"", "                        ) == FAIL) {"], "whitespace/indent"]
["src/nvim/file_search.c", ["                        , (char_u *)\"\"", "                        ) == FAIL) {", "                  if (p_verbose >= 5) {"], "whitespace/indent"]
["src/nvim/file_search.c", ["                        , (char_u *)\"\"", "                        ) == FAIL) {", "                  if (p_verbose >= 5) {"], "whitespace/parens"]
["src/nvim/file_search.c", ["", "                /* push dir to examine rest of subdirs later */", "                assert(i < UCHAR_MAX - 1);"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "                if (!path_with_url((char *)file_path))", "                  simplify_filename(file_path);"], "readability/braces"]
["src/nvim/file_search.c", ["                  p = path_shorten_fname(file_path,", "                      ff_expand_buffer);", "                  if (p != NULL)"], "whitespace/alignment"]
["src/nvim/file_search.c", ["                      ff_expand_buffer);", "                  if (p != NULL)", "                    STRMOVE(file_path, p);"], "readability/braces"]
["src/nvim/file_search.c", ["", "              /* Not found or found already, try next suffix. */", "              if (*suf == NUL)"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["              /* Not found or found already, try next suffix. */", "              if (*suf == NUL)", "                break;"], "readability/braces"]
["src/nvim/file_search.c", ["              copy_option_part(&suf, file_path + len,", "                  MAXPATHL - len, \",\");", "            }"], "whitespace/alignment"]
["src/nvim/file_search.c", ["        } else {", "          /*", "           * still wildcards left, push the directories for further"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["          for (int i = stackp->ffs_filearray_cur;", "               i < stackp->ffs_filearray_size; ++i) {", "            if (!os_isdir(stackp->ffs_filearray[i]))"], "readability/increment"]
["src/nvim/file_search.c", ["               i < stackp->ffs_filearray_size; ++i) {", "            if (!os_isdir(stackp->ffs_filearray[i]))", "              continue;                 /* not a directory */"], "readability/braces"]
["src/nvim/file_search.c", ["            if (!os_isdir(stackp->ffs_filearray[i]))", "              continue;                 /* not a directory */", ""], "readability/old_style_comment"]
["src/nvim/file_search.c", ["            ff_push(search_ctx,", "                ff_create_stack_element(", "                    stackp->ffs_filearray[i],"], "whitespace/alignment"]
["src/nvim/file_search.c", ["", "      /*", "       * if wildcards contains '**' we have to descent till we reach the"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["        for (int i = stackp->ffs_filearray_cur;", "             i < stackp->ffs_filearray_size; ++i) {", "          if (fnamecmp(stackp->ffs_filearray[i],"], "readability/increment"]
["src/nvim/file_search.c", ["             i < stackp->ffs_filearray_size; ++i) {", "          if (fnamecmp(stackp->ffs_filearray[i],", "                  stackp->ffs_fix_path) == 0)"], "readability/braces"]
["src/nvim/file_search.c", ["          if (fnamecmp(stackp->ffs_filearray[i],", "                  stackp->ffs_fix_path) == 0)", "            continue;             /* don't repush same directory */"], "whitespace/alignment"]
["src/nvim/file_search.c", ["                  stackp->ffs_fix_path) == 0)", "            continue;             /* don't repush same directory */", "          if (!os_isdir(stackp->ffs_filearray[i]))"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["            continue;             /* don't repush same directory */", "          if (!os_isdir(stackp->ffs_filearray[i]))", "            continue;               /* not a directory */"], "readability/braces"]
["src/nvim/file_search.c", ["          if (!os_isdir(stackp->ffs_filearray[i]))", "            continue;               /* not a directory */", "          ff_push(search_ctx,"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["          ff_push(search_ctx,", "              ff_create_stack_element(stackp->ffs_filearray[i],", "                  stackp->ffs_wc_path, stackp->ffs_level - 1, 1));"], "whitespace/alignment"]
["src/nvim/file_search.c", ["              ff_create_stack_element(stackp->ffs_filearray[i],", "                  stackp->ffs_wc_path, stackp->ffs_level - 1, 1));", "        }"], "whitespace/alignment"]
["src/nvim/file_search.c", ["              ff_create_stack_element(stackp->ffs_filearray[i],", "                  stackp->ffs_wc_path, stackp->ffs_level - 1, 1));", "        }"], "whitespace/alignment"]
["src/nvim/file_search.c", ["", "      /* we are done with the current directory */", "      ff_free_stack_element(stackp);"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["      ff_free_stack_element(stackp);", "", "    }"], "whitespace/blank_line"]
["src/nvim/file_search.c", ["", "    /* If we reached this, we didn't find anything downwards.", "     * Let's check if we should do an upward search."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "      /* is the last starting directory in the stop list? */", "      if (ff_path_in_stoplist(search_ctx->ffsc_start_dir,"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["      /* is the last starting directory in the stop list? */", "      if (ff_path_in_stoplist(search_ctx->ffsc_start_dir,", "              (int)(path_end - search_ctx->ffsc_start_dir),"], "readability/braces"]
["src/nvim/file_search.c", ["      if (ff_path_in_stoplist(search_ctx->ffsc_start_dir,", "              (int)(path_end - search_ctx->ffsc_start_dir),", "              search_ctx->ffsc_stopdirs_v) == TRUE)"], "whitespace/alignment"]
["src/nvim/file_search.c", ["              (int)(path_end - search_ctx->ffsc_start_dir),", "              search_ctx->ffsc_stopdirs_v) == TRUE)", "        break;"], "whitespace/alignment"]
["src/nvim/file_search.c", ["              (int)(path_end - search_ctx->ffsc_start_dir),", "              search_ctx->ffsc_stopdirs_v) == TRUE)", "        break;"], "readability/bool"]
["src/nvim/file_search.c", ["", "      /* cut of last dir */", "      while (path_end > search_ctx->ffsc_start_dir"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["      /* cut of last dir */", "      while (path_end > search_ctx->ffsc_start_dir", "             && vim_ispathsep(*path_end))"], "readability/braces"]
["src/nvim/file_search.c", ["        path_end--;", "      while (path_end > search_ctx->ffsc_start_dir", "             && !vim_ispathsep(path_end[-1]))"], "readability/braces"]
["src/nvim/file_search.c", ["", "      if (*search_ctx->ffsc_start_dir == 0)", "        break;"], "readability/braces"]
["src/nvim/file_search.c", ["", "      /* create a new stack entry */", "      sptr = ff_create_stack_element(file_path,"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["      sptr = ff_create_stack_element(file_path,", "          search_ctx->ffsc_wc_path, search_ctx->ffsc_level, 0);", "      ff_push(search_ctx, sptr);"], "whitespace/alignment"]
["src/nvim/file_search.c", ["      ff_push(search_ctx, sptr);", "    } else", "      break;"], "readability/braces"]
["src/nvim/file_search.c", ["", "/*", " * Free the list of lists of visited files and directories"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  if (search_ctx_arg == NULL)", "    return;"], "readability/braces"]
["src/nvim/file_search.c", ["", "/*", " * Returns the already visited list for the given filename. If none is found it"], "readability/old_style_comment"]
["src/nvim/file_search.c", [" */", "static ff_visited_list_hdr_T *ff_get_visited_list(char_u *filename, ff_visited_list_hdr_T **list_headp)", "{"], "whitespace/line_length"]
["src/nvim/file_search.c", ["", "  /* check if a visited list for the given filename exists */", "  if (*list_headp != NULL) {"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /*", "   * if we reach this we didn't find a list and we have to allocate new list"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * maintains the list of already visited files and dirs"], "readability/old_style_comment"]
["src/nvim/file_search.c", [" */", "static int ff_check_visited(ff_visited_T **visited_list, char_u *fname, char_u *wc_path)", "{"], "whitespace/line_length"]
["src/nvim/file_search.c", ["", "  /* check against list of already visited files */", "  for (vp = *visited_list; vp != NULL; vp = vp->ffv_next) {"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /*", "   * New file/dir.  Add it to the list of visited files/dirs."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  if (wc_path != NULL)", "    vp->ffv_wc_path = vim_strsave(wc_path);"], "readability/braces"]
["src/nvim/file_search.c", ["    vp->ffv_wc_path = vim_strsave(wc_path);", "  else", "    vp->ffv_wc_path = NULL;"], "readability/braces"]
["src/nvim/file_search.c", ["", "/*", " * create stack element from given path pieces"], "readability/old_style_comment"]
["src/nvim/file_search.c", [" */", "static ff_stack_T *ff_create_stack_element(char_u *fix_part, char_u *wc_part, int level, int star_star_empty)", "{"], "whitespace/line_length"]
["src/nvim/file_search.c", ["", "  /* the following saves NULL pointer checks in vim_findfile */", "  if (fix_part == NULL)"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  /* the following saves NULL pointer checks in vim_findfile */", "  if (fix_part == NULL)", "    fix_part = (char_u *)\"\";"], "readability/braces"]
["src/nvim/file_search.c", ["", "  if (wc_part == NULL)", "    wc_part  = (char_u *)\"\";"], "readability/braces"]
["src/nvim/file_search.c", ["", "/*", " * Push a dir on the directory stack."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["{", "  /* check for NULL pointer, not to return an error to the user, but", "   * to prevent a crash */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * Pop a dir from the directory stack."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  sptr = search_ctx->ffsc_stack_ptr;", "  if (search_ctx->ffsc_stack_ptr != NULL)", "    search_ctx->ffsc_stack_ptr = search_ctx->ffsc_stack_ptr->ffs_prev;"], "readability/braces"]
["src/nvim/file_search.c", ["", "/*", " * free the given stack element"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * Clear the search context, but NOT the visited list."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* clear up stack */", "  while ((sptr = ff_pop(search_ctx)) != NULL)"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  /* clear up stack */", "  while ((sptr = ff_pop(search_ctx)) != NULL)", "    ff_free_stack_element(sptr);"], "readability/braces"]
["src/nvim/file_search.c", ["", "  /* reset everything */", "  search_ctx->ffsc_file_to_search = NULL;"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * check if the given path is in the stopdirs"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* eat up trailing path separators, except the first */", "  while (path_len > 1 && vim_ispathsep(path[path_len - 1]))"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  /* eat up trailing path separators, except the first */", "  while (path_len > 1 && vim_ispathsep(path[path_len - 1]))", "    path_len--;"], "readability/braces"]
["src/nvim/file_search.c", ["", "  /* if no path consider it as match */", "  if (path_len == 0)"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  /* if no path consider it as match */", "  if (path_len == 0)", "    return TRUE;"], "readability/braces"]
["src/nvim/file_search.c", ["  if (path_len == 0)", "    return TRUE;", ""], "readability/bool"]
["src/nvim/file_search.c", ["    if ((int)STRLEN(stopdirs_v[i]) > path_len) {", "      /* match for parent directory. So '/home' also matches", "       * '/home/rks'. Check for PATHSEP in stopdirs_v[i], else"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["       */", "      if (fnamencmp(stopdirs_v[i], path, path_len) == 0", "          && vim_ispathsep(stopdirs_v[i][path_len]))"], "readability/braces"]
["src/nvim/file_search.c", ["          && vim_ispathsep(stopdirs_v[i][path_len]))", "        return TRUE;", "    } else {"], "readability/bool"]
["src/nvim/file_search.c", ["    } else {", "      if (fnamecmp(stopdirs_v[i], path) == 0)", "        return TRUE;"], "readability/braces"]
["src/nvim/file_search.c", ["      if (fnamecmp(stopdirs_v[i], path) == 0)", "        return TRUE;", "    }"], "readability/bool"]
["src/nvim/file_search.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/file_search.c", ["", "/*", " * Find the file name \"ptr[len]\" in the path.  Also finds directory names."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["char_u *", "find_file_in_path (", "    char_u *ptr,               /* file name */"], "whitespace/parens"]
["src/nvim/file_search.c", ["find_file_in_path (", "    char_u *ptr,               /* file name */", "    size_t len,                /* length of file name */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    char_u *ptr,               /* file name */", "    size_t len,                /* length of file name */", "    int options,"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    int options,", "    int first,                      /* use count'th matching file name */", "    char_u *rel_fname         /* file name searching relative to */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    int first,                      /* use count'th matching file name */", "    char_u *rel_fname         /* file name searching relative to */", ")"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * Find the directory name \"ptr[len]\" in the path."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["char_u *", "find_directory_in_path (", "    char_u *ptr,               /* file name */"], "whitespace/parens"]
["src/nvim/file_search.c", ["find_directory_in_path (", "    char_u *ptr,               /* file name */", "    size_t len,                /* length of file name */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    char_u *ptr,               /* file name */", "    size_t len,                /* length of file name */", "    int options,"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    int options,", "    char_u *rel_fname         /* file name searching relative to */", ")"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["{", "  return find_file_in_path_option(ptr, len, options, TRUE, p_cdpath,", "                                  FINDFILE_DIR, rel_fname, (char_u *)\"\");"], "readability/bool"]
["src/nvim/file_search.c", ["char_u *", "find_file_in_path_option (", "    char_u *ptr,               /* file name */"], "whitespace/parens"]
["src/nvim/file_search.c", ["find_file_in_path_option (", "    char_u *ptr,               /* file name */", "    size_t len,                /* length of file name */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    char_u *ptr,               /* file name */", "    size_t len,                /* length of file name */", "    int options,"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    int options,", "    int first,                      /* use count'th matching file name */", "    char_u *path_option,       /* p_path or p_cdpath */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    int first,                      /* use count'th matching file name */", "    char_u *path_option,       /* p_path or p_cdpath */", "    int find_what,                  /* FINDFILE_FILE, _DIR or _BOTH */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    char_u *path_option,       /* p_path or p_cdpath */", "    int find_what,                  /* FINDFILE_FILE, _DIR or _BOTH */", "    char_u *rel_fname,         /* file name we are looking relative to. */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    int find_what,                  /* FINDFILE_FILE, _DIR or _BOTH */", "    char_u *rel_fname,         /* file name we are looking relative to. */", "    char_u *suffixes          /* list of suffixes, 'suffixesadd' option */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    char_u *rel_fname,         /* file name we are looking relative to. */", "    char_u *suffixes          /* list of suffixes, 'suffixesadd' option */", ")"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  static char_u       *dir;", "  static int did_findfile_init = FALSE;", "  char_u save_char;"], "readability/bool"]
["src/nvim/file_search.c", ["", "  if (first == TRUE) {", "    /* copy file name into NameBuff, expanding environment variables */"], "readability/bool"]
["src/nvim/file_search.c", ["  if (first == TRUE) {", "    /* copy file name into NameBuff, expanding environment variables */", "    save_char = ptr[len];"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["      // Change all \"\\ \" to \" \".", "      for (ptr = ff_file_to_find; *ptr != NUL; ++ptr) {", "        if (ptr[0] == '\\\\' && ptr[1] == ' ') {"], "readability/increment"]
["src/nvim/file_search.c", ["      ) {", "    /*", "     * Absolute path, no need to use \"path_option\"."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["     */", "    if (first == TRUE) {", "      if (path_with_url((char *)ff_file_to_find)) {"], "readability/bool"]
["src/nvim/file_search.c", ["", "      /* When FNAME_REL flag given first use the directory of the file.", "       * Otherwise or when this fails use the current directory. */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["       * Otherwise or when this fails use the current directory. */", "      for (int run = 1; run <= 2; ++run) {", "        size_t l = STRLEN(ff_file_to_find);"], "readability/increment"]
["src/nvim/file_search.c", ["", "        /* When the file doesn't exist, try adding parts of", "         * 'suffixesadd'. */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["          }", "          if (*buf == NUL)", "            break;"], "readability/braces"]
["src/nvim/file_search.c", ["  } else {", "    /*", "     * Loop over all paths in the 'path' or 'cdpath' option."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["     */", "    if (first == TRUE) {", "      /* vim_findfile_free_visited can handle a possible NULL pointer */"], "readability/bool"]
["src/nvim/file_search.c", ["    if (first == TRUE) {", "      /* vim_findfile_free_visited can handle a possible NULL pointer */", "      vim_findfile_free_visited(fdip_search_ctx);"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["      dir = path_option;", "      did_findfile_init = FALSE;", "    }"], "readability/bool"]
["src/nvim/file_search.c", ["        file_name = vim_findfile(fdip_search_ctx);", "        if (file_name != NULL)", "          break;"], "readability/braces"]
["src/nvim/file_search.c", ["", "        did_findfile_init = FALSE;", "      } else {"], "readability/bool"]
["src/nvim/file_search.c", ["        if (dir == NULL || *dir == NUL) {", "          /* We searched all paths of the option, now we can", "           * free the search context. */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "        /* copy next path */", "        buf[0] = 0;"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "        /* get the stopdir string */", "        r_ptr = vim_findfile_stopdir(buf);"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["        fdip_search_ctx = vim_findfile_init(buf, ff_file_to_find,", "            r_ptr, 100, FALSE, find_what,", "            fdip_search_ctx, FALSE, rel_fname);"], "whitespace/alignment"]
["src/nvim/file_search.c", ["            r_ptr, 100, FALSE, find_what,", "            fdip_search_ctx, FALSE, rel_fname);", "        if (fdip_search_ctx != NULL)"], "whitespace/alignment"]
["src/nvim/file_search.c", ["        fdip_search_ctx = vim_findfile_init(buf, ff_file_to_find,", "            r_ptr, 100, FALSE, find_what,", "            fdip_search_ctx, FALSE, rel_fname);"], "readability/bool"]
["src/nvim/file_search.c", ["            r_ptr, 100, FALSE, find_what,", "            fdip_search_ctx, FALSE, rel_fname);", "        if (fdip_search_ctx != NULL)"], "readability/bool"]
["src/nvim/file_search.c", ["            fdip_search_ctx, FALSE, rel_fname);", "        if (fdip_search_ctx != NULL)", "          did_findfile_init = TRUE;"], "readability/braces"]
["src/nvim/file_search.c", ["        if (fdip_search_ctx != NULL)", "          did_findfile_init = TRUE;", "        xfree(buf);"], "readability/bool"]
["src/nvim/file_search.c", ["  if (file_name == NULL && (options & FNAME_MESS)) {", "    if (first == TRUE) {", "      if (find_what == FINDFILE_DIR)"], "readability/bool"]
["src/nvim/file_search.c", ["    if (first == TRUE) {", "      if (find_what == FINDFILE_DIR)", "        EMSG2(_(\"E344: Can't find directory \\\"%s\\\" in cdpath\"),"], "readability/braces"]
["src/nvim/file_search.c", ["        EMSG2(_(\"E344: Can't find directory \\\"%s\\\" in cdpath\"),", "            ff_file_to_find);", "      else"], "whitespace/alignment"]
["src/nvim/file_search.c", ["            ff_file_to_find);", "      else", "        EMSG2(_(\"E345: Can't find file \\\"%s\\\" in path\"),"], "readability/braces"]
["src/nvim/file_search.c", ["        EMSG2(_(\"E345: Can't find file \\\"%s\\\" in path\"),", "            ff_file_to_find);", "    } else {"], "whitespace/alignment"]
["src/nvim/file_search.c", ["    } else {", "      if (find_what == FINDFILE_DIR)", "        EMSG2(_(\"E346: No more directory \\\"%s\\\" found in cdpath\"),"], "readability/braces"]
["src/nvim/file_search.c", ["        EMSG2(_(\"E346: No more directory \\\"%s\\\" found in cdpath\"),", "            ff_file_to_find);", "      else"], "whitespace/alignment"]
["src/nvim/file_search.c", ["            ff_file_to_find);", "      else", "        EMSG2(_(\"E347: No more file \\\"%s\\\" found in path\"),"], "readability/braces"]
["src/nvim/file_search.c", ["        EMSG2(_(\"E347: No more file \\\"%s\\\" found in path\"),", "            ff_file_to_find);", "    }"], "whitespace/alignment"]
