["src/nvim/move.c", ["", "/*", " * move.c: Functions for moving the cursor and scrolling text."], "readability/old_style_comment"]
["src/nvim/move.c", ["typedef struct {", "  linenr_T lnum;                /* line number */", "  int fill;                     /* filler lines */"], "readability/old_style_comment"]
["src/nvim/move.c", ["  linenr_T lnum;                /* line number */", "  int fill;                     /* filler lines */", "  int height;                   /* height of added line */"], "readability/old_style_comment"]
["src/nvim/move.c", ["  int fill;                     /* filler lines */", "  int height;                   /* height of added line */", "} lineoff_T;"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Compute wp->w_botline for the current wp->w_topline.  Can be called after"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * If w_cline_row is valid, start there."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /* wp->w_botline is the line that is just below the window */", "  wp->w_botline = lnum;"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Update curwin->w_topline and redraw if necessary."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Update curwin->w_topline to move the cursor onto the screen."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "      /* If we weren't very close to begin with, we scroll to put the", "       * cursor in the middle of the window.  Otherwise put the cursor"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * If the cursor is below the bottom of the window, scroll the window"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "          /* Cursor is (a few lines) above botline, check if there are", "           * 'scrolloff' window lines below the cursor.  If not, need to"], "readability/old_style_comment"]
["src/nvim/move.c", ["        } else {", "          /* sufficient context, no need to scroll */", "          check_botline = false;"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * Need to redraw when topline changed."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Update win->w_topline to move the cursor onto the screen."], "readability/old_style_comment"]
["src/nvim/move.c", [" */", "void update_topline_win(win_T* win)", "{"], "whitespace/operators"]
["src/nvim/move.c", ["", "/*", " * Return the scrolljump value to use for the current window."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Return true when there are not 'scrolloff' lines above the cursor for the"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Check if the cursor has moved.  Set the w_valid flag accordingly."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Call this function when some window settings have changed, which require"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Set wp->w_topline to a certain number."], "readability/old_style_comment"]
["src/nvim/move.c", ["{", "  /* go to first of folded lines */", "  (void)hasFoldingWin(wp, lnum, &lnum, NULL, true, NULL);"], "readability/old_style_comment"]
["src/nvim/move.c", ["  (void)hasFoldingWin(wp, lnum, &lnum, NULL, true, NULL);", "  /* Approximate the value of w_botline */", "  wp->w_botline += lnum - wp->w_topline;"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Call this function when the length of the cursor line (in screen"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Call this function when the length of a line (in screen characters) above"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Make sure the value of curwin->w_botline is valid."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Mark curwin->w_botline as invalid (because of some change in the buffer)."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Return true if curwin->w_wrow and curwin->w_wcol are valid."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Validate cursor position.  Makes sure w_wrow and w_wcol are valid."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Compute wp->w_cline_row and wp->w_cline_height, based on the current value"], "readability/old_style_comment"]
["src/nvim/move.c", ["{", "  /* Check if wp->w_lines[].wl_size is invalid */", "  int all_invalid = (!redrawing()"], "readability/old_style_comment"]
["src/nvim/move.c", ["  wp->w_cline_row = 0;", "  for (linenr_T lnum = wp->w_topline; lnum < wp->w_cursor.lnum; ++i) {", "    bool valid = false;"], "readability/increment"]
["src/nvim/move.c", ["    if (!all_invalid && i < wp->w_lines_valid) {", "      if (wp->w_lines[i].wl_lnum < lnum || !wp->w_lines[i].wl_valid)", "        continue;                       /* skip changed or deleted lines */"], "readability/braces"]
["src/nvim/move.c", ["      if (wp->w_lines[i].wl_lnum < lnum || !wp->w_lines[i].wl_valid)", "        continue;                       /* skip changed or deleted lines */", "      if (wp->w_lines[i].wl_lnum == lnum) {"], "readability/old_style_comment"]
["src/nvim/move.c", ["      if (wp->w_lines[i].wl_lnum == lnum) {", "        /* Check for newly inserted lines below this row, in which", "         * case we need to check for folded lines. */"], "readability/old_style_comment"]
["src/nvim/move.c", ["         * case we need to check for folded lines. */", "        if (!wp->w_buffer->b_mod_set", "            || wp->w_lines[i].wl_lastlnum < wp->w_cursor.lnum"], "readability/braces"]
["src/nvim/move.c", ["            || wp->w_lines[i].wl_lastlnum < wp->w_cursor.lnum", "                                            || wp->w_buffer->b_mod_top", "                                            > wp->w_lines[i].wl_lastlnum + 1)"], "whitespace/alignment"]
["src/nvim/move.c", ["                                            || wp->w_buffer->b_mod_top", "                                            > wp->w_lines[i].wl_lastlnum + 1)", "          valid = true;"], "whitespace/alignment"]
["src/nvim/move.c", ["      } else if (wp->w_lines[i].wl_lnum > lnum) {", "        --i;                            /* hold at inserted lines */", "      }"], "readability/old_style_comment"]
["src/nvim/move.c", ["      } else if (wp->w_lines[i].wl_lnum > lnum) {", "        --i;                            /* hold at inserted lines */", "      }"], "readability/increment"]
["src/nvim/move.c", ["      lnum = wp->w_lines[i].wl_lastlnum + 1;", "      /* Cursor inside folded lines, don't count this row */", "      if (lnum > wp->w_cursor.lnum)"], "readability/old_style_comment"]
["src/nvim/move.c", ["      /* Cursor inside folded lines, don't count this row */", "      if (lnum > wp->w_cursor.lnum)", "        break;"], "readability/braces"]
["src/nvim/move.c", ["    } else if (i > wp->w_lines_valid) {", "      /* a line that is too long to fit on the last screen line */", "      wp->w_cline_height = 0;"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Validate curwin->w_virtcol only."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Validate wp->w_virtcol only."], "readability/old_style_comment"]
["src/nvim/move.c", ["    wp->w_valid |= VALID_VIRTCOL;", "    if (wp->w_p_cuc", "        && !pum_visible()"], "readability/braces"]
["src/nvim/move.c", ["", "/*", " * Validate curwin->w_cline_height only."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Validate w_wcol and w_virtcol only."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Compute offset of a window, occupied by absolute or relative line number,"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Return the difference in column offset for the second screen line of a"], "readability/old_style_comment"]
["src/nvim/move.c", ["{", "  if ((wp->w_p_nu || wp->w_p_rnu) && vim_strchr(p_cpo, CPO_NUMCOL) != NULL)", "    return number_width(wp) + 1;"], "readability/braces"]
["src/nvim/move.c", ["", "  /*", "   * First make sure that w_topline is valid (after moving the cursor)."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * Compute the number of virtual columns."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /* remove '$' from change command when cursor moves onto it */", "  if (startcol > dollar_vcol)"], "readability/old_style_comment"]
["src/nvim/move.c", ["  /* remove '$' from change command when cursor moves onto it */", "  if (startcol > dollar_vcol)", "    dollar_vcol = -1;"], "readability/braces"]
["src/nvim/move.c", ["", "      /* When cursor wraps to first char of next line in Insert", "       * mode, the 'showbreak' string isn't shown, backup to first"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "      /* When far off or not enough room on either side, put cursor in", "       * middle of window. */"], "readability/old_style_comment"]
["src/nvim/move.c", ["      }", "      if (new_leftcol < 0)", "        new_leftcol = 0;"], "readability/braces"]
["src/nvim/move.c", ["", "  /* Skip over filler lines.  At the top use w_topfill, there", "   * may be some filler lines above the window. */"], "readability/old_style_comment"]
["src/nvim/move.c", ["      ) {", "    /* Cursor past end of screen.  Happens with a single line that does", "     * not fit on screen.  Find a skipcol to show the text around the"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /* Make sure w_topline is at the first of a sequence of folded lines. */", "  (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);"], "readability/old_style_comment"]
["src/nvim/move.c", ["  (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);", "  validate_cursor();            /* w_wrow needs to be valid */", "  while (line_count-- > 0) {"], "readability/old_style_comment"]
["src/nvim/move.c", ["    } else {", "      if (curwin->w_topline == 1)", "        break;"], "readability/braces"]
["src/nvim/move.c", ["        break;", "      --curwin->w_topline;", "      curwin->w_topfill = 0;"], "readability/increment"]
["src/nvim/move.c", ["      curwin->w_topfill = 0;", "      /* A sequence of folded lines only counts for one logical line */", "      linenr_T first;"], "readability/old_style_comment"]
["src/nvim/move.c", ["      if (hasFolding(curwin->w_topline, &first, NULL)) {", "        ++done;", "        if (!byfold)"], "readability/increment"]
["src/nvim/move.c", ["        ++done;", "        if (!byfold)", "          line_count -= curwin->w_topline - first - 1;"], "readability/braces"]
["src/nvim/move.c", ["        curwin->w_topline = first;", "      } else", "        done += plines_nofill(curwin->w_topline);"], "readability/braces"]
["src/nvim/move.c", ["    }", "    --curwin->w_botline;                /* approximate w_botline */", "    invalidate_botline();"], "readability/old_style_comment"]
["src/nvim/move.c", ["    }", "    --curwin->w_botline;                /* approximate w_botline */", "    invalidate_botline();"], "readability/increment"]
["src/nvim/move.c", ["  }", "  curwin->w_wrow += done;               /* keep w_wrow updated */", "  curwin->w_cline_row += done;          /* keep w_cline_row updated */"], "readability/old_style_comment"]
["src/nvim/move.c", ["  curwin->w_wrow += done;               /* keep w_wrow updated */", "  curwin->w_cline_row += done;          /* keep w_cline_row updated */", ""], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  if (curwin->w_cursor.lnum == curwin->w_topline)", "    curwin->w_cline_row = 0;"], "readability/braces"]
["src/nvim/move.c", ["", "  /*", "   * Compute the row number of the last row of the cursor line"], "readability/old_style_comment"]
["src/nvim/move.c", ["    if (hasFolding(curwin->w_cursor.lnum, &first, NULL)) {", "      --wrow;", "      if (first == 1)"], "readability/increment"]
["src/nvim/move.c", ["      --wrow;", "      if (first == 1)", "        curwin->w_cursor.lnum = 1;"], "readability/braces"]
["src/nvim/move.c", ["        curwin->w_cursor.lnum = 1;", "      else", "        curwin->w_cursor.lnum = first - 1;"], "readability/braces"]
["src/nvim/move.c", ["        curwin->w_cursor.lnum = first - 1;", "    } else", "      wrow -= plines(curwin->w_cursor.lnum--);"], "readability/braces"]
["src/nvim/move.c", ["  if (moved) {", "    /* Move cursor to first line of closed fold. */", "    foldAdjustCursor();"], "readability/old_style_comment"]
["src/nvim/move.c", ["    while (line_count--) {", "      if (curwin->w_topfill > 0)", "        --curwin->w_topfill;"], "readability/braces"]
["src/nvim/move.c", ["      if (curwin->w_topfill > 0)", "        --curwin->w_topfill;", "      else {"], "readability/increment"]
["src/nvim/move.c", ["        --curwin->w_topfill;", "      else {", "        if (byfold)"], "readability/braces"]
["src/nvim/move.c", ["        --curwin->w_topfill;", "      else {", "        if (byfold)"], "readability/braces"]
["src/nvim/move.c", ["      else {", "        if (byfold)", "          (void)hasFolding(lnum, NULL, &lnum);"], "readability/braces"]
["src/nvim/move.c", ["          (void)hasFolding(lnum, NULL, &lnum);", "        if (lnum >= curbuf->b_ml.ml_line_count)", "          break;"], "readability/braces"]
["src/nvim/move.c", ["          break;", "        ++lnum;", "        curwin->w_topfill = diff_check_fill(curwin, lnum);"], "readability/increment"]
["src/nvim/move.c", ["    }", "    /* approximate w_botline */", "    curwin->w_botline += lnum - curwin->w_topline;"], "readability/old_style_comment"]
["src/nvim/move.c", ["    curwin->w_topline += line_count;", "    curwin->w_botline += line_count;            /* approximate w_botline */", "  }"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  if (curwin->w_topline > curbuf->b_ml.ml_line_count)", "    curwin->w_topline = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/move.c", ["    curwin->w_topline = curbuf->b_ml.ml_line_count;", "  if (curwin->w_botline > curbuf->b_ml.ml_line_count + 1)", "    curwin->w_botline = curbuf->b_ml.ml_line_count + 1;"], "readability/braces"]
["src/nvim/move.c", ["", "  if (hasAnyFolding(curwin))", "    /* Make sure w_topline is at the first of a sequence of folded lines. */"], "readability/braces"]
["src/nvim/move.c", ["  if (hasAnyFolding(curwin))", "    /* Make sure w_topline is at the first of a sequence of folded lines. */", "    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Don't end up with too many filler lines in the window."], "readability/old_style_comment"]
["src/nvim/move.c", [" */", "void ", "check_topfill ("], "whitespace/end_of_line"]
["src/nvim/move.c", ["void ", "check_topfill (", "    win_T *wp,"], "whitespace/parens"]
["src/nvim/move.c", ["    win_T *wp,", "    bool down              /* when true scroll down when not enough space */", ")"], "readability/old_style_comment"]
["src/nvim/move.c", ["      if (down && wp->w_topline > 1) {", "        --wp->w_topline;", "        wp->w_topfill = 0;"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Use as many filler lines as possible for w_topline.  Make sure w_topline"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Scroll the screen one line down, but don't do it if it would move the"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  if (curwin->w_topline <= 1", "      && !can_fill"], "readability/braces"]
["src/nvim/move.c", ["", "  validate_cursor();        /* w_wrow needs to be valid */", ""], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * Compute the row number of the last row of the cursor line"], "readability/old_style_comment"]
["src/nvim/move.c", ["  int end_row = curwin->w_wrow;", "  if (can_fill)", "    ++end_row;"], "readability/braces"]
["src/nvim/move.c", ["  if (can_fill)", "    ++end_row;", "  else"], "readability/increment"]
["src/nvim/move.c", ["    ++end_row;", "  else", "    end_row += plines_nofill(curwin->w_topline - 1);"], "readability/braces"]
["src/nvim/move.c", ["    if (can_fill) {", "      ++curwin->w_topfill;", "      check_topfill(curwin, true);"], "readability/increment"]
["src/nvim/move.c", ["    } else {", "      --curwin->w_topline;", "      curwin->w_topfill = 0;"], "readability/increment"]
["src/nvim/move.c", ["    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);", "    --curwin->w_botline;            /* approximate w_botline */", "    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);"], "readability/old_style_comment"]
["src/nvim/move.c", ["    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);", "    --curwin->w_botline;            /* approximate w_botline */", "    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Scroll the screen one line up, but don't do it if it would move the cursor"], "readability/old_style_comment"]
["src/nvim/move.c", ["{", "  if (curwin->w_topline == curbuf->b_ml.ml_line_count", "      && curwin->w_topfill == 0"], "readability/braces"]
["src/nvim/move.c", ["", "  validate_cursor();        /* w_wrow needs to be valid */", ""], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * Compute the row number of the first row of the cursor line"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Add one line above \"lp->lnum\".  This can be a filler line, a closed fold or"], "readability/old_style_comment"]
["src/nvim/move.c", ["  } else {", "    --lp->lnum;", "    lp->fill = 0;"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Add one line below \"lp->lnum\".  This can be a filler line, a closed fold or"], "readability/old_style_comment"]
["src/nvim/move.c", ["  } else {", "    ++lp->lnum;", "    lp->fill = 0;"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Switch from including filler lines below lp->lnum to including filler"], "readability/old_style_comment"]
["src/nvim/move.c", ["  if (lp->fill > 0) {", "    ++lp->lnum;", "    lp->fill = diff_check_fill(curwin, lp->lnum) - lp->fill + 1;"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Switch from including filler lines above lp->lnum to including filler"], "readability/old_style_comment"]
["src/nvim/move.c", ["    lp->fill = diff_check_fill(curwin, lp->lnum) - lp->fill + 1;", "    --lp->lnum;", "  }"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Recompute topline to put the cursor at the top of the window."], "readability/old_style_comment"]
["src/nvim/move.c", ["  int scrolled = 0;", "  linenr_T top;                 /* just above displayed lines */", "  linenr_T bot;                 /* just below displayed lines */"], "readability/old_style_comment"]
["src/nvim/move.c", ["  linenr_T top;                 /* just above displayed lines */", "  linenr_T bot;                 /* just below displayed lines */", "  linenr_T old_topline = curwin->w_topline;"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  if (mouse_dragging > 0)", "    off = mouse_dragging - 1;"], "readability/braces"]
["src/nvim/move.c", ["", "  /*", "   * Decrease topline until:"], "readability/old_style_comment"]
["src/nvim/move.c", ["  if (hasFolding(curwin->w_cursor.lnum, &top, &bot)) {", "    --top;", "    ++bot;"], "readability/increment"]
["src/nvim/move.c", ["    --top;", "    ++bot;", "  } else {"], "readability/increment"]
["src/nvim/move.c", ["", "  /*", "   * Check if the lines from \"top\" to \"bot\" fit in the window.  If they do,"], "readability/old_style_comment"]
["src/nvim/move.c", ["    if (extra + i <= off && bot < curbuf->b_ml.ml_line_count) {", "      if (hasFolding(bot, NULL, &bot))", "        /* count one logical line for a sequence of folded lines */"], "readability/braces"]
["src/nvim/move.c", ["      if (hasFolding(bot, NULL, &bot))", "        /* count one logical line for a sequence of folded lines */", "        ++used;"], "readability/old_style_comment"]
["src/nvim/move.c", ["        /* count one logical line for a sequence of folded lines */", "        ++used;", "      else"], "readability/increment"]
["src/nvim/move.c", ["        ++used;", "      else", "        used += plines(bot);"], "readability/braces"]
["src/nvim/move.c", ["", "    /*", "     * If scrolling is needed, scroll at least 'sj' lines."], "readability/old_style_comment"]
["src/nvim/move.c", ["     */", "    if ((new_topline >= curwin->w_topline || scrolled > min_scroll)", "        && extra >= off)"], "readability/braces"]
["src/nvim/move.c", ["    new_topline = top;", "    --top;", "    ++bot;"], "readability/increment"]
["src/nvim/move.c", ["    --top;", "    ++bot;", "  }"], "readability/increment"]
["src/nvim/move.c", ["", "  /*", "   * If we don't have enough space, put cursor in the middle."], "readability/old_style_comment"]
["src/nvim/move.c", ["  } else {", "    /*", "     * If \"always\" is false, only adjust topline to a lower value, higher"], "readability/old_style_comment"]
["src/nvim/move.c", ["     */", "    if (new_topline < curwin->w_topline || always)", "      curwin->w_topline = new_topline;"], "readability/braces"]
["src/nvim/move.c", ["      curwin->w_topline = new_topline;", "    if (curwin->w_topline > curwin->w_cursor.lnum)", "      curwin->w_topline = curwin->w_cursor.lnum;"], "readability/braces"]
["src/nvim/move.c", ["      curwin->w_topfill -= extra - off;", "      if (curwin->w_topfill < 0)", "        curwin->w_topfill = 0;"], "readability/braces"]
["src/nvim/move.c", ["    check_topfill(curwin, false);", "    if (curwin->w_topline != old_topline", "        || curwin->w_topfill != old_topfill"], "readability/braces"]
["src/nvim/move.c", ["", "/*", " * Set w_empty_rows and w_filler_rows for window \"wp\", having used up \"used\""], "readability/old_style_comment"]
["src/nvim/move.c", ["      wp->w_filler_rows = diff_check_fill(wp, wp->w_botline);", "      if (wp->w_empty_rows > wp->w_filler_rows)", "        wp->w_empty_rows -= wp->w_filler_rows;"], "readability/braces"]
["src/nvim/move.c", ["        wp->w_empty_rows -= wp->w_filler_rows;", "      else {", "        wp->w_filler_rows = wp->w_empty_rows;"], "readability/braces"]
["src/nvim/move.c", ["        wp->w_empty_rows -= wp->w_filler_rows;", "      else {", "        wp->w_filler_rows = wp->w_empty_rows;"], "readability/braces"]
["src/nvim/move.c", ["", "/*", " * Recompute topline to put the cursor at the bottom of the window."], "readability/old_style_comment"]
["src/nvim/move.c", ["    curwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;", "    if (curwin->w_topline != old_topline", "        || curwin->w_topfill != old_topfill"], "readability/braces"]
["src/nvim/move.c", ["", "  /* The lines of the cursor line itself are always used. */", "  used = plines_nofill(cln);"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /* If the cursor is below botline, we will at least scroll by the height", "   * of the cursor line.  Correct for empty lines, which are really part of"], "readability/old_style_comment"]
["src/nvim/move.c", ["    scrolled = used;", "    if (cln == curwin->w_botline)", "      scrolled -= curwin->w_empty_rows;"], "readability/braces"]
["src/nvim/move.c", ["", "  /*", "   * Stop counting lines to scroll when"], "readability/old_style_comment"]
["src/nvim/move.c", ["  while (loff.lnum > 1) {", "    /* Stop when scrolled nothing or at least \"min_scroll\", found \"extra\"", "     * context for 'scrolloff' and counted all lines below the window. */"], "readability/old_style_comment"]
["src/nvim/move.c", ["        ) {", "      /* Count screen lines that are below the window. */", "      scrolled += loff.height;"], "readability/old_style_comment"]
["src/nvim/move.c", ["            ) {", "          /* Count screen lines that are below the window. */", "          scrolled += boff.height;"], "readability/old_style_comment"]
["src/nvim/move.c", ["          scrolled += boff.height;", "          if (boff.lnum == curwin->w_botline", "              && boff.fill == 0"], "readability/braces"]
["src/nvim/move.c", ["      i += boff.height;", "      ++line_count;", "    }"], "readability/increment"]
["src/nvim/move.c", ["    }", "    if (i < scrolled)           /* below curwin->w_botline, don't scroll */", "      line_count = 9999;"], "readability/old_style_comment"]
["src/nvim/move.c", ["    }", "    if (i < scrolled)           /* below curwin->w_botline, don't scroll */", "      line_count = 9999;"], "readability/braces"]
["src/nvim/move.c", ["", "  /*", "   * Scroll up if the cursor is off the bottom of the screen a bit."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * If topline didn't change we need to restore w_botline and w_empty_rows"], "readability/old_style_comment"]
["src/nvim/move.c", ["  while (topline > 1) {", "    if (below <= above) {           /* add a line below the cursor first */", "      if (boff.lnum < curbuf->b_ml.ml_line_count) {"], "readability/old_style_comment"]
["src/nvim/move.c", ["      } else {", "        ++below;                    /* count a \"~\" line */", "        if (atend)"], "readability/old_style_comment"]
["src/nvim/move.c", ["      } else {", "        ++below;                    /* count a \"~\" line */", "        if (atend)"], "readability/increment"]
["src/nvim/move.c", ["        ++below;                    /* count a \"~\" line */", "        if (atend)", "          ++used;"], "readability/braces"]
["src/nvim/move.c", ["        if (atend)", "          ++used;", "      }"], "readability/increment"]
["src/nvim/move.c", ["  }", "  if (!hasFolding(topline, &curwin->w_topline, NULL))", "    curwin->w_topline = topline;"], "readability/braces"]
["src/nvim/move.c", ["", "/*", " * Correct the cursor position so that it is in a part of the screen at least"], "readability/old_style_comment"]
["src/nvim/move.c", ["{", "  /*", "   * How many lines we would like to have above/below the cursor depends on"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * If there are sufficient file-lines above and below the cursor, we can"], "readability/old_style_comment"]
["src/nvim/move.c", ["   */", "  linenr_T cln = curwin->w_cursor.lnum; /* Cursor Line Number */", "  if (cln >= curwin->w_topline + above_wanted"], "readability/old_style_comment"]
["src/nvim/move.c", ["  linenr_T cln = curwin->w_cursor.lnum; /* Cursor Line Number */", "  if (cln >= curwin->w_topline + above_wanted", "      && cln < curwin->w_botline - below_wanted"], "readability/braces"]
["src/nvim/move.c", ["", "  /*", "   * Narrow down the area where the cursor can be put by taking lines from"], "readability/old_style_comment"]
["src/nvim/move.c", ["  linenr_T botline = curwin->w_botline - 1;", "  /* count filler lines as context */", "  int above = curwin->w_topfill; /* screen lines above topline */"], "readability/old_style_comment"]
["src/nvim/move.c", ["  /* count filler lines as context */", "  int above = curwin->w_topfill; /* screen lines above topline */", "  int below = curwin->w_filler_rows; /* screen lines below botline */"], "readability/old_style_comment"]
["src/nvim/move.c", ["  int above = curwin->w_topfill; /* screen lines above topline */", "  int below = curwin->w_filler_rows; /* screen lines below botline */", "  while ((above < above_wanted || below < below_wanted) && topline < botline) {"], "readability/old_style_comment"]
["src/nvim/move.c", ["    if (below < below_wanted && (below <= above || above >= above_wanted)) {", "      if (hasFolding(botline, &botline, NULL))", "        ++below;"], "readability/braces"]
["src/nvim/move.c", ["      if (hasFolding(botline, &botline, NULL))", "        ++below;", "      else"], "readability/increment"]
["src/nvim/move.c", ["        ++below;", "      else", "        below += plines(botline);"], "readability/braces"]
["src/nvim/move.c", ["        below += plines(botline);", "      --botline;", "    }"], "readability/increment"]
["src/nvim/move.c", ["    if (above < above_wanted && (above < below || below >= below_wanted)) {", "      if (hasFolding(topline, NULL, &topline))", "        ++above;"], "readability/braces"]
["src/nvim/move.c", ["      if (hasFolding(topline, NULL, &topline))", "        ++above;", "      else"], "readability/increment"]
["src/nvim/move.c", ["        ++above;", "      else", "        above += plines_nofill(topline);"], "readability/braces"]
["src/nvim/move.c", ["", "      /* Count filler lines below this line as context. */", "      if (topline < botline)"], "readability/old_style_comment"]
["src/nvim/move.c", ["      /* Count filler lines below this line as context. */", "      if (topline < botline)", "        above += diff_check_fill(curwin, topline + 1);"], "readability/braces"]
["src/nvim/move.c", ["        above += diff_check_fill(curwin, topline + 1);", "      ++topline;", "    }"], "readability/increment"]
["src/nvim/move.c", ["  }", "  if (topline == botline || botline == 0)", "    curwin->w_cursor.lnum = topline;"], "readability/braces"]
["src/nvim/move.c", ["    curwin->w_cursor.lnum = topline;", "  else if (topline > botline)", "    curwin->w_cursor.lnum = botline;"], "readability/braces"]
["src/nvim/move.c", ["    curwin->w_cursor.lnum = botline;", "  else {", "    if (cln < topline && curwin->w_topline > 1) {"], "readability/braces"]
["src/nvim/move.c", ["    curwin->w_cursor.lnum = botline;", "  else {", "    if (cln < topline && curwin->w_topline > 1) {"], "readability/braces"]
["src/nvim/move.c", ["", "/*", " * move screen 'count' pages up or down and update screen"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  if (curbuf->b_ml.ml_line_count == 1) {    /* nothing to do */", "    beep_flush();"], "readability/old_style_comment"]
["src/nvim/move.c", ["           diff_check_fill(curwin, curwin->w_topline)", "           )) {", "      beep_flush();"], "whitespace/parens"]
["src/nvim/move.c", ["      if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1) {", "        /* Vi compatible scrolling */", "        if (p_window <= 2)"], "readability/old_style_comment"]
["src/nvim/move.c", ["        /* Vi compatible scrolling */", "        if (p_window <= 2)", "          ++curwin->w_topline;"], "readability/braces"]
["src/nvim/move.c", ["        if (p_window <= 2)", "          ++curwin->w_topline;", "        else"], "readability/increment"]
["src/nvim/move.c", ["          ++curwin->w_topline;", "        else", "          curwin->w_topline += p_window - 2;"], "readability/braces"]
["src/nvim/move.c", ["          curwin->w_topline += p_window - 2;", "        if (curwin->w_topline > curbuf->b_ml.ml_line_count)", "          curwin->w_topline = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/move.c", ["      } else if (curwin->w_botline > curbuf->b_ml.ml_line_count) {", "        /* at end of file */", "        curwin->w_topline = curbuf->b_ml.ml_line_count;"], "readability/old_style_comment"]
["src/nvim/move.c", ["      } else {", "        /* For the overlap, start with the line just below the window", "         * and go upwards. */"], "readability/old_style_comment"]
["src/nvim/move.c", ["      }", "    } else {  /* dir == BACKWARDS */", "      if (curwin->w_topline == 1) {"], "readability/old_style_comment"]
["src/nvim/move.c", ["      if (curwin->w_topline == 1) {", "        /* Include max number of filler lines */", "        max_topfill();"], "readability/old_style_comment"]
["src/nvim/move.c", ["      if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1) {", "        /* Vi compatible scrolling (sort of) */", "        if (p_window <= 2)"], "readability/old_style_comment"]
["src/nvim/move.c", ["        /* Vi compatible scrolling (sort of) */", "        if (p_window <= 2)", "          --curwin->w_topline;"], "readability/braces"]
["src/nvim/move.c", ["        if (p_window <= 2)", "          --curwin->w_topline;", "        else"], "readability/increment"]
["src/nvim/move.c", ["          --curwin->w_topline;", "        else", "          curwin->w_topline -= p_window - 2;"], "readability/braces"]
["src/nvim/move.c", ["          curwin->w_topline -= p_window - 2;", "        if (curwin->w_topline < 1)", "          curwin->w_topline = 1;"], "readability/braces"]
["src/nvim/move.c", ["        curwin->w_cursor.lnum = curwin->w_topline + p_window - 1;", "        if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)", "          curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/move.c", ["", "      /* Find the line at the top of the window that is going to be the", "       * line at the bottom of the window.  Make sure this results in"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "      /* Find the line just above the new topline to get the right line", "       * at the bottom of the window. */"], "readability/old_style_comment"]
["src/nvim/move.c", ["      }", "      if (loff.lnum < 1) {                      /* at begin of file */", "        curwin->w_topline = 1;"], "readability/old_style_comment"]
["src/nvim/move.c", ["      } else {", "        /* Go two lines forward again. */", "        topline_botline(&loff);"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "        /* Always scroll at least one line.  Avoid getting stuck on", "         * very long lines. */"], "readability/old_style_comment"]
["src/nvim/move.c", ["            ) {", "          /* First try using the maximum number of filler lines.  If", "           * that's not enough, backup one line. */"], "readability/old_style_comment"]
["src/nvim/move.c", ["          loff.fill = curwin->w_topfill;", "          if (curwin->w_topfill < diff_check_fill(curwin,", "                  curwin->w_topline))"], "readability/braces"]
["src/nvim/move.c", ["          if (curwin->w_topfill < diff_check_fill(curwin,", "                  curwin->w_topline))", "            max_topfill();"], "whitespace/alignment"]
["src/nvim/move.c", ["          if (curwin->w_topfill == loff.fill) {", "            --curwin->w_topline;", "            curwin->w_topfill = 0;"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Decide how much overlap to use for page-up or page-down scrolling."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  if (lp->fill > 0)", "    lp->height = 1;"], "readability/braces"]
["src/nvim/move.c", ["    lp->height = 1;", "  else", "    lp->height = plines_nofill(lp->lnum);"], "readability/braces"]
["src/nvim/move.c", ["  int h1 = lp->height;", "  if (h1 > min_height)", "    return;             /* no overlap */"], "readability/braces"]
["src/nvim/move.c", ["  if (h1 > min_height)", "    return;             /* no overlap */", ""], "readability/old_style_comment"]
["src/nvim/move.c", ["  if (h2 == MAXCOL || h2 + h1 > min_height) {", "    *lp = loff0;        /* no overlap */", "    return;"], "readability/old_style_comment"]
["src/nvim/move.c", ["  if (h3 == MAXCOL || h3 + h2 > min_height) {", "    *lp = loff0;        /* no overlap */", "    return;"], "readability/old_style_comment"]
["src/nvim/move.c", ["  int h4 = lp->height;", "  if (h4 == MAXCOL || h4 + h3 + h2 > min_height || h3 + h2 + h1 > min_height)", "    *lp = loff1;        /* 1 line overlap */"], "readability/braces"]
["src/nvim/move.c", ["  if (h4 == MAXCOL || h4 + h3 + h2 > min_height || h3 + h2 + h1 > min_height)", "    *lp = loff1;        /* 1 line overlap */", "  else"], "readability/old_style_comment"]
["src/nvim/move.c", ["    *lp = loff1;        /* 1 line overlap */", "  else", "    *lp = loff2;        /* 2 lines overlap */"], "readability/braces"]
["src/nvim/move.c", ["  else", "    *lp = loff2;        /* 2 lines overlap */", "  return;"], "readability/old_style_comment"]
["src/nvim/move.c", ["  if (flag) {", "    /*", "     * scroll the text up"], "readability/old_style_comment"]
["src/nvim/move.c", ["        n -= i;", "        if (n < 0 && scrolled > 0)", "          break;"], "readability/braces"]
["src/nvim/move.c", ["        (void)hasFolding(curwin->w_topline, NULL, &curwin->w_topline);", "        ++curwin->w_topline;", "        curwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);"], "readability/increment"]
["src/nvim/move.c", ["        if (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count) {", "          ++curwin->w_cursor.lnum;", "          curwin->w_valid &="], "readability/increment"]
["src/nvim/move.c", ["", "      /*", "       * Correct w_botline for changed w_topline."], "readability/old_style_comment"]
["src/nvim/move.c", ["       */", "      if (curwin->w_p_diff)", "        curwin->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);"], "readability/braces"]
["src/nvim/move.c", ["        curwin->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);", "      else {", "        room += i;"], "readability/braces"]
["src/nvim/move.c", ["        curwin->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);", "      else {", "        room += i;"], "readability/braces"]
["src/nvim/move.c", ["          i = plines(curwin->w_botline);", "          if (i > room)", "            break;"], "readability/braces"]
["src/nvim/move.c", ["          (void)hasFolding(curwin->w_botline, NULL,", "              &curwin->w_botline);", "          ++curwin->w_botline;"], "whitespace/alignment"]
["src/nvim/move.c", ["              &curwin->w_botline);", "          ++curwin->w_botline;", "          room -= i;"], "readability/increment"]
["src/nvim/move.c", ["          (void)hasFolding(curwin->w_cursor.lnum, NULL,", "              &curwin->w_cursor.lnum);", "          ++curwin->w_cursor.lnum;"], "whitespace/alignment"]
["src/nvim/move.c", ["              &curwin->w_cursor.lnum);", "          ++curwin->w_cursor.lnum;", "        }"], "readability/increment"]
["src/nvim/move.c", ["        }", "      } else", "        curwin->w_cursor.lnum += n;"], "readability/braces"]
["src/nvim/move.c", ["  } else {", "    /*", "     * scroll the text down"], "readability/old_style_comment"]
["src/nvim/move.c", ["        n -= i;", "        if (n < 0 && scrolled > 0)", "          break;"], "readability/braces"]
["src/nvim/move.c", ["          break;", "        --curwin->w_topline;", "        (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);"], "readability/increment"]
["src/nvim/move.c", ["      if (curwin->w_cursor.lnum > 1) {", "        --curwin->w_cursor.lnum;", "        curwin->w_valid &= ~(VALID_VIRTCOL|VALID_CHEIGHT|VALID_WCOL);"], "readability/increment"]
["src/nvim/move.c", ["    if (n > 0) {", "      if (curwin->w_cursor.lnum <= (linenr_T)n)", "        curwin->w_cursor.lnum = 1;"], "readability/braces"]
["src/nvim/move.c", ["        curwin->w_cursor.lnum = 1;", "      else if (hasAnyFolding(curwin)) {", "        while (--n >= 0 && curwin->w_cursor.lnum > 1) {"], "readability/braces"]
["src/nvim/move.c", ["        while (--n >= 0 && curwin->w_cursor.lnum > 1) {", "          --curwin->w_cursor.lnum;", "          (void)hasFolding(curwin->w_cursor.lnum,"], "readability/increment"]
["src/nvim/move.c", ["          (void)hasFolding(curwin->w_cursor.lnum,", "              &curwin->w_cursor.lnum, NULL);", "        }"], "whitespace/alignment"]
["src/nvim/move.c", ["        }", "      } else", "        curwin->w_cursor.lnum -= n;"], "readability/braces"]
["src/nvim/move.c", ["  }", "  /* Move cursor to first line of closed fold. */", "  foldAdjustCursor();"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * loop through the cursorbound windows"], "readability/old_style_comment"]
["src/nvim/move.c", ["    curbuf = curwin->w_buffer;", "    /* skip original window  and windows with 'noscrollbind' */", "    if (curwin != old_curwin && curwin->w_p_crb) {"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "      /* Make sure the cursor is in a valid position.  Temporarily set", "       * \"restart_edit\" to allow the cursor to be beyond the EOL. */"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * reset current-window"], "readability/old_style_comment"]
