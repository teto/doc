["src/nvim/eval/encode.c", ["  }", "  list_T *const list = (list_T *) data;", "  const char *const end = buf + len;"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["    const char *line_start = line_end;", "    line_end = xmemscan(line_start, NL, (size_t) (end - line_start));", "    char *str = NULL;"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["        char *const key = encode_tv2string(&key_tv, NULL);", "        vim_snprintf((char *) IObuff, IOSIZE, key_msg, key);", "        xfree(key);"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["          char *const key = encode_tv2echo(&key_tv, NULL);", "          vim_snprintf((char *) IObuff, IOSIZE, key_pair_msg, key, idx);", "          xfree(key);"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["      if (state->li == NULL) {", "        *read_bytes = (size_t) (p - buf);", "        return OK;"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["    do { \\", "      const char *const buf_ = (const char *) buf; \\", "      if (buf == NULL) { \\"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["        const size_t len_ = (len); \\", "        ga_grow(gap, (int) (2 + len_ + memcnt(buf_, '\\'', len_))); \\", "        ga_append(gap, '\\''); \\"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["      char numbuf[NUMBUFLEN]; \\", "      vim_snprintf(numbuf, ARRAY_SIZE(numbuf), \"%\" PRId64, (int64_t) (num)); \\", "      ga_concat(gap, numbuf); \\"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["          vim_snprintf(numbuf, ARRAY_SIZE(numbuf), \"%g\", flt_); \\", "          ga_concat(gap, (char_u *) numbuf); \\", "        } \\"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["          if (conv_type == kMPConvDict) { \\", "            if ((void *) mpval.data.d.dict == (void *) (val)) { \\", "              break; \\"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["          } else if (conv_type == kMPConvList) { \\", "            if ((void *) mpval.data.l.list == (void *) (val)) { \\", "              break; \\"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["          if (conv_type == kMPConvDict) { \\", "            if ((void *) mpval.data.d.dict == (void *) val) { \\", "              break; \\"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["          } else if (conv_type == kMPConvList) { \\", "            if ((void *) mpval.data.l.list == (void *) val) { \\", "              break; \\"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["          vim_snprintf(numbuf, ARRAY_SIZE(numbuf), \"%g\", flt_); \\", "          ga_concat(gap, (char_u *) numbuf); \\", "          break; \\"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["            str_len += ((sizeof(\"\\\\u1234\") - 1)", "                        * (size_t) (1 + (ch >= SURROGATE_FIRST_CHAR)));", "          }"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["    ga_append(gap, '\"');", "    ga_grow(gap, (int) str_len);", "    for (size_t i = 0; i < utf_len;) {"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["    do { \\", "      if (convert_to_json_string(gap, (const char *) (buf), (len)) != OK) { \\", "        return FAIL; \\"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["  if (len != NULL) {", "    *len = (size_t) ga.ga_len;", "  }"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["  ga_append(&ga, '\\0');", "  return (char *) ga.ga_data;", "}"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["  if (len != NULL) {", "    *len = (size_t) ga.ga_len;", "  }"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["  ga_append(&ga, '\\0');", "  return (char *) ga.ga_data;", "}"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["      if (buf == NULL) { \\", "        msgpack_pack_ext(packer, 0, (int8_t) type); \\", "      } else { \\"], "whitespace/cast"]
["src/nvim/eval/encode.c", ["        const size_t len_ = (len); \\", "        msgpack_pack_ext(packer, len_, (int8_t) type); \\", "        msgpack_pack_ext_body(packer, buf, len_); \\"], "whitespace/cast"]
