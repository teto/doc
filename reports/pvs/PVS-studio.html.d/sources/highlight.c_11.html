
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>highlight.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// highlight.c: low level code for UI and syntax highlighting</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;nvim/vim.h&quot;</a>
<a name="ln7">#include &quot;nvim/highlight.h&quot;</a>
<a name="ln8">#include &quot;nvim/highlight_defs.h&quot;</a>
<a name="ln9">#include &quot;nvim/map.h&quot;</a>
<a name="ln10">#include &quot;nvim/message.h&quot;</a>
<a name="ln11">#include &quot;nvim/option.h&quot;</a>
<a name="ln12">#include &quot;nvim/popupmnu.h&quot;</a>
<a name="ln13">#include &quot;nvim/screen.h&quot;</a>
<a name="ln14">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln15">#include &quot;nvim/ui.h&quot;</a>
<a name="ln16">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln17">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln18">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln19"> </a>
<a name="ln20">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln21"># include &quot;highlight.c.generated.h&quot;</a>
<a name="ln22">#endif</a>
<a name="ln23"> </a>
<a name="ln24">static bool hlstate_active = false;</a>
<a name="ln25"> </a>
<a name="ln26">static kvec_t(HlEntry) attr_entries = KV_INITIAL_VALUE;</a>
<a name="ln27"> </a>
<a name="ln28">static Map(HlEntry, int) *attr_entry_ids;</a>
<a name="ln29">static Map(int, int) *combine_attr_entries;</a>
<a name="ln30">static Map(int, int) *blend_attr_entries;</a>
<a name="ln31">static Map(int, int) *blendthrough_attr_entries;</a>
<a name="ln32"> </a>
<a name="ln33">/// highlight entries private to a namespace</a>
<a name="ln34">static Map(ColorKey, ColorItem) *ns_hl;</a>
<a name="ln35"> </a>
<a name="ln36">void highlight_init(void)</a>
<a name="ln37">{</a>
<a name="ln38">  attr_entry_ids = map_new(HlEntry, int)();</a>
<a name="ln39">  combine_attr_entries = map_new(int, int)();</a>
<a name="ln40">  blend_attr_entries = map_new(int, int)();</a>
<a name="ln41">  blendthrough_attr_entries = map_new(int, int)();</a>
<a name="ln42">  ns_hl = map_new(ColorKey, ColorItem)();</a>
<a name="ln43"> </a>
<a name="ln44">  // index 0 is no attribute, add dummy entry:</a>
<a name="ln45">  kv_push(attr_entries, ((HlEntry){ .attr = HLATTRS_INIT, .kind = kHlUnknown,</a>
<a name="ln46">                                    .id1 = 0, .id2 = 0 }));</a>
<a name="ln47">}</a>
<a name="ln48"> </a>
<a name="ln49">/// @return TRUE if hl table was reset</a>
<a name="ln50">bool highlight_use_hlstate(void)</a>
<a name="ln51">{</a>
<a name="ln52">  if (hlstate_active) {</a>
<a name="ln53">    return false;</a>
<a name="ln54">  }</a>
<a name="ln55">  hlstate_active = true;</a>
<a name="ln56">  // hl tables must now be rebuilt.</a>
<a name="ln57">  clear_hl_tables(true);</a>
<a name="ln58">  return true;</a>
<a name="ln59">}</a>
<a name="ln60"> </a>
<a name="ln61">/// Return the attr number for a set of colors and font, and optionally</a>
<a name="ln62">/// a semantic description (see ext_hlstate documentation).</a>
<a name="ln63">/// Add a new entry to the attr_entries array if the combination is new.</a>
<a name="ln64">/// @return 0 for error.</a>
<a name="ln65">static int get_attr_entry(HlEntry entry)</a>
<a name="ln66">{</a>
<a name="ln67">  if (!hlstate_active) {</a>
<a name="ln68">    // This information will not be used, erase it and reduce the table size.</a>
<a name="ln69">    entry.kind = kHlUnknown;</a>
<a name="ln70">    entry.id1 = 0;</a>
<a name="ln71">    entry.id2 = 0;</a>
<a name="ln72">  }</a>
<a name="ln73"> </a>
<a name="ln74">  int id = map_get(HlEntry, int)(attr_entry_ids, entry);</a>
<a name="ln75">  if (id &gt; 0) {</a>
<a name="ln76">    return id;</a>
<a name="ln77">  }</a>
<a name="ln78"> </a>
<a name="ln79">  static bool recursive = false;</a>
<a name="ln80">  if (kv_size(attr_entries) &gt; MAX_TYPENR) {</a>
<a name="ln81">    // Running out of attribute entries!  remove all attributes, and</a>
<a name="ln82">    // compute new ones for all groups.</a>
<a name="ln83">    // When called recursively, we are really out of numbers.</a>
<a name="ln84">    if (recursive) {</a>
<a name="ln85">      EMSG(_(&quot;E424: Too many different highlighting attributes in use&quot;));</a>
<a name="ln86">      return 0;</a>
<a name="ln87">    }</a>
<a name="ln88">    recursive = true;</a>
<a name="ln89"> </a>
<a name="ln90">    clear_hl_tables(true);</a>
<a name="ln91"> </a>
<a name="ln92">    recursive = false;</a>
<a name="ln93">    if (entry.kind == kHlCombine) {</a>
<a name="ln94">      // This entry is now invalid, don't put it</a>
<a name="ln95">      return 0;</a>
<a name="ln96">    }</a>
<a name="ln97">  }</a>
<a name="ln98"> </a>
<a name="ln99">  size_t next_id = kv_size(attr_entries);</a>
<a name="ln100">  if (next_id &gt; INT_MAX) {</a>
<a name="ln101">    ELOG(&quot;The index on attr_entries has overflowed&quot;);</a>
<a name="ln102">    return 0;</a>
<a name="ln103">  }</a>
<a name="ln104">  id = (int)next_id;</a>
<a name="ln105">  kv_push(attr_entries, entry);</a>
<a name="ln106"> </a>
<a name="ln107">  map_put(HlEntry, int)(attr_entry_ids, entry, id);</a>
<a name="ln108"> </a>
<a name="ln109">  Array inspect = hl_inspect(id);</a>
<a name="ln110"> </a>
<a name="ln111">  // Note: internally we don't distinguish between cterm and rgb attributes,</a>
<a name="ln112">  // remote_ui_hl_attr_define will however.</a>
<a name="ln113">  ui_call_hl_attr_define(id, entry.attr, entry.attr, inspect);</a>
<a name="ln114">  api_free_array(inspect);</a>
<a name="ln115">  return id;</a>
<a name="ln116">}</a>
<a name="ln117"> </a>
<a name="ln118">/// When a UI connects, we need to send it the table of highlights used so far.</a>
<a name="ln119">void ui_send_all_hls(UI *ui)</a>
<a name="ln120">{</a>
<a name="ln121">  if (ui-&gt;hl_attr_define) {</a>
<a name="ln122">    for (size_t i = 1; i &lt; kv_size(attr_entries); i++) {</a>
<a name="ln123">      Array inspect = hl_inspect((int)i);</a>
<a name="ln124">      ui-&gt;hl_attr_define(ui, (Integer)i, kv_A(attr_entries, i).attr,</a>
<a name="ln125">                         kv_A(attr_entries, i).attr, inspect);</a>
<a name="ln126">      api_free_array(inspect);</a>
<a name="ln127">    }</a>
<a name="ln128">  }</a>
<a name="ln129">  if (ui-&gt;hl_group_set) {</a>
<a name="ln130">    for (size_t hlf = 0; hlf &lt; HLF_COUNT; hlf++) {</a>
<a name="ln131">      ui-&gt;hl_group_set(ui, cstr_as_string((char *)hlf_names[hlf]),</a>
<a name="ln132">                       highlight_attr[hlf]);</a>
<a name="ln133">    }</a>
<a name="ln134">  }</a>
<a name="ln135">}</a>
<a name="ln136"> </a>
<a name="ln137">/// Get attribute code for a syntax group.</a>
<a name="ln138">int hl_get_syn_attr(int ns_id, int idx, HlAttrs at_en)</a>
<a name="ln139">{</a>
<a name="ln140">  // TODO(bfredl): should we do this unconditionally</a>
<a name="ln141">  if (at_en.cterm_fg_color != 0 || at_en.cterm_bg_color != 0</a>
<a name="ln142">      || at_en.rgb_fg_color != -1 || at_en.rgb_bg_color != -1</a>
<a name="ln143">      || at_en.rgb_sp_color != -1 || at_en.cterm_ae_attr != 0</a>
<a name="ln144">      || at_en.rgb_ae_attr != 0 || ns_id != 0) {</a>
<a name="ln145">    return get_attr_entry((HlEntry){ .attr = at_en, .kind = kHlSyntax,</a>
<a name="ln146">                                     .id1 = idx, .id2 = ns_id });</a>
<a name="ln147">  } else {</a>
<a name="ln148">    // If all the fields are cleared, clear the attr field back to default value</a>
<a name="ln149">    return 0;</a>
<a name="ln150">  }</a>
<a name="ln151">}</a>
<a name="ln152"> </a>
<a name="ln153">void ns_hl_def(NS ns_id, int hl_id, HlAttrs attrs, int link_id)</a>
<a name="ln154">{</a>
<a name="ln155">  DecorProvider *p = get_decor_provider(ns_id, true);</a>
<a name="ln156">  if ((attrs.rgb_ae_attr &amp; HL_DEFAULT)</a>
<a name="ln157">      &amp;&amp; map_has(ColorKey, ColorItem)(ns_hl, ColorKey(ns_id, hl_id))) {</a>
<a name="ln158">    return;</a>
<a name="ln159">  }</a>
<a name="ln160">  int attr_id = link_id &gt; 0 ? -1 : hl_get_syn_attr(ns_id, hl_id, attrs);</a>
<a name="ln161">  ColorItem it = { .attr_id = attr_id,</a>
<a name="ln162">                   .link_id = link_id,</a>
<a name="ln163">                   .version = p-&gt;hl_valid,</a>
<a name="ln164">                   .is_default = (attrs.rgb_ae_attr &amp; HL_DEFAULT) };</a>
<a name="ln165">  map_put(ColorKey, ColorItem)(ns_hl, ColorKey(ns_id, hl_id), it);</a>
<a name="ln166">}</a>
<a name="ln167"> </a>
<a name="ln168">int ns_get_hl(NS ns_id, int hl_id, bool link, bool nodefault)</a>
<a name="ln169">{</a>
<a name="ln170">  static int recursive = 0;</a>
<a name="ln171"> </a>
<a name="ln172">  if (ns_id &lt; 0) {</a>
<a name="ln173">    if (ns_hl_active &lt;= 0) {</a>
<a name="ln174">      return -1;</a>
<a name="ln175">    }</a>
<a name="ln176">    ns_id = ns_hl_active;</a>
<a name="ln177">  }</a>
<a name="ln178"> </a>
<a name="ln179">  DecorProvider *p = get_decor_provider(ns_id, true);</a>
<a name="ln180">  ColorItem it = map_get(ColorKey, ColorItem)(ns_hl, ColorKey(ns_id, hl_id));</a>
<a name="ln181">  // TODO(bfredl): map_ref true even this?</a>
<a name="ln182">  bool valid_cache = it.version &gt;= p-&gt;hl_valid;</a>
<a name="ln183"> </a>
<a name="ln184">  if (!valid_cache &amp;&amp; p-&gt;hl_def != LUA_NOREF &amp;&amp; !recursive) {</a>
<a name="ln185">    FIXED_TEMP_ARRAY(args, 3);</a>
<a name="ln186">    args.items[0] = INTEGER_OBJ((Integer)ns_id);</a>
<a name="ln187">    args.items[1] = STRING_OBJ(cstr_to_string((char *)syn_id2name(hl_id)));</a>
<a name="ln188">    args.items[2] = BOOLEAN_OBJ(link);</a>
<a name="ln189">    // TODO(bfredl): preload the &quot;global&quot; attr dict?</a>
<a name="ln190"> </a>
<a name="ln191">    Error err = ERROR_INIT;</a>
<a name="ln192">    recursive++;</a>
<a name="ln193">    Object ret = nlua_call_ref(p-&gt;hl_def, &quot;hl_def&quot;, args, true, &amp;err);</a>
<a name="ln194">    recursive--;</a>
<a name="ln195"> </a>
<a name="ln196">    // TODO(bfredl): or &quot;inherit&quot;, combine with global value?</a>
<a name="ln197">    bool fallback = true;</a>
<a name="ln198">    int tmp = false;</a>
<a name="ln199">    HlAttrs attrs = HLATTRS_INIT;</a>
<a name="ln200">    if (ret.type == kObjectTypeDictionary) {</a>
<a name="ln201">      Dictionary dict = ret.data.dictionary;</a>
<a name="ln202">      fallback = false;</a>
<a name="ln203">      attrs = dict2hlattrs(dict, true, &amp;it.link_id, &amp;err);</a>
<a name="ln204">      for (size_t i = 0; i &lt; dict.size; i++) {</a>
<a name="ln205">        char *key = dict.items[i].key.data;</a>
<a name="ln206">        Object val = dict.items[i].value;</a>
<a name="ln207">        bool truthy = api_object_to_bool(val, key, false, &amp;err);</a>
<a name="ln208"> </a>
<a name="ln209">        if (strequal(key, &quot;fallback&quot;)) {</a>
<a name="ln210">          fallback = truthy;</a>
<a name="ln211">        } else if (strequal(key, &quot;temp&quot;)) {</a>
<a name="ln212">          tmp = truthy;</a>
<a name="ln213">        }</a>
<a name="ln214">      }</a>
<a name="ln215">      if (it.link_id &gt;= 0) {</a>
<a name="ln216">        fallback = true;</a>
<a name="ln217">      }</a>
<a name="ln218">    }</a>
<a name="ln219"> </a>
<a name="ln220">    it.attr_id = fallback ? -1 : hl_get_syn_attr((int)ns_id, hl_id, attrs);</a>
<a name="ln221">    it.version = p-&gt;hl_valid-tmp;</a>
<a name="ln222">    it.is_default = attrs.rgb_ae_attr &amp; HL_DEFAULT;</a>
<a name="ln223">    map_put(ColorKey, ColorItem)(ns_hl, ColorKey(ns_id, hl_id), it);</a>
<a name="ln224">  }</a>
<a name="ln225"> </a>
<a name="ln226">  if (it.is_default &amp;&amp; nodefault) {</a>
<a name="ln227">    return -1;</a>
<a name="ln228">  }</a>
<a name="ln229"> </a>
<a name="ln230">  if (link) {</a>
<a name="ln231">    return it.attr_id &gt;= 0 ? 0 : it.link_id;</a>
<a name="ln232">  } else {</a>
<a name="ln233">    return it.attr_id;</a>
<a name="ln234">  }</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237"> </a>
<a name="ln238">bool win_check_ns_hl(win_T *wp)</a>
<a name="ln239">{</a>
<a name="ln240">  if (ns_hl_changed) {</a>
<a name="ln241">    highlight_changed();</a>
<a name="ln242">    if (wp) {</a>
<a name="ln243">      update_window_hl(wp, true);</a>
<a name="ln244">    }</a>
<a name="ln245">    ns_hl_changed = false;</a>
<a name="ln246">    return true;</a>
<a name="ln247">  }</a>
<a name="ln248">  return false;</a>
<a name="ln249">}</a>
<a name="ln250"> </a>
<a name="ln251">/// Get attribute code for a builtin highlight group.</a>
<a name="ln252">///</a>
<a name="ln253">/// The final syntax group could be modified by hi-link or 'winhighlight'.</a>
<a name="ln254">int hl_get_ui_attr(int idx, int final_id, bool optional)</a>
<a name="ln255">{</a>
<a name="ln256">  HlAttrs attrs = HLATTRS_INIT;</a>
<a name="ln257">  bool available = false;</a>
<a name="ln258"> </a>
<a name="ln259">  if (final_id &gt; 0) {</a>
<a name="ln260">    int syn_attr = syn_id2attr(final_id);</a>
<a name="ln261">    if (syn_attr != 0) {</a>
<a name="ln262">      attrs = syn_attr2entry(syn_attr);</a>
<a name="ln263">      available = true;</a>
<a name="ln264">    }</a>
<a name="ln265">  }</a>
<a name="ln266"> </a>
<a name="ln267">  if (HLF_PNI &lt;= idx &amp;&amp; idx &lt;= HLF_PST) {</a>
<a name="ln268">    if (attrs.hl_blend == -1 &amp;&amp; p_pb &gt; 0) {</a>
<a name="ln269">      attrs.hl_blend = (int)p_pb;</a>
<a name="ln270">    }</a>
<a name="ln271">    if (pum_drawn()) {</a>
<a name="ln272">      must_redraw_pum = true;</a>
<a name="ln273">    }</a>
<a name="ln274">  } else if (idx == HLF_MSG) {</a>
<a name="ln275">    msg_grid.blending = attrs.hl_blend &gt; -1;</a>
<a name="ln276">  }</a>
<a name="ln277"> </a>
<a name="ln278">  if (optional &amp;&amp; !available) {</a>
<a name="ln279">    return 0;</a>
<a name="ln280">  }</a>
<a name="ln281">  return get_attr_entry((HlEntry){ .attr = attrs, .kind = kHlUI,</a>
<a name="ln282">                                   .id1 = idx, .id2 = final_id });</a>
<a name="ln283">}</a>
<a name="ln284"> </a>
<a name="ln285">void update_window_hl(win_T *wp, bool invalid)</a>
<a name="ln286">{</a>
<a name="ln287">  if (!wp-&gt;w_hl_needs_update &amp;&amp; !invalid) {</a>
<a name="ln288">    return;</a>
<a name="ln289">  }</a>
<a name="ln290">  wp-&gt;w_hl_needs_update = false;</a>
<a name="ln291"> </a>
<a name="ln292">  // If a floating window is blending it always have a named</a>
<a name="ln293">  // wp-&gt;w_hl_attr_normal group. HL_ATTR(HLF_NFLOAT) is always named.</a>
<a name="ln294">  bool has_blend = wp-&gt;w_floating &amp;&amp; wp-&gt;w_p_winbl != 0;</a>
<a name="ln295"> </a>
<a name="ln296">  // determine window specific background set in 'winhighlight'</a>
<a name="ln297">  bool float_win = wp-&gt;w_floating &amp;&amp; !wp-&gt;w_float_config.external;</a>
<a name="ln298">  if (wp != curwin &amp;&amp; wp-&gt;w_hl_ids[HLF_INACTIVE] != 0) {</a>
<a name="ln299">    wp-&gt;w_hl_attr_normal = hl_get_ui_attr(HLF_INACTIVE,</a>
<a name="ln300">                                          wp-&gt;w_hl_ids[HLF_INACTIVE],</a>
<a name="ln301">                                          !has_blend);</a>
<a name="ln302">  } else if (float_win &amp;&amp; wp-&gt;w_hl_ids[HLF_NFLOAT] != 0) {</a>
<a name="ln303">    wp-&gt;w_hl_attr_normal = hl_get_ui_attr(HLF_NFLOAT,</a>
<a name="ln304">                                          wp-&gt;w_hl_ids[HLF_NFLOAT], !has_blend);</a>
<a name="ln305">  } else if (wp-&gt;w_hl_id_normal != 0) {</a>
<a name="ln306">    wp-&gt;w_hl_attr_normal = hl_get_ui_attr(-1, wp-&gt;w_hl_id_normal, !has_blend);</a>
<a name="ln307">  } else {</a>
<a name="ln308">    wp-&gt;w_hl_attr_normal = float_win ? HL_ATTR(HLF_NFLOAT) : 0;</a>
<a name="ln309">  }</a>
<a name="ln310"> </a>
<a name="ln311">  // NOOOO! You cannot just pretend that &quot;Normal&quot; is just like any other</a>
<a name="ln312">  // syntax group! It needs at least 10 layers of special casing! Noooooo!</a>
<a name="ln313">  //</a>
<a name="ln314">  // haha, theme engine go brrr</a>
<a name="ln315">  int normality = syn_check_group((const char_u *)S_LEN(&quot;Normal&quot;));</a>
<a name="ln316">  int ns_attr = ns_get_hl(-1, normality, false, false);</a>
<a name="ln317">  if (ns_attr &gt; 0) {</a>
<a name="ln318">    // TODO(bfredl): hantera NormalNC and so on</a>
<a name="ln319">    wp-&gt;w_hl_attr_normal = ns_attr;</a>
<a name="ln320">  }</a>
<a name="ln321"> </a>
<a name="ln322">  // if blend= attribute is not set, 'winblend' value overrides it.</a>
<a name="ln323">  if (wp-&gt;w_floating &amp;&amp; wp-&gt;w_p_winbl &gt; 0) {</a>
<a name="ln324">    HlEntry entry = kv_A(attr_entries, wp-&gt;w_hl_attr_normal);</a>
<a name="ln325">    if (entry.attr.hl_blend == -1) {</a>
<a name="ln326">      entry.attr.hl_blend = (int)wp-&gt;w_p_winbl;</a>
<a name="ln327">      wp-&gt;w_hl_attr_normal = get_attr_entry(entry);</a>
<a name="ln328">    }</a>
<a name="ln329">  }</a>
<a name="ln330"> </a>
<a name="ln331">  if (wp != curwin &amp;&amp; wp-&gt;w_hl_ids[HLF_INACTIVE] == 0) {</a>
<a name="ln332">    wp-&gt;w_hl_attr_normal = hl_combine_attr(HL_ATTR(HLF_INACTIVE),</a>
<a name="ln333">                                           wp-&gt;w_hl_attr_normal);</a>
<a name="ln334">  }</a>
<a name="ln335"> </a>
<a name="ln336">  for (int hlf = 0; hlf &lt; (int)HLF_COUNT; hlf++) {</a>
<a name="ln337">    int attr;</a>
<a name="ln338">    if (wp-&gt;w_hl_ids[hlf] != 0) {</a>
<a name="ln339">      attr = hl_get_ui_attr(hlf, wp-&gt;w_hl_ids[hlf], false);</a>
<a name="ln340">    } else {</a>
<a name="ln341">      attr = HL_ATTR(hlf);</a>
<a name="ln342">    }</a>
<a name="ln343">    wp-&gt;w_hl_attrs[hlf] = attr;</a>
<a name="ln344">  }</a>
<a name="ln345"> </a>
<a name="ln346">  wp-&gt;w_float_config.shadow = false;</a>
<a name="ln347">  if (wp-&gt;w_floating &amp;&amp; wp-&gt;w_float_config.border) {</a>
<a name="ln348">    for (int i = 0; i &lt; 8; i++) {</a>
<a name="ln349">      int attr = wp-&gt;w_hl_attrs[HLF_BORDER];</a>
<a name="ln350">      if (wp-&gt;w_float_config.border_hl_ids[i]) {</a>
<a name="ln351">        attr = hl_get_ui_attr(HLF_BORDER, wp-&gt;w_float_config.border_hl_ids[i],</a>
<a name="ln352">                              false);</a>
<a name="ln353">        HlAttrs a = syn_attr2entry(attr);</a>
<a name="ln354">        if (a.hl_blend) {</a>
<a name="ln355">          wp-&gt;w_float_config.shadow = true;</a>
<a name="ln356">        }</a>
<a name="ln357">      }</a>
<a name="ln358">      wp-&gt;w_float_config.border_attr[i] = attr;</a>
<a name="ln359">    }</a>
<a name="ln360">  }</a>
<a name="ln361"> </a>
<a name="ln362">  // shadow might cause blending</a>
<a name="ln363">  check_blending(wp);</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366">/// Gets HL_UNDERLINE highlight.</a>
<a name="ln367">int hl_get_underline(void)</a>
<a name="ln368">{</a>
<a name="ln369">  return get_attr_entry((HlEntry){</a>
<a name="ln370">      .attr = (HlAttrs){</a>
<a name="ln371">          .cterm_ae_attr = (int16_t)HL_UNDERLINE,</a>
<a name="ln372">          .cterm_fg_color = 0,</a>
<a name="ln373">          .cterm_bg_color = 0,</a>
<a name="ln374">          .rgb_ae_attr = (int16_t)HL_UNDERLINE,</a>
<a name="ln375">          .rgb_fg_color = -1,</a>
<a name="ln376">          .rgb_bg_color = -1,</a>
<a name="ln377">          .rgb_sp_color = -1,</a>
<a name="ln378">          .hl_blend = -1,</a>
<a name="ln379">      },</a>
<a name="ln380">      .kind = kHlUI,</a>
<a name="ln381">      .id1 = 0,</a>
<a name="ln382">      .id2 = 0,</a>
<a name="ln383">  });</a>
<a name="ln384">}</a>
<a name="ln385"> </a>
<a name="ln386">/// Get attribute code for forwarded :terminal highlights.</a>
<a name="ln387">int hl_get_term_attr(HlAttrs *aep)</a>
<a name="ln388">{</a>
<a name="ln389">  return get_attr_entry((HlEntry){ .attr= *aep, .kind = kHlTerminal,</a>
<a name="ln390">                                   .id1 = 0, .id2 = 0 });</a>
<a name="ln391">}</a>
<a name="ln392"> </a>
<a name="ln393">/// Clear all highlight tables.</a>
<a name="ln394">void clear_hl_tables(bool reinit)</a>
<a name="ln395">{</a>
<a name="ln396">  if (reinit) {</a>
<a name="ln397">    kv_size(attr_entries) = 1;</a>
<a name="ln398">    map_clear(HlEntry, int)(attr_entry_ids);</a>
<a name="ln399">    map_clear(int, int)(combine_attr_entries);</a>
<a name="ln400">    map_clear(int, int)(blend_attr_entries);</a>
<a name="ln401">    map_clear(int, int)(blendthrough_attr_entries);</a>
<a name="ln402">    memset(highlight_attr_last, -1, sizeof(highlight_attr_last));</a>
<a name="ln403">    highlight_attr_set_all();</a>
<a name="ln404">    highlight_changed();</a>
<a name="ln405">    screen_invalidate_highlights();</a>
<a name="ln406">  } else {</a>
<a name="ln407">    kv_destroy(attr_entries);</a>
<a name="ln408">    map_free(HlEntry, int)(attr_entry_ids);</a>
<a name="ln409">    map_free(int, int)(combine_attr_entries);</a>
<a name="ln410">    map_free(int, int)(blend_attr_entries);</a>
<a name="ln411">    map_free(int, int)(blendthrough_attr_entries);</a>
<a name="ln412">    map_free(ColorKey, ColorItem)(ns_hl);</a>
<a name="ln413">  }</a>
<a name="ln414">}</a>
<a name="ln415"> </a>
<a name="ln416">void hl_invalidate_blends(void)</a>
<a name="ln417">{</a>
<a name="ln418">  map_clear(int, int)(blend_attr_entries);</a>
<a name="ln419">  map_clear(int, int)(blendthrough_attr_entries);</a>
<a name="ln420">  highlight_changed();</a>
<a name="ln421">  update_window_hl(curwin, true);</a>
<a name="ln422">}</a>
<a name="ln423"> </a>
<a name="ln424">// Combine special attributes (e.g., for spelling) with other attributes</a>
<a name="ln425">// (e.g., for syntax highlighting).</a>
<a name="ln426">// &quot;prim_attr&quot; overrules &quot;char_attr&quot;.</a>
<a name="ln427">// This creates a new group when required.</a>
<a name="ln428">// Since we expect there to be a lot of spelling mistakes we cache the result.</a>
<a name="ln429">// Return the resulting attributes.</a>
<a name="ln430">int hl_combine_attr(int char_attr, int prim_attr)</a>
<a name="ln431">{</a>
<a name="ln432">  if (char_attr == 0) {</a>
<a name="ln433">    return prim_attr;</a>
<a name="ln434">  } else if (prim_attr == 0) {</a>
<a name="ln435">    return char_attr;</a>
<a name="ln436">  }</a>
<a name="ln437"> </a>
<a name="ln438">  // TODO(bfredl): could use a struct for clearer intent.</a>
<a name="ln439">  int combine_tag = (char_attr &lt;&lt; 16) + prim_attr;</a>
<a name="ln440">  int id = map_get(int, int)(combine_attr_entries, combine_tag);</a>
<a name="ln441">  if (id &gt; 0) {</a>
<a name="ln442">    return id;</a>
<a name="ln443">  }</a>
<a name="ln444"> </a>
<a name="ln445">  HlAttrs char_aep = syn_attr2entry(char_attr);</a>
<a name="ln446">  HlAttrs spell_aep = syn_attr2entry(prim_attr);</a>
<a name="ln447"> </a>
<a name="ln448">  // start with low-priority attribute, and override colors if present below.</a>
<a name="ln449">  HlAttrs new_en = char_aep;</a>
<a name="ln450"> </a>
<a name="ln451">  if (spell_aep.cterm_ae_attr &amp; HL_NOCOMBINE) {</a>
<a name="ln452">    new_en.cterm_ae_attr = spell_aep.cterm_ae_attr;</a>
<a name="ln453">  } else {</a>
<a name="ln454">    new_en.cterm_ae_attr |= spell_aep.cterm_ae_attr;</a>
<a name="ln455">  }</a>
<a name="ln456">  if (spell_aep.rgb_ae_attr &amp; HL_NOCOMBINE) {</a>
<a name="ln457">    new_en.rgb_ae_attr = spell_aep.rgb_ae_attr;</a>
<a name="ln458">  } else {</a>
<a name="ln459">    new_en.rgb_ae_attr |= spell_aep.rgb_ae_attr;</a>
<a name="ln460">  }</a>
<a name="ln461"> </a>
<a name="ln462">  if (spell_aep.cterm_fg_color &gt; 0) {</a>
<a name="ln463">    new_en.cterm_fg_color = spell_aep.cterm_fg_color;</a>
<a name="ln464">    new_en.rgb_ae_attr &amp;= ((~HL_FG_INDEXED)</a>
<a name="ln465">                           | (spell_aep.rgb_ae_attr &amp; HL_FG_INDEXED));</a>
<a name="ln466">  }</a>
<a name="ln467"> </a>
<a name="ln468">  if (spell_aep.cterm_bg_color &gt; 0) {</a>
<a name="ln469">    new_en.cterm_bg_color = spell_aep.cterm_bg_color;</a>
<a name="ln470">    new_en.rgb_ae_attr &amp;= ((~HL_BG_INDEXED)</a>
<a name="ln471">                           | (spell_aep.rgb_ae_attr &amp; HL_BG_INDEXED));</a>
<a name="ln472">  }</a>
<a name="ln473"> </a>
<a name="ln474">  if (spell_aep.rgb_fg_color &gt;= 0) {</a>
<a name="ln475">    new_en.rgb_fg_color = spell_aep.rgb_fg_color;</a>
<a name="ln476">    new_en.rgb_ae_attr &amp;= ((~HL_FG_INDEXED)</a>
<a name="ln477">                           | (spell_aep.rgb_ae_attr &amp; HL_FG_INDEXED));</a>
<a name="ln478">  }</a>
<a name="ln479"> </a>
<a name="ln480">  if (spell_aep.rgb_bg_color &gt;= 0) {</a>
<a name="ln481">    new_en.rgb_bg_color = spell_aep.rgb_bg_color;</a>
<a name="ln482">    new_en.rgb_ae_attr &amp;= ((~HL_BG_INDEXED)</a>
<a name="ln483">                           | (spell_aep.rgb_ae_attr &amp; HL_BG_INDEXED));</a>
<a name="ln484">  }</a>
<a name="ln485"> </a>
<a name="ln486">  if (spell_aep.rgb_sp_color &gt;= 0) {</a>
<a name="ln487">    new_en.rgb_sp_color = spell_aep.rgb_sp_color;</a>
<a name="ln488">  }</a>
<a name="ln489"> </a>
<a name="ln490">  if (spell_aep.hl_blend &gt;= 0) {</a>
<a name="ln491">    new_en.hl_blend = spell_aep.hl_blend;</a>
<a name="ln492">  }</a>
<a name="ln493"> </a>
<a name="ln494">  id = get_attr_entry((HlEntry){ .attr = new_en, .kind = kHlCombine,</a>
<a name="ln495">                                 .id1 = char_attr, .id2 = prim_attr });</a>
<a name="ln496">  if (id &gt; 0) {</a>
<a name="ln497">    map_put(int, int)(combine_attr_entries, combine_tag, id);</a>
<a name="ln498">  }</a>
<a name="ln499"> </a>
<a name="ln500">  return id;</a>
<a name="ln501">}</a>
<a name="ln502"> </a>
<a name="ln503">/// Get the used rgb colors for an attr group.</a>
<a name="ln504">///</a>
<a name="ln505">/// If colors are unset, use builtin default colors. Never returns -1</a>
<a name="ln506">/// Cterm colors are unchanged.</a>
<a name="ln507">static HlAttrs get_colors_force(int attr)</a>
<a name="ln508">{</a>
<a name="ln509">  HlAttrs attrs = syn_attr2entry(attr);</a>
<a name="ln510">  if (attrs.rgb_bg_color == -1) {</a>
<a name="ln511">    attrs.rgb_bg_color = normal_bg;</a>
<a name="ln512">  }</a>
<a name="ln513">  if (attrs.rgb_fg_color == -1) {</a>
<a name="ln514">    attrs.rgb_fg_color = normal_fg;</a>
<a name="ln515">  }</a>
<a name="ln516">  if (attrs.rgb_sp_color == -1) {</a>
<a name="ln517">    attrs.rgb_sp_color = normal_sp;</a>
<a name="ln518">  }</a>
<a name="ln519">  HL_SET_DEFAULT_COLORS(attrs.rgb_fg_color, attrs.rgb_bg_color,</a>
<a name="ln520">                        attrs.rgb_sp_color);</a>
<a name="ln521"> </a>
<a name="ln522">  if (attrs.rgb_ae_attr &amp; HL_INVERSE) {</a>
<a name="ln523">    int temp = attrs.rgb_bg_color;</a>
<a name="ln524">    attrs.rgb_bg_color = attrs.rgb_fg_color;</a>
<a name="ln525">    attrs.rgb_fg_color = temp;</a>
<a name="ln526">    attrs.rgb_ae_attr &amp;= ~HL_INVERSE;</a>
<a name="ln527">  }</a>
<a name="ln528"> </a>
<a name="ln529">  return attrs;</a>
<a name="ln530">}</a>
<a name="ln531"> </a>
<a name="ln532">/// Blend overlay attributes (for popupmenu) with other attributes</a>
<a name="ln533">///</a>
<a name="ln534">/// This creates a new group when required.</a>
<a name="ln535">/// This is called per-cell, so cache the result.</a>
<a name="ln536">///</a>
<a name="ln537">/// @return the resulting attributes.</a>
<a name="ln538">int hl_blend_attrs(int back_attr, int front_attr, bool *through)</a>
<a name="ln539">{</a>
<a name="ln540">  if (front_attr &lt; 0 || back_attr &lt; 0) {</a>
<a name="ln541">    return -1;</a>
<a name="ln542">  }</a>
<a name="ln543"> </a>
<a name="ln544">  HlAttrs fattrs = get_colors_force(front_attr);</a>
<a name="ln545">  int ratio = fattrs.hl_blend;</a>
<a name="ln546">  if (ratio &lt;= 0) {</a>
<a name="ln547">    *through = false;</a>
<a name="ln548">    return front_attr;</a>
<a name="ln549">  }</a>
<a name="ln550"> </a>
<a name="ln551">  int combine_tag = (back_attr &lt;&lt; 16) + front_attr;</a>
<a name="ln552">  Map(int, int) *map = (*through</a>
<a name="ln553">                        ? blendthrough_attr_entries</a>
<a name="ln554">                        : blend_attr_entries);</a>
<a name="ln555">  int id = map_get(int, int)(map, combine_tag);</a>
<a name="ln556">  if (id &gt; 0) {</a>
<a name="ln557">    return id;</a>
<a name="ln558">  }</a>
<a name="ln559"> </a>
<a name="ln560">  HlAttrs battrs = get_colors_force(back_attr);</a>
<a name="ln561">  HlAttrs cattrs;</a>
<a name="ln562"> </a>
<a name="ln563">  if (*through) {</a>
<a name="ln564">    cattrs = battrs;</a>
<a name="ln565">    cattrs.rgb_fg_color = rgb_blend(ratio, battrs.rgb_fg_color,</a>
<a name="ln566">                                    fattrs.rgb_bg_color);</a>
<a name="ln567">    if (cattrs.rgb_ae_attr &amp; (HL_UNDERLINE|HL_UNDERCURL)) {</a>
<a name="ln568">      cattrs.rgb_sp_color = rgb_blend(ratio, battrs.rgb_sp_color,</a>
<a name="ln569">                                      fattrs.rgb_bg_color);</a>
<a name="ln570">    } else {</a>
<a name="ln571">      cattrs.rgb_sp_color = -1;</a>
<a name="ln572">    }</a>
<a name="ln573"> </a>
<a name="ln574">    cattrs.cterm_bg_color = fattrs.cterm_bg_color;</a>
<a name="ln575">    cattrs.cterm_fg_color = cterm_blend(ratio, battrs.cterm_fg_color,</a>
<a name="ln576">                                        fattrs.cterm_bg_color);</a>
<a name="ln577">    cattrs.rgb_ae_attr &amp;= ~(HL_FG_INDEXED | HL_BG_INDEXED);</a>
<a name="ln578">  } else {</a>
<a name="ln579">    cattrs = fattrs;</a>
<a name="ln580">    if (ratio &gt;= 50) {</a>
<a name="ln581">      cattrs.rgb_ae_attr |= battrs.rgb_ae_attr;</a>
<a name="ln582">    }</a>
<a name="ln583">    cattrs.rgb_fg_color = rgb_blend(ratio/2, battrs.rgb_fg_color,</a>
<a name="ln584">                                    fattrs.rgb_fg_color);</a>
<a name="ln585">    if (cattrs.rgb_ae_attr &amp; (HL_UNDERLINE|HL_UNDERCURL)) {</a>
<a name="ln586">      cattrs.rgb_sp_color = rgb_blend(ratio/2, battrs.rgb_bg_color,</a>
<a name="ln587">                                      fattrs.rgb_sp_color);</a>
<a name="ln588">    } else {</a>
<a name="ln589">      cattrs.rgb_sp_color = -1;</a>
<a name="ln590">    }</a>
<a name="ln591"> </a>
<a name="ln592">    cattrs.rgb_ae_attr &amp;= ~HL_BG_INDEXED;</a>
<a name="ln593">  }</a>
<a name="ln594">  cattrs.rgb_bg_color = rgb_blend(ratio, battrs.rgb_bg_color,</a>
<a name="ln595">                                  fattrs.rgb_bg_color);</a>
<a name="ln596"> </a>
<a name="ln597">  cattrs.hl_blend = -1;  // blend property was consumed</a>
<a name="ln598"> </a>
<a name="ln599">  HlKind kind = *through ? kHlBlendThrough : kHlBlend;</a>
<a name="ln600">  id = get_attr_entry((HlEntry){ .attr = cattrs, .kind = kind,</a>
<a name="ln601">                                 .id1 = back_attr, .id2 = front_attr });</a>
<a name="ln602">  if (id &gt; 0) {</a>
<a name="ln603">    map_put(int, int)(map, combine_tag, id);</a>
<a name="ln604">  }</a>
<a name="ln605">  return id;</a>
<a name="ln606">}</a>
<a name="ln607"> </a>
<a name="ln608">static int rgb_blend(int ratio, int rgb1, int rgb2)</a>
<a name="ln609">{</a>
<a name="ln610">  int a = ratio, b = 100-ratio;</a>
<a name="ln611">  int r1 = (rgb1 &amp; 0xFF0000) &gt;&gt; 16;</a>
<a name="ln612">  int g1 = (rgb1 &amp; 0x00FF00) &gt;&gt; 8;</a>
<a name="ln613">  int b1 = (rgb1 &amp; 0x0000FF) &gt;&gt; 0;</a>
<a name="ln614">  int r2 = (rgb2 &amp; 0xFF0000) &gt;&gt; 16;</a>
<a name="ln615">  int g2 = (rgb2 &amp; 0x00FF00) &gt;&gt; 8;</a>
<a name="ln616">  int b2 = (rgb2 &amp; 0x0000FF) &gt;&gt; 0;</a>
<a name="ln617">  int mr = (a * r1 + b * r2)/100;</a>
<a name="ln618">  int mg = (a * g1 + b * g2)/100;</a>
<a name="ln619">  int mb = (a * b1 + b * b2)/100;</a>
<a name="ln620">  return (mr &lt;&lt; 16) + (mg &lt;&lt; 8) + mb;</a>
<a name="ln621">}</a>
<a name="ln622"> </a>
<a name="ln623">static int cterm_blend(int ratio, int c1, int c2)</a>
<a name="ln624">{</a>
<a name="ln625">  // 1. Convert cterm color numbers to RGB.</a>
<a name="ln626">  // 2. Blend the RGB colors.</a>
<a name="ln627">  // 3. Convert the RGB result to a cterm color.</a>
<a name="ln628">  int rgb1 = hl_cterm2rgb_color(c1);</a>
<a name="ln629">  int rgb2 = hl_cterm2rgb_color(c2);</a>
<a name="ln630">  int rgb_blended = rgb_blend(ratio, rgb1, rgb2);</a>
<a name="ln631">  return hl_rgb2cterm_color(rgb_blended);</a>
<a name="ln632">}</a>
<a name="ln633"> </a>
<a name="ln634">/// Converts RGB color to 8-bit color (0-255).</a>
<a name="ln635">static int hl_rgb2cterm_color(int rgb)</a>
<a name="ln636">{</a>
<a name="ln637">  int r = (rgb &amp; 0xFF0000) &gt;&gt; 16;</a>
<a name="ln638">  int g = (rgb &amp; 0x00FF00) &gt;&gt; 8;</a>
<a name="ln639">  int b = (rgb &amp; 0x0000FF) &gt;&gt; 0;</a>
<a name="ln640"> </a>
<a name="ln641">  return (r * 6 / 256) * 36 + (g * 6 / 256) * 6 + (b * 6 / 256);</a>
<a name="ln642">}</a>
<a name="ln643"> </a>
<a name="ln644">/// Converts 8-bit color (0-255) to RGB color.</a>
<a name="ln645">/// This is compatible with xterm.</a>
<a name="ln646">static int hl_cterm2rgb_color(int nr)</a>
<a name="ln647">{</a>
<a name="ln648">  static int cube_value[] = {</a>
<a name="ln649">    0x00, 0x5F, 0x87, 0xAF, 0xD7, 0xFF</a>
<a name="ln650">  };</a>
<a name="ln651">  static int grey_ramp[] = {</a>
<a name="ln652">    0x08, 0x12, 0x1C, 0x26, 0x30, 0x3A, 0x44, 0x4E, 0x58, 0x62, 0x6C, 0x76,</a>
<a name="ln653">    0x80, 0x8A, 0x94, 0x9E, 0xA8, 0xB2, 0xBC, 0xC6, 0xD0, 0xDA, 0xE4, 0xEE</a>
<a name="ln654">  };</a>
<a name="ln655">  static char_u ansi_table[16][4] = {</a>
<a name="ln656">    //  R    G    B   idx</a>
<a name="ln657">    {   0,   0,   0,  1 } ,  // black</a>
<a name="ln658">    { 224,   0,   0,  2 } ,  // dark red</a>
<a name="ln659">    {   0, 224,   0,  3 } ,  // dark green</a>
<a name="ln660">    { 224, 224,   0,  4 } ,  // dark yellow / brown</a>
<a name="ln661">    {   0,   0, 224,  5 } ,  // dark blue</a>
<a name="ln662">    { 224,   0, 224,  6 } ,  // dark magenta</a>
<a name="ln663">    {   0, 224, 224,  7 } ,  // dark cyan</a>
<a name="ln664">    { 224, 224, 224,  8 } ,  // light grey</a>
<a name="ln665"> </a>
<a name="ln666">    { 128, 128, 128,  9 } ,  // dark grey</a>
<a name="ln667">    { 255,  64,  64, 10 } ,  // light red</a>
<a name="ln668">    {  64, 255,  64, 11 } ,  // light green</a>
<a name="ln669">    { 255, 255,  64, 12 } ,  // yellow</a>
<a name="ln670">    {  64,  64, 255, 13 } ,  // light blue</a>
<a name="ln671">    { 255,  64, 255, 14 } ,  // light magenta</a>
<a name="ln672">    {  64, 255, 255, 15 } ,  // light cyan</a>
<a name="ln673">    { 255, 255, 255, 16 } ,  // white</a>
<a name="ln674">  };</a>
<a name="ln675"> </a>
<a name="ln676">  int r = 0;</a>
<a name="ln677">  int g = 0;</a>
<a name="ln678">  int b = 0;</a>
<a name="ln679">  int idx;</a>
<a name="ln680">  // *ansi_idx = 0;</a>
<a name="ln681"> </a>
<a name="ln682">  if (nr &lt; 16) {</a>
<a name="ln683">    r = ansi_table[nr][0];</a>
<a name="ln684">    g = ansi_table[nr][1];</a>
<a name="ln685">    b = ansi_table[nr][2];</a>
<a name="ln686">    // *ansi_idx = ansi_table[nr][3];</a>
<a name="ln687">  } else if (nr &lt; 232) {  // 216 color-cube</a>
<a name="ln688">    idx = nr - 16;</a>
<a name="ln689">    r = cube_value[idx / 36 % 6];</a>
<a name="ln690">    g = cube_value[idx / 6  % 6];</a>
<a name="ln691">    b = cube_value[idx      % 6];</a>
<a name="ln692">    // *ansi_idx = -1;</a>
<a name="ln693">  } else if (nr &lt; 256) {  // 24 greyscale ramp</a>
<a name="ln694">    idx = nr - 232;</a>
<a name="ln695">    r = grey_ramp[idx];</a>
<a name="ln696">    g = grey_ramp[idx];</a>
<a name="ln697">    b = grey_ramp[idx];</a>
<a name="ln698">    // *ansi_idx = -1;</a>
<a name="ln699">  }</a>
<a name="ln700">  return (r &lt;&lt; 16) + (g &lt;&lt; 8) + b;</a>
<a name="ln701">}</a>
<a name="ln702"> </a>
<a name="ln703">/// Get highlight attributes for a attribute code</a>
<a name="ln704">HlAttrs syn_attr2entry(int attr)</a>
<a name="ln705">{</a>
<a name="ln706">  if (attr &lt;= 0 || attr &gt;= (int)kv_size(attr_entries)) {</a>
<a name="ln707">    // invalid attribute code, or the tables were cleared</a>
<a name="ln708">    return HLATTRS_INIT;</a>
<a name="ln709">  }</a>
<a name="ln710">  return kv_A(attr_entries, attr).attr;</a>
<a name="ln711">}</a>
<a name="ln712"> </a>
<a name="ln713">/// Gets highlight description for id `attr_id` as a map.</a>
<a name="ln714">Dictionary hl_get_attr_by_id(Integer attr_id, Boolean rgb, Error *err)</a>
<a name="ln715">{</a>
<a name="ln716">  Dictionary dic = ARRAY_DICT_INIT;</a>
<a name="ln717"> </a>
<a name="ln718">  if (attr_id == 0) {</a>
<a name="ln719">    return dic;</a>
<a name="ln720">  }</a>
<a name="ln721"> </a>
<a name="ln722">  if (attr_id &lt;= 0 || attr_id &gt;= (int)kv_size(attr_entries)) {</a>
<a name="ln723">    api_set_error(err, kErrorTypeException,</a>
<a name="ln724">                  &quot;Invalid attribute id: %&quot; PRId64, attr_id);</a>
<a name="ln725">    return dic;</a>
<a name="ln726">  }</a>
<a name="ln727"> </a>
<a name="ln728">  return hlattrs2dict(syn_attr2entry((int)attr_id), rgb);</a>
<a name="ln729">}</a>
<a name="ln730"> </a>
<a name="ln731">/// Converts an HlAttrs into Dictionary</a>
<a name="ln732">///</a>
<a name="ln733">/// @param[in] aep data to convert</a>
<a name="ln734">/// @param use_rgb use 'gui*' settings if true, else resorts to 'cterm*'</a>
<a name="ln735">Dictionary hlattrs2dict(HlAttrs ae, bool use_rgb)</a>
<a name="ln736">{</a>
<a name="ln737">  Dictionary hl = ARRAY_DICT_INIT;</a>
<a name="ln738">  int mask  = use_rgb ? ae.rgb_ae_attr : ae.cterm_ae_attr;</a>
<a name="ln739"> </a>
<a name="ln740">  if (mask &amp; HL_BOLD) {</a>
<a name="ln741">    PUT(hl, &quot;bold&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln742">  }</a>
<a name="ln743"> </a>
<a name="ln744">  if (mask &amp; HL_STANDOUT) {</a>
<a name="ln745">    PUT(hl, &quot;standout&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln746">  }</a>
<a name="ln747"> </a>
<a name="ln748">  if (mask &amp; HL_UNDERLINE) {</a>
<a name="ln749">    PUT(hl, &quot;underline&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln750">  }</a>
<a name="ln751"> </a>
<a name="ln752">  if (mask &amp; HL_UNDERCURL) {</a>
<a name="ln753">    PUT(hl, &quot;undercurl&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln754">  }</a>
<a name="ln755"> </a>
<a name="ln756">  if (mask &amp; HL_ITALIC) {</a>
<a name="ln757">    PUT(hl, &quot;italic&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln758">  }</a>
<a name="ln759"> </a>
<a name="ln760">  if (mask &amp; HL_INVERSE) {</a>
<a name="ln761">    PUT(hl, &quot;reverse&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln762">  }</a>
<a name="ln763"> </a>
<a name="ln764">  if (mask &amp; HL_STRIKETHROUGH) {</a>
<a name="ln765">    PUT(hl, &quot;strikethrough&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln766">  }</a>
<a name="ln767"> </a>
<a name="ln768">  if (use_rgb) {</a>
<a name="ln769">    if (mask &amp; HL_FG_INDEXED) {</a>
<a name="ln770">      PUT(hl, &quot;fg_indexed&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln771">    }</a>
<a name="ln772"> </a>
<a name="ln773">    if (mask &amp; HL_BG_INDEXED) {</a>
<a name="ln774">      PUT(hl, &quot;bg_indexed&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln775">    }</a>
<a name="ln776"> </a>
<a name="ln777">    if (ae.rgb_fg_color != -1) {</a>
<a name="ln778">      PUT(hl, &quot;foreground&quot;, INTEGER_OBJ(ae.rgb_fg_color));</a>
<a name="ln779">    }</a>
<a name="ln780"> </a>
<a name="ln781">    if (ae.rgb_bg_color != -1) {</a>
<a name="ln782">      PUT(hl, &quot;background&quot;, INTEGER_OBJ(ae.rgb_bg_color));</a>
<a name="ln783">    }</a>
<a name="ln784"> </a>
<a name="ln785">    if (ae.rgb_sp_color != -1) {</a>
<a name="ln786">      PUT(hl, &quot;special&quot;, INTEGER_OBJ(ae.rgb_sp_color));</a>
<a name="ln787">    }</a>
<a name="ln788">  } else {</a>
<a name="ln789">    if (cterm_normal_fg_color != ae.cterm_fg_color &amp;&amp; ae.cterm_fg_color != 0) {</a>
<a name="ln790">      PUT(hl, &quot;foreground&quot;, INTEGER_OBJ(ae.cterm_fg_color - 1));</a>
<a name="ln791">    }</a>
<a name="ln792"> </a>
<a name="ln793">    if (cterm_normal_bg_color != ae.cterm_bg_color &amp;&amp; ae.cterm_bg_color != 0) {</a>
<a name="ln794">      PUT(hl, &quot;background&quot;, INTEGER_OBJ(ae.cterm_bg_color - 1));</a>
<a name="ln795">    }</a>
<a name="ln796">  }</a>
<a name="ln797"> </a>
<a name="ln798">  if (ae.hl_blend &gt; -1) {</a>
<a name="ln799">      PUT(hl, &quot;blend&quot;, INTEGER_OBJ(ae.hl_blend));</a>
<a name="ln800">  }</a>
<a name="ln801"> </a>
<a name="ln802">  return hl;</a>
<a name="ln803">}</a>
<a name="ln804"> </a>
<a name="ln805">HlAttrs dict2hlattrs(Dictionary dict, bool use_rgb, int *link_id, Error *err)</a>
<a name="ln806">{</a>
<a name="ln807">  HlAttrs hlattrs = HLATTRS_INIT;</a>
<a name="ln808"> </a>
<a name="ln809">  int32_t fg = -1, bg = -1, sp = -1;</a>
<a name="ln810">  int16_t mask = 0;</a>
<a name="ln811">  for (size_t i = 0; i &lt; dict.size; i++) {</a>
<a name="ln812">    char *key = dict.items[i].key.data;</a>
<a name="ln813">    Object val = dict.items[i].value;</a>
<a name="ln814"> </a>
<a name="ln815">    struct {</a>
<a name="ln816">      const char *name;</a>
<a name="ln817">      int16_t flag;</a>
<a name="ln818">    } flags[] = {</a>
<a name="ln819">      { &quot;bold&quot;, HL_BOLD },</a>
<a name="ln820">      { &quot;standout&quot;, HL_STANDOUT },</a>
<a name="ln821">      { &quot;underline&quot;, HL_UNDERLINE },</a>
<a name="ln822">      { &quot;undercurl&quot;, HL_UNDERCURL },</a>
<a name="ln823">      { &quot;italic&quot;, HL_ITALIC },</a>
<a name="ln824">      { &quot;reverse&quot;, HL_INVERSE },</a>
<a name="ln825">      { &quot;default&quot;, HL_DEFAULT },</a>
<a name="ln826">      { &quot;global&quot;, HL_GLOBAL },</a>
<a name="ln827">      { NULL, 0 },</a>
<a name="ln828">    };</a>
<a name="ln829"> </a>
<a name="ln830">    int j;</a>
<a name="ln831">    for (j = 0; flags[j].name; j++) {</a>
<a name="ln832">      if (strequal(flags[j].name, key)) {</a>
<a name="ln833">        if (api_object_to_bool(val, key, false, err)) {</a>
<a name="ln834">          mask = mask | flags[j].flag;</a>
<a name="ln835">        }</a>
<a name="ln836">        break;</a>
<a name="ln837">      }</a>
<a name="ln838">    }</a>
<a name="ln839"> </a>
<a name="ln840">    struct {</a>
<a name="ln841">      const char *name;</a>
<a name="ln842">      const char *shortname;</a>
<a name="ln843">      int *dest;</a>
<a name="ln844">    } colors[] = {</a>
<a name="ln845">      { &quot;foreground&quot;, &quot;fg&quot;, &amp;fg },</a>
<a name="ln846">      { &quot;background&quot;, &quot;bg&quot;, &amp;bg },</a>
<a name="ln847">      { &quot;special&quot;, &quot;sp&quot;, &amp;sp },</a>
<a name="ln848">      { NULL, NULL, NULL },</a>
<a name="ln849">    };</a>
<a name="ln850"> </a>
<a name="ln851">    int k;</a>
<a name="ln852">    for (k = 0; (!flags[j].name) &amp;&amp; colors[k].name; k++) {</a>
<a name="ln853">      if (strequal(colors[k].name, key) || strequal(colors[k].shortname, key)) {</a>
<a name="ln854">        if (val.type == kObjectTypeInteger) {</a>
<a name="ln855">          *colors[k].dest = (int)val.data.integer;</a>
<a name="ln856">        } else if (val.type == kObjectTypeString) {</a>
<a name="ln857">          String str = val.data.string;</a>
<a name="ln858">          // TODO(bfredl): be more fancy with &quot;bg&quot;, &quot;fg&quot; etc</a>
<a name="ln859">          if (str.size) {</a>
<a name="ln860">            *colors[k].dest = name_to_color(str.data);</a>
<a name="ln861">          }</a>
<a name="ln862">        } else {</a>
<a name="ln863">          api_set_error(err, kErrorTypeValidation,</a>
<a name="ln864">                        &quot;'%s' must be string or integer&quot;, key);</a>
<a name="ln865">        }</a>
<a name="ln866">        break;</a>
<a name="ln867">      }</a>
<a name="ln868">    }</a>
<a name="ln869"> </a>
<a name="ln870"> </a>
<a name="ln871">    if (flags[j].name || colors[k].name) {</a>
<a name="ln872">      // handled above</a>
<a name="ln873">    } else if (link_id &amp;&amp; strequal(key, &quot;link&quot;)) {</a>
<a name="ln874">      if (val.type == kObjectTypeString) {</a>
<a name="ln875">        String str = val.data.string;</a>
<a name="ln876">        *link_id = syn_check_group((const char_u *)str.data, (int)str.size);</a>
<a name="ln877">      } else if (val.type == kObjectTypeInteger) {</a>
<a name="ln878">        // TODO(bfredl): validate range?</a>
<a name="ln879">        *link_id = (int)val.data.integer;</a>
<a name="ln880">      } else {</a>
<a name="ln881">        api_set_error(err, kErrorTypeValidation,</a>
<a name="ln882">                      &quot;'link' must be string or integer&quot;);</a>
<a name="ln883">      }</a>
<a name="ln884">    }</a>
<a name="ln885"> </a>
<a name="ln886">    if (ERROR_SET(err)) {</a>
<a name="ln887">      return hlattrs;  // error set, caller should not use retval</a>
<a name="ln888">    }</a>
<a name="ln889">  }</a>
<a name="ln890"> </a>
<a name="ln891">  if (use_rgb) {</a>
<a name="ln892">    hlattrs.rgb_ae_attr = mask;</a>
<a name="ln893">    hlattrs.rgb_bg_color = bg;</a>
<a name="ln894">    hlattrs.rgb_fg_color = fg;</a>
<a name="ln895">    hlattrs.rgb_sp_color = sp;</a>
<a name="ln896">  } else {</a>
<a name="ln897">    hlattrs.cterm_ae_attr = mask;</a>
<a name="ln898">    hlattrs.cterm_bg_color = bg == -1 ? cterm_normal_bg_color : bg + 1;</a>
<a name="ln899">    hlattrs.cterm_fg_color = fg == -1 ? cterm_normal_fg_color : fg + 1;</a>
<a name="ln900">  }</a>
<a name="ln901"> </a>
<a name="ln902">  return hlattrs;</a>
<a name="ln903">}</a>
<a name="ln904">Array hl_inspect(int attr)</a>
<a name="ln905">{</a>
<a name="ln906">  Array ret = ARRAY_DICT_INIT;</a>
<a name="ln907">  if (hlstate_active) {</a>
<a name="ln908">    hl_inspect_impl(&amp;ret, attr);</a>
<a name="ln909">  }</a>
<a name="ln910">  return ret;</a>
<a name="ln911">}</a>
<a name="ln912"> </a>
<a name="ln913">static void hl_inspect_impl(Array *arr, int attr)</a>
<a name="ln914">{</a>
<a name="ln915">  Dictionary item = ARRAY_DICT_INIT;</a>
<a name="ln916">  if (attr &lt;= 0 || attr &gt;= (int)kv_size(attr_entries)) {</a>
<a name="ln917">    return;</a>
<a name="ln918">  }</a>
<a name="ln919"> </a>
<a name="ln920">  HlEntry e = kv_A(attr_entries, attr);</a>
<a name="ln921">  switch (e.kind) {</a>
<a name="ln922">    case kHlSyntax:</a>
<a name="ln923">      PUT(item, &quot;kind&quot;, STRING_OBJ(cstr_to_string(&quot;syntax&quot;)));</a>
<a name="ln924">      PUT(item, &quot;hi_name&quot;,</a>
<a name="ln925">          STRING_OBJ(cstr_to_string((char *)syn_id2name(e.id1))));</a>
<a name="ln926">      break;</a>
<a name="ln927"> </a>
<a name="ln928">    case kHlUI:</a>
<a name="ln929">      PUT(item, &quot;kind&quot;, STRING_OBJ(cstr_to_string(&quot;ui&quot;)));</a>
<a name="ln930">      const char *ui_name = (e.id1 == -1) ? &quot;Normal&quot; : hlf_names[e.id1];</a>
<a name="ln931">      PUT(item, &quot;ui_name&quot;, STRING_OBJ(cstr_to_string(ui_name)));</a>
<a name="ln932">      PUT(item, &quot;hi_name&quot;,</a>
<a name="ln933">          STRING_OBJ(cstr_to_string((char *)syn_id2name(e.id2))));</a>
<a name="ln934">      break;</a>
<a name="ln935"> </a>
<a name="ln936">    case kHlTerminal:</a>
<a name="ln937">      PUT(item, &quot;kind&quot;, STRING_OBJ(cstr_to_string(&quot;term&quot;)));</a>
<a name="ln938">      break;</a>
<a name="ln939"> </a>
<a name="ln940">    case kHlCombine:</a>
<a name="ln941">    case kHlBlend:</a>
<a name="ln942">    case kHlBlendThrough:</a>
<a name="ln943">      // attribute combination is associative, so flatten to an array</a>
<a name="ln944">      hl_inspect_impl(arr, e.id1);</a>
<a name="ln945">      hl_inspect_impl(arr, e.id2);</a>
<a name="ln946">      return;</a>
<a name="ln947"> </a>
<a name="ln948">     case kHlUnknown:</a>
<a name="ln949">      return;</a>
<a name="ln950">  }</a>
<a name="ln951">  PUT(item, &quot;id&quot;, INTEGER_OBJ(attr));</a>
<a name="ln952">  ADD(*arr, DICTIONARY_OBJ(item));</a>
<a name="ln953">}</a>

</code></pre>
<div class="balloon" rel="567"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'cattrs.rgb_fg_color' should be checked here.</p></div>
<div class="balloon" rel="585"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'cattrs.rgb_fg_color' should be checked here.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
