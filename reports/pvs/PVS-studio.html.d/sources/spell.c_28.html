
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>spell.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// spell.c: code for spell checking</a>
<a name="ln5">//</a>
<a name="ln6">// See spellfile.c for the Vim spell file format.</a>
<a name="ln7">//</a>
<a name="ln8">// The spell checking mechanism uses a tree (aka trie).  Each node in the tree</a>
<a name="ln9">// has a list of bytes that can appear (siblings).  For each byte there is a</a>
<a name="ln10">// pointer to the node with the byte that follows in the word (child).</a>
<a name="ln11">//</a>
<a name="ln12">// A NUL byte is used where the word may end.  The bytes are sorted, so that</a>
<a name="ln13">// binary searching can be used and the NUL bytes are at the start.  The</a>
<a name="ln14">// number of possible bytes is stored before the list of bytes.</a>
<a name="ln15">//</a>
<a name="ln16">// The tree uses two arrays: &quot;byts&quot; stores the characters, &quot;idxs&quot; stores</a>
<a name="ln17">// either the next index or flags.  The tree starts at index 0.  For example,</a>
<a name="ln18">// to lookup &quot;vi&quot; this sequence is followed:</a>
<a name="ln19">//      i = 0</a>
<a name="ln20">//      len = byts[i]</a>
<a name="ln21">//      n = where &quot;v&quot; appears in byts[i + 1] to byts[i + len]</a>
<a name="ln22">//      i = idxs[n]</a>
<a name="ln23">//      len = byts[i]</a>
<a name="ln24">//      n = where &quot;i&quot; appears in byts[i + 1] to byts[i + len]</a>
<a name="ln25">//      i = idxs[n]</a>
<a name="ln26">//      len = byts[i]</a>
<a name="ln27">//      find that byts[i + 1] is 0, idxs[i + 1] has flags for &quot;vi&quot;.</a>
<a name="ln28">//</a>
<a name="ln29">// There are two word trees: one with case-folded words and one with words in</a>
<a name="ln30">// original case.  The second one is only used for keep-case words and is</a>
<a name="ln31">// usually small.</a>
<a name="ln32">//</a>
<a name="ln33">// There is one additional tree for when not all prefixes are applied when</a>
<a name="ln34">// generating the .spl file.  This tree stores all the possible prefixes, as</a>
<a name="ln35">// if they were words.  At each word (prefix) end the prefix nr is stored, the</a>
<a name="ln36">// following word must support this prefix nr.  And the condition nr is</a>
<a name="ln37">// stored, used to lookup the condition that the word must match with.</a>
<a name="ln38">//</a>
<a name="ln39">// Thanks to Olaf Seibert for providing an example implementation of this tree</a>
<a name="ln40">// and the compression mechanism.</a>
<a name="ln41">// LZ trie ideas:</a>
<a name="ln42">//      http://www.irb.hr/hr/home/ristov/papers/RistovLZtrieRevision1.pdf</a>
<a name="ln43">// More papers: http://www-igm.univ-mlv.fr/~laporte/publi_en.html</a>
<a name="ln44">//</a>
<a name="ln45">// Matching involves checking the caps type: Onecap ALLCAP KeepCap.</a>
<a name="ln46">//</a>
<a name="ln47">// Why doesn't Vim use aspell/ispell/myspell/etc.?</a>
<a name="ln48">// See &quot;:help develop-spell&quot;.</a>
<a name="ln49"> </a>
<a name="ln50">// Use SPELL_PRINTTREE for debugging: dump the word tree after adding a word.</a>
<a name="ln51">// Only use it for small word lists!</a>
<a name="ln52"> </a>
<a name="ln53">// Use SPELL_COMPRESS_ALLWAYS for debugging: compress the word tree after</a>
<a name="ln54">// adding a word.  Only use it for small word lists!</a>
<a name="ln55"> </a>
<a name="ln56">// Use DEBUG_TRIEWALK to print the changes made in suggest_trie_walk() for a</a>
<a name="ln57">// specific word.</a>
<a name="ln58"> </a>
<a name="ln59">// Use this to adjust the score after finding suggestions, based on the</a>
<a name="ln60">// suggested word sounding like the bad word.  This is much faster than doing</a>
<a name="ln61">// it for every possible suggestion.</a>
<a name="ln62">// Disadvantage: When &quot;the&quot; is typed as &quot;hte&quot; it sounds quite different (&quot;@&quot;</a>
<a name="ln63">// vs &quot;ht&quot;) and goes down in the list.</a>
<a name="ln64">// Used when 'spellsuggest' is set to &quot;best&quot;.</a>
<a name="ln65">#define RESCORE(word_score, sound_score) ((3 * word_score + sound_score) / 4)</a>
<a name="ln66"> </a>
<a name="ln67">// Do the opposite: based on a maximum end score and a known sound score,</a>
<a name="ln68">// compute the maximum word score that can be used.</a>
<a name="ln69">#define MAXSCORE(word_score, sound_score) ((4 * word_score - sound_score) / 3)</a>
<a name="ln70"> </a>
<a name="ln71">#include &lt;assert.h&gt;</a>
<a name="ln72">#include &lt;inttypes.h&gt;</a>
<a name="ln73">#include &lt;limits.h&gt;</a>
<a name="ln74">#include &lt;stdbool.h&gt;</a>
<a name="ln75">#include &lt;string.h&gt;</a>
<a name="ln76">#include &lt;stdlib.h&gt;</a>
<a name="ln77">#include &lt;wctype.h&gt;</a>
<a name="ln78"> </a>
<a name="ln79">/* for offsetof() */</a>
<a name="ln80">#include &lt;stddef.h&gt;</a>
<a name="ln81"> </a>
<a name="ln82">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln83">#include &quot;nvim/spell.h&quot;</a>
<a name="ln84">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln85">#include &quot;nvim/change.h&quot;</a>
<a name="ln86">#include &quot;nvim/charset.h&quot;</a>
<a name="ln87">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln88">#include &quot;nvim/edit.h&quot;</a>
<a name="ln89">#include &quot;nvim/eval.h&quot;</a>
<a name="ln90">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln91">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln92">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln93">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln94">#include &quot;nvim/func_attr.h&quot;</a>
<a name="ln95">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln96">#include &quot;nvim/hashtab.h&quot;</a>
<a name="ln97">#include &quot;nvim/mark.h&quot;</a>
<a name="ln98">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln99">#include &quot;nvim/memline.h&quot;</a>
<a name="ln100">#include &quot;nvim/memory.h&quot;</a>
<a name="ln101">#include &quot;nvim/message.h&quot;</a>
<a name="ln102">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln103">#include &quot;nvim/garray.h&quot;</a>
<a name="ln104">#include &quot;nvim/normal.h&quot;</a>
<a name="ln105">#include &quot;nvim/option.h&quot;</a>
<a name="ln106">#include &quot;nvim/os_unix.h&quot;</a>
<a name="ln107">#include &quot;nvim/path.h&quot;</a>
<a name="ln108">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln109">#include &quot;nvim/screen.h&quot;</a>
<a name="ln110">#include &quot;nvim/search.h&quot;</a>
<a name="ln111">#include &quot;nvim/spellfile.h&quot;</a>
<a name="ln112">#include &quot;nvim/strings.h&quot;</a>
<a name="ln113">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln114">#include &quot;nvim/undo.h&quot;</a>
<a name="ln115">#include &quot;nvim/ui.h&quot;</a>
<a name="ln116">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln117">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln118"> </a>
<a name="ln119">// only used for su_badflags</a>
<a name="ln120">#define WF_MIXCAP   0x20        // mix of upper and lower case: macaRONI</a>
<a name="ln121"> </a>
<a name="ln122">#define WF_CAPMASK (WF_ONECAP | WF_ALLCAP | WF_KEEPCAP | WF_FIXCAP)</a>
<a name="ln123"> </a>
<a name="ln124">// Result values.  Lower number is accepted over higher one.</a>
<a name="ln125">#define SP_BANNED       -1</a>
<a name="ln126">#define SP_RARE         0</a>
<a name="ln127">#define SP_OK           1</a>
<a name="ln128">#define SP_LOCAL        2</a>
<a name="ln129">#define SP_BAD          3</a>
<a name="ln130"> </a>
<a name="ln131">// First language that is loaded, start of the linked list of loaded</a>
<a name="ln132">// languages.</a>
<a name="ln133">slang_T *first_lang = NULL;</a>
<a name="ln134"> </a>
<a name="ln135">// file used for &quot;zG&quot; and &quot;zW&quot;</a>
<a name="ln136">char_u *int_wordlist = NULL;</a>
<a name="ln137"> </a>
<a name="ln138">typedef struct wordcount_S {</a>
<a name="ln139">  uint16_t wc_count;                // nr of times word was seen</a>
<a name="ln140">  char_u wc_word[1];                // word, actually longer</a>
<a name="ln141">} wordcount_T;</a>
<a name="ln142"> </a>
<a name="ln143">#define WC_KEY_OFF   offsetof(wordcount_T, wc_word)</a>
<a name="ln144">#define HI2WC(hi)    ((wordcount_T *)((hi)-&gt;hi_key - WC_KEY_OFF))</a>
<a name="ln145">#define MAXWORDCOUNT 0xffff</a>
<a name="ln146"> </a>
<a name="ln147">// Information used when looking for suggestions.</a>
<a name="ln148">typedef struct suginfo_S {</a>
<a name="ln149">  garray_T su_ga;                   // suggestions, contains &quot;suggest_T&quot;</a>
<a name="ln150">  int su_maxcount;                  // max. number of suggestions displayed</a>
<a name="ln151">  int su_maxscore;                  // maximum score for adding to su_ga</a>
<a name="ln152">  int su_sfmaxscore;                // idem, for when doing soundfold words</a>
<a name="ln153">  garray_T su_sga;                  // like su_ga, sound-folded scoring</a>
<a name="ln154">  char_u      *su_badptr;           // start of bad word in line</a>
<a name="ln155">  int su_badlen;                    // length of detected bad word in line</a>
<a name="ln156">  int su_badflags;                  // caps flags for bad word</a>
<a name="ln157">  char_u su_badword[MAXWLEN];       // bad word truncated at su_badlen</a>
<a name="ln158">  char_u su_fbadword[MAXWLEN];      // su_badword case-folded</a>
<a name="ln159">  char_u su_sal_badword[MAXWLEN];   // su_badword soundfolded</a>
<a name="ln160">  hashtab_T su_banned;              // table with banned words</a>
<a name="ln161">  slang_T     *su_sallang;          // default language for sound folding</a>
<a name="ln162">} suginfo_T;</a>
<a name="ln163"> </a>
<a name="ln164">// One word suggestion.  Used in &quot;si_ga&quot;.</a>
<a name="ln165">typedef struct {</a>
<a name="ln166">  char_u      *st_word;         // suggested word, allocated string</a>
<a name="ln167">  int st_wordlen;               // STRLEN(st_word)</a>
<a name="ln168">  int st_orglen;                // length of replaced text</a>
<a name="ln169">  int st_score;                 // lower is better</a>
<a name="ln170">  int st_altscore;              // used when st_score compares equal</a>
<a name="ln171">  bool st_salscore;             // st_score is for soundalike</a>
<a name="ln172">  bool st_had_bonus;            // bonus already included in score</a>
<a name="ln173">  slang_T     *st_slang;        // language used for sound folding</a>
<a name="ln174">} suggest_T;</a>
<a name="ln175"> </a>
<a name="ln176">#define SUG(ga, i) (((suggest_T *)(ga).ga_data)[i])</a>
<a name="ln177"> </a>
<a name="ln178">// True if a word appears in the list of banned words.</a>
<a name="ln179">#define WAS_BANNED(su, word) (!HASHITEM_EMPTY(hash_find(&amp;su-&gt;su_banned, word)))</a>
<a name="ln180"> </a>
<a name="ln181">// Number of suggestions kept when cleaning up.  We need to keep more than</a>
<a name="ln182">// what is displayed, because when rescore_suggestions() is called the score</a>
<a name="ln183">// may change and wrong suggestions may be removed later.</a>
<a name="ln184">#define SUG_CLEAN_COUNT(su)    ((su)-&gt;su_maxcount &lt; \</a>
<a name="ln185">                                130 ? 150 : (su)-&gt;su_maxcount + 20)</a>
<a name="ln186"> </a>
<a name="ln187">// Threshold for sorting and cleaning up suggestions.  Don't want to keep lots</a>
<a name="ln188">// of suggestions that are not going to be displayed.</a>
<a name="ln189">#define SUG_MAX_COUNT(su)       (SUG_CLEAN_COUNT(su) + 50)</a>
<a name="ln190"> </a>
<a name="ln191">// score for various changes</a>
<a name="ln192">#define SCORE_SPLIT     149     // split bad word</a>
<a name="ln193">#define SCORE_SPLIT_NO  249     // split bad word with NOSPLITSUGS</a>
<a name="ln194">#define SCORE_ICASE     52      // slightly different case</a>
<a name="ln195">#define SCORE_REGION    200     // word is for different region</a>
<a name="ln196">#define SCORE_RARE      180     // rare word</a>
<a name="ln197">#define SCORE_SWAP      75      // swap two characters</a>
<a name="ln198">#define SCORE_SWAP3     110     // swap two characters in three</a>
<a name="ln199">#define SCORE_REP       65      // REP replacement</a>
<a name="ln200">#define SCORE_SUBST     93      // substitute a character</a>
<a name="ln201">#define SCORE_SIMILAR   33      // substitute a similar character</a>
<a name="ln202">#define SCORE_SUBCOMP   33      // substitute a composing character</a>
<a name="ln203">#define SCORE_DEL       94      // delete a character</a>
<a name="ln204">#define SCORE_DELDUP    66      // delete a duplicated character</a>
<a name="ln205">#define SCORE_DELCOMP   28      // delete a composing character</a>
<a name="ln206">#define SCORE_INS       96      // insert a character</a>
<a name="ln207">#define SCORE_INSDUP    67      // insert a duplicate character</a>
<a name="ln208">#define SCORE_INSCOMP   30      // insert a composing character</a>
<a name="ln209">#define SCORE_NONWORD   103     // change non-word to word char</a>
<a name="ln210"> </a>
<a name="ln211">#define SCORE_FILE      30      // suggestion from a file</a>
<a name="ln212">#define SCORE_MAXINIT   350     // Initial maximum score: higher == slower.</a>
<a name="ln213">                                // 350 allows for about three changes.</a>
<a name="ln214"> </a>
<a name="ln215">#define SCORE_COMMON1   30      // subtracted for words seen before</a>
<a name="ln216">#define SCORE_COMMON2   40      // subtracted for words often seen</a>
<a name="ln217">#define SCORE_COMMON3   50      // subtracted for words very often seen</a>
<a name="ln218">#define SCORE_THRES2    10      // word count threshold for COMMON2</a>
<a name="ln219">#define SCORE_THRES3    100     // word count threshold for COMMON3</a>
<a name="ln220"> </a>
<a name="ln221">// When trying changed soundfold words it becomes slow when trying more than</a>
<a name="ln222">// two changes.  With less then two changes it's slightly faster but we miss a</a>
<a name="ln223">// few good suggestions.  In rare cases we need to try three of four changes.</a>
<a name="ln224">#define SCORE_SFMAX1    200     // maximum score for first try</a>
<a name="ln225">#define SCORE_SFMAX2    300     // maximum score for second try</a>
<a name="ln226">#define SCORE_SFMAX3    400     // maximum score for third try</a>
<a name="ln227"> </a>
<a name="ln228">#define SCORE_BIG       SCORE_INS * 3   // big difference</a>
<a name="ln229">#define SCORE_MAXMAX    999999          // accept any score</a>
<a name="ln230">#define SCORE_LIMITMAX  350             // for spell_edit_score_limit()</a>
<a name="ln231"> </a>
<a name="ln232">// for spell_edit_score_limit() we need to know the minimum value of</a>
<a name="ln233">// SCORE_ICASE, SCORE_SWAP, SCORE_DEL, SCORE_SIMILAR and SCORE_INS</a>
<a name="ln234">#define SCORE_EDIT_MIN  SCORE_SIMILAR</a>
<a name="ln235"> </a>
<a name="ln236">// Structure to store info for word matching.</a>
<a name="ln237">typedef struct matchinf_S {</a>
<a name="ln238">  langp_T     *mi_lp;                   // info for language and region</a>
<a name="ln239"> </a>
<a name="ln240">  // pointers to original text to be checked</a>
<a name="ln241">  char_u      *mi_word;                 // start of word being checked</a>
<a name="ln242">  char_u      *mi_end;                  // end of matching word so far</a>
<a name="ln243">  char_u      *mi_fend;                 // next char to be added to mi_fword</a>
<a name="ln244">  char_u      *mi_cend;                 // char after what was used for</a>
<a name="ln245">                                        // mi_capflags</a>
<a name="ln246"> </a>
<a name="ln247">  // case-folded text</a>
<a name="ln248">  char_u mi_fword[MAXWLEN + 1];         // mi_word case-folded</a>
<a name="ln249">  int mi_fwordlen;                      // nr of valid bytes in mi_fword</a>
<a name="ln250"> </a>
<a name="ln251">  // for when checking word after a prefix</a>
<a name="ln252">  int mi_prefarridx;                    // index in sl_pidxs with list of</a>
<a name="ln253">                                        // affixID/condition</a>
<a name="ln254">  int mi_prefcnt;                       // number of entries at mi_prefarridx</a>
<a name="ln255">  int mi_prefixlen;                     // byte length of prefix</a>
<a name="ln256">  int mi_cprefixlen;                    // byte length of prefix in original</a>
<a name="ln257">                                        // case</a>
<a name="ln258"> </a>
<a name="ln259">  // for when checking a compound word</a>
<a name="ln260">  int mi_compoff;                       // start of following word offset</a>
<a name="ln261">  char_u mi_compflags[MAXWLEN];         // flags for compound words used</a>
<a name="ln262">  int mi_complen;                       // nr of compound words used</a>
<a name="ln263">  int mi_compextra;                     // nr of COMPOUNDROOT words</a>
<a name="ln264"> </a>
<a name="ln265">  // others</a>
<a name="ln266">  int mi_result;                        // result so far: SP_BAD, SP_OK, etc.</a>
<a name="ln267">  int mi_capflags;                      // WF_ONECAP WF_ALLCAP WF_KEEPCAP</a>
<a name="ln268">  win_T       *mi_win;                  // buffer being checked</a>
<a name="ln269"> </a>
<a name="ln270">  // for NOBREAK</a>
<a name="ln271">  int mi_result2;                       // &quot;mi_resul&quot; without following word</a>
<a name="ln272">  char_u      *mi_end2;                 // &quot;mi_end&quot; without following word</a>
<a name="ln273">} matchinf_T;</a>
<a name="ln274"> </a>
<a name="ln275">// Structure used for the cookie argument of do_in_runtimepath().</a>
<a name="ln276">typedef struct spelload_S {</a>
<a name="ln277">  char_u sl_lang[MAXWLEN + 1];          // language name</a>
<a name="ln278">  slang_T *sl_slang;                    // resulting slang_T struct</a>
<a name="ln279">  int sl_nobreak;                       // NOBREAK language found</a>
<a name="ln280">} spelload_T;</a>
<a name="ln281"> </a>
<a name="ln282">#define SY_MAXLEN   30</a>
<a name="ln283">typedef struct syl_item_S {</a>
<a name="ln284">  char_u sy_chars[SY_MAXLEN];               // the sequence of chars</a>
<a name="ln285">  int sy_len;</a>
<a name="ln286">} syl_item_T;</a>
<a name="ln287"> </a>
<a name="ln288">spelltab_T spelltab;</a>
<a name="ln289">int did_set_spelltab;</a>
<a name="ln290"> </a>
<a name="ln291">// structure used to store soundfolded words that add_sound_suggest() has</a>
<a name="ln292">// handled already.</a>
<a name="ln293">typedef struct {</a>
<a name="ln294">  short sft_score;              // lowest score used</a>
<a name="ln295">  char_u sft_word[1];           // soundfolded word, actually longer</a>
<a name="ln296">} sftword_T;</a>
<a name="ln297"> </a>
<a name="ln298">typedef struct {</a>
<a name="ln299">  int badi;</a>
<a name="ln300">  int goodi;</a>
<a name="ln301">  int score;</a>
<a name="ln302">} limitscore_T;</a>
<a name="ln303"> </a>
<a name="ln304"> </a>
<a name="ln305">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln306"># include &quot;spell.c.generated.h&quot;</a>
<a name="ln307">#endif</a>
<a name="ln308"> </a>
<a name="ln309">// values for ts_isdiff</a>
<a name="ln310">#define DIFF_NONE       0       // no different byte (yet)</a>
<a name="ln311">#define DIFF_YES        1       // different byte found</a>
<a name="ln312">#define DIFF_INSERT     2       // inserting character</a>
<a name="ln313"> </a>
<a name="ln314">// values for ts_flags</a>
<a name="ln315">#define TSF_PREFIXOK    1       // already checked that prefix is OK</a>
<a name="ln316">#define TSF_DIDSPLIT    2       // tried split at this point</a>
<a name="ln317">#define TSF_DIDDEL      4       // did a delete, &quot;ts_delidx&quot; has index</a>
<a name="ln318"> </a>
<a name="ln319">// special values ts_prefixdepth</a>
<a name="ln320">#define PFD_NOPREFIX    0xff    // not using prefixes</a>
<a name="ln321">#define PFD_PREFIXTREE  0xfe    // walking through the prefix tree</a>
<a name="ln322">#define PFD_NOTSPECIAL  0xfd    // highest value that's not special</a>
<a name="ln323"> </a>
<a name="ln324">// mode values for find_word</a>
<a name="ln325">#define FIND_FOLDWORD       0   // find word case-folded</a>
<a name="ln326">#define FIND_KEEPWORD       1   // find keep-case word</a>
<a name="ln327">#define FIND_PREFIX         2   // find word after prefix</a>
<a name="ln328">#define FIND_COMPOUND       3   // find case-folded compound word</a>
<a name="ln329">#define FIND_KEEPCOMPOUND   4   // find keep-case compound word</a>
<a name="ln330"> </a>
<a name="ln331">char *e_format = N_(&quot;E759: Format error in spell file&quot;);</a>
<a name="ln332"> </a>
<a name="ln333">// Remember what &quot;z?&quot; replaced.</a>
<a name="ln334">static char_u *repl_from = NULL;</a>
<a name="ln335">static char_u *repl_to = NULL;</a>
<a name="ln336"> </a>
<a name="ln337">// Main spell-checking function.</a>
<a name="ln338">// &quot;ptr&quot; points to a character that could be the start of a word.</a>
<a name="ln339">// &quot;*attrp&quot; is set to the highlight index for a badly spelled word.  For a</a>
<a name="ln340">// non-word or when it's OK it remains unchanged.</a>
<a name="ln341">// This must only be called when 'spelllang' is not empty.</a>
<a name="ln342">//</a>
<a name="ln343">// &quot;capcol&quot; is used to check for a Capitalised word after the end of a</a>
<a name="ln344">// sentence.  If it's zero then perform the check.  Return the column where to</a>
<a name="ln345">// check next, or -1 when no sentence end was found.  If it's NULL then don't</a>
<a name="ln346">// worry.</a>
<a name="ln347">//</a>
<a name="ln348">// Returns the length of the word in bytes, also when it's OK, so that the</a>
<a name="ln349">// caller can skip over the word.</a>
<a name="ln350">size_t spell_check(</a>
<a name="ln351">    win_T *wp,                // current window</a>
<a name="ln352">    char_u *ptr,</a>
<a name="ln353">    hlf_T *attrp,</a>
<a name="ln354">    int *capcol,              // column to check for Capital</a>
<a name="ln355">    bool docount              // count good words</a>
<a name="ln356">)</a>
<a name="ln357">{</a>
<a name="ln358">  matchinf_T mi;              // Most things are put in &quot;mi&quot; so that it can</a>
<a name="ln359">                              // be passed to functions quickly.</a>
<a name="ln360">  size_t nrlen = 0;              // found a number first</a>
<a name="ln361">  int c;</a>
<a name="ln362">  size_t wrongcaplen = 0;</a>
<a name="ln363">  int lpi;</a>
<a name="ln364">  bool count_word = docount;</a>
<a name="ln365">  bool use_camel_case = *wp-&gt;w_s-&gt;b_p_spo != NUL;</a>
<a name="ln366">  bool camel_case = false;</a>
<a name="ln367"> </a>
<a name="ln368">  // A word never starts at a space or a control character. Return quickly</a>
<a name="ln369">  // then, skipping over the character.</a>
<a name="ln370">  if (*ptr &lt;= ' ') {</a>
<a name="ln371">    return 1;</a>
<a name="ln372">  }</a>
<a name="ln373"> </a>
<a name="ln374">  // Return here when loading language files failed.</a>
<a name="ln375">  if (GA_EMPTY(&amp;wp-&gt;w_s-&gt;b_langp)) {</a>
<a name="ln376">    return 1;</a>
<a name="ln377">  }</a>
<a name="ln378"> </a>
<a name="ln379">  memset(&amp;mi, 0, sizeof(matchinf_T));</a>
<a name="ln380"> </a>
<a name="ln381">  // A number is always OK.  Also skip hexadecimal numbers 0xFF99 and</a>
<a name="ln382">  // 0X99FF.  But always do check spelling to find &quot;3GPP&quot; and &quot;11</a>
<a name="ln383">  // julifeest&quot;.</a>
<a name="ln384">  if (*ptr &gt;= '0' &amp;&amp; *ptr &lt;= '9') {</a>
<a name="ln385">    if (*ptr == '0' &amp;&amp; (ptr[1] == 'b' || ptr[1] == 'B')) {</a>
<a name="ln386">      mi.mi_end = (char_u*) skipbin((char*) ptr + 2);</a>
<a name="ln387">    } else if (*ptr == '0' &amp;&amp; (ptr[1] == 'x' || ptr[1] == 'X')) {</a>
<a name="ln388">      mi.mi_end = skiphex(ptr + 2);</a>
<a name="ln389">    } else {</a>
<a name="ln390">      mi.mi_end = skipdigits(ptr);</a>
<a name="ln391">    }</a>
<a name="ln392">    nrlen = (size_t)(mi.mi_end - ptr);</a>
<a name="ln393">  }</a>
<a name="ln394"> </a>
<a name="ln395">  // Find the normal end of the word (until the next non-word character).</a>
<a name="ln396">  mi.mi_word = ptr;</a>
<a name="ln397">  mi.mi_fend = ptr;</a>
<a name="ln398">  if (spell_iswordp(mi.mi_fend, wp)) {</a>
<a name="ln399">    bool this_upper = false;  // init for gcc</a>
<a name="ln400"> </a>
<a name="ln401">    if (use_camel_case) {</a>
<a name="ln402">      c = PTR2CHAR(mi.mi_fend);</a>
<a name="ln403">      this_upper = SPELL_ISUPPER(c);</a>
<a name="ln404">    }</a>
<a name="ln405"> </a>
<a name="ln406">    do {</a>
<a name="ln407">      MB_PTR_ADV(mi.mi_fend);</a>
<a name="ln408">      if (use_camel_case) {</a>
<a name="ln409">        const bool prev_upper = this_upper;</a>
<a name="ln410">        c = PTR2CHAR(mi.mi_fend);</a>
<a name="ln411">        this_upper = SPELL_ISUPPER(c);</a>
<a name="ln412">        camel_case = !prev_upper &amp;&amp; this_upper;</a>
<a name="ln413">      }</a>
<a name="ln414">    } while (*mi.mi_fend != NUL &amp;&amp; spell_iswordp(mi.mi_fend, wp)</a>
<a name="ln415">             &amp;&amp; !camel_case);</a>
<a name="ln416"> </a>
<a name="ln417">    if (capcol != NULL &amp;&amp; *capcol == 0 &amp;&amp; wp-&gt;w_s-&gt;b_cap_prog != NULL) {</a>
<a name="ln418">      // Check word starting with capital letter.</a>
<a name="ln419">      c = PTR2CHAR(ptr);</a>
<a name="ln420">      if (!SPELL_ISUPPER(c)) {</a>
<a name="ln421">        wrongcaplen = (size_t)(mi.mi_fend - ptr);</a>
<a name="ln422">      }</a>
<a name="ln423">    }</a>
<a name="ln424">  }</a>
<a name="ln425">  if (capcol != NULL) {</a>
<a name="ln426">    *capcol = -1;</a>
<a name="ln427">  }</a>
<a name="ln428"> </a>
<a name="ln429">  // We always use the characters up to the next non-word character,</a>
<a name="ln430">  // also for bad words.</a>
<a name="ln431">  mi.mi_end = mi.mi_fend;</a>
<a name="ln432"> </a>
<a name="ln433">  // Check caps type later.</a>
<a name="ln434">  mi.mi_capflags = 0;</a>
<a name="ln435">  mi.mi_cend = NULL;</a>
<a name="ln436">  mi.mi_win = wp;</a>
<a name="ln437"> </a>
<a name="ln438">  // case-fold the word with one non-word character, so that we can check</a>
<a name="ln439">  // for the word end.</a>
<a name="ln440">  if (*mi.mi_fend != NUL) {</a>
<a name="ln441">    MB_PTR_ADV(mi.mi_fend);</a>
<a name="ln442">  }</a>
<a name="ln443"> </a>
<a name="ln444">  (void)spell_casefold(ptr, (int)(mi.mi_fend - ptr), mi.mi_fword, MAXWLEN + 1);</a>
<a name="ln445">  mi.mi_fwordlen = (int)STRLEN(mi.mi_fword);</a>
<a name="ln446"> </a>
<a name="ln447">  if (camel_case) {</a>
<a name="ln448">    // introduce a fake word end space into the folded word.</a>
<a name="ln449">    mi.mi_fword[mi.mi_fwordlen - 1] = ' ';</a>
<a name="ln450">  }</a>
<a name="ln451"> </a>
<a name="ln452">  // The word is bad unless we recognize it.</a>
<a name="ln453">  mi.mi_result = SP_BAD;</a>
<a name="ln454">  mi.mi_result2 = SP_BAD;</a>
<a name="ln455"> </a>
<a name="ln456">  // Loop over the languages specified in 'spelllang'.</a>
<a name="ln457">  // We check them all, because a word may be matched longer in another</a>
<a name="ln458">  // language.</a>
<a name="ln459">  for (lpi = 0; lpi &lt; wp-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln460">    mi.mi_lp = LANGP_ENTRY(wp-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln461"> </a>
<a name="ln462">    // If reloading fails the language is still in the list but everything</a>
<a name="ln463">    // has been cleared.</a>
<a name="ln464">    if (mi.mi_lp-&gt;lp_slang-&gt;sl_fidxs == NULL) {</a>
<a name="ln465">      continue;</a>
<a name="ln466">    }</a>
<a name="ln467"> </a>
<a name="ln468">    // Check for a matching word in case-folded words.</a>
<a name="ln469">    find_word(&amp;mi, FIND_FOLDWORD);</a>
<a name="ln470"> </a>
<a name="ln471">    // Check for a matching word in keep-case words.</a>
<a name="ln472">    find_word(&amp;mi, FIND_KEEPWORD);</a>
<a name="ln473"> </a>
<a name="ln474">    // Check for matching prefixes.</a>
<a name="ln475">    find_prefix(&amp;mi, FIND_FOLDWORD);</a>
<a name="ln476"> </a>
<a name="ln477">    // For a NOBREAK language, may want to use a word without a following</a>
<a name="ln478">    // word as a backup.</a>
<a name="ln479">    if (mi.mi_lp-&gt;lp_slang-&gt;sl_nobreak &amp;&amp; mi.mi_result == SP_BAD</a>
<a name="ln480">        &amp;&amp; mi.mi_result2 != SP_BAD) {</a>
<a name="ln481">      mi.mi_result = mi.mi_result2;</a>
<a name="ln482">      mi.mi_end = mi.mi_end2;</a>
<a name="ln483">    }</a>
<a name="ln484"> </a>
<a name="ln485">    // Count the word in the first language where it's found to be OK.</a>
<a name="ln486">    if (count_word &amp;&amp; mi.mi_result == SP_OK) {</a>
<a name="ln487">      count_common_word(mi.mi_lp-&gt;lp_slang, ptr,</a>
<a name="ln488">          (int)(mi.mi_end - ptr), 1);</a>
<a name="ln489">      count_word = false;</a>
<a name="ln490">    }</a>
<a name="ln491">  }</a>
<a name="ln492"> </a>
<a name="ln493">  if (mi.mi_result != SP_OK) {</a>
<a name="ln494">    // If we found a number skip over it.  Allows for &quot;42nd&quot;.  Do flag</a>
<a name="ln495">    // rare and local words, e.g., &quot;3GPP&quot;.</a>
<a name="ln496">    if (nrlen &gt; 0) {</a>
<a name="ln497">      if (mi.mi_result == SP_BAD || mi.mi_result == SP_BANNED) {</a>
<a name="ln498">        return nrlen;</a>
<a name="ln499">      }</a>
<a name="ln500">    } else if (!spell_iswordp_nmw(ptr, wp)) {</a>
<a name="ln501">    // When we are at a non-word character there is no error, just</a>
<a name="ln502">    // skip over the character (try looking for a word after it).</a>
<a name="ln503">      if (capcol != NULL &amp;&amp; wp-&gt;w_s-&gt;b_cap_prog != NULL) {</a>
<a name="ln504">        regmatch_T regmatch;</a>
<a name="ln505"> </a>
<a name="ln506">        // Check for end of sentence.</a>
<a name="ln507">        regmatch.regprog = wp-&gt;w_s-&gt;b_cap_prog;</a>
<a name="ln508">        regmatch.rm_ic = false;</a>
<a name="ln509">        int r = vim_regexec(&amp;regmatch, ptr, 0);</a>
<a name="ln510">        wp-&gt;w_s-&gt;b_cap_prog = regmatch.regprog;</a>
<a name="ln511">        if (r) {</a>
<a name="ln512">          *capcol = (int)(regmatch.endp[0] - ptr);</a>
<a name="ln513">        }</a>
<a name="ln514">      }</a>
<a name="ln515"> </a>
<a name="ln516">      return (size_t)(utfc_ptr2len(ptr));</a>
<a name="ln517">    } else if (mi.mi_end == ptr) {</a>
<a name="ln518">      // Always include at least one character.  Required for when there</a>
<a name="ln519">      // is a mixup in &quot;midword&quot;.</a>
<a name="ln520">      MB_PTR_ADV(mi.mi_end);</a>
<a name="ln521">    } else if (mi.mi_result == SP_BAD</a>
<a name="ln522">               &amp;&amp; LANGP_ENTRY(wp-&gt;w_s-&gt;b_langp, 0)-&gt;lp_slang-&gt;sl_nobreak) {</a>
<a name="ln523">      char_u      *p, *fp;</a>
<a name="ln524">      int save_result = mi.mi_result;</a>
<a name="ln525"> </a>
<a name="ln526">      // First language in 'spelllang' is NOBREAK.  Find first position</a>
<a name="ln527">      // at which any word would be valid.</a>
<a name="ln528">      mi.mi_lp = LANGP_ENTRY(wp-&gt;w_s-&gt;b_langp, 0);</a>
<a name="ln529">      if (mi.mi_lp-&gt;lp_slang-&gt;sl_fidxs != NULL) {</a>
<a name="ln530">        p = mi.mi_word;</a>
<a name="ln531">        fp = mi.mi_fword;</a>
<a name="ln532">        for (;;) {</a>
<a name="ln533">          MB_PTR_ADV(p);</a>
<a name="ln534">          MB_PTR_ADV(fp);</a>
<a name="ln535">          if (p &gt;= mi.mi_end) {</a>
<a name="ln536">            break;</a>
<a name="ln537">          }</a>
<a name="ln538">          mi.mi_compoff = (int)(fp - mi.mi_fword);</a>
<a name="ln539">          find_word(&amp;mi, FIND_COMPOUND);</a>
<a name="ln540">          if (mi.mi_result != SP_BAD) {</a>
<a name="ln541">            mi.mi_end = p;</a>
<a name="ln542">            break;</a>
<a name="ln543">          }</a>
<a name="ln544">        }</a>
<a name="ln545">        mi.mi_result = save_result;</a>
<a name="ln546">      }</a>
<a name="ln547">    }</a>
<a name="ln548"> </a>
<a name="ln549">    if (mi.mi_result == SP_BAD || mi.mi_result == SP_BANNED) {</a>
<a name="ln550">      *attrp = HLF_SPB;</a>
<a name="ln551">    } else if (mi.mi_result == SP_RARE) {</a>
<a name="ln552">      *attrp = HLF_SPR;</a>
<a name="ln553">    } else {</a>
<a name="ln554">      *attrp = HLF_SPL;</a>
<a name="ln555">    }</a>
<a name="ln556">  }</a>
<a name="ln557"> </a>
<a name="ln558">  if (wrongcaplen &gt; 0 &amp;&amp; (mi.mi_result == SP_OK || mi.mi_result == SP_RARE)) {</a>
<a name="ln559">    // Report SpellCap only when the word isn't badly spelled.</a>
<a name="ln560">    *attrp = HLF_SPC;</a>
<a name="ln561">    return wrongcaplen;</a>
<a name="ln562">  }</a>
<a name="ln563"> </a>
<a name="ln564">  return (size_t)(mi.mi_end - ptr);</a>
<a name="ln565">}</a>
<a name="ln566"> </a>
<a name="ln567">// Check if the word at &quot;mip-&gt;mi_word&quot; is in the tree.</a>
<a name="ln568">// When &quot;mode&quot; is FIND_FOLDWORD check in fold-case word tree.</a>
<a name="ln569">// When &quot;mode&quot; is FIND_KEEPWORD check in keep-case word tree.</a>
<a name="ln570">// When &quot;mode&quot; is FIND_PREFIX check for word after prefix in fold-case word</a>
<a name="ln571">// tree.</a>
<a name="ln572">//</a>
<a name="ln573">// For a match mip-&gt;mi_result is updated.</a>
<a name="ln574">static void find_word(matchinf_T *mip, int mode)</a>
<a name="ln575">{</a>
<a name="ln576">  int wlen = 0;</a>
<a name="ln577">  int flen;</a>
<a name="ln578">  char_u      *ptr;</a>
<a name="ln579">  slang_T     *slang = mip-&gt;mi_lp-&gt;lp_slang;</a>
<a name="ln580">  char_u      *byts;</a>
<a name="ln581">  idx_T       *idxs;</a>
<a name="ln582"> </a>
<a name="ln583">  if (mode == FIND_KEEPWORD || mode == FIND_KEEPCOMPOUND) {</a>
<a name="ln584">    // Check for word with matching case in keep-case tree.</a>
<a name="ln585">    ptr = mip-&gt;mi_word;</a>
<a name="ln586">    flen = 9999;                    // no case folding, always enough bytes</a>
<a name="ln587">    byts = slang-&gt;sl_kbyts;</a>
<a name="ln588">    idxs = slang-&gt;sl_kidxs;</a>
<a name="ln589"> </a>
<a name="ln590">    if (mode == FIND_KEEPCOMPOUND)</a>
<a name="ln591">      // Skip over the previously found word(s).</a>
<a name="ln592">      wlen += mip-&gt;mi_compoff;</a>
<a name="ln593">  } else {</a>
<a name="ln594">    // Check for case-folded in case-folded tree.</a>
<a name="ln595">    ptr = mip-&gt;mi_fword;</a>
<a name="ln596">    flen = mip-&gt;mi_fwordlen;        // available case-folded bytes</a>
<a name="ln597">    byts = slang-&gt;sl_fbyts;</a>
<a name="ln598">    idxs = slang-&gt;sl_fidxs;</a>
<a name="ln599"> </a>
<a name="ln600">    if (mode == FIND_PREFIX) {</a>
<a name="ln601">      // Skip over the prefix.</a>
<a name="ln602">      wlen = mip-&gt;mi_prefixlen;</a>
<a name="ln603">      flen -= mip-&gt;mi_prefixlen;</a>
<a name="ln604">    } else if (mode == FIND_COMPOUND) {</a>
<a name="ln605">      // Skip over the previously found word(s).</a>
<a name="ln606">      wlen = mip-&gt;mi_compoff;</a>
<a name="ln607">      flen -= mip-&gt;mi_compoff;</a>
<a name="ln608">    }</a>
<a name="ln609"> </a>
<a name="ln610">  }</a>
<a name="ln611"> </a>
<a name="ln612">  if (byts == NULL)</a>
<a name="ln613">    return;                     // array is empty</a>
<a name="ln614"> </a>
<a name="ln615">  idx_T arridx = 0;</a>
<a name="ln616">  int endlen[MAXWLEN];              // length at possible word endings</a>
<a name="ln617">  idx_T endidx[MAXWLEN];            // possible word endings</a>
<a name="ln618">  int endidxcnt = 0;</a>
<a name="ln619">  int len;</a>
<a name="ln620">  int c;</a>
<a name="ln621"> </a>
<a name="ln622">  // Repeat advancing in the tree until:</a>
<a name="ln623">  // - there is a byte that doesn't match,</a>
<a name="ln624">  // - we reach the end of the tree,</a>
<a name="ln625">  // - or we reach the end of the line.</a>
<a name="ln626">  for (;; ) {</a>
<a name="ln627">    if (flen &lt;= 0 &amp;&amp; *mip-&gt;mi_fend != NUL)</a>
<a name="ln628">      flen = fold_more(mip);</a>
<a name="ln629"> </a>
<a name="ln630">    len = byts[arridx++];</a>
<a name="ln631"> </a>
<a name="ln632">    // If the first possible byte is a zero the word could end here.</a>
<a name="ln633">    // Remember this index, we first check for the longest word.</a>
<a name="ln634">    if (byts[arridx] == 0) {</a>
<a name="ln635">      if (endidxcnt == MAXWLEN) {</a>
<a name="ln636">        // Must be a corrupted spell file.</a>
<a name="ln637">        EMSG(_(e_format));</a>
<a name="ln638">        return;</a>
<a name="ln639">      }</a>
<a name="ln640">      endlen[endidxcnt] = wlen;</a>
<a name="ln641">      endidx[endidxcnt++] = arridx++;</a>
<a name="ln642">      --len;</a>
<a name="ln643"> </a>
<a name="ln644">      // Skip over the zeros, there can be several flag/region</a>
<a name="ln645">      // combinations.</a>
<a name="ln646">      while (len &gt; 0 &amp;&amp; byts[arridx] == 0) {</a>
<a name="ln647">        ++arridx;</a>
<a name="ln648">        --len;</a>
<a name="ln649">      }</a>
<a name="ln650">      if (len == 0)</a>
<a name="ln651">        break;              // no children, word must end here</a>
<a name="ln652">    }</a>
<a name="ln653"> </a>
<a name="ln654">    // Stop looking at end of the line.</a>
<a name="ln655">    if (ptr[wlen] == NUL)</a>
<a name="ln656">      break;</a>
<a name="ln657"> </a>
<a name="ln658">    // Perform a binary search in the list of accepted bytes.</a>
<a name="ln659">    c = ptr[wlen];</a>
<a name="ln660">    if (c == TAB)           // &lt;Tab&gt; is handled like &lt;Space&gt;</a>
<a name="ln661">      c = ' ';</a>
<a name="ln662">    idx_T lo = arridx;</a>
<a name="ln663">    idx_T hi = arridx + len - 1;</a>
<a name="ln664">    while (lo &lt; hi) {</a>
<a name="ln665">      idx_T m = (lo + hi) / 2;</a>
<a name="ln666">      if (byts[m] &gt; c)</a>
<a name="ln667">        hi = m - 1;</a>
<a name="ln668">      else if (byts[m] &lt; c)</a>
<a name="ln669">        lo = m + 1;</a>
<a name="ln670">      else {</a>
<a name="ln671">        lo = hi = m;</a>
<a name="ln672">        break;</a>
<a name="ln673">      }</a>
<a name="ln674">    }</a>
<a name="ln675"> </a>
<a name="ln676">    // Stop if there is no matching byte.</a>
<a name="ln677">    if (hi &lt; lo || byts[lo] != c)</a>
<a name="ln678">      break;</a>
<a name="ln679"> </a>
<a name="ln680">    // Continue at the child (if there is one).</a>
<a name="ln681">    arridx = idxs[lo];</a>
<a name="ln682">    ++wlen;</a>
<a name="ln683">    --flen;</a>
<a name="ln684"> </a>
<a name="ln685">    // One space in the good word may stand for several spaces in the</a>
<a name="ln686">    // checked word.</a>
<a name="ln687">    if (c == ' ') {</a>
<a name="ln688">      for (;; ) {</a>
<a name="ln689">        if (flen &lt;= 0 &amp;&amp; *mip-&gt;mi_fend != NUL)</a>
<a name="ln690">          flen = fold_more(mip);</a>
<a name="ln691">        if (ptr[wlen] != ' ' &amp;&amp; ptr[wlen] != TAB)</a>
<a name="ln692">          break;</a>
<a name="ln693">        ++wlen;</a>
<a name="ln694">        --flen;</a>
<a name="ln695">      }</a>
<a name="ln696">    }</a>
<a name="ln697">  }</a>
<a name="ln698"> </a>
<a name="ln699">  char_u *p;</a>
<a name="ln700">  bool word_ends;</a>
<a name="ln701"> </a>
<a name="ln702">  // Verify that one of the possible endings is valid.  Try the longest</a>
<a name="ln703">  // first.</a>
<a name="ln704">  while (endidxcnt &gt; 0) {</a>
<a name="ln705">    --endidxcnt;</a>
<a name="ln706">    arridx = endidx[endidxcnt];</a>
<a name="ln707">    wlen = endlen[endidxcnt];</a>
<a name="ln708"> </a>
<a name="ln709">    if (utf_head_off(ptr, ptr + wlen) &gt; 0) {</a>
<a name="ln710">      continue;             // not at first byte of character</a>
<a name="ln711">    }</a>
<a name="ln712">    if (spell_iswordp(ptr + wlen, mip-&gt;mi_win)) {</a>
<a name="ln713">      if (slang-&gt;sl_compprog == NULL &amp;&amp; !slang-&gt;sl_nobreak)</a>
<a name="ln714">        continue;                   // next char is a word character</a>
<a name="ln715">      word_ends = false;</a>
<a name="ln716">    } else</a>
<a name="ln717">      word_ends = true;</a>
<a name="ln718">    // The prefix flag is before compound flags.  Once a valid prefix flag</a>
<a name="ln719">    // has been found we try compound flags.</a>
<a name="ln720">    bool prefix_found = false;</a>
<a name="ln721"> </a>
<a name="ln722">    if (mode != FIND_KEEPWORD) {</a>
<a name="ln723">      // Compute byte length in original word, length may change</a>
<a name="ln724">      // when folding case.  This can be slow, take a shortcut when the</a>
<a name="ln725">      // case-folded word is equal to the keep-case word.</a>
<a name="ln726">      p = mip-&gt;mi_word;</a>
<a name="ln727">      if (STRNCMP(ptr, p, wlen) != 0) {</a>
<a name="ln728">        for (char_u *s = ptr; s &lt; ptr + wlen; MB_PTR_ADV(s)) {</a>
<a name="ln729">          MB_PTR_ADV(p);</a>
<a name="ln730">        }</a>
<a name="ln731">        wlen = (int)(p - mip-&gt;mi_word);</a>
<a name="ln732">      }</a>
<a name="ln733">    }</a>
<a name="ln734"> </a>
<a name="ln735">    // Check flags and region.  For FIND_PREFIX check the condition and</a>
<a name="ln736">    // prefix ID.</a>
<a name="ln737">    // Repeat this if there are more flags/region alternatives until there</a>
<a name="ln738">    // is a match.</a>
<a name="ln739">    for (len = byts[arridx - 1]; len &gt; 0 &amp;&amp; byts[arridx] == 0;</a>
<a name="ln740">         --len, ++arridx) {</a>
<a name="ln741">      uint32_t flags = idxs[arridx];</a>
<a name="ln742"> </a>
<a name="ln743">      // For the fold-case tree check that the case of the checked word</a>
<a name="ln744">      // matches with what the word in the tree requires.</a>
<a name="ln745">      // For keep-case tree the case is always right.  For prefixes we</a>
<a name="ln746">      // don't bother to check.</a>
<a name="ln747">      if (mode == FIND_FOLDWORD) {</a>
<a name="ln748">        if (mip-&gt;mi_cend != mip-&gt;mi_word + wlen) {</a>
<a name="ln749">          // mi_capflags was set for a different word length, need</a>
<a name="ln750">          // to do it again.</a>
<a name="ln751">          mip-&gt;mi_cend = mip-&gt;mi_word + wlen;</a>
<a name="ln752">          mip-&gt;mi_capflags = captype(mip-&gt;mi_word, mip-&gt;mi_cend);</a>
<a name="ln753">        }</a>
<a name="ln754"> </a>
<a name="ln755">        if (mip-&gt;mi_capflags == WF_KEEPCAP</a>
<a name="ln756">            || !spell_valid_case(mip-&gt;mi_capflags, flags))</a>
<a name="ln757">          continue;</a>
<a name="ln758">      }</a>
<a name="ln759">      // When mode is FIND_PREFIX the word must support the prefix:</a>
<a name="ln760">      // check the prefix ID and the condition.  Do that for the list at</a>
<a name="ln761">      // mip-&gt;mi_prefarridx that find_prefix() filled.</a>
<a name="ln762">      else if (mode == FIND_PREFIX &amp;&amp; !prefix_found) {</a>
<a name="ln763">        c = valid_word_prefix(mip-&gt;mi_prefcnt, mip-&gt;mi_prefarridx,</a>
<a name="ln764">            flags,</a>
<a name="ln765">            mip-&gt;mi_word + mip-&gt;mi_cprefixlen, slang,</a>
<a name="ln766">            false);</a>
<a name="ln767">        if (c == 0)</a>
<a name="ln768">          continue;</a>
<a name="ln769"> </a>
<a name="ln770">        // Use the WF_RARE flag for a rare prefix.</a>
<a name="ln771">        if (c &amp; WF_RAREPFX)</a>
<a name="ln772">          flags |= WF_RARE;</a>
<a name="ln773">        prefix_found = true;</a>
<a name="ln774">      }</a>
<a name="ln775"> </a>
<a name="ln776">      if (slang-&gt;sl_nobreak) {</a>
<a name="ln777">        if ((mode == FIND_COMPOUND || mode == FIND_KEEPCOMPOUND)</a>
<a name="ln778">            &amp;&amp; (flags &amp; WF_BANNED) == 0) {</a>
<a name="ln779">          // NOBREAK: found a valid following word.  That's all we</a>
<a name="ln780">          // need to know, so return.</a>
<a name="ln781">          mip-&gt;mi_result = SP_OK;</a>
<a name="ln782">          break;</a>
<a name="ln783">        }</a>
<a name="ln784">      } else if ((mode == FIND_COMPOUND || mode == FIND_KEEPCOMPOUND</a>
<a name="ln785">                  || !word_ends)) {</a>
<a name="ln786">        // If there is no compound flag or the word is shorter than</a>
<a name="ln787">        // COMPOUNDMIN reject it quickly.</a>
<a name="ln788">        // Makes you wonder why someone puts a compound flag on a word</a>
<a name="ln789">        // that's too short...  Myspell compatibility requires this</a>
<a name="ln790">        // anyway.</a>
<a name="ln791">        if (((unsigned)flags &gt;&gt; 24) == 0</a>
<a name="ln792">            || wlen - mip-&gt;mi_compoff &lt; slang-&gt;sl_compminlen)</a>
<a name="ln793">          continue;</a>
<a name="ln794">        // For multi-byte chars check character length against</a>
<a name="ln795">        // COMPOUNDMIN.</a>
<a name="ln796">        if (slang-&gt;sl_compminlen &gt; 0</a>
<a name="ln797">            &amp;&amp; mb_charlen_len(mip-&gt;mi_word + mip-&gt;mi_compoff,</a>
<a name="ln798">                              wlen - mip-&gt;mi_compoff) &lt; slang-&gt;sl_compminlen) {</a>
<a name="ln799">          continue;</a>
<a name="ln800">        }</a>
<a name="ln801"> </a>
<a name="ln802">        // Limit the number of compound words to COMPOUNDWORDMAX if no</a>
<a name="ln803">        // maximum for syllables is specified.</a>
<a name="ln804">        if (!word_ends &amp;&amp; mip-&gt;mi_complen + mip-&gt;mi_compextra + 2</a>
<a name="ln805">            &gt; slang-&gt;sl_compmax</a>
<a name="ln806">            &amp;&amp; slang-&gt;sl_compsylmax == MAXWLEN)</a>
<a name="ln807">          continue;</a>
<a name="ln808"> </a>
<a name="ln809">        // Don't allow compounding on a side where an affix was added,</a>
<a name="ln810">        // unless COMPOUNDPERMITFLAG was used.</a>
<a name="ln811">        if (mip-&gt;mi_complen &gt; 0 &amp;&amp; (flags &amp; WF_NOCOMPBEF))</a>
<a name="ln812">          continue;</a>
<a name="ln813">        if (!word_ends &amp;&amp; (flags &amp; WF_NOCOMPAFT))</a>
<a name="ln814">          continue;</a>
<a name="ln815"> </a>
<a name="ln816">        // Quickly check if compounding is possible with this flag.</a>
<a name="ln817">        if (!byte_in_str(mip-&gt;mi_complen == 0</a>
<a name="ln818">                ? slang-&gt;sl_compstartflags</a>
<a name="ln819">                : slang-&gt;sl_compallflags,</a>
<a name="ln820">                ((unsigned)flags &gt;&gt; 24)))</a>
<a name="ln821">          continue;</a>
<a name="ln822"> </a>
<a name="ln823">        // If there is a match with a CHECKCOMPOUNDPATTERN rule</a>
<a name="ln824">        // discard the compound word.</a>
<a name="ln825">        if (match_checkcompoundpattern(ptr, wlen, &amp;slang-&gt;sl_comppat))</a>
<a name="ln826">          continue;</a>
<a name="ln827"> </a>
<a name="ln828">        if (mode == FIND_COMPOUND) {</a>
<a name="ln829">          int capflags;</a>
<a name="ln830"> </a>
<a name="ln831">          // Need to check the caps type of the appended compound</a>
<a name="ln832">          // word.</a>
<a name="ln833">          if (STRNCMP(ptr, mip-&gt;mi_word, mip-&gt;mi_compoff) != 0) {</a>
<a name="ln834">            // case folding may have changed the length</a>
<a name="ln835">            p = mip-&gt;mi_word;</a>
<a name="ln836">            for (char_u *s = ptr; s &lt; ptr + mip-&gt;mi_compoff; MB_PTR_ADV(s)) {</a>
<a name="ln837">              MB_PTR_ADV(p);</a>
<a name="ln838">            }</a>
<a name="ln839">          } else {</a>
<a name="ln840">            p = mip-&gt;mi_word + mip-&gt;mi_compoff;</a>
<a name="ln841">          }</a>
<a name="ln842">          capflags = captype(p, mip-&gt;mi_word + wlen);</a>
<a name="ln843">          if (capflags == WF_KEEPCAP || (capflags == WF_ALLCAP</a>
<a name="ln844">                                         &amp;&amp; (flags &amp; WF_FIXCAP) != 0))</a>
<a name="ln845">            continue;</a>
<a name="ln846"> </a>
<a name="ln847">          if (capflags != WF_ALLCAP) {</a>
<a name="ln848">            // When the character before the word is a word</a>
<a name="ln849">            // character we do not accept a Onecap word.  We do</a>
<a name="ln850">            // accept a no-caps word, even when the dictionary</a>
<a name="ln851">            // word specifies ONECAP.</a>
<a name="ln852">            MB_PTR_BACK(mip-&gt;mi_word, p);</a>
<a name="ln853">            if (spell_iswordp_nmw(p, mip-&gt;mi_win)</a>
<a name="ln854">                ? capflags == WF_ONECAP</a>
<a name="ln855">                : (flags &amp; WF_ONECAP) != 0</a>
<a name="ln856">                &amp;&amp; capflags != WF_ONECAP) {</a>
<a name="ln857">              continue;</a>
<a name="ln858">            }</a>
<a name="ln859">          }</a>
<a name="ln860">        }</a>
<a name="ln861"> </a>
<a name="ln862">        // If the word ends the sequence of compound flags of the</a>
<a name="ln863">        // words must match with one of the COMPOUNDRULE items and</a>
<a name="ln864">        // the number of syllables must not be too large.</a>
<a name="ln865">        mip-&gt;mi_compflags[mip-&gt;mi_complen] = ((unsigned)flags &gt;&gt; 24);</a>
<a name="ln866">        mip-&gt;mi_compflags[mip-&gt;mi_complen + 1] = NUL;</a>
<a name="ln867">        if (word_ends) {</a>
<a name="ln868">          char_u fword[MAXWLEN] = { 0 };</a>
<a name="ln869"> </a>
<a name="ln870">          if (slang-&gt;sl_compsylmax &lt; MAXWLEN) {</a>
<a name="ln871">            // &quot;fword&quot; is only needed for checking syllables.</a>
<a name="ln872">            if (ptr == mip-&gt;mi_word)</a>
<a name="ln873">              (void)spell_casefold(ptr, wlen, fword, MAXWLEN);</a>
<a name="ln874">            else</a>
<a name="ln875">              STRLCPY(fword, ptr, endlen[endidxcnt] + 1);</a>
<a name="ln876">          }</a>
<a name="ln877">          if (!can_compound(slang, fword, mip-&gt;mi_compflags))</a>
<a name="ln878">            continue;</a>
<a name="ln879">        } else if (slang-&gt;sl_comprules != NULL</a>
<a name="ln880">                   &amp;&amp; !match_compoundrule(slang, mip-&gt;mi_compflags))</a>
<a name="ln881">          // The compound flags collected so far do not match any</a>
<a name="ln882">          // COMPOUNDRULE, discard the compounded word.</a>
<a name="ln883">          continue;</a>
<a name="ln884">      }</a>
<a name="ln885">      // Check NEEDCOMPOUND: can't use word without compounding.</a>
<a name="ln886">      else if (flags &amp; WF_NEEDCOMP)</a>
<a name="ln887">        continue;</a>
<a name="ln888"> </a>
<a name="ln889">      int nobreak_result = SP_OK;</a>
<a name="ln890"> </a>
<a name="ln891">      if (!word_ends) {</a>
<a name="ln892">        int save_result = mip-&gt;mi_result;</a>
<a name="ln893">        char_u  *save_end = mip-&gt;mi_end;</a>
<a name="ln894">        langp_T *save_lp = mip-&gt;mi_lp;</a>
<a name="ln895"> </a>
<a name="ln896">        // Check that a valid word follows.  If there is one and we</a>
<a name="ln897">        // are compounding, it will set &quot;mi_result&quot;, thus we are</a>
<a name="ln898">        // always finished here.  For NOBREAK we only check that a</a>
<a name="ln899">        // valid word follows.</a>
<a name="ln900">        // Recursive!</a>
<a name="ln901">        if (slang-&gt;sl_nobreak)</a>
<a name="ln902">          mip-&gt;mi_result = SP_BAD;</a>
<a name="ln903"> </a>
<a name="ln904">        // Find following word in case-folded tree.</a>
<a name="ln905">        mip-&gt;mi_compoff = endlen[endidxcnt];</a>
<a name="ln906">        if (mode == FIND_KEEPWORD) {</a>
<a name="ln907">          // Compute byte length in case-folded word from &quot;wlen&quot;:</a>
<a name="ln908">          // byte length in keep-case word.  Length may change when</a>
<a name="ln909">          // folding case.  This can be slow, take a shortcut when</a>
<a name="ln910">          // the case-folded word is equal to the keep-case word.</a>
<a name="ln911">          p = mip-&gt;mi_fword;</a>
<a name="ln912">          if (STRNCMP(ptr, p, wlen) != 0) {</a>
<a name="ln913">            for (char_u *s = ptr; s &lt; ptr + wlen; MB_PTR_ADV(s)) {</a>
<a name="ln914">              MB_PTR_ADV(p);</a>
<a name="ln915">            }</a>
<a name="ln916">            mip-&gt;mi_compoff = (int)(p - mip-&gt;mi_fword);</a>
<a name="ln917">          }</a>
<a name="ln918">        }</a>
<a name="ln919">#if 0</a>
<a name="ln920">        c = mip-&gt;mi_compoff;</a>
<a name="ln921">#endif</a>
<a name="ln922">        ++mip-&gt;mi_complen;</a>
<a name="ln923">        if (flags &amp; WF_COMPROOT)</a>
<a name="ln924">          ++mip-&gt;mi_compextra;</a>
<a name="ln925"> </a>
<a name="ln926">        // For NOBREAK we need to try all NOBREAK languages, at least</a>
<a name="ln927">        // to find the &quot;.add&quot; file(s).</a>
<a name="ln928">        for (int lpi = 0; lpi &lt; mip-&gt;mi_win-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln929">          if (slang-&gt;sl_nobreak) {</a>
<a name="ln930">            mip-&gt;mi_lp = LANGP_ENTRY(mip-&gt;mi_win-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln931">            if (mip-&gt;mi_lp-&gt;lp_slang-&gt;sl_fidxs == NULL</a>
<a name="ln932">                || !mip-&gt;mi_lp-&gt;lp_slang-&gt;sl_nobreak)</a>
<a name="ln933">              continue;</a>
<a name="ln934">          }</a>
<a name="ln935"> </a>
<a name="ln936">          find_word(mip, FIND_COMPOUND);</a>
<a name="ln937"> </a>
<a name="ln938">          // When NOBREAK any word that matches is OK.  Otherwise we</a>
<a name="ln939">          // need to find the longest match, thus try with keep-case</a>
<a name="ln940">          // and prefix too.</a>
<a name="ln941">          if (!slang-&gt;sl_nobreak || mip-&gt;mi_result == SP_BAD) {</a>
<a name="ln942">            // Find following word in keep-case tree.</a>
<a name="ln943">            mip-&gt;mi_compoff = wlen;</a>
<a name="ln944">            find_word(mip, FIND_KEEPCOMPOUND);</a>
<a name="ln945"> </a>
<a name="ln946">#if 0       // Disabled, a prefix must not appear halfway through a compound</a>
<a name="ln947">            // word, unless the COMPOUNDPERMITFLAG is used, in which case it</a>
<a name="ln948">            // can't be a postponed prefix.</a>
<a name="ln949">            if (!slang-&gt;sl_nobreak || mip-&gt;mi_result == SP_BAD) {</a>
<a name="ln950">              // Check for following word with prefix.</a>
<a name="ln951">              mip-&gt;mi_compoff = c;</a>
<a name="ln952">              find_prefix(mip, FIND_COMPOUND);</a>
<a name="ln953">            }</a>
<a name="ln954">#endif</a>
<a name="ln955">          }</a>
<a name="ln956"> </a>
<a name="ln957">          if (!slang-&gt;sl_nobreak)</a>
<a name="ln958">            break;</a>
<a name="ln959">        }</a>
<a name="ln960">        --mip-&gt;mi_complen;</a>
<a name="ln961">        if (flags &amp; WF_COMPROOT)</a>
<a name="ln962">          --mip-&gt;mi_compextra;</a>
<a name="ln963">        mip-&gt;mi_lp = save_lp;</a>
<a name="ln964"> </a>
<a name="ln965">        if (slang-&gt;sl_nobreak) {</a>
<a name="ln966">          nobreak_result = mip-&gt;mi_result;</a>
<a name="ln967">          mip-&gt;mi_result = save_result;</a>
<a name="ln968">          mip-&gt;mi_end = save_end;</a>
<a name="ln969">        } else {</a>
<a name="ln970">          if (mip-&gt;mi_result == SP_OK)</a>
<a name="ln971">            break;</a>
<a name="ln972">          continue;</a>
<a name="ln973">        }</a>
<a name="ln974">      }</a>
<a name="ln975"> </a>
<a name="ln976">      int res = SP_BAD;</a>
<a name="ln977">      if (flags &amp; WF_BANNED)</a>
<a name="ln978">        res = SP_BANNED;</a>
<a name="ln979">      else if (flags &amp; WF_REGION) {</a>
<a name="ln980">        // Check region.</a>
<a name="ln981">        if ((mip-&gt;mi_lp-&gt;lp_region &amp; (flags &gt;&gt; 16)) != 0)</a>
<a name="ln982">          res = SP_OK;</a>
<a name="ln983">        else</a>
<a name="ln984">          res = SP_LOCAL;</a>
<a name="ln985">      } else if (flags &amp; WF_RARE)</a>
<a name="ln986">        res = SP_RARE;</a>
<a name="ln987">      else</a>
<a name="ln988">        res = SP_OK;</a>
<a name="ln989"> </a>
<a name="ln990">      // Always use the longest match and the best result.  For NOBREAK</a>
<a name="ln991">      // we separately keep the longest match without a following good</a>
<a name="ln992">      // word as a fall-back.</a>
<a name="ln993">      if (nobreak_result == SP_BAD) {</a>
<a name="ln994">        if (mip-&gt;mi_result2 &gt; res) {</a>
<a name="ln995">          mip-&gt;mi_result2 = res;</a>
<a name="ln996">          mip-&gt;mi_end2 = mip-&gt;mi_word + wlen;</a>
<a name="ln997">        } else if (mip-&gt;mi_result2 == res</a>
<a name="ln998">                   &amp;&amp; mip-&gt;mi_end2 &lt; mip-&gt;mi_word + wlen)</a>
<a name="ln999">          mip-&gt;mi_end2 = mip-&gt;mi_word + wlen;</a>
<a name="ln1000">      } else if (mip-&gt;mi_result &gt; res) {</a>
<a name="ln1001">        mip-&gt;mi_result = res;</a>
<a name="ln1002">        mip-&gt;mi_end = mip-&gt;mi_word + wlen;</a>
<a name="ln1003">      } else if (mip-&gt;mi_result == res &amp;&amp; mip-&gt;mi_end &lt; mip-&gt;mi_word + wlen)</a>
<a name="ln1004">        mip-&gt;mi_end = mip-&gt;mi_word + wlen;</a>
<a name="ln1005"> </a>
<a name="ln1006">      if (mip-&gt;mi_result == SP_OK)</a>
<a name="ln1007">        break;</a>
<a name="ln1008">    }</a>
<a name="ln1009"> </a>
<a name="ln1010">    if (mip-&gt;mi_result == SP_OK)</a>
<a name="ln1011">      break;</a>
<a name="ln1012">  }</a>
<a name="ln1013">}</a>
<a name="ln1014"> </a>
<a name="ln1015">// Returns true if there is a match between the word ptr[wlen] and</a>
<a name="ln1016">// CHECKCOMPOUNDPATTERN rules, assuming that we will concatenate with another</a>
<a name="ln1017">// word.</a>
<a name="ln1018">// A match means that the first part of CHECKCOMPOUNDPATTERN matches at the</a>
<a name="ln1019">// end of ptr[wlen] and the second part matches after it.</a>
<a name="ln1020">static bool</a>
<a name="ln1021">match_checkcompoundpattern (</a>
<a name="ln1022">    char_u *ptr,</a>
<a name="ln1023">    int wlen,</a>
<a name="ln1024">    garray_T *gap      // &amp;sl_comppat</a>
<a name="ln1025">)</a>
<a name="ln1026">{</a>
<a name="ln1027">  char_u      *p;</a>
<a name="ln1028">  int len;</a>
<a name="ln1029"> </a>
<a name="ln1030">  for (int i = 0; i + 1 &lt; gap-&gt;ga_len; i += 2) {</a>
<a name="ln1031">    p = ((char_u **)gap-&gt;ga_data)[i + 1];</a>
<a name="ln1032">    if (STRNCMP(ptr + wlen, p, STRLEN(p)) == 0) {</a>
<a name="ln1033">      // Second part matches at start of following compound word, now</a>
<a name="ln1034">      // check if first part matches at end of previous word.</a>
<a name="ln1035">      p = ((char_u **)gap-&gt;ga_data)[i];</a>
<a name="ln1036">      len = (int)STRLEN(p);</a>
<a name="ln1037">      if (len &lt;= wlen &amp;&amp; STRNCMP(ptr + wlen - len, p, len) == 0)</a>
<a name="ln1038">        return true;</a>
<a name="ln1039">    }</a>
<a name="ln1040">  }</a>
<a name="ln1041">  return false;</a>
<a name="ln1042">}</a>
<a name="ln1043"> </a>
<a name="ln1044">// Returns true if &quot;flags&quot; is a valid sequence of compound flags and &quot;word&quot;</a>
<a name="ln1045">// does not have too many syllables.</a>
<a name="ln1046">static bool can_compound(slang_T *slang, const char_u *word,</a>
<a name="ln1047">                         const char_u *flags)</a>
<a name="ln1048">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1049">{</a>
<a name="ln1050">  char_u uflags[MAXWLEN * 2] = { 0 };</a>
<a name="ln1051"> </a>
<a name="ln1052">  if (slang-&gt;sl_compprog == NULL) {</a>
<a name="ln1053">    return false;</a>
<a name="ln1054">  }</a>
<a name="ln1055">  // Need to convert the single byte flags to utf8 characters.</a>
<a name="ln1056">  char_u *p = uflags;</a>
<a name="ln1057">  for (int i = 0; flags[i] != NUL; i++) {</a>
<a name="ln1058">    p += utf_char2bytes(flags[i], p);</a>
<a name="ln1059">  }</a>
<a name="ln1060">  *p = NUL;</a>
<a name="ln1061">  p = uflags;</a>
<a name="ln1062">  if (!vim_regexec_prog(&amp;slang-&gt;sl_compprog, false, p, 0)) {</a>
<a name="ln1063">    return false;</a>
<a name="ln1064">  }</a>
<a name="ln1065"> </a>
<a name="ln1066">  // Count the number of syllables.  This may be slow, do it last.  If there</a>
<a name="ln1067">  // are too many syllables AND the number of compound words is above</a>
<a name="ln1068">  // COMPOUNDWORDMAX then compounding is not allowed.</a>
<a name="ln1069">  if (slang-&gt;sl_compsylmax &lt; MAXWLEN</a>
<a name="ln1070">      &amp;&amp; count_syllables(slang, word) &gt; slang-&gt;sl_compsylmax)</a>
<a name="ln1071">    return (int)STRLEN(flags) &lt; slang-&gt;sl_compmax;</a>
<a name="ln1072">  return true;</a>
<a name="ln1073">}</a>
<a name="ln1074"> </a>
<a name="ln1075">// Returns true when the sequence of flags in &quot;compflags&quot; plus &quot;flag&quot; can</a>
<a name="ln1076">// possibly form a valid compounded word.  This also checks the COMPOUNDRULE</a>
<a name="ln1077">// lines if they don't contain wildcards.</a>
<a name="ln1078">static bool can_be_compound(trystate_T *sp, slang_T *slang, char_u *compflags, int flag)</a>
<a name="ln1079">{</a>
<a name="ln1080">  // If the flag doesn't appear in sl_compstartflags or sl_compallflags</a>
<a name="ln1081">  // then it can't possibly compound.</a>
<a name="ln1082">  if (!byte_in_str(sp-&gt;ts_complen == sp-&gt;ts_compsplit</a>
<a name="ln1083">          ? slang-&gt;sl_compstartflags : slang-&gt;sl_compallflags, flag))</a>
<a name="ln1084">    return false;</a>
<a name="ln1085"> </a>
<a name="ln1086">  // If there are no wildcards, we can check if the flags collected so far</a>
<a name="ln1087">  // possibly can form a match with COMPOUNDRULE patterns.  This only</a>
<a name="ln1088">  // makes sense when we have two or more words.</a>
<a name="ln1089">  if (slang-&gt;sl_comprules != NULL &amp;&amp; sp-&gt;ts_complen &gt; sp-&gt;ts_compsplit) {</a>
<a name="ln1090">    compflags[sp-&gt;ts_complen] = flag;</a>
<a name="ln1091">    compflags[sp-&gt;ts_complen + 1] = NUL;</a>
<a name="ln1092">    bool v = match_compoundrule(slang, compflags + sp-&gt;ts_compsplit);</a>
<a name="ln1093">    compflags[sp-&gt;ts_complen] = NUL;</a>
<a name="ln1094">    return v;</a>
<a name="ln1095">  }</a>
<a name="ln1096"> </a>
<a name="ln1097">  return true;</a>
<a name="ln1098">}</a>
<a name="ln1099"> </a>
<a name="ln1100">// Returns true if the compound flags in compflags[] match the start of any</a>
<a name="ln1101">// compound rule.  This is used to stop trying a compound if the flags</a>
<a name="ln1102">// collected so far can't possibly match any compound rule.</a>
<a name="ln1103">// Caller must check that slang-&gt;sl_comprules is not NULL.</a>
<a name="ln1104">static bool match_compoundrule(slang_T *slang, char_u *compflags)</a>
<a name="ln1105">{</a>
<a name="ln1106">  char_u      *p;</a>
<a name="ln1107">  int i;</a>
<a name="ln1108">  int c;</a>
<a name="ln1109"> </a>
<a name="ln1110">  // loop over all the COMPOUNDRULE entries</a>
<a name="ln1111">  for (p = slang-&gt;sl_comprules; *p != NUL; ++p) {</a>
<a name="ln1112">    // loop over the flags in the compound word we have made, match</a>
<a name="ln1113">    // them against the current rule entry</a>
<a name="ln1114">    for (i = 0;; ++i) {</a>
<a name="ln1115">      c = compflags[i];</a>
<a name="ln1116">      if (c == NUL)</a>
<a name="ln1117">        // found a rule that matches for the flags we have so far</a>
<a name="ln1118">        return true;</a>
<a name="ln1119">      if (*p == '/' || *p == NUL)</a>
<a name="ln1120">        break;          // end of rule, it's too short</a>
<a name="ln1121">      if (*p == '[') {</a>
<a name="ln1122">        bool match = false;</a>
<a name="ln1123"> </a>
<a name="ln1124">        // compare against all the flags in []</a>
<a name="ln1125">        ++p;</a>
<a name="ln1126">        while (*p != ']' &amp;&amp; *p != NUL)</a>
<a name="ln1127">          if (*p++ == c)</a>
<a name="ln1128">            match = true;</a>
<a name="ln1129">        if (!match)</a>
<a name="ln1130">          break;            // none matches</a>
<a name="ln1131">      } else if (*p != c)</a>
<a name="ln1132">        break;          // flag of word doesn't match flag in pattern</a>
<a name="ln1133">      ++p;</a>
<a name="ln1134">    }</a>
<a name="ln1135"> </a>
<a name="ln1136">    // Skip to the next &quot;/&quot;, where the next pattern starts.</a>
<a name="ln1137">    p = vim_strchr(p, '/');</a>
<a name="ln1138">    if (p == NULL)</a>
<a name="ln1139">      break;</a>
<a name="ln1140">  }</a>
<a name="ln1141"> </a>
<a name="ln1142">  // Checked all the rules and none of them match the flags, so there</a>
<a name="ln1143">  // can't possibly be a compound starting with these flags.</a>
<a name="ln1144">  return false;</a>
<a name="ln1145">}</a>
<a name="ln1146"> </a>
<a name="ln1147">// Return non-zero if the prefix indicated by &quot;arridx&quot; matches with the prefix</a>
<a name="ln1148">// ID in &quot;flags&quot; for the word &quot;word&quot;.</a>
<a name="ln1149">// The WF_RAREPFX flag is included in the return value for a rare prefix.</a>
<a name="ln1150">static int</a>
<a name="ln1151">valid_word_prefix (</a>
<a name="ln1152">    int totprefcnt,                 // nr of prefix IDs</a>
<a name="ln1153">    int arridx,                     // idx in sl_pidxs[]</a>
<a name="ln1154">    int flags,</a>
<a name="ln1155">    char_u *word,</a>
<a name="ln1156">    slang_T *slang,</a>
<a name="ln1157">    bool cond_req                   // only use prefixes with a condition</a>
<a name="ln1158">)</a>
<a name="ln1159">{</a>
<a name="ln1160">  int prefcnt;</a>
<a name="ln1161">  int pidx;</a>
<a name="ln1162">  int prefid;</a>
<a name="ln1163"> </a>
<a name="ln1164">  prefid = (unsigned)flags &gt;&gt; 24;</a>
<a name="ln1165">  for (prefcnt = totprefcnt - 1; prefcnt &gt;= 0; --prefcnt) {</a>
<a name="ln1166">    pidx = slang-&gt;sl_pidxs[arridx + prefcnt];</a>
<a name="ln1167"> </a>
<a name="ln1168">    // Check the prefix ID.</a>
<a name="ln1169">    if (prefid != (pidx &amp; 0xff))</a>
<a name="ln1170">      continue;</a>
<a name="ln1171"> </a>
<a name="ln1172">    // Check if the prefix doesn't combine and the word already has a</a>
<a name="ln1173">    // suffix.</a>
<a name="ln1174">    if ((flags &amp; WF_HAS_AFF) &amp;&amp; (pidx &amp; WF_PFX_NC))</a>
<a name="ln1175">      continue;</a>
<a name="ln1176"> </a>
<a name="ln1177">    // Check the condition, if there is one.  The condition index is</a>
<a name="ln1178">    // stored in the two bytes above the prefix ID byte.</a>
<a name="ln1179">    regprog_T **rp = &amp;slang-&gt;sl_prefprog[((unsigned)pidx &gt;&gt; 8) &amp; 0xffff];</a>
<a name="ln1180">    if (*rp != NULL) {</a>
<a name="ln1181">      if (!vim_regexec_prog(rp, false, word, 0)) {</a>
<a name="ln1182">        continue;</a>
<a name="ln1183">      }</a>
<a name="ln1184">    } else if (cond_req)</a>
<a name="ln1185">      continue;</a>
<a name="ln1186"> </a>
<a name="ln1187">    // It's a match!  Return the WF_ flags.</a>
<a name="ln1188">    return pidx;</a>
<a name="ln1189">  }</a>
<a name="ln1190">  return 0;</a>
<a name="ln1191">}</a>
<a name="ln1192"> </a>
<a name="ln1193">// Check if the word at &quot;mip-&gt;mi_word&quot; has a matching prefix.</a>
<a name="ln1194">// If it does, then check the following word.</a>
<a name="ln1195">//</a>
<a name="ln1196">// If &quot;mode&quot; is &quot;FIND_COMPOUND&quot; then do the same after another word, find a</a>
<a name="ln1197">// prefix in a compound word.</a>
<a name="ln1198">//</a>
<a name="ln1199">// For a match mip-&gt;mi_result is updated.</a>
<a name="ln1200">static void find_prefix(matchinf_T *mip, int mode)</a>
<a name="ln1201">{</a>
<a name="ln1202">  idx_T arridx = 0;</a>
<a name="ln1203">  int len;</a>
<a name="ln1204">  int wlen = 0;</a>
<a name="ln1205">  int flen;</a>
<a name="ln1206">  int c;</a>
<a name="ln1207">  char_u      *ptr;</a>
<a name="ln1208">  idx_T lo, hi, m;</a>
<a name="ln1209">  slang_T     *slang = mip-&gt;mi_lp-&gt;lp_slang;</a>
<a name="ln1210">  char_u      *byts;</a>
<a name="ln1211">  idx_T       *idxs;</a>
<a name="ln1212"> </a>
<a name="ln1213">  byts = slang-&gt;sl_pbyts;</a>
<a name="ln1214">  if (byts == NULL)</a>
<a name="ln1215">    return;                     // array is empty</a>
<a name="ln1216"> </a>
<a name="ln1217">  // We use the case-folded word here, since prefixes are always</a>
<a name="ln1218">  // case-folded.</a>
<a name="ln1219">  ptr = mip-&gt;mi_fword;</a>
<a name="ln1220">  flen = mip-&gt;mi_fwordlen;      // available case-folded bytes</a>
<a name="ln1221">  if (mode == FIND_COMPOUND) {</a>
<a name="ln1222">    // Skip over the previously found word(s).</a>
<a name="ln1223">    ptr += mip-&gt;mi_compoff;</a>
<a name="ln1224">    flen -= mip-&gt;mi_compoff;</a>
<a name="ln1225">  }</a>
<a name="ln1226">  idxs = slang-&gt;sl_pidxs;</a>
<a name="ln1227"> </a>
<a name="ln1228">  // Repeat advancing in the tree until:</a>
<a name="ln1229">  // - there is a byte that doesn't match,</a>
<a name="ln1230">  // - we reach the end of the tree,</a>
<a name="ln1231">  // - or we reach the end of the line.</a>
<a name="ln1232">  for (;; ) {</a>
<a name="ln1233">    if (flen == 0 &amp;&amp; *mip-&gt;mi_fend != NUL)</a>
<a name="ln1234">      flen = fold_more(mip);</a>
<a name="ln1235"> </a>
<a name="ln1236">    len = byts[arridx++];</a>
<a name="ln1237"> </a>
<a name="ln1238">    // If the first possible byte is a zero the prefix could end here.</a>
<a name="ln1239">    // Check if the following word matches and supports the prefix.</a>
<a name="ln1240">    if (byts[arridx] == 0) {</a>
<a name="ln1241">      // There can be several prefixes with different conditions.  We</a>
<a name="ln1242">      // try them all, since we don't know which one will give the</a>
<a name="ln1243">      // longest match.  The word is the same each time, pass the list</a>
<a name="ln1244">      // of possible prefixes to find_word().</a>
<a name="ln1245">      mip-&gt;mi_prefarridx = arridx;</a>
<a name="ln1246">      mip-&gt;mi_prefcnt = len;</a>
<a name="ln1247">      while (len &gt; 0 &amp;&amp; byts[arridx] == 0) {</a>
<a name="ln1248">        ++arridx;</a>
<a name="ln1249">        --len;</a>
<a name="ln1250">      }</a>
<a name="ln1251">      mip-&gt;mi_prefcnt -= len;</a>
<a name="ln1252"> </a>
<a name="ln1253">      // Find the word that comes after the prefix.</a>
<a name="ln1254">      mip-&gt;mi_prefixlen = wlen;</a>
<a name="ln1255">      if (mode == FIND_COMPOUND)</a>
<a name="ln1256">        // Skip over the previously found word(s).</a>
<a name="ln1257">        mip-&gt;mi_prefixlen += mip-&gt;mi_compoff;</a>
<a name="ln1258"> </a>
<a name="ln1259">      // Case-folded length may differ from original length.</a>
<a name="ln1260">      mip-&gt;mi_cprefixlen = nofold_len(mip-&gt;mi_fword, mip-&gt;mi_prefixlen,</a>
<a name="ln1261">                                      mip-&gt;mi_word);</a>
<a name="ln1262">      find_word(mip, FIND_PREFIX);</a>
<a name="ln1263"> </a>
<a name="ln1264"> </a>
<a name="ln1265">      if (len == 0)</a>
<a name="ln1266">        break;              // no children, word must end here</a>
<a name="ln1267">    }</a>
<a name="ln1268"> </a>
<a name="ln1269">    // Stop looking at end of the line.</a>
<a name="ln1270">    if (ptr[wlen] == NUL)</a>
<a name="ln1271">      break;</a>
<a name="ln1272"> </a>
<a name="ln1273">    // Perform a binary search in the list of accepted bytes.</a>
<a name="ln1274">    c = ptr[wlen];</a>
<a name="ln1275">    lo = arridx;</a>
<a name="ln1276">    hi = arridx + len - 1;</a>
<a name="ln1277">    while (lo &lt; hi) {</a>
<a name="ln1278">      m = (lo + hi) / 2;</a>
<a name="ln1279">      if (byts[m] &gt; c)</a>
<a name="ln1280">        hi = m - 1;</a>
<a name="ln1281">      else if (byts[m] &lt; c)</a>
<a name="ln1282">        lo = m + 1;</a>
<a name="ln1283">      else {</a>
<a name="ln1284">        lo = hi = m;</a>
<a name="ln1285">        break;</a>
<a name="ln1286">      }</a>
<a name="ln1287">    }</a>
<a name="ln1288"> </a>
<a name="ln1289">    // Stop if there is no matching byte.</a>
<a name="ln1290">    if (hi &lt; lo || byts[lo] != c)</a>
<a name="ln1291">      break;</a>
<a name="ln1292"> </a>
<a name="ln1293">    // Continue at the child (if there is one).</a>
<a name="ln1294">    arridx = idxs[lo];</a>
<a name="ln1295">    ++wlen;</a>
<a name="ln1296">    --flen;</a>
<a name="ln1297">  }</a>
<a name="ln1298">}</a>
<a name="ln1299"> </a>
<a name="ln1300">// Need to fold at least one more character.  Do until next non-word character</a>
<a name="ln1301">// for efficiency.  Include the non-word character too.</a>
<a name="ln1302">// Return the length of the folded chars in bytes.</a>
<a name="ln1303">static int fold_more(matchinf_T *mip)</a>
<a name="ln1304">{</a>
<a name="ln1305">  int flen;</a>
<a name="ln1306">  char_u      *p;</a>
<a name="ln1307"> </a>
<a name="ln1308">  p = mip-&gt;mi_fend;</a>
<a name="ln1309">  do {</a>
<a name="ln1310">    MB_PTR_ADV(mip-&gt;mi_fend);</a>
<a name="ln1311">  } while (*mip-&gt;mi_fend != NUL &amp;&amp; spell_iswordp(mip-&gt;mi_fend, mip-&gt;mi_win));</a>
<a name="ln1312"> </a>
<a name="ln1313">  // Include the non-word character so that we can check for the word end.</a>
<a name="ln1314">  if (*mip-&gt;mi_fend != NUL) {</a>
<a name="ln1315">    MB_PTR_ADV(mip-&gt;mi_fend);</a>
<a name="ln1316">  }</a>
<a name="ln1317"> </a>
<a name="ln1318">  (void)spell_casefold(p, (int)(mip-&gt;mi_fend - p),</a>
<a name="ln1319">      mip-&gt;mi_fword + mip-&gt;mi_fwordlen,</a>
<a name="ln1320">      MAXWLEN - mip-&gt;mi_fwordlen);</a>
<a name="ln1321">  flen = (int)STRLEN(mip-&gt;mi_fword + mip-&gt;mi_fwordlen);</a>
<a name="ln1322">  mip-&gt;mi_fwordlen += flen;</a>
<a name="ln1323">  return flen;</a>
<a name="ln1324">}</a>
<a name="ln1325"> </a>
<a name="ln1326">/// Checks case flags for a word. Returns true, if the word has the requested</a>
<a name="ln1327">/// case.</a>
<a name="ln1328">///</a>
<a name="ln1329">/// @param wordflags Flags for the checked word.</a>
<a name="ln1330">/// @param treeflags Flags for the word in the spell tree.</a>
<a name="ln1331">static bool spell_valid_case(int wordflags, int treeflags)</a>
<a name="ln1332">{</a>
<a name="ln1333">  return (wordflags == WF_ALLCAP &amp;&amp; (treeflags &amp; WF_FIXCAP) == 0)</a>
<a name="ln1334">         || ((treeflags &amp; (WF_ALLCAP | WF_KEEPCAP)) == 0</a>
<a name="ln1335">             &amp;&amp; ((treeflags &amp; WF_ONECAP) == 0</a>
<a name="ln1336">                 || (wordflags &amp; WF_ONECAP) != 0));</a>
<a name="ln1337">}</a>
<a name="ln1338"> </a>
<a name="ln1339">// Returns true if spell checking is not enabled.</a>
<a name="ln1340">static bool no_spell_checking(win_T *wp)</a>
<a name="ln1341">{</a>
<a name="ln1342">  if (!wp-&gt;w_p_spell || *wp-&gt;w_s-&gt;b_p_spl == NUL</a>
<a name="ln1343">      || GA_EMPTY(&amp;wp-&gt;w_s-&gt;b_langp)) {</a>
<a name="ln1344">    EMSG(_(&quot;E756: Spell checking is not enabled&quot;));</a>
<a name="ln1345">    return true;</a>
<a name="ln1346">  }</a>
<a name="ln1347">  return false;</a>
<a name="ln1348">}</a>
<a name="ln1349"> </a>
<a name="ln1350">// Moves to the next spell error.</a>
<a name="ln1351">// &quot;curline&quot; is false for &quot;[s&quot;, &quot;]s&quot;, &quot;[S&quot; and &quot;]S&quot;.</a>
<a name="ln1352">// &quot;curline&quot; is true to find word under/after cursor in the same line.</a>
<a name="ln1353">// For Insert mode completion &quot;dir&quot; is BACKWARD and &quot;curline&quot; is true: move</a>
<a name="ln1354">// to after badly spelled word before the cursor.</a>
<a name="ln1355">// Return 0 if not found, length of the badly spelled word otherwise.</a>
<a name="ln1356">size_t</a>
<a name="ln1357">spell_move_to (</a>
<a name="ln1358">    win_T *wp,</a>
<a name="ln1359">    int dir,                  // FORWARD or BACKWARD</a>
<a name="ln1360">    bool allwords,            // true for &quot;[s&quot;/&quot;]s&quot;, false for &quot;[S&quot;/&quot;]S&quot;</a>
<a name="ln1361">    bool curline,</a>
<a name="ln1362">    hlf_T *attrp              // return: attributes of bad word or NULL</a>
<a name="ln1363">                              // (only when &quot;dir&quot; is FORWARD)</a>
<a name="ln1364">)</a>
<a name="ln1365">{</a>
<a name="ln1366">  linenr_T lnum;</a>
<a name="ln1367">  pos_T found_pos;</a>
<a name="ln1368">  size_t found_len = 0;</a>
<a name="ln1369">  char_u      *line;</a>
<a name="ln1370">  char_u      *p;</a>
<a name="ln1371">  char_u      *endp;</a>
<a name="ln1372">  hlf_T attr = HLF_COUNT;</a>
<a name="ln1373">  size_t len;</a>
<a name="ln1374">  int has_syntax = syntax_present(wp);</a>
<a name="ln1375">  int col;</a>
<a name="ln1376">  bool can_spell;</a>
<a name="ln1377">  char_u      *buf = NULL;</a>
<a name="ln1378">  size_t buflen = 0;</a>
<a name="ln1379">  int skip = 0;</a>
<a name="ln1380">  int capcol = -1;</a>
<a name="ln1381">  bool found_one = false;</a>
<a name="ln1382">  bool wrapped = false;</a>
<a name="ln1383"> </a>
<a name="ln1384">  if (no_spell_checking(wp))</a>
<a name="ln1385">    return 0;</a>
<a name="ln1386"> </a>
<a name="ln1387">  // Start looking for bad word at the start of the line, because we can't</a>
<a name="ln1388">  // start halfway through a word, we don't know where it starts or ends.</a>
<a name="ln1389">  //</a>
<a name="ln1390">  // When searching backwards, we continue in the line to find the last</a>
<a name="ln1391">  // bad word (in the cursor line: before the cursor).</a>
<a name="ln1392">  //</a>
<a name="ln1393">  // We concatenate the start of the next line, so that wrapped words work</a>
<a name="ln1394">  // (e.g. &quot;et&lt;line-break&gt;cetera&quot;).  Doesn't work when searching backwards</a>
<a name="ln1395">  // though...</a>
<a name="ln1396">  lnum = wp-&gt;w_cursor.lnum;</a>
<a name="ln1397">  clearpos(&amp;found_pos);</a>
<a name="ln1398"> </a>
<a name="ln1399">  while (!got_int) {</a>
<a name="ln1400">    line = ml_get_buf(wp-&gt;w_buffer, lnum, FALSE);</a>
<a name="ln1401"> </a>
<a name="ln1402">    len = STRLEN(line);</a>
<a name="ln1403">    if (buflen &lt; len + MAXWLEN + 2) {</a>
<a name="ln1404">      xfree(buf);</a>
<a name="ln1405">      buflen = len + MAXWLEN + 2;</a>
<a name="ln1406">      buf = xmalloc(buflen);</a>
<a name="ln1407">    }</a>
<a name="ln1408">    assert(buf &amp;&amp; buflen &gt;= len + MAXWLEN + 2);</a>
<a name="ln1409"> </a>
<a name="ln1410">    // In first line check first word for Capital.</a>
<a name="ln1411">    if (lnum == 1)</a>
<a name="ln1412">      capcol = 0;</a>
<a name="ln1413"> </a>
<a name="ln1414">    // For checking first word with a capital skip white space.</a>
<a name="ln1415">    if (capcol == 0) {</a>
<a name="ln1416">      capcol = (int)getwhitecols(line);</a>
<a name="ln1417">    } else if (curline &amp;&amp; wp == curwin) {</a>
<a name="ln1418">      // For spellbadword(): check if first word needs a capital.</a>
<a name="ln1419">      col = (int)getwhitecols(line);</a>
<a name="ln1420">      if (check_need_cap(lnum, col)) {</a>
<a name="ln1421">        capcol = col;</a>
<a name="ln1422">      }</a>
<a name="ln1423"> </a>
<a name="ln1424">      // Need to get the line again, may have looked at the previous</a>
<a name="ln1425">      // one.</a>
<a name="ln1426">      line = ml_get_buf(wp-&gt;w_buffer, lnum, FALSE);</a>
<a name="ln1427">    }</a>
<a name="ln1428"> </a>
<a name="ln1429">    // Copy the line into &quot;buf&quot; and append the start of the next line if</a>
<a name="ln1430">    // possible.</a>
<a name="ln1431">    STRCPY(buf, line);</a>
<a name="ln1432">    if (lnum &lt; wp-&gt;w_buffer-&gt;b_ml.ml_line_count)</a>
<a name="ln1433">      spell_cat_line(buf + STRLEN(buf),</a>
<a name="ln1434">                     ml_get_buf(wp-&gt;w_buffer, lnum + 1, FALSE),</a>
<a name="ln1435">                     MAXWLEN);</a>
<a name="ln1436">    p = buf + skip;</a>
<a name="ln1437">    endp = buf + len;</a>
<a name="ln1438">    while (p &lt; endp) {</a>
<a name="ln1439">      // When searching backward don't search after the cursor.  Unless</a>
<a name="ln1440">      // we wrapped around the end of the buffer.</a>
<a name="ln1441">      if (dir == BACKWARD</a>
<a name="ln1442">          &amp;&amp; lnum == wp-&gt;w_cursor.lnum</a>
<a name="ln1443">          &amp;&amp; !wrapped</a>
<a name="ln1444">          &amp;&amp; (colnr_T)(p - buf) &gt;= wp-&gt;w_cursor.col)</a>
<a name="ln1445">        break;</a>
<a name="ln1446"> </a>
<a name="ln1447">      // start of word</a>
<a name="ln1448">      attr = HLF_COUNT;</a>
<a name="ln1449">      len = spell_check(wp, p, &amp;attr, &amp;capcol, false);</a>
<a name="ln1450"> </a>
<a name="ln1451">      if (attr != HLF_COUNT) {</a>
<a name="ln1452">        // We found a bad word.  Check the attribute.</a>
<a name="ln1453">        if (allwords || attr == HLF_SPB) {</a>
<a name="ln1454">          // When searching forward only accept a bad word after</a>
<a name="ln1455">          // the cursor.</a>
<a name="ln1456">          if (dir == BACKWARD</a>
<a name="ln1457">              || lnum != wp-&gt;w_cursor.lnum</a>
<a name="ln1458">              || wrapped</a>
<a name="ln1459">              || ((colnr_T)(curline</a>
<a name="ln1460">                            ? p - buf + (ptrdiff_t)len</a>
<a name="ln1461">                            : p - buf) &gt; wp-&gt;w_cursor.col)) {</a>
<a name="ln1462">            if (has_syntax) {</a>
<a name="ln1463">              col = (int)(p - buf);</a>
<a name="ln1464">              (void)syn_get_id(wp, lnum, (colnr_T)col,</a>
<a name="ln1465">                  FALSE, &amp;can_spell, FALSE);</a>
<a name="ln1466">              if (!can_spell)</a>
<a name="ln1467">                attr = HLF_COUNT;</a>
<a name="ln1468">            } else</a>
<a name="ln1469">              can_spell = true;</a>
<a name="ln1470"> </a>
<a name="ln1471">            if (can_spell) {</a>
<a name="ln1472">              found_one = true;</a>
<a name="ln1473">              found_pos.lnum = lnum;</a>
<a name="ln1474">              found_pos.col = (int)(p - buf);</a>
<a name="ln1475">              found_pos.coladd = 0;</a>
<a name="ln1476">              if (dir == FORWARD) {</a>
<a name="ln1477">                // No need to search further.</a>
<a name="ln1478">                wp-&gt;w_cursor = found_pos;</a>
<a name="ln1479">                xfree(buf);</a>
<a name="ln1480">                if (attrp != NULL)</a>
<a name="ln1481">                  *attrp = attr;</a>
<a name="ln1482">                return len;</a>
<a name="ln1483">              } else if (curline) {</a>
<a name="ln1484">                // Insert mode completion: put cursor after</a>
<a name="ln1485">                // the bad word.</a>
<a name="ln1486">                assert(len &lt;= INT_MAX);</a>
<a name="ln1487">                found_pos.col += (int)len;</a>
<a name="ln1488">              }</a>
<a name="ln1489">              found_len = len;</a>
<a name="ln1490">            }</a>
<a name="ln1491">          } else</a>
<a name="ln1492">            found_one = true;</a>
<a name="ln1493">        }</a>
<a name="ln1494">      }</a>
<a name="ln1495"> </a>
<a name="ln1496">      // advance to character after the word</a>
<a name="ln1497">      p += len;</a>
<a name="ln1498">      assert(len &lt;= INT_MAX);</a>
<a name="ln1499">      capcol -= (int)len;</a>
<a name="ln1500">    }</a>
<a name="ln1501"> </a>
<a name="ln1502">    if (dir == BACKWARD &amp;&amp; found_pos.lnum != 0) {</a>
<a name="ln1503">      // Use the last match in the line (before the cursor).</a>
<a name="ln1504">      wp-&gt;w_cursor = found_pos;</a>
<a name="ln1505">      xfree(buf);</a>
<a name="ln1506">      return found_len;</a>
<a name="ln1507">    }</a>
<a name="ln1508"> </a>
<a name="ln1509">    if (curline) {</a>
<a name="ln1510">      break;            // only check cursor line</a>
<a name="ln1511">    }</a>
<a name="ln1512"> </a>
<a name="ln1513">    // If we are back at the starting line and searched it again there</a>
<a name="ln1514">    // is no match, give up.</a>
<a name="ln1515">    if (lnum == wp-&gt;w_cursor.lnum &amp;&amp; wrapped) {</a>
<a name="ln1516">      break;</a>
<a name="ln1517">    }</a>
<a name="ln1518"> </a>
<a name="ln1519">    // Advance to next line.</a>
<a name="ln1520">    if (dir == BACKWARD) {</a>
<a name="ln1521">      if (lnum &gt; 1) {</a>
<a name="ln1522">        lnum--;</a>
<a name="ln1523">      } else if (!p_ws) {</a>
<a name="ln1524">        break;              // at first line and 'nowrapscan'</a>
<a name="ln1525">      } else {</a>
<a name="ln1526">        // Wrap around to the end of the buffer.  May search the</a>
<a name="ln1527">        // starting line again and accept the last match.</a>
<a name="ln1528">        lnum = wp-&gt;w_buffer-&gt;b_ml.ml_line_count;</a>
<a name="ln1529">        wrapped = true;</a>
<a name="ln1530">        if (!shortmess(SHM_SEARCH))</a>
<a name="ln1531">          give_warning((char_u *)_(top_bot_msg), true);</a>
<a name="ln1532">      }</a>
<a name="ln1533">      capcol = -1;</a>
<a name="ln1534">    } else {</a>
<a name="ln1535">      if (lnum &lt; wp-&gt;w_buffer-&gt;b_ml.ml_line_count)</a>
<a name="ln1536">        ++lnum;</a>
<a name="ln1537">      else if (!p_ws)</a>
<a name="ln1538">        break;              // at first line and 'nowrapscan'</a>
<a name="ln1539">      else {</a>
<a name="ln1540">        // Wrap around to the start of the buffer.  May search the</a>
<a name="ln1541">        // starting line again and accept the first match.</a>
<a name="ln1542">        lnum = 1;</a>
<a name="ln1543">        wrapped = true;</a>
<a name="ln1544">        if (!shortmess(SHM_SEARCH))</a>
<a name="ln1545">          give_warning((char_u *)_(bot_top_msg), true);</a>
<a name="ln1546">      }</a>
<a name="ln1547"> </a>
<a name="ln1548">      // If we are back at the starting line and there is no match then</a>
<a name="ln1549">      // give up.</a>
<a name="ln1550">      if (lnum == wp-&gt;w_cursor.lnum &amp;&amp; !found_one) {</a>
<a name="ln1551">        break;</a>
<a name="ln1552">      }</a>
<a name="ln1553"> </a>
<a name="ln1554">      // Skip the characters at the start of the next line that were</a>
<a name="ln1555">      // included in a match crossing line boundaries.</a>
<a name="ln1556">      if (attr == HLF_COUNT)</a>
<a name="ln1557">        skip = (int)(p - endp);</a>
<a name="ln1558">      else</a>
<a name="ln1559">        skip = 0;</a>
<a name="ln1560"> </a>
<a name="ln1561">      // Capcol skips over the inserted space.</a>
<a name="ln1562">      --capcol;</a>
<a name="ln1563"> </a>
<a name="ln1564">      // But after empty line check first word in next line</a>
<a name="ln1565">      if (*skipwhite(line) == NUL)</a>
<a name="ln1566">        capcol = 0;</a>
<a name="ln1567">    }</a>
<a name="ln1568"> </a>
<a name="ln1569">    line_breakcheck();</a>
<a name="ln1570">  }</a>
<a name="ln1571"> </a>
<a name="ln1572">  xfree(buf);</a>
<a name="ln1573">  return 0;</a>
<a name="ln1574">}</a>
<a name="ln1575"> </a>
<a name="ln1576">// For spell checking: concatenate the start of the following line &quot;line&quot; into</a>
<a name="ln1577">// &quot;buf&quot;, blanking-out special characters.  Copy less then &quot;maxlen&quot; bytes.</a>
<a name="ln1578">// Keep the blanks at the start of the next line, this is used in win_line()</a>
<a name="ln1579">// to skip those bytes if the word was OK.</a>
<a name="ln1580">void spell_cat_line(char_u *buf, char_u *line, int maxlen)</a>
<a name="ln1581">{</a>
<a name="ln1582">  char_u      *p;</a>
<a name="ln1583">  int n;</a>
<a name="ln1584"> </a>
<a name="ln1585">  p = skipwhite(line);</a>
<a name="ln1586">  while (vim_strchr((char_u *)&quot;*#/\&quot;\t&quot;, *p) != NULL)</a>
<a name="ln1587">    p = skipwhite(p + 1);</a>
<a name="ln1588"> </a>
<a name="ln1589">  if (*p != NUL) {</a>
<a name="ln1590">    // Only worth concatenating if there is something else than spaces to</a>
<a name="ln1591">    // concatenate.</a>
<a name="ln1592">    n = (int)(p - line) + 1;</a>
<a name="ln1593">    if (n &lt; maxlen - 1) {</a>
<a name="ln1594">      memset(buf, ' ', n);</a>
<a name="ln1595">      STRLCPY(buf +  n, p, maxlen - n);</a>
<a name="ln1596">    }</a>
<a name="ln1597">  }</a>
<a name="ln1598">}</a>
<a name="ln1599"> </a>
<a name="ln1600">// Load word list(s) for &quot;lang&quot; from Vim spell file(s).</a>
<a name="ln1601">// &quot;lang&quot; must be the language without the region: e.g., &quot;en&quot;.</a>
<a name="ln1602">static void spell_load_lang(char_u *lang)</a>
<a name="ln1603">{</a>
<a name="ln1604">  char_u fname_enc[85];</a>
<a name="ln1605">  int r;</a>
<a name="ln1606">  spelload_T sl;</a>
<a name="ln1607">  int round;</a>
<a name="ln1608"> </a>
<a name="ln1609">  // Copy the language name to pass it to spell_load_cb() as a cookie.</a>
<a name="ln1610">  // It's truncated when an error is detected.</a>
<a name="ln1611">  STRCPY(sl.sl_lang, lang);</a>
<a name="ln1612">  sl.sl_slang = NULL;</a>
<a name="ln1613">  sl.sl_nobreak = false;</a>
<a name="ln1614"> </a>
<a name="ln1615">  // We may retry when no spell file is found for the language, an</a>
<a name="ln1616">  // autocommand may load it then.</a>
<a name="ln1617">  for (round = 1; round &lt;= 2; ++round) {</a>
<a name="ln1618">    // Find the first spell file for &quot;lang&quot; in 'runtimepath' and load it.</a>
<a name="ln1619">    vim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,</a>
<a name="ln1620">                 &quot;spell/%s.%s.spl&quot;, lang, spell_enc());</a>
<a name="ln1621">    r = do_in_runtimepath(fname_enc, 0, spell_load_cb, &amp;sl);</a>
<a name="ln1622"> </a>
<a name="ln1623">    if (r == FAIL &amp;&amp; *sl.sl_lang != NUL) {</a>
<a name="ln1624">      // Try loading the ASCII version.</a>
<a name="ln1625">      vim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,</a>
<a name="ln1626">                   &quot;spell/%s.ascii.spl&quot;, lang);</a>
<a name="ln1627">      r = do_in_runtimepath(fname_enc, 0, spell_load_cb, &amp;sl);</a>
<a name="ln1628"> </a>
<a name="ln1629">      if (r == FAIL &amp;&amp; *sl.sl_lang != NUL &amp;&amp; round == 1</a>
<a name="ln1630">          &amp;&amp; apply_autocmds(EVENT_SPELLFILEMISSING, lang,</a>
<a name="ln1631">              curbuf-&gt;b_fname, FALSE, curbuf))</a>
<a name="ln1632">        continue;</a>
<a name="ln1633">      break;</a>
<a name="ln1634">    }</a>
<a name="ln1635">    break;</a>
<a name="ln1636">  }</a>
<a name="ln1637"> </a>
<a name="ln1638">  if (r == FAIL) {</a>
<a name="ln1639">    if (starting) {</a>
<a name="ln1640">      // Prompt the user at VimEnter if spell files are missing. #3027</a>
<a name="ln1641">      // Plugins aren't loaded yet, so spellfile.vim cannot handle this case.</a>
<a name="ln1642">      char autocmd_buf[512] = { 0 };</a>
<a name="ln1643">      snprintf(autocmd_buf, sizeof(autocmd_buf),</a>
<a name="ln1644">               &quot;autocmd VimEnter * call spellfile#LoadFile('%s')|set spell&quot;,</a>
<a name="ln1645">               lang);</a>
<a name="ln1646">      do_cmdline_cmd(autocmd_buf);</a>
<a name="ln1647">    } else {</a>
<a name="ln1648">      smsg(</a>
<a name="ln1649">        _(&quot;Warning: Cannot find word list \&quot;%s.%s.spl\&quot; or \&quot;%s.ascii.spl\&quot;&quot;),</a>
<a name="ln1650">        lang, spell_enc(), lang);</a>
<a name="ln1651">    }</a>
<a name="ln1652">  } else if (sl.sl_slang != NULL) {</a>
<a name="ln1653">    // At least one file was loaded, now load ALL the additions.</a>
<a name="ln1654">    STRCPY(fname_enc + STRLEN(fname_enc) - 3, &quot;add.spl&quot;);</a>
<a name="ln1655">    do_in_runtimepath(fname_enc, DIP_ALL, spell_load_cb, &amp;sl);</a>
<a name="ln1656">  }</a>
<a name="ln1657">}</a>
<a name="ln1658"> </a>
<a name="ln1659">// Return the encoding used for spell checking: Use 'encoding', except that we</a>
<a name="ln1660">// use &quot;latin1&quot; for &quot;latin9&quot;.  And limit to 60 characters (just in case).</a>
<a name="ln1661">char_u *spell_enc(void)</a>
<a name="ln1662">{</a>
<a name="ln1663"> </a>
<a name="ln1664">  if (STRLEN(p_enc) &lt; 60 &amp;&amp; STRCMP(p_enc, &quot;iso-8859-15&quot;) != 0)</a>
<a name="ln1665">    return p_enc;</a>
<a name="ln1666">  return (char_u *)&quot;latin1&quot;;</a>
<a name="ln1667">}</a>
<a name="ln1668"> </a>
<a name="ln1669">// Get the name of the .spl file for the internal wordlist into</a>
<a name="ln1670">// &quot;fname[MAXPATHL]&quot;.</a>
<a name="ln1671">static void int_wordlist_spl(char_u *fname)</a>
<a name="ln1672">{</a>
<a name="ln1673">  vim_snprintf((char *)fname, MAXPATHL, SPL_FNAME_TMPL,</a>
<a name="ln1674">      int_wordlist, spell_enc());</a>
<a name="ln1675">}</a>
<a name="ln1676"> </a>
<a name="ln1677">// Allocate a new slang_T for language &quot;lang&quot;.  &quot;lang&quot; can be NULL.</a>
<a name="ln1678">// Caller must fill &quot;sl_next&quot;.</a>
<a name="ln1679">slang_T *slang_alloc(char_u *lang)</a>
<a name="ln1680">{</a>
<a name="ln1681">  slang_T *lp = xcalloc(1, sizeof(slang_T));</a>
<a name="ln1682"> </a>
<a name="ln1683">  if (lang != NULL)</a>
<a name="ln1684">    lp-&gt;sl_name = vim_strsave(lang);</a>
<a name="ln1685">  ga_init(&amp;lp-&gt;sl_rep, sizeof(fromto_T), 10);</a>
<a name="ln1686">  ga_init(&amp;lp-&gt;sl_repsal, sizeof(fromto_T), 10);</a>
<a name="ln1687">  lp-&gt;sl_compmax = MAXWLEN;</a>
<a name="ln1688">  lp-&gt;sl_compsylmax = MAXWLEN;</a>
<a name="ln1689">  hash_init(&amp;lp-&gt;sl_wordcount);</a>
<a name="ln1690"> </a>
<a name="ln1691">  return lp;</a>
<a name="ln1692">}</a>
<a name="ln1693"> </a>
<a name="ln1694">// Free the contents of an slang_T and the structure itself.</a>
<a name="ln1695">void slang_free(slang_T *lp)</a>
<a name="ln1696">{</a>
<a name="ln1697">  xfree(lp-&gt;sl_name);</a>
<a name="ln1698">  xfree(lp-&gt;sl_fname);</a>
<a name="ln1699">  slang_clear(lp);</a>
<a name="ln1700">  xfree(lp);</a>
<a name="ln1701">}</a>
<a name="ln1702"> </a>
<a name="ln1703">/// Frees a salitem_T</a>
<a name="ln1704">static void free_salitem(salitem_T *smp) {</a>
<a name="ln1705">  xfree(smp-&gt;sm_lead);</a>
<a name="ln1706">  // Don't free sm_oneof and sm_rules, they point into sm_lead.</a>
<a name="ln1707">  xfree(smp-&gt;sm_to);</a>
<a name="ln1708">  xfree(smp-&gt;sm_lead_w);</a>
<a name="ln1709">  xfree(smp-&gt;sm_oneof_w);</a>
<a name="ln1710">  xfree(smp-&gt;sm_to_w);</a>
<a name="ln1711">}</a>
<a name="ln1712"> </a>
<a name="ln1713">/// Frees a fromto_T</a>
<a name="ln1714">static void free_fromto(fromto_T *ftp) {</a>
<a name="ln1715">  xfree(ftp-&gt;ft_from);</a>
<a name="ln1716">  xfree(ftp-&gt;ft_to);</a>
<a name="ln1717">}</a>
<a name="ln1718"> </a>
<a name="ln1719">// Clear an slang_T so that the file can be reloaded.</a>
<a name="ln1720">void slang_clear(slang_T *lp)</a>
<a name="ln1721">{</a>
<a name="ln1722">  garray_T    *gap;</a>
<a name="ln1723"> </a>
<a name="ln1724">  XFREE_CLEAR(lp-&gt;sl_fbyts);</a>
<a name="ln1725">  XFREE_CLEAR(lp-&gt;sl_kbyts);</a>
<a name="ln1726">  XFREE_CLEAR(lp-&gt;sl_pbyts);</a>
<a name="ln1727"> </a>
<a name="ln1728">  XFREE_CLEAR(lp-&gt;sl_fidxs);</a>
<a name="ln1729">  XFREE_CLEAR(lp-&gt;sl_kidxs);</a>
<a name="ln1730">  XFREE_CLEAR(lp-&gt;sl_pidxs);</a>
<a name="ln1731"> </a>
<a name="ln1732">  GA_DEEP_CLEAR(&amp;lp-&gt;sl_rep, fromto_T, free_fromto);</a>
<a name="ln1733">  GA_DEEP_CLEAR(&amp;lp-&gt;sl_repsal, fromto_T, free_fromto);</a>
<a name="ln1734"> </a>
<a name="ln1735">  gap = &amp;lp-&gt;sl_sal;</a>
<a name="ln1736">  if (lp-&gt;sl_sofo) {</a>
<a name="ln1737">    // &quot;ga_len&quot; is set to 1 without adding an item for latin1</a>
<a name="ln1738">    GA_DEEP_CLEAR_PTR(gap);</a>
<a name="ln1739">  } else {</a>
<a name="ln1740">    // SAL items: free salitem_T items</a>
<a name="ln1741">    GA_DEEP_CLEAR(gap, salitem_T, free_salitem);</a>
<a name="ln1742">  }</a>
<a name="ln1743"> </a>
<a name="ln1744">  for (int i = 0; i &lt; lp-&gt;sl_prefixcnt; ++i) {</a>
<a name="ln1745">    vim_regfree(lp-&gt;sl_prefprog[i]);</a>
<a name="ln1746">  }</a>
<a name="ln1747">  lp-&gt;sl_prefixcnt = 0;</a>
<a name="ln1748">  XFREE_CLEAR(lp-&gt;sl_prefprog);</a>
<a name="ln1749">  XFREE_CLEAR(lp-&gt;sl_info);</a>
<a name="ln1750">  XFREE_CLEAR(lp-&gt;sl_midword);</a>
<a name="ln1751"> </a>
<a name="ln1752">  vim_regfree(lp-&gt;sl_compprog);</a>
<a name="ln1753">  lp-&gt;sl_compprog = NULL;</a>
<a name="ln1754">  XFREE_CLEAR(lp-&gt;sl_comprules);</a>
<a name="ln1755">  XFREE_CLEAR(lp-&gt;sl_compstartflags);</a>
<a name="ln1756">  XFREE_CLEAR(lp-&gt;sl_compallflags);</a>
<a name="ln1757"> </a>
<a name="ln1758">  XFREE_CLEAR(lp-&gt;sl_syllable);</a>
<a name="ln1759">  ga_clear(&amp;lp-&gt;sl_syl_items);</a>
<a name="ln1760"> </a>
<a name="ln1761">  ga_clear_strings(&amp;lp-&gt;sl_comppat);</a>
<a name="ln1762"> </a>
<a name="ln1763">  hash_clear_all(&amp;lp-&gt;sl_wordcount, WC_KEY_OFF);</a>
<a name="ln1764">  hash_init(&amp;lp-&gt;sl_wordcount);</a>
<a name="ln1765"> </a>
<a name="ln1766">  hash_clear_all(&amp;lp-&gt;sl_map_hash, 0);</a>
<a name="ln1767"> </a>
<a name="ln1768">  // Clear info from .sug file.</a>
<a name="ln1769">  slang_clear_sug(lp);</a>
<a name="ln1770"> </a>
<a name="ln1771">  lp-&gt;sl_compmax = MAXWLEN;</a>
<a name="ln1772">  lp-&gt;sl_compminlen = 0;</a>
<a name="ln1773">  lp-&gt;sl_compsylmax = MAXWLEN;</a>
<a name="ln1774">  lp-&gt;sl_regions[0] = NUL;</a>
<a name="ln1775">}</a>
<a name="ln1776"> </a>
<a name="ln1777">// Clear the info from the .sug file in &quot;lp&quot;.</a>
<a name="ln1778">void slang_clear_sug(slang_T *lp)</a>
<a name="ln1779">{</a>
<a name="ln1780">  XFREE_CLEAR(lp-&gt;sl_sbyts);</a>
<a name="ln1781">  XFREE_CLEAR(lp-&gt;sl_sidxs);</a>
<a name="ln1782">  close_spellbuf(lp-&gt;sl_sugbuf);</a>
<a name="ln1783">  lp-&gt;sl_sugbuf = NULL;</a>
<a name="ln1784">  lp-&gt;sl_sugloaded = false;</a>
<a name="ln1785">  lp-&gt;sl_sugtime = 0;</a>
<a name="ln1786">}</a>
<a name="ln1787"> </a>
<a name="ln1788">// Load one spell file and store the info into a slang_T.</a>
<a name="ln1789">// Invoked through do_in_runtimepath().</a>
<a name="ln1790">static void spell_load_cb(char_u *fname, void *cookie)</a>
<a name="ln1791">{</a>
<a name="ln1792">  spelload_T  *slp = (spelload_T *)cookie;</a>
<a name="ln1793">  slang_T     *slang;</a>
<a name="ln1794"> </a>
<a name="ln1795">  slang = spell_load_file(fname, slp-&gt;sl_lang, NULL, false);</a>
<a name="ln1796">  if (slang != NULL) {</a>
<a name="ln1797">    // When a previously loaded file has NOBREAK also use it for the</a>
<a name="ln1798">    // &quot;.add&quot; files.</a>
<a name="ln1799">    if (slp-&gt;sl_nobreak &amp;&amp; slang-&gt;sl_add)</a>
<a name="ln1800">      slang-&gt;sl_nobreak = true;</a>
<a name="ln1801">    else if (slang-&gt;sl_nobreak)</a>
<a name="ln1802">      slp-&gt;sl_nobreak = true;</a>
<a name="ln1803"> </a>
<a name="ln1804">    slp-&gt;sl_slang = slang;</a>
<a name="ln1805">  }</a>
<a name="ln1806">}</a>
<a name="ln1807"> </a>
<a name="ln1808">/// Add a word to the hashtable of common words.</a>
<a name="ln1809">/// If it's already there then the counter is increased.</a>
<a name="ln1810">///</a>
<a name="ln1811">/// @param[in]  lp</a>
<a name="ln1812">/// @param[in]  word  added to common words hashtable</a>
<a name="ln1813">/// @param[in]  len  length of word or -1 for NUL terminated</a>
<a name="ln1814">/// @param[in]  count  1 to count once, 10 to init</a>
<a name="ln1815">void count_common_word(slang_T *lp, char_u *word, int len, int count)</a>
<a name="ln1816">{</a>
<a name="ln1817">  hash_T hash;</a>
<a name="ln1818">  hashitem_T  *hi;</a>
<a name="ln1819">  wordcount_T *wc;</a>
<a name="ln1820">  char_u buf[MAXWLEN];</a>
<a name="ln1821">  char_u      *p;</a>
<a name="ln1822"> </a>
<a name="ln1823">  if (len == -1) {</a>
<a name="ln1824">    p = word;</a>
<a name="ln1825">  } else if (len &gt;= MAXWLEN) {</a>
<a name="ln1826">    return;</a>
<a name="ln1827">  } else {</a>
<a name="ln1828">    STRLCPY(buf, word, len + 1);</a>
<a name="ln1829">    p = buf;</a>
<a name="ln1830">  }</a>
<a name="ln1831"> </a>
<a name="ln1832">  hash = hash_hash(p);</a>
<a name="ln1833">  const size_t p_len = STRLEN(p);</a>
<a name="ln1834">  hi = hash_lookup(&amp;lp-&gt;sl_wordcount, (const char *)p, p_len, hash);</a>
<a name="ln1835">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln1836">    wc = xmalloc(sizeof(wordcount_T) + p_len);</a>
<a name="ln1837">    memcpy(wc-&gt;wc_word, p, p_len + 1);</a>
<a name="ln1838">    wc-&gt;wc_count = count;</a>
<a name="ln1839">    hash_add_item(&amp;lp-&gt;sl_wordcount, hi, wc-&gt;wc_word, hash);</a>
<a name="ln1840">  } else {</a>
<a name="ln1841">    wc = HI2WC(hi);</a>
<a name="ln1842">    if ((wc-&gt;wc_count += count) &lt; (unsigned)count)      // check for overflow</a>
<a name="ln1843">      wc-&gt;wc_count = MAXWORDCOUNT;</a>
<a name="ln1844">  }</a>
<a name="ln1845">}</a>
<a name="ln1846"> </a>
<a name="ln1847">// Adjust the score of common words.</a>
<a name="ln1848">static int</a>
<a name="ln1849">score_wordcount_adj (</a>
<a name="ln1850">    slang_T *slang,</a>
<a name="ln1851">    int score,</a>
<a name="ln1852">    char_u *word,</a>
<a name="ln1853">    bool split                  // word was split, less bonus</a>
<a name="ln1854">)</a>
<a name="ln1855">{</a>
<a name="ln1856">  hashitem_T  *hi;</a>
<a name="ln1857">  wordcount_T *wc;</a>
<a name="ln1858">  int bonus;</a>
<a name="ln1859">  int newscore;</a>
<a name="ln1860"> </a>
<a name="ln1861">  hi = hash_find(&amp;slang-&gt;sl_wordcount, word);</a>
<a name="ln1862">  if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln1863">    wc = HI2WC(hi);</a>
<a name="ln1864">    if (wc-&gt;wc_count &lt; SCORE_THRES2)</a>
<a name="ln1865">      bonus = SCORE_COMMON1;</a>
<a name="ln1866">    else if (wc-&gt;wc_count &lt; SCORE_THRES3)</a>
<a name="ln1867">      bonus = SCORE_COMMON2;</a>
<a name="ln1868">    else</a>
<a name="ln1869">      bonus = SCORE_COMMON3;</a>
<a name="ln1870">    if (split)</a>
<a name="ln1871">      newscore = score - bonus / 2;</a>
<a name="ln1872">    else</a>
<a name="ln1873">      newscore = score - bonus;</a>
<a name="ln1874">    if (newscore &lt; 0)</a>
<a name="ln1875">      return 0;</a>
<a name="ln1876">    return newscore;</a>
<a name="ln1877">  }</a>
<a name="ln1878">  return score;</a>
<a name="ln1879">}</a>
<a name="ln1880"> </a>
<a name="ln1881">// Returns true if byte &quot;n&quot; appears in &quot;str&quot;.</a>
<a name="ln1882">// Like strchr() but independent of locale.</a>
<a name="ln1883">bool byte_in_str(char_u *str, int n)</a>
<a name="ln1884">{</a>
<a name="ln1885">  char_u      *p;</a>
<a name="ln1886"> </a>
<a name="ln1887">  for (p = str; *p != NUL; ++p)</a>
<a name="ln1888">    if (*p == n)</a>
<a name="ln1889">      return true;</a>
<a name="ln1890">  return false;</a>
<a name="ln1891">}</a>
<a name="ln1892"> </a>
<a name="ln1893">// Truncate &quot;slang-&gt;sl_syllable&quot; at the first slash and put the following items</a>
<a name="ln1894">// in &quot;slang-&gt;sl_syl_items&quot;.</a>
<a name="ln1895">int init_syl_tab(slang_T *slang)</a>
<a name="ln1896">{</a>
<a name="ln1897">  char_u      *p;</a>
<a name="ln1898">  char_u      *s;</a>
<a name="ln1899">  int l;</a>
<a name="ln1900"> </a>
<a name="ln1901">  ga_init(&amp;slang-&gt;sl_syl_items, sizeof(syl_item_T), 4);</a>
<a name="ln1902">  p = vim_strchr(slang-&gt;sl_syllable, '/');</a>
<a name="ln1903">  while (p != NULL) {</a>
<a name="ln1904">    *p++ = NUL;</a>
<a name="ln1905">    if (*p == NUL)          // trailing slash</a>
<a name="ln1906">      break;</a>
<a name="ln1907">    s = p;</a>
<a name="ln1908">    p = vim_strchr(p, '/');</a>
<a name="ln1909">    if (p == NULL)</a>
<a name="ln1910">      l = (int)STRLEN(s);</a>
<a name="ln1911">    else</a>
<a name="ln1912">      l = (int)(p - s);</a>
<a name="ln1913">    if (l &gt;= SY_MAXLEN)</a>
<a name="ln1914">      return SP_FORMERROR;</a>
<a name="ln1915"> </a>
<a name="ln1916">    syl_item_T *syl = GA_APPEND_VIA_PTR(syl_item_T, &amp;slang-&gt;sl_syl_items);</a>
<a name="ln1917">    STRLCPY(syl-&gt;sy_chars, s, l + 1);</a>
<a name="ln1918">    syl-&gt;sy_len = l;</a>
<a name="ln1919">  }</a>
<a name="ln1920">  return OK;</a>
<a name="ln1921">}</a>
<a name="ln1922"> </a>
<a name="ln1923">// Count the number of syllables in &quot;word&quot;.</a>
<a name="ln1924">// When &quot;word&quot; contains spaces the syllables after the last space are counted.</a>
<a name="ln1925">// Returns zero if syllables are not defines.</a>
<a name="ln1926">static int count_syllables(slang_T *slang, const char_u *word)</a>
<a name="ln1927">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1928">{</a>
<a name="ln1929">  int cnt = 0;</a>
<a name="ln1930">  bool skip = false;</a>
<a name="ln1931">  int len;</a>
<a name="ln1932">  syl_item_T  *syl;</a>
<a name="ln1933">  int c;</a>
<a name="ln1934"> </a>
<a name="ln1935">  if (slang-&gt;sl_syllable == NULL)</a>
<a name="ln1936">    return 0;</a>
<a name="ln1937"> </a>
<a name="ln1938">  for (const char_u *p = word; *p != NUL; p += len) {</a>
<a name="ln1939">    // When running into a space reset counter.</a>
<a name="ln1940">    if (*p == ' ') {</a>
<a name="ln1941">      len = 1;</a>
<a name="ln1942">      cnt = 0;</a>
<a name="ln1943">      continue;</a>
<a name="ln1944">    }</a>
<a name="ln1945"> </a>
<a name="ln1946">    // Find longest match of syllable items.</a>
<a name="ln1947">    len = 0;</a>
<a name="ln1948">    for (int i = 0; i &lt; slang-&gt;sl_syl_items.ga_len; ++i) {</a>
<a name="ln1949">      syl = ((syl_item_T *)slang-&gt;sl_syl_items.ga_data) + i;</a>
<a name="ln1950">      if (syl-&gt;sy_len &gt; len</a>
<a name="ln1951">          &amp;&amp; STRNCMP(p, syl-&gt;sy_chars, syl-&gt;sy_len) == 0)</a>
<a name="ln1952">        len = syl-&gt;sy_len;</a>
<a name="ln1953">    }</a>
<a name="ln1954">    if (len != 0) {     // found a match, count syllable</a>
<a name="ln1955">      ++cnt;</a>
<a name="ln1956">      skip = false;</a>
<a name="ln1957">    } else {</a>
<a name="ln1958">      // No recognized syllable item, at least a syllable char then?</a>
<a name="ln1959">      c = utf_ptr2char(p);</a>
<a name="ln1960">      len = (*mb_ptr2len)(p);</a>
<a name="ln1961">      if (vim_strchr(slang-&gt;sl_syllable, c) == NULL)</a>
<a name="ln1962">        skip = false;               // No, search for next syllable</a>
<a name="ln1963">      else if (!skip) {</a>
<a name="ln1964">        ++cnt;                      // Yes, count it</a>
<a name="ln1965">        skip = true;                // don't count following syllable chars</a>
<a name="ln1966">      }</a>
<a name="ln1967">    }</a>
<a name="ln1968">  }</a>
<a name="ln1969">  return cnt;</a>
<a name="ln1970">}</a>
<a name="ln1971"> </a>
<a name="ln1972">// Parse 'spelllang' and set w_s-&gt;b_langp accordingly.</a>
<a name="ln1973">// Returns NULL if it's OK, an error message otherwise.</a>
<a name="ln1974">char_u *did_set_spelllang(win_T *wp)</a>
<a name="ln1975">{</a>
<a name="ln1976">  garray_T ga;</a>
<a name="ln1977">  char_u      *splp;</a>
<a name="ln1978">  char_u      *region;</a>
<a name="ln1979">  char_u region_cp[3];</a>
<a name="ln1980">  bool filename;</a>
<a name="ln1981">  int region_mask;</a>
<a name="ln1982">  slang_T     *slang;</a>
<a name="ln1983">  int c;</a>
<a name="ln1984">  char_u lang[MAXWLEN + 1];</a>
<a name="ln1985">  char_u spf_name[MAXPATHL];</a>
<a name="ln1986">  int len;</a>
<a name="ln1987">  char_u      *p;</a>
<a name="ln1988">  int round;</a>
<a name="ln1989">  char_u      *spf;</a>
<a name="ln1990">  char_u      *use_region = NULL;</a>
<a name="ln1991">  bool dont_use_region = false;</a>
<a name="ln1992">  bool nobreak = false;</a>
<a name="ln1993">  langp_T     *lp, *lp2;</a>
<a name="ln1994">  static bool recursive = false;</a>
<a name="ln1995">  char_u      *ret_msg = NULL;</a>
<a name="ln1996">  char_u      *spl_copy;</a>
<a name="ln1997"> </a>
<a name="ln1998">  bufref_T bufref;</a>
<a name="ln1999">  set_bufref(&amp;bufref, wp-&gt;w_buffer);</a>
<a name="ln2000"> </a>
<a name="ln2001">  // We don't want to do this recursively.  May happen when a language is</a>
<a name="ln2002">  // not available and the SpellFileMissing autocommand opens a new buffer</a>
<a name="ln2003">  // in which 'spell' is set.</a>
<a name="ln2004">  if (recursive)</a>
<a name="ln2005">    return NULL;</a>
<a name="ln2006">  recursive = true;</a>
<a name="ln2007"> </a>
<a name="ln2008">  ga_init(&amp;ga, sizeof(langp_T), 2);</a>
<a name="ln2009">  clear_midword(wp);</a>
<a name="ln2010"> </a>
<a name="ln2011">  // Make a copy of 'spelllang', the SpellFileMissing autocommands may change</a>
<a name="ln2012">  // it under our fingers.</a>
<a name="ln2013">  spl_copy = vim_strsave(wp-&gt;w_s-&gt;b_p_spl);</a>
<a name="ln2014"> </a>
<a name="ln2015">  wp-&gt;w_s-&gt;b_cjk = 0;</a>
<a name="ln2016"> </a>
<a name="ln2017">  // Loop over comma separated language names.</a>
<a name="ln2018">  for (splp = spl_copy; *splp != NUL; ) {</a>
<a name="ln2019">    // Get one language name.</a>
<a name="ln2020">    copy_option_part(&amp;splp, lang, MAXWLEN, &quot;,&quot;);</a>
<a name="ln2021">    region = NULL;</a>
<a name="ln2022">    len = (int)STRLEN(lang);</a>
<a name="ln2023"> </a>
<a name="ln2024">    if (!valid_spelllang(lang)) {</a>
<a name="ln2025">      continue;</a>
<a name="ln2026">    }</a>
<a name="ln2027"> </a>
<a name="ln2028">    if (STRCMP(lang, &quot;cjk&quot;) == 0) {</a>
<a name="ln2029">      wp-&gt;w_s-&gt;b_cjk = 1;</a>
<a name="ln2030">      continue;</a>
<a name="ln2031">    }</a>
<a name="ln2032"> </a>
<a name="ln2033">    // If the name ends in &quot;.spl&quot; use it as the name of the spell file.</a>
<a name="ln2034">    // If there is a region name let &quot;region&quot; point to it and remove it</a>
<a name="ln2035">    // from the name.</a>
<a name="ln2036">    if (len &gt; 4 &amp;&amp; fnamecmp(lang + len - 4, &quot;.spl&quot;) == 0) {</a>
<a name="ln2037">      filename = true;</a>
<a name="ln2038"> </a>
<a name="ln2039">      // Locate a region and remove it from the file name.</a>
<a name="ln2040">      p = vim_strchr(path_tail(lang), '_');</a>
<a name="ln2041">      if (p != NULL &amp;&amp; ASCII_ISALPHA(p[1]) &amp;&amp; ASCII_ISALPHA(p[2])</a>
<a name="ln2042">          &amp;&amp; !ASCII_ISALPHA(p[3])) {</a>
<a name="ln2043">        STRLCPY(region_cp, p + 1, 3);</a>
<a name="ln2044">        memmove(p, p + 3, len - (p - lang) - 2);</a>
<a name="ln2045">        region = region_cp;</a>
<a name="ln2046">      } else</a>
<a name="ln2047">        dont_use_region = true;</a>
<a name="ln2048"> </a>
<a name="ln2049">      // Check if we loaded this language before.</a>
<a name="ln2050">      for (slang = first_lang; slang != NULL; slang = slang-&gt;sl_next) {</a>
<a name="ln2051">        if (path_full_compare(lang, slang-&gt;sl_fname, false, true)</a>
<a name="ln2052">            == kEqualFiles) {</a>
<a name="ln2053">          break;</a>
<a name="ln2054">        }</a>
<a name="ln2055">      }</a>
<a name="ln2056">    } else {</a>
<a name="ln2057">      filename = false;</a>
<a name="ln2058">      if (len &gt; 3 &amp;&amp; lang[len - 3] == '_') {</a>
<a name="ln2059">        region = lang + len - 2;</a>
<a name="ln2060">        lang[len - 3] = NUL;</a>
<a name="ln2061">      } else</a>
<a name="ln2062">        dont_use_region = true;</a>
<a name="ln2063"> </a>
<a name="ln2064">      // Check if we loaded this language before.</a>
<a name="ln2065">      for (slang = first_lang; slang != NULL; slang = slang-&gt;sl_next)</a>
<a name="ln2066">        if (STRICMP(lang, slang-&gt;sl_name) == 0)</a>
<a name="ln2067">          break;</a>
<a name="ln2068">    }</a>
<a name="ln2069"> </a>
<a name="ln2070">    if (region != NULL) {</a>
<a name="ln2071">      // If the region differs from what was used before then don't</a>
<a name="ln2072">      // use it for 'spellfile'.</a>
<a name="ln2073">      if (use_region != NULL &amp;&amp; STRCMP(region, use_region) != 0)</a>
<a name="ln2074">        dont_use_region = true;</a>
<a name="ln2075">      use_region = region;</a>
<a name="ln2076">    }</a>
<a name="ln2077"> </a>
<a name="ln2078">    // If not found try loading the language now.</a>
<a name="ln2079">    if (slang == NULL) {</a>
<a name="ln2080">      if (filename)</a>
<a name="ln2081">        (void)spell_load_file(lang, lang, NULL, false);</a>
<a name="ln2082">      else {</a>
<a name="ln2083">        spell_load_lang(lang);</a>
<a name="ln2084">        // SpellFileMissing autocommands may do anything, including</a>
<a name="ln2085">        // destroying the buffer we are using...</a>
<a name="ln2086">        if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln2087">          ret_msg =</a>
<a name="ln2088">            (char_u *)N_(&quot;E797: SpellFileMissing autocommand deleted buffer&quot;);</a>
<a name="ln2089">          goto theend;</a>
<a name="ln2090">        }</a>
<a name="ln2091">      }</a>
<a name="ln2092">    }</a>
<a name="ln2093"> </a>
<a name="ln2094">    // Loop over the languages, there can be several files for &quot;lang&quot;.</a>
<a name="ln2095">    for (slang = first_lang; slang != NULL; slang = slang-&gt;sl_next) {</a>
<a name="ln2096">      if (filename</a>
<a name="ln2097">          ? path_full_compare(lang, slang-&gt;sl_fname, false, true) == kEqualFiles</a>
<a name="ln2098">          : STRICMP(lang, slang-&gt;sl_name) == 0) {</a>
<a name="ln2099">        region_mask = REGION_ALL;</a>
<a name="ln2100">        if (!filename &amp;&amp; region != NULL) {</a>
<a name="ln2101">          // find region in sl_regions</a>
<a name="ln2102">          c = find_region(slang-&gt;sl_regions, region);</a>
<a name="ln2103">          if (c == REGION_ALL) {</a>
<a name="ln2104">            if (slang-&gt;sl_add) {</a>
<a name="ln2105">              if (*slang-&gt;sl_regions != NUL)</a>
<a name="ln2106">                // This addition file is for other regions.</a>
<a name="ln2107">                region_mask = 0;</a>
<a name="ln2108">            } else</a>
<a name="ln2109">              // This is probably an error.  Give a warning and</a>
<a name="ln2110">              // accept the words anyway.</a>
<a name="ln2111">              smsg(_(&quot;Warning: region %s not supported&quot;),</a>
<a name="ln2112">                   region);</a>
<a name="ln2113">          } else</a>
<a name="ln2114">            region_mask = 1 &lt;&lt; c;</a>
<a name="ln2115">        }</a>
<a name="ln2116"> </a>
<a name="ln2117">        if (region_mask != 0) {</a>
<a name="ln2118">          langp_T *p_ = GA_APPEND_VIA_PTR(langp_T, &amp;ga);</a>
<a name="ln2119">          p_-&gt;lp_slang = slang;</a>
<a name="ln2120">          p_-&gt;lp_region = region_mask;</a>
<a name="ln2121"> </a>
<a name="ln2122">          use_midword(slang, wp);</a>
<a name="ln2123">          if (slang-&gt;sl_nobreak)</a>
<a name="ln2124">            nobreak = true;</a>
<a name="ln2125">        }</a>
<a name="ln2126">      }</a>
<a name="ln2127">    }</a>
<a name="ln2128">  }</a>
<a name="ln2129"> </a>
<a name="ln2130">  // round 0: load int_wordlist, if possible.</a>
<a name="ln2131">  // round 1: load first name in 'spellfile'.</a>
<a name="ln2132">  // round 2: load second name in 'spellfile.</a>
<a name="ln2133">  // etc.</a>
<a name="ln2134">  spf = curwin-&gt;w_s-&gt;b_p_spf;</a>
<a name="ln2135">  for (round = 0; round == 0 || *spf != NUL; ++round) {</a>
<a name="ln2136">    if (round == 0) {</a>
<a name="ln2137">      // Internal wordlist, if there is one.</a>
<a name="ln2138">      if (int_wordlist == NULL)</a>
<a name="ln2139">        continue;</a>
<a name="ln2140">      int_wordlist_spl(spf_name);</a>
<a name="ln2141">    } else {</a>
<a name="ln2142">      // One entry in 'spellfile'.</a>
<a name="ln2143">      copy_option_part(&amp;spf, spf_name, MAXPATHL - 5, &quot;,&quot;);</a>
<a name="ln2144">      STRCAT(spf_name, &quot;.spl&quot;);</a>
<a name="ln2145"> </a>
<a name="ln2146">      // If it was already found above then skip it.</a>
<a name="ln2147">      for (c = 0; c &lt; ga.ga_len; ++c) {</a>
<a name="ln2148">        p = LANGP_ENTRY(ga, c)-&gt;lp_slang-&gt;sl_fname;</a>
<a name="ln2149">        if (p != NULL</a>
<a name="ln2150">            &amp;&amp; path_full_compare(spf_name, p, false, true) == kEqualFiles) {</a>
<a name="ln2151">          break;</a>
<a name="ln2152">        }</a>
<a name="ln2153">      }</a>
<a name="ln2154">      if (c &lt; ga.ga_len)</a>
<a name="ln2155">        continue;</a>
<a name="ln2156">    }</a>
<a name="ln2157"> </a>
<a name="ln2158">    // Check if it was loaded already.</a>
<a name="ln2159">    for (slang = first_lang; slang != NULL; slang = slang-&gt;sl_next) {</a>
<a name="ln2160">      if (path_full_compare(spf_name, slang-&gt;sl_fname, false, true)</a>
<a name="ln2161">          == kEqualFiles) {</a>
<a name="ln2162">        break;</a>
<a name="ln2163">      }</a>
<a name="ln2164">    }</a>
<a name="ln2165">    if (slang == NULL) {</a>
<a name="ln2166">      // Not loaded, try loading it now.  The language name includes the</a>
<a name="ln2167">      // region name, the region is ignored otherwise.  for int_wordlist</a>
<a name="ln2168">      // use an arbitrary name.</a>
<a name="ln2169">      if (round == 0)</a>
<a name="ln2170">        STRCPY(lang, &quot;internal wordlist&quot;);</a>
<a name="ln2171">      else {</a>
<a name="ln2172">        STRLCPY(lang, path_tail(spf_name), MAXWLEN + 1);</a>
<a name="ln2173">        p = vim_strchr(lang, '.');</a>
<a name="ln2174">        if (p != NULL)</a>
<a name="ln2175">          *p = NUL;             // truncate at &quot;.encoding.add&quot;</a>
<a name="ln2176">      }</a>
<a name="ln2177">      slang = spell_load_file(spf_name, lang, NULL, true);</a>
<a name="ln2178"> </a>
<a name="ln2179">      // If one of the languages has NOBREAK we assume the addition</a>
<a name="ln2180">      // files also have this.</a>
<a name="ln2181">      if (slang != NULL &amp;&amp; nobreak)</a>
<a name="ln2182">        slang-&gt;sl_nobreak = true;</a>
<a name="ln2183">    }</a>
<a name="ln2184">    if (slang != NULL) {</a>
<a name="ln2185">      region_mask = REGION_ALL;</a>
<a name="ln2186">      if (use_region != NULL &amp;&amp; !dont_use_region) {</a>
<a name="ln2187">        // find region in sl_regions</a>
<a name="ln2188">        c = find_region(slang-&gt;sl_regions, use_region);</a>
<a name="ln2189">        if (c != REGION_ALL)</a>
<a name="ln2190">          region_mask = 1 &lt;&lt; c;</a>
<a name="ln2191">        else if (*slang-&gt;sl_regions != NUL)</a>
<a name="ln2192">          // This spell file is for other regions.</a>
<a name="ln2193">          region_mask = 0;</a>
<a name="ln2194">      }</a>
<a name="ln2195"> </a>
<a name="ln2196">      if (region_mask != 0) {</a>
<a name="ln2197">        langp_T *p_ = GA_APPEND_VIA_PTR(langp_T, &amp;ga);</a>
<a name="ln2198">        p_-&gt;lp_slang = slang;</a>
<a name="ln2199">        p_-&gt;lp_sallang = NULL;</a>
<a name="ln2200">        p_-&gt;lp_replang = NULL;</a>
<a name="ln2201">        p_-&gt;lp_region = region_mask;</a>
<a name="ln2202"> </a>
<a name="ln2203">        use_midword(slang, wp);</a>
<a name="ln2204">      }</a>
<a name="ln2205">    }</a>
<a name="ln2206">  }</a>
<a name="ln2207"> </a>
<a name="ln2208">  // Everything is fine, store the new b_langp value.</a>
<a name="ln2209">  ga_clear(&amp;wp-&gt;w_s-&gt;b_langp);</a>
<a name="ln2210">  wp-&gt;w_s-&gt;b_langp = ga;</a>
<a name="ln2211"> </a>
<a name="ln2212">  // For each language figure out what language to use for sound folding and</a>
<a name="ln2213">  // REP items.  If the language doesn't support it itself use another one</a>
<a name="ln2214">  // with the same name.  E.g. for &quot;en-math&quot; use &quot;en&quot;.</a>
<a name="ln2215">  for (int i = 0; i &lt; ga.ga_len; ++i) {</a>
<a name="ln2216">    lp = LANGP_ENTRY(ga, i);</a>
<a name="ln2217"> </a>
<a name="ln2218">    // sound folding</a>
<a name="ln2219">    if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_sal))</a>
<a name="ln2220">      // language does sound folding itself</a>
<a name="ln2221">      lp-&gt;lp_sallang = lp-&gt;lp_slang;</a>
<a name="ln2222">    else</a>
<a name="ln2223">      // find first similar language that does sound folding</a>
<a name="ln2224">      for (int j = 0; j &lt; ga.ga_len; ++j) {</a>
<a name="ln2225">        lp2 = LANGP_ENTRY(ga, j);</a>
<a name="ln2226">        if (!GA_EMPTY(&amp;lp2-&gt;lp_slang-&gt;sl_sal)</a>
<a name="ln2227">            &amp;&amp; STRNCMP(lp-&gt;lp_slang-&gt;sl_name,</a>
<a name="ln2228">                lp2-&gt;lp_slang-&gt;sl_name, 2) == 0) {</a>
<a name="ln2229">          lp-&gt;lp_sallang = lp2-&gt;lp_slang;</a>
<a name="ln2230">          break;</a>
<a name="ln2231">        }</a>
<a name="ln2232">      }</a>
<a name="ln2233"> </a>
<a name="ln2234">    // REP items</a>
<a name="ln2235">    if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_rep))</a>
<a name="ln2236">      // language has REP items itself</a>
<a name="ln2237">      lp-&gt;lp_replang = lp-&gt;lp_slang;</a>
<a name="ln2238">    else</a>
<a name="ln2239">      // find first similar language that has REP items</a>
<a name="ln2240">      for (int j = 0; j &lt; ga.ga_len; ++j) {</a>
<a name="ln2241">        lp2 = LANGP_ENTRY(ga, j);</a>
<a name="ln2242">        if (!GA_EMPTY(&amp;lp2-&gt;lp_slang-&gt;sl_rep)</a>
<a name="ln2243">            &amp;&amp; STRNCMP(lp-&gt;lp_slang-&gt;sl_name,</a>
<a name="ln2244">                lp2-&gt;lp_slang-&gt;sl_name, 2) == 0) {</a>
<a name="ln2245">          lp-&gt;lp_replang = lp2-&gt;lp_slang;</a>
<a name="ln2246">          break;</a>
<a name="ln2247">        }</a>
<a name="ln2248">      }</a>
<a name="ln2249">  }</a>
<a name="ln2250"> </a>
<a name="ln2251">theend:</a>
<a name="ln2252">  xfree(spl_copy);</a>
<a name="ln2253">  recursive = false;</a>
<a name="ln2254">  redraw_later(wp, NOT_VALID);</a>
<a name="ln2255">  return ret_msg;</a>
<a name="ln2256">}</a>
<a name="ln2257"> </a>
<a name="ln2258">// Clear the midword characters for buffer &quot;buf&quot;.</a>
<a name="ln2259">static void clear_midword(win_T *wp)</a>
<a name="ln2260">{</a>
<a name="ln2261">  memset(wp-&gt;w_s-&gt;b_spell_ismw, 0, 256);</a>
<a name="ln2262">  XFREE_CLEAR(wp-&gt;w_s-&gt;b_spell_ismw_mb);</a>
<a name="ln2263">}</a>
<a name="ln2264"> </a>
<a name="ln2265">// Use the &quot;sl_midword&quot; field of language &quot;lp&quot; for buffer &quot;buf&quot;.</a>
<a name="ln2266">// They add up to any currently used midword characters.</a>
<a name="ln2267">static void use_midword(slang_T *lp, win_T *wp)</a>
<a name="ln2268">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2269">{</a>
<a name="ln2270">  if (lp-&gt;sl_midword == NULL) {  // there aren't any</a>
<a name="ln2271">    return;</a>
<a name="ln2272">  }</a>
<a name="ln2273"> </a>
<a name="ln2274">  for (char_u *p = lp-&gt;sl_midword; *p != NUL; ) {</a>
<a name="ln2275">    const int c = utf_ptr2char(p);</a>
<a name="ln2276">    const int l = utfc_ptr2len(p);</a>
<a name="ln2277">    if (c &lt; 256 &amp;&amp; l &lt;= 2) {</a>
<a name="ln2278">      wp-&gt;w_s-&gt;b_spell_ismw[c] = true;</a>
<a name="ln2279">    } else if (wp-&gt;w_s-&gt;b_spell_ismw_mb == NULL) {</a>
<a name="ln2280">      // First multi-byte char in &quot;b_spell_ismw_mb&quot;.</a>
<a name="ln2281">      wp-&gt;w_s-&gt;b_spell_ismw_mb = vim_strnsave(p, l);</a>
<a name="ln2282">    } else {</a>
<a name="ln2283">      // Append multi-byte chars to &quot;b_spell_ismw_mb&quot;.</a>
<a name="ln2284">      const int n = (int)STRLEN(wp-&gt;w_s-&gt;b_spell_ismw_mb);</a>
<a name="ln2285">      char_u *bp = vim_strnsave(wp-&gt;w_s-&gt;b_spell_ismw_mb, n + l);</a>
<a name="ln2286">      xfree(wp-&gt;w_s-&gt;b_spell_ismw_mb);</a>
<a name="ln2287">      wp-&gt;w_s-&gt;b_spell_ismw_mb = bp;</a>
<a name="ln2288">      STRLCPY(bp + n, p, l + 1);</a>
<a name="ln2289">    }</a>
<a name="ln2290">    p += l;</a>
<a name="ln2291">  }</a>
<a name="ln2292">}</a>
<a name="ln2293"> </a>
<a name="ln2294">// Find the region &quot;region[2]&quot; in &quot;rp&quot; (points to &quot;sl_regions&quot;).</a>
<a name="ln2295">// Each region is simply stored as the two characters of its name.</a>
<a name="ln2296">// Returns the index if found (first is 0), REGION_ALL if not found.</a>
<a name="ln2297">static int find_region(char_u *rp, char_u *region)</a>
<a name="ln2298">{</a>
<a name="ln2299">  int i;</a>
<a name="ln2300"> </a>
<a name="ln2301">  for (i = 0;; i += 2) {</a>
<a name="ln2302">    if (rp[i] == NUL)</a>
<a name="ln2303">      return REGION_ALL;</a>
<a name="ln2304">    if (rp[i] == region[0] &amp;&amp; rp[i + 1] == region[1])</a>
<a name="ln2305">      break;</a>
<a name="ln2306">  }</a>
<a name="ln2307">  return i / 2;</a>
<a name="ln2308">}</a>
<a name="ln2309"> </a>
<a name="ln2310">/// Return case type of word:</a>
<a name="ln2311">/// w word       0</a>
<a name="ln2312">/// Word         WF_ONECAP</a>
<a name="ln2313">/// W WORD       WF_ALLCAP</a>
<a name="ln2314">/// WoRd wOrd    WF_KEEPCAP</a>
<a name="ln2315">///</a>
<a name="ln2316">/// @param[in]  word</a>
<a name="ln2317">/// @param[in]  end  End of word or NULL for NUL delimited string</a>
<a name="ln2318">///</a>
<a name="ln2319">/// @returns  Case type of word</a>
<a name="ln2320">int captype(char_u *word, char_u *end)</a>
<a name="ln2321">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln2322">{</a>
<a name="ln2323">  char_u      *p;</a>
<a name="ln2324">  int firstcap;</a>
<a name="ln2325">  bool allcap;</a>
<a name="ln2326">  bool past_second = false;              // past second word char</a>
<a name="ln2327"> </a>
<a name="ln2328">  // find first letter</a>
<a name="ln2329">  for (p = word; !spell_iswordp_nmw(p, curwin); MB_PTR_ADV(p)) {</a>
<a name="ln2330">    if (end == NULL ? *p == NUL : p &gt;= end) {</a>
<a name="ln2331">      return 0;             // only non-word characters, illegal word</a>
<a name="ln2332">    }</a>
<a name="ln2333">  }</a>
<a name="ln2334">  int c = mb_ptr2char_adv((const char_u **)&amp;p);</a>
<a name="ln2335">  firstcap = allcap = SPELL_ISUPPER(c);</a>
<a name="ln2336"> </a>
<a name="ln2337">  // Need to check all letters to find a word with mixed upper/lower.</a>
<a name="ln2338">  // But a word with an upper char only at start is a ONECAP.</a>
<a name="ln2339">  for (; end == NULL ? *p != NUL : p &lt; end; MB_PTR_ADV(p)) {</a>
<a name="ln2340">    if (spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln2341">      c = PTR2CHAR(p);</a>
<a name="ln2342">      if (!SPELL_ISUPPER(c)) {</a>
<a name="ln2343">        // UUl -&gt; KEEPCAP</a>
<a name="ln2344">        if (past_second &amp;&amp; allcap) {</a>
<a name="ln2345">          return WF_KEEPCAP;</a>
<a name="ln2346">        }</a>
<a name="ln2347">        allcap = false;</a>
<a name="ln2348">      } else if (!allcap) {</a>
<a name="ln2349">        // UlU -&gt; KEEPCAP</a>
<a name="ln2350">        return WF_KEEPCAP;</a>
<a name="ln2351">      }</a>
<a name="ln2352">      past_second = true;</a>
<a name="ln2353">    }</a>
<a name="ln2354">  }</a>
<a name="ln2355"> </a>
<a name="ln2356">  if (allcap)</a>
<a name="ln2357">    return WF_ALLCAP;</a>
<a name="ln2358">  if (firstcap)</a>
<a name="ln2359">    return WF_ONECAP;</a>
<a name="ln2360">  return 0;</a>
<a name="ln2361">}</a>
<a name="ln2362"> </a>
<a name="ln2363">// Like captype() but for a KEEPCAP word add ONECAP if the word starts with a</a>
<a name="ln2364">// capital.  So that make_case_word() can turn WOrd into Word.</a>
<a name="ln2365">// Add ALLCAP for &quot;WOrD&quot;.</a>
<a name="ln2366">static int badword_captype(char_u *word, char_u *end)</a>
<a name="ln2367">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2368">{</a>
<a name="ln2369">  int flags = captype(word, end);</a>
<a name="ln2370">  int c;</a>
<a name="ln2371">  int l, u;</a>
<a name="ln2372">  bool first;</a>
<a name="ln2373">  char_u      *p;</a>
<a name="ln2374"> </a>
<a name="ln2375">  if (flags &amp; WF_KEEPCAP) {</a>
<a name="ln2376">    // Count the number of UPPER and lower case letters.</a>
<a name="ln2377">    l = u = 0;</a>
<a name="ln2378">    first = false;</a>
<a name="ln2379">    for (p = word; p &lt; end; MB_PTR_ADV(p)) {</a>
<a name="ln2380">      c = PTR2CHAR(p);</a>
<a name="ln2381">      if (SPELL_ISUPPER(c)) {</a>
<a name="ln2382">        ++u;</a>
<a name="ln2383">        if (p == word)</a>
<a name="ln2384">          first = true;</a>
<a name="ln2385">      } else</a>
<a name="ln2386">        ++l;</a>
<a name="ln2387">    }</a>
<a name="ln2388"> </a>
<a name="ln2389">    // If there are more UPPER than lower case letters suggest an</a>
<a name="ln2390">    // ALLCAP word.  Otherwise, if the first letter is UPPER then</a>
<a name="ln2391">    // suggest ONECAP.  Exception: &quot;ALl&quot; most likely should be &quot;All&quot;,</a>
<a name="ln2392">    // require three upper case letters.</a>
<a name="ln2393">    if (u &gt; l &amp;&amp; u &gt; 2)</a>
<a name="ln2394">      flags |= WF_ALLCAP;</a>
<a name="ln2395">    else if (first)</a>
<a name="ln2396">      flags |= WF_ONECAP;</a>
<a name="ln2397"> </a>
<a name="ln2398">    if (u &gt;= 2 &amp;&amp; l &gt;= 2)       // maCARONI maCAroni</a>
<a name="ln2399">      flags |= WF_MIXCAP;</a>
<a name="ln2400">  }</a>
<a name="ln2401">  return flags;</a>
<a name="ln2402">}</a>
<a name="ln2403"> </a>
<a name="ln2404">// Delete the internal wordlist and its .spl file.</a>
<a name="ln2405">void spell_delete_wordlist(void)</a>
<a name="ln2406">{</a>
<a name="ln2407">  char_u fname[MAXPATHL] = {0};</a>
<a name="ln2408"> </a>
<a name="ln2409">  if (int_wordlist != NULL) {</a>
<a name="ln2410">    os_remove((char *)int_wordlist);</a>
<a name="ln2411">    int_wordlist_spl(fname);</a>
<a name="ln2412">    os_remove((char *)fname);</a>
<a name="ln2413">    XFREE_CLEAR(int_wordlist);</a>
<a name="ln2414">  }</a>
<a name="ln2415">}</a>
<a name="ln2416"> </a>
<a name="ln2417">// Free all languages.</a>
<a name="ln2418">void spell_free_all(void)</a>
<a name="ln2419">{</a>
<a name="ln2420">  slang_T     *slang;</a>
<a name="ln2421"> </a>
<a name="ln2422">  // Go through all buffers and handle 'spelllang'. &lt;VN&gt;</a>
<a name="ln2423">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2424">    ga_clear(&amp;buf-&gt;b_s.b_langp);</a>
<a name="ln2425">  }</a>
<a name="ln2426"> </a>
<a name="ln2427">  while (first_lang != NULL) {</a>
<a name="ln2428">    slang = first_lang;</a>
<a name="ln2429">    first_lang = slang-&gt;sl_next;</a>
<a name="ln2430">    slang_free(slang);</a>
<a name="ln2431">  }</a>
<a name="ln2432"> </a>
<a name="ln2433">  spell_delete_wordlist();</a>
<a name="ln2434"> </a>
<a name="ln2435">  XFREE_CLEAR(repl_to);</a>
<a name="ln2436">  XFREE_CLEAR(repl_from);</a>
<a name="ln2437">}</a>
<a name="ln2438"> </a>
<a name="ln2439">// Clear all spelling tables and reload them.</a>
<a name="ln2440">// Used after 'encoding' is set and when &quot;:mkspell&quot; was used.</a>
<a name="ln2441">void spell_reload(void)</a>
<a name="ln2442">{</a>
<a name="ln2443">  // Initialize the table for spell_iswordp().</a>
<a name="ln2444">  init_spell_chartab();</a>
<a name="ln2445"> </a>
<a name="ln2446">  // Unload all allocated memory.</a>
<a name="ln2447">  spell_free_all();</a>
<a name="ln2448"> </a>
<a name="ln2449">  // Go through all buffers and handle 'spelllang'.</a>
<a name="ln2450">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln2451">    // Only load the wordlists when 'spelllang' is set and there is a</a>
<a name="ln2452">    // window for this buffer in which 'spell' is set.</a>
<a name="ln2453">    if (*wp-&gt;w_s-&gt;b_p_spl != NUL) {</a>
<a name="ln2454">      if (wp-&gt;w_p_spell) {</a>
<a name="ln2455">        (void)did_set_spelllang(wp);</a>
<a name="ln2456">        break;</a>
<a name="ln2457">      }</a>
<a name="ln2458">    }</a>
<a name="ln2459">  }</a>
<a name="ln2460">}</a>
<a name="ln2461"> </a>
<a name="ln2462"> </a>
<a name="ln2463">// Opposite of offset2bytes().</a>
<a name="ln2464">// &quot;pp&quot; points to the bytes and is advanced over it.</a>
<a name="ln2465">// Returns the offset.</a>
<a name="ln2466">static int bytes2offset(char_u **pp)</a>
<a name="ln2467">{</a>
<a name="ln2468">  char_u *p = *pp;</a>
<a name="ln2469">  int nr;</a>
<a name="ln2470">  int c;</a>
<a name="ln2471"> </a>
<a name="ln2472">  c = *p++;</a>
<a name="ln2473">  if ((c &amp; 0x80) == 0x00) {             // 1 byte</a>
<a name="ln2474">    nr = c - 1;</a>
<a name="ln2475">  } else if ((c &amp; 0xc0) == 0x80)   {    // 2 bytes</a>
<a name="ln2476">    nr = (c &amp; 0x3f) - 1;</a>
<a name="ln2477">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln2478">  } else if ((c &amp; 0xe0) == 0xc0)   {    // 3 bytes</a>
<a name="ln2479">    nr = (c &amp; 0x1f) - 1;</a>
<a name="ln2480">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln2481">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln2482">  } else {                              // 4 bytes</a>
<a name="ln2483">    nr = (c &amp; 0x0f) - 1;</a>
<a name="ln2484">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln2485">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln2486">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln2487">  }</a>
<a name="ln2488"> </a>
<a name="ln2489">  *pp = p;</a>
<a name="ln2490">  return nr;</a>
<a name="ln2491">}</a>
<a name="ln2492"> </a>
<a name="ln2493">// Open a spell buffer.  This is a nameless buffer that is not in the buffer</a>
<a name="ln2494">// list and only contains text lines.  Can use a swapfile to reduce memory</a>
<a name="ln2495">// use.</a>
<a name="ln2496">// Most other fields are invalid!  Esp. watch out for string options being</a>
<a name="ln2497">// NULL and there is no undo info.</a>
<a name="ln2498">buf_T *open_spellbuf(void)</a>
<a name="ln2499">{</a>
<a name="ln2500">  buf_T *buf = xcalloc(1, sizeof(buf_T));</a>
<a name="ln2501"> </a>
<a name="ln2502">  buf-&gt;b_spell = true;</a>
<a name="ln2503">  buf-&gt;b_p_swf = true;        // may create a swap file</a>
<a name="ln2504">  if (ml_open(buf) == FAIL) {</a>
<a name="ln2505">    ELOG(&quot;Error opening a new memline&quot;);</a>
<a name="ln2506">  }</a>
<a name="ln2507">  ml_open_file(buf);          // create swap file now</a>
<a name="ln2508"> </a>
<a name="ln2509">  return buf;</a>
<a name="ln2510">}</a>
<a name="ln2511"> </a>
<a name="ln2512">// Close the buffer used for spell info.</a>
<a name="ln2513">void close_spellbuf(buf_T *buf)</a>
<a name="ln2514">{</a>
<a name="ln2515">  if (buf != NULL) {</a>
<a name="ln2516">    ml_close(buf, TRUE);</a>
<a name="ln2517">    xfree(buf);</a>
<a name="ln2518">  }</a>
<a name="ln2519">}</a>
<a name="ln2520"> </a>
<a name="ln2521">// Init the chartab used for spelling for ASCII.</a>
<a name="ln2522">void clear_spell_chartab(spelltab_T *sp)</a>
<a name="ln2523">{</a>
<a name="ln2524">  int i;</a>
<a name="ln2525"> </a>
<a name="ln2526">  // Init everything to false.</a>
<a name="ln2527">  memset(sp-&gt;st_isw, false, sizeof(sp-&gt;st_isw));</a>
<a name="ln2528">  memset(sp-&gt;st_isu, false, sizeof(sp-&gt;st_isu));</a>
<a name="ln2529"> </a>
<a name="ln2530">  for (i = 0; i &lt; 256; ++i) {</a>
<a name="ln2531">    sp-&gt;st_fold[i] = i;</a>
<a name="ln2532">    sp-&gt;st_upper[i] = i;</a>
<a name="ln2533">  }</a>
<a name="ln2534"> </a>
<a name="ln2535">  // We include digits. A word shouldn't start with a digit, but handling</a>
<a name="ln2536">  // that is done separately.</a>
<a name="ln2537">  for (i = '0'; i &lt;= '9'; ++i)</a>
<a name="ln2538">    sp-&gt;st_isw[i] = true;</a>
<a name="ln2539">  for (i = 'A'; i &lt;= 'Z'; ++i) {</a>
<a name="ln2540">    sp-&gt;st_isw[i] = true;</a>
<a name="ln2541">    sp-&gt;st_isu[i] = true;</a>
<a name="ln2542">    sp-&gt;st_fold[i] = i + 0x20;</a>
<a name="ln2543">  }</a>
<a name="ln2544">  for (i = 'a'; i &lt;= 'z'; ++i) {</a>
<a name="ln2545">    sp-&gt;st_isw[i] = true;</a>
<a name="ln2546">    sp-&gt;st_upper[i] = i - 0x20;</a>
<a name="ln2547">  }</a>
<a name="ln2548">}</a>
<a name="ln2549"> </a>
<a name="ln2550">// Init the chartab used for spelling. Called once while starting up.</a>
<a name="ln2551">// The default is to use isalpha(), but the spell file should define the word</a>
<a name="ln2552">// characters to make it possible that 'encoding' differs from the current</a>
<a name="ln2553">// locale.  For utf-8 we don't use isalpha() but our own functions.</a>
<a name="ln2554">void init_spell_chartab(void)</a>
<a name="ln2555">{</a>
<a name="ln2556">  int i;</a>
<a name="ln2557"> </a>
<a name="ln2558">  did_set_spelltab = false;</a>
<a name="ln2559">  clear_spell_chartab(&amp;spelltab);</a>
<a name="ln2560">  for (i = 128; i &lt; 256; i++) {</a>
<a name="ln2561">    int f = utf_fold(i);</a>
<a name="ln2562">    int u = mb_toupper(i);</a>
<a name="ln2563"> </a>
<a name="ln2564">    spelltab.st_isu[i] = mb_isupper(i);</a>
<a name="ln2565">    spelltab.st_isw[i] = spelltab.st_isu[i] || mb_islower(i);</a>
<a name="ln2566">    // The folded/upper-cased value is different between latin1 and</a>
<a name="ln2567">    // utf8 for 0xb5, causing E763 for no good reason.  Use the latin1</a>
<a name="ln2568">    // value for utf-8 to avoid this.</a>
<a name="ln2569">    spelltab.st_fold[i] = (f &lt; 256) ? f : i;</a>
<a name="ln2570">    spelltab.st_upper[i] = (u &lt; 256) ? u : i;</a>
<a name="ln2571">  }</a>
<a name="ln2572">}</a>
<a name="ln2573"> </a>
<a name="ln2574">/// Returns true if &quot;p&quot; points to a word character.</a>
<a name="ln2575">/// As a special case we see &quot;midword&quot; characters as word character when it is</a>
<a name="ln2576">/// followed by a word character.  This finds they'there but not 'they there'.</a>
<a name="ln2577">/// Thus this only works properly when past the first character of the word.</a>
<a name="ln2578">///</a>
<a name="ln2579">/// @param wp Buffer used.</a>
<a name="ln2580">static bool spell_iswordp(const char_u *p, const win_T *wp)</a>
<a name="ln2581">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2582">{</a>
<a name="ln2583">  int c;</a>
<a name="ln2584"> </a>
<a name="ln2585">  const int l = utfc_ptr2len(p);</a>
<a name="ln2586">  const char_u *s = p;</a>
<a name="ln2587">  if (l == 1) {</a>
<a name="ln2588">    // be quick for ASCII</a>
<a name="ln2589">    if (wp-&gt;w_s-&gt;b_spell_ismw[*p]) {</a>
<a name="ln2590">      s = p + 1;                      // skip a mid-word character</a>
<a name="ln2591">    }</a>
<a name="ln2592">  } else {</a>
<a name="ln2593">    c = utf_ptr2char(p);</a>
<a name="ln2594">    if (c &lt; 256</a>
<a name="ln2595">        ? wp-&gt;w_s-&gt;b_spell_ismw[c]</a>
<a name="ln2596">        : (wp-&gt;w_s-&gt;b_spell_ismw_mb != NULL</a>
<a name="ln2597">           &amp;&amp; vim_strchr(wp-&gt;w_s-&gt;b_spell_ismw_mb, c) != NULL)) {</a>
<a name="ln2598">      s = p + l;</a>
<a name="ln2599">    }</a>
<a name="ln2600">  }</a>
<a name="ln2601"> </a>
<a name="ln2602">  c = utf_ptr2char(s);</a>
<a name="ln2603">  if (c &gt; 255) {</a>
<a name="ln2604">    return spell_mb_isword_class(mb_get_class(s), wp);</a>
<a name="ln2605">  }</a>
<a name="ln2606">  return spelltab.st_isw[c];</a>
<a name="ln2607">}</a>
<a name="ln2608"> </a>
<a name="ln2609">// Returns true if &quot;p&quot; points to a word character.</a>
<a name="ln2610">// Unlike spell_iswordp() this doesn't check for &quot;midword&quot; characters.</a>
<a name="ln2611">bool spell_iswordp_nmw(const char_u *p, win_T *wp)</a>
<a name="ln2612">{</a>
<a name="ln2613">  int c = utf_ptr2char(p);</a>
<a name="ln2614">  if (c &gt; 255) {</a>
<a name="ln2615">    return spell_mb_isword_class(mb_get_class(p), wp);</a>
<a name="ln2616">  }</a>
<a name="ln2617">  return spelltab.st_isw[c];</a>
<a name="ln2618">}</a>
<a name="ln2619"> </a>
<a name="ln2620">// Returns true if word class indicates a word character.</a>
<a name="ln2621">// Only for characters above 255.</a>
<a name="ln2622">// Unicode subscript and superscript are not considered word characters.</a>
<a name="ln2623">// See also utf_class() in mbyte.c.</a>
<a name="ln2624">static bool spell_mb_isword_class(int cl, const win_T *wp)</a>
<a name="ln2625">  FUNC_ATTR_PURE FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2626">{</a>
<a name="ln2627">  if (wp-&gt;w_s-&gt;b_cjk)</a>
<a name="ln2628">    // East Asian characters are not considered word characters.</a>
<a name="ln2629">    return cl == 2 || cl == 0x2800;</a>
<a name="ln2630">  return cl &gt;= 2 &amp;&amp; cl != 0x2070 &amp;&amp; cl != 0x2080 &amp;&amp; cl != 3;</a>
<a name="ln2631">}</a>
<a name="ln2632"> </a>
<a name="ln2633">// Returns true if &quot;p&quot; points to a word character.</a>
<a name="ln2634">// Wide version of spell_iswordp().</a>
<a name="ln2635">static bool spell_iswordp_w(const int *p, const win_T *wp)</a>
<a name="ln2636">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2637">{</a>
<a name="ln2638">  const int *s;</a>
<a name="ln2639"> </a>
<a name="ln2640">  if (*p &lt; 256 ? wp-&gt;w_s-&gt;b_spell_ismw[*p]</a>
<a name="ln2641">      : (wp-&gt;w_s-&gt;b_spell_ismw_mb != NULL</a>
<a name="ln2642">         &amp;&amp; vim_strchr(wp-&gt;w_s-&gt;b_spell_ismw_mb, *p) != NULL))</a>
<a name="ln2643">    s = p + 1;</a>
<a name="ln2644">  else</a>
<a name="ln2645">    s = p;</a>
<a name="ln2646"> </a>
<a name="ln2647">  if (*s &gt; 255) {</a>
<a name="ln2648">    return spell_mb_isword_class(utf_class(*s), wp);</a>
<a name="ln2649">  }</a>
<a name="ln2650">  return spelltab.st_isw[*s];</a>
<a name="ln2651">}</a>
<a name="ln2652"> </a>
<a name="ln2653">// Case-fold &quot;str[len]&quot; into &quot;buf[buflen]&quot;.  The result is NUL terminated.</a>
<a name="ln2654">// Uses the character definitions from the .spl file.</a>
<a name="ln2655">// When using a multi-byte 'encoding' the length may change!</a>
<a name="ln2656">// Returns FAIL when something wrong.</a>
<a name="ln2657">int spell_casefold(char_u *str, int len, char_u *buf, int buflen)</a>
<a name="ln2658">{</a>
<a name="ln2659">  if (len &gt;= buflen) {</a>
<a name="ln2660">    buf[0] = NUL;</a>
<a name="ln2661">    return FAIL;                // result will not fit</a>
<a name="ln2662">  }</a>
<a name="ln2663"> </a>
<a name="ln2664">  int outi = 0;</a>
<a name="ln2665"> </a>
<a name="ln2666">  // Fold one character at a time.</a>
<a name="ln2667">  for (char_u *p = str; p &lt; str + len; ) {</a>
<a name="ln2668">    if (outi + MB_MAXBYTES &gt; buflen) {</a>
<a name="ln2669">      buf[outi] = NUL;</a>
<a name="ln2670">      return FAIL;</a>
<a name="ln2671">    }</a>
<a name="ln2672">    const int c = mb_cptr2char_adv((const char_u **)&amp;p);</a>
<a name="ln2673">    outi += utf_char2bytes(SPELL_TOFOLD(c), buf + outi);</a>
<a name="ln2674">  }</a>
<a name="ln2675">  buf[outi] = NUL;</a>
<a name="ln2676"> </a>
<a name="ln2677">  return OK;</a>
<a name="ln2678">}</a>
<a name="ln2679"> </a>
<a name="ln2680">// values for sps_flags</a>
<a name="ln2681">#define SPS_BEST    1</a>
<a name="ln2682">#define SPS_FAST    2</a>
<a name="ln2683">#define SPS_DOUBLE  4</a>
<a name="ln2684"> </a>
<a name="ln2685">static int sps_flags = SPS_BEST;        // flags from 'spellsuggest'</a>
<a name="ln2686">static int sps_limit = 9999;            // max nr of suggestions given</a>
<a name="ln2687"> </a>
<a name="ln2688">// Check the 'spellsuggest' option.  Return FAIL if it's wrong.</a>
<a name="ln2689">// Sets &quot;sps_flags&quot; and &quot;sps_limit&quot;.</a>
<a name="ln2690">int spell_check_sps(void)</a>
<a name="ln2691">{</a>
<a name="ln2692">  char_u      *p;</a>
<a name="ln2693">  char_u      *s;</a>
<a name="ln2694">  char_u buf[MAXPATHL];</a>
<a name="ln2695">  int f;</a>
<a name="ln2696"> </a>
<a name="ln2697">  sps_flags = 0;</a>
<a name="ln2698">  sps_limit = 9999;</a>
<a name="ln2699"> </a>
<a name="ln2700">  for (p = p_sps; *p != NUL; ) {</a>
<a name="ln2701">    copy_option_part(&amp;p, buf, MAXPATHL, &quot;,&quot;);</a>
<a name="ln2702"> </a>
<a name="ln2703">    f = 0;</a>
<a name="ln2704">    if (ascii_isdigit(*buf)) {</a>
<a name="ln2705">      s = buf;</a>
<a name="ln2706">      sps_limit = getdigits_int(&amp;s, true, 0);</a>
<a name="ln2707">      if (*s != NUL &amp;&amp; !ascii_isdigit(*s)) {</a>
<a name="ln2708">        f = -1;</a>
<a name="ln2709">      }</a>
<a name="ln2710">    } else if (STRCMP(buf, &quot;best&quot;) == 0) {</a>
<a name="ln2711">      f = SPS_BEST;</a>
<a name="ln2712">    } else if (STRCMP(buf, &quot;fast&quot;) == 0) {</a>
<a name="ln2713">      f = SPS_FAST;</a>
<a name="ln2714">    } else if (STRCMP(buf, &quot;double&quot;) == 0) {</a>
<a name="ln2715">      f = SPS_DOUBLE;</a>
<a name="ln2716">    } else if (STRNCMP(buf, &quot;expr:&quot;, 5) != 0</a>
<a name="ln2717">               &amp;&amp; STRNCMP(buf, &quot;file:&quot;, 5) != 0) {</a>
<a name="ln2718">      f = -1;</a>
<a name="ln2719">    }</a>
<a name="ln2720"> </a>
<a name="ln2721">    if (f == -1 || (sps_flags != 0 &amp;&amp; f != 0)) {</a>
<a name="ln2722">      sps_flags = SPS_BEST;</a>
<a name="ln2723">      sps_limit = 9999;</a>
<a name="ln2724">      return FAIL;</a>
<a name="ln2725">    }</a>
<a name="ln2726">    if (f != 0)</a>
<a name="ln2727">      sps_flags = f;</a>
<a name="ln2728">  }</a>
<a name="ln2729"> </a>
<a name="ln2730">  if (sps_flags == 0)</a>
<a name="ln2731">    sps_flags = SPS_BEST;</a>
<a name="ln2732"> </a>
<a name="ln2733">  return OK;</a>
<a name="ln2734">}</a>
<a name="ln2735"> </a>
<a name="ln2736">// &quot;z=&quot;: Find badly spelled word under or after the cursor.</a>
<a name="ln2737">// Give suggestions for the properly spelled word.</a>
<a name="ln2738">// In Visual mode use the highlighted word as the bad word.</a>
<a name="ln2739">// When &quot;count&quot; is non-zero use that suggestion.</a>
<a name="ln2740">void spell_suggest(int count)</a>
<a name="ln2741">{</a>
<a name="ln2742">  char_u      *line;</a>
<a name="ln2743">  pos_T prev_cursor = curwin-&gt;w_cursor;</a>
<a name="ln2744">  char_u wcopy[MAXWLEN + 2];</a>
<a name="ln2745">  char_u      *p;</a>
<a name="ln2746">  int c;</a>
<a name="ln2747">  suginfo_T sug;</a>
<a name="ln2748">  suggest_T   *stp;</a>
<a name="ln2749">  int mouse_used;</a>
<a name="ln2750">  int need_cap;</a>
<a name="ln2751">  int limit;</a>
<a name="ln2752">  int selected = count;</a>
<a name="ln2753">  int badlen = 0;</a>
<a name="ln2754">  int msg_scroll_save = msg_scroll;</a>
<a name="ln2755"> </a>
<a name="ln2756">  if (no_spell_checking(curwin))</a>
<a name="ln2757">    return;</a>
<a name="ln2758"> </a>
<a name="ln2759">  if (VIsual_active) {</a>
<a name="ln2760">    // Use the Visually selected text as the bad word.  But reject</a>
<a name="ln2761">    // a multi-line selection.</a>
<a name="ln2762">    if (curwin-&gt;w_cursor.lnum != VIsual.lnum) {</a>
<a name="ln2763">      vim_beep(BO_SPELL);</a>
<a name="ln2764">      return;</a>
<a name="ln2765">    }</a>
<a name="ln2766">    badlen = (int)curwin-&gt;w_cursor.col - (int)VIsual.col;</a>
<a name="ln2767">    if (badlen &lt; 0) {</a>
<a name="ln2768">      badlen = -badlen;</a>
<a name="ln2769">    } else {</a>
<a name="ln2770">      curwin-&gt;w_cursor.col = VIsual.col;</a>
<a name="ln2771">    }</a>
<a name="ln2772">    badlen++;</a>
<a name="ln2773">    end_visual_mode();</a>
<a name="ln2774">  } else</a>
<a name="ln2775">  // Find the start of the badly spelled word.</a>
<a name="ln2776">  if (spell_move_to(curwin, FORWARD, true, true, NULL) == 0</a>
<a name="ln2777">      || curwin-&gt;w_cursor.col &gt; prev_cursor.col) {</a>
<a name="ln2778">    // No bad word or it starts after the cursor: use the word under the</a>
<a name="ln2779">    // cursor.</a>
<a name="ln2780">    curwin-&gt;w_cursor = prev_cursor;</a>
<a name="ln2781">    line = get_cursor_line_ptr();</a>
<a name="ln2782">    p = line + curwin-&gt;w_cursor.col;</a>
<a name="ln2783">    // Backup to before start of word.</a>
<a name="ln2784">    while (p &gt; line &amp;&amp; spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln2785">      MB_PTR_BACK(line, p);</a>
<a name="ln2786">    }</a>
<a name="ln2787">    // Forward to start of word.</a>
<a name="ln2788">    while (*p != NUL &amp;&amp; !spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln2789">      MB_PTR_ADV(p);</a>
<a name="ln2790">    }</a>
<a name="ln2791"> </a>
<a name="ln2792">    if (!spell_iswordp_nmw(p, curwin)) {                // No word found.</a>
<a name="ln2793">      beep_flush();</a>
<a name="ln2794">      return;</a>
<a name="ln2795">    }</a>
<a name="ln2796">    curwin-&gt;w_cursor.col = (colnr_T)(p - line);</a>
<a name="ln2797">  }</a>
<a name="ln2798"> </a>
<a name="ln2799">  // Get the word and its length.</a>
<a name="ln2800"> </a>
<a name="ln2801">  // Figure out if the word should be capitalised.</a>
<a name="ln2802">  need_cap = check_need_cap(curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.col);</a>
<a name="ln2803"> </a>
<a name="ln2804">  // Make a copy of current line since autocommands may free the line.</a>
<a name="ln2805">  line = vim_strsave(get_cursor_line_ptr());</a>
<a name="ln2806"> </a>
<a name="ln2807">  // Get the list of suggestions.  Limit to 'lines' - 2 or the number in</a>
<a name="ln2808">  // 'spellsuggest', whatever is smaller.</a>
<a name="ln2809">  if (sps_limit &gt; (int)Rows - 2)</a>
<a name="ln2810">    limit = (int)Rows - 2;</a>
<a name="ln2811">  else</a>
<a name="ln2812">    limit = sps_limit;</a>
<a name="ln2813">  spell_find_suggest(line + curwin-&gt;w_cursor.col, badlen, &amp;sug, limit,</a>
<a name="ln2814">      true, need_cap, true);</a>
<a name="ln2815"> </a>
<a name="ln2816">  if (GA_EMPTY(&amp;sug.su_ga))</a>
<a name="ln2817">    MSG(_(&quot;Sorry, no suggestions&quot;));</a>
<a name="ln2818">  else if (count &gt; 0) {</a>
<a name="ln2819">    if (count &gt; sug.su_ga.ga_len)</a>
<a name="ln2820">      smsg(_(&quot;Sorry, only %&quot; PRId64 &quot; suggestions&quot;),</a>
<a name="ln2821">           (int64_t)sug.su_ga.ga_len);</a>
<a name="ln2822">  } else {</a>
<a name="ln2823">    // When 'rightleft' is set the list is drawn right-left.</a>
<a name="ln2824">    cmdmsg_rl = curwin-&gt;w_p_rl;</a>
<a name="ln2825">    if (cmdmsg_rl)</a>
<a name="ln2826">      msg_col = Columns - 1;</a>
<a name="ln2827"> </a>
<a name="ln2828">    // List the suggestions.</a>
<a name="ln2829">    msg_start();</a>
<a name="ln2830">    msg_row = Rows - 1;         // for when 'cmdheight' &gt; 1</a>
<a name="ln2831">    lines_left = Rows;          // avoid more prompt</a>
<a name="ln2832">    vim_snprintf((char *)IObuff, IOSIZE, _(&quot;Change \&quot;%.*s\&quot; to:&quot;),</a>
<a name="ln2833">        sug.su_badlen, sug.su_badptr);</a>
<a name="ln2834">    if (cmdmsg_rl &amp;&amp; STRNCMP(IObuff, &quot;Change&quot;, 6) == 0) {</a>
<a name="ln2835">      // And now the rabbit from the high hat: Avoid showing the</a>
<a name="ln2836">      // untranslated message rightleft.</a>
<a name="ln2837">      vim_snprintf((char *)IObuff, IOSIZE, &quot;:ot \&quot;%.*s\&quot; egnahC&quot;,</a>
<a name="ln2838">          sug.su_badlen, sug.su_badptr);</a>
<a name="ln2839">    }</a>
<a name="ln2840">    msg_puts((const char *)IObuff);</a>
<a name="ln2841">    msg_clr_eos();</a>
<a name="ln2842">    msg_putchar('\n');</a>
<a name="ln2843"> </a>
<a name="ln2844">    msg_scroll = TRUE;</a>
<a name="ln2845">    for (int i = 0; i &lt; sug.su_ga.ga_len; ++i) {</a>
<a name="ln2846">      stp = &amp;SUG(sug.su_ga, i);</a>
<a name="ln2847"> </a>
<a name="ln2848">      // The suggested word may replace only part of the bad word, add</a>
<a name="ln2849">      // the not replaced part.</a>
<a name="ln2850">      STRLCPY(wcopy, stp-&gt;st_word, MAXWLEN + 1);</a>
<a name="ln2851">      if (sug.su_badlen &gt; stp-&gt;st_orglen)</a>
<a name="ln2852">        STRLCPY(wcopy + stp-&gt;st_wordlen,</a>
<a name="ln2853">            sug.su_badptr + stp-&gt;st_orglen,</a>
<a name="ln2854">            sug.su_badlen - stp-&gt;st_orglen + 1);</a>
<a name="ln2855">      vim_snprintf((char *)IObuff, IOSIZE, &quot;%2d&quot;, i + 1);</a>
<a name="ln2856">      if (cmdmsg_rl) {</a>
<a name="ln2857">        rl_mirror(IObuff);</a>
<a name="ln2858">      }</a>
<a name="ln2859">      msg_puts((const char *)IObuff);</a>
<a name="ln2860"> </a>
<a name="ln2861">      vim_snprintf((char *)IObuff, IOSIZE, &quot; \&quot;%s\&quot;&quot;, wcopy);</a>
<a name="ln2862">      msg_puts((const char *)IObuff);</a>
<a name="ln2863"> </a>
<a name="ln2864">      // The word may replace more than &quot;su_badlen&quot;.</a>
<a name="ln2865">      if (sug.su_badlen &lt; stp-&gt;st_orglen) {</a>
<a name="ln2866">        vim_snprintf((char *)IObuff, IOSIZE, _(&quot; &lt; \&quot;%.*s\&quot;&quot;),</a>
<a name="ln2867">                     stp-&gt;st_orglen, sug.su_badptr);</a>
<a name="ln2868">        msg_puts((const char *)IObuff);</a>
<a name="ln2869">      }</a>
<a name="ln2870"> </a>
<a name="ln2871">      if (p_verbose &gt; 0) {</a>
<a name="ln2872">        // Add the score.</a>
<a name="ln2873">        if (sps_flags &amp; (SPS_DOUBLE | SPS_BEST))</a>
<a name="ln2874">          vim_snprintf((char *)IObuff, IOSIZE, &quot; (%s%d - %d)&quot;,</a>
<a name="ln2875">              stp-&gt;st_salscore ? &quot;s &quot; : &quot;&quot;,</a>
<a name="ln2876">              stp-&gt;st_score, stp-&gt;st_altscore);</a>
<a name="ln2877">        else</a>
<a name="ln2878">          vim_snprintf((char *)IObuff, IOSIZE, &quot; (%d)&quot;,</a>
<a name="ln2879">              stp-&gt;st_score);</a>
<a name="ln2880">        if (cmdmsg_rl)</a>
<a name="ln2881">          // Mirror the numbers, but keep the leading space.</a>
<a name="ln2882">          rl_mirror(IObuff + 1);</a>
<a name="ln2883">        msg_advance(30);</a>
<a name="ln2884">        msg_puts((const char *)IObuff);</a>
<a name="ln2885">      }</a>
<a name="ln2886">      msg_putchar('\n');</a>
<a name="ln2887">    }</a>
<a name="ln2888"> </a>
<a name="ln2889">    cmdmsg_rl = FALSE;</a>
<a name="ln2890">    msg_col = 0;</a>
<a name="ln2891">    // Ask for choice.</a>
<a name="ln2892">    selected = prompt_for_number(&amp;mouse_used);</a>
<a name="ln2893"> </a>
<a name="ln2894">    if (ui_has(kUIMessages)) {</a>
<a name="ln2895">      ui_call_msg_clear();</a>
<a name="ln2896">    }</a>
<a name="ln2897"> </a>
<a name="ln2898">    if (mouse_used) {</a>
<a name="ln2899">      selected -= lines_left;</a>
<a name="ln2900">    }</a>
<a name="ln2901">    lines_left = Rows;                  // avoid more prompt</a>
<a name="ln2902">    // don't delay for 'smd' in normal_cmd()</a>
<a name="ln2903">    msg_scroll = msg_scroll_save;</a>
<a name="ln2904">  }</a>
<a name="ln2905"> </a>
<a name="ln2906">  if (selected &gt; 0 &amp;&amp; selected &lt;= sug.su_ga.ga_len &amp;&amp; u_save_cursor() == OK) {</a>
<a name="ln2907">    // Save the from and to text for :spellrepall.</a>
<a name="ln2908">    XFREE_CLEAR(repl_from);</a>
<a name="ln2909">    XFREE_CLEAR(repl_to);</a>
<a name="ln2910"> </a>
<a name="ln2911">    stp = &amp;SUG(sug.su_ga, selected - 1);</a>
<a name="ln2912">    if (sug.su_badlen &gt; stp-&gt;st_orglen) {</a>
<a name="ln2913">      // Replacing less than &quot;su_badlen&quot;, append the remainder to</a>
<a name="ln2914">      // repl_to.</a>
<a name="ln2915">      repl_from = vim_strnsave(sug.su_badptr, sug.su_badlen);</a>
<a name="ln2916">      vim_snprintf((char *)IObuff, IOSIZE, &quot;%s%.*s&quot;, stp-&gt;st_word,</a>
<a name="ln2917">          sug.su_badlen - stp-&gt;st_orglen,</a>
<a name="ln2918">          sug.su_badptr + stp-&gt;st_orglen);</a>
<a name="ln2919">      repl_to = vim_strsave(IObuff);</a>
<a name="ln2920">    } else {</a>
<a name="ln2921">      // Replacing su_badlen or more, use the whole word.</a>
<a name="ln2922">      repl_from = vim_strnsave(sug.su_badptr, stp-&gt;st_orglen);</a>
<a name="ln2923">      repl_to = vim_strsave(stp-&gt;st_word);</a>
<a name="ln2924">    }</a>
<a name="ln2925"> </a>
<a name="ln2926">    // Replace the word.</a>
<a name="ln2927">    p = xmalloc(STRLEN(line) - stp-&gt;st_orglen + stp-&gt;st_wordlen + 1);</a>
<a name="ln2928">    c = (int)(sug.su_badptr - line);</a>
<a name="ln2929">    memmove(p, line, c);</a>
<a name="ln2930">    STRCPY(p + c, stp-&gt;st_word);</a>
<a name="ln2931">    STRCAT(p, sug.su_badptr + stp-&gt;st_orglen);</a>
<a name="ln2932"> </a>
<a name="ln2933">    // For redo we use a change-word command.</a>
<a name="ln2934">    ResetRedobuff();</a>
<a name="ln2935">    AppendToRedobuff(&quot;ciw&quot;);</a>
<a name="ln2936">    AppendToRedobuffLit(p + c,</a>
<a name="ln2937">        stp-&gt;st_wordlen + sug.su_badlen - stp-&gt;st_orglen);</a>
<a name="ln2938">    AppendCharToRedobuff(ESC);</a>
<a name="ln2939"> </a>
<a name="ln2940">    // &quot;p&quot; may be freed here</a>
<a name="ln2941">    ml_replace(curwin-&gt;w_cursor.lnum, p, false);</a>
<a name="ln2942">    curwin-&gt;w_cursor.col = c;</a>
<a name="ln2943"> </a>
<a name="ln2944">    changed_bytes(curwin-&gt;w_cursor.lnum, c);</a>
<a name="ln2945">  } else</a>
<a name="ln2946">    curwin-&gt;w_cursor = prev_cursor;</a>
<a name="ln2947"> </a>
<a name="ln2948">  spell_find_cleanup(&amp;sug);</a>
<a name="ln2949">  xfree(line);</a>
<a name="ln2950">}</a>
<a name="ln2951"> </a>
<a name="ln2952">// Check if the word at line &quot;lnum&quot; column &quot;col&quot; is required to start with a</a>
<a name="ln2953">// capital.  This uses 'spellcapcheck' of the current buffer.</a>
<a name="ln2954">static bool check_need_cap(linenr_T lnum, colnr_T col)</a>
<a name="ln2955">{</a>
<a name="ln2956">  bool need_cap = false;</a>
<a name="ln2957">  char_u      *line;</a>
<a name="ln2958">  char_u      *line_copy = NULL;</a>
<a name="ln2959">  char_u      *p;</a>
<a name="ln2960">  colnr_T endcol;</a>
<a name="ln2961">  regmatch_T regmatch;</a>
<a name="ln2962"> </a>
<a name="ln2963">  if (curwin-&gt;w_s-&gt;b_cap_prog == NULL)</a>
<a name="ln2964">    return false;</a>
<a name="ln2965"> </a>
<a name="ln2966">  line = get_cursor_line_ptr();</a>
<a name="ln2967">  endcol = 0;</a>
<a name="ln2968">  if (getwhitecols(line) &gt;= (int)col) {</a>
<a name="ln2969">    // At start of line, check if previous line is empty or sentence</a>
<a name="ln2970">    // ends there.</a>
<a name="ln2971">    if (lnum == 1)</a>
<a name="ln2972">      need_cap = true;</a>
<a name="ln2973">    else {</a>
<a name="ln2974">      line = ml_get(lnum - 1);</a>
<a name="ln2975">      if (*skipwhite(line) == NUL)</a>
<a name="ln2976">        need_cap = true;</a>
<a name="ln2977">      else {</a>
<a name="ln2978">        // Append a space in place of the line break.</a>
<a name="ln2979">        line_copy = concat_str(line, (char_u *)&quot; &quot;);</a>
<a name="ln2980">        line = line_copy;</a>
<a name="ln2981">        endcol = (colnr_T)STRLEN(line);</a>
<a name="ln2982">      }</a>
<a name="ln2983">    }</a>
<a name="ln2984">  } else {</a>
<a name="ln2985">    endcol = col;</a>
<a name="ln2986">  }</a>
<a name="ln2987"> </a>
<a name="ln2988">  if (endcol &gt; 0) {</a>
<a name="ln2989">    // Check if sentence ends before the bad word.</a>
<a name="ln2990">    regmatch.regprog = curwin-&gt;w_s-&gt;b_cap_prog;</a>
<a name="ln2991">    regmatch.rm_ic = FALSE;</a>
<a name="ln2992">    p = line + endcol;</a>
<a name="ln2993">    for (;; ) {</a>
<a name="ln2994">      MB_PTR_BACK(line, p);</a>
<a name="ln2995">      if (p == line || spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln2996">        break;</a>
<a name="ln2997">      }</a>
<a name="ln2998">      if (vim_regexec(&amp;regmatch, p, 0)</a>
<a name="ln2999">          &amp;&amp; regmatch.endp[0] == line + endcol) {</a>
<a name="ln3000">        need_cap = true;</a>
<a name="ln3001">        break;</a>
<a name="ln3002">      }</a>
<a name="ln3003">    }</a>
<a name="ln3004">    curwin-&gt;w_s-&gt;b_cap_prog = regmatch.regprog;</a>
<a name="ln3005">  }</a>
<a name="ln3006"> </a>
<a name="ln3007">  xfree(line_copy);</a>
<a name="ln3008"> </a>
<a name="ln3009">  return need_cap;</a>
<a name="ln3010">}</a>
<a name="ln3011"> </a>
<a name="ln3012"> </a>
<a name="ln3013">// &quot;:spellrepall&quot;</a>
<a name="ln3014">void ex_spellrepall(exarg_T *eap)</a>
<a name="ln3015">{</a>
<a name="ln3016">  pos_T pos = curwin-&gt;w_cursor;</a>
<a name="ln3017">  char_u      *frompat;</a>
<a name="ln3018">  int addlen;</a>
<a name="ln3019">  char_u      *line;</a>
<a name="ln3020">  char_u      *p;</a>
<a name="ln3021">  bool save_ws = p_ws;</a>
<a name="ln3022">  linenr_T prev_lnum = 0;</a>
<a name="ln3023"> </a>
<a name="ln3024">  if (repl_from == NULL || repl_to == NULL) {</a>
<a name="ln3025">    EMSG(_(&quot;E752: No previous spell replacement&quot;));</a>
<a name="ln3026">    return;</a>
<a name="ln3027">  }</a>
<a name="ln3028">  addlen = (int)(STRLEN(repl_to) - STRLEN(repl_from));</a>
<a name="ln3029"> </a>
<a name="ln3030">  frompat = xmalloc(STRLEN(repl_from) + 7);</a>
<a name="ln3031">  sprintf((char *)frompat, &quot;\\V\\&lt;%s\\&gt;&quot;, repl_from);</a>
<a name="ln3032">  p_ws = false;</a>
<a name="ln3033"> </a>
<a name="ln3034">  sub_nsubs = 0;</a>
<a name="ln3035">  sub_nlines = 0;</a>
<a name="ln3036">  curwin-&gt;w_cursor.lnum = 0;</a>
<a name="ln3037">  while (!got_int) {</a>
<a name="ln3038">    if (do_search(NULL, '/', '/', frompat, 1L, SEARCH_KEEP, NULL) == 0</a>
<a name="ln3039">        || u_save_cursor() == FAIL) {</a>
<a name="ln3040">      break;</a>
<a name="ln3041">    }</a>
<a name="ln3042"> </a>
<a name="ln3043">    // Only replace when the right word isn't there yet.  This happens</a>
<a name="ln3044">    // when changing &quot;etc&quot; to &quot;etc.&quot;.</a>
<a name="ln3045">    line = get_cursor_line_ptr();</a>
<a name="ln3046">    if (addlen &lt;= 0 || STRNCMP(line + curwin-&gt;w_cursor.col,</a>
<a name="ln3047">            repl_to, STRLEN(repl_to)) != 0) {</a>
<a name="ln3048">      p = xmalloc(STRLEN(line) + addlen + 1);</a>
<a name="ln3049">      memmove(p, line, curwin-&gt;w_cursor.col);</a>
<a name="ln3050">      STRCPY(p + curwin-&gt;w_cursor.col, repl_to);</a>
<a name="ln3051">      STRCAT(p, line + curwin-&gt;w_cursor.col + STRLEN(repl_from));</a>
<a name="ln3052">      ml_replace(curwin-&gt;w_cursor.lnum, p, false);</a>
<a name="ln3053">      changed_bytes(curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.col);</a>
<a name="ln3054"> </a>
<a name="ln3055">      if (curwin-&gt;w_cursor.lnum != prev_lnum) {</a>
<a name="ln3056">        ++sub_nlines;</a>
<a name="ln3057">        prev_lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3058">      }</a>
<a name="ln3059">      ++sub_nsubs;</a>
<a name="ln3060">    }</a>
<a name="ln3061">    curwin-&gt;w_cursor.col += (colnr_T)STRLEN(repl_to);</a>
<a name="ln3062">  }</a>
<a name="ln3063"> </a>
<a name="ln3064">  p_ws = save_ws;</a>
<a name="ln3065">  curwin-&gt;w_cursor = pos;</a>
<a name="ln3066">  xfree(frompat);</a>
<a name="ln3067"> </a>
<a name="ln3068">  if (sub_nsubs == 0)</a>
<a name="ln3069">    EMSG2(_(&quot;E753: Not found: %s&quot;), repl_from);</a>
<a name="ln3070">  else</a>
<a name="ln3071">    do_sub_msg(false);</a>
<a name="ln3072">}</a>
<a name="ln3073"> </a>
<a name="ln3074">// Find spell suggestions for &quot;word&quot;.  Return them in the growarray &quot;*gap&quot; as</a>
<a name="ln3075">// a list of allocated strings.</a>
<a name="ln3076">void</a>
<a name="ln3077">spell_suggest_list (</a>
<a name="ln3078">    garray_T *gap,</a>
<a name="ln3079">    char_u *word,</a>
<a name="ln3080">    int maxcount,                   // maximum nr of suggestions</a>
<a name="ln3081">    bool need_cap,                  // 'spellcapcheck' matched</a>
<a name="ln3082">    bool interactive</a>
<a name="ln3083">)</a>
<a name="ln3084">{</a>
<a name="ln3085">  suginfo_T sug;</a>
<a name="ln3086">  suggest_T   *stp;</a>
<a name="ln3087">  char_u      *wcopy;</a>
<a name="ln3088"> </a>
<a name="ln3089">  spell_find_suggest(word, 0, &amp;sug, maxcount, false, need_cap, interactive);</a>
<a name="ln3090"> </a>
<a name="ln3091">  // Make room in &quot;gap&quot;.</a>
<a name="ln3092">  ga_init(gap, sizeof(char_u *), sug.su_ga.ga_len + 1);</a>
<a name="ln3093">  ga_grow(gap, sug.su_ga.ga_len);</a>
<a name="ln3094">  for (int i = 0; i &lt; sug.su_ga.ga_len; ++i) {</a>
<a name="ln3095">    stp = &amp;SUG(sug.su_ga, i);</a>
<a name="ln3096"> </a>
<a name="ln3097">    // The suggested word may replace only part of &quot;word&quot;, add the not</a>
<a name="ln3098">    // replaced part.</a>
<a name="ln3099">    wcopy = xmalloc(stp-&gt;st_wordlen</a>
<a name="ln3100">                    + STRLEN(sug.su_badptr + stp-&gt;st_orglen) + 1);</a>
<a name="ln3101">    STRCPY(wcopy, stp-&gt;st_word);</a>
<a name="ln3102">    STRCPY(wcopy + stp-&gt;st_wordlen, sug.su_badptr + stp-&gt;st_orglen);</a>
<a name="ln3103">    ((char_u **)gap-&gt;ga_data)[gap-&gt;ga_len++] = wcopy;</a>
<a name="ln3104">  }</a>
<a name="ln3105"> </a>
<a name="ln3106">  spell_find_cleanup(&amp;sug);</a>
<a name="ln3107">}</a>
<a name="ln3108"> </a>
<a name="ln3109">// Find spell suggestions for the word at the start of &quot;badptr&quot;.</a>
<a name="ln3110">// Return the suggestions in &quot;su-&gt;su_ga&quot;.</a>
<a name="ln3111">// The maximum number of suggestions is &quot;maxcount&quot;.</a>
<a name="ln3112">// Note: does use info for the current window.</a>
<a name="ln3113">// This is based on the mechanisms of Aspell, but completely reimplemented.</a>
<a name="ln3114">static void</a>
<a name="ln3115">spell_find_suggest (</a>
<a name="ln3116">    char_u *badptr,</a>
<a name="ln3117">    int badlen,                     // length of bad word or 0 if unknown</a>
<a name="ln3118">    suginfo_T *su,</a>
<a name="ln3119">    int maxcount,</a>
<a name="ln3120">    bool banbadword,                 // don't include badword in suggestions</a>
<a name="ln3121">    bool need_cap,                  // word should start with capital</a>
<a name="ln3122">    bool interactive</a>
<a name="ln3123">)</a>
<a name="ln3124">{</a>
<a name="ln3125">  hlf_T attr = HLF_COUNT;</a>
<a name="ln3126">  char_u buf[MAXPATHL];</a>
<a name="ln3127">  char_u      *p;</a>
<a name="ln3128">  bool do_combine = false;</a>
<a name="ln3129">  char_u      *sps_copy;</a>
<a name="ln3130">  static bool expr_busy = false;</a>
<a name="ln3131">  int c;</a>
<a name="ln3132">  langp_T     *lp;</a>
<a name="ln3133">  bool did_intern = false;</a>
<a name="ln3134"> </a>
<a name="ln3135">  // Set the info in &quot;*su&quot;.</a>
<a name="ln3136">  memset(su, 0, sizeof(suginfo_T));</a>
<a name="ln3137">  ga_init(&amp;su-&gt;su_ga, (int)sizeof(suggest_T), 10);</a>
<a name="ln3138">  ga_init(&amp;su-&gt;su_sga, (int)sizeof(suggest_T), 10);</a>
<a name="ln3139">  if (*badptr == NUL)</a>
<a name="ln3140">    return;</a>
<a name="ln3141">  hash_init(&amp;su-&gt;su_banned);</a>
<a name="ln3142"> </a>
<a name="ln3143">  su-&gt;su_badptr = badptr;</a>
<a name="ln3144">  if (badlen != 0)</a>
<a name="ln3145">    su-&gt;su_badlen = badlen;</a>
<a name="ln3146">  else {</a>
<a name="ln3147">    size_t tmplen = spell_check(curwin, su-&gt;su_badptr, &amp;attr, NULL, false);</a>
<a name="ln3148">    assert(tmplen &lt;= INT_MAX);</a>
<a name="ln3149">    su-&gt;su_badlen = (int)tmplen;</a>
<a name="ln3150">  }</a>
<a name="ln3151">  su-&gt;su_maxcount = maxcount;</a>
<a name="ln3152">  su-&gt;su_maxscore = SCORE_MAXINIT;</a>
<a name="ln3153"> </a>
<a name="ln3154">  if (su-&gt;su_badlen &gt;= MAXWLEN)</a>
<a name="ln3155">    su-&gt;su_badlen = MAXWLEN - 1;        // just in case</a>
<a name="ln3156">  STRLCPY(su-&gt;su_badword, su-&gt;su_badptr, su-&gt;su_badlen + 1);</a>
<a name="ln3157">  (void)spell_casefold(su-&gt;su_badptr, su-&gt;su_badlen, su-&gt;su_fbadword, MAXWLEN);</a>
<a name="ln3158"> </a>
<a name="ln3159">  // TODO(vim): make this work if the case-folded text is longer than the</a>
<a name="ln3160">  // original text. Currently an illegal byte causes wrong pointer</a>
<a name="ln3161">  // computations.</a>
<a name="ln3162">  su-&gt;su_fbadword[su-&gt;su_badlen] = NUL;</a>
<a name="ln3163"> </a>
<a name="ln3164">  // get caps flags for bad word</a>
<a name="ln3165">  su-&gt;su_badflags = badword_captype(su-&gt;su_badptr,</a>
<a name="ln3166">      su-&gt;su_badptr + su-&gt;su_badlen);</a>
<a name="ln3167">  if (need_cap)</a>
<a name="ln3168">    su-&gt;su_badflags |= WF_ONECAP;</a>
<a name="ln3169"> </a>
<a name="ln3170">  // Find the default language for sound folding.  We simply use the first</a>
<a name="ln3171">  // one in 'spelllang' that supports sound folding.  That's good for when</a>
<a name="ln3172">  // using multiple files for one language, it's not that bad when mixing</a>
<a name="ln3173">  // languages (e.g., &quot;pl,en&quot;).</a>
<a name="ln3174">  for (int i = 0; i &lt; curbuf-&gt;b_s.b_langp.ga_len; ++i) {</a>
<a name="ln3175">    lp = LANGP_ENTRY(curbuf-&gt;b_s.b_langp, i);</a>
<a name="ln3176">    if (lp-&gt;lp_sallang != NULL) {</a>
<a name="ln3177">      su-&gt;su_sallang = lp-&gt;lp_sallang;</a>
<a name="ln3178">      break;</a>
<a name="ln3179">    }</a>
<a name="ln3180">  }</a>
<a name="ln3181"> </a>
<a name="ln3182">  // Soundfold the bad word with the default sound folding, so that we don't</a>
<a name="ln3183">  // have to do this many times.</a>
<a name="ln3184">  if (su-&gt;su_sallang != NULL)</a>
<a name="ln3185">    spell_soundfold(su-&gt;su_sallang, su-&gt;su_fbadword, true,</a>
<a name="ln3186">        su-&gt;su_sal_badword);</a>
<a name="ln3187"> </a>
<a name="ln3188">  // If the word is not capitalised and spell_check() doesn't consider the</a>
<a name="ln3189">  // word to be bad then it might need to be capitalised.  Add a suggestion</a>
<a name="ln3190">  // for that.</a>
<a name="ln3191">  c = PTR2CHAR(su-&gt;su_badptr);</a>
<a name="ln3192">  if (!SPELL_ISUPPER(c) &amp;&amp; attr == HLF_COUNT) {</a>
<a name="ln3193">    make_case_word(su-&gt;su_badword, buf, WF_ONECAP);</a>
<a name="ln3194">    add_suggestion(su, &amp;su-&gt;su_ga, buf, su-&gt;su_badlen, SCORE_ICASE,</a>
<a name="ln3195">        0, true, su-&gt;su_sallang, false);</a>
<a name="ln3196">  }</a>
<a name="ln3197"> </a>
<a name="ln3198">  // Ban the bad word itself.  It may appear in another region.</a>
<a name="ln3199">  if (banbadword)</a>
<a name="ln3200">    add_banned(su, su-&gt;su_badword);</a>
<a name="ln3201"> </a>
<a name="ln3202">  // Make a copy of 'spellsuggest', because the expression may change it.</a>
<a name="ln3203">  sps_copy = vim_strsave(p_sps);</a>
<a name="ln3204"> </a>
<a name="ln3205">  // Loop over the items in 'spellsuggest'.</a>
<a name="ln3206">  for (p = sps_copy; *p != NUL; ) {</a>
<a name="ln3207">    copy_option_part(&amp;p, buf, MAXPATHL, &quot;,&quot;);</a>
<a name="ln3208"> </a>
<a name="ln3209">    if (STRNCMP(buf, &quot;expr:&quot;, 5) == 0) {</a>
<a name="ln3210">      // Evaluate an expression.  Skip this when called recursively,</a>
<a name="ln3211">      // when using spellsuggest() in the expression.</a>
<a name="ln3212">      if (!expr_busy) {</a>
<a name="ln3213">        expr_busy = true;</a>
<a name="ln3214">        spell_suggest_expr(su, buf + 5);</a>
<a name="ln3215">        expr_busy = false;</a>
<a name="ln3216">      }</a>
<a name="ln3217">    } else if (STRNCMP(buf, &quot;file:&quot;, 5) == 0) {</a>
<a name="ln3218">      // Use list of suggestions in a file.</a>
<a name="ln3219">      spell_suggest_file(su, buf + 5);</a>
<a name="ln3220">    } else if (!did_intern) {</a>
<a name="ln3221">      // Use internal method once.</a>
<a name="ln3222">      spell_suggest_intern(su, interactive);</a>
<a name="ln3223">      if (sps_flags &amp; SPS_DOUBLE) {</a>
<a name="ln3224">        do_combine = true;</a>
<a name="ln3225">      }</a>
<a name="ln3226">      did_intern = true;</a>
<a name="ln3227">    }</a>
<a name="ln3228">  }</a>
<a name="ln3229"> </a>
<a name="ln3230">  xfree(sps_copy);</a>
<a name="ln3231"> </a>
<a name="ln3232">  if (do_combine)</a>
<a name="ln3233">    // Combine the two list of suggestions.  This must be done last,</a>
<a name="ln3234">    // because sorting changes the order again.</a>
<a name="ln3235">    score_combine(su);</a>
<a name="ln3236">}</a>
<a name="ln3237"> </a>
<a name="ln3238">// Find suggestions by evaluating expression &quot;expr&quot;.</a>
<a name="ln3239">static void spell_suggest_expr(suginfo_T *su, char_u *expr)</a>
<a name="ln3240">{</a>
<a name="ln3241">  int score;</a>
<a name="ln3242">  const char *p;</a>
<a name="ln3243"> </a>
<a name="ln3244">  // The work is split up in a few parts to avoid having to export</a>
<a name="ln3245">  // suginfo_T.</a>
<a name="ln3246">  // First evaluate the expression and get the resulting list.</a>
<a name="ln3247">  list_T *const list = eval_spell_expr(su-&gt;su_badword, expr);</a>
<a name="ln3248">  if (list != NULL) {</a>
<a name="ln3249">    // Loop over the items in the list.</a>
<a name="ln3250">    TV_LIST_ITER(list, li, {</a>
<a name="ln3251">      if (TV_LIST_ITEM_TV(li)-&gt;v_type == VAR_LIST) {</a>
<a name="ln3252">        // Get the word and the score from the items.</a>
<a name="ln3253">        score = get_spellword(TV_LIST_ITEM_TV(li)-&gt;vval.v_list, &amp;p);</a>
<a name="ln3254">        if (score &gt;= 0 &amp;&amp; score &lt;= su-&gt;su_maxscore) {</a>
<a name="ln3255">          add_suggestion(su, &amp;su-&gt;su_ga, (const char_u *)p, su-&gt;su_badlen,</a>
<a name="ln3256">                         score, 0, true, su-&gt;su_sallang, false);</a>
<a name="ln3257">        }</a>
<a name="ln3258">      }</a>
<a name="ln3259">    });</a>
<a name="ln3260">    tv_list_unref(list);</a>
<a name="ln3261">  }</a>
<a name="ln3262"> </a>
<a name="ln3263">  // Remove bogus suggestions, sort and truncate at &quot;maxcount&quot;.</a>
<a name="ln3264">  check_suggestions(su, &amp;su-&gt;su_ga);</a>
<a name="ln3265">  (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln3266">}</a>
<a name="ln3267"> </a>
<a name="ln3268">// Find suggestions in file &quot;fname&quot;.  Used for &quot;file:&quot; in 'spellsuggest'.</a>
<a name="ln3269">static void spell_suggest_file(suginfo_T *su, char_u *fname)</a>
<a name="ln3270">{</a>
<a name="ln3271">  FILE        *fd;</a>
<a name="ln3272">  char_u line[MAXWLEN * 2];</a>
<a name="ln3273">  char_u      *p;</a>
<a name="ln3274">  int len;</a>
<a name="ln3275">  char_u cword[MAXWLEN];</a>
<a name="ln3276"> </a>
<a name="ln3277">  // Open the file.</a>
<a name="ln3278">  fd = os_fopen((char *)fname, &quot;r&quot;);</a>
<a name="ln3279">  if (fd == NULL) {</a>
<a name="ln3280">    EMSG2(_(e_notopen), fname);</a>
<a name="ln3281">    return;</a>
<a name="ln3282">  }</a>
<a name="ln3283"> </a>
<a name="ln3284">  // Read it line by line.</a>
<a name="ln3285">  while (!vim_fgets(line, MAXWLEN * 2, fd) &amp;&amp; !got_int) {</a>
<a name="ln3286">    line_breakcheck();</a>
<a name="ln3287"> </a>
<a name="ln3288">    p = vim_strchr(line, '/');</a>
<a name="ln3289">    if (p == NULL)</a>
<a name="ln3290">      continue;             // No Tab found, just skip the line.</a>
<a name="ln3291">    *p++ = NUL;</a>
<a name="ln3292">    if (STRICMP(su-&gt;su_badword, line) == 0) {</a>
<a name="ln3293">      // Match!  Isolate the good word, until CR or NL.</a>
<a name="ln3294">      for (len = 0; p[len] &gt;= ' '; ++len)</a>
<a name="ln3295">        ;</a>
<a name="ln3296">      p[len] = NUL;</a>
<a name="ln3297"> </a>
<a name="ln3298">      // If the suggestion doesn't have specific case duplicate the case</a>
<a name="ln3299">      // of the bad word.</a>
<a name="ln3300">      if (captype(p, NULL) == 0) {</a>
<a name="ln3301">        make_case_word(p, cword, su-&gt;su_badflags);</a>
<a name="ln3302">        p = cword;</a>
<a name="ln3303">      }</a>
<a name="ln3304"> </a>
<a name="ln3305">      add_suggestion(su, &amp;su-&gt;su_ga, p, su-&gt;su_badlen,</a>
<a name="ln3306">          SCORE_FILE, 0, true, su-&gt;su_sallang, false);</a>
<a name="ln3307">    }</a>
<a name="ln3308">  }</a>
<a name="ln3309"> </a>
<a name="ln3310">  fclose(fd);</a>
<a name="ln3311"> </a>
<a name="ln3312">  // Remove bogus suggestions, sort and truncate at &quot;maxcount&quot;.</a>
<a name="ln3313">  check_suggestions(su, &amp;su-&gt;su_ga);</a>
<a name="ln3314">  (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln3315">}</a>
<a name="ln3316"> </a>
<a name="ln3317">// Find suggestions for the internal method indicated by &quot;sps_flags&quot;.</a>
<a name="ln3318">static void spell_suggest_intern(suginfo_T *su, bool interactive)</a>
<a name="ln3319">{</a>
<a name="ln3320">  // Load the .sug file(s) that are available and not done yet.</a>
<a name="ln3321">  suggest_load_files();</a>
<a name="ln3322"> </a>
<a name="ln3323">  // 1. Try special cases, such as repeating a word: &quot;the the&quot; -&gt; &quot;the&quot;.</a>
<a name="ln3324">  //</a>
<a name="ln3325">  // Set a maximum score to limit the combination of operations that is</a>
<a name="ln3326">  // tried.</a>
<a name="ln3327">  suggest_try_special(su);</a>
<a name="ln3328"> </a>
<a name="ln3329">  // 2. Try inserting/deleting/swapping/changing a letter, use REP entries</a>
<a name="ln3330">  //    from the .aff file and inserting a space (split the word).</a>
<a name="ln3331">  suggest_try_change(su);</a>
<a name="ln3332"> </a>
<a name="ln3333">  // For the resulting top-scorers compute the sound-a-like score.</a>
<a name="ln3334">  if (sps_flags &amp; SPS_DOUBLE)</a>
<a name="ln3335">    score_comp_sal(su);</a>
<a name="ln3336"> </a>
<a name="ln3337">  // 3. Try finding sound-a-like words.</a>
<a name="ln3338">  if ((sps_flags &amp; SPS_FAST) == 0) {</a>
<a name="ln3339">    if (sps_flags &amp; SPS_BEST)</a>
<a name="ln3340">      // Adjust the word score for the suggestions found so far for how</a>
<a name="ln3341">      // they sounds like.</a>
<a name="ln3342">      rescore_suggestions(su);</a>
<a name="ln3343"> </a>
<a name="ln3344">    // While going through the soundfold tree &quot;su_maxscore&quot; is the score</a>
<a name="ln3345">    // for the soundfold word, limits the changes that are being tried,</a>
<a name="ln3346">    // and &quot;su_sfmaxscore&quot; the rescored score, which is set by</a>
<a name="ln3347">    // cleanup_suggestions().</a>
<a name="ln3348">    // First find words with a small edit distance, because this is much</a>
<a name="ln3349">    // faster and often already finds the top-N suggestions.  If we didn't</a>
<a name="ln3350">    // find many suggestions try again with a higher edit distance.</a>
<a name="ln3351">    // &quot;sl_sounddone&quot; is used to avoid doing the same word twice.</a>
<a name="ln3352">    suggest_try_soundalike_prep();</a>
<a name="ln3353">    su-&gt;su_maxscore = SCORE_SFMAX1;</a>
<a name="ln3354">    su-&gt;su_sfmaxscore = SCORE_MAXINIT * 3;</a>
<a name="ln3355">    suggest_try_soundalike(su);</a>
<a name="ln3356">    if (su-&gt;su_ga.ga_len &lt; SUG_CLEAN_COUNT(su)) {</a>
<a name="ln3357">      // We didn't find enough matches, try again, allowing more</a>
<a name="ln3358">      // changes to the soundfold word.</a>
<a name="ln3359">      su-&gt;su_maxscore = SCORE_SFMAX2;</a>
<a name="ln3360">      suggest_try_soundalike(su);</a>
<a name="ln3361">      if (su-&gt;su_ga.ga_len &lt; SUG_CLEAN_COUNT(su)) {</a>
<a name="ln3362">        // Still didn't find enough matches, try again, allowing even</a>
<a name="ln3363">        // more changes to the soundfold word.</a>
<a name="ln3364">        su-&gt;su_maxscore = SCORE_SFMAX3;</a>
<a name="ln3365">        suggest_try_soundalike(su);</a>
<a name="ln3366">      }</a>
<a name="ln3367">    }</a>
<a name="ln3368">    su-&gt;su_maxscore = su-&gt;su_sfmaxscore;</a>
<a name="ln3369">    suggest_try_soundalike_finish();</a>
<a name="ln3370">  }</a>
<a name="ln3371"> </a>
<a name="ln3372">  // When CTRL-C was hit while searching do show the results.  Only clear</a>
<a name="ln3373">  // got_int when using a command, not for spellsuggest().</a>
<a name="ln3374">  os_breakcheck();</a>
<a name="ln3375">  if (interactive &amp;&amp; got_int) {</a>
<a name="ln3376">    (void)vgetc();</a>
<a name="ln3377">    got_int = FALSE;</a>
<a name="ln3378">  }</a>
<a name="ln3379"> </a>
<a name="ln3380">  if ((sps_flags &amp; SPS_DOUBLE) == 0 &amp;&amp; su-&gt;su_ga.ga_len != 0) {</a>
<a name="ln3381">    if (sps_flags &amp; SPS_BEST)</a>
<a name="ln3382">      // Adjust the word score for how it sounds like.</a>
<a name="ln3383">      rescore_suggestions(su);</a>
<a name="ln3384"> </a>
<a name="ln3385">    // Remove bogus suggestions, sort and truncate at &quot;maxcount&quot;.</a>
<a name="ln3386">    check_suggestions(su, &amp;su-&gt;su_ga);</a>
<a name="ln3387">    (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln3388">  }</a>
<a name="ln3389">}</a>
<a name="ln3390"> </a>
<a name="ln3391">// Free the info put in &quot;*su&quot; by spell_find_suggest().</a>
<a name="ln3392">static void spell_find_cleanup(suginfo_T *su)</a>
<a name="ln3393">{</a>
<a name="ln3394"># define FREE_SUG_WORD(sug) xfree(sug-&gt;st_word)</a>
<a name="ln3395">  // Free the suggestions.</a>
<a name="ln3396">  GA_DEEP_CLEAR(&amp;su-&gt;su_ga, suggest_T, FREE_SUG_WORD);</a>
<a name="ln3397">  GA_DEEP_CLEAR(&amp;su-&gt;su_sga, suggest_T, FREE_SUG_WORD);</a>
<a name="ln3398"> </a>
<a name="ln3399">  // Free the banned words.</a>
<a name="ln3400">  hash_clear_all(&amp;su-&gt;su_banned, 0);</a>
<a name="ln3401">}</a>
<a name="ln3402"> </a>
<a name="ln3403">/// Make a copy of &quot;word&quot;, with the first letter upper or lower cased, to</a>
<a name="ln3404">/// &quot;wcopy[MAXWLEN]&quot;.  &quot;word&quot; must not be empty.</a>
<a name="ln3405">/// The result is NUL terminated.</a>
<a name="ln3406">///</a>
<a name="ln3407">/// @param[in]  word  source string to copy</a>
<a name="ln3408">/// @param[in,out]  wcopy  copied string, with case of first letter changed</a>
<a name="ln3409">/// @param[in]  upper  True to upper case, otherwise lower case</a>
<a name="ln3410">void onecap_copy(char_u *word, char_u *wcopy, bool upper)</a>
<a name="ln3411">{</a>
<a name="ln3412">  char_u *p = word;</a>
<a name="ln3413">  int c = mb_cptr2char_adv((const char_u **)&amp;p);</a>
<a name="ln3414">  if (upper) {</a>
<a name="ln3415">    c = SPELL_TOUPPER(c);</a>
<a name="ln3416">  } else {</a>
<a name="ln3417">    c = SPELL_TOFOLD(c);</a>
<a name="ln3418">  }</a>
<a name="ln3419">  int l = utf_char2bytes(c, wcopy);</a>
<a name="ln3420">  STRLCPY(wcopy + l, p, MAXWLEN - l);</a>
<a name="ln3421">}</a>
<a name="ln3422"> </a>
<a name="ln3423">// Make a copy of &quot;word&quot; with all the letters upper cased into</a>
<a name="ln3424">// &quot;wcopy[MAXWLEN]&quot;.  The result is NUL terminated.</a>
<a name="ln3425">static void allcap_copy(char_u *word, char_u *wcopy)</a>
<a name="ln3426">{</a>
<a name="ln3427">  char_u *d = wcopy;</a>
<a name="ln3428">  for (char_u *s = word; *s != NUL; ) {</a>
<a name="ln3429">    int c = mb_cptr2char_adv((const char_u **)&amp;s);</a>
<a name="ln3430"> </a>
<a name="ln3431">    if (c == 0xdf) {</a>
<a name="ln3432">      c = 'S';</a>
<a name="ln3433">      if (d - wcopy &gt;= MAXWLEN - 1)</a>
<a name="ln3434">        break;</a>
<a name="ln3435">      *d++ = c;</a>
<a name="ln3436">    } else</a>
<a name="ln3437">      c = SPELL_TOUPPER(c);</a>
<a name="ln3438"> </a>
<a name="ln3439">    if (d - wcopy &gt;= MAXWLEN - MB_MAXBYTES) {</a>
<a name="ln3440">      break;</a>
<a name="ln3441">    }</a>
<a name="ln3442">    d += utf_char2bytes(c, d);</a>
<a name="ln3443">  }</a>
<a name="ln3444">  *d = NUL;</a>
<a name="ln3445">}</a>
<a name="ln3446"> </a>
<a name="ln3447">// Try finding suggestions by recognizing specific situations.</a>
<a name="ln3448">static void suggest_try_special(suginfo_T *su)</a>
<a name="ln3449">{</a>
<a name="ln3450">  char_u      *p;</a>
<a name="ln3451">  size_t len;</a>
<a name="ln3452">  int c;</a>
<a name="ln3453">  char_u word[MAXWLEN];</a>
<a name="ln3454"> </a>
<a name="ln3455">  // Recognize a word that is repeated: &quot;the the&quot;.</a>
<a name="ln3456">  p = skiptowhite(su-&gt;su_fbadword);</a>
<a name="ln3457">  len = p - su-&gt;su_fbadword;</a>
<a name="ln3458">  p = skipwhite(p);</a>
<a name="ln3459">  if (STRLEN(p) == len &amp;&amp; STRNCMP(su-&gt;su_fbadword, p, len) == 0) {</a>
<a name="ln3460">    // Include badflags: if the badword is onecap or allcap</a>
<a name="ln3461">    // use that for the goodword too: &quot;The the&quot; -&gt; &quot;The&quot;.</a>
<a name="ln3462">    c = su-&gt;su_fbadword[len];</a>
<a name="ln3463">    su-&gt;su_fbadword[len] = NUL;</a>
<a name="ln3464">    make_case_word(su-&gt;su_fbadword, word, su-&gt;su_badflags);</a>
<a name="ln3465">    su-&gt;su_fbadword[len] = c;</a>
<a name="ln3466"> </a>
<a name="ln3467">    // Give a soundalike score of 0, compute the score as if deleting one</a>
<a name="ln3468">    // character.</a>
<a name="ln3469">    add_suggestion(su, &amp;su-&gt;su_ga, word, su-&gt;su_badlen,</a>
<a name="ln3470">        RESCORE(SCORE_REP, 0), 0, true, su-&gt;su_sallang, false);</a>
<a name="ln3471">  }</a>
<a name="ln3472">}</a>
<a name="ln3473"> </a>
<a name="ln3474">// Measure how much time is spent in each state.</a>
<a name="ln3475">// Output is dumped in &quot;suggestprof&quot;.</a>
<a name="ln3476"> </a>
<a name="ln3477">#ifdef SUGGEST_PROFILE</a>
<a name="ln3478">proftime_T current;</a>
<a name="ln3479">proftime_T total;</a>
<a name="ln3480">proftime_T times[STATE_FINAL + 1];</a>
<a name="ln3481">long counts[STATE_FINAL + 1];</a>
<a name="ln3482"> </a>
<a name="ln3483">  static void</a>
<a name="ln3484">prof_init(void)</a>
<a name="ln3485">{</a>
<a name="ln3486">  for (int i = 0; i &lt;= STATE_FINAL; i++) {</a>
<a name="ln3487">    profile_zero(&amp;times[i]);</a>
<a name="ln3488">    counts[i] = 0;</a>
<a name="ln3489">  }</a>
<a name="ln3490">  profile_start(&amp;current);</a>
<a name="ln3491">  profile_start(&amp;total);</a>
<a name="ln3492">}</a>
<a name="ln3493"> </a>
<a name="ln3494">// call before changing state</a>
<a name="ln3495">  static void</a>
<a name="ln3496">prof_store(state_T state)</a>
<a name="ln3497">{</a>
<a name="ln3498">  profile_end(&amp;current);</a>
<a name="ln3499">  profile_add(&amp;times[state], &amp;current);</a>
<a name="ln3500">  counts[state]++;</a>
<a name="ln3501">  profile_start(&amp;current);</a>
<a name="ln3502">}</a>
<a name="ln3503"># define PROF_STORE(state) prof_store(state);</a>
<a name="ln3504"> </a>
<a name="ln3505">  static void</a>
<a name="ln3506">prof_report(char *name)</a>
<a name="ln3507">{</a>
<a name="ln3508">  FILE *fd = fopen(&quot;suggestprof&quot;, &quot;a&quot;);</a>
<a name="ln3509"> </a>
<a name="ln3510">  profile_end(&amp;total);</a>
<a name="ln3511">  fprintf(fd, &quot;-----------------------\n&quot;);</a>
<a name="ln3512">  fprintf(fd, &quot;%s: %s\n&quot;, name, profile_msg(&amp;total));</a>
<a name="ln3513">  for (int i = 0; i &lt;= STATE_FINAL; i++) {</a>
<a name="ln3514">    fprintf(fd, &quot;%d: %s (&quot;%&quot; PRId64)\n&quot;, i, profile_msg(&amp;times[i]), counts[i]);</a>
<a name="ln3515">  }</a>
<a name="ln3516">  fclose(fd);</a>
<a name="ln3517">}</a>
<a name="ln3518">#else</a>
<a name="ln3519"># define PROF_STORE(state)</a>
<a name="ln3520">#endif</a>
<a name="ln3521"> </a>
<a name="ln3522">// Try finding suggestions by adding/removing/swapping letters.</a>
<a name="ln3523"> </a>
<a name="ln3524">static void suggest_try_change(suginfo_T *su)</a>
<a name="ln3525">{</a>
<a name="ln3526">  char_u fword[MAXWLEN];            // copy of the bad word, case-folded</a>
<a name="ln3527">  int n;</a>
<a name="ln3528">  char_u      *p;</a>
<a name="ln3529">  langp_T     *lp;</a>
<a name="ln3530"> </a>
<a name="ln3531">  // We make a copy of the case-folded bad word, so that we can modify it</a>
<a name="ln3532">  // to find matches (esp. REP items).  Append some more text, changing</a>
<a name="ln3533">  // chars after the bad word may help.</a>
<a name="ln3534">  STRCPY(fword, su-&gt;su_fbadword);</a>
<a name="ln3535">  n = (int)STRLEN(fword);</a>
<a name="ln3536">  p = su-&gt;su_badptr + su-&gt;su_badlen;</a>
<a name="ln3537">  (void)spell_casefold(p, (int)STRLEN(p), fword + n, MAXWLEN - n);</a>
<a name="ln3538"> </a>
<a name="ln3539">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln3540">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln3541"> </a>
<a name="ln3542">    // If reloading a spell file fails it's still in the list but</a>
<a name="ln3543">    // everything has been cleared.</a>
<a name="ln3544">    if (lp-&gt;lp_slang-&gt;sl_fbyts == NULL)</a>
<a name="ln3545">      continue;</a>
<a name="ln3546"> </a>
<a name="ln3547">    // Try it for this language.  Will add possible suggestions.</a>
<a name="ln3548">    //</a>
<a name="ln3549">#ifdef SUGGEST_PROFILE</a>
<a name="ln3550">    prof_init();</a>
<a name="ln3551">#endif</a>
<a name="ln3552">    suggest_trie_walk(su, lp, fword, false);</a>
<a name="ln3553">#ifdef SUGGEST_PROFILE</a>
<a name="ln3554">    prof_report(&quot;try_change&quot;);</a>
<a name="ln3555">#endif</a>
<a name="ln3556">  }</a>
<a name="ln3557">}</a>
<a name="ln3558"> </a>
<a name="ln3559">// Check the maximum score, if we go over it we won't try this change.</a>
<a name="ln3560">#define TRY_DEEPER(su, stack, depth, add) \</a>
<a name="ln3561">  (stack[depth].ts_score + (add) &lt; su-&gt;su_maxscore)</a>
<a name="ln3562"> </a>
<a name="ln3563">// Try finding suggestions by adding/removing/swapping letters.</a>
<a name="ln3564">//</a>
<a name="ln3565">// This uses a state machine.  At each node in the tree we try various</a>
<a name="ln3566">// operations.  When trying if an operation works &quot;depth&quot; is increased and the</a>
<a name="ln3567">// stack[] is used to store info.  This allows combinations, thus insert one</a>
<a name="ln3568">// character, replace one and delete another.  The number of changes is</a>
<a name="ln3569">// limited by su-&gt;su_maxscore.</a>
<a name="ln3570">//</a>
<a name="ln3571">// After implementing this I noticed an article by Kemal Oflazer that</a>
<a name="ln3572">// describes something similar: &quot;Error-tolerant Finite State Recognition with</a>
<a name="ln3573">// Applications to Morphological Analysis and Spelling Correction&quot; (1996).</a>
<a name="ln3574">// The implementation in the article is simplified and requires a stack of</a>
<a name="ln3575">// unknown depth.  The implementation here only needs a stack depth equal to</a>
<a name="ln3576">// the length of the word.</a>
<a name="ln3577">//</a>
<a name="ln3578">// This is also used for the sound-folded word, &quot;soundfold&quot; is true then.</a>
<a name="ln3579">// The mechanism is the same, but we find a match with a sound-folded word</a>
<a name="ln3580">// that comes from one or more original words.  Each of these words may be</a>
<a name="ln3581">// added, this is done by add_sound_suggest().</a>
<a name="ln3582">// Don't use:</a>
<a name="ln3583">//      the prefix tree or the keep-case tree</a>
<a name="ln3584">//      &quot;su-&gt;su_badlen&quot;</a>
<a name="ln3585">//      anything to do with upper and lower case</a>
<a name="ln3586">//      anything to do with word or non-word characters (&quot;spell_iswordp()&quot;)</a>
<a name="ln3587">//      banned words</a>
<a name="ln3588">//      word flags (rare, region, compounding)</a>
<a name="ln3589">//      word splitting for now</a>
<a name="ln3590">//      &quot;similar_chars()&quot;</a>
<a name="ln3591">//      use &quot;slang-&gt;sl_repsal&quot; instead of &quot;lp-&gt;lp_replang-&gt;sl_rep&quot;</a>
<a name="ln3592">static void suggest_trie_walk(suginfo_T *su, langp_T *lp, char_u *fword, bool soundfold)</a>
<a name="ln3593">{</a>
<a name="ln3594">  char_u tword[MAXWLEN];            // good word collected so far</a>
<a name="ln3595">  trystate_T stack[MAXWLEN];</a>
<a name="ln3596">  char_u preword[MAXWLEN * 3] = { 0 };  // word found with proper case;</a>
<a name="ln3597">                                    // concatenation of prefix compound</a>
<a name="ln3598">                                    // words and split word.  NUL terminated</a>
<a name="ln3599">                                    // when going deeper but not when coming</a>
<a name="ln3600">                                    // back.</a>
<a name="ln3601">  char_u compflags[MAXWLEN];        // compound flags, one for each word</a>
<a name="ln3602">  trystate_T  *sp;</a>
<a name="ln3603">  int newscore;</a>
<a name="ln3604">  int score;</a>
<a name="ln3605">  char_u      *byts, *fbyts, *pbyts;</a>
<a name="ln3606">  idx_T       *idxs, *fidxs, *pidxs;</a>
<a name="ln3607">  int depth;</a>
<a name="ln3608">  int c, c2, c3;</a>
<a name="ln3609">  int n = 0;</a>
<a name="ln3610">  int flags;</a>
<a name="ln3611">  garray_T    *gap;</a>
<a name="ln3612">  idx_T arridx;</a>
<a name="ln3613">  int len;</a>
<a name="ln3614">  char_u      *p;</a>
<a name="ln3615">  fromto_T    *ftp;</a>
<a name="ln3616">  int fl = 0, tl;</a>
<a name="ln3617">  int repextra = 0;                 // extra bytes in fword[] from REP item</a>
<a name="ln3618">  slang_T     *slang = lp-&gt;lp_slang;</a>
<a name="ln3619">  int fword_ends;</a>
<a name="ln3620">  bool goodword_ends;</a>
<a name="ln3621">#ifdef DEBUG_TRIEWALK</a>
<a name="ln3622">  // Stores the name of the change made at each level.</a>
<a name="ln3623">  char_u changename[MAXWLEN][80];</a>
<a name="ln3624">#endif</a>
<a name="ln3625">  int breakcheckcount = 1000;</a>
<a name="ln3626">  bool compound_ok;</a>
<a name="ln3627"> </a>
<a name="ln3628">  // Go through the whole case-fold tree, try changes at each node.</a>
<a name="ln3629">  // &quot;tword[]&quot; contains the word collected from nodes in the tree.</a>
<a name="ln3630">  // &quot;fword[]&quot; the word we are trying to match with (initially the bad</a>
<a name="ln3631">  // word).</a>
<a name="ln3632">  depth = 0;</a>
<a name="ln3633">  sp = &amp;stack[0];</a>
<a name="ln3634">  memset(sp, 0, sizeof(trystate_T));  // -V512</a>
<a name="ln3635">  sp-&gt;ts_curi = 1;</a>
<a name="ln3636"> </a>
<a name="ln3637">  if (soundfold) {</a>
<a name="ln3638">    // Going through the soundfold tree.</a>
<a name="ln3639">    byts = fbyts = slang-&gt;sl_sbyts;</a>
<a name="ln3640">    idxs = fidxs = slang-&gt;sl_sidxs;</a>
<a name="ln3641">    pbyts = NULL;</a>
<a name="ln3642">    pidxs = NULL;</a>
<a name="ln3643">    sp-&gt;ts_prefixdepth = PFD_NOPREFIX;</a>
<a name="ln3644">    sp-&gt;ts_state = STATE_START;</a>
<a name="ln3645">  } else {</a>
<a name="ln3646">    // When there are postponed prefixes we need to use these first.  At</a>
<a name="ln3647">    // the end of the prefix we continue in the case-fold tree.</a>
<a name="ln3648">    fbyts = slang-&gt;sl_fbyts;</a>
<a name="ln3649">    fidxs = slang-&gt;sl_fidxs;</a>
<a name="ln3650">    pbyts = slang-&gt;sl_pbyts;</a>
<a name="ln3651">    pidxs = slang-&gt;sl_pidxs;</a>
<a name="ln3652">    if (pbyts != NULL) {</a>
<a name="ln3653">      byts = pbyts;</a>
<a name="ln3654">      idxs = pidxs;</a>
<a name="ln3655">      sp-&gt;ts_prefixdepth = PFD_PREFIXTREE;</a>
<a name="ln3656">      sp-&gt;ts_state = STATE_NOPREFIX;            // try without prefix first</a>
<a name="ln3657">    } else {</a>
<a name="ln3658">      byts = fbyts;</a>
<a name="ln3659">      idxs = fidxs;</a>
<a name="ln3660">      sp-&gt;ts_prefixdepth = PFD_NOPREFIX;</a>
<a name="ln3661">      sp-&gt;ts_state = STATE_START;</a>
<a name="ln3662">    }</a>
<a name="ln3663">  }</a>
<a name="ln3664"> </a>
<a name="ln3665">  // Loop to find all suggestions.  At each round we either:</a>
<a name="ln3666">  // - For the current state try one operation, advance &quot;ts_curi&quot;,</a>
<a name="ln3667">  //   increase &quot;depth&quot;.</a>
<a name="ln3668">  // - When a state is done go to the next, set &quot;ts_state&quot;.</a>
<a name="ln3669">  // - When all states are tried decrease &quot;depth&quot;.</a>
<a name="ln3670">  while (depth &gt;= 0 &amp;&amp; !got_int) {</a>
<a name="ln3671">    sp = &amp;stack[depth];</a>
<a name="ln3672">    switch (sp-&gt;ts_state) {</a>
<a name="ln3673">    case STATE_START:</a>
<a name="ln3674">    case STATE_NOPREFIX:</a>
<a name="ln3675">      // Start of node: Deal with NUL bytes, which means</a>
<a name="ln3676">      // tword[] may end here.</a>
<a name="ln3677">      arridx = sp-&gt;ts_arridx;               // current node in the tree</a>
<a name="ln3678">      len = byts[arridx];                   // bytes in this node</a>
<a name="ln3679">      arridx += sp-&gt;ts_curi;                // index of current byte</a>
<a name="ln3680"> </a>
<a name="ln3681">      if (sp-&gt;ts_prefixdepth == PFD_PREFIXTREE) {</a>
<a name="ln3682">        // Skip over the NUL bytes, we use them later.</a>
<a name="ln3683">        for (n = 0; n &lt; len &amp;&amp; byts[arridx + n] == 0; ++n)</a>
<a name="ln3684">          ;</a>
<a name="ln3685">        sp-&gt;ts_curi += n;</a>
<a name="ln3686"> </a>
<a name="ln3687">        // Always past NUL bytes now.</a>
<a name="ln3688">        n = (int)sp-&gt;ts_state;</a>
<a name="ln3689">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln3690">        sp-&gt;ts_state = STATE_ENDNUL;</a>
<a name="ln3691">        sp-&gt;ts_save_badflags = su-&gt;su_badflags;</a>
<a name="ln3692"> </a>
<a name="ln3693">        // At end of a prefix or at start of prefixtree: check for</a>
<a name="ln3694">        // following word.</a>
<a name="ln3695">        if (byts[arridx] == 0 || n == (int)STATE_NOPREFIX) {</a>
<a name="ln3696">          // Set su-&gt;su_badflags to the caps type at this position.</a>
<a name="ln3697">          // Use the caps type until here for the prefix itself.</a>
<a name="ln3698">          n = nofold_len(fword, sp-&gt;ts_fidx, su-&gt;su_badptr);</a>
<a name="ln3699">          flags = badword_captype(su-&gt;su_badptr, su-&gt;su_badptr + n);</a>
<a name="ln3700">          su-&gt;su_badflags = badword_captype(su-&gt;su_badptr + n,</a>
<a name="ln3701">              su-&gt;su_badptr + su-&gt;su_badlen);</a>
<a name="ln3702">#ifdef DEBUG_TRIEWALK</a>
<a name="ln3703">          sprintf(changename[depth], &quot;prefix&quot;);</a>
<a name="ln3704">#endif</a>
<a name="ln3705">          go_deeper(stack, depth, 0);</a>
<a name="ln3706">          ++depth;</a>
<a name="ln3707">          sp = &amp;stack[depth];</a>
<a name="ln3708">          sp-&gt;ts_prefixdepth = depth - 1;</a>
<a name="ln3709">          byts = fbyts;</a>
<a name="ln3710">          idxs = fidxs;</a>
<a name="ln3711">          sp-&gt;ts_arridx = 0;</a>
<a name="ln3712"> </a>
<a name="ln3713">          // Move the prefix to preword[] with the right case</a>
<a name="ln3714">          // and make find_keepcap_word() works.</a>
<a name="ln3715">          tword[sp-&gt;ts_twordlen] = NUL;</a>
<a name="ln3716">          make_case_word(tword + sp-&gt;ts_splitoff,</a>
<a name="ln3717">              preword + sp-&gt;ts_prewordlen, flags);</a>
<a name="ln3718">          sp-&gt;ts_prewordlen = (char_u)STRLEN(preword);</a>
<a name="ln3719">          sp-&gt;ts_splitoff = sp-&gt;ts_twordlen;</a>
<a name="ln3720">        }</a>
<a name="ln3721">        break;</a>
<a name="ln3722">      }</a>
<a name="ln3723"> </a>
<a name="ln3724">      if (sp-&gt;ts_curi &gt; len || byts[arridx] != 0) {</a>
<a name="ln3725">        // Past bytes in node and/or past NUL bytes.</a>
<a name="ln3726">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln3727">        sp-&gt;ts_state = STATE_ENDNUL;</a>
<a name="ln3728">        sp-&gt;ts_save_badflags = su-&gt;su_badflags;</a>
<a name="ln3729">        break;</a>
<a name="ln3730">      }</a>
<a name="ln3731"> </a>
<a name="ln3732">      // End of word in tree.</a>
<a name="ln3733">      ++sp-&gt;ts_curi;                    // eat one NUL byte</a>
<a name="ln3734"> </a>
<a name="ln3735">      flags = (int)idxs[arridx];</a>
<a name="ln3736"> </a>
<a name="ln3737">      // Skip words with the NOSUGGEST flag.</a>
<a name="ln3738">      if (flags &amp; WF_NOSUGGEST)</a>
<a name="ln3739">        break;</a>
<a name="ln3740"> </a>
<a name="ln3741">      fword_ends = (fword[sp-&gt;ts_fidx] == NUL</a>
<a name="ln3742">                    || (soundfold</a>
<a name="ln3743">                        ? ascii_iswhite(fword[sp-&gt;ts_fidx])</a>
<a name="ln3744">                        : !spell_iswordp(fword + sp-&gt;ts_fidx, curwin)));</a>
<a name="ln3745">      tword[sp-&gt;ts_twordlen] = NUL;</a>
<a name="ln3746"> </a>
<a name="ln3747">      if (sp-&gt;ts_prefixdepth &lt;= PFD_NOTSPECIAL</a>
<a name="ln3748">          &amp;&amp; (sp-&gt;ts_flags &amp; TSF_PREFIXOK) == 0</a>
<a name="ln3749">          &amp;&amp; pbyts != NULL) {</a>
<a name="ln3750">        // There was a prefix before the word.  Check that the prefix</a>
<a name="ln3751">        // can be used with this word.</a>
<a name="ln3752">        // Count the length of the NULs in the prefix.  If there are</a>
<a name="ln3753">        // none this must be the first try without a prefix.</a>
<a name="ln3754">        n = stack[sp-&gt;ts_prefixdepth].ts_arridx;</a>
<a name="ln3755">        len = pbyts[n++];</a>
<a name="ln3756">        for (c = 0; c &lt; len &amp;&amp; pbyts[n + c] == 0; ++c)</a>
<a name="ln3757">          ;</a>
<a name="ln3758">        if (c &gt; 0) {</a>
<a name="ln3759">          c = valid_word_prefix(c, n, flags,</a>
<a name="ln3760">              tword + sp-&gt;ts_splitoff, slang, false);</a>
<a name="ln3761">          if (c == 0)</a>
<a name="ln3762">            break;</a>
<a name="ln3763"> </a>
<a name="ln3764">          // Use the WF_RARE flag for a rare prefix.</a>
<a name="ln3765">          if (c &amp; WF_RAREPFX)</a>
<a name="ln3766">            flags |= WF_RARE;</a>
<a name="ln3767"> </a>
<a name="ln3768">          // Tricky: when checking for both prefix and compounding</a>
<a name="ln3769">          // we run into the prefix flag first.</a>
<a name="ln3770">          // Remember that it's OK, so that we accept the prefix</a>
<a name="ln3771">          // when arriving at a compound flag.</a>
<a name="ln3772">          sp-&gt;ts_flags |= TSF_PREFIXOK;</a>
<a name="ln3773">        }</a>
<a name="ln3774">      }</a>
<a name="ln3775"> </a>
<a name="ln3776">      // Check NEEDCOMPOUND: can't use word without compounding.  Do try</a>
<a name="ln3777">      // appending another compound word below.</a>
<a name="ln3778">      if (sp-&gt;ts_complen == sp-&gt;ts_compsplit &amp;&amp; fword_ends</a>
<a name="ln3779">          &amp;&amp; (flags &amp; WF_NEEDCOMP))</a>
<a name="ln3780">        goodword_ends = false;</a>
<a name="ln3781">      else</a>
<a name="ln3782">        goodword_ends = true;</a>
<a name="ln3783"> </a>
<a name="ln3784">      p = NULL;</a>
<a name="ln3785">      compound_ok = true;</a>
<a name="ln3786">      if (sp-&gt;ts_complen &gt; sp-&gt;ts_compsplit) {</a>
<a name="ln3787">        if (slang-&gt;sl_nobreak) {</a>
<a name="ln3788">          // There was a word before this word.  When there was no</a>
<a name="ln3789">          // change in this word (it was correct) add the first word</a>
<a name="ln3790">          // as a suggestion.  If this word was corrected too, we</a>
<a name="ln3791">          // need to check if a correct word follows.</a>
<a name="ln3792">          if (sp-&gt;ts_fidx - sp-&gt;ts_splitfidx</a>
<a name="ln3793">              == sp-&gt;ts_twordlen - sp-&gt;ts_splitoff</a>
<a name="ln3794">              &amp;&amp; STRNCMP(fword + sp-&gt;ts_splitfidx,</a>
<a name="ln3795">                  tword + sp-&gt;ts_splitoff,</a>
<a name="ln3796">                  sp-&gt;ts_fidx - sp-&gt;ts_splitfidx) == 0) {</a>
<a name="ln3797">            preword[sp-&gt;ts_prewordlen] = NUL;</a>
<a name="ln3798">            newscore = score_wordcount_adj(slang, sp-&gt;ts_score,</a>
<a name="ln3799">                preword + sp-&gt;ts_prewordlen,</a>
<a name="ln3800">                sp-&gt;ts_prewordlen &gt; 0);</a>
<a name="ln3801">            // Add the suggestion if the score isn't too bad.</a>
<a name="ln3802">            if (newscore &lt;= su-&gt;su_maxscore)</a>
<a name="ln3803">              add_suggestion(su, &amp;su-&gt;su_ga, preword,</a>
<a name="ln3804">                  sp-&gt;ts_splitfidx - repextra,</a>
<a name="ln3805">                  newscore, 0, false,</a>
<a name="ln3806">                  lp-&gt;lp_sallang, false);</a>
<a name="ln3807">            break;</a>
<a name="ln3808">          }</a>
<a name="ln3809">        } else {</a>
<a name="ln3810">          // There was a compound word before this word.  If this</a>
<a name="ln3811">          // word does not support compounding then give up</a>
<a name="ln3812">          // (splitting is tried for the word without compound</a>
<a name="ln3813">          // flag).</a>
<a name="ln3814">          if (((unsigned)flags &gt;&gt; 24) == 0</a>
<a name="ln3815">              || sp-&gt;ts_twordlen - sp-&gt;ts_splitoff</a>
<a name="ln3816">              &lt; slang-&gt;sl_compminlen) {</a>
<a name="ln3817">            break;</a>
<a name="ln3818">          }</a>
<a name="ln3819">          // For multi-byte chars check character length against</a>
<a name="ln3820">          // COMPOUNDMIN.</a>
<a name="ln3821">          if (slang-&gt;sl_compminlen &gt; 0</a>
<a name="ln3822">              &amp;&amp; mb_charlen(tword + sp-&gt;ts_splitoff)</a>
<a name="ln3823">              &lt; slang-&gt;sl_compminlen) {</a>
<a name="ln3824">            break;</a>
<a name="ln3825">          }</a>
<a name="ln3826"> </a>
<a name="ln3827">          compflags[sp-&gt;ts_complen] = ((unsigned)flags &gt;&gt; 24);</a>
<a name="ln3828">          compflags[sp-&gt;ts_complen + 1] = NUL;</a>
<a name="ln3829">          STRLCPY(preword + sp-&gt;ts_prewordlen,</a>
<a name="ln3830">              tword + sp-&gt;ts_splitoff,</a>
<a name="ln3831">              sp-&gt;ts_twordlen - sp-&gt;ts_splitoff + 1);</a>
<a name="ln3832"> </a>
<a name="ln3833">          // Verify CHECKCOMPOUNDPATTERN  rules.</a>
<a name="ln3834">          if (match_checkcompoundpattern(preword,  sp-&gt;ts_prewordlen,</a>
<a name="ln3835">                  &amp;slang-&gt;sl_comppat))</a>
<a name="ln3836">            compound_ok = false;</a>
<a name="ln3837"> </a>
<a name="ln3838">          if (compound_ok) {</a>
<a name="ln3839">            p = preword;</a>
<a name="ln3840">            while (*skiptowhite(p) != NUL)</a>
<a name="ln3841">              p = skipwhite(skiptowhite(p));</a>
<a name="ln3842">            if (fword_ends &amp;&amp; !can_compound(slang, p,</a>
<a name="ln3843">                    compflags + sp-&gt;ts_compsplit))</a>
<a name="ln3844">              // Compound is not allowed.  But it may still be</a>
<a name="ln3845">              // possible if we add another (short) word.</a>
<a name="ln3846">              compound_ok = false;</a>
<a name="ln3847">          }</a>
<a name="ln3848"> </a>
<a name="ln3849">          // Get pointer to last char of previous word.</a>
<a name="ln3850">          p = preword + sp-&gt;ts_prewordlen;</a>
<a name="ln3851">          MB_PTR_BACK(preword, p);</a>
<a name="ln3852">        }</a>
<a name="ln3853">      }</a>
<a name="ln3854"> </a>
<a name="ln3855">      // Form the word with proper case in preword.</a>
<a name="ln3856">      // If there is a word from a previous split, append.</a>
<a name="ln3857">      // For the soundfold tree don't change the case, simply append.</a>
<a name="ln3858">      if (soundfold)</a>
<a name="ln3859">        STRCPY(preword + sp-&gt;ts_prewordlen, tword + sp-&gt;ts_splitoff);</a>
<a name="ln3860">      else if (flags &amp; WF_KEEPCAP)</a>
<a name="ln3861">        // Must find the word in the keep-case tree.</a>
<a name="ln3862">        find_keepcap_word(slang, tword + sp-&gt;ts_splitoff,</a>
<a name="ln3863">            preword + sp-&gt;ts_prewordlen);</a>
<a name="ln3864">      else {</a>
<a name="ln3865">        // Include badflags: If the badword is onecap or allcap</a>
<a name="ln3866">        // use that for the goodword too.  But if the badword is</a>
<a name="ln3867">        // allcap and it's only one char long use onecap.</a>
<a name="ln3868">        c = su-&gt;su_badflags;</a>
<a name="ln3869">        if ((c &amp; WF_ALLCAP)</a>
<a name="ln3870">            &amp;&amp; su-&gt;su_badlen == (*mb_ptr2len)(su-&gt;su_badptr)</a>
<a name="ln3871">            )</a>
<a name="ln3872">          c = WF_ONECAP;</a>
<a name="ln3873">        c |= flags;</a>
<a name="ln3874"> </a>
<a name="ln3875">        // When appending a compound word after a word character don't</a>
<a name="ln3876">        // use Onecap.</a>
<a name="ln3877">        if (p != NULL &amp;&amp; spell_iswordp_nmw(p, curwin))</a>
<a name="ln3878">          c &amp;= ~WF_ONECAP;</a>
<a name="ln3879">        make_case_word(tword + sp-&gt;ts_splitoff,</a>
<a name="ln3880">            preword + sp-&gt;ts_prewordlen, c);</a>
<a name="ln3881">      }</a>
<a name="ln3882"> </a>
<a name="ln3883">      if (!soundfold) {</a>
<a name="ln3884">        // Don't use a banned word.  It may appear again as a good</a>
<a name="ln3885">        // word, thus remember it.</a>
<a name="ln3886">        if (flags &amp; WF_BANNED) {</a>
<a name="ln3887">          add_banned(su, preword + sp-&gt;ts_prewordlen);</a>
<a name="ln3888">          break;</a>
<a name="ln3889">        }</a>
<a name="ln3890">        if ((sp-&gt;ts_complen == sp-&gt;ts_compsplit</a>
<a name="ln3891">             &amp;&amp; WAS_BANNED(su, preword + sp-&gt;ts_prewordlen))</a>
<a name="ln3892">            || WAS_BANNED(su, preword)) {</a>
<a name="ln3893">          if (slang-&gt;sl_compprog == NULL)</a>
<a name="ln3894">            break;</a>
<a name="ln3895">          // the word so far was banned but we may try compounding</a>
<a name="ln3896">          goodword_ends = false;</a>
<a name="ln3897">        }</a>
<a name="ln3898">      }</a>
<a name="ln3899"> </a>
<a name="ln3900">      newscore = 0;</a>
<a name="ln3901">      if (!soundfold) {         // soundfold words don't have flags</a>
<a name="ln3902">        if ((flags &amp; WF_REGION)</a>
<a name="ln3903">            &amp;&amp; (((unsigned)flags &gt;&gt; 16) &amp; lp-&gt;lp_region) == 0)</a>
<a name="ln3904">          newscore += SCORE_REGION;</a>
<a name="ln3905">        if (flags &amp; WF_RARE)</a>
<a name="ln3906">          newscore += SCORE_RARE;</a>
<a name="ln3907"> </a>
<a name="ln3908">        if (!spell_valid_case(su-&gt;su_badflags,</a>
<a name="ln3909">                captype(preword + sp-&gt;ts_prewordlen, NULL)))</a>
<a name="ln3910">          newscore += SCORE_ICASE;</a>
<a name="ln3911">      }</a>
<a name="ln3912"> </a>
<a name="ln3913">      // TODO: how about splitting in the soundfold tree?</a>
<a name="ln3914">      if (fword_ends</a>
<a name="ln3915">          &amp;&amp; goodword_ends</a>
<a name="ln3916">          &amp;&amp; sp-&gt;ts_fidx &gt;= sp-&gt;ts_fidxtry</a>
<a name="ln3917">          &amp;&amp; compound_ok) {</a>
<a name="ln3918">        // The badword also ends: add suggestions.</a>
<a name="ln3919">#ifdef DEBUG_TRIEWALK</a>
<a name="ln3920">        if (soundfold &amp;&amp; STRCMP(preword, &quot;smwrd&quot;) == 0) {</a>
<a name="ln3921">          int j;</a>
<a name="ln3922"> </a>
<a name="ln3923">          // print the stack of changes that brought us here</a>
<a name="ln3924">          smsg(&quot;------ %s -------&quot;, fword);</a>
<a name="ln3925">          for (j = 0; j &lt; depth; ++j)</a>
<a name="ln3926">            smsg(&quot;%s&quot;, changename[j]);</a>
<a name="ln3927">        }</a>
<a name="ln3928">#endif</a>
<a name="ln3929">        if (soundfold) {</a>
<a name="ln3930">          // For soundfolded words we need to find the original</a>
<a name="ln3931">          // words, the edit distance and then add them.</a>
<a name="ln3932">          add_sound_suggest(su, preword, sp-&gt;ts_score, lp);</a>
<a name="ln3933">        } else if (sp-&gt;ts_fidx &gt; 0)   {</a>
<a name="ln3934">          // Give a penalty when changing non-word char to word</a>
<a name="ln3935">          // char, e.g., &quot;thes,&quot; -&gt; &quot;these&quot;.</a>
<a name="ln3936">          p = fword + sp-&gt;ts_fidx;</a>
<a name="ln3937">          MB_PTR_BACK(fword, p);</a>
<a name="ln3938">          if (!spell_iswordp(p, curwin)) {</a>
<a name="ln3939">            p = preword + STRLEN(preword);</a>
<a name="ln3940">            MB_PTR_BACK(preword, p);</a>
<a name="ln3941">            if (spell_iswordp(p, curwin)) {</a>
<a name="ln3942">              newscore += SCORE_NONWORD;</a>
<a name="ln3943">            }</a>
<a name="ln3944">          }</a>
<a name="ln3945"> </a>
<a name="ln3946">          // Give a bonus to words seen before.</a>
<a name="ln3947">          score = score_wordcount_adj(slang,</a>
<a name="ln3948">              sp-&gt;ts_score + newscore,</a>
<a name="ln3949">              preword + sp-&gt;ts_prewordlen,</a>
<a name="ln3950">              sp-&gt;ts_prewordlen &gt; 0);</a>
<a name="ln3951"> </a>
<a name="ln3952">          // Add the suggestion if the score isn't too bad.</a>
<a name="ln3953">          if (score &lt;= su-&gt;su_maxscore) {</a>
<a name="ln3954">            add_suggestion(su, &amp;su-&gt;su_ga, preword,</a>
<a name="ln3955">                sp-&gt;ts_fidx - repextra,</a>
<a name="ln3956">                score, 0, false, lp-&gt;lp_sallang, false);</a>
<a name="ln3957"> </a>
<a name="ln3958">            if (su-&gt;su_badflags &amp; WF_MIXCAP) {</a>
<a name="ln3959">              // We really don't know if the word should be</a>
<a name="ln3960">              // upper or lower case, add both.</a>
<a name="ln3961">              c = captype(preword, NULL);</a>
<a name="ln3962">              if (c == 0 || c == WF_ALLCAP) {</a>
<a name="ln3963">                make_case_word(tword + sp-&gt;ts_splitoff,</a>
<a name="ln3964">                    preword + sp-&gt;ts_prewordlen,</a>
<a name="ln3965">                    c == 0 ? WF_ALLCAP : 0);</a>
<a name="ln3966"> </a>
<a name="ln3967">                add_suggestion(su, &amp;su-&gt;su_ga, preword,</a>
<a name="ln3968">                    sp-&gt;ts_fidx - repextra,</a>
<a name="ln3969">                    score + SCORE_ICASE, 0, false,</a>
<a name="ln3970">                    lp-&gt;lp_sallang, false);</a>
<a name="ln3971">              }</a>
<a name="ln3972">            }</a>
<a name="ln3973">          }</a>
<a name="ln3974">        }</a>
<a name="ln3975">      }</a>
<a name="ln3976"> </a>
<a name="ln3977">      // Try word split and/or compounding.</a>
<a name="ln3978">      if ((sp-&gt;ts_fidx &gt;= sp-&gt;ts_fidxtry || fword_ends)</a>
<a name="ln3979">          // Don't split in the middle of a character</a>
<a name="ln3980">          &amp;&amp; (sp-&gt;ts_tcharlen == 0)</a>
<a name="ln3981">          ) {</a>
<a name="ln3982">        bool try_compound;</a>
<a name="ln3983">        int try_split;</a>
<a name="ln3984"> </a>
<a name="ln3985">        // If past the end of the bad word don't try a split.</a>
<a name="ln3986">        // Otherwise try changing the next word.  E.g., find</a>
<a name="ln3987">        // suggestions for &quot;the the&quot; where the second &quot;the&quot; is</a>
<a name="ln3988">        // different.  It's done like a split.</a>
<a name="ln3989">        // TODO: word split for soundfold words</a>
<a name="ln3990">        try_split = (sp-&gt;ts_fidx - repextra &lt; su-&gt;su_badlen)</a>
<a name="ln3991">                    &amp;&amp; !soundfold;</a>
<a name="ln3992"> </a>
<a name="ln3993">        // Get here in several situations:</a>
<a name="ln3994">        // 1. The word in the tree ends:</a>
<a name="ln3995">        //    If the word allows compounding try that.  Otherwise try</a>
<a name="ln3996">        //    a split by inserting a space.  For both check that a</a>
<a name="ln3997">        //    valid words starts at fword[sp-&gt;ts_fidx].</a>
<a name="ln3998">        //    For NOBREAK do like compounding to be able to check if</a>
<a name="ln3999">        //    the next word is valid.</a>
<a name="ln4000">        // 2. The badword does end, but it was due to a change (e.g.,</a>
<a name="ln4001">        //    a swap).  No need to split, but do check that the</a>
<a name="ln4002">        //    following word is valid.</a>
<a name="ln4003">        // 3. The badword and the word in the tree end.  It may still</a>
<a name="ln4004">        //    be possible to compound another (short) word.</a>
<a name="ln4005">        try_compound = false;</a>
<a name="ln4006">        if (!soundfold</a>
<a name="ln4007">            &amp;&amp; !slang-&gt;sl_nocompoundsugs</a>
<a name="ln4008">            &amp;&amp; slang-&gt;sl_compprog != NULL</a>
<a name="ln4009">            &amp;&amp; ((unsigned)flags &gt;&gt; 24) != 0</a>
<a name="ln4010">            &amp;&amp; sp-&gt;ts_twordlen - sp-&gt;ts_splitoff</a>
<a name="ln4011">            &gt;= slang-&gt;sl_compminlen</a>
<a name="ln4012">            &amp;&amp; (slang-&gt;sl_compminlen == 0</a>
<a name="ln4013">                || mb_charlen(tword + sp-&gt;ts_splitoff)</a>
<a name="ln4014">                &gt;= slang-&gt;sl_compminlen)</a>
<a name="ln4015">            &amp;&amp; (slang-&gt;sl_compsylmax &lt; MAXWLEN</a>
<a name="ln4016">                || sp-&gt;ts_complen + 1 - sp-&gt;ts_compsplit</a>
<a name="ln4017">                &lt; slang-&gt;sl_compmax)</a>
<a name="ln4018">            &amp;&amp; (can_be_compound(sp, slang,</a>
<a name="ln4019">                    compflags, ((unsigned)flags &gt;&gt; 24)))) {</a>
<a name="ln4020">          try_compound = true;</a>
<a name="ln4021">          compflags[sp-&gt;ts_complen] = ((unsigned)flags &gt;&gt; 24);</a>
<a name="ln4022">          compflags[sp-&gt;ts_complen + 1] = NUL;</a>
<a name="ln4023">        }</a>
<a name="ln4024"> </a>
<a name="ln4025">        // For NOBREAK we never try splitting, it won't make any word</a>
<a name="ln4026">        // valid.</a>
<a name="ln4027">        if (slang-&gt;sl_nobreak &amp;&amp; !slang-&gt;sl_nocompoundsugs) {</a>
<a name="ln4028">          try_compound = true;</a>
<a name="ln4029">        } else if (!fword_ends</a>
<a name="ln4030">                   &amp;&amp; try_compound</a>
<a name="ln4031">                   &amp;&amp; (sp-&gt;ts_flags &amp; TSF_DIDSPLIT) == 0) {</a>
<a name="ln4032">          // If we could add a compound word, and it's also possible to</a>
<a name="ln4033">          // split at this point, do the split first and set</a>
<a name="ln4034">          // TSF_DIDSPLIT to avoid doing it again.</a>
<a name="ln4035">          try_compound = false;</a>
<a name="ln4036">          sp-&gt;ts_flags |= TSF_DIDSPLIT;</a>
<a name="ln4037">          --sp-&gt;ts_curi;                    // do the same NUL again</a>
<a name="ln4038">          compflags[sp-&gt;ts_complen] = NUL;</a>
<a name="ln4039">        } else {</a>
<a name="ln4040">          sp-&gt;ts_flags &amp;= ~TSF_DIDSPLIT;</a>
<a name="ln4041">        }</a>
<a name="ln4042"> </a>
<a name="ln4043">        if (try_split || try_compound) {</a>
<a name="ln4044">          if (!try_compound &amp;&amp; (!fword_ends || !goodword_ends)) {</a>
<a name="ln4045">            // If we're going to split need to check that the</a>
<a name="ln4046">            // words so far are valid for compounding.  If there</a>
<a name="ln4047">            // is only one word it must not have the NEEDCOMPOUND</a>
<a name="ln4048">            // flag.</a>
<a name="ln4049">            if (sp-&gt;ts_complen == sp-&gt;ts_compsplit</a>
<a name="ln4050">                &amp;&amp; (flags &amp; WF_NEEDCOMP))</a>
<a name="ln4051">              break;</a>
<a name="ln4052">            p = preword;</a>
<a name="ln4053">            while (*skiptowhite(p) != NUL)</a>
<a name="ln4054">              p = skipwhite(skiptowhite(p));</a>
<a name="ln4055">            if (sp-&gt;ts_complen &gt; sp-&gt;ts_compsplit</a>
<a name="ln4056">                &amp;&amp; !can_compound(slang, p,</a>
<a name="ln4057">                    compflags + sp-&gt;ts_compsplit))</a>
<a name="ln4058">              break;</a>
<a name="ln4059"> </a>
<a name="ln4060">            if (slang-&gt;sl_nosplitsugs)</a>
<a name="ln4061">              newscore += SCORE_SPLIT_NO;</a>
<a name="ln4062">            else</a>
<a name="ln4063">              newscore += SCORE_SPLIT;</a>
<a name="ln4064"> </a>
<a name="ln4065">            // Give a bonus to words seen before.</a>
<a name="ln4066">            newscore = score_wordcount_adj(slang, newscore,</a>
<a name="ln4067">                preword + sp-&gt;ts_prewordlen, true);</a>
<a name="ln4068">          }</a>
<a name="ln4069"> </a>
<a name="ln4070">          if (TRY_DEEPER(su, stack, depth, newscore)) {</a>
<a name="ln4071">            go_deeper(stack, depth, newscore);</a>
<a name="ln4072">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4073">            if (!try_compound &amp;&amp; !fword_ends)</a>
<a name="ln4074">              sprintf(changename[depth], &quot;%.*s-%s: split&quot;,</a>
<a name="ln4075">                  sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx);</a>
<a name="ln4076">            else</a>
<a name="ln4077">              sprintf(changename[depth], &quot;%.*s-%s: compound&quot;,</a>
<a name="ln4078">                  sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx);</a>
<a name="ln4079">#endif</a>
<a name="ln4080">            // Save things to be restored at STATE_SPLITUNDO.</a>
<a name="ln4081">            sp-&gt;ts_save_badflags = su-&gt;su_badflags;</a>
<a name="ln4082">            PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4083">            sp-&gt;ts_state = STATE_SPLITUNDO;</a>
<a name="ln4084"> </a>
<a name="ln4085">            ++depth;</a>
<a name="ln4086">            sp = &amp;stack[depth];</a>
<a name="ln4087"> </a>
<a name="ln4088">            // Append a space to preword when splitting.</a>
<a name="ln4089">            if (!try_compound &amp;&amp; !fword_ends)</a>
<a name="ln4090">              STRCAT(preword, &quot; &quot;);</a>
<a name="ln4091">            sp-&gt;ts_prewordlen = (char_u)STRLEN(preword);</a>
<a name="ln4092">            sp-&gt;ts_splitoff = sp-&gt;ts_twordlen;</a>
<a name="ln4093">            sp-&gt;ts_splitfidx = sp-&gt;ts_fidx;</a>
<a name="ln4094"> </a>
<a name="ln4095">            // If the badword has a non-word character at this</a>
<a name="ln4096">            // position skip it.  That means replacing the</a>
<a name="ln4097">            // non-word character with a space.  Always skip a</a>
<a name="ln4098">            // character when the word ends.  But only when the</a>
<a name="ln4099">            // good word can end.</a>
<a name="ln4100">            if (((!try_compound &amp;&amp; !spell_iswordp_nmw(fword</a>
<a name="ln4101">                      + sp-&gt;ts_fidx,</a>
<a name="ln4102">                      curwin))</a>
<a name="ln4103">                 || fword_ends)</a>
<a name="ln4104">                &amp;&amp; fword[sp-&gt;ts_fidx] != NUL</a>
<a name="ln4105">                &amp;&amp; goodword_ends) {</a>
<a name="ln4106">              int l;</a>
<a name="ln4107"> </a>
<a name="ln4108">              l = utfc_ptr2len(fword + sp-&gt;ts_fidx);</a>
<a name="ln4109">              if (fword_ends) {</a>
<a name="ln4110">                // Copy the skipped character to preword.</a>
<a name="ln4111">                memmove(preword + sp-&gt;ts_prewordlen,</a>
<a name="ln4112">                    fword + sp-&gt;ts_fidx, l);</a>
<a name="ln4113">                sp-&gt;ts_prewordlen += l;</a>
<a name="ln4114">                preword[sp-&gt;ts_prewordlen] = NUL;</a>
<a name="ln4115">              } else</a>
<a name="ln4116">                sp-&gt;ts_score -= SCORE_SPLIT - SCORE_SUBST;</a>
<a name="ln4117">              sp-&gt;ts_fidx += l;</a>
<a name="ln4118">            }</a>
<a name="ln4119"> </a>
<a name="ln4120">            // When compounding include compound flag in</a>
<a name="ln4121">            // compflags[] (already set above).  When splitting we</a>
<a name="ln4122">            // may start compounding over again.</a>
<a name="ln4123">            if (try_compound)</a>
<a name="ln4124">              ++sp-&gt;ts_complen;</a>
<a name="ln4125">            else</a>
<a name="ln4126">              sp-&gt;ts_compsplit = sp-&gt;ts_complen;</a>
<a name="ln4127">            sp-&gt;ts_prefixdepth = PFD_NOPREFIX;</a>
<a name="ln4128"> </a>
<a name="ln4129">            // set su-&gt;su_badflags to the caps type at this</a>
<a name="ln4130">            // position</a>
<a name="ln4131">            n = nofold_len(fword, sp-&gt;ts_fidx, su-&gt;su_badptr);</a>
<a name="ln4132">            su-&gt;su_badflags = badword_captype(su-&gt;su_badptr + n,</a>
<a name="ln4133">                su-&gt;su_badptr + su-&gt;su_badlen);</a>
<a name="ln4134"> </a>
<a name="ln4135">            // Restart at top of the tree.</a>
<a name="ln4136">            sp-&gt;ts_arridx = 0;</a>
<a name="ln4137"> </a>
<a name="ln4138">            // If there are postponed prefixes, try these too.</a>
<a name="ln4139">            if (pbyts != NULL) {</a>
<a name="ln4140">              byts = pbyts;</a>
<a name="ln4141">              idxs = pidxs;</a>
<a name="ln4142">              sp-&gt;ts_prefixdepth = PFD_PREFIXTREE;</a>
<a name="ln4143">              PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4144">              sp-&gt;ts_state = STATE_NOPREFIX;</a>
<a name="ln4145">            }</a>
<a name="ln4146">          }</a>
<a name="ln4147">        }</a>
<a name="ln4148">      }</a>
<a name="ln4149">      break;</a>
<a name="ln4150"> </a>
<a name="ln4151">    case STATE_SPLITUNDO:</a>
<a name="ln4152">      // Undo the changes done for word split or compound word.</a>
<a name="ln4153">      su-&gt;su_badflags = sp-&gt;ts_save_badflags;</a>
<a name="ln4154"> </a>
<a name="ln4155">      // Continue looking for NUL bytes.</a>
<a name="ln4156">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4157">      sp-&gt;ts_state = STATE_START;</a>
<a name="ln4158"> </a>
<a name="ln4159">      // In case we went into the prefix tree.</a>
<a name="ln4160">      byts = fbyts;</a>
<a name="ln4161">      idxs = fidxs;</a>
<a name="ln4162">      break;</a>
<a name="ln4163"> </a>
<a name="ln4164">    case STATE_ENDNUL:</a>
<a name="ln4165">      // Past the NUL bytes in the node.</a>
<a name="ln4166">      su-&gt;su_badflags = sp-&gt;ts_save_badflags;</a>
<a name="ln4167">      if (fword[sp-&gt;ts_fidx] == NUL</a>
<a name="ln4168">          &amp;&amp; sp-&gt;ts_tcharlen == 0</a>
<a name="ln4169">          ) {</a>
<a name="ln4170">        // The badword ends, can't use STATE_PLAIN.</a>
<a name="ln4171">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4172">        sp-&gt;ts_state = STATE_DEL;</a>
<a name="ln4173">        break;</a>
<a name="ln4174">      }</a>
<a name="ln4175">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4176">      sp-&gt;ts_state = STATE_PLAIN;</a>
<a name="ln4177">      FALLTHROUGH;</a>
<a name="ln4178"> </a>
<a name="ln4179">    case STATE_PLAIN:</a>
<a name="ln4180">      // Go over all possible bytes at this node, add each to tword[]</a>
<a name="ln4181">      // and use child node.  &quot;ts_curi&quot; is the index.</a>
<a name="ln4182">      arridx = sp-&gt;ts_arridx;</a>
<a name="ln4183">      if (sp-&gt;ts_curi &gt; byts[arridx]) {</a>
<a name="ln4184">        // Done all bytes at this node, do next state.  When still at</a>
<a name="ln4185">        // already changed bytes skip the other tricks.</a>
<a name="ln4186">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4187">        if (sp-&gt;ts_fidx &gt;= sp-&gt;ts_fidxtry) {</a>
<a name="ln4188">          sp-&gt;ts_state = STATE_DEL;</a>
<a name="ln4189">        } else {</a>
<a name="ln4190">          sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln4191">        }</a>
<a name="ln4192">      } else {</a>
<a name="ln4193">        arridx += sp-&gt;ts_curi++;</a>
<a name="ln4194">        c = byts[arridx];</a>
<a name="ln4195"> </a>
<a name="ln4196">        // Normal byte, go one level deeper.  If it's not equal to the</a>
<a name="ln4197">        // byte in the bad word adjust the score.  But don't even try</a>
<a name="ln4198">        // when the byte was already changed.  And don't try when we</a>
<a name="ln4199">        // just deleted this byte, accepting it is always cheaper than</a>
<a name="ln4200">        // delete + substitute.</a>
<a name="ln4201">        if (c == fword[sp-&gt;ts_fidx]</a>
<a name="ln4202">            || (sp-&gt;ts_tcharlen &gt; 0 &amp;&amp; sp-&gt;ts_isdiff != DIFF_NONE)</a>
<a name="ln4203">            )</a>
<a name="ln4204">          newscore = 0;</a>
<a name="ln4205">        else</a>
<a name="ln4206">          newscore = SCORE_SUBST;</a>
<a name="ln4207">        if ((newscore == 0</a>
<a name="ln4208">             || (sp-&gt;ts_fidx &gt;= sp-&gt;ts_fidxtry</a>
<a name="ln4209">                 &amp;&amp; ((sp-&gt;ts_flags &amp; TSF_DIDDEL) == 0</a>
<a name="ln4210">                     || c != fword[sp-&gt;ts_delidx])))</a>
<a name="ln4211">            &amp;&amp; TRY_DEEPER(su, stack, depth, newscore)) {</a>
<a name="ln4212">          go_deeper(stack, depth, newscore);</a>
<a name="ln4213">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4214">          if (newscore &gt; 0)</a>
<a name="ln4215">            sprintf(changename[depth], &quot;%.*s-%s: subst %c to %c&quot;,</a>
<a name="ln4216">                sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4217">                fword[sp-&gt;ts_fidx], c);</a>
<a name="ln4218">          else</a>
<a name="ln4219">            sprintf(changename[depth], &quot;%.*s-%s: accept %c&quot;,</a>
<a name="ln4220">                sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4221">                fword[sp-&gt;ts_fidx]);</a>
<a name="ln4222">#endif</a>
<a name="ln4223">          ++depth;</a>
<a name="ln4224">          sp = &amp;stack[depth];</a>
<a name="ln4225">          ++sp-&gt;ts_fidx;</a>
<a name="ln4226">          tword[sp-&gt;ts_twordlen++] = c;</a>
<a name="ln4227">          sp-&gt;ts_arridx = idxs[arridx];</a>
<a name="ln4228">          if (newscore == SCORE_SUBST) {</a>
<a name="ln4229">            sp-&gt;ts_isdiff = DIFF_YES;</a>
<a name="ln4230">          }</a>
<a name="ln4231">          // Multi-byte characters are a bit complicated to</a>
<a name="ln4232">          // handle: They differ when any of the bytes differ</a>
<a name="ln4233">          // and then their length may also differ.</a>
<a name="ln4234">          if (sp-&gt;ts_tcharlen == 0) {</a>
<a name="ln4235">            // First byte.</a>
<a name="ln4236">            sp-&gt;ts_tcharidx = 0;</a>
<a name="ln4237">            sp-&gt;ts_tcharlen = MB_BYTE2LEN(c);</a>
<a name="ln4238">            sp-&gt;ts_fcharstart = sp-&gt;ts_fidx - 1;</a>
<a name="ln4239">            sp-&gt;ts_isdiff = (newscore != 0)</a>
<a name="ln4240">                            ? DIFF_YES : DIFF_NONE;</a>
<a name="ln4241">          } else if (sp-&gt;ts_isdiff == DIFF_INSERT) {</a>
<a name="ln4242">            // When inserting trail bytes don't advance in the</a>
<a name="ln4243">            // bad word.</a>
<a name="ln4244">            sp-&gt;ts_fidx--;</a>
<a name="ln4245">          }</a>
<a name="ln4246">          if (++sp-&gt;ts_tcharidx == sp-&gt;ts_tcharlen) {</a>
<a name="ln4247">            // Last byte of character.</a>
<a name="ln4248">            if (sp-&gt;ts_isdiff == DIFF_YES) {</a>
<a name="ln4249">              // Correct ts_fidx for the byte length of the</a>
<a name="ln4250">              // character (we didn't check that before).</a>
<a name="ln4251">              sp-&gt;ts_fidx = sp-&gt;ts_fcharstart</a>
<a name="ln4252">                            + utfc_ptr2len(fword + sp-&gt;ts_fcharstart);</a>
<a name="ln4253"> </a>
<a name="ln4254">              // For changing a composing character adjust</a>
<a name="ln4255">              // the score from SCORE_SUBST to</a>
<a name="ln4256">              // SCORE_SUBCOMP.</a>
<a name="ln4257">              if (utf_iscomposing(utf_ptr2char(tword + sp-&gt;ts_twordlen</a>
<a name="ln4258">                                               - sp-&gt;ts_tcharlen))</a>
<a name="ln4259">                  &amp;&amp; utf_iscomposing(utf_ptr2char(fword</a>
<a name="ln4260">                                                  + sp-&gt;ts_fcharstart))) {</a>
<a name="ln4261">                sp-&gt;ts_score -= SCORE_SUBST - SCORE_SUBCOMP;</a>
<a name="ln4262">              } else if (</a>
<a name="ln4263">                  !soundfold</a>
<a name="ln4264">                  &amp;&amp; slang-&gt;sl_has_map</a>
<a name="ln4265">                  &amp;&amp; similar_chars(</a>
<a name="ln4266">                      slang,</a>
<a name="ln4267">                      utf_ptr2char(tword + sp-&gt;ts_twordlen - sp-&gt;ts_tcharlen),</a>
<a name="ln4268">                      utf_ptr2char(fword + sp-&gt;ts_fcharstart))) {</a>
<a name="ln4269">                // For a similar character adjust score from</a>
<a name="ln4270">                // SCORE_SUBST to SCORE_SIMILAR.</a>
<a name="ln4271">                sp-&gt;ts_score -= SCORE_SUBST - SCORE_SIMILAR;</a>
<a name="ln4272">              }</a>
<a name="ln4273">            } else if (sp-&gt;ts_isdiff == DIFF_INSERT</a>
<a name="ln4274">                       &amp;&amp; sp-&gt;ts_twordlen &gt; sp-&gt;ts_tcharlen) {</a>
<a name="ln4275">              p = tword + sp-&gt;ts_twordlen - sp-&gt;ts_tcharlen;</a>
<a name="ln4276">              c = utf_ptr2char(p);</a>
<a name="ln4277">              if (utf_iscomposing(c)) {</a>
<a name="ln4278">                // Inserting a composing char doesn't</a>
<a name="ln4279">                // count that much.</a>
<a name="ln4280">                sp-&gt;ts_score -= SCORE_INS - SCORE_INSCOMP;</a>
<a name="ln4281">              } else {</a>
<a name="ln4282">                // If the previous character was the same,</a>
<a name="ln4283">                // thus doubling a character, give a bonus</a>
<a name="ln4284">                // to the score.  Also for the soundfold</a>
<a name="ln4285">                // tree (might seem illogical but does</a>
<a name="ln4286">                // give better scores).</a>
<a name="ln4287">                MB_PTR_BACK(tword, p);</a>
<a name="ln4288">                if (c == utf_ptr2char(p)) {</a>
<a name="ln4289">                  sp-&gt;ts_score -= SCORE_INS - SCORE_INSDUP;</a>
<a name="ln4290">                }</a>
<a name="ln4291">              }</a>
<a name="ln4292">            }</a>
<a name="ln4293"> </a>
<a name="ln4294">            // Starting a new char, reset the length.</a>
<a name="ln4295">            sp-&gt;ts_tcharlen = 0;</a>
<a name="ln4296">          }</a>
<a name="ln4297">        }</a>
<a name="ln4298">      }</a>
<a name="ln4299">      break;</a>
<a name="ln4300"> </a>
<a name="ln4301">    case STATE_DEL:</a>
<a name="ln4302">      // When past the first byte of a multi-byte char don't try</a>
<a name="ln4303">      // delete/insert/swap a character.</a>
<a name="ln4304">      if (sp-&gt;ts_tcharlen &gt; 0) {</a>
<a name="ln4305">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4306">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln4307">        break;</a>
<a name="ln4308">      }</a>
<a name="ln4309">      // Try skipping one character in the bad word (delete it).</a>
<a name="ln4310">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4311">      sp-&gt;ts_state = STATE_INS_PREP;</a>
<a name="ln4312">      sp-&gt;ts_curi = 1;</a>
<a name="ln4313">      if (soundfold &amp;&amp; sp-&gt;ts_fidx == 0 &amp;&amp; fword[sp-&gt;ts_fidx] == '*')</a>
<a name="ln4314">        // Deleting a vowel at the start of a word counts less, see</a>
<a name="ln4315">        // soundalike_score().</a>
<a name="ln4316">        newscore = 2 * SCORE_DEL / 3;</a>
<a name="ln4317">      else</a>
<a name="ln4318">        newscore = SCORE_DEL;</a>
<a name="ln4319">      if (fword[sp-&gt;ts_fidx] != NUL</a>
<a name="ln4320">          &amp;&amp; TRY_DEEPER(su, stack, depth, newscore)) {</a>
<a name="ln4321">        go_deeper(stack, depth, newscore);</a>
<a name="ln4322">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4323">        sprintf(changename[depth], &quot;%.*s-%s: delete %c&quot;,</a>
<a name="ln4324">            sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4325">            fword[sp-&gt;ts_fidx]);</a>
<a name="ln4326">#endif</a>
<a name="ln4327">        ++depth;</a>
<a name="ln4328"> </a>
<a name="ln4329">        // Remember what character we deleted, so that we can avoid</a>
<a name="ln4330">        // inserting it again.</a>
<a name="ln4331">        stack[depth].ts_flags |= TSF_DIDDEL;</a>
<a name="ln4332">        stack[depth].ts_delidx = sp-&gt;ts_fidx;</a>
<a name="ln4333"> </a>
<a name="ln4334">        // Advance over the character in fword[].  Give a bonus to the</a>
<a name="ln4335">        // score if the same character is following &quot;nn&quot; -&gt; &quot;n&quot;.  It's</a>
<a name="ln4336">        // a bit illogical for soundfold tree but it does give better</a>
<a name="ln4337">        // results.</a>
<a name="ln4338">        c = utf_ptr2char(fword + sp-&gt;ts_fidx);</a>
<a name="ln4339">        stack[depth].ts_fidx += utfc_ptr2len(fword + sp-&gt;ts_fidx);</a>
<a name="ln4340">        if (utf_iscomposing(c)) {</a>
<a name="ln4341">          stack[depth].ts_score -= SCORE_DEL - SCORE_DELCOMP;</a>
<a name="ln4342">        } else if (c == utf_ptr2char(fword + stack[depth].ts_fidx)) {</a>
<a name="ln4343">          stack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;</a>
<a name="ln4344">        }</a>
<a name="ln4345"> </a>
<a name="ln4346">        break;</a>
<a name="ln4347">      }</a>
<a name="ln4348">      FALLTHROUGH;</a>
<a name="ln4349"> </a>
<a name="ln4350">    case STATE_INS_PREP:</a>
<a name="ln4351">      if (sp-&gt;ts_flags &amp; TSF_DIDDEL) {</a>
<a name="ln4352">        // If we just deleted a byte then inserting won't make sense,</a>
<a name="ln4353">        // a substitute is always cheaper.</a>
<a name="ln4354">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4355">        sp-&gt;ts_state = STATE_SWAP;</a>
<a name="ln4356">        break;</a>
<a name="ln4357">      }</a>
<a name="ln4358"> </a>
<a name="ln4359">      // skip over NUL bytes</a>
<a name="ln4360">      n = sp-&gt;ts_arridx;</a>
<a name="ln4361">      for (;; ) {</a>
<a name="ln4362">        if (sp-&gt;ts_curi &gt; byts[n]) {</a>
<a name="ln4363">          // Only NUL bytes at this node, go to next state.</a>
<a name="ln4364">          PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4365">          sp-&gt;ts_state = STATE_SWAP;</a>
<a name="ln4366">          break;</a>
<a name="ln4367">        }</a>
<a name="ln4368">        if (byts[n + sp-&gt;ts_curi] != NUL) {</a>
<a name="ln4369">          // Found a byte to insert.</a>
<a name="ln4370">          PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4371">          sp-&gt;ts_state = STATE_INS;</a>
<a name="ln4372">          break;</a>
<a name="ln4373">        }</a>
<a name="ln4374">        ++sp-&gt;ts_curi;</a>
<a name="ln4375">      }</a>
<a name="ln4376">      break;</a>
<a name="ln4377"> </a>
<a name="ln4378">    case STATE_INS:</a>
<a name="ln4379">      // Insert one byte.  Repeat this for each possible byte at this</a>
<a name="ln4380">      // node.</a>
<a name="ln4381">      n = sp-&gt;ts_arridx;</a>
<a name="ln4382">      if (sp-&gt;ts_curi &gt; byts[n]) {</a>
<a name="ln4383">        // Done all bytes at this node, go to next state.</a>
<a name="ln4384">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4385">        sp-&gt;ts_state = STATE_SWAP;</a>
<a name="ln4386">        break;</a>
<a name="ln4387">      }</a>
<a name="ln4388"> </a>
<a name="ln4389">      // Do one more byte at this node, but:</a>
<a name="ln4390">      // - Skip NUL bytes.</a>
<a name="ln4391">      // - Skip the byte if it's equal to the byte in the word,</a>
<a name="ln4392">      //   accepting that byte is always better.</a>
<a name="ln4393">      n += sp-&gt;ts_curi++;</a>
<a name="ln4394">      c = byts[n];</a>
<a name="ln4395">      if (soundfold &amp;&amp; sp-&gt;ts_twordlen == 0 &amp;&amp; c == '*')</a>
<a name="ln4396">        // Inserting a vowel at the start of a word counts less,</a>
<a name="ln4397">        // see soundalike_score().</a>
<a name="ln4398">        newscore = 2 * SCORE_INS / 3;</a>
<a name="ln4399">      else</a>
<a name="ln4400">        newscore = SCORE_INS;</a>
<a name="ln4401">      if (c != fword[sp-&gt;ts_fidx]</a>
<a name="ln4402">          &amp;&amp; TRY_DEEPER(su, stack, depth, newscore)) {</a>
<a name="ln4403">        go_deeper(stack, depth, newscore);</a>
<a name="ln4404">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4405">        sprintf(changename[depth], &quot;%.*s-%s: insert %c&quot;,</a>
<a name="ln4406">            sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4407">            c);</a>
<a name="ln4408">#endif</a>
<a name="ln4409">        ++depth;</a>
<a name="ln4410">        sp = &amp;stack[depth];</a>
<a name="ln4411">        tword[sp-&gt;ts_twordlen++] = c;</a>
<a name="ln4412">        sp-&gt;ts_arridx = idxs[n];</a>
<a name="ln4413">        fl = MB_BYTE2LEN(c);</a>
<a name="ln4414">        if (fl &gt; 1) {</a>
<a name="ln4415">          // There are following bytes for the same character.</a>
<a name="ln4416">          // We must find all bytes before trying</a>
<a name="ln4417">          // delete/insert/swap/etc.</a>
<a name="ln4418">          sp-&gt;ts_tcharlen = fl;</a>
<a name="ln4419">          sp-&gt;ts_tcharidx = 1;</a>
<a name="ln4420">          sp-&gt;ts_isdiff = DIFF_INSERT;</a>
<a name="ln4421">        }</a>
<a name="ln4422">        if (fl == 1) {</a>
<a name="ln4423">          // If the previous character was the same, thus doubling a</a>
<a name="ln4424">          // character, give a bonus to the score.  Also for</a>
<a name="ln4425">          // soundfold words (illogical but does give a better</a>
<a name="ln4426">          // score).</a>
<a name="ln4427">          if (sp-&gt;ts_twordlen &gt;= 2</a>
<a name="ln4428">              &amp;&amp; tword[sp-&gt;ts_twordlen - 2] == c)</a>
<a name="ln4429">            sp-&gt;ts_score -= SCORE_INS - SCORE_INSDUP;</a>
<a name="ln4430">        }</a>
<a name="ln4431">      }</a>
<a name="ln4432">      break;</a>
<a name="ln4433"> </a>
<a name="ln4434">    case STATE_SWAP:</a>
<a name="ln4435">      // Swap two bytes in the bad word: &quot;12&quot; -&gt; &quot;21&quot;.</a>
<a name="ln4436">      // We change &quot;fword&quot; here, it's changed back afterwards at</a>
<a name="ln4437">      // STATE_UNSWAP.</a>
<a name="ln4438">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4439">      c = *p;</a>
<a name="ln4440">      if (c == NUL) {</a>
<a name="ln4441">        // End of word, can't swap or replace.</a>
<a name="ln4442">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4443">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln4444">        break;</a>
<a name="ln4445">      }</a>
<a name="ln4446"> </a>
<a name="ln4447">      // Don't swap if the first character is not a word character.</a>
<a name="ln4448">      // SWAP3 etc. also don't make sense then.</a>
<a name="ln4449">      if (!soundfold &amp;&amp; !spell_iswordp(p, curwin)) {</a>
<a name="ln4450">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4451">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4452">        break;</a>
<a name="ln4453">      }</a>
<a name="ln4454"> </a>
<a name="ln4455">      n = MB_CPTR2LEN(p);</a>
<a name="ln4456">      c = utf_ptr2char(p);</a>
<a name="ln4457">      if (p[n] == NUL) {</a>
<a name="ln4458">        c2 = NUL;</a>
<a name="ln4459">      } else if (!soundfold &amp;&amp; !spell_iswordp(p + n, curwin)) {</a>
<a name="ln4460">        c2 = c;  // don't swap non-word char</a>
<a name="ln4461">      } else {</a>
<a name="ln4462">        c2 = utf_ptr2char(p + n);</a>
<a name="ln4463">      }</a>
<a name="ln4464"> </a>
<a name="ln4465">      // When the second character is NUL we can't swap.</a>
<a name="ln4466">      if (c2 == NUL) {</a>
<a name="ln4467">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4468">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4469">        break;</a>
<a name="ln4470">      }</a>
<a name="ln4471"> </a>
<a name="ln4472">      // When characters are identical, swap won't do anything.</a>
<a name="ln4473">      // Also get here if the second char is not a word character.</a>
<a name="ln4474">      if (c == c2) {</a>
<a name="ln4475">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4476">        sp-&gt;ts_state = STATE_SWAP3;</a>
<a name="ln4477">        break;</a>
<a name="ln4478">      }</a>
<a name="ln4479">      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP)) {</a>
<a name="ln4480">        go_deeper(stack, depth, SCORE_SWAP);</a>
<a name="ln4481">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4482">        snprintf(changename[depth], sizeof(changename[0]),</a>
<a name="ln4483">                 &quot;%.*s-%s: swap %c and %c&quot;,</a>
<a name="ln4484">                 sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4485">                 c, c2);</a>
<a name="ln4486">#endif</a>
<a name="ln4487">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4488">        sp-&gt;ts_state = STATE_UNSWAP;</a>
<a name="ln4489">        depth++;</a>
<a name="ln4490">        fl = mb_char2len(c2);</a>
<a name="ln4491">        memmove(p, p + n, fl);</a>
<a name="ln4492">        utf_char2bytes(c, p + fl);</a>
<a name="ln4493">        stack[depth].ts_fidxtry = sp-&gt;ts_fidx + n + fl;</a>
<a name="ln4494">      } else {</a>
<a name="ln4495">        // If this swap doesn't work then SWAP3 won't either.</a>
<a name="ln4496">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4497">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4498">      }</a>
<a name="ln4499">      break;</a>
<a name="ln4500"> </a>
<a name="ln4501">    case STATE_UNSWAP:</a>
<a name="ln4502">      // Undo the STATE_SWAP swap: &quot;21&quot; -&gt; &quot;12&quot;.</a>
<a name="ln4503">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4504">      n = utfc_ptr2len(p);</a>
<a name="ln4505">      c = utf_ptr2char(p + n);</a>
<a name="ln4506">      memmove(p + utfc_ptr2len(p + n), p, n);</a>
<a name="ln4507">      utf_char2bytes(c, p);</a>
<a name="ln4508"> </a>
<a name="ln4509">      FALLTHROUGH;</a>
<a name="ln4510"> </a>
<a name="ln4511">    case STATE_SWAP3:</a>
<a name="ln4512">      // Swap two bytes, skipping one: &quot;123&quot; -&gt; &quot;321&quot;.  We change</a>
<a name="ln4513">      // &quot;fword&quot; here, it's changed back afterwards at STATE_UNSWAP3.</a>
<a name="ln4514">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4515">      n = MB_CPTR2LEN(p);</a>
<a name="ln4516">      c = utf_ptr2char(p);</a>
<a name="ln4517">      fl = MB_CPTR2LEN(p + n);</a>
<a name="ln4518">      c2 = utf_ptr2char(p + n);</a>
<a name="ln4519">      if (!soundfold &amp;&amp; !spell_iswordp(p + n + fl, curwin)) {</a>
<a name="ln4520">        c3 = c;  // don't swap non-word char</a>
<a name="ln4521">      } else {</a>
<a name="ln4522">        c3 = utf_ptr2char(p + n + fl);</a>
<a name="ln4523">      }</a>
<a name="ln4524"> </a>
<a name="ln4525">      // When characters are identical: &quot;121&quot; then SWAP3 result is</a>
<a name="ln4526">      // identical, ROT3L result is same as SWAP: &quot;211&quot;, ROT3L result is</a>
<a name="ln4527">      // same as SWAP on next char: &quot;112&quot;.  Thus skip all swapping.</a>
<a name="ln4528">      // Also skip when c3 is NUL.</a>
<a name="ln4529">      // Also get here when the third character is not a word character.</a>
<a name="ln4530">      // Second character may any char: &quot;a.b&quot; -&gt; &quot;b.a&quot;</a>
<a name="ln4531">      if (c == c3 || c3 == NUL) {</a>
<a name="ln4532">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4533">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4534">        break;</a>
<a name="ln4535">      }</a>
<a name="ln4536">      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3)) {</a>
<a name="ln4537">        go_deeper(stack, depth, SCORE_SWAP3);</a>
<a name="ln4538">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4539">        sprintf(changename[depth], &quot;%.*s-%s: swap3 %c and %c&quot;,</a>
<a name="ln4540">            sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4541">            c, c3);</a>
<a name="ln4542">#endif</a>
<a name="ln4543">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4544">        sp-&gt;ts_state = STATE_UNSWAP3;</a>
<a name="ln4545">        depth++;</a>
<a name="ln4546">        tl = mb_char2len(c3);</a>
<a name="ln4547">        memmove(p, p + n + fl, tl);</a>
<a name="ln4548">        utf_char2bytes(c2, p + tl);</a>
<a name="ln4549">        utf_char2bytes(c, p + fl + tl);</a>
<a name="ln4550">        stack[depth].ts_fidxtry = sp-&gt;ts_fidx + n + fl + tl;</a>
<a name="ln4551">      } else {</a>
<a name="ln4552">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4553">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4554">      }</a>
<a name="ln4555">      break;</a>
<a name="ln4556"> </a>
<a name="ln4557">    case STATE_UNSWAP3:</a>
<a name="ln4558">      // Undo STATE_SWAP3: &quot;321&quot; -&gt; &quot;123&quot;</a>
<a name="ln4559">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4560">      n = utfc_ptr2len(p);</a>
<a name="ln4561">      c2 = utf_ptr2char(p + n);</a>
<a name="ln4562">      fl = utfc_ptr2len(p + n);</a>
<a name="ln4563">      c = utf_ptr2char(p + n + fl);</a>
<a name="ln4564">      tl = utfc_ptr2len(p + n + fl);</a>
<a name="ln4565">      memmove(p + fl + tl, p, n);</a>
<a name="ln4566">      utf_char2bytes(c, p);</a>
<a name="ln4567">      utf_char2bytes(c2, p + tl);</a>
<a name="ln4568">      p = p + tl;</a>
<a name="ln4569"> </a>
<a name="ln4570">      if (!soundfold &amp;&amp; !spell_iswordp(p, curwin)) {</a>
<a name="ln4571">        // Middle char is not a word char, skip the rotate.  First and</a>
<a name="ln4572">        // third char were already checked at swap and swap3.</a>
<a name="ln4573">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4574">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4575">        break;</a>
<a name="ln4576">      }</a>
<a name="ln4577"> </a>
<a name="ln4578">      // Rotate three characters left: &quot;123&quot; -&gt; &quot;231&quot;.  We change</a>
<a name="ln4579">      // &quot;fword&quot; here, it's changed back afterwards at STATE_UNROT3L.</a>
<a name="ln4580">      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3)) {</a>
<a name="ln4581">        go_deeper(stack, depth, SCORE_SWAP3);</a>
<a name="ln4582">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4583">        p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4584">        sprintf(changename[depth], &quot;%.*s-%s: rotate left %c%c%c&quot;,</a>
<a name="ln4585">            sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4586">            p[0], p[1], p[2]);</a>
<a name="ln4587">#endif</a>
<a name="ln4588">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4589">        sp-&gt;ts_state = STATE_UNROT3L;</a>
<a name="ln4590">        ++depth;</a>
<a name="ln4591">        p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4592">        n = MB_CPTR2LEN(p);</a>
<a name="ln4593">        c = utf_ptr2char(p);</a>
<a name="ln4594">        fl = MB_CPTR2LEN(p + n);</a>
<a name="ln4595">        fl += MB_CPTR2LEN(p + n + fl);</a>
<a name="ln4596">        memmove(p, p + n, fl);</a>
<a name="ln4597">        utf_char2bytes(c, p + fl);</a>
<a name="ln4598">        stack[depth].ts_fidxtry = sp-&gt;ts_fidx + n + fl;</a>
<a name="ln4599">      } else {</a>
<a name="ln4600">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4601">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4602">      }</a>
<a name="ln4603">      break;</a>
<a name="ln4604"> </a>
<a name="ln4605">    case STATE_UNROT3L:</a>
<a name="ln4606">      // Undo ROT3L: &quot;231&quot; -&gt; &quot;123&quot;</a>
<a name="ln4607">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4608">      n = utfc_ptr2len(p);</a>
<a name="ln4609">      n += utfc_ptr2len(p + n);</a>
<a name="ln4610">      c = utf_ptr2char(p + n);</a>
<a name="ln4611">      tl = utfc_ptr2len(p + n);</a>
<a name="ln4612">      memmove(p + tl, p, n);</a>
<a name="ln4613">      utf_char2bytes(c, p);</a>
<a name="ln4614"> </a>
<a name="ln4615">      // Rotate three bytes right: &quot;123&quot; -&gt; &quot;312&quot;.  We change &quot;fword&quot;</a>
<a name="ln4616">      // here, it's changed back afterwards at STATE_UNROT3R.</a>
<a name="ln4617">      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3)) {</a>
<a name="ln4618">        go_deeper(stack, depth, SCORE_SWAP3);</a>
<a name="ln4619">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4620">        p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4621">        sprintf(changename[depth], &quot;%.*s-%s: rotate right %c%c%c&quot;,</a>
<a name="ln4622">            sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4623">            p[0], p[1], p[2]);</a>
<a name="ln4624">#endif</a>
<a name="ln4625">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4626">        sp-&gt;ts_state = STATE_UNROT3R;</a>
<a name="ln4627">        ++depth;</a>
<a name="ln4628">        p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4629">        n = MB_CPTR2LEN(p);</a>
<a name="ln4630">        n += MB_CPTR2LEN(p + n);</a>
<a name="ln4631">        c = utf_ptr2char(p + n);</a>
<a name="ln4632">        tl = MB_CPTR2LEN(p + n);</a>
<a name="ln4633">        memmove(p + tl, p, n);</a>
<a name="ln4634">        utf_char2bytes(c, p);</a>
<a name="ln4635">        stack[depth].ts_fidxtry = sp-&gt;ts_fidx + n + tl;</a>
<a name="ln4636">      } else {</a>
<a name="ln4637">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4638">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4639">      }</a>
<a name="ln4640">      break;</a>
<a name="ln4641"> </a>
<a name="ln4642">    case STATE_UNROT3R:</a>
<a name="ln4643">      // Undo ROT3R: &quot;312&quot; -&gt; &quot;123&quot;</a>
<a name="ln4644">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4645">      c = utf_ptr2char(p);</a>
<a name="ln4646">      tl = utfc_ptr2len(p);</a>
<a name="ln4647">      n = utfc_ptr2len(p + tl);</a>
<a name="ln4648">      n += utfc_ptr2len(p + tl + n);</a>
<a name="ln4649">      memmove(p, p + tl, n);</a>
<a name="ln4650">      utf_char2bytes(c, p + n);</a>
<a name="ln4651"> </a>
<a name="ln4652">      FALLTHROUGH;</a>
<a name="ln4653"> </a>
<a name="ln4654">    case STATE_REP_INI:</a>
<a name="ln4655">      // Check if matching with REP items from the .aff file would work.</a>
<a name="ln4656">      // Quickly skip if:</a>
<a name="ln4657">      // - there are no REP items and we are not in the soundfold trie</a>
<a name="ln4658">      // - the score is going to be too high anyway</a>
<a name="ln4659">      // - already applied a REP item or swapped here</a>
<a name="ln4660">      if ((lp-&gt;lp_replang == NULL &amp;&amp; !soundfold)</a>
<a name="ln4661">          || sp-&gt;ts_score + SCORE_REP &gt;= su-&gt;su_maxscore</a>
<a name="ln4662">          || sp-&gt;ts_fidx &lt; sp-&gt;ts_fidxtry) {</a>
<a name="ln4663">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4664">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln4665">        break;</a>
<a name="ln4666">      }</a>
<a name="ln4667"> </a>
<a name="ln4668">      // Use the first byte to quickly find the first entry that may</a>
<a name="ln4669">      // match.  If the index is -1 there is none.</a>
<a name="ln4670">      if (soundfold)</a>
<a name="ln4671">        sp-&gt;ts_curi = slang-&gt;sl_repsal_first[fword[sp-&gt;ts_fidx]];</a>
<a name="ln4672">      else</a>
<a name="ln4673">        sp-&gt;ts_curi = lp-&gt;lp_replang-&gt;sl_rep_first[fword[sp-&gt;ts_fidx]];</a>
<a name="ln4674"> </a>
<a name="ln4675">      if (sp-&gt;ts_curi &lt; 0) {</a>
<a name="ln4676">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4677">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln4678">        break;</a>
<a name="ln4679">      }</a>
<a name="ln4680"> </a>
<a name="ln4681">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4682">      sp-&gt;ts_state = STATE_REP;</a>
<a name="ln4683">      FALLTHROUGH;</a>
<a name="ln4684"> </a>
<a name="ln4685">    case STATE_REP:</a>
<a name="ln4686">      // Try matching with REP items from the .aff file.  For each match</a>
<a name="ln4687">      // replace the characters and check if the resulting word is</a>
<a name="ln4688">      // valid.</a>
<a name="ln4689">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4690"> </a>
<a name="ln4691">      if (soundfold)</a>
<a name="ln4692">        gap = &amp;slang-&gt;sl_repsal;</a>
<a name="ln4693">      else</a>
<a name="ln4694">        gap = &amp;lp-&gt;lp_replang-&gt;sl_rep;</a>
<a name="ln4695">      while (sp-&gt;ts_curi &lt; gap-&gt;ga_len) {</a>
<a name="ln4696">        ftp = (fromto_T *)gap-&gt;ga_data + sp-&gt;ts_curi++;</a>
<a name="ln4697">        if (*ftp-&gt;ft_from != *p) {</a>
<a name="ln4698">          // past possible matching entries</a>
<a name="ln4699">          sp-&gt;ts_curi = gap-&gt;ga_len;</a>
<a name="ln4700">          break;</a>
<a name="ln4701">        }</a>
<a name="ln4702">        if (STRNCMP(ftp-&gt;ft_from, p, STRLEN(ftp-&gt;ft_from)) == 0</a>
<a name="ln4703">            &amp;&amp; TRY_DEEPER(su, stack, depth, SCORE_REP)) {</a>
<a name="ln4704">          go_deeper(stack, depth, SCORE_REP);</a>
<a name="ln4705">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4706">          sprintf(changename[depth], &quot;%.*s-%s: replace %s with %s&quot;,</a>
<a name="ln4707">              sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4708">              ftp-&gt;ft_from, ftp-&gt;ft_to);</a>
<a name="ln4709">#endif</a>
<a name="ln4710">          // Need to undo this afterwards.</a>
<a name="ln4711">          PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4712">          sp-&gt;ts_state = STATE_REP_UNDO;</a>
<a name="ln4713"> </a>
<a name="ln4714">          // Change the &quot;from&quot; to the &quot;to&quot; string.</a>
<a name="ln4715">          ++depth;</a>
<a name="ln4716">          fl = (int)STRLEN(ftp-&gt;ft_from);</a>
<a name="ln4717">          tl = (int)STRLEN(ftp-&gt;ft_to);</a>
<a name="ln4718">          if (fl != tl) {</a>
<a name="ln4719">            STRMOVE(p + tl, p + fl);</a>
<a name="ln4720">            repextra += tl - fl;</a>
<a name="ln4721">          }</a>
<a name="ln4722">          memmove(p, ftp-&gt;ft_to, tl);</a>
<a name="ln4723">          stack[depth].ts_fidxtry = sp-&gt;ts_fidx + tl;</a>
<a name="ln4724">          stack[depth].ts_tcharlen = 0;</a>
<a name="ln4725">          break;</a>
<a name="ln4726">        }</a>
<a name="ln4727">      }</a>
<a name="ln4728"> </a>
<a name="ln4729">      if (sp-&gt;ts_curi &gt;= gap-&gt;ga_len &amp;&amp; sp-&gt;ts_state == STATE_REP)</a>
<a name="ln4730">        // No (more) matches.</a>
<a name="ln4731">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4732">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln4733"> </a>
<a name="ln4734">      break;</a>
<a name="ln4735"> </a>
<a name="ln4736">    case STATE_REP_UNDO:</a>
<a name="ln4737">      // Undo a REP replacement and continue with the next one.</a>
<a name="ln4738">      if (soundfold)</a>
<a name="ln4739">        gap = &amp;slang-&gt;sl_repsal;</a>
<a name="ln4740">      else</a>
<a name="ln4741">        gap = &amp;lp-&gt;lp_replang-&gt;sl_rep;</a>
<a name="ln4742">      ftp = (fromto_T *)gap-&gt;ga_data + sp-&gt;ts_curi - 1;</a>
<a name="ln4743">      fl = (int)STRLEN(ftp-&gt;ft_from);</a>
<a name="ln4744">      tl = (int)STRLEN(ftp-&gt;ft_to);</a>
<a name="ln4745">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4746">      if (fl != tl) {</a>
<a name="ln4747">        STRMOVE(p + fl, p + tl);</a>
<a name="ln4748">        repextra -= tl - fl;</a>
<a name="ln4749">      }</a>
<a name="ln4750">      memmove(p, ftp-&gt;ft_from, fl);</a>
<a name="ln4751">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4752">      sp-&gt;ts_state = STATE_REP;</a>
<a name="ln4753">      break;</a>
<a name="ln4754"> </a>
<a name="ln4755">    default:</a>
<a name="ln4756">      // Did all possible states at this level, go up one level.</a>
<a name="ln4757">      --depth;</a>
<a name="ln4758"> </a>
<a name="ln4759">      if (depth &gt;= 0 &amp;&amp; stack[depth].ts_prefixdepth == PFD_PREFIXTREE) {</a>
<a name="ln4760">        // Continue in or go back to the prefix tree.</a>
<a name="ln4761">        byts = pbyts;</a>
<a name="ln4762">        idxs = pidxs;</a>
<a name="ln4763">      }</a>
<a name="ln4764"> </a>
<a name="ln4765">      // Don't check for CTRL-C too often, it takes time.</a>
<a name="ln4766">      if (--breakcheckcount == 0) {</a>
<a name="ln4767">        os_breakcheck();</a>
<a name="ln4768">        breakcheckcount = 1000;</a>
<a name="ln4769">      }</a>
<a name="ln4770">    }</a>
<a name="ln4771">  }</a>
<a name="ln4772">}</a>
<a name="ln4773"> </a>
<a name="ln4774"> </a>
<a name="ln4775">// Go one level deeper in the tree.</a>
<a name="ln4776">static void go_deeper(trystate_T *stack, int depth, int score_add)</a>
<a name="ln4777">{</a>
<a name="ln4778">  stack[depth + 1] = stack[depth];</a>
<a name="ln4779">  stack[depth + 1].ts_state = STATE_START;</a>
<a name="ln4780">  stack[depth + 1].ts_score = stack[depth].ts_score + score_add;</a>
<a name="ln4781">  stack[depth + 1].ts_curi = 1;         // start just after length byte</a>
<a name="ln4782">  stack[depth + 1].ts_flags = 0;</a>
<a name="ln4783">}</a>
<a name="ln4784"> </a>
<a name="ln4785">// Case-folding may change the number of bytes: Count nr of chars in</a>
<a name="ln4786">// fword[flen] and return the byte length of that many chars in &quot;word&quot;.</a>
<a name="ln4787">static int nofold_len(char_u *fword, int flen, char_u *word)</a>
<a name="ln4788">{</a>
<a name="ln4789">  char_u      *p;</a>
<a name="ln4790">  int i = 0;</a>
<a name="ln4791"> </a>
<a name="ln4792">  for (p = fword; p &lt; fword + flen; MB_PTR_ADV(p)) {</a>
<a name="ln4793">    i++;</a>
<a name="ln4794">  }</a>
<a name="ln4795">  for (p = word; i &gt; 0; MB_PTR_ADV(p)) {</a>
<a name="ln4796">    i--;</a>
<a name="ln4797">  }</a>
<a name="ln4798">  return (int)(p - word);</a>
<a name="ln4799">}</a>
<a name="ln4800"> </a>
<a name="ln4801">// &quot;fword&quot; is a good word with case folded.  Find the matching keep-case</a>
<a name="ln4802">// words and put it in &quot;kword&quot;.</a>
<a name="ln4803">// Theoretically there could be several keep-case words that result in the</a>
<a name="ln4804">// same case-folded word, but we only find one...</a>
<a name="ln4805">static void find_keepcap_word(slang_T *slang, char_u *fword, char_u *kword)</a>
<a name="ln4806">{</a>
<a name="ln4807">  char_u uword[MAXWLEN];                // &quot;fword&quot; in upper-case</a>
<a name="ln4808">  int depth;</a>
<a name="ln4809">  idx_T tryidx;</a>
<a name="ln4810"> </a>
<a name="ln4811">  // The following arrays are used at each depth in the tree.</a>
<a name="ln4812">  idx_T arridx[MAXWLEN];</a>
<a name="ln4813">  int round[MAXWLEN];</a>
<a name="ln4814">  int fwordidx[MAXWLEN];</a>
<a name="ln4815">  int uwordidx[MAXWLEN];</a>
<a name="ln4816">  int kwordlen[MAXWLEN];</a>
<a name="ln4817"> </a>
<a name="ln4818">  int flen, ulen;</a>
<a name="ln4819">  int l;</a>
<a name="ln4820">  int len;</a>
<a name="ln4821">  int c;</a>
<a name="ln4822">  idx_T lo, hi, m;</a>
<a name="ln4823">  char_u      *p;</a>
<a name="ln4824">  char_u      *byts = slang-&gt;sl_kbyts;      // array with bytes of the words</a>
<a name="ln4825">  idx_T       *idxs = slang-&gt;sl_kidxs;      // array with indexes</a>
<a name="ln4826"> </a>
<a name="ln4827">  if (byts == NULL) {</a>
<a name="ln4828">    // array is empty: &quot;cannot happen&quot;</a>
<a name="ln4829">    *kword = NUL;</a>
<a name="ln4830">    return;</a>
<a name="ln4831">  }</a>
<a name="ln4832"> </a>
<a name="ln4833">  // Make an all-cap version of &quot;fword&quot;.</a>
<a name="ln4834">  allcap_copy(fword, uword);</a>
<a name="ln4835"> </a>
<a name="ln4836">  // Each character needs to be tried both case-folded and upper-case.</a>
<a name="ln4837">  // All this gets very complicated if we keep in mind that changing case</a>
<a name="ln4838">  // may change the byte length of a multi-byte character...</a>
<a name="ln4839">  depth = 0;</a>
<a name="ln4840">  arridx[0] = 0;</a>
<a name="ln4841">  round[0] = 0;</a>
<a name="ln4842">  fwordidx[0] = 0;</a>
<a name="ln4843">  uwordidx[0] = 0;</a>
<a name="ln4844">  kwordlen[0] = 0;</a>
<a name="ln4845">  while (depth &gt;= 0) {</a>
<a name="ln4846">    if (fword[fwordidx[depth]] == NUL) {</a>
<a name="ln4847">      // We are at the end of &quot;fword&quot;.  If the tree allows a word to end</a>
<a name="ln4848">      // here we have found a match.</a>
<a name="ln4849">      if (byts[arridx[depth] + 1] == 0) {</a>
<a name="ln4850">        kword[kwordlen[depth]] = NUL;</a>
<a name="ln4851">        return;</a>
<a name="ln4852">      }</a>
<a name="ln4853"> </a>
<a name="ln4854">      // kword is getting too long, continue one level up</a>
<a name="ln4855">      --depth;</a>
<a name="ln4856">    } else if (++round[depth] &gt; 2)   {</a>
<a name="ln4857">      // tried both fold-case and upper-case character, continue one</a>
<a name="ln4858">      // level up</a>
<a name="ln4859">      --depth;</a>
<a name="ln4860">    } else {</a>
<a name="ln4861">      // round[depth] == 1: Try using the folded-case character.</a>
<a name="ln4862">      // round[depth] == 2: Try using the upper-case character.</a>
<a name="ln4863">      flen = MB_CPTR2LEN(fword + fwordidx[depth]);</a>
<a name="ln4864">      ulen = MB_CPTR2LEN(uword + uwordidx[depth]);</a>
<a name="ln4865">      if (round[depth] == 1) {</a>
<a name="ln4866">        p = fword + fwordidx[depth];</a>
<a name="ln4867">        l = flen;</a>
<a name="ln4868">      } else {</a>
<a name="ln4869">        p = uword + uwordidx[depth];</a>
<a name="ln4870">        l = ulen;</a>
<a name="ln4871">      }</a>
<a name="ln4872"> </a>
<a name="ln4873">      for (tryidx = arridx[depth]; l &gt; 0; --l) {</a>
<a name="ln4874">        // Perform a binary search in the list of accepted bytes.</a>
<a name="ln4875">        len = byts[tryidx++];</a>
<a name="ln4876">        c = *p++;</a>
<a name="ln4877">        lo = tryidx;</a>
<a name="ln4878">        hi = tryidx + len - 1;</a>
<a name="ln4879">        while (lo &lt; hi) {</a>
<a name="ln4880">          m = (lo + hi) / 2;</a>
<a name="ln4881">          if (byts[m] &gt; c)</a>
<a name="ln4882">            hi = m - 1;</a>
<a name="ln4883">          else if (byts[m] &lt; c)</a>
<a name="ln4884">            lo = m + 1;</a>
<a name="ln4885">          else {</a>
<a name="ln4886">            lo = hi = m;</a>
<a name="ln4887">            break;</a>
<a name="ln4888">          }</a>
<a name="ln4889">        }</a>
<a name="ln4890"> </a>
<a name="ln4891">        // Stop if there is no matching byte.</a>
<a name="ln4892">        if (hi &lt; lo || byts[lo] != c)</a>
<a name="ln4893">          break;</a>
<a name="ln4894"> </a>
<a name="ln4895">        // Continue at the child (if there is one).</a>
<a name="ln4896">        tryidx = idxs[lo];</a>
<a name="ln4897">      }</a>
<a name="ln4898"> </a>
<a name="ln4899">      if (l == 0) {</a>
<a name="ln4900">        // Found the matching char.  Copy it to &quot;kword&quot; and go a</a>
<a name="ln4901">        // level deeper.</a>
<a name="ln4902">        if (round[depth] == 1) {</a>
<a name="ln4903">          STRNCPY(kword + kwordlen[depth], fword + fwordidx[depth],</a>
<a name="ln4904">              flen);</a>
<a name="ln4905">          kwordlen[depth + 1] = kwordlen[depth] + flen;</a>
<a name="ln4906">        } else {</a>
<a name="ln4907">          STRNCPY(kword + kwordlen[depth], uword + uwordidx[depth],</a>
<a name="ln4908">              ulen);</a>
<a name="ln4909">          kwordlen[depth + 1] = kwordlen[depth] + ulen;</a>
<a name="ln4910">        }</a>
<a name="ln4911">        fwordidx[depth + 1] = fwordidx[depth] + flen;</a>
<a name="ln4912">        uwordidx[depth + 1] = uwordidx[depth] + ulen;</a>
<a name="ln4913"> </a>
<a name="ln4914">        ++depth;</a>
<a name="ln4915">        arridx[depth] = tryidx;</a>
<a name="ln4916">        round[depth] = 0;</a>
<a name="ln4917">      }</a>
<a name="ln4918">    }</a>
<a name="ln4919">  }</a>
<a name="ln4920"> </a>
<a name="ln4921">  // Didn't find it: &quot;cannot happen&quot;.</a>
<a name="ln4922">  *kword = NUL;</a>
<a name="ln4923">}</a>
<a name="ln4924"> </a>
<a name="ln4925">// Compute the sound-a-like score for suggestions in su-&gt;su_ga and add them to</a>
<a name="ln4926">// su-&gt;su_sga.</a>
<a name="ln4927">static void score_comp_sal(suginfo_T *su)</a>
<a name="ln4928">{</a>
<a name="ln4929">  langp_T     *lp;</a>
<a name="ln4930">  char_u badsound[MAXWLEN];</a>
<a name="ln4931">  int i;</a>
<a name="ln4932">  suggest_T   *stp;</a>
<a name="ln4933">  suggest_T   *sstp;</a>
<a name="ln4934">  int score;</a>
<a name="ln4935"> </a>
<a name="ln4936">  ga_grow(&amp;su-&gt;su_sga, su-&gt;su_ga.ga_len);</a>
<a name="ln4937"> </a>
<a name="ln4938">  // Use the sound-folding of the first language that supports it.</a>
<a name="ln4939">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln4940">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln4941">    if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_sal)) {</a>
<a name="ln4942">      // soundfold the bad word</a>
<a name="ln4943">      spell_soundfold(lp-&gt;lp_slang, su-&gt;su_fbadword, true, badsound);</a>
<a name="ln4944"> </a>
<a name="ln4945">      for (i = 0; i &lt; su-&gt;su_ga.ga_len; ++i) {</a>
<a name="ln4946">        stp = &amp;SUG(su-&gt;su_ga, i);</a>
<a name="ln4947"> </a>
<a name="ln4948">        // Case-fold the suggested word, sound-fold it and compute the</a>
<a name="ln4949">        // sound-a-like score.</a>
<a name="ln4950">        score = stp_sal_score(stp, su, lp-&gt;lp_slang, badsound);</a>
<a name="ln4951">        if (score &lt; SCORE_MAXMAX) {</a>
<a name="ln4952">          // Add the suggestion.</a>
<a name="ln4953">          sstp = &amp;SUG(su-&gt;su_sga, su-&gt;su_sga.ga_len);</a>
<a name="ln4954">          sstp-&gt;st_word = vim_strsave(stp-&gt;st_word);</a>
<a name="ln4955">          sstp-&gt;st_wordlen = stp-&gt;st_wordlen;</a>
<a name="ln4956">          sstp-&gt;st_score = score;</a>
<a name="ln4957">          sstp-&gt;st_altscore = 0;</a>
<a name="ln4958">          sstp-&gt;st_orglen = stp-&gt;st_orglen;</a>
<a name="ln4959">          ++su-&gt;su_sga.ga_len;</a>
<a name="ln4960">        }</a>
<a name="ln4961">      }</a>
<a name="ln4962">      break;</a>
<a name="ln4963">    }</a>
<a name="ln4964">  }</a>
<a name="ln4965">}</a>
<a name="ln4966"> </a>
<a name="ln4967">// Combine the list of suggestions in su-&gt;su_ga and su-&gt;su_sga.</a>
<a name="ln4968">// They are entwined.</a>
<a name="ln4969">static void score_combine(suginfo_T *su)</a>
<a name="ln4970">{</a>
<a name="ln4971">  garray_T ga;</a>
<a name="ln4972">  garray_T    *gap;</a>
<a name="ln4973">  langp_T     *lp;</a>
<a name="ln4974">  suggest_T   *stp;</a>
<a name="ln4975">  char_u      *p;</a>
<a name="ln4976">  char_u badsound[MAXWLEN];</a>
<a name="ln4977">  int round;</a>
<a name="ln4978">  slang_T     *slang = NULL;</a>
<a name="ln4979"> </a>
<a name="ln4980">  // Add the alternate score to su_ga.</a>
<a name="ln4981">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln4982">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln4983">    if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_sal)) {</a>
<a name="ln4984">      // soundfold the bad word</a>
<a name="ln4985">      slang = lp-&gt;lp_slang;</a>
<a name="ln4986">      spell_soundfold(slang, su-&gt;su_fbadword, true, badsound);</a>
<a name="ln4987"> </a>
<a name="ln4988">      for (int i = 0; i &lt; su-&gt;su_ga.ga_len; ++i) {</a>
<a name="ln4989">        stp = &amp;SUG(su-&gt;su_ga, i);</a>
<a name="ln4990">        stp-&gt;st_altscore = stp_sal_score(stp, su, slang, badsound);</a>
<a name="ln4991">        if (stp-&gt;st_altscore == SCORE_MAXMAX)</a>
<a name="ln4992">          stp-&gt;st_score = (stp-&gt;st_score * 3 + SCORE_BIG) / 4;</a>
<a name="ln4993">        else</a>
<a name="ln4994">          stp-&gt;st_score = (stp-&gt;st_score * 3</a>
<a name="ln4995">                           + stp-&gt;st_altscore) / 4;</a>
<a name="ln4996">        stp-&gt;st_salscore = false;</a>
<a name="ln4997">      }</a>
<a name="ln4998">      break;</a>
<a name="ln4999">    }</a>
<a name="ln5000">  }</a>
<a name="ln5001"> </a>
<a name="ln5002">  if (slang == NULL) {  // Using &quot;double&quot; without sound folding.</a>
<a name="ln5003">    (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore,</a>
<a name="ln5004">        su-&gt;su_maxcount);</a>
<a name="ln5005">    return;</a>
<a name="ln5006">  }</a>
<a name="ln5007"> </a>
<a name="ln5008">  // Add the alternate score to su_sga.</a>
<a name="ln5009">  for (int i = 0; i &lt; su-&gt;su_sga.ga_len; ++i) {</a>
<a name="ln5010">    stp = &amp;SUG(su-&gt;su_sga, i);</a>
<a name="ln5011">    stp-&gt;st_altscore = spell_edit_score(slang,</a>
<a name="ln5012">        su-&gt;su_badword, stp-&gt;st_word);</a>
<a name="ln5013">    if (stp-&gt;st_score == SCORE_MAXMAX)</a>
<a name="ln5014">      stp-&gt;st_score = (SCORE_BIG * 7 + stp-&gt;st_altscore) / 8;</a>
<a name="ln5015">    else</a>
<a name="ln5016">      stp-&gt;st_score = (stp-&gt;st_score * 7 + stp-&gt;st_altscore) / 8;</a>
<a name="ln5017">    stp-&gt;st_salscore = true;</a>
<a name="ln5018">  }</a>
<a name="ln5019"> </a>
<a name="ln5020">  // Remove bad suggestions, sort the suggestions and truncate at &quot;maxcount&quot;</a>
<a name="ln5021">  // for both lists.</a>
<a name="ln5022">  check_suggestions(su, &amp;su-&gt;su_ga);</a>
<a name="ln5023">  (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln5024">  check_suggestions(su, &amp;su-&gt;su_sga);</a>
<a name="ln5025">  (void)cleanup_suggestions(&amp;su-&gt;su_sga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln5026"> </a>
<a name="ln5027">  ga_init(&amp;ga, (int)sizeof(suginfo_T), 1);</a>
<a name="ln5028">  ga_grow(&amp;ga, su-&gt;su_ga.ga_len + su-&gt;su_sga.ga_len);</a>
<a name="ln5029"> </a>
<a name="ln5030">  stp = &amp;SUG(ga, 0);</a>
<a name="ln5031">  for (int i = 0; i &lt; su-&gt;su_ga.ga_len || i &lt; su-&gt;su_sga.ga_len; ++i) {</a>
<a name="ln5032">    // round 1: get a suggestion from su_ga</a>
<a name="ln5033">    // round 2: get a suggestion from su_sga</a>
<a name="ln5034">    for (round = 1; round &lt;= 2; ++round) {</a>
<a name="ln5035">      gap = round == 1 ? &amp;su-&gt;su_ga : &amp;su-&gt;su_sga;</a>
<a name="ln5036">      if (i &lt; gap-&gt;ga_len) {</a>
<a name="ln5037">        // Don't add a word if it's already there.</a>
<a name="ln5038">        p = SUG(*gap, i).st_word;</a>
<a name="ln5039">        int j;</a>
<a name="ln5040">        for (j = 0; j &lt; ga.ga_len; ++j)</a>
<a name="ln5041">          if (STRCMP(stp[j].st_word, p) == 0)</a>
<a name="ln5042">            break;</a>
<a name="ln5043">        if (j == ga.ga_len)</a>
<a name="ln5044">          stp[ga.ga_len++] = SUG(*gap, i);</a>
<a name="ln5045">        else</a>
<a name="ln5046">          xfree(p);</a>
<a name="ln5047">      }</a>
<a name="ln5048">    }</a>
<a name="ln5049">  }</a>
<a name="ln5050"> </a>
<a name="ln5051">  ga_clear(&amp;su-&gt;su_ga);</a>
<a name="ln5052">  ga_clear(&amp;su-&gt;su_sga);</a>
<a name="ln5053"> </a>
<a name="ln5054">  // Truncate the list to the number of suggestions that will be displayed.</a>
<a name="ln5055">  if (ga.ga_len &gt; su-&gt;su_maxcount) {</a>
<a name="ln5056">    for (int i = su-&gt;su_maxcount; i &lt; ga.ga_len; ++i) {</a>
<a name="ln5057">      xfree(stp[i].st_word);</a>
<a name="ln5058">    }</a>
<a name="ln5059">    ga.ga_len = su-&gt;su_maxcount;</a>
<a name="ln5060">  }</a>
<a name="ln5061"> </a>
<a name="ln5062">  su-&gt;su_ga = ga;</a>
<a name="ln5063">}</a>
<a name="ln5064"> </a>
<a name="ln5065">// For the goodword in &quot;stp&quot; compute the soundalike score compared to the</a>
<a name="ln5066">// badword.</a>
<a name="ln5067">static int</a>
<a name="ln5068">stp_sal_score (</a>
<a name="ln5069">    suggest_T *stp,</a>
<a name="ln5070">    suginfo_T *su,</a>
<a name="ln5071">    slang_T *slang,</a>
<a name="ln5072">    char_u *badsound          // sound-folded badword</a>
<a name="ln5073">)</a>
<a name="ln5074">{</a>
<a name="ln5075">  char_u      *p;</a>
<a name="ln5076">  char_u      *pbad;</a>
<a name="ln5077">  char_u      *pgood;</a>
<a name="ln5078">  char_u badsound2[MAXWLEN];</a>
<a name="ln5079">  char_u fword[MAXWLEN];</a>
<a name="ln5080">  char_u goodsound[MAXWLEN];</a>
<a name="ln5081">  char_u goodword[MAXWLEN];</a>
<a name="ln5082">  int lendiff;</a>
<a name="ln5083"> </a>
<a name="ln5084">  lendiff = su-&gt;su_badlen - stp-&gt;st_orglen;</a>
<a name="ln5085">  if (lendiff &gt;= 0)</a>
<a name="ln5086">    pbad = badsound;</a>
<a name="ln5087">  else {</a>
<a name="ln5088">    // soundfold the bad word with more characters following</a>
<a name="ln5089">    (void)spell_casefold(su-&gt;su_badptr, stp-&gt;st_orglen, fword, MAXWLEN);</a>
<a name="ln5090"> </a>
<a name="ln5091">    // When joining two words the sound often changes a lot.  E.g., &quot;t he&quot;</a>
<a name="ln5092">    // sounds like &quot;t h&quot; while &quot;the&quot; sounds like &quot;@&quot;.  Avoid that by</a>
<a name="ln5093">    // removing the space.  Don't do it when the good word also contains a</a>
<a name="ln5094">    // space.</a>
<a name="ln5095">    if (ascii_iswhite(su-&gt;su_badptr[su-&gt;su_badlen])</a>
<a name="ln5096">        &amp;&amp; *skiptowhite(stp-&gt;st_word) == NUL)</a>
<a name="ln5097">      for (p = fword; *(p = skiptowhite(p)) != NUL; )</a>
<a name="ln5098">        STRMOVE(p, p + 1);</a>
<a name="ln5099"> </a>
<a name="ln5100">    spell_soundfold(slang, fword, true, badsound2);</a>
<a name="ln5101">    pbad = badsound2;</a>
<a name="ln5102">  }</a>
<a name="ln5103"> </a>
<a name="ln5104">  if (lendiff &gt; 0 &amp;&amp; stp-&gt;st_wordlen + lendiff &lt; MAXWLEN) {</a>
<a name="ln5105">    // Add part of the bad word to the good word, so that we soundfold</a>
<a name="ln5106">    // what replaces the bad word.</a>
<a name="ln5107">    STRCPY(goodword, stp-&gt;st_word);</a>
<a name="ln5108">    STRLCPY(goodword + stp-&gt;st_wordlen,</a>
<a name="ln5109">        su-&gt;su_badptr + su-&gt;su_badlen - lendiff, lendiff + 1);</a>
<a name="ln5110">    pgood = goodword;</a>
<a name="ln5111">  } else</a>
<a name="ln5112">    pgood = stp-&gt;st_word;</a>
<a name="ln5113"> </a>
<a name="ln5114">  // Sound-fold the word and compute the score for the difference.</a>
<a name="ln5115">  spell_soundfold(slang, pgood, false, goodsound);</a>
<a name="ln5116"> </a>
<a name="ln5117">  return soundalike_score(goodsound, pbad);</a>
<a name="ln5118">}</a>
<a name="ln5119"> </a>
<a name="ln5120">static sftword_T dumsft;</a>
<a name="ln5121">#define HIKEY2SFT(p)  ((sftword_T *)(p - (dumsft.sft_word - (char_u *)&amp;dumsft)))</a>
<a name="ln5122">#define HI2SFT(hi)     HIKEY2SFT((hi)-&gt;hi_key)</a>
<a name="ln5123"> </a>
<a name="ln5124">// Prepare for calling suggest_try_soundalike().</a>
<a name="ln5125">static void suggest_try_soundalike_prep(void)</a>
<a name="ln5126">{</a>
<a name="ln5127">  langp_T     *lp;</a>
<a name="ln5128">  slang_T     *slang;</a>
<a name="ln5129"> </a>
<a name="ln5130">  // Do this for all languages that support sound folding and for which a</a>
<a name="ln5131">  // .sug file has been loaded.</a>
<a name="ln5132">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln5133">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln5134">    slang = lp-&gt;lp_slang;</a>
<a name="ln5135">    if (!GA_EMPTY(&amp;slang-&gt;sl_sal) &amp;&amp; slang-&gt;sl_sbyts != NULL)</a>
<a name="ln5136">      // prepare the hashtable used by add_sound_suggest()</a>
<a name="ln5137">      hash_init(&amp;slang-&gt;sl_sounddone);</a>
<a name="ln5138">  }</a>
<a name="ln5139">}</a>
<a name="ln5140"> </a>
<a name="ln5141">// Find suggestions by comparing the word in a sound-a-like form.</a>
<a name="ln5142">// Note: This doesn't support postponed prefixes.</a>
<a name="ln5143">static void suggest_try_soundalike(suginfo_T *su)</a>
<a name="ln5144">{</a>
<a name="ln5145">  char_u salword[MAXWLEN];</a>
<a name="ln5146">  langp_T     *lp;</a>
<a name="ln5147">  slang_T     *slang;</a>
<a name="ln5148"> </a>
<a name="ln5149">  // Do this for all languages that support sound folding and for which a</a>
<a name="ln5150">  // .sug file has been loaded.</a>
<a name="ln5151">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln5152">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln5153">    slang = lp-&gt;lp_slang;</a>
<a name="ln5154">    if (!GA_EMPTY(&amp;slang-&gt;sl_sal) &amp;&amp; slang-&gt;sl_sbyts != NULL) {</a>
<a name="ln5155">      // soundfold the bad word</a>
<a name="ln5156">      spell_soundfold(slang, su-&gt;su_fbadword, true, salword);</a>
<a name="ln5157"> </a>
<a name="ln5158">      // try all kinds of inserts/deletes/swaps/etc.</a>
<a name="ln5159">      // TODO: also soundfold the next words, so that we can try joining</a>
<a name="ln5160">      // and splitting</a>
<a name="ln5161">#ifdef SUGGEST_PROFILE</a>
<a name="ln5162">      prof_init();</a>
<a name="ln5163">#endif</a>
<a name="ln5164">      suggest_trie_walk(su, lp, salword, true);</a>
<a name="ln5165">#ifdef SUGGEST_PROFILE</a>
<a name="ln5166">      prof_report(&quot;soundalike&quot;);</a>
<a name="ln5167">#endif</a>
<a name="ln5168">    }</a>
<a name="ln5169">  }</a>
<a name="ln5170">}</a>
<a name="ln5171"> </a>
<a name="ln5172">// Finish up after calling suggest_try_soundalike().</a>
<a name="ln5173">static void suggest_try_soundalike_finish(void)</a>
<a name="ln5174">{</a>
<a name="ln5175">  langp_T     *lp;</a>
<a name="ln5176">  slang_T     *slang;</a>
<a name="ln5177">  int todo;</a>
<a name="ln5178">  hashitem_T  *hi;</a>
<a name="ln5179"> </a>
<a name="ln5180">  // Do this for all languages that support sound folding and for which a</a>
<a name="ln5181">  // .sug file has been loaded.</a>
<a name="ln5182">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln5183">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln5184">    slang = lp-&gt;lp_slang;</a>
<a name="ln5185">    if (!GA_EMPTY(&amp;slang-&gt;sl_sal) &amp;&amp; slang-&gt;sl_sbyts != NULL) {</a>
<a name="ln5186">      // Free the info about handled words.</a>
<a name="ln5187">      todo = (int)slang-&gt;sl_sounddone.ht_used;</a>
<a name="ln5188">      for (hi = slang-&gt;sl_sounddone.ht_array; todo &gt; 0; ++hi)</a>
<a name="ln5189">        if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln5190">          xfree(HI2SFT(hi));</a>
<a name="ln5191">          --todo;</a>
<a name="ln5192">        }</a>
<a name="ln5193"> </a>
<a name="ln5194">      // Clear the hashtable, it may also be used by another region.</a>
<a name="ln5195">      hash_clear(&amp;slang-&gt;sl_sounddone);</a>
<a name="ln5196">      hash_init(&amp;slang-&gt;sl_sounddone);</a>
<a name="ln5197">    }</a>
<a name="ln5198">  }</a>
<a name="ln5199">}</a>
<a name="ln5200"> </a>
<a name="ln5201">// A match with a soundfolded word is found.  Add the good word(s) that</a>
<a name="ln5202">// produce this soundfolded word.</a>
<a name="ln5203">static void</a>
<a name="ln5204">add_sound_suggest (</a>
<a name="ln5205">    suginfo_T *su,</a>
<a name="ln5206">    char_u *goodword,</a>
<a name="ln5207">    int score,                      // soundfold score</a>
<a name="ln5208">    langp_T *lp</a>
<a name="ln5209">)</a>
<a name="ln5210">{</a>
<a name="ln5211">  slang_T     *slang = lp-&gt;lp_slang;    // language for sound folding</a>
<a name="ln5212">  int sfwordnr;</a>
<a name="ln5213">  char_u      *nrline;</a>
<a name="ln5214">  int orgnr;</a>
<a name="ln5215">  char_u theword[MAXWLEN];</a>
<a name="ln5216">  int i;</a>
<a name="ln5217">  int wlen;</a>
<a name="ln5218">  char_u      *byts;</a>
<a name="ln5219">  idx_T       *idxs;</a>
<a name="ln5220">  int n;</a>
<a name="ln5221">  int wordcount;</a>
<a name="ln5222">  int wc;</a>
<a name="ln5223">  int goodscore;</a>
<a name="ln5224">  hash_T hash;</a>
<a name="ln5225">  hashitem_T  *hi;</a>
<a name="ln5226">  sftword_T   *sft;</a>
<a name="ln5227">  int bc, gc;</a>
<a name="ln5228">  int limit;</a>
<a name="ln5229"> </a>
<a name="ln5230">  // It's very well possible that the same soundfold word is found several</a>
<a name="ln5231">  // times with different scores.  Since the following is quite slow only do</a>
<a name="ln5232">  // the words that have a better score than before.  Use a hashtable to</a>
<a name="ln5233">  // remember the words that have been done.</a>
<a name="ln5234">  hash = hash_hash(goodword);</a>
<a name="ln5235">  const size_t goodword_len = STRLEN(goodword);</a>
<a name="ln5236">  hi = hash_lookup(&amp;slang-&gt;sl_sounddone, (const char *)goodword, goodword_len,</a>
<a name="ln5237">                   hash);</a>
<a name="ln5238">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln5239">    sft = xmalloc(sizeof(sftword_T) + goodword_len);</a>
<a name="ln5240">    sft-&gt;sft_score = score;</a>
<a name="ln5241">    memcpy(sft-&gt;sft_word, goodword, goodword_len + 1);</a>
<a name="ln5242">    hash_add_item(&amp;slang-&gt;sl_sounddone, hi, sft-&gt;sft_word, hash);</a>
<a name="ln5243">  } else {</a>
<a name="ln5244">    sft = HI2SFT(hi);</a>
<a name="ln5245">    if (score &gt;= sft-&gt;sft_score)</a>
<a name="ln5246">      return;</a>
<a name="ln5247">    sft-&gt;sft_score = score;</a>
<a name="ln5248">  }</a>
<a name="ln5249"> </a>
<a name="ln5250">  // Find the word nr in the soundfold tree.</a>
<a name="ln5251">  sfwordnr = soundfold_find(slang, goodword);</a>
<a name="ln5252">  if (sfwordnr &lt; 0) {</a>
<a name="ln5253">    internal_error(&quot;add_sound_suggest()&quot;);</a>
<a name="ln5254">    return;</a>
<a name="ln5255">  }</a>
<a name="ln5256"> </a>
<a name="ln5257">  // Go over the list of good words that produce this soundfold word</a>
<a name="ln5258">  nrline = ml_get_buf(slang-&gt;sl_sugbuf, (linenr_T)sfwordnr + 1, false);</a>
<a name="ln5259">  orgnr = 0;</a>
<a name="ln5260">  while (*nrline != NUL) {</a>
<a name="ln5261">    // The wordnr was stored in a minimal nr of bytes as an offset to the</a>
<a name="ln5262">    // previous wordnr.</a>
<a name="ln5263">    orgnr += bytes2offset(&amp;nrline);</a>
<a name="ln5264"> </a>
<a name="ln5265">    byts = slang-&gt;sl_fbyts;</a>
<a name="ln5266">    idxs = slang-&gt;sl_fidxs;</a>
<a name="ln5267"> </a>
<a name="ln5268">    // Lookup the word &quot;orgnr&quot; one of the two tries.</a>
<a name="ln5269">    n = 0;</a>
<a name="ln5270">    wordcount = 0;</a>
<a name="ln5271">    for (wlen = 0; wlen &lt; MAXWLEN - 3; ++wlen) {</a>
<a name="ln5272">      i = 1;</a>
<a name="ln5273">      if (wordcount == orgnr &amp;&amp; byts[n + 1] == NUL)</a>
<a name="ln5274">        break;          // found end of word</a>
<a name="ln5275"> </a>
<a name="ln5276">      if (byts[n + 1] == NUL)</a>
<a name="ln5277">        ++wordcount;</a>
<a name="ln5278"> </a>
<a name="ln5279">      // skip over the NUL bytes</a>
<a name="ln5280">      for (; byts[n + i] == NUL; ++i)</a>
<a name="ln5281">        if (i &gt; byts[n]) {              // safety check</a>
<a name="ln5282">          STRCPY(theword + wlen, &quot;BAD&quot;);</a>
<a name="ln5283">          wlen += 3;</a>
<a name="ln5284">          goto badword;</a>
<a name="ln5285">        }</a>
<a name="ln5286"> </a>
<a name="ln5287">      // One of the siblings must have the word.</a>
<a name="ln5288">      for (; i &lt; byts[n]; ++i) {</a>
<a name="ln5289">        wc = idxs[idxs[n + i]];         // nr of words under this byte</a>
<a name="ln5290">        if (wordcount + wc &gt; orgnr)</a>
<a name="ln5291">          break;</a>
<a name="ln5292">        wordcount += wc;</a>
<a name="ln5293">      }</a>
<a name="ln5294"> </a>
<a name="ln5295">      theword[wlen] = byts[n + i];</a>
<a name="ln5296">      n = idxs[n + i];</a>
<a name="ln5297">    }</a>
<a name="ln5298">badword:</a>
<a name="ln5299">    theword[wlen] = NUL;</a>
<a name="ln5300"> </a>
<a name="ln5301">    // Go over the possible flags and regions.</a>
<a name="ln5302">    for (; i &lt;= byts[n] &amp;&amp; byts[n + i] == NUL; ++i) {</a>
<a name="ln5303">      char_u cword[MAXWLEN];</a>
<a name="ln5304">      char_u      *p;</a>
<a name="ln5305">      int flags = (int)idxs[n + i];</a>
<a name="ln5306"> </a>
<a name="ln5307">      // Skip words with the NOSUGGEST flag</a>
<a name="ln5308">      if (flags &amp; WF_NOSUGGEST)</a>
<a name="ln5309">        continue;</a>
<a name="ln5310"> </a>
<a name="ln5311">      if (flags &amp; WF_KEEPCAP) {</a>
<a name="ln5312">        // Must find the word in the keep-case tree.</a>
<a name="ln5313">        find_keepcap_word(slang, theword, cword);</a>
<a name="ln5314">        p = cword;</a>
<a name="ln5315">      } else {</a>
<a name="ln5316">        flags |= su-&gt;su_badflags;</a>
<a name="ln5317">        if ((flags &amp; WF_CAPMASK) != 0) {</a>
<a name="ln5318">          // Need to fix case according to &quot;flags&quot;.</a>
<a name="ln5319">          make_case_word(theword, cword, flags);</a>
<a name="ln5320">          p = cword;</a>
<a name="ln5321">        } else</a>
<a name="ln5322">          p = theword;</a>
<a name="ln5323">      }</a>
<a name="ln5324"> </a>
<a name="ln5325">      // Add the suggestion.</a>
<a name="ln5326">      if (sps_flags &amp; SPS_DOUBLE) {</a>
<a name="ln5327">        // Add the suggestion if the score isn't too bad.</a>
<a name="ln5328">        if (score &lt;= su-&gt;su_maxscore)</a>
<a name="ln5329">          add_suggestion(su, &amp;su-&gt;su_sga, p, su-&gt;su_badlen,</a>
<a name="ln5330">              score, 0, false, slang, false);</a>
<a name="ln5331">      } else {</a>
<a name="ln5332">        // Add a penalty for words in another region.</a>
<a name="ln5333">        if ((flags &amp; WF_REGION)</a>
<a name="ln5334">            &amp;&amp; (((unsigned)flags &gt;&gt; 16) &amp; lp-&gt;lp_region) == 0)</a>
<a name="ln5335">          goodscore = SCORE_REGION;</a>
<a name="ln5336">        else</a>
<a name="ln5337">          goodscore = 0;</a>
<a name="ln5338"> </a>
<a name="ln5339">        // Add a small penalty for changing the first letter from</a>
<a name="ln5340">        // lower to upper case.  Helps for &quot;tath&quot; -&gt; &quot;Kath&quot;, which is</a>
<a name="ln5341">        // less common than &quot;tath&quot; -&gt; &quot;path&quot;.  Don't do it when the</a>
<a name="ln5342">        // letter is the same, that has already been counted.</a>
<a name="ln5343">        gc = PTR2CHAR(p);</a>
<a name="ln5344">        if (SPELL_ISUPPER(gc)) {</a>
<a name="ln5345">          bc = PTR2CHAR(su-&gt;su_badword);</a>
<a name="ln5346">          if (!SPELL_ISUPPER(bc)</a>
<a name="ln5347">              &amp;&amp; SPELL_TOFOLD(bc) != SPELL_TOFOLD(gc))</a>
<a name="ln5348">            goodscore += SCORE_ICASE / 2;</a>
<a name="ln5349">        }</a>
<a name="ln5350"> </a>
<a name="ln5351">        // Compute the score for the good word.  This only does letter</a>
<a name="ln5352">        // insert/delete/swap/replace.  REP items are not considered,</a>
<a name="ln5353">        // which may make the score a bit higher.</a>
<a name="ln5354">        // Use a limit for the score to make it work faster.  Use</a>
<a name="ln5355">        // MAXSCORE(), because RESCORE() will change the score.</a>
<a name="ln5356">        // If the limit is very high then the iterative method is</a>
<a name="ln5357">        // inefficient, using an array is quicker.</a>
<a name="ln5358">        limit = MAXSCORE(su-&gt;su_sfmaxscore - goodscore, score);</a>
<a name="ln5359">        if (limit &gt; SCORE_LIMITMAX)</a>
<a name="ln5360">          goodscore += spell_edit_score(slang, su-&gt;su_badword, p);</a>
<a name="ln5361">        else</a>
<a name="ln5362">          goodscore += spell_edit_score_limit(slang, su-&gt;su_badword,</a>
<a name="ln5363">              p, limit);</a>
<a name="ln5364"> </a>
<a name="ln5365">        // When going over the limit don't bother to do the rest.</a>
<a name="ln5366">        if (goodscore &lt; SCORE_MAXMAX) {</a>
<a name="ln5367">          // Give a bonus to words seen before.</a>
<a name="ln5368">          goodscore = score_wordcount_adj(slang, goodscore, p, false);</a>
<a name="ln5369"> </a>
<a name="ln5370">          // Add the suggestion if the score isn't too bad.</a>
<a name="ln5371">          goodscore = RESCORE(goodscore, score);</a>
<a name="ln5372">          if (goodscore &lt;= su-&gt;su_sfmaxscore)</a>
<a name="ln5373">            add_suggestion(su, &amp;su-&gt;su_ga, p, su-&gt;su_badlen,</a>
<a name="ln5374">                goodscore, score, true, slang, true);</a>
<a name="ln5375">        }</a>
<a name="ln5376">      }</a>
<a name="ln5377">    }</a>
<a name="ln5378">  }</a>
<a name="ln5379">}</a>
<a name="ln5380"> </a>
<a name="ln5381">// Find word &quot;word&quot; in fold-case tree for &quot;slang&quot; and return the word number.</a>
<a name="ln5382">static int soundfold_find(slang_T *slang, char_u *word)</a>
<a name="ln5383">{</a>
<a name="ln5384">  idx_T arridx = 0;</a>
<a name="ln5385">  int len;</a>
<a name="ln5386">  int wlen = 0;</a>
<a name="ln5387">  int c;</a>
<a name="ln5388">  char_u      *ptr = word;</a>
<a name="ln5389">  char_u      *byts;</a>
<a name="ln5390">  idx_T       *idxs;</a>
<a name="ln5391">  int wordnr = 0;</a>
<a name="ln5392"> </a>
<a name="ln5393">  byts = slang-&gt;sl_sbyts;</a>
<a name="ln5394">  idxs = slang-&gt;sl_sidxs;</a>
<a name="ln5395"> </a>
<a name="ln5396">  for (;; ) {</a>
<a name="ln5397">    // First byte is the number of possible bytes.</a>
<a name="ln5398">    len = byts[arridx++];</a>
<a name="ln5399"> </a>
<a name="ln5400">    // If the first possible byte is a zero the word could end here.</a>
<a name="ln5401">    // If the word ends we found the word.  If not skip the NUL bytes.</a>
<a name="ln5402">    c = ptr[wlen];</a>
<a name="ln5403">    if (byts[arridx] == NUL) {</a>
<a name="ln5404">      if (c == NUL)</a>
<a name="ln5405">        break;</a>
<a name="ln5406"> </a>
<a name="ln5407">      // Skip over the zeros, there can be several.</a>
<a name="ln5408">      while (len &gt; 0 &amp;&amp; byts[arridx] == NUL) {</a>
<a name="ln5409">        ++arridx;</a>
<a name="ln5410">        --len;</a>
<a name="ln5411">      }</a>
<a name="ln5412">      if (len == 0)</a>
<a name="ln5413">        return -1;            // no children, word should have ended here</a>
<a name="ln5414">      ++wordnr;</a>
<a name="ln5415">    }</a>
<a name="ln5416"> </a>
<a name="ln5417">    // If the word ends we didn't find it.</a>
<a name="ln5418">    if (c == NUL)</a>
<a name="ln5419">      return -1;</a>
<a name="ln5420"> </a>
<a name="ln5421">    // Perform a binary search in the list of accepted bytes.</a>
<a name="ln5422">    if (c == TAB)           // &lt;Tab&gt; is handled like &lt;Space&gt;</a>
<a name="ln5423">      c = ' ';</a>
<a name="ln5424">    while (byts[arridx] &lt; c) {</a>
<a name="ln5425">      // The word count is in the first idxs[] entry of the child.</a>
<a name="ln5426">      wordnr += idxs[idxs[arridx]];</a>
<a name="ln5427">      ++arridx;</a>
<a name="ln5428">      if (--len == 0)           // end of the bytes, didn't find it</a>
<a name="ln5429">        return -1;</a>
<a name="ln5430">    }</a>
<a name="ln5431">    if (byts[arridx] != c)      // didn't find the byte</a>
<a name="ln5432">      return -1;</a>
<a name="ln5433"> </a>
<a name="ln5434">    // Continue at the child (if there is one).</a>
<a name="ln5435">    arridx = idxs[arridx];</a>
<a name="ln5436">    ++wlen;</a>
<a name="ln5437"> </a>
<a name="ln5438">    // One space in the good word may stand for several spaces in the</a>
<a name="ln5439">    // checked word.</a>
<a name="ln5440">    if (c == ' ')</a>
<a name="ln5441">      while (ptr[wlen] == ' ' || ptr[wlen] == TAB)</a>
<a name="ln5442">        ++wlen;</a>
<a name="ln5443">  }</a>
<a name="ln5444"> </a>
<a name="ln5445">  return wordnr;</a>
<a name="ln5446">}</a>
<a name="ln5447"> </a>
<a name="ln5448">// Copy &quot;fword&quot; to &quot;cword&quot;, fixing case according to &quot;flags&quot;.</a>
<a name="ln5449">static void make_case_word(char_u *fword, char_u *cword, int flags)</a>
<a name="ln5450">{</a>
<a name="ln5451">  if (flags &amp; WF_ALLCAP)</a>
<a name="ln5452">    // Make it all upper-case</a>
<a name="ln5453">    allcap_copy(fword, cword);</a>
<a name="ln5454">  else if (flags &amp; WF_ONECAP)</a>
<a name="ln5455">    // Make the first letter upper-case</a>
<a name="ln5456">    onecap_copy(fword, cword, true);</a>
<a name="ln5457">  else</a>
<a name="ln5458">    // Use goodword as-is.</a>
<a name="ln5459">    STRCPY(cword, fword);</a>
<a name="ln5460">}</a>
<a name="ln5461"> </a>
<a name="ln5462">// Returns true if &quot;c1&quot; and &quot;c2&quot; are similar characters according to the MAP</a>
<a name="ln5463">// lines in the .aff file.</a>
<a name="ln5464">static bool similar_chars(slang_T *slang, int c1, int c2)</a>
<a name="ln5465">{</a>
<a name="ln5466">  int m1, m2;</a>
<a name="ln5467">  char_u buf[MB_MAXBYTES + 1];</a>
<a name="ln5468">  hashitem_T  *hi;</a>
<a name="ln5469"> </a>
<a name="ln5470">  if (c1 &gt;= 256) {</a>
<a name="ln5471">    buf[utf_char2bytes(c1, buf)] = 0;</a>
<a name="ln5472">    hi = hash_find(&amp;slang-&gt;sl_map_hash, buf);</a>
<a name="ln5473">    if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln5474">      m1 = 0;</a>
<a name="ln5475">    } else {</a>
<a name="ln5476">      m1 = utf_ptr2char(hi-&gt;hi_key + STRLEN(hi-&gt;hi_key) + 1);</a>
<a name="ln5477">    }</a>
<a name="ln5478">  } else {</a>
<a name="ln5479">    m1 = slang-&gt;sl_map_array[c1];</a>
<a name="ln5480">  }</a>
<a name="ln5481">  if (m1 == 0) {</a>
<a name="ln5482">    return false;</a>
<a name="ln5483">  }</a>
<a name="ln5484"> </a>
<a name="ln5485">  if (c2 &gt;= 256) {</a>
<a name="ln5486">    buf[utf_char2bytes(c2, buf)] = 0;</a>
<a name="ln5487">    hi = hash_find(&amp;slang-&gt;sl_map_hash, buf);</a>
<a name="ln5488">    if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln5489">      m2 = 0;</a>
<a name="ln5490">    } else {</a>
<a name="ln5491">      m2 = utf_ptr2char(hi-&gt;hi_key + STRLEN(hi-&gt;hi_key) + 1);</a>
<a name="ln5492">    }</a>
<a name="ln5493">  } else {</a>
<a name="ln5494">    m2 = slang-&gt;sl_map_array[c2];</a>
<a name="ln5495">  }</a>
<a name="ln5496"> </a>
<a name="ln5497">  return m1 == m2;</a>
<a name="ln5498">}</a>
<a name="ln5499"> </a>
<a name="ln5500">// Adds a suggestion to the list of suggestions.</a>
<a name="ln5501">// For a suggestion that is already in the list the lowest score is remembered.</a>
<a name="ln5502">static void</a>
<a name="ln5503">add_suggestion (</a>
<a name="ln5504">    suginfo_T *su,</a>
<a name="ln5505">    garray_T *gap,              // either su_ga or su_sga</a>
<a name="ln5506">    const char_u *goodword,</a>
<a name="ln5507">    int badlenarg,              // len of bad word replaced with &quot;goodword&quot;</a>
<a name="ln5508">    int score,</a>
<a name="ln5509">    int altscore,</a>
<a name="ln5510">    bool had_bonus,             // value for st_had_bonus</a>
<a name="ln5511">    slang_T *slang,             // language for sound folding</a>
<a name="ln5512">    bool maxsf                  // su_maxscore applies to soundfold score,</a>
<a name="ln5513">                                // su_sfmaxscore to the total score.</a>
<a name="ln5514">)</a>
<a name="ln5515">{</a>
<a name="ln5516">  int goodlen;                  // len of goodword changed</a>
<a name="ln5517">  int badlen;                   // len of bad word changed</a>
<a name="ln5518">  suggest_T   *stp;</a>
<a name="ln5519">  suggest_T new_sug;</a>
<a name="ln5520"> </a>
<a name="ln5521">  // Minimize &quot;badlen&quot; for consistency.  Avoids that changing &quot;the the&quot; to</a>
<a name="ln5522">  // &quot;thee the&quot; is added next to changing the first &quot;the&quot; the &quot;thee&quot;.</a>
<a name="ln5523">  const char_u *pgood = goodword + STRLEN(goodword);</a>
<a name="ln5524">  char_u *pbad = su-&gt;su_badptr + badlenarg;</a>
<a name="ln5525">  for (;; ) {</a>
<a name="ln5526">    goodlen = (int)(pgood - goodword);</a>
<a name="ln5527">    badlen = (int)(pbad - su-&gt;su_badptr);</a>
<a name="ln5528">    if (goodlen &lt;= 0 || badlen &lt;= 0)</a>
<a name="ln5529">      break;</a>
<a name="ln5530">    MB_PTR_BACK(goodword, pgood);</a>
<a name="ln5531">    MB_PTR_BACK(su-&gt;su_badptr, pbad);</a>
<a name="ln5532">    if (utf_ptr2char(pgood) != utf_ptr2char(pbad)) {</a>
<a name="ln5533">      break;</a>
<a name="ln5534">    }</a>
<a name="ln5535">  }</a>
<a name="ln5536"> </a>
<a name="ln5537">  if (badlen == 0 &amp;&amp; goodlen == 0)</a>
<a name="ln5538">    // goodword doesn't change anything; may happen for &quot;the the&quot; changing</a>
<a name="ln5539">    // the first &quot;the&quot; to itself.</a>
<a name="ln5540">    return;</a>
<a name="ln5541"> </a>
<a name="ln5542">  int i;</a>
<a name="ln5543">  if (GA_EMPTY(gap)) {</a>
<a name="ln5544">    i = -1;</a>
<a name="ln5545">  } else {</a>
<a name="ln5546">    // Check if the word is already there.  Also check the length that is</a>
<a name="ln5547">    // being replaced &quot;thes,&quot; -&gt; &quot;these&quot; is a different suggestion from</a>
<a name="ln5548">    // &quot;thes&quot; -&gt; &quot;these&quot;.</a>
<a name="ln5549">    stp = &amp;SUG(*gap, 0);</a>
<a name="ln5550">    for (i = gap-&gt;ga_len; --i &gt;= 0; ++stp) {</a>
<a name="ln5551">      if (stp-&gt;st_wordlen == goodlen</a>
<a name="ln5552">          &amp;&amp; stp-&gt;st_orglen == badlen</a>
<a name="ln5553">          &amp;&amp; STRNCMP(stp-&gt;st_word, goodword, goodlen) == 0) {</a>
<a name="ln5554">        // Found it.  Remember the word with the lowest score.</a>
<a name="ln5555">        if (stp-&gt;st_slang == NULL)</a>
<a name="ln5556">          stp-&gt;st_slang = slang;</a>
<a name="ln5557"> </a>
<a name="ln5558">        new_sug.st_score = score;</a>
<a name="ln5559">        new_sug.st_altscore = altscore;</a>
<a name="ln5560">        new_sug.st_had_bonus = had_bonus;</a>
<a name="ln5561"> </a>
<a name="ln5562">        if (stp-&gt;st_had_bonus != had_bonus) {</a>
<a name="ln5563">          // Only one of the two had the soundalike score computed.</a>
<a name="ln5564">          // Need to do that for the other one now, otherwise the</a>
<a name="ln5565">          // scores can't be compared.  This happens because</a>
<a name="ln5566">          // suggest_try_change() doesn't compute the soundalike</a>
<a name="ln5567">          // word to keep it fast, while some special methods set</a>
<a name="ln5568">          // the soundalike score to zero.</a>
<a name="ln5569">          if (had_bonus)</a>
<a name="ln5570">            rescore_one(su, stp);</a>
<a name="ln5571">          else {</a>
<a name="ln5572">            new_sug.st_word = stp-&gt;st_word;</a>
<a name="ln5573">            new_sug.st_wordlen = stp-&gt;st_wordlen;</a>
<a name="ln5574">            new_sug.st_slang = stp-&gt;st_slang;</a>
<a name="ln5575">            new_sug.st_orglen = badlen;</a>
<a name="ln5576">            rescore_one(su, &amp;new_sug);</a>
<a name="ln5577">          }</a>
<a name="ln5578">        }</a>
<a name="ln5579"> </a>
<a name="ln5580">        if (stp-&gt;st_score &gt; new_sug.st_score) {</a>
<a name="ln5581">          stp-&gt;st_score = new_sug.st_score;</a>
<a name="ln5582">          stp-&gt;st_altscore = new_sug.st_altscore;</a>
<a name="ln5583">          stp-&gt;st_had_bonus = new_sug.st_had_bonus;</a>
<a name="ln5584">        }</a>
<a name="ln5585">        break;</a>
<a name="ln5586">      }</a>
<a name="ln5587">    }</a>
<a name="ln5588">  }</a>
<a name="ln5589"> </a>
<a name="ln5590">  if (i &lt; 0) {</a>
<a name="ln5591">    // Add a suggestion.</a>
<a name="ln5592">    stp = GA_APPEND_VIA_PTR(suggest_T, gap);</a>
<a name="ln5593">    stp-&gt;st_word = vim_strnsave(goodword, goodlen);</a>
<a name="ln5594">    stp-&gt;st_wordlen = goodlen;</a>
<a name="ln5595">    stp-&gt;st_score = score;</a>
<a name="ln5596">    stp-&gt;st_altscore = altscore;</a>
<a name="ln5597">    stp-&gt;st_had_bonus = had_bonus;</a>
<a name="ln5598">    stp-&gt;st_orglen = badlen;</a>
<a name="ln5599">    stp-&gt;st_slang = slang;</a>
<a name="ln5600"> </a>
<a name="ln5601">    // If we have too many suggestions now, sort the list and keep</a>
<a name="ln5602">    // the best suggestions.</a>
<a name="ln5603">    if (gap-&gt;ga_len &gt; SUG_MAX_COUNT(su)) {</a>
<a name="ln5604">      if (maxsf)</a>
<a name="ln5605">        su-&gt;su_sfmaxscore = cleanup_suggestions(gap,</a>
<a name="ln5606">            su-&gt;su_sfmaxscore, SUG_CLEAN_COUNT(su));</a>
<a name="ln5607">      else</a>
<a name="ln5608">        su-&gt;su_maxscore = cleanup_suggestions(gap,</a>
<a name="ln5609">            su-&gt;su_maxscore, SUG_CLEAN_COUNT(su));</a>
<a name="ln5610">    }</a>
<a name="ln5611">  }</a>
<a name="ln5612">}</a>
<a name="ln5613"> </a>
<a name="ln5614">// Suggestions may in fact be flagged as errors.  Esp. for banned words and</a>
<a name="ln5615">// for split words, such as &quot;the the&quot;.  Remove these from the list here.</a>
<a name="ln5616">static void</a>
<a name="ln5617">check_suggestions (</a>
<a name="ln5618">    suginfo_T *su,</a>
<a name="ln5619">    garray_T *gap                   // either su_ga or su_sga</a>
<a name="ln5620">)</a>
<a name="ln5621">{</a>
<a name="ln5622">  suggest_T   *stp;</a>
<a name="ln5623">  char_u longword[MAXWLEN + 1];</a>
<a name="ln5624">  int len;</a>
<a name="ln5625">  hlf_T attr;</a>
<a name="ln5626"> </a>
<a name="ln5627">  if (gap-&gt;ga_len == 0) {</a>
<a name="ln5628">    return;</a>
<a name="ln5629">  }</a>
<a name="ln5630">  stp = &amp;SUG(*gap, 0);</a>
<a name="ln5631">  for (int i = gap-&gt;ga_len - 1; i &gt;= 0; --i) {</a>
<a name="ln5632">    // Need to append what follows to check for &quot;the the&quot;.</a>
<a name="ln5633">    STRLCPY(longword, stp[i].st_word, MAXWLEN + 1);</a>
<a name="ln5634">    len = stp[i].st_wordlen;</a>
<a name="ln5635">    STRLCPY(longword + len, su-&gt;su_badptr + stp[i].st_orglen,</a>
<a name="ln5636">        MAXWLEN - len + 1);</a>
<a name="ln5637">    attr = HLF_COUNT;</a>
<a name="ln5638">    (void)spell_check(curwin, longword, &amp;attr, NULL, false);</a>
<a name="ln5639">    if (attr != HLF_COUNT) {</a>
<a name="ln5640">      // Remove this entry.</a>
<a name="ln5641">      xfree(stp[i].st_word);</a>
<a name="ln5642">      --gap-&gt;ga_len;</a>
<a name="ln5643">      if (i &lt; gap-&gt;ga_len)</a>
<a name="ln5644">        memmove(stp + i, stp + i + 1,</a>
<a name="ln5645">            sizeof(suggest_T) * (gap-&gt;ga_len - i));</a>
<a name="ln5646">    }</a>
<a name="ln5647">  }</a>
<a name="ln5648">}</a>
<a name="ln5649"> </a>
<a name="ln5650"> </a>
<a name="ln5651">// Add a word to be banned.</a>
<a name="ln5652">static void add_banned(suginfo_T *su, char_u *word)</a>
<a name="ln5653">{</a>
<a name="ln5654">  char_u      *s;</a>
<a name="ln5655">  hash_T hash;</a>
<a name="ln5656">  hashitem_T  *hi;</a>
<a name="ln5657"> </a>
<a name="ln5658">  hash = hash_hash(word);</a>
<a name="ln5659">  const size_t word_len = STRLEN(word);</a>
<a name="ln5660">  hi = hash_lookup(&amp;su-&gt;su_banned, (const char *)word, word_len, hash);</a>
<a name="ln5661">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln5662">    s = xmemdupz(word, word_len);</a>
<a name="ln5663">    hash_add_item(&amp;su-&gt;su_banned, hi, s, hash);</a>
<a name="ln5664">  }</a>
<a name="ln5665">}</a>
<a name="ln5666"> </a>
<a name="ln5667">// Recompute the score for all suggestions if sound-folding is possible.  This</a>
<a name="ln5668">// is slow, thus only done for the final results.</a>
<a name="ln5669">static void rescore_suggestions(suginfo_T *su)</a>
<a name="ln5670">{</a>
<a name="ln5671">  if (su-&gt;su_sallang != NULL) {</a>
<a name="ln5672">    for (int i = 0; i &lt; su-&gt;su_ga.ga_len; ++i) {</a>
<a name="ln5673">      rescore_one(su, &amp;SUG(su-&gt;su_ga, i));</a>
<a name="ln5674">    }</a>
<a name="ln5675">  }</a>
<a name="ln5676">}</a>
<a name="ln5677"> </a>
<a name="ln5678">// Recompute the score for one suggestion if sound-folding is possible.</a>
<a name="ln5679">static void rescore_one(suginfo_T *su, suggest_T *stp)</a>
<a name="ln5680">{</a>
<a name="ln5681">  slang_T     *slang = stp-&gt;st_slang;</a>
<a name="ln5682">  char_u sal_badword[MAXWLEN];</a>
<a name="ln5683">  char_u      *p;</a>
<a name="ln5684"> </a>
<a name="ln5685">  // Only rescore suggestions that have no sal score yet and do have a</a>
<a name="ln5686">  // language.</a>
<a name="ln5687">  if (slang != NULL &amp;&amp; !GA_EMPTY(&amp;slang-&gt;sl_sal) &amp;&amp; !stp-&gt;st_had_bonus) {</a>
<a name="ln5688">    if (slang == su-&gt;su_sallang)</a>
<a name="ln5689">      p = su-&gt;su_sal_badword;</a>
<a name="ln5690">    else {</a>
<a name="ln5691">      spell_soundfold(slang, su-&gt;su_fbadword, true, sal_badword);</a>
<a name="ln5692">      p = sal_badword;</a>
<a name="ln5693">    }</a>
<a name="ln5694"> </a>
<a name="ln5695">    stp-&gt;st_altscore = stp_sal_score(stp, su, slang, p);</a>
<a name="ln5696">    if (stp-&gt;st_altscore == SCORE_MAXMAX)</a>
<a name="ln5697">      stp-&gt;st_altscore = SCORE_BIG;</a>
<a name="ln5698">    stp-&gt;st_score = RESCORE(stp-&gt;st_score, stp-&gt;st_altscore);</a>
<a name="ln5699">    stp-&gt;st_had_bonus = true;</a>
<a name="ln5700">  }</a>
<a name="ln5701">}</a>
<a name="ln5702"> </a>
<a name="ln5703"> </a>
<a name="ln5704">// Function given to qsort() to sort the suggestions on st_score.</a>
<a name="ln5705">// First on &quot;st_score&quot;, then &quot;st_altscore&quot; then alphabetically.</a>
<a name="ln5706">static int sug_compare(const void *s1, const void *s2)</a>
<a name="ln5707">{</a>
<a name="ln5708">  suggest_T   *p1 = (suggest_T *)s1;</a>
<a name="ln5709">  suggest_T   *p2 = (suggest_T *)s2;</a>
<a name="ln5710">  int n = p1-&gt;st_score - p2-&gt;st_score;</a>
<a name="ln5711"> </a>
<a name="ln5712">  if (n == 0) {</a>
<a name="ln5713">    n = p1-&gt;st_altscore - p2-&gt;st_altscore;</a>
<a name="ln5714">    if (n == 0)</a>
<a name="ln5715">      n = STRICMP(p1-&gt;st_word, p2-&gt;st_word);</a>
<a name="ln5716">  }</a>
<a name="ln5717">  return n;</a>
<a name="ln5718">}</a>
<a name="ln5719"> </a>
<a name="ln5720">// Cleanup the suggestions:</a>
<a name="ln5721">// - Sort on score.</a>
<a name="ln5722">// - Remove words that won't be displayed.</a>
<a name="ln5723">// Returns the maximum score in the list or &quot;maxscore&quot; unmodified.</a>
<a name="ln5724">static int</a>
<a name="ln5725">cleanup_suggestions (</a>
<a name="ln5726">    garray_T *gap,</a>
<a name="ln5727">    int maxscore,</a>
<a name="ln5728">    int keep                       // nr of suggestions to keep</a>
<a name="ln5729">)</a>
<a name="ln5730">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5731">{</a>
<a name="ln5732">  if (gap-&gt;ga_len &gt; 0) {</a>
<a name="ln5733">    // Sort the list.</a>
<a name="ln5734">    qsort(gap-&gt;ga_data, (size_t)gap-&gt;ga_len, sizeof(suggest_T), sug_compare);</a>
<a name="ln5735"> </a>
<a name="ln5736">    // Truncate the list to the number of suggestions that will be displayed.</a>
<a name="ln5737">    if (gap-&gt;ga_len &gt; keep) {</a>
<a name="ln5738">      suggest_T *const stp = &amp;SUG(*gap, 0);</a>
<a name="ln5739"> </a>
<a name="ln5740">      for (int i = keep; i &lt; gap-&gt;ga_len; i++) {</a>
<a name="ln5741">        xfree(stp[i].st_word);</a>
<a name="ln5742">      }</a>
<a name="ln5743">      gap-&gt;ga_len = keep;</a>
<a name="ln5744">      return stp[keep - 1].st_score;</a>
<a name="ln5745">    }</a>
<a name="ln5746">  }</a>
<a name="ln5747">  return maxscore;</a>
<a name="ln5748">}</a>
<a name="ln5749"> </a>
<a name="ln5750">/// Soundfold a string, for soundfold()</a>
<a name="ln5751">///</a>
<a name="ln5752">/// @param[in]  word  Word to soundfold.</a>
<a name="ln5753">///</a>
<a name="ln5754">/// @return [allocated] soundfolded string or NULL in case of error. May return</a>
<a name="ln5755">///                     copy of the input string if soundfolding is not</a>
<a name="ln5756">///                     supported by any of the languages in &amp;spellang.</a>
<a name="ln5757">char *eval_soundfold(const char *const word)</a>
<a name="ln5758">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5759">{</a>
<a name="ln5760">  if (curwin-&gt;w_p_spell &amp;&amp; *curwin-&gt;w_s-&gt;b_p_spl != NUL) {</a>
<a name="ln5761">    // Use the sound-folding of the first language that supports it.</a>
<a name="ln5762">    for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; lpi++) {</a>
<a name="ln5763">      langp_T *const lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln5764">      if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_sal)) {</a>
<a name="ln5765">        // soundfold the word</a>
<a name="ln5766">        char_u sound[MAXWLEN];</a>
<a name="ln5767">        spell_soundfold(lp-&gt;lp_slang, (char_u *)word, false, sound);</a>
<a name="ln5768">        return xstrdup((const char *)sound);</a>
<a name="ln5769">      }</a>
<a name="ln5770">    }</a>
<a name="ln5771">  }</a>
<a name="ln5772"> </a>
<a name="ln5773">  // No language with sound folding, return word as-is.</a>
<a name="ln5774">  return xstrdup(word);</a>
<a name="ln5775">}</a>
<a name="ln5776"> </a>
<a name="ln5777">/// Turn &quot;inword&quot; into its sound-a-like equivalent in &quot;res[MAXWLEN]&quot;.</a>
<a name="ln5778">///</a>
<a name="ln5779">/// There are many ways to turn a word into a sound-a-like representation.  The</a>
<a name="ln5780">/// oldest is Soundex (1918!).   A nice overview can be found in &quot;Approximate</a>
<a name="ln5781">/// swedish name matching - survey and test of different algorithms&quot; by Klas</a>
<a name="ln5782">/// Erikson.</a>
<a name="ln5783">///</a>
<a name="ln5784">/// We support two methods:</a>
<a name="ln5785">/// 1. SOFOFROM/SOFOTO do a simple character mapping.</a>
<a name="ln5786">/// 2. SAL items define a more advanced sound-folding (and much slower).</a>
<a name="ln5787">///</a>
<a name="ln5788">/// @param[in]  slang</a>
<a name="ln5789">/// @param[in]  inword  word to soundfold</a>
<a name="ln5790">/// @param[in]  folded  whether inword is already case-folded</a>
<a name="ln5791">/// @param[in,out]  res  destination for soundfolded word</a>
<a name="ln5792">void spell_soundfold(slang_T *slang, char_u *inword, bool folded, char_u *res)</a>
<a name="ln5793">{</a>
<a name="ln5794">  char_u fword[MAXWLEN];</a>
<a name="ln5795">  char_u      *word;</a>
<a name="ln5796"> </a>
<a name="ln5797">  if (slang-&gt;sl_sofo)</a>
<a name="ln5798">    // SOFOFROM and SOFOTO used</a>
<a name="ln5799">    spell_soundfold_sofo(slang, inword, res);</a>
<a name="ln5800">  else {</a>
<a name="ln5801">    // SAL items used.  Requires the word to be case-folded.</a>
<a name="ln5802">    if (folded)</a>
<a name="ln5803">      word = inword;</a>
<a name="ln5804">    else {</a>
<a name="ln5805">      (void)spell_casefold(inword, (int)STRLEN(inword), fword, MAXWLEN);</a>
<a name="ln5806">      word = fword;</a>
<a name="ln5807">    }</a>
<a name="ln5808"> </a>
<a name="ln5809">    spell_soundfold_wsal(slang, word, res);</a>
<a name="ln5810">  }</a>
<a name="ln5811">}</a>
<a name="ln5812"> </a>
<a name="ln5813">// Perform sound folding of &quot;inword&quot; into &quot;res&quot; according to SOFOFROM and</a>
<a name="ln5814">// SOFOTO lines.</a>
<a name="ln5815">static void spell_soundfold_sofo(slang_T *slang, char_u *inword, char_u *res)</a>
<a name="ln5816">{</a>
<a name="ln5817">  int ri = 0;</a>
<a name="ln5818"> </a>
<a name="ln5819">  int prevc = 0;</a>
<a name="ln5820"> </a>
<a name="ln5821">  // The sl_sal_first[] table contains the translation for chars up to</a>
<a name="ln5822">  // 255, sl_sal the rest.</a>
<a name="ln5823">  for (char_u *s = inword; *s != NUL; ) {</a>
<a name="ln5824">    int c = mb_cptr2char_adv((const char_u **)&amp;s);</a>
<a name="ln5825">    if (utf_class(c) == 0) {</a>
<a name="ln5826">      c = ' ';</a>
<a name="ln5827">    } else if (c &lt; 256) {</a>
<a name="ln5828">      c = slang-&gt;sl_sal_first[c];</a>
<a name="ln5829">    } else {</a>
<a name="ln5830">      int *ip = ((int **)slang-&gt;sl_sal.ga_data)[c &amp; 0xff];</a>
<a name="ln5831">      if (ip == NULL) {               // empty list, can't match</a>
<a name="ln5832">        c = NUL;</a>
<a name="ln5833">      } else {</a>
<a name="ln5834">        for (;; ) {                   // find &quot;c&quot; in the list</a>
<a name="ln5835">          if (*ip == 0) {             // not found</a>
<a name="ln5836">            c = NUL;</a>
<a name="ln5837">            break;</a>
<a name="ln5838">          }</a>
<a name="ln5839">          if (*ip == c) {             // match!</a>
<a name="ln5840">            c = ip[1];</a>
<a name="ln5841">            break;</a>
<a name="ln5842">          }</a>
<a name="ln5843">          ip += 2;</a>
<a name="ln5844">        }</a>
<a name="ln5845">      }</a>
<a name="ln5846">    }</a>
<a name="ln5847"> </a>
<a name="ln5848">    if (c != NUL &amp;&amp; c != prevc) {</a>
<a name="ln5849">      ri += utf_char2bytes(c, res + ri);</a>
<a name="ln5850">      if (ri + MB_MAXBYTES &gt; MAXWLEN) {</a>
<a name="ln5851">        break;</a>
<a name="ln5852">      }</a>
<a name="ln5853">      prevc = c;</a>
<a name="ln5854">    }</a>
<a name="ln5855">  }</a>
<a name="ln5856"> </a>
<a name="ln5857">  res[ri] = NUL;</a>
<a name="ln5858">}</a>
<a name="ln5859"> </a>
<a name="ln5860">// Turn &quot;inword&quot; into its sound-a-like equivalent in &quot;res[MAXWLEN]&quot;.</a>
<a name="ln5861">// Multi-byte version of spell_soundfold().</a>
<a name="ln5862">static void spell_soundfold_wsal(slang_T *slang, char_u *inword, char_u *res)</a>
<a name="ln5863">{</a>
<a name="ln5864">  salitem_T   *smp = (salitem_T *)slang-&gt;sl_sal.ga_data;</a>
<a name="ln5865">  int word[MAXWLEN] = { 0 };</a>
<a name="ln5866">  int wres[MAXWLEN] = { 0 };</a>
<a name="ln5867">  int l;</a>
<a name="ln5868">  int         *ws;</a>
<a name="ln5869">  int         *pf;</a>
<a name="ln5870">  int i, j, z;</a>
<a name="ln5871">  int reslen;</a>
<a name="ln5872">  int n, k = 0;</a>
<a name="ln5873">  int z0;</a>
<a name="ln5874">  int k0;</a>
<a name="ln5875">  int n0;</a>
<a name="ln5876">  int c;</a>
<a name="ln5877">  int pri;</a>
<a name="ln5878">  int p0 = -333;</a>
<a name="ln5879">  int c0;</a>
<a name="ln5880">  bool did_white = false;</a>
<a name="ln5881">  int wordlen;</a>
<a name="ln5882"> </a>
<a name="ln5883"> </a>
<a name="ln5884">  // Convert the multi-byte string to a wide-character string.</a>
<a name="ln5885">  // Remove accents, if wanted.  We actually remove all non-word characters.</a>
<a name="ln5886">  // But keep white space.</a>
<a name="ln5887">  wordlen = 0;</a>
<a name="ln5888">  for (const char_u *s = inword; *s != NUL; ) {</a>
<a name="ln5889">    const char_u *t = s;</a>
<a name="ln5890">    c = mb_cptr2char_adv((const char_u **)&amp;s);</a>
<a name="ln5891">    if (slang-&gt;sl_rem_accents) {</a>
<a name="ln5892">      if (utf_class(c) == 0) {</a>
<a name="ln5893">        if (did_white) {</a>
<a name="ln5894">          continue;</a>
<a name="ln5895">        }</a>
<a name="ln5896">        c = ' ';</a>
<a name="ln5897">        did_white = true;</a>
<a name="ln5898">      } else {</a>
<a name="ln5899">        did_white = false;</a>
<a name="ln5900">        if (!spell_iswordp_nmw(t, curwin)) {</a>
<a name="ln5901">          continue;</a>
<a name="ln5902">        }</a>
<a name="ln5903">      }</a>
<a name="ln5904">    }</a>
<a name="ln5905">    word[wordlen++] = c;</a>
<a name="ln5906">  }</a>
<a name="ln5907">  word[wordlen] = NUL;</a>
<a name="ln5908"> </a>
<a name="ln5909">  // This algorithm comes from Aspell phonet.cpp.</a>
<a name="ln5910">  // Converted from C++ to C.  Added support for multi-byte chars.</a>
<a name="ln5911">  // Changed to keep spaces.</a>
<a name="ln5912">  i = reslen = z = 0;</a>
<a name="ln5913">  while ((c = word[i]) != NUL) {</a>
<a name="ln5914">    // Start with the first rule that has the character in the word.</a>
<a name="ln5915">    n = slang-&gt;sl_sal_first[c &amp; 0xff];</a>
<a name="ln5916">    z0 = 0;</a>
<a name="ln5917"> </a>
<a name="ln5918">    if (n &gt;= 0) {</a>
<a name="ln5919">      // Check all rules for the same index byte.</a>
<a name="ln5920">      // If c is 0x300 need extra check for the end of the array, as</a>
<a name="ln5921">      // (c &amp; 0xff) is NUL.</a>
<a name="ln5922">      for (; ((ws = smp[n].sm_lead_w)[0] &amp; 0xff) == (c &amp; 0xff)</a>
<a name="ln5923">           &amp;&amp; ws[0] != NUL; ++n) {</a>
<a name="ln5924">        // Quickly skip entries that don't match the word.  Most</a>
<a name="ln5925">        // entries are less then three chars, optimize for that.</a>
<a name="ln5926">        if (c != ws[0])</a>
<a name="ln5927">          continue;</a>
<a name="ln5928">        k = smp[n].sm_leadlen;</a>
<a name="ln5929">        if (k &gt; 1) {</a>
<a name="ln5930">          if (word[i + 1] != ws[1])</a>
<a name="ln5931">            continue;</a>
<a name="ln5932">          if (k &gt; 2) {</a>
<a name="ln5933">            for (j = 2; j &lt; k; ++j)</a>
<a name="ln5934">              if (word[i + j] != ws[j])</a>
<a name="ln5935">                break;</a>
<a name="ln5936">            if (j &lt; k)</a>
<a name="ln5937">              continue;</a>
<a name="ln5938">          }</a>
<a name="ln5939">        }</a>
<a name="ln5940"> </a>
<a name="ln5941">        if ((pf = smp[n].sm_oneof_w) != NULL) {</a>
<a name="ln5942">          // Check for match with one of the chars in &quot;sm_oneof&quot;.</a>
<a name="ln5943">          while (*pf != NUL &amp;&amp; *pf != word[i + k])</a>
<a name="ln5944">            ++pf;</a>
<a name="ln5945">          if (*pf == NUL)</a>
<a name="ln5946">            continue;</a>
<a name="ln5947">          ++k;</a>
<a name="ln5948">        }</a>
<a name="ln5949">        char_u *s = smp[n].sm_rules;</a>
<a name="ln5950">        pri = 5;            // default priority</a>
<a name="ln5951"> </a>
<a name="ln5952">        p0 = *s;</a>
<a name="ln5953">        k0 = k;</a>
<a name="ln5954">        while (*s == '-' &amp;&amp; k &gt; 1) {</a>
<a name="ln5955">          k--;</a>
<a name="ln5956">          s++;</a>
<a name="ln5957">        }</a>
<a name="ln5958">        if (*s == '&lt;')</a>
<a name="ln5959">          s++;</a>
<a name="ln5960">        if (ascii_isdigit(*s)) {</a>
<a name="ln5961">          // determine priority</a>
<a name="ln5962">          pri = *s - '0';</a>
<a name="ln5963">          s++;</a>
<a name="ln5964">        }</a>
<a name="ln5965">        if (*s == '^' &amp;&amp; *(s + 1) == '^')</a>
<a name="ln5966">          s++;</a>
<a name="ln5967"> </a>
<a name="ln5968">        if (*s == NUL</a>
<a name="ln5969">            || (*s == '^'</a>
<a name="ln5970">                &amp;&amp; (i == 0 || !(word[i - 1] == ' '</a>
<a name="ln5971">                                || spell_iswordp_w(word + i - 1, curwin)))</a>
<a name="ln5972">                &amp;&amp; (*(s + 1) != '$'</a>
<a name="ln5973">                    || (!spell_iswordp_w(word + i + k0, curwin))))</a>
<a name="ln5974">            || (*s == '$' &amp;&amp; i &gt; 0</a>
<a name="ln5975">                &amp;&amp; spell_iswordp_w(word + i - 1, curwin)</a>
<a name="ln5976">                &amp;&amp; (!spell_iswordp_w(word + i + k0, curwin)))) {</a>
<a name="ln5977">          // search for followup rules, if:</a>
<a name="ln5978">          // followup and k &gt; 1  and  NO '-' in searchstring</a>
<a name="ln5979">          c0 = word[i + k - 1];</a>
<a name="ln5980">          n0 = slang-&gt;sl_sal_first[c0 &amp; 0xff];</a>
<a name="ln5981"> </a>
<a name="ln5982">          if (slang-&gt;sl_followup &amp;&amp; k &gt; 1 &amp;&amp; n0 &gt;= 0</a>
<a name="ln5983">              &amp;&amp; p0 != '-' &amp;&amp; word[i + k] != NUL) {</a>
<a name="ln5984">            // Test follow-up rule for &quot;word[i + k]&quot;; loop over</a>
<a name="ln5985">            // all entries with the same index byte.</a>
<a name="ln5986">            for (; ((ws = smp[n0].sm_lead_w)[0] &amp; 0xff)</a>
<a name="ln5987">                 == (c0 &amp; 0xff); ++n0) {</a>
<a name="ln5988">              // Quickly skip entries that don't match the word.</a>
<a name="ln5989">              if (c0 != ws[0])</a>
<a name="ln5990">                continue;</a>
<a name="ln5991">              k0 = smp[n0].sm_leadlen;</a>
<a name="ln5992">              if (k0 &gt; 1) {</a>
<a name="ln5993">                if (word[i + k] != ws[1])</a>
<a name="ln5994">                  continue;</a>
<a name="ln5995">                if (k0 &gt; 2) {</a>
<a name="ln5996">                  pf = word + i + k + 1;</a>
<a name="ln5997">                  for (j = 2; j &lt; k0; ++j)</a>
<a name="ln5998">                    if (*pf++ != ws[j])</a>
<a name="ln5999">                      break;</a>
<a name="ln6000">                  if (j &lt; k0)</a>
<a name="ln6001">                    continue;</a>
<a name="ln6002">                }</a>
<a name="ln6003">              }</a>
<a name="ln6004">              k0 += k - 1;</a>
<a name="ln6005"> </a>
<a name="ln6006">              if ((pf = smp[n0].sm_oneof_w) != NULL) {</a>
<a name="ln6007">                // Check for match with one of the chars in</a>
<a name="ln6008">                // &quot;sm_oneof&quot;.</a>
<a name="ln6009">                while (*pf != NUL &amp;&amp; *pf != word[i + k0])</a>
<a name="ln6010">                  ++pf;</a>
<a name="ln6011">                if (*pf == NUL)</a>
<a name="ln6012">                  continue;</a>
<a name="ln6013">                ++k0;</a>
<a name="ln6014">              }</a>
<a name="ln6015"> </a>
<a name="ln6016">              p0 = 5;</a>
<a name="ln6017">              s = smp[n0].sm_rules;</a>
<a name="ln6018">              while (*s == '-') {</a>
<a name="ln6019">                // &quot;k0&quot; gets NOT reduced because</a>
<a name="ln6020">                // &quot;if (k0 == k)&quot;</a>
<a name="ln6021">                s++;</a>
<a name="ln6022">              }</a>
<a name="ln6023">              if (*s == '&lt;')</a>
<a name="ln6024">                s++;</a>
<a name="ln6025">              if (ascii_isdigit(*s)) {</a>
<a name="ln6026">                p0 = *s - '0';</a>
<a name="ln6027">                s++;</a>
<a name="ln6028">              }</a>
<a name="ln6029"> </a>
<a name="ln6030">              if (*s == NUL</a>
<a name="ln6031">                  // *s == '^' cuts</a>
<a name="ln6032">                  || (*s == '$'</a>
<a name="ln6033">                      &amp;&amp; !spell_iswordp_w(word + i + k0,</a>
<a name="ln6034">                          curwin))) {</a>
<a name="ln6035">                if (k0 == k)</a>
<a name="ln6036">                  // this is just a piece of the string</a>
<a name="ln6037">                  continue;</a>
<a name="ln6038"> </a>
<a name="ln6039">                if (p0 &lt; pri)</a>
<a name="ln6040">                  // priority too low</a>
<a name="ln6041">                  continue;</a>
<a name="ln6042">                // rule fits; stop search</a>
<a name="ln6043">                break;</a>
<a name="ln6044">              }</a>
<a name="ln6045">            }</a>
<a name="ln6046"> </a>
<a name="ln6047">            if (p0 &gt;= pri &amp;&amp; (smp[n0].sm_lead_w[0] &amp; 0xff)</a>
<a name="ln6048">                == (c0 &amp; 0xff))</a>
<a name="ln6049">              continue;</a>
<a name="ln6050">          }</a>
<a name="ln6051"> </a>
<a name="ln6052">          // replace string</a>
<a name="ln6053">          ws = smp[n].sm_to_w;</a>
<a name="ln6054">          s = smp[n].sm_rules;</a>
<a name="ln6055">          p0 = (vim_strchr(s, '&lt;') != NULL) ? 1 : 0;</a>
<a name="ln6056">          if (p0 == 1 &amp;&amp; z == 0) {</a>
<a name="ln6057">            // rule with '&lt;' is used</a>
<a name="ln6058">            if (reslen &gt; 0 &amp;&amp; ws != NULL &amp;&amp; *ws != NUL</a>
<a name="ln6059">                &amp;&amp; (wres[reslen - 1] == c</a>
<a name="ln6060">                    || wres[reslen - 1] == *ws))</a>
<a name="ln6061">              reslen--;</a>
<a name="ln6062">            z0 = 1;</a>
<a name="ln6063">            z = 1;</a>
<a name="ln6064">            k0 = 0;</a>
<a name="ln6065">            if (ws != NULL)</a>
<a name="ln6066">              while (*ws != NUL &amp;&amp; word[i + k0] != NUL) {</a>
<a name="ln6067">                word[i + k0] = *ws;</a>
<a name="ln6068">                k0++;</a>
<a name="ln6069">                ws++;</a>
<a name="ln6070">              }</a>
<a name="ln6071">            if (k &gt; k0)</a>
<a name="ln6072">              memmove(word + i + k0, word + i + k,</a>
<a name="ln6073">                  sizeof(int) * (wordlen - (i + k) + 1));</a>
<a name="ln6074"> </a>
<a name="ln6075">            // new &quot;actual letter&quot;</a>
<a name="ln6076">            c = word[i];</a>
<a name="ln6077">          } else {</a>
<a name="ln6078">            // no '&lt;' rule used</a>
<a name="ln6079">            i += k - 1;</a>
<a name="ln6080">            z = 0;</a>
<a name="ln6081">            if (ws != NULL)</a>
<a name="ln6082">              while (*ws != NUL &amp;&amp; ws[1] != NUL</a>
<a name="ln6083">                     &amp;&amp; reslen &lt; MAXWLEN) {</a>
<a name="ln6084">                if (reslen == 0 || wres[reslen - 1] != *ws)</a>
<a name="ln6085">                  wres[reslen++] = *ws;</a>
<a name="ln6086">                ws++;</a>
<a name="ln6087">              }</a>
<a name="ln6088">            // new &quot;actual letter&quot;</a>
<a name="ln6089">            if (ws == NULL)</a>
<a name="ln6090">              c = NUL;</a>
<a name="ln6091">            else</a>
<a name="ln6092">              c = *ws;</a>
<a name="ln6093">            if (strstr((char *)s, &quot;^^&quot;) != NULL) {</a>
<a name="ln6094">              if (c != NUL)</a>
<a name="ln6095">                wres[reslen++] = c;</a>
<a name="ln6096">              memmove(word, word + i + 1,</a>
<a name="ln6097">                  sizeof(int) * (wordlen - (i + 1) + 1));</a>
<a name="ln6098">              i = 0;</a>
<a name="ln6099">              z0 = 1;</a>
<a name="ln6100">            }</a>
<a name="ln6101">          }</a>
<a name="ln6102">          break;</a>
<a name="ln6103">        }</a>
<a name="ln6104">      }</a>
<a name="ln6105">    } else if (ascii_iswhite(c))   {</a>
<a name="ln6106">      c = ' ';</a>
<a name="ln6107">      k = 1;</a>
<a name="ln6108">    }</a>
<a name="ln6109"> </a>
<a name="ln6110">    if (z0 == 0) {</a>
<a name="ln6111">      if (k &amp;&amp; !p0 &amp;&amp; reslen &lt; MAXWLEN &amp;&amp; c != NUL</a>
<a name="ln6112">          &amp;&amp; (!slang-&gt;sl_collapse || reslen == 0</a>
<a name="ln6113">              || wres[reslen - 1] != c))</a>
<a name="ln6114">        // condense only double letters</a>
<a name="ln6115">        wres[reslen++] = c;</a>
<a name="ln6116"> </a>
<a name="ln6117">      i++;</a>
<a name="ln6118">      z = 0;</a>
<a name="ln6119">      k = 0;</a>
<a name="ln6120">    }</a>
<a name="ln6121">  }</a>
<a name="ln6122"> </a>
<a name="ln6123">  // Convert wide characters in &quot;wres&quot; to a multi-byte string in &quot;res&quot;.</a>
<a name="ln6124">  l = 0;</a>
<a name="ln6125">  for (n = 0; n &lt; reslen; n++) {</a>
<a name="ln6126">    l += utf_char2bytes(wres[n], res + l);</a>
<a name="ln6127">    if (l + MB_MAXBYTES &gt; MAXWLEN) {</a>
<a name="ln6128">      break;</a>
<a name="ln6129">    }</a>
<a name="ln6130">  }</a>
<a name="ln6131">  res[l] = NUL;</a>
<a name="ln6132">}</a>
<a name="ln6133"> </a>
<a name="ln6134">// Compute a score for two sound-a-like words.</a>
<a name="ln6135">// This permits up to two inserts/deletes/swaps/etc. to keep things fast.</a>
<a name="ln6136">// Instead of a generic loop we write out the code.  That keeps it fast by</a>
<a name="ln6137">// avoiding checks that will not be possible.</a>
<a name="ln6138">static int</a>
<a name="ln6139">soundalike_score (</a>
<a name="ln6140">    char_u *goodstart,         // sound-folded good word</a>
<a name="ln6141">    char_u *badstart          // sound-folded bad word</a>
<a name="ln6142">)</a>
<a name="ln6143">{</a>
<a name="ln6144">  char_u      *goodsound = goodstart;</a>
<a name="ln6145">  char_u      *badsound = badstart;</a>
<a name="ln6146">  int goodlen;</a>
<a name="ln6147">  int badlen;</a>
<a name="ln6148">  int n;</a>
<a name="ln6149">  char_u      *pl, *ps;</a>
<a name="ln6150">  char_u      *pl2, *ps2;</a>
<a name="ln6151">  int score = 0;</a>
<a name="ln6152"> </a>
<a name="ln6153">  // Adding/inserting &quot;*&quot; at the start (word starts with vowel) shouldn't be</a>
<a name="ln6154">  // counted so much, vowels in the middle of the word aren't counted at all.</a>
<a name="ln6155">  if ((*badsound == '*' || *goodsound == '*') &amp;&amp; *badsound != *goodsound) {</a>
<a name="ln6156">    if ((badsound[0] == NUL &amp;&amp; goodsound[1] == NUL)</a>
<a name="ln6157">        || (goodsound[0] == NUL &amp;&amp; badsound[1] == NUL))</a>
<a name="ln6158">      // changing word with vowel to word without a sound</a>
<a name="ln6159">      return SCORE_DEL;</a>
<a name="ln6160">    if (badsound[0] == NUL || goodsound[0] == NUL)</a>
<a name="ln6161">      // more than two changes</a>
<a name="ln6162">      return SCORE_MAXMAX;</a>
<a name="ln6163"> </a>
<a name="ln6164">    if (badsound[1] == goodsound[1]</a>
<a name="ln6165">        || (badsound[1] != NUL</a>
<a name="ln6166">            &amp;&amp; goodsound[1] != NUL</a>
<a name="ln6167">            &amp;&amp; badsound[2] == goodsound[2])) {</a>
<a name="ln6168">      // handle like a substitute</a>
<a name="ln6169">    } else {</a>
<a name="ln6170">      score = 2 * SCORE_DEL / 3;</a>
<a name="ln6171">      if (*badsound == '*')</a>
<a name="ln6172">        ++badsound;</a>
<a name="ln6173">      else</a>
<a name="ln6174">        ++goodsound;</a>
<a name="ln6175">    }</a>
<a name="ln6176">  }</a>
<a name="ln6177"> </a>
<a name="ln6178">  goodlen = (int)STRLEN(goodsound);</a>
<a name="ln6179">  badlen = (int)STRLEN(badsound);</a>
<a name="ln6180"> </a>
<a name="ln6181">  // Return quickly if the lengths are too different to be fixed by two</a>
<a name="ln6182">  // changes.</a>
<a name="ln6183">  n = goodlen - badlen;</a>
<a name="ln6184">  if (n &lt; -2 || n &gt; 2)</a>
<a name="ln6185">    return SCORE_MAXMAX;</a>
<a name="ln6186"> </a>
<a name="ln6187">  if (n &gt; 0) {</a>
<a name="ln6188">    pl = goodsound;         // goodsound is longest</a>
<a name="ln6189">    ps = badsound;</a>
<a name="ln6190">  } else {</a>
<a name="ln6191">    pl = badsound;          // badsound is longest</a>
<a name="ln6192">    ps = goodsound;</a>
<a name="ln6193">  }</a>
<a name="ln6194"> </a>
<a name="ln6195">  // Skip over the identical part.</a>
<a name="ln6196">  while (*pl == *ps &amp;&amp; *pl != NUL) {</a>
<a name="ln6197">    ++pl;</a>
<a name="ln6198">    ++ps;</a>
<a name="ln6199">  }</a>
<a name="ln6200"> </a>
<a name="ln6201">  switch (n) {</a>
<a name="ln6202">  case -2:</a>
<a name="ln6203">  case 2:</a>
<a name="ln6204">    // Must delete two characters from &quot;pl&quot;.</a>
<a name="ln6205">    ++pl;               // first delete</a>
<a name="ln6206">    while (*pl == *ps) {</a>
<a name="ln6207">      ++pl;</a>
<a name="ln6208">      ++ps;</a>
<a name="ln6209">    }</a>
<a name="ln6210">    // strings must be equal after second delete</a>
<a name="ln6211">    if (STRCMP(pl + 1, ps) == 0)</a>
<a name="ln6212">      return score + SCORE_DEL * 2;</a>
<a name="ln6213"> </a>
<a name="ln6214">    // Failed to compare.</a>
<a name="ln6215">    break;</a>
<a name="ln6216"> </a>
<a name="ln6217">  case -1:</a>
<a name="ln6218">  case 1:</a>
<a name="ln6219">    // Minimal one delete from &quot;pl&quot; required.</a>
<a name="ln6220"> </a>
<a name="ln6221">    // 1: delete</a>
<a name="ln6222">    pl2 = pl + 1;</a>
<a name="ln6223">    ps2 = ps;</a>
<a name="ln6224">    while (*pl2 == *ps2) {</a>
<a name="ln6225">      if (*pl2 == NUL)                  // reached the end</a>
<a name="ln6226">        return score + SCORE_DEL;</a>
<a name="ln6227">      ++pl2;</a>
<a name="ln6228">      ++ps2;</a>
<a name="ln6229">    }</a>
<a name="ln6230"> </a>
<a name="ln6231">    // 2: delete then swap, then rest must be equal</a>
<a name="ln6232">    if (pl2[0] == ps2[1] &amp;&amp; pl2[1] == ps2[0]</a>
<a name="ln6233">        &amp;&amp; STRCMP(pl2 + 2, ps2 + 2) == 0)</a>
<a name="ln6234">      return score + SCORE_DEL + SCORE_SWAP;</a>
<a name="ln6235"> </a>
<a name="ln6236">    // 3: delete then substitute, then the rest must be equal</a>
<a name="ln6237">    if (STRCMP(pl2 + 1, ps2 + 1) == 0)</a>
<a name="ln6238">      return score + SCORE_DEL + SCORE_SUBST;</a>
<a name="ln6239"> </a>
<a name="ln6240">    // 4: first swap then delete</a>
<a name="ln6241">    if (pl[0] == ps[1] &amp;&amp; pl[1] == ps[0]) {</a>
<a name="ln6242">      pl2 = pl + 2;                 // swap, skip two chars</a>
<a name="ln6243">      ps2 = ps + 2;</a>
<a name="ln6244">      while (*pl2 == *ps2) {</a>
<a name="ln6245">        ++pl2;</a>
<a name="ln6246">        ++ps2;</a>
<a name="ln6247">      }</a>
<a name="ln6248">      // delete a char and then strings must be equal</a>
<a name="ln6249">      if (STRCMP(pl2 + 1, ps2) == 0)</a>
<a name="ln6250">        return score + SCORE_SWAP + SCORE_DEL;</a>
<a name="ln6251">    }</a>
<a name="ln6252"> </a>
<a name="ln6253">    // 5: first substitute then delete</a>
<a name="ln6254">    pl2 = pl + 1;                   // substitute, skip one char</a>
<a name="ln6255">    ps2 = ps + 1;</a>
<a name="ln6256">    while (*pl2 == *ps2) {</a>
<a name="ln6257">      ++pl2;</a>
<a name="ln6258">      ++ps2;</a>
<a name="ln6259">    }</a>
<a name="ln6260">    // delete a char and then strings must be equal</a>
<a name="ln6261">    if (STRCMP(pl2 + 1, ps2) == 0)</a>
<a name="ln6262">      return score + SCORE_SUBST + SCORE_DEL;</a>
<a name="ln6263"> </a>
<a name="ln6264">    // Failed to compare.</a>
<a name="ln6265">    break;</a>
<a name="ln6266"> </a>
<a name="ln6267">  case 0:</a>
<a name="ln6268">    // Lengths are equal, thus changes must result in same length: An</a>
<a name="ln6269">    // insert is only possible in combination with a delete.</a>
<a name="ln6270">    // 1: check if for identical strings</a>
<a name="ln6271">    if (*pl == NUL)</a>
<a name="ln6272">      return score;</a>
<a name="ln6273"> </a>
<a name="ln6274">    // 2: swap</a>
<a name="ln6275">    if (pl[0] == ps[1] &amp;&amp; pl[1] == ps[0]) {</a>
<a name="ln6276">      pl2 = pl + 2;                 // swap, skip two chars</a>
<a name="ln6277">      ps2 = ps + 2;</a>
<a name="ln6278">      while (*pl2 == *ps2) {</a>
<a name="ln6279">        if (*pl2 == NUL)                // reached the end</a>
<a name="ln6280">          return score + SCORE_SWAP;</a>
<a name="ln6281">        ++pl2;</a>
<a name="ln6282">        ++ps2;</a>
<a name="ln6283">      }</a>
<a name="ln6284">      // 3: swap and swap again</a>
<a name="ln6285">      if (pl2[0] == ps2[1] &amp;&amp; pl2[1] == ps2[0]</a>
<a name="ln6286">          &amp;&amp; STRCMP(pl2 + 2, ps2 + 2) == 0)</a>
<a name="ln6287">        return score + SCORE_SWAP + SCORE_SWAP;</a>
<a name="ln6288"> </a>
<a name="ln6289">      // 4: swap and substitute</a>
<a name="ln6290">      if (STRCMP(pl2 + 1, ps2 + 1) == 0)</a>
<a name="ln6291">        return score + SCORE_SWAP + SCORE_SUBST;</a>
<a name="ln6292">    }</a>
<a name="ln6293"> </a>
<a name="ln6294">    // 5: substitute</a>
<a name="ln6295">    pl2 = pl + 1;</a>
<a name="ln6296">    ps2 = ps + 1;</a>
<a name="ln6297">    while (*pl2 == *ps2) {</a>
<a name="ln6298">      if (*pl2 == NUL)                  // reached the end</a>
<a name="ln6299">        return score + SCORE_SUBST;</a>
<a name="ln6300">      ++pl2;</a>
<a name="ln6301">      ++ps2;</a>
<a name="ln6302">    }</a>
<a name="ln6303"> </a>
<a name="ln6304">    // 6: substitute and swap</a>
<a name="ln6305">    if (pl2[0] == ps2[1] &amp;&amp; pl2[1] == ps2[0]</a>
<a name="ln6306">        &amp;&amp; STRCMP(pl2 + 2, ps2 + 2) == 0)</a>
<a name="ln6307">      return score + SCORE_SUBST + SCORE_SWAP;</a>
<a name="ln6308"> </a>
<a name="ln6309">    // 7: substitute and substitute</a>
<a name="ln6310">    if (STRCMP(pl2 + 1, ps2 + 1) == 0)</a>
<a name="ln6311">      return score + SCORE_SUBST + SCORE_SUBST;</a>
<a name="ln6312"> </a>
<a name="ln6313">    // 8: insert then delete</a>
<a name="ln6314">    pl2 = pl;</a>
<a name="ln6315">    ps2 = ps + 1;</a>
<a name="ln6316">    while (*pl2 == *ps2) {</a>
<a name="ln6317">      ++pl2;</a>
<a name="ln6318">      ++ps2;</a>
<a name="ln6319">    }</a>
<a name="ln6320">    if (STRCMP(pl2 + 1, ps2) == 0)</a>
<a name="ln6321">      return score + SCORE_INS + SCORE_DEL;</a>
<a name="ln6322"> </a>
<a name="ln6323">    // 9: delete then insert</a>
<a name="ln6324">    pl2 = pl + 1;</a>
<a name="ln6325">    ps2 = ps;</a>
<a name="ln6326">    while (*pl2 == *ps2) {</a>
<a name="ln6327">      ++pl2;</a>
<a name="ln6328">      ++ps2;</a>
<a name="ln6329">    }</a>
<a name="ln6330">    if (STRCMP(pl2, ps2 + 1) == 0)</a>
<a name="ln6331">      return score + SCORE_INS + SCORE_DEL;</a>
<a name="ln6332"> </a>
<a name="ln6333">    // Failed to compare.</a>
<a name="ln6334">    break;</a>
<a name="ln6335">  }</a>
<a name="ln6336"> </a>
<a name="ln6337">  return SCORE_MAXMAX;</a>
<a name="ln6338">}</a>
<a name="ln6339"> </a>
<a name="ln6340">// Compute the &quot;edit distance&quot; to turn &quot;badword&quot; into &quot;goodword&quot;.  The less</a>
<a name="ln6341">// deletes/inserts/substitutes/swaps are required the lower the score.</a>
<a name="ln6342">//</a>
<a name="ln6343">// The algorithm is described by Du and Chang, 1992.</a>
<a name="ln6344">// The implementation of the algorithm comes from Aspell editdist.cpp,</a>
<a name="ln6345">// edit_distance().  It has been converted from C++ to C and modified to</a>
<a name="ln6346">// support multi-byte characters.</a>
<a name="ln6347">static int spell_edit_score(slang_T *slang, char_u *badword, char_u *goodword)</a>
<a name="ln6348">{</a>
<a name="ln6349">  int *cnt;</a>
<a name="ln6350">  int j, i;</a>
<a name="ln6351">  int t;</a>
<a name="ln6352">  int bc, gc;</a>
<a name="ln6353">  int pbc, pgc;</a>
<a name="ln6354">  int wbadword[MAXWLEN];</a>
<a name="ln6355">  int wgoodword[MAXWLEN];</a>
<a name="ln6356"> </a>
<a name="ln6357">  // Lengths with NUL.</a>
<a name="ln6358">  int badlen;</a>
<a name="ln6359">  int goodlen;</a>
<a name="ln6360">  {</a>
<a name="ln6361">    // Get the characters from the multi-byte strings and put them in an</a>
<a name="ln6362">    // int array for easy access.</a>
<a name="ln6363">    badlen = 0;</a>
<a name="ln6364">    for (const char_u *p = badword; *p != NUL; ) {</a>
<a name="ln6365">      wbadword[badlen++] = mb_cptr2char_adv(&amp;p);</a>
<a name="ln6366">    }</a>
<a name="ln6367">    wbadword[badlen++] = 0;</a>
<a name="ln6368">    goodlen = 0;</a>
<a name="ln6369">    for (const char_u *p = goodword; *p != NUL; ) {</a>
<a name="ln6370">      wgoodword[goodlen++] = mb_cptr2char_adv(&amp;p);</a>
<a name="ln6371">    }</a>
<a name="ln6372">    wgoodword[goodlen++] = 0;</a>
<a name="ln6373">  }</a>
<a name="ln6374"> </a>
<a name="ln6375">  // We use &quot;cnt&quot; as an array: CNT(badword_idx, goodword_idx).</a>
<a name="ln6376">#define CNT(a, b)   cnt[(a) + (b) * (badlen + 1)]</a>
<a name="ln6377">  cnt = xmalloc(sizeof(int) * (badlen + 1) * (goodlen + 1));</a>
<a name="ln6378"> </a>
<a name="ln6379">  CNT(0, 0) = 0;</a>
<a name="ln6380">  for (j = 1; j &lt;= goodlen; ++j)</a>
<a name="ln6381">    CNT(0, j) = CNT(0, j - 1) + SCORE_INS;</a>
<a name="ln6382"> </a>
<a name="ln6383">  for (i = 1; i &lt;= badlen; ++i) {</a>
<a name="ln6384">    CNT(i, 0) = CNT(i - 1, 0) + SCORE_DEL;</a>
<a name="ln6385">    for (j = 1; j &lt;= goodlen; j++) {</a>
<a name="ln6386">      bc = wbadword[i - 1];</a>
<a name="ln6387">      gc = wgoodword[j - 1];</a>
<a name="ln6388">      if (bc == gc) {</a>
<a name="ln6389">        CNT(i, j) = CNT(i - 1, j - 1);</a>
<a name="ln6390">      } else {</a>
<a name="ln6391">        // Use a better score when there is only a case difference.</a>
<a name="ln6392">        if (SPELL_TOFOLD(bc) == SPELL_TOFOLD(gc))</a>
<a name="ln6393">          CNT(i, j) = SCORE_ICASE + CNT(i - 1, j - 1);</a>
<a name="ln6394">        else {</a>
<a name="ln6395">          // For a similar character use SCORE_SIMILAR.</a>
<a name="ln6396">          if (slang != NULL</a>
<a name="ln6397">              &amp;&amp; slang-&gt;sl_has_map</a>
<a name="ln6398">              &amp;&amp; similar_chars(slang, gc, bc))</a>
<a name="ln6399">            CNT(i, j) = SCORE_SIMILAR + CNT(i - 1, j - 1);</a>
<a name="ln6400">          else</a>
<a name="ln6401">            CNT(i, j) = SCORE_SUBST + CNT(i - 1, j - 1);</a>
<a name="ln6402">        }</a>
<a name="ln6403"> </a>
<a name="ln6404">        if (i &gt; 1 &amp;&amp; j &gt; 1) {</a>
<a name="ln6405">          pbc = wbadword[i - 2];</a>
<a name="ln6406">          pgc = wgoodword[j - 2];</a>
<a name="ln6407">          if (bc == pgc &amp;&amp; pbc == gc) {</a>
<a name="ln6408">            t = SCORE_SWAP + CNT(i - 2, j - 2);</a>
<a name="ln6409">            if (t &lt; CNT(i, j))</a>
<a name="ln6410">              CNT(i, j) = t;</a>
<a name="ln6411">          }</a>
<a name="ln6412">        }</a>
<a name="ln6413">        t = SCORE_DEL + CNT(i - 1, j);</a>
<a name="ln6414">        if (t &lt; CNT(i, j))</a>
<a name="ln6415">          CNT(i, j) = t;</a>
<a name="ln6416">        t = SCORE_INS + CNT(i, j - 1);</a>
<a name="ln6417">        if (t &lt; CNT(i, j))</a>
<a name="ln6418">          CNT(i, j) = t;</a>
<a name="ln6419">      }</a>
<a name="ln6420">    }</a>
<a name="ln6421">  }</a>
<a name="ln6422"> </a>
<a name="ln6423">  i = CNT(badlen - 1, goodlen - 1);</a>
<a name="ln6424">  xfree(cnt);</a>
<a name="ln6425">  return i;</a>
<a name="ln6426">}</a>
<a name="ln6427"> </a>
<a name="ln6428">// Like spell_edit_score(), but with a limit on the score to make it faster.</a>
<a name="ln6429">// May return SCORE_MAXMAX when the score is higher than &quot;limit&quot;.</a>
<a name="ln6430">//</a>
<a name="ln6431">// This uses a stack for the edits still to be tried.</a>
<a name="ln6432">// The idea comes from Aspell leditdist.cpp.  Rewritten in C and added support</a>
<a name="ln6433">// for multi-byte characters.</a>
<a name="ln6434">static int spell_edit_score_limit(slang_T *slang, char_u *badword, char_u *goodword, int limit)</a>
<a name="ln6435">{</a>
<a name="ln6436">  return spell_edit_score_limit_w(slang, badword, goodword, limit);</a>
<a name="ln6437">}</a>
<a name="ln6438"> </a>
<a name="ln6439">// Multi-byte version of spell_edit_score_limit().</a>
<a name="ln6440">// Keep it in sync with the above!</a>
<a name="ln6441">static int spell_edit_score_limit_w(slang_T *slang, char_u *badword, char_u *goodword, int limit)</a>
<a name="ln6442">{</a>
<a name="ln6443">  limitscore_T stack[10];               // allow for over 3 * 2 edits</a>
<a name="ln6444">  int stackidx;</a>
<a name="ln6445">  int bi, gi;</a>
<a name="ln6446">  int bi2, gi2;</a>
<a name="ln6447">  int bc, gc;</a>
<a name="ln6448">  int score;</a>
<a name="ln6449">  int score_off;</a>
<a name="ln6450">  int minscore;</a>
<a name="ln6451">  int round;</a>
<a name="ln6452">  int wbadword[MAXWLEN];</a>
<a name="ln6453">  int wgoodword[MAXWLEN];</a>
<a name="ln6454"> </a>
<a name="ln6455">  // Get the characters from the multi-byte strings and put them in an</a>
<a name="ln6456">  // int array for easy access.</a>
<a name="ln6457">  bi = 0;</a>
<a name="ln6458">  for (const char_u *p = badword; *p != NUL; ) {</a>
<a name="ln6459">    wbadword[bi++] = mb_cptr2char_adv(&amp;p);</a>
<a name="ln6460">  }</a>
<a name="ln6461">  wbadword[bi++] = 0;</a>
<a name="ln6462">  gi = 0;</a>
<a name="ln6463">  for (const char_u *p = goodword; *p != NUL; ) {</a>
<a name="ln6464">    wgoodword[gi++] = mb_cptr2char_adv(&amp;p);</a>
<a name="ln6465">  }</a>
<a name="ln6466">  wgoodword[gi++] = 0;</a>
<a name="ln6467"> </a>
<a name="ln6468">  // The idea is to go from start to end over the words.  So long as</a>
<a name="ln6469">  // characters are equal just continue, this always gives the lowest score.</a>
<a name="ln6470">  // When there is a difference try several alternatives.  Each alternative</a>
<a name="ln6471">  // increases &quot;score&quot; for the edit distance.  Some of the alternatives are</a>
<a name="ln6472">  // pushed unto a stack and tried later, some are tried right away.  At the</a>
<a name="ln6473">  // end of the word the score for one alternative is known.  The lowest</a>
<a name="ln6474">  // possible score is stored in &quot;minscore&quot;.</a>
<a name="ln6475">  stackidx = 0;</a>
<a name="ln6476">  bi = 0;</a>
<a name="ln6477">  gi = 0;</a>
<a name="ln6478">  score = 0;</a>
<a name="ln6479">  minscore = limit + 1;</a>
<a name="ln6480"> </a>
<a name="ln6481">  for (;; ) {</a>
<a name="ln6482">    // Skip over an equal part, score remains the same.</a>
<a name="ln6483">    for (;; ) {</a>
<a name="ln6484">      bc = wbadword[bi];</a>
<a name="ln6485">      gc = wgoodword[gi];</a>
<a name="ln6486"> </a>
<a name="ln6487">      if (bc != gc)             // stop at a char that's different</a>
<a name="ln6488">        break;</a>
<a name="ln6489">      if (bc == NUL) {          // both words end</a>
<a name="ln6490">        if (score &lt; minscore)</a>
<a name="ln6491">          minscore = score;</a>
<a name="ln6492">        goto pop;               // do next alternative</a>
<a name="ln6493">      }</a>
<a name="ln6494">      ++bi;</a>
<a name="ln6495">      ++gi;</a>
<a name="ln6496">    }</a>
<a name="ln6497"> </a>
<a name="ln6498">    if (gc == NUL) {      // goodword ends, delete badword chars</a>
<a name="ln6499">      do {</a>
<a name="ln6500">        if ((score += SCORE_DEL) &gt;= minscore)</a>
<a name="ln6501">          goto pop;                 // do next alternative</a>
<a name="ln6502">      } while (wbadword[++bi] != NUL);</a>
<a name="ln6503">      minscore = score;</a>
<a name="ln6504">    } else if (bc == NUL)   { // badword ends, insert badword chars</a>
<a name="ln6505">      do {</a>
<a name="ln6506">        if ((score += SCORE_INS) &gt;= minscore)</a>
<a name="ln6507">          goto pop;                 // do next alternative</a>
<a name="ln6508">      } while (wgoodword[++gi] != NUL);</a>
<a name="ln6509">      minscore = score;</a>
<a name="ln6510">    } else {                  // both words continue</a>
<a name="ln6511">      // If not close to the limit, perform a change.  Only try changes</a>
<a name="ln6512">      // that may lead to a lower score than &quot;minscore&quot;.</a>
<a name="ln6513">      // round 0: try deleting a char from badword</a>
<a name="ln6514">      // round 1: try inserting a char in badword</a>
<a name="ln6515">      for (round = 0; round &lt;= 1; ++round) {</a>
<a name="ln6516">        score_off = score + (round == 0 ? SCORE_DEL : SCORE_INS);</a>
<a name="ln6517">        if (score_off &lt; minscore) {</a>
<a name="ln6518">          if (score_off + SCORE_EDIT_MIN &gt;= minscore) {</a>
<a name="ln6519">            // Near the limit, rest of the words must match.  We</a>
<a name="ln6520">            // can check that right now, no need to push an item</a>
<a name="ln6521">            // onto the stack.</a>
<a name="ln6522">            bi2 = bi + 1 - round;</a>
<a name="ln6523">            gi2 = gi + round;</a>
<a name="ln6524">            while (wgoodword[gi2] == wbadword[bi2]) {</a>
<a name="ln6525">              if (wgoodword[gi2] == NUL) {</a>
<a name="ln6526">                minscore = score_off;</a>
<a name="ln6527">                break;</a>
<a name="ln6528">              }</a>
<a name="ln6529">              ++bi2;</a>
<a name="ln6530">              ++gi2;</a>
<a name="ln6531">            }</a>
<a name="ln6532">          } else {</a>
<a name="ln6533">            // try deleting a character from badword later</a>
<a name="ln6534">            stack[stackidx].badi = bi + 1 - round;</a>
<a name="ln6535">            stack[stackidx].goodi = gi + round;</a>
<a name="ln6536">            stack[stackidx].score = score_off;</a>
<a name="ln6537">            ++stackidx;</a>
<a name="ln6538">          }</a>
<a name="ln6539">        }</a>
<a name="ln6540">      }</a>
<a name="ln6541"> </a>
<a name="ln6542">      if (score + SCORE_SWAP &lt; minscore) {</a>
<a name="ln6543">        // If swapping two characters makes a match then the</a>
<a name="ln6544">        // substitution is more expensive, thus there is no need to</a>
<a name="ln6545">        // try both.</a>
<a name="ln6546">        if (gc == wbadword[bi + 1] &amp;&amp; bc == wgoodword[gi + 1]) {</a>
<a name="ln6547">          // Swap two characters, that is: skip them.</a>
<a name="ln6548">          gi += 2;</a>
<a name="ln6549">          bi += 2;</a>
<a name="ln6550">          score += SCORE_SWAP;</a>
<a name="ln6551">          continue;</a>
<a name="ln6552">        }</a>
<a name="ln6553">      }</a>
<a name="ln6554"> </a>
<a name="ln6555">      // Substitute one character for another which is the same</a>
<a name="ln6556">      // thing as deleting a character from both goodword and badword.</a>
<a name="ln6557">      // Use a better score when there is only a case difference.</a>
<a name="ln6558">      if (SPELL_TOFOLD(bc) == SPELL_TOFOLD(gc))</a>
<a name="ln6559">        score += SCORE_ICASE;</a>
<a name="ln6560">      else {</a>
<a name="ln6561">        // For a similar character use SCORE_SIMILAR.</a>
<a name="ln6562">        if (slang != NULL</a>
<a name="ln6563">            &amp;&amp; slang-&gt;sl_has_map</a>
<a name="ln6564">            &amp;&amp; similar_chars(slang, gc, bc))</a>
<a name="ln6565">          score += SCORE_SIMILAR;</a>
<a name="ln6566">        else</a>
<a name="ln6567">          score += SCORE_SUBST;</a>
<a name="ln6568">      }</a>
<a name="ln6569"> </a>
<a name="ln6570">      if (score &lt; minscore) {</a>
<a name="ln6571">        // Do the substitution.</a>
<a name="ln6572">        ++gi;</a>
<a name="ln6573">        ++bi;</a>
<a name="ln6574">        continue;</a>
<a name="ln6575">      }</a>
<a name="ln6576">    }</a>
<a name="ln6577">pop:</a>
<a name="ln6578">    // Get here to try the next alternative, pop it from the stack.</a>
<a name="ln6579">    if (stackidx == 0)                  // stack is empty, finished</a>
<a name="ln6580">      break;</a>
<a name="ln6581"> </a>
<a name="ln6582">    // pop an item from the stack</a>
<a name="ln6583">    --stackidx;</a>
<a name="ln6584">    gi = stack[stackidx].goodi;</a>
<a name="ln6585">    bi = stack[stackidx].badi;</a>
<a name="ln6586">    score = stack[stackidx].score;</a>
<a name="ln6587">  }</a>
<a name="ln6588"> </a>
<a name="ln6589">  // When the score goes over &quot;limit&quot; it may actually be much higher.</a>
<a name="ln6590">  // Return a very large number to avoid going below the limit when giving a</a>
<a name="ln6591">  // bonus.</a>
<a name="ln6592">  if (minscore &gt; limit)</a>
<a name="ln6593">    return SCORE_MAXMAX;</a>
<a name="ln6594">  return minscore;</a>
<a name="ln6595">}</a>
<a name="ln6596"> </a>
<a name="ln6597">// &quot;:spellinfo&quot;</a>
<a name="ln6598">void ex_spellinfo(exarg_T *eap)</a>
<a name="ln6599">{</a>
<a name="ln6600">  if (no_spell_checking(curwin)) {</a>
<a name="ln6601">    return;</a>
<a name="ln6602">  }</a>
<a name="ln6603"> </a>
<a name="ln6604">  msg_start();</a>
<a name="ln6605">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len &amp;&amp; !got_int; lpi++) {</a>
<a name="ln6606">    langp_T *const lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln6607">    msg_puts(&quot;file: &quot;);</a>
<a name="ln6608">    msg_puts((const char *)lp-&gt;lp_slang-&gt;sl_fname);</a>
<a name="ln6609">    msg_putchar('\n');</a>
<a name="ln6610">    const char *const p = (const char *)lp-&gt;lp_slang-&gt;sl_info;</a>
<a name="ln6611">    if (p != NULL) {</a>
<a name="ln6612">      msg_puts(p);</a>
<a name="ln6613">      msg_putchar('\n');</a>
<a name="ln6614">    }</a>
<a name="ln6615">  }</a>
<a name="ln6616">  msg_end();</a>
<a name="ln6617">}</a>
<a name="ln6618"> </a>
<a name="ln6619">#define DUMPFLAG_KEEPCASE   1   // round 2: keep-case tree</a>
<a name="ln6620">#define DUMPFLAG_COUNT      2   // include word count</a>
<a name="ln6621">#define DUMPFLAG_ICASE      4   // ignore case when finding matches</a>
<a name="ln6622">#define DUMPFLAG_ONECAP     8   // pattern starts with capital</a>
<a name="ln6623">#define DUMPFLAG_ALLCAP     16  // pattern is all capitals</a>
<a name="ln6624"> </a>
<a name="ln6625">// &quot;:spelldump&quot;</a>
<a name="ln6626">void ex_spelldump(exarg_T *eap)</a>
<a name="ln6627">{</a>
<a name="ln6628">  char_u  *spl;</a>
<a name="ln6629">  long dummy;</a>
<a name="ln6630"> </a>
<a name="ln6631">  if (no_spell_checking(curwin)) {</a>
<a name="ln6632">    return;</a>
<a name="ln6633">  }</a>
<a name="ln6634">  get_option_value(&quot;spl&quot;, &amp;dummy, &amp;spl, OPT_LOCAL);</a>
<a name="ln6635"> </a>
<a name="ln6636">  // Create a new empty buffer in a new window.</a>
<a name="ln6637">  do_cmdline_cmd(&quot;new&quot;);</a>
<a name="ln6638"> </a>
<a name="ln6639">  // enable spelling locally in the new window</a>
<a name="ln6640">  set_option_value(&quot;spell&quot;, true, &quot;&quot;, OPT_LOCAL);</a>
<a name="ln6641">  set_option_value(&quot;spl&quot;,  dummy, (char *)spl, OPT_LOCAL);</a>
<a name="ln6642">  xfree(spl);</a>
<a name="ln6643"> </a>
<a name="ln6644">  if (!BUFEMPTY()) {</a>
<a name="ln6645">    return;</a>
<a name="ln6646">  }</a>
<a name="ln6647"> </a>
<a name="ln6648">  spell_dump_compl(NULL, 0, NULL, eap-&gt;forceit ? DUMPFLAG_COUNT : 0);</a>
<a name="ln6649"> </a>
<a name="ln6650">  // Delete the empty line that we started with.</a>
<a name="ln6651">  if (curbuf-&gt;b_ml.ml_line_count &gt; 1) {</a>
<a name="ln6652">    ml_delete(curbuf-&gt;b_ml.ml_line_count, false);</a>
<a name="ln6653">  }</a>
<a name="ln6654">  redraw_later(curwin, NOT_VALID);</a>
<a name="ln6655">}</a>
<a name="ln6656"> </a>
<a name="ln6657">// Go through all possible words and:</a>
<a name="ln6658">// 1. When &quot;pat&quot; is NULL: dump a list of all words in the current buffer.</a>
<a name="ln6659">//      &quot;ic&quot; and &quot;dir&quot; are not used.</a>
<a name="ln6660">// 2. When &quot;pat&quot; is not NULL: add matching words to insert mode completion.</a>
<a name="ln6661">void</a>
<a name="ln6662">spell_dump_compl (</a>
<a name="ln6663">    char_u *pat,           // leading part of the word</a>
<a name="ln6664">    int ic,                     // ignore case</a>
<a name="ln6665">    Direction *dir,        // direction for adding matches</a>
<a name="ln6666">    int dumpflags_arg              // DUMPFLAG_*</a>
<a name="ln6667">)</a>
<a name="ln6668">{</a>
<a name="ln6669">  langp_T     *lp;</a>
<a name="ln6670">  slang_T     *slang;</a>
<a name="ln6671">  idx_T arridx[MAXWLEN];</a>
<a name="ln6672">  int curi[MAXWLEN];</a>
<a name="ln6673">  char_u word[MAXWLEN];</a>
<a name="ln6674">  int c;</a>
<a name="ln6675">  char_u      *byts;</a>
<a name="ln6676">  idx_T       *idxs;</a>
<a name="ln6677">  linenr_T lnum = 0;</a>
<a name="ln6678">  int round;</a>
<a name="ln6679">  int depth;</a>
<a name="ln6680">  int n;</a>
<a name="ln6681">  int flags;</a>
<a name="ln6682">  char_u      *region_names = NULL;         // region names being used</a>
<a name="ln6683">  bool do_region = true;                    // dump region names and numbers</a>
<a name="ln6684">  char_u      *p;</a>
<a name="ln6685">  int dumpflags = dumpflags_arg;</a>
<a name="ln6686">  int patlen;</a>
<a name="ln6687"> </a>
<a name="ln6688">  // When ignoring case or when the pattern starts with capital pass this on</a>
<a name="ln6689">  // to dump_word().</a>
<a name="ln6690">  if (pat != NULL) {</a>
<a name="ln6691">    if (ic)</a>
<a name="ln6692">      dumpflags |= DUMPFLAG_ICASE;</a>
<a name="ln6693">    else {</a>
<a name="ln6694">      n = captype(pat, NULL);</a>
<a name="ln6695">      if (n == WF_ONECAP)</a>
<a name="ln6696">        dumpflags |= DUMPFLAG_ONECAP;</a>
<a name="ln6697">      else if (n == WF_ALLCAP</a>
<a name="ln6698">               &amp;&amp; (int)STRLEN(pat) &gt; mb_ptr2len(pat)</a>
<a name="ln6699">               )</a>
<a name="ln6700">        dumpflags |= DUMPFLAG_ALLCAP;</a>
<a name="ln6701">    }</a>
<a name="ln6702">  }</a>
<a name="ln6703"> </a>
<a name="ln6704">  // Find out if we can support regions: All languages must support the same</a>
<a name="ln6705">  // regions or none at all.</a>
<a name="ln6706">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln6707">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln6708">    p = lp-&gt;lp_slang-&gt;sl_regions;</a>
<a name="ln6709">    if (p[0] != 0) {</a>
<a name="ln6710">      if (region_names == NULL)             // first language with regions</a>
<a name="ln6711">        region_names = p;</a>
<a name="ln6712">      else if (STRCMP(region_names, p) != 0) {</a>
<a name="ln6713">        do_region = false;                  // region names are different</a>
<a name="ln6714">        break;</a>
<a name="ln6715">      }</a>
<a name="ln6716">    }</a>
<a name="ln6717">  }</a>
<a name="ln6718"> </a>
<a name="ln6719">  if (do_region &amp;&amp; region_names != NULL) {</a>
<a name="ln6720">    if (pat == NULL) {</a>
<a name="ln6721">      vim_snprintf((char *)IObuff, IOSIZE, &quot;/regions=%s&quot;, region_names);</a>
<a name="ln6722">      ml_append(lnum++, IObuff, (colnr_T)0, false);</a>
<a name="ln6723">    }</a>
<a name="ln6724">  } else</a>
<a name="ln6725">    do_region = false;</a>
<a name="ln6726"> </a>
<a name="ln6727">  // Loop over all files loaded for the entries in 'spelllang'.</a>
<a name="ln6728">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln6729">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln6730">    slang = lp-&gt;lp_slang;</a>
<a name="ln6731">    if (slang-&gt;sl_fbyts == NULL)            // reloading failed</a>
<a name="ln6732">      continue;</a>
<a name="ln6733"> </a>
<a name="ln6734">    if (pat == NULL) {</a>
<a name="ln6735">      vim_snprintf((char *)IObuff, IOSIZE, &quot;# file: %s&quot;, slang-&gt;sl_fname);</a>
<a name="ln6736">      ml_append(lnum++, IObuff, (colnr_T)0, false);</a>
<a name="ln6737">    }</a>
<a name="ln6738"> </a>
<a name="ln6739">    // When matching with a pattern and there are no prefixes only use</a>
<a name="ln6740">    // parts of the tree that match &quot;pat&quot;.</a>
<a name="ln6741">    if (pat != NULL &amp;&amp; slang-&gt;sl_pbyts == NULL)</a>
<a name="ln6742">      patlen = (int)STRLEN(pat);</a>
<a name="ln6743">    else</a>
<a name="ln6744">      patlen = -1;</a>
<a name="ln6745"> </a>
<a name="ln6746">    // round 1: case-folded tree</a>
<a name="ln6747">    // round 2: keep-case tree</a>
<a name="ln6748">    for (round = 1; round &lt;= 2; ++round) {</a>
<a name="ln6749">      if (round == 1) {</a>
<a name="ln6750">        dumpflags &amp;= ~DUMPFLAG_KEEPCASE;</a>
<a name="ln6751">        byts = slang-&gt;sl_fbyts;</a>
<a name="ln6752">        idxs = slang-&gt;sl_fidxs;</a>
<a name="ln6753">      } else {</a>
<a name="ln6754">        dumpflags |= DUMPFLAG_KEEPCASE;</a>
<a name="ln6755">        byts = slang-&gt;sl_kbyts;</a>
<a name="ln6756">        idxs = slang-&gt;sl_kidxs;</a>
<a name="ln6757">      }</a>
<a name="ln6758">      if (byts == NULL)</a>
<a name="ln6759">        continue;                       // array is empty</a>
<a name="ln6760"> </a>
<a name="ln6761">      depth = 0;</a>
<a name="ln6762">      arridx[0] = 0;</a>
<a name="ln6763">      curi[0] = 1;</a>
<a name="ln6764">      while (depth &gt;= 0 &amp;&amp; !got_int</a>
<a name="ln6765">             &amp;&amp; (pat == NULL || !compl_interrupted)) {</a>
<a name="ln6766">        if (curi[depth] &gt; byts[arridx[depth]]) {</a>
<a name="ln6767">          // Done all bytes at this node, go up one level.</a>
<a name="ln6768">          --depth;</a>
<a name="ln6769">          line_breakcheck();</a>
<a name="ln6770">          ins_compl_check_keys(50, false);</a>
<a name="ln6771">        } else {</a>
<a name="ln6772">          // Do one more byte at this node.</a>
<a name="ln6773">          n = arridx[depth] + curi[depth];</a>
<a name="ln6774">          ++curi[depth];</a>
<a name="ln6775">          c = byts[n];</a>
<a name="ln6776">          if (c == 0) {</a>
<a name="ln6777">            // End of word, deal with the word.</a>
<a name="ln6778">            // Don't use keep-case words in the fold-case tree,</a>
<a name="ln6779">            // they will appear in the keep-case tree.</a>
<a name="ln6780">            // Only use the word when the region matches.</a>
<a name="ln6781">            flags = (int)idxs[n];</a>
<a name="ln6782">            if ((round == 2 || (flags &amp; WF_KEEPCAP) == 0)</a>
<a name="ln6783">                &amp;&amp; (flags &amp; WF_NEEDCOMP) == 0</a>
<a name="ln6784">                &amp;&amp; (do_region</a>
<a name="ln6785">                    || (flags &amp; WF_REGION) == 0</a>
<a name="ln6786">                    || (((unsigned)flags &gt;&gt; 16)</a>
<a name="ln6787">                        &amp; lp-&gt;lp_region) != 0)) {</a>
<a name="ln6788">              word[depth] = NUL;</a>
<a name="ln6789">              if (!do_region)</a>
<a name="ln6790">                flags &amp;= ~WF_REGION;</a>
<a name="ln6791"> </a>
<a name="ln6792">              // Dump the basic word if there is no prefix or</a>
<a name="ln6793">              // when it's the first one.</a>
<a name="ln6794">              c = (unsigned)flags &gt;&gt; 24;</a>
<a name="ln6795">              if (c == 0 || curi[depth] == 2) {</a>
<a name="ln6796">                dump_word(slang, word, pat, dir,</a>
<a name="ln6797">                    dumpflags, flags, lnum);</a>
<a name="ln6798">                if (pat == NULL)</a>
<a name="ln6799">                  ++lnum;</a>
<a name="ln6800">              }</a>
<a name="ln6801"> </a>
<a name="ln6802">              // Apply the prefix, if there is one.</a>
<a name="ln6803">              if (c != 0)</a>
<a name="ln6804">                lnum = dump_prefixes(slang, word, pat, dir,</a>
<a name="ln6805">                    dumpflags, flags, lnum);</a>
<a name="ln6806">            }</a>
<a name="ln6807">          } else {</a>
<a name="ln6808">            // Normal char, go one level deeper.</a>
<a name="ln6809">            word[depth++] = c;</a>
<a name="ln6810">            arridx[depth] = idxs[n];</a>
<a name="ln6811">            curi[depth] = 1;</a>
<a name="ln6812"> </a>
<a name="ln6813">            // Check if this characters matches with the pattern.</a>
<a name="ln6814">            // If not skip the whole tree below it.</a>
<a name="ln6815">            // Always ignore case here, dump_word() will check</a>
<a name="ln6816">            // proper case later.  This isn't exactly right when</a>
<a name="ln6817">            // length changes for multi-byte characters with</a>
<a name="ln6818">            // ignore case...</a>
<a name="ln6819">            assert(depth &gt;= 0);</a>
<a name="ln6820">            if (depth &lt;= patlen</a>
<a name="ln6821">                &amp;&amp; mb_strnicmp(word, pat, (size_t)depth) != 0)</a>
<a name="ln6822">              --depth;</a>
<a name="ln6823">          }</a>
<a name="ln6824">        }</a>
<a name="ln6825">      }</a>
<a name="ln6826">    }</a>
<a name="ln6827">  }</a>
<a name="ln6828">}</a>
<a name="ln6829"> </a>
<a name="ln6830">// Dumps one word: apply case modifications and append a line to the buffer.</a>
<a name="ln6831">// When &quot;lnum&quot; is zero add insert mode completion.</a>
<a name="ln6832">static void dump_word(slang_T *slang, char_u *word, char_u *pat,</a>
<a name="ln6833">                      Direction *dir, int dumpflags, int wordflags,</a>
<a name="ln6834">                      linenr_T lnum)</a>
<a name="ln6835">{</a>
<a name="ln6836">  bool keepcap = false;</a>
<a name="ln6837">  char_u      *p;</a>
<a name="ln6838">  char_u      *tw;</a>
<a name="ln6839">  char_u cword[MAXWLEN];</a>
<a name="ln6840">  char_u badword[MAXWLEN + 10];</a>
<a name="ln6841">  int i;</a>
<a name="ln6842">  int flags = wordflags;</a>
<a name="ln6843"> </a>
<a name="ln6844">  if (dumpflags &amp; DUMPFLAG_ONECAP)</a>
<a name="ln6845">    flags |= WF_ONECAP;</a>
<a name="ln6846">  if (dumpflags &amp; DUMPFLAG_ALLCAP)</a>
<a name="ln6847">    flags |= WF_ALLCAP;</a>
<a name="ln6848"> </a>
<a name="ln6849">  if ((dumpflags &amp; DUMPFLAG_KEEPCASE) == 0 &amp;&amp; (flags &amp; WF_CAPMASK) != 0) {</a>
<a name="ln6850">    // Need to fix case according to &quot;flags&quot;.</a>
<a name="ln6851">    make_case_word(word, cword, flags);</a>
<a name="ln6852">    p = cword;</a>
<a name="ln6853">  } else {</a>
<a name="ln6854">    p = word;</a>
<a name="ln6855">    if ((dumpflags &amp; DUMPFLAG_KEEPCASE)</a>
<a name="ln6856">        &amp;&amp; ((captype(word, NULL) &amp; WF_KEEPCAP) == 0</a>
<a name="ln6857">            || (flags &amp; WF_FIXCAP) != 0))</a>
<a name="ln6858">      keepcap = true;</a>
<a name="ln6859">  }</a>
<a name="ln6860">  tw = p;</a>
<a name="ln6861"> </a>
<a name="ln6862">  if (pat == NULL) {</a>
<a name="ln6863">    // Add flags and regions after a slash.</a>
<a name="ln6864">    if ((flags &amp; (WF_BANNED | WF_RARE | WF_REGION)) || keepcap) {</a>
<a name="ln6865">      STRCPY(badword, p);</a>
<a name="ln6866">      STRCAT(badword, &quot;/&quot;);</a>
<a name="ln6867">      if (keepcap) {</a>
<a name="ln6868">        STRCAT(badword, &quot;=&quot;);</a>
<a name="ln6869">      }</a>
<a name="ln6870">      if (flags &amp; WF_BANNED) {</a>
<a name="ln6871">        STRCAT(badword, &quot;!&quot;);</a>
<a name="ln6872">      } else if (flags &amp; WF_RARE) {</a>
<a name="ln6873">        STRCAT(badword, &quot;?&quot;);</a>
<a name="ln6874">      }</a>
<a name="ln6875">      if (flags &amp; WF_REGION) {</a>
<a name="ln6876">        for (i = 0; i &lt; 7; i++) {</a>
<a name="ln6877">          if (flags &amp; (0x10000 &lt;&lt; i)) {</a>
<a name="ln6878">            const size_t badword_len = STRLEN(badword);</a>
<a name="ln6879">            snprintf((char *)badword + badword_len,</a>
<a name="ln6880">                     sizeof(badword) - badword_len,</a>
<a name="ln6881">                     &quot;%d&quot;, i + 1);</a>
<a name="ln6882">          }</a>
<a name="ln6883">        }</a>
<a name="ln6884">      }</a>
<a name="ln6885">      p = badword;</a>
<a name="ln6886">    }</a>
<a name="ln6887"> </a>
<a name="ln6888">    if (dumpflags &amp; DUMPFLAG_COUNT) {</a>
<a name="ln6889">      hashitem_T  *hi;</a>
<a name="ln6890"> </a>
<a name="ln6891">      // Include the word count for &quot;:spelldump!&quot;.</a>
<a name="ln6892">      hi = hash_find(&amp;slang-&gt;sl_wordcount, tw);</a>
<a name="ln6893">      if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln6894">        vim_snprintf((char *)IObuff, IOSIZE, &quot;%s\t%d&quot;,</a>
<a name="ln6895">            tw, HI2WC(hi)-&gt;wc_count);</a>
<a name="ln6896">        p = IObuff;</a>
<a name="ln6897">      }</a>
<a name="ln6898">    }</a>
<a name="ln6899"> </a>
<a name="ln6900">    ml_append(lnum, p, (colnr_T)0, false);</a>
<a name="ln6901">  } else if (((dumpflags &amp; DUMPFLAG_ICASE)</a>
<a name="ln6902">              ? mb_strnicmp(p, pat, STRLEN(pat)) == 0</a>
<a name="ln6903">              : STRNCMP(p, pat, STRLEN(pat)) == 0)</a>
<a name="ln6904">             &amp;&amp; ins_compl_add_infercase(p, (int)STRLEN(p),</a>
<a name="ln6905">                                        p_ic, NULL, *dir, false) == OK) {</a>
<a name="ln6906">    // if dir was BACKWARD then honor it just once</a>
<a name="ln6907">    *dir = FORWARD;</a>
<a name="ln6908">  }</a>
<a name="ln6909">}</a>
<a name="ln6910"> </a>
<a name="ln6911">// For &quot;:spelldump&quot;: Find matching prefixes for &quot;word&quot;.  Prepend each to</a>
<a name="ln6912">// &quot;word&quot; and append a line to the buffer.</a>
<a name="ln6913">// When &quot;lnum&quot; is zero add insert mode completion.</a>
<a name="ln6914">// Return the updated line number.</a>
<a name="ln6915">static linenr_T</a>
<a name="ln6916">dump_prefixes (</a>
<a name="ln6917">    slang_T *slang,</a>
<a name="ln6918">    char_u *word,          // case-folded word</a>
<a name="ln6919">    char_u *pat,</a>
<a name="ln6920">    Direction *dir,</a>
<a name="ln6921">    int dumpflags,</a>
<a name="ln6922">    int flags,                  // flags with prefix ID</a>
<a name="ln6923">    linenr_T startlnum</a>
<a name="ln6924">)</a>
<a name="ln6925">{</a>
<a name="ln6926">  idx_T arridx[MAXWLEN];</a>
<a name="ln6927">  int curi[MAXWLEN];</a>
<a name="ln6928">  char_u prefix[MAXWLEN];</a>
<a name="ln6929">  char_u word_up[MAXWLEN];</a>
<a name="ln6930">  bool has_word_up = false;</a>
<a name="ln6931">  int c;</a>
<a name="ln6932">  char_u      *byts;</a>
<a name="ln6933">  idx_T       *idxs;</a>
<a name="ln6934">  linenr_T lnum = startlnum;</a>
<a name="ln6935">  int depth;</a>
<a name="ln6936">  int n;</a>
<a name="ln6937">  int len;</a>
<a name="ln6938">  int i;</a>
<a name="ln6939"> </a>
<a name="ln6940">  // If the word starts with a lower-case letter make the word with an</a>
<a name="ln6941">  // upper-case letter in word_up[].</a>
<a name="ln6942">  c = PTR2CHAR(word);</a>
<a name="ln6943">  if (SPELL_TOUPPER(c) != c) {</a>
<a name="ln6944">    onecap_copy(word, word_up, true);</a>
<a name="ln6945">    has_word_up = true;</a>
<a name="ln6946">  }</a>
<a name="ln6947"> </a>
<a name="ln6948">  byts = slang-&gt;sl_pbyts;</a>
<a name="ln6949">  idxs = slang-&gt;sl_pidxs;</a>
<a name="ln6950">  if (byts != NULL) {           // array not is empty</a>
<a name="ln6951">    // Loop over all prefixes, building them byte-by-byte in prefix[].</a>
<a name="ln6952">    // When at the end of a prefix check that it supports &quot;flags&quot;.</a>
<a name="ln6953">    depth = 0;</a>
<a name="ln6954">    arridx[0] = 0;</a>
<a name="ln6955">    curi[0] = 1;</a>
<a name="ln6956">    while (depth &gt;= 0 &amp;&amp; !got_int) {</a>
<a name="ln6957">      n = arridx[depth];</a>
<a name="ln6958">      len = byts[n];</a>
<a name="ln6959">      if (curi[depth] &gt; len) {</a>
<a name="ln6960">        // Done all bytes at this node, go up one level.</a>
<a name="ln6961">        --depth;</a>
<a name="ln6962">        line_breakcheck();</a>
<a name="ln6963">      } else {</a>
<a name="ln6964">        // Do one more byte at this node.</a>
<a name="ln6965">        n += curi[depth];</a>
<a name="ln6966">        ++curi[depth];</a>
<a name="ln6967">        c = byts[n];</a>
<a name="ln6968">        if (c == 0) {</a>
<a name="ln6969">          // End of prefix, find out how many IDs there are.</a>
<a name="ln6970">          for (i = 1; i &lt; len; ++i)</a>
<a name="ln6971">            if (byts[n + i] != 0)</a>
<a name="ln6972">              break;</a>
<a name="ln6973">          curi[depth] += i - 1;</a>
<a name="ln6974"> </a>
<a name="ln6975">          c = valid_word_prefix(i, n, flags, word, slang, false);</a>
<a name="ln6976">          if (c != 0) {</a>
<a name="ln6977">            STRLCPY(prefix + depth, word, MAXWLEN - depth);</a>
<a name="ln6978">            dump_word(slang, prefix, pat, dir, dumpflags,</a>
<a name="ln6979">                (c &amp; WF_RAREPFX) ? (flags | WF_RARE)</a>
<a name="ln6980">                : flags, lnum);</a>
<a name="ln6981">            if (lnum != 0)</a>
<a name="ln6982">              ++lnum;</a>
<a name="ln6983">          }</a>
<a name="ln6984"> </a>
<a name="ln6985">          // Check for prefix that matches the word when the</a>
<a name="ln6986">          // first letter is upper-case, but only if the prefix has</a>
<a name="ln6987">          // a condition.</a>
<a name="ln6988">          if (has_word_up) {</a>
<a name="ln6989">            c = valid_word_prefix(i, n, flags, word_up, slang,</a>
<a name="ln6990">                true);</a>
<a name="ln6991">            if (c != 0) {</a>
<a name="ln6992">              STRLCPY(prefix + depth, word_up, MAXWLEN - depth);</a>
<a name="ln6993">              dump_word(slang, prefix, pat, dir, dumpflags,</a>
<a name="ln6994">                  (c &amp; WF_RAREPFX) ? (flags | WF_RARE)</a>
<a name="ln6995">                  : flags, lnum);</a>
<a name="ln6996">              if (lnum != 0)</a>
<a name="ln6997">                ++lnum;</a>
<a name="ln6998">            }</a>
<a name="ln6999">          }</a>
<a name="ln7000">        } else {</a>
<a name="ln7001">          // Normal char, go one level deeper.</a>
<a name="ln7002">          prefix[depth++] = c;</a>
<a name="ln7003">          arridx[depth] = idxs[n];</a>
<a name="ln7004">          curi[depth] = 1;</a>
<a name="ln7005">        }</a>
<a name="ln7006">      }</a>
<a name="ln7007">    }</a>
<a name="ln7008">  }</a>
<a name="ln7009"> </a>
<a name="ln7010">  return lnum;</a>
<a name="ln7011">}</a>
<a name="ln7012"> </a>
<a name="ln7013">// Move &quot;p&quot; to the end of word &quot;start&quot;.</a>
<a name="ln7014">// Uses the spell-checking word characters.</a>
<a name="ln7015">char_u *spell_to_word_end(char_u *start, win_T *win)</a>
<a name="ln7016">{</a>
<a name="ln7017">  char_u  *p = start;</a>
<a name="ln7018"> </a>
<a name="ln7019">  while (*p != NUL &amp;&amp; spell_iswordp(p, win)) {</a>
<a name="ln7020">    MB_PTR_ADV(p);</a>
<a name="ln7021">  }</a>
<a name="ln7022">  return p;</a>
<a name="ln7023">}</a>
<a name="ln7024"> </a>
<a name="ln7025">// For Insert mode completion CTRL-X s:</a>
<a name="ln7026">// Find start of the word in front of column &quot;startcol&quot;.</a>
<a name="ln7027">// We don't check if it is badly spelled, with completion we can only change</a>
<a name="ln7028">// the word in front of the cursor.</a>
<a name="ln7029">// Returns the column number of the word.</a>
<a name="ln7030">int spell_word_start(int startcol)</a>
<a name="ln7031">{</a>
<a name="ln7032">  char_u      *line;</a>
<a name="ln7033">  char_u      *p;</a>
<a name="ln7034">  int col = 0;</a>
<a name="ln7035"> </a>
<a name="ln7036">  if (no_spell_checking(curwin)) {</a>
<a name="ln7037">    return startcol;</a>
<a name="ln7038">  }</a>
<a name="ln7039"> </a>
<a name="ln7040">  // Find a word character before &quot;startcol&quot;.</a>
<a name="ln7041">  line = get_cursor_line_ptr();</a>
<a name="ln7042">  for (p = line + startcol; p &gt; line; ) {</a>
<a name="ln7043">    MB_PTR_BACK(line, p);</a>
<a name="ln7044">    if (spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln7045">      break;</a>
<a name="ln7046">    }</a>
<a name="ln7047">  }</a>
<a name="ln7048"> </a>
<a name="ln7049">  // Go back to start of the word.</a>
<a name="ln7050">  while (p &gt; line) {</a>
<a name="ln7051">    col = (int)(p - line);</a>
<a name="ln7052">    MB_PTR_BACK(line, p);</a>
<a name="ln7053">    if (!spell_iswordp(p, curwin)) {</a>
<a name="ln7054">      break;</a>
<a name="ln7055">    }</a>
<a name="ln7056">    col = 0;</a>
<a name="ln7057">  }</a>
<a name="ln7058"> </a>
<a name="ln7059">  return col;</a>
<a name="ln7060">}</a>
<a name="ln7061"> </a>
<a name="ln7062">// Need to check for 'spellcapcheck' now, the word is removed before</a>
<a name="ln7063">// expand_spelling() is called.  Therefore the ugly global variable.</a>
<a name="ln7064">static bool spell_expand_need_cap;</a>
<a name="ln7065"> </a>
<a name="ln7066">void spell_expand_check_cap(colnr_T col)</a>
<a name="ln7067">{</a>
<a name="ln7068">  spell_expand_need_cap = check_need_cap(curwin-&gt;w_cursor.lnum, col);</a>
<a name="ln7069">}</a>
<a name="ln7070"> </a>
<a name="ln7071">// Get list of spelling suggestions.</a>
<a name="ln7072">// Used for Insert mode completion CTRL-X ?.</a>
<a name="ln7073">// Returns the number of matches.  The matches are in &quot;matchp[]&quot;, array of</a>
<a name="ln7074">// allocated strings.</a>
<a name="ln7075">int expand_spelling(linenr_T lnum, char_u *pat, char_u ***matchp)</a>
<a name="ln7076">{</a>
<a name="ln7077">  garray_T ga;</a>
<a name="ln7078"> </a>
<a name="ln7079">  spell_suggest_list(&amp;ga, pat, 100, spell_expand_need_cap, true);</a>
<a name="ln7080">  *matchp = ga.ga_data;</a>
<a name="ln7081">  return ga.ga_len;</a>
<a name="ln7082">}</a>

</code></pre>
<div class="balloon" rel="449"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array underrun is possible. The value of 'mi.mi_fwordlen - 1' index could reach -1.</p></div>
<div class="balloon" rel="5968"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v781/" target="_blank">V781</a> The value of the 'i' index is checked after it was used. Perhaps there is a mistake in program logic.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
