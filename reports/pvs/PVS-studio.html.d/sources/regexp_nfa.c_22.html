
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>regexp_nfa.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">/*</a>
<a name="ln5"> * NFA regular expression implementation.</a>
<a name="ln6"> *</a>
<a name="ln7"> * This file is included in &quot;regexp.c&quot;.</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;assert.h&gt;</a>
<a name="ln11">#include &lt;inttypes.h&gt;</a>
<a name="ln12">#include &lt;stdbool.h&gt;</a>
<a name="ln13">#include &lt;limits.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln16">#include &quot;nvim/garray.h&quot;</a>
<a name="ln17"> </a>
<a name="ln18">/*</a>
<a name="ln19"> * Logging of NFA engine.</a>
<a name="ln20"> *</a>
<a name="ln21"> * The NFA engine can write four log files:</a>
<a name="ln22"> * - Error log: Contains NFA engine's fatal errors.</a>
<a name="ln23"> * - Dump log: Contains compiled NFA state machine's information.</a>
<a name="ln24"> * - Run log: Contains information of matching procedure.</a>
<a name="ln25"> * - Debug log: Contains detailed information of matching procedure. Can be</a>
<a name="ln26"> *   disabled by undefining NFA_REGEXP_DEBUG_LOG.</a>
<a name="ln27"> * The first one can also be used without debug mode.</a>
<a name="ln28"> * The last three are enabled when compiled as debug mode and individually</a>
<a name="ln29"> * disabled by commenting them out.</a>
<a name="ln30"> * The log files can get quite big!</a>
<a name="ln31"> * Do disable all of this when compiling Vim for debugging, undefine REGEXP_DEBUG in</a>
<a name="ln32"> * regexp.c</a>
<a name="ln33"> */</a>
<a name="ln34">#ifdef REGEXP_DEBUG</a>
<a name="ln35"># define NFA_REGEXP_ERROR_LOG   &quot;nfa_regexp_error.log&quot;</a>
<a name="ln36"># define NFA_REGEXP_DUMP_LOG    &quot;nfa_regexp_dump.log&quot;</a>
<a name="ln37"># define NFA_REGEXP_RUN_LOG     &quot;nfa_regexp_run.log&quot;</a>
<a name="ln38"># define NFA_REGEXP_DEBUG_LOG   &quot;nfa_regexp_debug.log&quot;</a>
<a name="ln39">#endif</a>
<a name="ln40"> </a>
<a name="ln41">/* Added to NFA_ANY - NFA_NUPPER_IC to include a NL. */</a>
<a name="ln42">#define NFA_ADD_NL              31</a>
<a name="ln43"> </a>
<a name="ln44">enum {</a>
<a name="ln45">  NFA_SPLIT = -1024,</a>
<a name="ln46">  NFA_MATCH,</a>
<a name="ln47">  NFA_EMPTY,                        /* matches 0-length */</a>
<a name="ln48"> </a>
<a name="ln49">  NFA_START_COLL,                   /* [abc] start */</a>
<a name="ln50">  NFA_END_COLL,                     /* [abc] end */</a>
<a name="ln51">  NFA_START_NEG_COLL,               /* [^abc] start */</a>
<a name="ln52">  NFA_END_NEG_COLL,                 /* [^abc] end (postfix only) */</a>
<a name="ln53">  NFA_RANGE,                        /* range of the two previous items</a>
<a name="ln54">                                     * (postfix only) */</a>
<a name="ln55">  NFA_RANGE_MIN,                    /* low end of a range  */</a>
<a name="ln56">  NFA_RANGE_MAX,                    /* high end of a range  */</a>
<a name="ln57"> </a>
<a name="ln58">  NFA_CONCAT,                       // concatenate two previous items (postfix</a>
<a name="ln59">                                    // only)</a>
<a name="ln60">  NFA_OR,                           // \| (postfix only)</a>
<a name="ln61">  NFA_STAR,                         // greedy * (postfix only)</a>
<a name="ln62">  NFA_STAR_NONGREEDY,               // non-greedy * (postfix only)</a>
<a name="ln63">  NFA_QUEST,                        // greedy \? (postfix only)</a>
<a name="ln64">  NFA_QUEST_NONGREEDY,              // non-greedy \? (postfix only)</a>
<a name="ln65"> </a>
<a name="ln66">  NFA_BOL,                          /* ^    Begin line */</a>
<a name="ln67">  NFA_EOL,                          /* $    End line */</a>
<a name="ln68">  NFA_BOW,                          /* \&lt;   Begin word */</a>
<a name="ln69">  NFA_EOW,                          /* \&gt;   End word */</a>
<a name="ln70">  NFA_BOF,                          /* \%^  Begin file */</a>
<a name="ln71">  NFA_EOF,                          /* \%$  End file */</a>
<a name="ln72">  NFA_NEWL,</a>
<a name="ln73">  NFA_ZSTART,                       /* Used for \zs */</a>
<a name="ln74">  NFA_ZEND,                         /* Used for \ze */</a>
<a name="ln75">  NFA_NOPEN,                        /* Start of subexpression marked with \%( */</a>
<a name="ln76">  NFA_NCLOSE,                       /* End of subexpr. marked with \%( ... \) */</a>
<a name="ln77">  NFA_START_INVISIBLE,</a>
<a name="ln78">  NFA_START_INVISIBLE_FIRST,</a>
<a name="ln79">  NFA_START_INVISIBLE_NEG,</a>
<a name="ln80">  NFA_START_INVISIBLE_NEG_FIRST,</a>
<a name="ln81">  NFA_START_INVISIBLE_BEFORE,</a>
<a name="ln82">  NFA_START_INVISIBLE_BEFORE_FIRST,</a>
<a name="ln83">  NFA_START_INVISIBLE_BEFORE_NEG,</a>
<a name="ln84">  NFA_START_INVISIBLE_BEFORE_NEG_FIRST,</a>
<a name="ln85">  NFA_START_PATTERN,</a>
<a name="ln86">  NFA_END_INVISIBLE,</a>
<a name="ln87">  NFA_END_INVISIBLE_NEG,</a>
<a name="ln88">  NFA_END_PATTERN,</a>
<a name="ln89">  NFA_COMPOSING,                    /* Next nodes in NFA are part of the</a>
<a name="ln90">                                       composing multibyte char */</a>
<a name="ln91">  NFA_END_COMPOSING,                /* End of a composing char in the NFA */</a>
<a name="ln92">  NFA_ANY_COMPOSING,                // \%C: Any composing characters.</a>
<a name="ln93">  NFA_OPT_CHARS,                    /* \%[abc] */</a>
<a name="ln94"> </a>
<a name="ln95">  /* The following are used only in the postfix form, not in the NFA */</a>
<a name="ln96">  NFA_PREV_ATOM_NO_WIDTH,           /* Used for \@= */</a>
<a name="ln97">  NFA_PREV_ATOM_NO_WIDTH_NEG,       /* Used for \@! */</a>
<a name="ln98">  NFA_PREV_ATOM_JUST_BEFORE,        /* Used for \@&lt;= */</a>
<a name="ln99">  NFA_PREV_ATOM_JUST_BEFORE_NEG,    /* Used for \@&lt;! */</a>
<a name="ln100">  NFA_PREV_ATOM_LIKE_PATTERN,       /* Used for \@&gt; */</a>
<a name="ln101"> </a>
<a name="ln102">  NFA_BACKREF1,                     /* \1 */</a>
<a name="ln103">  NFA_BACKREF2,                     /* \2 */</a>
<a name="ln104">  NFA_BACKREF3,                     /* \3 */</a>
<a name="ln105">  NFA_BACKREF4,                     /* \4 */</a>
<a name="ln106">  NFA_BACKREF5,                     /* \5 */</a>
<a name="ln107">  NFA_BACKREF6,                     /* \6 */</a>
<a name="ln108">  NFA_BACKREF7,                     /* \7 */</a>
<a name="ln109">  NFA_BACKREF8,                     /* \8 */</a>
<a name="ln110">  NFA_BACKREF9,                     /* \9 */</a>
<a name="ln111">  NFA_ZREF1,                        /* \z1 */</a>
<a name="ln112">  NFA_ZREF2,                        /* \z2 */</a>
<a name="ln113">  NFA_ZREF3,                        /* \z3 */</a>
<a name="ln114">  NFA_ZREF4,                        /* \z4 */</a>
<a name="ln115">  NFA_ZREF5,                        /* \z5 */</a>
<a name="ln116">  NFA_ZREF6,                        /* \z6 */</a>
<a name="ln117">  NFA_ZREF7,                        /* \z7 */</a>
<a name="ln118">  NFA_ZREF8,                        /* \z8 */</a>
<a name="ln119">  NFA_ZREF9,                        /* \z9 */</a>
<a name="ln120">  NFA_SKIP,                         /* Skip characters */</a>
<a name="ln121"> </a>
<a name="ln122">  NFA_MOPEN,</a>
<a name="ln123">  NFA_MOPEN1,</a>
<a name="ln124">  NFA_MOPEN2,</a>
<a name="ln125">  NFA_MOPEN3,</a>
<a name="ln126">  NFA_MOPEN4,</a>
<a name="ln127">  NFA_MOPEN5,</a>
<a name="ln128">  NFA_MOPEN6,</a>
<a name="ln129">  NFA_MOPEN7,</a>
<a name="ln130">  NFA_MOPEN8,</a>
<a name="ln131">  NFA_MOPEN9,</a>
<a name="ln132"> </a>
<a name="ln133">  NFA_MCLOSE,</a>
<a name="ln134">  NFA_MCLOSE1,</a>
<a name="ln135">  NFA_MCLOSE2,</a>
<a name="ln136">  NFA_MCLOSE3,</a>
<a name="ln137">  NFA_MCLOSE4,</a>
<a name="ln138">  NFA_MCLOSE5,</a>
<a name="ln139">  NFA_MCLOSE6,</a>
<a name="ln140">  NFA_MCLOSE7,</a>
<a name="ln141">  NFA_MCLOSE8,</a>
<a name="ln142">  NFA_MCLOSE9,</a>
<a name="ln143"> </a>
<a name="ln144">  NFA_ZOPEN,</a>
<a name="ln145">  NFA_ZOPEN1,</a>
<a name="ln146">  NFA_ZOPEN2,</a>
<a name="ln147">  NFA_ZOPEN3,</a>
<a name="ln148">  NFA_ZOPEN4,</a>
<a name="ln149">  NFA_ZOPEN5,</a>
<a name="ln150">  NFA_ZOPEN6,</a>
<a name="ln151">  NFA_ZOPEN7,</a>
<a name="ln152">  NFA_ZOPEN8,</a>
<a name="ln153">  NFA_ZOPEN9,</a>
<a name="ln154"> </a>
<a name="ln155">  NFA_ZCLOSE,</a>
<a name="ln156">  NFA_ZCLOSE1,</a>
<a name="ln157">  NFA_ZCLOSE2,</a>
<a name="ln158">  NFA_ZCLOSE3,</a>
<a name="ln159">  NFA_ZCLOSE4,</a>
<a name="ln160">  NFA_ZCLOSE5,</a>
<a name="ln161">  NFA_ZCLOSE6,</a>
<a name="ln162">  NFA_ZCLOSE7,</a>
<a name="ln163">  NFA_ZCLOSE8,</a>
<a name="ln164">  NFA_ZCLOSE9,</a>
<a name="ln165"> </a>
<a name="ln166">  /* NFA_FIRST_NL */</a>
<a name="ln167">  NFA_ANY,              /*	Match any one character. */</a>
<a name="ln168">  NFA_IDENT,            /*	Match identifier char */</a>
<a name="ln169">  NFA_SIDENT,           /*	Match identifier char but no digit */</a>
<a name="ln170">  NFA_KWORD,            /*	Match keyword char */</a>
<a name="ln171">  NFA_SKWORD,           /*	Match word char but no digit */</a>
<a name="ln172">  NFA_FNAME,            /*	Match file name char */</a>
<a name="ln173">  NFA_SFNAME,           /*	Match file name char but no digit */</a>
<a name="ln174">  NFA_PRINT,            /*	Match printable char */</a>
<a name="ln175">  NFA_SPRINT,           /*	Match printable char but no digit */</a>
<a name="ln176">  NFA_WHITE,            /*	Match whitespace char */</a>
<a name="ln177">  NFA_NWHITE,           /*	Match non-whitespace char */</a>
<a name="ln178">  NFA_DIGIT,            /*	Match digit char */</a>
<a name="ln179">  NFA_NDIGIT,           /*	Match non-digit char */</a>
<a name="ln180">  NFA_HEX,              /*	Match hex char */</a>
<a name="ln181">  NFA_NHEX,             /*	Match non-hex char */</a>
<a name="ln182">  NFA_OCTAL,            /*	Match octal char */</a>
<a name="ln183">  NFA_NOCTAL,           /*	Match non-octal char */</a>
<a name="ln184">  NFA_WORD,             /*	Match word char */</a>
<a name="ln185">  NFA_NWORD,            /*	Match non-word char */</a>
<a name="ln186">  NFA_HEAD,             /*	Match head char */</a>
<a name="ln187">  NFA_NHEAD,            /*	Match non-head char */</a>
<a name="ln188">  NFA_ALPHA,            /*	Match alpha char */</a>
<a name="ln189">  NFA_NALPHA,           /*	Match non-alpha char */</a>
<a name="ln190">  NFA_LOWER,            /*	Match lowercase char */</a>
<a name="ln191">  NFA_NLOWER,           /*	Match non-lowercase char */</a>
<a name="ln192">  NFA_UPPER,            /*	Match uppercase char */</a>
<a name="ln193">  NFA_NUPPER,           /*	Match non-uppercase char */</a>
<a name="ln194">  NFA_LOWER_IC,         /*	Match [a-z] */</a>
<a name="ln195">  NFA_NLOWER_IC,        /*	Match [^a-z] */</a>
<a name="ln196">  NFA_UPPER_IC,         /*	Match [A-Z] */</a>
<a name="ln197">  NFA_NUPPER_IC,        /*	Match [^A-Z] */</a>
<a name="ln198"> </a>
<a name="ln199">  NFA_FIRST_NL = NFA_ANY + NFA_ADD_NL,</a>
<a name="ln200">  NFA_LAST_NL = NFA_NUPPER_IC + NFA_ADD_NL,</a>
<a name="ln201"> </a>
<a name="ln202">  NFA_CURSOR,           /*	Match cursor pos */</a>
<a name="ln203">  NFA_LNUM,             /*	Match line number */</a>
<a name="ln204">  NFA_LNUM_GT,          /*	Match &gt; line number */</a>
<a name="ln205">  NFA_LNUM_LT,          /*	Match &lt; line number */</a>
<a name="ln206">  NFA_COL,              /*	Match cursor column */</a>
<a name="ln207">  NFA_COL_GT,           /*	Match &gt; cursor column */</a>
<a name="ln208">  NFA_COL_LT,           /*	Match &lt; cursor column */</a>
<a name="ln209">  NFA_VCOL,             /*	Match cursor virtual column */</a>
<a name="ln210">  NFA_VCOL_GT,          /*	Match &gt; cursor virtual column */</a>
<a name="ln211">  NFA_VCOL_LT,          /*	Match &lt; cursor virtual column */</a>
<a name="ln212">  NFA_MARK,             /*	Match mark */</a>
<a name="ln213">  NFA_MARK_GT,          /*	Match &gt; mark */</a>
<a name="ln214">  NFA_MARK_LT,          /*	Match &lt; mark */</a>
<a name="ln215">  NFA_VISUAL,           /*	Match Visual area */</a>
<a name="ln216"> </a>
<a name="ln217">  /* Character classes [:alnum:] etc */</a>
<a name="ln218">  NFA_CLASS_ALNUM,</a>
<a name="ln219">  NFA_CLASS_ALPHA,</a>
<a name="ln220">  NFA_CLASS_BLANK,</a>
<a name="ln221">  NFA_CLASS_CNTRL,</a>
<a name="ln222">  NFA_CLASS_DIGIT,</a>
<a name="ln223">  NFA_CLASS_GRAPH,</a>
<a name="ln224">  NFA_CLASS_LOWER,</a>
<a name="ln225">  NFA_CLASS_PRINT,</a>
<a name="ln226">  NFA_CLASS_PUNCT,</a>
<a name="ln227">  NFA_CLASS_SPACE,</a>
<a name="ln228">  NFA_CLASS_UPPER,</a>
<a name="ln229">  NFA_CLASS_XDIGIT,</a>
<a name="ln230">  NFA_CLASS_TAB,</a>
<a name="ln231">  NFA_CLASS_RETURN,</a>
<a name="ln232">  NFA_CLASS_BACKSPACE,</a>
<a name="ln233">  NFA_CLASS_ESCAPE,</a>
<a name="ln234">  NFA_CLASS_IDENT,</a>
<a name="ln235">  NFA_CLASS_KEYWORD,</a>
<a name="ln236">  NFA_CLASS_FNAME,</a>
<a name="ln237">};</a>
<a name="ln238"> </a>
<a name="ln239">/* Keep in sync with classchars. */</a>
<a name="ln240">static int nfa_classcodes[] = {</a>
<a name="ln241">  NFA_ANY, NFA_IDENT, NFA_SIDENT, NFA_KWORD,NFA_SKWORD,</a>
<a name="ln242">  NFA_FNAME, NFA_SFNAME, NFA_PRINT, NFA_SPRINT,</a>
<a name="ln243">  NFA_WHITE, NFA_NWHITE, NFA_DIGIT, NFA_NDIGIT,</a>
<a name="ln244">  NFA_HEX, NFA_NHEX, NFA_OCTAL, NFA_NOCTAL,</a>
<a name="ln245">  NFA_WORD, NFA_NWORD, NFA_HEAD, NFA_NHEAD,</a>
<a name="ln246">  NFA_ALPHA, NFA_NALPHA, NFA_LOWER, NFA_NLOWER,</a>
<a name="ln247">  NFA_UPPER, NFA_NUPPER</a>
<a name="ln248">};</a>
<a name="ln249"> </a>
<a name="ln250">static char_u e_nul_found[] = N_(</a>
<a name="ln251">    &quot;E865: (NFA) Regexp end encountered prematurely&quot;);</a>
<a name="ln252">static char_u e_misplaced[] = N_(&quot;E866: (NFA regexp) Misplaced %c&quot;);</a>
<a name="ln253">static char_u e_ill_char_class[] = N_(</a>
<a name="ln254">    &quot;E877: (NFA regexp) Invalid character class: %&quot; PRId64);</a>
<a name="ln255">static char_u e_value_too_large[] = N_(&quot;E951: \\% value too large&quot;);</a>
<a name="ln256"> </a>
<a name="ln257">/* Since the out pointers in the list are always</a>
<a name="ln258"> * uninitialized, we use the pointers themselves</a>
<a name="ln259"> * as storage for the Ptrlists. */</a>
<a name="ln260">typedef union Ptrlist Ptrlist;</a>
<a name="ln261">union Ptrlist {</a>
<a name="ln262">  Ptrlist     *next;</a>
<a name="ln263">  nfa_state_T *s;</a>
<a name="ln264">};</a>
<a name="ln265"> </a>
<a name="ln266">struct Frag {</a>
<a name="ln267">  nfa_state_T *start;</a>
<a name="ln268">  Ptrlist     *out;</a>
<a name="ln269">};</a>
<a name="ln270">typedef struct Frag Frag_T;</a>
<a name="ln271"> </a>
<a name="ln272">typedef struct {</a>
<a name="ln273">  int in_use;       ///&lt; number of subexpr with useful info</a>
<a name="ln274"> </a>
<a name="ln275">  // When REG_MULTI is true list.multi is used, otherwise list.line.</a>
<a name="ln276">  union {</a>
<a name="ln277">    struct multipos {</a>
<a name="ln278">      linenr_T  start_lnum;</a>
<a name="ln279">      linenr_T  end_lnum;</a>
<a name="ln280">      colnr_T start_col;</a>
<a name="ln281">      colnr_T end_col;</a>
<a name="ln282">    } multi[NSUBEXP];</a>
<a name="ln283">    struct linepos {</a>
<a name="ln284">      char_u      *start;</a>
<a name="ln285">      char_u      *end;</a>
<a name="ln286">    } line[NSUBEXP];</a>
<a name="ln287">  } list;</a>
<a name="ln288">} regsub_T;</a>
<a name="ln289"> </a>
<a name="ln290">typedef struct {</a>
<a name="ln291">  regsub_T norm;      /* \( .. \) matches */</a>
<a name="ln292">  regsub_T synt;      /* \z( .. \) matches */</a>
<a name="ln293">} regsubs_T;</a>
<a name="ln294"> </a>
<a name="ln295">/* nfa_pim_T stores a Postponed Invisible Match. */</a>
<a name="ln296">typedef struct nfa_pim_S nfa_pim_T;</a>
<a name="ln297">struct nfa_pim_S {</a>
<a name="ln298">  int result;                   /* NFA_PIM_*, see below */</a>
<a name="ln299">  nfa_state_T *state;           /* the invisible match start state */</a>
<a name="ln300">  regsubs_T subs;               /* submatch info, only party used */</a>
<a name="ln301">  union {</a>
<a name="ln302">    lpos_T pos;</a>
<a name="ln303">    char_u  *ptr;</a>
<a name="ln304">  } end;                        /* where the match must end */</a>
<a name="ln305">};</a>
<a name="ln306"> </a>
<a name="ln307">/* nfa_thread_T contains execution information of a NFA state */</a>
<a name="ln308">typedef struct {</a>
<a name="ln309">  nfa_state_T *state;</a>
<a name="ln310">  int count;</a>
<a name="ln311">  nfa_pim_T pim;                /* if pim.result != NFA_PIM_UNUSED: postponed</a>
<a name="ln312">                                 * invisible match */</a>
<a name="ln313">  regsubs_T subs;               /* submatch info, only party used */</a>
<a name="ln314">} nfa_thread_T;</a>
<a name="ln315"> </a>
<a name="ln316">// nfa_list_T contains the alternative NFA execution states.</a>
<a name="ln317">typedef struct {</a>
<a name="ln318">  nfa_thread_T    *t;           ///&lt; allocated array of states</a>
<a name="ln319">  int n;                        ///&lt; nr of states currently in &quot;t&quot;</a>
<a name="ln320">  int len;                      ///&lt; max nr of states in &quot;t&quot;</a>
<a name="ln321">  int id;                       ///&lt; ID of the list</a>
<a name="ln322">  int has_pim;                  ///&lt; true when any state has a PIM</a>
<a name="ln323">} nfa_list_T;</a>
<a name="ln324"> </a>
<a name="ln325">// Variables only used in nfa_regcomp() and descendants.</a>
<a name="ln326">static int nfa_re_flags;  ///&lt; re_flags passed to nfa_regcomp().</a>
<a name="ln327">static int *post_start;   ///&lt; holds the postfix form of r.e.</a>
<a name="ln328">static int *post_end;</a>
<a name="ln329">static int *post_ptr;</a>
<a name="ln330"> </a>
<a name="ln331">static int nstate;  ///&lt; Number of states in the NFA. Also used when executing.</a>
<a name="ln332">static int istate;  ///&lt; Index in the state vector, used in alloc_state()</a>
<a name="ln333"> </a>
<a name="ln334">/* If not NULL match must end at this position */</a>
<a name="ln335">static save_se_T *nfa_endp = NULL;</a>
<a name="ln336"> </a>
<a name="ln337">/* 0 for first call to nfa_regmatch(), 1 for recursive call. */</a>
<a name="ln338">static int nfa_ll_index = 0;</a>
<a name="ln339"> </a>
<a name="ln340">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln341"># include &quot;regexp_nfa.c.generated.h&quot;</a>
<a name="ln342">#endif</a>
<a name="ln343"> </a>
<a name="ln344">// Helper functions used when doing re2post() ... regatom() parsing</a>
<a name="ln345">#define EMIT(c) \</a>
<a name="ln346">    do { \</a>
<a name="ln347">      if (post_ptr &gt;= post_end) { \</a>
<a name="ln348">        realloc_post_list(); \</a>
<a name="ln349">      } \</a>
<a name="ln350">      *post_ptr++ = c; \</a>
<a name="ln351">    } while (0)</a>
<a name="ln352"> </a>
<a name="ln353">/*</a>
<a name="ln354"> * Initialize internal variables before NFA compilation.</a>
<a name="ln355"> */</a>
<a name="ln356">static void</a>
<a name="ln357">nfa_regcomp_start (</a>
<a name="ln358">    char_u *expr,</a>
<a name="ln359">    int re_flags                       /* see vim_regcomp() */</a>
<a name="ln360">)</a>
<a name="ln361">{</a>
<a name="ln362">  size_t postfix_size;</a>
<a name="ln363">  size_t nstate_max;</a>
<a name="ln364"> </a>
<a name="ln365">  nstate = 0;</a>
<a name="ln366">  istate = 0;</a>
<a name="ln367">  /* A reasonable estimation for maximum size */</a>
<a name="ln368">  nstate_max = (STRLEN(expr) + 1) * 25;</a>
<a name="ln369"> </a>
<a name="ln370">  /* Some items blow up in size, such as [A-z].  Add more space for that.</a>
<a name="ln371">   * When it is still not enough realloc_post_list() will be used. */</a>
<a name="ln372">  nstate_max += 1000;</a>
<a name="ln373"> </a>
<a name="ln374">  /* Size for postfix representation of expr. */</a>
<a name="ln375">  postfix_size = sizeof(int) * nstate_max;</a>
<a name="ln376"> </a>
<a name="ln377">  post_start = (int *)xmalloc(postfix_size);</a>
<a name="ln378">  post_ptr = post_start;</a>
<a name="ln379">  post_end = post_start + nstate_max;</a>
<a name="ln380">  rex.nfa_has_zend = false;</a>
<a name="ln381">  rex.nfa_has_backref = false;</a>
<a name="ln382"> </a>
<a name="ln383">  /* shared with BT engine */</a>
<a name="ln384">  regcomp_start(expr, re_flags);</a>
<a name="ln385">}</a>
<a name="ln386"> </a>
<a name="ln387">/*</a>
<a name="ln388"> * Figure out if the NFA state list starts with an anchor, must match at start</a>
<a name="ln389"> * of the line.</a>
<a name="ln390"> */</a>
<a name="ln391">static int nfa_get_reganch(nfa_state_T *start, int depth)</a>
<a name="ln392">{</a>
<a name="ln393">  nfa_state_T *p = start;</a>
<a name="ln394"> </a>
<a name="ln395">  if (depth &gt; 4)</a>
<a name="ln396">    return 0;</a>
<a name="ln397"> </a>
<a name="ln398">  while (p != NULL) {</a>
<a name="ln399">    switch (p-&gt;c) {</a>
<a name="ln400">    case NFA_BOL:</a>
<a name="ln401">    case NFA_BOF:</a>
<a name="ln402">      return 1;           /* yes! */</a>
<a name="ln403"> </a>
<a name="ln404">    case NFA_ZSTART:</a>
<a name="ln405">    case NFA_ZEND:</a>
<a name="ln406">    case NFA_CURSOR:</a>
<a name="ln407">    case NFA_VISUAL:</a>
<a name="ln408"> </a>
<a name="ln409">    case NFA_MOPEN:</a>
<a name="ln410">    case NFA_MOPEN1:</a>
<a name="ln411">    case NFA_MOPEN2:</a>
<a name="ln412">    case NFA_MOPEN3:</a>
<a name="ln413">    case NFA_MOPEN4:</a>
<a name="ln414">    case NFA_MOPEN5:</a>
<a name="ln415">    case NFA_MOPEN6:</a>
<a name="ln416">    case NFA_MOPEN7:</a>
<a name="ln417">    case NFA_MOPEN8:</a>
<a name="ln418">    case NFA_MOPEN9:</a>
<a name="ln419">    case NFA_NOPEN:</a>
<a name="ln420">    case NFA_ZOPEN:</a>
<a name="ln421">    case NFA_ZOPEN1:</a>
<a name="ln422">    case NFA_ZOPEN2:</a>
<a name="ln423">    case NFA_ZOPEN3:</a>
<a name="ln424">    case NFA_ZOPEN4:</a>
<a name="ln425">    case NFA_ZOPEN5:</a>
<a name="ln426">    case NFA_ZOPEN6:</a>
<a name="ln427">    case NFA_ZOPEN7:</a>
<a name="ln428">    case NFA_ZOPEN8:</a>
<a name="ln429">    case NFA_ZOPEN9:</a>
<a name="ln430">      p = p-&gt;out;</a>
<a name="ln431">      break;</a>
<a name="ln432"> </a>
<a name="ln433">    case NFA_SPLIT:</a>
<a name="ln434">      return nfa_get_reganch(p-&gt;out, depth + 1)</a>
<a name="ln435">             &amp;&amp; nfa_get_reganch(p-&gt;out1, depth + 1);</a>
<a name="ln436"> </a>
<a name="ln437">    default:</a>
<a name="ln438">      return 0;           /* noooo */</a>
<a name="ln439">    }</a>
<a name="ln440">  }</a>
<a name="ln441">  return 0;</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444">/*</a>
<a name="ln445"> * Figure out if the NFA state list starts with a character which must match</a>
<a name="ln446"> * at start of the match.</a>
<a name="ln447"> */</a>
<a name="ln448">static int nfa_get_regstart(nfa_state_T *start, int depth)</a>
<a name="ln449">{</a>
<a name="ln450">  nfa_state_T *p = start;</a>
<a name="ln451"> </a>
<a name="ln452">  if (depth &gt; 4)</a>
<a name="ln453">    return 0;</a>
<a name="ln454"> </a>
<a name="ln455">  while (p != NULL) {</a>
<a name="ln456">    switch (p-&gt;c) {</a>
<a name="ln457">    /* all kinds of zero-width matches */</a>
<a name="ln458">    case NFA_BOL:</a>
<a name="ln459">    case NFA_BOF:</a>
<a name="ln460">    case NFA_BOW:</a>
<a name="ln461">    case NFA_EOW:</a>
<a name="ln462">    case NFA_ZSTART:</a>
<a name="ln463">    case NFA_ZEND:</a>
<a name="ln464">    case NFA_CURSOR:</a>
<a name="ln465">    case NFA_VISUAL:</a>
<a name="ln466">    case NFA_LNUM:</a>
<a name="ln467">    case NFA_LNUM_GT:</a>
<a name="ln468">    case NFA_LNUM_LT:</a>
<a name="ln469">    case NFA_COL:</a>
<a name="ln470">    case NFA_COL_GT:</a>
<a name="ln471">    case NFA_COL_LT:</a>
<a name="ln472">    case NFA_VCOL:</a>
<a name="ln473">    case NFA_VCOL_GT:</a>
<a name="ln474">    case NFA_VCOL_LT:</a>
<a name="ln475">    case NFA_MARK:</a>
<a name="ln476">    case NFA_MARK_GT:</a>
<a name="ln477">    case NFA_MARK_LT:</a>
<a name="ln478"> </a>
<a name="ln479">    case NFA_MOPEN:</a>
<a name="ln480">    case NFA_MOPEN1:</a>
<a name="ln481">    case NFA_MOPEN2:</a>
<a name="ln482">    case NFA_MOPEN3:</a>
<a name="ln483">    case NFA_MOPEN4:</a>
<a name="ln484">    case NFA_MOPEN5:</a>
<a name="ln485">    case NFA_MOPEN6:</a>
<a name="ln486">    case NFA_MOPEN7:</a>
<a name="ln487">    case NFA_MOPEN8:</a>
<a name="ln488">    case NFA_MOPEN9:</a>
<a name="ln489">    case NFA_NOPEN:</a>
<a name="ln490">    case NFA_ZOPEN:</a>
<a name="ln491">    case NFA_ZOPEN1:</a>
<a name="ln492">    case NFA_ZOPEN2:</a>
<a name="ln493">    case NFA_ZOPEN3:</a>
<a name="ln494">    case NFA_ZOPEN4:</a>
<a name="ln495">    case NFA_ZOPEN5:</a>
<a name="ln496">    case NFA_ZOPEN6:</a>
<a name="ln497">    case NFA_ZOPEN7:</a>
<a name="ln498">    case NFA_ZOPEN8:</a>
<a name="ln499">    case NFA_ZOPEN9:</a>
<a name="ln500">      p = p-&gt;out;</a>
<a name="ln501">      break;</a>
<a name="ln502"> </a>
<a name="ln503">    case NFA_SPLIT:</a>
<a name="ln504">    {</a>
<a name="ln505">      int c1 = nfa_get_regstart(p-&gt;out, depth + 1);</a>
<a name="ln506">      int c2 = nfa_get_regstart(p-&gt;out1, depth + 1);</a>
<a name="ln507"> </a>
<a name="ln508">      if (c1 == c2)</a>
<a name="ln509">        return c1;             /* yes! */</a>
<a name="ln510">      return 0;</a>
<a name="ln511">    }</a>
<a name="ln512"> </a>
<a name="ln513">    default:</a>
<a name="ln514">      if (p-&gt;c &gt; 0)</a>
<a name="ln515">        return p-&gt;c;             /* yes! */</a>
<a name="ln516">      return 0;</a>
<a name="ln517">    }</a>
<a name="ln518">  }</a>
<a name="ln519">  return 0;</a>
<a name="ln520">}</a>
<a name="ln521"> </a>
<a name="ln522">/*</a>
<a name="ln523"> * Figure out if the NFA state list contains just literal text and nothing</a>
<a name="ln524"> * else.  If so return a string in allocated memory with what must match after</a>
<a name="ln525"> * regstart.  Otherwise return NULL.</a>
<a name="ln526"> */</a>
<a name="ln527">static char_u *nfa_get_match_text(nfa_state_T *start)</a>
<a name="ln528">{</a>
<a name="ln529">  nfa_state_T *p = start;</a>
<a name="ln530">  int len = 0;</a>
<a name="ln531">  char_u      *ret;</a>
<a name="ln532">  char_u      *s;</a>
<a name="ln533"> </a>
<a name="ln534">  if (p-&gt;c != NFA_MOPEN)</a>
<a name="ln535">    return NULL;     /* just in case */</a>
<a name="ln536">  p = p-&gt;out;</a>
<a name="ln537">  while (p-&gt;c &gt; 0) {</a>
<a name="ln538">    len += MB_CHAR2LEN(p-&gt;c);</a>
<a name="ln539">    p = p-&gt;out;</a>
<a name="ln540">  }</a>
<a name="ln541">  if (p-&gt;c != NFA_MCLOSE || p-&gt;out-&gt;c != NFA_MATCH)</a>
<a name="ln542">    return NULL;</a>
<a name="ln543"> </a>
<a name="ln544">  ret = xmalloc(len);</a>
<a name="ln545">  p = start-&gt;out-&gt;out;     /* skip first char, it goes into regstart */</a>
<a name="ln546">  s = ret;</a>
<a name="ln547">  while (p-&gt;c &gt; 0) {</a>
<a name="ln548">    s += utf_char2bytes(p-&gt;c, s);</a>
<a name="ln549">    p = p-&gt;out;</a>
<a name="ln550">  }</a>
<a name="ln551">  *s = NUL;</a>
<a name="ln552"> </a>
<a name="ln553">  return ret;</a>
<a name="ln554">}</a>
<a name="ln555"> </a>
<a name="ln556">/*</a>
<a name="ln557"> * Allocate more space for post_start.  Called when</a>
<a name="ln558"> * running above the estimated number of states.</a>
<a name="ln559"> */</a>
<a name="ln560">static void realloc_post_list(void)</a>
<a name="ln561">{</a>
<a name="ln562">  // For weird patterns the number of states can be very high. Increasing by</a>
<a name="ln563">  // 50% seems a reasonable compromise between memory use and speed.</a>
<a name="ln564">  const size_t new_max = (post_end - post_start) * 3 / 2;</a>
<a name="ln565">  int *new_start = xrealloc(post_start, new_max * sizeof(int));</a>
<a name="ln566">  post_ptr = new_start + (post_ptr - post_start);</a>
<a name="ln567">  post_end = new_start + new_max;</a>
<a name="ln568">  post_start = new_start;</a>
<a name="ln569">}</a>
<a name="ln570"> </a>
<a name="ln571">/*</a>
<a name="ln572"> * Search between &quot;start&quot; and &quot;end&quot; and try to recognize a</a>
<a name="ln573"> * character class in expanded form. For example [0-9].</a>
<a name="ln574"> * On success, return the id the character class to be emitted.</a>
<a name="ln575"> * On failure, return 0 (=FAIL)</a>
<a name="ln576"> * Start points to the first char of the range, while end should point</a>
<a name="ln577"> * to the closing brace.</a>
<a name="ln578"> * Keep in mind that 'ignorecase' applies at execution time, thus [a-z] may</a>
<a name="ln579"> * need to be interpreted as [a-zA-Z].</a>
<a name="ln580"> */</a>
<a name="ln581">static int nfa_recognize_char_class(char_u *start, char_u *end, int extra_newl)</a>
<a name="ln582">{</a>
<a name="ln583">#   define CLASS_not            0x80</a>
<a name="ln584">#   define CLASS_af             0x40</a>
<a name="ln585">#   define CLASS_AF             0x20</a>
<a name="ln586">#   define CLASS_az             0x10</a>
<a name="ln587">#   define CLASS_AZ             0x08</a>
<a name="ln588">#   define CLASS_o7             0x04</a>
<a name="ln589">#   define CLASS_o9             0x02</a>
<a name="ln590">#   define CLASS_underscore     0x01</a>
<a name="ln591"> </a>
<a name="ln592">  char_u      *p;</a>
<a name="ln593">  int config = 0;</a>
<a name="ln594"> </a>
<a name="ln595">  bool newl = extra_newl == true;</a>
<a name="ln596"> </a>
<a name="ln597">  if (*end != ']')</a>
<a name="ln598">    return FAIL;</a>
<a name="ln599">  p = start;</a>
<a name="ln600">  if (*p == '^') {</a>
<a name="ln601">    config |= CLASS_not;</a>
<a name="ln602">    p++;</a>
<a name="ln603">  }</a>
<a name="ln604"> </a>
<a name="ln605">  while (p &lt; end) {</a>
<a name="ln606">    if (p + 2 &lt; end &amp;&amp; *(p + 1) == '-') {</a>
<a name="ln607">      switch (*p) {</a>
<a name="ln608">      case '0':</a>
<a name="ln609">        if (*(p + 2) == '9') {</a>
<a name="ln610">          config |= CLASS_o9;</a>
<a name="ln611">          break;</a>
<a name="ln612">        } else if (*(p + 2) == '7') {</a>
<a name="ln613">          config |= CLASS_o7;</a>
<a name="ln614">          break;</a>
<a name="ln615">        }</a>
<a name="ln616">        return FAIL;</a>
<a name="ln617">      case 'a':</a>
<a name="ln618">        if (*(p + 2) == 'z') {</a>
<a name="ln619">          config |= CLASS_az;</a>
<a name="ln620">          break;</a>
<a name="ln621">        } else if (*(p + 2) == 'f') {</a>
<a name="ln622">          config |= CLASS_af;</a>
<a name="ln623">          break;</a>
<a name="ln624">        }</a>
<a name="ln625">        return FAIL;</a>
<a name="ln626">      case 'A':</a>
<a name="ln627">        if (*(p + 2) == 'Z') {</a>
<a name="ln628">          config |= CLASS_AZ;</a>
<a name="ln629">          break;</a>
<a name="ln630">        } else if (*(p + 2) == 'F') {</a>
<a name="ln631">          config |= CLASS_AF;</a>
<a name="ln632">          break;</a>
<a name="ln633">        }</a>
<a name="ln634">        return FAIL;</a>
<a name="ln635">      default:</a>
<a name="ln636">        return FAIL;</a>
<a name="ln637">      }</a>
<a name="ln638">      p += 3;</a>
<a name="ln639">    } else if (p + 1 &lt; end &amp;&amp; *p == '\\' &amp;&amp; *(p + 1) == 'n') {</a>
<a name="ln640">      newl = true;</a>
<a name="ln641">      p += 2;</a>
<a name="ln642">    } else if (*p == '_') {</a>
<a name="ln643">      config |= CLASS_underscore;</a>
<a name="ln644">      p++;</a>
<a name="ln645">    } else if (*p == '\n') {</a>
<a name="ln646">      newl = true;</a>
<a name="ln647">      p++;</a>
<a name="ln648">    } else</a>
<a name="ln649">      return FAIL;</a>
<a name="ln650">  }   /* while (p &lt; end) */</a>
<a name="ln651"> </a>
<a name="ln652">  if (p != end)</a>
<a name="ln653">    return FAIL;</a>
<a name="ln654"> </a>
<a name="ln655">  if (newl == true) {</a>
<a name="ln656">    extra_newl = NFA_ADD_NL;</a>
<a name="ln657">  }</a>
<a name="ln658"> </a>
<a name="ln659">  switch (config) {</a>
<a name="ln660">  case CLASS_o9:</a>
<a name="ln661">    return extra_newl + NFA_DIGIT;</a>
<a name="ln662">  case CLASS_not |  CLASS_o9:</a>
<a name="ln663">    return extra_newl + NFA_NDIGIT;</a>
<a name="ln664">  case CLASS_af | CLASS_AF | CLASS_o9:</a>
<a name="ln665">    return extra_newl + NFA_HEX;</a>
<a name="ln666">  case CLASS_not | CLASS_af | CLASS_AF | CLASS_o9:</a>
<a name="ln667">    return extra_newl + NFA_NHEX;</a>
<a name="ln668">  case CLASS_o7:</a>
<a name="ln669">    return extra_newl + NFA_OCTAL;</a>
<a name="ln670">  case CLASS_not | CLASS_o7:</a>
<a name="ln671">    return extra_newl + NFA_NOCTAL;</a>
<a name="ln672">  case CLASS_az | CLASS_AZ | CLASS_o9 | CLASS_underscore:</a>
<a name="ln673">    return extra_newl + NFA_WORD;</a>
<a name="ln674">  case CLASS_not | CLASS_az | CLASS_AZ | CLASS_o9 | CLASS_underscore:</a>
<a name="ln675">    return extra_newl + NFA_NWORD;</a>
<a name="ln676">  case CLASS_az | CLASS_AZ | CLASS_underscore:</a>
<a name="ln677">    return extra_newl + NFA_HEAD;</a>
<a name="ln678">  case CLASS_not | CLASS_az | CLASS_AZ | CLASS_underscore:</a>
<a name="ln679">    return extra_newl + NFA_NHEAD;</a>
<a name="ln680">  case CLASS_az | CLASS_AZ:</a>
<a name="ln681">    return extra_newl + NFA_ALPHA;</a>
<a name="ln682">  case CLASS_not | CLASS_az | CLASS_AZ:</a>
<a name="ln683">    return extra_newl + NFA_NALPHA;</a>
<a name="ln684">  case CLASS_az:</a>
<a name="ln685">    return extra_newl + NFA_LOWER_IC;</a>
<a name="ln686">  case CLASS_not | CLASS_az:</a>
<a name="ln687">    return extra_newl + NFA_NLOWER_IC;</a>
<a name="ln688">  case CLASS_AZ:</a>
<a name="ln689">    return extra_newl + NFA_UPPER_IC;</a>
<a name="ln690">  case CLASS_not | CLASS_AZ:</a>
<a name="ln691">    return extra_newl + NFA_NUPPER_IC;</a>
<a name="ln692">  }</a>
<a name="ln693">  return FAIL;</a>
<a name="ln694">}</a>
<a name="ln695"> </a>
<a name="ln696">/*</a>
<a name="ln697"> * Produce the bytes for equivalence class &quot;c&quot;.</a>
<a name="ln698"> * Currently only handles latin1, latin9 and utf-8.</a>
<a name="ln699"> * Emits bytes in postfix notation: 'a,b,NFA_OR,c,NFA_OR' is</a>
<a name="ln700"> * equivalent to 'a OR b OR c'</a>
<a name="ln701"> *</a>
<a name="ln702"> * NOTE! When changing this function, also update reg_equi_class()</a>
<a name="ln703"> */</a>
<a name="ln704">static void nfa_emit_equi_class(int c)</a>
<a name="ln705">{</a>
<a name="ln706">#define EMIT2(c)   EMIT(c); EMIT(NFA_CONCAT);</a>
<a name="ln707">#define EMITMBC(c) EMIT(c); EMIT(NFA_CONCAT);</a>
<a name="ln708"> </a>
<a name="ln709">  {</a>
<a name="ln710">#define A_grave 0xc0</a>
<a name="ln711">#define A_acute 0xc1</a>
<a name="ln712">#define A_circumflex 0xc2</a>
<a name="ln713">#define A_virguilla 0xc3</a>
<a name="ln714">#define A_diaeresis 0xc4</a>
<a name="ln715">#define A_ring 0xc5</a>
<a name="ln716">#define C_cedilla 0xc7</a>
<a name="ln717">#define E_grave 0xc8</a>
<a name="ln718">#define E_acute 0xc9</a>
<a name="ln719">#define E_circumflex 0xca</a>
<a name="ln720">#define E_diaeresis 0xcb</a>
<a name="ln721">#define I_grave 0xcc</a>
<a name="ln722">#define I_acute 0xcd</a>
<a name="ln723">#define I_circumflex 0xce</a>
<a name="ln724">#define I_diaeresis 0xcf</a>
<a name="ln725">#define N_virguilla 0xd1</a>
<a name="ln726">#define O_grave 0xd2</a>
<a name="ln727">#define O_acute 0xd3</a>
<a name="ln728">#define O_circumflex 0xd4</a>
<a name="ln729">#define O_virguilla 0xd5</a>
<a name="ln730">#define O_diaeresis 0xd6</a>
<a name="ln731">#define O_slash 0xd8</a>
<a name="ln732">#define U_grave 0xd9</a>
<a name="ln733">#define U_acute 0xda</a>
<a name="ln734">#define U_circumflex 0xdb</a>
<a name="ln735">#define U_diaeresis 0xdc</a>
<a name="ln736">#define Y_acute 0xdd</a>
<a name="ln737">#define a_grave 0xe0</a>
<a name="ln738">#define a_acute 0xe1</a>
<a name="ln739">#define a_circumflex 0xe2</a>
<a name="ln740">#define a_virguilla 0xe3</a>
<a name="ln741">#define a_diaeresis 0xe4</a>
<a name="ln742">#define a_ring 0xe5</a>
<a name="ln743">#define c_cedilla 0xe7</a>
<a name="ln744">#define e_grave 0xe8</a>
<a name="ln745">#define e_acute 0xe9</a>
<a name="ln746">#define e_circumflex 0xea</a>
<a name="ln747">#define e_diaeresis 0xeb</a>
<a name="ln748">#define i_grave 0xec</a>
<a name="ln749">#define i_acute 0xed</a>
<a name="ln750">#define i_circumflex 0xee</a>
<a name="ln751">#define i_diaeresis 0xef</a>
<a name="ln752">#define n_virguilla 0xf1</a>
<a name="ln753">#define o_grave 0xf2</a>
<a name="ln754">#define o_acute 0xf3</a>
<a name="ln755">#define o_circumflex 0xf4</a>
<a name="ln756">#define o_virguilla 0xf5</a>
<a name="ln757">#define o_diaeresis 0xf6</a>
<a name="ln758">#define o_slash 0xf8</a>
<a name="ln759">#define u_grave 0xf9</a>
<a name="ln760">#define u_acute 0xfa</a>
<a name="ln761">#define u_circumflex 0xfb</a>
<a name="ln762">#define u_diaeresis 0xfc</a>
<a name="ln763">#define y_acute 0xfd</a>
<a name="ln764">#define y_diaeresis 0xff</a>
<a name="ln765">    switch (c) {</a>
<a name="ln766">    case 'A': case A_grave: case A_acute: case A_circumflex:</a>
<a name="ln767">              case A_virguilla: case A_diaeresis: case A_ring:</a>
<a name="ln768">              CASEMBC(0x100) CASEMBC(0x102) CASEMBC(0x104)</a>
<a name="ln769">              CASEMBC(0x1cd) CASEMBC(0x1de) CASEMBC(0x1e0)</a>
<a name="ln770">              CASEMBC(0x1ea2)</a>
<a name="ln771">      EMIT2('A'); EMIT2(A_grave); EMIT2(A_acute);</a>
<a name="ln772">      EMIT2(A_circumflex); EMIT2(A_virguilla);</a>
<a name="ln773">      EMIT2(A_diaeresis); EMIT2(A_ring);</a>
<a name="ln774">      EMITMBC(0x100) EMITMBC(0x102) EMITMBC(0x104)</a>
<a name="ln775">      EMITMBC(0x1cd) EMITMBC(0x1de) EMITMBC(0x1e0)</a>
<a name="ln776">      EMITMBC(0x1ea2)</a>
<a name="ln777">      return;</a>
<a name="ln778"> </a>
<a name="ln779">    case 'B': CASEMBC(0x1e02) CASEMBC(0x1e06)</a>
<a name="ln780">      EMIT2('B'); EMITMBC(0x1e02) EMITMBC(0x1e06)</a>
<a name="ln781">      return;</a>
<a name="ln782"> </a>
<a name="ln783">    case 'C': case C_cedilla: CASEMBC(0x106) CASEMBC(0x108) CASEMBC(0x10a)</a>
<a name="ln784">              CASEMBC(0x10c)</a>
<a name="ln785">      EMIT2('C'); EMIT2(C_cedilla); EMITMBC(0x106) EMITMBC(0x108)</a>
<a name="ln786">      EMITMBC(0x10a) EMITMBC(0x10c)</a>
<a name="ln787">      return;</a>
<a name="ln788"> </a>
<a name="ln789">    case 'D': CASEMBC(0x10e) CASEMBC(0x110) CASEMBC(0x1e0a)</a>
<a name="ln790">              CASEMBC(0x1e0e) CASEMBC(0x1e10)</a>
<a name="ln791">      EMIT2('D'); EMITMBC(0x10e) EMITMBC(0x110) EMITMBC(0x1e0a)</a>
<a name="ln792">      EMITMBC(0x1e0e) EMITMBC(0x1e10)</a>
<a name="ln793">      return;</a>
<a name="ln794"> </a>
<a name="ln795">    case 'E': case E_grave: case E_acute: case E_circumflex:</a>
<a name="ln796">              case E_diaeresis: CASEMBC(0x112) CASEMBC(0x114)</a>
<a name="ln797">              CASEMBC(0x116) CASEMBC(0x118) CASEMBC(0x11a)</a>
<a name="ln798">              CASEMBC(0x1eba) CASEMBC(0x1ebc)</a>
<a name="ln799">      EMIT2('E'); EMIT2(E_grave); EMIT2(E_acute);</a>
<a name="ln800">      EMIT2(E_circumflex); EMIT2(E_diaeresis);</a>
<a name="ln801">      EMITMBC(0x112) EMITMBC(0x114) EMITMBC(0x116)</a>
<a name="ln802">      EMITMBC(0x118) EMITMBC(0x11a) EMITMBC(0x1eba)</a>
<a name="ln803">      EMITMBC(0x1ebc)</a>
<a name="ln804">      return;</a>
<a name="ln805"> </a>
<a name="ln806">    case 'F': CASEMBC(0x1e1e)</a>
<a name="ln807">      EMIT2('F'); EMITMBC(0x1e1e)</a>
<a name="ln808">      return;</a>
<a name="ln809"> </a>
<a name="ln810">    case 'G': CASEMBC(0x11c) CASEMBC(0x11e) CASEMBC(0x120)</a>
<a name="ln811">              CASEMBC(0x122) CASEMBC(0x1e4) CASEMBC(0x1e6)</a>
<a name="ln812">              CASEMBC(0x1f4) CASEMBC(0x1e20)</a>
<a name="ln813">      EMIT2('G'); EMITMBC(0x11c) EMITMBC(0x11e) EMITMBC(0x120)</a>
<a name="ln814">      EMITMBC(0x122) EMITMBC(0x1e4) EMITMBC(0x1e6)</a>
<a name="ln815">      EMITMBC(0x1f4) EMITMBC(0x1e20)</a>
<a name="ln816">      return;</a>
<a name="ln817"> </a>
<a name="ln818">    case 'H': CASEMBC(0x124) CASEMBC(0x126) CASEMBC(0x1e22)</a>
<a name="ln819">              CASEMBC(0x1e26) CASEMBC(0x1e28)</a>
<a name="ln820">      EMIT2('H'); EMITMBC(0x124) EMITMBC(0x126) EMITMBC(0x1e22)</a>
<a name="ln821">      EMITMBC(0x1e26) EMITMBC(0x1e28)</a>
<a name="ln822">      return;</a>
<a name="ln823"> </a>
<a name="ln824">    case 'I': case I_grave: case I_acute: case I_circumflex:</a>
<a name="ln825">              case I_diaeresis: CASEMBC(0x128) CASEMBC(0x12a)</a>
<a name="ln826">              CASEMBC(0x12c) CASEMBC(0x12e) CASEMBC(0x130)</a>
<a name="ln827">              CASEMBC(0x1cf) CASEMBC(0x1ec8)</a>
<a name="ln828">      EMIT2('I'); EMIT2(I_grave); EMIT2(I_acute);</a>
<a name="ln829">      EMIT2(I_circumflex); EMIT2(I_diaeresis);</a>
<a name="ln830">      EMITMBC(0x128) EMITMBC(0x12a)</a>
<a name="ln831">      EMITMBC(0x12c) EMITMBC(0x12e) EMITMBC(0x130)</a>
<a name="ln832">      EMITMBC(0x1cf) EMITMBC(0x1ec8)</a>
<a name="ln833">      return;</a>
<a name="ln834"> </a>
<a name="ln835">    case 'J': CASEMBC(0x134)</a>
<a name="ln836">      EMIT2('J'); EMITMBC(0x134)</a>
<a name="ln837">      return;</a>
<a name="ln838"> </a>
<a name="ln839">    case 'K': CASEMBC(0x136) CASEMBC(0x1e8) CASEMBC(0x1e30)</a>
<a name="ln840">              CASEMBC(0x1e34)</a>
<a name="ln841">      EMIT2('K'); EMITMBC(0x136) EMITMBC(0x1e8) EMITMBC(0x1e30)</a>
<a name="ln842">      EMITMBC(0x1e34)</a>
<a name="ln843">      return;</a>
<a name="ln844"> </a>
<a name="ln845">    case 'L': CASEMBC(0x139) CASEMBC(0x13b) CASEMBC(0x13d)</a>
<a name="ln846">              CASEMBC(0x13f) CASEMBC(0x141) CASEMBC(0x1e3a)</a>
<a name="ln847">      EMIT2('L'); EMITMBC(0x139) EMITMBC(0x13b) EMITMBC(0x13d)</a>
<a name="ln848">      EMITMBC(0x13f) EMITMBC(0x141) EMITMBC(0x1e3a)</a>
<a name="ln849">      return;</a>
<a name="ln850"> </a>
<a name="ln851">    case 'M': CASEMBC(0x1e3e) CASEMBC(0x1e40)</a>
<a name="ln852">      EMIT2('M'); EMITMBC(0x1e3e) EMITMBC(0x1e40)</a>
<a name="ln853">      return;</a>
<a name="ln854"> </a>
<a name="ln855">    case 'N': case N_virguilla: CASEMBC(0x143) CASEMBC(0x145)</a>
<a name="ln856">              CASEMBC(0x147) CASEMBC(0x1e44) CASEMBC(0x1e48)</a>
<a name="ln857">      EMIT2('N'); EMIT2(N_virguilla);</a>
<a name="ln858">      EMITMBC(0x143) EMITMBC(0x145)</a>
<a name="ln859">      EMITMBC(0x147) EMITMBC(0x1e44) EMITMBC(0x1e48)</a>
<a name="ln860">      return;</a>
<a name="ln861"> </a>
<a name="ln862">    case 'O': case O_grave: case O_acute: case O_circumflex:</a>
<a name="ln863">              case O_virguilla: case O_diaeresis: case O_slash:</a>
<a name="ln864">              CASEMBC(0x14c) CASEMBC(0x14e) CASEMBC(0x150)</a>
<a name="ln865">              CASEMBC(0x1a0) CASEMBC(0x1d1) CASEMBC(0x1ea)</a>
<a name="ln866">              CASEMBC(0x1ec) CASEMBC(0x1ece)</a>
<a name="ln867">      EMIT2('O'); EMIT2(O_grave); EMIT2(O_acute);</a>
<a name="ln868">      EMIT2(O_circumflex); EMIT2(O_virguilla);</a>
<a name="ln869">      EMIT2(O_diaeresis); EMIT2(O_slash);</a>
<a name="ln870">      EMITMBC(0x14c) EMITMBC(0x14e) EMITMBC(0x150)</a>
<a name="ln871">      EMITMBC(0x1a0) EMITMBC(0x1d1) EMITMBC(0x1ea)</a>
<a name="ln872">      EMITMBC(0x1ec) EMITMBC(0x1ece)</a>
<a name="ln873">      return;</a>
<a name="ln874"> </a>
<a name="ln875">    case 'P': case 0x1e54: case 0x1e56:</a>
<a name="ln876">      EMIT2('P'); EMITMBC(0x1e54) EMITMBC(0x1e56)</a>
<a name="ln877">      return;</a>
<a name="ln878"> </a>
<a name="ln879">    case 'R': CASEMBC(0x154) CASEMBC(0x156) CASEMBC(0x158)</a>
<a name="ln880">              CASEMBC(0x1e58) CASEMBC(0x1e5e)</a>
<a name="ln881">      EMIT2('R'); EMITMBC(0x154) EMITMBC(0x156) EMITMBC(0x158)</a>
<a name="ln882">      EMITMBC(0x1e58) EMITMBC(0x1e5e)</a>
<a name="ln883">      return;</a>
<a name="ln884"> </a>
<a name="ln885">    case 'S': CASEMBC(0x15a) CASEMBC(0x15c) CASEMBC(0x15e)</a>
<a name="ln886">              CASEMBC(0x160) CASEMBC(0x1e60)</a>
<a name="ln887">      EMIT2('S'); EMITMBC(0x15a) EMITMBC(0x15c) EMITMBC(0x15e)</a>
<a name="ln888">      EMITMBC(0x160) EMITMBC(0x1e60)</a>
<a name="ln889">      return;</a>
<a name="ln890"> </a>
<a name="ln891">    case 'T': CASEMBC(0x162) CASEMBC(0x164) CASEMBC(0x166)</a>
<a name="ln892">              CASEMBC(0x1e6a) CASEMBC(0x1e6e)</a>
<a name="ln893">      EMIT2('T'); EMITMBC(0x162) EMITMBC(0x164) EMITMBC(0x166)</a>
<a name="ln894">      EMITMBC(0x1e6a) EMITMBC(0x1e6e)</a>
<a name="ln895">      return;</a>
<a name="ln896"> </a>
<a name="ln897">    case 'U': case U_grave: case U_acute: case U_diaeresis:</a>
<a name="ln898">              case U_circumflex: CASEMBC(0x168) CASEMBC(0x16a)</a>
<a name="ln899">              CASEMBC(0x16c) CASEMBC(0x16e) CASEMBC(0x170)</a>
<a name="ln900">              CASEMBC(0x172) CASEMBC(0x1af) CASEMBC(0x1d3)</a>
<a name="ln901">              CASEMBC(0x1ee6)</a>
<a name="ln902">      EMIT2('U'); EMIT2(U_grave); EMIT2(U_acute);</a>
<a name="ln903">      EMIT2(U_diaeresis); EMIT2(U_circumflex);</a>
<a name="ln904">      EMITMBC(0x168) EMITMBC(0x16a)</a>
<a name="ln905">      EMITMBC(0x16c) EMITMBC(0x16e) EMITMBC(0x170)</a>
<a name="ln906">      EMITMBC(0x172) EMITMBC(0x1af) EMITMBC(0x1d3)</a>
<a name="ln907">      EMITMBC(0x1ee6)</a>
<a name="ln908">      return;</a>
<a name="ln909"> </a>
<a name="ln910">    case 'V': CASEMBC(0x1e7c)</a>
<a name="ln911">      EMIT2('V'); EMITMBC(0x1e7c)</a>
<a name="ln912">      return;</a>
<a name="ln913"> </a>
<a name="ln914">    case 'W': CASEMBC(0x174) CASEMBC(0x1e80) CASEMBC(0x1e82)</a>
<a name="ln915">              CASEMBC(0x1e84) CASEMBC(0x1e86)</a>
<a name="ln916">      EMIT2('W'); EMITMBC(0x174) EMITMBC(0x1e80) EMITMBC(0x1e82)</a>
<a name="ln917">      EMITMBC(0x1e84) EMITMBC(0x1e86)</a>
<a name="ln918">      return;</a>
<a name="ln919"> </a>
<a name="ln920">    case 'X': CASEMBC(0x1e8a) CASEMBC(0x1e8c)</a>
<a name="ln921">      EMIT2('X'); EMITMBC(0x1e8a) EMITMBC(0x1e8c)</a>
<a name="ln922">      return;</a>
<a name="ln923"> </a>
<a name="ln924">    case 'Y': case Y_acute: CASEMBC(0x176) CASEMBC(0x178)</a>
<a name="ln925">              CASEMBC(0x1e8e) CASEMBC(0x1ef2) CASEMBC(0x1ef6)</a>
<a name="ln926">              CASEMBC(0x1ef8)</a>
<a name="ln927">      EMIT2('Y'); EMIT2(Y_acute);</a>
<a name="ln928">      EMITMBC(0x176) EMITMBC(0x178)</a>
<a name="ln929">      EMITMBC(0x1e8e) EMITMBC(0x1ef2) EMITMBC(0x1ef6)</a>
<a name="ln930">      EMITMBC(0x1ef8)</a>
<a name="ln931">      return;</a>
<a name="ln932"> </a>
<a name="ln933">    case 'Z': CASEMBC(0x179) CASEMBC(0x17b) CASEMBC(0x17d)</a>
<a name="ln934">              CASEMBC(0x1b5) CASEMBC(0x1e90) CASEMBC(0x1e94)</a>
<a name="ln935">      EMIT2('Z'); EMITMBC(0x179) EMITMBC(0x17b) EMITMBC(0x17d)</a>
<a name="ln936">      EMITMBC(0x1b5) EMITMBC(0x1e90) EMITMBC(0x1e94)</a>
<a name="ln937">      return;</a>
<a name="ln938"> </a>
<a name="ln939">    case 'a': case a_grave: case a_acute: case a_circumflex:</a>
<a name="ln940">              case a_virguilla: case a_diaeresis: case a_ring:</a>
<a name="ln941">              CASEMBC(0x101) CASEMBC(0x103) CASEMBC(0x105)</a>
<a name="ln942">              CASEMBC(0x1ce) CASEMBC(0x1df) CASEMBC(0x1e1)</a>
<a name="ln943">              CASEMBC(0x1ea3)</a>
<a name="ln944">      EMIT2('a'); EMIT2(a_grave); EMIT2(a_acute);</a>
<a name="ln945">      EMIT2(a_circumflex); EMIT2(a_virguilla);</a>
<a name="ln946">      EMIT2(a_diaeresis); EMIT2(a_ring);</a>
<a name="ln947">      EMITMBC(0x101) EMITMBC(0x103) EMITMBC(0x105)</a>
<a name="ln948">      EMITMBC(0x1ce) EMITMBC(0x1df) EMITMBC(0x1e1)</a>
<a name="ln949">      EMITMBC(0x1ea3)</a>
<a name="ln950">      return;</a>
<a name="ln951"> </a>
<a name="ln952">    case 'b': CASEMBC(0x1e03) CASEMBC(0x1e07)</a>
<a name="ln953">      EMIT2('b'); EMITMBC(0x1e03) EMITMBC(0x1e07)</a>
<a name="ln954">      return;</a>
<a name="ln955"> </a>
<a name="ln956">    case 'c': case c_cedilla: CASEMBC(0x107) CASEMBC(0x109)</a>
<a name="ln957">              CASEMBC(0x10b) CASEMBC(0x10d)</a>
<a name="ln958">      EMIT2('c'); EMIT2(c_cedilla);</a>
<a name="ln959">      EMITMBC(0x107) EMITMBC(0x109)</a>
<a name="ln960">      EMITMBC(0x10b) EMITMBC(0x10d)</a>
<a name="ln961">      return;</a>
<a name="ln962"> </a>
<a name="ln963">    case 'd': CASEMBC(0x10f) CASEMBC(0x111) CASEMBC(0x1e0b)</a>
<a name="ln964">              CASEMBC(0x1e0f) CASEMBC(0x1e11)</a>
<a name="ln965">      EMIT2('d'); EMITMBC(0x10f) EMITMBC(0x111) EMITMBC(0x1e0b)</a>
<a name="ln966">      EMITMBC(0x1e0f) EMITMBC(0x1e11)</a>
<a name="ln967">      return;</a>
<a name="ln968"> </a>
<a name="ln969">    case 'e': case e_grave: case e_acute: case e_circumflex:</a>
<a name="ln970">              case e_diaeresis: CASEMBC(0x113) CASEMBC(0x115)</a>
<a name="ln971">              CASEMBC(0x117) CASEMBC(0x119) CASEMBC(0x11b)</a>
<a name="ln972">              CASEMBC(0x1ebb) CASEMBC(0x1ebd)</a>
<a name="ln973">      EMIT2('e'); EMIT2(e_grave); EMIT2(e_acute);</a>
<a name="ln974">      EMIT2(e_circumflex); EMIT2(e_diaeresis);</a>
<a name="ln975">      EMITMBC(0x113) EMITMBC(0x115)</a>
<a name="ln976">      EMITMBC(0x117) EMITMBC(0x119) EMITMBC(0x11b)</a>
<a name="ln977">      EMITMBC(0x1ebb) EMITMBC(0x1ebd)</a>
<a name="ln978">      return;</a>
<a name="ln979"> </a>
<a name="ln980">    case 'f': CASEMBC(0x1e1f)</a>
<a name="ln981">      EMIT2('f'); EMITMBC(0x1e1f)</a>
<a name="ln982">      return;</a>
<a name="ln983"> </a>
<a name="ln984">    case 'g': CASEMBC(0x11d) CASEMBC(0x11f) CASEMBC(0x121)</a>
<a name="ln985">              CASEMBC(0x123) CASEMBC(0x1e5) CASEMBC(0x1e7)</a>
<a name="ln986">              CASEMBC(0x1f5) CASEMBC(0x1e21)</a>
<a name="ln987">      EMIT2('g'); EMITMBC(0x11d) EMITMBC(0x11f) EMITMBC(0x121)</a>
<a name="ln988">      EMITMBC(0x123) EMITMBC(0x1e5) EMITMBC(0x1e7)</a>
<a name="ln989">      EMITMBC(0x1f5) EMITMBC(0x1e21)</a>
<a name="ln990">      return;</a>
<a name="ln991"> </a>
<a name="ln992">    case 'h': CASEMBC(0x125) CASEMBC(0x127) CASEMBC(0x1e23)</a>
<a name="ln993">              CASEMBC(0x1e27) CASEMBC(0x1e29) CASEMBC(0x1e96)</a>
<a name="ln994">      EMIT2('h'); EMITMBC(0x125) EMITMBC(0x127) EMITMBC(0x1e23)</a>
<a name="ln995">      EMITMBC(0x1e27) EMITMBC(0x1e29) EMITMBC(0x1e96)</a>
<a name="ln996">      return;</a>
<a name="ln997"> </a>
<a name="ln998">    case 'i': case i_grave: case i_acute: case i_circumflex:</a>
<a name="ln999">              case i_diaeresis: CASEMBC(0x129) CASEMBC(0x12b)</a>
<a name="ln1000">              CASEMBC(0x12d) CASEMBC(0x12f) CASEMBC(0x1d0)</a>
<a name="ln1001">              CASEMBC(0x1ec9)</a>
<a name="ln1002">      EMIT2('i'); EMIT2(i_grave); EMIT2(i_acute);</a>
<a name="ln1003">      EMIT2(i_circumflex); EMIT2(i_diaeresis);</a>
<a name="ln1004">      EMITMBC(0x129) EMITMBC(0x12b)</a>
<a name="ln1005">      EMITMBC(0x12d) EMITMBC(0x12f) EMITMBC(0x1d0)</a>
<a name="ln1006">      EMITMBC(0x1ec9)</a>
<a name="ln1007">      return;</a>
<a name="ln1008"> </a>
<a name="ln1009">    case 'j': CASEMBC(0x135) CASEMBC(0x1f0)</a>
<a name="ln1010">      EMIT2('j'); EMITMBC(0x135) EMITMBC(0x1f0)</a>
<a name="ln1011">      return;</a>
<a name="ln1012"> </a>
<a name="ln1013">    case 'k': CASEMBC(0x137) CASEMBC(0x1e9) CASEMBC(0x1e31)</a>
<a name="ln1014">              CASEMBC(0x1e35)</a>
<a name="ln1015">      EMIT2('k'); EMITMBC(0x137) EMITMBC(0x1e9) EMITMBC(0x1e31)</a>
<a name="ln1016">      EMITMBC(0x1e35)</a>
<a name="ln1017">      return;</a>
<a name="ln1018"> </a>
<a name="ln1019">    case 'l': CASEMBC(0x13a) CASEMBC(0x13c) CASEMBC(0x13e)</a>
<a name="ln1020">              CASEMBC(0x140) CASEMBC(0x142) CASEMBC(0x1e3b)</a>
<a name="ln1021">      EMIT2('l'); EMITMBC(0x13a) EMITMBC(0x13c) EMITMBC(0x13e)</a>
<a name="ln1022">      EMITMBC(0x140) EMITMBC(0x142) EMITMBC(0x1e3b)</a>
<a name="ln1023">      return;</a>
<a name="ln1024"> </a>
<a name="ln1025">    case 'm': CASEMBC(0x1e3f) CASEMBC(0x1e41)</a>
<a name="ln1026">      EMIT2('m'); EMITMBC(0x1e3f) EMITMBC(0x1e41)</a>
<a name="ln1027">      return;</a>
<a name="ln1028"> </a>
<a name="ln1029">    case 'n': case n_virguilla: CASEMBC(0x144) CASEMBC(0x146)</a>
<a name="ln1030">              CASEMBC(0x148) CASEMBC(0x149) CASEMBC(0x1e45)</a>
<a name="ln1031">              CASEMBC(0x1e49)</a>
<a name="ln1032">      EMIT2('n'); EMIT2(n_virguilla);</a>
<a name="ln1033">      EMITMBC(0x144) EMITMBC(0x146)</a>
<a name="ln1034">      EMITMBC(0x148) EMITMBC(0x149) EMITMBC(0x1e45)</a>
<a name="ln1035">      EMITMBC(0x1e49)</a>
<a name="ln1036">      return;</a>
<a name="ln1037"> </a>
<a name="ln1038">    case 'o': case o_grave: case o_acute: case o_circumflex:</a>
<a name="ln1039">              case o_virguilla: case o_diaeresis: case o_slash:</a>
<a name="ln1040">              CASEMBC(0x14d) CASEMBC(0x14f) CASEMBC(0x151)</a>
<a name="ln1041">              CASEMBC(0x1a1) CASEMBC(0x1d2) CASEMBC(0x1eb)</a>
<a name="ln1042">              CASEMBC(0x1ed) CASEMBC(0x1ecf)</a>
<a name="ln1043">      EMIT2('o'); EMIT2(o_grave); EMIT2(o_acute);</a>
<a name="ln1044">      EMIT2(o_circumflex); EMIT2(o_virguilla);</a>
<a name="ln1045">      EMIT2(o_diaeresis); EMIT2(o_slash);</a>
<a name="ln1046">      EMITMBC(0x14d) EMITMBC(0x14f) EMITMBC(0x151)</a>
<a name="ln1047">      EMITMBC(0x1a1) EMITMBC(0x1d2) EMITMBC(0x1eb)</a>
<a name="ln1048">      EMITMBC(0x1ed) EMITMBC(0x1ecf)</a>
<a name="ln1049">      return;</a>
<a name="ln1050"> </a>
<a name="ln1051">    case 'p': CASEMBC(0x1e55) CASEMBC(0x1e57)</a>
<a name="ln1052">      EMIT2('p'); EMITMBC(0x1e55) EMITMBC(0x1e57)</a>
<a name="ln1053">      return;</a>
<a name="ln1054"> </a>
<a name="ln1055">    case 'r': CASEMBC(0x155) CASEMBC(0x157) CASEMBC(0x159)</a>
<a name="ln1056">              CASEMBC(0x1e59) CASEMBC(0x1e5f)</a>
<a name="ln1057">      EMIT2('r'); EMITMBC(0x155) EMITMBC(0x157) EMITMBC(0x159)</a>
<a name="ln1058">      EMITMBC(0x1e59) EMITMBC(0x1e5f)</a>
<a name="ln1059">      return;</a>
<a name="ln1060"> </a>
<a name="ln1061">    case 's': CASEMBC(0x15b) CASEMBC(0x15d) CASEMBC(0x15f)</a>
<a name="ln1062">              CASEMBC(0x161) CASEMBC(0x1e61)</a>
<a name="ln1063">      EMIT2('s'); EMITMBC(0x15b) EMITMBC(0x15d) EMITMBC(0x15f)</a>
<a name="ln1064">      EMITMBC(0x161) EMITMBC(0x1e61)</a>
<a name="ln1065">      return;</a>
<a name="ln1066"> </a>
<a name="ln1067">    case 't': CASEMBC(0x163) CASEMBC(0x165) CASEMBC(0x167)</a>
<a name="ln1068">              CASEMBC(0x1e6b) CASEMBC(0x1e6f) CASEMBC(0x1e97)</a>
<a name="ln1069">      EMIT2('t'); EMITMBC(0x163) EMITMBC(0x165) EMITMBC(0x167)</a>
<a name="ln1070">      EMITMBC(0x1e6b) EMITMBC(0x1e6f) EMITMBC(0x1e97)</a>
<a name="ln1071">      return;</a>
<a name="ln1072"> </a>
<a name="ln1073">    case 'u': case u_grave: case u_acute: case u_circumflex:</a>
<a name="ln1074">              case u_diaeresis: CASEMBC(0x169) CASEMBC(0x16b)</a>
<a name="ln1075">              CASEMBC(0x16d) CASEMBC(0x16f) CASEMBC(0x171)</a>
<a name="ln1076">              CASEMBC(0x173) CASEMBC(0x1b0) CASEMBC(0x1d4)</a>
<a name="ln1077">              CASEMBC(0x1ee7)</a>
<a name="ln1078">      EMIT2('u'); EMIT2(u_grave); EMIT2(u_acute);</a>
<a name="ln1079">      EMIT2(u_circumflex); EMIT2(u_diaeresis);</a>
<a name="ln1080">      EMITMBC(0x169) EMITMBC(0x16b)</a>
<a name="ln1081">      EMITMBC(0x16d) EMITMBC(0x16f) EMITMBC(0x171)</a>
<a name="ln1082">      EMITMBC(0x173) EMITMBC(0x1b0) EMITMBC(0x1d4)</a>
<a name="ln1083">      EMITMBC(0x1ee7)</a>
<a name="ln1084">      return;</a>
<a name="ln1085"> </a>
<a name="ln1086">    case 'v': CASEMBC(0x1e7d)</a>
<a name="ln1087">      EMIT2('v'); EMITMBC(0x1e7d)</a>
<a name="ln1088">      return;</a>
<a name="ln1089"> </a>
<a name="ln1090">    case 'w': CASEMBC(0x175) CASEMBC(0x1e81) CASEMBC(0x1e83)</a>
<a name="ln1091">              CASEMBC(0x1e85) CASEMBC(0x1e87) CASEMBC(0x1e98)</a>
<a name="ln1092">      EMIT2('w'); EMITMBC(0x175) EMITMBC(0x1e81) EMITMBC(0x1e83)</a>
<a name="ln1093">      EMITMBC(0x1e85) EMITMBC(0x1e87) EMITMBC(0x1e98)</a>
<a name="ln1094">      return;</a>
<a name="ln1095"> </a>
<a name="ln1096">    case 'x': CASEMBC(0x1e8b) CASEMBC(0x1e8d)</a>
<a name="ln1097">      EMIT2('x'); EMITMBC(0x1e8b) EMITMBC(0x1e8d)</a>
<a name="ln1098">      return;</a>
<a name="ln1099"> </a>
<a name="ln1100">    case 'y': case y_acute: case y_diaeresis: CASEMBC(0x177)</a>
<a name="ln1101">              CASEMBC(0x1e8f) CASEMBC(0x1e99) CASEMBC(0x1ef3)</a>
<a name="ln1102">              CASEMBC(0x1ef7) CASEMBC(0x1ef9)</a>
<a name="ln1103">      EMIT2('y'); EMIT2(y_acute); EMIT2(y_diaeresis);</a>
<a name="ln1104">      EMITMBC(0x177)</a>
<a name="ln1105">      EMITMBC(0x1e8f) EMITMBC(0x1e99) EMITMBC(0x1ef3)</a>
<a name="ln1106">      EMITMBC(0x1ef7) EMITMBC(0x1ef9)</a>
<a name="ln1107">      return;</a>
<a name="ln1108"> </a>
<a name="ln1109">    case 'z': CASEMBC(0x17a) CASEMBC(0x17c) CASEMBC(0x17e)</a>
<a name="ln1110">              CASEMBC(0x1b6) CASEMBC(0x1e91) CASEMBC(0x1e95)</a>
<a name="ln1111">      EMIT2('z'); EMITMBC(0x17a) EMITMBC(0x17c) EMITMBC(0x17e)</a>
<a name="ln1112">      EMITMBC(0x1b6) EMITMBC(0x1e91) EMITMBC(0x1e95)</a>
<a name="ln1113">      return;</a>
<a name="ln1114"> </a>
<a name="ln1115">      /* default: character itself */</a>
<a name="ln1116">    }</a>
<a name="ln1117">  }</a>
<a name="ln1118"> </a>
<a name="ln1119">  EMIT2(c);</a>
<a name="ln1120">#undef EMIT2</a>
<a name="ln1121">#undef EMITMBC</a>
<a name="ln1122">}</a>
<a name="ln1123"> </a>
<a name="ln1124">/*</a>
<a name="ln1125"> * Code to parse regular expression.</a>
<a name="ln1126"> *</a>
<a name="ln1127"> * We try to reuse parsing functions in regexp.c to</a>
<a name="ln1128"> * minimize surprise and keep the syntax consistent.</a>
<a name="ln1129"> */</a>
<a name="ln1130"> </a>
<a name="ln1131">/*</a>
<a name="ln1132"> * Parse the lowest level.</a>
<a name="ln1133"> *</a>
<a name="ln1134"> * An atom can be one of a long list of items.  Many atoms match one character</a>
<a name="ln1135"> * in the text.  It is often an ordinary character or a character class.</a>
<a name="ln1136"> * Braces can be used to make a pattern into an atom.  The &quot;\z(\)&quot; construct</a>
<a name="ln1137"> * is only for syntax highlighting.</a>
<a name="ln1138"> *</a>
<a name="ln1139"> * atom    ::=     ordinary-atom</a>
<a name="ln1140"> *     or  \( pattern \)</a>
<a name="ln1141"> *     or  \%( pattern \)</a>
<a name="ln1142"> *     or  \z( pattern \)</a>
<a name="ln1143"> */</a>
<a name="ln1144">static int nfa_regatom(void)</a>
<a name="ln1145">{</a>
<a name="ln1146">  int c;</a>
<a name="ln1147">  int charclass;</a>
<a name="ln1148">  int equiclass;</a>
<a name="ln1149">  int collclass;</a>
<a name="ln1150">  int got_coll_char;</a>
<a name="ln1151">  char_u      *p;</a>
<a name="ln1152">  char_u      *endp;</a>
<a name="ln1153">  char_u      *old_regparse = regparse;</a>
<a name="ln1154">  int extra = 0;</a>
<a name="ln1155">  int emit_range;</a>
<a name="ln1156">  int negated;</a>
<a name="ln1157">  int startc = -1;</a>
<a name="ln1158">  int endc = -1;</a>
<a name="ln1159">  int oldstartc = -1;</a>
<a name="ln1160">  int save_prev_at_start = prev_at_start;</a>
<a name="ln1161"> </a>
<a name="ln1162">  c = getchr();</a>
<a name="ln1163">  switch (c) {</a>
<a name="ln1164">  case NUL:</a>
<a name="ln1165">    EMSG_RET_FAIL(_(e_nul_found));</a>
<a name="ln1166"> </a>
<a name="ln1167">  case Magic('^'):</a>
<a name="ln1168">    EMIT(NFA_BOL);</a>
<a name="ln1169">    break;</a>
<a name="ln1170"> </a>
<a name="ln1171">  case Magic('$'):</a>
<a name="ln1172">    EMIT(NFA_EOL);</a>
<a name="ln1173">    had_eol = true;</a>
<a name="ln1174">    break;</a>
<a name="ln1175"> </a>
<a name="ln1176">  case Magic('&lt;'):</a>
<a name="ln1177">    EMIT(NFA_BOW);</a>
<a name="ln1178">    break;</a>
<a name="ln1179"> </a>
<a name="ln1180">  case Magic('&gt;'):</a>
<a name="ln1181">    EMIT(NFA_EOW);</a>
<a name="ln1182">    break;</a>
<a name="ln1183"> </a>
<a name="ln1184">  case Magic('_'):</a>
<a name="ln1185">    c = no_Magic(getchr());</a>
<a name="ln1186">    if (c == NUL)</a>
<a name="ln1187">      EMSG_RET_FAIL(_(e_nul_found));</a>
<a name="ln1188"> </a>
<a name="ln1189">    if (c == '^') {             /* &quot;\_^&quot; is start-of-line */</a>
<a name="ln1190">      EMIT(NFA_BOL);</a>
<a name="ln1191">      break;</a>
<a name="ln1192">    }</a>
<a name="ln1193">    if (c == '$') {             /* &quot;\_$&quot; is end-of-line */</a>
<a name="ln1194">      EMIT(NFA_EOL);</a>
<a name="ln1195">      had_eol = true;</a>
<a name="ln1196">      break;</a>
<a name="ln1197">    }</a>
<a name="ln1198"> </a>
<a name="ln1199">    extra = NFA_ADD_NL;</a>
<a name="ln1200"> </a>
<a name="ln1201">    /* &quot;\_[&quot; is collection plus newline */</a>
<a name="ln1202">    if (c == '[')</a>
<a name="ln1203">      goto collection;</a>
<a name="ln1204"> </a>
<a name="ln1205">  // &quot;\_x&quot; is character class plus newline</a>
<a name="ln1206">  FALLTHROUGH;</a>
<a name="ln1207"> </a>
<a name="ln1208">  /*</a>
<a name="ln1209">   * Character classes.</a>
<a name="ln1210">   */</a>
<a name="ln1211">  case Magic('.'):</a>
<a name="ln1212">  case Magic('i'):</a>
<a name="ln1213">  case Magic('I'):</a>
<a name="ln1214">  case Magic('k'):</a>
<a name="ln1215">  case Magic('K'):</a>
<a name="ln1216">  case Magic('f'):</a>
<a name="ln1217">  case Magic('F'):</a>
<a name="ln1218">  case Magic('p'):</a>
<a name="ln1219">  case Magic('P'):</a>
<a name="ln1220">  case Magic('s'):</a>
<a name="ln1221">  case Magic('S'):</a>
<a name="ln1222">  case Magic('d'):</a>
<a name="ln1223">  case Magic('D'):</a>
<a name="ln1224">  case Magic('x'):</a>
<a name="ln1225">  case Magic('X'):</a>
<a name="ln1226">  case Magic('o'):</a>
<a name="ln1227">  case Magic('O'):</a>
<a name="ln1228">  case Magic('w'):</a>
<a name="ln1229">  case Magic('W'):</a>
<a name="ln1230">  case Magic('h'):</a>
<a name="ln1231">  case Magic('H'):</a>
<a name="ln1232">  case Magic('a'):</a>
<a name="ln1233">  case Magic('A'):</a>
<a name="ln1234">  case Magic('l'):</a>
<a name="ln1235">  case Magic('L'):</a>
<a name="ln1236">  case Magic('u'):</a>
<a name="ln1237">  case Magic('U'):</a>
<a name="ln1238">    p = vim_strchr(classchars, no_Magic(c));</a>
<a name="ln1239">    if (p == NULL) {</a>
<a name="ln1240">      if (extra == NFA_ADD_NL) {</a>
<a name="ln1241">        EMSGN(_(e_ill_char_class), c);</a>
<a name="ln1242">        rc_did_emsg = true;</a>
<a name="ln1243">        return FAIL;</a>
<a name="ln1244">      }</a>
<a name="ln1245">      IEMSGN(&quot;INTERNAL: Unknown character class char: %&quot; PRId64, c);</a>
<a name="ln1246">      return FAIL;</a>
<a name="ln1247">    }</a>
<a name="ln1248">    // When '.' is followed by a composing char ignore the dot, so that</a>
<a name="ln1249">    // the composing char is matched here.</a>
<a name="ln1250">    if (c == Magic('.') &amp;&amp; utf_iscomposing(peekchr())) {</a>
<a name="ln1251">      old_regparse = regparse;</a>
<a name="ln1252">      c = getchr();</a>
<a name="ln1253">      goto nfa_do_multibyte;</a>
<a name="ln1254">    }</a>
<a name="ln1255">    EMIT(nfa_classcodes[p - classchars]);</a>
<a name="ln1256">    if (extra == NFA_ADD_NL) {</a>
<a name="ln1257">      EMIT(NFA_NEWL);</a>
<a name="ln1258">      EMIT(NFA_OR);</a>
<a name="ln1259">      regflags |= RF_HASNL;</a>
<a name="ln1260">    }</a>
<a name="ln1261">    break;</a>
<a name="ln1262"> </a>
<a name="ln1263">  case Magic('n'):</a>
<a name="ln1264">    if (reg_string) {</a>
<a name="ln1265">      // In a string &quot;\n&quot; matches a newline character.</a>
<a name="ln1266">      EMIT(NL);</a>
<a name="ln1267">    } else {</a>
<a name="ln1268">      // In buffer text &quot;\n&quot; matches the end of a line.</a>
<a name="ln1269">      EMIT(NFA_NEWL);</a>
<a name="ln1270">      regflags |= RF_HASNL;</a>
<a name="ln1271">    }</a>
<a name="ln1272">    break;</a>
<a name="ln1273"> </a>
<a name="ln1274">  case Magic('('):</a>
<a name="ln1275">    if (nfa_reg(REG_PAREN) == FAIL) {</a>
<a name="ln1276">      return FAIL;                  // cascaded error</a>
<a name="ln1277">    }</a>
<a name="ln1278">    break;</a>
<a name="ln1279"> </a>
<a name="ln1280">  case Magic('|'):</a>
<a name="ln1281">  case Magic('&amp;'):</a>
<a name="ln1282">  case Magic(')'):</a>
<a name="ln1283">    EMSGN(_(e_misplaced), no_Magic(c));  // -V1037</a>
<a name="ln1284">    return FAIL;</a>
<a name="ln1285"> </a>
<a name="ln1286">  case Magic('='):</a>
<a name="ln1287">  case Magic('?'):</a>
<a name="ln1288">  case Magic('+'):</a>
<a name="ln1289">  case Magic('@'):</a>
<a name="ln1290">  case Magic('*'):</a>
<a name="ln1291">  case Magic('{'):</a>
<a name="ln1292">    // these should follow an atom, not form an atom</a>
<a name="ln1293">    EMSGN(_(e_misplaced), no_Magic(c));</a>
<a name="ln1294">    return FAIL;</a>
<a name="ln1295"> </a>
<a name="ln1296">  case Magic('~'):</a>
<a name="ln1297">  {</a>
<a name="ln1298">    char_u      *lp;</a>
<a name="ln1299"> </a>
<a name="ln1300">    // Previous substitute pattern.</a>
<a name="ln1301">    // Generated as &quot;\%(pattern\)&quot;.</a>
<a name="ln1302">    if (reg_prev_sub == NULL) {</a>
<a name="ln1303">      EMSG(_(e_nopresub));</a>
<a name="ln1304">      return FAIL;</a>
<a name="ln1305">    }</a>
<a name="ln1306">    for (lp = reg_prev_sub; *lp != NUL; MB_CPTR_ADV(lp)) {</a>
<a name="ln1307">      EMIT(PTR2CHAR(lp));</a>
<a name="ln1308">      if (lp != reg_prev_sub)</a>
<a name="ln1309">        EMIT(NFA_CONCAT);</a>
<a name="ln1310">    }</a>
<a name="ln1311">    EMIT(NFA_NOPEN);</a>
<a name="ln1312">    break;</a>
<a name="ln1313">  }</a>
<a name="ln1314"> </a>
<a name="ln1315">  case Magic('1'):</a>
<a name="ln1316">  case Magic('2'):</a>
<a name="ln1317">  case Magic('3'):</a>
<a name="ln1318">  case Magic('4'):</a>
<a name="ln1319">  case Magic('5'):</a>
<a name="ln1320">  case Magic('6'):</a>
<a name="ln1321">  case Magic('7'):</a>
<a name="ln1322">  case Magic('8'):</a>
<a name="ln1323">  case Magic('9'):</a>
<a name="ln1324">    {</a>
<a name="ln1325">      int refnum = no_Magic(c) - '1';</a>
<a name="ln1326"> </a>
<a name="ln1327">      if (!seen_endbrace(refnum + 1)) {</a>
<a name="ln1328">          return FAIL;</a>
<a name="ln1329">      }</a>
<a name="ln1330">      EMIT(NFA_BACKREF1 + refnum);</a>
<a name="ln1331">      rex.nfa_has_backref = true;</a>
<a name="ln1332">    }</a>
<a name="ln1333">    break;</a>
<a name="ln1334"> </a>
<a name="ln1335">  case Magic('z'):</a>
<a name="ln1336">    c = no_Magic(getchr());</a>
<a name="ln1337">    switch (c) {</a>
<a name="ln1338">    case 's':</a>
<a name="ln1339">      EMIT(NFA_ZSTART);</a>
<a name="ln1340">      if (!re_mult_next(&quot;\\zs&quot;)) {</a>
<a name="ln1341">        return false;</a>
<a name="ln1342">      }</a>
<a name="ln1343">      break;</a>
<a name="ln1344">    case 'e':</a>
<a name="ln1345">      EMIT(NFA_ZEND);</a>
<a name="ln1346">      rex.nfa_has_zend = true;</a>
<a name="ln1347">      if (!re_mult_next(&quot;\\zs&quot;)) {</a>
<a name="ln1348">        return false;</a>
<a name="ln1349">      }</a>
<a name="ln1350">      break;</a>
<a name="ln1351">    case '1':</a>
<a name="ln1352">    case '2':</a>
<a name="ln1353">    case '3':</a>
<a name="ln1354">    case '4':</a>
<a name="ln1355">    case '5':</a>
<a name="ln1356">    case '6':</a>
<a name="ln1357">    case '7':</a>
<a name="ln1358">    case '8':</a>
<a name="ln1359">    case '9':</a>
<a name="ln1360">      // \z1...\z9</a>
<a name="ln1361">      if ((reg_do_extmatch &amp; REX_USE) == 0) {</a>
<a name="ln1362">        EMSG_RET_FAIL(_(e_z1_not_allowed));</a>
<a name="ln1363">      }</a>
<a name="ln1364">      EMIT(NFA_ZREF1 + (no_Magic(c) - '1'));</a>
<a name="ln1365">      // No need to set rex.nfa_has_backref, the sub-matches don't</a>
<a name="ln1366">      // change when \z1 .. \z9 matches or not.</a>
<a name="ln1367">      re_has_z = REX_USE;</a>
<a name="ln1368">      break;</a>
<a name="ln1369">    case '(':</a>
<a name="ln1370">      // \z(</a>
<a name="ln1371">      if (reg_do_extmatch != REX_SET) {</a>
<a name="ln1372">        EMSG_RET_FAIL(_(e_z_not_allowed));</a>
<a name="ln1373">      }</a>
<a name="ln1374">      if (nfa_reg(REG_ZPAREN) == FAIL) {</a>
<a name="ln1375">        return FAIL;                        // cascaded error</a>
<a name="ln1376">      }</a>
<a name="ln1377">      re_has_z = REX_SET;</a>
<a name="ln1378">      break;</a>
<a name="ln1379">    default:</a>
<a name="ln1380">      emsgf(_(&quot;E867: (NFA) Unknown operator '\\z%c'&quot;),</a>
<a name="ln1381">            no_Magic(c));</a>
<a name="ln1382">      return FAIL;</a>
<a name="ln1383">    }</a>
<a name="ln1384">    break;</a>
<a name="ln1385"> </a>
<a name="ln1386">  case Magic('%'):</a>
<a name="ln1387">    c = no_Magic(getchr());</a>
<a name="ln1388">    switch (c) {</a>
<a name="ln1389">    /* () without a back reference */</a>
<a name="ln1390">    case '(':</a>
<a name="ln1391">      if (nfa_reg(REG_NPAREN) == FAIL)</a>
<a name="ln1392">        return FAIL;</a>
<a name="ln1393">      EMIT(NFA_NOPEN);</a>
<a name="ln1394">      break;</a>
<a name="ln1395"> </a>
<a name="ln1396">    case 'd':               /* %d123 decimal */</a>
<a name="ln1397">    case 'o':               /* %o123 octal */</a>
<a name="ln1398">    case 'x':               /* %xab hex 2 */</a>
<a name="ln1399">    case 'u':               /* %uabcd hex 4 */</a>
<a name="ln1400">    case 'U':               /* %U1234abcd hex 8 */</a>
<a name="ln1401">    {</a>
<a name="ln1402">      int64_t nr;</a>
<a name="ln1403"> </a>
<a name="ln1404">      switch (c) {</a>
<a name="ln1405">      case 'd': nr = getdecchrs(); break;</a>
<a name="ln1406">      case 'o': nr = getoctchrs(); break;</a>
<a name="ln1407">      case 'x': nr = gethexchrs(2); break;</a>
<a name="ln1408">      case 'u': nr = gethexchrs(4); break;</a>
<a name="ln1409">      case 'U': nr = gethexchrs(8); break;</a>
<a name="ln1410">      default:  nr = -1; break;</a>
<a name="ln1411">      }</a>
<a name="ln1412"> </a>
<a name="ln1413">      if (nr &lt; 0 || nr &gt; INT_MAX) {</a>
<a name="ln1414">        EMSG2_RET_FAIL(_(&quot;E678: Invalid character after %s%%[dxouU]&quot;),</a>
<a name="ln1415">                       reg_magic == MAGIC_ALL);</a>
<a name="ln1416">      }</a>
<a name="ln1417">      // A NUL is stored in the text as NL</a>
<a name="ln1418">      // TODO(vim): what if a composing character follows?</a>
<a name="ln1419">      EMIT(nr == 0 ? 0x0a : nr);</a>
<a name="ln1420">    }</a>
<a name="ln1421">    break;</a>
<a name="ln1422"> </a>
<a name="ln1423">    /* Catch \%^ and \%$ regardless of where they appear in the</a>
<a name="ln1424">     * pattern -- regardless of whether or not it makes sense. */</a>
<a name="ln1425">    case '^':</a>
<a name="ln1426">      EMIT(NFA_BOF);</a>
<a name="ln1427">      break;</a>
<a name="ln1428"> </a>
<a name="ln1429">    case '$':</a>
<a name="ln1430">      EMIT(NFA_EOF);</a>
<a name="ln1431">      break;</a>
<a name="ln1432"> </a>
<a name="ln1433">    case '#':</a>
<a name="ln1434">      EMIT(NFA_CURSOR);</a>
<a name="ln1435">      break;</a>
<a name="ln1436"> </a>
<a name="ln1437">    case 'V':</a>
<a name="ln1438">      EMIT(NFA_VISUAL);</a>
<a name="ln1439">      break;</a>
<a name="ln1440"> </a>
<a name="ln1441">    case 'C':</a>
<a name="ln1442">      EMIT(NFA_ANY_COMPOSING);</a>
<a name="ln1443">      break;</a>
<a name="ln1444"> </a>
<a name="ln1445">    case '[':</a>
<a name="ln1446">    {</a>
<a name="ln1447">      int n;</a>
<a name="ln1448"> </a>
<a name="ln1449">      /* \%[abc] */</a>
<a name="ln1450">      for (n = 0; (c = peekchr()) != ']'; ++n) {</a>
<a name="ln1451">        if (c == NUL)</a>
<a name="ln1452">          EMSG2_RET_FAIL(_(e_missing_sb),</a>
<a name="ln1453">              reg_magic == MAGIC_ALL);</a>
<a name="ln1454">        /* recursive call! */</a>
<a name="ln1455">        if (nfa_regatom() == FAIL)</a>
<a name="ln1456">          return FAIL;</a>
<a name="ln1457">      }</a>
<a name="ln1458">      getchr();                    /* get the ] */</a>
<a name="ln1459">      if (n == 0)</a>
<a name="ln1460">        EMSG2_RET_FAIL(_(e_empty_sb),</a>
<a name="ln1461">            reg_magic == MAGIC_ALL);</a>
<a name="ln1462">      EMIT(NFA_OPT_CHARS);</a>
<a name="ln1463">      EMIT(n);</a>
<a name="ln1464"> </a>
<a name="ln1465">      /* Emit as &quot;\%(\%[abc]\)&quot; to be able to handle</a>
<a name="ln1466">       * &quot;\%[abc]*&quot; which would cause the empty string to be</a>
<a name="ln1467">       * matched an unlimited number of times. NFA_NOPEN is</a>
<a name="ln1468">       * added only once at a position, while NFA_SPLIT is</a>
<a name="ln1469">       * added multiple times.  This is more efficient than</a>
<a name="ln1470">       * not allowing NFA_SPLIT multiple times, it is used</a>
<a name="ln1471">       * a lot. */</a>
<a name="ln1472">      EMIT(NFA_NOPEN);</a>
<a name="ln1473">      break;</a>
<a name="ln1474">    }</a>
<a name="ln1475"> </a>
<a name="ln1476">    default:</a>
<a name="ln1477">    {</a>
<a name="ln1478">      int64_t n = 0;</a>
<a name="ln1479">      const int cmp = c;</a>
<a name="ln1480"> </a>
<a name="ln1481">      if (c == '&lt;' || c == '&gt;')</a>
<a name="ln1482">        c = getchr();</a>
<a name="ln1483">      while (ascii_isdigit(c)) {</a>
<a name="ln1484">        if (n &gt; (INT32_MAX - (c - '0')) / 10) {</a>
<a name="ln1485">          // overflow.</a>
<a name="ln1486">          EMSG(_(e_value_too_large));</a>
<a name="ln1487">          return FAIL;</a>
<a name="ln1488">        }</a>
<a name="ln1489">        n = n * 10 + (c - '0');</a>
<a name="ln1490">        c = getchr();</a>
<a name="ln1491">      }</a>
<a name="ln1492">      if (c == 'l' || c == 'c' || c == 'v') {</a>
<a name="ln1493">        int32_t limit = INT32_MAX;</a>
<a name="ln1494"> </a>
<a name="ln1495">        if (c == 'l') {</a>
<a name="ln1496">          // \%{n}l  \%{n}&lt;l  \%{n}&gt;l</a>
<a name="ln1497">          EMIT(cmp == '&lt;' ? NFA_LNUM_LT :</a>
<a name="ln1498">               cmp == '&gt;' ? NFA_LNUM_GT : NFA_LNUM);</a>
<a name="ln1499">          if (save_prev_at_start) {</a>
<a name="ln1500">            at_start = true;</a>
<a name="ln1501">          }</a>
<a name="ln1502">        } else if (c == 'c') {</a>
<a name="ln1503">          // \%{n}c  \%{n}&lt;c  \%{n}&gt;c</a>
<a name="ln1504">          EMIT(cmp == '&lt;' ? NFA_COL_LT :</a>
<a name="ln1505">               cmp == '&gt;' ? NFA_COL_GT : NFA_COL);</a>
<a name="ln1506">        } else {</a>
<a name="ln1507">          // \%{n}v  \%{n}&lt;v  \%{n}&gt;v</a>
<a name="ln1508">          EMIT(cmp == '&lt;' ? NFA_VCOL_LT :</a>
<a name="ln1509">               cmp == '&gt;' ? NFA_VCOL_GT : NFA_VCOL);</a>
<a name="ln1510">          limit = INT32_MAX / MB_MAXBYTES;</a>
<a name="ln1511">        }</a>
<a name="ln1512">        if (n &gt;= limit) {</a>
<a name="ln1513">          EMSG(_(e_value_too_large));</a>
<a name="ln1514">          return FAIL;</a>
<a name="ln1515">        }</a>
<a name="ln1516">        EMIT((int)n);</a>
<a name="ln1517">        break;</a>
<a name="ln1518">      } else if (c == '\'' &amp;&amp; n == 0) {</a>
<a name="ln1519">        /* \%'m  \%&lt;'m  \%&gt;'m  */</a>
<a name="ln1520">        EMIT(cmp == '&lt;' ? NFA_MARK_LT :</a>
<a name="ln1521">            cmp == '&gt;' ? NFA_MARK_GT : NFA_MARK);</a>
<a name="ln1522">        EMIT(getchr());</a>
<a name="ln1523">        break;</a>
<a name="ln1524">      }</a>
<a name="ln1525">    }</a>
<a name="ln1526">      emsgf(_(&quot;E867: (NFA) Unknown operator '\\%%%c'&quot;),</a>
<a name="ln1527">            no_Magic(c));</a>
<a name="ln1528">      return FAIL;</a>
<a name="ln1529">    }</a>
<a name="ln1530">    break;</a>
<a name="ln1531"> </a>
<a name="ln1532">  case Magic('['):</a>
<a name="ln1533">collection:</a>
<a name="ln1534">    /*</a>
<a name="ln1535">     * [abc]  uses NFA_START_COLL - NFA_END_COLL</a>
<a name="ln1536">     * [^abc] uses NFA_START_NEG_COLL - NFA_END_NEG_COLL</a>
<a name="ln1537">     * Each character is produced as a regular state, using</a>
<a name="ln1538">     * NFA_CONCAT to bind them together.</a>
<a name="ln1539">     * Besides normal characters there can be:</a>
<a name="ln1540">     * - character classes  NFA_CLASS_*</a>
<a name="ln1541">     * - ranges, two characters followed by NFA_RANGE.</a>
<a name="ln1542">     */</a>
<a name="ln1543"> </a>
<a name="ln1544">    p = regparse;</a>
<a name="ln1545">    endp = skip_anyof(p);</a>
<a name="ln1546">    if (*endp == ']') {</a>
<a name="ln1547">      /*</a>
<a name="ln1548">       * Try to reverse engineer character classes. For example,</a>
<a name="ln1549">       * recognize that [0-9] stands for \d and [A-Za-z_] for \h,</a>
<a name="ln1550">       * and perform the necessary substitutions in the NFA.</a>
<a name="ln1551">       */</a>
<a name="ln1552">      int result = nfa_recognize_char_class(regparse, endp,</a>
<a name="ln1553">                                            extra == NFA_ADD_NL);</a>
<a name="ln1554">      if (result != FAIL) {</a>
<a name="ln1555">        if (result &gt;= NFA_FIRST_NL &amp;&amp; result &lt;= NFA_LAST_NL) {</a>
<a name="ln1556">          EMIT(result - NFA_ADD_NL);</a>
<a name="ln1557">          EMIT(NFA_NEWL);</a>
<a name="ln1558">          EMIT(NFA_OR);</a>
<a name="ln1559">        } else</a>
<a name="ln1560">          EMIT(result);</a>
<a name="ln1561">        regparse = endp;</a>
<a name="ln1562">        MB_PTR_ADV(regparse);</a>
<a name="ln1563">        return OK;</a>
<a name="ln1564">      }</a>
<a name="ln1565">      /*</a>
<a name="ln1566">       * Failed to recognize a character class. Use the simple</a>
<a name="ln1567">       * version that turns [abc] into 'a' OR 'b' OR 'c'</a>
<a name="ln1568">       */</a>
<a name="ln1569">      startc = endc = oldstartc = -1;</a>
<a name="ln1570">      negated = false;</a>
<a name="ln1571">      if (*regparse == '^') {                           // negated range</a>
<a name="ln1572">        negated = true;</a>
<a name="ln1573">        MB_PTR_ADV(regparse);</a>
<a name="ln1574">        EMIT(NFA_START_NEG_COLL);</a>
<a name="ln1575">      } else</a>
<a name="ln1576">        EMIT(NFA_START_COLL);</a>
<a name="ln1577">      if (*regparse == '-') {</a>
<a name="ln1578">        startc = '-';</a>
<a name="ln1579">        EMIT(startc);</a>
<a name="ln1580">        EMIT(NFA_CONCAT);</a>
<a name="ln1581">        MB_PTR_ADV(regparse);</a>
<a name="ln1582">      }</a>
<a name="ln1583">      // Emit the OR branches for each character in the []</a>
<a name="ln1584">      emit_range = false;</a>
<a name="ln1585">      while (regparse &lt; endp) {</a>
<a name="ln1586">        oldstartc = startc;</a>
<a name="ln1587">        startc = -1;</a>
<a name="ln1588">        got_coll_char = false;</a>
<a name="ln1589">        if (*regparse == '[') {</a>
<a name="ln1590">          /* Check for [: :], [= =], [. .] */</a>
<a name="ln1591">          equiclass = collclass = 0;</a>
<a name="ln1592">          charclass = get_char_class(&amp;regparse);</a>
<a name="ln1593">          if (charclass == CLASS_NONE) {</a>
<a name="ln1594">            equiclass = get_equi_class(&amp;regparse);</a>
<a name="ln1595">            if (equiclass == 0)</a>
<a name="ln1596">              collclass = get_coll_element(&amp;regparse);</a>
<a name="ln1597">          }</a>
<a name="ln1598"> </a>
<a name="ln1599">          /* Character class like [:alpha:]  */</a>
<a name="ln1600">          if (charclass != CLASS_NONE) {</a>
<a name="ln1601">            switch (charclass) {</a>
<a name="ln1602">            case CLASS_ALNUM:</a>
<a name="ln1603">              EMIT(NFA_CLASS_ALNUM);</a>
<a name="ln1604">              break;</a>
<a name="ln1605">            case CLASS_ALPHA:</a>
<a name="ln1606">              EMIT(NFA_CLASS_ALPHA);</a>
<a name="ln1607">              break;</a>
<a name="ln1608">            case CLASS_BLANK:</a>
<a name="ln1609">              EMIT(NFA_CLASS_BLANK);</a>
<a name="ln1610">              break;</a>
<a name="ln1611">            case CLASS_CNTRL:</a>
<a name="ln1612">              EMIT(NFA_CLASS_CNTRL);</a>
<a name="ln1613">              break;</a>
<a name="ln1614">            case CLASS_DIGIT:</a>
<a name="ln1615">              EMIT(NFA_CLASS_DIGIT);</a>
<a name="ln1616">              break;</a>
<a name="ln1617">            case CLASS_GRAPH:</a>
<a name="ln1618">              EMIT(NFA_CLASS_GRAPH);</a>
<a name="ln1619">              break;</a>
<a name="ln1620">            case CLASS_LOWER:</a>
<a name="ln1621">              EMIT(NFA_CLASS_LOWER);</a>
<a name="ln1622">              break;</a>
<a name="ln1623">            case CLASS_PRINT:</a>
<a name="ln1624">              EMIT(NFA_CLASS_PRINT);</a>
<a name="ln1625">              break;</a>
<a name="ln1626">            case CLASS_PUNCT:</a>
<a name="ln1627">              EMIT(NFA_CLASS_PUNCT);</a>
<a name="ln1628">              break;</a>
<a name="ln1629">            case CLASS_SPACE:</a>
<a name="ln1630">              EMIT(NFA_CLASS_SPACE);</a>
<a name="ln1631">              break;</a>
<a name="ln1632">            case CLASS_UPPER:</a>
<a name="ln1633">              EMIT(NFA_CLASS_UPPER);</a>
<a name="ln1634">              break;</a>
<a name="ln1635">            case CLASS_XDIGIT:</a>
<a name="ln1636">              EMIT(NFA_CLASS_XDIGIT);</a>
<a name="ln1637">              break;</a>
<a name="ln1638">            case CLASS_TAB:</a>
<a name="ln1639">              EMIT(NFA_CLASS_TAB);</a>
<a name="ln1640">              break;</a>
<a name="ln1641">            case CLASS_RETURN:</a>
<a name="ln1642">              EMIT(NFA_CLASS_RETURN);</a>
<a name="ln1643">              break;</a>
<a name="ln1644">            case CLASS_BACKSPACE:</a>
<a name="ln1645">              EMIT(NFA_CLASS_BACKSPACE);</a>
<a name="ln1646">              break;</a>
<a name="ln1647">            case CLASS_ESCAPE:</a>
<a name="ln1648">              EMIT(NFA_CLASS_ESCAPE);</a>
<a name="ln1649">              break;</a>
<a name="ln1650">            case CLASS_IDENT:</a>
<a name="ln1651">              EMIT(NFA_CLASS_IDENT);</a>
<a name="ln1652">              break;</a>
<a name="ln1653">            case CLASS_KEYWORD:</a>
<a name="ln1654">              EMIT(NFA_CLASS_KEYWORD);</a>
<a name="ln1655">              break;</a>
<a name="ln1656">            case CLASS_FNAME:</a>
<a name="ln1657">              EMIT(NFA_CLASS_FNAME);</a>
<a name="ln1658">              break;</a>
<a name="ln1659">            }</a>
<a name="ln1660">            EMIT(NFA_CONCAT);</a>
<a name="ln1661">            continue;</a>
<a name="ln1662">          }</a>
<a name="ln1663">          /* Try equivalence class [=a=] and the like */</a>
<a name="ln1664">          if (equiclass != 0) {</a>
<a name="ln1665">            nfa_emit_equi_class(equiclass);</a>
<a name="ln1666">            continue;</a>
<a name="ln1667">          }</a>
<a name="ln1668">          /* Try collating class like [. .]  */</a>
<a name="ln1669">          if (collclass != 0) {</a>
<a name="ln1670">            startc = collclass;                  /* allow [.a.]-x as a range */</a>
<a name="ln1671">            /* Will emit the proper atom at the end of the</a>
<a name="ln1672">             * while loop. */</a>
<a name="ln1673">          }</a>
<a name="ln1674">        }</a>
<a name="ln1675">        /* Try a range like 'a-x' or '\t-z'. Also allows '-' as a</a>
<a name="ln1676">         * start character. */</a>
<a name="ln1677">        if (*regparse == '-' &amp;&amp; oldstartc != -1) {</a>
<a name="ln1678">          emit_range = true;</a>
<a name="ln1679">          startc = oldstartc;</a>
<a name="ln1680">          MB_PTR_ADV(regparse);</a>
<a name="ln1681">          continue;                         // reading the end of the range</a>
<a name="ln1682">        }</a>
<a name="ln1683"> </a>
<a name="ln1684">        /* Now handle simple and escaped characters.</a>
<a name="ln1685">         * Only &quot;\]&quot;, &quot;\^&quot;, &quot;\]&quot; and &quot;\\&quot; are special in Vi.  Vim</a>
<a name="ln1686">         * accepts &quot;\t&quot;, &quot;\e&quot;, etc., but only when the 'l' flag in</a>
<a name="ln1687">         * 'cpoptions' is not included.</a>
<a name="ln1688">         */</a>
<a name="ln1689">        if (*regparse == '\\'</a>
<a name="ln1690">            &amp;&amp; regparse + 1 &lt;= endp</a>
<a name="ln1691">            &amp;&amp; (vim_strchr(REGEXP_INRANGE, regparse[1]) != NULL</a>
<a name="ln1692">                || (!reg_cpo_lit</a>
<a name="ln1693">                    &amp;&amp; vim_strchr(REGEXP_ABBR, regparse[1])</a>
<a name="ln1694">                    != NULL)</a>
<a name="ln1695">                )</a>
<a name="ln1696">            ) {</a>
<a name="ln1697">          MB_PTR_ADV(regparse);</a>
<a name="ln1698"> </a>
<a name="ln1699">          if (*regparse == 'n') {</a>
<a name="ln1700">            startc = (reg_string || emit_range || regparse[1] == '-')</a>
<a name="ln1701">              ? NL : NFA_NEWL;</a>
<a name="ln1702">          } else if  (*regparse == 'd'</a>
<a name="ln1703">                      || *regparse == 'o'</a>
<a name="ln1704">                      || *regparse == 'x'</a>
<a name="ln1705">                      || *regparse == 'u'</a>
<a name="ln1706">                      || *regparse == 'U'</a>
<a name="ln1707">                      ) {</a>
<a name="ln1708">            // TODO(RE): This needs more testing</a>
<a name="ln1709">            startc = coll_get_char();</a>
<a name="ln1710">            got_coll_char = true;</a>
<a name="ln1711">            MB_PTR_BACK(old_regparse, regparse);</a>
<a name="ln1712">          } else {</a>
<a name="ln1713">            /* \r,\t,\e,\b */</a>
<a name="ln1714">            startc = backslash_trans(*regparse);</a>
<a name="ln1715">          }</a>
<a name="ln1716">        }</a>
<a name="ln1717"> </a>
<a name="ln1718">        /* Normal printable char */</a>
<a name="ln1719">        if (startc == -1)</a>
<a name="ln1720">          startc = PTR2CHAR(regparse);</a>
<a name="ln1721"> </a>
<a name="ln1722">        /* Previous char was '-', so this char is end of range. */</a>
<a name="ln1723">        if (emit_range) {</a>
<a name="ln1724">          endc = startc;</a>
<a name="ln1725">          startc = oldstartc;</a>
<a name="ln1726">          if (startc &gt; endc) {</a>
<a name="ln1727">            EMSG_RET_FAIL(_(e_reverse_range));</a>
<a name="ln1728">          }</a>
<a name="ln1729"> </a>
<a name="ln1730">          if (endc &gt; startc + 2) {</a>
<a name="ln1731">            /* Emit a range instead of the sequence of</a>
<a name="ln1732">             * individual characters. */</a>
<a name="ln1733">            if (startc == 0)</a>
<a name="ln1734">              /* \x00 is translated to \x0a, start at \x01. */</a>
<a name="ln1735">              EMIT(1);</a>
<a name="ln1736">            else</a>
<a name="ln1737">              --post_ptr;                   /* remove NFA_CONCAT */</a>
<a name="ln1738">            EMIT(endc);</a>
<a name="ln1739">            EMIT(NFA_RANGE);</a>
<a name="ln1740">            EMIT(NFA_CONCAT);</a>
<a name="ln1741">          } else if ((*mb_char2len)(startc) &gt; 1</a>
<a name="ln1742">                     || (*mb_char2len)(endc) &gt; 1) {</a>
<a name="ln1743">            // Emit the characters in the range.</a>
<a name="ln1744">            // &quot;startc&quot; was already emitted, so skip it.</a>
<a name="ln1745">            for (c = startc + 1; c &lt;= endc; c++) {</a>
<a name="ln1746">              EMIT(c);</a>
<a name="ln1747">              EMIT(NFA_CONCAT);</a>
<a name="ln1748">            }</a>
<a name="ln1749">          } else {</a>
<a name="ln1750">            /* Emit the range. &quot;startc&quot; was already emitted, so</a>
<a name="ln1751">             * skip it. */</a>
<a name="ln1752">            for (c = startc + 1; c &lt;= endc; c++) {</a>
<a name="ln1753">              EMIT(c);</a>
<a name="ln1754">              EMIT(NFA_CONCAT);</a>
<a name="ln1755">            }</a>
<a name="ln1756">          }</a>
<a name="ln1757">          emit_range = false;</a>
<a name="ln1758">          startc = -1;</a>
<a name="ln1759">        } else {</a>
<a name="ln1760">          /* This char (startc) is not part of a range. Just</a>
<a name="ln1761">           * emit it.</a>
<a name="ln1762">           * Normally, simply emit startc. But if we get char</a>
<a name="ln1763">           * code=0 from a collating char, then replace it with</a>
<a name="ln1764">           * 0x0a.</a>
<a name="ln1765">           * This is needed to completely mimic the behaviour of</a>
<a name="ln1766">           * the backtracking engine. */</a>
<a name="ln1767">          if (startc == NFA_NEWL) {</a>
<a name="ln1768">            /* Line break can't be matched as part of the</a>
<a name="ln1769">             * collection, add an OR below. But not for negated</a>
<a name="ln1770">             * range. */</a>
<a name="ln1771">            if (!negated)</a>
<a name="ln1772">              extra = NFA_ADD_NL;</a>
<a name="ln1773">          } else {</a>
<a name="ln1774">            if (got_coll_char == true &amp;&amp; startc == 0) {</a>
<a name="ln1775">              EMIT(0x0a);</a>
<a name="ln1776">            } else {</a>
<a name="ln1777">              EMIT(startc);</a>
<a name="ln1778">            }</a>
<a name="ln1779">            EMIT(NFA_CONCAT);</a>
<a name="ln1780">          }</a>
<a name="ln1781">        }</a>
<a name="ln1782"> </a>
<a name="ln1783">        MB_PTR_ADV(regparse);</a>
<a name="ln1784">      }           // while (p &lt; endp)</a>
<a name="ln1785"> </a>
<a name="ln1786">      MB_PTR_BACK(old_regparse, regparse);</a>
<a name="ln1787">      if (*regparse == '-') {               // if last, '-' is just a char</a>
<a name="ln1788">        EMIT('-');</a>
<a name="ln1789">        EMIT(NFA_CONCAT);</a>
<a name="ln1790">      }</a>
<a name="ln1791"> </a>
<a name="ln1792">      /* skip the trailing ] */</a>
<a name="ln1793">      regparse = endp;</a>
<a name="ln1794">      MB_PTR_ADV(regparse);</a>
<a name="ln1795"> </a>
<a name="ln1796">      // Mark end of the collection.</a>
<a name="ln1797">      if (negated == true) {</a>
<a name="ln1798">        EMIT(NFA_END_NEG_COLL);</a>
<a name="ln1799">      } else {</a>
<a name="ln1800">        EMIT(NFA_END_COLL);</a>
<a name="ln1801">      }</a>
<a name="ln1802"> </a>
<a name="ln1803">      // \_[] also matches \n but it's not negated</a>
<a name="ln1804">      if (extra == NFA_ADD_NL) {</a>
<a name="ln1805">        EMIT(reg_string ? NL : NFA_NEWL);</a>
<a name="ln1806">        EMIT(NFA_OR);</a>
<a name="ln1807">      }</a>
<a name="ln1808"> </a>
<a name="ln1809">      return OK;</a>
<a name="ln1810">    }         /* if exists closing ] */</a>
<a name="ln1811"> </a>
<a name="ln1812">    if (reg_strict)</a>
<a name="ln1813">      EMSG_RET_FAIL(_(e_missingbracket));</a>
<a name="ln1814">    FALLTHROUGH;</a>
<a name="ln1815"> </a>
<a name="ln1816">  default:</a>
<a name="ln1817">  {</a>
<a name="ln1818">    int plen;</a>
<a name="ln1819"> </a>
<a name="ln1820">nfa_do_multibyte:</a>
<a name="ln1821">    // plen is length of current char with composing chars</a>
<a name="ln1822">    if ((*mb_char2len)(c) != (plen = utfc_ptr2len(old_regparse))</a>
<a name="ln1823">        || utf_iscomposing(c)) {</a>
<a name="ln1824">      int i = 0;</a>
<a name="ln1825"> </a>
<a name="ln1826">      /* A base character plus composing characters, or just one</a>
<a name="ln1827">       * or more composing characters.</a>
<a name="ln1828">       * This requires creating a separate atom as if enclosing</a>
<a name="ln1829">       * the characters in (), where NFA_COMPOSING is the ( and</a>
<a name="ln1830">       * NFA_END_COMPOSING is the ). Note that right now we are</a>
<a name="ln1831">       * building the postfix form, not the NFA itself;</a>
<a name="ln1832">       * a composing char could be: a, b, c, NFA_COMPOSING</a>
<a name="ln1833">       * where 'b' and 'c' are chars with codes &gt; 256. */</a>
<a name="ln1834">      for (;; ) {</a>
<a name="ln1835">        EMIT(c);</a>
<a name="ln1836">        if (i &gt; 0)</a>
<a name="ln1837">          EMIT(NFA_CONCAT);</a>
<a name="ln1838">        if ((i += utf_char2len(c)) &gt;= plen)</a>
<a name="ln1839">          break;</a>
<a name="ln1840">        c = utf_ptr2char(old_regparse + i);</a>
<a name="ln1841">      }</a>
<a name="ln1842">      EMIT(NFA_COMPOSING);</a>
<a name="ln1843">      regparse = old_regparse + plen;</a>
<a name="ln1844">    } else {</a>
<a name="ln1845">      c = no_Magic(c);</a>
<a name="ln1846">      EMIT(c);</a>
<a name="ln1847">    }</a>
<a name="ln1848">    return OK;</a>
<a name="ln1849">  }</a>
<a name="ln1850">  }</a>
<a name="ln1851"> </a>
<a name="ln1852">  return OK;</a>
<a name="ln1853">}</a>
<a name="ln1854"> </a>
<a name="ln1855">/*</a>
<a name="ln1856"> * Parse something followed by possible [*+=].</a>
<a name="ln1857"> *</a>
<a name="ln1858"> * A piece is an atom, possibly followed by a multi, an indication of how many</a>
<a name="ln1859"> * times the atom can be matched.  Example: &quot;a*&quot; matches any sequence of &quot;a&quot;</a>
<a name="ln1860"> * characters: &quot;&quot;, &quot;a&quot;, &quot;aa&quot;, etc.</a>
<a name="ln1861"> *</a>
<a name="ln1862"> * piece   ::=	    atom</a>
<a name="ln1863"> *	or  atom  multi</a>
<a name="ln1864"> */</a>
<a name="ln1865">static int nfa_regpiece(void)</a>
<a name="ln1866">{</a>
<a name="ln1867">  int i;</a>
<a name="ln1868">  int op;</a>
<a name="ln1869">  int ret;</a>
<a name="ln1870">  long minval, maxval;</a>
<a name="ln1871">  bool greedy = true;  // Braces are prefixed with '-' ?</a>
<a name="ln1872">  parse_state_T old_state;</a>
<a name="ln1873">  parse_state_T new_state;</a>
<a name="ln1874">  int64_t c2;</a>
<a name="ln1875">  int old_post_pos;</a>
<a name="ln1876">  int my_post_start;</a>
<a name="ln1877">  int quest;</a>
<a name="ln1878"> </a>
<a name="ln1879">  /* Save the current parse state, so that we can use it if &lt;atom&gt;{m,n} is</a>
<a name="ln1880">   * next. */</a>
<a name="ln1881">  save_parse_state(&amp;old_state);</a>
<a name="ln1882"> </a>
<a name="ln1883">  /* store current pos in the postfix form, for \{m,n} involving 0s */</a>
<a name="ln1884">  my_post_start = (int)(post_ptr - post_start);</a>
<a name="ln1885"> </a>
<a name="ln1886">  ret = nfa_regatom();</a>
<a name="ln1887">  if (ret == FAIL)</a>
<a name="ln1888">    return FAIL;            /* cascaded error */</a>
<a name="ln1889"> </a>
<a name="ln1890">  op = peekchr();</a>
<a name="ln1891">  if (re_multi_type(op) == NOT_MULTI)</a>
<a name="ln1892">    return OK;</a>
<a name="ln1893"> </a>
<a name="ln1894">  skipchr();</a>
<a name="ln1895">  switch (op) {</a>
<a name="ln1896">  case Magic('*'):</a>
<a name="ln1897">    EMIT(NFA_STAR);</a>
<a name="ln1898">    break;</a>
<a name="ln1899"> </a>
<a name="ln1900">  case Magic('+'):</a>
<a name="ln1901">    /*</a>
<a name="ln1902">     * Trick: Normally, (a*)\+ would match the whole input &quot;aaa&quot;.  The</a>
<a name="ln1903">     * first and only submatch would be &quot;aaa&quot;. But the backtracking</a>
<a name="ln1904">     * engine interprets the plus as &quot;try matching one more time&quot;, and</a>
<a name="ln1905">     * a* matches a second time at the end of the input, the empty</a>
<a name="ln1906">     * string.</a>
<a name="ln1907">     * The submatch will be the empty string.</a>
<a name="ln1908">     *</a>
<a name="ln1909">     * In order to be consistent with the old engine, we replace</a>
<a name="ln1910">     * &lt;atom&gt;+ with &lt;atom&gt;&lt;atom&gt;*</a>
<a name="ln1911">     */</a>
<a name="ln1912">    restore_parse_state(&amp;old_state);</a>
<a name="ln1913">    curchr = -1;</a>
<a name="ln1914">    if (nfa_regatom() == FAIL)</a>
<a name="ln1915">      return FAIL;</a>
<a name="ln1916">    EMIT(NFA_STAR);</a>
<a name="ln1917">    EMIT(NFA_CONCAT);</a>
<a name="ln1918">    skipchr();                  /* skip the \+	*/</a>
<a name="ln1919">    break;</a>
<a name="ln1920"> </a>
<a name="ln1921">  case Magic('@'):</a>
<a name="ln1922">    c2 = getdecchrs();</a>
<a name="ln1923">    op = no_Magic(getchr());</a>
<a name="ln1924">    i = 0;</a>
<a name="ln1925">    switch(op) {</a>
<a name="ln1926">    case '=':</a>
<a name="ln1927">      /* \@= */</a>
<a name="ln1928">      i = NFA_PREV_ATOM_NO_WIDTH;</a>
<a name="ln1929">      break;</a>
<a name="ln1930">    case '!':</a>
<a name="ln1931">      /* \@! */</a>
<a name="ln1932">      i = NFA_PREV_ATOM_NO_WIDTH_NEG;</a>
<a name="ln1933">      break;</a>
<a name="ln1934">    case '&lt;':</a>
<a name="ln1935">      op = no_Magic(getchr());</a>
<a name="ln1936">      if (op == '=')</a>
<a name="ln1937">        /* \@&lt;= */</a>
<a name="ln1938">        i = NFA_PREV_ATOM_JUST_BEFORE;</a>
<a name="ln1939">      else if (op == '!')</a>
<a name="ln1940">        /* \@&lt;! */</a>
<a name="ln1941">        i = NFA_PREV_ATOM_JUST_BEFORE_NEG;</a>
<a name="ln1942">      break;</a>
<a name="ln1943">    case '&gt;':</a>
<a name="ln1944">      /* \@&gt;  */</a>
<a name="ln1945">      i = NFA_PREV_ATOM_LIKE_PATTERN;</a>
<a name="ln1946">      break;</a>
<a name="ln1947">    }</a>
<a name="ln1948">    if (i == 0) {</a>
<a name="ln1949">      emsgf(_(&quot;E869: (NFA) Unknown operator '\\@%c'&quot;), op);</a>
<a name="ln1950">      return FAIL;</a>
<a name="ln1951">    }</a>
<a name="ln1952">    EMIT(i);</a>
<a name="ln1953">    if (i == NFA_PREV_ATOM_JUST_BEFORE</a>
<a name="ln1954">        || i == NFA_PREV_ATOM_JUST_BEFORE_NEG)</a>
<a name="ln1955">      EMIT(c2);</a>
<a name="ln1956">    break;</a>
<a name="ln1957"> </a>
<a name="ln1958">  case Magic('?'):</a>
<a name="ln1959">  case Magic('='):</a>
<a name="ln1960">    EMIT(NFA_QUEST);</a>
<a name="ln1961">    break;</a>
<a name="ln1962"> </a>
<a name="ln1963">  case Magic('{'):</a>
<a name="ln1964">    /* a{2,5} will expand to 'aaa?a?a?'</a>
<a name="ln1965">     * a{-1,3} will expand to 'aa??a??', where ?? is the nongreedy</a>
<a name="ln1966">     * version of '?'</a>
<a name="ln1967">     * \v(ab){2,3} will expand to '(ab)(ab)(ab)?', where all the</a>
<a name="ln1968">     * parenthesis have the same id</a>
<a name="ln1969">     */</a>
<a name="ln1970"> </a>
<a name="ln1971">    greedy = true;</a>
<a name="ln1972">    c2 = peekchr();</a>
<a name="ln1973">    if (c2 == '-' || c2 == Magic('-')) {</a>
<a name="ln1974">      skipchr();</a>
<a name="ln1975">      greedy = false;</a>
<a name="ln1976">    }</a>
<a name="ln1977">    if (!read_limits(&amp;minval, &amp;maxval))</a>
<a name="ln1978">      EMSG_RET_FAIL(_(&quot;E870: (NFA regexp) Error reading repetition limits&quot;));</a>
<a name="ln1979"> </a>
<a name="ln1980">    /*  &lt;atom&gt;{0,inf}, &lt;atom&gt;{0,} and &lt;atom&gt;{}  are equivalent to</a>
<a name="ln1981">     *  &lt;atom&gt;*  */</a>
<a name="ln1982">    if (minval == 0 &amp;&amp; maxval == MAX_LIMIT) {</a>
<a name="ln1983">      if (greedy)</a>
<a name="ln1984">        /* \{}, \{0,} */</a>
<a name="ln1985">        EMIT(NFA_STAR);</a>
<a name="ln1986">      else</a>
<a name="ln1987">        /* \{-}, \{-0,} */</a>
<a name="ln1988">        EMIT(NFA_STAR_NONGREEDY);</a>
<a name="ln1989">      break;</a>
<a name="ln1990">    }</a>
<a name="ln1991"> </a>
<a name="ln1992">    /* Special case: x{0} or x{-0} */</a>
<a name="ln1993">    if (maxval == 0) {</a>
<a name="ln1994">      /* Ignore result of previous call to nfa_regatom() */</a>
<a name="ln1995">      post_ptr = post_start + my_post_start;</a>
<a name="ln1996">      /* NFA_EMPTY is 0-length and works everywhere */</a>
<a name="ln1997">      EMIT(NFA_EMPTY);</a>
<a name="ln1998">      return OK;</a>
<a name="ln1999">    }</a>
<a name="ln2000"> </a>
<a name="ln2001">    // The engine is very inefficient (uses too many states) when the maximum</a>
<a name="ln2002">    // is much larger than the minimum and when the maximum is large. Bail out</a>
<a name="ln2003">    // if we can use the other engine.</a>
<a name="ln2004">    if ((nfa_re_flags &amp; RE_AUTO) &amp;&amp; (maxval &gt; 500 || maxval &gt; minval + 200)) {</a>
<a name="ln2005">      return FAIL;</a>
<a name="ln2006">    }</a>
<a name="ln2007"> </a>
<a name="ln2008">    /* Ignore previous call to nfa_regatom() */</a>
<a name="ln2009">    post_ptr = post_start + my_post_start;</a>
<a name="ln2010">    /* Save parse state after the repeated atom and the \{} */</a>
<a name="ln2011">    save_parse_state(&amp;new_state);</a>
<a name="ln2012"> </a>
<a name="ln2013">    quest = (greedy == true ? NFA_QUEST : NFA_QUEST_NONGREEDY);</a>
<a name="ln2014">    for (i = 0; i &lt; maxval; i++) {</a>
<a name="ln2015">      /* Goto beginning of the repeated atom */</a>
<a name="ln2016">      restore_parse_state(&amp;old_state);</a>
<a name="ln2017">      old_post_pos = (int)(post_ptr - post_start);</a>
<a name="ln2018">      if (nfa_regatom() == FAIL)</a>
<a name="ln2019">        return FAIL;</a>
<a name="ln2020">      /* after &quot;minval&quot; times, atoms are optional */</a>
<a name="ln2021">      if (i + 1 &gt; minval) {</a>
<a name="ln2022">        if (maxval == MAX_LIMIT) {</a>
<a name="ln2023">          if (greedy)</a>
<a name="ln2024">            EMIT(NFA_STAR);</a>
<a name="ln2025">          else</a>
<a name="ln2026">            EMIT(NFA_STAR_NONGREEDY);</a>
<a name="ln2027">        } else</a>
<a name="ln2028">          EMIT(quest);</a>
<a name="ln2029">      }</a>
<a name="ln2030">      if (old_post_pos != my_post_start)</a>
<a name="ln2031">        EMIT(NFA_CONCAT);</a>
<a name="ln2032">      if (i + 1 &gt; minval &amp;&amp; maxval == MAX_LIMIT)</a>
<a name="ln2033">        break;</a>
<a name="ln2034">    }</a>
<a name="ln2035"> </a>
<a name="ln2036">    /* Go to just after the repeated atom and the \{} */</a>
<a name="ln2037">    restore_parse_state(&amp;new_state);</a>
<a name="ln2038">    curchr = -1;</a>
<a name="ln2039"> </a>
<a name="ln2040">    break;</a>
<a name="ln2041"> </a>
<a name="ln2042"> </a>
<a name="ln2043">  default:</a>
<a name="ln2044">    break;</a>
<a name="ln2045">  }     /* end switch */</a>
<a name="ln2046"> </a>
<a name="ln2047">  if (re_multi_type(peekchr()) != NOT_MULTI) {</a>
<a name="ln2048">    // Can't have a multi follow a multi.</a>
<a name="ln2049">    EMSG_RET_FAIL(_(&quot;E871: (NFA regexp) Can't have a multi follow a multi&quot;));</a>
<a name="ln2050">  }</a>
<a name="ln2051"> </a>
<a name="ln2052">  return OK;</a>
<a name="ln2053">}</a>
<a name="ln2054"> </a>
<a name="ln2055">/*</a>
<a name="ln2056"> * Parse one or more pieces, concatenated.  It matches a match for the</a>
<a name="ln2057"> * first piece, followed by a match for the second piece, etc.  Example:</a>
<a name="ln2058"> * &quot;f[0-9]b&quot;, first matches &quot;f&quot;, then a digit and then &quot;b&quot;.</a>
<a name="ln2059"> *</a>
<a name="ln2060"> * concat  ::=	    piece</a>
<a name="ln2061"> *	or  piece piece</a>
<a name="ln2062"> *	or  piece piece piece</a>
<a name="ln2063"> *	etc.</a>
<a name="ln2064"> */</a>
<a name="ln2065">static int nfa_regconcat(void)</a>
<a name="ln2066">{</a>
<a name="ln2067">  bool cont = true;</a>
<a name="ln2068">  bool first = true;</a>
<a name="ln2069"> </a>
<a name="ln2070">  while (cont) {</a>
<a name="ln2071">    switch (peekchr()) {</a>
<a name="ln2072">    case NUL:</a>
<a name="ln2073">    case Magic('|'):</a>
<a name="ln2074">    case Magic('&amp;'):</a>
<a name="ln2075">    case Magic(')'):</a>
<a name="ln2076">      cont = false;</a>
<a name="ln2077">      break;</a>
<a name="ln2078"> </a>
<a name="ln2079">    case Magic('Z'):</a>
<a name="ln2080">      regflags |= RF_ICOMBINE;</a>
<a name="ln2081">      skipchr_keepstart();</a>
<a name="ln2082">      break;</a>
<a name="ln2083">    case Magic('c'):</a>
<a name="ln2084">      regflags |= RF_ICASE;</a>
<a name="ln2085">      skipchr_keepstart();</a>
<a name="ln2086">      break;</a>
<a name="ln2087">    case Magic('C'):</a>
<a name="ln2088">      regflags |= RF_NOICASE;</a>
<a name="ln2089">      skipchr_keepstart();</a>
<a name="ln2090">      break;</a>
<a name="ln2091">    case Magic('v'):</a>
<a name="ln2092">      reg_magic = MAGIC_ALL;</a>
<a name="ln2093">      skipchr_keepstart();</a>
<a name="ln2094">      curchr = -1;</a>
<a name="ln2095">      break;</a>
<a name="ln2096">    case Magic('m'):</a>
<a name="ln2097">      reg_magic = MAGIC_ON;</a>
<a name="ln2098">      skipchr_keepstart();</a>
<a name="ln2099">      curchr = -1;</a>
<a name="ln2100">      break;</a>
<a name="ln2101">    case Magic('M'):</a>
<a name="ln2102">      reg_magic = MAGIC_OFF;</a>
<a name="ln2103">      skipchr_keepstart();</a>
<a name="ln2104">      curchr = -1;</a>
<a name="ln2105">      break;</a>
<a name="ln2106">    case Magic('V'):</a>
<a name="ln2107">      reg_magic = MAGIC_NONE;</a>
<a name="ln2108">      skipchr_keepstart();</a>
<a name="ln2109">      curchr = -1;</a>
<a name="ln2110">      break;</a>
<a name="ln2111"> </a>
<a name="ln2112">    default:</a>
<a name="ln2113">      if (nfa_regpiece() == FAIL) {</a>
<a name="ln2114">        return FAIL;</a>
<a name="ln2115">      }</a>
<a name="ln2116">      if (first == false) {</a>
<a name="ln2117">        EMIT(NFA_CONCAT);</a>
<a name="ln2118">      } else {</a>
<a name="ln2119">        first = false;</a>
<a name="ln2120">      }</a>
<a name="ln2121">      break;</a>
<a name="ln2122">    }</a>
<a name="ln2123">  }</a>
<a name="ln2124"> </a>
<a name="ln2125">  return OK;</a>
<a name="ln2126">}</a>
<a name="ln2127"> </a>
<a name="ln2128">/*</a>
<a name="ln2129"> * Parse a branch, one or more concats, separated by &quot;\&amp;&quot;.  It matches the</a>
<a name="ln2130"> * last concat, but only if all the preceding concats also match at the same</a>
<a name="ln2131"> * position.  Examples:</a>
<a name="ln2132"> *      &quot;foobeep\&amp;...&quot; matches &quot;foo&quot; in &quot;foobeep&quot;.</a>
<a name="ln2133"> *      &quot;.*Peter\&amp;.*Bob&quot; matches in a line containing both &quot;Peter&quot; and &quot;Bob&quot;</a>
<a name="ln2134"> *</a>
<a name="ln2135"> * branch ::=	    concat</a>
<a name="ln2136"> *		or  concat \&amp; concat</a>
<a name="ln2137"> *		or  concat \&amp; concat \&amp; concat</a>
<a name="ln2138"> *		etc.</a>
<a name="ln2139"> */</a>
<a name="ln2140">static int nfa_regbranch(void)</a>
<a name="ln2141">{</a>
<a name="ln2142">  int old_post_pos;</a>
<a name="ln2143"> </a>
<a name="ln2144">  old_post_pos = (int)(post_ptr - post_start);</a>
<a name="ln2145"> </a>
<a name="ln2146">  /* First branch, possibly the only one */</a>
<a name="ln2147">  if (nfa_regconcat() == FAIL)</a>
<a name="ln2148">    return FAIL;</a>
<a name="ln2149"> </a>
<a name="ln2150">  // Try next concats</a>
<a name="ln2151">  while (peekchr() == Magic('&amp;')) {</a>
<a name="ln2152">    skipchr();</a>
<a name="ln2153">    // if concat is empty do emit a node</a>
<a name="ln2154">    if (old_post_pos == (int)(post_ptr - post_start)) {</a>
<a name="ln2155">      EMIT(NFA_EMPTY);</a>
<a name="ln2156">    }</a>
<a name="ln2157">    EMIT(NFA_NOPEN);</a>
<a name="ln2158">    EMIT(NFA_PREV_ATOM_NO_WIDTH);</a>
<a name="ln2159">    old_post_pos = (int)(post_ptr - post_start);</a>
<a name="ln2160">    if (nfa_regconcat() == FAIL)</a>
<a name="ln2161">      return FAIL;</a>
<a name="ln2162">    /* if concat is empty do emit a node */</a>
<a name="ln2163">    if (old_post_pos == (int)(post_ptr - post_start))</a>
<a name="ln2164">      EMIT(NFA_EMPTY);</a>
<a name="ln2165">    EMIT(NFA_CONCAT);</a>
<a name="ln2166">  }</a>
<a name="ln2167"> </a>
<a name="ln2168">  /* if a branch is empty, emit one node for it */</a>
<a name="ln2169">  if (old_post_pos == (int)(post_ptr - post_start))</a>
<a name="ln2170">    EMIT(NFA_EMPTY);</a>
<a name="ln2171"> </a>
<a name="ln2172">  return OK;</a>
<a name="ln2173">}</a>
<a name="ln2174"> </a>
<a name="ln2175">/*</a>
<a name="ln2176"> *  Parse a pattern, one or more branches, separated by &quot;\|&quot;.  It matches</a>
<a name="ln2177"> *  anything that matches one of the branches.  Example: &quot;foo\|beep&quot; matches</a>
<a name="ln2178"> *  &quot;foo&quot; and matches &quot;beep&quot;.  If more than one branch matches, the first one</a>
<a name="ln2179"> *  is used.</a>
<a name="ln2180"> *</a>
<a name="ln2181"> *  pattern ::=	    branch</a>
<a name="ln2182"> *	or  branch \| branch</a>
<a name="ln2183"> *	or  branch \| branch \| branch</a>
<a name="ln2184"> *	etc.</a>
<a name="ln2185"> */</a>
<a name="ln2186">static int </a>
<a name="ln2187">nfa_reg (</a>
<a name="ln2188">    int paren              /* REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN */</a>
<a name="ln2189">)</a>
<a name="ln2190">{</a>
<a name="ln2191">  int parno = 0;</a>
<a name="ln2192"> </a>
<a name="ln2193">  if (paren == REG_PAREN) {</a>
<a name="ln2194">    if (regnpar &gt;= NSUBEXP)     /* Too many `(' */</a>
<a name="ln2195">      EMSG_RET_FAIL(_(&quot;E872: (NFA regexp) Too many '('&quot;));</a>
<a name="ln2196">    parno = regnpar++;</a>
<a name="ln2197">  } else if (paren == REG_ZPAREN) {</a>
<a name="ln2198">    /* Make a ZOPEN node. */</a>
<a name="ln2199">    if (regnzpar &gt;= NSUBEXP)</a>
<a name="ln2200">      EMSG_RET_FAIL(_(&quot;E879: (NFA regexp) Too many \\z(&quot;));</a>
<a name="ln2201">    parno = regnzpar++;</a>
<a name="ln2202">  }</a>
<a name="ln2203"> </a>
<a name="ln2204">  if (nfa_regbranch() == FAIL)</a>
<a name="ln2205">    return FAIL;            /* cascaded error */</a>
<a name="ln2206"> </a>
<a name="ln2207">  while (peekchr() == Magic('|')) {</a>
<a name="ln2208">    skipchr();</a>
<a name="ln2209">    if (nfa_regbranch() == FAIL)</a>
<a name="ln2210">      return FAIL;          /* cascaded error */</a>
<a name="ln2211">    EMIT(NFA_OR);</a>
<a name="ln2212">  }</a>
<a name="ln2213"> </a>
<a name="ln2214">  /* Check for proper termination. */</a>
<a name="ln2215">  if (paren != REG_NOPAREN &amp;&amp; getchr() != Magic(')')) {</a>
<a name="ln2216">    if (paren == REG_NPAREN)</a>
<a name="ln2217">      EMSG2_RET_FAIL(_(e_unmatchedpp), reg_magic == MAGIC_ALL);</a>
<a name="ln2218">    else</a>
<a name="ln2219">      EMSG2_RET_FAIL(_(e_unmatchedp), reg_magic == MAGIC_ALL);</a>
<a name="ln2220">  } else if (paren == REG_NOPAREN &amp;&amp; peekchr() != NUL) {</a>
<a name="ln2221">    if (peekchr() == Magic(')'))</a>
<a name="ln2222">      EMSG2_RET_FAIL(_(e_unmatchedpar), reg_magic == MAGIC_ALL);</a>
<a name="ln2223">    else</a>
<a name="ln2224">      EMSG_RET_FAIL(_(&quot;E873: (NFA regexp) proper termination error&quot;));</a>
<a name="ln2225">  }</a>
<a name="ln2226">  // Here we set the flag allowing back references to this set of</a>
<a name="ln2227">  // parentheses.</a>
<a name="ln2228">  if (paren == REG_PAREN) {</a>
<a name="ln2229">    had_endbrace[parno] = true;  // have seen the close paren</a>
<a name="ln2230">    EMIT(NFA_MOPEN + parno);</a>
<a name="ln2231">  } else if (paren == REG_ZPAREN) {</a>
<a name="ln2232">    EMIT(NFA_ZOPEN + parno);</a>
<a name="ln2233">  }</a>
<a name="ln2234"> </a>
<a name="ln2235">  return OK;</a>
<a name="ln2236">}</a>
<a name="ln2237"> </a>
<a name="ln2238">#ifdef REGEXP_DEBUG</a>
<a name="ln2239">static char_u code[50];</a>
<a name="ln2240"> </a>
<a name="ln2241">static void nfa_set_code(int c)</a>
<a name="ln2242">{</a>
<a name="ln2243">  int addnl = false;</a>
<a name="ln2244"> </a>
<a name="ln2245">  if (c &gt;= NFA_FIRST_NL &amp;&amp; c &lt;= NFA_LAST_NL) {</a>
<a name="ln2246">    addnl = true;</a>
<a name="ln2247">    c -= NFA_ADD_NL;</a>
<a name="ln2248">  }</a>
<a name="ln2249"> </a>
<a name="ln2250">  STRCPY(code, &quot;&quot;);</a>
<a name="ln2251">  switch (c) {</a>
<a name="ln2252">  case NFA_MATCH:     STRCPY(code, &quot;NFA_MATCH &quot;); break;</a>
<a name="ln2253">  case NFA_SPLIT:     STRCPY(code, &quot;NFA_SPLIT &quot;); break;</a>
<a name="ln2254">  case NFA_CONCAT:    STRCPY(code, &quot;NFA_CONCAT &quot;); break;</a>
<a name="ln2255">  case NFA_NEWL:      STRCPY(code, &quot;NFA_NEWL &quot;); break;</a>
<a name="ln2256">  case NFA_ZSTART:    STRCPY(code, &quot;NFA_ZSTART&quot;); break;</a>
<a name="ln2257">  case NFA_ZEND:      STRCPY(code, &quot;NFA_ZEND&quot;); break;</a>
<a name="ln2258"> </a>
<a name="ln2259">  case NFA_BACKREF1:  STRCPY(code, &quot;NFA_BACKREF1&quot;); break;</a>
<a name="ln2260">  case NFA_BACKREF2:  STRCPY(code, &quot;NFA_BACKREF2&quot;); break;</a>
<a name="ln2261">  case NFA_BACKREF3:  STRCPY(code, &quot;NFA_BACKREF3&quot;); break;</a>
<a name="ln2262">  case NFA_BACKREF4:  STRCPY(code, &quot;NFA_BACKREF4&quot;); break;</a>
<a name="ln2263">  case NFA_BACKREF5:  STRCPY(code, &quot;NFA_BACKREF5&quot;); break;</a>
<a name="ln2264">  case NFA_BACKREF6:  STRCPY(code, &quot;NFA_BACKREF6&quot;); break;</a>
<a name="ln2265">  case NFA_BACKREF7:  STRCPY(code, &quot;NFA_BACKREF7&quot;); break;</a>
<a name="ln2266">  case NFA_BACKREF8:  STRCPY(code, &quot;NFA_BACKREF8&quot;); break;</a>
<a name="ln2267">  case NFA_BACKREF9:  STRCPY(code, &quot;NFA_BACKREF9&quot;); break;</a>
<a name="ln2268">  case NFA_ZREF1:     STRCPY(code, &quot;NFA_ZREF1&quot;); break;</a>
<a name="ln2269">  case NFA_ZREF2:     STRCPY(code, &quot;NFA_ZREF2&quot;); break;</a>
<a name="ln2270">  case NFA_ZREF3:     STRCPY(code, &quot;NFA_ZREF3&quot;); break;</a>
<a name="ln2271">  case NFA_ZREF4:     STRCPY(code, &quot;NFA_ZREF4&quot;); break;</a>
<a name="ln2272">  case NFA_ZREF5:     STRCPY(code, &quot;NFA_ZREF5&quot;); break;</a>
<a name="ln2273">  case NFA_ZREF6:     STRCPY(code, &quot;NFA_ZREF6&quot;); break;</a>
<a name="ln2274">  case NFA_ZREF7:     STRCPY(code, &quot;NFA_ZREF7&quot;); break;</a>
<a name="ln2275">  case NFA_ZREF8:     STRCPY(code, &quot;NFA_ZREF8&quot;); break;</a>
<a name="ln2276">  case NFA_ZREF9:     STRCPY(code, &quot;NFA_ZREF9&quot;); break;</a>
<a name="ln2277">  case NFA_SKIP:      STRCPY(code, &quot;NFA_SKIP&quot;); break;</a>
<a name="ln2278"> </a>
<a name="ln2279">  case NFA_PREV_ATOM_NO_WIDTH:</a>
<a name="ln2280">    STRCPY(code, &quot;NFA_PREV_ATOM_NO_WIDTH&quot;); break;</a>
<a name="ln2281">  case NFA_PREV_ATOM_NO_WIDTH_NEG:</a>
<a name="ln2282">    STRCPY(code, &quot;NFA_PREV_ATOM_NO_WIDTH_NEG&quot;); break;</a>
<a name="ln2283">  case NFA_PREV_ATOM_JUST_BEFORE:</a>
<a name="ln2284">    STRCPY(code, &quot;NFA_PREV_ATOM_JUST_BEFORE&quot;); break;</a>
<a name="ln2285">  case NFA_PREV_ATOM_JUST_BEFORE_NEG:</a>
<a name="ln2286">    STRCPY(code, &quot;NFA_PREV_ATOM_JUST_BEFORE_NEG&quot;); break;</a>
<a name="ln2287">  case NFA_PREV_ATOM_LIKE_PATTERN:</a>
<a name="ln2288">    STRCPY(code, &quot;NFA_PREV_ATOM_LIKE_PATTERN&quot;); break;</a>
<a name="ln2289"> </a>
<a name="ln2290">  case NFA_NOPEN:             STRCPY(code, &quot;NFA_NOPEN&quot;); break;</a>
<a name="ln2291">  case NFA_NCLOSE:            STRCPY(code, &quot;NFA_NCLOSE&quot;); break;</a>
<a name="ln2292">  case NFA_START_INVISIBLE:   STRCPY(code, &quot;NFA_START_INVISIBLE&quot;); break;</a>
<a name="ln2293">  case NFA_START_INVISIBLE_FIRST:</a>
<a name="ln2294">    STRCPY(code, &quot;NFA_START_INVISIBLE_FIRST&quot;); break;</a>
<a name="ln2295">  case NFA_START_INVISIBLE_NEG:</a>
<a name="ln2296">    STRCPY(code, &quot;NFA_START_INVISIBLE_NEG&quot;); break;</a>
<a name="ln2297">  case NFA_START_INVISIBLE_NEG_FIRST:</a>
<a name="ln2298">    STRCPY(code, &quot;NFA_START_INVISIBLE_NEG_FIRST&quot;); break;</a>
<a name="ln2299">  case NFA_START_INVISIBLE_BEFORE:</a>
<a name="ln2300">    STRCPY(code, &quot;NFA_START_INVISIBLE_BEFORE&quot;); break;</a>
<a name="ln2301">  case NFA_START_INVISIBLE_BEFORE_FIRST:</a>
<a name="ln2302">    STRCPY(code, &quot;NFA_START_INVISIBLE_BEFORE_FIRST&quot;); break;</a>
<a name="ln2303">  case NFA_START_INVISIBLE_BEFORE_NEG:</a>
<a name="ln2304">    STRCPY(code, &quot;NFA_START_INVISIBLE_BEFORE_NEG&quot;); break;</a>
<a name="ln2305">  case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:</a>
<a name="ln2306">    STRCPY(code, &quot;NFA_START_INVISIBLE_BEFORE_NEG_FIRST&quot;); break;</a>
<a name="ln2307">  case NFA_START_PATTERN:   STRCPY(code, &quot;NFA_START_PATTERN&quot;); break;</a>
<a name="ln2308">  case NFA_END_INVISIBLE:     STRCPY(code, &quot;NFA_END_INVISIBLE&quot;); break;</a>
<a name="ln2309">  case NFA_END_INVISIBLE_NEG: STRCPY(code, &quot;NFA_END_INVISIBLE_NEG&quot;); break;</a>
<a name="ln2310">  case NFA_END_PATTERN:       STRCPY(code, &quot;NFA_END_PATTERN&quot;); break;</a>
<a name="ln2311"> </a>
<a name="ln2312">  case NFA_COMPOSING:         STRCPY(code, &quot;NFA_COMPOSING&quot;); break;</a>
<a name="ln2313">  case NFA_END_COMPOSING:     STRCPY(code, &quot;NFA_END_COMPOSING&quot;); break;</a>
<a name="ln2314">  case NFA_OPT_CHARS:         STRCPY(code, &quot;NFA_OPT_CHARS&quot;); break;</a>
<a name="ln2315"> </a>
<a name="ln2316">  case NFA_MOPEN:</a>
<a name="ln2317">  case NFA_MOPEN1:</a>
<a name="ln2318">  case NFA_MOPEN2:</a>
<a name="ln2319">  case NFA_MOPEN3:</a>
<a name="ln2320">  case NFA_MOPEN4:</a>
<a name="ln2321">  case NFA_MOPEN5:</a>
<a name="ln2322">  case NFA_MOPEN6:</a>
<a name="ln2323">  case NFA_MOPEN7:</a>
<a name="ln2324">  case NFA_MOPEN8:</a>
<a name="ln2325">  case NFA_MOPEN9:</a>
<a name="ln2326">    STRCPY(code, &quot;NFA_MOPEN(x)&quot;);</a>
<a name="ln2327">    code[10] = c - NFA_MOPEN + '0';</a>
<a name="ln2328">    break;</a>
<a name="ln2329">  case NFA_MCLOSE:</a>
<a name="ln2330">  case NFA_MCLOSE1:</a>
<a name="ln2331">  case NFA_MCLOSE2:</a>
<a name="ln2332">  case NFA_MCLOSE3:</a>
<a name="ln2333">  case NFA_MCLOSE4:</a>
<a name="ln2334">  case NFA_MCLOSE5:</a>
<a name="ln2335">  case NFA_MCLOSE6:</a>
<a name="ln2336">  case NFA_MCLOSE7:</a>
<a name="ln2337">  case NFA_MCLOSE8:</a>
<a name="ln2338">  case NFA_MCLOSE9:</a>
<a name="ln2339">    STRCPY(code, &quot;NFA_MCLOSE(x)&quot;);</a>
<a name="ln2340">    code[11] = c - NFA_MCLOSE + '0';</a>
<a name="ln2341">    break;</a>
<a name="ln2342">  case NFA_ZOPEN:</a>
<a name="ln2343">  case NFA_ZOPEN1:</a>
<a name="ln2344">  case NFA_ZOPEN2:</a>
<a name="ln2345">  case NFA_ZOPEN3:</a>
<a name="ln2346">  case NFA_ZOPEN4:</a>
<a name="ln2347">  case NFA_ZOPEN5:</a>
<a name="ln2348">  case NFA_ZOPEN6:</a>
<a name="ln2349">  case NFA_ZOPEN7:</a>
<a name="ln2350">  case NFA_ZOPEN8:</a>
<a name="ln2351">  case NFA_ZOPEN9:</a>
<a name="ln2352">    STRCPY(code, &quot;NFA_ZOPEN(x)&quot;);</a>
<a name="ln2353">    code[10] = c - NFA_ZOPEN + '0';</a>
<a name="ln2354">    break;</a>
<a name="ln2355">  case NFA_ZCLOSE:</a>
<a name="ln2356">  case NFA_ZCLOSE1:</a>
<a name="ln2357">  case NFA_ZCLOSE2:</a>
<a name="ln2358">  case NFA_ZCLOSE3:</a>
<a name="ln2359">  case NFA_ZCLOSE4:</a>
<a name="ln2360">  case NFA_ZCLOSE5:</a>
<a name="ln2361">  case NFA_ZCLOSE6:</a>
<a name="ln2362">  case NFA_ZCLOSE7:</a>
<a name="ln2363">  case NFA_ZCLOSE8:</a>
<a name="ln2364">  case NFA_ZCLOSE9:</a>
<a name="ln2365">    STRCPY(code, &quot;NFA_ZCLOSE(x)&quot;);</a>
<a name="ln2366">    code[11] = c - NFA_ZCLOSE + '0';</a>
<a name="ln2367">    break;</a>
<a name="ln2368">  case NFA_EOL:           STRCPY(code, &quot;NFA_EOL &quot;); break;</a>
<a name="ln2369">  case NFA_BOL:           STRCPY(code, &quot;NFA_BOL &quot;); break;</a>
<a name="ln2370">  case NFA_EOW:           STRCPY(code, &quot;NFA_EOW &quot;); break;</a>
<a name="ln2371">  case NFA_BOW:           STRCPY(code, &quot;NFA_BOW &quot;); break;</a>
<a name="ln2372">  case NFA_EOF:           STRCPY(code, &quot;NFA_EOF &quot;); break;</a>
<a name="ln2373">  case NFA_BOF:           STRCPY(code, &quot;NFA_BOF &quot;); break;</a>
<a name="ln2374">  case NFA_LNUM:          STRCPY(code, &quot;NFA_LNUM &quot;); break;</a>
<a name="ln2375">  case NFA_LNUM_GT:       STRCPY(code, &quot;NFA_LNUM_GT &quot;); break;</a>
<a name="ln2376">  case NFA_LNUM_LT:       STRCPY(code, &quot;NFA_LNUM_LT &quot;); break;</a>
<a name="ln2377">  case NFA_COL:           STRCPY(code, &quot;NFA_COL &quot;); break;</a>
<a name="ln2378">  case NFA_COL_GT:        STRCPY(code, &quot;NFA_COL_GT &quot;); break;</a>
<a name="ln2379">  case NFA_COL_LT:        STRCPY(code, &quot;NFA_COL_LT &quot;); break;</a>
<a name="ln2380">  case NFA_VCOL:          STRCPY(code, &quot;NFA_VCOL &quot;); break;</a>
<a name="ln2381">  case NFA_VCOL_GT:       STRCPY(code, &quot;NFA_VCOL_GT &quot;); break;</a>
<a name="ln2382">  case NFA_VCOL_LT:       STRCPY(code, &quot;NFA_VCOL_LT &quot;); break;</a>
<a name="ln2383">  case NFA_MARK:          STRCPY(code, &quot;NFA_MARK &quot;); break;</a>
<a name="ln2384">  case NFA_MARK_GT:       STRCPY(code, &quot;NFA_MARK_GT &quot;); break;</a>
<a name="ln2385">  case NFA_MARK_LT:       STRCPY(code, &quot;NFA_MARK_LT &quot;); break;</a>
<a name="ln2386">  case NFA_CURSOR:        STRCPY(code, &quot;NFA_CURSOR &quot;); break;</a>
<a name="ln2387">  case NFA_VISUAL:        STRCPY(code, &quot;NFA_VISUAL &quot;); break;</a>
<a name="ln2388">  case NFA_ANY_COMPOSING: STRCPY(code, &quot;NFA_ANY_COMPOSING &quot;); break;</a>
<a name="ln2389"> </a>
<a name="ln2390">  case NFA_STAR:          STRCPY(code, &quot;NFA_STAR &quot;); break;</a>
<a name="ln2391">  case NFA_STAR_NONGREEDY: STRCPY(code, &quot;NFA_STAR_NONGREEDY &quot;); break;</a>
<a name="ln2392">  case NFA_QUEST:         STRCPY(code, &quot;NFA_QUEST&quot;); break;</a>
<a name="ln2393">  case NFA_QUEST_NONGREEDY: STRCPY(code, &quot;NFA_QUEST_NON_GREEDY&quot;); break;</a>
<a name="ln2394">  case NFA_EMPTY:         STRCPY(code, &quot;NFA_EMPTY&quot;); break;</a>
<a name="ln2395">  case NFA_OR:            STRCPY(code, &quot;NFA_OR&quot;); break;</a>
<a name="ln2396"> </a>
<a name="ln2397">  case NFA_START_COLL:    STRCPY(code, &quot;NFA_START_COLL&quot;); break;</a>
<a name="ln2398">  case NFA_END_COLL:      STRCPY(code, &quot;NFA_END_COLL&quot;); break;</a>
<a name="ln2399">  case NFA_START_NEG_COLL: STRCPY(code, &quot;NFA_START_NEG_COLL&quot;); break;</a>
<a name="ln2400">  case NFA_END_NEG_COLL:  STRCPY(code, &quot;NFA_END_NEG_COLL&quot;); break;</a>
<a name="ln2401">  case NFA_RANGE:         STRCPY(code, &quot;NFA_RANGE&quot;); break;</a>
<a name="ln2402">  case NFA_RANGE_MIN:     STRCPY(code, &quot;NFA_RANGE_MIN&quot;); break;</a>
<a name="ln2403">  case NFA_RANGE_MAX:     STRCPY(code, &quot;NFA_RANGE_MAX&quot;); break;</a>
<a name="ln2404"> </a>
<a name="ln2405">  case NFA_CLASS_ALNUM:   STRCPY(code, &quot;NFA_CLASS_ALNUM&quot;); break;</a>
<a name="ln2406">  case NFA_CLASS_ALPHA:   STRCPY(code, &quot;NFA_CLASS_ALPHA&quot;); break;</a>
<a name="ln2407">  case NFA_CLASS_BLANK:   STRCPY(code, &quot;NFA_CLASS_BLANK&quot;); break;</a>
<a name="ln2408">  case NFA_CLASS_CNTRL:   STRCPY(code, &quot;NFA_CLASS_CNTRL&quot;); break;</a>
<a name="ln2409">  case NFA_CLASS_DIGIT:   STRCPY(code, &quot;NFA_CLASS_DIGIT&quot;); break;</a>
<a name="ln2410">  case NFA_CLASS_GRAPH:   STRCPY(code, &quot;NFA_CLASS_GRAPH&quot;); break;</a>
<a name="ln2411">  case NFA_CLASS_LOWER:   STRCPY(code, &quot;NFA_CLASS_LOWER&quot;); break;</a>
<a name="ln2412">  case NFA_CLASS_PRINT:   STRCPY(code, &quot;NFA_CLASS_PRINT&quot;); break;</a>
<a name="ln2413">  case NFA_CLASS_PUNCT:   STRCPY(code, &quot;NFA_CLASS_PUNCT&quot;); break;</a>
<a name="ln2414">  case NFA_CLASS_SPACE:   STRCPY(code, &quot;NFA_CLASS_SPACE&quot;); break;</a>
<a name="ln2415">  case NFA_CLASS_UPPER:   STRCPY(code, &quot;NFA_CLASS_UPPER&quot;); break;</a>
<a name="ln2416">  case NFA_CLASS_XDIGIT:  STRCPY(code, &quot;NFA_CLASS_XDIGIT&quot;); break;</a>
<a name="ln2417">  case NFA_CLASS_TAB:     STRCPY(code, &quot;NFA_CLASS_TAB&quot;); break;</a>
<a name="ln2418">  case NFA_CLASS_RETURN:  STRCPY(code, &quot;NFA_CLASS_RETURN&quot;); break;</a>
<a name="ln2419">  case NFA_CLASS_BACKSPACE:   STRCPY(code, &quot;NFA_CLASS_BACKSPACE&quot;); break;</a>
<a name="ln2420">  case NFA_CLASS_ESCAPE:  STRCPY(code, &quot;NFA_CLASS_ESCAPE&quot;); break;</a>
<a name="ln2421">  case NFA_CLASS_IDENT:   STRCPY(code, &quot;NFA_CLASS_IDENT&quot;); break;</a>
<a name="ln2422">  case NFA_CLASS_KEYWORD: STRCPY(code, &quot;NFA_CLASS_KEYWORD&quot;); break;</a>
<a name="ln2423">  case NFA_CLASS_FNAME:   STRCPY(code, &quot;NFA_CLASS_FNAME&quot;); break;</a>
<a name="ln2424"> </a>
<a name="ln2425">  case NFA_ANY:   STRCPY(code, &quot;NFA_ANY&quot;); break;</a>
<a name="ln2426">  case NFA_IDENT: STRCPY(code, &quot;NFA_IDENT&quot;); break;</a>
<a name="ln2427">  case NFA_SIDENT: STRCPY(code, &quot;NFA_SIDENT&quot;); break;</a>
<a name="ln2428">  case NFA_KWORD: STRCPY(code, &quot;NFA_KWORD&quot;); break;</a>
<a name="ln2429">  case NFA_SKWORD: STRCPY(code, &quot;NFA_SKWORD&quot;); break;</a>
<a name="ln2430">  case NFA_FNAME: STRCPY(code, &quot;NFA_FNAME&quot;); break;</a>
<a name="ln2431">  case NFA_SFNAME: STRCPY(code, &quot;NFA_SFNAME&quot;); break;</a>
<a name="ln2432">  case NFA_PRINT: STRCPY(code, &quot;NFA_PRINT&quot;); break;</a>
<a name="ln2433">  case NFA_SPRINT: STRCPY(code, &quot;NFA_SPRINT&quot;); break;</a>
<a name="ln2434">  case NFA_WHITE: STRCPY(code, &quot;NFA_WHITE&quot;); break;</a>
<a name="ln2435">  case NFA_NWHITE: STRCPY(code, &quot;NFA_NWHITE&quot;); break;</a>
<a name="ln2436">  case NFA_DIGIT: STRCPY(code, &quot;NFA_DIGIT&quot;); break;</a>
<a name="ln2437">  case NFA_NDIGIT: STRCPY(code, &quot;NFA_NDIGIT&quot;); break;</a>
<a name="ln2438">  case NFA_HEX:   STRCPY(code, &quot;NFA_HEX&quot;); break;</a>
<a name="ln2439">  case NFA_NHEX:  STRCPY(code, &quot;NFA_NHEX&quot;); break;</a>
<a name="ln2440">  case NFA_OCTAL: STRCPY(code, &quot;NFA_OCTAL&quot;); break;</a>
<a name="ln2441">  case NFA_NOCTAL: STRCPY(code, &quot;NFA_NOCTAL&quot;); break;</a>
<a name="ln2442">  case NFA_WORD:  STRCPY(code, &quot;NFA_WORD&quot;); break;</a>
<a name="ln2443">  case NFA_NWORD: STRCPY(code, &quot;NFA_NWORD&quot;); break;</a>
<a name="ln2444">  case NFA_HEAD:  STRCPY(code, &quot;NFA_HEAD&quot;); break;</a>
<a name="ln2445">  case NFA_NHEAD: STRCPY(code, &quot;NFA_NHEAD&quot;); break;</a>
<a name="ln2446">  case NFA_ALPHA: STRCPY(code, &quot;NFA_ALPHA&quot;); break;</a>
<a name="ln2447">  case NFA_NALPHA: STRCPY(code, &quot;NFA_NALPHA&quot;); break;</a>
<a name="ln2448">  case NFA_LOWER: STRCPY(code, &quot;NFA_LOWER&quot;); break;</a>
<a name="ln2449">  case NFA_NLOWER: STRCPY(code, &quot;NFA_NLOWER&quot;); break;</a>
<a name="ln2450">  case NFA_UPPER: STRCPY(code, &quot;NFA_UPPER&quot;); break;</a>
<a name="ln2451">  case NFA_NUPPER: STRCPY(code, &quot;NFA_NUPPER&quot;); break;</a>
<a name="ln2452">  case NFA_LOWER_IC:  STRCPY(code, &quot;NFA_LOWER_IC&quot;); break;</a>
<a name="ln2453">  case NFA_NLOWER_IC: STRCPY(code, &quot;NFA_NLOWER_IC&quot;); break;</a>
<a name="ln2454">  case NFA_UPPER_IC:  STRCPY(code, &quot;NFA_UPPER_IC&quot;); break;</a>
<a name="ln2455">  case NFA_NUPPER_IC: STRCPY(code, &quot;NFA_NUPPER_IC&quot;); break;</a>
<a name="ln2456"> </a>
<a name="ln2457">  default:</a>
<a name="ln2458">    STRCPY(code, &quot;CHAR(x)&quot;);</a>
<a name="ln2459">    code[5] = c;</a>
<a name="ln2460">  }</a>
<a name="ln2461"> </a>
<a name="ln2462">  if (addnl == true) {</a>
<a name="ln2463">    STRCAT(code, &quot; + NEWLINE &quot;);</a>
<a name="ln2464">  }</a>
<a name="ln2465">}</a>
<a name="ln2466"> </a>
<a name="ln2467">static FILE *log_fd;</a>
<a name="ln2468">static char_u e_log_open_failed[] = N_(</a>
<a name="ln2469">    &quot;Could not open temporary log file for writing, displaying on stderr... &quot;);</a>
<a name="ln2470"> </a>
<a name="ln2471">/*</a>
<a name="ln2472"> * Print the postfix notation of the current regexp.</a>
<a name="ln2473"> */</a>
<a name="ln2474">static void nfa_postfix_dump(char_u *expr, int retval)</a>
<a name="ln2475">{</a>
<a name="ln2476">  int *p;</a>
<a name="ln2477">  FILE *f;</a>
<a name="ln2478"> </a>
<a name="ln2479">  f = fopen(NFA_REGEXP_DUMP_LOG, &quot;a&quot;);</a>
<a name="ln2480">  if (f != NULL) {</a>
<a name="ln2481">    fprintf(f, &quot;\n-------------------------\n&quot;);</a>
<a name="ln2482">    if (retval == FAIL) {</a>
<a name="ln2483">      fprintf(f, &quot;&gt;&gt;&gt; NFA engine failed... \n&quot;);</a>
<a name="ln2484">    } else if (retval == OK) {</a>
<a name="ln2485">      fprintf(f, &quot;&gt;&gt;&gt; NFA engine succeeded !\n&quot;);</a>
<a name="ln2486">    }</a>
<a name="ln2487">    fprintf(f, &quot;Regexp: \&quot;%s\&quot;\nPostfix notation (char): \&quot;&quot;, expr);</a>
<a name="ln2488">    for (p = post_start; *p &amp;&amp; p &lt; post_ptr; p++) {</a>
<a name="ln2489">      nfa_set_code(*p);</a>
<a name="ln2490">      fprintf(f, &quot;%s, &quot;, code);</a>
<a name="ln2491">    }</a>
<a name="ln2492">    fprintf(f, &quot;\&quot;\nPostfix notation (int): &quot;);</a>
<a name="ln2493">    for (p = post_start; *p &amp;&amp; p &lt; post_ptr; p++)</a>
<a name="ln2494">      fprintf(f, &quot;%d &quot;, *p);</a>
<a name="ln2495">    fprintf(f, &quot;\n\n&quot;);</a>
<a name="ln2496">    fclose(f);</a>
<a name="ln2497">  }</a>
<a name="ln2498">}</a>
<a name="ln2499"> </a>
<a name="ln2500">/*</a>
<a name="ln2501"> * Print the NFA starting with a root node &quot;state&quot;.</a>
<a name="ln2502"> */</a>
<a name="ln2503">static void nfa_print_state(FILE *debugf, nfa_state_T *state)</a>
<a name="ln2504">{</a>
<a name="ln2505">  garray_T indent;</a>
<a name="ln2506"> </a>
<a name="ln2507">  ga_init(&amp;indent, 1, 64);</a>
<a name="ln2508">  ga_append(&amp;indent, '\0');</a>
<a name="ln2509">  nfa_print_state2(debugf, state, &amp;indent);</a>
<a name="ln2510">  ga_clear(&amp;indent);</a>
<a name="ln2511">}</a>
<a name="ln2512"> </a>
<a name="ln2513">static void nfa_print_state2(FILE *debugf, nfa_state_T *state, garray_T *indent)</a>
<a name="ln2514">{</a>
<a name="ln2515">  char_u  *p;</a>
<a name="ln2516"> </a>
<a name="ln2517">  if (state == NULL)</a>
<a name="ln2518">    return;</a>
<a name="ln2519"> </a>
<a name="ln2520">  fprintf(debugf, &quot;(%2d)&quot;, abs(state-&gt;id));</a>
<a name="ln2521"> </a>
<a name="ln2522">  /* Output indent */</a>
<a name="ln2523">  p = (char_u *)indent-&gt;ga_data;</a>
<a name="ln2524">  if (indent-&gt;ga_len &gt;= 3) {</a>
<a name="ln2525">    int last = indent-&gt;ga_len - 3;</a>
<a name="ln2526">    char_u save[2];</a>
<a name="ln2527"> </a>
<a name="ln2528">    STRNCPY(save, &amp;p[last], 2);</a>
<a name="ln2529">    STRNCPY(&amp;p[last], &quot;+-&quot;, 2);</a>
<a name="ln2530">    fprintf(debugf, &quot; %s&quot;, p);</a>
<a name="ln2531">    STRNCPY(&amp;p[last], save, 2);</a>
<a name="ln2532">  } else</a>
<a name="ln2533">    fprintf(debugf, &quot; %s&quot;, p);</a>
<a name="ln2534"> </a>
<a name="ln2535">  nfa_set_code(state-&gt;c);</a>
<a name="ln2536">  fprintf(debugf, &quot;%s (%d) (id=%d) val=%d\n&quot;,</a>
<a name="ln2537">      code,</a>
<a name="ln2538">      state-&gt;c,</a>
<a name="ln2539">      abs(state-&gt;id),</a>
<a name="ln2540">      state-&gt;val);</a>
<a name="ln2541">  if (state-&gt;id &lt; 0)</a>
<a name="ln2542">    return;</a>
<a name="ln2543"> </a>
<a name="ln2544">  state-&gt;id = abs(state-&gt;id) * -1;</a>
<a name="ln2545"> </a>
<a name="ln2546">  /* grow indent for state-&gt;out */</a>
<a name="ln2547">  indent-&gt;ga_len -= 1;</a>
<a name="ln2548">  if (state-&gt;out1)</a>
<a name="ln2549">    ga_concat(indent, (char_u *)&quot;| &quot;);</a>
<a name="ln2550">  else</a>
<a name="ln2551">    ga_concat(indent, (char_u *)&quot;  &quot;);</a>
<a name="ln2552">  ga_append(indent, '\0');</a>
<a name="ln2553"> </a>
<a name="ln2554">  nfa_print_state2(debugf, state-&gt;out, indent);</a>
<a name="ln2555"> </a>
<a name="ln2556">  /* replace last part of indent for state-&gt;out1 */</a>
<a name="ln2557">  indent-&gt;ga_len -= 3;</a>
<a name="ln2558">  ga_concat(indent, (char_u *)&quot;  &quot;);</a>
<a name="ln2559">  ga_append(indent, '\0');</a>
<a name="ln2560"> </a>
<a name="ln2561">  nfa_print_state2(debugf, state-&gt;out1, indent);</a>
<a name="ln2562"> </a>
<a name="ln2563">  /* shrink indent */</a>
<a name="ln2564">  indent-&gt;ga_len -= 3;</a>
<a name="ln2565">  ga_append(indent, '\0');</a>
<a name="ln2566">}</a>
<a name="ln2567"> </a>
<a name="ln2568">/*</a>
<a name="ln2569"> * Print the NFA state machine.</a>
<a name="ln2570"> */</a>
<a name="ln2571">static void nfa_dump(nfa_regprog_T *prog)</a>
<a name="ln2572">{</a>
<a name="ln2573">  FILE *debugf = fopen(NFA_REGEXP_DUMP_LOG, &quot;a&quot;);</a>
<a name="ln2574"> </a>
<a name="ln2575">  if (debugf != NULL) {</a>
<a name="ln2576">    nfa_print_state(debugf, prog-&gt;start);</a>
<a name="ln2577"> </a>
<a name="ln2578">    if (prog-&gt;reganch)</a>
<a name="ln2579">      fprintf(debugf, &quot;reganch: %d\n&quot;, prog-&gt;reganch);</a>
<a name="ln2580">    if (prog-&gt;regstart != NUL)</a>
<a name="ln2581">      fprintf(debugf, &quot;regstart: %c (decimal: %d)\n&quot;,</a>
<a name="ln2582">          prog-&gt;regstart, prog-&gt;regstart);</a>
<a name="ln2583">    if (prog-&gt;match_text != NULL)</a>
<a name="ln2584">      fprintf(debugf, &quot;match_text: \&quot;%s\&quot;\n&quot;, prog-&gt;match_text);</a>
<a name="ln2585"> </a>
<a name="ln2586">    fclose(debugf);</a>
<a name="ln2587">  }</a>
<a name="ln2588">}</a>
<a name="ln2589">#endif      /* REGEXP_DEBUG */</a>
<a name="ln2590"> </a>
<a name="ln2591">/*</a>
<a name="ln2592"> * Parse r.e. @expr and convert it into postfix form.</a>
<a name="ln2593"> * Return the postfix string on success, NULL otherwise.</a>
<a name="ln2594"> */</a>
<a name="ln2595">static int *re2post(void)</a>
<a name="ln2596">{</a>
<a name="ln2597">  if (nfa_reg(REG_NOPAREN) == FAIL)</a>
<a name="ln2598">    return NULL;</a>
<a name="ln2599">  EMIT(NFA_MOPEN);</a>
<a name="ln2600">  return post_start;</a>
<a name="ln2601">}</a>
<a name="ln2602"> </a>
<a name="ln2603">/* NB. Some of the code below is inspired by Russ's. */</a>
<a name="ln2604"> </a>
<a name="ln2605">/*</a>
<a name="ln2606"> * Represents an NFA state plus zero or one or two arrows exiting.</a>
<a name="ln2607"> * if c == MATCH, no arrows out; matching state.</a>
<a name="ln2608"> * If c == SPLIT, unlabeled arrows to out and out1 (if != NULL).</a>
<a name="ln2609"> * If c &lt; 256, labeled arrow with character c to out.</a>
<a name="ln2610"> */</a>
<a name="ln2611"> </a>
<a name="ln2612">static nfa_state_T      *state_ptr; /* points to nfa_prog-&gt;state */</a>
<a name="ln2613"> </a>
<a name="ln2614">/*</a>
<a name="ln2615"> * Allocate and initialize nfa_state_T.</a>
<a name="ln2616"> */</a>
<a name="ln2617">static nfa_state_T *alloc_state(int c, nfa_state_T *out, nfa_state_T *out1)</a>
<a name="ln2618">{</a>
<a name="ln2619">  nfa_state_T *s;</a>
<a name="ln2620"> </a>
<a name="ln2621">  if (istate &gt;= nstate)</a>
<a name="ln2622">    return NULL;</a>
<a name="ln2623"> </a>
<a name="ln2624">  s = &amp;state_ptr[istate++];</a>
<a name="ln2625"> </a>
<a name="ln2626">  s-&gt;c    = c;</a>
<a name="ln2627">  s-&gt;out  = out;</a>
<a name="ln2628">  s-&gt;out1 = out1;</a>
<a name="ln2629">  s-&gt;val  = 0;</a>
<a name="ln2630"> </a>
<a name="ln2631">  s-&gt;id   = istate;</a>
<a name="ln2632">  s-&gt;lastlist[0] = 0;</a>
<a name="ln2633">  s-&gt;lastlist[1] = 0;</a>
<a name="ln2634"> </a>
<a name="ln2635">  return s;</a>
<a name="ln2636">}</a>
<a name="ln2637"> </a>
<a name="ln2638">/*</a>
<a name="ln2639"> * A partially built NFA without the matching state filled in.</a>
<a name="ln2640"> * Frag_T.start points at the start state.</a>
<a name="ln2641"> * Frag_T.out is a list of places that need to be set to the</a>
<a name="ln2642"> * next state for this fragment.</a>
<a name="ln2643"> */</a>
<a name="ln2644"> </a>
<a name="ln2645"> </a>
<a name="ln2646">/*</a>
<a name="ln2647"> * Initialize a Frag_T struct and return it.</a>
<a name="ln2648"> */</a>
<a name="ln2649">static Frag_T frag(nfa_state_T *start, Ptrlist *out)</a>
<a name="ln2650">{</a>
<a name="ln2651">  Frag_T n;</a>
<a name="ln2652"> </a>
<a name="ln2653">  n.start = start;</a>
<a name="ln2654">  n.out = out;</a>
<a name="ln2655">  return n;</a>
<a name="ln2656">}</a>
<a name="ln2657"> </a>
<a name="ln2658">/*</a>
<a name="ln2659"> * Create singleton list containing just outp.</a>
<a name="ln2660"> */</a>
<a name="ln2661">static Ptrlist *list1(nfa_state_T **outp)</a>
<a name="ln2662">{</a>
<a name="ln2663">  Ptrlist *l;</a>
<a name="ln2664"> </a>
<a name="ln2665">  l = (Ptrlist *)outp;</a>
<a name="ln2666">  l-&gt;next = NULL;</a>
<a name="ln2667">  return l;</a>
<a name="ln2668">}</a>
<a name="ln2669"> </a>
<a name="ln2670">/*</a>
<a name="ln2671"> * Patch the list of states at out to point to start.</a>
<a name="ln2672"> */</a>
<a name="ln2673">static void patch(Ptrlist *l, nfa_state_T *s)</a>
<a name="ln2674">{</a>
<a name="ln2675">  Ptrlist *next;</a>
<a name="ln2676"> </a>
<a name="ln2677">  for (; l; l = next) {</a>
<a name="ln2678">    next = l-&gt;next;</a>
<a name="ln2679">    l-&gt;s = s;</a>
<a name="ln2680">  }</a>
<a name="ln2681">}</a>
<a name="ln2682"> </a>
<a name="ln2683"> </a>
<a name="ln2684">/*</a>
<a name="ln2685"> * Join the two lists l1 and l2, returning the combination.</a>
<a name="ln2686"> */</a>
<a name="ln2687">static Ptrlist *append(Ptrlist *l1, Ptrlist *l2)</a>
<a name="ln2688">{</a>
<a name="ln2689">  Ptrlist *oldl1;</a>
<a name="ln2690"> </a>
<a name="ln2691">  oldl1 = l1;</a>
<a name="ln2692">  while (l1-&gt;next)</a>
<a name="ln2693">    l1 = l1-&gt;next;</a>
<a name="ln2694">  l1-&gt;next = l2;</a>
<a name="ln2695">  return oldl1;</a>
<a name="ln2696">}</a>
<a name="ln2697"> </a>
<a name="ln2698">/*</a>
<a name="ln2699"> * Stack used for transforming postfix form into NFA.</a>
<a name="ln2700"> */</a>
<a name="ln2701">static Frag_T empty;</a>
<a name="ln2702"> </a>
<a name="ln2703">static void st_error(int *postfix, int *end, int *p)</a>
<a name="ln2704">{</a>
<a name="ln2705">#ifdef NFA_REGEXP_ERROR_LOG</a>
<a name="ln2706">  FILE *df;</a>
<a name="ln2707">  int *p2;</a>
<a name="ln2708"> </a>
<a name="ln2709">  df = fopen(NFA_REGEXP_ERROR_LOG, &quot;a&quot;);</a>
<a name="ln2710">  if (df) {</a>
<a name="ln2711">    fprintf(df, &quot;Error popping the stack!\n&quot;);</a>
<a name="ln2712">#ifdef REGEXP_DEBUG</a>
<a name="ln2713">    fprintf(df, &quot;Current regexp is \&quot;%s\&quot;\n&quot;, nfa_regengine.expr);</a>
<a name="ln2714">#endif</a>
<a name="ln2715">    fprintf(df, &quot;Postfix form is: &quot;);</a>
<a name="ln2716">#ifdef REGEXP_DEBUG</a>
<a name="ln2717">    for (p2 = postfix; p2 &lt; end; p2++) {</a>
<a name="ln2718">      nfa_set_code(*p2);</a>
<a name="ln2719">      fprintf(df, &quot;%s, &quot;, code);</a>
<a name="ln2720">    }</a>
<a name="ln2721">    nfa_set_code(*p);</a>
<a name="ln2722">    fprintf(df, &quot;\nCurrent position is: &quot;);</a>
<a name="ln2723">    for (p2 = postfix; p2 &lt;= p; p2++) {</a>
<a name="ln2724">      nfa_set_code(*p2);</a>
<a name="ln2725">      fprintf(df, &quot;%s, &quot;, code);</a>
<a name="ln2726">    }</a>
<a name="ln2727">#else</a>
<a name="ln2728">    for (p2 = postfix; p2 &lt; end; p2++) {</a>
<a name="ln2729">      fprintf(df, &quot;%d, &quot;, *p2);</a>
<a name="ln2730">    }</a>
<a name="ln2731">    fprintf(df, &quot;\nCurrent position is: &quot;);</a>
<a name="ln2732">    for (p2 = postfix; p2 &lt;= p; p2++) {</a>
<a name="ln2733">      fprintf(df, &quot;%d, &quot;, *p2);</a>
<a name="ln2734">    }</a>
<a name="ln2735">#endif</a>
<a name="ln2736">    fprintf(df, &quot;\n--------------------------\n&quot;);</a>
<a name="ln2737">    fclose(df);</a>
<a name="ln2738">  }</a>
<a name="ln2739">#endif</a>
<a name="ln2740">  EMSG(_(&quot;E874: (NFA) Could not pop the stack!&quot;));</a>
<a name="ln2741">}</a>
<a name="ln2742"> </a>
<a name="ln2743">/*</a>
<a name="ln2744"> * Push an item onto the stack.</a>
<a name="ln2745"> */</a>
<a name="ln2746">static void st_push(Frag_T s, Frag_T **p, Frag_T *stack_end)</a>
<a name="ln2747">{</a>
<a name="ln2748">  Frag_T *stackp = *p;</a>
<a name="ln2749"> </a>
<a name="ln2750">  if (stackp &gt;= stack_end)</a>
<a name="ln2751">    return;</a>
<a name="ln2752">  *stackp = s;</a>
<a name="ln2753">  *p = *p + 1;</a>
<a name="ln2754">}</a>
<a name="ln2755"> </a>
<a name="ln2756">/*</a>
<a name="ln2757"> * Pop an item from the stack.</a>
<a name="ln2758"> */</a>
<a name="ln2759">static Frag_T st_pop(Frag_T **p, Frag_T *stack)</a>
<a name="ln2760">{</a>
<a name="ln2761">  Frag_T *stackp;</a>
<a name="ln2762"> </a>
<a name="ln2763">  *p = *p - 1;</a>
<a name="ln2764">  stackp = *p;</a>
<a name="ln2765">  if (stackp &lt; stack)</a>
<a name="ln2766">    return empty;</a>
<a name="ln2767">  return **p;</a>
<a name="ln2768">}</a>
<a name="ln2769"> </a>
<a name="ln2770">/*</a>
<a name="ln2771"> * Estimate the maximum byte length of anything matching &quot;state&quot;.</a>
<a name="ln2772"> * When unknown or unlimited return -1.</a>
<a name="ln2773"> */</a>
<a name="ln2774">static int nfa_max_width(nfa_state_T *startstate, int depth)</a>
<a name="ln2775">{</a>
<a name="ln2776">  int l, r;</a>
<a name="ln2777">  nfa_state_T     *state = startstate;</a>
<a name="ln2778">  int len = 0;</a>
<a name="ln2779"> </a>
<a name="ln2780">  /* detect looping in a NFA_SPLIT */</a>
<a name="ln2781">  if (depth &gt; 4)</a>
<a name="ln2782">    return -1;</a>
<a name="ln2783"> </a>
<a name="ln2784">  while (state != NULL) {</a>
<a name="ln2785">    switch (state-&gt;c) {</a>
<a name="ln2786">    case NFA_END_INVISIBLE:</a>
<a name="ln2787">    case NFA_END_INVISIBLE_NEG:</a>
<a name="ln2788">      /* the end, return what we have */</a>
<a name="ln2789">      return len;</a>
<a name="ln2790"> </a>
<a name="ln2791">    case NFA_SPLIT:</a>
<a name="ln2792">      /* two alternatives, use the maximum */</a>
<a name="ln2793">      l = nfa_max_width(state-&gt;out, depth + 1);</a>
<a name="ln2794">      r = nfa_max_width(state-&gt;out1, depth + 1);</a>
<a name="ln2795">      if (l &lt; 0 || r &lt; 0)</a>
<a name="ln2796">        return -1;</a>
<a name="ln2797">      return len + (l &gt; r ? l : r);</a>
<a name="ln2798"> </a>
<a name="ln2799">    case NFA_ANY:</a>
<a name="ln2800">    case NFA_START_COLL:</a>
<a name="ln2801">    case NFA_START_NEG_COLL:</a>
<a name="ln2802">      // Matches some character, including composing chars.</a>
<a name="ln2803">      len += MB_MAXBYTES;</a>
<a name="ln2804">      if (state-&gt;c != NFA_ANY) {</a>
<a name="ln2805">        // Skip over the characters.</a>
<a name="ln2806">        state = state-&gt;out1-&gt;out;</a>
<a name="ln2807">        continue;</a>
<a name="ln2808">      }</a>
<a name="ln2809">      break;</a>
<a name="ln2810"> </a>
<a name="ln2811">    case NFA_DIGIT:</a>
<a name="ln2812">    case NFA_WHITE:</a>
<a name="ln2813">    case NFA_HEX:</a>
<a name="ln2814">    case NFA_OCTAL:</a>
<a name="ln2815">      /* ascii */</a>
<a name="ln2816">      ++len;</a>
<a name="ln2817">      break;</a>
<a name="ln2818"> </a>
<a name="ln2819">    case NFA_IDENT:</a>
<a name="ln2820">    case NFA_SIDENT:</a>
<a name="ln2821">    case NFA_KWORD:</a>
<a name="ln2822">    case NFA_SKWORD:</a>
<a name="ln2823">    case NFA_FNAME:</a>
<a name="ln2824">    case NFA_SFNAME:</a>
<a name="ln2825">    case NFA_PRINT:</a>
<a name="ln2826">    case NFA_SPRINT:</a>
<a name="ln2827">    case NFA_NWHITE:</a>
<a name="ln2828">    case NFA_NDIGIT:</a>
<a name="ln2829">    case NFA_NHEX:</a>
<a name="ln2830">    case NFA_NOCTAL:</a>
<a name="ln2831">    case NFA_WORD:</a>
<a name="ln2832">    case NFA_NWORD:</a>
<a name="ln2833">    case NFA_HEAD:</a>
<a name="ln2834">    case NFA_NHEAD:</a>
<a name="ln2835">    case NFA_ALPHA:</a>
<a name="ln2836">    case NFA_NALPHA:</a>
<a name="ln2837">    case NFA_LOWER:</a>
<a name="ln2838">    case NFA_NLOWER:</a>
<a name="ln2839">    case NFA_UPPER:</a>
<a name="ln2840">    case NFA_NUPPER:</a>
<a name="ln2841">    case NFA_LOWER_IC:</a>
<a name="ln2842">    case NFA_NLOWER_IC:</a>
<a name="ln2843">    case NFA_UPPER_IC:</a>
<a name="ln2844">    case NFA_NUPPER_IC:</a>
<a name="ln2845">    case NFA_ANY_COMPOSING:</a>
<a name="ln2846">      // possibly non-ascii</a>
<a name="ln2847">      len += 3;</a>
<a name="ln2848">      break;</a>
<a name="ln2849"> </a>
<a name="ln2850">    case NFA_START_INVISIBLE:</a>
<a name="ln2851">    case NFA_START_INVISIBLE_NEG:</a>
<a name="ln2852">    case NFA_START_INVISIBLE_BEFORE:</a>
<a name="ln2853">    case NFA_START_INVISIBLE_BEFORE_NEG:</a>
<a name="ln2854">      /* zero-width, out1 points to the END state */</a>
<a name="ln2855">      state = state-&gt;out1-&gt;out;</a>
<a name="ln2856">      continue;</a>
<a name="ln2857"> </a>
<a name="ln2858">    case NFA_BACKREF1:</a>
<a name="ln2859">    case NFA_BACKREF2:</a>
<a name="ln2860">    case NFA_BACKREF3:</a>
<a name="ln2861">    case NFA_BACKREF4:</a>
<a name="ln2862">    case NFA_BACKREF5:</a>
<a name="ln2863">    case NFA_BACKREF6:</a>
<a name="ln2864">    case NFA_BACKREF7:</a>
<a name="ln2865">    case NFA_BACKREF8:</a>
<a name="ln2866">    case NFA_BACKREF9:</a>
<a name="ln2867">    case NFA_ZREF1:</a>
<a name="ln2868">    case NFA_ZREF2:</a>
<a name="ln2869">    case NFA_ZREF3:</a>
<a name="ln2870">    case NFA_ZREF4:</a>
<a name="ln2871">    case NFA_ZREF5:</a>
<a name="ln2872">    case NFA_ZREF6:</a>
<a name="ln2873">    case NFA_ZREF7:</a>
<a name="ln2874">    case NFA_ZREF8:</a>
<a name="ln2875">    case NFA_ZREF9:</a>
<a name="ln2876">    case NFA_NEWL:</a>
<a name="ln2877">    case NFA_SKIP:</a>
<a name="ln2878">      /* unknown width */</a>
<a name="ln2879">      return -1;</a>
<a name="ln2880"> </a>
<a name="ln2881">    case NFA_BOL:</a>
<a name="ln2882">    case NFA_EOL:</a>
<a name="ln2883">    case NFA_BOF:</a>
<a name="ln2884">    case NFA_EOF:</a>
<a name="ln2885">    case NFA_BOW:</a>
<a name="ln2886">    case NFA_EOW:</a>
<a name="ln2887">    case NFA_MOPEN:</a>
<a name="ln2888">    case NFA_MOPEN1:</a>
<a name="ln2889">    case NFA_MOPEN2:</a>
<a name="ln2890">    case NFA_MOPEN3:</a>
<a name="ln2891">    case NFA_MOPEN4:</a>
<a name="ln2892">    case NFA_MOPEN5:</a>
<a name="ln2893">    case NFA_MOPEN6:</a>
<a name="ln2894">    case NFA_MOPEN7:</a>
<a name="ln2895">    case NFA_MOPEN8:</a>
<a name="ln2896">    case NFA_MOPEN9:</a>
<a name="ln2897">    case NFA_ZOPEN:</a>
<a name="ln2898">    case NFA_ZOPEN1:</a>
<a name="ln2899">    case NFA_ZOPEN2:</a>
<a name="ln2900">    case NFA_ZOPEN3:</a>
<a name="ln2901">    case NFA_ZOPEN4:</a>
<a name="ln2902">    case NFA_ZOPEN5:</a>
<a name="ln2903">    case NFA_ZOPEN6:</a>
<a name="ln2904">    case NFA_ZOPEN7:</a>
<a name="ln2905">    case NFA_ZOPEN8:</a>
<a name="ln2906">    case NFA_ZOPEN9:</a>
<a name="ln2907">    case NFA_ZCLOSE:</a>
<a name="ln2908">    case NFA_ZCLOSE1:</a>
<a name="ln2909">    case NFA_ZCLOSE2:</a>
<a name="ln2910">    case NFA_ZCLOSE3:</a>
<a name="ln2911">    case NFA_ZCLOSE4:</a>
<a name="ln2912">    case NFA_ZCLOSE5:</a>
<a name="ln2913">    case NFA_ZCLOSE6:</a>
<a name="ln2914">    case NFA_ZCLOSE7:</a>
<a name="ln2915">    case NFA_ZCLOSE8:</a>
<a name="ln2916">    case NFA_ZCLOSE9:</a>
<a name="ln2917">    case NFA_MCLOSE:</a>
<a name="ln2918">    case NFA_MCLOSE1:</a>
<a name="ln2919">    case NFA_MCLOSE2:</a>
<a name="ln2920">    case NFA_MCLOSE3:</a>
<a name="ln2921">    case NFA_MCLOSE4:</a>
<a name="ln2922">    case NFA_MCLOSE5:</a>
<a name="ln2923">    case NFA_MCLOSE6:</a>
<a name="ln2924">    case NFA_MCLOSE7:</a>
<a name="ln2925">    case NFA_MCLOSE8:</a>
<a name="ln2926">    case NFA_MCLOSE9:</a>
<a name="ln2927">    case NFA_NOPEN:</a>
<a name="ln2928">    case NFA_NCLOSE:</a>
<a name="ln2929"> </a>
<a name="ln2930">    case NFA_LNUM_GT:</a>
<a name="ln2931">    case NFA_LNUM_LT:</a>
<a name="ln2932">    case NFA_COL_GT:</a>
<a name="ln2933">    case NFA_COL_LT:</a>
<a name="ln2934">    case NFA_VCOL_GT:</a>
<a name="ln2935">    case NFA_VCOL_LT:</a>
<a name="ln2936">    case NFA_MARK_GT:</a>
<a name="ln2937">    case NFA_MARK_LT:</a>
<a name="ln2938">    case NFA_VISUAL:</a>
<a name="ln2939">    case NFA_LNUM:</a>
<a name="ln2940">    case NFA_CURSOR:</a>
<a name="ln2941">    case NFA_COL:</a>
<a name="ln2942">    case NFA_VCOL:</a>
<a name="ln2943">    case NFA_MARK:</a>
<a name="ln2944"> </a>
<a name="ln2945">    case NFA_ZSTART:</a>
<a name="ln2946">    case NFA_ZEND:</a>
<a name="ln2947">    case NFA_OPT_CHARS:</a>
<a name="ln2948">    case NFA_EMPTY:</a>
<a name="ln2949">    case NFA_START_PATTERN:</a>
<a name="ln2950">    case NFA_END_PATTERN:</a>
<a name="ln2951">    case NFA_COMPOSING:</a>
<a name="ln2952">    case NFA_END_COMPOSING:</a>
<a name="ln2953">      /* zero-width */</a>
<a name="ln2954">      break;</a>
<a name="ln2955"> </a>
<a name="ln2956">    default:</a>
<a name="ln2957">      if (state-&gt;c &lt; 0)</a>
<a name="ln2958">        /* don't know what this is */</a>
<a name="ln2959">        return -1;</a>
<a name="ln2960">      /* normal character */</a>
<a name="ln2961">      len += MB_CHAR2LEN(state-&gt;c);</a>
<a name="ln2962">      break;</a>
<a name="ln2963">    }</a>
<a name="ln2964"> </a>
<a name="ln2965">    /* normal way to continue */</a>
<a name="ln2966">    state = state-&gt;out;</a>
<a name="ln2967">  }</a>
<a name="ln2968"> </a>
<a name="ln2969">  /* unrecognized, &quot;cannot happen&quot; */</a>
<a name="ln2970">  return -1;</a>
<a name="ln2971">}</a>
<a name="ln2972"> </a>
<a name="ln2973">/*</a>
<a name="ln2974"> * Convert a postfix form into its equivalent NFA.</a>
<a name="ln2975"> * Return the NFA start state on success, NULL otherwise.</a>
<a name="ln2976"> */</a>
<a name="ln2977">static nfa_state_T *post2nfa(int *postfix, int *end, int nfa_calc_size)</a>
<a name="ln2978">{</a>
<a name="ln2979">  int         *p;</a>
<a name="ln2980">  int mopen;</a>
<a name="ln2981">  int mclose;</a>
<a name="ln2982">  Frag_T      *stack = NULL;</a>
<a name="ln2983">  Frag_T      *stackp = NULL;</a>
<a name="ln2984">  Frag_T      *stack_end = NULL;</a>
<a name="ln2985">  Frag_T e1;</a>
<a name="ln2986">  Frag_T e2;</a>
<a name="ln2987">  Frag_T e;</a>
<a name="ln2988">  nfa_state_T *s;</a>
<a name="ln2989">  nfa_state_T *s1;</a>
<a name="ln2990">  nfa_state_T *matchstate;</a>
<a name="ln2991">  nfa_state_T *ret = NULL;</a>
<a name="ln2992"> </a>
<a name="ln2993">  if (postfix == NULL)</a>
<a name="ln2994">    return NULL;</a>
<a name="ln2995"> </a>
<a name="ln2996">#define PUSH(s)     st_push((s), &amp;stackp, stack_end)</a>
<a name="ln2997">#define POP()       st_pop(&amp;stackp, stack); \</a>
<a name="ln2998">  if (stackp &lt; stack) { \</a>
<a name="ln2999">    st_error(postfix, end, p); \</a>
<a name="ln3000">    xfree(stack); \</a>
<a name="ln3001">    return NULL; \</a>
<a name="ln3002">  }</a>
<a name="ln3003"> </a>
<a name="ln3004">  if (nfa_calc_size == false) {</a>
<a name="ln3005">    // Allocate space for the stack. Max states on the stack: &quot;nstate&quot;.</a>
<a name="ln3006">    stack = xmalloc((nstate + 1) * sizeof(Frag_T));</a>
<a name="ln3007">    stackp = stack;</a>
<a name="ln3008">    stack_end = stack + (nstate + 1);</a>
<a name="ln3009">  }</a>
<a name="ln3010"> </a>
<a name="ln3011">  for (p = postfix; p &lt; end; ++p) {</a>
<a name="ln3012">    switch (*p) {</a>
<a name="ln3013">    case NFA_CONCAT:</a>
<a name="ln3014">      // Concatenation.</a>
<a name="ln3015">      // Pay attention: this operator does not exist in the r.e. itself</a>
<a name="ln3016">      // (it is implicit, really).  It is added when r.e. is translated</a>
<a name="ln3017">      // to postfix form in re2post().</a>
<a name="ln3018">      if (nfa_calc_size == true) {</a>
<a name="ln3019">        // nstate += 0;</a>
<a name="ln3020">        break;</a>
<a name="ln3021">      }</a>
<a name="ln3022">      e2 = POP();</a>
<a name="ln3023">      e1 = POP();</a>
<a name="ln3024">      patch(e1.out, e2.start);</a>
<a name="ln3025">      PUSH(frag(e1.start, e2.out));</a>
<a name="ln3026">      break;</a>
<a name="ln3027"> </a>
<a name="ln3028">    case NFA_OR:</a>
<a name="ln3029">      // Alternation</a>
<a name="ln3030">      if (nfa_calc_size == true) {</a>
<a name="ln3031">        nstate++;</a>
<a name="ln3032">        break;</a>
<a name="ln3033">      }</a>
<a name="ln3034">      e2 = POP();</a>
<a name="ln3035">      e1 = POP();</a>
<a name="ln3036">      s = alloc_state(NFA_SPLIT, e1.start, e2.start);</a>
<a name="ln3037">      if (s == NULL)</a>
<a name="ln3038">        goto theend;</a>
<a name="ln3039">      PUSH(frag(s, append(e1.out, e2.out)));</a>
<a name="ln3040">      break;</a>
<a name="ln3041"> </a>
<a name="ln3042">    case NFA_STAR:</a>
<a name="ln3043">      // Zero or more, prefer more</a>
<a name="ln3044">      if (nfa_calc_size == true) {</a>
<a name="ln3045">        nstate++;</a>
<a name="ln3046">        break;</a>
<a name="ln3047">      }</a>
<a name="ln3048">      e = POP();</a>
<a name="ln3049">      s = alloc_state(NFA_SPLIT, e.start, NULL);</a>
<a name="ln3050">      if (s == NULL)</a>
<a name="ln3051">        goto theend;</a>
<a name="ln3052">      patch(e.out, s);</a>
<a name="ln3053">      PUSH(frag(s, list1(&amp;s-&gt;out1)));</a>
<a name="ln3054">      break;</a>
<a name="ln3055"> </a>
<a name="ln3056">    case NFA_STAR_NONGREEDY:</a>
<a name="ln3057">      // Zero or more, prefer zero</a>
<a name="ln3058">      if (nfa_calc_size == true) {</a>
<a name="ln3059">        nstate++;</a>
<a name="ln3060">        break;</a>
<a name="ln3061">      }</a>
<a name="ln3062">      e = POP();</a>
<a name="ln3063">      s = alloc_state(NFA_SPLIT, NULL, e.start);</a>
<a name="ln3064">      if (s == NULL)</a>
<a name="ln3065">        goto theend;</a>
<a name="ln3066">      patch(e.out, s);</a>
<a name="ln3067">      PUSH(frag(s, list1(&amp;s-&gt;out)));</a>
<a name="ln3068">      break;</a>
<a name="ln3069"> </a>
<a name="ln3070">    case NFA_QUEST:</a>
<a name="ln3071">      // one or zero atoms=&gt; greedy match</a>
<a name="ln3072">      if (nfa_calc_size == true) {</a>
<a name="ln3073">        nstate++;</a>
<a name="ln3074">        break;</a>
<a name="ln3075">      }</a>
<a name="ln3076">      e = POP();</a>
<a name="ln3077">      s = alloc_state(NFA_SPLIT, e.start, NULL);</a>
<a name="ln3078">      if (s == NULL)</a>
<a name="ln3079">        goto theend;</a>
<a name="ln3080">      PUSH(frag(s, append(e.out, list1(&amp;s-&gt;out1))));</a>
<a name="ln3081">      break;</a>
<a name="ln3082"> </a>
<a name="ln3083">    case NFA_QUEST_NONGREEDY:</a>
<a name="ln3084">      // zero or one atoms =&gt; non-greedy match</a>
<a name="ln3085">      if (nfa_calc_size == true) {</a>
<a name="ln3086">        nstate++;</a>
<a name="ln3087">        break;</a>
<a name="ln3088">      }</a>
<a name="ln3089">      e = POP();</a>
<a name="ln3090">      s = alloc_state(NFA_SPLIT, NULL, e.start);</a>
<a name="ln3091">      if (s == NULL)</a>
<a name="ln3092">        goto theend;</a>
<a name="ln3093">      PUSH(frag(s, append(e.out, list1(&amp;s-&gt;out))));</a>
<a name="ln3094">      break;</a>
<a name="ln3095"> </a>
<a name="ln3096">    case NFA_END_COLL:</a>
<a name="ln3097">    case NFA_END_NEG_COLL:</a>
<a name="ln3098">      /* On the stack is the sequence starting with NFA_START_COLL or</a>
<a name="ln3099">       * NFA_START_NEG_COLL and all possible characters. Patch it to</a>
<a name="ln3100">       * add the output to the start. */</a>
<a name="ln3101">      if (nfa_calc_size == true) {</a>
<a name="ln3102">        nstate++;</a>
<a name="ln3103">        break;</a>
<a name="ln3104">      }</a>
<a name="ln3105">      e = POP();</a>
<a name="ln3106">      s = alloc_state(NFA_END_COLL, NULL, NULL);</a>
<a name="ln3107">      if (s == NULL)</a>
<a name="ln3108">        goto theend;</a>
<a name="ln3109">      patch(e.out, s);</a>
<a name="ln3110">      e.start-&gt;out1 = s;</a>
<a name="ln3111">      PUSH(frag(e.start, list1(&amp;s-&gt;out)));</a>
<a name="ln3112">      break;</a>
<a name="ln3113"> </a>
<a name="ln3114">    case NFA_RANGE:</a>
<a name="ln3115">      // Before this are two characters, the low and high end of a</a>
<a name="ln3116">      // range.  Turn them into two states with MIN and MAX.</a>
<a name="ln3117">      if (nfa_calc_size == true) {</a>
<a name="ln3118">        // nstate += 0;</a>
<a name="ln3119">        break;</a>
<a name="ln3120">      }</a>
<a name="ln3121">      e2 = POP();</a>
<a name="ln3122">      e1 = POP();</a>
<a name="ln3123">      e2.start-&gt;val = e2.start-&gt;c;</a>
<a name="ln3124">      e2.start-&gt;c = NFA_RANGE_MAX;</a>
<a name="ln3125">      e1.start-&gt;val = e1.start-&gt;c;</a>
<a name="ln3126">      e1.start-&gt;c = NFA_RANGE_MIN;</a>
<a name="ln3127">      patch(e1.out, e2.start);</a>
<a name="ln3128">      PUSH(frag(e1.start, e2.out));</a>
<a name="ln3129">      break;</a>
<a name="ln3130"> </a>
<a name="ln3131">    case NFA_EMPTY:</a>
<a name="ln3132">      // 0-length, used in a repetition with max/min count of 0</a>
<a name="ln3133">      if (nfa_calc_size == true) {</a>
<a name="ln3134">        nstate++;</a>
<a name="ln3135">        break;</a>
<a name="ln3136">      }</a>
<a name="ln3137">      s = alloc_state(NFA_EMPTY, NULL, NULL);</a>
<a name="ln3138">      if (s == NULL)</a>
<a name="ln3139">        goto theend;</a>
<a name="ln3140">      PUSH(frag(s, list1(&amp;s-&gt;out)));</a>
<a name="ln3141">      break;</a>
<a name="ln3142"> </a>
<a name="ln3143">    case NFA_OPT_CHARS:</a>
<a name="ln3144">    {</a>
<a name="ln3145">      int n;</a>
<a name="ln3146"> </a>
<a name="ln3147">      // \%[abc] implemented as:</a>
<a name="ln3148">      //    NFA_SPLIT</a>
<a name="ln3149">      //    +-CHAR(a)</a>
<a name="ln3150">      //    | +-NFA_SPLIT</a>
<a name="ln3151">      //    |   +-CHAR(b)</a>
<a name="ln3152">      //    |   | +-NFA_SPLIT</a>
<a name="ln3153">      //    |   |   +-CHAR(c)</a>
<a name="ln3154">      //    |   |   | +-next</a>
<a name="ln3155">      //    |   |   +- next</a>
<a name="ln3156">      //    |   +- next</a>
<a name="ln3157">      //    +- next</a>
<a name="ln3158">      n = *++p;  // get number of characters</a>
<a name="ln3159">      if (nfa_calc_size == true) {</a>
<a name="ln3160">        nstate += n;</a>
<a name="ln3161">        break;</a>
<a name="ln3162">      }</a>
<a name="ln3163">      s = NULL;       /* avoid compiler warning */</a>
<a name="ln3164">      e1.out = NULL;       /* stores list with out1's */</a>
<a name="ln3165">      s1 = NULL;       /* previous NFA_SPLIT to connect to */</a>
<a name="ln3166">      while (n-- &gt; 0) {</a>
<a name="ln3167">        e = POP();         /* get character */</a>
<a name="ln3168">        s = alloc_state(NFA_SPLIT, e.start, NULL);</a>
<a name="ln3169">        if (s == NULL)</a>
<a name="ln3170">          goto theend;</a>
<a name="ln3171">        if (e1.out == NULL)</a>
<a name="ln3172">          e1 = e;</a>
<a name="ln3173">        patch(e.out, s1);</a>
<a name="ln3174">        append(e1.out, list1(&amp;s-&gt;out1));</a>
<a name="ln3175">        s1 = s;</a>
<a name="ln3176">      }</a>
<a name="ln3177">      PUSH(frag(s, e1.out));</a>
<a name="ln3178">      break;</a>
<a name="ln3179">    }</a>
<a name="ln3180"> </a>
<a name="ln3181">    case NFA_PREV_ATOM_NO_WIDTH:</a>
<a name="ln3182">    case NFA_PREV_ATOM_NO_WIDTH_NEG:</a>
<a name="ln3183">    case NFA_PREV_ATOM_JUST_BEFORE:</a>
<a name="ln3184">    case NFA_PREV_ATOM_JUST_BEFORE_NEG:</a>
<a name="ln3185">    case NFA_PREV_ATOM_LIKE_PATTERN:</a>
<a name="ln3186">    {</a>
<a name="ln3187">      int before = (*p == NFA_PREV_ATOM_JUST_BEFORE</a>
<a name="ln3188">                    || *p == NFA_PREV_ATOM_JUST_BEFORE_NEG);</a>
<a name="ln3189">      int pattern = (*p == NFA_PREV_ATOM_LIKE_PATTERN);</a>
<a name="ln3190">      int start_state;</a>
<a name="ln3191">      int end_state;</a>
<a name="ln3192">      int n = 0;</a>
<a name="ln3193">      nfa_state_T *zend;</a>
<a name="ln3194">      nfa_state_T *skip;</a>
<a name="ln3195"> </a>
<a name="ln3196">      switch (*p) {</a>
<a name="ln3197">      case NFA_PREV_ATOM_NO_WIDTH:</a>
<a name="ln3198">        start_state = NFA_START_INVISIBLE;</a>
<a name="ln3199">        end_state = NFA_END_INVISIBLE;</a>
<a name="ln3200">        break;</a>
<a name="ln3201">      case NFA_PREV_ATOM_NO_WIDTH_NEG:</a>
<a name="ln3202">        start_state = NFA_START_INVISIBLE_NEG;</a>
<a name="ln3203">        end_state = NFA_END_INVISIBLE_NEG;</a>
<a name="ln3204">        break;</a>
<a name="ln3205">      case NFA_PREV_ATOM_JUST_BEFORE:</a>
<a name="ln3206">        start_state = NFA_START_INVISIBLE_BEFORE;</a>
<a name="ln3207">        end_state = NFA_END_INVISIBLE;</a>
<a name="ln3208">        break;</a>
<a name="ln3209">      case NFA_PREV_ATOM_JUST_BEFORE_NEG:</a>
<a name="ln3210">        start_state = NFA_START_INVISIBLE_BEFORE_NEG;</a>
<a name="ln3211">        end_state = NFA_END_INVISIBLE_NEG;</a>
<a name="ln3212">        break;</a>
<a name="ln3213">      default:           /* NFA_PREV_ATOM_LIKE_PATTERN: */</a>
<a name="ln3214">        start_state = NFA_START_PATTERN;</a>
<a name="ln3215">        end_state = NFA_END_PATTERN;</a>
<a name="ln3216">        break;</a>
<a name="ln3217">      }</a>
<a name="ln3218"> </a>
<a name="ln3219">      if (before)</a>
<a name="ln3220">        n = *++p;         /* get the count */</a>
<a name="ln3221"> </a>
<a name="ln3222">      /* The \@= operator: match the preceding atom with zero width.</a>
<a name="ln3223">       * The \@! operator: no match for the preceding atom.</a>
<a name="ln3224">       * The \@&lt;= operator: match for the preceding atom.</a>
<a name="ln3225">       * The \@&lt;! operator: no match for the preceding atom.</a>
<a name="ln3226">       * Surrounds the preceding atom with START_INVISIBLE and</a>
<a name="ln3227">       * END_INVISIBLE, similarly to MOPEN. */</a>
<a name="ln3228"> </a>
<a name="ln3229">      if (nfa_calc_size == true) {</a>
<a name="ln3230">        nstate += pattern ? 4 : 2;</a>
<a name="ln3231">        break;</a>
<a name="ln3232">      }</a>
<a name="ln3233">      e = POP();</a>
<a name="ln3234">      s1 = alloc_state(end_state, NULL, NULL);</a>
<a name="ln3235">      if (s1 == NULL)</a>
<a name="ln3236">        goto theend;</a>
<a name="ln3237"> </a>
<a name="ln3238">      s = alloc_state(start_state, e.start, s1);</a>
<a name="ln3239">      if (s == NULL)</a>
<a name="ln3240">        goto theend;</a>
<a name="ln3241">      if (pattern) {</a>
<a name="ln3242">        /* NFA_ZEND -&gt; NFA_END_PATTERN -&gt; NFA_SKIP -&gt; what follows. */</a>
<a name="ln3243">        skip = alloc_state(NFA_SKIP, NULL, NULL);</a>
<a name="ln3244">        if (skip == NULL) {</a>
<a name="ln3245">          goto theend;</a>
<a name="ln3246">        }</a>
<a name="ln3247">        zend = alloc_state(NFA_ZEND, s1, NULL);</a>
<a name="ln3248">        if (zend == NULL) {</a>
<a name="ln3249">          goto theend;</a>
<a name="ln3250">        }</a>
<a name="ln3251">        s1-&gt;out= skip;</a>
<a name="ln3252">        patch(e.out, zend);</a>
<a name="ln3253">        PUSH(frag(s, list1(&amp;skip-&gt;out)));</a>
<a name="ln3254">      } else {</a>
<a name="ln3255">        patch(e.out, s1);</a>
<a name="ln3256">        PUSH(frag(s, list1(&amp;s1-&gt;out)));</a>
<a name="ln3257">        if (before) {</a>
<a name="ln3258">          if (n &lt;= 0)</a>
<a name="ln3259">            /* See if we can guess the maximum width, it avoids a</a>
<a name="ln3260">             * lot of pointless tries. */</a>
<a name="ln3261">            n = nfa_max_width(e.start, 0);</a>
<a name="ln3262">          s-&gt;val = n;           /* store the count */</a>
<a name="ln3263">        }</a>
<a name="ln3264">      }</a>
<a name="ln3265">      break;</a>
<a name="ln3266">    }</a>
<a name="ln3267"> </a>
<a name="ln3268">    case NFA_COMPOSING:         // char with composing char</a>
<a name="ln3269">      FALLTHROUGH;</a>
<a name="ln3270"> </a>
<a name="ln3271">    case NFA_MOPEN:     /* \( \) Submatch */</a>
<a name="ln3272">    case NFA_MOPEN1:</a>
<a name="ln3273">    case NFA_MOPEN2:</a>
<a name="ln3274">    case NFA_MOPEN3:</a>
<a name="ln3275">    case NFA_MOPEN4:</a>
<a name="ln3276">    case NFA_MOPEN5:</a>
<a name="ln3277">    case NFA_MOPEN6:</a>
<a name="ln3278">    case NFA_MOPEN7:</a>
<a name="ln3279">    case NFA_MOPEN8:</a>
<a name="ln3280">    case NFA_MOPEN9:</a>
<a name="ln3281">    case NFA_ZOPEN:     /* \z( \) Submatch */</a>
<a name="ln3282">    case NFA_ZOPEN1:</a>
<a name="ln3283">    case NFA_ZOPEN2:</a>
<a name="ln3284">    case NFA_ZOPEN3:</a>
<a name="ln3285">    case NFA_ZOPEN4:</a>
<a name="ln3286">    case NFA_ZOPEN5:</a>
<a name="ln3287">    case NFA_ZOPEN6:</a>
<a name="ln3288">    case NFA_ZOPEN7:</a>
<a name="ln3289">    case NFA_ZOPEN8:</a>
<a name="ln3290">    case NFA_ZOPEN9:</a>
<a name="ln3291">    case NFA_NOPEN:     // \%( \) &quot;Invisible Submatch&quot;</a>
<a name="ln3292">      if (nfa_calc_size == true) {</a>
<a name="ln3293">        nstate += 2;</a>
<a name="ln3294">        break;</a>
<a name="ln3295">      }</a>
<a name="ln3296"> </a>
<a name="ln3297">      mopen = *p;</a>
<a name="ln3298">      switch (*p) {</a>
<a name="ln3299">      case NFA_NOPEN: mclose = NFA_NCLOSE; break;</a>
<a name="ln3300">      case NFA_ZOPEN: mclose = NFA_ZCLOSE; break;</a>
<a name="ln3301">      case NFA_ZOPEN1: mclose = NFA_ZCLOSE1; break;</a>
<a name="ln3302">      case NFA_ZOPEN2: mclose = NFA_ZCLOSE2; break;</a>
<a name="ln3303">      case NFA_ZOPEN3: mclose = NFA_ZCLOSE3; break;</a>
<a name="ln3304">      case NFA_ZOPEN4: mclose = NFA_ZCLOSE4; break;</a>
<a name="ln3305">      case NFA_ZOPEN5: mclose = NFA_ZCLOSE5; break;</a>
<a name="ln3306">      case NFA_ZOPEN6: mclose = NFA_ZCLOSE6; break;</a>
<a name="ln3307">      case NFA_ZOPEN7: mclose = NFA_ZCLOSE7; break;</a>
<a name="ln3308">      case NFA_ZOPEN8: mclose = NFA_ZCLOSE8; break;</a>
<a name="ln3309">      case NFA_ZOPEN9: mclose = NFA_ZCLOSE9; break;</a>
<a name="ln3310">      case NFA_COMPOSING: mclose = NFA_END_COMPOSING; break;</a>
<a name="ln3311">      default:</a>
<a name="ln3312">        /* NFA_MOPEN, NFA_MOPEN1 .. NFA_MOPEN9 */</a>
<a name="ln3313">        mclose = *p + NSUBEXP;</a>
<a name="ln3314">        break;</a>
<a name="ln3315">      }</a>
<a name="ln3316"> </a>
<a name="ln3317">      /* Allow &quot;NFA_MOPEN&quot; as a valid postfix representation for</a>
<a name="ln3318">       * the empty regexp &quot;&quot;. In this case, the NFA will be</a>
<a name="ln3319">       * NFA_MOPEN -&gt; NFA_MCLOSE. Note that this also allows</a>
<a name="ln3320">       * empty groups of parenthesis, and empty mbyte chars */</a>
<a name="ln3321">      if (stackp == stack) {</a>
<a name="ln3322">        s = alloc_state(mopen, NULL, NULL);</a>
<a name="ln3323">        if (s == NULL)</a>
<a name="ln3324">          goto theend;</a>
<a name="ln3325">        s1 = alloc_state(mclose, NULL, NULL);</a>
<a name="ln3326">        if (s1 == NULL)</a>
<a name="ln3327">          goto theend;</a>
<a name="ln3328">        patch(list1(&amp;s-&gt;out), s1);</a>
<a name="ln3329">        PUSH(frag(s, list1(&amp;s1-&gt;out)));</a>
<a name="ln3330">        break;</a>
<a name="ln3331">      }</a>
<a name="ln3332"> </a>
<a name="ln3333">      /* At least one node was emitted before NFA_MOPEN, so</a>
<a name="ln3334">       * at least one node will be between NFA_MOPEN and NFA_MCLOSE */</a>
<a name="ln3335">      e = POP();</a>
<a name="ln3336">      s = alloc_state(mopen, e.start, NULL);         /* `(' */</a>
<a name="ln3337">      if (s == NULL)</a>
<a name="ln3338">        goto theend;</a>
<a name="ln3339"> </a>
<a name="ln3340">      s1 = alloc_state(mclose, NULL, NULL);         /* `)' */</a>
<a name="ln3341">      if (s1 == NULL)</a>
<a name="ln3342">        goto theend;</a>
<a name="ln3343">      patch(e.out, s1);</a>
<a name="ln3344"> </a>
<a name="ln3345">      if (mopen == NFA_COMPOSING)</a>
<a name="ln3346">        /* COMPOSING-&gt;out1 = END_COMPOSING */</a>
<a name="ln3347">        patch(list1(&amp;s-&gt;out1), s1);</a>
<a name="ln3348"> </a>
<a name="ln3349">      PUSH(frag(s, list1(&amp;s1-&gt;out)));</a>
<a name="ln3350">      break;</a>
<a name="ln3351"> </a>
<a name="ln3352">    case NFA_BACKREF1:</a>
<a name="ln3353">    case NFA_BACKREF2:</a>
<a name="ln3354">    case NFA_BACKREF3:</a>
<a name="ln3355">    case NFA_BACKREF4:</a>
<a name="ln3356">    case NFA_BACKREF5:</a>
<a name="ln3357">    case NFA_BACKREF6:</a>
<a name="ln3358">    case NFA_BACKREF7:</a>
<a name="ln3359">    case NFA_BACKREF8:</a>
<a name="ln3360">    case NFA_BACKREF9:</a>
<a name="ln3361">    case NFA_ZREF1:</a>
<a name="ln3362">    case NFA_ZREF2:</a>
<a name="ln3363">    case NFA_ZREF3:</a>
<a name="ln3364">    case NFA_ZREF4:</a>
<a name="ln3365">    case NFA_ZREF5:</a>
<a name="ln3366">    case NFA_ZREF6:</a>
<a name="ln3367">    case NFA_ZREF7:</a>
<a name="ln3368">    case NFA_ZREF8:</a>
<a name="ln3369">    case NFA_ZREF9:</a>
<a name="ln3370">      if (nfa_calc_size == true) {</a>
<a name="ln3371">        nstate += 2;</a>
<a name="ln3372">        break;</a>
<a name="ln3373">      }</a>
<a name="ln3374">      s = alloc_state(*p, NULL, NULL);</a>
<a name="ln3375">      if (s == NULL)</a>
<a name="ln3376">        goto theend;</a>
<a name="ln3377">      s1 = alloc_state(NFA_SKIP, NULL, NULL);</a>
<a name="ln3378">      if (s1 == NULL)</a>
<a name="ln3379">        goto theend;</a>
<a name="ln3380">      patch(list1(&amp;s-&gt;out), s1);</a>
<a name="ln3381">      PUSH(frag(s, list1(&amp;s1-&gt;out)));</a>
<a name="ln3382">      break;</a>
<a name="ln3383"> </a>
<a name="ln3384">    case NFA_LNUM:</a>
<a name="ln3385">    case NFA_LNUM_GT:</a>
<a name="ln3386">    case NFA_LNUM_LT:</a>
<a name="ln3387">    case NFA_VCOL:</a>
<a name="ln3388">    case NFA_VCOL_GT:</a>
<a name="ln3389">    case NFA_VCOL_LT:</a>
<a name="ln3390">    case NFA_COL:</a>
<a name="ln3391">    case NFA_COL_GT:</a>
<a name="ln3392">    case NFA_COL_LT:</a>
<a name="ln3393">    case NFA_MARK:</a>
<a name="ln3394">    case NFA_MARK_GT:</a>
<a name="ln3395">    case NFA_MARK_LT:</a>
<a name="ln3396">    {</a>
<a name="ln3397">      int n = *++p;       /* lnum, col or mark name */</a>
<a name="ln3398"> </a>
<a name="ln3399">      if (nfa_calc_size == true) {</a>
<a name="ln3400">        nstate += 1;</a>
<a name="ln3401">        break;</a>
<a name="ln3402">      }</a>
<a name="ln3403">      s = alloc_state(p[-1], NULL, NULL);</a>
<a name="ln3404">      if (s == NULL)</a>
<a name="ln3405">        goto theend;</a>
<a name="ln3406">      s-&gt;val = n;</a>
<a name="ln3407">      PUSH(frag(s, list1(&amp;s-&gt;out)));</a>
<a name="ln3408">      break;</a>
<a name="ln3409">    }</a>
<a name="ln3410"> </a>
<a name="ln3411">    case NFA_ZSTART:</a>
<a name="ln3412">    case NFA_ZEND:</a>
<a name="ln3413">    default:</a>
<a name="ln3414">      // Operands</a>
<a name="ln3415">      if (nfa_calc_size == true) {</a>
<a name="ln3416">        nstate++;</a>
<a name="ln3417">        break;</a>
<a name="ln3418">      }</a>
<a name="ln3419">      s = alloc_state(*p, NULL, NULL);</a>
<a name="ln3420">      if (s == NULL)</a>
<a name="ln3421">        goto theend;</a>
<a name="ln3422">      PUSH(frag(s, list1(&amp;s-&gt;out)));</a>
<a name="ln3423">      break;</a>
<a name="ln3424"> </a>
<a name="ln3425">    }     /* switch(*p) */</a>
<a name="ln3426"> </a>
<a name="ln3427">  }   /* for(p = postfix; *p; ++p) */</a>
<a name="ln3428"> </a>
<a name="ln3429">  if (nfa_calc_size == true) {</a>
<a name="ln3430">    nstate++;</a>
<a name="ln3431">    goto theend;        /* Return value when counting size is ignored anyway */</a>
<a name="ln3432">  }</a>
<a name="ln3433"> </a>
<a name="ln3434">  e = POP();</a>
<a name="ln3435">  if (stackp != stack) {</a>
<a name="ln3436">    xfree(stack);</a>
<a name="ln3437">    EMSG_RET_NULL(_(&quot;E875: (NFA regexp) (While converting from postfix to NFA),&quot;</a>
<a name="ln3438">                    &quot;too many states left on stack&quot;));</a>
<a name="ln3439">  }</a>
<a name="ln3440"> </a>
<a name="ln3441">  if (istate &gt;= nstate) {</a>
<a name="ln3442">    xfree(stack);</a>
<a name="ln3443">    EMSG_RET_NULL(_(&quot;E876: (NFA regexp) &quot;</a>
<a name="ln3444">                    &quot;Not enough space to store the whole NFA &quot;));</a>
<a name="ln3445">  }</a>
<a name="ln3446"> </a>
<a name="ln3447">  matchstate = &amp;state_ptr[istate++];   /* the match state */</a>
<a name="ln3448">  matchstate-&gt;c = NFA_MATCH;</a>
<a name="ln3449">  matchstate-&gt;out = matchstate-&gt;out1 = NULL;</a>
<a name="ln3450">  matchstate-&gt;id = 0;</a>
<a name="ln3451"> </a>
<a name="ln3452">  patch(e.out, matchstate);</a>
<a name="ln3453">  ret = e.start;</a>
<a name="ln3454"> </a>
<a name="ln3455">theend:</a>
<a name="ln3456">  xfree(stack);</a>
<a name="ln3457">  return ret;</a>
<a name="ln3458"> </a>
<a name="ln3459">#undef POP1</a>
<a name="ln3460">#undef PUSH1</a>
<a name="ln3461">#undef POP2</a>
<a name="ln3462">#undef PUSH2</a>
<a name="ln3463">#undef POP</a>
<a name="ln3464">#undef PUSH</a>
<a name="ln3465">}</a>
<a name="ln3466"> </a>
<a name="ln3467">/*</a>
<a name="ln3468"> * After building the NFA program, inspect it to add optimization hints.</a>
<a name="ln3469"> */</a>
<a name="ln3470">static void nfa_postprocess(nfa_regprog_T *prog)</a>
<a name="ln3471">{</a>
<a name="ln3472">  int i;</a>
<a name="ln3473">  int c;</a>
<a name="ln3474"> </a>
<a name="ln3475">  for (i = 0; i &lt; prog-&gt;nstate; ++i) {</a>
<a name="ln3476">    c = prog-&gt;state[i].c;</a>
<a name="ln3477">    if (c == NFA_START_INVISIBLE</a>
<a name="ln3478">        || c == NFA_START_INVISIBLE_NEG</a>
<a name="ln3479">        || c == NFA_START_INVISIBLE_BEFORE</a>
<a name="ln3480">        || c == NFA_START_INVISIBLE_BEFORE_NEG) {</a>
<a name="ln3481">      int directly;</a>
<a name="ln3482"> </a>
<a name="ln3483">      // Do it directly when what follows is possibly the end of the</a>
<a name="ln3484">      // match.</a>
<a name="ln3485">      if (match_follows(prog-&gt;state[i].out1-&gt;out, 0)) {</a>
<a name="ln3486">        directly = true;</a>
<a name="ln3487">      } else {</a>
<a name="ln3488">        int ch_invisible = failure_chance(prog-&gt;state[i].out, 0);</a>
<a name="ln3489">        int ch_follows = failure_chance(prog-&gt;state[i].out1-&gt;out, 0);</a>
<a name="ln3490"> </a>
<a name="ln3491">        /* Postpone when the invisible match is expensive or has a</a>
<a name="ln3492">         * lower chance of failing. */</a>
<a name="ln3493">        if (c == NFA_START_INVISIBLE_BEFORE</a>
<a name="ln3494">            || c == NFA_START_INVISIBLE_BEFORE_NEG) {</a>
<a name="ln3495">          /* &quot;before&quot; matches are very expensive when</a>
<a name="ln3496">           * unbounded, always prefer what follows then,</a>
<a name="ln3497">           * unless what follows will always match.</a>
<a name="ln3498">           * Otherwise strongly prefer what follows. */</a>
<a name="ln3499">          if (prog-&gt;state[i].val &lt;= 0 &amp;&amp; ch_follows &gt; 0) {</a>
<a name="ln3500">            directly = false;</a>
<a name="ln3501">          } else {</a>
<a name="ln3502">            directly = ch_follows * 10 &lt; ch_invisible;</a>
<a name="ln3503">          }</a>
<a name="ln3504">        } else {</a>
<a name="ln3505">          /* normal invisible, first do the one with the</a>
<a name="ln3506">           * highest failure chance */</a>
<a name="ln3507">          directly = ch_follows &lt; ch_invisible;</a>
<a name="ln3508">        }</a>
<a name="ln3509">      }</a>
<a name="ln3510">      if (directly)</a>
<a name="ln3511">        /* switch to the _FIRST state */</a>
<a name="ln3512">        ++prog-&gt;state[i].c;</a>
<a name="ln3513">    }</a>
<a name="ln3514">  }</a>
<a name="ln3515">}</a>
<a name="ln3516"> </a>
<a name="ln3517">/****************************************************************</a>
<a name="ln3518">* NFA execution code.</a>
<a name="ln3519">****************************************************************/</a>
<a name="ln3520"> </a>
<a name="ln3521">/* Values for done in nfa_pim_T. */</a>
<a name="ln3522">#define NFA_PIM_UNUSED   0      /* pim not used */</a>
<a name="ln3523">#define NFA_PIM_TODO     1      /* pim not done yet */</a>
<a name="ln3524">#define NFA_PIM_MATCH    2      /* pim executed, matches */</a>
<a name="ln3525">#define NFA_PIM_NOMATCH  3      /* pim executed, no match */</a>
<a name="ln3526"> </a>
<a name="ln3527"> </a>
<a name="ln3528">#ifdef REGEXP_DEBUG</a>
<a name="ln3529">static void log_subsexpr(regsubs_T *subs)</a>
<a name="ln3530">{</a>
<a name="ln3531">  log_subexpr(&amp;subs-&gt;norm);</a>
<a name="ln3532">  if (rex.nfa_has_zsubexpr) {</a>
<a name="ln3533">    log_subexpr(&amp;subs-&gt;synt);</a>
<a name="ln3534">  }</a>
<a name="ln3535">}</a>
<a name="ln3536"> </a>
<a name="ln3537">static void log_subexpr(regsub_T *sub)</a>
<a name="ln3538">{</a>
<a name="ln3539">  int j;</a>
<a name="ln3540"> </a>
<a name="ln3541">  for (j = 0; j &lt; sub-&gt;in_use; j++)</a>
<a name="ln3542">    if (REG_MULTI)</a>
<a name="ln3543">      fprintf(log_fd, &quot;*** group %d, start: c=%d, l=%d, end: c=%d, l=%d\n&quot;,</a>
<a name="ln3544">          j,</a>
<a name="ln3545">          sub-&gt;list.multi[j].start_col,</a>
<a name="ln3546">          (int)sub-&gt;list.multi[j].start_lnum,</a>
<a name="ln3547">          sub-&gt;list.multi[j].end_col,</a>
<a name="ln3548">          (int)sub-&gt;list.multi[j].end_lnum);</a>
<a name="ln3549">    else {</a>
<a name="ln3550">      char *s = (char *)sub-&gt;list.line[j].start;</a>
<a name="ln3551">      char *e = (char *)sub-&gt;list.line[j].end;</a>
<a name="ln3552"> </a>
<a name="ln3553">      fprintf(log_fd, &quot;*** group %d, start: \&quot;%s\&quot;, end: \&quot;%s\&quot;\n&quot;,</a>
<a name="ln3554">          j,</a>
<a name="ln3555">          s == NULL ? &quot;NULL&quot; : s,</a>
<a name="ln3556">          e == NULL ? &quot;NULL&quot; : e);</a>
<a name="ln3557">    }</a>
<a name="ln3558">}</a>
<a name="ln3559"> </a>
<a name="ln3560">static char *pim_info(const nfa_pim_T *pim)</a>
<a name="ln3561">{</a>
<a name="ln3562">  static char buf[30];</a>
<a name="ln3563"> </a>
<a name="ln3564">  if (pim == NULL || pim-&gt;result == NFA_PIM_UNUSED) {</a>
<a name="ln3565">    buf[0] = NUL;</a>
<a name="ln3566">  } else {</a>
<a name="ln3567">    snprintf(buf, sizeof(buf), &quot; PIM col %d&quot;,</a>
<a name="ln3568">             REG_MULTI</a>
<a name="ln3569">             ? (int)pim-&gt;end.pos.col</a>
<a name="ln3570">             : (int)(pim-&gt;end.ptr - rex.input));</a>
<a name="ln3571">  }</a>
<a name="ln3572">  return buf;</a>
<a name="ln3573">}</a>
<a name="ln3574"> </a>
<a name="ln3575">#endif</a>
<a name="ln3576"> </a>
<a name="ln3577">// Used during execution: whether a match has been found.</a>
<a name="ln3578">static int nfa_match;</a>
<a name="ln3579">static proftime_T *nfa_time_limit;</a>
<a name="ln3580">static int *nfa_timed_out;</a>
<a name="ln3581">static int nfa_time_count;</a>
<a name="ln3582"> </a>
<a name="ln3583">// Copy postponed invisible match info from &quot;from&quot; to &quot;to&quot;.</a>
<a name="ln3584">static void copy_pim(nfa_pim_T *to, nfa_pim_T *from)</a>
<a name="ln3585">{</a>
<a name="ln3586">  to-&gt;result = from-&gt;result;</a>
<a name="ln3587">  to-&gt;state = from-&gt;state;</a>
<a name="ln3588">  copy_sub(&amp;to-&gt;subs.norm, &amp;from-&gt;subs.norm);</a>
<a name="ln3589">  if (rex.nfa_has_zsubexpr) {</a>
<a name="ln3590">    copy_sub(&amp;to-&gt;subs.synt, &amp;from-&gt;subs.synt);</a>
<a name="ln3591">  }</a>
<a name="ln3592">  to-&gt;end = from-&gt;end;</a>
<a name="ln3593">}</a>
<a name="ln3594"> </a>
<a name="ln3595">static void clear_sub(regsub_T *sub)</a>
<a name="ln3596">{</a>
<a name="ln3597">  if (REG_MULTI) {</a>
<a name="ln3598">    // Use 0xff to set lnum to -1</a>
<a name="ln3599">    memset(sub-&gt;list.multi, 0xff,</a>
<a name="ln3600">           sizeof(struct multipos) * rex.nfa_nsubexpr);</a>
<a name="ln3601">  } else {</a>
<a name="ln3602">    memset(sub-&gt;list.line, 0, sizeof(struct linepos) * rex.nfa_nsubexpr);</a>
<a name="ln3603">  }</a>
<a name="ln3604">  sub-&gt;in_use = 0;</a>
<a name="ln3605">}</a>
<a name="ln3606"> </a>
<a name="ln3607">/*</a>
<a name="ln3608"> * Copy the submatches from &quot;from&quot; to &quot;to&quot;.</a>
<a name="ln3609"> */</a>
<a name="ln3610">static void copy_sub(regsub_T *to, regsub_T *from)</a>
<a name="ln3611">{</a>
<a name="ln3612">  to-&gt;in_use = from-&gt;in_use;</a>
<a name="ln3613">  if (from-&gt;in_use &gt; 0) {</a>
<a name="ln3614">    /* Copy the match start and end positions. */</a>
<a name="ln3615">    if (REG_MULTI)</a>
<a name="ln3616">      memmove(&amp;to-&gt;list.multi[0],</a>
<a name="ln3617">          &amp;from-&gt;list.multi[0],</a>
<a name="ln3618">          sizeof(struct multipos) * from-&gt;in_use);</a>
<a name="ln3619">    else</a>
<a name="ln3620">      memmove(&amp;to-&gt;list.line[0],</a>
<a name="ln3621">          &amp;from-&gt;list.line[0],</a>
<a name="ln3622">          sizeof(struct linepos) * from-&gt;in_use);</a>
<a name="ln3623">  }</a>
<a name="ln3624">}</a>
<a name="ln3625"> </a>
<a name="ln3626">/*</a>
<a name="ln3627"> * Like copy_sub() but exclude the main match.</a>
<a name="ln3628"> */</a>
<a name="ln3629">static void copy_sub_off(regsub_T *to, regsub_T *from)</a>
<a name="ln3630">{</a>
<a name="ln3631">  if (to-&gt;in_use &lt; from-&gt;in_use)</a>
<a name="ln3632">    to-&gt;in_use = from-&gt;in_use;</a>
<a name="ln3633">  if (from-&gt;in_use &gt; 1) {</a>
<a name="ln3634">    /* Copy the match start and end positions. */</a>
<a name="ln3635">    if (REG_MULTI)</a>
<a name="ln3636">      memmove(&amp;to-&gt;list.multi[1],</a>
<a name="ln3637">          &amp;from-&gt;list.multi[1],</a>
<a name="ln3638">          sizeof(struct multipos) * (from-&gt;in_use - 1));</a>
<a name="ln3639">    else</a>
<a name="ln3640">      memmove(&amp;to-&gt;list.line[1],</a>
<a name="ln3641">          &amp;from-&gt;list.line[1],</a>
<a name="ln3642">          sizeof(struct linepos) * (from-&gt;in_use - 1));</a>
<a name="ln3643">  }</a>
<a name="ln3644">}</a>
<a name="ln3645"> </a>
<a name="ln3646">/*</a>
<a name="ln3647"> * Like copy_sub() but only do the end of the main match if \ze is present.</a>
<a name="ln3648"> */</a>
<a name="ln3649">static void copy_ze_off(regsub_T *to, regsub_T *from)</a>
<a name="ln3650">{</a>
<a name="ln3651">  if (rex.nfa_has_zend) {</a>
<a name="ln3652">    if (REG_MULTI) {</a>
<a name="ln3653">      if (from-&gt;list.multi[0].end_lnum &gt;= 0){</a>
<a name="ln3654">        to-&gt;list.multi[0].end_lnum = from-&gt;list.multi[0].end_lnum;</a>
<a name="ln3655">        to-&gt;list.multi[0].end_col = from-&gt;list.multi[0].end_col;</a>
<a name="ln3656">      }</a>
<a name="ln3657">    } else {</a>
<a name="ln3658">      if (from-&gt;list.line[0].end != NULL)</a>
<a name="ln3659">        to-&gt;list.line[0].end = from-&gt;list.line[0].end;</a>
<a name="ln3660">    }</a>
<a name="ln3661">  }</a>
<a name="ln3662">}</a>
<a name="ln3663"> </a>
<a name="ln3664">// Return true if &quot;sub1&quot; and &quot;sub2&quot; have the same start positions.</a>
<a name="ln3665">// When using back-references also check the end position.</a>
<a name="ln3666">static bool sub_equal(regsub_T *sub1, regsub_T *sub2)</a>
<a name="ln3667">{</a>
<a name="ln3668">  int i;</a>
<a name="ln3669">  int todo;</a>
<a name="ln3670">  linenr_T s1;</a>
<a name="ln3671">  linenr_T s2;</a>
<a name="ln3672">  char_u      *sp1;</a>
<a name="ln3673">  char_u      *sp2;</a>
<a name="ln3674"> </a>
<a name="ln3675">  todo = sub1-&gt;in_use &gt; sub2-&gt;in_use ? sub1-&gt;in_use : sub2-&gt;in_use;</a>
<a name="ln3676">  if (REG_MULTI) {</a>
<a name="ln3677">    for (i = 0; i &lt; todo; i++) {</a>
<a name="ln3678">      if (i &lt; sub1-&gt;in_use) {</a>
<a name="ln3679">        s1 = sub1-&gt;list.multi[i].start_lnum;</a>
<a name="ln3680">      } else {</a>
<a name="ln3681">        s1 = -1;</a>
<a name="ln3682">      }</a>
<a name="ln3683">      if (i &lt; sub2-&gt;in_use) {</a>
<a name="ln3684">        s2 = sub2-&gt;list.multi[i].start_lnum;</a>
<a name="ln3685">      } else {</a>
<a name="ln3686">        s2 = -1;</a>
<a name="ln3687">      }</a>
<a name="ln3688">      if (s1 != s2) {</a>
<a name="ln3689">        return false;</a>
<a name="ln3690">      }</a>
<a name="ln3691">      if (s1 != -1 &amp;&amp; sub1-&gt;list.multi[i].start_col</a>
<a name="ln3692">          != sub2-&gt;list.multi[i].start_col) {</a>
<a name="ln3693">        return false;</a>
<a name="ln3694">      }</a>
<a name="ln3695">      if (rex.nfa_has_backref) {</a>
<a name="ln3696">        if (i &lt; sub1-&gt;in_use) {</a>
<a name="ln3697">          s1 = sub1-&gt;list.multi[i].end_lnum;</a>
<a name="ln3698">        } else {</a>
<a name="ln3699">          s1 = -1;</a>
<a name="ln3700">        }</a>
<a name="ln3701">        if (i &lt; sub2-&gt;in_use) {</a>
<a name="ln3702">          s2 = sub2-&gt;list.multi[i].end_lnum;</a>
<a name="ln3703">        } else {</a>
<a name="ln3704">          s2 = -1;</a>
<a name="ln3705">        }</a>
<a name="ln3706">        if (s1 != s2) {</a>
<a name="ln3707">          return false;</a>
<a name="ln3708">        }</a>
<a name="ln3709">        if (s1 != -1</a>
<a name="ln3710">            &amp;&amp; sub1-&gt;list.multi[i].end_col != sub2-&gt;list.multi[i].end_col) {</a>
<a name="ln3711">          return false;</a>
<a name="ln3712">        }</a>
<a name="ln3713">      }</a>
<a name="ln3714">    }</a>
<a name="ln3715">  } else {</a>
<a name="ln3716">    for (i = 0; i &lt; todo; i++) {</a>
<a name="ln3717">      if (i &lt; sub1-&gt;in_use) {</a>
<a name="ln3718">        sp1 = sub1-&gt;list.line[i].start;</a>
<a name="ln3719">      } else {</a>
<a name="ln3720">        sp1 = NULL;</a>
<a name="ln3721">      }</a>
<a name="ln3722">      if (i &lt; sub2-&gt;in_use) {</a>
<a name="ln3723">        sp2 = sub2-&gt;list.line[i].start;</a>
<a name="ln3724">      } else {</a>
<a name="ln3725">        sp2 = NULL;</a>
<a name="ln3726">      }</a>
<a name="ln3727">      if (sp1 != sp2) {</a>
<a name="ln3728">        return false;</a>
<a name="ln3729">      }</a>
<a name="ln3730">      if (rex.nfa_has_backref) {</a>
<a name="ln3731">        if (i &lt; sub1-&gt;in_use) {</a>
<a name="ln3732">          sp1 = sub1-&gt;list.line[i].end;</a>
<a name="ln3733">        } else {</a>
<a name="ln3734">          sp1 = NULL;</a>
<a name="ln3735">        }</a>
<a name="ln3736">        if (i &lt; sub2-&gt;in_use) {</a>
<a name="ln3737">          sp2 = sub2-&gt;list.line[i].end;</a>
<a name="ln3738">        } else {</a>
<a name="ln3739">          sp2 = NULL;</a>
<a name="ln3740">        }</a>
<a name="ln3741">        if (sp1 != sp2) {</a>
<a name="ln3742">          return false;</a>
<a name="ln3743">        }</a>
<a name="ln3744">      }</a>
<a name="ln3745">    }</a>
<a name="ln3746">  }</a>
<a name="ln3747"> </a>
<a name="ln3748">  return true;</a>
<a name="ln3749">}</a>
<a name="ln3750"> </a>
<a name="ln3751">#ifdef REGEXP_DEBUG</a>
<a name="ln3752">static void report_state(char *action,</a>
<a name="ln3753">    regsub_T *sub,</a>
<a name="ln3754">    nfa_state_T *state,</a>
<a name="ln3755">    int lid,</a>
<a name="ln3756">    nfa_pim_T *pim) {</a>
<a name="ln3757">  int col;</a>
<a name="ln3758"> </a>
<a name="ln3759">  if (sub-&gt;in_use &lt;= 0) {</a>
<a name="ln3760">    col = -1;</a>
<a name="ln3761">  } else if (REG_MULTI) {</a>
<a name="ln3762">    col = sub-&gt;list.multi[0].start_col;</a>
<a name="ln3763">  } else {</a>
<a name="ln3764">    col = (int)(sub-&gt;list.line[0].start - rex.line);</a>
<a name="ln3765">  }</a>
<a name="ln3766">  nfa_set_code(state-&gt;c);</a>
<a name="ln3767">  fprintf(log_fd, &quot;&gt; %s state %d to list %d. char %d: %s (start col %d)%s\n&quot;,</a>
<a name="ln3768">          action, abs(state-&gt;id), lid, state-&gt;c, code, col,</a>
<a name="ln3769">          pim_info(pim));</a>
<a name="ln3770">}</a>
<a name="ln3771"> </a>
<a name="ln3772">#endif</a>
<a name="ln3773"> </a>
<a name="ln3774">// Return true if the same state is already in list &quot;l&quot; with the same</a>
<a name="ln3775">// positions as &quot;subs&quot;.</a>
<a name="ln3776">static bool has_state_with_pos(</a>
<a name="ln3777">    nfa_list_T *l,        // runtime state list</a>
<a name="ln3778">    nfa_state_T *state,   // state to update</a>
<a name="ln3779">    regsubs_T *subs,      // pointers to subexpressions</a>
<a name="ln3780">    nfa_pim_T *pim        // postponed match or NULL</a>
<a name="ln3781">)</a>
<a name="ln3782">  FUNC_ATTR_NONNULL_ARG(1, 2, 3)</a>
<a name="ln3783">{</a>
<a name="ln3784">  for (int i = 0; i &lt; l-&gt;n; i++) {</a>
<a name="ln3785">    nfa_thread_T *thread = &amp;l-&gt;t[i];</a>
<a name="ln3786">    if (thread-&gt;state-&gt;id == state-&gt;id</a>
<a name="ln3787">        &amp;&amp; sub_equal(&amp;thread-&gt;subs.norm, &amp;subs-&gt;norm)</a>
<a name="ln3788">        &amp;&amp; (!rex.nfa_has_zsubexpr</a>
<a name="ln3789">            || sub_equal(&amp;thread-&gt;subs.synt, &amp;subs-&gt;synt))</a>
<a name="ln3790">        &amp;&amp; pim_equal(&amp;thread-&gt;pim, pim)) {</a>
<a name="ln3791">      return true;</a>
<a name="ln3792">    }</a>
<a name="ln3793">  }</a>
<a name="ln3794">  return false;</a>
<a name="ln3795">}</a>
<a name="ln3796"> </a>
<a name="ln3797">// Return true if &quot;one&quot; and &quot;two&quot; are equal.  That includes when both are not</a>
<a name="ln3798">// set.</a>
<a name="ln3799">static bool pim_equal(const nfa_pim_T *one, const nfa_pim_T *two)</a>
<a name="ln3800">{</a>
<a name="ln3801">  const bool one_unused = (one == NULL || one-&gt;result == NFA_PIM_UNUSED);</a>
<a name="ln3802">  const bool two_unused = (two == NULL || two-&gt;result == NFA_PIM_UNUSED);</a>
<a name="ln3803"> </a>
<a name="ln3804">  if (one_unused) {</a>
<a name="ln3805">    // one is unused: equal when two is also unused</a>
<a name="ln3806">    return two_unused;</a>
<a name="ln3807">  }</a>
<a name="ln3808">  if (two_unused) {</a>
<a name="ln3809">    // one is used and two is not: not equal</a>
<a name="ln3810">    return false;</a>
<a name="ln3811">  }</a>
<a name="ln3812">  // compare the state id</a>
<a name="ln3813">  if (one-&gt;state-&gt;id != two-&gt;state-&gt;id) {</a>
<a name="ln3814">    return false;</a>
<a name="ln3815">  }</a>
<a name="ln3816">  // compare the position</a>
<a name="ln3817">  if (REG_MULTI) {</a>
<a name="ln3818">    return one-&gt;end.pos.lnum == two-&gt;end.pos.lnum</a>
<a name="ln3819">           &amp;&amp; one-&gt;end.pos.col == two-&gt;end.pos.col;</a>
<a name="ln3820">  }</a>
<a name="ln3821">  return one-&gt;end.ptr == two-&gt;end.ptr;</a>
<a name="ln3822">}</a>
<a name="ln3823"> </a>
<a name="ln3824">// Return true if &quot;state&quot; leads to a NFA_MATCH without advancing the input.</a>
<a name="ln3825">static bool match_follows(const nfa_state_T *startstate, int depth)</a>
<a name="ln3826">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3827">{</a>
<a name="ln3828">  const nfa_state_T *state = startstate;</a>
<a name="ln3829"> </a>
<a name="ln3830">  // avoid too much recursion</a>
<a name="ln3831">  if (depth &gt; 10) {</a>
<a name="ln3832">    return false;</a>
<a name="ln3833">  }</a>
<a name="ln3834">  while (state != NULL) {</a>
<a name="ln3835">    switch (state-&gt;c) {</a>
<a name="ln3836">    case NFA_MATCH:</a>
<a name="ln3837">    case NFA_MCLOSE:</a>
<a name="ln3838">    case NFA_END_INVISIBLE:</a>
<a name="ln3839">    case NFA_END_INVISIBLE_NEG:</a>
<a name="ln3840">    case NFA_END_PATTERN:</a>
<a name="ln3841">      return true;</a>
<a name="ln3842"> </a>
<a name="ln3843">    case NFA_SPLIT:</a>
<a name="ln3844">      return match_follows(state-&gt;out, depth + 1)</a>
<a name="ln3845">             || match_follows(state-&gt;out1, depth + 1);</a>
<a name="ln3846"> </a>
<a name="ln3847">    case NFA_START_INVISIBLE:</a>
<a name="ln3848">    case NFA_START_INVISIBLE_FIRST:</a>
<a name="ln3849">    case NFA_START_INVISIBLE_BEFORE:</a>
<a name="ln3850">    case NFA_START_INVISIBLE_BEFORE_FIRST:</a>
<a name="ln3851">    case NFA_START_INVISIBLE_NEG:</a>
<a name="ln3852">    case NFA_START_INVISIBLE_NEG_FIRST:</a>
<a name="ln3853">    case NFA_START_INVISIBLE_BEFORE_NEG:</a>
<a name="ln3854">    case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:</a>
<a name="ln3855">    case NFA_COMPOSING:</a>
<a name="ln3856">      /* skip ahead to next state */</a>
<a name="ln3857">      state = state-&gt;out1-&gt;out;</a>
<a name="ln3858">      continue;</a>
<a name="ln3859"> </a>
<a name="ln3860">    case NFA_ANY:</a>
<a name="ln3861">    case NFA_ANY_COMPOSING:</a>
<a name="ln3862">    case NFA_IDENT:</a>
<a name="ln3863">    case NFA_SIDENT:</a>
<a name="ln3864">    case NFA_KWORD:</a>
<a name="ln3865">    case NFA_SKWORD:</a>
<a name="ln3866">    case NFA_FNAME:</a>
<a name="ln3867">    case NFA_SFNAME:</a>
<a name="ln3868">    case NFA_PRINT:</a>
<a name="ln3869">    case NFA_SPRINT:</a>
<a name="ln3870">    case NFA_WHITE:</a>
<a name="ln3871">    case NFA_NWHITE:</a>
<a name="ln3872">    case NFA_DIGIT:</a>
<a name="ln3873">    case NFA_NDIGIT:</a>
<a name="ln3874">    case NFA_HEX:</a>
<a name="ln3875">    case NFA_NHEX:</a>
<a name="ln3876">    case NFA_OCTAL:</a>
<a name="ln3877">    case NFA_NOCTAL:</a>
<a name="ln3878">    case NFA_WORD:</a>
<a name="ln3879">    case NFA_NWORD:</a>
<a name="ln3880">    case NFA_HEAD:</a>
<a name="ln3881">    case NFA_NHEAD:</a>
<a name="ln3882">    case NFA_ALPHA:</a>
<a name="ln3883">    case NFA_NALPHA:</a>
<a name="ln3884">    case NFA_LOWER:</a>
<a name="ln3885">    case NFA_NLOWER:</a>
<a name="ln3886">    case NFA_UPPER:</a>
<a name="ln3887">    case NFA_NUPPER:</a>
<a name="ln3888">    case NFA_LOWER_IC:</a>
<a name="ln3889">    case NFA_NLOWER_IC:</a>
<a name="ln3890">    case NFA_UPPER_IC:</a>
<a name="ln3891">    case NFA_NUPPER_IC:</a>
<a name="ln3892">    case NFA_START_COLL:</a>
<a name="ln3893">    case NFA_START_NEG_COLL:</a>
<a name="ln3894">    case NFA_NEWL:</a>
<a name="ln3895">      // state will advance input</a>
<a name="ln3896">      return false;</a>
<a name="ln3897"> </a>
<a name="ln3898">    default:</a>
<a name="ln3899">      if (state-&gt;c &gt; 0) {</a>
<a name="ln3900">        // state will advance input</a>
<a name="ln3901">        return false;</a>
<a name="ln3902">      }</a>
<a name="ln3903">      // Others: zero-width or possibly zero-width, might still find</a>
<a name="ln3904">      // a match at the same position, keep looking.</a>
<a name="ln3905">      break;</a>
<a name="ln3906">    }</a>
<a name="ln3907">    state = state-&gt;out;</a>
<a name="ln3908">  }</a>
<a name="ln3909">  return false;</a>
<a name="ln3910">}</a>
<a name="ln3911"> </a>
<a name="ln3912"> </a>
<a name="ln3913">// Return true if &quot;state&quot; is already in list &quot;l&quot;.</a>
<a name="ln3914">static bool state_in_list(</a>
<a name="ln3915">    nfa_list_T *l,        // runtime state list</a>
<a name="ln3916">    nfa_state_T *state,   // state to update</a>
<a name="ln3917">    regsubs_T *subs       // pointers to subexpressions</a>
<a name="ln3918">)</a>
<a name="ln3919">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3920">{</a>
<a name="ln3921">  if (state-&gt;lastlist[nfa_ll_index] == l-&gt;id) {</a>
<a name="ln3922">    if (!rex.nfa_has_backref || has_state_with_pos(l, state, subs, NULL)) {</a>
<a name="ln3923">      return true;</a>
<a name="ln3924">    }</a>
<a name="ln3925">  }</a>
<a name="ln3926">  return false;</a>
<a name="ln3927">}</a>
<a name="ln3928"> </a>
<a name="ln3929">// Offset used for &quot;off&quot; by addstate_here().</a>
<a name="ln3930">#define ADDSTATE_HERE_OFFSET 10</a>
<a name="ln3931"> </a>
<a name="ln3932">// Add &quot;state&quot; and possibly what follows to state list &quot;.&quot;.</a>
<a name="ln3933">// Returns &quot;subs_arg&quot;, possibly copied into temp_subs.</a>
<a name="ln3934">// Returns NULL when recursiveness is too deep.</a>
<a name="ln3935">static regsubs_T *addstate(</a>
<a name="ln3936">    nfa_list_T *l,        // runtime state list</a>
<a name="ln3937">    nfa_state_T *state,   // state to update</a>
<a name="ln3938">    regsubs_T *subs_arg,  // pointers to subexpressions</a>
<a name="ln3939">    nfa_pim_T *pim,       // postponed look-behind match</a>
<a name="ln3940">    int off_arg)          // byte offset, when -1 go to next line</a>
<a name="ln3941">  FUNC_ATTR_NONNULL_ARG(1, 2) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3942">{</a>
<a name="ln3943">  int subidx;</a>
<a name="ln3944">  int off = off_arg;</a>
<a name="ln3945">  int add_here = false;</a>
<a name="ln3946">  int listindex = 0;</a>
<a name="ln3947">  int k;</a>
<a name="ln3948">  int found = false;</a>
<a name="ln3949">  nfa_thread_T        *thread;</a>
<a name="ln3950">  struct multipos     save_multipos;</a>
<a name="ln3951">  int save_in_use;</a>
<a name="ln3952">  char_u              *save_ptr;</a>
<a name="ln3953">  int i;</a>
<a name="ln3954">  regsub_T            *sub;</a>
<a name="ln3955">  regsubs_T           *subs = subs_arg;</a>
<a name="ln3956">  static regsubs_T temp_subs;</a>
<a name="ln3957">#ifdef REGEXP_DEBUG</a>
<a name="ln3958">  int did_print = false;</a>
<a name="ln3959">#endif</a>
<a name="ln3960">  static int depth = 0;</a>
<a name="ln3961"> </a>
<a name="ln3962">  // This function is called recursively.  When the depth is too much we run</a>
<a name="ln3963">  // out of stack and crash, limit recursiveness here.</a>
<a name="ln3964">  if (++depth &gt;= 5000 || subs == NULL) {</a>
<a name="ln3965">    depth--;</a>
<a name="ln3966">    return NULL;</a>
<a name="ln3967">  }</a>
<a name="ln3968"> </a>
<a name="ln3969">  if (off_arg &lt;= -ADDSTATE_HERE_OFFSET) {</a>
<a name="ln3970">    add_here = true;</a>
<a name="ln3971">    off = 0;</a>
<a name="ln3972">    listindex = -(off_arg + ADDSTATE_HERE_OFFSET);</a>
<a name="ln3973">  }</a>
<a name="ln3974"> </a>
<a name="ln3975">  switch (state-&gt;c) {</a>
<a name="ln3976">  case NFA_NCLOSE:</a>
<a name="ln3977">  case NFA_MCLOSE:</a>
<a name="ln3978">  case NFA_MCLOSE1:</a>
<a name="ln3979">  case NFA_MCLOSE2:</a>
<a name="ln3980">  case NFA_MCLOSE3:</a>
<a name="ln3981">  case NFA_MCLOSE4:</a>
<a name="ln3982">  case NFA_MCLOSE5:</a>
<a name="ln3983">  case NFA_MCLOSE6:</a>
<a name="ln3984">  case NFA_MCLOSE7:</a>
<a name="ln3985">  case NFA_MCLOSE8:</a>
<a name="ln3986">  case NFA_MCLOSE9:</a>
<a name="ln3987">  case NFA_ZCLOSE:</a>
<a name="ln3988">  case NFA_ZCLOSE1:</a>
<a name="ln3989">  case NFA_ZCLOSE2:</a>
<a name="ln3990">  case NFA_ZCLOSE3:</a>
<a name="ln3991">  case NFA_ZCLOSE4:</a>
<a name="ln3992">  case NFA_ZCLOSE5:</a>
<a name="ln3993">  case NFA_ZCLOSE6:</a>
<a name="ln3994">  case NFA_ZCLOSE7:</a>
<a name="ln3995">  case NFA_ZCLOSE8:</a>
<a name="ln3996">  case NFA_ZCLOSE9:</a>
<a name="ln3997">  case NFA_MOPEN:</a>
<a name="ln3998">  case NFA_ZEND:</a>
<a name="ln3999">  case NFA_SPLIT:</a>
<a name="ln4000">  case NFA_EMPTY:</a>
<a name="ln4001">    /* These nodes are not added themselves but their &quot;out&quot; and/or</a>
<a name="ln4002">     * &quot;out1&quot; may be added below.  */</a>
<a name="ln4003">    break;</a>
<a name="ln4004"> </a>
<a name="ln4005">  case NFA_BOL:</a>
<a name="ln4006">  case NFA_BOF:</a>
<a name="ln4007">    // &quot;^&quot; won't match past end-of-line, don't bother trying.</a>
<a name="ln4008">    // Except when at the end of the line, or when we are going to the</a>
<a name="ln4009">    // next line for a look-behind match.</a>
<a name="ln4010">    if (rex.input &gt; rex.line</a>
<a name="ln4011">        &amp;&amp; *rex.input != NUL</a>
<a name="ln4012">        &amp;&amp; (nfa_endp == NULL</a>
<a name="ln4013">            || !REG_MULTI</a>
<a name="ln4014">            || rex.lnum == nfa_endp-&gt;se_u.pos.lnum)) {</a>
<a name="ln4015">      goto skip_add;</a>
<a name="ln4016">    }</a>
<a name="ln4017">    FALLTHROUGH;</a>
<a name="ln4018"> </a>
<a name="ln4019">  case NFA_MOPEN1:</a>
<a name="ln4020">  case NFA_MOPEN2:</a>
<a name="ln4021">  case NFA_MOPEN3:</a>
<a name="ln4022">  case NFA_MOPEN4:</a>
<a name="ln4023">  case NFA_MOPEN5:</a>
<a name="ln4024">  case NFA_MOPEN6:</a>
<a name="ln4025">  case NFA_MOPEN7:</a>
<a name="ln4026">  case NFA_MOPEN8:</a>
<a name="ln4027">  case NFA_MOPEN9:</a>
<a name="ln4028">  case NFA_ZOPEN:</a>
<a name="ln4029">  case NFA_ZOPEN1:</a>
<a name="ln4030">  case NFA_ZOPEN2:</a>
<a name="ln4031">  case NFA_ZOPEN3:</a>
<a name="ln4032">  case NFA_ZOPEN4:</a>
<a name="ln4033">  case NFA_ZOPEN5:</a>
<a name="ln4034">  case NFA_ZOPEN6:</a>
<a name="ln4035">  case NFA_ZOPEN7:</a>
<a name="ln4036">  case NFA_ZOPEN8:</a>
<a name="ln4037">  case NFA_ZOPEN9:</a>
<a name="ln4038">  case NFA_NOPEN:</a>
<a name="ln4039">  case NFA_ZSTART:</a>
<a name="ln4040">  /* These nodes need to be added so that we can bail out when it</a>
<a name="ln4041">   * was added to this list before at the same position to avoid an</a>
<a name="ln4042">   * endless loop for &quot;\(\)*&quot; */</a>
<a name="ln4043"> </a>
<a name="ln4044">  default:</a>
<a name="ln4045">    if (state-&gt;lastlist[nfa_ll_index] == l-&gt;id &amp;&amp; state-&gt;c != NFA_SKIP) {</a>
<a name="ln4046">      /* This state is already in the list, don't add it again,</a>
<a name="ln4047">       * unless it is an MOPEN that is used for a backreference or</a>
<a name="ln4048">       * when there is a PIM. For NFA_MATCH check the position,</a>
<a name="ln4049">       * lower position is preferred. */</a>
<a name="ln4050">      if (!rex.nfa_has_backref &amp;&amp; pim == NULL &amp;&amp; !l-&gt;has_pim</a>
<a name="ln4051">          &amp;&amp; state-&gt;c != NFA_MATCH) {</a>
<a name="ln4052"> </a>
<a name="ln4053">        /* When called from addstate_here() do insert before</a>
<a name="ln4054">         * existing states. */</a>
<a name="ln4055">        if (add_here) {</a>
<a name="ln4056">          for (k = 0; k &lt; l-&gt;n &amp;&amp; k &lt; listindex; ++k) {</a>
<a name="ln4057">            if (l-&gt;t[k].state-&gt;id == state-&gt;id) {</a>
<a name="ln4058">              found = true;</a>
<a name="ln4059">              break;</a>
<a name="ln4060">            }</a>
<a name="ln4061">          }</a>
<a name="ln4062">        }</a>
<a name="ln4063"> </a>
<a name="ln4064">        if (!add_here || found) {</a>
<a name="ln4065">skip_add:</a>
<a name="ln4066">#ifdef REGEXP_DEBUG</a>
<a name="ln4067">          nfa_set_code(state-&gt;c);</a>
<a name="ln4068">          fprintf(log_fd, &quot;&gt; Not adding state %d to list %d. char %d: %s pim: %s has_pim: %d found: %d\n&quot;,</a>
<a name="ln4069">                  abs(state-&gt;id), l-&gt;id, state-&gt;c, code,</a>
<a name="ln4070">                  pim == NULL ? &quot;NULL&quot; : &quot;yes&quot;, l-&gt;has_pim, found);</a>
<a name="ln4071">#endif</a>
<a name="ln4072">        depth--;</a>
<a name="ln4073">        return subs;</a>
<a name="ln4074">        }</a>
<a name="ln4075">      }</a>
<a name="ln4076"> </a>
<a name="ln4077">      /* Do not add the state again when it exists with the same</a>
<a name="ln4078">       * positions. */</a>
<a name="ln4079">      if (has_state_with_pos(l, state, subs, pim))</a>
<a name="ln4080">        goto skip_add;</a>
<a name="ln4081">    }</a>
<a name="ln4082"> </a>
<a name="ln4083">    // When there are backreferences or PIMs the number of states may</a>
<a name="ln4084">    // be (a lot) bigger than anticipated.</a>
<a name="ln4085">    if (l-&gt;n == l-&gt;len) {</a>
<a name="ln4086">      const int newlen = l-&gt;len * 3 / 2 + 50;</a>
<a name="ln4087">      const size_t newsize = newlen * sizeof(nfa_thread_T);</a>
<a name="ln4088"> </a>
<a name="ln4089">      if ((long)(newsize &gt;&gt; 10) &gt;= p_mmp) {</a>
<a name="ln4090">        EMSG(_(e_maxmempat));</a>
<a name="ln4091">        depth--;</a>
<a name="ln4092">        return NULL;</a>
<a name="ln4093">      }</a>
<a name="ln4094">      if (subs != &amp;temp_subs) {</a>
<a name="ln4095">        // &quot;subs&quot; may point into the current array, need to make a</a>
<a name="ln4096">        // copy before it becomes invalid.</a>
<a name="ln4097">        copy_sub(&amp;temp_subs.norm, &amp;subs-&gt;norm);</a>
<a name="ln4098">        if (rex.nfa_has_zsubexpr) {</a>
<a name="ln4099">          copy_sub(&amp;temp_subs.synt, &amp;subs-&gt;synt);</a>
<a name="ln4100">        }</a>
<a name="ln4101">        subs = &amp;temp_subs;</a>
<a name="ln4102">      }</a>
<a name="ln4103"> </a>
<a name="ln4104">      nfa_thread_T *const newt = xrealloc(l-&gt;t, newsize);</a>
<a name="ln4105">      l-&gt;t = newt;</a>
<a name="ln4106">      l-&gt;len = newlen;</a>
<a name="ln4107">    }</a>
<a name="ln4108"> </a>
<a name="ln4109">    /* add the state to the list */</a>
<a name="ln4110">    state-&gt;lastlist[nfa_ll_index] = l-&gt;id;</a>
<a name="ln4111">    thread = &amp;l-&gt;t[l-&gt;n++];</a>
<a name="ln4112">    thread-&gt;state = state;</a>
<a name="ln4113">    if (pim == NULL)</a>
<a name="ln4114">      thread-&gt;pim.result = NFA_PIM_UNUSED;</a>
<a name="ln4115">    else {</a>
<a name="ln4116">      copy_pim(&amp;thread-&gt;pim, pim);</a>
<a name="ln4117">      l-&gt;has_pim = true;</a>
<a name="ln4118">    }</a>
<a name="ln4119">    copy_sub(&amp;thread-&gt;subs.norm, &amp;subs-&gt;norm);</a>
<a name="ln4120">    if (rex.nfa_has_zsubexpr) {</a>
<a name="ln4121">      copy_sub(&amp;thread-&gt;subs.synt, &amp;subs-&gt;synt);</a>
<a name="ln4122">    }</a>
<a name="ln4123">#ifdef REGEXP_DEBUG</a>
<a name="ln4124">    report_state(&quot;Adding&quot;, &amp;thread-&gt;subs.norm, state, l-&gt;id, pim);</a>
<a name="ln4125">    did_print = true;</a>
<a name="ln4126">#endif</a>
<a name="ln4127">  }</a>
<a name="ln4128"> </a>
<a name="ln4129">#ifdef REGEXP_DEBUG</a>
<a name="ln4130">  if (!did_print)</a>
<a name="ln4131">    report_state(&quot;Processing&quot;, &amp;subs-&gt;norm, state, l-&gt;id, pim);</a>
<a name="ln4132">#endif</a>
<a name="ln4133">  switch (state-&gt;c) {</a>
<a name="ln4134">  case NFA_MATCH:</a>
<a name="ln4135">    break;</a>
<a name="ln4136"> </a>
<a name="ln4137">  case NFA_SPLIT:</a>
<a name="ln4138">    /* order matters here */</a>
<a name="ln4139">    subs = addstate(l, state-&gt;out, subs, pim, off_arg);</a>
<a name="ln4140">    subs = addstate(l, state-&gt;out1, subs, pim, off_arg);</a>
<a name="ln4141">    break;</a>
<a name="ln4142"> </a>
<a name="ln4143">  case NFA_EMPTY:</a>
<a name="ln4144">  case NFA_NOPEN:</a>
<a name="ln4145">  case NFA_NCLOSE:</a>
<a name="ln4146">    subs = addstate(l, state-&gt;out, subs, pim, off_arg);</a>
<a name="ln4147">    break;</a>
<a name="ln4148"> </a>
<a name="ln4149">  case NFA_MOPEN:</a>
<a name="ln4150">  case NFA_MOPEN1:</a>
<a name="ln4151">  case NFA_MOPEN2:</a>
<a name="ln4152">  case NFA_MOPEN3:</a>
<a name="ln4153">  case NFA_MOPEN4:</a>
<a name="ln4154">  case NFA_MOPEN5:</a>
<a name="ln4155">  case NFA_MOPEN6:</a>
<a name="ln4156">  case NFA_MOPEN7:</a>
<a name="ln4157">  case NFA_MOPEN8:</a>
<a name="ln4158">  case NFA_MOPEN9:</a>
<a name="ln4159">  case NFA_ZOPEN:</a>
<a name="ln4160">  case NFA_ZOPEN1:</a>
<a name="ln4161">  case NFA_ZOPEN2:</a>
<a name="ln4162">  case NFA_ZOPEN3:</a>
<a name="ln4163">  case NFA_ZOPEN4:</a>
<a name="ln4164">  case NFA_ZOPEN5:</a>
<a name="ln4165">  case NFA_ZOPEN6:</a>
<a name="ln4166">  case NFA_ZOPEN7:</a>
<a name="ln4167">  case NFA_ZOPEN8:</a>
<a name="ln4168">  case NFA_ZOPEN9:</a>
<a name="ln4169">  case NFA_ZSTART:</a>
<a name="ln4170">    if (state-&gt;c == NFA_ZSTART) {</a>
<a name="ln4171">      subidx = 0;</a>
<a name="ln4172">      sub = &amp;subs-&gt;norm;</a>
<a name="ln4173">    } else if (state-&gt;c &gt;= NFA_ZOPEN &amp;&amp; state-&gt;c &lt;= NFA_ZOPEN9) {  // -V560</a>
<a name="ln4174">      subidx = state-&gt;c - NFA_ZOPEN;</a>
<a name="ln4175">      sub = &amp;subs-&gt;synt;</a>
<a name="ln4176">    } else {</a>
<a name="ln4177">      subidx = state-&gt;c - NFA_MOPEN;</a>
<a name="ln4178">      sub = &amp;subs-&gt;norm;</a>
<a name="ln4179">    }</a>
<a name="ln4180"> </a>
<a name="ln4181">    /* avoid compiler warnings */</a>
<a name="ln4182">    save_ptr = NULL;</a>
<a name="ln4183">    memset(&amp;save_multipos, 0, sizeof(save_multipos));</a>
<a name="ln4184"> </a>
<a name="ln4185">    /* Set the position (with &quot;off&quot; added) in the subexpression.  Save</a>
<a name="ln4186">     * and restore it when it was in use.  Otherwise fill any gap. */</a>
<a name="ln4187">    if (REG_MULTI) {</a>
<a name="ln4188">      if (subidx &lt; sub-&gt;in_use) {</a>
<a name="ln4189">        save_multipos = sub-&gt;list.multi[subidx];</a>
<a name="ln4190">        save_in_use = -1;</a>
<a name="ln4191">      } else {</a>
<a name="ln4192">        save_in_use = sub-&gt;in_use;</a>
<a name="ln4193">        for (i = sub-&gt;in_use; i &lt; subidx; ++i) {</a>
<a name="ln4194">          sub-&gt;list.multi[i].start_lnum = -1;</a>
<a name="ln4195">          sub-&gt;list.multi[i].end_lnum = -1;</a>
<a name="ln4196">        }</a>
<a name="ln4197">        sub-&gt;in_use = subidx + 1;</a>
<a name="ln4198">      }</a>
<a name="ln4199">      if (off == -1) {</a>
<a name="ln4200">        sub-&gt;list.multi[subidx].start_lnum = rex.lnum + 1;</a>
<a name="ln4201">        sub-&gt;list.multi[subidx].start_col = 0;</a>
<a name="ln4202">      } else {</a>
<a name="ln4203">        sub-&gt;list.multi[subidx].start_lnum = rex.lnum;</a>
<a name="ln4204">        sub-&gt;list.multi[subidx].start_col =</a>
<a name="ln4205">          (colnr_T)(rex.input - rex.line + off);</a>
<a name="ln4206">      }</a>
<a name="ln4207">      sub-&gt;list.multi[subidx].end_lnum = -1;</a>
<a name="ln4208">    } else {</a>
<a name="ln4209">      if (subidx &lt; sub-&gt;in_use) {</a>
<a name="ln4210">        save_ptr = sub-&gt;list.line[subidx].start;</a>
<a name="ln4211">        save_in_use = -1;</a>
<a name="ln4212">      } else {</a>
<a name="ln4213">        save_in_use = sub-&gt;in_use;</a>
<a name="ln4214">        for (i = sub-&gt;in_use; i &lt; subidx; ++i) {</a>
<a name="ln4215">          sub-&gt;list.line[i].start = NULL;</a>
<a name="ln4216">          sub-&gt;list.line[i].end = NULL;</a>
<a name="ln4217">        }</a>
<a name="ln4218">        sub-&gt;in_use = subidx + 1;</a>
<a name="ln4219">      }</a>
<a name="ln4220">      sub-&gt;list.line[subidx].start = rex.input + off;</a>
<a name="ln4221">    }</a>
<a name="ln4222"> </a>
<a name="ln4223">    subs = addstate(l, state-&gt;out, subs, pim, off_arg);</a>
<a name="ln4224">    if (subs == NULL) {</a>
<a name="ln4225">      break;</a>
<a name="ln4226">    }</a>
<a name="ln4227">    // &quot;subs&quot; may have changed, need to set &quot;sub&quot; again.</a>
<a name="ln4228">    if (state-&gt;c &gt;= NFA_ZOPEN &amp;&amp; state-&gt;c &lt;= NFA_ZOPEN9) {  // -V560</a>
<a name="ln4229">      sub = &amp;subs-&gt;synt;</a>
<a name="ln4230">    } else {</a>
<a name="ln4231">      sub = &amp;subs-&gt;norm;</a>
<a name="ln4232">    }</a>
<a name="ln4233"> </a>
<a name="ln4234">    if (save_in_use == -1) {</a>
<a name="ln4235">      if (REG_MULTI) {</a>
<a name="ln4236">        sub-&gt;list.multi[subidx] = save_multipos;</a>
<a name="ln4237">      }</a>
<a name="ln4238">      else</a>
<a name="ln4239">        sub-&gt;list.line[subidx].start = save_ptr;</a>
<a name="ln4240">    } else</a>
<a name="ln4241">      sub-&gt;in_use = save_in_use;</a>
<a name="ln4242">    break;</a>
<a name="ln4243"> </a>
<a name="ln4244">  case NFA_MCLOSE:</a>
<a name="ln4245">    if (rex.nfa_has_zend</a>
<a name="ln4246">        &amp;&amp; (REG_MULTI</a>
<a name="ln4247">            ? subs-&gt;norm.list.multi[0].end_lnum &gt;= 0</a>
<a name="ln4248">            : subs-&gt;norm.list.line[0].end != NULL)) {</a>
<a name="ln4249">      // Do not overwrite the position set by \ze.</a>
<a name="ln4250">      subs = addstate(l, state-&gt;out, subs, pim, off_arg);</a>
<a name="ln4251">      break;</a>
<a name="ln4252">    }</a>
<a name="ln4253">    FALLTHROUGH;</a>
<a name="ln4254">  case NFA_MCLOSE1:</a>
<a name="ln4255">  case NFA_MCLOSE2:</a>
<a name="ln4256">  case NFA_MCLOSE3:</a>
<a name="ln4257">  case NFA_MCLOSE4:</a>
<a name="ln4258">  case NFA_MCLOSE5:</a>
<a name="ln4259">  case NFA_MCLOSE6:</a>
<a name="ln4260">  case NFA_MCLOSE7:</a>
<a name="ln4261">  case NFA_MCLOSE8:</a>
<a name="ln4262">  case NFA_MCLOSE9:</a>
<a name="ln4263">  case NFA_ZCLOSE:</a>
<a name="ln4264">  case NFA_ZCLOSE1:</a>
<a name="ln4265">  case NFA_ZCLOSE2:</a>
<a name="ln4266">  case NFA_ZCLOSE3:</a>
<a name="ln4267">  case NFA_ZCLOSE4:</a>
<a name="ln4268">  case NFA_ZCLOSE5:</a>
<a name="ln4269">  case NFA_ZCLOSE6:</a>
<a name="ln4270">  case NFA_ZCLOSE7:</a>
<a name="ln4271">  case NFA_ZCLOSE8:</a>
<a name="ln4272">  case NFA_ZCLOSE9:</a>
<a name="ln4273">  case NFA_ZEND:</a>
<a name="ln4274">    if (state-&gt;c == NFA_ZEND) {</a>
<a name="ln4275">      subidx = 0;</a>
<a name="ln4276">      sub = &amp;subs-&gt;norm;</a>
<a name="ln4277">    } else if (state-&gt;c &gt;= NFA_ZCLOSE &amp;&amp; state-&gt;c &lt;= NFA_ZCLOSE9) {  // -V560</a>
<a name="ln4278">      subidx = state-&gt;c - NFA_ZCLOSE;</a>
<a name="ln4279">      sub = &amp;subs-&gt;synt;</a>
<a name="ln4280">    } else {</a>
<a name="ln4281">      subidx = state-&gt;c - NFA_MCLOSE;</a>
<a name="ln4282">      sub = &amp;subs-&gt;norm;</a>
<a name="ln4283">    }</a>
<a name="ln4284"> </a>
<a name="ln4285">    /* We don't fill in gaps here, there must have been an MOPEN that</a>
<a name="ln4286">     * has done that. */</a>
<a name="ln4287">    save_in_use = sub-&gt;in_use;</a>
<a name="ln4288">    if (sub-&gt;in_use &lt;= subidx)</a>
<a name="ln4289">      sub-&gt;in_use = subidx + 1;</a>
<a name="ln4290">    if (REG_MULTI) {</a>
<a name="ln4291">      save_multipos = sub-&gt;list.multi[subidx];</a>
<a name="ln4292">      if (off == -1) {</a>
<a name="ln4293">        sub-&gt;list.multi[subidx].end_lnum = rex.lnum + 1;</a>
<a name="ln4294">        sub-&gt;list.multi[subidx].end_col = 0;</a>
<a name="ln4295">      } else {</a>
<a name="ln4296">        sub-&gt;list.multi[subidx].end_lnum = rex.lnum;</a>
<a name="ln4297">        sub-&gt;list.multi[subidx].end_col =</a>
<a name="ln4298">          (colnr_T)(rex.input - rex.line + off);</a>
<a name="ln4299">      }</a>
<a name="ln4300">      /* avoid compiler warnings */</a>
<a name="ln4301">      save_ptr = NULL;</a>
<a name="ln4302">    } else {</a>
<a name="ln4303">      save_ptr = sub-&gt;list.line[subidx].end;</a>
<a name="ln4304">      sub-&gt;list.line[subidx].end = rex.input + off;</a>
<a name="ln4305">      // avoid compiler warnings</a>
<a name="ln4306">      memset(&amp;save_multipos, 0, sizeof(save_multipos));</a>
<a name="ln4307">    }</a>
<a name="ln4308"> </a>
<a name="ln4309">    subs = addstate(l, state-&gt;out, subs, pim, off_arg);</a>
<a name="ln4310">    if (subs == NULL) {</a>
<a name="ln4311">      break;</a>
<a name="ln4312">    }</a>
<a name="ln4313">    // &quot;subs&quot; may have changed, need to set &quot;sub&quot; again.</a>
<a name="ln4314">    if (state-&gt;c &gt;= NFA_ZCLOSE &amp;&amp; state-&gt;c &lt;= NFA_ZCLOSE9) {  // -V560</a>
<a name="ln4315">      sub = &amp;subs-&gt;synt;</a>
<a name="ln4316">    } else {</a>
<a name="ln4317">      sub = &amp;subs-&gt;norm;</a>
<a name="ln4318">    }</a>
<a name="ln4319"> </a>
<a name="ln4320">    if (REG_MULTI) {</a>
<a name="ln4321">      sub-&gt;list.multi[subidx] = save_multipos;</a>
<a name="ln4322">    }</a>
<a name="ln4323">    else</a>
<a name="ln4324">      sub-&gt;list.line[subidx].end = save_ptr;</a>
<a name="ln4325">    sub-&gt;in_use = save_in_use;</a>
<a name="ln4326">    break;</a>
<a name="ln4327">  }</a>
<a name="ln4328">  depth--;</a>
<a name="ln4329">  return subs;</a>
<a name="ln4330">}</a>
<a name="ln4331"> </a>
<a name="ln4332">/*</a>
<a name="ln4333"> * Like addstate(), but the new state(s) are put at position &quot;*ip&quot;.</a>
<a name="ln4334"> * Used for zero-width matches, next state to use is the added one.</a>
<a name="ln4335"> * This makes sure the order of states to be tried does not change, which</a>
<a name="ln4336"> * matters for alternatives.</a>
<a name="ln4337"> */</a>
<a name="ln4338">static regsubs_T *addstate_here(</a>
<a name="ln4339">    nfa_list_T *l,        // runtime state list</a>
<a name="ln4340">    nfa_state_T *state,   // state to update</a>
<a name="ln4341">    regsubs_T *subs,      // pointers to subexpressions</a>
<a name="ln4342">    nfa_pim_T *pim,       // postponed look-behind match</a>
<a name="ln4343">    int *ip</a>
<a name="ln4344">)</a>
<a name="ln4345">  FUNC_ATTR_NONNULL_ARG(1, 2, 5) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4346">{</a>
<a name="ln4347">  int tlen = l-&gt;n;</a>
<a name="ln4348">  int count;</a>
<a name="ln4349">  int listidx = *ip;</a>
<a name="ln4350"> </a>
<a name="ln4351">  /* First add the state(s) at the end, so that we know how many there are.</a>
<a name="ln4352">   * Pass the listidx as offset (avoids adding another argument to</a>
<a name="ln4353">   * addstate(). */</a>
<a name="ln4354">  regsubs_T *r = addstate(l, state, subs, pim, -listidx - ADDSTATE_HERE_OFFSET);</a>
<a name="ln4355">  if (r == NULL) {</a>
<a name="ln4356">    return NULL;</a>
<a name="ln4357">  }</a>
<a name="ln4358"> </a>
<a name="ln4359">  // when &quot;*ip&quot; was at the end of the list, nothing to do</a>
<a name="ln4360">  if (listidx + 1 == tlen) {</a>
<a name="ln4361">    return r;</a>
<a name="ln4362">  }</a>
<a name="ln4363"> </a>
<a name="ln4364">  // re-order to put the new state at the current position</a>
<a name="ln4365">  count = l-&gt;n - tlen;</a>
<a name="ln4366">  if (count == 0) {</a>
<a name="ln4367">    return r;  // no state got added</a>
<a name="ln4368">  }</a>
<a name="ln4369">  if (count == 1) {</a>
<a name="ln4370">    // overwrite the current state</a>
<a name="ln4371">    l-&gt;t[listidx] = l-&gt;t[l-&gt;n - 1];</a>
<a name="ln4372">  } else if (count &gt; 1) {</a>
<a name="ln4373">    if (l-&gt;n + count - 1 &gt;= l-&gt;len) {</a>
<a name="ln4374">      /* not enough space to move the new states, reallocate the list</a>
<a name="ln4375">       * and move the states to the right position */</a>
<a name="ln4376">      const int newlen = l-&gt;len * 3 / 2 + 50;</a>
<a name="ln4377">      const size_t newsize = newlen * sizeof(nfa_thread_T);</a>
<a name="ln4378"> </a>
<a name="ln4379">      if ((long)(newsize &gt;&gt; 10) &gt;= p_mmp) {</a>
<a name="ln4380">        EMSG(_(e_maxmempat));</a>
<a name="ln4381">        return NULL;</a>
<a name="ln4382">      }</a>
<a name="ln4383">      nfa_thread_T *const newl = xmalloc(newsize);</a>
<a name="ln4384">      l-&gt;len = newlen;</a>
<a name="ln4385">      memmove(&amp;(newl[0]),</a>
<a name="ln4386">          &amp;(l-&gt;t[0]),</a>
<a name="ln4387">          sizeof(nfa_thread_T) * listidx);</a>
<a name="ln4388">      memmove(&amp;(newl[listidx]),</a>
<a name="ln4389">          &amp;(l-&gt;t[l-&gt;n - count]),</a>
<a name="ln4390">          sizeof(nfa_thread_T) * count);</a>
<a name="ln4391">      memmove(&amp;(newl[listidx + count]),</a>
<a name="ln4392">          &amp;(l-&gt;t[listidx + 1]),</a>
<a name="ln4393">          sizeof(nfa_thread_T) * (l-&gt;n - count - listidx - 1));</a>
<a name="ln4394">      xfree(l-&gt;t);</a>
<a name="ln4395">      l-&gt;t = newl;</a>
<a name="ln4396">    } else {</a>
<a name="ln4397">      /* make space for new states, then move them from the</a>
<a name="ln4398">       * end to the current position */</a>
<a name="ln4399">      memmove(&amp;(l-&gt;t[listidx + count]),</a>
<a name="ln4400">          &amp;(l-&gt;t[listidx + 1]),</a>
<a name="ln4401">          sizeof(nfa_thread_T) * (l-&gt;n - listidx - 1));</a>
<a name="ln4402">      memmove(&amp;(l-&gt;t[listidx]),</a>
<a name="ln4403">          &amp;(l-&gt;t[l-&gt;n - 1]),</a>
<a name="ln4404">          sizeof(nfa_thread_T) * count);</a>
<a name="ln4405">    }</a>
<a name="ln4406">  }</a>
<a name="ln4407">  --l-&gt;n;</a>
<a name="ln4408">  *ip = listidx - 1;</a>
<a name="ln4409"> </a>
<a name="ln4410">  return r;</a>
<a name="ln4411">}</a>
<a name="ln4412"> </a>
<a name="ln4413">/*</a>
<a name="ln4414"> * Check character class &quot;class&quot; against current character c.</a>
<a name="ln4415"> */</a>
<a name="ln4416">static int check_char_class(int class, int c)</a>
<a name="ln4417">{</a>
<a name="ln4418">  switch (class) {</a>
<a name="ln4419">  case NFA_CLASS_ALNUM:</a>
<a name="ln4420">    if (c &gt;= 1 &amp;&amp; c &lt; 128 &amp;&amp; isalnum(c)) {</a>
<a name="ln4421">      return OK;</a>
<a name="ln4422">    }</a>
<a name="ln4423">    break;</a>
<a name="ln4424">  case NFA_CLASS_ALPHA:</a>
<a name="ln4425">    if (c &gt;= 1 &amp;&amp; c &lt; 128 &amp;&amp; isalpha(c)) {</a>
<a name="ln4426">      return OK;</a>
<a name="ln4427">    }</a>
<a name="ln4428">    break;</a>
<a name="ln4429">  case NFA_CLASS_BLANK:</a>
<a name="ln4430">    if (c == ' ' || c == '\t')</a>
<a name="ln4431">      return OK;</a>
<a name="ln4432">    break;</a>
<a name="ln4433">  case NFA_CLASS_CNTRL:</a>
<a name="ln4434">    if (c &gt;= 1 &amp;&amp; c &lt;= 127 &amp;&amp; iscntrl(c)) {</a>
<a name="ln4435">      return OK;</a>
<a name="ln4436">    }</a>
<a name="ln4437">    break;</a>
<a name="ln4438">  case NFA_CLASS_DIGIT:</a>
<a name="ln4439">    if (ascii_isdigit(c))</a>
<a name="ln4440">      return OK;</a>
<a name="ln4441">    break;</a>
<a name="ln4442">  case NFA_CLASS_GRAPH:</a>
<a name="ln4443">    if (c &gt;= 1 &amp;&amp; c &lt;= 127 &amp;&amp; isgraph(c)) {</a>
<a name="ln4444">      return OK;</a>
<a name="ln4445">    }</a>
<a name="ln4446">    break;</a>
<a name="ln4447">  case NFA_CLASS_LOWER:</a>
<a name="ln4448">    if (mb_islower(c) &amp;&amp; c != 170 &amp;&amp; c != 186) {</a>
<a name="ln4449">      return OK;</a>
<a name="ln4450">    }</a>
<a name="ln4451">    break;</a>
<a name="ln4452">  case NFA_CLASS_PRINT:</a>
<a name="ln4453">    if (vim_isprintc(c))</a>
<a name="ln4454">      return OK;</a>
<a name="ln4455">    break;</a>
<a name="ln4456">  case NFA_CLASS_PUNCT:</a>
<a name="ln4457">    if (c &gt;= 1 &amp;&amp; c &lt; 128 &amp;&amp; ispunct(c)) {</a>
<a name="ln4458">      return OK;</a>
<a name="ln4459">    }</a>
<a name="ln4460">    break;</a>
<a name="ln4461">  case NFA_CLASS_SPACE:</a>
<a name="ln4462">    if ((c &gt;= 9 &amp;&amp; c &lt;= 13) || (c == ' '))</a>
<a name="ln4463">      return OK;</a>
<a name="ln4464">    break;</a>
<a name="ln4465">  case NFA_CLASS_UPPER:</a>
<a name="ln4466">    if (mb_isupper(c)) {</a>
<a name="ln4467">      return OK;</a>
<a name="ln4468">    }</a>
<a name="ln4469">    break;</a>
<a name="ln4470">  case NFA_CLASS_XDIGIT:</a>
<a name="ln4471">    if (ascii_isxdigit(c))</a>
<a name="ln4472">      return OK;</a>
<a name="ln4473">    break;</a>
<a name="ln4474">  case NFA_CLASS_TAB:</a>
<a name="ln4475">    if (c == '\t')</a>
<a name="ln4476">      return OK;</a>
<a name="ln4477">    break;</a>
<a name="ln4478">  case NFA_CLASS_RETURN:</a>
<a name="ln4479">    if (c == '\r')</a>
<a name="ln4480">      return OK;</a>
<a name="ln4481">    break;</a>
<a name="ln4482">  case NFA_CLASS_BACKSPACE:</a>
<a name="ln4483">    if (c == '\b')</a>
<a name="ln4484">      return OK;</a>
<a name="ln4485">    break;</a>
<a name="ln4486">  case NFA_CLASS_ESCAPE:</a>
<a name="ln4487">    if (c == ESC) {</a>
<a name="ln4488">      return OK;</a>
<a name="ln4489">    }</a>
<a name="ln4490">    break;</a>
<a name="ln4491">  case NFA_CLASS_IDENT:</a>
<a name="ln4492">    if (vim_isIDc(c)) {</a>
<a name="ln4493">      return OK;</a>
<a name="ln4494">    }</a>
<a name="ln4495">    break;</a>
<a name="ln4496">  case NFA_CLASS_KEYWORD:</a>
<a name="ln4497">    if (reg_iswordc(c)) {</a>
<a name="ln4498">      return OK;</a>
<a name="ln4499">    }</a>
<a name="ln4500">    break;</a>
<a name="ln4501">  case NFA_CLASS_FNAME:</a>
<a name="ln4502">    if (vim_isfilec(c)) {</a>
<a name="ln4503">      return OK;</a>
<a name="ln4504">    }</a>
<a name="ln4505">    break;</a>
<a name="ln4506"> </a>
<a name="ln4507">  default:</a>
<a name="ln4508">    // should not be here :P</a>
<a name="ln4509">    IEMSGN(_(e_ill_char_class), class);</a>
<a name="ln4510">    return FAIL;</a>
<a name="ln4511">  }</a>
<a name="ln4512">  return FAIL;</a>
<a name="ln4513">}</a>
<a name="ln4514"> </a>
<a name="ln4515">/*</a>
<a name="ln4516"> * Check for a match with subexpression &quot;subidx&quot;.</a>
<a name="ln4517"> * Return true if it matches.</a>
<a name="ln4518"> */</a>
<a name="ln4519">static int </a>
<a name="ln4520">match_backref (</a>
<a name="ln4521">    regsub_T *sub,           /* pointers to subexpressions */</a>
<a name="ln4522">    int subidx,</a>
<a name="ln4523">    int *bytelen       /* out: length of match in bytes */</a>
<a name="ln4524">)</a>
<a name="ln4525">{</a>
<a name="ln4526">  int len;</a>
<a name="ln4527"> </a>
<a name="ln4528">  if (sub-&gt;in_use &lt;= subidx) {</a>
<a name="ln4529">retempty:</a>
<a name="ln4530">    /* backref was not set, match an empty string */</a>
<a name="ln4531">    *bytelen = 0;</a>
<a name="ln4532">    return true;</a>
<a name="ln4533">  }</a>
<a name="ln4534"> </a>
<a name="ln4535">  if (REG_MULTI) {</a>
<a name="ln4536">    if (sub-&gt;list.multi[subidx].start_lnum &lt; 0</a>
<a name="ln4537">        || sub-&gt;list.multi[subidx].end_lnum &lt; 0)</a>
<a name="ln4538">      goto retempty;</a>
<a name="ln4539">    if (sub-&gt;list.multi[subidx].start_lnum == rex.lnum</a>
<a name="ln4540">        &amp;&amp; sub-&gt;list.multi[subidx].end_lnum == rex.lnum) {</a>
<a name="ln4541">      len = sub-&gt;list.multi[subidx].end_col</a>
<a name="ln4542">            - sub-&gt;list.multi[subidx].start_col;</a>
<a name="ln4543">      if (cstrncmp(rex.line + sub-&gt;list.multi[subidx].start_col,</a>
<a name="ln4544">                   rex.input, &amp;len) == 0) {</a>
<a name="ln4545">        *bytelen = len;</a>
<a name="ln4546">        return true;</a>
<a name="ln4547">      }</a>
<a name="ln4548">    } else {</a>
<a name="ln4549">      if (match_with_backref(sub-&gt;list.multi[subidx].start_lnum,</a>
<a name="ln4550">                             sub-&gt;list.multi[subidx].start_col,</a>
<a name="ln4551">                             sub-&gt;list.multi[subidx].end_lnum,</a>
<a name="ln4552">                             sub-&gt;list.multi[subidx].end_col,</a>
<a name="ln4553">                             bytelen) == RA_MATCH) {</a>
<a name="ln4554">        return true;</a>
<a name="ln4555">      }</a>
<a name="ln4556">    }</a>
<a name="ln4557">  } else {</a>
<a name="ln4558">    if (sub-&gt;list.line[subidx].start == NULL</a>
<a name="ln4559">        || sub-&gt;list.line[subidx].end == NULL)</a>
<a name="ln4560">      goto retempty;</a>
<a name="ln4561">    len = (int)(sub-&gt;list.line[subidx].end - sub-&gt;list.line[subidx].start);</a>
<a name="ln4562">    if (cstrncmp(sub-&gt;list.line[subidx].start, rex.input, &amp;len) == 0) {</a>
<a name="ln4563">      *bytelen = len;</a>
<a name="ln4564">      return true;</a>
<a name="ln4565">    }</a>
<a name="ln4566">  }</a>
<a name="ln4567">  return false;</a>
<a name="ln4568">}</a>
<a name="ln4569"> </a>
<a name="ln4570"> </a>
<a name="ln4571"> </a>
<a name="ln4572">/*</a>
<a name="ln4573"> * Check for a match with \z subexpression &quot;subidx&quot;.</a>
<a name="ln4574"> * Return true if it matches.</a>
<a name="ln4575"> */</a>
<a name="ln4576">static int </a>
<a name="ln4577">match_zref (</a>
<a name="ln4578">    int subidx,</a>
<a name="ln4579">    int *bytelen       /* out: length of match in bytes */</a>
<a name="ln4580">)</a>
<a name="ln4581">{</a>
<a name="ln4582">  int len;</a>
<a name="ln4583"> </a>
<a name="ln4584">  cleanup_zsubexpr();</a>
<a name="ln4585">  if (re_extmatch_in == NULL || re_extmatch_in-&gt;matches[subidx] == NULL) {</a>
<a name="ln4586">    /* backref was not set, match an empty string */</a>
<a name="ln4587">    *bytelen = 0;</a>
<a name="ln4588">    return true;</a>
<a name="ln4589">  }</a>
<a name="ln4590"> </a>
<a name="ln4591">  len = (int)STRLEN(re_extmatch_in-&gt;matches[subidx]);</a>
<a name="ln4592">  if (cstrncmp(re_extmatch_in-&gt;matches[subidx], rex.input, &amp;len) == 0) {</a>
<a name="ln4593">    *bytelen = len;</a>
<a name="ln4594">    return true;</a>
<a name="ln4595">  }</a>
<a name="ln4596">  return false;</a>
<a name="ln4597">}</a>
<a name="ln4598"> </a>
<a name="ln4599">/*</a>
<a name="ln4600"> * Save list IDs for all NFA states of &quot;prog&quot; into &quot;list&quot;.</a>
<a name="ln4601"> * Also reset the IDs to zero.</a>
<a name="ln4602"> * Only used for the recursive value lastlist[1].</a>
<a name="ln4603"> */</a>
<a name="ln4604">static void nfa_save_listids(nfa_regprog_T *prog, int *list)</a>
<a name="ln4605">{</a>
<a name="ln4606">  int i;</a>
<a name="ln4607">  nfa_state_T     *p;</a>
<a name="ln4608"> </a>
<a name="ln4609">  /* Order in the list is reverse, it's a bit faster that way. */</a>
<a name="ln4610">  p = &amp;prog-&gt;state[0];</a>
<a name="ln4611">  for (i = prog-&gt;nstate; --i &gt;= 0; ) {</a>
<a name="ln4612">    list[i] = p-&gt;lastlist[1];</a>
<a name="ln4613">    p-&gt;lastlist[1] = 0;</a>
<a name="ln4614">    ++p;</a>
<a name="ln4615">  }</a>
<a name="ln4616">}</a>
<a name="ln4617"> </a>
<a name="ln4618">/*</a>
<a name="ln4619"> * Restore list IDs from &quot;list&quot; to all NFA states.</a>
<a name="ln4620"> */</a>
<a name="ln4621">static void nfa_restore_listids(nfa_regprog_T *prog, int *list)</a>
<a name="ln4622">{</a>
<a name="ln4623">  int i;</a>
<a name="ln4624">  nfa_state_T     *p;</a>
<a name="ln4625"> </a>
<a name="ln4626">  p = &amp;prog-&gt;state[0];</a>
<a name="ln4627">  for (i = prog-&gt;nstate; --i &gt;= 0; ) {</a>
<a name="ln4628">    p-&gt;lastlist[1] = list[i];</a>
<a name="ln4629">    ++p;</a>
<a name="ln4630">  }</a>
<a name="ln4631">}</a>
<a name="ln4632"> </a>
<a name="ln4633">static bool nfa_re_num_cmp(uintmax_t val, int op, uintmax_t pos)</a>
<a name="ln4634">{</a>
<a name="ln4635">  if (op == 1) return pos &gt; val;</a>
<a name="ln4636">  if (op == 2) return pos &lt; val;</a>
<a name="ln4637">  return val == pos;</a>
<a name="ln4638">}</a>
<a name="ln4639"> </a>
<a name="ln4640"> </a>
<a name="ln4641">/*</a>
<a name="ln4642"> * Recursively call nfa_regmatch()</a>
<a name="ln4643"> * &quot;pim&quot; is NULL or contains info about a Postponed Invisible Match (start</a>
<a name="ln4644"> * position).</a>
<a name="ln4645"> */</a>
<a name="ln4646">static int recursive_regmatch(</a>
<a name="ln4647">    nfa_state_T *state, nfa_pim_T *pim, nfa_regprog_T *prog,</a>
<a name="ln4648">    regsubs_T *submatch, regsubs_T *m, int **listids, int *listids_len)</a>
<a name="ln4649">  FUNC_ATTR_NONNULL_ARG(1, 3, 5, 6, 7)</a>
<a name="ln4650">{</a>
<a name="ln4651">  const int save_reginput_col = (int)(rex.input - rex.line);</a>
<a name="ln4652">  const int save_reglnum = rex.lnum;</a>
<a name="ln4653">  const int save_nfa_match = nfa_match;</a>
<a name="ln4654">  const int save_nfa_listid = rex.nfa_listid;</a>
<a name="ln4655">  save_se_T *const save_nfa_endp = nfa_endp;</a>
<a name="ln4656">  save_se_T endpos;</a>
<a name="ln4657">  save_se_T   *endposp = NULL;</a>
<a name="ln4658">  int need_restore = false;</a>
<a name="ln4659"> </a>
<a name="ln4660">  if (pim != NULL) {</a>
<a name="ln4661">    // start at the position where the postponed match was</a>
<a name="ln4662">    if (REG_MULTI) {</a>
<a name="ln4663">      rex.input = rex.line + pim-&gt;end.pos.col;</a>
<a name="ln4664">    } else {</a>
<a name="ln4665">      rex.input = pim-&gt;end.ptr;</a>
<a name="ln4666">    }</a>
<a name="ln4667">  }</a>
<a name="ln4668"> </a>
<a name="ln4669">  if (state-&gt;c == NFA_START_INVISIBLE_BEFORE</a>
<a name="ln4670">      || state-&gt;c == NFA_START_INVISIBLE_BEFORE_FIRST</a>
<a name="ln4671">      || state-&gt;c == NFA_START_INVISIBLE_BEFORE_NEG</a>
<a name="ln4672">      || state-&gt;c == NFA_START_INVISIBLE_BEFORE_NEG_FIRST) {</a>
<a name="ln4673">    // The recursive match must end at the current position. When &quot;pim&quot; is</a>
<a name="ln4674">    // not NULL it specifies the current position.</a>
<a name="ln4675">    endposp = &amp;endpos;</a>
<a name="ln4676">    if (REG_MULTI) {</a>
<a name="ln4677">      if (pim == NULL) {</a>
<a name="ln4678">        endpos.se_u.pos.col = (int)(rex.input - rex.line);</a>
<a name="ln4679">        endpos.se_u.pos.lnum = rex.lnum;</a>
<a name="ln4680">      } else {</a>
<a name="ln4681">        endpos.se_u.pos = pim-&gt;end.pos;</a>
<a name="ln4682">      }</a>
<a name="ln4683">    } else {</a>
<a name="ln4684">      if (pim == NULL) {</a>
<a name="ln4685">        endpos.se_u.ptr = rex.input;</a>
<a name="ln4686">      } else {</a>
<a name="ln4687">        endpos.se_u.ptr = pim-&gt;end.ptr;</a>
<a name="ln4688">      }</a>
<a name="ln4689">    }</a>
<a name="ln4690"> </a>
<a name="ln4691">    // Go back the specified number of bytes, or as far as the</a>
<a name="ln4692">    // start of the previous line, to try matching &quot;\@&lt;=&quot; or</a>
<a name="ln4693">    // not matching &quot;\@&lt;!&quot;. This is very inefficient, limit the number of</a>
<a name="ln4694">    // bytes if possible.</a>
<a name="ln4695">    if (state-&gt;val &lt;= 0) {</a>
<a name="ln4696">      if (REG_MULTI) {</a>
<a name="ln4697">        rex.line = reg_getline(--rex.lnum);</a>
<a name="ln4698">        if (rex.line == NULL) {</a>
<a name="ln4699">          // can't go before the first line</a>
<a name="ln4700">          rex.line = reg_getline(++rex.lnum);</a>
<a name="ln4701">        }</a>
<a name="ln4702">      }</a>
<a name="ln4703">      rex.input = rex.line;</a>
<a name="ln4704">    } else {</a>
<a name="ln4705">      if (REG_MULTI &amp;&amp; (int)(rex.input - rex.line) &lt; state-&gt;val) {</a>
<a name="ln4706">        // Not enough bytes in this line, go to end of</a>
<a name="ln4707">        // previous line.</a>
<a name="ln4708">        rex.line = reg_getline(--rex.lnum);</a>
<a name="ln4709">        if (rex.line == NULL) {</a>
<a name="ln4710">          // can't go before the first line</a>
<a name="ln4711">          rex.line = reg_getline(++rex.lnum);</a>
<a name="ln4712">          rex.input = rex.line;</a>
<a name="ln4713">        } else {</a>
<a name="ln4714">          rex.input = rex.line + STRLEN(rex.line);</a>
<a name="ln4715">        }</a>
<a name="ln4716">      }</a>
<a name="ln4717">      if ((int)(rex.input - rex.line) &gt;= state-&gt;val) {</a>
<a name="ln4718">        rex.input -= state-&gt;val;</a>
<a name="ln4719">        rex.input -= utf_head_off(rex.line, rex.input);</a>
<a name="ln4720">      } else {</a>
<a name="ln4721">        rex.input = rex.line;</a>
<a name="ln4722">      }</a>
<a name="ln4723">    }</a>
<a name="ln4724">  }</a>
<a name="ln4725"> </a>
<a name="ln4726">#ifdef REGEXP_DEBUG</a>
<a name="ln4727">  if (log_fd != stderr)</a>
<a name="ln4728">    fclose(log_fd);</a>
<a name="ln4729">  log_fd = NULL;</a>
<a name="ln4730">#endif</a>
<a name="ln4731">  // Have to clear the lastlist field of the NFA nodes, so that</a>
<a name="ln4732">  // nfa_regmatch() and addstate() can run properly after recursion.</a>
<a name="ln4733">  if (nfa_ll_index == 1) {</a>
<a name="ln4734">    // Already calling nfa_regmatch() recursively.  Save the lastlist[1]</a>
<a name="ln4735">    // values and clear them.</a>
<a name="ln4736">    if (*listids == NULL || *listids_len &lt; prog-&gt;nstate) {</a>
<a name="ln4737">      xfree(*listids);</a>
<a name="ln4738">      *listids = xmalloc(sizeof(**listids) * prog-&gt;nstate);</a>
<a name="ln4739">      *listids_len = prog-&gt;nstate;</a>
<a name="ln4740">    }</a>
<a name="ln4741">    nfa_save_listids(prog, *listids);</a>
<a name="ln4742">    need_restore = true;</a>
<a name="ln4743">    // any value of rex.nfa_listid will do</a>
<a name="ln4744">  } else {</a>
<a name="ln4745">    // First recursive nfa_regmatch() call, switch to the second lastlist</a>
<a name="ln4746">    // entry.  Make sure rex.nfa_listid is different from a previous</a>
<a name="ln4747">    // recursive call, because some states may still have this ID.</a>
<a name="ln4748">    nfa_ll_index++;</a>
<a name="ln4749">    if (rex.nfa_listid &lt;= rex.nfa_alt_listid) {</a>
<a name="ln4750">      rex.nfa_listid = rex.nfa_alt_listid;</a>
<a name="ln4751">    }</a>
<a name="ln4752">  }</a>
<a name="ln4753"> </a>
<a name="ln4754">  // Call nfa_regmatch() to check if the current concat matches at this</a>
<a name="ln4755">  // position. The concat ends with the node NFA_END_INVISIBLE</a>
<a name="ln4756">  nfa_endp = endposp;</a>
<a name="ln4757">  const int result = nfa_regmatch(prog, state-&gt;out, submatch, m);</a>
<a name="ln4758"> </a>
<a name="ln4759">  if (need_restore) {</a>
<a name="ln4760">    nfa_restore_listids(prog, *listids);</a>
<a name="ln4761">  } else {</a>
<a name="ln4762">    nfa_ll_index--;</a>
<a name="ln4763">    rex.nfa_alt_listid = rex.nfa_listid;</a>
<a name="ln4764">  }</a>
<a name="ln4765"> </a>
<a name="ln4766">  // restore position in input text</a>
<a name="ln4767">  rex.lnum = save_reglnum;</a>
<a name="ln4768">  if (REG_MULTI) {</a>
<a name="ln4769">    rex.line = reg_getline(rex.lnum);</a>
<a name="ln4770">  }</a>
<a name="ln4771">  rex.input = rex.line + save_reginput_col;</a>
<a name="ln4772">  if (result != NFA_TOO_EXPENSIVE) {</a>
<a name="ln4773">    nfa_match = save_nfa_match;</a>
<a name="ln4774">    rex.nfa_listid = save_nfa_listid;</a>
<a name="ln4775">  }</a>
<a name="ln4776">  nfa_endp = save_nfa_endp;</a>
<a name="ln4777"> </a>
<a name="ln4778">#ifdef REGEXP_DEBUG</a>
<a name="ln4779">  log_fd = fopen(NFA_REGEXP_RUN_LOG, &quot;a&quot;);</a>
<a name="ln4780">  if (log_fd != NULL) {</a>
<a name="ln4781">    fprintf(log_fd, &quot;****************************\n&quot;);</a>
<a name="ln4782">    fprintf(log_fd, &quot;FINISHED RUNNING nfa_regmatch() recursively\n&quot;);</a>
<a name="ln4783">    fprintf(log_fd, &quot;MATCH = %s\n&quot;, !result ? &quot;false&quot; : &quot;OK&quot;);</a>
<a name="ln4784">    fprintf(log_fd, &quot;****************************\n&quot;);</a>
<a name="ln4785">  } else {</a>
<a name="ln4786">    EMSG(_(e_log_open_failed));</a>
<a name="ln4787">    log_fd = stderr;</a>
<a name="ln4788">  }</a>
<a name="ln4789">#endif</a>
<a name="ln4790"> </a>
<a name="ln4791">  return result;</a>
<a name="ln4792">}</a>
<a name="ln4793"> </a>
<a name="ln4794"> </a>
<a name="ln4795">/*</a>
<a name="ln4796"> * Estimate the chance of a match with &quot;state&quot; failing.</a>
<a name="ln4797"> * empty match: 0</a>
<a name="ln4798"> * NFA_ANY: 1</a>
<a name="ln4799"> * specific character: 99</a>
<a name="ln4800"> */</a>
<a name="ln4801">static int failure_chance(nfa_state_T *state, int depth)</a>
<a name="ln4802">{</a>
<a name="ln4803">  int c = state-&gt;c;</a>
<a name="ln4804">  int l, r;</a>
<a name="ln4805"> </a>
<a name="ln4806">  /* detect looping */</a>
<a name="ln4807">  if (depth &gt; 4)</a>
<a name="ln4808">    return 1;</a>
<a name="ln4809"> </a>
<a name="ln4810">  switch (c) {</a>
<a name="ln4811">  case NFA_SPLIT:</a>
<a name="ln4812">    if (state-&gt;out-&gt;c == NFA_SPLIT || state-&gt;out1-&gt;c == NFA_SPLIT)</a>
<a name="ln4813">      /* avoid recursive stuff */</a>
<a name="ln4814">      return 1;</a>
<a name="ln4815">    /* two alternatives, use the lowest failure chance */</a>
<a name="ln4816">    l = failure_chance(state-&gt;out, depth + 1);</a>
<a name="ln4817">    r = failure_chance(state-&gt;out1, depth + 1);</a>
<a name="ln4818">    return l &lt; r ? l : r;</a>
<a name="ln4819"> </a>
<a name="ln4820">  case NFA_ANY:</a>
<a name="ln4821">    /* matches anything, unlikely to fail */</a>
<a name="ln4822">    return 1;</a>
<a name="ln4823"> </a>
<a name="ln4824">  case NFA_MATCH:</a>
<a name="ln4825">  case NFA_MCLOSE:</a>
<a name="ln4826">  case NFA_ANY_COMPOSING:</a>
<a name="ln4827">    /* empty match works always */</a>
<a name="ln4828">    return 0;</a>
<a name="ln4829"> </a>
<a name="ln4830">  case NFA_START_INVISIBLE:</a>
<a name="ln4831">  case NFA_START_INVISIBLE_FIRST:</a>
<a name="ln4832">  case NFA_START_INVISIBLE_NEG:</a>
<a name="ln4833">  case NFA_START_INVISIBLE_NEG_FIRST:</a>
<a name="ln4834">  case NFA_START_INVISIBLE_BEFORE:</a>
<a name="ln4835">  case NFA_START_INVISIBLE_BEFORE_FIRST:</a>
<a name="ln4836">  case NFA_START_INVISIBLE_BEFORE_NEG:</a>
<a name="ln4837">  case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:</a>
<a name="ln4838">  case NFA_START_PATTERN:</a>
<a name="ln4839">    /* recursive regmatch is expensive, use low failure chance */</a>
<a name="ln4840">    return 5;</a>
<a name="ln4841"> </a>
<a name="ln4842">  case NFA_BOL:</a>
<a name="ln4843">  case NFA_EOL:</a>
<a name="ln4844">  case NFA_BOF:</a>
<a name="ln4845">  case NFA_EOF:</a>
<a name="ln4846">  case NFA_NEWL:</a>
<a name="ln4847">    return 99;</a>
<a name="ln4848"> </a>
<a name="ln4849">  case NFA_BOW:</a>
<a name="ln4850">  case NFA_EOW:</a>
<a name="ln4851">    return 90;</a>
<a name="ln4852"> </a>
<a name="ln4853">  case NFA_MOPEN:</a>
<a name="ln4854">  case NFA_MOPEN1:</a>
<a name="ln4855">  case NFA_MOPEN2:</a>
<a name="ln4856">  case NFA_MOPEN3:</a>
<a name="ln4857">  case NFA_MOPEN4:</a>
<a name="ln4858">  case NFA_MOPEN5:</a>
<a name="ln4859">  case NFA_MOPEN6:</a>
<a name="ln4860">  case NFA_MOPEN7:</a>
<a name="ln4861">  case NFA_MOPEN8:</a>
<a name="ln4862">  case NFA_MOPEN9:</a>
<a name="ln4863">  case NFA_ZOPEN:</a>
<a name="ln4864">  case NFA_ZOPEN1:</a>
<a name="ln4865">  case NFA_ZOPEN2:</a>
<a name="ln4866">  case NFA_ZOPEN3:</a>
<a name="ln4867">  case NFA_ZOPEN4:</a>
<a name="ln4868">  case NFA_ZOPEN5:</a>
<a name="ln4869">  case NFA_ZOPEN6:</a>
<a name="ln4870">  case NFA_ZOPEN7:</a>
<a name="ln4871">  case NFA_ZOPEN8:</a>
<a name="ln4872">  case NFA_ZOPEN9:</a>
<a name="ln4873">  case NFA_ZCLOSE:</a>
<a name="ln4874">  case NFA_ZCLOSE1:</a>
<a name="ln4875">  case NFA_ZCLOSE2:</a>
<a name="ln4876">  case NFA_ZCLOSE3:</a>
<a name="ln4877">  case NFA_ZCLOSE4:</a>
<a name="ln4878">  case NFA_ZCLOSE5:</a>
<a name="ln4879">  case NFA_ZCLOSE6:</a>
<a name="ln4880">  case NFA_ZCLOSE7:</a>
<a name="ln4881">  case NFA_ZCLOSE8:</a>
<a name="ln4882">  case NFA_ZCLOSE9:</a>
<a name="ln4883">  case NFA_NOPEN:</a>
<a name="ln4884">  case NFA_MCLOSE1:</a>
<a name="ln4885">  case NFA_MCLOSE2:</a>
<a name="ln4886">  case NFA_MCLOSE3:</a>
<a name="ln4887">  case NFA_MCLOSE4:</a>
<a name="ln4888">  case NFA_MCLOSE5:</a>
<a name="ln4889">  case NFA_MCLOSE6:</a>
<a name="ln4890">  case NFA_MCLOSE7:</a>
<a name="ln4891">  case NFA_MCLOSE8:</a>
<a name="ln4892">  case NFA_MCLOSE9:</a>
<a name="ln4893">  case NFA_NCLOSE:</a>
<a name="ln4894">    return failure_chance(state-&gt;out, depth + 1);</a>
<a name="ln4895"> </a>
<a name="ln4896">  case NFA_BACKREF1:</a>
<a name="ln4897">  case NFA_BACKREF2:</a>
<a name="ln4898">  case NFA_BACKREF3:</a>
<a name="ln4899">  case NFA_BACKREF4:</a>
<a name="ln4900">  case NFA_BACKREF5:</a>
<a name="ln4901">  case NFA_BACKREF6:</a>
<a name="ln4902">  case NFA_BACKREF7:</a>
<a name="ln4903">  case NFA_BACKREF8:</a>
<a name="ln4904">  case NFA_BACKREF9:</a>
<a name="ln4905">  case NFA_ZREF1:</a>
<a name="ln4906">  case NFA_ZREF2:</a>
<a name="ln4907">  case NFA_ZREF3:</a>
<a name="ln4908">  case NFA_ZREF4:</a>
<a name="ln4909">  case NFA_ZREF5:</a>
<a name="ln4910">  case NFA_ZREF6:</a>
<a name="ln4911">  case NFA_ZREF7:</a>
<a name="ln4912">  case NFA_ZREF8:</a>
<a name="ln4913">  case NFA_ZREF9:</a>
<a name="ln4914">    /* backreferences don't match in many places */</a>
<a name="ln4915">    return 94;</a>
<a name="ln4916"> </a>
<a name="ln4917">  case NFA_LNUM_GT:</a>
<a name="ln4918">  case NFA_LNUM_LT:</a>
<a name="ln4919">  case NFA_COL_GT:</a>
<a name="ln4920">  case NFA_COL_LT:</a>
<a name="ln4921">  case NFA_VCOL_GT:</a>
<a name="ln4922">  case NFA_VCOL_LT:</a>
<a name="ln4923">  case NFA_MARK_GT:</a>
<a name="ln4924">  case NFA_MARK_LT:</a>
<a name="ln4925">  case NFA_VISUAL:</a>
<a name="ln4926">    /* before/after positions don't match very often */</a>
<a name="ln4927">    return 85;</a>
<a name="ln4928"> </a>
<a name="ln4929">  case NFA_LNUM:</a>
<a name="ln4930">    return 90;</a>
<a name="ln4931"> </a>
<a name="ln4932">  case NFA_CURSOR:</a>
<a name="ln4933">  case NFA_COL:</a>
<a name="ln4934">  case NFA_VCOL:</a>
<a name="ln4935">  case NFA_MARK:</a>
<a name="ln4936">    /* specific positions rarely match */</a>
<a name="ln4937">    return 98;</a>
<a name="ln4938"> </a>
<a name="ln4939">  case NFA_COMPOSING:</a>
<a name="ln4940">    return 95;</a>
<a name="ln4941"> </a>
<a name="ln4942">  default:</a>
<a name="ln4943">    if (c &gt; 0)</a>
<a name="ln4944">      /* character match fails often */</a>
<a name="ln4945">      return 95;</a>
<a name="ln4946">  }</a>
<a name="ln4947"> </a>
<a name="ln4948">  /* something else, includes character classes */</a>
<a name="ln4949">  return 50;</a>
<a name="ln4950">}</a>
<a name="ln4951"> </a>
<a name="ln4952">/*</a>
<a name="ln4953"> * Skip until the char &quot;c&quot; we know a match must start with.</a>
<a name="ln4954"> */</a>
<a name="ln4955">static int skip_to_start(int c, colnr_T *colp)</a>
<a name="ln4956">{</a>
<a name="ln4957">  const char_u *const s = cstrchr(rex.line + *colp, c);</a>
<a name="ln4958">  if (s == NULL) {</a>
<a name="ln4959">    return FAIL;</a>
<a name="ln4960">  }</a>
<a name="ln4961">  *colp = (int)(s - rex.line);</a>
<a name="ln4962">  return OK;</a>
<a name="ln4963">}</a>
<a name="ln4964"> </a>
<a name="ln4965">/*</a>
<a name="ln4966"> * Check for a match with match_text.</a>
<a name="ln4967"> * Called after skip_to_start() has found regstart.</a>
<a name="ln4968"> * Returns zero for no match, 1 for a match.</a>
<a name="ln4969"> */</a>
<a name="ln4970">static long find_match_text(colnr_T startcol, int regstart, char_u *match_text)</a>
<a name="ln4971">{</a>
<a name="ln4972">#define PTR2LEN(x) utf_ptr2len(x)</a>
<a name="ln4973"> </a>
<a name="ln4974">  colnr_T col = startcol;</a>
<a name="ln4975">  int regstart_len = PTR2LEN(rex.line + startcol);</a>
<a name="ln4976"> </a>
<a name="ln4977">  for (;;) {</a>
<a name="ln4978">    bool match = true;</a>
<a name="ln4979">    char_u *s1 = match_text;</a>
<a name="ln4980">    char_u *s2 = rex.line + col + regstart_len;  // skip regstart</a>
<a name="ln4981">    while (*s1) {</a>
<a name="ln4982">      int c1_len = PTR2LEN(s1);</a>
<a name="ln4983">      int c1 = PTR2CHAR(s1);</a>
<a name="ln4984">      int c2_len = PTR2LEN(s2);</a>
<a name="ln4985">      int c2 = PTR2CHAR(s2);</a>
<a name="ln4986"> </a>
<a name="ln4987">      if ((c1 != c2 &amp;&amp; (!rex.reg_ic || utf_fold(c1) != utf_fold(c2)))</a>
<a name="ln4988">          || c1_len != c2_len) {</a>
<a name="ln4989">        match = false;</a>
<a name="ln4990">        break;</a>
<a name="ln4991">      }</a>
<a name="ln4992">      s1 += c1_len;</a>
<a name="ln4993">      s2 += c2_len;</a>
<a name="ln4994">    }</a>
<a name="ln4995">    if (match</a>
<a name="ln4996">        // check that no composing char follows</a>
<a name="ln4997">        &amp;&amp; !utf_iscomposing(PTR2CHAR(s2))) {</a>
<a name="ln4998">      cleanup_subexpr();</a>
<a name="ln4999">      if (REG_MULTI) {</a>
<a name="ln5000">        rex.reg_startpos[0].lnum = rex.lnum;</a>
<a name="ln5001">        rex.reg_startpos[0].col = col;</a>
<a name="ln5002">        rex.reg_endpos[0].lnum = rex.lnum;</a>
<a name="ln5003">        rex.reg_endpos[0].col = s2 - rex.line;</a>
<a name="ln5004">      } else {</a>
<a name="ln5005">        rex.reg_startp[0] = rex.line + col;</a>
<a name="ln5006">        rex.reg_endp[0] = s2;</a>
<a name="ln5007">      }</a>
<a name="ln5008">      return 1L;</a>
<a name="ln5009">    }</a>
<a name="ln5010"> </a>
<a name="ln5011">    // Try finding regstart after the current match.</a>
<a name="ln5012">    col += regstart_len;  // skip regstart</a>
<a name="ln5013">    if (skip_to_start(regstart, &amp;col) == FAIL) {</a>
<a name="ln5014">      break;</a>
<a name="ln5015">    }</a>
<a name="ln5016">  }</a>
<a name="ln5017">  return 0L;</a>
<a name="ln5018"> </a>
<a name="ln5019">#undef PTR2LEN</a>
<a name="ln5020">}</a>
<a name="ln5021"> </a>
<a name="ln5022">static int nfa_did_time_out(void)</a>
<a name="ln5023">{</a>
<a name="ln5024">  if (nfa_time_limit != NULL &amp;&amp; profile_passed_limit(*nfa_time_limit)) {</a>
<a name="ln5025">    if (nfa_timed_out != NULL) {</a>
<a name="ln5026">      *nfa_timed_out = true;</a>
<a name="ln5027">    }</a>
<a name="ln5028">    return true;</a>
<a name="ln5029">  }</a>
<a name="ln5030">  return false;</a>
<a name="ln5031">}</a>
<a name="ln5032"> </a>
<a name="ln5033">/// Main matching routine.</a>
<a name="ln5034">///</a>
<a name="ln5035">/// Run NFA to determine whether it matches rex.input.</a>
<a name="ln5036">///</a>
<a name="ln5037">/// When &quot;nfa_endp&quot; is not NULL it is a required end-of-match position.</a>
<a name="ln5038">///</a>
<a name="ln5039">/// Return true if there is a match, false if there is no match,</a>
<a name="ln5040">/// NFA_TOO_EXPENSIVE if we end up with too many states.</a>
<a name="ln5041">/// When there is a match &quot;submatch&quot; contains the positions.</a>
<a name="ln5042">///</a>
<a name="ln5043">/// Note: Caller must ensure that: start != NULL.</a>
<a name="ln5044">static int nfa_regmatch(nfa_regprog_T *prog, nfa_state_T *start,</a>
<a name="ln5045">                        regsubs_T *submatch, regsubs_T *m)</a>
<a name="ln5046">  FUNC_ATTR_NONNULL_ARG(1, 2, 4)</a>
<a name="ln5047">{</a>
<a name="ln5048">  int result = false;</a>
<a name="ln5049">  int flag = 0;</a>
<a name="ln5050">  bool go_to_nextline = false;</a>
<a name="ln5051">  nfa_thread_T *t;</a>
<a name="ln5052">  nfa_list_T list[2];</a>
<a name="ln5053">  int listidx;</a>
<a name="ln5054">  nfa_list_T  *thislist;</a>
<a name="ln5055">  nfa_list_T  *nextlist;</a>
<a name="ln5056">  int         *listids = NULL;</a>
<a name="ln5057">  int listids_len = 0;</a>
<a name="ln5058">  nfa_state_T *add_state;</a>
<a name="ln5059">  bool add_here;</a>
<a name="ln5060">  int add_count;</a>
<a name="ln5061">  int add_off = 0;</a>
<a name="ln5062">  int toplevel = start-&gt;c == NFA_MOPEN;</a>
<a name="ln5063">  regsubs_T *r;</a>
<a name="ln5064">#ifdef NFA_REGEXP_DEBUG_LOG</a>
<a name="ln5065">  FILE        *debug = fopen(NFA_REGEXP_DEBUG_LOG, &quot;a&quot;);</a>
<a name="ln5066"> </a>
<a name="ln5067">  if (debug == NULL) {</a>
<a name="ln5068">    EMSG2(&quot;(NFA) COULD NOT OPEN %s!&quot;, NFA_REGEXP_DEBUG_LOG);</a>
<a name="ln5069">    return false;</a>
<a name="ln5070">  }</a>
<a name="ln5071">#endif</a>
<a name="ln5072">  // Some patterns may take a long time to match, especially when using</a>
<a name="ln5073">  // recursive_regmatch(). Allow interrupting them with CTRL-C.</a>
<a name="ln5074">  fast_breakcheck();</a>
<a name="ln5075">  if (got_int) {</a>
<a name="ln5076">#ifdef NFA_REGEXP_DEBUG_LOG</a>
<a name="ln5077">    fclose(debug);</a>
<a name="ln5078">#endif</a>
<a name="ln5079">    return false;</a>
<a name="ln5080">  }</a>
<a name="ln5081">  if (nfa_did_time_out()) {</a>
<a name="ln5082">#ifdef NFA_REGEXP_DEBUG_LOG</a>
<a name="ln5083">    fclose(debug);</a>
<a name="ln5084">#endif</a>
<a name="ln5085">    return false;</a>
<a name="ln5086">  }</a>
<a name="ln5087"> </a>
<a name="ln5088">  nfa_match = false;</a>
<a name="ln5089"> </a>
<a name="ln5090">  // Allocate memory for the lists of nodes.</a>
<a name="ln5091">  size_t size = (prog-&gt;nstate + 1) * sizeof(nfa_thread_T);</a>
<a name="ln5092">  list[0].t = xmalloc(size);</a>
<a name="ln5093">  list[0].len = prog-&gt;nstate + 1;</a>
<a name="ln5094">  list[1].t = xmalloc(size);</a>
<a name="ln5095">  list[1].len = prog-&gt;nstate + 1;</a>
<a name="ln5096"> </a>
<a name="ln5097">#ifdef REGEXP_DEBUG</a>
<a name="ln5098">  log_fd = fopen(NFA_REGEXP_RUN_LOG, &quot;a&quot;);</a>
<a name="ln5099">  if (log_fd != NULL) {</a>
<a name="ln5100">    fprintf(log_fd, &quot;**********************************\n&quot;);</a>
<a name="ln5101">    nfa_set_code(start-&gt;c);</a>
<a name="ln5102">    fprintf(log_fd, &quot; RUNNING nfa_regmatch() starting with state %d, code %s\n&quot;,</a>
<a name="ln5103">        abs(start-&gt;id), code);</a>
<a name="ln5104">    fprintf(log_fd, &quot;**********************************\n&quot;);</a>
<a name="ln5105">  } else {</a>
<a name="ln5106">    EMSG(_(e_log_open_failed));</a>
<a name="ln5107">    log_fd = stderr;</a>
<a name="ln5108">  }</a>
<a name="ln5109">#endif</a>
<a name="ln5110"> </a>
<a name="ln5111">  thislist = &amp;list[0];</a>
<a name="ln5112">  thislist-&gt;n = 0;</a>
<a name="ln5113">  thislist-&gt;has_pim = false;</a>
<a name="ln5114">  nextlist = &amp;list[1];</a>
<a name="ln5115">  nextlist-&gt;n = 0;</a>
<a name="ln5116">  nextlist-&gt;has_pim = false;</a>
<a name="ln5117">#ifdef REGEXP_DEBUG</a>
<a name="ln5118">  fprintf(log_fd, &quot;(---) STARTSTATE first\n&quot;);</a>
<a name="ln5119">#endif</a>
<a name="ln5120">  thislist-&gt;id = rex.nfa_listid + 1;</a>
<a name="ln5121"> </a>
<a name="ln5122">  // Inline optimized code for addstate(thislist, start, m, 0) if we know</a>
<a name="ln5123">  // it's the first MOPEN.</a>
<a name="ln5124">  if (toplevel) {</a>
<a name="ln5125">    if (REG_MULTI) {</a>
<a name="ln5126">      m-&gt;norm.list.multi[0].start_lnum = rex.lnum;</a>
<a name="ln5127">      m-&gt;norm.list.multi[0].start_col = (colnr_T)(rex.input - rex.line);</a>
<a name="ln5128">    } else {</a>
<a name="ln5129">      m-&gt;norm.list.line[0].start = rex.input;</a>
<a name="ln5130">    }</a>
<a name="ln5131">    m-&gt;norm.in_use = 1;</a>
<a name="ln5132">    r = addstate(thislist, start-&gt;out, m, NULL, 0);</a>
<a name="ln5133">  } else {</a>
<a name="ln5134">    r = addstate(thislist, start, m, NULL, 0);</a>
<a name="ln5135">  }</a>
<a name="ln5136">  if (r == NULL) {</a>
<a name="ln5137">    nfa_match = NFA_TOO_EXPENSIVE;</a>
<a name="ln5138">    goto theend;</a>
<a name="ln5139">  }</a>
<a name="ln5140"> </a>
<a name="ln5141">#define ADD_STATE_IF_MATCH(state) \</a>
<a name="ln5142">  if (result) { \</a>
<a name="ln5143">    add_state = state-&gt;out; \</a>
<a name="ln5144">    add_off = clen; \</a>
<a name="ln5145">  }</a>
<a name="ln5146"> </a>
<a name="ln5147">  /*</a>
<a name="ln5148">   * Run for each character.</a>
<a name="ln5149">   */</a>
<a name="ln5150">  for (;; ) {</a>
<a name="ln5151">    int curc = utf_ptr2char(rex.input);</a>
<a name="ln5152">    int clen = utfc_ptr2len(rex.input);</a>
<a name="ln5153">    if (curc == NUL) {</a>
<a name="ln5154">      clen = 0;</a>
<a name="ln5155">      go_to_nextline = false;</a>
<a name="ln5156">    }</a>
<a name="ln5157"> </a>
<a name="ln5158">    /* swap lists */</a>
<a name="ln5159">    thislist = &amp;list[flag];</a>
<a name="ln5160">    nextlist = &amp;list[flag ^= 1];</a>
<a name="ln5161">    nextlist-&gt;n = 0;                // clear nextlist</a>
<a name="ln5162">    nextlist-&gt;has_pim = false;</a>
<a name="ln5163">    rex.nfa_listid++;</a>
<a name="ln5164">    if (prog-&gt;re_engine == AUTOMATIC_ENGINE</a>
<a name="ln5165">        &amp;&amp; (rex.nfa_listid &gt;= NFA_MAX_STATES)) {</a>
<a name="ln5166">      // Too many states, retry with old engine.</a>
<a name="ln5167">      nfa_match = NFA_TOO_EXPENSIVE;</a>
<a name="ln5168">      goto theend;</a>
<a name="ln5169">    }</a>
<a name="ln5170"> </a>
<a name="ln5171">    thislist-&gt;id = rex.nfa_listid;</a>
<a name="ln5172">    nextlist-&gt;id = rex.nfa_listid + 1;</a>
<a name="ln5173"> </a>
<a name="ln5174">#ifdef REGEXP_DEBUG</a>
<a name="ln5175">    fprintf(log_fd, &quot;------------------------------------------\n&quot;);</a>
<a name="ln5176">    fprintf(log_fd, &quot;&gt;&gt;&gt; Reginput is \&quot;%s\&quot;\n&quot;, rex.input);</a>
<a name="ln5177">    fprintf(log_fd,</a>
<a name="ln5178">            &quot;&gt;&gt;&gt; Advanced one character... Current char is %c (code %d) \n&quot;,</a>
<a name="ln5179">            curc,</a>
<a name="ln5180">            (int)curc);</a>
<a name="ln5181">    fprintf(log_fd, &quot;&gt;&gt;&gt; Thislist has %d states available: &quot;, thislist-&gt;n);</a>
<a name="ln5182">    {</a>
<a name="ln5183">      int i;</a>
<a name="ln5184"> </a>
<a name="ln5185">      for (i = 0; i &lt; thislist-&gt;n; i++)</a>
<a name="ln5186">        fprintf(log_fd, &quot;%d  &quot;, abs(thislist-&gt;t[i].state-&gt;id));</a>
<a name="ln5187">    }</a>
<a name="ln5188">    fprintf(log_fd, &quot;\n&quot;);</a>
<a name="ln5189">#endif</a>
<a name="ln5190"> </a>
<a name="ln5191">#ifdef NFA_REGEXP_DEBUG_LOG</a>
<a name="ln5192">    fprintf(debug, &quot;\n-------------------\n&quot;);</a>
<a name="ln5193">#endif</a>
<a name="ln5194">    /*</a>
<a name="ln5195">     * If the state lists are empty we can stop.</a>
<a name="ln5196">     */</a>
<a name="ln5197">    if (thislist-&gt;n == 0)</a>
<a name="ln5198">      break;</a>
<a name="ln5199"> </a>
<a name="ln5200">    // compute nextlist</a>
<a name="ln5201">    for (listidx = 0; listidx &lt; thislist-&gt;n; listidx++) {</a>
<a name="ln5202">      // If the list gets very long there probably is something wrong.</a>
<a name="ln5203">      // At least allow interrupting with CTRL-C.</a>
<a name="ln5204">      fast_breakcheck();</a>
<a name="ln5205">      if (got_int) {</a>
<a name="ln5206">        break;</a>
<a name="ln5207">      }</a>
<a name="ln5208">      if (nfa_time_limit != NULL &amp;&amp; ++nfa_time_count == 20) {</a>
<a name="ln5209">        nfa_time_count = 0;</a>
<a name="ln5210">        if (nfa_did_time_out()) {</a>
<a name="ln5211">          break;</a>
<a name="ln5212">        }</a>
<a name="ln5213">      }</a>
<a name="ln5214">      t = &amp;thislist-&gt;t[listidx];</a>
<a name="ln5215"> </a>
<a name="ln5216">#ifdef NFA_REGEXP_DEBUG_LOG</a>
<a name="ln5217">      nfa_set_code(t-&gt;state-&gt;c);</a>
<a name="ln5218">      fprintf(debug, &quot;%s, &quot;, code);</a>
<a name="ln5219">#endif</a>
<a name="ln5220">#ifdef REGEXP_DEBUG</a>
<a name="ln5221">      {</a>
<a name="ln5222">        int col;</a>
<a name="ln5223"> </a>
<a name="ln5224">        if (t-&gt;subs.norm.in_use &lt;= 0) {</a>
<a name="ln5225">          col = -1;</a>
<a name="ln5226">        } else if (REG_MULTI) {</a>
<a name="ln5227">          col = t-&gt;subs.norm.list.multi[0].start_col;</a>
<a name="ln5228">        } else {</a>
<a name="ln5229">          col = (int)(t-&gt;subs.norm.list.line[0].start - rex.line);</a>
<a name="ln5230">        }</a>
<a name="ln5231">        nfa_set_code(t-&gt;state-&gt;c);</a>
<a name="ln5232">        fprintf(log_fd, &quot;(%d) char %d %s (start col %d)%s... \n&quot;,</a>
<a name="ln5233">                abs(t-&gt;state-&gt;id), (int)t-&gt;state-&gt;c, code, col,</a>
<a name="ln5234">                pim_info(&amp;t-&gt;pim));</a>
<a name="ln5235">      }</a>
<a name="ln5236">#endif</a>
<a name="ln5237"> </a>
<a name="ln5238">      /*</a>
<a name="ln5239">       * Handle the possible codes of the current state.</a>
<a name="ln5240">       * The most important is NFA_MATCH.</a>
<a name="ln5241">       */</a>
<a name="ln5242">      add_state = NULL;</a>
<a name="ln5243">      add_here = false;</a>
<a name="ln5244">      add_count = 0;</a>
<a name="ln5245">      switch (t-&gt;state-&gt;c) {</a>
<a name="ln5246">      case NFA_MATCH:</a>
<a name="ln5247">      {</a>
<a name="ln5248">        // If the match is not at the start of the line, ends before a</a>
<a name="ln5249">        // composing characters and rex.reg_icombine is not set, that</a>
<a name="ln5250">        // is not really a match.</a>
<a name="ln5251">        if (!rex.reg_icombine</a>
<a name="ln5252">            &amp;&amp; rex.input != rex.line</a>
<a name="ln5253">            &amp;&amp; utf_iscomposing(curc)) {</a>
<a name="ln5254">          break;</a>
<a name="ln5255">        }</a>
<a name="ln5256">        nfa_match = true;</a>
<a name="ln5257">        copy_sub(&amp;submatch-&gt;norm, &amp;t-&gt;subs.norm);</a>
<a name="ln5258">        if (rex.nfa_has_zsubexpr) {</a>
<a name="ln5259">          copy_sub(&amp;submatch-&gt;synt, &amp;t-&gt;subs.synt);</a>
<a name="ln5260">        }</a>
<a name="ln5261">#ifdef REGEXP_DEBUG</a>
<a name="ln5262">        log_subsexpr(&amp;t-&gt;subs);</a>
<a name="ln5263">#endif</a>
<a name="ln5264">        // Found the left-most longest match, do not look at any other</a>
<a name="ln5265">        // states at this position.  When the list of states is going</a>
<a name="ln5266">        // to be empty quit without advancing, so that &quot;rex.input&quot; is</a>
<a name="ln5267">        // correct.</a>
<a name="ln5268">        if (nextlist-&gt;n == 0) {</a>
<a name="ln5269">          clen = 0;</a>
<a name="ln5270">        }</a>
<a name="ln5271">        goto nextchar;</a>
<a name="ln5272">      }</a>
<a name="ln5273"> </a>
<a name="ln5274">      case NFA_END_INVISIBLE:</a>
<a name="ln5275">      case NFA_END_INVISIBLE_NEG:</a>
<a name="ln5276">      case NFA_END_PATTERN:</a>
<a name="ln5277">        // This is only encountered after a NFA_START_INVISIBLE or</a>
<a name="ln5278">        // NFA_START_INVISIBLE_BEFORE node.</a>
<a name="ln5279">        // They surround a zero-width group, used with &quot;\@=&quot;, &quot;\&amp;&quot;,</a>
<a name="ln5280">        // &quot;\@!&quot;, &quot;\@&lt;=&quot; and &quot;\@&lt;!&quot;.</a>
<a name="ln5281">        // If we got here, it means that the current &quot;invisible&quot; group</a>
<a name="ln5282">        // finished successfully, so return control to the parent</a>
<a name="ln5283">        // nfa_regmatch().  For a look-behind match only when it ends</a>
<a name="ln5284">        // in the position in &quot;nfa_endp&quot;.</a>
<a name="ln5285">        // Submatches are stored in *m, and used in the parent call.</a>
<a name="ln5286">#ifdef REGEXP_DEBUG</a>
<a name="ln5287">        if (nfa_endp != NULL) {</a>
<a name="ln5288">          if (REG_MULTI) {</a>
<a name="ln5289">            fprintf(log_fd,</a>
<a name="ln5290">                    &quot;Current lnum: %d, endp lnum: %d;&quot;</a>
<a name="ln5291">                    &quot; current col: %d, endp col: %d\n&quot;,</a>
<a name="ln5292">                    (int)rex.lnum,</a>
<a name="ln5293">                    (int)nfa_endp-&gt;se_u.pos.lnum,</a>
<a name="ln5294">                    (int)(rex.input - rex.line),</a>
<a name="ln5295">                    nfa_endp-&gt;se_u.pos.col);</a>
<a name="ln5296">          } else {</a>
<a name="ln5297">            fprintf(log_fd, &quot;Current col: %d, endp col: %d\n&quot;,</a>
<a name="ln5298">                    (int)(rex.input - rex.line),</a>
<a name="ln5299">                    (int)(nfa_endp-&gt;se_u.ptr - rex.input));</a>
<a name="ln5300">          }</a>
<a name="ln5301">        }</a>
<a name="ln5302">#endif</a>
<a name="ln5303">        // If &quot;nfa_endp&quot; is set it's only a match if it ends at</a>
<a name="ln5304">        // &quot;nfa_endp&quot;</a>
<a name="ln5305">        if (nfa_endp != NULL</a>
<a name="ln5306">            &amp;&amp; (REG_MULTI</a>
<a name="ln5307">                ? (rex.lnum != nfa_endp-&gt;se_u.pos.lnum</a>
<a name="ln5308">                   || (int)(rex.input - rex.line) != nfa_endp-&gt;se_u.pos.col)</a>
<a name="ln5309">                : rex.input != nfa_endp-&gt;se_u.ptr)) {</a>
<a name="ln5310">          break;</a>
<a name="ln5311">        }</a>
<a name="ln5312">        // do not set submatches for \@!</a>
<a name="ln5313">        if (t-&gt;state-&gt;c != NFA_END_INVISIBLE_NEG) {</a>
<a name="ln5314">          copy_sub(&amp;m-&gt;norm, &amp;t-&gt;subs.norm);</a>
<a name="ln5315">          if (rex.nfa_has_zsubexpr) {</a>
<a name="ln5316">            copy_sub(&amp;m-&gt;synt, &amp;t-&gt;subs.synt);</a>
<a name="ln5317">          }</a>
<a name="ln5318">        }</a>
<a name="ln5319">#ifdef REGEXP_DEBUG</a>
<a name="ln5320">        fprintf(log_fd, &quot;Match found:\n&quot;);</a>
<a name="ln5321">        log_subsexpr(m);</a>
<a name="ln5322">#endif</a>
<a name="ln5323">        nfa_match = true;</a>
<a name="ln5324">        // See comment above at &quot;goto nextchar&quot;.</a>
<a name="ln5325">        if (nextlist-&gt;n == 0) {</a>
<a name="ln5326">          clen = 0;</a>
<a name="ln5327">        }</a>
<a name="ln5328">        goto nextchar;</a>
<a name="ln5329"> </a>
<a name="ln5330">      case NFA_START_INVISIBLE:</a>
<a name="ln5331">      case NFA_START_INVISIBLE_FIRST:</a>
<a name="ln5332">      case NFA_START_INVISIBLE_NEG:</a>
<a name="ln5333">      case NFA_START_INVISIBLE_NEG_FIRST:</a>
<a name="ln5334">      case NFA_START_INVISIBLE_BEFORE:</a>
<a name="ln5335">      case NFA_START_INVISIBLE_BEFORE_FIRST:</a>
<a name="ln5336">      case NFA_START_INVISIBLE_BEFORE_NEG:</a>
<a name="ln5337">      case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:</a>
<a name="ln5338">      {</a>
<a name="ln5339">#ifdef REGEXP_DEBUG</a>
<a name="ln5340">        fprintf(log_fd, &quot;Failure chance invisible: %d, what follows: %d\n&quot;,</a>
<a name="ln5341">            failure_chance(t-&gt;state-&gt;out, 0),</a>
<a name="ln5342">            failure_chance(t-&gt;state-&gt;out1-&gt;out, 0));</a>
<a name="ln5343">#endif</a>
<a name="ln5344">        // Do it directly if there already is a PIM or when</a>
<a name="ln5345">        // nfa_postprocess() detected it will work better.</a>
<a name="ln5346">        if (t-&gt;pim.result != NFA_PIM_UNUSED</a>
<a name="ln5347">            || t-&gt;state-&gt;c == NFA_START_INVISIBLE_FIRST</a>
<a name="ln5348">            || t-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG_FIRST</a>
<a name="ln5349">            || t-&gt;state-&gt;c == NFA_START_INVISIBLE_BEFORE_FIRST</a>
<a name="ln5350">            || t-&gt;state-&gt;c == NFA_START_INVISIBLE_BEFORE_NEG_FIRST) {</a>
<a name="ln5351">          int in_use = m-&gt;norm.in_use;</a>
<a name="ln5352"> </a>
<a name="ln5353">          // Copy submatch info for the recursive call, opposite</a>
<a name="ln5354">          // of what happens on success below.</a>
<a name="ln5355">          copy_sub_off(&amp;m-&gt;norm, &amp;t-&gt;subs.norm);</a>
<a name="ln5356">          if (rex.nfa_has_zsubexpr) {</a>
<a name="ln5357">            copy_sub_off(&amp;m-&gt;synt, &amp;t-&gt;subs.synt);</a>
<a name="ln5358">          }</a>
<a name="ln5359">          // First try matching the invisible match, then what</a>
<a name="ln5360">          // follows.</a>
<a name="ln5361">          result = recursive_regmatch(t-&gt;state, NULL, prog, submatch, m,</a>
<a name="ln5362">                                      &amp;listids, &amp;listids_len);</a>
<a name="ln5363">          if (result == NFA_TOO_EXPENSIVE) {</a>
<a name="ln5364">            nfa_match = result;</a>
<a name="ln5365">            goto theend;</a>
<a name="ln5366">          }</a>
<a name="ln5367"> </a>
<a name="ln5368">          // for \@! and \@&lt;! it is a match when the result is</a>
<a name="ln5369">          // false</a>
<a name="ln5370">          if (result != (t-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG</a>
<a name="ln5371">                         || t-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG_FIRST</a>
<a name="ln5372">                         || t-&gt;state-&gt;c</a>
<a name="ln5373">                         == NFA_START_INVISIBLE_BEFORE_NEG</a>
<a name="ln5374">                         || t-&gt;state-&gt;c</a>
<a name="ln5375">                         == NFA_START_INVISIBLE_BEFORE_NEG_FIRST)) {</a>
<a name="ln5376">            // Copy submatch info from the recursive call</a>
<a name="ln5377">            copy_sub_off(&amp;t-&gt;subs.norm, &amp;m-&gt;norm);</a>
<a name="ln5378">            if (rex.nfa_has_zsubexpr) {</a>
<a name="ln5379">              copy_sub_off(&amp;t-&gt;subs.synt, &amp;m-&gt;synt);</a>
<a name="ln5380">            }</a>
<a name="ln5381">            // If the pattern has \ze and it matched in the</a>
<a name="ln5382">            // sub pattern, use it.</a>
<a name="ln5383">            copy_ze_off(&amp;t-&gt;subs.norm, &amp;m-&gt;norm);</a>
<a name="ln5384"> </a>
<a name="ln5385">            // t-&gt;state-&gt;out1 is the corresponding</a>
<a name="ln5386">            // END_INVISIBLE node; Add its out to the current</a>
<a name="ln5387">            // list (zero-width match).</a>
<a name="ln5388">            add_here = true;</a>
<a name="ln5389">            add_state = t-&gt;state-&gt;out1-&gt;out;</a>
<a name="ln5390">          }</a>
<a name="ln5391">          m-&gt;norm.in_use = in_use;</a>
<a name="ln5392">        } else {</a>
<a name="ln5393">          nfa_pim_T pim;</a>
<a name="ln5394"> </a>
<a name="ln5395">          // First try matching what follows.  Only if a match</a>
<a name="ln5396">          // is found verify the invisible match matches.  Add a</a>
<a name="ln5397">          // nfa_pim_T to the following states, it contains info</a>
<a name="ln5398">          // about the invisible match.</a>
<a name="ln5399">          pim.state = t-&gt;state;</a>
<a name="ln5400">          pim.result = NFA_PIM_TODO;</a>
<a name="ln5401">          pim.subs.norm.in_use = 0;</a>
<a name="ln5402">          pim.subs.synt.in_use = 0;</a>
<a name="ln5403">          if (REG_MULTI) {</a>
<a name="ln5404">            pim.end.pos.col = (int)(rex.input - rex.line);</a>
<a name="ln5405">            pim.end.pos.lnum = rex.lnum;</a>
<a name="ln5406">          } else {</a>
<a name="ln5407">            pim.end.ptr = rex.input;</a>
<a name="ln5408">          }</a>
<a name="ln5409">          // t-&gt;state-&gt;out1 is the corresponding END_INVISIBLE</a>
<a name="ln5410">          // node; Add its out to the current list (zero-width</a>
<a name="ln5411">          // match).</a>
<a name="ln5412">          if (addstate_here(thislist, t-&gt;state-&gt;out1-&gt;out, &amp;t-&gt;subs,</a>
<a name="ln5413">                            &amp;pim, &amp;listidx) == NULL) {</a>
<a name="ln5414">            nfa_match = NFA_TOO_EXPENSIVE;</a>
<a name="ln5415">            goto theend;</a>
<a name="ln5416">          }</a>
<a name="ln5417">        }</a>
<a name="ln5418">      }</a>
<a name="ln5419">      break;</a>
<a name="ln5420"> </a>
<a name="ln5421">      case NFA_START_PATTERN:</a>
<a name="ln5422">      {</a>
<a name="ln5423">        nfa_state_T *skip = NULL;</a>
<a name="ln5424">#ifdef REGEXP_DEBUG</a>
<a name="ln5425">        int skip_lid = 0;</a>
<a name="ln5426">#endif</a>
<a name="ln5427"> </a>
<a name="ln5428">        // There is no point in trying to match the pattern if the</a>
<a name="ln5429">        // output state is not going to be added to the list.</a>
<a name="ln5430">        if (state_in_list(nextlist, t-&gt;state-&gt;out1-&gt;out, &amp;t-&gt;subs)) {</a>
<a name="ln5431">          skip = t-&gt;state-&gt;out1-&gt;out;</a>
<a name="ln5432">#ifdef REGEXP_DEBUG</a>
<a name="ln5433">          skip_lid = nextlist-&gt;id;</a>
<a name="ln5434">#endif</a>
<a name="ln5435">        } else if (state_in_list(nextlist,</a>
<a name="ln5436">                       t-&gt;state-&gt;out1-&gt;out-&gt;out, &amp;t-&gt;subs)) {</a>
<a name="ln5437">          skip = t-&gt;state-&gt;out1-&gt;out-&gt;out;</a>
<a name="ln5438">#ifdef REGEXP_DEBUG</a>
<a name="ln5439">          skip_lid = nextlist-&gt;id;</a>
<a name="ln5440">#endif</a>
<a name="ln5441">        } else if (state_in_list(thislist,</a>
<a name="ln5442">                       t-&gt;state-&gt;out1-&gt;out-&gt;out, &amp;t-&gt;subs)) {</a>
<a name="ln5443">          skip = t-&gt;state-&gt;out1-&gt;out-&gt;out;</a>
<a name="ln5444">#ifdef REGEXP_DEBUG</a>
<a name="ln5445">          skip_lid = thislist-&gt;id;</a>
<a name="ln5446">#endif</a>
<a name="ln5447">        }</a>
<a name="ln5448">        if (skip != NULL) {</a>
<a name="ln5449">#ifdef REGEXP_DEBUG</a>
<a name="ln5450">          nfa_set_code(skip-&gt;c);</a>
<a name="ln5451">          fprintf(</a>
<a name="ln5452">              log_fd,</a>
<a name="ln5453">              &quot;&gt; Not trying to match pattern, output state %d is already in list %d. char %d: %s\n&quot;,</a>
<a name="ln5454">              abs(skip-&gt;id), skip_lid, skip-&gt;c, code);</a>
<a name="ln5455">#endif</a>
<a name="ln5456">          break;</a>
<a name="ln5457">        }</a>
<a name="ln5458">        // Copy submatch info to the recursive call, opposite of what</a>
<a name="ln5459">        // happens afterwards.</a>
<a name="ln5460">        copy_sub_off(&amp;m-&gt;norm, &amp;t-&gt;subs.norm);</a>
<a name="ln5461">        if (rex.nfa_has_zsubexpr) {</a>
<a name="ln5462">          copy_sub_off(&amp;m-&gt;synt, &amp;t-&gt;subs.synt);</a>
<a name="ln5463">        }</a>
<a name="ln5464"> </a>
<a name="ln5465">        // First try matching the pattern.</a>
<a name="ln5466">        result = recursive_regmatch(t-&gt;state, NULL, prog, submatch, m,</a>
<a name="ln5467">                                    &amp;listids, &amp;listids_len);</a>
<a name="ln5468">        if (result == NFA_TOO_EXPENSIVE) {</a>
<a name="ln5469">          nfa_match = result;</a>
<a name="ln5470">          goto theend;</a>
<a name="ln5471">        }</a>
<a name="ln5472">        if (result) {</a>
<a name="ln5473">          int bytelen;</a>
<a name="ln5474"> </a>
<a name="ln5475">#ifdef REGEXP_DEBUG</a>
<a name="ln5476">          fprintf(log_fd, &quot;NFA_START_PATTERN matches:\n&quot;);</a>
<a name="ln5477">          log_subsexpr(m);</a>
<a name="ln5478">#endif</a>
<a name="ln5479">          // Copy submatch info from the recursive call</a>
<a name="ln5480">          copy_sub_off(&amp;t-&gt;subs.norm, &amp;m-&gt;norm);</a>
<a name="ln5481">          if (rex.nfa_has_zsubexpr) {</a>
<a name="ln5482">            copy_sub_off(&amp;t-&gt;subs.synt, &amp;m-&gt;synt);</a>
<a name="ln5483">          }</a>
<a name="ln5484">          // Now we need to skip over the matched text and then</a>
<a name="ln5485">          // continue with what follows.</a>
<a name="ln5486">          if (REG_MULTI) {</a>
<a name="ln5487">            // TODO(RE): multi-line match</a>
<a name="ln5488">            bytelen = m-&gt;norm.list.multi[0].end_col</a>
<a name="ln5489">                      - (int)(rex.input - rex.line);</a>
<a name="ln5490">          } else {</a>
<a name="ln5491">            bytelen = (int)(m-&gt;norm.list.line[0].end - rex.input);</a>
<a name="ln5492">          }</a>
<a name="ln5493"> </a>
<a name="ln5494">#ifdef REGEXP_DEBUG</a>
<a name="ln5495">          fprintf(log_fd, &quot;NFA_START_PATTERN length: %d\n&quot;, bytelen);</a>
<a name="ln5496">#endif</a>
<a name="ln5497">          if (bytelen == 0) {</a>
<a name="ln5498">            // empty match, output of corresponding</a>
<a name="ln5499">            // NFA_END_PATTERN/NFA_SKIP to be used at current</a>
<a name="ln5500">            // position</a>
<a name="ln5501">            add_here = true;</a>
<a name="ln5502">            add_state = t-&gt;state-&gt;out1-&gt;out-&gt;out;</a>
<a name="ln5503">          } else if (bytelen &lt;= clen) {</a>
<a name="ln5504">            // match current character, output of corresponding</a>
<a name="ln5505">            // NFA_END_PATTERN to be used at next position.</a>
<a name="ln5506">            add_state = t-&gt;state-&gt;out1-&gt;out-&gt;out;</a>
<a name="ln5507">            add_off = clen;</a>
<a name="ln5508">          } else {</a>
<a name="ln5509">            // skip over the matched characters, set character</a>
<a name="ln5510">            // count in NFA_SKIP</a>
<a name="ln5511">            add_state = t-&gt;state-&gt;out1-&gt;out;</a>
<a name="ln5512">            add_off = bytelen;</a>
<a name="ln5513">            add_count = bytelen - clen;</a>
<a name="ln5514">          }</a>
<a name="ln5515">        }</a>
<a name="ln5516">        break;</a>
<a name="ln5517">      }</a>
<a name="ln5518"> </a>
<a name="ln5519">      case NFA_BOL:</a>
<a name="ln5520">        if (rex.input == rex.line) {</a>
<a name="ln5521">          add_here = true;</a>
<a name="ln5522">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5523">        }</a>
<a name="ln5524">        break;</a>
<a name="ln5525"> </a>
<a name="ln5526">      case NFA_EOL:</a>
<a name="ln5527">        if (curc == NUL) {</a>
<a name="ln5528">          add_here = true;</a>
<a name="ln5529">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5530">        }</a>
<a name="ln5531">        break;</a>
<a name="ln5532"> </a>
<a name="ln5533">      case NFA_BOW:</a>
<a name="ln5534">        result = true;</a>
<a name="ln5535"> </a>
<a name="ln5536">        if (curc == NUL) {</a>
<a name="ln5537">          result = false;</a>
<a name="ln5538">        } else {</a>
<a name="ln5539">          int this_class;</a>
<a name="ln5540"> </a>
<a name="ln5541">          // Get class of current and previous char (if it exists).</a>
<a name="ln5542">          this_class = mb_get_class_tab(rex.input, rex.reg_buf-&gt;b_chartab);</a>
<a name="ln5543">          if (this_class &lt;= 1) {</a>
<a name="ln5544">            result = false;</a>
<a name="ln5545">          } else if (reg_prev_class() == this_class) {</a>
<a name="ln5546">            result = false;</a>
<a name="ln5547">          }</a>
<a name="ln5548">        }</a>
<a name="ln5549">        if (result) {</a>
<a name="ln5550">          add_here = true;</a>
<a name="ln5551">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5552">        }</a>
<a name="ln5553">        break;</a>
<a name="ln5554"> </a>
<a name="ln5555">      case NFA_EOW:</a>
<a name="ln5556">        result = true;</a>
<a name="ln5557">        if (rex.input == rex.line) {</a>
<a name="ln5558">          result = false;</a>
<a name="ln5559">        } else {</a>
<a name="ln5560">          int this_class, prev_class;</a>
<a name="ln5561"> </a>
<a name="ln5562">          // Get class of current and previous char (if it exists).</a>
<a name="ln5563">          this_class = mb_get_class_tab(rex.input, rex.reg_buf-&gt;b_chartab);</a>
<a name="ln5564">          prev_class = reg_prev_class();</a>
<a name="ln5565">          if (this_class == prev_class</a>
<a name="ln5566">              || prev_class == 0 || prev_class == 1) {</a>
<a name="ln5567">            result = false;</a>
<a name="ln5568">          }</a>
<a name="ln5569">        }</a>
<a name="ln5570">        if (result) {</a>
<a name="ln5571">          add_here = true;</a>
<a name="ln5572">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5573">        }</a>
<a name="ln5574">        break;</a>
<a name="ln5575"> </a>
<a name="ln5576">      case NFA_BOF:</a>
<a name="ln5577">        if (rex.lnum == 0 &amp;&amp; rex.input == rex.line</a>
<a name="ln5578">            &amp;&amp; (!REG_MULTI || rex.reg_firstlnum == 1)) {</a>
<a name="ln5579">          add_here = true;</a>
<a name="ln5580">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5581">        }</a>
<a name="ln5582">        break;</a>
<a name="ln5583"> </a>
<a name="ln5584">      case NFA_EOF:</a>
<a name="ln5585">        if (rex.lnum == rex.reg_maxline &amp;&amp; curc == NUL) {</a>
<a name="ln5586">          add_here = true;</a>
<a name="ln5587">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5588">        }</a>
<a name="ln5589">        break;</a>
<a name="ln5590"> </a>
<a name="ln5591">      case NFA_COMPOSING:</a>
<a name="ln5592">      {</a>
<a name="ln5593">        int mc = curc;</a>
<a name="ln5594">        int len = 0;</a>
<a name="ln5595">        nfa_state_T *end;</a>
<a name="ln5596">        nfa_state_T *sta;</a>
<a name="ln5597">        int cchars[MAX_MCO];</a>
<a name="ln5598">        int ccount = 0;</a>
<a name="ln5599">        int j;</a>
<a name="ln5600"> </a>
<a name="ln5601">        sta = t-&gt;state-&gt;out;</a>
<a name="ln5602">        len = 0;</a>
<a name="ln5603">        if (utf_iscomposing(sta-&gt;c)) {</a>
<a name="ln5604">          // Only match composing character(s), ignore base</a>
<a name="ln5605">          // character.  Used for &quot;.{composing}&quot; and &quot;{composing}&quot;</a>
<a name="ln5606">          // (no preceding character).</a>
<a name="ln5607">          len += mb_char2len(mc);</a>
<a name="ln5608">        }</a>
<a name="ln5609">        if (rex.reg_icombine &amp;&amp; len == 0) {</a>
<a name="ln5610">          // If \Z was present, then ignore composing characters.</a>
<a name="ln5611">          // When ignoring the base character this always matches.</a>
<a name="ln5612">          if (sta-&gt;c != curc) {</a>
<a name="ln5613">            result = FAIL;</a>
<a name="ln5614">          } else {</a>
<a name="ln5615">            result = OK;</a>
<a name="ln5616">          }</a>
<a name="ln5617">          while (sta-&gt;c != NFA_END_COMPOSING) {</a>
<a name="ln5618">            sta = sta-&gt;out;</a>
<a name="ln5619">          }</a>
<a name="ln5620">        } else if (len &gt; 0 || mc == sta-&gt;c) {</a>
<a name="ln5621">          // Check base character matches first, unless ignored.</a>
<a name="ln5622">          if (len == 0) {</a>
<a name="ln5623">            len += mb_char2len(mc);</a>
<a name="ln5624">            sta = sta-&gt;out;</a>
<a name="ln5625">          }</a>
<a name="ln5626"> </a>
<a name="ln5627">          // We don't care about the order of composing characters.</a>
<a name="ln5628">          // Get them into cchars[] first.</a>
<a name="ln5629">          while (len &lt; clen) {</a>
<a name="ln5630">            mc = utf_ptr2char(rex.input + len);</a>
<a name="ln5631">            cchars[ccount++] = mc;</a>
<a name="ln5632">            len += mb_char2len(mc);</a>
<a name="ln5633">            if (ccount == MAX_MCO)</a>
<a name="ln5634">              break;</a>
<a name="ln5635">          }</a>
<a name="ln5636"> </a>
<a name="ln5637">          // Check that each composing char in the pattern matches a</a>
<a name="ln5638">          // composing char in the text.  We do not check if all</a>
<a name="ln5639">          // composing chars are matched.</a>
<a name="ln5640">          result = OK;</a>
<a name="ln5641">          while (sta-&gt;c != NFA_END_COMPOSING) {</a>
<a name="ln5642">            for (j = 0; j &lt; ccount; ++j)</a>
<a name="ln5643">              if (cchars[j] == sta-&gt;c)</a>
<a name="ln5644">                break;</a>
<a name="ln5645">            if (j == ccount) {</a>
<a name="ln5646">              result = FAIL;</a>
<a name="ln5647">              break;</a>
<a name="ln5648">            }</a>
<a name="ln5649">            sta = sta-&gt;out;</a>
<a name="ln5650">          }</a>
<a name="ln5651">        } else</a>
<a name="ln5652">          result = FAIL;</a>
<a name="ln5653"> </a>
<a name="ln5654">        end = t-&gt;state-&gt;out1;               // NFA_END_COMPOSING</a>
<a name="ln5655">        ADD_STATE_IF_MATCH(end);</a>
<a name="ln5656">        break;</a>
<a name="ln5657">      }</a>
<a name="ln5658"> </a>
<a name="ln5659">      case NFA_NEWL:</a>
<a name="ln5660">        if (curc == NUL &amp;&amp; !rex.reg_line_lbr &amp;&amp; REG_MULTI</a>
<a name="ln5661">            &amp;&amp; rex.lnum &lt;= rex.reg_maxline) {</a>
<a name="ln5662">          go_to_nextline = true;</a>
<a name="ln5663">          // Pass -1 for the offset, which means taking the position</a>
<a name="ln5664">          // at the start of the next line.</a>
<a name="ln5665">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5666">          add_off = -1;</a>
<a name="ln5667">        } else if (curc == '\n' &amp;&amp; rex.reg_line_lbr) {</a>
<a name="ln5668">          // match \n as if it is an ordinary character</a>
<a name="ln5669">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5670">          add_off = 1;</a>
<a name="ln5671">        }</a>
<a name="ln5672">        break;</a>
<a name="ln5673"> </a>
<a name="ln5674">      case NFA_START_COLL:</a>
<a name="ln5675">      case NFA_START_NEG_COLL:</a>
<a name="ln5676">      {</a>
<a name="ln5677">        // What follows is a list of characters, until NFA_END_COLL.</a>
<a name="ln5678">        // One of them must match or none of them must match.</a>
<a name="ln5679">        nfa_state_T     *state;</a>
<a name="ln5680">        int result_if_matched;</a>
<a name="ln5681">        int c1, c2;</a>
<a name="ln5682"> </a>
<a name="ln5683">        // Never match EOL. If it's part of the collection it is added</a>
<a name="ln5684">        // as a separate state with an OR.</a>
<a name="ln5685">        if (curc == NUL) {</a>
<a name="ln5686">          break;</a>
<a name="ln5687">        }</a>
<a name="ln5688"> </a>
<a name="ln5689">        state = t-&gt;state-&gt;out;</a>
<a name="ln5690">        result_if_matched = (t-&gt;state-&gt;c == NFA_START_COLL);</a>
<a name="ln5691">        for (;; ) {</a>
<a name="ln5692">          if (state-&gt;c == NFA_END_COLL) {</a>
<a name="ln5693">            result = !result_if_matched;</a>
<a name="ln5694">            break;</a>
<a name="ln5695">          }</a>
<a name="ln5696">          if (state-&gt;c == NFA_RANGE_MIN) {</a>
<a name="ln5697">            c1 = state-&gt;val;</a>
<a name="ln5698">            state = state-&gt;out;             // advance to NFA_RANGE_MAX</a>
<a name="ln5699">            c2 = state-&gt;val;</a>
<a name="ln5700">#ifdef REGEXP_DEBUG</a>
<a name="ln5701">            fprintf(log_fd, &quot;NFA_RANGE_MIN curc=%d c1=%d c2=%d\n&quot;,</a>
<a name="ln5702">                curc, c1, c2);</a>
<a name="ln5703">#endif</a>
<a name="ln5704">            if (curc &gt;= c1 &amp;&amp; curc &lt;= c2) {</a>
<a name="ln5705">              result = result_if_matched;</a>
<a name="ln5706">              break;</a>
<a name="ln5707">            }</a>
<a name="ln5708">            if (rex.reg_ic) {</a>
<a name="ln5709">              int curc_low = utf_fold(curc);</a>
<a name="ln5710">              int done = false;</a>
<a name="ln5711"> </a>
<a name="ln5712">              for (; c1 &lt;= c2; c1++) {</a>
<a name="ln5713">                if (utf_fold(c1) == curc_low) {</a>
<a name="ln5714">                  result = result_if_matched;</a>
<a name="ln5715">                  done = true;</a>
<a name="ln5716">                  break;</a>
<a name="ln5717">                }</a>
<a name="ln5718">              }</a>
<a name="ln5719">              if (done) {</a>
<a name="ln5720">                break;</a>
<a name="ln5721">              }</a>
<a name="ln5722">            }</a>
<a name="ln5723">          } else if (state-&gt;c &lt; 0 ? check_char_class(state-&gt;c, curc)</a>
<a name="ln5724">                     : (curc == state-&gt;c</a>
<a name="ln5725">                        || (rex.reg_ic</a>
<a name="ln5726">                            &amp;&amp; utf_fold(curc) == utf_fold(state-&gt;c)))) {</a>
<a name="ln5727">            result = result_if_matched;</a>
<a name="ln5728">            break;</a>
<a name="ln5729">          }</a>
<a name="ln5730">          state = state-&gt;out;</a>
<a name="ln5731">        }</a>
<a name="ln5732">        if (result) {</a>
<a name="ln5733">          // next state is in out of the NFA_END_COLL, out1 of</a>
<a name="ln5734">          // START points to the END state</a>
<a name="ln5735">          add_state = t-&gt;state-&gt;out1-&gt;out;</a>
<a name="ln5736">          add_off = clen;</a>
<a name="ln5737">        }</a>
<a name="ln5738">        break;</a>
<a name="ln5739">      }</a>
<a name="ln5740"> </a>
<a name="ln5741">      case NFA_ANY:</a>
<a name="ln5742">        // Any char except '\0', (end of input) does not match.</a>
<a name="ln5743">        if (curc &gt; 0) {</a>
<a name="ln5744">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5745">          add_off = clen;</a>
<a name="ln5746">        }</a>
<a name="ln5747">        break;</a>
<a name="ln5748"> </a>
<a name="ln5749">      case NFA_ANY_COMPOSING:</a>
<a name="ln5750">        // On a composing character skip over it.  Otherwise do</a>
<a name="ln5751">        // nothing.  Always matches.</a>
<a name="ln5752">        if (utf_iscomposing(curc)) {</a>
<a name="ln5753">          add_off = clen;</a>
<a name="ln5754">        } else {</a>
<a name="ln5755">          add_here = true;</a>
<a name="ln5756">          add_off = 0;</a>
<a name="ln5757">        }</a>
<a name="ln5758">        add_state = t-&gt;state-&gt;out;</a>
<a name="ln5759">        break;</a>
<a name="ln5760"> </a>
<a name="ln5761">      // Character classes like \a for alpha, \d for digit etc.</a>
<a name="ln5762">      case NFA_IDENT:           //  \i</a>
<a name="ln5763">        result = vim_isIDc(curc);</a>
<a name="ln5764">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5765">        break;</a>
<a name="ln5766"> </a>
<a name="ln5767">      case NFA_SIDENT:          //  \I</a>
<a name="ln5768">        result = !ascii_isdigit(curc) &amp;&amp; vim_isIDc(curc);</a>
<a name="ln5769">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5770">        break;</a>
<a name="ln5771"> </a>
<a name="ln5772">      case NFA_KWORD:           //  \k</a>
<a name="ln5773">        result = vim_iswordp_buf(rex.input, rex.reg_buf);</a>
<a name="ln5774">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5775">        break;</a>
<a name="ln5776"> </a>
<a name="ln5777">      case NFA_SKWORD:          //  \K</a>
<a name="ln5778">        result = !ascii_isdigit(curc)</a>
<a name="ln5779">                 &amp;&amp; vim_iswordp_buf(rex.input, rex.reg_buf);</a>
<a name="ln5780">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5781">        break;</a>
<a name="ln5782"> </a>
<a name="ln5783">      case NFA_FNAME:           //  \f</a>
<a name="ln5784">        result = vim_isfilec(curc);</a>
<a name="ln5785">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5786">        break;</a>
<a name="ln5787"> </a>
<a name="ln5788">      case NFA_SFNAME:          //  \F</a>
<a name="ln5789">        result = !ascii_isdigit(curc) &amp;&amp; vim_isfilec(curc);</a>
<a name="ln5790">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5791">        break;</a>
<a name="ln5792"> </a>
<a name="ln5793">      case NFA_PRINT:           //  \p</a>
<a name="ln5794">        result = vim_isprintc(PTR2CHAR(rex.input));</a>
<a name="ln5795">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5796">        break;</a>
<a name="ln5797"> </a>
<a name="ln5798">      case NFA_SPRINT:          //  \P</a>
<a name="ln5799">        result = !ascii_isdigit(curc) &amp;&amp; vim_isprintc(PTR2CHAR(rex.input));</a>
<a name="ln5800">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5801">        break;</a>
<a name="ln5802"> </a>
<a name="ln5803">      case NFA_WHITE:           //  \s</a>
<a name="ln5804">        result = ascii_iswhite(curc);</a>
<a name="ln5805">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5806">        break;</a>
<a name="ln5807"> </a>
<a name="ln5808">      case NFA_NWHITE:          //  \S</a>
<a name="ln5809">        result = curc != NUL &amp;&amp; !ascii_iswhite(curc);</a>
<a name="ln5810">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5811">        break;</a>
<a name="ln5812"> </a>
<a name="ln5813">      case NFA_DIGIT:           //  \d</a>
<a name="ln5814">        result = ri_digit(curc);</a>
<a name="ln5815">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5816">        break;</a>
<a name="ln5817"> </a>
<a name="ln5818">      case NFA_NDIGIT:          //  \D</a>
<a name="ln5819">        result = curc != NUL &amp;&amp; !ri_digit(curc);</a>
<a name="ln5820">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5821">        break;</a>
<a name="ln5822"> </a>
<a name="ln5823">      case NFA_HEX:             //  \x</a>
<a name="ln5824">        result = ri_hex(curc);</a>
<a name="ln5825">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5826">        break;</a>
<a name="ln5827"> </a>
<a name="ln5828">      case NFA_NHEX:            //  \X</a>
<a name="ln5829">        result = curc != NUL &amp;&amp; !ri_hex(curc);</a>
<a name="ln5830">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5831">        break;</a>
<a name="ln5832"> </a>
<a name="ln5833">      case NFA_OCTAL:           //  \o</a>
<a name="ln5834">        result = ri_octal(curc);</a>
<a name="ln5835">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5836">        break;</a>
<a name="ln5837"> </a>
<a name="ln5838">      case NFA_NOCTAL:          //  \O</a>
<a name="ln5839">        result = curc != NUL &amp;&amp; !ri_octal(curc);</a>
<a name="ln5840">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5841">        break;</a>
<a name="ln5842"> </a>
<a name="ln5843">      case NFA_WORD:            //  \w</a>
<a name="ln5844">        result = ri_word(curc);</a>
<a name="ln5845">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5846">        break;</a>
<a name="ln5847"> </a>
<a name="ln5848">      case NFA_NWORD:           //  \W</a>
<a name="ln5849">        result = curc != NUL &amp;&amp; !ri_word(curc);</a>
<a name="ln5850">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5851">        break;</a>
<a name="ln5852"> </a>
<a name="ln5853">      case NFA_HEAD:            //  \h</a>
<a name="ln5854">        result = ri_head(curc);</a>
<a name="ln5855">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5856">        break;</a>
<a name="ln5857"> </a>
<a name="ln5858">      case NFA_NHEAD:           //  \H</a>
<a name="ln5859">        result = curc != NUL &amp;&amp; !ri_head(curc);</a>
<a name="ln5860">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5861">        break;</a>
<a name="ln5862"> </a>
<a name="ln5863">      case NFA_ALPHA:           //  \a</a>
<a name="ln5864">        result = ri_alpha(curc);</a>
<a name="ln5865">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5866">        break;</a>
<a name="ln5867"> </a>
<a name="ln5868">      case NFA_NALPHA:          //  \A</a>
<a name="ln5869">        result = curc != NUL &amp;&amp; !ri_alpha(curc);</a>
<a name="ln5870">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5871">        break;</a>
<a name="ln5872"> </a>
<a name="ln5873">      case NFA_LOWER:           //  \l</a>
<a name="ln5874">        result = ri_lower(curc);</a>
<a name="ln5875">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5876">        break;</a>
<a name="ln5877"> </a>
<a name="ln5878">      case NFA_NLOWER:          //  \L</a>
<a name="ln5879">        result = curc != NUL &amp;&amp; !ri_lower(curc);</a>
<a name="ln5880">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5881">        break;</a>
<a name="ln5882"> </a>
<a name="ln5883">      case NFA_UPPER:           //  \u</a>
<a name="ln5884">        result = ri_upper(curc);</a>
<a name="ln5885">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5886">        break;</a>
<a name="ln5887"> </a>
<a name="ln5888">      case NFA_NUPPER:          // \U</a>
<a name="ln5889">        result = curc != NUL &amp;&amp; !ri_upper(curc);</a>
<a name="ln5890">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5891">        break;</a>
<a name="ln5892"> </a>
<a name="ln5893">      case NFA_LOWER_IC:        // [a-z]</a>
<a name="ln5894">        result = ri_lower(curc) || (rex.reg_ic &amp;&amp; ri_upper(curc));</a>
<a name="ln5895">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5896">        break;</a>
<a name="ln5897"> </a>
<a name="ln5898">      case NFA_NLOWER_IC:       // [^a-z]</a>
<a name="ln5899">        result = curc != NUL</a>
<a name="ln5900">                 &amp;&amp; !(ri_lower(curc) || (rex.reg_ic &amp;&amp; ri_upper(curc)));</a>
<a name="ln5901">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5902">        break;</a>
<a name="ln5903"> </a>
<a name="ln5904">      case NFA_UPPER_IC:        // [A-Z]</a>
<a name="ln5905">        result = ri_upper(curc) || (rex.reg_ic &amp;&amp; ri_lower(curc));</a>
<a name="ln5906">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5907">        break;</a>
<a name="ln5908"> </a>
<a name="ln5909">      case NFA_NUPPER_IC:       // [^A-Z]</a>
<a name="ln5910">        result = curc != NUL</a>
<a name="ln5911">                 &amp;&amp; !(ri_upper(curc) || (rex.reg_ic &amp;&amp; ri_lower(curc)));</a>
<a name="ln5912">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5913">        break;</a>
<a name="ln5914"> </a>
<a name="ln5915">      case NFA_BACKREF1:</a>
<a name="ln5916">      case NFA_BACKREF2:</a>
<a name="ln5917">      case NFA_BACKREF3:</a>
<a name="ln5918">      case NFA_BACKREF4:</a>
<a name="ln5919">      case NFA_BACKREF5:</a>
<a name="ln5920">      case NFA_BACKREF6:</a>
<a name="ln5921">      case NFA_BACKREF7:</a>
<a name="ln5922">      case NFA_BACKREF8:</a>
<a name="ln5923">      case NFA_BACKREF9:</a>
<a name="ln5924">      case NFA_ZREF1:</a>
<a name="ln5925">      case NFA_ZREF2:</a>
<a name="ln5926">      case NFA_ZREF3:</a>
<a name="ln5927">      case NFA_ZREF4:</a>
<a name="ln5928">      case NFA_ZREF5:</a>
<a name="ln5929">      case NFA_ZREF6:</a>
<a name="ln5930">      case NFA_ZREF7:</a>
<a name="ln5931">      case NFA_ZREF8:</a>
<a name="ln5932">      case NFA_ZREF9:</a>
<a name="ln5933">        // \1 .. \9  \z1 .. \z9</a>
<a name="ln5934">      {</a>
<a name="ln5935">        int subidx;</a>
<a name="ln5936">        int bytelen;</a>
<a name="ln5937"> </a>
<a name="ln5938">        if (t-&gt;state-&gt;c &lt;= NFA_BACKREF9) {</a>
<a name="ln5939">          subidx = t-&gt;state-&gt;c - NFA_BACKREF1 + 1;</a>
<a name="ln5940">          result = match_backref(&amp;t-&gt;subs.norm, subidx, &amp;bytelen);</a>
<a name="ln5941">        } else {</a>
<a name="ln5942">          subidx = t-&gt;state-&gt;c - NFA_ZREF1 + 1;</a>
<a name="ln5943">          result = match_zref(subidx, &amp;bytelen);</a>
<a name="ln5944">        }</a>
<a name="ln5945"> </a>
<a name="ln5946">        if (result) {</a>
<a name="ln5947">          if (bytelen == 0) {</a>
<a name="ln5948">            // empty match always works, output of NFA_SKIP to be</a>
<a name="ln5949">            // used next</a>
<a name="ln5950">            add_here = true;</a>
<a name="ln5951">            add_state = t-&gt;state-&gt;out-&gt;out;</a>
<a name="ln5952">          } else if (bytelen &lt;= clen) {</a>
<a name="ln5953">            // match current character, jump ahead to out of</a>
<a name="ln5954">            // NFA_SKIP</a>
<a name="ln5955">            add_state = t-&gt;state-&gt;out-&gt;out;</a>
<a name="ln5956">            add_off = clen;</a>
<a name="ln5957">          } else {</a>
<a name="ln5958">            // skip over the matched characters, set character</a>
<a name="ln5959">            // count in NFA_SKIP</a>
<a name="ln5960">            add_state = t-&gt;state-&gt;out;</a>
<a name="ln5961">            add_off = bytelen;</a>
<a name="ln5962">            add_count = bytelen - clen;</a>
<a name="ln5963">          }</a>
<a name="ln5964">        }</a>
<a name="ln5965">        break;</a>
<a name="ln5966">      }</a>
<a name="ln5967">      case NFA_SKIP:</a>
<a name="ln5968">        // character of previous matching \1 .. \9  or \@&gt;</a>
<a name="ln5969">        if (t-&gt;count - clen &lt;= 0) {</a>
<a name="ln5970">          // end of match, go to what follows</a>
<a name="ln5971">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5972">          add_off = clen;</a>
<a name="ln5973">        } else {</a>
<a name="ln5974">          // add state again with decremented count</a>
<a name="ln5975">          add_state = t-&gt;state;</a>
<a name="ln5976">          add_off = 0;</a>
<a name="ln5977">          add_count = t-&gt;count - clen;</a>
<a name="ln5978">        }</a>
<a name="ln5979">        break;</a>
<a name="ln5980"> </a>
<a name="ln5981">      case NFA_LNUM:</a>
<a name="ln5982">      case NFA_LNUM_GT:</a>
<a name="ln5983">      case NFA_LNUM_LT:</a>
<a name="ln5984">        assert(t-&gt;state-&gt;val &gt;= 0</a>
<a name="ln5985">               &amp;&amp; !((rex.reg_firstlnum &gt; 0</a>
<a name="ln5986">                     &amp;&amp; rex.lnum &gt; LONG_MAX - rex.reg_firstlnum)</a>
<a name="ln5987">                    || (rex.reg_firstlnum &lt; 0</a>
<a name="ln5988">                        &amp;&amp; rex.lnum &lt; LONG_MIN + rex.reg_firstlnum))</a>
<a name="ln5989">               &amp;&amp; rex.lnum + rex.reg_firstlnum &gt;= 0);</a>
<a name="ln5990">        result = (REG_MULTI</a>
<a name="ln5991">                  &amp;&amp; nfa_re_num_cmp((uintmax_t)t-&gt;state-&gt;val,</a>
<a name="ln5992">                                    t-&gt;state-&gt;c - NFA_LNUM,</a>
<a name="ln5993">                                    (uintmax_t)(rex.lnum + rex.reg_firstlnum)));</a>
<a name="ln5994">        if (result) {</a>
<a name="ln5995">          add_here = true;</a>
<a name="ln5996">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5997">        }</a>
<a name="ln5998">        break;</a>
<a name="ln5999"> </a>
<a name="ln6000">      case NFA_COL:</a>
<a name="ln6001">      case NFA_COL_GT:</a>
<a name="ln6002">      case NFA_COL_LT:</a>
<a name="ln6003">        assert(t-&gt;state-&gt;val &gt;= 0</a>
<a name="ln6004">               &amp;&amp; rex.input &gt;= rex.line</a>
<a name="ln6005">               &amp;&amp; (uintmax_t)(rex.input - rex.line) &lt;= UINTMAX_MAX - 1);</a>
<a name="ln6006">        result = nfa_re_num_cmp((uintmax_t)t-&gt;state-&gt;val,</a>
<a name="ln6007">                                t-&gt;state-&gt;c - NFA_COL,</a>
<a name="ln6008">                                (uintmax_t)(rex.input - rex.line + 1));</a>
<a name="ln6009">        if (result) {</a>
<a name="ln6010">          add_here = true;</a>
<a name="ln6011">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln6012">        }</a>
<a name="ln6013">        break;</a>
<a name="ln6014"> </a>
<a name="ln6015">      case NFA_VCOL:</a>
<a name="ln6016">      case NFA_VCOL_GT:</a>
<a name="ln6017">      case NFA_VCOL_LT:</a>
<a name="ln6018">        {</a>
<a name="ln6019">          int op = t-&gt;state-&gt;c - NFA_VCOL;</a>
<a name="ln6020">          colnr_T col = (colnr_T)(rex.input - rex.line);</a>
<a name="ln6021"> </a>
<a name="ln6022">          // Bail out quickly when there can't be a match, avoid the overhead of</a>
<a name="ln6023">          // win_linetabsize() on long lines.</a>
<a name="ln6024">          if (op != 1 &amp;&amp; col &gt; t-&gt;state-&gt;val * MB_MAXBYTES) {</a>
<a name="ln6025">            break;</a>
<a name="ln6026">          }</a>
<a name="ln6027"> </a>
<a name="ln6028">          result = false;</a>
<a name="ln6029">          win_T *wp = rex.reg_win == NULL ? curwin : rex.reg_win;</a>
<a name="ln6030">          if (op == 1 &amp;&amp; col - 1 &gt; t-&gt;state-&gt;val &amp;&amp; col &gt; 100) {</a>
<a name="ln6031">            long ts = wp-&gt;w_buffer-&gt;b_p_ts;</a>
<a name="ln6032"> </a>
<a name="ln6033">            // Guess that a character won't use more columns than 'tabstop',</a>
<a name="ln6034">            // with a minimum of 4.</a>
<a name="ln6035">            if (ts &lt; 4) {</a>
<a name="ln6036">              ts = 4;</a>
<a name="ln6037">            }</a>
<a name="ln6038">            result = col &gt; t-&gt;state-&gt;val * ts;</a>
<a name="ln6039">          }</a>
<a name="ln6040">          if (!result) {</a>
<a name="ln6041">            uintmax_t lts = win_linetabsize(wp, rex.line, col);</a>
<a name="ln6042">            assert(t-&gt;state-&gt;val &gt;= 0);</a>
<a name="ln6043">            result = nfa_re_num_cmp((uintmax_t)t-&gt;state-&gt;val, op, lts + 1);</a>
<a name="ln6044">          }</a>
<a name="ln6045">          if (result) {</a>
<a name="ln6046">            add_here = true;</a>
<a name="ln6047">            add_state = t-&gt;state-&gt;out;</a>
<a name="ln6048">          }</a>
<a name="ln6049">        }</a>
<a name="ln6050">        break;</a>
<a name="ln6051"> </a>
<a name="ln6052">      case NFA_MARK:</a>
<a name="ln6053">      case NFA_MARK_GT:</a>
<a name="ln6054">      case NFA_MARK_LT:</a>
<a name="ln6055">      {</a>
<a name="ln6056">        pos_T *pos = getmark_buf(rex.reg_buf, t-&gt;state-&gt;val, false);</a>
<a name="ln6057"> </a>
<a name="ln6058">        // Compare the mark position to the match position.</a>
<a name="ln6059">        result = (pos != NULL                        // mark doesn't exist</a>
<a name="ln6060">                  &amp;&amp; pos-&gt;lnum &gt; 0          // mark isn't set in reg_buf</a>
<a name="ln6061">                  &amp;&amp; (pos-&gt;lnum == rex.lnum + rex.reg_firstlnum</a>
<a name="ln6062">                      ? (pos-&gt;col == (colnr_T)(rex.input - rex.line)</a>
<a name="ln6063">                         ? t-&gt;state-&gt;c == NFA_MARK</a>
<a name="ln6064">                         : (pos-&gt;col &lt; (colnr_T)(rex.input - rex.line)</a>
<a name="ln6065">                            ? t-&gt;state-&gt;c == NFA_MARK_GT</a>
<a name="ln6066">                            : t-&gt;state-&gt;c == NFA_MARK_LT))</a>
<a name="ln6067">                      : (pos-&gt;lnum &lt; rex.lnum + rex.reg_firstlnum</a>
<a name="ln6068">                         ? t-&gt;state-&gt;c == NFA_MARK_GT</a>
<a name="ln6069">                         : t-&gt;state-&gt;c == NFA_MARK_LT)));</a>
<a name="ln6070">        if (result) {</a>
<a name="ln6071">          add_here = true;</a>
<a name="ln6072">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln6073">        }</a>
<a name="ln6074">        break;</a>
<a name="ln6075">      }</a>
<a name="ln6076"> </a>
<a name="ln6077">      case NFA_CURSOR:</a>
<a name="ln6078">        result = rex.reg_win != NULL</a>
<a name="ln6079">          &amp;&amp; (rex.lnum + rex.reg_firstlnum == rex.reg_win-&gt;w_cursor.lnum)</a>
<a name="ln6080">          &amp;&amp; ((colnr_T)(rex.input - rex.line) == rex.reg_win-&gt;w_cursor.col);</a>
<a name="ln6081">        if (result) {</a>
<a name="ln6082">          add_here = true;</a>
<a name="ln6083">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln6084">        }</a>
<a name="ln6085">        break;</a>
<a name="ln6086"> </a>
<a name="ln6087">      case NFA_VISUAL:</a>
<a name="ln6088">        result = reg_match_visual();</a>
<a name="ln6089">        if (result) {</a>
<a name="ln6090">          add_here = true;</a>
<a name="ln6091">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln6092">        }</a>
<a name="ln6093">        break;</a>
<a name="ln6094"> </a>
<a name="ln6095">      case NFA_MOPEN1:</a>
<a name="ln6096">      case NFA_MOPEN2:</a>
<a name="ln6097">      case NFA_MOPEN3:</a>
<a name="ln6098">      case NFA_MOPEN4:</a>
<a name="ln6099">      case NFA_MOPEN5:</a>
<a name="ln6100">      case NFA_MOPEN6:</a>
<a name="ln6101">      case NFA_MOPEN7:</a>
<a name="ln6102">      case NFA_MOPEN8:</a>
<a name="ln6103">      case NFA_MOPEN9:</a>
<a name="ln6104">      case NFA_ZOPEN:</a>
<a name="ln6105">      case NFA_ZOPEN1:</a>
<a name="ln6106">      case NFA_ZOPEN2:</a>
<a name="ln6107">      case NFA_ZOPEN3:</a>
<a name="ln6108">      case NFA_ZOPEN4:</a>
<a name="ln6109">      case NFA_ZOPEN5:</a>
<a name="ln6110">      case NFA_ZOPEN6:</a>
<a name="ln6111">      case NFA_ZOPEN7:</a>
<a name="ln6112">      case NFA_ZOPEN8:</a>
<a name="ln6113">      case NFA_ZOPEN9:</a>
<a name="ln6114">      case NFA_NOPEN:</a>
<a name="ln6115">      case NFA_ZSTART:</a>
<a name="ln6116">        // These states are only added to be able to bail out when</a>
<a name="ln6117">        // they are added again, nothing is to be done.</a>
<a name="ln6118">        break;</a>
<a name="ln6119"> </a>
<a name="ln6120">      default:          // regular character</a>
<a name="ln6121">      {</a>
<a name="ln6122">        int c = t-&gt;state-&gt;c;</a>
<a name="ln6123"> </a>
<a name="ln6124">#ifdef REGEXP_DEBUG</a>
<a name="ln6125">        if (c &lt; 0) {</a>
<a name="ln6126">          IEMSGN(&quot;INTERNAL: Negative state char: %&quot; PRId64, c);</a>
<a name="ln6127">        }</a>
<a name="ln6128">#endif</a>
<a name="ln6129">        result = (c == curc);</a>
<a name="ln6130"> </a>
<a name="ln6131">        if (!result &amp;&amp; rex.reg_ic) {</a>
<a name="ln6132">          result = utf_fold(c) == utf_fold(curc);</a>
<a name="ln6133">        }</a>
<a name="ln6134"> </a>
<a name="ln6135">        // If rex.reg_icombine is not set only skip over the character</a>
<a name="ln6136">        // itself.  When it is set skip over composing characters.</a>
<a name="ln6137">        if (result &amp;&amp; !rex.reg_icombine) {</a>
<a name="ln6138">          clen = utf_ptr2len(rex.input);</a>
<a name="ln6139">        }</a>
<a name="ln6140"> </a>
<a name="ln6141">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln6142">        break;</a>
<a name="ln6143">      }</a>
<a name="ln6144">      }       // switch (t-&gt;state-&gt;c)</a>
<a name="ln6145"> </a>
<a name="ln6146">      if (add_state != NULL) {</a>
<a name="ln6147">        nfa_pim_T *pim;</a>
<a name="ln6148">        nfa_pim_T pim_copy;</a>
<a name="ln6149"> </a>
<a name="ln6150">        if (t-&gt;pim.result == NFA_PIM_UNUSED)</a>
<a name="ln6151">          pim = NULL;</a>
<a name="ln6152">        else</a>
<a name="ln6153">          pim = &amp;t-&gt;pim;</a>
<a name="ln6154"> </a>
<a name="ln6155">        // Handle the postponed invisible match if the match might end</a>
<a name="ln6156">        // without advancing and before the end of the line.</a>
<a name="ln6157">        if (pim != NULL &amp;&amp; (clen == 0 || match_follows(add_state, 0))) {</a>
<a name="ln6158">          if (pim-&gt;result == NFA_PIM_TODO) {</a>
<a name="ln6159">#ifdef REGEXP_DEBUG</a>
<a name="ln6160">            fprintf(log_fd, &quot;\n&quot;);</a>
<a name="ln6161">            fprintf(log_fd, &quot;==================================\n&quot;);</a>
<a name="ln6162">            fprintf(log_fd, &quot;Postponed recursive nfa_regmatch()\n&quot;);</a>
<a name="ln6163">            fprintf(log_fd, &quot;\n&quot;);</a>
<a name="ln6164">#endif</a>
<a name="ln6165">            result = recursive_regmatch(pim-&gt;state, pim, prog, submatch, m,</a>
<a name="ln6166">                                        &amp;listids, &amp;listids_len);</a>
<a name="ln6167">            pim-&gt;result = result ? NFA_PIM_MATCH : NFA_PIM_NOMATCH;</a>
<a name="ln6168">            // for \@! and \@&lt;! it is a match when the result is</a>
<a name="ln6169">            // false</a>
<a name="ln6170">            if (result != (pim-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG</a>
<a name="ln6171">                           || pim-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG_FIRST</a>
<a name="ln6172">                           || pim-&gt;state-&gt;c</a>
<a name="ln6173">                           == NFA_START_INVISIBLE_BEFORE_NEG</a>
<a name="ln6174">                           || pim-&gt;state-&gt;c</a>
<a name="ln6175">                           == NFA_START_INVISIBLE_BEFORE_NEG_FIRST)) {</a>
<a name="ln6176">              // Copy submatch info from the recursive call</a>
<a name="ln6177">              copy_sub_off(&amp;pim-&gt;subs.norm, &amp;m-&gt;norm);</a>
<a name="ln6178">              if (rex.nfa_has_zsubexpr) {</a>
<a name="ln6179">                copy_sub_off(&amp;pim-&gt;subs.synt, &amp;m-&gt;synt);</a>
<a name="ln6180">              }</a>
<a name="ln6181">            }</a>
<a name="ln6182">          } else {</a>
<a name="ln6183">            result = (pim-&gt;result == NFA_PIM_MATCH);</a>
<a name="ln6184">#ifdef REGEXP_DEBUG</a>
<a name="ln6185">            fprintf(log_fd, &quot;\n&quot;);</a>
<a name="ln6186">            fprintf(</a>
<a name="ln6187">                log_fd,</a>
<a name="ln6188">                &quot;Using previous recursive nfa_regmatch() result, result == %d\n&quot;,</a>
<a name="ln6189">                pim-&gt;result);</a>
<a name="ln6190">            fprintf(log_fd, &quot;MATCH = %s\n&quot;, result ? &quot;OK&quot; : &quot;false&quot;);</a>
<a name="ln6191">            fprintf(log_fd, &quot;\n&quot;);</a>
<a name="ln6192">#endif</a>
<a name="ln6193">          }</a>
<a name="ln6194"> </a>
<a name="ln6195">          // for \@! and \@&lt;! it is a match when result is false</a>
<a name="ln6196">          if (result != (pim-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG</a>
<a name="ln6197">                         || pim-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG_FIRST</a>
<a name="ln6198">                         || pim-&gt;state-&gt;c</a>
<a name="ln6199">                         == NFA_START_INVISIBLE_BEFORE_NEG</a>
<a name="ln6200">                         || pim-&gt;state-&gt;c</a>
<a name="ln6201">                         == NFA_START_INVISIBLE_BEFORE_NEG_FIRST)) {</a>
<a name="ln6202">            // Copy submatch info from the recursive call</a>
<a name="ln6203">            copy_sub_off(&amp;t-&gt;subs.norm, &amp;pim-&gt;subs.norm);</a>
<a name="ln6204">            if (rex.nfa_has_zsubexpr) {</a>
<a name="ln6205">              copy_sub_off(&amp;t-&gt;subs.synt, &amp;pim-&gt;subs.synt);</a>
<a name="ln6206">            }</a>
<a name="ln6207">          } else {</a>
<a name="ln6208">            // look-behind match failed, don't add the state</a>
<a name="ln6209">            continue;</a>
<a name="ln6210">          }</a>
<a name="ln6211"> </a>
<a name="ln6212">          // Postponed invisible match was handled, don't add it to</a>
<a name="ln6213">          // following states.</a>
<a name="ln6214">          pim = NULL;</a>
<a name="ln6215">        }</a>
<a name="ln6216"> </a>
<a name="ln6217">        // If &quot;pim&quot; points into l-&gt;t it will become invalid when</a>
<a name="ln6218">        // adding the state causes the list to be reallocated.  Make a</a>
<a name="ln6219">        // local copy to avoid that.</a>
<a name="ln6220">        if (pim == &amp;t-&gt;pim) {</a>
<a name="ln6221">          copy_pim(&amp;pim_copy, pim);</a>
<a name="ln6222">          pim = &amp;pim_copy;</a>
<a name="ln6223">        }</a>
<a name="ln6224"> </a>
<a name="ln6225">        if (add_here) {</a>
<a name="ln6226">          r = addstate_here(thislist, add_state, &amp;t-&gt;subs, pim, &amp;listidx);</a>
<a name="ln6227">        } else {</a>
<a name="ln6228">          r = addstate(nextlist, add_state, &amp;t-&gt;subs, pim, add_off);</a>
<a name="ln6229">          if (add_count &gt; 0) {</a>
<a name="ln6230">            nextlist-&gt;t[nextlist-&gt;n - 1].count = add_count;</a>
<a name="ln6231">          }</a>
<a name="ln6232">        }</a>
<a name="ln6233">        if (r == NULL) {</a>
<a name="ln6234">          nfa_match = NFA_TOO_EXPENSIVE;</a>
<a name="ln6235">          goto theend;</a>
<a name="ln6236">        }</a>
<a name="ln6237">      }</a>
<a name="ln6238">    }     // for (thislist = thislist; thislist-&gt;state; thislist++)</a>
<a name="ln6239"> </a>
<a name="ln6240">    // Look for the start of a match in the current position by adding the</a>
<a name="ln6241">    // start state to the list of states.</a>
<a name="ln6242">    // The first found match is the leftmost one, thus the order of states</a>
<a name="ln6243">    // matters!</a>
<a name="ln6244">    // Do not add the start state in recursive calls of nfa_regmatch(),</a>
<a name="ln6245">    // because recursive calls should only start in the first position.</a>
<a name="ln6246">    // Unless &quot;nfa_endp&quot; is not NULL, then we match the end position.</a>
<a name="ln6247">    // Also don't start a match past the first line.</a>
<a name="ln6248">    if (!nfa_match</a>
<a name="ln6249">        &amp;&amp; ((toplevel</a>
<a name="ln6250">             &amp;&amp; rex.lnum == 0</a>
<a name="ln6251">             &amp;&amp; clen != 0</a>
<a name="ln6252">             &amp;&amp; (rex.reg_maxcol == 0</a>
<a name="ln6253">                 || (colnr_T)(rex.input - rex.line) &lt; rex.reg_maxcol))</a>
<a name="ln6254">            || (nfa_endp != NULL</a>
<a name="ln6255">                &amp;&amp; (REG_MULTI</a>
<a name="ln6256">                    ? (rex.lnum &lt; nfa_endp-&gt;se_u.pos.lnum</a>
<a name="ln6257">                       || (rex.lnum == nfa_endp-&gt;se_u.pos.lnum</a>
<a name="ln6258">                           &amp;&amp; (int)(rex.input - rex.line)</a>
<a name="ln6259">                           &lt; nfa_endp-&gt;se_u.pos.col))</a>
<a name="ln6260">                    : rex.input &lt; nfa_endp-&gt;se_u.ptr)))) {</a>
<a name="ln6261">#ifdef REGEXP_DEBUG</a>
<a name="ln6262">      fprintf(log_fd, &quot;(---) STARTSTATE\n&quot;);</a>
<a name="ln6263">#endif</a>
<a name="ln6264">      // Inline optimized code for addstate() if we know the state is</a>
<a name="ln6265">      // the first MOPEN.</a>
<a name="ln6266">      if (toplevel) {</a>
<a name="ln6267">        int add = true;</a>
<a name="ln6268"> </a>
<a name="ln6269">        if (prog-&gt;regstart != NUL &amp;&amp; clen != 0) {</a>
<a name="ln6270">          if (nextlist-&gt;n == 0) {</a>
<a name="ln6271">            colnr_T col = (colnr_T)(rex.input - rex.line) + clen;</a>
<a name="ln6272"> </a>
<a name="ln6273">            // Nextlist is empty, we can skip ahead to the</a>
<a name="ln6274">            // character that must appear at the start.</a>
<a name="ln6275">            if (skip_to_start(prog-&gt;regstart, &amp;col) == FAIL) {</a>
<a name="ln6276">              break;</a>
<a name="ln6277">            }</a>
<a name="ln6278">#ifdef REGEXP_DEBUG</a>
<a name="ln6279">            fprintf(log_fd, &quot;  Skipping ahead %d bytes to regstart\n&quot;,</a>
<a name="ln6280">                    col - ((colnr_T)(rex.input - rex.line) + clen));</a>
<a name="ln6281">#endif</a>
<a name="ln6282">            rex.input = rex.line + col - clen;</a>
<a name="ln6283">          } else {</a>
<a name="ln6284">            // Checking if the required start character matches is</a>
<a name="ln6285">            // cheaper than adding a state that won't match.</a>
<a name="ln6286">            const int c = PTR2CHAR(rex.input + clen);</a>
<a name="ln6287">            if (c != prog-&gt;regstart</a>
<a name="ln6288">                &amp;&amp; (!rex.reg_ic</a>
<a name="ln6289">                    || utf_fold(c) != utf_fold(prog-&gt;regstart))) {</a>
<a name="ln6290">#ifdef REGEXP_DEBUG</a>
<a name="ln6291">              fprintf(log_fd,</a>
<a name="ln6292">                  &quot;  Skipping start state, regstart does not match\n&quot;);</a>
<a name="ln6293">#endif</a>
<a name="ln6294">              add = false;</a>
<a name="ln6295">            }</a>
<a name="ln6296">          }</a>
<a name="ln6297">        }</a>
<a name="ln6298"> </a>
<a name="ln6299">        if (add) {</a>
<a name="ln6300">          if (REG_MULTI) {</a>
<a name="ln6301">            m-&gt;norm.list.multi[0].start_col =</a>
<a name="ln6302">              (colnr_T)(rex.input - rex.line) + clen;</a>
<a name="ln6303">          } else {</a>
<a name="ln6304">            m-&gt;norm.list.line[0].start = rex.input + clen;</a>
<a name="ln6305">          }</a>
<a name="ln6306">          if (addstate(nextlist, start-&gt;out, m, NULL, clen) == NULL) {</a>
<a name="ln6307">            nfa_match = NFA_TOO_EXPENSIVE;</a>
<a name="ln6308">            goto theend;</a>
<a name="ln6309">          }</a>
<a name="ln6310">        }</a>
<a name="ln6311">      } else {</a>
<a name="ln6312">        if (addstate(nextlist, start, m, NULL, clen) == NULL) {</a>
<a name="ln6313">          nfa_match = NFA_TOO_EXPENSIVE;</a>
<a name="ln6314">          goto theend;</a>
<a name="ln6315">        }</a>
<a name="ln6316">      }</a>
<a name="ln6317">    }</a>
<a name="ln6318"> </a>
<a name="ln6319">#ifdef REGEXP_DEBUG</a>
<a name="ln6320">    fprintf(log_fd, &quot;&gt;&gt;&gt; Thislist had %d states available: &quot;, thislist-&gt;n);</a>
<a name="ln6321">    {</a>
<a name="ln6322">      int i;</a>
<a name="ln6323"> </a>
<a name="ln6324">      for (i = 0; i &lt; thislist-&gt;n; i++)</a>
<a name="ln6325">        fprintf(log_fd, &quot;%d  &quot;, abs(thislist-&gt;t[i].state-&gt;id));</a>
<a name="ln6326">    }</a>
<a name="ln6327">    fprintf(log_fd, &quot;\n&quot;);</a>
<a name="ln6328">#endif</a>
<a name="ln6329"> </a>
<a name="ln6330">nextchar:</a>
<a name="ln6331">    // Advance to the next character, or advance to the next line, or</a>
<a name="ln6332">    // finish.</a>
<a name="ln6333">    if (clen != 0) {</a>
<a name="ln6334">      rex.input += clen;</a>
<a name="ln6335">    } else if (go_to_nextline || (nfa_endp != NULL &amp;&amp; REG_MULTI</a>
<a name="ln6336">                                  &amp;&amp; rex.lnum &lt; nfa_endp-&gt;se_u.pos.lnum)) {</a>
<a name="ln6337">      reg_nextline();</a>
<a name="ln6338">    } else {</a>
<a name="ln6339">      break;</a>
<a name="ln6340">    }</a>
<a name="ln6341"> </a>
<a name="ln6342">    // Allow interrupting with CTRL-C.</a>
<a name="ln6343">    line_breakcheck();</a>
<a name="ln6344">    if (got_int) {</a>
<a name="ln6345">      break;</a>
<a name="ln6346">    }</a>
<a name="ln6347">    // Check for timeout once every twenty times to avoid overhead.</a>
<a name="ln6348">    if (nfa_time_limit != NULL &amp;&amp; ++nfa_time_count == 20) {</a>
<a name="ln6349">      nfa_time_count = 0;</a>
<a name="ln6350">      if (nfa_did_time_out()) {</a>
<a name="ln6351">        break;</a>
<a name="ln6352">      }</a>
<a name="ln6353">    }</a>
<a name="ln6354">  }</a>
<a name="ln6355"> </a>
<a name="ln6356">#ifdef REGEXP_DEBUG</a>
<a name="ln6357">  if (log_fd != stderr)</a>
<a name="ln6358">    fclose(log_fd);</a>
<a name="ln6359">  log_fd = NULL;</a>
<a name="ln6360">#endif</a>
<a name="ln6361"> </a>
<a name="ln6362">theend:</a>
<a name="ln6363">  // Free memory</a>
<a name="ln6364">  xfree(list[0].t);</a>
<a name="ln6365">  xfree(list[1].t);</a>
<a name="ln6366">  xfree(listids);</a>
<a name="ln6367">#undef ADD_STATE_IF_MATCH</a>
<a name="ln6368">#ifdef NFA_REGEXP_DEBUG_LOG</a>
<a name="ln6369">  fclose(debug);</a>
<a name="ln6370">#endif</a>
<a name="ln6371"> </a>
<a name="ln6372">  return nfa_match;</a>
<a name="ln6373">}</a>
<a name="ln6374"> </a>
<a name="ln6375">// Try match of &quot;prog&quot; with at rex.line[&quot;col&quot;].</a>
<a name="ln6376">// Returns &lt;= 0 for failure, number of lines contained in the match otherwise.</a>
<a name="ln6377">static long nfa_regtry(nfa_regprog_T *prog,</a>
<a name="ln6378">                       colnr_T col,</a>
<a name="ln6379">                       proftime_T *tm,    // timeout limit or NULL</a>
<a name="ln6380">                       int *timed_out)    // flag set on timeout or NULL</a>
<a name="ln6381">{</a>
<a name="ln6382">  int i;</a>
<a name="ln6383">  regsubs_T subs, m;</a>
<a name="ln6384">  nfa_state_T *start = prog-&gt;start;</a>
<a name="ln6385">#ifdef REGEXP_DEBUG</a>
<a name="ln6386">  FILE        *f;</a>
<a name="ln6387">#endif</a>
<a name="ln6388"> </a>
<a name="ln6389">  rex.input = rex.line + col;</a>
<a name="ln6390">  nfa_time_limit = tm;</a>
<a name="ln6391">  nfa_timed_out = timed_out;</a>
<a name="ln6392">  nfa_time_count = 0;</a>
<a name="ln6393"> </a>
<a name="ln6394">#ifdef REGEXP_DEBUG</a>
<a name="ln6395">  f = fopen(NFA_REGEXP_RUN_LOG, &quot;a&quot;);</a>
<a name="ln6396">  if (f != NULL) {</a>
<a name="ln6397">    fprintf(f,</a>
<a name="ln6398">        &quot;\n\n\t=======================================================\n&quot;);</a>
<a name="ln6399">#ifdef REGEXP_DEBUG</a>
<a name="ln6400">    fprintf(f, &quot;\tRegexp is \&quot;%s\&quot;\n&quot;, nfa_regengine.expr);</a>
<a name="ln6401">#endif</a>
<a name="ln6402">    fprintf(f, &quot;\tInput text is \&quot;%s\&quot; \n&quot;, rex.input);</a>
<a name="ln6403">    fprintf(f, &quot;\t=======================================================\n\n&quot;);</a>
<a name="ln6404">    nfa_print_state(f, start);</a>
<a name="ln6405">    fprintf(f, &quot;\n\n&quot;);</a>
<a name="ln6406">    fclose(f);</a>
<a name="ln6407">  } else {</a>
<a name="ln6408">    EMSG(&quot;Could not open temporary log file for writing&quot;);</a>
<a name="ln6409">  }</a>
<a name="ln6410">#endif</a>
<a name="ln6411"> </a>
<a name="ln6412">  clear_sub(&amp;subs.norm);</a>
<a name="ln6413">  clear_sub(&amp;m.norm);</a>
<a name="ln6414">  clear_sub(&amp;subs.synt);</a>
<a name="ln6415">  clear_sub(&amp;m.synt);</a>
<a name="ln6416"> </a>
<a name="ln6417">  int result = nfa_regmatch(prog, start, &amp;subs, &amp;m);</a>
<a name="ln6418">  if (!result) {</a>
<a name="ln6419">    return 0;</a>
<a name="ln6420">  } else if (result == NFA_TOO_EXPENSIVE) {</a>
<a name="ln6421">    return result;</a>
<a name="ln6422">  }</a>
<a name="ln6423"> </a>
<a name="ln6424">  cleanup_subexpr();</a>
<a name="ln6425">  if (REG_MULTI) {</a>
<a name="ln6426">    for (i = 0; i &lt; subs.norm.in_use; i++) {</a>
<a name="ln6427">      rex.reg_startpos[i].lnum = subs.norm.list.multi[i].start_lnum;</a>
<a name="ln6428">      rex.reg_startpos[i].col = subs.norm.list.multi[i].start_col;</a>
<a name="ln6429"> </a>
<a name="ln6430">      rex.reg_endpos[i].lnum = subs.norm.list.multi[i].end_lnum;</a>
<a name="ln6431">      rex.reg_endpos[i].col = subs.norm.list.multi[i].end_col;</a>
<a name="ln6432">    }</a>
<a name="ln6433"> </a>
<a name="ln6434">    if (rex.reg_startpos[0].lnum &lt; 0) {</a>
<a name="ln6435">      rex.reg_startpos[0].lnum = 0;</a>
<a name="ln6436">      rex.reg_startpos[0].col = col;</a>
<a name="ln6437">    }</a>
<a name="ln6438">    if (rex.reg_endpos[0].lnum &lt; 0) {</a>
<a name="ln6439">      // pattern has a \ze but it didn't match, use current end</a>
<a name="ln6440">      rex.reg_endpos[0].lnum = rex.lnum;</a>
<a name="ln6441">      rex.reg_endpos[0].col = (int)(rex.input - rex.line);</a>
<a name="ln6442">    } else {</a>
<a name="ln6443">      // Use line number of &quot;\ze&quot;.</a>
<a name="ln6444">      rex.lnum = rex.reg_endpos[0].lnum;</a>
<a name="ln6445">    }</a>
<a name="ln6446">  } else {</a>
<a name="ln6447">    for (i = 0; i &lt; subs.norm.in_use; i++) {</a>
<a name="ln6448">      rex.reg_startp[i] = subs.norm.list.line[i].start;</a>
<a name="ln6449">      rex.reg_endp[i] = subs.norm.list.line[i].end;</a>
<a name="ln6450">    }</a>
<a name="ln6451"> </a>
<a name="ln6452">    if (rex.reg_startp[0] == NULL) {</a>
<a name="ln6453">      rex.reg_startp[0] = rex.line + col;</a>
<a name="ln6454">    }</a>
<a name="ln6455">    if (rex.reg_endp[0] == NULL) {</a>
<a name="ln6456">      rex.reg_endp[0] = rex.input;</a>
<a name="ln6457">    }</a>
<a name="ln6458">  }</a>
<a name="ln6459"> </a>
<a name="ln6460">  /* Package any found \z(...\) matches for export. Default is none. */</a>
<a name="ln6461">  unref_extmatch(re_extmatch_out);</a>
<a name="ln6462">  re_extmatch_out = NULL;</a>
<a name="ln6463"> </a>
<a name="ln6464">  if (prog-&gt;reghasz == REX_SET) {</a>
<a name="ln6465">    cleanup_zsubexpr();</a>
<a name="ln6466">    re_extmatch_out = make_extmatch();</a>
<a name="ln6467">    // Loop over \z1, \z2, etc.  There is no \z0.</a>
<a name="ln6468">    for (i = 1; i &lt; subs.synt.in_use; i++) {</a>
<a name="ln6469">      if (REG_MULTI) {</a>
<a name="ln6470">        struct multipos *mpos = &amp;subs.synt.list.multi[i];</a>
<a name="ln6471"> </a>
<a name="ln6472">        // Only accept single line matches that are valid.</a>
<a name="ln6473">        if (mpos-&gt;start_lnum &gt;= 0</a>
<a name="ln6474">            &amp;&amp; mpos-&gt;start_lnum == mpos-&gt;end_lnum</a>
<a name="ln6475">            &amp;&amp; mpos-&gt;end_col &gt;= mpos-&gt;start_col) {</a>
<a name="ln6476">          re_extmatch_out-&gt;matches[i] =</a>
<a name="ln6477">            vim_strnsave(reg_getline(mpos-&gt;start_lnum) + mpos-&gt;start_col,</a>
<a name="ln6478">                         mpos-&gt;end_col - mpos-&gt;start_col);</a>
<a name="ln6479">        }</a>
<a name="ln6480">      } else {</a>
<a name="ln6481">        struct linepos *lpos = &amp;subs.synt.list.line[i];</a>
<a name="ln6482"> </a>
<a name="ln6483">        if (lpos-&gt;start != NULL &amp;&amp; lpos-&gt;end != NULL)</a>
<a name="ln6484">          re_extmatch_out-&gt;matches[i] =</a>
<a name="ln6485">            vim_strnsave(lpos-&gt;start, lpos-&gt;end - lpos-&gt;start);</a>
<a name="ln6486">      }</a>
<a name="ln6487">    }</a>
<a name="ln6488">  }</a>
<a name="ln6489"> </a>
<a name="ln6490">  return 1 + rex.lnum;</a>
<a name="ln6491">}</a>
<a name="ln6492"> </a>
<a name="ln6493">/// Match a regexp against a string (&quot;line&quot; points to the string) or multiple</a>
<a name="ln6494">/// lines (&quot;line&quot; is NULL, use reg_getline()).</a>
<a name="ln6495">///</a>
<a name="ln6496">/// @param line String in which to search or NULL</a>
<a name="ln6497">/// @param startcol Column to start looking for match</a>
<a name="ln6498">/// @param tm Timeout limit or NULL</a>
<a name="ln6499">/// @param timed_out Flag set on timeout or NULL</a>
<a name="ln6500">///</a>
<a name="ln6501">/// @return &lt;= 0 if there is no match and number of lines contained in the</a>
<a name="ln6502">/// match otherwise.</a>
<a name="ln6503">static long nfa_regexec_both(char_u *line, colnr_T startcol,</a>
<a name="ln6504">                             proftime_T *tm, int *timed_out)</a>
<a name="ln6505">{</a>
<a name="ln6506">  nfa_regprog_T   *prog;</a>
<a name="ln6507">  long retval = 0L;</a>
<a name="ln6508">  colnr_T col = startcol;</a>
<a name="ln6509"> </a>
<a name="ln6510">  if (REG_MULTI) {</a>
<a name="ln6511">    prog = (nfa_regprog_T *)rex.reg_mmatch-&gt;regprog;</a>
<a name="ln6512">    line = reg_getline((linenr_T)0);  // relative to the cursor</a>
<a name="ln6513">    rex.reg_startpos = rex.reg_mmatch-&gt;startpos;</a>
<a name="ln6514">    rex.reg_endpos = rex.reg_mmatch-&gt;endpos;</a>
<a name="ln6515">  } else {</a>
<a name="ln6516">    prog = (nfa_regprog_T *)rex.reg_match-&gt;regprog;</a>
<a name="ln6517">    rex.reg_startp = rex.reg_match-&gt;startp;</a>
<a name="ln6518">    rex.reg_endp = rex.reg_match-&gt;endp;</a>
<a name="ln6519">  }</a>
<a name="ln6520"> </a>
<a name="ln6521">  /* Be paranoid... */</a>
<a name="ln6522">  if (prog == NULL || line == NULL) {</a>
<a name="ln6523">    IEMSG(_(e_null));</a>
<a name="ln6524">    goto theend;</a>
<a name="ln6525">  }</a>
<a name="ln6526"> </a>
<a name="ln6527">  // If pattern contains &quot;\c&quot; or &quot;\C&quot;: overrule value of rex.reg_ic</a>
<a name="ln6528">  if (prog-&gt;regflags &amp; RF_ICASE) {</a>
<a name="ln6529">    rex.reg_ic = true;</a>
<a name="ln6530">  } else if (prog-&gt;regflags &amp; RF_NOICASE) {</a>
<a name="ln6531">    rex.reg_ic = false;</a>
<a name="ln6532">  }</a>
<a name="ln6533"> </a>
<a name="ln6534">  // If pattern contains &quot;\Z&quot; overrule value of rex.reg_icombine</a>
<a name="ln6535">  if (prog-&gt;regflags &amp; RF_ICOMBINE) {</a>
<a name="ln6536">    rex.reg_icombine = true;</a>
<a name="ln6537">  }</a>
<a name="ln6538"> </a>
<a name="ln6539">  rex.line = line;</a>
<a name="ln6540">  rex.lnum = 0;  // relative to line</a>
<a name="ln6541"> </a>
<a name="ln6542">  rex.nfa_has_zend = prog-&gt;has_zend;</a>
<a name="ln6543">  rex.nfa_has_backref = prog-&gt;has_backref;</a>
<a name="ln6544">  rex.nfa_nsubexpr = prog-&gt;nsubexp;</a>
<a name="ln6545">  rex.nfa_listid = 1;</a>
<a name="ln6546">  rex.nfa_alt_listid = 2;</a>
<a name="ln6547">#ifdef REGEXP_DEBUG</a>
<a name="ln6548">  nfa_regengine.expr = prog-&gt;pattern;</a>
<a name="ln6549">#endif</a>
<a name="ln6550"> </a>
<a name="ln6551">  if (prog-&gt;reganch &amp;&amp; col &gt; 0)</a>
<a name="ln6552">    return 0L;</a>
<a name="ln6553"> </a>
<a name="ln6554">  rex.need_clear_subexpr = true;</a>
<a name="ln6555">  // Clear the external match subpointers if necessary.</a>
<a name="ln6556">  if (prog-&gt;reghasz == REX_SET) {</a>
<a name="ln6557">    rex.nfa_has_zsubexpr = true;</a>
<a name="ln6558">    rex.need_clear_zsubexpr = true;</a>
<a name="ln6559">  } else {</a>
<a name="ln6560">    rex.nfa_has_zsubexpr = false;</a>
<a name="ln6561">    rex.need_clear_zsubexpr = false;</a>
<a name="ln6562">  }</a>
<a name="ln6563"> </a>
<a name="ln6564">  if (prog-&gt;regstart != NUL) {</a>
<a name="ln6565">    /* Skip ahead until a character we know the match must start with.</a>
<a name="ln6566">     * When there is none there is no match. */</a>
<a name="ln6567">    if (skip_to_start(prog-&gt;regstart, &amp;col) == FAIL)</a>
<a name="ln6568">      return 0L;</a>
<a name="ln6569"> </a>
<a name="ln6570">    // If match_text is set it contains the full text that must match.</a>
<a name="ln6571">    // Nothing else to try. Doesn't handle combining chars well.</a>
<a name="ln6572">    if (prog-&gt;match_text != NULL &amp;&amp; !rex.reg_icombine) {</a>
<a name="ln6573">      return find_match_text(col, prog-&gt;regstart, prog-&gt;match_text);</a>
<a name="ln6574">    }</a>
<a name="ln6575">  }</a>
<a name="ln6576"> </a>
<a name="ln6577">  // If the start column is past the maximum column: no need to try.</a>
<a name="ln6578">  if (rex.reg_maxcol &gt; 0 &amp;&amp; col &gt;= rex.reg_maxcol) {</a>
<a name="ln6579">    goto theend;</a>
<a name="ln6580">  }</a>
<a name="ln6581"> </a>
<a name="ln6582">  // Set the &quot;nstate&quot; used by nfa_regcomp() to zero to trigger an error when</a>
<a name="ln6583">  // it's accidentally used during execution.</a>
<a name="ln6584">  nstate = 0;</a>
<a name="ln6585">  for (int i = 0; i &lt; prog-&gt;nstate; i++) {</a>
<a name="ln6586">    prog-&gt;state[i].id = i;</a>
<a name="ln6587">    prog-&gt;state[i].lastlist[0] = 0;</a>
<a name="ln6588">    prog-&gt;state[i].lastlist[1] = 0;</a>
<a name="ln6589">  }</a>
<a name="ln6590"> </a>
<a name="ln6591">  retval = nfa_regtry(prog, col, tm, timed_out);</a>
<a name="ln6592"> </a>
<a name="ln6593">#ifdef REGEXP_DEBUG</a>
<a name="ln6594">  nfa_regengine.expr = NULL;</a>
<a name="ln6595">#endif</a>
<a name="ln6596"> </a>
<a name="ln6597">theend:</a>
<a name="ln6598">  if (retval &gt; 0) {</a>
<a name="ln6599">    // Make sure the end is never before the start.  Can happen when \zs and</a>
<a name="ln6600">    // \ze are used.</a>
<a name="ln6601">    if (REG_MULTI) {</a>
<a name="ln6602">      const lpos_T *const start = &amp;rex.reg_mmatch-&gt;startpos[0];</a>
<a name="ln6603">      const lpos_T *const end = &amp;rex.reg_mmatch-&gt;endpos[0];</a>
<a name="ln6604"> </a>
<a name="ln6605">      if (end-&gt;lnum &lt; start-&gt;lnum</a>
<a name="ln6606">          || (end-&gt;lnum == start-&gt;lnum &amp;&amp; end-&gt;col &lt; start-&gt;col)) {</a>
<a name="ln6607">        rex.reg_mmatch-&gt;endpos[0] = rex.reg_mmatch-&gt;startpos[0];</a>
<a name="ln6608">      }</a>
<a name="ln6609">    } else {</a>
<a name="ln6610">      if (rex.reg_match-&gt;endp[0] &lt; rex.reg_match-&gt;startp[0]) {</a>
<a name="ln6611">        rex.reg_match-&gt;endp[0] = rex.reg_match-&gt;startp[0];</a>
<a name="ln6612">      }</a>
<a name="ln6613">    }</a>
<a name="ln6614">  }</a>
<a name="ln6615"> </a>
<a name="ln6616">  return retval;</a>
<a name="ln6617">}</a>
<a name="ln6618"> </a>
<a name="ln6619">/*</a>
<a name="ln6620"> * Compile a regular expression into internal code for the NFA matcher.</a>
<a name="ln6621"> * Returns the program in allocated space.  Returns NULL for an error.</a>
<a name="ln6622"> */</a>
<a name="ln6623">static regprog_T *nfa_regcomp(char_u *expr, int re_flags)</a>
<a name="ln6624">{</a>
<a name="ln6625">  nfa_regprog_T       *prog = NULL;</a>
<a name="ln6626">  int                 *postfix;</a>
<a name="ln6627"> </a>
<a name="ln6628">  if (expr == NULL)</a>
<a name="ln6629">    return NULL;</a>
<a name="ln6630"> </a>
<a name="ln6631">#ifdef REGEXP_DEBUG</a>
<a name="ln6632">  nfa_regengine.expr = expr;</a>
<a name="ln6633">#endif</a>
<a name="ln6634">  nfa_re_flags = re_flags;</a>
<a name="ln6635"> </a>
<a name="ln6636">  init_class_tab();</a>
<a name="ln6637"> </a>
<a name="ln6638">  nfa_regcomp_start(expr, re_flags);</a>
<a name="ln6639"> </a>
<a name="ln6640">  // Build postfix form of the regexp. Needed to build the NFA</a>
<a name="ln6641">  // (and count its size).</a>
<a name="ln6642">  postfix = re2post();</a>
<a name="ln6643">  if (postfix == NULL) {</a>
<a name="ln6644">    goto fail;              // Cascaded (syntax?) error</a>
<a name="ln6645">  }</a>
<a name="ln6646"> </a>
<a name="ln6647">  /*</a>
<a name="ln6648">   * In order to build the NFA, we parse the input regexp twice:</a>
<a name="ln6649">   * 1. first pass to count size (so we can allocate space)</a>
<a name="ln6650">   * 2. second to emit code</a>
<a name="ln6651">   */</a>
<a name="ln6652">#ifdef REGEXP_DEBUG</a>
<a name="ln6653">  {</a>
<a name="ln6654">    FILE *f = fopen(NFA_REGEXP_RUN_LOG, &quot;a&quot;);</a>
<a name="ln6655"> </a>
<a name="ln6656">    if (f != NULL) {</a>
<a name="ln6657">      fprintf(f,</a>
<a name="ln6658">              &quot;\n*****************************\n\n\n\n\t&quot;</a>
<a name="ln6659">              &quot;Compiling regexp \&quot;%s\&quot;... hold on !\n&quot;,</a>
<a name="ln6660">              expr);</a>
<a name="ln6661">      fclose(f);</a>
<a name="ln6662">    }</a>
<a name="ln6663">  }</a>
<a name="ln6664">#endif</a>
<a name="ln6665"> </a>
<a name="ln6666">  /*</a>
<a name="ln6667">   * PASS 1</a>
<a name="ln6668">   * Count number of NFA states in &quot;nstate&quot;. Do not build the NFA.</a>
<a name="ln6669">   */</a>
<a name="ln6670">  post2nfa(postfix, post_ptr, true);</a>
<a name="ln6671"> </a>
<a name="ln6672">  /* allocate the regprog with space for the compiled regexp */</a>
<a name="ln6673">  size_t prog_size = sizeof(nfa_regprog_T) + sizeof(nfa_state_T) * (nstate - 1);</a>
<a name="ln6674">  prog = xmalloc(prog_size);</a>
<a name="ln6675">  state_ptr = prog-&gt;state;</a>
<a name="ln6676">  prog-&gt;re_in_use = false;</a>
<a name="ln6677"> </a>
<a name="ln6678">  /*</a>
<a name="ln6679">   * PASS 2</a>
<a name="ln6680">   * Build the NFA</a>
<a name="ln6681">   */</a>
<a name="ln6682">  prog-&gt;start = post2nfa(postfix, post_ptr, false);</a>
<a name="ln6683">  if (prog-&gt;start == NULL) {</a>
<a name="ln6684">    goto fail;</a>
<a name="ln6685">  }</a>
<a name="ln6686">  prog-&gt;regflags = regflags;</a>
<a name="ln6687">  prog-&gt;engine = &amp;nfa_regengine;</a>
<a name="ln6688">  prog-&gt;nstate = nstate;</a>
<a name="ln6689">  prog-&gt;has_zend = rex.nfa_has_zend;</a>
<a name="ln6690">  prog-&gt;has_backref = rex.nfa_has_backref;</a>
<a name="ln6691">  prog-&gt;nsubexp = regnpar;</a>
<a name="ln6692"> </a>
<a name="ln6693">  nfa_postprocess(prog);</a>
<a name="ln6694"> </a>
<a name="ln6695">  prog-&gt;reganch = nfa_get_reganch(prog-&gt;start, 0);</a>
<a name="ln6696">  prog-&gt;regstart = nfa_get_regstart(prog-&gt;start, 0);</a>
<a name="ln6697">  prog-&gt;match_text = nfa_get_match_text(prog-&gt;start);</a>
<a name="ln6698"> </a>
<a name="ln6699">#ifdef REGEXP_DEBUG</a>
<a name="ln6700">  nfa_postfix_dump(expr, OK);</a>
<a name="ln6701">  nfa_dump(prog);</a>
<a name="ln6702">#endif</a>
<a name="ln6703">  /* Remember whether this pattern has any \z specials in it. */</a>
<a name="ln6704">  prog-&gt;reghasz = re_has_z;</a>
<a name="ln6705">  prog-&gt;pattern = vim_strsave(expr);</a>
<a name="ln6706">#ifdef REGEXP_DEBUG</a>
<a name="ln6707">  nfa_regengine.expr = NULL;</a>
<a name="ln6708">#endif</a>
<a name="ln6709"> </a>
<a name="ln6710">out:</a>
<a name="ln6711">  xfree(post_start);</a>
<a name="ln6712">  post_start = post_ptr = post_end = NULL;</a>
<a name="ln6713">  state_ptr = NULL;</a>
<a name="ln6714">  return (regprog_T *)prog;</a>
<a name="ln6715"> </a>
<a name="ln6716">fail:</a>
<a name="ln6717">  XFREE_CLEAR(prog);</a>
<a name="ln6718">#ifdef REGEXP_DEBUG</a>
<a name="ln6719">  nfa_postfix_dump(expr, FAIL);</a>
<a name="ln6720">  nfa_regengine.expr = NULL;</a>
<a name="ln6721">#endif</a>
<a name="ln6722">  goto out;</a>
<a name="ln6723">}</a>
<a name="ln6724"> </a>
<a name="ln6725">/*</a>
<a name="ln6726"> * Free a compiled regexp program, returned by nfa_regcomp().</a>
<a name="ln6727"> */</a>
<a name="ln6728">static void nfa_regfree(regprog_T *prog)</a>
<a name="ln6729">{</a>
<a name="ln6730">  if (prog != NULL) {</a>
<a name="ln6731">    xfree(((nfa_regprog_T *)prog)-&gt;match_text);</a>
<a name="ln6732">    xfree(((nfa_regprog_T *)prog)-&gt;pattern);</a>
<a name="ln6733">    xfree(prog);</a>
<a name="ln6734">  }</a>
<a name="ln6735">}</a>
<a name="ln6736"> </a>
<a name="ln6737">/*</a>
<a name="ln6738"> * Match a regexp against a string.</a>
<a name="ln6739"> * &quot;rmp-&gt;regprog&quot; is a compiled regexp as returned by nfa_regcomp().</a>
<a name="ln6740"> * Uses curbuf for line count and 'iskeyword'.</a>
<a name="ln6741"> * If &quot;line_lbr&quot; is true, consider a &quot;\n&quot; in &quot;line&quot; to be a line break.</a>
<a name="ln6742"> *</a>
<a name="ln6743"> * Returns &lt;= 0 for failure, number of lines contained in the match otherwise.</a>
<a name="ln6744"> */</a>
<a name="ln6745">static int </a>
<a name="ln6746">nfa_regexec_nl (</a>
<a name="ln6747">    regmatch_T *rmp,</a>
<a name="ln6748">    char_u *line,      /* string to match against */</a>
<a name="ln6749">    colnr_T col,       /* column to start looking for match */</a>
<a name="ln6750">    bool line_lbr</a>
<a name="ln6751">)</a>
<a name="ln6752">{</a>
<a name="ln6753">  rex.reg_match = rmp;</a>
<a name="ln6754">  rex.reg_mmatch = NULL;</a>
<a name="ln6755">  rex.reg_maxline = 0;</a>
<a name="ln6756">  rex.reg_line_lbr = line_lbr;</a>
<a name="ln6757">  rex.reg_buf = curbuf;</a>
<a name="ln6758">  rex.reg_win = NULL;</a>
<a name="ln6759">  rex.reg_ic = rmp-&gt;rm_ic;</a>
<a name="ln6760">  rex.reg_icombine = false;</a>
<a name="ln6761">  rex.reg_maxcol = 0;</a>
<a name="ln6762">  return nfa_regexec_both(line, col, NULL, NULL);</a>
<a name="ln6763">}</a>
<a name="ln6764"> </a>
<a name="ln6765">/// Matches a regexp against multiple lines.</a>
<a name="ln6766">/// &quot;rmp-&gt;regprog&quot; is a compiled regexp as returned by vim_regcomp().</a>
<a name="ln6767">/// Uses curbuf for line count and 'iskeyword'.</a>
<a name="ln6768">///</a>
<a name="ln6769">/// @param win Window in which to search or NULL</a>
<a name="ln6770">/// @param buf Buffer in which to search</a>
<a name="ln6771">/// @param lnum Number of line to start looking for match</a>
<a name="ln6772">/// @param col Column to start looking for match</a>
<a name="ln6773">/// @param tm Timeout limit or NULL</a>
<a name="ln6774">/// @param timed_out Flag set on timeout or NULL</a>
<a name="ln6775">///</a>
<a name="ln6776">/// @return &lt;= 0 if there is no match and number of lines contained in the match</a>
<a name="ln6777">/// otherwise.</a>
<a name="ln6778">///</a>
<a name="ln6779">/// @note The body is the same as bt_regexec() except for nfa_regexec_both()</a>
<a name="ln6780">///</a>
<a name="ln6781">/// @warning</a>
<a name="ln6782">/// Match may actually be in another line. e.g.:</a>
<a name="ln6783">/// when r.e. is \nc, cursor is at 'a' and the text buffer looks like</a>
<a name="ln6784">///</a>
<a name="ln6785">/// @par</a>
<a name="ln6786">///</a>
<a name="ln6787">///     +-------------------------+</a>
<a name="ln6788">///     |a                        |</a>
<a name="ln6789">///     |b                        |</a>
<a name="ln6790">///     |c                        |</a>
<a name="ln6791">///     |                         |</a>
<a name="ln6792">///     +-------------------------+</a>
<a name="ln6793">///</a>
<a name="ln6794">/// @par</a>
<a name="ln6795">/// then nfa_regexec_multi() returns 3. while the original vim_regexec_multi()</a>
<a name="ln6796">/// returns 0 and a second call at line 2 will return 2.</a>
<a name="ln6797">///</a>
<a name="ln6798">/// @par</a>
<a name="ln6799">/// FIXME if this behavior is not compatible.</a>
<a name="ln6800">static long nfa_regexec_multi(regmmatch_T *rmp, win_T *win, buf_T *buf,</a>
<a name="ln6801">                              linenr_T lnum, colnr_T col,</a>
<a name="ln6802">                              proftime_T *tm, int *timed_out)</a>
<a name="ln6803">{</a>
<a name="ln6804">  rex.reg_match = NULL;</a>
<a name="ln6805">  rex.reg_mmatch = rmp;</a>
<a name="ln6806">  rex.reg_buf = buf;</a>
<a name="ln6807">  rex.reg_win = win;</a>
<a name="ln6808">  rex.reg_firstlnum = lnum;</a>
<a name="ln6809">  rex.reg_maxline = rex.reg_buf-&gt;b_ml.ml_line_count - lnum;</a>
<a name="ln6810">  rex.reg_line_lbr = false;</a>
<a name="ln6811">  rex.reg_ic = rmp-&gt;rmm_ic;</a>
<a name="ln6812">  rex.reg_icombine = false;</a>
<a name="ln6813">  rex.reg_maxcol = rmp-&gt;rmm_maxcol;</a>
<a name="ln6814"> </a>
<a name="ln6815">  return nfa_regexec_both(NULL, col, tm, timed_out);</a>
<a name="ln6816">}</a>

</code></pre>
<div class="balloon" rel="6170"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'pim->result' should be checked here.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
