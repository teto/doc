
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>typval_encode.c.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/// @file eval/typval_encode.c.h</a>
<a name="ln2">///</a>
<a name="ln3">/// Contains set of macros used to convert (possibly recursive) typval_T into</a>
<a name="ln4">/// something else. For these macros to work the following macros must be</a>
<a name="ln5">/// defined:</a>
<a name="ln6"> </a>
<a name="ln7">/// @def TYPVAL_ENCODE_CONV_NIL</a>
<a name="ln8">/// @brief Macros used to convert NIL value</a>
<a name="ln9">///</a>
<a name="ln10">/// Is called both for special dictionary (unless #TYPVAL_ENCODE_ALLOW_SPECIALS</a>
<a name="ln11">/// is false) and `v:null`.</a>
<a name="ln12">///</a>
<a name="ln13">/// @param  tv  Pointer to typval where value is stored. May not be NULL. May</a>
<a name="ln14">///             point to special dictionary.</a>
<a name="ln15"> </a>
<a name="ln16">/// @def TYPVAL_ENCODE_CONV_BOOL</a>
<a name="ln17">/// @brief Macros used to convert boolean value</a>
<a name="ln18">///</a>
<a name="ln19">/// Is called both for special dictionary (unless #TYPVAL_ENCODE_ALLOW_SPECIALS</a>
<a name="ln20">/// is false) and `v:true`/`v:false`.</a>
<a name="ln21">///</a>
<a name="ln22">/// @param  tv  Pointer to typval where value is stored. May not be NULL. May</a>
<a name="ln23">///             point to a special dictionary.</a>
<a name="ln24">/// @param  num  Boolean value to convert. Value is an expression which</a>
<a name="ln25">///              evaluates to some integer.</a>
<a name="ln26"> </a>
<a name="ln27">/// @def TYPVAL_ENCODE_CONV_NUMBER</a>
<a name="ln28">/// @brief Macros used to convert integer</a>
<a name="ln29">///</a>
<a name="ln30">/// @param  tv  Pointer to typval where value is stored. May not be NULL. May</a>
<a name="ln31">///             point to a special dictionary.</a>
<a name="ln32">/// @param  num  Integer to convert, must accept both varnumber_T and int64_t.</a>
<a name="ln33"> </a>
<a name="ln34">/// @def TYPVAL_ENCODE_CONV_UNSIGNED_NUMBER</a>
<a name="ln35">/// @brief Macros used to convert unsigned integer</a>
<a name="ln36">///</a>
<a name="ln37">/// Not used if #TYPVAL_ENCODE_ALLOW_SPECIALS is false, but still must be</a>
<a name="ln38">/// defined.</a>
<a name="ln39">///</a>
<a name="ln40">/// @param  tv  Pointer to typval where value is stored. May not be NULL. Points</a>
<a name="ln41">///             to a special dictionary.</a>
<a name="ln42">/// @param  num  Integer to convert, must accept uint64_t.</a>
<a name="ln43"> </a>
<a name="ln44">/// @def TYPVAL_ENCODE_CONV_FLOAT</a>
<a name="ln45">/// @brief Macros used to convert floating-point number</a>
<a name="ln46">///</a>
<a name="ln47">/// @param  tv  Pointer to typval where value is stored. May not be NULL. May</a>
<a name="ln48">///             point to a special dictionary.</a>
<a name="ln49">/// @param  flt  Number to convert, must accept float_T.</a>
<a name="ln50"> </a>
<a name="ln51">/// @def TYPVAL_ENCODE_CONV_STRING</a>
<a name="ln52">/// @brief Macros used to convert plain string</a>
<a name="ln53">///</a>
<a name="ln54">/// Is used to convert VAR_STRING objects as well as BIN strings represented as</a>
<a name="ln55">/// special dictionary.</a>
<a name="ln56">///</a>
<a name="ln57">/// @param  tv  Pointer to typval where value is stored. May not be NULL. May</a>
<a name="ln58">///             point to a special dictionary.</a>
<a name="ln59">/// @param  buf  String to convert. Is a char[] buffer, not NUL-terminated.</a>
<a name="ln60">/// @param  len  String length.</a>
<a name="ln61"> </a>
<a name="ln62">/// @def TYPVAL_ENCODE_CONV_STR_STRING</a>
<a name="ln63">/// @brief Like #TYPVAL_ENCODE_CONV_STRING, but for STR strings</a>
<a name="ln64">///</a>
<a name="ln65">/// Is used to convert dictionary keys and STR strings represented as special</a>
<a name="ln66">/// dictionaries.</a>
<a name="ln67">///</a>
<a name="ln68">/// @param  tv  Pointer to typval where value is stored. May be NULL. May</a>
<a name="ln69">///             point to a special dictionary.</a>
<a name="ln70">/// @param  buf  String to convert. Is a char[] buffer, not NUL-terminated.</a>
<a name="ln71">/// @param  len  String length.</a>
<a name="ln72"> </a>
<a name="ln73">/// @def TYPVAL_ENCODE_CONV_EXT_STRING</a>
<a name="ln74">/// @brief Macros used to convert EXT string</a>
<a name="ln75">///</a>
<a name="ln76">/// Is used to convert EXT strings represented as special dictionaries. Never</a>
<a name="ln77">/// actually used if #TYPVAL_ENCODE_ALLOW_SPECIALS is false, but still must be</a>
<a name="ln78">/// defined.</a>
<a name="ln79">///</a>
<a name="ln80">/// @param  tv  Pointer to typval where value is stored. May not be NULL. Points</a>
<a name="ln81">///             to a special dictionary.</a>
<a name="ln82">/// @param  buf  String to convert. Is a char[] buffer, not NUL-terminated.</a>
<a name="ln83">/// @param  len  String length.</a>
<a name="ln84">/// @param  type  EXT type.</a>
<a name="ln85"> </a>
<a name="ln86">/// @def TYPVAL_ENCODE_CONV_FUNC_START</a>
<a name="ln87">/// @brief Macros used when starting to convert a funcref or a partial</a>
<a name="ln88">///</a>
<a name="ln89">/// @param  tv  Pointer to typval where value is stored. May not be NULL.</a>
<a name="ln90">/// @param  fun  Function name. May be NULL.</a>
<a name="ln91"> </a>
<a name="ln92">/// @def TYPVAL_ENCODE_CONV_FUNC_BEFORE_ARGS</a>
<a name="ln93">/// @brief Macros used before starting to convert partial arguments</a>
<a name="ln94">///</a>
<a name="ln95">/// @param  tv  Pointer to typval where value is stored. May not be NULL.</a>
<a name="ln96">/// @param  len  Number of arguments. Zero for absent arguments or when</a>
<a name="ln97">///              converting a funcref.</a>
<a name="ln98"> </a>
<a name="ln99">/// @def TYPVAL_ENCODE_CONV_FUNC_BEFORE_SELF</a>
<a name="ln100">/// @brief Macros used before starting to convert self dictionary</a>
<a name="ln101">///</a>
<a name="ln102">/// @param  tv  Pointer to typval where value is stored. May not be NULL.</a>
<a name="ln103">/// @param  len  Number of arguments. May be zero for empty dictionary or -1 for</a>
<a name="ln104">///              missing self dictionary, also when converting function</a>
<a name="ln105">///              reference.</a>
<a name="ln106"> </a>
<a name="ln107">/// @def TYPVAL_ENCODE_CONV_FUNC_END</a>
<a name="ln108">/// @brief Macros used after converting a funcref or a partial</a>
<a name="ln109">///</a>
<a name="ln110">/// @param  tv  Pointer to typval where value is stored. May not be NULL.</a>
<a name="ln111"> </a>
<a name="ln112">/// @def TYPVAL_ENCODE_CONV_EMPTY_LIST</a>
<a name="ln113">/// @brief Macros used to convert an empty list</a>
<a name="ln114">///</a>
<a name="ln115">/// @param  tv  Pointer to typval where value is stored. May not be NULL.</a>
<a name="ln116"> </a>
<a name="ln117">/// @def TYPVAL_ENCODE_CONV_EMPTY_DICT</a>
<a name="ln118">/// @brief Macros used to convert an empty dictionary</a>
<a name="ln119">///</a>
<a name="ln120">/// @param  tv  Pointer to typval where value is stored. May be NULL. May</a>
<a name="ln121">///             point to a special dictionary.</a>
<a name="ln122">/// @param  dict  Converted dictionary, lvalue or #TYPVAL_ENCODE_NODICT_VAR</a>
<a name="ln123">///               (for dictionaries represented as special lists).</a>
<a name="ln124"> </a>
<a name="ln125">/// @def TYPVAL_ENCODE_CONV_LIST_START</a>
<a name="ln126">/// @brief Macros used before starting to convert non-empty list</a>
<a name="ln127">///</a>
<a name="ln128">/// @param  tv  Pointer to typval where value is stored. May be NULL. May</a>
<a name="ln129">///             point to a special dictionary.</a>
<a name="ln130">/// @param  len  List length. Is an expression which evaluates to an integer.</a>
<a name="ln131"> </a>
<a name="ln132">/// @def TYPVAL_ENCODE_CONV_REAL_LIST_AFTER_START</a>
<a name="ln133">/// @brief Macros used after pushing list onto the stack</a>
<a name="ln134">///</a>
<a name="ln135">/// Only used for real list_T* lists, not for special dictionaries or partial</a>
<a name="ln136">/// arguments.</a>
<a name="ln137">///</a>
<a name="ln138">/// @param  tv  Pointer to typval where value is stored. May be NULL. May</a>
<a name="ln139">///             point to a special dictionary.</a>
<a name="ln140">/// @param  mpsv  Pushed MPConvStackVal value.</a>
<a name="ln141"> </a>
<a name="ln142">/// @def TYPVAL_ENCODE_CONV_LIST_BETWEEN_ITEMS</a>
<a name="ln143">/// @brief Macros used after finishing converting non-last list item</a>
<a name="ln144">///</a>
<a name="ln145">/// @param  tv  Pointer to typval where list is stored. May be NULL.</a>
<a name="ln146"> </a>
<a name="ln147">/// @def TYPVAL_ENCODE_CONV_LIST_END</a>
<a name="ln148">/// @brief Macros used after converting non-empty list</a>
<a name="ln149">///</a>
<a name="ln150">/// @param  tv  Pointer to typval where list is stored. May be NULL.</a>
<a name="ln151"> </a>
<a name="ln152">/// @def TYPVAL_ENCODE_CONV_DICT_START</a>
<a name="ln153">/// @brief Macros used before starting to convert non-empty dictionary</a>
<a name="ln154">///</a>
<a name="ln155">/// Only used for real dict_T* dictionaries, not for special dictionaries. Also</a>
<a name="ln156">/// used for partial self dictionary.</a>
<a name="ln157">///</a>
<a name="ln158">/// @param  tv  Pointer to typval where dictionary is stored. May be NULL. May</a>
<a name="ln159">///             point to a special dictionary.</a>
<a name="ln160">/// @param  dict  Converted dictionary, lvalue or #TYPVAL_ENCODE_NODICT_VAR</a>
<a name="ln161">///               (for dictionaries represented as special lists).</a>
<a name="ln162">/// @param  len  Dictionary length. Is an expression which evaluates to an</a>
<a name="ln163">///              integer.</a>
<a name="ln164"> </a>
<a name="ln165">/// @def TYPVAL_ENCODE_CONV_REAL_DICT_AFTER_START</a>
<a name="ln166">/// @brief Macros used after pushing dictionary onto the stack</a>
<a name="ln167">///</a>
<a name="ln168">/// @param  tv  Pointer to typval where dictionary is stored. May be NULL.</a>
<a name="ln169">///             May not point to a special dictionary.</a>
<a name="ln170">/// @param  dict  Converted dictionary, lvalue.</a>
<a name="ln171">/// @param  mpsv  Pushed MPConvStackVal value.</a>
<a name="ln172"> </a>
<a name="ln173">/// @def TYPVAL_ENCODE_SPECIAL_DICT_KEY_CHECK</a>
<a name="ln174">/// @brief Macros used to check special dictionary key</a>
<a name="ln175">///</a>
<a name="ln176">/// @param  label  Label for goto in case check was not successful.</a>
<a name="ln177">/// @param  key  typval_T key to check.</a>
<a name="ln178"> </a>
<a name="ln179">/// @def TYPVAL_ENCODE_CONV_DICT_AFTER_KEY</a>
<a name="ln180">/// @brief Macros used after finishing converting dictionary key</a>
<a name="ln181">///</a>
<a name="ln182">/// @param  tv  Pointer to typval where dictionary is stored. May be NULL. May</a>
<a name="ln183">///             point to a special dictionary.</a>
<a name="ln184">/// @param  dict  Converted dictionary, lvalue or #TYPVAL_ENCODE_NODICT_VAR</a>
<a name="ln185">///               (for dictionaries represented as special lists).</a>
<a name="ln186"> </a>
<a name="ln187">/// @def TYPVAL_ENCODE_CONV_DICT_BETWEEN_ITEMS</a>
<a name="ln188">/// @brief Macros used after finishing converting non-last dictionary value</a>
<a name="ln189">///</a>
<a name="ln190">/// @param  tv  Pointer to typval where dictionary is stored. May be NULL. May</a>
<a name="ln191">///             point to a special dictionary.</a>
<a name="ln192">/// @param  dict  Converted dictionary, lvalue or #TYPVAL_ENCODE_NODICT_VAR</a>
<a name="ln193">///               (for dictionaries represented as special lists).</a>
<a name="ln194"> </a>
<a name="ln195">/// @def TYPVAL_ENCODE_CONV_DICT_END</a>
<a name="ln196">/// @brief Macros used after converting non-empty dictionary</a>
<a name="ln197">///</a>
<a name="ln198">/// @param  tv  Pointer to typval where dictionary is stored. May be NULL. May</a>
<a name="ln199">///             point to a special dictionary.</a>
<a name="ln200">/// @param  dict  Converted dictionary, lvalue or #TYPVAL_ENCODE_NODICT_VAR</a>
<a name="ln201">///               (for dictionaries represented as special lists).</a>
<a name="ln202"> </a>
<a name="ln203">/// @def TYPVAL_ENCODE_CONV_RECURSE</a>
<a name="ln204">/// @brief Macros used when self-containing container is detected</a>
<a name="ln205">///</a>
<a name="ln206">/// @param  val  Container for which this situation was detected.</a>
<a name="ln207">/// @param  conv_type  Type of the stack entry, @see MPConvStackValType.</a>
<a name="ln208"> </a>
<a name="ln209">/// @def TYPVAL_ENCODE_ALLOW_SPECIALS</a>
<a name="ln210">/// @brief Macros that specifies whether special dictionaries are special</a>
<a name="ln211">///</a>
<a name="ln212">/// Must be something that evaluates to boolean, most likely `true` or `false`.</a>
<a name="ln213">/// If it is false then special dictionaries are not treated specially.</a>
<a name="ln214"> </a>
<a name="ln215">/// @def TYPVAL_ENCODE_SCOPE</a>
<a name="ln216">/// @brief Scope of the main function: either nothing or `static`</a>
<a name="ln217"> </a>
<a name="ln218">/// @def TYPVAL_ENCODE_NAME</a>
<a name="ln219">/// @brief Name of the target converter</a>
<a name="ln220">///</a>
<a name="ln221">/// After including this file it will define function</a>
<a name="ln222">/// `encode_vim_to_{TYPVAL_ENCODE_NAME}` with scope #TYPVAL_ENCODE_SCOPE and</a>
<a name="ln223">/// static functions `_typval_encode_{TYPVAL_ENCODE_NAME}_convert_one_value` and</a>
<a name="ln224">/// `_typval_encode_{TYPVAL_ENCODE_NAME}_check_self_reference`.</a>
<a name="ln225"> </a>
<a name="ln226">/// @def TYPVAL_ENCODE_FIRST_ARG_TYPE</a>
<a name="ln227">/// @brief Type of the first argument, which will be used to return the results</a>
<a name="ln228">///</a>
<a name="ln229">/// Is expected to be a pointer type.</a>
<a name="ln230"> </a>
<a name="ln231">/// @def TYPVAL_ENCODE_FIRST_ARG_NAME</a>
<a name="ln232">/// @brief Name of the first argument</a>
<a name="ln233">///</a>
<a name="ln234">/// This name will only be used by one of the above macros which are defined by</a>
<a name="ln235">/// the caller. Functions defined here do not use first argument directly.</a>
<a name="ln236">#include &lt;stddef.h&gt;</a>
<a name="ln237">#include &lt;inttypes.h&gt;</a>
<a name="ln238">#include &lt;assert.h&gt;</a>
<a name="ln239"> </a>
<a name="ln240">#include &quot;nvim/lib/kvec.h&quot;</a>
<a name="ln241">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln242">#include &quot;nvim/eval/encode.h&quot;</a>
<a name="ln243">#include &quot;nvim/func_attr.h&quot;</a>
<a name="ln244">#include &quot;nvim/eval/typval_encode.h&quot;</a>
<a name="ln245"> </a>
<a name="ln246">/// Dummy variable used because some macros need lvalue</a>
<a name="ln247">///</a>
<a name="ln248">/// Must not be written to, if needed one must check that address of the</a>
<a name="ln249">/// macros argument is (not) equal to `&amp;TYPVAL_ENCODE_NODICT_VAR`.</a>
<a name="ln250">const dict_T *const TYPVAL_ENCODE_NODICT_VAR = NULL;</a>
<a name="ln251"> </a>
<a name="ln252">static inline int _TYPVAL_ENCODE_CHECK_SELF_REFERENCE(</a>
<a name="ln253">    TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME,</a>
<a name="ln254">    void *const val, int *const val_copyID,</a>
<a name="ln255">    const MPConvStack *const mpstack, const int copyID,</a>
<a name="ln256">    const MPConvStackValType conv_type,</a>
<a name="ln257">    const char *const objname)</a>
<a name="ln258">  REAL_FATTR_NONNULL_ARG(2, 3, 4, 7) REAL_FATTR_WARN_UNUSED_RESULT</a>
<a name="ln259">  REAL_FATTR_ALWAYS_INLINE;</a>
<a name="ln260"> </a>
<a name="ln261">/// Function for checking whether container references itself</a>
<a name="ln262">///</a>
<a name="ln263">/// @param  TYPVAL_ENCODE_FIRST_ARG_NAME  First argument.</a>
<a name="ln264">/// @param[in,out]  val  Container to check.</a>
<a name="ln265">/// @param  val_copyID  Pointer to the container attribute that holds copyID.</a>
<a name="ln266">///                     After checking whether value of this attribute is</a>
<a name="ln267">///                     copyID (variable) it is set to copyID.</a>
<a name="ln268">/// @param[in]  mpstack  Stack with values to convert. Read-only, used for error</a>
<a name="ln269">///                      reporting.</a>
<a name="ln270">/// @param[in]  copyID  CopyID used by the caller.</a>
<a name="ln271">/// @param[in]  conv_type  Type of the conversion, @see MPConvStackValType.</a>
<a name="ln272">/// @param[in]  objname  Object name, used for error reporting.</a>
<a name="ln273">///</a>
<a name="ln274">/// @return NOTDONE in case of success, what to return in case of failure.</a>
<a name="ln275">static inline int _TYPVAL_ENCODE_CHECK_SELF_REFERENCE(</a>
<a name="ln276">    TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME,</a>
<a name="ln277">    void *const val, int *const val_copyID,</a>
<a name="ln278">    const MPConvStack *const mpstack, const int copyID,</a>
<a name="ln279">    const MPConvStackValType conv_type,</a>
<a name="ln280">    const char *const objname)</a>
<a name="ln281">{</a>
<a name="ln282">  if (*val_copyID == copyID) {</a>
<a name="ln283">    TYPVAL_ENCODE_CONV_RECURSE(val, conv_type);</a>
<a name="ln284">    return OK;</a>
<a name="ln285">  }</a>
<a name="ln286">  *val_copyID = copyID;</a>
<a name="ln287">  return NOTDONE;</a>
<a name="ln288">}</a>
<a name="ln289"> </a>
<a name="ln290">static int _TYPVAL_ENCODE_CONVERT_ONE_VALUE(</a>
<a name="ln291">    TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME,</a>
<a name="ln292">    MPConvStack *const mpstack, MPConvStackVal *const cur_mpsv,</a>
<a name="ln293">    typval_T *const tv, const int copyID,</a>
<a name="ln294">    const char *const objname)</a>
<a name="ln295">  REAL_FATTR_NONNULL_ARG(2, 4, 6) REAL_FATTR_WARN_UNUSED_RESULT;</a>
<a name="ln296"> </a>
<a name="ln297">/// Convert single value</a>
<a name="ln298">///</a>
<a name="ln299">/// Only scalar values are converted immediately, everything else is pushed onto</a>
<a name="ln300">/// the stack.</a>
<a name="ln301">///</a>
<a name="ln302">/// @param  TYPVAL_ENCODE_FIRST_ARG_NAME  First argument, defined by the</a>
<a name="ln303">///                                       includer. Only meaningful to macros</a>
<a name="ln304">///                                       defined by the includer.</a>
<a name="ln305">/// @param  mpstack  Stack with values to convert. Values which are not</a>
<a name="ln306">///                  converted completely by this function (i.e.</a>
<a name="ln307">///                  non-scalars) are pushed here.</a>
<a name="ln308">/// @param  cur_mpsv  Currently converted value from stack.</a>
<a name="ln309">/// @param  tv  Converted value.</a>
<a name="ln310">/// @param[in]  copyID  CopyID.</a>
<a name="ln311">/// @param[in]  objname  Object name, used for error reporting.</a>
<a name="ln312">///</a>
<a name="ln313">/// @return OK in case of success, FAIL in case of failure.</a>
<a name="ln314">static int _TYPVAL_ENCODE_CONVERT_ONE_VALUE(</a>
<a name="ln315">    TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME,</a>
<a name="ln316">    MPConvStack *const mpstack, MPConvStackVal *const cur_mpsv,</a>
<a name="ln317">    typval_T *const tv, const int copyID,</a>
<a name="ln318">    const char *const objname)</a>
<a name="ln319">{</a>
<a name="ln320">  switch (tv-&gt;v_type) {</a>
<a name="ln321">    case VAR_STRING: {</a>
<a name="ln322">      TYPVAL_ENCODE_CONV_STRING(tv, tv-&gt;vval.v_string, tv_strlen(tv));</a>
<a name="ln323">      break;</a>
<a name="ln324">    }</a>
<a name="ln325">    case VAR_NUMBER: {</a>
<a name="ln326">      TYPVAL_ENCODE_CONV_NUMBER(tv, tv-&gt;vval.v_number);</a>
<a name="ln327">      break;</a>
<a name="ln328">    }</a>
<a name="ln329">    case VAR_FLOAT: {</a>
<a name="ln330">      TYPVAL_ENCODE_CONV_FLOAT(tv, tv-&gt;vval.v_float);</a>
<a name="ln331">      break;</a>
<a name="ln332">    }</a>
<a name="ln333">    case VAR_FUNC: {</a>
<a name="ln334">      TYPVAL_ENCODE_CONV_FUNC_START(tv, tv-&gt;vval.v_string);</a>
<a name="ln335">      TYPVAL_ENCODE_CONV_FUNC_BEFORE_ARGS(tv, 0);</a>
<a name="ln336">      TYPVAL_ENCODE_CONV_FUNC_BEFORE_SELF(tv, -1);</a>
<a name="ln337">      TYPVAL_ENCODE_CONV_FUNC_END(tv);</a>
<a name="ln338">      break;</a>
<a name="ln339">    }</a>
<a name="ln340">    case VAR_PARTIAL: {</a>
<a name="ln341">      partial_T *const pt = tv-&gt;vval.v_partial;</a>
<a name="ln342">      (void)pt;</a>
<a name="ln343">      TYPVAL_ENCODE_CONV_FUNC_START(  // -V547</a>
<a name="ln344">          tv, (pt == NULL ? NULL : partial_name(pt)));</a>
<a name="ln345">      _mp_push(*mpstack, ((MPConvStackVal) {  // -V779</a>
<a name="ln346">        .type = kMPConvPartial,</a>
<a name="ln347">        .tv = tv,</a>
<a name="ln348">        .saved_copyID = copyID - 1,</a>
<a name="ln349">        .data = {</a>
<a name="ln350">          .p = {</a>
<a name="ln351">            .stage = kMPConvPartialArgs,</a>
<a name="ln352">            .pt = tv-&gt;vval.v_partial,</a>
<a name="ln353">          },</a>
<a name="ln354">        },</a>
<a name="ln355">      }));</a>
<a name="ln356">      break;</a>
<a name="ln357">    }</a>
<a name="ln358">    case VAR_LIST: {</a>
<a name="ln359">      if (tv-&gt;vval.v_list == NULL || tv_list_len(tv-&gt;vval.v_list) == 0) {</a>
<a name="ln360">        TYPVAL_ENCODE_CONV_EMPTY_LIST(tv);</a>
<a name="ln361">        break;</a>
<a name="ln362">      }</a>
<a name="ln363">      const int saved_copyID = tv_list_copyid(tv-&gt;vval.v_list);</a>
<a name="ln364">      _TYPVAL_ENCODE_DO_CHECK_SELF_REFERENCE(tv-&gt;vval.v_list, lv_copyID, copyID,</a>
<a name="ln365">                                             kMPConvList);</a>
<a name="ln366">      TYPVAL_ENCODE_CONV_LIST_START(tv, tv_list_len(tv-&gt;vval.v_list));</a>
<a name="ln367">      assert(saved_copyID != copyID);</a>
<a name="ln368">      _mp_push(*mpstack, ((MPConvStackVal) {</a>
<a name="ln369">        .type = kMPConvList,</a>
<a name="ln370">        .tv = tv,</a>
<a name="ln371">        .saved_copyID = saved_copyID,</a>
<a name="ln372">        .data = {</a>
<a name="ln373">          .l = {</a>
<a name="ln374">            .list = tv-&gt;vval.v_list,</a>
<a name="ln375">            .li = tv_list_first(tv-&gt;vval.v_list),</a>
<a name="ln376">          },</a>
<a name="ln377">        },</a>
<a name="ln378">      }));</a>
<a name="ln379">      TYPVAL_ENCODE_CONV_REAL_LIST_AFTER_START(tv, _mp_last(*mpstack));</a>
<a name="ln380">      break;</a>
<a name="ln381">    }</a>
<a name="ln382">    case VAR_BOOL: {</a>
<a name="ln383">      switch (tv-&gt;vval.v_bool) {</a>
<a name="ln384">        case kBoolVarTrue:</a>
<a name="ln385">        case kBoolVarFalse: {</a>
<a name="ln386">          TYPVAL_ENCODE_CONV_BOOL(tv, tv-&gt;vval.v_bool == kBoolVarTrue);</a>
<a name="ln387">          break;</a>
<a name="ln388">        }</a>
<a name="ln389">      }</a>
<a name="ln390">      break;</a>
<a name="ln391">    }</a>
<a name="ln392">    case VAR_SPECIAL: {</a>
<a name="ln393">      switch (tv-&gt;vval.v_special) {</a>
<a name="ln394">        case kSpecialVarNull: {</a>
<a name="ln395">          TYPVAL_ENCODE_CONV_NIL(tv);  // -V1037</a>
<a name="ln396">          break;</a>
<a name="ln397">        }</a>
<a name="ln398">      }</a>
<a name="ln399">      break;</a>
<a name="ln400">    }</a>
<a name="ln401">    case VAR_DICT: {</a>
<a name="ln402">      if (tv-&gt;vval.v_dict == NULL</a>
<a name="ln403">          || tv-&gt;vval.v_dict-&gt;dv_hashtab.ht_used == 0) {</a>
<a name="ln404">        TYPVAL_ENCODE_CONV_EMPTY_DICT(tv, tv-&gt;vval.v_dict);</a>
<a name="ln405">        break;</a>
<a name="ln406">      }</a>
<a name="ln407">      const dictitem_T *type_di;</a>
<a name="ln408">      const dictitem_T *val_di;</a>
<a name="ln409">      if (TYPVAL_ENCODE_ALLOW_SPECIALS</a>
<a name="ln410">          &amp;&amp; tv-&gt;vval.v_dict-&gt;dv_hashtab.ht_used == 2</a>
<a name="ln411">          &amp;&amp; (type_di = tv_dict_find((dict_T *)tv-&gt;vval.v_dict,</a>
<a name="ln412">                                     S_LEN(&quot;_TYPE&quot;))) != NULL</a>
<a name="ln413">          &amp;&amp; type_di-&gt;di_tv.v_type == VAR_LIST</a>
<a name="ln414">          &amp;&amp; (val_di = tv_dict_find((dict_T *)tv-&gt;vval.v_dict,</a>
<a name="ln415">                                    S_LEN(&quot;_VAL&quot;))) != NULL) {</a>
<a name="ln416">        size_t i;</a>
<a name="ln417">        for (i = 0; i &lt; ARRAY_SIZE(eval_msgpack_type_lists); i++) {</a>
<a name="ln418">          if (type_di-&gt;di_tv.vval.v_list == eval_msgpack_type_lists[i]) {</a>
<a name="ln419">            break;</a>
<a name="ln420">          }</a>
<a name="ln421">        }</a>
<a name="ln422">        if (i == ARRAY_SIZE(eval_msgpack_type_lists)) {</a>
<a name="ln423">          goto _convert_one_value_regular_dict;</a>
<a name="ln424">        }</a>
<a name="ln425">        switch ((MessagePackType)i) {</a>
<a name="ln426">          case kMPNil: {</a>
<a name="ln427">            TYPVAL_ENCODE_CONV_NIL(tv);</a>
<a name="ln428">            break;</a>
<a name="ln429">          }</a>
<a name="ln430">          case kMPBoolean: {</a>
<a name="ln431">            if (val_di-&gt;di_tv.v_type != VAR_NUMBER) {</a>
<a name="ln432">              goto _convert_one_value_regular_dict;</a>
<a name="ln433">            }</a>
<a name="ln434">            TYPVAL_ENCODE_CONV_BOOL(tv, val_di-&gt;di_tv.vval.v_number);</a>
<a name="ln435">            break;</a>
<a name="ln436">          }</a>
<a name="ln437">          case kMPInteger: {</a>
<a name="ln438">            const list_T *val_list;</a>
<a name="ln439">            varnumber_T sign;</a>
<a name="ln440">            varnumber_T highest_bits;</a>
<a name="ln441">            varnumber_T high_bits;</a>
<a name="ln442">            varnumber_T low_bits;</a>
<a name="ln443">            // List of 4 integers; first is signed (should be 1 or -1, but</a>
<a name="ln444">            // this is not checked), second is unsigned and have at most</a>
<a name="ln445">            // one (sign is -1) or two (sign is 1) non-zero bits (number of</a>
<a name="ln446">            // bits is not checked), other unsigned and have at most 31</a>
<a name="ln447">            // non-zero bits (number of bits is not checked).</a>
<a name="ln448">            if (val_di-&gt;di_tv.v_type != VAR_LIST</a>
<a name="ln449">                || tv_list_len(val_list = val_di-&gt;di_tv.vval.v_list) != 4) {</a>
<a name="ln450">              goto _convert_one_value_regular_dict;</a>
<a name="ln451">            }</a>
<a name="ln452"> </a>
<a name="ln453">            const listitem_T *const sign_li = tv_list_first(val_list);</a>
<a name="ln454">            if (TV_LIST_ITEM_TV(sign_li)-&gt;v_type != VAR_NUMBER</a>
<a name="ln455">                || (sign = TV_LIST_ITEM_TV(sign_li)-&gt;vval.v_number) == 0) {</a>
<a name="ln456">              goto _convert_one_value_regular_dict;</a>
<a name="ln457">            }</a>
<a name="ln458"> </a>
<a name="ln459">            const listitem_T *const highest_bits_li = (</a>
<a name="ln460">                TV_LIST_ITEM_NEXT(val_list, sign_li));</a>
<a name="ln461">            if (TV_LIST_ITEM_TV(highest_bits_li)-&gt;v_type != VAR_NUMBER</a>
<a name="ln462">                || ((highest_bits</a>
<a name="ln463">                     = TV_LIST_ITEM_TV(highest_bits_li)-&gt;vval.v_number)</a>
<a name="ln464">                    &lt; 0)) {</a>
<a name="ln465">              goto _convert_one_value_regular_dict;</a>
<a name="ln466">            }</a>
<a name="ln467"> </a>
<a name="ln468">            const listitem_T *const high_bits_li =  (</a>
<a name="ln469">                TV_LIST_ITEM_NEXT(val_list, highest_bits_li));</a>
<a name="ln470">            if (TV_LIST_ITEM_TV(high_bits_li)-&gt;v_type != VAR_NUMBER</a>
<a name="ln471">                || ((high_bits = TV_LIST_ITEM_TV(high_bits_li)-&gt;vval.v_number)</a>
<a name="ln472">                    &lt; 0)) {</a>
<a name="ln473">              goto _convert_one_value_regular_dict;</a>
<a name="ln474">            }</a>
<a name="ln475"> </a>
<a name="ln476">            const listitem_T *const low_bits_li = tv_list_last(val_list);</a>
<a name="ln477">            if (TV_LIST_ITEM_TV(low_bits_li)-&gt;v_type != VAR_NUMBER</a>
<a name="ln478">                || ((low_bits = TV_LIST_ITEM_TV(low_bits_li)-&gt;vval.v_number)</a>
<a name="ln479">                    &lt; 0)) {</a>
<a name="ln480">              goto _convert_one_value_regular_dict;</a>
<a name="ln481">            }</a>
<a name="ln482"> </a>
<a name="ln483">            const uint64_t number = ((uint64_t)(((uint64_t)highest_bits) &lt;&lt; 62)</a>
<a name="ln484">                                     | (uint64_t)(((uint64_t)high_bits) &lt;&lt; 31)</a>
<a name="ln485">                                     | (uint64_t)low_bits);</a>
<a name="ln486">            if (sign &gt; 0) {</a>
<a name="ln487">              TYPVAL_ENCODE_CONV_UNSIGNED_NUMBER(tv, number);</a>
<a name="ln488">            } else {</a>
<a name="ln489">              TYPVAL_ENCODE_CONV_NUMBER(tv, -number);</a>
<a name="ln490">            }</a>
<a name="ln491">            break;</a>
<a name="ln492">          }</a>
<a name="ln493">          case kMPFloat: {</a>
<a name="ln494">            if (val_di-&gt;di_tv.v_type != VAR_FLOAT) {</a>
<a name="ln495">              goto _convert_one_value_regular_dict;</a>
<a name="ln496">            }</a>
<a name="ln497">            TYPVAL_ENCODE_CONV_FLOAT(tv, val_di-&gt;di_tv.vval.v_float);</a>
<a name="ln498">            break;</a>
<a name="ln499">          }</a>
<a name="ln500">          case kMPString:</a>
<a name="ln501">          case kMPBinary: {</a>
<a name="ln502">            const bool is_string = ((MessagePackType)i == kMPString);</a>
<a name="ln503">            if (val_di-&gt;di_tv.v_type != VAR_LIST) {</a>
<a name="ln504">              goto _convert_one_value_regular_dict;</a>
<a name="ln505">            }</a>
<a name="ln506">            size_t len;</a>
<a name="ln507">            char *buf;</a>
<a name="ln508">            if (!encode_vim_list_to_buf(val_di-&gt;di_tv.vval.v_list, &amp;len,</a>
<a name="ln509">                                        &amp;buf)) {</a>
<a name="ln510">              goto _convert_one_value_regular_dict;</a>
<a name="ln511">            }</a>
<a name="ln512">            if (is_string) {</a>
<a name="ln513">              TYPVAL_ENCODE_CONV_STR_STRING(tv, buf, len);</a>
<a name="ln514">            } else {  // -V523</a>
<a name="ln515">              TYPVAL_ENCODE_CONV_STRING(tv, buf, len);</a>
<a name="ln516">            }</a>
<a name="ln517">            xfree(buf);</a>
<a name="ln518">            break;</a>
<a name="ln519">          }</a>
<a name="ln520">          case kMPArray: {</a>
<a name="ln521">            if (val_di-&gt;di_tv.v_type != VAR_LIST) {</a>
<a name="ln522">              goto _convert_one_value_regular_dict;</a>
<a name="ln523">            }</a>
<a name="ln524">            const int saved_copyID = tv_list_copyid(val_di-&gt;di_tv.vval.v_list);</a>
<a name="ln525">            _TYPVAL_ENCODE_DO_CHECK_SELF_REFERENCE(val_di-&gt;di_tv.vval.v_list,</a>
<a name="ln526">                                                   lv_copyID, copyID,</a>
<a name="ln527">                                                   kMPConvList);</a>
<a name="ln528">            TYPVAL_ENCODE_CONV_LIST_START(</a>
<a name="ln529">                tv, tv_list_len(val_di-&gt;di_tv.vval.v_list));</a>
<a name="ln530">            assert(saved_copyID != copyID &amp;&amp; saved_copyID != copyID - 1);</a>
<a name="ln531">            _mp_push(*mpstack, ((MPConvStackVal) {</a>
<a name="ln532">              .tv = tv,</a>
<a name="ln533">              .type = kMPConvList,</a>
<a name="ln534">              .saved_copyID = saved_copyID,</a>
<a name="ln535">              .data = {</a>
<a name="ln536">                .l = {</a>
<a name="ln537">                  .list = val_di-&gt;di_tv.vval.v_list,</a>
<a name="ln538">                  .li = tv_list_first(val_di-&gt;di_tv.vval.v_list),</a>
<a name="ln539">                },</a>
<a name="ln540">              },</a>
<a name="ln541">            }));</a>
<a name="ln542">            break;</a>
<a name="ln543">          }</a>
<a name="ln544">          case kMPMap: {</a>
<a name="ln545">            if (val_di-&gt;di_tv.v_type != VAR_LIST) {</a>
<a name="ln546">              goto _convert_one_value_regular_dict;</a>
<a name="ln547">            }</a>
<a name="ln548">            list_T *const val_list = val_di-&gt;di_tv.vval.v_list;</a>
<a name="ln549">            if (val_list == NULL || tv_list_len(val_list) == 0) {</a>
<a name="ln550">              TYPVAL_ENCODE_CONV_EMPTY_DICT(  // -V501</a>
<a name="ln551">                  tv, TYPVAL_ENCODE_NODICT_VAR);</a>
<a name="ln552">              break;</a>
<a name="ln553">            }</a>
<a name="ln554">            TV_LIST_ITER_CONST(val_list, li, {</a>
<a name="ln555">              if (TV_LIST_ITEM_TV(li)-&gt;v_type != VAR_LIST</a>
<a name="ln556">                  || tv_list_len(TV_LIST_ITEM_TV(li)-&gt;vval.v_list) != 2) {</a>
<a name="ln557">                goto _convert_one_value_regular_dict;</a>
<a name="ln558">              }</a>
<a name="ln559">            });</a>
<a name="ln560">            const int saved_copyID = tv_list_copyid(val_di-&gt;di_tv.vval.v_list);</a>
<a name="ln561">            _TYPVAL_ENCODE_DO_CHECK_SELF_REFERENCE(val_list, lv_copyID, copyID,</a>
<a name="ln562">                                                   kMPConvPairs);</a>
<a name="ln563">            TYPVAL_ENCODE_CONV_DICT_START(tv, TYPVAL_ENCODE_NODICT_VAR,</a>
<a name="ln564">                                          tv_list_len(val_list));</a>
<a name="ln565">            assert(saved_copyID != copyID &amp;&amp; saved_copyID != copyID - 1);</a>
<a name="ln566">            _mp_push(*mpstack, ((MPConvStackVal) {</a>
<a name="ln567">              .tv = tv,</a>
<a name="ln568">              .type = kMPConvPairs,</a>
<a name="ln569">              .saved_copyID = saved_copyID,</a>
<a name="ln570">              .data = {</a>
<a name="ln571">                .l = {</a>
<a name="ln572">                  .list = val_list,</a>
<a name="ln573">                  .li = tv_list_first(val_list),</a>
<a name="ln574">                },</a>
<a name="ln575">              },</a>
<a name="ln576">            }));</a>
<a name="ln577">            break;</a>
<a name="ln578">          }</a>
<a name="ln579">          case kMPExt: {</a>
<a name="ln580">            const list_T *val_list;</a>
<a name="ln581">            varnumber_T type;</a>
<a name="ln582">            if (val_di-&gt;di_tv.v_type != VAR_LIST</a>
<a name="ln583">                || tv_list_len((val_list = val_di-&gt;di_tv.vval.v_list)) != 2</a>
<a name="ln584">                || (TV_LIST_ITEM_TV(tv_list_first(val_list))-&gt;v_type</a>
<a name="ln585">                    != VAR_NUMBER)</a>
<a name="ln586">                || ((type</a>
<a name="ln587">                     = TV_LIST_ITEM_TV(tv_list_first(val_list))-&gt;vval.v_number)</a>
<a name="ln588">                    &gt; INT8_MAX)</a>
<a name="ln589">                || type &lt; INT8_MIN</a>
<a name="ln590">                || (TV_LIST_ITEM_TV(tv_list_last(val_list))-&gt;v_type</a>
<a name="ln591">                    != VAR_LIST)) {</a>
<a name="ln592">              goto _convert_one_value_regular_dict;</a>
<a name="ln593">            }</a>
<a name="ln594">            size_t len;</a>
<a name="ln595">            char *buf;</a>
<a name="ln596">            if (!(</a>
<a name="ln597">                encode_vim_list_to_buf(</a>
<a name="ln598">                    TV_LIST_ITEM_TV(tv_list_last(val_list))-&gt;vval.v_list, &amp;len,</a>
<a name="ln599">                    &amp;buf))) {</a>
<a name="ln600">              goto _convert_one_value_regular_dict;</a>
<a name="ln601">            }</a>
<a name="ln602">            TYPVAL_ENCODE_CONV_EXT_STRING(tv, buf, len, type);</a>
<a name="ln603">            xfree(buf);</a>
<a name="ln604">            break;</a>
<a name="ln605">          }</a>
<a name="ln606">        }</a>
<a name="ln607">        break;</a>
<a name="ln608">      }</a>
<a name="ln609">_convert_one_value_regular_dict: {}</a>
<a name="ln610">      const int saved_copyID = tv-&gt;vval.v_dict-&gt;dv_copyID;</a>
<a name="ln611">      _TYPVAL_ENCODE_DO_CHECK_SELF_REFERENCE(tv-&gt;vval.v_dict, dv_copyID, copyID,</a>
<a name="ln612">                                             kMPConvDict);</a>
<a name="ln613">      TYPVAL_ENCODE_CONV_DICT_START(tv, tv-&gt;vval.v_dict,</a>
<a name="ln614">                                    tv-&gt;vval.v_dict-&gt;dv_hashtab.ht_used);</a>
<a name="ln615">      assert(saved_copyID != copyID);</a>
<a name="ln616">      _mp_push(*mpstack, ((MPConvStackVal) {</a>
<a name="ln617">        .tv = tv,</a>
<a name="ln618">        .type = kMPConvDict,</a>
<a name="ln619">        .saved_copyID = saved_copyID,</a>
<a name="ln620">        .data = {</a>
<a name="ln621">          .d = {</a>
<a name="ln622">            .dict = tv-&gt;vval.v_dict,</a>
<a name="ln623">            .dictp = &amp;tv-&gt;vval.v_dict,</a>
<a name="ln624">            .hi = tv-&gt;vval.v_dict-&gt;dv_hashtab.ht_array,</a>
<a name="ln625">            .todo = tv-&gt;vval.v_dict-&gt;dv_hashtab.ht_used,</a>
<a name="ln626">          },</a>
<a name="ln627">        },</a>
<a name="ln628">      }));</a>
<a name="ln629">      TYPVAL_ENCODE_CONV_REAL_DICT_AFTER_START(tv, tv-&gt;vval.v_dict,</a>
<a name="ln630">                                               _mp_last(*mpstack));</a>
<a name="ln631">      break;</a>
<a name="ln632">    }</a>
<a name="ln633">    case VAR_UNKNOWN: {</a>
<a name="ln634">      internal_error(STR(_TYPVAL_ENCODE_CONVERT_ONE_VALUE) &quot;()&quot;);</a>
<a name="ln635">      return FAIL;</a>
<a name="ln636">    }</a>
<a name="ln637">  }</a>
<a name="ln638">typval_encode_stop_converting_one_item:</a>
<a name="ln639">  return OK;</a>
<a name="ln640">  // Prevent “unused label” warnings.</a>
<a name="ln641">  goto typval_encode_stop_converting_one_item;  // -V779</a>
<a name="ln642">}</a>
<a name="ln643"> </a>
<a name="ln644">TYPVAL_ENCODE_SCOPE int _TYPVAL_ENCODE_ENCODE(</a>
<a name="ln645">    TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME,</a>
<a name="ln646">    typval_T *const tv, const char *const objname)</a>
<a name="ln647">  REAL_FATTR_NONNULL_ARG(2, 3) REAL_FATTR_WARN_UNUSED_RESULT;</a>
<a name="ln648"> </a>
<a name="ln649">/// Convert the whole typval</a>
<a name="ln650">///</a>
<a name="ln651">/// @param  TYPVAL_ENCODE_FIRST_ARG_NAME  First argument, defined by the</a>
<a name="ln652">///                                       includer. Only meaningful to macros</a>
<a name="ln653">///                                       defined by the includer.</a>
<a name="ln654">/// @param  top_tv  Converted value.</a>
<a name="ln655">/// @param[in]  objname  Object name, used for error reporting.</a>
<a name="ln656">///</a>
<a name="ln657">/// @return OK in case of success, FAIL in case of failure.</a>
<a name="ln658">TYPVAL_ENCODE_SCOPE int _TYPVAL_ENCODE_ENCODE(</a>
<a name="ln659">    TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME,</a>
<a name="ln660">    typval_T *const top_tv, const char *const objname)</a>
<a name="ln661">{</a>
<a name="ln662">  const int copyID = get_copyID();</a>
<a name="ln663">  MPConvStack mpstack;</a>
<a name="ln664">  _mp_init(mpstack);</a>
<a name="ln665">  if (_TYPVAL_ENCODE_CONVERT_ONE_VALUE(TYPVAL_ENCODE_FIRST_ARG_NAME, &amp;mpstack,</a>
<a name="ln666">                                       NULL,</a>
<a name="ln667">                                       top_tv, copyID, objname)</a>
<a name="ln668">      == FAIL) {</a>
<a name="ln669">    goto encode_vim_to__error_ret;</a>
<a name="ln670">  }</a>
<a name="ln671">/// Label common for this and convert_one_value functions, used for escaping</a>
<a name="ln672">/// from macros like TYPVAL_ENCODE_CONV_DICT_START.</a>
<a name="ln673">typval_encode_stop_converting_one_item:</a>
<a name="ln674">  while (_mp_size(mpstack)) {</a>
<a name="ln675">    MPConvStackVal *cur_mpsv = &amp;_mp_last(mpstack);</a>
<a name="ln676">    typval_T *tv = NULL;</a>
<a name="ln677">    switch (cur_mpsv-&gt;type) {</a>
<a name="ln678">      case kMPConvDict: {</a>
<a name="ln679">        if (!cur_mpsv-&gt;data.d.todo) {</a>
<a name="ln680">          (void)_mp_pop(mpstack);</a>
<a name="ln681">          cur_mpsv-&gt;data.d.dict-&gt;dv_copyID = cur_mpsv-&gt;saved_copyID;</a>
<a name="ln682">          TYPVAL_ENCODE_CONV_DICT_END(cur_mpsv-&gt;tv, *cur_mpsv-&gt;data.d.dictp);</a>
<a name="ln683">          continue;</a>
<a name="ln684">        } else if (cur_mpsv-&gt;data.d.todo</a>
<a name="ln685">                   != cur_mpsv-&gt;data.d.dict-&gt;dv_hashtab.ht_used) {</a>
<a name="ln686">          TYPVAL_ENCODE_CONV_DICT_BETWEEN_ITEMS(cur_mpsv-&gt;tv,</a>
<a name="ln687">                                                *cur_mpsv-&gt;data.d.dictp);</a>
<a name="ln688">        }</a>
<a name="ln689">        while (HASHITEM_EMPTY(cur_mpsv-&gt;data.d.hi)) {</a>
<a name="ln690">          cur_mpsv-&gt;data.d.hi++;</a>
<a name="ln691">        }</a>
<a name="ln692">        dictitem_T *const di = TV_DICT_HI2DI(cur_mpsv-&gt;data.d.hi);</a>
<a name="ln693">        cur_mpsv-&gt;data.d.todo--;</a>
<a name="ln694">        cur_mpsv-&gt;data.d.hi++;</a>
<a name="ln695">        TYPVAL_ENCODE_CONV_STR_STRING(NULL, &amp;di-&gt;di_key[0],</a>
<a name="ln696">                                      strlen((char *)&amp;di-&gt;di_key[0]));</a>
<a name="ln697">        TYPVAL_ENCODE_CONV_DICT_AFTER_KEY(cur_mpsv-&gt;tv,</a>
<a name="ln698">                                          *cur_mpsv-&gt;data.d.dictp);</a>
<a name="ln699">        tv = &amp;di-&gt;di_tv;</a>
<a name="ln700">        break;</a>
<a name="ln701">      }</a>
<a name="ln702">      case kMPConvList: {</a>
<a name="ln703">        if (cur_mpsv-&gt;data.l.li == NULL) {</a>
<a name="ln704">          (void)_mp_pop(mpstack);</a>
<a name="ln705">          tv_list_set_copyid(cur_mpsv-&gt;data.l.list, cur_mpsv-&gt;saved_copyID);</a>
<a name="ln706">          TYPVAL_ENCODE_CONV_LIST_END(cur_mpsv-&gt;tv);</a>
<a name="ln707">          continue;</a>
<a name="ln708">        } else if (cur_mpsv-&gt;data.l.li</a>
<a name="ln709">                   != tv_list_first(cur_mpsv-&gt;data.l.list)) {</a>
<a name="ln710">          TYPVAL_ENCODE_CONV_LIST_BETWEEN_ITEMS(cur_mpsv-&gt;tv);</a>
<a name="ln711">        }</a>
<a name="ln712">        tv = TV_LIST_ITEM_TV(cur_mpsv-&gt;data.l.li);</a>
<a name="ln713">        cur_mpsv-&gt;data.l.li = TV_LIST_ITEM_NEXT(cur_mpsv-&gt;data.l.list,</a>
<a name="ln714">                                                cur_mpsv-&gt;data.l.li);</a>
<a name="ln715">        break;</a>
<a name="ln716">      }</a>
<a name="ln717">      case kMPConvPairs: {</a>
<a name="ln718">        if (cur_mpsv-&gt;data.l.li == NULL) {</a>
<a name="ln719">          (void)_mp_pop(mpstack);</a>
<a name="ln720">          tv_list_set_copyid(cur_mpsv-&gt;data.l.list, cur_mpsv-&gt;saved_copyID);</a>
<a name="ln721">          TYPVAL_ENCODE_CONV_DICT_END(cur_mpsv-&gt;tv, TYPVAL_ENCODE_NODICT_VAR);</a>
<a name="ln722">          continue;</a>
<a name="ln723">        } else if (cur_mpsv-&gt;data.l.li</a>
<a name="ln724">                   != tv_list_first(cur_mpsv-&gt;data.l.list)) {</a>
<a name="ln725">          TYPVAL_ENCODE_CONV_DICT_BETWEEN_ITEMS(</a>
<a name="ln726">              cur_mpsv-&gt;tv, TYPVAL_ENCODE_NODICT_VAR);</a>
<a name="ln727">        }</a>
<a name="ln728">        const list_T *const kv_pair = (</a>
<a name="ln729">            TV_LIST_ITEM_TV(cur_mpsv-&gt;data.l.li)-&gt;vval.v_list);</a>
<a name="ln730">        TYPVAL_ENCODE_SPECIAL_DICT_KEY_CHECK(</a>
<a name="ln731">            encode_vim_to__error_ret, *TV_LIST_ITEM_TV(tv_list_first(kv_pair)));</a>
<a name="ln732">        if (</a>
<a name="ln733">            _TYPVAL_ENCODE_CONVERT_ONE_VALUE(</a>
<a name="ln734">                TYPVAL_ENCODE_FIRST_ARG_NAME, &amp;mpstack, cur_mpsv,</a>
<a name="ln735">                TV_LIST_ITEM_TV(tv_list_first(kv_pair)), copyID, objname)</a>
<a name="ln736">            == FAIL) {</a>
<a name="ln737">          goto encode_vim_to__error_ret;</a>
<a name="ln738">        }</a>
<a name="ln739">        TYPVAL_ENCODE_CONV_DICT_AFTER_KEY(cur_mpsv-&gt;tv,</a>
<a name="ln740">                                          TYPVAL_ENCODE_NODICT_VAR);</a>
<a name="ln741">        tv = TV_LIST_ITEM_TV(tv_list_last(kv_pair));</a>
<a name="ln742">        cur_mpsv-&gt;data.l.li = TV_LIST_ITEM_NEXT(cur_mpsv-&gt;data.l.list,</a>
<a name="ln743">                                                cur_mpsv-&gt;data.l.li);</a>
<a name="ln744">        break;</a>
<a name="ln745">      }</a>
<a name="ln746">      case kMPConvPartial: {</a>
<a name="ln747">        partial_T *const pt = cur_mpsv-&gt;data.p.pt;</a>
<a name="ln748">        tv = cur_mpsv-&gt;tv;</a>
<a name="ln749">        (void)tv;</a>
<a name="ln750">        switch (cur_mpsv-&gt;data.p.stage) {</a>
<a name="ln751">          case kMPConvPartialArgs: {</a>
<a name="ln752">            TYPVAL_ENCODE_CONV_FUNC_BEFORE_ARGS(tv,</a>
<a name="ln753">                                                pt == NULL ? 0 : pt-&gt;pt_argc);</a>
<a name="ln754">            cur_mpsv-&gt;data.p.stage = kMPConvPartialSelf;</a>
<a name="ln755">            if (pt != NULL &amp;&amp; pt-&gt;pt_argc &gt; 0) {</a>
<a name="ln756">              TYPVAL_ENCODE_CONV_LIST_START(NULL, pt-&gt;pt_argc);</a>
<a name="ln757">              _mp_push(mpstack, ((MPConvStackVal) {</a>
<a name="ln758">                .type = kMPConvPartialList,</a>
<a name="ln759">                .tv = NULL,</a>
<a name="ln760">                .saved_copyID = copyID - 1,</a>
<a name="ln761">                .data = {</a>
<a name="ln762">                  .a = {</a>
<a name="ln763">                    .arg = pt-&gt;pt_argv,</a>
<a name="ln764">                    .argv = pt-&gt;pt_argv,</a>
<a name="ln765">                    .todo = (size_t)pt-&gt;pt_argc,</a>
<a name="ln766">                  },</a>
<a name="ln767">                },</a>
<a name="ln768">              }));</a>
<a name="ln769">            }</a>
<a name="ln770">            break;</a>
<a name="ln771">          }</a>
<a name="ln772">          case kMPConvPartialSelf: {</a>
<a name="ln773">            cur_mpsv-&gt;data.p.stage = kMPConvPartialEnd;</a>
<a name="ln774">            dict_T *const dict = pt == NULL ? NULL : pt-&gt;pt_dict;</a>
<a name="ln775">            if (dict != NULL) {</a>
<a name="ln776">              TYPVAL_ENCODE_CONV_FUNC_BEFORE_SELF(tv, dict-&gt;dv_hashtab.ht_used);</a>
<a name="ln777">              if (dict-&gt;dv_hashtab.ht_used == 0) {</a>
<a name="ln778">                TYPVAL_ENCODE_CONV_EMPTY_DICT(NULL, pt-&gt;pt_dict);</a>
<a name="ln779">                continue;</a>
<a name="ln780">              }</a>
<a name="ln781">              const int saved_copyID = dict-&gt;dv_copyID;</a>
<a name="ln782">              const int te_csr_ret = _TYPVAL_ENCODE_CHECK_SELF_REFERENCE(</a>
<a name="ln783">                  TYPVAL_ENCODE_FIRST_ARG_NAME,</a>
<a name="ln784">                  dict, &amp;dict-&gt;dv_copyID, &amp;mpstack, copyID, kMPConvDict,</a>
<a name="ln785">                  objname);</a>
<a name="ln786">              if (te_csr_ret != NOTDONE) {</a>
<a name="ln787">                if (te_csr_ret == FAIL) {</a>
<a name="ln788">                  goto encode_vim_to__error_ret;</a>
<a name="ln789">                } else {</a>
<a name="ln790">                  continue;</a>
<a name="ln791">                }</a>
<a name="ln792">              }</a>
<a name="ln793">              TYPVAL_ENCODE_CONV_DICT_START(NULL, pt-&gt;pt_dict,</a>
<a name="ln794">                                            dict-&gt;dv_hashtab.ht_used);</a>
<a name="ln795">              assert(saved_copyID != copyID &amp;&amp; saved_copyID != copyID - 1);</a>
<a name="ln796">              _mp_push(mpstack, ((MPConvStackVal) {</a>
<a name="ln797">                .type = kMPConvDict,</a>
<a name="ln798">                .tv = NULL,</a>
<a name="ln799">                .saved_copyID = saved_copyID,</a>
<a name="ln800">                .data = {</a>
<a name="ln801">                  .d = {</a>
<a name="ln802">                    .dict = dict,</a>
<a name="ln803">                    .dictp = &amp;pt-&gt;pt_dict,</a>
<a name="ln804">                    .hi = dict-&gt;dv_hashtab.ht_array,</a>
<a name="ln805">                    .todo = dict-&gt;dv_hashtab.ht_used,</a>
<a name="ln806">                  },</a>
<a name="ln807">                },</a>
<a name="ln808">              }));</a>
<a name="ln809">              TYPVAL_ENCODE_CONV_REAL_DICT_AFTER_START(NULL, pt-&gt;pt_dict,</a>
<a name="ln810">                                                       _mp_last(mpstack));</a>
<a name="ln811">            } else {</a>
<a name="ln812">              TYPVAL_ENCODE_CONV_FUNC_BEFORE_SELF(tv, -1);</a>
<a name="ln813">            }</a>
<a name="ln814">            break;</a>
<a name="ln815">          }</a>
<a name="ln816">          case kMPConvPartialEnd: {</a>
<a name="ln817">            TYPVAL_ENCODE_CONV_FUNC_END(tv);</a>
<a name="ln818">            (void)_mp_pop(mpstack);</a>
<a name="ln819">            break;</a>
<a name="ln820">          }</a>
<a name="ln821">        }</a>
<a name="ln822">        continue;</a>
<a name="ln823">      }</a>
<a name="ln824">      case kMPConvPartialList: {</a>
<a name="ln825">        if (!cur_mpsv-&gt;data.a.todo) {</a>
<a name="ln826">          (void)_mp_pop(mpstack);</a>
<a name="ln827">          TYPVAL_ENCODE_CONV_LIST_END(NULL);</a>
<a name="ln828">          continue;</a>
<a name="ln829">        } else if (cur_mpsv-&gt;data.a.argv != cur_mpsv-&gt;data.a.arg) {</a>
<a name="ln830">          TYPVAL_ENCODE_CONV_LIST_BETWEEN_ITEMS(NULL);</a>
<a name="ln831">        }</a>
<a name="ln832">        tv = cur_mpsv-&gt;data.a.arg++;</a>
<a name="ln833">        cur_mpsv-&gt;data.a.todo--;</a>
<a name="ln834">        break;</a>
<a name="ln835">      }</a>
<a name="ln836">    }</a>
<a name="ln837">    assert(tv != NULL);</a>
<a name="ln838">    if (_TYPVAL_ENCODE_CONVERT_ONE_VALUE(TYPVAL_ENCODE_FIRST_ARG_NAME, &amp;mpstack,</a>
<a name="ln839">                                         cur_mpsv, tv, copyID, objname)</a>
<a name="ln840">        == FAIL) {</a>
<a name="ln841">      goto encode_vim_to__error_ret;</a>
<a name="ln842">    }</a>
<a name="ln843">  }</a>
<a name="ln844">  _mp_destroy(mpstack);</a>
<a name="ln845">  return OK;</a>
<a name="ln846">encode_vim_to__error_ret:</a>
<a name="ln847">  _mp_destroy(mpstack);</a>
<a name="ln848">  return FAIL;</a>
<a name="ln849">  // Prevent “unused label” warnings.</a>
<a name="ln850">  goto typval_encode_stop_converting_one_item;  // -V779</a>
<a name="ln851">}</a>

</code></pre>
<div class="balloon" rel="393"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v785/" target="_blank">V785</a> Constant expression in switch statement.</p></div>
<div class="balloon" rel="283"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="326"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="326"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'vim_snprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="330"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="489"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="489"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'vim_snprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="497"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="487"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="487"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'vim_snprintf' function. The memsize type argument is expected.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
