
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>shada.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;stdlib.h&gt;</a>
<a name="ln5">#include &lt;stddef.h&gt;</a>
<a name="ln6">#include &lt;stdbool.h&gt;</a>
<a name="ln7">#include &lt;string.h&gt;</a>
<a name="ln8">#include &lt;inttypes.h&gt;</a>
<a name="ln9">#include &lt;errno.h&gt;</a>
<a name="ln10">#include &lt;assert.h&gt;</a>
<a name="ln11"> </a>
<a name="ln12">#include &lt;msgpack.h&gt;</a>
<a name="ln13">#include &lt;uv.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln16">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln17">#include &quot;nvim/vim.h&quot;</a>
<a name="ln18">#include &quot;nvim/pos.h&quot;</a>
<a name="ln19">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln20">#include &quot;nvim/shada.h&quot;</a>
<a name="ln21">#include &quot;nvim/message.h&quot;</a>
<a name="ln22">#include &quot;nvim/globals.h&quot;</a>
<a name="ln23">#include &quot;nvim/memory.h&quot;</a>
<a name="ln24">#include &quot;nvim/mark.h&quot;</a>
<a name="ln25">#include &quot;nvim/macros.h&quot;</a>
<a name="ln26">#include &quot;nvim/ops.h&quot;</a>
<a name="ln27">#include &quot;nvim/garray.h&quot;</a>
<a name="ln28">#include &quot;nvim/option.h&quot;</a>
<a name="ln29">#include &quot;nvim/msgpack_rpc/helpers.h&quot;</a>
<a name="ln30">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln31">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln32">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln33">#include &quot;nvim/buffer_defs.h&quot;</a>
<a name="ln34">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln35">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln36">#include &quot;nvim/search.h&quot;</a>
<a name="ln37">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln38">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln39">#include &quot;nvim/version.h&quot;</a>
<a name="ln40">#include &quot;nvim/path.h&quot;</a>
<a name="ln41">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln42">#include &quot;nvim/os/fileio.h&quot;</a>
<a name="ln43">#include &quot;nvim/strings.h&quot;</a>
<a name="ln44">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln45">#include &quot;nvim/eval/encode.h&quot;</a>
<a name="ln46">#include &quot;nvim/eval/decode.h&quot;</a>
<a name="ln47">#include &quot;nvim/lib/khash.h&quot;</a>
<a name="ln48">#include &quot;nvim/lib/kvec.h&quot;</a>
<a name="ln49"> </a>
<a name="ln50">#ifdef HAVE_BE64TOH</a>
<a name="ln51"># define _BSD_SOURCE 1</a>
<a name="ln52"># define _DEFAULT_SOURCE 1</a>
<a name="ln53"># include ENDIAN_INCLUDE_FILE</a>
<a name="ln54">#endif</a>
<a name="ln55"> </a>
<a name="ln56">// Note: when using bufset hash pointers are intentionally casted to uintptr_t</a>
<a name="ln57">// and not to khint32_t or khint64_t: this way compiler must give a warning</a>
<a name="ln58">// (-Wconversion) when types change.</a>
<a name="ln59">#ifdef ARCH_32</a>
<a name="ln60">KHASH_SET_INIT_INT(bufset)</a>
<a name="ln61">#elif defined(ARCH_64)</a>
<a name="ln62">KHASH_SET_INIT_INT64(bufset)</a>
<a name="ln63">#else</a>
<a name="ln64"># error Not a 64- or 32-bit architecture</a>
<a name="ln65">#endif</a>
<a name="ln66">KHASH_MAP_INIT_STR(fnamebufs, buf_T *)</a>
<a name="ln67">KHASH_SET_INIT_STR(strset)</a>
<a name="ln68"> </a>
<a name="ln69">#define copy_option_part(src, dest, ...) \</a>
<a name="ln70">    ((char *) copy_option_part((char_u **) src, (char_u *) dest, __VA_ARGS__))</a>
<a name="ln71">#define find_shada_parameter(...) \</a>
<a name="ln72">    ((const char *) find_shada_parameter(__VA_ARGS__))</a>
<a name="ln73">#define home_replace_save(a, b) \</a>
<a name="ln74">    ((char *)home_replace_save(a, (char_u *)b))</a>
<a name="ln75">#define home_replace(a, b, c, d, e) \</a>
<a name="ln76">    home_replace(a, (char_u *)b, (char_u *)c, d, e)</a>
<a name="ln77">#define vim_rename(a, b) \</a>
<a name="ln78">    (vim_rename((char_u *)a, (char_u *)b))</a>
<a name="ln79">#define mb_strnicmp(a, b, c) \</a>
<a name="ln80">    (mb_strnicmp((char_u *)a, (char_u *)b, c))</a>
<a name="ln81">#define path_try_shorten_fname(b) \</a>
<a name="ln82">    ((char *)path_try_shorten_fname((char_u *)b))</a>
<a name="ln83">#define buflist_new(ffname, sfname, ...) \</a>
<a name="ln84">    (buflist_new((char_u *)ffname, (char_u *)sfname, __VA_ARGS__))</a>
<a name="ln85">#define os_isdir(f) (os_isdir((char_u *) f))</a>
<a name="ln86">#define regtilde(s, m) ((char *) regtilde((char_u *) s, m))</a>
<a name="ln87">#define path_tail_with_sep(f) ((char *) path_tail_with_sep((char_u *)f))</a>
<a name="ln88"> </a>
<a name="ln89">#define SEARCH_KEY_MAGIC &quot;sm&quot;</a>
<a name="ln90">#define SEARCH_KEY_SMARTCASE &quot;sc&quot;</a>
<a name="ln91">#define SEARCH_KEY_HAS_LINE_OFFSET &quot;sl&quot;</a>
<a name="ln92">#define SEARCH_KEY_PLACE_CURSOR_AT_END &quot;se&quot;</a>
<a name="ln93">#define SEARCH_KEY_IS_LAST_USED &quot;su&quot;</a>
<a name="ln94">#define SEARCH_KEY_IS_SUBSTITUTE_PATTERN &quot;ss&quot;</a>
<a name="ln95">#define SEARCH_KEY_HIGHLIGHTED &quot;sh&quot;</a>
<a name="ln96">#define SEARCH_KEY_OFFSET &quot;so&quot;</a>
<a name="ln97">#define SEARCH_KEY_PAT &quot;sp&quot;</a>
<a name="ln98">#define SEARCH_KEY_BACKWARD &quot;sb&quot;</a>
<a name="ln99"> </a>
<a name="ln100">#define REG_KEY_TYPE &quot;rt&quot;</a>
<a name="ln101">#define REG_KEY_WIDTH &quot;rw&quot;</a>
<a name="ln102">#define REG_KEY_CONTENTS &quot;rc&quot;</a>
<a name="ln103">#define REG_KEY_UNNAMED &quot;ru&quot;</a>
<a name="ln104"> </a>
<a name="ln105">#define KEY_LNUM &quot;l&quot;</a>
<a name="ln106">#define KEY_COL &quot;c&quot;</a>
<a name="ln107">#define KEY_FILE &quot;f&quot;</a>
<a name="ln108">#define KEY_NAME_CHAR &quot;n&quot;</a>
<a name="ln109"> </a>
<a name="ln110">// Error messages formerly used by viminfo code:</a>
<a name="ln111">//   E136: viminfo: Too many errors, skipping rest of file</a>
<a name="ln112">//   E137: Viminfo file is not writable: %s</a>
<a name="ln113">//   E138: Can't write viminfo file %s!</a>
<a name="ln114">//   E195: Cannot open ShaDa file for reading</a>
<a name="ln115">//   E574: Unknown register type %d</a>
<a name="ln116">//   E575: Illegal starting char</a>
<a name="ln117">//   E576: Missing '&gt;'</a>
<a name="ln118">//   E577: Illegal register name</a>
<a name="ln119">//   E886: Can't rename viminfo file to %s!</a>
<a name="ln120">//   E929: Too many viminfo temp files, like %s!</a>
<a name="ln121">// Now only six of them are used:</a>
<a name="ln122">//   E137: ShaDa file is not writeable (for pre-open checks)</a>
<a name="ln123">//   E929: All %s.tmp.X files exist, cannot write ShaDa file!</a>
<a name="ln124">//   RCERR (E576) for critical read errors.</a>
<a name="ln125">//   RNERR (E136) for various errors when renaming.</a>
<a name="ln126">//   RERR (E575) for various errors inside read ShaDa file.</a>
<a name="ln127">//   SERR (E886) for various “system” errors (always contains output of</a>
<a name="ln128">//   strerror)</a>
<a name="ln129">//   WERR (E574) for various ignorable write errors</a>
<a name="ln130"> </a>
<a name="ln131">/// Common prefix for all errors inside ShaDa file</a>
<a name="ln132">///</a>
<a name="ln133">/// I.e. errors occurred while parsing, but not system errors occurred while</a>
<a name="ln134">/// reading.</a>
<a name="ln135">#define RERR &quot;E575: &quot;</a>
<a name="ln136"> </a>
<a name="ln137">/// Common prefix for critical read errors</a>
<a name="ln138">///</a>
<a name="ln139">/// I.e. errors that make shada_read_next_item return kSDReadStatusNotShaDa.</a>
<a name="ln140">#define RCERR &quot;E576: &quot;</a>
<a name="ln141"> </a>
<a name="ln142">/// Common prefix for all “system” errors</a>
<a name="ln143">#define SERR &quot;E886: &quot;</a>
<a name="ln144"> </a>
<a name="ln145">/// Common prefix for all “rename” errors</a>
<a name="ln146">#define RNERR &quot;E136: &quot;</a>
<a name="ln147"> </a>
<a name="ln148">/// Common prefix for all ignorable “write” errors</a>
<a name="ln149">#define WERR &quot;E574: &quot;</a>
<a name="ln150"> </a>
<a name="ln151">/// Callback function for add_search_pattern</a>
<a name="ln152">typedef void (*SearchPatternGetter)(SearchPattern *);</a>
<a name="ln153"> </a>
<a name="ln154">/// Possible ShaDa entry types</a>
<a name="ln155">///</a>
<a name="ln156">/// @warning Enum values are part of the API and must not be altered.</a>
<a name="ln157">///</a>
<a name="ln158">/// All values that are not in enum are ignored.</a>
<a name="ln159">typedef enum {</a>
<a name="ln160">  kSDItemUnknown = -1,       ///&lt; Unknown item.</a>
<a name="ln161">  kSDItemMissing = 0,        ///&lt; Missing value. Should never appear in a file.</a>
<a name="ln162">  kSDItemHeader = 1,         ///&lt; Header. Present for debugging purposes.</a>
<a name="ln163">  kSDItemSearchPattern = 2,  ///&lt; Last search pattern (*not* history item).</a>
<a name="ln164">                             ///&lt; Comes from user searches (e.g. when typing</a>
<a name="ln165">                             ///&lt; &quot;/pat&quot;) or :substitute command calls.</a>
<a name="ln166">  kSDItemSubString = 3,      ///&lt; Last substitute replacement string.</a>
<a name="ln167">  kSDItemHistoryEntry = 4,   ///&lt; History item.</a>
<a name="ln168">  kSDItemRegister = 5,       ///&lt; Register.</a>
<a name="ln169">  kSDItemVariable = 6,       ///&lt; Global variable.</a>
<a name="ln170">  kSDItemGlobalMark = 7,     ///&lt; Global mark definition.</a>
<a name="ln171">  kSDItemJump = 8,           ///&lt; Item from jump list.</a>
<a name="ln172">  kSDItemBufferList = 9,     ///&lt; Buffer list.</a>
<a name="ln173">  kSDItemLocalMark = 10,     ///&lt; Buffer-local mark.</a>
<a name="ln174">  kSDItemChange = 11,        ///&lt; Item from buffer change list.</a>
<a name="ln175">#define SHADA_LAST_ENTRY ((uint64_t) kSDItemChange)</a>
<a name="ln176">} ShadaEntryType;</a>
<a name="ln177"> </a>
<a name="ln178">/// Possible results when reading ShaDa file</a>
<a name="ln179">typedef enum {</a>
<a name="ln180">  kSDReadStatusSuccess,    ///&lt; Reading was successful.</a>
<a name="ln181">  kSDReadStatusFinished,   ///&lt; Nothing more to read.</a>
<a name="ln182">  kSDReadStatusReadError,  ///&lt; Failed to read from file.</a>
<a name="ln183">  kSDReadStatusNotShaDa,   ///&lt; Input is most likely not a ShaDa file.</a>
<a name="ln184">  kSDReadStatusMalformed,  ///&lt; Error in the currently read item.</a>
<a name="ln185">} ShaDaReadResult;</a>
<a name="ln186"> </a>
<a name="ln187">/// Possible results of shada_write function.</a>
<a name="ln188">typedef enum {</a>
<a name="ln189">  kSDWriteSuccessfull,   ///&lt; Writing was successful.</a>
<a name="ln190">  kSDWriteReadNotShada,  ///&lt; Writing was successful, but when reading it</a>
<a name="ln191">                         ///&lt; attempted to read file that did not look like</a>
<a name="ln192">                         ///&lt; a ShaDa file.</a>
<a name="ln193">  kSDWriteFailed,        ///&lt; Writing was not successful (e.g. because there</a>
<a name="ln194">                         ///&lt; was no space left on device).</a>
<a name="ln195">  kSDWriteIgnError,      ///&lt; Writing resulted in a error which can be ignored</a>
<a name="ln196">                         ///&lt; (e.g. when trying to dump a function reference or</a>
<a name="ln197">                         ///&lt; self-referencing container in a variable).</a>
<a name="ln198">} ShaDaWriteResult;</a>
<a name="ln199"> </a>
<a name="ln200">/// Flags for shada_read_next_item</a>
<a name="ln201">enum SRNIFlags {</a>
<a name="ln202">  kSDReadHeader = (1 &lt;&lt; kSDItemHeader),  ///&lt; Determines whether header should</a>
<a name="ln203">                                         ///&lt; be read (it is usually ignored).</a>
<a name="ln204">  kSDReadUndisableableData = (</a>
<a name="ln205">      (1 &lt;&lt; kSDItemSearchPattern)</a>
<a name="ln206">      | (1 &lt;&lt; kSDItemSubString)</a>
<a name="ln207">      | (1 &lt;&lt; kSDItemJump)),  ///&lt; Data reading which cannot be disabled by</a>
<a name="ln208">                              ///&lt; &amp;shada or other options except for disabling</a>
<a name="ln209">                              ///&lt; reading ShaDa as a whole.</a>
<a name="ln210">  kSDReadRegisters = (1 &lt;&lt; kSDItemRegister),  ///&lt; Determines whether registers</a>
<a name="ln211">                                              ///&lt; should be read (may only be</a>
<a name="ln212">                                              ///&lt; disabled when writing, but</a>
<a name="ln213">                                              ///&lt; not when reading).</a>
<a name="ln214">  kSDReadHistory = (1 &lt;&lt; kSDItemHistoryEntry),  ///&lt; Determines whether history</a>
<a name="ln215">                                                ///&lt; should be read (can only be</a>
<a name="ln216">                                                ///&lt; disabled by &amp;history).</a>
<a name="ln217">  kSDReadVariables = (1 &lt;&lt; kSDItemVariable),  ///&lt; Determines whether variables</a>
<a name="ln218">                                              ///&lt; should be read (disabled by</a>
<a name="ln219">                                              ///&lt; removing ! from &amp;shada).</a>
<a name="ln220">  kSDReadBufferList = (1 &lt;&lt; kSDItemBufferList),  ///&lt; Determines whether buffer</a>
<a name="ln221">                                                 ///&lt; list should be read</a>
<a name="ln222">                                                 ///&lt; (disabled by removing</a>
<a name="ln223">                                                 ///&lt; % entry from &amp;shada).</a>
<a name="ln224">  kSDReadUnknown = (1 &lt;&lt; (SHADA_LAST_ENTRY + 1)),  ///&lt; Determines whether</a>
<a name="ln225">                                                   ///&lt; unknown items should be</a>
<a name="ln226">                                                   ///&lt; read (usually disabled).</a>
<a name="ln227">  kSDReadGlobalMarks = (1 &lt;&lt; kSDItemGlobalMark),  ///&lt; Determines whether global</a>
<a name="ln228">                                                  ///&lt; marks should be read. Can</a>
<a name="ln229">                                                  ///&lt; only be disabled by</a>
<a name="ln230">                                                  ///&lt; having f0 in &amp;shada when</a>
<a name="ln231">                                                  ///&lt; writing.</a>
<a name="ln232">  kSDReadLocalMarks = (1 &lt;&lt; kSDItemLocalMark),  ///&lt; Determines whether local</a>
<a name="ln233">                                                ///&lt; marks should be read. Can</a>
<a name="ln234">                                                ///&lt; only be disabled by</a>
<a name="ln235">                                                ///&lt; disabling &amp;shada or putting</a>
<a name="ln236">                                                ///&lt; '0 there. Is also used for</a>
<a name="ln237">                                                ///&lt; v:oldfiles.</a>
<a name="ln238">  kSDReadChanges = (1 &lt;&lt; kSDItemChange),  ///&lt; Determines whether change list</a>
<a name="ln239">                                          ///&lt; should be read. Can only be</a>
<a name="ln240">                                          ///&lt; disabled by disabling &amp;shada or</a>
<a name="ln241">                                          ///&lt; putting '0 there.</a>
<a name="ln242">};</a>
<a name="ln243">// Note: SRNIFlags enum name was created only to make it possible to reference</a>
<a name="ln244">// it. This name is not actually used anywhere outside of the documentation.</a>
<a name="ln245"> </a>
<a name="ln246">/// Structure defining a single ShaDa file entry</a>
<a name="ln247">typedef struct {</a>
<a name="ln248">  ShadaEntryType type;</a>
<a name="ln249">  Timestamp timestamp;</a>
<a name="ln250">  union {</a>
<a name="ln251">    Dictionary header;</a>
<a name="ln252">    struct shada_filemark {</a>
<a name="ln253">      char name;</a>
<a name="ln254">      pos_T mark;</a>
<a name="ln255">      char *fname;</a>
<a name="ln256">      dict_T *additional_data;</a>
<a name="ln257">    } filemark;</a>
<a name="ln258">    struct search_pattern {</a>
<a name="ln259">      bool magic;</a>
<a name="ln260">      bool smartcase;</a>
<a name="ln261">      bool has_line_offset;</a>
<a name="ln262">      bool place_cursor_at_end;</a>
<a name="ln263">      int64_t offset;</a>
<a name="ln264">      bool is_last_used;</a>
<a name="ln265">      bool is_substitute_pattern;</a>
<a name="ln266">      bool highlighted;</a>
<a name="ln267">      bool search_backward;</a>
<a name="ln268">      char *pat;</a>
<a name="ln269">      dict_T *additional_data;</a>
<a name="ln270">    } search_pattern;</a>
<a name="ln271">    struct history_item {</a>
<a name="ln272">      uint8_t histtype;</a>
<a name="ln273">      char *string;</a>
<a name="ln274">      char sep;</a>
<a name="ln275">      list_T *additional_elements;</a>
<a name="ln276">    } history_item;</a>
<a name="ln277">    struct reg {  // yankreg_T</a>
<a name="ln278">      char name;</a>
<a name="ln279">      MotionType type;</a>
<a name="ln280">      char **contents;</a>
<a name="ln281">      bool is_unnamed;</a>
<a name="ln282">      size_t contents_size;</a>
<a name="ln283">      size_t width;</a>
<a name="ln284">      dict_T *additional_data;</a>
<a name="ln285">    } reg;</a>
<a name="ln286">    struct global_var {</a>
<a name="ln287">      char *name;</a>
<a name="ln288">      typval_T value;</a>
<a name="ln289">      list_T *additional_elements;</a>
<a name="ln290">    } global_var;</a>
<a name="ln291">    struct {</a>
<a name="ln292">      uint64_t type;</a>
<a name="ln293">      char *contents;</a>
<a name="ln294">      size_t size;</a>
<a name="ln295">    } unknown_item;</a>
<a name="ln296">    struct sub_string {</a>
<a name="ln297">      char *sub;</a>
<a name="ln298">      list_T *additional_elements;</a>
<a name="ln299">    } sub_string;</a>
<a name="ln300">    struct buffer_list {</a>
<a name="ln301">      size_t size;</a>
<a name="ln302">      struct buffer_list_buffer {</a>
<a name="ln303">        pos_T pos;</a>
<a name="ln304">        char *fname;</a>
<a name="ln305">        dict_T *additional_data;</a>
<a name="ln306">      } *buffers;</a>
<a name="ln307">    } buffer_list;</a>
<a name="ln308">  } data;</a>
<a name="ln309">} ShadaEntry;</a>
<a name="ln310"> </a>
<a name="ln311">struct hm_llist_entry;</a>
<a name="ln312"> </a>
<a name="ln313">/// One entry in sized linked list</a>
<a name="ln314">typedef struct hm_llist_entry {</a>
<a name="ln315">  ShadaEntry data;              ///&lt; Entry data.</a>
<a name="ln316">  bool can_free_entry;          ///&lt; True if data can be freed.</a>
<a name="ln317">  struct hm_llist_entry *next;  ///&lt; Pointer to next entry or NULL.</a>
<a name="ln318">  struct hm_llist_entry *prev;  ///&lt; Pointer to previous entry or NULL.</a>
<a name="ln319">} HMLListEntry;</a>
<a name="ln320"> </a>
<a name="ln321">KHASH_MAP_INIT_STR(hmll_entries, HMLListEntry *)</a>
<a name="ln322"> </a>
<a name="ln323">/// Sized linked list structure for history merger</a>
<a name="ln324">typedef struct {</a>
<a name="ln325">  HMLListEntry *entries;  ///&lt; Pointer to the start of the allocated array of</a>
<a name="ln326">                          ///&lt; entries.</a>
<a name="ln327">  HMLListEntry *first;    ///&lt; First entry in the list (is not necessary start</a>
<a name="ln328">                          ///&lt; of the array) or NULL.</a>
<a name="ln329">  HMLListEntry *last;     ///&lt; Last entry in the list or NULL.</a>
<a name="ln330">  HMLListEntry *free_entry;  ///&lt; Last free entry removed by hmll_remove.</a>
<a name="ln331">  HMLListEntry *last_free_entry;  ///&lt; Last unused element in entries array.</a>
<a name="ln332">  size_t size;            ///&lt; Number of allocated entries.</a>
<a name="ln333">  size_t num_entries;     ///&lt; Number of entries already used.</a>
<a name="ln334">  khash_t(hmll_entries) contained_entries;  ///&lt; Hash mapping all history entry</a>
<a name="ln335">                                            ///&lt; strings to corresponding entry</a>
<a name="ln336">                                            ///&lt; pointers.</a>
<a name="ln337">} HMLList;</a>
<a name="ln338"> </a>
<a name="ln339">typedef struct {</a>
<a name="ln340">  HMLList hmll;</a>
<a name="ln341">  bool do_merge;</a>
<a name="ln342">  bool reading;</a>
<a name="ln343">  const void *iter;</a>
<a name="ln344">  ShadaEntry last_hist_entry;</a>
<a name="ln345">  uint8_t history_type;</a>
<a name="ln346">} HistoryMergerState;</a>
<a name="ln347"> </a>
<a name="ln348">/// ShadaEntry structure that knows whether it should be freed</a>
<a name="ln349">typedef struct {</a>
<a name="ln350">  ShadaEntry data;      ///&lt; ShadaEntry data.</a>
<a name="ln351">  bool can_free_entry;  ///&lt; True if entry can be freed.</a>
<a name="ln352">} PossiblyFreedShadaEntry;</a>
<a name="ln353"> </a>
<a name="ln354">/// Structure that holds one file marks.</a>
<a name="ln355">typedef struct {</a>
<a name="ln356">  PossiblyFreedShadaEntry marks[NLOCALMARKS];  ///&lt; All file marks.</a>
<a name="ln357">  PossiblyFreedShadaEntry changes[JUMPLISTSIZE];  ///&lt; All file changes.</a>
<a name="ln358">  size_t changes_size;  ///&lt; Number of changes occupied.</a>
<a name="ln359">  ShadaEntry *additional_marks;  ///&lt; All marks with unknown names.</a>
<a name="ln360">  size_t additional_marks_size;  ///&lt; Size of the additional_marks array.</a>
<a name="ln361">  Timestamp greatest_timestamp;  ///&lt; Greatest timestamp among marks.</a>
<a name="ln362">} FileMarks;</a>
<a name="ln363"> </a>
<a name="ln364">KHASH_MAP_INIT_STR(file_marks, FileMarks)</a>
<a name="ln365"> </a>
<a name="ln366">/// State structure used by shada_write</a>
<a name="ln367">///</a>
<a name="ln368">/// Before actually writing most of the data is read to this structure.</a>
<a name="ln369">typedef struct {</a>
<a name="ln370">  HistoryMergerState hms[HIST_COUNT];  ///&lt; Structures for history merging.</a>
<a name="ln371">  PossiblyFreedShadaEntry global_marks[NMARKS];  ///&lt; Named global marks.</a>
<a name="ln372">  PossiblyFreedShadaEntry numbered_marks[EXTRA_MARKS];  ///&lt; Numbered marks.</a>
<a name="ln373">  PossiblyFreedShadaEntry registers[NUM_SAVED_REGISTERS];  ///&lt; All registers.</a>
<a name="ln374">  PossiblyFreedShadaEntry jumps[JUMPLISTSIZE];  ///&lt; All dumped jumps.</a>
<a name="ln375">  size_t jumps_size;  ///&lt; Number of jumps occupied.</a>
<a name="ln376">  PossiblyFreedShadaEntry search_pattern;  ///&lt; Last search pattern.</a>
<a name="ln377">  PossiblyFreedShadaEntry sub_search_pattern;  ///&lt; Last s/ search pattern.</a>
<a name="ln378">  PossiblyFreedShadaEntry replacement;  ///&lt; Last s// replacement string.</a>
<a name="ln379">  khash_t(strset) dumped_variables;  ///&lt; Names of already dumped variables.</a>
<a name="ln380">  khash_t(file_marks) file_marks;  ///&lt; All file marks.</a>
<a name="ln381">} WriteMergerState;</a>
<a name="ln382"> </a>
<a name="ln383">struct sd_read_def;</a>
<a name="ln384"> </a>
<a name="ln385">/// Function used to close files defined by ShaDaReadDef</a>
<a name="ln386">typedef void (*ShaDaReadCloser)(struct sd_read_def *const sd_reader)</a>
<a name="ln387">  REAL_FATTR_NONNULL_ALL;</a>
<a name="ln388"> </a>
<a name="ln389">/// Function used to read ShaDa files</a>
<a name="ln390">typedef ptrdiff_t (*ShaDaFileReader)(struct sd_read_def *const sd_reader,</a>
<a name="ln391">                                     void *const dest,</a>
<a name="ln392">                                     const size_t size)</a>
<a name="ln393">  REAL_FATTR_NONNULL_ALL REAL_FATTR_WARN_UNUSED_RESULT;</a>
<a name="ln394"> </a>
<a name="ln395">/// Function used to skip in ShaDa files</a>
<a name="ln396">typedef int (*ShaDaFileSkipper)(struct sd_read_def *const sd_reader,</a>
<a name="ln397">                                const size_t offset)</a>
<a name="ln398">  REAL_FATTR_NONNULL_ALL REAL_FATTR_WARN_UNUSED_RESULT;</a>
<a name="ln399"> </a>
<a name="ln400">/// Structure containing necessary pointers for reading ShaDa files</a>
<a name="ln401">typedef struct sd_read_def {</a>
<a name="ln402">  ShaDaFileReader read;   ///&lt; Reader function.</a>
<a name="ln403">  ShaDaReadCloser close;  ///&lt; Close function.</a>
<a name="ln404">  ShaDaFileSkipper skip;  ///&lt; Function used to skip some bytes.</a>
<a name="ln405">  void *cookie;           ///&lt; Data describing object read from.</a>
<a name="ln406">  bool eof;               ///&lt; True if reader reached end of file.</a>
<a name="ln407">  const char *error;      ///&lt; Error message in case of error.</a>
<a name="ln408">  uintmax_t fpos;         ///&lt; Current position (amount of bytes read since</a>
<a name="ln409">                          ///&lt; reader structure initialization). May overflow.</a>
<a name="ln410">} ShaDaReadDef;</a>
<a name="ln411"> </a>
<a name="ln412">struct sd_write_def;</a>
<a name="ln413"> </a>
<a name="ln414">/// Function used to close files defined by ShaDaWriteDef</a>
<a name="ln415">typedef void (*ShaDaWriteCloser)(struct sd_write_def *const sd_writer)</a>
<a name="ln416">  REAL_FATTR_NONNULL_ALL;</a>
<a name="ln417"> </a>
<a name="ln418">/// Function used to write ShaDa files</a>
<a name="ln419">typedef ptrdiff_t (*ShaDaFileWriter)(struct sd_write_def *const sd_writer,</a>
<a name="ln420">                                     const void *const src,</a>
<a name="ln421">                                     const size_t size)</a>
<a name="ln422">  REAL_FATTR_NONNULL_ALL REAL_FATTR_WARN_UNUSED_RESULT;</a>
<a name="ln423"> </a>
<a name="ln424">/// Structure containing necessary pointers for writing ShaDa files</a>
<a name="ln425">typedef struct sd_write_def {</a>
<a name="ln426">  ShaDaFileWriter write;   ///&lt; Writer function.</a>
<a name="ln427">  ShaDaWriteCloser close;  ///&lt; Close function.</a>
<a name="ln428">  void *cookie;            ///&lt; Data describing object written to.</a>
<a name="ln429">  const char *error;       ///&lt; Error message in case of error.</a>
<a name="ln430">} ShaDaWriteDef;</a>
<a name="ln431"> </a>
<a name="ln432">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln433"># include &quot;shada.c.generated.h&quot;</a>
<a name="ln434">#endif</a>
<a name="ln435"> </a>
<a name="ln436">#define DEF_SDE(name, attr, ...) \</a>
<a name="ln437">    [kSDItem##name] = { \</a>
<a name="ln438">      .timestamp = 0, \</a>
<a name="ln439">      .type = kSDItem##name, \</a>
<a name="ln440">      .data = { \</a>
<a name="ln441">        .attr = { __VA_ARGS__ } \</a>
<a name="ln442">      } \</a>
<a name="ln443">    }</a>
<a name="ln444">#define DEFAULT_POS { 1, 0, 0 }</a>
<a name="ln445">static const pos_T default_pos = DEFAULT_POS;</a>
<a name="ln446">static const ShadaEntry sd_default_values[] = {</a>
<a name="ln447">  [kSDItemMissing] = { .type = kSDItemMissing, .timestamp = 0 },</a>
<a name="ln448">  DEF_SDE(Header, header, .size = 0),</a>
<a name="ln449">  DEF_SDE(SearchPattern, search_pattern,</a>
<a name="ln450">          .magic = true,</a>
<a name="ln451">          .smartcase = false,</a>
<a name="ln452">          .has_line_offset = false,</a>
<a name="ln453">          .place_cursor_at_end = false,</a>
<a name="ln454">          .offset = 0,</a>
<a name="ln455">          .is_last_used = true,</a>
<a name="ln456">          .is_substitute_pattern = false,</a>
<a name="ln457">          .highlighted = false,</a>
<a name="ln458">          .search_backward = false,</a>
<a name="ln459">          .pat = NULL,</a>
<a name="ln460">          .additional_data = NULL),</a>
<a name="ln461">  DEF_SDE(SubString, sub_string, .sub = NULL, .additional_elements = NULL),</a>
<a name="ln462">  DEF_SDE(HistoryEntry, history_item,</a>
<a name="ln463">          .histtype = HIST_CMD,</a>
<a name="ln464">          .string = NULL,</a>
<a name="ln465">          .sep = NUL,</a>
<a name="ln466">          .additional_elements = NULL),</a>
<a name="ln467">  DEF_SDE(Register, reg,</a>
<a name="ln468">          .name = NUL,</a>
<a name="ln469">          .type = kMTCharWise,</a>
<a name="ln470">          .contents = NULL,</a>
<a name="ln471">          .contents_size = 0,</a>
<a name="ln472">          .is_unnamed = false,</a>
<a name="ln473">          .width = 0,</a>
<a name="ln474">          .additional_data = NULL),</a>
<a name="ln475">  DEF_SDE(Variable, global_var,</a>
<a name="ln476">          .name = NULL,</a>
<a name="ln477">          .value = {</a>
<a name="ln478">            .v_type = VAR_UNKNOWN,</a>
<a name="ln479">            .vval = { .v_string = NULL }</a>
<a name="ln480">          },</a>
<a name="ln481">          .additional_elements = NULL),</a>
<a name="ln482">  DEF_SDE(GlobalMark, filemark,</a>
<a name="ln483">          .name = '&quot;',</a>
<a name="ln484">          .mark = DEFAULT_POS,</a>
<a name="ln485">          .fname = NULL,</a>
<a name="ln486">          .additional_data = NULL),</a>
<a name="ln487">  DEF_SDE(Jump, filemark,</a>
<a name="ln488">          .name = NUL,</a>
<a name="ln489">          .mark = DEFAULT_POS,</a>
<a name="ln490">          .fname = NULL,</a>
<a name="ln491">          .additional_data = NULL),</a>
<a name="ln492">  DEF_SDE(BufferList, buffer_list,</a>
<a name="ln493">          .size = 0,</a>
<a name="ln494">          .buffers = NULL),</a>
<a name="ln495">  DEF_SDE(LocalMark, filemark,</a>
<a name="ln496">          .name = '&quot;',</a>
<a name="ln497">          .mark = DEFAULT_POS,</a>
<a name="ln498">          .fname = NULL,</a>
<a name="ln499">          .additional_data = NULL),</a>
<a name="ln500">  DEF_SDE(Change, filemark,</a>
<a name="ln501">          .name = NUL,</a>
<a name="ln502">          .mark = DEFAULT_POS,</a>
<a name="ln503">          .fname = NULL,</a>
<a name="ln504">          .additional_data = NULL),</a>
<a name="ln505">};</a>
<a name="ln506">#undef DEFAULT_POS</a>
<a name="ln507">#undef DEF_SDE</a>
<a name="ln508"> </a>
<a name="ln509">/// Initialize new linked list</a>
<a name="ln510">///</a>
<a name="ln511">/// @param[out]  hmll       List to initialize.</a>
<a name="ln512">/// @param[in]   size       Maximum size of the list.</a>
<a name="ln513">static inline void hmll_init(HMLList *const hmll, const size_t size)</a>
<a name="ln514">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln515">{</a>
<a name="ln516">  *hmll = (HMLList) {</a>
<a name="ln517">    .entries = xcalloc(size, sizeof(hmll-&gt;entries[0])),</a>
<a name="ln518">    .first = NULL,</a>
<a name="ln519">    .last = NULL,</a>
<a name="ln520">    .free_entry = NULL,</a>
<a name="ln521">    .size = size,</a>
<a name="ln522">    .num_entries = 0,</a>
<a name="ln523">    .contained_entries = KHASH_EMPTY_TABLE(hmll_entries),</a>
<a name="ln524">  };</a>
<a name="ln525">  hmll-&gt;last_free_entry = hmll-&gt;entries;</a>
<a name="ln526">}</a>
<a name="ln527"> </a>
<a name="ln528">/// Iterate over HMLList in forward direction</a>
<a name="ln529">///</a>
<a name="ln530">/// @param  hmll       Pointer to the list.</a>
<a name="ln531">/// @param  cur_entry  Name of the variable to iterate over.</a>
<a name="ln532">/// @param  code       Code to execute on each iteration.</a>
<a name="ln533">///</a>
<a name="ln534">/// @return `for` cycle header (use `HMLL_FORALL(hmll, cur_entry) {body}`).</a>
<a name="ln535">#define HMLL_FORALL(hmll, cur_entry, code) \</a>
<a name="ln536">    for (HMLListEntry *cur_entry = (hmll)-&gt;first; cur_entry != NULL; \</a>
<a name="ln537">         cur_entry = cur_entry-&gt;next) { \</a>
<a name="ln538">      code \</a>
<a name="ln539">    } \</a>
<a name="ln540"> </a>
<a name="ln541">/// Remove entry from the linked list</a>
<a name="ln542">///</a>
<a name="ln543">/// @param  hmll        List to remove from.</a>
<a name="ln544">/// @param  hmll_entry  Entry to remove.</a>
<a name="ln545">static inline void hmll_remove(HMLList *const hmll,</a>
<a name="ln546">                               HMLListEntry *const hmll_entry)</a>
<a name="ln547">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln548">{</a>
<a name="ln549">  if (hmll_entry == hmll-&gt;last_free_entry - 1) {</a>
<a name="ln550">    hmll-&gt;last_free_entry--;</a>
<a name="ln551">  } else {</a>
<a name="ln552">    assert(hmll-&gt;free_entry == NULL);</a>
<a name="ln553">    hmll-&gt;free_entry = hmll_entry;</a>
<a name="ln554">  }</a>
<a name="ln555">  const khiter_t k = kh_get(hmll_entries, &amp;hmll-&gt;contained_entries,</a>
<a name="ln556">                            hmll_entry-&gt;data.data.history_item.string);</a>
<a name="ln557">  assert(k != kh_end(&amp;hmll-&gt;contained_entries));</a>
<a name="ln558">  kh_del(hmll_entries, &amp;hmll-&gt;contained_entries, k);</a>
<a name="ln559">  if (hmll_entry-&gt;next == NULL) {</a>
<a name="ln560">    hmll-&gt;last = hmll_entry-&gt;prev;</a>
<a name="ln561">  } else {</a>
<a name="ln562">    hmll_entry-&gt;next-&gt;prev = hmll_entry-&gt;prev;</a>
<a name="ln563">  }</a>
<a name="ln564">  if (hmll_entry-&gt;prev == NULL) {</a>
<a name="ln565">    hmll-&gt;first = hmll_entry-&gt;next;</a>
<a name="ln566">  } else {</a>
<a name="ln567">    hmll_entry-&gt;prev-&gt;next = hmll_entry-&gt;next;</a>
<a name="ln568">  }</a>
<a name="ln569">  hmll-&gt;num_entries--;</a>
<a name="ln570">  if (hmll_entry-&gt;can_free_entry) {</a>
<a name="ln571">    shada_free_shada_entry(&amp;hmll_entry-&gt;data);</a>
<a name="ln572">  }</a>
<a name="ln573">}</a>
<a name="ln574"> </a>
<a name="ln575"> </a>
<a name="ln576">/// Insert entry to the linked list</a>
<a name="ln577">///</a>
<a name="ln578">/// @param[out]  hmll            List to insert to.</a>
<a name="ln579">/// @param[in]   hmll_entry      Entry to insert after or NULL if it is needed</a>
<a name="ln580">///                              to insert at the first entry.</a>
<a name="ln581">/// @param[in]   data            Data to insert.</a>
<a name="ln582">/// @param[in]   can_free_entry  True if data can be freed.</a>
<a name="ln583">static inline void hmll_insert(HMLList *const hmll,</a>
<a name="ln584">                               HMLListEntry *hmll_entry,</a>
<a name="ln585">                               const ShadaEntry data,</a>
<a name="ln586">                               const bool can_free_entry)</a>
<a name="ln587">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln588">{</a>
<a name="ln589">  if (hmll-&gt;num_entries == hmll-&gt;size) {</a>
<a name="ln590">    if (hmll_entry == hmll-&gt;first) {</a>
<a name="ln591">      hmll_entry = NULL;</a>
<a name="ln592">    }</a>
<a name="ln593">    assert(hmll-&gt;first != NULL);</a>
<a name="ln594">    hmll_remove(hmll, hmll-&gt;first);</a>
<a name="ln595">  }</a>
<a name="ln596">  HMLListEntry *target_entry;</a>
<a name="ln597">  if (hmll-&gt;free_entry == NULL) {</a>
<a name="ln598">    assert((size_t) (hmll-&gt;last_free_entry - hmll-&gt;entries)</a>
<a name="ln599">           == hmll-&gt;num_entries);</a>
<a name="ln600">    target_entry = hmll-&gt;last_free_entry++;</a>
<a name="ln601">  } else {</a>
<a name="ln602">    assert((size_t) (hmll-&gt;last_free_entry - hmll-&gt;entries) - 1</a>
<a name="ln603">           == hmll-&gt;num_entries);</a>
<a name="ln604">    target_entry = hmll-&gt;free_entry;</a>
<a name="ln605">    hmll-&gt;free_entry = NULL;</a>
<a name="ln606">  }</a>
<a name="ln607">  target_entry-&gt;data = data;</a>
<a name="ln608">  target_entry-&gt;can_free_entry = can_free_entry;</a>
<a name="ln609">  int kh_ret;</a>
<a name="ln610">  const khiter_t k = kh_put(hmll_entries, &amp;hmll-&gt;contained_entries,</a>
<a name="ln611">                            data.data.history_item.string, &amp;kh_ret);</a>
<a name="ln612">  if (kh_ret &gt; 0) {</a>
<a name="ln613">    kh_val(&amp;hmll-&gt;contained_entries, k) = target_entry;</a>
<a name="ln614">  }</a>
<a name="ln615">  hmll-&gt;num_entries++;</a>
<a name="ln616">  target_entry-&gt;prev = hmll_entry;</a>
<a name="ln617">  if (hmll_entry == NULL) {</a>
<a name="ln618">    target_entry-&gt;next = hmll-&gt;first;</a>
<a name="ln619">    hmll-&gt;first = target_entry;</a>
<a name="ln620">  } else {</a>
<a name="ln621">    target_entry-&gt;next = hmll_entry-&gt;next;</a>
<a name="ln622">    hmll_entry-&gt;next = target_entry;</a>
<a name="ln623">  }</a>
<a name="ln624">  if (target_entry-&gt;next == NULL) {</a>
<a name="ln625">    hmll-&gt;last = target_entry;</a>
<a name="ln626">  } else {</a>
<a name="ln627">    target_entry-&gt;next-&gt;prev = target_entry;</a>
<a name="ln628">  }</a>
<a name="ln629">}</a>
<a name="ln630"> </a>
<a name="ln631">/// Iterate over HMLList in backward direction</a>
<a name="ln632">///</a>
<a name="ln633">/// @param  hmll       Pointer to the list.</a>
<a name="ln634">/// @param  cur_entry  Name of the variable to iterate over, must be already</a>
<a name="ln635">///                    defined.</a>
<a name="ln636">/// @param  code       Code to execute on each iteration.</a>
<a name="ln637">///</a>
<a name="ln638">/// @return `for` cycle header (use `HMLL_FORALL(hmll, cur_entry) {body}`).</a>
<a name="ln639">#define HMLL_ITER_BACK(hmll, cur_entry, code) \</a>
<a name="ln640">    for (cur_entry = (hmll)-&gt;last; cur_entry != NULL; \</a>
<a name="ln641">         cur_entry = cur_entry-&gt;prev) { \</a>
<a name="ln642">      code \</a>
<a name="ln643">    }</a>
<a name="ln644"> </a>
<a name="ln645">/// Free linked list</a>
<a name="ln646">///</a>
<a name="ln647">/// @param[in]  hmll  List to free.</a>
<a name="ln648">static inline void hmll_dealloc(HMLList *const hmll)</a>
<a name="ln649">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln650">{</a>
<a name="ln651">  kh_dealloc(hmll_entries, &amp;hmll-&gt;contained_entries);</a>
<a name="ln652">  xfree(hmll-&gt;entries);</a>
<a name="ln653">}</a>
<a name="ln654"> </a>
<a name="ln655">/// Wrapper for reading from file descriptors</a>
<a name="ln656">///</a>
<a name="ln657">/// @return -1 or number of bytes read.</a>
<a name="ln658">static ptrdiff_t read_file(ShaDaReadDef *const sd_reader, void *const dest,</a>
<a name="ln659">                           const size_t size)</a>
<a name="ln660">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln661">{</a>
<a name="ln662">  const ptrdiff_t ret = file_read(sd_reader-&gt;cookie, dest, size);</a>
<a name="ln663">  sd_reader-&gt;eof = file_eof(sd_reader-&gt;cookie);</a>
<a name="ln664">  if (ret &lt; 0) {</a>
<a name="ln665">    sd_reader-&gt;error = os_strerror((int)ret);</a>
<a name="ln666">    return -1;</a>
<a name="ln667">  }</a>
<a name="ln668">  sd_reader-&gt;fpos += (size_t)ret;</a>
<a name="ln669">  return ret;</a>
<a name="ln670">}</a>
<a name="ln671"> </a>
<a name="ln672">/// Read one character</a>
<a name="ln673">static int read_char(ShaDaReadDef *const sd_reader)</a>
<a name="ln674">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln675">{</a>
<a name="ln676">  uint8_t ret;</a>
<a name="ln677">  ptrdiff_t read_bytes = sd_reader-&gt;read(sd_reader, &amp;ret, 1);</a>
<a name="ln678">  if (read_bytes != 1) {</a>
<a name="ln679">    return EOF;</a>
<a name="ln680">  }</a>
<a name="ln681">  return (int) ret;</a>
<a name="ln682">}</a>
<a name="ln683"> </a>
<a name="ln684">/// Wrapper for writing to file descriptors</a>
<a name="ln685">///</a>
<a name="ln686">/// @return -1 or number of bytes written.</a>
<a name="ln687">static ptrdiff_t write_file(ShaDaWriteDef *const sd_writer,</a>
<a name="ln688">                            const void *const dest,</a>
<a name="ln689">                            const size_t size)</a>
<a name="ln690">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln691">{</a>
<a name="ln692">  const ptrdiff_t ret = file_write(sd_writer-&gt;cookie, dest, size);</a>
<a name="ln693">  if (ret &lt; 0) {</a>
<a name="ln694">    sd_writer-&gt;error = os_strerror((int)ret);</a>
<a name="ln695">    return -1;</a>
<a name="ln696">  }</a>
<a name="ln697">  return ret;</a>
<a name="ln698">}</a>
<a name="ln699"> </a>
<a name="ln700">/// Wrapper for closing file descriptors opened for reading</a>
<a name="ln701">static void close_sd_reader(ShaDaReadDef *const sd_reader)</a>
<a name="ln702">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln703">{</a>
<a name="ln704">  close_file(sd_reader-&gt;cookie);</a>
<a name="ln705">}</a>
<a name="ln706"> </a>
<a name="ln707">/// Wrapper for closing file descriptors opened for writing</a>
<a name="ln708">static void close_sd_writer(ShaDaWriteDef *const sd_writer)</a>
<a name="ln709">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln710">{</a>
<a name="ln711">  close_file(sd_writer-&gt;cookie);</a>
<a name="ln712">}</a>
<a name="ln713"> </a>
<a name="ln714">/// Wrapper for read that reads to IObuff and ignores bytes read</a>
<a name="ln715">///</a>
<a name="ln716">/// Used for skipping.</a>
<a name="ln717">///</a>
<a name="ln718">/// @param[in,out]  sd_reader  File read.</a>
<a name="ln719">/// @param[in]      offset     Amount of bytes to skip.</a>
<a name="ln720">///</a>
<a name="ln721">/// @return FAIL in case of failure, OK in case of success. May set</a>
<a name="ln722">///         sd_reader-&gt;eof or sd_reader-&gt;error.</a>
<a name="ln723">static int sd_reader_skip_read(ShaDaReadDef *const sd_reader,</a>
<a name="ln724">                               const size_t offset)</a>
<a name="ln725">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln726">{</a>
<a name="ln727">  const ptrdiff_t skip_bytes = file_skip(sd_reader-&gt;cookie, offset);</a>
<a name="ln728">  if (skip_bytes &lt; 0) {</a>
<a name="ln729">    sd_reader-&gt;error = os_strerror((int)skip_bytes);</a>
<a name="ln730">    return FAIL;</a>
<a name="ln731">  } else if (skip_bytes != (ptrdiff_t)offset) {</a>
<a name="ln732">    assert(skip_bytes &lt; (ptrdiff_t)offset);</a>
<a name="ln733">    sd_reader-&gt;eof = file_eof(sd_reader-&gt;cookie);</a>
<a name="ln734">    if (!sd_reader-&gt;eof) {</a>
<a name="ln735">      sd_reader-&gt;error = _(&quot;too few bytes read&quot;);</a>
<a name="ln736">    }</a>
<a name="ln737">    return FAIL;</a>
<a name="ln738">  }</a>
<a name="ln739">  sd_reader-&gt;fpos += (size_t)skip_bytes;</a>
<a name="ln740">  return OK;</a>
<a name="ln741">}</a>
<a name="ln742"> </a>
<a name="ln743">/// Wrapper for read that can be used when lseek cannot be used</a>
<a name="ln744">///</a>
<a name="ln745">/// E.g. when trying to read from a pipe.</a>
<a name="ln746">///</a>
<a name="ln747">/// @param[in,out]  sd_reader  File read.</a>
<a name="ln748">/// @param[in]      offset     Amount of bytes to skip.</a>
<a name="ln749">///</a>
<a name="ln750">/// @return kSDReadStatusReadError, kSDReadStatusNotShaDa or</a>
<a name="ln751">///         kSDReadStatusSuccess.</a>
<a name="ln752">static ShaDaReadResult sd_reader_skip(ShaDaReadDef *const sd_reader,</a>
<a name="ln753">                                      const size_t offset)</a>
<a name="ln754">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln755">{</a>
<a name="ln756">  if (sd_reader-&gt;skip(sd_reader, offset) != OK) {</a>
<a name="ln757">    if (sd_reader-&gt;error != NULL) {</a>
<a name="ln758">      emsgf(_(SERR &quot;System error while skipping in ShaDa file: %s&quot;),</a>
<a name="ln759">            sd_reader-&gt;error);</a>
<a name="ln760">      return kSDReadStatusReadError;</a>
<a name="ln761">    } else if (sd_reader-&gt;eof) {</a>
<a name="ln762">      emsgf(_(RCERR &quot;Error while reading ShaDa file: &quot;</a>
<a name="ln763">              &quot;last entry specified that it occupies %&quot; PRIu64 &quot; bytes, &quot;</a>
<a name="ln764">              &quot;but file ended earlier&quot;),</a>
<a name="ln765">            (uint64_t) offset);</a>
<a name="ln766">      return kSDReadStatusNotShaDa;</a>
<a name="ln767">    }</a>
<a name="ln768">    abort();</a>
<a name="ln769">  }</a>
<a name="ln770">  return kSDReadStatusSuccess;</a>
<a name="ln771">}</a>
<a name="ln772"> </a>
<a name="ln773">/// Open ShaDa file for reading</a>
<a name="ln774">///</a>
<a name="ln775">/// @param[in]   fname      File name to open.</a>
<a name="ln776">/// @param[out]  sd_reader  Location where reader structure will be saved.</a>
<a name="ln777">///</a>
<a name="ln778">/// @return libuv error in case of error, 0 otherwise.</a>
<a name="ln779">static int open_shada_file_for_reading(const char *const fname,</a>
<a name="ln780">                                       ShaDaReadDef *sd_reader)</a>
<a name="ln781">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln782">{</a>
<a name="ln783">  int error;</a>
<a name="ln784"> </a>
<a name="ln785">  *sd_reader = (ShaDaReadDef) {</a>
<a name="ln786">    .read = &amp;read_file,</a>
<a name="ln787">    .close = &amp;close_sd_reader,</a>
<a name="ln788">    .skip = &amp;sd_reader_skip_read,</a>
<a name="ln789">    .error = NULL,</a>
<a name="ln790">    .eof = false,</a>
<a name="ln791">    .fpos = 0,</a>
<a name="ln792">    .cookie = file_open_new(&amp;error, fname, kFileReadOnly, 0),</a>
<a name="ln793">  };</a>
<a name="ln794">  if (sd_reader-&gt;cookie == NULL) {</a>
<a name="ln795">    return error;</a>
<a name="ln796">  }</a>
<a name="ln797"> </a>
<a name="ln798">  assert(STRCMP(p_enc, &quot;utf-8&quot;) == 0);</a>
<a name="ln799"> </a>
<a name="ln800">  return 0;</a>
<a name="ln801">}</a>
<a name="ln802"> </a>
<a name="ln803">/// Wrapper for closing file descriptors</a>
<a name="ln804">static void close_file(void *cookie)</a>
<a name="ln805">{</a>
<a name="ln806">  const int error = file_free(cookie, !!p_fs);</a>
<a name="ln807">  if (error != 0) {</a>
<a name="ln808">    emsgf(_(SERR &quot;System error while closing ShaDa file: %s&quot;),</a>
<a name="ln809">          os_strerror(error));</a>
<a name="ln810">  }</a>
<a name="ln811">}</a>
<a name="ln812"> </a>
<a name="ln813">/// Check whether buffer is in the given set</a>
<a name="ln814">///</a>
<a name="ln815">/// @param[in]  set  Set to check within.</a>
<a name="ln816">/// @param[in]  buf  Buffer to find.</a>
<a name="ln817">///</a>
<a name="ln818">/// @return true or false.</a>
<a name="ln819">static inline bool in_bufset(const khash_t(bufset) *const set, const buf_T *buf)</a>
<a name="ln820">  FUNC_ATTR_PURE</a>
<a name="ln821">{</a>
<a name="ln822">  return kh_get(bufset, set, (uintptr_t) buf) != kh_end(set);</a>
<a name="ln823">}</a>
<a name="ln824"> </a>
<a name="ln825">/// Check whether string is in the given set</a>
<a name="ln826">///</a>
<a name="ln827">/// @param[in]  set  Set to check within.</a>
<a name="ln828">/// @param[in]  buf  Buffer to find.</a>
<a name="ln829">///</a>
<a name="ln830">/// @return true or false.</a>
<a name="ln831">static inline bool in_strset(const khash_t(strset) *const set, char *str)</a>
<a name="ln832">  FUNC_ATTR_PURE</a>
<a name="ln833">{</a>
<a name="ln834">  return kh_get(strset, set, str) != kh_end(set);</a>
<a name="ln835">}</a>
<a name="ln836"> </a>
<a name="ln837">/// Msgpack callback for writing to ShaDaWriteDef*</a>
<a name="ln838">static int msgpack_sd_writer_write(void *data, const char *buf, size_t len)</a>
<a name="ln839">{</a>
<a name="ln840">  ShaDaWriteDef *const sd_writer = (ShaDaWriteDef *) data;</a>
<a name="ln841">  ptrdiff_t written_bytes = sd_writer-&gt;write(sd_writer, buf, len);</a>
<a name="ln842">  if (written_bytes == -1) {</a>
<a name="ln843">    emsgf(_(SERR &quot;System error while writing ShaDa file: %s&quot;),</a>
<a name="ln844">          sd_writer-&gt;error);</a>
<a name="ln845">    return -1;</a>
<a name="ln846">  }</a>
<a name="ln847">  return 0;</a>
<a name="ln848">}</a>
<a name="ln849"> </a>
<a name="ln850">/// Check whether writing to shada file was disabled (&quot;-i NONE&quot; or &quot;--clean&quot;).</a>
<a name="ln851">///</a>
<a name="ln852">/// @return true if it was disabled, false otherwise.</a>
<a name="ln853">static bool shada_disabled(void)</a>
<a name="ln854">  FUNC_ATTR_PURE</a>
<a name="ln855">{</a>
<a name="ln856">  return strequal(p_shadafile, &quot;NONE&quot;);</a>
<a name="ln857">}</a>
<a name="ln858"> </a>
<a name="ln859">/// Read ShaDa file</a>
<a name="ln860">///</a>
<a name="ln861">/// @param[in]  file   File to read or NULL to use default name.</a>
<a name="ln862">/// @param[in]  flags  Flags, see ShaDaReadFileFlags enum.</a>
<a name="ln863">///</a>
<a name="ln864">/// @return FAIL if reading failed for some reason and OK otherwise.</a>
<a name="ln865">static int shada_read_file(const char *const file, const int flags)</a>
<a name="ln866">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln867">{</a>
<a name="ln868">  if (shada_disabled()) {</a>
<a name="ln869">    return FAIL;</a>
<a name="ln870">  }</a>
<a name="ln871"> </a>
<a name="ln872">  char *const fname = shada_filename(file);</a>
<a name="ln873"> </a>
<a name="ln874">  ShaDaReadDef sd_reader;</a>
<a name="ln875">  const int of_ret = open_shada_file_for_reading(fname, &amp;sd_reader);</a>
<a name="ln876"> </a>
<a name="ln877">  if (p_verbose &gt; 0) {</a>
<a name="ln878">    verbose_enter();</a>
<a name="ln879">    smsg(_(&quot;Reading ShaDa file \&quot;%s\&quot;%s%s%s%s&quot;),</a>
<a name="ln880">         fname,</a>
<a name="ln881">         (flags &amp; kShaDaWantInfo) ? _(&quot; info&quot;) : &quot;&quot;,</a>
<a name="ln882">         (flags &amp; kShaDaWantMarks) ? _(&quot; marks&quot;) : &quot;&quot;,</a>
<a name="ln883">         (flags &amp; kShaDaGetOldfiles) ? _(&quot; oldfiles&quot;) : &quot;&quot;,</a>
<a name="ln884">         of_ret != 0 ? _(&quot; FAILED&quot;) : &quot;&quot;);</a>
<a name="ln885">    verbose_leave();</a>
<a name="ln886">  }</a>
<a name="ln887"> </a>
<a name="ln888">  if (of_ret != 0) {</a>
<a name="ln889">    if (of_ret != UV_ENOENT || (flags &amp; kShaDaMissingError)) {</a>
<a name="ln890">      emsgf(_(SERR &quot;System error while opening ShaDa file %s for reading: %s&quot;),</a>
<a name="ln891">            fname, os_strerror(of_ret));</a>
<a name="ln892">    }</a>
<a name="ln893">    xfree(fname);</a>
<a name="ln894">    return FAIL;</a>
<a name="ln895">  }</a>
<a name="ln896">  xfree(fname);</a>
<a name="ln897"> </a>
<a name="ln898">  shada_read(&amp;sd_reader, flags);</a>
<a name="ln899">  sd_reader.close(&amp;sd_reader);</a>
<a name="ln900"> </a>
<a name="ln901">  return OK;</a>
<a name="ln902">}</a>
<a name="ln903"> </a>
<a name="ln904">/// Wrapper for hist_iter() function which produces ShadaEntry values</a>
<a name="ln905">///</a>
<a name="ln906">/// @param[in]   iter          Current iteration state.</a>
<a name="ln907">/// @param[in]   history_type  Type of the history (HIST_*).</a>
<a name="ln908">/// @param[in]   zero          If true, then item is removed from instance</a>
<a name="ln909">///                            memory upon reading.</a>
<a name="ln910">/// @param[out]  hist          Location where iteration results should be saved.</a>
<a name="ln911">///</a>
<a name="ln912">/// @return Next iteration state.</a>
<a name="ln913">static const void *shada_hist_iter(const void *const iter,</a>
<a name="ln914">                                   const uint8_t history_type,</a>
<a name="ln915">                                   const bool zero,</a>
<a name="ln916">                                   ShadaEntry *const hist)</a>
<a name="ln917">  FUNC_ATTR_NONNULL_ARG(4) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln918">{</a>
<a name="ln919">  histentry_T hist_he;</a>
<a name="ln920">  const void *const ret = hist_iter(iter, history_type, zero, &amp;hist_he);</a>
<a name="ln921">  if (hist_he.hisstr == NULL) {</a>
<a name="ln922">    *hist = (ShadaEntry) { .type = kSDItemMissing };</a>
<a name="ln923">  } else {</a>
<a name="ln924">    *hist = (ShadaEntry) {</a>
<a name="ln925">      .type = kSDItemHistoryEntry,</a>
<a name="ln926">      .timestamp = hist_he.timestamp,</a>
<a name="ln927">      .data = {</a>
<a name="ln928">        .history_item = {</a>
<a name="ln929">          .histtype = history_type,</a>
<a name="ln930">          .string = (char *) hist_he.hisstr,</a>
<a name="ln931">          .sep = (char) (history_type == HIST_SEARCH</a>
<a name="ln932">                         ? (char) hist_he.hisstr[STRLEN(hist_he.hisstr) + 1]</a>
<a name="ln933">                         : 0),</a>
<a name="ln934">          .additional_elements = hist_he.additional_elements,</a>
<a name="ln935">        }</a>
<a name="ln936">      }</a>
<a name="ln937">    };</a>
<a name="ln938">  }</a>
<a name="ln939">  return ret;</a>
<a name="ln940">}</a>
<a name="ln941"> </a>
<a name="ln942">/// Insert history entry</a>
<a name="ln943">///</a>
<a name="ln944">/// Inserts history entry at the end of the ring buffer (may insert earlier</a>
<a name="ln945">/// according to the timestamp). If entry was already in the ring buffer</a>
<a name="ln946">/// existing entry will be removed unless it has greater timestamp.</a>
<a name="ln947">///</a>
<a name="ln948">/// Before the new entry entries from the current Neovim history will be</a>
<a name="ln949">/// inserted unless `do_iter` argument is false.</a>
<a name="ln950">///</a>
<a name="ln951">/// @param[in,out]  hms_p           Ring buffer and associated structures.</a>
<a name="ln952">/// @param[in]      entry           Inserted entry.</a>
<a name="ln953">/// @param[in]      do_iter         Determines whether Neovim own history should</a>
<a name="ln954">///                                 be used. Must be true only if inserting</a>
<a name="ln955">///                                 entry from current Neovim history.</a>
<a name="ln956">/// @param[in]      can_free_entry  True if entry can be freed.</a>
<a name="ln957">static void hms_insert(HistoryMergerState *const hms_p, const ShadaEntry entry,</a>
<a name="ln958">                       const bool do_iter, const bool can_free_entry)</a>
<a name="ln959">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln960">{</a>
<a name="ln961">  if (do_iter) {</a>
<a name="ln962">    while (hms_p-&gt;last_hist_entry.type != kSDItemMissing</a>
<a name="ln963">           &amp;&amp; hms_p-&gt;last_hist_entry.timestamp &lt; entry.timestamp) {</a>
<a name="ln964">      hms_insert(hms_p, hms_p-&gt;last_hist_entry, false, hms_p-&gt;reading);</a>
<a name="ln965">      if (hms_p-&gt;iter == NULL) {</a>
<a name="ln966">        hms_p-&gt;last_hist_entry.type = kSDItemMissing;</a>
<a name="ln967">        break;</a>
<a name="ln968">      }</a>
<a name="ln969">      hms_p-&gt;iter = shada_hist_iter(hms_p-&gt;iter, hms_p-&gt;history_type,</a>
<a name="ln970">                                    hms_p-&gt;reading, &amp;hms_p-&gt;last_hist_entry);</a>
<a name="ln971">    }</a>
<a name="ln972">  }</a>
<a name="ln973">  HMLList *const hmll = &amp;hms_p-&gt;hmll;</a>
<a name="ln974">  const khiter_t k = kh_get(hmll_entries, &amp;hms_p-&gt;hmll.contained_entries,</a>
<a name="ln975">                            entry.data.history_item.string);</a>
<a name="ln976">  if (k != kh_end(&amp;hmll-&gt;contained_entries)) {</a>
<a name="ln977">    HMLListEntry *const existing_entry = kh_val(&amp;hmll-&gt;contained_entries, k);</a>
<a name="ln978">    if (entry.timestamp &gt; existing_entry-&gt;data.timestamp) {</a>
<a name="ln979">      hmll_remove(hmll, existing_entry);</a>
<a name="ln980">    } else if (!do_iter &amp;&amp; entry.timestamp == existing_entry-&gt;data.timestamp) {</a>
<a name="ln981">      // Prefer entry from the current Neovim instance.</a>
<a name="ln982">      if (existing_entry-&gt;can_free_entry) {</a>
<a name="ln983">        shada_free_shada_entry(&amp;existing_entry-&gt;data);</a>
<a name="ln984">      }</a>
<a name="ln985">      existing_entry-&gt;data = entry;</a>
<a name="ln986">      existing_entry-&gt;can_free_entry = can_free_entry;</a>
<a name="ln987">      // Previous key was freed above, as part of freeing the ShaDa entry.</a>
<a name="ln988">      kh_key(&amp;hmll-&gt;contained_entries, k) = entry.data.history_item.string;</a>
<a name="ln989">      return;</a>
<a name="ln990">    } else {</a>
<a name="ln991">      return;</a>
<a name="ln992">    }</a>
<a name="ln993">  }</a>
<a name="ln994">  HMLListEntry *insert_after;</a>
<a name="ln995">  HMLL_ITER_BACK(hmll, insert_after, {</a>
<a name="ln996">    if (insert_after-&gt;data.timestamp &lt;= entry.timestamp) {</a>
<a name="ln997">      break;</a>
<a name="ln998">    }</a>
<a name="ln999">  })</a>
<a name="ln1000">  hmll_insert(hmll, insert_after, entry, can_free_entry);</a>
<a name="ln1001">}</a>
<a name="ln1002"> </a>
<a name="ln1003">/// Initialize the history merger</a>
<a name="ln1004">///</a>
<a name="ln1005">/// @param[out]  hms_p         Structure to be initialized.</a>
<a name="ln1006">/// @param[in]   history_type  History type (one of HIST_\* values).</a>
<a name="ln1007">/// @param[in]   num_elements  Number of elements in the result.</a>
<a name="ln1008">/// @param[in]   do_merge      Prepare structure for merging elements.</a>
<a name="ln1009">/// @param[in]   reading       If true, then merger is reading history for use</a>
<a name="ln1010">///                            in Neovim.</a>
<a name="ln1011">static inline void hms_init(HistoryMergerState *const hms_p,</a>
<a name="ln1012">                            const uint8_t history_type,</a>
<a name="ln1013">                            const size_t num_elements,</a>
<a name="ln1014">                            const bool do_merge,</a>
<a name="ln1015">                            const bool reading)</a>
<a name="ln1016">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1017">{</a>
<a name="ln1018">  hmll_init(&amp;hms_p-&gt;hmll, num_elements);</a>
<a name="ln1019">  hms_p-&gt;do_merge = do_merge;</a>
<a name="ln1020">  hms_p-&gt;reading = reading;</a>
<a name="ln1021">  hms_p-&gt;iter = shada_hist_iter(NULL, history_type, hms_p-&gt;reading,</a>
<a name="ln1022">                                &amp;hms_p-&gt;last_hist_entry);</a>
<a name="ln1023">  hms_p-&gt;history_type = history_type;</a>
<a name="ln1024">}</a>
<a name="ln1025"> </a>
<a name="ln1026">/// Merge in all remaining Neovim own history entries</a>
<a name="ln1027">///</a>
<a name="ln1028">/// @param[in,out]  hms_p  Merger structure into which history should be</a>
<a name="ln1029">///                        inserted.</a>
<a name="ln1030">static inline void hms_insert_whole_neovim_history(</a>
<a name="ln1031">    HistoryMergerState *const hms_p)</a>
<a name="ln1032">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1033">{</a>
<a name="ln1034">  while (hms_p-&gt;last_hist_entry.type != kSDItemMissing) {</a>
<a name="ln1035">    hms_insert(hms_p, hms_p-&gt;last_hist_entry, false, hms_p-&gt;reading);</a>
<a name="ln1036">    if (hms_p-&gt;iter == NULL) {</a>
<a name="ln1037">      break;</a>
<a name="ln1038">    }</a>
<a name="ln1039">    hms_p-&gt;iter = shada_hist_iter(hms_p-&gt;iter, hms_p-&gt;history_type,</a>
<a name="ln1040">                                  hms_p-&gt;reading, &amp;hms_p-&gt;last_hist_entry);</a>
<a name="ln1041">  }</a>
<a name="ln1042">}</a>
<a name="ln1043"> </a>
<a name="ln1044">/// Convert merger structure to Neovim internal structure for history</a>
<a name="ln1045">///</a>
<a name="ln1046">/// @param[in]   hms_p       Converted merger structure.</a>
<a name="ln1047">/// @param[out]  hist_array  Array with the results.</a>
<a name="ln1048">/// @param[out]  new_hisidx  New last history entry index.</a>
<a name="ln1049">/// @param[out]  new_hisnum  Amount of history items in merger structure.</a>
<a name="ln1050">static inline void hms_to_he_array(const HistoryMergerState *const hms_p,</a>
<a name="ln1051">                                   histentry_T *const hist_array,</a>
<a name="ln1052">                                   int *const new_hisidx,</a>
<a name="ln1053">                                   int *const new_hisnum)</a>
<a name="ln1054">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1055">{</a>
<a name="ln1056">  histentry_T *hist = hist_array;</a>
<a name="ln1057">  HMLL_FORALL(&amp;hms_p-&gt;hmll, cur_entry,  {</a>
<a name="ln1058">    hist-&gt;timestamp = cur_entry-&gt;data.timestamp;</a>
<a name="ln1059">    hist-&gt;hisnum = (int) (hist - hist_array) + 1;</a>
<a name="ln1060">    hist-&gt;hisstr = (char_u *) cur_entry-&gt;data.data.history_item.string;</a>
<a name="ln1061">    hist-&gt;additional_elements =</a>
<a name="ln1062">        cur_entry-&gt;data.data.history_item.additional_elements;</a>
<a name="ln1063">    hist++;</a>
<a name="ln1064">  })</a>
<a name="ln1065">  *new_hisnum = (int) (hist - hist_array);</a>
<a name="ln1066">  *new_hisidx = *new_hisnum - 1;</a>
<a name="ln1067">}</a>
<a name="ln1068"> </a>
<a name="ln1069">/// Free history merger structure</a>
<a name="ln1070">///</a>
<a name="ln1071">/// @param[in]  hms_p  Structure to be freed.</a>
<a name="ln1072">static inline void hms_dealloc(HistoryMergerState *const hms_p)</a>
<a name="ln1073">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1074">{</a>
<a name="ln1075">  hmll_dealloc(&amp;hms_p-&gt;hmll);</a>
<a name="ln1076">}</a>
<a name="ln1077"> </a>
<a name="ln1078">/// Iterate over all history entries in history merger, in order</a>
<a name="ln1079">///</a>
<a name="ln1080">/// @param[in]   hms_p      Merger structure to iterate over.</a>
<a name="ln1081">/// @param[out]  cur_entry  Name of the iterator variable.</a>
<a name="ln1082">/// @param       code       Code to execute on each iteration.</a>
<a name="ln1083">///</a>
<a name="ln1084">/// @return for cycle header. Use `HMS_ITER(hms_p, cur_entry) {body}`.</a>
<a name="ln1085">#define HMS_ITER(hms_p, cur_entry, code) \</a>
<a name="ln1086">    HMLL_FORALL(&amp;((hms_p)-&gt;hmll), cur_entry, code)</a>
<a name="ln1087"> </a>
<a name="ln1088">/// Find buffer for given buffer name (cached)</a>
<a name="ln1089">///</a>
<a name="ln1090">/// @param[in,out]  fname_bufs  Cache containing fname to buffer mapping.</a>
<a name="ln1091">/// @param[in]      fname       File name to find.</a>
<a name="ln1092">///</a>
<a name="ln1093">/// @return Pointer to the buffer or NULL.</a>
<a name="ln1094">static buf_T *find_buffer(khash_t(fnamebufs) *const fname_bufs,</a>
<a name="ln1095">                          const char *const fname)</a>
<a name="ln1096">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1097">{</a>
<a name="ln1098">  int kh_ret;</a>
<a name="ln1099">  khint_t k = kh_put(fnamebufs, fname_bufs, fname, &amp;kh_ret);</a>
<a name="ln1100">  if (!kh_ret) {</a>
<a name="ln1101">    return kh_val(fname_bufs, k);</a>
<a name="ln1102">  }</a>
<a name="ln1103">  kh_key(fname_bufs, k) = xstrdup(fname);</a>
<a name="ln1104">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln1105">    if (buf-&gt;b_ffname != NULL) {</a>
<a name="ln1106">      if (fnamecmp(fname, buf-&gt;b_ffname) == 0) {</a>
<a name="ln1107">        kh_val(fname_bufs, k) = buf;</a>
<a name="ln1108">        return buf;</a>
<a name="ln1109">      }</a>
<a name="ln1110">    }</a>
<a name="ln1111">  }</a>
<a name="ln1112">  kh_val(fname_bufs, k) = NULL;</a>
<a name="ln1113">  return NULL;</a>
<a name="ln1114">}</a>
<a name="ln1115"> </a>
<a name="ln1116">/// Compare two marks</a>
<a name="ln1117">static inline bool marks_equal(const pos_T a, const pos_T b)</a>
<a name="ln1118">{</a>
<a name="ln1119">  return (a.lnum == b.lnum) &amp;&amp; (a.col == b.col);</a>
<a name="ln1120">}</a>
<a name="ln1121"> </a>
<a name="ln1122">#define MERGE_JUMPS(jumps_size, jumps, jumps_type, timestamp_attr, mark_attr, \</a>
<a name="ln1123">                    entry, fname_cond, free_func, fin_func, \</a>
<a name="ln1124">                    idxadj_func, afterfree_func) \</a>
<a name="ln1125">  do { \</a>
<a name="ln1126">    const int jl_len = (int) jumps_size; \</a>
<a name="ln1127">    int i; \</a>
<a name="ln1128">    for (i = jl_len; i &gt; 0; i--) { \</a>
<a name="ln1129">      const jumps_type jl_entry = jumps[i - 1]; \</a>
<a name="ln1130">      if (jl_entry.timestamp_attr &lt;= entry.timestamp) { \</a>
<a name="ln1131">        if (marks_equal(jl_entry.mark_attr, entry.data.filemark.mark) \</a>
<a name="ln1132">            &amp;&amp; fname_cond) { \</a>
<a name="ln1133">          i = -1; \</a>
<a name="ln1134">        } \</a>
<a name="ln1135">        break; \</a>
<a name="ln1136">      } \</a>
<a name="ln1137">    } \</a>
<a name="ln1138">    if (i &gt; 0) { \</a>
<a name="ln1139">      if (jl_len == JUMPLISTSIZE) { \</a>
<a name="ln1140">        free_func(jumps[0]); \</a>
<a name="ln1141">        i--; \</a>
<a name="ln1142">        if (i &gt; 0) { \</a>
<a name="ln1143">          memmove(&amp;jumps[0], &amp;jumps[1], sizeof(jumps[1]) * (size_t) i); \</a>
<a name="ln1144">        } \</a>
<a name="ln1145">      } else if (i != jl_len) { \</a>
<a name="ln1146">        memmove(&amp;jumps[i + 1], &amp;jumps[i], \</a>
<a name="ln1147">                sizeof(jumps[0]) * (size_t) (jl_len - i)); \</a>
<a name="ln1148">      } \</a>
<a name="ln1149">    } else if (i == 0) { \</a>
<a name="ln1150">      if (jl_len == JUMPLISTSIZE) { \</a>
<a name="ln1151">        i = -1; \</a>
<a name="ln1152">      } else if (jl_len &gt; 0) { \</a>
<a name="ln1153">        memmove(&amp;jumps[1], &amp;jumps[0], sizeof(jumps[0]) * (size_t) jl_len); \</a>
<a name="ln1154">      } \</a>
<a name="ln1155">    } \</a>
<a name="ln1156">    if (i != -1) { \</a>
<a name="ln1157">      jumps[i] = fin_func(entry); \</a>
<a name="ln1158">      if (jl_len &lt; JUMPLISTSIZE) { \</a>
<a name="ln1159">        jumps_size++; \</a>
<a name="ln1160">      } \</a>
<a name="ln1161">      idxadj_func(i); \</a>
<a name="ln1162">    } else { \</a>
<a name="ln1163">      shada_free_shada_entry(&amp;entry); \</a>
<a name="ln1164">      afterfree_func(entry); \</a>
<a name="ln1165">    } \</a>
<a name="ln1166">  } while (0)</a>
<a name="ln1167"> </a>
<a name="ln1168">/// Read data from ShaDa file</a>
<a name="ln1169">///</a>
<a name="ln1170">/// @param[in]  sd_reader  Structure containing file reader definition.</a>
<a name="ln1171">/// @param[in]  flags      What to read, see ShaDaReadFileFlags enum.</a>
<a name="ln1172">static void shada_read(ShaDaReadDef *const sd_reader, const int flags)</a>
<a name="ln1173">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1174">{</a>
<a name="ln1175">  list_T *oldfiles_list = get_vim_var_list(VV_OLDFILES);</a>
<a name="ln1176">  const bool force = flags &amp; kShaDaForceit;</a>
<a name="ln1177">  const bool get_old_files = (flags &amp; (kShaDaGetOldfiles | kShaDaForceit)</a>
<a name="ln1178">                              &amp;&amp; (force || tv_list_len(oldfiles_list) == 0));</a>
<a name="ln1179">  const bool want_marks = flags &amp; kShaDaWantMarks;</a>
<a name="ln1180">  const unsigned srni_flags = (unsigned) (</a>
<a name="ln1181">      (flags &amp; kShaDaWantInfo</a>
<a name="ln1182">       ? (kSDReadUndisableableData</a>
<a name="ln1183">          | kSDReadRegisters</a>
<a name="ln1184">          | kSDReadGlobalMarks</a>
<a name="ln1185">          | (p_hi ? kSDReadHistory : 0)</a>
<a name="ln1186">          | (find_shada_parameter('!') != NULL</a>
<a name="ln1187">             ? kSDReadVariables</a>
<a name="ln1188">             : 0)</a>
<a name="ln1189">          | (find_shada_parameter('%') != NULL</a>
<a name="ln1190">             &amp;&amp; ARGCOUNT == 0</a>
<a name="ln1191">             ? kSDReadBufferList</a>
<a name="ln1192">             : 0))</a>
<a name="ln1193">       : 0)</a>
<a name="ln1194">      | (want_marks &amp;&amp; get_shada_parameter('\'') &gt; 0</a>
<a name="ln1195">         ? kSDReadLocalMarks | kSDReadChanges</a>
<a name="ln1196">         : 0)</a>
<a name="ln1197">      | (get_old_files</a>
<a name="ln1198">         ? kSDReadLocalMarks</a>
<a name="ln1199">         : 0));</a>
<a name="ln1200">  if (srni_flags == 0) {</a>
<a name="ln1201">    // Nothing to do.</a>
<a name="ln1202">    return;</a>
<a name="ln1203">  }</a>
<a name="ln1204">  HistoryMergerState hms[HIST_COUNT];</a>
<a name="ln1205">  if (srni_flags &amp; kSDReadHistory) {</a>
<a name="ln1206">    for (uint8_t i = 0; i &lt; HIST_COUNT; i++) {</a>
<a name="ln1207">      hms_init(&amp;hms[i], i, (size_t) p_hi, true, true);</a>
<a name="ln1208">    }</a>
<a name="ln1209">  }</a>
<a name="ln1210">  ShadaEntry cur_entry;</a>
<a name="ln1211">  khash_t(bufset) cl_bufs = KHASH_EMPTY_TABLE(bufset);</a>
<a name="ln1212">  khash_t(fnamebufs) fname_bufs = KHASH_EMPTY_TABLE(fnamebufs);</a>
<a name="ln1213">  khash_t(strset) oldfiles_set = KHASH_EMPTY_TABLE(strset);</a>
<a name="ln1214">  if (get_old_files &amp;&amp; (oldfiles_list == NULL || force)) {</a>
<a name="ln1215">    oldfiles_list = tv_list_alloc(kListLenUnknown);</a>
<a name="ln1216">    set_vim_var_list(VV_OLDFILES, oldfiles_list);</a>
<a name="ln1217">  }</a>
<a name="ln1218">  ShaDaReadResult srni_ret;</a>
<a name="ln1219">  while ((srni_ret = shada_read_next_item(sd_reader, &amp;cur_entry, srni_flags, 0))</a>
<a name="ln1220">         != kSDReadStatusFinished) {</a>
<a name="ln1221">    switch (srni_ret) {</a>
<a name="ln1222">      case kSDReadStatusSuccess: {</a>
<a name="ln1223">        break;</a>
<a name="ln1224">      }</a>
<a name="ln1225">      case kSDReadStatusFinished: {</a>
<a name="ln1226">        // Should be handled by the while condition.</a>
<a name="ln1227">        abort();</a>
<a name="ln1228">      }</a>
<a name="ln1229">      case kSDReadStatusNotShaDa:</a>
<a name="ln1230">      case kSDReadStatusReadError: {</a>
<a name="ln1231">        goto shada_read_main_cycle_end;</a>
<a name="ln1232">      }</a>
<a name="ln1233">      case kSDReadStatusMalformed: {</a>
<a name="ln1234">        continue;</a>
<a name="ln1235">      }</a>
<a name="ln1236">    }</a>
<a name="ln1237">    switch (cur_entry.type) {</a>
<a name="ln1238">      case kSDItemMissing: {</a>
<a name="ln1239">        abort();</a>
<a name="ln1240">      }</a>
<a name="ln1241">      case kSDItemUnknown: {</a>
<a name="ln1242">        break;</a>
<a name="ln1243">      }</a>
<a name="ln1244">      case kSDItemHeader: {</a>
<a name="ln1245">        shada_free_shada_entry(&amp;cur_entry);</a>
<a name="ln1246">        break;</a>
<a name="ln1247">      }</a>
<a name="ln1248">      case kSDItemSearchPattern: {</a>
<a name="ln1249">        if (!force) {</a>
<a name="ln1250">          SearchPattern pat;</a>
<a name="ln1251">          (cur_entry.data.search_pattern.is_substitute_pattern</a>
<a name="ln1252">           ? &amp;get_substitute_pattern</a>
<a name="ln1253">           : &amp;get_search_pattern)(&amp;pat);</a>
<a name="ln1254">          if (pat.pat != NULL &amp;&amp; pat.timestamp &gt;= cur_entry.timestamp) {</a>
<a name="ln1255">            shada_free_shada_entry(&amp;cur_entry);</a>
<a name="ln1256">            break;</a>
<a name="ln1257">          }</a>
<a name="ln1258">        }</a>
<a name="ln1259">        (cur_entry.data.search_pattern.is_substitute_pattern</a>
<a name="ln1260">         ? &amp;set_substitute_pattern</a>
<a name="ln1261">         : &amp;set_search_pattern)((SearchPattern) {</a>
<a name="ln1262">           .magic = cur_entry.data.search_pattern.magic,</a>
<a name="ln1263">           .no_scs = !cur_entry.data.search_pattern.smartcase,</a>
<a name="ln1264">           .off = {</a>
<a name="ln1265">             .dir = cur_entry.data.search_pattern.search_backward ? '?' : '/',</a>
<a name="ln1266">             .line = cur_entry.data.search_pattern.has_line_offset,</a>
<a name="ln1267">             .end = cur_entry.data.search_pattern.place_cursor_at_end,</a>
<a name="ln1268">             .off = cur_entry.data.search_pattern.offset,</a>
<a name="ln1269">           },</a>
<a name="ln1270">           .pat = (char_u *) cur_entry.data.search_pattern.pat,</a>
<a name="ln1271">           .additional_data = cur_entry.data.search_pattern.additional_data,</a>
<a name="ln1272">           .timestamp = cur_entry.timestamp,</a>
<a name="ln1273">         });</a>
<a name="ln1274">        if (cur_entry.data.search_pattern.is_last_used) {</a>
<a name="ln1275">          set_last_used_pattern(</a>
<a name="ln1276">              cur_entry.data.search_pattern.is_substitute_pattern);</a>
<a name="ln1277">          set_no_hlsearch(!cur_entry.data.search_pattern.highlighted);</a>
<a name="ln1278">        }</a>
<a name="ln1279">        // Do not free shada entry: its allocated memory was saved above.</a>
<a name="ln1280">        break;</a>
<a name="ln1281">      }</a>
<a name="ln1282">      case kSDItemSubString: {</a>
<a name="ln1283">        if (!force) {</a>
<a name="ln1284">          SubReplacementString sub;</a>
<a name="ln1285">          sub_get_replacement(&amp;sub);</a>
<a name="ln1286">          if (sub.sub != NULL &amp;&amp; sub.timestamp &gt;= cur_entry.timestamp) {</a>
<a name="ln1287">            shada_free_shada_entry(&amp;cur_entry);</a>
<a name="ln1288">            break;</a>
<a name="ln1289">          }</a>
<a name="ln1290">        }</a>
<a name="ln1291">        sub_set_replacement((SubReplacementString) {</a>
<a name="ln1292">          .sub = cur_entry.data.sub_string.sub,</a>
<a name="ln1293">          .timestamp = cur_entry.timestamp,</a>
<a name="ln1294">          .additional_elements = cur_entry.data.sub_string.additional_elements,</a>
<a name="ln1295">        });</a>
<a name="ln1296">        // Without using regtilde and without / &amp;cpo flag previous substitute</a>
<a name="ln1297">        // string is close to useless: you can only use it with :&amp; or :~ and</a>
<a name="ln1298">        // that’s all because s//~ is not available until the first call to</a>
<a name="ln1299">        // regtilde. Vim was not calling this for some reason.</a>
<a name="ln1300">        (void) regtilde(cur_entry.data.sub_string.sub, p_magic);</a>
<a name="ln1301">        // Do not free shada entry: its allocated memory was saved above.</a>
<a name="ln1302">        break;</a>
<a name="ln1303">      }</a>
<a name="ln1304">      case kSDItemHistoryEntry: {</a>
<a name="ln1305">        if (cur_entry.data.history_item.histtype &gt;= HIST_COUNT) {</a>
<a name="ln1306">          shada_free_shada_entry(&amp;cur_entry);</a>
<a name="ln1307">          break;</a>
<a name="ln1308">        }</a>
<a name="ln1309">        hms_insert(hms + cur_entry.data.history_item.histtype, cur_entry, true,</a>
<a name="ln1310">                   true);</a>
<a name="ln1311">        // Do not free shada entry: its allocated memory was saved above.</a>
<a name="ln1312">        break;</a>
<a name="ln1313">      }</a>
<a name="ln1314">      case kSDItemRegister: {</a>
<a name="ln1315">        if (cur_entry.data.reg.type != kMTCharWise</a>
<a name="ln1316">            &amp;&amp; cur_entry.data.reg.type != kMTLineWise</a>
<a name="ln1317">            &amp;&amp; cur_entry.data.reg.type != kMTBlockWise) {</a>
<a name="ln1318">          shada_free_shada_entry(&amp;cur_entry);</a>
<a name="ln1319">          break;</a>
<a name="ln1320">        }</a>
<a name="ln1321">        if (!force) {</a>
<a name="ln1322">          const yankreg_T *const reg = op_reg_get(cur_entry.data.reg.name);</a>
<a name="ln1323">          if (reg == NULL || reg-&gt;timestamp &gt;= cur_entry.timestamp) {</a>
<a name="ln1324">            shada_free_shada_entry(&amp;cur_entry);</a>
<a name="ln1325">            break;</a>
<a name="ln1326">          }</a>
<a name="ln1327">        }</a>
<a name="ln1328">        if (!op_reg_set(cur_entry.data.reg.name, (yankreg_T) {</a>
<a name="ln1329">          .y_array = (char_u **)cur_entry.data.reg.contents,</a>
<a name="ln1330">          .y_size = cur_entry.data.reg.contents_size,</a>
<a name="ln1331">          .y_type = cur_entry.data.reg.type,</a>
<a name="ln1332">          .y_width = (colnr_T) cur_entry.data.reg.width,</a>
<a name="ln1333">          .timestamp = cur_entry.timestamp,</a>
<a name="ln1334">          .additional_data = cur_entry.data.reg.additional_data,</a>
<a name="ln1335">        }, cur_entry.data.reg.is_unnamed)) {</a>
<a name="ln1336">          shada_free_shada_entry(&amp;cur_entry);</a>
<a name="ln1337">        }</a>
<a name="ln1338">        // Do not free shada entry: its allocated memory was saved above.</a>
<a name="ln1339">        break;</a>
<a name="ln1340">      }</a>
<a name="ln1341">      case kSDItemVariable: {</a>
<a name="ln1342">        var_set_global(cur_entry.data.global_var.name,</a>
<a name="ln1343">                       cur_entry.data.global_var.value);</a>
<a name="ln1344">        cur_entry.data.global_var.value.v_type = VAR_UNKNOWN;</a>
<a name="ln1345">        shada_free_shada_entry(&amp;cur_entry);</a>
<a name="ln1346">        break;</a>
<a name="ln1347">      }</a>
<a name="ln1348">      case kSDItemJump:</a>
<a name="ln1349">      case kSDItemGlobalMark: {</a>
<a name="ln1350">        buf_T *buf = find_buffer(&amp;fname_bufs, cur_entry.data.filemark.fname);</a>
<a name="ln1351">        if (buf != NULL) {</a>
<a name="ln1352">          XFREE_CLEAR(cur_entry.data.filemark.fname);</a>
<a name="ln1353">        }</a>
<a name="ln1354">        xfmark_T fm = (xfmark_T) {</a>
<a name="ln1355">          .fname = (char_u *) (buf == NULL</a>
<a name="ln1356">                               ? cur_entry.data.filemark.fname</a>
<a name="ln1357">                               : NULL),</a>
<a name="ln1358">          .fmark = {</a>
<a name="ln1359">            .mark = cur_entry.data.filemark.mark,</a>
<a name="ln1360">            .fnum = (buf == NULL ? 0 : buf-&gt;b_fnum),</a>
<a name="ln1361">            .timestamp = cur_entry.timestamp,</a>
<a name="ln1362">            .additional_data = cur_entry.data.filemark.additional_data,</a>
<a name="ln1363">          },</a>
<a name="ln1364">        };</a>
<a name="ln1365">        if (cur_entry.type == kSDItemGlobalMark) {</a>
<a name="ln1366">          if (!mark_set_global(cur_entry.data.filemark.name, fm, !force)) {</a>
<a name="ln1367">            shada_free_shada_entry(&amp;cur_entry);</a>
<a name="ln1368">            break;</a>
<a name="ln1369">          }</a>
<a name="ln1370">        } else {</a>
<a name="ln1371">#define SDE_TO_XFMARK(entry) fm</a>
<a name="ln1372">#define ADJUST_IDX(i) \</a>
<a name="ln1373">          if (curwin-&gt;w_jumplistidx &gt;= i \</a>
<a name="ln1374">              &amp;&amp; curwin-&gt;w_jumplistidx + 1 &lt;= curwin-&gt;w_jumplistlen) { \</a>
<a name="ln1375">            curwin-&gt;w_jumplistidx++; \</a>
<a name="ln1376">          }</a>
<a name="ln1377">#define DUMMY_AFTERFREE(entry)</a>
<a name="ln1378">          MERGE_JUMPS(curwin-&gt;w_jumplistlen, curwin-&gt;w_jumplist, xfmark_T,</a>
<a name="ln1379">                      fmark.timestamp, fmark.mark, cur_entry,</a>
<a name="ln1380">                      (buf == NULL</a>
<a name="ln1381">                       ? (jl_entry.fname != NULL</a>
<a name="ln1382">                          &amp;&amp; STRCMP(fm.fname, jl_entry.fname) == 0)</a>
<a name="ln1383">                       : fm.fmark.fnum == jl_entry.fmark.fnum),</a>
<a name="ln1384">                      free_xfmark, SDE_TO_XFMARK, ADJUST_IDX, DUMMY_AFTERFREE);</a>
<a name="ln1385">#undef SDE_TO_XFMARK</a>
<a name="ln1386">#undef ADJUST_IDX</a>
<a name="ln1387">#undef DUMMY_AFTERFREE</a>
<a name="ln1388">        }</a>
<a name="ln1389">        // Do not free shada entry: its allocated memory was saved above.</a>
<a name="ln1390">        break;</a>
<a name="ln1391">      }</a>
<a name="ln1392">      case kSDItemBufferList: {</a>
<a name="ln1393">        for (size_t i = 0; i &lt; cur_entry.data.buffer_list.size; i++) {</a>
<a name="ln1394">          char *const sfname = path_try_shorten_fname(</a>
<a name="ln1395">              cur_entry.data.buffer_list.buffers[i].fname);</a>
<a name="ln1396">          buf_T *const buf = buflist_new(</a>
<a name="ln1397">              cur_entry.data.buffer_list.buffers[i].fname, sfname, 0,</a>
<a name="ln1398">              BLN_LISTED);</a>
<a name="ln1399">          if (buf != NULL) {</a>
<a name="ln1400">            RESET_FMARK(&amp;buf-&gt;b_last_cursor,</a>
<a name="ln1401">                        cur_entry.data.buffer_list.buffers[i].pos, 0);</a>
<a name="ln1402">            buflist_setfpos(buf, curwin, buf-&gt;b_last_cursor.mark.lnum,</a>
<a name="ln1403">                            buf-&gt;b_last_cursor.mark.col, false);</a>
<a name="ln1404">            buf-&gt;additional_data =</a>
<a name="ln1405">                cur_entry.data.buffer_list.buffers[i].additional_data;</a>
<a name="ln1406">            cur_entry.data.buffer_list.buffers[i].additional_data = NULL;</a>
<a name="ln1407">          }</a>
<a name="ln1408">        }</a>
<a name="ln1409">        shada_free_shada_entry(&amp;cur_entry);</a>
<a name="ln1410">        break;</a>
<a name="ln1411">      }</a>
<a name="ln1412">      case kSDItemChange:</a>
<a name="ln1413">      case kSDItemLocalMark: {</a>
<a name="ln1414">        if (get_old_files &amp;&amp; !in_strset(&amp;oldfiles_set,</a>
<a name="ln1415">                                        cur_entry.data.filemark.fname)) {</a>
<a name="ln1416">          char *fname = cur_entry.data.filemark.fname;</a>
<a name="ln1417">          if (want_marks) {</a>
<a name="ln1418">            // Do not bother with allocating memory for the string if already</a>
<a name="ln1419">            // allocated string from cur_entry can be used. It cannot be used if</a>
<a name="ln1420">            // want_marks is set because this way it may be used for a mark.</a>
<a name="ln1421">            fname = xstrdup(fname);</a>
<a name="ln1422">          }</a>
<a name="ln1423">          int kh_ret;</a>
<a name="ln1424">          (void)kh_put(strset, &amp;oldfiles_set, fname, &amp;kh_ret);</a>
<a name="ln1425">          tv_list_append_allocated_string(oldfiles_list, fname);</a>
<a name="ln1426">          if (!want_marks) {</a>
<a name="ln1427">            // Avoid free because this string was already used.</a>
<a name="ln1428">            cur_entry.data.filemark.fname = NULL;</a>
<a name="ln1429">          }</a>
<a name="ln1430">        }</a>
<a name="ln1431">        if (!want_marks) {</a>
<a name="ln1432">          shada_free_shada_entry(&amp;cur_entry);</a>
<a name="ln1433">          break;</a>
<a name="ln1434">        }</a>
<a name="ln1435">        buf_T *buf = find_buffer(&amp;fname_bufs, cur_entry.data.filemark.fname);</a>
<a name="ln1436">        if (buf == NULL) {</a>
<a name="ln1437">          shada_free_shada_entry(&amp;cur_entry);</a>
<a name="ln1438">          break;</a>
<a name="ln1439">        }</a>
<a name="ln1440">        const fmark_T fm = (fmark_T) {</a>
<a name="ln1441">          .mark = cur_entry.data.filemark.mark,</a>
<a name="ln1442">          .fnum = 0,</a>
<a name="ln1443">          .timestamp = cur_entry.timestamp,</a>
<a name="ln1444">          .additional_data = cur_entry.data.filemark.additional_data,</a>
<a name="ln1445">        };</a>
<a name="ln1446">        if (cur_entry.type == kSDItemLocalMark) {</a>
<a name="ln1447">          if (!mark_set_local(cur_entry.data.filemark.name, buf, fm, !force)) {</a>
<a name="ln1448">            shada_free_shada_entry(&amp;cur_entry);</a>
<a name="ln1449">            break;</a>
<a name="ln1450">          }</a>
<a name="ln1451">        } else {</a>
<a name="ln1452">          int kh_ret;</a>
<a name="ln1453">          (void) kh_put(bufset, &amp;cl_bufs, (uintptr_t) buf, &amp;kh_ret);</a>
<a name="ln1454">#define SDE_TO_FMARK(entry) fm</a>
<a name="ln1455">#define AFTERFREE(entry) (entry).data.filemark.fname = NULL</a>
<a name="ln1456">#define DUMMY_IDX_ADJ(i)</a>
<a name="ln1457">          MERGE_JUMPS(buf-&gt;b_changelistlen, buf-&gt;b_changelist, fmark_T,</a>
<a name="ln1458">                      timestamp, mark, cur_entry, true,</a>
<a name="ln1459">                      free_fmark, SDE_TO_FMARK, DUMMY_IDX_ADJ, AFTERFREE);</a>
<a name="ln1460">#undef SDE_TO_FMARK</a>
<a name="ln1461">#undef AFTERFREE</a>
<a name="ln1462">#undef DUMMY_IDX_ADJ</a>
<a name="ln1463">        }</a>
<a name="ln1464">        // Do not free shada entry: except for fname, its allocated memory (i.e.</a>
<a name="ln1465">        // additional_data attribute contents if non-NULL) was saved above.</a>
<a name="ln1466">        xfree(cur_entry.data.filemark.fname);</a>
<a name="ln1467">        break;</a>
<a name="ln1468">      }</a>
<a name="ln1469">    }</a>
<a name="ln1470">  }</a>
<a name="ln1471">shada_read_main_cycle_end:</a>
<a name="ln1472">  // Warning: shada_hist_iter returns ShadaEntry elements which use strings from</a>
<a name="ln1473">  //          original history list. This means that once such entry is removed</a>
<a name="ln1474">  //          from the history Neovim array will no longer be valid. To reduce</a>
<a name="ln1475">  //          amount of memory allocations ShaDa file reader allocates enough</a>
<a name="ln1476">  //          memory for the history string itself and separator character which</a>
<a name="ln1477">  //          may be assigned right away.</a>
<a name="ln1478">  if (srni_flags &amp; kSDReadHistory) {</a>
<a name="ln1479">    for (uint8_t i = 0; i &lt; HIST_COUNT; i++) {</a>
<a name="ln1480">      hms_insert_whole_neovim_history(&amp;hms[i]);</a>
<a name="ln1481">      clr_history(i);</a>
<a name="ln1482">      int *new_hisidx;</a>
<a name="ln1483">      int *new_hisnum;</a>
<a name="ln1484">      histentry_T *hist = hist_get_array(i, &amp;new_hisidx, &amp;new_hisnum);</a>
<a name="ln1485">      if (hist != NULL) {</a>
<a name="ln1486">        hms_to_he_array(&amp;hms[i], hist, new_hisidx, new_hisnum);</a>
<a name="ln1487">      }</a>
<a name="ln1488">      hms_dealloc(&amp;hms[i]);</a>
<a name="ln1489">    }</a>
<a name="ln1490">  }</a>
<a name="ln1491">  if (cl_bufs.n_occupied) {</a>
<a name="ln1492">    FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln1493">      (void) tp;</a>
<a name="ln1494">      if (in_bufset(&amp;cl_bufs, wp-&gt;w_buffer)) {</a>
<a name="ln1495">        wp-&gt;w_changelistidx = wp-&gt;w_buffer-&gt;b_changelistlen;</a>
<a name="ln1496">      }</a>
<a name="ln1497">    }</a>
<a name="ln1498">  }</a>
<a name="ln1499">  kh_dealloc(bufset, &amp;cl_bufs);</a>
<a name="ln1500">  const char *key;</a>
<a name="ln1501">  kh_foreach_key(&amp;fname_bufs, key, {</a>
<a name="ln1502">    xfree((void *) key);</a>
<a name="ln1503">  })</a>
<a name="ln1504">  kh_dealloc(fnamebufs, &amp;fname_bufs);</a>
<a name="ln1505">  kh_dealloc(strset, &amp;oldfiles_set);</a>
<a name="ln1506">}</a>
<a name="ln1507"> </a>
<a name="ln1508">/// Default shada file location: cached path</a>
<a name="ln1509">static char *default_shada_file = NULL;</a>
<a name="ln1510"> </a>
<a name="ln1511">/// Get the default ShaDa file</a>
<a name="ln1512">static const char *shada_get_default_file(void)</a>
<a name="ln1513">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1514">{</a>
<a name="ln1515">  if (default_shada_file == NULL) {</a>
<a name="ln1516">    char *shada_dir = stdpaths_user_data_subpath(&quot;shada&quot;, 0, false);</a>
<a name="ln1517">    default_shada_file = concat_fnames_realloc(shada_dir, &quot;main.shada&quot;, true);</a>
<a name="ln1518">  }</a>
<a name="ln1519">  return default_shada_file;</a>
<a name="ln1520">}</a>
<a name="ln1521"> </a>
<a name="ln1522">/// Get the ShaDa file name to use</a>
<a name="ln1523">///</a>
<a name="ln1524">/// If &quot;file&quot; is given and not empty, use it (has already been expanded by</a>
<a name="ln1525">/// cmdline functions). Otherwise use &quot;-i file_name&quot;, value from 'shada' or the</a>
<a name="ln1526">/// default, and expand environment variables.</a>
<a name="ln1527">///</a>
<a name="ln1528">/// @param[in]  file  Forced file name or NULL.</a>
<a name="ln1529">///</a>
<a name="ln1530">/// @return An allocated string containing shada file name.</a>
<a name="ln1531">static char *shada_filename(const char *file)</a>
<a name="ln1532">  FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1533">{</a>
<a name="ln1534">  if (file == NULL || *file == NUL) {</a>
<a name="ln1535">    if (p_shadafile != NULL &amp;&amp; *p_shadafile != NUL) {</a>
<a name="ln1536">      file = p_shadafile;</a>
<a name="ln1537">    } else {</a>
<a name="ln1538">      if ((file = find_shada_parameter('n')) == NULL || *file == NUL) {</a>
<a name="ln1539">        file =  shada_get_default_file();</a>
<a name="ln1540">      }</a>
<a name="ln1541">      // XXX It used to be one level lower, so that whatever is in</a>
<a name="ln1542">      //     `p_shadafile` was expanded. I intentionally moved it here</a>
<a name="ln1543">      //     because various expansions must have already be done by the shell.</a>
<a name="ln1544">      //     If shell is not performing them then they should be done in main.c</a>
<a name="ln1545">      //     where arguments are parsed, *not here*.</a>
<a name="ln1546">      expand_env((char_u *)file, &amp;(NameBuff[0]), MAXPATHL);</a>
<a name="ln1547">      file = (const char *) &amp;(NameBuff[0]);</a>
<a name="ln1548">    }</a>
<a name="ln1549">  }</a>
<a name="ln1550">  return xstrdup(file);</a>
<a name="ln1551">}</a>
<a name="ln1552"> </a>
<a name="ln1553">#define PACK_STATIC_STR(s) \</a>
<a name="ln1554">    do { \</a>
<a name="ln1555">      msgpack_pack_str(spacker, sizeof(s) - 1); \</a>
<a name="ln1556">      msgpack_pack_str_body(spacker, s, sizeof(s) - 1); \</a>
<a name="ln1557">    } while (0)</a>
<a name="ln1558">#define PACK_STRING(s) \</a>
<a name="ln1559">    do { \</a>
<a name="ln1560">      const String s_ = (s); \</a>
<a name="ln1561">      msgpack_pack_str(spacker, s_.size); \</a>
<a name="ln1562">      if (s_.size) { \</a>
<a name="ln1563">        msgpack_pack_str_body(spacker, s_.data, s_.size); \</a>
<a name="ln1564">      } \</a>
<a name="ln1565">    } while (0)</a>
<a name="ln1566">#define PACK_BIN(s) \</a>
<a name="ln1567">    do { \</a>
<a name="ln1568">      const String s_ = (s); \</a>
<a name="ln1569">      msgpack_pack_bin(spacker, s_.size); \</a>
<a name="ln1570">      if (s_.size &gt; 0) { \</a>
<a name="ln1571">        msgpack_pack_bin_body(spacker, s_.data, s_.size); \</a>
<a name="ln1572">      } \</a>
<a name="ln1573">    } while (0)</a>
<a name="ln1574"> </a>
<a name="ln1575">/// Write single ShaDa entry</a>
<a name="ln1576">///</a>
<a name="ln1577">/// @param[in]  packer     Packer used to write entry.</a>
<a name="ln1578">/// @param[in]  entry      Entry written.</a>
<a name="ln1579">/// @param[in]  max_kbyte  Maximum size of an item in KiB. Zero means no</a>
<a name="ln1580">///                        restrictions.</a>
<a name="ln1581">///</a>
<a name="ln1582">/// @return kSDWriteSuccessfull, kSDWriteFailed or kSDWriteIgnError.</a>
<a name="ln1583">static ShaDaWriteResult shada_pack_entry(msgpack_packer *const packer,</a>
<a name="ln1584">                                         ShadaEntry entry,</a>
<a name="ln1585">                                         const size_t max_kbyte)</a>
<a name="ln1586">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1587">{</a>
<a name="ln1588">  ShaDaWriteResult ret = kSDWriteFailed;</a>
<a name="ln1589">  msgpack_sbuffer sbuf;</a>
<a name="ln1590">  msgpack_sbuffer_init(&amp;sbuf);</a>
<a name="ln1591">  msgpack_packer *spacker = msgpack_packer_new(&amp;sbuf, &amp;msgpack_sbuffer_write);</a>
<a name="ln1592">#define DUMP_ADDITIONAL_ELEMENTS(src, what) \</a>
<a name="ln1593">  do { \</a>
<a name="ln1594">    if ((src) != NULL) { \</a>
<a name="ln1595">      TV_LIST_ITER((src), li, { \</a>
<a name="ln1596">        if (encode_vim_to_msgpack(spacker, TV_LIST_ITEM_TV(li), \</a>
<a name="ln1597">                                  _(&quot;additional elements of ShaDa &quot; what)) \</a>
<a name="ln1598">            == FAIL) { \</a>
<a name="ln1599">          goto shada_pack_entry_error; \</a>
<a name="ln1600">        } \</a>
<a name="ln1601">      }); \</a>
<a name="ln1602">    } \</a>
<a name="ln1603">  } while (0)</a>
<a name="ln1604">#define DUMP_ADDITIONAL_DATA(src, what) \</a>
<a name="ln1605">  do { \</a>
<a name="ln1606">    dict_T *const d = (src); \</a>
<a name="ln1607">    if (d != NULL) { \</a>
<a name="ln1608">      size_t todo = d-&gt;dv_hashtab.ht_used; \</a>
<a name="ln1609">      for (const hashitem_T *hi= d-&gt;dv_hashtab.ht_array; todo; hi++) { \</a>
<a name="ln1610">        if (!HASHITEM_EMPTY(hi)) { \</a>
<a name="ln1611">          todo--; \</a>
<a name="ln1612">          dictitem_T *const di = TV_DICT_HI2DI(hi); \</a>
<a name="ln1613">          const size_t key_len = strlen((const char *)hi-&gt;hi_key); \</a>
<a name="ln1614">          msgpack_pack_str(spacker, key_len); \</a>
<a name="ln1615">          msgpack_pack_str_body(spacker, (const char *)hi-&gt;hi_key, key_len); \</a>
<a name="ln1616">          if (encode_vim_to_msgpack(spacker, &amp;di-&gt;di_tv, \</a>
<a name="ln1617">                                    _(&quot;additional data of ShaDa &quot; what)) \</a>
<a name="ln1618">              == FAIL) { \</a>
<a name="ln1619">            goto shada_pack_entry_error; \</a>
<a name="ln1620">          } \</a>
<a name="ln1621">        } \</a>
<a name="ln1622">      } \</a>
<a name="ln1623">    } \</a>
<a name="ln1624">  } while (0)</a>
<a name="ln1625">#define CHECK_DEFAULT(entry, attr) \</a>
<a name="ln1626">  (sd_default_values[entry.type].data.attr == entry.data.attr)</a>
<a name="ln1627">#define ONE_IF_NOT_DEFAULT(entry, attr) \</a>
<a name="ln1628">  ((size_t) (!CHECK_DEFAULT(entry, attr)))</a>
<a name="ln1629">  switch (entry.type) {</a>
<a name="ln1630">    case kSDItemMissing: {</a>
<a name="ln1631">      abort();</a>
<a name="ln1632">    }</a>
<a name="ln1633">    case kSDItemUnknown: {</a>
<a name="ln1634">      if (spacker-&gt;callback(spacker-&gt;data, entry.data.unknown_item.contents,</a>
<a name="ln1635">                            (unsigned) entry.data.unknown_item.size) == -1) {</a>
<a name="ln1636">        goto shada_pack_entry_error;</a>
<a name="ln1637">      }</a>
<a name="ln1638">      break;</a>
<a name="ln1639">    }</a>
<a name="ln1640">    case kSDItemHistoryEntry: {</a>
<a name="ln1641">      const bool is_hist_search =</a>
<a name="ln1642">          entry.data.history_item.histtype == HIST_SEARCH;</a>
<a name="ln1643">      const size_t arr_size = 2 + (size_t)is_hist_search + (size_t)(</a>
<a name="ln1644">          tv_list_len(entry.data.history_item.additional_elements));</a>
<a name="ln1645">      msgpack_pack_array(spacker, arr_size);</a>
<a name="ln1646">      msgpack_pack_uint8(spacker, entry.data.history_item.histtype);</a>
<a name="ln1647">      PACK_BIN(cstr_as_string(entry.data.history_item.string));</a>
<a name="ln1648">      if (is_hist_search) {</a>
<a name="ln1649">        msgpack_pack_uint8(spacker, (uint8_t)entry.data.history_item.sep);</a>
<a name="ln1650">      }</a>
<a name="ln1651">      DUMP_ADDITIONAL_ELEMENTS(entry.data.history_item.additional_elements,</a>
<a name="ln1652">                               &quot;history entry item&quot;);</a>
<a name="ln1653">      break;</a>
<a name="ln1654">    }</a>
<a name="ln1655">    case kSDItemVariable: {</a>
<a name="ln1656">      const size_t arr_size = 2 + (size_t)(</a>
<a name="ln1657">          tv_list_len(entry.data.global_var.additional_elements));</a>
<a name="ln1658">      msgpack_pack_array(spacker, arr_size);</a>
<a name="ln1659">      const String varname = cstr_as_string(entry.data.global_var.name);</a>
<a name="ln1660">      PACK_BIN(varname);</a>
<a name="ln1661">      char vardesc[256] = &quot;variable g:&quot;;</a>
<a name="ln1662">      memcpy(&amp;vardesc[sizeof(&quot;variable g:&quot;) - 1], varname.data,</a>
<a name="ln1663">             varname.size + 1);</a>
<a name="ln1664">      if (encode_vim_to_msgpack(spacker, &amp;entry.data.global_var.value, vardesc)</a>
<a name="ln1665">          == FAIL) {</a>
<a name="ln1666">        ret = kSDWriteIgnError;</a>
<a name="ln1667">        EMSG2(_(WERR &quot;Failed to write variable %s&quot;),</a>
<a name="ln1668">              entry.data.global_var.name);</a>
<a name="ln1669">        goto shada_pack_entry_error;</a>
<a name="ln1670">      }</a>
<a name="ln1671">      DUMP_ADDITIONAL_ELEMENTS(entry.data.global_var.additional_elements,</a>
<a name="ln1672">                               &quot;variable item&quot;);</a>
<a name="ln1673">      break;</a>
<a name="ln1674">    }</a>
<a name="ln1675">    case kSDItemSubString: {</a>
<a name="ln1676">      const size_t arr_size = 1 + (size_t)(</a>
<a name="ln1677">          tv_list_len(entry.data.sub_string.additional_elements));</a>
<a name="ln1678">      msgpack_pack_array(spacker, arr_size);</a>
<a name="ln1679">      PACK_BIN(cstr_as_string(entry.data.sub_string.sub));</a>
<a name="ln1680">      DUMP_ADDITIONAL_ELEMENTS(entry.data.sub_string.additional_elements,</a>
<a name="ln1681">                               &quot;sub string item&quot;);</a>
<a name="ln1682">      break;</a>
<a name="ln1683">    }</a>
<a name="ln1684">    case kSDItemSearchPattern: {</a>
<a name="ln1685">      const size_t map_size = (size_t) (</a>
<a name="ln1686">          1  // Search pattern is always present</a>
<a name="ln1687">          + ONE_IF_NOT_DEFAULT(entry, search_pattern.magic)</a>
<a name="ln1688">          + ONE_IF_NOT_DEFAULT(entry, search_pattern.is_last_used)</a>
<a name="ln1689">          + ONE_IF_NOT_DEFAULT(entry, search_pattern.smartcase)</a>
<a name="ln1690">          + ONE_IF_NOT_DEFAULT(entry, search_pattern.has_line_offset)</a>
<a name="ln1691">          + ONE_IF_NOT_DEFAULT(entry, search_pattern.place_cursor_at_end)</a>
<a name="ln1692">          + ONE_IF_NOT_DEFAULT(entry, search_pattern.is_substitute_pattern)</a>
<a name="ln1693">          + ONE_IF_NOT_DEFAULT(entry, search_pattern.highlighted)</a>
<a name="ln1694">          + ONE_IF_NOT_DEFAULT(entry, search_pattern.offset)</a>
<a name="ln1695">          + ONE_IF_NOT_DEFAULT(entry, search_pattern.search_backward)</a>
<a name="ln1696">          // finally, additional data:</a>
<a name="ln1697">          + (size_t) (</a>
<a name="ln1698">              entry.data.search_pattern.additional_data</a>
<a name="ln1699">              ? entry.data.search_pattern.additional_data-&gt;dv_hashtab.ht_used</a>
<a name="ln1700">              : 0));</a>
<a name="ln1701">      msgpack_pack_map(spacker, map_size);</a>
<a name="ln1702">      PACK_STATIC_STR(SEARCH_KEY_PAT);</a>
<a name="ln1703">      PACK_BIN(cstr_as_string(entry.data.search_pattern.pat));</a>
<a name="ln1704">#define PACK_BOOL(entry, name, attr) \</a>
<a name="ln1705">      do { \</a>
<a name="ln1706">        if (!CHECK_DEFAULT(entry, search_pattern.attr)) { \</a>
<a name="ln1707">          PACK_STATIC_STR(name); \</a>
<a name="ln1708">          if (sd_default_values[entry.type].data.search_pattern.attr) { \</a>
<a name="ln1709">            msgpack_pack_false(spacker); \</a>
<a name="ln1710">          } else { \</a>
<a name="ln1711">            msgpack_pack_true(spacker); \</a>
<a name="ln1712">          } \</a>
<a name="ln1713">        } \</a>
<a name="ln1714">      } while (0)</a>
<a name="ln1715">      PACK_BOOL(entry, SEARCH_KEY_MAGIC, magic);</a>
<a name="ln1716">      PACK_BOOL(entry, SEARCH_KEY_IS_LAST_USED, is_last_used);</a>
<a name="ln1717">      PACK_BOOL(entry, SEARCH_KEY_SMARTCASE, smartcase);</a>
<a name="ln1718">      PACK_BOOL(entry, SEARCH_KEY_HAS_LINE_OFFSET, has_line_offset);</a>
<a name="ln1719">      PACK_BOOL(entry, SEARCH_KEY_PLACE_CURSOR_AT_END, place_cursor_at_end);</a>
<a name="ln1720">      PACK_BOOL(entry, SEARCH_KEY_IS_SUBSTITUTE_PATTERN, is_substitute_pattern);</a>
<a name="ln1721">      PACK_BOOL(entry, SEARCH_KEY_HIGHLIGHTED, highlighted);</a>
<a name="ln1722">      PACK_BOOL(entry, SEARCH_KEY_BACKWARD, search_backward);</a>
<a name="ln1723">      if (!CHECK_DEFAULT(entry, search_pattern.offset)) {</a>
<a name="ln1724">        PACK_STATIC_STR(SEARCH_KEY_OFFSET);</a>
<a name="ln1725">        msgpack_pack_int64(spacker, entry.data.search_pattern.offset);</a>
<a name="ln1726">      }</a>
<a name="ln1727">#undef PACK_BOOL</a>
<a name="ln1728">      DUMP_ADDITIONAL_DATA(entry.data.search_pattern.additional_data,</a>
<a name="ln1729">                           &quot;search pattern item&quot;);</a>
<a name="ln1730">      break;</a>
<a name="ln1731">    }</a>
<a name="ln1732">    case kSDItemChange:</a>
<a name="ln1733">    case kSDItemGlobalMark:</a>
<a name="ln1734">    case kSDItemLocalMark:</a>
<a name="ln1735">    case kSDItemJump: {</a>
<a name="ln1736">      const size_t map_size = (size_t) (</a>
<a name="ln1737">          1  // File name</a>
<a name="ln1738">          + ONE_IF_NOT_DEFAULT(entry, filemark.mark.lnum)</a>
<a name="ln1739">          + ONE_IF_NOT_DEFAULT(entry, filemark.mark.col)</a>
<a name="ln1740">          + ONE_IF_NOT_DEFAULT(entry, filemark.name)</a>
<a name="ln1741">          // Additional entries, if any:</a>
<a name="ln1742">          + (size_t) (</a>
<a name="ln1743">              entry.data.filemark.additional_data == NULL</a>
<a name="ln1744">              ? 0</a>
<a name="ln1745">              : entry.data.filemark.additional_data-&gt;dv_hashtab.ht_used));</a>
<a name="ln1746">      msgpack_pack_map(spacker, map_size);</a>
<a name="ln1747">      PACK_STATIC_STR(KEY_FILE);</a>
<a name="ln1748">      PACK_BIN(cstr_as_string(entry.data.filemark.fname));</a>
<a name="ln1749">      if (!CHECK_DEFAULT(entry, filemark.mark.lnum)) {</a>
<a name="ln1750">        PACK_STATIC_STR(KEY_LNUM);</a>
<a name="ln1751">        msgpack_pack_long(spacker, entry.data.filemark.mark.lnum);</a>
<a name="ln1752">      }</a>
<a name="ln1753">      if (!CHECK_DEFAULT(entry, filemark.mark.col)) {</a>
<a name="ln1754">        PACK_STATIC_STR(KEY_COL);</a>
<a name="ln1755">        msgpack_pack_long(spacker, entry.data.filemark.mark.col);</a>
<a name="ln1756">      }</a>
<a name="ln1757">      assert(entry.type == kSDItemJump || entry.type == kSDItemChange</a>
<a name="ln1758">             ? CHECK_DEFAULT(entry, filemark.name)</a>
<a name="ln1759">             : true);</a>
<a name="ln1760">      if (!CHECK_DEFAULT(entry, filemark.name)) {</a>
<a name="ln1761">        PACK_STATIC_STR(KEY_NAME_CHAR);</a>
<a name="ln1762">        msgpack_pack_uint8(spacker, (uint8_t) entry.data.filemark.name);</a>
<a name="ln1763">      }</a>
<a name="ln1764">      DUMP_ADDITIONAL_DATA(entry.data.filemark.additional_data,</a>
<a name="ln1765">                           &quot;mark (change, jump, global or local) item&quot;);</a>
<a name="ln1766">      break;</a>
<a name="ln1767">    }</a>
<a name="ln1768">    case kSDItemRegister: {</a>
<a name="ln1769">      const size_t map_size = (size_t) (</a>
<a name="ln1770">          2  // Register contents and name</a>
<a name="ln1771">          + ONE_IF_NOT_DEFAULT(entry, reg.type)</a>
<a name="ln1772">          + ONE_IF_NOT_DEFAULT(entry, reg.width)</a>
<a name="ln1773">          + ONE_IF_NOT_DEFAULT(entry, reg.is_unnamed)</a>
<a name="ln1774">          // Additional entries, if any:</a>
<a name="ln1775">          + (size_t) (entry.data.reg.additional_data == NULL</a>
<a name="ln1776">                      ? 0</a>
<a name="ln1777">                      : entry.data.reg.additional_data-&gt;dv_hashtab.ht_used));</a>
<a name="ln1778">      msgpack_pack_map(spacker, map_size);</a>
<a name="ln1779">      PACK_STATIC_STR(REG_KEY_CONTENTS);</a>
<a name="ln1780">      msgpack_pack_array(spacker, entry.data.reg.contents_size);</a>
<a name="ln1781">      for (size_t i = 0; i &lt; entry.data.reg.contents_size; i++) {</a>
<a name="ln1782">        PACK_BIN(cstr_as_string(entry.data.reg.contents[i]));</a>
<a name="ln1783">      }</a>
<a name="ln1784">      PACK_STATIC_STR(KEY_NAME_CHAR);</a>
<a name="ln1785">      msgpack_pack_char(spacker, entry.data.reg.name);</a>
<a name="ln1786">      if (!CHECK_DEFAULT(entry, reg.type)) {</a>
<a name="ln1787">        PACK_STATIC_STR(REG_KEY_TYPE);</a>
<a name="ln1788">        msgpack_pack_uint8(spacker, (uint8_t)entry.data.reg.type);</a>
<a name="ln1789">      }</a>
<a name="ln1790">      if (!CHECK_DEFAULT(entry, reg.width)) {</a>
<a name="ln1791">        PACK_STATIC_STR(REG_KEY_WIDTH);</a>
<a name="ln1792">        msgpack_pack_uint64(spacker, (uint64_t) entry.data.reg.width);</a>
<a name="ln1793">      }</a>
<a name="ln1794">      if (!CHECK_DEFAULT(entry, reg.is_unnamed)) {</a>
<a name="ln1795">        PACK_STATIC_STR(REG_KEY_UNNAMED);</a>
<a name="ln1796">        if (entry.data.reg.is_unnamed) {</a>
<a name="ln1797">          msgpack_pack_true(spacker);</a>
<a name="ln1798">        } else {</a>
<a name="ln1799">          msgpack_pack_false(spacker);</a>
<a name="ln1800">        }</a>
<a name="ln1801">      }</a>
<a name="ln1802">      DUMP_ADDITIONAL_DATA(entry.data.reg.additional_data, &quot;register item&quot;);</a>
<a name="ln1803">      break;</a>
<a name="ln1804">    }</a>
<a name="ln1805">    case kSDItemBufferList: {</a>
<a name="ln1806">      msgpack_pack_array(spacker, entry.data.buffer_list.size);</a>
<a name="ln1807">      for (size_t i = 0; i &lt; entry.data.buffer_list.size; i++) {</a>
<a name="ln1808">        const size_t map_size = (size_t) (</a>
<a name="ln1809">            1  // Buffer name</a>
<a name="ln1810">            + (size_t) (entry.data.buffer_list.buffers[i].pos.lnum</a>
<a name="ln1811">                        != default_pos.lnum)</a>
<a name="ln1812">            + (size_t) (entry.data.buffer_list.buffers[i].pos.col</a>
<a name="ln1813">                        != default_pos.col)</a>
<a name="ln1814">            // Additional entries, if any:</a>
<a name="ln1815">            + (size_t) (</a>
<a name="ln1816">                entry.data.buffer_list.buffers[i].additional_data == NULL</a>
<a name="ln1817">                ? 0</a>
<a name="ln1818">                : (entry.data.buffer_list.buffers[i].additional_data</a>
<a name="ln1819">                   -&gt;dv_hashtab.ht_used)));</a>
<a name="ln1820">        msgpack_pack_map(spacker, map_size);</a>
<a name="ln1821">        PACK_STATIC_STR(KEY_FILE);</a>
<a name="ln1822">        PACK_BIN(cstr_as_string(entry.data.buffer_list.buffers[i].fname));</a>
<a name="ln1823">        if (entry.data.buffer_list.buffers[i].pos.lnum != 1) {</a>
<a name="ln1824">          PACK_STATIC_STR(KEY_LNUM);</a>
<a name="ln1825">          msgpack_pack_uint64(</a>
<a name="ln1826">              spacker, (uint64_t) entry.data.buffer_list.buffers[i].pos.lnum);</a>
<a name="ln1827">        }</a>
<a name="ln1828">        if (entry.data.buffer_list.buffers[i].pos.col != 0) {</a>
<a name="ln1829">          PACK_STATIC_STR(KEY_COL);</a>
<a name="ln1830">          msgpack_pack_uint64(</a>
<a name="ln1831">              spacker, (uint64_t) entry.data.buffer_list.buffers[i].pos.col);</a>
<a name="ln1832">        }</a>
<a name="ln1833">        DUMP_ADDITIONAL_DATA(entry.data.buffer_list.buffers[i].additional_data,</a>
<a name="ln1834">                             &quot;buffer list subitem&quot;);</a>
<a name="ln1835">      }</a>
<a name="ln1836">      break;</a>
<a name="ln1837">    }</a>
<a name="ln1838">    case kSDItemHeader: {</a>
<a name="ln1839">      msgpack_pack_map(spacker, entry.data.header.size);</a>
<a name="ln1840">      for (size_t i = 0; i &lt; entry.data.header.size; i++) {</a>
<a name="ln1841">        PACK_STRING(entry.data.header.items[i].key);</a>
<a name="ln1842">        const Object obj = entry.data.header.items[i].value;</a>
<a name="ln1843">        switch (obj.type) {</a>
<a name="ln1844">          case kObjectTypeString: {</a>
<a name="ln1845">            PACK_BIN(obj.data.string);</a>
<a name="ln1846">            break;</a>
<a name="ln1847">          }</a>
<a name="ln1848">          case kObjectTypeInteger: {</a>
<a name="ln1849">            msgpack_pack_int64(spacker, (int64_t) obj.data.integer);</a>
<a name="ln1850">            break;</a>
<a name="ln1851">          }</a>
<a name="ln1852">          default: {</a>
<a name="ln1853">            abort();</a>
<a name="ln1854">          }</a>
<a name="ln1855">        }</a>
<a name="ln1856">      }</a>
<a name="ln1857">      break;</a>
<a name="ln1858">    }</a>
<a name="ln1859">  }</a>
<a name="ln1860">#undef CHECK_DEFAULT</a>
<a name="ln1861">#undef ONE_IF_NOT_DEFAULT</a>
<a name="ln1862">  if (!max_kbyte || sbuf.size &lt;= max_kbyte * 1024) {</a>
<a name="ln1863">    if (entry.type == kSDItemUnknown) {</a>
<a name="ln1864">      if (msgpack_pack_uint64(packer, entry.data.unknown_item.type) == -1) {</a>
<a name="ln1865">        goto shada_pack_entry_error;</a>
<a name="ln1866">      }</a>
<a name="ln1867">    } else {</a>
<a name="ln1868">      if (msgpack_pack_uint64(packer, (uint64_t) entry.type) == -1) {</a>
<a name="ln1869">        goto shada_pack_entry_error;</a>
<a name="ln1870">      }</a>
<a name="ln1871">    }</a>
<a name="ln1872">    if (msgpack_pack_uint64(packer, (uint64_t) entry.timestamp) == -1) {</a>
<a name="ln1873">      goto shada_pack_entry_error;</a>
<a name="ln1874">    }</a>
<a name="ln1875">    if (sbuf.size &gt; 0) {</a>
<a name="ln1876">      if ((msgpack_pack_uint64(packer, (uint64_t) sbuf.size) == -1)</a>
<a name="ln1877">          || (packer-&gt;callback(packer-&gt;data, sbuf.data,</a>
<a name="ln1878">                               (unsigned) sbuf.size) == -1)) {</a>
<a name="ln1879">        goto shada_pack_entry_error;</a>
<a name="ln1880">      }</a>
<a name="ln1881">    }</a>
<a name="ln1882">  }</a>
<a name="ln1883">  msgpack_packer_free(spacker);</a>
<a name="ln1884">  msgpack_sbuffer_destroy(&amp;sbuf);</a>
<a name="ln1885">  return kSDWriteSuccessfull;</a>
<a name="ln1886">shada_pack_entry_error:</a>
<a name="ln1887">  msgpack_packer_free(spacker);</a>
<a name="ln1888">  msgpack_sbuffer_destroy(&amp;sbuf);</a>
<a name="ln1889">  return ret;</a>
<a name="ln1890">}</a>
<a name="ln1891">#undef PACK_STRING</a>
<a name="ln1892"> </a>
<a name="ln1893">/// Write single ShaDa entry and free it afterwards</a>
<a name="ln1894">///</a>
<a name="ln1895">/// Will not free if entry could not be freed.</a>
<a name="ln1896">///</a>
<a name="ln1897">/// @param[in]  packer     Packer used to write entry.</a>
<a name="ln1898">/// @param[in]  entry      Entry written.</a>
<a name="ln1899">/// @param[in]  max_kbyte  Maximum size of an item in KiB. Zero means no</a>
<a name="ln1900">///                        restrictions.</a>
<a name="ln1901">static inline ShaDaWriteResult shada_pack_pfreed_entry(</a>
<a name="ln1902">    msgpack_packer *const packer, PossiblyFreedShadaEntry entry,</a>
<a name="ln1903">    const size_t max_kbyte)</a>
<a name="ln1904">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_ALWAYS_INLINE</a>
<a name="ln1905">{</a>
<a name="ln1906">  ShaDaWriteResult ret = kSDWriteSuccessfull;</a>
<a name="ln1907">  ret = shada_pack_entry(packer, entry.data, max_kbyte);</a>
<a name="ln1908">  if (entry.can_free_entry) {</a>
<a name="ln1909">    shada_free_shada_entry(&amp;entry.data);</a>
<a name="ln1910">  }</a>
<a name="ln1911">  return ret;</a>
<a name="ln1912">}</a>
<a name="ln1913"> </a>
<a name="ln1914">/// Compare two FileMarks structure to order them by greatest_timestamp</a>
<a name="ln1915">///</a>
<a name="ln1916">/// Order is reversed: structure with greatest greatest_timestamp comes first.</a>
<a name="ln1917">/// Function signature is compatible with qsort.</a>
<a name="ln1918">static int compare_file_marks(const void *a, const void *b)</a>
<a name="ln1919">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln1920">{</a>
<a name="ln1921">  const FileMarks *const *const a_fms = a;</a>
<a name="ln1922">  const FileMarks *const *const b_fms = b;</a>
<a name="ln1923">  return ((*a_fms)-&gt;greatest_timestamp == (*b_fms)-&gt;greatest_timestamp</a>
<a name="ln1924">          ? 0</a>
<a name="ln1925">          : ((*a_fms)-&gt;greatest_timestamp &gt; (*b_fms)-&gt;greatest_timestamp</a>
<a name="ln1926">             ? -1</a>
<a name="ln1927">             : 1));</a>
<a name="ln1928">}</a>
<a name="ln1929"> </a>
<a name="ln1930">/// Parse msgpack object that has given length</a>
<a name="ln1931">///</a>
<a name="ln1932">/// @param[in]   sd_reader     Structure containing file reader definition.</a>
<a name="ln1933">/// @param[in]   length        Object length.</a>
<a name="ln1934">/// @param[out]  ret_unpacked  Location where read result should be saved. If</a>
<a name="ln1935">///                            NULL then unpacked data will be freed. Must be</a>
<a name="ln1936">///                            NULL if `ret_buf` is NULL.</a>
<a name="ln1937">/// @param[out]  ret_buf       Buffer containing parsed string.</a>
<a name="ln1938">///</a>
<a name="ln1939">/// @return kSDReadStatusNotShaDa, kSDReadStatusReadError or</a>
<a name="ln1940">///         kSDReadStatusSuccess.</a>
<a name="ln1941">static inline ShaDaReadResult shada_parse_msgpack(</a>
<a name="ln1942">    ShaDaReadDef *const sd_reader, const size_t length,</a>
<a name="ln1943">    msgpack_unpacked *ret_unpacked, char **const ret_buf)</a>
<a name="ln1944">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln1945">{</a>
<a name="ln1946">  const uintmax_t initial_fpos = sd_reader-&gt;fpos;</a>
<a name="ln1947">  char *const buf = xmalloc(length);</a>
<a name="ln1948"> </a>
<a name="ln1949">  const ShaDaReadResult fl_ret = fread_len(sd_reader, buf, length);</a>
<a name="ln1950">  if (fl_ret != kSDReadStatusSuccess) {</a>
<a name="ln1951">    xfree(buf);</a>
<a name="ln1952">    return fl_ret;</a>
<a name="ln1953">  }</a>
<a name="ln1954">  bool did_try_to_free = false;</a>
<a name="ln1955">shada_parse_msgpack_read_next: {}</a>
<a name="ln1956">  size_t off = 0;</a>
<a name="ln1957">  msgpack_unpacked unpacked;</a>
<a name="ln1958">  msgpack_unpacked_init(&amp;unpacked);</a>
<a name="ln1959">  const msgpack_unpack_return result =</a>
<a name="ln1960">      msgpack_unpack_next(&amp;unpacked, buf, length, &amp;off);</a>
<a name="ln1961">  ShaDaReadResult ret = kSDReadStatusSuccess;</a>
<a name="ln1962">  switch (result) {</a>
<a name="ln1963">    case MSGPACK_UNPACK_SUCCESS: {</a>
<a name="ln1964">      if (off &lt; length) {</a>
<a name="ln1965">        goto shada_parse_msgpack_extra_bytes;</a>
<a name="ln1966">      }</a>
<a name="ln1967">      break;</a>
<a name="ln1968">    }</a>
<a name="ln1969">    case MSGPACK_UNPACK_PARSE_ERROR: {</a>
<a name="ln1970">      emsgf(_(RCERR &quot;Failed to parse ShaDa file due to a msgpack parser error &quot;</a>
<a name="ln1971">              &quot;at position %&quot; PRIu64),</a>
<a name="ln1972">            (uint64_t) initial_fpos);</a>
<a name="ln1973">      ret = kSDReadStatusNotShaDa;</a>
<a name="ln1974">      break;</a>
<a name="ln1975">    }</a>
<a name="ln1976">    case MSGPACK_UNPACK_NOMEM_ERROR: {</a>
<a name="ln1977">      if (!did_try_to_free) {</a>
<a name="ln1978">        did_try_to_free = true;</a>
<a name="ln1979">        try_to_free_memory();</a>
<a name="ln1980">        goto shada_parse_msgpack_read_next;</a>
<a name="ln1981">      }</a>
<a name="ln1982">      EMSG(_(e_outofmem));</a>
<a name="ln1983">      ret = kSDReadStatusReadError;</a>
<a name="ln1984">      break;</a>
<a name="ln1985">    }</a>
<a name="ln1986">    case MSGPACK_UNPACK_CONTINUE: {</a>
<a name="ln1987">      emsgf(_(RCERR &quot;Failed to parse ShaDa file: incomplete msgpack string &quot;</a>
<a name="ln1988">              &quot;at position %&quot; PRIu64),</a>
<a name="ln1989">            (uint64_t) initial_fpos);</a>
<a name="ln1990">      ret = kSDReadStatusNotShaDa;</a>
<a name="ln1991">      break;</a>
<a name="ln1992">    }</a>
<a name="ln1993">    case MSGPACK_UNPACK_EXTRA_BYTES: {</a>
<a name="ln1994">shada_parse_msgpack_extra_bytes:</a>
<a name="ln1995">      emsgf(_(RCERR &quot;Failed to parse ShaDa file: extra bytes in msgpack string &quot;</a>
<a name="ln1996">              &quot;at position %&quot; PRIu64),</a>
<a name="ln1997">            (uint64_t) initial_fpos);</a>
<a name="ln1998">      ret = kSDReadStatusNotShaDa;</a>
<a name="ln1999">      break;</a>
<a name="ln2000">    }</a>
<a name="ln2001">  }</a>
<a name="ln2002">  if (ret_buf != NULL &amp;&amp; ret == kSDReadStatusSuccess) {</a>
<a name="ln2003">    if (ret_unpacked == NULL) {</a>
<a name="ln2004">      msgpack_unpacked_destroy(&amp;unpacked);</a>
<a name="ln2005">    } else {</a>
<a name="ln2006">      *ret_unpacked = unpacked;</a>
<a name="ln2007">    }</a>
<a name="ln2008">    *ret_buf = buf;</a>
<a name="ln2009">  } else {</a>
<a name="ln2010">    assert(ret_buf == NULL || ret != kSDReadStatusSuccess);</a>
<a name="ln2011">    msgpack_unpacked_destroy(&amp;unpacked);</a>
<a name="ln2012">    xfree(buf);</a>
<a name="ln2013">  }</a>
<a name="ln2014">  return ret;</a>
<a name="ln2015">}</a>
<a name="ln2016"> </a>
<a name="ln2017">/// Format shada entry for debugging purposes</a>
<a name="ln2018">///</a>
<a name="ln2019">/// @param[in]  entry  ShaDa entry to format.</a>
<a name="ln2020">///</a>
<a name="ln2021">/// @return string representing ShaDa entry in a static buffer.</a>
<a name="ln2022">static const char *shada_format_entry(const ShadaEntry entry)</a>
<a name="ln2023">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_UNUSED FUNC_ATTR_NONNULL_RET</a>
<a name="ln2024">{</a>
<a name="ln2025">  static char ret[1024];</a>
<a name="ln2026">  ret[0] = 0;</a>
<a name="ln2027">  vim_snprintf(S_LEN(ret), &quot;%s&quot;, &quot;[ ] ts=%&quot; PRIu64 &quot; &quot;);</a>
<a name="ln2028">  //                         ^ Space for `can_free_entry`</a>
<a name="ln2029">  switch (entry.type) {</a>
<a name="ln2030">    case kSDItemMissing: {</a>
<a name="ln2031">      vim_snprintf_add(S_LEN(ret), &quot;Missing&quot;);</a>
<a name="ln2032">      break;</a>
<a name="ln2033">    }</a>
<a name="ln2034">    case kSDItemHeader: {</a>
<a name="ln2035">      vim_snprintf_add(S_LEN(ret), &quot;Header { TODO }&quot;);</a>
<a name="ln2036">      break;</a>
<a name="ln2037">    }</a>
<a name="ln2038">    case kSDItemBufferList: {</a>
<a name="ln2039">      vim_snprintf_add(S_LEN(ret), &quot;BufferList { TODO }&quot;);</a>
<a name="ln2040">      break;</a>
<a name="ln2041">    }</a>
<a name="ln2042">    case kSDItemUnknown: {</a>
<a name="ln2043">      vim_snprintf_add(S_LEN(ret), &quot;Unknown { TODO }&quot;);</a>
<a name="ln2044">      break;</a>
<a name="ln2045">    }</a>
<a name="ln2046">    case kSDItemSearchPattern: {</a>
<a name="ln2047">      vim_snprintf_add(S_LEN(ret), &quot;SearchPattern { TODO }&quot;);</a>
<a name="ln2048">      break;</a>
<a name="ln2049">    }</a>
<a name="ln2050">    case kSDItemSubString: {</a>
<a name="ln2051">      vim_snprintf_add(S_LEN(ret), &quot;SubString { TODO }&quot;);</a>
<a name="ln2052">      break;</a>
<a name="ln2053">    }</a>
<a name="ln2054">    case kSDItemHistoryEntry: {</a>
<a name="ln2055">      vim_snprintf_add(S_LEN(ret), &quot;HistoryEntry { TODO }&quot;);</a>
<a name="ln2056">      break;</a>
<a name="ln2057">    }</a>
<a name="ln2058">    case kSDItemRegister: {</a>
<a name="ln2059">      vim_snprintf_add(S_LEN(ret), &quot;Register { TODO }&quot;);</a>
<a name="ln2060">      break;</a>
<a name="ln2061">    }</a>
<a name="ln2062">    case kSDItemVariable: {</a>
<a name="ln2063">      vim_snprintf_add(S_LEN(ret), &quot;Variable { TODO }&quot;);</a>
<a name="ln2064">      break;</a>
<a name="ln2065">    }</a>
<a name="ln2066">#define FORMAT_MARK_ENTRY(entry_name, name_fmt, name_fmt_arg) \</a>
<a name="ln2067">    do { \</a>
<a name="ln2068">      typval_T ad_tv = { \</a>
<a name="ln2069">        .v_type = VAR_DICT, \</a>
<a name="ln2070">        .vval.v_dict = entry.data.filemark.additional_data \</a>
<a name="ln2071">      }; \</a>
<a name="ln2072">      size_t ad_len; \</a>
<a name="ln2073">      char *const ad = encode_tv2string(&amp;ad_tv, &amp;ad_len); \</a>
<a name="ln2074">      vim_snprintf_add( \</a>
<a name="ln2075">          S_LEN(ret), \</a>
<a name="ln2076">          entry_name &quot; {&quot; name_fmt &quot; file=[%zu]\&quot;%.512s\&quot;, &quot; \</a>
<a name="ln2077">          &quot;pos={l=%&quot; PRIdLINENR &quot;,c=%&quot; PRIdCOLNR &quot;,a=%&quot; PRIdCOLNR &quot;}, &quot; \</a>
<a name="ln2078">          &quot;ad={%p:[%zu]%.64s} }&quot;, \</a>
<a name="ln2079">          name_fmt_arg, \</a>
<a name="ln2080">          strlen(entry.data.filemark.fname), \</a>
<a name="ln2081">          entry.data.filemark.fname, \</a>
<a name="ln2082">          entry.data.filemark.mark.lnum, \</a>
<a name="ln2083">          entry.data.filemark.mark.col, \</a>
<a name="ln2084">          entry.data.filemark.mark.coladd, \</a>
<a name="ln2085">          (void *)entry.data.filemark.additional_data, \</a>
<a name="ln2086">          ad_len, \</a>
<a name="ln2087">          ad); \</a>
<a name="ln2088">    } while (0)</a>
<a name="ln2089">    case kSDItemGlobalMark: {</a>
<a name="ln2090">      FORMAT_MARK_ENTRY(&quot;GlobalMark&quot;, &quot; name='%c',&quot;, entry.data.filemark.name);</a>
<a name="ln2091">      break;</a>
<a name="ln2092">    }</a>
<a name="ln2093">    case kSDItemChange: {</a>
<a name="ln2094">      FORMAT_MARK_ENTRY(&quot;Change&quot;, &quot;%s&quot;, &quot;&quot;);</a>
<a name="ln2095">      break;</a>
<a name="ln2096">    }</a>
<a name="ln2097">    case kSDItemLocalMark: {</a>
<a name="ln2098">      FORMAT_MARK_ENTRY(&quot;LocalMark&quot;, &quot; name='%c',&quot;, entry.data.filemark.name);</a>
<a name="ln2099">      break;</a>
<a name="ln2100">    }</a>
<a name="ln2101">    case kSDItemJump: {</a>
<a name="ln2102">      FORMAT_MARK_ENTRY(&quot;Jump&quot;, &quot;%s&quot;, &quot;&quot;);</a>
<a name="ln2103">      break;</a>
<a name="ln2104">    }</a>
<a name="ln2105">#undef FORMAT_MARK_ENTRY</a>
<a name="ln2106">  }</a>
<a name="ln2107">  return ret;</a>
<a name="ln2108">}</a>
<a name="ln2109"> </a>
<a name="ln2110">/// Format possibly freed shada entry for debugging purposes</a>
<a name="ln2111">///</a>
<a name="ln2112">/// @param[in]  entry  ShaDa entry to format.</a>
<a name="ln2113">///</a>
<a name="ln2114">/// @return string representing ShaDa entry in a static buffer.</a>
<a name="ln2115">static const char *shada_format_pfreed_entry(</a>
<a name="ln2116">    const PossiblyFreedShadaEntry pfs_entry)</a>
<a name="ln2117">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_UNUSED FUNC_ATTR_NONNULL_RET</a>
<a name="ln2118">{</a>
<a name="ln2119">  char *ret = (char *)shada_format_entry(pfs_entry.data);</a>
<a name="ln2120">  ret[1] = (pfs_entry.can_free_entry ? 'T' : 'F');</a>
<a name="ln2121">  return ret;</a>
<a name="ln2122">}</a>
<a name="ln2123"> </a>
<a name="ln2124">/// Read and merge in ShaDa file, used when writing</a>
<a name="ln2125">///</a>
<a name="ln2126">/// @param[in]      sd_reader   Structure containing file reader definition.</a>
<a name="ln2127">/// @param[in]      srni_flags  Flags determining what to read.</a>
<a name="ln2128">/// @param[in]      max_kbyte   Maximum size of one element.</a>
<a name="ln2129">/// @param[in,out]  ret_wms     Location where results are saved.</a>
<a name="ln2130">/// @param[out]     packer      MessagePack packer for entries which are not</a>
<a name="ln2131">///                             merged.</a>
<a name="ln2132">static inline ShaDaWriteResult shada_read_when_writing(</a>
<a name="ln2133">    ShaDaReadDef *const sd_reader, const unsigned srni_flags,</a>
<a name="ln2134">    const size_t max_kbyte, WriteMergerState *const wms,</a>
<a name="ln2135">    msgpack_packer *const packer)</a>
<a name="ln2136">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2137">{</a>
<a name="ln2138">  ShaDaWriteResult ret = kSDWriteSuccessfull;</a>
<a name="ln2139">  ShadaEntry entry;</a>
<a name="ln2140">  ShaDaReadResult srni_ret;</a>
<a name="ln2141">  while ((srni_ret = shada_read_next_item(sd_reader, &amp;entry, srni_flags,</a>
<a name="ln2142">                                          max_kbyte))</a>
<a name="ln2143">         != kSDReadStatusFinished) {</a>
<a name="ln2144">    switch (srni_ret) {</a>
<a name="ln2145">      case kSDReadStatusSuccess: {</a>
<a name="ln2146">        break;</a>
<a name="ln2147">      }</a>
<a name="ln2148">      case kSDReadStatusFinished: {</a>
<a name="ln2149">        // Should be handled by the while condition.</a>
<a name="ln2150">        abort();</a>
<a name="ln2151">      }</a>
<a name="ln2152">      case kSDReadStatusNotShaDa: {</a>
<a name="ln2153">        ret = kSDWriteReadNotShada;</a>
<a name="ln2154">        FALLTHROUGH;</a>
<a name="ln2155">      }</a>
<a name="ln2156">      case kSDReadStatusReadError: {</a>
<a name="ln2157">        return ret;</a>
<a name="ln2158">      }</a>
<a name="ln2159">      case kSDReadStatusMalformed: {</a>
<a name="ln2160">        continue;</a>
<a name="ln2161">      }</a>
<a name="ln2162">    }</a>
<a name="ln2163">#define COMPARE_WITH_ENTRY(wms_entry_, entry) \</a>
<a name="ln2164">    do { \</a>
<a name="ln2165">      PossiblyFreedShadaEntry *const wms_entry = (wms_entry_); \</a>
<a name="ln2166">      if (wms_entry-&gt;data.type != kSDItemMissing) { \</a>
<a name="ln2167">        if (wms_entry-&gt;data.timestamp &gt;= (entry).timestamp) { \</a>
<a name="ln2168">          shada_free_shada_entry(&amp;(entry)); \</a>
<a name="ln2169">          break; \</a>
<a name="ln2170">        } \</a>
<a name="ln2171">        if (wms_entry-&gt;can_free_entry) { \</a>
<a name="ln2172">          shada_free_shada_entry(&amp;wms_entry-&gt;data); \</a>
<a name="ln2173">        } \</a>
<a name="ln2174">      } \</a>
<a name="ln2175">      *wms_entry = pfs_entry; \</a>
<a name="ln2176">    } while (0)</a>
<a name="ln2177">    const PossiblyFreedShadaEntry pfs_entry = {</a>
<a name="ln2178">      .can_free_entry = true,</a>
<a name="ln2179">      .data = entry,</a>
<a name="ln2180">    };</a>
<a name="ln2181">    switch (entry.type) {</a>
<a name="ln2182">      case kSDItemMissing: {</a>
<a name="ln2183">        break;</a>
<a name="ln2184">      }</a>
<a name="ln2185">      case kSDItemHeader:</a>
<a name="ln2186">      case kSDItemBufferList: {</a>
<a name="ln2187">        abort();</a>
<a name="ln2188">      }</a>
<a name="ln2189">      case kSDItemUnknown: {</a>
<a name="ln2190">        ret = shada_pack_entry(packer, entry, 0);</a>
<a name="ln2191">        shada_free_shada_entry(&amp;entry);</a>
<a name="ln2192">        break;</a>
<a name="ln2193">      }</a>
<a name="ln2194">      case kSDItemSearchPattern: {</a>
<a name="ln2195">        COMPARE_WITH_ENTRY((entry.data.search_pattern.is_substitute_pattern</a>
<a name="ln2196">                            ? &amp;wms-&gt;sub_search_pattern</a>
<a name="ln2197">                            : &amp;wms-&gt;search_pattern), entry);</a>
<a name="ln2198">        break;</a>
<a name="ln2199">      }</a>
<a name="ln2200">      case kSDItemSubString: {</a>
<a name="ln2201">        COMPARE_WITH_ENTRY(&amp;wms-&gt;replacement, entry);</a>
<a name="ln2202">        break;</a>
<a name="ln2203">      }</a>
<a name="ln2204">      case kSDItemHistoryEntry: {</a>
<a name="ln2205">        if (entry.data.history_item.histtype &gt;= HIST_COUNT) {</a>
<a name="ln2206">          ret = shada_pack_entry(packer, entry, 0);</a>
<a name="ln2207">          shada_free_shada_entry(&amp;entry);</a>
<a name="ln2208">          break;</a>
<a name="ln2209">        }</a>
<a name="ln2210">        if (wms-&gt;hms[entry.data.history_item.histtype].hmll.size != 0) {</a>
<a name="ln2211">          hms_insert(&amp;wms-&gt;hms[entry.data.history_item.histtype], entry, true,</a>
<a name="ln2212">                     true);</a>
<a name="ln2213">        } else {</a>
<a name="ln2214">          shada_free_shada_entry(&amp;entry);</a>
<a name="ln2215">        }</a>
<a name="ln2216">        break;</a>
<a name="ln2217">      }</a>
<a name="ln2218">      case kSDItemRegister: {</a>
<a name="ln2219">        const int idx = op_reg_index(entry.data.reg.name);</a>
<a name="ln2220">        if (idx &lt; 0) {</a>
<a name="ln2221">          ret = shada_pack_entry(packer, entry, 0);</a>
<a name="ln2222">          shada_free_shada_entry(&amp;entry);</a>
<a name="ln2223">          break;</a>
<a name="ln2224">        }</a>
<a name="ln2225">        COMPARE_WITH_ENTRY(&amp;wms-&gt;registers[idx], entry);</a>
<a name="ln2226">        break;</a>
<a name="ln2227">      }</a>
<a name="ln2228">      case kSDItemVariable: {</a>
<a name="ln2229">        if (!in_strset(&amp;wms-&gt;dumped_variables, entry.data.global_var.name)) {</a>
<a name="ln2230">          ret = shada_pack_entry(packer, entry, 0);</a>
<a name="ln2231">        }</a>
<a name="ln2232">        shada_free_shada_entry(&amp;entry);</a>
<a name="ln2233">        break;</a>
<a name="ln2234">      }</a>
<a name="ln2235">      case kSDItemGlobalMark: {</a>
<a name="ln2236">        if (ascii_isdigit(entry.data.filemark.name)) {</a>
<a name="ln2237">          bool processed_mark = false;</a>
<a name="ln2238">          // Completely ignore numbered mark names, make a list sorted by</a>
<a name="ln2239">          // timestamp.</a>
<a name="ln2240">          for (size_t i = ARRAY_SIZE(wms-&gt;numbered_marks); i &gt; 0; i--) {</a>
<a name="ln2241">            ShadaEntry wms_entry = wms-&gt;numbered_marks[i - 1].data;</a>
<a name="ln2242">            if (wms_entry.type != kSDItemGlobalMark) {</a>
<a name="ln2243">              continue;</a>
<a name="ln2244">            }</a>
<a name="ln2245">            // Ignore duplicates.</a>
<a name="ln2246">            if (wms_entry.timestamp == entry.timestamp</a>
<a name="ln2247">                &amp;&amp; (wms_entry.data.filemark.additional_data == NULL</a>
<a name="ln2248">                    &amp;&amp; entry.data.filemark.additional_data == NULL)</a>
<a name="ln2249">                &amp;&amp; marks_equal(wms_entry.data.filemark.mark,</a>
<a name="ln2250">                               entry.data.filemark.mark)</a>
<a name="ln2251">                &amp;&amp; strcmp(wms_entry.data.filemark.fname,</a>
<a name="ln2252">                          entry.data.filemark.fname) == 0) {</a>
<a name="ln2253">              shada_free_shada_entry(&amp;entry);</a>
<a name="ln2254">              processed_mark = true;</a>
<a name="ln2255">              break;</a>
<a name="ln2256">            }</a>
<a name="ln2257">            if (wms_entry.timestamp &gt;= entry.timestamp) {</a>
<a name="ln2258">              processed_mark = true;</a>
<a name="ln2259">              if (i &lt; ARRAY_SIZE(wms-&gt;numbered_marks)) {</a>
<a name="ln2260">                replace_numbered_mark(wms, i, pfs_entry);</a>
<a name="ln2261">              } else {</a>
<a name="ln2262">                shada_free_shada_entry(&amp;entry);</a>
<a name="ln2263">              }</a>
<a name="ln2264">              break;</a>
<a name="ln2265">            }</a>
<a name="ln2266">          }</a>
<a name="ln2267">          if (!processed_mark) {</a>
<a name="ln2268">            replace_numbered_mark(wms, 0, pfs_entry);</a>
<a name="ln2269">          }</a>
<a name="ln2270">        } else {</a>
<a name="ln2271">          const int idx = mark_global_index(entry.data.filemark.name);</a>
<a name="ln2272">          if (idx &lt; 0) {</a>
<a name="ln2273">            ret = shada_pack_entry(packer, entry, 0);</a>
<a name="ln2274">            shada_free_shada_entry(&amp;entry);</a>
<a name="ln2275">            break;</a>
<a name="ln2276">          }</a>
<a name="ln2277">          COMPARE_WITH_ENTRY(&amp;wms-&gt;global_marks[idx], entry);</a>
<a name="ln2278">        }</a>
<a name="ln2279">        break;</a>
<a name="ln2280">      }</a>
<a name="ln2281">      case kSDItemChange:</a>
<a name="ln2282">      case kSDItemLocalMark: {</a>
<a name="ln2283">        if (shada_removable(entry.data.filemark.fname)) {</a>
<a name="ln2284">          shada_free_shada_entry(&amp;entry);</a>
<a name="ln2285">          break;</a>
<a name="ln2286">        }</a>
<a name="ln2287">        const char *const fname = (const char *) entry.data.filemark.fname;</a>
<a name="ln2288">        khiter_t k;</a>
<a name="ln2289">        int kh_ret;</a>
<a name="ln2290">        k = kh_put(file_marks, &amp;wms-&gt;file_marks, fname, &amp;kh_ret);</a>
<a name="ln2291">        FileMarks *const filemarks = &amp;kh_val(&amp;wms-&gt;file_marks, k);</a>
<a name="ln2292">        if (kh_ret &gt; 0) {</a>
<a name="ln2293">          memset(filemarks, 0, sizeof(*filemarks));</a>
<a name="ln2294">        }</a>
<a name="ln2295">        if (entry.timestamp &gt; filemarks-&gt;greatest_timestamp) {</a>
<a name="ln2296">          filemarks-&gt;greatest_timestamp = entry.timestamp;</a>
<a name="ln2297">        }</a>
<a name="ln2298">        if (entry.type == kSDItemLocalMark) {</a>
<a name="ln2299">          const int idx = mark_local_index(entry.data.filemark.name);</a>
<a name="ln2300">          if (idx &lt; 0) {</a>
<a name="ln2301">            filemarks-&gt;additional_marks = xrealloc(</a>
<a name="ln2302">                filemarks-&gt;additional_marks,</a>
<a name="ln2303">                (++filemarks-&gt;additional_marks_size</a>
<a name="ln2304">                 * sizeof(filemarks-&gt;additional_marks[0])));</a>
<a name="ln2305">            filemarks-&gt;additional_marks[filemarks-&gt;additional_marks_size - 1] =</a>
<a name="ln2306">                entry;</a>
<a name="ln2307">          } else {</a>
<a name="ln2308">            PossiblyFreedShadaEntry *const wms_entry = &amp;filemarks-&gt;marks[idx];</a>
<a name="ln2309">            if (wms_entry-&gt;data.type != kSDItemMissing) {</a>
<a name="ln2310">              if (wms_entry-&gt;data.timestamp &gt;= entry.timestamp) {</a>
<a name="ln2311">                shada_free_shada_entry(&amp;entry);</a>
<a name="ln2312">                break;</a>
<a name="ln2313">              }</a>
<a name="ln2314">              if (wms_entry-&gt;can_free_entry) {</a>
<a name="ln2315">                if (kh_key(&amp;wms-&gt;file_marks, k)</a>
<a name="ln2316">                    == wms_entry-&gt;data.data.filemark.fname) {</a>
<a name="ln2317">                  kh_key(&amp;wms-&gt;file_marks, k) = entry.data.filemark.fname;</a>
<a name="ln2318">                }</a>
<a name="ln2319">                shada_free_shada_entry(&amp;wms_entry-&gt;data);</a>
<a name="ln2320">              }</a>
<a name="ln2321">            }</a>
<a name="ln2322">            *wms_entry = pfs_entry;</a>
<a name="ln2323">          }</a>
<a name="ln2324">        } else {</a>
<a name="ln2325">#define FREE_POSSIBLY_FREED_SHADA_ENTRY(entry) \</a>
<a name="ln2326">        do { \</a>
<a name="ln2327">          if (entry.can_free_entry) { \</a>
<a name="ln2328">            shada_free_shada_entry(&amp;entry.data); \</a>
<a name="ln2329">          } \</a>
<a name="ln2330">        } while (0)</a>
<a name="ln2331">#define SDE_TO_PFSDE(entry) \</a>
<a name="ln2332">        ((PossiblyFreedShadaEntry) { .can_free_entry = true, .data = entry })</a>
<a name="ln2333">#define AFTERFREE_DUMMY(entry)</a>
<a name="ln2334">#define DUMMY_IDX_ADJ(i)</a>
<a name="ln2335">          MERGE_JUMPS(filemarks-&gt;changes_size, filemarks-&gt;changes,</a>
<a name="ln2336">                      PossiblyFreedShadaEntry, data.timestamp,</a>
<a name="ln2337">                      data.data.filemark.mark, entry, true,</a>
<a name="ln2338">                      FREE_POSSIBLY_FREED_SHADA_ENTRY, SDE_TO_PFSDE,</a>
<a name="ln2339">                      DUMMY_IDX_ADJ, AFTERFREE_DUMMY);</a>
<a name="ln2340">        }</a>
<a name="ln2341">        break;</a>
<a name="ln2342">      }</a>
<a name="ln2343">      case kSDItemJump: {</a>
<a name="ln2344">        MERGE_JUMPS(wms-&gt;jumps_size, wms-&gt;jumps, PossiblyFreedShadaEntry,</a>
<a name="ln2345">                    data.timestamp, data.data.filemark.mark, entry,</a>
<a name="ln2346">                    strcmp(jl_entry.data.data.filemark.fname,</a>
<a name="ln2347">                           entry.data.filemark.fname) == 0,</a>
<a name="ln2348">                    FREE_POSSIBLY_FREED_SHADA_ENTRY, SDE_TO_PFSDE,</a>
<a name="ln2349">                    DUMMY_IDX_ADJ, AFTERFREE_DUMMY);</a>
<a name="ln2350">#undef FREE_POSSIBLY_FREED_SHADA_ENTRY</a>
<a name="ln2351">#undef SDE_TO_PFSDE</a>
<a name="ln2352">#undef DUMMY_IDX_ADJ</a>
<a name="ln2353">#undef AFTERFREE_DUMMY</a>
<a name="ln2354">        break;</a>
<a name="ln2355">      }</a>
<a name="ln2356">    }</a>
<a name="ln2357">  }</a>
<a name="ln2358">#undef COMPARE_WITH_ENTRY</a>
<a name="ln2359">  return ret;</a>
<a name="ln2360">}</a>
<a name="ln2361"> </a>
<a name="ln2362">/// Check whether buffer should be ignored</a>
<a name="ln2363">///</a>
<a name="ln2364">/// @param[in]  buf  buf_T* to check.</a>
<a name="ln2365">/// @param[in]  removable_bufs  Cache of buffers ignored due to their location.</a>
<a name="ln2366">///</a>
<a name="ln2367">/// @return true or false.</a>
<a name="ln2368">static inline bool ignore_buf(const buf_T *const buf,</a>
<a name="ln2369">                              khash_t(bufset) *const removable_bufs)</a>
<a name="ln2370">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_ALWAYS_INLINE</a>
<a name="ln2371">{</a>
<a name="ln2372">  return (buf-&gt;b_ffname == NULL || !buf-&gt;b_p_bl || bt_quickfix(buf) \</a>
<a name="ln2373">          || bt_terminal(buf) || in_bufset(removable_bufs, buf));</a>
<a name="ln2374">}</a>
<a name="ln2375"> </a>
<a name="ln2376">/// Get list of buffers to write to the shada file</a>
<a name="ln2377">///</a>
<a name="ln2378">/// @param[in]  removable_bufs  Buffers which are ignored</a>
<a name="ln2379">///</a>
<a name="ln2380">/// @return  ShadaEntry  List of buffers to save, kSDItemBufferList entry.</a>
<a name="ln2381">static inline ShadaEntry shada_get_buflist(</a>
<a name="ln2382">    khash_t(bufset) *const removable_bufs)</a>
<a name="ln2383">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_ALWAYS_INLINE</a>
<a name="ln2384">{</a>
<a name="ln2385">  int max_bufs = get_shada_parameter('%');</a>
<a name="ln2386">  size_t buf_count = 0;</a>
<a name="ln2387">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2388">    if (!ignore_buf(buf, removable_bufs)</a>
<a name="ln2389">        &amp;&amp; (max_bufs &lt; 0 || buf_count &lt; (size_t)max_bufs)) {</a>
<a name="ln2390">      buf_count++;</a>
<a name="ln2391">    }</a>
<a name="ln2392">  }</a>
<a name="ln2393"> </a>
<a name="ln2394">  ShadaEntry buflist_entry = (ShadaEntry) {</a>
<a name="ln2395">    .type = kSDItemBufferList,</a>
<a name="ln2396">      .timestamp = os_time(),</a>
<a name="ln2397">      .data = {</a>
<a name="ln2398">        .buffer_list = {</a>
<a name="ln2399">          .size = buf_count,</a>
<a name="ln2400">          .buffers = xmalloc(buf_count</a>
<a name="ln2401">                             * sizeof(*buflist_entry.data.buffer_list.buffers)),</a>
<a name="ln2402">        },</a>
<a name="ln2403">      },</a>
<a name="ln2404">  };</a>
<a name="ln2405">  size_t i = 0;</a>
<a name="ln2406">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2407">    if (ignore_buf(buf, removable_bufs)) {</a>
<a name="ln2408">      continue;</a>
<a name="ln2409">    }</a>
<a name="ln2410">    if (i &gt;= buf_count) {</a>
<a name="ln2411">      break;</a>
<a name="ln2412">    }</a>
<a name="ln2413">    buflist_entry.data.buffer_list.buffers[i] = (struct buffer_list_buffer) {</a>
<a name="ln2414">      .pos = buf-&gt;b_last_cursor.mark,</a>
<a name="ln2415">        .fname = (char *)buf-&gt;b_ffname,</a>
<a name="ln2416">        .additional_data = buf-&gt;additional_data,</a>
<a name="ln2417">    };</a>
<a name="ln2418">    i++;</a>
<a name="ln2419">  }</a>
<a name="ln2420"> </a>
<a name="ln2421">  return buflist_entry;</a>
<a name="ln2422">}</a>
<a name="ln2423"> </a>
<a name="ln2424">/// Save search pattern to PossiblyFreedShadaEntry</a>
<a name="ln2425">///</a>
<a name="ln2426">/// @param[out]  ret_pse  Location where result will be saved.</a>
<a name="ln2427">/// @param[in]  get_pattern  Function used to get pattern.</a>
<a name="ln2428">/// @param[in]  is_substitute_pattern  True if pattern in question is substitute</a>
<a name="ln2429">///                                    pattern. Also controls whether some</a>
<a name="ln2430">///                                    fields should be initialized to default</a>
<a name="ln2431">///                                    or values from get_pattern.</a>
<a name="ln2432">/// @param[in]  search_last_used  Result of search_was_last_used().</a>
<a name="ln2433">/// @param[in]  search_highlighted  True if search pattern was highlighted by</a>
<a name="ln2434">///                                 &amp;hlsearch and this information should be</a>
<a name="ln2435">///                                 saved.</a>
<a name="ln2436">static inline void add_search_pattern(PossiblyFreedShadaEntry *const ret_pse,</a>
<a name="ln2437">                                      const SearchPatternGetter get_pattern,</a>
<a name="ln2438">                                      const bool is_substitute_pattern,</a>
<a name="ln2439">                                      const bool search_last_used,</a>
<a name="ln2440">                                      const bool search_highlighted)</a>
<a name="ln2441">  FUNC_ATTR_ALWAYS_INLINE</a>
<a name="ln2442">{</a>
<a name="ln2443">  const ShadaEntry defaults = sd_default_values[kSDItemSearchPattern];</a>
<a name="ln2444">  SearchPattern pat;</a>
<a name="ln2445">  get_pattern(&amp;pat);</a>
<a name="ln2446">  if (pat.pat != NULL) {</a>
<a name="ln2447">    *ret_pse = (PossiblyFreedShadaEntry) {</a>
<a name="ln2448">      .can_free_entry = false,</a>
<a name="ln2449">      .data = {</a>
<a name="ln2450">        .type = kSDItemSearchPattern,</a>
<a name="ln2451">        .timestamp = pat.timestamp,</a>
<a name="ln2452">        .data = {</a>
<a name="ln2453">          .search_pattern = {</a>
<a name="ln2454">            .magic = pat.magic,</a>
<a name="ln2455">            .smartcase = !pat.no_scs,</a>
<a name="ln2456">            .has_line_offset = (is_substitute_pattern</a>
<a name="ln2457">                                ? defaults.data.search_pattern.has_line_offset</a>
<a name="ln2458">                                : pat.off.line),</a>
<a name="ln2459">            .place_cursor_at_end = (</a>
<a name="ln2460">                is_substitute_pattern</a>
<a name="ln2461">                ? defaults.data.search_pattern.place_cursor_at_end</a>
<a name="ln2462">                : pat.off.end),</a>
<a name="ln2463">            .offset = (is_substitute_pattern</a>
<a name="ln2464">                       ? defaults.data.search_pattern.offset</a>
<a name="ln2465">                       : pat.off.off),</a>
<a name="ln2466">            .is_last_used = (is_substitute_pattern ^ search_last_used),</a>
<a name="ln2467">            .is_substitute_pattern = is_substitute_pattern,</a>
<a name="ln2468">            .highlighted = ((is_substitute_pattern ^ search_last_used)</a>
<a name="ln2469">                            &amp;&amp; search_highlighted),</a>
<a name="ln2470">            .pat = (char *)pat.pat,</a>
<a name="ln2471">            .additional_data = pat.additional_data,</a>
<a name="ln2472">            .search_backward = (!is_substitute_pattern &amp;&amp; pat.off.dir == '?'),</a>
<a name="ln2473">          }</a>
<a name="ln2474">        }</a>
<a name="ln2475">      }</a>
<a name="ln2476">    };</a>
<a name="ln2477">  }</a>
<a name="ln2478">}</a>
<a name="ln2479"> </a>
<a name="ln2480">/// Initialize registers for writing to the ShaDa file</a>
<a name="ln2481">///</a>
<a name="ln2482">/// @param[in]  wms  The WriteMergerState used when writing.</a>
<a name="ln2483">/// @param[in]  max_reg_lines  The maximum number of register lines.</a>
<a name="ln2484">static inline void shada_initialize_registers(WriteMergerState *const wms,</a>
<a name="ln2485">                                              int max_reg_lines)</a>
<a name="ln2486">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_ALWAYS_INLINE</a>
<a name="ln2487">{</a>
<a name="ln2488">  const void *reg_iter = NULL;</a>
<a name="ln2489">  const bool limit_reg_lines = max_reg_lines &gt;= 0;</a>
<a name="ln2490">  do {</a>
<a name="ln2491">    yankreg_T reg;</a>
<a name="ln2492">    char name = NUL;</a>
<a name="ln2493">    bool is_unnamed = false;</a>
<a name="ln2494">    reg_iter = op_global_reg_iter(reg_iter, &amp;name, &amp;reg, &amp;is_unnamed);</a>
<a name="ln2495">    if (name == NUL) {</a>
<a name="ln2496">      break;</a>
<a name="ln2497">    }</a>
<a name="ln2498">    if (limit_reg_lines &amp;&amp; reg.y_size &gt; (size_t)max_reg_lines) {</a>
<a name="ln2499">      continue;</a>
<a name="ln2500">    }</a>
<a name="ln2501">    wms-&gt;registers[op_reg_index(name)] = (PossiblyFreedShadaEntry) {</a>
<a name="ln2502">      .can_free_entry = false,</a>
<a name="ln2503">      .data = {</a>
<a name="ln2504">        .type = kSDItemRegister,</a>
<a name="ln2505">        .timestamp = reg.timestamp,</a>
<a name="ln2506">        .data = {</a>
<a name="ln2507">          .reg = {</a>
<a name="ln2508">            .contents = (char **)reg.y_array,</a>
<a name="ln2509">            .contents_size = (size_t)reg.y_size,</a>
<a name="ln2510">            .type = reg.y_type,</a>
<a name="ln2511">            .width = (size_t)(reg.y_type == kMTBlockWise ? reg.y_width : 0),</a>
<a name="ln2512">            .additional_data = reg.additional_data,</a>
<a name="ln2513">            .name = name,</a>
<a name="ln2514">            .is_unnamed = is_unnamed,</a>
<a name="ln2515">          }</a>
<a name="ln2516">        }</a>
<a name="ln2517">      }</a>
<a name="ln2518">    };</a>
<a name="ln2519">  } while (reg_iter != NULL);</a>
<a name="ln2520">}</a>
<a name="ln2521"> </a>
<a name="ln2522">/// Replace numbered mark in WriteMergerState</a>
<a name="ln2523">///</a>
<a name="ln2524">/// Frees the last mark, moves (including adjusting mark names) marks from idx</a>
<a name="ln2525">/// to the last-but-one one and saves the new mark at given index.</a>
<a name="ln2526">///</a>
<a name="ln2527">/// @param[out]  wms  Merger state to adjust.</a>
<a name="ln2528">/// @param[in]  idx  Index at which new mark should be placed.</a>
<a name="ln2529">/// @param[in]  entry  New mark.</a>
<a name="ln2530">static inline void replace_numbered_mark(WriteMergerState *const wms,</a>
<a name="ln2531">                                         const size_t idx,</a>
<a name="ln2532">                                         const PossiblyFreedShadaEntry entry)</a>
<a name="ln2533">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_ALWAYS_INLINE</a>
<a name="ln2534">{</a>
<a name="ln2535">  if (ARRAY_LAST_ENTRY(wms-&gt;numbered_marks).can_free_entry) {</a>
<a name="ln2536">    shada_free_shada_entry(&amp;ARRAY_LAST_ENTRY(wms-&gt;numbered_marks).data);</a>
<a name="ln2537">  }</a>
<a name="ln2538">  for (size_t i = idx; i &lt; ARRAY_SIZE(wms-&gt;numbered_marks) - 1; i++) {</a>
<a name="ln2539">    if (wms-&gt;numbered_marks[i].data.type == kSDItemGlobalMark) {</a>
<a name="ln2540">      wms-&gt;numbered_marks[i].data.data.filemark.name = (char)('0' + (int)i + 1);</a>
<a name="ln2541">    }</a>
<a name="ln2542">  }</a>
<a name="ln2543">  memmove(wms-&gt;numbered_marks + idx + 1, wms-&gt;numbered_marks + idx,</a>
<a name="ln2544">          sizeof(wms-&gt;numbered_marks[0])</a>
<a name="ln2545">          * (ARRAY_SIZE(wms-&gt;numbered_marks) - 1 - idx));</a>
<a name="ln2546">  wms-&gt;numbered_marks[idx] = entry;</a>
<a name="ln2547">  wms-&gt;numbered_marks[idx].data.data.filemark.name = (char)('0' + (int)idx);</a>
<a name="ln2548">}</a>
<a name="ln2549"> </a>
<a name="ln2550">/// Find buffers ignored due to their location.</a>
<a name="ln2551">///</a>
<a name="ln2552">/// @param[out]  removable_bufs  Cache of buffers ignored due to their location.</a>
<a name="ln2553">static inline void find_removable_bufs(khash_t(bufset) *removable_bufs)</a>
<a name="ln2554">{</a>
<a name="ln2555">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2556">    if (buf-&gt;b_ffname != NULL &amp;&amp; shada_removable((char *)buf-&gt;b_ffname)) {</a>
<a name="ln2557">      int kh_ret;</a>
<a name="ln2558">      (void)kh_put(bufset, removable_bufs, (uintptr_t)buf, &amp;kh_ret);</a>
<a name="ln2559">    }</a>
<a name="ln2560">  }</a>
<a name="ln2561">}</a>
<a name="ln2562"> </a>
<a name="ln2563">/// Write ShaDa file</a>
<a name="ln2564">///</a>
<a name="ln2565">/// @param[in]  sd_writer  Structure containing file writer definition.</a>
<a name="ln2566">/// @param[in]  sd_reader  Structure containing file reader definition. If it is</a>
<a name="ln2567">///                        not NULL then contents of this file will be merged</a>
<a name="ln2568">///                        with current Neovim runtime.</a>
<a name="ln2569">static ShaDaWriteResult shada_write(ShaDaWriteDef *const sd_writer,</a>
<a name="ln2570">                                    ShaDaReadDef *const sd_reader)</a>
<a name="ln2571">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln2572">{</a>
<a name="ln2573">  ShaDaWriteResult ret = kSDWriteSuccessfull;</a>
<a name="ln2574">  int max_kbyte_i = get_shada_parameter('s');</a>
<a name="ln2575">  if (max_kbyte_i &lt; 0) {</a>
<a name="ln2576">    max_kbyte_i = 10;</a>
<a name="ln2577">  }</a>
<a name="ln2578">  if (max_kbyte_i == 0) {</a>
<a name="ln2579">    return ret;</a>
<a name="ln2580">  }</a>
<a name="ln2581"> </a>
<a name="ln2582">  WriteMergerState *const wms = xcalloc(1, sizeof(*wms));</a>
<a name="ln2583">  bool dump_one_history[HIST_COUNT];</a>
<a name="ln2584">  const bool dump_global_vars = (find_shada_parameter('!') != NULL);</a>
<a name="ln2585">  int max_reg_lines = get_shada_parameter('&lt;');</a>
<a name="ln2586">  if (max_reg_lines &lt; 0) {</a>
<a name="ln2587">    max_reg_lines = get_shada_parameter('&quot;');</a>
<a name="ln2588">  }</a>
<a name="ln2589">  const bool dump_registers = (max_reg_lines != 0);</a>
<a name="ln2590">  khash_t(bufset) removable_bufs = KHASH_EMPTY_TABLE(bufset);</a>
<a name="ln2591">  const size_t max_kbyte = (size_t) max_kbyte_i;</a>
<a name="ln2592">  const size_t num_marked_files = (size_t) get_shada_parameter('\'');</a>
<a name="ln2593">  const bool dump_global_marks = get_shada_parameter('f') != 0;</a>
<a name="ln2594">  bool dump_history = false;</a>
<a name="ln2595"> </a>
<a name="ln2596">  // Initialize history merger</a>
<a name="ln2597">  for (uint8_t i = 0; i &lt; HIST_COUNT; i++) {</a>
<a name="ln2598">    long num_saved = get_shada_parameter(hist_type2char(i));</a>
<a name="ln2599">    if (num_saved == -1) {</a>
<a name="ln2600">      num_saved = p_hi;</a>
<a name="ln2601">    }</a>
<a name="ln2602">    if (num_saved &gt; 0) {</a>
<a name="ln2603">      dump_history = true;</a>
<a name="ln2604">      dump_one_history[i] = true;</a>
<a name="ln2605">      hms_init(&amp;wms-&gt;hms[i], i, (size_t) num_saved, sd_reader != NULL, false);</a>
<a name="ln2606">    } else {</a>
<a name="ln2607">      dump_one_history[i] = false;</a>
<a name="ln2608">    }</a>
<a name="ln2609">  }</a>
<a name="ln2610"> </a>
<a name="ln2611">  const unsigned srni_flags = (unsigned) (</a>
<a name="ln2612">      kSDReadUndisableableData</a>
<a name="ln2613">      | kSDReadUnknown</a>
<a name="ln2614">      | (dump_history ? kSDReadHistory : 0)</a>
<a name="ln2615">      | (dump_registers ? kSDReadRegisters : 0)</a>
<a name="ln2616">      | (dump_global_vars ? kSDReadVariables : 0)</a>
<a name="ln2617">      | (dump_global_marks ? kSDReadGlobalMarks : 0)</a>
<a name="ln2618">      | (num_marked_files ? kSDReadLocalMarks | kSDReadChanges : 0));</a>
<a name="ln2619"> </a>
<a name="ln2620">  msgpack_packer *const packer = msgpack_packer_new(sd_writer,</a>
<a name="ln2621">                                                    &amp;msgpack_sd_writer_write);</a>
<a name="ln2622"> </a>
<a name="ln2623">  // Set b_last_cursor for all the buffers that have a window.</a>
<a name="ln2624">  //</a>
<a name="ln2625">  // It is needed to correctly save '&quot;' mark on exit. Has a side effect of</a>
<a name="ln2626">  // setting '&quot;' mark in all windows on :wshada to the current cursor</a>
<a name="ln2627">  // position (basically what :wviminfo used to do).</a>
<a name="ln2628">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln2629">    set_last_cursor(wp);</a>
<a name="ln2630">  }</a>
<a name="ln2631"> </a>
<a name="ln2632">  find_removable_bufs(&amp;removable_bufs);</a>
<a name="ln2633"> </a>
<a name="ln2634">  // Write header</a>
<a name="ln2635">  if (shada_pack_entry(packer, (ShadaEntry) {</a>
<a name="ln2636">    .type = kSDItemHeader,</a>
<a name="ln2637">    .timestamp = os_time(),</a>
<a name="ln2638">    .data = {</a>
<a name="ln2639">      .header = {</a>
<a name="ln2640">        .size = 5,</a>
<a name="ln2641">        .capacity = 5,</a>
<a name="ln2642">        .items = ((KeyValuePair[]) {</a>
<a name="ln2643">          { STATIC_CSTR_AS_STRING(&quot;generator&quot;),</a>
<a name="ln2644">            STRING_OBJ(STATIC_CSTR_AS_STRING(&quot;nvim&quot;)) },</a>
<a name="ln2645">          { STATIC_CSTR_AS_STRING(&quot;version&quot;),</a>
<a name="ln2646">            STRING_OBJ(cstr_as_string(longVersion)) },</a>
<a name="ln2647">          { STATIC_CSTR_AS_STRING(&quot;max_kbyte&quot;),</a>
<a name="ln2648">            INTEGER_OBJ((Integer) max_kbyte) },</a>
<a name="ln2649">          { STATIC_CSTR_AS_STRING(&quot;pid&quot;),</a>
<a name="ln2650">            INTEGER_OBJ((Integer) os_get_pid()) },</a>
<a name="ln2651">          { STATIC_CSTR_AS_STRING(&quot;encoding&quot;),</a>
<a name="ln2652">            STRING_OBJ(cstr_as_string((char *) p_enc)) },</a>
<a name="ln2653">        }),</a>
<a name="ln2654">      }</a>
<a name="ln2655">    }</a>
<a name="ln2656">  }, 0) == kSDWriteFailed) {</a>
<a name="ln2657">    ret = kSDWriteFailed;</a>
<a name="ln2658">    goto shada_write_exit;</a>
<a name="ln2659">  }</a>
<a name="ln2660"> </a>
<a name="ln2661">  // Write buffer list</a>
<a name="ln2662">  if (find_shada_parameter('%') != NULL) {</a>
<a name="ln2663">    ShadaEntry buflist_entry = shada_get_buflist(&amp;removable_bufs);</a>
<a name="ln2664">    if (shada_pack_entry(packer, buflist_entry, 0) == kSDWriteFailed) {</a>
<a name="ln2665">      xfree(buflist_entry.data.buffer_list.buffers);</a>
<a name="ln2666">      ret = kSDWriteFailed;</a>
<a name="ln2667">      goto shada_write_exit;</a>
<a name="ln2668">    }</a>
<a name="ln2669">    xfree(buflist_entry.data.buffer_list.buffers);</a>
<a name="ln2670">  }</a>
<a name="ln2671"> </a>
<a name="ln2672">  // Write some of the variables</a>
<a name="ln2673">  if (dump_global_vars) {</a>
<a name="ln2674">    const void *var_iter = NULL;</a>
<a name="ln2675">    const Timestamp cur_timestamp = os_time();</a>
<a name="ln2676">    do {</a>
<a name="ln2677">      typval_T vartv;</a>
<a name="ln2678">      const char *name = NULL;</a>
<a name="ln2679">      var_iter = var_shada_iter(var_iter, &amp;name, &amp;vartv, VAR_FLAVOUR_SHADA);</a>
<a name="ln2680">      if (name == NULL) {</a>
<a name="ln2681">        break;</a>
<a name="ln2682">      }</a>
<a name="ln2683">      switch (vartv.v_type) {</a>
<a name="ln2684">        case VAR_FUNC:</a>
<a name="ln2685">        case VAR_PARTIAL:</a>
<a name="ln2686">          tv_clear(&amp;vartv);</a>
<a name="ln2687">          continue;</a>
<a name="ln2688">        case VAR_DICT:</a>
<a name="ln2689">          {</a>
<a name="ln2690">            dict_T *di = vartv.vval.v_dict;</a>
<a name="ln2691">            int copyID = get_copyID();</a>
<a name="ln2692">            if (!set_ref_in_ht(&amp;di-&gt;dv_hashtab, copyID, NULL)</a>
<a name="ln2693">                &amp;&amp; copyID == di-&gt;dv_copyID) {</a>
<a name="ln2694">              tv_clear(&amp;vartv);</a>
<a name="ln2695">              continue;</a>
<a name="ln2696">            }</a>
<a name="ln2697">            break;</a>
<a name="ln2698">          }</a>
<a name="ln2699">        case VAR_LIST:</a>
<a name="ln2700">          {</a>
<a name="ln2701">            list_T *l = vartv.vval.v_list;</a>
<a name="ln2702">            int copyID = get_copyID();</a>
<a name="ln2703">            if (!set_ref_in_list(l, copyID, NULL)</a>
<a name="ln2704">                &amp;&amp; copyID == l-&gt;lv_copyID) {</a>
<a name="ln2705">              tv_clear(&amp;vartv);</a>
<a name="ln2706">              continue;</a>
<a name="ln2707">            }</a>
<a name="ln2708">            break;</a>
<a name="ln2709">          }</a>
<a name="ln2710">        default:</a>
<a name="ln2711">          break;</a>
<a name="ln2712">      }</a>
<a name="ln2713">      typval_T tgttv;</a>
<a name="ln2714">      tv_copy(&amp;vartv, &amp;tgttv);</a>
<a name="ln2715">      ShaDaWriteResult spe_ret;</a>
<a name="ln2716">      if ((spe_ret = shada_pack_entry(packer, (ShadaEntry) {</a>
<a name="ln2717">        .type = kSDItemVariable,</a>
<a name="ln2718">        .timestamp = cur_timestamp,</a>
<a name="ln2719">        .data = {</a>
<a name="ln2720">          .global_var = {</a>
<a name="ln2721">            .name = (char *) name,</a>
<a name="ln2722">            .value = tgttv,</a>
<a name="ln2723">            .additional_elements = NULL,</a>
<a name="ln2724">          }</a>
<a name="ln2725">        }</a>
<a name="ln2726">      }, max_kbyte)) == kSDWriteFailed) {</a>
<a name="ln2727">        tv_clear(&amp;vartv);</a>
<a name="ln2728">        tv_clear(&amp;tgttv);</a>
<a name="ln2729">        ret = kSDWriteFailed;</a>
<a name="ln2730">        goto shada_write_exit;</a>
<a name="ln2731">      }</a>
<a name="ln2732">      tv_clear(&amp;vartv);</a>
<a name="ln2733">      tv_clear(&amp;tgttv);</a>
<a name="ln2734">      if (spe_ret == kSDWriteSuccessfull) {</a>
<a name="ln2735">        int kh_ret;</a>
<a name="ln2736">        (void) kh_put(strset, &amp;wms-&gt;dumped_variables, name, &amp;kh_ret);</a>
<a name="ln2737">      }</a>
<a name="ln2738">    } while (var_iter != NULL);</a>
<a name="ln2739">  }</a>
<a name="ln2740"> </a>
<a name="ln2741">  // Initialize jump list</a>
<a name="ln2742">  setpcmark();</a>
<a name="ln2743">  cleanup_jumplist(curwin, false);</a>
<a name="ln2744">  wms-&gt;jumps_size = shada_init_jumps(wms-&gt;jumps, &amp;removable_bufs);</a>
<a name="ln2745"> </a>
<a name="ln2746">  const bool search_highlighted = !(no_hlsearch</a>
<a name="ln2747">                                    || find_shada_parameter('h') != NULL);</a>
<a name="ln2748">  const bool search_last_used = search_was_last_used();</a>
<a name="ln2749"> </a>
<a name="ln2750">  // Initialize search pattern</a>
<a name="ln2751">  add_search_pattern(&amp;wms-&gt;search_pattern, &amp;get_search_pattern, false,</a>
<a name="ln2752">                     search_last_used, search_highlighted);</a>
<a name="ln2753"> </a>
<a name="ln2754">  // Initialize substitute search pattern</a>
<a name="ln2755">  add_search_pattern(&amp;wms-&gt;sub_search_pattern, &amp;get_substitute_pattern, true,</a>
<a name="ln2756">                     search_last_used, search_highlighted);</a>
<a name="ln2757"> </a>
<a name="ln2758">  // Initialize substitute replacement string</a>
<a name="ln2759">  {</a>
<a name="ln2760">    SubReplacementString sub;</a>
<a name="ln2761">    sub_get_replacement(&amp;sub);</a>
<a name="ln2762">    wms-&gt;replacement = (PossiblyFreedShadaEntry) {</a>
<a name="ln2763">      .can_free_entry = false,</a>
<a name="ln2764">      .data = {</a>
<a name="ln2765">        .type = kSDItemSubString,</a>
<a name="ln2766">        .timestamp = sub.timestamp,</a>
<a name="ln2767">        .data = {</a>
<a name="ln2768">          .sub_string = {</a>
<a name="ln2769">            .sub = (char *) sub.sub,</a>
<a name="ln2770">            .additional_elements = sub.additional_elements,</a>
<a name="ln2771">          }</a>
<a name="ln2772">        }</a>
<a name="ln2773">      }</a>
<a name="ln2774">    };</a>
<a name="ln2775">  }</a>
<a name="ln2776"> </a>
<a name="ln2777">  // Initialize global marks</a>
<a name="ln2778">  if (dump_global_marks) {</a>
<a name="ln2779">    const void *global_mark_iter = NULL;</a>
<a name="ln2780">    size_t digit_mark_idx = 0;</a>
<a name="ln2781">    do {</a>
<a name="ln2782">      char name = NUL;</a>
<a name="ln2783">      xfmark_T fm;</a>
<a name="ln2784">      global_mark_iter = mark_global_iter(global_mark_iter, &amp;name, &amp;fm);</a>
<a name="ln2785">      if (name == NUL) {</a>
<a name="ln2786">        break;</a>
<a name="ln2787">      }</a>
<a name="ln2788">      const char *fname;</a>
<a name="ln2789">      if (fm.fmark.fnum == 0) {</a>
<a name="ln2790">        assert(fm.fname != NULL);</a>
<a name="ln2791">        if (shada_removable((const char *) fm.fname)) {</a>
<a name="ln2792">          continue;</a>
<a name="ln2793">        }</a>
<a name="ln2794">        fname = (const char *) fm.fname;</a>
<a name="ln2795">      } else {</a>
<a name="ln2796">        const buf_T *const buf = buflist_findnr(fm.fmark.fnum);</a>
<a name="ln2797">        if (buf == NULL || buf-&gt;b_ffname == NULL</a>
<a name="ln2798">            || in_bufset(&amp;removable_bufs, buf)) {</a>
<a name="ln2799">          continue;</a>
<a name="ln2800">        }</a>
<a name="ln2801">        fname = (const char *) buf-&gt;b_ffname;</a>
<a name="ln2802">      }</a>
<a name="ln2803">      const PossiblyFreedShadaEntry pf_entry = {</a>
<a name="ln2804">        .can_free_entry = false,</a>
<a name="ln2805">        .data = {</a>
<a name="ln2806">          .type = kSDItemGlobalMark,</a>
<a name="ln2807">          .timestamp = fm.fmark.timestamp,</a>
<a name="ln2808">          .data = {</a>
<a name="ln2809">            .filemark = {</a>
<a name="ln2810">              .mark = fm.fmark.mark,</a>
<a name="ln2811">              .name = name,</a>
<a name="ln2812">              .additional_data = fm.fmark.additional_data,</a>
<a name="ln2813">              .fname = (char *)fname,</a>
<a name="ln2814">            }</a>
<a name="ln2815">          }</a>
<a name="ln2816">        },</a>
<a name="ln2817">      };</a>
<a name="ln2818">      if (ascii_isdigit(name)) {</a>
<a name="ln2819">        replace_numbered_mark(wms, digit_mark_idx++, pf_entry);</a>
<a name="ln2820">      } else {</a>
<a name="ln2821">        wms-&gt;global_marks[mark_global_index(name)] = pf_entry;</a>
<a name="ln2822">      }</a>
<a name="ln2823">    } while (global_mark_iter != NULL);</a>
<a name="ln2824">  }</a>
<a name="ln2825"> </a>
<a name="ln2826">  // Initialize registers</a>
<a name="ln2827">  if (dump_registers) {</a>
<a name="ln2828">    shada_initialize_registers(wms, max_reg_lines);</a>
<a name="ln2829">  }</a>
<a name="ln2830"> </a>
<a name="ln2831">  // Initialize buffers</a>
<a name="ln2832">  if (num_marked_files &gt; 0) {</a>
<a name="ln2833">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2834">      if (buf-&gt;b_ffname == NULL || in_bufset(&amp;removable_bufs, buf)) {</a>
<a name="ln2835">        continue;</a>
<a name="ln2836">      }</a>
<a name="ln2837">      const void *local_marks_iter = NULL;</a>
<a name="ln2838">      const char *const fname = (const char *) buf-&gt;b_ffname;</a>
<a name="ln2839">      khiter_t k;</a>
<a name="ln2840">      int kh_ret;</a>
<a name="ln2841">      k = kh_put(file_marks, &amp;wms-&gt;file_marks, fname, &amp;kh_ret);</a>
<a name="ln2842">      FileMarks *const filemarks = &amp;kh_val(&amp;wms-&gt;file_marks, k);</a>
<a name="ln2843">      if (kh_ret &gt; 0) {</a>
<a name="ln2844">        memset(filemarks, 0, sizeof(*filemarks));</a>
<a name="ln2845">      }</a>
<a name="ln2846">      do {</a>
<a name="ln2847">        fmark_T fm;</a>
<a name="ln2848">        char name = NUL;</a>
<a name="ln2849">        local_marks_iter = mark_buffer_iter(local_marks_iter, buf, &amp;name, &amp;fm);</a>
<a name="ln2850">        if (name == NUL) {</a>
<a name="ln2851">          break;</a>
<a name="ln2852">        }</a>
<a name="ln2853">        filemarks-&gt;marks[mark_local_index(name)] = (PossiblyFreedShadaEntry) {</a>
<a name="ln2854">          .can_free_entry = false,</a>
<a name="ln2855">          .data = {</a>
<a name="ln2856">            .type = kSDItemLocalMark,</a>
<a name="ln2857">            .timestamp = fm.timestamp,</a>
<a name="ln2858">            .data = {</a>
<a name="ln2859">              .filemark = {</a>
<a name="ln2860">                .mark = fm.mark,</a>
<a name="ln2861">                .name = name,</a>
<a name="ln2862">                .fname = (char *) fname,</a>
<a name="ln2863">                .additional_data = fm.additional_data,</a>
<a name="ln2864">              }</a>
<a name="ln2865">            }</a>
<a name="ln2866">          }</a>
<a name="ln2867">        };</a>
<a name="ln2868">        if (fm.timestamp &gt; filemarks-&gt;greatest_timestamp) {</a>
<a name="ln2869">          filemarks-&gt;greatest_timestamp = fm.timestamp;</a>
<a name="ln2870">        }</a>
<a name="ln2871">      } while (local_marks_iter != NULL);</a>
<a name="ln2872">      for (int i = 0; i &lt; buf-&gt;b_changelistlen; i++) {</a>
<a name="ln2873">        const fmark_T fm = buf-&gt;b_changelist[i];</a>
<a name="ln2874">        filemarks-&gt;changes[i] = (PossiblyFreedShadaEntry) {</a>
<a name="ln2875">          .can_free_entry = false,</a>
<a name="ln2876">          .data = {</a>
<a name="ln2877">            .type = kSDItemChange,</a>
<a name="ln2878">            .timestamp = fm.timestamp,</a>
<a name="ln2879">            .data = {</a>
<a name="ln2880">              .filemark = {</a>
<a name="ln2881">                .mark = fm.mark,</a>
<a name="ln2882">                .fname = (char *) fname,</a>
<a name="ln2883">                .additional_data = fm.additional_data,</a>
<a name="ln2884">              }</a>
<a name="ln2885">            }</a>
<a name="ln2886">          }</a>
<a name="ln2887">        };</a>
<a name="ln2888">        if (fm.timestamp &gt; filemarks-&gt;greatest_timestamp) {</a>
<a name="ln2889">          filemarks-&gt;greatest_timestamp = fm.timestamp;</a>
<a name="ln2890">        }</a>
<a name="ln2891">      }</a>
<a name="ln2892">      filemarks-&gt;changes_size = (size_t) buf-&gt;b_changelistlen;</a>
<a name="ln2893">    }</a>
<a name="ln2894">  }</a>
<a name="ln2895"> </a>
<a name="ln2896">  if (sd_reader != NULL) {</a>
<a name="ln2897">    const ShaDaWriteResult srww_ret = shada_read_when_writing(</a>
<a name="ln2898">        sd_reader, srni_flags, max_kbyte, wms, packer);</a>
<a name="ln2899">    if (srww_ret != kSDWriteSuccessfull) {</a>
<a name="ln2900">      ret = srww_ret;</a>
<a name="ln2901">    }</a>
<a name="ln2902">  }</a>
<a name="ln2903"> </a>
<a name="ln2904">  // Update numbered marks: '0' should be replaced with the current position,</a>
<a name="ln2905">  // '9' should be removed and all other marks shifted.</a>
<a name="ln2906">  if (!ignore_buf(curbuf, &amp;removable_bufs) &amp;&amp; curwin-&gt;w_cursor.lnum != 0) {</a>
<a name="ln2907">    replace_numbered_mark(wms, 0, (PossiblyFreedShadaEntry) {</a>
<a name="ln2908">      .can_free_entry = false,</a>
<a name="ln2909">      .data = {</a>
<a name="ln2910">        .type = kSDItemGlobalMark,</a>
<a name="ln2911">        .timestamp = os_time(),</a>
<a name="ln2912">        .data = {</a>
<a name="ln2913">          .filemark = {</a>
<a name="ln2914">            .mark = curwin-&gt;w_cursor,</a>
<a name="ln2915">            .name = '0',</a>
<a name="ln2916">            .additional_data = NULL,</a>
<a name="ln2917">            .fname = (char *)curbuf-&gt;b_ffname,</a>
<a name="ln2918">          }</a>
<a name="ln2919">        }</a>
<a name="ln2920">      },</a>
<a name="ln2921">    });</a>
<a name="ln2922">  }</a>
<a name="ln2923"> </a>
<a name="ln2924">  // Write the rest</a>
<a name="ln2925">#define PACK_WMS_ARRAY(wms_array) \</a>
<a name="ln2926">  do { \</a>
<a name="ln2927">    for (size_t i_ = 0; i_ &lt; ARRAY_SIZE(wms_array); i_++) { \</a>
<a name="ln2928">      if (wms_array[i_].data.type != kSDItemMissing) { \</a>
<a name="ln2929">        if (shada_pack_pfreed_entry(packer, wms_array[i_], max_kbyte) \</a>
<a name="ln2930">            == kSDWriteFailed) { \</a>
<a name="ln2931">          ret = kSDWriteFailed; \</a>
<a name="ln2932">          goto shada_write_exit; \</a>
<a name="ln2933">        } \</a>
<a name="ln2934">      } \</a>
<a name="ln2935">    } \</a>
<a name="ln2936">  } while (0)</a>
<a name="ln2937">  PACK_WMS_ARRAY(wms-&gt;global_marks);</a>
<a name="ln2938">  PACK_WMS_ARRAY(wms-&gt;numbered_marks);</a>
<a name="ln2939">  PACK_WMS_ARRAY(wms-&gt;registers);</a>
<a name="ln2940">  for (size_t i = 0; i &lt; wms-&gt;jumps_size; i++) {</a>
<a name="ln2941">    if (shada_pack_pfreed_entry(packer, wms-&gt;jumps[i], max_kbyte)</a>
<a name="ln2942">        == kSDWriteFailed) {</a>
<a name="ln2943">      ret = kSDWriteFailed;</a>
<a name="ln2944">      goto shada_write_exit;</a>
<a name="ln2945">    }</a>
<a name="ln2946">  }</a>
<a name="ln2947">#define PACK_WMS_ENTRY(wms_entry) \</a>
<a name="ln2948">  do { \</a>
<a name="ln2949">    if (wms_entry.data.type != kSDItemMissing) { \</a>
<a name="ln2950">      if (shada_pack_pfreed_entry(packer, wms_entry, max_kbyte) \</a>
<a name="ln2951">          == kSDWriteFailed) { \</a>
<a name="ln2952">        ret = kSDWriteFailed; \</a>
<a name="ln2953">        goto shada_write_exit; \</a>
<a name="ln2954">      } \</a>
<a name="ln2955">    } \</a>
<a name="ln2956">  } while (0)</a>
<a name="ln2957">  PACK_WMS_ENTRY(wms-&gt;search_pattern);</a>
<a name="ln2958">  PACK_WMS_ENTRY(wms-&gt;sub_search_pattern);</a>
<a name="ln2959">  PACK_WMS_ENTRY(wms-&gt;replacement);</a>
<a name="ln2960">#undef PACK_WMS_ENTRY</a>
<a name="ln2961"> </a>
<a name="ln2962">  const size_t file_markss_size = kh_size(&amp;wms-&gt;file_marks);</a>
<a name="ln2963">  FileMarks **const all_file_markss =</a>
<a name="ln2964">      xmalloc(file_markss_size * sizeof(*all_file_markss));</a>
<a name="ln2965">  FileMarks **cur_file_marks = all_file_markss;</a>
<a name="ln2966">  for (khint_t i = kh_begin(&amp;wms-&gt;file_marks); i != kh_end(&amp;wms-&gt;file_marks);</a>
<a name="ln2967">       i++) {</a>
<a name="ln2968">    if (kh_exist(&amp;wms-&gt;file_marks, i)) {</a>
<a name="ln2969">      *cur_file_marks++ = &amp;kh_val(&amp;wms-&gt;file_marks, i);</a>
<a name="ln2970">    }</a>
<a name="ln2971">  }</a>
<a name="ln2972">  qsort((void *) all_file_markss, file_markss_size, sizeof(*all_file_markss),</a>
<a name="ln2973">        &amp;compare_file_marks);</a>
<a name="ln2974">  const size_t file_markss_to_dump = MIN(num_marked_files, file_markss_size);</a>
<a name="ln2975">  for (size_t i = 0; i &lt; file_markss_to_dump; i++) {</a>
<a name="ln2976">    PACK_WMS_ARRAY(all_file_markss[i]-&gt;marks);</a>
<a name="ln2977">    for (size_t j = 0; j &lt; all_file_markss[i]-&gt;changes_size; j++) {</a>
<a name="ln2978">      if (shada_pack_pfreed_entry(packer, all_file_markss[i]-&gt;changes[j],</a>
<a name="ln2979">                                  max_kbyte) == kSDWriteFailed) {</a>
<a name="ln2980">        ret = kSDWriteFailed;</a>
<a name="ln2981">        goto shada_write_exit;</a>
<a name="ln2982">      }</a>
<a name="ln2983">    }</a>
<a name="ln2984">    for (size_t j = 0; j &lt; all_file_markss[i]-&gt;additional_marks_size; j++) {</a>
<a name="ln2985">      if (shada_pack_entry(packer, all_file_markss[i]-&gt;additional_marks[j],</a>
<a name="ln2986">                           0) == kSDWriteFailed) {</a>
<a name="ln2987">        shada_free_shada_entry(&amp;all_file_markss[i]-&gt;additional_marks[j]);</a>
<a name="ln2988">        ret = kSDWriteFailed;</a>
<a name="ln2989">        goto shada_write_exit;</a>
<a name="ln2990">      }</a>
<a name="ln2991">      shada_free_shada_entry(&amp;all_file_markss[i]-&gt;additional_marks[j]);</a>
<a name="ln2992">    }</a>
<a name="ln2993">    xfree(all_file_markss[i]-&gt;additional_marks);</a>
<a name="ln2994">  }</a>
<a name="ln2995">  xfree(all_file_markss);</a>
<a name="ln2996">#undef PACK_WMS_ARRAY</a>
<a name="ln2997"> </a>
<a name="ln2998">  if (dump_history) {</a>
<a name="ln2999">    for (size_t i = 0; i &lt; HIST_COUNT; i++) {</a>
<a name="ln3000">      if (dump_one_history[i]) {</a>
<a name="ln3001">        hms_insert_whole_neovim_history(&amp;wms-&gt;hms[i]);</a>
<a name="ln3002">        HMS_ITER(&amp;wms-&gt;hms[i], cur_entry, {</a>
<a name="ln3003">          if (shada_pack_pfreed_entry(</a>
<a name="ln3004">              packer, (PossiblyFreedShadaEntry) {</a>
<a name="ln3005">                .data = cur_entry-&gt;data,</a>
<a name="ln3006">                .can_free_entry = cur_entry-&gt;can_free_entry,</a>
<a name="ln3007">              }, max_kbyte) == kSDWriteFailed) {</a>
<a name="ln3008">            ret = kSDWriteFailed;</a>
<a name="ln3009">            break;</a>
<a name="ln3010">          }</a>
<a name="ln3011">        })</a>
<a name="ln3012">        if (ret == kSDWriteFailed) {</a>
<a name="ln3013">          goto shada_write_exit;</a>
<a name="ln3014">        }</a>
<a name="ln3015">      }</a>
<a name="ln3016">    }</a>
<a name="ln3017">  }</a>
<a name="ln3018"> </a>
<a name="ln3019">shada_write_exit:</a>
<a name="ln3020">  for (size_t i = 0; i &lt; HIST_COUNT; i++) {</a>
<a name="ln3021">    if (dump_one_history[i]) {</a>
<a name="ln3022">      hms_dealloc(&amp;wms-&gt;hms[i]);</a>
<a name="ln3023">    }</a>
<a name="ln3024">  }</a>
<a name="ln3025">  kh_dealloc(file_marks, &amp;wms-&gt;file_marks);</a>
<a name="ln3026">  kh_dealloc(bufset, &amp;removable_bufs);</a>
<a name="ln3027">  msgpack_packer_free(packer);</a>
<a name="ln3028">  kh_dealloc(strset, &amp;wms-&gt;dumped_variables);</a>
<a name="ln3029">  xfree(wms);</a>
<a name="ln3030">  return ret;</a>
<a name="ln3031">}</a>
<a name="ln3032"> </a>
<a name="ln3033">#undef IGNORE_BUF</a>
<a name="ln3034">#undef PACK_STATIC_STR</a>
<a name="ln3035"> </a>
<a name="ln3036">/// Write ShaDa file to a given location</a>
<a name="ln3037">///</a>
<a name="ln3038">/// @param[in]  fname    File to write to. If it is NULL or empty then default</a>
<a name="ln3039">///                      location is used.</a>
<a name="ln3040">/// @param[in]  nomerge  If true then old file is ignored.</a>
<a name="ln3041">///</a>
<a name="ln3042">/// @return OK if writing was successful, FAIL otherwise.</a>
<a name="ln3043">int shada_write_file(const char *const file, bool nomerge)</a>
<a name="ln3044">{</a>
<a name="ln3045">  if (shada_disabled()) {</a>
<a name="ln3046">    return FAIL;</a>
<a name="ln3047">  }</a>
<a name="ln3048"> </a>
<a name="ln3049">  char *const fname = shada_filename(file);</a>
<a name="ln3050">  char *tempname = NULL;</a>
<a name="ln3051">  ShaDaWriteDef sd_writer = {</a>
<a name="ln3052">    .write = &amp;write_file,</a>
<a name="ln3053">    .close = &amp;close_sd_writer,</a>
<a name="ln3054">    .error = NULL,</a>
<a name="ln3055">  };</a>
<a name="ln3056">  ShaDaReadDef sd_reader = { .close = NULL };</a>
<a name="ln3057"> </a>
<a name="ln3058">  if (!nomerge) {</a>
<a name="ln3059">    int error;</a>
<a name="ln3060">    if ((error = open_shada_file_for_reading(fname, &amp;sd_reader)) != 0) {</a>
<a name="ln3061">      if (error != UV_ENOENT) {</a>
<a name="ln3062">        emsgf(_(SERR &quot;System error while opening ShaDa file %s for reading &quot;</a>
<a name="ln3063">                &quot;to merge before writing it: %s&quot;),</a>
<a name="ln3064">              fname, os_strerror(error));</a>
<a name="ln3065">        // Try writing the file even if opening it emerged any issues besides</a>
<a name="ln3066">        // file not existing: maybe writing will succeed nevertheless.</a>
<a name="ln3067">      }</a>
<a name="ln3068">      nomerge = true;</a>
<a name="ln3069">      goto shada_write_file_nomerge;</a>
<a name="ln3070">    }</a>
<a name="ln3071">    tempname = modname(fname, &quot;.tmp.a&quot;, false);</a>
<a name="ln3072">    if (tempname == NULL) {</a>
<a name="ln3073">      nomerge = true;</a>
<a name="ln3074">      goto shada_write_file_nomerge;</a>
<a name="ln3075">    }</a>
<a name="ln3076"> </a>
<a name="ln3077">    // Save permissions from the original file, with modifications:</a>
<a name="ln3078">    int perm = (int) os_getperm(fname);</a>
<a name="ln3079">    perm = (perm &gt;= 0) ? ((perm &amp; 0777) | 0600) : 0600;</a>
<a name="ln3080">    //                 ^3         ^1       ^2      ^2,3</a>
<a name="ln3081">    // 1: Strip SUID bit if any.</a>
<a name="ln3082">    // 2: Make sure that user can always read and write the result.</a>
<a name="ln3083">    // 3: If somebody happened to delete the file after it was opened for</a>
<a name="ln3084">    //    reading use u=rw permissions.</a>
<a name="ln3085">shada_write_file_open: {}</a>
<a name="ln3086">    sd_writer.cookie = file_open_new(</a>
<a name="ln3087">        &amp;error, tempname, kFileCreateOnly|kFileNoSymlink, perm);</a>
<a name="ln3088">    if (sd_writer.cookie == NULL) {</a>
<a name="ln3089">      if (error == UV_EEXIST || error == UV_ELOOP) {</a>
<a name="ln3090">        // File already exists, try another name</a>
<a name="ln3091">        char *const wp = tempname + strlen(tempname) - 1;</a>
<a name="ln3092">        if (*wp == 'z') {</a>
<a name="ln3093">          // Tried names from .tmp.a to .tmp.z, all failed. Something must be</a>
<a name="ln3094">          // wrong then.</a>
<a name="ln3095">          EMSG2(_(&quot;E138: All %s.tmp.X files exist, cannot write ShaDa file!&quot;),</a>
<a name="ln3096">                fname);</a>
<a name="ln3097">          xfree(fname);</a>
<a name="ln3098">          xfree(tempname);</a>
<a name="ln3099">          assert(sd_reader.close != NULL);</a>
<a name="ln3100">          sd_reader.close(&amp;sd_reader);</a>
<a name="ln3101">          return FAIL;</a>
<a name="ln3102">        } else {</a>
<a name="ln3103">          (*wp)++;</a>
<a name="ln3104">          goto shada_write_file_open;</a>
<a name="ln3105">        }</a>
<a name="ln3106">      } else {</a>
<a name="ln3107">        emsgf(_(SERR &quot;System error while opening temporary ShaDa file %s &quot;</a>
<a name="ln3108">                &quot;for writing: %s&quot;), tempname, os_strerror(error));</a>
<a name="ln3109">      }</a>
<a name="ln3110">    }</a>
<a name="ln3111">  }</a>
<a name="ln3112">  if (nomerge) {</a>
<a name="ln3113">shada_write_file_nomerge: {}</a>
<a name="ln3114">    char *const tail = path_tail_with_sep(fname);</a>
<a name="ln3115">    if (tail != fname) {</a>
<a name="ln3116">      const char tail_save = *tail;</a>
<a name="ln3117">      *tail = NUL;</a>
<a name="ln3118">      if (!os_isdir(fname)) {</a>
<a name="ln3119">        int ret;</a>
<a name="ln3120">        char *failed_dir;</a>
<a name="ln3121">        if ((ret = os_mkdir_recurse(fname, 0700, &amp;failed_dir)) != 0) {</a>
<a name="ln3122">          EMSG3(_(SERR &quot;Failed to create directory %s &quot;</a>
<a name="ln3123">                  &quot;for writing ShaDa file: %s&quot;),</a>
<a name="ln3124">                failed_dir, os_strerror(ret));</a>
<a name="ln3125">          xfree(fname);</a>
<a name="ln3126">          xfree(failed_dir);</a>
<a name="ln3127">          return FAIL;</a>
<a name="ln3128">        }</a>
<a name="ln3129">      }</a>
<a name="ln3130">      *tail = tail_save;</a>
<a name="ln3131">    }</a>
<a name="ln3132">    int error;</a>
<a name="ln3133">    sd_writer.cookie = file_open_new(&amp;error, fname, kFileCreate|kFileTruncate,</a>
<a name="ln3134">                                     0600);</a>
<a name="ln3135">    if (sd_writer.cookie == NULL) {</a>
<a name="ln3136">      emsgf(_(SERR &quot;System error while opening ShaDa file %s for writing: %s&quot;),</a>
<a name="ln3137">            fname, os_strerror(error));</a>
<a name="ln3138">    }</a>
<a name="ln3139">  }</a>
<a name="ln3140"> </a>
<a name="ln3141">  if (sd_writer.cookie == NULL) {</a>
<a name="ln3142">    xfree(fname);</a>
<a name="ln3143">    xfree(tempname);</a>
<a name="ln3144">    if (sd_reader.cookie != NULL) {</a>
<a name="ln3145">      sd_reader.close(&amp;sd_reader);</a>
<a name="ln3146">    }</a>
<a name="ln3147">    return FAIL;</a>
<a name="ln3148">  }</a>
<a name="ln3149"> </a>
<a name="ln3150">  if (p_verbose &gt; 0) {</a>
<a name="ln3151">    verbose_enter();</a>
<a name="ln3152">    smsg(_(&quot;Writing ShaDa file \&quot;%s\&quot;&quot;), fname);</a>
<a name="ln3153">    verbose_leave();</a>
<a name="ln3154">  }</a>
<a name="ln3155"> </a>
<a name="ln3156">  const ShaDaWriteResult sw_ret = shada_write(&amp;sd_writer, (nomerge</a>
<a name="ln3157">                                                           ? NULL</a>
<a name="ln3158">                                                           : &amp;sd_reader));</a>
<a name="ln3159">  assert(sw_ret != kSDWriteIgnError);</a>
<a name="ln3160">  if (!nomerge) {</a>
<a name="ln3161">    sd_reader.close(&amp;sd_reader);</a>
<a name="ln3162">    bool did_remove = false;</a>
<a name="ln3163">    if (sw_ret == kSDWriteSuccessfull) {</a>
<a name="ln3164">#ifdef UNIX</a>
<a name="ln3165">      // For Unix we check the owner of the file.  It's not very nice to</a>
<a name="ln3166">      // overwrite a user’s viminfo file after a &quot;su root&quot;, with a</a>
<a name="ln3167">      // viminfo file that the user can't read.</a>
<a name="ln3168">      FileInfo old_info;</a>
<a name="ln3169">      if (os_fileinfo((char *)fname, &amp;old_info)) {</a>
<a name="ln3170">        if (getuid() == ROOT_UID) {</a>
<a name="ln3171">          if (old_info.stat.st_uid != ROOT_UID</a>
<a name="ln3172">              || old_info.stat.st_gid != getgid()) {</a>
<a name="ln3173">            const uv_uid_t old_uid = (uv_uid_t)old_info.stat.st_uid;</a>
<a name="ln3174">            const uv_gid_t old_gid = (uv_gid_t)old_info.stat.st_gid;</a>
<a name="ln3175">            const int fchown_ret = os_fchown(file_fd(sd_writer.cookie),</a>
<a name="ln3176">                                             old_uid, old_gid);</a>
<a name="ln3177">            if (fchown_ret != 0) {</a>
<a name="ln3178">              EMSG3(_(RNERR &quot;Failed setting uid and gid for file %s: %s&quot;),</a>
<a name="ln3179">                    tempname, os_strerror(fchown_ret));</a>
<a name="ln3180">              goto shada_write_file_did_not_remove;</a>
<a name="ln3181">            }</a>
<a name="ln3182">          }</a>
<a name="ln3183">        } else if (!(old_info.stat.st_uid == getuid()</a>
<a name="ln3184">                     ? (old_info.stat.st_mode &amp; 0200)</a>
<a name="ln3185">                     : (old_info.stat.st_gid == getgid()</a>
<a name="ln3186">                        ? (old_info.stat.st_mode &amp; 0020)</a>
<a name="ln3187">                        : (old_info.stat.st_mode &amp; 0002)))) {</a>
<a name="ln3188">          EMSG2(_(&quot;E137: ShaDa file is not writable: %s&quot;), fname);</a>
<a name="ln3189">          goto shada_write_file_did_not_remove;</a>
<a name="ln3190">        }</a>
<a name="ln3191">      }</a>
<a name="ln3192">#endif</a>
<a name="ln3193">      if (vim_rename(tempname, fname) == -1) {</a>
<a name="ln3194">        EMSG3(_(RNERR &quot;Can't rename ShaDa file from %s to %s!&quot;),</a>
<a name="ln3195">              tempname, fname);</a>
<a name="ln3196">      } else {</a>
<a name="ln3197">        did_remove = true;</a>
<a name="ln3198">        os_remove(tempname);</a>
<a name="ln3199">      }</a>
<a name="ln3200">    } else {</a>
<a name="ln3201">      if (sw_ret == kSDWriteReadNotShada) {</a>
<a name="ln3202">        EMSG3(_(RNERR &quot;Did not rename %s because %s &quot;</a>
<a name="ln3203">                &quot;does not look like a ShaDa file&quot;), tempname, fname);</a>
<a name="ln3204">      } else {</a>
<a name="ln3205">        EMSG3(_(RNERR &quot;Did not rename %s to %s because there were errors &quot;</a>
<a name="ln3206">                &quot;during writing it&quot;), tempname, fname);</a>
<a name="ln3207">      }</a>
<a name="ln3208">    }</a>
<a name="ln3209">    if (!did_remove) {</a>
<a name="ln3210">#ifdef UNIX</a>
<a name="ln3211">shada_write_file_did_not_remove:</a>
<a name="ln3212">#endif</a>
<a name="ln3213">      EMSG3(_(RNERR &quot;Do not forget to remove %s or rename it manually to %s.&quot;),</a>
<a name="ln3214">            tempname, fname);</a>
<a name="ln3215">    }</a>
<a name="ln3216">    xfree(tempname);</a>
<a name="ln3217">  }</a>
<a name="ln3218">  sd_writer.close(&amp;sd_writer);</a>
<a name="ln3219"> </a>
<a name="ln3220">  xfree(fname);</a>
<a name="ln3221">  return OK;</a>
<a name="ln3222">}</a>
<a name="ln3223"> </a>
<a name="ln3224">/// Read marks information from ShaDa file</a>
<a name="ln3225">///</a>
<a name="ln3226">/// @return OK in case of success, FAIL otherwise.</a>
<a name="ln3227">int shada_read_marks(void)</a>
<a name="ln3228">{</a>
<a name="ln3229">  return shada_read_file(NULL, kShaDaWantMarks);</a>
<a name="ln3230">}</a>
<a name="ln3231"> </a>
<a name="ln3232">/// Read all information from ShaDa file</a>
<a name="ln3233">///</a>
<a name="ln3234">/// @param[in]  fname    File to write to. If it is NULL or empty then default</a>
<a name="ln3235">/// @param[in]  forceit  If true, use forced reading (prioritize file contents</a>
<a name="ln3236">///                      over current Neovim state).</a>
<a name="ln3237">/// @param[in]  missing_ok  If true, do not error out when file is missing.</a>
<a name="ln3238">///</a>
<a name="ln3239">/// @return OK in case of success, FAIL otherwise.</a>
<a name="ln3240">int shada_read_everything(const char *const fname, const bool forceit,</a>
<a name="ln3241">                          const bool missing_ok)</a>
<a name="ln3242">{</a>
<a name="ln3243">  return shada_read_file(fname,</a>
<a name="ln3244">                         kShaDaWantInfo|kShaDaWantMarks|kShaDaGetOldfiles</a>
<a name="ln3245">                         |(forceit?kShaDaForceit:0)</a>
<a name="ln3246">                         |(missing_ok?0:kShaDaMissingError));</a>
<a name="ln3247">}</a>
<a name="ln3248"> </a>
<a name="ln3249">static void shada_free_shada_entry(ShadaEntry *const entry)</a>
<a name="ln3250">{</a>
<a name="ln3251">  if (entry == NULL) {</a>
<a name="ln3252">    return;</a>
<a name="ln3253">  }</a>
<a name="ln3254">  switch (entry-&gt;type) {</a>
<a name="ln3255">    case kSDItemMissing: {</a>
<a name="ln3256">      break;</a>
<a name="ln3257">    }</a>
<a name="ln3258">    case kSDItemUnknown: {</a>
<a name="ln3259">      xfree(entry-&gt;data.unknown_item.contents);</a>
<a name="ln3260">      break;</a>
<a name="ln3261">    }</a>
<a name="ln3262">    case kSDItemHeader: {</a>
<a name="ln3263">      api_free_dictionary(entry-&gt;data.header);</a>
<a name="ln3264">      break;</a>
<a name="ln3265">    }</a>
<a name="ln3266">    case kSDItemChange:</a>
<a name="ln3267">    case kSDItemJump:</a>
<a name="ln3268">    case kSDItemGlobalMark:</a>
<a name="ln3269">    case kSDItemLocalMark: {</a>
<a name="ln3270">      tv_dict_unref(entry-&gt;data.filemark.additional_data);</a>
<a name="ln3271">      xfree(entry-&gt;data.filemark.fname);</a>
<a name="ln3272">      break;</a>
<a name="ln3273">    }</a>
<a name="ln3274">    case kSDItemSearchPattern: {</a>
<a name="ln3275">      tv_dict_unref(entry-&gt;data.search_pattern.additional_data);</a>
<a name="ln3276">      xfree(entry-&gt;data.search_pattern.pat);</a>
<a name="ln3277">      break;</a>
<a name="ln3278">    }</a>
<a name="ln3279">    case kSDItemRegister: {</a>
<a name="ln3280">      tv_dict_unref(entry-&gt;data.reg.additional_data);</a>
<a name="ln3281">      for (size_t i = 0; i &lt; entry-&gt;data.reg.contents_size; i++) {</a>
<a name="ln3282">        xfree(entry-&gt;data.reg.contents[i]);</a>
<a name="ln3283">      }</a>
<a name="ln3284">      xfree(entry-&gt;data.reg.contents);</a>
<a name="ln3285">      break;</a>
<a name="ln3286">    }</a>
<a name="ln3287">    case kSDItemHistoryEntry: {</a>
<a name="ln3288">      tv_list_unref(entry-&gt;data.history_item.additional_elements);</a>
<a name="ln3289">      xfree(entry-&gt;data.history_item.string);</a>
<a name="ln3290">      break;</a>
<a name="ln3291">    }</a>
<a name="ln3292">    case kSDItemVariable: {</a>
<a name="ln3293">      tv_list_unref(entry-&gt;data.global_var.additional_elements);</a>
<a name="ln3294">      xfree(entry-&gt;data.global_var.name);</a>
<a name="ln3295">      tv_clear(&amp;entry-&gt;data.global_var.value);</a>
<a name="ln3296">      break;</a>
<a name="ln3297">    }</a>
<a name="ln3298">    case kSDItemSubString: {</a>
<a name="ln3299">      tv_list_unref(entry-&gt;data.sub_string.additional_elements);</a>
<a name="ln3300">      xfree(entry-&gt;data.sub_string.sub);</a>
<a name="ln3301">      break;</a>
<a name="ln3302">    }</a>
<a name="ln3303">    case kSDItemBufferList: {</a>
<a name="ln3304">      for (size_t i = 0; i &lt; entry-&gt;data.buffer_list.size; i++) {</a>
<a name="ln3305">        xfree(entry-&gt;data.buffer_list.buffers[i].fname);</a>
<a name="ln3306">        tv_dict_unref(entry-&gt;data.buffer_list.buffers[i].additional_data);</a>
<a name="ln3307">      }</a>
<a name="ln3308">      xfree(entry-&gt;data.buffer_list.buffers);</a>
<a name="ln3309">      break;</a>
<a name="ln3310">    }</a>
<a name="ln3311">  }</a>
<a name="ln3312">}</a>
<a name="ln3313"> </a>
<a name="ln3314">#ifndef HAVE_BE64TOH</a>
<a name="ln3315">static inline uint64_t be64toh(uint64_t big_endian_64_bits)</a>
<a name="ln3316">{</a>
<a name="ln3317">#ifdef ORDER_BIG_ENDIAN</a>
<a name="ln3318">  return big_endian_64_bits;</a>
<a name="ln3319">#else</a>
<a name="ln3320">  // It may appear that when !defined(ORDER_BIG_ENDIAN) actual order is big</a>
<a name="ln3321">  // endian. This variant is suboptimal, but it works regardless of actual</a>
<a name="ln3322">  // order.</a>
<a name="ln3323">  uint8_t *buf = (uint8_t *) &amp;big_endian_64_bits;</a>
<a name="ln3324">  uint64_t ret = 0;</a>
<a name="ln3325">  for (size_t i = 8; i; i--) {</a>
<a name="ln3326">    ret |= ((uint64_t) buf[i - 1]) &lt;&lt; ((8 - i) * 8);</a>
<a name="ln3327">  }</a>
<a name="ln3328">  return ret;</a>
<a name="ln3329">#endif</a>
<a name="ln3330">}</a>
<a name="ln3331">#endif</a>
<a name="ln3332"> </a>
<a name="ln3333">/// Read given number of bytes into given buffer, display error if needed</a>
<a name="ln3334">///</a>
<a name="ln3335">/// @param[in]   sd_reader  Structure containing file reader definition.</a>
<a name="ln3336">/// @param[out]  buffer     Where to save the results.</a>
<a name="ln3337">/// @param[in]   length     How many bytes should be read.</a>
<a name="ln3338">///</a>
<a name="ln3339">/// @return kSDReadStatusSuccess if everything was OK, kSDReadStatusNotShaDa if</a>
<a name="ln3340">///         there were not enough bytes to read or kSDReadStatusReadError if</a>
<a name="ln3341">///         there was some error while reading.</a>
<a name="ln3342">static ShaDaReadResult fread_len(ShaDaReadDef *const sd_reader,</a>
<a name="ln3343">                                 char *const buffer,</a>
<a name="ln3344">                                 const size_t length)</a>
<a name="ln3345">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3346">{</a>
<a name="ln3347">  const ptrdiff_t read_bytes = sd_reader-&gt;read(sd_reader, buffer, length);</a>
<a name="ln3348"> </a>
<a name="ln3349">  if (read_bytes != (ptrdiff_t)length) {</a>
<a name="ln3350">    if (sd_reader-&gt;error != NULL) {</a>
<a name="ln3351">      emsgf(_(SERR &quot;System error while reading ShaDa file: %s&quot;),</a>
<a name="ln3352">            sd_reader-&gt;error);</a>
<a name="ln3353">      return kSDReadStatusReadError;</a>
<a name="ln3354">    } else {</a>
<a name="ln3355">      emsgf(_(RCERR &quot;Error while reading ShaDa file: &quot;</a>
<a name="ln3356">              &quot;last entry specified that it occupies %&quot; PRIu64 &quot; bytes, &quot;</a>
<a name="ln3357">              &quot;but file ended earlier&quot;),</a>
<a name="ln3358">            (uint64_t)length);</a>
<a name="ln3359">      return kSDReadStatusNotShaDa;</a>
<a name="ln3360">    }</a>
<a name="ln3361">  }</a>
<a name="ln3362">  return kSDReadStatusSuccess;</a>
<a name="ln3363">}</a>
<a name="ln3364"> </a>
<a name="ln3365">/// Read next unsigned integer from file</a>
<a name="ln3366">///</a>
<a name="ln3367">/// Errors out if the result is not an unsigned integer.</a>
<a name="ln3368">///</a>
<a name="ln3369">/// Unlike msgpack own function this one works with `FILE *` and reads *exactly*</a>
<a name="ln3370">/// as much bytes as needed, making it possible to avoid both maintaining own</a>
<a name="ln3371">/// buffer and calling `fseek`.</a>
<a name="ln3372">///</a>
<a name="ln3373">/// One byte from file stream is always consumed, even if it is not correct.</a>
<a name="ln3374">///</a>
<a name="ln3375">/// @param[in]   sd_reader  Structure containing file reader definition.</a>
<a name="ln3376">/// @param[out]  result     Location where result is saved.</a>
<a name="ln3377">///</a>
<a name="ln3378">/// @return kSDReadStatusSuccess if reading was successful,</a>
<a name="ln3379">///         kSDReadStatusNotShaDa if there were not enough bytes to read or</a>
<a name="ln3380">///         kSDReadStatusReadError if reading failed for whatever reason.</a>
<a name="ln3381">static ShaDaReadResult msgpack_read_uint64(ShaDaReadDef *const sd_reader,</a>
<a name="ln3382">                                           const int first_char,</a>
<a name="ln3383">                                           uint64_t *const result)</a>
<a name="ln3384">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3385">{</a>
<a name="ln3386">  const uintmax_t fpos = sd_reader-&gt;fpos - 1;</a>
<a name="ln3387"> </a>
<a name="ln3388">  if (first_char == EOF) {</a>
<a name="ln3389">    if (sd_reader-&gt;error) {</a>
<a name="ln3390">      emsgf(_(SERR &quot;System error while reading integer from ShaDa file: %s&quot;),</a>
<a name="ln3391">            sd_reader-&gt;error);</a>
<a name="ln3392">      return kSDReadStatusReadError;</a>
<a name="ln3393">    } else if (sd_reader-&gt;eof) {</a>
<a name="ln3394">      emsgf(_(RCERR &quot;Error while reading ShaDa file: &quot;</a>
<a name="ln3395">              &quot;expected positive integer at position %&quot; PRIu64</a>
<a name="ln3396">              &quot;, but got nothing&quot;),</a>
<a name="ln3397">            (uint64_t) fpos);</a>
<a name="ln3398">      return kSDReadStatusNotShaDa;</a>
<a name="ln3399">    }</a>
<a name="ln3400">  }</a>
<a name="ln3401"> </a>
<a name="ln3402">  if (~first_char &amp; 0x80) {</a>
<a name="ln3403">    // Positive fixnum</a>
<a name="ln3404">    *result = (uint64_t) ((uint8_t) first_char);</a>
<a name="ln3405">  } else {</a>
<a name="ln3406">    size_t length = 0;</a>
<a name="ln3407">    switch (first_char) {</a>
<a name="ln3408">      case 0xCC: {  // uint8</a>
<a name="ln3409">        length = 1;</a>
<a name="ln3410">        break;</a>
<a name="ln3411">      }</a>
<a name="ln3412">      case 0xCD: {  // uint16</a>
<a name="ln3413">        length = 2;</a>
<a name="ln3414">        break;</a>
<a name="ln3415">      }</a>
<a name="ln3416">      case 0xCE: {  // uint32</a>
<a name="ln3417">        length = 4;</a>
<a name="ln3418">        break;</a>
<a name="ln3419">      }</a>
<a name="ln3420">      case 0xCF: {  // uint64</a>
<a name="ln3421">        length = 8;</a>
<a name="ln3422">        break;</a>
<a name="ln3423">      }</a>
<a name="ln3424">      default: {</a>
<a name="ln3425">        emsgf(_(RCERR &quot;Error while reading ShaDa file: &quot;</a>
<a name="ln3426">                &quot;expected positive integer at position %&quot; PRIu64),</a>
<a name="ln3427">              (uint64_t) fpos);</a>
<a name="ln3428">        return kSDReadStatusNotShaDa;</a>
<a name="ln3429">      }</a>
<a name="ln3430">    }</a>
<a name="ln3431">    uint64_t buf = 0;</a>
<a name="ln3432">    char *buf_u8 = (char *) &amp;buf;</a>
<a name="ln3433">    ShaDaReadResult fl_ret;</a>
<a name="ln3434">    if ((fl_ret = fread_len(sd_reader, &amp;(buf_u8[sizeof(buf)-length]), length))</a>
<a name="ln3435">        != kSDReadStatusSuccess) {</a>
<a name="ln3436">      return fl_ret;</a>
<a name="ln3437">    }</a>
<a name="ln3438">    *result = be64toh(buf);</a>
<a name="ln3439">  }</a>
<a name="ln3440">  return kSDReadStatusSuccess;</a>
<a name="ln3441">}</a>
<a name="ln3442"> </a>
<a name="ln3443">#define READERR(entry_name, error_desc) \</a>
<a name="ln3444">    RERR &quot;Error while reading ShaDa file: &quot; \</a>
<a name="ln3445">    entry_name &quot; entry at position %&quot; PRIu64 &quot; &quot; \</a>
<a name="ln3446">    error_desc</a>
<a name="ln3447">#define CHECK_KEY(key, expected) ( \</a>
<a name="ln3448">    key.via.str.size == sizeof(expected) - 1 \</a>
<a name="ln3449">    &amp;&amp; STRNCMP(key.via.str.ptr, expected, sizeof(expected) - 1) == 0)</a>
<a name="ln3450">#define CLEAR_GA_AND_ERROR_OUT(ga) \</a>
<a name="ln3451">    do { \</a>
<a name="ln3452">      ga_clear(&amp;ga); \</a>
<a name="ln3453">      goto shada_read_next_item_error; \</a>
<a name="ln3454">    } while (0)</a>
<a name="ln3455">#define ID(s) s</a>
<a name="ln3456">#define BINDUP(b) xmemdupz(b.ptr, b.size)</a>
<a name="ln3457">#define TOINT(s) ((int) (s))</a>
<a name="ln3458">#define TOLONG(s) ((long) (s))</a>
<a name="ln3459">#define TOCHAR(s) ((char) (s))</a>
<a name="ln3460">#define TOU8(s) ((uint8_t) (s))</a>
<a name="ln3461">#define TOSIZE(s) ((size_t) (s))</a>
<a name="ln3462">#define CHECKED_ENTRY(condition, error_desc, entry_name, obj, tgt, attr, \</a>
<a name="ln3463">                      proc) \</a>
<a name="ln3464">  do { \</a>
<a name="ln3465">    if (!(condition)) { \</a>
<a name="ln3466">      emsgf(_(READERR(entry_name, error_desc)), initial_fpos); \</a>
<a name="ln3467">      CLEAR_GA_AND_ERROR_OUT(ad_ga); \</a>
<a name="ln3468">    } \</a>
<a name="ln3469">    tgt = proc(obj.via.attr); \</a>
<a name="ln3470">  } while (0)</a>
<a name="ln3471">#define CHECK_KEY_IS_STR(un, entry_name) \</a>
<a name="ln3472">  if (un.data.via.map.ptr[i].key.type != MSGPACK_OBJECT_STR) { \</a>
<a name="ln3473">    emsgf(_(READERR(entry_name, &quot;has key which is not a string&quot;)), \</a>
<a name="ln3474">          initial_fpos); \</a>
<a name="ln3475">    CLEAR_GA_AND_ERROR_OUT(ad_ga); \</a>
<a name="ln3476">  } else if (un.data.via.map.ptr[i].key.via.str.size == 0) { \</a>
<a name="ln3477">    emsgf(_(READERR(entry_name, &quot;has empty key&quot;)), initial_fpos); \</a>
<a name="ln3478">    CLEAR_GA_AND_ERROR_OUT(ad_ga); \</a>
<a name="ln3479">  }</a>
<a name="ln3480">#define CHECKED_KEY(un, entry_name, name, error_desc, tgt, condition, attr, \</a>
<a name="ln3481">                    proc) \</a>
<a name="ln3482">  else if (CHECK_KEY( /* NOLINT(readability/braces) */ \</a>
<a name="ln3483">      un.data.via.map.ptr[i].key, name)) { \</a>
<a name="ln3484">    CHECKED_ENTRY( \</a>
<a name="ln3485">        condition, &quot;has &quot; name &quot; key value &quot; error_desc, \</a>
<a name="ln3486">        entry_name, un.data.via.map.ptr[i].val, \</a>
<a name="ln3487">        tgt, attr, proc); \</a>
<a name="ln3488">  }</a>
<a name="ln3489">#define TYPED_KEY(un, entry_name, name, type_name, tgt, objtype, attr, proc) \</a>
<a name="ln3490">  CHECKED_KEY( \</a>
<a name="ln3491">      un, entry_name, name, &quot;which is not &quot; type_name, tgt, \</a>
<a name="ln3492">      un.data.via.map.ptr[i].val.type == MSGPACK_OBJECT_##objtype, \</a>
<a name="ln3493">      attr, proc)</a>
<a name="ln3494">#define BOOLEAN_KEY(un, entry_name, name, tgt) \</a>
<a name="ln3495">  TYPED_KEY(un, entry_name, name, &quot;a boolean&quot;, tgt, BOOLEAN, boolean, ID)</a>
<a name="ln3496">#define STRING_KEY(un, entry_name, name, tgt) \</a>
<a name="ln3497">  TYPED_KEY(un, entry_name, name, &quot;a binary&quot;, tgt, BIN, bin, BINDUP)</a>
<a name="ln3498">#define CONVERTED_STRING_KEY(un, entry_name, name, tgt) \</a>
<a name="ln3499">  TYPED_KEY(un, entry_name, name, &quot;a binary&quot;, tgt, BIN, bin, \</a>
<a name="ln3500">            BIN_CONVERTED)</a>
<a name="ln3501">#define INT_KEY(un, entry_name, name, tgt, proc) \</a>
<a name="ln3502">  CHECKED_KEY( \</a>
<a name="ln3503">      un, entry_name, name, &quot;which is not an integer&quot;, tgt, \</a>
<a name="ln3504">      ((un.data.via.map.ptr[i].val.type \</a>
<a name="ln3505">        == MSGPACK_OBJECT_POSITIVE_INTEGER) \</a>
<a name="ln3506">       || (un.data.via.map.ptr[i].val.type \</a>
<a name="ln3507">           == MSGPACK_OBJECT_NEGATIVE_INTEGER)), \</a>
<a name="ln3508">      i64, proc)</a>
<a name="ln3509">#define INTEGER_KEY(un, entry_name, name, tgt) \</a>
<a name="ln3510">  INT_KEY(un, entry_name, name, tgt, TOINT)</a>
<a name="ln3511">#define LONG_KEY(un, entry_name, name, tgt) \</a>
<a name="ln3512">  INT_KEY(un, entry_name, name, tgt, TOLONG)</a>
<a name="ln3513">#define ADDITIONAL_KEY(un) \</a>
<a name="ln3514">  else { /* NOLINT(readability/braces) */ \</a>
<a name="ln3515">    ga_grow(&amp;ad_ga, 1); \</a>
<a name="ln3516">    memcpy(((char *)ad_ga.ga_data) + ((size_t)ad_ga.ga_len \</a>
<a name="ln3517">                                      * sizeof(*un.data.via.map.ptr)), \</a>
<a name="ln3518">           un.data.via.map.ptr + i, \</a>
<a name="ln3519">           sizeof(*un.data.via.map.ptr)); \</a>
<a name="ln3520">    ad_ga.ga_len++; \</a>
<a name="ln3521">  }</a>
<a name="ln3522">#define CONVERTED(str, len) (xmemdupz((str), (len)))</a>
<a name="ln3523">#define BIN_CONVERTED(b) CONVERTED(b.ptr, b.size)</a>
<a name="ln3524">#define SET_ADDITIONAL_DATA(tgt, name) \</a>
<a name="ln3525">      do { \</a>
<a name="ln3526">        if (ad_ga.ga_len) { \</a>
<a name="ln3527">          msgpack_object obj = { \</a>
<a name="ln3528">            .type = MSGPACK_OBJECT_MAP, \</a>
<a name="ln3529">            .via = { \</a>
<a name="ln3530">              .map = { \</a>
<a name="ln3531">                .size = (uint32_t) ad_ga.ga_len, \</a>
<a name="ln3532">                .ptr = ad_ga.ga_data, \</a>
<a name="ln3533">              } \</a>
<a name="ln3534">            } \</a>
<a name="ln3535">          }; \</a>
<a name="ln3536">          typval_T adtv; \</a>
<a name="ln3537">          if (msgpack_to_vim(obj, &amp;adtv) == FAIL \</a>
<a name="ln3538">              || adtv.v_type != VAR_DICT) { \</a>
<a name="ln3539">            emsgf(_(READERR(name, \</a>
<a name="ln3540">                            &quot;cannot be converted to a VimL dictionary&quot;)), \</a>
<a name="ln3541">                  initial_fpos); \</a>
<a name="ln3542">            ga_clear(&amp;ad_ga); \</a>
<a name="ln3543">            tv_clear(&amp;adtv); \</a>
<a name="ln3544">            goto shada_read_next_item_error; \</a>
<a name="ln3545">          } \</a>
<a name="ln3546">          tgt = adtv.vval.v_dict; \</a>
<a name="ln3547">        } \</a>
<a name="ln3548">        ga_clear(&amp;ad_ga); \</a>
<a name="ln3549">      } while (0)</a>
<a name="ln3550">#define SET_ADDITIONAL_ELEMENTS(src, src_maxsize, tgt, name) \</a>
<a name="ln3551">      do { \</a>
<a name="ln3552">        if ((src).size &gt; (size_t) (src_maxsize)) { \</a>
<a name="ln3553">          msgpack_object obj = { \</a>
<a name="ln3554">            .type = MSGPACK_OBJECT_ARRAY, \</a>
<a name="ln3555">            .via = { \</a>
<a name="ln3556">              .array = { \</a>
<a name="ln3557">                .size = ((src).size - (uint32_t) (src_maxsize)), \</a>
<a name="ln3558">                .ptr = (src).ptr + (src_maxsize), \</a>
<a name="ln3559">              } \</a>
<a name="ln3560">            } \</a>
<a name="ln3561">          }; \</a>
<a name="ln3562">          typval_T aetv; \</a>
<a name="ln3563">          if (msgpack_to_vim(obj, &amp;aetv) == FAIL) { \</a>
<a name="ln3564">            emsgf(_(READERR(name, &quot;cannot be converted to a VimL list&quot;)), \</a>
<a name="ln3565">                  initial_fpos); \</a>
<a name="ln3566">            tv_clear(&amp;aetv); \</a>
<a name="ln3567">            goto shada_read_next_item_error; \</a>
<a name="ln3568">          } \</a>
<a name="ln3569">          assert(aetv.v_type == VAR_LIST); \</a>
<a name="ln3570">          (tgt) = aetv.vval.v_list; \</a>
<a name="ln3571">        } \</a>
<a name="ln3572">      } while (0)</a>
<a name="ln3573"> </a>
<a name="ln3574">/// Iterate over shada file contents</a>
<a name="ln3575">///</a>
<a name="ln3576">/// @param[in]   sd_reader  Structure containing file reader definition.</a>
<a name="ln3577">/// @param[out]  entry      Address where next entry contents will be saved.</a>
<a name="ln3578">/// @param[in]   flags      Flags, determining whether and which items should be</a>
<a name="ln3579">///                         skipped (see SRNIFlags enum).</a>
<a name="ln3580">/// @param[in]   max_kbyte  If non-zero, skip reading entries which have length</a>
<a name="ln3581">///                         greater then given.</a>
<a name="ln3582">///</a>
<a name="ln3583">/// @return Any value from ShaDaReadResult enum.</a>
<a name="ln3584">static ShaDaReadResult shada_read_next_item(ShaDaReadDef *const sd_reader,</a>
<a name="ln3585">                                            ShadaEntry *const entry,</a>
<a name="ln3586">                                            const unsigned flags,</a>
<a name="ln3587">                                            const size_t max_kbyte)</a>
<a name="ln3588">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3589">{</a>
<a name="ln3590">  ShaDaReadResult ret = kSDReadStatusMalformed;</a>
<a name="ln3591">shada_read_next_item_start:</a>
<a name="ln3592">  // Set entry type to kSDItemMissing and also make sure that all pointers in</a>
<a name="ln3593">  // data union are NULL so they are safe to xfree(). This is needed in case</a>
<a name="ln3594">  // somebody calls goto shada_read_next_item_error before anything is set in</a>
<a name="ln3595">  // the switch.</a>
<a name="ln3596">  memset(entry, 0, sizeof(*entry));</a>
<a name="ln3597">  if (sd_reader-&gt;eof) {</a>
<a name="ln3598">    return kSDReadStatusFinished;</a>
<a name="ln3599">  }</a>
<a name="ln3600"> </a>
<a name="ln3601">  // First: manually unpack type, timestamp and length.</a>
<a name="ln3602">  // This is needed to avoid both seeking and having to maintain a buffer.</a>
<a name="ln3603">  uint64_t type_u64 = (uint64_t) kSDItemMissing;</a>
<a name="ln3604">  uint64_t timestamp_u64;</a>
<a name="ln3605">  uint64_t length_u64;</a>
<a name="ln3606"> </a>
<a name="ln3607">  const uint64_t initial_fpos = (uint64_t) sd_reader-&gt;fpos;</a>
<a name="ln3608">  const int first_char = read_char(sd_reader);</a>
<a name="ln3609">  if (first_char == EOF &amp;&amp; sd_reader-&gt;eof) {</a>
<a name="ln3610">    return kSDReadStatusFinished;</a>
<a name="ln3611">  }</a>
<a name="ln3612"> </a>
<a name="ln3613">  ShaDaReadResult mru_ret;</a>
<a name="ln3614">  if (((mru_ret = msgpack_read_uint64(sd_reader, first_char, &amp;type_u64))</a>
<a name="ln3615">       != kSDReadStatusSuccess)</a>
<a name="ln3616">      || ((mru_ret = msgpack_read_uint64(sd_reader, read_char(sd_reader),</a>
<a name="ln3617">                                         &amp;timestamp_u64))</a>
<a name="ln3618">          != kSDReadStatusSuccess)</a>
<a name="ln3619">      || ((mru_ret = msgpack_read_uint64(sd_reader, read_char(sd_reader),</a>
<a name="ln3620">                                         &amp;length_u64))</a>
<a name="ln3621">          != kSDReadStatusSuccess)) {</a>
<a name="ln3622">    return mru_ret;</a>
<a name="ln3623">  }</a>
<a name="ln3624"> </a>
<a name="ln3625">  if (length_u64 &gt; PTRDIFF_MAX) {</a>
<a name="ln3626">    emsgf(_(RCERR &quot;Error while reading ShaDa file: &quot;</a>
<a name="ln3627">            &quot;there is an item at position %&quot; PRIu64 &quot; &quot;</a>
<a name="ln3628">            &quot;that is stated to be too long&quot;),</a>
<a name="ln3629">          initial_fpos);</a>
<a name="ln3630">    return kSDReadStatusNotShaDa;</a>
<a name="ln3631">  }</a>
<a name="ln3632"> </a>
<a name="ln3633">  const size_t length = (size_t)length_u64;</a>
<a name="ln3634">  entry-&gt;timestamp = (Timestamp)timestamp_u64;</a>
<a name="ln3635"> </a>
<a name="ln3636">  if (type_u64 == 0) {</a>
<a name="ln3637">    // kSDItemUnknown cannot possibly pass that far because it is -1 and that</a>
<a name="ln3638">    // will fail in msgpack_read_uint64. But kSDItemMissing may and it will</a>
<a name="ln3639">    // otherwise be skipped because (1 &lt;&lt; 0) will never appear in flags.</a>
<a name="ln3640">    emsgf(_(RCERR &quot;Error while reading ShaDa file: &quot;</a>
<a name="ln3641">            &quot;there is an item at position %&quot; PRIu64 &quot; &quot;</a>
<a name="ln3642">            &quot;that must not be there: Missing items are &quot;</a>
<a name="ln3643">            &quot;for internal uses only&quot;),</a>
<a name="ln3644">          initial_fpos);</a>
<a name="ln3645">    return kSDReadStatusNotShaDa;</a>
<a name="ln3646">  }</a>
<a name="ln3647"> </a>
<a name="ln3648">  if ((type_u64 &gt; SHADA_LAST_ENTRY</a>
<a name="ln3649">       ? !(flags &amp; kSDReadUnknown)</a>
<a name="ln3650">       : !((unsigned) (1 &lt;&lt; type_u64) &amp; flags))</a>
<a name="ln3651">      || (max_kbyte &amp;&amp; length &gt; max_kbyte * 1024)) {</a>
<a name="ln3652">    // First entry is unknown or equal to &quot;\n&quot; (10)? Most likely this means that</a>
<a name="ln3653">    // current file is not a ShaDa file because first item should normally be</a>
<a name="ln3654">    // a header (excluding tests where first item is tested item). Check this by</a>
<a name="ln3655">    // parsing entry contents: in non-ShaDa files this will most likely result</a>
<a name="ln3656">    // in incomplete MessagePack string.</a>
<a name="ln3657">    if (initial_fpos == 0</a>
<a name="ln3658">        &amp;&amp; (type_u64 == '\n' || type_u64 &gt; SHADA_LAST_ENTRY)) {</a>
<a name="ln3659">      const ShaDaReadResult spm_ret = shada_parse_msgpack(sd_reader, length,</a>
<a name="ln3660">                                                          NULL, NULL);</a>
<a name="ln3661">      if (spm_ret != kSDReadStatusSuccess) {</a>
<a name="ln3662">        return spm_ret;</a>
<a name="ln3663">      }</a>
<a name="ln3664">    } else {</a>
<a name="ln3665">      const ShaDaReadResult srs_ret = sd_reader_skip(sd_reader, length);</a>
<a name="ln3666">      if (srs_ret != kSDReadStatusSuccess) {</a>
<a name="ln3667">        return srs_ret;</a>
<a name="ln3668">      }</a>
<a name="ln3669">    }</a>
<a name="ln3670">    goto shada_read_next_item_start;</a>
<a name="ln3671">  }</a>
<a name="ln3672"> </a>
<a name="ln3673">  if (type_u64 &gt; SHADA_LAST_ENTRY) {</a>
<a name="ln3674">    entry-&gt;type = kSDItemUnknown;</a>
<a name="ln3675">    entry-&gt;data.unknown_item.size = length;</a>
<a name="ln3676">    entry-&gt;data.unknown_item.type = type_u64;</a>
<a name="ln3677">    if (initial_fpos == 0) {</a>
<a name="ln3678">      const ShaDaReadResult spm_ret = shada_parse_msgpack(</a>
<a name="ln3679">          sd_reader, length, NULL, &amp;entry-&gt;data.unknown_item.contents);</a>
<a name="ln3680">      if (spm_ret != kSDReadStatusSuccess) {</a>
<a name="ln3681">        entry-&gt;type = kSDItemMissing;</a>
<a name="ln3682">      }</a>
<a name="ln3683">      return spm_ret;</a>
<a name="ln3684">    } else {</a>
<a name="ln3685">      entry-&gt;data.unknown_item.contents = xmalloc(length);</a>
<a name="ln3686">      const ShaDaReadResult fl_ret = fread_len(</a>
<a name="ln3687">          sd_reader, entry-&gt;data.unknown_item.contents, length);</a>
<a name="ln3688">      if (fl_ret != kSDReadStatusSuccess) {</a>
<a name="ln3689">        shada_free_shada_entry(entry);</a>
<a name="ln3690">        entry-&gt;type = kSDItemMissing;</a>
<a name="ln3691">      }</a>
<a name="ln3692">      return fl_ret;</a>
<a name="ln3693">    }</a>
<a name="ln3694">  }</a>
<a name="ln3695"> </a>
<a name="ln3696">  msgpack_unpacked unpacked;</a>
<a name="ln3697">  char *buf = NULL;</a>
<a name="ln3698"> </a>
<a name="ln3699">  const ShaDaReadResult spm_ret = shada_parse_msgpack(sd_reader, length,</a>
<a name="ln3700">                                                      &amp;unpacked, &amp;buf);</a>
<a name="ln3701">  if (spm_ret != kSDReadStatusSuccess) {</a>
<a name="ln3702">    ret = spm_ret;</a>
<a name="ln3703">    goto shada_read_next_item_error;</a>
<a name="ln3704">  }</a>
<a name="ln3705">  ret = kSDReadStatusMalformed;</a>
<a name="ln3706">  entry-&gt;data = sd_default_values[type_u64].data;</a>
<a name="ln3707">  switch ((ShadaEntryType) type_u64) {</a>
<a name="ln3708">    case kSDItemHeader: {</a>
<a name="ln3709">      if (!msgpack_rpc_to_dictionary(&amp;(unpacked.data), &amp;(entry-&gt;data.header))) {</a>
<a name="ln3710">        emsgf(_(READERR(&quot;header&quot;, &quot;is not a dictionary&quot;)), initial_fpos);</a>
<a name="ln3711">        goto shada_read_next_item_error;</a>
<a name="ln3712">      }</a>
<a name="ln3713">      break;</a>
<a name="ln3714">    }</a>
<a name="ln3715">    case kSDItemSearchPattern: {</a>
<a name="ln3716">      if (unpacked.data.type != MSGPACK_OBJECT_MAP) {</a>
<a name="ln3717">        emsgf(_(READERR(&quot;search pattern&quot;, &quot;is not a dictionary&quot;)),</a>
<a name="ln3718">              initial_fpos);</a>
<a name="ln3719">        goto shada_read_next_item_error;</a>
<a name="ln3720">      }</a>
<a name="ln3721">      garray_T ad_ga;</a>
<a name="ln3722">      ga_init(&amp;ad_ga, sizeof(*(unpacked.data.via.map.ptr)), 1);</a>
<a name="ln3723">      for (size_t i = 0; i &lt; unpacked.data.via.map.size; i++) {</a>
<a name="ln3724">        CHECK_KEY_IS_STR(unpacked, &quot;search pattern&quot;)</a>
<a name="ln3725">        BOOLEAN_KEY(unpacked, &quot;search pattern&quot;, SEARCH_KEY_MAGIC,</a>
<a name="ln3726">                    entry-&gt;data.search_pattern.magic)</a>
<a name="ln3727">        BOOLEAN_KEY(unpacked, &quot;search pattern&quot;, SEARCH_KEY_SMARTCASE,</a>
<a name="ln3728">                    entry-&gt;data.search_pattern.smartcase)</a>
<a name="ln3729">        BOOLEAN_KEY(unpacked, &quot;search pattern&quot;, SEARCH_KEY_HAS_LINE_OFFSET,</a>
<a name="ln3730">                    entry-&gt;data.search_pattern.has_line_offset)</a>
<a name="ln3731">        BOOLEAN_KEY(unpacked, &quot;search pattern&quot;, SEARCH_KEY_PLACE_CURSOR_AT_END,</a>
<a name="ln3732">                    entry-&gt;data.search_pattern.place_cursor_at_end)</a>
<a name="ln3733">        BOOLEAN_KEY(unpacked, &quot;search pattern&quot;, SEARCH_KEY_IS_LAST_USED,</a>
<a name="ln3734">                    entry-&gt;data.search_pattern.is_last_used)</a>
<a name="ln3735">        BOOLEAN_KEY(unpacked, &quot;search pattern&quot;,</a>
<a name="ln3736">                    SEARCH_KEY_IS_SUBSTITUTE_PATTERN,</a>
<a name="ln3737">                    entry-&gt;data.search_pattern.is_substitute_pattern)</a>
<a name="ln3738">        BOOLEAN_KEY(unpacked, &quot;search pattern&quot;, SEARCH_KEY_HIGHLIGHTED,</a>
<a name="ln3739">                    entry-&gt;data.search_pattern.highlighted)</a>
<a name="ln3740">        BOOLEAN_KEY(unpacked, &quot;search pattern&quot;, SEARCH_KEY_BACKWARD,</a>
<a name="ln3741">                    entry-&gt;data.search_pattern.search_backward)</a>
<a name="ln3742">        INTEGER_KEY(unpacked, &quot;search pattern&quot;, SEARCH_KEY_OFFSET,</a>
<a name="ln3743">                    entry-&gt;data.search_pattern.offset)</a>
<a name="ln3744">        CONVERTED_STRING_KEY(unpacked, &quot;search pattern&quot;, SEARCH_KEY_PAT,</a>
<a name="ln3745">                             entry-&gt;data.search_pattern.pat)</a>
<a name="ln3746">        ADDITIONAL_KEY(unpacked)</a>
<a name="ln3747">      }</a>
<a name="ln3748">      if (entry-&gt;data.search_pattern.pat == NULL) {</a>
<a name="ln3749">        emsgf(_(READERR(&quot;search pattern&quot;, &quot;has no pattern&quot;)), initial_fpos);</a>
<a name="ln3750">        CLEAR_GA_AND_ERROR_OUT(ad_ga);</a>
<a name="ln3751">      }</a>
<a name="ln3752">      SET_ADDITIONAL_DATA(entry-&gt;data.search_pattern.additional_data,</a>
<a name="ln3753">                          &quot;search pattern&quot;);</a>
<a name="ln3754">      break;</a>
<a name="ln3755">    }</a>
<a name="ln3756">    case kSDItemChange:</a>
<a name="ln3757">    case kSDItemJump:</a>
<a name="ln3758">    case kSDItemGlobalMark:</a>
<a name="ln3759">    case kSDItemLocalMark: {</a>
<a name="ln3760">      if (unpacked.data.type != MSGPACK_OBJECT_MAP) {</a>
<a name="ln3761">        emsgf(_(READERR(&quot;mark&quot;, &quot;is not a dictionary&quot;)), initial_fpos);</a>
<a name="ln3762">        goto shada_read_next_item_error;</a>
<a name="ln3763">      }</a>
<a name="ln3764">      garray_T ad_ga;</a>
<a name="ln3765">      ga_init(&amp;ad_ga, sizeof(*(unpacked.data.via.map.ptr)), 1);</a>
<a name="ln3766">      for (size_t i = 0; i &lt; unpacked.data.via.map.size; i++) {</a>
<a name="ln3767">        CHECK_KEY_IS_STR(unpacked, &quot;mark&quot;)</a>
<a name="ln3768">        if (CHECK_KEY(unpacked.data.via.map.ptr[i].key, KEY_NAME_CHAR)) {</a>
<a name="ln3769">          if (type_u64 == kSDItemJump || type_u64 == kSDItemChange) {</a>
<a name="ln3770">            emsgf(_(READERR(&quot;mark&quot;, &quot;has n key which is only valid for &quot;</a>
<a name="ln3771">                            &quot;local and global mark entries&quot;)), initial_fpos);</a>
<a name="ln3772">            CLEAR_GA_AND_ERROR_OUT(ad_ga);</a>
<a name="ln3773">          }</a>
<a name="ln3774">          CHECKED_ENTRY(</a>
<a name="ln3775">              (unpacked.data.via.map.ptr[i].val.type</a>
<a name="ln3776">               == MSGPACK_OBJECT_POSITIVE_INTEGER),</a>
<a name="ln3777">              &quot;has n key value which is not an unsigned integer&quot;,</a>
<a name="ln3778">              &quot;mark&quot;, unpacked.data.via.map.ptr[i].val,</a>
<a name="ln3779">              entry-&gt;data.filemark.name, u64, TOCHAR);</a>
<a name="ln3780">        }</a>
<a name="ln3781">        LONG_KEY(unpacked, &quot;mark&quot;, KEY_LNUM, entry-&gt;data.filemark.mark.lnum)</a>
<a name="ln3782">        INTEGER_KEY(unpacked, &quot;mark&quot;, KEY_COL, entry-&gt;data.filemark.mark.col)</a>
<a name="ln3783">        STRING_KEY(unpacked, &quot;mark&quot;, KEY_FILE, entry-&gt;data.filemark.fname)</a>
<a name="ln3784">        ADDITIONAL_KEY(unpacked)</a>
<a name="ln3785">      }</a>
<a name="ln3786">      if (entry-&gt;data.filemark.fname == NULL) {</a>
<a name="ln3787">        emsgf(_(READERR(&quot;mark&quot;, &quot;is missing file name&quot;)), initial_fpos);</a>
<a name="ln3788">        CLEAR_GA_AND_ERROR_OUT(ad_ga);</a>
<a name="ln3789">      }</a>
<a name="ln3790">      if (entry-&gt;data.filemark.mark.lnum &lt;= 0) {</a>
<a name="ln3791">        emsgf(_(READERR(&quot;mark&quot;, &quot;has invalid line number&quot;)), initial_fpos);</a>
<a name="ln3792">        CLEAR_GA_AND_ERROR_OUT(ad_ga);</a>
<a name="ln3793">      }</a>
<a name="ln3794">      if (entry-&gt;data.filemark.mark.col &lt; 0) {</a>
<a name="ln3795">        emsgf(_(READERR(&quot;mark&quot;, &quot;has invalid column number&quot;)), initial_fpos);</a>
<a name="ln3796">        CLEAR_GA_AND_ERROR_OUT(ad_ga);</a>
<a name="ln3797">      }</a>
<a name="ln3798">      SET_ADDITIONAL_DATA(entry-&gt;data.filemark.additional_data, &quot;mark&quot;);</a>
<a name="ln3799">      break;</a>
<a name="ln3800">    }</a>
<a name="ln3801">    case kSDItemRegister: {</a>
<a name="ln3802">      if (unpacked.data.type != MSGPACK_OBJECT_MAP) {</a>
<a name="ln3803">        emsgf(_(READERR(&quot;register&quot;, &quot;is not a dictionary&quot;)), initial_fpos);</a>
<a name="ln3804">        goto shada_read_next_item_error;</a>
<a name="ln3805">      }</a>
<a name="ln3806">      garray_T ad_ga;</a>
<a name="ln3807">      ga_init(&amp;ad_ga, sizeof(*(unpacked.data.via.map.ptr)), 1);</a>
<a name="ln3808">      for (size_t i = 0; i &lt; unpacked.data.via.map.size; i++) {</a>
<a name="ln3809">        CHECK_KEY_IS_STR(unpacked, &quot;register&quot;)</a>
<a name="ln3810">        if (CHECK_KEY(unpacked.data.via.map.ptr[i].key,</a>
<a name="ln3811">                      REG_KEY_CONTENTS)) {</a>
<a name="ln3812">          if (unpacked.data.via.map.ptr[i].val.type != MSGPACK_OBJECT_ARRAY) {</a>
<a name="ln3813">            emsgf(_(READERR(&quot;register&quot;,</a>
<a name="ln3814">                            &quot;has &quot; REG_KEY_CONTENTS</a>
<a name="ln3815">                            &quot; key with non-array value&quot;)),</a>
<a name="ln3816">                  initial_fpos);</a>
<a name="ln3817">            CLEAR_GA_AND_ERROR_OUT(ad_ga);</a>
<a name="ln3818">          }</a>
<a name="ln3819">          if (unpacked.data.via.map.ptr[i].val.via.array.size == 0) {</a>
<a name="ln3820">            emsgf(_(READERR(&quot;register&quot;,</a>
<a name="ln3821">                            &quot;has &quot; REG_KEY_CONTENTS &quot; key with empty array&quot;)),</a>
<a name="ln3822">                  initial_fpos);</a>
<a name="ln3823">            CLEAR_GA_AND_ERROR_OUT(ad_ga);</a>
<a name="ln3824">          }</a>
<a name="ln3825">          const msgpack_object_array arr =</a>
<a name="ln3826">              unpacked.data.via.map.ptr[i].val.via.array;</a>
<a name="ln3827">          for (size_t j = 0; j &lt; arr.size; j++) {</a>
<a name="ln3828">            if (arr.ptr[j].type != MSGPACK_OBJECT_BIN) {</a>
<a name="ln3829">              emsgf(_(READERR(&quot;register&quot;, &quot;has &quot; REG_KEY_CONTENTS &quot; array &quot;</a>
<a name="ln3830">                              &quot;with non-binary value&quot;)), initial_fpos);</a>
<a name="ln3831">              CLEAR_GA_AND_ERROR_OUT(ad_ga);</a>
<a name="ln3832">            }</a>
<a name="ln3833">          }</a>
<a name="ln3834">          entry-&gt;data.reg.contents_size = arr.size;</a>
<a name="ln3835">          entry-&gt;data.reg.contents = xmalloc(arr.size * sizeof(char *));</a>
<a name="ln3836">          for (size_t j = 0; j &lt; arr.size; j++) {</a>
<a name="ln3837">            entry-&gt;data.reg.contents[j] = BIN_CONVERTED(arr.ptr[j].via.bin);</a>
<a name="ln3838">          }</a>
<a name="ln3839">        }</a>
<a name="ln3840">        BOOLEAN_KEY(unpacked, &quot;register&quot;, REG_KEY_UNNAMED,</a>
<a name="ln3841">                    entry-&gt;data.reg.is_unnamed)</a>
<a name="ln3842">        TYPED_KEY(unpacked, &quot;register&quot;, REG_KEY_TYPE, &quot;an unsigned integer&quot;,</a>
<a name="ln3843">                  entry-&gt;data.reg.type, POSITIVE_INTEGER, u64, TOU8)</a>
<a name="ln3844">        TYPED_KEY(unpacked, &quot;register&quot;, KEY_NAME_CHAR, &quot;an unsigned integer&quot;,</a>
<a name="ln3845">                  entry-&gt;data.reg.name, POSITIVE_INTEGER, u64, TOCHAR)</a>
<a name="ln3846">        TYPED_KEY(unpacked, &quot;register&quot;, REG_KEY_WIDTH, &quot;an unsigned integer&quot;,</a>
<a name="ln3847">                  entry-&gt;data.reg.width, POSITIVE_INTEGER, u64, TOSIZE)</a>
<a name="ln3848">        ADDITIONAL_KEY(unpacked)</a>
<a name="ln3849">      }</a>
<a name="ln3850">      if (entry-&gt;data.reg.contents == NULL) {</a>
<a name="ln3851">        emsgf(_(READERR(&quot;register&quot;, &quot;has missing &quot; REG_KEY_CONTENTS &quot; array&quot;)),</a>
<a name="ln3852">              initial_fpos);</a>
<a name="ln3853">        CLEAR_GA_AND_ERROR_OUT(ad_ga);</a>
<a name="ln3854">      }</a>
<a name="ln3855">      SET_ADDITIONAL_DATA(entry-&gt;data.reg.additional_data, &quot;register&quot;);</a>
<a name="ln3856">      break;</a>
<a name="ln3857">    }</a>
<a name="ln3858">    case kSDItemHistoryEntry: {</a>
<a name="ln3859">      if (unpacked.data.type != MSGPACK_OBJECT_ARRAY) {</a>
<a name="ln3860">        emsgf(_(READERR(&quot;history&quot;, &quot;is not an array&quot;)), initial_fpos);</a>
<a name="ln3861">        goto shada_read_next_item_error;</a>
<a name="ln3862">      }</a>
<a name="ln3863">      if (unpacked.data.via.array.size &lt; 2) {</a>
<a name="ln3864">        emsgf(_(READERR(&quot;history&quot;, &quot;does not have enough elements&quot;)),</a>
<a name="ln3865">              initial_fpos);</a>
<a name="ln3866">        goto shada_read_next_item_error;</a>
<a name="ln3867">      }</a>
<a name="ln3868">      if (unpacked.data.via.array.ptr[0].type</a>
<a name="ln3869">          != MSGPACK_OBJECT_POSITIVE_INTEGER) {</a>
<a name="ln3870">        emsgf(_(READERR(&quot;history&quot;, &quot;has wrong history type type&quot;)),</a>
<a name="ln3871">              initial_fpos);</a>
<a name="ln3872">        goto shada_read_next_item_error;</a>
<a name="ln3873">      }</a>
<a name="ln3874">      if (unpacked.data.via.array.ptr[1].type</a>
<a name="ln3875">          != MSGPACK_OBJECT_BIN) {</a>
<a name="ln3876">        emsgf(_(READERR(&quot;history&quot;, &quot;has wrong history string type&quot;)),</a>
<a name="ln3877">              initial_fpos);</a>
<a name="ln3878">        goto shada_read_next_item_error;</a>
<a name="ln3879">      }</a>
<a name="ln3880">      if (memchr(unpacked.data.via.array.ptr[1].via.bin.ptr, 0,</a>
<a name="ln3881">                 unpacked.data.via.array.ptr[1].via.bin.size) != NULL) {</a>
<a name="ln3882">        emsgf(_(READERR(&quot;history&quot;, &quot;contains string with zero byte inside&quot;)),</a>
<a name="ln3883">              initial_fpos);</a>
<a name="ln3884">        goto shada_read_next_item_error;</a>
<a name="ln3885">      }</a>
<a name="ln3886">      entry-&gt;data.history_item.histtype =</a>
<a name="ln3887">          (uint8_t) unpacked.data.via.array.ptr[0].via.u64;</a>
<a name="ln3888">      const bool is_hist_search =</a>
<a name="ln3889">          entry-&gt;data.history_item.histtype == HIST_SEARCH;</a>
<a name="ln3890">      if (is_hist_search) {</a>
<a name="ln3891">        if (unpacked.data.via.array.size &lt; 3) {</a>
<a name="ln3892">          emsgf(_(READERR(&quot;search history&quot;,</a>
<a name="ln3893">                          &quot;does not have separator character&quot;)), initial_fpos);</a>
<a name="ln3894">          goto shada_read_next_item_error;</a>
<a name="ln3895">        }</a>
<a name="ln3896">        if (unpacked.data.via.array.ptr[2].type</a>
<a name="ln3897">            != MSGPACK_OBJECT_POSITIVE_INTEGER) {</a>
<a name="ln3898">          emsgf(_(READERR(&quot;search history&quot;,</a>
<a name="ln3899">                          &quot;has wrong history separator type&quot;)), initial_fpos);</a>
<a name="ln3900">          goto shada_read_next_item_error;</a>
<a name="ln3901">        }</a>
<a name="ln3902">        entry-&gt;data.history_item.sep =</a>
<a name="ln3903">            (char) unpacked.data.via.array.ptr[2].via.u64;</a>
<a name="ln3904">      }</a>
<a name="ln3905">      size_t strsize;</a>
<a name="ln3906">      strsize = (</a>
<a name="ln3907">          unpacked.data.via.array.ptr[1].via.bin.size</a>
<a name="ln3908">          + 1  // Zero byte</a>
<a name="ln3909">          + 1);  // Separator character</a>
<a name="ln3910">      entry-&gt;data.history_item.string = xmalloc(strsize);</a>
<a name="ln3911">      memcpy(entry-&gt;data.history_item.string,</a>
<a name="ln3912">             unpacked.data.via.array.ptr[1].via.bin.ptr,</a>
<a name="ln3913">             unpacked.data.via.array.ptr[1].via.bin.size);</a>
<a name="ln3914">      entry-&gt;data.history_item.string[strsize - 2] = 0;</a>
<a name="ln3915">      entry-&gt;data.history_item.string[strsize - 1] =</a>
<a name="ln3916">          entry-&gt;data.history_item.sep;</a>
<a name="ln3917">      SET_ADDITIONAL_ELEMENTS(unpacked.data.via.array, (2 + is_hist_search),</a>
<a name="ln3918">                              entry-&gt;data.history_item.additional_elements,</a>
<a name="ln3919">                              &quot;history&quot;);</a>
<a name="ln3920">      break;</a>
<a name="ln3921">    }</a>
<a name="ln3922">    case kSDItemVariable: {</a>
<a name="ln3923">      if (unpacked.data.type != MSGPACK_OBJECT_ARRAY) {</a>
<a name="ln3924">        emsgf(_(READERR(&quot;variable&quot;, &quot;is not an array&quot;)), initial_fpos);</a>
<a name="ln3925">        goto shada_read_next_item_error;</a>
<a name="ln3926">      }</a>
<a name="ln3927">      if (unpacked.data.via.array.size &lt; 2) {</a>
<a name="ln3928">        emsgf(_(READERR(&quot;variable&quot;, &quot;does not have enough elements&quot;)),</a>
<a name="ln3929">              initial_fpos);</a>
<a name="ln3930">        goto shada_read_next_item_error;</a>
<a name="ln3931">      }</a>
<a name="ln3932">      if (unpacked.data.via.array.ptr[0].type != MSGPACK_OBJECT_BIN) {</a>
<a name="ln3933">        emsgf(_(READERR(&quot;variable&quot;, &quot;has wrong variable name type&quot;)),</a>
<a name="ln3934">              initial_fpos);</a>
<a name="ln3935">        goto shada_read_next_item_error;</a>
<a name="ln3936">      }</a>
<a name="ln3937">      entry-&gt;data.global_var.name =</a>
<a name="ln3938">          xmemdupz(unpacked.data.via.array.ptr[0].via.bin.ptr,</a>
<a name="ln3939">                   unpacked.data.via.array.ptr[0].via.bin.size);</a>
<a name="ln3940">      if (msgpack_to_vim(unpacked.data.via.array.ptr[1],</a>
<a name="ln3941">                         &amp;(entry-&gt;data.global_var.value)) == FAIL) {</a>
<a name="ln3942">        emsgf(_(READERR(&quot;variable&quot;, &quot;has value that cannot &quot;</a>
<a name="ln3943">                        &quot;be converted to the VimL value&quot;)), initial_fpos);</a>
<a name="ln3944">        goto shada_read_next_item_error;</a>
<a name="ln3945">      }</a>
<a name="ln3946">      SET_ADDITIONAL_ELEMENTS(unpacked.data.via.array, 2,</a>
<a name="ln3947">                              entry-&gt;data.global_var.additional_elements,</a>
<a name="ln3948">                              &quot;variable&quot;);</a>
<a name="ln3949">      break;</a>
<a name="ln3950">    }</a>
<a name="ln3951">    case kSDItemSubString: {</a>
<a name="ln3952">      if (unpacked.data.type != MSGPACK_OBJECT_ARRAY) {</a>
<a name="ln3953">        emsgf(_(READERR(&quot;sub string&quot;, &quot;is not an array&quot;)), initial_fpos);</a>
<a name="ln3954">        goto shada_read_next_item_error;</a>
<a name="ln3955">      }</a>
<a name="ln3956">      if (unpacked.data.via.array.size &lt; 1) {</a>
<a name="ln3957">        emsgf(_(READERR(&quot;sub string&quot;, &quot;does not have enough elements&quot;)),</a>
<a name="ln3958">              initial_fpos);</a>
<a name="ln3959">        goto shada_read_next_item_error;</a>
<a name="ln3960">      }</a>
<a name="ln3961">      if (unpacked.data.via.array.ptr[0].type != MSGPACK_OBJECT_BIN) {</a>
<a name="ln3962">        emsgf(_(READERR(&quot;sub string&quot;, &quot;has wrong sub string type&quot;)),</a>
<a name="ln3963">              initial_fpos);</a>
<a name="ln3964">        goto shada_read_next_item_error;</a>
<a name="ln3965">      }</a>
<a name="ln3966">      entry-&gt;data.sub_string.sub =</a>
<a name="ln3967">          BIN_CONVERTED(unpacked.data.via.array.ptr[0].via.bin);</a>
<a name="ln3968">      SET_ADDITIONAL_ELEMENTS(unpacked.data.via.array, 1,</a>
<a name="ln3969">                              entry-&gt;data.sub_string.additional_elements,</a>
<a name="ln3970">                              &quot;sub string&quot;);</a>
<a name="ln3971">      break;</a>
<a name="ln3972">    }</a>
<a name="ln3973">    case kSDItemBufferList: {</a>
<a name="ln3974">      if (unpacked.data.type != MSGPACK_OBJECT_ARRAY) {</a>
<a name="ln3975">        emsgf(_(READERR(&quot;buffer list&quot;, &quot;is not an array&quot;)), initial_fpos);</a>
<a name="ln3976">        goto shada_read_next_item_error;</a>
<a name="ln3977">      }</a>
<a name="ln3978">      if (unpacked.data.via.array.size == 0) {</a>
<a name="ln3979">        break;</a>
<a name="ln3980">      }</a>
<a name="ln3981">      entry-&gt;data.buffer_list.buffers =</a>
<a name="ln3982">          xcalloc(unpacked.data.via.array.size,</a>
<a name="ln3983">                  sizeof(*entry-&gt;data.buffer_list.buffers));</a>
<a name="ln3984">      for (size_t i = 0; i &lt; unpacked.data.via.array.size; i++) {</a>
<a name="ln3985">        entry-&gt;data.buffer_list.size++;</a>
<a name="ln3986">        msgpack_unpacked unpacked_2 = (msgpack_unpacked) {</a>
<a name="ln3987">          .data = unpacked.data.via.array.ptr[i],</a>
<a name="ln3988">        };</a>
<a name="ln3989">        {</a>
<a name="ln3990">          if (unpacked_2.data.type != MSGPACK_OBJECT_MAP) {</a>
<a name="ln3991">            emsgf(_(RERR &quot;Error while reading ShaDa file: &quot;</a>
<a name="ln3992">                    &quot;buffer list at position %&quot; PRIu64 &quot; &quot;</a>
<a name="ln3993">                    &quot;contains entry that is not a dictionary&quot;),</a>
<a name="ln3994">                  initial_fpos);</a>
<a name="ln3995">            goto shada_read_next_item_error;</a>
<a name="ln3996">          }</a>
<a name="ln3997">          entry-&gt;data.buffer_list.buffers[i].pos = default_pos;</a>
<a name="ln3998">          garray_T ad_ga;</a>
<a name="ln3999">          ga_init(&amp;ad_ga, sizeof(*(unpacked_2.data.via.map.ptr)), 1);</a>
<a name="ln4000">          {</a>
<a name="ln4001">            // XXX: Temporarily reassign `i` because the macros depend on it.</a>
<a name="ln4002">            const size_t j = i;</a>
<a name="ln4003">            {</a>
<a name="ln4004">              for (i = 0; i &lt; unpacked_2.data.via.map.size; i++) {  // -V535</a>
<a name="ln4005">                CHECK_KEY_IS_STR(unpacked_2, &quot;buffer list entry&quot;)</a>
<a name="ln4006">                LONG_KEY(unpacked_2, &quot;buffer list entry&quot;, KEY_LNUM,</a>
<a name="ln4007">                         entry-&gt;data.buffer_list.buffers[j].pos.lnum)</a>
<a name="ln4008">                INTEGER_KEY(unpacked_2, &quot;buffer list entry&quot;, KEY_COL,</a>
<a name="ln4009">                            entry-&gt;data.buffer_list.buffers[j].pos.col)</a>
<a name="ln4010">                STRING_KEY(unpacked_2, &quot;buffer list entry&quot;, KEY_FILE,</a>
<a name="ln4011">                           entry-&gt;data.buffer_list.buffers[j].fname)</a>
<a name="ln4012">                ADDITIONAL_KEY(unpacked_2)</a>
<a name="ln4013">              }</a>
<a name="ln4014">            }</a>
<a name="ln4015">            i = j;  // XXX: Restore `i`.</a>
<a name="ln4016">          }</a>
<a name="ln4017">          if (entry-&gt;data.buffer_list.buffers[i].pos.lnum &lt;= 0) {</a>
<a name="ln4018">            emsgf(_(RERR &quot;Error while reading ShaDa file: &quot;</a>
<a name="ln4019">                    &quot;buffer list at position %&quot; PRIu64 &quot; &quot;</a>
<a name="ln4020">                    &quot;contains entry with invalid line number&quot;),</a>
<a name="ln4021">                  initial_fpos);</a>
<a name="ln4022">            CLEAR_GA_AND_ERROR_OUT(ad_ga);</a>
<a name="ln4023">          }</a>
<a name="ln4024">          if (entry-&gt;data.buffer_list.buffers[i].pos.col &lt; 0) {</a>
<a name="ln4025">            emsgf(_(RERR &quot;Error while reading ShaDa file: &quot;</a>
<a name="ln4026">                    &quot;buffer list at position %&quot; PRIu64 &quot; &quot;</a>
<a name="ln4027">                    &quot;contains entry with invalid column number&quot;),</a>
<a name="ln4028">                  initial_fpos);</a>
<a name="ln4029">            CLEAR_GA_AND_ERROR_OUT(ad_ga);</a>
<a name="ln4030">          }</a>
<a name="ln4031">          if (entry-&gt;data.buffer_list.buffers[i].fname == NULL) {</a>
<a name="ln4032">            emsgf(_(RERR &quot;Error while reading ShaDa file: &quot;</a>
<a name="ln4033">                    &quot;buffer list at position %&quot; PRIu64 &quot; &quot;</a>
<a name="ln4034">                    &quot;contains entry that does not have a file name&quot;),</a>
<a name="ln4035">                  initial_fpos);</a>
<a name="ln4036">            CLEAR_GA_AND_ERROR_OUT(ad_ga);</a>
<a name="ln4037">          }</a>
<a name="ln4038">          SET_ADDITIONAL_DATA(</a>
<a name="ln4039">              entry-&gt;data.buffer_list.buffers[i].additional_data,</a>
<a name="ln4040">              &quot;buffer list entry&quot;);</a>
<a name="ln4041">        }</a>
<a name="ln4042">      }</a>
<a name="ln4043">      break;</a>
<a name="ln4044">    }</a>
<a name="ln4045">    case kSDItemMissing:</a>
<a name="ln4046">    case kSDItemUnknown: {</a>
<a name="ln4047">      abort();</a>
<a name="ln4048">    }</a>
<a name="ln4049">  }</a>
<a name="ln4050">  entry-&gt;type = (ShadaEntryType) type_u64;</a>
<a name="ln4051">  ret = kSDReadStatusSuccess;</a>
<a name="ln4052">shada_read_next_item_end:</a>
<a name="ln4053">  if (buf != NULL) {</a>
<a name="ln4054">    msgpack_unpacked_destroy(&amp;unpacked);</a>
<a name="ln4055">    xfree(buf);</a>
<a name="ln4056">  }</a>
<a name="ln4057">  return ret;</a>
<a name="ln4058">shada_read_next_item_error:</a>
<a name="ln4059">  entry-&gt;type = (ShadaEntryType) type_u64;</a>
<a name="ln4060">  shada_free_shada_entry(entry);</a>
<a name="ln4061">  entry-&gt;type = kSDItemMissing;</a>
<a name="ln4062">  goto shada_read_next_item_end;</a>
<a name="ln4063">}</a>
<a name="ln4064">#undef BIN_CONVERTED</a>
<a name="ln4065">#undef CONVERTED</a>
<a name="ln4066">#undef CHECK_KEY</a>
<a name="ln4067">#undef BOOLEAN_KEY</a>
<a name="ln4068">#undef CONVERTED_STRING_KEY</a>
<a name="ln4069">#undef STRING_KEY</a>
<a name="ln4070">#undef ADDITIONAL_KEY</a>
<a name="ln4071">#undef ID</a>
<a name="ln4072">#undef BINDUP</a>
<a name="ln4073">#undef TOCHAR</a>
<a name="ln4074">#undef TOINT</a>
<a name="ln4075">#undef TOLONG</a>
<a name="ln4076">#undef TYPED_KEY</a>
<a name="ln4077">#undef INT_KEY</a>
<a name="ln4078">#undef INTEGER_KEY</a>
<a name="ln4079">#undef LONG_KEY</a>
<a name="ln4080">#undef TOU8</a>
<a name="ln4081">#undef TOSIZE</a>
<a name="ln4082">#undef SET_ADDITIONAL_DATA</a>
<a name="ln4083">#undef SET_ADDITIONAL_ELEMENTS</a>
<a name="ln4084">#undef CLEAR_GA_AND_ERROR_OUT</a>
<a name="ln4085"> </a>
<a name="ln4086">/// Check whether &quot;name&quot; is on removable media (according to 'shada')</a>
<a name="ln4087">///</a>
<a name="ln4088">/// @param[in]  name  Checked name.</a>
<a name="ln4089">///</a>
<a name="ln4090">/// @return True if it is, false otherwise.</a>
<a name="ln4091">static bool shada_removable(const char *name)</a>
<a name="ln4092">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4093">{</a>
<a name="ln4094">  char  *p;</a>
<a name="ln4095">  char part[MAXPATHL + 1];</a>
<a name="ln4096">  bool retval = false;</a>
<a name="ln4097"> </a>
<a name="ln4098">  char *new_name = home_replace_save(NULL, name);</a>
<a name="ln4099">  for (p = (char *) p_shada; *p; ) {</a>
<a name="ln4100">    (void) copy_option_part(&amp;p, part, ARRAY_SIZE(part), &quot;, &quot;);</a>
<a name="ln4101">    if (part[0] == 'r') {</a>
<a name="ln4102">      home_replace(NULL, part + 1, NameBuff, MAXPATHL, true);</a>
<a name="ln4103">      size_t n = STRLEN(NameBuff);</a>
<a name="ln4104">      if (mb_strnicmp(NameBuff, new_name, n) == 0) {</a>
<a name="ln4105">        retval = true;</a>
<a name="ln4106">        break;</a>
<a name="ln4107">      }</a>
<a name="ln4108">    }</a>
<a name="ln4109">  }</a>
<a name="ln4110">  xfree(new_name);</a>
<a name="ln4111">  return retval;</a>
<a name="ln4112">}</a>
<a name="ln4113"> </a>
<a name="ln4114">/// Initialize ShaDa jumplist entries.</a>
<a name="ln4115">///</a>
<a name="ln4116">/// @param[in,out]  jumps           Array of ShaDa entries to set.</a>
<a name="ln4117">/// @param[in]      removable_bufs  Cache of buffers ignored due to their</a>
<a name="ln4118">///                                 location.</a>
<a name="ln4119">///</a>
<a name="ln4120">/// @return number of jumplist entries</a>
<a name="ln4121">static inline size_t shada_init_jumps(</a>
<a name="ln4122">    PossiblyFreedShadaEntry *jumps, khash_t(bufset) *const removable_bufs)</a>
<a name="ln4123">{</a>
<a name="ln4124">  if (!curwin-&gt;w_jumplistlen) {</a>
<a name="ln4125">    return 0;</a>
<a name="ln4126">  }</a>
<a name="ln4127"> </a>
<a name="ln4128">  size_t jumps_size = 0;</a>
<a name="ln4129">  const void *jump_iter = NULL;</a>
<a name="ln4130"> </a>
<a name="ln4131">  do {</a>
<a name="ln4132">    xfmark_T fm;</a>
<a name="ln4133">    jump_iter = mark_jumplist_iter(jump_iter, curwin, &amp;fm);</a>
<a name="ln4134"> </a>
<a name="ln4135">    if (fm.fmark.mark.lnum == 0) {</a>
<a name="ln4136">      iemsgf(&quot;ShaDa: mark lnum zero (ji:%p, js:%p, len:%i)&quot;,</a>
<a name="ln4137">             (void *)jump_iter, (void *)&amp;curwin-&gt;w_jumplist[0],</a>
<a name="ln4138">             curwin-&gt;w_jumplistlen);</a>
<a name="ln4139">      continue;</a>
<a name="ln4140">    }</a>
<a name="ln4141">    const buf_T *const buf = (fm.fmark.fnum == 0</a>
<a name="ln4142">                              ? NULL</a>
<a name="ln4143">                              : buflist_findnr(fm.fmark.fnum));</a>
<a name="ln4144">    if (buf != NULL</a>
<a name="ln4145">        ? in_bufset(removable_bufs, buf)</a>
<a name="ln4146">        : fm.fmark.fnum != 0) {</a>
<a name="ln4147">      continue;</a>
<a name="ln4148">    }</a>
<a name="ln4149">    const char *const fname = (char *) (fm.fmark.fnum == 0</a>
<a name="ln4150">                                        ? (fm.fname == NULL ? NULL : fm.fname)</a>
<a name="ln4151">                                        : buf ? buf-&gt;b_ffname : NULL);</a>
<a name="ln4152">    if (fname == NULL) {</a>
<a name="ln4153">      continue;</a>
<a name="ln4154">    }</a>
<a name="ln4155">    jumps[jumps_size++] = (PossiblyFreedShadaEntry) {</a>
<a name="ln4156">      .can_free_entry = false,</a>
<a name="ln4157">      .data = {</a>
<a name="ln4158">        .type = kSDItemJump,</a>
<a name="ln4159">        .timestamp = fm.fmark.timestamp,</a>
<a name="ln4160">        .data = {</a>
<a name="ln4161">          .filemark = {</a>
<a name="ln4162">            .name = NUL,</a>
<a name="ln4163">            .mark = fm.fmark.mark,</a>
<a name="ln4164">            .fname = (char *) fname,</a>
<a name="ln4165">            .additional_data = fm.fmark.additional_data,</a>
<a name="ln4166">          }</a>
<a name="ln4167">        }</a>
<a name="ln4168">      }</a>
<a name="ln4169">    };</a>
<a name="ln4170">  } while (jump_iter != NULL);</a>
<a name="ln4171">  return jumps_size;</a>
<a name="ln4172">}</a>
<a name="ln4173"> </a>
<a name="ln4174">/// Write registers ShaDa entries in given msgpack_sbuffer.</a>
<a name="ln4175">///</a>
<a name="ln4176">/// @param[in]  sbuf  target msgpack_sbuffer to write to.</a>
<a name="ln4177">void shada_encode_regs(msgpack_sbuffer *const sbuf)</a>
<a name="ln4178">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4179">{</a>
<a name="ln4180">  WriteMergerState *const wms = xcalloc(1, sizeof(*wms));</a>
<a name="ln4181">  shada_initialize_registers(wms, -1);</a>
<a name="ln4182">  msgpack_packer packer;</a>
<a name="ln4183">  msgpack_packer_init(&amp;packer, sbuf, msgpack_sbuffer_write);</a>
<a name="ln4184">  for (size_t i = 0; i &lt; ARRAY_SIZE(wms-&gt;registers); i++) {</a>
<a name="ln4185">    if (wms-&gt;registers[i].data.type == kSDItemRegister) {</a>
<a name="ln4186">      if (kSDWriteFailed</a>
<a name="ln4187">          == shada_pack_pfreed_entry(&amp;packer, wms-&gt;registers[i], 0)) {</a>
<a name="ln4188">        abort();</a>
<a name="ln4189">      }</a>
<a name="ln4190">    }</a>
<a name="ln4191">  }</a>
<a name="ln4192">  xfree(wms);</a>
<a name="ln4193">}</a>
<a name="ln4194"> </a>
<a name="ln4195">/// Write jumplist ShaDa entries in given msgpack_sbuffer.</a>
<a name="ln4196">///</a>
<a name="ln4197">/// @param[in]  sbuf            target msgpack_sbuffer to write to.</a>
<a name="ln4198">void shada_encode_jumps(msgpack_sbuffer *const sbuf)</a>
<a name="ln4199">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4200">{</a>
<a name="ln4201">  khash_t(bufset) removable_bufs = KHASH_EMPTY_TABLE(bufset);</a>
<a name="ln4202">  find_removable_bufs(&amp;removable_bufs);</a>
<a name="ln4203">  PossiblyFreedShadaEntry jumps[JUMPLISTSIZE];</a>
<a name="ln4204">  cleanup_jumplist(curwin, true);</a>
<a name="ln4205">  size_t jumps_size = shada_init_jumps(jumps, &amp;removable_bufs);</a>
<a name="ln4206">  msgpack_packer packer;</a>
<a name="ln4207">  msgpack_packer_init(&amp;packer, sbuf, msgpack_sbuffer_write);</a>
<a name="ln4208">  for (size_t i = 0; i &lt; jumps_size; i++) {</a>
<a name="ln4209">    if (kSDWriteFailed == shada_pack_pfreed_entry(&amp;packer, jumps[i], 0)) {</a>
<a name="ln4210">      abort();</a>
<a name="ln4211">    }</a>
<a name="ln4212">  }</a>
<a name="ln4213">}</a>
<a name="ln4214"> </a>
<a name="ln4215">/// Write buffer list ShaDa entry in given msgpack_sbuffer.</a>
<a name="ln4216">///</a>
<a name="ln4217">/// @param[in]  sbuf            target msgpack_sbuffer to write to.</a>
<a name="ln4218">void shada_encode_buflist(msgpack_sbuffer *const sbuf)</a>
<a name="ln4219">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4220">{</a>
<a name="ln4221">  khash_t(bufset) removable_bufs = KHASH_EMPTY_TABLE(bufset);</a>
<a name="ln4222">  find_removable_bufs(&amp;removable_bufs);</a>
<a name="ln4223">  ShadaEntry buflist_entry = shada_get_buflist(&amp;removable_bufs);</a>
<a name="ln4224">  msgpack_packer packer;</a>
<a name="ln4225">  msgpack_packer_init(&amp;packer, sbuf, msgpack_sbuffer_write);</a>
<a name="ln4226">  if (kSDWriteFailed == shada_pack_entry(&amp;packer, buflist_entry, 0)) {</a>
<a name="ln4227">    abort();</a>
<a name="ln4228">  }</a>
<a name="ln4229">  xfree(buflist_entry.data.buffer_list.buffers);</a>
<a name="ln4230">}</a>
<a name="ln4231"> </a>
<a name="ln4232">/// Write global variables ShaDa entries in given msgpack_sbuffer.</a>
<a name="ln4233">///</a>
<a name="ln4234">/// @param[in]  sbuf            target msgpack_sbuffer to write to.</a>
<a name="ln4235">void shada_encode_gvars(msgpack_sbuffer *const sbuf)</a>
<a name="ln4236">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4237">{</a>
<a name="ln4238">  msgpack_packer packer;</a>
<a name="ln4239">  msgpack_packer_init(&amp;packer, sbuf, msgpack_sbuffer_write);</a>
<a name="ln4240">  const void *var_iter = NULL;</a>
<a name="ln4241">  const Timestamp cur_timestamp = os_time();</a>
<a name="ln4242">  do {</a>
<a name="ln4243">    typval_T vartv;</a>
<a name="ln4244">    const char *name = NULL;</a>
<a name="ln4245">    var_iter = var_shada_iter(</a>
<a name="ln4246">        var_iter, &amp;name, &amp;vartv,</a>
<a name="ln4247">        VAR_FLAVOUR_DEFAULT | VAR_FLAVOUR_SESSION | VAR_FLAVOUR_SHADA);</a>
<a name="ln4248">    if (name == NULL) {</a>
<a name="ln4249">      break;</a>
<a name="ln4250">    }</a>
<a name="ln4251">    if (vartv.v_type != VAR_FUNC &amp;&amp; vartv.v_type != VAR_PARTIAL) {</a>
<a name="ln4252">      typval_T tgttv;</a>
<a name="ln4253">      tv_copy(&amp;vartv, &amp;tgttv);</a>
<a name="ln4254">      ShaDaWriteResult r = shada_pack_entry(&amp;packer, (ShadaEntry) {</a>
<a name="ln4255">        .type = kSDItemVariable,</a>
<a name="ln4256">        .timestamp = cur_timestamp,</a>
<a name="ln4257">        .data = {</a>
<a name="ln4258">          .global_var = {</a>
<a name="ln4259">            .name = (char *)name,</a>
<a name="ln4260">            .value = tgttv,</a>
<a name="ln4261">            .additional_elements = NULL,</a>
<a name="ln4262">          }</a>
<a name="ln4263">        }</a>
<a name="ln4264">      }, 0);</a>
<a name="ln4265">      if (kSDWriteFailed == r) {</a>
<a name="ln4266">        abort();</a>
<a name="ln4267">      }</a>
<a name="ln4268">      tv_clear(&amp;tgttv);</a>
<a name="ln4269">    }</a>
<a name="ln4270">    tv_clear(&amp;vartv);</a>
<a name="ln4271">  } while (var_iter != NULL);</a>
<a name="ln4272">}</a>
<a name="ln4273"> </a>
<a name="ln4274">/// Wrapper for reading from msgpack_sbuffer.</a>
<a name="ln4275">///</a>
<a name="ln4276">/// @return number of bytes read.</a>
<a name="ln4277">static ptrdiff_t read_sbuf(ShaDaReadDef *const sd_reader, void *const dest,</a>
<a name="ln4278">                           const size_t size)</a>
<a name="ln4279">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4280">{</a>
<a name="ln4281">  msgpack_sbuffer *sbuf = (msgpack_sbuffer *)sd_reader-&gt;cookie;</a>
<a name="ln4282">  const uintmax_t bytes_read = MIN(size, sbuf-&gt;size - sd_reader-&gt;fpos);</a>
<a name="ln4283">  if (bytes_read &lt; size) {</a>
<a name="ln4284">    sd_reader-&gt;eof = true;</a>
<a name="ln4285">  }</a>
<a name="ln4286">  memcpy(dest, sbuf-&gt;data + sd_reader-&gt;fpos, (size_t)bytes_read);</a>
<a name="ln4287">  sd_reader-&gt;fpos += bytes_read;</a>
<a name="ln4288">  return (ptrdiff_t)bytes_read;</a>
<a name="ln4289">}</a>
<a name="ln4290"> </a>
<a name="ln4291">/// Wrapper for read that ignores bytes read from msgpack_sbuffer.</a>
<a name="ln4292">///</a>
<a name="ln4293">/// Used for skipping.</a>
<a name="ln4294">///</a>
<a name="ln4295">/// @param[in,out]  sd_reader  ShaDaReadDef with msgpack_sbuffer.</a>
<a name="ln4296">/// @param[in]      offset     Amount of bytes to skip.</a>
<a name="ln4297">///</a>
<a name="ln4298">/// @return FAIL in case of failure, OK in case of success. May set</a>
<a name="ln4299">///         sd_reader-&gt;eof.</a>
<a name="ln4300">static int sd_sbuf_reader_skip_read(ShaDaReadDef *const sd_reader,</a>
<a name="ln4301">                                    const size_t offset)</a>
<a name="ln4302">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4303">{</a>
<a name="ln4304">  msgpack_sbuffer *sbuf = (msgpack_sbuffer *)sd_reader-&gt;cookie;</a>
<a name="ln4305">  assert(sbuf-&gt;size &gt;= sd_reader-&gt;fpos);</a>
<a name="ln4306">  const uintmax_t skip_bytes = MIN(offset, sbuf-&gt;size - sd_reader-&gt;fpos);</a>
<a name="ln4307">  if (skip_bytes &lt; offset) {</a>
<a name="ln4308">    sd_reader-&gt;eof = true;</a>
<a name="ln4309">    return FAIL;</a>
<a name="ln4310">  }</a>
<a name="ln4311">  sd_reader-&gt;fpos += offset;</a>
<a name="ln4312">  return OK;</a>
<a name="ln4313">}</a>
<a name="ln4314"> </a>
<a name="ln4315">/// Prepare ShaDaReadDef with msgpack_sbuffer for reading.</a>
<a name="ln4316">///</a>
<a name="ln4317">/// @param[in]   sbuf       msgpack_sbuffer to read from.</a>
<a name="ln4318">/// @param[out]  sd_reader  Location where reader structure will be saved.</a>
<a name="ln4319">static void open_shada_sbuf_for_reading(const msgpack_sbuffer *const sbuf,</a>
<a name="ln4320">                                        ShaDaReadDef *sd_reader)</a>
<a name="ln4321">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4322">{</a>
<a name="ln4323">  *sd_reader = (ShaDaReadDef) {</a>
<a name="ln4324">    .read = &amp;read_sbuf,</a>
<a name="ln4325">    .close = NULL,</a>
<a name="ln4326">    .skip = &amp;sd_sbuf_reader_skip_read,</a>
<a name="ln4327">    .error = NULL,</a>
<a name="ln4328">    .eof = false,</a>
<a name="ln4329">    .fpos = 0,</a>
<a name="ln4330">    .cookie = (void *)sbuf,</a>
<a name="ln4331">  };</a>
<a name="ln4332">}</a>
<a name="ln4333"> </a>
<a name="ln4334">/// Read ShaDa from msgpack_sbuffer.</a>
<a name="ln4335">///</a>
<a name="ln4336">/// @param[in]  file   msgpack_sbuffer to read from.</a>
<a name="ln4337">/// @param[in]  flags  Flags, see ShaDaReadFileFlags enum.</a>
<a name="ln4338">void shada_read_sbuf(msgpack_sbuffer *const sbuf, const int flags)</a>
<a name="ln4339">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4340">{</a>
<a name="ln4341">  assert(sbuf != NULL);</a>
<a name="ln4342">  if (sbuf-&gt;data == NULL) {</a>
<a name="ln4343">    return;</a>
<a name="ln4344">  }</a>
<a name="ln4345">  ShaDaReadDef sd_reader;</a>
<a name="ln4346">  open_shada_sbuf_for_reading(sbuf, &amp;sd_reader);</a>
<a name="ln4347">  shada_read(&amp;sd_reader, flags);</a>
<a name="ln4348">}</a>

</code></pre>
<div class="balloon" rel="4100"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
