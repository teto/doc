
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>input.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;assert.h&gt;</a>
<a name="ln5">#include &lt;string.h&gt;</a>
<a name="ln6">#include &lt;stdbool.h&gt;</a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;uv.h&gt;</a>
<a name="ln9"> </a>
<a name="ln10">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln11">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln12">#include &quot;nvim/event/loop.h&quot;</a>
<a name="ln13">#include &quot;nvim/event/rstream.h&quot;</a>
<a name="ln14">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln15">#include &quot;nvim/vim.h&quot;</a>
<a name="ln16">#include &quot;nvim/ui.h&quot;</a>
<a name="ln17">#include &quot;nvim/memory.h&quot;</a>
<a name="ln18">#include &quot;nvim/keymap.h&quot;</a>
<a name="ln19">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln20">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln21">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln22">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln23">#include &quot;nvim/main.h&quot;</a>
<a name="ln24">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln25">#include &quot;nvim/state.h&quot;</a>
<a name="ln26">#include &quot;nvim/msgpack_rpc/channel.h&quot;</a>
<a name="ln27"> </a>
<a name="ln28">#define READ_BUFFER_SIZE 0xfff</a>
<a name="ln29">#define INPUT_BUFFER_SIZE (READ_BUFFER_SIZE * 4)</a>
<a name="ln30"> </a>
<a name="ln31">typedef enum {</a>
<a name="ln32">  kInputNone,</a>
<a name="ln33">  kInputAvail,</a>
<a name="ln34">  kInputEof</a>
<a name="ln35">} InbufPollResult;</a>
<a name="ln36"> </a>
<a name="ln37">static Stream read_stream = { .closed = true };  // Input before UI starts.</a>
<a name="ln38">static RBuffer *input_buffer = NULL;</a>
<a name="ln39">static bool input_eof = false;</a>
<a name="ln40">static int global_fd = -1;</a>
<a name="ln41">static bool blocking = false;</a>
<a name="ln42"> </a>
<a name="ln43">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln44"># include &quot;os/input.c.generated.h&quot;</a>
<a name="ln45">#endif</a>
<a name="ln46"> </a>
<a name="ln47">void input_init(void)</a>
<a name="ln48">{</a>
<a name="ln49">  input_buffer = rbuffer_new(INPUT_BUFFER_SIZE + MAX_KEY_CODE_LEN);</a>
<a name="ln50">}</a>
<a name="ln51"> </a>
<a name="ln52">void input_global_fd_init(int fd)</a>
<a name="ln53">{</a>
<a name="ln54">  global_fd = fd;</a>
<a name="ln55">}</a>
<a name="ln56"> </a>
<a name="ln57">/// Global TTY (or pipe for &quot;-es&quot;) input stream, before UI starts.</a>
<a name="ln58">int input_global_fd(void)</a>
<a name="ln59">{</a>
<a name="ln60">  return global_fd;</a>
<a name="ln61">}</a>
<a name="ln62"> </a>
<a name="ln63">void input_start(int fd)</a>
<a name="ln64">{</a>
<a name="ln65">  if (!read_stream.closed) {</a>
<a name="ln66">    return;</a>
<a name="ln67">  }</a>
<a name="ln68"> </a>
<a name="ln69">  input_global_fd_init(fd);</a>
<a name="ln70">  rstream_init_fd(&amp;main_loop, &amp;read_stream, fd, READ_BUFFER_SIZE);</a>
<a name="ln71">  rstream_start(&amp;read_stream, input_read_cb, NULL);</a>
<a name="ln72">}</a>
<a name="ln73"> </a>
<a name="ln74">void input_stop(void)</a>
<a name="ln75">{</a>
<a name="ln76">  if (read_stream.closed) {</a>
<a name="ln77">    return;</a>
<a name="ln78">  }</a>
<a name="ln79"> </a>
<a name="ln80">  rstream_stop(&amp;read_stream);</a>
<a name="ln81">  stream_close(&amp;read_stream, NULL, NULL);</a>
<a name="ln82">}</a>
<a name="ln83"> </a>
<a name="ln84">static void cursorhold_event(void **argv)</a>
<a name="ln85">{</a>
<a name="ln86">  event_T event = State &amp; INSERT ? EVENT_CURSORHOLDI : EVENT_CURSORHOLD;</a>
<a name="ln87">  apply_autocmds(event, NULL, NULL, false, curbuf);</a>
<a name="ln88">  did_cursorhold = true;</a>
<a name="ln89">}</a>
<a name="ln90"> </a>
<a name="ln91">static void create_cursorhold_event(bool events_enabled)</a>
<a name="ln92">{</a>
<a name="ln93">  // If events are enabled and the queue has any items, this function should not</a>
<a name="ln94">  // have been called(inbuf_poll would return kInputAvail)</a>
<a name="ln95">  // TODO(tarruda): Cursorhold should be implemented as a timer set during the</a>
<a name="ln96">  // `state_check` callback for the states where it can be triggered.</a>
<a name="ln97">  assert(!events_enabled || multiqueue_empty(main_loop.events));</a>
<a name="ln98">  multiqueue_put(main_loop.events, cursorhold_event, 0);</a>
<a name="ln99">}</a>
<a name="ln100"> </a>
<a name="ln101">/// Low level input function</a>
<a name="ln102">///</a>
<a name="ln103">/// wait until either the input buffer is non-empty or , if `events` is not NULL</a>
<a name="ln104">/// until `events` is non-empty.</a>
<a name="ln105">int os_inchar(uint8_t *buf, int maxlen, int ms, int tb_change_cnt,</a>
<a name="ln106">              MultiQueue *events)</a>
<a name="ln107">{</a>
<a name="ln108">  if (maxlen &amp;&amp; rbuffer_size(input_buffer)) {</a>
<a name="ln109">    return (int)rbuffer_read(input_buffer, (char *)buf, (size_t)maxlen);</a>
<a name="ln110">  }</a>
<a name="ln111"> </a>
<a name="ln112">  InbufPollResult result;</a>
<a name="ln113">  if (ms &gt;= 0) {</a>
<a name="ln114">    if ((result = inbuf_poll(ms, events)) == kInputNone) {</a>
<a name="ln115">      return 0;</a>
<a name="ln116">    }</a>
<a name="ln117">  } else {</a>
<a name="ln118">    if ((result = inbuf_poll((int)p_ut, events)) == kInputNone) {</a>
<a name="ln119">      if (read_stream.closed &amp;&amp; silent_mode) {</a>
<a name="ln120">        // Drained eventloop &amp; initial input; exit silent/batch-mode (-es/-Es).</a>
<a name="ln121">        read_error_exit();</a>
<a name="ln122">      }</a>
<a name="ln123"> </a>
<a name="ln124">      if (trigger_cursorhold() &amp;&amp; !typebuf_changed(tb_change_cnt)) {</a>
<a name="ln125">        create_cursorhold_event(events == main_loop.events);</a>
<a name="ln126">      } else {</a>
<a name="ln127">        before_blocking();</a>
<a name="ln128">        result = inbuf_poll(-1, events);</a>
<a name="ln129">      }</a>
<a name="ln130">    }</a>
<a name="ln131">  }</a>
<a name="ln132"> </a>
<a name="ln133">  // If input was put directly in typeahead buffer bail out here.</a>
<a name="ln134">  if (typebuf_changed(tb_change_cnt)) {</a>
<a name="ln135">    return 0;</a>
<a name="ln136">  }</a>
<a name="ln137"> </a>
<a name="ln138">  if (maxlen &amp;&amp; rbuffer_size(input_buffer)) {</a>
<a name="ln139">    // Safe to convert rbuffer_read to int, it will never overflow since we use</a>
<a name="ln140">    // relatively small buffers.</a>
<a name="ln141">    return (int)rbuffer_read(input_buffer, (char *)buf, (size_t)maxlen);</a>
<a name="ln142">  }</a>
<a name="ln143"> </a>
<a name="ln144">  // If there are events, return the keys directly</a>
<a name="ln145">  if (maxlen &amp;&amp; pending_events(events)) {</a>
<a name="ln146">    return push_event_key(buf, maxlen);</a>
<a name="ln147">  }</a>
<a name="ln148"> </a>
<a name="ln149">  if (result == kInputEof) {</a>
<a name="ln150">    read_error_exit();</a>
<a name="ln151">  }</a>
<a name="ln152"> </a>
<a name="ln153">  return 0;</a>
<a name="ln154">}</a>
<a name="ln155"> </a>
<a name="ln156">// Check if a character is available for reading</a>
<a name="ln157">bool os_char_avail(void)</a>
<a name="ln158">{</a>
<a name="ln159">  return inbuf_poll(0, NULL) == kInputAvail;</a>
<a name="ln160">}</a>
<a name="ln161"> </a>
<a name="ln162">/// Poll for fast events. `got_int` will be set to `true` if CTRL-C was typed.</a>
<a name="ln163">///</a>
<a name="ln164">/// This invokes a full libuv loop iteration which can be quite costly.</a>
<a name="ln165">/// Prefer `line_breakcheck()` if called in a busy inner loop.</a>
<a name="ln166">///</a>
<a name="ln167">/// Caller must at least check `got_int` before calling this function again.</a>
<a name="ln168">/// checking for other low-level input state like `input_available()` might</a>
<a name="ln169">/// also be relevant (i e to throttle idle processing when user input is</a>
<a name="ln170">/// available)</a>
<a name="ln171">void os_breakcheck(void)</a>
<a name="ln172">{</a>
<a name="ln173">  if (got_int) {</a>
<a name="ln174">    return;</a>
<a name="ln175">  }</a>
<a name="ln176"> </a>
<a name="ln177">  int save_us = updating_screen;</a>
<a name="ln178">  // We do not want screen_resize() to redraw here.</a>
<a name="ln179">  // TODO(bfredl): we are already special casing redraw events, is this</a>
<a name="ln180">  // hack still needed?</a>
<a name="ln181">  updating_screen++;</a>
<a name="ln182"> </a>
<a name="ln183">  loop_poll_events(&amp;main_loop, 0);</a>
<a name="ln184"> </a>
<a name="ln185">  updating_screen = save_us;</a>
<a name="ln186">}</a>
<a name="ln187"> </a>
<a name="ln188"> </a>
<a name="ln189">/// Test whether a file descriptor refers to a terminal.</a>
<a name="ln190">///</a>
<a name="ln191">/// @param fd File descriptor.</a>
<a name="ln192">/// @return `true` if file descriptor refers to a terminal.</a>
<a name="ln193">bool os_isatty(int fd)</a>
<a name="ln194">{</a>
<a name="ln195">    return uv_guess_handle(fd) == UV_TTY;</a>
<a name="ln196">}</a>
<a name="ln197"> </a>
<a name="ln198">size_t input_enqueue(String keys)</a>
<a name="ln199">{</a>
<a name="ln200">  char *ptr = keys.data;</a>
<a name="ln201">  char *end = ptr + keys.size;</a>
<a name="ln202"> </a>
<a name="ln203">  while (rbuffer_space(input_buffer) &gt;= 19 &amp;&amp; ptr &lt; end) {</a>
<a name="ln204">    // A &quot;&lt;x&gt;&quot; form occupies at least 1 characters, and produces up</a>
<a name="ln205">    // to 19 characters (1 + 5 * 3 for the char and 3 for a modifier).</a>
<a name="ln206">    // In the case of K_SPECIAL(0x80) or CSI(0x9B), 3 bytes are escaped and</a>
<a name="ln207">    // needed, but since the keys are UTF-8, so the first byte cannot be</a>
<a name="ln208">    // K_SPECIAL(0x80) or CSI(0x9B).</a>
<a name="ln209">    uint8_t buf[19] = { 0 };</a>
<a name="ln210">    unsigned int new_size</a>
<a name="ln211">        = trans_special((const uint8_t **)&amp;ptr, (size_t)(end - ptr), buf, true,</a>
<a name="ln212">                        false);</a>
<a name="ln213"> </a>
<a name="ln214">    if (new_size) {</a>
<a name="ln215">      new_size = handle_mouse_event(&amp;ptr, buf, new_size);</a>
<a name="ln216">      rbuffer_write(input_buffer, (char *)buf, new_size);</a>
<a name="ln217">      continue;</a>
<a name="ln218">    }</a>
<a name="ln219"> </a>
<a name="ln220">    if (*ptr == '&lt;') {</a>
<a name="ln221">      char *old_ptr = ptr;</a>
<a name="ln222">      // Invalid or incomplete key sequence, skip until the next '&gt;' or *end.</a>
<a name="ln223">      do {</a>
<a name="ln224">        ptr++;</a>
<a name="ln225">      } while (ptr &lt; end &amp;&amp; *ptr != '&gt;');</a>
<a name="ln226">      if (*ptr != '&gt;') {</a>
<a name="ln227">        // Incomplete key sequence, return without consuming.</a>
<a name="ln228">        ptr = old_ptr;</a>
<a name="ln229">        break;</a>
<a name="ln230">      }</a>
<a name="ln231">      ptr++;</a>
<a name="ln232">      continue;</a>
<a name="ln233">    }</a>
<a name="ln234"> </a>
<a name="ln235">    // copy the character, escaping CSI and K_SPECIAL</a>
<a name="ln236">    if ((uint8_t)*ptr == CSI) {</a>
<a name="ln237">      rbuffer_write(input_buffer, (char *)&amp;(uint8_t){K_SPECIAL}, 1);</a>
<a name="ln238">      rbuffer_write(input_buffer, (char *)&amp;(uint8_t){KS_EXTRA}, 1);</a>
<a name="ln239">      rbuffer_write(input_buffer, (char *)&amp;(uint8_t){KE_CSI}, 1);</a>
<a name="ln240">    } else if ((uint8_t)*ptr == K_SPECIAL) {</a>
<a name="ln241">      rbuffer_write(input_buffer, (char *)&amp;(uint8_t){K_SPECIAL}, 1);</a>
<a name="ln242">      rbuffer_write(input_buffer, (char *)&amp;(uint8_t){KS_SPECIAL}, 1);</a>
<a name="ln243">      rbuffer_write(input_buffer, (char *)&amp;(uint8_t){KE_FILLER}, 1);</a>
<a name="ln244">    } else {</a>
<a name="ln245">      rbuffer_write(input_buffer, ptr, 1);</a>
<a name="ln246">    }</a>
<a name="ln247">    ptr++;</a>
<a name="ln248">  }</a>
<a name="ln249"> </a>
<a name="ln250">  size_t rv = (size_t)(ptr - keys.data);</a>
<a name="ln251">  process_interrupts();</a>
<a name="ln252">  return rv;</a>
<a name="ln253">}</a>
<a name="ln254"> </a>
<a name="ln255">static uint8_t check_multiclick(int code, int grid, int row, int col)</a>
<a name="ln256">{</a>
<a name="ln257">  static int orig_num_clicks = 0;</a>
<a name="ln258">  static int orig_mouse_code = 0;</a>
<a name="ln259">  static int orig_mouse_grid = 0;</a>
<a name="ln260">  static int orig_mouse_col = 0;</a>
<a name="ln261">  static int orig_mouse_row = 0;</a>
<a name="ln262">  static uint64_t orig_mouse_time = 0;  // time of previous mouse click</a>
<a name="ln263"> </a>
<a name="ln264">  if (code == KE_LEFTRELEASE || code == KE_RIGHTRELEASE</a>
<a name="ln265">      || code == KE_MIDDLERELEASE) {</a>
<a name="ln266">    return 0;</a>
<a name="ln267">  }</a>
<a name="ln268">  uint64_t mouse_time = os_hrtime();    // time of current mouse click (ns)</a>
<a name="ln269"> </a>
<a name="ln270">  // compute the time elapsed since the previous mouse click and</a>
<a name="ln271">  // convert p_mouse from ms to ns</a>
<a name="ln272">  uint64_t timediff = mouse_time - orig_mouse_time;</a>
<a name="ln273">  uint64_t mouset = (uint64_t)p_mouset * 1000000;</a>
<a name="ln274">  if (code == orig_mouse_code</a>
<a name="ln275">      &amp;&amp; timediff &lt; mouset</a>
<a name="ln276">      &amp;&amp; orig_num_clicks != 4</a>
<a name="ln277">      &amp;&amp; orig_mouse_grid == grid</a>
<a name="ln278">      &amp;&amp; orig_mouse_col == col</a>
<a name="ln279">      &amp;&amp; orig_mouse_row == row) {</a>
<a name="ln280">    orig_num_clicks++;</a>
<a name="ln281">  } else {</a>
<a name="ln282">    orig_num_clicks = 1;</a>
<a name="ln283">  }</a>
<a name="ln284">  orig_mouse_code = code;</a>
<a name="ln285">  orig_mouse_grid = grid;</a>
<a name="ln286">  orig_mouse_col = col;</a>
<a name="ln287">  orig_mouse_row = row;</a>
<a name="ln288">  orig_mouse_time = mouse_time;</a>
<a name="ln289"> </a>
<a name="ln290">  uint8_t modifiers = 0;</a>
<a name="ln291">  if (orig_num_clicks == 2) {</a>
<a name="ln292">    modifiers |= MOD_MASK_2CLICK;</a>
<a name="ln293">  } else if (orig_num_clicks == 3) {</a>
<a name="ln294">    modifiers |= MOD_MASK_3CLICK;</a>
<a name="ln295">  } else if (orig_num_clicks == 4) {</a>
<a name="ln296">    modifiers |= MOD_MASK_4CLICK;</a>
<a name="ln297">  }</a>
<a name="ln298">  return modifiers;</a>
<a name="ln299">}</a>
<a name="ln300"> </a>
<a name="ln301"> </a>
<a name="ln302">// Mouse event handling code(Extract row/col if available and detect multiple</a>
<a name="ln303">// clicks)</a>
<a name="ln304">static unsigned int handle_mouse_event(char **ptr, uint8_t *buf,</a>
<a name="ln305">                                       unsigned int bufsize)</a>
<a name="ln306">{</a>
<a name="ln307">  int mouse_code = 0;</a>
<a name="ln308">  int type = 0;</a>
<a name="ln309"> </a>
<a name="ln310">  if (bufsize == 3) {</a>
<a name="ln311">    mouse_code = buf[2];</a>
<a name="ln312">    type = buf[1];</a>
<a name="ln313">  } else if (bufsize == 6) {</a>
<a name="ln314">    // prefixed with K_SPECIAL KS_MODIFIER mod</a>
<a name="ln315">    mouse_code = buf[5];</a>
<a name="ln316">    type = buf[4];</a>
<a name="ln317">  }</a>
<a name="ln318"> </a>
<a name="ln319">  if (type != KS_EXTRA</a>
<a name="ln320">      || !((mouse_code &gt;= KE_LEFTMOUSE &amp;&amp; mouse_code &lt;= KE_RIGHTRELEASE)</a>
<a name="ln321">        || (mouse_code &gt;= KE_MOUSEDOWN &amp;&amp; mouse_code &lt;= KE_MOUSERIGHT))) {</a>
<a name="ln322">    return bufsize;</a>
<a name="ln323">  }</a>
<a name="ln324"> </a>
<a name="ln325">  // a &lt;[COL],[ROW]&gt; sequence can follow and will set the mouse_row/mouse_col</a>
<a name="ln326">  // global variables. This is ugly but its how the rest of the code expects to</a>
<a name="ln327">  // find mouse coordinates, and it would be too expensive to refactor this</a>
<a name="ln328">  // now.</a>
<a name="ln329">  int col, row, advance;</a>
<a name="ln330">  if (sscanf(*ptr, &quot;&lt;%d,%d&gt;%n&quot;, &amp;col, &amp;row, &amp;advance) != EOF &amp;&amp; advance) {</a>
<a name="ln331">    if (col &gt;= 0 &amp;&amp; row &gt;= 0) {</a>
<a name="ln332">      // Make sure the mouse position is valid.  Some terminals may</a>
<a name="ln333">      // return weird values.</a>
<a name="ln334">      if (col &gt;= Columns) {</a>
<a name="ln335">        col = Columns - 1;</a>
<a name="ln336">      }</a>
<a name="ln337">      if (row &gt;= Rows) {</a>
<a name="ln338">        row = Rows - 1;</a>
<a name="ln339">      }</a>
<a name="ln340">      mouse_grid = 0;</a>
<a name="ln341">      mouse_row = row;</a>
<a name="ln342">      mouse_col = col;</a>
<a name="ln343">    }</a>
<a name="ln344">    *ptr += advance;</a>
<a name="ln345">  }</a>
<a name="ln346"> </a>
<a name="ln347">  uint8_t modifiers = check_multiclick(mouse_code, mouse_grid,</a>
<a name="ln348">                                       mouse_row, mouse_col);</a>
<a name="ln349"> </a>
<a name="ln350">  if (modifiers) {</a>
<a name="ln351">    if (buf[1] != KS_MODIFIER) {</a>
<a name="ln352">      // no modifiers in the buffer yet, shift the bytes 3 positions</a>
<a name="ln353">      memcpy(buf + 3, buf, 3);</a>
<a name="ln354">      // add the modifier sequence</a>
<a name="ln355">      buf[0] = K_SPECIAL;</a>
<a name="ln356">      buf[1] = KS_MODIFIER;</a>
<a name="ln357">      buf[2] = modifiers;</a>
<a name="ln358">      bufsize += 3;</a>
<a name="ln359">    } else {</a>
<a name="ln360">      buf[2] |= modifiers;</a>
<a name="ln361">    }</a>
<a name="ln362">  }</a>
<a name="ln363"> </a>
<a name="ln364">  return bufsize;</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367">size_t input_enqueue_mouse(int code, uint8_t modifier,</a>
<a name="ln368">                           int grid, int row, int col)</a>
<a name="ln369">{</a>
<a name="ln370">  modifier |= check_multiclick(code, grid, row, col);</a>
<a name="ln371">  uint8_t buf[7], *p = buf;</a>
<a name="ln372">  if (modifier) {</a>
<a name="ln373">    p[0] = K_SPECIAL;</a>
<a name="ln374">    p[1] = KS_MODIFIER;</a>
<a name="ln375">    p[2] = modifier;</a>
<a name="ln376">    p += 3;</a>
<a name="ln377">  }</a>
<a name="ln378">  p[0] = K_SPECIAL;</a>
<a name="ln379">  p[1] = KS_EXTRA;</a>
<a name="ln380">  p[2] = (uint8_t)code;</a>
<a name="ln381"> </a>
<a name="ln382">  mouse_grid = grid;</a>
<a name="ln383">  mouse_row = row;</a>
<a name="ln384">  mouse_col = col;</a>
<a name="ln385"> </a>
<a name="ln386">  size_t written = 3 + (size_t)(p-buf);</a>
<a name="ln387">  rbuffer_write(input_buffer, (char *)buf, written);</a>
<a name="ln388">  return written;</a>
<a name="ln389">}</a>
<a name="ln390"> </a>
<a name="ln391">/// @return true if the main loop is blocked and waiting for input.</a>
<a name="ln392">bool input_blocking(void)</a>
<a name="ln393">{</a>
<a name="ln394">  return blocking;</a>
<a name="ln395">}</a>
<a name="ln396"> </a>
<a name="ln397">// This is a replacement for the old `WaitForChar` function in os_unix.c</a>
<a name="ln398">static InbufPollResult inbuf_poll(int ms, MultiQueue *events)</a>
<a name="ln399">{</a>
<a name="ln400">  if (input_ready(events)) {</a>
<a name="ln401">    return kInputAvail;</a>
<a name="ln402">  }</a>
<a name="ln403"> </a>
<a name="ln404">  if (do_profiling == PROF_YES &amp;&amp; ms) {</a>
<a name="ln405">    prof_inchar_enter();</a>
<a name="ln406">  }</a>
<a name="ln407"> </a>
<a name="ln408">  if ((ms == - 1 || ms &gt; 0) &amp;&amp; events != main_loop.events &amp;&amp; !input_eof) {</a>
<a name="ln409">    // The pending input provoked a blocking wait. Do special events now. #6247</a>
<a name="ln410">    blocking = true;</a>
<a name="ln411">    multiqueue_process_events(ch_before_blocking_events);</a>
<a name="ln412">  }</a>
<a name="ln413">  DLOG(&quot;blocking... events_enabled=%d events_pending=%d&quot;, events != NULL,</a>
<a name="ln414">       events &amp;&amp; !multiqueue_empty(events));</a>
<a name="ln415">  LOOP_PROCESS_EVENTS_UNTIL(&amp;main_loop, NULL, ms,</a>
<a name="ln416">                            input_ready(events) || input_eof);</a>
<a name="ln417">  blocking = false;</a>
<a name="ln418"> </a>
<a name="ln419">  if (do_profiling == PROF_YES &amp;&amp; ms) {</a>
<a name="ln420">    prof_inchar_exit();</a>
<a name="ln421">  }</a>
<a name="ln422"> </a>
<a name="ln423">  if (input_ready(events)) {</a>
<a name="ln424">    return kInputAvail;</a>
<a name="ln425">  } else {</a>
<a name="ln426">    return input_eof ? kInputEof : kInputNone;</a>
<a name="ln427">  }</a>
<a name="ln428">}</a>
<a name="ln429"> </a>
<a name="ln430">void input_done(void)</a>
<a name="ln431">{</a>
<a name="ln432">  input_eof = true;</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435">bool input_available(void)</a>
<a name="ln436">{</a>
<a name="ln437">  return rbuffer_size(input_buffer) != 0;</a>
<a name="ln438">}</a>
<a name="ln439"> </a>
<a name="ln440">static void input_read_cb(Stream *stream, RBuffer *buf, size_t c, void *data,</a>
<a name="ln441">                          bool at_eof)</a>
<a name="ln442">{</a>
<a name="ln443">  if (at_eof) {</a>
<a name="ln444">    input_done();</a>
<a name="ln445">  }</a>
<a name="ln446"> </a>
<a name="ln447">  assert(rbuffer_space(input_buffer) &gt;= rbuffer_size(buf));</a>
<a name="ln448">  RBUFFER_UNTIL_EMPTY(buf, ptr, len) {</a>
<a name="ln449">    (void)rbuffer_write(input_buffer, ptr, len);</a>
<a name="ln450">    rbuffer_consumed(buf, len);</a>
<a name="ln451">  }</a>
<a name="ln452">}</a>
<a name="ln453"> </a>
<a name="ln454">static void process_interrupts(void)</a>
<a name="ln455">{</a>
<a name="ln456">  if ((mapped_ctrl_c | curbuf-&gt;b_mapped_ctrl_c) &amp; get_real_state()) {</a>
<a name="ln457">    return;</a>
<a name="ln458">  }</a>
<a name="ln459"> </a>
<a name="ln460">  size_t consume_count = 0;</a>
<a name="ln461">  RBUFFER_EACH_REVERSE(input_buffer, c, i) {</a>
<a name="ln462">    if ((uint8_t)c == Ctrl_C) {</a>
<a name="ln463">      got_int = true;</a>
<a name="ln464">      consume_count = i;</a>
<a name="ln465">      break;</a>
<a name="ln466">    }</a>
<a name="ln467">  }</a>
<a name="ln468"> </a>
<a name="ln469">  if (got_int &amp;&amp; consume_count) {</a>
<a name="ln470">    // Remove all unprocessed input (typeahead) before the CTRL-C.</a>
<a name="ln471">    rbuffer_consumed(input_buffer, consume_count);</a>
<a name="ln472">  }</a>
<a name="ln473">}</a>
<a name="ln474"> </a>
<a name="ln475">// Helper function used to push bytes from the 'event' key sequence partially</a>
<a name="ln476">// between calls to os_inchar when maxlen &lt; 3</a>
<a name="ln477">static int push_event_key(uint8_t *buf, int maxlen)</a>
<a name="ln478">{</a>
<a name="ln479">  static const uint8_t key[3] = { K_SPECIAL, KS_EXTRA, KE_EVENT };</a>
<a name="ln480">  static int key_idx = 0;</a>
<a name="ln481">  int buf_idx = 0;</a>
<a name="ln482"> </a>
<a name="ln483">  do {</a>
<a name="ln484">    buf[buf_idx++] = key[key_idx++];</a>
<a name="ln485">    key_idx %= 3;</a>
<a name="ln486">  } while (key_idx &gt; 0 &amp;&amp; buf_idx &lt; maxlen);</a>
<a name="ln487"> </a>
<a name="ln488">  return buf_idx;</a>
<a name="ln489">}</a>
<a name="ln490"> </a>
<a name="ln491">// Check if there's pending input</a>
<a name="ln492">static bool input_ready(MultiQueue *events)</a>
<a name="ln493">{</a>
<a name="ln494">  return (typebuf_was_filled             // API call filled typeahead</a>
<a name="ln495">          || rbuffer_size(input_buffer)  // Input buffer filled</a>
<a name="ln496">          || pending_events(events));          // Events must be processed</a>
<a name="ln497">}</a>
<a name="ln498"> </a>
<a name="ln499">// Exit because of an input read error.</a>
<a name="ln500">static void read_error_exit(void)</a>
<a name="ln501">{</a>
<a name="ln502">  if (silent_mode) {  // Normal way to exit for &quot;nvim -es&quot;.</a>
<a name="ln503">    getout(0);</a>
<a name="ln504">  }</a>
<a name="ln505">  STRCPY(IObuff, _(&quot;Vim: Error reading input, exiting...\n&quot;));</a>
<a name="ln506">  preserve_exit();</a>
<a name="ln507">}</a>
<a name="ln508"> </a>
<a name="ln509">static bool pending_events(MultiQueue *events)</a>
<a name="ln510">{</a>
<a name="ln511">  return events &amp;&amp; !multiqueue_empty(events);</a>
<a name="ln512">}</a>

</code></pre>
<div class="balloon" rel="448"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1044/" target="_blank">V1044</a> Loop break conditions do not depend on the number of iterations.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
