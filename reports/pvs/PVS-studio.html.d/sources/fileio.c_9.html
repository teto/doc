
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>fileio.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// fileio.c: read from and write to a file</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;assert.h&gt;</a>
<a name="ln7">#include &lt;errno.h&gt;</a>
<a name="ln8">#include &lt;stdbool.h&gt;</a>
<a name="ln9">#include &lt;string.h&gt;</a>
<a name="ln10">#include &lt;inttypes.h&gt;</a>
<a name="ln11">#include &lt;fcntl.h&gt;</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;nvim/vim.h&quot;</a>
<a name="ln14">#include &quot;nvim/api/private/handle.h&quot;</a>
<a name="ln15">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln16">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln17">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln18">#include &quot;nvim/buffer_updates.h&quot;</a>
<a name="ln19">#include &quot;nvim/change.h&quot;</a>
<a name="ln20">#include &quot;nvim/charset.h&quot;</a>
<a name="ln21">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln22">#include &quot;nvim/diff.h&quot;</a>
<a name="ln23">#include &quot;nvim/edit.h&quot;</a>
<a name="ln24">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln25">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln26">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln27">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln28">#include &quot;nvim/fold.h&quot;</a>
<a name="ln29">#include &quot;nvim/func_attr.h&quot;</a>
<a name="ln30">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln31">#include &quot;nvim/hashtab.h&quot;</a>
<a name="ln32">#include &quot;nvim/iconv.h&quot;</a>
<a name="ln33">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln34">#include &quot;nvim/memfile.h&quot;</a>
<a name="ln35">#include &quot;nvim/memline.h&quot;</a>
<a name="ln36">#include &quot;nvim/memory.h&quot;</a>
<a name="ln37">#include &quot;nvim/message.h&quot;</a>
<a name="ln38">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln39">#include &quot;nvim/garray.h&quot;</a>
<a name="ln40">#include &quot;nvim/move.h&quot;</a>
<a name="ln41">#include &quot;nvim/normal.h&quot;</a>
<a name="ln42">#include &quot;nvim/option.h&quot;</a>
<a name="ln43">#include &quot;nvim/os_unix.h&quot;</a>
<a name="ln44">#include &quot;nvim/path.h&quot;</a>
<a name="ln45">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln46">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln47">#include &quot;nvim/screen.h&quot;</a>
<a name="ln48">#include &quot;nvim/search.h&quot;</a>
<a name="ln49">#include &quot;nvim/sha256.h&quot;</a>
<a name="ln50">#include &quot;nvim/state.h&quot;</a>
<a name="ln51">#include &quot;nvim/strings.h&quot;</a>
<a name="ln52">#include &quot;nvim/ui.h&quot;</a>
<a name="ln53">#include &quot;nvim/ui_compositor.h&quot;</a>
<a name="ln54">#include &quot;nvim/types.h&quot;</a>
<a name="ln55">#include &quot;nvim/undo.h&quot;</a>
<a name="ln56">#include &quot;nvim/window.h&quot;</a>
<a name="ln57">#include &quot;nvim/shada.h&quot;</a>
<a name="ln58">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln59">#include &quot;nvim/os/os_defs.h&quot;</a>
<a name="ln60">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln61">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln62"> </a>
<a name="ln63">#define BUFSIZE         8192    /* size of normal write buffer */</a>
<a name="ln64">#define SMBUFSIZE       256     /* size of emergency write buffer */</a>
<a name="ln65"> </a>
<a name="ln66">// For compatibility with libuv &lt; 1.20.0 (tested on 1.18.0)</a>
<a name="ln67">#ifndef UV_FS_COPYFILE_FICLONE</a>
<a name="ln68">#define UV_FS_COPYFILE_FICLONE 0</a>
<a name="ln69">#endif</a>
<a name="ln70"> </a>
<a name="ln71">#define HAS_BW_FLAGS</a>
<a name="ln72">#define FIO_LATIN1     0x01    /* convert Latin1 */</a>
<a name="ln73">#define FIO_UTF8       0x02    /* convert UTF-8 */</a>
<a name="ln74">#define FIO_UCS2       0x04    /* convert UCS-2 */</a>
<a name="ln75">#define FIO_UCS4       0x08    /* convert UCS-4 */</a>
<a name="ln76">#define FIO_UTF16      0x10    /* convert UTF-16 */</a>
<a name="ln77">#define FIO_ENDIAN_L   0x80    /* little endian */</a>
<a name="ln78">#define FIO_NOCONVERT  0x2000  /* skip encoding conversion */</a>
<a name="ln79">#define FIO_UCSBOM     0x4000  /* check for BOM at start of file */</a>
<a name="ln80">#define FIO_ALL        -1      /* allow all formats */</a>
<a name="ln81"> </a>
<a name="ln82">/* When converting, a read() or write() may leave some bytes to be converted</a>
<a name="ln83"> * for the next call.  The value is guessed... */</a>
<a name="ln84">#define CONV_RESTLEN 30</a>
<a name="ln85"> </a>
<a name="ln86">/* We have to guess how much a sequence of bytes may expand when converting</a>
<a name="ln87"> * with iconv() to be able to allocate a buffer. */</a>
<a name="ln88">#define ICONV_MULT 8</a>
<a name="ln89"> </a>
<a name="ln90">/*</a>
<a name="ln91"> * Structure to pass arguments from buf_write() to buf_write_bytes().</a>
<a name="ln92"> */</a>
<a name="ln93">struct bw_info {</a>
<a name="ln94">  int bw_fd;                     // file descriptor</a>
<a name="ln95">  char_u      *bw_buf;           // buffer with data to be written</a>
<a name="ln96">  int bw_len;                    // length of data</a>
<a name="ln97">#ifdef HAS_BW_FLAGS</a>
<a name="ln98">  int bw_flags;                  // FIO_ flags</a>
<a name="ln99">#endif</a>
<a name="ln100">  char_u bw_rest[CONV_RESTLEN];  // not converted bytes</a>
<a name="ln101">  int bw_restlen;                // nr of bytes in bw_rest[]</a>
<a name="ln102">  int bw_first;                  // first write call</a>
<a name="ln103">  char_u      *bw_conv_buf;      // buffer for writing converted chars</a>
<a name="ln104">  int bw_conv_buflen;            // size of bw_conv_buf</a>
<a name="ln105">  int bw_conv_error;             // set for conversion error</a>
<a name="ln106">  linenr_T bw_conv_error_lnum;   // first line with error or zero</a>
<a name="ln107">  linenr_T bw_start_lnum;        // line number at start of buffer</a>
<a name="ln108"># ifdef HAVE_ICONV</a>
<a name="ln109">  iconv_t bw_iconv_fd;           // descriptor for iconv() or -1</a>
<a name="ln110"># endif</a>
<a name="ln111">};</a>
<a name="ln112"> </a>
<a name="ln113">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln114"># include &quot;fileio.c.generated.h&quot;</a>
<a name="ln115">#endif</a>
<a name="ln116"> </a>
<a name="ln117">static char *e_auchangedbuf = N_(</a>
<a name="ln118">    &quot;E812: Autocommands changed buffer or buffer name&quot;);</a>
<a name="ln119"> </a>
<a name="ln120">void filemess(buf_T *buf, char_u *name, char_u *s, int attr)</a>
<a name="ln121">{</a>
<a name="ln122">  int msg_scroll_save;</a>
<a name="ln123"> </a>
<a name="ln124">  if (msg_silent != 0) {</a>
<a name="ln125">    return;</a>
<a name="ln126">  }</a>
<a name="ln127">  add_quoted_fname((char *)IObuff, IOSIZE - 100, buf, (const char *)name);</a>
<a name="ln128">  // Avoid an over-long translation to cause trouble.</a>
<a name="ln129">  xstrlcat((char *)IObuff, (const char *)s, IOSIZE);</a>
<a name="ln130">  // For the first message may have to start a new line.</a>
<a name="ln131">  // For further ones overwrite the previous one, reset msg_scroll before</a>
<a name="ln132">  // calling filemess().</a>
<a name="ln133">  msg_scroll_save = msg_scroll;</a>
<a name="ln134">  if (shortmess(SHM_OVERALL) &amp;&amp; !exiting &amp;&amp; p_verbose == 0)</a>
<a name="ln135">    msg_scroll = FALSE;</a>
<a name="ln136">  if (!msg_scroll)      /* wait a bit when overwriting an error msg */</a>
<a name="ln137">    check_for_delay(FALSE);</a>
<a name="ln138">  msg_start();</a>
<a name="ln139">  msg_scroll = msg_scroll_save;</a>
<a name="ln140">  msg_scrolled_ign = TRUE;</a>
<a name="ln141">  /* may truncate the message to avoid a hit-return prompt */</a>
<a name="ln142">  msg_outtrans_attr(msg_may_trunc(FALSE, IObuff), attr);</a>
<a name="ln143">  msg_clr_eos();</a>
<a name="ln144">  ui_flush();</a>
<a name="ln145">  msg_scrolled_ign = FALSE;</a>
<a name="ln146">}</a>
<a name="ln147"> </a>
<a name="ln148"> </a>
<a name="ln149">/*</a>
<a name="ln150"> * Read lines from file &quot;fname&quot; into the buffer after line &quot;from&quot;.</a>
<a name="ln151"> *</a>
<a name="ln152"> * 1. We allocate blocks with try_malloc, as big as possible.</a>
<a name="ln153"> * 2. Each block is filled with characters from the file with a single read().</a>
<a name="ln154"> * 3. The lines are inserted in the buffer with ml_append().</a>
<a name="ln155"> *</a>
<a name="ln156"> * (caller must check that fname != NULL, unless READ_STDIN is used)</a>
<a name="ln157"> *</a>
<a name="ln158"> * &quot;lines_to_skip&quot; is the number of lines that must be skipped</a>
<a name="ln159"> * &quot;lines_to_read&quot; is the number of lines that are appended</a>
<a name="ln160"> * When not recovering lines_to_skip is 0 and lines_to_read MAXLNUM.</a>
<a name="ln161"> *</a>
<a name="ln162"> * flags:</a>
<a name="ln163"> * READ_NEW	starting to edit a new buffer</a>
<a name="ln164"> * READ_FILTER	reading filter output</a>
<a name="ln165"> * READ_STDIN	read from stdin instead of a file</a>
<a name="ln166"> * READ_BUFFER	read from curbuf instead of a file (converting after reading</a>
<a name="ln167"> *		stdin)</a>
<a name="ln168"> * READ_DUMMY	read into a dummy buffer (to check if file contents changed)</a>
<a name="ln169"> * READ_KEEP_UNDO  don't clear undo info or read it from a file</a>
<a name="ln170"> * READ_FIFO	read from fifo/socket instead of a file</a>
<a name="ln171"> *</a>
<a name="ln172"> * return FAIL for failure, NOTDONE for directory (failure), or OK</a>
<a name="ln173"> */</a>
<a name="ln174">int</a>
<a name="ln175">readfile(</a>
<a name="ln176">    char_u *fname,</a>
<a name="ln177">    char_u *sfname,</a>
<a name="ln178">    linenr_T from,</a>
<a name="ln179">    linenr_T lines_to_skip,</a>
<a name="ln180">    linenr_T lines_to_read,</a>
<a name="ln181">    exarg_T *eap,                       // can be NULL!</a>
<a name="ln182">    int flags</a>
<a name="ln183">)</a>
<a name="ln184">{</a>
<a name="ln185">  int fd = 0;</a>
<a name="ln186">  int newfile = (flags &amp; READ_NEW);</a>
<a name="ln187">  int check_readonly;</a>
<a name="ln188">  int filtering = (flags &amp; READ_FILTER);</a>
<a name="ln189">  int read_stdin = (flags &amp; READ_STDIN);</a>
<a name="ln190">  int read_buffer = (flags &amp; READ_BUFFER);</a>
<a name="ln191">  int read_fifo = (flags &amp; READ_FIFO);</a>
<a name="ln192">  int set_options = newfile || read_buffer</a>
<a name="ln193">                    || (eap != NULL &amp;&amp; eap-&gt;read_edit);</a>
<a name="ln194">  linenr_T read_buf_lnum = 1;           /* next line to read from curbuf */</a>
<a name="ln195">  colnr_T read_buf_col = 0;             /* next char to read from this line */</a>
<a name="ln196">  char_u c;</a>
<a name="ln197">  linenr_T lnum = from;</a>
<a name="ln198">  char_u      *ptr = NULL;              /* pointer into read buffer */</a>
<a name="ln199">  char_u      *buffer = NULL;           /* read buffer */</a>
<a name="ln200">  char_u      *new_buffer = NULL;       /* init to shut up gcc */</a>
<a name="ln201">  char_u      *line_start = NULL;       /* init to shut up gcc */</a>
<a name="ln202">  int wasempty;                         /* buffer was empty before reading */</a>
<a name="ln203">  colnr_T len;</a>
<a name="ln204">  long size = 0;</a>
<a name="ln205">  uint8_t *p = NULL;</a>
<a name="ln206">  off_T filesize = 0;</a>
<a name="ln207">  int skip_read = false;</a>
<a name="ln208">  context_sha256_T sha_ctx;</a>
<a name="ln209">  int read_undo_file = false;</a>
<a name="ln210">  int split = 0;  // number of split lines</a>
<a name="ln211">  linenr_T linecnt;</a>
<a name="ln212">  int error = FALSE;                    /* errors encountered */</a>
<a name="ln213">  int ff_error = EOL_UNKNOWN;           /* file format with errors */</a>
<a name="ln214">  long linerest = 0;                    /* remaining chars in line */</a>
<a name="ln215">  int perm = 0;</a>
<a name="ln216">#ifdef UNIX</a>
<a name="ln217">  int swap_mode = -1;                   /* protection bits for swap file */</a>
<a name="ln218">#endif</a>
<a name="ln219">  int fileformat = 0;                   // end-of-line format</a>
<a name="ln220">  bool keep_fileformat = false;</a>
<a name="ln221">  FileInfo file_info;</a>
<a name="ln222">  int file_readonly;</a>
<a name="ln223">  linenr_T skip_count = 0;</a>
<a name="ln224">  linenr_T read_count = 0;</a>
<a name="ln225">  int msg_save = msg_scroll;</a>
<a name="ln226">  linenr_T read_no_eol_lnum = 0;        // non-zero lnum when last line of</a>
<a name="ln227">                                        // last read was missing the eol</a>
<a name="ln228">  bool file_rewind = false;</a>
<a name="ln229">  int can_retry;</a>
<a name="ln230">  linenr_T conv_error = 0;              // line nr with conversion error</a>
<a name="ln231">  linenr_T illegal_byte = 0;            // line nr with illegal byte</a>
<a name="ln232">  bool keep_dest_enc = false;           // don't retry when char doesn't fit</a>
<a name="ln233">                                        // in destination encoding</a>
<a name="ln234">  int bad_char_behavior = BAD_REPLACE;</a>
<a name="ln235">  /* BAD_KEEP, BAD_DROP or character to</a>
<a name="ln236">   * replace with */</a>
<a name="ln237">  char_u      *tmpname = NULL;          /* name of 'charconvert' output file */</a>
<a name="ln238">  int fio_flags = 0;</a>
<a name="ln239">  char_u      *fenc;                    // fileencoding to use</a>
<a name="ln240">  bool fenc_alloced;                    // fenc_next is in allocated memory</a>
<a name="ln241">  char_u      *fenc_next = NULL;        // next item in 'fencs' or NULL</a>
<a name="ln242">  bool advance_fenc = false;</a>
<a name="ln243">  long real_size = 0;</a>
<a name="ln244"># ifdef HAVE_ICONV</a>
<a name="ln245">  iconv_t iconv_fd = (iconv_t)-1;       // descriptor for iconv() or -1</a>
<a name="ln246">  int did_iconv = false;                // TRUE when iconv() failed and trying</a>
<a name="ln247">                                        // 'charconvert' next</a>
<a name="ln248"># endif</a>
<a name="ln249">  int converted = FALSE;                /* TRUE if conversion done */</a>
<a name="ln250">  int notconverted = FALSE;             /* TRUE if conversion wanted but it</a>
<a name="ln251">                                           wasn't possible */</a>
<a name="ln252">  char_u conv_rest[CONV_RESTLEN];</a>
<a name="ln253">  int conv_restlen = 0;                 /* nr of bytes in conv_rest[] */</a>
<a name="ln254">  buf_T       *old_curbuf;</a>
<a name="ln255">  char_u      *old_b_ffname;</a>
<a name="ln256">  char_u      *old_b_fname;</a>
<a name="ln257">  int using_b_ffname;</a>
<a name="ln258">  int using_b_fname;</a>
<a name="ln259">  static char *msg_is_a_directory = N_(&quot;is a directory&quot;);</a>
<a name="ln260"> </a>
<a name="ln261">  au_did_filetype = false;  // reset before triggering any autocommands</a>
<a name="ln262"> </a>
<a name="ln263">  curbuf-&gt;b_no_eol_lnum = 0;    /* in case it was set by the previous read */</a>
<a name="ln264"> </a>
<a name="ln265">  /*</a>
<a name="ln266">   * If there is no file name yet, use the one for the read file.</a>
<a name="ln267">   * BF_NOTEDITED is set to reflect this.</a>
<a name="ln268">   * Don't do this for a read from a filter.</a>
<a name="ln269">   * Only do this when 'cpoptions' contains the 'f' flag.</a>
<a name="ln270">   */</a>
<a name="ln271">  if (curbuf-&gt;b_ffname == NULL</a>
<a name="ln272">      &amp;&amp; !filtering</a>
<a name="ln273">      &amp;&amp; fname != NULL</a>
<a name="ln274">      &amp;&amp; vim_strchr(p_cpo, CPO_FNAMER) != NULL</a>
<a name="ln275">      &amp;&amp; !(flags &amp; READ_DUMMY)) {</a>
<a name="ln276">    if (set_rw_fname(fname, sfname) == FAIL)</a>
<a name="ln277">      return FAIL;</a>
<a name="ln278">  }</a>
<a name="ln279"> </a>
<a name="ln280">  /* Remember the initial values of curbuf, curbuf-&gt;b_ffname and</a>
<a name="ln281">   * curbuf-&gt;b_fname to detect whether they are altered as a result of</a>
<a name="ln282">   * executing nasty autocommands.  Also check if &quot;fname&quot; and &quot;sfname&quot;</a>
<a name="ln283">   * point to one of these values. */</a>
<a name="ln284">  old_curbuf = curbuf;</a>
<a name="ln285">  old_b_ffname = curbuf-&gt;b_ffname;</a>
<a name="ln286">  old_b_fname = curbuf-&gt;b_fname;</a>
<a name="ln287">  using_b_ffname = (fname == curbuf-&gt;b_ffname)</a>
<a name="ln288">                   || (sfname == curbuf-&gt;b_ffname);</a>
<a name="ln289">  using_b_fname = (fname == curbuf-&gt;b_fname) || (sfname == curbuf-&gt;b_fname);</a>
<a name="ln290"> </a>
<a name="ln291">  /* After reading a file the cursor line changes but we don't want to</a>
<a name="ln292">   * display the line. */</a>
<a name="ln293">  ex_no_reprint = TRUE;</a>
<a name="ln294"> </a>
<a name="ln295">  /* don't display the file info for another buffer now */</a>
<a name="ln296">  need_fileinfo = FALSE;</a>
<a name="ln297"> </a>
<a name="ln298">  // For Unix: Use the short file name whenever possible.</a>
<a name="ln299">  // Avoids problems with networks and when directory names are changed.</a>
<a name="ln300">  // Don't do this for Windows, a &quot;cd&quot; in a sub-shell may have moved us to</a>
<a name="ln301">  // another directory, which we don't detect.</a>
<a name="ln302">  if (sfname == NULL) {</a>
<a name="ln303">    sfname = fname;</a>
<a name="ln304">  }</a>
<a name="ln305">#if defined(UNIX)</a>
<a name="ln306">  fname = sfname;</a>
<a name="ln307">#endif</a>
<a name="ln308"> </a>
<a name="ln309">  /*</a>
<a name="ln310">   * The BufReadCmd and FileReadCmd events intercept the reading process by</a>
<a name="ln311">   * executing the associated commands instead.</a>
<a name="ln312">   */</a>
<a name="ln313">  if (!filtering &amp;&amp; !read_stdin &amp;&amp; !read_buffer) {</a>
<a name="ln314">    pos_T pos;</a>
<a name="ln315"> </a>
<a name="ln316">    pos = curbuf-&gt;b_op_start;</a>
<a name="ln317"> </a>
<a name="ln318">    /* Set '[ mark to the line above where the lines go (line 1 if zero). */</a>
<a name="ln319">    curbuf-&gt;b_op_start.lnum = ((from == 0) ? 1 : from);</a>
<a name="ln320">    curbuf-&gt;b_op_start.col = 0;</a>
<a name="ln321"> </a>
<a name="ln322">    if (newfile) {</a>
<a name="ln323">      if (apply_autocmds_exarg(EVENT_BUFREADCMD, NULL, sfname,</a>
<a name="ln324">                               false, curbuf, eap)) {</a>
<a name="ln325">        int status = OK;</a>
<a name="ln326"> </a>
<a name="ln327">        if (aborting()) {</a>
<a name="ln328">          status = FAIL;</a>
<a name="ln329">        }</a>
<a name="ln330"> </a>
<a name="ln331">        // The BufReadCmd code usually uses &quot;:read&quot; to get the text and</a>
<a name="ln332">        // perhaps &quot;:file&quot; to change the buffer name. But we should</a>
<a name="ln333">        // consider this to work like &quot;:edit&quot;, thus reset the</a>
<a name="ln334">        // BF_NOTEDITED flag.  Then &quot;:write&quot; will work to overwrite the</a>
<a name="ln335">        // same file.</a>
<a name="ln336">        if (status == OK) {</a>
<a name="ln337">          curbuf-&gt;b_flags &amp;= ~BF_NOTEDITED;</a>
<a name="ln338">        }</a>
<a name="ln339">        return status;</a>
<a name="ln340">      }</a>
<a name="ln341">    } else if (apply_autocmds_exarg(EVENT_FILEREADCMD, sfname, sfname,</a>
<a name="ln342">                                    false, NULL, eap)) {</a>
<a name="ln343">      return aborting() ? FAIL : OK;</a>
<a name="ln344">    }</a>
<a name="ln345"> </a>
<a name="ln346">    curbuf-&gt;b_op_start = pos;</a>
<a name="ln347">  }</a>
<a name="ln348"> </a>
<a name="ln349">  if ((shortmess(SHM_OVER) || curbuf-&gt;b_help) &amp;&amp; p_verbose == 0)</a>
<a name="ln350">    msg_scroll = FALSE;         /* overwrite previous file message */</a>
<a name="ln351">  else</a>
<a name="ln352">    msg_scroll = TRUE;          /* don't overwrite previous file message */</a>
<a name="ln353"> </a>
<a name="ln354">  // If the name is too long we might crash further on, quit here.</a>
<a name="ln355">  if (fname != NULL &amp;&amp; *fname != NUL) {</a>
<a name="ln356">    size_t namelen = STRLEN(fname);</a>
<a name="ln357"> </a>
<a name="ln358">    // If the name is too long we might crash further on, quit here.</a>
<a name="ln359">    if (namelen &gt;= MAXPATHL) {</a>
<a name="ln360">      filemess(curbuf, fname, (char_u *)_(&quot;Illegal file name&quot;), 0);</a>
<a name="ln361">      msg_end();</a>
<a name="ln362">      msg_scroll = msg_save;</a>
<a name="ln363">      return FAIL;</a>
<a name="ln364">    }</a>
<a name="ln365"> </a>
<a name="ln366">    // If the name ends in a path separator, we can't open it.  Check here,</a>
<a name="ln367">    // because reading the file may actually work, but then creating the</a>
<a name="ln368">    // swap file may destroy it!  Reported on MS-DOS and Win 95.</a>
<a name="ln369">    if (after_pathsep((const char *)fname, (const char *)(fname + namelen))) {</a>
<a name="ln370">      filemess(curbuf, fname, (char_u *)_(msg_is_a_directory), 0);</a>
<a name="ln371">      msg_end();</a>
<a name="ln372">      msg_scroll = msg_save;</a>
<a name="ln373">      return FAIL;</a>
<a name="ln374">    }</a>
<a name="ln375">  }</a>
<a name="ln376"> </a>
<a name="ln377">  if (!read_buffer &amp;&amp; !read_stdin &amp;&amp; !read_fifo) {</a>
<a name="ln378">    perm = os_getperm((const char *)fname);</a>
<a name="ln379">    // On Unix it is possible to read a directory, so we have to</a>
<a name="ln380">    // check for it before os_open().</a>
<a name="ln381">    if (perm &gt;= 0 &amp;&amp; !S_ISREG(perm)                 // not a regular file ...</a>
<a name="ln382">        &amp;&amp; !S_ISFIFO(perm)                          // ... or fifo</a>
<a name="ln383">        &amp;&amp; !S_ISSOCK(perm)                          // ... or socket</a>
<a name="ln384"># ifdef OPEN_CHR_FILES</a>
<a name="ln385">        &amp;&amp; !(S_ISCHR(perm) &amp;&amp; is_dev_fd_file(fname))</a>
<a name="ln386">        // ... or a character special file named /dev/fd/&lt;n&gt;</a>
<a name="ln387"># endif</a>
<a name="ln388">        ) {</a>
<a name="ln389">      if (S_ISDIR(perm)) {</a>
<a name="ln390">        filemess(curbuf, fname, (char_u *)_(msg_is_a_directory), 0);</a>
<a name="ln391">      } else {</a>
<a name="ln392">        filemess(curbuf, fname, (char_u *)_(&quot;is not a file&quot;), 0);</a>
<a name="ln393">      }</a>
<a name="ln394">      msg_end();</a>
<a name="ln395">      msg_scroll = msg_save;</a>
<a name="ln396">      return S_ISDIR(perm) ? NOTDONE : FAIL;</a>
<a name="ln397">    }</a>
<a name="ln398">  }</a>
<a name="ln399"> </a>
<a name="ln400">  /* Set default or forced 'fileformat' and 'binary'. */</a>
<a name="ln401">  set_file_options(set_options, eap);</a>
<a name="ln402"> </a>
<a name="ln403">  /*</a>
<a name="ln404">   * When opening a new file we take the readonly flag from the file.</a>
<a name="ln405">   * Default is r/w, can be set to r/o below.</a>
<a name="ln406">   * Don't reset it when in readonly mode</a>
<a name="ln407">   * Only set/reset b_p_ro when BF_CHECK_RO is set.</a>
<a name="ln408">   */</a>
<a name="ln409">  check_readonly = (newfile &amp;&amp; (curbuf-&gt;b_flags &amp; BF_CHECK_RO));</a>
<a name="ln410">  if (check_readonly &amp;&amp; !readonlymode)</a>
<a name="ln411">    curbuf-&gt;b_p_ro = FALSE;</a>
<a name="ln412"> </a>
<a name="ln413">  if (newfile &amp;&amp; !read_stdin &amp;&amp; !read_buffer &amp;&amp; !read_fifo) {</a>
<a name="ln414">    // Remember time of file.</a>
<a name="ln415">    if (os_fileinfo((char *)fname, &amp;file_info)) {</a>
<a name="ln416">      buf_store_file_info(curbuf, &amp;file_info);</a>
<a name="ln417">      curbuf-&gt;b_mtime_read = curbuf-&gt;b_mtime;</a>
<a name="ln418">#ifdef UNIX</a>
<a name="ln419">      /*</a>
<a name="ln420">       * Use the protection bits of the original file for the swap file.</a>
<a name="ln421">       * This makes it possible for others to read the name of the</a>
<a name="ln422">       * edited file from the swapfile, but only if they can read the</a>
<a name="ln423">       * edited file.</a>
<a name="ln424">       * Remove the &quot;write&quot; and &quot;execute&quot; bits for group and others</a>
<a name="ln425">       * (they must not write the swapfile).</a>
<a name="ln426">       * Add the &quot;read&quot; and &quot;write&quot; bits for the user, otherwise we may</a>
<a name="ln427">       * not be able to write to the file ourselves.</a>
<a name="ln428">       * Setting the bits is done below, after creating the swap file.</a>
<a name="ln429">       */</a>
<a name="ln430">      swap_mode = (file_info.stat.st_mode &amp; 0644) | 0600;</a>
<a name="ln431">#endif</a>
<a name="ln432">    } else {</a>
<a name="ln433">      curbuf-&gt;b_mtime = 0;</a>
<a name="ln434">      curbuf-&gt;b_mtime_read = 0;</a>
<a name="ln435">      curbuf-&gt;b_orig_size = 0;</a>
<a name="ln436">      curbuf-&gt;b_orig_mode = 0;</a>
<a name="ln437">    }</a>
<a name="ln438"> </a>
<a name="ln439">    /* Reset the &quot;new file&quot; flag.  It will be set again below when the</a>
<a name="ln440">     * file doesn't exist. */</a>
<a name="ln441">    curbuf-&gt;b_flags &amp;= ~(BF_NEW | BF_NEW_W);</a>
<a name="ln442">  }</a>
<a name="ln443"> </a>
<a name="ln444">  // Check readonly.</a>
<a name="ln445">  file_readonly = false;</a>
<a name="ln446">  if (!read_buffer &amp;&amp; !read_stdin) {</a>
<a name="ln447">    if (!newfile || readonlymode || !(perm &amp; 0222)</a>
<a name="ln448">        || !os_file_is_writable((char *)fname)) {</a>
<a name="ln449">      file_readonly = true;</a>
<a name="ln450">    }</a>
<a name="ln451">    fd = os_open((char *)fname, O_RDONLY, 0);</a>
<a name="ln452">  }</a>
<a name="ln453"> </a>
<a name="ln454">  if (fd &lt; 0) {                     // cannot open at all</a>
<a name="ln455">    msg_scroll = msg_save;</a>
<a name="ln456">    if (!newfile) {</a>
<a name="ln457">      return FAIL;</a>
<a name="ln458">    }</a>
<a name="ln459">    if (perm == UV_ENOENT) {  // check if the file exists</a>
<a name="ln460">      // Set the 'new-file' flag, so that when the file has</a>
<a name="ln461">      // been created by someone else, a &quot;:w&quot; will complain.</a>
<a name="ln462">      curbuf-&gt;b_flags |= BF_NEW;</a>
<a name="ln463"> </a>
<a name="ln464">      /* Create a swap file now, so that other Vims are warned</a>
<a name="ln465">       * that we are editing this file.  Don't do this for a</a>
<a name="ln466">       * &quot;nofile&quot; or &quot;nowrite&quot; buffer type. */</a>
<a name="ln467">      if (!bt_dontwrite(curbuf)) {</a>
<a name="ln468">        check_need_swap(newfile);</a>
<a name="ln469">        /* SwapExists autocommand may mess things up */</a>
<a name="ln470">        if (curbuf != old_curbuf</a>
<a name="ln471">            || (using_b_ffname</a>
<a name="ln472">                &amp;&amp; (old_b_ffname != curbuf-&gt;b_ffname))</a>
<a name="ln473">            || (using_b_fname</a>
<a name="ln474">                &amp;&amp; (old_b_fname != curbuf-&gt;b_fname))) {</a>
<a name="ln475">          EMSG(_(e_auchangedbuf));</a>
<a name="ln476">          return FAIL;</a>
<a name="ln477">        }</a>
<a name="ln478">      }</a>
<a name="ln479">      if (dir_of_file_exists(fname)) {</a>
<a name="ln480">        filemess(curbuf, sfname, (char_u *)new_file_message(), 0);</a>
<a name="ln481">      } else {</a>
<a name="ln482">        filemess(curbuf, sfname, (char_u *)_(&quot;[New DIRECTORY]&quot;), 0);</a>
<a name="ln483">      }</a>
<a name="ln484">      // Even though this is a new file, it might have been</a>
<a name="ln485">      // edited before and deleted.  Get the old marks.</a>
<a name="ln486">      check_marks_read();</a>
<a name="ln487">      // Set forced 'fileencoding'.</a>
<a name="ln488">      if (eap != NULL) {</a>
<a name="ln489">        set_forced_fenc(eap);</a>
<a name="ln490">      }</a>
<a name="ln491">      apply_autocmds_exarg(EVENT_BUFNEWFILE, sfname, sfname,</a>
<a name="ln492">                           false, curbuf, eap);</a>
<a name="ln493">      // remember the current fileformat</a>
<a name="ln494">      save_file_ff(curbuf);</a>
<a name="ln495"> </a>
<a name="ln496">      if (aborting())               /* autocmds may abort script processing */</a>
<a name="ln497">        return FAIL;</a>
<a name="ln498">      return OK;                  /* a new file is not an error */</a>
<a name="ln499">    } else {</a>
<a name="ln500">      filemess(curbuf, sfname, (char_u *)(</a>
<a name="ln501">            (fd == UV_EFBIG) ? _(&quot;[File too big]&quot;) :</a>
<a name="ln502"># if defined(UNIX) &amp;&amp; defined(EOVERFLOW)</a>
<a name="ln503">            // libuv only returns -errno in Unix and in Windows open() does not</a>
<a name="ln504">            // set EOVERFLOW</a>
<a name="ln505">            (fd == -EOVERFLOW) ? _(&quot;[File too big]&quot;) :</a>
<a name="ln506"># endif</a>
<a name="ln507">            _(&quot;[Permission Denied]&quot;)), 0);</a>
<a name="ln508">      curbuf-&gt;b_p_ro = TRUE;                  /* must use &quot;w!&quot; now */</a>
<a name="ln509">    }</a>
<a name="ln510"> </a>
<a name="ln511">    return FAIL;</a>
<a name="ln512">  }</a>
<a name="ln513"> </a>
<a name="ln514">  /*</a>
<a name="ln515">   * Only set the 'ro' flag for readonly files the first time they are</a>
<a name="ln516">   * loaded.	Help files always get readonly mode</a>
<a name="ln517">   */</a>
<a name="ln518">  if ((check_readonly &amp;&amp; file_readonly) || curbuf-&gt;b_help)</a>
<a name="ln519">    curbuf-&gt;b_p_ro = TRUE;</a>
<a name="ln520"> </a>
<a name="ln521">  if (set_options) {</a>
<a name="ln522">    /* Don't change 'eol' if reading from buffer as it will already be</a>
<a name="ln523">     * correctly set when reading stdin. */</a>
<a name="ln524">    if (!read_buffer) {</a>
<a name="ln525">      curbuf-&gt;b_p_eol = TRUE;</a>
<a name="ln526">      curbuf-&gt;b_start_eol = TRUE;</a>
<a name="ln527">    }</a>
<a name="ln528">    curbuf-&gt;b_p_bomb = FALSE;</a>
<a name="ln529">    curbuf-&gt;b_start_bomb = FALSE;</a>
<a name="ln530">  }</a>
<a name="ln531"> </a>
<a name="ln532">  /* Create a swap file now, so that other Vims are warned that we are</a>
<a name="ln533">   * editing this file.</a>
<a name="ln534">   * Don't do this for a &quot;nofile&quot; or &quot;nowrite&quot; buffer type. */</a>
<a name="ln535">  if (!bt_dontwrite(curbuf)) {</a>
<a name="ln536">    check_need_swap(newfile);</a>
<a name="ln537">    if (!read_stdin</a>
<a name="ln538">        &amp;&amp; (curbuf != old_curbuf</a>
<a name="ln539">            || (using_b_ffname &amp;&amp; (old_b_ffname != curbuf-&gt;b_ffname))</a>
<a name="ln540">            || (using_b_fname &amp;&amp; (old_b_fname != curbuf-&gt;b_fname)))) {</a>
<a name="ln541">      EMSG(_(e_auchangedbuf));</a>
<a name="ln542">      if (!read_buffer) {</a>
<a name="ln543">        close(fd);</a>
<a name="ln544">      }</a>
<a name="ln545">      return FAIL;</a>
<a name="ln546">    }</a>
<a name="ln547">#ifdef UNIX</a>
<a name="ln548">    // Set swap file protection bits after creating it.</a>
<a name="ln549">    if (swap_mode &gt; 0 &amp;&amp; curbuf-&gt;b_ml.ml_mfp != NULL</a>
<a name="ln550">        &amp;&amp; curbuf-&gt;b_ml.ml_mfp-&gt;mf_fname != NULL) {</a>
<a name="ln551">      const char *swap_fname = (const char *)curbuf-&gt;b_ml.ml_mfp-&gt;mf_fname;</a>
<a name="ln552"> </a>
<a name="ln553">      // If the group-read bit is set but not the world-read bit, then</a>
<a name="ln554">      // the group must be equal to the group of the original file.  If</a>
<a name="ln555">      // we can't make that happen then reset the group-read bit.  This</a>
<a name="ln556">      // avoids making the swap file readable to more users when the</a>
<a name="ln557">      // primary group of the user is too permissive.</a>
<a name="ln558">      if ((swap_mode &amp; 044) == 040) {</a>
<a name="ln559">        FileInfo swap_info;</a>
<a name="ln560"> </a>
<a name="ln561">        if (os_fileinfo(swap_fname, &amp;swap_info)</a>
<a name="ln562">            &amp;&amp; file_info.stat.st_gid != swap_info.stat.st_gid</a>
<a name="ln563">            &amp;&amp; os_fchown(curbuf-&gt;b_ml.ml_mfp-&gt;mf_fd, -1, file_info.stat.st_gid)</a>
<a name="ln564">            == -1) {</a>
<a name="ln565">          swap_mode &amp;= 0600;</a>
<a name="ln566">        }</a>
<a name="ln567">      }</a>
<a name="ln568"> </a>
<a name="ln569">      (void)os_setperm(swap_fname, swap_mode);</a>
<a name="ln570">    }</a>
<a name="ln571">#endif</a>
<a name="ln572">  }</a>
<a name="ln573"> </a>
<a name="ln574">  // If &quot;Quit&quot; selected at ATTENTION dialog, don't load the file.</a>
<a name="ln575">  if (swap_exists_action == SEA_QUIT) {</a>
<a name="ln576">    if (!read_buffer &amp;&amp; !read_stdin)</a>
<a name="ln577">      close(fd);</a>
<a name="ln578">    return FAIL;</a>
<a name="ln579">  }</a>
<a name="ln580"> </a>
<a name="ln581">  ++no_wait_return;         /* don't wait for return yet */</a>
<a name="ln582"> </a>
<a name="ln583">  /*</a>
<a name="ln584">   * Set '[ mark to the line above where the lines go (line 1 if zero).</a>
<a name="ln585">   */</a>
<a name="ln586">  curbuf-&gt;b_op_start.lnum = ((from == 0) ? 1 : from);</a>
<a name="ln587">  curbuf-&gt;b_op_start.col = 0;</a>
<a name="ln588"> </a>
<a name="ln589">  int try_mac = (vim_strchr(p_ffs, 'm') != NULL);</a>
<a name="ln590">  int try_dos = (vim_strchr(p_ffs, 'd') != NULL);</a>
<a name="ln591">  int try_unix = (vim_strchr(p_ffs, 'x') != NULL);</a>
<a name="ln592"> </a>
<a name="ln593">  if (!read_buffer) {</a>
<a name="ln594">    int m = msg_scroll;</a>
<a name="ln595">    int n = msg_scrolled;</a>
<a name="ln596"> </a>
<a name="ln597">    // The file must be closed again, the autocommands may want to change</a>
<a name="ln598">    // the file before reading it.</a>
<a name="ln599">    if (!read_stdin) {</a>
<a name="ln600">      close(fd);                // ignore errors</a>
<a name="ln601">    }</a>
<a name="ln602"> </a>
<a name="ln603">    // The output from the autocommands should not overwrite anything and</a>
<a name="ln604">    // should not be overwritten: Set msg_scroll, restore its value if no</a>
<a name="ln605">    // output was done.</a>
<a name="ln606">    msg_scroll = true;</a>
<a name="ln607">    if (filtering) {</a>
<a name="ln608">      apply_autocmds_exarg(EVENT_FILTERREADPRE, NULL, sfname,</a>
<a name="ln609">                           false, curbuf, eap);</a>
<a name="ln610">    } else if (read_stdin) {</a>
<a name="ln611">      apply_autocmds_exarg(EVENT_STDINREADPRE, NULL, sfname,</a>
<a name="ln612">                           false, curbuf, eap);</a>
<a name="ln613">    } else if (newfile) {</a>
<a name="ln614">      apply_autocmds_exarg(EVENT_BUFREADPRE, NULL, sfname,</a>
<a name="ln615">                           false, curbuf, eap);</a>
<a name="ln616">    } else {</a>
<a name="ln617">      apply_autocmds_exarg(EVENT_FILEREADPRE, sfname, sfname,</a>
<a name="ln618">                           false, NULL, eap);</a>
<a name="ln619">    }</a>
<a name="ln620"> </a>
<a name="ln621">    // autocommands may have changed it</a>
<a name="ln622">    try_mac = (vim_strchr(p_ffs, 'm') != NULL);</a>
<a name="ln623">    try_dos = (vim_strchr(p_ffs, 'd') != NULL);</a>
<a name="ln624">    try_unix = (vim_strchr(p_ffs, 'x') != NULL);</a>
<a name="ln625"> </a>
<a name="ln626">    if (msg_scrolled == n) {</a>
<a name="ln627">      msg_scroll = m;</a>
<a name="ln628">    }</a>
<a name="ln629"> </a>
<a name="ln630">    if (aborting()) {       /* autocmds may abort script processing */</a>
<a name="ln631">      --no_wait_return;</a>
<a name="ln632">      msg_scroll = msg_save;</a>
<a name="ln633">      curbuf-&gt;b_p_ro = TRUE;            /* must use &quot;w!&quot; now */</a>
<a name="ln634">      return FAIL;</a>
<a name="ln635">    }</a>
<a name="ln636">    /*</a>
<a name="ln637">     * Don't allow the autocommands to change the current buffer.</a>
<a name="ln638">     * Try to re-open the file.</a>
<a name="ln639">     *</a>
<a name="ln640">     * Don't allow the autocommands to change the buffer name either</a>
<a name="ln641">     * (cd for example) if it invalidates fname or sfname.</a>
<a name="ln642">     */</a>
<a name="ln643">    if (!read_stdin &amp;&amp; (curbuf != old_curbuf</a>
<a name="ln644">                        || (using_b_ffname &amp;&amp; (old_b_ffname != curbuf-&gt;b_ffname))</a>
<a name="ln645">                        || (using_b_fname &amp;&amp; (old_b_fname != curbuf-&gt;b_fname))</a>
<a name="ln646">                        || (fd = os_open((char *)fname, O_RDONLY, 0)) &lt; 0)) {</a>
<a name="ln647">      --no_wait_return;</a>
<a name="ln648">      msg_scroll = msg_save;</a>
<a name="ln649">      if (fd &lt; 0)</a>
<a name="ln650">        EMSG(_(&quot;E200: *ReadPre autocommands made the file unreadable&quot;));</a>
<a name="ln651">      else</a>
<a name="ln652">        EMSG(_(&quot;E201: *ReadPre autocommands must not change current buffer&quot;));</a>
<a name="ln653">      curbuf-&gt;b_p_ro = TRUE;            /* must use &quot;w!&quot; now */</a>
<a name="ln654">      return FAIL;</a>
<a name="ln655">    }</a>
<a name="ln656">  }</a>
<a name="ln657"> </a>
<a name="ln658">  /* Autocommands may add lines to the file, need to check if it is empty */</a>
<a name="ln659">  wasempty = (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY);</a>
<a name="ln660"> </a>
<a name="ln661">  if (!recoverymode &amp;&amp; !filtering &amp;&amp; !(flags &amp; READ_DUMMY)) {</a>
<a name="ln662">    if (!read_stdin &amp;&amp; !read_buffer) {</a>
<a name="ln663">      filemess(curbuf, sfname, (char_u *)&quot;&quot;, 0);</a>
<a name="ln664">    }</a>
<a name="ln665">  }</a>
<a name="ln666"> </a>
<a name="ln667">  msg_scroll = FALSE;                   /* overwrite the file message */</a>
<a name="ln668"> </a>
<a name="ln669">  /*</a>
<a name="ln670">   * Set linecnt now, before the &quot;retry&quot; caused by a wrong guess for</a>
<a name="ln671">   * fileformat, and after the autocommands, which may change them.</a>
<a name="ln672">   */</a>
<a name="ln673">  linecnt = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln674"> </a>
<a name="ln675">  /* &quot;++bad=&quot; argument. */</a>
<a name="ln676">  if (eap != NULL &amp;&amp; eap-&gt;bad_char != 0) {</a>
<a name="ln677">    bad_char_behavior = eap-&gt;bad_char;</a>
<a name="ln678">    if (set_options)</a>
<a name="ln679">      curbuf-&gt;b_bad_char = eap-&gt;bad_char;</a>
<a name="ln680">  } else</a>
<a name="ln681">    curbuf-&gt;b_bad_char = 0;</a>
<a name="ln682"> </a>
<a name="ln683">  /*</a>
<a name="ln684">   * Decide which 'encoding' to use or use first.</a>
<a name="ln685">   */</a>
<a name="ln686">  if (eap != NULL &amp;&amp; eap-&gt;force_enc != 0) {</a>
<a name="ln687">    fenc = enc_canonize(eap-&gt;cmd + eap-&gt;force_enc);</a>
<a name="ln688">    fenc_alloced = true;</a>
<a name="ln689">    keep_dest_enc = true;</a>
<a name="ln690">  } else if (curbuf-&gt;b_p_bin) {</a>
<a name="ln691">    fenc = (char_u *)&quot;&quot;;                // binary: don't convert</a>
<a name="ln692">    fenc_alloced = false;</a>
<a name="ln693">  } else if (curbuf-&gt;b_help) {</a>
<a name="ln694">    // Help files are either utf-8 or latin1.  Try utf-8 first, if this</a>
<a name="ln695">    // fails it must be latin1.</a>
<a name="ln696">    // It is needed when the first line contains non-ASCII characters.</a>
<a name="ln697">    // That is only in *.??x files.</a>
<a name="ln698">    fenc_next = (char_u *)&quot;latin1&quot;;</a>
<a name="ln699">    fenc = (char_u *)&quot;utf-8&quot;;</a>
<a name="ln700"> </a>
<a name="ln701">    fenc_alloced = false;</a>
<a name="ln702">  } else if (*p_fencs == NUL) {</a>
<a name="ln703">    fenc = curbuf-&gt;b_p_fenc;            // use format from buffer</a>
<a name="ln704">    fenc_alloced = false;</a>
<a name="ln705">  } else {</a>
<a name="ln706">    fenc_next = p_fencs;                // try items in 'fileencodings'</a>
<a name="ln707">    fenc = next_fenc(&amp;fenc_next, &amp;fenc_alloced);</a>
<a name="ln708">  }</a>
<a name="ln709"> </a>
<a name="ln710">  /*</a>
<a name="ln711">   * Jump back here to retry reading the file in different ways.</a>
<a name="ln712">   * Reasons to retry:</a>
<a name="ln713">   * - encoding conversion failed: try another one from &quot;fenc_next&quot;</a>
<a name="ln714">   * - BOM detected and fenc was set, need to setup conversion</a>
<a name="ln715">   * - &quot;fileformat&quot; check failed: try another</a>
<a name="ln716">   *</a>
<a name="ln717">   * Variables set for special retry actions:</a>
<a name="ln718">   * &quot;file_rewind&quot;	Rewind the file to start reading it again.</a>
<a name="ln719">   * &quot;advance_fenc&quot;	Advance &quot;fenc&quot; using &quot;fenc_next&quot;.</a>
<a name="ln720">   * &quot;skip_read&quot;	Re-use already read bytes (BOM detected).</a>
<a name="ln721">   * &quot;did_iconv&quot;	iconv() conversion failed, try 'charconvert'.</a>
<a name="ln722">   * &quot;keep_fileformat&quot; Don't reset &quot;fileformat&quot;.</a>
<a name="ln723">   *</a>
<a name="ln724">   * Other status indicators:</a>
<a name="ln725">   * &quot;tmpname&quot;	When != NULL did conversion with 'charconvert'.</a>
<a name="ln726">   *			Output file has to be deleted afterwards.</a>
<a name="ln727">   * &quot;iconv_fd&quot;	When != -1 did conversion with iconv().</a>
<a name="ln728">   */</a>
<a name="ln729">retry:</a>
<a name="ln730"> </a>
<a name="ln731">  if (file_rewind) {</a>
<a name="ln732">    if (read_buffer) {</a>
<a name="ln733">      read_buf_lnum = 1;</a>
<a name="ln734">      read_buf_col = 0;</a>
<a name="ln735">    } else if (read_stdin || vim_lseek(fd, (off_T)0L, SEEK_SET) != 0) {</a>
<a name="ln736">      // Can't rewind the file, give up.</a>
<a name="ln737">      error = true;</a>
<a name="ln738">      goto failed;</a>
<a name="ln739">    }</a>
<a name="ln740">    // Delete the previously read lines.</a>
<a name="ln741">    while (lnum &gt; from) {</a>
<a name="ln742">      ml_delete(lnum--, false);</a>
<a name="ln743">    }</a>
<a name="ln744">    file_rewind = false;</a>
<a name="ln745">    if (set_options) {</a>
<a name="ln746">      curbuf-&gt;b_p_bomb = FALSE;</a>
<a name="ln747">      curbuf-&gt;b_start_bomb = FALSE;</a>
<a name="ln748">    }</a>
<a name="ln749">    conv_error = 0;</a>
<a name="ln750">  }</a>
<a name="ln751"> </a>
<a name="ln752">  /*</a>
<a name="ln753">   * When retrying with another &quot;fenc&quot; and the first time &quot;fileformat&quot;</a>
<a name="ln754">   * will be reset.</a>
<a name="ln755">   */</a>
<a name="ln756">  if (keep_fileformat) {</a>
<a name="ln757">    keep_fileformat = false;</a>
<a name="ln758">  } else {</a>
<a name="ln759">    if (eap != NULL &amp;&amp; eap-&gt;force_ff != 0) {</a>
<a name="ln760">      fileformat = get_fileformat_force(curbuf, eap);</a>
<a name="ln761">      try_unix = try_dos = try_mac = FALSE;</a>
<a name="ln762">    } else if (curbuf-&gt;b_p_bin)</a>
<a name="ln763">      fileformat = EOL_UNIX;                    /* binary: use Unix format */</a>
<a name="ln764">    else if (*p_ffs == NUL)</a>
<a name="ln765">      fileformat = get_fileformat(curbuf);      /* use format from buffer */</a>
<a name="ln766">    else</a>
<a name="ln767">      fileformat = EOL_UNKNOWN;                 /* detect from file */</a>
<a name="ln768">  }</a>
<a name="ln769"> </a>
<a name="ln770"># ifdef HAVE_ICONV</a>
<a name="ln771">  if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln772">    /* aborted conversion with iconv(), close the descriptor */</a>
<a name="ln773">    iconv_close(iconv_fd);</a>
<a name="ln774">    iconv_fd = (iconv_t)-1;</a>
<a name="ln775">  }</a>
<a name="ln776"># endif</a>
<a name="ln777"> </a>
<a name="ln778">  if (advance_fenc) {</a>
<a name="ln779">    /*</a>
<a name="ln780">     * Try the next entry in 'fileencodings'.</a>
<a name="ln781">     */</a>
<a name="ln782">    advance_fenc = false;</a>
<a name="ln783"> </a>
<a name="ln784">    if (eap != NULL &amp;&amp; eap-&gt;force_enc != 0) {</a>
<a name="ln785">      /* Conversion given with &quot;++cc=&quot; wasn't possible, read</a>
<a name="ln786">       * without conversion. */</a>
<a name="ln787">      notconverted = TRUE;</a>
<a name="ln788">      conv_error = 0;</a>
<a name="ln789">      if (fenc_alloced)</a>
<a name="ln790">        xfree(fenc);</a>
<a name="ln791">      fenc = (char_u *)&quot;&quot;;</a>
<a name="ln792">      fenc_alloced = false;</a>
<a name="ln793">    } else {</a>
<a name="ln794">      if (fenc_alloced)</a>
<a name="ln795">        xfree(fenc);</a>
<a name="ln796">      if (fenc_next != NULL) {</a>
<a name="ln797">        fenc = next_fenc(&amp;fenc_next, &amp;fenc_alloced);</a>
<a name="ln798">      } else {</a>
<a name="ln799">        fenc = (char_u *)&quot;&quot;;</a>
<a name="ln800">        fenc_alloced = false;</a>
<a name="ln801">      }</a>
<a name="ln802">    }</a>
<a name="ln803">    if (tmpname != NULL) {</a>
<a name="ln804">      os_remove((char *)tmpname);  // delete converted file</a>
<a name="ln805">      XFREE_CLEAR(tmpname);</a>
<a name="ln806">    }</a>
<a name="ln807">  }</a>
<a name="ln808"> </a>
<a name="ln809">  /*</a>
<a name="ln810">   * Conversion may be required when the encoding of the file is different</a>
<a name="ln811">   * from 'encoding' or 'encoding' is UTF-16, UCS-2 or UCS-4.</a>
<a name="ln812">   */</a>
<a name="ln813">  fio_flags = 0;</a>
<a name="ln814">  converted = need_conversion(fenc);</a>
<a name="ln815">  if (converted) {</a>
<a name="ln816"> </a>
<a name="ln817">    /* &quot;ucs-bom&quot; means we need to check the first bytes of the file</a>
<a name="ln818">     * for a BOM. */</a>
<a name="ln819">    if (STRCMP(fenc, ENC_UCSBOM) == 0) {</a>
<a name="ln820">      fio_flags = FIO_UCSBOM;</a>
<a name="ln821">    } else {</a>
<a name="ln822">      // Check if UCS-2/4 or Latin1 to UTF-8 conversion needs to be</a>
<a name="ln823">      // done.  This is handled below after read().  Prepare the</a>
<a name="ln824">      // fio_flags to avoid having to parse the string each time.</a>
<a name="ln825">      // Also check for Unicode to Latin1 conversion, because iconv()</a>
<a name="ln826">      // appears not to handle this correctly.  This works just like</a>
<a name="ln827">      // conversion to UTF-8 except how the resulting character is put in</a>
<a name="ln828">      // the buffer.</a>
<a name="ln829">      fio_flags = get_fio_flags(fenc);</a>
<a name="ln830">    }</a>
<a name="ln831"> </a>
<a name="ln832"> </a>
<a name="ln833"> </a>
<a name="ln834"># ifdef HAVE_ICONV</a>
<a name="ln835">    // Try using iconv() if we can't convert internally.</a>
<a name="ln836">    if (fio_flags == 0</a>
<a name="ln837">        &amp;&amp; !did_iconv</a>
<a name="ln838">        ) {</a>
<a name="ln839">      iconv_fd = (iconv_t)my_iconv_open((char_u *)&quot;utf-8&quot;, fenc);</a>
<a name="ln840">    }</a>
<a name="ln841"># endif</a>
<a name="ln842"> </a>
<a name="ln843">    /*</a>
<a name="ln844">     * Use the 'charconvert' expression when conversion is required</a>
<a name="ln845">     * and we can't do it internally or with iconv().</a>
<a name="ln846">     */</a>
<a name="ln847">    if (fio_flags == 0 &amp;&amp; !read_stdin &amp;&amp; !read_buffer &amp;&amp; *p_ccv != NUL</a>
<a name="ln848">        &amp;&amp; !read_fifo</a>
<a name="ln849">#  ifdef HAVE_ICONV</a>
<a name="ln850">        &amp;&amp; iconv_fd == (iconv_t)-1</a>
<a name="ln851">#  endif</a>
<a name="ln852">        ) {</a>
<a name="ln853">#  ifdef HAVE_ICONV</a>
<a name="ln854">      did_iconv = false;</a>
<a name="ln855">#  endif</a>
<a name="ln856">      /* Skip conversion when it's already done (retry for wrong</a>
<a name="ln857">       * &quot;fileformat&quot;). */</a>
<a name="ln858">      if (tmpname == NULL) {</a>
<a name="ln859">        tmpname = readfile_charconvert(fname, fenc, &amp;fd);</a>
<a name="ln860">        if (tmpname == NULL) {</a>
<a name="ln861">          // Conversion failed.  Try another one.</a>
<a name="ln862">          advance_fenc = true;</a>
<a name="ln863">          if (fd &lt; 0) {</a>
<a name="ln864">            /* Re-opening the original file failed! */</a>
<a name="ln865">            EMSG(_(&quot;E202: Conversion made file unreadable!&quot;));</a>
<a name="ln866">            error = TRUE;</a>
<a name="ln867">            goto failed;</a>
<a name="ln868">          }</a>
<a name="ln869">          goto retry;</a>
<a name="ln870">        }</a>
<a name="ln871">      }</a>
<a name="ln872">    } else {</a>
<a name="ln873">      if (fio_flags == 0</a>
<a name="ln874"># ifdef HAVE_ICONV</a>
<a name="ln875">          &amp;&amp; iconv_fd == (iconv_t)-1</a>
<a name="ln876"># endif</a>
<a name="ln877">          ) {</a>
<a name="ln878">        /* Conversion wanted but we can't.</a>
<a name="ln879">         * Try the next conversion in 'fileencodings' */</a>
<a name="ln880">        advance_fenc = true;</a>
<a name="ln881">        goto retry;</a>
<a name="ln882">      }</a>
<a name="ln883">    }</a>
<a name="ln884">  }</a>
<a name="ln885"> </a>
<a name="ln886">  /* Set &quot;can_retry&quot; when it's possible to rewind the file and try with</a>
<a name="ln887">   * another &quot;fenc&quot; value.  It's FALSE when no other &quot;fenc&quot; to try, reading</a>
<a name="ln888">   * stdin or fixed at a specific encoding. */</a>
<a name="ln889">  can_retry = (*fenc != NUL &amp;&amp; !read_stdin &amp;&amp; !keep_dest_enc &amp;&amp; !read_fifo);</a>
<a name="ln890"> </a>
<a name="ln891">  if (!skip_read) {</a>
<a name="ln892">    linerest = 0;</a>
<a name="ln893">    filesize = 0;</a>
<a name="ln894">    skip_count = lines_to_skip;</a>
<a name="ln895">    read_count = lines_to_read;</a>
<a name="ln896">    conv_restlen = 0;</a>
<a name="ln897">    read_undo_file = (newfile &amp;&amp; (flags &amp; READ_KEEP_UNDO) == 0</a>
<a name="ln898">                      &amp;&amp; curbuf-&gt;b_ffname != NULL</a>
<a name="ln899">                      &amp;&amp; curbuf-&gt;b_p_udf</a>
<a name="ln900">                      &amp;&amp; !filtering</a>
<a name="ln901">                      &amp;&amp; !read_fifo</a>
<a name="ln902">                      &amp;&amp; !read_stdin</a>
<a name="ln903">                      &amp;&amp; !read_buffer);</a>
<a name="ln904">    if (read_undo_file)</a>
<a name="ln905">      sha256_start(&amp;sha_ctx);</a>
<a name="ln906">  }</a>
<a name="ln907"> </a>
<a name="ln908">  while (!error &amp;&amp; !got_int) {</a>
<a name="ln909">    /*</a>
<a name="ln910">     * We allocate as much space for the file as we can get, plus</a>
<a name="ln911">     * space for the old line plus room for one terminating NUL.</a>
<a name="ln912">     * The amount is limited by the fact that read() only can read</a>
<a name="ln913">     * up to max_unsigned characters (and other things).</a>
<a name="ln914">     */</a>
<a name="ln915">    {</a>
<a name="ln916">      if (!skip_read) {</a>
<a name="ln917">        // Use buffer &gt;= 64K.  Add linerest to double the size if the</a>
<a name="ln918">        // line gets very long, to avoid a lot of copying. But don't</a>
<a name="ln919">        // read more than 1 Mbyte at a time, so we can be interrupted.</a>
<a name="ln920">        size = 0x10000L + linerest;</a>
<a name="ln921">        if (size &gt; 0x100000L) {</a>
<a name="ln922">          size = 0x100000L;</a>
<a name="ln923">        }</a>
<a name="ln924">      }</a>
<a name="ln925"> </a>
<a name="ln926">      // Protect against the argument of lalloc() going negative.</a>
<a name="ln927">      if (size &lt; 0 || size + linerest + 1 &lt; 0 || linerest &gt;= MAXCOL) {</a>
<a name="ln928">        split++;</a>
<a name="ln929">        *ptr = NL;  // split line by inserting a NL</a>
<a name="ln930">        size = 1;</a>
<a name="ln931">      } else if (!skip_read) {</a>
<a name="ln932">        for (; size &gt;= 10; size /= 2) {</a>
<a name="ln933">          new_buffer = verbose_try_malloc((size_t)size + (size_t)linerest + 1);</a>
<a name="ln934">          if (new_buffer) {</a>
<a name="ln935">            break;</a>
<a name="ln936">          }</a>
<a name="ln937">        }</a>
<a name="ln938">        if (new_buffer == NULL) {</a>
<a name="ln939">          error = TRUE;</a>
<a name="ln940">          break;</a>
<a name="ln941">        }</a>
<a name="ln942">        if (linerest)           /* copy characters from the previous buffer */</a>
<a name="ln943">          memmove(new_buffer, ptr - linerest, (size_t)linerest);</a>
<a name="ln944">        xfree(buffer);</a>
<a name="ln945">        buffer = new_buffer;</a>
<a name="ln946">        ptr = buffer + linerest;</a>
<a name="ln947">        line_start = buffer;</a>
<a name="ln948"> </a>
<a name="ln949">        /* May need room to translate into.</a>
<a name="ln950">         * For iconv() we don't really know the required space, use a</a>
<a name="ln951">         * factor ICONV_MULT.</a>
<a name="ln952">         * latin1 to utf-8: 1 byte becomes up to 2 bytes</a>
<a name="ln953">         * utf-16 to utf-8: 2 bytes become up to 3 bytes, 4 bytes</a>
<a name="ln954">         * become up to 4 bytes, size must be multiple of 2</a>
<a name="ln955">         * ucs-2 to utf-8: 2 bytes become up to 3 bytes, size must be</a>
<a name="ln956">         * multiple of 2</a>
<a name="ln957">         * ucs-4 to utf-8: 4 bytes become up to 6 bytes, size must be</a>
<a name="ln958">         * multiple of 4 */</a>
<a name="ln959">        real_size = (int)size;</a>
<a name="ln960"># ifdef HAVE_ICONV</a>
<a name="ln961">        if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln962">          size = size / ICONV_MULT;</a>
<a name="ln963">        } else {</a>
<a name="ln964"># endif</a>
<a name="ln965">        if (fio_flags &amp; FIO_LATIN1) {</a>
<a name="ln966">          size = size / 2;</a>
<a name="ln967">        } else if (fio_flags &amp; (FIO_UCS2 | FIO_UTF16)) {</a>
<a name="ln968">          size = (size * 2 / 3) &amp; ~1;</a>
<a name="ln969">        } else if (fio_flags &amp; FIO_UCS4) {</a>
<a name="ln970">          size = (size * 2 / 3) &amp; ~3;</a>
<a name="ln971">        } else if (fio_flags == FIO_UCSBOM) {</a>
<a name="ln972">          size = size / ICONV_MULT;  // worst case</a>
<a name="ln973">        }</a>
<a name="ln974"># ifdef HAVE_ICONV</a>
<a name="ln975">        }</a>
<a name="ln976"># endif</a>
<a name="ln977">        if (conv_restlen &gt; 0) {</a>
<a name="ln978">          // Insert unconverted bytes from previous line.</a>
<a name="ln979">          memmove(ptr, conv_rest, conv_restlen);  // -V614</a>
<a name="ln980">          ptr += conv_restlen;</a>
<a name="ln981">          size -= conv_restlen;</a>
<a name="ln982">        }</a>
<a name="ln983"> </a>
<a name="ln984">        if (read_buffer) {</a>
<a name="ln985">          /*</a>
<a name="ln986">           * Read bytes from curbuf.  Used for converting text read</a>
<a name="ln987">           * from stdin.</a>
<a name="ln988">           */</a>
<a name="ln989">          if (read_buf_lnum &gt; from)</a>
<a name="ln990">            size = 0;</a>
<a name="ln991">          else {</a>
<a name="ln992">            int n, ni;</a>
<a name="ln993">            long tlen;</a>
<a name="ln994"> </a>
<a name="ln995">            tlen = 0;</a>
<a name="ln996">            for (;; ) {</a>
<a name="ln997">              p = ml_get(read_buf_lnum) + read_buf_col;</a>
<a name="ln998">              n = (int)STRLEN(p);</a>
<a name="ln999">              if ((int)tlen + n + 1 &gt; size) {</a>
<a name="ln1000">                /* Filled up to &quot;size&quot;, append partial line.</a>
<a name="ln1001">                 * Change NL to NUL to reverse the effect done</a>
<a name="ln1002">                 * below. */</a>
<a name="ln1003">                n = (int)(size - tlen);</a>
<a name="ln1004">                for (ni = 0; ni &lt; n; ++ni) {</a>
<a name="ln1005">                  if (p[ni] == NL)</a>
<a name="ln1006">                    ptr[tlen++] = NUL;</a>
<a name="ln1007">                  else</a>
<a name="ln1008">                    ptr[tlen++] = p[ni];</a>
<a name="ln1009">                }</a>
<a name="ln1010">                read_buf_col += n;</a>
<a name="ln1011">                break;</a>
<a name="ln1012">              } else {</a>
<a name="ln1013">                /* Append whole line and new-line.  Change NL</a>
<a name="ln1014">                * to NUL to reverse the effect done below. */</a>
<a name="ln1015">                for (ni = 0; ni &lt; n; ++ni) {</a>
<a name="ln1016">                  if (p[ni] == NL)</a>
<a name="ln1017">                    ptr[tlen++] = NUL;</a>
<a name="ln1018">                  else</a>
<a name="ln1019">                    ptr[tlen++] = p[ni];</a>
<a name="ln1020">                }</a>
<a name="ln1021">                ptr[tlen++] = NL;</a>
<a name="ln1022">                read_buf_col = 0;</a>
<a name="ln1023">                if (++read_buf_lnum &gt; from) {</a>
<a name="ln1024">                  /* When the last line didn't have an</a>
<a name="ln1025">                   * end-of-line don't add it now either. */</a>
<a name="ln1026">                  if (!curbuf-&gt;b_p_eol)</a>
<a name="ln1027">                    --tlen;</a>
<a name="ln1028">                  size = tlen;</a>
<a name="ln1029">                  break;</a>
<a name="ln1030">                }</a>
<a name="ln1031">              }</a>
<a name="ln1032">            }</a>
<a name="ln1033">          }</a>
<a name="ln1034">        } else {</a>
<a name="ln1035">          /*</a>
<a name="ln1036">           * Read bytes from the file.</a>
<a name="ln1037">           */</a>
<a name="ln1038">          size = read_eintr(fd, ptr, size);</a>
<a name="ln1039">        }</a>
<a name="ln1040"> </a>
<a name="ln1041">        if (size &lt;= 0) {</a>
<a name="ln1042">          if (size &lt; 0)                             /* read error */</a>
<a name="ln1043">            error = TRUE;</a>
<a name="ln1044">          else if (conv_restlen &gt; 0) {</a>
<a name="ln1045">            /*</a>
<a name="ln1046">             * Reached end-of-file but some trailing bytes could</a>
<a name="ln1047">             * not be converted.  Truncated file?</a>
<a name="ln1048">             */</a>
<a name="ln1049"> </a>
<a name="ln1050">            /* When we did a conversion report an error. */</a>
<a name="ln1051">            if (fio_flags != 0</a>
<a name="ln1052"># ifdef HAVE_ICONV</a>
<a name="ln1053">                || iconv_fd != (iconv_t)-1</a>
<a name="ln1054"># endif</a>
<a name="ln1055">                ) {</a>
<a name="ln1056">              if (can_retry)</a>
<a name="ln1057">                goto rewind_retry;</a>
<a name="ln1058">              if (conv_error == 0)</a>
<a name="ln1059">                conv_error = curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln1060">                             - linecnt + 1;</a>
<a name="ln1061">            }</a>
<a name="ln1062">            /* Remember the first linenr with an illegal byte */</a>
<a name="ln1063">            else if (illegal_byte == 0)</a>
<a name="ln1064">              illegal_byte = curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln1065">                             - linecnt + 1;</a>
<a name="ln1066">            if (bad_char_behavior == BAD_DROP) {</a>
<a name="ln1067">              *(ptr - conv_restlen) = NUL;</a>
<a name="ln1068">              conv_restlen = 0;</a>
<a name="ln1069">            } else {</a>
<a name="ln1070">              /* Replace the trailing bytes with the replacement</a>
<a name="ln1071">               * character if we were converting; if we weren't,</a>
<a name="ln1072">               * leave the UTF8 checking code to do it, as it</a>
<a name="ln1073">               * works slightly differently. */</a>
<a name="ln1074">              if (bad_char_behavior != BAD_KEEP &amp;&amp; (fio_flags != 0</a>
<a name="ln1075"># ifdef HAVE_ICONV</a>
<a name="ln1076">                                                    || iconv_fd != (iconv_t)-1</a>
<a name="ln1077"># endif</a>
<a name="ln1078">                                                    )) {</a>
<a name="ln1079">                while (conv_restlen &gt; 0) {</a>
<a name="ln1080">                  *(--ptr) = bad_char_behavior;</a>
<a name="ln1081">                  --conv_restlen;</a>
<a name="ln1082">                }</a>
<a name="ln1083">              }</a>
<a name="ln1084">              fio_flags = 0;  // don't convert this</a>
<a name="ln1085"># ifdef HAVE_ICONV</a>
<a name="ln1086">              if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln1087">                iconv_close(iconv_fd);</a>
<a name="ln1088">                iconv_fd = (iconv_t)-1;</a>
<a name="ln1089">              }</a>
<a name="ln1090"># endif</a>
<a name="ln1091">            }</a>
<a name="ln1092">          }</a>
<a name="ln1093">        }</a>
<a name="ln1094">      }</a>
<a name="ln1095"> </a>
<a name="ln1096">      skip_read = FALSE;</a>
<a name="ln1097"> </a>
<a name="ln1098">      /*</a>
<a name="ln1099">       * At start of file: Check for BOM.</a>
<a name="ln1100">       * Also check for a BOM for other Unicode encodings, but not after</a>
<a name="ln1101">       * converting with 'charconvert' or when a BOM has already been</a>
<a name="ln1102">       * found.</a>
<a name="ln1103">       */</a>
<a name="ln1104">      if ((filesize == 0)</a>
<a name="ln1105">          &amp;&amp; (fio_flags == FIO_UCSBOM</a>
<a name="ln1106">              || (!curbuf-&gt;b_p_bomb</a>
<a name="ln1107">                  &amp;&amp; tmpname == NULL</a>
<a name="ln1108">                  &amp;&amp; (*fenc == 'u' || *fenc == NUL)))) {</a>
<a name="ln1109">        char_u  *ccname;</a>
<a name="ln1110">        int blen;</a>
<a name="ln1111"> </a>
<a name="ln1112">        /* no BOM detection in a short file or in binary mode */</a>
<a name="ln1113">        if (size &lt; 2 || curbuf-&gt;b_p_bin)</a>
<a name="ln1114">          ccname = NULL;</a>
<a name="ln1115">        else</a>
<a name="ln1116">          ccname = check_for_bom(ptr, size, &amp;blen,</a>
<a name="ln1117">              fio_flags == FIO_UCSBOM ? FIO_ALL : get_fio_flags(fenc));</a>
<a name="ln1118">        if (ccname != NULL) {</a>
<a name="ln1119">          /* Remove BOM from the text */</a>
<a name="ln1120">          filesize += blen;</a>
<a name="ln1121">          size -= blen;</a>
<a name="ln1122">          memmove(ptr, ptr + blen, (size_t)size);</a>
<a name="ln1123">          if (set_options) {</a>
<a name="ln1124">            curbuf-&gt;b_p_bomb = TRUE;</a>
<a name="ln1125">            curbuf-&gt;b_start_bomb = TRUE;</a>
<a name="ln1126">          }</a>
<a name="ln1127">        }</a>
<a name="ln1128"> </a>
<a name="ln1129">        if (fio_flags == FIO_UCSBOM) {</a>
<a name="ln1130">          if (ccname == NULL) {</a>
<a name="ln1131">            // No BOM detected: retry with next encoding.</a>
<a name="ln1132">            advance_fenc = true;</a>
<a name="ln1133">          } else {</a>
<a name="ln1134">            /* BOM detected: set &quot;fenc&quot; and jump back */</a>
<a name="ln1135">            if (fenc_alloced)</a>
<a name="ln1136">              xfree(fenc);</a>
<a name="ln1137">            fenc = ccname;</a>
<a name="ln1138">            fenc_alloced = false;</a>
<a name="ln1139">          }</a>
<a name="ln1140">          /* retry reading without getting new bytes or rewinding */</a>
<a name="ln1141">          skip_read = TRUE;</a>
<a name="ln1142">          goto retry;</a>
<a name="ln1143">        }</a>
<a name="ln1144">      }</a>
<a name="ln1145"> </a>
<a name="ln1146">      /* Include not converted bytes. */</a>
<a name="ln1147">      ptr -= conv_restlen;</a>
<a name="ln1148">      size += conv_restlen;</a>
<a name="ln1149">      conv_restlen = 0;</a>
<a name="ln1150">      /*</a>
<a name="ln1151">       * Break here for a read error or end-of-file.</a>
<a name="ln1152">       */</a>
<a name="ln1153">      if (size &lt;= 0)</a>
<a name="ln1154">        break;</a>
<a name="ln1155"> </a>
<a name="ln1156"># ifdef HAVE_ICONV</a>
<a name="ln1157">      if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln1158">        /*</a>
<a name="ln1159">         * Attempt conversion of the read bytes to 'encoding' using</a>
<a name="ln1160">         * iconv().</a>
<a name="ln1161">         */</a>
<a name="ln1162">        const char      *fromp;</a>
<a name="ln1163">        char            *top;</a>
<a name="ln1164">        size_t from_size;</a>
<a name="ln1165">        size_t to_size;</a>
<a name="ln1166"> </a>
<a name="ln1167">        fromp = (char *)ptr;</a>
<a name="ln1168">        from_size = size;</a>
<a name="ln1169">        ptr += size;</a>
<a name="ln1170">        top = (char *)ptr;</a>
<a name="ln1171">        to_size = real_size - size;</a>
<a name="ln1172"> </a>
<a name="ln1173">        /*</a>
<a name="ln1174">         * If there is conversion error or not enough room try using</a>
<a name="ln1175">         * another conversion.  Except for when there is no</a>
<a name="ln1176">         * alternative (help files).</a>
<a name="ln1177">         */</a>
<a name="ln1178">        while ((iconv(iconv_fd, (void *)&amp;fromp, &amp;from_size,</a>
<a name="ln1179">                    &amp;top, &amp;to_size)</a>
<a name="ln1180">                == (size_t)-1 &amp;&amp; ICONV_ERRNO != ICONV_EINVAL)</a>
<a name="ln1181">               || from_size &gt; CONV_RESTLEN) {</a>
<a name="ln1182">          if (can_retry)</a>
<a name="ln1183">            goto rewind_retry;</a>
<a name="ln1184">          if (conv_error == 0)</a>
<a name="ln1185">            conv_error = readfile_linenr(linecnt,</a>
<a name="ln1186">                ptr, (char_u *)top);</a>
<a name="ln1187"> </a>
<a name="ln1188">          /* Deal with a bad byte and continue with the next. */</a>
<a name="ln1189">          ++fromp;</a>
<a name="ln1190">          --from_size;</a>
<a name="ln1191">          if (bad_char_behavior == BAD_KEEP) {</a>
<a name="ln1192">            *top++ = *(fromp - 1);</a>
<a name="ln1193">            --to_size;</a>
<a name="ln1194">          } else if (bad_char_behavior != BAD_DROP) {</a>
<a name="ln1195">            *top++ = bad_char_behavior;</a>
<a name="ln1196">            --to_size;</a>
<a name="ln1197">          }</a>
<a name="ln1198">        }</a>
<a name="ln1199"> </a>
<a name="ln1200">        if (from_size &gt; 0) {</a>
<a name="ln1201">          /* Some remaining characters, keep them for the next</a>
<a name="ln1202">           * round. */</a>
<a name="ln1203">          memmove(conv_rest, (char_u *)fromp, from_size);</a>
<a name="ln1204">          conv_restlen = (int)from_size;</a>
<a name="ln1205">        }</a>
<a name="ln1206"> </a>
<a name="ln1207">        /* move the linerest to before the converted characters */</a>
<a name="ln1208">        line_start = ptr - linerest;</a>
<a name="ln1209">        memmove(line_start, buffer, (size_t)linerest);</a>
<a name="ln1210">        size = (long)((char_u *)top - ptr);</a>
<a name="ln1211">      }</a>
<a name="ln1212"># endif</a>
<a name="ln1213"> </a>
<a name="ln1214">      if (fio_flags != 0) {</a>
<a name="ln1215">        unsigned int u8c;</a>
<a name="ln1216">        char_u  *dest;</a>
<a name="ln1217">        char_u  *tail = NULL;</a>
<a name="ln1218"> </a>
<a name="ln1219">        // Convert Unicode or Latin1 to UTF-8.</a>
<a name="ln1220">        // Go from end to start through the buffer, because the number</a>
<a name="ln1221">        // of bytes may increase.</a>
<a name="ln1222">        // &quot;dest&quot; points to after where the UTF-8 bytes go, &quot;p&quot; points</a>
<a name="ln1223">        // to after the next character to convert.</a>
<a name="ln1224">        dest = ptr + real_size;</a>
<a name="ln1225">        if (fio_flags == FIO_LATIN1 || fio_flags == FIO_UTF8) {</a>
<a name="ln1226">          p = ptr + size;</a>
<a name="ln1227">          if (fio_flags == FIO_UTF8) {</a>
<a name="ln1228">            /* Check for a trailing incomplete UTF-8 sequence */</a>
<a name="ln1229">            tail = ptr + size - 1;</a>
<a name="ln1230">            while (tail &gt; ptr &amp;&amp; (*tail &amp; 0xc0) == 0x80)</a>
<a name="ln1231">              --tail;</a>
<a name="ln1232">            if (tail + utf_byte2len(*tail) &lt;= ptr + size)</a>
<a name="ln1233">              tail = NULL;</a>
<a name="ln1234">            else</a>
<a name="ln1235">              p = tail;</a>
<a name="ln1236">          }</a>
<a name="ln1237">        } else if (fio_flags &amp; (FIO_UCS2 | FIO_UTF16)) {</a>
<a name="ln1238">          /* Check for a trailing byte */</a>
<a name="ln1239">          p = ptr + (size &amp; ~1);</a>
<a name="ln1240">          if (size &amp; 1)</a>
<a name="ln1241">            tail = p;</a>
<a name="ln1242">          if ((fio_flags &amp; FIO_UTF16) &amp;&amp; p &gt; ptr) {</a>
<a name="ln1243">            /* Check for a trailing leading word */</a>
<a name="ln1244">            if (fio_flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln1245">              u8c = (*--p &lt;&lt; 8);</a>
<a name="ln1246">              u8c += *--p;</a>
<a name="ln1247">            } else {</a>
<a name="ln1248">              u8c = *--p;</a>
<a name="ln1249">              u8c += (*--p &lt;&lt; 8);</a>
<a name="ln1250">            }</a>
<a name="ln1251">            if (u8c &gt;= 0xd800 &amp;&amp; u8c &lt;= 0xdbff)</a>
<a name="ln1252">              tail = p;</a>
<a name="ln1253">            else</a>
<a name="ln1254">              p += 2;</a>
<a name="ln1255">          }</a>
<a name="ln1256">        } else {   /*  FIO_UCS4 */</a>
<a name="ln1257">                     /* Check for trailing 1, 2 or 3 bytes */</a>
<a name="ln1258">          p = ptr + (size &amp; ~3);</a>
<a name="ln1259">          if (size &amp; 3)</a>
<a name="ln1260">            tail = p;</a>
<a name="ln1261">        }</a>
<a name="ln1262"> </a>
<a name="ln1263">        /* If there is a trailing incomplete sequence move it to</a>
<a name="ln1264">         * conv_rest[]. */</a>
<a name="ln1265">        if (tail != NULL) {</a>
<a name="ln1266">          conv_restlen = (int)((ptr + size) - tail);</a>
<a name="ln1267">          memmove(conv_rest, tail, conv_restlen);</a>
<a name="ln1268">          size -= conv_restlen;</a>
<a name="ln1269">        }</a>
<a name="ln1270"> </a>
<a name="ln1271"> </a>
<a name="ln1272">        while (p &gt; ptr) {</a>
<a name="ln1273">          if (fio_flags &amp; FIO_LATIN1)</a>
<a name="ln1274">            u8c = *--p;</a>
<a name="ln1275">          else if (fio_flags &amp; (FIO_UCS2 | FIO_UTF16)) {</a>
<a name="ln1276">            if (fio_flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln1277">              u8c = (*--p &lt;&lt; 8);</a>
<a name="ln1278">              u8c += *--p;</a>
<a name="ln1279">            } else {</a>
<a name="ln1280">              u8c = *--p;</a>
<a name="ln1281">              u8c += (*--p &lt;&lt; 8);</a>
<a name="ln1282">            }</a>
<a name="ln1283">            if ((fio_flags &amp; FIO_UTF16)</a>
<a name="ln1284">                &amp;&amp; u8c &gt;= 0xdc00 &amp;&amp; u8c &lt;= 0xdfff) {</a>
<a name="ln1285">              int u16c;</a>
<a name="ln1286"> </a>
<a name="ln1287">              if (p == ptr) {</a>
<a name="ln1288">                /* Missing leading word. */</a>
<a name="ln1289">                if (can_retry)</a>
<a name="ln1290">                  goto rewind_retry;</a>
<a name="ln1291">                if (conv_error == 0)</a>
<a name="ln1292">                  conv_error = readfile_linenr(linecnt,</a>
<a name="ln1293">                      ptr, p);</a>
<a name="ln1294">                if (bad_char_behavior == BAD_DROP)</a>
<a name="ln1295">                  continue;</a>
<a name="ln1296">                if (bad_char_behavior != BAD_KEEP)</a>
<a name="ln1297">                  u8c = bad_char_behavior;</a>
<a name="ln1298">              }</a>
<a name="ln1299"> </a>
<a name="ln1300">              /* found second word of double-word, get the first</a>
<a name="ln1301">               * word and compute the resulting character */</a>
<a name="ln1302">              if (fio_flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln1303">                u16c = (*--p &lt;&lt; 8);</a>
<a name="ln1304">                u16c += *--p;</a>
<a name="ln1305">              } else {</a>
<a name="ln1306">                u16c = *--p;</a>
<a name="ln1307">                u16c += (*--p &lt;&lt; 8);</a>
<a name="ln1308">              }</a>
<a name="ln1309">              u8c = 0x10000 + ((u16c &amp; 0x3ff) &lt;&lt; 10)</a>
<a name="ln1310">                    + (u8c &amp; 0x3ff);</a>
<a name="ln1311"> </a>
<a name="ln1312">              /* Check if the word is indeed a leading word. */</a>
<a name="ln1313">              if (u16c &lt; 0xd800 || u16c &gt; 0xdbff) {</a>
<a name="ln1314">                if (can_retry)</a>
<a name="ln1315">                  goto rewind_retry;</a>
<a name="ln1316">                if (conv_error == 0)</a>
<a name="ln1317">                  conv_error = readfile_linenr(linecnt,</a>
<a name="ln1318">                      ptr, p);</a>
<a name="ln1319">                if (bad_char_behavior == BAD_DROP)</a>
<a name="ln1320">                  continue;</a>
<a name="ln1321">                if (bad_char_behavior != BAD_KEEP)</a>
<a name="ln1322">                  u8c = bad_char_behavior;</a>
<a name="ln1323">              }</a>
<a name="ln1324">            }</a>
<a name="ln1325">          } else if (fio_flags &amp; FIO_UCS4) {</a>
<a name="ln1326">            if (fio_flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln1327">              u8c = (unsigned)(*--p) &lt;&lt; 24;</a>
<a name="ln1328">              u8c += (unsigned)(*--p) &lt;&lt; 16;</a>
<a name="ln1329">              u8c += (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1330">              u8c += *--p;</a>
<a name="ln1331">            } else {          /* big endian */</a>
<a name="ln1332">              u8c = *--p;</a>
<a name="ln1333">              u8c += (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1334">              u8c += (unsigned)(*--p) &lt;&lt; 16;</a>
<a name="ln1335">              u8c += (unsigned)(*--p) &lt;&lt; 24;</a>
<a name="ln1336">            }</a>
<a name="ln1337">          } else {        /* UTF-8 */</a>
<a name="ln1338">            if (*--p &lt; 0x80)</a>
<a name="ln1339">              u8c = *p;</a>
<a name="ln1340">            else {</a>
<a name="ln1341">              len = utf_head_off(ptr, p);</a>
<a name="ln1342">              p -= len;</a>
<a name="ln1343">              u8c = utf_ptr2char(p);</a>
<a name="ln1344">              if (len == 0) {</a>
<a name="ln1345">                /* Not a valid UTF-8 character, retry with</a>
<a name="ln1346">                 * another fenc when possible, otherwise just</a>
<a name="ln1347">                 * report the error. */</a>
<a name="ln1348">                if (can_retry)</a>
<a name="ln1349">                  goto rewind_retry;</a>
<a name="ln1350">                if (conv_error == 0)</a>
<a name="ln1351">                  conv_error = readfile_linenr(linecnt,</a>
<a name="ln1352">                      ptr, p);</a>
<a name="ln1353">                if (bad_char_behavior == BAD_DROP)</a>
<a name="ln1354">                  continue;</a>
<a name="ln1355">                if (bad_char_behavior != BAD_KEEP)</a>
<a name="ln1356">                  u8c = bad_char_behavior;</a>
<a name="ln1357">              }</a>
<a name="ln1358">            }</a>
<a name="ln1359">          }</a>
<a name="ln1360">          assert(u8c &lt;= INT_MAX);</a>
<a name="ln1361">          // produce UTF-8</a>
<a name="ln1362">          dest -= utf_char2len((int)u8c);</a>
<a name="ln1363">          (void)utf_char2bytes((int)u8c, dest);</a>
<a name="ln1364">        }</a>
<a name="ln1365"> </a>
<a name="ln1366">        // move the linerest to before the converted characters</a>
<a name="ln1367">        line_start = dest - linerest;</a>
<a name="ln1368">        memmove(line_start, buffer, (size_t)linerest);</a>
<a name="ln1369">        size = (long)((ptr + real_size) - dest);</a>
<a name="ln1370">        ptr = dest;</a>
<a name="ln1371">      } else if (!curbuf-&gt;b_p_bin) {</a>
<a name="ln1372">        bool incomplete_tail = false;</a>
<a name="ln1373"> </a>
<a name="ln1374">        // Reading UTF-8: Check if the bytes are valid UTF-8.</a>
<a name="ln1375">        for (p = ptr;; p++) {</a>
<a name="ln1376">          int todo = (int)((ptr + size) - p);</a>
<a name="ln1377">          int l;</a>
<a name="ln1378"> </a>
<a name="ln1379">          if (todo &lt;= 0) {</a>
<a name="ln1380">            break;</a>
<a name="ln1381">          }</a>
<a name="ln1382">          if (*p &gt;= 0x80) {</a>
<a name="ln1383">            // A length of 1 means it's an illegal byte.  Accept</a>
<a name="ln1384">            // an incomplete character at the end though, the next</a>
<a name="ln1385">            // read() will get the next bytes, we'll check it</a>
<a name="ln1386">            // then.</a>
<a name="ln1387">            l = utf_ptr2len_len(p, todo);</a>
<a name="ln1388">            if (l &gt; todo &amp;&amp; !incomplete_tail) {</a>
<a name="ln1389">              // Avoid retrying with a different encoding when</a>
<a name="ln1390">              // a truncated file is more likely, or attempting</a>
<a name="ln1391">              // to read the rest of an incomplete sequence when</a>
<a name="ln1392">              // we have already done so.</a>
<a name="ln1393">              if (p &gt; ptr || filesize &gt; 0) {</a>
<a name="ln1394">                incomplete_tail = true;</a>
<a name="ln1395">              }</a>
<a name="ln1396">              // Incomplete byte sequence, move it to conv_rest[]</a>
<a name="ln1397">              // and try to read the rest of it, unless we've</a>
<a name="ln1398">              // already done so.</a>
<a name="ln1399">              if (p &gt; ptr) {</a>
<a name="ln1400">                conv_restlen = todo;</a>
<a name="ln1401">                memmove(conv_rest, p, conv_restlen);</a>
<a name="ln1402">                size -= conv_restlen;</a>
<a name="ln1403">                break;</a>
<a name="ln1404">              }</a>
<a name="ln1405">            }</a>
<a name="ln1406">            if (l == 1 || l &gt; todo) {</a>
<a name="ln1407">              /* Illegal byte.  If we can try another encoding</a>
<a name="ln1408">               * do that, unless at EOF where a truncated</a>
<a name="ln1409">               * file is more likely than a conversion error. */</a>
<a name="ln1410">              if (can_retry &amp;&amp; !incomplete_tail)</a>
<a name="ln1411">                break;</a>
<a name="ln1412"># ifdef HAVE_ICONV</a>
<a name="ln1413">              // When we did a conversion report an error.</a>
<a name="ln1414">              if (iconv_fd != (iconv_t)-1 &amp;&amp; conv_error == 0) {</a>
<a name="ln1415">                conv_error = readfile_linenr(linecnt, ptr, p);</a>
<a name="ln1416">              }</a>
<a name="ln1417"># endif</a>
<a name="ln1418">              /* Remember the first linenr with an illegal byte */</a>
<a name="ln1419">              if (conv_error == 0 &amp;&amp; illegal_byte == 0)</a>
<a name="ln1420">                illegal_byte = readfile_linenr(linecnt, ptr, p);</a>
<a name="ln1421"> </a>
<a name="ln1422">              /* Drop, keep or replace the bad byte. */</a>
<a name="ln1423">              if (bad_char_behavior == BAD_DROP) {</a>
<a name="ln1424">                memmove(p, p + 1, todo - 1);</a>
<a name="ln1425">                --p;</a>
<a name="ln1426">                --size;</a>
<a name="ln1427">              } else if (bad_char_behavior != BAD_KEEP)</a>
<a name="ln1428">                *p = bad_char_behavior;</a>
<a name="ln1429">            } else</a>
<a name="ln1430">              p += l - 1;</a>
<a name="ln1431">          }</a>
<a name="ln1432">        }</a>
<a name="ln1433">        if (p &lt; ptr + size &amp;&amp; !incomplete_tail) {</a>
<a name="ln1434">          /* Detected a UTF-8 error. */</a>
<a name="ln1435">rewind_retry:</a>
<a name="ln1436">          // Retry reading with another conversion.</a>
<a name="ln1437"># ifdef HAVE_ICONV</a>
<a name="ln1438">          if (*p_ccv != NUL &amp;&amp; iconv_fd != (iconv_t)-1) {</a>
<a name="ln1439">            // iconv() failed, try 'charconvert'</a>
<a name="ln1440">            did_iconv = true;</a>
<a name="ln1441">          } else {</a>
<a name="ln1442"># endif</a>
<a name="ln1443">          // use next item from 'fileencodings'</a>
<a name="ln1444">          advance_fenc = true;</a>
<a name="ln1445"># ifdef HAVE_ICONV</a>
<a name="ln1446">          }</a>
<a name="ln1447"># endif</a>
<a name="ln1448">          file_rewind = true;</a>
<a name="ln1449">          goto retry;</a>
<a name="ln1450">        }</a>
<a name="ln1451">      }</a>
<a name="ln1452"> </a>
<a name="ln1453">      /* count the number of characters (after conversion!) */</a>
<a name="ln1454">      filesize += size;</a>
<a name="ln1455"> </a>
<a name="ln1456">      /*</a>
<a name="ln1457">       * when reading the first part of a file: guess EOL type</a>
<a name="ln1458">       */</a>
<a name="ln1459">      if (fileformat == EOL_UNKNOWN) {</a>
<a name="ln1460">        /* First try finding a NL, for Dos and Unix */</a>
<a name="ln1461">        if (try_dos || try_unix) {</a>
<a name="ln1462">          // Reset the carriage return counter.</a>
<a name="ln1463">          if (try_mac) {</a>
<a name="ln1464">            try_mac = 1;</a>
<a name="ln1465">          }</a>
<a name="ln1466"> </a>
<a name="ln1467">          for (p = ptr; p &lt; ptr + size; ++p) {</a>
<a name="ln1468">            if (*p == NL) {</a>
<a name="ln1469">              if (!try_unix</a>
<a name="ln1470">                  || (try_dos &amp;&amp; p &gt; ptr &amp;&amp; p[-1] == CAR))</a>
<a name="ln1471">                fileformat = EOL_DOS;</a>
<a name="ln1472">              else</a>
<a name="ln1473">                fileformat = EOL_UNIX;</a>
<a name="ln1474">              break;</a>
<a name="ln1475">            } else if (*p == CAR &amp;&amp; try_mac) {</a>
<a name="ln1476">              try_mac++;</a>
<a name="ln1477">            }</a>
<a name="ln1478">          }</a>
<a name="ln1479"> </a>
<a name="ln1480">          /* Don't give in to EOL_UNIX if EOL_MAC is more likely */</a>
<a name="ln1481">          if (fileformat == EOL_UNIX &amp;&amp; try_mac) {</a>
<a name="ln1482">            /* Need to reset the counters when retrying fenc. */</a>
<a name="ln1483">            try_mac = 1;</a>
<a name="ln1484">            try_unix = 1;</a>
<a name="ln1485">            for (; p &gt;= ptr &amp;&amp; *p != CAR; p--)</a>
<a name="ln1486">              ;</a>
<a name="ln1487">            if (p &gt;= ptr) {</a>
<a name="ln1488">              for (p = ptr; p &lt; ptr + size; ++p) {</a>
<a name="ln1489">                if (*p == NL)</a>
<a name="ln1490">                  try_unix++;</a>
<a name="ln1491">                else if (*p == CAR)</a>
<a name="ln1492">                  try_mac++;</a>
<a name="ln1493">              }</a>
<a name="ln1494">              if (try_mac &gt; try_unix)</a>
<a name="ln1495">                fileformat = EOL_MAC;</a>
<a name="ln1496">            }</a>
<a name="ln1497">          } else if (fileformat == EOL_UNKNOWN &amp;&amp; try_mac == 1) {</a>
<a name="ln1498">            // Looking for CR but found no end-of-line markers at all:</a>
<a name="ln1499">            // use the default format.</a>
<a name="ln1500">            fileformat = default_fileformat();</a>
<a name="ln1501">          }</a>
<a name="ln1502">        }</a>
<a name="ln1503"> </a>
<a name="ln1504">        /* No NL found: may use Mac format */</a>
<a name="ln1505">        if (fileformat == EOL_UNKNOWN &amp;&amp; try_mac)</a>
<a name="ln1506">          fileformat = EOL_MAC;</a>
<a name="ln1507"> </a>
<a name="ln1508">        /* Still nothing found?  Use first format in 'ffs' */</a>
<a name="ln1509">        if (fileformat == EOL_UNKNOWN)</a>
<a name="ln1510">          fileformat = default_fileformat();</a>
<a name="ln1511"> </a>
<a name="ln1512">        // May set 'p_ff' if editing a new file.</a>
<a name="ln1513">        if (set_options) {</a>
<a name="ln1514">          set_fileformat(fileformat, OPT_LOCAL);</a>
<a name="ln1515">        }</a>
<a name="ln1516">      }</a>
<a name="ln1517">    }</a>
<a name="ln1518"> </a>
<a name="ln1519">    /*</a>
<a name="ln1520">     * This loop is executed once for every character read.</a>
<a name="ln1521">     * Keep it fast!</a>
<a name="ln1522">     */</a>
<a name="ln1523">    if (fileformat == EOL_MAC) {</a>
<a name="ln1524">      --ptr;</a>
<a name="ln1525">      while (++ptr, --size &gt;= 0) {</a>
<a name="ln1526">        /* catch most common case first */</a>
<a name="ln1527">        if ((c = *ptr) != NUL &amp;&amp; c != CAR &amp;&amp; c != NL)</a>
<a name="ln1528">          continue;</a>
<a name="ln1529">        if (c == NUL)</a>
<a name="ln1530">          *ptr = NL;            /* NULs are replaced by newlines! */</a>
<a name="ln1531">        else if (c == NL)</a>
<a name="ln1532">          *ptr = CAR;           /* NLs are replaced by CRs! */</a>
<a name="ln1533">        else {</a>
<a name="ln1534">          if (skip_count == 0) {</a>
<a name="ln1535">            *ptr = NUL;                     /* end of line */</a>
<a name="ln1536">            len = (colnr_T) (ptr - line_start + 1);</a>
<a name="ln1537">            if (ml_append(lnum, line_start, len, newfile) == FAIL) {</a>
<a name="ln1538">              error = TRUE;</a>
<a name="ln1539">              break;</a>
<a name="ln1540">            }</a>
<a name="ln1541">            if (read_undo_file)</a>
<a name="ln1542">              sha256_update(&amp;sha_ctx, line_start, len);</a>
<a name="ln1543">            ++lnum;</a>
<a name="ln1544">            if (--read_count == 0) {</a>
<a name="ln1545">              error = TRUE;                     /* break loop */</a>
<a name="ln1546">              line_start = ptr;                 /* nothing left to write */</a>
<a name="ln1547">              break;</a>
<a name="ln1548">            }</a>
<a name="ln1549">          } else</a>
<a name="ln1550">            --skip_count;</a>
<a name="ln1551">          line_start = ptr + 1;</a>
<a name="ln1552">        }</a>
<a name="ln1553">      }</a>
<a name="ln1554">    } else {</a>
<a name="ln1555">      --ptr;</a>
<a name="ln1556">      while (++ptr, --size &gt;= 0) {</a>
<a name="ln1557">        if ((c = *ptr) != NUL &amp;&amp; c != NL)          /* catch most common case */</a>
<a name="ln1558">          continue;</a>
<a name="ln1559">        if (c == NUL)</a>
<a name="ln1560">          *ptr = NL;            /* NULs are replaced by newlines! */</a>
<a name="ln1561">        else {</a>
<a name="ln1562">          if (skip_count == 0) {</a>
<a name="ln1563">            *ptr = NUL;                         /* end of line */</a>
<a name="ln1564">            len = (colnr_T)(ptr - line_start + 1);</a>
<a name="ln1565">            if (fileformat == EOL_DOS) {</a>
<a name="ln1566">              if (ptr &gt; line_start &amp;&amp; ptr[-1] == CAR) {</a>
<a name="ln1567">                // remove CR before NL</a>
<a name="ln1568">                ptr[-1] = NUL;</a>
<a name="ln1569">                len--;</a>
<a name="ln1570">              } else if (ff_error != EOL_DOS) {</a>
<a name="ln1571">                // Reading in Dos format, but no CR-LF found!</a>
<a name="ln1572">                // When 'fileformats' includes &quot;unix&quot;, delete all</a>
<a name="ln1573">                // the lines read so far and start all over again.</a>
<a name="ln1574">                // Otherwise give an error message later.</a>
<a name="ln1575">                if (try_unix</a>
<a name="ln1576">                    &amp;&amp; !read_stdin</a>
<a name="ln1577">                    &amp;&amp; (read_buffer</a>
<a name="ln1578">                        || vim_lseek(fd, (off_T)0L, SEEK_SET) == 0)) {</a>
<a name="ln1579">                  fileformat = EOL_UNIX;</a>
<a name="ln1580">                  if (set_options)</a>
<a name="ln1581">                    set_fileformat(EOL_UNIX, OPT_LOCAL);</a>
<a name="ln1582">                  file_rewind = true;</a>
<a name="ln1583">                  keep_fileformat = true;</a>
<a name="ln1584">                  goto retry;</a>
<a name="ln1585">                }</a>
<a name="ln1586">                ff_error = EOL_DOS;</a>
<a name="ln1587">              }</a>
<a name="ln1588">            }</a>
<a name="ln1589">            if (ml_append(lnum, line_start, len, newfile) == FAIL) {</a>
<a name="ln1590">              error = TRUE;</a>
<a name="ln1591">              break;</a>
<a name="ln1592">            }</a>
<a name="ln1593">            if (read_undo_file)</a>
<a name="ln1594">              sha256_update(&amp;sha_ctx, line_start, len);</a>
<a name="ln1595">            ++lnum;</a>
<a name="ln1596">            if (--read_count == 0) {</a>
<a name="ln1597">              error = TRUE;                         /* break loop */</a>
<a name="ln1598">              line_start = ptr;                 /* nothing left to write */</a>
<a name="ln1599">              break;</a>
<a name="ln1600">            }</a>
<a name="ln1601">          } else</a>
<a name="ln1602">            --skip_count;</a>
<a name="ln1603">          line_start = ptr + 1;</a>
<a name="ln1604">        }</a>
<a name="ln1605">      }</a>
<a name="ln1606">    }</a>
<a name="ln1607">    linerest = (long)(ptr - line_start);</a>
<a name="ln1608">    os_breakcheck();</a>
<a name="ln1609">  }</a>
<a name="ln1610"> </a>
<a name="ln1611">failed:</a>
<a name="ln1612">  /* not an error, max. number of lines reached */</a>
<a name="ln1613">  if (error &amp;&amp; read_count == 0)</a>
<a name="ln1614">    error = FALSE;</a>
<a name="ln1615"> </a>
<a name="ln1616">  /*</a>
<a name="ln1617">   * If we get EOF in the middle of a line, note the fact and</a>
<a name="ln1618">   * complete the line ourselves.</a>
<a name="ln1619">   * In Dos format ignore a trailing CTRL-Z, unless 'binary' set.</a>
<a name="ln1620">   */</a>
<a name="ln1621">  if (!error</a>
<a name="ln1622">      &amp;&amp; !got_int</a>
<a name="ln1623">      &amp;&amp; linerest != 0</a>
<a name="ln1624">      &amp;&amp; !(!curbuf-&gt;b_p_bin</a>
<a name="ln1625">           &amp;&amp; fileformat == EOL_DOS</a>
<a name="ln1626">           &amp;&amp; *line_start == Ctrl_Z</a>
<a name="ln1627">           &amp;&amp; ptr == line_start + 1)) {</a>
<a name="ln1628">    /* remember for when writing */</a>
<a name="ln1629">    if (set_options)</a>
<a name="ln1630">      curbuf-&gt;b_p_eol = FALSE;</a>
<a name="ln1631">    *ptr = NUL;</a>
<a name="ln1632">    len = (colnr_T)(ptr - line_start + 1);</a>
<a name="ln1633">    if (ml_append(lnum, line_start, len, newfile) == FAIL)</a>
<a name="ln1634">      error = TRUE;</a>
<a name="ln1635">    else {</a>
<a name="ln1636">      if (read_undo_file)</a>
<a name="ln1637">        sha256_update(&amp;sha_ctx, line_start, len);</a>
<a name="ln1638">      read_no_eol_lnum = ++lnum;</a>
<a name="ln1639">    }</a>
<a name="ln1640">  }</a>
<a name="ln1641"> </a>
<a name="ln1642">  if (set_options) {</a>
<a name="ln1643">    // Remember the current file format.</a>
<a name="ln1644">    save_file_ff(curbuf);</a>
<a name="ln1645">    // If editing a new file: set 'fenc' for the current buffer.</a>
<a name="ln1646">    // Also for &quot;:read ++edit file&quot;.</a>
<a name="ln1647">    set_string_option_direct(&quot;fenc&quot;, -1, fenc, OPT_FREE | OPT_LOCAL, 0);</a>
<a name="ln1648">  }</a>
<a name="ln1649">  if (fenc_alloced)</a>
<a name="ln1650">    xfree(fenc);</a>
<a name="ln1651"># ifdef HAVE_ICONV</a>
<a name="ln1652">  if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln1653">    iconv_close(iconv_fd);</a>
<a name="ln1654">  }</a>
<a name="ln1655"># endif</a>
<a name="ln1656"> </a>
<a name="ln1657">  if (!read_buffer &amp;&amp; !read_stdin) {</a>
<a name="ln1658">    close(fd);  // errors are ignored</a>
<a name="ln1659">  } else {</a>
<a name="ln1660">    (void)os_set_cloexec(fd);</a>
<a name="ln1661">  }</a>
<a name="ln1662">  xfree(buffer);</a>
<a name="ln1663"> </a>
<a name="ln1664">  if (read_stdin) {</a>
<a name="ln1665">    close(0);</a>
<a name="ln1666">#ifndef WIN32</a>
<a name="ln1667">    // On Unix, use stderr for stdin, makes shell commands work.</a>
<a name="ln1668">    vim_ignored = dup(2);</a>
<a name="ln1669">#else</a>
<a name="ln1670">    // On Windows, use the console input handle for stdin.</a>
<a name="ln1671">    HANDLE conin = CreateFile(&quot;CONIN$&quot;, GENERIC_READ | GENERIC_WRITE,</a>
<a name="ln1672">                              FILE_SHARE_READ, (LPSECURITY_ATTRIBUTES)NULL,</a>
<a name="ln1673">                              OPEN_EXISTING, 0, (HANDLE)NULL);</a>
<a name="ln1674">    vim_ignored = _open_osfhandle(conin, _O_RDONLY);</a>
<a name="ln1675">#endif</a>
<a name="ln1676">  }</a>
<a name="ln1677"> </a>
<a name="ln1678">  if (tmpname != NULL) {</a>
<a name="ln1679">    os_remove((char *)tmpname);  // delete converted file</a>
<a name="ln1680">    xfree(tmpname);</a>
<a name="ln1681">  }</a>
<a name="ln1682">  --no_wait_return;                     /* may wait for return now */</a>
<a name="ln1683"> </a>
<a name="ln1684">  /*</a>
<a name="ln1685">   * In recovery mode everything but autocommands is skipped.</a>
<a name="ln1686">   */</a>
<a name="ln1687">  if (!recoverymode) {</a>
<a name="ln1688">    /* need to delete the last line, which comes from the empty buffer */</a>
<a name="ln1689">    if (newfile &amp;&amp; wasempty &amp;&amp; !(curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY)) {</a>
<a name="ln1690">      ml_delete(curbuf-&gt;b_ml.ml_line_count, false);</a>
<a name="ln1691">      linecnt--;</a>
<a name="ln1692">    }</a>
<a name="ln1693">    curbuf-&gt;deleted_bytes = 0;</a>
<a name="ln1694">    curbuf-&gt;deleted_bytes2 = 0;</a>
<a name="ln1695">    curbuf-&gt;deleted_codepoints = 0;</a>
<a name="ln1696">    curbuf-&gt;deleted_codeunits = 0;</a>
<a name="ln1697">    linecnt = curbuf-&gt;b_ml.ml_line_count - linecnt;</a>
<a name="ln1698">    if (filesize == 0)</a>
<a name="ln1699">      linecnt = 0;</a>
<a name="ln1700">    if (newfile || read_buffer) {</a>
<a name="ln1701">      redraw_curbuf_later(NOT_VALID);</a>
<a name="ln1702">      /* After reading the text into the buffer the diff info needs to</a>
<a name="ln1703">       * be updated. */</a>
<a name="ln1704">      diff_invalidate(curbuf);</a>
<a name="ln1705">      /* All folds in the window are invalid now.  Mark them for update</a>
<a name="ln1706">       * before triggering autocommands. */</a>
<a name="ln1707">      foldUpdateAll(curwin);</a>
<a name="ln1708">    } else if (linecnt)                 /* appended at least one line */</a>
<a name="ln1709">      appended_lines_mark(from, linecnt);</a>
<a name="ln1710"> </a>
<a name="ln1711">    /*</a>
<a name="ln1712">     * If we were reading from the same terminal as where messages go,</a>
<a name="ln1713">     * the screen will have been messed up.</a>
<a name="ln1714">     * Switch on raw mode now and clear the screen.</a>
<a name="ln1715">     */</a>
<a name="ln1716">    if (read_stdin) {</a>
<a name="ln1717">      screenclear();</a>
<a name="ln1718">    }</a>
<a name="ln1719"> </a>
<a name="ln1720">    if (got_int) {</a>
<a name="ln1721">      if (!(flags &amp; READ_DUMMY)) {</a>
<a name="ln1722">        filemess(curbuf, sfname, (char_u *)_(e_interr), 0);</a>
<a name="ln1723">        if (newfile)</a>
<a name="ln1724">          curbuf-&gt;b_p_ro = TRUE;                /* must use &quot;w!&quot; now */</a>
<a name="ln1725">      }</a>
<a name="ln1726">      msg_scroll = msg_save;</a>
<a name="ln1727">      check_marks_read();</a>
<a name="ln1728">      return OK;                /* an interrupt isn't really an error */</a>
<a name="ln1729">    }</a>
<a name="ln1730"> </a>
<a name="ln1731">    if (!filtering &amp;&amp; !(flags &amp; READ_DUMMY)) {</a>
<a name="ln1732">      add_quoted_fname((char *)IObuff, IOSIZE, curbuf, (const char *)sfname);</a>
<a name="ln1733">      c = false;</a>
<a name="ln1734"> </a>
<a name="ln1735">#ifdef UNIX</a>
<a name="ln1736">      if (S_ISFIFO(perm)) {             // fifo</a>
<a name="ln1737">        STRCAT(IObuff, _(&quot;[fifo]&quot;));</a>
<a name="ln1738">        c = TRUE;</a>
<a name="ln1739">      }</a>
<a name="ln1740">      if (S_ISSOCK(perm)) {            // or socket</a>
<a name="ln1741">        STRCAT(IObuff, _(&quot;[socket]&quot;));</a>
<a name="ln1742">        c = TRUE;</a>
<a name="ln1743">      }</a>
<a name="ln1744"># ifdef OPEN_CHR_FILES</a>
<a name="ln1745">      if (S_ISCHR(perm)) {                          /* or character special */</a>
<a name="ln1746">        STRCAT(IObuff, _(&quot;[character special]&quot;));</a>
<a name="ln1747">        c = TRUE;</a>
<a name="ln1748">      }</a>
<a name="ln1749"># endif</a>
<a name="ln1750">#endif</a>
<a name="ln1751">      if (curbuf-&gt;b_p_ro) {</a>
<a name="ln1752">        STRCAT(IObuff, shortmess(SHM_RO) ? _(&quot;[RO]&quot;) : _(&quot;[readonly]&quot;));</a>
<a name="ln1753">        c = TRUE;</a>
<a name="ln1754">      }</a>
<a name="ln1755">      if (read_no_eol_lnum) {</a>
<a name="ln1756">        msg_add_eol();</a>
<a name="ln1757">        c = TRUE;</a>
<a name="ln1758">      }</a>
<a name="ln1759">      if (ff_error == EOL_DOS) {</a>
<a name="ln1760">        STRCAT(IObuff, _(&quot;[CR missing]&quot;));</a>
<a name="ln1761">        c = TRUE;</a>
<a name="ln1762">      }</a>
<a name="ln1763">      if (split) {</a>
<a name="ln1764">        STRCAT(IObuff, _(&quot;[long lines split]&quot;));</a>
<a name="ln1765">        c = true;</a>
<a name="ln1766">      }</a>
<a name="ln1767">      if (notconverted) {</a>
<a name="ln1768">        STRCAT(IObuff, _(&quot;[NOT converted]&quot;));</a>
<a name="ln1769">        c = TRUE;</a>
<a name="ln1770">      } else if (converted) {</a>
<a name="ln1771">        STRCAT(IObuff, _(&quot;[converted]&quot;));</a>
<a name="ln1772">        c = TRUE;</a>
<a name="ln1773">      }</a>
<a name="ln1774">      if (conv_error != 0) {</a>
<a name="ln1775">        sprintf((char *)IObuff + STRLEN(IObuff),</a>
<a name="ln1776">            _(&quot;[CONVERSION ERROR in line %&quot; PRId64 &quot;]&quot;), (int64_t)conv_error);</a>
<a name="ln1777">        c = TRUE;</a>
<a name="ln1778">      } else if (illegal_byte &gt; 0) {</a>
<a name="ln1779">        sprintf((char *)IObuff + STRLEN(IObuff),</a>
<a name="ln1780">            _(&quot;[ILLEGAL BYTE in line %&quot; PRId64 &quot;]&quot;), (int64_t)illegal_byte);</a>
<a name="ln1781">        c = TRUE;</a>
<a name="ln1782">      } else if (error)  {</a>
<a name="ln1783">        STRCAT(IObuff, _(&quot;[READ ERRORS]&quot;));</a>
<a name="ln1784">        c = TRUE;</a>
<a name="ln1785">      }</a>
<a name="ln1786">      if (msg_add_fileformat(fileformat))</a>
<a name="ln1787">        c = TRUE;</a>
<a name="ln1788"> </a>
<a name="ln1789">      msg_add_lines(c, (long)linecnt, filesize);</a>
<a name="ln1790"> </a>
<a name="ln1791">      XFREE_CLEAR(keep_msg);</a>
<a name="ln1792">      p = NULL;</a>
<a name="ln1793">      msg_scrolled_ign = TRUE;</a>
<a name="ln1794"> </a>
<a name="ln1795">      if (!read_stdin &amp;&amp; !read_buffer) {</a>
<a name="ln1796">        p = msg_trunc_attr(IObuff, FALSE, 0);</a>
<a name="ln1797">      }</a>
<a name="ln1798"> </a>
<a name="ln1799">      if (read_stdin || read_buffer || restart_edit != 0</a>
<a name="ln1800">          || (msg_scrolled != 0 &amp;&amp; !need_wait_return)) {</a>
<a name="ln1801">        // Need to repeat the message after redrawing when:</a>
<a name="ln1802">        // - When reading from stdin (the screen will be cleared next).</a>
<a name="ln1803">        // - When restart_edit is set (otherwise there will be a delay before</a>
<a name="ln1804">        //   redrawing).</a>
<a name="ln1805">        // - When the screen was scrolled but there is no wait-return prompt.</a>
<a name="ln1806">        set_keep_msg(p, 0);</a>
<a name="ln1807">      }</a>
<a name="ln1808">      msg_scrolled_ign = FALSE;</a>
<a name="ln1809">    }</a>
<a name="ln1810"> </a>
<a name="ln1811">    /* with errors writing the file requires &quot;:w!&quot; */</a>
<a name="ln1812">    if (newfile &amp;&amp; (error</a>
<a name="ln1813">                    || conv_error != 0</a>
<a name="ln1814">                    || (illegal_byte &gt; 0 &amp;&amp; bad_char_behavior != BAD_KEEP)</a>
<a name="ln1815">                    ))</a>
<a name="ln1816">      curbuf-&gt;b_p_ro = TRUE;</a>
<a name="ln1817"> </a>
<a name="ln1818">    u_clearline();          /* cannot use &quot;U&quot; command after adding lines */</a>
<a name="ln1819"> </a>
<a name="ln1820">    /*</a>
<a name="ln1821">     * In Ex mode: cursor at last new line.</a>
<a name="ln1822">     * Otherwise: cursor at first new line.</a>
<a name="ln1823">     */</a>
<a name="ln1824">    if (exmode_active)</a>
<a name="ln1825">      curwin-&gt;w_cursor.lnum = from + linecnt;</a>
<a name="ln1826">    else</a>
<a name="ln1827">      curwin-&gt;w_cursor.lnum = from + 1;</a>
<a name="ln1828">    check_cursor_lnum();</a>
<a name="ln1829">    beginline(BL_WHITE | BL_FIX);           /* on first non-blank */</a>
<a name="ln1830"> </a>
<a name="ln1831">    /*</a>
<a name="ln1832">     * Set '[ and '] marks to the newly read lines.</a>
<a name="ln1833">     */</a>
<a name="ln1834">    curbuf-&gt;b_op_start.lnum = from + 1;</a>
<a name="ln1835">    curbuf-&gt;b_op_start.col = 0;</a>
<a name="ln1836">    curbuf-&gt;b_op_end.lnum = from + linecnt;</a>
<a name="ln1837">    curbuf-&gt;b_op_end.col = 0;</a>
<a name="ln1838"> </a>
<a name="ln1839">  }</a>
<a name="ln1840">  msg_scroll = msg_save;</a>
<a name="ln1841"> </a>
<a name="ln1842">  /*</a>
<a name="ln1843">   * Get the marks before executing autocommands, so they can be used there.</a>
<a name="ln1844">   */</a>
<a name="ln1845">  check_marks_read();</a>
<a name="ln1846"> </a>
<a name="ln1847">  /*</a>
<a name="ln1848">   * We remember if the last line of the read didn't have</a>
<a name="ln1849">   * an eol even when 'binary' is off, to support turning 'fixeol' off,</a>
<a name="ln1850">   * or writing the read again with 'binary' on.  The latter is required</a>
<a name="ln1851">   * for &quot;:autocmd FileReadPost *.gz set bin|'[,']!gunzip&quot; to work.</a>
<a name="ln1852">   */</a>
<a name="ln1853">  curbuf-&gt;b_no_eol_lnum = read_no_eol_lnum;</a>
<a name="ln1854"> </a>
<a name="ln1855">  /* When reloading a buffer put the cursor at the first line that is</a>
<a name="ln1856">   * different. */</a>
<a name="ln1857">  if (flags &amp; READ_KEEP_UNDO)</a>
<a name="ln1858">    u_find_first_changed();</a>
<a name="ln1859"> </a>
<a name="ln1860">  /*</a>
<a name="ln1861">   * When opening a new file locate undo info and read it.</a>
<a name="ln1862">   */</a>
<a name="ln1863">  if (read_undo_file) {</a>
<a name="ln1864">    char_u hash[UNDO_HASH_SIZE];</a>
<a name="ln1865"> </a>
<a name="ln1866">    sha256_finish(&amp;sha_ctx, hash);</a>
<a name="ln1867">    u_read_undo(NULL, hash, fname);</a>
<a name="ln1868">  }</a>
<a name="ln1869"> </a>
<a name="ln1870">  if (!read_stdin &amp;&amp; !read_fifo &amp;&amp; (!read_buffer || sfname != NULL)) {</a>
<a name="ln1871">    int m = msg_scroll;</a>
<a name="ln1872">    int n = msg_scrolled;</a>
<a name="ln1873"> </a>
<a name="ln1874">    /* Save the fileformat now, otherwise the buffer will be considered</a>
<a name="ln1875">     * modified if the format/encoding was automatically detected. */</a>
<a name="ln1876">    if (set_options)</a>
<a name="ln1877">      save_file_ff(curbuf);</a>
<a name="ln1878"> </a>
<a name="ln1879">    /*</a>
<a name="ln1880">     * The output from the autocommands should not overwrite anything and</a>
<a name="ln1881">     * should not be overwritten: Set msg_scroll, restore its value if no</a>
<a name="ln1882">     * output was done.</a>
<a name="ln1883">     */</a>
<a name="ln1884">    msg_scroll = true;</a>
<a name="ln1885">    if (filtering) {</a>
<a name="ln1886">      apply_autocmds_exarg(EVENT_FILTERREADPOST, NULL, sfname,</a>
<a name="ln1887">                           false, curbuf, eap);</a>
<a name="ln1888">    } else if (newfile || (read_buffer &amp;&amp; sfname != NULL)) {</a>
<a name="ln1889">      apply_autocmds_exarg(EVENT_BUFREADPOST, NULL, sfname,</a>
<a name="ln1890">                           false, curbuf, eap);</a>
<a name="ln1891">      if (!au_did_filetype &amp;&amp; *curbuf-&gt;b_p_ft != NUL) {</a>
<a name="ln1892">        // EVENT_FILETYPE was not triggered but the buffer already has a</a>
<a name="ln1893">        // filetype.  Trigger EVENT_FILETYPE using the existing filetype.</a>
<a name="ln1894">        apply_autocmds(EVENT_FILETYPE, curbuf-&gt;b_p_ft, curbuf-&gt;b_fname,</a>
<a name="ln1895">                       true, curbuf);</a>
<a name="ln1896">      }</a>
<a name="ln1897">    } else {</a>
<a name="ln1898">      apply_autocmds_exarg(EVENT_FILEREADPOST, sfname, sfname,</a>
<a name="ln1899">                           false, NULL, eap);</a>
<a name="ln1900">    }</a>
<a name="ln1901">    if (msg_scrolled == n) {</a>
<a name="ln1902">      msg_scroll = m;</a>
<a name="ln1903">    }</a>
<a name="ln1904">    if (aborting()) {       // autocmds may abort script processing</a>
<a name="ln1905">      return FAIL;</a>
<a name="ln1906">    }</a>
<a name="ln1907">  }</a>
<a name="ln1908"> </a>
<a name="ln1909">  if (recoverymode &amp;&amp; error)</a>
<a name="ln1910">    return FAIL;</a>
<a name="ln1911">  return OK;</a>
<a name="ln1912">}</a>
<a name="ln1913"> </a>
<a name="ln1914">#ifdef OPEN_CHR_FILES</a>
<a name="ln1915">/// Returns true if the file name argument is of the form &quot;/dev/fd/\d\+&quot;,</a>
<a name="ln1916">/// which is the name of files used for process substitution output by</a>
<a name="ln1917">/// some shells on some operating systems, e.g., bash on SunOS.</a>
<a name="ln1918">/// Do not accept &quot;/dev/fd/[012]&quot;, opening these may hang Vim.</a>
<a name="ln1919">///</a>
<a name="ln1920">/// @param fname file name to check</a>
<a name="ln1921">bool is_dev_fd_file(char_u *fname)</a>
<a name="ln1922">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1923">{</a>
<a name="ln1924">  return STRNCMP(fname, &quot;/dev/fd/&quot;, 8) == 0</a>
<a name="ln1925">         &amp;&amp; ascii_isdigit(fname[8])</a>
<a name="ln1926">         &amp;&amp; *skipdigits(fname + 9) == NUL</a>
<a name="ln1927">         &amp;&amp; (fname[9] != NUL</a>
<a name="ln1928">             || (fname[8] != '0' &amp;&amp; fname[8] != '1' &amp;&amp; fname[8] != '2'));</a>
<a name="ln1929">}</a>
<a name="ln1930">#endif</a>
<a name="ln1931"> </a>
<a name="ln1932"> </a>
<a name="ln1933">/*</a>
<a name="ln1934"> * From the current line count and characters read after that, estimate the</a>
<a name="ln1935"> * line number where we are now.</a>
<a name="ln1936"> * Used for error messages that include a line number.</a>
<a name="ln1937"> */</a>
<a name="ln1938">static linenr_T</a>
<a name="ln1939">readfile_linenr(</a>
<a name="ln1940">    linenr_T linecnt,         // line count before reading more bytes</a>
<a name="ln1941">    char_u *p,                // start of more bytes read</a>
<a name="ln1942">    char_u *endp              // end of more bytes read</a>
<a name="ln1943">)</a>
<a name="ln1944">{</a>
<a name="ln1945">  char_u      *s;</a>
<a name="ln1946">  linenr_T lnum;</a>
<a name="ln1947"> </a>
<a name="ln1948">  lnum = curbuf-&gt;b_ml.ml_line_count - linecnt + 1;</a>
<a name="ln1949">  for (s = p; s &lt; endp; ++s)</a>
<a name="ln1950">    if (*s == '\n')</a>
<a name="ln1951">      ++lnum;</a>
<a name="ln1952">  return lnum;</a>
<a name="ln1953">}</a>
<a name="ln1954"> </a>
<a name="ln1955">/*</a>
<a name="ln1956"> * Fill &quot;*eap&quot; to force the 'fileencoding', 'fileformat' and 'binary to be</a>
<a name="ln1957"> * equal to the buffer &quot;buf&quot;.  Used for calling readfile().</a>
<a name="ln1958"> */</a>
<a name="ln1959">void prep_exarg(exarg_T *eap, const buf_T *buf)</a>
<a name="ln1960">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1961">{</a>
<a name="ln1962">  const size_t cmd_len = 15 + STRLEN(buf-&gt;b_p_fenc);</a>
<a name="ln1963">  eap-&gt;cmd = xmalloc(cmd_len);</a>
<a name="ln1964"> </a>
<a name="ln1965">  snprintf((char *)eap-&gt;cmd, cmd_len, &quot;e ++enc=%s&quot;, buf-&gt;b_p_fenc);</a>
<a name="ln1966">  eap-&gt;force_enc = 8;</a>
<a name="ln1967">  eap-&gt;bad_char = buf-&gt;b_bad_char;</a>
<a name="ln1968">  eap-&gt;force_ff = *buf-&gt;b_p_ff;</a>
<a name="ln1969"> </a>
<a name="ln1970">  eap-&gt;force_bin = buf-&gt;b_p_bin ? FORCE_BIN : FORCE_NOBIN;</a>
<a name="ln1971">  eap-&gt;read_edit = FALSE;</a>
<a name="ln1972">  eap-&gt;forceit = FALSE;</a>
<a name="ln1973">}</a>
<a name="ln1974"> </a>
<a name="ln1975">/*</a>
<a name="ln1976"> * Set default or forced 'fileformat' and 'binary'.</a>
<a name="ln1977"> */</a>
<a name="ln1978">void set_file_options(int set_options, exarg_T *eap)</a>
<a name="ln1979">{</a>
<a name="ln1980">  /* set default 'fileformat' */</a>
<a name="ln1981">  if (set_options) {</a>
<a name="ln1982">    if (eap != NULL &amp;&amp; eap-&gt;force_ff != 0)</a>
<a name="ln1983">      set_fileformat(get_fileformat_force(curbuf, eap), OPT_LOCAL);</a>
<a name="ln1984">    else if (*p_ffs != NUL)</a>
<a name="ln1985">      set_fileformat(default_fileformat(), OPT_LOCAL);</a>
<a name="ln1986">  }</a>
<a name="ln1987"> </a>
<a name="ln1988">  /* set or reset 'binary' */</a>
<a name="ln1989">  if (eap != NULL &amp;&amp; eap-&gt;force_bin != 0) {</a>
<a name="ln1990">    int oldval = curbuf-&gt;b_p_bin;</a>
<a name="ln1991"> </a>
<a name="ln1992">    curbuf-&gt;b_p_bin = (eap-&gt;force_bin == FORCE_BIN);</a>
<a name="ln1993">    set_options_bin(oldval, curbuf-&gt;b_p_bin, OPT_LOCAL);</a>
<a name="ln1994">  }</a>
<a name="ln1995">}</a>
<a name="ln1996"> </a>
<a name="ln1997">/*</a>
<a name="ln1998"> * Set forced 'fileencoding'.</a>
<a name="ln1999"> */</a>
<a name="ln2000">void set_forced_fenc(exarg_T *eap)</a>
<a name="ln2001">{</a>
<a name="ln2002">  if (eap-&gt;force_enc != 0) {</a>
<a name="ln2003">    char_u *fenc = enc_canonize(eap-&gt;cmd + eap-&gt;force_enc);</a>
<a name="ln2004">    set_string_option_direct(&quot;fenc&quot;, -1, fenc, OPT_FREE|OPT_LOCAL, 0);</a>
<a name="ln2005">    xfree(fenc);</a>
<a name="ln2006">  }</a>
<a name="ln2007">}</a>
<a name="ln2008"> </a>
<a name="ln2009">// Find next fileencoding to use from 'fileencodings'.</a>
<a name="ln2010">// &quot;pp&quot; points to fenc_next.  It's advanced to the next item.</a>
<a name="ln2011">// When there are no more items, an empty string is returned and *pp is set to</a>
<a name="ln2012">// NULL.</a>
<a name="ln2013">// When *pp is not set to NULL, the result is in allocated memory and &quot;alloced&quot;</a>
<a name="ln2014">// is set to true.</a>
<a name="ln2015">static char_u *next_fenc(char_u **pp, bool *alloced)</a>
<a name="ln2016">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET</a>
<a name="ln2017">{</a>
<a name="ln2018">  char_u      *p;</a>
<a name="ln2019">  char_u      *r;</a>
<a name="ln2020"> </a>
<a name="ln2021">  *alloced = false;</a>
<a name="ln2022">  if (**pp == NUL) {</a>
<a name="ln2023">    *pp = NULL;</a>
<a name="ln2024">    return (char_u *)&quot;&quot;;</a>
<a name="ln2025">  }</a>
<a name="ln2026">  p = vim_strchr(*pp, ',');</a>
<a name="ln2027">  if (p == NULL) {</a>
<a name="ln2028">    r = enc_canonize(*pp);</a>
<a name="ln2029">    *pp += STRLEN(*pp);</a>
<a name="ln2030">  } else {</a>
<a name="ln2031">    r = vim_strnsave(*pp, p - *pp);</a>
<a name="ln2032">    *pp = p + 1;</a>
<a name="ln2033">    p = enc_canonize(r);</a>
<a name="ln2034">    xfree(r);</a>
<a name="ln2035">    r = p;</a>
<a name="ln2036">  }</a>
<a name="ln2037">  *alloced = true;</a>
<a name="ln2038">  return r;</a>
<a name="ln2039">}</a>
<a name="ln2040"> </a>
<a name="ln2041">/*</a>
<a name="ln2042"> * Convert a file with the 'charconvert' expression.</a>
<a name="ln2043"> * This closes the file which is to be read, converts it and opens the</a>
<a name="ln2044"> * resulting file for reading.</a>
<a name="ln2045"> * Returns name of the resulting converted file (the caller should delete it</a>
<a name="ln2046"> * after reading it).</a>
<a name="ln2047"> * Returns NULL if the conversion failed (&quot;*fdp&quot; is not set) .</a>
<a name="ln2048"> */</a>
<a name="ln2049">static char_u *</a>
<a name="ln2050">readfile_charconvert (</a>
<a name="ln2051">    char_u *fname,             /* name of input file */</a>
<a name="ln2052">    char_u *fenc,              /* converted from */</a>
<a name="ln2053">    int *fdp               /* in/out: file descriptor of file */</a>
<a name="ln2054">)</a>
<a name="ln2055">{</a>
<a name="ln2056">  char_u      *tmpname;</a>
<a name="ln2057">  char_u      *errmsg = NULL;</a>
<a name="ln2058"> </a>
<a name="ln2059">  tmpname = vim_tempname();</a>
<a name="ln2060">  if (tmpname == NULL)</a>
<a name="ln2061">    errmsg = (char_u *)_(&quot;Can't find temp file for conversion&quot;);</a>
<a name="ln2062">  else {</a>
<a name="ln2063">    close(*fdp);                /* close the input file, ignore errors */</a>
<a name="ln2064">    *fdp = -1;</a>
<a name="ln2065">    if (eval_charconvert((char *)fenc, &quot;utf-8&quot;,</a>
<a name="ln2066">                         (char *)fname, (char *)tmpname) == FAIL) {</a>
<a name="ln2067">      errmsg = (char_u *)_(&quot;Conversion with 'charconvert' failed&quot;);</a>
<a name="ln2068">    }</a>
<a name="ln2069">    if (errmsg == NULL &amp;&amp; (*fdp = os_open((char *)tmpname, O_RDONLY, 0)) &lt; 0) {</a>
<a name="ln2070">      errmsg = (char_u *)_(&quot;can't read output of 'charconvert'&quot;);</a>
<a name="ln2071">    }</a>
<a name="ln2072">  }</a>
<a name="ln2073"> </a>
<a name="ln2074">  if (errmsg != NULL) {</a>
<a name="ln2075">    /* Don't use emsg(), it breaks mappings, the retry with</a>
<a name="ln2076">     * another type of conversion might still work. */</a>
<a name="ln2077">    MSG(errmsg);</a>
<a name="ln2078">    if (tmpname != NULL) {</a>
<a name="ln2079">      os_remove((char *)tmpname);  // delete converted file</a>
<a name="ln2080">      XFREE_CLEAR(tmpname);</a>
<a name="ln2081">    }</a>
<a name="ln2082">  }</a>
<a name="ln2083"> </a>
<a name="ln2084">  /* If the input file is closed, open it (caller should check for error). */</a>
<a name="ln2085">  if (*fdp &lt; 0) {</a>
<a name="ln2086">    *fdp = os_open((char *)fname, O_RDONLY, 0);</a>
<a name="ln2087">  }</a>
<a name="ln2088"> </a>
<a name="ln2089">  return tmpname;</a>
<a name="ln2090">}</a>
<a name="ln2091"> </a>
<a name="ln2092"> </a>
<a name="ln2093">/*</a>
<a name="ln2094"> * Read marks for the current buffer from the ShaDa file, when we support</a>
<a name="ln2095"> * buffer marks and the buffer has a name.</a>
<a name="ln2096"> */</a>
<a name="ln2097">static void check_marks_read(void)</a>
<a name="ln2098">{</a>
<a name="ln2099">  if (!curbuf-&gt;b_marks_read &amp;&amp; get_shada_parameter('\'') &gt; 0</a>
<a name="ln2100">      &amp;&amp; curbuf-&gt;b_ffname != NULL) {</a>
<a name="ln2101">    shada_read_marks();</a>
<a name="ln2102">  }</a>
<a name="ln2103"> </a>
<a name="ln2104">  /* Always set b_marks_read; needed when 'shada' is changed to include</a>
<a name="ln2105">   * the ' parameter after opening a buffer. */</a>
<a name="ln2106">  curbuf-&gt;b_marks_read = true;</a>
<a name="ln2107">}</a>
<a name="ln2108"> </a>
<a name="ln2109">char *new_file_message(void)</a>
<a name="ln2110">{</a>
<a name="ln2111">  return shortmess(SHM_NEW) ? _(&quot;[New]&quot;) : _(&quot;[New File]&quot;);</a>
<a name="ln2112">}</a>
<a name="ln2113"> </a>
<a name="ln2114">/*</a>
<a name="ln2115"> * buf_write() - write to file &quot;fname&quot; lines &quot;start&quot; through &quot;end&quot;</a>
<a name="ln2116"> *</a>
<a name="ln2117"> * We do our own buffering here because fwrite() is so slow.</a>
<a name="ln2118"> *</a>
<a name="ln2119"> * If &quot;forceit&quot; is true, we don't care for errors when attempting backups.</a>
<a name="ln2120"> * In case of an error everything possible is done to restore the original</a>
<a name="ln2121"> * file.  But when &quot;forceit&quot; is TRUE, we risk losing it.</a>
<a name="ln2122"> *</a>
<a name="ln2123"> * When &quot;reset_changed&quot; is TRUE and &quot;append&quot; == FALSE and &quot;start&quot; == 1 and</a>
<a name="ln2124"> * &quot;end&quot; == curbuf-&gt;b_ml.ml_line_count, reset curbuf-&gt;b_changed.</a>
<a name="ln2125"> *</a>
<a name="ln2126"> * This function must NOT use NameBuff (because it's called by autowrite()).</a>
<a name="ln2127"> *</a>
<a name="ln2128"> * return FAIL for failure, OK otherwise</a>
<a name="ln2129"> */</a>
<a name="ln2130">int</a>
<a name="ln2131">buf_write(</a>
<a name="ln2132">    buf_T *buf,</a>
<a name="ln2133">    char_u *fname,</a>
<a name="ln2134">    char_u *sfname,</a>
<a name="ln2135">    linenr_T start,</a>
<a name="ln2136">    linenr_T end,</a>
<a name="ln2137">    exarg_T *eap,                   /* for forced 'ff' and 'fenc', can be</a>
<a name="ln2138">                                           NULL! */</a>
<a name="ln2139">    int append,                             /* append to the file */</a>
<a name="ln2140">    int forceit,</a>
<a name="ln2141">    int reset_changed,</a>
<a name="ln2142">    int filtering</a>
<a name="ln2143">)</a>
<a name="ln2144">{</a>
<a name="ln2145">  int fd;</a>
<a name="ln2146">  char_u          *backup = NULL;</a>
<a name="ln2147">  int backup_copy = FALSE;               /* copy the original file? */</a>
<a name="ln2148">  int dobackup;</a>
<a name="ln2149">  char_u          *ffname;</a>
<a name="ln2150">  char_u          *wfname = NULL;       /* name of file to write to */</a>
<a name="ln2151">  char_u          *s;</a>
<a name="ln2152">  char_u          *ptr;</a>
<a name="ln2153">  char_u c;</a>
<a name="ln2154">  int len;</a>
<a name="ln2155">  linenr_T lnum;</a>
<a name="ln2156">  long nchars;</a>
<a name="ln2157">#define SET_ERRMSG_NUM(num, msg) \</a>
<a name="ln2158">  errnum = num, errmsg = msg, errmsgarg = 0</a>
<a name="ln2159">#define SET_ERRMSG_ARG(msg, error) \</a>
<a name="ln2160">  errnum = NULL, errmsg = msg, errmsgarg = error</a>
<a name="ln2161">#define SET_ERRMSG(msg) \</a>
<a name="ln2162">  errnum = NULL, errmsg = msg, errmsgarg = 0</a>
<a name="ln2163">  const char *errnum = NULL;</a>
<a name="ln2164">  char *errmsg = NULL;</a>
<a name="ln2165">  int errmsgarg = 0;</a>
<a name="ln2166">  bool errmsg_allocated = false;</a>
<a name="ln2167">  char_u          *buffer;</a>
<a name="ln2168">  char_u smallbuf[SMBUFSIZE];</a>
<a name="ln2169">  char_u          *backup_ext;</a>
<a name="ln2170">  int bufsize;</a>
<a name="ln2171">  long perm;                                // file permissions</a>
<a name="ln2172">  int retval = OK;</a>
<a name="ln2173">  int newfile = false;                      // TRUE if file doesn't exist yet</a>
<a name="ln2174">  int msg_save = msg_scroll;</a>
<a name="ln2175">  int overwriting;                          // TRUE if writing over original</a>
<a name="ln2176">  int no_eol = false;                       // no end-of-line written</a>
<a name="ln2177">  int device = false;                       // writing to a device</a>
<a name="ln2178">  int prev_got_int = got_int;</a>
<a name="ln2179">  int checking_conversion;</a>
<a name="ln2180">  bool file_readonly = false;               // overwritten file is read-only</a>
<a name="ln2181">  static char     *err_readonly =</a>
<a name="ln2182">    &quot;is read-only (cannot override: \&quot;W\&quot; in 'cpoptions')&quot;;</a>
<a name="ln2183">#if defined(UNIX)</a>
<a name="ln2184">  int made_writable = FALSE;                /* 'w' bit has been set */</a>
<a name="ln2185">#endif</a>
<a name="ln2186">  /* writing everything */</a>
<a name="ln2187">  int whole = (start == 1 &amp;&amp; end == buf-&gt;b_ml.ml_line_count);</a>
<a name="ln2188">  linenr_T old_line_count = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2189">  int fileformat;</a>
<a name="ln2190">  int write_bin;</a>
<a name="ln2191">  struct bw_info write_info;            /* info for buf_write_bytes() */</a>
<a name="ln2192">  int converted = FALSE;</a>
<a name="ln2193">  int notconverted = FALSE;</a>
<a name="ln2194">  char_u          *fenc;                /* effective 'fileencoding' */</a>
<a name="ln2195">  char_u          *fenc_tofree = NULL;   /* allocated &quot;fenc&quot; */</a>
<a name="ln2196">#ifdef HAS_BW_FLAGS</a>
<a name="ln2197">  int wb_flags = 0;</a>
<a name="ln2198">#endif</a>
<a name="ln2199">#ifdef HAVE_ACL</a>
<a name="ln2200">  vim_acl_T acl = NULL;                 /* ACL copied from original file to</a>
<a name="ln2201">                                           backup or new file */</a>
<a name="ln2202">#endif</a>
<a name="ln2203">  int write_undo_file = FALSE;</a>
<a name="ln2204">  context_sha256_T sha_ctx;</a>
<a name="ln2205">  unsigned int bkc = get_bkc_value(buf);</a>
<a name="ln2206"> </a>
<a name="ln2207">  if (fname == NULL || *fname == NUL)   /* safety check */</a>
<a name="ln2208">    return FAIL;</a>
<a name="ln2209">  if (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln2210">    /* This can happen during startup when there is a stray &quot;w&quot; in the</a>
<a name="ln2211">     * vimrc file. */</a>
<a name="ln2212">    EMSG(_(e_emptybuf));</a>
<a name="ln2213">    return FAIL;</a>
<a name="ln2214">  }</a>
<a name="ln2215"> </a>
<a name="ln2216">  /*</a>
<a name="ln2217">   * Disallow writing from .exrc and .vimrc in current directory for</a>
<a name="ln2218">   * security reasons.</a>
<a name="ln2219">   */</a>
<a name="ln2220">  if (check_secure())</a>
<a name="ln2221">    return FAIL;</a>
<a name="ln2222"> </a>
<a name="ln2223">  /* Avoid a crash for a long name. */</a>
<a name="ln2224">  if (STRLEN(fname) &gt;= MAXPATHL) {</a>
<a name="ln2225">    EMSG(_(e_longname));</a>
<a name="ln2226">    return FAIL;</a>
<a name="ln2227">  }</a>
<a name="ln2228"> </a>
<a name="ln2229">  /* must init bw_conv_buf and bw_iconv_fd before jumping to &quot;fail&quot; */</a>
<a name="ln2230">  write_info.bw_conv_buf = NULL;</a>
<a name="ln2231">  write_info.bw_conv_error = FALSE;</a>
<a name="ln2232">  write_info.bw_conv_error_lnum = 0;</a>
<a name="ln2233">  write_info.bw_restlen = 0;</a>
<a name="ln2234"># ifdef HAVE_ICONV</a>
<a name="ln2235">  write_info.bw_iconv_fd = (iconv_t)-1;</a>
<a name="ln2236"># endif</a>
<a name="ln2237"> </a>
<a name="ln2238">  /* After writing a file changedtick changes but we don't want to display</a>
<a name="ln2239">   * the line. */</a>
<a name="ln2240">  ex_no_reprint = TRUE;</a>
<a name="ln2241"> </a>
<a name="ln2242">  /*</a>
<a name="ln2243">   * If there is no file name yet, use the one for the written file.</a>
<a name="ln2244">   * BF_NOTEDITED is set to reflect this (in case the write fails).</a>
<a name="ln2245">   * Don't do this when the write is for a filter command.</a>
<a name="ln2246">   * Don't do this when appending.</a>
<a name="ln2247">   * Only do this when 'cpoptions' contains the 'F' flag.</a>
<a name="ln2248">   */</a>
<a name="ln2249">  if (buf-&gt;b_ffname == NULL</a>
<a name="ln2250">      &amp;&amp; reset_changed</a>
<a name="ln2251">      &amp;&amp; whole</a>
<a name="ln2252">      &amp;&amp; buf == curbuf</a>
<a name="ln2253">      &amp;&amp; !bt_nofile(buf)</a>
<a name="ln2254">      &amp;&amp; !filtering</a>
<a name="ln2255">      &amp;&amp; (!append || vim_strchr(p_cpo, CPO_FNAMEAPP) != NULL)</a>
<a name="ln2256">      &amp;&amp; vim_strchr(p_cpo, CPO_FNAMEW) != NULL) {</a>
<a name="ln2257">    if (set_rw_fname(fname, sfname) == FAIL)</a>
<a name="ln2258">      return FAIL;</a>
<a name="ln2259">    buf = curbuf;           /* just in case autocmds made &quot;buf&quot; invalid */</a>
<a name="ln2260">  }</a>
<a name="ln2261"> </a>
<a name="ln2262">  if (sfname == NULL)</a>
<a name="ln2263">    sfname = fname;</a>
<a name="ln2264"> </a>
<a name="ln2265">  // For Unix: Use the short file name whenever possible.</a>
<a name="ln2266">  // Avoids problems with networks and when directory names are changed.</a>
<a name="ln2267">  // Don't do this for Windows, a &quot;cd&quot; in a sub-shell may have moved us to</a>
<a name="ln2268">  // another directory, which we don't detect.</a>
<a name="ln2269">  ffname = fname;                           // remember full fname</a>
<a name="ln2270">#ifdef UNIX</a>
<a name="ln2271">  fname = sfname;</a>
<a name="ln2272">#endif</a>
<a name="ln2273"> </a>
<a name="ln2274">  if (buf-&gt;b_ffname != NULL &amp;&amp; fnamecmp(ffname, buf-&gt;b_ffname) == 0)</a>
<a name="ln2275">    overwriting = TRUE;</a>
<a name="ln2276">  else</a>
<a name="ln2277">    overwriting = FALSE;</a>
<a name="ln2278"> </a>
<a name="ln2279">  ++no_wait_return;                 /* don't wait for return yet */</a>
<a name="ln2280"> </a>
<a name="ln2281">  /*</a>
<a name="ln2282">   * Set '[ and '] marks to the lines to be written.</a>
<a name="ln2283">   */</a>
<a name="ln2284">  buf-&gt;b_op_start.lnum = start;</a>
<a name="ln2285">  buf-&gt;b_op_start.col = 0;</a>
<a name="ln2286">  buf-&gt;b_op_end.lnum = end;</a>
<a name="ln2287">  buf-&gt;b_op_end.col = 0;</a>
<a name="ln2288"> </a>
<a name="ln2289">  {</a>
<a name="ln2290">    aco_save_T aco;</a>
<a name="ln2291">    int buf_ffname = FALSE;</a>
<a name="ln2292">    int buf_sfname = FALSE;</a>
<a name="ln2293">    int buf_fname_f = FALSE;</a>
<a name="ln2294">    int buf_fname_s = FALSE;</a>
<a name="ln2295">    int did_cmd = FALSE;</a>
<a name="ln2296">    int nofile_err = FALSE;</a>
<a name="ln2297">    int empty_memline = (buf-&gt;b_ml.ml_mfp == NULL);</a>
<a name="ln2298">    bufref_T bufref;</a>
<a name="ln2299"> </a>
<a name="ln2300">    /*</a>
<a name="ln2301">     * Apply PRE autocommands.</a>
<a name="ln2302">     * Set curbuf to the buffer to be written.</a>
<a name="ln2303">     * Careful: The autocommands may call buf_write() recursively!</a>
<a name="ln2304">     */</a>
<a name="ln2305">    if (ffname == buf-&gt;b_ffname)</a>
<a name="ln2306">      buf_ffname = TRUE;</a>
<a name="ln2307">    if (sfname == buf-&gt;b_sfname)</a>
<a name="ln2308">      buf_sfname = TRUE;</a>
<a name="ln2309">    if (fname == buf-&gt;b_ffname)</a>
<a name="ln2310">      buf_fname_f = TRUE;</a>
<a name="ln2311">    if (fname == buf-&gt;b_sfname)</a>
<a name="ln2312">      buf_fname_s = TRUE;</a>
<a name="ln2313"> </a>
<a name="ln2314">    // Set curwin/curbuf to buf and save a few things.</a>
<a name="ln2315">    aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln2316">    set_bufref(&amp;bufref, buf);</a>
<a name="ln2317"> </a>
<a name="ln2318">    if (append) {</a>
<a name="ln2319">      if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEAPPENDCMD,</a>
<a name="ln2320">                sfname, sfname, FALSE, curbuf, eap))) {</a>
<a name="ln2321">        if (overwriting &amp;&amp; bt_nofile(curbuf))</a>
<a name="ln2322">          nofile_err = TRUE;</a>
<a name="ln2323">        else</a>
<a name="ln2324">          apply_autocmds_exarg(EVENT_FILEAPPENDPRE,</a>
<a name="ln2325">              sfname, sfname, FALSE, curbuf, eap);</a>
<a name="ln2326">      }</a>
<a name="ln2327">    } else if (filtering) {</a>
<a name="ln2328">      apply_autocmds_exarg(EVENT_FILTERWRITEPRE,</a>
<a name="ln2329">          NULL, sfname, FALSE, curbuf, eap);</a>
<a name="ln2330">    } else if (reset_changed &amp;&amp; whole)   {</a>
<a name="ln2331">      int was_changed = curbufIsChanged();</a>
<a name="ln2332"> </a>
<a name="ln2333">      did_cmd = apply_autocmds_exarg(EVENT_BUFWRITECMD,</a>
<a name="ln2334">          sfname, sfname, FALSE, curbuf, eap);</a>
<a name="ln2335">      if (did_cmd) {</a>
<a name="ln2336">        if (was_changed &amp;&amp; !curbufIsChanged()) {</a>
<a name="ln2337">          /* Written everything correctly and BufWriteCmd has reset</a>
<a name="ln2338">           * 'modified': Correct the undo information so that an</a>
<a name="ln2339">           * undo now sets 'modified'. */</a>
<a name="ln2340">          u_unchanged(curbuf);</a>
<a name="ln2341">          u_update_save_nr(curbuf);</a>
<a name="ln2342">        }</a>
<a name="ln2343">      } else {</a>
<a name="ln2344">        if (overwriting &amp;&amp; bt_nofile(curbuf))</a>
<a name="ln2345">          nofile_err = TRUE;</a>
<a name="ln2346">        else</a>
<a name="ln2347">          apply_autocmds_exarg(EVENT_BUFWRITEPRE,</a>
<a name="ln2348">              sfname, sfname, FALSE, curbuf, eap);</a>
<a name="ln2349">      }</a>
<a name="ln2350">    } else {</a>
<a name="ln2351">      if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEWRITECMD,</a>
<a name="ln2352">                sfname, sfname, FALSE, curbuf, eap))) {</a>
<a name="ln2353">        if (overwriting &amp;&amp; bt_nofile(curbuf))</a>
<a name="ln2354">          nofile_err = TRUE;</a>
<a name="ln2355">        else</a>
<a name="ln2356">          apply_autocmds_exarg(EVENT_FILEWRITEPRE,</a>
<a name="ln2357">              sfname, sfname, FALSE, curbuf, eap);</a>
<a name="ln2358">      }</a>
<a name="ln2359">    }</a>
<a name="ln2360"> </a>
<a name="ln2361">    /* restore curwin/curbuf and a few other things */</a>
<a name="ln2362">    aucmd_restbuf(&amp;aco);</a>
<a name="ln2363"> </a>
<a name="ln2364">    // In three situations we return here and don't write the file:</a>
<a name="ln2365">    // 1. the autocommands deleted or unloaded the buffer.</a>
<a name="ln2366">    // 2. The autocommands abort script processing.</a>
<a name="ln2367">    // 3. If one of the &quot;Cmd&quot; autocommands was executed.</a>
<a name="ln2368">    if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln2369">      buf = NULL;</a>
<a name="ln2370">    }</a>
<a name="ln2371">    if (buf == NULL || (buf-&gt;b_ml.ml_mfp == NULL &amp;&amp; !empty_memline)</a>
<a name="ln2372">        || did_cmd || nofile_err</a>
<a name="ln2373">        || aborting()</a>
<a name="ln2374">        ) {</a>
<a name="ln2375">      --no_wait_return;</a>
<a name="ln2376">      msg_scroll = msg_save;</a>
<a name="ln2377">      if (nofile_err)</a>
<a name="ln2378">        EMSG(_(&quot;E676: No matching autocommands for acwrite buffer&quot;));</a>
<a name="ln2379"> </a>
<a name="ln2380">      if (nofile_err</a>
<a name="ln2381">          || aborting()</a>
<a name="ln2382">          )</a>
<a name="ln2383">        /* An aborting error, interrupt or exception in the</a>
<a name="ln2384">         * autocommands. */</a>
<a name="ln2385">        return FAIL;</a>
<a name="ln2386">      if (did_cmd) {</a>
<a name="ln2387">        if (buf == NULL)</a>
<a name="ln2388">          /* The buffer was deleted.  We assume it was written</a>
<a name="ln2389">           * (can't retry anyway). */</a>
<a name="ln2390">          return OK;</a>
<a name="ln2391">        if (overwriting) {</a>
<a name="ln2392">          /* Assume the buffer was written, update the timestamp. */</a>
<a name="ln2393">          ml_timestamp(buf);</a>
<a name="ln2394">          if (append)</a>
<a name="ln2395">            buf-&gt;b_flags &amp;= ~BF_NEW;</a>
<a name="ln2396">          else</a>
<a name="ln2397">            buf-&gt;b_flags &amp;= ~BF_WRITE_MASK;</a>
<a name="ln2398">        }</a>
<a name="ln2399">        if (reset_changed &amp;&amp; buf-&gt;b_changed &amp;&amp; !append</a>
<a name="ln2400">            &amp;&amp; (overwriting || vim_strchr(p_cpo, CPO_PLUS) != NULL))</a>
<a name="ln2401">          /* Buffer still changed, the autocommands didn't work</a>
<a name="ln2402">           * properly. */</a>
<a name="ln2403">          return FAIL;</a>
<a name="ln2404">        return OK;</a>
<a name="ln2405">      }</a>
<a name="ln2406">      if (!aborting())</a>
<a name="ln2407">        EMSG(_(&quot;E203: Autocommands deleted or unloaded buffer to be written&quot;));</a>
<a name="ln2408">      return FAIL;</a>
<a name="ln2409">    }</a>
<a name="ln2410"> </a>
<a name="ln2411">    /*</a>
<a name="ln2412">     * The autocommands may have changed the number of lines in the file.</a>
<a name="ln2413">     * When writing the whole file, adjust the end.</a>
<a name="ln2414">     * When writing part of the file, assume that the autocommands only</a>
<a name="ln2415">     * changed the number of lines that are to be written (tricky!).</a>
<a name="ln2416">     */</a>
<a name="ln2417">    if (buf-&gt;b_ml.ml_line_count != old_line_count) {</a>
<a name="ln2418">      if (whole)                                                /* write all */</a>
<a name="ln2419">        end = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2420">      else if (buf-&gt;b_ml.ml_line_count &gt; old_line_count)        /* more lines */</a>
<a name="ln2421">        end += buf-&gt;b_ml.ml_line_count - old_line_count;</a>
<a name="ln2422">      else {                                                    /* less lines */</a>
<a name="ln2423">        end -= old_line_count - buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2424">        if (end &lt; start) {</a>
<a name="ln2425">          --no_wait_return;</a>
<a name="ln2426">          msg_scroll = msg_save;</a>
<a name="ln2427">          EMSG(_(&quot;E204: Autocommand changed number of lines in unexpected way&quot;));</a>
<a name="ln2428">          return FAIL;</a>
<a name="ln2429">        }</a>
<a name="ln2430">      }</a>
<a name="ln2431">    }</a>
<a name="ln2432"> </a>
<a name="ln2433">    /*</a>
<a name="ln2434">     * The autocommands may have changed the name of the buffer, which may</a>
<a name="ln2435">     * be kept in fname, ffname and sfname.</a>
<a name="ln2436">     */</a>
<a name="ln2437">    if (buf_ffname)</a>
<a name="ln2438">      ffname = buf-&gt;b_ffname;</a>
<a name="ln2439">    if (buf_sfname)</a>
<a name="ln2440">      sfname = buf-&gt;b_sfname;</a>
<a name="ln2441">    if (buf_fname_f)</a>
<a name="ln2442">      fname = buf-&gt;b_ffname;</a>
<a name="ln2443">    if (buf_fname_s)</a>
<a name="ln2444">      fname = buf-&gt;b_sfname;</a>
<a name="ln2445">  }</a>
<a name="ln2446"> </a>
<a name="ln2447"> </a>
<a name="ln2448">  if (shortmess(SHM_OVER) &amp;&amp; !exiting)</a>
<a name="ln2449">    msg_scroll = FALSE;             /* overwrite previous file message */</a>
<a name="ln2450">  else</a>
<a name="ln2451">    msg_scroll = TRUE;              /* don't overwrite previous file message */</a>
<a name="ln2452">  if (!filtering)</a>
<a name="ln2453">    filemess(buf,</a>
<a name="ln2454">#ifndef UNIX</a>
<a name="ln2455">        sfname,</a>
<a name="ln2456">#else</a>
<a name="ln2457">        fname,</a>
<a name="ln2458">#endif</a>
<a name="ln2459">        (char_u *)&quot;&quot;, 0);               /* show that we are busy */</a>
<a name="ln2460">  msg_scroll = FALSE;               /* always overwrite the file message now */</a>
<a name="ln2461"> </a>
<a name="ln2462">  buffer = verbose_try_malloc(BUFSIZE);</a>
<a name="ln2463">  // can't allocate big buffer, use small one (to be able to write when out of</a>
<a name="ln2464">  // memory)</a>
<a name="ln2465">  if (buffer == NULL) {</a>
<a name="ln2466">    buffer = smallbuf;</a>
<a name="ln2467">    bufsize = SMBUFSIZE;</a>
<a name="ln2468">  } else</a>
<a name="ln2469">    bufsize = BUFSIZE;</a>
<a name="ln2470"> </a>
<a name="ln2471">  /*</a>
<a name="ln2472">   * Get information about original file (if there is one).</a>
<a name="ln2473">   */</a>
<a name="ln2474">  FileInfo file_info_old;</a>
<a name="ln2475">#if defined(UNIX)</a>
<a name="ln2476">  perm = -1;</a>
<a name="ln2477">  if (!os_fileinfo((char *)fname, &amp;file_info_old)) {</a>
<a name="ln2478">    newfile = TRUE;</a>
<a name="ln2479">  } else {</a>
<a name="ln2480">    perm = file_info_old.stat.st_mode;</a>
<a name="ln2481">    if (!S_ISREG(file_info_old.stat.st_mode)) {             /* not a file */</a>
<a name="ln2482">      if (S_ISDIR(file_info_old.stat.st_mode)) {</a>
<a name="ln2483">        SET_ERRMSG_NUM(&quot;E502&quot;, _(&quot;is a directory&quot;));</a>
<a name="ln2484">        goto fail;</a>
<a name="ln2485">      }</a>
<a name="ln2486">      if (os_nodetype((char *)fname) != NODE_WRITABLE) {</a>
<a name="ln2487">        SET_ERRMSG_NUM(&quot;E503&quot;, _(&quot;is not a file or writable device&quot;));</a>
<a name="ln2488">        goto fail;</a>
<a name="ln2489">      }</a>
<a name="ln2490">      /* It's a device of some kind (or a fifo) which we can write to</a>
<a name="ln2491">       * but for which we can't make a backup. */</a>
<a name="ln2492">      device = TRUE;</a>
<a name="ln2493">      newfile = TRUE;</a>
<a name="ln2494">      perm = -1;</a>
<a name="ln2495">    }</a>
<a name="ln2496">  }</a>
<a name="ln2497">#else  // win32</a>
<a name="ln2498">  // Check for a writable device name.</a>
<a name="ln2499">  c = fname == NULL ? NODE_OTHER : os_nodetype((char *)fname);</a>
<a name="ln2500">  if (c == NODE_OTHER) {</a>
<a name="ln2501">    SET_ERRMSG_NUM(&quot;E503&quot;, _(&quot;is not a file or writable device&quot;));</a>
<a name="ln2502">    goto fail;</a>
<a name="ln2503">  }</a>
<a name="ln2504">  if (c == NODE_WRITABLE) {</a>
<a name="ln2505">    device = TRUE;</a>
<a name="ln2506">    newfile = TRUE;</a>
<a name="ln2507">    perm = -1;</a>
<a name="ln2508">  } else {</a>
<a name="ln2509">    perm = os_getperm((const char *)fname);</a>
<a name="ln2510">    if (perm &lt; 0) {</a>
<a name="ln2511">      newfile = true;</a>
<a name="ln2512">    } else if (os_isdir(fname)) {</a>
<a name="ln2513">      SET_ERRMSG_NUM(&quot;E502&quot;, _(&quot;is a directory&quot;));</a>
<a name="ln2514">      goto fail;</a>
<a name="ln2515">    }</a>
<a name="ln2516">    if (overwriting) {</a>
<a name="ln2517">      os_fileinfo((char *)fname, &amp;file_info_old);</a>
<a name="ln2518">    }</a>
<a name="ln2519">  }</a>
<a name="ln2520">#endif  // !UNIX</a>
<a name="ln2521"> </a>
<a name="ln2522">  if (!device &amp;&amp; !newfile) {</a>
<a name="ln2523">    /*</a>
<a name="ln2524">     * Check if the file is really writable (when renaming the file to</a>
<a name="ln2525">     * make a backup we won't discover it later).</a>
<a name="ln2526">     */</a>
<a name="ln2527">    file_readonly = !os_file_is_writable((char *)fname);</a>
<a name="ln2528"> </a>
<a name="ln2529">    if (!forceit &amp;&amp; file_readonly) {</a>
<a name="ln2530">      if (vim_strchr(p_cpo, CPO_FWRITE) != NULL) {</a>
<a name="ln2531">        SET_ERRMSG_NUM(&quot;E504&quot;, _(err_readonly));</a>
<a name="ln2532">      } else {</a>
<a name="ln2533">        SET_ERRMSG_NUM(&quot;E505&quot;, _(&quot;is read-only (add ! to override)&quot;));</a>
<a name="ln2534">      }</a>
<a name="ln2535">      goto fail;</a>
<a name="ln2536">    }</a>
<a name="ln2537"> </a>
<a name="ln2538">    /*</a>
<a name="ln2539">     * Check if the timestamp hasn't changed since reading the file.</a>
<a name="ln2540">     */</a>
<a name="ln2541">    if (overwriting) {</a>
<a name="ln2542">      retval = check_mtime(buf, &amp;file_info_old);</a>
<a name="ln2543">      if (retval == FAIL)</a>
<a name="ln2544">        goto fail;</a>
<a name="ln2545">    }</a>
<a name="ln2546">  }</a>
<a name="ln2547"> </a>
<a name="ln2548">#ifdef HAVE_ACL</a>
<a name="ln2549">  /*</a>
<a name="ln2550">   * For systems that support ACL: get the ACL from the original file.</a>
<a name="ln2551">   */</a>
<a name="ln2552">  if (!newfile)</a>
<a name="ln2553">    acl = mch_get_acl(fname);</a>
<a name="ln2554">#endif</a>
<a name="ln2555"> </a>
<a name="ln2556">  /*</a>
<a name="ln2557">   * If 'backupskip' is not empty, don't make a backup for some files.</a>
<a name="ln2558">   */</a>
<a name="ln2559">  dobackup = (p_wb || p_bk || *p_pm != NUL);</a>
<a name="ln2560">  if (dobackup &amp;&amp; *p_bsk != NUL &amp;&amp; match_file_list(p_bsk, sfname, ffname))</a>
<a name="ln2561">    dobackup = FALSE;</a>
<a name="ln2562"> </a>
<a name="ln2563">  /*</a>
<a name="ln2564">   * Save the value of got_int and reset it.  We don't want a previous</a>
<a name="ln2565">   * interruption cancel writing, only hitting CTRL-C while writing should</a>
<a name="ln2566">   * abort it.</a>
<a name="ln2567">   */</a>
<a name="ln2568">  prev_got_int = got_int;</a>
<a name="ln2569">  got_int = FALSE;</a>
<a name="ln2570"> </a>
<a name="ln2571">  /* Mark the buffer as 'being saved' to prevent changed buffer warnings */</a>
<a name="ln2572">  buf-&gt;b_saving = true;</a>
<a name="ln2573"> </a>
<a name="ln2574">  /*</a>
<a name="ln2575">   * If we are not appending or filtering, the file exists, and the</a>
<a name="ln2576">   * 'writebackup', 'backup' or 'patchmode' option is set, need a backup.</a>
<a name="ln2577">   * When 'patchmode' is set also make a backup when appending.</a>
<a name="ln2578">   *</a>
<a name="ln2579">   * Do not make any backup, if 'writebackup' and 'backup' are both switched</a>
<a name="ln2580">   * off.  This helps when editing large files on almost-full disks.</a>
<a name="ln2581">   */</a>
<a name="ln2582">  if (!(append &amp;&amp; *p_pm == NUL) &amp;&amp; !filtering &amp;&amp; perm &gt;= 0 &amp;&amp; dobackup) {</a>
<a name="ln2583">    FileInfo file_info;</a>
<a name="ln2584">    const bool no_prepend_dot = false;</a>
<a name="ln2585"> </a>
<a name="ln2586">    if ((bkc &amp; BKC_YES) || append) {       /* &quot;yes&quot; */</a>
<a name="ln2587">      backup_copy = TRUE;</a>
<a name="ln2588">    } else if ((bkc &amp; BKC_AUTO)) {          /* &quot;auto&quot; */</a>
<a name="ln2589">      int i;</a>
<a name="ln2590"> </a>
<a name="ln2591">      /*</a>
<a name="ln2592">       * Don't rename the file when:</a>
<a name="ln2593">       * - it's a hard link</a>
<a name="ln2594">       * - it's a symbolic link</a>
<a name="ln2595">       * - we don't have write permission in the directory</a>
<a name="ln2596">       */</a>
<a name="ln2597">      if (os_fileinfo_hardlinks(&amp;file_info_old) &gt; 1</a>
<a name="ln2598">          || !os_fileinfo_link((char *)fname, &amp;file_info)</a>
<a name="ln2599">          || !os_fileinfo_id_equal(&amp;file_info, &amp;file_info_old)) {</a>
<a name="ln2600">        backup_copy = TRUE;</a>
<a name="ln2601">      } else {</a>
<a name="ln2602">        /*</a>
<a name="ln2603">         * Check if we can create a file and set the owner/group to</a>
<a name="ln2604">         * the ones from the original file.</a>
<a name="ln2605">         * First find a file name that doesn't exist yet (use some</a>
<a name="ln2606">         * arbitrary numbers).</a>
<a name="ln2607">         */</a>
<a name="ln2608">        STRCPY(IObuff, fname);</a>
<a name="ln2609">        for (i = 4913;; i += 123) {</a>
<a name="ln2610">          sprintf((char *)path_tail(IObuff), &quot;%d&quot;, i);</a>
<a name="ln2611">          if (!os_fileinfo_link((char *)IObuff, &amp;file_info)) {</a>
<a name="ln2612">            break;</a>
<a name="ln2613">          }</a>
<a name="ln2614">        }</a>
<a name="ln2615">        fd = os_open((char *)IObuff,</a>
<a name="ln2616">            O_CREAT|O_WRONLY|O_EXCL|O_NOFOLLOW, perm);</a>
<a name="ln2617">        if (fd &lt; 0)             /* can't write in directory */</a>
<a name="ln2618">          backup_copy = TRUE;</a>
<a name="ln2619">        else {</a>
<a name="ln2620"># ifdef UNIX</a>
<a name="ln2621">          os_fchown(fd, file_info_old.stat.st_uid, file_info_old.stat.st_gid);</a>
<a name="ln2622">          if (!os_fileinfo((char *)IObuff, &amp;file_info)</a>
<a name="ln2623">              || file_info.stat.st_uid != file_info_old.stat.st_uid</a>
<a name="ln2624">              || file_info.stat.st_gid != file_info_old.stat.st_gid</a>
<a name="ln2625">              || (long)file_info.stat.st_mode != perm) {</a>
<a name="ln2626">            backup_copy = TRUE;</a>
<a name="ln2627">          }</a>
<a name="ln2628"># endif</a>
<a name="ln2629">          /* Close the file before removing it, on MS-Windows we</a>
<a name="ln2630">           * can't delete an open file. */</a>
<a name="ln2631">          close(fd);</a>
<a name="ln2632">          os_remove((char *)IObuff);</a>
<a name="ln2633">        }</a>
<a name="ln2634">      }</a>
<a name="ln2635">    }</a>
<a name="ln2636"> </a>
<a name="ln2637">    /*</a>
<a name="ln2638">     * Break symlinks and/or hardlinks if we've been asked to.</a>
<a name="ln2639">     */</a>
<a name="ln2640">    if ((bkc &amp; BKC_BREAKSYMLINK) || (bkc &amp; BKC_BREAKHARDLINK)) {</a>
<a name="ln2641"># ifdef UNIX</a>
<a name="ln2642">      bool file_info_link_ok = os_fileinfo_link((char *)fname, &amp;file_info);</a>
<a name="ln2643"> </a>
<a name="ln2644">      /* Symlinks. */</a>
<a name="ln2645">      if ((bkc &amp; BKC_BREAKSYMLINK)</a>
<a name="ln2646">          &amp;&amp; file_info_link_ok</a>
<a name="ln2647">          &amp;&amp; !os_fileinfo_id_equal(&amp;file_info, &amp;file_info_old)) {</a>
<a name="ln2648">        backup_copy = FALSE;</a>
<a name="ln2649">      }</a>
<a name="ln2650"> </a>
<a name="ln2651">      /* Hardlinks. */</a>
<a name="ln2652">      if ((bkc &amp; BKC_BREAKHARDLINK)</a>
<a name="ln2653">          &amp;&amp; os_fileinfo_hardlinks(&amp;file_info_old) &gt; 1</a>
<a name="ln2654">          &amp;&amp; (!file_info_link_ok</a>
<a name="ln2655">              || os_fileinfo_id_equal(&amp;file_info, &amp;file_info_old))) {</a>
<a name="ln2656">        backup_copy = FALSE;</a>
<a name="ln2657">      }</a>
<a name="ln2658"># endif</a>
<a name="ln2659">    }</a>
<a name="ln2660"> </a>
<a name="ln2661">    /* make sure we have a valid backup extension to use */</a>
<a name="ln2662">    if (*p_bex == NUL)</a>
<a name="ln2663">      backup_ext = (char_u *)&quot;.bak&quot;;</a>
<a name="ln2664">    else</a>
<a name="ln2665">      backup_ext = p_bex;</a>
<a name="ln2666"> </a>
<a name="ln2667">    if (backup_copy) {</a>
<a name="ln2668">      char_u *wp;</a>
<a name="ln2669">      int some_error = false;</a>
<a name="ln2670">      char_u      *dirp;</a>
<a name="ln2671">      char_u      *rootname;</a>
<a name="ln2672">      char_u      *p;</a>
<a name="ln2673"> </a>
<a name="ln2674">      /*</a>
<a name="ln2675">       * Try to make the backup in each directory in the 'bdir' option.</a>
<a name="ln2676">       *</a>
<a name="ln2677">       * Unix semantics has it, that we may have a writable file,</a>
<a name="ln2678">       * that cannot be recreated with a simple open(..., O_CREAT, ) e.g:</a>
<a name="ln2679">       *  - the directory is not writable,</a>
<a name="ln2680">       *  - the file may be a symbolic link,</a>
<a name="ln2681">       *  - the file may belong to another user/group, etc.</a>
<a name="ln2682">       *</a>
<a name="ln2683">       * For these reasons, the existing writable file must be truncated</a>
<a name="ln2684">       * and reused. Creation of a backup COPY will be attempted.</a>
<a name="ln2685">       */</a>
<a name="ln2686">      dirp = p_bdir;</a>
<a name="ln2687">      while (*dirp) {</a>
<a name="ln2688">        /*</a>
<a name="ln2689">         * Isolate one directory name, using an entry in 'bdir'.</a>
<a name="ln2690">         */</a>
<a name="ln2691">        (void)copy_option_part(&amp;dirp, IObuff, IOSIZE, &quot;,&quot;);</a>
<a name="ln2692">        p = IObuff + STRLEN(IObuff);</a>
<a name="ln2693">        if (after_pathsep((char *)IObuff, (char *)p) &amp;&amp; p[-1] == p[-2]) {</a>
<a name="ln2694">          // Ends with '//', Use Full path</a>
<a name="ln2695">          if ((p = (char_u *)make_percent_swname((char *)IObuff, (char *)fname))</a>
<a name="ln2696">              != NULL) {</a>
<a name="ln2697">            backup = (char_u *)modname((char *)p, (char *)backup_ext,</a>
<a name="ln2698">                                       no_prepend_dot);</a>
<a name="ln2699">            xfree(p);</a>
<a name="ln2700">          }</a>
<a name="ln2701">        }</a>
<a name="ln2702"> </a>
<a name="ln2703">        rootname = get_file_in_dir(fname, IObuff);</a>
<a name="ln2704">        if (rootname == NULL) {</a>
<a name="ln2705">          some_error = TRUE;                /* out of memory */</a>
<a name="ln2706">          goto nobackup;</a>
<a name="ln2707">        }</a>
<a name="ln2708"> </a>
<a name="ln2709">        FileInfo file_info_new;</a>
<a name="ln2710">        {</a>
<a name="ln2711">          //</a>
<a name="ln2712">          // Make the backup file name.</a>
<a name="ln2713">          //</a>
<a name="ln2714">          if (backup == NULL) {</a>
<a name="ln2715">            backup = (char_u *)modname((char *)rootname, (char *)backup_ext,</a>
<a name="ln2716">                                       no_prepend_dot);</a>
<a name="ln2717">          }</a>
<a name="ln2718"> </a>
<a name="ln2719">          if (backup == NULL) {</a>
<a name="ln2720">            xfree(rootname);</a>
<a name="ln2721">            some_error = TRUE;                          /* out of memory */</a>
<a name="ln2722">            goto nobackup;</a>
<a name="ln2723">          }</a>
<a name="ln2724"> </a>
<a name="ln2725">          /*</a>
<a name="ln2726">           * Check if backup file already exists.</a>
<a name="ln2727">           */</a>
<a name="ln2728">          if (os_fileinfo((char *)backup, &amp;file_info_new)) {</a>
<a name="ln2729">            if (os_fileinfo_id_equal(&amp;file_info_new, &amp;file_info_old)) {</a>
<a name="ln2730">              //</a>
<a name="ln2731">              // Backup file is same as original file.</a>
<a name="ln2732">              // May happen when modname() gave the same file back (e.g. silly</a>
<a name="ln2733">              // link). If we don't check here, we either ruin the file when</a>
<a name="ln2734">              // copying or erase it after writing.</a>
<a name="ln2735">              //</a>
<a name="ln2736">              XFREE_CLEAR(backup);              // no backup file to delete</a>
<a name="ln2737">            } else if (!p_bk) {</a>
<a name="ln2738">              // We are not going to keep the backup file, so don't</a>
<a name="ln2739">              // delete an existing one, and try to use another name instead.</a>
<a name="ln2740">              // Change one character, just before the extension.</a>
<a name="ln2741">              //</a>
<a name="ln2742">              wp = backup + STRLEN(backup) - 1 - STRLEN(backup_ext);</a>
<a name="ln2743">              if (wp &lt; backup) {                // empty file name ???</a>
<a name="ln2744">                wp = backup;</a>
<a name="ln2745">              }</a>
<a name="ln2746">              *wp = 'z';</a>
<a name="ln2747">              while (*wp &gt; 'a'</a>
<a name="ln2748">                     &amp;&amp; os_fileinfo((char *)backup, &amp;file_info_new)) {</a>
<a name="ln2749">                --*wp;</a>
<a name="ln2750">              }</a>
<a name="ln2751">              // They all exist??? Must be something wrong.</a>
<a name="ln2752">              if (*wp == 'a') {</a>
<a name="ln2753">                XFREE_CLEAR(backup);</a>
<a name="ln2754">              }</a>
<a name="ln2755">            }</a>
<a name="ln2756">          }</a>
<a name="ln2757">        }</a>
<a name="ln2758">        xfree(rootname);</a>
<a name="ln2759"> </a>
<a name="ln2760">        /*</a>
<a name="ln2761">         * Try to create the backup file</a>
<a name="ln2762">         */</a>
<a name="ln2763">        if (backup != NULL) {</a>
<a name="ln2764">          /* remove old backup, if present */</a>
<a name="ln2765">          os_remove((char *)backup);</a>
<a name="ln2766"> </a>
<a name="ln2767">          // set file protection same as original file, but</a>
<a name="ln2768">          // strip s-bit.</a>
<a name="ln2769">          (void)os_setperm((const char *)backup, perm &amp; 0777);</a>
<a name="ln2770"> </a>
<a name="ln2771">#ifdef UNIX</a>
<a name="ln2772">          //</a>
<a name="ln2773">          // Try to set the group of the backup same as the original file. If</a>
<a name="ln2774">          // this fails, set the protection bits for the group same as the</a>
<a name="ln2775">          // protection bits for others.</a>
<a name="ln2776">          //</a>
<a name="ln2777">          if (file_info_new.stat.st_gid != file_info_old.stat.st_gid</a>
<a name="ln2778">              &amp;&amp; os_chown((char *)backup, -1, file_info_old.stat.st_gid) != 0) {</a>
<a name="ln2779">            os_setperm((const char *)backup,</a>
<a name="ln2780">                       (perm &amp; 0707) | ((perm &amp; 07) &lt;&lt; 3));</a>
<a name="ln2781">          }</a>
<a name="ln2782">#endif</a>
<a name="ln2783"> </a>
<a name="ln2784">          // copy the file</a>
<a name="ln2785">          if (os_copy((char *)fname, (char *)backup, UV_FS_COPYFILE_FICLONE)</a>
<a name="ln2786">              != 0) {</a>
<a name="ln2787">            SET_ERRMSG(_(&quot;E506: Can't write to backup file &quot;</a>
<a name="ln2788">                         &quot;(add ! to override)&quot;));</a>
<a name="ln2789">          }</a>
<a name="ln2790"> </a>
<a name="ln2791">#ifdef UNIX</a>
<a name="ln2792">          os_file_settime((char *)backup,</a>
<a name="ln2793">                          file_info_old.stat.st_atim.tv_sec,</a>
<a name="ln2794">                          file_info_old.stat.st_mtim.tv_sec);</a>
<a name="ln2795">#endif</a>
<a name="ln2796">#ifdef HAVE_ACL</a>
<a name="ln2797">          mch_set_acl(backup, acl);</a>
<a name="ln2798">#endif</a>
<a name="ln2799">          break;</a>
<a name="ln2800">        }</a>
<a name="ln2801">      }</a>
<a name="ln2802"> </a>
<a name="ln2803">nobackup:</a>
<a name="ln2804">      if (backup == NULL &amp;&amp; errmsg == NULL) {</a>
<a name="ln2805">        SET_ERRMSG(_(</a>
<a name="ln2806">            &quot;E509: Cannot create backup file (add ! to override)&quot;));</a>
<a name="ln2807">      }</a>
<a name="ln2808">      // Ignore errors when forceit is TRUE.</a>
<a name="ln2809">      if ((some_error || errmsg != NULL) &amp;&amp; !forceit) {</a>
<a name="ln2810">        retval = FAIL;</a>
<a name="ln2811">        goto fail;</a>
<a name="ln2812">      }</a>
<a name="ln2813">      SET_ERRMSG(NULL);</a>
<a name="ln2814">    } else {</a>
<a name="ln2815">      char_u      *dirp;</a>
<a name="ln2816">      char_u      *p;</a>
<a name="ln2817">      char_u      *rootname;</a>
<a name="ln2818"> </a>
<a name="ln2819">      /*</a>
<a name="ln2820">       * Make a backup by renaming the original file.</a>
<a name="ln2821">       */</a>
<a name="ln2822">      /*</a>
<a name="ln2823">       * If 'cpoptions' includes the &quot;W&quot; flag, we don't want to</a>
<a name="ln2824">       * overwrite a read-only file.  But rename may be possible</a>
<a name="ln2825">       * anyway, thus we need an extra check here.</a>
<a name="ln2826">       */</a>
<a name="ln2827">      if (file_readonly &amp;&amp; vim_strchr(p_cpo, CPO_FWRITE) != NULL) {</a>
<a name="ln2828">        SET_ERRMSG_NUM(&quot;E504&quot;, _(err_readonly));</a>
<a name="ln2829">        goto fail;</a>
<a name="ln2830">      }</a>
<a name="ln2831"> </a>
<a name="ln2832">      /*</a>
<a name="ln2833">       *</a>
<a name="ln2834">       * Form the backup file name - change path/fo.o.h to</a>
<a name="ln2835">       * path/fo.o.h.bak Try all directories in 'backupdir', first one</a>
<a name="ln2836">       * that works is used.</a>
<a name="ln2837">       */</a>
<a name="ln2838">      dirp = p_bdir;</a>
<a name="ln2839">      while (*dirp) {</a>
<a name="ln2840">        /*</a>
<a name="ln2841">         * Isolate one directory name and make the backup file name.</a>
<a name="ln2842">         */</a>
<a name="ln2843">        (void)copy_option_part(&amp;dirp, IObuff, IOSIZE, &quot;,&quot;);</a>
<a name="ln2844">        p = IObuff + STRLEN(IObuff);</a>
<a name="ln2845">        if (after_pathsep((char *)IObuff, (char *)p) &amp;&amp; p[-1] == p[-2]) {</a>
<a name="ln2846">          // path ends with '//', use full path</a>
<a name="ln2847">          if ((p = (char_u *)make_percent_swname((char *)IObuff, (char *)fname))</a>
<a name="ln2848">              != NULL) {</a>
<a name="ln2849">            backup = (char_u *)modname((char *)p, (char *)backup_ext,</a>
<a name="ln2850">                                       no_prepend_dot);</a>
<a name="ln2851">            xfree(p);</a>
<a name="ln2852">          }</a>
<a name="ln2853">        }</a>
<a name="ln2854"> </a>
<a name="ln2855">        if (backup == NULL) {</a>
<a name="ln2856">          rootname = get_file_in_dir(fname, IObuff);</a>
<a name="ln2857">          if (rootname == NULL) {</a>
<a name="ln2858">            backup = NULL;</a>
<a name="ln2859">          } else {</a>
<a name="ln2860">            backup = (char_u *)modname((char *)rootname, (char *)backup_ext,</a>
<a name="ln2861">                                       no_prepend_dot);</a>
<a name="ln2862">            xfree(rootname);</a>
<a name="ln2863">          }</a>
<a name="ln2864">        }</a>
<a name="ln2865"> </a>
<a name="ln2866">        if (backup != NULL) {</a>
<a name="ln2867">          /*</a>
<a name="ln2868">           * If we are not going to keep the backup file, don't</a>
<a name="ln2869">           * delete an existing one, try to use another name.</a>
<a name="ln2870">           * Change one character, just before the extension.</a>
<a name="ln2871">           */</a>
<a name="ln2872">          if (!p_bk &amp;&amp; os_path_exists(backup)) {</a>
<a name="ln2873">            p = backup + STRLEN(backup) - 1 - STRLEN(backup_ext);</a>
<a name="ln2874">            if (p &lt; backup)             /* empty file name ??? */</a>
<a name="ln2875">              p = backup;</a>
<a name="ln2876">            *p = 'z';</a>
<a name="ln2877">            while (*p &gt; 'a' &amp;&amp; os_path_exists(backup)) {</a>
<a name="ln2878">              (*p)--;</a>
<a name="ln2879">            }</a>
<a name="ln2880">            // They all exist??? Must be something wrong!</a>
<a name="ln2881">            if (*p == 'a') {</a>
<a name="ln2882">              XFREE_CLEAR(backup);</a>
<a name="ln2883">            }</a>
<a name="ln2884">          }</a>
<a name="ln2885">        }</a>
<a name="ln2886">        if (backup != NULL) {</a>
<a name="ln2887">          // Delete any existing backup and move the current version</a>
<a name="ln2888">          // to the backup. For safety, we don't remove the backup</a>
<a name="ln2889">          // until the write has finished successfully. And if the</a>
<a name="ln2890">          // 'backup' option is set, leave it around.</a>
<a name="ln2891"> </a>
<a name="ln2892">          // If the renaming of the original file to the backup file</a>
<a name="ln2893">          // works, quit here.</a>
<a name="ln2894">          ///</a>
<a name="ln2895">          if (vim_rename(fname, backup) == 0) {</a>
<a name="ln2896">            break;</a>
<a name="ln2897">          }</a>
<a name="ln2898"> </a>
<a name="ln2899">          XFREE_CLEAR(backup);             // don't do the rename below</a>
<a name="ln2900">        }</a>
<a name="ln2901">      }</a>
<a name="ln2902">      if (backup == NULL &amp;&amp; !forceit) {</a>
<a name="ln2903">        SET_ERRMSG(_(&quot;E510: Can't make backup file (add ! to override)&quot;));</a>
<a name="ln2904">        goto fail;</a>
<a name="ln2905">      }</a>
<a name="ln2906">    }</a>
<a name="ln2907">  }</a>
<a name="ln2908"> </a>
<a name="ln2909">#if defined(UNIX)</a>
<a name="ln2910">  // When using &quot;:w!&quot; and the file was read-only: make it writable</a>
<a name="ln2911">  if (forceit &amp;&amp; perm &gt;= 0 &amp;&amp; !(perm &amp; 0200)</a>
<a name="ln2912">      &amp;&amp; file_info_old.stat.st_uid == getuid()</a>
<a name="ln2913">      &amp;&amp; vim_strchr(p_cpo, CPO_FWRITE) == NULL) {</a>
<a name="ln2914">    perm |= 0200;</a>
<a name="ln2915">    (void)os_setperm((const char *)fname, perm);</a>
<a name="ln2916">    made_writable = true;</a>
<a name="ln2917">  }</a>
<a name="ln2918">#endif</a>
<a name="ln2919"> </a>
<a name="ln2920">  // When using &quot;:w!&quot; and writing to the current file, 'readonly' makes no</a>
<a name="ln2921">  // sense, reset it, unless 'Z' appears in 'cpoptions'.</a>
<a name="ln2922">  if (forceit &amp;&amp; overwriting &amp;&amp; vim_strchr(p_cpo, CPO_KEEPRO) == NULL) {</a>
<a name="ln2923">    buf-&gt;b_p_ro = false;</a>
<a name="ln2924">    need_maketitle = true;          // set window title later</a>
<a name="ln2925">    status_redraw_all();            // redraw status lines later</a>
<a name="ln2926">  }</a>
<a name="ln2927"> </a>
<a name="ln2928">  if (end &gt; buf-&gt;b_ml.ml_line_count)</a>
<a name="ln2929">    end = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2930">  if (buf-&gt;b_ml.ml_flags &amp; ML_EMPTY)</a>
<a name="ln2931">    start = end + 1;</a>
<a name="ln2932"> </a>
<a name="ln2933">  // If the original file is being overwritten, there is a small chance that</a>
<a name="ln2934">  // we crash in the middle of writing. Therefore the file is preserved now.</a>
<a name="ln2935">  // This makes all block numbers positive so that recovery does not need</a>
<a name="ln2936">  // the original file.</a>
<a name="ln2937">  // Don't do this if there is a backup file and we are exiting.</a>
<a name="ln2938">  if (reset_changed &amp;&amp; !newfile &amp;&amp; overwriting</a>
<a name="ln2939">      &amp;&amp; !(exiting &amp;&amp; backup != NULL)) {</a>
<a name="ln2940">    ml_preserve(buf, false, !!p_fs);</a>
<a name="ln2941">    if (got_int) {</a>
<a name="ln2942">      SET_ERRMSG(_(e_interr));</a>
<a name="ln2943">      goto restore_backup;</a>
<a name="ln2944">    }</a>
<a name="ln2945">  }</a>
<a name="ln2946"> </a>
<a name="ln2947"> </a>
<a name="ln2948">  // Default: write the file directly.  May write to a temp file for</a>
<a name="ln2949">  // multi-byte conversion.</a>
<a name="ln2950">  wfname = fname;</a>
<a name="ln2951"> </a>
<a name="ln2952">  // Check for forced 'fileencoding' from &quot;++opt=val&quot; argument.</a>
<a name="ln2953">  if (eap != NULL &amp;&amp; eap-&gt;force_enc != 0) {</a>
<a name="ln2954">    fenc = eap-&gt;cmd + eap-&gt;force_enc;</a>
<a name="ln2955">    fenc = enc_canonize(fenc);</a>
<a name="ln2956">    fenc_tofree = fenc;</a>
<a name="ln2957">  } else {</a>
<a name="ln2958">    fenc = buf-&gt;b_p_fenc;</a>
<a name="ln2959">  }</a>
<a name="ln2960"> </a>
<a name="ln2961">  // Check if the file needs to be converted.</a>
<a name="ln2962">  converted = need_conversion(fenc);</a>
<a name="ln2963"> </a>
<a name="ln2964">  // Check if UTF-8 to UCS-2/4 or Latin1 conversion needs to be done.  Or</a>
<a name="ln2965">  // Latin1 to Unicode conversion.  This is handled in buf_write_bytes().</a>
<a name="ln2966">  // Prepare the flags for it and allocate bw_conv_buf when needed.</a>
<a name="ln2967">  if (converted) {</a>
<a name="ln2968">    wb_flags = get_fio_flags(fenc);</a>
<a name="ln2969">    if (wb_flags &amp; (FIO_UCS2 | FIO_UCS4 | FIO_UTF16 | FIO_UTF8)) {</a>
<a name="ln2970">      // Need to allocate a buffer to translate into.</a>
<a name="ln2971">      if (wb_flags &amp; (FIO_UCS2 | FIO_UTF16 | FIO_UTF8)) {</a>
<a name="ln2972">        write_info.bw_conv_buflen = bufsize * 2;</a>
<a name="ln2973">      } else {       // FIO_UCS4</a>
<a name="ln2974">        write_info.bw_conv_buflen = bufsize * 4;</a>
<a name="ln2975">      }</a>
<a name="ln2976">      write_info.bw_conv_buf = verbose_try_malloc(write_info.bw_conv_buflen);</a>
<a name="ln2977">      if (!write_info.bw_conv_buf) {</a>
<a name="ln2978">        end = 0;</a>
<a name="ln2979">      }</a>
<a name="ln2980">    }</a>
<a name="ln2981">  }</a>
<a name="ln2982"> </a>
<a name="ln2983"> </a>
<a name="ln2984"> </a>
<a name="ln2985">  if (converted &amp;&amp; wb_flags == 0) {</a>
<a name="ln2986">#  ifdef HAVE_ICONV</a>
<a name="ln2987">    // Use iconv() conversion when conversion is needed and it's not done</a>
<a name="ln2988">    // internally.</a>
<a name="ln2989">    write_info.bw_iconv_fd = (iconv_t)my_iconv_open(fenc, (char_u *)&quot;utf-8&quot;);</a>
<a name="ln2990">    if (write_info.bw_iconv_fd != (iconv_t)-1) {</a>
<a name="ln2991">      /* We're going to use iconv(), allocate a buffer to convert in. */</a>
<a name="ln2992">      write_info.bw_conv_buflen = bufsize * ICONV_MULT;</a>
<a name="ln2993">      write_info.bw_conv_buf = verbose_try_malloc(write_info.bw_conv_buflen);</a>
<a name="ln2994">      if (!write_info.bw_conv_buf) {</a>
<a name="ln2995">        end = 0;</a>
<a name="ln2996">      }</a>
<a name="ln2997">      write_info.bw_first = TRUE;</a>
<a name="ln2998">    } else</a>
<a name="ln2999">#  endif</a>
<a name="ln3000"> </a>
<a name="ln3001">    /*</a>
<a name="ln3002">     * When the file needs to be converted with 'charconvert' after</a>
<a name="ln3003">     * writing, write to a temp file instead and let the conversion</a>
<a name="ln3004">     * overwrite the original file.</a>
<a name="ln3005">     */</a>
<a name="ln3006">    if (*p_ccv != NUL) {</a>
<a name="ln3007">      wfname = vim_tempname();</a>
<a name="ln3008">      if (wfname == NULL) {  // Can't write without a tempfile!</a>
<a name="ln3009">        SET_ERRMSG(_(&quot;E214: Can't find temp file for writing&quot;));</a>
<a name="ln3010">        goto restore_backup;</a>
<a name="ln3011">      }</a>
<a name="ln3012">    }</a>
<a name="ln3013">  }</a>
<a name="ln3014">  if (converted &amp;&amp; wb_flags == 0</a>
<a name="ln3015">#  ifdef HAVE_ICONV</a>
<a name="ln3016">      &amp;&amp; write_info.bw_iconv_fd == (iconv_t)-1</a>
<a name="ln3017">#  endif</a>
<a name="ln3018">      &amp;&amp; wfname == fname</a>
<a name="ln3019">      ) {</a>
<a name="ln3020">    if (!forceit) {</a>
<a name="ln3021">      SET_ERRMSG(_(</a>
<a name="ln3022">          &quot;E213: Cannot convert (add ! to write without conversion)&quot;));</a>
<a name="ln3023">      goto restore_backup;</a>
<a name="ln3024">    }</a>
<a name="ln3025">    notconverted = TRUE;</a>
<a name="ln3026">  }</a>
<a name="ln3027"> </a>
<a name="ln3028">  // If conversion is taking place, we may first pretend to write and check</a>
<a name="ln3029">  // for conversion errors.  Then loop again to write for real.</a>
<a name="ln3030">  // When not doing conversion this writes for real right away.</a>
<a name="ln3031">  for (checking_conversion = true; ; checking_conversion = false) {</a>
<a name="ln3032">    // There is no need to check conversion when:</a>
<a name="ln3033">    // - there is no conversion</a>
<a name="ln3034">    // - we make a backup file, that can be restored in case of conversion</a>
<a name="ln3035">    // failure.</a>
<a name="ln3036">    if (!converted || dobackup) {</a>
<a name="ln3037">      checking_conversion = false;</a>
<a name="ln3038">    }</a>
<a name="ln3039"> </a>
<a name="ln3040">    if (checking_conversion) {</a>
<a name="ln3041">      // Make sure we don't write anything.</a>
<a name="ln3042">      fd = -1;</a>
<a name="ln3043">      write_info.bw_fd = fd;</a>
<a name="ln3044">    } else {</a>
<a name="ln3045">      // Open the file &quot;wfname&quot; for writing.</a>
<a name="ln3046">      // We may try to open the file twice: If we can't write to the file</a>
<a name="ln3047">      // and forceit is TRUE we delete the existing file and try to</a>
<a name="ln3048">      // create a new one. If this still fails we may have lost the</a>
<a name="ln3049">      // original file!  (this may happen when the user reached his</a>
<a name="ln3050">      // quotum for number of files).</a>
<a name="ln3051">      // Appending will fail if the file does not exist and forceit is</a>
<a name="ln3052">      // FALSE.</a>
<a name="ln3053">      while ((fd = os_open((char *)wfname,</a>
<a name="ln3054">                           O_WRONLY |</a>
<a name="ln3055">                           (append ?</a>
<a name="ln3056">                            (forceit ? (O_APPEND | O_CREAT) : O_APPEND)</a>
<a name="ln3057">                            : (O_CREAT | O_TRUNC))</a>
<a name="ln3058">                           , perm &lt; 0 ? 0666 : (perm &amp; 0777))) &lt; 0) {</a>
<a name="ln3059">        // A forced write will try to create a new file if the old one</a>
<a name="ln3060">        // is still readonly. This may also happen when the directory</a>
<a name="ln3061">        // is read-only. In that case the mch_remove() will fail.</a>
<a name="ln3062">        if (errmsg == NULL) {</a>
<a name="ln3063">#ifdef UNIX</a>
<a name="ln3064">          FileInfo file_info;</a>
<a name="ln3065"> </a>
<a name="ln3066">          // Don't delete the file when it's a hard or symbolic link.</a>
<a name="ln3067">          if ((!newfile &amp;&amp; os_fileinfo_hardlinks(&amp;file_info_old) &gt; 1)</a>
<a name="ln3068">              || (os_fileinfo_link((char *)fname, &amp;file_info)</a>
<a name="ln3069">                  &amp;&amp; !os_fileinfo_id_equal(&amp;file_info, &amp;file_info_old))) {</a>
<a name="ln3070">            SET_ERRMSG(_(&quot;E166: Can't open linked file for writing&quot;));</a>
<a name="ln3071">          } else {</a>
<a name="ln3072">#endif</a>
<a name="ln3073">            SET_ERRMSG_ARG(_(&quot;E212: Can't open file for writing: %s&quot;), fd);</a>
<a name="ln3074">            if (forceit &amp;&amp; vim_strchr(p_cpo, CPO_FWRITE) == NULL</a>
<a name="ln3075">                &amp;&amp; perm &gt;= 0) {</a>
<a name="ln3076">#ifdef UNIX</a>
<a name="ln3077">              // we write to the file, thus it should be marked</a>
<a name="ln3078">              // writable after all</a>
<a name="ln3079">              if (!(perm &amp; 0200)) {</a>
<a name="ln3080">                made_writable = true;</a>
<a name="ln3081">              }</a>
<a name="ln3082">              perm |= 0200;</a>
<a name="ln3083">              if (file_info_old.stat.st_uid != getuid()</a>
<a name="ln3084">                  || file_info_old.stat.st_gid != getgid()) {</a>
<a name="ln3085">                perm &amp;= 0777;</a>
<a name="ln3086">              }</a>
<a name="ln3087">#endif</a>
<a name="ln3088">              if (!append) {                    // don't remove when appending</a>
<a name="ln3089">                os_remove((char *)wfname);</a>
<a name="ln3090">              }</a>
<a name="ln3091">              continue;</a>
<a name="ln3092">            }</a>
<a name="ln3093">#ifdef UNIX</a>
<a name="ln3094">          }</a>
<a name="ln3095">#endif</a>
<a name="ln3096">        }</a>
<a name="ln3097"> </a>
<a name="ln3098">restore_backup:</a>
<a name="ln3099">        {</a>
<a name="ln3100">          // If we failed to open the file, we don't need a backup. Throw it</a>
<a name="ln3101">          // away.  If we moved or removed the original file try to put the</a>
<a name="ln3102">          // backup in its place.</a>
<a name="ln3103">          if (backup != NULL &amp;&amp; wfname == fname) {</a>
<a name="ln3104">            if (backup_copy) {</a>
<a name="ln3105">              // There is a small chance that we removed the original,</a>
<a name="ln3106">              // try to move the copy in its place.</a>
<a name="ln3107">              // This may not work if the vim_rename() fails.</a>
<a name="ln3108">              // In that case we leave the copy around.</a>
<a name="ln3109">              // If file does not exist, put the copy in its place</a>
<a name="ln3110">              if (!os_path_exists(fname)) {</a>
<a name="ln3111">                vim_rename(backup, fname);</a>
<a name="ln3112">              }</a>
<a name="ln3113">              // if original file does exist throw away the copy</a>
<a name="ln3114">              if (os_path_exists(fname)) {</a>
<a name="ln3115">                os_remove((char *)backup);</a>
<a name="ln3116">              }</a>
<a name="ln3117">            } else {</a>
<a name="ln3118">              // try to put the original file back</a>
<a name="ln3119">              vim_rename(backup, fname);</a>
<a name="ln3120">            }</a>
<a name="ln3121">          }</a>
<a name="ln3122"> </a>
<a name="ln3123">          // if original file no longer exists give an extra warning</a>
<a name="ln3124">          if (!newfile &amp;&amp; !os_path_exists(fname)) {</a>
<a name="ln3125">            end = 0;</a>
<a name="ln3126">          }</a>
<a name="ln3127">        }</a>
<a name="ln3128"> </a>
<a name="ln3129">        if (wfname != fname) {</a>
<a name="ln3130">          xfree(wfname);</a>
<a name="ln3131">        }</a>
<a name="ln3132">        goto fail;</a>
<a name="ln3133">      }</a>
<a name="ln3134">      write_info.bw_fd = fd;</a>
<a name="ln3135">    }</a>
<a name="ln3136">    SET_ERRMSG(NULL);</a>
<a name="ln3137"> </a>
<a name="ln3138">    write_info.bw_buf = buffer;</a>
<a name="ln3139">    nchars = 0;</a>
<a name="ln3140"> </a>
<a name="ln3141">    // use &quot;++bin&quot;, &quot;++nobin&quot; or 'binary'</a>
<a name="ln3142">    if (eap != NULL &amp;&amp; eap-&gt;force_bin != 0) {</a>
<a name="ln3143">      write_bin = (eap-&gt;force_bin == FORCE_BIN);</a>
<a name="ln3144">    } else {</a>
<a name="ln3145">      write_bin = buf-&gt;b_p_bin;</a>
<a name="ln3146">    }</a>
<a name="ln3147"> </a>
<a name="ln3148">    // Skip the BOM when appending and the file already existed, the BOM</a>
<a name="ln3149">    // only makes sense at the start of the file.</a>
<a name="ln3150">    if (buf-&gt;b_p_bomb &amp;&amp; !write_bin &amp;&amp; (!append || perm &lt; 0)) {</a>
<a name="ln3151">      write_info.bw_len = make_bom(buffer, fenc);</a>
<a name="ln3152">      if (write_info.bw_len &gt; 0) {</a>
<a name="ln3153">        // don't convert</a>
<a name="ln3154">        write_info.bw_flags = FIO_NOCONVERT | wb_flags;</a>
<a name="ln3155">        if (buf_write_bytes(&amp;write_info) == FAIL) {</a>
<a name="ln3156">          end = 0;</a>
<a name="ln3157">        } else {</a>
<a name="ln3158">          nchars += write_info.bw_len;</a>
<a name="ln3159">        }</a>
<a name="ln3160">      }</a>
<a name="ln3161">    }</a>
<a name="ln3162">    write_info.bw_start_lnum = start;</a>
<a name="ln3163"> </a>
<a name="ln3164">    write_undo_file = (buf-&gt;b_p_udf &amp;&amp; overwriting &amp;&amp; !append</a>
<a name="ln3165">                       &amp;&amp; !filtering &amp;&amp; reset_changed &amp;&amp; !checking_conversion);</a>
<a name="ln3166">    if (write_undo_file) {</a>
<a name="ln3167">      // Prepare for computing the hash value of the text.</a>
<a name="ln3168">      sha256_start(&amp;sha_ctx);</a>
<a name="ln3169">    }</a>
<a name="ln3170"> </a>
<a name="ln3171">    write_info.bw_len = bufsize;</a>
<a name="ln3172">#ifdef HAS_BW_FLAGS</a>
<a name="ln3173">    write_info.bw_flags = wb_flags;</a>
<a name="ln3174">#endif</a>
<a name="ln3175">    fileformat = get_fileformat_force(buf, eap);</a>
<a name="ln3176">    s = buffer;</a>
<a name="ln3177">    len = 0;</a>
<a name="ln3178">    for (lnum = start; lnum &lt;= end; lnum++) {</a>
<a name="ln3179">      // The next while loop is done once for each character written.</a>
<a name="ln3180">      // Keep it fast!</a>
<a name="ln3181">      ptr = ml_get_buf(buf, lnum, false) - 1;</a>
<a name="ln3182">      if (write_undo_file) {</a>
<a name="ln3183">        sha256_update(&amp;sha_ctx, ptr + 1, (uint32_t)(STRLEN(ptr + 1) + 1));</a>
<a name="ln3184">      }</a>
<a name="ln3185">      while ((c = *++ptr) != NUL) {</a>
<a name="ln3186">        if (c == NL) {</a>
<a name="ln3187">          *s = NUL;                       // replace newlines with NULs</a>
<a name="ln3188">        } else if (c == CAR &amp;&amp; fileformat == EOL_MAC) {</a>
<a name="ln3189">          *s = NL;                        // Mac: replace CRs with NLs</a>
<a name="ln3190">        } else {</a>
<a name="ln3191">          *s = c;</a>
<a name="ln3192">        }</a>
<a name="ln3193">        s++;</a>
<a name="ln3194">        if (++len != bufsize) {</a>
<a name="ln3195">          continue;</a>
<a name="ln3196">        }</a>
<a name="ln3197">        if (buf_write_bytes(&amp;write_info) == FAIL) {</a>
<a name="ln3198">          end = 0;                        // write error: break loop</a>
<a name="ln3199">          break;</a>
<a name="ln3200">        }</a>
<a name="ln3201">        nchars += bufsize;</a>
<a name="ln3202">        s = buffer;</a>
<a name="ln3203">        len = 0;</a>
<a name="ln3204">        write_info.bw_start_lnum = lnum;</a>
<a name="ln3205">      }</a>
<a name="ln3206">      // write failed or last line has no EOL: stop here</a>
<a name="ln3207">      if (end == 0</a>
<a name="ln3208">          || (lnum == end</a>
<a name="ln3209">              &amp;&amp; (write_bin || !buf-&gt;b_p_fixeol)</a>
<a name="ln3210">              &amp;&amp; (lnum == buf-&gt;b_no_eol_lnum</a>
<a name="ln3211">                  || (lnum == buf-&gt;b_ml.ml_line_count &amp;&amp; !buf-&gt;b_p_eol)))) {</a>
<a name="ln3212">        lnum++;                           // written the line, count it</a>
<a name="ln3213">        no_eol = true;</a>
<a name="ln3214">        break;</a>
<a name="ln3215">      }</a>
<a name="ln3216">      if (fileformat == EOL_UNIX) {</a>
<a name="ln3217">        *s++ = NL;</a>
<a name="ln3218">      } else {</a>
<a name="ln3219">        *s++ = CAR;                       // EOL_MAC or EOL_DOS: write CR</a>
<a name="ln3220">        if (fileformat == EOL_DOS) {      // write CR-NL</a>
<a name="ln3221">          if (++len == bufsize) {</a>
<a name="ln3222">            if (buf_write_bytes(&amp;write_info) == FAIL) {</a>
<a name="ln3223">              end = 0;                    // write error: break loop</a>
<a name="ln3224">              break;</a>
<a name="ln3225">            }</a>
<a name="ln3226">            nchars += bufsize;</a>
<a name="ln3227">            s = buffer;</a>
<a name="ln3228">            len = 0;</a>
<a name="ln3229">          }</a>
<a name="ln3230">          *s++ = NL;</a>
<a name="ln3231">        }</a>
<a name="ln3232">      }</a>
<a name="ln3233">      if (++len == bufsize) {</a>
<a name="ln3234">        if (buf_write_bytes(&amp;write_info) == FAIL) {</a>
<a name="ln3235">          end = 0;  // Write error: break loop.</a>
<a name="ln3236">          break;</a>
<a name="ln3237">        }</a>
<a name="ln3238">        nchars += bufsize;</a>
<a name="ln3239">        s = buffer;</a>
<a name="ln3240">        len = 0;</a>
<a name="ln3241"> </a>
<a name="ln3242">        os_breakcheck();</a>
<a name="ln3243">        if (got_int) {</a>
<a name="ln3244">          end = 0;  // Interrupted, break loop.</a>
<a name="ln3245">          break;</a>
<a name="ln3246">        }</a>
<a name="ln3247">      }</a>
<a name="ln3248">    }</a>
<a name="ln3249">    if (len &gt; 0 &amp;&amp; end &gt; 0) {</a>
<a name="ln3250">      write_info.bw_len = len;</a>
<a name="ln3251">      if (buf_write_bytes(&amp;write_info) == FAIL) {</a>
<a name="ln3252">        end = 0;                      // write error</a>
<a name="ln3253">      }</a>
<a name="ln3254">      nchars += len;</a>
<a name="ln3255">    }</a>
<a name="ln3256"> </a>
<a name="ln3257">    // Stop when writing done or an error was encountered.</a>
<a name="ln3258">    if (!checking_conversion || end == 0) {</a>
<a name="ln3259">        break;</a>
<a name="ln3260">    }</a>
<a name="ln3261"> </a>
<a name="ln3262">    // If no error happened until now, writing should be ok, so loop to</a>
<a name="ln3263">    // really write the buffer.</a>
<a name="ln3264">  }</a>
<a name="ln3265"> </a>
<a name="ln3266">  // If we started writing, finish writing. Also when an error was</a>
<a name="ln3267">  // encountered.</a>
<a name="ln3268">  if (!checking_conversion) {</a>
<a name="ln3269">    // On many journalling file systems there is a bug that causes both the</a>
<a name="ln3270">    // original and the backup file to be lost when halting the system right</a>
<a name="ln3271">    // after writing the file.  That's because only the meta-data is</a>
<a name="ln3272">    // journalled.  Syncing the file slows down the system, but assures it has</a>
<a name="ln3273">    // been written to disk and we don't lose it.</a>
<a name="ln3274">    // For a device do try the fsync() but don't complain if it does not work</a>
<a name="ln3275">    // (could be a pipe).</a>
<a name="ln3276">    // If the 'fsync' option is FALSE, don't fsync().  Useful for laptops.</a>
<a name="ln3277">    int error;</a>
<a name="ln3278">    if (p_fs &amp;&amp; (error = os_fsync(fd)) != 0 &amp;&amp; !device</a>
<a name="ln3279">        // fsync not supported on this storage.</a>
<a name="ln3280">        &amp;&amp; error != UV_ENOTSUP) {</a>
<a name="ln3281">      SET_ERRMSG_ARG(e_fsync, error);</a>
<a name="ln3282">      end = 0;</a>
<a name="ln3283">    }</a>
<a name="ln3284"> </a>
<a name="ln3285">#ifdef UNIX</a>
<a name="ln3286">    // When creating a new file, set its owner/group to that of the original</a>
<a name="ln3287">    // file.  Get the new device and inode number.</a>
<a name="ln3288">    if (backup != NULL &amp;&amp; !backup_copy) {</a>
<a name="ln3289">      // don't change the owner when it's already OK, some systems remove</a>
<a name="ln3290">      // permission or ACL stuff</a>
<a name="ln3291">      FileInfo file_info;</a>
<a name="ln3292">      if (!os_fileinfo((char *)wfname, &amp;file_info)</a>
<a name="ln3293">          || file_info.stat.st_uid != file_info_old.stat.st_uid</a>
<a name="ln3294">          || file_info.stat.st_gid != file_info_old.stat.st_gid) {</a>
<a name="ln3295">        os_fchown(fd, file_info_old.stat.st_uid, file_info_old.stat.st_gid);</a>
<a name="ln3296">        if (perm &gt;= 0) {  // Set permission again, may have changed.</a>
<a name="ln3297">          (void)os_setperm((const char *)wfname, perm);</a>
<a name="ln3298">        }</a>
<a name="ln3299">      }</a>
<a name="ln3300">      buf_set_file_id(buf);</a>
<a name="ln3301">    } else if (!buf-&gt;file_id_valid) {</a>
<a name="ln3302">      // Set the file_id when creating a new file.</a>
<a name="ln3303">      buf_set_file_id(buf);</a>
<a name="ln3304">    }</a>
<a name="ln3305">#endif</a>
<a name="ln3306"> </a>
<a name="ln3307">    if ((error = os_close(fd)) != 0) {</a>
<a name="ln3308">      SET_ERRMSG_ARG(_(&quot;E512: Close failed: %s&quot;), error);</a>
<a name="ln3309">      end = 0;</a>
<a name="ln3310">    }</a>
<a name="ln3311"> </a>
<a name="ln3312">#ifdef UNIX</a>
<a name="ln3313">    if (made_writable) {</a>
<a name="ln3314">      perm &amp;= ~0200;              // reset 'w' bit for security reasons</a>
<a name="ln3315">    }</a>
<a name="ln3316">#endif</a>
<a name="ln3317">    if (perm &gt;= 0) {  // Set perm. of new file same as old file.</a>
<a name="ln3318">      (void)os_setperm((const char *)wfname, perm);</a>
<a name="ln3319">    }</a>
<a name="ln3320">#ifdef HAVE_ACL</a>
<a name="ln3321">    // Probably need to set the ACL before changing the user (can't set the</a>
<a name="ln3322">    // ACL on a file the user doesn't own).</a>
<a name="ln3323">    if (!backup_copy) {</a>
<a name="ln3324">      mch_set_acl(wfname, acl);</a>
<a name="ln3325">    }</a>
<a name="ln3326">#endif</a>
<a name="ln3327"> </a>
<a name="ln3328">    if (wfname != fname) {</a>
<a name="ln3329">      // The file was written to a temp file, now it needs to be converted</a>
<a name="ln3330">      // with 'charconvert' to (overwrite) the output file.</a>
<a name="ln3331">      if (end != 0) {</a>
<a name="ln3332">        if (eval_charconvert(&quot;utf-8&quot;, (char *)fenc,</a>
<a name="ln3333">                             (char *)wfname, (char *)fname) == FAIL) {</a>
<a name="ln3334">          write_info.bw_conv_error = true;</a>
<a name="ln3335">          end = 0;</a>
<a name="ln3336">        }</a>
<a name="ln3337">      }</a>
<a name="ln3338">      os_remove((char *)wfname);</a>
<a name="ln3339">      xfree(wfname);</a>
<a name="ln3340">    }</a>
<a name="ln3341">  }</a>
<a name="ln3342"> </a>
<a name="ln3343">  if (end == 0) {</a>
<a name="ln3344">    // Error encountered.</a>
<a name="ln3345">    if (errmsg == NULL) {</a>
<a name="ln3346">      if (write_info.bw_conv_error) {</a>
<a name="ln3347">        if (write_info.bw_conv_error_lnum == 0) {</a>
<a name="ln3348">          SET_ERRMSG(_(</a>
<a name="ln3349">              &quot;E513: write error, conversion failed &quot;</a>
<a name="ln3350">              &quot;(make 'fenc' empty to override)&quot;));</a>
<a name="ln3351">        } else {</a>
<a name="ln3352">          errmsg_allocated = true;</a>
<a name="ln3353">          SET_ERRMSG(xmalloc(300));</a>
<a name="ln3354">          vim_snprintf(</a>
<a name="ln3355">              errmsg, 300,</a>
<a name="ln3356">              _(&quot;E513: write error, conversion failed in line %&quot; PRIdLINENR</a>
<a name="ln3357">                &quot; (make 'fenc' empty to override)&quot;),</a>
<a name="ln3358">              write_info.bw_conv_error_lnum);</a>
<a name="ln3359">        }</a>
<a name="ln3360">      } else if (got_int) {</a>
<a name="ln3361">        SET_ERRMSG(_(e_interr));</a>
<a name="ln3362">      } else {</a>
<a name="ln3363">        SET_ERRMSG(_(&quot;E514: write error (file system full?)&quot;));</a>
<a name="ln3364">      }</a>
<a name="ln3365">    }</a>
<a name="ln3366"> </a>
<a name="ln3367">    // If we have a backup file, try to put it in place of the new file,</a>
<a name="ln3368">    // because the new file is probably corrupt.  This avoids losing the</a>
<a name="ln3369">    // original file when trying to make a backup when writing the file a</a>
<a name="ln3370">    // second time.</a>
<a name="ln3371">    // When &quot;backup_copy&quot; is set we need to copy the backup over the new</a>
<a name="ln3372">    // file.  Otherwise rename the backup file.</a>
<a name="ln3373">    // If this is OK, don't give the extra warning message.</a>
<a name="ln3374">    if (backup != NULL) {</a>
<a name="ln3375">      if (backup_copy) {</a>
<a name="ln3376">        // This may take a while, if we were interrupted let the user</a>
<a name="ln3377">        // know we got the message.</a>
<a name="ln3378">        if (got_int) {</a>
<a name="ln3379">          MSG(_(e_interr));</a>
<a name="ln3380">          ui_flush();</a>
<a name="ln3381">        }</a>
<a name="ln3382"> </a>
<a name="ln3383">        // copy the file.</a>
<a name="ln3384">        if (os_copy((char *)backup, (char *)fname, UV_FS_COPYFILE_FICLONE)</a>
<a name="ln3385">            == 0) {</a>
<a name="ln3386">          end = 1;  // success</a>
<a name="ln3387">        }</a>
<a name="ln3388">      } else {</a>
<a name="ln3389">        if (vim_rename(backup, fname) == 0) {</a>
<a name="ln3390">          end = 1;</a>
<a name="ln3391">        }</a>
<a name="ln3392">      }</a>
<a name="ln3393">    }</a>
<a name="ln3394">    goto fail;</a>
<a name="ln3395">  }</a>
<a name="ln3396"> </a>
<a name="ln3397">  lnum -= start;            /* compute number of written lines */</a>
<a name="ln3398">  --no_wait_return;         /* may wait for return now */</a>
<a name="ln3399"> </a>
<a name="ln3400">#if !defined(UNIX)</a>
<a name="ln3401">  fname = sfname;           /* use shortname now, for the messages */</a>
<a name="ln3402">#endif</a>
<a name="ln3403">  if (!filtering) {</a>
<a name="ln3404">    add_quoted_fname((char *)IObuff, IOSIZE, buf, (const char *)fname);</a>
<a name="ln3405">    c = false;</a>
<a name="ln3406">    if (write_info.bw_conv_error) {</a>
<a name="ln3407">      STRCAT(IObuff, _(&quot; CONVERSION ERROR&quot;));</a>
<a name="ln3408">      c = TRUE;</a>
<a name="ln3409">      if (write_info.bw_conv_error_lnum != 0)</a>
<a name="ln3410">        vim_snprintf_add((char *)IObuff, IOSIZE, _(&quot; in line %&quot; PRId64 &quot;;&quot;),</a>
<a name="ln3411">            (int64_t)write_info.bw_conv_error_lnum);</a>
<a name="ln3412">    } else if (notconverted) {</a>
<a name="ln3413">      STRCAT(IObuff, _(&quot;[NOT converted]&quot;));</a>
<a name="ln3414">      c = TRUE;</a>
<a name="ln3415">    } else if (converted) {</a>
<a name="ln3416">      STRCAT(IObuff, _(&quot;[converted]&quot;));</a>
<a name="ln3417">      c = TRUE;</a>
<a name="ln3418">    }</a>
<a name="ln3419">    if (device) {</a>
<a name="ln3420">      STRCAT(IObuff, _(&quot;[Device]&quot;));</a>
<a name="ln3421">      c = TRUE;</a>
<a name="ln3422">    } else if (newfile) {</a>
<a name="ln3423">      STRCAT(IObuff, new_file_message());</a>
<a name="ln3424">      c = true;</a>
<a name="ln3425">    }</a>
<a name="ln3426">    if (no_eol) {</a>
<a name="ln3427">      msg_add_eol();</a>
<a name="ln3428">      c = TRUE;</a>
<a name="ln3429">    }</a>
<a name="ln3430">    /* may add [unix/dos/mac] */</a>
<a name="ln3431">    if (msg_add_fileformat(fileformat))</a>
<a name="ln3432">      c = TRUE;</a>
<a name="ln3433">    msg_add_lines(c, (long)lnum, nchars);       /* add line/char count */</a>
<a name="ln3434">    if (!shortmess(SHM_WRITE)) {</a>
<a name="ln3435">      if (append)</a>
<a name="ln3436">        STRCAT(IObuff, shortmess(SHM_WRI) ? _(&quot; [a]&quot;) : _(&quot; appended&quot;));</a>
<a name="ln3437">      else</a>
<a name="ln3438">        STRCAT(IObuff, shortmess(SHM_WRI) ? _(&quot; [w]&quot;) : _(&quot; written&quot;));</a>
<a name="ln3439">    }</a>
<a name="ln3440"> </a>
<a name="ln3441">    set_keep_msg(msg_trunc_attr(IObuff, FALSE, 0), 0);</a>
<a name="ln3442">  }</a>
<a name="ln3443"> </a>
<a name="ln3444">  /* When written everything correctly: reset 'modified'.  Unless not</a>
<a name="ln3445">   * writing to the original file and '+' is not in 'cpoptions'. */</a>
<a name="ln3446">  if (reset_changed &amp;&amp; whole &amp;&amp; !append</a>
<a name="ln3447">      &amp;&amp; !write_info.bw_conv_error</a>
<a name="ln3448">      &amp;&amp; (overwriting || vim_strchr(p_cpo, CPO_PLUS) != NULL)) {</a>
<a name="ln3449">    unchanged(buf, true, false);</a>
<a name="ln3450">    const varnumber_T changedtick = buf_get_changedtick(buf);</a>
<a name="ln3451">    if (buf-&gt;b_last_changedtick + 1 == changedtick) {</a>
<a name="ln3452">      // b:changedtick may be incremented in unchanged() but that</a>
<a name="ln3453">      // should not trigger a TextChanged event.</a>
<a name="ln3454">      buf-&gt;b_last_changedtick = changedtick;</a>
<a name="ln3455">    }</a>
<a name="ln3456">    u_unchanged(buf);</a>
<a name="ln3457">    u_update_save_nr(buf);</a>
<a name="ln3458">  }</a>
<a name="ln3459"> </a>
<a name="ln3460">  /*</a>
<a name="ln3461">   * If written to the current file, update the timestamp of the swap file</a>
<a name="ln3462">   * and reset the BF_WRITE_MASK flags. Also sets buf-&gt;b_mtime.</a>
<a name="ln3463">   */</a>
<a name="ln3464">  if (overwriting) {</a>
<a name="ln3465">    ml_timestamp(buf);</a>
<a name="ln3466">    if (append)</a>
<a name="ln3467">      buf-&gt;b_flags &amp;= ~BF_NEW;</a>
<a name="ln3468">    else</a>
<a name="ln3469">      buf-&gt;b_flags &amp;= ~BF_WRITE_MASK;</a>
<a name="ln3470">  }</a>
<a name="ln3471"> </a>
<a name="ln3472">  /*</a>
<a name="ln3473">   * If we kept a backup until now, and we are in patch mode, then we make</a>
<a name="ln3474">   * the backup file our 'original' file.</a>
<a name="ln3475">   */</a>
<a name="ln3476">  if (*p_pm &amp;&amp; dobackup) {</a>
<a name="ln3477">    char *const org = modname((char *)fname, (char *)p_pm, false);</a>
<a name="ln3478"> </a>
<a name="ln3479">    if (backup != NULL) {</a>
<a name="ln3480">      /*</a>
<a name="ln3481">       * If the original file does not exist yet</a>
<a name="ln3482">       * the current backup file becomes the original file</a>
<a name="ln3483">       */</a>
<a name="ln3484">      if (org == NULL) {</a>
<a name="ln3485">        EMSG(_(&quot;E205: Patchmode: can't save original file&quot;));</a>
<a name="ln3486">      } else if (!os_path_exists((char_u *)org)) {</a>
<a name="ln3487">        vim_rename(backup, (char_u *)org);</a>
<a name="ln3488">        XFREE_CLEAR(backup);                   // don't delete the file</a>
<a name="ln3489">#ifdef UNIX</a>
<a name="ln3490">        os_file_settime(org,</a>
<a name="ln3491">                        file_info_old.stat.st_atim.tv_sec,</a>
<a name="ln3492">                        file_info_old.stat.st_mtim.tv_sec);</a>
<a name="ln3493">#endif</a>
<a name="ln3494">      }</a>
<a name="ln3495">    }</a>
<a name="ln3496">    /*</a>
<a name="ln3497">     * If there is no backup file, remember that a (new) file was</a>
<a name="ln3498">     * created.</a>
<a name="ln3499">     */</a>
<a name="ln3500">    else {</a>
<a name="ln3501">      int empty_fd;</a>
<a name="ln3502"> </a>
<a name="ln3503">      if (org == NULL</a>
<a name="ln3504">          || (empty_fd = os_open(org,</a>
<a name="ln3505">                  O_CREAT | O_EXCL | O_NOFOLLOW,</a>
<a name="ln3506">                  perm &lt; 0 ? 0666 : (perm &amp; 0777))) &lt; 0)</a>
<a name="ln3507">        EMSG(_(&quot;E206: patchmode: can't touch empty original file&quot;));</a>
<a name="ln3508">      else</a>
<a name="ln3509">        close(empty_fd);</a>
<a name="ln3510">    }</a>
<a name="ln3511">    if (org != NULL) {</a>
<a name="ln3512">      os_setperm(org, os_getperm((const char *)fname) &amp; 0777);</a>
<a name="ln3513">      xfree(org);</a>
<a name="ln3514">    }</a>
<a name="ln3515">  }</a>
<a name="ln3516"> </a>
<a name="ln3517">  /*</a>
<a name="ln3518">   * Remove the backup unless 'backup' option is set</a>
<a name="ln3519">   */</a>
<a name="ln3520">  if (!p_bk &amp;&amp; backup != NULL</a>
<a name="ln3521">      &amp;&amp; !write_info.bw_conv_error</a>
<a name="ln3522">      &amp;&amp; os_remove((char *)backup) != 0) {</a>
<a name="ln3523">    EMSG(_(&quot;E207: Can't delete backup file&quot;));</a>
<a name="ln3524">  }</a>
<a name="ln3525"> </a>
<a name="ln3526">  goto nofail;</a>
<a name="ln3527"> </a>
<a name="ln3528">  /*</a>
<a name="ln3529">   * Finish up.  We get here either after failure or success.</a>
<a name="ln3530">   */</a>
<a name="ln3531">fail:</a>
<a name="ln3532">  --no_wait_return;             /* may wait for return now */</a>
<a name="ln3533">nofail:</a>
<a name="ln3534"> </a>
<a name="ln3535">  /* Done saving, we accept changed buffer warnings again */</a>
<a name="ln3536">  buf-&gt;b_saving = false;</a>
<a name="ln3537"> </a>
<a name="ln3538">  xfree(backup);</a>
<a name="ln3539">  if (buffer != smallbuf)</a>
<a name="ln3540">    xfree(buffer);</a>
<a name="ln3541">  xfree(fenc_tofree);</a>
<a name="ln3542">  xfree(write_info.bw_conv_buf);</a>
<a name="ln3543"># ifdef HAVE_ICONV</a>
<a name="ln3544">  if (write_info.bw_iconv_fd != (iconv_t)-1) {</a>
<a name="ln3545">    iconv_close(write_info.bw_iconv_fd);</a>
<a name="ln3546">    write_info.bw_iconv_fd = (iconv_t)-1;</a>
<a name="ln3547">  }</a>
<a name="ln3548"># endif</a>
<a name="ln3549">#ifdef HAVE_ACL</a>
<a name="ln3550">  mch_free_acl(acl);</a>
<a name="ln3551">#endif</a>
<a name="ln3552"> </a>
<a name="ln3553">  if (errmsg != NULL) {</a>
<a name="ln3554">    // - 100 to save some space for further error message</a>
<a name="ln3555">#ifndef UNIX</a>
<a name="ln3556">    add_quoted_fname((char *)IObuff, IOSIZE - 100, buf, (const char *)sfname);</a>
<a name="ln3557">#else</a>
<a name="ln3558">    add_quoted_fname((char *)IObuff, IOSIZE - 100, buf, (const char *)fname);</a>
<a name="ln3559">#endif</a>
<a name="ln3560">    if (errnum != NULL) {</a>
<a name="ln3561">      if (errmsgarg != 0) {</a>
<a name="ln3562">        emsgf(&quot;%s: %s%s: %s&quot;, errnum, IObuff, errmsg, os_strerror(errmsgarg));</a>
<a name="ln3563">      } else {</a>
<a name="ln3564">        emsgf(&quot;%s: %s%s&quot;, errnum, IObuff, errmsg);</a>
<a name="ln3565">      }</a>
<a name="ln3566">    } else if (errmsgarg != 0) {</a>
<a name="ln3567">      emsgf(errmsg, os_strerror(errmsgarg));</a>
<a name="ln3568">    } else {</a>
<a name="ln3569">      EMSG(errmsg);</a>
<a name="ln3570">    }</a>
<a name="ln3571">    if (errmsg_allocated) {</a>
<a name="ln3572">      xfree(errmsg);</a>
<a name="ln3573">    }</a>
<a name="ln3574"> </a>
<a name="ln3575">    retval = FAIL;</a>
<a name="ln3576">    if (end == 0) {</a>
<a name="ln3577">      const int attr = HL_ATTR(HLF_E);  // Set highlight for error messages.</a>
<a name="ln3578">      MSG_PUTS_ATTR(_(&quot;\nWARNING: Original file may be lost or damaged\n&quot;),</a>
<a name="ln3579">                    attr | MSG_HIST);</a>
<a name="ln3580">      MSG_PUTS_ATTR(_(</a>
<a name="ln3581">              &quot;don't quit the editor until the file is successfully written!&quot;),</a>
<a name="ln3582">          attr | MSG_HIST);</a>
<a name="ln3583"> </a>
<a name="ln3584">      /* Update the timestamp to avoid an &quot;overwrite changed file&quot;</a>
<a name="ln3585">       * prompt when writing again. */</a>
<a name="ln3586">      if (os_fileinfo((char *)fname, &amp;file_info_old)) {</a>
<a name="ln3587">        buf_store_file_info(buf, &amp;file_info_old);</a>
<a name="ln3588">        buf-&gt;b_mtime_read = buf-&gt;b_mtime;</a>
<a name="ln3589">      }</a>
<a name="ln3590">    }</a>
<a name="ln3591">  }</a>
<a name="ln3592">  msg_scroll = msg_save;</a>
<a name="ln3593"> </a>
<a name="ln3594">  /*</a>
<a name="ln3595">   * When writing the whole file and 'undofile' is set, also write the undo</a>
<a name="ln3596">   * file.</a>
<a name="ln3597">   */</a>
<a name="ln3598">  if (retval == OK &amp;&amp; write_undo_file) {</a>
<a name="ln3599">    char_u hash[UNDO_HASH_SIZE];</a>
<a name="ln3600"> </a>
<a name="ln3601">    sha256_finish(&amp;sha_ctx, hash);</a>
<a name="ln3602">    u_write_undo(NULL, FALSE, buf, hash);</a>
<a name="ln3603">  }</a>
<a name="ln3604"> </a>
<a name="ln3605">  if (!should_abort(retval)) {</a>
<a name="ln3606">    aco_save_T aco;</a>
<a name="ln3607"> </a>
<a name="ln3608">    curbuf-&gt;b_no_eol_lnum = 0;      /* in case it was set by the previous read */</a>
<a name="ln3609"> </a>
<a name="ln3610">    /*</a>
<a name="ln3611">     * Apply POST autocommands.</a>
<a name="ln3612">     * Careful: The autocommands may call buf_write() recursively!</a>
<a name="ln3613">     */</a>
<a name="ln3614">    aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln3615"> </a>
<a name="ln3616">    if (append)</a>
<a name="ln3617">      apply_autocmds_exarg(EVENT_FILEAPPENDPOST, fname, fname,</a>
<a name="ln3618">          FALSE, curbuf, eap);</a>
<a name="ln3619">    else if (filtering)</a>
<a name="ln3620">      apply_autocmds_exarg(EVENT_FILTERWRITEPOST, NULL, fname,</a>
<a name="ln3621">          FALSE, curbuf, eap);</a>
<a name="ln3622">    else if (reset_changed &amp;&amp; whole)</a>
<a name="ln3623">      apply_autocmds_exarg(EVENT_BUFWRITEPOST, fname, fname,</a>
<a name="ln3624">          FALSE, curbuf, eap);</a>
<a name="ln3625">    else</a>
<a name="ln3626">      apply_autocmds_exarg(EVENT_FILEWRITEPOST, fname, fname,</a>
<a name="ln3627">          FALSE, curbuf, eap);</a>
<a name="ln3628"> </a>
<a name="ln3629">    /* restore curwin/curbuf and a few other things */</a>
<a name="ln3630">    aucmd_restbuf(&amp;aco);</a>
<a name="ln3631"> </a>
<a name="ln3632">    if (aborting())         /* autocmds may abort script processing */</a>
<a name="ln3633">      retval = FALSE;</a>
<a name="ln3634">  }</a>
<a name="ln3635"> </a>
<a name="ln3636">  got_int |= prev_got_int;</a>
<a name="ln3637"> </a>
<a name="ln3638">  return retval;</a>
<a name="ln3639">#undef SET_ERRMSG</a>
<a name="ln3640">#undef SET_ERRMSG_ARG</a>
<a name="ln3641">#undef SET_ERRMSG_NUM</a>
<a name="ln3642">}</a>
<a name="ln3643"> </a>
<a name="ln3644">/*</a>
<a name="ln3645"> * Set the name of the current buffer.  Use when the buffer doesn't have a</a>
<a name="ln3646"> * name and a &quot;:r&quot; or &quot;:w&quot; command with a file name is used.</a>
<a name="ln3647"> */</a>
<a name="ln3648">static int set_rw_fname(char_u *fname, char_u *sfname)</a>
<a name="ln3649">{</a>
<a name="ln3650">  buf_T       *buf = curbuf;</a>
<a name="ln3651"> </a>
<a name="ln3652">  /* It's like the unnamed buffer is deleted.... */</a>
<a name="ln3653">  if (curbuf-&gt;b_p_bl)</a>
<a name="ln3654">    apply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);</a>
<a name="ln3655">  apply_autocmds(EVENT_BUFWIPEOUT, NULL, NULL, FALSE, curbuf);</a>
<a name="ln3656">  if (aborting())           /* autocmds may abort script processing */</a>
<a name="ln3657">    return FAIL;</a>
<a name="ln3658">  if (curbuf != buf) {</a>
<a name="ln3659">    /* We are in another buffer now, don't do the renaming. */</a>
<a name="ln3660">    EMSG(_(e_auchangedbuf));</a>
<a name="ln3661">    return FAIL;</a>
<a name="ln3662">  }</a>
<a name="ln3663"> </a>
<a name="ln3664">  if (setfname(curbuf, fname, sfname, false) == OK) {</a>
<a name="ln3665">    curbuf-&gt;b_flags |= BF_NOTEDITED;</a>
<a name="ln3666">  }</a>
<a name="ln3667"> </a>
<a name="ln3668">  /* ....and a new named one is created */</a>
<a name="ln3669">  apply_autocmds(EVENT_BUFNEW, NULL, NULL, FALSE, curbuf);</a>
<a name="ln3670">  if (curbuf-&gt;b_p_bl)</a>
<a name="ln3671">    apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, curbuf);</a>
<a name="ln3672">  if (aborting())           /* autocmds may abort script processing */</a>
<a name="ln3673">    return FAIL;</a>
<a name="ln3674"> </a>
<a name="ln3675">  /* Do filetype detection now if 'filetype' is empty. */</a>
<a name="ln3676">  if (*curbuf-&gt;b_p_ft == NUL) {</a>
<a name="ln3677">    if (au_has_group((char_u *)&quot;filetypedetect&quot;)) {</a>
<a name="ln3678">      (void)do_doautocmd((char_u *)&quot;filetypedetect BufRead&quot;, false, NULL);</a>
<a name="ln3679">    }</a>
<a name="ln3680">    do_modelines(0);</a>
<a name="ln3681">  }</a>
<a name="ln3682"> </a>
<a name="ln3683">  return OK;</a>
<a name="ln3684">}</a>
<a name="ln3685"> </a>
<a name="ln3686">/// Put file name into the specified buffer with quotes</a>
<a name="ln3687">///</a>
<a name="ln3688">/// Replaces home directory at the start with `~`.</a>
<a name="ln3689">///</a>
<a name="ln3690">/// @param[out]  ret_buf  Buffer to save results to.</a>
<a name="ln3691">/// @param[in]  buf_len  ret_buf length.</a>
<a name="ln3692">/// @param[in]  buf  buf_T file name is coming from.</a>
<a name="ln3693">/// @param[in]  fname  File name to write.</a>
<a name="ln3694">static void add_quoted_fname(char *const ret_buf, const size_t buf_len,</a>
<a name="ln3695">                             const buf_T *const buf, const char *fname)</a>
<a name="ln3696">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln3697">{</a>
<a name="ln3698">  if (fname == NULL) {</a>
<a name="ln3699">    fname = &quot;-stdin-&quot;;</a>
<a name="ln3700">  }</a>
<a name="ln3701">  ret_buf[0] = '&quot;';</a>
<a name="ln3702">  home_replace(buf, (const char_u *)fname, (char_u *)ret_buf + 1,</a>
<a name="ln3703">               (int)buf_len - 4, true);</a>
<a name="ln3704">  xstrlcat(ret_buf, &quot;\&quot; &quot;, buf_len);</a>
<a name="ln3705">}</a>
<a name="ln3706"> </a>
<a name="ln3707">/// Append message for text mode to IObuff.</a>
<a name="ln3708">///</a>
<a name="ln3709">/// @param eol_type line ending type</a>
<a name="ln3710">///</a>
<a name="ln3711">/// @return true if something was appended.</a>
<a name="ln3712">static bool msg_add_fileformat(int eol_type)</a>
<a name="ln3713">{</a>
<a name="ln3714">#ifndef USE_CRNL</a>
<a name="ln3715">  if (eol_type == EOL_DOS) {</a>
<a name="ln3716">    STRCAT(IObuff, shortmess(SHM_TEXT) ? _(&quot;[dos]&quot;) : _(&quot;[dos format]&quot;));</a>
<a name="ln3717">    return true;</a>
<a name="ln3718">  }</a>
<a name="ln3719">#endif</a>
<a name="ln3720">  if (eol_type == EOL_MAC) {</a>
<a name="ln3721">    STRCAT(IObuff, shortmess(SHM_TEXT) ? _(&quot;[mac]&quot;) : _(&quot;[mac format]&quot;));</a>
<a name="ln3722">    return true;</a>
<a name="ln3723">  }</a>
<a name="ln3724">#ifdef USE_CRNL</a>
<a name="ln3725">  if (eol_type == EOL_UNIX) {</a>
<a name="ln3726">    STRCAT(IObuff, shortmess(SHM_TEXT) ? _(&quot;[unix]&quot;) : _(&quot;[unix format]&quot;));</a>
<a name="ln3727">    return true;</a>
<a name="ln3728">  }</a>
<a name="ln3729">#endif</a>
<a name="ln3730">  return false;</a>
<a name="ln3731">}</a>
<a name="ln3732"> </a>
<a name="ln3733">/*</a>
<a name="ln3734"> * Append line and character count to IObuff.</a>
<a name="ln3735"> */</a>
<a name="ln3736">void msg_add_lines(int insert_space, long lnum, off_T nchars)</a>
<a name="ln3737">{</a>
<a name="ln3738">  char_u  *p;</a>
<a name="ln3739"> </a>
<a name="ln3740">  p = IObuff + STRLEN(IObuff);</a>
<a name="ln3741"> </a>
<a name="ln3742">  if (insert_space)</a>
<a name="ln3743">    *p++ = ' ';</a>
<a name="ln3744">  if (shortmess(SHM_LINES)) {</a>
<a name="ln3745">     sprintf((char *)p, &quot;%&quot; PRId64 &quot;L, %&quot; PRId64 &quot;C&quot;,</a>
<a name="ln3746">             (int64_t)lnum, (int64_t)nchars);</a>
<a name="ln3747">  }</a>
<a name="ln3748">  else {</a>
<a name="ln3749">    if (lnum == 1)</a>
<a name="ln3750">      STRCPY(p, _(&quot;1 line, &quot;));</a>
<a name="ln3751">    else</a>
<a name="ln3752">      sprintf((char *)p, _(&quot;%&quot; PRId64 &quot; lines, &quot;), (int64_t)lnum);</a>
<a name="ln3753">    p += STRLEN(p);</a>
<a name="ln3754">    if (nchars == 1)</a>
<a name="ln3755">      STRCPY(p, _(&quot;1 character&quot;));</a>
<a name="ln3756">    else {</a>
<a name="ln3757">      sprintf((char *)p, _(&quot;%&quot; PRId64 &quot; characters&quot;), (int64_t)nchars);</a>
<a name="ln3758">    }</a>
<a name="ln3759">  }</a>
<a name="ln3760">}</a>
<a name="ln3761"> </a>
<a name="ln3762">/*</a>
<a name="ln3763"> * Append message for missing line separator to IObuff.</a>
<a name="ln3764"> */</a>
<a name="ln3765">static void msg_add_eol(void)</a>
<a name="ln3766">{</a>
<a name="ln3767">  STRCAT(IObuff,</a>
<a name="ln3768">      shortmess(SHM_LAST) ? _(&quot;[noeol]&quot;) : _(&quot;[Incomplete last line]&quot;));</a>
<a name="ln3769">}</a>
<a name="ln3770"> </a>
<a name="ln3771">/*</a>
<a name="ln3772"> * Check modification time of file, before writing to it.</a>
<a name="ln3773"> * The size isn't checked, because using a tool like &quot;gzip&quot; takes care of</a>
<a name="ln3774"> * using the same timestamp but can't set the size.</a>
<a name="ln3775"> */</a>
<a name="ln3776">static int check_mtime(buf_T *buf, FileInfo *file_info)</a>
<a name="ln3777">{</a>
<a name="ln3778">  if (buf-&gt;b_mtime_read != 0</a>
<a name="ln3779">      &amp;&amp; time_differs(file_info-&gt;stat.st_mtim.tv_sec,</a>
<a name="ln3780">                      buf-&gt;b_mtime_read)) {</a>
<a name="ln3781">    msg_scroll = true;  // Don't overwrite messages here.</a>
<a name="ln3782">    msg_silent = 0;     // Must give this prompt.</a>
<a name="ln3783">    // Don't use emsg() here, don't want to flush the buffers.</a>
<a name="ln3784">    msg_attr(_(&quot;WARNING: The file has been changed since reading it!!!&quot;),</a>
<a name="ln3785">             HL_ATTR(HLF_E));</a>
<a name="ln3786">    if (ask_yesno(_(&quot;Do you really want to write to it&quot;), true) == 'n') {</a>
<a name="ln3787">      return FAIL;</a>
<a name="ln3788">    }</a>
<a name="ln3789">    msg_scroll = false;  // Always overwrite the file message now.</a>
<a name="ln3790">  }</a>
<a name="ln3791">  return OK;</a>
<a name="ln3792">}</a>
<a name="ln3793"> </a>
<a name="ln3794">/// Return true if the times differ</a>
<a name="ln3795">///</a>
<a name="ln3796">/// @param t1 first time</a>
<a name="ln3797">/// @param t2 second time</a>
<a name="ln3798">static bool time_differs(long t1, long t2) FUNC_ATTR_CONST</a>
<a name="ln3799">{</a>
<a name="ln3800">#if defined(__linux__) || defined(MSWIN)</a>
<a name="ln3801">  /* On a FAT filesystem, esp. under Linux, there are only 5 bits to store</a>
<a name="ln3802">   * the seconds.  Since the roundoff is done when flushing the inode, the</a>
<a name="ln3803">   * time may change unexpectedly by one second!!! */</a>
<a name="ln3804">  return t1 - t2 &gt; 1 || t2 - t1 &gt; 1;</a>
<a name="ln3805">#else</a>
<a name="ln3806">  return t1 != t2;</a>
<a name="ln3807">#endif</a>
<a name="ln3808">}</a>
<a name="ln3809"> </a>
<a name="ln3810">/*</a>
<a name="ln3811"> * Call write() to write a number of bytes to the file.</a>
<a name="ln3812"> * Handles 'encoding' conversion.</a>
<a name="ln3813"> *</a>
<a name="ln3814"> * Return FAIL for failure, OK otherwise.</a>
<a name="ln3815"> */</a>
<a name="ln3816">static int buf_write_bytes(struct bw_info *ip)</a>
<a name="ln3817">{</a>
<a name="ln3818">  int wlen;</a>
<a name="ln3819">  char_u      *buf = ip-&gt;bw_buf;        /* data to write */</a>
<a name="ln3820">  int len = ip-&gt;bw_len;                 /* length of data */</a>
<a name="ln3821">#ifdef HAS_BW_FLAGS</a>
<a name="ln3822">  int flags = ip-&gt;bw_flags;             /* extra flags */</a>
<a name="ln3823">#endif</a>
<a name="ln3824"> </a>
<a name="ln3825">  /*</a>
<a name="ln3826">   * Skip conversion when writing the BOM.</a>
<a name="ln3827">   */</a>
<a name="ln3828">  if (!(flags &amp; FIO_NOCONVERT)) {</a>
<a name="ln3829">    char_u          *p;</a>
<a name="ln3830">    unsigned c;</a>
<a name="ln3831">    int n;</a>
<a name="ln3832"> </a>
<a name="ln3833">    if (flags &amp; FIO_UTF8) {</a>
<a name="ln3834">      /*</a>
<a name="ln3835">       * Convert latin1 in the buffer to UTF-8 in the file.</a>
<a name="ln3836">       */</a>
<a name="ln3837">      p = ip-&gt;bw_conv_buf;              /* translate to buffer */</a>
<a name="ln3838">      for (wlen = 0; wlen &lt; len; ++wlen)</a>
<a name="ln3839">        p += utf_char2bytes(buf[wlen], p);</a>
<a name="ln3840">      buf = ip-&gt;bw_conv_buf;</a>
<a name="ln3841">      len = (int)(p - ip-&gt;bw_conv_buf);</a>
<a name="ln3842">    } else if (flags &amp; (FIO_UCS4 | FIO_UTF16 | FIO_UCS2 | FIO_LATIN1)) {</a>
<a name="ln3843">      /*</a>
<a name="ln3844">       * Convert UTF-8 bytes in the buffer to UCS-2, UCS-4, UTF-16 or</a>
<a name="ln3845">       * Latin1 chars in the file.</a>
<a name="ln3846">       */</a>
<a name="ln3847">      if (flags &amp; FIO_LATIN1)</a>
<a name="ln3848">        p = buf;                /* translate in-place (can only get shorter) */</a>
<a name="ln3849">      else</a>
<a name="ln3850">        p = ip-&gt;bw_conv_buf;            /* translate to buffer */</a>
<a name="ln3851">      for (wlen = 0; wlen &lt; len; wlen += n) {</a>
<a name="ln3852">        if (wlen == 0 &amp;&amp; ip-&gt;bw_restlen != 0) {</a>
<a name="ln3853">          int l;</a>
<a name="ln3854"> </a>
<a name="ln3855">          /* Use remainder of previous call.  Append the start of</a>
<a name="ln3856">           * buf[] to get a full sequence.  Might still be too</a>
<a name="ln3857">           * short! */</a>
<a name="ln3858">          l = CONV_RESTLEN - ip-&gt;bw_restlen;</a>
<a name="ln3859">          if (l &gt; len)</a>
<a name="ln3860">            l = len;</a>
<a name="ln3861">          memmove(ip-&gt;bw_rest + ip-&gt;bw_restlen, buf, (size_t)l);</a>
<a name="ln3862">          n = utf_ptr2len_len(ip-&gt;bw_rest, ip-&gt;bw_restlen + l);</a>
<a name="ln3863">          if (n &gt; ip-&gt;bw_restlen + len) {</a>
<a name="ln3864">            /* We have an incomplete byte sequence at the end to</a>
<a name="ln3865">             * be written.  We can't convert it without the</a>
<a name="ln3866">             * remaining bytes.  Keep them for the next call. */</a>
<a name="ln3867">            if (ip-&gt;bw_restlen + len &gt; CONV_RESTLEN)</a>
<a name="ln3868">              return FAIL;</a>
<a name="ln3869">            ip-&gt;bw_restlen += len;</a>
<a name="ln3870">            break;</a>
<a name="ln3871">          }</a>
<a name="ln3872">          if (n &gt; 1)</a>
<a name="ln3873">            c = utf_ptr2char(ip-&gt;bw_rest);</a>
<a name="ln3874">          else</a>
<a name="ln3875">            c = ip-&gt;bw_rest[0];</a>
<a name="ln3876">          if (n &gt;= ip-&gt;bw_restlen) {</a>
<a name="ln3877">            n -= ip-&gt;bw_restlen;</a>
<a name="ln3878">            ip-&gt;bw_restlen = 0;</a>
<a name="ln3879">          } else {</a>
<a name="ln3880">            ip-&gt;bw_restlen -= n;</a>
<a name="ln3881">            memmove(ip-&gt;bw_rest, ip-&gt;bw_rest + n,</a>
<a name="ln3882">                (size_t)ip-&gt;bw_restlen);</a>
<a name="ln3883">            n = 0;</a>
<a name="ln3884">          }</a>
<a name="ln3885">        } else {</a>
<a name="ln3886">          n = utf_ptr2len_len(buf + wlen, len - wlen);</a>
<a name="ln3887">          if (n &gt; len - wlen) {</a>
<a name="ln3888">            /* We have an incomplete byte sequence at the end to</a>
<a name="ln3889">             * be written.  We can't convert it without the</a>
<a name="ln3890">             * remaining bytes.  Keep them for the next call. */</a>
<a name="ln3891">            if (len - wlen &gt; CONV_RESTLEN)</a>
<a name="ln3892">              return FAIL;</a>
<a name="ln3893">            ip-&gt;bw_restlen = len - wlen;</a>
<a name="ln3894">            memmove(ip-&gt;bw_rest, buf + wlen,</a>
<a name="ln3895">                (size_t)ip-&gt;bw_restlen);</a>
<a name="ln3896">            break;</a>
<a name="ln3897">          }</a>
<a name="ln3898">          if (n &gt; 1)</a>
<a name="ln3899">            c = utf_ptr2char(buf + wlen);</a>
<a name="ln3900">          else</a>
<a name="ln3901">            c = buf[wlen];</a>
<a name="ln3902">        }</a>
<a name="ln3903"> </a>
<a name="ln3904">        if (ucs2bytes(c, &amp;p, flags) &amp;&amp; !ip-&gt;bw_conv_error) {</a>
<a name="ln3905">          ip-&gt;bw_conv_error = TRUE;</a>
<a name="ln3906">          ip-&gt;bw_conv_error_lnum = ip-&gt;bw_start_lnum;</a>
<a name="ln3907">        }</a>
<a name="ln3908">        if (c == NL)</a>
<a name="ln3909">          ++ip-&gt;bw_start_lnum;</a>
<a name="ln3910">      }</a>
<a name="ln3911">      if (flags &amp; FIO_LATIN1)</a>
<a name="ln3912">        len = (int)(p - buf);</a>
<a name="ln3913">      else {</a>
<a name="ln3914">        buf = ip-&gt;bw_conv_buf;</a>
<a name="ln3915">        len = (int)(p - ip-&gt;bw_conv_buf);</a>
<a name="ln3916">      }</a>
<a name="ln3917">    }</a>
<a name="ln3918"> </a>
<a name="ln3919"># ifdef HAVE_ICONV</a>
<a name="ln3920">    if (ip-&gt;bw_iconv_fd != (iconv_t)-1) {</a>
<a name="ln3921">      const char  *from;</a>
<a name="ln3922">      size_t fromlen;</a>
<a name="ln3923">      char        *to;</a>
<a name="ln3924">      size_t tolen;</a>
<a name="ln3925"> </a>
<a name="ln3926">      /* Convert with iconv(). */</a>
<a name="ln3927">      if (ip-&gt;bw_restlen &gt; 0) {</a>
<a name="ln3928">        char *fp;</a>
<a name="ln3929"> </a>
<a name="ln3930">        /* Need to concatenate the remainder of the previous call and</a>
<a name="ln3931">         * the bytes of the current call.  Use the end of the</a>
<a name="ln3932">         * conversion buffer for this. */</a>
<a name="ln3933">        fromlen = len + ip-&gt;bw_restlen;</a>
<a name="ln3934">        fp = (char *)ip-&gt;bw_conv_buf + ip-&gt;bw_conv_buflen - fromlen;</a>
<a name="ln3935">        memmove(fp, ip-&gt;bw_rest, (size_t)ip-&gt;bw_restlen);</a>
<a name="ln3936">        memmove(fp + ip-&gt;bw_restlen, buf, (size_t)len);</a>
<a name="ln3937">        from = fp;</a>
<a name="ln3938">        tolen = ip-&gt;bw_conv_buflen - fromlen;</a>
<a name="ln3939">      } else {</a>
<a name="ln3940">        from = (const char *)buf;</a>
<a name="ln3941">        fromlen = len;</a>
<a name="ln3942">        tolen = ip-&gt;bw_conv_buflen;</a>
<a name="ln3943">      }</a>
<a name="ln3944">      to = (char *)ip-&gt;bw_conv_buf;</a>
<a name="ln3945"> </a>
<a name="ln3946">      if (ip-&gt;bw_first) {</a>
<a name="ln3947">        size_t save_len = tolen;</a>
<a name="ln3948"> </a>
<a name="ln3949">        /* output the initial shift state sequence */</a>
<a name="ln3950">        (void)iconv(ip-&gt;bw_iconv_fd, NULL, NULL, &amp;to, &amp;tolen);</a>
<a name="ln3951"> </a>
<a name="ln3952">        /* There is a bug in iconv() on Linux (which appears to be</a>
<a name="ln3953">         * wide-spread) which sets &quot;to&quot; to NULL and messes up &quot;tolen&quot;.</a>
<a name="ln3954">         */</a>
<a name="ln3955">        if (to == NULL) {</a>
<a name="ln3956">          to = (char *)ip-&gt;bw_conv_buf;</a>
<a name="ln3957">          tolen = save_len;</a>
<a name="ln3958">        }</a>
<a name="ln3959">        ip-&gt;bw_first = FALSE;</a>
<a name="ln3960">      }</a>
<a name="ln3961"> </a>
<a name="ln3962">      /*</a>
<a name="ln3963">       * If iconv() has an error or there is not enough room, fail.</a>
<a name="ln3964">       */</a>
<a name="ln3965">      if ((iconv(ip-&gt;bw_iconv_fd, (void *)&amp;from, &amp;fromlen, &amp;to, &amp;tolen)</a>
<a name="ln3966">           == (size_t)-1 &amp;&amp; ICONV_ERRNO != ICONV_EINVAL)</a>
<a name="ln3967">          || fromlen &gt; CONV_RESTLEN) {</a>
<a name="ln3968">        ip-&gt;bw_conv_error = TRUE;</a>
<a name="ln3969">        return FAIL;</a>
<a name="ln3970">      }</a>
<a name="ln3971"> </a>
<a name="ln3972">      /* copy remainder to ip-&gt;bw_rest[] to be used for the next call. */</a>
<a name="ln3973">      if (fromlen &gt; 0)</a>
<a name="ln3974">        memmove(ip-&gt;bw_rest, (void *)from, fromlen);</a>
<a name="ln3975">      ip-&gt;bw_restlen = (int)fromlen;</a>
<a name="ln3976"> </a>
<a name="ln3977">      buf = ip-&gt;bw_conv_buf;</a>
<a name="ln3978">      len = (int)((char_u *)to - ip-&gt;bw_conv_buf);</a>
<a name="ln3979">    }</a>
<a name="ln3980"># endif</a>
<a name="ln3981">  }</a>
<a name="ln3982"> </a>
<a name="ln3983">  if (ip-&gt;bw_fd &lt; 0) {</a>
<a name="ln3984">    // Only checking conversion, which is OK if we get here.</a>
<a name="ln3985">    return OK;</a>
<a name="ln3986">  }</a>
<a name="ln3987">  wlen = write_eintr(ip-&gt;bw_fd, buf, len);</a>
<a name="ln3988">  return (wlen &lt; len) ? FAIL : OK;</a>
<a name="ln3989">}</a>
<a name="ln3990"> </a>
<a name="ln3991">/// Convert a Unicode character to bytes.</a>
<a name="ln3992">///</a>
<a name="ln3993">/// @param c character to convert</a>
<a name="ln3994">/// @param[in,out] pp pointer to store the result at</a>
<a name="ln3995">/// @param flags FIO_ flags that specify which encoding to use</a>
<a name="ln3996">///</a>
<a name="ln3997">/// @return true for an error, false when it's OK.</a>
<a name="ln3998">static bool ucs2bytes(unsigned c, char_u **pp, int flags) FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3999">{</a>
<a name="ln4000">  char_u      *p = *pp;</a>
<a name="ln4001">  bool error = false;</a>
<a name="ln4002">  int cc;</a>
<a name="ln4003"> </a>
<a name="ln4004"> </a>
<a name="ln4005">  if (flags &amp; FIO_UCS4) {</a>
<a name="ln4006">    if (flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln4007">      *p++ = c;</a>
<a name="ln4008">      *p++ = (c &gt;&gt; 8);</a>
<a name="ln4009">      *p++ = (c &gt;&gt; 16);</a>
<a name="ln4010">      *p++ = (c &gt;&gt; 24);</a>
<a name="ln4011">    } else {</a>
<a name="ln4012">      *p++ = (c &gt;&gt; 24);</a>
<a name="ln4013">      *p++ = (c &gt;&gt; 16);</a>
<a name="ln4014">      *p++ = (c &gt;&gt; 8);</a>
<a name="ln4015">      *p++ = c;</a>
<a name="ln4016">    }</a>
<a name="ln4017">  } else if (flags &amp; (FIO_UCS2 | FIO_UTF16)) {</a>
<a name="ln4018">    if (c &gt;= 0x10000) {</a>
<a name="ln4019">      if (flags &amp; FIO_UTF16) {</a>
<a name="ln4020">        /* Make two words, ten bits of the character in each.  First</a>
<a name="ln4021">         * word is 0xd800 - 0xdbff, second one 0xdc00 - 0xdfff */</a>
<a name="ln4022">        c -= 0x10000;</a>
<a name="ln4023">        if (c &gt;= 0x100000) {</a>
<a name="ln4024">          error = true;</a>
<a name="ln4025">        }</a>
<a name="ln4026">        cc = ((c &gt;&gt; 10) &amp; 0x3ff) + 0xd800;</a>
<a name="ln4027">        if (flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln4028">          *p++ = cc;</a>
<a name="ln4029">          *p++ = ((unsigned)cc &gt;&gt; 8);</a>
<a name="ln4030">        } else {</a>
<a name="ln4031">          *p++ = ((unsigned)cc &gt;&gt; 8);</a>
<a name="ln4032">          *p++ = cc;</a>
<a name="ln4033">        }</a>
<a name="ln4034">        c = (c &amp; 0x3ff) + 0xdc00;</a>
<a name="ln4035">      } else {</a>
<a name="ln4036">        error = true;</a>
<a name="ln4037">      }</a>
<a name="ln4038">    }</a>
<a name="ln4039">    if (flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln4040">      *p++ = c;</a>
<a name="ln4041">      *p++ = (c &gt;&gt; 8);</a>
<a name="ln4042">    } else {</a>
<a name="ln4043">      *p++ = (c &gt;&gt; 8);</a>
<a name="ln4044">      *p++ = c;</a>
<a name="ln4045">    }</a>
<a name="ln4046">  } else { /* Latin1 */</a>
<a name="ln4047">    if (c &gt;= 0x100) {</a>
<a name="ln4048">      error = true;</a>
<a name="ln4049">      *p++ = 0xBF;</a>
<a name="ln4050">    } else</a>
<a name="ln4051">      *p++ = c;</a>
<a name="ln4052">  }</a>
<a name="ln4053"> </a>
<a name="ln4054">  *pp = p;</a>
<a name="ln4055">  return error;</a>
<a name="ln4056">}</a>
<a name="ln4057"> </a>
<a name="ln4058">/// Return true if file encoding &quot;fenc&quot; requires conversion from or to</a>
<a name="ln4059">/// 'encoding'.</a>
<a name="ln4060">///</a>
<a name="ln4061">/// @param fenc file encoding to check</a>
<a name="ln4062">///</a>
<a name="ln4063">/// @return true if conversion is required</a>
<a name="ln4064">static bool need_conversion(const char_u *fenc)</a>
<a name="ln4065">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4066">{</a>
<a name="ln4067">  int same_encoding;</a>
<a name="ln4068">  int enc_flags;</a>
<a name="ln4069">  int fenc_flags;</a>
<a name="ln4070"> </a>
<a name="ln4071">  if (*fenc == NUL || STRCMP(p_enc, fenc) == 0) {</a>
<a name="ln4072">    same_encoding = TRUE;</a>
<a name="ln4073">    fenc_flags = 0;</a>
<a name="ln4074">  } else {</a>
<a name="ln4075">    /* Ignore difference between &quot;ansi&quot; and &quot;latin1&quot;, &quot;ucs-4&quot; and</a>
<a name="ln4076">     * &quot;ucs-4be&quot;, etc. */</a>
<a name="ln4077">    enc_flags = get_fio_flags(p_enc);</a>
<a name="ln4078">    fenc_flags = get_fio_flags(fenc);</a>
<a name="ln4079">    same_encoding = (enc_flags != 0 &amp;&amp; fenc_flags == enc_flags);</a>
<a name="ln4080">  }</a>
<a name="ln4081">  if (same_encoding) {</a>
<a name="ln4082">    // Specified file encoding matches UTF-8.</a>
<a name="ln4083">    return false;</a>
<a name="ln4084">  }</a>
<a name="ln4085"> </a>
<a name="ln4086">  /* Encodings differ.  However, conversion is not needed when 'enc' is any</a>
<a name="ln4087">   * Unicode encoding and the file is UTF-8. */</a>
<a name="ln4088">  return !(fenc_flags == FIO_UTF8);</a>
<a name="ln4089">}</a>
<a name="ln4090"> </a>
<a name="ln4091">/// Return the FIO_ flags needed for the internal conversion if 'name' was</a>
<a name="ln4092">/// unicode or latin1, otherwise 0. If &quot;name&quot; is an empty string,</a>
<a name="ln4093">/// use 'encoding'.</a>
<a name="ln4094">///</a>
<a name="ln4095">/// @param name string to check for encoding</a>
<a name="ln4096">static int get_fio_flags(const char_u *name)</a>
<a name="ln4097">{</a>
<a name="ln4098">  int prop;</a>
<a name="ln4099"> </a>
<a name="ln4100">  if (*name == NUL) {</a>
<a name="ln4101">    name = p_enc;</a>
<a name="ln4102">  }</a>
<a name="ln4103">  prop = enc_canon_props(name);</a>
<a name="ln4104">  if (prop &amp; ENC_UNICODE) {</a>
<a name="ln4105">    if (prop &amp; ENC_2BYTE) {</a>
<a name="ln4106">      if (prop &amp; ENC_ENDIAN_L)</a>
<a name="ln4107">        return FIO_UCS2 | FIO_ENDIAN_L;</a>
<a name="ln4108">      return FIO_UCS2;</a>
<a name="ln4109">    }</a>
<a name="ln4110">    if (prop &amp; ENC_4BYTE) {</a>
<a name="ln4111">      if (prop &amp; ENC_ENDIAN_L)</a>
<a name="ln4112">        return FIO_UCS4 | FIO_ENDIAN_L;</a>
<a name="ln4113">      return FIO_UCS4;</a>
<a name="ln4114">    }</a>
<a name="ln4115">    if (prop &amp; ENC_2WORD) {</a>
<a name="ln4116">      if (prop &amp; ENC_ENDIAN_L)</a>
<a name="ln4117">        return FIO_UTF16 | FIO_ENDIAN_L;</a>
<a name="ln4118">      return FIO_UTF16;</a>
<a name="ln4119">    }</a>
<a name="ln4120">    return FIO_UTF8;</a>
<a name="ln4121">  }</a>
<a name="ln4122">  if (prop &amp; ENC_LATIN1)</a>
<a name="ln4123">    return FIO_LATIN1;</a>
<a name="ln4124">  /* must be ENC_DBCS, requires iconv() */</a>
<a name="ln4125">  return 0;</a>
<a name="ln4126">}</a>
<a name="ln4127"> </a>
<a name="ln4128"> </a>
<a name="ln4129"> </a>
<a name="ln4130">/*</a>
<a name="ln4131"> * Check for a Unicode BOM (Byte Order Mark) at the start of p[size].</a>
<a name="ln4132"> * &quot;size&quot; must be at least 2.</a>
<a name="ln4133"> * Return the name of the encoding and set &quot;*lenp&quot; to the length.</a>
<a name="ln4134"> * Returns NULL when no BOM found.</a>
<a name="ln4135"> */</a>
<a name="ln4136">static char_u *check_for_bom(char_u *p, long size, int *lenp, int flags)</a>
<a name="ln4137">{</a>
<a name="ln4138">  char        *name = NULL;</a>
<a name="ln4139">  int len = 2;</a>
<a name="ln4140"> </a>
<a name="ln4141">  if (p[0] == 0xef &amp;&amp; p[1] == 0xbb &amp;&amp; size &gt;= 3 &amp;&amp; p[2] == 0xbf</a>
<a name="ln4142">      &amp;&amp; (flags == FIO_ALL || flags == FIO_UTF8 || flags == 0)) {</a>
<a name="ln4143">    name = &quot;utf-8&quot;;             /* EF BB BF */</a>
<a name="ln4144">    len = 3;</a>
<a name="ln4145">  } else if (p[0] == 0xff &amp;&amp; p[1] == 0xfe) {</a>
<a name="ln4146">    if (size &gt;= 4 &amp;&amp; p[2] == 0 &amp;&amp; p[3] == 0</a>
<a name="ln4147">        &amp;&amp; (flags == FIO_ALL || flags == (FIO_UCS4 | FIO_ENDIAN_L))) {</a>
<a name="ln4148">      name = &quot;ucs-4le&quot;;         /* FF FE 00 00 */</a>
<a name="ln4149">      len = 4;</a>
<a name="ln4150">    } else if (flags == (FIO_UCS2 | FIO_ENDIAN_L))</a>
<a name="ln4151">      name = &quot;ucs-2le&quot;;         /* FF FE */</a>
<a name="ln4152">    else if (flags == FIO_ALL || flags == (FIO_UTF16 | FIO_ENDIAN_L))</a>
<a name="ln4153">      /* utf-16le is preferred, it also works for ucs-2le text */</a>
<a name="ln4154">      name = &quot;utf-16le&quot;;        /* FF FE */</a>
<a name="ln4155">  } else if (p[0] == 0xfe &amp;&amp; p[1] == 0xff</a>
<a name="ln4156">             &amp;&amp; (flags == FIO_ALL || flags == FIO_UCS2 || flags ==</a>
<a name="ln4157">                 FIO_UTF16)) {</a>
<a name="ln4158">    /* Default to utf-16, it works also for ucs-2 text. */</a>
<a name="ln4159">    if (flags == FIO_UCS2)</a>
<a name="ln4160">      name = &quot;ucs-2&quot;;           /* FE FF */</a>
<a name="ln4161">    else</a>
<a name="ln4162">      name = &quot;utf-16&quot;;          /* FE FF */</a>
<a name="ln4163">  } else if (size &gt;= 4 &amp;&amp; p[0] == 0 &amp;&amp; p[1] == 0 &amp;&amp; p[2] == 0xfe</a>
<a name="ln4164">             &amp;&amp; p[3] == 0xff &amp;&amp; (flags == FIO_ALL || flags == FIO_UCS4)) {</a>
<a name="ln4165">    name = &quot;ucs-4&quot;;             /* 00 00 FE FF */</a>
<a name="ln4166">    len = 4;</a>
<a name="ln4167">  }</a>
<a name="ln4168"> </a>
<a name="ln4169">  *lenp = len;</a>
<a name="ln4170">  return (char_u *)name;</a>
<a name="ln4171">}</a>
<a name="ln4172"> </a>
<a name="ln4173">/*</a>
<a name="ln4174"> * Generate a BOM in &quot;buf[4]&quot; for encoding &quot;name&quot;.</a>
<a name="ln4175"> * Return the length of the BOM (zero when no BOM).</a>
<a name="ln4176"> */</a>
<a name="ln4177">static int make_bom(char_u *buf, char_u *name)</a>
<a name="ln4178">{</a>
<a name="ln4179">  int flags;</a>
<a name="ln4180">  char_u      *p;</a>
<a name="ln4181"> </a>
<a name="ln4182">  flags = get_fio_flags(name);</a>
<a name="ln4183"> </a>
<a name="ln4184">  /* Can't put a BOM in a non-Unicode file. */</a>
<a name="ln4185">  if (flags == FIO_LATIN1 || flags == 0)</a>
<a name="ln4186">    return 0;</a>
<a name="ln4187"> </a>
<a name="ln4188">  if (flags == FIO_UTF8) {      /* UTF-8 */</a>
<a name="ln4189">    buf[0] = 0xef;</a>
<a name="ln4190">    buf[1] = 0xbb;</a>
<a name="ln4191">    buf[2] = 0xbf;</a>
<a name="ln4192">    return 3;</a>
<a name="ln4193">  }</a>
<a name="ln4194">  p = buf;</a>
<a name="ln4195">  (void)ucs2bytes(0xfeff, &amp;p, flags);</a>
<a name="ln4196">  return (int)(p - buf);</a>
<a name="ln4197">}</a>
<a name="ln4198"> </a>
<a name="ln4199">/// Shorten filename of a buffer.</a>
<a name="ln4200">/// When &quot;force&quot; is TRUE: Use full path from now on for files currently being</a>
<a name="ln4201">/// edited, both for file name and swap file name.  Try to shorten the file</a>
<a name="ln4202">/// names a bit, if safe to do so.</a>
<a name="ln4203">/// When &quot;force&quot; is FALSE: Only try to shorten absolute file names.</a>
<a name="ln4204">/// For buffers that have buftype &quot;nofile&quot; or &quot;scratch&quot;: never change the file</a>
<a name="ln4205">/// name.</a>
<a name="ln4206">void shorten_buf_fname(buf_T *buf, char_u *dirname, int force)</a>
<a name="ln4207">{</a>
<a name="ln4208">  char_u      *p;</a>
<a name="ln4209"> </a>
<a name="ln4210">  if (buf-&gt;b_fname != NULL</a>
<a name="ln4211">      &amp;&amp; !bt_nofile(buf)</a>
<a name="ln4212">      &amp;&amp; !path_with_url((char *)buf-&gt;b_fname)</a>
<a name="ln4213">      &amp;&amp; (force</a>
<a name="ln4214">          || buf-&gt;b_sfname == NULL</a>
<a name="ln4215">          || path_is_absolute(buf-&gt;b_sfname))) {</a>
<a name="ln4216">    if (buf-&gt;b_sfname != buf-&gt;b_ffname) {</a>
<a name="ln4217">      XFREE_CLEAR(buf-&gt;b_sfname);</a>
<a name="ln4218">    }</a>
<a name="ln4219">    p = path_shorten_fname(buf-&gt;b_ffname, dirname);</a>
<a name="ln4220">    if (p != NULL) {</a>
<a name="ln4221">      buf-&gt;b_sfname = vim_strsave(p);</a>
<a name="ln4222">      buf-&gt;b_fname = buf-&gt;b_sfname;</a>
<a name="ln4223">    }</a>
<a name="ln4224">    if (p == NULL) {</a>
<a name="ln4225">      buf-&gt;b_fname = buf-&gt;b_ffname;</a>
<a name="ln4226">    }</a>
<a name="ln4227">  }</a>
<a name="ln4228">}</a>
<a name="ln4229"> </a>
<a name="ln4230">/// Shorten filenames for all buffers.</a>
<a name="ln4231">void shorten_fnames(int force)</a>
<a name="ln4232">{</a>
<a name="ln4233">  char_u dirname[MAXPATHL];</a>
<a name="ln4234"> </a>
<a name="ln4235">  os_dirname(dirname, MAXPATHL);</a>
<a name="ln4236">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln4237">      shorten_buf_fname(buf, dirname, force);</a>
<a name="ln4238"> </a>
<a name="ln4239">    // Always make the swap file name a full path, a &quot;nofile&quot; buffer may</a>
<a name="ln4240">    // also have a swap file.</a>
<a name="ln4241">    mf_fullname(buf-&gt;b_ml.ml_mfp);</a>
<a name="ln4242">  }</a>
<a name="ln4243">  status_redraw_all();</a>
<a name="ln4244">  redraw_tabline = TRUE;</a>
<a name="ln4245">}</a>
<a name="ln4246"> </a>
<a name="ln4247">/// Get new filename ended by given extension.</a>
<a name="ln4248">///</a>
<a name="ln4249">/// @param fname        The original filename.</a>
<a name="ln4250">///                     If NULL, use current directory name and ext to</a>
<a name="ln4251">///                     compute new filename.</a>
<a name="ln4252">/// @param ext          The extension to add to the filename.</a>
<a name="ln4253">///                     4 chars max if prefixed with a dot, 3 otherwise.</a>
<a name="ln4254">/// @param prepend_dot  If true, prefix ext with a dot.</a>
<a name="ln4255">///                     Does nothing if ext already starts with a dot, or</a>
<a name="ln4256">///                     if fname is NULL.</a>
<a name="ln4257">///</a>
<a name="ln4258">/// @return [allocated] - A new filename, made up from:</a>
<a name="ln4259">///                       * fname + ext, if fname not NULL.</a>
<a name="ln4260">///                       * current dir + ext, if fname is NULL.</a>
<a name="ln4261">///                       Result is guaranteed to:</a>
<a name="ln4262">///                       * be ended by &lt;ext&gt;.</a>
<a name="ln4263">///                       * have a basename with at most BASENAMELEN chars:</a>
<a name="ln4264">///                         original basename is truncated if necessary.</a>
<a name="ln4265">///                       * be different than original: basename chars are</a>
<a name="ln4266">///                         replaced by &quot;_&quot; if necessary. If that can't be done</a>
<a name="ln4267">///                         because truncated value of original filename was</a>
<a name="ln4268">///                         made of all underscores, replace first &quot;_&quot; by &quot;v&quot;.</a>
<a name="ln4269">///                     - NULL, if fname is NULL and there was a problem trying</a>
<a name="ln4270">///                       to get current directory.</a>
<a name="ln4271">char *modname(const char *fname, const char *ext, bool prepend_dot)</a>
<a name="ln4272">  FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln4273">{</a>
<a name="ln4274">  char *retval;</a>
<a name="ln4275">  size_t fnamelen;</a>
<a name="ln4276">  size_t extlen = strlen(ext);</a>
<a name="ln4277"> </a>
<a name="ln4278">  // If there is no file name we must get the name of the current directory</a>
<a name="ln4279">  // (we need the full path in case :cd is used).</a>
<a name="ln4280">  if (fname == NULL || *fname == NUL) {</a>
<a name="ln4281">    retval = xmalloc(MAXPATHL + extlen + 3);  // +3 for PATHSEP, &quot;_&quot; (Win), NUL</a>
<a name="ln4282">    if (os_dirname((char_u *)retval, MAXPATHL) == FAIL</a>
<a name="ln4283">        || strlen(retval) == 0) {</a>
<a name="ln4284">      xfree(retval);</a>
<a name="ln4285">      return NULL;</a>
<a name="ln4286">    }</a>
<a name="ln4287">    add_pathsep(retval);</a>
<a name="ln4288">    fnamelen = strlen(retval);</a>
<a name="ln4289">    prepend_dot = FALSE;  // nothing to prepend a dot to</a>
<a name="ln4290">  } else {</a>
<a name="ln4291">    fnamelen = strlen(fname);</a>
<a name="ln4292">    retval = xmalloc(fnamelen + extlen + 3);</a>
<a name="ln4293">    strcpy(retval, fname);</a>
<a name="ln4294">  }</a>
<a name="ln4295"> </a>
<a name="ln4296">  // Search backwards until we hit a '/', '\' or ':'.</a>
<a name="ln4297">  // Then truncate what is after the '/', '\' or ':' to BASENAMELEN characters.</a>
<a name="ln4298">  char *ptr = NULL;</a>
<a name="ln4299">  for (ptr = retval + fnamelen; ptr &gt; retval; MB_PTR_BACK(retval, ptr)) {</a>
<a name="ln4300">    if (vim_ispathsep(*ptr)) {</a>
<a name="ln4301">      ptr++;</a>
<a name="ln4302">      break;</a>
<a name="ln4303">    }</a>
<a name="ln4304">  }</a>
<a name="ln4305"> </a>
<a name="ln4306">  // the file name has at most BASENAMELEN characters.</a>
<a name="ln4307">  if (strlen(ptr) &gt; BASENAMELEN) {</a>
<a name="ln4308">    ptr[BASENAMELEN] = '\0';</a>
<a name="ln4309">  }</a>
<a name="ln4310"> </a>
<a name="ln4311">  char *s;</a>
<a name="ln4312">  s = ptr + strlen(ptr);</a>
<a name="ln4313"> </a>
<a name="ln4314">  // Append the extension.</a>
<a name="ln4315">  // ext can start with '.' and cannot exceed 3 more characters.</a>
<a name="ln4316">  strcpy(s, ext);</a>
<a name="ln4317"> </a>
<a name="ln4318">  char *e;</a>
<a name="ln4319">  // Prepend the dot if needed.</a>
<a name="ln4320">  if (prepend_dot &amp;&amp; *(e = (char *)path_tail((char_u *)retval)) != '.') {</a>
<a name="ln4321">    STRMOVE(e + 1, e);</a>
<a name="ln4322">    *e = '.';</a>
<a name="ln4323">  }</a>
<a name="ln4324"> </a>
<a name="ln4325">  // Check that, after appending the extension, the file name is really</a>
<a name="ln4326">  // different.</a>
<a name="ln4327">  if (fname != NULL &amp;&amp; strcmp(fname, retval) == 0) {</a>
<a name="ln4328">    // we search for a character that can be replaced by '_'</a>
<a name="ln4329">    while (--s &gt;= ptr) {</a>
<a name="ln4330">      if (*s != '_') {</a>
<a name="ln4331">        *s = '_';</a>
<a name="ln4332">        break;</a>
<a name="ln4333">      }</a>
<a name="ln4334">    }</a>
<a name="ln4335">    if (s &lt; ptr) {  // fname was &quot;________.&lt;ext&gt;&quot;, how tricky!</a>
<a name="ln4336">      *ptr = 'v';</a>
<a name="ln4337">    }</a>
<a name="ln4338">  }</a>
<a name="ln4339">  return retval;</a>
<a name="ln4340">}</a>
<a name="ln4341"> </a>
<a name="ln4342">/// Like fgets(), but if the file line is too long, it is truncated and the</a>
<a name="ln4343">/// rest of the line is thrown away.</a>
<a name="ln4344">///</a>
<a name="ln4345">/// @param[out] buf buffer to fill</a>
<a name="ln4346">/// @param size size of the buffer</a>
<a name="ln4347">/// @param fp file to read from</a>
<a name="ln4348">///</a>
<a name="ln4349">/// @return true for EOF or error</a>
<a name="ln4350">bool vim_fgets(char_u *buf, int size, FILE *fp) FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4351">{</a>
<a name="ln4352">  char *retval;</a>
<a name="ln4353"> </a>
<a name="ln4354">  assert(size &gt; 0);</a>
<a name="ln4355">  buf[size - 2] = NUL;</a>
<a name="ln4356"> </a>
<a name="ln4357">  do {</a>
<a name="ln4358">    errno = 0;</a>
<a name="ln4359">    retval = fgets((char *)buf, size, fp);</a>
<a name="ln4360">  } while (retval == NULL &amp;&amp; errno == EINTR &amp;&amp; ferror(fp));</a>
<a name="ln4361"> </a>
<a name="ln4362">  if (buf[size - 2] != NUL &amp;&amp; buf[size - 2] != '\n') {</a>
<a name="ln4363">    char tbuf[200];</a>
<a name="ln4364"> </a>
<a name="ln4365">    buf[size - 1] = NUL;  // Truncate the line.</a>
<a name="ln4366"> </a>
<a name="ln4367">    // Now throw away the rest of the line:</a>
<a name="ln4368">    do {</a>
<a name="ln4369">      tbuf[sizeof(tbuf) - 2] = NUL;</a>
<a name="ln4370">      errno = 0;</a>
<a name="ln4371">      retval = fgets((char *)tbuf, sizeof(tbuf), fp);</a>
<a name="ln4372">      if (retval == NULL &amp;&amp; (feof(fp) || errno != EINTR)) {</a>
<a name="ln4373">        break;</a>
<a name="ln4374">      }</a>
<a name="ln4375">    } while (tbuf[sizeof(tbuf) - 2] != NUL &amp;&amp; tbuf[sizeof(tbuf) - 2] != '\n');</a>
<a name="ln4376">  }</a>
<a name="ln4377">  return retval == NULL;</a>
<a name="ln4378">}</a>
<a name="ln4379"> </a>
<a name="ln4380">/// Read 2 bytes from &quot;fd&quot; and turn them into an int, MSB first.</a>
<a name="ln4381">/// Returns -1 when encountering EOF.</a>
<a name="ln4382">int get2c(FILE *fd)</a>
<a name="ln4383">{</a>
<a name="ln4384">  const int n = getc(fd);</a>
<a name="ln4385">  if (n == EOF) {</a>
<a name="ln4386">    return -1;</a>
<a name="ln4387">  }</a>
<a name="ln4388">  const int c = getc(fd);</a>
<a name="ln4389">  if (c == EOF) {</a>
<a name="ln4390">    return -1;</a>
<a name="ln4391">  }</a>
<a name="ln4392">  return (n &lt;&lt; 8) + c;</a>
<a name="ln4393">}</a>
<a name="ln4394"> </a>
<a name="ln4395">/// Read 3 bytes from &quot;fd&quot; and turn them into an int, MSB first.</a>
<a name="ln4396">/// Returns -1 when encountering EOF.</a>
<a name="ln4397">int get3c(FILE *fd)</a>
<a name="ln4398">{</a>
<a name="ln4399">  int n = getc(fd);</a>
<a name="ln4400">  if (n == EOF) {</a>
<a name="ln4401">    return -1;</a>
<a name="ln4402">  }</a>
<a name="ln4403">  int c = getc(fd);</a>
<a name="ln4404">  if (c == EOF) {</a>
<a name="ln4405">    return -1;</a>
<a name="ln4406">  }</a>
<a name="ln4407">  n = (n &lt;&lt; 8) + c;</a>
<a name="ln4408">  c = getc(fd);</a>
<a name="ln4409">  if (c == EOF) {</a>
<a name="ln4410">    return -1;</a>
<a name="ln4411">  }</a>
<a name="ln4412">  return (n &lt;&lt; 8) + c;</a>
<a name="ln4413">}</a>
<a name="ln4414"> </a>
<a name="ln4415">/// Read 4 bytes from &quot;fd&quot; and turn them into an int, MSB first.</a>
<a name="ln4416">/// Returns -1 when encountering EOF.</a>
<a name="ln4417">int get4c(FILE *fd)</a>
<a name="ln4418">{</a>
<a name="ln4419">  // Use unsigned rather than int otherwise result is undefined</a>
<a name="ln4420">  // when left-shift sets the MSB.</a>
<a name="ln4421">  unsigned n;</a>
<a name="ln4422"> </a>
<a name="ln4423">  int c = getc(fd);</a>
<a name="ln4424">  if (c == EOF) {</a>
<a name="ln4425">    return -1;</a>
<a name="ln4426">  }</a>
<a name="ln4427">  n = (unsigned)c;</a>
<a name="ln4428">  c = getc(fd);</a>
<a name="ln4429">  if (c == EOF) {</a>
<a name="ln4430">    return -1;</a>
<a name="ln4431">  }</a>
<a name="ln4432">  n = (n &lt;&lt; 8) + (unsigned)c;</a>
<a name="ln4433">  c = getc(fd);</a>
<a name="ln4434">  if (c == EOF) {</a>
<a name="ln4435">    return -1;</a>
<a name="ln4436">  }</a>
<a name="ln4437">  n = (n &lt;&lt; 8) + (unsigned)c;</a>
<a name="ln4438">  c = getc(fd);</a>
<a name="ln4439">  if (c == EOF) {</a>
<a name="ln4440">    return -1;</a>
<a name="ln4441">  }</a>
<a name="ln4442">  n = (n &lt;&lt; 8) + (unsigned)c;</a>
<a name="ln4443">  return (int)n;</a>
<a name="ln4444">}</a>
<a name="ln4445"> </a>
<a name="ln4446">/// Read 8 bytes from `fd` and turn them into a time_t, MSB first.</a>
<a name="ln4447">/// Returns -1 when encountering EOF.</a>
<a name="ln4448">time_t get8ctime(FILE *fd)</a>
<a name="ln4449">{</a>
<a name="ln4450">  time_t n = 0;</a>
<a name="ln4451"> </a>
<a name="ln4452">  for (int i = 0; i &lt; 8; i++) {</a>
<a name="ln4453">    const int c = getc(fd);</a>
<a name="ln4454">    if (c == EOF) {</a>
<a name="ln4455">      return -1;</a>
<a name="ln4456">    }</a>
<a name="ln4457">    n = (n &lt;&lt; 8) + c;</a>
<a name="ln4458">  }</a>
<a name="ln4459">  return n;</a>
<a name="ln4460">}</a>
<a name="ln4461"> </a>
<a name="ln4462">/// Reads a string of length &quot;cnt&quot; from &quot;fd&quot; into allocated memory.</a>
<a name="ln4463">/// @return pointer to the string or NULL when unable to read that many bytes.</a>
<a name="ln4464">char *read_string(FILE *fd, size_t cnt)</a>
<a name="ln4465">{</a>
<a name="ln4466">  char *str = xmallocz(cnt);</a>
<a name="ln4467">  for (size_t i = 0; i &lt; cnt; i++) {</a>
<a name="ln4468">    int c = getc(fd);</a>
<a name="ln4469">    if (c == EOF) {</a>
<a name="ln4470">      xfree(str);</a>
<a name="ln4471">      return NULL;</a>
<a name="ln4472">    }</a>
<a name="ln4473">    str[i] = (char)c;</a>
<a name="ln4474">  }</a>
<a name="ln4475">  return str;</a>
<a name="ln4476">}</a>
<a name="ln4477"> </a>
<a name="ln4478">/// Writes a number to file &quot;fd&quot;, most significant bit first, in &quot;len&quot; bytes.</a>
<a name="ln4479">/// @returns false in case of an error.</a>
<a name="ln4480">bool put_bytes(FILE *fd, uintmax_t number, size_t len)</a>
<a name="ln4481">{</a>
<a name="ln4482">  assert(len &gt; 0);</a>
<a name="ln4483">  for (size_t i = len - 1; i &lt; len; i--) {</a>
<a name="ln4484">    if (putc((int)(number &gt;&gt; (i * 8)), fd) == EOF) {</a>
<a name="ln4485">      return false;</a>
<a name="ln4486">    }</a>
<a name="ln4487">  }</a>
<a name="ln4488">  return true;</a>
<a name="ln4489">}</a>
<a name="ln4490"> </a>
<a name="ln4491">/// Writes time_t to file &quot;fd&quot; in 8 bytes.</a>
<a name="ln4492">/// @returns FAIL when the write failed.</a>
<a name="ln4493">int put_time(FILE *fd, time_t time_)</a>
<a name="ln4494">{</a>
<a name="ln4495">  uint8_t buf[8];</a>
<a name="ln4496">  time_to_bytes(time_, buf);</a>
<a name="ln4497">  return fwrite(buf, sizeof(uint8_t), ARRAY_SIZE(buf), fd) == 1 ? OK : FAIL;</a>
<a name="ln4498">}</a>
<a name="ln4499"> </a>
<a name="ln4500">/// os_rename() only works if both files are on the same file system, this</a>
<a name="ln4501">/// function will (attempts to?) copy the file across if rename fails -- webb</a>
<a name="ln4502">///</a>
<a name="ln4503">/// @return -1 for failure, 0 for success</a>
<a name="ln4504">int vim_rename(const char_u *from, const char_u *to)</a>
<a name="ln4505">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4506">{</a>
<a name="ln4507">  int fd_in;</a>
<a name="ln4508">  int fd_out;</a>
<a name="ln4509">  int n;</a>
<a name="ln4510">  char        *errmsg = NULL;</a>
<a name="ln4511">  char        *buffer;</a>
<a name="ln4512">  long perm;</a>
<a name="ln4513">#ifdef HAVE_ACL</a>
<a name="ln4514">  vim_acl_T acl;                /* ACL from original file */</a>
<a name="ln4515">#endif</a>
<a name="ln4516">  bool use_tmp_file = false;</a>
<a name="ln4517"> </a>
<a name="ln4518">  /*</a>
<a name="ln4519">   * When the names are identical, there is nothing to do.  When they refer</a>
<a name="ln4520">   * to the same file (ignoring case and slash/backslash differences) but</a>
<a name="ln4521">   * the file name differs we need to go through a temp file.</a>
<a name="ln4522">   */</a>
<a name="ln4523">  if (fnamecmp(from, to) == 0) {</a>
<a name="ln4524">    if (p_fic &amp;&amp; (STRCMP(path_tail((char_u *)from), path_tail((char_u *)to))</a>
<a name="ln4525">                  != 0)) {</a>
<a name="ln4526">      use_tmp_file = true;</a>
<a name="ln4527">    } else {</a>
<a name="ln4528">      return 0;</a>
<a name="ln4529">    }</a>
<a name="ln4530">  }</a>
<a name="ln4531"> </a>
<a name="ln4532">  // Fail if the &quot;from&quot; file doesn't exist. Avoids that &quot;to&quot; is deleted.</a>
<a name="ln4533">  FileInfo from_info;</a>
<a name="ln4534">  if (!os_fileinfo((char *)from, &amp;from_info)) {</a>
<a name="ln4535">    return -1;</a>
<a name="ln4536">  }</a>
<a name="ln4537"> </a>
<a name="ln4538">  // It's possible for the source and destination to be the same file.</a>
<a name="ln4539">  // This happens when &quot;from&quot; and &quot;to&quot; differ in case and are on a FAT32</a>
<a name="ln4540">  // filesystem. In that case go through a temp file name.</a>
<a name="ln4541">  FileInfo to_info;</a>
<a name="ln4542">  if (os_fileinfo((char *)to, &amp;to_info)</a>
<a name="ln4543">      &amp;&amp; os_fileinfo_id_equal(&amp;from_info,  &amp;to_info)) {</a>
<a name="ln4544">    use_tmp_file = true;</a>
<a name="ln4545">  }</a>
<a name="ln4546"> </a>
<a name="ln4547">  if (use_tmp_file) {</a>
<a name="ln4548">    char_u tempname[MAXPATHL + 1];</a>
<a name="ln4549"> </a>
<a name="ln4550">    /*</a>
<a name="ln4551">     * Find a name that doesn't exist and is in the same directory.</a>
<a name="ln4552">     * Rename &quot;from&quot; to &quot;tempname&quot; and then rename &quot;tempname&quot; to &quot;to&quot;.</a>
<a name="ln4553">     */</a>
<a name="ln4554">    if (STRLEN(from) &gt;= MAXPATHL - 5)</a>
<a name="ln4555">      return -1;</a>
<a name="ln4556">    STRCPY(tempname, from);</a>
<a name="ln4557">    for (n = 123; n &lt; 99999; n++) {</a>
<a name="ln4558">      char * tail = (char *)path_tail(tempname);</a>
<a name="ln4559">      snprintf(tail, (MAXPATHL + 1) - (tail - (char *)tempname - 1), &quot;%d&quot;, n);</a>
<a name="ln4560"> </a>
<a name="ln4561">      if (!os_path_exists(tempname)) {</a>
<a name="ln4562">        if (os_rename(from, tempname) == OK) {</a>
<a name="ln4563">          if (os_rename(tempname, to) == OK)</a>
<a name="ln4564">            return 0;</a>
<a name="ln4565">          /* Strange, the second step failed.  Try moving the</a>
<a name="ln4566">           * file back and return failure. */</a>
<a name="ln4567">          os_rename(tempname, from);</a>
<a name="ln4568">          return -1;</a>
<a name="ln4569">        }</a>
<a name="ln4570">        /* If it fails for one temp name it will most likely fail</a>
<a name="ln4571">         * for any temp name, give up. */</a>
<a name="ln4572">        return -1;</a>
<a name="ln4573">      }</a>
<a name="ln4574">    }</a>
<a name="ln4575">    return -1;</a>
<a name="ln4576">  }</a>
<a name="ln4577"> </a>
<a name="ln4578">  /*</a>
<a name="ln4579">   * Delete the &quot;to&quot; file, this is required on some systems to make the</a>
<a name="ln4580">   * os_rename() work, on other systems it makes sure that we don't have</a>
<a name="ln4581">   * two files when the os_rename() fails.</a>
<a name="ln4582">   */</a>
<a name="ln4583"> </a>
<a name="ln4584">  os_remove((char *)to);</a>
<a name="ln4585"> </a>
<a name="ln4586">  /*</a>
<a name="ln4587">   * First try a normal rename, return if it works.</a>
<a name="ln4588">   */</a>
<a name="ln4589">  if (os_rename(from, to) == OK)</a>
<a name="ln4590">    return 0;</a>
<a name="ln4591"> </a>
<a name="ln4592">  /*</a>
<a name="ln4593">   * Rename() failed, try copying the file.</a>
<a name="ln4594">   */</a>
<a name="ln4595">  perm = os_getperm((const char *)from);</a>
<a name="ln4596">#ifdef HAVE_ACL</a>
<a name="ln4597">  // For systems that support ACL: get the ACL from the original file.</a>
<a name="ln4598">  acl = mch_get_acl(from);</a>
<a name="ln4599">#endif</a>
<a name="ln4600">  fd_in = os_open((char *)from, O_RDONLY, 0);</a>
<a name="ln4601">  if (fd_in &lt; 0) {</a>
<a name="ln4602">#ifdef HAVE_ACL</a>
<a name="ln4603">    mch_free_acl(acl);</a>
<a name="ln4604">#endif</a>
<a name="ln4605">    return -1;</a>
<a name="ln4606">  }</a>
<a name="ln4607"> </a>
<a name="ln4608">  /* Create the new file with same permissions as the original. */</a>
<a name="ln4609">  fd_out = os_open((char *)to,</a>
<a name="ln4610">      O_CREAT|O_EXCL|O_WRONLY|O_NOFOLLOW, (int)perm);</a>
<a name="ln4611">  if (fd_out &lt; 0) {</a>
<a name="ln4612">    close(fd_in);</a>
<a name="ln4613">#ifdef HAVE_ACL</a>
<a name="ln4614">    mch_free_acl(acl);</a>
<a name="ln4615">#endif</a>
<a name="ln4616">    return -1;</a>
<a name="ln4617">  }</a>
<a name="ln4618"> </a>
<a name="ln4619">  // Avoid xmalloc() here as vim_rename() is called by buf_write() when nvim</a>
<a name="ln4620">  // is `preserve_exit()`ing.</a>
<a name="ln4621">  buffer = try_malloc(BUFSIZE);</a>
<a name="ln4622">  if (buffer == NULL) {</a>
<a name="ln4623">    close(fd_out);</a>
<a name="ln4624">    close(fd_in);</a>
<a name="ln4625">#ifdef HAVE_ACL</a>
<a name="ln4626">    mch_free_acl(acl);</a>
<a name="ln4627">#endif</a>
<a name="ln4628">    return -1;</a>
<a name="ln4629">  }</a>
<a name="ln4630"> </a>
<a name="ln4631">  while ((n = read_eintr(fd_in, buffer, BUFSIZE)) &gt; 0)</a>
<a name="ln4632">    if (write_eintr(fd_out, buffer, n) != n) {</a>
<a name="ln4633">      errmsg = _(&quot;E208: Error writing to \&quot;%s\&quot;&quot;);</a>
<a name="ln4634">      break;</a>
<a name="ln4635">    }</a>
<a name="ln4636"> </a>
<a name="ln4637">  xfree(buffer);</a>
<a name="ln4638">  close(fd_in);</a>
<a name="ln4639">  if (close(fd_out) &lt; 0)</a>
<a name="ln4640">    errmsg = _(&quot;E209: Error closing \&quot;%s\&quot;&quot;);</a>
<a name="ln4641">  if (n &lt; 0) {</a>
<a name="ln4642">    errmsg = _(&quot;E210: Error reading \&quot;%s\&quot;&quot;);</a>
<a name="ln4643">    to = from;</a>
<a name="ln4644">  }</a>
<a name="ln4645">#ifndef UNIX  // For Unix os_open() already set the permission.</a>
<a name="ln4646">  os_setperm((const char *)to, perm);</a>
<a name="ln4647">#endif</a>
<a name="ln4648">#ifdef HAVE_ACL</a>
<a name="ln4649">  mch_set_acl(to, acl);</a>
<a name="ln4650">  mch_free_acl(acl);</a>
<a name="ln4651">#endif</a>
<a name="ln4652">  if (errmsg != NULL) {</a>
<a name="ln4653">    EMSG2(errmsg, to);</a>
<a name="ln4654">    return -1;</a>
<a name="ln4655">  }</a>
<a name="ln4656">  os_remove((char *)from);</a>
<a name="ln4657">  return 0;</a>
<a name="ln4658">}</a>
<a name="ln4659"> </a>
<a name="ln4660">static int already_warned = FALSE;</a>
<a name="ln4661"> </a>
<a name="ln4662">// Check if any not hidden buffer has been changed.</a>
<a name="ln4663">// Postpone the check if there are characters in the stuff buffer, a global</a>
<a name="ln4664">// command is being executed, a mapping is being executed or an autocommand is</a>
<a name="ln4665">// busy.</a>
<a name="ln4666">// Returns TRUE if some message was written (screen should be redrawn and</a>
<a name="ln4667">// cursor positioned).</a>
<a name="ln4668">int</a>
<a name="ln4669">check_timestamps(</a>
<a name="ln4670">    int focus                      // called for GUI focus event</a>
<a name="ln4671">)</a>
<a name="ln4672">{</a>
<a name="ln4673">  int didit = 0;</a>
<a name="ln4674"> </a>
<a name="ln4675">  /* Don't check timestamps while system() or another low-level function may</a>
<a name="ln4676">   * cause us to lose and gain focus. */</a>
<a name="ln4677">  if (no_check_timestamps &gt; 0)</a>
<a name="ln4678">    return FALSE;</a>
<a name="ln4679"> </a>
<a name="ln4680">  /* Avoid doing a check twice.  The OK/Reload dialog can cause a focus</a>
<a name="ln4681">   * event and we would keep on checking if the file is steadily growing.</a>
<a name="ln4682">   * Do check again after typing something. */</a>
<a name="ln4683">  if (focus &amp;&amp; did_check_timestamps) {</a>
<a name="ln4684">    need_check_timestamps = TRUE;</a>
<a name="ln4685">    return FALSE;</a>
<a name="ln4686">  }</a>
<a name="ln4687"> </a>
<a name="ln4688">  if (!stuff_empty() || global_busy || !typebuf_typed()</a>
<a name="ln4689">      || autocmd_busy || curbuf_lock &gt; 0 || allbuf_lock &gt; 0</a>
<a name="ln4690">      ) {</a>
<a name="ln4691">    need_check_timestamps = true;               // check later</a>
<a name="ln4692">  } else {</a>
<a name="ln4693">    no_wait_return++;</a>
<a name="ln4694">    did_check_timestamps = true;</a>
<a name="ln4695">    already_warned = false;</a>
<a name="ln4696">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln4697">      // Only check buffers in a window.</a>
<a name="ln4698">      if (buf-&gt;b_nwindows &gt; 0) {</a>
<a name="ln4699">        bufref_T bufref;</a>
<a name="ln4700">        set_bufref(&amp;bufref, buf);</a>
<a name="ln4701">        const int n = buf_check_timestamp(buf);</a>
<a name="ln4702">        if (didit &lt; n) {</a>
<a name="ln4703">          didit = n;</a>
<a name="ln4704">        }</a>
<a name="ln4705">        if (n &gt; 0 &amp;&amp; !bufref_valid(&amp;bufref)) {</a>
<a name="ln4706">          // Autocommands have removed the buffer, start at the first one again.</a>
<a name="ln4707">          buf = firstbuf;</a>
<a name="ln4708">          continue;</a>
<a name="ln4709">        }</a>
<a name="ln4710">      }</a>
<a name="ln4711">    }</a>
<a name="ln4712">    --no_wait_return;</a>
<a name="ln4713">    need_check_timestamps = FALSE;</a>
<a name="ln4714">    if (need_wait_return &amp;&amp; didit == 2) {</a>
<a name="ln4715">      // make sure msg isn't overwritten</a>
<a name="ln4716">      msg_puts(&quot;\n&quot;);</a>
<a name="ln4717">      ui_flush();</a>
<a name="ln4718">    }</a>
<a name="ln4719">  }</a>
<a name="ln4720">  return didit;</a>
<a name="ln4721">}</a>
<a name="ln4722"> </a>
<a name="ln4723">/*</a>
<a name="ln4724"> * Move all the lines from buffer &quot;frombuf&quot; to buffer &quot;tobuf&quot;.</a>
<a name="ln4725"> * Return OK or FAIL.  When FAIL &quot;tobuf&quot; is incomplete and/or &quot;frombuf&quot; is not</a>
<a name="ln4726"> * empty.</a>
<a name="ln4727"> */</a>
<a name="ln4728">static int move_lines(buf_T *frombuf, buf_T *tobuf)</a>
<a name="ln4729">{</a>
<a name="ln4730">  buf_T       *tbuf = curbuf;</a>
<a name="ln4731">  int retval = OK;</a>
<a name="ln4732">  linenr_T lnum;</a>
<a name="ln4733">  char_u      *p;</a>
<a name="ln4734"> </a>
<a name="ln4735">  /* Copy the lines in &quot;frombuf&quot; to &quot;tobuf&quot;. */</a>
<a name="ln4736">  curbuf = tobuf;</a>
<a name="ln4737">  for (lnum = 1; lnum &lt;= frombuf-&gt;b_ml.ml_line_count; lnum++) {</a>
<a name="ln4738">    p = vim_strsave(ml_get_buf(frombuf, lnum, false));</a>
<a name="ln4739">    if (ml_append(lnum - 1, p, 0, false) == FAIL) {</a>
<a name="ln4740">      xfree(p);</a>
<a name="ln4741">      retval = FAIL;</a>
<a name="ln4742">      break;</a>
<a name="ln4743">    }</a>
<a name="ln4744">    xfree(p);</a>
<a name="ln4745">  }</a>
<a name="ln4746"> </a>
<a name="ln4747">  /* Delete all the lines in &quot;frombuf&quot;. */</a>
<a name="ln4748">  if (retval != FAIL) {</a>
<a name="ln4749">    curbuf = frombuf;</a>
<a name="ln4750">    for (lnum = curbuf-&gt;b_ml.ml_line_count; lnum &gt; 0; lnum--) {</a>
<a name="ln4751">      if (ml_delete(lnum, false) == FAIL) {</a>
<a name="ln4752">        // Oops!  We could try putting back the saved lines, but that</a>
<a name="ln4753">        // might fail again...</a>
<a name="ln4754">        retval = FAIL;</a>
<a name="ln4755">        break;</a>
<a name="ln4756">      }</a>
<a name="ln4757">    }</a>
<a name="ln4758">  }</a>
<a name="ln4759"> </a>
<a name="ln4760">  curbuf = tbuf;</a>
<a name="ln4761">  return retval;</a>
<a name="ln4762">}</a>
<a name="ln4763"> </a>
<a name="ln4764">/*</a>
<a name="ln4765"> * Check if buffer &quot;buf&quot; has been changed.</a>
<a name="ln4766"> * Also check if the file for a new buffer unexpectedly appeared.</a>
<a name="ln4767"> * return 1 if a changed buffer was found.</a>
<a name="ln4768"> * return 2 if a message has been displayed.</a>
<a name="ln4769"> * return 0 otherwise.</a>
<a name="ln4770"> */</a>
<a name="ln4771">int buf_check_timestamp(buf_T *buf)</a>
<a name="ln4772">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4773">{</a>
<a name="ln4774">  int retval = 0;</a>
<a name="ln4775">  char_u      *path;</a>
<a name="ln4776">  char        *mesg = NULL;</a>
<a name="ln4777">  char        *mesg2 = &quot;&quot;;</a>
<a name="ln4778">  bool helpmesg = false;</a>
<a name="ln4779">  bool reload = false;</a>
<a name="ln4780">  bool can_reload = false;</a>
<a name="ln4781">  uint64_t orig_size = buf-&gt;b_orig_size;</a>
<a name="ln4782">  int orig_mode = buf-&gt;b_orig_mode;</a>
<a name="ln4783">  static bool busy = false;</a>
<a name="ln4784">  char_u      *s;</a>
<a name="ln4785">  char        *reason;</a>
<a name="ln4786"> </a>
<a name="ln4787">  bufref_T bufref;</a>
<a name="ln4788">  set_bufref(&amp;bufref, buf);</a>
<a name="ln4789"> </a>
<a name="ln4790">  // If its a terminal, there is no file name, the buffer is not loaded,</a>
<a name="ln4791">  // 'buftype' is set, we are in the middle of a save or being called</a>
<a name="ln4792">  // recursively: ignore this buffer.</a>
<a name="ln4793">  if (buf-&gt;terminal</a>
<a name="ln4794">      || buf-&gt;b_ffname == NULL</a>
<a name="ln4795">      || buf-&gt;b_ml.ml_mfp == NULL</a>
<a name="ln4796">      || !bt_normal(buf)</a>
<a name="ln4797">      || buf-&gt;b_saving</a>
<a name="ln4798">      || busy</a>
<a name="ln4799">      )</a>
<a name="ln4800">    return 0;</a>
<a name="ln4801"> </a>
<a name="ln4802">  FileInfo file_info;</a>
<a name="ln4803">  bool file_info_ok;</a>
<a name="ln4804">  if (!(buf-&gt;b_flags &amp; BF_NOTEDITED)</a>
<a name="ln4805">      &amp;&amp; buf-&gt;b_mtime != 0</a>
<a name="ln4806">      &amp;&amp; (!(file_info_ok = os_fileinfo((char *)buf-&gt;b_ffname, &amp;file_info))</a>
<a name="ln4807">          || time_differs(file_info.stat.st_mtim.tv_sec, buf-&gt;b_mtime)</a>
<a name="ln4808">          || (int)file_info.stat.st_mode != buf-&gt;b_orig_mode)) {</a>
<a name="ln4809">    const long prev_b_mtime = buf-&gt;b_mtime;</a>
<a name="ln4810"> </a>
<a name="ln4811">    retval = 1;</a>
<a name="ln4812"> </a>
<a name="ln4813">    // set b_mtime to stop further warnings (e.g., when executing</a>
<a name="ln4814">    // FileChangedShell autocmd)</a>
<a name="ln4815">    if (!file_info_ok) {</a>
<a name="ln4816">      // Check the file again later to see if it re-appears.</a>
<a name="ln4817">      buf-&gt;b_mtime = -1;</a>
<a name="ln4818">      buf-&gt;b_orig_size = 0;</a>
<a name="ln4819">      buf-&gt;b_orig_mode = 0;</a>
<a name="ln4820">    } else {</a>
<a name="ln4821">      buf_store_file_info(buf, &amp;file_info);</a>
<a name="ln4822">    }</a>
<a name="ln4823"> </a>
<a name="ln4824">    /* Don't do anything for a directory.  Might contain the file</a>
<a name="ln4825">     * explorer. */</a>
<a name="ln4826">    if (os_isdir(buf-&gt;b_fname)) {</a>
<a name="ln4827">    } else if ((buf-&gt;b_p_ar &gt;= 0 ? buf-&gt;b_p_ar : p_ar)</a>
<a name="ln4828">               &amp;&amp; !bufIsChanged(buf) &amp;&amp; file_info_ok) {</a>
<a name="ln4829">      // If 'autoread' is set, the buffer has no changes and the file still</a>
<a name="ln4830">      // exists, reload the buffer.  Use the buffer-local option value if it</a>
<a name="ln4831">      // was set, the global option value otherwise.</a>
<a name="ln4832">      reload = true;</a>
<a name="ln4833">    } else {</a>
<a name="ln4834">      if (!file_info_ok) {</a>
<a name="ln4835">        reason = &quot;deleted&quot;;</a>
<a name="ln4836">      } else if (bufIsChanged(buf)) {</a>
<a name="ln4837">        reason = &quot;conflict&quot;;</a>
<a name="ln4838">      } else if (orig_size != buf-&gt;b_orig_size || buf_contents_changed(buf)) {</a>
<a name="ln4839">        reason = &quot;changed&quot;;</a>
<a name="ln4840">      } else if (orig_mode != buf-&gt;b_orig_mode) {</a>
<a name="ln4841">        reason = &quot;mode&quot;;</a>
<a name="ln4842">      } else {</a>
<a name="ln4843">        reason = &quot;time&quot;;</a>
<a name="ln4844">      }</a>
<a name="ln4845"> </a>
<a name="ln4846">      // Only give the warning if there are no FileChangedShell</a>
<a name="ln4847">      // autocommands.</a>
<a name="ln4848">      // Avoid being called recursively by setting &quot;busy&quot;.</a>
<a name="ln4849">      busy = true;</a>
<a name="ln4850">      set_vim_var_string(VV_FCS_REASON, reason, -1);</a>
<a name="ln4851">      set_vim_var_string(VV_FCS_CHOICE, &quot;&quot;, -1);</a>
<a name="ln4852">      allbuf_lock++;</a>
<a name="ln4853">      bool n = apply_autocmds(EVENT_FILECHANGEDSHELL,</a>
<a name="ln4854">                              buf-&gt;b_fname, buf-&gt;b_fname, false, buf);</a>
<a name="ln4855">      allbuf_lock--;</a>
<a name="ln4856">      busy = false;</a>
<a name="ln4857">      if (n) {</a>
<a name="ln4858">        if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln4859">          EMSG(_(&quot;E246: FileChangedShell autocommand deleted buffer&quot;));</a>
<a name="ln4860">        }</a>
<a name="ln4861">        s = get_vim_var_str(VV_FCS_CHOICE);</a>
<a name="ln4862">        if (STRCMP(s, &quot;reload&quot;) == 0 &amp;&amp; *reason != 'd') {</a>
<a name="ln4863">          reload = true;</a>
<a name="ln4864">        } else if (STRCMP(s, &quot;ask&quot;) == 0) {</a>
<a name="ln4865">          n = false;</a>
<a name="ln4866">        } else {</a>
<a name="ln4867">          return 2;</a>
<a name="ln4868">        }</a>
<a name="ln4869">      }</a>
<a name="ln4870">      if (!n) {</a>
<a name="ln4871">        if (*reason == 'd') {</a>
<a name="ln4872">          // Only give the message once.</a>
<a name="ln4873">          if (prev_b_mtime != -1) {</a>
<a name="ln4874">            mesg = _(&quot;E211: File \&quot;%s\&quot; no longer available&quot;);</a>
<a name="ln4875">          }</a>
<a name="ln4876">        } else {</a>
<a name="ln4877">          helpmesg = true;</a>
<a name="ln4878">          can_reload = true;</a>
<a name="ln4879"> </a>
<a name="ln4880">          // Check if the file contents really changed to avoid</a>
<a name="ln4881">          // giving a warning when only the timestamp was set (e.g.,</a>
<a name="ln4882">          // checked out of CVS).  Always warn when the buffer was</a>
<a name="ln4883">          // changed.</a>
<a name="ln4884">          if (reason[2] == 'n') {</a>
<a name="ln4885">            mesg = _(</a>
<a name="ln4886">                &quot;W12: Warning: File \&quot;%s\&quot; has changed and the buffer was changed in Vim as well&quot;);</a>
<a name="ln4887">            mesg2 = _(&quot;See \&quot;:help W12\&quot; for more info.&quot;);</a>
<a name="ln4888">          } else if (reason[1] == 'h') {</a>
<a name="ln4889">            mesg = _(</a>
<a name="ln4890">                &quot;W11: Warning: File \&quot;%s\&quot; has changed since editing started&quot;);</a>
<a name="ln4891">            mesg2 = _(&quot;See \&quot;:help W11\&quot; for more info.&quot;);</a>
<a name="ln4892">          } else if (*reason == 'm') {</a>
<a name="ln4893">            mesg = _(</a>
<a name="ln4894">                &quot;W16: Warning: Mode of file \&quot;%s\&quot; has changed since editing started&quot;);</a>
<a name="ln4895">            mesg2 = _(&quot;See \&quot;:help W16\&quot; for more info.&quot;);</a>
<a name="ln4896">          } else</a>
<a name="ln4897">            /* Only timestamp changed, store it to avoid a warning</a>
<a name="ln4898">             * in check_mtime() later. */</a>
<a name="ln4899">            buf-&gt;b_mtime_read = buf-&gt;b_mtime;</a>
<a name="ln4900">        }</a>
<a name="ln4901">      }</a>
<a name="ln4902">    }</a>
<a name="ln4903"> </a>
<a name="ln4904">  } else if ((buf-&gt;b_flags &amp; BF_NEW) &amp;&amp; !(buf-&gt;b_flags &amp; BF_NEW_W)</a>
<a name="ln4905">             &amp;&amp; os_path_exists(buf-&gt;b_ffname)) {</a>
<a name="ln4906">    retval = 1;</a>
<a name="ln4907">    mesg = _(&quot;W13: Warning: File \&quot;%s\&quot; has been created after editing started&quot;);</a>
<a name="ln4908">    buf-&gt;b_flags |= BF_NEW_W;</a>
<a name="ln4909">    can_reload = true;</a>
<a name="ln4910">  }</a>
<a name="ln4911"> </a>
<a name="ln4912">  if (mesg != NULL) {</a>
<a name="ln4913">    path = home_replace_save(buf, buf-&gt;b_fname);</a>
<a name="ln4914">    if (!helpmesg) {</a>
<a name="ln4915">      mesg2 = &quot;&quot;;</a>
<a name="ln4916">    }</a>
<a name="ln4917">    const size_t tbuf_len = STRLEN(path) + STRLEN(mesg) + STRLEN(mesg2) + 2;</a>
<a name="ln4918">    char *const tbuf = xmalloc(tbuf_len);</a>
<a name="ln4919">    snprintf(tbuf, tbuf_len, mesg, path);</a>
<a name="ln4920">    // Set warningmsg here, before the unimportant and output-specific</a>
<a name="ln4921">    // mesg2 has been appended.</a>
<a name="ln4922">    set_vim_var_string(VV_WARNINGMSG, tbuf, -1);</a>
<a name="ln4923">    if (can_reload) {</a>
<a name="ln4924">      if (*mesg2 != NUL) {</a>
<a name="ln4925">        xstrlcat(tbuf, &quot;\n&quot;, tbuf_len - 1);</a>
<a name="ln4926">        xstrlcat(tbuf, mesg2, tbuf_len - 1);</a>
<a name="ln4927">      }</a>
<a name="ln4928">      if (do_dialog(VIM_WARNING, (char_u *) _(&quot;Warning&quot;), (char_u *) tbuf,</a>
<a name="ln4929">                    (char_u *) _(&quot;&amp;OK\n&amp;Load File&quot;), 1, NULL, true) == 2) {</a>
<a name="ln4930">        reload = true;</a>
<a name="ln4931">      }</a>
<a name="ln4932">    } else if (State &gt; NORMAL_BUSY || (State &amp; CMDLINE) || already_warned) {</a>
<a name="ln4933">      if (*mesg2 != NUL) {</a>
<a name="ln4934">        xstrlcat(tbuf, &quot;; &quot;, tbuf_len - 1);</a>
<a name="ln4935">        xstrlcat(tbuf, mesg2, tbuf_len - 1);</a>
<a name="ln4936">      }</a>
<a name="ln4937">      EMSG(tbuf);</a>
<a name="ln4938">      retval = 2;</a>
<a name="ln4939">    } else {</a>
<a name="ln4940">      if (!autocmd_busy) {</a>
<a name="ln4941">        msg_start();</a>
<a name="ln4942">        msg_puts_attr(tbuf, HL_ATTR(HLF_E) + MSG_HIST);</a>
<a name="ln4943">        if (*mesg2 != NUL) {</a>
<a name="ln4944">          msg_puts_attr(mesg2, HL_ATTR(HLF_W) + MSG_HIST);</a>
<a name="ln4945">        }</a>
<a name="ln4946">        msg_clr_eos();</a>
<a name="ln4947">        (void)msg_end();</a>
<a name="ln4948">        if (emsg_silent == 0) {</a>
<a name="ln4949">          ui_flush();</a>
<a name="ln4950">          // give the user some time to think about it</a>
<a name="ln4951">          os_delay(1004L, true);</a>
<a name="ln4952"> </a>
<a name="ln4953">          // don't redraw and erase the message</a>
<a name="ln4954">          redraw_cmdline = false;</a>
<a name="ln4955">        }</a>
<a name="ln4956">      }</a>
<a name="ln4957">      already_warned = TRUE;</a>
<a name="ln4958">    }</a>
<a name="ln4959"> </a>
<a name="ln4960">    xfree(path);</a>
<a name="ln4961">    xfree(tbuf);</a>
<a name="ln4962">  }</a>
<a name="ln4963"> </a>
<a name="ln4964">  if (reload) {</a>
<a name="ln4965">    /* Reload the buffer. */</a>
<a name="ln4966">    buf_reload(buf, orig_mode);</a>
<a name="ln4967">    if (buf-&gt;b_p_udf &amp;&amp; buf-&gt;b_ffname != NULL) {</a>
<a name="ln4968">      char_u hash[UNDO_HASH_SIZE];</a>
<a name="ln4969">      buf_T           *save_curbuf = curbuf;</a>
<a name="ln4970"> </a>
<a name="ln4971">      /* Any existing undo file is unusable, write it now. */</a>
<a name="ln4972">      curbuf = buf;</a>
<a name="ln4973">      u_compute_hash(hash);</a>
<a name="ln4974">      u_write_undo(NULL, FALSE, buf, hash);</a>
<a name="ln4975">      curbuf = save_curbuf;</a>
<a name="ln4976">    }</a>
<a name="ln4977">  }</a>
<a name="ln4978"> </a>
<a name="ln4979">  // Trigger FileChangedShell when the file was changed in any way.</a>
<a name="ln4980">  if (bufref_valid(&amp;bufref) &amp;&amp; retval != 0) {</a>
<a name="ln4981">    (void)apply_autocmds(EVENT_FILECHANGEDSHELLPOST, buf-&gt;b_fname, buf-&gt;b_fname,</a>
<a name="ln4982">                         false, buf);</a>
<a name="ln4983">  }</a>
<a name="ln4984">  return retval;</a>
<a name="ln4985">}</a>
<a name="ln4986"> </a>
<a name="ln4987">/*</a>
<a name="ln4988"> * Reload a buffer that is already loaded.</a>
<a name="ln4989"> * Used when the file was changed outside of Vim.</a>
<a name="ln4990"> * &quot;orig_mode&quot; is buf-&gt;b_orig_mode before the need for reloading was detected.</a>
<a name="ln4991"> * buf-&gt;b_orig_mode may have been reset already.</a>
<a name="ln4992"> */</a>
<a name="ln4993">void buf_reload(buf_T *buf, int orig_mode)</a>
<a name="ln4994">{</a>
<a name="ln4995">  exarg_T ea;</a>
<a name="ln4996">  pos_T old_cursor;</a>
<a name="ln4997">  linenr_T old_topline;</a>
<a name="ln4998">  int old_ro = buf-&gt;b_p_ro;</a>
<a name="ln4999">  buf_T       *savebuf;</a>
<a name="ln5000">  bufref_T bufref;</a>
<a name="ln5001">  int saved = OK;</a>
<a name="ln5002">  aco_save_T aco;</a>
<a name="ln5003">  int flags = READ_NEW;</a>
<a name="ln5004"> </a>
<a name="ln5005">  /* set curwin/curbuf for &quot;buf&quot; and save some things */</a>
<a name="ln5006">  aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln5007"> </a>
<a name="ln5008">  // We only want to read the text from the file, not reset the syntax</a>
<a name="ln5009">  // highlighting, clear marks, diff status, etc.  Force the fileformat and</a>
<a name="ln5010">  // encoding to be the same.</a>
<a name="ln5011"> </a>
<a name="ln5012">  prep_exarg(&amp;ea, buf);</a>
<a name="ln5013">  old_cursor = curwin-&gt;w_cursor;</a>
<a name="ln5014">  old_topline = curwin-&gt;w_topline;</a>
<a name="ln5015"> </a>
<a name="ln5016">  if (p_ur &lt; 0 || curbuf-&gt;b_ml.ml_line_count &lt;= p_ur) {</a>
<a name="ln5017">    /* Save all the text, so that the reload can be undone.</a>
<a name="ln5018">     * Sync first so that this is a separate undo-able action. */</a>
<a name="ln5019">    u_sync(FALSE);</a>
<a name="ln5020">    saved = u_savecommon(0, curbuf-&gt;b_ml.ml_line_count + 1, 0, TRUE);</a>
<a name="ln5021">    flags |= READ_KEEP_UNDO;</a>
<a name="ln5022">  }</a>
<a name="ln5023"> </a>
<a name="ln5024">  // To behave like when a new file is edited (matters for</a>
<a name="ln5025">  // BufReadPost autocommands) we first need to delete the current</a>
<a name="ln5026">  // buffer contents.  But if reading the file fails we should keep</a>
<a name="ln5027">  // the old contents.  Can't use memory only, the file might be</a>
<a name="ln5028">  // too big.  Use a hidden buffer to move the buffer contents to.</a>
<a name="ln5029">  if (BUFEMPTY() || saved == FAIL) {</a>
<a name="ln5030">    savebuf = NULL;</a>
<a name="ln5031">  } else {</a>
<a name="ln5032">    // Allocate a buffer without putting it in the buffer list.</a>
<a name="ln5033">    savebuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);</a>
<a name="ln5034">    set_bufref(&amp;bufref, savebuf);</a>
<a name="ln5035">    if (savebuf != NULL &amp;&amp; buf == curbuf) {</a>
<a name="ln5036">      /* Open the memline. */</a>
<a name="ln5037">      curbuf = savebuf;</a>
<a name="ln5038">      curwin-&gt;w_buffer = savebuf;</a>
<a name="ln5039">      saved = ml_open(curbuf);</a>
<a name="ln5040">      curbuf = buf;</a>
<a name="ln5041">      curwin-&gt;w_buffer = buf;</a>
<a name="ln5042">    }</a>
<a name="ln5043">    if (savebuf == NULL || saved == FAIL || buf != curbuf</a>
<a name="ln5044">        || move_lines(buf, savebuf) == FAIL) {</a>
<a name="ln5045">      EMSG2(_(&quot;E462: Could not prepare for reloading \&quot;%s\&quot;&quot;),</a>
<a name="ln5046">          buf-&gt;b_fname);</a>
<a name="ln5047">      saved = FAIL;</a>
<a name="ln5048">    }</a>
<a name="ln5049">  }</a>
<a name="ln5050"> </a>
<a name="ln5051">  if (saved == OK) {</a>
<a name="ln5052">    curbuf-&gt;b_flags |= BF_CHECK_RO;           // check for RO again</a>
<a name="ln5053">    keep_filetype = true;                     // don't detect 'filetype'</a>
<a name="ln5054">    if (readfile(buf-&gt;b_ffname, buf-&gt;b_fname, (linenr_T)0, (linenr_T)0,</a>
<a name="ln5055">                 (linenr_T)MAXLNUM, &amp;ea, flags) != OK) {</a>
<a name="ln5056">      if (!aborting()) {</a>
<a name="ln5057">        EMSG2(_(&quot;E321: Could not reload \&quot;%s\&quot;&quot;), buf-&gt;b_fname);</a>
<a name="ln5058">      }</a>
<a name="ln5059">      if (savebuf != NULL &amp;&amp; bufref_valid(&amp;bufref) &amp;&amp; buf == curbuf) {</a>
<a name="ln5060">        // Put the text back from the save buffer.  First</a>
<a name="ln5061">        // delete any lines that readfile() added.</a>
<a name="ln5062">        while (!BUFEMPTY()) {</a>
<a name="ln5063">          if (ml_delete(buf-&gt;b_ml.ml_line_count, false) == FAIL) {</a>
<a name="ln5064">            break;</a>
<a name="ln5065">          }</a>
<a name="ln5066">        }</a>
<a name="ln5067">        (void)move_lines(savebuf, buf);</a>
<a name="ln5068">      }</a>
<a name="ln5069">    } else if (buf == curbuf) {  // &quot;buf&quot; still valid.</a>
<a name="ln5070">      // Mark the buffer as unmodified and free undo info.</a>
<a name="ln5071">      unchanged(buf, true, true);</a>
<a name="ln5072">      if ((flags &amp; READ_KEEP_UNDO) == 0) {</a>
<a name="ln5073">        u_blockfree(buf);</a>
<a name="ln5074">        u_clearall(buf);</a>
<a name="ln5075">      } else {</a>
<a name="ln5076">        // Mark all undo states as changed.</a>
<a name="ln5077">        u_unchanged(curbuf);</a>
<a name="ln5078">      }</a>
<a name="ln5079">      buf_updates_unload(curbuf, true);</a>
<a name="ln5080">      curbuf-&gt;b_mod_set = true;</a>
<a name="ln5081">    }</a>
<a name="ln5082">  }</a>
<a name="ln5083">  xfree(ea.cmd);</a>
<a name="ln5084"> </a>
<a name="ln5085">  if (savebuf != NULL &amp;&amp; bufref_valid(&amp;bufref)) {</a>
<a name="ln5086">    wipe_buffer(savebuf, false);</a>
<a name="ln5087">  }</a>
<a name="ln5088"> </a>
<a name="ln5089">  /* Invalidate diff info if necessary. */</a>
<a name="ln5090">  diff_invalidate(curbuf);</a>
<a name="ln5091"> </a>
<a name="ln5092">  /* Restore the topline and cursor position and check it (lines may</a>
<a name="ln5093">   * have been removed). */</a>
<a name="ln5094">  if (old_topline &gt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln5095">    curwin-&gt;w_topline = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln5096">  else</a>
<a name="ln5097">    curwin-&gt;w_topline = old_topline;</a>
<a name="ln5098">  curwin-&gt;w_cursor = old_cursor;</a>
<a name="ln5099">  check_cursor();</a>
<a name="ln5100">  update_topline(curwin);</a>
<a name="ln5101">  keep_filetype = false;</a>
<a name="ln5102"> </a>
<a name="ln5103">  /* Update folds unless they are defined manually. */</a>
<a name="ln5104">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln5105">    if (wp-&gt;w_buffer == curwin-&gt;w_buffer</a>
<a name="ln5106">        &amp;&amp; !foldmethodIsManual(wp)) {</a>
<a name="ln5107">      foldUpdateAll(wp);</a>
<a name="ln5108">    }</a>
<a name="ln5109">  }</a>
<a name="ln5110"> </a>
<a name="ln5111">  /* If the mode didn't change and 'readonly' was set, keep the old</a>
<a name="ln5112">   * value; the user probably used the &quot;:view&quot; command.  But don't</a>
<a name="ln5113">   * reset it, might have had a read error. */</a>
<a name="ln5114">  if (orig_mode == curbuf-&gt;b_orig_mode)</a>
<a name="ln5115">    curbuf-&gt;b_p_ro |= old_ro;</a>
<a name="ln5116"> </a>
<a name="ln5117">  /* Modelines must override settings done by autocommands. */</a>
<a name="ln5118">  do_modelines(0);</a>
<a name="ln5119"> </a>
<a name="ln5120">  /* restore curwin/curbuf and a few other things */</a>
<a name="ln5121">  aucmd_restbuf(&amp;aco);</a>
<a name="ln5122">  /* Careful: autocommands may have made &quot;buf&quot; invalid! */</a>
<a name="ln5123">}</a>
<a name="ln5124"> </a>
<a name="ln5125">void buf_store_file_info(buf_T *buf, FileInfo *file_info)</a>
<a name="ln5126">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5127">{</a>
<a name="ln5128">  buf-&gt;b_mtime = file_info-&gt;stat.st_mtim.tv_sec;</a>
<a name="ln5129">  buf-&gt;b_orig_size = os_fileinfo_size(file_info);</a>
<a name="ln5130">  buf-&gt;b_orig_mode = (int)file_info-&gt;stat.st_mode;</a>
<a name="ln5131">}</a>
<a name="ln5132"> </a>
<a name="ln5133">/*</a>
<a name="ln5134"> * Adjust the line with missing eol, used for the next write.</a>
<a name="ln5135"> * Used for do_filter(), when the input lines for the filter are deleted.</a>
<a name="ln5136"> */</a>
<a name="ln5137">void write_lnum_adjust(linenr_T offset)</a>
<a name="ln5138">{</a>
<a name="ln5139">  if (curbuf-&gt;b_no_eol_lnum != 0)       /* only if there is a missing eol */</a>
<a name="ln5140">    curbuf-&gt;b_no_eol_lnum += offset;</a>
<a name="ln5141">}</a>
<a name="ln5142"> </a>
<a name="ln5143">#if defined(BACKSLASH_IN_FILENAME)</a>
<a name="ln5144">/// Convert all backslashes in fname to forward slashes in-place,</a>
<a name="ln5145">/// unless when it looks like a URL.</a>
<a name="ln5146">void forward_slash(char_u *fname)</a>
<a name="ln5147">{</a>
<a name="ln5148">  char_u      *p;</a>
<a name="ln5149"> </a>
<a name="ln5150">  if (path_with_url((const char *)fname)) {</a>
<a name="ln5151">    return;</a>
<a name="ln5152">  }</a>
<a name="ln5153">  for (p = fname; *p != NUL; p++) {</a>
<a name="ln5154">    // The Big5 encoding can have '\' in the trail byte.</a>
<a name="ln5155">    if (*p == '\\') {</a>
<a name="ln5156">      *p = '/';</a>
<a name="ln5157">    }</a>
<a name="ln5158">  }</a>
<a name="ln5159">}</a>
<a name="ln5160">#endif</a>
<a name="ln5161"> </a>
<a name="ln5162">/// Name of Vim's own temp dir. Ends in a slash.</a>
<a name="ln5163">static char_u *vim_tempdir = NULL;</a>
<a name="ln5164"> </a>
<a name="ln5165">/// Create a directory for private use by this instance of Neovim.</a>
<a name="ln5166">/// This is done once, and the same directory is used for all temp files.</a>
<a name="ln5167">/// This method avoids security problems because of symlink attacks et al.</a>
<a name="ln5168">/// It's also a bit faster, because we only need to check for an existing</a>
<a name="ln5169">/// file when creating the directory and not for each temp file.</a>
<a name="ln5170">static void vim_maketempdir(void)</a>
<a name="ln5171">{</a>
<a name="ln5172">  static const char *temp_dirs[] = TEMP_DIR_NAMES;</a>
<a name="ln5173">  // Try the entries in `TEMP_DIR_NAMES` to create the temp directory.</a>
<a name="ln5174">  char_u template[TEMP_FILE_PATH_MAXLEN];</a>
<a name="ln5175">  char_u path[TEMP_FILE_PATH_MAXLEN];</a>
<a name="ln5176"> </a>
<a name="ln5177">  // Make sure the umask doesn't remove the executable bit.</a>
<a name="ln5178">  // &quot;repl&quot; has been reported to use &quot;0177&quot;.</a>
<a name="ln5179">  mode_t umask_save = umask(0077);</a>
<a name="ln5180">  for (size_t i = 0; i &lt; ARRAY_SIZE(temp_dirs); i++) {</a>
<a name="ln5181">    // Expand environment variables, leave room for &quot;/nvimXXXXXX/999999999&quot;</a>
<a name="ln5182">    expand_env((char_u *)temp_dirs[i], template, TEMP_FILE_PATH_MAXLEN - 22);</a>
<a name="ln5183">    if (!os_isdir(template)) {  // directory doesn't exist</a>
<a name="ln5184">      continue;</a>
<a name="ln5185">    }</a>
<a name="ln5186"> </a>
<a name="ln5187">    add_pathsep((char *)template);</a>
<a name="ln5188">    // Concatenate with temporary directory name pattern</a>
<a name="ln5189">    STRCAT(template, &quot;nvimXXXXXX&quot;);</a>
<a name="ln5190"> </a>
<a name="ln5191">    if (os_mkdtemp((const char *)template, (char *)path) != 0) {</a>
<a name="ln5192">      continue;</a>
<a name="ln5193">    }</a>
<a name="ln5194"> </a>
<a name="ln5195">    if (vim_settempdir((char *)path)) {</a>
<a name="ln5196">      // Successfully created and set temporary directory so stop trying.</a>
<a name="ln5197">      break;</a>
<a name="ln5198">    } else {</a>
<a name="ln5199">      // Couldn't set `vim_tempdir` to `path` so remove created directory.</a>
<a name="ln5200">      os_rmdir((char *)path);</a>
<a name="ln5201">    }</a>
<a name="ln5202">  }</a>
<a name="ln5203">  (void)umask(umask_save);</a>
<a name="ln5204">}</a>
<a name="ln5205"> </a>
<a name="ln5206">/// Delete &quot;name&quot; and everything in it, recursively.</a>
<a name="ln5207">/// @param name The path which should be deleted.</a>
<a name="ln5208">/// @return 0 for success, -1 if some file was not deleted.</a>
<a name="ln5209">int delete_recursive(const char *name)</a>
<a name="ln5210">{</a>
<a name="ln5211">  int result = 0;</a>
<a name="ln5212"> </a>
<a name="ln5213">  if (os_isrealdir(name)) {</a>
<a name="ln5214">    snprintf((char *)NameBuff, MAXPATHL, &quot;%s/*&quot;, name);  // NOLINT</a>
<a name="ln5215"> </a>
<a name="ln5216">    char_u **files;</a>
<a name="ln5217">    int file_count;</a>
<a name="ln5218">    char_u *exp = vim_strsave(NameBuff);</a>
<a name="ln5219">    if (gen_expand_wildcards(1, &amp;exp, &amp;file_count, &amp;files,</a>
<a name="ln5220">                             EW_DIR | EW_FILE | EW_SILENT | EW_ALLLINKS</a>
<a name="ln5221">                             | EW_DODOT | EW_EMPTYOK) == OK) {</a>
<a name="ln5222">      for (int i = 0; i &lt; file_count; i++) {</a>
<a name="ln5223">        if (delete_recursive((const char *)files[i]) != 0) {</a>
<a name="ln5224">          result = -1;</a>
<a name="ln5225">        }</a>
<a name="ln5226">      }</a>
<a name="ln5227">      FreeWild(file_count, files);</a>
<a name="ln5228">    } else {</a>
<a name="ln5229">      result = -1;</a>
<a name="ln5230">    }</a>
<a name="ln5231"> </a>
<a name="ln5232">    xfree(exp);</a>
<a name="ln5233">    os_rmdir(name);</a>
<a name="ln5234">  } else {</a>
<a name="ln5235">    result = os_remove(name) == 0 ? 0 : -1;</a>
<a name="ln5236">  }</a>
<a name="ln5237"> </a>
<a name="ln5238">  return result;</a>
<a name="ln5239">}</a>
<a name="ln5240"> </a>
<a name="ln5241">/// Delete the temp directory and all files it contains.</a>
<a name="ln5242">void vim_deltempdir(void)</a>
<a name="ln5243">{</a>
<a name="ln5244">  if (vim_tempdir != NULL) {</a>
<a name="ln5245">    // remove the trailing path separator</a>
<a name="ln5246">    path_tail(vim_tempdir)[-1] = NUL;</a>
<a name="ln5247">    delete_recursive((const char *)vim_tempdir);</a>
<a name="ln5248">    XFREE_CLEAR(vim_tempdir);</a>
<a name="ln5249">  }</a>
<a name="ln5250">}</a>
<a name="ln5251"> </a>
<a name="ln5252">/// Get the name of temp directory. This directory would be created on the first</a>
<a name="ln5253">/// call to this function.</a>
<a name="ln5254">char_u *vim_gettempdir(void)</a>
<a name="ln5255">{</a>
<a name="ln5256">  if (vim_tempdir == NULL) {</a>
<a name="ln5257">    vim_maketempdir();</a>
<a name="ln5258">  }</a>
<a name="ln5259"> </a>
<a name="ln5260">  return vim_tempdir;</a>
<a name="ln5261">}</a>
<a name="ln5262"> </a>
<a name="ln5263">/// Set Neovim own temporary directory name to `tempdir`. This directory should</a>
<a name="ln5264">/// be already created. Expand this name to a full path and put it in</a>
<a name="ln5265">/// `vim_tempdir`. This avoids that using `:cd` would confuse us.</a>
<a name="ln5266">///</a>
<a name="ln5267">/// @param tempdir must be no longer than MAXPATHL.</a>
<a name="ln5268">///</a>
<a name="ln5269">/// @return false if we run out of memory.</a>
<a name="ln5270">static bool vim_settempdir(char *tempdir)</a>
<a name="ln5271">{</a>
<a name="ln5272">  char *buf = verbose_try_malloc(MAXPATHL + 2);</a>
<a name="ln5273">  if (!buf) {</a>
<a name="ln5274">    return false;</a>
<a name="ln5275">  }</a>
<a name="ln5276">  vim_FullName(tempdir, buf, MAXPATHL, false);</a>
<a name="ln5277">  add_pathsep(buf);</a>
<a name="ln5278">  vim_tempdir = (char_u *)xstrdup(buf);</a>
<a name="ln5279">  xfree(buf);</a>
<a name="ln5280">  return true;</a>
<a name="ln5281">}</a>
<a name="ln5282"> </a>
<a name="ln5283">/// Return a unique name that can be used for a temp file.</a>
<a name="ln5284">///</a>
<a name="ln5285">/// @note The temp file is NOT created.</a>
<a name="ln5286">///</a>
<a name="ln5287">/// @return pointer to the temp file name or NULL if Neovim can't create</a>
<a name="ln5288">///         temporary directory for its own temporary files.</a>
<a name="ln5289">char_u *vim_tempname(void)</a>
<a name="ln5290">{</a>
<a name="ln5291">  // Temp filename counter.</a>
<a name="ln5292">  static uint64_t temp_count;</a>
<a name="ln5293"> </a>
<a name="ln5294">  char_u *tempdir = vim_gettempdir();</a>
<a name="ln5295">  if (!tempdir) {</a>
<a name="ln5296">    return NULL;</a>
<a name="ln5297">  }</a>
<a name="ln5298"> </a>
<a name="ln5299">  // There is no need to check if the file exists, because we own the directory</a>
<a name="ln5300">  // and nobody else creates a file in it.</a>
<a name="ln5301">  char_u template[TEMP_FILE_PATH_MAXLEN];</a>
<a name="ln5302">  snprintf((char *)template, TEMP_FILE_PATH_MAXLEN,</a>
<a name="ln5303">           &quot;%s%&quot; PRIu64, tempdir, temp_count++);</a>
<a name="ln5304">  return vim_strsave(template);</a>
<a name="ln5305">}</a>
<a name="ln5306"> </a>
<a name="ln5307"> </a>
<a name="ln5308"> </a>
<a name="ln5309">/// Tries matching a filename with a &quot;pattern&quot; (&quot;prog&quot; is NULL), or use the</a>
<a name="ln5310">/// precompiled regprog &quot;prog&quot; (&quot;pattern&quot; is NULL).  That avoids calling</a>
<a name="ln5311">/// vim_regcomp() often.</a>
<a name="ln5312">///</a>
<a name="ln5313">/// Used for autocommands and 'wildignore'.</a>
<a name="ln5314">///</a>
<a name="ln5315">/// @param pattern pattern to match with</a>
<a name="ln5316">/// @param prog pre-compiled regprog or NULL</a>
<a name="ln5317">/// @param fname full path of the file name</a>
<a name="ln5318">/// @param sfname short file name or NULL</a>
<a name="ln5319">/// @param tail tail of the path</a>
<a name="ln5320">/// @param allow_dirs Allow matching with dir</a>
<a name="ln5321">///</a>
<a name="ln5322">/// @return true if there is a match, false otherwise</a>
<a name="ln5323">bool match_file_pat(char_u *pattern, regprog_T **prog, char_u *fname,</a>
<a name="ln5324">                    char_u *sfname, char_u *tail, int allow_dirs)</a>
<a name="ln5325">{</a>
<a name="ln5326">  regmatch_T regmatch;</a>
<a name="ln5327">  bool result = false;</a>
<a name="ln5328"> </a>
<a name="ln5329">  regmatch.rm_ic = p_fic;   /* ignore case if 'fileignorecase' is set */</a>
<a name="ln5330">  {</a>
<a name="ln5331">    if (prog != NULL)</a>
<a name="ln5332">      regmatch.regprog = *prog;</a>
<a name="ln5333">    else</a>
<a name="ln5334">      regmatch.regprog = vim_regcomp(pattern, RE_MAGIC);</a>
<a name="ln5335">  }</a>
<a name="ln5336"> </a>
<a name="ln5337">  /*</a>
<a name="ln5338">   * Try for a match with the pattern with:</a>
<a name="ln5339">   * 1. the full file name, when the pattern has a '/'.</a>
<a name="ln5340">   * 2. the short file name, when the pattern has a '/'.</a>
<a name="ln5341">   * 3. the tail of the file name, when the pattern has no '/'.</a>
<a name="ln5342">   */</a>
<a name="ln5343">  if (regmatch.regprog != NULL</a>
<a name="ln5344">      &amp;&amp; ((allow_dirs</a>
<a name="ln5345">           &amp;&amp; (vim_regexec(&amp;regmatch, fname, (colnr_T)0)</a>
<a name="ln5346">               || (sfname != NULL</a>
<a name="ln5347">                   &amp;&amp; vim_regexec(&amp;regmatch, sfname, (colnr_T)0))))</a>
<a name="ln5348">          || (!allow_dirs &amp;&amp; vim_regexec(&amp;regmatch, tail, (colnr_T)0)))) {</a>
<a name="ln5349">    result = true;</a>
<a name="ln5350">  }</a>
<a name="ln5351"> </a>
<a name="ln5352">  if (prog != NULL) {</a>
<a name="ln5353">    *prog = regmatch.regprog;</a>
<a name="ln5354">  } else {</a>
<a name="ln5355">    vim_regfree(regmatch.regprog);</a>
<a name="ln5356">  }</a>
<a name="ln5357">  return result;</a>
<a name="ln5358">}</a>
<a name="ln5359"> </a>
<a name="ln5360">/// Check if a file matches with a pattern in &quot;list&quot;.</a>
<a name="ln5361">/// &quot;list&quot; is a comma-separated list of patterns, like 'wildignore'.</a>
<a name="ln5362">/// &quot;sfname&quot; is the short file name or NULL, &quot;ffname&quot; the long file name.</a>
<a name="ln5363">///</a>
<a name="ln5364">/// @param list list of patterns to match</a>
<a name="ln5365">/// @param sfname short file name</a>
<a name="ln5366">/// @param ffname full file name</a>
<a name="ln5367">///</a>
<a name="ln5368">/// @return true if there was a match</a>
<a name="ln5369">bool match_file_list(char_u *list, char_u *sfname, char_u *ffname)</a>
<a name="ln5370">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ARG(1, 3)</a>
<a name="ln5371">{</a>
<a name="ln5372">  char_u buf[100];</a>
<a name="ln5373">  char_u      *tail;</a>
<a name="ln5374">  char_u      *regpat;</a>
<a name="ln5375">  char allow_dirs;</a>
<a name="ln5376">  bool match;</a>
<a name="ln5377">  char_u      *p;</a>
<a name="ln5378"> </a>
<a name="ln5379">  tail = path_tail(sfname);</a>
<a name="ln5380"> </a>
<a name="ln5381">  // try all patterns in 'wildignore'</a>
<a name="ln5382">  p = list;</a>
<a name="ln5383">  while (*p) {</a>
<a name="ln5384">    copy_option_part(&amp;p, buf, ARRAY_SIZE(buf), &quot;,&quot;);</a>
<a name="ln5385">    regpat = file_pat_to_reg_pat(buf, NULL, &amp;allow_dirs, false);</a>
<a name="ln5386">    if (regpat == NULL) {</a>
<a name="ln5387">      break;</a>
<a name="ln5388">    }</a>
<a name="ln5389">    match = match_file_pat(regpat, NULL, ffname, sfname, tail, (int)allow_dirs);</a>
<a name="ln5390">    xfree(regpat);</a>
<a name="ln5391">    if (match) {</a>
<a name="ln5392">      return true;</a>
<a name="ln5393">    }</a>
<a name="ln5394">  }</a>
<a name="ln5395">  return false;</a>
<a name="ln5396">}</a>
<a name="ln5397"> </a>
<a name="ln5398">/// Convert the given pattern &quot;pat&quot; which has shell style wildcards in it, into</a>
<a name="ln5399">/// a regular expression, and return the result in allocated memory.  If there</a>
<a name="ln5400">/// is a directory path separator to be matched, then TRUE is put in</a>
<a name="ln5401">/// allow_dirs, otherwise FALSE is put there -- webb.</a>
<a name="ln5402">/// Handle backslashes before special characters, like &quot;\*&quot; and &quot;\ &quot;.</a>
<a name="ln5403">///</a>
<a name="ln5404">/// Returns NULL on failure.</a>
<a name="ln5405">char_u * file_pat_to_reg_pat(</a>
<a name="ln5406">    const char_u *pat,</a>
<a name="ln5407">    const char_u *pat_end,   // first char after pattern or NULL</a>
<a name="ln5408">    char *allow_dirs,        // Result passed back out in here</a>
<a name="ln5409">    int no_bslash            // Don't use a backward slash as pathsep</a>
<a name="ln5410">)</a>
<a name="ln5411">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln5412">{</a>
<a name="ln5413">  const char_u *endp;</a>
<a name="ln5414">  char_u      *reg_pat;</a>
<a name="ln5415">  const char_u *p;</a>
<a name="ln5416">  int nested = 0;</a>
<a name="ln5417">  int add_dollar = TRUE;</a>
<a name="ln5418"> </a>
<a name="ln5419">  if (allow_dirs != NULL)</a>
<a name="ln5420">    *allow_dirs = FALSE;</a>
<a name="ln5421">  if (pat_end == NULL)</a>
<a name="ln5422">    pat_end = pat + STRLEN(pat);</a>
<a name="ln5423"> </a>
<a name="ln5424">  if (pat_end == pat) {</a>
<a name="ln5425">    return (char_u *)xstrdup(&quot;^$&quot;);</a>
<a name="ln5426">  }</a>
<a name="ln5427"> </a>
<a name="ln5428">  size_t size = 2;  // '^' at start, '$' at end.</a>
<a name="ln5429"> </a>
<a name="ln5430">  for (p = pat; p &lt; pat_end; p++) {</a>
<a name="ln5431">    switch (*p) {</a>
<a name="ln5432">    case '*':</a>
<a name="ln5433">    case '.':</a>
<a name="ln5434">    case ',':</a>
<a name="ln5435">    case '{':</a>
<a name="ln5436">    case '}':</a>
<a name="ln5437">    case '~':</a>
<a name="ln5438">      size += 2;                /* extra backslash */</a>
<a name="ln5439">      break;</a>
<a name="ln5440">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln5441">    case '\\':</a>
<a name="ln5442">    case '/':</a>
<a name="ln5443">      size += 4;                /* could become &quot;[\/]&quot; */</a>
<a name="ln5444">      break;</a>
<a name="ln5445">#endif</a>
<a name="ln5446">    default:</a>
<a name="ln5447">      size++;</a>
<a name="ln5448">      break;</a>
<a name="ln5449">    }</a>
<a name="ln5450">  }</a>
<a name="ln5451">  reg_pat = xmalloc(size + 1);</a>
<a name="ln5452"> </a>
<a name="ln5453">  size_t i = 0;</a>
<a name="ln5454"> </a>
<a name="ln5455">  if (pat[0] == '*')</a>
<a name="ln5456">    while (pat[0] == '*' &amp;&amp; pat &lt; pat_end - 1)</a>
<a name="ln5457">      pat++;</a>
<a name="ln5458">  else</a>
<a name="ln5459">    reg_pat[i++] = '^';</a>
<a name="ln5460">  endp = pat_end - 1;</a>
<a name="ln5461">  if (endp &gt;= pat &amp;&amp; *endp == '*') {</a>
<a name="ln5462">    while (endp - pat &gt; 0 &amp;&amp; *endp == '*') {</a>
<a name="ln5463">      endp--;</a>
<a name="ln5464">    }</a>
<a name="ln5465">    add_dollar = false;</a>
<a name="ln5466">  }</a>
<a name="ln5467">  for (p = pat; *p &amp;&amp; nested &gt;= 0 &amp;&amp; p &lt;= endp; p++) {</a>
<a name="ln5468">    switch (*p) {</a>
<a name="ln5469">    case '*':</a>
<a name="ln5470">      reg_pat[i++] = '.';</a>
<a name="ln5471">      reg_pat[i++] = '*';</a>
<a name="ln5472">      while (p[1] == '*')               /* &quot;**&quot; matches like &quot;*&quot; */</a>
<a name="ln5473">        ++p;</a>
<a name="ln5474">      break;</a>
<a name="ln5475">    case '.':</a>
<a name="ln5476">    case '~':</a>
<a name="ln5477">      reg_pat[i++] = '\\';</a>
<a name="ln5478">      reg_pat[i++] = *p;</a>
<a name="ln5479">      break;</a>
<a name="ln5480">    case '?':</a>
<a name="ln5481">      reg_pat[i++] = '.';</a>
<a name="ln5482">      break;</a>
<a name="ln5483">    case '\\':</a>
<a name="ln5484">      if (p[1] == NUL)</a>
<a name="ln5485">        break;</a>
<a name="ln5486">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln5487">      if (!no_bslash) {</a>
<a name="ln5488">        /* translate:</a>
<a name="ln5489">         * &quot;\x&quot; to &quot;\\x&quot;  e.g., &quot;dir\file&quot;</a>
<a name="ln5490">         * &quot;\*&quot; to &quot;\\.*&quot; e.g., &quot;dir\*.c&quot;</a>
<a name="ln5491">         * &quot;\?&quot; to &quot;\\.&quot;  e.g., &quot;dir\??.c&quot;</a>
<a name="ln5492">         * &quot;\+&quot; to &quot;\+&quot;   e.g., &quot;fileX\+.c&quot;</a>
<a name="ln5493">         */</a>
<a name="ln5494">        if ((vim_isfilec(p[1]) || p[1] == '*' || p[1] == '?')</a>
<a name="ln5495">            &amp;&amp; p[1] != '+') {</a>
<a name="ln5496">          reg_pat[i++] = '[';</a>
<a name="ln5497">          reg_pat[i++] = '\\';</a>
<a name="ln5498">          reg_pat[i++] = '/';</a>
<a name="ln5499">          reg_pat[i++] = ']';</a>
<a name="ln5500">          if (allow_dirs != NULL)</a>
<a name="ln5501">            *allow_dirs = TRUE;</a>
<a name="ln5502">          break;</a>
<a name="ln5503">        }</a>
<a name="ln5504">      }</a>
<a name="ln5505">#endif</a>
<a name="ln5506">      /* Undo escaping from ExpandEscape():</a>
<a name="ln5507">       * foo\?bar -&gt; foo?bar</a>
<a name="ln5508">       * foo\%bar -&gt; foo%bar</a>
<a name="ln5509">       * foo\,bar -&gt; foo,bar</a>
<a name="ln5510">       * foo\ bar -&gt; foo bar</a>
<a name="ln5511">       * Don't unescape \, * and others that are also special in a</a>
<a name="ln5512">       * regexp.</a>
<a name="ln5513">       * An escaped { must be unescaped since we use magic not</a>
<a name="ln5514">       * verymagic.  Use &quot;\\\{n,m\}&quot;&quot; to get &quot;\{n,m}&quot;.</a>
<a name="ln5515">       */</a>
<a name="ln5516">      if (*++p == '?'</a>
<a name="ln5517">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln5518">          &amp;&amp; no_bslash</a>
<a name="ln5519">#endif</a>
<a name="ln5520">          ) {</a>
<a name="ln5521">        reg_pat[i++] = '?';</a>
<a name="ln5522">      } else if (*p == ',' || *p == '%' || *p == '#'</a>
<a name="ln5523">                 || ascii_isspace(*p) || *p == '{' || *p == '}') {</a>
<a name="ln5524">        reg_pat[i++] = *p;</a>
<a name="ln5525">      } else if (*p == '\\' &amp;&amp; p[1] == '\\' &amp;&amp; p[2] == '{') {</a>
<a name="ln5526">        reg_pat[i++] = '\\';</a>
<a name="ln5527">        reg_pat[i++] = '{';</a>
<a name="ln5528">        p += 2;</a>
<a name="ln5529">      } else {</a>
<a name="ln5530">        if (allow_dirs != NULL &amp;&amp; vim_ispathsep(*p)</a>
<a name="ln5531">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln5532">            &amp;&amp; (!no_bslash || *p != '\\')</a>
<a name="ln5533">#endif</a>
<a name="ln5534">            )</a>
<a name="ln5535">          *allow_dirs = TRUE;</a>
<a name="ln5536">        reg_pat[i++] = '\\';</a>
<a name="ln5537">        reg_pat[i++] = *p;</a>
<a name="ln5538">      }</a>
<a name="ln5539">      break;</a>
<a name="ln5540">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln5541">    case '/':</a>
<a name="ln5542">      reg_pat[i++] = '[';</a>
<a name="ln5543">      reg_pat[i++] = '\\';</a>
<a name="ln5544">      reg_pat[i++] = '/';</a>
<a name="ln5545">      reg_pat[i++] = ']';</a>
<a name="ln5546">      if (allow_dirs != NULL)</a>
<a name="ln5547">        *allow_dirs = TRUE;</a>
<a name="ln5548">      break;</a>
<a name="ln5549">#endif</a>
<a name="ln5550">    case '{':</a>
<a name="ln5551">      reg_pat[i++] = '\\';</a>
<a name="ln5552">      reg_pat[i++] = '(';</a>
<a name="ln5553">      nested++;</a>
<a name="ln5554">      break;</a>
<a name="ln5555">    case '}':</a>
<a name="ln5556">      reg_pat[i++] = '\\';</a>
<a name="ln5557">      reg_pat[i++] = ')';</a>
<a name="ln5558">      --nested;</a>
<a name="ln5559">      break;</a>
<a name="ln5560">    case ',':</a>
<a name="ln5561">      if (nested) {</a>
<a name="ln5562">        reg_pat[i++] = '\\';</a>
<a name="ln5563">        reg_pat[i++] = '|';</a>
<a name="ln5564">      } else</a>
<a name="ln5565">        reg_pat[i++] = ',';</a>
<a name="ln5566">      break;</a>
<a name="ln5567">    default:</a>
<a name="ln5568">      if (allow_dirs != NULL &amp;&amp; vim_ispathsep(*p)) {</a>
<a name="ln5569">        *allow_dirs = true;</a>
<a name="ln5570">      }</a>
<a name="ln5571">      reg_pat[i++] = *p;</a>
<a name="ln5572">      break;</a>
<a name="ln5573">    }</a>
<a name="ln5574">  }</a>
<a name="ln5575">  if (add_dollar)</a>
<a name="ln5576">    reg_pat[i++] = '$';</a>
<a name="ln5577">  reg_pat[i] = NUL;</a>
<a name="ln5578">  if (nested != 0) {</a>
<a name="ln5579">    if (nested &lt; 0) {</a>
<a name="ln5580">      EMSG(_(&quot;E219: Missing {.&quot;));</a>
<a name="ln5581">    } else {</a>
<a name="ln5582">      EMSG(_(&quot;E220: Missing }.&quot;));</a>
<a name="ln5583">    }</a>
<a name="ln5584">    XFREE_CLEAR(reg_pat);</a>
<a name="ln5585">  }</a>
<a name="ln5586">  return reg_pat;</a>
<a name="ln5587">}</a>
<a name="ln5588"> </a>
<a name="ln5589">#if defined(EINTR)</a>
<a name="ln5590">/*</a>
<a name="ln5591"> * Version of read() that retries when interrupted by EINTR (possibly</a>
<a name="ln5592"> * by a SIGWINCH).</a>
<a name="ln5593"> */</a>
<a name="ln5594">long read_eintr(int fd, void *buf, size_t bufsize)</a>
<a name="ln5595">{</a>
<a name="ln5596">  long ret;</a>
<a name="ln5597"> </a>
<a name="ln5598">  for (;; ) {</a>
<a name="ln5599">    ret = read(fd, buf, bufsize);</a>
<a name="ln5600">    if (ret &gt;= 0 || errno != EINTR)</a>
<a name="ln5601">      break;</a>
<a name="ln5602">  }</a>
<a name="ln5603">  return ret;</a>
<a name="ln5604">}</a>
<a name="ln5605"> </a>
<a name="ln5606">/*</a>
<a name="ln5607"> * Version of write() that retries when interrupted by EINTR (possibly</a>
<a name="ln5608"> * by a SIGWINCH).</a>
<a name="ln5609"> */</a>
<a name="ln5610">long write_eintr(int fd, void *buf, size_t bufsize)</a>
<a name="ln5611">{</a>
<a name="ln5612">  long ret = 0;</a>
<a name="ln5613">  long wlen;</a>
<a name="ln5614"> </a>
<a name="ln5615">  /* Repeat the write() so long it didn't fail, other than being interrupted</a>
<a name="ln5616">   * by a signal. */</a>
<a name="ln5617">  while (ret &lt; (long)bufsize) {</a>
<a name="ln5618">    wlen = write(fd, (char *)buf + ret, bufsize - ret);</a>
<a name="ln5619">    if (wlen &lt; 0) {</a>
<a name="ln5620">      if (errno != EINTR)</a>
<a name="ln5621">        break;</a>
<a name="ln5622">    } else</a>
<a name="ln5623">      ret += wlen;</a>
<a name="ln5624">  }</a>
<a name="ln5625">  return ret;</a>
<a name="ln5626">}</a>
<a name="ln5627">#endif</a>

</code></pre>
<div class="balloon" rel="4497"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="5384"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
