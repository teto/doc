
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>typval.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;stdio.h&gt;</a>
<a name="ln5">#include &lt;stddef.h&gt;</a>
<a name="ln6">#include &lt;stdlib.h&gt;</a>
<a name="ln7">#include &lt;string.h&gt;</a>
<a name="ln8">#include &lt;assert.h&gt;</a>
<a name="ln9">#include &lt;stdbool.h&gt;</a>
<a name="ln10"> </a>
<a name="ln11">#include &quot;nvim/lib/queue.h&quot;</a>
<a name="ln12">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln13">#include &quot;nvim/eval/gc.h&quot;</a>
<a name="ln14">#include &quot;nvim/eval/executor.h&quot;</a>
<a name="ln15">#include &quot;nvim/eval/encode.h&quot;</a>
<a name="ln16">#include &quot;nvim/eval/typval_encode.h&quot;</a>
<a name="ln17">#include &quot;nvim/eval.h&quot;</a>
<a name="ln18">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln19">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln20">#include &quot;nvim/types.h&quot;</a>
<a name="ln21">#include &quot;nvim/assert.h&quot;</a>
<a name="ln22">#include &quot;nvim/memory.h&quot;</a>
<a name="ln23">#include &quot;nvim/globals.h&quot;</a>
<a name="ln24">#include &quot;nvim/hashtab.h&quot;</a>
<a name="ln25">#include &quot;nvim/vim.h&quot;</a>
<a name="ln26">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln27">#include &quot;nvim/pos.h&quot;</a>
<a name="ln28">#include &quot;nvim/charset.h&quot;</a>
<a name="ln29">#include &quot;nvim/garray.h&quot;</a>
<a name="ln30">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln31">#include &quot;nvim/macros.h&quot;</a>
<a name="ln32">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln33">#include &quot;nvim/message.h&quot;</a>
<a name="ln34">// TODO(ZyX-I): Move line_breakcheck out of misc1</a>
<a name="ln35">#include &quot;nvim/misc1.h&quot;  // For line_breakcheck</a>
<a name="ln36">#include &quot;nvim/os/fileio.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln39"># include &quot;eval/typval.c.generated.h&quot;</a>
<a name="ln40">#endif</a>
<a name="ln41"> </a>
<a name="ln42">bool tv_in_free_unref_items = false;</a>
<a name="ln43"> </a>
<a name="ln44">// TODO(ZyX-I): Remove DICT_MAXNEST, make users be non-recursive instead</a>
<a name="ln45"> </a>
<a name="ln46">#define DICT_MAXNEST 100</a>
<a name="ln47"> </a>
<a name="ln48">const char *const tv_empty_string = &quot;&quot;;</a>
<a name="ln49"> </a>
<a name="ln50">//{{{1 Lists</a>
<a name="ln51">//{{{2 List log</a>
<a name="ln52">#ifdef LOG_LIST_ACTIONS</a>
<a name="ln53">ListLog *list_log_first = NULL;</a>
<a name="ln54">ListLog *list_log_last = NULL;</a>
<a name="ln55"> </a>
<a name="ln56">/// Write list log to the given file</a>
<a name="ln57">///</a>
<a name="ln58">/// @param[in]  fname  File to write log to. Will be appended to if already</a>
<a name="ln59">///                    present.</a>
<a name="ln60">void list_write_log(const char *const fname)</a>
<a name="ln61">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln62">{</a>
<a name="ln63">  FileDescriptor fp;</a>
<a name="ln64">  const int fo_ret = file_open(&amp;fp, fname, kFileCreate|kFileAppend, 0600);</a>
<a name="ln65">  if (fo_ret != 0) {</a>
<a name="ln66">    emsgf(_(&quot;E5142: Failed to open file %s: %s&quot;), fname, os_strerror(fo_ret));</a>
<a name="ln67">    return;</a>
<a name="ln68">  }</a>
<a name="ln69">  for (ListLog *chunk = list_log_first; chunk != NULL;) {</a>
<a name="ln70">    for (size_t i = 0; i &lt; chunk-&gt;size; i++) {</a>
<a name="ln71">      char buf[10 + 1 + ((16 + 3) * 3) + (8 + 2) + 2];</a>
<a name="ln72">      //       act  :     hex  &quot; c:&quot;      len &quot;[]&quot; &quot;\n\0&quot;</a>
<a name="ln73">      const ListLogEntry entry = chunk-&gt;entries[i];</a>
<a name="ln74">      const size_t snp_len = (size_t)snprintf(</a>
<a name="ln75">          buf, sizeof(buf),</a>
<a name="ln76">          &quot;%-10.10s: l:%016&quot; PRIxPTR &quot;[%08d] 1:%016&quot; PRIxPTR &quot; 2:%016&quot; PRIxPTR</a>
<a name="ln77">          &quot;\n&quot;,</a>
<a name="ln78">          entry.action, entry.l, entry.len, entry.li1, entry.li2);</a>
<a name="ln79">      assert(snp_len + 1 == sizeof(buf));</a>
<a name="ln80">      const ptrdiff_t fw_ret = file_write(&amp;fp, buf, snp_len);</a>
<a name="ln81">      if (fw_ret != (ptrdiff_t)snp_len) {</a>
<a name="ln82">        assert(fw_ret &lt; 0);</a>
<a name="ln83">        if (i) {</a>
<a name="ln84">          memmove(chunk-&gt;entries, chunk-&gt;entries + i,</a>
<a name="ln85">                  sizeof(chunk-&gt;entries[0]) * (chunk-&gt;size - i));</a>
<a name="ln86">          chunk-&gt;size -= i;</a>
<a name="ln87">        }</a>
<a name="ln88">        emsgf(_(&quot;E5143: Failed to write to file %s: %s&quot;),</a>
<a name="ln89">              fname, os_strerror((int)fw_ret));</a>
<a name="ln90">        return;</a>
<a name="ln91">      }</a>
<a name="ln92">    }</a>
<a name="ln93">    list_log_first = chunk-&gt;next;</a>
<a name="ln94">    xfree(chunk);</a>
<a name="ln95">    chunk = list_log_first;</a>
<a name="ln96">  }</a>
<a name="ln97">  const int fc_ret = file_close(&amp;fp, true);</a>
<a name="ln98">  if (fc_ret != 0) {</a>
<a name="ln99">    emsgf(_(&quot;E5144: Failed to close file %s: %s&quot;), fname, os_strerror(fc_ret));</a>
<a name="ln100">  }</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">#ifdef EXITFREE</a>
<a name="ln104">/// Free list log</a>
<a name="ln105">void list_free_log(void)</a>
<a name="ln106">{</a>
<a name="ln107">  for (ListLog *chunk = list_log_first; chunk != NULL;) {</a>
<a name="ln108">    list_log_first = chunk-&gt;next;</a>
<a name="ln109">    xfree(chunk);</a>
<a name="ln110">    chunk = list_log_first;</a>
<a name="ln111">  }</a>
<a name="ln112">}</a>
<a name="ln113">#endif</a>
<a name="ln114">#endif</a>
<a name="ln115">//{{{2 List item</a>
<a name="ln116"> </a>
<a name="ln117">/// Allocate a list item</a>
<a name="ln118">///</a>
<a name="ln119">/// @warning Allocated item is not initialized, do not forget to initialize it</a>
<a name="ln120">///          and specifically set lv_lock.</a>
<a name="ln121">///</a>
<a name="ln122">/// @return [allocated] new list item.</a>
<a name="ln123">static listitem_T *tv_list_item_alloc(void)</a>
<a name="ln124">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC</a>
<a name="ln125">{</a>
<a name="ln126">  return xmalloc(sizeof(listitem_T));</a>
<a name="ln127">}</a>
<a name="ln128"> </a>
<a name="ln129">/// Remove a list item from a List and free it</a>
<a name="ln130">///</a>
<a name="ln131">/// Also clears the value.</a>
<a name="ln132">///</a>
<a name="ln133">/// @param[out]  l  List to remove item from.</a>
<a name="ln134">/// @param[in,out]  item  Item to remove.</a>
<a name="ln135">///</a>
<a name="ln136">/// @return Pointer to the list item just after removed one, NULL if removed</a>
<a name="ln137">///         item was the last one.</a>
<a name="ln138">listitem_T *tv_list_item_remove(list_T *const l, listitem_T *const item)</a>
<a name="ln139">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln140">{</a>
<a name="ln141">  listitem_T *const next_item = TV_LIST_ITEM_NEXT(l, item);</a>
<a name="ln142">  tv_list_drop_items(l, item, item);</a>
<a name="ln143">  tv_clear(TV_LIST_ITEM_TV(item));</a>
<a name="ln144">  xfree(item);</a>
<a name="ln145">  return next_item;</a>
<a name="ln146">}</a>
<a name="ln147"> </a>
<a name="ln148">//{{{2 List watchers</a>
<a name="ln149"> </a>
<a name="ln150">/// Add a watcher to a list</a>
<a name="ln151">///</a>
<a name="ln152">/// @param[out]  l  List to add watcher to.</a>
<a name="ln153">/// @param[in]  lw  Watcher to add.</a>
<a name="ln154">void tv_list_watch_add(list_T *const l, listwatch_T *const lw)</a>
<a name="ln155">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln156">{</a>
<a name="ln157">  lw-&gt;lw_next = l-&gt;lv_watch;</a>
<a name="ln158">  l-&gt;lv_watch = lw;</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161">/// Remove a watcher from a list</a>
<a name="ln162">///</a>
<a name="ln163">/// Does not give a warning if watcher was not found.</a>
<a name="ln164">///</a>
<a name="ln165">/// @param[out]  l  List to remove watcher from.</a>
<a name="ln166">/// @param[in]  lwrem  Watcher to remove.</a>
<a name="ln167">void tv_list_watch_remove(list_T *const l, listwatch_T *const lwrem)</a>
<a name="ln168">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln169">{</a>
<a name="ln170">  listwatch_T **lwp = &amp;l-&gt;lv_watch;</a>
<a name="ln171">  for (listwatch_T *lw = l-&gt;lv_watch; lw != NULL; lw = lw-&gt;lw_next) {</a>
<a name="ln172">    if (lw == lwrem) {</a>
<a name="ln173">      *lwp = lw-&gt;lw_next;</a>
<a name="ln174">      break;</a>
<a name="ln175">    }</a>
<a name="ln176">    lwp = &amp;lw-&gt;lw_next;</a>
<a name="ln177">  }</a>
<a name="ln178">}</a>
<a name="ln179"> </a>
<a name="ln180">/// Advance watchers to the next item</a>
<a name="ln181">///</a>
<a name="ln182">/// Used just before removing an item from a list.</a>
<a name="ln183">///</a>
<a name="ln184">/// @param[out]  l  List from which item is removed.</a>
<a name="ln185">/// @param[in]  item  List item being removed.</a>
<a name="ln186">void tv_list_watch_fix(list_T *const l, const listitem_T *const item)</a>
<a name="ln187">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln188">{</a>
<a name="ln189">  for (listwatch_T *lw = l-&gt;lv_watch; lw != NULL; lw = lw-&gt;lw_next) {</a>
<a name="ln190">    if (lw-&gt;lw_item == item) {</a>
<a name="ln191">      lw-&gt;lw_item = item-&gt;li_next;</a>
<a name="ln192">    }</a>
<a name="ln193">  }</a>
<a name="ln194">}</a>
<a name="ln195"> </a>
<a name="ln196">//{{{2 Alloc/free</a>
<a name="ln197"> </a>
<a name="ln198">/// Allocate an empty list</a>
<a name="ln199">///</a>
<a name="ln200">/// Caller should take care of the reference count.</a>
<a name="ln201">///</a>
<a name="ln202">/// @param[in]  len  Expected number of items to be populated before list</a>
<a name="ln203">///                  becomes accessible from VimL. It is still valid to</a>
<a name="ln204">///                  underpopulate a list, value only controls how many elements</a>
<a name="ln205">///                  will be allocated in advance. Currently does nothing.</a>
<a name="ln206">///                  @see ListLenSpecials.</a>
<a name="ln207">///</a>
<a name="ln208">/// @return [allocated] new list.</a>
<a name="ln209">list_T *tv_list_alloc(const ptrdiff_t len)</a>
<a name="ln210">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln211">{</a>
<a name="ln212">  list_T *const list = xcalloc(1, sizeof(list_T));</a>
<a name="ln213"> </a>
<a name="ln214">  // Prepend the list to the list of lists for garbage collection.</a>
<a name="ln215">  if (gc_first_list != NULL) {</a>
<a name="ln216">    gc_first_list-&gt;lv_used_prev = list;</a>
<a name="ln217">  }</a>
<a name="ln218">  list-&gt;lv_used_prev = NULL;</a>
<a name="ln219">  list-&gt;lv_used_next = gc_first_list;</a>
<a name="ln220">  gc_first_list = list;</a>
<a name="ln221">  list_log(list, NULL, (void *)(uintptr_t)len, &quot;alloc&quot;);</a>
<a name="ln222">  list-&gt;lua_table_ref = LUA_NOREF;</a>
<a name="ln223">  return list;</a>
<a name="ln224">}</a>
<a name="ln225"> </a>
<a name="ln226">/// Initialize a static list with 10 items</a>
<a name="ln227">///</a>
<a name="ln228">/// @param[out]  sl  Static list to initialize.</a>
<a name="ln229">void tv_list_init_static10(staticList10_T *const sl)</a>
<a name="ln230">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln231">{</a>
<a name="ln232">#define SL_SIZE ARRAY_SIZE(sl-&gt;sl_items)</a>
<a name="ln233">  list_T *const l = &amp;sl-&gt;sl_list;</a>
<a name="ln234"> </a>
<a name="ln235">  memset(sl, 0, sizeof(staticList10_T));</a>
<a name="ln236">  l-&gt;lv_first = &amp;sl-&gt;sl_items[0];</a>
<a name="ln237">  l-&gt;lv_last = &amp;sl-&gt;sl_items[SL_SIZE - 1];</a>
<a name="ln238">  l-&gt;lv_refcount = DO_NOT_FREE_CNT;</a>
<a name="ln239">  tv_list_set_lock(l, VAR_FIXED);</a>
<a name="ln240">  sl-&gt;sl_list.lv_len = 10;</a>
<a name="ln241"> </a>
<a name="ln242">  sl-&gt;sl_items[0].li_prev = NULL;</a>
<a name="ln243">  sl-&gt;sl_items[0].li_next = &amp;sl-&gt;sl_items[1];</a>
<a name="ln244">  sl-&gt;sl_items[SL_SIZE - 1].li_prev = &amp;sl-&gt;sl_items[SL_SIZE - 2];</a>
<a name="ln245">  sl-&gt;sl_items[SL_SIZE - 1].li_next = NULL;</a>
<a name="ln246"> </a>
<a name="ln247">  for (size_t i = 1; i &lt; SL_SIZE - 1; i++) {</a>
<a name="ln248">    listitem_T *const li = &amp;sl-&gt;sl_items[i];</a>
<a name="ln249">    li-&gt;li_prev = li - 1;</a>
<a name="ln250">    li-&gt;li_next = li + 1;</a>
<a name="ln251">  }</a>
<a name="ln252">  list_log((const list_T *)sl, &amp;sl-&gt;sl_items[0], &amp;sl-&gt;sl_items[SL_SIZE - 1],</a>
<a name="ln253">           &quot;s10init&quot;);</a>
<a name="ln254">#undef SL_SIZE</a>
<a name="ln255">}</a>
<a name="ln256"> </a>
<a name="ln257">/// Initialize static list with undefined number of elements</a>
<a name="ln258">///</a>
<a name="ln259">/// @param[out]  l  List to initialize.</a>
<a name="ln260">void tv_list_init_static(list_T *const l)</a>
<a name="ln261">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln262">{</a>
<a name="ln263">  memset(l, 0, sizeof(*l));</a>
<a name="ln264">  l-&gt;lv_refcount = DO_NOT_FREE_CNT;</a>
<a name="ln265">  list_log(l, NULL, NULL, &quot;sinit&quot;);</a>
<a name="ln266">}</a>
<a name="ln267"> </a>
<a name="ln268">/// Free items contained in a list</a>
<a name="ln269">///</a>
<a name="ln270">/// @param[in,out]  l  List to clear.</a>
<a name="ln271">void tv_list_free_contents(list_T *const l)</a>
<a name="ln272">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln273">{</a>
<a name="ln274">  list_log(l, NULL, NULL, &quot;freecont&quot;);</a>
<a name="ln275">  for (listitem_T *item = l-&gt;lv_first; item != NULL; item = l-&gt;lv_first) {</a>
<a name="ln276">    // Remove the item before deleting it.</a>
<a name="ln277">    l-&gt;lv_first = item-&gt;li_next;</a>
<a name="ln278">    tv_clear(&amp;item-&gt;li_tv);</a>
<a name="ln279">    xfree(item);</a>
<a name="ln280">  }</a>
<a name="ln281">  l-&gt;lv_len = 0;</a>
<a name="ln282">  l-&gt;lv_idx_item = NULL;</a>
<a name="ln283">  l-&gt;lv_last = NULL;</a>
<a name="ln284">  assert(l-&gt;lv_watch == NULL);</a>
<a name="ln285">}</a>
<a name="ln286"> </a>
<a name="ln287">/// Free a list itself, ignoring items it contains</a>
<a name="ln288">///</a>
<a name="ln289">/// Ignores the reference count.</a>
<a name="ln290">///</a>
<a name="ln291">/// @param[in,out]  l  List to free.</a>
<a name="ln292">void tv_list_free_list(list_T *const l)</a>
<a name="ln293">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln294">{</a>
<a name="ln295">  // Remove the list from the list of lists for garbage collection.</a>
<a name="ln296">  if (l-&gt;lv_used_prev == NULL) {</a>
<a name="ln297">    gc_first_list = l-&gt;lv_used_next;</a>
<a name="ln298">  } else {</a>
<a name="ln299">    l-&gt;lv_used_prev-&gt;lv_used_next = l-&gt;lv_used_next;</a>
<a name="ln300">  }</a>
<a name="ln301">  if (l-&gt;lv_used_next != NULL) {</a>
<a name="ln302">    l-&gt;lv_used_next-&gt;lv_used_prev = l-&gt;lv_used_prev;</a>
<a name="ln303">  }</a>
<a name="ln304">  list_log(l, NULL, NULL, &quot;freelist&quot;);</a>
<a name="ln305"> </a>
<a name="ln306">  NLUA_CLEAR_REF(l-&gt;lua_table_ref);</a>
<a name="ln307">  xfree(l);</a>
<a name="ln308">}</a>
<a name="ln309"> </a>
<a name="ln310">/// Free a list, including all items it points to</a>
<a name="ln311">///</a>
<a name="ln312">/// Ignores the reference count. Does not do anything if</a>
<a name="ln313">/// tv_in_free_unref_items is true.</a>
<a name="ln314">///</a>
<a name="ln315">/// @param[in,out]  l  List to free.</a>
<a name="ln316">void tv_list_free(list_T *const l)</a>
<a name="ln317">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln318">{</a>
<a name="ln319">  if (!tv_in_free_unref_items) {</a>
<a name="ln320">    tv_list_free_contents(l);</a>
<a name="ln321">    tv_list_free_list(l);</a>
<a name="ln322">  }</a>
<a name="ln323">}</a>
<a name="ln324"> </a>
<a name="ln325">/// Unreference a list</a>
<a name="ln326">///</a>
<a name="ln327">/// Decrements the reference count and frees when it becomes zero or less.</a>
<a name="ln328">///</a>
<a name="ln329">/// @param[in,out]  l  List to unreference.</a>
<a name="ln330">void tv_list_unref(list_T *const l)</a>
<a name="ln331">{</a>
<a name="ln332">  if (l != NULL &amp;&amp; --l-&gt;lv_refcount &lt;= 0) {</a>
<a name="ln333">    tv_list_free(l);</a>
<a name="ln334">  }</a>
<a name="ln335">}</a>
<a name="ln336"> </a>
<a name="ln337">//{{{2 Add/remove</a>
<a name="ln338"> </a>
<a name="ln339">/// Remove items &quot;item&quot; to &quot;item2&quot; from list &quot;l&quot;</a>
<a name="ln340">///</a>
<a name="ln341">/// @warning Does not free the listitem or the value!</a>
<a name="ln342">///</a>
<a name="ln343">/// @param[out]  l  List to remove from.</a>
<a name="ln344">/// @param[in]  item  First item to remove.</a>
<a name="ln345">/// @param[in]  item2  Last item to remove.</a>
<a name="ln346">void tv_list_drop_items(list_T *const l, listitem_T *const item,</a>
<a name="ln347">                        listitem_T *const item2)</a>
<a name="ln348">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln349">{</a>
<a name="ln350">  list_log(l, item, item2, &quot;drop&quot;);</a>
<a name="ln351">  // Notify watchers.</a>
<a name="ln352">  for (listitem_T *ip = item; ip != item2-&gt;li_next; ip = ip-&gt;li_next) {</a>
<a name="ln353">    l-&gt;lv_len--;</a>
<a name="ln354">    tv_list_watch_fix(l, ip);</a>
<a name="ln355">  }</a>
<a name="ln356"> </a>
<a name="ln357">  if (item2-&gt;li_next == NULL) {</a>
<a name="ln358">    l-&gt;lv_last = item-&gt;li_prev;</a>
<a name="ln359">  } else {</a>
<a name="ln360">    item2-&gt;li_next-&gt;li_prev = item-&gt;li_prev;</a>
<a name="ln361">  }</a>
<a name="ln362">  if (item-&gt;li_prev == NULL) {</a>
<a name="ln363">    l-&gt;lv_first = item2-&gt;li_next;</a>
<a name="ln364">  } else {</a>
<a name="ln365">    item-&gt;li_prev-&gt;li_next = item2-&gt;li_next;</a>
<a name="ln366">  }</a>
<a name="ln367">  l-&gt;lv_idx_item = NULL;</a>
<a name="ln368">  list_log(l, l-&gt;lv_first, l-&gt;lv_last, &quot;afterdrop&quot;);</a>
<a name="ln369">}</a>
<a name="ln370"> </a>
<a name="ln371">/// Like tv_list_drop_items, but also frees all removed items</a>
<a name="ln372">void tv_list_remove_items(list_T *const l, listitem_T *const item,</a>
<a name="ln373">                          listitem_T *const item2)</a>
<a name="ln374">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln375">{</a>
<a name="ln376">  list_log(l, item, item2, &quot;remove&quot;);</a>
<a name="ln377">  tv_list_drop_items(l, item, item2);</a>
<a name="ln378">  for (listitem_T *li = item;;) {</a>
<a name="ln379">    tv_clear(TV_LIST_ITEM_TV(li));</a>
<a name="ln380">    listitem_T *const nli = li-&gt;li_next;</a>
<a name="ln381">    xfree(li);</a>
<a name="ln382">    if (li == item2) {</a>
<a name="ln383">      break;</a>
<a name="ln384">    }</a>
<a name="ln385">    li = nli;</a>
<a name="ln386">  }</a>
<a name="ln387">}</a>
<a name="ln388"> </a>
<a name="ln389">/// Move items &quot;item&quot; to &quot;item2&quot; from list &quot;l&quot; to the end of the list &quot;tgt_l&quot;</a>
<a name="ln390">///</a>
<a name="ln391">/// @param[out]  l  List to move from.</a>
<a name="ln392">/// @param[in]  item  First item to move.</a>
<a name="ln393">/// @param[in]  item2  Last item to move.</a>
<a name="ln394">/// @param[out]  tgt_l  List to move to.</a>
<a name="ln395">/// @param[in]  cnt  Number of items moved.</a>
<a name="ln396">void tv_list_move_items(list_T *const l, listitem_T *const item,</a>
<a name="ln397">                        listitem_T *const item2, list_T *const tgt_l,</a>
<a name="ln398">                        const int cnt)</a>
<a name="ln399">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln400">{</a>
<a name="ln401">  list_log(l, item, item2, &quot;move&quot;);</a>
<a name="ln402">  tv_list_drop_items(l, item, item2);</a>
<a name="ln403">  item-&gt;li_prev = tgt_l-&gt;lv_last;</a>
<a name="ln404">  item2-&gt;li_next = NULL;</a>
<a name="ln405">  if (tgt_l-&gt;lv_last == NULL) {</a>
<a name="ln406">    tgt_l-&gt;lv_first = item;</a>
<a name="ln407">  } else {</a>
<a name="ln408">    tgt_l-&gt;lv_last-&gt;li_next = item;</a>
<a name="ln409">  }</a>
<a name="ln410">  tgt_l-&gt;lv_last = item2;</a>
<a name="ln411">  tgt_l-&gt;lv_len += cnt;</a>
<a name="ln412">  list_log(tgt_l, tgt_l-&gt;lv_first, tgt_l-&gt;lv_last, &quot;movetgt&quot;);</a>
<a name="ln413">}</a>
<a name="ln414"> </a>
<a name="ln415">/// Insert list item</a>
<a name="ln416">///</a>
<a name="ln417">/// @param[out]  l  List to insert to.</a>
<a name="ln418">/// @param[in,out]  ni  Item to insert.</a>
<a name="ln419">/// @param[in]  item  Item to insert before. If NULL, inserts at the end of the</a>
<a name="ln420">///                   list.</a>
<a name="ln421">void tv_list_insert(list_T *const l, listitem_T *const ni,</a>
<a name="ln422">                    listitem_T *const item)</a>
<a name="ln423">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln424">{</a>
<a name="ln425">  if (item == NULL) {</a>
<a name="ln426">    // Append new item at end of list.</a>
<a name="ln427">    tv_list_append(l, ni);</a>
<a name="ln428">  } else {</a>
<a name="ln429">    // Insert new item before existing item.</a>
<a name="ln430">    ni-&gt;li_prev = item-&gt;li_prev;</a>
<a name="ln431">    ni-&gt;li_next = item;</a>
<a name="ln432">    if (item-&gt;li_prev == NULL) {</a>
<a name="ln433">      l-&gt;lv_first = ni;</a>
<a name="ln434">      l-&gt;lv_idx++;</a>
<a name="ln435">    } else {</a>
<a name="ln436">      item-&gt;li_prev-&gt;li_next = ni;</a>
<a name="ln437">      l-&gt;lv_idx_item = NULL;</a>
<a name="ln438">    }</a>
<a name="ln439">    item-&gt;li_prev = ni;</a>
<a name="ln440">    l-&gt;lv_len++;</a>
<a name="ln441">    list_log(l, ni, item, &quot;insert&quot;);</a>
<a name="ln442">  }</a>
<a name="ln443">}</a>
<a name="ln444"> </a>
<a name="ln445">/// Insert VimL value into a list</a>
<a name="ln446">///</a>
<a name="ln447">/// @param[out]  l  List to insert to.</a>
<a name="ln448">/// @param[in,out]  tv  Value to insert. Is copied (@see tv_copy()) to an</a>
<a name="ln449">///                     allocated listitem_T and inserted.</a>
<a name="ln450">/// @param[in]  item  Item to insert before. If NULL, inserts at the end of the</a>
<a name="ln451">///                   list.</a>
<a name="ln452">void tv_list_insert_tv(list_T *const l, typval_T *const tv,</a>
<a name="ln453">                       listitem_T *const item)</a>
<a name="ln454">{</a>
<a name="ln455">  listitem_T *const ni = tv_list_item_alloc();</a>
<a name="ln456"> </a>
<a name="ln457">  tv_copy(tv, &amp;ni-&gt;li_tv);</a>
<a name="ln458">  tv_list_insert(l, ni, item);</a>
<a name="ln459">}</a>
<a name="ln460"> </a>
<a name="ln461">/// Append item to the end of list</a>
<a name="ln462">///</a>
<a name="ln463">/// @param[out]  l  List to append to.</a>
<a name="ln464">/// @param[in,out]  item  Item to append.</a>
<a name="ln465">void tv_list_append(list_T *const l, listitem_T *const item)</a>
<a name="ln466">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln467">{</a>
<a name="ln468">  list_log(l, item, NULL, &quot;append&quot;);</a>
<a name="ln469">  if (l-&gt;lv_last == NULL) {</a>
<a name="ln470">    // empty list</a>
<a name="ln471">    l-&gt;lv_first = item;</a>
<a name="ln472">    l-&gt;lv_last = item;</a>
<a name="ln473">    item-&gt;li_prev = NULL;</a>
<a name="ln474">  } else {</a>
<a name="ln475">    l-&gt;lv_last-&gt;li_next = item;</a>
<a name="ln476">    item-&gt;li_prev = l-&gt;lv_last;</a>
<a name="ln477">    l-&gt;lv_last = item;</a>
<a name="ln478">  }</a>
<a name="ln479">  l-&gt;lv_len++;</a>
<a name="ln480">  item-&gt;li_next = NULL;</a>
<a name="ln481">}</a>
<a name="ln482"> </a>
<a name="ln483">/// Append VimL value to the end of list</a>
<a name="ln484">///</a>
<a name="ln485">/// @param[out]  l  List to append to.</a>
<a name="ln486">/// @param[in,out]  tv  Value to append. Is copied (@see tv_copy()) to an</a>
<a name="ln487">///                     allocated listitem_T.</a>
<a name="ln488">void tv_list_append_tv(list_T *const l, typval_T *const tv)</a>
<a name="ln489">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln490">{</a>
<a name="ln491">  listitem_T *const li = tv_list_item_alloc();</a>
<a name="ln492">  tv_copy(tv, TV_LIST_ITEM_TV(li));</a>
<a name="ln493">  tv_list_append(l, li);</a>
<a name="ln494">}</a>
<a name="ln495"> </a>
<a name="ln496">/// Like tv_list_append_tv(), but tv is moved to a list</a>
<a name="ln497">///</a>
<a name="ln498">/// This means that it is no longer valid to use contents of the typval_T after</a>
<a name="ln499">/// function exits.</a>
<a name="ln500">void tv_list_append_owned_tv(list_T *const l, typval_T tv)</a>
<a name="ln501">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln502">{</a>
<a name="ln503">  listitem_T *const li = tv_list_item_alloc();</a>
<a name="ln504">  *TV_LIST_ITEM_TV(li) = tv;</a>
<a name="ln505">  tv_list_append(l, li);</a>
<a name="ln506">}</a>
<a name="ln507"> </a>
<a name="ln508">/// Append a list to a list as one item</a>
<a name="ln509">///</a>
<a name="ln510">/// @param[out]  l  List to append to.</a>
<a name="ln511">/// @param[in,out]  itemlist  List to append. Reference count is increased.</a>
<a name="ln512">void tv_list_append_list(list_T *const l, list_T *const itemlist)</a>
<a name="ln513">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln514">{</a>
<a name="ln515">  tv_list_append_owned_tv(l, (typval_T) {</a>
<a name="ln516">    .v_type = VAR_LIST,</a>
<a name="ln517">    .v_lock = VAR_UNLOCKED,</a>
<a name="ln518">    .vval.v_list = itemlist,</a>
<a name="ln519">  });</a>
<a name="ln520">  tv_list_ref(itemlist);</a>
<a name="ln521">}</a>
<a name="ln522"> </a>
<a name="ln523">/// Append a dictionary to a list</a>
<a name="ln524">///</a>
<a name="ln525">/// @param[out]  l  List to append to.</a>
<a name="ln526">/// @param[in,out]  dict  Dictionary to append. Reference count is increased.</a>
<a name="ln527">void tv_list_append_dict(list_T *const l, dict_T *const dict)</a>
<a name="ln528">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln529">{</a>
<a name="ln530">  tv_list_append_owned_tv(l, (typval_T) {</a>
<a name="ln531">    .v_type = VAR_DICT,</a>
<a name="ln532">    .v_lock = VAR_UNLOCKED,</a>
<a name="ln533">    .vval.v_dict = dict,</a>
<a name="ln534">  });</a>
<a name="ln535">  if (dict != NULL) {</a>
<a name="ln536">    dict-&gt;dv_refcount++;</a>
<a name="ln537">  }</a>
<a name="ln538">}</a>
<a name="ln539"> </a>
<a name="ln540">/// Make a copy of &quot;str&quot; and append it as an item to list &quot;l&quot;</a>
<a name="ln541">///</a>
<a name="ln542">/// @param[out]  l  List to append to.</a>
<a name="ln543">/// @param[in]  str  String to append.</a>
<a name="ln544">/// @param[in]  len  Length of the appended string. May be -1, in this</a>
<a name="ln545">///                  case string is considered to be usual zero-terminated</a>
<a name="ln546">///                  string or NULL “empty” string.</a>
<a name="ln547">void tv_list_append_string(list_T *const l, const char *const str,</a>
<a name="ln548">                           const ssize_t len)</a>
<a name="ln549">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln550">{</a>
<a name="ln551">  tv_list_append_owned_tv(l, (typval_T) {</a>
<a name="ln552">    .v_type = VAR_STRING,</a>
<a name="ln553">    .v_lock = VAR_UNLOCKED,</a>
<a name="ln554">    .vval.v_string = (str == NULL</a>
<a name="ln555">                      ? NULL</a>
<a name="ln556">                      : (len &gt;= 0</a>
<a name="ln557">                         ? xmemdupz(str, (size_t)len)</a>
<a name="ln558">                         : xstrdup(str))),</a>
<a name="ln559">  });</a>
<a name="ln560">}</a>
<a name="ln561"> </a>
<a name="ln562">/// Append given string to the list</a>
<a name="ln563">///</a>
<a name="ln564">/// Unlike list_append_string this function does not copy the string.</a>
<a name="ln565">///</a>
<a name="ln566">/// @param[out]  l    List to append to.</a>
<a name="ln567">/// @param[in]   str  String to append.</a>
<a name="ln568">void tv_list_append_allocated_string(list_T *const l, char *const str)</a>
<a name="ln569">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln570">{</a>
<a name="ln571">  tv_list_append_owned_tv(l, (typval_T) {</a>
<a name="ln572">    .v_type = VAR_STRING,</a>
<a name="ln573">    .v_lock = VAR_UNLOCKED,</a>
<a name="ln574">    .vval.v_string = (char_u *)str,</a>
<a name="ln575">  });</a>
<a name="ln576">}</a>
<a name="ln577"> </a>
<a name="ln578">/// Append number to the list</a>
<a name="ln579">///</a>
<a name="ln580">/// @param[out]  l  List to append to.</a>
<a name="ln581">/// @param[in]  n  Number to append. Will be recorded in the allocated</a>
<a name="ln582">///                listitem_T.</a>
<a name="ln583">void tv_list_append_number(list_T *const l, const varnumber_T n)</a>
<a name="ln584">{</a>
<a name="ln585">  tv_list_append_owned_tv(l, (typval_T) {</a>
<a name="ln586">    .v_type = VAR_NUMBER,</a>
<a name="ln587">    .v_lock = VAR_UNLOCKED,</a>
<a name="ln588">    .vval.v_number = n,</a>
<a name="ln589">  });</a>
<a name="ln590">}</a>
<a name="ln591"> </a>
<a name="ln592">//{{{2 Operations on the whole list</a>
<a name="ln593"> </a>
<a name="ln594">/// Make a copy of list</a>
<a name="ln595">///</a>
<a name="ln596">/// @param[in]  conv  If non-NULL, then all internal strings will be converted.</a>
<a name="ln597">///                   Only used when `deep` is true.</a>
<a name="ln598">/// @param[in]  orig  Original list to copy.</a>
<a name="ln599">/// @param[in]  deep  If false, then shallow copy will be done.</a>
<a name="ln600">/// @param[in]  copyID  See var_item_copy().</a>
<a name="ln601">///</a>
<a name="ln602">/// @return Copied list. May be NULL in case original list is NULL or some</a>
<a name="ln603">///         failure happens. The refcount of the new list is set to 1.</a>
<a name="ln604">list_T *tv_list_copy(const vimconv_T *const conv, list_T *const orig,</a>
<a name="ln605">                     const bool deep, const int copyID)</a>
<a name="ln606">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln607">{</a>
<a name="ln608">  if (orig == NULL) {</a>
<a name="ln609">    return NULL;</a>
<a name="ln610">  }</a>
<a name="ln611"> </a>
<a name="ln612">  list_T *copy = tv_list_alloc(tv_list_len(orig));</a>
<a name="ln613">  tv_list_ref(copy);</a>
<a name="ln614">  if (copyID != 0) {</a>
<a name="ln615">    // Do this before adding the items, because one of the items may</a>
<a name="ln616">    // refer back to this list.</a>
<a name="ln617">    orig-&gt;lv_copyID = copyID;</a>
<a name="ln618">    orig-&gt;lv_copylist = copy;</a>
<a name="ln619">  }</a>
<a name="ln620">  TV_LIST_ITER(orig, item, {</a>
<a name="ln621">    if (got_int) {</a>
<a name="ln622">      break;</a>
<a name="ln623">    }</a>
<a name="ln624">    listitem_T *const ni = tv_list_item_alloc();</a>
<a name="ln625">    if (deep) {</a>
<a name="ln626">      if (var_item_copy(conv, TV_LIST_ITEM_TV(item), TV_LIST_ITEM_TV(ni),</a>
<a name="ln627">                        deep, copyID) == FAIL) {</a>
<a name="ln628">        xfree(ni);</a>
<a name="ln629">        goto tv_list_copy_error;</a>
<a name="ln630">      }</a>
<a name="ln631">    } else {</a>
<a name="ln632">      tv_copy(TV_LIST_ITEM_TV(item), TV_LIST_ITEM_TV(ni));</a>
<a name="ln633">    }</a>
<a name="ln634">    tv_list_append(copy, ni);</a>
<a name="ln635">  });</a>
<a name="ln636"> </a>
<a name="ln637">  return copy;</a>
<a name="ln638"> </a>
<a name="ln639">tv_list_copy_error:</a>
<a name="ln640">  tv_list_unref(copy);</a>
<a name="ln641">  return NULL;</a>
<a name="ln642">}</a>
<a name="ln643"> </a>
<a name="ln644">/// Flatten &quot;list&quot; in place to depth &quot;maxdepth&quot;.</a>
<a name="ln645">/// Does nothing if &quot;maxdepth&quot; is 0.</a>
<a name="ln646">///</a>
<a name="ln647">/// @param[in,out] list   List to flatten</a>
<a name="ln648">/// @param[in] maxdepth   Maximum depth that will be flattened</a>
<a name="ln649">///</a>
<a name="ln650">/// @return OK or FAIL</a>
<a name="ln651">int tv_list_flatten(list_T *list, long maxdepth)</a>
<a name="ln652">  FUNC_ATTR_NONNULL_ARG(1) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln653">{</a>
<a name="ln654">  listitem_T *item;</a>
<a name="ln655">  listitem_T *to_free;</a>
<a name="ln656">  int n;</a>
<a name="ln657">  if (maxdepth == 0) {</a>
<a name="ln658">    return OK;</a>
<a name="ln659">  }</a>
<a name="ln660"> </a>
<a name="ln661">  n = 0;</a>
<a name="ln662">  item = list-&gt;lv_first;</a>
<a name="ln663">  while (item != NULL) {</a>
<a name="ln664">    fast_breakcheck();</a>
<a name="ln665">    if (got_int) {</a>
<a name="ln666">      return FAIL;</a>
<a name="ln667">    }</a>
<a name="ln668">    if (item-&gt;li_tv.v_type == VAR_LIST) {</a>
<a name="ln669">      listitem_T *next = item-&gt;li_next;</a>
<a name="ln670"> </a>
<a name="ln671">      tv_list_drop_items(list, item, item);</a>
<a name="ln672">      tv_list_extend(list, item-&gt;li_tv.vval.v_list, next);</a>
<a name="ln673">      tv_clear(&amp;item-&gt;li_tv);</a>
<a name="ln674">      to_free = item;</a>
<a name="ln675"> </a>
<a name="ln676">      if (item-&gt;li_prev == NULL) {</a>
<a name="ln677">        item = list-&gt;lv_first;</a>
<a name="ln678">      } else {</a>
<a name="ln679">        item = item-&gt;li_prev-&gt;li_next;</a>
<a name="ln680">      }</a>
<a name="ln681">      xfree(to_free);</a>
<a name="ln682"> </a>
<a name="ln683">      if (++n &gt;= maxdepth) {</a>
<a name="ln684">        n = 0;</a>
<a name="ln685">        item = next;</a>
<a name="ln686">      }</a>
<a name="ln687">    } else {</a>
<a name="ln688">      n = 0;</a>
<a name="ln689">      item = item-&gt;li_next;</a>
<a name="ln690">    }</a>
<a name="ln691">  }</a>
<a name="ln692">  return OK;</a>
<a name="ln693">}</a>
<a name="ln694"> </a>
<a name="ln695">/// Extend first list with the second</a>
<a name="ln696">///</a>
<a name="ln697">/// @param[out]  l1  List to extend.</a>
<a name="ln698">/// @param[in]  l2  List to extend with.</a>
<a name="ln699">/// @param[in]  bef  If not NULL, extends before this item.</a>
<a name="ln700">void tv_list_extend(list_T *const l1, list_T *const l2,</a>
<a name="ln701">                    listitem_T *const bef)</a>
<a name="ln702">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln703">{</a>
<a name="ln704">  int todo = tv_list_len(l2);</a>
<a name="ln705">  listitem_T *const befbef = (bef == NULL ? NULL : bef-&gt;li_prev);</a>
<a name="ln706">  listitem_T *const saved_next = (befbef == NULL ? NULL : befbef-&gt;li_next);</a>
<a name="ln707">  // We also quit the loop when we have inserted the original item count of</a>
<a name="ln708">  // the list, avoid a hang when we extend a list with itself.</a>
<a name="ln709">  for (listitem_T *item = tv_list_first(l2)</a>
<a name="ln710">       ; item != NULL &amp;&amp; todo--</a>
<a name="ln711">       ; item = (item == befbef ? saved_next : item-&gt;li_next)) {</a>
<a name="ln712">    tv_list_insert_tv(l1, TV_LIST_ITEM_TV(item), bef);</a>
<a name="ln713">  }</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716">/// Concatenate lists into a new list</a>
<a name="ln717">///</a>
<a name="ln718">/// @param[in]  l1  First list.</a>
<a name="ln719">/// @param[in]  l2  Second list.</a>
<a name="ln720">/// @param[out]  ret_tv  Location where new list is saved.</a>
<a name="ln721">///</a>
<a name="ln722">/// @return OK or FAIL.</a>
<a name="ln723">int tv_list_concat(list_T *const l1, list_T *const l2, typval_T *const tv)</a>
<a name="ln724">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln725">{</a>
<a name="ln726">  list_T *l;</a>
<a name="ln727"> </a>
<a name="ln728">  tv-&gt;v_type = VAR_LIST;</a>
<a name="ln729">  tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln730">  if (l1 == NULL &amp;&amp; l2 == NULL) {</a>
<a name="ln731">    l = NULL;</a>
<a name="ln732">  } else if (l1 == NULL) {</a>
<a name="ln733">    l = tv_list_copy(NULL, l2, false, 0);</a>
<a name="ln734">  } else {</a>
<a name="ln735">    l = tv_list_copy(NULL, l1, false, 0);</a>
<a name="ln736">    if (l != NULL &amp;&amp; l2 != NULL) {</a>
<a name="ln737">      tv_list_extend(l, l2, NULL);</a>
<a name="ln738">    }</a>
<a name="ln739">  }</a>
<a name="ln740">  if (l == NULL &amp;&amp; !(l1 == NULL &amp;&amp; l2 == NULL)) {</a>
<a name="ln741">    return FAIL;</a>
<a name="ln742">  }</a>
<a name="ln743"> </a>
<a name="ln744">  tv-&gt;vval.v_list = l;</a>
<a name="ln745">  return OK;</a>
<a name="ln746">}</a>
<a name="ln747"> </a>
<a name="ln748">typedef struct {</a>
<a name="ln749">  char_u *s;</a>
<a name="ln750">  char_u *tofree;</a>
<a name="ln751">} Join;</a>
<a name="ln752"> </a>
<a name="ln753">/// Join list into a string, helper function</a>
<a name="ln754">///</a>
<a name="ln755">/// @param[out]  gap  Garray where result will be saved.</a>
<a name="ln756">/// @param[in]  l  List to join.</a>
<a name="ln757">/// @param[in]  sep  Used separator.</a>
<a name="ln758">/// @param[in]  join_gap  Garray to keep each list item string.</a>
<a name="ln759">///</a>
<a name="ln760">/// @return OK in case of success, FAIL otherwise.</a>
<a name="ln761">static int list_join_inner(garray_T *const gap, list_T *const l,</a>
<a name="ln762">                           const char *const sep, garray_T *const join_gap)</a>
<a name="ln763">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln764">{</a>
<a name="ln765">  size_t sumlen = 0;</a>
<a name="ln766">  bool first = true;</a>
<a name="ln767"> </a>
<a name="ln768">  // Stringify each item in the list.</a>
<a name="ln769">  TV_LIST_ITER(l, item, {</a>
<a name="ln770">    if (got_int) {</a>
<a name="ln771">      break;</a>
<a name="ln772">    }</a>
<a name="ln773">    char *s;</a>
<a name="ln774">    size_t len;</a>
<a name="ln775">    s = encode_tv2echo(TV_LIST_ITEM_TV(item), &amp;len);</a>
<a name="ln776">    if (s == NULL) {</a>
<a name="ln777">      return FAIL;</a>
<a name="ln778">    }</a>
<a name="ln779"> </a>
<a name="ln780">    sumlen += len;</a>
<a name="ln781"> </a>
<a name="ln782">    Join *const p = GA_APPEND_VIA_PTR(Join, join_gap);</a>
<a name="ln783">    p-&gt;tofree = p-&gt;s = (char_u *)s;</a>
<a name="ln784"> </a>
<a name="ln785">    line_breakcheck();</a>
<a name="ln786">  });</a>
<a name="ln787"> </a>
<a name="ln788">  // Allocate result buffer with its total size, avoid re-allocation and</a>
<a name="ln789">  // multiple copy operations.  Add 2 for a tailing ']' and NUL.</a>
<a name="ln790">  if (join_gap-&gt;ga_len &gt;= 2) {</a>
<a name="ln791">    sumlen += strlen(sep) * (size_t)(join_gap-&gt;ga_len - 1);</a>
<a name="ln792">  }</a>
<a name="ln793">  ga_grow(gap, (int)sumlen + 2);</a>
<a name="ln794"> </a>
<a name="ln795">  for (int i = 0; i &lt; join_gap-&gt;ga_len &amp;&amp; !got_int; i++) {</a>
<a name="ln796">    if (first) {</a>
<a name="ln797">      first = false;</a>
<a name="ln798">    } else {</a>
<a name="ln799">      ga_concat(gap, (const char_u *)sep);</a>
<a name="ln800">    }</a>
<a name="ln801">    const Join *const p = ((const Join *)join_gap-&gt;ga_data) + i;</a>
<a name="ln802"> </a>
<a name="ln803">    if (p-&gt;s != NULL) {</a>
<a name="ln804">      ga_concat(gap, p-&gt;s);</a>
<a name="ln805">    }</a>
<a name="ln806">    line_breakcheck();</a>
<a name="ln807">  }</a>
<a name="ln808"> </a>
<a name="ln809">  return OK;</a>
<a name="ln810">}</a>
<a name="ln811"> </a>
<a name="ln812">/// Join list into a string using given separator</a>
<a name="ln813">///</a>
<a name="ln814">/// @param[out]  gap  Garray where result will be saved.</a>
<a name="ln815">/// @param[in]  l  Joined list.</a>
<a name="ln816">/// @param[in]  sep  Separator.</a>
<a name="ln817">///</a>
<a name="ln818">/// @return OK in case of success, FAIL otherwise.</a>
<a name="ln819">int tv_list_join(garray_T *const gap, list_T *const l, const char *const sep)</a>
<a name="ln820">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln821">{</a>
<a name="ln822">  if (!tv_list_len(l)) {</a>
<a name="ln823">    return OK;</a>
<a name="ln824">  }</a>
<a name="ln825"> </a>
<a name="ln826">  garray_T join_ga;</a>
<a name="ln827">  int retval;</a>
<a name="ln828"> </a>
<a name="ln829">  ga_init(&amp;join_ga, (int)sizeof(Join), tv_list_len(l));</a>
<a name="ln830">  retval = list_join_inner(gap, l, sep, &amp;join_ga);</a>
<a name="ln831"> </a>
<a name="ln832">#define FREE_JOIN_TOFREE(join) xfree((join)-&gt;tofree)</a>
<a name="ln833">  GA_DEEP_CLEAR(&amp;join_ga, Join, FREE_JOIN_TOFREE);</a>
<a name="ln834">#undef FREE_JOIN_TOFREE</a>
<a name="ln835"> </a>
<a name="ln836">  return retval;</a>
<a name="ln837">}</a>
<a name="ln838"> </a>
<a name="ln839">/// Chech whether two lists are equal</a>
<a name="ln840">///</a>
<a name="ln841">/// @param[in]  l1  First list to compare.</a>
<a name="ln842">/// @param[in]  l2  Second list to compare.</a>
<a name="ln843">/// @param[in]  ic  True if case is to be ignored.</a>
<a name="ln844">/// @param[in]  recursive  True when used recursively.</a>
<a name="ln845">///</a>
<a name="ln846">/// @return True if lists are equal, false otherwise.</a>
<a name="ln847">bool tv_list_equal(list_T *const l1, list_T *const l2, const bool ic,</a>
<a name="ln848">                   const bool recursive)</a>
<a name="ln849">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln850">{</a>
<a name="ln851">  if (l1 == l2) {</a>
<a name="ln852">    return true;</a>
<a name="ln853">  }</a>
<a name="ln854">  if (tv_list_len(l1) != tv_list_len(l2)) {</a>
<a name="ln855">    return false;</a>
<a name="ln856">  }</a>
<a name="ln857">  if (tv_list_len(l1) == 0) {</a>
<a name="ln858">    // empty and NULL list are considered equal</a>
<a name="ln859">    return true;</a>
<a name="ln860">  }</a>
<a name="ln861">  if (l1 == NULL || l2 == NULL) {</a>
<a name="ln862">    return false;</a>
<a name="ln863">  }</a>
<a name="ln864"> </a>
<a name="ln865">  listitem_T *item1 = tv_list_first(l1);</a>
<a name="ln866">  listitem_T *item2 = tv_list_first(l2);</a>
<a name="ln867">  for (; item1 != NULL &amp;&amp; item2 != NULL</a>
<a name="ln868">       ; (item1 = TV_LIST_ITEM_NEXT(l1, item1),</a>
<a name="ln869">          item2 = TV_LIST_ITEM_NEXT(l2, item2))) {</a>
<a name="ln870">    if (!tv_equal(TV_LIST_ITEM_TV(item1), TV_LIST_ITEM_TV(item2), ic,</a>
<a name="ln871">                  recursive)) {</a>
<a name="ln872">      return false;</a>
<a name="ln873">    }</a>
<a name="ln874">  }</a>
<a name="ln875">  assert(item1 == NULL &amp;&amp; item2 == NULL);</a>
<a name="ln876">  return true;</a>
<a name="ln877">}</a>
<a name="ln878"> </a>
<a name="ln879">/// Reverse list in-place</a>
<a name="ln880">///</a>
<a name="ln881">/// @param[in,out]  l  List to reverse.</a>
<a name="ln882">void tv_list_reverse(list_T *const l)</a>
<a name="ln883">{</a>
<a name="ln884">  if (tv_list_len(l) &lt;= 1) {</a>
<a name="ln885">    return;</a>
<a name="ln886">  }</a>
<a name="ln887">  list_log(l, NULL, NULL, &quot;reverse&quot;);</a>
<a name="ln888">#define SWAP(a, b) \</a>
<a name="ln889">  do { \</a>
<a name="ln890">    tmp = a; \</a>
<a name="ln891">    a = b; \</a>
<a name="ln892">    b = tmp; \</a>
<a name="ln893">  } while (0)</a>
<a name="ln894">  listitem_T *tmp;</a>
<a name="ln895"> </a>
<a name="ln896">  SWAP(l-&gt;lv_first, l-&gt;lv_last);</a>
<a name="ln897">  for (listitem_T *li = l-&gt;lv_first; li != NULL; li = li-&gt;li_next) {</a>
<a name="ln898">    SWAP(li-&gt;li_next, li-&gt;li_prev);</a>
<a name="ln899">  }</a>
<a name="ln900">#undef SWAP</a>
<a name="ln901"> </a>
<a name="ln902">  l-&gt;lv_idx = l-&gt;lv_len - l-&gt;lv_idx - 1;</a>
<a name="ln903">}</a>
<a name="ln904"> </a>
<a name="ln905">// FIXME Add unit tests for tv_list_item_sort().</a>
<a name="ln906"> </a>
<a name="ln907">/// Sort list using libc qsort</a>
<a name="ln908">///</a>
<a name="ln909">/// @param[in,out]  l  List to sort, will be sorted in-place.</a>
<a name="ln910">/// @param  ptrs  Preallocated array of items to sort, must have at least</a>
<a name="ln911">///               tv_list_len(l) entries. Should not be initialized.</a>
<a name="ln912">/// @param[in]  item_compare_func  Function used to compare list items.</a>
<a name="ln913">/// @param  errp  Location where information about whether error occurred is</a>
<a name="ln914">///               saved by item_compare_func. If boolean there appears to be</a>
<a name="ln915">///               true list will not be modified. Must be initialized to false</a>
<a name="ln916">///               by the caller.</a>
<a name="ln917">void tv_list_item_sort(list_T *const l, ListSortItem *const ptrs,</a>
<a name="ln918">                       const ListSorter item_compare_func,</a>
<a name="ln919">                       bool *errp)</a>
<a name="ln920">  FUNC_ATTR_NONNULL_ARG(3, 4)</a>
<a name="ln921">{</a>
<a name="ln922">  const int len = tv_list_len(l);</a>
<a name="ln923">  if (len &lt;= 1) {</a>
<a name="ln924">    return;</a>
<a name="ln925">  }</a>
<a name="ln926">  list_log(l, NULL, NULL, &quot;sort&quot;);</a>
<a name="ln927">  int i = 0;</a>
<a name="ln928">  TV_LIST_ITER(l, li, {</a>
<a name="ln929">    ptrs[i].item = li;</a>
<a name="ln930">    ptrs[i].idx = i;</a>
<a name="ln931">    i++;</a>
<a name="ln932">  });</a>
<a name="ln933">  // Sort the array with item pointers.</a>
<a name="ln934">  qsort(ptrs, (size_t)len, sizeof(ListSortItem), item_compare_func);</a>
<a name="ln935">  if (!(*errp)) {</a>
<a name="ln936">    // Clear the list and append the items in the sorted order.</a>
<a name="ln937">    l-&gt;lv_first    = NULL;</a>
<a name="ln938">    l-&gt;lv_last     = NULL;</a>
<a name="ln939">    l-&gt;lv_idx_item = NULL;</a>
<a name="ln940">    l-&gt;lv_len      = 0;</a>
<a name="ln941">    for (i = 0; i &lt; len; i++) {</a>
<a name="ln942">      tv_list_append(l, ptrs[i].item);</a>
<a name="ln943">    }</a>
<a name="ln944">  }</a>
<a name="ln945">}</a>
<a name="ln946"> </a>
<a name="ln947">//{{{2 Indexing/searching</a>
<a name="ln948"> </a>
<a name="ln949">/// Locate item with a given index in a list and return it</a>
<a name="ln950">///</a>
<a name="ln951">/// @param[in]  l  List to index.</a>
<a name="ln952">/// @param[in]  n  Index. Negative index is counted from the end, -1 is the last</a>
<a name="ln953">///                item.</a>
<a name="ln954">///</a>
<a name="ln955">/// @return Item at the given index or NULL if `n` is out of range.</a>
<a name="ln956">listitem_T *tv_list_find(list_T *const l, int n)</a>
<a name="ln957">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln958">{</a>
<a name="ln959">  STATIC_ASSERT(sizeof(n) == sizeof(l-&gt;lv_idx),</a>
<a name="ln960">                &quot;n and lv_idx sizes do not match&quot;);</a>
<a name="ln961">  if (l == NULL) {</a>
<a name="ln962">    return NULL;</a>
<a name="ln963">  }</a>
<a name="ln964"> </a>
<a name="ln965">  n = tv_list_uidx(l, n);</a>
<a name="ln966">  if (n == -1) {</a>
<a name="ln967">    return NULL;</a>
<a name="ln968">  }</a>
<a name="ln969"> </a>
<a name="ln970">  int idx;</a>
<a name="ln971">  listitem_T  *item;</a>
<a name="ln972"> </a>
<a name="ln973">  // When there is a cached index may start search from there.</a>
<a name="ln974">  if (l-&gt;lv_idx_item != NULL) {</a>
<a name="ln975">    if (n &lt; l-&gt;lv_idx / 2) {</a>
<a name="ln976">      // Closest to the start of the list.</a>
<a name="ln977">      item = l-&gt;lv_first;</a>
<a name="ln978">      idx = 0;</a>
<a name="ln979">    } else if (n &gt; (l-&gt;lv_idx + l-&gt;lv_len) / 2) {</a>
<a name="ln980">      // Closest to the end of the list.</a>
<a name="ln981">      item = l-&gt;lv_last;</a>
<a name="ln982">      idx = l-&gt;lv_len - 1;</a>
<a name="ln983">    } else {</a>
<a name="ln984">      // Closest to the cached index.</a>
<a name="ln985">      item = l-&gt;lv_idx_item;</a>
<a name="ln986">      idx = l-&gt;lv_idx;</a>
<a name="ln987">    }</a>
<a name="ln988">  } else {</a>
<a name="ln989">    if (n &lt; l-&gt;lv_len / 2) {</a>
<a name="ln990">      // Closest to the start of the list.</a>
<a name="ln991">      item = l-&gt;lv_first;</a>
<a name="ln992">      idx = 0;</a>
<a name="ln993">    } else {</a>
<a name="ln994">      // Closest to the end of the list.</a>
<a name="ln995">      item = l-&gt;lv_last;</a>
<a name="ln996">      idx = l-&gt;lv_len - 1;</a>
<a name="ln997">    }</a>
<a name="ln998">  }</a>
<a name="ln999"> </a>
<a name="ln1000">  while (n &gt; idx) {</a>
<a name="ln1001">    // Search forward.</a>
<a name="ln1002">    item = item-&gt;li_next;</a>
<a name="ln1003">    idx++;</a>
<a name="ln1004">  }</a>
<a name="ln1005">  while (n &lt; idx) {</a>
<a name="ln1006">    // Search backward.</a>
<a name="ln1007">    item = item-&gt;li_prev;</a>
<a name="ln1008">    idx--;</a>
<a name="ln1009">  }</a>
<a name="ln1010"> </a>
<a name="ln1011">  assert(idx == n);</a>
<a name="ln1012">  // Cache the used index.</a>
<a name="ln1013">  l-&gt;lv_idx = idx;</a>
<a name="ln1014">  l-&gt;lv_idx_item = item;</a>
<a name="ln1015">  list_log(l, l-&gt;lv_idx_item, (void *)(uintptr_t)l-&gt;lv_idx, &quot;find&quot;);</a>
<a name="ln1016"> </a>
<a name="ln1017">  return item;</a>
<a name="ln1018">}</a>
<a name="ln1019"> </a>
<a name="ln1020">/// Get list item l[n] as a number</a>
<a name="ln1021">///</a>
<a name="ln1022">/// @param[in]  l  List to index.</a>
<a name="ln1023">/// @param[in]  n  Index in a list.</a>
<a name="ln1024">/// @param[out]  ret_error  Location where 1 will be saved if index was not</a>
<a name="ln1025">///                         found. May be NULL. If everything is OK,</a>
<a name="ln1026">///                         `*ret_error` is not touched.</a>
<a name="ln1027">///</a>
<a name="ln1028">/// @return Integer value at the given index or -1.</a>
<a name="ln1029">varnumber_T tv_list_find_nr(list_T *const l, const int n, bool *const ret_error)</a>
<a name="ln1030">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1031">{</a>
<a name="ln1032">  const listitem_T *const li = tv_list_find(l, n);</a>
<a name="ln1033">  if (li == NULL) {</a>
<a name="ln1034">    if (ret_error != NULL) {</a>
<a name="ln1035">      *ret_error = true;</a>
<a name="ln1036">    }</a>
<a name="ln1037">    return -1;</a>
<a name="ln1038">  }</a>
<a name="ln1039">  return tv_get_number_chk(TV_LIST_ITEM_TV(li), ret_error);</a>
<a name="ln1040">}</a>
<a name="ln1041"> </a>
<a name="ln1042">/// Get list item l[n] as a string</a>
<a name="ln1043">///</a>
<a name="ln1044">/// @param[in]  l  List to index.</a>
<a name="ln1045">/// @param[in]  n  Index in a list.</a>
<a name="ln1046">///</a>
<a name="ln1047">/// @return List item string value or NULL in case of error.</a>
<a name="ln1048">const char *tv_list_find_str(list_T *const l, const int n)</a>
<a name="ln1049">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1050">{</a>
<a name="ln1051">  const listitem_T *const li = tv_list_find(l, n);</a>
<a name="ln1052">  if (li == NULL) {</a>
<a name="ln1053">    EMSG2(_(e_listidx), (int64_t)n);</a>
<a name="ln1054">    return NULL;</a>
<a name="ln1055">  }</a>
<a name="ln1056">  return tv_get_string(TV_LIST_ITEM_TV(li));</a>
<a name="ln1057">}</a>
<a name="ln1058"> </a>
<a name="ln1059">/// Locate item in a list and return its index</a>
<a name="ln1060">///</a>
<a name="ln1061">/// @param[in]  l  List to search.</a>
<a name="ln1062">/// @param[in]  item  Item to search for.</a>
<a name="ln1063">///</a>
<a name="ln1064">/// @return Index of an item or -1 if item is not in the list.</a>
<a name="ln1065">long tv_list_idx_of_item(const list_T *const l, const listitem_T *const item)</a>
<a name="ln1066">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln1067">{</a>
<a name="ln1068">  if (l == NULL) {</a>
<a name="ln1069">    return -1;</a>
<a name="ln1070">  }</a>
<a name="ln1071">  int idx = 0;</a>
<a name="ln1072">  TV_LIST_ITER_CONST(l, li, {</a>
<a name="ln1073">    if (li == item) {</a>
<a name="ln1074">      return idx;</a>
<a name="ln1075">    }</a>
<a name="ln1076">    idx++;</a>
<a name="ln1077">  });</a>
<a name="ln1078">  return -1;</a>
<a name="ln1079">}</a>
<a name="ln1080"> </a>
<a name="ln1081">//{{{1 Dictionaries</a>
<a name="ln1082">//{{{2 Dictionary watchers</a>
<a name="ln1083"> </a>
<a name="ln1084">/// Perform all necessary cleanup for a `DictWatcher` instance</a>
<a name="ln1085">///</a>
<a name="ln1086">/// @param  watcher  Watcher to free.</a>
<a name="ln1087">static void tv_dict_watcher_free(DictWatcher *watcher)</a>
<a name="ln1088">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1089">{</a>
<a name="ln1090">  callback_free(&amp;watcher-&gt;callback);</a>
<a name="ln1091">  xfree(watcher-&gt;key_pattern);</a>
<a name="ln1092">  xfree(watcher);</a>
<a name="ln1093">}</a>
<a name="ln1094"> </a>
<a name="ln1095">/// Add watcher to a dictionary</a>
<a name="ln1096">///</a>
<a name="ln1097">/// @param[in]  dict  Dictionary to add watcher to.</a>
<a name="ln1098">/// @param[in]  key_pattern  Pattern to watch for.</a>
<a name="ln1099">/// @param[in]  key_pattern_len  Key pattern length.</a>
<a name="ln1100">/// @param  callback  Function to be called on events.</a>
<a name="ln1101">void tv_dict_watcher_add(dict_T *const dict, const char *const key_pattern,</a>
<a name="ln1102">                         const size_t key_pattern_len, Callback callback)</a>
<a name="ln1103">  FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln1104">{</a>
<a name="ln1105">  if (dict == NULL) {</a>
<a name="ln1106">    return;</a>
<a name="ln1107">  }</a>
<a name="ln1108">  DictWatcher *const watcher = xmalloc(sizeof(DictWatcher));</a>
<a name="ln1109">  watcher-&gt;key_pattern = xmemdupz(key_pattern, key_pattern_len);</a>
<a name="ln1110">  watcher-&gt;key_pattern_len = key_pattern_len;</a>
<a name="ln1111">  watcher-&gt;callback = callback;</a>
<a name="ln1112">  watcher-&gt;busy = false;</a>
<a name="ln1113">  watcher-&gt;needs_free = false;</a>
<a name="ln1114">  QUEUE_INSERT_TAIL(&amp;dict-&gt;watchers, &amp;watcher-&gt;node);</a>
<a name="ln1115">}</a>
<a name="ln1116"> </a>
<a name="ln1117">/// Check whether two callbacks are equal</a>
<a name="ln1118">///</a>
<a name="ln1119">/// @param[in]  cb1  First callback to check.</a>
<a name="ln1120">/// @param[in]  cb2  Second callback to check.</a>
<a name="ln1121">///</a>
<a name="ln1122">/// @return True if they are equal, false otherwise.</a>
<a name="ln1123">bool tv_callback_equal(const Callback *cb1, const Callback *cb2)</a>
<a name="ln1124">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1125">{</a>
<a name="ln1126">  if (cb1-&gt;type != cb2-&gt;type) {</a>
<a name="ln1127">    return false;</a>
<a name="ln1128">  }</a>
<a name="ln1129">  switch (cb1-&gt;type) {</a>
<a name="ln1130">    case kCallbackFuncref: {</a>
<a name="ln1131">      return STRCMP(cb1-&gt;data.funcref, cb2-&gt;data.funcref) == 0;</a>
<a name="ln1132">    }</a>
<a name="ln1133">    case kCallbackPartial: {</a>
<a name="ln1134">      // FIXME: this is inconsistent with tv_equal but is needed for precision</a>
<a name="ln1135">      // maybe change dictwatcheradd to return a watcher id instead?</a>
<a name="ln1136">      return cb1-&gt;data.partial == cb2-&gt;data.partial;</a>
<a name="ln1137">    }</a>
<a name="ln1138">    case kCallbackNone: {</a>
<a name="ln1139">      return true;</a>
<a name="ln1140">    }</a>
<a name="ln1141">  }</a>
<a name="ln1142">  abort();</a>
<a name="ln1143">  return false;</a>
<a name="ln1144">}</a>
<a name="ln1145"> </a>
<a name="ln1146">/// Unref/free callback</a>
<a name="ln1147">void callback_free(Callback *callback)</a>
<a name="ln1148">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1149">{</a>
<a name="ln1150">  switch (callback-&gt;type) {</a>
<a name="ln1151">    case kCallbackFuncref: {</a>
<a name="ln1152">      func_unref(callback-&gt;data.funcref);</a>
<a name="ln1153">      xfree(callback-&gt;data.funcref);</a>
<a name="ln1154">      break;</a>
<a name="ln1155">    }</a>
<a name="ln1156">    case kCallbackPartial: {</a>
<a name="ln1157">      partial_unref(callback-&gt;data.partial);</a>
<a name="ln1158">      break;</a>
<a name="ln1159">    }</a>
<a name="ln1160">    case kCallbackNone: {</a>
<a name="ln1161">      break;</a>
<a name="ln1162">    }</a>
<a name="ln1163">  }</a>
<a name="ln1164">  callback-&gt;type = kCallbackNone;</a>
<a name="ln1165">}</a>
<a name="ln1166"> </a>
<a name="ln1167">/// Remove watcher from a dictionary</a>
<a name="ln1168">///</a>
<a name="ln1169">/// @param  dict  Dictionary to remove watcher from.</a>
<a name="ln1170">/// @param[in]  key_pattern  Pattern to remove watcher for.</a>
<a name="ln1171">/// @param[in]  key_pattern_len  Pattern length.</a>
<a name="ln1172">/// @param  callback  Callback to remove watcher for.</a>
<a name="ln1173">///</a>
<a name="ln1174">/// @return True on success, false if relevant watcher was not found.</a>
<a name="ln1175">bool tv_dict_watcher_remove(dict_T *const dict, const char *const key_pattern,</a>
<a name="ln1176">                            const size_t key_pattern_len,</a>
<a name="ln1177">                            Callback callback)</a>
<a name="ln1178">  FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln1179">{</a>
<a name="ln1180">  if (dict == NULL) {</a>
<a name="ln1181">    return false;</a>
<a name="ln1182">  }</a>
<a name="ln1183"> </a>
<a name="ln1184">  QUEUE *w = NULL;</a>
<a name="ln1185">  DictWatcher *watcher = NULL;</a>
<a name="ln1186">  bool matched = false;</a>
<a name="ln1187">  bool queue_is_busy = false;</a>
<a name="ln1188">  QUEUE_FOREACH(w, &amp;dict-&gt;watchers, {</a>
<a name="ln1189">    watcher = tv_dict_watcher_node_data(w);</a>
<a name="ln1190">    if (watcher-&gt;busy) {</a>
<a name="ln1191">      queue_is_busy = true;</a>
<a name="ln1192">    }</a>
<a name="ln1193">    if (tv_callback_equal(&amp;watcher-&gt;callback, &amp;callback)</a>
<a name="ln1194">        &amp;&amp; watcher-&gt;key_pattern_len == key_pattern_len</a>
<a name="ln1195">        &amp;&amp; memcmp(watcher-&gt;key_pattern, key_pattern, key_pattern_len) == 0) {</a>
<a name="ln1196">      matched = true;</a>
<a name="ln1197">      break;</a>
<a name="ln1198">    }</a>
<a name="ln1199">  })</a>
<a name="ln1200"> </a>
<a name="ln1201">  if (!matched) {</a>
<a name="ln1202">    return false;</a>
<a name="ln1203">  }</a>
<a name="ln1204"> </a>
<a name="ln1205">  if (queue_is_busy) {</a>
<a name="ln1206">    watcher-&gt;needs_free = true;</a>
<a name="ln1207">  } else {</a>
<a name="ln1208">    QUEUE_REMOVE(w);</a>
<a name="ln1209">    tv_dict_watcher_free(watcher);</a>
<a name="ln1210">  }</a>
<a name="ln1211">  return true;</a>
<a name="ln1212">}</a>
<a name="ln1213"> </a>
<a name="ln1214">/// Test if `key` matches with with `watcher-&gt;key_pattern`</a>
<a name="ln1215">///</a>
<a name="ln1216">/// @param[in]  watcher  Watcher to check key pattern from.</a>
<a name="ln1217">/// @param[in]  key  Key to check.</a>
<a name="ln1218">///</a>
<a name="ln1219">/// @return true if key matches, false otherwise.</a>
<a name="ln1220">static bool tv_dict_watcher_matches(DictWatcher *watcher, const char *const key)</a>
<a name="ln1221">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln1222">{</a>
<a name="ln1223">  // For now only allow very simple globbing in key patterns: a '*' at the end</a>
<a name="ln1224">  // of the string means it should match everything up to the '*' instead of the</a>
<a name="ln1225">  // whole string.</a>
<a name="ln1226">  const size_t len = watcher-&gt;key_pattern_len;</a>
<a name="ln1227">  if (len &amp;&amp; watcher-&gt;key_pattern[len - 1] == '*') {</a>
<a name="ln1228">    return strncmp(key, watcher-&gt;key_pattern, len - 1) == 0;</a>
<a name="ln1229">  } else {</a>
<a name="ln1230">    return strcmp(key, watcher-&gt;key_pattern) == 0;</a>
<a name="ln1231">  }</a>
<a name="ln1232">}</a>
<a name="ln1233"> </a>
<a name="ln1234">/// Send a change notification to all dictionary watchers that match given key</a>
<a name="ln1235">///</a>
<a name="ln1236">/// @param[in]  dict  Dictionary which was modified.</a>
<a name="ln1237">/// @param[in]  key  Key which was modified.</a>
<a name="ln1238">/// @param[in]  newtv  New key value.</a>
<a name="ln1239">/// @param[in]  oldtv  Old key value.</a>
<a name="ln1240">void tv_dict_watcher_notify(dict_T *const dict, const char *const key,</a>
<a name="ln1241">                            typval_T *const newtv, typval_T *const oldtv)</a>
<a name="ln1242">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln1243">{</a>
<a name="ln1244">  typval_T argv[3];</a>
<a name="ln1245"> </a>
<a name="ln1246">  argv[0].v_type = VAR_DICT;</a>
<a name="ln1247">  argv[0].v_lock = VAR_UNLOCKED;</a>
<a name="ln1248">  argv[0].vval.v_dict = dict;</a>
<a name="ln1249">  argv[1].v_type = VAR_STRING;</a>
<a name="ln1250">  argv[1].v_lock = VAR_UNLOCKED;</a>
<a name="ln1251">  argv[1].vval.v_string = (char_u *)xstrdup(key);</a>
<a name="ln1252">  argv[2].v_type = VAR_DICT;</a>
<a name="ln1253">  argv[2].v_lock = VAR_UNLOCKED;</a>
<a name="ln1254">  argv[2].vval.v_dict = tv_dict_alloc();</a>
<a name="ln1255">  argv[2].vval.v_dict-&gt;dv_refcount++;</a>
<a name="ln1256"> </a>
<a name="ln1257">  if (newtv) {</a>
<a name="ln1258">    dictitem_T *const v = tv_dict_item_alloc_len(S_LEN(&quot;new&quot;));</a>
<a name="ln1259">    tv_copy(newtv, &amp;v-&gt;di_tv);</a>
<a name="ln1260">    tv_dict_add(argv[2].vval.v_dict, v);</a>
<a name="ln1261">  }</a>
<a name="ln1262"> </a>
<a name="ln1263">  if (oldtv) {</a>
<a name="ln1264">    dictitem_T *const v = tv_dict_item_alloc_len(S_LEN(&quot;old&quot;));</a>
<a name="ln1265">    tv_copy(oldtv, &amp;v-&gt;di_tv);</a>
<a name="ln1266">    tv_dict_add(argv[2].vval.v_dict, v);</a>
<a name="ln1267">  }</a>
<a name="ln1268"> </a>
<a name="ln1269">  typval_T rettv;</a>
<a name="ln1270"> </a>
<a name="ln1271">  bool any_needs_free = false;</a>
<a name="ln1272">  dict-&gt;dv_refcount++;</a>
<a name="ln1273">  QUEUE *w;</a>
<a name="ln1274">  QUEUE_FOREACH(w, &amp;dict-&gt;watchers, {</a>
<a name="ln1275">    DictWatcher *watcher = tv_dict_watcher_node_data(w);</a>
<a name="ln1276">    if (!watcher-&gt;busy &amp;&amp; tv_dict_watcher_matches(watcher, key)) {</a>
<a name="ln1277">      rettv = TV_INITIAL_VALUE;</a>
<a name="ln1278">      watcher-&gt;busy = true;</a>
<a name="ln1279">      callback_call(&amp;watcher-&gt;callback, 3, argv, &amp;rettv);</a>
<a name="ln1280">      watcher-&gt;busy = false;</a>
<a name="ln1281">      tv_clear(&amp;rettv);</a>
<a name="ln1282">      if (watcher-&gt;needs_free) {</a>
<a name="ln1283">        any_needs_free = true;</a>
<a name="ln1284">      }</a>
<a name="ln1285">    }</a>
<a name="ln1286">  })</a>
<a name="ln1287">  if (any_needs_free) {</a>
<a name="ln1288">    QUEUE_FOREACH(w, &amp;dict-&gt;watchers, {</a>
<a name="ln1289">      DictWatcher *watcher = tv_dict_watcher_node_data(w);</a>
<a name="ln1290">      if (watcher-&gt;needs_free) {</a>
<a name="ln1291">        QUEUE_REMOVE(w);</a>
<a name="ln1292">        tv_dict_watcher_free(watcher);</a>
<a name="ln1293">      }</a>
<a name="ln1294">    })</a>
<a name="ln1295">  }</a>
<a name="ln1296">  tv_dict_unref(dict);</a>
<a name="ln1297"> </a>
<a name="ln1298">  for (size_t i = 1; i &lt; ARRAY_SIZE(argv); i++) {</a>
<a name="ln1299">    tv_clear(argv + i);</a>
<a name="ln1300">  }</a>
<a name="ln1301">}</a>
<a name="ln1302"> </a>
<a name="ln1303">//{{{2 Dictionary item</a>
<a name="ln1304"> </a>
<a name="ln1305">/// Allocate a dictionary item</a>
<a name="ln1306">///</a>
<a name="ln1307">/// @note that the type and value of the item (-&gt;di_tv) still needs to</a>
<a name="ln1308">///       be initialized.</a>
<a name="ln1309">///</a>
<a name="ln1310">/// @param[in]  key  Key, is copied to the new item.</a>
<a name="ln1311">/// @param[in]  key_len  Key length.</a>
<a name="ln1312">///</a>
<a name="ln1313">/// @return [allocated] new dictionary item.</a>
<a name="ln1314">dictitem_T *tv_dict_item_alloc_len(const char *const key, const size_t key_len)</a>
<a name="ln1315">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1316">  FUNC_ATTR_MALLOC</a>
<a name="ln1317">{</a>
<a name="ln1318">  dictitem_T *const di = xmalloc(offsetof(dictitem_T, di_key) + key_len + 1);</a>
<a name="ln1319">  memcpy(di-&gt;di_key, key, key_len);</a>
<a name="ln1320">  di-&gt;di_key[key_len] = NUL;</a>
<a name="ln1321">  di-&gt;di_flags = DI_FLAGS_ALLOC;</a>
<a name="ln1322">  di-&gt;di_tv.v_lock = VAR_UNLOCKED;</a>
<a name="ln1323">  return di;</a>
<a name="ln1324">}</a>
<a name="ln1325"> </a>
<a name="ln1326">/// Allocate a dictionary item</a>
<a name="ln1327">///</a>
<a name="ln1328">/// @note that the type and value of the item (-&gt;di_tv) still needs to</a>
<a name="ln1329">///       be initialized.</a>
<a name="ln1330">///</a>
<a name="ln1331">/// @param[in]  key  Key, is copied to the new item.</a>
<a name="ln1332">///</a>
<a name="ln1333">/// @return [allocated] new dictionary item.</a>
<a name="ln1334">dictitem_T *tv_dict_item_alloc(const char *const key)</a>
<a name="ln1335">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1336">  FUNC_ATTR_MALLOC</a>
<a name="ln1337">{</a>
<a name="ln1338">  return tv_dict_item_alloc_len(key, strlen(key));</a>
<a name="ln1339">}</a>
<a name="ln1340"> </a>
<a name="ln1341">/// Free a dictionary item, also clearing the value</a>
<a name="ln1342">///</a>
<a name="ln1343">/// @param  item  Item to free.</a>
<a name="ln1344">void tv_dict_item_free(dictitem_T *const item)</a>
<a name="ln1345">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1346">{</a>
<a name="ln1347">  tv_clear(&amp;item-&gt;di_tv);</a>
<a name="ln1348">  if (item-&gt;di_flags &amp; DI_FLAGS_ALLOC) {</a>
<a name="ln1349">    xfree(item);</a>
<a name="ln1350">  }</a>
<a name="ln1351">}</a>
<a name="ln1352"> </a>
<a name="ln1353">/// Make a copy of a dictionary item</a>
<a name="ln1354">///</a>
<a name="ln1355">/// @param[in]  di  Item to copy.</a>
<a name="ln1356">///</a>
<a name="ln1357">/// @return [allocated] new dictionary item.</a>
<a name="ln1358">dictitem_T *tv_dict_item_copy(dictitem_T *const di)</a>
<a name="ln1359">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1360">{</a>
<a name="ln1361">  dictitem_T *const new_di = tv_dict_item_alloc((const char *)di-&gt;di_key);</a>
<a name="ln1362">  tv_copy(&amp;di-&gt;di_tv, &amp;new_di-&gt;di_tv);</a>
<a name="ln1363">  return new_di;</a>
<a name="ln1364">}</a>
<a name="ln1365"> </a>
<a name="ln1366">/// Remove item from dictionary and free it</a>
<a name="ln1367">///</a>
<a name="ln1368">/// @param  dict  Dictionary to remove item from.</a>
<a name="ln1369">/// @param  item  Item to remove.</a>
<a name="ln1370">void tv_dict_item_remove(dict_T *const dict, dictitem_T *const item)</a>
<a name="ln1371">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1372">{</a>
<a name="ln1373">  hashitem_T *const hi = hash_find(&amp;dict-&gt;dv_hashtab, item-&gt;di_key);</a>
<a name="ln1374">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln1375">    emsgf(_(e_intern2), &quot;tv_dict_item_remove()&quot;);</a>
<a name="ln1376">  } else {</a>
<a name="ln1377">    hash_remove(&amp;dict-&gt;dv_hashtab, hi);</a>
<a name="ln1378">  }</a>
<a name="ln1379">  tv_dict_item_free(item);</a>
<a name="ln1380">}</a>
<a name="ln1381"> </a>
<a name="ln1382">//{{{2 Alloc/free</a>
<a name="ln1383"> </a>
<a name="ln1384">/// Allocate an empty dictionary.</a>
<a name="ln1385">/// Caller should take care of the reference count.</a>
<a name="ln1386">///</a>
<a name="ln1387">/// @return [allocated] new dictionary.</a>
<a name="ln1388">dict_T *tv_dict_alloc(void)</a>
<a name="ln1389">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1390">{</a>
<a name="ln1391">  dict_T *const d = xcalloc(1, sizeof(dict_T));</a>
<a name="ln1392"> </a>
<a name="ln1393">  // Add the dict to the list of dicts for garbage collection.</a>
<a name="ln1394">  if (gc_first_dict != NULL) {</a>
<a name="ln1395">    gc_first_dict-&gt;dv_used_prev = d;</a>
<a name="ln1396">  }</a>
<a name="ln1397">  d-&gt;dv_used_next = gc_first_dict;</a>
<a name="ln1398">  d-&gt;dv_used_prev = NULL;</a>
<a name="ln1399">  gc_first_dict = d;</a>
<a name="ln1400"> </a>
<a name="ln1401">  hash_init(&amp;d-&gt;dv_hashtab);</a>
<a name="ln1402">  d-&gt;dv_lock = VAR_UNLOCKED;</a>
<a name="ln1403">  d-&gt;dv_scope = VAR_NO_SCOPE;</a>
<a name="ln1404">  d-&gt;dv_refcount = 0;</a>
<a name="ln1405">  d-&gt;dv_copyID = 0;</a>
<a name="ln1406">  QUEUE_INIT(&amp;d-&gt;watchers);</a>
<a name="ln1407"> </a>
<a name="ln1408">  d-&gt;lua_table_ref = LUA_NOREF;</a>
<a name="ln1409"> </a>
<a name="ln1410">  return d;</a>
<a name="ln1411">}</a>
<a name="ln1412"> </a>
<a name="ln1413">/// Free items contained in a dictionary</a>
<a name="ln1414">///</a>
<a name="ln1415">/// @param[in,out]  d  Dictionary to clear.</a>
<a name="ln1416">void tv_dict_free_contents(dict_T *const d)</a>
<a name="ln1417">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1418">{</a>
<a name="ln1419">  // Lock the hashtab, we don't want it to resize while freeing items.</a>
<a name="ln1420">  hash_lock(&amp;d-&gt;dv_hashtab);</a>
<a name="ln1421">  assert(d-&gt;dv_hashtab.ht_locked &gt; 0);</a>
<a name="ln1422">  HASHTAB_ITER(&amp;d-&gt;dv_hashtab, hi, {</a>
<a name="ln1423">    // Remove the item before deleting it, just in case there is</a>
<a name="ln1424">    // something recursive causing trouble.</a>
<a name="ln1425">    dictitem_T *const di = TV_DICT_HI2DI(hi);</a>
<a name="ln1426">    hash_remove(&amp;d-&gt;dv_hashtab, hi);</a>
<a name="ln1427">    tv_dict_item_free(di);</a>
<a name="ln1428">  });</a>
<a name="ln1429"> </a>
<a name="ln1430">  while (!QUEUE_EMPTY(&amp;d-&gt;watchers)) {</a>
<a name="ln1431">    QUEUE *w = QUEUE_HEAD(&amp;d-&gt;watchers);</a>
<a name="ln1432">    QUEUE_REMOVE(w);</a>
<a name="ln1433">    DictWatcher *watcher = tv_dict_watcher_node_data(w);</a>
<a name="ln1434">    tv_dict_watcher_free(watcher);</a>
<a name="ln1435">  }</a>
<a name="ln1436"> </a>
<a name="ln1437">  hash_clear(&amp;d-&gt;dv_hashtab);</a>
<a name="ln1438">  d-&gt;dv_hashtab.ht_locked--;</a>
<a name="ln1439">  hash_init(&amp;d-&gt;dv_hashtab);</a>
<a name="ln1440">}</a>
<a name="ln1441"> </a>
<a name="ln1442">/// Free a dictionary itself, ignoring items it contains</a>
<a name="ln1443">///</a>
<a name="ln1444">/// Ignores the reference count.</a>
<a name="ln1445">///</a>
<a name="ln1446">/// @param[in,out]  d  Dictionary to free.</a>
<a name="ln1447">void tv_dict_free_dict(dict_T *const d)</a>
<a name="ln1448">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1449">{</a>
<a name="ln1450">  // Remove the dict from the list of dicts for garbage collection.</a>
<a name="ln1451">  if (d-&gt;dv_used_prev == NULL) {</a>
<a name="ln1452">    gc_first_dict = d-&gt;dv_used_next;</a>
<a name="ln1453">  } else {</a>
<a name="ln1454">    d-&gt;dv_used_prev-&gt;dv_used_next = d-&gt;dv_used_next;</a>
<a name="ln1455">  }</a>
<a name="ln1456">  if (d-&gt;dv_used_next != NULL) {</a>
<a name="ln1457">    d-&gt;dv_used_next-&gt;dv_used_prev = d-&gt;dv_used_prev;</a>
<a name="ln1458">  }</a>
<a name="ln1459"> </a>
<a name="ln1460">  NLUA_CLEAR_REF(d-&gt;lua_table_ref);</a>
<a name="ln1461">  xfree(d);</a>
<a name="ln1462">}</a>
<a name="ln1463"> </a>
<a name="ln1464">/// Free a dictionary, including all items it contains</a>
<a name="ln1465">///</a>
<a name="ln1466">/// Ignores the reference count.</a>
<a name="ln1467">///</a>
<a name="ln1468">/// @param  d  Dictionary to free.</a>
<a name="ln1469">void tv_dict_free(dict_T *const d)</a>
<a name="ln1470">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1471">{</a>
<a name="ln1472">  if (!tv_in_free_unref_items) {</a>
<a name="ln1473">    tv_dict_free_contents(d);</a>
<a name="ln1474">    tv_dict_free_dict(d);</a>
<a name="ln1475">  }</a>
<a name="ln1476">}</a>
<a name="ln1477"> </a>
<a name="ln1478"> </a>
<a name="ln1479">/// Unreference a dictionary</a>
<a name="ln1480">///</a>
<a name="ln1481">/// Decrements the reference count and frees dictionary when it becomes zero.</a>
<a name="ln1482">///</a>
<a name="ln1483">/// @param[in]  d  Dictionary to operate on.</a>
<a name="ln1484">void tv_dict_unref(dict_T *const d)</a>
<a name="ln1485">{</a>
<a name="ln1486">  if (d != NULL &amp;&amp; --d-&gt;dv_refcount &lt;= 0) {</a>
<a name="ln1487">    tv_dict_free(d);</a>
<a name="ln1488">  }</a>
<a name="ln1489">}</a>
<a name="ln1490"> </a>
<a name="ln1491">//{{{2 Indexing/searching</a>
<a name="ln1492"> </a>
<a name="ln1493">/// Find item in dictionary</a>
<a name="ln1494">///</a>
<a name="ln1495">/// @param[in]  d  Dictionary to check.</a>
<a name="ln1496">/// @param[in]  key  Dictionary key.</a>
<a name="ln1497">/// @param[in]  len  Key length. If negative, then strlen(key) is used.</a>
<a name="ln1498">///</a>
<a name="ln1499">/// @return found item or NULL if nothing was found.</a>
<a name="ln1500">dictitem_T *tv_dict_find(const dict_T *const d, const char *const key,</a>
<a name="ln1501">                         const ptrdiff_t len)</a>
<a name="ln1502">  FUNC_ATTR_NONNULL_ARG(2) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1503">{</a>
<a name="ln1504">  if (d == NULL) {</a>
<a name="ln1505">    return NULL;</a>
<a name="ln1506">  }</a>
<a name="ln1507">  hashitem_T *const hi = (len &lt; 0</a>
<a name="ln1508">                          ? hash_find(&amp;d-&gt;dv_hashtab, (const char_u *)key)</a>
<a name="ln1509">                          : hash_find_len(&amp;d-&gt;dv_hashtab, key, (size_t)len));</a>
<a name="ln1510">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln1511">    return NULL;</a>
<a name="ln1512">  }</a>
<a name="ln1513">  return TV_DICT_HI2DI(hi);</a>
<a name="ln1514">}</a>
<a name="ln1515"> </a>
<a name="ln1516">/// Get a typval item from a dictionary and copy it into &quot;rettv&quot;.</a>
<a name="ln1517">///</a>
<a name="ln1518">/// @param[in]  d  Dictionary to check.</a>
<a name="ln1519">/// @param[in]  key  Dictionary key.</a>
<a name="ln1520">/// @param[in]  rettv  Return value.</a>
<a name="ln1521">/// @return OK in case of success or FAIL if nothing was found.</a>
<a name="ln1522">int tv_dict_get_tv(dict_T *d, const char *const key, typval_T *rettv)</a>
<a name="ln1523">{</a>
<a name="ln1524">  dictitem_T *const di = tv_dict_find(d, key, -1);</a>
<a name="ln1525">  if (di == NULL) {</a>
<a name="ln1526">    return FAIL;</a>
<a name="ln1527">  }</a>
<a name="ln1528"> </a>
<a name="ln1529">  tv_copy(&amp;di-&gt;di_tv, rettv);</a>
<a name="ln1530">  return OK;</a>
<a name="ln1531">}</a>
<a name="ln1532"> </a>
<a name="ln1533">/// Get a number item from a dictionary</a>
<a name="ln1534">///</a>
<a name="ln1535">/// Returns 0 if the entry does not exist.</a>
<a name="ln1536">///</a>
<a name="ln1537">/// @param[in]  d  Dictionary to get item from.</a>
<a name="ln1538">/// @param[in]  key  Key to find in dictionary.</a>
<a name="ln1539">///</a>
<a name="ln1540">/// @return Dictionary item.</a>
<a name="ln1541">varnumber_T tv_dict_get_number(const dict_T *const d, const char *const key)</a>
<a name="ln1542">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1543">{</a>
<a name="ln1544">  dictitem_T *const di = tv_dict_find(d, key, -1);</a>
<a name="ln1545">  if (di == NULL) {</a>
<a name="ln1546">    return 0;</a>
<a name="ln1547">  }</a>
<a name="ln1548">  return tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln1549">}</a>
<a name="ln1550"> </a>
<a name="ln1551">/// Converts a dict to an environment</a>
<a name="ln1552">///</a>
<a name="ln1553">///</a>
<a name="ln1554">char **tv_dict_to_env(dict_T *denv)</a>
<a name="ln1555">{</a>
<a name="ln1556">  size_t env_size = (size_t)tv_dict_len(denv);</a>
<a name="ln1557"> </a>
<a name="ln1558">  size_t i = 0;</a>
<a name="ln1559">  char **env = NULL;</a>
<a name="ln1560"> </a>
<a name="ln1561">  // + 1 for NULL</a>
<a name="ln1562">  env = xmalloc((env_size + 1) * sizeof(*env));</a>
<a name="ln1563"> </a>
<a name="ln1564">  TV_DICT_ITER(denv, var, {</a>
<a name="ln1565">    const char *str = tv_get_string(&amp;var-&gt;di_tv);</a>
<a name="ln1566">    assert(str);</a>
<a name="ln1567">    size_t len = STRLEN(var-&gt;di_key) + strlen(str) + strlen(&quot;=&quot;) + 1;</a>
<a name="ln1568">    env[i] = xmalloc(len);</a>
<a name="ln1569">    snprintf(env[i], len, &quot;%s=%s&quot;, (char *)var-&gt;di_key, str);</a>
<a name="ln1570">    i++;</a>
<a name="ln1571">  });</a>
<a name="ln1572"> </a>
<a name="ln1573">  // must be null terminated</a>
<a name="ln1574">  env[env_size] = NULL;</a>
<a name="ln1575">  return env;</a>
<a name="ln1576">}</a>
<a name="ln1577"> </a>
<a name="ln1578">/// Get a string item from a dictionary</a>
<a name="ln1579">///</a>
<a name="ln1580">/// @param[in]  d  Dictionary to get item from.</a>
<a name="ln1581">/// @param[in]  key  Dictionary key.</a>
<a name="ln1582">/// @param[in]  save  If true, returned string will be placed in the allocated</a>
<a name="ln1583">///                   memory.</a>
<a name="ln1584">///</a>
<a name="ln1585">/// @return NULL if key does not exist, empty string in case of type error,</a>
<a name="ln1586">///         string item value otherwise. If returned value is not NULL, it may</a>
<a name="ln1587">///         be allocated depending on `save` argument.</a>
<a name="ln1588">char *tv_dict_get_string(const dict_T *const d, const char *const key,</a>
<a name="ln1589">                         const bool save)</a>
<a name="ln1590">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1591">{</a>
<a name="ln1592">  static char numbuf[NUMBUFLEN];</a>
<a name="ln1593">  const char *const s = tv_dict_get_string_buf(d, key, numbuf);</a>
<a name="ln1594">  if (save &amp;&amp; s != NULL) {</a>
<a name="ln1595">    return xstrdup(s);</a>
<a name="ln1596">  }</a>
<a name="ln1597">  return (char *)s;</a>
<a name="ln1598">}</a>
<a name="ln1599"> </a>
<a name="ln1600">/// Get a string item from a dictionary</a>
<a name="ln1601">///</a>
<a name="ln1602">/// @param[in]  d  Dictionary to get item from.</a>
<a name="ln1603">/// @param[in]  key  Dictionary key.</a>
<a name="ln1604">/// @param[in]  numbuf  Buffer for non-string items converted to strings, at</a>
<a name="ln1605">///                     least of #NUMBUFLEN length.</a>
<a name="ln1606">///</a>
<a name="ln1607">/// @return NULL if key does not exist, empty string in case of type error,</a>
<a name="ln1608">///         string item value otherwise.</a>
<a name="ln1609">const char *tv_dict_get_string_buf(const dict_T *const d, const char *const key,</a>
<a name="ln1610">                                   char *const numbuf)</a>
<a name="ln1611">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1612">{</a>
<a name="ln1613">  const dictitem_T *const di = tv_dict_find(d, key, -1);</a>
<a name="ln1614">  if (di == NULL) {</a>
<a name="ln1615">    return NULL;</a>
<a name="ln1616">  }</a>
<a name="ln1617">  return tv_get_string_buf(&amp;di-&gt;di_tv, numbuf);</a>
<a name="ln1618">}</a>
<a name="ln1619"> </a>
<a name="ln1620">/// Get a string item from a dictionary</a>
<a name="ln1621">///</a>
<a name="ln1622">/// @param[in]  d  Dictionary to get item from.</a>
<a name="ln1623">/// @param[in]  key  Dictionary key.</a>
<a name="ln1624">/// @param[in]  key_len  Key length.</a>
<a name="ln1625">/// @param[in]  numbuf  Buffer for non-string items converted to strings, at</a>
<a name="ln1626">///                     least of #NUMBUFLEN length.</a>
<a name="ln1627">/// @param[in]  def  Default return when key does not exist.</a>
<a name="ln1628">///</a>
<a name="ln1629">/// @return `def` when key does not exist,</a>
<a name="ln1630">///         NULL in case of type error,</a>
<a name="ln1631">///         string item value in case of success.</a>
<a name="ln1632">const char *tv_dict_get_string_buf_chk(const dict_T *const d,</a>
<a name="ln1633">                                       const char *const key,</a>
<a name="ln1634">                                       const ptrdiff_t key_len,</a>
<a name="ln1635">                                       char *const numbuf,</a>
<a name="ln1636">                                       const char *const def)</a>
<a name="ln1637">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1638">{</a>
<a name="ln1639">  const dictitem_T *const di = tv_dict_find(d, key, key_len);</a>
<a name="ln1640">  if (di == NULL) {</a>
<a name="ln1641">    return def;</a>
<a name="ln1642">  }</a>
<a name="ln1643">  return tv_get_string_buf_chk(&amp;di-&gt;di_tv, numbuf);</a>
<a name="ln1644">}</a>
<a name="ln1645"> </a>
<a name="ln1646">/// Get a function from a dictionary</a>
<a name="ln1647">///</a>
<a name="ln1648">/// @param[in]  d  Dictionary to get callback from.</a>
<a name="ln1649">/// @param[in]  key  Dictionary key.</a>
<a name="ln1650">/// @param[in]  key_len  Key length, may be -1 to use strlen().</a>
<a name="ln1651">/// @param[out]  result  The address where a pointer to the wanted callback</a>
<a name="ln1652">///                      will be left.</a>
<a name="ln1653">///</a>
<a name="ln1654">/// @return true/false on success/failure.</a>
<a name="ln1655">bool tv_dict_get_callback(dict_T *const d,</a>
<a name="ln1656">                          const char *const key, const ptrdiff_t key_len,</a>
<a name="ln1657">                          Callback *const result)</a>
<a name="ln1658">  FUNC_ATTR_NONNULL_ARG(2, 4) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1659">{</a>
<a name="ln1660">  result-&gt;type = kCallbackNone;</a>
<a name="ln1661"> </a>
<a name="ln1662">  dictitem_T *const di = tv_dict_find(d, key, key_len);</a>
<a name="ln1663"> </a>
<a name="ln1664">  if (di == NULL) {</a>
<a name="ln1665">    return true;</a>
<a name="ln1666">  }</a>
<a name="ln1667"> </a>
<a name="ln1668">  if (!tv_is_func(di-&gt;di_tv) &amp;&amp; di-&gt;di_tv.v_type != VAR_STRING) {</a>
<a name="ln1669">    EMSG(_(&quot;E6000: Argument is not a function or function name&quot;));</a>
<a name="ln1670">    return false;</a>
<a name="ln1671">  }</a>
<a name="ln1672"> </a>
<a name="ln1673">  typval_T tv;</a>
<a name="ln1674">  tv_copy(&amp;di-&gt;di_tv, &amp;tv);</a>
<a name="ln1675">  set_selfdict(&amp;tv, d);</a>
<a name="ln1676">  const bool res = callback_from_typval(result, &amp;tv);</a>
<a name="ln1677">  tv_clear(&amp;tv);</a>
<a name="ln1678">  return res;</a>
<a name="ln1679">}</a>
<a name="ln1680"> </a>
<a name="ln1681">//{{{2 dict_add*</a>
<a name="ln1682"> </a>
<a name="ln1683">/// Add item to dictionary</a>
<a name="ln1684">///</a>
<a name="ln1685">/// @param[out]  d  Dictionary to add to.</a>
<a name="ln1686">/// @param[in]  item  Item to add.</a>
<a name="ln1687">///</a>
<a name="ln1688">/// @return FAIL if key already exists.</a>
<a name="ln1689">int tv_dict_add(dict_T *const d, dictitem_T *const item)</a>
<a name="ln1690">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1691">{</a>
<a name="ln1692">  return hash_add(&amp;d-&gt;dv_hashtab, item-&gt;di_key);</a>
<a name="ln1693">}</a>
<a name="ln1694"> </a>
<a name="ln1695">/// Add a list entry to dictionary</a>
<a name="ln1696">///</a>
<a name="ln1697">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln1698">/// @param[in]  key  Key to add.</a>
<a name="ln1699">/// @param[in]  key_len  Key length.</a>
<a name="ln1700">/// @param  list  List to add. Will have reference count incremented.</a>
<a name="ln1701">///</a>
<a name="ln1702">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln1703">int tv_dict_add_list(dict_T *const d, const char *const key,</a>
<a name="ln1704">                     const size_t key_len, list_T *const list)</a>
<a name="ln1705">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1706">{</a>
<a name="ln1707">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln1708"> </a>
<a name="ln1709">  item-&gt;di_tv.v_type = VAR_LIST;</a>
<a name="ln1710">  item-&gt;di_tv.vval.v_list = list;</a>
<a name="ln1711">  tv_list_ref(list);</a>
<a name="ln1712">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln1713">    tv_dict_item_free(item);</a>
<a name="ln1714">    return FAIL;</a>
<a name="ln1715">  }</a>
<a name="ln1716">  return OK;</a>
<a name="ln1717">}</a>
<a name="ln1718"> </a>
<a name="ln1719">/// Add a typval entry to dictionary.</a>
<a name="ln1720">///</a>
<a name="ln1721">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln1722">/// @param[in]  key  Key to add.</a>
<a name="ln1723">/// @param[in]  key_len  Key length.</a>
<a name="ln1724">///</a>
<a name="ln1725">/// @return FAIL if out of memory or key already exists.</a>
<a name="ln1726">int tv_dict_add_tv(dict_T *d, const char *key, const size_t key_len,</a>
<a name="ln1727">                   typval_T *tv)</a>
<a name="ln1728">{</a>
<a name="ln1729">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln1730"> </a>
<a name="ln1731">  tv_copy(tv, &amp;item-&gt;di_tv);</a>
<a name="ln1732">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln1733">      tv_dict_item_free(item);</a>
<a name="ln1734">      return FAIL;</a>
<a name="ln1735">  }</a>
<a name="ln1736">  return OK;</a>
<a name="ln1737">}</a>
<a name="ln1738"> </a>
<a name="ln1739">/// Add a dictionary entry to dictionary</a>
<a name="ln1740">///</a>
<a name="ln1741">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln1742">/// @param[in]  key  Key to add.</a>
<a name="ln1743">/// @param[in]  key_len  Key length.</a>
<a name="ln1744">/// @param  dict  Dictionary to add. Will have reference count incremented.</a>
<a name="ln1745">///</a>
<a name="ln1746">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln1747">int tv_dict_add_dict(dict_T *const d, const char *const key,</a>
<a name="ln1748">                     const size_t key_len, dict_T *const dict)</a>
<a name="ln1749">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1750">{</a>
<a name="ln1751">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln1752"> </a>
<a name="ln1753">  item-&gt;di_tv.v_type = VAR_DICT;</a>
<a name="ln1754">  item-&gt;di_tv.vval.v_dict = dict;</a>
<a name="ln1755">  dict-&gt;dv_refcount++;</a>
<a name="ln1756">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln1757">    tv_dict_item_free(item);</a>
<a name="ln1758">    return FAIL;</a>
<a name="ln1759">  }</a>
<a name="ln1760">  return OK;</a>
<a name="ln1761">}</a>
<a name="ln1762"> </a>
<a name="ln1763">/// Add a number entry to dictionary</a>
<a name="ln1764">///</a>
<a name="ln1765">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln1766">/// @param[in]  key  Key to add.</a>
<a name="ln1767">/// @param[in]  key_len  Key length.</a>
<a name="ln1768">/// @param[in]  nr  Number to add.</a>
<a name="ln1769">///</a>
<a name="ln1770">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln1771">int tv_dict_add_nr(dict_T *const d, const char *const key,</a>
<a name="ln1772">                   const size_t key_len, const varnumber_T nr)</a>
<a name="ln1773">{</a>
<a name="ln1774">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln1775"> </a>
<a name="ln1776">  item-&gt;di_tv.v_type = VAR_NUMBER;</a>
<a name="ln1777">  item-&gt;di_tv.vval.v_number = nr;</a>
<a name="ln1778">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln1779">    tv_dict_item_free(item);</a>
<a name="ln1780">    return FAIL;</a>
<a name="ln1781">  }</a>
<a name="ln1782">  return OK;</a>
<a name="ln1783">}</a>
<a name="ln1784"> </a>
<a name="ln1785">/// Add a floating point number entry to dictionary</a>
<a name="ln1786">///</a>
<a name="ln1787">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln1788">/// @param[in]  key  Key to add.</a>
<a name="ln1789">/// @param[in]  key_len  Key length.</a>
<a name="ln1790">/// @param[in]  nr  Floating point number to add.</a>
<a name="ln1791">///</a>
<a name="ln1792">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln1793">int tv_dict_add_float(dict_T *const d, const char *const key,</a>
<a name="ln1794">                      const size_t key_len, const float_T nr)</a>
<a name="ln1795">{</a>
<a name="ln1796">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln1797"> </a>
<a name="ln1798">  item-&gt;di_tv.v_type = VAR_FLOAT;</a>
<a name="ln1799">  item-&gt;di_tv.vval.v_float = nr;</a>
<a name="ln1800">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln1801">    tv_dict_item_free(item);</a>
<a name="ln1802">    return FAIL;</a>
<a name="ln1803">  }</a>
<a name="ln1804">  return OK;</a>
<a name="ln1805">}</a>
<a name="ln1806"> </a>
<a name="ln1807">/// Add a boolean entry to dictionary</a>
<a name="ln1808">///</a>
<a name="ln1809">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln1810">/// @param[in]  key  Key to add.</a>
<a name="ln1811">/// @param[in]  key_len  Key length.</a>
<a name="ln1812">/// @param[in]  val BoolVarValue to add.</a>
<a name="ln1813">///</a>
<a name="ln1814">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln1815">int tv_dict_add_bool(dict_T *const d, const char *const key,</a>
<a name="ln1816">                     const size_t key_len, BoolVarValue val)</a>
<a name="ln1817">{</a>
<a name="ln1818">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln1819"> </a>
<a name="ln1820">  item-&gt;di_tv.v_type = VAR_BOOL;</a>
<a name="ln1821">  item-&gt;di_tv.vval.v_bool = val;</a>
<a name="ln1822">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln1823">    tv_dict_item_free(item);</a>
<a name="ln1824">    return FAIL;</a>
<a name="ln1825">  }</a>
<a name="ln1826">  return OK;</a>
<a name="ln1827">}</a>
<a name="ln1828"> </a>
<a name="ln1829">/// Add a string entry to dictionary</a>
<a name="ln1830">///</a>
<a name="ln1831">/// @see tv_dict_add_allocated_str</a>
<a name="ln1832">int tv_dict_add_str(dict_T *const d,</a>
<a name="ln1833">                    const char *const key, const size_t key_len,</a>
<a name="ln1834">                    const char *const val)</a>
<a name="ln1835">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln1836">{</a>
<a name="ln1837">  return tv_dict_add_str_len(d, key, key_len, val, -1);</a>
<a name="ln1838">}</a>
<a name="ln1839"> </a>
<a name="ln1840">/// Add a string entry to dictionary</a>
<a name="ln1841">///</a>
<a name="ln1842">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln1843">/// @param[in]  key  Key to add.</a>
<a name="ln1844">/// @param[in]  key_len  Key length.</a>
<a name="ln1845">/// @param[in]  val  String to add. NULL adds empty string.</a>
<a name="ln1846">/// @param[in]  len  Use this many bytes from `val`, or -1 for whole string.</a>
<a name="ln1847">///</a>
<a name="ln1848">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln1849">int tv_dict_add_str_len(dict_T *const d,</a>
<a name="ln1850">                        const char *const key, const size_t key_len,</a>
<a name="ln1851">                        const char *const val, int len)</a>
<a name="ln1852">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln1853">{</a>
<a name="ln1854">  char *s = NULL;</a>
<a name="ln1855">  if (val != NULL) {</a>
<a name="ln1856">    s = (len &lt; 0) ? xstrdup(val) : xstrndup(val, (size_t)len);</a>
<a name="ln1857">  }</a>
<a name="ln1858">  return tv_dict_add_allocated_str(d, key, key_len, s);</a>
<a name="ln1859">}</a>
<a name="ln1860"> </a>
<a name="ln1861">/// Add a string entry to dictionary</a>
<a name="ln1862">///</a>
<a name="ln1863">/// Unlike tv_dict_add_str() saves val to the new dictionary item in place of</a>
<a name="ln1864">/// creating a new copy.</a>
<a name="ln1865">///</a>
<a name="ln1866">/// @warning String will be freed even in case addition fails.</a>
<a name="ln1867">///</a>
<a name="ln1868">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln1869">/// @param[in]  key  Key to add.</a>
<a name="ln1870">/// @param[in]  key_len  Key length.</a>
<a name="ln1871">/// @param[in]  val  String to add.</a>
<a name="ln1872">///</a>
<a name="ln1873">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln1874">int tv_dict_add_allocated_str(dict_T *const d,</a>
<a name="ln1875">                              const char *const key, const size_t key_len,</a>
<a name="ln1876">                              char *const val)</a>
<a name="ln1877">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln1878">{</a>
<a name="ln1879">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln1880"> </a>
<a name="ln1881">  item-&gt;di_tv.v_type = VAR_STRING;</a>
<a name="ln1882">  item-&gt;di_tv.vval.v_string = (char_u *)val;</a>
<a name="ln1883">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln1884">    tv_dict_item_free(item);</a>
<a name="ln1885">    return FAIL;</a>
<a name="ln1886">  }</a>
<a name="ln1887">  return OK;</a>
<a name="ln1888">}</a>
<a name="ln1889"> </a>
<a name="ln1890">//{{{2 Operations on the whole dict</a>
<a name="ln1891"> </a>
<a name="ln1892">/// Clear all the keys of a Dictionary. &quot;d&quot; remains a valid empty Dictionary.</a>
<a name="ln1893">///</a>
<a name="ln1894">/// @param  d  The Dictionary to clear</a>
<a name="ln1895">void tv_dict_clear(dict_T *const d)</a>
<a name="ln1896">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1897">{</a>
<a name="ln1898">  hash_lock(&amp;d-&gt;dv_hashtab);</a>
<a name="ln1899">  assert(d-&gt;dv_hashtab.ht_locked &gt; 0);</a>
<a name="ln1900"> </a>
<a name="ln1901">  HASHTAB_ITER(&amp;d-&gt;dv_hashtab, hi, {</a>
<a name="ln1902">    tv_dict_item_free(TV_DICT_HI2DI(hi));</a>
<a name="ln1903">    hash_remove(&amp;d-&gt;dv_hashtab, hi);</a>
<a name="ln1904">  });</a>
<a name="ln1905"> </a>
<a name="ln1906">  hash_unlock(&amp;d-&gt;dv_hashtab);</a>
<a name="ln1907">}</a>
<a name="ln1908"> </a>
<a name="ln1909">/// Extend dictionary with items from another dictionary</a>
<a name="ln1910">///</a>
<a name="ln1911">/// @param  d1  Dictionary to extend.</a>
<a name="ln1912">/// @param[in]  d2  Dictionary to extend with.</a>
<a name="ln1913">/// @param[in]  action  &quot;error&quot;, &quot;force&quot;, &quot;keep&quot;:</a>
<a name="ln1914">///</a>
<a name="ln1915">///                     e*, including &quot;error&quot;: duplicate key gives an error.</a>
<a name="ln1916">///                     f*, including &quot;force&quot;: duplicate d2 keys override d1.</a>
<a name="ln1917">///                     other, including &quot;keep&quot;: duplicate d2 keys ignored.</a>
<a name="ln1918">void tv_dict_extend(dict_T *const d1, dict_T *const d2,</a>
<a name="ln1919">                    const char *const action)</a>
<a name="ln1920">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1921">{</a>
<a name="ln1922">  const bool watched = tv_dict_is_watched(d1);</a>
<a name="ln1923">  const char *const arg_errmsg = _(&quot;extend() argument&quot;);</a>
<a name="ln1924">  const size_t arg_errmsg_len = strlen(arg_errmsg);</a>
<a name="ln1925"> </a>
<a name="ln1926">  TV_DICT_ITER(d2, di2, {</a>
<a name="ln1927">    dictitem_T *const di1 = tv_dict_find(d1, (const char *)di2-&gt;di_key, -1);</a>
<a name="ln1928">    if (d1-&gt;dv_scope != VAR_NO_SCOPE) {</a>
<a name="ln1929">      // Disallow replacing a builtin function in l: and g:.</a>
<a name="ln1930">      // Check the key to be valid when adding to any scope.</a>
<a name="ln1931">      if (d1-&gt;dv_scope == VAR_DEF_SCOPE</a>
<a name="ln1932">          &amp;&amp; tv_is_func(di2-&gt;di_tv)</a>
<a name="ln1933">          &amp;&amp; !var_check_func_name((const char *)di2-&gt;di_key, di1 == NULL)) {</a>
<a name="ln1934">        break;</a>
<a name="ln1935">      }</a>
<a name="ln1936">      if (!valid_varname((const char *)di2-&gt;di_key)) {</a>
<a name="ln1937">        break;</a>
<a name="ln1938">      }</a>
<a name="ln1939">    }</a>
<a name="ln1940">    if (di1 == NULL) {</a>
<a name="ln1941">      dictitem_T *const new_di = tv_dict_item_copy(di2);</a>
<a name="ln1942">      if (tv_dict_add(d1, new_di) == FAIL) {</a>
<a name="ln1943">        tv_dict_item_free(new_di);</a>
<a name="ln1944">      } else if (watched) {</a>
<a name="ln1945">        tv_dict_watcher_notify(d1, (const char *)new_di-&gt;di_key, &amp;new_di-&gt;di_tv,</a>
<a name="ln1946">                               NULL);</a>
<a name="ln1947">      }</a>
<a name="ln1948">    } else if (*action == 'e') {</a>
<a name="ln1949">      emsgf(_(&quot;E737: Key already exists: %s&quot;), di2-&gt;di_key);</a>
<a name="ln1950">      break;</a>
<a name="ln1951">    } else if (*action == 'f' &amp;&amp; di2 != di1) {</a>
<a name="ln1952">      typval_T oldtv;</a>
<a name="ln1953"> </a>
<a name="ln1954">      if (tv_check_lock(di1-&gt;di_tv.v_lock, arg_errmsg, arg_errmsg_len)</a>
<a name="ln1955">          || var_check_ro(di1-&gt;di_flags, arg_errmsg, arg_errmsg_len)) {</a>
<a name="ln1956">        break;</a>
<a name="ln1957">      }</a>
<a name="ln1958"> </a>
<a name="ln1959">      if (watched) {</a>
<a name="ln1960">        tv_copy(&amp;di1-&gt;di_tv, &amp;oldtv);</a>
<a name="ln1961">      }</a>
<a name="ln1962"> </a>
<a name="ln1963">      tv_clear(&amp;di1-&gt;di_tv);</a>
<a name="ln1964">      tv_copy(&amp;di2-&gt;di_tv, &amp;di1-&gt;di_tv);</a>
<a name="ln1965"> </a>
<a name="ln1966">      if (watched) {</a>
<a name="ln1967">        tv_dict_watcher_notify(d1, (const char *)di1-&gt;di_key, &amp;di1-&gt;di_tv,</a>
<a name="ln1968">                               &amp;oldtv);</a>
<a name="ln1969">        tv_clear(&amp;oldtv);</a>
<a name="ln1970">      }</a>
<a name="ln1971">    }</a>
<a name="ln1972">  });</a>
<a name="ln1973">}</a>
<a name="ln1974"> </a>
<a name="ln1975">/// Compare two dictionaries</a>
<a name="ln1976">///</a>
<a name="ln1977">/// @param[in]  d1  First dictionary.</a>
<a name="ln1978">/// @param[in]  d2  Second dictionary.</a>
<a name="ln1979">/// @param[in]  ic  True if case is to be ignored.</a>
<a name="ln1980">/// @param[in]  recursive  True when used recursively.</a>
<a name="ln1981">bool tv_dict_equal(dict_T *const d1, dict_T *const d2,</a>
<a name="ln1982">                   const bool ic, const bool recursive)</a>
<a name="ln1983">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1984">{</a>
<a name="ln1985">  if (d1 == d2) {</a>
<a name="ln1986">    return true;</a>
<a name="ln1987">  }</a>
<a name="ln1988">  if (d1 == NULL || d2 == NULL) {</a>
<a name="ln1989">    return false;</a>
<a name="ln1990">  }</a>
<a name="ln1991">  if (tv_dict_len(d1) != tv_dict_len(d2)) {</a>
<a name="ln1992">    return false;</a>
<a name="ln1993">  }</a>
<a name="ln1994"> </a>
<a name="ln1995">  TV_DICT_ITER(d1, di1, {</a>
<a name="ln1996">    dictitem_T *const di2 = tv_dict_find(d2, (const char *)di1-&gt;di_key, -1);</a>
<a name="ln1997">    if (di2 == NULL) {</a>
<a name="ln1998">      return false;</a>
<a name="ln1999">    }</a>
<a name="ln2000">    if (!tv_equal(&amp;di1-&gt;di_tv, &amp;di2-&gt;di_tv, ic, recursive)) {</a>
<a name="ln2001">      return false;</a>
<a name="ln2002">    }</a>
<a name="ln2003">  });</a>
<a name="ln2004">  return true;</a>
<a name="ln2005">}</a>
<a name="ln2006"> </a>
<a name="ln2007">/// Make a copy of dictionary</a>
<a name="ln2008">///</a>
<a name="ln2009">/// @param[in]  conv  If non-NULL, then all internal strings will be converted.</a>
<a name="ln2010">/// @param[in]  orig  Original dictionary to copy.</a>
<a name="ln2011">/// @param[in]  deep  If false, then shallow copy will be done.</a>
<a name="ln2012">/// @param[in]  copyID  See var_item_copy().</a>
<a name="ln2013">///</a>
<a name="ln2014">/// @return Copied dictionary. May be NULL in case original dictionary is NULL</a>
<a name="ln2015">///         or some failure happens. The refcount of the new dictionary is set</a>
<a name="ln2016">///         to 1.</a>
<a name="ln2017">dict_T *tv_dict_copy(const vimconv_T *const conv,</a>
<a name="ln2018">                     dict_T *const orig,</a>
<a name="ln2019">                     const bool deep,</a>
<a name="ln2020">                     const int copyID)</a>
<a name="ln2021">{</a>
<a name="ln2022">  if (orig == NULL) {</a>
<a name="ln2023">    return NULL;</a>
<a name="ln2024">  }</a>
<a name="ln2025"> </a>
<a name="ln2026">  dict_T *copy = tv_dict_alloc();</a>
<a name="ln2027">  if (copyID != 0) {</a>
<a name="ln2028">    orig-&gt;dv_copyID = copyID;</a>
<a name="ln2029">    orig-&gt;dv_copydict = copy;</a>
<a name="ln2030">  }</a>
<a name="ln2031">  TV_DICT_ITER(orig, di, {</a>
<a name="ln2032">    if (got_int) {</a>
<a name="ln2033">      break;</a>
<a name="ln2034">    }</a>
<a name="ln2035">    dictitem_T *new_di;</a>
<a name="ln2036">    if (conv == NULL || conv-&gt;vc_type == CONV_NONE) {</a>
<a name="ln2037">      new_di = tv_dict_item_alloc((const char *)di-&gt;di_key);</a>
<a name="ln2038">    } else {</a>
<a name="ln2039">      size_t len = STRLEN(di-&gt;di_key);</a>
<a name="ln2040">      char *const key = (char *)string_convert(conv, di-&gt;di_key, &amp;len);</a>
<a name="ln2041">      if (key == NULL) {</a>
<a name="ln2042">        new_di = tv_dict_item_alloc_len((const char *)di-&gt;di_key, len);</a>
<a name="ln2043">      } else {</a>
<a name="ln2044">        new_di = tv_dict_item_alloc_len(key, len);</a>
<a name="ln2045">        xfree(key);</a>
<a name="ln2046">      }</a>
<a name="ln2047">    }</a>
<a name="ln2048">    if (deep) {</a>
<a name="ln2049">      if (var_item_copy(conv, &amp;di-&gt;di_tv, &amp;new_di-&gt;di_tv, deep,</a>
<a name="ln2050">                        copyID) == FAIL) {</a>
<a name="ln2051">        xfree(new_di);</a>
<a name="ln2052">        break;</a>
<a name="ln2053">      }</a>
<a name="ln2054">    } else {</a>
<a name="ln2055">      tv_copy(&amp;di-&gt;di_tv, &amp;new_di-&gt;di_tv);</a>
<a name="ln2056">    }</a>
<a name="ln2057">    if (tv_dict_add(copy, new_di) == FAIL) {</a>
<a name="ln2058">      tv_dict_item_free(new_di);</a>
<a name="ln2059">      break;</a>
<a name="ln2060">    }</a>
<a name="ln2061">  });</a>
<a name="ln2062"> </a>
<a name="ln2063">  copy-&gt;dv_refcount++;</a>
<a name="ln2064">  if (got_int) {</a>
<a name="ln2065">    tv_dict_unref(copy);</a>
<a name="ln2066">    copy = NULL;</a>
<a name="ln2067">  }</a>
<a name="ln2068"> </a>
<a name="ln2069">  return copy;</a>
<a name="ln2070">}</a>
<a name="ln2071"> </a>
<a name="ln2072">/// Set all existing keys in &quot;dict&quot; as read-only.</a>
<a name="ln2073">///</a>
<a name="ln2074">/// This does not protect against adding new keys to the Dictionary.</a>
<a name="ln2075">///</a>
<a name="ln2076">/// @param  dict  The dict whose keys should be frozen.</a>
<a name="ln2077">void tv_dict_set_keys_readonly(dict_T *const dict)</a>
<a name="ln2078">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2079">{</a>
<a name="ln2080">  TV_DICT_ITER(dict, di, {</a>
<a name="ln2081">    di-&gt;di_flags |= DI_FLAGS_RO | DI_FLAGS_FIX;</a>
<a name="ln2082">  });</a>
<a name="ln2083">}</a>
<a name="ln2084"> </a>
<a name="ln2085">//{{{1 Generic typval operations</a>
<a name="ln2086">//{{{2 Init/alloc/clear</a>
<a name="ln2087">//{{{3 Alloc</a>
<a name="ln2088"> </a>
<a name="ln2089">/// Allocate an empty list for a return value</a>
<a name="ln2090">///</a>
<a name="ln2091">/// Also sets reference count.</a>
<a name="ln2092">///</a>
<a name="ln2093">/// @param[out]  ret_tv  Structure where list is saved.</a>
<a name="ln2094">/// @param[in]  len  Expected number of items to be populated before list</a>
<a name="ln2095">///                  becomes accessible from VimL. It is still valid to</a>
<a name="ln2096">///                  underpopulate a list, value only controls how many elements</a>
<a name="ln2097">///                  will be allocated in advance. @see ListLenSpecials.</a>
<a name="ln2098">///</a>
<a name="ln2099">/// @return [allocated] pointer to the created list.</a>
<a name="ln2100">list_T *tv_list_alloc_ret(typval_T *const ret_tv, const ptrdiff_t len)</a>
<a name="ln2101">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2102">{</a>
<a name="ln2103">  list_T *const l = tv_list_alloc(len);</a>
<a name="ln2104">  tv_list_set_ret(ret_tv, l);</a>
<a name="ln2105">  ret_tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln2106">  return l;</a>
<a name="ln2107">}</a>
<a name="ln2108"> </a>
<a name="ln2109">/// Allocate an empty dictionary for a return value</a>
<a name="ln2110">///</a>
<a name="ln2111">/// Also sets reference count.</a>
<a name="ln2112">///</a>
<a name="ln2113">/// @param[out]  ret_tv  Structure where dictionary is saved.</a>
<a name="ln2114">void tv_dict_alloc_ret(typval_T *const ret_tv)</a>
<a name="ln2115">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2116">{</a>
<a name="ln2117">  dict_T *const d = tv_dict_alloc();</a>
<a name="ln2118">  tv_dict_set_ret(ret_tv, d);</a>
<a name="ln2119">  ret_tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln2120">}</a>
<a name="ln2121"> </a>
<a name="ln2122">//{{{3 Clear</a>
<a name="ln2123">#define TYPVAL_ENCODE_ALLOW_SPECIALS false</a>
<a name="ln2124"> </a>
<a name="ln2125">#define TYPVAL_ENCODE_CONV_NIL(tv) \</a>
<a name="ln2126">    do { \</a>
<a name="ln2127">      tv-&gt;vval.v_special = kSpecialVarNull; \</a>
<a name="ln2128">      tv-&gt;v_lock = VAR_UNLOCKED; \</a>
<a name="ln2129">    } while (0)</a>
<a name="ln2130"> </a>
<a name="ln2131">#define TYPVAL_ENCODE_CONV_BOOL(tv, num) \</a>
<a name="ln2132">    do { \</a>
<a name="ln2133">      tv-&gt;vval.v_bool = kBoolVarFalse; \</a>
<a name="ln2134">      tv-&gt;v_lock = VAR_UNLOCKED; \</a>
<a name="ln2135">    } while (0)</a>
<a name="ln2136"> </a>
<a name="ln2137">#define TYPVAL_ENCODE_CONV_NUMBER(tv, num) \</a>
<a name="ln2138">    do { \</a>
<a name="ln2139">      (void)num; \</a>
<a name="ln2140">      tv-&gt;vval.v_number = 0; \</a>
<a name="ln2141">      tv-&gt;v_lock = VAR_UNLOCKED; \</a>
<a name="ln2142">    } while (0)</a>
<a name="ln2143"> </a>
<a name="ln2144">#define TYPVAL_ENCODE_CONV_UNSIGNED_NUMBER(tv, num)</a>
<a name="ln2145"> </a>
<a name="ln2146">#define TYPVAL_ENCODE_CONV_FLOAT(tv, flt) \</a>
<a name="ln2147">    do { \</a>
<a name="ln2148">      tv-&gt;vval.v_float = 0; \</a>
<a name="ln2149">      tv-&gt;v_lock = VAR_UNLOCKED; \</a>
<a name="ln2150">    } while (0)</a>
<a name="ln2151"> </a>
<a name="ln2152">#define TYPVAL_ENCODE_CONV_STRING(tv, buf, len) \</a>
<a name="ln2153">    do { \</a>
<a name="ln2154">      xfree(buf); \</a>
<a name="ln2155">      tv-&gt;vval.v_string = NULL; \</a>
<a name="ln2156">      tv-&gt;v_lock = VAR_UNLOCKED; \</a>
<a name="ln2157">    } while (0)</a>
<a name="ln2158"> </a>
<a name="ln2159">#define TYPVAL_ENCODE_CONV_STR_STRING(tv, buf, len)</a>
<a name="ln2160"> </a>
<a name="ln2161">#define TYPVAL_ENCODE_CONV_EXT_STRING(tv, buf, len, type)</a>
<a name="ln2162"> </a>
<a name="ln2163">static inline int _nothing_conv_func_start(typval_T *const tv,</a>
<a name="ln2164">                                           char_u *const fun)</a>
<a name="ln2165">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln2166">{</a>
<a name="ln2167">  tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln2168">  if (tv-&gt;v_type == VAR_PARTIAL) {</a>
<a name="ln2169">    partial_T *const pt_ = tv-&gt;vval.v_partial;</a>
<a name="ln2170">    if (pt_ != NULL &amp;&amp; pt_-&gt;pt_refcount &gt; 1) {</a>
<a name="ln2171">      pt_-&gt;pt_refcount--;</a>
<a name="ln2172">      tv-&gt;vval.v_partial = NULL;</a>
<a name="ln2173">      return OK;</a>
<a name="ln2174">    }</a>
<a name="ln2175">  } else {</a>
<a name="ln2176">    func_unref(fun);</a>
<a name="ln2177">    if ((const char *)fun != tv_empty_string) {</a>
<a name="ln2178">      xfree(fun);</a>
<a name="ln2179">    }</a>
<a name="ln2180">    tv-&gt;vval.v_string = NULL;</a>
<a name="ln2181">  }</a>
<a name="ln2182">  return NOTDONE;</a>
<a name="ln2183">}</a>
<a name="ln2184">#define TYPVAL_ENCODE_CONV_FUNC_START(tv, fun) \</a>
<a name="ln2185">    do { \</a>
<a name="ln2186">      if (_nothing_conv_func_start(tv, fun) != NOTDONE) { \</a>
<a name="ln2187">        return OK; \</a>
<a name="ln2188">      } \</a>
<a name="ln2189">    } while (0)</a>
<a name="ln2190"> </a>
<a name="ln2191">#define TYPVAL_ENCODE_CONV_FUNC_BEFORE_ARGS(tv, len)</a>
<a name="ln2192">#define TYPVAL_ENCODE_CONV_FUNC_BEFORE_SELF(tv, len)</a>
<a name="ln2193"> </a>
<a name="ln2194">static inline void _nothing_conv_func_end(typval_T *const tv, const int copyID)</a>
<a name="ln2195">  FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2196">{</a>
<a name="ln2197">  if (tv-&gt;v_type == VAR_PARTIAL) {</a>
<a name="ln2198">    partial_T *const pt = tv-&gt;vval.v_partial;</a>
<a name="ln2199">    if (pt == NULL) {</a>
<a name="ln2200">      return;</a>
<a name="ln2201">    }</a>
<a name="ln2202">    // Dictionary should already be freed by the time.</a>
<a name="ln2203">    // If it was not freed then it is a part of the reference cycle.</a>
<a name="ln2204">    assert(pt-&gt;pt_dict == NULL || pt-&gt;pt_dict-&gt;dv_copyID == copyID);</a>
<a name="ln2205">    pt-&gt;pt_dict = NULL;</a>
<a name="ln2206">    // As well as all arguments.</a>
<a name="ln2207">    pt-&gt;pt_argc = 0;</a>
<a name="ln2208">    assert(pt-&gt;pt_refcount &lt;= 1);</a>
<a name="ln2209">    partial_unref(pt);</a>
<a name="ln2210">    tv-&gt;vval.v_partial = NULL;</a>
<a name="ln2211">    assert(tv-&gt;v_lock == VAR_UNLOCKED);</a>
<a name="ln2212">  }</a>
<a name="ln2213">}</a>
<a name="ln2214">#define TYPVAL_ENCODE_CONV_FUNC_END(tv) _nothing_conv_func_end(tv, copyID)</a>
<a name="ln2215"> </a>
<a name="ln2216">#define TYPVAL_ENCODE_CONV_EMPTY_LIST(tv) \</a>
<a name="ln2217">    do { \</a>
<a name="ln2218">      tv_list_unref(tv-&gt;vval.v_list); \</a>
<a name="ln2219">      tv-&gt;vval.v_list = NULL; \</a>
<a name="ln2220">      tv-&gt;v_lock = VAR_UNLOCKED; \</a>
<a name="ln2221">    } while (0)</a>
<a name="ln2222"> </a>
<a name="ln2223">static inline void _nothing_conv_empty_dict(typval_T *const tv,</a>
<a name="ln2224">                                            dict_T **const dictp)</a>
<a name="ln2225">  FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln2226">{</a>
<a name="ln2227">  tv_dict_unref(*dictp);</a>
<a name="ln2228">  *dictp = NULL;</a>
<a name="ln2229">  if (tv != NULL) {</a>
<a name="ln2230">    tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln2231">  }</a>
<a name="ln2232">}</a>
<a name="ln2233">#define TYPVAL_ENCODE_CONV_EMPTY_DICT(tv, dict) \</a>
<a name="ln2234">    do { \</a>
<a name="ln2235">      assert((void *)&amp;dict != (void *)&amp;TYPVAL_ENCODE_NODICT_VAR); \</a>
<a name="ln2236">      _nothing_conv_empty_dict(tv, ((dict_T **)&amp;dict)); \</a>
<a name="ln2237">    } while (0)</a>
<a name="ln2238"> </a>
<a name="ln2239">static inline int _nothing_conv_real_list_after_start(</a>
<a name="ln2240">    typval_T *const tv, MPConvStackVal *const mpsv)</a>
<a name="ln2241">  FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2242">{</a>
<a name="ln2243">  assert(tv != NULL);</a>
<a name="ln2244">  tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln2245">  if (tv-&gt;vval.v_list-&gt;lv_refcount &gt; 1) {</a>
<a name="ln2246">    tv-&gt;vval.v_list-&gt;lv_refcount--;</a>
<a name="ln2247">    tv-&gt;vval.v_list = NULL;</a>
<a name="ln2248">    mpsv-&gt;data.l.li = NULL;</a>
<a name="ln2249">    return OK;</a>
<a name="ln2250">  }</a>
<a name="ln2251">  return NOTDONE;</a>
<a name="ln2252">}</a>
<a name="ln2253">#define TYPVAL_ENCODE_CONV_LIST_START(tv, len)</a>
<a name="ln2254"> </a>
<a name="ln2255">#define TYPVAL_ENCODE_CONV_REAL_LIST_AFTER_START(tv, mpsv) \</a>
<a name="ln2256">    do { \</a>
<a name="ln2257">      if (_nothing_conv_real_list_after_start(tv, &amp;mpsv) != NOTDONE) { \</a>
<a name="ln2258">        goto typval_encode_stop_converting_one_item; \</a>
<a name="ln2259">      } \</a>
<a name="ln2260">    } while (0)</a>
<a name="ln2261"> </a>
<a name="ln2262">#define TYPVAL_ENCODE_CONV_LIST_BETWEEN_ITEMS(tv)</a>
<a name="ln2263"> </a>
<a name="ln2264">static inline void _nothing_conv_list_end(typval_T *const tv)</a>
<a name="ln2265">  FUNC_ATTR_ALWAYS_INLINE</a>
<a name="ln2266">{</a>
<a name="ln2267">  if (tv == NULL) {</a>
<a name="ln2268">    return;</a>
<a name="ln2269">  }</a>
<a name="ln2270">  assert(tv-&gt;v_type == VAR_LIST);</a>
<a name="ln2271">  list_T *const list = tv-&gt;vval.v_list;</a>
<a name="ln2272">  tv_list_unref(list);</a>
<a name="ln2273">  tv-&gt;vval.v_list = NULL;</a>
<a name="ln2274">}</a>
<a name="ln2275">#define TYPVAL_ENCODE_CONV_LIST_END(tv) _nothing_conv_list_end(tv)</a>
<a name="ln2276"> </a>
<a name="ln2277">static inline int _nothing_conv_real_dict_after_start(</a>
<a name="ln2278">    typval_T *const tv, dict_T **const dictp, const void *const nodictvar,</a>
<a name="ln2279">    MPConvStackVal *const mpsv)</a>
<a name="ln2280">  FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2281">{</a>
<a name="ln2282">  if (tv != NULL) {</a>
<a name="ln2283">    tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln2284">  }</a>
<a name="ln2285">  if ((const void *)dictp != nodictvar &amp;&amp; (*dictp)-&gt;dv_refcount &gt; 1) {</a>
<a name="ln2286">    (*dictp)-&gt;dv_refcount--;</a>
<a name="ln2287">    *dictp = NULL;</a>
<a name="ln2288">    mpsv-&gt;data.d.todo = 0;</a>
<a name="ln2289">    return OK;</a>
<a name="ln2290">  }</a>
<a name="ln2291">  return NOTDONE;</a>
<a name="ln2292">}</a>
<a name="ln2293">#define TYPVAL_ENCODE_CONV_DICT_START(tv, dict, len)</a>
<a name="ln2294"> </a>
<a name="ln2295">#define TYPVAL_ENCODE_CONV_REAL_DICT_AFTER_START(tv, dict, mpsv) \</a>
<a name="ln2296">    do { \</a>
<a name="ln2297">      if (_nothing_conv_real_dict_after_start( \</a>
<a name="ln2298">          tv, (dict_T **)&amp;dict, (void *)&amp;TYPVAL_ENCODE_NODICT_VAR, \</a>
<a name="ln2299">          &amp;mpsv) != NOTDONE) { \</a>
<a name="ln2300">        goto typval_encode_stop_converting_one_item; \</a>
<a name="ln2301">      } \</a>
<a name="ln2302">    } while (0)</a>
<a name="ln2303"> </a>
<a name="ln2304">#define TYPVAL_ENCODE_SPECIAL_DICT_KEY_CHECK(tv, dict)</a>
<a name="ln2305">#define TYPVAL_ENCODE_CONV_DICT_AFTER_KEY(tv, dict)</a>
<a name="ln2306">#define TYPVAL_ENCODE_CONV_DICT_BETWEEN_ITEMS(tv, dict)</a>
<a name="ln2307"> </a>
<a name="ln2308">static inline void _nothing_conv_dict_end(typval_T *const tv,</a>
<a name="ln2309">                                          dict_T **const dictp,</a>
<a name="ln2310">                                          const void *const nodictvar)</a>
<a name="ln2311">  FUNC_ATTR_ALWAYS_INLINE</a>
<a name="ln2312">{</a>
<a name="ln2313">  if ((const void *)dictp != nodictvar) {</a>
<a name="ln2314">    tv_dict_unref(*dictp);</a>
<a name="ln2315">    *dictp = NULL;</a>
<a name="ln2316">  }</a>
<a name="ln2317">}</a>
<a name="ln2318">#define TYPVAL_ENCODE_CONV_DICT_END(tv, dict) \</a>
<a name="ln2319">    _nothing_conv_dict_end(tv, (dict_T **)&amp;dict, \</a>
<a name="ln2320">                           (void *)&amp;TYPVAL_ENCODE_NODICT_VAR)</a>
<a name="ln2321"> </a>
<a name="ln2322">#define TYPVAL_ENCODE_CONV_RECURSE(val, conv_type)</a>
<a name="ln2323"> </a>
<a name="ln2324">#define TYPVAL_ENCODE_SCOPE static</a>
<a name="ln2325">#define TYPVAL_ENCODE_NAME nothing</a>
<a name="ln2326">#define TYPVAL_ENCODE_FIRST_ARG_TYPE const void *const</a>
<a name="ln2327">#define TYPVAL_ENCODE_FIRST_ARG_NAME ignored</a>
<a name="ln2328">#define TYPVAL_ENCODE_TRANSLATE_OBJECT_NAME</a>
<a name="ln2329">#include &quot;nvim/eval/typval_encode.c.h&quot;</a>
<a name="ln2330">#undef TYPVAL_ENCODE_SCOPE</a>
<a name="ln2331">#undef TYPVAL_ENCODE_NAME</a>
<a name="ln2332">#undef TYPVAL_ENCODE_FIRST_ARG_TYPE</a>
<a name="ln2333">#undef TYPVAL_ENCODE_FIRST_ARG_NAME</a>
<a name="ln2334">#undef TYPVAL_ENCODE_TRANSLATE_OBJECT_NAME</a>
<a name="ln2335"> </a>
<a name="ln2336">#undef TYPVAL_ENCODE_ALLOW_SPECIALS</a>
<a name="ln2337">#undef TYPVAL_ENCODE_CONV_NIL</a>
<a name="ln2338">#undef TYPVAL_ENCODE_CONV_BOOL</a>
<a name="ln2339">#undef TYPVAL_ENCODE_CONV_NUMBER</a>
<a name="ln2340">#undef TYPVAL_ENCODE_CONV_UNSIGNED_NUMBER</a>
<a name="ln2341">#undef TYPVAL_ENCODE_CONV_FLOAT</a>
<a name="ln2342">#undef TYPVAL_ENCODE_CONV_STRING</a>
<a name="ln2343">#undef TYPVAL_ENCODE_CONV_STR_STRING</a>
<a name="ln2344">#undef TYPVAL_ENCODE_CONV_EXT_STRING</a>
<a name="ln2345">#undef TYPVAL_ENCODE_CONV_FUNC_START</a>
<a name="ln2346">#undef TYPVAL_ENCODE_CONV_FUNC_BEFORE_ARGS</a>
<a name="ln2347">#undef TYPVAL_ENCODE_CONV_FUNC_BEFORE_SELF</a>
<a name="ln2348">#undef TYPVAL_ENCODE_CONV_FUNC_END</a>
<a name="ln2349">#undef TYPVAL_ENCODE_CONV_EMPTY_LIST</a>
<a name="ln2350">#undef TYPVAL_ENCODE_CONV_EMPTY_DICT</a>
<a name="ln2351">#undef TYPVAL_ENCODE_CONV_LIST_START</a>
<a name="ln2352">#undef TYPVAL_ENCODE_CONV_REAL_LIST_AFTER_START</a>
<a name="ln2353">#undef TYPVAL_ENCODE_CONV_LIST_BETWEEN_ITEMS</a>
<a name="ln2354">#undef TYPVAL_ENCODE_CONV_LIST_END</a>
<a name="ln2355">#undef TYPVAL_ENCODE_CONV_DICT_START</a>
<a name="ln2356">#undef TYPVAL_ENCODE_CONV_REAL_DICT_AFTER_START</a>
<a name="ln2357">#undef TYPVAL_ENCODE_SPECIAL_DICT_KEY_CHECK</a>
<a name="ln2358">#undef TYPVAL_ENCODE_CONV_DICT_AFTER_KEY</a>
<a name="ln2359">#undef TYPVAL_ENCODE_CONV_DICT_BETWEEN_ITEMS</a>
<a name="ln2360">#undef TYPVAL_ENCODE_CONV_DICT_END</a>
<a name="ln2361">#undef TYPVAL_ENCODE_CONV_RECURSE</a>
<a name="ln2362"> </a>
<a name="ln2363">/// Free memory for a variable value and set the value to NULL or 0</a>
<a name="ln2364">///</a>
<a name="ln2365">/// @param[in,out]  tv  Value to free.</a>
<a name="ln2366">void tv_clear(typval_T *const tv)</a>
<a name="ln2367">{</a>
<a name="ln2368">  if (tv != NULL &amp;&amp; tv-&gt;v_type != VAR_UNKNOWN) {</a>
<a name="ln2369">    // WARNING: do not translate the string here, gettext is slow and function</a>
<a name="ln2370">    // is used *very* often. At the current state encode_vim_to_nothing() does</a>
<a name="ln2371">    // not error out and does not use the argument anywhere.</a>
<a name="ln2372">    //</a>
<a name="ln2373">    // If situation changes and this argument will be used, translate it in the</a>
<a name="ln2374">    // place where it is used.</a>
<a name="ln2375">    const int evn_ret = encode_vim_to_nothing(NULL, tv, &quot;tv_clear() argument&quot;);</a>
<a name="ln2376">    (void)evn_ret;</a>
<a name="ln2377">    assert(evn_ret == OK);</a>
<a name="ln2378">  }</a>
<a name="ln2379">}</a>
<a name="ln2380"> </a>
<a name="ln2381">//{{{3 Free</a>
<a name="ln2382"> </a>
<a name="ln2383">/// Free allocated VimL object and value stored inside</a>
<a name="ln2384">///</a>
<a name="ln2385">/// @param  tv  Object to free.</a>
<a name="ln2386">void tv_free(typval_T *tv)</a>
<a name="ln2387">{</a>
<a name="ln2388">  if (tv != NULL) {</a>
<a name="ln2389">    switch (tv-&gt;v_type) {</a>
<a name="ln2390">      case VAR_PARTIAL: {</a>
<a name="ln2391">        partial_unref(tv-&gt;vval.v_partial);</a>
<a name="ln2392">        break;</a>
<a name="ln2393">      }</a>
<a name="ln2394">      case VAR_FUNC: {</a>
<a name="ln2395">        func_unref(tv-&gt;vval.v_string);</a>
<a name="ln2396">        FALLTHROUGH;</a>
<a name="ln2397">      }</a>
<a name="ln2398">      case VAR_STRING: {</a>
<a name="ln2399">        xfree(tv-&gt;vval.v_string);</a>
<a name="ln2400">        break;</a>
<a name="ln2401">      }</a>
<a name="ln2402">      case VAR_LIST: {</a>
<a name="ln2403">        tv_list_unref(tv-&gt;vval.v_list);</a>
<a name="ln2404">        break;</a>
<a name="ln2405">      }</a>
<a name="ln2406">      case VAR_DICT: {</a>
<a name="ln2407">        tv_dict_unref(tv-&gt;vval.v_dict);</a>
<a name="ln2408">        break;</a>
<a name="ln2409">      }</a>
<a name="ln2410">      case VAR_BOOL:</a>
<a name="ln2411">      case VAR_SPECIAL:</a>
<a name="ln2412">      case VAR_NUMBER:</a>
<a name="ln2413">      case VAR_FLOAT:</a>
<a name="ln2414">      case VAR_UNKNOWN: {</a>
<a name="ln2415">        break;</a>
<a name="ln2416">      }</a>
<a name="ln2417">    }</a>
<a name="ln2418">    xfree(tv);</a>
<a name="ln2419">  }</a>
<a name="ln2420">}</a>
<a name="ln2421"> </a>
<a name="ln2422">//{{{3 Copy</a>
<a name="ln2423"> </a>
<a name="ln2424">/// Copy typval from one location to another</a>
<a name="ln2425">///</a>
<a name="ln2426">/// When needed allocates string or increases reference count. Does not make</a>
<a name="ln2427">/// a copy of a container, but copies its reference!</a>
<a name="ln2428">///</a>
<a name="ln2429">/// It is OK for `from` and `to` to point to the same location; this is used to</a>
<a name="ln2430">/// make a copy later.</a>
<a name="ln2431">///</a>
<a name="ln2432">/// @param[in]  from  Location to copy from.</a>
<a name="ln2433">/// @param[out]  to  Location to copy to.</a>
<a name="ln2434">void tv_copy(const typval_T *const from, typval_T *const to)</a>
<a name="ln2435">{</a>
<a name="ln2436">  to-&gt;v_type = from-&gt;v_type;</a>
<a name="ln2437">  to-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln2438">  memmove(&amp;to-&gt;vval, &amp;from-&gt;vval, sizeof(to-&gt;vval));</a>
<a name="ln2439">  switch (from-&gt;v_type) {</a>
<a name="ln2440">    case VAR_NUMBER:</a>
<a name="ln2441">    case VAR_FLOAT:</a>
<a name="ln2442">    case VAR_BOOL:</a>
<a name="ln2443">    case VAR_SPECIAL: {</a>
<a name="ln2444">      break;</a>
<a name="ln2445">    }</a>
<a name="ln2446">    case VAR_STRING:</a>
<a name="ln2447">    case VAR_FUNC: {</a>
<a name="ln2448">      if (from-&gt;vval.v_string != NULL) {</a>
<a name="ln2449">        to-&gt;vval.v_string = vim_strsave(from-&gt;vval.v_string);</a>
<a name="ln2450">        if (from-&gt;v_type == VAR_FUNC) {</a>
<a name="ln2451">          func_ref(to-&gt;vval.v_string);</a>
<a name="ln2452">        }</a>
<a name="ln2453">      }</a>
<a name="ln2454">      break;</a>
<a name="ln2455">    }</a>
<a name="ln2456">    case VAR_PARTIAL: {</a>
<a name="ln2457">      if (to-&gt;vval.v_partial != NULL) {</a>
<a name="ln2458">        to-&gt;vval.v_partial-&gt;pt_refcount++;</a>
<a name="ln2459">      }</a>
<a name="ln2460">      break;</a>
<a name="ln2461">    }</a>
<a name="ln2462">    case VAR_LIST: {</a>
<a name="ln2463">      tv_list_ref(to-&gt;vval.v_list);</a>
<a name="ln2464">      break;</a>
<a name="ln2465">    }</a>
<a name="ln2466">    case VAR_DICT: {</a>
<a name="ln2467">      if (from-&gt;vval.v_dict != NULL) {</a>
<a name="ln2468">        to-&gt;vval.v_dict-&gt;dv_refcount++;</a>
<a name="ln2469">      }</a>
<a name="ln2470">      break;</a>
<a name="ln2471">    }</a>
<a name="ln2472">    case VAR_UNKNOWN: {</a>
<a name="ln2473">      emsgf(_(e_intern2), &quot;tv_copy(UNKNOWN)&quot;);</a>
<a name="ln2474">      break;</a>
<a name="ln2475">    }</a>
<a name="ln2476">  }</a>
<a name="ln2477">}</a>
<a name="ln2478"> </a>
<a name="ln2479">//{{{2 Locks</a>
<a name="ln2480"> </a>
<a name="ln2481">/// Lock or unlock an item</a>
<a name="ln2482">///</a>
<a name="ln2483">/// @param[out]  tv  Item to (un)lock.</a>
<a name="ln2484">/// @param[in]  deep  Levels to (un)lock, -1 to (un)lock everything.</a>
<a name="ln2485">/// @param[in]  lock  True if it is needed to lock an item, false to unlock.</a>
<a name="ln2486">void tv_item_lock(typval_T *const tv, const int deep, const bool lock)</a>
<a name="ln2487">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2488">{</a>
<a name="ln2489">  // TODO(ZyX-I): Make this not recursive</a>
<a name="ln2490">  static int recurse = 0;</a>
<a name="ln2491"> </a>
<a name="ln2492">  if (recurse &gt;= DICT_MAXNEST) {</a>
<a name="ln2493">    EMSG(_(&quot;E743: variable nested too deep for (un)lock&quot;));</a>
<a name="ln2494">    return;</a>
<a name="ln2495">  }</a>
<a name="ln2496">  if (deep == 0) {</a>
<a name="ln2497">    return;</a>
<a name="ln2498">  }</a>
<a name="ln2499">  recurse++;</a>
<a name="ln2500"> </a>
<a name="ln2501">  // lock/unlock the item itself</a>
<a name="ln2502">#define CHANGE_LOCK(lock, var) \</a>
<a name="ln2503">  do { \</a>
<a name="ln2504">    var = ((VarLockStatus[]) { \</a>
<a name="ln2505">      [VAR_UNLOCKED] = (lock ? VAR_LOCKED : VAR_UNLOCKED), \</a>
<a name="ln2506">      [VAR_LOCKED] = (lock ? VAR_LOCKED : VAR_UNLOCKED), \</a>
<a name="ln2507">      [VAR_FIXED] = VAR_FIXED, \</a>
<a name="ln2508">    })[var]; \</a>
<a name="ln2509">  } while (0)</a>
<a name="ln2510">  CHANGE_LOCK(lock, tv-&gt;v_lock);</a>
<a name="ln2511"> </a>
<a name="ln2512">  switch (tv-&gt;v_type) {</a>
<a name="ln2513">    case VAR_LIST: {</a>
<a name="ln2514">      list_T *const l = tv-&gt;vval.v_list;</a>
<a name="ln2515">      if (l != NULL) {</a>
<a name="ln2516">        CHANGE_LOCK(lock, l-&gt;lv_lock);</a>
<a name="ln2517">        if (deep &lt; 0 || deep &gt; 1) {</a>
<a name="ln2518">          // Recursive: lock/unlock the items the List contains.</a>
<a name="ln2519">          TV_LIST_ITER(l, li, {</a>
<a name="ln2520">            tv_item_lock(TV_LIST_ITEM_TV(li), deep - 1, lock);</a>
<a name="ln2521">          });</a>
<a name="ln2522">        }</a>
<a name="ln2523">      }</a>
<a name="ln2524">      break;</a>
<a name="ln2525">    }</a>
<a name="ln2526">    case VAR_DICT: {</a>
<a name="ln2527">      dict_T *const d = tv-&gt;vval.v_dict;</a>
<a name="ln2528">      if (d != NULL) {</a>
<a name="ln2529">        CHANGE_LOCK(lock, d-&gt;dv_lock);</a>
<a name="ln2530">        if (deep &lt; 0 || deep &gt; 1) {</a>
<a name="ln2531">          // recursive: lock/unlock the items the List contains</a>
<a name="ln2532">          TV_DICT_ITER(d, di, {</a>
<a name="ln2533">            tv_item_lock(&amp;di-&gt;di_tv, deep - 1, lock);</a>
<a name="ln2534">          });</a>
<a name="ln2535">        }</a>
<a name="ln2536">      }</a>
<a name="ln2537">      break;</a>
<a name="ln2538">    }</a>
<a name="ln2539">    case VAR_NUMBER:</a>
<a name="ln2540">    case VAR_FLOAT:</a>
<a name="ln2541">    case VAR_STRING:</a>
<a name="ln2542">    case VAR_FUNC:</a>
<a name="ln2543">    case VAR_PARTIAL:</a>
<a name="ln2544">    case VAR_BOOL:</a>
<a name="ln2545">    case VAR_SPECIAL: {</a>
<a name="ln2546">      break;</a>
<a name="ln2547">    }</a>
<a name="ln2548">    case VAR_UNKNOWN: {</a>
<a name="ln2549">      abort();</a>
<a name="ln2550">    }</a>
<a name="ln2551">  }</a>
<a name="ln2552">#undef CHANGE_LOCK</a>
<a name="ln2553">  recurse--;</a>
<a name="ln2554">}</a>
<a name="ln2555"> </a>
<a name="ln2556">/// Check whether VimL value is locked itself or refers to a locked container</a>
<a name="ln2557">///</a>
<a name="ln2558">/// @warning Fixed container is not the same as locked.</a>
<a name="ln2559">///</a>
<a name="ln2560">/// @param[in]  tv  Value to check.</a>
<a name="ln2561">///</a>
<a name="ln2562">/// @return True if value is locked, false otherwise.</a>
<a name="ln2563">bool tv_islocked(const typval_T *const tv)</a>
<a name="ln2564">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2565">{</a>
<a name="ln2566">  return ((tv-&gt;v_lock == VAR_LOCKED)</a>
<a name="ln2567">          || (tv-&gt;v_type == VAR_LIST</a>
<a name="ln2568">              &amp;&amp; (tv_list_locked(tv-&gt;vval.v_list) == VAR_LOCKED))</a>
<a name="ln2569">          || (tv-&gt;v_type == VAR_DICT</a>
<a name="ln2570">              &amp;&amp; tv-&gt;vval.v_dict != NULL</a>
<a name="ln2571">              &amp;&amp; (tv-&gt;vval.v_dict-&gt;dv_lock == VAR_LOCKED)));</a>
<a name="ln2572">}</a>
<a name="ln2573"> </a>
<a name="ln2574">/// Return true if typval is locked</a>
<a name="ln2575">///</a>
<a name="ln2576">/// Also gives an error message when typval is locked.</a>
<a name="ln2577">///</a>
<a name="ln2578">/// @param[in]  lock  Lock status.</a>
<a name="ln2579">/// @param[in]  name  Variable name, used in the error message.</a>
<a name="ln2580">/// @param[in]  name_len  Variable name length. Use #TV_TRANSLATE to translate</a>
<a name="ln2581">///                       variable name and compute the length. Use #TV_CSTRING</a>
<a name="ln2582">///                       to compute the length with strlen() without</a>
<a name="ln2583">///                       translating.</a>
<a name="ln2584">///</a>
<a name="ln2585">///                       Both #TV_… values are used for optimization purposes:</a>
<a name="ln2586">///                       variable name with its length is needed only in case</a>
<a name="ln2587">///                       of error, when no error occurs computing them is</a>
<a name="ln2588">///                       a waste of CPU resources. This especially applies to</a>
<a name="ln2589">///                       gettext.</a>
<a name="ln2590">///</a>
<a name="ln2591">/// @return true if variable is locked, false otherwise.</a>
<a name="ln2592">bool tv_check_lock(const VarLockStatus lock, const char *name,</a>
<a name="ln2593">                   size_t name_len)</a>
<a name="ln2594">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2595">{</a>
<a name="ln2596">  const char *error_message = NULL;</a>
<a name="ln2597">  switch (lock) {</a>
<a name="ln2598">    case VAR_UNLOCKED: {</a>
<a name="ln2599">      return false;</a>
<a name="ln2600">    }</a>
<a name="ln2601">    case VAR_LOCKED: {</a>
<a name="ln2602">      error_message = N_(&quot;E741: Value is locked: %.*s&quot;);</a>
<a name="ln2603">      break;</a>
<a name="ln2604">    }</a>
<a name="ln2605">    case VAR_FIXED: {</a>
<a name="ln2606">      error_message = N_(&quot;E742: Cannot change value of %.*s&quot;);</a>
<a name="ln2607">      break;</a>
<a name="ln2608">    }</a>
<a name="ln2609">  }</a>
<a name="ln2610">  assert(error_message != NULL);</a>
<a name="ln2611"> </a>
<a name="ln2612">  if (name == NULL) {</a>
<a name="ln2613">    name = _(&quot;Unknown&quot;);</a>
<a name="ln2614">    name_len = strlen(name);</a>
<a name="ln2615">  } else if (name_len == TV_TRANSLATE) {</a>
<a name="ln2616">    name = _(name);</a>
<a name="ln2617">    name_len = strlen(name);</a>
<a name="ln2618">  } else if (name_len == TV_CSTRING) {</a>
<a name="ln2619">    name_len = strlen(name);</a>
<a name="ln2620">  }</a>
<a name="ln2621"> </a>
<a name="ln2622">  emsgf(_(error_message), (int)name_len, name);</a>
<a name="ln2623"> </a>
<a name="ln2624">  return true;</a>
<a name="ln2625">}</a>
<a name="ln2626"> </a>
<a name="ln2627">//{{{2 Comparison</a>
<a name="ln2628"> </a>
<a name="ln2629">static int tv_equal_recurse_limit;</a>
<a name="ln2630"> </a>
<a name="ln2631">/// Compare two VimL values</a>
<a name="ln2632">///</a>
<a name="ln2633">/// Like &quot;==&quot;, but strings and numbers are different, as well as floats and</a>
<a name="ln2634">/// numbers.</a>
<a name="ln2635">///</a>
<a name="ln2636">/// @warning Too nested structures may be considered equal even if they are not.</a>
<a name="ln2637">///</a>
<a name="ln2638">/// @param[in]  tv1  First value to compare.</a>
<a name="ln2639">/// @param[in]  tv2  Second value to compare.</a>
<a name="ln2640">/// @param[in]  ic  True if case is to be ignored.</a>
<a name="ln2641">/// @param[in]  recursive  True when used recursively.</a>
<a name="ln2642">///</a>
<a name="ln2643">/// @return true if values are equal.</a>
<a name="ln2644">bool tv_equal(typval_T *const tv1, typval_T *const tv2, const bool ic,</a>
<a name="ln2645">              const bool recursive)</a>
<a name="ln2646">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2647">{</a>
<a name="ln2648">  // TODO(ZyX-I): Make this not recursive</a>
<a name="ln2649">  static int recursive_cnt = 0;  // Catch recursive loops.</a>
<a name="ln2650"> </a>
<a name="ln2651">  if (!(tv_is_func(*tv1) &amp;&amp; tv_is_func(*tv2)) &amp;&amp; tv1-&gt;v_type != tv2-&gt;v_type) {</a>
<a name="ln2652">    return false;</a>
<a name="ln2653">  }</a>
<a name="ln2654"> </a>
<a name="ln2655">  // Catch lists and dicts that have an endless loop by limiting</a>
<a name="ln2656">  // recursiveness to a limit.  We guess they are equal then.</a>
<a name="ln2657">  // A fixed limit has the problem of still taking an awful long time.</a>
<a name="ln2658">  // Reduce the limit every time running into it. That should work fine for</a>
<a name="ln2659">  // deeply linked structures that are not recursively linked and catch</a>
<a name="ln2660">  // recursiveness quickly.</a>
<a name="ln2661">  if (!recursive) {</a>
<a name="ln2662">    tv_equal_recurse_limit = 1000;</a>
<a name="ln2663">  }</a>
<a name="ln2664">  if (recursive_cnt &gt;= tv_equal_recurse_limit) {</a>
<a name="ln2665">    tv_equal_recurse_limit--;</a>
<a name="ln2666">    return true;</a>
<a name="ln2667">  }</a>
<a name="ln2668"> </a>
<a name="ln2669">  switch (tv1-&gt;v_type) {</a>
<a name="ln2670">    case VAR_LIST: {</a>
<a name="ln2671">      recursive_cnt++;</a>
<a name="ln2672">      const bool r = tv_list_equal(tv1-&gt;vval.v_list, tv2-&gt;vval.v_list, ic,</a>
<a name="ln2673">                                   true);</a>
<a name="ln2674">      recursive_cnt--;</a>
<a name="ln2675">      return r;</a>
<a name="ln2676">    }</a>
<a name="ln2677">    case VAR_DICT: {</a>
<a name="ln2678">      recursive_cnt++;</a>
<a name="ln2679">      const bool r = tv_dict_equal(tv1-&gt;vval.v_dict, tv2-&gt;vval.v_dict, ic,</a>
<a name="ln2680">                                   true);</a>
<a name="ln2681">      recursive_cnt--;</a>
<a name="ln2682">      return r;</a>
<a name="ln2683">    }</a>
<a name="ln2684">    case VAR_PARTIAL:</a>
<a name="ln2685">    case VAR_FUNC: {</a>
<a name="ln2686">      if ((tv1-&gt;v_type == VAR_PARTIAL &amp;&amp; tv1-&gt;vval.v_partial == NULL)</a>
<a name="ln2687">          || (tv2-&gt;v_type == VAR_PARTIAL &amp;&amp; tv2-&gt;vval.v_partial == NULL)) {</a>
<a name="ln2688">        return false;</a>
<a name="ln2689">      }</a>
<a name="ln2690">      recursive_cnt++;</a>
<a name="ln2691">      const bool r = func_equal(tv1, tv2, ic);</a>
<a name="ln2692">      recursive_cnt--;</a>
<a name="ln2693">      return r;</a>
<a name="ln2694">    }</a>
<a name="ln2695">    case VAR_NUMBER: {</a>
<a name="ln2696">      return tv1-&gt;vval.v_number == tv2-&gt;vval.v_number;</a>
<a name="ln2697">    }</a>
<a name="ln2698">    case VAR_FLOAT: {</a>
<a name="ln2699">      return tv1-&gt;vval.v_float == tv2-&gt;vval.v_float;</a>
<a name="ln2700">    }</a>
<a name="ln2701">    case VAR_STRING: {</a>
<a name="ln2702">      char buf1[NUMBUFLEN];</a>
<a name="ln2703">      char buf2[NUMBUFLEN];</a>
<a name="ln2704">      const char *s1 = tv_get_string_buf(tv1, buf1);</a>
<a name="ln2705">      const char *s2 = tv_get_string_buf(tv2, buf2);</a>
<a name="ln2706">      return mb_strcmp_ic((bool)ic, s1, s2) == 0;</a>
<a name="ln2707">    }</a>
<a name="ln2708">    case VAR_BOOL: {</a>
<a name="ln2709">      return tv1-&gt;vval.v_bool == tv2-&gt;vval.v_bool;</a>
<a name="ln2710">    }</a>
<a name="ln2711">    case VAR_SPECIAL: {</a>
<a name="ln2712">      return tv1-&gt;vval.v_special == tv2-&gt;vval.v_special;</a>
<a name="ln2713">    }</a>
<a name="ln2714">    case VAR_UNKNOWN: {</a>
<a name="ln2715">      // VAR_UNKNOWN can be the result of an invalid expression, let’s say it</a>
<a name="ln2716">      // does not equal anything, not even self.</a>
<a name="ln2717">      return false;</a>
<a name="ln2718">    }</a>
<a name="ln2719">  }</a>
<a name="ln2720"> </a>
<a name="ln2721">  abort();</a>
<a name="ln2722">  return false;</a>
<a name="ln2723">}</a>
<a name="ln2724"> </a>
<a name="ln2725">//{{{2 Type checks</a>
<a name="ln2726"> </a>
<a name="ln2727">/// Check that given value is a number or string</a>
<a name="ln2728">///</a>
<a name="ln2729">/// Error messages are compatible with tv_get_number() previously used for the</a>
<a name="ln2730">/// same purpose in buf*() functions. Special values are not accepted (previous</a>
<a name="ln2731">/// behaviour: silently fail to find buffer).</a>
<a name="ln2732">///</a>
<a name="ln2733">/// @param[in]  tv  Value to check.</a>
<a name="ln2734">///</a>
<a name="ln2735">/// @return true if everything is OK, false otherwise.</a>
<a name="ln2736">bool tv_check_str_or_nr(const typval_T *const tv)</a>
<a name="ln2737">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2738">{</a>
<a name="ln2739">  switch (tv-&gt;v_type) {</a>
<a name="ln2740">    case VAR_NUMBER:</a>
<a name="ln2741">    case VAR_STRING: {</a>
<a name="ln2742">      return true;</a>
<a name="ln2743">    }</a>
<a name="ln2744">    case VAR_FLOAT: {</a>
<a name="ln2745">      EMSG(_(&quot;E805: Expected a Number or a String, Float found&quot;));</a>
<a name="ln2746">      return false;</a>
<a name="ln2747">    }</a>
<a name="ln2748">    case VAR_PARTIAL:</a>
<a name="ln2749">    case VAR_FUNC: {</a>
<a name="ln2750">      EMSG(_(&quot;E703: Expected a Number or a String, Funcref found&quot;));</a>
<a name="ln2751">      return false;</a>
<a name="ln2752">    }</a>
<a name="ln2753">    case VAR_LIST: {</a>
<a name="ln2754">      EMSG(_(&quot;E745: Expected a Number or a String, List found&quot;));</a>
<a name="ln2755">      return false;</a>
<a name="ln2756">    }</a>
<a name="ln2757">    case VAR_DICT: {</a>
<a name="ln2758">      EMSG(_(&quot;E728: Expected a Number or a String, Dictionary found&quot;));</a>
<a name="ln2759">      return false;</a>
<a name="ln2760">    }</a>
<a name="ln2761">    case VAR_BOOL: {</a>
<a name="ln2762">      EMSG(_(&quot;E5299: Expected a Number or a String, Boolean found&quot;));</a>
<a name="ln2763">      return false;</a>
<a name="ln2764">    }</a>
<a name="ln2765">    case VAR_SPECIAL: {</a>
<a name="ln2766">      EMSG(_(&quot;E5300: Expected a Number or a String&quot;));</a>
<a name="ln2767">      return false;</a>
<a name="ln2768">    }</a>
<a name="ln2769">    case VAR_UNKNOWN: {</a>
<a name="ln2770">      EMSG2(_(e_intern2), &quot;tv_check_str_or_nr(UNKNOWN)&quot;);</a>
<a name="ln2771">      return false;</a>
<a name="ln2772">    }</a>
<a name="ln2773">  }</a>
<a name="ln2774">  abort();</a>
<a name="ln2775">  return false;</a>
<a name="ln2776">}</a>
<a name="ln2777"> </a>
<a name="ln2778">#define FUNC_ERROR &quot;E703: Using a Funcref as a Number&quot;</a>
<a name="ln2779"> </a>
<a name="ln2780">static const char *const num_errors[] = {</a>
<a name="ln2781">  [VAR_PARTIAL]=N_(FUNC_ERROR),</a>
<a name="ln2782">  [VAR_FUNC]=N_(FUNC_ERROR),</a>
<a name="ln2783">  [VAR_LIST]=N_(&quot;E745: Using a List as a Number&quot;),</a>
<a name="ln2784">  [VAR_DICT]=N_(&quot;E728: Using a Dictionary as a Number&quot;),</a>
<a name="ln2785">  [VAR_FLOAT]=N_(&quot;E805: Using a Float as a Number&quot;),</a>
<a name="ln2786">  [VAR_UNKNOWN]=N_(&quot;E685: using an invalid value as a Number&quot;),</a>
<a name="ln2787">};</a>
<a name="ln2788"> </a>
<a name="ln2789">#undef FUNC_ERROR</a>
<a name="ln2790"> </a>
<a name="ln2791">/// Check that given value is a number or can be converted to it</a>
<a name="ln2792">///</a>
<a name="ln2793">/// Error messages are compatible with tv_get_number_chk() previously used for</a>
<a name="ln2794">/// the same purpose.</a>
<a name="ln2795">///</a>
<a name="ln2796">/// @param[in]  tv  Value to check.</a>
<a name="ln2797">///</a>
<a name="ln2798">/// @return true if everything is OK, false otherwise.</a>
<a name="ln2799">bool tv_check_num(const typval_T *const tv)</a>
<a name="ln2800">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2801">{</a>
<a name="ln2802">  switch (tv-&gt;v_type) {</a>
<a name="ln2803">    case VAR_NUMBER:</a>
<a name="ln2804">    case VAR_BOOL:</a>
<a name="ln2805">    case VAR_SPECIAL:</a>
<a name="ln2806">    case VAR_STRING: {</a>
<a name="ln2807">      return true;</a>
<a name="ln2808">    }</a>
<a name="ln2809">    case VAR_FUNC:</a>
<a name="ln2810">    case VAR_PARTIAL:</a>
<a name="ln2811">    case VAR_LIST:</a>
<a name="ln2812">    case VAR_DICT:</a>
<a name="ln2813">    case VAR_FLOAT:</a>
<a name="ln2814">    case VAR_UNKNOWN: {</a>
<a name="ln2815">      EMSG(_(num_errors[tv-&gt;v_type]));</a>
<a name="ln2816">      return false;</a>
<a name="ln2817">    }</a>
<a name="ln2818">  }</a>
<a name="ln2819">  abort();</a>
<a name="ln2820">  return false;</a>
<a name="ln2821">}</a>
<a name="ln2822"> </a>
<a name="ln2823">#define FUNC_ERROR &quot;E729: using Funcref as a String&quot;</a>
<a name="ln2824"> </a>
<a name="ln2825">static const char *const str_errors[] = {</a>
<a name="ln2826">  [VAR_PARTIAL]=N_(FUNC_ERROR),</a>
<a name="ln2827">  [VAR_FUNC]=N_(FUNC_ERROR),</a>
<a name="ln2828">  [VAR_LIST]=N_(&quot;E730: using List as a String&quot;),</a>
<a name="ln2829">  [VAR_DICT]=N_(&quot;E731: using Dictionary as a String&quot;),</a>
<a name="ln2830">  [VAR_FLOAT]=((const char *)e_float_as_string),</a>
<a name="ln2831">  [VAR_UNKNOWN]=N_(&quot;E908: using an invalid value as a String&quot;),</a>
<a name="ln2832">};</a>
<a name="ln2833"> </a>
<a name="ln2834">#undef FUNC_ERROR</a>
<a name="ln2835"> </a>
<a name="ln2836">/// Check that given value is a VimL String or can be &quot;cast&quot; to it.</a>
<a name="ln2837">///</a>
<a name="ln2838">/// Error messages are compatible with tv_get_string_chk() previously used for</a>
<a name="ln2839">/// the same purpose.</a>
<a name="ln2840">///</a>
<a name="ln2841">/// @param[in]  tv  Value to check.</a>
<a name="ln2842">///</a>
<a name="ln2843">/// @return true if everything is OK, false otherwise.</a>
<a name="ln2844">bool tv_check_str(const typval_T *const tv)</a>
<a name="ln2845">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2846">{</a>
<a name="ln2847">  switch (tv-&gt;v_type) {</a>
<a name="ln2848">    case VAR_NUMBER:</a>
<a name="ln2849">    case VAR_BOOL:</a>
<a name="ln2850">    case VAR_SPECIAL:</a>
<a name="ln2851">    case VAR_STRING: {</a>
<a name="ln2852">      return true;</a>
<a name="ln2853">    }</a>
<a name="ln2854">    case VAR_PARTIAL:</a>
<a name="ln2855">    case VAR_FUNC:</a>
<a name="ln2856">    case VAR_LIST:</a>
<a name="ln2857">    case VAR_DICT:</a>
<a name="ln2858">    case VAR_FLOAT:</a>
<a name="ln2859">    case VAR_UNKNOWN: {</a>
<a name="ln2860">      EMSG(_(str_errors[tv-&gt;v_type]));</a>
<a name="ln2861">      return false;</a>
<a name="ln2862">    }</a>
<a name="ln2863">  }</a>
<a name="ln2864">  abort();</a>
<a name="ln2865">  return false;</a>
<a name="ln2866">}</a>
<a name="ln2867"> </a>
<a name="ln2868">//{{{2 Get</a>
<a name="ln2869"> </a>
<a name="ln2870">/// Get the number value of a VimL object</a>
<a name="ln2871">///</a>
<a name="ln2872">/// @note Use tv_get_number_chk() if you need to determine whether there was an</a>
<a name="ln2873">///       error.</a>
<a name="ln2874">///</a>
<a name="ln2875">/// @param[in]  tv  Object to get value from.</a>
<a name="ln2876">///</a>
<a name="ln2877">/// @return Number value: vim_str2nr() output for VAR_STRING objects, value</a>
<a name="ln2878">///         for VAR_NUMBER objects, -1 for other types.</a>
<a name="ln2879">varnumber_T tv_get_number(const typval_T *const tv)</a>
<a name="ln2880">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2881">{</a>
<a name="ln2882">  bool error = false;</a>
<a name="ln2883">  return tv_get_number_chk(tv, &amp;error);</a>
<a name="ln2884">}</a>
<a name="ln2885"> </a>
<a name="ln2886">/// Get the number value of a VimL object</a>
<a name="ln2887">///</a>
<a name="ln2888">/// @param[in]  tv  Object to get value from.</a>
<a name="ln2889">/// @param[out]  ret_error  If type error occurred then `true` will be written</a>
<a name="ln2890">///                         to this location. Otherwise it is not touched.</a>
<a name="ln2891">///</a>
<a name="ln2892">///                         @note Needs to be initialized to `false` to be</a>
<a name="ln2893">///                               useful.</a>
<a name="ln2894">///</a>
<a name="ln2895">/// @return Number value: vim_str2nr() output for VAR_STRING objects, value</a>
<a name="ln2896">///         for VAR_NUMBER objects, -1 (ret_error == NULL) or 0 (otherwise) for</a>
<a name="ln2897">///         other types.</a>
<a name="ln2898">varnumber_T tv_get_number_chk(const typval_T *const tv, bool *const ret_error)</a>
<a name="ln2899">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln2900">{</a>
<a name="ln2901">  switch (tv-&gt;v_type) {</a>
<a name="ln2902">    case VAR_FUNC:</a>
<a name="ln2903">    case VAR_PARTIAL:</a>
<a name="ln2904">    case VAR_LIST:</a>
<a name="ln2905">    case VAR_DICT:</a>
<a name="ln2906">    case VAR_FLOAT: {</a>
<a name="ln2907">      EMSG(_(num_errors[tv-&gt;v_type]));</a>
<a name="ln2908">      break;</a>
<a name="ln2909">    }</a>
<a name="ln2910">    case VAR_NUMBER: {</a>
<a name="ln2911">      return tv-&gt;vval.v_number;</a>
<a name="ln2912">    }</a>
<a name="ln2913">    case VAR_STRING: {</a>
<a name="ln2914">      varnumber_T n = 0;</a>
<a name="ln2915">      if (tv-&gt;vval.v_string != NULL) {</a>
<a name="ln2916">        vim_str2nr(tv-&gt;vval.v_string, NULL, NULL, STR2NR_ALL, &amp;n, NULL, 0);</a>
<a name="ln2917">      }</a>
<a name="ln2918">      return n;</a>
<a name="ln2919">    }</a>
<a name="ln2920">    case VAR_BOOL: {</a>
<a name="ln2921">      return tv-&gt;vval.v_bool == kBoolVarTrue ? 1 : 0;</a>
<a name="ln2922">    }</a>
<a name="ln2923">    case VAR_SPECIAL: {</a>
<a name="ln2924">      return 0;</a>
<a name="ln2925">    }</a>
<a name="ln2926">    case VAR_UNKNOWN: {</a>
<a name="ln2927">      emsgf(_(e_intern2), &quot;tv_get_number(UNKNOWN)&quot;);</a>
<a name="ln2928">      break;</a>
<a name="ln2929">    }</a>
<a name="ln2930">  }</a>
<a name="ln2931">  if (ret_error != NULL) {</a>
<a name="ln2932">    *ret_error = true;</a>
<a name="ln2933">  }</a>
<a name="ln2934">  return (ret_error == NULL ? -1 : 0);</a>
<a name="ln2935">}</a>
<a name="ln2936"> </a>
<a name="ln2937">/// Get the line number from VimL object</a>
<a name="ln2938">///</a>
<a name="ln2939">/// @param[in]  tv  Object to get value from. Is expected to be a number or</a>
<a name="ln2940">///                 a special string like &quot;.&quot;, &quot;$&quot;, … (works with current buffer</a>
<a name="ln2941">///                 only).</a>
<a name="ln2942">///</a>
<a name="ln2943">/// @return Line number or -1 or 0.</a>
<a name="ln2944">linenr_T tv_get_lnum(const typval_T *const tv)</a>
<a name="ln2945">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2946">{</a>
<a name="ln2947">  linenr_T lnum = (linenr_T)tv_get_number_chk(tv, NULL);</a>
<a name="ln2948">  if (lnum == 0) {  // No valid number, try using same function as line() does.</a>
<a name="ln2949">    int fnum;</a>
<a name="ln2950">    pos_T *const fp = var2fpos(tv, true, &amp;fnum);</a>
<a name="ln2951">    if (fp != NULL) {</a>
<a name="ln2952">      lnum = fp-&gt;lnum;</a>
<a name="ln2953">    }</a>
<a name="ln2954">  }</a>
<a name="ln2955">  return lnum;</a>
<a name="ln2956">}</a>
<a name="ln2957"> </a>
<a name="ln2958">/// Get the floating-point value of a VimL object</a>
<a name="ln2959">///</a>
<a name="ln2960">/// Raises an error if object is not number or floating-point.</a>
<a name="ln2961">///</a>
<a name="ln2962">/// @param[in]  tv  Object to get value of.</a>
<a name="ln2963">///</a>
<a name="ln2964">/// @return Floating-point value of the variable or zero.</a>
<a name="ln2965">float_T tv_get_float(const typval_T *const tv)</a>
<a name="ln2966">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2967">{</a>
<a name="ln2968">  switch (tv-&gt;v_type) {</a>
<a name="ln2969">    case VAR_NUMBER: {</a>
<a name="ln2970">      return (float_T)(tv-&gt;vval.v_number);</a>
<a name="ln2971">    }</a>
<a name="ln2972">    case VAR_FLOAT: {</a>
<a name="ln2973">      return tv-&gt;vval.v_float;</a>
<a name="ln2974">    }</a>
<a name="ln2975">    case VAR_PARTIAL:</a>
<a name="ln2976">    case VAR_FUNC: {</a>
<a name="ln2977">      EMSG(_(&quot;E891: Using a Funcref as a Float&quot;));</a>
<a name="ln2978">      break;</a>
<a name="ln2979">    }</a>
<a name="ln2980">    case VAR_STRING: {</a>
<a name="ln2981">      EMSG(_(&quot;E892: Using a String as a Float&quot;));</a>
<a name="ln2982">      break;</a>
<a name="ln2983">    }</a>
<a name="ln2984">    case VAR_LIST: {</a>
<a name="ln2985">      EMSG(_(&quot;E893: Using a List as a Float&quot;));</a>
<a name="ln2986">      break;</a>
<a name="ln2987">    }</a>
<a name="ln2988">    case VAR_DICT: {</a>
<a name="ln2989">      EMSG(_(&quot;E894: Using a Dictionary as a Float&quot;));</a>
<a name="ln2990">      break;</a>
<a name="ln2991">    }</a>
<a name="ln2992">    case VAR_BOOL: {</a>
<a name="ln2993">      EMSG(_(&quot;E362: Using a boolean value as a Float&quot;));</a>
<a name="ln2994">      break;</a>
<a name="ln2995">    }</a>
<a name="ln2996">    case VAR_SPECIAL: {</a>
<a name="ln2997">      EMSG(_(&quot;E907: Using a special value as a Float&quot;));</a>
<a name="ln2998">      break;</a>
<a name="ln2999">    }</a>
<a name="ln3000">    case VAR_UNKNOWN: {</a>
<a name="ln3001">      emsgf(_(e_intern2), &quot;tv_get_float(UNKNOWN)&quot;);</a>
<a name="ln3002">      break;</a>
<a name="ln3003">    }</a>
<a name="ln3004">  }</a>
<a name="ln3005">  return 0;</a>
<a name="ln3006">}</a>
<a name="ln3007"> </a>
<a name="ln3008">// Give an error and return FAIL unless &quot;tv&quot; is a non-empty string.</a>
<a name="ln3009">int tv_check_for_string(const typval_T *const tv)</a>
<a name="ln3010">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln3011">{</a>
<a name="ln3012">  if (tv-&gt;v_type != VAR_STRING</a>
<a name="ln3013">      || tv-&gt;vval.v_string == NULL</a>
<a name="ln3014">      || *tv-&gt;vval.v_string == NUL) {</a>
<a name="ln3015">    EMSG(_(e_stringreq));</a>
<a name="ln3016">    return FAIL;</a>
<a name="ln3017">  }</a>
<a name="ln3018">  return OK;</a>
<a name="ln3019">}</a>
<a name="ln3020"> </a>
<a name="ln3021">/// Get the string value of a &quot;stringish&quot; VimL object.</a>
<a name="ln3022">///</a>
<a name="ln3023">/// @param[in]  tv  Object to get value of.</a>
<a name="ln3024">/// @param  buf  Buffer used to hold numbers and special variables converted to</a>
<a name="ln3025">///              string. When function encounters one of these stringified value</a>
<a name="ln3026">///              will be written to buf and buf will be returned.</a>
<a name="ln3027">///</a>
<a name="ln3028">///              Buffer must have NUMBUFLEN size.</a>
<a name="ln3029">///</a>
<a name="ln3030">/// @return Object value if it is VAR_STRING object, number converted to</a>
<a name="ln3031">///         a string for VAR_NUMBER, v: variable name for VAR_SPECIAL or NULL.</a>
<a name="ln3032">const char *tv_get_string_buf_chk(const typval_T *const tv, char *const buf)</a>
<a name="ln3033">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3034">{</a>
<a name="ln3035">  switch (tv-&gt;v_type) {</a>
<a name="ln3036">    case VAR_NUMBER: {</a>
<a name="ln3037">      snprintf(buf, NUMBUFLEN, &quot;%&quot; PRIdVARNUMBER, tv-&gt;vval.v_number);  // -V576</a>
<a name="ln3038">      return buf;</a>
<a name="ln3039">    }</a>
<a name="ln3040">    case VAR_STRING: {</a>
<a name="ln3041">      if (tv-&gt;vval.v_string != NULL) {</a>
<a name="ln3042">        return (const char *)tv-&gt;vval.v_string;</a>
<a name="ln3043">      }</a>
<a name="ln3044">      return &quot;&quot;;</a>
<a name="ln3045">    }</a>
<a name="ln3046">    case VAR_BOOL: {</a>
<a name="ln3047">      STRCPY(buf, encode_bool_var_names[tv-&gt;vval.v_bool]);</a>
<a name="ln3048">      return buf;</a>
<a name="ln3049">    }</a>
<a name="ln3050">    case VAR_SPECIAL: {</a>
<a name="ln3051">      STRCPY(buf, encode_special_var_names[tv-&gt;vval.v_special]);</a>
<a name="ln3052">      return buf;</a>
<a name="ln3053">    }</a>
<a name="ln3054">    case VAR_PARTIAL:</a>
<a name="ln3055">    case VAR_FUNC:</a>
<a name="ln3056">    case VAR_LIST:</a>
<a name="ln3057">    case VAR_DICT:</a>
<a name="ln3058">    case VAR_FLOAT:</a>
<a name="ln3059">    case VAR_UNKNOWN: {</a>
<a name="ln3060">      EMSG(_(str_errors[tv-&gt;v_type]));</a>
<a name="ln3061">      return false;</a>
<a name="ln3062">    }</a>
<a name="ln3063">  }</a>
<a name="ln3064">  return NULL;</a>
<a name="ln3065">}</a>
<a name="ln3066"> </a>
<a name="ln3067">/// Get the string value of a &quot;stringish&quot; VimL object.</a>
<a name="ln3068">///</a>
<a name="ln3069">/// @warning For number and special values it uses a single, static buffer. It</a>
<a name="ln3070">///          may be used only once, next call to tv_get_string may reuse it. Use</a>
<a name="ln3071">///          tv_get_string_buf() if you need to use tv_get_string() output after</a>
<a name="ln3072">///          calling it again.</a>
<a name="ln3073">///</a>
<a name="ln3074">/// @param[in]  tv  Object to get value of.</a>
<a name="ln3075">///</a>
<a name="ln3076">/// @return Object value if it is VAR_STRING object, number converted to</a>
<a name="ln3077">///         a string for VAR_NUMBER, v: variable name for VAR_SPECIAL or NULL.</a>
<a name="ln3078">const char *tv_get_string_chk(const typval_T *const tv)</a>
<a name="ln3079">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3080">{</a>
<a name="ln3081">  static char mybuf[NUMBUFLEN];</a>
<a name="ln3082"> </a>
<a name="ln3083">  return tv_get_string_buf_chk(tv, mybuf);</a>
<a name="ln3084">}</a>
<a name="ln3085"> </a>
<a name="ln3086">/// Get the string value of a &quot;stringish&quot; VimL object.</a>
<a name="ln3087">///</a>
<a name="ln3088">/// @warning For number and special values it uses a single, static buffer. It</a>
<a name="ln3089">///          may be used only once, next call to tv_get_string may reuse it. Use</a>
<a name="ln3090">///          tv_get_string_buf() if you need to use tv_get_string() output after</a>
<a name="ln3091">///          calling it again.</a>
<a name="ln3092">///</a>
<a name="ln3093">/// @note tv_get_string_chk() and tv_get_string_buf_chk() are similar, but</a>
<a name="ln3094">///       return NULL on error.</a>
<a name="ln3095">///</a>
<a name="ln3096">/// @param[in]  tv  Object to get value of.</a>
<a name="ln3097">///</a>
<a name="ln3098">/// @return Object value if it is VAR_STRING object, number converted to</a>
<a name="ln3099">///         a string for VAR_NUMBER, v: variable name for VAR_SPECIAL or empty</a>
<a name="ln3100">///         string.</a>
<a name="ln3101">const char *tv_get_string(const typval_T *const tv)</a>
<a name="ln3102">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3103">{</a>
<a name="ln3104">  static char mybuf[NUMBUFLEN];</a>
<a name="ln3105">  return tv_get_string_buf((typval_T *)tv, mybuf);</a>
<a name="ln3106">}</a>
<a name="ln3107"> </a>
<a name="ln3108">/// Get the string value of a &quot;stringish&quot; VimL object.</a>
<a name="ln3109">///</a>
<a name="ln3110">/// @note tv_get_string_chk() and tv_get_string_buf_chk() are similar, but</a>
<a name="ln3111">///       return NULL on error.</a>
<a name="ln3112">///</a>
<a name="ln3113">/// @param[in]  tv  Object to get value of.</a>
<a name="ln3114">/// @param  buf  Buffer used to hold numbers and special variables converted to</a>
<a name="ln3115">///              string. When function encounters one of these stringified value</a>
<a name="ln3116">///              will be written to buf and buf will be returned.</a>
<a name="ln3117">///</a>
<a name="ln3118">///              Buffer must have NUMBUFLEN size.</a>
<a name="ln3119">///</a>
<a name="ln3120">/// @return Object value if it is VAR_STRING object, number converted to</a>
<a name="ln3121">///         a string for VAR_NUMBER, v: variable name for VAR_SPECIAL or empty</a>
<a name="ln3122">///         string.</a>
<a name="ln3123">const char *tv_get_string_buf(const typval_T *const tv, char *const buf)</a>
<a name="ln3124">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3125">{</a>
<a name="ln3126">  const char *const res = (const char *)tv_get_string_buf_chk(tv, buf);</a>
<a name="ln3127"> </a>
<a name="ln3128">  return res != NULL ? res : &quot;&quot;;</a>
<a name="ln3129">}</a>

</code></pre>
<div class="balloon" rel="2712"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
