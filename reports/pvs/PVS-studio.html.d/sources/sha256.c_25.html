
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>sha256.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">/// @file sha256.c</a>
<a name="ln5">///</a>
<a name="ln6">/// FIPS-180-2 compliant SHA-256 implementation</a>
<a name="ln7">/// GPL by Christophe Devine, applies to older version.</a>
<a name="ln8">/// Modified for md5deep, in public domain.</a>
<a name="ln9">/// Modified For Vim, Mohsin Ahmed, http://www.cs.albany.edu/~mosh</a>
<a name="ln10">/// Mohsin Ahmed states this work is distributed under the VIM License or GPL,</a>
<a name="ln11">/// at your choice.</a>
<a name="ln12">///</a>
<a name="ln13">/// Vim specific notes:</a>
<a name="ln14">/// sha256_self_test() is implicitly called once.</a>
<a name="ln15"> </a>
<a name="ln16">#include &lt;stddef.h&gt;        // for size_t</a>
<a name="ln17">#include &lt;stdio.h&gt;         // for snprintf().</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;nvim/sha256.h&quot;   // for context_sha256_T</a>
<a name="ln20">#include &quot;nvim/vim.h&quot;      // for STRCPY()/STRLEN().</a>
<a name="ln21"> </a>
<a name="ln22">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln23"># include &quot;sha256.c.generated.h&quot;</a>
<a name="ln24">#endif</a>
<a name="ln25">#define GET_UINT32(n, b, i) { \</a>
<a name="ln26">  (n) = ((uint32_t)(b)[(i)] &lt;&lt; 24) \</a>
<a name="ln27">        | ((uint32_t)(b)[(i) + 1] &lt;&lt; 16) \</a>
<a name="ln28">        | ((uint32_t)(b)[(i) + 2] &lt;&lt;  8) \</a>
<a name="ln29">        | ((uint32_t)(b)[(i) + 3]); \</a>
<a name="ln30">}</a>
<a name="ln31"> </a>
<a name="ln32">#define PUT_UINT32(n, b, i) { \</a>
<a name="ln33">  (b)[(i)] = (char_u)((n) &gt;&gt; 24); \</a>
<a name="ln34">  (b)[(i) + 1] = (char_u)((n) &gt;&gt; 16); \</a>
<a name="ln35">  (b)[(i) + 2] = (char_u)((n) &gt;&gt;  8); \</a>
<a name="ln36">  (b)[(i) + 3] = (char_u)((n)); \</a>
<a name="ln37">}</a>
<a name="ln38"> </a>
<a name="ln39">void sha256_start(context_sha256_T *ctx)</a>
<a name="ln40">{</a>
<a name="ln41">  ctx-&gt;total[0] = 0;</a>
<a name="ln42">  ctx-&gt;total[1] = 0;</a>
<a name="ln43"> </a>
<a name="ln44">  ctx-&gt;state[0] = 0x6A09E667;</a>
<a name="ln45">  ctx-&gt;state[1] = 0xBB67AE85;</a>
<a name="ln46">  ctx-&gt;state[2] = 0x3C6EF372;</a>
<a name="ln47">  ctx-&gt;state[3] = 0xA54FF53A;</a>
<a name="ln48">  ctx-&gt;state[4] = 0x510E527F;</a>
<a name="ln49">  ctx-&gt;state[5] = 0x9B05688C;</a>
<a name="ln50">  ctx-&gt;state[6] = 0x1F83D9AB;</a>
<a name="ln51">  ctx-&gt;state[7] = 0x5BE0CD19;</a>
<a name="ln52">}</a>
<a name="ln53"> </a>
<a name="ln54">static void sha256_process(context_sha256_T *ctx,</a>
<a name="ln55">                           const char_u data[SHA256_BUFFER_SIZE])</a>
<a name="ln56">{</a>
<a name="ln57">  uint32_t temp1, temp2, W[SHA256_BUFFER_SIZE];</a>
<a name="ln58">  uint32_t A, B, C, D, E, F, G, H;</a>
<a name="ln59"> </a>
<a name="ln60">  GET_UINT32(W[0],  data,  0);</a>
<a name="ln61">  GET_UINT32(W[1],  data,  4);</a>
<a name="ln62">  GET_UINT32(W[2],  data,  8);</a>
<a name="ln63">  GET_UINT32(W[3],  data, 12);</a>
<a name="ln64">  GET_UINT32(W[4],  data, 16);</a>
<a name="ln65">  GET_UINT32(W[5],  data, 20);</a>
<a name="ln66">  GET_UINT32(W[6],  data, 24);</a>
<a name="ln67">  GET_UINT32(W[7],  data, 28);</a>
<a name="ln68">  GET_UINT32(W[8],  data, 32);</a>
<a name="ln69">  GET_UINT32(W[9],  data, 36);</a>
<a name="ln70">  GET_UINT32(W[10], data, 40);</a>
<a name="ln71">  GET_UINT32(W[11], data, 44);</a>
<a name="ln72">  GET_UINT32(W[12], data, 48);</a>
<a name="ln73">  GET_UINT32(W[13], data, 52);</a>
<a name="ln74">  GET_UINT32(W[14], data, 56);</a>
<a name="ln75">  GET_UINT32(W[15], data, 60);</a>
<a name="ln76"> </a>
<a name="ln77">#define  SHR(x, n) ((x &amp; 0xFFFFFFFF) &gt;&gt; n)</a>
<a name="ln78">#define ROTR(x, n) (SHR(x, n) | (x &lt;&lt; (32 - n)))</a>
<a name="ln79"> </a>
<a name="ln80">#define S0(x) (ROTR(x, 7) ^ ROTR(x, 18) ^  SHR(x, 3))</a>
<a name="ln81">#define S1(x) (ROTR(x, 17) ^ ROTR(x, 19) ^  SHR(x, 10))</a>
<a name="ln82"> </a>
<a name="ln83">#define S2(x) (ROTR(x, 2) ^ ROTR(x, 13) ^ ROTR(x, 22))</a>
<a name="ln84">#define S3(x) (ROTR(x, 6) ^ ROTR(x, 11) ^ ROTR(x, 25))</a>
<a name="ln85"> </a>
<a name="ln86">#define F0(x, y, z) ((x &amp; y) | (z &amp; (x | y)))</a>
<a name="ln87">#define F1(x, y, z) (z ^ (x &amp; (y ^ z)))</a>
<a name="ln88"> </a>
<a name="ln89">#define R(t) \</a>
<a name="ln90">  (W[t] = S1(W[t -  2]) + W[t -  7] + \</a>
<a name="ln91">           S0(W[t - 15]) + W[t - 16])</a>
<a name="ln92"> </a>
<a name="ln93">#define P(a, b, c, d, e, f, g, h, x, K) { \</a>
<a name="ln94">  temp1 = h + S3(e) + F1(e, f, g) + K + x; \</a>
<a name="ln95">  temp2 = S2(a) + F0(a, b, c); \</a>
<a name="ln96">  d += temp1; h = temp1 + temp2; \</a>
<a name="ln97">}</a>
<a name="ln98"> </a>
<a name="ln99">  A = ctx-&gt;state[0];</a>
<a name="ln100">  B = ctx-&gt;state[1];</a>
<a name="ln101">  C = ctx-&gt;state[2];</a>
<a name="ln102">  D = ctx-&gt;state[3];</a>
<a name="ln103">  E = ctx-&gt;state[4];</a>
<a name="ln104">  F = ctx-&gt;state[5];</a>
<a name="ln105">  G = ctx-&gt;state[6];</a>
<a name="ln106">  H = ctx-&gt;state[7];</a>
<a name="ln107"> </a>
<a name="ln108">  P(A, B, C, D, E, F, G, H, W[0],  0x428A2F98);</a>
<a name="ln109">  P(H, A, B, C, D, E, F, G, W[1],  0x71374491);</a>
<a name="ln110">  P(G, H, A, B, C, D, E, F, W[2],  0xB5C0FBCF);</a>
<a name="ln111">  P(F, G, H, A, B, C, D, E, W[3],  0xE9B5DBA5);</a>
<a name="ln112">  P(E, F, G, H, A, B, C, D, W[4],  0x3956C25B);</a>
<a name="ln113">  P(D, E, F, G, H, A, B, C, W[5],  0x59F111F1);</a>
<a name="ln114">  P(C, D, E, F, G, H, A, B, W[6],  0x923F82A4);</a>
<a name="ln115">  P(B, C, D, E, F, G, H, A, W[7],  0xAB1C5ED5);</a>
<a name="ln116">  P(A, B, C, D, E, F, G, H, W[8],  0xD807AA98);</a>
<a name="ln117">  P(H, A, B, C, D, E, F, G, W[9],  0x12835B01);</a>
<a name="ln118">  P(G, H, A, B, C, D, E, F, W[10], 0x243185BE);</a>
<a name="ln119">  P(F, G, H, A, B, C, D, E, W[11], 0x550C7DC3);</a>
<a name="ln120">  P(E, F, G, H, A, B, C, D, W[12], 0x72BE5D74);</a>
<a name="ln121">  P(D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE);</a>
<a name="ln122">  P(C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7);</a>
<a name="ln123">  P(B, C, D, E, F, G, H, A, W[15], 0xC19BF174);</a>
<a name="ln124">  P(A, B, C, D, E, F, G, H, R(16), 0xE49B69C1);</a>
<a name="ln125">  P(H, A, B, C, D, E, F, G, R(17), 0xEFBE4786);</a>
<a name="ln126">  P(G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6);</a>
<a name="ln127">  P(F, G, H, A, B, C, D, E, R(19), 0x240CA1CC);</a>
<a name="ln128">  P(E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F);</a>
<a name="ln129">  P(D, E, F, G, H, A, B, C, R(21), 0x4A7484AA);</a>
<a name="ln130">  P(C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC);</a>
<a name="ln131">  P(B, C, D, E, F, G, H, A, R(23), 0x76F988DA);</a>
<a name="ln132">  P(A, B, C, D, E, F, G, H, R(24), 0x983E5152);</a>
<a name="ln133">  P(H, A, B, C, D, E, F, G, R(25), 0xA831C66D);</a>
<a name="ln134">  P(G, H, A, B, C, D, E, F, R(26), 0xB00327C8);</a>
<a name="ln135">  P(F, G, H, A, B, C, D, E, R(27), 0xBF597FC7);</a>
<a name="ln136">  P(E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3);</a>
<a name="ln137">  P(D, E, F, G, H, A, B, C, R(29), 0xD5A79147);</a>
<a name="ln138">  P(C, D, E, F, G, H, A, B, R(30), 0x06CA6351);</a>
<a name="ln139">  P(B, C, D, E, F, G, H, A, R(31), 0x14292967);</a>
<a name="ln140">  P(A, B, C, D, E, F, G, H, R(32), 0x27B70A85);</a>
<a name="ln141">  P(H, A, B, C, D, E, F, G, R(33), 0x2E1B2138);</a>
<a name="ln142">  P(G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC);</a>
<a name="ln143">  P(F, G, H, A, B, C, D, E, R(35), 0x53380D13);</a>
<a name="ln144">  P(E, F, G, H, A, B, C, D, R(36), 0x650A7354);</a>
<a name="ln145">  P(D, E, F, G, H, A, B, C, R(37), 0x766A0ABB);</a>
<a name="ln146">  P(C, D, E, F, G, H, A, B, R(38), 0x81C2C92E);</a>
<a name="ln147">  P(B, C, D, E, F, G, H, A, R(39), 0x92722C85);</a>
<a name="ln148">  P(A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1);</a>
<a name="ln149">  P(H, A, B, C, D, E, F, G, R(41), 0xA81A664B);</a>
<a name="ln150">  P(G, H, A, B, C, D, E, F, R(42), 0xC24B8B70);</a>
<a name="ln151">  P(F, G, H, A, B, C, D, E, R(43), 0xC76C51A3);</a>
<a name="ln152">  P(E, F, G, H, A, B, C, D, R(44), 0xD192E819);</a>
<a name="ln153">  P(D, E, F, G, H, A, B, C, R(45), 0xD6990624);</a>
<a name="ln154">  P(C, D, E, F, G, H, A, B, R(46), 0xF40E3585);</a>
<a name="ln155">  P(B, C, D, E, F, G, H, A, R(47), 0x106AA070);</a>
<a name="ln156">  P(A, B, C, D, E, F, G, H, R(48), 0x19A4C116);</a>
<a name="ln157">  P(H, A, B, C, D, E, F, G, R(49), 0x1E376C08);</a>
<a name="ln158">  P(G, H, A, B, C, D, E, F, R(50), 0x2748774C);</a>
<a name="ln159">  P(F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5);</a>
<a name="ln160">  P(E, F, G, H, A, B, C, D, R(52), 0x391C0CB3);</a>
<a name="ln161">  P(D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A);</a>
<a name="ln162">  P(C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F);</a>
<a name="ln163">  P(B, C, D, E, F, G, H, A, R(55), 0x682E6FF3);</a>
<a name="ln164">  P(A, B, C, D, E, F, G, H, R(56), 0x748F82EE);</a>
<a name="ln165">  P(H, A, B, C, D, E, F, G, R(57), 0x78A5636F);</a>
<a name="ln166">  P(G, H, A, B, C, D, E, F, R(58), 0x84C87814);</a>
<a name="ln167">  P(F, G, H, A, B, C, D, E, R(59), 0x8CC70208);</a>
<a name="ln168">  P(E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA);</a>
<a name="ln169">  P(D, E, F, G, H, A, B, C, R(61), 0xA4506CEB);</a>
<a name="ln170">  P(C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7);</a>
<a name="ln171">  P(B, C, D, E, F, G, H, A, R(63), 0xC67178F2);</a>
<a name="ln172"> </a>
<a name="ln173">  ctx-&gt;state[0] += A;</a>
<a name="ln174">  ctx-&gt;state[1] += B;</a>
<a name="ln175">  ctx-&gt;state[2] += C;</a>
<a name="ln176">  ctx-&gt;state[3] += D;</a>
<a name="ln177">  ctx-&gt;state[4] += E;</a>
<a name="ln178">  ctx-&gt;state[5] += F;</a>
<a name="ln179">  ctx-&gt;state[6] += G;</a>
<a name="ln180">  ctx-&gt;state[7] += H;</a>
<a name="ln181">}</a>
<a name="ln182"> </a>
<a name="ln183">void sha256_update(context_sha256_T *ctx, const char_u *input, size_t length)</a>
<a name="ln184">{</a>
<a name="ln185">  if (length == 0) {</a>
<a name="ln186">    return;</a>
<a name="ln187">  }</a>
<a name="ln188"> </a>
<a name="ln189">  uint32_t left = ctx-&gt;total[0] &amp; (SHA256_BUFFER_SIZE-1);  // left &lt; buf size</a>
<a name="ln190"> </a>
<a name="ln191">  ctx-&gt;total[0] += (uint32_t) length;</a>
<a name="ln192">  ctx-&gt;total[0] &amp;= 0xFFFFFFFF;</a>
<a name="ln193"> </a>
<a name="ln194">  if (ctx-&gt;total[0] &lt; length) {</a>
<a name="ln195">    ctx-&gt;total[1]++;</a>
<a name="ln196">  }</a>
<a name="ln197"> </a>
<a name="ln198">  size_t fill = SHA256_BUFFER_SIZE - left;</a>
<a name="ln199"> </a>
<a name="ln200">  if (left &amp;&amp; (length &gt;= fill)) {</a>
<a name="ln201">    memcpy((void *)(ctx-&gt;buffer + left), (void *)input, fill);</a>
<a name="ln202">    sha256_process(ctx, ctx-&gt;buffer);</a>
<a name="ln203">    length -= fill;</a>
<a name="ln204">    input  += fill;</a>
<a name="ln205">    left = 0;</a>
<a name="ln206">  }</a>
<a name="ln207"> </a>
<a name="ln208">  while (length &gt;= SHA256_BUFFER_SIZE) {</a>
<a name="ln209">    sha256_process(ctx, input);</a>
<a name="ln210">    length -= SHA256_BUFFER_SIZE;</a>
<a name="ln211">    input  += SHA256_BUFFER_SIZE;</a>
<a name="ln212">  }</a>
<a name="ln213"> </a>
<a name="ln214">  if (length) {</a>
<a name="ln215">    memcpy((void *)(ctx-&gt;buffer + left), (void *)input, length);</a>
<a name="ln216">  }</a>
<a name="ln217">}</a>
<a name="ln218"> </a>
<a name="ln219">static char_u sha256_padding[SHA256_BUFFER_SIZE] = {</a>
<a name="ln220">  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</a>
<a name="ln221">  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</a>
<a name="ln222">  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</a>
<a name="ln223">  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</a>
<a name="ln224">};</a>
<a name="ln225"> </a>
<a name="ln226">void sha256_finish(context_sha256_T *ctx, char_u digest[SHA256_SUM_SIZE])</a>
<a name="ln227">{</a>
<a name="ln228">  uint32_t last, padn;</a>
<a name="ln229">  uint32_t high, low;</a>
<a name="ln230">  char_u msglen[8];</a>
<a name="ln231"> </a>
<a name="ln232">  high = (ctx-&gt;total[0] &gt;&gt; 29) | (ctx-&gt;total[1] &lt;&lt;  3);</a>
<a name="ln233">  low  = (ctx-&gt;total[0] &lt;&lt;  3);</a>
<a name="ln234"> </a>
<a name="ln235">  PUT_UINT32(high, msglen, 0);</a>
<a name="ln236">  PUT_UINT32(low,  msglen, 4);</a>
<a name="ln237"> </a>
<a name="ln238">  last = ctx-&gt;total[0] &amp; 0x3F;</a>
<a name="ln239">  padn = (last &lt; 56) ? (56 - last) : (120 - last);</a>
<a name="ln240"> </a>
<a name="ln241">  sha256_update(ctx, sha256_padding, padn);</a>
<a name="ln242">  sha256_update(ctx, msglen,            8);</a>
<a name="ln243"> </a>
<a name="ln244">  PUT_UINT32(ctx-&gt;state[0], digest,  0);</a>
<a name="ln245">  PUT_UINT32(ctx-&gt;state[1], digest,  4);</a>
<a name="ln246">  PUT_UINT32(ctx-&gt;state[2], digest,  8);</a>
<a name="ln247">  PUT_UINT32(ctx-&gt;state[3], digest, 12);</a>
<a name="ln248">  PUT_UINT32(ctx-&gt;state[4], digest, 16);</a>
<a name="ln249">  PUT_UINT32(ctx-&gt;state[5], digest, 20);</a>
<a name="ln250">  PUT_UINT32(ctx-&gt;state[6], digest, 24);</a>
<a name="ln251">  PUT_UINT32(ctx-&gt;state[7], digest, 28);</a>
<a name="ln252">}</a>
<a name="ln253"> </a>
<a name="ln254">#define SHA_STEP 2</a>
<a name="ln255"> </a>
<a name="ln256">/// Gets the hex digest of the buffer.</a>
<a name="ln257">///</a>
<a name="ln258">/// @param buf</a>
<a name="ln259">/// @param buf_len</a>
<a name="ln260">/// @param salt</a>
<a name="ln261">/// @param salt_len</a>
<a name="ln262">///</a>
<a name="ln263">/// @returns hex digest of &quot;buf[buf_len]&quot; in a static array.</a>
<a name="ln264">///          if &quot;salt&quot; is not NULL also do &quot;salt[salt_len]&quot;.</a>
<a name="ln265">const char *sha256_bytes(const uint8_t *restrict buf,  size_t buf_len,</a>
<a name="ln266">                         const uint8_t *restrict salt, size_t salt_len)</a>
<a name="ln267">{</a>
<a name="ln268">  char_u sha256sum[SHA256_SUM_SIZE];</a>
<a name="ln269">  static char hexit[SHA256_BUFFER_SIZE + 1];  // buf size + NULL</a>
<a name="ln270">  context_sha256_T ctx;</a>
<a name="ln271"> </a>
<a name="ln272">  sha256_self_test();</a>
<a name="ln273"> </a>
<a name="ln274">  sha256_start(&amp;ctx);</a>
<a name="ln275">  sha256_update(&amp;ctx, buf, buf_len);</a>
<a name="ln276"> </a>
<a name="ln277">  if (salt != NULL) {</a>
<a name="ln278">    sha256_update(&amp;ctx, salt, salt_len);</a>
<a name="ln279">  }</a>
<a name="ln280">  sha256_finish(&amp;ctx, sha256sum);</a>
<a name="ln281"> </a>
<a name="ln282">  for (size_t j = 0; j &lt; SHA256_SUM_SIZE; j++) {</a>
<a name="ln283">    snprintf(hexit + j * SHA_STEP, SHA_STEP + 1, &quot;%02x&quot;, sha256sum[j]);</a>
<a name="ln284">  }</a>
<a name="ln285">  hexit[sizeof(hexit) - 1] = '\0';</a>
<a name="ln286">  return hexit;</a>
<a name="ln287">}</a>
<a name="ln288"> </a>
<a name="ln289">// These are the standard FIPS-180-2 test vectors</a>
<a name="ln290">static char *sha_self_test_msg[] = {</a>
<a name="ln291">  &quot;abc&quot;,</a>
<a name="ln292">  &quot;abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq&quot;,</a>
<a name="ln293">  NULL</a>
<a name="ln294">};</a>
<a name="ln295"> </a>
<a name="ln296">static char *sha_self_test_vector[] = {</a>
<a name="ln297">  &quot;ba7816bf8f01cfea414140de5dae2223&quot; \</a>
<a name="ln298">  &quot;b00361a396177a9cb410ff61f20015ad&quot;,</a>
<a name="ln299">  &quot;248d6a61d20638b8e5c026930c3e6039&quot; \</a>
<a name="ln300">  &quot;a33ce45964ff2167f6ecedd419db06c1&quot;,</a>
<a name="ln301">  &quot;cdc76e5c9914fb9281a1c7e284d73e67&quot; \</a>
<a name="ln302">  &quot;f1809a48a497200e046d39ccc7112cd0&quot;</a>
<a name="ln303">};</a>
<a name="ln304"> </a>
<a name="ln305">/// Perform a test on the SHA256 algorithm.</a>
<a name="ln306">///</a>
<a name="ln307">/// @returns true if not failures generated.</a>
<a name="ln308">bool sha256_self_test(void)</a>
<a name="ln309">{</a>
<a name="ln310">  char output[SHA256_BUFFER_SIZE + 1];  // buf size + NULL</a>
<a name="ln311">  context_sha256_T ctx;</a>
<a name="ln312">  char_u buf[1000];</a>
<a name="ln313">  char_u sha256sum[SHA256_SUM_SIZE];</a>
<a name="ln314">  const char *hexit;</a>
<a name="ln315"> </a>
<a name="ln316">  static bool sha256_self_tested = false;</a>
<a name="ln317">  static bool failures = false;</a>
<a name="ln318"> </a>
<a name="ln319">  if (sha256_self_tested) {</a>
<a name="ln320">    return failures == false;</a>
<a name="ln321">  }</a>
<a name="ln322">  sha256_self_tested = true;</a>
<a name="ln323"> </a>
<a name="ln324">  for (size_t i = 0; i &lt; 3; i++) {</a>
<a name="ln325">    if (i &lt; 2) {</a>
<a name="ln326">      hexit = sha256_bytes((uint8_t *)sha_self_test_msg[i],</a>
<a name="ln327">                           strlen(sha_self_test_msg[i]),</a>
<a name="ln328">                           NULL, 0);</a>
<a name="ln329">      STRCPY(output, hexit);</a>
<a name="ln330">    } else {</a>
<a name="ln331">      sha256_start(&amp;ctx);</a>
<a name="ln332">      memset(buf, 'a', 1000);</a>
<a name="ln333"> </a>
<a name="ln334">      for (size_t j = 0; j &lt; 1000; j++) {</a>
<a name="ln335">        sha256_update(&amp;ctx, buf, 1000);</a>
<a name="ln336">      }</a>
<a name="ln337">      sha256_finish(&amp;ctx, sha256sum);</a>
<a name="ln338"> </a>
<a name="ln339">      for (size_t j = 0; j &lt; SHA256_SUM_SIZE; j++) {</a>
<a name="ln340">        snprintf(output + j * SHA_STEP, SHA_STEP+1, &quot;%02x&quot;, sha256sum[j]);</a>
<a name="ln341">      }</a>
<a name="ln342">    }</a>
<a name="ln343"> </a>
<a name="ln344">    if (memcmp(output, sha_self_test_vector[i], SHA256_BUFFER_SIZE)) {</a>
<a name="ln345">      failures = true;</a>
<a name="ln346">      output[sizeof(output) - 1] = '\0';</a>
<a name="ln347"> </a>
<a name="ln348">      // printf(&quot;sha256_self_test %d failed %s\n&quot;, i, output);</a>
<a name="ln349">    }</a>
<a name="ln350">  }</a>
<a name="ln351">  return failures == false;</a>
<a name="ln352">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
