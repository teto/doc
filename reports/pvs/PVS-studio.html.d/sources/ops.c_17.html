
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ops.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">/*</a>
<a name="ln5"> * ops.c: implementation of various operators: op_shift, op_delete, op_tilde,</a>
<a name="ln6"> *        op_change, op_yank, do_put, do_join</a>
<a name="ln7"> */</a>
<a name="ln8"> </a>
<a name="ln9">#include &lt;assert.h&gt;</a>
<a name="ln10">#include &lt;inttypes.h&gt;</a>
<a name="ln11">#include &lt;stdbool.h&gt;</a>
<a name="ln12">#include &lt;string.h&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;nvim/vim.h&quot;</a>
<a name="ln15">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln16">#include &quot;nvim/ops.h&quot;</a>
<a name="ln17">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln18">#include &quot;nvim/change.h&quot;</a>
<a name="ln19">#include &quot;nvim/charset.h&quot;</a>
<a name="ln20">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln21">#include &quot;nvim/assert.h&quot;</a>
<a name="ln22">#include &quot;nvim/edit.h&quot;</a>
<a name="ln23">#include &quot;nvim/eval.h&quot;</a>
<a name="ln24">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln25">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln26">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln27">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln28">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln29">#include &quot;nvim/fold.h&quot;</a>
<a name="ln30">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln31">#include &quot;nvim/indent.h&quot;</a>
<a name="ln32">#include &quot;nvim/log.h&quot;</a>
<a name="ln33">#include &quot;nvim/mark.h&quot;</a>
<a name="ln34">#include &quot;nvim/extmark.h&quot;</a>
<a name="ln35">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln36">#include &quot;nvim/memline.h&quot;</a>
<a name="ln37">#include &quot;nvim/memory.h&quot;</a>
<a name="ln38">#include &quot;nvim/message.h&quot;</a>
<a name="ln39">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln40">#include &quot;nvim/move.h&quot;</a>
<a name="ln41">#include &quot;nvim/normal.h&quot;</a>
<a name="ln42">#include &quot;nvim/option.h&quot;</a>
<a name="ln43">#include &quot;nvim/path.h&quot;</a>
<a name="ln44">#include &quot;nvim/screen.h&quot;</a>
<a name="ln45">#include &quot;nvim/search.h&quot;</a>
<a name="ln46">#include &quot;nvim/state.h&quot;</a>
<a name="ln47">#include &quot;nvim/strings.h&quot;</a>
<a name="ln48">#include &quot;nvim/terminal.h&quot;</a>
<a name="ln49">#include &quot;nvim/ui.h&quot;</a>
<a name="ln50">#include &quot;nvim/undo.h&quot;</a>
<a name="ln51">#include &quot;nvim/macros.h&quot;</a>
<a name="ln52">#include &quot;nvim/window.h&quot;</a>
<a name="ln53">#include &quot;nvim/lib/kvec.h&quot;</a>
<a name="ln54">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln55">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln56"> </a>
<a name="ln57">static yankreg_T y_regs[NUM_REGISTERS];</a>
<a name="ln58"> </a>
<a name="ln59">static yankreg_T *y_previous = NULL; /* ptr to last written yankreg */</a>
<a name="ln60"> </a>
<a name="ln61">// for behavior between start_batch_changes() and end_batch_changes())</a>
<a name="ln62">static int batch_change_count = 0;           // inside a script</a>
<a name="ln63">static bool clipboard_delay_update = false;  // delay clipboard update</a>
<a name="ln64">static bool clipboard_needs_update = false;  // clipboard was updated</a>
<a name="ln65">static bool clipboard_didwarn = false;</a>
<a name="ln66"> </a>
<a name="ln67">/*</a>
<a name="ln68"> * structure used by block_prep, op_delete and op_yank for blockwise operators</a>
<a name="ln69"> * also op_change, op_shift, op_insert, op_replace - AKelly</a>
<a name="ln70"> */</a>
<a name="ln71">struct block_def {</a>
<a name="ln72">  int startspaces;              /* 'extra' cols before first char */</a>
<a name="ln73">  int endspaces;                /* 'extra' cols after last char */</a>
<a name="ln74">  int textlen;                  /* chars in block */</a>
<a name="ln75">  char_u      *textstart;       /* pointer to 1st char (partially) in block */</a>
<a name="ln76">  colnr_T textcol;              /* index of chars (partially) in block */</a>
<a name="ln77">  colnr_T start_vcol;           /* start col of 1st char wholly inside block */</a>
<a name="ln78">  colnr_T end_vcol;             /* start col of 1st char wholly after block */</a>
<a name="ln79">  int is_short;                 /* TRUE if line is too short to fit in block */</a>
<a name="ln80">  int is_MAX;                   /* TRUE if curswant==MAXCOL when starting */</a>
<a name="ln81">  int is_oneChar;               /* TRUE if block within one character */</a>
<a name="ln82">  int pre_whitesp;              /* screen cols of ws before block */</a>
<a name="ln83">  int pre_whitesp_c;            /* chars of ws before block */</a>
<a name="ln84">  colnr_T end_char_vcols;       /* number of vcols of post-block char */</a>
<a name="ln85">  colnr_T start_char_vcols;       /* number of vcols of pre-block char */</a>
<a name="ln86">};</a>
<a name="ln87"> </a>
<a name="ln88">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln89"># include &quot;ops.c.generated.h&quot;</a>
<a name="ln90">#endif</a>
<a name="ln91"> </a>
<a name="ln92">// Flags for third item in &quot;opchars&quot;.</a>
<a name="ln93">#define OPF_LINES  1  // operator always works on lines</a>
<a name="ln94">#define OPF_CHANGE 2  // operator changes text</a>
<a name="ln95"> </a>
<a name="ln96">/*</a>
<a name="ln97"> * The names of operators.</a>
<a name="ln98"> * IMPORTANT: Index must correspond with defines in vim.h!!!</a>
<a name="ln99"> * The third field indicates whether the operator always works on lines.</a>
<a name="ln100"> */</a>
<a name="ln101">static char opchars[][3] =</a>
<a name="ln102">{</a>
<a name="ln103">  { NUL, NUL, 0 },                       // OP_NOP</a>
<a name="ln104">  { 'd', NUL, OPF_CHANGE },              // OP_DELETE</a>
<a name="ln105">  { 'y', NUL, 0 },                       // OP_YANK</a>
<a name="ln106">  { 'c', NUL, OPF_CHANGE },              // OP_CHANGE</a>
<a name="ln107">  { '&lt;', NUL, OPF_LINES | OPF_CHANGE },  // OP_LSHIFT</a>
<a name="ln108">  { '&gt;', NUL, OPF_LINES | OPF_CHANGE },  // OP_RSHIFT</a>
<a name="ln109">  { '!', NUL, OPF_LINES | OPF_CHANGE },  // OP_FILTER</a>
<a name="ln110">  { 'g', '~', OPF_CHANGE },              // OP_TILDE</a>
<a name="ln111">  { '=', NUL, OPF_LINES | OPF_CHANGE },  // OP_INDENT</a>
<a name="ln112">  { 'g', 'q', OPF_LINES | OPF_CHANGE },  // OP_FORMAT</a>
<a name="ln113">  { ':', NUL, OPF_LINES },               // OP_COLON</a>
<a name="ln114">  { 'g', 'U', OPF_CHANGE },              // OP_UPPER</a>
<a name="ln115">  { 'g', 'u', OPF_CHANGE },              // OP_LOWER</a>
<a name="ln116">  { 'J', NUL, OPF_LINES | OPF_CHANGE },  // DO_JOIN</a>
<a name="ln117">  { 'g', 'J', OPF_LINES | OPF_CHANGE },  // DO_JOIN_NS</a>
<a name="ln118">  { 'g', '?', OPF_CHANGE },              // OP_ROT13</a>
<a name="ln119">  { 'r', NUL, OPF_CHANGE },              // OP_REPLACE</a>
<a name="ln120">  { 'I', NUL, OPF_CHANGE },              // OP_INSERT</a>
<a name="ln121">  { 'A', NUL, OPF_CHANGE },              // OP_APPEND</a>
<a name="ln122">  { 'z', 'f', 0         },               // OP_FOLD</a>
<a name="ln123">  { 'z', 'o', OPF_LINES },               // OP_FOLDOPEN</a>
<a name="ln124">  { 'z', 'O', OPF_LINES },               // OP_FOLDOPENREC</a>
<a name="ln125">  { 'z', 'c', OPF_LINES },               // OP_FOLDCLOSE</a>
<a name="ln126">  { 'z', 'C', OPF_LINES },               // OP_FOLDCLOSEREC</a>
<a name="ln127">  { 'z', 'd', OPF_LINES },               // OP_FOLDDEL</a>
<a name="ln128">  { 'z', 'D', OPF_LINES },               // OP_FOLDDELREC</a>
<a name="ln129">  { 'g', 'w', OPF_LINES | OPF_CHANGE },  // OP_FORMAT2</a>
<a name="ln130">  { 'g', '@', OPF_CHANGE },              // OP_FUNCTION</a>
<a name="ln131">  { Ctrl_A, NUL, OPF_CHANGE },           // OP_NR_ADD</a>
<a name="ln132">  { Ctrl_X, NUL, OPF_CHANGE },           // OP_NR_SUB</a>
<a name="ln133">};</a>
<a name="ln134"> </a>
<a name="ln135">/*</a>
<a name="ln136"> * Translate a command name into an operator type.</a>
<a name="ln137"> * Must only be called with a valid operator name!</a>
<a name="ln138"> */</a>
<a name="ln139">int get_op_type(int char1, int char2)</a>
<a name="ln140">{</a>
<a name="ln141">  int i;</a>
<a name="ln142"> </a>
<a name="ln143">  if (char1 == 'r') {</a>
<a name="ln144">    // ignore second character</a>
<a name="ln145">    return OP_REPLACE;</a>
<a name="ln146">  }</a>
<a name="ln147">  if (char1 == '~') {</a>
<a name="ln148">    // when tilde is an operator</a>
<a name="ln149">    return OP_TILDE;</a>
<a name="ln150">  }</a>
<a name="ln151">  if (char1 == 'g' &amp;&amp; char2 == Ctrl_A) {</a>
<a name="ln152">    // add</a>
<a name="ln153">    return OP_NR_ADD;</a>
<a name="ln154">  }</a>
<a name="ln155">  if (char1 == 'g' &amp;&amp; char2 == Ctrl_X) {</a>
<a name="ln156">    // subtract</a>
<a name="ln157">    return OP_NR_SUB;</a>
<a name="ln158">  }</a>
<a name="ln159">  for (i = 0;; i++) {</a>
<a name="ln160">    if (opchars[i][0] == char1 &amp;&amp; opchars[i][1] == char2) {</a>
<a name="ln161">      break;</a>
<a name="ln162">    }</a>
<a name="ln163">    if (i == (int)(ARRAY_SIZE(opchars) - 1)) {</a>
<a name="ln164">      internal_error(&quot;get_op_type()&quot;);</a>
<a name="ln165">      break;</a>
<a name="ln166">    }</a>
<a name="ln167">  }</a>
<a name="ln168">  return i;</a>
<a name="ln169">}</a>
<a name="ln170"> </a>
<a name="ln171">/*</a>
<a name="ln172"> * Return TRUE if operator &quot;op&quot; always works on whole lines.</a>
<a name="ln173"> */</a>
<a name="ln174">int op_on_lines(int op)</a>
<a name="ln175">{</a>
<a name="ln176">  return opchars[op][2] &amp; OPF_LINES;</a>
<a name="ln177">}</a>
<a name="ln178"> </a>
<a name="ln179">// Return TRUE if operator &quot;op&quot; changes text.</a>
<a name="ln180">int op_is_change(int op)</a>
<a name="ln181">{</a>
<a name="ln182">    return opchars[op][2] &amp; OPF_CHANGE;</a>
<a name="ln183">}</a>
<a name="ln184"> </a>
<a name="ln185">/*</a>
<a name="ln186"> * Get first operator command character.</a>
<a name="ln187"> * Returns 'g' or 'z' if there is another command character.</a>
<a name="ln188"> */</a>
<a name="ln189">int get_op_char(int optype)</a>
<a name="ln190">{</a>
<a name="ln191">  return opchars[optype][0];</a>
<a name="ln192">}</a>
<a name="ln193"> </a>
<a name="ln194">/*</a>
<a name="ln195"> * Get second operator command character.</a>
<a name="ln196"> */</a>
<a name="ln197">int get_extra_op_char(int optype)</a>
<a name="ln198">{</a>
<a name="ln199">  return opchars[optype][1];</a>
<a name="ln200">}</a>
<a name="ln201"> </a>
<a name="ln202">/*</a>
<a name="ln203"> * op_shift - handle a shift operation</a>
<a name="ln204"> */</a>
<a name="ln205">void op_shift(oparg_T *oap, int curs_top, int amount)</a>
<a name="ln206">{</a>
<a name="ln207">  long i;</a>
<a name="ln208">  int first_char;</a>
<a name="ln209">  char_u          *s;</a>
<a name="ln210">  int block_col = 0;</a>
<a name="ln211"> </a>
<a name="ln212">  if (u_save((linenr_T)(oap-&gt;start.lnum - 1),</a>
<a name="ln213">          (linenr_T)(oap-&gt;end.lnum + 1)) == FAIL)</a>
<a name="ln214">    return;</a>
<a name="ln215"> </a>
<a name="ln216">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln217">    block_col = curwin-&gt;w_cursor.col;</a>
<a name="ln218">  }</a>
<a name="ln219"> </a>
<a name="ln220">  for (i = oap-&gt;line_count - 1; i &gt;= 0; i--) {</a>
<a name="ln221">    first_char = *get_cursor_line_ptr();</a>
<a name="ln222">    if (first_char == NUL) {  // empty line</a>
<a name="ln223">      curwin-&gt;w_cursor.col = 0;</a>
<a name="ln224">    } else if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln225">      shift_block(oap, amount);</a>
<a name="ln226">    } else if (first_char != '#' || !preprocs_left()) {</a>
<a name="ln227">      // Move the line right if it doesn't start with '#', 'smartindent'</a>
<a name="ln228">      // isn't set or 'cindent' isn't set or '#' isn't in 'cino'.</a>
<a name="ln229">      shift_line(oap-&gt;op_type == OP_LSHIFT, p_sr, amount, false);</a>
<a name="ln230">    }</a>
<a name="ln231">    ++curwin-&gt;w_cursor.lnum;</a>
<a name="ln232">  }</a>
<a name="ln233"> </a>
<a name="ln234">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln235">    curwin-&gt;w_cursor.lnum = oap-&gt;start.lnum;</a>
<a name="ln236">    curwin-&gt;w_cursor.col = block_col;</a>
<a name="ln237">  } else if (curs_top) { /* put cursor on first line, for &quot;&gt;&gt;&quot; */</a>
<a name="ln238">    curwin-&gt;w_cursor.lnum = oap-&gt;start.lnum;</a>
<a name="ln239">    beginline(BL_SOL | BL_FIX);       /* shift_line() may have set cursor.col */</a>
<a name="ln240">  } else</a>
<a name="ln241">    --curwin-&gt;w_cursor.lnum;            /* put cursor on last line, for &quot;:&gt;&quot; */</a>
<a name="ln242"> </a>
<a name="ln243">  // The cursor line is not in a closed fold</a>
<a name="ln244">  foldOpenCursor();</a>
<a name="ln245"> </a>
<a name="ln246">  if (oap-&gt;line_count &gt; p_report) {</a>
<a name="ln247">    if (oap-&gt;op_type == OP_RSHIFT)</a>
<a name="ln248">      s = (char_u *)&quot;&gt;&quot;;</a>
<a name="ln249">    else</a>
<a name="ln250">      s = (char_u *)&quot;&lt;&quot;;</a>
<a name="ln251">    if (oap-&gt;line_count == 1) {</a>
<a name="ln252">      if (amount == 1)</a>
<a name="ln253">        sprintf((char *)IObuff, _(&quot;1 line %sed 1 time&quot;), s);</a>
<a name="ln254">      else</a>
<a name="ln255">        sprintf((char *)IObuff, _(&quot;1 line %sed %d times&quot;), s, amount);</a>
<a name="ln256">    } else {</a>
<a name="ln257">      if (amount == 1)</a>
<a name="ln258">        sprintf((char *)IObuff, _(&quot;%&quot; PRId64 &quot; lines %sed 1 time&quot;),</a>
<a name="ln259">            (int64_t)oap-&gt;line_count, s);</a>
<a name="ln260">      else</a>
<a name="ln261">        sprintf((char *)IObuff, _(&quot;%&quot; PRId64 &quot; lines %sed %d times&quot;),</a>
<a name="ln262">            (int64_t)oap-&gt;line_count, s, amount);</a>
<a name="ln263">    }</a>
<a name="ln264">    msg_attr_keep(IObuff, 0, true, false);</a>
<a name="ln265">  }</a>
<a name="ln266"> </a>
<a name="ln267">  /*</a>
<a name="ln268">   * Set &quot;'[&quot; and &quot;']&quot; marks.</a>
<a name="ln269">   */</a>
<a name="ln270">  curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln271">  curbuf-&gt;b_op_end.lnum = oap-&gt;end.lnum;</a>
<a name="ln272">  curbuf-&gt;b_op_end.col = (colnr_T)STRLEN(ml_get(oap-&gt;end.lnum));</a>
<a name="ln273">  if (curbuf-&gt;b_op_end.col &gt; 0) {</a>
<a name="ln274">    curbuf-&gt;b_op_end.col--;</a>
<a name="ln275">  }</a>
<a name="ln276"> </a>
<a name="ln277">  changed_lines(oap-&gt;start.lnum, 0, oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280">// Shift the current line one shiftwidth left (if left != 0) or right</a>
<a name="ln281">// leaves cursor on first blank in the line.</a>
<a name="ln282">void shift_line(</a>
<a name="ln283">    int left,</a>
<a name="ln284">    int round,</a>
<a name="ln285">    int amount,</a>
<a name="ln286">    int call_changed_bytes  // call changed_bytes()</a>
<a name="ln287">)</a>
<a name="ln288">{</a>
<a name="ln289">  int count;</a>
<a name="ln290">  int i, j;</a>
<a name="ln291">  int p_sw = (int)get_sw_value_indent(curbuf);</a>
<a name="ln292"> </a>
<a name="ln293">  count = get_indent();  // get current indent</a>
<a name="ln294"> </a>
<a name="ln295">  if (round) {  // round off indent</a>
<a name="ln296">    i = count / p_sw;  // number of p_sw rounded down</a>
<a name="ln297">    j = count % p_sw;  // extra spaces</a>
<a name="ln298">    if (j &amp;&amp; left) {  // first remove extra spaces</a>
<a name="ln299">      amount--;</a>
<a name="ln300">    }</a>
<a name="ln301">    if (left) {</a>
<a name="ln302">      i -= amount;</a>
<a name="ln303">      if (i &lt; 0)</a>
<a name="ln304">        i = 0;</a>
<a name="ln305">    } else</a>
<a name="ln306">      i += amount;</a>
<a name="ln307">    count = i * p_sw;</a>
<a name="ln308">  } else {  // original vi indent</a>
<a name="ln309">    if (left) {</a>
<a name="ln310">      count -= p_sw * amount;</a>
<a name="ln311">      if (count &lt; 0)</a>
<a name="ln312">        count = 0;</a>
<a name="ln313">    } else</a>
<a name="ln314">      count += p_sw * amount;</a>
<a name="ln315">  }</a>
<a name="ln316"> </a>
<a name="ln317">  // Set new indent</a>
<a name="ln318">  if (State &amp; VREPLACE_FLAG) {</a>
<a name="ln319">    change_indent(INDENT_SET, count, false, NUL, call_changed_bytes);</a>
<a name="ln320">  } else {</a>
<a name="ln321">    (void)set_indent(count, call_changed_bytes ? SIN_CHANGED : 0);</a>
<a name="ln322">  }</a>
<a name="ln323">}</a>
<a name="ln324"> </a>
<a name="ln325">/*</a>
<a name="ln326"> * Shift one line of the current block one shiftwidth right or left.</a>
<a name="ln327"> * Leaves cursor on first character in block.</a>
<a name="ln328"> */</a>
<a name="ln329">static void shift_block(oparg_T *oap, int amount)</a>
<a name="ln330">{</a>
<a name="ln331">  const bool left = (oap-&gt;op_type == OP_LSHIFT);</a>
<a name="ln332">  const int oldstate = State;</a>
<a name="ln333">  char_u *newp;</a>
<a name="ln334">  const int oldcol = curwin-&gt;w_cursor.col;</a>
<a name="ln335">  int p_sw = (int)get_sw_value_indent(curbuf);</a>
<a name="ln336">  long *p_vts = curbuf-&gt;b_p_vts_array;</a>
<a name="ln337">  const long p_ts = curbuf-&gt;b_p_ts;</a>
<a name="ln338">  struct block_def bd;</a>
<a name="ln339">  int incr;</a>
<a name="ln340">  int i = 0, j = 0;</a>
<a name="ln341">  const int old_p_ri = p_ri;</a>
<a name="ln342"> </a>
<a name="ln343">  p_ri = 0;                     /* don't want revins in indent */</a>
<a name="ln344"> </a>
<a name="ln345">  State = INSERT;               // don't want REPLACE for State</a>
<a name="ln346">  block_prep(oap, &amp;bd, curwin-&gt;w_cursor.lnum, true);</a>
<a name="ln347">  if (bd.is_short) {</a>
<a name="ln348">    return;</a>
<a name="ln349">  }</a>
<a name="ln350"> </a>
<a name="ln351">  // total is number of screen columns to be inserted/removed</a>
<a name="ln352">  int total = (int)((unsigned)amount * (unsigned)p_sw);</a>
<a name="ln353">  if ((total / p_sw) != amount) {</a>
<a name="ln354">    return;   // multiplication overflow</a>
<a name="ln355">  }</a>
<a name="ln356"> </a>
<a name="ln357">  char_u *const oldp = get_cursor_line_ptr();</a>
<a name="ln358"> </a>
<a name="ln359">  int startcol, oldlen, newlen;</a>
<a name="ln360"> </a>
<a name="ln361">  if (!left) {</a>
<a name="ln362">    /*</a>
<a name="ln363">     *  1. Get start vcol</a>
<a name="ln364">     *  2. Total ws vcols</a>
<a name="ln365">     *  3. Divvy into TABs &amp; spp</a>
<a name="ln366">     *  4. Construct new string</a>
<a name="ln367">     */</a>
<a name="ln368">    total += bd.pre_whitesp;    // all virtual WS up to &amp; incl a split TAB</a>
<a name="ln369">    colnr_T ws_vcol = bd.start_vcol - bd.pre_whitesp;</a>
<a name="ln370">    char_u * old_textstart = bd.textstart;</a>
<a name="ln371">    if (bd.startspaces) {</a>
<a name="ln372">      if (utfc_ptr2len(bd.textstart) == 1) {</a>
<a name="ln373">        bd.textstart++;</a>
<a name="ln374">      } else {</a>
<a name="ln375">        ws_vcol = 0;</a>
<a name="ln376">        bd.startspaces = 0;</a>
<a name="ln377">      }</a>
<a name="ln378">    }</a>
<a name="ln379">    for (; ascii_iswhite(*bd.textstart); ) {</a>
<a name="ln380">      // TODO: is passing bd.textstart for start of the line OK?</a>
<a name="ln381">      incr = lbr_chartabsize_adv(bd.textstart, &amp;bd.textstart, (colnr_T)(bd.start_vcol));</a>
<a name="ln382">      total += incr;</a>
<a name="ln383">      bd.start_vcol += incr;</a>
<a name="ln384">    }</a>
<a name="ln385">    /* OK, now total=all the VWS reqd, and textstart points at the 1st</a>
<a name="ln386">     * non-ws char in the block. */</a>
<a name="ln387">    if (!curbuf-&gt;b_p_et) {</a>
<a name="ln388">      tabstop_fromto(ws_vcol, ws_vcol + total, p_ts, p_vts, &amp;i, &amp;j);</a>
<a name="ln389">    } else {</a>
<a name="ln390">      j = total;</a>
<a name="ln391">    }</a>
<a name="ln392"> </a>
<a name="ln393">    // if we're splitting a TAB, allow for it</a>
<a name="ln394">    int col_pre = bd.pre_whitesp_c - (bd.startspaces != 0);</a>
<a name="ln395">    bd.textcol -= col_pre;</a>
<a name="ln396">    const int len = (int)STRLEN(bd.textstart) + 1;</a>
<a name="ln397">    int col = bd.textcol + i +j + len;</a>
<a name="ln398">    assert(col &gt;= 0);</a>
<a name="ln399">    newp = (char_u *)xmalloc((size_t)col);</a>
<a name="ln400">    memset(newp, NUL, (size_t)col);</a>
<a name="ln401">    memmove(newp, oldp, (size_t)bd.textcol);</a>
<a name="ln402">    startcol = bd.textcol;</a>
<a name="ln403">    oldlen = (int)(bd.textstart-old_textstart) + col_pre;</a>
<a name="ln404">    newlen = i+j;</a>
<a name="ln405">    memset(newp + bd.textcol, TAB, (size_t)i);</a>
<a name="ln406">    memset(newp + bd.textcol + i, ' ', (size_t)j);</a>
<a name="ln407">    /* the end */</a>
<a name="ln408">    memmove(newp + bd.textcol + i + j, bd.textstart, (size_t)len);</a>
<a name="ln409">  } else {  // left</a>
<a name="ln410">    colnr_T destination_col;      // column to which text in block will</a>
<a name="ln411">                                  // be shifted</a>
<a name="ln412">    char_u *verbatim_copy_end;    // end of the part of the line which is</a>
<a name="ln413">                                  // copied verbatim</a>
<a name="ln414">    colnr_T verbatim_copy_width;  // the (displayed) width of this part</a>
<a name="ln415">                                  // of line</a>
<a name="ln416">    size_t fill;                  // nr of spaces that replace a TAB</a>
<a name="ln417">    size_t new_line_len;          // the length of the line after the</a>
<a name="ln418">                                  // block shift</a>
<a name="ln419">    char_u      *non_white = bd.textstart;</a>
<a name="ln420"> </a>
<a name="ln421">    /*</a>
<a name="ln422">     * Firstly, let's find the first non-whitespace character that is</a>
<a name="ln423">     * displayed after the block's start column and the character's column</a>
<a name="ln424">     * number. Also, let's calculate the width of all the whitespace</a>
<a name="ln425">     * characters that are displayed in the block and precede the searched</a>
<a name="ln426">     * non-whitespace character.</a>
<a name="ln427">     */</a>
<a name="ln428"> </a>
<a name="ln429">    /* If &quot;bd.startspaces&quot; is set, &quot;bd.textstart&quot; points to the character,</a>
<a name="ln430">     * the part of which is displayed at the block's beginning. Let's start</a>
<a name="ln431">     * searching from the next character. */</a>
<a name="ln432">    if (bd.startspaces) {</a>
<a name="ln433">      MB_PTR_ADV(non_white);</a>
<a name="ln434">    }</a>
<a name="ln435"> </a>
<a name="ln436">    // The character's column is in &quot;bd.start_vcol&quot;.</a>
<a name="ln437">    colnr_T non_white_col = bd.start_vcol;</a>
<a name="ln438"> </a>
<a name="ln439">    while (ascii_iswhite(*non_white)) {</a>
<a name="ln440">      incr = lbr_chartabsize_adv(bd.textstart, &amp;non_white, non_white_col);</a>
<a name="ln441">      non_white_col += incr;</a>
<a name="ln442">    }</a>
<a name="ln443"> </a>
<a name="ln444"> </a>
<a name="ln445">    const colnr_T block_space_width = non_white_col - oap-&gt;start_vcol;</a>
<a name="ln446">    // We will shift by &quot;total&quot; or &quot;block_space_width&quot;, whichever is less.</a>
<a name="ln447">    const colnr_T shift_amount = block_space_width &lt; total</a>
<a name="ln448">        ? block_space_width</a>
<a name="ln449">        : total;</a>
<a name="ln450">    // The column to which we will shift the text.</a>
<a name="ln451">    destination_col = non_white_col - shift_amount;</a>
<a name="ln452"> </a>
<a name="ln453">    /* Now let's find out how much of the beginning of the line we can</a>
<a name="ln454">     * reuse without modification.  */</a>
<a name="ln455">    verbatim_copy_end = bd.textstart;</a>
<a name="ln456">    verbatim_copy_width = bd.start_vcol;</a>
<a name="ln457"> </a>
<a name="ln458">    /* If &quot;bd.startspaces&quot; is set, &quot;bd.textstart&quot; points to the character</a>
<a name="ln459">     * preceding the block. We have to subtract its width to obtain its</a>
<a name="ln460">     * column number.  */</a>
<a name="ln461">    if (bd.startspaces)</a>
<a name="ln462">      verbatim_copy_width -= bd.start_char_vcols;</a>
<a name="ln463">    while (verbatim_copy_width &lt; destination_col) {</a>
<a name="ln464">      char_u *line = verbatim_copy_end;</a>
<a name="ln465"> </a>
<a name="ln466">      // TODO: is passing verbatim_copy_end for start of the line OK?</a>
<a name="ln467">      incr = lbr_chartabsize(line, verbatim_copy_end, verbatim_copy_width);</a>
<a name="ln468">      if (verbatim_copy_width + incr &gt; destination_col)</a>
<a name="ln469">        break;</a>
<a name="ln470">      verbatim_copy_width += incr;</a>
<a name="ln471">      MB_PTR_ADV(verbatim_copy_end);</a>
<a name="ln472">    }</a>
<a name="ln473"> </a>
<a name="ln474">    /* If &quot;destination_col&quot; is different from the width of the initial</a>
<a name="ln475">    * part of the line that will be copied, it means we encountered a tab</a>
<a name="ln476">    * character, which we will have to partly replace with spaces.  */</a>
<a name="ln477">    assert(destination_col - verbatim_copy_width &gt;= 0);</a>
<a name="ln478">    fill = (size_t)(destination_col - verbatim_copy_width);</a>
<a name="ln479"> </a>
<a name="ln480">    assert(verbatim_copy_end - oldp &gt;= 0);</a>
<a name="ln481">    const size_t verbatim_diff = (size_t)(verbatim_copy_end - oldp);</a>
<a name="ln482">    // The replacement line will consist of:</a>
<a name="ln483">    // - the beginning of the original line up to &quot;verbatim_copy_end&quot;,</a>
<a name="ln484">    // - &quot;fill&quot; number of spaces,</a>
<a name="ln485">    // - the rest of the line, pointed to by non_white.</a>
<a name="ln486">    new_line_len = verbatim_diff + fill + STRLEN(non_white) + 1;</a>
<a name="ln487"> </a>
<a name="ln488">    newp = (char_u *)xmalloc(new_line_len);</a>
<a name="ln489">    startcol = (int)verbatim_diff;</a>
<a name="ln490">    oldlen = bd.textcol + (int)(non_white - bd.textstart) - (int)verbatim_diff;</a>
<a name="ln491">    newlen = (int)fill;</a>
<a name="ln492">    memmove(newp, oldp, verbatim_diff);</a>
<a name="ln493">    memset(newp + verbatim_diff, ' ', fill);</a>
<a name="ln494">    STRMOVE(newp + verbatim_diff + fill, non_white);</a>
<a name="ln495">  }</a>
<a name="ln496">  // replace the line</a>
<a name="ln497">  ml_replace(curwin-&gt;w_cursor.lnum, newp, false);</a>
<a name="ln498">  changed_bytes(curwin-&gt;w_cursor.lnum, (colnr_T)bd.textcol);</a>
<a name="ln499">  extmark_splice_cols(curbuf, (int)curwin-&gt;w_cursor.lnum-1, startcol,</a>
<a name="ln500">                      oldlen, newlen,</a>
<a name="ln501">                      kExtmarkUndo);</a>
<a name="ln502">  State = oldstate;</a>
<a name="ln503">  curwin-&gt;w_cursor.col = oldcol;</a>
<a name="ln504">  p_ri = old_p_ri;</a>
<a name="ln505">}</a>
<a name="ln506"> </a>
<a name="ln507">/*</a>
<a name="ln508"> * Insert string &quot;s&quot; (b_insert ? before : after) block :AKelly</a>
<a name="ln509"> * Caller must prepare for undo.</a>
<a name="ln510"> */</a>
<a name="ln511">static void block_insert(oparg_T *oap, char_u *s, int b_insert, struct block_def *bdp)</a>
<a name="ln512">{</a>
<a name="ln513">  int p_ts;</a>
<a name="ln514">  int count = 0;                // extra spaces to replace a cut TAB</a>
<a name="ln515">  int spaces = 0;               // non-zero if cutting a TAB</a>
<a name="ln516">  colnr_T offset;               // pointer along new line</a>
<a name="ln517">  size_t s_len = STRLEN(s);</a>
<a name="ln518">  char_u      *newp, *oldp;     // new, old lines</a>
<a name="ln519">  linenr_T lnum;                // loop var</a>
<a name="ln520">  int oldstate = State;</a>
<a name="ln521">  State = INSERT;               // don't want REPLACE for State</a>
<a name="ln522"> </a>
<a name="ln523">  for (lnum = oap-&gt;start.lnum + 1; lnum &lt;= oap-&gt;end.lnum; lnum++) {</a>
<a name="ln524">    block_prep(oap, bdp, lnum, true);</a>
<a name="ln525">    if (bdp-&gt;is_short &amp;&amp; b_insert) {</a>
<a name="ln526">      continue;  // OP_INSERT, line ends before block start</a>
<a name="ln527">    }</a>
<a name="ln528"> </a>
<a name="ln529">    oldp = ml_get(lnum);</a>
<a name="ln530"> </a>
<a name="ln531">    if (b_insert) {</a>
<a name="ln532">      p_ts = bdp-&gt;start_char_vcols;</a>
<a name="ln533">      spaces = bdp-&gt;startspaces;</a>
<a name="ln534">      if (spaces != 0)</a>
<a name="ln535">        count = p_ts - 1;         /* we're cutting a TAB */</a>
<a name="ln536">      offset = bdp-&gt;textcol;</a>
<a name="ln537">    } else { /* append */</a>
<a name="ln538">      p_ts = bdp-&gt;end_char_vcols;</a>
<a name="ln539">      if (!bdp-&gt;is_short) {     /* spaces = padding after block */</a>
<a name="ln540">        spaces = (bdp-&gt;endspaces ? p_ts - bdp-&gt;endspaces : 0);</a>
<a name="ln541">        if (spaces != 0)</a>
<a name="ln542">          count = p_ts - 1;           /* we're cutting a TAB */</a>
<a name="ln543">        offset = bdp-&gt;textcol + bdp-&gt;textlen - (spaces != 0);</a>
<a name="ln544">      } else { /* spaces = padding to block edge */</a>
<a name="ln545">                 /* if $ used, just append to EOL (ie spaces==0) */</a>
<a name="ln546">        if (!bdp-&gt;is_MAX)</a>
<a name="ln547">          spaces = (oap-&gt;end_vcol - bdp-&gt;end_vcol) + 1;</a>
<a name="ln548">        count = spaces;</a>
<a name="ln549">        offset = bdp-&gt;textcol + bdp-&gt;textlen;</a>
<a name="ln550">      }</a>
<a name="ln551">    }</a>
<a name="ln552"> </a>
<a name="ln553">    if (spaces &gt; 0) {</a>
<a name="ln554">      int off;</a>
<a name="ln555"> </a>
<a name="ln556">      // Avoid starting halfway through a multi-byte character.</a>
<a name="ln557">      if (b_insert) {</a>
<a name="ln558">        off = utf_head_off(oldp, oldp + offset + spaces);</a>
<a name="ln559">      } else {</a>
<a name="ln560">        off = (*mb_off_next)(oldp, oldp + offset);</a>
<a name="ln561">        offset += off;</a>
<a name="ln562">      }</a>
<a name="ln563">      spaces -= off;</a>
<a name="ln564">      count -= off;</a>
<a name="ln565">    }</a>
<a name="ln566"> </a>
<a name="ln567">    assert(count &gt;= 0);</a>
<a name="ln568">    newp = (char_u *)xmalloc(STRLEN(oldp) + s_len + (size_t)count + 1);</a>
<a name="ln569"> </a>
<a name="ln570">    // copy up to shifted part</a>
<a name="ln571">    memmove(newp, oldp, (size_t)offset);</a>
<a name="ln572">    oldp += offset;</a>
<a name="ln573">    int startcol = offset;</a>
<a name="ln574"> </a>
<a name="ln575">    // insert pre-padding</a>
<a name="ln576">    memset(newp + offset, ' ', (size_t)spaces);</a>
<a name="ln577"> </a>
<a name="ln578">    // copy the new text</a>
<a name="ln579">    memmove(newp + offset + spaces, s, s_len);</a>
<a name="ln580">    offset += (int)s_len;</a>
<a name="ln581"> </a>
<a name="ln582">    int skipped = 0;</a>
<a name="ln583">    if (spaces &amp;&amp; !bdp-&gt;is_short) {</a>
<a name="ln584">      // insert post-padding</a>
<a name="ln585">      memset(newp + offset + spaces, ' ', (size_t)(p_ts - spaces));</a>
<a name="ln586">      // We're splitting a TAB, don't copy it.</a>
<a name="ln587">      oldp++;</a>
<a name="ln588">      // We allowed for that TAB, remember this now</a>
<a name="ln589">      count++;</a>
<a name="ln590">      skipped = 1;</a>
<a name="ln591">    }</a>
<a name="ln592"> </a>
<a name="ln593">    if (spaces &gt; 0)</a>
<a name="ln594">      offset += count;</a>
<a name="ln595">    STRMOVE(newp + offset, oldp);</a>
<a name="ln596"> </a>
<a name="ln597">    ml_replace(lnum, newp, false);</a>
<a name="ln598">    extmark_splice_cols(curbuf, (int)lnum-1, startcol,</a>
<a name="ln599">                        skipped, offset-startcol, kExtmarkUndo);</a>
<a name="ln600"> </a>
<a name="ln601">    if (lnum == oap-&gt;end.lnum) {</a>
<a name="ln602">      /* Set &quot;']&quot; mark to the end of the block instead of the end of</a>
<a name="ln603">       * the insert in the first line.  */</a>
<a name="ln604">      curbuf-&gt;b_op_end.lnum = oap-&gt;end.lnum;</a>
<a name="ln605">      curbuf-&gt;b_op_end.col = offset;</a>
<a name="ln606">    }</a>
<a name="ln607">  }   /* for all lnum */</a>
<a name="ln608"> </a>
<a name="ln609">  changed_lines(oap-&gt;start.lnum + 1, 0, oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln610"> </a>
<a name="ln611">  State = oldstate;</a>
<a name="ln612">}</a>
<a name="ln613"> </a>
<a name="ln614">/*</a>
<a name="ln615"> * op_reindent - handle reindenting a block of lines.</a>
<a name="ln616"> */</a>
<a name="ln617">void op_reindent(oparg_T *oap, Indenter how)</a>
<a name="ln618">{</a>
<a name="ln619">  long i;</a>
<a name="ln620">  char_u      *l;</a>
<a name="ln621">  int amount;</a>
<a name="ln622">  linenr_T first_changed = 0;</a>
<a name="ln623">  linenr_T last_changed = 0;</a>
<a name="ln624">  linenr_T start_lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln625"> </a>
<a name="ln626">  /* Don't even try when 'modifiable' is off. */</a>
<a name="ln627">  if (!MODIFIABLE(curbuf)) {</a>
<a name="ln628">    EMSG(_(e_modifiable));</a>
<a name="ln629">    return;</a>
<a name="ln630">  }</a>
<a name="ln631"> </a>
<a name="ln632">  for (i = oap-&gt;line_count - 1; i &gt;= 0 &amp;&amp; !got_int; i--) {</a>
<a name="ln633">    /* it's a slow thing to do, so give feedback so there's no worry that</a>
<a name="ln634">     * the computer's just hung. */</a>
<a name="ln635"> </a>
<a name="ln636">    if (i &gt; 1</a>
<a name="ln637">        &amp;&amp; (i % 50 == 0 || i == oap-&gt;line_count - 1)</a>
<a name="ln638">        &amp;&amp; oap-&gt;line_count &gt; p_report)</a>
<a name="ln639">      smsg(_(&quot;%&quot; PRId64 &quot; lines to indent... &quot;), (int64_t)i);</a>
<a name="ln640"> </a>
<a name="ln641">    /*</a>
<a name="ln642">     * Be vi-compatible: For lisp indenting the first line is not</a>
<a name="ln643">     * indented, unless there is only one line.</a>
<a name="ln644">     */</a>
<a name="ln645">    if (i != oap-&gt;line_count - 1 || oap-&gt;line_count == 1</a>
<a name="ln646">        || how != get_lisp_indent) {</a>
<a name="ln647">      l = skipwhite(get_cursor_line_ptr());</a>
<a name="ln648">      if (*l == NUL)                        /* empty or blank line */</a>
<a name="ln649">        amount = 0;</a>
<a name="ln650">      else</a>
<a name="ln651">        amount = how();                     /* get the indent for this line */</a>
<a name="ln652"> </a>
<a name="ln653">      if (amount &gt;= 0 &amp;&amp; set_indent(amount, SIN_UNDO)) {</a>
<a name="ln654">        // did change the indent, call changed_lines() later</a>
<a name="ln655">        if (first_changed == 0) {</a>
<a name="ln656">          first_changed = curwin-&gt;w_cursor.lnum;</a>
<a name="ln657">        }</a>
<a name="ln658">        last_changed = curwin-&gt;w_cursor.lnum;</a>
<a name="ln659">      }</a>
<a name="ln660">    }</a>
<a name="ln661">    ++curwin-&gt;w_cursor.lnum;</a>
<a name="ln662">    curwin-&gt;w_cursor.col = 0;      /* make sure it's valid */</a>
<a name="ln663">  }</a>
<a name="ln664"> </a>
<a name="ln665">  /* put cursor on first non-blank of indented line */</a>
<a name="ln666">  curwin-&gt;w_cursor.lnum = start_lnum;</a>
<a name="ln667">  beginline(BL_SOL | BL_FIX);</a>
<a name="ln668"> </a>
<a name="ln669">  /* Mark changed lines so that they will be redrawn.  When Visual</a>
<a name="ln670">   * highlighting was present, need to continue until the last line.  When</a>
<a name="ln671">   * there is no change still need to remove the Visual highlighting. */</a>
<a name="ln672">  if (last_changed != 0) {</a>
<a name="ln673">    changed_lines(first_changed, 0,</a>
<a name="ln674">                  oap-&gt;is_VIsual ? start_lnum + oap-&gt;line_count :</a>
<a name="ln675">                  last_changed + 1, 0L, true);</a>
<a name="ln676">  } else if (oap-&gt;is_VIsual) {</a>
<a name="ln677">    redraw_curbuf_later(INVERTED);</a>
<a name="ln678">  }</a>
<a name="ln679"> </a>
<a name="ln680">  if (oap-&gt;line_count &gt; p_report) {</a>
<a name="ln681">    i = oap-&gt;line_count - (i + 1);</a>
<a name="ln682">    if (i == 1)</a>
<a name="ln683">      MSG(_(&quot;1 line indented &quot;));</a>
<a name="ln684">    else</a>
<a name="ln685">      smsg(_(&quot;%&quot; PRId64 &quot; lines indented &quot;), (int64_t)i);</a>
<a name="ln686">  }</a>
<a name="ln687">  /* set '[ and '] marks */</a>
<a name="ln688">  curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln689">  curbuf-&gt;b_op_end = oap-&gt;end;</a>
<a name="ln690">}</a>
<a name="ln691"> </a>
<a name="ln692">/*</a>
<a name="ln693"> * Keep the last expression line here, for repeating.</a>
<a name="ln694"> */</a>
<a name="ln695">static char_u   *expr_line = NULL;</a>
<a name="ln696"> </a>
<a name="ln697">/*</a>
<a name="ln698"> * Get an expression for the &quot;\&quot;=expr1&quot; or &quot;CTRL-R =expr1&quot;</a>
<a name="ln699"> * Returns '=' when OK, NUL otherwise.</a>
<a name="ln700"> */</a>
<a name="ln701">int get_expr_register(void)</a>
<a name="ln702">{</a>
<a name="ln703">  char_u      *new_line;</a>
<a name="ln704"> </a>
<a name="ln705">  new_line = getcmdline('=', 0L, 0, true);</a>
<a name="ln706">  if (new_line == NULL) {</a>
<a name="ln707">    return NUL;</a>
<a name="ln708">  }</a>
<a name="ln709">  if (*new_line == NUL) {  // use previous line</a>
<a name="ln710">    xfree(new_line);</a>
<a name="ln711">  } else {</a>
<a name="ln712">    set_expr_line(new_line);</a>
<a name="ln713">  }</a>
<a name="ln714">  return '=';</a>
<a name="ln715">}</a>
<a name="ln716"> </a>
<a name="ln717">/*</a>
<a name="ln718"> * Set the expression for the '=' register.</a>
<a name="ln719"> * Argument must be an allocated string.</a>
<a name="ln720"> */</a>
<a name="ln721">void set_expr_line(char_u *new_line)</a>
<a name="ln722">{</a>
<a name="ln723">  xfree(expr_line);</a>
<a name="ln724">  expr_line = new_line;</a>
<a name="ln725">}</a>
<a name="ln726"> </a>
<a name="ln727">/*</a>
<a name="ln728"> * Get the result of the '=' register expression.</a>
<a name="ln729"> * Returns a pointer to allocated memory, or NULL for failure.</a>
<a name="ln730"> */</a>
<a name="ln731">char_u *get_expr_line(void)</a>
<a name="ln732">{</a>
<a name="ln733">  char_u      *expr_copy;</a>
<a name="ln734">  char_u      *rv;</a>
<a name="ln735">  static int nested = 0;</a>
<a name="ln736"> </a>
<a name="ln737">  if (expr_line == NULL)</a>
<a name="ln738">    return NULL;</a>
<a name="ln739"> </a>
<a name="ln740">  /* Make a copy of the expression, because evaluating it may cause it to be</a>
<a name="ln741">   * changed. */</a>
<a name="ln742">  expr_copy = vim_strsave(expr_line);</a>
<a name="ln743"> </a>
<a name="ln744">  /* When we are invoked recursively limit the evaluation to 10 levels.</a>
<a name="ln745">   * Then return the string as-is. */</a>
<a name="ln746">  if (nested &gt;= 10)</a>
<a name="ln747">    return expr_copy;</a>
<a name="ln748"> </a>
<a name="ln749">  ++nested;</a>
<a name="ln750">  rv = eval_to_string(expr_copy, NULL, TRUE);</a>
<a name="ln751">  --nested;</a>
<a name="ln752">  xfree(expr_copy);</a>
<a name="ln753">  return rv;</a>
<a name="ln754">}</a>
<a name="ln755"> </a>
<a name="ln756">/*</a>
<a name="ln757"> * Get the '=' register expression itself, without evaluating it.</a>
<a name="ln758"> */</a>
<a name="ln759">char_u *get_expr_line_src(void)</a>
<a name="ln760">{</a>
<a name="ln761">  if (expr_line == NULL)</a>
<a name="ln762">    return NULL;</a>
<a name="ln763">  return vim_strsave(expr_line);</a>
<a name="ln764">}</a>
<a name="ln765"> </a>
<a name="ln766">/// Returns whether `regname` is a valid name of a yank register.</a>
<a name="ln767">/// Note: There is no check for 0 (default register), caller should do this.</a>
<a name="ln768">/// The black hole register '_' is regarded as valid.</a>
<a name="ln769">///</a>
<a name="ln770">/// @param regname name of register</a>
<a name="ln771">/// @param writing allow only writable registers</a>
<a name="ln772">bool valid_yank_reg(int regname, bool writing)</a>
<a name="ln773">{</a>
<a name="ln774">  if ((regname &gt; 0 &amp;&amp; ASCII_ISALNUM(regname))</a>
<a name="ln775">      || (!writing &amp;&amp; vim_strchr((char_u *) &quot;/.%:=&quot; , regname) != NULL)</a>
<a name="ln776">      || regname == '#'</a>
<a name="ln777">      || regname == '&quot;'</a>
<a name="ln778">      || regname == '-'</a>
<a name="ln779">      || regname == '_'</a>
<a name="ln780">      || regname == '*'</a>
<a name="ln781">      || regname == '+') {</a>
<a name="ln782">    return true;</a>
<a name="ln783">  }</a>
<a name="ln784">  return false;</a>
<a name="ln785">}</a>
<a name="ln786"> </a>
<a name="ln787">typedef enum {</a>
<a name="ln788">  YREG_PASTE,</a>
<a name="ln789">  YREG_YANK,</a>
<a name="ln790">  YREG_PUT,</a>
<a name="ln791">} yreg_mode_t;</a>
<a name="ln792"> </a>
<a name="ln793">/// Return yankreg_T to use, according to the value of `regname`.</a>
<a name="ln794">/// Cannot handle the '_' (black hole) register.</a>
<a name="ln795">/// Must only be called with a valid register name!</a>
<a name="ln796">///</a>
<a name="ln797">/// @param regname The name of the register used or 0 for the unnamed register</a>
<a name="ln798">/// @param mode One of the following three flags:</a>
<a name="ln799">///</a>
<a name="ln800">/// `YREG_PASTE`:</a>
<a name="ln801">/// Prepare for pasting the register `regname`. With no regname specified,</a>
<a name="ln802">/// read from last written register, or from unnamed clipboard (depending on the</a>
<a name="ln803">/// `clipboard=unnamed` option). Queries the clipboard provider if necessary.</a>
<a name="ln804">///</a>
<a name="ln805">/// `YREG_YANK`:</a>
<a name="ln806">/// Preparare for yanking into `regname`. With no regname specified,</a>
<a name="ln807">/// yank into `&quot;0` register. Update `y_previous` for next unnamed paste.</a>
<a name="ln808">///</a>
<a name="ln809">/// `YREG_PUT`:</a>
<a name="ln810">/// Obtain the location that would be read when pasting `regname`.</a>
<a name="ln811">yankreg_T *get_yank_register(int regname, int mode)</a>
<a name="ln812">{</a>
<a name="ln813">  yankreg_T *reg;</a>
<a name="ln814"> </a>
<a name="ln815">  if (mode == YREG_PASTE &amp;&amp; get_clipboard(regname, &amp;reg, false)) {</a>
<a name="ln816">    // reg is set to clipboard contents.</a>
<a name="ln817">    return reg;</a>
<a name="ln818">  } else if (mode != YREG_YANK</a>
<a name="ln819">      &amp;&amp; (regname == 0 || regname == '&quot;' || regname == '*' || regname == '+')</a>
<a name="ln820">      &amp;&amp; y_previous != NULL) {</a>
<a name="ln821">    // in case clipboard not available, paste from previous used register</a>
<a name="ln822">    return y_previous;</a>
<a name="ln823">  }</a>
<a name="ln824"> </a>
<a name="ln825">  int i = op_reg_index(regname);</a>
<a name="ln826">  // when not 0-9, a-z, A-Z or '-'/'+'/'*': use register 0</a>
<a name="ln827">  if (i == -1) {</a>
<a name="ln828">    i = 0;</a>
<a name="ln829">  }</a>
<a name="ln830">  reg = &amp;y_regs[i];</a>
<a name="ln831"> </a>
<a name="ln832">  if (mode == YREG_YANK) {</a>
<a name="ln833">    // remember the written register for unnamed paste</a>
<a name="ln834">    y_previous = reg;</a>
<a name="ln835">  }</a>
<a name="ln836">  return reg;</a>
<a name="ln837">}</a>
<a name="ln838"> </a>
<a name="ln839">static bool is_append_register(int regname)</a>
<a name="ln840">{</a>
<a name="ln841">  return ASCII_ISUPPER(regname);</a>
<a name="ln842">}</a>
<a name="ln843"> </a>
<a name="ln844">/// @see get_yank_register</a>
<a name="ln845">/// @returns true when register should be inserted literally</a>
<a name="ln846">/// (selection or clipboard)</a>
<a name="ln847">static inline bool is_literal_register(int regname)</a>
<a name="ln848">  FUNC_ATTR_CONST</a>
<a name="ln849">{</a>
<a name="ln850">  return regname == '*' || regname == '+';</a>
<a name="ln851">}</a>
<a name="ln852"> </a>
<a name="ln853">/// Returns a copy of contents in register `name`</a>
<a name="ln854">/// for use in do_put. Should be freed by caller.</a>
<a name="ln855">yankreg_T *copy_register(int name)</a>
<a name="ln856">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln857">{</a>
<a name="ln858">  yankreg_T *reg = get_yank_register(name, YREG_PASTE);</a>
<a name="ln859"> </a>
<a name="ln860">  yankreg_T *copy = xmalloc(sizeof(yankreg_T));</a>
<a name="ln861">  *copy = *reg;</a>
<a name="ln862">  if (copy-&gt;y_size == 0) {</a>
<a name="ln863">    copy-&gt;y_array = NULL;</a>
<a name="ln864">  } else {</a>
<a name="ln865">    copy-&gt;y_array = xcalloc(copy-&gt;y_size, sizeof(char_u *));</a>
<a name="ln866">    for (size_t i = 0; i &lt; copy-&gt;y_size; i++) {</a>
<a name="ln867">      copy-&gt;y_array[i] = vim_strsave(reg-&gt;y_array[i]);</a>
<a name="ln868">    }</a>
<a name="ln869">  }</a>
<a name="ln870">  return copy;</a>
<a name="ln871">}</a>
<a name="ln872"> </a>
<a name="ln873">/// check if the current yank register has kMTLineWise register type</a>
<a name="ln874">bool yank_register_mline(int regname)</a>
<a name="ln875">{</a>
<a name="ln876">  if (regname != 0 &amp;&amp; !valid_yank_reg(regname, false)) {</a>
<a name="ln877">    return false;</a>
<a name="ln878">  }</a>
<a name="ln879">  if (regname == '_') {  // black hole is always empty</a>
<a name="ln880">    return false;</a>
<a name="ln881">  }</a>
<a name="ln882">  yankreg_T *reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln883">  return reg-&gt;y_type == kMTLineWise;</a>
<a name="ln884">}</a>
<a name="ln885"> </a>
<a name="ln886">/*</a>
<a name="ln887"> * Start or stop recording into a yank register.</a>
<a name="ln888"> *</a>
<a name="ln889"> * Return FAIL for failure, OK otherwise.</a>
<a name="ln890"> */</a>
<a name="ln891">int do_record(int c)</a>
<a name="ln892">{</a>
<a name="ln893">  char_u          *p;</a>
<a name="ln894">  static int regname;</a>
<a name="ln895">  yankreg_T  *old_y_previous;</a>
<a name="ln896">  int retval;</a>
<a name="ln897"> </a>
<a name="ln898">  if (reg_recording == 0) {</a>
<a name="ln899">    // start recording</a>
<a name="ln900">    // registers 0-9, a-z and &quot; are allowed</a>
<a name="ln901">    if (c &lt; 0 || (!ASCII_ISALNUM(c) &amp;&amp; c != '&quot;')) {</a>
<a name="ln902">      retval = FAIL;</a>
<a name="ln903">    } else {</a>
<a name="ln904">      reg_recording = c;</a>
<a name="ln905">      showmode();</a>
<a name="ln906">      regname = c;</a>
<a name="ln907">      retval = OK;</a>
<a name="ln908">    }</a>
<a name="ln909">  } else {                        /* stop recording */</a>
<a name="ln910">    /*</a>
<a name="ln911">     * Get the recorded key hits.  K_SPECIAL and CSI will be escaped, this</a>
<a name="ln912">     * needs to be removed again to put it in a register.  exec_reg then</a>
<a name="ln913">     * adds the escaping back later.</a>
<a name="ln914">     */</a>
<a name="ln915">    reg_recording = 0;</a>
<a name="ln916">    if (ui_has(kUIMessages)) {</a>
<a name="ln917">      showmode();</a>
<a name="ln918">    } else {</a>
<a name="ln919">      MSG(&quot;&quot;);</a>
<a name="ln920">    }</a>
<a name="ln921">    p = get_recorded();</a>
<a name="ln922">    if (p == NULL)</a>
<a name="ln923">      retval = FAIL;</a>
<a name="ln924">    else {</a>
<a name="ln925">      /* Remove escaping for CSI and K_SPECIAL in multi-byte chars. */</a>
<a name="ln926">      vim_unescape_csi(p);</a>
<a name="ln927"> </a>
<a name="ln928">      /*</a>
<a name="ln929">       * We don't want to change the default register here, so save and</a>
<a name="ln930">       * restore the current register name.</a>
<a name="ln931">       */</a>
<a name="ln932">      old_y_previous = y_previous;</a>
<a name="ln933"> </a>
<a name="ln934">      retval = stuff_yank(regname, p);</a>
<a name="ln935"> </a>
<a name="ln936">      y_previous = old_y_previous;</a>
<a name="ln937">    }</a>
<a name="ln938">  }</a>
<a name="ln939">  return retval;</a>
<a name="ln940">}</a>
<a name="ln941"> </a>
<a name="ln942">static void set_yreg_additional_data(yankreg_T *reg, dict_T *additional_data)</a>
<a name="ln943">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln944">{</a>
<a name="ln945">  if (reg-&gt;additional_data == additional_data) {</a>
<a name="ln946">    return;</a>
<a name="ln947">  }</a>
<a name="ln948">  tv_dict_unref(reg-&gt;additional_data);</a>
<a name="ln949">  reg-&gt;additional_data = additional_data;</a>
<a name="ln950">}</a>
<a name="ln951"> </a>
<a name="ln952">/*</a>
<a name="ln953"> * Stuff string &quot;p&quot; into yank register &quot;regname&quot; as a single line (append if</a>
<a name="ln954"> * uppercase). &quot;p&quot; must have been alloced.</a>
<a name="ln955"> *</a>
<a name="ln956"> * return FAIL for failure, OK otherwise</a>
<a name="ln957"> */</a>
<a name="ln958">static int stuff_yank(int regname, char_u *p)</a>
<a name="ln959">{</a>
<a name="ln960">  /* check for read-only register */</a>
<a name="ln961">  if (regname != 0 &amp;&amp; !valid_yank_reg(regname, true)) {</a>
<a name="ln962">    xfree(p);</a>
<a name="ln963">    return FAIL;</a>
<a name="ln964">  }</a>
<a name="ln965">  if (regname == '_') {             /* black hole: don't do anything */</a>
<a name="ln966">    xfree(p);</a>
<a name="ln967">    return OK;</a>
<a name="ln968">  }</a>
<a name="ln969">  yankreg_T *reg = get_yank_register(regname, YREG_YANK);</a>
<a name="ln970">  if (is_append_register(regname) &amp;&amp; reg-&gt;y_array != NULL) {</a>
<a name="ln971">    char_u **pp = &amp;(reg-&gt;y_array[reg-&gt;y_size - 1]);</a>
<a name="ln972">    char_u *lp = xmalloc(STRLEN(*pp) + STRLEN(p) + 1);</a>
<a name="ln973">    STRCPY(lp, *pp);</a>
<a name="ln974">    // TODO(philix): use xstpcpy() in stuff_yank()</a>
<a name="ln975">    STRCAT(lp, p);</a>
<a name="ln976">    xfree(p);</a>
<a name="ln977">    xfree(*pp);</a>
<a name="ln978">    *pp = lp;</a>
<a name="ln979">  } else {</a>
<a name="ln980">    free_register(reg);</a>
<a name="ln981">    set_yreg_additional_data(reg, NULL);</a>
<a name="ln982">    reg-&gt;y_array = (char_u **)xmalloc(sizeof(char_u *));</a>
<a name="ln983">    reg-&gt;y_array[0] = p;</a>
<a name="ln984">    reg-&gt;y_size = 1;</a>
<a name="ln985">    reg-&gt;y_type = kMTCharWise;</a>
<a name="ln986">  }</a>
<a name="ln987">  reg-&gt;timestamp = os_time();</a>
<a name="ln988">  return OK;</a>
<a name="ln989">}</a>
<a name="ln990"> </a>
<a name="ln991">static int execreg_lastc = NUL;</a>
<a name="ln992"> </a>
<a name="ln993">/// Execute a yank register: copy it into the stuff buffer</a>
<a name="ln994">///</a>
<a name="ln995">/// Return FAIL for failure, OK otherwise</a>
<a name="ln996">int</a>
<a name="ln997">do_execreg(</a>
<a name="ln998">    int regname,</a>
<a name="ln999">    int colon,                      /* insert ':' before each line */</a>
<a name="ln1000">    int addcr,                      /* always add '\n' to end of line */</a>
<a name="ln1001">    int silent                     /* set &quot;silent&quot; flag in typeahead buffer */</a>
<a name="ln1002">)</a>
<a name="ln1003">{</a>
<a name="ln1004">  char_u *p;</a>
<a name="ln1005">  int retval = OK;</a>
<a name="ln1006"> </a>
<a name="ln1007">  if (regname == '@') {                 /* repeat previous one */</a>
<a name="ln1008">    if (execreg_lastc == NUL) {</a>
<a name="ln1009">      EMSG(_(&quot;E748: No previously used register&quot;));</a>
<a name="ln1010">      return FAIL;</a>
<a name="ln1011">    }</a>
<a name="ln1012">    regname = execreg_lastc;</a>
<a name="ln1013">  }</a>
<a name="ln1014">  /* check for valid regname */</a>
<a name="ln1015">  if (regname == '%' || regname == '#' || !valid_yank_reg(regname, false)) {</a>
<a name="ln1016">    emsg_invreg(regname);</a>
<a name="ln1017">    return FAIL;</a>
<a name="ln1018">  }</a>
<a name="ln1019">  execreg_lastc = regname;</a>
<a name="ln1020"> </a>
<a name="ln1021">  if (regname == '_')                   /* black hole: don't stuff anything */</a>
<a name="ln1022">    return OK;</a>
<a name="ln1023"> </a>
<a name="ln1024">  if (regname == ':') {                 /* use last command line */</a>
<a name="ln1025">    if (last_cmdline == NULL) {</a>
<a name="ln1026">      EMSG(_(e_nolastcmd));</a>
<a name="ln1027">      return FAIL;</a>
<a name="ln1028">    }</a>
<a name="ln1029">    // don't keep the cmdline containing @:</a>
<a name="ln1030">    XFREE_CLEAR(new_last_cmdline);</a>
<a name="ln1031">    // Escape all control characters with a CTRL-V</a>
<a name="ln1032">    p = vim_strsave_escaped_ext(</a>
<a name="ln1033">        last_cmdline,</a>
<a name="ln1034">        (char_u *)&quot;\001\002\003\004\005\006\007&quot;</a>
<a name="ln1035">        &quot;\010\011\012\013\014\015\016\017&quot;</a>
<a name="ln1036">        &quot;\020\021\022\023\024\025\026\027&quot;</a>
<a name="ln1037">        &quot;\030\031\032\033\034\035\036\037&quot;,</a>
<a name="ln1038">        Ctrl_V, false);</a>
<a name="ln1039">    // When in Visual mode &quot;'&lt;,'&gt;&quot; will be prepended to the command.</a>
<a name="ln1040">    // Remove it when it's already there.</a>
<a name="ln1041">    if (VIsual_active &amp;&amp; STRNCMP(p, &quot;'&lt;,'&gt;&quot;, 5) == 0) {</a>
<a name="ln1042">      retval = put_in_typebuf(p + 5, true, true, silent);</a>
<a name="ln1043">    } else {</a>
<a name="ln1044">      retval = put_in_typebuf(p, true, true, silent);</a>
<a name="ln1045">    }</a>
<a name="ln1046">    xfree(p);</a>
<a name="ln1047">  } else if (regname == '=') {</a>
<a name="ln1048">    p = get_expr_line();</a>
<a name="ln1049">    if (p == NULL)</a>
<a name="ln1050">      return FAIL;</a>
<a name="ln1051">    retval = put_in_typebuf(p, true, colon, silent);</a>
<a name="ln1052">    xfree(p);</a>
<a name="ln1053">  } else if (regname == '.') {        /* use last inserted text */</a>
<a name="ln1054">    p = get_last_insert_save();</a>
<a name="ln1055">    if (p == NULL) {</a>
<a name="ln1056">      EMSG(_(e_noinstext));</a>
<a name="ln1057">      return FAIL;</a>
<a name="ln1058">    }</a>
<a name="ln1059">    retval = put_in_typebuf(p, false, colon, silent);</a>
<a name="ln1060">    xfree(p);</a>
<a name="ln1061">  } else {</a>
<a name="ln1062">    yankreg_T *reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln1063">    if (reg-&gt;y_array == NULL)</a>
<a name="ln1064">      return FAIL;</a>
<a name="ln1065"> </a>
<a name="ln1066">    // Disallow remaping for &quot;:@r&quot;.</a>
<a name="ln1067">    int remap = colon ? REMAP_NONE : REMAP_YES;</a>
<a name="ln1068"> </a>
<a name="ln1069">    /*</a>
<a name="ln1070">     * Insert lines into typeahead buffer, from last one to first one.</a>
<a name="ln1071">     */</a>
<a name="ln1072">    put_reedit_in_typebuf(silent);</a>
<a name="ln1073">    char_u *escaped;</a>
<a name="ln1074">    for (size_t i = reg-&gt;y_size; i-- &gt; 0;) {  // from y_size - 1 to 0 included</a>
<a name="ln1075">      // insert NL between lines and after last line if type is kMTLineWise</a>
<a name="ln1076">      if (reg-&gt;y_type == kMTLineWise || i &lt; reg-&gt;y_size - 1 || addcr) {</a>
<a name="ln1077">        if (ins_typebuf((char_u *)&quot;\n&quot;, remap, 0, true, silent) == FAIL) {</a>
<a name="ln1078">          return FAIL;</a>
<a name="ln1079">        }</a>
<a name="ln1080">      }</a>
<a name="ln1081">      escaped = vim_strsave_escape_csi(reg-&gt;y_array[i]);</a>
<a name="ln1082">      retval = ins_typebuf(escaped, remap, 0, true, silent);</a>
<a name="ln1083">      xfree(escaped);</a>
<a name="ln1084">      if (retval == FAIL) {</a>
<a name="ln1085">        return FAIL;</a>
<a name="ln1086">      }</a>
<a name="ln1087">      if (colon</a>
<a name="ln1088">          &amp;&amp; ins_typebuf((char_u *)&quot;:&quot;, remap, 0, true, silent) == FAIL) {</a>
<a name="ln1089">        return FAIL;</a>
<a name="ln1090">      }</a>
<a name="ln1091">    }</a>
<a name="ln1092">    reg_executing = regname == 0 ? '&quot;' : regname;  // disable the 'q' command</a>
<a name="ln1093">  }</a>
<a name="ln1094">  return retval;</a>
<a name="ln1095">}</a>
<a name="ln1096"> </a>
<a name="ln1097">/*</a>
<a name="ln1098"> * If &quot;restart_edit&quot; is not zero, put it in the typeahead buffer, so that it's</a>
<a name="ln1099"> * used only after other typeahead has been processed.</a>
<a name="ln1100"> */</a>
<a name="ln1101">static void put_reedit_in_typebuf(int silent)</a>
<a name="ln1102">{</a>
<a name="ln1103">  char_u buf[3];</a>
<a name="ln1104"> </a>
<a name="ln1105">  if (restart_edit != NUL) {</a>
<a name="ln1106">    if (restart_edit == 'V') {</a>
<a name="ln1107">      buf[0] = 'g';</a>
<a name="ln1108">      buf[1] = 'R';</a>
<a name="ln1109">      buf[2] = NUL;</a>
<a name="ln1110">    } else {</a>
<a name="ln1111">      buf[0] = (char_u)(restart_edit == 'I' ? 'i' : restart_edit);</a>
<a name="ln1112">      buf[1] = NUL;</a>
<a name="ln1113">    }</a>
<a name="ln1114">    if (ins_typebuf(buf, REMAP_NONE, 0, true, silent) == OK) {</a>
<a name="ln1115">      restart_edit = NUL;</a>
<a name="ln1116">    }</a>
<a name="ln1117">  }</a>
<a name="ln1118">}</a>
<a name="ln1119"> </a>
<a name="ln1120">/*</a>
<a name="ln1121"> * Insert register contents &quot;s&quot; into the typeahead buffer, so that it will be</a>
<a name="ln1122"> * executed again.</a>
<a name="ln1123"> * When &quot;esc&quot; is TRUE it is to be taken literally: Escape CSI characters and</a>
<a name="ln1124"> * no remapping.</a>
<a name="ln1125"> */</a>
<a name="ln1126">static int put_in_typebuf(</a>
<a name="ln1127">    char_u *s,</a>
<a name="ln1128">    bool esc,</a>
<a name="ln1129">    bool colon,                 // add ':' before the line</a>
<a name="ln1130">    int silent</a>
<a name="ln1131">)</a>
<a name="ln1132">{</a>
<a name="ln1133">  int retval = OK;</a>
<a name="ln1134"> </a>
<a name="ln1135">  put_reedit_in_typebuf(silent);</a>
<a name="ln1136">  if (colon) {</a>
<a name="ln1137">    retval = ins_typebuf((char_u *)&quot;\n&quot;, REMAP_NONE, 0, true, silent);</a>
<a name="ln1138">  }</a>
<a name="ln1139">  if (retval == OK) {</a>
<a name="ln1140">    char_u  *p;</a>
<a name="ln1141"> </a>
<a name="ln1142">    if (esc) {</a>
<a name="ln1143">      p = vim_strsave_escape_csi(s);</a>
<a name="ln1144">    } else {</a>
<a name="ln1145">      p = s;</a>
<a name="ln1146">    }</a>
<a name="ln1147">    if (p == NULL) {</a>
<a name="ln1148">      retval = FAIL;</a>
<a name="ln1149">    } else {</a>
<a name="ln1150">      retval = ins_typebuf(p, esc ? REMAP_NONE : REMAP_YES, 0, true, silent);</a>
<a name="ln1151">    }</a>
<a name="ln1152">    if (esc) {</a>
<a name="ln1153">      xfree(p);</a>
<a name="ln1154">    }</a>
<a name="ln1155">  }</a>
<a name="ln1156">  if (colon &amp;&amp; retval == OK) {</a>
<a name="ln1157">    retval = ins_typebuf((char_u *)&quot;:&quot;, REMAP_NONE, 0, true, silent);</a>
<a name="ln1158">  }</a>
<a name="ln1159">  return retval;</a>
<a name="ln1160">}</a>
<a name="ln1161"> </a>
<a name="ln1162">/*</a>
<a name="ln1163"> * Insert a yank register: copy it into the Read buffer.</a>
<a name="ln1164"> * Used by CTRL-R command and middle mouse button in insert mode.</a>
<a name="ln1165"> *</a>
<a name="ln1166"> * return FAIL for failure, OK otherwise</a>
<a name="ln1167"> */</a>
<a name="ln1168">int insert_reg(</a>
<a name="ln1169">    int regname,</a>
<a name="ln1170">    bool literally_arg            // insert literally, not as if typed</a>
<a name="ln1171">)</a>
<a name="ln1172">{</a>
<a name="ln1173">  int retval = OK;</a>
<a name="ln1174">  bool allocated;</a>
<a name="ln1175">  const bool literally = literally_arg || is_literal_register(regname);</a>
<a name="ln1176"> </a>
<a name="ln1177">  /*</a>
<a name="ln1178">   * It is possible to get into an endless loop by having CTRL-R a in</a>
<a name="ln1179">   * register a and then, in insert mode, doing CTRL-R a.</a>
<a name="ln1180">   * If you hit CTRL-C, the loop will be broken here.</a>
<a name="ln1181">   */</a>
<a name="ln1182">  os_breakcheck();</a>
<a name="ln1183">  if (got_int)</a>
<a name="ln1184">    return FAIL;</a>
<a name="ln1185"> </a>
<a name="ln1186">  /* check for valid regname */</a>
<a name="ln1187">  if (regname != NUL &amp;&amp; !valid_yank_reg(regname, false))</a>
<a name="ln1188">    return FAIL;</a>
<a name="ln1189"> </a>
<a name="ln1190">  char_u *arg;</a>
<a name="ln1191">  if (regname == '.') {  // Insert last inserted text.</a>
<a name="ln1192">    retval = stuff_inserted(NUL, 1L, true);</a>
<a name="ln1193">  } else if (get_spec_reg(regname, &amp;arg, &amp;allocated, true)) {</a>
<a name="ln1194">    if (arg == NULL) {</a>
<a name="ln1195">      return FAIL;</a>
<a name="ln1196">    }</a>
<a name="ln1197">    stuffescaped((const char *)arg, literally);</a>
<a name="ln1198">    if (allocated) {</a>
<a name="ln1199">      xfree(arg);</a>
<a name="ln1200">    }</a>
<a name="ln1201">  } else {  // Name or number register.</a>
<a name="ln1202">    yankreg_T *reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln1203">    if (reg-&gt;y_array == NULL) {</a>
<a name="ln1204">      retval = FAIL;</a>
<a name="ln1205">    } else {</a>
<a name="ln1206">      for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln1207">        if (regname == '-') {</a>
<a name="ln1208">          AppendCharToRedobuff(Ctrl_R);</a>
<a name="ln1209">          AppendCharToRedobuff(regname);</a>
<a name="ln1210">          do_put(regname, NULL, BACKWARD, 1L, PUT_CURSEND);</a>
<a name="ln1211">        } else {</a>
<a name="ln1212">          stuffescaped((const char *)reg-&gt;y_array[i], literally);</a>
<a name="ln1213">        }</a>
<a name="ln1214">        // Insert a newline between lines and after last line if</a>
<a name="ln1215">        // y_type is kMTLineWise.</a>
<a name="ln1216">        if (reg-&gt;y_type == kMTLineWise || i &lt; reg-&gt;y_size - 1) {</a>
<a name="ln1217">          stuffcharReadbuff('\n');</a>
<a name="ln1218">        }</a>
<a name="ln1219">      }</a>
<a name="ln1220">    }</a>
<a name="ln1221">  }</a>
<a name="ln1222"> </a>
<a name="ln1223">  return retval;</a>
<a name="ln1224">}</a>
<a name="ln1225"> </a>
<a name="ln1226">/*</a>
<a name="ln1227"> * Stuff a string into the typeahead buffer, such that edit() will insert it</a>
<a name="ln1228"> * literally (&quot;literally&quot; TRUE) or interpret is as typed characters.</a>
<a name="ln1229"> */</a>
<a name="ln1230">static void stuffescaped(const char *arg, int literally)</a>
<a name="ln1231">{</a>
<a name="ln1232">  while (*arg != NUL) {</a>
<a name="ln1233">    // Stuff a sequence of normal ASCII characters, that's fast.  Also</a>
<a name="ln1234">    // stuff K_SPECIAL to get the effect of a special key when &quot;literally&quot;</a>
<a name="ln1235">    // is TRUE.</a>
<a name="ln1236">    const char *const start = arg;</a>
<a name="ln1237">    while ((*arg &gt;= ' ' &amp;&amp; *arg &lt; DEL) || ((uint8_t)(*arg) == K_SPECIAL</a>
<a name="ln1238">                                           &amp;&amp; !literally)) {</a>
<a name="ln1239">      arg++;</a>
<a name="ln1240">    }</a>
<a name="ln1241">    if (arg &gt; start) {</a>
<a name="ln1242">      stuffReadbuffLen(start, (long)(arg - start));</a>
<a name="ln1243">    }</a>
<a name="ln1244"> </a>
<a name="ln1245">    /* stuff a single special character */</a>
<a name="ln1246">    if (*arg != NUL) {</a>
<a name="ln1247">      const int c = mb_cptr2char_adv((const char_u **)&amp;arg);</a>
<a name="ln1248">      if (literally &amp;&amp; ((c &lt; ' ' &amp;&amp; c != TAB) || c == DEL)) {</a>
<a name="ln1249">        stuffcharReadbuff(Ctrl_V);</a>
<a name="ln1250">      }</a>
<a name="ln1251">      stuffcharReadbuff(c);</a>
<a name="ln1252">    }</a>
<a name="ln1253">  }</a>
<a name="ln1254">}</a>
<a name="ln1255"> </a>
<a name="ln1256">// If &quot;regname&quot; is a special register, return true and store a pointer to its</a>
<a name="ln1257">// value in &quot;argp&quot;.</a>
<a name="ln1258">bool get_spec_reg(</a>
<a name="ln1259">    int regname,</a>
<a name="ln1260">    char_u **argp,</a>
<a name="ln1261">    bool *allocated,        // return: true when value was allocated</a>
<a name="ln1262">    bool errmsg             // give error message when failing</a>
<a name="ln1263">)</a>
<a name="ln1264">{</a>
<a name="ln1265">  size_t cnt;</a>
<a name="ln1266"> </a>
<a name="ln1267">  *argp = NULL;</a>
<a name="ln1268">  *allocated = false;</a>
<a name="ln1269">  switch (regname) {</a>
<a name="ln1270">  case '%':                     /* file name */</a>
<a name="ln1271">    if (errmsg)</a>
<a name="ln1272">      check_fname();            /* will give emsg if not set */</a>
<a name="ln1273">    *argp = curbuf-&gt;b_fname;</a>
<a name="ln1274">    return true;</a>
<a name="ln1275"> </a>
<a name="ln1276">  case '#':                       // alternate file name</a>
<a name="ln1277">    *argp = getaltfname(errmsg);  // may give emsg if not set</a>
<a name="ln1278">    return true;</a>
<a name="ln1279"> </a>
<a name="ln1280">  case '=':                     /* result of expression */</a>
<a name="ln1281">    *argp = get_expr_line();</a>
<a name="ln1282">    *allocated = true;</a>
<a name="ln1283">    return true;</a>
<a name="ln1284"> </a>
<a name="ln1285">  case ':':                     /* last command line */</a>
<a name="ln1286">    if (last_cmdline == NULL &amp;&amp; errmsg)</a>
<a name="ln1287">      EMSG(_(e_nolastcmd));</a>
<a name="ln1288">    *argp = last_cmdline;</a>
<a name="ln1289">    return true;</a>
<a name="ln1290"> </a>
<a name="ln1291">  case '/':                     /* last search-pattern */</a>
<a name="ln1292">    if (last_search_pat() == NULL &amp;&amp; errmsg)</a>
<a name="ln1293">      EMSG(_(e_noprevre));</a>
<a name="ln1294">    *argp = last_search_pat();</a>
<a name="ln1295">    return true;</a>
<a name="ln1296"> </a>
<a name="ln1297">  case '.':                     /* last inserted text */</a>
<a name="ln1298">    *argp = get_last_insert_save();</a>
<a name="ln1299">    *allocated = true;</a>
<a name="ln1300">    if (*argp == NULL &amp;&amp; errmsg) {</a>
<a name="ln1301">      EMSG(_(e_noinstext));</a>
<a name="ln1302">    }</a>
<a name="ln1303">    return true;</a>
<a name="ln1304"> </a>
<a name="ln1305">  case Ctrl_F:                  // Filename under cursor</a>
<a name="ln1306">  case Ctrl_P:                  // Path under cursor, expand via &quot;path&quot;</a>
<a name="ln1307">    if (!errmsg) {</a>
<a name="ln1308">      return false;</a>
<a name="ln1309">    }</a>
<a name="ln1310">    *argp = file_name_at_cursor(</a>
<a name="ln1311">        FNAME_MESS | FNAME_HYP | (regname == Ctrl_P ? FNAME_EXP : 0),</a>
<a name="ln1312">        1L, NULL);</a>
<a name="ln1313">    *allocated = true;</a>
<a name="ln1314">    return true;</a>
<a name="ln1315"> </a>
<a name="ln1316">  case Ctrl_W:                  // word under cursor</a>
<a name="ln1317">  case Ctrl_A:                  // WORD (mnemonic All) under cursor</a>
<a name="ln1318">    if (!errmsg) {</a>
<a name="ln1319">      return false;</a>
<a name="ln1320">    }</a>
<a name="ln1321">    cnt = find_ident_under_cursor(argp, (regname == Ctrl_W</a>
<a name="ln1322">                                         ? (FIND_IDENT|FIND_STRING)</a>
<a name="ln1323">                                         : FIND_STRING));</a>
<a name="ln1324">    *argp = cnt ? vim_strnsave(*argp, cnt) : NULL;</a>
<a name="ln1325">    *allocated = true;</a>
<a name="ln1326">    return true;</a>
<a name="ln1327"> </a>
<a name="ln1328">  case Ctrl_L:                  // Line under cursor</a>
<a name="ln1329">    if (!errmsg) {</a>
<a name="ln1330">      return false;</a>
<a name="ln1331">    }</a>
<a name="ln1332"> </a>
<a name="ln1333">    *argp = ml_get_buf(curwin-&gt;w_buffer, curwin-&gt;w_cursor.lnum, false);</a>
<a name="ln1334">    return true;</a>
<a name="ln1335"> </a>
<a name="ln1336">  case '_':                     /* black hole: always empty */</a>
<a name="ln1337">    *argp = (char_u *)&quot;&quot;;</a>
<a name="ln1338">    return true;</a>
<a name="ln1339">  }</a>
<a name="ln1340"> </a>
<a name="ln1341">  return false;</a>
<a name="ln1342">}</a>
<a name="ln1343"> </a>
<a name="ln1344">/// Paste a yank register into the command line.</a>
<a name="ln1345">/// Only for non-special registers.</a>
<a name="ln1346">/// Used by CTRL-R in command-line mode.</a>
<a name="ln1347">/// insert_reg() can't be used here, because special characters from the</a>
<a name="ln1348">/// register contents will be interpreted as commands.</a>
<a name="ln1349">///</a>
<a name="ln1350">/// @param regname   Register name.</a>
<a name="ln1351">/// @param literally_arg Insert text literally instead of &quot;as typed&quot;.</a>
<a name="ln1352">/// @param remcr     When true, don't add CR characters.</a>
<a name="ln1353">///</a>
<a name="ln1354">/// @returns FAIL for failure, OK otherwise</a>
<a name="ln1355">bool cmdline_paste_reg(int regname, bool literally_arg, bool remcr)</a>
<a name="ln1356">{</a>
<a name="ln1357">  const bool literally = literally_arg || is_literal_register(regname);</a>
<a name="ln1358"> </a>
<a name="ln1359">  yankreg_T *reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln1360">  if (reg-&gt;y_array == NULL)</a>
<a name="ln1361">    return FAIL;</a>
<a name="ln1362"> </a>
<a name="ln1363">  for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln1364">    cmdline_paste_str(reg-&gt;y_array[i], literally);</a>
<a name="ln1365"> </a>
<a name="ln1366">    // Insert ^M between lines, unless `remcr` is true.</a>
<a name="ln1367">    if (i &lt; reg-&gt;y_size - 1 &amp;&amp; !remcr) {</a>
<a name="ln1368">      cmdline_paste_str((char_u *)&quot;\r&quot;, literally);</a>
<a name="ln1369">    }</a>
<a name="ln1370"> </a>
<a name="ln1371">    /* Check for CTRL-C, in case someone tries to paste a few thousand</a>
<a name="ln1372">     * lines and gets bored. */</a>
<a name="ln1373">    os_breakcheck();</a>
<a name="ln1374">    if (got_int)</a>
<a name="ln1375">      return FAIL;</a>
<a name="ln1376">  }</a>
<a name="ln1377">  return OK;</a>
<a name="ln1378">}</a>
<a name="ln1379"> </a>
<a name="ln1380">// Shift the delete registers: &quot;9 is cleared, &quot;8 becomes &quot;9, etc.</a>
<a name="ln1381">static void shift_delete_registers(bool y_append)</a>
<a name="ln1382">{</a>
<a name="ln1383">  free_register(&amp;y_regs[9]);  // free register &quot;9</a>
<a name="ln1384">  for (int n = 9; n &gt; 1; n--) {</a>
<a name="ln1385">    y_regs[n] = y_regs[n - 1];</a>
<a name="ln1386">  }</a>
<a name="ln1387">  if (!y_append) {</a>
<a name="ln1388">    y_previous = &amp;y_regs[1];</a>
<a name="ln1389">  }</a>
<a name="ln1390">  y_regs[1].y_array = NULL;  // set register &quot;1 to empty</a>
<a name="ln1391">}</a>
<a name="ln1392"> </a>
<a name="ln1393">/*</a>
<a name="ln1394"> * Handle a delete operation.</a>
<a name="ln1395"> *</a>
<a name="ln1396"> * Return FAIL if undo failed, OK otherwise.</a>
<a name="ln1397"> */</a>
<a name="ln1398">int op_delete(oparg_T *oap)</a>
<a name="ln1399">{</a>
<a name="ln1400">  int n;</a>
<a name="ln1401">  linenr_T lnum;</a>
<a name="ln1402">  char_u              *ptr;</a>
<a name="ln1403">  char_u              *newp, *oldp;</a>
<a name="ln1404">  struct block_def bd = { 0 };</a>
<a name="ln1405">  linenr_T old_lcount = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1406"> </a>
<a name="ln1407">  if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {  // nothing to do</a>
<a name="ln1408">    return OK;</a>
<a name="ln1409">  }</a>
<a name="ln1410"> </a>
<a name="ln1411">  // Nothing to delete, return here. Do prepare undo, for op_change().</a>
<a name="ln1412">  if (oap-&gt;empty) {</a>
<a name="ln1413">    return u_save_cursor();</a>
<a name="ln1414">  }</a>
<a name="ln1415"> </a>
<a name="ln1416">  if (!MODIFIABLE(curbuf)) {</a>
<a name="ln1417">    EMSG(_(e_modifiable));</a>
<a name="ln1418">    return FAIL;</a>
<a name="ln1419">  }</a>
<a name="ln1420"> </a>
<a name="ln1421">  mb_adjust_opend(oap);</a>
<a name="ln1422"> </a>
<a name="ln1423">  /*</a>
<a name="ln1424">   * Imitate the strange Vi behaviour: If the delete spans more than one</a>
<a name="ln1425">   * line and motion_type == kMTCharWise and the result is a blank line, make the</a>
<a name="ln1426">   * delete linewise.  Don't do this for the change command or Visual mode.</a>
<a name="ln1427">   */</a>
<a name="ln1428">  if (oap-&gt;motion_type == kMTCharWise</a>
<a name="ln1429">      &amp;&amp; !oap-&gt;is_VIsual</a>
<a name="ln1430">      &amp;&amp; oap-&gt;line_count &gt; 1</a>
<a name="ln1431">      &amp;&amp; oap-&gt;motion_force == NUL</a>
<a name="ln1432">      &amp;&amp; oap-&gt;op_type == OP_DELETE) {</a>
<a name="ln1433">    ptr = ml_get(oap-&gt;end.lnum) + oap-&gt;end.col;</a>
<a name="ln1434">    if (*ptr != NUL)</a>
<a name="ln1435">      ptr += oap-&gt;inclusive;</a>
<a name="ln1436">    ptr = skipwhite(ptr);</a>
<a name="ln1437">    if (*ptr == NUL &amp;&amp; inindent(0)) {</a>
<a name="ln1438">      oap-&gt;motion_type = kMTLineWise;</a>
<a name="ln1439">    }</a>
<a name="ln1440">  }</a>
<a name="ln1441"> </a>
<a name="ln1442">  /*</a>
<a name="ln1443">   * Check for trying to delete (e.g. &quot;D&quot;) in an empty line.</a>
<a name="ln1444">   * Note: For the change operator it is ok.</a>
<a name="ln1445">   */</a>
<a name="ln1446">  if (oap-&gt;motion_type != kMTLineWise</a>
<a name="ln1447">      &amp;&amp; oap-&gt;line_count == 1</a>
<a name="ln1448">      &amp;&amp; oap-&gt;op_type == OP_DELETE</a>
<a name="ln1449">      &amp;&amp; *ml_get(oap-&gt;start.lnum) == NUL) {</a>
<a name="ln1450">    // It's an error to operate on an empty region, when 'E' included in</a>
<a name="ln1451">    // 'cpoptions' (Vi compatible).</a>
<a name="ln1452">    if (virtual_op) {</a>
<a name="ln1453">      // Virtual editing: Nothing gets deleted, but we set the '[ and ']</a>
<a name="ln1454">      // marks as if it happened.</a>
<a name="ln1455">      goto setmarks;</a>
<a name="ln1456">    }</a>
<a name="ln1457">    if (vim_strchr(p_cpo, CPO_EMPTYREGION) != NULL) {</a>
<a name="ln1458">      beep_flush();</a>
<a name="ln1459">    }</a>
<a name="ln1460">    return OK;</a>
<a name="ln1461">  }</a>
<a name="ln1462"> </a>
<a name="ln1463">  /*</a>
<a name="ln1464">   * Do a yank of whatever we're about to delete.</a>
<a name="ln1465">   * If a yank register was specified, put the deleted text into that</a>
<a name="ln1466">   * register.  For the black hole register '_' don't yank anything.</a>
<a name="ln1467">   */</a>
<a name="ln1468">  if (oap-&gt;regname != '_') {</a>
<a name="ln1469">    yankreg_T *reg = NULL;</a>
<a name="ln1470">    int did_yank = false;</a>
<a name="ln1471">    if (oap-&gt;regname != 0) {</a>
<a name="ln1472">      // yank without message</a>
<a name="ln1473">      did_yank = op_yank(oap, false, true);</a>
<a name="ln1474">      if (!did_yank) {</a>
<a name="ln1475">        // op_yank failed, don't do anything</a>
<a name="ln1476">        return OK;</a>
<a name="ln1477">      }</a>
<a name="ln1478">    }</a>
<a name="ln1479"> </a>
<a name="ln1480">    /*</a>
<a name="ln1481">     * Put deleted text into register 1 and shift number registers if the</a>
<a name="ln1482">     * delete contains a line break, or when a regname has been specified.</a>
<a name="ln1483">     */</a>
<a name="ln1484">    if (oap-&gt;regname != 0 || oap-&gt;motion_type == kMTLineWise</a>
<a name="ln1485">        || oap-&gt;line_count &gt; 1 || oap-&gt;use_reg_one) {</a>
<a name="ln1486">      shift_delete_registers(is_append_register(oap-&gt;regname));</a>
<a name="ln1487">      reg = &amp;y_regs[1];</a>
<a name="ln1488">      op_yank_reg(oap, false, reg, false);</a>
<a name="ln1489">      did_yank = true;</a>
<a name="ln1490">    }</a>
<a name="ln1491"> </a>
<a name="ln1492">    /* Yank into small delete register when no named register specified</a>
<a name="ln1493">     * and the delete is within one line. */</a>
<a name="ln1494">    if (oap-&gt;regname == 0 &amp;&amp; oap-&gt;motion_type != kMTLineWise</a>
<a name="ln1495">        &amp;&amp; oap-&gt;line_count == 1) {</a>
<a name="ln1496">      reg = get_yank_register('-', YREG_YANK);</a>
<a name="ln1497">      op_yank_reg(oap, false, reg, false);</a>
<a name="ln1498">      did_yank = true;</a>
<a name="ln1499">    }</a>
<a name="ln1500"> </a>
<a name="ln1501">    if (did_yank || oap-&gt;regname == 0) {</a>
<a name="ln1502">      if (reg == NULL) {</a>
<a name="ln1503">        abort();</a>
<a name="ln1504">      }</a>
<a name="ln1505">      set_clipboard(oap-&gt;regname, reg);</a>
<a name="ln1506">      do_autocmd_textyankpost(oap, reg);</a>
<a name="ln1507">    }</a>
<a name="ln1508"> </a>
<a name="ln1509">  }</a>
<a name="ln1510"> </a>
<a name="ln1511">  /*</a>
<a name="ln1512">   * block mode delete</a>
<a name="ln1513">   */</a>
<a name="ln1514">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln1515">    if (u_save((linenr_T)(oap-&gt;start.lnum - 1),</a>
<a name="ln1516">               (linenr_T)(oap-&gt;end.lnum + 1)) == FAIL) {</a>
<a name="ln1517">      return FAIL;</a>
<a name="ln1518">    }</a>
<a name="ln1519"> </a>
<a name="ln1520">    for (lnum = curwin-&gt;w_cursor.lnum; lnum &lt;= oap-&gt;end.lnum; lnum++) {</a>
<a name="ln1521">      block_prep(oap, &amp;bd, lnum, true);</a>
<a name="ln1522">      if (bd.textlen == 0) {            // nothing to delete</a>
<a name="ln1523">        continue;</a>
<a name="ln1524">      }</a>
<a name="ln1525"> </a>
<a name="ln1526">      /* Adjust cursor position for tab replaced by spaces and 'lbr'. */</a>
<a name="ln1527">      if (lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln1528">        curwin-&gt;w_cursor.col = bd.textcol + bd.startspaces;</a>
<a name="ln1529">        curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln1530">      }</a>
<a name="ln1531"> </a>
<a name="ln1532">      // n == number of chars deleted</a>
<a name="ln1533">      // If we delete a TAB, it may be replaced by several characters.</a>
<a name="ln1534">      // Thus the number of characters may increase!</a>
<a name="ln1535">      n = bd.textlen - bd.startspaces - bd.endspaces;</a>
<a name="ln1536">      oldp = ml_get(lnum);</a>
<a name="ln1537">      newp = (char_u *)xmalloc(STRLEN(oldp) - (size_t)n + 1);</a>
<a name="ln1538">      // copy up to deleted part</a>
<a name="ln1539">      memmove(newp, oldp, (size_t)bd.textcol);</a>
<a name="ln1540">      // insert spaces</a>
<a name="ln1541">      memset(newp + bd.textcol, ' ', (size_t)bd.startspaces +</a>
<a name="ln1542">             (size_t)bd.endspaces);</a>
<a name="ln1543">      // copy the part after the deleted part</a>
<a name="ln1544">      oldp += bd.textcol + bd.textlen;</a>
<a name="ln1545">      STRMOVE(newp + bd.textcol + bd.startspaces + bd.endspaces, oldp);</a>
<a name="ln1546">      // replace the line</a>
<a name="ln1547">      ml_replace(lnum, newp, false);</a>
<a name="ln1548"> </a>
<a name="ln1549">      extmark_splice_cols(curbuf, (int)lnum-1, bd.textcol,</a>
<a name="ln1550">                          bd.textlen, bd.startspaces+bd.endspaces,</a>
<a name="ln1551">                          kExtmarkUndo);</a>
<a name="ln1552">    }</a>
<a name="ln1553"> </a>
<a name="ln1554">    check_cursor_col();</a>
<a name="ln1555">    changed_lines(curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.col,</a>
<a name="ln1556">                  oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln1557">    oap-&gt;line_count = 0;  // no lines deleted</a>
<a name="ln1558">  } else if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln1559">    if (oap-&gt;op_type == OP_CHANGE) {</a>
<a name="ln1560">      // Delete the lines except the first one.  Temporarily move the</a>
<a name="ln1561">      // cursor to the next line.  Save the current line number, if the</a>
<a name="ln1562">      // last line is deleted it may be changed.</a>
<a name="ln1563"> </a>
<a name="ln1564">      if (oap-&gt;line_count &gt; 1) {</a>
<a name="ln1565">        lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1566">        ++curwin-&gt;w_cursor.lnum;</a>
<a name="ln1567">        del_lines(oap-&gt;line_count - 1, TRUE);</a>
<a name="ln1568">        curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln1569">      }</a>
<a name="ln1570">      if (u_save_cursor() == FAIL)</a>
<a name="ln1571">        return FAIL;</a>
<a name="ln1572">      if (curbuf-&gt;b_p_ai) {                 // don't delete indent</a>
<a name="ln1573">        beginline(BL_WHITE);                // cursor on first non-white</a>
<a name="ln1574">        did_ai = true;                      // delete the indent when ESC hit</a>
<a name="ln1575">        ai_col = curwin-&gt;w_cursor.col;</a>
<a name="ln1576">      } else {</a>
<a name="ln1577">        beginline(0);                       // cursor in column 0</a>
<a name="ln1578">      }</a>
<a name="ln1579"> </a>
<a name="ln1580">      int old_len = (int)STRLEN(ml_get(curwin-&gt;w_cursor.lnum));</a>
<a name="ln1581">      truncate_line(false);         // delete the rest of the line</a>
<a name="ln1582"> </a>
<a name="ln1583">      extmark_splice_cols(curbuf,</a>
<a name="ln1584">                          (int)curwin-&gt;w_cursor.lnum-1, curwin-&gt;w_cursor.col,</a>
<a name="ln1585">                          old_len - curwin-&gt;w_cursor.col, 0, kExtmarkUndo);</a>
<a name="ln1586"> </a>
<a name="ln1587">                                    // leave cursor past last char in line</a>
<a name="ln1588">      if (oap-&gt;line_count &gt; 1) {</a>
<a name="ln1589">        u_clearline();              // &quot;U&quot; command not possible after &quot;2cc&quot;</a>
<a name="ln1590">      }</a>
<a name="ln1591">    } else {</a>
<a name="ln1592">      del_lines(oap-&gt;line_count, TRUE);</a>
<a name="ln1593">      beginline(BL_WHITE | BL_FIX);</a>
<a name="ln1594">      u_clearline();            /* &quot;U&quot; command not possible after &quot;dd&quot; */</a>
<a name="ln1595">    }</a>
<a name="ln1596">  } else {</a>
<a name="ln1597">    if (virtual_op) {</a>
<a name="ln1598">      int endcol = 0;</a>
<a name="ln1599"> </a>
<a name="ln1600">      /* For virtualedit: break the tabs that are partly included. */</a>
<a name="ln1601">      if (gchar_pos(&amp;oap-&gt;start) == '\t') {</a>
<a name="ln1602">        if (u_save_cursor() == FAIL)            /* save first line for undo */</a>
<a name="ln1603">          return FAIL;</a>
<a name="ln1604">        if (oap-&gt;line_count == 1)</a>
<a name="ln1605">          endcol = getviscol2(oap-&gt;end.col, oap-&gt;end.coladd);</a>
<a name="ln1606">        coladvance_force(getviscol2(oap-&gt;start.col, oap-&gt;start.coladd));</a>
<a name="ln1607">        oap-&gt;start = curwin-&gt;w_cursor;</a>
<a name="ln1608">        if (oap-&gt;line_count == 1) {</a>
<a name="ln1609">          coladvance(endcol);</a>
<a name="ln1610">          oap-&gt;end.col = curwin-&gt;w_cursor.col;</a>
<a name="ln1611">          oap-&gt;end.coladd = curwin-&gt;w_cursor.coladd;</a>
<a name="ln1612">          curwin-&gt;w_cursor = oap-&gt;start;</a>
<a name="ln1613">        }</a>
<a name="ln1614">      }</a>
<a name="ln1615"> </a>
<a name="ln1616">      /* Break a tab only when it's included in the area. */</a>
<a name="ln1617">      if (gchar_pos(&amp;oap-&gt;end) == '\t'</a>
<a name="ln1618">          &amp;&amp; oap-&gt;end.coladd == 0</a>
<a name="ln1619">          &amp;&amp; oap-&gt;inclusive) {</a>
<a name="ln1620">        /* save last line for undo */</a>
<a name="ln1621">        if (u_save((linenr_T)(oap-&gt;end.lnum - 1),</a>
<a name="ln1622">                (linenr_T)(oap-&gt;end.lnum + 1)) == FAIL)</a>
<a name="ln1623">          return FAIL;</a>
<a name="ln1624">        curwin-&gt;w_cursor = oap-&gt;end;</a>
<a name="ln1625">        coladvance_force(getviscol2(oap-&gt;end.col, oap-&gt;end.coladd));</a>
<a name="ln1626">        oap-&gt;end = curwin-&gt;w_cursor;</a>
<a name="ln1627">        curwin-&gt;w_cursor = oap-&gt;start;</a>
<a name="ln1628">      }</a>
<a name="ln1629">      mb_adjust_opend(oap);</a>
<a name="ln1630">    }</a>
<a name="ln1631"> </a>
<a name="ln1632">    if (oap-&gt;line_count == 1) {         /* delete characters within one line */</a>
<a name="ln1633">      if (u_save_cursor() == FAIL)              /* save line for undo */</a>
<a name="ln1634">        return FAIL;</a>
<a name="ln1635"> </a>
<a name="ln1636">      /* if 'cpoptions' contains '$', display '$' at end of change */</a>
<a name="ln1637">      if (           vim_strchr(p_cpo, CPO_DOLLAR) != NULL</a>
<a name="ln1638">                     &amp;&amp; oap-&gt;op_type == OP_CHANGE</a>
<a name="ln1639">                     &amp;&amp; oap-&gt;end.lnum == curwin-&gt;w_cursor.lnum</a>
<a name="ln1640">                     &amp;&amp; !oap-&gt;is_VIsual</a>
<a name="ln1641">                     )</a>
<a name="ln1642">        display_dollar(oap-&gt;end.col - !oap-&gt;inclusive);</a>
<a name="ln1643"> </a>
<a name="ln1644">      n = oap-&gt;end.col - oap-&gt;start.col + 1 - !oap-&gt;inclusive;</a>
<a name="ln1645"> </a>
<a name="ln1646">      if (virtual_op) {</a>
<a name="ln1647">        /* fix up things for virtualedit-delete:</a>
<a name="ln1648">         * break the tabs which are going to get in our way</a>
<a name="ln1649">         */</a>
<a name="ln1650">        char_u          *curline = get_cursor_line_ptr();</a>
<a name="ln1651">        int len = (int)STRLEN(curline);</a>
<a name="ln1652"> </a>
<a name="ln1653">        if (oap-&gt;end.coladd != 0</a>
<a name="ln1654">            &amp;&amp; (int)oap-&gt;end.col &gt;= len - 1</a>
<a name="ln1655">            &amp;&amp; !(oap-&gt;start.coladd &amp;&amp; (int)oap-&gt;end.col &gt;= len - 1))</a>
<a name="ln1656">          n++;</a>
<a name="ln1657">        /* Delete at least one char (e.g, when on a control char). */</a>
<a name="ln1658">        if (n == 0 &amp;&amp; oap-&gt;start.coladd != oap-&gt;end.coladd)</a>
<a name="ln1659">          n = 1;</a>
<a name="ln1660"> </a>
<a name="ln1661">        /* When deleted a char in the line, reset coladd. */</a>
<a name="ln1662">        if (gchar_cursor() != NUL)</a>
<a name="ln1663">          curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln1664">      }</a>
<a name="ln1665"> </a>
<a name="ln1666">      (void)del_bytes((colnr_T)n, !virtual_op,</a>
<a name="ln1667">                      oap-&gt;op_type == OP_DELETE &amp;&amp; !oap-&gt;is_VIsual);</a>
<a name="ln1668">    } else {</a>
<a name="ln1669">      // delete characters between lines</a>
<a name="ln1670">      pos_T curpos;</a>
<a name="ln1671"> </a>
<a name="ln1672">      /* save deleted and changed lines for undo */</a>
<a name="ln1673">      if (u_save((linenr_T)(curwin-&gt;w_cursor.lnum - 1),</a>
<a name="ln1674">              (linenr_T)(curwin-&gt;w_cursor.lnum + oap-&gt;line_count)) == FAIL)</a>
<a name="ln1675">        return FAIL;</a>
<a name="ln1676"> </a>
<a name="ln1677">      curbuf_splice_pending++;</a>
<a name="ln1678">      pos_T startpos = curwin-&gt;w_cursor;  // start position for delete</a>
<a name="ln1679">      bcount_t deleted_bytes = (bcount_t)STRLEN(</a>
<a name="ln1680">          ml_get(startpos.lnum)) + 1 - startpos.col;</a>
<a name="ln1681">      truncate_line(true);        // delete from cursor to end of line</a>
<a name="ln1682"> </a>
<a name="ln1683">      curpos = curwin-&gt;w_cursor;  // remember curwin-&gt;w_cursor</a>
<a name="ln1684">      curwin-&gt;w_cursor.lnum++;</a>
<a name="ln1685"> </a>
<a name="ln1686">      for (linenr_T i = 1; i &lt;= oap-&gt;line_count - 2; i++) {</a>
<a name="ln1687">        deleted_bytes += (bcount_t)STRLEN(</a>
<a name="ln1688">            ml_get(startpos.lnum + i)) + 1;</a>
<a name="ln1689">      }</a>
<a name="ln1690">      del_lines(oap-&gt;line_count - 2, false);</a>
<a name="ln1691"> </a>
<a name="ln1692">      // delete from start of line until op_end</a>
<a name="ln1693">      n = (oap-&gt;end.col + 1 - !oap-&gt;inclusive);</a>
<a name="ln1694">      curwin-&gt;w_cursor.col = 0;</a>
<a name="ln1695">      (void)del_bytes((colnr_T)n, !virtual_op,</a>
<a name="ln1696">                      oap-&gt;op_type == OP_DELETE &amp;&amp; !oap-&gt;is_VIsual);</a>
<a name="ln1697">      deleted_bytes += n;</a>
<a name="ln1698">      curwin-&gt;w_cursor = curpos;  // restore curwin-&gt;w_cursor</a>
<a name="ln1699">      (void)do_join(2, false, false, false, false);</a>
<a name="ln1700">      curbuf_splice_pending--;</a>
<a name="ln1701">      extmark_splice(curbuf, (int)startpos.lnum-1, startpos.col,</a>
<a name="ln1702">                     (int)oap-&gt;line_count-1, n, deleted_bytes,</a>
<a name="ln1703">                     0, 0, 0, kExtmarkUndo);</a>
<a name="ln1704">    }</a>
<a name="ln1705">    auto_format(false, true);</a>
<a name="ln1706">  }</a>
<a name="ln1707"> </a>
<a name="ln1708">  msgmore(curbuf-&gt;b_ml.ml_line_count - old_lcount);</a>
<a name="ln1709"> </a>
<a name="ln1710">setmarks:</a>
<a name="ln1711">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln1712">    curbuf-&gt;b_op_end.lnum = oap-&gt;end.lnum;</a>
<a name="ln1713">    curbuf-&gt;b_op_end.col = oap-&gt;start.col;</a>
<a name="ln1714">  } else {</a>
<a name="ln1715">    curbuf-&gt;b_op_end = oap-&gt;start;</a>
<a name="ln1716">  }</a>
<a name="ln1717">  curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln1718"> </a>
<a name="ln1719">  return OK;</a>
<a name="ln1720">}</a>
<a name="ln1721"> </a>
<a name="ln1722">/*</a>
<a name="ln1723"> * Adjust end of operating area for ending on a multi-byte character.</a>
<a name="ln1724"> * Used for deletion.</a>
<a name="ln1725"> */</a>
<a name="ln1726">static void mb_adjust_opend(oparg_T *oap)</a>
<a name="ln1727">{</a>
<a name="ln1728">  char_u      *p;</a>
<a name="ln1729"> </a>
<a name="ln1730">  if (oap-&gt;inclusive) {</a>
<a name="ln1731">    p = ml_get(oap-&gt;end.lnum);</a>
<a name="ln1732">    oap-&gt;end.col += mb_tail_off(p, p + oap-&gt;end.col);</a>
<a name="ln1733">  }</a>
<a name="ln1734">}</a>
<a name="ln1735"> </a>
<a name="ln1736">/*</a>
<a name="ln1737"> * Put character 'c' at position 'lp'</a>
<a name="ln1738"> */</a>
<a name="ln1739">static inline void pbyte(pos_T lp, int c)</a>
<a name="ln1740">{</a>
<a name="ln1741">  assert(c &lt;= UCHAR_MAX);</a>
<a name="ln1742">  *(ml_get_buf(curbuf, lp.lnum, true) + lp.col) = (char_u)c;</a>
<a name="ln1743">  if (!curbuf_splice_pending) {</a>
<a name="ln1744">    extmark_splice_cols(curbuf, (int)lp.lnum-1, lp.col, 1, 1, kExtmarkUndo);</a>
<a name="ln1745">  }</a>
<a name="ln1746">}</a>
<a name="ln1747"> </a>
<a name="ln1748">// Replace the character under the cursor with &quot;c&quot;.</a>
<a name="ln1749">// This takes care of multi-byte characters.</a>
<a name="ln1750">static void replace_character(int c)</a>
<a name="ln1751">{</a>
<a name="ln1752">  const int n = State;</a>
<a name="ln1753"> </a>
<a name="ln1754">  State = REPLACE;</a>
<a name="ln1755">  ins_char(c);</a>
<a name="ln1756">  State = n;</a>
<a name="ln1757">  // Backup to the replaced character.</a>
<a name="ln1758">  dec_cursor();</a>
<a name="ln1759">}</a>
<a name="ln1760"> </a>
<a name="ln1761">/*</a>
<a name="ln1762"> * Replace a whole area with one character.</a>
<a name="ln1763"> */</a>
<a name="ln1764">int op_replace(oparg_T *oap, int c)</a>
<a name="ln1765">{</a>
<a name="ln1766">  int n, numc;</a>
<a name="ln1767">  int num_chars;</a>
<a name="ln1768">  char_u              *newp, *oldp;</a>
<a name="ln1769">  colnr_T oldlen;</a>
<a name="ln1770">  struct block_def bd;</a>
<a name="ln1771">  char_u              *after_p = NULL;</a>
<a name="ln1772">  int had_ctrl_v_cr = false;</a>
<a name="ln1773"> </a>
<a name="ln1774">  if ((curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY ) || oap-&gt;empty)</a>
<a name="ln1775">    return OK;              /* nothing to do */</a>
<a name="ln1776"> </a>
<a name="ln1777">  if (c == REPLACE_CR_NCHAR) {</a>
<a name="ln1778">    had_ctrl_v_cr = true;</a>
<a name="ln1779">    c = CAR;</a>
<a name="ln1780">  } else if (c == REPLACE_NL_NCHAR) {</a>
<a name="ln1781">    had_ctrl_v_cr = true;</a>
<a name="ln1782">    c = NL;</a>
<a name="ln1783">  }</a>
<a name="ln1784"> </a>
<a name="ln1785">  mb_adjust_opend(oap);</a>
<a name="ln1786"> </a>
<a name="ln1787">  if (u_save((linenr_T)(oap-&gt;start.lnum - 1),</a>
<a name="ln1788">          (linenr_T)(oap-&gt;end.lnum + 1)) == FAIL)</a>
<a name="ln1789">    return FAIL;</a>
<a name="ln1790"> </a>
<a name="ln1791">  /*</a>
<a name="ln1792">   * block mode replace</a>
<a name="ln1793">   */</a>
<a name="ln1794">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln1795">    bd.is_MAX = (curwin-&gt;w_curswant == MAXCOL);</a>
<a name="ln1796">    for (; curwin-&gt;w_cursor.lnum &lt;= oap-&gt;end.lnum; curwin-&gt;w_cursor.lnum++) {</a>
<a name="ln1797">      curwin-&gt;w_cursor.col = 0;       // make sure cursor position is valid</a>
<a name="ln1798">      block_prep(oap, &amp;bd, curwin-&gt;w_cursor.lnum, true);</a>
<a name="ln1799">      if (bd.textlen == 0 &amp;&amp; (!virtual_op || bd.is_MAX)) {</a>
<a name="ln1800">        continue;                     // nothing to replace</a>
<a name="ln1801">      }</a>
<a name="ln1802"> </a>
<a name="ln1803">      /* n == number of extra chars required</a>
<a name="ln1804">       * If we split a TAB, it may be replaced by several characters.</a>
<a name="ln1805">       * Thus the number of characters may increase!</a>
<a name="ln1806">       */</a>
<a name="ln1807">      /* If the range starts in virtual space, count the initial</a>
<a name="ln1808">       * coladd offset as part of &quot;startspaces&quot; */</a>
<a name="ln1809">      if (virtual_op &amp;&amp; bd.is_short &amp;&amp; *bd.textstart == NUL) {</a>
<a name="ln1810">        pos_T vpos;</a>
<a name="ln1811"> </a>
<a name="ln1812">        vpos.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1813">        getvpos(&amp;vpos, oap-&gt;start_vcol);</a>
<a name="ln1814">        bd.startspaces += vpos.coladd;</a>
<a name="ln1815">        n = bd.startspaces;</a>
<a name="ln1816">      } else</a>
<a name="ln1817">        /* allow for pre spaces */</a>
<a name="ln1818">        n = (bd.startspaces ? bd.start_char_vcols - 1 : 0);</a>
<a name="ln1819"> </a>
<a name="ln1820">      /* allow for post spp */</a>
<a name="ln1821">      n += (bd.endspaces</a>
<a name="ln1822">            &amp;&amp; !bd.is_oneChar</a>
<a name="ln1823">            &amp;&amp; bd.end_char_vcols &gt; 0) ? bd.end_char_vcols - 1 : 0;</a>
<a name="ln1824">      /* Figure out how many characters to replace. */</a>
<a name="ln1825">      numc = oap-&gt;end_vcol - oap-&gt;start_vcol + 1;</a>
<a name="ln1826">      if (bd.is_short &amp;&amp; (!virtual_op || bd.is_MAX))</a>
<a name="ln1827">        numc -= (oap-&gt;end_vcol - bd.end_vcol) + 1;</a>
<a name="ln1828"> </a>
<a name="ln1829">      /* A double-wide character can be replaced only up to half the</a>
<a name="ln1830">       * times. */</a>
<a name="ln1831">      if ((*mb_char2cells)(c) &gt; 1) {</a>
<a name="ln1832">        if ((numc &amp; 1) &amp;&amp; !bd.is_short) {</a>
<a name="ln1833">          ++bd.endspaces;</a>
<a name="ln1834">          ++n;</a>
<a name="ln1835">        }</a>
<a name="ln1836">        numc = numc / 2;</a>
<a name="ln1837">      }</a>
<a name="ln1838"> </a>
<a name="ln1839">      /* Compute bytes needed, move character count to num_chars. */</a>
<a name="ln1840">      num_chars = numc;</a>
<a name="ln1841">      numc *= (*mb_char2len)(c);</a>
<a name="ln1842"> </a>
<a name="ln1843">      oldp = get_cursor_line_ptr();</a>
<a name="ln1844">      oldlen = (int)STRLEN(oldp);</a>
<a name="ln1845"> </a>
<a name="ln1846">      size_t newp_size = (size_t)bd.textcol + (size_t)bd.startspaces;</a>
<a name="ln1847">      if (had_ctrl_v_cr || (c != '\r' &amp;&amp; c != '\n')) {</a>
<a name="ln1848">        newp_size += (size_t)numc;</a>
<a name="ln1849">        if (!bd.is_short) {</a>
<a name="ln1850">          newp_size += (size_t)(bd.endspaces + oldlen</a>
<a name="ln1851">                                - bd.textcol - bd.textlen);</a>
<a name="ln1852">        }</a>
<a name="ln1853">      }</a>
<a name="ln1854">      newp = xmallocz(newp_size);</a>
<a name="ln1855">      // copy up to deleted part</a>
<a name="ln1856">      memmove(newp, oldp, (size_t)bd.textcol);</a>
<a name="ln1857">      oldp += bd.textcol + bd.textlen;</a>
<a name="ln1858">      // insert pre-spaces</a>
<a name="ln1859">      memset(newp + bd.textcol, ' ', (size_t)bd.startspaces);</a>
<a name="ln1860">      // insert replacement chars CHECK FOR ALLOCATED SPACE</a>
<a name="ln1861">      // REPLACE_CR_NCHAR/REPLACE_NL_NCHAR is used for entering CR literally.</a>
<a name="ln1862">      size_t after_p_len = 0;</a>
<a name="ln1863">      int col = oldlen - bd.textcol - bd.textlen + 1;</a>
<a name="ln1864">      assert(col &gt;= 0);</a>
<a name="ln1865">      int newrows = 0, newcols = 0;</a>
<a name="ln1866">      if (had_ctrl_v_cr || (c != '\r' &amp;&amp; c != '\n')) {</a>
<a name="ln1867">          // strlen(newp) at this point</a>
<a name="ln1868">          int newp_len = bd.textcol + bd.startspaces;</a>
<a name="ln1869">          while (--num_chars &gt;= 0) {</a>
<a name="ln1870">            newp_len += utf_char2bytes(c, newp + newp_len);</a>
<a name="ln1871">          }</a>
<a name="ln1872">          if (!bd.is_short) {</a>
<a name="ln1873">            // insert post-spaces</a>
<a name="ln1874">            memset(newp + newp_len, ' ', (size_t)bd.endspaces);</a>
<a name="ln1875">            newp_len += bd.endspaces;</a>
<a name="ln1876">            // copy the part after the changed part</a>
<a name="ln1877">            memmove(newp + newp_len, oldp, (size_t)col);</a>
<a name="ln1878">          }</a>
<a name="ln1879">          newcols = newp_len - bd.textcol;</a>
<a name="ln1880">      } else {</a>
<a name="ln1881">        // Replacing with \r or \n means splitting the line.</a>
<a name="ln1882">        after_p_len = (size_t)col;</a>
<a name="ln1883">        after_p = (char_u *)xmalloc(after_p_len);</a>
<a name="ln1884">        memmove(after_p, oldp, after_p_len);</a>
<a name="ln1885">        newrows = 1;</a>
<a name="ln1886">      }</a>
<a name="ln1887">      // replace the line</a>
<a name="ln1888">      ml_replace(curwin-&gt;w_cursor.lnum, newp, false);</a>
<a name="ln1889">      curbuf_splice_pending++;</a>
<a name="ln1890">      linenr_T baselnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1891">      if (after_p != NULL) {</a>
<a name="ln1892">        ml_append(curwin-&gt;w_cursor.lnum++, after_p, (int)after_p_len, false);</a>
<a name="ln1893">        appended_lines_mark(curwin-&gt;w_cursor.lnum, 1L);</a>
<a name="ln1894">        oap-&gt;end.lnum++;</a>
<a name="ln1895">        xfree(after_p);</a>
<a name="ln1896">      }</a>
<a name="ln1897">      curbuf_splice_pending--;</a>
<a name="ln1898">      extmark_splice(curbuf, (int)baselnum-1, bd.textcol,</a>
<a name="ln1899">                     0, bd.textlen, bd.textlen,</a>
<a name="ln1900">                     newrows, newcols, newrows+newcols, kExtmarkUndo);</a>
<a name="ln1901">    }</a>
<a name="ln1902">  } else {</a>
<a name="ln1903">    // Characterwise or linewise motion replace.</a>
<a name="ln1904">    if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln1905">      oap-&gt;start.col = 0;</a>
<a name="ln1906">      curwin-&gt;w_cursor.col = 0;</a>
<a name="ln1907">      oap-&gt;end.col = (colnr_T)STRLEN(ml_get(oap-&gt;end.lnum));</a>
<a name="ln1908">      if (oap-&gt;end.col)</a>
<a name="ln1909">        --oap-&gt;end.col;</a>
<a name="ln1910">    } else if (!oap-&gt;inclusive)</a>
<a name="ln1911">      dec(&amp;(oap-&gt;end));</a>
<a name="ln1912"> </a>
<a name="ln1913">    // TODO(bfredl): we could batch all the splicing</a>
<a name="ln1914">    // done on the same line, at least</a>
<a name="ln1915">    while (ltoreq(curwin-&gt;w_cursor, oap-&gt;end)) {</a>
<a name="ln1916">      n = gchar_cursor();</a>
<a name="ln1917">      if (n != NUL) {</a>
<a name="ln1918">        if ((*mb_char2len)(c) &gt; 1 || (*mb_char2len)(n) &gt; 1) {</a>
<a name="ln1919">          /* This is slow, but it handles replacing a single-byte</a>
<a name="ln1920">           * with a multi-byte and the other way around. */</a>
<a name="ln1921">          if (curwin-&gt;w_cursor.lnum == oap-&gt;end.lnum)</a>
<a name="ln1922">            oap-&gt;end.col += (*mb_char2len)(c) - (*mb_char2len)(n);</a>
<a name="ln1923">          replace_character(c);</a>
<a name="ln1924">        } else {</a>
<a name="ln1925">          if (n == TAB) {</a>
<a name="ln1926">            int end_vcol = 0;</a>
<a name="ln1927"> </a>
<a name="ln1928">            if (curwin-&gt;w_cursor.lnum == oap-&gt;end.lnum) {</a>
<a name="ln1929">              /* oap-&gt;end has to be recalculated when</a>
<a name="ln1930">               * the tab breaks */</a>
<a name="ln1931">              end_vcol = getviscol2(oap-&gt;end.col,</a>
<a name="ln1932">                  oap-&gt;end.coladd);</a>
<a name="ln1933">            }</a>
<a name="ln1934">            coladvance_force(getviscol());</a>
<a name="ln1935">            if (curwin-&gt;w_cursor.lnum == oap-&gt;end.lnum)</a>
<a name="ln1936">              getvpos(&amp;oap-&gt;end, end_vcol);</a>
<a name="ln1937">          }</a>
<a name="ln1938">          pbyte(curwin-&gt;w_cursor, c);</a>
<a name="ln1939">        }</a>
<a name="ln1940">      } else if (virtual_op &amp;&amp; curwin-&gt;w_cursor.lnum == oap-&gt;end.lnum) {</a>
<a name="ln1941">        int virtcols = oap-&gt;end.coladd;</a>
<a name="ln1942"> </a>
<a name="ln1943">        if (curwin-&gt;w_cursor.lnum == oap-&gt;start.lnum</a>
<a name="ln1944">            &amp;&amp; oap-&gt;start.col == oap-&gt;end.col &amp;&amp; oap-&gt;start.coladd)</a>
<a name="ln1945">          virtcols -= oap-&gt;start.coladd;</a>
<a name="ln1946"> </a>
<a name="ln1947">        /* oap-&gt;end has been trimmed so it's effectively inclusive;</a>
<a name="ln1948">         * as a result an extra +1 must be counted so we don't</a>
<a name="ln1949">         * trample the NUL byte. */</a>
<a name="ln1950">        coladvance_force(getviscol2(oap-&gt;end.col, oap-&gt;end.coladd) + 1);</a>
<a name="ln1951">        curwin-&gt;w_cursor.col -= (virtcols + 1);</a>
<a name="ln1952">        for (; virtcols &gt;= 0; virtcols--) {</a>
<a name="ln1953">          if (utf_char2len(c) &gt; 1) {</a>
<a name="ln1954">            replace_character(c);</a>
<a name="ln1955">          } else {</a>
<a name="ln1956">            pbyte(curwin-&gt;w_cursor, c);</a>
<a name="ln1957">          }</a>
<a name="ln1958">          if (inc(&amp;curwin-&gt;w_cursor) == -1) {</a>
<a name="ln1959">            break;</a>
<a name="ln1960">          }</a>
<a name="ln1961">        }</a>
<a name="ln1962">      }</a>
<a name="ln1963"> </a>
<a name="ln1964">      /* Advance to next character, stop at the end of the file. */</a>
<a name="ln1965">      if (inc_cursor() == -1)</a>
<a name="ln1966">        break;</a>
<a name="ln1967">    }</a>
<a name="ln1968">  }</a>
<a name="ln1969"> </a>
<a name="ln1970">  curwin-&gt;w_cursor = oap-&gt;start;</a>
<a name="ln1971">  check_cursor();</a>
<a name="ln1972">  changed_lines(oap-&gt;start.lnum, oap-&gt;start.col, oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln1973"> </a>
<a name="ln1974">  /* Set &quot;'[&quot; and &quot;']&quot; marks. */</a>
<a name="ln1975">  curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln1976">  curbuf-&gt;b_op_end = oap-&gt;end;</a>
<a name="ln1977"> </a>
<a name="ln1978">  return OK;</a>
<a name="ln1979">}</a>
<a name="ln1980"> </a>
<a name="ln1981"> </a>
<a name="ln1982">/*</a>
<a name="ln1983"> * Handle the (non-standard vi) tilde operator.  Also for &quot;gu&quot;, &quot;gU&quot; and &quot;g?&quot;.</a>
<a name="ln1984"> */</a>
<a name="ln1985">void op_tilde(oparg_T *oap)</a>
<a name="ln1986">{</a>
<a name="ln1987">  pos_T pos;</a>
<a name="ln1988">  struct block_def bd;</a>
<a name="ln1989">  int did_change = FALSE;</a>
<a name="ln1990"> </a>
<a name="ln1991">  if (u_save((linenr_T)(oap-&gt;start.lnum - 1),</a>
<a name="ln1992">          (linenr_T)(oap-&gt;end.lnum + 1)) == FAIL)</a>
<a name="ln1993">    return;</a>
<a name="ln1994"> </a>
<a name="ln1995">  pos = oap-&gt;start;</a>
<a name="ln1996">  if (oap-&gt;motion_type == kMTBlockWise) {  // Visual block mode</a>
<a name="ln1997">    for (; pos.lnum &lt;= oap-&gt;end.lnum; pos.lnum++) {</a>
<a name="ln1998">      int one_change;</a>
<a name="ln1999"> </a>
<a name="ln2000">      block_prep(oap, &amp;bd, pos.lnum, false);</a>
<a name="ln2001">      pos.col = bd.textcol;</a>
<a name="ln2002">      one_change = swapchars(oap-&gt;op_type, &amp;pos, bd.textlen);</a>
<a name="ln2003">      did_change |= one_change;</a>
<a name="ln2004"> </a>
<a name="ln2005">    }</a>
<a name="ln2006">    if (did_change) {</a>
<a name="ln2007">      changed_lines(oap-&gt;start.lnum, 0, oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln2008">    }</a>
<a name="ln2009">  } else {  // not block mode</a>
<a name="ln2010">    if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln2011">      oap-&gt;start.col = 0;</a>
<a name="ln2012">      pos.col = 0;</a>
<a name="ln2013">      oap-&gt;end.col = (colnr_T)STRLEN(ml_get(oap-&gt;end.lnum));</a>
<a name="ln2014">      if (oap-&gt;end.col)</a>
<a name="ln2015">        --oap-&gt;end.col;</a>
<a name="ln2016">    } else if (!oap-&gt;inclusive)</a>
<a name="ln2017">      dec(&amp;(oap-&gt;end));</a>
<a name="ln2018"> </a>
<a name="ln2019">    if (pos.lnum == oap-&gt;end.lnum)</a>
<a name="ln2020">      did_change = swapchars(oap-&gt;op_type, &amp;pos,</a>
<a name="ln2021">          oap-&gt;end.col - pos.col + 1);</a>
<a name="ln2022">    else</a>
<a name="ln2023">      for (;; ) {</a>
<a name="ln2024">        did_change |= swapchars(oap-&gt;op_type, &amp;pos,</a>
<a name="ln2025">            pos.lnum == oap-&gt;end.lnum ? oap-&gt;end.col + 1 :</a>
<a name="ln2026">            (int)STRLEN(ml_get_pos(&amp;pos)));</a>
<a name="ln2027">        if (ltoreq(oap-&gt;end, pos) || inc(&amp;pos) == -1)</a>
<a name="ln2028">          break;</a>
<a name="ln2029">      }</a>
<a name="ln2030">    if (did_change) {</a>
<a name="ln2031">      changed_lines(oap-&gt;start.lnum, oap-&gt;start.col, oap-&gt;end.lnum + 1,</a>
<a name="ln2032">                    0L, true);</a>
<a name="ln2033">    }</a>
<a name="ln2034">  }</a>
<a name="ln2035"> </a>
<a name="ln2036">  if (!did_change &amp;&amp; oap-&gt;is_VIsual)</a>
<a name="ln2037">    /* No change: need to remove the Visual selection */</a>
<a name="ln2038">    redraw_curbuf_later(INVERTED);</a>
<a name="ln2039"> </a>
<a name="ln2040">  /*</a>
<a name="ln2041">   * Set '[ and '] marks.</a>
<a name="ln2042">   */</a>
<a name="ln2043">  curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln2044">  curbuf-&gt;b_op_end = oap-&gt;end;</a>
<a name="ln2045"> </a>
<a name="ln2046">  if (oap-&gt;line_count &gt; p_report) {</a>
<a name="ln2047">    if (oap-&gt;line_count == 1)</a>
<a name="ln2048">      MSG(_(&quot;1 line changed&quot;));</a>
<a name="ln2049">    else</a>
<a name="ln2050">      smsg(_(&quot;%&quot; PRId64 &quot; lines changed&quot;), (int64_t)oap-&gt;line_count);</a>
<a name="ln2051">  }</a>
<a name="ln2052">}</a>
<a name="ln2053"> </a>
<a name="ln2054">/*</a>
<a name="ln2055"> * Invoke swapchar() on &quot;length&quot; bytes at position &quot;pos&quot;.</a>
<a name="ln2056"> * &quot;pos&quot; is advanced to just after the changed characters.</a>
<a name="ln2057"> * &quot;length&quot; is rounded up to include the whole last multi-byte character.</a>
<a name="ln2058"> * Also works correctly when the number of bytes changes.</a>
<a name="ln2059"> * Returns TRUE if some character was changed.</a>
<a name="ln2060"> */</a>
<a name="ln2061">static int swapchars(int op_type, pos_T *pos, int length)</a>
<a name="ln2062">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2063">{</a>
<a name="ln2064">  int did_change = 0;</a>
<a name="ln2065"> </a>
<a name="ln2066">  for (int todo = length; todo &gt; 0; todo--) {</a>
<a name="ln2067">    const int len = utfc_ptr2len(ml_get_pos(pos));</a>
<a name="ln2068"> </a>
<a name="ln2069">    // we're counting bytes, not characters</a>
<a name="ln2070">    if (len &gt; 0) {</a>
<a name="ln2071">      todo -= len - 1;</a>
<a name="ln2072">    }</a>
<a name="ln2073">    did_change |= swapchar(op_type, pos);</a>
<a name="ln2074">    if (inc(pos) == -1)        /* at end of file */</a>
<a name="ln2075">      break;</a>
<a name="ln2076">  }</a>
<a name="ln2077">  return did_change;</a>
<a name="ln2078">}</a>
<a name="ln2079"> </a>
<a name="ln2080">// If op_type == OP_UPPER: make uppercase,</a>
<a name="ln2081">// if op_type == OP_LOWER: make lowercase,</a>
<a name="ln2082">// if op_type == OP_ROT13: do rot13 encoding,</a>
<a name="ln2083">// else swap case of character at 'pos'</a>
<a name="ln2084">// returns true when something actually changed.</a>
<a name="ln2085">bool swapchar(int op_type, pos_T *pos)</a>
<a name="ln2086">  FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln2087">{</a>
<a name="ln2088">  const int c = gchar_pos(pos);</a>
<a name="ln2089"> </a>
<a name="ln2090">  // Only do rot13 encoding for ASCII characters.</a>
<a name="ln2091">  if (c &gt;= 0x80 &amp;&amp; op_type == OP_ROT13) {</a>
<a name="ln2092">    return false;</a>
<a name="ln2093">  }</a>
<a name="ln2094"> </a>
<a name="ln2095">  if (op_type == OP_UPPER &amp;&amp; c == 0xdf) {</a>
<a name="ln2096">    pos_T sp = curwin-&gt;w_cursor;</a>
<a name="ln2097"> </a>
<a name="ln2098">    /* Special handling of German sharp s: change to &quot;SS&quot;. */</a>
<a name="ln2099">    curwin-&gt;w_cursor = *pos;</a>
<a name="ln2100">    del_char(false);</a>
<a name="ln2101">    ins_char('S');</a>
<a name="ln2102">    ins_char('S');</a>
<a name="ln2103">    curwin-&gt;w_cursor = sp;</a>
<a name="ln2104">    inc(pos);</a>
<a name="ln2105">  }</a>
<a name="ln2106"> </a>
<a name="ln2107">  int nc = c;</a>
<a name="ln2108">  if (mb_islower(c)) {</a>
<a name="ln2109">    if (op_type == OP_ROT13) {</a>
<a name="ln2110">      nc = ROT13(c, 'a');</a>
<a name="ln2111">    } else if (op_type != OP_LOWER) {</a>
<a name="ln2112">      nc = mb_toupper(c);</a>
<a name="ln2113">    }</a>
<a name="ln2114">  } else if (mb_isupper(c)) {</a>
<a name="ln2115">    if (op_type == OP_ROT13) {</a>
<a name="ln2116">      nc = ROT13(c, 'A');</a>
<a name="ln2117">    } else if (op_type != OP_UPPER) {</a>
<a name="ln2118">      nc = mb_tolower(c);</a>
<a name="ln2119">    }</a>
<a name="ln2120">  }</a>
<a name="ln2121">  if (nc != c) {</a>
<a name="ln2122">    if (c &gt;= 0x80 || nc &gt;= 0x80) {</a>
<a name="ln2123">      pos_T sp = curwin-&gt;w_cursor;</a>
<a name="ln2124"> </a>
<a name="ln2125">      curwin-&gt;w_cursor = *pos;</a>
<a name="ln2126">      // don't use del_char(), it also removes composing chars</a>
<a name="ln2127">      del_bytes(utf_ptr2len(get_cursor_pos_ptr()), false, false);</a>
<a name="ln2128">      ins_char(nc);</a>
<a name="ln2129">      curwin-&gt;w_cursor = sp;</a>
<a name="ln2130">    } else {</a>
<a name="ln2131">      pbyte(*pos, nc);</a>
<a name="ln2132">    }</a>
<a name="ln2133">    return true;</a>
<a name="ln2134">  }</a>
<a name="ln2135">  return false;</a>
<a name="ln2136">}</a>
<a name="ln2137"> </a>
<a name="ln2138">/*</a>
<a name="ln2139"> * op_insert - Insert and append operators for Visual mode.</a>
<a name="ln2140"> */</a>
<a name="ln2141">void op_insert(oparg_T *oap, long count1)</a>
<a name="ln2142">{</a>
<a name="ln2143">  long ins_len, pre_textlen = 0;</a>
<a name="ln2144">  char_u              *firstline, *ins_text;</a>
<a name="ln2145">  colnr_T ind_pre = 0;</a>
<a name="ln2146">  struct block_def bd;</a>
<a name="ln2147">  int i;</a>
<a name="ln2148">  pos_T t1;</a>
<a name="ln2149"> </a>
<a name="ln2150">  /* edit() changes this - record it for OP_APPEND */</a>
<a name="ln2151">  bd.is_MAX = (curwin-&gt;w_curswant == MAXCOL);</a>
<a name="ln2152"> </a>
<a name="ln2153">  /* vis block is still marked. Get rid of it now. */</a>
<a name="ln2154">  curwin-&gt;w_cursor.lnum = oap-&gt;start.lnum;</a>
<a name="ln2155">  update_screen(INVERTED);</a>
<a name="ln2156"> </a>
<a name="ln2157">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln2158">    // When 'virtualedit' is used, need to insert the extra spaces before</a>
<a name="ln2159">    // doing block_prep().  When only &quot;block&quot; is used, virtual edit is</a>
<a name="ln2160">    // already disabled, but still need it when calling</a>
<a name="ln2161">    // coladvance_force().</a>
<a name="ln2162">    if (curwin-&gt;w_cursor.coladd &gt; 0) {</a>
<a name="ln2163">      unsigned old_ve_flags = ve_flags;</a>
<a name="ln2164"> </a>
<a name="ln2165">      ve_flags = VE_ALL;</a>
<a name="ln2166">      if (u_save_cursor() == FAIL)</a>
<a name="ln2167">        return;</a>
<a name="ln2168">      coladvance_force(oap-&gt;op_type == OP_APPEND</a>
<a name="ln2169">          ? oap-&gt;end_vcol + 1 : getviscol());</a>
<a name="ln2170">      if (oap-&gt;op_type == OP_APPEND)</a>
<a name="ln2171">        --curwin-&gt;w_cursor.col;</a>
<a name="ln2172">      ve_flags = old_ve_flags;</a>
<a name="ln2173">    }</a>
<a name="ln2174">    // Get the info about the block before entering the text</a>
<a name="ln2175">    block_prep(oap, &amp;bd, oap-&gt;start.lnum, true);</a>
<a name="ln2176">    // Get indent information</a>
<a name="ln2177">    ind_pre = (colnr_T)getwhitecols_curline();</a>
<a name="ln2178">    firstline = ml_get(oap-&gt;start.lnum) + bd.textcol;</a>
<a name="ln2179"> </a>
<a name="ln2180">    if (oap-&gt;op_type == OP_APPEND) {</a>
<a name="ln2181">      firstline += bd.textlen;</a>
<a name="ln2182">    }</a>
<a name="ln2183">    pre_textlen = (long)STRLEN(firstline);</a>
<a name="ln2184">  }</a>
<a name="ln2185"> </a>
<a name="ln2186">  if (oap-&gt;op_type == OP_APPEND) {</a>
<a name="ln2187">    if (oap-&gt;motion_type == kMTBlockWise</a>
<a name="ln2188">        &amp;&amp; curwin-&gt;w_cursor.coladd == 0</a>
<a name="ln2189">        ) {</a>
<a name="ln2190">      /* Move the cursor to the character right of the block. */</a>
<a name="ln2191">      curwin-&gt;w_set_curswant = TRUE;</a>
<a name="ln2192">      while (*get_cursor_pos_ptr() != NUL</a>
<a name="ln2193">             &amp;&amp; (curwin-&gt;w_cursor.col &lt; bd.textcol + bd.textlen))</a>
<a name="ln2194">        ++curwin-&gt;w_cursor.col;</a>
<a name="ln2195">      if (bd.is_short &amp;&amp; !bd.is_MAX) {</a>
<a name="ln2196">        /* First line was too short, make it longer and adjust the</a>
<a name="ln2197">         * values in &quot;bd&quot;. */</a>
<a name="ln2198">        if (u_save_cursor() == FAIL)</a>
<a name="ln2199">          return;</a>
<a name="ln2200">        for (i = 0; i &lt; bd.endspaces; i++) {</a>
<a name="ln2201">          ins_char(' ');</a>
<a name="ln2202">        }</a>
<a name="ln2203">        bd.textlen += bd.endspaces;</a>
<a name="ln2204">      }</a>
<a name="ln2205">    } else {</a>
<a name="ln2206">      curwin-&gt;w_cursor = oap-&gt;end;</a>
<a name="ln2207">      check_cursor_col();</a>
<a name="ln2208"> </a>
<a name="ln2209">      // Works just like an 'i'nsert on the next character.</a>
<a name="ln2210">      if (!LINEEMPTY(curwin-&gt;w_cursor.lnum)</a>
<a name="ln2211">          &amp;&amp; oap-&gt;start_vcol != oap-&gt;end_vcol) {</a>
<a name="ln2212">        inc_cursor();</a>
<a name="ln2213">      }</a>
<a name="ln2214">    }</a>
<a name="ln2215">  }</a>
<a name="ln2216"> </a>
<a name="ln2217">  t1 = oap-&gt;start;</a>
<a name="ln2218">  (void)edit(NUL, false, (linenr_T)count1);</a>
<a name="ln2219"> </a>
<a name="ln2220">  // When a tab was inserted, and the characters in front of the tab</a>
<a name="ln2221">  // have been converted to a tab as well, the column of the cursor</a>
<a name="ln2222">  // might have actually been reduced, so need to adjust here. */</a>
<a name="ln2223">  if (t1.lnum == curbuf-&gt;b_op_start_orig.lnum</a>
<a name="ln2224">      &amp;&amp; lt(curbuf-&gt;b_op_start_orig, t1)) {</a>
<a name="ln2225">    oap-&gt;start = curbuf-&gt;b_op_start_orig;</a>
<a name="ln2226">  }</a>
<a name="ln2227"> </a>
<a name="ln2228">  /* If user has moved off this line, we don't know what to do, so do</a>
<a name="ln2229">   * nothing.</a>
<a name="ln2230">   * Also don't repeat the insert when Insert mode ended with CTRL-C. */</a>
<a name="ln2231">  if (curwin-&gt;w_cursor.lnum != oap-&gt;start.lnum || got_int)</a>
<a name="ln2232">    return;</a>
<a name="ln2233"> </a>
<a name="ln2234">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln2235">    struct block_def bd2;</a>
<a name="ln2236">    bool did_indent = false;</a>
<a name="ln2237"> </a>
<a name="ln2238">    // if indent kicked in, the firstline might have changed</a>
<a name="ln2239">    // but only do that, if the indent actually increased</a>
<a name="ln2240">    const colnr_T ind_post = (colnr_T)getwhitecols_curline();</a>
<a name="ln2241">    if (curbuf-&gt;b_op_start.col &gt; ind_pre &amp;&amp; ind_post &gt; ind_pre) {</a>
<a name="ln2242">      bd.textcol += ind_post - ind_pre;</a>
<a name="ln2243">      bd.start_vcol += ind_post - ind_pre;</a>
<a name="ln2244">      did_indent = true;</a>
<a name="ln2245">    }</a>
<a name="ln2246"> </a>
<a name="ln2247">    // The user may have moved the cursor before inserting something, try</a>
<a name="ln2248">    // to adjust the block for that.  But only do it, if the difference</a>
<a name="ln2249">    // does not come from indent kicking in.</a>
<a name="ln2250">    if (oap-&gt;start.lnum == curbuf-&gt;b_op_start_orig.lnum</a>
<a name="ln2251">        &amp;&amp; !bd.is_MAX</a>
<a name="ln2252">        &amp;&amp; !did_indent) {</a>
<a name="ln2253">      if (oap-&gt;op_type == OP_INSERT</a>
<a name="ln2254">          &amp;&amp; oap-&gt;start.col + oap-&gt;start.coladd</a>
<a name="ln2255">          != curbuf-&gt;b_op_start_orig.col + curbuf-&gt;b_op_start_orig.coladd) {</a>
<a name="ln2256">        int t = getviscol2(curbuf-&gt;b_op_start_orig.col,</a>
<a name="ln2257">                           curbuf-&gt;b_op_start_orig.coladd);</a>
<a name="ln2258">        oap-&gt;start.col = curbuf-&gt;b_op_start_orig.col;</a>
<a name="ln2259">        pre_textlen -= t - oap-&gt;start_vcol;</a>
<a name="ln2260">        oap-&gt;start_vcol = t;</a>
<a name="ln2261">      } else if (oap-&gt;op_type == OP_APPEND</a>
<a name="ln2262">                 &amp;&amp; oap-&gt;end.col + oap-&gt;end.coladd</a>
<a name="ln2263">                 &gt;= curbuf-&gt;b_op_start_orig.col</a>
<a name="ln2264">                 + curbuf-&gt;b_op_start_orig.coladd) {</a>
<a name="ln2265">        int t = getviscol2(curbuf-&gt;b_op_start_orig.col,</a>
<a name="ln2266">                           curbuf-&gt;b_op_start_orig.coladd);</a>
<a name="ln2267">        oap-&gt;start.col = curbuf-&gt;b_op_start_orig.col;</a>
<a name="ln2268">        /* reset pre_textlen to the value of OP_INSERT */</a>
<a name="ln2269">        pre_textlen += bd.textlen;</a>
<a name="ln2270">        pre_textlen -= t - oap-&gt;start_vcol;</a>
<a name="ln2271">        oap-&gt;start_vcol = t;</a>
<a name="ln2272">        oap-&gt;op_type = OP_INSERT;</a>
<a name="ln2273">      }</a>
<a name="ln2274">    }</a>
<a name="ln2275"> </a>
<a name="ln2276">    /*</a>
<a name="ln2277">     * Spaces and tabs in the indent may have changed to other spaces and</a>
<a name="ln2278">     * tabs.  Get the starting column again and correct the length.</a>
<a name="ln2279">     * Don't do this when &quot;$&quot; used, end-of-line will have changed.</a>
<a name="ln2280">     */</a>
<a name="ln2281">    block_prep(oap, &amp;bd2, oap-&gt;start.lnum, true);</a>
<a name="ln2282">    if (!bd.is_MAX || bd2.textlen &lt; bd.textlen) {</a>
<a name="ln2283">      if (oap-&gt;op_type == OP_APPEND) {</a>
<a name="ln2284">        pre_textlen += bd2.textlen - bd.textlen;</a>
<a name="ln2285">        if (bd2.endspaces)</a>
<a name="ln2286">          --bd2.textlen;</a>
<a name="ln2287">      }</a>
<a name="ln2288">      bd.textcol = bd2.textcol;</a>
<a name="ln2289">      bd.textlen = bd2.textlen;</a>
<a name="ln2290">    }</a>
<a name="ln2291"> </a>
<a name="ln2292">    /*</a>
<a name="ln2293">     * Subsequent calls to ml_get() flush the firstline data - take a</a>
<a name="ln2294">     * copy of the required string.</a>
<a name="ln2295">     */</a>
<a name="ln2296">    firstline = ml_get(oap-&gt;start.lnum);</a>
<a name="ln2297">    const size_t len = STRLEN(firstline);</a>
<a name="ln2298">    colnr_T add = bd.textcol;</a>
<a name="ln2299">    if (oap-&gt;op_type == OP_APPEND) {</a>
<a name="ln2300">      add += bd.textlen;</a>
<a name="ln2301">    }</a>
<a name="ln2302">    if ((size_t)add &gt; len) {</a>
<a name="ln2303">      firstline += len;  // short line, point to the NUL</a>
<a name="ln2304">    } else {</a>
<a name="ln2305">      firstline += add;</a>
<a name="ln2306">    }</a>
<a name="ln2307">    ins_len = (long)STRLEN(firstline) - pre_textlen;</a>
<a name="ln2308">    if (pre_textlen &gt;= 0 &amp;&amp; ins_len &gt; 0) {</a>
<a name="ln2309">      ins_text = vim_strnsave(firstline, (size_t)ins_len);</a>
<a name="ln2310">      // block handled here</a>
<a name="ln2311">      if (u_save(oap-&gt;start.lnum, (linenr_T)(oap-&gt;end.lnum + 1)) == OK) {</a>
<a name="ln2312">        block_insert(oap, ins_text, (oap-&gt;op_type == OP_INSERT), &amp;bd);</a>
<a name="ln2313">      }</a>
<a name="ln2314"> </a>
<a name="ln2315">      curwin-&gt;w_cursor.col = oap-&gt;start.col;</a>
<a name="ln2316">      check_cursor();</a>
<a name="ln2317">      xfree(ins_text);</a>
<a name="ln2318">    }</a>
<a name="ln2319">  }</a>
<a name="ln2320">}</a>
<a name="ln2321"> </a>
<a name="ln2322">/*</a>
<a name="ln2323"> * op_change - handle a change operation</a>
<a name="ln2324"> *</a>
<a name="ln2325"> * return TRUE if edit() returns because of a CTRL-O command</a>
<a name="ln2326"> */</a>
<a name="ln2327">int op_change(oparg_T *oap)</a>
<a name="ln2328">{</a>
<a name="ln2329">  colnr_T l;</a>
<a name="ln2330">  int retval;</a>
<a name="ln2331">  long offset;</a>
<a name="ln2332">  linenr_T linenr;</a>
<a name="ln2333">  long ins_len;</a>
<a name="ln2334">  long pre_textlen = 0;</a>
<a name="ln2335">  long pre_indent = 0;</a>
<a name="ln2336">  char_u *newp;</a>
<a name="ln2337">  char_u *firstline;</a>
<a name="ln2338">  char_u *ins_text;</a>
<a name="ln2339">  char_u *oldp;</a>
<a name="ln2340">  struct block_def bd;</a>
<a name="ln2341"> </a>
<a name="ln2342">  l = oap-&gt;start.col;</a>
<a name="ln2343">  if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln2344">    l = 0;</a>
<a name="ln2345">    if (!p_paste &amp;&amp; curbuf-&gt;b_p_si</a>
<a name="ln2346">        &amp;&amp; !curbuf-&gt;b_p_cin</a>
<a name="ln2347">        )</a>
<a name="ln2348">      can_si = true;            // It's like opening a new line, do si</a>
<a name="ln2349">  }</a>
<a name="ln2350"> </a>
<a name="ln2351">  /* First delete the text in the region.  In an empty buffer only need to</a>
<a name="ln2352">   * save for undo */</a>
<a name="ln2353">  if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {</a>
<a name="ln2354">    if (u_save_cursor() == FAIL)</a>
<a name="ln2355">      return FALSE;</a>
<a name="ln2356">  } else if (op_delete(oap) == FAIL)</a>
<a name="ln2357">    return FALSE;</a>
<a name="ln2358"> </a>
<a name="ln2359">  if ((l &gt; curwin-&gt;w_cursor.col) &amp;&amp; !LINEEMPTY(curwin-&gt;w_cursor.lnum)</a>
<a name="ln2360">      &amp;&amp; !virtual_op) {</a>
<a name="ln2361">    inc_cursor();</a>
<a name="ln2362">  }</a>
<a name="ln2363"> </a>
<a name="ln2364">  // check for still on same line (&lt;CR&gt; in inserted text meaningless)</a>
<a name="ln2365">  // skip blank lines too</a>
<a name="ln2366">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln2367">    // Add spaces before getting the current line length.</a>
<a name="ln2368">    if (virtual_op &amp;&amp; (curwin-&gt;w_cursor.coladd &gt; 0</a>
<a name="ln2369">                       || gchar_cursor() == NUL)) {</a>
<a name="ln2370">      coladvance_force(getviscol());</a>
<a name="ln2371">    }</a>
<a name="ln2372">    firstline = ml_get(oap-&gt;start.lnum);</a>
<a name="ln2373">    pre_textlen = (long)STRLEN(firstline);</a>
<a name="ln2374">    pre_indent = (long)getwhitecols(firstline);</a>
<a name="ln2375">    bd.textcol = curwin-&gt;w_cursor.col;</a>
<a name="ln2376">  }</a>
<a name="ln2377"> </a>
<a name="ln2378">  if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln2379">    fix_indent();</a>
<a name="ln2380">  }</a>
<a name="ln2381"> </a>
<a name="ln2382">  retval = edit(NUL, FALSE, (linenr_T)1);</a>
<a name="ln2383"> </a>
<a name="ln2384">  /*</a>
<a name="ln2385">   * In Visual block mode, handle copying the new text to all lines of the</a>
<a name="ln2386">   * block.</a>
<a name="ln2387">   * Don't repeat the insert when Insert mode ended with CTRL-C.</a>
<a name="ln2388">   */</a>
<a name="ln2389">  if (oap-&gt;motion_type == kMTBlockWise</a>
<a name="ln2390">      &amp;&amp; oap-&gt;start.lnum != oap-&gt;end.lnum &amp;&amp; !got_int) {</a>
<a name="ln2391">    // Auto-indenting may have changed the indent.  If the cursor was past</a>
<a name="ln2392">    // the indent, exclude that indent change from the inserted text.</a>
<a name="ln2393">    firstline = ml_get(oap-&gt;start.lnum);</a>
<a name="ln2394">    if (bd.textcol &gt; (colnr_T)pre_indent) {</a>
<a name="ln2395">      long new_indent = (long)getwhitecols(firstline);</a>
<a name="ln2396"> </a>
<a name="ln2397">      pre_textlen += new_indent - pre_indent;</a>
<a name="ln2398">      bd.textcol += (colnr_T)(new_indent - pre_indent);</a>
<a name="ln2399">    }</a>
<a name="ln2400"> </a>
<a name="ln2401">    ins_len = (long)STRLEN(firstline) - pre_textlen;</a>
<a name="ln2402">    if (ins_len &gt; 0) {</a>
<a name="ln2403">      /* Subsequent calls to ml_get() flush the firstline data - take a</a>
<a name="ln2404">       * copy of the inserted text.  */</a>
<a name="ln2405">      ins_text = (char_u *)xmalloc((size_t)(ins_len + 1));</a>
<a name="ln2406">      STRLCPY(ins_text, firstline + bd.textcol, ins_len + 1);</a>
<a name="ln2407">      for (linenr = oap-&gt;start.lnum + 1; linenr &lt;= oap-&gt;end.lnum;</a>
<a name="ln2408">           linenr++) {</a>
<a name="ln2409">        block_prep(oap, &amp;bd, linenr, true);</a>
<a name="ln2410">        if (!bd.is_short || virtual_op) {</a>
<a name="ln2411">          pos_T vpos;</a>
<a name="ln2412"> </a>
<a name="ln2413">          /* If the block starts in virtual space, count the</a>
<a name="ln2414">           * initial coladd offset as part of &quot;startspaces&quot; */</a>
<a name="ln2415">          if (bd.is_short) {</a>
<a name="ln2416">            vpos.lnum = linenr;</a>
<a name="ln2417">            (void)getvpos(&amp;vpos, oap-&gt;start_vcol);</a>
<a name="ln2418">          } else {</a>
<a name="ln2419">            vpos.coladd = 0;</a>
<a name="ln2420">          }</a>
<a name="ln2421">          oldp = ml_get(linenr);</a>
<a name="ln2422">          newp = xmalloc(STRLEN(oldp) + (size_t)vpos.coladd</a>
<a name="ln2423">                         + (size_t)ins_len + 1);</a>
<a name="ln2424">          // copy up to block start</a>
<a name="ln2425">          memmove(newp, oldp, (size_t)bd.textcol);</a>
<a name="ln2426">          offset = bd.textcol;</a>
<a name="ln2427">          memset(newp + offset, ' ', (size_t)vpos.coladd);</a>
<a name="ln2428">          offset += vpos.coladd;</a>
<a name="ln2429">          memmove(newp + offset, ins_text, (size_t)ins_len);</a>
<a name="ln2430">          offset += ins_len;</a>
<a name="ln2431">          oldp += bd.textcol;</a>
<a name="ln2432">          STRMOVE(newp + offset, oldp);</a>
<a name="ln2433">          ml_replace(linenr, newp, false);</a>
<a name="ln2434">          extmark_splice_cols(curbuf, (int)linenr-1, bd.textcol,</a>
<a name="ln2435">                              0, vpos.coladd+(int)ins_len, kExtmarkUndo);</a>
<a name="ln2436">        }</a>
<a name="ln2437">      }</a>
<a name="ln2438">      check_cursor();</a>
<a name="ln2439">      changed_lines(oap-&gt;start.lnum + 1, 0, oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln2440">      xfree(ins_text);</a>
<a name="ln2441">    }</a>
<a name="ln2442">  }</a>
<a name="ln2443"> </a>
<a name="ln2444">  return retval;</a>
<a name="ln2445">}</a>
<a name="ln2446"> </a>
<a name="ln2447">/*</a>
<a name="ln2448"> * set all the yank registers to empty (called from main())</a>
<a name="ln2449"> */</a>
<a name="ln2450">void init_yank(void)</a>
<a name="ln2451">{</a>
<a name="ln2452">  memset(&amp;(y_regs[0]), 0, sizeof(y_regs));</a>
<a name="ln2453">}</a>
<a name="ln2454"> </a>
<a name="ln2455">#if defined(EXITFREE)</a>
<a name="ln2456">void clear_registers(void)</a>
<a name="ln2457">{</a>
<a name="ln2458">  int i;</a>
<a name="ln2459"> </a>
<a name="ln2460">  for (i = 0; i &lt; NUM_REGISTERS; i++) {</a>
<a name="ln2461">    free_register(&amp;y_regs[i]);</a>
<a name="ln2462">  }</a>
<a name="ln2463">}</a>
<a name="ln2464"> </a>
<a name="ln2465">#endif</a>
<a name="ln2466"> </a>
<a name="ln2467"> </a>
<a name="ln2468"> /// Free contents of yankreg `reg`.</a>
<a name="ln2469"> /// Called for normal freeing and in case of error.</a>
<a name="ln2470"> /// `reg` must not be NULL (but `reg-&gt;y_array` might be)</a>
<a name="ln2471">void free_register(yankreg_T *reg)</a>
<a name="ln2472">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2473">{</a>
<a name="ln2474">  set_yreg_additional_data(reg, NULL);</a>
<a name="ln2475">  if (reg-&gt;y_array != NULL) {</a>
<a name="ln2476">    for (size_t i = reg-&gt;y_size; i-- &gt; 0;) {  // from y_size - 1 to 0 included</a>
<a name="ln2477">      xfree(reg-&gt;y_array[i]);</a>
<a name="ln2478">    }</a>
<a name="ln2479">    XFREE_CLEAR(reg-&gt;y_array);</a>
<a name="ln2480">  }</a>
<a name="ln2481">}</a>
<a name="ln2482"> </a>
<a name="ln2483">/// Yanks the text between &quot;oap-&gt;start&quot; and &quot;oap-&gt;end&quot; into a yank register.</a>
<a name="ln2484">/// If we are to append (uppercase register), we first yank into a new yank</a>
<a name="ln2485">/// register and then concatenate the old and the new one.</a>
<a name="ln2486">///</a>
<a name="ln2487">/// @param oap operator arguments</a>
<a name="ln2488">/// @param message show message when more than `&amp;report` lines are yanked.</a>
<a name="ln2489">/// @param deleting whether the function was called from a delete operation.</a>
<a name="ln2490">/// @returns whether the operation register was writable.</a>
<a name="ln2491">bool op_yank(oparg_T *oap, bool message, int deleting)</a>
<a name="ln2492">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2493">{</a>
<a name="ln2494">  // check for read-only register</a>
<a name="ln2495">  if (oap-&gt;regname != 0 &amp;&amp; !valid_yank_reg(oap-&gt;regname, true)) {</a>
<a name="ln2496">    beep_flush();</a>
<a name="ln2497">    return false;</a>
<a name="ln2498">  }</a>
<a name="ln2499">  if (oap-&gt;regname == '_') {</a>
<a name="ln2500">    return true; // black hole: nothing to do</a>
<a name="ln2501">  }</a>
<a name="ln2502"> </a>
<a name="ln2503">  yankreg_T *reg = get_yank_register(oap-&gt;regname, YREG_YANK);</a>
<a name="ln2504">  op_yank_reg(oap, message, reg, is_append_register(oap-&gt;regname));</a>
<a name="ln2505">  // op_delete will set_clipboard and do_autocmd</a>
<a name="ln2506">  if (!deleting) {</a>
<a name="ln2507">    set_clipboard(oap-&gt;regname, reg);</a>
<a name="ln2508">    do_autocmd_textyankpost(oap, reg);</a>
<a name="ln2509">  }</a>
<a name="ln2510"> </a>
<a name="ln2511">  return true;</a>
<a name="ln2512">}</a>
<a name="ln2513"> </a>
<a name="ln2514">static void op_yank_reg(oparg_T *oap, bool message, yankreg_T *reg, bool append)</a>
<a name="ln2515">{</a>
<a name="ln2516">  yankreg_T newreg;  // new yank register when appending</a>
<a name="ln2517">  char_u **new_ptr;</a>
<a name="ln2518">  linenr_T lnum;     // current line number</a>
<a name="ln2519">  size_t j;</a>
<a name="ln2520">  MotionType yank_type = oap-&gt;motion_type;</a>
<a name="ln2521">  size_t yanklines = (size_t)oap-&gt;line_count;</a>
<a name="ln2522">  linenr_T yankendlnum = oap-&gt;end.lnum;</a>
<a name="ln2523">  char_u *p;</a>
<a name="ln2524">  char_u *pnew;</a>
<a name="ln2525">  struct block_def bd;</a>
<a name="ln2526"> </a>
<a name="ln2527">  yankreg_T *curr = reg;  // copy of current register</a>
<a name="ln2528">  // append to existing contents</a>
<a name="ln2529">  if (append &amp;&amp; reg-&gt;y_array != NULL) {</a>
<a name="ln2530">    reg = &amp;newreg;</a>
<a name="ln2531">  } else {</a>
<a name="ln2532">    free_register(reg);  // free previously yanked lines</a>
<a name="ln2533">  }</a>
<a name="ln2534"> </a>
<a name="ln2535">  // If the cursor was in column 1 before and after the movement, and the</a>
<a name="ln2536">  // operator is not inclusive, the yank is always linewise.</a>
<a name="ln2537">  if (oap-&gt;motion_type == kMTCharWise</a>
<a name="ln2538">      &amp;&amp; oap-&gt;start.col == 0</a>
<a name="ln2539">      &amp;&amp; !oap-&gt;inclusive</a>
<a name="ln2540">      &amp;&amp; (!oap-&gt;is_VIsual || *p_sel == 'o')</a>
<a name="ln2541">      &amp;&amp; oap-&gt;end.col == 0</a>
<a name="ln2542">      &amp;&amp; yanklines &gt; 1) {</a>
<a name="ln2543">    yank_type = kMTLineWise;</a>
<a name="ln2544">    yankendlnum--;</a>
<a name="ln2545">    yanklines--;</a>
<a name="ln2546">  }</a>
<a name="ln2547"> </a>
<a name="ln2548">  reg-&gt;y_size = yanklines;</a>
<a name="ln2549">  reg-&gt;y_type = yank_type;  // set the yank register type</a>
<a name="ln2550">  reg-&gt;y_width = 0;</a>
<a name="ln2551">  reg-&gt;y_array = xcalloc(yanklines, sizeof(char_u *));</a>
<a name="ln2552">  reg-&gt;additional_data = NULL;</a>
<a name="ln2553">  reg-&gt;timestamp = os_time();</a>
<a name="ln2554"> </a>
<a name="ln2555">  size_t y_idx = 0;  // index in y_array[]</a>
<a name="ln2556">  lnum = oap-&gt;start.lnum;</a>
<a name="ln2557"> </a>
<a name="ln2558">  if (yank_type == kMTBlockWise) {</a>
<a name="ln2559">    // Visual block mode</a>
<a name="ln2560">    reg-&gt;y_width = oap-&gt;end_vcol - oap-&gt;start_vcol;</a>
<a name="ln2561"> </a>
<a name="ln2562">    if (curwin-&gt;w_curswant == MAXCOL &amp;&amp; reg-&gt;y_width &gt; 0)</a>
<a name="ln2563">      reg-&gt;y_width--;</a>
<a name="ln2564">  }</a>
<a name="ln2565"> </a>
<a name="ln2566">  for (; lnum &lt;= yankendlnum; lnum++, y_idx++) {</a>
<a name="ln2567">    switch (reg-&gt;y_type) {</a>
<a name="ln2568">    case kMTBlockWise:</a>
<a name="ln2569">      block_prep(oap, &amp;bd, lnum, false);</a>
<a name="ln2570">      yank_copy_line(reg, &amp;bd, y_idx);</a>
<a name="ln2571">      break;</a>
<a name="ln2572"> </a>
<a name="ln2573">    case kMTLineWise:</a>
<a name="ln2574">      reg-&gt;y_array[y_idx] = vim_strsave(ml_get(lnum));</a>
<a name="ln2575">      break;</a>
<a name="ln2576"> </a>
<a name="ln2577">    case kMTCharWise:</a>
<a name="ln2578">    {</a>
<a name="ln2579">      colnr_T startcol = 0, endcol = MAXCOL;</a>
<a name="ln2580">      int is_oneChar = false;</a>
<a name="ln2581">      colnr_T cs, ce;</a>
<a name="ln2582">      p = ml_get(lnum);</a>
<a name="ln2583">      bd.startspaces = 0;</a>
<a name="ln2584">      bd.endspaces = 0;</a>
<a name="ln2585"> </a>
<a name="ln2586">      if (lnum == oap-&gt;start.lnum) {</a>
<a name="ln2587">        startcol = oap-&gt;start.col;</a>
<a name="ln2588">        if (virtual_op) {</a>
<a name="ln2589">          getvcol(curwin, &amp;oap-&gt;start, &amp;cs, NULL, &amp;ce);</a>
<a name="ln2590">          if (ce != cs &amp;&amp; oap-&gt;start.coladd &gt; 0) {</a>
<a name="ln2591">            /* Part of a tab selected -- but don't</a>
<a name="ln2592">             * double-count it. */</a>
<a name="ln2593">            bd.startspaces = (ce - cs + 1)</a>
<a name="ln2594">                             - oap-&gt;start.coladd;</a>
<a name="ln2595">            startcol++;</a>
<a name="ln2596">          }</a>
<a name="ln2597">        }</a>
<a name="ln2598">      }</a>
<a name="ln2599"> </a>
<a name="ln2600">      if (lnum == oap-&gt;end.lnum) {</a>
<a name="ln2601">        endcol = oap-&gt;end.col;</a>
<a name="ln2602">        if (virtual_op) {</a>
<a name="ln2603">          getvcol(curwin, &amp;oap-&gt;end, &amp;cs, NULL, &amp;ce);</a>
<a name="ln2604">          if (p[endcol] == NUL || (cs + oap-&gt;end.coladd &lt; ce</a>
<a name="ln2605">                                   // Don't add space for double-wide</a>
<a name="ln2606">                                   // char; endcol will be on last byte</a>
<a name="ln2607">                                   // of multi-byte char.</a>
<a name="ln2608">                                   &amp;&amp; utf_head_off(p, p + endcol) == 0)) {</a>
<a name="ln2609">            if (oap-&gt;start.lnum == oap-&gt;end.lnum</a>
<a name="ln2610">                &amp;&amp; oap-&gt;start.col == oap-&gt;end.col) {</a>
<a name="ln2611">              // Special case: inside a single char</a>
<a name="ln2612">              is_oneChar = true;</a>
<a name="ln2613">              bd.startspaces = oap-&gt;end.coladd</a>
<a name="ln2614">                               - oap-&gt;start.coladd + oap-&gt;inclusive;</a>
<a name="ln2615">              endcol = startcol;</a>
<a name="ln2616">            } else {</a>
<a name="ln2617">              bd.endspaces = oap-&gt;end.coladd</a>
<a name="ln2618">                             + oap-&gt;inclusive;</a>
<a name="ln2619">              endcol -= oap-&gt;inclusive;</a>
<a name="ln2620">            }</a>
<a name="ln2621">          }</a>
<a name="ln2622">        }</a>
<a name="ln2623">      }</a>
<a name="ln2624">      if (endcol == MAXCOL)</a>
<a name="ln2625">        endcol = (colnr_T)STRLEN(p);</a>
<a name="ln2626">      if (startcol &gt; endcol</a>
<a name="ln2627">          || is_oneChar</a>
<a name="ln2628">          ) {</a>
<a name="ln2629">        bd.textlen = 0;</a>
<a name="ln2630">      } else {</a>
<a name="ln2631">        bd.textlen = endcol - startcol + oap-&gt;inclusive;</a>
<a name="ln2632">      }</a>
<a name="ln2633">      bd.textstart = p + startcol;</a>
<a name="ln2634">      yank_copy_line(reg, &amp;bd, y_idx);</a>
<a name="ln2635">      break;</a>
<a name="ln2636">    }</a>
<a name="ln2637">    // NOTREACHED</a>
<a name="ln2638">    case kMTUnknown:</a>
<a name="ln2639">        abort();</a>
<a name="ln2640">    }</a>
<a name="ln2641">  }</a>
<a name="ln2642"> </a>
<a name="ln2643">  if (curr != reg) {      /* append the new block to the old block */</a>
<a name="ln2644">    new_ptr = xmalloc(sizeof(char_u *) * (curr-&gt;y_size + reg-&gt;y_size));</a>
<a name="ln2645">    for (j = 0; j &lt; curr-&gt;y_size; ++j)</a>
<a name="ln2646">      new_ptr[j] = curr-&gt;y_array[j];</a>
<a name="ln2647">    xfree(curr-&gt;y_array);</a>
<a name="ln2648">    curr-&gt;y_array = new_ptr;</a>
<a name="ln2649"> </a>
<a name="ln2650">    if (yank_type == kMTLineWise) {</a>
<a name="ln2651">      // kMTLineWise overrides kMTCharWise and kMTBlockWise</a>
<a name="ln2652">      curr-&gt;y_type = kMTLineWise;</a>
<a name="ln2653">    }</a>
<a name="ln2654"> </a>
<a name="ln2655">    // Concatenate the last line of the old block with the first line of</a>
<a name="ln2656">    // the new block, unless being Vi compatible.</a>
<a name="ln2657">    if (curr-&gt;y_type == kMTCharWise</a>
<a name="ln2658">        &amp;&amp; vim_strchr(p_cpo, CPO_REGAPPEND) == NULL) {</a>
<a name="ln2659">      pnew = xmalloc(STRLEN(curr-&gt;y_array[curr-&gt;y_size - 1])</a>
<a name="ln2660">                     + STRLEN(reg-&gt;y_array[0]) + 1);</a>
<a name="ln2661">      STRCPY(pnew, curr-&gt;y_array[--j]);</a>
<a name="ln2662">      STRCAT(pnew, reg-&gt;y_array[0]);</a>
<a name="ln2663">      xfree(curr-&gt;y_array[j]);</a>
<a name="ln2664">      xfree(reg-&gt;y_array[0]);</a>
<a name="ln2665">      curr-&gt;y_array[j++] = pnew;</a>
<a name="ln2666">      y_idx = 1;</a>
<a name="ln2667">    } else</a>
<a name="ln2668">      y_idx = 0;</a>
<a name="ln2669">    while (y_idx &lt; reg-&gt;y_size)</a>
<a name="ln2670">      curr-&gt;y_array[j++] = reg-&gt;y_array[y_idx++];</a>
<a name="ln2671">    curr-&gt;y_size = j;</a>
<a name="ln2672">    xfree(reg-&gt;y_array);</a>
<a name="ln2673">  }</a>
<a name="ln2674">  if (curwin-&gt;w_p_rnu) {</a>
<a name="ln2675">    redraw_later(curwin, SOME_VALID);  // cursor moved to start</a>
<a name="ln2676">  }</a>
<a name="ln2677">  if (message) {  // Display message about yank?</a>
<a name="ln2678">    if (yank_type == kMTCharWise &amp;&amp; yanklines == 1) {</a>
<a name="ln2679">      yanklines = 0;</a>
<a name="ln2680">    }</a>
<a name="ln2681">    // Some versions of Vi use &quot;&gt;=&quot; here, some don't...</a>
<a name="ln2682">    if (yanklines &gt; (size_t)p_report) {</a>
<a name="ln2683">      char namebuf[100];</a>
<a name="ln2684"> </a>
<a name="ln2685">      if (oap-&gt;regname == NUL) {</a>
<a name="ln2686">        *namebuf = NUL;</a>
<a name="ln2687">      } else {</a>
<a name="ln2688">        vim_snprintf(namebuf, sizeof(namebuf), _(&quot; into \&quot;%c&quot;), oap-&gt;regname);</a>
<a name="ln2689">      }</a>
<a name="ln2690"> </a>
<a name="ln2691">      // redisplay now, so message is not deleted</a>
<a name="ln2692">      update_topline_redraw();</a>
<a name="ln2693">      if (yanklines == 1) {</a>
<a name="ln2694">        if (yank_type == kMTBlockWise) {</a>
<a name="ln2695">          smsg(_(&quot;block of 1 line yanked%s&quot;), namebuf);</a>
<a name="ln2696">        } else {</a>
<a name="ln2697">          smsg(_(&quot;1 line yanked%s&quot;), namebuf);</a>
<a name="ln2698">        }</a>
<a name="ln2699">      } else if (yank_type == kMTBlockWise) {</a>
<a name="ln2700">        smsg(_(&quot;block of %&quot; PRId64 &quot; lines yanked%s&quot;),</a>
<a name="ln2701">             (int64_t)yanklines, namebuf);</a>
<a name="ln2702">      } else {</a>
<a name="ln2703">        smsg(_(&quot;%&quot; PRId64 &quot; lines yanked%s&quot;), (int64_t)yanklines, namebuf);</a>
<a name="ln2704">      }</a>
<a name="ln2705">    }</a>
<a name="ln2706">  }</a>
<a name="ln2707"> </a>
<a name="ln2708">  /*</a>
<a name="ln2709">   * Set &quot;'[&quot; and &quot;']&quot; marks.</a>
<a name="ln2710">   */</a>
<a name="ln2711">  curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln2712">  curbuf-&gt;b_op_end = oap-&gt;end;</a>
<a name="ln2713">  if (yank_type == kMTLineWise) {</a>
<a name="ln2714">    curbuf-&gt;b_op_start.col = 0;</a>
<a name="ln2715">    curbuf-&gt;b_op_end.col = MAXCOL;</a>
<a name="ln2716">  }</a>
<a name="ln2717"> </a>
<a name="ln2718">  return;</a>
<a name="ln2719">}</a>
<a name="ln2720"> </a>
<a name="ln2721">static void yank_copy_line(yankreg_T *reg, struct block_def *bd, size_t y_idx)</a>
<a name="ln2722">{</a>
<a name="ln2723">  int size = bd-&gt;startspaces + bd-&gt;endspaces + bd-&gt;textlen;</a>
<a name="ln2724">  assert(size &gt;= 0);</a>
<a name="ln2725">  char_u *pnew = xmallocz((size_t)size);</a>
<a name="ln2726">  reg-&gt;y_array[y_idx] = pnew;</a>
<a name="ln2727">  memset(pnew, ' ', (size_t)bd-&gt;startspaces);</a>
<a name="ln2728">  pnew += bd-&gt;startspaces;</a>
<a name="ln2729">  memmove(pnew, bd-&gt;textstart, (size_t)bd-&gt;textlen);</a>
<a name="ln2730">  pnew += bd-&gt;textlen;</a>
<a name="ln2731">  memset(pnew, ' ', (size_t)bd-&gt;endspaces);</a>
<a name="ln2732">  pnew += bd-&gt;endspaces;</a>
<a name="ln2733">  *pnew = NUL;</a>
<a name="ln2734">}</a>
<a name="ln2735"> </a>
<a name="ln2736">/// Execute autocommands for TextYankPost.</a>
<a name="ln2737">///</a>
<a name="ln2738">/// @param oap Operator arguments.</a>
<a name="ln2739">/// @param reg The yank register used.</a>
<a name="ln2740">static void do_autocmd_textyankpost(oparg_T *oap, yankreg_T *reg)</a>
<a name="ln2741">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2742">{</a>
<a name="ln2743">  static bool recursive = false;</a>
<a name="ln2744"> </a>
<a name="ln2745">  if (recursive || !has_event(EVENT_TEXTYANKPOST)) {</a>
<a name="ln2746">    // No autocommand was defined, or we yanked from this autocommand.</a>
<a name="ln2747">    return;</a>
<a name="ln2748">  }</a>
<a name="ln2749"> </a>
<a name="ln2750">  recursive = true;</a>
<a name="ln2751"> </a>
<a name="ln2752">  // Set the v:event dictionary with information about the yank.</a>
<a name="ln2753">  dict_T *dict = get_vim_var_dict(VV_EVENT);</a>
<a name="ln2754"> </a>
<a name="ln2755">  // The yanked text contents.</a>
<a name="ln2756">  list_T *const list = tv_list_alloc((ptrdiff_t)reg-&gt;y_size);</a>
<a name="ln2757">  for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln2758">    tv_list_append_string(list, (const char *)reg-&gt;y_array[i], -1);</a>
<a name="ln2759">  }</a>
<a name="ln2760">  tv_list_set_lock(list, VAR_FIXED);</a>
<a name="ln2761">  tv_dict_add_list(dict, S_LEN(&quot;regcontents&quot;), list);</a>
<a name="ln2762"> </a>
<a name="ln2763">  // Register type.</a>
<a name="ln2764">  char buf[NUMBUFLEN+2];</a>
<a name="ln2765">  format_reg_type(reg-&gt;y_type, reg-&gt;y_width, buf, ARRAY_SIZE(buf));</a>
<a name="ln2766">  tv_dict_add_str(dict, S_LEN(&quot;regtype&quot;), buf);</a>
<a name="ln2767"> </a>
<a name="ln2768">  // Name of requested register, or empty string for unnamed operation.</a>
<a name="ln2769">  buf[0] = (char)oap-&gt;regname;</a>
<a name="ln2770">  buf[1] = NUL;</a>
<a name="ln2771">  tv_dict_add_str(dict, S_LEN(&quot;regname&quot;), buf);</a>
<a name="ln2772"> </a>
<a name="ln2773">  // Motion type: inclusive or exclusive.</a>
<a name="ln2774">  tv_dict_add_bool(dict, S_LEN(&quot;inclusive&quot;),</a>
<a name="ln2775">                   oap-&gt;inclusive ? kBoolVarTrue : kBoolVarFalse);</a>
<a name="ln2776"> </a>
<a name="ln2777">  // Kind of operation: yank, delete, change).</a>
<a name="ln2778">  buf[0] = (char)get_op_char(oap-&gt;op_type);</a>
<a name="ln2779">  buf[1] = NUL;</a>
<a name="ln2780">  tv_dict_add_str(dict, S_LEN(&quot;operator&quot;), buf);</a>
<a name="ln2781"> </a>
<a name="ln2782">  // Selection type: visual or not.</a>
<a name="ln2783">  tv_dict_add_bool(dict, S_LEN(&quot;visual&quot;),</a>
<a name="ln2784">                   oap-&gt;is_VIsual ? kBoolVarTrue : kBoolVarFalse);</a>
<a name="ln2785"> </a>
<a name="ln2786">  tv_dict_set_keys_readonly(dict);</a>
<a name="ln2787">  textlock++;</a>
<a name="ln2788">  apply_autocmds(EVENT_TEXTYANKPOST, NULL, NULL, false, curbuf);</a>
<a name="ln2789">  textlock--;</a>
<a name="ln2790">  tv_dict_clear(dict);</a>
<a name="ln2791"> </a>
<a name="ln2792">  recursive = false;</a>
<a name="ln2793">}</a>
<a name="ln2794"> </a>
<a name="ln2795">/*</a>
<a name="ln2796"> * Put contents of register &quot;regname&quot; into the text.</a>
<a name="ln2797"> * Caller must check &quot;regname&quot; to be valid!</a>
<a name="ln2798"> * &quot;flags&quot;: PUT_FIXINDENT     make indent look nice</a>
<a name="ln2799"> *          PUT_CURSEND       leave cursor after end of new text</a>
<a name="ln2800"> *          PUT_LINE          force linewise put (&quot;:put&quot;)</a>
<a name="ln2801">    dir: BACKWARD for 'P', FORWARD for 'p' */</a>
<a name="ln2802">void do_put(int regname, yankreg_T *reg, int dir, long count, int flags)</a>
<a name="ln2803">{</a>
<a name="ln2804">  char_u *ptr;</a>
<a name="ln2805">  char_u *newp;</a>
<a name="ln2806">  char_u *oldp;</a>
<a name="ln2807">  int yanklen;</a>
<a name="ln2808">  size_t totlen = 0;  // init for gcc</a>
<a name="ln2809">  linenr_T lnum = 0;</a>
<a name="ln2810">  colnr_T col = 0;</a>
<a name="ln2811">  size_t i;  // index in y_array[]</a>
<a name="ln2812">  MotionType y_type;</a>
<a name="ln2813">  size_t y_size;</a>
<a name="ln2814">  size_t oldlen;</a>
<a name="ln2815">  int y_width = 0;</a>
<a name="ln2816">  colnr_T vcol = 0;</a>
<a name="ln2817">  int delcount;</a>
<a name="ln2818">  int incr = 0;</a>
<a name="ln2819">  struct block_def bd;</a>
<a name="ln2820">  char_u      **y_array = NULL;</a>
<a name="ln2821">  long nr_lines = 0;</a>
<a name="ln2822">  pos_T new_cursor;</a>
<a name="ln2823">  int indent;</a>
<a name="ln2824">  int orig_indent = 0;                  /* init for gcc */</a>
<a name="ln2825">  int indent_diff = 0;                  /* init for gcc */</a>
<a name="ln2826">  int first_indent = TRUE;</a>
<a name="ln2827">  int lendiff = 0;</a>
<a name="ln2828">  pos_T old_pos;</a>
<a name="ln2829">  char_u      *insert_string = NULL;</a>
<a name="ln2830">  bool allocated = false;</a>
<a name="ln2831">  long cnt;</a>
<a name="ln2832"> </a>
<a name="ln2833">  if (flags &amp; PUT_FIXINDENT)</a>
<a name="ln2834">    orig_indent = get_indent();</a>
<a name="ln2835"> </a>
<a name="ln2836">  curbuf-&gt;b_op_start = curwin-&gt;w_cursor;        /* default for '[ mark */</a>
<a name="ln2837">  curbuf-&gt;b_op_end = curwin-&gt;w_cursor;          /* default for '] mark */</a>
<a name="ln2838"> </a>
<a name="ln2839">  /*</a>
<a name="ln2840">   * Using inserted text works differently, because the register includes</a>
<a name="ln2841">   * special characters (newlines, etc.).</a>
<a name="ln2842">   */</a>
<a name="ln2843">  if (regname == '.' &amp;&amp; !reg) {</a>
<a name="ln2844">    bool non_linewise_vis = (VIsual_active &amp;&amp; VIsual_mode != 'V');</a>
<a name="ln2845"> </a>
<a name="ln2846">    // PUT_LINE has special handling below which means we use 'i' to start.</a>
<a name="ln2847">    char command_start_char = non_linewise_vis ? 'c' :</a>
<a name="ln2848">      (flags &amp; PUT_LINE ? 'i' : (dir == FORWARD ? 'a' : 'i'));</a>
<a name="ln2849"> </a>
<a name="ln2850">    // To avoid 'autoindent' on linewise puts, create a new line with `:put _`.</a>
<a name="ln2851">    if (flags &amp; PUT_LINE) {</a>
<a name="ln2852">      do_put('_', NULL, dir, 1, PUT_LINE);</a>
<a name="ln2853">    }</a>
<a name="ln2854"> </a>
<a name="ln2855">    // If given a count when putting linewise, we stuff the readbuf with the</a>
<a name="ln2856">    // dot register 'count' times split by newlines.</a>
<a name="ln2857">    if (flags &amp; PUT_LINE) {</a>
<a name="ln2858">      stuffcharReadbuff(command_start_char);</a>
<a name="ln2859">      for (; count &gt; 0; count--) {</a>
<a name="ln2860">        (void)stuff_inserted(NUL, 1, count != 1);</a>
<a name="ln2861">        if (count != 1) {</a>
<a name="ln2862">          // To avoid 'autoindent' affecting the text, use Ctrl_U to remove any</a>
<a name="ln2863">          // whitespace. Can't just insert Ctrl_U into readbuf1, this would go</a>
<a name="ln2864">          // back to the previous line in the case of 'noautoindent' and</a>
<a name="ln2865">          // 'backspace' includes &quot;eol&quot;. So we insert a dummy space for Ctrl_U</a>
<a name="ln2866">          // to consume.</a>
<a name="ln2867">          stuffReadbuff(&quot;\n &quot;);</a>
<a name="ln2868">          stuffcharReadbuff(Ctrl_U);</a>
<a name="ln2869">        }</a>
<a name="ln2870">      }</a>
<a name="ln2871">    } else {</a>
<a name="ln2872">      (void)stuff_inserted(command_start_char, count, false);</a>
<a name="ln2873">    }</a>
<a name="ln2874"> </a>
<a name="ln2875">    // Putting the text is done later, so can't move the cursor to the next</a>
<a name="ln2876">    // character.  Simulate it with motion commands after the insert.</a>
<a name="ln2877">    if (flags &amp; PUT_CURSEND) {</a>
<a name="ln2878">      if (flags &amp; PUT_LINE) {</a>
<a name="ln2879">        stuffReadbuff(&quot;j0&quot;);</a>
<a name="ln2880">      } else {</a>
<a name="ln2881">        // Avoid ringing the bell from attempting to move into the space after</a>
<a name="ln2882">        // the current line. We can stuff the readbuffer with &quot;l&quot; if:</a>
<a name="ln2883">        // 1) 'virtualedit' is &quot;all&quot; or &quot;onemore&quot;</a>
<a name="ln2884">        // 2) We are not at the end of the line</a>
<a name="ln2885">        // 3) We are not  (one past the end of the line &amp;&amp; on the last line)</a>
<a name="ln2886">        //    This allows a visual put over a selection one past the end of the</a>
<a name="ln2887">        //    line joining the current line with the one below.</a>
<a name="ln2888"> </a>
<a name="ln2889">        // curwin-&gt;w_cursor.col marks the byte position of the cursor in the</a>
<a name="ln2890">        // currunt line. It increases up to a max of</a>
<a name="ln2891">        // STRLEN(ml_get(curwin-&gt;w_cursor.lnum)). With 'virtualedit' and the</a>
<a name="ln2892">        // cursor past the end of the line, curwin-&gt;w_cursor.coladd is</a>
<a name="ln2893">        // incremented instead of curwin-&gt;w_cursor.col.</a>
<a name="ln2894">        char_u *cursor_pos = get_cursor_pos_ptr();</a>
<a name="ln2895">        bool one_past_line = (*cursor_pos == NUL);</a>
<a name="ln2896">        bool eol = false;</a>
<a name="ln2897">        if (!one_past_line) {</a>
<a name="ln2898">          eol = (*(cursor_pos + mb_ptr2len(cursor_pos)) == NUL);</a>
<a name="ln2899">        }</a>
<a name="ln2900"> </a>
<a name="ln2901">        bool ve_allows = (ve_flags == VE_ALL || ve_flags == VE_ONEMORE);</a>
<a name="ln2902">        bool eof = curbuf-&gt;b_ml.ml_line_count == curwin-&gt;w_cursor.lnum</a>
<a name="ln2903">                   &amp;&amp; one_past_line;</a>
<a name="ln2904">        if (ve_allows || !(eol || eof)) {</a>
<a name="ln2905">          stuffcharReadbuff('l');</a>
<a name="ln2906">        }</a>
<a name="ln2907">      }</a>
<a name="ln2908">    } else if (flags &amp; PUT_LINE) {</a>
<a name="ln2909">      stuffReadbuff(&quot;g'[&quot;);</a>
<a name="ln2910">    }</a>
<a name="ln2911"> </a>
<a name="ln2912">    // So the 'u' command restores cursor position after &quot;.p, save the cursor</a>
<a name="ln2913">    // position now (though not saving any text).</a>
<a name="ln2914">    if (command_start_char == 'a') {</a>
<a name="ln2915">      if (u_save(curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.lnum + 1) == FAIL) {</a>
<a name="ln2916">        return;</a>
<a name="ln2917">      }</a>
<a name="ln2918">    }</a>
<a name="ln2919">    return;</a>
<a name="ln2920">  }</a>
<a name="ln2921"> </a>
<a name="ln2922">  /*</a>
<a name="ln2923">   * For special registers '%' (file name), '#' (alternate file name) and</a>
<a name="ln2924">   * ':' (last command line), etc. we have to create a fake yank register.</a>
<a name="ln2925">   */</a>
<a name="ln2926">  if (!reg &amp;&amp; get_spec_reg(regname, &amp;insert_string, &amp;allocated, true)) {</a>
<a name="ln2927">    if (insert_string == NULL) {</a>
<a name="ln2928">      return;</a>
<a name="ln2929">    }</a>
<a name="ln2930">  }</a>
<a name="ln2931"> </a>
<a name="ln2932">  if (!curbuf-&gt;terminal) {</a>
<a name="ln2933">    // Autocommands may be executed when saving lines for undo.  This might</a>
<a name="ln2934">    // make y_array invalid, so we start undo now to avoid that.</a>
<a name="ln2935">    if (u_save(curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.lnum + 1) == FAIL) {</a>
<a name="ln2936">      return;</a>
<a name="ln2937">    }</a>
<a name="ln2938">  }</a>
<a name="ln2939"> </a>
<a name="ln2940">  if (insert_string != NULL) {</a>
<a name="ln2941">    y_type = kMTCharWise;</a>
<a name="ln2942">    if (regname == '=') {</a>
<a name="ln2943">      /* For the = register we need to split the string at NL</a>
<a name="ln2944">       * characters.</a>
<a name="ln2945">       * Loop twice: count the number of lines and save them. */</a>
<a name="ln2946">      for (;; ) {</a>
<a name="ln2947">        y_size = 0;</a>
<a name="ln2948">        ptr = insert_string;</a>
<a name="ln2949">        while (ptr != NULL) {</a>
<a name="ln2950">          if (y_array != NULL)</a>
<a name="ln2951">            y_array[y_size] = ptr;</a>
<a name="ln2952">          ++y_size;</a>
<a name="ln2953">          ptr = vim_strchr(ptr, '\n');</a>
<a name="ln2954">          if (ptr != NULL) {</a>
<a name="ln2955">            if (y_array != NULL)</a>
<a name="ln2956">              *ptr = NUL;</a>
<a name="ln2957">            ++ptr;</a>
<a name="ln2958">            /* A trailing '\n' makes the register linewise. */</a>
<a name="ln2959">            if (*ptr == NUL) {</a>
<a name="ln2960">              y_type = kMTLineWise;</a>
<a name="ln2961">              break;</a>
<a name="ln2962">            }</a>
<a name="ln2963">          }</a>
<a name="ln2964">        }</a>
<a name="ln2965">        if (y_array != NULL)</a>
<a name="ln2966">          break;</a>
<a name="ln2967">        y_array = (char_u **)xmalloc(y_size * sizeof(char_u *));</a>
<a name="ln2968">      }</a>
<a name="ln2969">    } else {</a>
<a name="ln2970">      y_size = 1;               /* use fake one-line yank register */</a>
<a name="ln2971">      y_array = &amp;insert_string;</a>
<a name="ln2972">    }</a>
<a name="ln2973">  } else {</a>
<a name="ln2974">    // in case of replacing visually selected text</a>
<a name="ln2975">    // the yankreg might already have been saved to avoid</a>
<a name="ln2976">    // just restoring the deleted text.</a>
<a name="ln2977">    if (reg == NULL) {</a>
<a name="ln2978">      reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln2979">    }</a>
<a name="ln2980"> </a>
<a name="ln2981">    y_type = reg-&gt;y_type;</a>
<a name="ln2982">    y_width = reg-&gt;y_width;</a>
<a name="ln2983">    y_size = reg-&gt;y_size;</a>
<a name="ln2984">    y_array = reg-&gt;y_array;</a>
<a name="ln2985">  }</a>
<a name="ln2986"> </a>
<a name="ln2987">  if (curbuf-&gt;terminal) {</a>
<a name="ln2988">    terminal_paste(count, y_array, y_size);</a>
<a name="ln2989">    return;</a>
<a name="ln2990">  }</a>
<a name="ln2991"> </a>
<a name="ln2992">  if (y_type == kMTLineWise) {</a>
<a name="ln2993">    if (flags &amp; PUT_LINE_SPLIT) {</a>
<a name="ln2994">      // &quot;p&quot; or &quot;P&quot; in Visual mode: split the lines to put the text in</a>
<a name="ln2995">      // between.</a>
<a name="ln2996">      if (u_save_cursor() == FAIL) {</a>
<a name="ln2997">        goto end;</a>
<a name="ln2998">      }</a>
<a name="ln2999">      char_u *p = get_cursor_pos_ptr();</a>
<a name="ln3000">      if (dir == FORWARD &amp;&amp; *p != NUL) {</a>
<a name="ln3001">        MB_PTR_ADV(p);</a>
<a name="ln3002">      }</a>
<a name="ln3003">      ptr = vim_strsave(p);</a>
<a name="ln3004">      ml_append(curwin-&gt;w_cursor.lnum, ptr, (colnr_T)0, false);</a>
<a name="ln3005">      xfree(ptr);</a>
<a name="ln3006"> </a>
<a name="ln3007">      oldp = get_cursor_line_ptr();</a>
<a name="ln3008">      p = oldp + curwin-&gt;w_cursor.col;</a>
<a name="ln3009">      if (dir == FORWARD &amp;&amp; *p != NUL) {</a>
<a name="ln3010">        MB_PTR_ADV(p);</a>
<a name="ln3011">      }</a>
<a name="ln3012">      ptr = vim_strnsave(oldp, (size_t)(p - oldp));</a>
<a name="ln3013">      ml_replace(curwin-&gt;w_cursor.lnum, ptr, false);</a>
<a name="ln3014">      nr_lines++;</a>
<a name="ln3015">      dir = FORWARD;</a>
<a name="ln3016">    }</a>
<a name="ln3017">    if (flags &amp; PUT_LINE_FORWARD) {</a>
<a name="ln3018">      /* Must be &quot;p&quot; for a Visual block, put lines below the block. */</a>
<a name="ln3019">      curwin-&gt;w_cursor = curbuf-&gt;b_visual.vi_end;</a>
<a name="ln3020">      dir = FORWARD;</a>
<a name="ln3021">    }</a>
<a name="ln3022">    curbuf-&gt;b_op_start = curwin-&gt;w_cursor;      /* default for '[ mark */</a>
<a name="ln3023">    curbuf-&gt;b_op_end = curwin-&gt;w_cursor;        /* default for '] mark */</a>
<a name="ln3024">  }</a>
<a name="ln3025"> </a>
<a name="ln3026">  if (flags &amp; PUT_LINE) {  // :put command or &quot;p&quot; in Visual line mode.</a>
<a name="ln3027">    y_type = kMTLineWise;</a>
<a name="ln3028">  }</a>
<a name="ln3029"> </a>
<a name="ln3030">  if (y_size == 0 || y_array == NULL) {</a>
<a name="ln3031">    EMSG2(_(&quot;E353: Nothing in register %s&quot;),</a>
<a name="ln3032">        regname == 0 ? (char_u *)&quot;\&quot;&quot; : transchar(regname));</a>
<a name="ln3033">    goto end;</a>
<a name="ln3034">  }</a>
<a name="ln3035"> </a>
<a name="ln3036">  if (y_type == kMTBlockWise) {</a>
<a name="ln3037">    lnum = curwin-&gt;w_cursor.lnum + (linenr_T)y_size + 1;</a>
<a name="ln3038">    if (lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3039">      lnum = curbuf-&gt;b_ml.ml_line_count + 1;</a>
<a name="ln3040">    }</a>
<a name="ln3041">    if (u_save(curwin-&gt;w_cursor.lnum - 1, lnum) == FAIL) {</a>
<a name="ln3042">      goto end;</a>
<a name="ln3043">    }</a>
<a name="ln3044">  } else if (y_type == kMTLineWise) {</a>
<a name="ln3045">    lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3046">    // Correct line number for closed fold.  Don't move the cursor yet,</a>
<a name="ln3047">    // u_save() uses it.</a>
<a name="ln3048">    if (dir == BACKWARD) {</a>
<a name="ln3049">      (void)hasFolding(lnum, &amp;lnum, NULL);</a>
<a name="ln3050">    } else {</a>
<a name="ln3051">      (void)hasFolding(lnum, NULL, &amp;lnum);</a>
<a name="ln3052">    }</a>
<a name="ln3053">    if (dir == FORWARD) {</a>
<a name="ln3054">      lnum++;</a>
<a name="ln3055">    }</a>
<a name="ln3056">    // In an empty buffer the empty line is going to be replaced, include</a>
<a name="ln3057">    // it in the saved lines.</a>
<a name="ln3058">    if ((BUFEMPTY() ? u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL) {</a>
<a name="ln3059">      goto end;</a>
<a name="ln3060">    }</a>
<a name="ln3061">    if (dir == FORWARD) {</a>
<a name="ln3062">      curwin-&gt;w_cursor.lnum = lnum - 1;</a>
<a name="ln3063">    } else {</a>
<a name="ln3064">      curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3065">    }</a>
<a name="ln3066">    curbuf-&gt;b_op_start = curwin-&gt;w_cursor;      // for mark_adjust()</a>
<a name="ln3067">  } else if (u_save_cursor() == FAIL) {</a>
<a name="ln3068">    goto end;</a>
<a name="ln3069">  }</a>
<a name="ln3070"> </a>
<a name="ln3071">  yanklen = (int)STRLEN(y_array[0]);</a>
<a name="ln3072"> </a>
<a name="ln3073">  if (ve_flags == VE_ALL &amp;&amp; y_type == kMTCharWise) {</a>
<a name="ln3074">    if (gchar_cursor() == TAB) {</a>
<a name="ln3075">      /* Don't need to insert spaces when &quot;p&quot; on the last position of a</a>
<a name="ln3076">       * tab or &quot;P&quot; on the first position. */</a>
<a name="ln3077">      int viscol = getviscol();</a>
<a name="ln3078">      if (dir == FORWARD</a>
<a name="ln3079">          ? tabstop_padding(viscol, curbuf-&gt;b_p_ts, curbuf-&gt;b_p_vts_array) != 1</a>
<a name="ln3080">          : curwin-&gt;w_cursor.coladd &gt; 0) {</a>
<a name="ln3081">        coladvance_force(viscol);</a>
<a name="ln3082">      } else {</a>
<a name="ln3083">        curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln3084">      }</a>
<a name="ln3085">    } else if (curwin-&gt;w_cursor.coladd &gt; 0 || gchar_cursor() == NUL) {</a>
<a name="ln3086">      coladvance_force(getviscol() + (dir == FORWARD));</a>
<a name="ln3087">    }</a>
<a name="ln3088">  }</a>
<a name="ln3089"> </a>
<a name="ln3090">  lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3091">  col = curwin-&gt;w_cursor.col;</a>
<a name="ln3092"> </a>
<a name="ln3093">  /*</a>
<a name="ln3094">   * Block mode</a>
<a name="ln3095">   */</a>
<a name="ln3096">  if (y_type == kMTBlockWise) {</a>
<a name="ln3097">    int c = gchar_cursor();</a>
<a name="ln3098">    colnr_T endcol2 = 0;</a>
<a name="ln3099"> </a>
<a name="ln3100">    if (dir == FORWARD &amp;&amp; c != NUL) {</a>
<a name="ln3101">      if (ve_flags == VE_ALL)</a>
<a name="ln3102">        getvcol(curwin, &amp;curwin-&gt;w_cursor, &amp;col, NULL, &amp;endcol2);</a>
<a name="ln3103">      else</a>
<a name="ln3104">        getvcol(curwin, &amp;curwin-&gt;w_cursor, NULL, NULL, &amp;col);</a>
<a name="ln3105"> </a>
<a name="ln3106">      // move to start of next multi-byte character</a>
<a name="ln3107">      curwin-&gt;w_cursor.col += utfc_ptr2len(get_cursor_pos_ptr());</a>
<a name="ln3108">      col++;</a>
<a name="ln3109">    } else {</a>
<a name="ln3110">      getvcol(curwin, &amp;curwin-&gt;w_cursor, &amp;col, NULL, &amp;endcol2);</a>
<a name="ln3111">    }</a>
<a name="ln3112"> </a>
<a name="ln3113">    col += curwin-&gt;w_cursor.coladd;</a>
<a name="ln3114">    if (ve_flags == VE_ALL</a>
<a name="ln3115">        &amp;&amp; (curwin-&gt;w_cursor.coladd &gt; 0</a>
<a name="ln3116">            || endcol2 == curwin-&gt;w_cursor.col)) {</a>
<a name="ln3117">      if (dir == FORWARD &amp;&amp; c == NUL) {</a>
<a name="ln3118">        col++;</a>
<a name="ln3119">      }</a>
<a name="ln3120">      if (dir != FORWARD &amp;&amp; c != NUL &amp;&amp; curwin-&gt;w_cursor.coladd &gt; 0) {</a>
<a name="ln3121">        curwin-&gt;w_cursor.col++;</a>
<a name="ln3122">      }</a>
<a name="ln3123">      if (c == TAB) {</a>
<a name="ln3124">        if (dir == BACKWARD &amp;&amp; curwin-&gt;w_cursor.col)</a>
<a name="ln3125">          curwin-&gt;w_cursor.col--;</a>
<a name="ln3126">        if (dir == FORWARD &amp;&amp; col - 1 == endcol2)</a>
<a name="ln3127">          curwin-&gt;w_cursor.col++;</a>
<a name="ln3128">      }</a>
<a name="ln3129">    }</a>
<a name="ln3130">    curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln3131">    bd.textcol = 0;</a>
<a name="ln3132">    for (i = 0; i &lt; y_size; i++) {</a>
<a name="ln3133">      int spaces;</a>
<a name="ln3134">      char shortline;</a>
<a name="ln3135">      // can just be 0 or 1, needed for blockwise paste beyond the current</a>
<a name="ln3136">      // buffer end</a>
<a name="ln3137">      int lines_appended = 0;</a>
<a name="ln3138"> </a>
<a name="ln3139">      bd.startspaces = 0;</a>
<a name="ln3140">      bd.endspaces = 0;</a>
<a name="ln3141">      vcol = 0;</a>
<a name="ln3142">      delcount = 0;</a>
<a name="ln3143"> </a>
<a name="ln3144">      /* add a new line */</a>
<a name="ln3145">      if (curwin-&gt;w_cursor.lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3146">        if (ml_append(curbuf-&gt;b_ml.ml_line_count, (char_u *)&quot;&quot;,</a>
<a name="ln3147">                      (colnr_T)1, false) == FAIL) {</a>
<a name="ln3148">          break;</a>
<a name="ln3149">        }</a>
<a name="ln3150">        nr_lines++;</a>
<a name="ln3151">        lines_appended = 1;</a>
<a name="ln3152">      }</a>
<a name="ln3153">      /* get the old line and advance to the position to insert at */</a>
<a name="ln3154">      oldp = get_cursor_line_ptr();</a>
<a name="ln3155">      oldlen = STRLEN(oldp);</a>
<a name="ln3156">      for (ptr = oldp; vcol &lt; col &amp;&amp; *ptr; ) {</a>
<a name="ln3157">        /* Count a tab for what it's worth (if list mode not on) */</a>
<a name="ln3158">        incr = lbr_chartabsize_adv(oldp, &amp;ptr, (colnr_T)vcol);</a>
<a name="ln3159">        vcol += incr;</a>
<a name="ln3160">      }</a>
<a name="ln3161">      bd.textcol = (colnr_T)(ptr - oldp);</a>
<a name="ln3162"> </a>
<a name="ln3163">      shortline = (vcol &lt; col) || (vcol == col &amp;&amp; !*ptr);</a>
<a name="ln3164"> </a>
<a name="ln3165">      if (vcol &lt; col)       /* line too short, padd with spaces */</a>
<a name="ln3166">        bd.startspaces = col - vcol;</a>
<a name="ln3167">      else if (vcol &gt; col) {</a>
<a name="ln3168">        bd.endspaces = vcol - col;</a>
<a name="ln3169">        bd.startspaces = incr - bd.endspaces;</a>
<a name="ln3170">        --bd.textcol;</a>
<a name="ln3171">        delcount = 1;</a>
<a name="ln3172">        bd.textcol -= utf_head_off(oldp, oldp + bd.textcol);</a>
<a name="ln3173">        if (oldp[bd.textcol] != TAB) {</a>
<a name="ln3174">          /* Only a Tab can be split into spaces.  Other</a>
<a name="ln3175">           * characters will have to be moved to after the</a>
<a name="ln3176">           * block, causing misalignment. */</a>
<a name="ln3177">          delcount = 0;</a>
<a name="ln3178">          bd.endspaces = 0;</a>
<a name="ln3179">        }</a>
<a name="ln3180">      }</a>
<a name="ln3181"> </a>
<a name="ln3182">      yanklen = (int)STRLEN(y_array[i]);</a>
<a name="ln3183"> </a>
<a name="ln3184">      // calculate number of spaces required to fill right side of block</a>
<a name="ln3185">      spaces = y_width + 1;</a>
<a name="ln3186">      for (long j = 0; j &lt; yanklen; j++) {</a>
<a name="ln3187">        spaces -= lbr_chartabsize(NULL, &amp;y_array[i][j], 0);</a>
<a name="ln3188">      }</a>
<a name="ln3189">      if (spaces &lt; 0) {</a>
<a name="ln3190">        spaces = 0;</a>
<a name="ln3191">      }</a>
<a name="ln3192"> </a>
<a name="ln3193">      // insert the new text</a>
<a name="ln3194">      totlen = (size_t)(count * (yanklen + spaces)</a>
<a name="ln3195">                        + bd.startspaces + bd.endspaces);</a>
<a name="ln3196">      int addcount = (int)totlen + lines_appended;</a>
<a name="ln3197">      newp = (char_u *)xmalloc(totlen + oldlen + 1);</a>
<a name="ln3198">      // copy part up to cursor to new line</a>
<a name="ln3199">      ptr = newp;</a>
<a name="ln3200">      memmove(ptr, oldp, (size_t)bd.textcol);</a>
<a name="ln3201">      ptr += bd.textcol;</a>
<a name="ln3202">      // may insert some spaces before the new text</a>
<a name="ln3203">      memset(ptr, ' ', (size_t)bd.startspaces);</a>
<a name="ln3204">      ptr += bd.startspaces;</a>
<a name="ln3205">      // insert the new text</a>
<a name="ln3206">      for (long j = 0; j &lt; count; j++) {</a>
<a name="ln3207">        memmove(ptr, y_array[i], (size_t)yanklen);</a>
<a name="ln3208">        ptr += yanklen;</a>
<a name="ln3209"> </a>
<a name="ln3210">        // insert block's trailing spaces only if there's text behind</a>
<a name="ln3211">        if ((j &lt; count - 1 || !shortline) &amp;&amp; spaces) {</a>
<a name="ln3212">          memset(ptr, ' ', (size_t)spaces);</a>
<a name="ln3213">          ptr += spaces;</a>
<a name="ln3214">        } else {</a>
<a name="ln3215">          addcount -= spaces;</a>
<a name="ln3216">        }</a>
<a name="ln3217">      }</a>
<a name="ln3218">      // may insert some spaces after the new text</a>
<a name="ln3219">      memset(ptr, ' ', (size_t)bd.endspaces);</a>
<a name="ln3220">      ptr += bd.endspaces;</a>
<a name="ln3221">      // move the text after the cursor to the end of the line.</a>
<a name="ln3222">      int columns = (int)oldlen - bd.textcol - delcount + 1;</a>
<a name="ln3223">      assert(columns &gt;= 0);</a>
<a name="ln3224">      memmove(ptr, oldp + bd.textcol + delcount, (size_t)columns);</a>
<a name="ln3225">      ml_replace(curwin-&gt;w_cursor.lnum, newp, false);</a>
<a name="ln3226">      extmark_splice_cols(curbuf, (int)curwin-&gt;w_cursor.lnum-1, bd.textcol,</a>
<a name="ln3227">                          delcount, addcount, kExtmarkUndo);</a>
<a name="ln3228"> </a>
<a name="ln3229">      ++curwin-&gt;w_cursor.lnum;</a>
<a name="ln3230">      if (i == 0)</a>
<a name="ln3231">        curwin-&gt;w_cursor.col += bd.startspaces;</a>
<a name="ln3232">    }</a>
<a name="ln3233"> </a>
<a name="ln3234">    changed_lines(lnum, 0, curbuf-&gt;b_op_start.lnum + (linenr_T)y_size</a>
<a name="ln3235">                  - (linenr_T)nr_lines , nr_lines, true);</a>
<a name="ln3236"> </a>
<a name="ln3237">    /* Set '[ mark. */</a>
<a name="ln3238">    curbuf-&gt;b_op_start = curwin-&gt;w_cursor;</a>
<a name="ln3239">    curbuf-&gt;b_op_start.lnum = lnum;</a>
<a name="ln3240"> </a>
<a name="ln3241">    /* adjust '] mark */</a>
<a name="ln3242">    curbuf-&gt;b_op_end.lnum = curwin-&gt;w_cursor.lnum - 1;</a>
<a name="ln3243">    curbuf-&gt;b_op_end.col = bd.textcol + (colnr_T)totlen - 1;</a>
<a name="ln3244">    curbuf-&gt;b_op_end.coladd = 0;</a>
<a name="ln3245">    if (flags &amp; PUT_CURSEND) {</a>
<a name="ln3246">      colnr_T len;</a>
<a name="ln3247"> </a>
<a name="ln3248">      curwin-&gt;w_cursor = curbuf-&gt;b_op_end;</a>
<a name="ln3249">      curwin-&gt;w_cursor.col++;</a>
<a name="ln3250"> </a>
<a name="ln3251">      /* in Insert mode we might be after the NUL, correct for that */</a>
<a name="ln3252">      len = (colnr_T)STRLEN(get_cursor_line_ptr());</a>
<a name="ln3253">      if (curwin-&gt;w_cursor.col &gt; len)</a>
<a name="ln3254">        curwin-&gt;w_cursor.col = len;</a>
<a name="ln3255">    } else</a>
<a name="ln3256">      curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3257">  } else {</a>
<a name="ln3258">    // Character or Line mode</a>
<a name="ln3259">    if (y_type == kMTCharWise) {</a>
<a name="ln3260">      // if type is kMTCharWise, FORWARD is the same as BACKWARD on the next</a>
<a name="ln3261">      // char</a>
<a name="ln3262">      if (dir == FORWARD &amp;&amp; gchar_cursor() != NUL) {</a>
<a name="ln3263">        int bytelen = (*mb_ptr2len)(get_cursor_pos_ptr());</a>
<a name="ln3264"> </a>
<a name="ln3265">        // put it on the next of the multi-byte character.</a>
<a name="ln3266">        col += bytelen;</a>
<a name="ln3267">        if (yanklen) {</a>
<a name="ln3268">          curwin-&gt;w_cursor.col += bytelen;</a>
<a name="ln3269">          curbuf-&gt;b_op_end.col += bytelen;</a>
<a name="ln3270">        }</a>
<a name="ln3271">      }</a>
<a name="ln3272">      curbuf-&gt;b_op_start = curwin-&gt;w_cursor;</a>
<a name="ln3273">    }</a>
<a name="ln3274">    /*</a>
<a name="ln3275">     * Line mode: BACKWARD is the same as FORWARD on the previous line</a>
<a name="ln3276">     */</a>
<a name="ln3277">    else if (dir == BACKWARD)</a>
<a name="ln3278">      --lnum;</a>
<a name="ln3279">    new_cursor = curwin-&gt;w_cursor;</a>
<a name="ln3280"> </a>
<a name="ln3281">    // simple case: insert into one line at a time</a>
<a name="ln3282">    if (y_type == kMTCharWise &amp;&amp; y_size == 1) {</a>
<a name="ln3283">      linenr_T end_lnum = 0;  // init for gcc</a>
<a name="ln3284">      linenr_T start_lnum = lnum;</a>
<a name="ln3285"> </a>
<a name="ln3286">      if (VIsual_active) {</a>
<a name="ln3287">        end_lnum = curbuf-&gt;b_visual.vi_end.lnum;</a>
<a name="ln3288">        if (end_lnum &lt; curbuf-&gt;b_visual.vi_start.lnum) {</a>
<a name="ln3289">            end_lnum = curbuf-&gt;b_visual.vi_start.lnum;</a>
<a name="ln3290">        }</a>
<a name="ln3291">        if (end_lnum &gt; start_lnum) {</a>
<a name="ln3292">          // &quot;col&quot; is valid for the first line, in following lines</a>
<a name="ln3293">          // the virtual column needs to be used.  Matters for</a>
<a name="ln3294">          // multi-byte characters.</a>
<a name="ln3295">          pos_T pos = {</a>
<a name="ln3296">            .lnum = lnum,</a>
<a name="ln3297">            .col = col,</a>
<a name="ln3298">            .coladd = 0,</a>
<a name="ln3299">          };</a>
<a name="ln3300">          getvcol(curwin, &amp;pos, NULL, &amp;vcol, NULL);</a>
<a name="ln3301">        }</a>
<a name="ln3302">      }</a>
<a name="ln3303"> </a>
<a name="ln3304">      do {</a>
<a name="ln3305">        totlen = (size_t)(count * yanklen);</a>
<a name="ln3306">        if (totlen &gt; 0) {</a>
<a name="ln3307">          oldp = ml_get(lnum);</a>
<a name="ln3308">          if (lnum &gt; start_lnum) {</a>
<a name="ln3309">            pos_T pos = {</a>
<a name="ln3310">              .lnum = lnum,</a>
<a name="ln3311">            };</a>
<a name="ln3312">            if (getvpos(&amp;pos, vcol) == OK) {</a>
<a name="ln3313">              col = pos.col;</a>
<a name="ln3314">            } else {</a>
<a name="ln3315">              col = MAXCOL;</a>
<a name="ln3316">            }</a>
<a name="ln3317">          }</a>
<a name="ln3318">          if (VIsual_active &amp;&amp; col &gt; (int)STRLEN(oldp)) {</a>
<a name="ln3319">            lnum++;</a>
<a name="ln3320">            continue;</a>
<a name="ln3321">          }</a>
<a name="ln3322">          newp = (char_u *)xmalloc((size_t)(STRLEN(oldp) + totlen + 1));</a>
<a name="ln3323">          memmove(newp, oldp, (size_t)col);</a>
<a name="ln3324">          ptr = newp + col;</a>
<a name="ln3325">          for (i = 0; i &lt; (size_t)count; i++) {</a>
<a name="ln3326">            memmove(ptr, y_array[0], (size_t)yanklen);</a>
<a name="ln3327">            ptr += yanklen;</a>
<a name="ln3328">          }</a>
<a name="ln3329">          STRMOVE(ptr, oldp + col);</a>
<a name="ln3330">          ml_replace(lnum, newp, false);</a>
<a name="ln3331">          // Place cursor on last putted char.</a>
<a name="ln3332">          if (lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln3333">            // make sure curwin-&gt;w_virtcol is updated</a>
<a name="ln3334">            changed_cline_bef_curs();</a>
<a name="ln3335">            curwin-&gt;w_cursor.col += (colnr_T)(totlen - 1);</a>
<a name="ln3336">          }</a>
<a name="ln3337">        }</a>
<a name="ln3338">        if (VIsual_active) {</a>
<a name="ln3339">          lnum++;</a>
<a name="ln3340">        }</a>
<a name="ln3341">      } while (VIsual_active &amp;&amp; lnum &lt;= end_lnum);</a>
<a name="ln3342"> </a>
<a name="ln3343">      if (VIsual_active) {  /* reset lnum to the last visual line */</a>
<a name="ln3344">        lnum--;</a>
<a name="ln3345">      }</a>
<a name="ln3346"> </a>
<a name="ln3347">      curbuf-&gt;b_op_end = curwin-&gt;w_cursor;</a>
<a name="ln3348">      /* For &quot;CTRL-O p&quot; in Insert mode, put cursor after last char */</a>
<a name="ln3349">      if (totlen &amp;&amp; (restart_edit != 0 || (flags &amp; PUT_CURSEND)))</a>
<a name="ln3350">        ++curwin-&gt;w_cursor.col;</a>
<a name="ln3351">      changed_bytes(lnum, col);</a>
<a name="ln3352">      extmark_splice_cols(curbuf, (int)lnum-1, col,</a>
<a name="ln3353">                          0, (int)totlen, kExtmarkUndo);</a>
<a name="ln3354">    } else {</a>
<a name="ln3355">      // Insert at least one line.  When y_type is kMTCharWise, break the first</a>
<a name="ln3356">      // line in two.</a>
<a name="ln3357">      for (cnt = 1; cnt &lt;= count; cnt++) {</a>
<a name="ln3358">        i = 0;</a>
<a name="ln3359">        if (y_type == kMTCharWise) {</a>
<a name="ln3360">          // Split the current line in two at the insert position.</a>
<a name="ln3361">          // First insert y_array[size - 1] in front of second line.</a>
<a name="ln3362">          // Then append y_array[0] to first line.</a>
<a name="ln3363">          lnum = new_cursor.lnum;</a>
<a name="ln3364">          ptr = ml_get(lnum) + col;</a>
<a name="ln3365">          totlen = STRLEN(y_array[y_size - 1]);</a>
<a name="ln3366">          newp = (char_u *) xmalloc((size_t)(STRLEN(ptr) + totlen + 1));</a>
<a name="ln3367">          STRCPY(newp, y_array[y_size - 1]);</a>
<a name="ln3368">          STRCAT(newp, ptr);</a>
<a name="ln3369">          // insert second line</a>
<a name="ln3370">          ml_append(lnum, newp, (colnr_T)0, false);</a>
<a name="ln3371">          xfree(newp);</a>
<a name="ln3372"> </a>
<a name="ln3373">          oldp = ml_get(lnum);</a>
<a name="ln3374">          newp = (char_u *)xmalloc((size_t)col + (size_t)yanklen + 1);</a>
<a name="ln3375">          // copy first part of line</a>
<a name="ln3376">          memmove(newp, oldp, (size_t)col);</a>
<a name="ln3377">          // append to first line</a>
<a name="ln3378">          memmove(newp + col, y_array[0], (size_t)yanklen + 1);</a>
<a name="ln3379">          ml_replace(lnum, newp, false);</a>
<a name="ln3380"> </a>
<a name="ln3381">          curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3382">          i = 1;</a>
<a name="ln3383">        }</a>
<a name="ln3384"> </a>
<a name="ln3385">        for (; i &lt; y_size; i++) {</a>
<a name="ln3386">          if ((y_type != kMTCharWise || i &lt; y_size - 1)</a>
<a name="ln3387">              &amp;&amp; ml_append(lnum, y_array[i], (colnr_T)0, false)</a>
<a name="ln3388">              == FAIL) {</a>
<a name="ln3389">            goto error;</a>
<a name="ln3390">          }</a>
<a name="ln3391">          lnum++;</a>
<a name="ln3392">          ++nr_lines;</a>
<a name="ln3393">          if (flags &amp; PUT_FIXINDENT) {</a>
<a name="ln3394">            old_pos = curwin-&gt;w_cursor;</a>
<a name="ln3395">            curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3396">            ptr = ml_get(lnum);</a>
<a name="ln3397">            if (cnt == count &amp;&amp; i == y_size - 1)</a>
<a name="ln3398">              lendiff = (int)STRLEN(ptr);</a>
<a name="ln3399">            if (*ptr == '#' &amp;&amp; preprocs_left())</a>
<a name="ln3400">              indent = 0;                   /* Leave # lines at start */</a>
<a name="ln3401">            else if (*ptr == NUL)</a>
<a name="ln3402">              indent = 0;                   /* Ignore empty lines */</a>
<a name="ln3403">            else if (first_indent) {</a>
<a name="ln3404">              indent_diff = orig_indent - get_indent();</a>
<a name="ln3405">              indent = orig_indent;</a>
<a name="ln3406">              first_indent = FALSE;</a>
<a name="ln3407">            } else if ((indent = get_indent() + indent_diff) &lt; 0)</a>
<a name="ln3408">              indent = 0;</a>
<a name="ln3409">            (void)set_indent(indent, SIN_NOMARK);</a>
<a name="ln3410">            curwin-&gt;w_cursor = old_pos;</a>
<a name="ln3411">            /* remember how many chars were removed */</a>
<a name="ln3412">            if (cnt == count &amp;&amp; i == y_size - 1)</a>
<a name="ln3413">              lendiff -= (int)STRLEN(ml_get(lnum));</a>
<a name="ln3414">          }</a>
<a name="ln3415">        }</a>
<a name="ln3416"> </a>
<a name="ln3417">        bcount_t totsize = 0;</a>
<a name="ln3418">        int lastsize = 0;</a>
<a name="ln3419">        if (y_type == kMTCharWise</a>
<a name="ln3420">            || (y_type == kMTLineWise &amp;&amp; flags &amp; PUT_LINE_SPLIT)) {</a>
<a name="ln3421">          for (i = 0; i &lt; y_size-1; i++) {</a>
<a name="ln3422">            totsize += (bcount_t)STRLEN(y_array[i]) + 1;</a>
<a name="ln3423">          }</a>
<a name="ln3424">          lastsize = (int)STRLEN(y_array[y_size-1]);</a>
<a name="ln3425">          totsize += lastsize;</a>
<a name="ln3426">        }</a>
<a name="ln3427">        if (y_type == kMTCharWise) {</a>
<a name="ln3428">          extmark_splice(curbuf, (int)new_cursor.lnum-1, col, 0, 0, 0,</a>
<a name="ln3429">                         (int)y_size-1, lastsize, totsize,</a>
<a name="ln3430">                         kExtmarkUndo);</a>
<a name="ln3431">        } else if (y_type == kMTLineWise &amp;&amp; flags &amp; PUT_LINE_SPLIT) {</a>
<a name="ln3432">          extmark_splice(curbuf, (int)new_cursor.lnum-1, col, 0, 0, 0,</a>
<a name="ln3433">                         (int)y_size+1, 0, totsize+1, kExtmarkUndo);</a>
<a name="ln3434">        }</a>
<a name="ln3435">      }</a>
<a name="ln3436"> </a>
<a name="ln3437">error:</a>
<a name="ln3438">      // Adjust marks.</a>
<a name="ln3439">      if (y_type == kMTLineWise) {</a>
<a name="ln3440">        curbuf-&gt;b_op_start.col = 0;</a>
<a name="ln3441">        if (dir == FORWARD)</a>
<a name="ln3442">          curbuf-&gt;b_op_start.lnum++;</a>
<a name="ln3443">      }</a>
<a name="ln3444"> </a>
<a name="ln3445">      ExtmarkOp kind = (y_type == kMTLineWise &amp;&amp; !(flags &amp; PUT_LINE_SPLIT))</a>
<a name="ln3446">                       ? kExtmarkUndo : kExtmarkNOOP;</a>
<a name="ln3447">      mark_adjust(curbuf-&gt;b_op_start.lnum + (y_type == kMTCharWise),</a>
<a name="ln3448">                  (linenr_T)MAXLNUM, nr_lines, 0L, kind);</a>
<a name="ln3449"> </a>
<a name="ln3450">      // note changed text for displaying and folding</a>
<a name="ln3451">      if (y_type == kMTCharWise) {</a>
<a name="ln3452">        changed_lines(curwin-&gt;w_cursor.lnum, col,</a>
<a name="ln3453">                      curwin-&gt;w_cursor.lnum + 1, nr_lines, true);</a>
<a name="ln3454">      } else {</a>
<a name="ln3455">        changed_lines(curbuf-&gt;b_op_start.lnum, 0,</a>
<a name="ln3456">                      curbuf-&gt;b_op_start.lnum, nr_lines, true);</a>
<a name="ln3457">      }</a>
<a name="ln3458"> </a>
<a name="ln3459">      /* put '] mark at last inserted character */</a>
<a name="ln3460">      curbuf-&gt;b_op_end.lnum = lnum;</a>
<a name="ln3461">      /* correct length for change in indent */</a>
<a name="ln3462">      col = (colnr_T)STRLEN(y_array[y_size - 1]) - lendiff;</a>
<a name="ln3463">      if (col &gt; 1)</a>
<a name="ln3464">        curbuf-&gt;b_op_end.col = col - 1;</a>
<a name="ln3465">      else</a>
<a name="ln3466">        curbuf-&gt;b_op_end.col = 0;</a>
<a name="ln3467"> </a>
<a name="ln3468">      if (flags &amp; PUT_CURSLINE) {</a>
<a name="ln3469">        /* &quot;:put&quot;: put cursor on last inserted line */</a>
<a name="ln3470">        curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3471">        beginline(BL_WHITE | BL_FIX);</a>
<a name="ln3472">      } else if (flags &amp; PUT_CURSEND) {</a>
<a name="ln3473">        // put cursor after inserted text</a>
<a name="ln3474">        if (y_type == kMTLineWise) {</a>
<a name="ln3475">          if (lnum &gt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3476">            curwin-&gt;w_cursor.lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3477">          } else {</a>
<a name="ln3478">            curwin-&gt;w_cursor.lnum = lnum + 1;</a>
<a name="ln3479">          }</a>
<a name="ln3480">          curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3481">        } else {</a>
<a name="ln3482">          curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3483">          curwin-&gt;w_cursor.col = col;</a>
<a name="ln3484">        }</a>
<a name="ln3485">      } else if (y_type == kMTLineWise) {</a>
<a name="ln3486">        // put cursor on first non-blank in first inserted line</a>
<a name="ln3487">        curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3488">        if (dir == FORWARD)</a>
<a name="ln3489">          ++curwin-&gt;w_cursor.lnum;</a>
<a name="ln3490">        beginline(BL_WHITE | BL_FIX);</a>
<a name="ln3491">      } else            /* put cursor on first inserted character */</a>
<a name="ln3492">        curwin-&gt;w_cursor = new_cursor;</a>
<a name="ln3493">    }</a>
<a name="ln3494">  }</a>
<a name="ln3495"> </a>
<a name="ln3496">  msgmore(nr_lines);</a>
<a name="ln3497">  curwin-&gt;w_set_curswant = TRUE;</a>
<a name="ln3498"> </a>
<a name="ln3499">end:</a>
<a name="ln3500">  if (allocated)</a>
<a name="ln3501">    xfree(insert_string);</a>
<a name="ln3502">  if (regname == '=')</a>
<a name="ln3503">    xfree(y_array);</a>
<a name="ln3504"> </a>
<a name="ln3505">  VIsual_active = FALSE;</a>
<a name="ln3506"> </a>
<a name="ln3507">  /* If the cursor is past the end of the line put it at the end. */</a>
<a name="ln3508">  adjust_cursor_eol();</a>
<a name="ln3509">}  // NOLINT(readability/fn_size)</a>
<a name="ln3510"> </a>
<a name="ln3511">/*</a>
<a name="ln3512"> * When the cursor is on the NUL past the end of the line and it should not be</a>
<a name="ln3513"> * there move it left.</a>
<a name="ln3514"> */</a>
<a name="ln3515">void adjust_cursor_eol(void)</a>
<a name="ln3516">{</a>
<a name="ln3517">  if (curwin-&gt;w_cursor.col &gt; 0</a>
<a name="ln3518">      &amp;&amp; gchar_cursor() == NUL</a>
<a name="ln3519">      &amp;&amp; (ve_flags &amp; VE_ONEMORE) == 0</a>
<a name="ln3520">      &amp;&amp; !(restart_edit || (State &amp; INSERT))) {</a>
<a name="ln3521">    /* Put the cursor on the last character in the line. */</a>
<a name="ln3522">    dec_cursor();</a>
<a name="ln3523"> </a>
<a name="ln3524">    if (ve_flags == VE_ALL) {</a>
<a name="ln3525">      colnr_T scol, ecol;</a>
<a name="ln3526"> </a>
<a name="ln3527">      /* Coladd is set to the width of the last character. */</a>
<a name="ln3528">      getvcol(curwin, &amp;curwin-&gt;w_cursor, &amp;scol, NULL, &amp;ecol);</a>
<a name="ln3529">      curwin-&gt;w_cursor.coladd = ecol - scol + 1;</a>
<a name="ln3530">    }</a>
<a name="ln3531">  }</a>
<a name="ln3532">}</a>
<a name="ln3533"> </a>
<a name="ln3534">/*</a>
<a name="ln3535"> * Return TRUE if lines starting with '#' should be left aligned.</a>
<a name="ln3536"> */</a>
<a name="ln3537">int preprocs_left(void)</a>
<a name="ln3538">{</a>
<a name="ln3539">  return ((curbuf-&gt;b_p_si &amp;&amp; !curbuf-&gt;b_p_cin)</a>
<a name="ln3540">          || (curbuf-&gt;b_p_cin &amp;&amp; in_cinkeys('#', ' ', true)</a>
<a name="ln3541">              &amp;&amp; curbuf-&gt;b_ind_hash_comment == 0));</a>
<a name="ln3542">}</a>
<a name="ln3543"> </a>
<a name="ln3544">/* Return the character name of the register with the given number */</a>
<a name="ln3545">int get_register_name(int num)</a>
<a name="ln3546">{</a>
<a name="ln3547">  if (num == -1)</a>
<a name="ln3548">    return '&quot;';</a>
<a name="ln3549">  else if (num &lt; 10)</a>
<a name="ln3550">    return num + '0';</a>
<a name="ln3551">  else if (num == DELETION_REGISTER)</a>
<a name="ln3552">    return '-';</a>
<a name="ln3553">  else if (num == STAR_REGISTER)</a>
<a name="ln3554">    return '*';</a>
<a name="ln3555">  else if (num == PLUS_REGISTER)</a>
<a name="ln3556">    return '+';</a>
<a name="ln3557">  else {</a>
<a name="ln3558">    return num + 'a' - 10;</a>
<a name="ln3559">  }</a>
<a name="ln3560">}</a>
<a name="ln3561"> </a>
<a name="ln3562">/*</a>
<a name="ln3563"> * &quot;:dis&quot; and &quot;:registers&quot;: Display the contents of the yank registers.</a>
<a name="ln3564"> */</a>
<a name="ln3565">void ex_display(exarg_T *eap)</a>
<a name="ln3566">{</a>
<a name="ln3567">  char_u *p;</a>
<a name="ln3568">  yankreg_T *yb;</a>
<a name="ln3569">  int name;</a>
<a name="ln3570">  char_u *arg = eap-&gt;arg;</a>
<a name="ln3571">  int clen;</a>
<a name="ln3572">  char_u type[2];</a>
<a name="ln3573"> </a>
<a name="ln3574">  if (arg != NULL &amp;&amp; *arg == NUL)</a>
<a name="ln3575">    arg = NULL;</a>
<a name="ln3576">  int attr = HL_ATTR(HLF_8);</a>
<a name="ln3577"> </a>
<a name="ln3578">  // Highlight title</a>
<a name="ln3579">  msg_puts_title(_(&quot;\nType Name Content&quot;));</a>
<a name="ln3580">  for (int i = -1; i &lt; NUM_REGISTERS &amp;&amp; !got_int; i++) {</a>
<a name="ln3581">    name = get_register_name(i);</a>
<a name="ln3582">    switch (get_reg_type(name, NULL)) {</a>
<a name="ln3583">      case kMTLineWise: type[0] = 'l'; break;</a>
<a name="ln3584">      case kMTCharWise: type[0] = 'c'; break;</a>
<a name="ln3585">      default: type[0] = 'b'; break;</a>
<a name="ln3586">    }</a>
<a name="ln3587"> </a>
<a name="ln3588">    if (arg != NULL &amp;&amp; vim_strchr(arg, name) == NULL) {</a>
<a name="ln3589">      continue;             /* did not ask for this register */</a>
<a name="ln3590">    }</a>
<a name="ln3591"> </a>
<a name="ln3592"> </a>
<a name="ln3593">    if (i == -1) {</a>
<a name="ln3594">      if (y_previous != NULL)</a>
<a name="ln3595">        yb = y_previous;</a>
<a name="ln3596">      else</a>
<a name="ln3597">        yb = &amp;(y_regs[0]);</a>
<a name="ln3598">    } else</a>
<a name="ln3599">      yb = &amp;(y_regs[i]);</a>
<a name="ln3600"> </a>
<a name="ln3601">    get_clipboard(name, &amp;yb, true);</a>
<a name="ln3602"> </a>
<a name="ln3603">    if (name == mb_tolower(redir_reg)</a>
<a name="ln3604">        || (redir_reg == '&quot;' &amp;&amp; yb == y_previous)) {</a>
<a name="ln3605">      continue;  // do not list register being written to, the</a>
<a name="ln3606">                 // pointer can be freed</a>
<a name="ln3607">    }</a>
<a name="ln3608"> </a>
<a name="ln3609">    if (yb-&gt;y_array != NULL) {</a>
<a name="ln3610">      msg_putchar('\n');</a>
<a name="ln3611">      msg_puts(&quot;  &quot;);</a>
<a name="ln3612">      msg_putchar(type[0]);</a>
<a name="ln3613">      msg_puts(&quot;  &quot;);</a>
<a name="ln3614">      msg_putchar('&quot;');</a>
<a name="ln3615">      msg_putchar(name);</a>
<a name="ln3616">      MSG_PUTS(&quot;   &quot;);</a>
<a name="ln3617"> </a>
<a name="ln3618">      int n = Columns - 11;</a>
<a name="ln3619">      for (size_t j = 0; j &lt; yb-&gt;y_size &amp;&amp; n &gt; 1; j++) {</a>
<a name="ln3620">        if (j) {</a>
<a name="ln3621">          MSG_PUTS_ATTR(&quot;^J&quot;, attr);</a>
<a name="ln3622">          n -= 2;</a>
<a name="ln3623">        }</a>
<a name="ln3624">        for (p = yb-&gt;y_array[j]; *p &amp;&amp; (n -= ptr2cells(p)) &gt;= 0; p++) {  // -V1019 NOLINT(whitespace/line_length)</a>
<a name="ln3625">          clen = (*mb_ptr2len)(p);</a>
<a name="ln3626">          msg_outtrans_len(p, clen);</a>
<a name="ln3627">          p += clen - 1;</a>
<a name="ln3628">        }</a>
<a name="ln3629">      }</a>
<a name="ln3630">      if (n &gt; 1 &amp;&amp; yb-&gt;y_type == kMTLineWise) {</a>
<a name="ln3631">        MSG_PUTS_ATTR(&quot;^J&quot;, attr);</a>
<a name="ln3632">      }</a>
<a name="ln3633">      ui_flush();  // show one line at a time</a>
<a name="ln3634">    }</a>
<a name="ln3635">    os_breakcheck();</a>
<a name="ln3636">  }</a>
<a name="ln3637"> </a>
<a name="ln3638">  /*</a>
<a name="ln3639">   * display last inserted text</a>
<a name="ln3640">   */</a>
<a name="ln3641">  if ((p = get_last_insert()) != NULL</a>
<a name="ln3642">      &amp;&amp; (arg == NULL || vim_strchr(arg, '.') != NULL) &amp;&amp; !got_int) {</a>
<a name="ln3643">    msg_puts(&quot;\n  c  \&quot;.   &quot;);</a>
<a name="ln3644">    dis_msg(p, true);</a>
<a name="ln3645">  }</a>
<a name="ln3646"> </a>
<a name="ln3647">  /*</a>
<a name="ln3648">   * display last command line</a>
<a name="ln3649">   */</a>
<a name="ln3650">  if (last_cmdline != NULL &amp;&amp; (arg == NULL || vim_strchr(arg, ':') != NULL)</a>
<a name="ln3651">      &amp;&amp; !got_int) {</a>
<a name="ln3652">    msg_puts(&quot;\n  c  \&quot;:   &quot;);</a>
<a name="ln3653">    dis_msg(last_cmdline, false);</a>
<a name="ln3654">  }</a>
<a name="ln3655"> </a>
<a name="ln3656">  /*</a>
<a name="ln3657">   * display current file name</a>
<a name="ln3658">   */</a>
<a name="ln3659">  if (curbuf-&gt;b_fname != NULL</a>
<a name="ln3660">      &amp;&amp; (arg == NULL || vim_strchr(arg, '%') != NULL) &amp;&amp; !got_int) {</a>
<a name="ln3661">    msg_puts(&quot;\n  c  \&quot;%   &quot;);</a>
<a name="ln3662">    dis_msg(curbuf-&gt;b_fname, false);</a>
<a name="ln3663">  }</a>
<a name="ln3664"> </a>
<a name="ln3665">  /*</a>
<a name="ln3666">   * display alternate file name</a>
<a name="ln3667">   */</a>
<a name="ln3668">  if ((arg == NULL || vim_strchr(arg, '%') != NULL) &amp;&amp; !got_int) {</a>
<a name="ln3669">    char_u      *fname;</a>
<a name="ln3670">    linenr_T dummy;</a>
<a name="ln3671"> </a>
<a name="ln3672">    if (buflist_name_nr(0, &amp;fname, &amp;dummy) != FAIL) {</a>
<a name="ln3673">      msg_puts(&quot;\n  c  \&quot;#   &quot;);</a>
<a name="ln3674">      dis_msg(fname, false);</a>
<a name="ln3675">    }</a>
<a name="ln3676">  }</a>
<a name="ln3677"> </a>
<a name="ln3678">  /*</a>
<a name="ln3679">   * display last search pattern</a>
<a name="ln3680">   */</a>
<a name="ln3681">  if (last_search_pat() != NULL</a>
<a name="ln3682">      &amp;&amp; (arg == NULL || vim_strchr(arg, '/') != NULL) &amp;&amp; !got_int) {</a>
<a name="ln3683">    msg_puts(&quot;\n  c  \&quot;/   &quot;);</a>
<a name="ln3684">    dis_msg(last_search_pat(), false);</a>
<a name="ln3685">  }</a>
<a name="ln3686"> </a>
<a name="ln3687">  /*</a>
<a name="ln3688">   * display last used expression</a>
<a name="ln3689">   */</a>
<a name="ln3690">  if (expr_line != NULL &amp;&amp; (arg == NULL || vim_strchr(arg, '=') != NULL)</a>
<a name="ln3691">      &amp;&amp; !got_int) {</a>
<a name="ln3692">    msg_puts(&quot;\n  c  \&quot;=   &quot;);</a>
<a name="ln3693">    dis_msg(expr_line, false);</a>
<a name="ln3694">  }</a>
<a name="ln3695">}</a>
<a name="ln3696"> </a>
<a name="ln3697">/*</a>
<a name="ln3698"> * display a string for do_dis()</a>
<a name="ln3699"> * truncate at end of screen line</a>
<a name="ln3700"> */</a>
<a name="ln3701">static void</a>
<a name="ln3702">dis_msg(</a>
<a name="ln3703">    const char_u *p,</a>
<a name="ln3704">    bool skip_esc     // if true, ignore trailing ESC</a>
<a name="ln3705">)</a>
<a name="ln3706">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3707">{</a>
<a name="ln3708">  int n;</a>
<a name="ln3709">  int l;</a>
<a name="ln3710"> </a>
<a name="ln3711">  n = Columns - 6;</a>
<a name="ln3712">  while (*p != NUL</a>
<a name="ln3713">         &amp;&amp; !(*p == ESC &amp;&amp; skip_esc &amp;&amp; *(p + 1) == NUL)</a>
<a name="ln3714">         &amp;&amp; (n -= ptr2cells(p)) &gt;= 0) {</a>
<a name="ln3715">    if ((l = utfc_ptr2len(p)) &gt; 1) {</a>
<a name="ln3716">      msg_outtrans_len(p, l);</a>
<a name="ln3717">      p += l;</a>
<a name="ln3718">    } else</a>
<a name="ln3719">      msg_outtrans_len(p++, 1);</a>
<a name="ln3720">  }</a>
<a name="ln3721">  os_breakcheck();</a>
<a name="ln3722">}</a>
<a name="ln3723"> </a>
<a name="ln3724">/// If \p &quot;process&quot; is true and the line begins with a comment leader (possibly</a>
<a name="ln3725">/// after some white space), return a pointer to the text after it.</a>
<a name="ln3726">/// Put a boolean value indicating whether the line ends with an unclosed</a>
<a name="ln3727">/// comment in &quot;is_comment&quot;.</a>
<a name="ln3728">///</a>
<a name="ln3729">/// @param line - line to be processed</a>
<a name="ln3730">/// @param process - if false, will only check whether the line ends</a>
<a name="ln3731">///         with an unclosed comment,</a>
<a name="ln3732">/// @param include_space - whether to skip space following the comment leader</a>
<a name="ln3733">/// @param[out] is_comment - whether the current line ends with an unclosed</a>
<a name="ln3734">///  comment.</a>
<a name="ln3735">char_u *skip_comment(</a>
<a name="ln3736">    char_u *line, bool process, bool include_space, bool *is_comment</a>
<a name="ln3737">)</a>
<a name="ln3738">{</a>
<a name="ln3739">  char_u *comment_flags = NULL;</a>
<a name="ln3740">  int lead_len;</a>
<a name="ln3741">  int leader_offset = get_last_leader_offset(line, &amp;comment_flags);</a>
<a name="ln3742"> </a>
<a name="ln3743">  *is_comment = false;</a>
<a name="ln3744">  if (leader_offset != -1) {</a>
<a name="ln3745">    /* Let's check whether the line ends with an unclosed comment.</a>
<a name="ln3746">     * If the last comment leader has COM_END in flags, there's no comment.</a>
<a name="ln3747">     */</a>
<a name="ln3748">    while (*comment_flags) {</a>
<a name="ln3749">      if (*comment_flags == COM_END</a>
<a name="ln3750">          || *comment_flags == ':') {</a>
<a name="ln3751">        break;</a>
<a name="ln3752">      }</a>
<a name="ln3753">      comment_flags++;</a>
<a name="ln3754">    }</a>
<a name="ln3755">    if (*comment_flags != COM_END) {</a>
<a name="ln3756">      *is_comment = true;</a>
<a name="ln3757">    }</a>
<a name="ln3758">  }</a>
<a name="ln3759"> </a>
<a name="ln3760">  if (process == false) {</a>
<a name="ln3761">    return line;</a>
<a name="ln3762">  }</a>
<a name="ln3763"> </a>
<a name="ln3764">  lead_len = get_leader_len(line, &amp;comment_flags, false, include_space);</a>
<a name="ln3765"> </a>
<a name="ln3766">  if (lead_len == 0)</a>
<a name="ln3767">    return line;</a>
<a name="ln3768"> </a>
<a name="ln3769">  /* Find:</a>
<a name="ln3770">   * - COM_END,</a>
<a name="ln3771">   * - colon,</a>
<a name="ln3772">   * whichever comes first.</a>
<a name="ln3773">   */</a>
<a name="ln3774">  while (*comment_flags) {</a>
<a name="ln3775">    if (*comment_flags == COM_END</a>
<a name="ln3776">        || *comment_flags == ':') {</a>
<a name="ln3777">      break;</a>
<a name="ln3778">    }</a>
<a name="ln3779">    ++comment_flags;</a>
<a name="ln3780">  }</a>
<a name="ln3781"> </a>
<a name="ln3782">  /* If we found a colon, it means that we are not processing a line</a>
<a name="ln3783">   * starting with a closing part of a three-part comment. That's good,</a>
<a name="ln3784">   * because we don't want to remove those as this would be annoying.</a>
<a name="ln3785">   */</a>
<a name="ln3786">  if (*comment_flags == ':' || *comment_flags == NUL) {</a>
<a name="ln3787">    line += lead_len;</a>
<a name="ln3788">  }</a>
<a name="ln3789"> </a>
<a name="ln3790">  return line;</a>
<a name="ln3791">}</a>
<a name="ln3792"> </a>
<a name="ln3793">// Join 'count' lines (minimal 2) at cursor position.</a>
<a name="ln3794">// When &quot;save_undo&quot; is TRUE save lines for undo first.</a>
<a name="ln3795">// Set &quot;use_formatoptions&quot; to FALSE when e.g. processing backspace and comment</a>
<a name="ln3796">// leaders should not be removed.</a>
<a name="ln3797">// When setmark is true, sets the '[ and '] mark, else, the caller is expected</a>
<a name="ln3798">// to set those marks.</a>
<a name="ln3799">//</a>
<a name="ln3800">// return FAIL for failure, OK otherwise</a>
<a name="ln3801">int do_join(size_t count,</a>
<a name="ln3802">            int insert_space,</a>
<a name="ln3803">            int save_undo,</a>
<a name="ln3804">            int use_formatoptions,</a>
<a name="ln3805">            bool setmark)</a>
<a name="ln3806">{</a>
<a name="ln3807">  char_u      *curr = NULL;</a>
<a name="ln3808">  char_u      *curr_start = NULL;</a>
<a name="ln3809">  char_u      *cend;</a>
<a name="ln3810">  char_u      *newp;</a>
<a name="ln3811">  char_u      *spaces;          /* number of spaces inserted before a line */</a>
<a name="ln3812">  int endcurr1 = NUL;</a>
<a name="ln3813">  int endcurr2 = NUL;</a>
<a name="ln3814">  int currsize = 0;             /* size of the current line */</a>
<a name="ln3815">  int sumsize = 0;              /* size of the long new line */</a>
<a name="ln3816">  linenr_T t;</a>
<a name="ln3817">  colnr_T col = 0;</a>
<a name="ln3818">  int ret = OK;</a>
<a name="ln3819">  int         *comments = NULL;</a>
<a name="ln3820">  int remove_comments = (use_formatoptions == TRUE)</a>
<a name="ln3821">                        &amp;&amp; has_format_option(FO_REMOVE_COMS);</a>
<a name="ln3822">  bool prev_was_comment = false;</a>
<a name="ln3823">  assert(count &gt;= 1);</a>
<a name="ln3824"> </a>
<a name="ln3825">  if (save_undo &amp;&amp; u_save(curwin-&gt;w_cursor.lnum - 1,</a>
<a name="ln3826">                          curwin-&gt;w_cursor.lnum + (linenr_T)count) == FAIL) {</a>
<a name="ln3827">    return FAIL;</a>
<a name="ln3828">  }</a>
<a name="ln3829">  // Allocate an array to store the number of spaces inserted before each</a>
<a name="ln3830">  // line.  We will use it to pre-compute the length of the new line and the</a>
<a name="ln3831">  // proper placement of each original line in the new one.</a>
<a name="ln3832">  spaces = xcalloc(count, 1);</a>
<a name="ln3833">  if (remove_comments) {</a>
<a name="ln3834">    comments = xcalloc(count, sizeof(*comments));</a>
<a name="ln3835">  }</a>
<a name="ln3836"> </a>
<a name="ln3837">  // Don't move anything, just compute the final line length</a>
<a name="ln3838">  // and setup the array of space strings lengths</a>
<a name="ln3839">  for (t = 0; t &lt; (linenr_T)count; t++) {</a>
<a name="ln3840">    curr = curr_start = ml_get((linenr_T)(curwin-&gt;w_cursor.lnum + t));</a>
<a name="ln3841">    if (t == 0 &amp;&amp; setmark) {</a>
<a name="ln3842">      // Set the '[ mark.</a>
<a name="ln3843">      curwin-&gt;w_buffer-&gt;b_op_start.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3844">      curwin-&gt;w_buffer-&gt;b_op_start.col = (colnr_T)STRLEN(curr);</a>
<a name="ln3845">    }</a>
<a name="ln3846">    if (remove_comments) {</a>
<a name="ln3847">      // We don't want to remove the comment leader if the</a>
<a name="ln3848">      // previous line is not a comment.</a>
<a name="ln3849">      if (t &gt; 0 &amp;&amp; prev_was_comment) {</a>
<a name="ln3850">        char_u *new_curr = skip_comment(curr, true, insert_space,</a>
<a name="ln3851">                                        &amp;prev_was_comment);</a>
<a name="ln3852">        comments[t] = (int)(new_curr - curr);</a>
<a name="ln3853">        curr = new_curr;</a>
<a name="ln3854">      } else {</a>
<a name="ln3855">        curr = skip_comment(curr, false, insert_space, &amp;prev_was_comment);</a>
<a name="ln3856">      }</a>
<a name="ln3857">    }</a>
<a name="ln3858"> </a>
<a name="ln3859">    if (insert_space &amp;&amp; t &gt; 0) {</a>
<a name="ln3860">      curr = skipwhite(curr);</a>
<a name="ln3861">      if (*curr != NUL</a>
<a name="ln3862">          &amp;&amp; *curr != ')'</a>
<a name="ln3863">          &amp;&amp; sumsize != 0</a>
<a name="ln3864">          &amp;&amp; endcurr1 != TAB</a>
<a name="ln3865">          &amp;&amp; (!has_format_option(FO_MBYTE_JOIN)</a>
<a name="ln3866">              || (utf_ptr2char(curr) &lt; 0x100 &amp;&amp; endcurr1 &lt; 0x100))</a>
<a name="ln3867">          &amp;&amp; (!has_format_option(FO_MBYTE_JOIN2)</a>
<a name="ln3868">              || (utf_ptr2char(curr) &lt; 0x100 &amp;&amp; !utf_eat_space(endcurr1))</a>
<a name="ln3869">              || (endcurr1 &lt; 0x100 &amp;&amp; !utf_eat_space(utf_ptr2char(curr))))</a>
<a name="ln3870">          ) {</a>
<a name="ln3871">        /* don't add a space if the line is ending in a space */</a>
<a name="ln3872">        if (endcurr1 == ' ')</a>
<a name="ln3873">          endcurr1 = endcurr2;</a>
<a name="ln3874">        else</a>
<a name="ln3875">          ++spaces[t];</a>
<a name="ln3876">        // Extra space when 'joinspaces' set and line ends in '.', '?', or '!'.</a>
<a name="ln3877">        if (p_js &amp;&amp; (endcurr1 == '.' || endcurr1 == '?' || endcurr1 == '!')) {</a>
<a name="ln3878">          ++spaces[t];</a>
<a name="ln3879">        }</a>
<a name="ln3880">      }</a>
<a name="ln3881">    }</a>
<a name="ln3882"> </a>
<a name="ln3883">    if (t &gt; 0 &amp;&amp; curbuf_splice_pending == 0) {</a>
<a name="ln3884">      colnr_T removed = (int)(curr- curr_start);</a>
<a name="ln3885">      extmark_splice(curbuf, (int)curwin-&gt;w_cursor.lnum-1, sumsize,</a>
<a name="ln3886">                     1, removed, removed + 1,</a>
<a name="ln3887">                     0, spaces[t], spaces[t],</a>
<a name="ln3888">                     kExtmarkUndo);</a>
<a name="ln3889">    }</a>
<a name="ln3890">    currsize = (int)STRLEN(curr);</a>
<a name="ln3891">    sumsize += currsize + spaces[t];</a>
<a name="ln3892">    endcurr1 = endcurr2 = NUL;</a>
<a name="ln3893">    if (insert_space &amp;&amp; currsize &gt; 0) {</a>
<a name="ln3894">      cend = curr + currsize;</a>
<a name="ln3895">      MB_PTR_BACK(curr, cend);</a>
<a name="ln3896">      endcurr1 = utf_ptr2char(cend);</a>
<a name="ln3897">      if (cend &gt; curr) {</a>
<a name="ln3898">        MB_PTR_BACK(curr, cend);</a>
<a name="ln3899">        endcurr2 = utf_ptr2char(cend);</a>
<a name="ln3900">      }</a>
<a name="ln3901">    }</a>
<a name="ln3902">    line_breakcheck();</a>
<a name="ln3903">    if (got_int) {</a>
<a name="ln3904">      ret = FAIL;</a>
<a name="ln3905">      goto theend;</a>
<a name="ln3906">    }</a>
<a name="ln3907">  }</a>
<a name="ln3908"> </a>
<a name="ln3909">  // store the column position before last line</a>
<a name="ln3910">  col = sumsize - currsize - spaces[count - 1];</a>
<a name="ln3911"> </a>
<a name="ln3912">  // allocate the space for the new line</a>
<a name="ln3913">  newp = (char_u *)xmalloc((size_t)sumsize + 1);</a>
<a name="ln3914">  cend = newp + sumsize;</a>
<a name="ln3915">  *cend = 0;</a>
<a name="ln3916"> </a>
<a name="ln3917">  /*</a>
<a name="ln3918">   * Move affected lines to the new long one.</a>
<a name="ln3919">   *</a>
<a name="ln3920">   * Move marks from each deleted line to the joined line, adjusting the</a>
<a name="ln3921">   * column.  This is not Vi compatible, but Vi deletes the marks, thus that</a>
<a name="ln3922">   * should not really be a problem.</a>
<a name="ln3923">   */</a>
<a name="ln3924"> </a>
<a name="ln3925">  curbuf_splice_pending++;</a>
<a name="ln3926"> </a>
<a name="ln3927">  for (t = (linenr_T)count - 1;; t--) {</a>
<a name="ln3928">    cend -= currsize;</a>
<a name="ln3929">    memmove(cend, curr, (size_t)currsize);</a>
<a name="ln3930">    if (spaces[t] &gt; 0) {</a>
<a name="ln3931">      cend -= spaces[t];</a>
<a name="ln3932">      memset(cend, ' ', (size_t)(spaces[t]));</a>
<a name="ln3933">    }</a>
<a name="ln3934"> </a>
<a name="ln3935">    // If deleting more spaces than adding, the cursor moves no more than</a>
<a name="ln3936">    // what is added if it is inside these spaces.</a>
<a name="ln3937">    const int spaces_removed = (int)((curr - curr_start) - spaces[t]);</a>
<a name="ln3938">    linenr_T lnum = curwin-&gt;w_cursor.lnum + t;</a>
<a name="ln3939">    colnr_T mincol = (colnr_T)0;</a>
<a name="ln3940">    long lnum_amount = (linenr_T)-t;</a>
<a name="ln3941">    long col_amount = (long)(cend - newp - spaces_removed);</a>
<a name="ln3942"> </a>
<a name="ln3943">    mark_col_adjust(lnum, mincol, lnum_amount, col_amount, spaces_removed);</a>
<a name="ln3944"> </a>
<a name="ln3945">    if (t == 0) {</a>
<a name="ln3946">      break;</a>
<a name="ln3947">    }</a>
<a name="ln3948"> </a>
<a name="ln3949">    curr = curr_start = ml_get((linenr_T)(curwin-&gt;w_cursor.lnum + t - 1));</a>
<a name="ln3950">    if (remove_comments)</a>
<a name="ln3951">      curr += comments[t - 1];</a>
<a name="ln3952">    if (insert_space &amp;&amp; t &gt; 1)</a>
<a name="ln3953">      curr = skipwhite(curr);</a>
<a name="ln3954">    currsize = (int)STRLEN(curr);</a>
<a name="ln3955">  }</a>
<a name="ln3956"> </a>
<a name="ln3957">  ml_replace(curwin-&gt;w_cursor.lnum, newp, false);</a>
<a name="ln3958"> </a>
<a name="ln3959">  if (setmark) {</a>
<a name="ln3960">    // Set the '] mark.</a>
<a name="ln3961">    curwin-&gt;w_buffer-&gt;b_op_end.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3962">    curwin-&gt;w_buffer-&gt;b_op_end.col = sumsize;</a>
<a name="ln3963">  }</a>
<a name="ln3964"> </a>
<a name="ln3965">  /* Only report the change in the first line here, del_lines() will report</a>
<a name="ln3966">   * the deleted line. */</a>
<a name="ln3967">  changed_lines(curwin-&gt;w_cursor.lnum, currsize,</a>
<a name="ln3968">                curwin-&gt;w_cursor.lnum + 1, 0L, true);</a>
<a name="ln3969"> </a>
<a name="ln3970">  /*</a>
<a name="ln3971">   * Delete following lines. To do this we move the cursor there</a>
<a name="ln3972">   * briefly, and then move it back. After del_lines() the cursor may</a>
<a name="ln3973">   * have moved up (last line deleted), so the current lnum is kept in t.</a>
<a name="ln3974">   */</a>
<a name="ln3975">  t = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3976">  curwin-&gt;w_cursor.lnum++;</a>
<a name="ln3977">  del_lines((long)count - 1, false);</a>
<a name="ln3978">  curwin-&gt;w_cursor.lnum = t;</a>
<a name="ln3979">  curbuf_splice_pending--;</a>
<a name="ln3980"> </a>
<a name="ln3981">  /*</a>
<a name="ln3982">   * Set the cursor column:</a>
<a name="ln3983">   * Vi compatible: use the column of the first join</a>
<a name="ln3984">   * vim:	      use the column of the last join</a>
<a name="ln3985">   */</a>
<a name="ln3986">  curwin-&gt;w_cursor.col =</a>
<a name="ln3987">    (vim_strchr(p_cpo, CPO_JOINCOL) != NULL ? currsize : col);</a>
<a name="ln3988">  check_cursor_col();</a>
<a name="ln3989"> </a>
<a name="ln3990">  curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln3991">  curwin-&gt;w_set_curswant = TRUE;</a>
<a name="ln3992"> </a>
<a name="ln3993">theend:</a>
<a name="ln3994">  xfree(spaces);</a>
<a name="ln3995">  if (remove_comments)</a>
<a name="ln3996">    xfree(comments);</a>
<a name="ln3997">  return ret;</a>
<a name="ln3998">}</a>
<a name="ln3999"> </a>
<a name="ln4000">/*</a>
<a name="ln4001"> * Return TRUE if the two comment leaders given are the same.  &quot;lnum&quot; is</a>
<a name="ln4002"> * the first line.  White-space is ignored.  Note that the whole of</a>
<a name="ln4003"> * 'leader1' must match 'leader2_len' characters from 'leader2' -- webb</a>
<a name="ln4004"> */</a>
<a name="ln4005">static int same_leader(linenr_T lnum, int leader1_len, char_u *leader1_flags, int leader2_len, char_u *leader2_flags)</a>
<a name="ln4006">{</a>
<a name="ln4007">  int idx1 = 0, idx2 = 0;</a>
<a name="ln4008">  char_u  *p;</a>
<a name="ln4009">  char_u  *line1;</a>
<a name="ln4010">  char_u  *line2;</a>
<a name="ln4011"> </a>
<a name="ln4012">  if (leader1_len == 0)</a>
<a name="ln4013">    return leader2_len == 0;</a>
<a name="ln4014"> </a>
<a name="ln4015">  /*</a>
<a name="ln4016">   * If first leader has 'f' flag, the lines can be joined only if the</a>
<a name="ln4017">   * second line does not have a leader.</a>
<a name="ln4018">   * If first leader has 'e' flag, the lines can never be joined.</a>
<a name="ln4019">   * If fist leader has 's' flag, the lines can only be joined if there is</a>
<a name="ln4020">   * some text after it and the second line has the 'm' flag.</a>
<a name="ln4021">   */</a>
<a name="ln4022">  if (leader1_flags != NULL) {</a>
<a name="ln4023">    for (p = leader1_flags; *p &amp;&amp; *p != ':'; ++p) {</a>
<a name="ln4024">      if (*p == COM_FIRST)</a>
<a name="ln4025">        return leader2_len == 0;</a>
<a name="ln4026">      if (*p == COM_END)</a>
<a name="ln4027">        return FALSE;</a>
<a name="ln4028">      if (*p == COM_START) {</a>
<a name="ln4029">        if (*(ml_get(lnum) + leader1_len) == NUL)</a>
<a name="ln4030">          return FALSE;</a>
<a name="ln4031">        if (leader2_flags == NULL || leader2_len == 0)</a>
<a name="ln4032">          return FALSE;</a>
<a name="ln4033">        for (p = leader2_flags; *p &amp;&amp; *p != ':'; ++p)</a>
<a name="ln4034">          if (*p == COM_MIDDLE)</a>
<a name="ln4035">            return TRUE;</a>
<a name="ln4036">        return FALSE;</a>
<a name="ln4037">      }</a>
<a name="ln4038">    }</a>
<a name="ln4039">  }</a>
<a name="ln4040"> </a>
<a name="ln4041">  /*</a>
<a name="ln4042">   * Get current line and next line, compare the leaders.</a>
<a name="ln4043">   * The first line has to be saved, only one line can be locked at a time.</a>
<a name="ln4044">   */</a>
<a name="ln4045">  line1 = vim_strsave(ml_get(lnum));</a>
<a name="ln4046">  for (idx1 = 0; ascii_iswhite(line1[idx1]); ++idx1)</a>
<a name="ln4047">    ;</a>
<a name="ln4048">  line2 = ml_get(lnum + 1);</a>
<a name="ln4049">  for (idx2 = 0; idx2 &lt; leader2_len; ++idx2) {</a>
<a name="ln4050">    if (!ascii_iswhite(line2[idx2])) {</a>
<a name="ln4051">      if (line1[idx1++] != line2[idx2])</a>
<a name="ln4052">        break;</a>
<a name="ln4053">    } else</a>
<a name="ln4054">      while (ascii_iswhite(line1[idx1]))</a>
<a name="ln4055">        ++idx1;</a>
<a name="ln4056">  }</a>
<a name="ln4057">  xfree(line1);</a>
<a name="ln4058"> </a>
<a name="ln4059">  return idx2 == leader2_len &amp;&amp; idx1 == leader1_len;</a>
<a name="ln4060">}</a>
<a name="ln4061"> </a>
<a name="ln4062">/*</a>
<a name="ln4063"> * Implementation of the format operator 'gq'.</a>
<a name="ln4064"> */</a>
<a name="ln4065">void</a>
<a name="ln4066">op_format(</a>
<a name="ln4067">    oparg_T *oap,</a>
<a name="ln4068">    int keep_cursor                        /* keep cursor on same text char */</a>
<a name="ln4069">)</a>
<a name="ln4070">{</a>
<a name="ln4071">  long old_line_count = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln4072"> </a>
<a name="ln4073">  /* Place the cursor where the &quot;gq&quot; or &quot;gw&quot; command was given, so that &quot;u&quot;</a>
<a name="ln4074">   * can put it back there. */</a>
<a name="ln4075">  curwin-&gt;w_cursor = oap-&gt;cursor_start;</a>
<a name="ln4076"> </a>
<a name="ln4077">  if (u_save((linenr_T)(oap-&gt;start.lnum - 1),</a>
<a name="ln4078">          (linenr_T)(oap-&gt;end.lnum + 1)) == FAIL)</a>
<a name="ln4079">    return;</a>
<a name="ln4080">  curwin-&gt;w_cursor = oap-&gt;start;</a>
<a name="ln4081"> </a>
<a name="ln4082">  if (oap-&gt;is_VIsual)</a>
<a name="ln4083">    /* When there is no change: need to remove the Visual selection */</a>
<a name="ln4084">    redraw_curbuf_later(INVERTED);</a>
<a name="ln4085"> </a>
<a name="ln4086">  /* Set '[ mark at the start of the formatted area */</a>
<a name="ln4087">  curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln4088"> </a>
<a name="ln4089">  /* For &quot;gw&quot; remember the cursor position and put it back below (adjusted</a>
<a name="ln4090">   * for joined and split lines). */</a>
<a name="ln4091">  if (keep_cursor)</a>
<a name="ln4092">    saved_cursor = oap-&gt;cursor_start;</a>
<a name="ln4093"> </a>
<a name="ln4094">  format_lines(oap-&gt;line_count, keep_cursor);</a>
<a name="ln4095"> </a>
<a name="ln4096">  /*</a>
<a name="ln4097">   * Leave the cursor at the first non-blank of the last formatted line.</a>
<a name="ln4098">   * If the cursor was moved one line back (e.g. with &quot;Q}&quot;) go to the next</a>
<a name="ln4099">   * line, so &quot;.&quot; will do the next lines.</a>
<a name="ln4100">   */</a>
<a name="ln4101">  if (oap-&gt;end_adjusted &amp;&amp; curwin-&gt;w_cursor.lnum &lt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln4102">    ++curwin-&gt;w_cursor.lnum;</a>
<a name="ln4103">  beginline(BL_WHITE | BL_FIX);</a>
<a name="ln4104">  old_line_count = curbuf-&gt;b_ml.ml_line_count - old_line_count;</a>
<a name="ln4105">  msgmore(old_line_count);</a>
<a name="ln4106"> </a>
<a name="ln4107">  /* put '] mark on the end of the formatted area */</a>
<a name="ln4108">  curbuf-&gt;b_op_end = curwin-&gt;w_cursor;</a>
<a name="ln4109"> </a>
<a name="ln4110">  if (keep_cursor) {</a>
<a name="ln4111">    curwin-&gt;w_cursor = saved_cursor;</a>
<a name="ln4112">    saved_cursor.lnum = 0;</a>
<a name="ln4113">  }</a>
<a name="ln4114"> </a>
<a name="ln4115">  if (oap-&gt;is_VIsual) {</a>
<a name="ln4116">    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln4117">      if (wp-&gt;w_old_cursor_lnum != 0) {</a>
<a name="ln4118">        /* When lines have been inserted or deleted, adjust the end of</a>
<a name="ln4119">         * the Visual area to be redrawn. */</a>
<a name="ln4120">        if (wp-&gt;w_old_cursor_lnum &gt; wp-&gt;w_old_visual_lnum) {</a>
<a name="ln4121">          wp-&gt;w_old_cursor_lnum += old_line_count;</a>
<a name="ln4122">        } else {</a>
<a name="ln4123">          wp-&gt;w_old_visual_lnum += old_line_count;</a>
<a name="ln4124">        }</a>
<a name="ln4125">      }</a>
<a name="ln4126">    }</a>
<a name="ln4127">  }</a>
<a name="ln4128">}</a>
<a name="ln4129"> </a>
<a name="ln4130">/*</a>
<a name="ln4131"> * Implementation of the format operator 'gq' for when using 'formatexpr'.</a>
<a name="ln4132"> */</a>
<a name="ln4133">void op_formatexpr(oparg_T *oap)</a>
<a name="ln4134">{</a>
<a name="ln4135">  if (oap-&gt;is_VIsual)</a>
<a name="ln4136">    /* When there is no change: need to remove the Visual selection */</a>
<a name="ln4137">    redraw_curbuf_later(INVERTED);</a>
<a name="ln4138"> </a>
<a name="ln4139">  if (fex_format(oap-&gt;start.lnum, oap-&gt;line_count, NUL) != 0)</a>
<a name="ln4140">    /* As documented: when 'formatexpr' returns non-zero fall back to</a>
<a name="ln4141">     * internal formatting. */</a>
<a name="ln4142">    op_format(oap, FALSE);</a>
<a name="ln4143">}</a>
<a name="ln4144"> </a>
<a name="ln4145">int</a>
<a name="ln4146">fex_format(</a>
<a name="ln4147">    linenr_T lnum,</a>
<a name="ln4148">    long count,</a>
<a name="ln4149">    int c                  /* character to be inserted */</a>
<a name="ln4150">)</a>
<a name="ln4151">{</a>
<a name="ln4152">  int use_sandbox = was_set_insecurely(</a>
<a name="ln4153">      curwin, (char_u *)&quot;formatexpr&quot;, OPT_LOCAL);</a>
<a name="ln4154">  int r;</a>
<a name="ln4155">  char_u *fex;</a>
<a name="ln4156"> </a>
<a name="ln4157">  /*</a>
<a name="ln4158">   * Set v:lnum to the first line number and v:count to the number of lines.</a>
<a name="ln4159">   * Set v:char to the character to be inserted (can be NUL).</a>
<a name="ln4160">   */</a>
<a name="ln4161">  set_vim_var_nr(VV_LNUM, (varnumber_T)lnum);</a>
<a name="ln4162">  set_vim_var_nr(VV_COUNT, (varnumber_T)count);</a>
<a name="ln4163">  set_vim_var_char(c);</a>
<a name="ln4164"> </a>
<a name="ln4165">  // Make a copy, the option could be changed while calling it.</a>
<a name="ln4166">  fex = vim_strsave(curbuf-&gt;b_p_fex);</a>
<a name="ln4167">  // Evaluate the function.</a>
<a name="ln4168">  if (use_sandbox) {</a>
<a name="ln4169">    sandbox++;</a>
<a name="ln4170">  }</a>
<a name="ln4171">  r = (int)eval_to_number(fex);</a>
<a name="ln4172">  if (use_sandbox) {</a>
<a name="ln4173">    sandbox--;</a>
<a name="ln4174">  }</a>
<a name="ln4175"> </a>
<a name="ln4176">  set_vim_var_string(VV_CHAR, NULL, -1);</a>
<a name="ln4177">  xfree(fex);</a>
<a name="ln4178"> </a>
<a name="ln4179">  return r;</a>
<a name="ln4180">}</a>
<a name="ln4181"> </a>
<a name="ln4182">/*</a>
<a name="ln4183"> * Format &quot;line_count&quot; lines, starting at the cursor position.</a>
<a name="ln4184"> * When &quot;line_count&quot; is negative, format until the end of the paragraph.</a>
<a name="ln4185"> * Lines after the cursor line are saved for undo, caller must have saved the</a>
<a name="ln4186"> * first line.</a>
<a name="ln4187"> */</a>
<a name="ln4188">void</a>
<a name="ln4189">format_lines(</a>
<a name="ln4190">    linenr_T line_count,</a>
<a name="ln4191">    int avoid_fex                          /* don't use 'formatexpr' */</a>
<a name="ln4192">)</a>
<a name="ln4193">{</a>
<a name="ln4194">  bool is_not_par;                  // current line not part of parag.</a>
<a name="ln4195">  bool next_is_not_par;             // next line not part of paragraph</a>
<a name="ln4196">  bool is_end_par;                  // at end of paragraph</a>
<a name="ln4197">  bool prev_is_end_par = false;     // prev. line not part of parag.</a>
<a name="ln4198">  bool next_is_start_par = false;</a>
<a name="ln4199">  int leader_len = 0;               // leader len of current line</a>
<a name="ln4200">  int next_leader_len;              // leader len of next line</a>
<a name="ln4201">  char_u *leader_flags = NULL;      // flags for leader of current line</a>
<a name="ln4202">  char_u *next_leader_flags;        // flags for leader of next line</a>
<a name="ln4203">  bool advance = true;</a>
<a name="ln4204">  int second_indent = -1;           // indent for second line (comment aware)</a>
<a name="ln4205">  bool first_par_line = true;</a>
<a name="ln4206">  int smd_save;</a>
<a name="ln4207">  long count;</a>
<a name="ln4208">  bool need_set_indent = true;      // set indent of next paragraph</a>
<a name="ln4209">  bool force_format = false;</a>
<a name="ln4210">  const int old_State = State;</a>
<a name="ln4211"> </a>
<a name="ln4212">  // length of a line to force formatting: 3 * 'tw'</a>
<a name="ln4213">  const int max_len = comp_textwidth(true) * 3;</a>
<a name="ln4214"> </a>
<a name="ln4215">  // check for 'q', '2' and '1' in 'formatoptions'</a>
<a name="ln4216">  const bool do_comments = has_format_option(FO_Q_COMS);  // format comments</a>
<a name="ln4217">  int do_comments_list = 0;  // format comments with 'n' or '2'</a>
<a name="ln4218">  const bool do_second_indent = has_format_option(FO_Q_SECOND);</a>
<a name="ln4219">  const bool do_number_indent = has_format_option(FO_Q_NUMBER);</a>
<a name="ln4220">  const bool do_trail_white = has_format_option(FO_WHITE_PAR);</a>
<a name="ln4221"> </a>
<a name="ln4222">  // Get info about the previous and current line.</a>
<a name="ln4223">  if (curwin-&gt;w_cursor.lnum &gt; 1) {</a>
<a name="ln4224">    is_not_par = fmt_check_par(curwin-&gt;w_cursor.lnum - 1,</a>
<a name="ln4225">                               &amp;leader_len, &amp;leader_flags, do_comments);</a>
<a name="ln4226">  } else {</a>
<a name="ln4227">    is_not_par = true;</a>
<a name="ln4228">  }</a>
<a name="ln4229">  next_is_not_par = fmt_check_par(curwin-&gt;w_cursor.lnum</a>
<a name="ln4230">      , &amp;next_leader_len, &amp;next_leader_flags, do_comments</a>
<a name="ln4231">      );</a>
<a name="ln4232">  is_end_par = (is_not_par || next_is_not_par);</a>
<a name="ln4233">  if (!is_end_par &amp;&amp; do_trail_white)</a>
<a name="ln4234">    is_end_par = !ends_in_white(curwin-&gt;w_cursor.lnum - 1);</a>
<a name="ln4235"> </a>
<a name="ln4236">  curwin-&gt;w_cursor.lnum--;</a>
<a name="ln4237">  for (count = line_count; count != 0 &amp;&amp; !got_int; --count) {</a>
<a name="ln4238">    /*</a>
<a name="ln4239">     * Advance to next paragraph.</a>
<a name="ln4240">     */</a>
<a name="ln4241">    if (advance) {</a>
<a name="ln4242">      curwin-&gt;w_cursor.lnum++;</a>
<a name="ln4243">      prev_is_end_par = is_end_par;</a>
<a name="ln4244">      is_not_par = next_is_not_par;</a>
<a name="ln4245">      leader_len = next_leader_len;</a>
<a name="ln4246">      leader_flags = next_leader_flags;</a>
<a name="ln4247">    }</a>
<a name="ln4248"> </a>
<a name="ln4249">    /*</a>
<a name="ln4250">     * The last line to be formatted.</a>
<a name="ln4251">     */</a>
<a name="ln4252">    if (count == 1 || curwin-&gt;w_cursor.lnum == curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln4253">      next_is_not_par = true;</a>
<a name="ln4254">      next_leader_len = 0;</a>
<a name="ln4255">      next_leader_flags = NULL;</a>
<a name="ln4256">    } else {</a>
<a name="ln4257">      next_is_not_par = fmt_check_par(curwin-&gt;w_cursor.lnum + 1</a>
<a name="ln4258">          , &amp;next_leader_len, &amp;next_leader_flags, do_comments</a>
<a name="ln4259">          );</a>
<a name="ln4260">      if (do_number_indent)</a>
<a name="ln4261">        next_is_start_par =</a>
<a name="ln4262">          (get_number_indent(curwin-&gt;w_cursor.lnum + 1) &gt; 0);</a>
<a name="ln4263">    }</a>
<a name="ln4264">    advance = true;</a>
<a name="ln4265">    is_end_par = (is_not_par || next_is_not_par || next_is_start_par);</a>
<a name="ln4266">    if (!is_end_par &amp;&amp; do_trail_white)</a>
<a name="ln4267">      is_end_par = !ends_in_white(curwin-&gt;w_cursor.lnum);</a>
<a name="ln4268"> </a>
<a name="ln4269">    /*</a>
<a name="ln4270">     * Skip lines that are not in a paragraph.</a>
<a name="ln4271">     */</a>
<a name="ln4272">    if (is_not_par) {</a>
<a name="ln4273">      if (line_count &lt; 0)</a>
<a name="ln4274">        break;</a>
<a name="ln4275">    } else {</a>
<a name="ln4276">      /*</a>
<a name="ln4277">       * For the first line of a paragraph, check indent of second line.</a>
<a name="ln4278">       * Don't do this for comments and empty lines.</a>
<a name="ln4279">       */</a>
<a name="ln4280">      if (first_par_line</a>
<a name="ln4281">          &amp;&amp; (do_second_indent || do_number_indent)</a>
<a name="ln4282">          &amp;&amp; prev_is_end_par</a>
<a name="ln4283">          &amp;&amp; curwin-&gt;w_cursor.lnum &lt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln4284">        if (do_second_indent &amp;&amp; !LINEEMPTY(curwin-&gt;w_cursor.lnum + 1)) {</a>
<a name="ln4285">          if (leader_len == 0 &amp;&amp; next_leader_len == 0) {</a>
<a name="ln4286">            /* no comment found */</a>
<a name="ln4287">            second_indent =</a>
<a name="ln4288">              get_indent_lnum(curwin-&gt;w_cursor.lnum + 1);</a>
<a name="ln4289">          } else {</a>
<a name="ln4290">            second_indent = next_leader_len;</a>
<a name="ln4291">            do_comments_list = 1;</a>
<a name="ln4292">          }</a>
<a name="ln4293">        } else if (do_number_indent) {</a>
<a name="ln4294">          if (leader_len == 0 &amp;&amp; next_leader_len == 0) {</a>
<a name="ln4295">            /* no comment found */</a>
<a name="ln4296">            second_indent =</a>
<a name="ln4297">              get_number_indent(curwin-&gt;w_cursor.lnum);</a>
<a name="ln4298">          } else {</a>
<a name="ln4299">            /* get_number_indent() is now &quot;comment aware&quot;... */</a>
<a name="ln4300">            second_indent =</a>
<a name="ln4301">              get_number_indent(curwin-&gt;w_cursor.lnum);</a>
<a name="ln4302">            do_comments_list = 1;</a>
<a name="ln4303">          }</a>
<a name="ln4304">        }</a>
<a name="ln4305">      }</a>
<a name="ln4306"> </a>
<a name="ln4307">      /*</a>
<a name="ln4308">       * When the comment leader changes, it's the end of the paragraph.</a>
<a name="ln4309">       */</a>
<a name="ln4310">      if (curwin-&gt;w_cursor.lnum &gt;= curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln4311">          || !same_leader(curwin-&gt;w_cursor.lnum,</a>
<a name="ln4312">              leader_len, leader_flags,</a>
<a name="ln4313">              next_leader_len, next_leader_flags)</a>
<a name="ln4314">          )</a>
<a name="ln4315">        is_end_par = true;</a>
<a name="ln4316"> </a>
<a name="ln4317">      /*</a>
<a name="ln4318">       * If we have got to the end of a paragraph, or the line is</a>
<a name="ln4319">       * getting long, format it.</a>
<a name="ln4320">       */</a>
<a name="ln4321">      if (is_end_par || force_format) {</a>
<a name="ln4322">        if (need_set_indent)</a>
<a name="ln4323">          /* replace indent in first line with minimal number of</a>
<a name="ln4324">           * tabs and spaces, according to current options */</a>
<a name="ln4325">          (void)set_indent(get_indent(), SIN_CHANGED);</a>
<a name="ln4326"> </a>
<a name="ln4327">        // put cursor on last non-space</a>
<a name="ln4328">        State = NORMAL;  // don't go past end-of-line</a>
<a name="ln4329">        coladvance(MAXCOL);</a>
<a name="ln4330">        while (curwin-&gt;w_cursor.col &amp;&amp; ascii_isspace(gchar_cursor())) {</a>
<a name="ln4331">          dec_cursor();</a>
<a name="ln4332">        }</a>
<a name="ln4333"> </a>
<a name="ln4334">        /* do the formatting, without 'showmode' */</a>
<a name="ln4335">        State = INSERT;         /* for open_line() */</a>
<a name="ln4336">        smd_save = p_smd;</a>
<a name="ln4337">        p_smd = FALSE;</a>
<a name="ln4338">        insertchar(NUL, INSCHAR_FORMAT</a>
<a name="ln4339">            + (do_comments ? INSCHAR_DO_COM : 0)</a>
<a name="ln4340">            + (do_comments &amp;&amp; do_comments_list</a>
<a name="ln4341">               ? INSCHAR_COM_LIST : 0)</a>
<a name="ln4342">            + (avoid_fex ? INSCHAR_NO_FEX : 0), second_indent);</a>
<a name="ln4343">        State = old_State;</a>
<a name="ln4344">        p_smd = smd_save;</a>
<a name="ln4345">        second_indent = -1;</a>
<a name="ln4346">        /* at end of par.: need to set indent of next par. */</a>
<a name="ln4347">        need_set_indent = is_end_par;</a>
<a name="ln4348">        if (is_end_par) {</a>
<a name="ln4349">          /* When called with a negative line count, break at the</a>
<a name="ln4350">           * end of the paragraph. */</a>
<a name="ln4351">          if (line_count &lt; 0)</a>
<a name="ln4352">            break;</a>
<a name="ln4353">          first_par_line = true;</a>
<a name="ln4354">        }</a>
<a name="ln4355">        force_format = false;</a>
<a name="ln4356">      }</a>
<a name="ln4357"> </a>
<a name="ln4358">      /*</a>
<a name="ln4359">       * When still in same paragraph, join the lines together.  But</a>
<a name="ln4360">       * first delete the leader from the second line.</a>
<a name="ln4361">       */</a>
<a name="ln4362">      if (!is_end_par) {</a>
<a name="ln4363">        advance = false;</a>
<a name="ln4364">        curwin-&gt;w_cursor.lnum++;</a>
<a name="ln4365">        curwin-&gt;w_cursor.col = 0;</a>
<a name="ln4366">        if (line_count &lt; 0 &amp;&amp; u_save_cursor() == FAIL)</a>
<a name="ln4367">          break;</a>
<a name="ln4368">        if (next_leader_len &gt; 0) {</a>
<a name="ln4369">          (void)del_bytes(next_leader_len, false, false);</a>
<a name="ln4370">          mark_col_adjust(curwin-&gt;w_cursor.lnum, (colnr_T)0, 0L,</a>
<a name="ln4371">                          (long)-next_leader_len, 0);</a>
<a name="ln4372">        } else if (second_indent &gt; 0) {   // the &quot;leader&quot; for FO_Q_SECOND</a>
<a name="ln4373">          int indent = (int)getwhitecols_curline();</a>
<a name="ln4374"> </a>
<a name="ln4375">          if (indent &gt; 0) {</a>
<a name="ln4376">            (void)del_bytes(indent, false, false);</a>
<a name="ln4377">            mark_col_adjust(curwin-&gt;w_cursor.lnum,</a>
<a name="ln4378">                            (colnr_T)0, 0L, (long)-indent, 0);</a>
<a name="ln4379">          }</a>
<a name="ln4380">        }</a>
<a name="ln4381">        curwin-&gt;w_cursor.lnum--;</a>
<a name="ln4382">        if (do_join(2, TRUE, FALSE, FALSE, false) == FAIL) {</a>
<a name="ln4383">          beep_flush();</a>
<a name="ln4384">          break;</a>
<a name="ln4385">        }</a>
<a name="ln4386">        first_par_line = false;</a>
<a name="ln4387">        // If the line is getting long, format it next time</a>
<a name="ln4388">        if (STRLEN(get_cursor_line_ptr()) &gt; (size_t)max_len) {</a>
<a name="ln4389">          force_format = true;</a>
<a name="ln4390">        } else {</a>
<a name="ln4391">          force_format = false;</a>
<a name="ln4392">        }</a>
<a name="ln4393">      }</a>
<a name="ln4394">    }</a>
<a name="ln4395">    line_breakcheck();</a>
<a name="ln4396">  }</a>
<a name="ln4397">}</a>
<a name="ln4398"> </a>
<a name="ln4399">/*</a>
<a name="ln4400"> * Return TRUE if line &quot;lnum&quot; ends in a white character.</a>
<a name="ln4401"> */</a>
<a name="ln4402">static int ends_in_white(linenr_T lnum)</a>
<a name="ln4403">{</a>
<a name="ln4404">  char_u      *s = ml_get(lnum);</a>
<a name="ln4405">  size_t l;</a>
<a name="ln4406"> </a>
<a name="ln4407">  if (*s == NUL)</a>
<a name="ln4408">    return FALSE;</a>
<a name="ln4409">  l = STRLEN(s) - 1;</a>
<a name="ln4410">  return ascii_iswhite(s[l]);</a>
<a name="ln4411">}</a>
<a name="ln4412"> </a>
<a name="ln4413">/*</a>
<a name="ln4414"> * Blank lines, and lines containing only the comment leader, are left</a>
<a name="ln4415"> * untouched by the formatting.  The function returns TRUE in this</a>
<a name="ln4416"> * case.  It also returns TRUE when a line starts with the end of a comment</a>
<a name="ln4417"> * ('e' in comment flags), so that this line is skipped, and not joined to the</a>
<a name="ln4418"> * previous line.  A new paragraph starts after a blank line, or when the</a>
<a name="ln4419"> * comment leader changes -- webb.</a>
<a name="ln4420"> */</a>
<a name="ln4421">static int fmt_check_par(linenr_T lnum, int *leader_len, char_u **leader_flags, int do_comments)</a>
<a name="ln4422">{</a>
<a name="ln4423">  char_u      *flags = NULL;        /* init for GCC */</a>
<a name="ln4424">  char_u      *ptr;</a>
<a name="ln4425"> </a>
<a name="ln4426">  ptr = ml_get(lnum);</a>
<a name="ln4427">  if (do_comments)</a>
<a name="ln4428">    *leader_len = get_leader_len(ptr, leader_flags, FALSE, TRUE);</a>
<a name="ln4429">  else</a>
<a name="ln4430">    *leader_len = 0;</a>
<a name="ln4431"> </a>
<a name="ln4432">  if (*leader_len &gt; 0) {</a>
<a name="ln4433">    /*</a>
<a name="ln4434">     * Search for 'e' flag in comment leader flags.</a>
<a name="ln4435">     */</a>
<a name="ln4436">    flags = *leader_flags;</a>
<a name="ln4437">    while (*flags &amp;&amp; *flags != ':' &amp;&amp; *flags != COM_END)</a>
<a name="ln4438">      ++flags;</a>
<a name="ln4439">  }</a>
<a name="ln4440"> </a>
<a name="ln4441">  return *skipwhite(ptr + *leader_len) == NUL</a>
<a name="ln4442">         || (*leader_len &gt; 0 &amp;&amp; *flags == COM_END)</a>
<a name="ln4443">         || startPS(lnum, NUL, FALSE);</a>
<a name="ln4444">}</a>
<a name="ln4445"> </a>
<a name="ln4446">/*</a>
<a name="ln4447"> * Return TRUE when a paragraph starts in line &quot;lnum&quot;.  Return FALSE when the</a>
<a name="ln4448"> * previous line is in the same paragraph.  Used for auto-formatting.</a>
<a name="ln4449"> */</a>
<a name="ln4450">int paragraph_start(linenr_T lnum)</a>
<a name="ln4451">{</a>
<a name="ln4452">  char_u *p;</a>
<a name="ln4453">  int leader_len = 0;                // leader len of current line</a>
<a name="ln4454">  char_u *leader_flags = NULL;       // flags for leader of current line</a>
<a name="ln4455">  int next_leader_len = 0;           // leader len of next line</a>
<a name="ln4456">  char_u *next_leader_flags = NULL;  // flags for leader of next line</a>
<a name="ln4457"> </a>
<a name="ln4458">  if (lnum &lt;= 1)</a>
<a name="ln4459">    return TRUE;                /* start of the file */</a>
<a name="ln4460"> </a>
<a name="ln4461">  p = ml_get(lnum - 1);</a>
<a name="ln4462">  if (*p == NUL)</a>
<a name="ln4463">    return TRUE;                /* after empty line */</a>
<a name="ln4464"> </a>
<a name="ln4465">  const bool do_comments = has_format_option(FO_Q_COMS);  // format comments</a>
<a name="ln4466">  if (fmt_check_par(lnum - 1, &amp;leader_len, &amp;leader_flags, do_comments)) {</a>
<a name="ln4467">    return true;  // after non-paragraph line</a>
<a name="ln4468">  }</a>
<a name="ln4469"> </a>
<a name="ln4470">  if (fmt_check_par(lnum, &amp;next_leader_len, &amp;next_leader_flags, do_comments)) {</a>
<a name="ln4471">    return true;  // &quot;lnum&quot; is not a paragraph line</a>
<a name="ln4472">  }</a>
<a name="ln4473"> </a>
<a name="ln4474">  if (has_format_option(FO_WHITE_PAR) &amp;&amp; !ends_in_white(lnum - 1))</a>
<a name="ln4475">    return TRUE;                /* missing trailing space in previous line. */</a>
<a name="ln4476"> </a>
<a name="ln4477">  if (has_format_option(FO_Q_NUMBER) &amp;&amp; (get_number_indent(lnum) &gt; 0))</a>
<a name="ln4478">    return TRUE;                /* numbered item starts in &quot;lnum&quot;. */</a>
<a name="ln4479"> </a>
<a name="ln4480">  if (!same_leader(lnum - 1, leader_len, leader_flags,</a>
<a name="ln4481">          next_leader_len, next_leader_flags))</a>
<a name="ln4482">    return TRUE;                /* change of comment leader. */</a>
<a name="ln4483"> </a>
<a name="ln4484">  return FALSE;</a>
<a name="ln4485">}</a>
<a name="ln4486"> </a>
<a name="ln4487">/*</a>
<a name="ln4488"> * prepare a few things for block mode yank/delete/tilde</a>
<a name="ln4489"> *</a>
<a name="ln4490"> * for delete:</a>
<a name="ln4491"> * - textlen includes the first/last char to be (partly) deleted</a>
<a name="ln4492"> * - start/endspaces is the number of columns that are taken by the</a>
<a name="ln4493"> *   first/last deleted char minus the number of columns that have to be</a>
<a name="ln4494"> *   deleted.</a>
<a name="ln4495"> * for yank and tilde:</a>
<a name="ln4496"> * - textlen includes the first/last char to be wholly yanked</a>
<a name="ln4497"> * - start/endspaces is the number of columns of the first/last yanked char</a>
<a name="ln4498"> *   that are to be yanked.</a>
<a name="ln4499"> */</a>
<a name="ln4500">static void block_prep(oparg_T *oap, struct block_def *bdp, linenr_T lnum,</a>
<a name="ln4501">                       bool is_del)</a>
<a name="ln4502">{</a>
<a name="ln4503">  int incr = 0;</a>
<a name="ln4504">  char_u      *pend;</a>
<a name="ln4505">  char_u      *pstart;</a>
<a name="ln4506">  char_u      *line;</a>
<a name="ln4507">  char_u      *prev_pstart;</a>
<a name="ln4508">  char_u      *prev_pend;</a>
<a name="ln4509">  const int lbr_saved = curwin-&gt;w_p_lbr;</a>
<a name="ln4510"> </a>
<a name="ln4511">  // Avoid a problem with unwanted linebreaks in block mode.</a>
<a name="ln4512">  curwin-&gt;w_p_lbr = false;</a>
<a name="ln4513">  bdp-&gt;startspaces = 0;</a>
<a name="ln4514">  bdp-&gt;endspaces = 0;</a>
<a name="ln4515">  bdp-&gt;textlen = 0;</a>
<a name="ln4516">  bdp-&gt;start_vcol = 0;</a>
<a name="ln4517">  bdp-&gt;end_vcol = 0;</a>
<a name="ln4518">  bdp-&gt;is_short = false;</a>
<a name="ln4519">  bdp-&gt;is_oneChar = false;</a>
<a name="ln4520">  bdp-&gt;pre_whitesp = 0;</a>
<a name="ln4521">  bdp-&gt;pre_whitesp_c = 0;</a>
<a name="ln4522">  bdp-&gt;end_char_vcols = 0;</a>
<a name="ln4523">  bdp-&gt;start_char_vcols = 0;</a>
<a name="ln4524"> </a>
<a name="ln4525">  line = ml_get(lnum);</a>
<a name="ln4526">  pstart = line;</a>
<a name="ln4527">  prev_pstart = line;</a>
<a name="ln4528">  while (bdp-&gt;start_vcol &lt; oap-&gt;start_vcol &amp;&amp; *pstart) {</a>
<a name="ln4529">    /* Count a tab for what it's worth (if list mode not on) */</a>
<a name="ln4530">    incr = lbr_chartabsize(line, pstart, (colnr_T)bdp-&gt;start_vcol);</a>
<a name="ln4531">    bdp-&gt;start_vcol += incr;</a>
<a name="ln4532">    if (ascii_iswhite(*pstart)) {</a>
<a name="ln4533">      bdp-&gt;pre_whitesp += incr;</a>
<a name="ln4534">      bdp-&gt;pre_whitesp_c++;</a>
<a name="ln4535">    } else {</a>
<a name="ln4536">      bdp-&gt;pre_whitesp = 0;</a>
<a name="ln4537">      bdp-&gt;pre_whitesp_c = 0;</a>
<a name="ln4538">    }</a>
<a name="ln4539">    prev_pstart = pstart;</a>
<a name="ln4540">    MB_PTR_ADV(pstart);</a>
<a name="ln4541">  }</a>
<a name="ln4542">  bdp-&gt;start_char_vcols = incr;</a>
<a name="ln4543">  if (bdp-&gt;start_vcol &lt; oap-&gt;start_vcol) {      /* line too short */</a>
<a name="ln4544">    bdp-&gt;end_vcol = bdp-&gt;start_vcol;</a>
<a name="ln4545">    bdp-&gt;is_short = true;</a>
<a name="ln4546">    if (!is_del || oap-&gt;op_type == OP_APPEND) {</a>
<a name="ln4547">      bdp-&gt;endspaces = oap-&gt;end_vcol - oap-&gt;start_vcol + 1;</a>
<a name="ln4548">    }</a>
<a name="ln4549">  } else {</a>
<a name="ln4550">    /* notice: this converts partly selected Multibyte characters to</a>
<a name="ln4551">     * spaces, too. */</a>
<a name="ln4552">    bdp-&gt;startspaces = bdp-&gt;start_vcol - oap-&gt;start_vcol;</a>
<a name="ln4553">    if (is_del &amp;&amp; bdp-&gt;startspaces)</a>
<a name="ln4554">      bdp-&gt;startspaces = bdp-&gt;start_char_vcols - bdp-&gt;startspaces;</a>
<a name="ln4555">    pend = pstart;</a>
<a name="ln4556">    bdp-&gt;end_vcol = bdp-&gt;start_vcol;</a>
<a name="ln4557">    if (bdp-&gt;end_vcol &gt; oap-&gt;end_vcol) {  // it's all in one character</a>
<a name="ln4558">      bdp-&gt;is_oneChar = true;</a>
<a name="ln4559">      if (oap-&gt;op_type == OP_INSERT) {</a>
<a name="ln4560">        bdp-&gt;endspaces = bdp-&gt;start_char_vcols - bdp-&gt;startspaces;</a>
<a name="ln4561">      } else if (oap-&gt;op_type == OP_APPEND) {</a>
<a name="ln4562">        bdp-&gt;startspaces += oap-&gt;end_vcol - oap-&gt;start_vcol + 1;</a>
<a name="ln4563">        bdp-&gt;endspaces = bdp-&gt;start_char_vcols - bdp-&gt;startspaces;</a>
<a name="ln4564">      } else {</a>
<a name="ln4565">        bdp-&gt;startspaces = oap-&gt;end_vcol - oap-&gt;start_vcol + 1;</a>
<a name="ln4566">        if (is_del &amp;&amp; oap-&gt;op_type != OP_LSHIFT) {</a>
<a name="ln4567">          /* just putting the sum of those two into</a>
<a name="ln4568">           * bdp-&gt;startspaces doesn't work for Visual replace,</a>
<a name="ln4569">           * so we have to split the tab in two */</a>
<a name="ln4570">          bdp-&gt;startspaces = bdp-&gt;start_char_vcols</a>
<a name="ln4571">                             - (bdp-&gt;start_vcol - oap-&gt;start_vcol);</a>
<a name="ln4572">          bdp-&gt;endspaces = bdp-&gt;end_vcol - oap-&gt;end_vcol - 1;</a>
<a name="ln4573">        }</a>
<a name="ln4574">      }</a>
<a name="ln4575">    } else {</a>
<a name="ln4576">      prev_pend = pend;</a>
<a name="ln4577">      while (bdp-&gt;end_vcol &lt;= oap-&gt;end_vcol &amp;&amp; *pend != NUL) {</a>
<a name="ln4578">        /* Count a tab for what it's worth (if list mode not on) */</a>
<a name="ln4579">        prev_pend = pend;</a>
<a name="ln4580">        incr = lbr_chartabsize_adv(line, &amp;pend, (colnr_T)bdp-&gt;end_vcol);</a>
<a name="ln4581">        bdp-&gt;end_vcol += incr;</a>
<a name="ln4582">      }</a>
<a name="ln4583">      if (bdp-&gt;end_vcol &lt;= oap-&gt;end_vcol</a>
<a name="ln4584">          &amp;&amp; (!is_del</a>
<a name="ln4585">              || oap-&gt;op_type == OP_APPEND</a>
<a name="ln4586">              || oap-&gt;op_type == OP_REPLACE)) {  // line too short</a>
<a name="ln4587">        bdp-&gt;is_short = true;</a>
<a name="ln4588">        // Alternative: include spaces to fill up the block.</a>
<a name="ln4589">        // Disadvantage: can lead to trailing spaces when the line is</a>
<a name="ln4590">        // short where the text is put</a>
<a name="ln4591">        // if (!is_del || oap-&gt;op_type == OP_APPEND)</a>
<a name="ln4592">        if (oap-&gt;op_type == OP_APPEND || virtual_op) {</a>
<a name="ln4593">          bdp-&gt;endspaces = oap-&gt;end_vcol - bdp-&gt;end_vcol</a>
<a name="ln4594">                           + oap-&gt;inclusive;</a>
<a name="ln4595">        }</a>
<a name="ln4596">      } else if (bdp-&gt;end_vcol &gt; oap-&gt;end_vcol) {</a>
<a name="ln4597">        bdp-&gt;endspaces = bdp-&gt;end_vcol - oap-&gt;end_vcol - 1;</a>
<a name="ln4598">        if (!is_del &amp;&amp; bdp-&gt;endspaces) {</a>
<a name="ln4599">          bdp-&gt;endspaces = incr - bdp-&gt;endspaces;</a>
<a name="ln4600">          if (pend != pstart)</a>
<a name="ln4601">            pend = prev_pend;</a>
<a name="ln4602">        }</a>
<a name="ln4603">      }</a>
<a name="ln4604">    }</a>
<a name="ln4605">    bdp-&gt;end_char_vcols = incr;</a>
<a name="ln4606">    if (is_del &amp;&amp; bdp-&gt;startspaces)</a>
<a name="ln4607">      pstart = prev_pstart;</a>
<a name="ln4608">    bdp-&gt;textlen = (int)(pend - pstart);</a>
<a name="ln4609">  }</a>
<a name="ln4610">  bdp-&gt;textcol = (colnr_T) (pstart - line);</a>
<a name="ln4611">  bdp-&gt;textstart = pstart;</a>
<a name="ln4612">  curwin-&gt;w_p_lbr = lbr_saved;</a>
<a name="ln4613">}</a>
<a name="ln4614"> </a>
<a name="ln4615">/// Handle the add/subtract operator.</a>
<a name="ln4616">///</a>
<a name="ln4617">/// @param[in]  oap      Arguments of operator.</a>
<a name="ln4618">/// @param[in]  Prenum1  Amount of addition or subtraction.</a>
<a name="ln4619">/// @param[in]  g_cmd    Prefixed with `g`.</a>
<a name="ln4620">void op_addsub(oparg_T *oap, linenr_T Prenum1, bool g_cmd)</a>
<a name="ln4621">{</a>
<a name="ln4622">  pos_T pos;</a>
<a name="ln4623">  struct block_def bd;</a>
<a name="ln4624">  ssize_t change_cnt = 0;</a>
<a name="ln4625">  linenr_T amount = Prenum1;</a>
<a name="ln4626"> </a>
<a name="ln4627">  if (!VIsual_active) {</a>
<a name="ln4628">    pos = curwin-&gt;w_cursor;</a>
<a name="ln4629">    if (u_save_cursor() == FAIL) {</a>
<a name="ln4630">      return;</a>
<a name="ln4631">    }</a>
<a name="ln4632">    change_cnt = do_addsub(oap-&gt;op_type, &amp;pos, 0, amount);</a>
<a name="ln4633">    if (change_cnt) {</a>
<a name="ln4634">      changed_lines(pos.lnum, 0, pos.lnum + 1, 0L, true);</a>
<a name="ln4635">    }</a>
<a name="ln4636">  } else {</a>
<a name="ln4637">    int one_change;</a>
<a name="ln4638">    int length;</a>
<a name="ln4639">    pos_T startpos;</a>
<a name="ln4640"> </a>
<a name="ln4641">    if (u_save((linenr_T)(oap-&gt;start.lnum - 1),</a>
<a name="ln4642">               (linenr_T)(oap-&gt;end.lnum + 1)) == FAIL) {</a>
<a name="ln4643">      return;</a>
<a name="ln4644">    }</a>
<a name="ln4645"> </a>
<a name="ln4646">    pos = oap-&gt;start;</a>
<a name="ln4647">    for (; pos.lnum &lt;= oap-&gt;end.lnum; pos.lnum++) {</a>
<a name="ln4648">      if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln4649">        // Visual block mode</a>
<a name="ln4650">        block_prep(oap, &amp;bd, pos.lnum, false);</a>
<a name="ln4651">        pos.col = bd.textcol;</a>
<a name="ln4652">        length = bd.textlen;</a>
<a name="ln4653">      } else if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln4654">        curwin-&gt;w_cursor.col = 0;</a>
<a name="ln4655">        pos.col = 0;</a>
<a name="ln4656">        length = (colnr_T)STRLEN(ml_get(pos.lnum));</a>
<a name="ln4657">      } else {</a>
<a name="ln4658">        // oap-&gt;motion_type == kMTCharWise</a>
<a name="ln4659">        if (pos.lnum == oap-&gt;start.lnum &amp;&amp; !oap-&gt;inclusive) {</a>
<a name="ln4660">          dec(&amp;(oap-&gt;end));</a>
<a name="ln4661">        }</a>
<a name="ln4662">        length = (colnr_T)STRLEN(ml_get(pos.lnum));</a>
<a name="ln4663">        pos.col = 0;</a>
<a name="ln4664">        if (pos.lnum == oap-&gt;start.lnum) {</a>
<a name="ln4665">          pos.col += oap-&gt;start.col;</a>
<a name="ln4666">          length -= oap-&gt;start.col;</a>
<a name="ln4667">        }</a>
<a name="ln4668">        if (pos.lnum == oap-&gt;end.lnum) {</a>
<a name="ln4669">          length = (int)STRLEN(ml_get(oap-&gt;end.lnum));</a>
<a name="ln4670">          if (oap-&gt;end.col &gt;= length) {</a>
<a name="ln4671">            oap-&gt;end.col = length - 1;</a>
<a name="ln4672">          }</a>
<a name="ln4673">          length = oap-&gt;end.col - pos.col + 1;</a>
<a name="ln4674">        }</a>
<a name="ln4675">      }</a>
<a name="ln4676">      one_change = do_addsub(oap-&gt;op_type, &amp;pos, length, amount);</a>
<a name="ln4677">      if (one_change) {</a>
<a name="ln4678">        // Remember the start position of the first change.</a>
<a name="ln4679">        if (change_cnt == 0) {</a>
<a name="ln4680">          startpos = curbuf-&gt;b_op_start;</a>
<a name="ln4681">        }</a>
<a name="ln4682">        change_cnt++;</a>
<a name="ln4683">      }</a>
<a name="ln4684"> </a>
<a name="ln4685">      if (g_cmd &amp;&amp; one_change) {</a>
<a name="ln4686">        amount += Prenum1;</a>
<a name="ln4687">      }</a>
<a name="ln4688">    }</a>
<a name="ln4689">    if (change_cnt) {</a>
<a name="ln4690">      changed_lines(oap-&gt;start.lnum, 0, oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln4691">    }</a>
<a name="ln4692"> </a>
<a name="ln4693">    if (!change_cnt &amp;&amp; oap-&gt;is_VIsual) {</a>
<a name="ln4694">      // No change: need to remove the Visual selection</a>
<a name="ln4695">      redraw_curbuf_later(INVERTED);</a>
<a name="ln4696">    }</a>
<a name="ln4697"> </a>
<a name="ln4698">    // Set '[ mark if something changed. Keep the last end</a>
<a name="ln4699">    // position from do_addsub().</a>
<a name="ln4700">    if (change_cnt &gt; 0) {</a>
<a name="ln4701">      curbuf-&gt;b_op_start = startpos;</a>
<a name="ln4702">    }</a>
<a name="ln4703"> </a>
<a name="ln4704">    if (change_cnt &gt; p_report) {</a>
<a name="ln4705">      if (change_cnt == 1) {</a>
<a name="ln4706">        MSG(_(&quot;1 line changed&quot;));</a>
<a name="ln4707">      } else {</a>
<a name="ln4708">        smsg((char *)_(&quot;%&quot; PRId64 &quot; lines changed&quot;), (int64_t)change_cnt);</a>
<a name="ln4709">      }</a>
<a name="ln4710">    }</a>
<a name="ln4711">  }</a>
<a name="ln4712">}</a>
<a name="ln4713"> </a>
<a name="ln4714">/// Add or subtract from a number in a line.</a>
<a name="ln4715">///</a>
<a name="ln4716">/// @param op_type OP_NR_ADD or OP_NR_SUB.</a>
<a name="ln4717">/// @param pos     Cursor position.</a>
<a name="ln4718">/// @param length  Target number length.</a>
<a name="ln4719">/// @param Prenum1 Amount of addition or subtraction.</a>
<a name="ln4720">///</a>
<a name="ln4721">/// @return true if some character was changed.</a>
<a name="ln4722">int do_addsub(int op_type, pos_T *pos, int length, linenr_T Prenum1)</a>
<a name="ln4723">{</a>
<a name="ln4724">  int col;</a>
<a name="ln4725">  char_u      *buf1 = NULL;</a>
<a name="ln4726">  char_u buf2[NUMBUFLEN];</a>
<a name="ln4727">  int pre;  // 'X' or 'x': hex; '0': octal; 'B' or 'b': bin</a>
<a name="ln4728">  static bool hexupper = false;  // 0xABC</a>
<a name="ln4729">  uvarnumber_T n;</a>
<a name="ln4730">  uvarnumber_T oldn;</a>
<a name="ln4731">  char_u      *ptr;</a>
<a name="ln4732">  int c;</a>
<a name="ln4733">  int todel;</a>
<a name="ln4734">  bool dohex;</a>
<a name="ln4735">  bool dooct;</a>
<a name="ln4736">  bool dobin;</a>
<a name="ln4737">  bool doalp;</a>
<a name="ln4738">  int firstdigit;</a>
<a name="ln4739">  bool subtract;</a>
<a name="ln4740">  bool negative = false;</a>
<a name="ln4741">  bool was_positive = true;</a>
<a name="ln4742">  bool visual = VIsual_active;</a>
<a name="ln4743">  bool did_change = false;</a>
<a name="ln4744">  pos_T save_cursor = curwin-&gt;w_cursor;</a>
<a name="ln4745">  int maxlen = 0;</a>
<a name="ln4746">  pos_T startpos;</a>
<a name="ln4747">  pos_T endpos;</a>
<a name="ln4748">  colnr_T save_coladd = 0;</a>
<a name="ln4749"> </a>
<a name="ln4750">  dohex = (vim_strchr(curbuf-&gt;b_p_nf, 'x') != NULL);    // &quot;heX&quot;</a>
<a name="ln4751">  dooct = (vim_strchr(curbuf-&gt;b_p_nf, 'o') != NULL);    // &quot;Octal&quot;</a>
<a name="ln4752">  dobin = (vim_strchr(curbuf-&gt;b_p_nf, 'b') != NULL);    // &quot;Bin&quot;</a>
<a name="ln4753">  doalp = (vim_strchr(curbuf-&gt;b_p_nf, 'p') != NULL);    // &quot;alPha&quot;</a>
<a name="ln4754"> </a>
<a name="ln4755">  if (virtual_active()) {</a>
<a name="ln4756">    save_coladd = pos-&gt;coladd;</a>
<a name="ln4757">    pos-&gt;coladd = 0;</a>
<a name="ln4758">  }</a>
<a name="ln4759"> </a>
<a name="ln4760">  curwin-&gt;w_cursor = *pos;</a>
<a name="ln4761">  ptr = ml_get(pos-&gt;lnum);</a>
<a name="ln4762">  col = pos-&gt;col;</a>
<a name="ln4763"> </a>
<a name="ln4764">  if (*ptr == NUL || col + !!save_coladd &gt;= (int)STRLEN(ptr)) {</a>
<a name="ln4765">    goto theend;</a>
<a name="ln4766">  }</a>
<a name="ln4767"> </a>
<a name="ln4768">  // First check if we are on a hexadecimal number, after the &quot;0x&quot;.</a>
<a name="ln4769">  if (!VIsual_active) {</a>
<a name="ln4770">    if (dobin) {</a>
<a name="ln4771">      while (col &gt; 0 &amp;&amp; ascii_isbdigit(ptr[col])) {</a>
<a name="ln4772">        col--;</a>
<a name="ln4773">        col -= utf_head_off(ptr, ptr + col);</a>
<a name="ln4774">      }</a>
<a name="ln4775">    }</a>
<a name="ln4776"> </a>
<a name="ln4777">    if (dohex) {</a>
<a name="ln4778">      while (col &gt; 0 &amp;&amp; ascii_isxdigit(ptr[col])) {</a>
<a name="ln4779">        col--;</a>
<a name="ln4780">        col -= utf_head_off(ptr, ptr + col);</a>
<a name="ln4781">      }</a>
<a name="ln4782">    }</a>
<a name="ln4783">    if (dobin</a>
<a name="ln4784">        &amp;&amp; dohex</a>
<a name="ln4785">        &amp;&amp; !((col &gt; 0</a>
<a name="ln4786">              &amp;&amp; (ptr[col] == 'X' || ptr[col] == 'x')</a>
<a name="ln4787">              &amp;&amp; ptr[col - 1] == '0'</a>
<a name="ln4788">              &amp;&amp; !utf_head_off(ptr, ptr + col - 1)</a>
<a name="ln4789">              &amp;&amp; ascii_isxdigit(ptr[col + 1])))) {</a>
<a name="ln4790">        // In case of binary/hexadecimal pattern overlap match, rescan</a>
<a name="ln4791"> </a>
<a name="ln4792">        col = curwin-&gt;w_cursor.col;</a>
<a name="ln4793"> </a>
<a name="ln4794">        while (col &gt; 0 &amp;&amp; ascii_isdigit(ptr[col])) {</a>
<a name="ln4795">          col--;</a>
<a name="ln4796">          col -= utf_head_off(ptr, ptr + col);</a>
<a name="ln4797">        }</a>
<a name="ln4798">    }</a>
<a name="ln4799"> </a>
<a name="ln4800">    if ((dohex</a>
<a name="ln4801">         &amp;&amp; col &gt; 0</a>
<a name="ln4802">         &amp;&amp; (ptr[col] == 'X' || ptr[col] == 'x')</a>
<a name="ln4803">         &amp;&amp; ptr[col - 1] == '0'</a>
<a name="ln4804">         &amp;&amp; !utf_head_off(ptr, ptr + col - 1)</a>
<a name="ln4805">         &amp;&amp; ascii_isxdigit(ptr[col + 1]))</a>
<a name="ln4806">        || (dobin</a>
<a name="ln4807">            &amp;&amp; col &gt; 0</a>
<a name="ln4808">            &amp;&amp; (ptr[col] == 'B' || ptr[col] == 'b')</a>
<a name="ln4809">            &amp;&amp; ptr[col - 1] == '0'</a>
<a name="ln4810">            &amp;&amp; !utf_head_off(ptr, ptr + col - 1)</a>
<a name="ln4811">            &amp;&amp; ascii_isbdigit(ptr[col + 1]))) {</a>
<a name="ln4812">      // Found hexadecimal or binary number, move to its start.</a>
<a name="ln4813">        col--;</a>
<a name="ln4814">        col -= utf_head_off(ptr, ptr + col);</a>
<a name="ln4815">    } else {</a>
<a name="ln4816">      // Search forward and then backward to find the start of number.</a>
<a name="ln4817">      col = pos-&gt;col;</a>
<a name="ln4818"> </a>
<a name="ln4819">      while (ptr[col] != NUL</a>
<a name="ln4820">             &amp;&amp; !ascii_isdigit(ptr[col])</a>
<a name="ln4821">             &amp;&amp; !(doalp &amp;&amp; ASCII_ISALPHA(ptr[col]))) {</a>
<a name="ln4822">        col++;</a>
<a name="ln4823">      }</a>
<a name="ln4824"> </a>
<a name="ln4825">      while (col &gt; 0</a>
<a name="ln4826">             &amp;&amp; ascii_isdigit(ptr[col - 1])</a>
<a name="ln4827">             &amp;&amp; !(doalp &amp;&amp; ASCII_ISALPHA(ptr[col]))) {</a>
<a name="ln4828">        col--;</a>
<a name="ln4829">      }</a>
<a name="ln4830">    }</a>
<a name="ln4831">  }</a>
<a name="ln4832"> </a>
<a name="ln4833">  if (visual) {</a>
<a name="ln4834">    while (ptr[col] != NUL &amp;&amp; length &gt; 0 &amp;&amp; !ascii_isdigit(ptr[col])</a>
<a name="ln4835">           &amp;&amp; !(doalp &amp;&amp; ASCII_ISALPHA(ptr[col]))) {</a>
<a name="ln4836">      int mb_len = utfc_ptr2len(ptr + col);</a>
<a name="ln4837"> </a>
<a name="ln4838">      col += mb_len;</a>
<a name="ln4839">      length -= mb_len;</a>
<a name="ln4840">    }</a>
<a name="ln4841"> </a>
<a name="ln4842">    if (length == 0) {</a>
<a name="ln4843">      goto theend;</a>
<a name="ln4844">    }</a>
<a name="ln4845"> </a>
<a name="ln4846">    if (col &gt; pos-&gt;col &amp;&amp; ptr[col - 1] == '-'</a>
<a name="ln4847">        &amp;&amp; !utf_head_off(ptr, ptr + col - 1)) {</a>
<a name="ln4848">      negative = true;</a>
<a name="ln4849">      was_positive = false;</a>
<a name="ln4850">    }</a>
<a name="ln4851">  }</a>
<a name="ln4852"> </a>
<a name="ln4853">  // If a number was found, and saving for undo works, replace the number.</a>
<a name="ln4854">  firstdigit = ptr[col];</a>
<a name="ln4855">  if (!ascii_isdigit(firstdigit) &amp;&amp; !(doalp &amp;&amp; ASCII_ISALPHA(firstdigit))) {</a>
<a name="ln4856">    beep_flush();</a>
<a name="ln4857">    goto theend;</a>
<a name="ln4858">  }</a>
<a name="ln4859"> </a>
<a name="ln4860">  if (doalp &amp;&amp; ASCII_ISALPHA(firstdigit)) {</a>
<a name="ln4861">    // decrement or increment alphabetic character</a>
<a name="ln4862">    if (op_type == OP_NR_SUB) {</a>
<a name="ln4863">      if (CharOrd(firstdigit) &lt; Prenum1) {</a>
<a name="ln4864">        if (isupper(firstdigit)) {</a>
<a name="ln4865">          firstdigit = 'A';</a>
<a name="ln4866">        } else {</a>
<a name="ln4867">          firstdigit = 'a';</a>
<a name="ln4868">        }</a>
<a name="ln4869">      } else {</a>
<a name="ln4870">        firstdigit -= (int)Prenum1;</a>
<a name="ln4871">      }</a>
<a name="ln4872">    } else {</a>
<a name="ln4873">      if (26 - CharOrd(firstdigit) - 1 &lt; Prenum1) {</a>
<a name="ln4874">        if (isupper(firstdigit)) {</a>
<a name="ln4875">          firstdigit = 'Z';</a>
<a name="ln4876">        } else {</a>
<a name="ln4877">          firstdigit = 'z';</a>
<a name="ln4878">        }</a>
<a name="ln4879">      } else {</a>
<a name="ln4880">        firstdigit += (int)Prenum1;</a>
<a name="ln4881">      }</a>
<a name="ln4882">    }</a>
<a name="ln4883">    curwin-&gt;w_cursor.col = col;</a>
<a name="ln4884">    startpos = curwin-&gt;w_cursor;</a>
<a name="ln4885">    did_change = true;</a>
<a name="ln4886">    (void)del_char(false);</a>
<a name="ln4887">    ins_char(firstdigit);</a>
<a name="ln4888">    endpos = curwin-&gt;w_cursor;</a>
<a name="ln4889">    curwin-&gt;w_cursor.col = col;</a>
<a name="ln4890">  } else {</a>
<a name="ln4891">    if (col &gt; 0 &amp;&amp; ptr[col - 1] == '-'</a>
<a name="ln4892">        &amp;&amp; !utf_head_off(ptr, ptr + col - 1) &amp;&amp; !visual) {</a>
<a name="ln4893">      // negative number</a>
<a name="ln4894">      col--;</a>
<a name="ln4895">      negative = true;</a>
<a name="ln4896">    }</a>
<a name="ln4897"> </a>
<a name="ln4898">    // get the number value (unsigned)</a>
<a name="ln4899">    if (visual &amp;&amp; VIsual_mode != 'V') {</a>
<a name="ln4900">      maxlen = (curbuf-&gt;b_visual.vi_curswant == MAXCOL</a>
<a name="ln4901">                ? (int)STRLEN(ptr) - col</a>
<a name="ln4902">                : length);</a>
<a name="ln4903">    }</a>
<a name="ln4904"> </a>
<a name="ln4905">    vim_str2nr(ptr + col, &amp;pre, &amp;length,</a>
<a name="ln4906">               0 + (dobin ? STR2NR_BIN : 0)</a>
<a name="ln4907">               + (dooct ? STR2NR_OCT : 0)</a>
<a name="ln4908">               + (dohex ? STR2NR_HEX : 0),</a>
<a name="ln4909">               NULL, &amp;n, maxlen);</a>
<a name="ln4910"> </a>
<a name="ln4911">    // ignore leading '-' for hex, octal and bin numbers</a>
<a name="ln4912">    if (pre &amp;&amp; negative) {</a>
<a name="ln4913">      col++;</a>
<a name="ln4914">      length--;</a>
<a name="ln4915">      negative = false;</a>
<a name="ln4916">    }</a>
<a name="ln4917"> </a>
<a name="ln4918">    // add or subtract</a>
<a name="ln4919">    subtract = false;</a>
<a name="ln4920">    if (op_type == OP_NR_SUB) {</a>
<a name="ln4921">      subtract ^= true;</a>
<a name="ln4922">    }</a>
<a name="ln4923">    if (negative) {</a>
<a name="ln4924">      subtract ^= true;</a>
<a name="ln4925">    }</a>
<a name="ln4926"> </a>
<a name="ln4927">    oldn = n;</a>
<a name="ln4928"> </a>
<a name="ln4929">    n = subtract ? n - (uvarnumber_T)Prenum1</a>
<a name="ln4930">                 : n + (uvarnumber_T)Prenum1;</a>
<a name="ln4931"> </a>
<a name="ln4932">    // handle wraparound for decimal numbers</a>
<a name="ln4933">    if (!pre) {</a>
<a name="ln4934">      if (subtract) {</a>
<a name="ln4935">        if (n &gt; oldn) {</a>
<a name="ln4936">          n = 1 + (n ^ (uvarnumber_T)-1);</a>
<a name="ln4937">          negative ^= true;</a>
<a name="ln4938">        }</a>
<a name="ln4939">      } else {</a>
<a name="ln4940">        // add</a>
<a name="ln4941">        if (n &lt; oldn) {</a>
<a name="ln4942">          n = (n ^ (uvarnumber_T)-1);</a>
<a name="ln4943">          negative ^= true;</a>
<a name="ln4944">        }</a>
<a name="ln4945">      }</a>
<a name="ln4946">      if (n == 0) {</a>
<a name="ln4947">        negative = false;</a>
<a name="ln4948">      }</a>
<a name="ln4949">    }</a>
<a name="ln4950"> </a>
<a name="ln4951">    if (visual &amp;&amp; !was_positive &amp;&amp; !negative &amp;&amp; col &gt; 0) {</a>
<a name="ln4952">      // need to remove the '-'</a>
<a name="ln4953">      col--;</a>
<a name="ln4954">      length++;</a>
<a name="ln4955">    }</a>
<a name="ln4956"> </a>
<a name="ln4957">    // Delete the old number.</a>
<a name="ln4958">    curwin-&gt;w_cursor.col = col;</a>
<a name="ln4959">    startpos = curwin-&gt;w_cursor;</a>
<a name="ln4960">    did_change = true;</a>
<a name="ln4961">    todel = length;</a>
<a name="ln4962">    c = gchar_cursor();</a>
<a name="ln4963"> </a>
<a name="ln4964">    // Don't include the '-' in the length, only the length of the part</a>
<a name="ln4965">    // after it is kept the same.</a>
<a name="ln4966">    if (c == '-') {</a>
<a name="ln4967">      length--;</a>
<a name="ln4968">    }</a>
<a name="ln4969">    while (todel-- &gt; 0) {</a>
<a name="ln4970">      if (c &lt; 0x100 &amp;&amp; isalpha(c)) {</a>
<a name="ln4971">        if (isupper(c)) {</a>
<a name="ln4972">          hexupper = true;</a>
<a name="ln4973">        } else {</a>
<a name="ln4974">          hexupper = false;</a>
<a name="ln4975">        }</a>
<a name="ln4976">      }</a>
<a name="ln4977">      // del_char() will mark line needing displaying</a>
<a name="ln4978">      (void)del_char(false);</a>
<a name="ln4979">      c = gchar_cursor();</a>
<a name="ln4980">    }</a>
<a name="ln4981"> </a>
<a name="ln4982">    // Prepare the leading characters in buf1[].</a>
<a name="ln4983">    // When there are many leading zeros it could be very long.</a>
<a name="ln4984">    // Allocate a bit too much.</a>
<a name="ln4985">    buf1 = xmalloc((size_t)length + NUMBUFLEN);</a>
<a name="ln4986">    ptr = buf1;</a>
<a name="ln4987">    if (negative &amp;&amp; (!visual || was_positive)) {</a>
<a name="ln4988">      *ptr++ = '-';</a>
<a name="ln4989">    }</a>
<a name="ln4990">    if (pre) {</a>
<a name="ln4991">      *ptr++ = '0';</a>
<a name="ln4992">      length--;</a>
<a name="ln4993">    }</a>
<a name="ln4994">    if (pre == 'b' || pre == 'B' || pre == 'x' || pre == 'X') {</a>
<a name="ln4995">      *ptr++ = (char_u)pre;</a>
<a name="ln4996">      length--;</a>
<a name="ln4997">    }</a>
<a name="ln4998"> </a>
<a name="ln4999">    // Put the number characters in buf2[].</a>
<a name="ln5000">    if (pre == 'b' || pre == 'B') {</a>
<a name="ln5001">      size_t bits = 0;</a>
<a name="ln5002">      size_t i = 0;</a>
<a name="ln5003"> </a>
<a name="ln5004">      // leading zeros</a>
<a name="ln5005">      for (bits = 8 * sizeof(n); bits &gt; 0; bits--) {</a>
<a name="ln5006">          if ((n &gt;&gt; (bits - 1)) &amp; 0x1) {</a>
<a name="ln5007">            break;</a>
<a name="ln5008">          }</a>
<a name="ln5009">      }</a>
<a name="ln5010"> </a>
<a name="ln5011">      while (bits &gt; 0) {</a>
<a name="ln5012">          buf2[i++] = ((n &gt;&gt; --bits) &amp; 0x1) ? '1' : '0';</a>
<a name="ln5013">      }</a>
<a name="ln5014"> </a>
<a name="ln5015">      buf2[i] = '\0';</a>
<a name="ln5016"> </a>
<a name="ln5017">    } else if (pre == 0) {</a>
<a name="ln5018">      vim_snprintf((char *)buf2, ARRAY_SIZE(buf2), &quot;%&quot; PRIu64, (uint64_t)n);</a>
<a name="ln5019">    } else if (pre == '0') {</a>
<a name="ln5020">      vim_snprintf((char *)buf2, ARRAY_SIZE(buf2), &quot;%&quot; PRIo64, (uint64_t)n);</a>
<a name="ln5021">    } else if (hexupper) {</a>
<a name="ln5022">      vim_snprintf((char *)buf2, ARRAY_SIZE(buf2), &quot;%&quot; PRIX64, (uint64_t)n);</a>
<a name="ln5023">    } else {</a>
<a name="ln5024">      vim_snprintf((char *)buf2, ARRAY_SIZE(buf2), &quot;%&quot; PRIx64, (uint64_t)n);</a>
<a name="ln5025">    }</a>
<a name="ln5026">    length -= (int)STRLEN(buf2);</a>
<a name="ln5027"> </a>
<a name="ln5028">    // Adjust number of zeros to the new number of digits, so the</a>
<a name="ln5029">    // total length of the number remains the same.</a>
<a name="ln5030">    // Don't do this when</a>
<a name="ln5031">    // the result may look like an octal number.</a>
<a name="ln5032">    if (firstdigit == '0' &amp;&amp; !(dooct &amp;&amp; pre == 0)) {</a>
<a name="ln5033">      while (length-- &gt; 0) {</a>
<a name="ln5034">        *ptr++ = '0';</a>
<a name="ln5035">      }</a>
<a name="ln5036">    }</a>
<a name="ln5037">    *ptr = NUL;</a>
<a name="ln5038">    STRCAT(buf1, buf2);</a>
<a name="ln5039">    ins_str(buf1);              // insert the new number</a>
<a name="ln5040">    endpos = curwin-&gt;w_cursor;</a>
<a name="ln5041">    if (curwin-&gt;w_cursor.col) {</a>
<a name="ln5042">      curwin-&gt;w_cursor.col--;</a>
<a name="ln5043">    }</a>
<a name="ln5044">  }</a>
<a name="ln5045"> </a>
<a name="ln5046">  // set the '[ and '] marks</a>
<a name="ln5047">  curbuf-&gt;b_op_start = startpos;</a>
<a name="ln5048">  curbuf-&gt;b_op_end = endpos;</a>
<a name="ln5049">  if (curbuf-&gt;b_op_end.col &gt; 0) {</a>
<a name="ln5050">    curbuf-&gt;b_op_end.col--;</a>
<a name="ln5051">  }</a>
<a name="ln5052"> </a>
<a name="ln5053">theend:</a>
<a name="ln5054">  xfree(buf1);</a>
<a name="ln5055">  if (visual) {</a>
<a name="ln5056">    curwin-&gt;w_cursor = save_cursor;</a>
<a name="ln5057">  } else if (did_change) {</a>
<a name="ln5058">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln5059">  } else if (virtual_active()) {</a>
<a name="ln5060">    curwin-&gt;w_cursor.coladd = save_coladd;</a>
<a name="ln5061">  }</a>
<a name="ln5062"> </a>
<a name="ln5063">  return did_change;</a>
<a name="ln5064">}</a>
<a name="ln5065"> </a>
<a name="ln5066">/*</a>
<a name="ln5067"> * Return the type of a register.</a>
<a name="ln5068"> * Used for getregtype()</a>
<a name="ln5069"> * Returns kMTUnknown for error.</a>
<a name="ln5070"> */</a>
<a name="ln5071">MotionType get_reg_type(int regname, colnr_T *reg_width)</a>
<a name="ln5072">{</a>
<a name="ln5073">  switch (regname) {</a>
<a name="ln5074">    case '%':     // file name</a>
<a name="ln5075">    case '#':     // alternate file name</a>
<a name="ln5076">    case '=':     // expression</a>
<a name="ln5077">    case ':':     // last command line</a>
<a name="ln5078">    case '/':     // last search-pattern</a>
<a name="ln5079">    case '.':     // last inserted text</a>
<a name="ln5080">    case Ctrl_F:  // Filename under cursor</a>
<a name="ln5081">    case Ctrl_P:  // Path under cursor, expand via &quot;path&quot;</a>
<a name="ln5082">    case Ctrl_W:  // word under cursor</a>
<a name="ln5083">    case Ctrl_A:  // WORD (mnemonic All) under cursor</a>
<a name="ln5084">    case '_':     // black hole: always empty</a>
<a name="ln5085">      return kMTCharWise;</a>
<a name="ln5086">  }</a>
<a name="ln5087"> </a>
<a name="ln5088">  if (regname != NUL &amp;&amp; !valid_yank_reg(regname, false)) {</a>
<a name="ln5089">    return kMTUnknown;</a>
<a name="ln5090">  }</a>
<a name="ln5091"> </a>
<a name="ln5092">  yankreg_T *reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln5093"> </a>
<a name="ln5094">  if (reg-&gt;y_array != NULL) {</a>
<a name="ln5095">    if (reg_width != NULL &amp;&amp; reg-&gt;y_type == kMTBlockWise) {</a>
<a name="ln5096">      *reg_width = reg-&gt;y_width;</a>
<a name="ln5097">    }</a>
<a name="ln5098">    return reg-&gt;y_type;</a>
<a name="ln5099">  }</a>
<a name="ln5100">  return kMTUnknown;</a>
<a name="ln5101">}</a>
<a name="ln5102"> </a>
<a name="ln5103">/// Format the register type as a string.</a>
<a name="ln5104">///</a>
<a name="ln5105">/// @param reg_type The register type.</a>
<a name="ln5106">/// @param reg_width The width, only used if &quot;reg_type&quot; is kMTBlockWise.</a>
<a name="ln5107">/// @param[out] buf Buffer to store formatted string. The allocated size should</a>
<a name="ln5108">///                 be at least NUMBUFLEN+2 to always fit the value.</a>
<a name="ln5109">/// @param buf_len The allocated size of the buffer.</a>
<a name="ln5110">void format_reg_type(MotionType reg_type, colnr_T reg_width,</a>
<a name="ln5111">                     char *buf, size_t buf_len)</a>
<a name="ln5112">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5113">{</a>
<a name="ln5114">  assert(buf_len &gt; 1);</a>
<a name="ln5115">  switch (reg_type) {</a>
<a name="ln5116">    case kMTLineWise:</a>
<a name="ln5117">      buf[0] = 'V';</a>
<a name="ln5118">      buf[1] = NUL;</a>
<a name="ln5119">      break;</a>
<a name="ln5120">    case kMTCharWise:</a>
<a name="ln5121">      buf[0] = 'v';</a>
<a name="ln5122">      buf[1] = NUL;</a>
<a name="ln5123">      break;</a>
<a name="ln5124">    case kMTBlockWise:</a>
<a name="ln5125">      snprintf(buf, buf_len, CTRL_V_STR &quot;%&quot; PRIdCOLNR, reg_width + 1);</a>
<a name="ln5126">      break;</a>
<a name="ln5127">    case kMTUnknown:</a>
<a name="ln5128">      buf[0] = NUL;</a>
<a name="ln5129">      break;</a>
<a name="ln5130">  }</a>
<a name="ln5131">}</a>
<a name="ln5132"> </a>
<a name="ln5133"> </a>
<a name="ln5134">/// When `flags` has `kGRegList` return a list with text `s`.</a>
<a name="ln5135">/// Otherwise just return `s`.</a>
<a name="ln5136">///</a>
<a name="ln5137">/// Returns a void * for use in get_reg_contents().</a>
<a name="ln5138">static void *get_reg_wrap_one_line(char_u *s, int flags)</a>
<a name="ln5139">{</a>
<a name="ln5140">  if (!(flags &amp; kGRegList)) {</a>
<a name="ln5141">    return s;</a>
<a name="ln5142">  }</a>
<a name="ln5143">  list_T *const list = tv_list_alloc(1);</a>
<a name="ln5144">  tv_list_append_allocated_string(list, (char *)s);</a>
<a name="ln5145">  return list;</a>
<a name="ln5146">}</a>
<a name="ln5147"> </a>
<a name="ln5148">/// Gets the contents of a register.</a>
<a name="ln5149">/// @remark Used for `@r` in expressions and for `getreg()`.</a>
<a name="ln5150">///</a>
<a name="ln5151">/// @param regname  The register.</a>
<a name="ln5152">/// @param flags    see @ref GRegFlags</a>
<a name="ln5153">///</a>
<a name="ln5154">/// @returns The contents of the register as an allocated string.</a>
<a name="ln5155">/// @returns A linked list when `flags` contains @ref kGRegList.</a>
<a name="ln5156">/// @returns NULL for error.</a>
<a name="ln5157">void *get_reg_contents(int regname, int flags)</a>
<a name="ln5158">{</a>
<a name="ln5159">  // Don't allow using an expression register inside an expression.</a>
<a name="ln5160">  if (regname == '=') {</a>
<a name="ln5161">    if (flags &amp; kGRegNoExpr) {</a>
<a name="ln5162">      return NULL;</a>
<a name="ln5163">    }</a>
<a name="ln5164">    if (flags &amp; kGRegExprSrc) {</a>
<a name="ln5165">      return get_reg_wrap_one_line(get_expr_line_src(), flags);</a>
<a name="ln5166">    }</a>
<a name="ln5167">    return get_reg_wrap_one_line(get_expr_line(), flags);</a>
<a name="ln5168">  }</a>
<a name="ln5169"> </a>
<a name="ln5170">  if (regname == '@')       /* &quot;@@&quot; is used for unnamed register */</a>
<a name="ln5171">    regname = '&quot;';</a>
<a name="ln5172"> </a>
<a name="ln5173">  /* check for valid regname */</a>
<a name="ln5174">  if (regname != NUL &amp;&amp; !valid_yank_reg(regname, false))</a>
<a name="ln5175">    return NULL;</a>
<a name="ln5176"> </a>
<a name="ln5177">  char_u *retval;</a>
<a name="ln5178">  bool allocated;</a>
<a name="ln5179">  if (get_spec_reg(regname, &amp;retval, &amp;allocated, false)) {</a>
<a name="ln5180">    if (retval == NULL) {</a>
<a name="ln5181">      return NULL;</a>
<a name="ln5182">    }</a>
<a name="ln5183">    if (allocated) {</a>
<a name="ln5184">      return get_reg_wrap_one_line(retval, flags);</a>
<a name="ln5185">    }</a>
<a name="ln5186">    return get_reg_wrap_one_line(vim_strsave(retval), flags);</a>
<a name="ln5187">  }</a>
<a name="ln5188"> </a>
<a name="ln5189">  yankreg_T *reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln5190">  if (reg-&gt;y_array == NULL)</a>
<a name="ln5191">    return NULL;</a>
<a name="ln5192"> </a>
<a name="ln5193">  if (flags &amp; kGRegList) {</a>
<a name="ln5194">    list_T *const list = tv_list_alloc((ptrdiff_t)reg-&gt;y_size);</a>
<a name="ln5195">    for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln5196">      tv_list_append_string(list, (const char *)reg-&gt;y_array[i], -1);</a>
<a name="ln5197">    }</a>
<a name="ln5198"> </a>
<a name="ln5199">    return list;</a>
<a name="ln5200">  }</a>
<a name="ln5201"> </a>
<a name="ln5202">  /*</a>
<a name="ln5203">   * Compute length of resulting string.</a>
<a name="ln5204">   */</a>
<a name="ln5205">  size_t len = 0;</a>
<a name="ln5206">  for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln5207">    len += STRLEN(reg-&gt;y_array[i]);</a>
<a name="ln5208">    /*</a>
<a name="ln5209">     * Insert a newline between lines and after last line if</a>
<a name="ln5210">     * y_type is kMTLineWise.</a>
<a name="ln5211">     */</a>
<a name="ln5212">    if (reg-&gt;y_type == kMTLineWise || i &lt; reg-&gt;y_size - 1) {</a>
<a name="ln5213">      len++;</a>
<a name="ln5214">    }</a>
<a name="ln5215">  }</a>
<a name="ln5216"> </a>
<a name="ln5217">  retval = xmalloc(len + 1);</a>
<a name="ln5218"> </a>
<a name="ln5219">  /*</a>
<a name="ln5220">   * Copy the lines of the yank register into the string.</a>
<a name="ln5221">   */</a>
<a name="ln5222">  len = 0;</a>
<a name="ln5223">  for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln5224">    STRCPY(retval + len, reg-&gt;y_array[i]);</a>
<a name="ln5225">    len += STRLEN(retval + len);</a>
<a name="ln5226"> </a>
<a name="ln5227">    /*</a>
<a name="ln5228">     * Insert a NL between lines and after the last line if y_type is</a>
<a name="ln5229">     * kMTLineWise.</a>
<a name="ln5230">     */</a>
<a name="ln5231">    if (reg-&gt;y_type == kMTLineWise || i &lt; reg-&gt;y_size - 1) {</a>
<a name="ln5232">      retval[len++] = '\n';</a>
<a name="ln5233">    }</a>
<a name="ln5234">  }</a>
<a name="ln5235">  retval[len] = NUL;</a>
<a name="ln5236"> </a>
<a name="ln5237">  return retval;</a>
<a name="ln5238">}</a>
<a name="ln5239"> </a>
<a name="ln5240">static yankreg_T *init_write_reg(int name, yankreg_T **old_y_previous, bool must_append)</a>
<a name="ln5241">{</a>
<a name="ln5242">  if (!valid_yank_reg(name, true)) {  // check for valid reg name</a>
<a name="ln5243">    emsg_invreg(name);</a>
<a name="ln5244">    return NULL;</a>
<a name="ln5245">  }</a>
<a name="ln5246"> </a>
<a name="ln5247">  // Don't want to change the current (unnamed) register.</a>
<a name="ln5248">  *old_y_previous = y_previous;</a>
<a name="ln5249"> </a>
<a name="ln5250">  yankreg_T *reg = get_yank_register(name, YREG_YANK);</a>
<a name="ln5251">  if (!is_append_register(name) &amp;&amp; !must_append) {</a>
<a name="ln5252">      free_register(reg);</a>
<a name="ln5253">  }</a>
<a name="ln5254">  return reg;</a>
<a name="ln5255">}</a>
<a name="ln5256"> </a>
<a name="ln5257">static void finish_write_reg(int name, yankreg_T *reg, yankreg_T *old_y_previous)</a>
<a name="ln5258">{</a>
<a name="ln5259">  // Send text of clipboard register to the clipboard.</a>
<a name="ln5260">  set_clipboard(name, reg);</a>
<a name="ln5261"> </a>
<a name="ln5262">  // ':let @&quot; = &quot;val&quot;' should change the meaning of the &quot;&quot; register</a>
<a name="ln5263">  if (name != '&quot;') {</a>
<a name="ln5264">    y_previous = old_y_previous;</a>
<a name="ln5265">  }</a>
<a name="ln5266">}</a>
<a name="ln5267"> </a>
<a name="ln5268">/// write_reg_contents - store `str` in register `name`</a>
<a name="ln5269">///</a>
<a name="ln5270">/// @see write_reg_contents_ex</a>
<a name="ln5271">void write_reg_contents(int name, const char_u *str, ssize_t len,</a>
<a name="ln5272">                        int must_append)</a>
<a name="ln5273">{</a>
<a name="ln5274">  write_reg_contents_ex(name, str, len, must_append, kMTUnknown, 0L);</a>
<a name="ln5275">}</a>
<a name="ln5276"> </a>
<a name="ln5277">void write_reg_contents_lst(int name, char_u **strings,</a>
<a name="ln5278">                            bool must_append, MotionType yank_type,</a>
<a name="ln5279">                            colnr_T block_len)</a>
<a name="ln5280">{</a>
<a name="ln5281">  if (name == '/' || name == '=') {</a>
<a name="ln5282">    char_u  *s = strings[0];</a>
<a name="ln5283">    if (strings[0] == NULL) {</a>
<a name="ln5284">      s = (char_u *)&quot;&quot;;</a>
<a name="ln5285">    } else if (strings[1] != NULL) {</a>
<a name="ln5286">      EMSG(_(&quot;E883: search pattern and expression register may not &quot;</a>
<a name="ln5287">             &quot;contain two or more lines&quot;));</a>
<a name="ln5288">      return;</a>
<a name="ln5289">    }</a>
<a name="ln5290">    write_reg_contents_ex(name, s, -1, must_append, yank_type, block_len);</a>
<a name="ln5291">    return;</a>
<a name="ln5292">  }</a>
<a name="ln5293"> </a>
<a name="ln5294">  // black hole: nothing to do</a>
<a name="ln5295">  if (name == '_') {</a>
<a name="ln5296">    return;</a>
<a name="ln5297">  }</a>
<a name="ln5298"> </a>
<a name="ln5299">  yankreg_T  *old_y_previous, *reg;</a>
<a name="ln5300">  if (!(reg = init_write_reg(name, &amp;old_y_previous, must_append))) {</a>
<a name="ln5301">    return;</a>
<a name="ln5302">  }</a>
<a name="ln5303"> </a>
<a name="ln5304">  str_to_reg(reg, yank_type, (char_u *)strings, STRLEN((char_u *)strings),</a>
<a name="ln5305">             block_len, true);</a>
<a name="ln5306">  finish_write_reg(name, reg, old_y_previous);</a>
<a name="ln5307">}</a>
<a name="ln5308"> </a>
<a name="ln5309">/// write_reg_contents_ex - store `str` in register `name`</a>
<a name="ln5310">///</a>
<a name="ln5311">/// If `str` ends in '\n' or '\r', use linewise, otherwise use charwise.</a>
<a name="ln5312">///</a>
<a name="ln5313">/// @warning when `name` is '/', `len` and `must_append` are ignored. This</a>
<a name="ln5314">///          means that `str` MUST be NUL-terminated.</a>
<a name="ln5315">///</a>
<a name="ln5316">/// @param name The name of the register</a>
<a name="ln5317">/// @param str The contents to write</a>
<a name="ln5318">/// @param len If &gt;= 0, write `len` bytes of `str`. Otherwise, write</a>
<a name="ln5319">///               `strlen(str)` bytes. If `len` is larger than the</a>
<a name="ln5320">///               allocated size of `src`, the behaviour is undefined.</a>
<a name="ln5321">/// @param must_append If true, append the contents of `str` to the current</a>
<a name="ln5322">///                    contents of the register. Note that regardless of</a>
<a name="ln5323">///                    `must_append`, this function will append when `name`</a>
<a name="ln5324">///                    is an uppercase letter.</a>
<a name="ln5325">/// @param yank_type The motion type (kMTUnknown to auto detect)</a>
<a name="ln5326">/// @param block_len width of visual block</a>
<a name="ln5327">void write_reg_contents_ex(int name,</a>
<a name="ln5328">                           const char_u *str,</a>
<a name="ln5329">                           ssize_t len,</a>
<a name="ln5330">                           bool must_append,</a>
<a name="ln5331">                           MotionType yank_type,</a>
<a name="ln5332">                           colnr_T block_len)</a>
<a name="ln5333">{</a>
<a name="ln5334">  if (len &lt; 0) {</a>
<a name="ln5335">    len = (ssize_t) STRLEN(str);</a>
<a name="ln5336">  }</a>
<a name="ln5337"> </a>
<a name="ln5338">  /* Special case: '/' search pattern */</a>
<a name="ln5339">  if (name == '/') {</a>
<a name="ln5340">    set_last_search_pat(str, RE_SEARCH, TRUE, TRUE);</a>
<a name="ln5341">    return;</a>
<a name="ln5342">  }</a>
<a name="ln5343"> </a>
<a name="ln5344">  if (name == '#') {</a>
<a name="ln5345">    buf_T *buf;</a>
<a name="ln5346"> </a>
<a name="ln5347">    if (ascii_isdigit(*str)) {</a>
<a name="ln5348">      int num = atoi((char *)str);</a>
<a name="ln5349"> </a>
<a name="ln5350">      buf = buflist_findnr(num);</a>
<a name="ln5351">      if (buf == NULL) {</a>
<a name="ln5352">        EMSGN(_(e_nobufnr), (long)num);</a>
<a name="ln5353">      }</a>
<a name="ln5354">    } else {</a>
<a name="ln5355">      buf = buflist_findnr(buflist_findpat(str, str + STRLEN(str),</a>
<a name="ln5356">                                           true, false, false));</a>
<a name="ln5357">    }</a>
<a name="ln5358">    if (buf == NULL) {</a>
<a name="ln5359">      return;</a>
<a name="ln5360">    }</a>
<a name="ln5361">    curwin-&gt;w_alt_fnum = buf-&gt;b_fnum;</a>
<a name="ln5362">    return;</a>
<a name="ln5363">  }</a>
<a name="ln5364"> </a>
<a name="ln5365">  if (name == '=') {</a>
<a name="ln5366">    size_t offset = 0;</a>
<a name="ln5367">    size_t totlen = (size_t) len;</a>
<a name="ln5368"> </a>
<a name="ln5369">    if (must_append &amp;&amp; expr_line) {</a>
<a name="ln5370">      // append has been specified and expr_line already exists, so we'll</a>
<a name="ln5371">      // append the new string to expr_line.</a>
<a name="ln5372">      size_t exprlen = STRLEN(expr_line);</a>
<a name="ln5373"> </a>
<a name="ln5374">      totlen += exprlen;</a>
<a name="ln5375">      offset = exprlen;</a>
<a name="ln5376">    }</a>
<a name="ln5377"> </a>
<a name="ln5378">    // modify the global expr_line, extend/shrink it if necessary (realloc).</a>
<a name="ln5379">    // Copy the input string into the adjusted memory at the specified</a>
<a name="ln5380">    // offset.</a>
<a name="ln5381">    expr_line = xrealloc(expr_line, totlen + 1);</a>
<a name="ln5382">    memcpy(expr_line + offset, str, (size_t)len);</a>
<a name="ln5383">    expr_line[totlen] = NUL;</a>
<a name="ln5384"> </a>
<a name="ln5385">    return;</a>
<a name="ln5386">  }</a>
<a name="ln5387"> </a>
<a name="ln5388">  if (name == '_') {        // black hole: nothing to do</a>
<a name="ln5389">    return;</a>
<a name="ln5390">  }</a>
<a name="ln5391"> </a>
<a name="ln5392">  yankreg_T  *old_y_previous, *reg;</a>
<a name="ln5393">  if (!(reg = init_write_reg(name, &amp;old_y_previous, must_append))) {</a>
<a name="ln5394">    return;</a>
<a name="ln5395">  }</a>
<a name="ln5396">  str_to_reg(reg, yank_type, str, (size_t)len, block_len, false);</a>
<a name="ln5397">  finish_write_reg(name, reg, old_y_previous);</a>
<a name="ln5398">}</a>
<a name="ln5399"> </a>
<a name="ln5400">/// str_to_reg - Put a string into a register.</a>
<a name="ln5401">///</a>
<a name="ln5402">/// When the register is not empty, the string is appended.</a>
<a name="ln5403">///</a>
<a name="ln5404">/// @param y_ptr pointer to yank register</a>
<a name="ln5405">/// @param yank_type The motion type (kMTUnknown to auto detect)</a>
<a name="ln5406">/// @param str string or list of strings to put in register</a>
<a name="ln5407">/// @param len length of the string (Ignored when str_list=true.)</a>
<a name="ln5408">/// @param blocklen width of visual block, or -1 for &quot;I don't know.&quot;</a>
<a name="ln5409">/// @param str_list True if str is `char_u **`.</a>
<a name="ln5410">static void str_to_reg(yankreg_T *y_ptr, MotionType yank_type,</a>
<a name="ln5411">                       const char_u *str, size_t len, colnr_T blocklen,</a>
<a name="ln5412">                       bool str_list)</a>
<a name="ln5413">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5414">{</a>
<a name="ln5415">  if (y_ptr-&gt;y_array == NULL) {  // NULL means empty register</a>
<a name="ln5416">    y_ptr-&gt;y_size = 0;</a>
<a name="ln5417">  }</a>
<a name="ln5418"> </a>
<a name="ln5419">  if (yank_type == kMTUnknown) {</a>
<a name="ln5420">    yank_type = ((str_list</a>
<a name="ln5421">                  || (len &gt; 0 &amp;&amp; (str[len - 1] == NL || str[len - 1] == CAR)))</a>
<a name="ln5422">                 ? kMTLineWise : kMTCharWise);</a>
<a name="ln5423">  }</a>
<a name="ln5424"> </a>
<a name="ln5425">  size_t newlines = 0;</a>
<a name="ln5426">  bool extraline = false;  // extra line at the end</a>
<a name="ln5427">  bool append = false;     // append to last line in register</a>
<a name="ln5428"> </a>
<a name="ln5429">  // Count the number of lines within the string</a>
<a name="ln5430">  if (str_list) {</a>
<a name="ln5431">    for (char_u **ss = (char_u **) str; *ss != NULL; ++ss) {</a>
<a name="ln5432">      newlines++;</a>
<a name="ln5433">    }</a>
<a name="ln5434">  } else {</a>
<a name="ln5435">    newlines = memcnt(str, '\n', len);</a>
<a name="ln5436">    if (yank_type == kMTCharWise || len == 0 || str[len - 1] != '\n') {</a>
<a name="ln5437">      extraline = 1;</a>
<a name="ln5438">      ++newlines;         // count extra newline at the end</a>
<a name="ln5439">    }</a>
<a name="ln5440">    if (y_ptr-&gt;y_size &gt; 0 &amp;&amp; y_ptr-&gt;y_type == kMTCharWise) {</a>
<a name="ln5441">      append = true;</a>
<a name="ln5442">      --newlines;         // uncount newline when appending first line</a>
<a name="ln5443">    }</a>
<a name="ln5444">  }</a>
<a name="ln5445"> </a>
<a name="ln5446"> </a>
<a name="ln5447">  // Grow the register array to hold the pointers to the new lines.</a>
<a name="ln5448">  char_u **pp = xrealloc(y_ptr-&gt;y_array,</a>
<a name="ln5449">                         (y_ptr-&gt;y_size + newlines) * sizeof(char_u *));</a>
<a name="ln5450">  y_ptr-&gt;y_array = pp;</a>
<a name="ln5451"> </a>
<a name="ln5452">  size_t lnum = y_ptr-&gt;y_size;  // The current line number.</a>
<a name="ln5453"> </a>
<a name="ln5454">  // If called with `blocklen &lt; 0`, we have to update the yank reg's width.</a>
<a name="ln5455">  size_t maxlen = 0;</a>
<a name="ln5456"> </a>
<a name="ln5457">  // Find the end of each line and save it into the array.</a>
<a name="ln5458">  if (str_list) {</a>
<a name="ln5459">    for (char_u **ss = (char_u **) str; *ss != NULL; ++ss, ++lnum) {</a>
<a name="ln5460">      size_t ss_len = STRLEN(*ss);</a>
<a name="ln5461">      pp[lnum] = xmemdupz(*ss, ss_len);</a>
<a name="ln5462">      if (ss_len &gt; maxlen) {</a>
<a name="ln5463">        maxlen = ss_len;</a>
<a name="ln5464">      }</a>
<a name="ln5465">    }</a>
<a name="ln5466">  } else {</a>
<a name="ln5467">    size_t line_len;</a>
<a name="ln5468">    for (const char_u *start = str, *end = str + len;</a>
<a name="ln5469">         start &lt; end + extraline;</a>
<a name="ln5470">         start += line_len + 1, lnum++) {</a>
<a name="ln5471">      assert(end - start &gt;= 0);</a>
<a name="ln5472">      line_len = (size_t)((char_u *)xmemscan(start, '\n',</a>
<a name="ln5473">                                             (size_t)(end - start)) - start);</a>
<a name="ln5474">      if (line_len &gt; maxlen) {</a>
<a name="ln5475">        maxlen = line_len;</a>
<a name="ln5476">      }</a>
<a name="ln5477"> </a>
<a name="ln5478">      // When appending, copy the previous line and free it after.</a>
<a name="ln5479">      size_t extra = append ? STRLEN(pp[--lnum]) : 0;</a>
<a name="ln5480">      char_u *s = xmallocz(line_len + extra);</a>
<a name="ln5481">      memcpy(s, pp[lnum], extra);</a>
<a name="ln5482">      memcpy(s + extra, start, line_len);</a>
<a name="ln5483">      size_t s_len = extra + line_len;</a>
<a name="ln5484"> </a>
<a name="ln5485">      if (append) {</a>
<a name="ln5486">        xfree(pp[lnum]);</a>
<a name="ln5487">        append = false;  // only first line is appended</a>
<a name="ln5488">      }</a>
<a name="ln5489">      pp[lnum] = s;</a>
<a name="ln5490"> </a>
<a name="ln5491">      // Convert NULs to '\n' to prevent truncation.</a>
<a name="ln5492">      memchrsub(pp[lnum], NUL, '\n', s_len);</a>
<a name="ln5493">    }</a>
<a name="ln5494">  }</a>
<a name="ln5495">  y_ptr-&gt;y_type = yank_type;</a>
<a name="ln5496">  y_ptr-&gt;y_size = lnum;</a>
<a name="ln5497">  set_yreg_additional_data(y_ptr, NULL);</a>
<a name="ln5498">  y_ptr-&gt;timestamp = os_time();</a>
<a name="ln5499">  if (yank_type == kMTBlockWise) {</a>
<a name="ln5500">    y_ptr-&gt;y_width = (blocklen == -1 ? (colnr_T) maxlen - 1 : blocklen);</a>
<a name="ln5501">  } else {</a>
<a name="ln5502">    y_ptr-&gt;y_width = 0;</a>
<a name="ln5503">  }</a>
<a name="ln5504">}</a>
<a name="ln5505"> </a>
<a name="ln5506">void clear_oparg(oparg_T *oap)</a>
<a name="ln5507">{</a>
<a name="ln5508">  memset(oap, 0, sizeof(oparg_T));</a>
<a name="ln5509">}</a>
<a name="ln5510"> </a>
<a name="ln5511"> </a>
<a name="ln5512">/*</a>
<a name="ln5513"> *  Count the number of bytes, characters and &quot;words&quot; in a line.</a>
<a name="ln5514"> *</a>
<a name="ln5515"> *  &quot;Words&quot; are counted by looking for boundaries between non-space and</a>
<a name="ln5516"> *  space characters.  (it seems to produce results that match 'wc'.)</a>
<a name="ln5517"> *</a>
<a name="ln5518"> *  Return value is byte count; word count for the line is added to &quot;*wc&quot;.</a>
<a name="ln5519"> *  Char count is added to &quot;*cc&quot;.</a>
<a name="ln5520"> *</a>
<a name="ln5521"> *  The function will only examine the first &quot;limit&quot; characters in the</a>
<a name="ln5522"> *  line, stopping if it encounters an end-of-line (NUL byte).  In that</a>
<a name="ln5523"> *  case, eol_size will be added to the character count to account for</a>
<a name="ln5524"> *  the size of the EOL character.</a>
<a name="ln5525"> */</a>
<a name="ln5526">static varnumber_T line_count_info(char_u *line, varnumber_T *wc,</a>
<a name="ln5527">                                   varnumber_T *cc, varnumber_T limit,</a>
<a name="ln5528">                                   int eol_size)</a>
<a name="ln5529">{</a>
<a name="ln5530">  varnumber_T i;</a>
<a name="ln5531">  varnumber_T words = 0;</a>
<a name="ln5532">  varnumber_T chars = 0;</a>
<a name="ln5533">  int is_word = 0;</a>
<a name="ln5534"> </a>
<a name="ln5535">  for (i = 0; i &lt; limit &amp;&amp; line[i] != NUL; ) {</a>
<a name="ln5536">    if (is_word) {</a>
<a name="ln5537">      if (ascii_isspace(line[i])) {</a>
<a name="ln5538">        words++;</a>
<a name="ln5539">        is_word = 0;</a>
<a name="ln5540">      }</a>
<a name="ln5541">    } else if (!ascii_isspace(line[i]))</a>
<a name="ln5542">      is_word = 1;</a>
<a name="ln5543">    ++chars;</a>
<a name="ln5544">    i += (*mb_ptr2len)(line + i);</a>
<a name="ln5545">  }</a>
<a name="ln5546"> </a>
<a name="ln5547">  if (is_word)</a>
<a name="ln5548">    words++;</a>
<a name="ln5549">  *wc += words;</a>
<a name="ln5550"> </a>
<a name="ln5551">  /* Add eol_size if the end of line was reached before hitting limit. */</a>
<a name="ln5552">  if (i &lt; limit &amp;&amp; line[i] == NUL) {</a>
<a name="ln5553">    i += eol_size;</a>
<a name="ln5554">    chars += eol_size;</a>
<a name="ln5555">  }</a>
<a name="ln5556">  *cc += chars;</a>
<a name="ln5557">  return i;</a>
<a name="ln5558">}</a>
<a name="ln5559"> </a>
<a name="ln5560">/// Give some info about the position of the cursor (for &quot;g CTRL-G&quot;).</a>
<a name="ln5561">/// In Visual mode, give some info about the selected region.  (In this case,</a>
<a name="ln5562">/// the *_count_cursor variables store running totals for the selection.)</a>
<a name="ln5563">/// When &quot;dict&quot; is not NULL store the info there instead of showing it.</a>
<a name="ln5564">void cursor_pos_info(dict_T *dict)</a>
<a name="ln5565">{</a>
<a name="ln5566">  char_u      *p;</a>
<a name="ln5567">  char_u buf1[50];</a>
<a name="ln5568">  char_u buf2[40];</a>
<a name="ln5569">  linenr_T lnum;</a>
<a name="ln5570">  varnumber_T byte_count = 0;</a>
<a name="ln5571">  varnumber_T bom_count = 0;</a>
<a name="ln5572">  varnumber_T byte_count_cursor = 0;</a>
<a name="ln5573">  varnumber_T char_count = 0;</a>
<a name="ln5574">  varnumber_T char_count_cursor = 0;</a>
<a name="ln5575">  varnumber_T word_count = 0;</a>
<a name="ln5576">  varnumber_T word_count_cursor = 0;</a>
<a name="ln5577">  int eol_size;</a>
<a name="ln5578">  varnumber_T last_check = 100000L;</a>
<a name="ln5579">  long line_count_selected = 0;</a>
<a name="ln5580">  pos_T min_pos, max_pos;</a>
<a name="ln5581">  oparg_T oparg;</a>
<a name="ln5582">  struct block_def bd;</a>
<a name="ln5583">  const int l_VIsual_active = VIsual_active;</a>
<a name="ln5584">  const int l_VIsual_mode = VIsual_mode;</a>
<a name="ln5585"> </a>
<a name="ln5586">  // Compute the length of the file in characters.</a>
<a name="ln5587">  if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {</a>
<a name="ln5588">    if (dict == NULL) {</a>
<a name="ln5589">      MSG(_(no_lines_msg));</a>
<a name="ln5590">      return;</a>
<a name="ln5591">    }</a>
<a name="ln5592">  } else {</a>
<a name="ln5593">    if (get_fileformat(curbuf) == EOL_DOS)</a>
<a name="ln5594">      eol_size = 2;</a>
<a name="ln5595">    else</a>
<a name="ln5596">      eol_size = 1;</a>
<a name="ln5597"> </a>
<a name="ln5598">    if (l_VIsual_active) {</a>
<a name="ln5599">      if (lt(VIsual, curwin-&gt;w_cursor)) {</a>
<a name="ln5600">        min_pos = VIsual;</a>
<a name="ln5601">        max_pos = curwin-&gt;w_cursor;</a>
<a name="ln5602">      } else {</a>
<a name="ln5603">        min_pos = curwin-&gt;w_cursor;</a>
<a name="ln5604">        max_pos = VIsual;</a>
<a name="ln5605">      }</a>
<a name="ln5606">      if (*p_sel == 'e' &amp;&amp; max_pos.col &gt; 0)</a>
<a name="ln5607">        --max_pos.col;</a>
<a name="ln5608"> </a>
<a name="ln5609">      if (l_VIsual_mode == Ctrl_V) {</a>
<a name="ln5610">        char_u * saved_sbr = p_sbr;</a>
<a name="ln5611"> </a>
<a name="ln5612">        /* Make 'sbr' empty for a moment to get the correct size. */</a>
<a name="ln5613">        p_sbr = empty_option;</a>
<a name="ln5614">        oparg.is_VIsual = true;</a>
<a name="ln5615">        oparg.motion_type = kMTBlockWise;</a>
<a name="ln5616">        oparg.op_type = OP_NOP;</a>
<a name="ln5617">        getvcols(curwin, &amp;min_pos, &amp;max_pos,</a>
<a name="ln5618">            &amp;oparg.start_vcol, &amp;oparg.end_vcol);</a>
<a name="ln5619">        p_sbr = saved_sbr;</a>
<a name="ln5620">        if (curwin-&gt;w_curswant == MAXCOL)</a>
<a name="ln5621">          oparg.end_vcol = MAXCOL;</a>
<a name="ln5622">        /* Swap the start, end vcol if needed */</a>
<a name="ln5623">        if (oparg.end_vcol &lt; oparg.start_vcol) {</a>
<a name="ln5624">          oparg.end_vcol += oparg.start_vcol;</a>
<a name="ln5625">          oparg.start_vcol = oparg.end_vcol - oparg.start_vcol;</a>
<a name="ln5626">          oparg.end_vcol -= oparg.start_vcol;</a>
<a name="ln5627">        }</a>
<a name="ln5628">      }</a>
<a name="ln5629">      line_count_selected = max_pos.lnum - min_pos.lnum + 1;</a>
<a name="ln5630">    }</a>
<a name="ln5631"> </a>
<a name="ln5632">    for (lnum = 1; lnum &lt;= curbuf-&gt;b_ml.ml_line_count; ++lnum) {</a>
<a name="ln5633">      /* Check for a CTRL-C every 100000 characters. */</a>
<a name="ln5634">      if (byte_count &gt; last_check) {</a>
<a name="ln5635">        os_breakcheck();</a>
<a name="ln5636">        if (got_int)</a>
<a name="ln5637">          return;</a>
<a name="ln5638">        last_check = byte_count + 100000L;</a>
<a name="ln5639">      }</a>
<a name="ln5640"> </a>
<a name="ln5641">      /* Do extra processing for VIsual mode. */</a>
<a name="ln5642">      if (l_VIsual_active</a>
<a name="ln5643">          &amp;&amp; lnum &gt;= min_pos.lnum &amp;&amp; lnum &lt;= max_pos.lnum) {</a>
<a name="ln5644">        char_u      *s = NULL;</a>
<a name="ln5645">        long len = 0L;</a>
<a name="ln5646"> </a>
<a name="ln5647">        switch (l_VIsual_mode) {</a>
<a name="ln5648">        case Ctrl_V:</a>
<a name="ln5649">          virtual_op = virtual_active();</a>
<a name="ln5650">          block_prep(&amp;oparg, &amp;bd, lnum, false);</a>
<a name="ln5651">          virtual_op = kNone;</a>
<a name="ln5652">          s = bd.textstart;</a>
<a name="ln5653">          len = (long)bd.textlen;</a>
<a name="ln5654">          break;</a>
<a name="ln5655">        case 'V':</a>
<a name="ln5656">          s = ml_get(lnum);</a>
<a name="ln5657">          len = MAXCOL;</a>
<a name="ln5658">          break;</a>
<a name="ln5659">        case 'v':</a>
<a name="ln5660">        {</a>
<a name="ln5661">          colnr_T start_col = (lnum == min_pos.lnum)</a>
<a name="ln5662">                              ? min_pos.col : 0;</a>
<a name="ln5663">          colnr_T end_col = (lnum == max_pos.lnum)</a>
<a name="ln5664">                            ? max_pos.col - start_col + 1 : MAXCOL;</a>
<a name="ln5665"> </a>
<a name="ln5666">          s = ml_get(lnum) + start_col;</a>
<a name="ln5667">          len = end_col;</a>
<a name="ln5668">        }</a>
<a name="ln5669">        break;</a>
<a name="ln5670">        }</a>
<a name="ln5671">        if (s != NULL) {</a>
<a name="ln5672">          byte_count_cursor += line_count_info(s, &amp;word_count_cursor,</a>
<a name="ln5673">              &amp;char_count_cursor, len, eol_size);</a>
<a name="ln5674">          if (lnum == curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln5675">              &amp;&amp; !curbuf-&gt;b_p_eol</a>
<a name="ln5676">              &amp;&amp; (curbuf-&gt;b_p_bin || !curbuf-&gt;b_p_fixeol)</a>
<a name="ln5677">              &amp;&amp; (long)STRLEN(s) &lt; len)</a>
<a name="ln5678">            byte_count_cursor -= eol_size;</a>
<a name="ln5679">        }</a>
<a name="ln5680">      } else {</a>
<a name="ln5681">        /* In non-visual mode, check for the line the cursor is on */</a>
<a name="ln5682">        if (lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln5683">          word_count_cursor += word_count;</a>
<a name="ln5684">          char_count_cursor += char_count;</a>
<a name="ln5685">          byte_count_cursor = byte_count</a>
<a name="ln5686">            + line_count_info(ml_get(lnum), &amp;word_count_cursor,</a>
<a name="ln5687">                              &amp;char_count_cursor,</a>
<a name="ln5688">                              (varnumber_T)curwin-&gt;w_cursor.col + 1,</a>
<a name="ln5689">                              eol_size);</a>
<a name="ln5690">        }</a>
<a name="ln5691">      }</a>
<a name="ln5692">      // Add to the running totals</a>
<a name="ln5693">      byte_count += line_count_info(ml_get(lnum), &amp;word_count, &amp;char_count,</a>
<a name="ln5694">                                    (varnumber_T)MAXCOL, eol_size);</a>
<a name="ln5695">    }</a>
<a name="ln5696"> </a>
<a name="ln5697">    // Correction for when last line doesn't have an EOL.</a>
<a name="ln5698">    if (!curbuf-&gt;b_p_eol &amp;&amp; (curbuf-&gt;b_p_bin || !curbuf-&gt;b_p_fixeol)) {</a>
<a name="ln5699">      byte_count -= eol_size;</a>
<a name="ln5700">    }</a>
<a name="ln5701"> </a>
<a name="ln5702">    if (dict == NULL) {</a>
<a name="ln5703">      if (l_VIsual_active) {</a>
<a name="ln5704">        if (l_VIsual_mode == Ctrl_V &amp;&amp; curwin-&gt;w_curswant &lt; MAXCOL) {</a>
<a name="ln5705">          getvcols(curwin, &amp;min_pos, &amp;max_pos, &amp;min_pos.col, &amp;max_pos.col);</a>
<a name="ln5706">          int64_t cols;</a>
<a name="ln5707">          STRICT_SUB(oparg.end_vcol + 1, oparg.start_vcol, &amp;cols, int64_t);</a>
<a name="ln5708">          vim_snprintf((char *)buf1, sizeof(buf1), _(&quot;%&quot; PRId64 &quot; Cols; &quot;),</a>
<a name="ln5709">                       cols);</a>
<a name="ln5710">        } else {</a>
<a name="ln5711">          buf1[0] = NUL;</a>
<a name="ln5712">        }</a>
<a name="ln5713"> </a>
<a name="ln5714">        if (char_count_cursor == byte_count_cursor</a>
<a name="ln5715">            &amp;&amp; char_count == byte_count) {</a>
<a name="ln5716">          vim_snprintf((char *)IObuff, IOSIZE,</a>
<a name="ln5717">                       _(&quot;Selected %s%&quot; PRId64 &quot; of %&quot; PRId64 &quot; Lines;&quot;</a>
<a name="ln5718">                         &quot; %&quot; PRId64 &quot; of %&quot; PRId64 &quot; Words;&quot;</a>
<a name="ln5719">                         &quot; %&quot; PRId64 &quot; of %&quot; PRId64 &quot; Bytes&quot;),</a>
<a name="ln5720">                       buf1, (int64_t)line_count_selected,</a>
<a name="ln5721">                       (int64_t)curbuf-&gt;b_ml.ml_line_count,</a>
<a name="ln5722">                       (int64_t)word_count_cursor, (int64_t)word_count,</a>
<a name="ln5723">                       (int64_t)byte_count_cursor, (int64_t)byte_count);</a>
<a name="ln5724">        } else {</a>
<a name="ln5725">          vim_snprintf((char *)IObuff, IOSIZE,</a>
<a name="ln5726">                       _(&quot;Selected %s%&quot; PRId64 &quot; of %&quot; PRId64 &quot; Lines;&quot;</a>
<a name="ln5727">                         &quot; %&quot; PRId64 &quot; of %&quot; PRId64 &quot; Words;&quot;</a>
<a name="ln5728">                         &quot; %&quot; PRId64 &quot; of %&quot; PRId64 &quot; Chars;&quot;</a>
<a name="ln5729">                         &quot; %&quot; PRId64 &quot; of %&quot; PRId64 &quot; Bytes&quot;),</a>
<a name="ln5730">                       buf1, (int64_t)line_count_selected,</a>
<a name="ln5731">                       (int64_t)curbuf-&gt;b_ml.ml_line_count,</a>
<a name="ln5732">                       (int64_t)word_count_cursor, (int64_t)word_count,</a>
<a name="ln5733">                       (int64_t)char_count_cursor, (int64_t)char_count,</a>
<a name="ln5734">                       (int64_t)byte_count_cursor, (int64_t)byte_count);</a>
<a name="ln5735">        }</a>
<a name="ln5736">      } else {</a>
<a name="ln5737">        p = get_cursor_line_ptr();</a>
<a name="ln5738">        validate_virtcol();</a>
<a name="ln5739">        col_print(buf1, sizeof(buf1), (int)curwin-&gt;w_cursor.col + 1,</a>
<a name="ln5740">                  (int)curwin-&gt;w_virtcol + 1);</a>
<a name="ln5741">        col_print(buf2, sizeof(buf2), (int)STRLEN(p), linetabsize(p));</a>
<a name="ln5742"> </a>
<a name="ln5743">        if (char_count_cursor == byte_count_cursor</a>
<a name="ln5744">            &amp;&amp; char_count == byte_count) {</a>
<a name="ln5745">          vim_snprintf((char *)IObuff, IOSIZE,</a>
<a name="ln5746">                       _(&quot;Col %s of %s; Line %&quot; PRId64 &quot; of %&quot; PRId64 &quot;;&quot;</a>
<a name="ln5747">                         &quot; Word %&quot; PRId64 &quot; of %&quot; PRId64 &quot;;&quot;</a>
<a name="ln5748">                         &quot; Byte %&quot; PRId64 &quot; of %&quot; PRId64 &quot;&quot;),</a>
<a name="ln5749">                       (char *)buf1, (char *)buf2,</a>
<a name="ln5750">                       (int64_t)curwin-&gt;w_cursor.lnum,</a>
<a name="ln5751">                       (int64_t)curbuf-&gt;b_ml.ml_line_count,</a>
<a name="ln5752">                       (int64_t)word_count_cursor, (int64_t)word_count,</a>
<a name="ln5753">                       (int64_t)byte_count_cursor, (int64_t)byte_count);</a>
<a name="ln5754">        } else {</a>
<a name="ln5755">          vim_snprintf((char *)IObuff, IOSIZE,</a>
<a name="ln5756">                       _(&quot;Col %s of %s; Line %&quot; PRId64 &quot; of %&quot; PRId64 &quot;;&quot;</a>
<a name="ln5757">                         &quot; Word %&quot; PRId64 &quot; of %&quot; PRId64 &quot;;&quot;</a>
<a name="ln5758">                         &quot; Char %&quot; PRId64 &quot; of %&quot; PRId64 &quot;;&quot;</a>
<a name="ln5759">                         &quot; Byte %&quot; PRId64 &quot; of %&quot; PRId64 &quot;&quot;),</a>
<a name="ln5760">                       (char *)buf1, (char *)buf2,</a>
<a name="ln5761">                       (int64_t)curwin-&gt;w_cursor.lnum,</a>
<a name="ln5762">                       (int64_t)curbuf-&gt;b_ml.ml_line_count,</a>
<a name="ln5763">                       (int64_t)word_count_cursor, (int64_t)word_count,</a>
<a name="ln5764">                       (int64_t)char_count_cursor, (int64_t)char_count,</a>
<a name="ln5765">                       (int64_t)byte_count_cursor, (int64_t)byte_count);</a>
<a name="ln5766">        }</a>
<a name="ln5767">      }</a>
<a name="ln5768">    }</a>
<a name="ln5769"> </a>
<a name="ln5770">    bom_count = bomb_size();</a>
<a name="ln5771">    if (dict == NULL &amp;&amp; bom_count &gt; 0) {</a>
<a name="ln5772">      const size_t len = STRLEN(IObuff);</a>
<a name="ln5773">      vim_snprintf((char *)IObuff + len, IOSIZE - len,</a>
<a name="ln5774">                   _(&quot;(+%&quot; PRId64 &quot; for BOM)&quot;), (int64_t)bom_count);</a>
<a name="ln5775">    }</a>
<a name="ln5776">    if (dict == NULL) {</a>
<a name="ln5777">      // Don't shorten this message, the user asked for it.</a>
<a name="ln5778">      p = p_shm;</a>
<a name="ln5779">      p_shm = (char_u *)&quot;&quot;;</a>
<a name="ln5780">      msg(IObuff);</a>
<a name="ln5781">      p_shm = p;</a>
<a name="ln5782">    }</a>
<a name="ln5783">  }</a>
<a name="ln5784"> </a>
<a name="ln5785">  if (dict != NULL) {</a>
<a name="ln5786">    // Don't shorten this message, the user asked for it.</a>
<a name="ln5787">    tv_dict_add_nr(dict, S_LEN(&quot;words&quot;), (varnumber_T)word_count);</a>
<a name="ln5788">    tv_dict_add_nr(dict, S_LEN(&quot;chars&quot;), (varnumber_T)char_count);</a>
<a name="ln5789">    tv_dict_add_nr(dict, S_LEN(&quot;bytes&quot;), (varnumber_T)(byte_count + bom_count));</a>
<a name="ln5790"> </a>
<a name="ln5791">    STATIC_ASSERT(sizeof(&quot;visual&quot;) == sizeof(&quot;cursor&quot;),</a>
<a name="ln5792">                  &quot;key_len argument in tv_dict_add_nr is wrong&quot;);</a>
<a name="ln5793">    tv_dict_add_nr(dict, l_VIsual_active ? &quot;visual_bytes&quot; : &quot;cursor_bytes&quot;,</a>
<a name="ln5794">                   sizeof(&quot;visual_bytes&quot;) - 1, (varnumber_T)byte_count_cursor);</a>
<a name="ln5795">    tv_dict_add_nr(dict, l_VIsual_active ? &quot;visual_chars&quot; : &quot;cursor_chars&quot;,</a>
<a name="ln5796">                   sizeof(&quot;visual_chars&quot;) - 1, (varnumber_T)char_count_cursor);</a>
<a name="ln5797">    tv_dict_add_nr(dict, l_VIsual_active ? &quot;visual_words&quot; : &quot;cursor_words&quot;,</a>
<a name="ln5798">                   sizeof(&quot;visual_words&quot;) - 1, (varnumber_T)word_count_cursor);</a>
<a name="ln5799">  }</a>
<a name="ln5800">}</a>
<a name="ln5801"> </a>
<a name="ln5802">/// Check if the default register (used in an unnamed paste) should be a</a>
<a name="ln5803">/// clipboard register. This happens when `clipboard=unnamed[plus]` is set</a>
<a name="ln5804">/// and a provider is available.</a>
<a name="ln5805">///</a>
<a name="ln5806">/// @returns the name of of a clipboard register that should be used, or `NUL` if none.</a>
<a name="ln5807">int get_default_register_name(void)</a>
<a name="ln5808">{</a>
<a name="ln5809">  int name = NUL;</a>
<a name="ln5810">  adjust_clipboard_name(&amp;name, true, false);</a>
<a name="ln5811">  return name;</a>
<a name="ln5812">}</a>
<a name="ln5813"> </a>
<a name="ln5814">/// Determine if register `*name` should be used as a clipboard.</a>
<a name="ln5815">/// In an unnamed operation, `*name` is `NUL` and will be adjusted to */+ if</a>
<a name="ln5816">/// `clipboard=unnamed[plus]` is set.</a>
<a name="ln5817">///</a>
<a name="ln5818">/// @param name The name of register, or `NUL` if unnamed.</a>
<a name="ln5819">/// @param quiet Suppress error messages</a>
<a name="ln5820">/// @param writing if we're setting the contents of the clipboard</a>
<a name="ln5821">///</a>
<a name="ln5822">/// @returns the yankreg that should be written into, or `NULL`</a>
<a name="ln5823">/// if the register isn't a clipboard or provider isn't available.</a>
<a name="ln5824">static yankreg_T *adjust_clipboard_name(int *name, bool quiet, bool writing)</a>
<a name="ln5825">{</a>
<a name="ln5826">#define MSG_NO_CLIP &quot;clipboard: No provider. &quot; \</a>
<a name="ln5827">  &quot;Try \&quot;:checkhealth\&quot; or \&quot;:h clipboard\&quot;.&quot;</a>
<a name="ln5828"> </a>
<a name="ln5829">  yankreg_T *target = NULL;</a>
<a name="ln5830">  bool explicit_cb_reg = (*name == '*' || *name == '+');</a>
<a name="ln5831">  bool implicit_cb_reg = (*name == NUL) &amp;&amp; (cb_flags &amp; CB_UNNAMEDMASK);</a>
<a name="ln5832">  if (!explicit_cb_reg &amp;&amp; !implicit_cb_reg) {</a>
<a name="ln5833">    goto end;</a>
<a name="ln5834">  }</a>
<a name="ln5835"> </a>
<a name="ln5836">  if (!eval_has_provider(&quot;clipboard&quot;)) {</a>
<a name="ln5837">    if (batch_change_count == 1 &amp;&amp; !quiet</a>
<a name="ln5838">        &amp;&amp; (!clipboard_didwarn || (explicit_cb_reg &amp;&amp; !redirecting()))) {</a>
<a name="ln5839">      clipboard_didwarn = true;</a>
<a name="ln5840">      // Do NOT error (emsg()) here--if it interrupts :redir we get into</a>
<a name="ln5841">      // a weird state, stuck in &quot;redirect mode&quot;.</a>
<a name="ln5842">      msg((char_u *)MSG_NO_CLIP);</a>
<a name="ln5843">    }</a>
<a name="ln5844">    // ... else, be silent (don't flood during :while, :redir, etc.).</a>
<a name="ln5845">    goto end;</a>
<a name="ln5846">  }</a>
<a name="ln5847"> </a>
<a name="ln5848">  if (explicit_cb_reg) {</a>
<a name="ln5849">    target = &amp;y_regs[*name == '*' ? STAR_REGISTER : PLUS_REGISTER];</a>
<a name="ln5850">    if (writing &amp;&amp; (cb_flags &amp; (*name == '*' ? CB_UNNAMED : CB_UNNAMEDPLUS))) {</a>
<a name="ln5851">      clipboard_needs_update = false;</a>
<a name="ln5852">    }</a>
<a name="ln5853">    goto end;</a>
<a name="ln5854">  } else {  // unnamed register: &quot;implicit&quot; clipboard</a>
<a name="ln5855">    if (writing &amp;&amp; clipboard_delay_update) {</a>
<a name="ln5856">      // For &quot;set&quot; (copy), defer the clipboard call.</a>
<a name="ln5857">      clipboard_needs_update = true;</a>
<a name="ln5858">      goto end;</a>
<a name="ln5859">    } else if (!writing &amp;&amp; clipboard_needs_update) {</a>
<a name="ln5860">      // For &quot;get&quot; (paste), use the internal value.</a>
<a name="ln5861">      goto end;</a>
<a name="ln5862">    }</a>
<a name="ln5863"> </a>
<a name="ln5864">    if (cb_flags &amp; CB_UNNAMEDPLUS) {</a>
<a name="ln5865">      *name = (cb_flags &amp; CB_UNNAMED &amp;&amp; writing) ? '&quot;': '+';</a>
<a name="ln5866">      target = &amp;y_regs[PLUS_REGISTER];</a>
<a name="ln5867">    } else {</a>
<a name="ln5868">      *name = '*';</a>
<a name="ln5869">      target = &amp;y_regs[STAR_REGISTER];</a>
<a name="ln5870">    }</a>
<a name="ln5871">    goto end;</a>
<a name="ln5872">  }</a>
<a name="ln5873"> </a>
<a name="ln5874">end:</a>
<a name="ln5875">  return target;</a>
<a name="ln5876">}</a>
<a name="ln5877"> </a>
<a name="ln5878">/// @param[out] reg Expected to be empty</a>
<a name="ln5879">bool prepare_yankreg_from_object(yankreg_T *reg, String regtype, size_t lines)</a>
<a name="ln5880">{</a>
<a name="ln5881">  char type = regtype.data ? regtype.data[0] : NUL;</a>
<a name="ln5882"> </a>
<a name="ln5883">  switch (type) {</a>
<a name="ln5884">  case 0:</a>
<a name="ln5885">    reg-&gt;y_type = kMTUnknown;</a>
<a name="ln5886">    break;</a>
<a name="ln5887">  case 'v': case 'c':</a>
<a name="ln5888">    reg-&gt;y_type = kMTCharWise;</a>
<a name="ln5889">    break;</a>
<a name="ln5890">  case 'V': case 'l':</a>
<a name="ln5891">    reg-&gt;y_type = kMTLineWise;</a>
<a name="ln5892">    break;</a>
<a name="ln5893">  case 'b': case Ctrl_V:</a>
<a name="ln5894">    reg-&gt;y_type = kMTBlockWise;</a>
<a name="ln5895">    break;</a>
<a name="ln5896">  default:</a>
<a name="ln5897">    return false;</a>
<a name="ln5898">  }</a>
<a name="ln5899"> </a>
<a name="ln5900">  reg-&gt;y_width = 0;</a>
<a name="ln5901">  if (regtype.size &gt; 1) {</a>
<a name="ln5902">    if (reg-&gt;y_type != kMTBlockWise) {</a>
<a name="ln5903">      return false;</a>
<a name="ln5904">    }</a>
<a name="ln5905"> </a>
<a name="ln5906">    // allow &quot;b7&quot; for a block at least 7 spaces wide</a>
<a name="ln5907">    if (!ascii_isdigit(regtype.data[1])) {</a>
<a name="ln5908">      return false;</a>
<a name="ln5909">    }</a>
<a name="ln5910">    const char *p = regtype.data+1;</a>
<a name="ln5911">    reg-&gt;y_width = getdigits_int((char_u **)&amp;p, false, 1) - 1;</a>
<a name="ln5912">    if (regtype.size &gt; (size_t)(p-regtype.data)) {</a>
<a name="ln5913">      return false;</a>
<a name="ln5914">    }</a>
<a name="ln5915">  }</a>
<a name="ln5916"> </a>
<a name="ln5917">  reg-&gt;y_array = xcalloc(lines, sizeof(uint8_t *));</a>
<a name="ln5918">  reg-&gt;y_size = lines;</a>
<a name="ln5919">  reg-&gt;additional_data = NULL;</a>
<a name="ln5920">  reg-&gt;timestamp = 0;</a>
<a name="ln5921">  return true;</a>
<a name="ln5922">}</a>
<a name="ln5923"> </a>
<a name="ln5924">void finish_yankreg_from_object(yankreg_T *reg, bool clipboard_adjust)</a>
<a name="ln5925">{</a>
<a name="ln5926">  if (reg-&gt;y_size &gt; 0 &amp;&amp; strlen((char *)reg-&gt;y_array[reg-&gt;y_size-1]) == 0) {</a>
<a name="ln5927">    // a known-to-be charwise yank might have a final linebreak</a>
<a name="ln5928">    // but otherwise there is no line after the final newline</a>
<a name="ln5929">    if (reg-&gt;y_type != kMTCharWise) {</a>
<a name="ln5930">      if (reg-&gt;y_type == kMTUnknown || clipboard_adjust) {</a>
<a name="ln5931">        xfree(reg-&gt;y_array[reg-&gt;y_size-1]);</a>
<a name="ln5932">        reg-&gt;y_size--;</a>
<a name="ln5933">      }</a>
<a name="ln5934">      if (reg-&gt;y_type == kMTUnknown) {</a>
<a name="ln5935">        reg-&gt;y_type = kMTLineWise;</a>
<a name="ln5936">      }</a>
<a name="ln5937">    }</a>
<a name="ln5938">  } else {</a>
<a name="ln5939">    if (reg-&gt;y_type == kMTUnknown) {</a>
<a name="ln5940">      reg-&gt;y_type = kMTCharWise;</a>
<a name="ln5941">    }</a>
<a name="ln5942">  }</a>
<a name="ln5943"> </a>
<a name="ln5944">  if (reg-&gt;y_type == kMTBlockWise) {</a>
<a name="ln5945">    size_t maxlen = 0;</a>
<a name="ln5946">    for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln5947">      size_t rowlen = STRLEN(reg-&gt;y_array[i]);</a>
<a name="ln5948">      if (rowlen &gt; maxlen) {</a>
<a name="ln5949">        maxlen = rowlen;</a>
<a name="ln5950">      }</a>
<a name="ln5951">    }</a>
<a name="ln5952">    assert(maxlen &lt;= INT_MAX);</a>
<a name="ln5953">    reg-&gt;y_width = MAX(reg-&gt;y_width, (int)maxlen - 1);</a>
<a name="ln5954">  }</a>
<a name="ln5955">}</a>
<a name="ln5956"> </a>
<a name="ln5957">static bool get_clipboard(int name, yankreg_T **target, bool quiet)</a>
<a name="ln5958">{</a>
<a name="ln5959">  // show message on error</a>
<a name="ln5960">  bool errmsg = true;</a>
<a name="ln5961"> </a>
<a name="ln5962">  yankreg_T *reg = adjust_clipboard_name(&amp;name, quiet, false);</a>
<a name="ln5963">  if (reg == NULL) {</a>
<a name="ln5964">    return false;</a>
<a name="ln5965">  }</a>
<a name="ln5966">  free_register(reg);</a>
<a name="ln5967"> </a>
<a name="ln5968">  list_T *const args = tv_list_alloc(1);</a>
<a name="ln5969">  const char regname = (char)name;</a>
<a name="ln5970">  tv_list_append_string(args, &amp;regname, 1);</a>
<a name="ln5971"> </a>
<a name="ln5972">  typval_T result = eval_call_provider(&quot;clipboard&quot;, &quot;get&quot;, args, false);</a>
<a name="ln5973"> </a>
<a name="ln5974">  if (result.v_type != VAR_LIST) {</a>
<a name="ln5975">    if (result.v_type == VAR_NUMBER &amp;&amp; result.vval.v_number == 0) {</a>
<a name="ln5976">      // failure has already been indicated by provider</a>
<a name="ln5977">      errmsg = false;</a>
<a name="ln5978">    }</a>
<a name="ln5979">    goto err;</a>
<a name="ln5980">  }</a>
<a name="ln5981"> </a>
<a name="ln5982">  list_T *res = result.vval.v_list;</a>
<a name="ln5983">  list_T *lines = NULL;</a>
<a name="ln5984">  if (tv_list_len(res) == 2</a>
<a name="ln5985">      &amp;&amp; TV_LIST_ITEM_TV(tv_list_first(res))-&gt;v_type == VAR_LIST) {</a>
<a name="ln5986">    lines = TV_LIST_ITEM_TV(tv_list_first(res))-&gt;vval.v_list;</a>
<a name="ln5987">    if (TV_LIST_ITEM_TV(tv_list_last(res))-&gt;v_type != VAR_STRING) {</a>
<a name="ln5988">      goto err;</a>
<a name="ln5989">    }</a>
<a name="ln5990">    char_u *regtype = TV_LIST_ITEM_TV(tv_list_last(res))-&gt;vval.v_string;</a>
<a name="ln5991">    if (regtype == NULL || strlen((char *)regtype) &gt; 1) {</a>
<a name="ln5992">      goto err;</a>
<a name="ln5993">    }</a>
<a name="ln5994">    switch (regtype[0]) {</a>
<a name="ln5995">    case 0:</a>
<a name="ln5996">      reg-&gt;y_type = kMTUnknown;</a>
<a name="ln5997">      break;</a>
<a name="ln5998">    case 'v': case 'c':</a>
<a name="ln5999">      reg-&gt;y_type = kMTCharWise;</a>
<a name="ln6000">      break;</a>
<a name="ln6001">    case 'V': case 'l':</a>
<a name="ln6002">      reg-&gt;y_type = kMTLineWise;</a>
<a name="ln6003">      break;</a>
<a name="ln6004">    case 'b': case Ctrl_V:</a>
<a name="ln6005">      reg-&gt;y_type = kMTBlockWise;</a>
<a name="ln6006">      break;</a>
<a name="ln6007">    default:</a>
<a name="ln6008">      goto err;</a>
<a name="ln6009">    }</a>
<a name="ln6010">  } else {</a>
<a name="ln6011">    lines = res;</a>
<a name="ln6012">    // provider did not specify regtype, calculate it below</a>
<a name="ln6013">    reg-&gt;y_type = kMTUnknown;</a>
<a name="ln6014">  }</a>
<a name="ln6015"> </a>
<a name="ln6016">  reg-&gt;y_array = xcalloc((size_t)tv_list_len(lines), sizeof(char_u *));</a>
<a name="ln6017">  reg-&gt;y_size = (size_t)tv_list_len(lines);</a>
<a name="ln6018">  reg-&gt;additional_data = NULL;</a>
<a name="ln6019">  reg-&gt;timestamp = 0;</a>
<a name="ln6020">  // Timestamp is not saved for clipboard registers because clipboard registers</a>
<a name="ln6021">  // are not saved in the ShaDa file.</a>
<a name="ln6022"> </a>
<a name="ln6023">  size_t tv_idx = 0;</a>
<a name="ln6024">  TV_LIST_ITER_CONST(lines, li, {</a>
<a name="ln6025">    if (TV_LIST_ITEM_TV(li)-&gt;v_type != VAR_STRING) {</a>
<a name="ln6026">      goto err;</a>
<a name="ln6027">    }</a>
<a name="ln6028">    reg-&gt;y_array[tv_idx++] = (char_u *)xstrdupnul(</a>
<a name="ln6029">        (const char *)TV_LIST_ITEM_TV(li)-&gt;vval.v_string);</a>
<a name="ln6030">  });</a>
<a name="ln6031"> </a>
<a name="ln6032">  if (reg-&gt;y_size &gt; 0 &amp;&amp; strlen((char*)reg-&gt;y_array[reg-&gt;y_size-1]) == 0) {</a>
<a name="ln6033">    // a known-to-be charwise yank might have a final linebreak</a>
<a name="ln6034">    // but otherwise there is no line after the final newline</a>
<a name="ln6035">    if (reg-&gt;y_type != kMTCharWise) {</a>
<a name="ln6036">      xfree(reg-&gt;y_array[reg-&gt;y_size-1]);</a>
<a name="ln6037">      reg-&gt;y_size--;</a>
<a name="ln6038">      if (reg-&gt;y_type == kMTUnknown) {</a>
<a name="ln6039">        reg-&gt;y_type = kMTLineWise;</a>
<a name="ln6040">      }</a>
<a name="ln6041">    }</a>
<a name="ln6042">  } else {</a>
<a name="ln6043">    if (reg-&gt;y_type == kMTUnknown) {</a>
<a name="ln6044">      reg-&gt;y_type = kMTCharWise;</a>
<a name="ln6045">    }</a>
<a name="ln6046">  }</a>
<a name="ln6047"> </a>
<a name="ln6048">  if (reg-&gt;y_type == kMTBlockWise) {</a>
<a name="ln6049">    size_t maxlen = 0;</a>
<a name="ln6050">    for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln6051">      size_t rowlen = STRLEN(reg-&gt;y_array[i]);</a>
<a name="ln6052">      if (rowlen &gt; maxlen) {</a>
<a name="ln6053">        maxlen = rowlen;</a>
<a name="ln6054">      }</a>
<a name="ln6055">    }</a>
<a name="ln6056">    assert(maxlen &lt;= INT_MAX);</a>
<a name="ln6057">    reg-&gt;y_width = (int)maxlen - 1;</a>
<a name="ln6058">  }</a>
<a name="ln6059"> </a>
<a name="ln6060">  *target = reg;</a>
<a name="ln6061">  return true;</a>
<a name="ln6062"> </a>
<a name="ln6063">err:</a>
<a name="ln6064">  if (reg-&gt;y_array) {</a>
<a name="ln6065">    for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln6066">      xfree(reg-&gt;y_array[i]);</a>
<a name="ln6067">    }</a>
<a name="ln6068">    xfree(reg-&gt;y_array);</a>
<a name="ln6069">  }</a>
<a name="ln6070">  reg-&gt;y_array = NULL;</a>
<a name="ln6071">  reg-&gt;y_size = 0;</a>
<a name="ln6072">  reg-&gt;additional_data = NULL;</a>
<a name="ln6073">  reg-&gt;timestamp = 0;</a>
<a name="ln6074">  if (errmsg) {</a>
<a name="ln6075">    EMSG(&quot;clipboard: provider returned invalid data&quot;);</a>
<a name="ln6076">  }</a>
<a name="ln6077">  *target = reg;</a>
<a name="ln6078">  return false;</a>
<a name="ln6079">}</a>
<a name="ln6080"> </a>
<a name="ln6081">static void set_clipboard(int name, yankreg_T *reg)</a>
<a name="ln6082">{</a>
<a name="ln6083">  if (!adjust_clipboard_name(&amp;name, false, true)) {</a>
<a name="ln6084">    return;</a>
<a name="ln6085">  }</a>
<a name="ln6086"> </a>
<a name="ln6087">  list_T *const lines = tv_list_alloc(</a>
<a name="ln6088">      (ptrdiff_t)reg-&gt;y_size + (reg-&gt;y_type != kMTCharWise));</a>
<a name="ln6089"> </a>
<a name="ln6090">  for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln6091">    tv_list_append_string(lines, (const char *)reg-&gt;y_array[i], -1);</a>
<a name="ln6092">  }</a>
<a name="ln6093"> </a>
<a name="ln6094">  char regtype;</a>
<a name="ln6095">  switch (reg-&gt;y_type) {</a>
<a name="ln6096">    case kMTLineWise: {</a>
<a name="ln6097">      regtype = 'V';</a>
<a name="ln6098">      tv_list_append_string(lines, NULL, 0);</a>
<a name="ln6099">      break;</a>
<a name="ln6100">    }</a>
<a name="ln6101">    case kMTCharWise: {</a>
<a name="ln6102">      regtype = 'v';</a>
<a name="ln6103">      break;</a>
<a name="ln6104">    }</a>
<a name="ln6105">    case kMTBlockWise: {</a>
<a name="ln6106">      regtype = 'b';</a>
<a name="ln6107">      tv_list_append_string(lines, NULL, 0);</a>
<a name="ln6108">      break;</a>
<a name="ln6109">    }</a>
<a name="ln6110">    case kMTUnknown: {</a>
<a name="ln6111">      abort();</a>
<a name="ln6112">    }</a>
<a name="ln6113">  }</a>
<a name="ln6114"> </a>
<a name="ln6115">  list_T *args = tv_list_alloc(3);</a>
<a name="ln6116">  tv_list_append_list(args, lines);</a>
<a name="ln6117">  tv_list_append_string(args, &amp;regtype, 1);  // -V614</a>
<a name="ln6118">  tv_list_append_string(args, ((char[]) { (char)name }), 1);</a>
<a name="ln6119"> </a>
<a name="ln6120">  (void)eval_call_provider(&quot;clipboard&quot;, &quot;set&quot;, args, true);</a>
<a name="ln6121">}</a>
<a name="ln6122"> </a>
<a name="ln6123">/// Avoid slow things (clipboard) during batch operations (while/for-loops).</a>
<a name="ln6124">void start_batch_changes(void)</a>
<a name="ln6125">{</a>
<a name="ln6126">  if (++batch_change_count &gt; 1) {</a>
<a name="ln6127">    return;</a>
<a name="ln6128">  }</a>
<a name="ln6129">  clipboard_delay_update = true;</a>
<a name="ln6130">}</a>
<a name="ln6131"> </a>
<a name="ln6132">/// Counterpart to start_batch_changes().</a>
<a name="ln6133">void end_batch_changes(void)</a>
<a name="ln6134">{</a>
<a name="ln6135">  if (--batch_change_count &gt; 0) {</a>
<a name="ln6136">    // recursive</a>
<a name="ln6137">    return;</a>
<a name="ln6138">  }</a>
<a name="ln6139">  clipboard_delay_update = false;</a>
<a name="ln6140">  if (clipboard_needs_update) {</a>
<a name="ln6141">    // must be before, as set_clipboard will invoke</a>
<a name="ln6142">    // start/end_batch_changes recursively</a>
<a name="ln6143">    clipboard_needs_update = false;</a>
<a name="ln6144">    // unnamed (&quot;implicit&quot; clipboard)</a>
<a name="ln6145">    set_clipboard(NUL, y_previous);</a>
<a name="ln6146">  }</a>
<a name="ln6147">}</a>
<a name="ln6148"> </a>
<a name="ln6149">int save_batch_count(void)</a>
<a name="ln6150">{</a>
<a name="ln6151">  int save_count = batch_change_count;</a>
<a name="ln6152">  batch_change_count = 0;</a>
<a name="ln6153">  clipboard_delay_update = false;</a>
<a name="ln6154">  if (clipboard_needs_update) {</a>
<a name="ln6155">    clipboard_needs_update = false;</a>
<a name="ln6156">    // unnamed (&quot;implicit&quot; clipboard)</a>
<a name="ln6157">    set_clipboard(NUL, y_previous);</a>
<a name="ln6158">  }</a>
<a name="ln6159">  return save_count;</a>
<a name="ln6160">}</a>
<a name="ln6161"> </a>
<a name="ln6162">void restore_batch_count(int save_count)</a>
<a name="ln6163">{</a>
<a name="ln6164">  assert(batch_change_count == 0);</a>
<a name="ln6165">  batch_change_count = save_count;</a>
<a name="ln6166">  if (batch_change_count &gt; 0) {</a>
<a name="ln6167">    clipboard_delay_update = true;</a>
<a name="ln6168">  }</a>
<a name="ln6169">}</a>
<a name="ln6170"> </a>
<a name="ln6171"> </a>
<a name="ln6172">/// Check whether register is empty</a>
<a name="ln6173">static inline bool reg_empty(const yankreg_T *const reg)</a>
<a name="ln6174">  FUNC_ATTR_PURE</a>
<a name="ln6175">{</a>
<a name="ln6176">  return (reg-&gt;y_array == NULL</a>
<a name="ln6177">          || reg-&gt;y_size == 0</a>
<a name="ln6178">          || (reg-&gt;y_size == 1</a>
<a name="ln6179">              &amp;&amp; reg-&gt;y_type == kMTCharWise</a>
<a name="ln6180">              &amp;&amp; *(reg-&gt;y_array[0]) == NUL));</a>
<a name="ln6181">}</a>
<a name="ln6182"> </a>
<a name="ln6183">/// Iterate over global registers.</a>
<a name="ln6184">///</a>
<a name="ln6185">/// @see op_register_iter</a>
<a name="ln6186">const void *op_global_reg_iter(const void *const iter, char *const name,</a>
<a name="ln6187">                               yankreg_T *const reg, bool *is_unnamed)</a>
<a name="ln6188">  FUNC_ATTR_NONNULL_ARG(2, 3, 4) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6189">{</a>
<a name="ln6190">  return op_reg_iter(iter, y_regs, name, reg, is_unnamed);</a>
<a name="ln6191">}</a>
<a name="ln6192"> </a>
<a name="ln6193">/// Iterate over registers `regs`.</a>
<a name="ln6194">///</a>
<a name="ln6195">/// @param[in]   iter      Iterator. Pass NULL to start iteration.</a>
<a name="ln6196">/// @param[in]   regs      Registers list to be iterated.</a>
<a name="ln6197">/// @param[out]  name      Register name.</a>
<a name="ln6198">/// @param[out]  reg       Register contents.</a>
<a name="ln6199">///</a>
<a name="ln6200">/// @return Pointer that must be passed to next `op_register_iter` call or</a>
<a name="ln6201">///         NULL if iteration is over.</a>
<a name="ln6202">const void *op_reg_iter(const void *const iter, const yankreg_T *const regs,</a>
<a name="ln6203">                        char *const name, yankreg_T *const reg,</a>
<a name="ln6204">                        bool *is_unnamed)</a>
<a name="ln6205">  FUNC_ATTR_NONNULL_ARG(3, 4, 5) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6206">{</a>
<a name="ln6207">  *name = NUL;</a>
<a name="ln6208">  const yankreg_T *iter_reg = (iter == NULL</a>
<a name="ln6209">                               ? &amp;(regs[0])</a>
<a name="ln6210">                               : (const yankreg_T *const)iter);</a>
<a name="ln6211">  while (iter_reg - &amp;(regs[0]) &lt; NUM_SAVED_REGISTERS &amp;&amp; reg_empty(iter_reg)) {</a>
<a name="ln6212">    iter_reg++;</a>
<a name="ln6213">  }</a>
<a name="ln6214">  if (iter_reg - &amp;(regs[0]) == NUM_SAVED_REGISTERS || reg_empty(iter_reg)) {</a>
<a name="ln6215">    return NULL;</a>
<a name="ln6216">  }</a>
<a name="ln6217">  int iter_off = (int)(iter_reg - &amp;(regs[0]));</a>
<a name="ln6218">  *name = (char)get_register_name(iter_off);</a>
<a name="ln6219">  *reg = *iter_reg;</a>
<a name="ln6220">  *is_unnamed = (iter_reg == y_previous);</a>
<a name="ln6221">  while (++iter_reg - &amp;(regs[0]) &lt; NUM_SAVED_REGISTERS) {</a>
<a name="ln6222">    if (!reg_empty(iter_reg)) {</a>
<a name="ln6223">      return (void *) iter_reg;</a>
<a name="ln6224">    }</a>
<a name="ln6225">  }</a>
<a name="ln6226">  return NULL;</a>
<a name="ln6227">}</a>
<a name="ln6228"> </a>
<a name="ln6229">/// Get a number of non-empty registers</a>
<a name="ln6230">size_t op_reg_amount(void)</a>
<a name="ln6231">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6232">{</a>
<a name="ln6233">  size_t ret = 0;</a>
<a name="ln6234">  for (size_t i = 0; i &lt; NUM_SAVED_REGISTERS; i++) {</a>
<a name="ln6235">    if (!reg_empty(y_regs + i)) {</a>
<a name="ln6236">      ret++;</a>
<a name="ln6237">    }</a>
<a name="ln6238">  }</a>
<a name="ln6239">  return ret;</a>
<a name="ln6240">}</a>
<a name="ln6241"> </a>
<a name="ln6242">/// Set register to a given value</a>
<a name="ln6243">///</a>
<a name="ln6244">/// @param[in]  name  Register name.</a>
<a name="ln6245">/// @param[in]  reg  Register value.</a>
<a name="ln6246">/// @param[in]  is_unnamed  Whether to set the unnamed regiseter to reg</a>
<a name="ln6247">///</a>
<a name="ln6248">/// @return true on success, false on failure.</a>
<a name="ln6249">bool op_reg_set(const char name, const yankreg_T reg, bool is_unnamed)</a>
<a name="ln6250">{</a>
<a name="ln6251">  int i = op_reg_index(name);</a>
<a name="ln6252">  if (i == -1) {</a>
<a name="ln6253">    return false;</a>
<a name="ln6254">  }</a>
<a name="ln6255">  free_register(&amp;y_regs[i]);</a>
<a name="ln6256">  y_regs[i] = reg;</a>
<a name="ln6257"> </a>
<a name="ln6258">  if (is_unnamed) {</a>
<a name="ln6259">    y_previous = &amp;y_regs[i];</a>
<a name="ln6260">  }</a>
<a name="ln6261">  return true;</a>
<a name="ln6262">}</a>
<a name="ln6263"> </a>
<a name="ln6264">/// Get register with the given name</a>
<a name="ln6265">///</a>
<a name="ln6266">/// @param[in]  name  Register name.</a>
<a name="ln6267">///</a>
<a name="ln6268">/// @return Pointer to the register contents or NULL.</a>
<a name="ln6269">const yankreg_T *op_reg_get(const char name)</a>
<a name="ln6270">{</a>
<a name="ln6271">  int i = op_reg_index(name);</a>
<a name="ln6272">  if (i == -1) {</a>
<a name="ln6273">    return NULL;</a>
<a name="ln6274">  }</a>
<a name="ln6275">  return &amp;y_regs[i];</a>
<a name="ln6276">}</a>
<a name="ln6277"> </a>
<a name="ln6278">/// Set the previous yank register</a>
<a name="ln6279">///</a>
<a name="ln6280">/// @param[in]  name  Register name.</a>
<a name="ln6281">///</a>
<a name="ln6282">/// @return true on success, false on failure.</a>
<a name="ln6283">bool op_reg_set_previous(const char name)</a>
<a name="ln6284">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6285">{</a>
<a name="ln6286">  int i = op_reg_index(name);</a>
<a name="ln6287">  if (i == -1) {</a>
<a name="ln6288">    return false;</a>
<a name="ln6289">  }</a>
<a name="ln6290"> </a>
<a name="ln6291">  y_previous = &amp;y_regs[i];</a>
<a name="ln6292">  return true;</a>
<a name="ln6293">}</a>

</code></pre>
<div class="balloon" rel="2765"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="5018"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="5020"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="5022"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="5024"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
