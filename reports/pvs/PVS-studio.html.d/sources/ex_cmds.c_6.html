
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ex_cmds.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">/*</a>
<a name="ln5"> * ex_cmds.c: some functions for command line commands</a>
<a name="ln6"> */</a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;assert.h&gt;</a>
<a name="ln9">#include &lt;float.h&gt;</a>
<a name="ln10">#include &lt;stdbool.h&gt;</a>
<a name="ln11">#include &lt;string.h&gt;</a>
<a name="ln12">#include &lt;stdlib.h&gt;</a>
<a name="ln13">#include &lt;inttypes.h&gt;</a>
<a name="ln14">#include &lt;math.h&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln17">#include &quot;nvim/api/vim.h&quot;</a>
<a name="ln18">#include &quot;nvim/api/buffer.h&quot;</a>
<a name="ln19">#include &quot;nvim/log.h&quot;</a>
<a name="ln20">#include &quot;nvim/vim.h&quot;</a>
<a name="ln21">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln22">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln23">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln24">#include &quot;nvim/change.h&quot;</a>
<a name="ln25">#include &quot;nvim/charset.h&quot;</a>
<a name="ln26">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln27">#include &quot;nvim/diff.h&quot;</a>
<a name="ln28">#include &quot;nvim/digraph.h&quot;</a>
<a name="ln29">#include &quot;nvim/edit.h&quot;</a>
<a name="ln30">#include &quot;nvim/eval.h&quot;</a>
<a name="ln31">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln32">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln33">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln34">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln35">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln36">#include &quot;nvim/fold.h&quot;</a>
<a name="ln37">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln38">#include &quot;nvim/highlight.h&quot;</a>
<a name="ln39">#include &quot;nvim/indent.h&quot;</a>
<a name="ln40">#include &quot;nvim/buffer_updates.h&quot;</a>
<a name="ln41">#include &quot;nvim/main.h&quot;</a>
<a name="ln42">#include &quot;nvim/mark.h&quot;</a>
<a name="ln43">#include &quot;nvim/extmark.h&quot;</a>
<a name="ln44">#include &quot;nvim/decoration.h&quot;</a>
<a name="ln45">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln46">#include &quot;nvim/memline.h&quot;</a>
<a name="ln47">#include &quot;nvim/message.h&quot;</a>
<a name="ln48">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln49">#include &quot;nvim/garray.h&quot;</a>
<a name="ln50">#include &quot;nvim/memory.h&quot;</a>
<a name="ln51">#include &quot;nvim/move.h&quot;</a>
<a name="ln52">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln53">#include &quot;nvim/normal.h&quot;</a>
<a name="ln54">#include &quot;nvim/ops.h&quot;</a>
<a name="ln55">#include &quot;nvim/option.h&quot;</a>
<a name="ln56">#include &quot;nvim/os_unix.h&quot;</a>
<a name="ln57">#include &quot;nvim/path.h&quot;</a>
<a name="ln58">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln59">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln60">#include &quot;nvim/screen.h&quot;</a>
<a name="ln61">#include &quot;nvim/search.h&quot;</a>
<a name="ln62">#include &quot;nvim/spell.h&quot;</a>
<a name="ln63">#include &quot;nvim/strings.h&quot;</a>
<a name="ln64">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln65">#include &quot;nvim/tag.h&quot;</a>
<a name="ln66">#include &quot;nvim/ui.h&quot;</a>
<a name="ln67">#include &quot;nvim/undo.h&quot;</a>
<a name="ln68">#include &quot;nvim/window.h&quot;</a>
<a name="ln69">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln70">#include &quot;nvim/os/shell.h&quot;</a>
<a name="ln71">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln72">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln73"> </a>
<a name="ln74"> </a>
<a name="ln75">/// Case matching style to use for :substitute</a>
<a name="ln76">typedef enum {</a>
<a name="ln77">  kSubHonorOptions = 0,  ///&lt; Honor the user's 'ignorecase'/'smartcase' options</a>
<a name="ln78">  kSubIgnoreCase,        ///&lt; Ignore case of the search</a>
<a name="ln79">  kSubMatchCase,         ///&lt; Match case of the search</a>
<a name="ln80">} SubIgnoreType;</a>
<a name="ln81"> </a>
<a name="ln82">/// Flags kept between calls to :substitute.</a>
<a name="ln83">typedef struct {</a>
<a name="ln84">  bool do_all;          ///&lt; do multiple substitutions per line</a>
<a name="ln85">  bool do_ask;          ///&lt; ask for confirmation</a>
<a name="ln86">  bool do_count;        ///&lt; count only</a>
<a name="ln87">  bool do_error;        ///&lt; if false, ignore errors</a>
<a name="ln88">  bool do_print;        ///&lt; print last line with subs</a>
<a name="ln89">  bool do_list;         ///&lt; list last line with subs</a>
<a name="ln90">  bool do_number;       ///&lt; list last line with line nr</a>
<a name="ln91">  SubIgnoreType do_ic;  ///&lt; ignore case flag</a>
<a name="ln92">} subflags_T;</a>
<a name="ln93"> </a>
<a name="ln94">/// Partial result of a substitution during :substitute.</a>
<a name="ln95">/// Numbers refer to the buffer _after_ substitution</a>
<a name="ln96">typedef struct {</a>
<a name="ln97">  lpos_T start;  // start of the match</a>
<a name="ln98">  lpos_T end;    // end of the match</a>
<a name="ln99">  linenr_T pre_match;  // where to begin showing lines before the match</a>
<a name="ln100">} SubResult;</a>
<a name="ln101"> </a>
<a name="ln102">// Collected results of a substitution for showing them in</a>
<a name="ln103">// the preview window</a>
<a name="ln104">typedef struct {</a>
<a name="ln105">  kvec_t(SubResult) subresults;</a>
<a name="ln106">  linenr_T lines_needed;  // lines neede in the preview window</a>
<a name="ln107">} PreviewLines;</a>
<a name="ln108"> </a>
<a name="ln109">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln110"># include &quot;ex_cmds.c.generated.h&quot;</a>
<a name="ln111">#endif</a>
<a name="ln112"> </a>
<a name="ln113">static int preview_bufnr = 0;</a>
<a name="ln114"> </a>
<a name="ln115">/// &quot;:ascii&quot; and &quot;ga&quot; implementation</a>
<a name="ln116">void do_ascii(const exarg_T *const eap)</a>
<a name="ln117">{</a>
<a name="ln118">  char_u *dig;</a>
<a name="ln119">  int cc[MAX_MCO];</a>
<a name="ln120">  int c = utfc_ptr2char(get_cursor_pos_ptr(), cc);</a>
<a name="ln121">  if (c == NUL) {</a>
<a name="ln122">    MSG(&quot;NUL&quot;);</a>
<a name="ln123">    return;</a>
<a name="ln124">  }</a>
<a name="ln125"> </a>
<a name="ln126">  size_t iobuff_len = 0;</a>
<a name="ln127"> </a>
<a name="ln128">  int ci = 0;</a>
<a name="ln129">  if (c &lt; 0x80) {</a>
<a name="ln130">    if (c == NL) {  // NUL is stored as NL.</a>
<a name="ln131">      c = NUL;</a>
<a name="ln132">    }</a>
<a name="ln133">    const int cval = (c == CAR &amp;&amp; get_fileformat(curbuf) == EOL_MAC</a>
<a name="ln134">                      ? NL  // NL is stored as CR.</a>
<a name="ln135">                      : c);</a>
<a name="ln136">    char buf1[20];</a>
<a name="ln137">    if (vim_isprintc_strict(c) &amp;&amp; (c &lt; ' ' || c &gt; '~')) {</a>
<a name="ln138">      char_u buf3[7];</a>
<a name="ln139">      transchar_nonprint(curbuf, buf3, c);</a>
<a name="ln140">      vim_snprintf(buf1, sizeof(buf1), &quot;  &lt;%s&gt;&quot;, (char *)buf3);</a>
<a name="ln141">    } else {</a>
<a name="ln142">      buf1[0] = NUL;</a>
<a name="ln143">    }</a>
<a name="ln144">    char buf2[20];</a>
<a name="ln145">    buf2[0] = NUL;</a>
<a name="ln146"> </a>
<a name="ln147">    dig = get_digraph_for_char(cval);</a>
<a name="ln148">    if (dig != NULL) {</a>
<a name="ln149">        iobuff_len += (</a>
<a name="ln150">            vim_snprintf((char *)IObuff + iobuff_len,</a>
<a name="ln151">                         sizeof(IObuff) - iobuff_len,</a>
<a name="ln152">                         _(&quot;&lt;%s&gt;%s%s  %d,  Hex %02x,  Oct %03o, Digr %s&quot;),</a>
<a name="ln153">                         transchar(c), buf1, buf2, cval, cval, cval, dig));</a>
<a name="ln154">    } else {</a>
<a name="ln155">        iobuff_len += (</a>
<a name="ln156">            vim_snprintf((char *)IObuff + iobuff_len,</a>
<a name="ln157">                         sizeof(IObuff) - iobuff_len,</a>
<a name="ln158">                         _(&quot;&lt;%s&gt;%s%s  %d,  Hex %02x,  Octal %03o&quot;),</a>
<a name="ln159">                         transchar(c), buf1, buf2, cval, cval, cval));</a>
<a name="ln160">    }</a>
<a name="ln161"> </a>
<a name="ln162">    c = cc[ci++];</a>
<a name="ln163">  }</a>
<a name="ln164"> </a>
<a name="ln165">#define SPACE_FOR_DESC (1 + 1 + 1 + MB_MAXBYTES + 16 + 4 + 3 + 3 + 1)</a>
<a name="ln166">  // Space for description:</a>
<a name="ln167">  // - 1 byte for separator (starting from second entry)</a>
<a name="ln168">  // - 1 byte for &quot;&lt;&quot;</a>
<a name="ln169">  // - 1 byte for space to draw composing character on (optional, but really</a>
<a name="ln170">  //   mostly required)</a>
<a name="ln171">  // - up to MB_MAXBYTES bytes for character itself</a>
<a name="ln172">  // - 16 bytes for raw text (&quot;&gt; , Hex , Octal &quot;).</a>
<a name="ln173">  // - at least 4 bytes for hexadecimal representation</a>
<a name="ln174">  // - at least 3 bytes for decimal representation</a>
<a name="ln175">  // - at least 3 bytes for octal representation</a>
<a name="ln176">  // - 1 byte for NUL</a>
<a name="ln177">  //</a>
<a name="ln178">  // Taking into account MAX_MCO and characters which need 8 bytes for</a>
<a name="ln179">  // hexadecimal representation, but not taking translation into account:</a>
<a name="ln180">  // resulting string will occupy less then 400 bytes (conservative estimate).</a>
<a name="ln181">  //</a>
<a name="ln182">  // Less then 1000 bytes if translation multiplies number of bytes needed for</a>
<a name="ln183">  // raw text by 6, so it should always fit into 1025 bytes reserved for IObuff.</a>
<a name="ln184"> </a>
<a name="ln185">  // Repeat for combining characters, also handle multiby here.</a>
<a name="ln186">  while (c &gt;= 0x80 &amp;&amp; iobuff_len &lt; sizeof(IObuff) - SPACE_FOR_DESC) {</a>
<a name="ln187">    // This assumes every multi-byte char is printable...</a>
<a name="ln188">    if (iobuff_len &gt; 0) {</a>
<a name="ln189">      IObuff[iobuff_len++] = ' ';</a>
<a name="ln190">    }</a>
<a name="ln191">    IObuff[iobuff_len++] = '&lt;';</a>
<a name="ln192">    if (utf_iscomposing(c)) {</a>
<a name="ln193">      IObuff[iobuff_len++] = ' ';  // Draw composing char on top of a space.</a>
<a name="ln194">    }</a>
<a name="ln195">    iobuff_len += utf_char2bytes(c, IObuff + iobuff_len);</a>
<a name="ln196"> </a>
<a name="ln197">    dig = get_digraph_for_char(c);</a>
<a name="ln198">    if (dig != NULL) {</a>
<a name="ln199">        iobuff_len += (</a>
<a name="ln200">            vim_snprintf((char *)IObuff + iobuff_len,</a>
<a name="ln201">                         sizeof(IObuff) - iobuff_len,</a>
<a name="ln202">                         (c &lt; 0x10000</a>
<a name="ln203">                          ? _(&quot;&gt; %d, Hex %04x, Oct %o, Digr %s&quot;)</a>
<a name="ln204">                          : _(&quot;&gt; %d, Hex %08x, Oct %o, Digr %s&quot;)),</a>
<a name="ln205">                         c, c, c, dig));</a>
<a name="ln206">    } else {</a>
<a name="ln207">        iobuff_len += (</a>
<a name="ln208">            vim_snprintf((char *)IObuff + iobuff_len,</a>
<a name="ln209">                         sizeof(IObuff) - iobuff_len,</a>
<a name="ln210">                         (c &lt; 0x10000</a>
<a name="ln211">                          ? _(&quot;&gt; %d, Hex %04x, Octal %o&quot;)</a>
<a name="ln212">                          : _(&quot;&gt; %d, Hex %08x, Octal %o&quot;)),</a>
<a name="ln213">                         c, c, c));</a>
<a name="ln214">    }</a>
<a name="ln215">    if (ci == MAX_MCO) {</a>
<a name="ln216">      break;</a>
<a name="ln217">    }</a>
<a name="ln218">    c = cc[ci++];</a>
<a name="ln219">  }</a>
<a name="ln220">  if (ci != MAX_MCO &amp;&amp; c != 0) {</a>
<a name="ln221">    xstrlcpy((char *)IObuff + iobuff_len, &quot; ...&quot;, sizeof(IObuff) - iobuff_len);</a>
<a name="ln222">  }</a>
<a name="ln223"> </a>
<a name="ln224">  msg(IObuff);</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227">/*</a>
<a name="ln228"> * &quot;:left&quot;, &quot;:center&quot; and &quot;:right&quot;: align text.</a>
<a name="ln229"> */</a>
<a name="ln230">void ex_align(exarg_T *eap)</a>
<a name="ln231">{</a>
<a name="ln232">  pos_T save_curpos;</a>
<a name="ln233">  int len;</a>
<a name="ln234">  int indent = 0;</a>
<a name="ln235">  int new_indent;</a>
<a name="ln236">  int has_tab;</a>
<a name="ln237">  int width;</a>
<a name="ln238"> </a>
<a name="ln239">  if (curwin-&gt;w_p_rl) {</a>
<a name="ln240">    /* switch left and right aligning */</a>
<a name="ln241">    if (eap-&gt;cmdidx == CMD_right)</a>
<a name="ln242">      eap-&gt;cmdidx = CMD_left;</a>
<a name="ln243">    else if (eap-&gt;cmdidx == CMD_left)</a>
<a name="ln244">      eap-&gt;cmdidx = CMD_right;</a>
<a name="ln245">  }</a>
<a name="ln246"> </a>
<a name="ln247">  width = atoi((char *)eap-&gt;arg);</a>
<a name="ln248">  save_curpos = curwin-&gt;w_cursor;</a>
<a name="ln249">  if (eap-&gt;cmdidx == CMD_left) {    /* width is used for new indent */</a>
<a name="ln250">    if (width &gt;= 0)</a>
<a name="ln251">      indent = width;</a>
<a name="ln252">  } else {</a>
<a name="ln253">    /*</a>
<a name="ln254">     * if 'textwidth' set, use it</a>
<a name="ln255">     * else if 'wrapmargin' set, use it</a>
<a name="ln256">     * if invalid value, use 80</a>
<a name="ln257">     */</a>
<a name="ln258">    if (width &lt;= 0)</a>
<a name="ln259">      width = curbuf-&gt;b_p_tw;</a>
<a name="ln260">    if (width == 0 &amp;&amp; curbuf-&gt;b_p_wm &gt; 0) {</a>
<a name="ln261">      width = curwin-&gt;w_width_inner - curbuf-&gt;b_p_wm;</a>
<a name="ln262">    }</a>
<a name="ln263">    if (width &lt;= 0) {</a>
<a name="ln264">      width = 80;</a>
<a name="ln265">    }</a>
<a name="ln266">  }</a>
<a name="ln267"> </a>
<a name="ln268">  if (u_save((linenr_T)(eap-&gt;line1 - 1), (linenr_T)(eap-&gt;line2 + 1)) == FAIL)</a>
<a name="ln269">    return;</a>
<a name="ln270"> </a>
<a name="ln271">  for (curwin-&gt;w_cursor.lnum = eap-&gt;line1;</a>
<a name="ln272">       curwin-&gt;w_cursor.lnum &lt;= eap-&gt;line2; ++curwin-&gt;w_cursor.lnum) {</a>
<a name="ln273">    if (eap-&gt;cmdidx == CMD_left)                /* left align */</a>
<a name="ln274">      new_indent = indent;</a>
<a name="ln275">    else {</a>
<a name="ln276">      has_tab = FALSE;          /* avoid uninit warnings */</a>
<a name="ln277">      len = linelen(eap-&gt;cmdidx == CMD_right ? &amp;has_tab</a>
<a name="ln278">          : NULL) - get_indent();</a>
<a name="ln279"> </a>
<a name="ln280">      if (len &lt;= 0)                             /* skip blank lines */</a>
<a name="ln281">        continue;</a>
<a name="ln282"> </a>
<a name="ln283">      if (eap-&gt;cmdidx == CMD_center)</a>
<a name="ln284">        new_indent = (width - len) / 2;</a>
<a name="ln285">      else {</a>
<a name="ln286">        new_indent = width - len;               /* right align */</a>
<a name="ln287"> </a>
<a name="ln288">        /*</a>
<a name="ln289">         * Make sure that embedded TABs don't make the text go too far</a>
<a name="ln290">         * to the right.</a>
<a name="ln291">         */</a>
<a name="ln292">        if (has_tab)</a>
<a name="ln293">          while (new_indent &gt; 0) {</a>
<a name="ln294">            (void)set_indent(new_indent, 0);</a>
<a name="ln295">            if (linelen(NULL) &lt;= width) {</a>
<a name="ln296">              /*</a>
<a name="ln297">               * Now try to move the line as much as possible to</a>
<a name="ln298">               * the right.  Stop when it moves too far.</a>
<a name="ln299">               */</a>
<a name="ln300">              do</a>
<a name="ln301">                (void)set_indent(++new_indent, 0);</a>
<a name="ln302">              while (linelen(NULL) &lt;= width);</a>
<a name="ln303">              --new_indent;</a>
<a name="ln304">              break;</a>
<a name="ln305">            }</a>
<a name="ln306">            --new_indent;</a>
<a name="ln307">          }</a>
<a name="ln308">      }</a>
<a name="ln309">    }</a>
<a name="ln310">    if (new_indent &lt; 0)</a>
<a name="ln311">      new_indent = 0;</a>
<a name="ln312">    (void)set_indent(new_indent, 0);                    /* set indent */</a>
<a name="ln313">  }</a>
<a name="ln314">  changed_lines(eap-&gt;line1, 0, eap-&gt;line2 + 1, 0L, true);</a>
<a name="ln315">  curwin-&gt;w_cursor = save_curpos;</a>
<a name="ln316">  beginline(BL_WHITE | BL_FIX);</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319">/*</a>
<a name="ln320"> * Get the length of the current line, excluding trailing white space.</a>
<a name="ln321"> */</a>
<a name="ln322">static int linelen(int *has_tab)</a>
<a name="ln323">{</a>
<a name="ln324">  char_u  *line;</a>
<a name="ln325">  char_u  *first;</a>
<a name="ln326">  char_u  *last;</a>
<a name="ln327">  int save;</a>
<a name="ln328">  int len;</a>
<a name="ln329"> </a>
<a name="ln330">  // Get the line.  If it's empty bail out early (could be the empty string</a>
<a name="ln331">  // for an unloaded buffer).</a>
<a name="ln332">  line = get_cursor_line_ptr();</a>
<a name="ln333">  if (*line == NUL) {</a>
<a name="ln334">    return 0;</a>
<a name="ln335">  }</a>
<a name="ln336">  // find the first non-blank character</a>
<a name="ln337">  first = skipwhite(line);</a>
<a name="ln338"> </a>
<a name="ln339">  // find the character after the last non-blank character</a>
<a name="ln340">  for (last = first + STRLEN(first);</a>
<a name="ln341">       last &gt; first &amp;&amp; ascii_iswhite(last[-1]); last--) {</a>
<a name="ln342">  }</a>
<a name="ln343">  save = *last;</a>
<a name="ln344">  *last = NUL;</a>
<a name="ln345">  // Get line length.</a>
<a name="ln346">  len = linetabsize(line);</a>
<a name="ln347">  // Check for embedded TAB.</a>
<a name="ln348">  if (has_tab != NULL) {</a>
<a name="ln349">    *has_tab = vim_strchr(first, TAB) != NULL;</a>
<a name="ln350">  }</a>
<a name="ln351">  *last = save;</a>
<a name="ln352"> </a>
<a name="ln353">  return len;</a>
<a name="ln354">}</a>
<a name="ln355"> </a>
<a name="ln356">/* Buffer for two lines used during sorting.  They are allocated to</a>
<a name="ln357"> * contain the longest line being sorted. */</a>
<a name="ln358">static char_u   *sortbuf1;</a>
<a name="ln359">static char_u   *sortbuf2;</a>
<a name="ln360"> </a>
<a name="ln361">static int sort_ic;       ///&lt; ignore case</a>
<a name="ln362">static int sort_nr;       ///&lt; sort on number</a>
<a name="ln363">static int sort_rx;       ///&lt; sort on regex instead of skipping it</a>
<a name="ln364">static int sort_flt;      ///&lt; sort on floating number</a>
<a name="ln365"> </a>
<a name="ln366">static int sort_abort;    ///&lt; flag to indicate if sorting has been interrupted</a>
<a name="ln367"> </a>
<a name="ln368">/// Struct to store info to be sorted.</a>
<a name="ln369">typedef struct {</a>
<a name="ln370">  linenr_T lnum;          ///&lt; line number</a>
<a name="ln371">  union {</a>
<a name="ln372">    struct {</a>
<a name="ln373">      varnumber_T start_col_nr;  ///&lt; starting column number</a>
<a name="ln374">      varnumber_T end_col_nr;    ///&lt; ending column number</a>
<a name="ln375">    } line;</a>
<a name="ln376">    struct {</a>
<a name="ln377">      varnumber_T value;         ///&lt; value if sorting by integer</a>
<a name="ln378">      bool is_number;            ///&lt; true when line contains a number</a>
<a name="ln379">    } num;</a>
<a name="ln380">    float_T value_flt;    ///&lt; value if sorting by float</a>
<a name="ln381">  } st_u;</a>
<a name="ln382">} sorti_T;</a>
<a name="ln383"> </a>
<a name="ln384"> </a>
<a name="ln385">static int sort_compare(const void *s1, const void *s2)</a>
<a name="ln386">{</a>
<a name="ln387">  sorti_T l1 = *(sorti_T *)s1;</a>
<a name="ln388">  sorti_T l2 = *(sorti_T *)s2;</a>
<a name="ln389">  int result = 0;</a>
<a name="ln390"> </a>
<a name="ln391">  /* If the user interrupts, there's no way to stop qsort() immediately, but</a>
<a name="ln392">   * if we return 0 every time, qsort will assume it's done sorting and</a>
<a name="ln393">   * exit. */</a>
<a name="ln394">  if (sort_abort)</a>
<a name="ln395">    return 0;</a>
<a name="ln396">  fast_breakcheck();</a>
<a name="ln397">  if (got_int)</a>
<a name="ln398">    sort_abort = TRUE;</a>
<a name="ln399"> </a>
<a name="ln400">  // When sorting numbers &quot;start_col_nr&quot; is the number, not the column</a>
<a name="ln401">  // number.</a>
<a name="ln402">  if (sort_nr) {</a>
<a name="ln403">    if (l1.st_u.num.is_number != l2.st_u.num.is_number) {</a>
<a name="ln404">      result = l1.st_u.num.is_number - l2.st_u.num.is_number;</a>
<a name="ln405">    } else {</a>
<a name="ln406">      result = l1.st_u.num.value == l2.st_u.num.value</a>
<a name="ln407">        ? 0</a>
<a name="ln408">        : l1.st_u.num.value &gt; l2.st_u.num.value</a>
<a name="ln409">          ? 1</a>
<a name="ln410">          : -1;</a>
<a name="ln411">    }</a>
<a name="ln412">  } else if (sort_flt) {</a>
<a name="ln413">    result = l1.st_u.value_flt == l2.st_u.value_flt</a>
<a name="ln414">             ? 0 : l1.st_u.value_flt &gt; l2.st_u.value_flt</a>
<a name="ln415">             ? 1 : -1;</a>
<a name="ln416">  } else {</a>
<a name="ln417">    // We need to copy one line into &quot;sortbuf1&quot;, because there is no</a>
<a name="ln418">    // guarantee that the first pointer becomes invalid when obtaining the</a>
<a name="ln419">    // second one.</a>
<a name="ln420">    memcpy(sortbuf1, ml_get(l1.lnum) + l1.st_u.line.start_col_nr,</a>
<a name="ln421">           l1.st_u.line.end_col_nr - l1.st_u.line.start_col_nr + 1);</a>
<a name="ln422">    sortbuf1[l1.st_u.line.end_col_nr - l1.st_u.line.start_col_nr] = NUL;</a>
<a name="ln423">    memcpy(sortbuf2, ml_get(l2.lnum) + l2.st_u.line.start_col_nr,</a>
<a name="ln424">           l2.st_u.line.end_col_nr - l2.st_u.line.start_col_nr + 1);</a>
<a name="ln425">    sortbuf2[l2.st_u.line.end_col_nr - l2.st_u.line.start_col_nr] = NUL;</a>
<a name="ln426"> </a>
<a name="ln427">    result = sort_ic ? STRICMP(sortbuf1, sortbuf2)</a>
<a name="ln428">             : STRCMP(sortbuf1, sortbuf2);</a>
<a name="ln429">  }</a>
<a name="ln430"> </a>
<a name="ln431">  /* If two lines have the same value, preserve the original line order. */</a>
<a name="ln432">  if (result == 0)</a>
<a name="ln433">    return (int)(l1.lnum - l2.lnum);</a>
<a name="ln434">  return result;</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437">// &quot;:sort&quot;.</a>
<a name="ln438">void ex_sort(exarg_T *eap)</a>
<a name="ln439">{</a>
<a name="ln440">  regmatch_T regmatch;</a>
<a name="ln441">  int len;</a>
<a name="ln442">  linenr_T lnum;</a>
<a name="ln443">  long maxlen = 0;</a>
<a name="ln444">  size_t count = (size_t)(eap-&gt;line2 - eap-&gt;line1 + 1);</a>
<a name="ln445">  size_t i;</a>
<a name="ln446">  char_u      *p;</a>
<a name="ln447">  char_u      *s;</a>
<a name="ln448">  char_u      *s2;</a>
<a name="ln449">  char_u c;                             // temporary character storage</a>
<a name="ln450">  bool unique = false;</a>
<a name="ln451">  long deleted;</a>
<a name="ln452">  colnr_T start_col;</a>
<a name="ln453">  colnr_T end_col;</a>
<a name="ln454">  int sort_what = 0;</a>
<a name="ln455"> </a>
<a name="ln456">  // Sorting one line is really quick!</a>
<a name="ln457">  if (count &lt;= 1) {</a>
<a name="ln458">    return;</a>
<a name="ln459">  }</a>
<a name="ln460"> </a>
<a name="ln461">  if (u_save((linenr_T)(eap-&gt;line1 - 1), (linenr_T)(eap-&gt;line2 + 1)) == FAIL) {</a>
<a name="ln462">    return;</a>
<a name="ln463">  }</a>
<a name="ln464">  sortbuf1 = NULL;</a>
<a name="ln465">  sortbuf2 = NULL;</a>
<a name="ln466">  regmatch.regprog = NULL;</a>
<a name="ln467">  sorti_T *nrs = xmalloc(count * sizeof(sorti_T));</a>
<a name="ln468"> </a>
<a name="ln469">  sort_abort = sort_ic = sort_rx = sort_nr = sort_flt = 0;</a>
<a name="ln470">  size_t format_found = 0;</a>
<a name="ln471">  bool change_occurred = false;   // Buffer contents changed.</a>
<a name="ln472"> </a>
<a name="ln473">  for (p = eap-&gt;arg; *p != NUL; ++p) {</a>
<a name="ln474">    if (ascii_iswhite(*p)) {</a>
<a name="ln475">    } else if (*p == 'i') {</a>
<a name="ln476">      sort_ic = true;</a>
<a name="ln477">    } else if (*p == 'r') {</a>
<a name="ln478">      sort_rx = true;</a>
<a name="ln479">    } else if (*p == 'n') {</a>
<a name="ln480">      sort_nr = 1;</a>
<a name="ln481">      format_found++;</a>
<a name="ln482">    } else if (*p == 'f') {</a>
<a name="ln483">      sort_flt = 1;</a>
<a name="ln484">      format_found++;</a>
<a name="ln485">    } else if (*p == 'b') {</a>
<a name="ln486">      sort_what = STR2NR_BIN + STR2NR_FORCE;</a>
<a name="ln487">      format_found++;</a>
<a name="ln488">    } else if (*p == 'o') {</a>
<a name="ln489">      sort_what = STR2NR_OCT + STR2NR_FORCE;</a>
<a name="ln490">      format_found++;</a>
<a name="ln491">    } else if (*p == 'x') {</a>
<a name="ln492">      sort_what = STR2NR_HEX + STR2NR_FORCE;</a>
<a name="ln493">      format_found++;</a>
<a name="ln494">    } else if (*p == 'u') {</a>
<a name="ln495">      unique = true;</a>
<a name="ln496">    } else if (*p == '&quot;') {</a>
<a name="ln497">      // comment start</a>
<a name="ln498">      break;</a>
<a name="ln499">    } else if (check_nextcmd(p) != NULL) {</a>
<a name="ln500">      eap-&gt;nextcmd = check_nextcmd(p);</a>
<a name="ln501">      break;</a>
<a name="ln502">    } else if (!ASCII_ISALPHA(*p) &amp;&amp; regmatch.regprog == NULL) {</a>
<a name="ln503">      s = skip_regexp(p + 1, *p, true, NULL);</a>
<a name="ln504">      if (*s != *p) {</a>
<a name="ln505">        EMSG(_(e_invalpat));</a>
<a name="ln506">        goto sortend;</a>
<a name="ln507">      }</a>
<a name="ln508">      *s = NUL;</a>
<a name="ln509">      // Use last search pattern if sort pattern is empty.</a>
<a name="ln510">      if (s == p + 1) {</a>
<a name="ln511">        if (last_search_pat() == NULL) {</a>
<a name="ln512">          EMSG(_(e_noprevre));</a>
<a name="ln513">          goto sortend;</a>
<a name="ln514">        }</a>
<a name="ln515">        regmatch.regprog = vim_regcomp(last_search_pat(), RE_MAGIC);</a>
<a name="ln516">      } else {</a>
<a name="ln517">        regmatch.regprog = vim_regcomp(p + 1, RE_MAGIC);</a>
<a name="ln518">      }</a>
<a name="ln519">      if (regmatch.regprog == NULL) {</a>
<a name="ln520">        goto sortend;</a>
<a name="ln521">      }</a>
<a name="ln522">      p = s;                    // continue after the regexp</a>
<a name="ln523">      regmatch.rm_ic = p_ic;</a>
<a name="ln524">    } else {</a>
<a name="ln525">      EMSG2(_(e_invarg2), p);</a>
<a name="ln526">      goto sortend;</a>
<a name="ln527">    }</a>
<a name="ln528">  }</a>
<a name="ln529"> </a>
<a name="ln530">  // Can only have one of 'n', 'b', 'o' and 'x'.</a>
<a name="ln531">  if (format_found &gt; 1) {</a>
<a name="ln532">    EMSG(_(e_invarg));</a>
<a name="ln533">    goto sortend;</a>
<a name="ln534">  }</a>
<a name="ln535"> </a>
<a name="ln536">  // From here on &quot;sort_nr&quot; is used as a flag for any integer number</a>
<a name="ln537">  // sorting.</a>
<a name="ln538">  sort_nr += sort_what;</a>
<a name="ln539"> </a>
<a name="ln540">  // Make an array with all line numbers.  This avoids having to copy all</a>
<a name="ln541">  // the lines into allocated memory.</a>
<a name="ln542">  // When sorting on strings &quot;start_col_nr&quot; is the offset in the line, for</a>
<a name="ln543">  // numbers sorting it's the number to sort on.  This means the pattern</a>
<a name="ln544">  // matching and number conversion only has to be done once per line.</a>
<a name="ln545">  // Also get the longest line length for allocating &quot;sortbuf&quot;.</a>
<a name="ln546">  for (lnum = eap-&gt;line1; lnum &lt;= eap-&gt;line2; ++lnum) {</a>
<a name="ln547">    s = ml_get(lnum);</a>
<a name="ln548">    len = (int)STRLEN(s);</a>
<a name="ln549">    if (maxlen &lt; len) {</a>
<a name="ln550">      maxlen = len;</a>
<a name="ln551">    }</a>
<a name="ln552"> </a>
<a name="ln553">    start_col = 0;</a>
<a name="ln554">    end_col = len;</a>
<a name="ln555">    if (regmatch.regprog != NULL &amp;&amp; vim_regexec(&amp;regmatch, s, 0)) {</a>
<a name="ln556">      if (sort_rx) {</a>
<a name="ln557">        start_col = (colnr_T)(regmatch.startp[0] - s);</a>
<a name="ln558">        end_col = (colnr_T)(regmatch.endp[0] - s);</a>
<a name="ln559">      } else {</a>
<a name="ln560">        start_col = (colnr_T)(regmatch.endp[0] - s);</a>
<a name="ln561">      }</a>
<a name="ln562">    } else if (regmatch.regprog != NULL) {</a>
<a name="ln563">      end_col = 0;</a>
<a name="ln564">    }</a>
<a name="ln565"> </a>
<a name="ln566">    if (sort_nr || sort_flt) {</a>
<a name="ln567">      // Make sure vim_str2nr doesn't read any digits past the end</a>
<a name="ln568">      // of the match, by temporarily terminating the string there</a>
<a name="ln569">      s2 = s + end_col;</a>
<a name="ln570">      c = *s2;</a>
<a name="ln571">      *s2 = NUL;</a>
<a name="ln572">      // Sorting on number: Store the number itself.</a>
<a name="ln573">      p = s + start_col;</a>
<a name="ln574">      if (sort_nr) {</a>
<a name="ln575">        if (sort_what &amp; STR2NR_HEX) {</a>
<a name="ln576">          s = skiptohex(p);</a>
<a name="ln577">        } else if (sort_what &amp; STR2NR_BIN) {</a>
<a name="ln578">          s = (char_u *)skiptobin((char *)p);</a>
<a name="ln579">        } else {</a>
<a name="ln580">          s = skiptodigit(p);</a>
<a name="ln581">        }</a>
<a name="ln582">        if (s &gt; p &amp;&amp; s[-1] == '-') {</a>
<a name="ln583">          s--;  // include preceding negative sign</a>
<a name="ln584">        }</a>
<a name="ln585">        if (*s == NUL) {</a>
<a name="ln586">          // line without number should sort before any number</a>
<a name="ln587">          nrs[lnum - eap-&gt;line1].st_u.num.is_number = false;</a>
<a name="ln588">          nrs[lnum - eap-&gt;line1].st_u.num.value = 0;</a>
<a name="ln589">        } else {</a>
<a name="ln590">          nrs[lnum - eap-&gt;line1].st_u.num.is_number = true;</a>
<a name="ln591">          vim_str2nr(s, NULL, NULL, sort_what,</a>
<a name="ln592">                     &amp;nrs[lnum - eap-&gt;line1].st_u.num.value, NULL, 0);</a>
<a name="ln593">        }</a>
<a name="ln594">      } else {</a>
<a name="ln595">        s = skipwhite(p);</a>
<a name="ln596">        if (*s == '+') {</a>
<a name="ln597">          s = skipwhite(s + 1);</a>
<a name="ln598">        }</a>
<a name="ln599"> </a>
<a name="ln600">        if (*s == NUL) {</a>
<a name="ln601">          // empty line should sort before any number</a>
<a name="ln602">          nrs[lnum - eap-&gt;line1].st_u.value_flt = -DBL_MAX;</a>
<a name="ln603">        } else {</a>
<a name="ln604">          nrs[lnum - eap-&gt;line1].st_u.value_flt = strtod((char *)s, NULL);</a>
<a name="ln605">        }</a>
<a name="ln606">      }</a>
<a name="ln607">      *s2 = c;</a>
<a name="ln608">    } else {</a>
<a name="ln609">      // Store the column to sort at.</a>
<a name="ln610">      nrs[lnum - eap-&gt;line1].st_u.line.start_col_nr = start_col;</a>
<a name="ln611">      nrs[lnum - eap-&gt;line1].st_u.line.end_col_nr = end_col;</a>
<a name="ln612">    }</a>
<a name="ln613"> </a>
<a name="ln614">    nrs[lnum - eap-&gt;line1].lnum = lnum;</a>
<a name="ln615"> </a>
<a name="ln616">    if (regmatch.regprog != NULL)</a>
<a name="ln617">      fast_breakcheck();</a>
<a name="ln618">    if (got_int)</a>
<a name="ln619">      goto sortend;</a>
<a name="ln620">  }</a>
<a name="ln621"> </a>
<a name="ln622">  // Allocate a buffer that can hold the longest line.</a>
<a name="ln623">  sortbuf1 = xmalloc(maxlen + 1);</a>
<a name="ln624">  sortbuf2 = xmalloc(maxlen + 1);</a>
<a name="ln625"> </a>
<a name="ln626">  // Sort the array of line numbers.  Note: can't be interrupted!</a>
<a name="ln627">  qsort((void *)nrs, count, sizeof(sorti_T), sort_compare);</a>
<a name="ln628"> </a>
<a name="ln629">  if (sort_abort)</a>
<a name="ln630">    goto sortend;</a>
<a name="ln631"> </a>
<a name="ln632">  bcount_t old_count = 0, new_count = 0;</a>
<a name="ln633"> </a>
<a name="ln634">  // Insert the lines in the sorted order below the last one.</a>
<a name="ln635">  lnum = eap-&gt;line2;</a>
<a name="ln636">  for (i = 0; i &lt; count; i++) {</a>
<a name="ln637">    const linenr_T get_lnum = nrs[eap-&gt;forceit ? count - i - 1 : i].lnum;</a>
<a name="ln638"> </a>
<a name="ln639">    // If the original line number of the line being placed is not the same</a>
<a name="ln640">    // as &quot;lnum&quot; (accounting for offset), we know that the buffer changed.</a>
<a name="ln641">    if (get_lnum + ((linenr_T)count - 1) != lnum) {</a>
<a name="ln642">      change_occurred = true;</a>
<a name="ln643">    }</a>
<a name="ln644"> </a>
<a name="ln645">    s = ml_get(get_lnum);</a>
<a name="ln646">    size_t bytelen = STRLEN(s) + 1;  // include EOL in bytelen</a>
<a name="ln647">    old_count += bytelen;</a>
<a name="ln648">    if (!unique || i == 0</a>
<a name="ln649">        || (sort_ic ? STRICMP(s, sortbuf1) : STRCMP(s, sortbuf1)) != 0) {</a>
<a name="ln650">      // Copy the line into a buffer, it may become invalid in</a>
<a name="ln651">      // ml_append(). And it's needed for &quot;unique&quot;.</a>
<a name="ln652">      STRCPY(sortbuf1, s);</a>
<a name="ln653">      if (ml_append(lnum++, sortbuf1, (colnr_T)0, false) == FAIL) {</a>
<a name="ln654">        break;</a>
<a name="ln655">      }</a>
<a name="ln656">      new_count += bytelen;</a>
<a name="ln657">    }</a>
<a name="ln658">    fast_breakcheck();</a>
<a name="ln659">    if (got_int)</a>
<a name="ln660">      goto sortend;</a>
<a name="ln661">  }</a>
<a name="ln662"> </a>
<a name="ln663">  // delete the original lines if appending worked</a>
<a name="ln664">  if (i == count) {</a>
<a name="ln665">    for (i = 0; i &lt; count; ++i) {</a>
<a name="ln666">      ml_delete(eap-&gt;line1, false);</a>
<a name="ln667">    }</a>
<a name="ln668">  } else {</a>
<a name="ln669">    count = 0;</a>
<a name="ln670">  }</a>
<a name="ln671"> </a>
<a name="ln672">  // Adjust marks for deleted (or added) lines and prepare for displaying.</a>
<a name="ln673">  deleted = (long)(count - (lnum - eap-&gt;line2));</a>
<a name="ln674">  if (deleted &gt; 0) {</a>
<a name="ln675">    mark_adjust(eap-&gt;line2 - deleted, eap-&gt;line2, (long)MAXLNUM, -deleted,</a>
<a name="ln676">                kExtmarkNOOP);</a>
<a name="ln677">    msgmore(-deleted);</a>
<a name="ln678">  } else if (deleted &lt; 0) {</a>
<a name="ln679">    mark_adjust(eap-&gt;line2, MAXLNUM, -deleted, 0L, kExtmarkNOOP);</a>
<a name="ln680">  }</a>
<a name="ln681"> </a>
<a name="ln682">  extmark_splice(curbuf, eap-&gt;line1-1, 0,</a>
<a name="ln683">                 count, 0, old_count,</a>
<a name="ln684">                 lnum - eap-&gt;line2, 0, new_count, kExtmarkUndo);</a>
<a name="ln685"> </a>
<a name="ln686">  if (change_occurred || deleted != 0) {</a>
<a name="ln687">    changed_lines(eap-&gt;line1, 0, eap-&gt;line2 + 1, -deleted, true);</a>
<a name="ln688">  }</a>
<a name="ln689"> </a>
<a name="ln690">  curwin-&gt;w_cursor.lnum = eap-&gt;line1;</a>
<a name="ln691">  beginline(BL_WHITE | BL_FIX);</a>
<a name="ln692"> </a>
<a name="ln693">sortend:</a>
<a name="ln694">  xfree(nrs);</a>
<a name="ln695">  xfree(sortbuf1);</a>
<a name="ln696">  xfree(sortbuf2);</a>
<a name="ln697">  vim_regfree(regmatch.regprog);</a>
<a name="ln698">  if (got_int) {</a>
<a name="ln699">    EMSG(_(e_interr));</a>
<a name="ln700">  }</a>
<a name="ln701">}</a>
<a name="ln702"> </a>
<a name="ln703">/*</a>
<a name="ln704"> * &quot;:retab&quot;.</a>
<a name="ln705"> */</a>
<a name="ln706">void ex_retab(exarg_T *eap)</a>
<a name="ln707">{</a>
<a name="ln708">  linenr_T lnum;</a>
<a name="ln709">  int got_tab = FALSE;</a>
<a name="ln710">  long num_spaces = 0;</a>
<a name="ln711">  long num_tabs;</a>
<a name="ln712">  long len;</a>
<a name="ln713">  long col;</a>
<a name="ln714">  long vcol;</a>
<a name="ln715">  long start_col = 0;                   // For start of white-space string</a>
<a name="ln716">  long start_vcol = 0;                  // For start of white-space string</a>
<a name="ln717">  long old_len;</a>
<a name="ln718">  char_u      *ptr;</a>
<a name="ln719">  char_u      *new_line = (char_u *)1;  // init to non-NULL</a>
<a name="ln720">  int did_undo;                         // called u_save for current line</a>
<a name="ln721">  long *new_vts_array = NULL;</a>
<a name="ln722">  char_u *new_ts_str;  // string value of tab argument</a>
<a name="ln723"> </a>
<a name="ln724">  int save_list;</a>
<a name="ln725">  linenr_T first_line = 0;              /* first changed line */</a>
<a name="ln726">  linenr_T last_line = 0;               /* last changed line */</a>
<a name="ln727"> </a>
<a name="ln728">  save_list = curwin-&gt;w_p_list;</a>
<a name="ln729">  curwin-&gt;w_p_list = 0;             /* don't want list mode here */</a>
<a name="ln730"> </a>
<a name="ln731">  new_ts_str = eap-&gt;arg;</a>
<a name="ln732">  if (!tabstop_set(eap-&gt;arg, &amp;new_vts_array)) {</a>
<a name="ln733">    return;</a>
<a name="ln734">  }</a>
<a name="ln735">  while (ascii_isdigit(*(eap-&gt;arg)) || *(eap-&gt;arg) == ',') {</a>
<a name="ln736">    (eap-&gt;arg)++;</a>
<a name="ln737">  }</a>
<a name="ln738"> </a>
<a name="ln739">  // This ensures that either new_vts_array and new_ts_str are freshly</a>
<a name="ln740">  // allocated, or new_vts_array points to an existing array and new_ts_str</a>
<a name="ln741">  // is null.</a>
<a name="ln742">  if (new_vts_array == NULL) {</a>
<a name="ln743">    new_vts_array = curbuf-&gt;b_p_vts_array;</a>
<a name="ln744">    new_ts_str = NULL;</a>
<a name="ln745">  } else {</a>
<a name="ln746">    new_ts_str = vim_strnsave(new_ts_str, eap-&gt;arg - new_ts_str);</a>
<a name="ln747">  }</a>
<a name="ln748">  for (lnum = eap-&gt;line1; !got_int &amp;&amp; lnum &lt;= eap-&gt;line2; lnum++) {</a>
<a name="ln749">    ptr = ml_get(lnum);</a>
<a name="ln750">    col = 0;</a>
<a name="ln751">    vcol = 0;</a>
<a name="ln752">    did_undo = FALSE;</a>
<a name="ln753">    for (;; ) {</a>
<a name="ln754">      if (ascii_iswhite(ptr[col])) {</a>
<a name="ln755">        if (!got_tab &amp;&amp; num_spaces == 0) {</a>
<a name="ln756">          /* First consecutive white-space */</a>
<a name="ln757">          start_vcol = vcol;</a>
<a name="ln758">          start_col = col;</a>
<a name="ln759">        }</a>
<a name="ln760">        if (ptr[col] == ' ')</a>
<a name="ln761">          num_spaces++;</a>
<a name="ln762">        else</a>
<a name="ln763">          got_tab = TRUE;</a>
<a name="ln764">      } else {</a>
<a name="ln765">        if (got_tab || (eap-&gt;forceit &amp;&amp; num_spaces &gt; 1)) {</a>
<a name="ln766">          /* Retabulate this string of white-space */</a>
<a name="ln767"> </a>
<a name="ln768">          /* len is virtual length of white string */</a>
<a name="ln769">          len = num_spaces = vcol - start_vcol;</a>
<a name="ln770">          num_tabs = 0;</a>
<a name="ln771">          if (!curbuf-&gt;b_p_et) {</a>
<a name="ln772">            int t, s;</a>
<a name="ln773"> </a>
<a name="ln774">            tabstop_fromto(start_vcol, vcol,</a>
<a name="ln775">                           curbuf-&gt;b_p_ts, new_vts_array, &amp;t, &amp;s);</a>
<a name="ln776">            num_tabs = t;</a>
<a name="ln777">            num_spaces = s;</a>
<a name="ln778">          }</a>
<a name="ln779">          if (curbuf-&gt;b_p_et || got_tab</a>
<a name="ln780">              || (num_spaces + num_tabs &lt; len)) {</a>
<a name="ln781">            if (did_undo == false) {</a>
<a name="ln782">              did_undo = true;</a>
<a name="ln783">              if (u_save((linenr_T)(lnum - 1),</a>
<a name="ln784">                         (linenr_T)(lnum + 1)) == FAIL) {</a>
<a name="ln785">                new_line = NULL;  // flag out-of-memory</a>
<a name="ln786">                break;</a>
<a name="ln787">              }</a>
<a name="ln788">            }</a>
<a name="ln789"> </a>
<a name="ln790">            /* len is actual number of white characters used */</a>
<a name="ln791">            len = num_spaces + num_tabs;</a>
<a name="ln792">            old_len = (long)STRLEN(ptr);</a>
<a name="ln793">            long new_len = old_len - col + start_col + len + 1;</a>
<a name="ln794">            new_line = xmalloc(new_len);</a>
<a name="ln795"> </a>
<a name="ln796">            if (start_col &gt; 0)</a>
<a name="ln797">              memmove(new_line, ptr, (size_t)start_col);</a>
<a name="ln798">            memmove(new_line + start_col + len,</a>
<a name="ln799">                ptr + col, (size_t)(old_len - col + 1));</a>
<a name="ln800">            ptr = new_line + start_col;</a>
<a name="ln801">            for (col = 0; col &lt; len; col++) {</a>
<a name="ln802">              ptr[col] = (col &lt; num_tabs) ? '\t' : ' ';</a>
<a name="ln803">            }</a>
<a name="ln804">            if (ml_replace(lnum, new_line, false) == OK) {</a>
<a name="ln805">              // &quot;new_line&quot; may have been copied</a>
<a name="ln806">              new_line = curbuf-&gt;b_ml.ml_line_ptr;</a>
<a name="ln807">              extmark_splice_cols(curbuf, lnum - 1, 0, (colnr_T)old_len,</a>
<a name="ln808">                                  (colnr_T)new_len - 1, kExtmarkUndo);</a>
<a name="ln809">            }</a>
<a name="ln810">            if (first_line == 0) {</a>
<a name="ln811">              first_line = lnum;</a>
<a name="ln812">            }</a>
<a name="ln813">            last_line = lnum;</a>
<a name="ln814">            ptr = new_line;</a>
<a name="ln815">            col = start_col + len;</a>
<a name="ln816">          }</a>
<a name="ln817">        }</a>
<a name="ln818">        got_tab = FALSE;</a>
<a name="ln819">        num_spaces = 0;</a>
<a name="ln820">      }</a>
<a name="ln821">      if (ptr[col] == NUL)</a>
<a name="ln822">        break;</a>
<a name="ln823">      vcol += chartabsize(ptr + col, (colnr_T)vcol);</a>
<a name="ln824">      col += utfc_ptr2len(ptr + col);</a>
<a name="ln825">    }</a>
<a name="ln826">    if (new_line == NULL)                   /* out of memory */</a>
<a name="ln827">      break;</a>
<a name="ln828">    line_breakcheck();</a>
<a name="ln829">  }</a>
<a name="ln830">  if (got_int)</a>
<a name="ln831">    EMSG(_(e_interr));</a>
<a name="ln832"> </a>
<a name="ln833">  // If a single value was given then it can be considered equal to</a>
<a name="ln834">  // either the value of 'tabstop' or the value of 'vartabstop'.</a>
<a name="ln835">  if (tabstop_count(curbuf-&gt;b_p_vts_array) == 0</a>
<a name="ln836">      &amp;&amp; tabstop_count(new_vts_array) == 1</a>
<a name="ln837">      &amp;&amp; curbuf-&gt;b_p_ts == tabstop_first(new_vts_array)) {</a>
<a name="ln838">    // not changed</a>
<a name="ln839">  } else if (tabstop_count(curbuf-&gt;b_p_vts_array) &gt; 0</a>
<a name="ln840">             &amp;&amp; tabstop_eq(curbuf-&gt;b_p_vts_array, new_vts_array)) {</a>
<a name="ln841">    // not changed</a>
<a name="ln842">  } else {</a>
<a name="ln843">    redraw_curbuf_later(NOT_VALID);</a>
<a name="ln844">  }</a>
<a name="ln845">  if (first_line != 0) {</a>
<a name="ln846">    changed_lines(first_line, 0, last_line + 1, 0L, true);</a>
<a name="ln847">  }</a>
<a name="ln848"> </a>
<a name="ln849">  curwin-&gt;w_p_list = save_list;         /* restore 'list' */</a>
<a name="ln850"> </a>
<a name="ln851">  if (new_ts_str != NULL) {  // set the new tabstop</a>
<a name="ln852">    // If 'vartabstop' is in use or if the value given to retab has more</a>
<a name="ln853">    // than one tabstop then update 'vartabstop'.</a>
<a name="ln854">    long *old_vts_ary = curbuf-&gt;b_p_vts_array;</a>
<a name="ln855"> </a>
<a name="ln856">    if (tabstop_count(old_vts_ary) &gt; 0 || tabstop_count(new_vts_array) &gt; 1) {</a>
<a name="ln857">      set_string_option_direct(&quot;vts&quot;, -1, new_ts_str,</a>
<a name="ln858">                               OPT_FREE | OPT_LOCAL, 0);</a>
<a name="ln859">      curbuf-&gt;b_p_vts_array = new_vts_array;</a>
<a name="ln860">      xfree(old_vts_ary);</a>
<a name="ln861">    } else {</a>
<a name="ln862">      // 'vartabstop' wasn't in use and a single value was given to</a>
<a name="ln863">      // retab then update 'tabstop'.</a>
<a name="ln864">      curbuf-&gt;b_p_ts = tabstop_first(new_vts_array);</a>
<a name="ln865">      xfree(new_vts_array);</a>
<a name="ln866">    }</a>
<a name="ln867">    xfree(new_ts_str);</a>
<a name="ln868">  }</a>
<a name="ln869">  coladvance(curwin-&gt;w_curswant);</a>
<a name="ln870"> </a>
<a name="ln871">  u_clearline();</a>
<a name="ln872">}</a>
<a name="ln873"> </a>
<a name="ln874">/*</a>
<a name="ln875"> * :move command - move lines line1-line2 to line dest</a>
<a name="ln876"> *</a>
<a name="ln877"> * return FAIL for failure, OK otherwise</a>
<a name="ln878"> */</a>
<a name="ln879">int do_move(linenr_T line1, linenr_T line2, linenr_T dest)</a>
<a name="ln880">{</a>
<a name="ln881">  char_u      *str;</a>
<a name="ln882">  linenr_T l;</a>
<a name="ln883">  linenr_T extra;      // Num lines added before line1</a>
<a name="ln884">  linenr_T num_lines;  // Num lines moved</a>
<a name="ln885">  linenr_T last_line;  // Last line in file after adding new text</a>
<a name="ln886"> </a>
<a name="ln887">  if (dest &gt;= line1 &amp;&amp; dest &lt; line2) {</a>
<a name="ln888">    EMSG(_(&quot;E134: Cannot move a range of lines into itself&quot;));</a>
<a name="ln889">    return FAIL;</a>
<a name="ln890">  }</a>
<a name="ln891"> </a>
<a name="ln892">  // Do nothing if we are not actually moving any lines.  This will prevent</a>
<a name="ln893">  // the 'modified' flag from being set without cause.</a>
<a name="ln894">  if (dest == line1 - 1 || dest == line2) {</a>
<a name="ln895">    // Move the cursor as if lines were moved (see below) to be backwards</a>
<a name="ln896">    // compatible.</a>
<a name="ln897">    if (dest &gt;= line1) {</a>
<a name="ln898">      curwin-&gt;w_cursor.lnum = dest;</a>
<a name="ln899">    } else {</a>
<a name="ln900">      curwin-&gt;w_cursor.lnum = dest + (line2 - line1) + 1;</a>
<a name="ln901">    }</a>
<a name="ln902">    return OK;</a>
<a name="ln903">  }</a>
<a name="ln904"> </a>
<a name="ln905">  bcount_t start_byte = ml_find_line_or_offset(curbuf, line1, NULL, true);</a>
<a name="ln906">  bcount_t end_byte = ml_find_line_or_offset(curbuf, line2+1, NULL, true);</a>
<a name="ln907">  bcount_t extent_byte = end_byte-start_byte;</a>
<a name="ln908">  bcount_t dest_byte = ml_find_line_or_offset(curbuf, dest+1, NULL, true);</a>
<a name="ln909"> </a>
<a name="ln910">  num_lines = line2 - line1 + 1;</a>
<a name="ln911"> </a>
<a name="ln912">  /*</a>
<a name="ln913">   * First we copy the old text to its new location -- webb</a>
<a name="ln914">   * Also copy the flag that &quot;:global&quot; command uses.</a>
<a name="ln915">   */</a>
<a name="ln916">  if (u_save(dest, dest + 1) == FAIL)</a>
<a name="ln917">    return FAIL;</a>
<a name="ln918">  for (extra = 0, l = line1; l &lt;= line2; l++) {</a>
<a name="ln919">    str = vim_strsave(ml_get(l + extra));</a>
<a name="ln920">    ml_append(dest + l - line1, str, (colnr_T)0, false);</a>
<a name="ln921">    xfree(str);</a>
<a name="ln922">    if (dest &lt; line1)</a>
<a name="ln923">      extra++;</a>
<a name="ln924">  }</a>
<a name="ln925"> </a>
<a name="ln926">  /*</a>
<a name="ln927">   * Now we must be careful adjusting our marks so that we don't overlap our</a>
<a name="ln928">   * mark_adjust() calls.</a>
<a name="ln929">   *</a>
<a name="ln930">   * We adjust the marks within the old text so that they refer to the</a>
<a name="ln931">   * last lines of the file (temporarily), because we know no other marks</a>
<a name="ln932">   * will be set there since these line numbers did not exist until we added</a>
<a name="ln933">   * our new lines.</a>
<a name="ln934">   *</a>
<a name="ln935">   * Then we adjust the marks on lines between the old and new text positions</a>
<a name="ln936">   * (either forwards or backwards).</a>
<a name="ln937">   *</a>
<a name="ln938">   * And Finally we adjust the marks we put at the end of the file back to</a>
<a name="ln939">   * their final destination at the new text position -- webb</a>
<a name="ln940">   */</a>
<a name="ln941">  last_line = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln942">  mark_adjust_nofold(line1, line2, last_line - line2, 0L, kExtmarkNOOP);</a>
<a name="ln943">  changed_lines(last_line - num_lines + 1, 0, last_line + 1, num_lines, false);</a>
<a name="ln944">  int line_off = 0;</a>
<a name="ln945">  bcount_t byte_off = 0;</a>
<a name="ln946">  if (dest &gt;= line2) {</a>
<a name="ln947">    mark_adjust_nofold(line2 + 1, dest, -num_lines, 0L, kExtmarkNOOP);</a>
<a name="ln948">    FOR_ALL_TAB_WINDOWS(tab, win) {</a>
<a name="ln949">      if (win-&gt;w_buffer == curbuf) {</a>
<a name="ln950">        foldMoveRange(win, &amp;win-&gt;w_folds, line1, line2, dest);</a>
<a name="ln951">      }</a>
<a name="ln952">    }</a>
<a name="ln953">    curbuf-&gt;b_op_start.lnum = dest - num_lines + 1;</a>
<a name="ln954">    curbuf-&gt;b_op_end.lnum = dest;</a>
<a name="ln955">    line_off = -num_lines;</a>
<a name="ln956">    byte_off = -extent_byte;</a>
<a name="ln957">  } else {</a>
<a name="ln958">    mark_adjust_nofold(dest + 1, line1 - 1, num_lines, 0L, kExtmarkNOOP);</a>
<a name="ln959">    FOR_ALL_TAB_WINDOWS(tab, win) {</a>
<a name="ln960">      if (win-&gt;w_buffer == curbuf) {</a>
<a name="ln961">        foldMoveRange(win, &amp;win-&gt;w_folds, dest + 1, line1 - 1, line2);</a>
<a name="ln962">      }</a>
<a name="ln963">    }</a>
<a name="ln964">    curbuf-&gt;b_op_start.lnum = dest + 1;</a>
<a name="ln965">    curbuf-&gt;b_op_end.lnum = dest + num_lines;</a>
<a name="ln966">  }</a>
<a name="ln967">  curbuf-&gt;b_op_start.col = curbuf-&gt;b_op_end.col = 0;</a>
<a name="ln968">  mark_adjust_nofold(last_line - num_lines + 1, last_line,</a>
<a name="ln969">                     -(last_line - dest - extra), 0L, kExtmarkNOOP);</a>
<a name="ln970"> </a>
<a name="ln971">  changed_lines(last_line - num_lines + 1, 0, last_line + 1, -extra, false);</a>
<a name="ln972"> </a>
<a name="ln973">  // send update regarding the new lines that were added</a>
<a name="ln974">  buf_updates_send_changes(curbuf, dest + 1, num_lines, 0, true);</a>
<a name="ln975"> </a>
<a name="ln976">  /*</a>
<a name="ln977">   * Now we delete the original text -- webb</a>
<a name="ln978">   */</a>
<a name="ln979">  if (u_save(line1 + extra - 1, line2 + extra + 1) == FAIL)</a>
<a name="ln980">    return FAIL;</a>
<a name="ln981"> </a>
<a name="ln982">  for (l = line1; l &lt;= line2; l++) {</a>
<a name="ln983">    ml_delete(line1 + extra, true);</a>
<a name="ln984">  }</a>
<a name="ln985">  if (!global_busy &amp;&amp; num_lines &gt; p_report) {</a>
<a name="ln986">    if (num_lines == 1)</a>
<a name="ln987">      MSG(_(&quot;1 line moved&quot;));</a>
<a name="ln988">    else</a>
<a name="ln989">      smsg(_(&quot;%&quot; PRId64 &quot; lines moved&quot;), (int64_t)num_lines);</a>
<a name="ln990">  }</a>
<a name="ln991"> </a>
<a name="ln992">  extmark_move_region(curbuf, line1-1, 0, start_byte,</a>
<a name="ln993">                      line2-line1+1, 0, extent_byte,</a>
<a name="ln994">                      dest+line_off, 0, dest_byte+byte_off,</a>
<a name="ln995">                      kExtmarkUndo);</a>
<a name="ln996"> </a>
<a name="ln997">  /*</a>
<a name="ln998">   * Leave the cursor on the last of the moved lines.</a>
<a name="ln999">   */</a>
<a name="ln1000">  if (dest &gt;= line1)</a>
<a name="ln1001">    curwin-&gt;w_cursor.lnum = dest;</a>
<a name="ln1002">  else</a>
<a name="ln1003">    curwin-&gt;w_cursor.lnum = dest + (line2 - line1) + 1;</a>
<a name="ln1004"> </a>
<a name="ln1005">  if (line1 &lt; dest) {</a>
<a name="ln1006">    dest += num_lines + 1;</a>
<a name="ln1007">    last_line = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1008">    if (dest &gt; last_line + 1)</a>
<a name="ln1009">      dest = last_line + 1;</a>
<a name="ln1010">    changed_lines(line1, 0, dest, 0L, false);</a>
<a name="ln1011">  } else {</a>
<a name="ln1012">    changed_lines(dest + 1, 0, line1 + num_lines, 0L, false);</a>
<a name="ln1013">  }</a>
<a name="ln1014"> </a>
<a name="ln1015">  // send nvim_buf_lines_event regarding lines that were deleted</a>
<a name="ln1016">  buf_updates_send_changes(curbuf, line1 + extra, 0, num_lines, true);</a>
<a name="ln1017"> </a>
<a name="ln1018">  return OK;</a>
<a name="ln1019">}</a>
<a name="ln1020"> </a>
<a name="ln1021">/*</a>
<a name="ln1022"> * &quot;:copy&quot;</a>
<a name="ln1023"> */</a>
<a name="ln1024">void ex_copy(linenr_T line1, linenr_T line2, linenr_T n)</a>
<a name="ln1025">{</a>
<a name="ln1026">  linenr_T count;</a>
<a name="ln1027">  char_u      *p;</a>
<a name="ln1028"> </a>
<a name="ln1029">  count = line2 - line1 + 1;</a>
<a name="ln1030">  curbuf-&gt;b_op_start.lnum = n + 1;</a>
<a name="ln1031">  curbuf-&gt;b_op_end.lnum = n + count;</a>
<a name="ln1032">  curbuf-&gt;b_op_start.col = curbuf-&gt;b_op_end.col = 0;</a>
<a name="ln1033"> </a>
<a name="ln1034">  /*</a>
<a name="ln1035">   * there are three situations:</a>
<a name="ln1036">   * 1. destination is above line1</a>
<a name="ln1037">   * 2. destination is between line1 and line2</a>
<a name="ln1038">   * 3. destination is below line2</a>
<a name="ln1039">   *</a>
<a name="ln1040">   * n = destination (when starting)</a>
<a name="ln1041">   * curwin-&gt;w_cursor.lnum = destination (while copying)</a>
<a name="ln1042">   * line1 = start of source (while copying)</a>
<a name="ln1043">   * line2 = end of source (while copying)</a>
<a name="ln1044">   */</a>
<a name="ln1045">  if (u_save(n, n + 1) == FAIL)</a>
<a name="ln1046">    return;</a>
<a name="ln1047"> </a>
<a name="ln1048">  curwin-&gt;w_cursor.lnum = n;</a>
<a name="ln1049">  while (line1 &lt;= line2) {</a>
<a name="ln1050">    /* need to use vim_strsave() because the line will be unlocked within</a>
<a name="ln1051">     * ml_append() */</a>
<a name="ln1052">    p = vim_strsave(ml_get(line1));</a>
<a name="ln1053">    ml_append(curwin-&gt;w_cursor.lnum, p, (colnr_T)0, false);</a>
<a name="ln1054">    xfree(p);</a>
<a name="ln1055"> </a>
<a name="ln1056">    /* situation 2: skip already copied lines */</a>
<a name="ln1057">    if (line1 == n)</a>
<a name="ln1058">      line1 = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1059">    ++line1;</a>
<a name="ln1060">    if (curwin-&gt;w_cursor.lnum &lt; line1)</a>
<a name="ln1061">      ++line1;</a>
<a name="ln1062">    if (curwin-&gt;w_cursor.lnum &lt; line2)</a>
<a name="ln1063">      ++line2;</a>
<a name="ln1064">    ++curwin-&gt;w_cursor.lnum;</a>
<a name="ln1065">  }</a>
<a name="ln1066"> </a>
<a name="ln1067">  appended_lines_mark(n, count);</a>
<a name="ln1068"> </a>
<a name="ln1069">  msgmore((long)count);</a>
<a name="ln1070">}</a>
<a name="ln1071"> </a>
<a name="ln1072">static char_u   *prevcmd = NULL;        /* the previous command */</a>
<a name="ln1073"> </a>
<a name="ln1074">#if defined(EXITFREE)</a>
<a name="ln1075">void free_prev_shellcmd(void)</a>
<a name="ln1076">{</a>
<a name="ln1077">  xfree(prevcmd);</a>
<a name="ln1078">}</a>
<a name="ln1079"> </a>
<a name="ln1080">#endif</a>
<a name="ln1081"> </a>
<a name="ln1082">/*</a>
<a name="ln1083"> * Handle the &quot;:!cmd&quot; command.	Also for &quot;:r !cmd&quot; and &quot;:w !cmd&quot;</a>
<a name="ln1084"> * Bangs in the argument are replaced with the previously entered command.</a>
<a name="ln1085"> * Remember the argument.</a>
<a name="ln1086"> */</a>
<a name="ln1087">void do_bang(int addr_count, exarg_T *eap, bool forceit,</a>
<a name="ln1088">             bool do_in, bool do_out)</a>
<a name="ln1089">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1090">{</a>
<a name="ln1091">  char_u *arg = eap-&gt;arg;             // command</a>
<a name="ln1092">  linenr_T line1 = eap-&gt;line1;        // start of range</a>
<a name="ln1093">  linenr_T line2 = eap-&gt;line2;        // end of range</a>
<a name="ln1094">  char_u *newcmd = NULL;              // the new command</a>
<a name="ln1095">  bool free_newcmd = false;           // need to free() newcmd</a>
<a name="ln1096">  char_u              *t;</a>
<a name="ln1097">  char_u              *p;</a>
<a name="ln1098">  char_u              *trailarg;</a>
<a name="ln1099">  int len;</a>
<a name="ln1100">  int scroll_save = msg_scroll;</a>
<a name="ln1101"> </a>
<a name="ln1102">  //</a>
<a name="ln1103">  // Disallow shell commands from .exrc and .vimrc in current directory for</a>
<a name="ln1104">  // security reasons.</a>
<a name="ln1105">  //</a>
<a name="ln1106">  if (check_secure()) {</a>
<a name="ln1107">    return;</a>
<a name="ln1108">  }</a>
<a name="ln1109"> </a>
<a name="ln1110">  if (addr_count == 0) {                /* :! */</a>
<a name="ln1111">    msg_scroll = FALSE;             /* don't scroll here */</a>
<a name="ln1112">    autowrite_all();</a>
<a name="ln1113">    msg_scroll = scroll_save;</a>
<a name="ln1114">  }</a>
<a name="ln1115"> </a>
<a name="ln1116">  /*</a>
<a name="ln1117">   * Try to find an embedded bang, like in :!&lt;cmd&gt; ! [args]</a>
<a name="ln1118">   * (:!! is indicated by the 'forceit' variable)</a>
<a name="ln1119">   */</a>
<a name="ln1120">  bool ins_prevcmd = forceit;</a>
<a name="ln1121">  trailarg = arg;</a>
<a name="ln1122">  do {</a>
<a name="ln1123">    len = (int)STRLEN(trailarg) + 1;</a>
<a name="ln1124">    if (newcmd != NULL)</a>
<a name="ln1125">      len += (int)STRLEN(newcmd);</a>
<a name="ln1126">    if (ins_prevcmd) {</a>
<a name="ln1127">      if (prevcmd == NULL) {</a>
<a name="ln1128">        EMSG(_(e_noprev));</a>
<a name="ln1129">        xfree(newcmd);</a>
<a name="ln1130">        return;</a>
<a name="ln1131">      }</a>
<a name="ln1132">      len += (int)STRLEN(prevcmd);</a>
<a name="ln1133">    }</a>
<a name="ln1134">    t = xmalloc(len);</a>
<a name="ln1135">    *t = NUL;</a>
<a name="ln1136">    if (newcmd != NULL)</a>
<a name="ln1137">      STRCAT(t, newcmd);</a>
<a name="ln1138">    if (ins_prevcmd)</a>
<a name="ln1139">      STRCAT(t, prevcmd);</a>
<a name="ln1140">    p = t + STRLEN(t);</a>
<a name="ln1141">    STRCAT(t, trailarg);</a>
<a name="ln1142">    xfree(newcmd);</a>
<a name="ln1143">    newcmd = t;</a>
<a name="ln1144"> </a>
<a name="ln1145">    /*</a>
<a name="ln1146">     * Scan the rest of the argument for '!', which is replaced by the</a>
<a name="ln1147">     * previous command.  &quot;\!&quot; is replaced by &quot;!&quot; (this is vi compatible).</a>
<a name="ln1148">     */</a>
<a name="ln1149">    trailarg = NULL;</a>
<a name="ln1150">    while (*p) {</a>
<a name="ln1151">      if (*p == '!') {</a>
<a name="ln1152">        if (p &gt; newcmd &amp;&amp; p[-1] == '\\')</a>
<a name="ln1153">          STRMOVE(p - 1, p);</a>
<a name="ln1154">        else {</a>
<a name="ln1155">          trailarg = p;</a>
<a name="ln1156">          *trailarg++ = NUL;</a>
<a name="ln1157">          ins_prevcmd = true;</a>
<a name="ln1158">          break;</a>
<a name="ln1159">        }</a>
<a name="ln1160">      }</a>
<a name="ln1161">      ++p;</a>
<a name="ln1162">    }</a>
<a name="ln1163">  } while (trailarg != NULL);</a>
<a name="ln1164"> </a>
<a name="ln1165">  xfree(prevcmd);</a>
<a name="ln1166">  prevcmd = newcmd;</a>
<a name="ln1167"> </a>
<a name="ln1168">  if (bangredo) { /* put cmd in redo buffer for ! command */</a>
<a name="ln1169">    /* If % or # appears in the command, it must have been escaped.</a>
<a name="ln1170">     * Reescape them, so that redoing them does not substitute them by the</a>
<a name="ln1171">     * buffername. */</a>
<a name="ln1172">    char_u *cmd = vim_strsave_escaped(prevcmd, (char_u *)&quot;%#&quot;);</a>
<a name="ln1173"> </a>
<a name="ln1174">    AppendToRedobuffLit(cmd, -1);</a>
<a name="ln1175">    xfree(cmd);</a>
<a name="ln1176">    AppendToRedobuff(&quot;\n&quot;);</a>
<a name="ln1177">    bangredo = false;</a>
<a name="ln1178">  }</a>
<a name="ln1179">  /*</a>
<a name="ln1180">   * Add quotes around the command, for shells that need them.</a>
<a name="ln1181">   */</a>
<a name="ln1182">  if (*p_shq != NUL) {</a>
<a name="ln1183">    newcmd = xmalloc(STRLEN(prevcmd) + 2 * STRLEN(p_shq) + 1);</a>
<a name="ln1184">    STRCPY(newcmd, p_shq);</a>
<a name="ln1185">    STRCAT(newcmd, prevcmd);</a>
<a name="ln1186">    STRCAT(newcmd, p_shq);</a>
<a name="ln1187">    free_newcmd = true;</a>
<a name="ln1188">  }</a>
<a name="ln1189">  if (addr_count == 0) {                /* :! */</a>
<a name="ln1190">    /* echo the command */</a>
<a name="ln1191">    msg_start();</a>
<a name="ln1192">    msg_putchar(':');</a>
<a name="ln1193">    msg_putchar('!');</a>
<a name="ln1194">    msg_outtrans(newcmd);</a>
<a name="ln1195">    msg_clr_eos();</a>
<a name="ln1196">    ui_cursor_goto(msg_row, msg_col);</a>
<a name="ln1197"> </a>
<a name="ln1198">    do_shell(newcmd, 0);</a>
<a name="ln1199">  } else {                            /* :range! */</a>
<a name="ln1200">    /* Careful: This may recursively call do_bang() again! (because of</a>
<a name="ln1201">     * autocommands) */</a>
<a name="ln1202">    do_filter(line1, line2, eap, newcmd, do_in, do_out);</a>
<a name="ln1203">    apply_autocmds(EVENT_SHELLFILTERPOST, NULL, NULL, FALSE, curbuf);</a>
<a name="ln1204">  }</a>
<a name="ln1205">  if (free_newcmd)</a>
<a name="ln1206">    xfree(newcmd);</a>
<a name="ln1207">}</a>
<a name="ln1208"> </a>
<a name="ln1209">// do_filter: filter lines through a command given by the user</a>
<a name="ln1210">//</a>
<a name="ln1211">// We mostly use temp files and the call_shell() routine here. This would</a>
<a name="ln1212">// normally be done using pipes on a Unix system, but this is more portable</a>
<a name="ln1213">// to non-Unix systems. The call_shell() routine needs to be able</a>
<a name="ln1214">// to deal with redirection somehow, and should handle things like looking</a>
<a name="ln1215">// at the PATH env. variable, and adding reasonable extensions to the</a>
<a name="ln1216">// command name given by the user. All reasonable versions of call_shell()</a>
<a name="ln1217">// do this.</a>
<a name="ln1218">// Alternatively, if on Unix and redirecting input or output, but not both,</a>
<a name="ln1219">// and the 'shelltemp' option isn't set, use pipes.</a>
<a name="ln1220">// We use input redirection if do_in is true.</a>
<a name="ln1221">// We use output redirection if do_out is true.</a>
<a name="ln1222">static void do_filter(</a>
<a name="ln1223">    linenr_T line1,</a>
<a name="ln1224">    linenr_T line2,</a>
<a name="ln1225">    exarg_T *eap,               /* for forced 'ff' and 'fenc' */</a>
<a name="ln1226">    char_u *cmd,</a>
<a name="ln1227">    bool do_in,</a>
<a name="ln1228">    bool do_out)</a>
<a name="ln1229">{</a>
<a name="ln1230">  char_u      *itmp = NULL;</a>
<a name="ln1231">  char_u      *otmp = NULL;</a>
<a name="ln1232">  linenr_T linecount;</a>
<a name="ln1233">  linenr_T read_linecount;</a>
<a name="ln1234">  pos_T cursor_save;</a>
<a name="ln1235">  char_u      *cmd_buf;</a>
<a name="ln1236">  buf_T       *old_curbuf = curbuf;</a>
<a name="ln1237">  int shell_flags = 0;</a>
<a name="ln1238">  const int stmp = p_stmp;</a>
<a name="ln1239"> </a>
<a name="ln1240">  if (*cmd == NUL)          /* no filter command */</a>
<a name="ln1241">    return;</a>
<a name="ln1242"> </a>
<a name="ln1243"> </a>
<a name="ln1244">  cursor_save = curwin-&gt;w_cursor;</a>
<a name="ln1245">  linecount = line2 - line1 + 1;</a>
<a name="ln1246">  curwin-&gt;w_cursor.lnum = line1;</a>
<a name="ln1247">  curwin-&gt;w_cursor.col = 0;</a>
<a name="ln1248">  changed_line_abv_curs();</a>
<a name="ln1249">  invalidate_botline();</a>
<a name="ln1250"> </a>
<a name="ln1251">  /*</a>
<a name="ln1252">   * When using temp files:</a>
<a name="ln1253">   * 1. * Form temp file names</a>
<a name="ln1254">   * 2. * Write the lines to a temp file</a>
<a name="ln1255">   * 3.   Run the filter command on the temp file</a>
<a name="ln1256">   * 4. * Read the output of the command into the buffer</a>
<a name="ln1257">   * 5. * Delete the original lines to be filtered</a>
<a name="ln1258">   * 6. * Remove the temp files</a>
<a name="ln1259">   *</a>
<a name="ln1260">   * When writing the input with a pipe or when catching the output with a</a>
<a name="ln1261">   * pipe only need to do 3.</a>
<a name="ln1262">   */</a>
<a name="ln1263"> </a>
<a name="ln1264">  if (do_out)</a>
<a name="ln1265">    shell_flags |= kShellOptDoOut;</a>
<a name="ln1266"> </a>
<a name="ln1267">  if (!do_in &amp;&amp; do_out &amp;&amp; !stmp) {</a>
<a name="ln1268">    // Use a pipe to fetch stdout of the command, do not use a temp file.</a>
<a name="ln1269">    shell_flags |= kShellOptRead;</a>
<a name="ln1270">    curwin-&gt;w_cursor.lnum = line2;</a>
<a name="ln1271">  } else if (do_in &amp;&amp; !do_out &amp;&amp; !stmp) {</a>
<a name="ln1272">    // Use a pipe to write stdin of the command, do not use a temp file.</a>
<a name="ln1273">    shell_flags |= kShellOptWrite;</a>
<a name="ln1274">    curbuf-&gt;b_op_start.lnum = line1;</a>
<a name="ln1275">    curbuf-&gt;b_op_end.lnum = line2;</a>
<a name="ln1276">  } else if (do_in &amp;&amp; do_out &amp;&amp; !stmp) {</a>
<a name="ln1277">    // Use a pipe to write stdin and fetch stdout of the command, do not</a>
<a name="ln1278">    // use a temp file.</a>
<a name="ln1279">    shell_flags |= kShellOptRead | kShellOptWrite;</a>
<a name="ln1280">    curbuf-&gt;b_op_start.lnum = line1;</a>
<a name="ln1281">    curbuf-&gt;b_op_end.lnum = line2;</a>
<a name="ln1282">    curwin-&gt;w_cursor.lnum = line2;</a>
<a name="ln1283">  } else if ((do_in &amp;&amp; (itmp = vim_tempname()) == NULL)</a>
<a name="ln1284">      || (do_out &amp;&amp; (otmp = vim_tempname()) == NULL)) {</a>
<a name="ln1285">    EMSG(_(e_notmp));</a>
<a name="ln1286">    goto filterend;</a>
<a name="ln1287">  }</a>
<a name="ln1288"> </a>
<a name="ln1289">  /*</a>
<a name="ln1290">   * The writing and reading of temp files will not be shown.</a>
<a name="ln1291">   * Vi also doesn't do this and the messages are not very informative.</a>
<a name="ln1292">   */</a>
<a name="ln1293">  ++no_wait_return;             /* don't call wait_return() while busy */</a>
<a name="ln1294">  if (itmp != NULL &amp;&amp; buf_write(curbuf, itmp, NULL, line1, line2, eap,</a>
<a name="ln1295">                                false, false, false, true) == FAIL) {</a>
<a name="ln1296">    msg_putchar('\n');  // Keep message from buf_write().</a>
<a name="ln1297">    no_wait_return--;</a>
<a name="ln1298">    if (!aborting()) {</a>
<a name="ln1299">      EMSG2(_(&quot;E482: Can't create file %s&quot;), itmp);  // Will call wait_return.</a>
<a name="ln1300">    }</a>
<a name="ln1301">    goto filterend;</a>
<a name="ln1302">  }</a>
<a name="ln1303">  if (curbuf != old_curbuf)</a>
<a name="ln1304">    goto filterend;</a>
<a name="ln1305"> </a>
<a name="ln1306">  if (!do_out)</a>
<a name="ln1307">    msg_putchar('\n');</a>
<a name="ln1308"> </a>
<a name="ln1309">  /* Create the shell command in allocated memory. */</a>
<a name="ln1310">  cmd_buf = make_filter_cmd(cmd, itmp, otmp);</a>
<a name="ln1311">  ui_cursor_goto(Rows - 1, 0);</a>
<a name="ln1312"> </a>
<a name="ln1313">  if (do_out) {</a>
<a name="ln1314">    if (u_save((linenr_T)(line2), (linenr_T)(line2 + 1)) == FAIL) {</a>
<a name="ln1315">      xfree(cmd_buf);</a>
<a name="ln1316">      goto error;</a>
<a name="ln1317">    }</a>
<a name="ln1318">    redraw_curbuf_later(VALID);</a>
<a name="ln1319">  }</a>
<a name="ln1320">  read_linecount = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1321"> </a>
<a name="ln1322">  // Pass on the kShellOptDoOut flag when the output is being redirected.</a>
<a name="ln1323">  call_shell(cmd_buf, kShellOptFilter | shell_flags, NULL);</a>
<a name="ln1324">  xfree(cmd_buf);</a>
<a name="ln1325"> </a>
<a name="ln1326">  did_check_timestamps = FALSE;</a>
<a name="ln1327">  need_check_timestamps = TRUE;</a>
<a name="ln1328"> </a>
<a name="ln1329">  /* When interrupting the shell command, it may still have produced some</a>
<a name="ln1330">   * useful output.  Reset got_int here, so that readfile() won't cancel</a>
<a name="ln1331">   * reading. */</a>
<a name="ln1332">  os_breakcheck();</a>
<a name="ln1333">  got_int = FALSE;</a>
<a name="ln1334"> </a>
<a name="ln1335">  if (do_out) {</a>
<a name="ln1336">    if (otmp != NULL) {</a>
<a name="ln1337">      if (readfile(otmp, NULL, line2, (linenr_T)0, (linenr_T)MAXLNUM, eap,</a>
<a name="ln1338">                   READ_FILTER) != OK) {</a>
<a name="ln1339">        if (!aborting()) {</a>
<a name="ln1340">          msg_putchar('\n');</a>
<a name="ln1341">          EMSG2(_(e_notread), otmp);</a>
<a name="ln1342">        }</a>
<a name="ln1343">        goto error;</a>
<a name="ln1344">      }</a>
<a name="ln1345">      if (curbuf != old_curbuf)</a>
<a name="ln1346">        goto filterend;</a>
<a name="ln1347">    }</a>
<a name="ln1348"> </a>
<a name="ln1349">    read_linecount = curbuf-&gt;b_ml.ml_line_count - read_linecount;</a>
<a name="ln1350"> </a>
<a name="ln1351">    if (shell_flags &amp; kShellOptRead) {</a>
<a name="ln1352">      curbuf-&gt;b_op_start.lnum = line2 + 1;</a>
<a name="ln1353">      curbuf-&gt;b_op_end.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1354">      appended_lines_mark(line2, read_linecount);</a>
<a name="ln1355">    }</a>
<a name="ln1356"> </a>
<a name="ln1357">    if (do_in) {</a>
<a name="ln1358">      if (cmdmod.keepmarks || vim_strchr(p_cpo, CPO_REMMARK) == NULL) {</a>
<a name="ln1359">        // TODO(bfredl): Currently not active for extmarks. What would we</a>
<a name="ln1360">        // do if columns don't match, assume added/deleted bytes at the</a>
<a name="ln1361">        // end of each line?</a>
<a name="ln1362">        if (read_linecount &gt;= linecount) {</a>
<a name="ln1363">          // move all marks from old lines to new lines</a>
<a name="ln1364">          mark_adjust(line1, line2, linecount, 0L, kExtmarkNOOP);</a>
<a name="ln1365">        } else {</a>
<a name="ln1366">          // move marks from old lines to new lines, delete marks</a>
<a name="ln1367">          // that are in deleted lines</a>
<a name="ln1368">          mark_adjust(line1, line1 + read_linecount - 1, linecount, 0L,</a>
<a name="ln1369">                      kExtmarkNOOP);</a>
<a name="ln1370">          mark_adjust(line1 + read_linecount, line2, MAXLNUM, 0L,</a>
<a name="ln1371">                      kExtmarkNOOP);</a>
<a name="ln1372">        }</a>
<a name="ln1373">      }</a>
<a name="ln1374"> </a>
<a name="ln1375">      /*</a>
<a name="ln1376">       * Put cursor on first filtered line for &quot;:range!cmd&quot;.</a>
<a name="ln1377">       * Adjust '[ and '] (set by buf_write()).</a>
<a name="ln1378">       */</a>
<a name="ln1379">      curwin-&gt;w_cursor.lnum = line1;</a>
<a name="ln1380">      del_lines(linecount, TRUE);</a>
<a name="ln1381">      curbuf-&gt;b_op_start.lnum -= linecount;             /* adjust '[ */</a>
<a name="ln1382">      curbuf-&gt;b_op_end.lnum -= linecount;               /* adjust '] */</a>
<a name="ln1383">      write_lnum_adjust(-linecount);                    /* adjust last line</a>
<a name="ln1384">                                                           for next write */</a>
<a name="ln1385">      foldUpdate(curwin, curbuf-&gt;b_op_start.lnum, curbuf-&gt;b_op_end.lnum);</a>
<a name="ln1386">    } else {</a>
<a name="ln1387">      /*</a>
<a name="ln1388">       * Put cursor on last new line for &quot;:r !cmd&quot;.</a>
<a name="ln1389">       */</a>
<a name="ln1390">      linecount = curbuf-&gt;b_op_end.lnum - curbuf-&gt;b_op_start.lnum + 1;</a>
<a name="ln1391">      curwin-&gt;w_cursor.lnum = curbuf-&gt;b_op_end.lnum;</a>
<a name="ln1392">    }</a>
<a name="ln1393"> </a>
<a name="ln1394">    beginline(BL_WHITE | BL_FIX);           /* cursor on first non-blank */</a>
<a name="ln1395">    --no_wait_return;</a>
<a name="ln1396"> </a>
<a name="ln1397">    if (linecount &gt; p_report) {</a>
<a name="ln1398">      if (do_in) {</a>
<a name="ln1399">        vim_snprintf((char *)msg_buf, sizeof(msg_buf),</a>
<a name="ln1400">            _(&quot;%&quot; PRId64 &quot; lines filtered&quot;), (int64_t)linecount);</a>
<a name="ln1401">        if (msg(msg_buf) &amp;&amp; !msg_scroll)</a>
<a name="ln1402">          /* save message to display it after redraw */</a>
<a name="ln1403">          set_keep_msg(msg_buf, 0);</a>
<a name="ln1404">      } else</a>
<a name="ln1405">        msgmore((long)linecount);</a>
<a name="ln1406">    }</a>
<a name="ln1407">  } else {</a>
<a name="ln1408">error:</a>
<a name="ln1409">    /* put cursor back in same position for &quot;:w !cmd&quot; */</a>
<a name="ln1410">    curwin-&gt;w_cursor = cursor_save;</a>
<a name="ln1411">    --no_wait_return;</a>
<a name="ln1412">    wait_return(FALSE);</a>
<a name="ln1413">  }</a>
<a name="ln1414"> </a>
<a name="ln1415">filterend:</a>
<a name="ln1416"> </a>
<a name="ln1417">  if (curbuf != old_curbuf) {</a>
<a name="ln1418">    --no_wait_return;</a>
<a name="ln1419">    EMSG(_(&quot;E135: *Filter* Autocommands must not change current buffer&quot;));</a>
<a name="ln1420">  }</a>
<a name="ln1421">  if (itmp != NULL)</a>
<a name="ln1422">    os_remove((char *)itmp);</a>
<a name="ln1423">  if (otmp != NULL)</a>
<a name="ln1424">    os_remove((char *)otmp);</a>
<a name="ln1425">  xfree(itmp);</a>
<a name="ln1426">  xfree(otmp);</a>
<a name="ln1427">}</a>
<a name="ln1428"> </a>
<a name="ln1429">// Call a shell to execute a command.</a>
<a name="ln1430">// When &quot;cmd&quot; is NULL start an interactive shell.</a>
<a name="ln1431">void</a>
<a name="ln1432">do_shell(</a>
<a name="ln1433">    char_u *cmd,</a>
<a name="ln1434">    int flags             // may be SHELL_DOOUT when output is redirected</a>
<a name="ln1435">)</a>
<a name="ln1436">{</a>
<a name="ln1437">  // Disallow shell commands from .exrc and .vimrc in current directory for</a>
<a name="ln1438">  // security reasons.</a>
<a name="ln1439">  if (check_secure()) {</a>
<a name="ln1440">    msg_end();</a>
<a name="ln1441">    return;</a>
<a name="ln1442">  }</a>
<a name="ln1443"> </a>
<a name="ln1444"> </a>
<a name="ln1445">  /*</a>
<a name="ln1446">   * For autocommands we want to get the output on the current screen, to</a>
<a name="ln1447">   * avoid having to type return below.</a>
<a name="ln1448">   */</a>
<a name="ln1449">  msg_putchar('\r');                    // put cursor at start of line</a>
<a name="ln1450">  msg_putchar('\n');                    // may shift screen one line up</a>
<a name="ln1451"> </a>
<a name="ln1452">  // warning message before calling the shell</a>
<a name="ln1453">  if (p_warn</a>
<a name="ln1454">      &amp;&amp; !autocmd_busy</a>
<a name="ln1455">      &amp;&amp; msg_silent == 0) {</a>
<a name="ln1456">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln1457">      if (bufIsChanged(buf)) {</a>
<a name="ln1458">        MSG_PUTS(_(&quot;[No write since last change]\n&quot;));</a>
<a name="ln1459">        break;</a>
<a name="ln1460">      }</a>
<a name="ln1461">    }</a>
<a name="ln1462">  }</a>
<a name="ln1463"> </a>
<a name="ln1464">  // This ui_cursor_goto is required for when the '\n' resulted in a &quot;delete line</a>
<a name="ln1465">  // 1&quot; command to the terminal.</a>
<a name="ln1466">  ui_cursor_goto(msg_row, msg_col);</a>
<a name="ln1467">  (void)call_shell(cmd, flags, NULL);</a>
<a name="ln1468">  msg_didout = true;</a>
<a name="ln1469">  did_check_timestamps = false;</a>
<a name="ln1470">  need_check_timestamps = true;</a>
<a name="ln1471"> </a>
<a name="ln1472">  // put the message cursor at the end of the screen, avoids wait_return()</a>
<a name="ln1473">  // to overwrite the text that the external command showed</a>
<a name="ln1474">  msg_row = Rows - 1;</a>
<a name="ln1475">  msg_col = 0;</a>
<a name="ln1476"> </a>
<a name="ln1477">  apply_autocmds(EVENT_SHELLCMDPOST, NULL, NULL, FALSE, curbuf);</a>
<a name="ln1478">}</a>
<a name="ln1479"> </a>
<a name="ln1480">#if !defined(UNIX)</a>
<a name="ln1481">static char *find_pipe(const char *cmd)</a>
<a name="ln1482">{</a>
<a name="ln1483">  bool inquote = false;</a>
<a name="ln1484"> </a>
<a name="ln1485">  for (const char *p = cmd; *p != NUL; p++) {</a>
<a name="ln1486">    if (!inquote &amp;&amp; *p == '|') {</a>
<a name="ln1487">      return p;</a>
<a name="ln1488">    }</a>
<a name="ln1489">    if (*p == '&quot;') {</a>
<a name="ln1490">      inquote = !inquote;</a>
<a name="ln1491">    } else if (rem_backslash((const char_u *)p)) {</a>
<a name="ln1492">      p++;</a>
<a name="ln1493">    }</a>
<a name="ln1494">  }</a>
<a name="ln1495">  return NULL;</a>
<a name="ln1496">}</a>
<a name="ln1497">#endif</a>
<a name="ln1498"> </a>
<a name="ln1499">/// Create a shell command from a command string, input redirection file and</a>
<a name="ln1500">/// output redirection file.</a>
<a name="ln1501">///</a>
<a name="ln1502">/// @param cmd  Command to execute.</a>
<a name="ln1503">/// @param itmp NULL or the input file.</a>
<a name="ln1504">/// @param otmp NULL or the output file.</a>
<a name="ln1505">/// @returns an allocated string with the shell command.</a>
<a name="ln1506">char_u *make_filter_cmd(char_u *cmd, char_u *itmp, char_u *otmp)</a>
<a name="ln1507">{</a>
<a name="ln1508">  bool is_fish_shell =</a>
<a name="ln1509">#if defined(UNIX)</a>
<a name="ln1510">    STRNCMP(invocation_path_tail(p_sh, NULL), &quot;fish&quot;, 4) == 0;</a>
<a name="ln1511">#else</a>
<a name="ln1512">    false;</a>
<a name="ln1513">#endif</a>
<a name="ln1514"> </a>
<a name="ln1515">  size_t len = STRLEN(cmd) + 1;  // At least enough space for cmd + NULL.</a>
<a name="ln1516"> </a>
<a name="ln1517">  len += is_fish_shell ?  sizeof(&quot;begin; &quot;&quot;; end&quot;) - 1</a>
<a name="ln1518">                       :  sizeof(&quot;(&quot;&quot;)&quot;) - 1;</a>
<a name="ln1519"> </a>
<a name="ln1520">  if (itmp != NULL) {</a>
<a name="ln1521">    len += STRLEN(itmp) + sizeof(&quot; { &quot;&quot; &lt; &quot;&quot; } &quot;) - 1;</a>
<a name="ln1522">  }</a>
<a name="ln1523">  if (otmp != NULL) {</a>
<a name="ln1524">    len += STRLEN(otmp) + STRLEN(p_srr) + 2;  // two extra spaces (&quot;  &quot;),</a>
<a name="ln1525">  }</a>
<a name="ln1526">  char *const buf = xmalloc(len);</a>
<a name="ln1527"> </a>
<a name="ln1528">#if defined(UNIX)</a>
<a name="ln1529">  // Put delimiters around the command (for concatenated commands) when</a>
<a name="ln1530">  // redirecting input and/or output.</a>
<a name="ln1531">  if (itmp != NULL || otmp != NULL) {</a>
<a name="ln1532">    char *fmt = is_fish_shell ? &quot;begin; %s; end&quot;</a>
<a name="ln1533">                              :       &quot;(%s)&quot;;</a>
<a name="ln1534">    vim_snprintf(buf, len, fmt, (char *)cmd);</a>
<a name="ln1535">  } else {</a>
<a name="ln1536">    xstrlcpy(buf, (char *)cmd, len);</a>
<a name="ln1537">  }</a>
<a name="ln1538"> </a>
<a name="ln1539">  if (itmp != NULL) {</a>
<a name="ln1540">    xstrlcat(buf, &quot; &lt; &quot;, len - 1);</a>
<a name="ln1541">    xstrlcat(buf, (const char *)itmp, len - 1);</a>
<a name="ln1542">  }</a>
<a name="ln1543">#else</a>
<a name="ln1544">  // For shells that don't understand braces around commands, at least allow</a>
<a name="ln1545">  // the use of commands in a pipe.</a>
<a name="ln1546">  xstrlcpy(buf, (char *)cmd, len);</a>
<a name="ln1547">  if (itmp != NULL) {</a>
<a name="ln1548">    // If there is a pipe, we have to put the '&lt;' in front of it.</a>
<a name="ln1549">    // Don't do this when 'shellquote' is not empty, otherwise the</a>
<a name="ln1550">    // redirection would be inside the quotes.</a>
<a name="ln1551">    if (*p_shq == NUL) {</a>
<a name="ln1552">      char *const p = find_pipe(buf);</a>
<a name="ln1553">      if (p != NULL) {</a>
<a name="ln1554">        *p = NUL;</a>
<a name="ln1555">      }</a>
<a name="ln1556">    }</a>
<a name="ln1557">    xstrlcat(buf, &quot; &lt; &quot;, len);</a>
<a name="ln1558">    xstrlcat(buf, (const char *)itmp, len);</a>
<a name="ln1559">    if (*p_shq == NUL) {</a>
<a name="ln1560">      const char *const p = find_pipe((const char *)cmd);</a>
<a name="ln1561">      if (p != NULL) {</a>
<a name="ln1562">        xstrlcat(buf, &quot; &quot;, len - 1);  // Insert a space before the '|' for DOS</a>
<a name="ln1563">        xstrlcat(buf, p, len - 1);</a>
<a name="ln1564">      }</a>
<a name="ln1565">    }</a>
<a name="ln1566">  }</a>
<a name="ln1567">#endif</a>
<a name="ln1568">  if (otmp != NULL) {</a>
<a name="ln1569">    append_redir(buf, len, (char *) p_srr, (char *) otmp);</a>
<a name="ln1570">  }</a>
<a name="ln1571">  return (char_u *) buf;</a>
<a name="ln1572">}</a>
<a name="ln1573"> </a>
<a name="ln1574">/// Append output redirection for the given file to the end of the buffer</a>
<a name="ln1575">///</a>
<a name="ln1576">/// @param[out]  buf  Buffer to append to.</a>
<a name="ln1577">/// @param[in]  buflen  Buffer length.</a>
<a name="ln1578">/// @param[in]  opt  Separator or format string to append: will append</a>
<a name="ln1579">///                  `printf(' ' . opt, fname)` if `%s` is found in `opt` or</a>
<a name="ln1580">///                  a space, opt, a space and then fname if `%s` is not found</a>
<a name="ln1581">///                  there.</a>
<a name="ln1582">/// @param[in]  fname  File name to append.</a>
<a name="ln1583">void append_redir(char *const buf, const size_t buflen,</a>
<a name="ln1584">                  const char *const opt, const char *const fname)</a>
<a name="ln1585">{</a>
<a name="ln1586">  char *const end = buf + strlen(buf);</a>
<a name="ln1587">  // find &quot;%s&quot;</a>
<a name="ln1588">  const char *p = opt;</a>
<a name="ln1589">  for (; (p = strchr(p, '%')) != NULL; p++) {</a>
<a name="ln1590">    if (p[1] == 's') {  // found %s</a>
<a name="ln1591">      break;</a>
<a name="ln1592">    } else if (p[1] == '%') {  // skip %%</a>
<a name="ln1593">      p++;</a>
<a name="ln1594">    }</a>
<a name="ln1595">  }</a>
<a name="ln1596">  if (p != NULL) {</a>
<a name="ln1597">    *end = ' ';  // not really needed? Not with sh, ksh or bash</a>
<a name="ln1598">    vim_snprintf(end + 1, (size_t) (buflen - (end + 1 - buf)), opt, fname);</a>
<a name="ln1599">  } else {</a>
<a name="ln1600">    vim_snprintf(end, (size_t) (buflen - (end - buf)), &quot; %s %s&quot;, opt, fname);</a>
<a name="ln1601">  }</a>
<a name="ln1602">}</a>
<a name="ln1603"> </a>
<a name="ln1604">void print_line_no_prefix(linenr_T lnum, int use_number, int list)</a>
<a name="ln1605">{</a>
<a name="ln1606">  char numbuf[30];</a>
<a name="ln1607"> </a>
<a name="ln1608">  if (curwin-&gt;w_p_nu || use_number) {</a>
<a name="ln1609">    vim_snprintf(numbuf, sizeof(numbuf), &quot;%*&quot; PRIdLINENR &quot; &quot;,</a>
<a name="ln1610">                 number_width(curwin), lnum);</a>
<a name="ln1611">    msg_puts_attr(numbuf, HL_ATTR(HLF_N));  // Highlight line nrs.</a>
<a name="ln1612">  }</a>
<a name="ln1613">  msg_prt_line(ml_get(lnum), list);</a>
<a name="ln1614">}</a>
<a name="ln1615"> </a>
<a name="ln1616">/*</a>
<a name="ln1617"> * Print a text line.  Also in silent mode (&quot;ex -s&quot;).</a>
<a name="ln1618"> */</a>
<a name="ln1619">void print_line(linenr_T lnum, int use_number, int list)</a>
<a name="ln1620">{</a>
<a name="ln1621">  int save_silent = silent_mode;</a>
<a name="ln1622"> </a>
<a name="ln1623">  // apply :filter /pat/</a>
<a name="ln1624">  if (message_filtered(ml_get(lnum))) {</a>
<a name="ln1625">    return;</a>
<a name="ln1626">  }</a>
<a name="ln1627"> </a>
<a name="ln1628">  msg_start();</a>
<a name="ln1629">  silent_mode = FALSE;</a>
<a name="ln1630">  info_message = TRUE;          /* use mch_msg(), not mch_errmsg() */</a>
<a name="ln1631">  print_line_no_prefix(lnum, use_number, list);</a>
<a name="ln1632">  if (save_silent) {</a>
<a name="ln1633">    msg_putchar('\n');</a>
<a name="ln1634">    ui_flush();</a>
<a name="ln1635">    silent_mode = save_silent;</a>
<a name="ln1636">  }</a>
<a name="ln1637">  info_message = FALSE;</a>
<a name="ln1638">}</a>
<a name="ln1639"> </a>
<a name="ln1640">int rename_buffer(char_u *new_fname)</a>
<a name="ln1641">{</a>
<a name="ln1642">  char_u      *fname, *sfname, *xfname;</a>
<a name="ln1643">  buf_T       *buf;</a>
<a name="ln1644"> </a>
<a name="ln1645">  buf = curbuf;</a>
<a name="ln1646">  apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);</a>
<a name="ln1647">  /* buffer changed, don't change name now */</a>
<a name="ln1648">  if (buf != curbuf)</a>
<a name="ln1649">    return FAIL;</a>
<a name="ln1650">  if (aborting())           /* autocmds may abort script processing */</a>
<a name="ln1651">    return FAIL;</a>
<a name="ln1652">  /*</a>
<a name="ln1653">   * The name of the current buffer will be changed.</a>
<a name="ln1654">   * A new (unlisted) buffer entry needs to be made to hold the old file</a>
<a name="ln1655">   * name, which will become the alternate file name.</a>
<a name="ln1656">   * But don't set the alternate file name if the buffer didn't have a</a>
<a name="ln1657">   * name.</a>
<a name="ln1658">   */</a>
<a name="ln1659">  fname = curbuf-&gt;b_ffname;</a>
<a name="ln1660">  sfname = curbuf-&gt;b_sfname;</a>
<a name="ln1661">  xfname = curbuf-&gt;b_fname;</a>
<a name="ln1662">  curbuf-&gt;b_ffname = NULL;</a>
<a name="ln1663">  curbuf-&gt;b_sfname = NULL;</a>
<a name="ln1664">  if (setfname(curbuf, new_fname, NULL, true) == FAIL) {</a>
<a name="ln1665">    curbuf-&gt;b_ffname = fname;</a>
<a name="ln1666">    curbuf-&gt;b_sfname = sfname;</a>
<a name="ln1667">    return FAIL;</a>
<a name="ln1668">  }</a>
<a name="ln1669">  curbuf-&gt;b_flags |= BF_NOTEDITED;</a>
<a name="ln1670">  if (xfname != NULL &amp;&amp; *xfname != NUL) {</a>
<a name="ln1671">    buf = buflist_new(fname, xfname, curwin-&gt;w_cursor.lnum, 0);</a>
<a name="ln1672">    if (buf != NULL &amp;&amp; !cmdmod.keepalt) {</a>
<a name="ln1673">      curwin-&gt;w_alt_fnum = buf-&gt;b_fnum;</a>
<a name="ln1674">    }</a>
<a name="ln1675">  }</a>
<a name="ln1676">  xfree(fname);</a>
<a name="ln1677">  xfree(sfname);</a>
<a name="ln1678">  apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);</a>
<a name="ln1679">  /* Change directories when the 'acd' option is set. */</a>
<a name="ln1680">  do_autochdir();</a>
<a name="ln1681">  return OK;</a>
<a name="ln1682">}</a>
<a name="ln1683"> </a>
<a name="ln1684">/*</a>
<a name="ln1685"> * &quot;:file[!] [fname]&quot;.</a>
<a name="ln1686"> */</a>
<a name="ln1687">void ex_file(exarg_T *eap)</a>
<a name="ln1688">{</a>
<a name="ln1689">  /* &quot;:0file&quot; removes the file name.  Check for illegal uses &quot;:3file&quot;,</a>
<a name="ln1690">   * &quot;0file name&quot;, etc. */</a>
<a name="ln1691">  if (eap-&gt;addr_count &gt; 0</a>
<a name="ln1692">      &amp;&amp; (*eap-&gt;arg != NUL</a>
<a name="ln1693">          || eap-&gt;line2 &gt; 0</a>
<a name="ln1694">          || eap-&gt;addr_count &gt; 1)) {</a>
<a name="ln1695">    EMSG(_(e_invarg));</a>
<a name="ln1696">    return;</a>
<a name="ln1697">  }</a>
<a name="ln1698"> </a>
<a name="ln1699">  if (*eap-&gt;arg != NUL || eap-&gt;addr_count == 1) {</a>
<a name="ln1700">    if (rename_buffer(eap-&gt;arg) == FAIL) {</a>
<a name="ln1701">      return;</a>
<a name="ln1702">    }</a>
<a name="ln1703">    redraw_tabline = true;</a>
<a name="ln1704">  }</a>
<a name="ln1705"> </a>
<a name="ln1706">  // print file name if no argument or 'F' is not in 'shortmess'</a>
<a name="ln1707">  if (*eap-&gt;arg == NUL || !shortmess(SHM_FILEINFO)) {</a>
<a name="ln1708">    fileinfo(false, false, eap-&gt;forceit);</a>
<a name="ln1709">  }</a>
<a name="ln1710">}</a>
<a name="ln1711"> </a>
<a name="ln1712">/*</a>
<a name="ln1713"> * &quot;:update&quot;.</a>
<a name="ln1714"> */</a>
<a name="ln1715">void ex_update(exarg_T *eap)</a>
<a name="ln1716">{</a>
<a name="ln1717">  if (curbufIsChanged())</a>
<a name="ln1718">    (void)do_write(eap);</a>
<a name="ln1719">}</a>
<a name="ln1720"> </a>
<a name="ln1721">/*</a>
<a name="ln1722"> * &quot;:write&quot; and &quot;:saveas&quot;.</a>
<a name="ln1723"> */</a>
<a name="ln1724">void ex_write(exarg_T *eap)</a>
<a name="ln1725">{</a>
<a name="ln1726">  if (eap-&gt;cmdidx == CMD_saveas) {</a>
<a name="ln1727">    // :saveas does not take a range, uses all lines.</a>
<a name="ln1728">    eap-&gt;line1 = 1;</a>
<a name="ln1729">    eap-&gt;line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1730">  }</a>
<a name="ln1731"> </a>
<a name="ln1732">  if (eap-&gt;usefilter) {  // input lines to shell command</a>
<a name="ln1733">    do_bang(1, eap, false, true, false);</a>
<a name="ln1734">  } else {</a>
<a name="ln1735">    (void)do_write(eap);</a>
<a name="ln1736">  }</a>
<a name="ln1737">}</a>
<a name="ln1738"> </a>
<a name="ln1739">/*</a>
<a name="ln1740"> * write current buffer to file 'eap-&gt;arg'</a>
<a name="ln1741"> * if 'eap-&gt;append' is TRUE, append to the file</a>
<a name="ln1742"> *</a>
<a name="ln1743"> * if *eap-&gt;arg == NUL write to current file</a>
<a name="ln1744"> *</a>
<a name="ln1745"> * return FAIL for failure, OK otherwise</a>
<a name="ln1746"> */</a>
<a name="ln1747">int do_write(exarg_T *eap)</a>
<a name="ln1748">{</a>
<a name="ln1749">  int other;</a>
<a name="ln1750">  char_u      *fname = NULL;            /* init to shut up gcc */</a>
<a name="ln1751">  char_u      *ffname;</a>
<a name="ln1752">  int retval = FAIL;</a>
<a name="ln1753">  char_u      *free_fname = NULL;</a>
<a name="ln1754">  buf_T       *alt_buf = NULL;</a>
<a name="ln1755">  int          name_was_missing;</a>
<a name="ln1756"> </a>
<a name="ln1757">  if (not_writing())            /* check 'write' option */</a>
<a name="ln1758">    return FAIL;</a>
<a name="ln1759"> </a>
<a name="ln1760">  ffname = eap-&gt;arg;</a>
<a name="ln1761">  if (*ffname == NUL) {</a>
<a name="ln1762">    if (eap-&gt;cmdidx == CMD_saveas) {</a>
<a name="ln1763">      EMSG(_(e_argreq));</a>
<a name="ln1764">      goto theend;</a>
<a name="ln1765">    }</a>
<a name="ln1766">    other = FALSE;</a>
<a name="ln1767">  } else {</a>
<a name="ln1768">    fname = ffname;</a>
<a name="ln1769">    free_fname = (char_u *)fix_fname((char *)ffname);</a>
<a name="ln1770">    /*</a>
<a name="ln1771">     * When out-of-memory, keep unexpanded file name, because we MUST be</a>
<a name="ln1772">     * able to write the file in this situation.</a>
<a name="ln1773">     */</a>
<a name="ln1774">    if (free_fname != NULL)</a>
<a name="ln1775">      ffname = free_fname;</a>
<a name="ln1776">    other = otherfile(ffname);</a>
<a name="ln1777">  }</a>
<a name="ln1778"> </a>
<a name="ln1779">  /*</a>
<a name="ln1780">   * If we have a new file, put its name in the list of alternate file names.</a>
<a name="ln1781">   */</a>
<a name="ln1782">  if (other) {</a>
<a name="ln1783">    if (vim_strchr(p_cpo, CPO_ALTWRITE) != NULL</a>
<a name="ln1784">        || eap-&gt;cmdidx == CMD_saveas)</a>
<a name="ln1785">      alt_buf = setaltfname(ffname, fname, (linenr_T)1);</a>
<a name="ln1786">    else</a>
<a name="ln1787">      alt_buf = buflist_findname(ffname);</a>
<a name="ln1788">    if (alt_buf != NULL &amp;&amp; alt_buf-&gt;b_ml.ml_mfp != NULL) {</a>
<a name="ln1789">      /* Overwriting a file that is loaded in another buffer is not a</a>
<a name="ln1790">       * good idea. */</a>
<a name="ln1791">      EMSG(_(e_bufloaded));</a>
<a name="ln1792">      goto theend;</a>
<a name="ln1793">    }</a>
<a name="ln1794">  }</a>
<a name="ln1795"> </a>
<a name="ln1796">  // Writing to the current file is not allowed in readonly mode</a>
<a name="ln1797">  // and a file name is required.</a>
<a name="ln1798">  // &quot;nofile&quot; and &quot;nowrite&quot; buffers cannot be written implicitly either.</a>
<a name="ln1799">  if (!other &amp;&amp; (bt_dontwrite_msg(curbuf)</a>
<a name="ln1800">                 || check_fname() == FAIL</a>
<a name="ln1801">                 || check_readonly(&amp;eap-&gt;forceit, curbuf))) {</a>
<a name="ln1802">    goto theend;</a>
<a name="ln1803">  }</a>
<a name="ln1804"> </a>
<a name="ln1805">  if (!other) {</a>
<a name="ln1806">    ffname = curbuf-&gt;b_ffname;</a>
<a name="ln1807">    fname = curbuf-&gt;b_fname;</a>
<a name="ln1808">    /*</a>
<a name="ln1809">     * Not writing the whole file is only allowed with '!'.</a>
<a name="ln1810">     */</a>
<a name="ln1811">    if (       (eap-&gt;line1 != 1</a>
<a name="ln1812">                || eap-&gt;line2 != curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln1813">               &amp;&amp; !eap-&gt;forceit</a>
<a name="ln1814">               &amp;&amp; !eap-&gt;append</a>
<a name="ln1815">               &amp;&amp; !p_wa) {</a>
<a name="ln1816">      if (p_confirm || cmdmod.confirm) {</a>
<a name="ln1817">        if (vim_dialog_yesno(VIM_QUESTION, NULL,</a>
<a name="ln1818">                (char_u *)_(&quot;Write partial file?&quot;), 2) != VIM_YES)</a>
<a name="ln1819">          goto theend;</a>
<a name="ln1820">        eap-&gt;forceit = TRUE;</a>
<a name="ln1821">      } else {</a>
<a name="ln1822">        EMSG(_(&quot;E140: Use ! to write partial buffer&quot;));</a>
<a name="ln1823">        goto theend;</a>
<a name="ln1824">      }</a>
<a name="ln1825">    }</a>
<a name="ln1826">  }</a>
<a name="ln1827"> </a>
<a name="ln1828">  if (check_overwrite(eap, curbuf, fname, ffname, other) == OK) {</a>
<a name="ln1829">    if (eap-&gt;cmdidx == CMD_saveas &amp;&amp; alt_buf != NULL) {</a>
<a name="ln1830">      buf_T       *was_curbuf = curbuf;</a>
<a name="ln1831"> </a>
<a name="ln1832">      apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);</a>
<a name="ln1833">      apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, alt_buf);</a>
<a name="ln1834">      if (curbuf != was_curbuf || aborting()) {</a>
<a name="ln1835">        /* buffer changed, don't change name now */</a>
<a name="ln1836">        retval = FAIL;</a>
<a name="ln1837">        goto theend;</a>
<a name="ln1838">      }</a>
<a name="ln1839">      /* Exchange the file names for the current and the alternate</a>
<a name="ln1840">       * buffer.  This makes it look like we are now editing the buffer</a>
<a name="ln1841">       * under the new name.  Must be done before buf_write(), because</a>
<a name="ln1842">       * if there is no file name and 'cpo' contains 'F', it will set</a>
<a name="ln1843">       * the file name. */</a>
<a name="ln1844">      fname = alt_buf-&gt;b_fname;</a>
<a name="ln1845">      alt_buf-&gt;b_fname = curbuf-&gt;b_fname;</a>
<a name="ln1846">      curbuf-&gt;b_fname = fname;</a>
<a name="ln1847">      fname = alt_buf-&gt;b_ffname;</a>
<a name="ln1848">      alt_buf-&gt;b_ffname = curbuf-&gt;b_ffname;</a>
<a name="ln1849">      curbuf-&gt;b_ffname = fname;</a>
<a name="ln1850">      fname = alt_buf-&gt;b_sfname;</a>
<a name="ln1851">      alt_buf-&gt;b_sfname = curbuf-&gt;b_sfname;</a>
<a name="ln1852">      curbuf-&gt;b_sfname = fname;</a>
<a name="ln1853">      buf_name_changed(curbuf);</a>
<a name="ln1854">      apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);</a>
<a name="ln1855">      apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, alt_buf);</a>
<a name="ln1856">      if (!alt_buf-&gt;b_p_bl) {</a>
<a name="ln1857">        alt_buf-&gt;b_p_bl = TRUE;</a>
<a name="ln1858">        apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, alt_buf);</a>
<a name="ln1859">      }</a>
<a name="ln1860">      if (curbuf != was_curbuf || aborting()) {</a>
<a name="ln1861">        /* buffer changed, don't write the file */</a>
<a name="ln1862">        retval = FAIL;</a>
<a name="ln1863">        goto theend;</a>
<a name="ln1864">      }</a>
<a name="ln1865"> </a>
<a name="ln1866">      // If 'filetype' was empty try detecting it now.</a>
<a name="ln1867">      if (*curbuf-&gt;b_p_ft == NUL) {</a>
<a name="ln1868">        if (au_has_group((char_u *)&quot;filetypedetect&quot;)) {</a>
<a name="ln1869">          (void)do_doautocmd((char_u *)&quot;filetypedetect BufRead&quot;, true, NULL);</a>
<a name="ln1870">        }</a>
<a name="ln1871">        do_modelines(0);</a>
<a name="ln1872">      }</a>
<a name="ln1873"> </a>
<a name="ln1874">      /* Autocommands may have changed buffer names, esp. when</a>
<a name="ln1875">       * 'autochdir' is set. */</a>
<a name="ln1876">      fname = curbuf-&gt;b_sfname;</a>
<a name="ln1877">    }</a>
<a name="ln1878"> </a>
<a name="ln1879">    name_was_missing = curbuf-&gt;b_ffname == NULL;</a>
<a name="ln1880">    retval = buf_write(curbuf, ffname, fname, eap-&gt;line1, eap-&gt;line2,</a>
<a name="ln1881">        eap, eap-&gt;append, eap-&gt;forceit, TRUE, FALSE);</a>
<a name="ln1882"> </a>
<a name="ln1883">    /* After &quot;:saveas fname&quot; reset 'readonly'. */</a>
<a name="ln1884">    if (eap-&gt;cmdidx == CMD_saveas) {</a>
<a name="ln1885">      if (retval == OK) {</a>
<a name="ln1886">        curbuf-&gt;b_p_ro = FALSE;</a>
<a name="ln1887">        redraw_tabline = TRUE;</a>
<a name="ln1888">      }</a>
<a name="ln1889">    }</a>
<a name="ln1890"> </a>
<a name="ln1891">    // Change directories when the 'acd' option is set and the file name</a>
<a name="ln1892">    // got changed or set.</a>
<a name="ln1893">    if (eap-&gt;cmdidx == CMD_saveas || name_was_missing) {</a>
<a name="ln1894">      do_autochdir();</a>
<a name="ln1895">    }</a>
<a name="ln1896">  }</a>
<a name="ln1897"> </a>
<a name="ln1898">theend:</a>
<a name="ln1899">  xfree(free_fname);</a>
<a name="ln1900">  return retval;</a>
<a name="ln1901">}</a>
<a name="ln1902"> </a>
<a name="ln1903">/*</a>
<a name="ln1904"> * Check if it is allowed to overwrite a file.  If b_flags has BF_NOTEDITED,</a>
<a name="ln1905"> * BF_NEW or BF_READERR, check for overwriting current file.</a>
<a name="ln1906"> * May set eap-&gt;forceit if a dialog says it's OK to overwrite.</a>
<a name="ln1907"> * Return OK if it's OK, FAIL if it is not.</a>
<a name="ln1908"> */</a>
<a name="ln1909">int</a>
<a name="ln1910">check_overwrite(</a>
<a name="ln1911">    exarg_T *eap,</a>
<a name="ln1912">    buf_T *buf,</a>
<a name="ln1913">    char_u *fname,         // file name to be used (can differ from</a>
<a name="ln1914">                           //   buf-&gt;ffname)</a>
<a name="ln1915">    char_u *ffname,        // full path version of fname</a>
<a name="ln1916">    int other              // writing under other name</a>
<a name="ln1917">)</a>
<a name="ln1918">{</a>
<a name="ln1919">  /*</a>
<a name="ln1920">   * write to other file or b_flags set or not writing the whole file:</a>
<a name="ln1921">   * overwriting only allowed with '!'</a>
<a name="ln1922">   */</a>
<a name="ln1923">  if ((other</a>
<a name="ln1924">       || (buf-&gt;b_flags &amp; BF_NOTEDITED)</a>
<a name="ln1925">       || ((buf-&gt;b_flags &amp; BF_NEW)</a>
<a name="ln1926">           &amp;&amp; vim_strchr(p_cpo, CPO_OVERNEW) == NULL)</a>
<a name="ln1927">       || (buf-&gt;b_flags &amp; BF_READERR))</a>
<a name="ln1928">      &amp;&amp; !p_wa</a>
<a name="ln1929">      &amp;&amp; !bt_nofile(buf)</a>
<a name="ln1930">      &amp;&amp; os_path_exists(ffname)) {</a>
<a name="ln1931">    if (!eap-&gt;forceit &amp;&amp; !eap-&gt;append) {</a>
<a name="ln1932">#ifdef UNIX</a>
<a name="ln1933">      // It is possible to open a directory on Unix.</a>
<a name="ln1934">      if (os_isdir(ffname)) {</a>
<a name="ln1935">        EMSG2(_(e_isadir2), ffname);</a>
<a name="ln1936">        return FAIL;</a>
<a name="ln1937">      }</a>
<a name="ln1938">#endif</a>
<a name="ln1939">      if (p_confirm || cmdmod.confirm) {</a>
<a name="ln1940">        char_u buff[DIALOG_MSG_SIZE];</a>
<a name="ln1941"> </a>
<a name="ln1942">        dialog_msg(buff, _(&quot;Overwrite existing file \&quot;%s\&quot;?&quot;), fname);</a>
<a name="ln1943">        if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) != VIM_YES)</a>
<a name="ln1944">          return FAIL;</a>
<a name="ln1945">        eap-&gt;forceit = TRUE;</a>
<a name="ln1946">      } else {</a>
<a name="ln1947">        EMSG(_(e_exists));</a>
<a name="ln1948">        return FAIL;</a>
<a name="ln1949">      }</a>
<a name="ln1950">    }</a>
<a name="ln1951"> </a>
<a name="ln1952">    /* For &quot;:w! filename&quot; check that no swap file exists for &quot;filename&quot;. */</a>
<a name="ln1953">    if (other &amp;&amp; !emsg_silent) {</a>
<a name="ln1954">      char_u      *dir;</a>
<a name="ln1955">      char_u      *p;</a>
<a name="ln1956">      char_u      *swapname;</a>
<a name="ln1957"> </a>
<a name="ln1958">      /* We only try the first entry in 'directory', without checking if</a>
<a name="ln1959">       * it's writable.  If the &quot;.&quot; directory is not writable the write</a>
<a name="ln1960">       * will probably fail anyway.</a>
<a name="ln1961">       * Use 'shortname' of the current buffer, since there is no buffer</a>
<a name="ln1962">       * for the written file. */</a>
<a name="ln1963">      if (*p_dir == NUL) {</a>
<a name="ln1964">        dir = xmalloc(5);</a>
<a name="ln1965">        STRCPY(dir, &quot;.&quot;);</a>
<a name="ln1966">      } else {</a>
<a name="ln1967">        dir = xmalloc(MAXPATHL);</a>
<a name="ln1968">        p = p_dir;</a>
<a name="ln1969">        copy_option_part(&amp;p, dir, MAXPATHL, &quot;,&quot;);</a>
<a name="ln1970">      }</a>
<a name="ln1971">      swapname = makeswapname(fname, ffname, curbuf, dir);</a>
<a name="ln1972">      xfree(dir);</a>
<a name="ln1973">      if (os_path_exists(swapname)) {</a>
<a name="ln1974">        if (p_confirm || cmdmod.confirm) {</a>
<a name="ln1975">          char_u buff[DIALOG_MSG_SIZE];</a>
<a name="ln1976"> </a>
<a name="ln1977">          dialog_msg(buff,</a>
<a name="ln1978">              _(&quot;Swap file \&quot;%s\&quot; exists, overwrite anyway?&quot;),</a>
<a name="ln1979">              swapname);</a>
<a name="ln1980">          if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2)</a>
<a name="ln1981">              != VIM_YES) {</a>
<a name="ln1982">            xfree(swapname);</a>
<a name="ln1983">            return FAIL;</a>
<a name="ln1984">          }</a>
<a name="ln1985">          eap-&gt;forceit = TRUE;</a>
<a name="ln1986">        } else {</a>
<a name="ln1987">          EMSG2(_(&quot;E768: Swap file exists: %s (:silent! overrides)&quot;),</a>
<a name="ln1988">              swapname);</a>
<a name="ln1989">          xfree(swapname);</a>
<a name="ln1990">          return FAIL;</a>
<a name="ln1991">        }</a>
<a name="ln1992">      }</a>
<a name="ln1993">      xfree(swapname);</a>
<a name="ln1994">    }</a>
<a name="ln1995">  }</a>
<a name="ln1996">  return OK;</a>
<a name="ln1997">}</a>
<a name="ln1998"> </a>
<a name="ln1999">/*</a>
<a name="ln2000"> * Handle &quot;:wnext&quot;, &quot;:wNext&quot; and &quot;:wprevious&quot; commands.</a>
<a name="ln2001"> */</a>
<a name="ln2002">void ex_wnext(exarg_T *eap)</a>
<a name="ln2003">{</a>
<a name="ln2004">  int i;</a>
<a name="ln2005"> </a>
<a name="ln2006">  if (eap-&gt;cmd[1] == 'n')</a>
<a name="ln2007">    i = curwin-&gt;w_arg_idx + (int)eap-&gt;line2;</a>
<a name="ln2008">  else</a>
<a name="ln2009">    i = curwin-&gt;w_arg_idx - (int)eap-&gt;line2;</a>
<a name="ln2010">  eap-&gt;line1 = 1;</a>
<a name="ln2011">  eap-&gt;line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln2012">  if (do_write(eap) != FAIL)</a>
<a name="ln2013">    do_argfile(eap, i);</a>
<a name="ln2014">}</a>
<a name="ln2015"> </a>
<a name="ln2016">/*</a>
<a name="ln2017"> * &quot;:wall&quot;, &quot;:wqall&quot; and &quot;:xall&quot;: Write all changed files (and exit).</a>
<a name="ln2018"> */</a>
<a name="ln2019">void do_wqall(exarg_T *eap)</a>
<a name="ln2020">{</a>
<a name="ln2021">  int error = 0;</a>
<a name="ln2022">  int save_forceit = eap-&gt;forceit;</a>
<a name="ln2023"> </a>
<a name="ln2024">  if (eap-&gt;cmdidx == CMD_xall || eap-&gt;cmdidx == CMD_wqall) {</a>
<a name="ln2025">    exiting = true;</a>
<a name="ln2026">  }</a>
<a name="ln2027"> </a>
<a name="ln2028">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2029">    if (exiting</a>
<a name="ln2030">        &amp;&amp; buf-&gt;terminal</a>
<a name="ln2031">        &amp;&amp; channel_job_running((uint64_t)buf-&gt;b_p_channel)) {</a>
<a name="ln2032">      no_write_message_nobang(buf);</a>
<a name="ln2033">      error++;</a>
<a name="ln2034">    } else if (!bufIsChanged(buf) || bt_dontwrite(buf)) {</a>
<a name="ln2035">      continue;</a>
<a name="ln2036">    }</a>
<a name="ln2037">    /*</a>
<a name="ln2038">     * Check if there is a reason the buffer cannot be written:</a>
<a name="ln2039">     * 1. if the 'write' option is set</a>
<a name="ln2040">     * 2. if there is no file name (even after browsing)</a>
<a name="ln2041">     * 3. if the 'readonly' is set (even after a dialog)</a>
<a name="ln2042">     * 4. if overwriting is allowed (even after a dialog)</a>
<a name="ln2043">     */</a>
<a name="ln2044">    if (not_writing()) {</a>
<a name="ln2045">      ++error;</a>
<a name="ln2046">      break;</a>
<a name="ln2047">    }</a>
<a name="ln2048">    if (buf-&gt;b_ffname == NULL) {</a>
<a name="ln2049">      EMSGN(_(&quot;E141: No file name for buffer %&quot; PRId64), buf-&gt;b_fnum);</a>
<a name="ln2050">      ++error;</a>
<a name="ln2051">    } else if (check_readonly(&amp;eap-&gt;forceit, buf)</a>
<a name="ln2052">               || check_overwrite(eap, buf, buf-&gt;b_fname, buf-&gt;b_ffname,</a>
<a name="ln2053">                   FALSE) == FAIL) {</a>
<a name="ln2054">      ++error;</a>
<a name="ln2055">    } else {</a>
<a name="ln2056">      bufref_T bufref;</a>
<a name="ln2057">      set_bufref(&amp;bufref, buf);</a>
<a name="ln2058">      if (buf_write_all(buf, eap-&gt;forceit) == FAIL) {</a>
<a name="ln2059">        error++;</a>
<a name="ln2060">      }</a>
<a name="ln2061">      // An autocommand may have deleted the buffer.</a>
<a name="ln2062">      if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln2063">        buf = firstbuf;</a>
<a name="ln2064">      }</a>
<a name="ln2065">    }</a>
<a name="ln2066">    eap-&gt;forceit = save_forceit;          /* check_overwrite() may set it */</a>
<a name="ln2067">  }</a>
<a name="ln2068">  if (exiting) {</a>
<a name="ln2069">    if (!error)</a>
<a name="ln2070">      getout(0);                /* exit Vim */</a>
<a name="ln2071">    not_exiting();</a>
<a name="ln2072">  }</a>
<a name="ln2073">}</a>
<a name="ln2074"> </a>
<a name="ln2075">/*</a>
<a name="ln2076"> * Check the 'write' option.</a>
<a name="ln2077"> * Return TRUE and give a message when it's not st.</a>
<a name="ln2078"> */</a>
<a name="ln2079">int not_writing(void)</a>
<a name="ln2080">{</a>
<a name="ln2081">  if (p_write)</a>
<a name="ln2082">    return FALSE;</a>
<a name="ln2083">  EMSG(_(&quot;E142: File not written: Writing is disabled by 'write' option&quot;));</a>
<a name="ln2084">  return TRUE;</a>
<a name="ln2085">}</a>
<a name="ln2086"> </a>
<a name="ln2087">/*</a>
<a name="ln2088"> * Check if a buffer is read-only (either 'readonly' option is set or file is</a>
<a name="ln2089"> * read-only). Ask for overruling in a dialog. Return TRUE and give an error</a>
<a name="ln2090"> * message when the buffer is readonly.</a>
<a name="ln2091"> */</a>
<a name="ln2092">static int check_readonly(int *forceit, buf_T *buf)</a>
<a name="ln2093">{</a>
<a name="ln2094">  /* Handle a file being readonly when the 'readonly' option is set or when</a>
<a name="ln2095">   * the file exists and permissions are read-only. */</a>
<a name="ln2096">  if (!*forceit &amp;&amp; (buf-&gt;b_p_ro</a>
<a name="ln2097">                    || (os_path_exists(buf-&gt;b_ffname)</a>
<a name="ln2098">                        &amp;&amp; !os_file_is_writable((char *)buf-&gt;b_ffname)))) {</a>
<a name="ln2099">    if ((p_confirm || cmdmod.confirm) &amp;&amp; buf-&gt;b_fname != NULL) {</a>
<a name="ln2100">      char_u buff[DIALOG_MSG_SIZE];</a>
<a name="ln2101"> </a>
<a name="ln2102">      if (buf-&gt;b_p_ro)</a>
<a name="ln2103">        dialog_msg(buff,</a>
<a name="ln2104">            _(</a>
<a name="ln2105">                &quot;'readonly' option is set for \&quot;%s\&quot;.\nDo you wish to write anyway?&quot;),</a>
<a name="ln2106">            buf-&gt;b_fname);</a>
<a name="ln2107">      else</a>
<a name="ln2108">        dialog_msg(buff,</a>
<a name="ln2109">            _(</a>
<a name="ln2110">                &quot;File permissions of \&quot;%s\&quot; are read-only.\nIt may still be possible to write it.\nDo you wish to try?&quot;),</a>
<a name="ln2111">            buf-&gt;b_fname);</a>
<a name="ln2112"> </a>
<a name="ln2113">      if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) == VIM_YES) {</a>
<a name="ln2114">        /* Set forceit, to force the writing of a readonly file */</a>
<a name="ln2115">        *forceit = TRUE;</a>
<a name="ln2116">        return FALSE;</a>
<a name="ln2117">      } else</a>
<a name="ln2118">        return TRUE;</a>
<a name="ln2119">    } else if (buf-&gt;b_p_ro)</a>
<a name="ln2120">      EMSG(_(e_readonly));</a>
<a name="ln2121">    else</a>
<a name="ln2122">      EMSG2(_(&quot;E505: \&quot;%s\&quot; is read-only (add ! to override)&quot;),</a>
<a name="ln2123">          buf-&gt;b_fname);</a>
<a name="ln2124">    return TRUE;</a>
<a name="ln2125">  }</a>
<a name="ln2126"> </a>
<a name="ln2127">  return FALSE;</a>
<a name="ln2128">}</a>
<a name="ln2129"> </a>
<a name="ln2130">// Try to abandon the current file and edit a new or existing file.</a>
<a name="ln2131">// &quot;fnum&quot; is the number of the file, if zero use &quot;ffname_arg&quot;/&quot;sfname_arg&quot;.</a>
<a name="ln2132">// &quot;lnum&quot; is the line number for the cursor in the new file (if non-zero).</a>
<a name="ln2133">//</a>
<a name="ln2134">// Return:</a>
<a name="ln2135">// GETFILE_ERROR for &quot;normal&quot; error,</a>
<a name="ln2136">// GETFILE_NOT_WRITTEN for &quot;not written&quot; error,</a>
<a name="ln2137">// GETFILE_SAME_FILE for success</a>
<a name="ln2138">// GETFILE_OPEN_OTHER for successfully opening another file.</a>
<a name="ln2139">int getfile(int fnum, char_u *ffname_arg, char_u *sfname_arg, int setpm,</a>
<a name="ln2140">            linenr_T lnum, int forceit)</a>
<a name="ln2141">{</a>
<a name="ln2142">  char_u *ffname = ffname_arg;</a>
<a name="ln2143">  char_u *sfname = sfname_arg;</a>
<a name="ln2144">  int other;</a>
<a name="ln2145">  int retval;</a>
<a name="ln2146">  char_u      *free_me = NULL;</a>
<a name="ln2147"> </a>
<a name="ln2148">  if (text_locked()) {</a>
<a name="ln2149">    return GETFILE_ERROR;</a>
<a name="ln2150">  }</a>
<a name="ln2151">  if (curbuf_locked()) {</a>
<a name="ln2152">    return GETFILE_ERROR;</a>
<a name="ln2153">  }</a>
<a name="ln2154"> </a>
<a name="ln2155">  if (fnum == 0) {</a>
<a name="ln2156">    /* make ffname full path, set sfname */</a>
<a name="ln2157">    fname_expand(curbuf, &amp;ffname, &amp;sfname);</a>
<a name="ln2158">    other = otherfile(ffname);</a>
<a name="ln2159">    free_me = ffname;                   /* has been allocated, free() later */</a>
<a name="ln2160">  } else</a>
<a name="ln2161">    other = (fnum != curbuf-&gt;b_fnum);</a>
<a name="ln2162"> </a>
<a name="ln2163">  if (other) {</a>
<a name="ln2164">    no_wait_return++;               // don't wait for autowrite message</a>
<a name="ln2165">  }</a>
<a name="ln2166">  if (other &amp;&amp; !forceit &amp;&amp; curbuf-&gt;b_nwindows == 1 &amp;&amp; !buf_hide(curbuf)</a>
<a name="ln2167">      &amp;&amp; curbufIsChanged() &amp;&amp; autowrite(curbuf, forceit) == FAIL) {</a>
<a name="ln2168">    if (p_confirm &amp;&amp; p_write) {</a>
<a name="ln2169">      dialog_changed(curbuf, false);</a>
<a name="ln2170">    }</a>
<a name="ln2171">    if (curbufIsChanged()) {</a>
<a name="ln2172">      no_wait_return--;</a>
<a name="ln2173">      no_write_message();</a>
<a name="ln2174">      retval = GETFILE_NOT_WRITTEN;     // File has been changed.</a>
<a name="ln2175">      goto theend;</a>
<a name="ln2176">    }</a>
<a name="ln2177">  }</a>
<a name="ln2178">  if (other)</a>
<a name="ln2179">    --no_wait_return;</a>
<a name="ln2180">  if (setpm)</a>
<a name="ln2181">    setpcmark();</a>
<a name="ln2182">  if (!other) {</a>
<a name="ln2183">    if (lnum != 0) {</a>
<a name="ln2184">      curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln2185">    }</a>
<a name="ln2186">    check_cursor_lnum();</a>
<a name="ln2187">    beginline(BL_SOL | BL_FIX);</a>
<a name="ln2188">    retval = GETFILE_SAME_FILE;     // it's in the same file</a>
<a name="ln2189">  } else if (do_ecmd(fnum, ffname, sfname, NULL, lnum,</a>
<a name="ln2190">                     (buf_hide(curbuf) ? ECMD_HIDE : 0)</a>
<a name="ln2191">                     + (forceit ? ECMD_FORCEIT : 0), curwin) == OK) {</a>
<a name="ln2192">    retval = GETFILE_OPEN_OTHER;    // opened another file</a>
<a name="ln2193">  } else {</a>
<a name="ln2194">    retval = GETFILE_ERROR;         // error encountered</a>
<a name="ln2195">  }</a>
<a name="ln2196"> </a>
<a name="ln2197">theend:</a>
<a name="ln2198">  xfree(free_me);</a>
<a name="ln2199">  return retval;</a>
<a name="ln2200">}</a>
<a name="ln2201"> </a>
<a name="ln2202">/// start editing a new file</a>
<a name="ln2203">///</a>
<a name="ln2204">/// @param fnum     file number; if zero use ffname/sfname</a>
<a name="ln2205">/// @param ffname   the file name</a>
<a name="ln2206">///                 - full path if sfname used,</a>
<a name="ln2207">///                 - any file name if sfname is NULL</a>
<a name="ln2208">///                 - empty string to re-edit with the same file name (but may</a>
<a name="ln2209">///                   be in a different directory)</a>
<a name="ln2210">///                 - NULL to start an empty buffer</a>
<a name="ln2211">/// @param sfname   the short file name (or NULL)</a>
<a name="ln2212">/// @param eap      contains the command to be executed after loading the file</a>
<a name="ln2213">///                 and forced 'ff' and 'fenc'</a>
<a name="ln2214">/// @param newlnum  if &gt; 0: put cursor on this line number (if possible)</a>
<a name="ln2215">///                 ECMD_LASTL: use last position in loaded file</a>
<a name="ln2216">///                 ECMD_LAST: use last position in all files</a>
<a name="ln2217">///                 ECMD_ONE: use first line</a>
<a name="ln2218">/// @param flags    ECMD_HIDE: if TRUE don't free the current buffer</a>
<a name="ln2219">///                 ECMD_SET_HELP: set b_help flag of (new) buffer before</a>
<a name="ln2220">///                 opening file</a>
<a name="ln2221">///                 ECMD_OLDBUF: use existing buffer if it exists</a>
<a name="ln2222">///                 ECMD_FORCEIT: ! used for Ex command</a>
<a name="ln2223">///                 ECMD_ADDBUF: don't edit, just add to buffer list</a>
<a name="ln2224">///                 ECMD_ALTBUF: like ECMD_ADDBUF and also set the alternate</a>
<a name="ln2225">///                 file</a>
<a name="ln2226">/// @param oldwin   Should be &quot;curwin&quot; when editing a new buffer in the current</a>
<a name="ln2227">///                 window, NULL when splitting the window first.  When not NULL</a>
<a name="ln2228">///                 info of the previous buffer for &quot;oldwin&quot; is stored.</a>
<a name="ln2229">///</a>
<a name="ln2230">/// @return FAIL for failure, OK otherwise</a>
<a name="ln2231">int do_ecmd(</a>
<a name="ln2232">    int fnum,</a>
<a name="ln2233">    char_u *ffname,</a>
<a name="ln2234">    char_u *sfname,</a>
<a name="ln2235">    exarg_T *eap,                       /* can be NULL! */</a>
<a name="ln2236">    linenr_T newlnum,</a>
<a name="ln2237">    int flags,</a>
<a name="ln2238">    win_T *oldwin</a>
<a name="ln2239">)</a>
<a name="ln2240">{</a>
<a name="ln2241">  int other_file;                       /* TRUE if editing another file */</a>
<a name="ln2242">  int oldbuf;                           /* TRUE if using existing buffer */</a>
<a name="ln2243">  int auto_buf = FALSE;                 /* TRUE if autocommands brought us</a>
<a name="ln2244">                                           into the buffer unexpectedly */</a>
<a name="ln2245">  char_u      *new_name = NULL;</a>
<a name="ln2246">  int did_set_swapcommand = FALSE;</a>
<a name="ln2247">  buf_T       *buf;</a>
<a name="ln2248">  bufref_T     bufref;</a>
<a name="ln2249">  bufref_T     old_curbuf;</a>
<a name="ln2250">  char_u      *free_fname = NULL;</a>
<a name="ln2251">  int retval = FAIL;</a>
<a name="ln2252">  long n;</a>
<a name="ln2253">  pos_T orig_pos;</a>
<a name="ln2254">  linenr_T topline = 0;</a>
<a name="ln2255">  int newcol = -1;</a>
<a name="ln2256">  int solcol = -1;</a>
<a name="ln2257">  pos_T       *pos;</a>
<a name="ln2258">  char_u      *command = NULL;</a>
<a name="ln2259">  int did_get_winopts = FALSE;</a>
<a name="ln2260">  int readfile_flags = 0;</a>
<a name="ln2261">  bool did_inc_redrawing_disabled = false;</a>
<a name="ln2262">  long *so_ptr = curwin-&gt;w_p_so &gt;= 0 ? &amp;curwin-&gt;w_p_so : &amp;p_so;</a>
<a name="ln2263"> </a>
<a name="ln2264">  if (eap != NULL)</a>
<a name="ln2265">    command = eap-&gt;do_ecmd_cmd;</a>
<a name="ln2266"> </a>
<a name="ln2267">  set_bufref(&amp;old_curbuf, curbuf);</a>
<a name="ln2268"> </a>
<a name="ln2269">  if (fnum != 0) {</a>
<a name="ln2270">    if (fnum == curbuf-&gt;b_fnum)         /* file is already being edited */</a>
<a name="ln2271">      return OK;                        /* nothing to do */</a>
<a name="ln2272">    other_file = TRUE;</a>
<a name="ln2273">  } else {</a>
<a name="ln2274">    /* if no short name given, use ffname for short name */</a>
<a name="ln2275">    if (sfname == NULL)</a>
<a name="ln2276">      sfname = ffname;</a>
<a name="ln2277">#ifdef USE_FNAME_CASE</a>
<a name="ln2278">    if (sfname != NULL)</a>
<a name="ln2279">      path_fix_case(sfname);             // set correct case for sfname</a>
<a name="ln2280">#endif</a>
<a name="ln2281"> </a>
<a name="ln2282">    if ((flags &amp; (ECMD_ADDBUF | ECMD_ALTBUF))</a>
<a name="ln2283">        &amp;&amp; (ffname == NULL || *ffname == NUL)) {</a>
<a name="ln2284">      goto theend;</a>
<a name="ln2285">    }</a>
<a name="ln2286"> </a>
<a name="ln2287">    if (ffname == NULL)</a>
<a name="ln2288">      other_file = TRUE;</a>
<a name="ln2289">    /* there is no file name */</a>
<a name="ln2290">    else if (*ffname == NUL &amp;&amp; curbuf-&gt;b_ffname == NULL)</a>
<a name="ln2291">      other_file = FALSE;</a>
<a name="ln2292">    else {</a>
<a name="ln2293">      if (*ffname == NUL) {                 /* re-edit with same file name */</a>
<a name="ln2294">        ffname = curbuf-&gt;b_ffname;</a>
<a name="ln2295">        sfname = curbuf-&gt;b_fname;</a>
<a name="ln2296">      }</a>
<a name="ln2297">      free_fname = (char_u *)fix_fname((char *)ffname);       /* may expand to full path name */</a>
<a name="ln2298">      if (free_fname != NULL)</a>
<a name="ln2299">        ffname = free_fname;</a>
<a name="ln2300">      other_file = otherfile(ffname);</a>
<a name="ln2301">    }</a>
<a name="ln2302">  }</a>
<a name="ln2303"> </a>
<a name="ln2304">  // Re-editing a terminal buffer: skip most buffer re-initialization.</a>
<a name="ln2305">  if (!other_file &amp;&amp; curbuf-&gt;terminal) {</a>
<a name="ln2306">    check_arg_idx(curwin);  // Needed when called from do_argfile().</a>
<a name="ln2307">    maketitle();            // Title may show the arg index, e.g. &quot;(2 of 5)&quot;.</a>
<a name="ln2308">    retval = OK;</a>
<a name="ln2309">    goto theend;</a>
<a name="ln2310">  }</a>
<a name="ln2311"> </a>
<a name="ln2312">  // If the file was changed we may not be allowed to abandon it:</a>
<a name="ln2313">  // - if we are going to re-edit the same file</a>
<a name="ln2314">  // - or if we are the only window on this file and if ECMD_HIDE is FALSE</a>
<a name="ln2315">  if (((!other_file &amp;&amp; !(flags &amp; ECMD_OLDBUF))</a>
<a name="ln2316">       || (curbuf-&gt;b_nwindows == 1</a>
<a name="ln2317">           &amp;&amp; !(flags &amp; (ECMD_HIDE | ECMD_ADDBUF | ECMD_ALTBUF))))</a>
<a name="ln2318">      &amp;&amp; check_changed(curbuf, (p_awa ? CCGD_AW : 0)</a>
<a name="ln2319">                       | (other_file ? 0 : CCGD_MULTWIN)</a>
<a name="ln2320">                       | ((flags &amp; ECMD_FORCEIT) ? CCGD_FORCEIT : 0)</a>
<a name="ln2321">                       | (eap == NULL ? 0 : CCGD_EXCMD))) {</a>
<a name="ln2322">    if (fnum == 0 &amp;&amp; other_file &amp;&amp; ffname != NULL) {</a>
<a name="ln2323">      (void)setaltfname(ffname, sfname, newlnum &lt; 0 ? 0 : newlnum);</a>
<a name="ln2324">    }</a>
<a name="ln2325">    goto theend;</a>
<a name="ln2326">  }</a>
<a name="ln2327"> </a>
<a name="ln2328">  /*</a>
<a name="ln2329">   * End Visual mode before switching to another buffer, so the text can be</a>
<a name="ln2330">   * copied into the GUI selection buffer.</a>
<a name="ln2331">   */</a>
<a name="ln2332">  reset_VIsual();</a>
<a name="ln2333"> </a>
<a name="ln2334">  if ((command != NULL || newlnum &gt; (linenr_T)0)</a>
<a name="ln2335">      &amp;&amp; *get_vim_var_str(VV_SWAPCOMMAND) == NUL) {</a>
<a name="ln2336">    // Set v:swapcommand for the SwapExists autocommands.</a>
<a name="ln2337">    const size_t len = (command != NULL) ? STRLEN(command) + 3 : 30;</a>
<a name="ln2338">    char *const p = xmalloc(len);</a>
<a name="ln2339">    if (command != NULL) {</a>
<a name="ln2340">      vim_snprintf(p, len, &quot;:%s\r&quot;, command);</a>
<a name="ln2341">    } else {</a>
<a name="ln2342">      vim_snprintf(p, len, &quot;%&quot; PRId64 &quot;G&quot;, (int64_t)newlnum);</a>
<a name="ln2343">    }</a>
<a name="ln2344">    set_vim_var_string(VV_SWAPCOMMAND, p, -1);</a>
<a name="ln2345">    did_set_swapcommand = TRUE;</a>
<a name="ln2346">    xfree(p);</a>
<a name="ln2347">  }</a>
<a name="ln2348"> </a>
<a name="ln2349">  /*</a>
<a name="ln2350">   * If we are starting to edit another file, open a (new) buffer.</a>
<a name="ln2351">   * Otherwise we re-use the current buffer.</a>
<a name="ln2352">   */</a>
<a name="ln2353">  if (other_file) {</a>
<a name="ln2354">    if (!(flags &amp; (ECMD_ADDBUF | ECMD_ALTBUF))) {</a>
<a name="ln2355">      if (!cmdmod.keepalt) {</a>
<a name="ln2356">        curwin-&gt;w_alt_fnum = curbuf-&gt;b_fnum;</a>
<a name="ln2357">      }</a>
<a name="ln2358">      if (oldwin != NULL) {</a>
<a name="ln2359">        buflist_altfpos(oldwin);</a>
<a name="ln2360">      }</a>
<a name="ln2361">    }</a>
<a name="ln2362"> </a>
<a name="ln2363">    if (fnum) {</a>
<a name="ln2364">      buf = buflist_findnr(fnum);</a>
<a name="ln2365">    } else {</a>
<a name="ln2366">      if (flags &amp; (ECMD_ADDBUF | ECMD_ALTBUF)) {</a>
<a name="ln2367">        // Default the line number to zero to avoid that a wininfo item</a>
<a name="ln2368">        // is added for the current window.</a>
<a name="ln2369">        linenr_T tlnum = 0;</a>
<a name="ln2370"> </a>
<a name="ln2371">        if (command != NULL) {</a>
<a name="ln2372">          tlnum = atol((char *)command);</a>
<a name="ln2373">          if (tlnum &lt;= 0)</a>
<a name="ln2374">            tlnum = 1L;</a>
<a name="ln2375">        }</a>
<a name="ln2376">        // Add BLN_NOCURWIN to avoid a new wininfo items are associated</a>
<a name="ln2377">        // with the current window.</a>
<a name="ln2378">        const buf_T *const newbuf</a>
<a name="ln2379">            = buflist_new(ffname, sfname, tlnum, BLN_LISTED | BLN_NOCURWIN);</a>
<a name="ln2380">        if (newbuf != NULL &amp;&amp; (flags &amp; ECMD_ALTBUF)) {</a>
<a name="ln2381">          curwin-&gt;w_alt_fnum = newbuf-&gt;b_fnum;</a>
<a name="ln2382">        }</a>
<a name="ln2383">        goto theend;</a>
<a name="ln2384">      }</a>
<a name="ln2385">      buf = buflist_new(ffname, sfname, 0L,</a>
<a name="ln2386">                        BLN_CURBUF | (flags &amp; ECMD_SET_HELP ? 0 : BLN_LISTED));</a>
<a name="ln2387">      // Autocmds may change curwin and curbuf.</a>
<a name="ln2388">      if (oldwin != NULL) {</a>
<a name="ln2389">        oldwin = curwin;</a>
<a name="ln2390">      }</a>
<a name="ln2391">      set_bufref(&amp;old_curbuf, curbuf);</a>
<a name="ln2392">    }</a>
<a name="ln2393">    if (buf == NULL)</a>
<a name="ln2394">      goto theend;</a>
<a name="ln2395">    if (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln2396">      // No memfile yet.</a>
<a name="ln2397">      oldbuf = false;</a>
<a name="ln2398">    } else {</a>
<a name="ln2399">      // Existing memfile.</a>
<a name="ln2400">      oldbuf = true;</a>
<a name="ln2401">      set_bufref(&amp;bufref, buf);</a>
<a name="ln2402">      (void)buf_check_timestamp(buf);</a>
<a name="ln2403">      // Check if autocommands made buffer invalid or changed the current</a>
<a name="ln2404">      // buffer.</a>
<a name="ln2405">      if (!bufref_valid(&amp;bufref) || curbuf != old_curbuf.br_buf) {</a>
<a name="ln2406">        goto theend;</a>
<a name="ln2407">      }</a>
<a name="ln2408">      if (aborting()) {</a>
<a name="ln2409">        // Autocmds may abort script processing.</a>
<a name="ln2410">        goto theend;</a>
<a name="ln2411">      }</a>
<a name="ln2412">    }</a>
<a name="ln2413"> </a>
<a name="ln2414">    /* May jump to last used line number for a loaded buffer or when asked</a>
<a name="ln2415">     * for explicitly */</a>
<a name="ln2416">    if ((oldbuf &amp;&amp; newlnum == ECMD_LASTL) || newlnum == ECMD_LAST) {</a>
<a name="ln2417">      pos = buflist_findfpos(buf);</a>
<a name="ln2418">      newlnum = pos-&gt;lnum;</a>
<a name="ln2419">      solcol = pos-&gt;col;</a>
<a name="ln2420">    }</a>
<a name="ln2421"> </a>
<a name="ln2422">    /*</a>
<a name="ln2423">     * Make the (new) buffer the one used by the current window.</a>
<a name="ln2424">     * If the old buffer becomes unused, free it if ECMD_HIDE is FALSE.</a>
<a name="ln2425">     * If the current buffer was empty and has no file name, curbuf</a>
<a name="ln2426">     * is returned by buflist_new(), nothing to do here.</a>
<a name="ln2427">     */</a>
<a name="ln2428">    if (buf != curbuf) {</a>
<a name="ln2429">      /*</a>
<a name="ln2430">       * Be careful: The autocommands may delete any buffer and change</a>
<a name="ln2431">       * the current buffer.</a>
<a name="ln2432">       * - If the buffer we are going to edit is deleted, give up.</a>
<a name="ln2433">       * - If the current buffer is deleted, prefer to load the new</a>
<a name="ln2434">       *   buffer when loading a buffer is required.  This avoids</a>
<a name="ln2435">       *   loading another buffer which then must be closed again.</a>
<a name="ln2436">       * - If we ended up in the new buffer already, need to skip a few</a>
<a name="ln2437">       *	 things, set auto_buf.</a>
<a name="ln2438">       */</a>
<a name="ln2439">      if (buf-&gt;b_fname != NULL) {</a>
<a name="ln2440">        new_name = vim_strsave(buf-&gt;b_fname);</a>
<a name="ln2441">      }</a>
<a name="ln2442">      set_bufref(&amp;au_new_curbuf, buf);</a>
<a name="ln2443">      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, false, curbuf);</a>
<a name="ln2444">      if (!bufref_valid(&amp;au_new_curbuf)) {</a>
<a name="ln2445">        // New buffer has been deleted.</a>
<a name="ln2446">        delbuf_msg(new_name);  // Frees new_name.</a>
<a name="ln2447">        goto theend;</a>
<a name="ln2448">      }</a>
<a name="ln2449">      if (aborting()) {             /* autocmds may abort script processing */</a>
<a name="ln2450">        xfree(new_name);</a>
<a name="ln2451">        goto theend;</a>
<a name="ln2452">      }</a>
<a name="ln2453">      if (buf == curbuf) {  // already in new buffer</a>
<a name="ln2454">        auto_buf = true;</a>
<a name="ln2455">      } else {</a>
<a name="ln2456">        win_T *the_curwin = curwin;</a>
<a name="ln2457"> </a>
<a name="ln2458">        // Set w_closing to avoid that autocommands close the window.</a>
<a name="ln2459">        // Set b_locked for the same reason.</a>
<a name="ln2460">        the_curwin-&gt;w_closing = true;</a>
<a name="ln2461">        buf-&gt;b_locked++;</a>
<a name="ln2462"> </a>
<a name="ln2463">        if (curbuf == old_curbuf.br_buf) {</a>
<a name="ln2464">          buf_copy_options(buf, BCO_ENTER);</a>
<a name="ln2465">        }</a>
<a name="ln2466"> </a>
<a name="ln2467">        // Close the link to the current buffer. This will set</a>
<a name="ln2468">        // oldwin-&gt;w_buffer to NULL.</a>
<a name="ln2469">        u_sync(false);</a>
<a name="ln2470">        close_buffer(oldwin, curbuf,</a>
<a name="ln2471">                     (flags &amp; ECMD_HIDE) || curbuf-&gt;terminal ? 0 : DOBUF_UNLOAD,</a>
<a name="ln2472">                     false);</a>
<a name="ln2473"> </a>
<a name="ln2474">        // Autocommands may have closed the window.</a>
<a name="ln2475">        if (win_valid(the_curwin)) {</a>
<a name="ln2476">          the_curwin-&gt;w_closing = false;</a>
<a name="ln2477">        }</a>
<a name="ln2478">        buf-&gt;b_locked--;</a>
<a name="ln2479"> </a>
<a name="ln2480">        // autocmds may abort script processing</a>
<a name="ln2481">        if (aborting() &amp;&amp; curwin-&gt;w_buffer != NULL) {</a>
<a name="ln2482">          xfree(new_name);</a>
<a name="ln2483">          goto theend;</a>
<a name="ln2484">        }</a>
<a name="ln2485">        // Be careful again, like above.</a>
<a name="ln2486">        if (!bufref_valid(&amp;au_new_curbuf)) {</a>
<a name="ln2487">          // New buffer has been deleted.</a>
<a name="ln2488">          delbuf_msg(new_name);  // Frees new_name.</a>
<a name="ln2489">          goto theend;</a>
<a name="ln2490">        }</a>
<a name="ln2491">        if (buf == curbuf) {  // already in new buffer</a>
<a name="ln2492">          auto_buf = true;</a>
<a name="ln2493">        } else {</a>
<a name="ln2494">          // &lt;VN&gt; We could instead free the synblock</a>
<a name="ln2495">          // and re-attach to buffer, perhaps.</a>
<a name="ln2496">          if (curwin-&gt;w_buffer == NULL</a>
<a name="ln2497">              || curwin-&gt;w_s == &amp;(curwin-&gt;w_buffer-&gt;b_s)) {</a>
<a name="ln2498">            curwin-&gt;w_s = &amp;(buf-&gt;b_s);</a>
<a name="ln2499">          }</a>
<a name="ln2500"> </a>
<a name="ln2501">          curwin-&gt;w_buffer = buf;</a>
<a name="ln2502">          curbuf = buf;</a>
<a name="ln2503">          ++curbuf-&gt;b_nwindows;</a>
<a name="ln2504"> </a>
<a name="ln2505">          /* Set 'fileformat', 'binary' and 'fenc' when forced. */</a>
<a name="ln2506">          if (!oldbuf &amp;&amp; eap != NULL) {</a>
<a name="ln2507">            set_file_options(TRUE, eap);</a>
<a name="ln2508">            set_forced_fenc(eap);</a>
<a name="ln2509">          }</a>
<a name="ln2510">        }</a>
<a name="ln2511"> </a>
<a name="ln2512">        /* May get the window options from the last time this buffer</a>
<a name="ln2513">         * was in this window (or another window).  If not used</a>
<a name="ln2514">         * before, reset the local window options to the global</a>
<a name="ln2515">         * values.  Also restores old folding stuff. */</a>
<a name="ln2516">        get_winopts(curbuf);</a>
<a name="ln2517">        did_get_winopts = TRUE;</a>
<a name="ln2518"> </a>
<a name="ln2519">      }</a>
<a name="ln2520">      xfree(new_name);</a>
<a name="ln2521">      au_new_curbuf.br_buf = NULL;</a>
<a name="ln2522">      au_new_curbuf.br_buf_free_count = 0;</a>
<a name="ln2523">    }</a>
<a name="ln2524"> </a>
<a name="ln2525">    curwin-&gt;w_pcmark.lnum = 1;</a>
<a name="ln2526">    curwin-&gt;w_pcmark.col = 0;</a>
<a name="ln2527">  } else {  // !other_file</a>
<a name="ln2528">    if ((flags &amp; (ECMD_ADDBUF | ECMD_ALTBUF)) || check_fname() == FAIL) {</a>
<a name="ln2529">      goto theend;</a>
<a name="ln2530">    }</a>
<a name="ln2531">    oldbuf = (flags &amp; ECMD_OLDBUF);</a>
<a name="ln2532">  }</a>
<a name="ln2533"> </a>
<a name="ln2534">  // Don't redraw until the cursor is in the right line, otherwise</a>
<a name="ln2535">  // autocommands may cause ml_get errors.</a>
<a name="ln2536">  RedrawingDisabled++;</a>
<a name="ln2537">  did_inc_redrawing_disabled = true;</a>
<a name="ln2538"> </a>
<a name="ln2539">  buf = curbuf;</a>
<a name="ln2540">  if ((flags &amp; ECMD_SET_HELP) || keep_help_flag) {</a>
<a name="ln2541">    prepare_help_buffer();</a>
<a name="ln2542">  } else if (!curbuf-&gt;b_help) {</a>
<a name="ln2543">    // Don't make a buffer listed if it's a help buffer.  Useful when using</a>
<a name="ln2544">    // CTRL-O to go back to a help file.</a>
<a name="ln2545">    set_buflisted(TRUE);</a>
<a name="ln2546">  }</a>
<a name="ln2547"> </a>
<a name="ln2548">  /* If autocommands change buffers under our fingers, forget about</a>
<a name="ln2549">   * editing the file. */</a>
<a name="ln2550">  if (buf != curbuf)</a>
<a name="ln2551">    goto theend;</a>
<a name="ln2552">  if (aborting())           /* autocmds may abort script processing */</a>
<a name="ln2553">    goto theend;</a>
<a name="ln2554"> </a>
<a name="ln2555">  /* Since we are starting to edit a file, consider the filetype to be</a>
<a name="ln2556">   * unset.  Helps for when an autocommand changes files and expects syntax</a>
<a name="ln2557">   * highlighting to work in the other file. */</a>
<a name="ln2558">  did_filetype = FALSE;</a>
<a name="ln2559"> </a>
<a name="ln2560">  /*</a>
<a name="ln2561">   * other_file	oldbuf</a>
<a name="ln2562">   *  FALSE	FALSE	    re-edit same file, buffer is re-used</a>
<a name="ln2563">   *  FALSE	TRUE	    re-edit same file, nothing changes</a>
<a name="ln2564">   *  TRUE	FALSE	    start editing new file, new buffer</a>
<a name="ln2565">   *  TRUE	TRUE	    start editing in existing buffer (nothing to do)</a>
<a name="ln2566">   */</a>
<a name="ln2567">  if (!other_file &amp;&amp; !oldbuf) {         /* re-use the buffer */</a>
<a name="ln2568">    set_last_cursor(curwin);            /* may set b_last_cursor */</a>
<a name="ln2569">    if (newlnum == ECMD_LAST || newlnum == ECMD_LASTL) {</a>
<a name="ln2570">      newlnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln2571">      solcol = curwin-&gt;w_cursor.col;</a>
<a name="ln2572">    }</a>
<a name="ln2573">    buf = curbuf;</a>
<a name="ln2574">    if (buf-&gt;b_fname != NULL) {</a>
<a name="ln2575">      new_name = vim_strsave(buf-&gt;b_fname);</a>
<a name="ln2576">    } else {</a>
<a name="ln2577">      new_name = NULL;</a>
<a name="ln2578">    }</a>
<a name="ln2579">    set_bufref(&amp;bufref, buf);</a>
<a name="ln2580"> </a>
<a name="ln2581">    // If the buffer was used before, store the current contents so that</a>
<a name="ln2582">    // the reload can be undone.  Do not do this if the (empty) buffer is</a>
<a name="ln2583">    // being re-used for another file.</a>
<a name="ln2584">    if (!(curbuf-&gt;b_flags &amp; BF_NEVERLOADED)</a>
<a name="ln2585">        &amp;&amp; (p_ur &lt; 0 || curbuf-&gt;b_ml.ml_line_count &lt;= p_ur)) {</a>
<a name="ln2586">      // Sync first so that this is a separate undo-able action.</a>
<a name="ln2587">      u_sync(false);</a>
<a name="ln2588">      if (u_savecommon(0, curbuf-&gt;b_ml.ml_line_count + 1, 0, true)</a>
<a name="ln2589">          == FAIL) {</a>
<a name="ln2590">        xfree(new_name);</a>
<a name="ln2591">        goto theend;</a>
<a name="ln2592">      }</a>
<a name="ln2593">      u_unchanged(curbuf);</a>
<a name="ln2594">      buf_updates_unload(curbuf, false);</a>
<a name="ln2595">      buf_freeall(curbuf, BFA_KEEP_UNDO);</a>
<a name="ln2596"> </a>
<a name="ln2597">      // Tell readfile() not to clear or reload undo info.</a>
<a name="ln2598">      readfile_flags = READ_KEEP_UNDO;</a>
<a name="ln2599">    } else {</a>
<a name="ln2600">      buf_updates_unload(curbuf, false);</a>
<a name="ln2601">      buf_freeall(curbuf, 0);  // Free all things for buffer.</a>
<a name="ln2602">    }</a>
<a name="ln2603">    // If autocommands deleted the buffer we were going to re-edit, give</a>
<a name="ln2604">    // up and jump to the end.</a>
<a name="ln2605">    if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln2606">      delbuf_msg(new_name);  // Frees new_name.</a>
<a name="ln2607">      goto theend;</a>
<a name="ln2608">    }</a>
<a name="ln2609">    xfree(new_name);</a>
<a name="ln2610"> </a>
<a name="ln2611">    /* If autocommands change buffers under our fingers, forget about</a>
<a name="ln2612">     * re-editing the file.  Should do the buf_clear_file(), but perhaps</a>
<a name="ln2613">     * the autocommands changed the buffer... */</a>
<a name="ln2614">    if (buf != curbuf)</a>
<a name="ln2615">      goto theend;</a>
<a name="ln2616">    if (aborting())         /* autocmds may abort script processing */</a>
<a name="ln2617">      goto theend;</a>
<a name="ln2618">    buf_clear_file(curbuf);</a>
<a name="ln2619">    curbuf-&gt;b_op_start.lnum = 0;        /* clear '[ and '] marks */</a>
<a name="ln2620">    curbuf-&gt;b_op_end.lnum = 0;</a>
<a name="ln2621">  }</a>
<a name="ln2622"> </a>
<a name="ln2623">  /*</a>
<a name="ln2624">   * If we get here we are sure to start editing</a>
<a name="ln2625">   */</a>
<a name="ln2626"> </a>
<a name="ln2627">  /* Assume success now */</a>
<a name="ln2628">  retval = OK;</a>
<a name="ln2629"> </a>
<a name="ln2630">  /*</a>
<a name="ln2631">   * Check if we are editing the w_arg_idx file in the argument list.</a>
<a name="ln2632">   */</a>
<a name="ln2633">  check_arg_idx(curwin);</a>
<a name="ln2634"> </a>
<a name="ln2635">  if (!auto_buf) {</a>
<a name="ln2636">    /*</a>
<a name="ln2637">     * Set cursor and init window before reading the file and executing</a>
<a name="ln2638">     * autocommands.  This allows for the autocommands to position the</a>
<a name="ln2639">     * cursor.</a>
<a name="ln2640">     */</a>
<a name="ln2641">    curwin_init();</a>
<a name="ln2642"> </a>
<a name="ln2643">    /* It's possible that all lines in the buffer changed.  Need to update</a>
<a name="ln2644">     * automatic folding for all windows where it's used. */</a>
<a name="ln2645">    FOR_ALL_TAB_WINDOWS(tp, win) {</a>
<a name="ln2646">      if (win-&gt;w_buffer == curbuf) {</a>
<a name="ln2647">        foldUpdateAll(win);</a>
<a name="ln2648">      }</a>
<a name="ln2649">    }</a>
<a name="ln2650"> </a>
<a name="ln2651">    /* Change directories when the 'acd' option is set. */</a>
<a name="ln2652">    do_autochdir();</a>
<a name="ln2653"> </a>
<a name="ln2654">    /*</a>
<a name="ln2655">     * Careful: open_buffer() and apply_autocmds() may change the current</a>
<a name="ln2656">     * buffer and window.</a>
<a name="ln2657">     */</a>
<a name="ln2658">    orig_pos = curwin-&gt;w_cursor;</a>
<a name="ln2659">    topline = curwin-&gt;w_topline;</a>
<a name="ln2660">    if (!oldbuf) {                          /* need to read the file */</a>
<a name="ln2661">      swap_exists_action = SEA_DIALOG;</a>
<a name="ln2662">      curbuf-&gt;b_flags |= BF_CHECK_RO;       /* set/reset 'ro' flag */</a>
<a name="ln2663"> </a>
<a name="ln2664">      /*</a>
<a name="ln2665">       * Open the buffer and read the file.</a>
<a name="ln2666">       */</a>
<a name="ln2667">      if (should_abort(open_buffer(FALSE, eap, readfile_flags)))</a>
<a name="ln2668">        retval = FAIL;</a>
<a name="ln2669"> </a>
<a name="ln2670">      if (swap_exists_action == SEA_QUIT)</a>
<a name="ln2671">        retval = FAIL;</a>
<a name="ln2672">      handle_swap_exists(&amp;old_curbuf);</a>
<a name="ln2673">    } else {</a>
<a name="ln2674">      /* Read the modelines, but only to set window-local options.  Any</a>
<a name="ln2675">       * buffer-local options have already been set and may have been</a>
<a name="ln2676">       * changed by the user. */</a>
<a name="ln2677">      do_modelines(OPT_WINONLY);</a>
<a name="ln2678"> </a>
<a name="ln2679">      apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf,</a>
<a name="ln2680">          &amp;retval);</a>
<a name="ln2681">      apply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf,</a>
<a name="ln2682">          &amp;retval);</a>
<a name="ln2683">    }</a>
<a name="ln2684">    check_arg_idx(curwin);</a>
<a name="ln2685"> </a>
<a name="ln2686">    // If autocommands change the cursor position or topline, we should</a>
<a name="ln2687">    // keep it.  Also when it moves within a line. But not when it moves</a>
<a name="ln2688">    // to the first non-blank.</a>
<a name="ln2689">    if (!equalpos(curwin-&gt;w_cursor, orig_pos)) {</a>
<a name="ln2690">      const char_u *text = get_cursor_line_ptr();</a>
<a name="ln2691"> </a>
<a name="ln2692">      if (curwin-&gt;w_cursor.lnum != orig_pos.lnum</a>
<a name="ln2693">          || curwin-&gt;w_cursor.col != (int)(skipwhite(text) - text)) {</a>
<a name="ln2694">        newlnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln2695">        newcol = curwin-&gt;w_cursor.col;</a>
<a name="ln2696">      }</a>
<a name="ln2697">    }</a>
<a name="ln2698">    if (curwin-&gt;w_topline == topline)</a>
<a name="ln2699">      topline = 0;</a>
<a name="ln2700"> </a>
<a name="ln2701">    /* Even when cursor didn't move we need to recompute topline. */</a>
<a name="ln2702">    changed_line_abv_curs();</a>
<a name="ln2703"> </a>
<a name="ln2704">    maketitle();</a>
<a name="ln2705">  }</a>
<a name="ln2706"> </a>
<a name="ln2707">  /* Tell the diff stuff that this buffer is new and/or needs updating.</a>
<a name="ln2708">   * Also needed when re-editing the same buffer, because unloading will</a>
<a name="ln2709">   * have removed it as a diff buffer. */</a>
<a name="ln2710">  if (curwin-&gt;w_p_diff) {</a>
<a name="ln2711">    diff_buf_add(curbuf);</a>
<a name="ln2712">    diff_invalidate(curbuf);</a>
<a name="ln2713">  }</a>
<a name="ln2714"> </a>
<a name="ln2715">  /* If the window options were changed may need to set the spell language.</a>
<a name="ln2716">   * Can only do this after the buffer has been properly setup. */</a>
<a name="ln2717">  if (did_get_winopts &amp;&amp; curwin-&gt;w_p_spell &amp;&amp; *curwin-&gt;w_s-&gt;b_p_spl != NUL)</a>
<a name="ln2718">    (void)did_set_spelllang(curwin);</a>
<a name="ln2719"> </a>
<a name="ln2720">  if (command == NULL) {</a>
<a name="ln2721">    if (newcol &gt;= 0) {          /* position set by autocommands */</a>
<a name="ln2722">      curwin-&gt;w_cursor.lnum = newlnum;</a>
<a name="ln2723">      curwin-&gt;w_cursor.col = newcol;</a>
<a name="ln2724">      check_cursor();</a>
<a name="ln2725">    } else if (newlnum &gt; 0) { /* line number from caller or old position */</a>
<a name="ln2726">      curwin-&gt;w_cursor.lnum = newlnum;</a>
<a name="ln2727">      check_cursor_lnum();</a>
<a name="ln2728">      if (solcol &gt;= 0 &amp;&amp; !p_sol) {</a>
<a name="ln2729">        /* 'sol' is off: Use last known column. */</a>
<a name="ln2730">        curwin-&gt;w_cursor.col = solcol;</a>
<a name="ln2731">        check_cursor_col();</a>
<a name="ln2732">        curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln2733">        curwin-&gt;w_set_curswant = TRUE;</a>
<a name="ln2734">      } else</a>
<a name="ln2735">        beginline(BL_SOL | BL_FIX);</a>
<a name="ln2736">    } else {                  /* no line number, go to last line in Ex mode */</a>
<a name="ln2737">      if (exmode_active)</a>
<a name="ln2738">        curwin-&gt;w_cursor.lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln2739">      beginline(BL_WHITE | BL_FIX);</a>
<a name="ln2740">    }</a>
<a name="ln2741">  }</a>
<a name="ln2742"> </a>
<a name="ln2743">  /* Check if cursors in other windows on the same buffer are still valid */</a>
<a name="ln2744">  check_lnums(FALSE);</a>
<a name="ln2745"> </a>
<a name="ln2746">  /*</a>
<a name="ln2747">   * Did not read the file, need to show some info about the file.</a>
<a name="ln2748">   * Do this after setting the cursor.</a>
<a name="ln2749">   */</a>
<a name="ln2750">  if (oldbuf</a>
<a name="ln2751">      &amp;&amp; !auto_buf</a>
<a name="ln2752">      ) {</a>
<a name="ln2753">    int msg_scroll_save = msg_scroll;</a>
<a name="ln2754"> </a>
<a name="ln2755">    /* Obey the 'O' flag in 'cpoptions': overwrite any previous file</a>
<a name="ln2756">     * message. */</a>
<a name="ln2757">    if (shortmess(SHM_OVERALL) &amp;&amp; !exiting &amp;&amp; p_verbose == 0)</a>
<a name="ln2758">      msg_scroll = FALSE;</a>
<a name="ln2759">    if (!msg_scroll)            /* wait a bit when overwriting an error msg */</a>
<a name="ln2760">      check_for_delay(FALSE);</a>
<a name="ln2761">    msg_start();</a>
<a name="ln2762">    msg_scroll = msg_scroll_save;</a>
<a name="ln2763">    msg_scrolled_ign = TRUE;</a>
<a name="ln2764"> </a>
<a name="ln2765">    if (!shortmess(SHM_FILEINFO)) {</a>
<a name="ln2766">      fileinfo(false, true, false);</a>
<a name="ln2767">    }</a>
<a name="ln2768"> </a>
<a name="ln2769">    msg_scrolled_ign = FALSE;</a>
<a name="ln2770">  }</a>
<a name="ln2771"> </a>
<a name="ln2772">  curbuf-&gt;b_last_used = time(NULL);</a>
<a name="ln2773"> </a>
<a name="ln2774">  if (command != NULL)</a>
<a name="ln2775">    do_cmdline(command, NULL, NULL, DOCMD_VERBOSE);</a>
<a name="ln2776"> </a>
<a name="ln2777">  if (curbuf-&gt;b_kmap_state &amp; KEYMAP_INIT)</a>
<a name="ln2778">    (void)keymap_init();</a>
<a name="ln2779"> </a>
<a name="ln2780">  RedrawingDisabled--;</a>
<a name="ln2781">  did_inc_redrawing_disabled = false;</a>
<a name="ln2782">  if (!skip_redraw) {</a>
<a name="ln2783">    n = *so_ptr;</a>
<a name="ln2784">    if (topline == 0 &amp;&amp; command == NULL) {</a>
<a name="ln2785">      *so_ptr = 999;    // force cursor to be vertically centered in the window</a>
<a name="ln2786">    }</a>
<a name="ln2787">    update_topline(curwin);</a>
<a name="ln2788">    curwin-&gt;w_scbind_pos = curwin-&gt;w_topline;</a>
<a name="ln2789">    *so_ptr = n;</a>
<a name="ln2790">    redraw_curbuf_later(NOT_VALID);     // redraw this buffer later</a>
<a name="ln2791">  }</a>
<a name="ln2792"> </a>
<a name="ln2793">  if (p_im)</a>
<a name="ln2794">    need_start_insertmode = TRUE;</a>
<a name="ln2795"> </a>
<a name="ln2796">  /* Change directories when the 'acd' option is set. */</a>
<a name="ln2797">  do_autochdir();</a>
<a name="ln2798"> </a>
<a name="ln2799"> </a>
<a name="ln2800">theend:</a>
<a name="ln2801">  if (bufref_valid(&amp;old_curbuf) &amp;&amp; old_curbuf.br_buf-&gt;terminal != NULL) {</a>
<a name="ln2802">    terminal_check_size(old_curbuf.br_buf-&gt;terminal);</a>
<a name="ln2803">  }</a>
<a name="ln2804"> </a>
<a name="ln2805">  if (did_inc_redrawing_disabled) {</a>
<a name="ln2806">    RedrawingDisabled--;</a>
<a name="ln2807">  }</a>
<a name="ln2808">  if (did_set_swapcommand) {</a>
<a name="ln2809">    set_vim_var_string(VV_SWAPCOMMAND, NULL, -1);</a>
<a name="ln2810">  }</a>
<a name="ln2811">  xfree(free_fname);</a>
<a name="ln2812">  return retval;</a>
<a name="ln2813">}</a>
<a name="ln2814"> </a>
<a name="ln2815">static void delbuf_msg(char_u *name)</a>
<a name="ln2816">{</a>
<a name="ln2817">  EMSG2(_(&quot;E143: Autocommands unexpectedly deleted new buffer %s&quot;),</a>
<a name="ln2818">      name == NULL ? (char_u *)&quot;&quot; : name);</a>
<a name="ln2819">  xfree(name);</a>
<a name="ln2820">  au_new_curbuf.br_buf = NULL;</a>
<a name="ln2821">  au_new_curbuf.br_buf_free_count = 0;</a>
<a name="ln2822">}</a>
<a name="ln2823"> </a>
<a name="ln2824">static int append_indent = 0;       /* autoindent for first line */</a>
<a name="ln2825"> </a>
<a name="ln2826">/*</a>
<a name="ln2827"> * &quot;:insert&quot; and &quot;:append&quot;, also used by &quot;:change&quot;</a>
<a name="ln2828"> */</a>
<a name="ln2829">void ex_append(exarg_T *eap)</a>
<a name="ln2830">{</a>
<a name="ln2831">  char_u      *theline;</a>
<a name="ln2832">  bool did_undo = false;</a>
<a name="ln2833">  linenr_T lnum = eap-&gt;line2;</a>
<a name="ln2834">  int indent = 0;</a>
<a name="ln2835">  char_u      *p;</a>
<a name="ln2836">  int vcol;</a>
<a name="ln2837">  int empty = (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY);</a>
<a name="ln2838"> </a>
<a name="ln2839">  /* the ! flag toggles autoindent */</a>
<a name="ln2840">  if (eap-&gt;forceit)</a>
<a name="ln2841">    curbuf-&gt;b_p_ai = !curbuf-&gt;b_p_ai;</a>
<a name="ln2842"> </a>
<a name="ln2843">  /* First autoindent comes from the line we start on */</a>
<a name="ln2844">  if (eap-&gt;cmdidx != CMD_change &amp;&amp; curbuf-&gt;b_p_ai &amp;&amp; lnum &gt; 0)</a>
<a name="ln2845">    append_indent = get_indent_lnum(lnum);</a>
<a name="ln2846"> </a>
<a name="ln2847">  if (eap-&gt;cmdidx != CMD_append)</a>
<a name="ln2848">    --lnum;</a>
<a name="ln2849"> </a>
<a name="ln2850">  // when the buffer is empty need to delete the dummy line</a>
<a name="ln2851">  if (empty &amp;&amp; lnum == 1)</a>
<a name="ln2852">    lnum = 0;</a>
<a name="ln2853"> </a>
<a name="ln2854">  State = INSERT;                   /* behave like in Insert mode */</a>
<a name="ln2855">  if (curbuf-&gt;b_p_iminsert == B_IMODE_LMAP)</a>
<a name="ln2856">    State |= LANGMAP;</a>
<a name="ln2857"> </a>
<a name="ln2858">  for (;; ) {</a>
<a name="ln2859">    msg_scroll = TRUE;</a>
<a name="ln2860">    need_wait_return = FALSE;</a>
<a name="ln2861">    if (curbuf-&gt;b_p_ai) {</a>
<a name="ln2862">      if (append_indent &gt;= 0) {</a>
<a name="ln2863">        indent = append_indent;</a>
<a name="ln2864">        append_indent = -1;</a>
<a name="ln2865">      } else if (lnum &gt; 0)</a>
<a name="ln2866">        indent = get_indent_lnum(lnum);</a>
<a name="ln2867">    }</a>
<a name="ln2868">    ex_keep_indent = FALSE;</a>
<a name="ln2869">    if (eap-&gt;getline == NULL) {</a>
<a name="ln2870">      /* No getline() function, use the lines that follow. This ends</a>
<a name="ln2871">       * when there is no more. */</a>
<a name="ln2872">      if (eap-&gt;nextcmd == NULL || *eap-&gt;nextcmd == NUL)</a>
<a name="ln2873">        break;</a>
<a name="ln2874">      p = vim_strchr(eap-&gt;nextcmd, NL);</a>
<a name="ln2875">      if (p == NULL)</a>
<a name="ln2876">        p = eap-&gt;nextcmd + STRLEN(eap-&gt;nextcmd);</a>
<a name="ln2877">      theline = vim_strnsave(eap-&gt;nextcmd, p - eap-&gt;nextcmd);</a>
<a name="ln2878">      if (*p != NUL) {</a>
<a name="ln2879">        p++;</a>
<a name="ln2880">      }</a>
<a name="ln2881">      eap-&gt;nextcmd = p;</a>
<a name="ln2882">    } else {</a>
<a name="ln2883">      // Set State to avoid the cursor shape to be set to INSERT mode</a>
<a name="ln2884">      // when getline() returns.</a>
<a name="ln2885">      int save_State = State;</a>
<a name="ln2886">      State = CMDLINE;</a>
<a name="ln2887">      theline = eap-&gt;getline(</a>
<a name="ln2888">          eap-&gt;cstack-&gt;cs_looplevel &gt; 0 ? -1 :</a>
<a name="ln2889">          NUL, eap-&gt;cookie, indent, true);</a>
<a name="ln2890">      State = save_State;</a>
<a name="ln2891">    }</a>
<a name="ln2892">    lines_left = Rows - 1;</a>
<a name="ln2893">    if (theline == NULL)</a>
<a name="ln2894">      break;</a>
<a name="ln2895"> </a>
<a name="ln2896">    /* Using ^ CTRL-D in getexmodeline() makes us repeat the indent. */</a>
<a name="ln2897">    if (ex_keep_indent)</a>
<a name="ln2898">      append_indent = indent;</a>
<a name="ln2899"> </a>
<a name="ln2900">    /* Look for the &quot;.&quot; after automatic indent. */</a>
<a name="ln2901">    vcol = 0;</a>
<a name="ln2902">    for (p = theline; indent &gt; vcol; ++p) {</a>
<a name="ln2903">      if (*p == ' ')</a>
<a name="ln2904">        ++vcol;</a>
<a name="ln2905">      else if (*p == TAB)</a>
<a name="ln2906">        vcol += 8 - vcol % 8;</a>
<a name="ln2907">      else</a>
<a name="ln2908">        break;</a>
<a name="ln2909">    }</a>
<a name="ln2910">    if ((p[0] == '.' &amp;&amp; p[1] == NUL)</a>
<a name="ln2911">        || (!did_undo &amp;&amp; u_save(lnum, lnum + 1 + (empty ? 1 : 0))</a>
<a name="ln2912">            == FAIL)) {</a>
<a name="ln2913">      xfree(theline);</a>
<a name="ln2914">      break;</a>
<a name="ln2915">    }</a>
<a name="ln2916"> </a>
<a name="ln2917">    /* don't use autoindent if nothing was typed. */</a>
<a name="ln2918">    if (p[0] == NUL)</a>
<a name="ln2919">      theline[0] = NUL;</a>
<a name="ln2920"> </a>
<a name="ln2921">    did_undo = true;</a>
<a name="ln2922">    ml_append(lnum, theline, (colnr_T)0, false);</a>
<a name="ln2923">    appended_lines_mark(lnum + (empty ? 1 : 0), 1L);</a>
<a name="ln2924"> </a>
<a name="ln2925">    xfree(theline);</a>
<a name="ln2926">    ++lnum;</a>
<a name="ln2927"> </a>
<a name="ln2928">    if (empty) {</a>
<a name="ln2929">      ml_delete(2L, false);</a>
<a name="ln2930">      empty = 0;</a>
<a name="ln2931">    }</a>
<a name="ln2932">  }</a>
<a name="ln2933">  State = NORMAL;</a>
<a name="ln2934"> </a>
<a name="ln2935">  if (eap-&gt;forceit)</a>
<a name="ln2936">    curbuf-&gt;b_p_ai = !curbuf-&gt;b_p_ai;</a>
<a name="ln2937"> </a>
<a name="ln2938">  /* &quot;start&quot; is set to eap-&gt;line2+1 unless that position is invalid (when</a>
<a name="ln2939">   * eap-&gt;line2 pointed to the end of the buffer and nothing was appended)</a>
<a name="ln2940">   * &quot;end&quot; is set to lnum when something has been appended, otherwise</a>
<a name="ln2941">   * it is the same than &quot;start&quot;  -- Acevedo */</a>
<a name="ln2942">  curbuf-&gt;b_op_start.lnum = (eap-&gt;line2 &lt; curbuf-&gt;b_ml.ml_line_count) ?</a>
<a name="ln2943">                            eap-&gt;line2 + 1 : curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln2944">  if (eap-&gt;cmdidx != CMD_append)</a>
<a name="ln2945">    --curbuf-&gt;b_op_start.lnum;</a>
<a name="ln2946">  curbuf-&gt;b_op_end.lnum = (eap-&gt;line2 &lt; lnum)</a>
<a name="ln2947">                          ? lnum : curbuf-&gt;b_op_start.lnum;</a>
<a name="ln2948">  curbuf-&gt;b_op_start.col = curbuf-&gt;b_op_end.col = 0;</a>
<a name="ln2949">  curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln2950">  check_cursor_lnum();</a>
<a name="ln2951">  beginline(BL_SOL | BL_FIX);</a>
<a name="ln2952"> </a>
<a name="ln2953">  need_wait_return = FALSE;     /* don't use wait_return() now */</a>
<a name="ln2954">  ex_no_reprint = TRUE;</a>
<a name="ln2955">}</a>
<a name="ln2956"> </a>
<a name="ln2957">/*</a>
<a name="ln2958"> * &quot;:change&quot;</a>
<a name="ln2959"> */</a>
<a name="ln2960">void ex_change(exarg_T *eap)</a>
<a name="ln2961">{</a>
<a name="ln2962">  linenr_T lnum;</a>
<a name="ln2963"> </a>
<a name="ln2964">  if (eap-&gt;line2 &gt;= eap-&gt;line1</a>
<a name="ln2965">      &amp;&amp; u_save(eap-&gt;line1 - 1, eap-&gt;line2 + 1) == FAIL)</a>
<a name="ln2966">    return;</a>
<a name="ln2967"> </a>
<a name="ln2968">  /* the ! flag toggles autoindent */</a>
<a name="ln2969">  if (eap-&gt;forceit ? !curbuf-&gt;b_p_ai : curbuf-&gt;b_p_ai)</a>
<a name="ln2970">    append_indent = get_indent_lnum(eap-&gt;line1);</a>
<a name="ln2971"> </a>
<a name="ln2972">  for (lnum = eap-&gt;line2; lnum &gt;= eap-&gt;line1; --lnum) {</a>
<a name="ln2973">    if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY)           /* nothing to delete */</a>
<a name="ln2974">      break;</a>
<a name="ln2975">    ml_delete(eap-&gt;line1, false);</a>
<a name="ln2976">  }</a>
<a name="ln2977"> </a>
<a name="ln2978">  /* make sure the cursor is not beyond the end of the file now */</a>
<a name="ln2979">  check_cursor_lnum();</a>
<a name="ln2980">  deleted_lines_mark(eap-&gt;line1, (long)(eap-&gt;line2 - lnum));</a>
<a name="ln2981"> </a>
<a name="ln2982">  /* &quot;:append&quot; on the line above the deleted lines. */</a>
<a name="ln2983">  eap-&gt;line2 = eap-&gt;line1;</a>
<a name="ln2984">  ex_append(eap);</a>
<a name="ln2985">}</a>
<a name="ln2986"> </a>
<a name="ln2987">void ex_z(exarg_T *eap)</a>
<a name="ln2988">{</a>
<a name="ln2989">  char_u      *x;</a>
<a name="ln2990">  int64_t     bigness;</a>
<a name="ln2991">  char_u      *kind;</a>
<a name="ln2992">  int minus = 0;</a>
<a name="ln2993">  linenr_T start, end, curs, i;</a>
<a name="ln2994">  int j;</a>
<a name="ln2995">  linenr_T lnum = eap-&gt;line2;</a>
<a name="ln2996"> </a>
<a name="ln2997">  // Vi compatible: &quot;:z!&quot; uses display height, without a count uses</a>
<a name="ln2998">  // 'scroll'</a>
<a name="ln2999">  if (eap-&gt;forceit) {</a>
<a name="ln3000">    bigness = curwin-&gt;w_height_inner;</a>
<a name="ln3001">  } else if (ONE_WINDOW) {</a>
<a name="ln3002">    bigness = curwin-&gt;w_p_scr * 2;</a>
<a name="ln3003">  } else {</a>
<a name="ln3004">    bigness = curwin-&gt;w_height_inner - 3;</a>
<a name="ln3005">  }</a>
<a name="ln3006">  if (bigness &lt; 1) {</a>
<a name="ln3007">    bigness = 1;</a>
<a name="ln3008">  }</a>
<a name="ln3009"> </a>
<a name="ln3010">  x = eap-&gt;arg;</a>
<a name="ln3011">  kind = x;</a>
<a name="ln3012">  if (*kind == '-' || *kind == '+' || *kind == '='</a>
<a name="ln3013">      || *kind == '^' || *kind == '.')</a>
<a name="ln3014">    ++x;</a>
<a name="ln3015">  while (*x == '-' || *x == '+')</a>
<a name="ln3016">    ++x;</a>
<a name="ln3017"> </a>
<a name="ln3018">  if (*x != 0) {</a>
<a name="ln3019">    if (!ascii_isdigit(*x)) {</a>
<a name="ln3020">      EMSG(_(&quot;E144: non-numeric argument to :z&quot;));</a>
<a name="ln3021">      return;</a>
<a name="ln3022">    }</a>
<a name="ln3023">    bigness = atol((char *)x);</a>
<a name="ln3024"> </a>
<a name="ln3025">    // bigness could be &lt; 0 if atol(x) overflows.</a>
<a name="ln3026">    if (bigness &gt; 2 * curbuf-&gt;b_ml.ml_line_count || bigness &lt; 0) {</a>
<a name="ln3027">      bigness = 2 * curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3028">    }</a>
<a name="ln3029"> </a>
<a name="ln3030">    p_window = bigness;</a>
<a name="ln3031">    if (*kind == '=') {</a>
<a name="ln3032">      bigness += 2;</a>
<a name="ln3033">    }</a>
<a name="ln3034">  }</a>
<a name="ln3035"> </a>
<a name="ln3036">  /* the number of '-' and '+' multiplies the distance */</a>
<a name="ln3037">  if (*kind == '-' || *kind == '+')</a>
<a name="ln3038">    for (x = kind + 1; *x == *kind; ++x)</a>
<a name="ln3039">      ;</a>
<a name="ln3040"> </a>
<a name="ln3041">  switch (*kind) {</a>
<a name="ln3042">  case '-':</a>
<a name="ln3043">    start = lnum - bigness * (linenr_T)(x - kind) + 1;</a>
<a name="ln3044">    end = start + bigness - 1;</a>
<a name="ln3045">    curs = end;</a>
<a name="ln3046">    break;</a>
<a name="ln3047"> </a>
<a name="ln3048">  case '=':</a>
<a name="ln3049">    start = lnum - (bigness + 1) / 2 + 1;</a>
<a name="ln3050">    end = lnum + (bigness + 1) / 2 - 1;</a>
<a name="ln3051">    curs = lnum;</a>
<a name="ln3052">    minus = 1;</a>
<a name="ln3053">    break;</a>
<a name="ln3054"> </a>
<a name="ln3055">  case '^':</a>
<a name="ln3056">    start = lnum - bigness * 2;</a>
<a name="ln3057">    end = lnum - bigness;</a>
<a name="ln3058">    curs = lnum - bigness;</a>
<a name="ln3059">    break;</a>
<a name="ln3060"> </a>
<a name="ln3061">  case '.':</a>
<a name="ln3062">    start = lnum - (bigness + 1) / 2 + 1;</a>
<a name="ln3063">    end = lnum + (bigness + 1) / 2 - 1;</a>
<a name="ln3064">    curs = end;</a>
<a name="ln3065">    break;</a>
<a name="ln3066"> </a>
<a name="ln3067">  default:        /* '+' */</a>
<a name="ln3068">    start = lnum;</a>
<a name="ln3069">    if (*kind == '+')</a>
<a name="ln3070">      start += bigness * (linenr_T)(x - kind - 1) + 1;</a>
<a name="ln3071">    else if (eap-&gt;addr_count == 0)</a>
<a name="ln3072">      ++start;</a>
<a name="ln3073">    end = start + bigness - 1;</a>
<a name="ln3074">    curs = end;</a>
<a name="ln3075">    break;</a>
<a name="ln3076">  }</a>
<a name="ln3077"> </a>
<a name="ln3078">  if (start &lt; 1)</a>
<a name="ln3079">    start = 1;</a>
<a name="ln3080"> </a>
<a name="ln3081">  if (end &gt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln3082">    end = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3083"> </a>
<a name="ln3084">  if (curs &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3085">    curs = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3086">  } else if (curs &lt; 1) {</a>
<a name="ln3087">    curs = 1;</a>
<a name="ln3088">  }</a>
<a name="ln3089"> </a>
<a name="ln3090">  for (i = start; i &lt;= end; i++) {</a>
<a name="ln3091">    if (minus &amp;&amp; i == lnum) {</a>
<a name="ln3092">      msg_putchar('\n');</a>
<a name="ln3093"> </a>
<a name="ln3094">      for (j = 1; j &lt; Columns; j++)</a>
<a name="ln3095">        msg_putchar('-');</a>
<a name="ln3096">    }</a>
<a name="ln3097"> </a>
<a name="ln3098">    print_line(i, eap-&gt;flags &amp; EXFLAG_NR, eap-&gt;flags &amp; EXFLAG_LIST);</a>
<a name="ln3099"> </a>
<a name="ln3100">    if (minus &amp;&amp; i == lnum) {</a>
<a name="ln3101">      msg_putchar('\n');</a>
<a name="ln3102"> </a>
<a name="ln3103">      for (j = 1; j &lt; Columns; j++)</a>
<a name="ln3104">        msg_putchar('-');</a>
<a name="ln3105">    }</a>
<a name="ln3106">  }</a>
<a name="ln3107"> </a>
<a name="ln3108">  if (curwin-&gt;w_cursor.lnum != curs) {</a>
<a name="ln3109">    curwin-&gt;w_cursor.lnum = curs;</a>
<a name="ln3110">    curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3111">  }</a>
<a name="ln3112">  ex_no_reprint = true;</a>
<a name="ln3113">}</a>
<a name="ln3114"> </a>
<a name="ln3115">/*</a>
<a name="ln3116"> * Check if the secure flag is set (.exrc or .vimrc in current directory).</a>
<a name="ln3117"> * If so, give an error message and return TRUE.</a>
<a name="ln3118"> * Otherwise, return FALSE.</a>
<a name="ln3119"> */</a>
<a name="ln3120">int check_secure(void)</a>
<a name="ln3121">{</a>
<a name="ln3122">  if (secure) {</a>
<a name="ln3123">    secure = 2;</a>
<a name="ln3124">    EMSG(_(e_curdir));</a>
<a name="ln3125">    return TRUE;</a>
<a name="ln3126">  }</a>
<a name="ln3127"> </a>
<a name="ln3128">  // In the sandbox more things are not allowed, including the things</a>
<a name="ln3129">  // disallowed in secure mode.</a>
<a name="ln3130">  if (sandbox != 0) {</a>
<a name="ln3131">    EMSG(_(e_sandbox));</a>
<a name="ln3132">    return TRUE;</a>
<a name="ln3133">  }</a>
<a name="ln3134">  return FALSE;</a>
<a name="ln3135">}</a>
<a name="ln3136"> </a>
<a name="ln3137">/// Previous substitute replacement string</a>
<a name="ln3138">static SubReplacementString old_sub = {NULL, 0, NULL};</a>
<a name="ln3139"> </a>
<a name="ln3140">static int global_need_beginline;       // call beginline() after &quot;:g&quot;</a>
<a name="ln3141"> </a>
<a name="ln3142">/// Get old substitute replacement string</a>
<a name="ln3143">///</a>
<a name="ln3144">/// @param[out]  ret_sub    Location where old string will be saved.</a>
<a name="ln3145">void sub_get_replacement(SubReplacementString *const ret_sub)</a>
<a name="ln3146">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3147">{</a>
<a name="ln3148">  *ret_sub = old_sub;</a>
<a name="ln3149">}</a>
<a name="ln3150"> </a>
<a name="ln3151">/// Set substitute string and timestamp</a>
<a name="ln3152">///</a>
<a name="ln3153">/// @warning `sub` must be in allocated memory. It is not copied.</a>
<a name="ln3154">///</a>
<a name="ln3155">/// @param[in]  sub  New replacement string.</a>
<a name="ln3156">void sub_set_replacement(SubReplacementString sub)</a>
<a name="ln3157">{</a>
<a name="ln3158">  xfree(old_sub.sub);</a>
<a name="ln3159">  if (sub.additional_elements != old_sub.additional_elements) {</a>
<a name="ln3160">    tv_list_unref(old_sub.additional_elements);</a>
<a name="ln3161">  }</a>
<a name="ln3162">  old_sub = sub;</a>
<a name="ln3163">}</a>
<a name="ln3164"> </a>
<a name="ln3165">/// Recognize &quot;:%s/\n//&quot; and turn it into a join command, which is much</a>
<a name="ln3166">/// more efficient.</a>
<a name="ln3167">///</a>
<a name="ln3168">/// @param[in]  eap  Ex arguments</a>
<a name="ln3169">/// @param[in]  pat  Search pattern</a>
<a name="ln3170">/// @param[in]  sub  Replacement string</a>
<a name="ln3171">/// @param[in]  cmd  Command from :s_flags</a>
<a name="ln3172">/// @param[in]  save Save pattern to options, history</a>
<a name="ln3173">///</a>
<a name="ln3174">/// @returns true if :substitute can be replaced with a join command</a>
<a name="ln3175">static bool sub_joining_lines(exarg_T *eap, char_u *pat, char_u *sub,</a>
<a name="ln3176">                              char_u *cmd, bool save)</a>
<a name="ln3177">  FUNC_ATTR_NONNULL_ARG(1, 3, 4)</a>
<a name="ln3178">{</a>
<a name="ln3179">  // TODO(vim): find a generic solution to make line-joining operations more</a>
<a name="ln3180">  // efficient, avoid allocating a string that grows in size.</a>
<a name="ln3181">  if (pat != NULL</a>
<a name="ln3182">      &amp;&amp; strcmp((const char *)pat, &quot;\\n&quot;) == 0</a>
<a name="ln3183">      &amp;&amp; *sub == NUL</a>
<a name="ln3184">      &amp;&amp; (*cmd == NUL || (cmd[1] == NUL</a>
<a name="ln3185">                          &amp;&amp; (*cmd == 'g'</a>
<a name="ln3186">                              || *cmd == 'l'</a>
<a name="ln3187">                              || *cmd == 'p'</a>
<a name="ln3188">                              || *cmd == '#')))) {</a>
<a name="ln3189">    if (eap-&gt;skip) {</a>
<a name="ln3190">      return true;</a>
<a name="ln3191">    }</a>
<a name="ln3192">    curwin-&gt;w_cursor.lnum = eap-&gt;line1;</a>
<a name="ln3193">    if (*cmd == 'l') {</a>
<a name="ln3194">      eap-&gt;flags = EXFLAG_LIST;</a>
<a name="ln3195">    } else if (*cmd == '#') {</a>
<a name="ln3196">      eap-&gt;flags = EXFLAG_NR;</a>
<a name="ln3197">    } else if (*cmd == 'p') {</a>
<a name="ln3198">      eap-&gt;flags = EXFLAG_PRINT;</a>
<a name="ln3199">    }</a>
<a name="ln3200"> </a>
<a name="ln3201">    // The number of lines joined is the number of lines in the range</a>
<a name="ln3202">    linenr_T joined_lines_count = eap-&gt;line2 - eap-&gt;line1 + 1</a>
<a name="ln3203">      // plus one extra line if not at the end of file.</a>
<a name="ln3204">      + (eap-&gt;line2 &lt; curbuf-&gt;b_ml.ml_line_count ? 1 : 0);</a>
<a name="ln3205">    if (joined_lines_count &gt; 1) {</a>
<a name="ln3206">      do_join(joined_lines_count, FALSE, TRUE, FALSE, true);</a>
<a name="ln3207">      sub_nsubs = joined_lines_count - 1;</a>
<a name="ln3208">      sub_nlines = 1;</a>
<a name="ln3209">      do_sub_msg(false);</a>
<a name="ln3210">      ex_may_print(eap);</a>
<a name="ln3211">    }</a>
<a name="ln3212"> </a>
<a name="ln3213">    if (save) {</a>
<a name="ln3214">      if (!cmdmod.keeppatterns) {</a>
<a name="ln3215">        save_re_pat(RE_SUBST, pat, p_magic);</a>
<a name="ln3216">      }</a>
<a name="ln3217">      add_to_history(HIST_SEARCH, pat, true, NUL);</a>
<a name="ln3218">    }</a>
<a name="ln3219"> </a>
<a name="ln3220">    return true;</a>
<a name="ln3221">  }</a>
<a name="ln3222"> </a>
<a name="ln3223">  return false;</a>
<a name="ln3224">}</a>
<a name="ln3225"> </a>
<a name="ln3226">/// Allocate memory to store the replacement text for :substitute.</a>
<a name="ln3227">///</a>
<a name="ln3228">/// Slightly more memory that is strictly necessary is allocated to reduce the</a>
<a name="ln3229">/// frequency of memory (re)allocation.</a>
<a name="ln3230">///</a>
<a name="ln3231">/// @param[in,out]  new_start   pointer to the memory for the replacement text</a>
<a name="ln3232">/// @param[in]      needed_len  amount of memory needed</a>
<a name="ln3233">///</a>
<a name="ln3234">/// @returns pointer to the end of the allocated memory</a>
<a name="ln3235">static char_u *sub_grow_buf(char_u **new_start, int needed_len)</a>
<a name="ln3236">  FUNC_ATTR_NONNULL_ARG(1) FUNC_ATTR_NONNULL_RET</a>
<a name="ln3237">{</a>
<a name="ln3238">  int new_start_len = 0;</a>
<a name="ln3239">  char_u *new_end;</a>
<a name="ln3240">  if (*new_start == NULL) {</a>
<a name="ln3241">    // Get some space for a temporary buffer to do the</a>
<a name="ln3242">    // substitution into (and some extra space to avoid</a>
<a name="ln3243">    // too many calls to xmalloc()/free()).</a>
<a name="ln3244">    new_start_len = needed_len + 50;</a>
<a name="ln3245">    *new_start = xmalloc(new_start_len);</a>
<a name="ln3246">    **new_start = NUL;</a>
<a name="ln3247">    new_end = *new_start;</a>
<a name="ln3248">  } else {</a>
<a name="ln3249">    // Check if the temporary buffer is long enough to do the</a>
<a name="ln3250">    // substitution into.  If not, make it larger (with a bit</a>
<a name="ln3251">    // extra to avoid too many calls to xmalloc()/free()).</a>
<a name="ln3252">    size_t len = STRLEN(*new_start);</a>
<a name="ln3253">    needed_len += len;</a>
<a name="ln3254">    if (needed_len &gt; new_start_len) {</a>
<a name="ln3255">      new_start_len = needed_len + 50;</a>
<a name="ln3256">      *new_start = xrealloc(*new_start, new_start_len);</a>
<a name="ln3257">    }</a>
<a name="ln3258">    new_end = *new_start + len;</a>
<a name="ln3259">  }</a>
<a name="ln3260"> </a>
<a name="ln3261">  return new_end;</a>
<a name="ln3262">}</a>
<a name="ln3263"> </a>
<a name="ln3264">/// Parse cmd string for :substitute's {flags} and update subflags accordingly</a>
<a name="ln3265">///</a>
<a name="ln3266">/// @param[in]      cmd  command string</a>
<a name="ln3267">/// @param[in,out]  subflags  current flags defined for the :substitute command</a>
<a name="ln3268">/// @param[in,out]  which_pat  pattern type from which to get default search</a>
<a name="ln3269">///</a>
<a name="ln3270">/// @returns pointer to the end of the flags, which may be the end of the string</a>
<a name="ln3271">static char_u *sub_parse_flags(char_u *cmd, subflags_T *subflags,</a>
<a name="ln3272">                               int *which_pat)</a>
<a name="ln3273">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET</a>
<a name="ln3274">{</a>
<a name="ln3275">  // Find trailing options.  When '&amp;' is used, keep old options.</a>
<a name="ln3276">  if (*cmd == '&amp;') {</a>
<a name="ln3277">    cmd++;</a>
<a name="ln3278">  } else {</a>
<a name="ln3279">    subflags-&gt;do_all = p_gd;</a>
<a name="ln3280">    subflags-&gt;do_ask = false;</a>
<a name="ln3281">    subflags-&gt;do_error = true;</a>
<a name="ln3282">    subflags-&gt;do_print = false;</a>
<a name="ln3283">    subflags-&gt;do_list = false;</a>
<a name="ln3284">    subflags-&gt;do_count = false;</a>
<a name="ln3285">    subflags-&gt;do_number = false;</a>
<a name="ln3286">    subflags-&gt;do_ic = kSubHonorOptions;</a>
<a name="ln3287">  }</a>
<a name="ln3288">  while (*cmd) {</a>
<a name="ln3289">    // Note that 'g' and 'c' are always inverted.</a>
<a name="ln3290">    // 'r' is never inverted.</a>
<a name="ln3291">    if (*cmd == 'g') {</a>
<a name="ln3292">      subflags-&gt;do_all = !subflags-&gt;do_all;</a>
<a name="ln3293">    } else if (*cmd == 'c') {</a>
<a name="ln3294">      subflags-&gt;do_ask = !subflags-&gt;do_ask;</a>
<a name="ln3295">    } else if (*cmd == 'n') {</a>
<a name="ln3296">      subflags-&gt;do_count = true;</a>
<a name="ln3297">    } else if (*cmd == 'e') {</a>
<a name="ln3298">      subflags-&gt;do_error = !subflags-&gt;do_error;</a>
<a name="ln3299">    } else if (*cmd == 'r') {  // use last used regexp</a>
<a name="ln3300">      *which_pat = RE_LAST;</a>
<a name="ln3301">    } else if (*cmd == 'p') {</a>
<a name="ln3302">      subflags-&gt;do_print = true;</a>
<a name="ln3303">    } else if (*cmd == '#') {</a>
<a name="ln3304">      subflags-&gt;do_print = true;</a>
<a name="ln3305">      subflags-&gt;do_number = true;</a>
<a name="ln3306">    } else if (*cmd == 'l') {</a>
<a name="ln3307">      subflags-&gt;do_print = true;</a>
<a name="ln3308">      subflags-&gt;do_list = true;</a>
<a name="ln3309">    } else if (*cmd == 'i') {  // ignore case</a>
<a name="ln3310">      subflags-&gt;do_ic = kSubIgnoreCase;</a>
<a name="ln3311">    } else if (*cmd == 'I') {  // don't ignore case</a>
<a name="ln3312">      subflags-&gt;do_ic = kSubMatchCase;</a>
<a name="ln3313">    } else {</a>
<a name="ln3314">      break;</a>
<a name="ln3315">    }</a>
<a name="ln3316">    cmd++;</a>
<a name="ln3317">  }</a>
<a name="ln3318">  if (subflags-&gt;do_count) {</a>
<a name="ln3319">    subflags-&gt;do_ask = false;</a>
<a name="ln3320">  }</a>
<a name="ln3321"> </a>
<a name="ln3322">  return cmd;</a>
<a name="ln3323">}</a>
<a name="ln3324"> </a>
<a name="ln3325"> </a>
<a name="ln3326">/// Perform a substitution from line eap-&gt;line1 to line eap-&gt;line2 using the</a>
<a name="ln3327">/// command pointed to by eap-&gt;arg which should be of the form:</a>
<a name="ln3328">///</a>
<a name="ln3329">/// /pattern/substitution/{flags}</a>
<a name="ln3330">///</a>
<a name="ln3331">/// The usual escapes are supported as described in the regexp docs.</a>
<a name="ln3332">///</a>
<a name="ln3333">/// @param do_buf_event If `true`, send buffer updates.</a>
<a name="ln3334">/// @return buffer used for 'inccommand' preview</a>
<a name="ln3335">static buf_T *do_sub(exarg_T *eap, proftime_T timeout,</a>
<a name="ln3336">                     bool do_buf_event, handle_T bufnr)</a>
<a name="ln3337">{</a>
<a name="ln3338">  long i = 0;</a>
<a name="ln3339">  regmmatch_T regmatch;</a>
<a name="ln3340">  static subflags_T subflags = {</a>
<a name="ln3341">    .do_all = false,</a>
<a name="ln3342">    .do_ask = false,</a>
<a name="ln3343">    .do_count = false,</a>
<a name="ln3344">    .do_error = true,</a>
<a name="ln3345">    .do_print = false,</a>
<a name="ln3346">    .do_list = false,</a>
<a name="ln3347">    .do_number = false,</a>
<a name="ln3348">    .do_ic = kSubHonorOptions</a>
<a name="ln3349">  };</a>
<a name="ln3350">  char_u *pat = NULL, *sub = NULL;  // init for GCC</a>
<a name="ln3351">  int delimiter;</a>
<a name="ln3352">  bool has_second_delim = false;</a>
<a name="ln3353">  int sublen;</a>
<a name="ln3354">  int got_quit = false;</a>
<a name="ln3355">  int got_match = false;</a>
<a name="ln3356">  int which_pat;</a>
<a name="ln3357">  char_u *cmd = eap-&gt;arg;</a>
<a name="ln3358">  linenr_T first_line = 0;  // first changed line</a>
<a name="ln3359">  linenr_T last_line= 0;    // below last changed line AFTER the change</a>
<a name="ln3360">  linenr_T old_line_count = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3361">  char_u *sub_firstline;    // allocated copy of first sub line</a>
<a name="ln3362">  bool endcolumn = false;   // cursor in last column when done</a>
<a name="ln3363">  PreviewLines preview_lines = { KV_INITIAL_VALUE, 0 };</a>
<a name="ln3364">  static int pre_src_id = 0;  // Source id for the preview highlight</a>
<a name="ln3365">  static int pre_hl_id = 0;</a>
<a name="ln3366">  buf_T *orig_buf = curbuf;  // save to reset highlighting</a>
<a name="ln3367">  pos_T old_cursor = curwin-&gt;w_cursor;</a>
<a name="ln3368">  int start_nsubs;</a>
<a name="ln3369">  int save_ma = 0;</a>
<a name="ln3370">  int save_b_changed = curbuf-&gt;b_changed;</a>
<a name="ln3371">  bool preview = (State &amp; CMDPREVIEW);</a>
<a name="ln3372"> </a>
<a name="ln3373">  bool did_save = false;</a>
<a name="ln3374"> </a>
<a name="ln3375">  if (!global_busy) {</a>
<a name="ln3376">    sub_nsubs = 0;</a>
<a name="ln3377">    sub_nlines = 0;</a>
<a name="ln3378">  }</a>
<a name="ln3379">  start_nsubs = sub_nsubs;</a>
<a name="ln3380"> </a>
<a name="ln3381">  if (eap-&gt;cmdidx == CMD_tilde)</a>
<a name="ln3382">    which_pat = RE_LAST;        /* use last used regexp */</a>
<a name="ln3383">  else</a>
<a name="ln3384">    which_pat = RE_SUBST;       /* use last substitute regexp */</a>
<a name="ln3385"> </a>
<a name="ln3386">  /* new pattern and substitution */</a>
<a name="ln3387">  if (eap-&gt;cmd[0] == 's' &amp;&amp; *cmd != NUL &amp;&amp; !ascii_iswhite(*cmd)</a>
<a name="ln3388">      &amp;&amp; vim_strchr((char_u *)&quot;0123456789cegriIp|\&quot;&quot;, *cmd) == NULL) {</a>
<a name="ln3389">    /* don't accept alphanumeric for separator */</a>
<a name="ln3390">    if (isalpha(*cmd)) {</a>
<a name="ln3391">      EMSG(_(&quot;E146: Regular expressions can't be delimited by letters&quot;));</a>
<a name="ln3392">      return NULL;</a>
<a name="ln3393">    }</a>
<a name="ln3394">    /*</a>
<a name="ln3395">     * undocumented vi feature:</a>
<a name="ln3396">     *  &quot;\/sub/&quot; and &quot;\?sub?&quot; use last used search pattern (almost like</a>
<a name="ln3397">     *  //sub/r).  &quot;\&amp;sub&amp;&quot; use last substitute pattern (like //sub/).</a>
<a name="ln3398">     */</a>
<a name="ln3399">    if (*cmd == '\\') {</a>
<a name="ln3400">      ++cmd;</a>
<a name="ln3401">      if (vim_strchr((char_u *)&quot;/?&amp;&quot;, *cmd) == NULL) {</a>
<a name="ln3402">        EMSG(_(e_backslash));</a>
<a name="ln3403">        return NULL;</a>
<a name="ln3404">      }</a>
<a name="ln3405">      if (*cmd != '&amp;') {</a>
<a name="ln3406">        which_pat = RE_SEARCH;              // use last '/' pattern</a>
<a name="ln3407">      }</a>
<a name="ln3408">      pat = (char_u *)&quot;&quot;;                   // empty search pattern</a>
<a name="ln3409">      delimiter = *cmd++;                   // remember delimiter character</a>
<a name="ln3410">      has_second_delim = true;</a>
<a name="ln3411">    } else {          // find the end of the regexp</a>
<a name="ln3412">      which_pat = RE_LAST;                  // use last used regexp</a>
<a name="ln3413">      delimiter = *cmd++;                   // remember delimiter character</a>
<a name="ln3414">      pat = cmd;                            // remember start of search pat</a>
<a name="ln3415">      cmd = skip_regexp(cmd, delimiter, p_magic, &amp;eap-&gt;arg);</a>
<a name="ln3416">      if (cmd[0] == delimiter) {            // end delimiter found</a>
<a name="ln3417">        *cmd++ = NUL;                       // replace it with a NUL</a>
<a name="ln3418">        has_second_delim = true;</a>
<a name="ln3419">      }</a>
<a name="ln3420">    }</a>
<a name="ln3421"> </a>
<a name="ln3422">    /*</a>
<a name="ln3423">     * Small incompatibility: vi sees '\n' as end of the command, but in</a>
<a name="ln3424">     * Vim we want to use '\n' to find/substitute a NUL.</a>
<a name="ln3425">     */</a>
<a name="ln3426">    sub = cmd;              /* remember the start of the substitution */</a>
<a name="ln3427"> </a>
<a name="ln3428">    while (cmd[0]) {</a>
<a name="ln3429">      if (cmd[0] == delimiter) {                /* end delimiter found */</a>
<a name="ln3430">        *cmd++ = NUL;                           /* replace it with a NUL */</a>
<a name="ln3431">        break;</a>
<a name="ln3432">      }</a>
<a name="ln3433">      if (cmd[0] == '\\' &amp;&amp; cmd[1] != 0) {      // skip escaped characters</a>
<a name="ln3434">        cmd++;</a>
<a name="ln3435">      }</a>
<a name="ln3436">      MB_PTR_ADV(cmd);</a>
<a name="ln3437">    }</a>
<a name="ln3438"> </a>
<a name="ln3439">    if (!eap-&gt;skip &amp;&amp; !preview) {</a>
<a name="ln3440">      sub_set_replacement((SubReplacementString) {</a>
<a name="ln3441">        .sub = xstrdup((char *) sub),</a>
<a name="ln3442">        .timestamp = os_time(),</a>
<a name="ln3443">        .additional_elements = NULL,</a>
<a name="ln3444">      });</a>
<a name="ln3445">    }</a>
<a name="ln3446">  } else if (!eap-&gt;skip) {    /* use previous pattern and substitution */</a>
<a name="ln3447">    if (old_sub.sub == NULL) {      /* there is no previous command */</a>
<a name="ln3448">      EMSG(_(e_nopresub));</a>
<a name="ln3449">      return NULL;</a>
<a name="ln3450">    }</a>
<a name="ln3451">    pat = NULL;                 /* search_regcomp() will use previous pattern */</a>
<a name="ln3452">    sub = (char_u *) old_sub.sub;</a>
<a name="ln3453"> </a>
<a name="ln3454">    /* Vi compatibility quirk: repeating with &quot;:s&quot; keeps the cursor in the</a>
<a name="ln3455">     * last column after using &quot;$&quot;. */</a>
<a name="ln3456">    endcolumn = (curwin-&gt;w_curswant == MAXCOL);</a>
<a name="ln3457">  }</a>
<a name="ln3458"> </a>
<a name="ln3459">  if (sub != NULL &amp;&amp; sub_joining_lines(eap, pat, sub, cmd, !preview)) {</a>
<a name="ln3460">    return NULL;</a>
<a name="ln3461">  }</a>
<a name="ln3462"> </a>
<a name="ln3463">  cmd = sub_parse_flags(cmd, &amp;subflags, &amp;which_pat);</a>
<a name="ln3464"> </a>
<a name="ln3465">  bool save_do_all = subflags.do_all;  // remember user specified 'g' flag</a>
<a name="ln3466">  bool save_do_ask = subflags.do_ask;  // remember user specified 'c' flag</a>
<a name="ln3467"> </a>
<a name="ln3468">  // check for a trailing count</a>
<a name="ln3469">  cmd = skipwhite(cmd);</a>
<a name="ln3470">  if (ascii_isdigit(*cmd)) {</a>
<a name="ln3471">    i = getdigits_long(&amp;cmd, true, 0);</a>
<a name="ln3472">    if (i &lt;= 0 &amp;&amp; !eap-&gt;skip &amp;&amp; subflags.do_error) {</a>
<a name="ln3473">      EMSG(_(e_zerocount));</a>
<a name="ln3474">      return NULL;</a>
<a name="ln3475">    }</a>
<a name="ln3476">    eap-&gt;line1 = eap-&gt;line2;</a>
<a name="ln3477">    eap-&gt;line2 += i - 1;</a>
<a name="ln3478">    if (eap-&gt;line2 &gt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln3479">      eap-&gt;line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3480">  }</a>
<a name="ln3481"> </a>
<a name="ln3482">  /*</a>
<a name="ln3483">   * check for trailing command or garbage</a>
<a name="ln3484">   */</a>
<a name="ln3485">  cmd = skipwhite(cmd);</a>
<a name="ln3486">  if (*cmd &amp;&amp; *cmd != '&quot;') {        /* if not end-of-line or comment */</a>
<a name="ln3487">    eap-&gt;nextcmd = check_nextcmd(cmd);</a>
<a name="ln3488">    if (eap-&gt;nextcmd == NULL) {</a>
<a name="ln3489">      EMSG(_(e_trailing));</a>
<a name="ln3490">      return NULL;</a>
<a name="ln3491">    }</a>
<a name="ln3492">  }</a>
<a name="ln3493"> </a>
<a name="ln3494">  if (eap-&gt;skip) {          // not executing commands, only parsing</a>
<a name="ln3495">    return NULL;</a>
<a name="ln3496">  }</a>
<a name="ln3497"> </a>
<a name="ln3498">  if (!subflags.do_count &amp;&amp; !MODIFIABLE(curbuf)) {</a>
<a name="ln3499">    // Substitution is not allowed in non-'modifiable' buffer</a>
<a name="ln3500">    EMSG(_(e_modifiable));</a>
<a name="ln3501">    return NULL;</a>
<a name="ln3502">  }</a>
<a name="ln3503"> </a>
<a name="ln3504">  if (search_regcomp(pat, RE_SUBST, which_pat, (preview ? 0 : SEARCH_HIS),</a>
<a name="ln3505">                     &amp;regmatch) == FAIL) {</a>
<a name="ln3506">    if (subflags.do_error) {</a>
<a name="ln3507">      EMSG(_(e_invcmd));</a>
<a name="ln3508">    }</a>
<a name="ln3509">    return NULL;</a>
<a name="ln3510">  }</a>
<a name="ln3511"> </a>
<a name="ln3512">  // the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'</a>
<a name="ln3513">  if (subflags.do_ic == kSubIgnoreCase) {</a>
<a name="ln3514">    regmatch.rmm_ic = true;</a>
<a name="ln3515">  } else if (subflags.do_ic == kSubMatchCase) {</a>
<a name="ln3516">    regmatch.rmm_ic = false;</a>
<a name="ln3517">  }</a>
<a name="ln3518"> </a>
<a name="ln3519">  sub_firstline = NULL;</a>
<a name="ln3520"> </a>
<a name="ln3521">  // ~ in the substitute pattern is replaced with the old pattern.</a>
<a name="ln3522">  // We do it here once to avoid it to be replaced over and over again.</a>
<a name="ln3523">  // But don't do it when it starts with &quot;\=&quot;, then it's an expression.</a>
<a name="ln3524">  assert(sub != NULL);</a>
<a name="ln3525">  if (!(sub[0] == '\\' &amp;&amp; sub[1] == '=')) {</a>
<a name="ln3526">    sub = regtilde(sub, p_magic);</a>
<a name="ln3527">  }</a>
<a name="ln3528"> </a>
<a name="ln3529">  // Check for a match on each line.</a>
<a name="ln3530">  // If preview: limit to max('cmdwinheight', viewport).</a>
<a name="ln3531">  linenr_T line2 = eap-&gt;line2;</a>
<a name="ln3532"> </a>
<a name="ln3533">  for (linenr_T lnum = eap-&gt;line1;</a>
<a name="ln3534">       lnum &lt;= line2 &amp;&amp; !got_quit &amp;&amp; !aborting()</a>
<a name="ln3535">       &amp;&amp; (!preview || preview_lines.lines_needed &lt;= (linenr_T)p_cwh</a>
<a name="ln3536">           || lnum &lt;= curwin-&gt;w_botline);</a>
<a name="ln3537">       lnum++) {</a>
<a name="ln3538">    long nmatch = vim_regexec_multi(&amp;regmatch, curwin, curbuf, lnum,</a>
<a name="ln3539">                                    (colnr_T)0, NULL, NULL);</a>
<a name="ln3540">    if (nmatch) {</a>
<a name="ln3541">      colnr_T copycol;</a>
<a name="ln3542">      colnr_T matchcol;</a>
<a name="ln3543">      colnr_T prev_matchcol = MAXCOL;</a>
<a name="ln3544">      char_u      *new_end, *new_start = NULL;</a>
<a name="ln3545">      char_u      *p1;</a>
<a name="ln3546">      int did_sub = FALSE;</a>
<a name="ln3547">      int lastone;</a>
<a name="ln3548">      long nmatch_tl = 0;               // nr of lines matched below lnum</a>
<a name="ln3549">      int do_again;                     // do it again after joining lines</a>
<a name="ln3550">      bool skip_match = false;</a>
<a name="ln3551">      linenr_T sub_firstlnum;           // nr of first sub line</a>
<a name="ln3552"> </a>
<a name="ln3553">      /*</a>
<a name="ln3554">       * The new text is build up step by step, to avoid too much</a>
<a name="ln3555">       * copying.  There are these pieces:</a>
<a name="ln3556">       * sub_firstline	The old text, unmodified.</a>
<a name="ln3557">       * copycol		Column in the old text where we started</a>
<a name="ln3558">       *			looking for a match; from here old text still</a>
<a name="ln3559">       *			needs to be copied to the new text.</a>
<a name="ln3560">       * matchcol		Column number of the old text where to look</a>
<a name="ln3561">       *			for the next match.  It's just after the</a>
<a name="ln3562">       *			previous match or one further.</a>
<a name="ln3563">       * prev_matchcol	Column just after the previous match (if any).</a>
<a name="ln3564">       *			Mostly equal to matchcol, except for the first</a>
<a name="ln3565">       *			match and after skipping an empty match.</a>
<a name="ln3566">       * regmatch.*pos	Where the pattern matched in the old text.</a>
<a name="ln3567">       * new_start	The new text, all that has been produced so</a>
<a name="ln3568">       *			far.</a>
<a name="ln3569">       * new_end		The new text, where to append new text.</a>
<a name="ln3570">       *</a>
<a name="ln3571">       * lnum		The line number where we found the start of</a>
<a name="ln3572">       *			the match.  Can be below the line we searched</a>
<a name="ln3573">       *			when there is a \n before a \zs in the</a>
<a name="ln3574">       *			pattern.</a>
<a name="ln3575">       * sub_firstlnum	The line number in the buffer where to look</a>
<a name="ln3576">       *			for a match.  Can be different from &quot;lnum&quot;</a>
<a name="ln3577">       *			when the pattern or substitute string contains</a>
<a name="ln3578">       *			line breaks.</a>
<a name="ln3579">       *</a>
<a name="ln3580">       * Special situations:</a>
<a name="ln3581">       * - When the substitute string contains a line break, the part up</a>
<a name="ln3582">       *   to the line break is inserted in the text, but the copy of</a>
<a name="ln3583">       *   the original line is kept.  &quot;sub_firstlnum&quot; is adjusted for</a>
<a name="ln3584">       *   the inserted lines.</a>
<a name="ln3585">       * - When the matched pattern contains a line break, the old line</a>
<a name="ln3586">       *   is taken from the line at the end of the pattern.  The lines</a>
<a name="ln3587">       *   in the match are deleted later, &quot;sub_firstlnum&quot; is adjusted</a>
<a name="ln3588">       *   accordingly.</a>
<a name="ln3589">       *</a>
<a name="ln3590">       * The new text is built up in new_start[].  It has some extra</a>
<a name="ln3591">       * room to avoid using xmalloc()/free() too often.</a>
<a name="ln3592">       *</a>
<a name="ln3593">       * Make a copy of the old line, so it won't be taken away when</a>
<a name="ln3594">       * updating the screen or handling a multi-line match.  The &quot;old_&quot;</a>
<a name="ln3595">       * pointers point into this copy.</a>
<a name="ln3596">       */</a>
<a name="ln3597">      sub_firstlnum = lnum;</a>
<a name="ln3598">      copycol = 0;</a>
<a name="ln3599">      matchcol = 0;</a>
<a name="ln3600"> </a>
<a name="ln3601">      /* At first match, remember current cursor position. */</a>
<a name="ln3602">      if (!got_match) {</a>
<a name="ln3603">        setpcmark();</a>
<a name="ln3604">        got_match = TRUE;</a>
<a name="ln3605">      }</a>
<a name="ln3606"> </a>
<a name="ln3607">      /*</a>
<a name="ln3608">       * Loop until nothing more to replace in this line.</a>
<a name="ln3609">       * 1. Handle match with empty string.</a>
<a name="ln3610">       * 2. If subflags.do_ask is set, ask for confirmation.</a>
<a name="ln3611">       * 3. substitute the string.</a>
<a name="ln3612">       * 4. if subflags.do_all is set, find next match</a>
<a name="ln3613">       * 5. break if there isn't another match in this line</a>
<a name="ln3614">       */</a>
<a name="ln3615">      for (;; ) {</a>
<a name="ln3616">        SubResult current_match = {</a>
<a name="ln3617">          .start = { 0, 0 },</a>
<a name="ln3618">          .end   = { 0, 0 },</a>
<a name="ln3619">          .pre_match = 0,</a>
<a name="ln3620">        };</a>
<a name="ln3621">        // lnum is where the match start, but maybe not the pattern match,</a>
<a name="ln3622">        // since we can have \n before \zs in the pattern</a>
<a name="ln3623"> </a>
<a name="ln3624">        // Advance &quot;lnum&quot; to the line where the match starts.  The</a>
<a name="ln3625">        // match does not start in the first line when there is a line</a>
<a name="ln3626">        // break before \zs.</a>
<a name="ln3627">        if (regmatch.startpos[0].lnum &gt; 0) {</a>
<a name="ln3628">          current_match.pre_match = lnum;</a>
<a name="ln3629">          lnum += regmatch.startpos[0].lnum;</a>
<a name="ln3630">          sub_firstlnum += regmatch.startpos[0].lnum;</a>
<a name="ln3631">          nmatch -= regmatch.startpos[0].lnum;</a>
<a name="ln3632">          XFREE_CLEAR(sub_firstline);</a>
<a name="ln3633">        }</a>
<a name="ln3634"> </a>
<a name="ln3635">        // Now we're at the line where the pattern match starts</a>
<a name="ln3636">        // Note: If not first match on a line, column can't be known here</a>
<a name="ln3637">        current_match.start.lnum = sub_firstlnum;</a>
<a name="ln3638"> </a>
<a name="ln3639">        // Match might be after the last line for &quot;\n\zs&quot; matching at</a>
<a name="ln3640">        // the end of the last line.</a>
<a name="ln3641">        if (lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3642">          break;</a>
<a name="ln3643">        }</a>
<a name="ln3644">        if (sub_firstline == NULL) {</a>
<a name="ln3645">          sub_firstline = vim_strsave(ml_get(sub_firstlnum));</a>
<a name="ln3646">        }</a>
<a name="ln3647"> </a>
<a name="ln3648">        /* Save the line number of the last change for the final</a>
<a name="ln3649">         * cursor position (just like Vi). */</a>
<a name="ln3650">        curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3651">        do_again = FALSE;</a>
<a name="ln3652"> </a>
<a name="ln3653">        /*</a>
<a name="ln3654">         * 1. Match empty string does not count, except for first</a>
<a name="ln3655">         * match.  This reproduces the strange vi behaviour.</a>
<a name="ln3656">         * This also catches endless loops.</a>
<a name="ln3657">         */</a>
<a name="ln3658">        if (matchcol == prev_matchcol</a>
<a name="ln3659">            &amp;&amp; regmatch.endpos[0].lnum == 0</a>
<a name="ln3660">            &amp;&amp; matchcol == regmatch.endpos[0].col) {</a>
<a name="ln3661">          if (sub_firstline[matchcol] == NUL) {</a>
<a name="ln3662">            // We already were at the end of the line.  Don't look</a>
<a name="ln3663">            // for a match in this line again.</a>
<a name="ln3664">            skip_match = true;</a>
<a name="ln3665">          } else {</a>
<a name="ln3666">            // search for a match at next column</a>
<a name="ln3667">            matchcol += mb_ptr2len(sub_firstline + matchcol);</a>
<a name="ln3668">          }</a>
<a name="ln3669">          // match will be pushed to preview_lines, bring it into a proper state</a>
<a name="ln3670">          current_match.start.col = matchcol;</a>
<a name="ln3671">          current_match.end.lnum = sub_firstlnum;</a>
<a name="ln3672">          current_match.end.col = matchcol;</a>
<a name="ln3673">          goto skip;</a>
<a name="ln3674">        }</a>
<a name="ln3675"> </a>
<a name="ln3676">        /* Normally we continue searching for a match just after the</a>
<a name="ln3677">         * previous match. */</a>
<a name="ln3678">        matchcol = regmatch.endpos[0].col;</a>
<a name="ln3679">        prev_matchcol = matchcol;</a>
<a name="ln3680"> </a>
<a name="ln3681">        // 2. If subflags.do_count is set only increase the counter.</a>
<a name="ln3682">        //    If do_ask is set, ask for confirmation.</a>
<a name="ln3683">        if (subflags.do_count) {</a>
<a name="ln3684">          // For a multi-line match, put matchcol at the NUL at</a>
<a name="ln3685">          // the end of the line and set nmatch to one, so that</a>
<a name="ln3686">          // we continue looking for a match on the next line.</a>
<a name="ln3687">          // Avoids that &quot;:s/\nB\@=//gc&quot; get stuck.</a>
<a name="ln3688">          if (nmatch &gt; 1) {</a>
<a name="ln3689">            matchcol = (colnr_T)STRLEN(sub_firstline);</a>
<a name="ln3690">            nmatch = 1;</a>
<a name="ln3691">            skip_match = true;</a>
<a name="ln3692">          }</a>
<a name="ln3693">          sub_nsubs++;</a>
<a name="ln3694">          did_sub = TRUE;</a>
<a name="ln3695">          /* Skip the substitution, unless an expression is used,</a>
<a name="ln3696">           * then it is evaluated in the sandbox. */</a>
<a name="ln3697">          if (!(sub[0] == '\\' &amp;&amp; sub[1] == '='))</a>
<a name="ln3698">            goto skip;</a>
<a name="ln3699">        }</a>
<a name="ln3700"> </a>
<a name="ln3701">        if (subflags.do_ask &amp;&amp; !preview) {</a>
<a name="ln3702">          int typed = 0;</a>
<a name="ln3703"> </a>
<a name="ln3704">          /* change State to CONFIRM, so that the mouse works</a>
<a name="ln3705">           * properly */</a>
<a name="ln3706">          int save_State = State;</a>
<a name="ln3707">          State = CONFIRM;</a>
<a name="ln3708">          setmouse();                   /* disable mouse in xterm */</a>
<a name="ln3709">          curwin-&gt;w_cursor.col = regmatch.startpos[0].col;</a>
<a name="ln3710"> </a>
<a name="ln3711">          if (curwin-&gt;w_p_crb) {</a>
<a name="ln3712">            do_check_cursorbind();</a>
<a name="ln3713">          }</a>
<a name="ln3714"> </a>
<a name="ln3715">          /* When 'cpoptions' contains &quot;u&quot; don't sync undo when</a>
<a name="ln3716">           * asking for confirmation. */</a>
<a name="ln3717">          if (vim_strchr(p_cpo, CPO_UNDO) != NULL)</a>
<a name="ln3718">            ++no_u_sync;</a>
<a name="ln3719"> </a>
<a name="ln3720">          /*</a>
<a name="ln3721">           * Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed.</a>
<a name="ln3722">           */</a>
<a name="ln3723">          while (subflags.do_ask) {</a>
<a name="ln3724">            if (exmode_active) {</a>
<a name="ln3725">              char_u      *resp;</a>
<a name="ln3726">              colnr_T sc, ec;</a>
<a name="ln3727"> </a>
<a name="ln3728">              print_line_no_prefix(lnum, subflags.do_number, subflags.do_list);</a>
<a name="ln3729"> </a>
<a name="ln3730">              getvcol(curwin, &amp;curwin-&gt;w_cursor, &amp;sc, NULL, NULL);</a>
<a name="ln3731">              curwin-&gt;w_cursor.col = regmatch.endpos[0].col - 1;</a>
<a name="ln3732">              if (curwin-&gt;w_cursor.col &lt; 0) {</a>
<a name="ln3733">                curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3734">              }</a>
<a name="ln3735">              getvcol(curwin, &amp;curwin-&gt;w_cursor, NULL, NULL, &amp;ec);</a>
<a name="ln3736">              if (subflags.do_number || curwin-&gt;w_p_nu) {</a>
<a name="ln3737">                int numw = number_width(curwin) + 1;</a>
<a name="ln3738">                sc += numw;</a>
<a name="ln3739">                ec += numw;</a>
<a name="ln3740">              }</a>
<a name="ln3741">              msg_start();</a>
<a name="ln3742">              for (i = 0; i &lt; (long)sc; ++i)</a>
<a name="ln3743">                msg_putchar(' ');</a>
<a name="ln3744">              for (; i &lt;= (long)ec; ++i)</a>
<a name="ln3745">                msg_putchar('^');</a>
<a name="ln3746"> </a>
<a name="ln3747">              resp = getexmodeline('?', NULL, 0, true);</a>
<a name="ln3748">              if (resp != NULL) {</a>
<a name="ln3749">                typed = *resp;</a>
<a name="ln3750">                xfree(resp);</a>
<a name="ln3751">              }</a>
<a name="ln3752">            } else {</a>
<a name="ln3753">              char_u *orig_line = NULL;</a>
<a name="ln3754">              int len_change = 0;</a>
<a name="ln3755">              const bool save_p_lz = p_lz;</a>
<a name="ln3756">              int save_p_fen = curwin-&gt;w_p_fen;</a>
<a name="ln3757"> </a>
<a name="ln3758">              curwin-&gt;w_p_fen = FALSE;</a>
<a name="ln3759">              /* Invert the matched string.</a>
<a name="ln3760">               * Remove the inversion afterwards. */</a>
<a name="ln3761">              int temp = RedrawingDisabled;</a>
<a name="ln3762">              RedrawingDisabled = 0;</a>
<a name="ln3763"> </a>
<a name="ln3764">              // avoid calling update_screen() in vgetorpeek()</a>
<a name="ln3765">              p_lz = false;</a>
<a name="ln3766"> </a>
<a name="ln3767">              if (new_start != NULL) {</a>
<a name="ln3768">                /* There already was a substitution, we would</a>
<a name="ln3769">                 * like to show this to the user.  We cannot</a>
<a name="ln3770">                 * really update the line, it would change</a>
<a name="ln3771">                 * what matches.  Temporarily replace the line</a>
<a name="ln3772">                 * and change it back afterwards. */</a>
<a name="ln3773">                orig_line = vim_strsave(ml_get(lnum));</a>
<a name="ln3774">                char_u *new_line = concat_str(new_start, sub_firstline + copycol);</a>
<a name="ln3775"> </a>
<a name="ln3776">                // Position the cursor relative to the end of the line, the</a>
<a name="ln3777">                // previous substitute may have inserted or deleted characters</a>
<a name="ln3778">                // before the cursor.</a>
<a name="ln3779">                len_change = (int)STRLEN(new_line) - (int)STRLEN(orig_line);</a>
<a name="ln3780">                curwin-&gt;w_cursor.col += len_change;</a>
<a name="ln3781">                ml_replace(lnum, new_line, false);</a>
<a name="ln3782">              }</a>
<a name="ln3783"> </a>
<a name="ln3784">              search_match_lines = regmatch.endpos[0].lnum</a>
<a name="ln3785">                                   - regmatch.startpos[0].lnum;</a>
<a name="ln3786">              search_match_endcol = regmatch.endpos[0].col</a>
<a name="ln3787">                                    + len_change;</a>
<a name="ln3788">              highlight_match = TRUE;</a>
<a name="ln3789"> </a>
<a name="ln3790">              update_topline(curwin);</a>
<a name="ln3791">              validate_cursor();</a>
<a name="ln3792">              update_screen(SOME_VALID);</a>
<a name="ln3793">              highlight_match = false;</a>
<a name="ln3794">              redraw_later(curwin, SOME_VALID);</a>
<a name="ln3795"> </a>
<a name="ln3796">              curwin-&gt;w_p_fen = save_p_fen;</a>
<a name="ln3797">              if (msg_row == Rows - 1)</a>
<a name="ln3798">                msg_didout = FALSE;                     /* avoid a scroll-up */</a>
<a name="ln3799">              msg_starthere();</a>
<a name="ln3800">              i = msg_scroll;</a>
<a name="ln3801">              msg_scroll = 0;                           /* truncate msg when</a>
<a name="ln3802">                                                           needed */</a>
<a name="ln3803">              msg_no_more = true;</a>
<a name="ln3804">              msg_ext_set_kind(&quot;confirm_sub&quot;);</a>
<a name="ln3805">              smsg_attr(HL_ATTR(HLF_R),  // Same highlight as wait_return().</a>
<a name="ln3806">                        _(&quot;replace with %s (y/n/a/q/l/^E/^Y)?&quot;), sub);</a>
<a name="ln3807">              msg_no_more = FALSE;</a>
<a name="ln3808">              msg_scroll = i;</a>
<a name="ln3809">              showruler(TRUE);</a>
<a name="ln3810">              ui_cursor_goto(msg_row, msg_col);</a>
<a name="ln3811">              RedrawingDisabled = temp;</a>
<a name="ln3812"> </a>
<a name="ln3813">              no_mapping++;                     // don't map this key</a>
<a name="ln3814">              typed = plain_vgetc();</a>
<a name="ln3815">              no_mapping--;</a>
<a name="ln3816"> </a>
<a name="ln3817">              /* clear the question */</a>
<a name="ln3818">              msg_didout = FALSE;               /* don't scroll up */</a>
<a name="ln3819">              msg_col = 0;</a>
<a name="ln3820">              gotocmdline(true);</a>
<a name="ln3821">              p_lz = save_p_lz;</a>
<a name="ln3822"> </a>
<a name="ln3823">              // restore the line</a>
<a name="ln3824">              if (orig_line != NULL) {</a>
<a name="ln3825">                ml_replace(lnum, orig_line, false);</a>
<a name="ln3826">              }</a>
<a name="ln3827">            }</a>
<a name="ln3828"> </a>
<a name="ln3829">            need_wait_return = false;             // no hit-return prompt</a>
<a name="ln3830">            if (typed == 'q' || typed == ESC || typed == Ctrl_C) {</a>
<a name="ln3831">              got_quit = true;</a>
<a name="ln3832">              break;</a>
<a name="ln3833">            }</a>
<a name="ln3834">            if (typed == 'n')</a>
<a name="ln3835">              break;</a>
<a name="ln3836">            if (typed == 'y')</a>
<a name="ln3837">              break;</a>
<a name="ln3838">            if (typed == 'l') {</a>
<a name="ln3839">              // last: replace and then stop</a>
<a name="ln3840">              subflags.do_all = false;</a>
<a name="ln3841">              line2 = lnum;</a>
<a name="ln3842">              break;</a>
<a name="ln3843">            }</a>
<a name="ln3844">            if (typed == 'a') {</a>
<a name="ln3845">              subflags.do_ask = false;</a>
<a name="ln3846">              break;</a>
<a name="ln3847">            }</a>
<a name="ln3848">            if (typed == Ctrl_E)</a>
<a name="ln3849">              scrollup_clamp();</a>
<a name="ln3850">            else if (typed == Ctrl_Y)</a>
<a name="ln3851">              scrolldown_clamp();</a>
<a name="ln3852">          }</a>
<a name="ln3853">          State = save_State;</a>
<a name="ln3854">          setmouse();</a>
<a name="ln3855">          if (vim_strchr(p_cpo, CPO_UNDO) != NULL)</a>
<a name="ln3856">            --no_u_sync;</a>
<a name="ln3857"> </a>
<a name="ln3858">          if (typed == 'n') {</a>
<a name="ln3859">            /* For a multi-line match, put matchcol at the NUL at</a>
<a name="ln3860">             * the end of the line and set nmatch to one, so that</a>
<a name="ln3861">             * we continue looking for a match on the next line.</a>
<a name="ln3862">             * Avoids that &quot;:%s/\nB\@=//gc&quot; and &quot;:%s/\n/,\r/gc&quot;</a>
<a name="ln3863">             * get stuck when pressing 'n'. */</a>
<a name="ln3864">            if (nmatch &gt; 1) {</a>
<a name="ln3865">              matchcol = (colnr_T)STRLEN(sub_firstline);</a>
<a name="ln3866">              skip_match = true;</a>
<a name="ln3867">            }</a>
<a name="ln3868">            goto skip;</a>
<a name="ln3869">          }</a>
<a name="ln3870">          if (got_quit)</a>
<a name="ln3871">            goto skip;</a>
<a name="ln3872">        }</a>
<a name="ln3873"> </a>
<a name="ln3874">        /* Move the cursor to the start of the match, so that we can</a>
<a name="ln3875">         * use &quot;\=col(&quot;.&quot;). */</a>
<a name="ln3876">        curwin-&gt;w_cursor.col = regmatch.startpos[0].col;</a>
<a name="ln3877"> </a>
<a name="ln3878">        // When the match included the &quot;$&quot; of the last line it may</a>
<a name="ln3879">        // go beyond the last line of the buffer.</a>
<a name="ln3880">        if (nmatch &gt; curbuf-&gt;b_ml.ml_line_count - sub_firstlnum + 1) {</a>
<a name="ln3881">          nmatch = curbuf-&gt;b_ml.ml_line_count - sub_firstlnum + 1;</a>
<a name="ln3882">          current_match.end.lnum = sub_firstlnum + nmatch;</a>
<a name="ln3883">          skip_match = true;</a>
<a name="ln3884">        }</a>
<a name="ln3885"> </a>
<a name="ln3886">#define ADJUST_SUB_FIRSTLNUM() \</a>
<a name="ln3887">        do { \</a>
<a name="ln3888">          /* For a multi-line match, make a copy of the last matched */ \</a>
<a name="ln3889">          /* line and continue in that one. */ \</a>
<a name="ln3890">          if (nmatch &gt; 1) { \</a>
<a name="ln3891">            sub_firstlnum += nmatch - 1; \</a>
<a name="ln3892">            xfree(sub_firstline); \</a>
<a name="ln3893">            sub_firstline = vim_strsave(ml_get(sub_firstlnum)); \</a>
<a name="ln3894">            /* When going beyond the last line, stop substituting. */ \</a>
<a name="ln3895">            if (sub_firstlnum &lt;= line2) { \</a>
<a name="ln3896">              do_again = true; \</a>
<a name="ln3897">            } else { \</a>
<a name="ln3898">              subflags.do_all = false; \</a>
<a name="ln3899">            } \</a>
<a name="ln3900">          } \</a>
<a name="ln3901">          if (skip_match) { \</a>
<a name="ln3902">            /* Already hit end of the buffer, sub_firstlnum is one */ \</a>
<a name="ln3903">            /* less than what it ought to be. */ \</a>
<a name="ln3904">            xfree(sub_firstline); \</a>
<a name="ln3905">            sub_firstline = vim_strsave((char_u *)&quot;&quot;); \</a>
<a name="ln3906">            copycol = 0; \</a>
<a name="ln3907">          } \</a>
<a name="ln3908">        } while (0)</a>
<a name="ln3909"> </a>
<a name="ln3910">        // Save the line numbers for the preview buffer</a>
<a name="ln3911">        // NOTE: If the pattern matches a final newline, the next line will</a>
<a name="ln3912">        // be shown also, but should not be highlighted. Intentional for now.</a>
<a name="ln3913">        if (preview &amp;&amp; !has_second_delim) {</a>
<a name="ln3914">          current_match.start.col = regmatch.startpos[0].col;</a>
<a name="ln3915">          if (current_match.end.lnum == 0) {</a>
<a name="ln3916">            current_match.end.lnum = sub_firstlnum + nmatch - 1;</a>
<a name="ln3917">          }</a>
<a name="ln3918">          current_match.end.col  = regmatch.endpos[0].col;</a>
<a name="ln3919"> </a>
<a name="ln3920">          ADJUST_SUB_FIRSTLNUM();</a>
<a name="ln3921">          lnum += nmatch - 1;</a>
<a name="ln3922"> </a>
<a name="ln3923">          goto skip;</a>
<a name="ln3924">        }</a>
<a name="ln3925"> </a>
<a name="ln3926"> </a>
<a name="ln3927">        // 3. Substitute the string. During 'inccommand' preview only do this if</a>
<a name="ln3928">        //    there is a replace pattern.</a>
<a name="ln3929">        if (!preview || has_second_delim) {</a>
<a name="ln3930">          long lnum_start = lnum;  // save the start lnum</a>
<a name="ln3931">          save_ma = curbuf-&gt;b_p_ma;</a>
<a name="ln3932">          if (subflags.do_count) {</a>
<a name="ln3933">            // prevent accidentally changing the buffer by a function</a>
<a name="ln3934">            curbuf-&gt;b_p_ma = false;</a>
<a name="ln3935">            sandbox++;</a>
<a name="ln3936">          }</a>
<a name="ln3937">          // Save flags for recursion.  They can change for e.g.</a>
<a name="ln3938">          // :s/^/\=execute(&quot;s#^##gn&quot;)</a>
<a name="ln3939">          subflags_T subflags_save = subflags;</a>
<a name="ln3940">          // get length of substitution part</a>
<a name="ln3941">          sublen = vim_regsub_multi(&amp;regmatch,</a>
<a name="ln3942">                                    sub_firstlnum - regmatch.startpos[0].lnum,</a>
<a name="ln3943">                                    sub, sub_firstline, false, p_magic, true);</a>
<a name="ln3944">          // If getting the substitute string caused an error, don't do</a>
<a name="ln3945">          // the replacement.</a>
<a name="ln3946">          // Don't keep flags set by a recursive call</a>
<a name="ln3947">          subflags = subflags_save;</a>
<a name="ln3948">          if (aborting() || subflags.do_count) {</a>
<a name="ln3949">            curbuf-&gt;b_p_ma = save_ma;</a>
<a name="ln3950">            if (sandbox &gt; 0) {</a>
<a name="ln3951">              sandbox--;</a>
<a name="ln3952">            }</a>
<a name="ln3953">            goto skip;</a>
<a name="ln3954">          }</a>
<a name="ln3955"> </a>
<a name="ln3956">          // Need room for:</a>
<a name="ln3957">          // - result so far in new_start (not for first sub in line)</a>
<a name="ln3958">          // - original text up to match</a>
<a name="ln3959">          // - length of substituted part</a>
<a name="ln3960">          // - original text after match</a>
<a name="ln3961">          if (nmatch == 1) {</a>
<a name="ln3962">            p1 = sub_firstline;</a>
<a name="ln3963">          } else {</a>
<a name="ln3964">            p1 = ml_get(sub_firstlnum + nmatch - 1);</a>
<a name="ln3965">            nmatch_tl += nmatch - 1;</a>
<a name="ln3966">          }</a>
<a name="ln3967">          size_t copy_len = regmatch.startpos[0].col - copycol;</a>
<a name="ln3968">          new_end = sub_grow_buf(&amp;new_start,</a>
<a name="ln3969">                                 (STRLEN(p1) - regmatch.endpos[0].col)</a>
<a name="ln3970">                                 + copy_len + sublen + 1);</a>
<a name="ln3971"> </a>
<a name="ln3972">          // copy the text up to the part that matched</a>
<a name="ln3973">          memmove(new_end, sub_firstline + copycol, (size_t)copy_len);</a>
<a name="ln3974">          new_end += copy_len;</a>
<a name="ln3975"> </a>
<a name="ln3976">          // Finally, at this point we can know where the match actually will</a>
<a name="ln3977">          // start in the new text</a>
<a name="ln3978">          int start_col = new_end - new_start;</a>
<a name="ln3979">          current_match.start.col = start_col;</a>
<a name="ln3980"> </a>
<a name="ln3981">          (void)vim_regsub_multi(&amp;regmatch,</a>
<a name="ln3982">                                 sub_firstlnum - regmatch.startpos[0].lnum,</a>
<a name="ln3983">                                 sub, new_end, true, p_magic, true);</a>
<a name="ln3984">          sub_nsubs++;</a>
<a name="ln3985">          did_sub = true;</a>
<a name="ln3986"> </a>
<a name="ln3987">          // Move the cursor to the start of the line, to avoid that it</a>
<a name="ln3988">          // is beyond the end of the line after the substitution.</a>
<a name="ln3989">          curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3990"> </a>
<a name="ln3991">          // Remember next character to be copied.</a>
<a name="ln3992">          copycol = regmatch.endpos[0].col;</a>
<a name="ln3993"> </a>
<a name="ln3994">          ADJUST_SUB_FIRSTLNUM();</a>
<a name="ln3995"> </a>
<a name="ln3996">          // TODO(bfredl): this has some robustness issues, look into later.</a>
<a name="ln3997">          bcount_t replaced_bytes = 0;</a>
<a name="ln3998">          lpos_T start = regmatch.startpos[0], end = regmatch.endpos[0];</a>
<a name="ln3999">          for (i = 0; i &lt; nmatch-1; i++) {</a>
<a name="ln4000">            replaced_bytes += STRLEN(ml_get(lnum_start+i)) + 1;</a>
<a name="ln4001">          }</a>
<a name="ln4002">          replaced_bytes += end.col - start.col;</a>
<a name="ln4003"> </a>
<a name="ln4004"> </a>
<a name="ln4005">          // Now the trick is to replace CTRL-M chars with a real line</a>
<a name="ln4006">          // break.  This would make it impossible to insert a CTRL-M in</a>
<a name="ln4007">          // the text.  The line break can be avoided by preceding the</a>
<a name="ln4008">          // CTRL-M with a backslash.  To be able to insert a backslash,</a>
<a name="ln4009">          // they must be doubled in the string and are halved here.</a>
<a name="ln4010">          // That is Vi compatible.</a>
<a name="ln4011">          for (p1 = new_end; *p1; p1++) {</a>
<a name="ln4012">            if (p1[0] == '\\' &amp;&amp; p1[1] != NUL) {            // remove backslash</a>
<a name="ln4013">              STRMOVE(p1, p1 + 1);</a>
<a name="ln4014">            } else if (*p1 == CAR) {</a>
<a name="ln4015">              if (u_inssub(lnum) == OK) {             // prepare for undo</a>
<a name="ln4016">                *p1 = NUL;                            // truncate up to the CR</a>
<a name="ln4017">                ml_append(lnum - 1, new_start,</a>
<a name="ln4018">                          (colnr_T)(p1 - new_start + 1), false);</a>
<a name="ln4019">                mark_adjust(lnum + 1, (linenr_T)MAXLNUM, 1L, 0L, kExtmarkNOOP);</a>
<a name="ln4020"> </a>
<a name="ln4021">                if (subflags.do_ask) {</a>
<a name="ln4022">                  appended_lines(lnum - 1, 1L);</a>
<a name="ln4023">                } else {</a>
<a name="ln4024">                  if (first_line == 0) {</a>
<a name="ln4025">                    first_line = lnum;</a>
<a name="ln4026">                  }</a>
<a name="ln4027">                  last_line = lnum + 1;</a>
<a name="ln4028">                }</a>
<a name="ln4029">                // All line numbers increase.</a>
<a name="ln4030">                sub_firstlnum++;</a>
<a name="ln4031">                lnum++;</a>
<a name="ln4032">                line2++;</a>
<a name="ln4033">                // move the cursor to the new line, like Vi</a>
<a name="ln4034">                curwin-&gt;w_cursor.lnum++;</a>
<a name="ln4035">                // copy the rest</a>
<a name="ln4036">                STRMOVE(new_start, p1 + 1);</a>
<a name="ln4037">                p1 = new_start - 1;</a>
<a name="ln4038">              }</a>
<a name="ln4039">            } else {</a>
<a name="ln4040">              p1 += utfc_ptr2len(p1) - 1;</a>
<a name="ln4041">            }</a>
<a name="ln4042">          }</a>
<a name="ln4043">          size_t new_endcol = STRLEN(new_start);</a>
<a name="ln4044">          current_match.end.col = new_endcol;</a>
<a name="ln4045">          current_match.end.lnum = lnum;</a>
<a name="ln4046"> </a>
<a name="ln4047">          int matchcols = end.col - ((end.lnum == start.lnum)</a>
<a name="ln4048">                                     ? start.col : 0);</a>
<a name="ln4049">          int subcols = new_endcol - ((lnum == lnum_start) ? start_col : 0);</a>
<a name="ln4050">          if (!did_save) {</a>
<a name="ln4051">            // Required for Undo to work for extmarks.</a>
<a name="ln4052">            u_save_cursor();</a>
<a name="ln4053">            did_save = true;</a>
<a name="ln4054">          }</a>
<a name="ln4055">          extmark_splice(curbuf, lnum_start-1, start_col,</a>
<a name="ln4056">                         end.lnum-start.lnum, matchcols, replaced_bytes,</a>
<a name="ln4057">                         lnum-lnum_start, subcols, sublen-1, kExtmarkUndo);</a>
<a name="ln4058">        }</a>
<a name="ln4059"> </a>
<a name="ln4060"> </a>
<a name="ln4061">        // 4. If subflags.do_all is set, find next match.</a>
<a name="ln4062">        // Prevent endless loop with patterns that match empty</a>
<a name="ln4063">        // strings, e.g. :s/$/pat/g or :s/[a-z]* /(&amp;)/g.</a>
<a name="ln4064">        // But &quot;:s/\n/#/&quot; is OK.</a>
<a name="ln4065">skip:</a>
<a name="ln4066">        /* We already know that we did the last subst when we are at</a>
<a name="ln4067">         * the end of the line, except that a pattern like</a>
<a name="ln4068">         * &quot;bar\|\nfoo&quot; may match at the NUL.  &quot;lnum&quot; can be below</a>
<a name="ln4069">         * &quot;line2&quot; when there is a \zs in the pattern after a line</a>
<a name="ln4070">         * break. */</a>
<a name="ln4071">        lastone = (skip_match</a>
<a name="ln4072">                   || got_int</a>
<a name="ln4073">                   || got_quit</a>
<a name="ln4074">                   || lnum &gt; line2</a>
<a name="ln4075">                   || !(subflags.do_all || do_again)</a>
<a name="ln4076">                   || (sub_firstline[matchcol] == NUL &amp;&amp; nmatch &lt;= 1</a>
<a name="ln4077">                       &amp;&amp; !re_multiline(regmatch.regprog)));</a>
<a name="ln4078">        nmatch = -1;</a>
<a name="ln4079"> </a>
<a name="ln4080">        /*</a>
<a name="ln4081">         * Replace the line in the buffer when needed.  This is</a>
<a name="ln4082">         * skipped when there are more matches.</a>
<a name="ln4083">         * The check for nmatch_tl is needed for when multi-line</a>
<a name="ln4084">         * matching must replace the lines before trying to do another</a>
<a name="ln4085">         * match, otherwise &quot;\@&lt;=&quot; won't work.</a>
<a name="ln4086">         * When the match starts below where we start searching also</a>
<a name="ln4087">         * need to replace the line first (using \zs after \n).</a>
<a name="ln4088">         */</a>
<a name="ln4089">        if (lastone</a>
<a name="ln4090">            || nmatch_tl &gt; 0</a>
<a name="ln4091">            || (nmatch = vim_regexec_multi(&amp;regmatch, curwin,</a>
<a name="ln4092">                                           curbuf, sub_firstlnum,</a>
<a name="ln4093">                                           matchcol, NULL, NULL)) == 0</a>
<a name="ln4094">            || regmatch.startpos[0].lnum &gt; 0) {</a>
<a name="ln4095">          if (new_start != NULL) {</a>
<a name="ln4096">            /*</a>
<a name="ln4097">             * Copy the rest of the line, that didn't match.</a>
<a name="ln4098">             * &quot;matchcol&quot; has to be adjusted, we use the end of</a>
<a name="ln4099">             * the line as reference, because the substitute may</a>
<a name="ln4100">             * have changed the number of characters.  Same for</a>
<a name="ln4101">             * &quot;prev_matchcol&quot;.</a>
<a name="ln4102">             */</a>
<a name="ln4103">            STRCAT(new_start, sub_firstline + copycol);</a>
<a name="ln4104">            matchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;</a>
<a name="ln4105">            prev_matchcol = (colnr_T)STRLEN(sub_firstline)</a>
<a name="ln4106">                            - prev_matchcol;</a>
<a name="ln4107"> </a>
<a name="ln4108">            if (u_savesub(lnum) != OK) {</a>
<a name="ln4109">              break;</a>
<a name="ln4110">            }</a>
<a name="ln4111">            ml_replace(lnum, new_start, true);</a>
<a name="ln4112"> </a>
<a name="ln4113">            if (nmatch_tl &gt; 0) {</a>
<a name="ln4114">              /*</a>
<a name="ln4115">               * Matched lines have now been substituted and are</a>
<a name="ln4116">               * useless, delete them.  The part after the match</a>
<a name="ln4117">               * has been appended to new_start, we don't need</a>
<a name="ln4118">               * it in the buffer.</a>
<a name="ln4119">               */</a>
<a name="ln4120">              ++lnum;</a>
<a name="ln4121">              if (u_savedel(lnum, nmatch_tl) != OK)</a>
<a name="ln4122">                break;</a>
<a name="ln4123">              for (i = 0; i &lt; nmatch_tl; i++) {</a>
<a name="ln4124">                ml_delete(lnum, false);</a>
<a name="ln4125">              }</a>
<a name="ln4126">              mark_adjust(lnum, lnum + nmatch_tl - 1,</a>
<a name="ln4127">                          (long)MAXLNUM, -nmatch_tl, kExtmarkNOOP);</a>
<a name="ln4128">              if (subflags.do_ask) {</a>
<a name="ln4129">                deleted_lines(lnum, nmatch_tl);</a>
<a name="ln4130">              }</a>
<a name="ln4131">              lnum--;</a>
<a name="ln4132">              line2 -= nmatch_tl;  // nr of lines decreases</a>
<a name="ln4133">              nmatch_tl = 0;</a>
<a name="ln4134">            }</a>
<a name="ln4135"> </a>
<a name="ln4136">            /* When asking, undo is saved each time, must also set</a>
<a name="ln4137">             * changed flag each time. */</a>
<a name="ln4138">            if (subflags.do_ask) {</a>
<a name="ln4139">              changed_bytes(lnum, 0);</a>
<a name="ln4140">            } else {</a>
<a name="ln4141">              if (first_line == 0) {</a>
<a name="ln4142">                first_line = lnum;</a>
<a name="ln4143">              }</a>
<a name="ln4144">              last_line = lnum + 1;</a>
<a name="ln4145">            }</a>
<a name="ln4146"> </a>
<a name="ln4147">            sub_firstlnum = lnum;</a>
<a name="ln4148">            xfree(sub_firstline);                /* free the temp buffer */</a>
<a name="ln4149">            sub_firstline = new_start;</a>
<a name="ln4150">            new_start = NULL;</a>
<a name="ln4151">            matchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;</a>
<a name="ln4152">            prev_matchcol = (colnr_T)STRLEN(sub_firstline)</a>
<a name="ln4153">                            - prev_matchcol;</a>
<a name="ln4154">            copycol = 0;</a>
<a name="ln4155">          }</a>
<a name="ln4156">          if (nmatch == -1 &amp;&amp; !lastone)</a>
<a name="ln4157">            nmatch = vim_regexec_multi(&amp;regmatch, curwin, curbuf,</a>
<a name="ln4158">                                       sub_firstlnum, matchcol, NULL, NULL);</a>
<a name="ln4159"> </a>
<a name="ln4160">          /*</a>
<a name="ln4161">           * 5. break if there isn't another match in this line</a>
<a name="ln4162">           */</a>
<a name="ln4163">          if (nmatch &lt;= 0) {</a>
<a name="ln4164">            /* If the match found didn't start where we were</a>
<a name="ln4165">             * searching, do the next search in the line where we</a>
<a name="ln4166">             * found the match. */</a>
<a name="ln4167">            if (nmatch == -1)</a>
<a name="ln4168">              lnum -= regmatch.startpos[0].lnum;</a>
<a name="ln4169"> </a>
<a name="ln4170">#define PUSH_PREVIEW_LINES() \</a>
<a name="ln4171">            do { \</a>
<a name="ln4172">              linenr_T match_lines = current_match.end.lnum \</a>
<a name="ln4173">                                     - current_match.start.lnum +1; \</a>
<a name="ln4174">              if (preview_lines.subresults.size &gt; 0) { \</a>
<a name="ln4175">                linenr_T last = kv_last(preview_lines.subresults).end.lnum; \</a>
<a name="ln4176">                if (last == current_match.start.lnum) { \</a>
<a name="ln4177">                  preview_lines.lines_needed += match_lines - 1; \</a>
<a name="ln4178">                } \</a>
<a name="ln4179">              } else { \</a>
<a name="ln4180">                preview_lines.lines_needed += match_lines; \</a>
<a name="ln4181">              } \</a>
<a name="ln4182">              kv_push(preview_lines.subresults, current_match); \</a>
<a name="ln4183">            } while (0)</a>
<a name="ln4184"> </a>
<a name="ln4185">            // Push the match to preview_lines.</a>
<a name="ln4186">            PUSH_PREVIEW_LINES();</a>
<a name="ln4187"> </a>
<a name="ln4188">            break;</a>
<a name="ln4189">          }</a>
<a name="ln4190">        }</a>
<a name="ln4191">        // Push the match to preview_lines.</a>
<a name="ln4192">        PUSH_PREVIEW_LINES();</a>
<a name="ln4193"> </a>
<a name="ln4194">        line_breakcheck();</a>
<a name="ln4195">      }</a>
<a name="ln4196"> </a>
<a name="ln4197">      if (did_sub) {</a>
<a name="ln4198">        sub_nlines++;</a>
<a name="ln4199">      }</a>
<a name="ln4200">      xfree(new_start);              // for when substitute was cancelled</a>
<a name="ln4201">      XFREE_CLEAR(sub_firstline);    // free the copy of the original line</a>
<a name="ln4202">    }</a>
<a name="ln4203"> </a>
<a name="ln4204">    line_breakcheck();</a>
<a name="ln4205"> </a>
<a name="ln4206">    if (profile_passed_limit(timeout)) {</a>
<a name="ln4207">      got_quit = true;</a>
<a name="ln4208">    }</a>
<a name="ln4209">  }</a>
<a name="ln4210"> </a>
<a name="ln4211">  if (first_line != 0) {</a>
<a name="ln4212">    /* Need to subtract the number of added lines from &quot;last_line&quot; to get</a>
<a name="ln4213">     * the line number before the change (same as adding the number of</a>
<a name="ln4214">     * deleted lines). */</a>
<a name="ln4215">    i = curbuf-&gt;b_ml.ml_line_count - old_line_count;</a>
<a name="ln4216">    changed_lines(first_line, 0, last_line - i, i, false);</a>
<a name="ln4217"> </a>
<a name="ln4218">    int64_t num_added = last_line - first_line;</a>
<a name="ln4219">    int64_t num_removed = num_added - i;</a>
<a name="ln4220">    buf_updates_send_changes(curbuf, first_line, num_added, num_removed,</a>
<a name="ln4221">                             do_buf_event);</a>
<a name="ln4222">  }</a>
<a name="ln4223"> </a>
<a name="ln4224">  xfree(sub_firstline);   /* may have to free allocated copy of the line */</a>
<a name="ln4225"> </a>
<a name="ln4226">  // &quot;:s/pat//n&quot; doesn't move the cursor</a>
<a name="ln4227">  if (subflags.do_count) {</a>
<a name="ln4228">    curwin-&gt;w_cursor = old_cursor;</a>
<a name="ln4229">  }</a>
<a name="ln4230"> </a>
<a name="ln4231">  if (sub_nsubs &gt; start_nsubs) {</a>
<a name="ln4232">    /* Set the '[ and '] marks. */</a>
<a name="ln4233">    curbuf-&gt;b_op_start.lnum = eap-&gt;line1;</a>
<a name="ln4234">    curbuf-&gt;b_op_end.lnum = line2;</a>
<a name="ln4235">    curbuf-&gt;b_op_start.col = curbuf-&gt;b_op_end.col = 0;</a>
<a name="ln4236"> </a>
<a name="ln4237">    if (!global_busy) {</a>
<a name="ln4238">      // when interactive leave cursor on the match</a>
<a name="ln4239">      if (!subflags.do_ask) {</a>
<a name="ln4240">        if (endcolumn) {</a>
<a name="ln4241">          coladvance(MAXCOL);</a>
<a name="ln4242">        } else {</a>
<a name="ln4243">          beginline(BL_WHITE | BL_FIX);</a>
<a name="ln4244">        }</a>
<a name="ln4245">      }</a>
<a name="ln4246">      if (!preview &amp;&amp; !do_sub_msg(subflags.do_count) &amp;&amp; subflags.do_ask) {</a>
<a name="ln4247">        MSG(&quot;&quot;);</a>
<a name="ln4248">      }</a>
<a name="ln4249">    } else {</a>
<a name="ln4250">      global_need_beginline = true;</a>
<a name="ln4251">    }</a>
<a name="ln4252">    if (subflags.do_print) {</a>
<a name="ln4253">      print_line(curwin-&gt;w_cursor.lnum, subflags.do_number, subflags.do_list);</a>
<a name="ln4254">    }</a>
<a name="ln4255">  } else if (!global_busy) {</a>
<a name="ln4256">    if (got_int) {</a>
<a name="ln4257">      // interrupted</a>
<a name="ln4258">      EMSG(_(e_interr));</a>
<a name="ln4259">    } else if (got_match) {</a>
<a name="ln4260">      // did find something but nothing substituted</a>
<a name="ln4261">      MSG(&quot;&quot;);</a>
<a name="ln4262">    } else if (subflags.do_error) {</a>
<a name="ln4263">      // nothing found</a>
<a name="ln4264">      EMSG2(_(e_patnotf2), get_search_pat());</a>
<a name="ln4265">    }</a>
<a name="ln4266">  }</a>
<a name="ln4267"> </a>
<a name="ln4268">  if (subflags.do_ask &amp;&amp; hasAnyFolding(curwin)) {</a>
<a name="ln4269">    // Cursor position may require updating</a>
<a name="ln4270">    changed_window_setting();</a>
<a name="ln4271">  }</a>
<a name="ln4272"> </a>
<a name="ln4273">  vim_regfree(regmatch.regprog);</a>
<a name="ln4274"> </a>
<a name="ln4275">  // Restore the flag values, they can be used for &quot;:&amp;&amp;&quot;.</a>
<a name="ln4276">  subflags.do_all = save_do_all;</a>
<a name="ln4277">  subflags.do_ask = save_do_ask;</a>
<a name="ln4278"> </a>
<a name="ln4279">  // Show 'inccommand' preview if there are matched lines.</a>
<a name="ln4280">  buf_T *preview_buf = NULL;</a>
<a name="ln4281">  size_t subsize = preview_lines.subresults.size;</a>
<a name="ln4282">  if (preview &amp;&amp; !aborting()) {</a>
<a name="ln4283">    if (got_quit || profile_passed_limit(timeout)) {  // Too slow, disable.</a>
<a name="ln4284">      set_string_option_direct(&quot;icm&quot;, -1, (char_u *)&quot;&quot;, OPT_FREE,</a>
<a name="ln4285">                               SID_NONE);</a>
<a name="ln4286">    } else if (*p_icm != NUL &amp;&amp;  pat != NULL) {</a>
<a name="ln4287">      if (pre_src_id == 0) {</a>
<a name="ln4288">        // Get a unique new src_id, saved in a static</a>
<a name="ln4289">        pre_src_id = (int)nvim_create_namespace((String)STRING_INIT);</a>
<a name="ln4290">      }</a>
<a name="ln4291">      if (pre_hl_id == 0) {</a>
<a name="ln4292">        pre_hl_id = syn_check_group((char_u *)S_LEN(&quot;Substitute&quot;));</a>
<a name="ln4293">      }</a>
<a name="ln4294">      curbuf-&gt;b_changed = save_b_changed;  // preserve 'modified' during preview</a>
<a name="ln4295">      preview_buf = show_sub(eap, old_cursor, &amp;preview_lines,</a>
<a name="ln4296">                             pre_hl_id, pre_src_id, bufnr);</a>
<a name="ln4297">      if (subsize &gt; 0) {</a>
<a name="ln4298">        extmark_clear(orig_buf, pre_src_id, eap-&gt;line1-1, 0,</a>
<a name="ln4299">                      kv_last(preview_lines.subresults).end.lnum-1, MAXCOL);</a>
<a name="ln4300">      }</a>
<a name="ln4301">    }</a>
<a name="ln4302">  }</a>
<a name="ln4303"> </a>
<a name="ln4304">  kv_destroy(preview_lines.subresults);</a>
<a name="ln4305"> </a>
<a name="ln4306">  return preview_buf;</a>
<a name="ln4307">#undef ADJUST_SUB_FIRSTLNUM</a>
<a name="ln4308">#undef PUSH_PREVIEW_LINES</a>
<a name="ln4309">}  // NOLINT(readability/fn_size)</a>
<a name="ln4310"> </a>
<a name="ln4311">/*</a>
<a name="ln4312"> * Give message for number of substitutions.</a>
<a name="ln4313"> * Can also be used after a &quot;:global&quot; command.</a>
<a name="ln4314"> * Return TRUE if a message was given.</a>
<a name="ln4315"> */</a>
<a name="ln4316">bool</a>
<a name="ln4317">do_sub_msg (</a>
<a name="ln4318">    bool count_only                /* used 'n' flag for &quot;:s&quot; */</a>
<a name="ln4319">)</a>
<a name="ln4320">{</a>
<a name="ln4321">  /*</a>
<a name="ln4322">   * Only report substitutions when:</a>
<a name="ln4323">   * - more than 'report' substitutions</a>
<a name="ln4324">   * - command was typed by user, or number of changed lines &gt; 'report'</a>
<a name="ln4325">   * - giving messages is not disabled by 'lazyredraw'</a>
<a name="ln4326">   */</a>
<a name="ln4327">  if (((sub_nsubs &gt; p_report &amp;&amp; (KeyTyped || sub_nlines &gt; 1 || p_report &lt; 1))</a>
<a name="ln4328">       || count_only)</a>
<a name="ln4329">      &amp;&amp; messaging()) {</a>
<a name="ln4330">    if (got_int)</a>
<a name="ln4331">      STRCPY(msg_buf, _(&quot;(Interrupted) &quot;));</a>
<a name="ln4332">    else</a>
<a name="ln4333">      *msg_buf = NUL;</a>
<a name="ln4334">    if (sub_nsubs == 1)</a>
<a name="ln4335">      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),</a>
<a name="ln4336">          &quot;%s&quot;, count_only ? _(&quot;1 match&quot;) : _(&quot;1 substitution&quot;));</a>
<a name="ln4337">    else</a>
<a name="ln4338">      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),</a>
<a name="ln4339">          count_only ? _(&quot;%&quot; PRId64 &quot; matches&quot;)</a>
<a name="ln4340">                     : _(&quot;%&quot; PRId64 &quot; substitutions&quot;),</a>
<a name="ln4341">          (int64_t)sub_nsubs);</a>
<a name="ln4342">    if (sub_nlines == 1)</a>
<a name="ln4343">      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),</a>
<a name="ln4344">          &quot;%s&quot;, _(&quot; on 1 line&quot;));</a>
<a name="ln4345">    else</a>
<a name="ln4346">      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),</a>
<a name="ln4347">          _(&quot; on %&quot; PRId64 &quot; lines&quot;), (int64_t)sub_nlines);</a>
<a name="ln4348">    if (msg(msg_buf))</a>
<a name="ln4349">      /* save message to display it after redraw */</a>
<a name="ln4350">      set_keep_msg(msg_buf, 0);</a>
<a name="ln4351">    return true;</a>
<a name="ln4352">  }</a>
<a name="ln4353">  if (got_int) {</a>
<a name="ln4354">    EMSG(_(e_interr));</a>
<a name="ln4355">    return true;</a>
<a name="ln4356">  }</a>
<a name="ln4357">  return false;</a>
<a name="ln4358">}</a>
<a name="ln4359"> </a>
<a name="ln4360">static void global_exe_one(char_u *const cmd, const linenr_T lnum)</a>
<a name="ln4361">{</a>
<a name="ln4362">  curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln4363">  curwin-&gt;w_cursor.col = 0;</a>
<a name="ln4364">  if (*cmd == NUL || *cmd == '\n') {</a>
<a name="ln4365">    do_cmdline((char_u *)&quot;p&quot;, NULL, NULL, DOCMD_NOWAIT);</a>
<a name="ln4366">  } else {</a>
<a name="ln4367">    do_cmdline(cmd, NULL, NULL, DOCMD_NOWAIT);</a>
<a name="ln4368">  }</a>
<a name="ln4369">}</a>
<a name="ln4370"> </a>
<a name="ln4371">/*</a>
<a name="ln4372"> * Execute a global command of the form:</a>
<a name="ln4373"> *</a>
<a name="ln4374"> * g/pattern/X : execute X on all lines where pattern matches</a>
<a name="ln4375"> * v/pattern/X : execute X on all lines where pattern does not match</a>
<a name="ln4376"> *</a>
<a name="ln4377"> * where 'X' is an EX command</a>
<a name="ln4378"> *</a>
<a name="ln4379"> * The command character (as well as the trailing slash) is optional, and</a>
<a name="ln4380"> * is assumed to be 'p' if missing.</a>
<a name="ln4381"> *</a>
<a name="ln4382"> * This is implemented in two passes: first we scan the file for the pattern and</a>
<a name="ln4383"> * set a mark for each line that (not) matches. Secondly we execute the command</a>
<a name="ln4384"> * for each line that has a mark. This is required because after deleting</a>
<a name="ln4385"> * lines we do not know where to search for the next match.</a>
<a name="ln4386"> */</a>
<a name="ln4387">void ex_global(exarg_T *eap)</a>
<a name="ln4388">{</a>
<a name="ln4389">  linenr_T lnum;                /* line number according to old situation */</a>
<a name="ln4390">  int ndone = 0;</a>
<a name="ln4391">  int type;                     /* first char of cmd: 'v' or 'g' */</a>
<a name="ln4392">  char_u      *cmd;             /* command argument */</a>
<a name="ln4393"> </a>
<a name="ln4394">  char_u delim;                 /* delimiter, normally '/' */</a>
<a name="ln4395">  char_u      *pat;</a>
<a name="ln4396">  regmmatch_T regmatch;</a>
<a name="ln4397">  int match;</a>
<a name="ln4398">  int which_pat;</a>
<a name="ln4399"> </a>
<a name="ln4400">  // When nesting the command works on one line.  This allows for</a>
<a name="ln4401">  // &quot;:g/found/v/notfound/command&quot;.</a>
<a name="ln4402">  if (global_busy &amp;&amp; (eap-&gt;line1 != 1</a>
<a name="ln4403">                      || eap-&gt;line2 != curbuf-&gt;b_ml.ml_line_count)) {</a>
<a name="ln4404">    // will increment global_busy to break out of the loop</a>
<a name="ln4405">    EMSG(_(&quot;E147: Cannot do :global recursive with a range&quot;));</a>
<a name="ln4406">    return;</a>
<a name="ln4407">  }</a>
<a name="ln4408"> </a>
<a name="ln4409">  if (eap-&gt;forceit)                 /* &quot;:global!&quot; is like &quot;:vglobal&quot; */</a>
<a name="ln4410">    type = 'v';</a>
<a name="ln4411">  else</a>
<a name="ln4412">    type = *eap-&gt;cmd;</a>
<a name="ln4413">  cmd = eap-&gt;arg;</a>
<a name="ln4414">  which_pat = RE_LAST;              /* default: use last used regexp */</a>
<a name="ln4415"> </a>
<a name="ln4416">  /*</a>
<a name="ln4417">   * undocumented vi feature:</a>
<a name="ln4418">   *	&quot;\/&quot; and &quot;\?&quot;: use previous search pattern.</a>
<a name="ln4419">   *		 &quot;\&amp;&quot;: use previous substitute pattern.</a>
<a name="ln4420">   */</a>
<a name="ln4421">  if (*cmd == '\\') {</a>
<a name="ln4422">    ++cmd;</a>
<a name="ln4423">    if (vim_strchr((char_u *)&quot;/?&amp;&quot;, *cmd) == NULL) {</a>
<a name="ln4424">      EMSG(_(e_backslash));</a>
<a name="ln4425">      return;</a>
<a name="ln4426">    }</a>
<a name="ln4427">    if (*cmd == '&amp;')</a>
<a name="ln4428">      which_pat = RE_SUBST;             /* use previous substitute pattern */</a>
<a name="ln4429">    else</a>
<a name="ln4430">      which_pat = RE_SEARCH;            /* use previous search pattern */</a>
<a name="ln4431">    ++cmd;</a>
<a name="ln4432">    pat = (char_u *)&quot;&quot;;</a>
<a name="ln4433">  } else if (*cmd == NUL) {</a>
<a name="ln4434">    EMSG(_(&quot;E148: Regular expression missing from global&quot;));</a>
<a name="ln4435">    return;</a>
<a name="ln4436">  } else {</a>
<a name="ln4437">    delim = *cmd;               /* get the delimiter */</a>
<a name="ln4438">    if (delim)</a>
<a name="ln4439">      ++cmd;                    /* skip delimiter if there is one */</a>
<a name="ln4440">    pat = cmd;                  /* remember start of pattern */</a>
<a name="ln4441">    cmd = skip_regexp(cmd, delim, p_magic, &amp;eap-&gt;arg);</a>
<a name="ln4442">    if (cmd[0] == delim)                    /* end delimiter found */</a>
<a name="ln4443">      *cmd++ = NUL;                         /* replace it with a NUL */</a>
<a name="ln4444">  }</a>
<a name="ln4445"> </a>
<a name="ln4446">  if (search_regcomp(pat, RE_BOTH, which_pat, SEARCH_HIS, &amp;regmatch) == FAIL) {</a>
<a name="ln4447">    EMSG(_(e_invcmd));</a>
<a name="ln4448">    return;</a>
<a name="ln4449">  }</a>
<a name="ln4450"> </a>
<a name="ln4451">  if (global_busy) {</a>
<a name="ln4452">    lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln4453">    match = vim_regexec_multi(&amp;regmatch, curwin, curbuf, lnum,</a>
<a name="ln4454">                              (colnr_T)0, NULL, NULL);</a>
<a name="ln4455">    if ((type == 'g' &amp;&amp; match) || (type == 'v' &amp;&amp; !match)) {</a>
<a name="ln4456">      global_exe_one(cmd, lnum);</a>
<a name="ln4457">    }</a>
<a name="ln4458">  } else {</a>
<a name="ln4459">    // pass 1: set marks for each (not) matching line</a>
<a name="ln4460">    for (lnum = eap-&gt;line1; lnum &lt;= eap-&gt;line2 &amp;&amp; !got_int; lnum++) {</a>
<a name="ln4461">      // a match on this line?</a>
<a name="ln4462">      match = vim_regexec_multi(&amp;regmatch, curwin, curbuf, lnum,</a>
<a name="ln4463">                                (colnr_T)0, NULL, NULL);</a>
<a name="ln4464">      if ((type == 'g' &amp;&amp; match) || (type == 'v' &amp;&amp; !match)) {</a>
<a name="ln4465">        ml_setmarked(lnum);</a>
<a name="ln4466">        ndone++;</a>
<a name="ln4467">      }</a>
<a name="ln4468">      line_breakcheck();</a>
<a name="ln4469">    }</a>
<a name="ln4470"> </a>
<a name="ln4471">    // pass 2: execute the command for each line that has been marked</a>
<a name="ln4472">    if (got_int) {</a>
<a name="ln4473">      MSG(_(e_interr));</a>
<a name="ln4474">    } else if (ndone == 0) {</a>
<a name="ln4475">      if (type == 'v') {</a>
<a name="ln4476">        smsg(_(&quot;Pattern found in every line: %s&quot;), pat);</a>
<a name="ln4477">      } else {</a>
<a name="ln4478">        smsg(_(&quot;Pattern not found: %s&quot;), pat);</a>
<a name="ln4479">      }</a>
<a name="ln4480">    } else {</a>
<a name="ln4481">      global_exe(cmd);</a>
<a name="ln4482">    }</a>
<a name="ln4483">    ml_clearmarked();         // clear rest of the marks</a>
<a name="ln4484">  }</a>
<a name="ln4485">  vim_regfree(regmatch.regprog);</a>
<a name="ln4486">}</a>
<a name="ln4487"> </a>
<a name="ln4488">/// Execute `cmd` on lines marked with ml_setmarked().</a>
<a name="ln4489">void global_exe(char_u *cmd)</a>
<a name="ln4490">{</a>
<a name="ln4491">  linenr_T old_lcount;      // b_ml.ml_line_count before the command</a>
<a name="ln4492">  buf_T *old_buf = curbuf;  // remember what buffer we started in</a>
<a name="ln4493">  linenr_T lnum;            // line number according to old situation</a>
<a name="ln4494">  int save_mapped_ctrl_c = mapped_ctrl_c;</a>
<a name="ln4495"> </a>
<a name="ln4496">  // Set current position only once for a global command.</a>
<a name="ln4497">  // If global_busy is set, setpcmark() will not do anything.</a>
<a name="ln4498">  // If there is an error, global_busy will be incremented.</a>
<a name="ln4499">  setpcmark();</a>
<a name="ln4500"> </a>
<a name="ln4501">  // When the command writes a message, don't overwrite the command.</a>
<a name="ln4502">  msg_didout = true;</a>
<a name="ln4503">  // Disable CTRL-C mapping, let it interrupt (potentially long output).</a>
<a name="ln4504">  mapped_ctrl_c = 0;</a>
<a name="ln4505"> </a>
<a name="ln4506">  sub_nsubs = 0;</a>
<a name="ln4507">  sub_nlines = 0;</a>
<a name="ln4508">  global_need_beginline = false;</a>
<a name="ln4509">  global_busy = 1;</a>
<a name="ln4510">  old_lcount = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln4511"> </a>
<a name="ln4512">  while (!got_int &amp;&amp; (lnum = ml_firstmarked()) != 0 &amp;&amp; global_busy == 1) {</a>
<a name="ln4513">    global_exe_one(cmd, lnum);</a>
<a name="ln4514">    os_breakcheck();</a>
<a name="ln4515">  }</a>
<a name="ln4516"> </a>
<a name="ln4517">  mapped_ctrl_c = save_mapped_ctrl_c;</a>
<a name="ln4518">  global_busy = 0;</a>
<a name="ln4519">  if (global_need_beginline) {</a>
<a name="ln4520">    beginline(BL_WHITE | BL_FIX);</a>
<a name="ln4521">  } else {</a>
<a name="ln4522">    check_cursor();  // cursor may be beyond the end of the line</a>
<a name="ln4523">  }</a>
<a name="ln4524"> </a>
<a name="ln4525">  // the cursor may not have moved in the text but a change in a previous</a>
<a name="ln4526">  // line may move it on the screen</a>
<a name="ln4527">  changed_line_abv_curs();</a>
<a name="ln4528"> </a>
<a name="ln4529">  // If it looks like no message was written, allow overwriting the</a>
<a name="ln4530">  // command with the report for number of changes.</a>
<a name="ln4531">  if (msg_col == 0 &amp;&amp; msg_scrolled == 0) {</a>
<a name="ln4532">    msg_didout = false;</a>
<a name="ln4533">  }</a>
<a name="ln4534"> </a>
<a name="ln4535">  // If substitutes done, report number of substitutes, otherwise report</a>
<a name="ln4536">  // number of extra or deleted lines.</a>
<a name="ln4537">  // Don't report extra or deleted lines in the edge case where the buffer</a>
<a name="ln4538">  // we are in after execution is different from the buffer we started in.</a>
<a name="ln4539">  if (!do_sub_msg(false) &amp;&amp; curbuf == old_buf) {</a>
<a name="ln4540">    msgmore(curbuf-&gt;b_ml.ml_line_count - old_lcount);</a>
<a name="ln4541">  }</a>
<a name="ln4542">}</a>
<a name="ln4543"> </a>
<a name="ln4544">#if defined(EXITFREE)</a>
<a name="ln4545">void free_old_sub(void)</a>
<a name="ln4546">{</a>
<a name="ln4547">  sub_set_replacement((SubReplacementString) {NULL, 0, NULL});</a>
<a name="ln4548">}</a>
<a name="ln4549"> </a>
<a name="ln4550">#endif</a>
<a name="ln4551"> </a>
<a name="ln4552">/*</a>
<a name="ln4553"> * Set up for a tagpreview.</a>
<a name="ln4554"> * Return TRUE when it was created.</a>
<a name="ln4555"> */</a>
<a name="ln4556">bool</a>
<a name="ln4557">prepare_tagpreview (</a>
<a name="ln4558">    bool undo_sync                  /* sync undo when leaving the window */</a>
<a name="ln4559">)</a>
<a name="ln4560">{</a>
<a name="ln4561">  /*</a>
<a name="ln4562">   * If there is already a preview window open, use that one.</a>
<a name="ln4563">   */</a>
<a name="ln4564">  if (!curwin-&gt;w_p_pvw) {</a>
<a name="ln4565">    bool found_win = false;</a>
<a name="ln4566">    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln4567">      if (wp-&gt;w_p_pvw) {</a>
<a name="ln4568">        win_enter(wp, undo_sync);</a>
<a name="ln4569">        found_win = true;</a>
<a name="ln4570">        break;</a>
<a name="ln4571">      }</a>
<a name="ln4572">    }</a>
<a name="ln4573">    if (!found_win) {</a>
<a name="ln4574">      /*</a>
<a name="ln4575">       * There is no preview window open yet.  Create one.</a>
<a name="ln4576">       */</a>
<a name="ln4577">      if (win_split(g_do_tagpreview &gt; 0 ? g_do_tagpreview : 0, 0)</a>
<a name="ln4578">          == FAIL)</a>
<a name="ln4579">        return false;</a>
<a name="ln4580">      curwin-&gt;w_p_pvw = TRUE;</a>
<a name="ln4581">      curwin-&gt;w_p_wfh = TRUE;</a>
<a name="ln4582">      RESET_BINDING(curwin);                /* don't take over 'scrollbind'</a>
<a name="ln4583">                                               and 'cursorbind' */</a>
<a name="ln4584">      curwin-&gt;w_p_diff = false;             // no 'diff'</a>
<a name="ln4585">      set_string_option_direct(&quot;fdc&quot;, -1,     // no 'foldcolumn'</a>
<a name="ln4586">                               (char_u *)&quot;0&quot;, OPT_FREE, SID_NONE);</a>
<a name="ln4587">      return true;</a>
<a name="ln4588">    }</a>
<a name="ln4589">  }</a>
<a name="ln4590">  return false;</a>
<a name="ln4591">}</a>
<a name="ln4592"> </a>
<a name="ln4593"> </a>
<a name="ln4594"> </a>
<a name="ln4595">/*</a>
<a name="ln4596"> * &quot;:help&quot;: open a read-only window on a help file</a>
<a name="ln4597"> */</a>
<a name="ln4598">void ex_help(exarg_T *eap)</a>
<a name="ln4599">{</a>
<a name="ln4600">  char_u      *arg;</a>
<a name="ln4601">  char_u      *tag;</a>
<a name="ln4602">  FILE        *helpfd;          /* file descriptor of help file */</a>
<a name="ln4603">  int n;</a>
<a name="ln4604">  int i;</a>
<a name="ln4605">  win_T       *wp;</a>
<a name="ln4606">  int num_matches;</a>
<a name="ln4607">  char_u      **matches;</a>
<a name="ln4608">  char_u      *p;</a>
<a name="ln4609">  int empty_fnum = 0;</a>
<a name="ln4610">  int alt_fnum = 0;</a>
<a name="ln4611">  buf_T       *buf;</a>
<a name="ln4612">  int len;</a>
<a name="ln4613">  char_u      *lang;</a>
<a name="ln4614">  const bool old_KeyTyped = KeyTyped;</a>
<a name="ln4615"> </a>
<a name="ln4616">  if (eap != NULL) {</a>
<a name="ln4617">    /*</a>
<a name="ln4618">     * A &quot;:help&quot; command ends at the first LF, or at a '|' that is</a>
<a name="ln4619">     * followed by some text.  Set nextcmd to the following command.</a>
<a name="ln4620">     */</a>
<a name="ln4621">    for (arg = eap-&gt;arg; *arg; ++arg) {</a>
<a name="ln4622">      if (*arg == '\n' || *arg == '\r'</a>
<a name="ln4623">          || (*arg == '|' &amp;&amp; arg[1] != NUL &amp;&amp; arg[1] != '|')) {</a>
<a name="ln4624">        *arg++ = NUL;</a>
<a name="ln4625">        eap-&gt;nextcmd = arg;</a>
<a name="ln4626">        break;</a>
<a name="ln4627">      }</a>
<a name="ln4628">    }</a>
<a name="ln4629">    arg = eap-&gt;arg;</a>
<a name="ln4630"> </a>
<a name="ln4631">    if (eap-&gt;forceit &amp;&amp; *arg == NUL &amp;&amp; !curbuf-&gt;b_help) {</a>
<a name="ln4632">      EMSG(_(&quot;E478: Don't panic!&quot;));</a>
<a name="ln4633">      return;</a>
<a name="ln4634">    }</a>
<a name="ln4635"> </a>
<a name="ln4636">    if (eap-&gt;skip)          /* not executing commands */</a>
<a name="ln4637">      return;</a>
<a name="ln4638">  } else</a>
<a name="ln4639">    arg = (char_u *)&quot;&quot;;</a>
<a name="ln4640"> </a>
<a name="ln4641">  /* remove trailing blanks */</a>
<a name="ln4642">  p = arg + STRLEN(arg) - 1;</a>
<a name="ln4643">  while (p &gt; arg &amp;&amp; ascii_iswhite(*p) &amp;&amp; p[-1] != '\\')</a>
<a name="ln4644">    *p-- = NUL;</a>
<a name="ln4645"> </a>
<a name="ln4646">  /* Check for a specified language */</a>
<a name="ln4647">  lang = check_help_lang(arg);</a>
<a name="ln4648"> </a>
<a name="ln4649">  /* When no argument given go to the index. */</a>
<a name="ln4650">  if (*arg == NUL)</a>
<a name="ln4651">    arg = (char_u *)&quot;help.txt&quot;;</a>
<a name="ln4652"> </a>
<a name="ln4653">  /*</a>
<a name="ln4654">   * Check if there is a match for the argument.</a>
<a name="ln4655">   */</a>
<a name="ln4656">  n = find_help_tags(arg, &amp;num_matches, &amp;matches,</a>
<a name="ln4657">      eap != NULL &amp;&amp; eap-&gt;forceit);</a>
<a name="ln4658"> </a>
<a name="ln4659">  i = 0;</a>
<a name="ln4660">  if (n != FAIL &amp;&amp; lang != NULL)</a>
<a name="ln4661">    /* Find first item with the requested language. */</a>
<a name="ln4662">    for (i = 0; i &lt; num_matches; ++i) {</a>
<a name="ln4663">      len = (int)STRLEN(matches[i]);</a>
<a name="ln4664">      if (len &gt; 3 &amp;&amp; matches[i][len - 3] == '@'</a>
<a name="ln4665">          &amp;&amp; STRICMP(matches[i] + len - 2, lang) == 0)</a>
<a name="ln4666">        break;</a>
<a name="ln4667">    }</a>
<a name="ln4668">  if (i &gt;= num_matches || n == FAIL) {</a>
<a name="ln4669">    if (lang != NULL)</a>
<a name="ln4670">      EMSG3(_(&quot;E661: Sorry, no '%s' help for %s&quot;), lang, arg);</a>
<a name="ln4671">    else</a>
<a name="ln4672">      EMSG2(_(&quot;E149: Sorry, no help for %s&quot;), arg);</a>
<a name="ln4673">    if (n != FAIL)</a>
<a name="ln4674">      FreeWild(num_matches, matches);</a>
<a name="ln4675">    return;</a>
<a name="ln4676">  }</a>
<a name="ln4677"> </a>
<a name="ln4678">  /* The first match (in the requested language) is the best match. */</a>
<a name="ln4679">  tag = vim_strsave(matches[i]);</a>
<a name="ln4680">  FreeWild(num_matches, matches);</a>
<a name="ln4681"> </a>
<a name="ln4682">  /*</a>
<a name="ln4683">   * Re-use an existing help window or open a new one.</a>
<a name="ln4684">   * Always open a new one for &quot;:tab help&quot;.</a>
<a name="ln4685">   */</a>
<a name="ln4686">  if (!bt_help(curwin-&gt;w_buffer)</a>
<a name="ln4687">      || cmdmod.tab != 0</a>
<a name="ln4688">      ) {</a>
<a name="ln4689">    if (cmdmod.tab != 0) {</a>
<a name="ln4690">      wp = NULL;</a>
<a name="ln4691">    } else {</a>
<a name="ln4692">      wp = NULL;</a>
<a name="ln4693">      FOR_ALL_WINDOWS_IN_TAB(wp2, curtab) {</a>
<a name="ln4694">        if (bt_help(wp2-&gt;w_buffer)) {</a>
<a name="ln4695">          wp = wp2;</a>
<a name="ln4696">          break;</a>
<a name="ln4697">        }</a>
<a name="ln4698">      }</a>
<a name="ln4699">    }</a>
<a name="ln4700">    if (wp != NULL &amp;&amp; wp-&gt;w_buffer-&gt;b_nwindows &gt; 0) {</a>
<a name="ln4701">      win_enter(wp, true);</a>
<a name="ln4702">    } else {</a>
<a name="ln4703">      // There is no help window yet.</a>
<a name="ln4704">      // Try to open the file specified by the &quot;helpfile&quot; option.</a>
<a name="ln4705">      if ((helpfd = os_fopen((char *)p_hf, READBIN)) == NULL) {</a>
<a name="ln4706">        smsg(_(&quot;Sorry, help file \&quot;%s\&quot; not found&quot;), p_hf);</a>
<a name="ln4707">        goto erret;</a>
<a name="ln4708">      }</a>
<a name="ln4709">      fclose(helpfd);</a>
<a name="ln4710"> </a>
<a name="ln4711">      /* Split off help window; put it at far top if no position</a>
<a name="ln4712">       * specified, the current window is vertically split and</a>
<a name="ln4713">       * narrow. */</a>
<a name="ln4714">      n = WSP_HELP;</a>
<a name="ln4715">      if (cmdmod.split == 0 &amp;&amp; curwin-&gt;w_width != Columns</a>
<a name="ln4716">          &amp;&amp; curwin-&gt;w_width &lt; 80)</a>
<a name="ln4717">        n |= WSP_TOP;</a>
<a name="ln4718">      if (win_split(0, n) == FAIL)</a>
<a name="ln4719">        goto erret;</a>
<a name="ln4720"> </a>
<a name="ln4721">      if (curwin-&gt;w_height &lt; p_hh)</a>
<a name="ln4722">        win_setheight((int)p_hh);</a>
<a name="ln4723"> </a>
<a name="ln4724">      /*</a>
<a name="ln4725">       * Open help file (do_ecmd() will set b_help flag, readfile() will</a>
<a name="ln4726">       * set b_p_ro flag).</a>
<a name="ln4727">       * Set the alternate file to the previously edited file.</a>
<a name="ln4728">       */</a>
<a name="ln4729">      alt_fnum = curbuf-&gt;b_fnum;</a>
<a name="ln4730">      (void)do_ecmd(0, NULL, NULL, NULL, ECMD_LASTL,</a>
<a name="ln4731">          ECMD_HIDE + ECMD_SET_HELP,</a>
<a name="ln4732">          NULL                  /* buffer is still open, don't store info */</a>
<a name="ln4733">          );</a>
<a name="ln4734">      if (!cmdmod.keepalt)</a>
<a name="ln4735">        curwin-&gt;w_alt_fnum = alt_fnum;</a>
<a name="ln4736">      empty_fnum = curbuf-&gt;b_fnum;</a>
<a name="ln4737">    }</a>
<a name="ln4738">  }</a>
<a name="ln4739"> </a>
<a name="ln4740">  if (!p_im)</a>
<a name="ln4741">    restart_edit = 0;               /* don't want insert mode in help file */</a>
<a name="ln4742"> </a>
<a name="ln4743">  /* Restore KeyTyped, setting 'filetype=help' may reset it.</a>
<a name="ln4744">   * It is needed for do_tag top open folds under the cursor. */</a>
<a name="ln4745">  KeyTyped = old_KeyTyped;</a>
<a name="ln4746"> </a>
<a name="ln4747">  do_tag(tag, DT_HELP, 1, FALSE, TRUE);</a>
<a name="ln4748"> </a>
<a name="ln4749">  /* Delete the empty buffer if we're not using it.  Careful: autocommands</a>
<a name="ln4750">   * may have jumped to another window, check that the buffer is not in a</a>
<a name="ln4751">   * window. */</a>
<a name="ln4752">  if (empty_fnum != 0 &amp;&amp; curbuf-&gt;b_fnum != empty_fnum) {</a>
<a name="ln4753">    buf = buflist_findnr(empty_fnum);</a>
<a name="ln4754">    if (buf != NULL &amp;&amp; buf-&gt;b_nwindows == 0)</a>
<a name="ln4755">      wipe_buffer(buf, TRUE);</a>
<a name="ln4756">  }</a>
<a name="ln4757"> </a>
<a name="ln4758">  /* keep the previous alternate file */</a>
<a name="ln4759">  if (alt_fnum != 0 &amp;&amp; curwin-&gt;w_alt_fnum == empty_fnum &amp;&amp; !cmdmod.keepalt)</a>
<a name="ln4760">    curwin-&gt;w_alt_fnum = alt_fnum;</a>
<a name="ln4761"> </a>
<a name="ln4762">erret:</a>
<a name="ln4763">  xfree(tag);</a>
<a name="ln4764">}</a>
<a name="ln4765"> </a>
<a name="ln4766"> </a>
<a name="ln4767">/*</a>
<a name="ln4768"> * In an argument search for a language specifiers in the form &quot;@xx&quot;.</a>
<a name="ln4769"> * Changes the &quot;@&quot; to NUL if found, and returns a pointer to &quot;xx&quot;.</a>
<a name="ln4770"> * Returns NULL if not found.</a>
<a name="ln4771"> */</a>
<a name="ln4772">char_u *check_help_lang(char_u *arg)</a>
<a name="ln4773">{</a>
<a name="ln4774">  int len = (int)STRLEN(arg);</a>
<a name="ln4775"> </a>
<a name="ln4776">  if (len &gt;= 3 &amp;&amp; arg[len - 3] == '@' &amp;&amp; ASCII_ISALPHA(arg[len - 2])</a>
<a name="ln4777">      &amp;&amp; ASCII_ISALPHA(arg[len - 1])) {</a>
<a name="ln4778">    arg[len - 3] = NUL;                 /* remove the '@' */</a>
<a name="ln4779">    return arg + len - 2;</a>
<a name="ln4780">  }</a>
<a name="ln4781">  return NULL;</a>
<a name="ln4782">}</a>
<a name="ln4783"> </a>
<a name="ln4784">/*</a>
<a name="ln4785"> * Return a heuristic indicating how well the given string matches.  The</a>
<a name="ln4786"> * smaller the number, the better the match.  This is the order of priorities,</a>
<a name="ln4787"> * from best match to worst match:</a>
<a name="ln4788"> *	- Match with least alpha-numeric characters is better.</a>
<a name="ln4789"> *	- Match with least total characters is better.</a>
<a name="ln4790"> *	- Match towards the start is better.</a>
<a name="ln4791"> *	- Match starting with &quot;+&quot; is worse (feature instead of command)</a>
<a name="ln4792"> * Assumption is made that the matched_string passed has already been found to</a>
<a name="ln4793"> * match some string for which help is requested.  webb.</a>
<a name="ln4794"> */</a>
<a name="ln4795">int</a>
<a name="ln4796">help_heuristic(</a>
<a name="ln4797">    char_u *matched_string,</a>
<a name="ln4798">    int offset,                             // offset for match</a>
<a name="ln4799">    int wrong_case                          // no matching case</a>
<a name="ln4800">)</a>
<a name="ln4801">{</a>
<a name="ln4802">  int num_letters;</a>
<a name="ln4803">  char_u      *p;</a>
<a name="ln4804"> </a>
<a name="ln4805">  num_letters = 0;</a>
<a name="ln4806">  for (p = matched_string; *p; p++)</a>
<a name="ln4807">    if (ASCII_ISALNUM(*p))</a>
<a name="ln4808">      num_letters++;</a>
<a name="ln4809"> </a>
<a name="ln4810">  /*</a>
<a name="ln4811">   * Multiply the number of letters by 100 to give it a much bigger</a>
<a name="ln4812">   * weighting than the number of characters.</a>
<a name="ln4813">   * If there only is a match while ignoring case, add 5000.</a>
<a name="ln4814">   * If the match starts in the middle of a word, add 10000 to put it</a>
<a name="ln4815">   * somewhere in the last half.</a>
<a name="ln4816">   * If the match is more than 2 chars from the start, multiply by 200 to</a>
<a name="ln4817">   * put it after matches at the start.</a>
<a name="ln4818">   */</a>
<a name="ln4819">  if (offset &gt; 0</a>
<a name="ln4820">      &amp;&amp; ASCII_ISALNUM(matched_string[offset])</a>
<a name="ln4821">      &amp;&amp; ASCII_ISALNUM(matched_string[offset - 1])) {</a>
<a name="ln4822">    offset += 10000;</a>
<a name="ln4823">  } else if (offset &gt; 2) {</a>
<a name="ln4824">    offset *= 200;</a>
<a name="ln4825">  }</a>
<a name="ln4826">  if (wrong_case) {</a>
<a name="ln4827">    offset += 5000;</a>
<a name="ln4828">  }</a>
<a name="ln4829">  // Features are less interesting than the subjects themselves, but &quot;+&quot;</a>
<a name="ln4830">  // alone is not a feature.</a>
<a name="ln4831">  if (matched_string[0] == '+' &amp;&amp; matched_string[1] != NUL) {</a>
<a name="ln4832">    offset += 100;</a>
<a name="ln4833">  }</a>
<a name="ln4834">  return (int)(100 * num_letters + STRLEN(matched_string) + offset);</a>
<a name="ln4835">}</a>
<a name="ln4836"> </a>
<a name="ln4837">/*</a>
<a name="ln4838"> * Compare functions for qsort() below, that checks the help heuristics number</a>
<a name="ln4839"> * that has been put after the tagname by find_tags().</a>
<a name="ln4840"> */</a>
<a name="ln4841">static int help_compare(const void *s1, const void *s2)</a>
<a name="ln4842">{</a>
<a name="ln4843">  char    *p1;</a>
<a name="ln4844">  char    *p2;</a>
<a name="ln4845"> </a>
<a name="ln4846">  p1 = *(char **)s1 + strlen(*(char **)s1) + 1;</a>
<a name="ln4847">  p2 = *(char **)s2 + strlen(*(char **)s2) + 1;</a>
<a name="ln4848">  return strcmp(p1, p2);</a>
<a name="ln4849">}</a>
<a name="ln4850"> </a>
<a name="ln4851">// Find all help tags matching &quot;arg&quot;, sort them and return in matches[], with</a>
<a name="ln4852">// the number of matches in num_matches.</a>
<a name="ln4853">// The matches will be sorted with a &quot;best&quot; match algorithm.</a>
<a name="ln4854">// When &quot;keep_lang&quot; is true try keeping the language of the current buffer.</a>
<a name="ln4855">int find_help_tags(const char_u *arg, int *num_matches, char_u ***matches,</a>
<a name="ln4856">                   bool keep_lang)</a>
<a name="ln4857">{</a>
<a name="ln4858">  int i;</a>
<a name="ln4859">  static const char *(mtable[]) = {</a>
<a name="ln4860">      &quot;*&quot;, &quot;g*&quot;, &quot;[*&quot;, &quot;]*&quot;,</a>
<a name="ln4861">      &quot;/*&quot;, &quot;/\\*&quot;, &quot;\&quot;*&quot;, &quot;**&quot;,</a>
<a name="ln4862">      &quot;/\\(\\)&quot;, &quot;/\\%(\\)&quot;,</a>
<a name="ln4863">      &quot;?&quot;, &quot;:?&quot;, &quot;?&lt;CR&gt;&quot;, &quot;g?&quot;, &quot;g?g?&quot;, &quot;g??&quot;,</a>
<a name="ln4864">      &quot;-?&quot;, &quot;q?&quot;, &quot;v_g?&quot;,</a>
<a name="ln4865">      &quot;/\\?&quot;, &quot;/\\z(\\)&quot;, &quot;\\=&quot;, &quot;:s\\=&quot;,</a>
<a name="ln4866">      &quot;[count]&quot;, &quot;[quotex]&quot;,</a>
<a name="ln4867">      &quot;[range]&quot;, &quot;:[range]&quot;,</a>
<a name="ln4868">      &quot;[pattern]&quot;, &quot;\\|&quot;, &quot;\\%$&quot;,</a>
<a name="ln4869">      &quot;s/\\~&quot;, &quot;s/\\U&quot;, &quot;s/\\L&quot;,</a>
<a name="ln4870">      &quot;s/\\1&quot;, &quot;s/\\2&quot;, &quot;s/\\3&quot;, &quot;s/\\9&quot;</a>
<a name="ln4871">  };</a>
<a name="ln4872">  static const char *(rtable[]) = {</a>
<a name="ln4873">      &quot;star&quot;, &quot;gstar&quot;, &quot;[star&quot;, &quot;]star&quot;,</a>
<a name="ln4874">      &quot;/star&quot;, &quot;/\\\\star&quot;, &quot;quotestar&quot;, &quot;starstar&quot;,</a>
<a name="ln4875">      &quot;/\\\\(\\\\)&quot;, &quot;/\\\\%(\\\\)&quot;,</a>
<a name="ln4876">      &quot;?&quot;, &quot;:?&quot;, &quot;?&lt;CR&gt;&quot;, &quot;g?&quot;, &quot;g?g?&quot;, &quot;g??&quot;,</a>
<a name="ln4877">      &quot;-?&quot;, &quot;q?&quot;, &quot;v_g?&quot;,</a>
<a name="ln4878">      &quot;/\\\\?&quot;, &quot;/\\\\z(\\\\)&quot;, &quot;\\\\=&quot;, &quot;:s\\\\=&quot;,</a>
<a name="ln4879">      &quot;\\[count]&quot;, &quot;\\[quotex]&quot;,</a>
<a name="ln4880">      &quot;\\[range]&quot;, &quot;:\\[range]&quot;,</a>
<a name="ln4881">      &quot;\\[pattern]&quot;, &quot;\\\\bar&quot;, &quot;/\\\\%\\$&quot;,</a>
<a name="ln4882">      &quot;s/\\\\\\~&quot;, &quot;s/\\\\U&quot;, &quot;s/\\\\L&quot;,</a>
<a name="ln4883">      &quot;s/\\\\1&quot;, &quot;s/\\\\2&quot;, &quot;s/\\\\3&quot;, &quot;s/\\\\9&quot;</a>
<a name="ln4884">  };</a>
<a name="ln4885">  static const char *(expr_table[]) = {</a>
<a name="ln4886">      &quot;!=?&quot;, &quot;!~?&quot;, &quot;&lt;=?&quot;, &quot;&lt;?&quot;, &quot;==?&quot;, &quot;=~?&quot;,</a>
<a name="ln4887">      &quot;&gt;=?&quot;, &quot;&gt;?&quot;, &quot;is?&quot;, &quot;isnot?&quot;</a>
<a name="ln4888">  };</a>
<a name="ln4889">  char_u *d = IObuff;       // assume IObuff is long enough!</a>
<a name="ln4890"> </a>
<a name="ln4891">  if (STRNICMP(arg, &quot;expr-&quot;, 5) == 0) {</a>
<a name="ln4892">    // When the string starting with &quot;expr-&quot; and containing '?' and matches</a>
<a name="ln4893">    // the table, it is taken literally (but ~ is escaped).  Otherwise '?'</a>
<a name="ln4894">    // is recognized as a wildcard.</a>
<a name="ln4895">    for (i = (int)ARRAY_SIZE(expr_table); --i &gt;= 0; ) {</a>
<a name="ln4896">      if (STRCMP(arg + 5, expr_table[i]) == 0) {</a>
<a name="ln4897">        for (int si = 0, di = 0; ; si++) {</a>
<a name="ln4898">          if (arg[si] == '~') {</a>
<a name="ln4899">            d[di++] = '\\';</a>
<a name="ln4900">          }</a>
<a name="ln4901">          d[di++] = arg[si];</a>
<a name="ln4902">          if (arg[si] == NUL) {</a>
<a name="ln4903">            break;</a>
<a name="ln4904">          }</a>
<a name="ln4905">        }</a>
<a name="ln4906">        break;</a>
<a name="ln4907">      }</a>
<a name="ln4908">    }</a>
<a name="ln4909">  } else {</a>
<a name="ln4910">    // Recognize a few exceptions to the rule.  Some strings that contain</a>
<a name="ln4911">    // '*' with &quot;star&quot;.  Otherwise '*' is recognized as a wildcard.</a>
<a name="ln4912">    for (i = (int)ARRAY_SIZE(mtable); --i &gt;= 0; ) {</a>
<a name="ln4913">      if (STRCMP(arg, mtable[i]) == 0) {</a>
<a name="ln4914">        STRCPY(d, rtable[i]);</a>
<a name="ln4915">        break;</a>
<a name="ln4916">      }</a>
<a name="ln4917">    }</a>
<a name="ln4918">  }</a>
<a name="ln4919"> </a>
<a name="ln4920">  if (i &lt; 0) {  /* no match in table */</a>
<a name="ln4921">    /* Replace &quot;\S&quot; with &quot;/\\S&quot;, etc.  Otherwise every tag is matched.</a>
<a name="ln4922">     * Also replace &quot;\%^&quot; and &quot;\%(&quot;, they match every tag too.</a>
<a name="ln4923">     * Also &quot;\zs&quot;, &quot;\z1&quot;, etc.</a>
<a name="ln4924">     * Also &quot;\@&lt;&quot;, &quot;\@=&quot;, &quot;\@&lt;=&quot;, etc.</a>
<a name="ln4925">     * And also &quot;\_$&quot; and &quot;\_^&quot;. */</a>
<a name="ln4926">    if (arg[0] == '\\'</a>
<a name="ln4927">        &amp;&amp; ((arg[1] != NUL &amp;&amp; arg[2] == NUL)</a>
<a name="ln4928">            || (vim_strchr((char_u *)&quot;%_z@&quot;, arg[1]) != NULL</a>
<a name="ln4929">                &amp;&amp; arg[2] != NUL))) {</a>
<a name="ln4930">      STRCPY(d, &quot;/\\\\&quot;);</a>
<a name="ln4931">      STRCPY(d + 3, arg + 1);</a>
<a name="ln4932">      /* Check for &quot;/\\_$&quot;, should be &quot;/\\_\$&quot; */</a>
<a name="ln4933">      if (d[3] == '_' &amp;&amp; d[4] == '$')</a>
<a name="ln4934">        STRCPY(d + 4, &quot;\\$&quot;);</a>
<a name="ln4935">    } else {</a>
<a name="ln4936">      /* Replace:</a>
<a name="ln4937">       * &quot;[:...:]&quot; with &quot;\[:...:]&quot;</a>
<a name="ln4938">       * &quot;[++...]&quot; with &quot;\[++...]&quot;</a>
<a name="ln4939">       * &quot;\{&quot; with &quot;\\{&quot;               -- matching &quot;} \}&quot;</a>
<a name="ln4940">       */</a>
<a name="ln4941">      if ((arg[0] == '[' &amp;&amp; (arg[1] == ':'</a>
<a name="ln4942">                             || (arg[1] == '+' &amp;&amp; arg[2] == '+')))</a>
<a name="ln4943">          || (arg[0] == '\\' &amp;&amp; arg[1] == '{'))</a>
<a name="ln4944">        *d++ = '\\';</a>
<a name="ln4945"> </a>
<a name="ln4946">      // If tag starts with &quot;('&quot;, skip the &quot;(&quot;. Fixes CTRL-] on ('option'.</a>
<a name="ln4947">      if (*arg == '(' &amp;&amp; arg[1] == '\'') {</a>
<a name="ln4948">          arg++;</a>
<a name="ln4949">      }</a>
<a name="ln4950">      for (const char_u *s = arg; *s; s++) {</a>
<a name="ln4951">        // Replace &quot;|&quot; with &quot;bar&quot; and '&quot;' with &quot;quote&quot; to match the name of</a>
<a name="ln4952">        // the tags for these commands.</a>
<a name="ln4953">        // Replace &quot;*&quot; with &quot;.*&quot; and &quot;?&quot; with &quot;.&quot; to match command line</a>
<a name="ln4954">        // completion.</a>
<a name="ln4955">        // Insert a backslash before '~', '$' and '.' to avoid their</a>
<a name="ln4956">        // special meaning.</a>
<a name="ln4957">        if (d - IObuff &gt; IOSIZE - 10) {           // getting too long!?</a>
<a name="ln4958">          break;</a>
<a name="ln4959">        }</a>
<a name="ln4960">        switch (*s) {</a>
<a name="ln4961">        case '|':   STRCPY(d, &quot;bar&quot;);</a>
<a name="ln4962">          d += 3;</a>
<a name="ln4963">          continue;</a>
<a name="ln4964">        case '&quot;':   STRCPY(d, &quot;quote&quot;);</a>
<a name="ln4965">          d += 5;</a>
<a name="ln4966">          continue;</a>
<a name="ln4967">        case '*':   *d++ = '.';</a>
<a name="ln4968">          break;</a>
<a name="ln4969">        case '?':   *d++ = '.';</a>
<a name="ln4970">          continue;</a>
<a name="ln4971">        case '$':</a>
<a name="ln4972">        case '.':</a>
<a name="ln4973">        case '~':   *d++ = '\\';</a>
<a name="ln4974">          break;</a>
<a name="ln4975">        }</a>
<a name="ln4976"> </a>
<a name="ln4977">        /*</a>
<a name="ln4978">         * Replace &quot;^x&quot; by &quot;CTRL-X&quot;. Don't do this for &quot;^_&quot; to make</a>
<a name="ln4979">         * &quot;:help i_^_CTRL-D&quot; work.</a>
<a name="ln4980">         * Insert '-' before and after &quot;CTRL-X&quot; when applicable.</a>
<a name="ln4981">         */</a>
<a name="ln4982">        if (*s &lt; ' ' || (*s == '^' &amp;&amp; s[1] &amp;&amp; (ASCII_ISALPHA(s[1])</a>
<a name="ln4983">                                               || vim_strchr((char_u *)</a>
<a name="ln4984">                                                   &quot;?@[\\]^&quot;,</a>
<a name="ln4985">                                                   s[1]) != NULL))) {</a>
<a name="ln4986">          if (d &gt; IObuff &amp;&amp; d[-1] != '_' &amp;&amp; d[-1] != '\\')</a>
<a name="ln4987">            *d++ = '_';                 /* prepend a '_' to make x_CTRL-x */</a>
<a name="ln4988">          STRCPY(d, &quot;CTRL-&quot;);</a>
<a name="ln4989">          d += 5;</a>
<a name="ln4990">          if (*s &lt; ' ') {</a>
<a name="ln4991">            *d++ = *s + '@';</a>
<a name="ln4992">            if (d[-1] == '\\')</a>
<a name="ln4993">              *d++ = '\\';              /* double a backslash */</a>
<a name="ln4994">          } else</a>
<a name="ln4995">            *d++ = *++s;</a>
<a name="ln4996">          if (s[1] != NUL &amp;&amp; s[1] != '_')</a>
<a name="ln4997">            *d++ = '_';                 /* append a '_' */</a>
<a name="ln4998">          continue;</a>
<a name="ln4999">        } else if (*s == '^')           /* &quot;^&quot; or &quot;CTRL-^&quot; or &quot;^_&quot; */</a>
<a name="ln5000">          *d++ = '\\';</a>
<a name="ln5001"> </a>
<a name="ln5002">        /*</a>
<a name="ln5003">         * Insert a backslash before a backslash after a slash, for search</a>
<a name="ln5004">         * pattern tags: &quot;/\|&quot; --&gt; &quot;/\\|&quot;.</a>
<a name="ln5005">         */</a>
<a name="ln5006">        else if (s[0] == '\\' &amp;&amp; s[1] != '\\'</a>
<a name="ln5007">                 &amp;&amp; *arg == '/' &amp;&amp; s == arg + 1)</a>
<a name="ln5008">          *d++ = '\\';</a>
<a name="ln5009"> </a>
<a name="ln5010">        /* &quot;CTRL-\_&quot; -&gt; &quot;CTRL-\\_&quot; to avoid the special meaning of &quot;\_&quot; in</a>
<a name="ln5011">         * &quot;CTRL-\_CTRL-N&quot; */</a>
<a name="ln5012">        if (STRNICMP(s, &quot;CTRL-\\_&quot;, 7) == 0) {</a>
<a name="ln5013">          STRCPY(d, &quot;CTRL-\\\\&quot;);</a>
<a name="ln5014">          d += 7;</a>
<a name="ln5015">          s += 6;</a>
<a name="ln5016">        }</a>
<a name="ln5017"> </a>
<a name="ln5018">        *d++ = *s;</a>
<a name="ln5019"> </a>
<a name="ln5020">        // If tag contains &quot;({&quot; or &quot;([&quot;, tag terminates at the &quot;(&quot;.</a>
<a name="ln5021">        // This is for help on functions, e.g.: abs({expr}).</a>
<a name="ln5022">        if (*s == '(' &amp;&amp; (s[1] == '{' || s[1] =='[')) {</a>
<a name="ln5023">          break;</a>
<a name="ln5024">        }</a>
<a name="ln5025"> </a>
<a name="ln5026">        // If tag starts with ', toss everything after a second '. Fixes</a>
<a name="ln5027">        // CTRL-] on 'option'. (would include the trailing '.').</a>
<a name="ln5028">        if (*s == '\'' &amp;&amp; s &gt; arg &amp;&amp; *arg == '\'') {</a>
<a name="ln5029">          break;</a>
<a name="ln5030">        }</a>
<a name="ln5031">        // Also '{' and '}'. Fixes CTRL-] on '{address}'.</a>
<a name="ln5032">        if (*s == '}' &amp;&amp; s &gt; arg &amp;&amp; *arg == '{') {</a>
<a name="ln5033">          break;</a>
<a name="ln5034">        }</a>
<a name="ln5035">      }</a>
<a name="ln5036">      *d = NUL;</a>
<a name="ln5037"> </a>
<a name="ln5038">      if (*IObuff == '`') {</a>
<a name="ln5039">        if (d &gt; IObuff + 2 &amp;&amp; d[-1] == '`') {</a>
<a name="ln5040">          /* remove the backticks from `command` */</a>
<a name="ln5041">          memmove(IObuff, IObuff + 1, STRLEN(IObuff));</a>
<a name="ln5042">          d[-2] = NUL;</a>
<a name="ln5043">        } else if (d &gt; IObuff + 3 &amp;&amp; d[-2] == '`' &amp;&amp; d[-1] == ',') {</a>
<a name="ln5044">          /* remove the backticks and comma from `command`, */</a>
<a name="ln5045">          memmove(IObuff, IObuff + 1, STRLEN(IObuff));</a>
<a name="ln5046">          d[-3] = NUL;</a>
<a name="ln5047">        } else if (d &gt; IObuff + 4 &amp;&amp; d[-3] == '`'</a>
<a name="ln5048">                   &amp;&amp; d[-2] == '\\' &amp;&amp; d[-1] == '.') {</a>
<a name="ln5049">          /* remove the backticks and dot from `command`\. */</a>
<a name="ln5050">          memmove(IObuff, IObuff + 1, STRLEN(IObuff));</a>
<a name="ln5051">          d[-4] = NUL;</a>
<a name="ln5052">        }</a>
<a name="ln5053">      }</a>
<a name="ln5054">    }</a>
<a name="ln5055">  }</a>
<a name="ln5056"> </a>
<a name="ln5057">  *matches = NULL;</a>
<a name="ln5058">  *num_matches = 0;</a>
<a name="ln5059">  int flags = TAG_HELP | TAG_REGEXP | TAG_NAMES | TAG_VERBOSE | TAG_NO_TAGFUNC;</a>
<a name="ln5060">  if (keep_lang) {</a>
<a name="ln5061">    flags |= TAG_KEEP_LANG;</a>
<a name="ln5062">  }</a>
<a name="ln5063">  if (find_tags(IObuff, num_matches, matches, flags, MAXCOL, NULL) == OK</a>
<a name="ln5064">      &amp;&amp; *num_matches &gt; 0) {</a>
<a name="ln5065">    /* Sort the matches found on the heuristic number that is after the</a>
<a name="ln5066">     * tag name. */</a>
<a name="ln5067">    qsort((void *)*matches, (size_t)*num_matches,</a>
<a name="ln5068">        sizeof(char_u *), help_compare);</a>
<a name="ln5069">    /* Delete more than TAG_MANY to reduce the size of the listing. */</a>
<a name="ln5070">    while (*num_matches &gt; TAG_MANY)</a>
<a name="ln5071">      xfree((*matches)[--*num_matches]);</a>
<a name="ln5072">  }</a>
<a name="ln5073">  return OK;</a>
<a name="ln5074">}</a>
<a name="ln5075"> </a>
<a name="ln5076">/// Called when starting to edit a buffer for a help file.</a>
<a name="ln5077">static void prepare_help_buffer(void)</a>
<a name="ln5078">{</a>
<a name="ln5079">  curbuf-&gt;b_help = true;</a>
<a name="ln5080">  set_string_option_direct(&quot;buftype&quot;, -1, (char_u *)&quot;help&quot;,</a>
<a name="ln5081">                           OPT_FREE|OPT_LOCAL, 0);</a>
<a name="ln5082"> </a>
<a name="ln5083">  // Always set these options after jumping to a help tag, because the</a>
<a name="ln5084">  // user may have an autocommand that gets in the way.</a>
<a name="ln5085">  // Accept all ASCII chars for keywords, except ' ', '*', '&quot;', '|', and</a>
<a name="ln5086">  // latin1 word characters (for translated help files).</a>
<a name="ln5087">  // Only set it when needed, buf_init_chartab() is some work.</a>
<a name="ln5088">  char_u *p = (char_u *)&quot;!-~,^*,^|,^\&quot;,192-255&quot;;</a>
<a name="ln5089">  if (STRCMP(curbuf-&gt;b_p_isk, p) != 0) {</a>
<a name="ln5090">    set_string_option_direct(&quot;isk&quot;, -1, p, OPT_FREE|OPT_LOCAL, 0);</a>
<a name="ln5091">    check_buf_options(curbuf);</a>
<a name="ln5092">    (void)buf_init_chartab(curbuf, FALSE);</a>
<a name="ln5093">  }</a>
<a name="ln5094"> </a>
<a name="ln5095">  // Don't use the global foldmethod.</a>
<a name="ln5096">  set_string_option_direct(&quot;fdm&quot;, -1, (char_u *)&quot;manual&quot;,</a>
<a name="ln5097">                           OPT_FREE|OPT_LOCAL, 0);</a>
<a name="ln5098"> </a>
<a name="ln5099">  curbuf-&gt;b_p_ts = 8;         // 'tabstop' is 8.</a>
<a name="ln5100">  curwin-&gt;w_p_list = FALSE;   // No list mode.</a>
<a name="ln5101"> </a>
<a name="ln5102">  curbuf-&gt;b_p_ma = FALSE;     // Not modifiable.</a>
<a name="ln5103">  curbuf-&gt;b_p_bin = FALSE;    // Reset 'bin' before reading file.</a>
<a name="ln5104">  curwin-&gt;w_p_nu = 0;         // No line numbers.</a>
<a name="ln5105">  curwin-&gt;w_p_rnu = 0;        // No relative line numbers.</a>
<a name="ln5106">  RESET_BINDING(curwin);      // No scroll or cursor binding.</a>
<a name="ln5107">  curwin-&gt;w_p_arab = FALSE;   // No arabic mode.</a>
<a name="ln5108">  curwin-&gt;w_p_rl  = FALSE;    // Help window is left-to-right.</a>
<a name="ln5109">  curwin-&gt;w_p_fen = FALSE;    // No folding in the help window.</a>
<a name="ln5110">  curwin-&gt;w_p_diff = FALSE;   // No 'diff'.</a>
<a name="ln5111">  curwin-&gt;w_p_spell = FALSE;  // No spell checking.</a>
<a name="ln5112"> </a>
<a name="ln5113">  set_buflisted(FALSE);</a>
<a name="ln5114">}</a>
<a name="ln5115"> </a>
<a name="ln5116">/*</a>
<a name="ln5117"> * After reading a help file: May cleanup a help buffer when syntax</a>
<a name="ln5118"> * highlighting is not used.</a>
<a name="ln5119"> */</a>
<a name="ln5120">void fix_help_buffer(void)</a>
<a name="ln5121">{</a>
<a name="ln5122">  linenr_T lnum;</a>
<a name="ln5123">  char_u      *line;</a>
<a name="ln5124">  bool in_example = false;</a>
<a name="ln5125"> </a>
<a name="ln5126">  // Set filetype to &quot;help&quot;.</a>
<a name="ln5127">  if (STRCMP(curbuf-&gt;b_p_ft, &quot;help&quot;) != 0) {</a>
<a name="ln5128">    curbuf_lock++;</a>
<a name="ln5129">    set_option_value(&quot;ft&quot;, 0L, &quot;help&quot;, OPT_LOCAL);</a>
<a name="ln5130">    curbuf_lock--;</a>
<a name="ln5131">  }</a>
<a name="ln5132"> </a>
<a name="ln5133">  if (!syntax_present(curwin)) {</a>
<a name="ln5134">    for (lnum = 1; lnum &lt;= curbuf-&gt;b_ml.ml_line_count; lnum++) {</a>
<a name="ln5135">      line = ml_get_buf(curbuf, lnum, false);</a>
<a name="ln5136">      const size_t len = STRLEN(line);</a>
<a name="ln5137">      if (in_example &amp;&amp; len &gt; 0 &amp;&amp; !ascii_iswhite(line[0])) {</a>
<a name="ln5138">        /* End of example: non-white or '&lt;' in first column. */</a>
<a name="ln5139">        if (line[0] == '&lt;') {</a>
<a name="ln5140">          /* blank-out a '&lt;' in the first column */</a>
<a name="ln5141">          line = ml_get_buf(curbuf, lnum, TRUE);</a>
<a name="ln5142">          line[0] = ' ';</a>
<a name="ln5143">        }</a>
<a name="ln5144">        in_example = false;</a>
<a name="ln5145">      }</a>
<a name="ln5146">      if (!in_example &amp;&amp; len &gt; 0) {</a>
<a name="ln5147">        if (line[len - 1] == '&gt;' &amp;&amp; (len == 1 || line[len - 2] == ' ')) {</a>
<a name="ln5148">          /* blank-out a '&gt;' in the last column (start of example) */</a>
<a name="ln5149">          line = ml_get_buf(curbuf, lnum, TRUE);</a>
<a name="ln5150">          line[len - 1] = ' ';</a>
<a name="ln5151">          in_example = true;</a>
<a name="ln5152">        } else if (line[len - 1] == '~') {</a>
<a name="ln5153">          /* blank-out a '~' at the end of line (header marker) */</a>
<a name="ln5154">          line = ml_get_buf(curbuf, lnum, TRUE);</a>
<a name="ln5155">          line[len - 1] = ' ';</a>
<a name="ln5156">        }</a>
<a name="ln5157">      }</a>
<a name="ln5158">    }</a>
<a name="ln5159">  }</a>
<a name="ln5160"> </a>
<a name="ln5161">  /*</a>
<a name="ln5162">   * In the &quot;help.txt&quot; and &quot;help.abx&quot; file, add the locally added help</a>
<a name="ln5163">   * files.  This uses the very first line in the help file.</a>
<a name="ln5164">   */</a>
<a name="ln5165">  char_u *const fname = path_tail(curbuf-&gt;b_fname);</a>
<a name="ln5166">  if (fnamecmp(fname, &quot;help.txt&quot;) == 0</a>
<a name="ln5167">      || (fnamencmp(fname, &quot;help.&quot;, 5) == 0</a>
<a name="ln5168">          &amp;&amp; ASCII_ISALPHA(fname[5])</a>
<a name="ln5169">          &amp;&amp; ASCII_ISALPHA(fname[6])</a>
<a name="ln5170">          &amp;&amp; TOLOWER_ASC(fname[7]) == 'x'</a>
<a name="ln5171">          &amp;&amp; fname[8] == NUL)</a>
<a name="ln5172">      ) {</a>
<a name="ln5173">    for (lnum = 1; lnum &lt; curbuf-&gt;b_ml.ml_line_count; ++lnum) {</a>
<a name="ln5174">      line = ml_get_buf(curbuf, lnum, FALSE);</a>
<a name="ln5175">      if (strstr((char *)line, &quot;*local-additions*&quot;) == NULL)</a>
<a name="ln5176">        continue;</a>
<a name="ln5177"> </a>
<a name="ln5178">      /* Go through all directories in 'runtimepath', skipping</a>
<a name="ln5179">       * $VIMRUNTIME. */</a>
<a name="ln5180">      char_u *p = p_rtp;</a>
<a name="ln5181">      while (*p != NUL) {</a>
<a name="ln5182">        copy_option_part(&amp;p, NameBuff, MAXPATHL, &quot;,&quot;);</a>
<a name="ln5183">        char_u *const rt = (char_u *)vim_getenv(&quot;VIMRUNTIME&quot;);</a>
<a name="ln5184">        if (rt != NULL</a>
<a name="ln5185">            &amp;&amp; path_full_compare(rt, NameBuff, false, true) != kEqualFiles) {</a>
<a name="ln5186">          int fcount;</a>
<a name="ln5187">          char_u      **fnames;</a>
<a name="ln5188">          char_u      *s;</a>
<a name="ln5189">          vimconv_T vc;</a>
<a name="ln5190">          char_u      *cp;</a>
<a name="ln5191"> </a>
<a name="ln5192">          // Find all &quot;doc/ *.txt&quot; files in this directory.</a>
<a name="ln5193">          if (!add_pathsep((char *)NameBuff)</a>
<a name="ln5194">              || STRLCAT(NameBuff, &quot;doc/*.??[tx]&quot;,</a>
<a name="ln5195">                         sizeof(NameBuff)) &gt;= MAXPATHL) {</a>
<a name="ln5196">            EMSG(_(e_fnametoolong));</a>
<a name="ln5197">            continue;</a>
<a name="ln5198">          }</a>
<a name="ln5199"> </a>
<a name="ln5200">          // Note: We cannot just do `&amp;NameBuff` because it is a statically sized array</a>
<a name="ln5201">          //       so `NameBuff == &amp;NameBuff` according to C semantics.</a>
<a name="ln5202">          char_u *buff_list[1] = {NameBuff};</a>
<a name="ln5203">          if (gen_expand_wildcards(1, buff_list, &amp;fcount,</a>
<a name="ln5204">                  &amp;fnames, EW_FILE|EW_SILENT) == OK</a>
<a name="ln5205">              &amp;&amp; fcount &gt; 0) {</a>
<a name="ln5206">            // If foo.abx is found use it instead of foo.txt in</a>
<a name="ln5207">            // the same directory.</a>
<a name="ln5208">            for (int i1 = 0; i1 &lt; fcount; i1++) {</a>
<a name="ln5209">              for (int i2 = 0; i2 &lt; fcount; i2++) {</a>
<a name="ln5210">                if (i1 == i2) {</a>
<a name="ln5211">                  continue;</a>
<a name="ln5212">                }</a>
<a name="ln5213">                if (fnames[i1] == NULL || fnames[i2] == NULL) {</a>
<a name="ln5214">                  continue;</a>
<a name="ln5215">                }</a>
<a name="ln5216">                const char_u *const f1 = fnames[i1];</a>
<a name="ln5217">                const char_u *const f2 = fnames[i2];</a>
<a name="ln5218">                const char_u *const t1 = path_tail(f1);</a>
<a name="ln5219">                const char_u *const t2 = path_tail(f2);</a>
<a name="ln5220">                const char_u *const e1 = STRRCHR(t1, '.');</a>
<a name="ln5221">                const char_u *const e2 = STRRCHR(t2, '.');</a>
<a name="ln5222">                if (e1 == NULL || e2 == NULL) {</a>
<a name="ln5223">                  continue;</a>
<a name="ln5224">                }</a>
<a name="ln5225">                if (fnamecmp(e1, &quot;.txt&quot;) != 0</a>
<a name="ln5226">                    &amp;&amp; fnamecmp(e1, fname + 4) != 0) {</a>
<a name="ln5227">                  // Not .txt and not .abx, remove it.</a>
<a name="ln5228">                  XFREE_CLEAR(fnames[i1]);</a>
<a name="ln5229">                  continue;</a>
<a name="ln5230">                }</a>
<a name="ln5231">                if (e1 - f1 != e2 - f2</a>
<a name="ln5232">                    || fnamencmp(f1, f2, e1 - f1) != 0) {</a>
<a name="ln5233">                  continue;</a>
<a name="ln5234">                }</a>
<a name="ln5235">                if (fnamecmp(e1, &quot;.txt&quot;) == 0</a>
<a name="ln5236">                    &amp;&amp; fnamecmp(e2, fname + 4) == 0) {</a>
<a name="ln5237">                  // use .abx instead of .txt</a>
<a name="ln5238">                  XFREE_CLEAR(fnames[i1]);</a>
<a name="ln5239">                }</a>
<a name="ln5240">              }</a>
<a name="ln5241">            }</a>
<a name="ln5242">            for (int fi = 0; fi &lt; fcount; fi++) {</a>
<a name="ln5243">              if (fnames[fi] == NULL) {</a>
<a name="ln5244">                continue;</a>
<a name="ln5245">              }</a>
<a name="ln5246"> </a>
<a name="ln5247">              FILE *const fd = os_fopen((char *)fnames[fi], &quot;r&quot;);</a>
<a name="ln5248">              if (fd == NULL) {</a>
<a name="ln5249">                continue;</a>
<a name="ln5250">              }</a>
<a name="ln5251">              vim_fgets(IObuff, IOSIZE, fd);</a>
<a name="ln5252">              if (IObuff[0] == '*'</a>
<a name="ln5253">                  &amp;&amp; (s = vim_strchr(IObuff + 1, '*'))</a>
<a name="ln5254">                  != NULL) {</a>
<a name="ln5255">                TriState this_utf = kNone;</a>
<a name="ln5256">                // Change tag definition to a</a>
<a name="ln5257">                // reference and remove &lt;CR&gt;/&lt;NL&gt;.</a>
<a name="ln5258">                IObuff[0] = '|';</a>
<a name="ln5259">                *s = '|';</a>
<a name="ln5260">                while (*s != NUL) {</a>
<a name="ln5261">                  if (*s == '\r' || *s == '\n')</a>
<a name="ln5262">                    *s = NUL;</a>
<a name="ln5263">                  /* The text is utf-8 when a byte</a>
<a name="ln5264">                   * above 127 is found and no</a>
<a name="ln5265">                   * illegal byte sequence is found.</a>
<a name="ln5266">                   */</a>
<a name="ln5267">                  if (*s &gt;= 0x80 &amp;&amp; this_utf != kFalse) {</a>
<a name="ln5268">                    this_utf = kTrue;</a>
<a name="ln5269">                    const int l = utf_ptr2len(s);</a>
<a name="ln5270">                    if (l == 1) {</a>
<a name="ln5271">                      this_utf = kFalse;</a>
<a name="ln5272">                    }</a>
<a name="ln5273">                    s += l - 1;</a>
<a name="ln5274">                  }</a>
<a name="ln5275">                  ++s;</a>
<a name="ln5276">                }</a>
<a name="ln5277">                /* The help file is latin1 or utf-8;</a>
<a name="ln5278">                 * conversion to the current</a>
<a name="ln5279">                 * 'encoding' may be required. */</a>
<a name="ln5280">                vc.vc_type = CONV_NONE;</a>
<a name="ln5281">                convert_setup(</a>
<a name="ln5282">                    &amp;vc,</a>
<a name="ln5283">                    (char_u *)(this_utf == kTrue ? &quot;utf-8&quot; : &quot;latin1&quot;),</a>
<a name="ln5284">                    p_enc);</a>
<a name="ln5285">                if (vc.vc_type == CONV_NONE) {</a>
<a name="ln5286">                  // No conversion needed.</a>
<a name="ln5287">                  cp = IObuff;</a>
<a name="ln5288">                } else {</a>
<a name="ln5289">                  // Do the conversion.  If it fails</a>
<a name="ln5290">                  // use the unconverted text.</a>
<a name="ln5291">                  cp = string_convert(&amp;vc, IObuff, NULL);</a>
<a name="ln5292">                  if (cp == NULL) {</a>
<a name="ln5293">                    cp = IObuff;</a>
<a name="ln5294">                  }</a>
<a name="ln5295">                }</a>
<a name="ln5296">                convert_setup(&amp;vc, NULL, NULL);</a>
<a name="ln5297"> </a>
<a name="ln5298">                ml_append(lnum, cp, (colnr_T)0, false);</a>
<a name="ln5299">                if (cp != IObuff) {</a>
<a name="ln5300">                  xfree(cp);</a>
<a name="ln5301">                }</a>
<a name="ln5302">                lnum++;</a>
<a name="ln5303">              }</a>
<a name="ln5304">              fclose(fd);</a>
<a name="ln5305">            }</a>
<a name="ln5306">            FreeWild(fcount, fnames);</a>
<a name="ln5307">          }</a>
<a name="ln5308">        }</a>
<a name="ln5309">        xfree(rt);</a>
<a name="ln5310">      }</a>
<a name="ln5311">      break;</a>
<a name="ln5312">    }</a>
<a name="ln5313">  }</a>
<a name="ln5314">}</a>
<a name="ln5315"> </a>
<a name="ln5316">/*</a>
<a name="ln5317"> * &quot;:exusage&quot;</a>
<a name="ln5318"> */</a>
<a name="ln5319">void ex_exusage(exarg_T *eap)</a>
<a name="ln5320">{</a>
<a name="ln5321">  do_cmdline_cmd(&quot;help ex-cmd-index&quot;);</a>
<a name="ln5322">}</a>
<a name="ln5323"> </a>
<a name="ln5324">/*</a>
<a name="ln5325"> * &quot;:viusage&quot;</a>
<a name="ln5326"> */</a>
<a name="ln5327">void ex_viusage(exarg_T *eap)</a>
<a name="ln5328">{</a>
<a name="ln5329">  do_cmdline_cmd(&quot;help normal-index&quot;);</a>
<a name="ln5330">}</a>
<a name="ln5331"> </a>
<a name="ln5332"> </a>
<a name="ln5333">/// Generate tags in one help directory</a>
<a name="ln5334">///</a>
<a name="ln5335">/// @param dir  Path to the doc directory</a>
<a name="ln5336">/// @param ext  Suffix of the help files (&quot;.txt&quot;, &quot;.itx&quot;, &quot;.frx&quot;, etc.)</a>
<a name="ln5337">/// @param tagname  Name of the tags file (&quot;tags&quot; for English, &quot;tags-fr&quot; for</a>
<a name="ln5338">///                 French)</a>
<a name="ln5339">/// @param add_help_tags  Whether to add the &quot;help-tags&quot; tag</a>
<a name="ln5340">/// @param ignore_writeerr  ignore write error</a>
<a name="ln5341">static void helptags_one(char_u *dir, const char_u *ext, const char_u *tagfname,</a>
<a name="ln5342">                         bool add_help_tags, bool ignore_writeerr)</a>
<a name="ln5343">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5344">{</a>
<a name="ln5345">  garray_T ga;</a>
<a name="ln5346">  int filecount;</a>
<a name="ln5347">  char_u      **files;</a>
<a name="ln5348">  char_u      *p1, *p2;</a>
<a name="ln5349">  char_u      *s;</a>
<a name="ln5350">  TriState utf8 = kNone;</a>
<a name="ln5351">  bool mix = false;             // detected mixed encodings</a>
<a name="ln5352"> </a>
<a name="ln5353">  // Find all *.txt files.</a>
<a name="ln5354">  size_t dirlen = STRLCPY(NameBuff, dir, sizeof(NameBuff));</a>
<a name="ln5355">  if (dirlen &gt;= MAXPATHL</a>
<a name="ln5356">      || STRLCAT(NameBuff, &quot;/**/*&quot;, sizeof(NameBuff)) &gt;= MAXPATHL  // NOLINT</a>
<a name="ln5357">      || STRLCAT(NameBuff, ext, sizeof(NameBuff)) &gt;= MAXPATHL) {</a>
<a name="ln5358">    EMSG(_(e_fnametoolong));</a>
<a name="ln5359">    return;</a>
<a name="ln5360">  }</a>
<a name="ln5361"> </a>
<a name="ln5362">  // Note: We cannot just do `&amp;NameBuff` because it is a statically sized array</a>
<a name="ln5363">  //       so `NameBuff == &amp;NameBuff` according to C semantics.</a>
<a name="ln5364">  char_u *buff_list[1] = {NameBuff};</a>
<a name="ln5365">  if (gen_expand_wildcards(1, buff_list, &amp;filecount, &amp;files,</a>
<a name="ln5366">          EW_FILE|EW_SILENT) == FAIL</a>
<a name="ln5367">      || filecount == 0) {</a>
<a name="ln5368">    if (!got_int) {</a>
<a name="ln5369">      EMSG2(_(&quot;E151: No match: %s&quot;), NameBuff);</a>
<a name="ln5370">    }</a>
<a name="ln5371">    return;</a>
<a name="ln5372">  }</a>
<a name="ln5373"> </a>
<a name="ln5374">  //</a>
<a name="ln5375">  // Open the tags file for writing.</a>
<a name="ln5376">  // Do this before scanning through all the files.</a>
<a name="ln5377">  //</a>
<a name="ln5378">  memcpy(NameBuff, dir, dirlen + 1);</a>
<a name="ln5379">  if (!add_pathsep((char *)NameBuff)</a>
<a name="ln5380">      || STRLCAT(NameBuff, tagfname, sizeof(NameBuff)) &gt;= MAXPATHL) {</a>
<a name="ln5381">    EMSG(_(e_fnametoolong));</a>
<a name="ln5382">    return;</a>
<a name="ln5383">  }</a>
<a name="ln5384"> </a>
<a name="ln5385">  FILE *const fd_tags = os_fopen((char *)NameBuff, &quot;w&quot;);</a>
<a name="ln5386">  if (fd_tags == NULL) {</a>
<a name="ln5387">    if (!ignore_writeerr) {</a>
<a name="ln5388">      EMSG2(_(&quot;E152: Cannot open %s for writing&quot;), NameBuff);</a>
<a name="ln5389">    }</a>
<a name="ln5390">    FreeWild(filecount, files);</a>
<a name="ln5391">    return;</a>
<a name="ln5392">  }</a>
<a name="ln5393"> </a>
<a name="ln5394">  // If using the &quot;++t&quot; argument or generating tags for &quot;$VIMRUNTIME/doc&quot;</a>
<a name="ln5395">  // add the &quot;help-tags&quot; tag.</a>
<a name="ln5396">  ga_init(&amp;ga, (int)sizeof(char_u *), 100);</a>
<a name="ln5397">  if (add_help_tags</a>
<a name="ln5398">      || path_full_compare((char_u *)&quot;$VIMRUNTIME/doc&quot;,</a>
<a name="ln5399">                           dir, false, true) == kEqualFiles) {</a>
<a name="ln5400">    s = xmalloc(18 + STRLEN(tagfname));</a>
<a name="ln5401">    sprintf((char *)s, &quot;help-tags\t%s\t1\n&quot;, tagfname);</a>
<a name="ln5402">    GA_APPEND(char_u *, &amp;ga, s);</a>
<a name="ln5403">  }</a>
<a name="ln5404"> </a>
<a name="ln5405">  // Go over all the files and extract the tags.</a>
<a name="ln5406">  for (int fi = 0; fi &lt; filecount &amp;&amp; !got_int; fi++) {</a>
<a name="ln5407">    FILE *const fd = os_fopen((char *)files[fi], &quot;r&quot;);</a>
<a name="ln5408">    if (fd == NULL) {</a>
<a name="ln5409">      EMSG2(_(&quot;E153: Unable to open %s for reading&quot;), files[fi]);</a>
<a name="ln5410">      continue;</a>
<a name="ln5411">    }</a>
<a name="ln5412">    const char_u *const fname = files[fi] + dirlen + 1;</a>
<a name="ln5413"> </a>
<a name="ln5414">    bool firstline = true;</a>
<a name="ln5415">    while (!vim_fgets(IObuff, IOSIZE, fd) &amp;&amp; !got_int) {</a>
<a name="ln5416">      if (firstline) {</a>
<a name="ln5417">        // Detect utf-8 file by a non-ASCII char in the first line.</a>
<a name="ln5418">        TriState this_utf8 = kNone;</a>
<a name="ln5419">        for (s = IObuff; *s != NUL; s++) {</a>
<a name="ln5420">          if (*s &gt;= 0x80) {</a>
<a name="ln5421">            this_utf8 = kTrue;</a>
<a name="ln5422">            const int l = utf_ptr2len(s);</a>
<a name="ln5423">            if (l == 1) {</a>
<a name="ln5424">              // Illegal UTF-8 byte sequence.</a>
<a name="ln5425">              this_utf8 = kFalse;</a>
<a name="ln5426">              break;</a>
<a name="ln5427">            }</a>
<a name="ln5428">            s += l - 1;</a>
<a name="ln5429">          }</a>
<a name="ln5430">        }</a>
<a name="ln5431">        if (this_utf8 == kNone) {           // only ASCII characters found</a>
<a name="ln5432">          this_utf8 = kFalse;</a>
<a name="ln5433">        }</a>
<a name="ln5434">        if (utf8 == kNone) {                // first file</a>
<a name="ln5435">          utf8 = this_utf8;</a>
<a name="ln5436">        } else if (utf8 != this_utf8) {</a>
<a name="ln5437">          EMSG2(_(</a>
<a name="ln5438">                  &quot;E670: Mix of help file encodings within a language: %s&quot;),</a>
<a name="ln5439">              files[fi]);</a>
<a name="ln5440">          mix = !got_int;</a>
<a name="ln5441">          got_int = TRUE;</a>
<a name="ln5442">        }</a>
<a name="ln5443">        firstline = false;</a>
<a name="ln5444">      }</a>
<a name="ln5445">      p1 = vim_strchr(IObuff, '*');                        // find first '*'</a>
<a name="ln5446">      while (p1 != NULL) {</a>
<a name="ln5447">        p2 = (char_u *)strchr((const char *)p1 + 1, '*');  // Find second '*'.</a>
<a name="ln5448">        if (p2 != NULL &amp;&amp; p2 &gt; p1 + 1) {                   // Skip &quot;*&quot; and &quot;**&quot;.</a>
<a name="ln5449">          for (s = p1 + 1; s &lt; p2; s++) {</a>
<a name="ln5450">            if (*s == ' ' || *s == '\t' || *s == '|') {</a>
<a name="ln5451">              break;</a>
<a name="ln5452">            }</a>
<a name="ln5453">          }</a>
<a name="ln5454"> </a>
<a name="ln5455">          // Only accept a *tag* when it consists of valid</a>
<a name="ln5456">          // characters, there is white space before it and is</a>
<a name="ln5457">          // followed by a white character or end-of-line.</a>
<a name="ln5458">          if (s == p2</a>
<a name="ln5459">              &amp;&amp; (p1 == IObuff || p1[-1] == ' ' || p1[-1] == '\t')</a>
<a name="ln5460">              &amp;&amp; (vim_strchr((char_u *)&quot; \t\n\r&quot;, s[1]) != NULL</a>
<a name="ln5461">                  || s[1] == '\0')) {</a>
<a name="ln5462">            *p2 = '\0';</a>
<a name="ln5463">            ++p1;</a>
<a name="ln5464">            s = xmalloc((p2 - p1) + STRLEN(fname) + 2);</a>
<a name="ln5465">            GA_APPEND(char_u *, &amp;ga, s);</a>
<a name="ln5466">            sprintf((char *)s, &quot;%s\t%s&quot;, p1, fname);</a>
<a name="ln5467"> </a>
<a name="ln5468">            // find next '*'</a>
<a name="ln5469">            p2 = vim_strchr(p2 + 1, '*');</a>
<a name="ln5470">          }</a>
<a name="ln5471">        }</a>
<a name="ln5472">        p1 = p2;</a>
<a name="ln5473">      }</a>
<a name="ln5474">      line_breakcheck();</a>
<a name="ln5475">    }</a>
<a name="ln5476"> </a>
<a name="ln5477">    fclose(fd);</a>
<a name="ln5478">  }</a>
<a name="ln5479"> </a>
<a name="ln5480">  FreeWild(filecount, files);</a>
<a name="ln5481"> </a>
<a name="ln5482">  if (!got_int &amp;&amp; ga.ga_data != NULL) {</a>
<a name="ln5483">    // Sort the tags.</a>
<a name="ln5484">    sort_strings((char_u **)ga.ga_data, ga.ga_len);</a>
<a name="ln5485"> </a>
<a name="ln5486">    // Check for duplicates.</a>
<a name="ln5487">    for (int i = 1; i &lt; ga.ga_len; i++) {</a>
<a name="ln5488">      p1 = ((char_u **)ga.ga_data)[i - 1];</a>
<a name="ln5489">      p2 = ((char_u **)ga.ga_data)[i];</a>
<a name="ln5490">      while (*p1 == *p2) {</a>
<a name="ln5491">        if (*p2 == '\t') {</a>
<a name="ln5492">          *p2 = NUL;</a>
<a name="ln5493">          vim_snprintf((char *)NameBuff, MAXPATHL,</a>
<a name="ln5494">              _(&quot;E154: Duplicate tag \&quot;%s\&quot; in file %s/%s&quot;),</a>
<a name="ln5495">              ((char_u **)ga.ga_data)[i], dir, p2 + 1);</a>
<a name="ln5496">          EMSG(NameBuff);</a>
<a name="ln5497">          *p2 = '\t';</a>
<a name="ln5498">          break;</a>
<a name="ln5499">        }</a>
<a name="ln5500">        ++p1;</a>
<a name="ln5501">        ++p2;</a>
<a name="ln5502">      }</a>
<a name="ln5503">    }</a>
<a name="ln5504"> </a>
<a name="ln5505">    if (utf8 == kTrue) {</a>
<a name="ln5506">      fprintf(fd_tags, &quot;!_TAG_FILE_ENCODING\tutf-8\t//\n&quot;);</a>
<a name="ln5507">    }</a>
<a name="ln5508"> </a>
<a name="ln5509">    // Write the tags into the file.</a>
<a name="ln5510">    for (int i = 0; i &lt; ga.ga_len; i++) {</a>
<a name="ln5511">      s = ((char_u **)ga.ga_data)[i];</a>
<a name="ln5512">      if (STRNCMP(s, &quot;help-tags\t&quot;, 10) == 0) {</a>
<a name="ln5513">        // help-tags entry was added in formatted form</a>
<a name="ln5514">        fputs((char *)s, fd_tags);</a>
<a name="ln5515">      } else {</a>
<a name="ln5516">        fprintf(fd_tags, &quot;%s\t/&quot; &quot;*&quot;, s);</a>
<a name="ln5517">        for (p1 = s; *p1 != '\t'; p1++) {</a>
<a name="ln5518">          // insert backslash before '\\' and '/'</a>
<a name="ln5519">          if (*p1 == '\\' || *p1 == '/') {</a>
<a name="ln5520">            putc('\\', fd_tags);</a>
<a name="ln5521">          }</a>
<a name="ln5522">          putc(*p1, fd_tags);</a>
<a name="ln5523">        }</a>
<a name="ln5524">        fprintf(fd_tags, &quot;*\n&quot;);</a>
<a name="ln5525">      }</a>
<a name="ln5526">    }</a>
<a name="ln5527">  }</a>
<a name="ln5528">  if (mix) {</a>
<a name="ln5529">    got_int = false;        // continue with other languages</a>
<a name="ln5530">  }</a>
<a name="ln5531"> </a>
<a name="ln5532">  GA_DEEP_CLEAR_PTR(&amp;ga);</a>
<a name="ln5533">  fclose(fd_tags);          // there is no check for an error...</a>
<a name="ln5534">}</a>
<a name="ln5535"> </a>
<a name="ln5536">/// Generate tags in one help directory, taking care of translations.</a>
<a name="ln5537">static void do_helptags(char_u *dirname, bool add_help_tags,</a>
<a name="ln5538">                        bool ignore_writeerr)</a>
<a name="ln5539">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5540">{</a>
<a name="ln5541">  int len;</a>
<a name="ln5542">  garray_T ga;</a>
<a name="ln5543">  char_u lang[2];</a>
<a name="ln5544">  char_u ext[5];</a>
<a name="ln5545">  char_u fname[8];</a>
<a name="ln5546">  int filecount;</a>
<a name="ln5547">  char_u **files;</a>
<a name="ln5548"> </a>
<a name="ln5549">  // Get a list of all files in the help directory and in subdirectories.</a>
<a name="ln5550">  STRLCPY(NameBuff, dirname, sizeof(NameBuff));</a>
<a name="ln5551">  if (!add_pathsep((char *)NameBuff)</a>
<a name="ln5552">      || STRLCAT(NameBuff, &quot;**&quot;, sizeof(NameBuff)) &gt;= MAXPATHL) {</a>
<a name="ln5553">    EMSG(_(e_fnametoolong));</a>
<a name="ln5554">    return;</a>
<a name="ln5555">  }</a>
<a name="ln5556"> </a>
<a name="ln5557">  // Note: We cannot just do `&amp;NameBuff` because it is a statically sized array</a>
<a name="ln5558">  //       so `NameBuff == &amp;NameBuff` according to C semantics.</a>
<a name="ln5559">  char_u *buff_list[1] = {NameBuff};</a>
<a name="ln5560">  if (gen_expand_wildcards(1, buff_list, &amp;filecount, &amp;files,</a>
<a name="ln5561">                           EW_FILE|EW_SILENT) == FAIL</a>
<a name="ln5562">      || filecount == 0) {</a>
<a name="ln5563">    EMSG2(_(&quot;E151: No match: %s&quot;), NameBuff);</a>
<a name="ln5564">    return;</a>
<a name="ln5565">  }</a>
<a name="ln5566"> </a>
<a name="ln5567">  /* Go over all files in the directory to find out what languages are</a>
<a name="ln5568">   * present. */</a>
<a name="ln5569">  int j;</a>
<a name="ln5570">  ga_init(&amp;ga, 1, 10);</a>
<a name="ln5571">  for (int i = 0; i &lt; filecount; i++) {</a>
<a name="ln5572">    len = (int)STRLEN(files[i]);</a>
<a name="ln5573">    if (len &lt;= 4) {</a>
<a name="ln5574">      continue;</a>
<a name="ln5575">    }</a>
<a name="ln5576">    if (STRICMP(files[i] + len - 4, &quot;.txt&quot;) == 0) {</a>
<a name="ln5577">      /* &quot;.txt&quot; -&gt; language &quot;en&quot; */</a>
<a name="ln5578">      lang[0] = 'e';</a>
<a name="ln5579">      lang[1] = 'n';</a>
<a name="ln5580">    } else if (files[i][len - 4] == '.'</a>
<a name="ln5581">               &amp;&amp; ASCII_ISALPHA(files[i][len - 3])</a>
<a name="ln5582">               &amp;&amp; ASCII_ISALPHA(files[i][len - 2])</a>
<a name="ln5583">               &amp;&amp; TOLOWER_ASC(files[i][len - 1]) == 'x') {</a>
<a name="ln5584">      /* &quot;.abx&quot; -&gt; language &quot;ab&quot; */</a>
<a name="ln5585">      lang[0] = TOLOWER_ASC(files[i][len - 3]);</a>
<a name="ln5586">      lang[1] = TOLOWER_ASC(files[i][len - 2]);</a>
<a name="ln5587">    } else</a>
<a name="ln5588">      continue;</a>
<a name="ln5589"> </a>
<a name="ln5590">    // Did we find this language already?</a>
<a name="ln5591">    for (j = 0; j &lt; ga.ga_len; j += 2) {</a>
<a name="ln5592">      if (STRNCMP(lang, ((char_u *)ga.ga_data) + j, 2) == 0) {</a>
<a name="ln5593">        break;</a>
<a name="ln5594">      }</a>
<a name="ln5595">    }</a>
<a name="ln5596">    if (j == ga.ga_len) {</a>
<a name="ln5597">      // New language, add it.</a>
<a name="ln5598">      ga_grow(&amp;ga, 2);</a>
<a name="ln5599">      ((char_u *)ga.ga_data)[ga.ga_len++] = lang[0];</a>
<a name="ln5600">      ((char_u *)ga.ga_data)[ga.ga_len++] = lang[1];</a>
<a name="ln5601">    }</a>
<a name="ln5602">  }</a>
<a name="ln5603"> </a>
<a name="ln5604">  /*</a>
<a name="ln5605">   * Loop over the found languages to generate a tags file for each one.</a>
<a name="ln5606">   */</a>
<a name="ln5607">  for (j = 0; j &lt; ga.ga_len; j += 2) {</a>
<a name="ln5608">    STRCPY(fname, &quot;tags-xx&quot;);</a>
<a name="ln5609">    fname[5] = ((char_u *)ga.ga_data)[j];</a>
<a name="ln5610">    fname[6] = ((char_u *)ga.ga_data)[j + 1];</a>
<a name="ln5611">    if (fname[5] == 'e' &amp;&amp; fname[6] == 'n') {</a>
<a name="ln5612">      /* English is an exception: use &quot;.txt&quot; and &quot;tags&quot;. */</a>
<a name="ln5613">      fname[4] = NUL;</a>
<a name="ln5614">      STRCPY(ext, &quot;.txt&quot;);</a>
<a name="ln5615">    } else {</a>
<a name="ln5616">      /* Language &quot;ab&quot; uses &quot;.abx&quot; and &quot;tags-ab&quot;. */</a>
<a name="ln5617">      STRCPY(ext, &quot;.xxx&quot;);</a>
<a name="ln5618">      ext[1] = fname[5];</a>
<a name="ln5619">      ext[2] = fname[6];</a>
<a name="ln5620">    }</a>
<a name="ln5621">    helptags_one(dirname, ext, fname, add_help_tags, ignore_writeerr);</a>
<a name="ln5622">  }</a>
<a name="ln5623"> </a>
<a name="ln5624">  ga_clear(&amp;ga);</a>
<a name="ln5625">  FreeWild(filecount, files);</a>
<a name="ln5626">}</a>
<a name="ln5627"> </a>
<a name="ln5628">static void helptags_cb(char_u *fname, void *cookie)</a>
<a name="ln5629">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5630">{</a>
<a name="ln5631">    do_helptags(fname, *(bool *)cookie, true);</a>
<a name="ln5632">}</a>
<a name="ln5633"> </a>
<a name="ln5634">/*</a>
<a name="ln5635"> * &quot;:helptags&quot;</a>
<a name="ln5636"> */</a>
<a name="ln5637">void ex_helptags(exarg_T *eap)</a>
<a name="ln5638">{</a>
<a name="ln5639">  expand_T xpc;</a>
<a name="ln5640">  char_u *dirname;</a>
<a name="ln5641">  bool add_help_tags = false;</a>
<a name="ln5642"> </a>
<a name="ln5643">  /* Check for &quot;:helptags ++t {dir}&quot;. */</a>
<a name="ln5644">  if (STRNCMP(eap-&gt;arg, &quot;++t&quot;, 3) == 0 &amp;&amp; ascii_iswhite(eap-&gt;arg[3])) {</a>
<a name="ln5645">    add_help_tags = true;</a>
<a name="ln5646">    eap-&gt;arg = skipwhite(eap-&gt;arg + 3);</a>
<a name="ln5647">  }</a>
<a name="ln5648"> </a>
<a name="ln5649">  if (STRCMP(eap-&gt;arg, &quot;ALL&quot;) == 0) {</a>
<a name="ln5650">    do_in_path(p_rtp, (char_u *)&quot;doc&quot;, DIP_ALL + DIP_DIR,</a>
<a name="ln5651">               helptags_cb, &amp;add_help_tags);</a>
<a name="ln5652">  } else {</a>
<a name="ln5653">    ExpandInit(&amp;xpc);</a>
<a name="ln5654">    xpc.xp_context = EXPAND_DIRECTORIES;</a>
<a name="ln5655">    dirname = ExpandOne(&amp;xpc, eap-&gt;arg, NULL,</a>
<a name="ln5656">                        WILD_LIST_NOTFOUND|WILD_SILENT, WILD_EXPAND_FREE);</a>
<a name="ln5657">    if (dirname == NULL || !os_isdir(dirname)) {</a>
<a name="ln5658">      EMSG2(_(&quot;E150: Not a directory: %s&quot;), eap-&gt;arg);</a>
<a name="ln5659">    } else {</a>
<a name="ln5660">      do_helptags(dirname, add_help_tags, false);</a>
<a name="ln5661">    }</a>
<a name="ln5662">    xfree(dirname);</a>
<a name="ln5663">  }</a>
<a name="ln5664">}</a>
<a name="ln5665"> </a>
<a name="ln5666">/*</a>
<a name="ln5667"> * &quot;:helpclose&quot;: Close one help window</a>
<a name="ln5668"> */</a>
<a name="ln5669">void ex_helpclose(exarg_T *eap)</a>
<a name="ln5670">{</a>
<a name="ln5671">  FOR_ALL_WINDOWS_IN_TAB(win, curtab) {</a>
<a name="ln5672">    if (bt_help(win-&gt;w_buffer)) {</a>
<a name="ln5673">      win_close(win, false);</a>
<a name="ln5674">      return;</a>
<a name="ln5675">    }</a>
<a name="ln5676">  }</a>
<a name="ln5677">}</a>
<a name="ln5678"> </a>
<a name="ln5679">/// Tries to enter to an existing window of given buffer. If no existing buffer</a>
<a name="ln5680">/// is found, creates a new split.</a>
<a name="ln5681">///</a>
<a name="ln5682">/// Returns OK/FAIL.</a>
<a name="ln5683">int sub_preview_win(buf_T *preview_buf)</a>
<a name="ln5684">{</a>
<a name="ln5685">  if (preview_buf != NULL) {</a>
<a name="ln5686">    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln5687">      if (wp-&gt;w_buffer == preview_buf) {</a>
<a name="ln5688">        win_enter(wp, false);</a>
<a name="ln5689"> </a>
<a name="ln5690">        return OK;</a>
<a name="ln5691">      }</a>
<a name="ln5692">    }</a>
<a name="ln5693">  }</a>
<a name="ln5694">  return win_split((int)p_cwh, WSP_BOT);</a>
<a name="ln5695">}</a>
<a name="ln5696"> </a>
<a name="ln5697">/// Shows the effects of the :substitute command being typed ('inccommand').</a>
<a name="ln5698">/// If inccommand=split, shows a preview window and later restores the layout.</a>
<a name="ln5699">static buf_T *show_sub(exarg_T *eap, pos_T old_cusr,</a>
<a name="ln5700">                       PreviewLines *preview_lines, int hl_id, int src_id,</a>
<a name="ln5701">                       handle_T bufnr)</a>
<a name="ln5702">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5703">{</a>
<a name="ln5704">  win_T *save_curwin = curwin;</a>
<a name="ln5705">  cmdmod_T save_cmdmod = cmdmod;</a>
<a name="ln5706">  char_u *save_shm_p = vim_strsave(p_shm);</a>
<a name="ln5707">  PreviewLines lines = *preview_lines;</a>
<a name="ln5708">  buf_T *orig_buf = curbuf;</a>
<a name="ln5709"> </a>
<a name="ln5710">  // We keep a special-purpose buffer around, but don't assume it exists.</a>
<a name="ln5711">  buf_T *preview_buf = bufnr ? buflist_findnr(bufnr) : 0;</a>
<a name="ln5712">  cmdmod.split = 0;               // disable :leftabove/botright modifiers</a>
<a name="ln5713">  cmdmod.tab = 0;                 // disable :tab modifier</a>
<a name="ln5714">  cmdmod.noswapfile = true;       // disable swap for preview buffer</a>
<a name="ln5715">  // disable file info message</a>
<a name="ln5716">  set_string_option_direct(&quot;shm&quot;, -1, (char_u *)&quot;F&quot;, OPT_FREE,</a>
<a name="ln5717">                           SID_NONE);</a>
<a name="ln5718"> </a>
<a name="ln5719">  bool outside_curline = (eap-&gt;line1 != old_cusr.lnum</a>
<a name="ln5720">                          || eap-&gt;line2 != old_cusr.lnum);</a>
<a name="ln5721">  bool preview = outside_curline &amp;&amp; (*p_icm != 'n');</a>
<a name="ln5722">  if (preview_buf == curbuf) {  // Preview buffer cannot preview itself!</a>
<a name="ln5723">    preview = false;</a>
<a name="ln5724">    preview_buf = NULL;</a>
<a name="ln5725">  }</a>
<a name="ln5726"> </a>
<a name="ln5727">  // Place cursor on nearest matching line, to undo do_sub() cursor placement.</a>
<a name="ln5728">  for (size_t i = 0; i &lt; lines.subresults.size; i++) {</a>
<a name="ln5729">    SubResult curres = lines.subresults.items[i];</a>
<a name="ln5730">    if (curres.start.lnum &gt;= old_cusr.lnum) {</a>
<a name="ln5731">      curwin-&gt;w_cursor.lnum = curres.start.lnum;</a>
<a name="ln5732">      curwin-&gt;w_cursor.col = curres.start.col;</a>
<a name="ln5733">      break;</a>
<a name="ln5734">    }  // Else: All matches are above, do_sub() already placed cursor.</a>
<a name="ln5735">  }</a>
<a name="ln5736"> </a>
<a name="ln5737">  // Width of the &quot;| lnum|...&quot; column which displays the line numbers.</a>
<a name="ln5738">  linenr_T highest_num_line = 0;</a>
<a name="ln5739">  int col_width = 0;</a>
<a name="ln5740"> </a>
<a name="ln5741">  if (preview &amp;&amp; sub_preview_win(preview_buf) != FAIL) {</a>
<a name="ln5742">    buf_open_scratch(preview_buf ? bufnr : 0, &quot;[Preview]&quot;);</a>
<a name="ln5743">    buf_clear();</a>
<a name="ln5744">    preview_buf = curbuf;</a>
<a name="ln5745">    curbuf-&gt;b_p_bl = false;</a>
<a name="ln5746">    curbuf-&gt;b_p_ma = true;</a>
<a name="ln5747">    curbuf-&gt;b_p_ul = -1;</a>
<a name="ln5748">    curbuf-&gt;b_p_tw = 0;         // Reset 'textwidth' (was set by ftplugin)</a>
<a name="ln5749">    curwin-&gt;w_p_cul = false;</a>
<a name="ln5750">    curwin-&gt;w_p_cuc = false;</a>
<a name="ln5751">    curwin-&gt;w_p_spell = false;</a>
<a name="ln5752">    curwin-&gt;w_p_fen = false;</a>
<a name="ln5753"> </a>
<a name="ln5754">    if (lines.subresults.size &gt; 0) {</a>
<a name="ln5755">      highest_num_line = kv_last(lines.subresults).end.lnum;</a>
<a name="ln5756">      col_width = log10(highest_num_line) + 1 + 3;</a>
<a name="ln5757">    }</a>
<a name="ln5758">  } else {</a>
<a name="ln5759">    // Failed to split the window, don't show 'inccommand' preview.</a>
<a name="ln5760">    preview_buf = NULL;</a>
<a name="ln5761">  }</a>
<a name="ln5762"> </a>
<a name="ln5763">  char *str = NULL;  // construct the line to show in here</a>
<a name="ln5764">  size_t old_line_size = 0;</a>
<a name="ln5765">  size_t line_size = 0;</a>
<a name="ln5766">  linenr_T linenr_preview = 0;  // last line added to preview buffer</a>
<a name="ln5767">  linenr_T linenr_origbuf = 0;  // last line added to original buffer</a>
<a name="ln5768">  linenr_T next_linenr = 0;     // next line to show for the match</a>
<a name="ln5769"> </a>
<a name="ln5770">  for (size_t matchidx = 0; matchidx &lt; lines.subresults.size; matchidx++) {</a>
<a name="ln5771">    SubResult match = lines.subresults.items[matchidx];</a>
<a name="ln5772"> </a>
<a name="ln5773">    if (preview_buf) {</a>
<a name="ln5774">      lpos_T p_start = { 0, match.start.col };  // match starts here in preview</a>
<a name="ln5775">      lpos_T p_end   = { 0, match.end.col };    // ... and ends here</a>
<a name="ln5776"> </a>
<a name="ln5777">      if (match.pre_match == 0) {</a>
<a name="ln5778">        next_linenr = match.start.lnum;</a>
<a name="ln5779">      } else {</a>
<a name="ln5780">        next_linenr = match.pre_match;</a>
<a name="ln5781">      }</a>
<a name="ln5782">      // Don't add a line twice</a>
<a name="ln5783">      if (next_linenr == linenr_origbuf) {</a>
<a name="ln5784">        next_linenr++;</a>
<a name="ln5785">        p_start.lnum = linenr_preview;  // might be redefined below</a>
<a name="ln5786">        p_end.lnum = linenr_preview;  // might be redefined below</a>
<a name="ln5787">      }</a>
<a name="ln5788"> </a>
<a name="ln5789">      for (; next_linenr &lt;= match.end.lnum; next_linenr++) {</a>
<a name="ln5790">        if (next_linenr == match.start.lnum) {</a>
<a name="ln5791">          p_start.lnum = linenr_preview + 1;</a>
<a name="ln5792">        }</a>
<a name="ln5793">        if (next_linenr == match.end.lnum) {</a>
<a name="ln5794">          p_end.lnum = linenr_preview + 1;</a>
<a name="ln5795">        }</a>
<a name="ln5796">        char *line;</a>
<a name="ln5797">        if (next_linenr == orig_buf-&gt;b_ml.ml_line_count + 1) {</a>
<a name="ln5798">          line = &quot;&quot;;</a>
<a name="ln5799">        } else {</a>
<a name="ln5800">          line = (char *)ml_get_buf(orig_buf, next_linenr, false);</a>
<a name="ln5801">          line_size = strlen(line) + col_width + 1;</a>
<a name="ln5802"> </a>
<a name="ln5803">          // Reallocate if line not long enough</a>
<a name="ln5804">          if (line_size &gt; old_line_size) {</a>
<a name="ln5805">            str = xrealloc(str, line_size * sizeof(char));</a>
<a name="ln5806">            old_line_size = line_size;</a>
<a name="ln5807">          }</a>
<a name="ln5808">        }</a>
<a name="ln5809">        // Put &quot;|lnum| line&quot; into `str` and append it to the preview buffer.</a>
<a name="ln5810">        snprintf(str, line_size, &quot;|%*ld| %s&quot;, col_width - 3,</a>
<a name="ln5811">                 next_linenr, line);</a>
<a name="ln5812">        if (linenr_preview == 0) {</a>
<a name="ln5813">          ml_replace(1, (char_u *)str, true);</a>
<a name="ln5814">        } else {</a>
<a name="ln5815">          ml_append(linenr_preview, (char_u *)str, (colnr_T)line_size, false);</a>
<a name="ln5816">        }</a>
<a name="ln5817">        linenr_preview += 1;</a>
<a name="ln5818">      }</a>
<a name="ln5819">      linenr_origbuf = match.end.lnum;</a>
<a name="ln5820"> </a>
<a name="ln5821">      bufhl_add_hl_pos_offset(preview_buf, src_id, hl_id, p_start,</a>
<a name="ln5822">                              p_end, col_width);</a>
<a name="ln5823">    }</a>
<a name="ln5824">    bufhl_add_hl_pos_offset(orig_buf, src_id, hl_id, match.start,</a>
<a name="ln5825">                            match.end, 0);</a>
<a name="ln5826">  }</a>
<a name="ln5827">  xfree(str);</a>
<a name="ln5828"> </a>
<a name="ln5829">  redraw_later(curwin, SOME_VALID);</a>
<a name="ln5830">  win_enter(save_curwin, false);  // Return to original window</a>
<a name="ln5831">  update_topline(curwin);</a>
<a name="ln5832"> </a>
<a name="ln5833">  // Update screen now.</a>
<a name="ln5834">  int save_rd = RedrawingDisabled;</a>
<a name="ln5835">  RedrawingDisabled = 0;</a>
<a name="ln5836">  update_screen(SOME_VALID);</a>
<a name="ln5837">  RedrawingDisabled = save_rd;</a>
<a name="ln5838"> </a>
<a name="ln5839">  set_string_option_direct(&quot;shm&quot;, -1, save_shm_p, OPT_FREE, SID_NONE);</a>
<a name="ln5840">  xfree(save_shm_p);</a>
<a name="ln5841"> </a>
<a name="ln5842">  cmdmod = save_cmdmod;</a>
<a name="ln5843"> </a>
<a name="ln5844">  return preview_buf;</a>
<a name="ln5845">}</a>
<a name="ln5846"> </a>
<a name="ln5847">/// Closes any open windows for inccommand preview buffer.</a>
<a name="ln5848">void close_preview_windows(void)</a>
<a name="ln5849">{</a>
<a name="ln5850">    block_autocmds();</a>
<a name="ln5851">    buf_T *buf = preview_bufnr ? buflist_findnr(preview_bufnr) : NULL;</a>
<a name="ln5852">    if (buf != NULL) {</a>
<a name="ln5853">      close_windows(buf, false);</a>
<a name="ln5854">    }</a>
<a name="ln5855">    unblock_autocmds();</a>
<a name="ln5856">}</a>
<a name="ln5857"> </a>
<a name="ln5858">/// :substitute command</a>
<a name="ln5859">///</a>
<a name="ln5860">/// If 'inccommand' is empty: calls do_sub().</a>
<a name="ln5861">/// If 'inccommand' is set: shows a &quot;live&quot; preview then removes the changes.</a>
<a name="ln5862">/// from undo history.</a>
<a name="ln5863">void ex_substitute(exarg_T *eap)</a>
<a name="ln5864">{</a>
<a name="ln5865">  bool preview = (State &amp; CMDPREVIEW);</a>
<a name="ln5866">  if (*p_icm == NUL || !preview) {  // 'inccommand' is disabled</a>
<a name="ln5867">    close_preview_windows();</a>
<a name="ln5868">    (void)do_sub(eap, profile_zero(), true, preview_bufnr);</a>
<a name="ln5869"> </a>
<a name="ln5870">    return;</a>
<a name="ln5871">  }</a>
<a name="ln5872"> </a>
<a name="ln5873">  block_autocmds();           // Disable events during command preview.</a>
<a name="ln5874"> </a>
<a name="ln5875">  char_u *save_eap = eap-&gt;arg;</a>
<a name="ln5876">  garray_T save_view;</a>
<a name="ln5877">  win_size_save(&amp;save_view);  // Save current window sizes.</a>
<a name="ln5878">  save_search_patterns();</a>
<a name="ln5879">  int save_changedtick = buf_get_changedtick(curbuf);</a>
<a name="ln5880">  time_t save_b_u_time_cur = curbuf-&gt;b_u_time_cur;</a>
<a name="ln5881">  u_header_T *save_b_u_newhead = curbuf-&gt;b_u_newhead;</a>
<a name="ln5882">  long save_b_p_ul = curbuf-&gt;b_p_ul;</a>
<a name="ln5883">  int save_w_p_cul = curwin-&gt;w_p_cul;</a>
<a name="ln5884">  int save_w_p_cuc = curwin-&gt;w_p_cuc;</a>
<a name="ln5885"> </a>
<a name="ln5886">  curbuf-&gt;b_p_ul = LONG_MAX;  // make sure we can undo all changes</a>
<a name="ln5887">  curwin-&gt;w_p_cul = false;    // Disable 'cursorline'</a>
<a name="ln5888">  curwin-&gt;w_p_cuc = false;    // Disable 'cursorcolumn'</a>
<a name="ln5889"> </a>
<a name="ln5890">  // Don't show search highlighting during live substitution</a>
<a name="ln5891">  bool save_hls = p_hls;</a>
<a name="ln5892">  p_hls = false;</a>
<a name="ln5893">  buf_T *preview_buf = do_sub(eap, profile_setlimit(p_rdt), false,</a>
<a name="ln5894">                              preview_bufnr);</a>
<a name="ln5895">  p_hls = save_hls;</a>
<a name="ln5896"> </a>
<a name="ln5897">  if (preview_buf != NULL) {</a>
<a name="ln5898">    preview_bufnr = preview_buf-&gt;handle;</a>
<a name="ln5899">  }</a>
<a name="ln5900"> </a>
<a name="ln5901">  if (save_changedtick != buf_get_changedtick(curbuf)) {</a>
<a name="ln5902">    // Undo invisibly. This also moves the cursor!</a>
<a name="ln5903">    if (!u_undo_and_forget(1)) { abort(); }</a>
<a name="ln5904">    // Restore newhead. It is meaningless when curhead is valid, but we must</a>
<a name="ln5905">    // restore it so that undotree() is identical before/after the preview.</a>
<a name="ln5906">    curbuf-&gt;b_u_newhead = save_b_u_newhead;</a>
<a name="ln5907">    curbuf-&gt;b_u_time_cur = save_b_u_time_cur;</a>
<a name="ln5908">    buf_set_changedtick(curbuf, save_changedtick);</a>
<a name="ln5909">  }</a>
<a name="ln5910"> </a>
<a name="ln5911">  curbuf-&gt;b_p_ul = save_b_p_ul;</a>
<a name="ln5912">  curwin-&gt;w_p_cul = save_w_p_cul;   // Restore 'cursorline'</a>
<a name="ln5913">  curwin-&gt;w_p_cuc = save_w_p_cuc;   // Restore 'cursorcolumn'</a>
<a name="ln5914">  eap-&gt;arg = save_eap;</a>
<a name="ln5915">  restore_search_patterns();</a>
<a name="ln5916">  win_size_restore(&amp;save_view);</a>
<a name="ln5917">  ga_clear(&amp;save_view);</a>
<a name="ln5918">  unblock_autocmds();</a>
<a name="ln5919">}</a>
<a name="ln5920"> </a>
<a name="ln5921">/// Skip over the pattern argument of &quot;:vimgrep /pat/[g][j]&quot;.</a>
<a name="ln5922">/// Put the start of the pattern in &quot;*s&quot;, unless &quot;s&quot; is NULL.</a>
<a name="ln5923">/// If &quot;flags&quot; is not NULL put the flags in it: VGR_GLOBAL, VGR_NOJUMP.</a>
<a name="ln5924">/// If &quot;s&quot; is not NULL terminate the pattern with a NUL.</a>
<a name="ln5925">/// Return a pointer to the char just past the pattern plus flags.</a>
<a name="ln5926">char_u *skip_vimgrep_pat(char_u *p, char_u **s, int *flags)</a>
<a name="ln5927">{</a>
<a name="ln5928">  int c;</a>
<a name="ln5929"> </a>
<a name="ln5930">  if (vim_isIDc(*p)) {</a>
<a name="ln5931">    // &quot;:vimgrep pattern fname&quot;</a>
<a name="ln5932">    if (s != NULL) {</a>
<a name="ln5933">      *s = p;</a>
<a name="ln5934">    }</a>
<a name="ln5935">    p = skiptowhite(p);</a>
<a name="ln5936">    if (s != NULL &amp;&amp; *p != NUL) {</a>
<a name="ln5937">      *p++ = NUL;</a>
<a name="ln5938">    }</a>
<a name="ln5939">  } else {</a>
<a name="ln5940">    // &quot;:vimgrep /pattern/[g][j] fname&quot;</a>
<a name="ln5941">    if (s != NULL) {</a>
<a name="ln5942">      *s = p + 1;</a>
<a name="ln5943">    }</a>
<a name="ln5944">    c = *p;</a>
<a name="ln5945">    p = skip_regexp(p + 1, c, true, NULL);</a>
<a name="ln5946">    if (*p != c) {</a>
<a name="ln5947">      return NULL;</a>
<a name="ln5948">    }</a>
<a name="ln5949"> </a>
<a name="ln5950">    // Truncate the pattern.</a>
<a name="ln5951">    if (s != NULL) {</a>
<a name="ln5952">      *p = NUL;</a>
<a name="ln5953">    }</a>
<a name="ln5954">    p++;</a>
<a name="ln5955"> </a>
<a name="ln5956">    // Find the flags</a>
<a name="ln5957">    while (*p == 'g' || *p == 'j') {</a>
<a name="ln5958">      if (flags != NULL) {</a>
<a name="ln5959">        if (*p == 'g') {</a>
<a name="ln5960">          *flags |= VGR_GLOBAL;</a>
<a name="ln5961">        } else {</a>
<a name="ln5962">          *flags |= VGR_NOJUMP;</a>
<a name="ln5963">        }</a>
<a name="ln5964">      }</a>
<a name="ln5965">      p++;</a>
<a name="ln5966">    }</a>
<a name="ln5967">  }</a>
<a name="ln5968">  return p;</a>
<a name="ln5969">}</a>
<a name="ln5970"> </a>
<a name="ln5971">/// List v:oldfiles in a nice way.</a>
<a name="ln5972">void ex_oldfiles(exarg_T *eap)</a>
<a name="ln5973">{</a>
<a name="ln5974">  list_T      *l = get_vim_var_list(VV_OLDFILES);</a>
<a name="ln5975">  long nr = 0;</a>
<a name="ln5976"> </a>
<a name="ln5977">  if (l == NULL) {</a>
<a name="ln5978">    msg((char_u *)_(&quot;No old files&quot;));</a>
<a name="ln5979">  } else {</a>
<a name="ln5980">    msg_start();</a>
<a name="ln5981">    msg_scroll = true;</a>
<a name="ln5982">    TV_LIST_ITER(l, li, {</a>
<a name="ln5983">      if (got_int) {</a>
<a name="ln5984">        break;</a>
<a name="ln5985">      }</a>
<a name="ln5986">      nr++;</a>
<a name="ln5987">      const char *fname = tv_get_string(TV_LIST_ITEM_TV(li));</a>
<a name="ln5988">      if (!message_filtered((char_u *)fname)) {</a>
<a name="ln5989">        msg_outnum(nr);</a>
<a name="ln5990">        MSG_PUTS(&quot;: &quot;);</a>
<a name="ln5991">        msg_outtrans((char_u *)tv_get_string(TV_LIST_ITEM_TV(li)));</a>
<a name="ln5992">        msg_clr_eos();</a>
<a name="ln5993">        msg_putchar('\n');</a>
<a name="ln5994">        ui_flush();                  // output one line at a time</a>
<a name="ln5995">        os_breakcheck();</a>
<a name="ln5996">      }</a>
<a name="ln5997">    });</a>
<a name="ln5998"> </a>
<a name="ln5999">    // Assume &quot;got_int&quot; was set to truncate the listing.</a>
<a name="ln6000">    got_int = false;</a>
<a name="ln6001"> </a>
<a name="ln6002">    // File selection prompt on &quot;:browse oldfiles&quot;</a>
<a name="ln6003">    if (cmdmod.browse) {</a>
<a name="ln6004">      quit_more = false;</a>
<a name="ln6005">      nr = prompt_for_number(false);</a>
<a name="ln6006">      msg_starthere();</a>
<a name="ln6007">      if (nr &gt; 0 &amp;&amp; nr &lt;= tv_list_len(l)) {</a>
<a name="ln6008">        const char *const p = tv_list_find_str(l, nr - 1);</a>
<a name="ln6009">        if (p == NULL) {</a>
<a name="ln6010">          return;</a>
<a name="ln6011">        }</a>
<a name="ln6012">        char *const s = (char *)expand_env_save((char_u *)p);</a>
<a name="ln6013">        eap-&gt;arg = (char_u *)s;</a>
<a name="ln6014">        eap-&gt;cmdidx = CMD_edit;</a>
<a name="ln6015">        cmdmod.browse = false;</a>
<a name="ln6016">        do_exedit(eap, NULL);</a>
<a name="ln6017">        xfree(s);</a>
<a name="ln6018">      }</a>
<a name="ln6019">    }</a>
<a name="ln6020">  }</a>
<a name="ln6021">}</a>

</code></pre>
<div class="balloon" rel="3641"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'current_match.start.lnum' should be checked here.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
