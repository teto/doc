
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>memline.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// for debugging</a>
<a name="ln5">// #define CHECK(c, s) do { if (c) EMSG(s); } while (0)</a>
<a name="ln6">#define CHECK(c, s) do { } while (0)</a>
<a name="ln7"> </a>
<a name="ln8">/*</a>
<a name="ln9"> * memline.c: Contains the functions for appending, deleting and changing the</a>
<a name="ln10"> * text lines. The memfile functions are used to store the information in</a>
<a name="ln11"> * blocks of memory, backed up by a file. The structure of the information is</a>
<a name="ln12"> * a tree.  The root of the tree is a pointer block. The leaves of the tree</a>
<a name="ln13"> * are data blocks. In between may be several layers of pointer blocks,</a>
<a name="ln14"> * forming branches.</a>
<a name="ln15"> *</a>
<a name="ln16"> * Three types of blocks are used:</a>
<a name="ln17"> * - Block nr 0 contains information for recovery</a>
<a name="ln18"> * - Pointer blocks contain list of pointers to other blocks.</a>
<a name="ln19"> * - Data blocks contain the actual text.</a>
<a name="ln20"> *</a>
<a name="ln21"> * Block nr 0 contains the block0 structure (see below).</a>
<a name="ln22"> *</a>
<a name="ln23"> * Block nr 1 is the first pointer block. It is the root of the tree.</a>
<a name="ln24"> * Other pointer blocks are branches.</a>
<a name="ln25"> *</a>
<a name="ln26"> *  If a line is too big to fit in a single page, the block containing that</a>
<a name="ln27"> *  line is made big enough to hold the line. It may span several pages.</a>
<a name="ln28"> *  Otherwise all blocks are one page.</a>
<a name="ln29"> *</a>
<a name="ln30"> *  A data block that was filled when starting to edit a file and was not</a>
<a name="ln31"> *  changed since then, can have a negative block number. This means that it</a>
<a name="ln32"> *  has not yet been assigned a place in the file. When recovering, the lines</a>
<a name="ln33"> *  in this data block can be read from the original file. When the block is</a>
<a name="ln34"> *  changed (lines appended/deleted/changed) or when it is flushed it gets a</a>
<a name="ln35"> *  positive number. Use mf_trans_del() to get the new number, before calling</a>
<a name="ln36"> *  mf_get().</a>
<a name="ln37"> */</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;assert.h&gt;</a>
<a name="ln40">#include &lt;errno.h&gt;</a>
<a name="ln41">#include &lt;inttypes.h&gt;</a>
<a name="ln42">#include &lt;string.h&gt;</a>
<a name="ln43">#include &lt;stdbool.h&gt;</a>
<a name="ln44">#include &lt;fcntl.h&gt;</a>
<a name="ln45"> </a>
<a name="ln46">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln47">#include &quot;nvim/vim.h&quot;</a>
<a name="ln48">#include &quot;nvim/memline.h&quot;</a>
<a name="ln49">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln50">#include &quot;nvim/change.h&quot;</a>
<a name="ln51">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln52">#include &quot;nvim/eval.h&quot;</a>
<a name="ln53">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln54">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln55">#include &quot;nvim/func_attr.h&quot;</a>
<a name="ln56">#include &quot;nvim/main.h&quot;</a>
<a name="ln57">#include &quot;nvim/mark.h&quot;</a>
<a name="ln58">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln59">#include &quot;nvim/memfile.h&quot;</a>
<a name="ln60">#include &quot;nvim/memory.h&quot;</a>
<a name="ln61">#include &quot;nvim/message.h&quot;</a>
<a name="ln62">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln63">#include &quot;nvim/option.h&quot;</a>
<a name="ln64">#include &quot;nvim/os_unix.h&quot;</a>
<a name="ln65">#include &quot;nvim/path.h&quot;</a>
<a name="ln66">#include &quot;nvim/screen.h&quot;</a>
<a name="ln67">#include &quot;nvim/sha256.h&quot;</a>
<a name="ln68">#include &quot;nvim/spell.h&quot;</a>
<a name="ln69">#include &quot;nvim/strings.h&quot;</a>
<a name="ln70">#include &quot;nvim/ui.h&quot;</a>
<a name="ln71">#include &quot;nvim/version.h&quot;</a>
<a name="ln72">#include &quot;nvim/undo.h&quot;</a>
<a name="ln73">#include &quot;nvim/window.h&quot;</a>
<a name="ln74">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln75">#include &quot;nvim/os/process.h&quot;</a>
<a name="ln76">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln77"> </a>
<a name="ln78">#ifndef UNIX            /* it's in os/unix_defs.h for Unix */</a>
<a name="ln79"># include &lt;time.h&gt;</a>
<a name="ln80">#endif</a>
<a name="ln81"> </a>
<a name="ln82">typedef struct block0 ZERO_BL;              /* contents of the first block */</a>
<a name="ln83">typedef struct pointer_block PTR_BL;        /* contents of a pointer block */</a>
<a name="ln84">typedef struct data_block DATA_BL;          /* contents of a data block */</a>
<a name="ln85">typedef struct pointer_entry PTR_EN;        /* block/line-count pair */</a>
<a name="ln86"> </a>
<a name="ln87">#define DATA_ID        (('d' &lt;&lt; 8) + 'a')   /* data block id */</a>
<a name="ln88">#define PTR_ID         (('p' &lt;&lt; 8) + 't')   /* pointer block id */</a>
<a name="ln89">#define BLOCK0_ID0     'b'                  /* block 0 id 0 */</a>
<a name="ln90">#define BLOCK0_ID1     '0'                  /* block 0 id 1 */</a>
<a name="ln91"> </a>
<a name="ln92">/*</a>
<a name="ln93"> * pointer to a block, used in a pointer block</a>
<a name="ln94"> */</a>
<a name="ln95">struct pointer_entry {</a>
<a name="ln96">  blocknr_T pe_bnum;            /* block number */</a>
<a name="ln97">  linenr_T pe_line_count;       /* number of lines in this branch */</a>
<a name="ln98">  linenr_T pe_old_lnum;         /* lnum for this block (for recovery) */</a>
<a name="ln99">  int pe_page_count;            /* number of pages in block pe_bnum */</a>
<a name="ln100">};</a>
<a name="ln101"> </a>
<a name="ln102">/*</a>
<a name="ln103"> * A pointer block contains a list of branches in the tree.</a>
<a name="ln104"> */</a>
<a name="ln105">struct pointer_block {</a>
<a name="ln106">  uint16_t pb_id;               /* ID for pointer block: PTR_ID */</a>
<a name="ln107">  uint16_t pb_count;            /* number of pointers in this block */</a>
<a name="ln108">  uint16_t pb_count_max;        /* maximum value for pb_count */</a>
<a name="ln109">  PTR_EN pb_pointer[1];         /* list of pointers to blocks (actually longer)</a>
<a name="ln110">                                 * followed by empty space until end of page */</a>
<a name="ln111">};</a>
<a name="ln112"> </a>
<a name="ln113">/*</a>
<a name="ln114"> * A data block is a leaf in the tree.</a>
<a name="ln115"> *</a>
<a name="ln116"> * The text of the lines is at the end of the block. The text of the first line</a>
<a name="ln117"> * in the block is put at the end, the text of the second line in front of it,</a>
<a name="ln118"> * etc. Thus the order of the lines is the opposite of the line number.</a>
<a name="ln119"> */</a>
<a name="ln120">struct data_block {</a>
<a name="ln121">  uint16_t db_id;               /* ID for data block: DATA_ID */</a>
<a name="ln122">  unsigned db_free;             /* free space available */</a>
<a name="ln123">  unsigned db_txt_start;        /* byte where text starts */</a>
<a name="ln124">  unsigned db_txt_end;          /* byte just after data block */</a>
<a name="ln125">  linenr_T db_line_count;       /* number of lines in this block */</a>
<a name="ln126">  unsigned db_index[1];         /* index for start of line (actually bigger)</a>
<a name="ln127">                                 * followed by empty space upto db_txt_start</a>
<a name="ln128">                                 * followed by the text in the lines until</a>
<a name="ln129">                                 * end of page */</a>
<a name="ln130">};</a>
<a name="ln131"> </a>
<a name="ln132">/*</a>
<a name="ln133"> * The low bits of db_index hold the actual index. The topmost bit is</a>
<a name="ln134"> * used for the global command to be able to mark a line.</a>
<a name="ln135"> * This method is not clean, but otherwise there would be at least one extra</a>
<a name="ln136"> * byte used for each line.</a>
<a name="ln137"> * The mark has to be in this place to keep it with the correct line when other</a>
<a name="ln138"> * lines are inserted or deleted.</a>
<a name="ln139"> */</a>
<a name="ln140">#define DB_MARKED       ((unsigned)1 &lt;&lt; ((sizeof(unsigned) * 8) - 1))</a>
<a name="ln141">#define DB_INDEX_MASK   (~DB_MARKED)</a>
<a name="ln142"> </a>
<a name="ln143">#define INDEX_SIZE  (sizeof(unsigned))      /* size of one db_index entry */</a>
<a name="ln144">#define HEADER_SIZE (sizeof(DATA_BL) - INDEX_SIZE)  /* size of data block header */</a>
<a name="ln145"> </a>
<a name="ln146">#define B0_FNAME_SIZE_ORG       900     /* what it was in older versions */</a>
<a name="ln147">#define B0_FNAME_SIZE_NOCRYPT   898     /* 2 bytes used for other things */</a>
<a name="ln148">#define B0_FNAME_SIZE_CRYPT     890     /* 10 bytes used for other things */</a>
<a name="ln149">#define B0_UNAME_SIZE           40</a>
<a name="ln150">#define B0_HNAME_SIZE           40</a>
<a name="ln151">/*</a>
<a name="ln152"> * Restrict the numbers to 32 bits, otherwise most compilers will complain.</a>
<a name="ln153"> * This won't detect a 64 bit machine that only swaps a byte in the top 32</a>
<a name="ln154"> * bits, but that is crazy anyway.</a>
<a name="ln155"> */</a>
<a name="ln156">#define B0_MAGIC_LONG   0x30313233L</a>
<a name="ln157">#define B0_MAGIC_INT    0x20212223L</a>
<a name="ln158">#define B0_MAGIC_SHORT  0x10111213L</a>
<a name="ln159">#define B0_MAGIC_CHAR   0x55</a>
<a name="ln160"> </a>
<a name="ln161">/*</a>
<a name="ln162"> * Block zero holds all info about the swap file.</a>
<a name="ln163"> *</a>
<a name="ln164"> * NOTE: DEFINITION OF BLOCK 0 SHOULD NOT CHANGE! It would make all existing</a>
<a name="ln165"> * swap files unusable!</a>
<a name="ln166"> *</a>
<a name="ln167"> * If size of block0 changes anyway, adjust MIN_SWAP_PAGE_SIZE in vim.h!!</a>
<a name="ln168"> *</a>
<a name="ln169"> * This block is built up of single bytes, to make it portable across</a>
<a name="ln170"> * different machines. b0_magic_* is used to check the byte order and size of</a>
<a name="ln171"> * variables, because the rest of the swap file is not portable.</a>
<a name="ln172"> */</a>
<a name="ln173">struct block0 {</a>
<a name="ln174">  char_u b0_id[2];              ///&lt; ID for block 0: BLOCK0_ID0 and BLOCK0_ID1.</a>
<a name="ln175">  char_u b0_version[10];        /* Vim version string */</a>
<a name="ln176">  char_u b0_page_size[4];       /* number of bytes per page */</a>
<a name="ln177">  char_u b0_mtime[4];           /* last modification time of file */</a>
<a name="ln178">  char_u b0_ino[4];             /* inode of b0_fname */</a>
<a name="ln179">  char_u b0_pid[4];             /* process id of creator (or 0) */</a>
<a name="ln180">  char_u b0_uname[B0_UNAME_SIZE];        /* name of user (uid if no name) */</a>
<a name="ln181">  char_u b0_hname[B0_HNAME_SIZE];        /* host name (if it has a name) */</a>
<a name="ln182">  char_u b0_fname[B0_FNAME_SIZE_ORG];        /* name of file being edited */</a>
<a name="ln183">  long b0_magic_long;           /* check for byte order of long */</a>
<a name="ln184">  int b0_magic_int;             /* check for byte order of int */</a>
<a name="ln185">  short b0_magic_short;         /* check for byte order of short */</a>
<a name="ln186">  char_u b0_magic_char;         /* check for last char */</a>
<a name="ln187">};</a>
<a name="ln188"> </a>
<a name="ln189">/*</a>
<a name="ln190"> * Note: b0_dirty and b0_flags are put at the end of the file name.  For very</a>
<a name="ln191"> * long file names in older versions of Vim they are invalid.</a>
<a name="ln192"> * The 'fileencoding' comes before b0_flags, with a NUL in front.  But only</a>
<a name="ln193"> * when there is room, for very long file names it's omitted.</a>
<a name="ln194"> */</a>
<a name="ln195">#define B0_DIRTY        0x55</a>
<a name="ln196">#define b0_dirty        b0_fname[B0_FNAME_SIZE_ORG - 1]</a>
<a name="ln197"> </a>
<a name="ln198">/*</a>
<a name="ln199"> * The b0_flags field is new in Vim 7.0.</a>
<a name="ln200"> */</a>
<a name="ln201">#define b0_flags        b0_fname[B0_FNAME_SIZE_ORG - 2]</a>
<a name="ln202"> </a>
<a name="ln203">/* The lowest two bits contain the fileformat.  Zero means it's not set</a>
<a name="ln204"> * (compatible with Vim 6.x), otherwise it's EOL_UNIX + 1, EOL_DOS + 1 or</a>
<a name="ln205"> * EOL_MAC + 1. */</a>
<a name="ln206">#define B0_FF_MASK      3</a>
<a name="ln207"> </a>
<a name="ln208">/* Swap file is in directory of edited file.  Used to find the file from</a>
<a name="ln209"> * different mount points. */</a>
<a name="ln210">#define B0_SAME_DIR     4</a>
<a name="ln211"> </a>
<a name="ln212">/* The 'fileencoding' is at the end of b0_fname[], with a NUL in front of it.</a>
<a name="ln213"> * When empty there is only the NUL. */</a>
<a name="ln214">#define B0_HAS_FENC     8</a>
<a name="ln215"> </a>
<a name="ln216">#define STACK_INCR      5       /* nr of entries added to ml_stack at a time */</a>
<a name="ln217"> </a>
<a name="ln218">/*</a>
<a name="ln219"> * The line number where the first mark may be is remembered.</a>
<a name="ln220"> * If it is 0 there are no marks at all.</a>
<a name="ln221"> * (always used for the current buffer only, no buffer change possible while</a>
<a name="ln222"> * executing a global command).</a>
<a name="ln223"> */</a>
<a name="ln224">static linenr_T lowest_marked = 0;</a>
<a name="ln225"> </a>
<a name="ln226">/*</a>
<a name="ln227"> * arguments for ml_find_line()</a>
<a name="ln228"> */</a>
<a name="ln229">#define ML_DELETE       0x11        /* delete line */</a>
<a name="ln230">#define ML_INSERT       0x12        /* insert line */</a>
<a name="ln231">#define ML_FIND         0x13        /* just find the line */</a>
<a name="ln232">#define ML_FLUSH        0x02        /* flush locked block */</a>
<a name="ln233">#define ML_SIMPLE(x)    (x &amp; 0x10)  /* DEL, INS or FIND */</a>
<a name="ln234"> </a>
<a name="ln235">/* argument for ml_upd_block0() */</a>
<a name="ln236">typedef enum {</a>
<a name="ln237">  UB_FNAME = 0          /* update timestamp and filename */</a>
<a name="ln238">  , UB_SAME_DIR         /* update the B0_SAME_DIR flag */</a>
<a name="ln239">} upd_block0_T;</a>
<a name="ln240"> </a>
<a name="ln241">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln242"># include &quot;memline.c.generated.h&quot;</a>
<a name="ln243">#endif</a>
<a name="ln244"> </a>
<a name="ln245">/*</a>
<a name="ln246"> * Open a new memline for &quot;buf&quot;.</a>
<a name="ln247"> *</a>
<a name="ln248"> * Return FAIL for failure, OK otherwise.</a>
<a name="ln249"> */</a>
<a name="ln250">int ml_open(buf_T *buf)</a>
<a name="ln251">{</a>
<a name="ln252">  bhdr_T      *hp = NULL;</a>
<a name="ln253">  ZERO_BL     *b0p;</a>
<a name="ln254">  PTR_BL      *pp;</a>
<a name="ln255">  DATA_BL     *dp;</a>
<a name="ln256"> </a>
<a name="ln257">  /*</a>
<a name="ln258">   * init fields in memline struct</a>
<a name="ln259">   */</a>
<a name="ln260">  buf-&gt;b_ml.ml_stack_size = 0;   // no stack yet</a>
<a name="ln261">  buf-&gt;b_ml.ml_stack = NULL;    // no stack yet</a>
<a name="ln262">  buf-&gt;b_ml.ml_stack_top = 0;   // nothing in the stack</a>
<a name="ln263">  buf-&gt;b_ml.ml_locked = NULL;   // no cached block</a>
<a name="ln264">  buf-&gt;b_ml.ml_line_lnum = 0;   // no cached line</a>
<a name="ln265">  buf-&gt;b_ml.ml_line_offset = 0;</a>
<a name="ln266">  buf-&gt;b_ml.ml_chunksize = NULL;</a>
<a name="ln267"> </a>
<a name="ln268">  if (cmdmod.noswapfile) {</a>
<a name="ln269">    buf-&gt;b_p_swf = false;</a>
<a name="ln270">  }</a>
<a name="ln271"> </a>
<a name="ln272">  /*</a>
<a name="ln273">   * When 'updatecount' is non-zero swap file may be opened later.</a>
<a name="ln274">   */</a>
<a name="ln275">  if (!buf-&gt;terminal &amp;&amp; p_uc &amp;&amp; buf-&gt;b_p_swf) {</a>
<a name="ln276">    buf-&gt;b_may_swap = true;</a>
<a name="ln277">  } else {</a>
<a name="ln278">    buf-&gt;b_may_swap = false;</a>
<a name="ln279">  }</a>
<a name="ln280"> </a>
<a name="ln281">  // Open the memfile.  No swap file is created yet.</a>
<a name="ln282">  memfile_T *mfp = mf_open(NULL, 0);</a>
<a name="ln283">  if (mfp == NULL) {</a>
<a name="ln284">    goto error;</a>
<a name="ln285">  }</a>
<a name="ln286"> </a>
<a name="ln287">  buf-&gt;b_ml.ml_mfp = mfp;</a>
<a name="ln288">  buf-&gt;b_ml.ml_flags = ML_EMPTY;</a>
<a name="ln289">  buf-&gt;b_ml.ml_line_count = 1;</a>
<a name="ln290">  curwin-&gt;w_nrwidth_line_count = 0;</a>
<a name="ln291"> </a>
<a name="ln292"> </a>
<a name="ln293">  /*</a>
<a name="ln294">   * fill block0 struct and write page 0</a>
<a name="ln295">   */</a>
<a name="ln296">  hp = mf_new(mfp, false, 1);</a>
<a name="ln297">  if (hp-&gt;bh_bnum != 0) {</a>
<a name="ln298">    IEMSG(_(&quot;E298: Didn't get block nr 0?&quot;));</a>
<a name="ln299">    goto error;</a>
<a name="ln300">  }</a>
<a name="ln301">  b0p = hp-&gt;bh_data;</a>
<a name="ln302"> </a>
<a name="ln303">  b0p-&gt;b0_id[0] = BLOCK0_ID0;</a>
<a name="ln304">  b0p-&gt;b0_id[1] = BLOCK0_ID1;</a>
<a name="ln305">  b0p-&gt;b0_magic_long = (long)B0_MAGIC_LONG;</a>
<a name="ln306">  b0p-&gt;b0_magic_int = (int)B0_MAGIC_INT;</a>
<a name="ln307">  b0p-&gt;b0_magic_short = (short)B0_MAGIC_SHORT;</a>
<a name="ln308">  b0p-&gt;b0_magic_char = B0_MAGIC_CHAR;</a>
<a name="ln309">  xstrlcpy(xstpcpy((char *) b0p-&gt;b0_version, &quot;VIM &quot;), Version, 6);</a>
<a name="ln310">  long_to_char((long)mfp-&gt;mf_page_size, b0p-&gt;b0_page_size);</a>
<a name="ln311"> </a>
<a name="ln312">  if (!buf-&gt;b_spell) {</a>
<a name="ln313">    b0p-&gt;b0_dirty = buf-&gt;b_changed ? B0_DIRTY : 0;</a>
<a name="ln314">    b0p-&gt;b0_flags = get_fileformat(buf) + 1;</a>
<a name="ln315">    set_b0_fname(b0p, buf);</a>
<a name="ln316">    (void)os_get_user_name((char *)b0p-&gt;b0_uname, B0_UNAME_SIZE);</a>
<a name="ln317">    b0p-&gt;b0_uname[B0_UNAME_SIZE - 1] = NUL;</a>
<a name="ln318">    os_get_hostname((char *)b0p-&gt;b0_hname, B0_HNAME_SIZE);</a>
<a name="ln319">    b0p-&gt;b0_hname[B0_HNAME_SIZE - 1] = NUL;</a>
<a name="ln320">    long_to_char(os_get_pid(), b0p-&gt;b0_pid);</a>
<a name="ln321">  }</a>
<a name="ln322"> </a>
<a name="ln323">  /*</a>
<a name="ln324">   * Always sync block number 0 to disk, so we can check the file name in</a>
<a name="ln325">   * the swap file in findswapname(). Don't do this for a help files or</a>
<a name="ln326">   * a spell buffer though.</a>
<a name="ln327">   * Only works when there's a swapfile, otherwise it's done when the file</a>
<a name="ln328">   * is created.</a>
<a name="ln329">   */</a>
<a name="ln330">  mf_put(mfp, hp, true, false);</a>
<a name="ln331">  if (!buf-&gt;b_help &amp;&amp; !B_SPELL(buf))</a>
<a name="ln332">    (void)mf_sync(mfp, 0);</a>
<a name="ln333"> </a>
<a name="ln334">  /*</a>
<a name="ln335">   * Fill in root pointer block and write page 1.</a>
<a name="ln336">   */</a>
<a name="ln337">  if ((hp = ml_new_ptr(mfp)) == NULL)</a>
<a name="ln338">    goto error;</a>
<a name="ln339">  if (hp-&gt;bh_bnum != 1) {</a>
<a name="ln340">    IEMSG(_(&quot;E298: Didn't get block nr 1?&quot;));</a>
<a name="ln341">    goto error;</a>
<a name="ln342">  }</a>
<a name="ln343">  pp = hp-&gt;bh_data;</a>
<a name="ln344">  pp-&gt;pb_count = 1;</a>
<a name="ln345">  pp-&gt;pb_pointer[0].pe_bnum = 2;</a>
<a name="ln346">  pp-&gt;pb_pointer[0].pe_page_count = 1;</a>
<a name="ln347">  pp-&gt;pb_pointer[0].pe_old_lnum = 1;</a>
<a name="ln348">  pp-&gt;pb_pointer[0].pe_line_count = 1;      /* line count after insertion */</a>
<a name="ln349">  mf_put(mfp, hp, true, false);</a>
<a name="ln350"> </a>
<a name="ln351">  /*</a>
<a name="ln352">   * Allocate first data block and create an empty line 1.</a>
<a name="ln353">   */</a>
<a name="ln354">  hp = ml_new_data(mfp, false, 1);</a>
<a name="ln355">  if (hp-&gt;bh_bnum != 2) {</a>
<a name="ln356">    IEMSG(_(&quot;E298: Didn't get block nr 2?&quot;));</a>
<a name="ln357">    goto error;</a>
<a name="ln358">  }</a>
<a name="ln359"> </a>
<a name="ln360">  dp = hp-&gt;bh_data;</a>
<a name="ln361">  dp-&gt;db_index[0] = --dp-&gt;db_txt_start;         /* at end of block */</a>
<a name="ln362">  dp-&gt;db_free -= 1 + INDEX_SIZE;</a>
<a name="ln363">  dp-&gt;db_line_count = 1;</a>
<a name="ln364">  *((char_u *)dp + dp-&gt;db_txt_start) = NUL;     /* empty line */</a>
<a name="ln365"> </a>
<a name="ln366">  return OK;</a>
<a name="ln367"> </a>
<a name="ln368">error:</a>
<a name="ln369">  if (mfp != NULL) {</a>
<a name="ln370">    if (hp) {</a>
<a name="ln371">      mf_put(mfp, hp, false, false);</a>
<a name="ln372">    }</a>
<a name="ln373">    mf_close(mfp, true);  // will also xfree(mfp-&gt;mf_fname)</a>
<a name="ln374">  }</a>
<a name="ln375">  buf-&gt;b_ml.ml_mfp = NULL;</a>
<a name="ln376">  return FAIL;</a>
<a name="ln377">}</a>
<a name="ln378"> </a>
<a name="ln379">/*</a>
<a name="ln380"> * ml_setname() is called when the file name of &quot;buf&quot; has been changed.</a>
<a name="ln381"> * It may rename the swap file.</a>
<a name="ln382"> */</a>
<a name="ln383">void ml_setname(buf_T *buf)</a>
<a name="ln384">{</a>
<a name="ln385">  int success = FALSE;</a>
<a name="ln386">  memfile_T   *mfp;</a>
<a name="ln387">  char_u      *fname;</a>
<a name="ln388">  char_u      *dirp;</a>
<a name="ln389"> </a>
<a name="ln390">  mfp = buf-&gt;b_ml.ml_mfp;</a>
<a name="ln391">  if (mfp-&gt;mf_fd &lt; 0) {             /* there is no swap file yet */</a>
<a name="ln392">    /*</a>
<a name="ln393">     * When 'updatecount' is 0 and 'noswapfile' there is no swap file.</a>
<a name="ln394">     * For help files we will make a swap file now.</a>
<a name="ln395">     */</a>
<a name="ln396">    if (p_uc != 0 &amp;&amp; !cmdmod.noswapfile) {</a>
<a name="ln397">      ml_open_file(buf); /* create a swap file */</a>
<a name="ln398">    }</a>
<a name="ln399">    return;</a>
<a name="ln400">  }</a>
<a name="ln401"> </a>
<a name="ln402">  /*</a>
<a name="ln403">   * Try all directories in the 'directory' option.</a>
<a name="ln404">   */</a>
<a name="ln405">  dirp = p_dir;</a>
<a name="ln406">  bool found_existing_dir = false;</a>
<a name="ln407">  for (;; ) {</a>
<a name="ln408">    if (*dirp == NUL)               /* tried all directories, fail */</a>
<a name="ln409">      break;</a>
<a name="ln410">    fname = (char_u *)findswapname(buf, (char **)&amp;dirp, (char *)mfp-&gt;mf_fname,</a>
<a name="ln411">                                   &amp;found_existing_dir);</a>
<a name="ln412">    /* alloc's fname */</a>
<a name="ln413">    if (dirp == NULL)               /* out of memory */</a>
<a name="ln414">      break;</a>
<a name="ln415">    if (fname == NULL)              /* no file name found for this dir */</a>
<a name="ln416">      continue;</a>
<a name="ln417"> </a>
<a name="ln418">    /* if the file name is the same we don't have to do anything */</a>
<a name="ln419">    if (fnamecmp(fname, mfp-&gt;mf_fname) == 0) {</a>
<a name="ln420">      xfree(fname);</a>
<a name="ln421">      success = TRUE;</a>
<a name="ln422">      break;</a>
<a name="ln423">    }</a>
<a name="ln424">    /* need to close the swap file before renaming */</a>
<a name="ln425">    if (mfp-&gt;mf_fd &gt;= 0) {</a>
<a name="ln426">      close(mfp-&gt;mf_fd);</a>
<a name="ln427">      mfp-&gt;mf_fd = -1;</a>
<a name="ln428">    }</a>
<a name="ln429"> </a>
<a name="ln430">    /* try to rename the swap file */</a>
<a name="ln431">    if (vim_rename(mfp-&gt;mf_fname, fname) == 0) {</a>
<a name="ln432">      success = TRUE;</a>
<a name="ln433">      mf_free_fnames(mfp);</a>
<a name="ln434">      mf_set_fnames(mfp, fname);</a>
<a name="ln435">      ml_upd_block0(buf, UB_SAME_DIR);</a>
<a name="ln436">      break;</a>
<a name="ln437">    }</a>
<a name="ln438">    xfree(fname);                /* this fname didn't work, try another */</a>
<a name="ln439">  }</a>
<a name="ln440"> </a>
<a name="ln441">  if (mfp-&gt;mf_fd == -1) {           /* need to (re)open the swap file */</a>
<a name="ln442">    mfp-&gt;mf_fd = os_open((char *)mfp-&gt;mf_fname, O_RDWR, 0);</a>
<a name="ln443">    if (mfp-&gt;mf_fd &lt; 0) {</a>
<a name="ln444">      /* could not (re)open the swap file, what can we do???? */</a>
<a name="ln445">      EMSG(_(&quot;E301: Oops, lost the swap file!!!&quot;));</a>
<a name="ln446">      return;</a>
<a name="ln447">    }</a>
<a name="ln448">    (void)os_set_cloexec(mfp-&gt;mf_fd);</a>
<a name="ln449">  }</a>
<a name="ln450">  if (!success)</a>
<a name="ln451">    EMSG(_(&quot;E302: Could not rename swap file&quot;));</a>
<a name="ln452">}</a>
<a name="ln453"> </a>
<a name="ln454">/*</a>
<a name="ln455"> * Open a file for the memfile for all buffers that are not readonly or have</a>
<a name="ln456"> * been modified.</a>
<a name="ln457"> * Used when 'updatecount' changes from zero to non-zero.</a>
<a name="ln458"> */</a>
<a name="ln459">void ml_open_files(void)</a>
<a name="ln460">{</a>
<a name="ln461">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln462">    if (!buf-&gt;b_p_ro || buf-&gt;b_changed) {</a>
<a name="ln463">      ml_open_file(buf);</a>
<a name="ln464">    }</a>
<a name="ln465">  }</a>
<a name="ln466">}</a>
<a name="ln467"> </a>
<a name="ln468">/*</a>
<a name="ln469"> * Open a swap file for an existing memfile, if there is no swap file yet.</a>
<a name="ln470"> * If we are unable to find a file name, mf_fname will be NULL</a>
<a name="ln471"> * and the memfile will be in memory only (no recovery possible).</a>
<a name="ln472"> */</a>
<a name="ln473">void ml_open_file(buf_T *buf)</a>
<a name="ln474">{</a>
<a name="ln475">  memfile_T   *mfp;</a>
<a name="ln476">  char_u      *fname;</a>
<a name="ln477">  char_u      *dirp;</a>
<a name="ln478"> </a>
<a name="ln479">  mfp = buf-&gt;b_ml.ml_mfp;</a>
<a name="ln480">  if (mfp == NULL || mfp-&gt;mf_fd &gt;= 0 || !buf-&gt;b_p_swf || cmdmod.noswapfile</a>
<a name="ln481">      || buf-&gt;terminal) {</a>
<a name="ln482">    return; /* nothing to do */</a>
<a name="ln483">  }</a>
<a name="ln484"> </a>
<a name="ln485">  /* For a spell buffer use a temp file name. */</a>
<a name="ln486">  if (buf-&gt;b_spell) {</a>
<a name="ln487">    fname = vim_tempname();</a>
<a name="ln488">    if (fname != NULL)</a>
<a name="ln489">      (void)mf_open_file(mfp, fname);           /* consumes fname! */</a>
<a name="ln490">    buf-&gt;b_may_swap = false;</a>
<a name="ln491">    return;</a>
<a name="ln492">  }</a>
<a name="ln493"> </a>
<a name="ln494">  /*</a>
<a name="ln495">   * Try all directories in 'directory' option.</a>
<a name="ln496">   */</a>
<a name="ln497">  dirp = p_dir;</a>
<a name="ln498">  bool found_existing_dir = false;</a>
<a name="ln499">  for (;; ) {</a>
<a name="ln500">    if (*dirp == NUL)</a>
<a name="ln501">      break;</a>
<a name="ln502">    // There is a small chance that between choosing the swap file name</a>
<a name="ln503">    // and creating it, another Vim creates the file.  In that case the</a>
<a name="ln504">    // creation will fail and we will use another directory.</a>
<a name="ln505">    fname = (char_u *)findswapname(buf, (char **)&amp;dirp, NULL,</a>
<a name="ln506">                                   &amp;found_existing_dir);</a>
<a name="ln507">    if (dirp == NULL)</a>
<a name="ln508">      break;        /* out of memory */</a>
<a name="ln509">    if (fname == NULL)</a>
<a name="ln510">      continue;</a>
<a name="ln511">    if (mf_open_file(mfp, fname) == OK) {       /* consumes fname! */</a>
<a name="ln512">      ml_upd_block0(buf, UB_SAME_DIR);</a>
<a name="ln513"> </a>
<a name="ln514">      /* Flush block zero, so others can read it */</a>
<a name="ln515">      if (mf_sync(mfp, MFS_ZERO) == OK) {</a>
<a name="ln516">        /* Mark all blocks that should be in the swapfile as dirty.</a>
<a name="ln517">         * Needed for when the 'swapfile' option was reset, so that</a>
<a name="ln518">         * the swap file was deleted, and then on again. */</a>
<a name="ln519">        mf_set_dirty(mfp);</a>
<a name="ln520">        break;</a>
<a name="ln521">      }</a>
<a name="ln522">      /* Writing block 0 failed: close the file and try another dir */</a>
<a name="ln523">      mf_close_file(buf, false);</a>
<a name="ln524">    }</a>
<a name="ln525">  }</a>
<a name="ln526"> </a>
<a name="ln527">  if (*p_dir != NUL &amp;&amp; mfp-&gt;mf_fname == NULL) {</a>
<a name="ln528">    need_wait_return = true;  // call wait_return later</a>
<a name="ln529">    no_wait_return++;</a>
<a name="ln530">    (void)EMSG2(_(</a>
<a name="ln531">            &quot;E303: Unable to open swap file for \&quot;%s\&quot;, recovery impossible&quot;),</a>
<a name="ln532">        buf_spname(buf) != NULL ? buf_spname(buf) : buf-&gt;b_fname);</a>
<a name="ln533">    --no_wait_return;</a>
<a name="ln534">  }</a>
<a name="ln535"> </a>
<a name="ln536">  /* don't try to open a swap file again */</a>
<a name="ln537">  buf-&gt;b_may_swap = false;</a>
<a name="ln538">}</a>
<a name="ln539"> </a>
<a name="ln540">/// If still need to create a swap file, and starting to edit a not-readonly</a>
<a name="ln541">/// file, or reading into an existing buffer, create a swap file now.</a>
<a name="ln542">///</a>
<a name="ln543">/// @param newfile reading file into new buffer</a>
<a name="ln544">void check_need_swap(bool newfile)</a>
<a name="ln545">{</a>
<a name="ln546">  int old_msg_silent = msg_silent;  // might be reset by an E325 message</a>
<a name="ln547">  msg_silent = 0;  // If swap dialog prompts for input, user needs to see it!</a>
<a name="ln548"> </a>
<a name="ln549">  if (curbuf-&gt;b_may_swap &amp;&amp; (!curbuf-&gt;b_p_ro || !newfile)) {</a>
<a name="ln550">    ml_open_file(curbuf);</a>
<a name="ln551">  }</a>
<a name="ln552"> </a>
<a name="ln553">  msg_silent = old_msg_silent;</a>
<a name="ln554">}</a>
<a name="ln555"> </a>
<a name="ln556">/*</a>
<a name="ln557"> * Close memline for buffer 'buf'.</a>
<a name="ln558"> * If 'del_file' is TRUE, delete the swap file</a>
<a name="ln559"> */</a>
<a name="ln560">void ml_close(buf_T *buf, int del_file)</a>
<a name="ln561">{</a>
<a name="ln562">  if (buf-&gt;b_ml.ml_mfp == NULL)                 /* not open */</a>
<a name="ln563">    return;</a>
<a name="ln564">  mf_close(buf-&gt;b_ml.ml_mfp, del_file);       /* close the .swp file */</a>
<a name="ln565">  if (buf-&gt;b_ml.ml_line_lnum != 0 &amp;&amp; (buf-&gt;b_ml.ml_flags &amp; ML_LINE_DIRTY))</a>
<a name="ln566">    xfree(buf-&gt;b_ml.ml_line_ptr);</a>
<a name="ln567">  xfree(buf-&gt;b_ml.ml_stack);</a>
<a name="ln568">  XFREE_CLEAR(buf-&gt;b_ml.ml_chunksize);</a>
<a name="ln569">  buf-&gt;b_ml.ml_mfp = NULL;</a>
<a name="ln570"> </a>
<a name="ln571">  /* Reset the &quot;recovered&quot; flag, give the ATTENTION prompt the next time</a>
<a name="ln572">   * this buffer is loaded. */</a>
<a name="ln573">  buf-&gt;b_flags &amp;= ~BF_RECOVERED;</a>
<a name="ln574">}</a>
<a name="ln575"> </a>
<a name="ln576">/*</a>
<a name="ln577"> * Close all existing memlines and memfiles.</a>
<a name="ln578"> * Only used when exiting.</a>
<a name="ln579"> * When 'del_file' is TRUE, delete the memfiles.</a>
<a name="ln580"> * But don't delete files that were &quot;:preserve&quot;d when we are POSIX compatible.</a>
<a name="ln581"> */</a>
<a name="ln582">void ml_close_all(int del_file)</a>
<a name="ln583">{</a>
<a name="ln584">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln585">    ml_close(buf, del_file &amp;&amp; ((buf-&gt;b_flags &amp; BF_PRESERVED) == 0));</a>
<a name="ln586">  }</a>
<a name="ln587">  spell_delete_wordlist();      /* delete the internal wordlist */</a>
<a name="ln588">  vim_deltempdir();             /* delete created temp directory */</a>
<a name="ln589">}</a>
<a name="ln590"> </a>
<a name="ln591">/*</a>
<a name="ln592"> * Close all memfiles for not modified buffers.</a>
<a name="ln593"> * Only use just before exiting!</a>
<a name="ln594"> */</a>
<a name="ln595">void ml_close_notmod(void)</a>
<a name="ln596">{</a>
<a name="ln597">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln598">    if (!bufIsChanged(buf)) {</a>
<a name="ln599">      ml_close(buf, TRUE);          /* close all not-modified buffers */</a>
<a name="ln600">    }</a>
<a name="ln601">  }</a>
<a name="ln602">}</a>
<a name="ln603"> </a>
<a name="ln604">/*</a>
<a name="ln605"> * Update the timestamp in the .swp file.</a>
<a name="ln606"> * Used when the file has been written.</a>
<a name="ln607"> */</a>
<a name="ln608">void ml_timestamp(buf_T *buf)</a>
<a name="ln609">{</a>
<a name="ln610">  ml_upd_block0(buf, UB_FNAME);</a>
<a name="ln611">}</a>
<a name="ln612"> </a>
<a name="ln613">/// Checks whether the IDs in b0 are valid.</a>
<a name="ln614">static bool ml_check_b0_id(ZERO_BL *b0p)</a>
<a name="ln615">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln616">{</a>
<a name="ln617">  return b0p-&gt;b0_id[0] == BLOCK0_ID0 &amp;&amp; b0p-&gt;b0_id[1] == BLOCK0_ID1;</a>
<a name="ln618">}</a>
<a name="ln619"> </a>
<a name="ln620">/// Checks whether all strings in b0 are valid (i.e. nul-terminated).</a>
<a name="ln621">static bool ml_check_b0_strings(ZERO_BL *b0p)</a>
<a name="ln622">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln623">{</a>
<a name="ln624">  return (memchr(b0p-&gt;b0_version, NUL, 10)</a>
<a name="ln625">          &amp;&amp; memchr(b0p-&gt;b0_uname, NUL, B0_UNAME_SIZE)</a>
<a name="ln626">          &amp;&amp; memchr(b0p-&gt;b0_hname, NUL, B0_HNAME_SIZE)</a>
<a name="ln627">          &amp;&amp; memchr(b0p-&gt;b0_fname, NUL, B0_FNAME_SIZE_CRYPT));  // -V512</a>
<a name="ln628">}</a>
<a name="ln629"> </a>
<a name="ln630">/*</a>
<a name="ln631"> * Update the timestamp or the B0_SAME_DIR flag of the .swp file.</a>
<a name="ln632"> */</a>
<a name="ln633">static void ml_upd_block0(buf_T *buf, upd_block0_T what)</a>
<a name="ln634">{</a>
<a name="ln635">  memfile_T   *mfp;</a>
<a name="ln636">  bhdr_T      *hp;</a>
<a name="ln637">  ZERO_BL     *b0p;</a>
<a name="ln638"> </a>
<a name="ln639">  mfp = buf-&gt;b_ml.ml_mfp;</a>
<a name="ln640">  if (mfp == NULL || (hp = mf_get(mfp, 0, 1)) == NULL)</a>
<a name="ln641">    return;</a>
<a name="ln642">  b0p = hp-&gt;bh_data;</a>
<a name="ln643">  if (ml_check_b0_id(b0p) == FAIL) {</a>
<a name="ln644">    IEMSG(_(&quot;E304: ml_upd_block0(): Didn't get block 0??&quot;));</a>
<a name="ln645">  } else {</a>
<a name="ln646">    if (what == UB_FNAME) {</a>
<a name="ln647">      set_b0_fname(b0p, buf);</a>
<a name="ln648">    } else {    // what == UB_SAME_DIR</a>
<a name="ln649">      set_b0_dir_flag(b0p, buf);</a>
<a name="ln650">    }</a>
<a name="ln651">  }</a>
<a name="ln652">  mf_put(mfp, hp, true, false);</a>
<a name="ln653">}</a>
<a name="ln654"> </a>
<a name="ln655">/*</a>
<a name="ln656"> * Write file name and timestamp into block 0 of a swap file.</a>
<a name="ln657"> * Also set buf-&gt;b_mtime.</a>
<a name="ln658"> * Don't use NameBuff[]!!!</a>
<a name="ln659"> */</a>
<a name="ln660">static void set_b0_fname(ZERO_BL *b0p, buf_T *buf)</a>
<a name="ln661">{</a>
<a name="ln662">  if (buf-&gt;b_ffname == NULL)</a>
<a name="ln663">    b0p-&gt;b0_fname[0] = NUL;</a>
<a name="ln664">  else {</a>
<a name="ln665">    char uname[B0_UNAME_SIZE];</a>
<a name="ln666"> </a>
<a name="ln667">    /*</a>
<a name="ln668">     * For a file under the home directory of the current user, we try to</a>
<a name="ln669">     * replace the home directory path with &quot;~user&quot;. This helps when</a>
<a name="ln670">     * editing the same file on different machines over a network.</a>
<a name="ln671">     * First replace home dir path with &quot;~/&quot; with home_replace().</a>
<a name="ln672">     * Then insert the user name to get &quot;~user/&quot;.</a>
<a name="ln673">     */</a>
<a name="ln674">    home_replace(NULL, buf-&gt;b_ffname, b0p-&gt;b0_fname,</a>
<a name="ln675">        B0_FNAME_SIZE_CRYPT, TRUE);</a>
<a name="ln676">    if (b0p-&gt;b0_fname[0] == '~') {</a>
<a name="ln677">      /* If there is no user name or it is too long, don't use &quot;~/&quot; */</a>
<a name="ln678">      int retval = os_get_user_name(uname, B0_UNAME_SIZE);</a>
<a name="ln679">      size_t ulen = STRLEN(uname);</a>
<a name="ln680">      size_t flen = STRLEN(b0p-&gt;b0_fname);</a>
<a name="ln681">      if (retval == FAIL || ulen + flen &gt; B0_FNAME_SIZE_CRYPT - 1) {</a>
<a name="ln682">        STRLCPY(b0p-&gt;b0_fname, buf-&gt;b_ffname, B0_FNAME_SIZE_CRYPT);</a>
<a name="ln683">      } else {</a>
<a name="ln684">        memmove(b0p-&gt;b0_fname + ulen + 1, b0p-&gt;b0_fname + 1, flen);</a>
<a name="ln685">        memmove(b0p-&gt;b0_fname + 1, uname, ulen);</a>
<a name="ln686">      }</a>
<a name="ln687">    }</a>
<a name="ln688">    FileInfo file_info;</a>
<a name="ln689">    if (os_fileinfo((char *)buf-&gt;b_ffname, &amp;file_info)) {</a>
<a name="ln690">      long_to_char(file_info.stat.st_mtim.tv_sec, b0p-&gt;b0_mtime);</a>
<a name="ln691">      long_to_char((long)os_fileinfo_inode(&amp;file_info), b0p-&gt;b0_ino);</a>
<a name="ln692">      buf_store_file_info(buf, &amp;file_info);</a>
<a name="ln693">      buf-&gt;b_mtime_read = buf-&gt;b_mtime;</a>
<a name="ln694">    } else {</a>
<a name="ln695">      long_to_char(0L, b0p-&gt;b0_mtime);</a>
<a name="ln696">      long_to_char(0L, b0p-&gt;b0_ino);</a>
<a name="ln697">      buf-&gt;b_mtime = 0;</a>
<a name="ln698">      buf-&gt;b_mtime_read = 0;</a>
<a name="ln699">      buf-&gt;b_orig_size = 0;</a>
<a name="ln700">      buf-&gt;b_orig_mode = 0;</a>
<a name="ln701">    }</a>
<a name="ln702">  }</a>
<a name="ln703"> </a>
<a name="ln704">  /* Also add the 'fileencoding' if there is room. */</a>
<a name="ln705">  add_b0_fenc(b0p, curbuf);</a>
<a name="ln706">}</a>
<a name="ln707"> </a>
<a name="ln708">/*</a>
<a name="ln709"> * Update the B0_SAME_DIR flag of the swap file.  It's set if the file and the</a>
<a name="ln710"> * swapfile for &quot;buf&quot; are in the same directory.</a>
<a name="ln711"> * This is fail safe: if we are not sure the directories are equal the flag is</a>
<a name="ln712"> * not set.</a>
<a name="ln713"> */</a>
<a name="ln714">static void set_b0_dir_flag(ZERO_BL *b0p, buf_T *buf)</a>
<a name="ln715">{</a>
<a name="ln716">  if (same_directory(buf-&gt;b_ml.ml_mfp-&gt;mf_fname, buf-&gt;b_ffname))</a>
<a name="ln717">    b0p-&gt;b0_flags |= B0_SAME_DIR;</a>
<a name="ln718">  else</a>
<a name="ln719">    b0p-&gt;b0_flags &amp;= ~B0_SAME_DIR;</a>
<a name="ln720">}</a>
<a name="ln721"> </a>
<a name="ln722">/*</a>
<a name="ln723"> * When there is room, add the 'fileencoding' to block zero.</a>
<a name="ln724"> */</a>
<a name="ln725">static void add_b0_fenc(ZERO_BL *b0p, buf_T *buf)</a>
<a name="ln726">{</a>
<a name="ln727">  int n;</a>
<a name="ln728">  int size = B0_FNAME_SIZE_NOCRYPT;</a>
<a name="ln729"> </a>
<a name="ln730">  n = (int)STRLEN(buf-&gt;b_p_fenc);</a>
<a name="ln731">  if ((int)STRLEN(b0p-&gt;b0_fname) + n + 1 &gt; size)</a>
<a name="ln732">    b0p-&gt;b0_flags &amp;= ~B0_HAS_FENC;</a>
<a name="ln733">  else {</a>
<a name="ln734">    memmove((char *)b0p-&gt;b0_fname + size - n,</a>
<a name="ln735">        (char *)buf-&gt;b_p_fenc, (size_t)n);</a>
<a name="ln736">    *(b0p-&gt;b0_fname + size - n - 1) = NUL;</a>
<a name="ln737">    b0p-&gt;b0_flags |= B0_HAS_FENC;</a>
<a name="ln738">  }</a>
<a name="ln739">}</a>
<a name="ln740"> </a>
<a name="ln741"> </a>
<a name="ln742">/// Try to recover curbuf from the .swp file.</a>
<a name="ln743">/// @param checkext If true, check the extension and detect whether it is a</a>
<a name="ln744">/// swap file.</a>
<a name="ln745">void ml_recover(bool checkext)</a>
<a name="ln746">{</a>
<a name="ln747">  buf_T       *buf = NULL;</a>
<a name="ln748">  memfile_T   *mfp = NULL;</a>
<a name="ln749">  char_u      *fname;</a>
<a name="ln750">  char_u      *fname_used = NULL;</a>
<a name="ln751">  bhdr_T      *hp = NULL;</a>
<a name="ln752">  ZERO_BL     *b0p;</a>
<a name="ln753">  int b0_ff;</a>
<a name="ln754">  char_u      *b0_fenc = NULL;</a>
<a name="ln755">  PTR_BL      *pp;</a>
<a name="ln756">  DATA_BL     *dp;</a>
<a name="ln757">  infoptr_T   *ip;</a>
<a name="ln758">  blocknr_T bnum;</a>
<a name="ln759">  int page_count;</a>
<a name="ln760">  int len;</a>
<a name="ln761">  int directly;</a>
<a name="ln762">  linenr_T lnum;</a>
<a name="ln763">  char_u      *p;</a>
<a name="ln764">  int i;</a>
<a name="ln765">  long error;</a>
<a name="ln766">  int cannot_open;</a>
<a name="ln767">  linenr_T line_count;</a>
<a name="ln768">  bool has_error;</a>
<a name="ln769">  int idx;</a>
<a name="ln770">  int top;</a>
<a name="ln771">  int txt_start;</a>
<a name="ln772">  off_T size;</a>
<a name="ln773">  int called_from_main;</a>
<a name="ln774">  int serious_error = TRUE;</a>
<a name="ln775">  long mtime;</a>
<a name="ln776">  int attr;</a>
<a name="ln777">  int orig_file_status = NOTDONE;</a>
<a name="ln778"> </a>
<a name="ln779">  recoverymode = TRUE;</a>
<a name="ln780">  called_from_main = (curbuf-&gt;b_ml.ml_mfp == NULL);</a>
<a name="ln781">  attr = HL_ATTR(HLF_E);</a>
<a name="ln782"> </a>
<a name="ln783">  // If the file name ends in &quot;.s[a-w][a-z]&quot; we assume this is the swap file.</a>
<a name="ln784">  // Otherwise a search is done to find the swap file(s).</a>
<a name="ln785">  fname = curbuf-&gt;b_fname;</a>
<a name="ln786">  if (fname == NULL)                /* When there is no file name */</a>
<a name="ln787">    fname = (char_u *)&quot;&quot;;</a>
<a name="ln788">  len = (int)STRLEN(fname);</a>
<a name="ln789">  if (checkext &amp;&amp; len &gt;= 4</a>
<a name="ln790">      &amp;&amp; STRNICMP(fname + len - 4, &quot;.s&quot;, 2) == 0</a>
<a name="ln791">      &amp;&amp; vim_strchr((char_u *)&quot;abcdefghijklmnopqrstuvw&quot;,</a>
<a name="ln792">                    TOLOWER_ASC(fname[len - 2])) != NULL</a>
<a name="ln793">      &amp;&amp; ASCII_ISALPHA(fname[len - 1])) {</a>
<a name="ln794">    directly = TRUE;</a>
<a name="ln795">    fname_used = vim_strsave(fname);     /* make a copy for mf_open() */</a>
<a name="ln796">  } else {</a>
<a name="ln797">    directly = FALSE;</a>
<a name="ln798"> </a>
<a name="ln799">    /* count the number of matching swap files */</a>
<a name="ln800">    len = recover_names(fname, FALSE, 0, NULL);</a>
<a name="ln801">    if (len == 0) {                 /* no swap files found */</a>
<a name="ln802">      EMSG2(_(&quot;E305: No swap file found for %s&quot;), fname);</a>
<a name="ln803">      goto theend;</a>
<a name="ln804">    }</a>
<a name="ln805">    if (len == 1)                   /* one swap file found, use it */</a>
<a name="ln806">      i = 1;</a>
<a name="ln807">    else {                          /* several swap files found, choose */</a>
<a name="ln808">      /* list the names of the swap files */</a>
<a name="ln809">      (void)recover_names(fname, TRUE, 0, NULL);</a>
<a name="ln810">      msg_putchar('\n');</a>
<a name="ln811">      MSG_PUTS(_(&quot;Enter number of swap file to use (0 to quit): &quot;));</a>
<a name="ln812">      i = get_number(FALSE, NULL);</a>
<a name="ln813">      if (i &lt; 1 || i &gt; len)</a>
<a name="ln814">        goto theend;</a>
<a name="ln815">    }</a>
<a name="ln816">    /* get the swap file name that will be used */</a>
<a name="ln817">    (void)recover_names(fname, FALSE, i, &amp;fname_used);</a>
<a name="ln818">  }</a>
<a name="ln819">  if (fname_used == NULL)</a>
<a name="ln820">    goto theend;  // user chose invalid number.</a>
<a name="ln821"> </a>
<a name="ln822">  /* When called from main() still need to initialize storage structure */</a>
<a name="ln823">  if (called_from_main &amp;&amp; ml_open(curbuf) == FAIL)</a>
<a name="ln824">    getout(1);</a>
<a name="ln825"> </a>
<a name="ln826">  /*</a>
<a name="ln827">   * Allocate a buffer structure for the swap file that is used for recovery.</a>
<a name="ln828">   * Only the memline in it is really used.</a>
<a name="ln829">   */</a>
<a name="ln830">  buf = xmalloc(sizeof(buf_T));</a>
<a name="ln831"> </a>
<a name="ln832">  /*</a>
<a name="ln833">   * init fields in memline struct</a>
<a name="ln834">   */</a>
<a name="ln835">  buf-&gt;b_ml.ml_stack_size = 0;          // no stack yet</a>
<a name="ln836">  buf-&gt;b_ml.ml_stack = NULL;            // no stack yet</a>
<a name="ln837">  buf-&gt;b_ml.ml_stack_top = 0;           // nothing in the stack</a>
<a name="ln838">  buf-&gt;b_ml.ml_line_lnum = 0;           // no cached line</a>
<a name="ln839">  buf-&gt;b_ml.ml_line_offset = 0;</a>
<a name="ln840">  buf-&gt;b_ml.ml_locked = NULL;           // no locked block</a>
<a name="ln841">  buf-&gt;b_ml.ml_flags = 0;</a>
<a name="ln842"> </a>
<a name="ln843">  /*</a>
<a name="ln844">   * open the memfile from the old swap file</a>
<a name="ln845">   */</a>
<a name="ln846">  p = vim_strsave(fname_used);   /* save &quot;fname_used&quot; for the message:</a>
<a name="ln847">                                    mf_open() will consume &quot;fname_used&quot;! */</a>
<a name="ln848">  mfp = mf_open(fname_used, O_RDONLY);</a>
<a name="ln849">  fname_used = p;</a>
<a name="ln850">  if (mfp == NULL || mfp-&gt;mf_fd &lt; 0) {</a>
<a name="ln851">    EMSG2(_(&quot;E306: Cannot open %s&quot;), fname_used);</a>
<a name="ln852">    goto theend;</a>
<a name="ln853">  }</a>
<a name="ln854">  buf-&gt;b_ml.ml_mfp = mfp;</a>
<a name="ln855"> </a>
<a name="ln856">  /*</a>
<a name="ln857">   * The page size set in mf_open() might be different from the page size</a>
<a name="ln858">   * used in the swap file, we must get it from block 0.  But to read block</a>
<a name="ln859">   * 0 we need a page size.  Use the minimal size for block 0 here, it will</a>
<a name="ln860">   * be set to the real value below.</a>
<a name="ln861">   */</a>
<a name="ln862">  mfp-&gt;mf_page_size = MIN_SWAP_PAGE_SIZE;</a>
<a name="ln863"> </a>
<a name="ln864">  /*</a>
<a name="ln865">   * try to read block 0</a>
<a name="ln866">   */</a>
<a name="ln867">  if ((hp = mf_get(mfp, 0, 1)) == NULL) {</a>
<a name="ln868">    msg_start();</a>
<a name="ln869">    MSG_PUTS_ATTR(_(&quot;Unable to read block 0 from &quot;), attr | MSG_HIST);</a>
<a name="ln870">    msg_outtrans_attr(mfp-&gt;mf_fname, attr | MSG_HIST);</a>
<a name="ln871">    MSG_PUTS_ATTR(_(</a>
<a name="ln872">            &quot;\nMaybe no changes were made or Vim did not update the swap file.&quot;),</a>
<a name="ln873">        attr | MSG_HIST);</a>
<a name="ln874">    msg_end();</a>
<a name="ln875">    goto theend;</a>
<a name="ln876">  }</a>
<a name="ln877">  b0p = hp-&gt;bh_data;</a>
<a name="ln878">  if (STRNCMP(b0p-&gt;b0_version, &quot;VIM 3.0&quot;, 7) == 0) {</a>
<a name="ln879">    msg_start();</a>
<a name="ln880">    msg_outtrans_attr(mfp-&gt;mf_fname, MSG_HIST);</a>
<a name="ln881">    MSG_PUTS_ATTR(_(&quot; cannot be used with this version of Vim.\n&quot;),</a>
<a name="ln882">        MSG_HIST);</a>
<a name="ln883">    MSG_PUTS_ATTR(_(&quot;Use Vim version 3.0.\n&quot;), MSG_HIST);</a>
<a name="ln884">    msg_end();</a>
<a name="ln885">    goto theend;</a>
<a name="ln886">  }</a>
<a name="ln887">  if (ml_check_b0_id(b0p) == FAIL) {</a>
<a name="ln888">    EMSG2(_(&quot;E307: %s does not look like a Vim swap file&quot;), mfp-&gt;mf_fname);</a>
<a name="ln889">    goto theend;</a>
<a name="ln890">  }</a>
<a name="ln891">  if (b0_magic_wrong(b0p)) {</a>
<a name="ln892">    msg_start();</a>
<a name="ln893">    msg_outtrans_attr(mfp-&gt;mf_fname, attr | MSG_HIST);</a>
<a name="ln894">    MSG_PUTS_ATTR(_(&quot; cannot be used on this computer.\n&quot;),</a>
<a name="ln895">        attr | MSG_HIST);</a>
<a name="ln896">    MSG_PUTS_ATTR(_(&quot;The file was created on &quot;), attr | MSG_HIST);</a>
<a name="ln897">    /* avoid going past the end of a corrupted hostname */</a>
<a name="ln898">    b0p-&gt;b0_fname[0] = NUL;</a>
<a name="ln899">    MSG_PUTS_ATTR(b0p-&gt;b0_hname, attr | MSG_HIST);</a>
<a name="ln900">    MSG_PUTS_ATTR(_(&quot;,\nor the file has been damaged.&quot;), attr | MSG_HIST);</a>
<a name="ln901">    msg_end();</a>
<a name="ln902">    goto theend;</a>
<a name="ln903">  }</a>
<a name="ln904"> </a>
<a name="ln905">  /*</a>
<a name="ln906">   * If we guessed the wrong page size, we have to recalculate the</a>
<a name="ln907">   * highest block number in the file.</a>
<a name="ln908">   */</a>
<a name="ln909">  if (mfp-&gt;mf_page_size != (unsigned)char_to_long(b0p-&gt;b0_page_size)) {</a>
<a name="ln910">    unsigned previous_page_size = mfp-&gt;mf_page_size;</a>
<a name="ln911"> </a>
<a name="ln912">    mf_new_page_size(mfp, (unsigned)char_to_long(b0p-&gt;b0_page_size));</a>
<a name="ln913">    if (mfp-&gt;mf_page_size &lt; previous_page_size) {</a>
<a name="ln914">      msg_start();</a>
<a name="ln915">      msg_outtrans_attr(mfp-&gt;mf_fname, attr | MSG_HIST);</a>
<a name="ln916">      MSG_PUTS_ATTR(_(</a>
<a name="ln917">              &quot; has been damaged (page size is smaller than minimum value).\n&quot;),</a>
<a name="ln918">          attr | MSG_HIST);</a>
<a name="ln919">      msg_end();</a>
<a name="ln920">      goto theend;</a>
<a name="ln921">    }</a>
<a name="ln922">    if ((size = vim_lseek(mfp-&gt;mf_fd, (off_T)0L, SEEK_END)) &lt;= 0) {</a>
<a name="ln923">      mfp-&gt;mf_blocknr_max = 0;              // no file or empty file</a>
<a name="ln924">    } else {</a>
<a name="ln925">      mfp-&gt;mf_blocknr_max = size / mfp-&gt;mf_page_size;</a>
<a name="ln926">    }</a>
<a name="ln927">    mfp-&gt;mf_infile_count = mfp-&gt;mf_blocknr_max;</a>
<a name="ln928"> </a>
<a name="ln929">    /* need to reallocate the memory used to store the data */</a>
<a name="ln930">    p = xmalloc(mfp-&gt;mf_page_size);</a>
<a name="ln931">    memmove(p, hp-&gt;bh_data, previous_page_size);</a>
<a name="ln932">    xfree(hp-&gt;bh_data);</a>
<a name="ln933">    hp-&gt;bh_data = p;</a>
<a name="ln934">    b0p = hp-&gt;bh_data;</a>
<a name="ln935">  }</a>
<a name="ln936"> </a>
<a name="ln937">  /*</a>
<a name="ln938">   * If .swp file name given directly, use name from swap file for buffer.</a>
<a name="ln939">   */</a>
<a name="ln940">  if (directly) {</a>
<a name="ln941">    expand_env(b0p-&gt;b0_fname, NameBuff, MAXPATHL);</a>
<a name="ln942">    if (setfname(curbuf, NameBuff, NULL, true) == FAIL) {</a>
<a name="ln943">      goto theend;</a>
<a name="ln944">    }</a>
<a name="ln945">  }</a>
<a name="ln946"> </a>
<a name="ln947">  home_replace(NULL, mfp-&gt;mf_fname, NameBuff, MAXPATHL, TRUE);</a>
<a name="ln948">  smsg(_(&quot;Using swap file \&quot;%s\&quot;&quot;), NameBuff);</a>
<a name="ln949"> </a>
<a name="ln950">  if (buf_spname(curbuf) != NULL)</a>
<a name="ln951">    STRLCPY(NameBuff, buf_spname(curbuf), MAXPATHL);</a>
<a name="ln952">  else</a>
<a name="ln953">    home_replace(NULL, curbuf-&gt;b_ffname, NameBuff, MAXPATHL, TRUE);</a>
<a name="ln954">  smsg(_(&quot;Original file \&quot;%s\&quot;&quot;), NameBuff);</a>
<a name="ln955">  msg_putchar('\n');</a>
<a name="ln956"> </a>
<a name="ln957">  /*</a>
<a name="ln958">   * check date of swap file and original file</a>
<a name="ln959">   */</a>
<a name="ln960">  FileInfo org_file_info;</a>
<a name="ln961">  FileInfo swp_file_info;</a>
<a name="ln962">  mtime = char_to_long(b0p-&gt;b0_mtime);</a>
<a name="ln963">  if (curbuf-&gt;b_ffname != NULL</a>
<a name="ln964">      &amp;&amp; os_fileinfo((char *)curbuf-&gt;b_ffname, &amp;org_file_info)</a>
<a name="ln965">      &amp;&amp; ((os_fileinfo((char *)mfp-&gt;mf_fname, &amp;swp_file_info)</a>
<a name="ln966">           &amp;&amp; org_file_info.stat.st_mtim.tv_sec</a>
<a name="ln967">              &gt; swp_file_info.stat.st_mtim.tv_sec)</a>
<a name="ln968">          || org_file_info.stat.st_mtim.tv_sec != mtime)) {</a>
<a name="ln969">    EMSG(_(&quot;E308: Warning: Original file may have been changed&quot;));</a>
<a name="ln970">  }</a>
<a name="ln971">  ui_flush();</a>
<a name="ln972"> </a>
<a name="ln973">  /* Get the 'fileformat' and 'fileencoding' from block zero. */</a>
<a name="ln974">  b0_ff = (b0p-&gt;b0_flags &amp; B0_FF_MASK);</a>
<a name="ln975">  if (b0p-&gt;b0_flags &amp; B0_HAS_FENC) {</a>
<a name="ln976">    int fnsize = B0_FNAME_SIZE_NOCRYPT;</a>
<a name="ln977"> </a>
<a name="ln978">    for (p = b0p-&gt;b0_fname + fnsize; p &gt; b0p-&gt;b0_fname &amp;&amp; p[-1] != NUL; p--) {</a>
<a name="ln979">    }</a>
<a name="ln980">    b0_fenc = vim_strnsave(p, b0p-&gt;b0_fname + fnsize - p);</a>
<a name="ln981">  }</a>
<a name="ln982"> </a>
<a name="ln983">  mf_put(mfp, hp, false, false);        /* release block 0 */</a>
<a name="ln984">  hp = NULL;</a>
<a name="ln985"> </a>
<a name="ln986">  /*</a>
<a name="ln987">   * Now that we are sure that the file is going to be recovered, clear the</a>
<a name="ln988">   * contents of the current buffer.</a>
<a name="ln989">   */</a>
<a name="ln990">  while (!(curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY)) {</a>
<a name="ln991">    ml_delete((linenr_T)1, false);</a>
<a name="ln992">  }</a>
<a name="ln993"> </a>
<a name="ln994">  /*</a>
<a name="ln995">   * Try reading the original file to obtain the values of 'fileformat',</a>
<a name="ln996">   * 'fileencoding', etc.  Ignore errors.  The text itself is not used.</a>
<a name="ln997">   */</a>
<a name="ln998">  if (curbuf-&gt;b_ffname != NULL)</a>
<a name="ln999">    orig_file_status = readfile(curbuf-&gt;b_ffname, NULL, (linenr_T)0,</a>
<a name="ln1000">        (linenr_T)0, (linenr_T)MAXLNUM, NULL, READ_NEW);</a>
<a name="ln1001"> </a>
<a name="ln1002">  /* Use the 'fileformat' and 'fileencoding' as stored in the swap file. */</a>
<a name="ln1003">  if (b0_ff != 0)</a>
<a name="ln1004">    set_fileformat(b0_ff - 1, OPT_LOCAL);</a>
<a name="ln1005">  if (b0_fenc != NULL) {</a>
<a name="ln1006">    set_option_value(&quot;fenc&quot;, 0L, (char *)b0_fenc, OPT_LOCAL);</a>
<a name="ln1007">    xfree(b0_fenc);</a>
<a name="ln1008">  }</a>
<a name="ln1009">  unchanged(curbuf, true, true);</a>
<a name="ln1010"> </a>
<a name="ln1011">  bnum = 1;             /* start with block 1 */</a>
<a name="ln1012">  page_count = 1;       /* which is 1 page */</a>
<a name="ln1013">  lnum = 0;             /* append after line 0 in curbuf */</a>
<a name="ln1014">  line_count = 0;</a>
<a name="ln1015">  idx = 0;              /* start with first index in block 1 */</a>
<a name="ln1016">  error = 0;</a>
<a name="ln1017">  buf-&gt;b_ml.ml_stack_top = 0;</a>
<a name="ln1018">  buf-&gt;b_ml.ml_stack = NULL;</a>
<a name="ln1019">  buf-&gt;b_ml.ml_stack_size = 0;          /* no stack yet */</a>
<a name="ln1020"> </a>
<a name="ln1021">  if (curbuf-&gt;b_ffname == NULL)</a>
<a name="ln1022">    cannot_open = TRUE;</a>
<a name="ln1023">  else</a>
<a name="ln1024">    cannot_open = FALSE;</a>
<a name="ln1025"> </a>
<a name="ln1026">  serious_error = FALSE;</a>
<a name="ln1027">  for (; !got_int; line_breakcheck()) {</a>
<a name="ln1028">    if (hp != NULL)</a>
<a name="ln1029">      mf_put(mfp, hp, false, false);            /* release previous block */</a>
<a name="ln1030"> </a>
<a name="ln1031">    /*</a>
<a name="ln1032">     * get block</a>
<a name="ln1033">     */</a>
<a name="ln1034">    if ((hp = mf_get(mfp, bnum, page_count)) == NULL) {</a>
<a name="ln1035">      if (bnum == 1) {</a>
<a name="ln1036">        EMSG2(_(&quot;E309: Unable to read block 1 from %s&quot;), mfp-&gt;mf_fname);</a>
<a name="ln1037">        goto theend;</a>
<a name="ln1038">      }</a>
<a name="ln1039">      ++error;</a>
<a name="ln1040">      ml_append(lnum++, (char_u *)_(&quot;???MANY LINES MISSING&quot;),</a>
<a name="ln1041">                (colnr_T)0, true);</a>
<a name="ln1042">    } else {          // there is a block</a>
<a name="ln1043">      pp = hp-&gt;bh_data;</a>
<a name="ln1044">      if (pp-&gt;pb_id == PTR_ID) {                /* it is a pointer block */</a>
<a name="ln1045">        /* check line count when using pointer block first time */</a>
<a name="ln1046">        if (idx == 0 &amp;&amp; line_count != 0) {</a>
<a name="ln1047">          for (i = 0; i &lt; (int)pp-&gt;pb_count; ++i)</a>
<a name="ln1048">            line_count -= pp-&gt;pb_pointer[i].pe_line_count;</a>
<a name="ln1049">          if (line_count != 0) {</a>
<a name="ln1050">            ++error;</a>
<a name="ln1051">            ml_append(lnum++, (char_u *)_(&quot;???LINE COUNT WRONG&quot;),</a>
<a name="ln1052">                      (colnr_T)0, true);</a>
<a name="ln1053">          }</a>
<a name="ln1054">        }</a>
<a name="ln1055"> </a>
<a name="ln1056">        if (pp-&gt;pb_count == 0) {</a>
<a name="ln1057">          ml_append(lnum++, (char_u *)_(&quot;???EMPTY BLOCK&quot;),</a>
<a name="ln1058">                    (colnr_T)0, true);</a>
<a name="ln1059">          error++;</a>
<a name="ln1060">        } else if (idx &lt; (int)pp-&gt;pb_count) {         // go a block deeper</a>
<a name="ln1061">          if (pp-&gt;pb_pointer[idx].pe_bnum &lt; 0) {</a>
<a name="ln1062">            /*</a>
<a name="ln1063">             * Data block with negative block number.</a>
<a name="ln1064">             * Try to read lines from the original file.</a>
<a name="ln1065">             * This is slow, but it works.</a>
<a name="ln1066">             */</a>
<a name="ln1067">            if (!cannot_open) {</a>
<a name="ln1068">              line_count = pp-&gt;pb_pointer[idx].pe_line_count;</a>
<a name="ln1069">              if (readfile(curbuf-&gt;b_ffname, NULL, lnum,</a>
<a name="ln1070">                           pp-&gt;pb_pointer[idx].pe_old_lnum - 1, line_count,</a>
<a name="ln1071">                           NULL, 0) != OK) {</a>
<a name="ln1072">                cannot_open = true;</a>
<a name="ln1073">              } else {</a>
<a name="ln1074">                lnum += line_count;</a>
<a name="ln1075">              }</a>
<a name="ln1076">            }</a>
<a name="ln1077">            if (cannot_open) {</a>
<a name="ln1078">              ++error;</a>
<a name="ln1079">              ml_append(lnum++, (char_u *)_(&quot;???LINES MISSING&quot;),</a>
<a name="ln1080">                        (colnr_T)0, true);</a>
<a name="ln1081">            }</a>
<a name="ln1082">            ++idx;                  /* get same block again for next index */</a>
<a name="ln1083">            continue;</a>
<a name="ln1084">          }</a>
<a name="ln1085"> </a>
<a name="ln1086">          /*</a>
<a name="ln1087">           * going one block deeper in the tree</a>
<a name="ln1088">           */</a>
<a name="ln1089">          top = ml_add_stack(buf);  // new entry in stack</a>
<a name="ln1090">          ip = &amp;(buf-&gt;b_ml.ml_stack[top]);</a>
<a name="ln1091">          ip-&gt;ip_bnum = bnum;</a>
<a name="ln1092">          ip-&gt;ip_index = idx;</a>
<a name="ln1093"> </a>
<a name="ln1094">          bnum = pp-&gt;pb_pointer[idx].pe_bnum;</a>
<a name="ln1095">          line_count = pp-&gt;pb_pointer[idx].pe_line_count;</a>
<a name="ln1096">          page_count = pp-&gt;pb_pointer[idx].pe_page_count;</a>
<a name="ln1097">          idx = 0;</a>
<a name="ln1098">          continue;</a>
<a name="ln1099">        }</a>
<a name="ln1100">      } else {            /* not a pointer block */</a>
<a name="ln1101">        dp = hp-&gt;bh_data;</a>
<a name="ln1102">        if (dp-&gt;db_id != DATA_ID) {             /* block id wrong */</a>
<a name="ln1103">          if (bnum == 1) {</a>
<a name="ln1104">            EMSG2(_(&quot;E310: Block 1 ID wrong (%s not a .swp file?)&quot;),</a>
<a name="ln1105">                mfp-&gt;mf_fname);</a>
<a name="ln1106">            goto theend;</a>
<a name="ln1107">          }</a>
<a name="ln1108">          ++error;</a>
<a name="ln1109">          ml_append(lnum++, (char_u *)_(&quot;???BLOCK MISSING&quot;),</a>
<a name="ln1110">                    (colnr_T)0, true);</a>
<a name="ln1111">        } else {</a>
<a name="ln1112">          // it is a data block</a>
<a name="ln1113">          // Append all the lines in this block</a>
<a name="ln1114">          has_error = false;</a>
<a name="ln1115">          // check length of block</a>
<a name="ln1116">          // if wrong, use length in pointer block</a>
<a name="ln1117">          if (page_count * mfp-&gt;mf_page_size != dp-&gt;db_txt_end) {</a>
<a name="ln1118">            ml_append(</a>
<a name="ln1119">                lnum++,</a>
<a name="ln1120">                (char_u *)_(&quot;??? from here until ???END lines&quot;</a>
<a name="ln1121">                            &quot; may be messed up&quot;),</a>
<a name="ln1122">                (colnr_T)0, true);</a>
<a name="ln1123">            error++;</a>
<a name="ln1124">            has_error = true;</a>
<a name="ln1125">            dp-&gt;db_txt_end = page_count * mfp-&gt;mf_page_size;</a>
<a name="ln1126">          }</a>
<a name="ln1127"> </a>
<a name="ln1128">          /* make sure there is a NUL at the end of the block */</a>
<a name="ln1129">          *((char_u *)dp + dp-&gt;db_txt_end - 1) = NUL;</a>
<a name="ln1130"> </a>
<a name="ln1131">          /*</a>
<a name="ln1132">           * check number of lines in block</a>
<a name="ln1133">           * if wrong, use count in data block</a>
<a name="ln1134">           */</a>
<a name="ln1135">          if (line_count != dp-&gt;db_line_count) {</a>
<a name="ln1136">            ml_append(</a>
<a name="ln1137">                lnum++,</a>
<a name="ln1138">                (char_u *)_(&quot;??? from here until ???END lines&quot;</a>
<a name="ln1139">                            &quot; may have been inserted/deleted&quot;),</a>
<a name="ln1140">                (colnr_T)0, true);</a>
<a name="ln1141">            error++;</a>
<a name="ln1142">            has_error = true;</a>
<a name="ln1143">          }</a>
<a name="ln1144"> </a>
<a name="ln1145">          for (i = 0; i &lt; dp-&gt;db_line_count; ++i) {</a>
<a name="ln1146">            txt_start = (dp-&gt;db_index[i] &amp; DB_INDEX_MASK);</a>
<a name="ln1147">            if (txt_start &lt;= (int)HEADER_SIZE</a>
<a name="ln1148">                || txt_start &gt;= (int)dp-&gt;db_txt_end) {</a>
<a name="ln1149">              p = (char_u *)&quot;???&quot;;</a>
<a name="ln1150">              ++error;</a>
<a name="ln1151">            } else</a>
<a name="ln1152">              p = (char_u *)dp + txt_start;</a>
<a name="ln1153">            ml_append(lnum++, p, (colnr_T)0, true);</a>
<a name="ln1154">          }</a>
<a name="ln1155">          if (has_error) {</a>
<a name="ln1156">            ml_append(lnum++, (char_u *)_(&quot;???END&quot;), (colnr_T)0, true);</a>
<a name="ln1157">          }</a>
<a name="ln1158">        }</a>
<a name="ln1159">      }</a>
<a name="ln1160">    }</a>
<a name="ln1161"> </a>
<a name="ln1162">    if (buf-&gt;b_ml.ml_stack_top == 0)            /* finished */</a>
<a name="ln1163">      break;</a>
<a name="ln1164"> </a>
<a name="ln1165">    /*</a>
<a name="ln1166">     * go one block up in the tree</a>
<a name="ln1167">     */</a>
<a name="ln1168">    ip = &amp;(buf-&gt;b_ml.ml_stack[--(buf-&gt;b_ml.ml_stack_top)]);</a>
<a name="ln1169">    bnum = ip-&gt;ip_bnum;</a>
<a name="ln1170">    idx = ip-&gt;ip_index + 1;         /* go to next index */</a>
<a name="ln1171">    page_count = 1;</a>
<a name="ln1172">  }</a>
<a name="ln1173"> </a>
<a name="ln1174">  /*</a>
<a name="ln1175">   * Compare the buffer contents with the original file.  When they differ</a>
<a name="ln1176">   * set the 'modified' flag.</a>
<a name="ln1177">   * Lines 1 - lnum are the new contents.</a>
<a name="ln1178">   * Lines lnum + 1 to ml_line_count are the original contents.</a>
<a name="ln1179">   * Line ml_line_count + 1 in the dummy empty line.</a>
<a name="ln1180">   */</a>
<a name="ln1181">  if (orig_file_status != OK || curbuf-&gt;b_ml.ml_line_count != lnum * 2 + 1) {</a>
<a name="ln1182">    /* Recovering an empty file results in two lines and the first line is</a>
<a name="ln1183">     * empty.  Don't set the modified flag then. */</a>
<a name="ln1184">    if (!(curbuf-&gt;b_ml.ml_line_count == 2 &amp;&amp; *ml_get(1) == NUL)) {</a>
<a name="ln1185">      changed_internal();</a>
<a name="ln1186">      buf_inc_changedtick(curbuf);</a>
<a name="ln1187">    }</a>
<a name="ln1188">  } else {</a>
<a name="ln1189">    for (idx = 1; idx &lt;= lnum; ++idx) {</a>
<a name="ln1190">      /* Need to copy one line, fetching the other one may flush it. */</a>
<a name="ln1191">      p = vim_strsave(ml_get(idx));</a>
<a name="ln1192">      i = STRCMP(p, ml_get(idx + lnum));</a>
<a name="ln1193">      xfree(p);</a>
<a name="ln1194">      if (i != 0) {</a>
<a name="ln1195">        changed_internal();</a>
<a name="ln1196">        buf_inc_changedtick(curbuf);</a>
<a name="ln1197">        break;</a>
<a name="ln1198">      }</a>
<a name="ln1199">    }</a>
<a name="ln1200">  }</a>
<a name="ln1201"> </a>
<a name="ln1202">  /*</a>
<a name="ln1203">   * Delete the lines from the original file and the dummy line from the</a>
<a name="ln1204">   * empty buffer.  These will now be after the last line in the buffer.</a>
<a name="ln1205">   */</a>
<a name="ln1206">  while (curbuf-&gt;b_ml.ml_line_count &gt; lnum</a>
<a name="ln1207">         &amp;&amp; !(curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY))</a>
<a name="ln1208">    ml_delete(curbuf-&gt;b_ml.ml_line_count, false);</a>
<a name="ln1209">  curbuf-&gt;b_flags |= BF_RECOVERED;</a>
<a name="ln1210"> </a>
<a name="ln1211">  recoverymode = FALSE;</a>
<a name="ln1212">  if (got_int)</a>
<a name="ln1213">    EMSG(_(&quot;E311: Recovery Interrupted&quot;));</a>
<a name="ln1214">  else if (error) {</a>
<a name="ln1215">    ++no_wait_return;</a>
<a name="ln1216">    MSG(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);</a>
<a name="ln1217">    EMSG(_(</a>
<a name="ln1218">            &quot;E312: Errors detected while recovering; look for lines starting with ???&quot;));</a>
<a name="ln1219">    --no_wait_return;</a>
<a name="ln1220">    MSG(_(&quot;See \&quot;:help E312\&quot; for more information.&quot;));</a>
<a name="ln1221">    MSG(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);</a>
<a name="ln1222">  } else {</a>
<a name="ln1223">    if (curbuf-&gt;b_changed) {</a>
<a name="ln1224">      MSG(_(&quot;Recovery completed. You should check if everything is OK.&quot;));</a>
<a name="ln1225">      MSG_PUTS(_(</a>
<a name="ln1226">              &quot;\n(You might want to write out this file under another name\n&quot;));</a>
<a name="ln1227">      MSG_PUTS(_(&quot;and run diff with the original file to check for changes)&quot;));</a>
<a name="ln1228">    } else</a>
<a name="ln1229">      MSG(_(&quot;Recovery completed. Buffer contents equals file contents.&quot;));</a>
<a name="ln1230">    MSG_PUTS(_(&quot;\nYou may want to delete the .swp file now.\n\n&quot;));</a>
<a name="ln1231">    cmdline_row = msg_row;</a>
<a name="ln1232">  }</a>
<a name="ln1233">  redraw_curbuf_later(NOT_VALID);</a>
<a name="ln1234"> </a>
<a name="ln1235">theend:</a>
<a name="ln1236">  xfree(fname_used);</a>
<a name="ln1237">  recoverymode = FALSE;</a>
<a name="ln1238">  if (mfp != NULL) {</a>
<a name="ln1239">    if (hp != NULL)</a>
<a name="ln1240">      mf_put(mfp, hp, false, false);</a>
<a name="ln1241">    mf_close(mfp, false);           /* will also xfree(mfp-&gt;mf_fname) */</a>
<a name="ln1242">  }</a>
<a name="ln1243">  if (buf != NULL) {  //may be NULL if swap file not found.</a>
<a name="ln1244">    xfree(buf-&gt;b_ml.ml_stack);</a>
<a name="ln1245">    xfree(buf);</a>
<a name="ln1246">  }</a>
<a name="ln1247">  if (serious_error &amp;&amp; called_from_main)</a>
<a name="ln1248">    ml_close(curbuf, TRUE);</a>
<a name="ln1249">  else {</a>
<a name="ln1250">    apply_autocmds(EVENT_BUFREADPOST, NULL, curbuf-&gt;b_fname, FALSE, curbuf);</a>
<a name="ln1251">    apply_autocmds(EVENT_BUFWINENTER, NULL, curbuf-&gt;b_fname, FALSE, curbuf);</a>
<a name="ln1252">  }</a>
<a name="ln1253">  return;</a>
<a name="ln1254">}</a>
<a name="ln1255"> </a>
<a name="ln1256">/*</a>
<a name="ln1257"> * Find the names of swap files in current directory and the directory given</a>
<a name="ln1258"> * with the 'directory' option.</a>
<a name="ln1259"> *</a>
<a name="ln1260"> * Used to:</a>
<a name="ln1261"> * - list the swap files for &quot;vim -r&quot;</a>
<a name="ln1262"> * - count the number of swap files when recovering</a>
<a name="ln1263"> * - list the swap files when recovering</a>
<a name="ln1264"> * - find the name of the n'th swap file when recovering</a>
<a name="ln1265"> */</a>
<a name="ln1266">int </a>
<a name="ln1267">recover_names (</a>
<a name="ln1268">    char_u *fname,             /* base for swap file name */</a>
<a name="ln1269">    int list,                       /* when TRUE, list the swap file names */</a>
<a name="ln1270">    int nr,                         /* when non-zero, return nr'th swap file name */</a>
<a name="ln1271">    char_u **fname_out        /* result when &quot;nr&quot; &gt; 0 */</a>
<a name="ln1272">)</a>
<a name="ln1273">{</a>
<a name="ln1274">  int num_names;</a>
<a name="ln1275">  char_u      *(names[6]);</a>
<a name="ln1276">  char_u      *tail;</a>
<a name="ln1277">  char_u      *p;</a>
<a name="ln1278">  int num_files;</a>
<a name="ln1279">  int file_count = 0;</a>
<a name="ln1280">  char_u      **files;</a>
<a name="ln1281">  char_u      *dirp;</a>
<a name="ln1282">  char_u      *dir_name;</a>
<a name="ln1283">  char_u      *fname_res = NULL;</a>
<a name="ln1284">#ifdef HAVE_READLINK</a>
<a name="ln1285">  char_u fname_buf[MAXPATHL];</a>
<a name="ln1286">#endif</a>
<a name="ln1287"> </a>
<a name="ln1288">  if (fname != NULL) {</a>
<a name="ln1289">#ifdef HAVE_READLINK</a>
<a name="ln1290">    /* Expand symlink in the file name, because the swap file is created</a>
<a name="ln1291">     * with the actual file instead of with the symlink. */</a>
<a name="ln1292">    if (resolve_symlink(fname, fname_buf) == OK)</a>
<a name="ln1293">      fname_res = fname_buf;</a>
<a name="ln1294">    else</a>
<a name="ln1295">#endif</a>
<a name="ln1296">    fname_res = fname;</a>
<a name="ln1297">  }</a>
<a name="ln1298"> </a>
<a name="ln1299">  if (list) {</a>
<a name="ln1300">    /* use msg() to start the scrolling properly */</a>
<a name="ln1301">    msg((char_u *)_(&quot;Swap files found:&quot;));</a>
<a name="ln1302">    msg_putchar('\n');</a>
<a name="ln1303">  }</a>
<a name="ln1304"> </a>
<a name="ln1305">  // Do the loop for every directory in 'directory'.</a>
<a name="ln1306">  // First allocate some memory to put the directory name in.</a>
<a name="ln1307">  dir_name = xmalloc(STRLEN(p_dir) + 1);</a>
<a name="ln1308">  dirp = p_dir;</a>
<a name="ln1309">  while (*dirp) {</a>
<a name="ln1310">    // Isolate a directory name from *dirp and put it in dir_name (we know</a>
<a name="ln1311">    // it is large enough, so use 31000 for length).</a>
<a name="ln1312">    // Advance dirp to next directory name.</a>
<a name="ln1313">    (void)copy_option_part(&amp;dirp, dir_name, 31000, &quot;,&quot;);</a>
<a name="ln1314"> </a>
<a name="ln1315">    if (dir_name[0] == '.' &amp;&amp; dir_name[1] == NUL) {     /* check current dir */</a>
<a name="ln1316">      if (fname == NULL) {</a>
<a name="ln1317">        names[0] = vim_strsave((char_u *)&quot;*.sw?&quot;);</a>
<a name="ln1318">        /* For Unix names starting with a dot are special.  MS-Windows</a>
<a name="ln1319">         * supports this too, on some file systems. */</a>
<a name="ln1320">        names[1] = vim_strsave((char_u *)&quot;.*.sw?&quot;);</a>
<a name="ln1321">        names[2] = vim_strsave((char_u *)&quot;.sw?&quot;);</a>
<a name="ln1322">        num_names = 3;</a>
<a name="ln1323">      } else</a>
<a name="ln1324">        num_names = recov_file_names(names, fname_res, TRUE);</a>
<a name="ln1325">    } else {                      /* check directory dir_name */</a>
<a name="ln1326">      if (fname == NULL) {</a>
<a name="ln1327">        names[0] = (char_u *)concat_fnames((char *)dir_name, &quot;*.sw?&quot;, TRUE);</a>
<a name="ln1328">        /* For Unix names starting with a dot are special.  MS-Windows</a>
<a name="ln1329">         * supports this too, on some file systems. */</a>
<a name="ln1330">        names[1] = (char_u *)concat_fnames((char *)dir_name, &quot;.*.sw?&quot;, TRUE);</a>
<a name="ln1331">        names[2] = (char_u *)concat_fnames((char *)dir_name, &quot;.sw?&quot;, TRUE);</a>
<a name="ln1332">        num_names = 3;</a>
<a name="ln1333">      } else {</a>
<a name="ln1334">        int len = (int)STRLEN(dir_name);</a>
<a name="ln1335">        p = dir_name + len;</a>
<a name="ln1336">        if (after_pathsep((char *)dir_name, (char *)p)</a>
<a name="ln1337">            &amp;&amp; len &gt; 1</a>
<a name="ln1338">            &amp;&amp; p[-1] == p[-2]) {</a>
<a name="ln1339">          // Ends with '//', Use Full path for swap name</a>
<a name="ln1340">          tail = (char_u *)make_percent_swname((char *)dir_name,</a>
<a name="ln1341">                                               (char *)fname_res);</a>
<a name="ln1342">        } else {</a>
<a name="ln1343">          tail = path_tail(fname_res);</a>
<a name="ln1344">          tail = (char_u *)concat_fnames((char *)dir_name, (char *)tail, TRUE);</a>
<a name="ln1345">        }</a>
<a name="ln1346">        num_names = recov_file_names(names, tail, FALSE);</a>
<a name="ln1347">        xfree(tail);</a>
<a name="ln1348">      }</a>
<a name="ln1349">    }</a>
<a name="ln1350"> </a>
<a name="ln1351">    if (num_names == 0)</a>
<a name="ln1352">      num_files = 0;</a>
<a name="ln1353">    else if (expand_wildcards(num_names, names, &amp;num_files, &amp;files,</a>
<a name="ln1354">                 EW_KEEPALL|EW_FILE|EW_SILENT) == FAIL)</a>
<a name="ln1355">      num_files = 0;</a>
<a name="ln1356"> </a>
<a name="ln1357">    /*</a>
<a name="ln1358">     * When no swap file found, wildcard expansion might have failed (e.g.</a>
<a name="ln1359">     * not able to execute the shell).</a>
<a name="ln1360">     * Try finding a swap file by simply adding &quot;.swp&quot; to the file name.</a>
<a name="ln1361">     */</a>
<a name="ln1362">    if (*dirp == NUL &amp;&amp; file_count + num_files == 0 &amp;&amp; fname != NULL) {</a>
<a name="ln1363">      char_u *swapname = (char_u *)modname((char *)fname_res, &quot;.swp&quot;, true);</a>
<a name="ln1364">      if (swapname != NULL) {</a>
<a name="ln1365">        if (os_path_exists(swapname)) {</a>
<a name="ln1366">          files = xmalloc(sizeof(char_u *));</a>
<a name="ln1367">          files[0] = swapname;</a>
<a name="ln1368">          swapname = NULL;</a>
<a name="ln1369">          num_files = 1;</a>
<a name="ln1370">        }</a>
<a name="ln1371">        xfree(swapname);</a>
<a name="ln1372">      }</a>
<a name="ln1373">    }</a>
<a name="ln1374"> </a>
<a name="ln1375">    /*</a>
<a name="ln1376">     * remove swapfile name of the current buffer, it must be ignored</a>
<a name="ln1377">     */</a>
<a name="ln1378">    if (curbuf-&gt;b_ml.ml_mfp != NULL</a>
<a name="ln1379">        &amp;&amp; (p = curbuf-&gt;b_ml.ml_mfp-&gt;mf_fname) != NULL) {</a>
<a name="ln1380">      for (int i = 0; i &lt; num_files; i++) {</a>
<a name="ln1381">        // Do not expand wildcards, on Windows would try to expand</a>
<a name="ln1382">        // &quot;%tmp%&quot; in &quot;%tmp%file&quot;</a>
<a name="ln1383">        if (path_full_compare(p, files[i], true, false) &amp; kEqualFiles) {</a>
<a name="ln1384">          // Remove the name from files[i].  Move further entries</a>
<a name="ln1385">          // down.  When the array becomes empty free it here, since</a>
<a name="ln1386">          // FreeWild() won't be called below.</a>
<a name="ln1387">          xfree(files[i]);</a>
<a name="ln1388">          if (--num_files == 0)</a>
<a name="ln1389">            xfree(files);</a>
<a name="ln1390">          else</a>
<a name="ln1391">            for (; i &lt; num_files; ++i)</a>
<a name="ln1392">              files[i] = files[i + 1];</a>
<a name="ln1393">        }</a>
<a name="ln1394">      }</a>
<a name="ln1395">    }</a>
<a name="ln1396">    if (nr &gt; 0) {</a>
<a name="ln1397">      file_count += num_files;</a>
<a name="ln1398">      if (nr &lt;= file_count) {</a>
<a name="ln1399">        *fname_out = vim_strsave(</a>
<a name="ln1400">            files[nr - 1 + num_files - file_count]);</a>
<a name="ln1401">        dirp = (char_u *)&quot;&quot;;                        /* stop searching */</a>
<a name="ln1402">      }</a>
<a name="ln1403">    } else if (list) {</a>
<a name="ln1404">      if (dir_name[0] == '.' &amp;&amp; dir_name[1] == NUL) {</a>
<a name="ln1405">        if (fname == NULL)</a>
<a name="ln1406">          MSG_PUTS(_(&quot;   In current directory:\n&quot;));</a>
<a name="ln1407">        else</a>
<a name="ln1408">          MSG_PUTS(_(&quot;   Using specified name:\n&quot;));</a>
<a name="ln1409">      } else {</a>
<a name="ln1410">        MSG_PUTS(_(&quot;   In directory &quot;));</a>
<a name="ln1411">        msg_home_replace(dir_name);</a>
<a name="ln1412">        MSG_PUTS(&quot;:\n&quot;);</a>
<a name="ln1413">      }</a>
<a name="ln1414"> </a>
<a name="ln1415">      if (num_files) {</a>
<a name="ln1416">        for (int i = 0; i &lt; num_files; ++i) {</a>
<a name="ln1417">          /* print the swap file name */</a>
<a name="ln1418">          msg_outnum((long)++file_count);</a>
<a name="ln1419">          msg_puts(&quot;.    &quot;);</a>
<a name="ln1420">          msg_puts((const char *)path_tail(files[i]));</a>
<a name="ln1421">          msg_putchar('\n');</a>
<a name="ln1422">          (void)swapfile_info(files[i]);</a>
<a name="ln1423">        }</a>
<a name="ln1424">      } else</a>
<a name="ln1425">        MSG_PUTS(_(&quot;      -- none --\n&quot;));</a>
<a name="ln1426">      ui_flush();</a>
<a name="ln1427">    } else</a>
<a name="ln1428">      file_count += num_files;</a>
<a name="ln1429"> </a>
<a name="ln1430">    for (int i = 0; i &lt; num_names; ++i)</a>
<a name="ln1431">      xfree(names[i]);</a>
<a name="ln1432">    if (num_files &gt; 0)</a>
<a name="ln1433">      FreeWild(num_files, files);</a>
<a name="ln1434">  }</a>
<a name="ln1435">  xfree(dir_name);</a>
<a name="ln1436">  return file_count;</a>
<a name="ln1437">}</a>
<a name="ln1438"> </a>
<a name="ln1439">/*</a>
<a name="ln1440"> * Append the full path to name with path separators made into percent</a>
<a name="ln1441"> * signs, to dir. An unnamed buffer is handled as &quot;&quot; (&lt;currentdir&gt;/&quot;&quot;)</a>
<a name="ln1442"> */</a>
<a name="ln1443">char *make_percent_swname(const char *dir, char *name)</a>
<a name="ln1444">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln1445">{</a>
<a name="ln1446">  char *d = NULL;</a>
<a name="ln1447">  char *f = fix_fname(name != NULL ? name : &quot;&quot;);</a>
<a name="ln1448">  if (f != NULL) {</a>
<a name="ln1449">    char *s = xstrdup(f);</a>
<a name="ln1450">    for (d = s; *d != NUL; MB_PTR_ADV(d)) {</a>
<a name="ln1451">      if (vim_ispathsep(*d)) {</a>
<a name="ln1452">        *d = '%';</a>
<a name="ln1453">      }</a>
<a name="ln1454">    }</a>
<a name="ln1455">    d = concat_fnames(dir, s, TRUE);</a>
<a name="ln1456">    xfree(s);</a>
<a name="ln1457">    xfree(f);</a>
<a name="ln1458">  }</a>
<a name="ln1459">  return d;</a>
<a name="ln1460">}</a>
<a name="ln1461"> </a>
<a name="ln1462">static bool process_still_running;</a>
<a name="ln1463"> </a>
<a name="ln1464">/// Return information found in swapfile &quot;fname&quot; in dictionary &quot;d&quot;.</a>
<a name="ln1465">/// This is used by the swapinfo() function.</a>
<a name="ln1466">void get_b0_dict(const char *fname, dict_T *d)</a>
<a name="ln1467">{</a>
<a name="ln1468">  int fd;</a>
<a name="ln1469">  struct block0 b0;</a>
<a name="ln1470"> </a>
<a name="ln1471">  if ((fd = os_open(fname, O_RDONLY, 0)) &gt;= 0) {</a>
<a name="ln1472">    if (read_eintr(fd, &amp;b0, sizeof(b0)) == sizeof(b0)) {</a>
<a name="ln1473">      if (ml_check_b0_id(&amp;b0) == FAIL) {</a>
<a name="ln1474">        tv_dict_add_str(d, S_LEN(&quot;error&quot;), &quot;Not a swap file&quot;);</a>
<a name="ln1475">      } else if (b0_magic_wrong(&amp;b0)) {</a>
<a name="ln1476">        tv_dict_add_str(d, S_LEN(&quot;error&quot;), &quot;Magic number mismatch&quot;);</a>
<a name="ln1477">      } else {</a>
<a name="ln1478">        // We have swap information.</a>
<a name="ln1479">        tv_dict_add_str_len(d, S_LEN(&quot;version&quot;), (char *)b0.b0_version, 10);</a>
<a name="ln1480">        tv_dict_add_str_len(d, S_LEN(&quot;user&quot;), (char *)b0.b0_uname,</a>
<a name="ln1481">                            B0_UNAME_SIZE);</a>
<a name="ln1482">        tv_dict_add_str_len(d, S_LEN(&quot;host&quot;), (char *)b0.b0_hname,</a>
<a name="ln1483">                            B0_HNAME_SIZE);</a>
<a name="ln1484">        tv_dict_add_str_len(d, S_LEN(&quot;fname&quot;), (char *)b0.b0_fname,</a>
<a name="ln1485">                            B0_FNAME_SIZE_ORG);</a>
<a name="ln1486"> </a>
<a name="ln1487">        tv_dict_add_nr(d, S_LEN(&quot;pid&quot;), char_to_long(b0.b0_pid));</a>
<a name="ln1488">        tv_dict_add_nr(d, S_LEN(&quot;mtime&quot;), char_to_long(b0.b0_mtime));</a>
<a name="ln1489">        tv_dict_add_nr(d, S_LEN(&quot;dirty&quot;), b0.b0_dirty ? 1 : 0);</a>
<a name="ln1490">        tv_dict_add_nr(d, S_LEN(&quot;inode&quot;), char_to_long(b0.b0_ino));</a>
<a name="ln1491">      }</a>
<a name="ln1492">    } else {</a>
<a name="ln1493">      tv_dict_add_str(d, S_LEN(&quot;error&quot;), &quot;Cannot read file&quot;);</a>
<a name="ln1494">    }</a>
<a name="ln1495">    close(fd);</a>
<a name="ln1496">  } else {</a>
<a name="ln1497">    tv_dict_add_str(d, S_LEN(&quot;error&quot;), &quot;Cannot open file&quot;);</a>
<a name="ln1498">  }</a>
<a name="ln1499">}</a>
<a name="ln1500"> </a>
<a name="ln1501">/// Give information about an existing swap file.</a>
<a name="ln1502">/// Returns timestamp (0 when unknown).</a>
<a name="ln1503">static time_t swapfile_info(char_u *fname)</a>
<a name="ln1504">{</a>
<a name="ln1505">  assert(fname != NULL);</a>
<a name="ln1506">  int fd;</a>
<a name="ln1507">  struct block0 b0;</a>
<a name="ln1508">  time_t x = (time_t)0;</a>
<a name="ln1509">#ifdef UNIX</a>
<a name="ln1510">  char uname[B0_UNAME_SIZE];</a>
<a name="ln1511">#endif</a>
<a name="ln1512"> </a>
<a name="ln1513">  // print the swap file date</a>
<a name="ln1514">  FileInfo file_info;</a>
<a name="ln1515">  if (os_fileinfo((char *)fname, &amp;file_info)) {</a>
<a name="ln1516">#ifdef UNIX</a>
<a name="ln1517">    // print name of owner of the file</a>
<a name="ln1518">    if (os_get_uname(file_info.stat.st_uid, uname, B0_UNAME_SIZE) == OK) {</a>
<a name="ln1519">      MSG_PUTS(_(&quot;          owned by: &quot;));</a>
<a name="ln1520">      msg_outtrans((char_u *)uname);</a>
<a name="ln1521">      MSG_PUTS(_(&quot;   dated: &quot;));</a>
<a name="ln1522">    } else</a>
<a name="ln1523">#endif</a>
<a name="ln1524">    MSG_PUTS(_(&quot;             dated: &quot;));</a>
<a name="ln1525">    x = file_info.stat.st_mtim.tv_sec;</a>
<a name="ln1526">    char ctime_buf[50];</a>
<a name="ln1527">    MSG_PUTS(os_ctime_r(&amp;x, ctime_buf, sizeof(ctime_buf)));</a>
<a name="ln1528">  }</a>
<a name="ln1529"> </a>
<a name="ln1530">  /*</a>
<a name="ln1531">   * print the original file name</a>
<a name="ln1532">   */</a>
<a name="ln1533">  fd = os_open((char *)fname, O_RDONLY, 0);</a>
<a name="ln1534">  if (fd &gt;= 0) {</a>
<a name="ln1535">    if (read_eintr(fd, &amp;b0, sizeof(b0)) == sizeof(b0)) {</a>
<a name="ln1536">      if (STRNCMP(b0.b0_version, &quot;VIM 3.0&quot;, 7) == 0) {</a>
<a name="ln1537">        MSG_PUTS(_(&quot;         [from Vim version 3.0]&quot;));</a>
<a name="ln1538">      } else if (ml_check_b0_id(&amp;b0) == FAIL) {</a>
<a name="ln1539">        MSG_PUTS(_(&quot;         [does not look like a Vim swap file]&quot;));</a>
<a name="ln1540">      } else if (!ml_check_b0_strings(&amp;b0)) {</a>
<a name="ln1541">        MSG_PUTS(_(&quot;         [garbled strings (not nul terminated)]&quot;));</a>
<a name="ln1542">      } else {</a>
<a name="ln1543">        MSG_PUTS(_(&quot;         file name: &quot;));</a>
<a name="ln1544">        if (b0.b0_fname[0] == NUL)</a>
<a name="ln1545">          MSG_PUTS(_(&quot;[No Name]&quot;));</a>
<a name="ln1546">        else</a>
<a name="ln1547">          msg_outtrans(b0.b0_fname);</a>
<a name="ln1548"> </a>
<a name="ln1549">        MSG_PUTS(_(&quot;\n          modified: &quot;));</a>
<a name="ln1550">        MSG_PUTS(b0.b0_dirty ? _(&quot;YES&quot;) : _(&quot;no&quot;));</a>
<a name="ln1551"> </a>
<a name="ln1552">        if (*(b0.b0_uname) != NUL) {</a>
<a name="ln1553">          MSG_PUTS(_(&quot;\n         user name: &quot;));</a>
<a name="ln1554">          msg_outtrans(b0.b0_uname);</a>
<a name="ln1555">        }</a>
<a name="ln1556"> </a>
<a name="ln1557">        if (*(b0.b0_hname) != NUL) {</a>
<a name="ln1558">          if (*(b0.b0_uname) != NUL)</a>
<a name="ln1559">            MSG_PUTS(_(&quot;   host name: &quot;));</a>
<a name="ln1560">          else</a>
<a name="ln1561">            MSG_PUTS(_(&quot;\n         host name: &quot;));</a>
<a name="ln1562">          msg_outtrans(b0.b0_hname);</a>
<a name="ln1563">        }</a>
<a name="ln1564"> </a>
<a name="ln1565">        if (char_to_long(b0.b0_pid) != 0L) {</a>
<a name="ln1566">          MSG_PUTS(_(&quot;\n        process ID: &quot;));</a>
<a name="ln1567">          msg_outnum(char_to_long(b0.b0_pid));</a>
<a name="ln1568">          if (os_proc_running((int)char_to_long(b0.b0_pid))) {</a>
<a name="ln1569">            MSG_PUTS(_(&quot; (STILL RUNNING)&quot;));</a>
<a name="ln1570">            process_still_running = true;</a>
<a name="ln1571">          }</a>
<a name="ln1572">        }</a>
<a name="ln1573"> </a>
<a name="ln1574">        if (b0_magic_wrong(&amp;b0)) {</a>
<a name="ln1575">          MSG_PUTS(_(&quot;\n         [not usable on this computer]&quot;));</a>
<a name="ln1576">        }</a>
<a name="ln1577">      }</a>
<a name="ln1578">    } else</a>
<a name="ln1579">      MSG_PUTS(_(&quot;         [cannot be read]&quot;));</a>
<a name="ln1580">    close(fd);</a>
<a name="ln1581">  } else</a>
<a name="ln1582">    MSG_PUTS(_(&quot;         [cannot be opened]&quot;));</a>
<a name="ln1583">  msg_putchar('\n');</a>
<a name="ln1584"> </a>
<a name="ln1585">  return x;</a>
<a name="ln1586">}</a>
<a name="ln1587"> </a>
<a name="ln1588">/// Returns TRUE if the swap file looks OK and there are no changes, thus it</a>
<a name="ln1589">/// can be safely deleted.</a>
<a name="ln1590">static time_t swapfile_unchanged(char *fname)</a>
<a name="ln1591">{</a>
<a name="ln1592">  struct block0 b0;</a>
<a name="ln1593">  int ret = true;</a>
<a name="ln1594"> </a>
<a name="ln1595">  // Swap file must exist.</a>
<a name="ln1596">  if (!os_path_exists((char_u *)fname)) {</a>
<a name="ln1597">    return false;</a>
<a name="ln1598">  }</a>
<a name="ln1599"> </a>
<a name="ln1600">  // must be able to read the first block</a>
<a name="ln1601">  int fd = os_open(fname, O_RDONLY, 0);</a>
<a name="ln1602">  if (fd &lt; 0) {</a>
<a name="ln1603">    return false;</a>
<a name="ln1604">  }</a>
<a name="ln1605">  if (read_eintr(fd, &amp;b0, sizeof(b0)) != sizeof(b0)) {</a>
<a name="ln1606">    close(fd);</a>
<a name="ln1607">    return false;</a>
<a name="ln1608">  }</a>
<a name="ln1609"> </a>
<a name="ln1610">  // the ID and magic number must be correct</a>
<a name="ln1611">  if (ml_check_b0_id(&amp;b0) == FAIL|| b0_magic_wrong(&amp;b0)) {</a>
<a name="ln1612">    ret = false;</a>
<a name="ln1613">  }</a>
<a name="ln1614"> </a>
<a name="ln1615">  // must be unchanged</a>
<a name="ln1616">  if (b0.b0_dirty) {</a>
<a name="ln1617">    ret = false;</a>
<a name="ln1618">  }</a>
<a name="ln1619"> </a>
<a name="ln1620">  // process must be known and not running.</a>
<a name="ln1621">  long pid = char_to_long(b0.b0_pid);</a>
<a name="ln1622">  if (pid == 0L || os_proc_running((int)pid)) {</a>
<a name="ln1623">    ret = false;</a>
<a name="ln1624">  }</a>
<a name="ln1625"> </a>
<a name="ln1626">  // TODO(bram): Should we check if the swap file was created on the current</a>
<a name="ln1627">  // system?  And the current user?</a>
<a name="ln1628"> </a>
<a name="ln1629">  close(fd);</a>
<a name="ln1630">  return ret;</a>
<a name="ln1631">}</a>
<a name="ln1632"> </a>
<a name="ln1633">static int recov_file_names(char_u **names, char_u *path, int prepend_dot)</a>
<a name="ln1634">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1635">{</a>
<a name="ln1636">  int num_names = 0;</a>
<a name="ln1637"> </a>
<a name="ln1638">  // May also add the file name with a dot prepended, for swap file in same</a>
<a name="ln1639">  // dir as original file.</a>
<a name="ln1640">  if (prepend_dot) {</a>
<a name="ln1641">    names[num_names] = (char_u *)modname((char *)path, &quot;.sw?&quot;, true);</a>
<a name="ln1642">    if (names[num_names] == NULL) {</a>
<a name="ln1643">      return num_names;</a>
<a name="ln1644">    }</a>
<a name="ln1645">    num_names++;</a>
<a name="ln1646">  }</a>
<a name="ln1647"> </a>
<a name="ln1648">  // Form the normal swap file name pattern by appending &quot;.sw?&quot;.</a>
<a name="ln1649">  names[num_names] = (char_u *)concat_fnames((char *)path, &quot;.sw?&quot;, FALSE);</a>
<a name="ln1650">  if (num_names &gt;= 1) {     /* check if we have the same name twice */</a>
<a name="ln1651">    char_u *p = names[num_names - 1];</a>
<a name="ln1652">    int i = (int)STRLEN(names[num_names - 1]) - (int)STRLEN(names[num_names]);</a>
<a name="ln1653">    if (i &gt; 0)</a>
<a name="ln1654">      p += i;               /* file name has been expanded to full path */</a>
<a name="ln1655"> </a>
<a name="ln1656">    if (STRCMP(p, names[num_names]) != 0)</a>
<a name="ln1657">      ++num_names;</a>
<a name="ln1658">    else</a>
<a name="ln1659">      xfree(names[num_names]);</a>
<a name="ln1660">  } else</a>
<a name="ln1661">    ++num_names;</a>
<a name="ln1662"> </a>
<a name="ln1663">  return num_names;</a>
<a name="ln1664">}</a>
<a name="ln1665"> </a>
<a name="ln1666">/*</a>
<a name="ln1667"> * sync all memlines</a>
<a name="ln1668"> *</a>
<a name="ln1669"> * If 'check_file' is TRUE, check if original file exists and was not changed.</a>
<a name="ln1670"> * If 'check_char' is TRUE, stop syncing when character becomes available, but</a>
<a name="ln1671"> * always sync at least one block.</a>
<a name="ln1672"> */</a>
<a name="ln1673">void ml_sync_all(int check_file, int check_char, bool do_fsync)</a>
<a name="ln1674">{</a>
<a name="ln1675">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln1676">    if (buf-&gt;b_ml.ml_mfp == NULL || buf-&gt;b_ml.ml_mfp-&gt;mf_fname == NULL)</a>
<a name="ln1677">      continue;                             /* no file */</a>
<a name="ln1678"> </a>
<a name="ln1679">    ml_flush_line(buf);                     /* flush buffered line */</a>
<a name="ln1680">                                            /* flush locked block */</a>
<a name="ln1681">    (void)ml_find_line(buf, (linenr_T)0, ML_FLUSH);</a>
<a name="ln1682">    if (bufIsChanged(buf) &amp;&amp; check_file &amp;&amp; mf_need_trans(buf-&gt;b_ml.ml_mfp)</a>
<a name="ln1683">        &amp;&amp; buf-&gt;b_ffname != NULL) {</a>
<a name="ln1684">      /*</a>
<a name="ln1685">       * If the original file does not exist anymore or has been changed</a>
<a name="ln1686">       * call ml_preserve() to get rid of all negative numbered blocks.</a>
<a name="ln1687">       */</a>
<a name="ln1688">      FileInfo file_info;</a>
<a name="ln1689">      if (!os_fileinfo((char *)buf-&gt;b_ffname, &amp;file_info)</a>
<a name="ln1690">          || file_info.stat.st_mtim.tv_sec != buf-&gt;b_mtime_read</a>
<a name="ln1691">          || os_fileinfo_size(&amp;file_info) != buf-&gt;b_orig_size) {</a>
<a name="ln1692">        ml_preserve(buf, false, do_fsync);</a>
<a name="ln1693">        did_check_timestamps = false;</a>
<a name="ln1694">        need_check_timestamps = true;           // give message later</a>
<a name="ln1695">      }</a>
<a name="ln1696">    }</a>
<a name="ln1697">    if (buf-&gt;b_ml.ml_mfp-&gt;mf_dirty) {</a>
<a name="ln1698">      (void)mf_sync(buf-&gt;b_ml.ml_mfp, (check_char ? MFS_STOP : 0)</a>
<a name="ln1699">                    | (do_fsync &amp;&amp; bufIsChanged(buf) ? MFS_FLUSH : 0));</a>
<a name="ln1700">      if (check_char &amp;&amp; os_char_avail()) {      // character available now</a>
<a name="ln1701">        break;</a>
<a name="ln1702">      }</a>
<a name="ln1703">    }</a>
<a name="ln1704">  }</a>
<a name="ln1705">}</a>
<a name="ln1706"> </a>
<a name="ln1707">/*</a>
<a name="ln1708"> * sync one buffer, including negative blocks</a>
<a name="ln1709"> *</a>
<a name="ln1710"> * after this all the blocks are in the swap file</a>
<a name="ln1711"> *</a>
<a name="ln1712"> * Used for the :preserve command and when the original file has been</a>
<a name="ln1713"> * changed or deleted.</a>
<a name="ln1714"> *</a>
<a name="ln1715"> * when message is TRUE the success of preserving is reported</a>
<a name="ln1716"> */</a>
<a name="ln1717">void ml_preserve(buf_T *buf, int message, bool do_fsync)</a>
<a name="ln1718">{</a>
<a name="ln1719">  bhdr_T      *hp;</a>
<a name="ln1720">  linenr_T lnum;</a>
<a name="ln1721">  memfile_T   *mfp = buf-&gt;b_ml.ml_mfp;</a>
<a name="ln1722">  int status;</a>
<a name="ln1723">  int got_int_save = got_int;</a>
<a name="ln1724"> </a>
<a name="ln1725">  if (mfp == NULL || mfp-&gt;mf_fname == NULL) {</a>
<a name="ln1726">    if (message)</a>
<a name="ln1727">      EMSG(_(&quot;E313: Cannot preserve, there is no swap file&quot;));</a>
<a name="ln1728">    return;</a>
<a name="ln1729">  }</a>
<a name="ln1730"> </a>
<a name="ln1731">  /* We only want to stop when interrupted here, not when interrupted</a>
<a name="ln1732">   * before. */</a>
<a name="ln1733">  got_int = FALSE;</a>
<a name="ln1734"> </a>
<a name="ln1735">  ml_flush_line(buf);                               // flush buffered line</a>
<a name="ln1736">  (void)ml_find_line(buf, (linenr_T)0, ML_FLUSH);   // flush locked block</a>
<a name="ln1737">  status = mf_sync(mfp, MFS_ALL | (do_fsync ? MFS_FLUSH : 0));</a>
<a name="ln1738"> </a>
<a name="ln1739">  /* stack is invalid after mf_sync(.., MFS_ALL) */</a>
<a name="ln1740">  buf-&gt;b_ml.ml_stack_top = 0;</a>
<a name="ln1741"> </a>
<a name="ln1742">  /*</a>
<a name="ln1743">   * Some of the data blocks may have been changed from negative to</a>
<a name="ln1744">   * positive block number. In that case the pointer blocks need to be</a>
<a name="ln1745">   * updated.</a>
<a name="ln1746">   *</a>
<a name="ln1747">   * We don't know in which pointer block the references are, so we visit</a>
<a name="ln1748">   * all data blocks until there are no more translations to be done (or</a>
<a name="ln1749">   * we hit the end of the file, which can only happen in case a write fails,</a>
<a name="ln1750">   * e.g. when file system if full).</a>
<a name="ln1751">   * ml_find_line() does the work by translating the negative block numbers</a>
<a name="ln1752">   * when getting the first line of each data block.</a>
<a name="ln1753">   */</a>
<a name="ln1754">  if (mf_need_trans(mfp) &amp;&amp; !got_int) {</a>
<a name="ln1755">    lnum = 1;</a>
<a name="ln1756">    while (mf_need_trans(mfp) &amp;&amp; lnum &lt;= buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1757">      hp = ml_find_line(buf, lnum, ML_FIND);</a>
<a name="ln1758">      if (hp == NULL) {</a>
<a name="ln1759">        status = FAIL;</a>
<a name="ln1760">        goto theend;</a>
<a name="ln1761">      }</a>
<a name="ln1762">      CHECK(buf-&gt;b_ml.ml_locked_low != lnum, &quot;low != lnum&quot;);</a>
<a name="ln1763">      lnum = buf-&gt;b_ml.ml_locked_high + 1;</a>
<a name="ln1764">    }</a>
<a name="ln1765">    (void)ml_find_line(buf, (linenr_T)0, ML_FLUSH);  // flush locked block</a>
<a name="ln1766">    // sync the updated pointer blocks</a>
<a name="ln1767">    if (mf_sync(mfp, MFS_ALL | (do_fsync ? MFS_FLUSH : 0)) == FAIL) {</a>
<a name="ln1768">      status = FAIL;</a>
<a name="ln1769">    }</a>
<a name="ln1770">    buf-&gt;b_ml.ml_stack_top = 0;  // stack is invalid now</a>
<a name="ln1771">  }</a>
<a name="ln1772">theend:</a>
<a name="ln1773">  got_int |= got_int_save;</a>
<a name="ln1774"> </a>
<a name="ln1775">  if (message) {</a>
<a name="ln1776">    if (status == OK)</a>
<a name="ln1777">      MSG(_(&quot;File preserved&quot;));</a>
<a name="ln1778">    else</a>
<a name="ln1779">      EMSG(_(&quot;E314: Preserve failed&quot;));</a>
<a name="ln1780">  }</a>
<a name="ln1781">}</a>
<a name="ln1782"> </a>
<a name="ln1783">/*</a>
<a name="ln1784"> * NOTE: The pointer returned by the ml_get_*() functions only remains valid</a>
<a name="ln1785"> * until the next call!</a>
<a name="ln1786"> *  line1 = ml_get(1);</a>
<a name="ln1787"> *  line2 = ml_get(2);	// line1 is now invalid!</a>
<a name="ln1788"> * Make a copy of the line if necessary.</a>
<a name="ln1789"> */</a>
<a name="ln1790">/*</a>
<a name="ln1791"> * Return a pointer to a (read-only copy of a) line.</a>
<a name="ln1792"> *</a>
<a name="ln1793"> * On failure an error message is given and IObuff is returned (to avoid</a>
<a name="ln1794"> * having to check for error everywhere).</a>
<a name="ln1795"> */</a>
<a name="ln1796">char_u *ml_get(linenr_T lnum)</a>
<a name="ln1797">{</a>
<a name="ln1798">  return ml_get_buf(curbuf, lnum, FALSE);</a>
<a name="ln1799">}</a>
<a name="ln1800"> </a>
<a name="ln1801">/*</a>
<a name="ln1802"> * Return pointer to position &quot;pos&quot;.</a>
<a name="ln1803"> */</a>
<a name="ln1804">char_u *ml_get_pos(const pos_T *pos)</a>
<a name="ln1805">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1806">{</a>
<a name="ln1807">  return ml_get_buf(curbuf, pos-&gt;lnum, false) + pos-&gt;col;</a>
<a name="ln1808">}</a>
<a name="ln1809"> </a>
<a name="ln1810">/*</a>
<a name="ln1811"> * Return a pointer to a line in a specific buffer</a>
<a name="ln1812"> *</a>
<a name="ln1813"> * &quot;will_change&quot;: if TRUE mark the buffer dirty (chars in the line will be</a>
<a name="ln1814"> * changed)</a>
<a name="ln1815"> */</a>
<a name="ln1816">char_u *</a>
<a name="ln1817">ml_get_buf (</a>
<a name="ln1818">    buf_T *buf,</a>
<a name="ln1819">    linenr_T lnum,</a>
<a name="ln1820">    bool will_change                        // line will be changed</a>
<a name="ln1821">)</a>
<a name="ln1822">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1823">{</a>
<a name="ln1824">  bhdr_T      *hp;</a>
<a name="ln1825">  DATA_BL     *dp;</a>
<a name="ln1826">  char_u      *ptr;</a>
<a name="ln1827">  static int recursive = 0;</a>
<a name="ln1828"> </a>
<a name="ln1829">  if (lnum &gt; buf-&gt;b_ml.ml_line_count) { /* invalid line number */</a>
<a name="ln1830">    if (recursive == 0) {</a>
<a name="ln1831">      // Avoid giving this message for a recursive call, may happen when</a>
<a name="ln1832">      // the GUI redraws part of the text.</a>
<a name="ln1833">      recursive++;</a>
<a name="ln1834">      IEMSGN(_(&quot;E315: ml_get: invalid lnum: %&quot; PRId64), lnum);</a>
<a name="ln1835">      recursive--;</a>
<a name="ln1836">    }</a>
<a name="ln1837">errorret:</a>
<a name="ln1838">    STRCPY(IObuff, &quot;???&quot;);</a>
<a name="ln1839">    return IObuff;</a>
<a name="ln1840">  }</a>
<a name="ln1841">  if (lnum &lt;= 0)                        /* pretend line 0 is line 1 */</a>
<a name="ln1842">    lnum = 1;</a>
<a name="ln1843"> </a>
<a name="ln1844">  if (buf-&gt;b_ml.ml_mfp == NULL)         /* there are no lines */</a>
<a name="ln1845">    return (char_u *)&quot;&quot;;</a>
<a name="ln1846"> </a>
<a name="ln1847">  /*</a>
<a name="ln1848">   * See if it is the same line as requested last time.</a>
<a name="ln1849">   * Otherwise may need to flush last used line.</a>
<a name="ln1850">   * Don't use the last used line when 'swapfile' is reset, need to load all</a>
<a name="ln1851">   * blocks.</a>
<a name="ln1852">   */</a>
<a name="ln1853">  if (buf-&gt;b_ml.ml_line_lnum != lnum) {</a>
<a name="ln1854">    ml_flush_line(buf);</a>
<a name="ln1855"> </a>
<a name="ln1856">    /*</a>
<a name="ln1857">     * Find the data block containing the line.</a>
<a name="ln1858">     * This also fills the stack with the blocks from the root to the data</a>
<a name="ln1859">     * block and releases any locked block.</a>
<a name="ln1860">     */</a>
<a name="ln1861">    if ((hp = ml_find_line(buf, lnum, ML_FIND)) == NULL) {</a>
<a name="ln1862">      if (recursive == 0) {</a>
<a name="ln1863">        // Avoid giving this message for a recursive call, may happen</a>
<a name="ln1864">        // when the GUI redraws part of the text.</a>
<a name="ln1865">        recursive++;</a>
<a name="ln1866">        get_trans_bufname(buf);</a>
<a name="ln1867">        shorten_dir(NameBuff);</a>
<a name="ln1868">        iemsgf(_(&quot;E316: ml_get: cannot find line %&quot; PRId64 &quot; in buffer %d %s&quot;),</a>
<a name="ln1869">               lnum, buf-&gt;b_fnum, NameBuff);</a>
<a name="ln1870">        recursive--;</a>
<a name="ln1871">      }</a>
<a name="ln1872">      goto errorret;</a>
<a name="ln1873">    }</a>
<a name="ln1874"> </a>
<a name="ln1875">    dp = hp-&gt;bh_data;</a>
<a name="ln1876"> </a>
<a name="ln1877">    ptr = (char_u *)dp +</a>
<a name="ln1878">          ((dp-&gt;db_index[lnum - buf-&gt;b_ml.ml_locked_low]) &amp; DB_INDEX_MASK);</a>
<a name="ln1879">    buf-&gt;b_ml.ml_line_ptr = ptr;</a>
<a name="ln1880">    buf-&gt;b_ml.ml_line_lnum = lnum;</a>
<a name="ln1881">    buf-&gt;b_ml.ml_flags &amp;= ~ML_LINE_DIRTY;</a>
<a name="ln1882">  }</a>
<a name="ln1883">  if (will_change) {</a>
<a name="ln1884">    buf-&gt;b_ml.ml_flags |= (ML_LOCKED_DIRTY | ML_LOCKED_POS);</a>
<a name="ln1885">    ml_add_deleted_len_buf(buf, buf-&gt;b_ml.ml_line_ptr, -1);</a>
<a name="ln1886">  }</a>
<a name="ln1887"> </a>
<a name="ln1888">  return buf-&gt;b_ml.ml_line_ptr;</a>
<a name="ln1889">}</a>
<a name="ln1890"> </a>
<a name="ln1891">/*</a>
<a name="ln1892"> * Check if a line that was just obtained by a call to ml_get</a>
<a name="ln1893"> * is in allocated memory.</a>
<a name="ln1894"> */</a>
<a name="ln1895">int ml_line_alloced(void)</a>
<a name="ln1896">{</a>
<a name="ln1897">  return curbuf-&gt;b_ml.ml_flags &amp; ML_LINE_DIRTY;</a>
<a name="ln1898">}</a>
<a name="ln1899"> </a>
<a name="ln1900">/*</a>
<a name="ln1901"> * Append a line after lnum (may be 0 to insert a line in front of the file).</a>
<a name="ln1902"> * &quot;line&quot; does not need to be allocated, but can't be another line in a</a>
<a name="ln1903"> * buffer, unlocking may make it invalid.</a>
<a name="ln1904"> *</a>
<a name="ln1905"> *   newfile: TRUE when starting to edit a new file, meaning that pe_old_lnum</a>
<a name="ln1906"> *		will be set for recovery</a>
<a name="ln1907"> * Check: The caller of this function should probably also call</a>
<a name="ln1908"> * appended_lines().</a>
<a name="ln1909"> *</a>
<a name="ln1910"> * return FAIL for failure, OK otherwise</a>
<a name="ln1911"> */</a>
<a name="ln1912">int ml_append(</a>
<a name="ln1913">    linenr_T lnum,                  // append after this line (can be 0)</a>
<a name="ln1914">    char_u *line,                   // text of the new line</a>
<a name="ln1915">    colnr_T len,                    // length of new line, including NUL, or 0</a>
<a name="ln1916">    bool newfile                    // flag, see above</a>
<a name="ln1917">)</a>
<a name="ln1918">{</a>
<a name="ln1919">  /* When starting up, we might still need to create the memfile */</a>
<a name="ln1920">  if (curbuf-&gt;b_ml.ml_mfp == NULL &amp;&amp; open_buffer(FALSE, NULL, 0) == FAIL)</a>
<a name="ln1921">    return FAIL;</a>
<a name="ln1922"> </a>
<a name="ln1923">  if (curbuf-&gt;b_ml.ml_line_lnum != 0)</a>
<a name="ln1924">    ml_flush_line(curbuf);</a>
<a name="ln1925">  return ml_append_int(curbuf, lnum, line, len, newfile, FALSE);</a>
<a name="ln1926">}</a>
<a name="ln1927"> </a>
<a name="ln1928">/*</a>
<a name="ln1929"> * Like ml_append() but for an arbitrary buffer.  The buffer must already have</a>
<a name="ln1930"> * a memline.</a>
<a name="ln1931"> */</a>
<a name="ln1932">int ml_append_buf(</a>
<a name="ln1933">    buf_T *buf,</a>
<a name="ln1934">    linenr_T lnum,                  // append after this line (can be 0)</a>
<a name="ln1935">    char_u *line,                   // text of the new line</a>
<a name="ln1936">    colnr_T len,                    // length of new line, including NUL, or 0</a>
<a name="ln1937">    bool newfile                    // flag, see above</a>
<a name="ln1938">)</a>
<a name="ln1939">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln1940">{</a>
<a name="ln1941">  if (buf-&gt;b_ml.ml_mfp == NULL)</a>
<a name="ln1942">    return FAIL;</a>
<a name="ln1943"> </a>
<a name="ln1944">  if (buf-&gt;b_ml.ml_line_lnum != 0)</a>
<a name="ln1945">    ml_flush_line(buf);</a>
<a name="ln1946">  return ml_append_int(buf, lnum, line, len, newfile, FALSE);</a>
<a name="ln1947">}</a>
<a name="ln1948"> </a>
<a name="ln1949">static int ml_append_int(</a>
<a name="ln1950">    buf_T *buf,</a>
<a name="ln1951">    linenr_T lnum,                  // append after this line (can be 0)</a>
<a name="ln1952">    char_u *line,                   // text of the new line</a>
<a name="ln1953">    colnr_T len,                    // length of line, including NUL, or 0</a>
<a name="ln1954">    bool newfile,                   // flag, see above</a>
<a name="ln1955">    int mark                        // mark the new line</a>
<a name="ln1956">)</a>
<a name="ln1957">{</a>
<a name="ln1958">  int i;</a>
<a name="ln1959">  int line_count;               /* number of indexes in current block */</a>
<a name="ln1960">  int offset;</a>
<a name="ln1961">  int from, to;</a>
<a name="ln1962">  int space_needed;             /* space needed for new line */</a>
<a name="ln1963">  int page_size;</a>
<a name="ln1964">  int page_count;</a>
<a name="ln1965">  int db_idx;                   /* index for lnum in data block */</a>
<a name="ln1966">  bhdr_T      *hp;</a>
<a name="ln1967">  memfile_T   *mfp;</a>
<a name="ln1968">  DATA_BL     *dp;</a>
<a name="ln1969">  PTR_BL      *pp;</a>
<a name="ln1970">  infoptr_T   *ip;</a>
<a name="ln1971"> </a>
<a name="ln1972">  /* lnum out of range */</a>
<a name="ln1973">  if (lnum &gt; buf-&gt;b_ml.ml_line_count || buf-&gt;b_ml.ml_mfp == NULL)</a>
<a name="ln1974">    return FAIL;</a>
<a name="ln1975"> </a>
<a name="ln1976">  if (lowest_marked &amp;&amp; lowest_marked &gt; lnum)</a>
<a name="ln1977">    lowest_marked = lnum + 1;</a>
<a name="ln1978"> </a>
<a name="ln1979">  if (len == 0)</a>
<a name="ln1980">    len = (colnr_T)STRLEN(line) + 1;            /* space needed for the text */</a>
<a name="ln1981">  space_needed = len + INDEX_SIZE;      /* space needed for text + index */</a>
<a name="ln1982"> </a>
<a name="ln1983">  mfp = buf-&gt;b_ml.ml_mfp;</a>
<a name="ln1984">  page_size = mfp-&gt;mf_page_size;</a>
<a name="ln1985"> </a>
<a name="ln1986">  /*</a>
<a name="ln1987">   * find the data block containing the previous line</a>
<a name="ln1988">   * This also fills the stack with the blocks from the root to the data block</a>
<a name="ln1989">   * This also releases any locked block.</a>
<a name="ln1990">   */</a>
<a name="ln1991">  if ((hp = ml_find_line(buf, lnum == 0 ? (linenr_T)1 : lnum,</a>
<a name="ln1992">           ML_INSERT)) == NULL)</a>
<a name="ln1993">    return FAIL;</a>
<a name="ln1994"> </a>
<a name="ln1995">  buf-&gt;b_ml.ml_flags &amp;= ~ML_EMPTY;</a>
<a name="ln1996"> </a>
<a name="ln1997">  if (lnum == 0)                /* got line one instead, correct db_idx */</a>
<a name="ln1998">    db_idx = -1;                /* careful, it is negative! */</a>
<a name="ln1999">  else</a>
<a name="ln2000">    db_idx = lnum - buf-&gt;b_ml.ml_locked_low;</a>
<a name="ln2001">  /* get line count before the insertion */</a>
<a name="ln2002">  line_count = buf-&gt;b_ml.ml_locked_high - buf-&gt;b_ml.ml_locked_low;</a>
<a name="ln2003"> </a>
<a name="ln2004">  dp = hp-&gt;bh_data;</a>
<a name="ln2005"> </a>
<a name="ln2006">  /*</a>
<a name="ln2007">   * If</a>
<a name="ln2008">   * - there is not enough room in the current block</a>
<a name="ln2009">   * - appending to the last line in the block</a>
<a name="ln2010">   * - not appending to the last line in the file</a>
<a name="ln2011">   * insert in front of the next block.</a>
<a name="ln2012">   */</a>
<a name="ln2013">  if ((int)dp-&gt;db_free &lt; space_needed &amp;&amp; db_idx == line_count - 1</a>
<a name="ln2014">      &amp;&amp; lnum &lt; buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2015">    /*</a>
<a name="ln2016">     * Now that the line is not going to be inserted in the block that we</a>
<a name="ln2017">     * expected, the line count has to be adjusted in the pointer blocks</a>
<a name="ln2018">     * by using ml_locked_lineadd.</a>
<a name="ln2019">     */</a>
<a name="ln2020">    --(buf-&gt;b_ml.ml_locked_lineadd);</a>
<a name="ln2021">    --(buf-&gt;b_ml.ml_locked_high);</a>
<a name="ln2022">    if ((hp = ml_find_line(buf, lnum + 1, ML_INSERT)) == NULL)</a>
<a name="ln2023">      return FAIL;</a>
<a name="ln2024"> </a>
<a name="ln2025">    db_idx = -1;                    /* careful, it is negative! */</a>
<a name="ln2026">    /* get line count before the insertion */</a>
<a name="ln2027">    line_count = buf-&gt;b_ml.ml_locked_high - buf-&gt;b_ml.ml_locked_low;</a>
<a name="ln2028">    CHECK(buf-&gt;b_ml.ml_locked_low != lnum + 1, &quot;locked_low != lnum + 1&quot;);</a>
<a name="ln2029"> </a>
<a name="ln2030">    dp = hp-&gt;bh_data;</a>
<a name="ln2031">  }</a>
<a name="ln2032"> </a>
<a name="ln2033">  ++buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2034"> </a>
<a name="ln2035">  if ((int)dp-&gt;db_free &gt;= space_needed) {       /* enough room in data block */</a>
<a name="ln2036">    /*</a>
<a name="ln2037">     * Insert new line in existing data block, or in data block allocated above.</a>
<a name="ln2038">     */</a>
<a name="ln2039">    dp-&gt;db_txt_start -= len;</a>
<a name="ln2040">    dp-&gt;db_free -= space_needed;</a>
<a name="ln2041">    ++(dp-&gt;db_line_count);</a>
<a name="ln2042"> </a>
<a name="ln2043">    /*</a>
<a name="ln2044">     * move the text of the lines that follow to the front</a>
<a name="ln2045">     * adjust the indexes of the lines that follow</a>
<a name="ln2046">     */</a>
<a name="ln2047">    if (line_count &gt; db_idx + 1) {          /* if there are following lines */</a>
<a name="ln2048">      /*</a>
<a name="ln2049">       * Offset is the start of the previous line.</a>
<a name="ln2050">       * This will become the character just after the new line.</a>
<a name="ln2051">       */</a>
<a name="ln2052">      if (db_idx &lt; 0)</a>
<a name="ln2053">        offset = dp-&gt;db_txt_end;</a>
<a name="ln2054">      else</a>
<a name="ln2055">        offset = ((dp-&gt;db_index[db_idx]) &amp; DB_INDEX_MASK);</a>
<a name="ln2056">      memmove((char *)dp + dp-&gt;db_txt_start,</a>
<a name="ln2057">          (char *)dp + dp-&gt;db_txt_start + len,</a>
<a name="ln2058">          (size_t)(offset - (dp-&gt;db_txt_start + len)));</a>
<a name="ln2059">      for (i = line_count - 1; i &gt; db_idx; --i)</a>
<a name="ln2060">        dp-&gt;db_index[i + 1] = dp-&gt;db_index[i] - len;</a>
<a name="ln2061">      dp-&gt;db_index[db_idx + 1] = offset - len;</a>
<a name="ln2062">    } else                                  /* add line at the end */</a>
<a name="ln2063">      dp-&gt;db_index[db_idx + 1] = dp-&gt;db_txt_start;</a>
<a name="ln2064"> </a>
<a name="ln2065">    /*</a>
<a name="ln2066">     * copy the text into the block</a>
<a name="ln2067">     */</a>
<a name="ln2068">    memmove((char *)dp + dp-&gt;db_index[db_idx + 1], line, (size_t)len);</a>
<a name="ln2069">    if (mark)</a>
<a name="ln2070">      dp-&gt;db_index[db_idx + 1] |= DB_MARKED;</a>
<a name="ln2071"> </a>
<a name="ln2072">    /*</a>
<a name="ln2073">     * Mark the block dirty.</a>
<a name="ln2074">     */</a>
<a name="ln2075">    buf-&gt;b_ml.ml_flags |= ML_LOCKED_DIRTY;</a>
<a name="ln2076">    if (!newfile)</a>
<a name="ln2077">      buf-&gt;b_ml.ml_flags |= ML_LOCKED_POS;</a>
<a name="ln2078">  } else {        /* not enough space in data block */</a>
<a name="ln2079">    /*</a>
<a name="ln2080">     * If there is not enough room we have to create a new data block and copy some</a>
<a name="ln2081">     * lines into it.</a>
<a name="ln2082">     * Then we have to insert an entry in the pointer block.</a>
<a name="ln2083">     * If this pointer block also is full, we go up another block, and so on, up</a>
<a name="ln2084">     * to the root if necessary.</a>
<a name="ln2085">     * The line counts in the pointer blocks have already been adjusted by</a>
<a name="ln2086">     * ml_find_line().</a>
<a name="ln2087">     */</a>
<a name="ln2088">    long line_count_left, line_count_right;</a>
<a name="ln2089">    int page_count_left, page_count_right;</a>
<a name="ln2090">    bhdr_T      *hp_left;</a>
<a name="ln2091">    bhdr_T      *hp_right;</a>
<a name="ln2092">    bhdr_T      *hp_new;</a>
<a name="ln2093">    int lines_moved;</a>
<a name="ln2094">    int data_moved = 0;                     /* init to shut up gcc */</a>
<a name="ln2095">    int total_moved = 0;                    /* init to shut up gcc */</a>
<a name="ln2096">    DATA_BL     *dp_right, *dp_left;</a>
<a name="ln2097">    int stack_idx;</a>
<a name="ln2098">    int in_left;</a>
<a name="ln2099">    int lineadd;</a>
<a name="ln2100">    blocknr_T bnum_left, bnum_right;</a>
<a name="ln2101">    linenr_T lnum_left, lnum_right;</a>
<a name="ln2102">    int pb_idx;</a>
<a name="ln2103">    PTR_BL      *pp_new;</a>
<a name="ln2104"> </a>
<a name="ln2105">    /*</a>
<a name="ln2106">     * We are going to allocate a new data block. Depending on the</a>
<a name="ln2107">     * situation it will be put to the left or right of the existing</a>
<a name="ln2108">     * block.  If possible we put the new line in the left block and move</a>
<a name="ln2109">     * the lines after it to the right block. Otherwise the new line is</a>
<a name="ln2110">     * also put in the right block. This method is more efficient when</a>
<a name="ln2111">     * inserting a lot of lines at one place.</a>
<a name="ln2112">     */</a>
<a name="ln2113">    if (db_idx &lt; 0) {           /* left block is new, right block is existing */</a>
<a name="ln2114">      lines_moved = 0;</a>
<a name="ln2115">      in_left = TRUE;</a>
<a name="ln2116">      /* space_needed does not change */</a>
<a name="ln2117">    } else {                  /* left block is existing, right block is new */</a>
<a name="ln2118">      lines_moved = line_count - db_idx - 1;</a>
<a name="ln2119">      if (lines_moved == 0)</a>
<a name="ln2120">        in_left = FALSE;                /* put new line in right block */</a>
<a name="ln2121">                                        /* space_needed does not change */</a>
<a name="ln2122">      else {</a>
<a name="ln2123">        data_moved = ((dp-&gt;db_index[db_idx]) &amp; DB_INDEX_MASK) -</a>
<a name="ln2124">                     dp-&gt;db_txt_start;</a>
<a name="ln2125">        total_moved = data_moved + lines_moved * INDEX_SIZE;</a>
<a name="ln2126">        if ((int)dp-&gt;db_free + total_moved &gt;= space_needed) {</a>
<a name="ln2127">          in_left = TRUE;               /* put new line in left block */</a>
<a name="ln2128">          space_needed = total_moved;</a>
<a name="ln2129">        } else {</a>
<a name="ln2130">          in_left = FALSE;                  /* put new line in right block */</a>
<a name="ln2131">          space_needed += total_moved;</a>
<a name="ln2132">        }</a>
<a name="ln2133">      }</a>
<a name="ln2134">    }</a>
<a name="ln2135"> </a>
<a name="ln2136">    page_count = ((space_needed + HEADER_SIZE) + page_size - 1) / page_size;</a>
<a name="ln2137">    hp_new = ml_new_data(mfp, newfile, page_count);</a>
<a name="ln2138">    if (db_idx &lt; 0) {           /* left block is new */</a>
<a name="ln2139">      hp_left = hp_new;</a>
<a name="ln2140">      hp_right = hp;</a>
<a name="ln2141">      line_count_left = 0;</a>
<a name="ln2142">      line_count_right = line_count;</a>
<a name="ln2143">    } else {                  /* right block is new */</a>
<a name="ln2144">      hp_left = hp;</a>
<a name="ln2145">      hp_right = hp_new;</a>
<a name="ln2146">      line_count_left = line_count;</a>
<a name="ln2147">      line_count_right = 0;</a>
<a name="ln2148">    }</a>
<a name="ln2149">    dp_right = hp_right-&gt;bh_data;</a>
<a name="ln2150">    dp_left = hp_left-&gt;bh_data;</a>
<a name="ln2151">    bnum_left = hp_left-&gt;bh_bnum;</a>
<a name="ln2152">    bnum_right = hp_right-&gt;bh_bnum;</a>
<a name="ln2153">    page_count_left = hp_left-&gt;bh_page_count;</a>
<a name="ln2154">    page_count_right = hp_right-&gt;bh_page_count;</a>
<a name="ln2155"> </a>
<a name="ln2156">    /*</a>
<a name="ln2157">     * May move the new line into the right/new block.</a>
<a name="ln2158">     */</a>
<a name="ln2159">    if (!in_left) {</a>
<a name="ln2160">      dp_right-&gt;db_txt_start -= len;</a>
<a name="ln2161">      dp_right-&gt;db_free -= len + INDEX_SIZE;</a>
<a name="ln2162">      dp_right-&gt;db_index[0] = dp_right-&gt;db_txt_start;</a>
<a name="ln2163">      if (mark)</a>
<a name="ln2164">        dp_right-&gt;db_index[0] |= DB_MARKED;</a>
<a name="ln2165"> </a>
<a name="ln2166">      memmove((char *)dp_right + dp_right-&gt;db_txt_start,</a>
<a name="ln2167">          line, (size_t)len);</a>
<a name="ln2168">      ++line_count_right;</a>
<a name="ln2169">    }</a>
<a name="ln2170">    /*</a>
<a name="ln2171">     * may move lines from the left/old block to the right/new one.</a>
<a name="ln2172">     */</a>
<a name="ln2173">    if (lines_moved) {</a>
<a name="ln2174">      /*</a>
<a name="ln2175">       */</a>
<a name="ln2176">      dp_right-&gt;db_txt_start -= data_moved;</a>
<a name="ln2177">      dp_right-&gt;db_free -= total_moved;</a>
<a name="ln2178">      memmove((char *)dp_right + dp_right-&gt;db_txt_start,</a>
<a name="ln2179">          (char *)dp_left + dp_left-&gt;db_txt_start,</a>
<a name="ln2180">          (size_t)data_moved);</a>
<a name="ln2181">      offset = dp_right-&gt;db_txt_start - dp_left-&gt;db_txt_start;</a>
<a name="ln2182">      dp_left-&gt;db_txt_start += data_moved;</a>
<a name="ln2183">      dp_left-&gt;db_free += total_moved;</a>
<a name="ln2184"> </a>
<a name="ln2185">      /*</a>
<a name="ln2186">       * update indexes in the new block</a>
<a name="ln2187">       */</a>
<a name="ln2188">      for (to = line_count_right, from = db_idx + 1;</a>
<a name="ln2189">           from &lt; line_count_left; ++from, ++to)</a>
<a name="ln2190">        dp_right-&gt;db_index[to] = dp-&gt;db_index[from] + offset;</a>
<a name="ln2191">      line_count_right += lines_moved;</a>
<a name="ln2192">      line_count_left -= lines_moved;</a>
<a name="ln2193">    }</a>
<a name="ln2194"> </a>
<a name="ln2195">    /*</a>
<a name="ln2196">     * May move the new line into the left (old or new) block.</a>
<a name="ln2197">     */</a>
<a name="ln2198">    if (in_left) {</a>
<a name="ln2199">      dp_left-&gt;db_txt_start -= len;</a>
<a name="ln2200">      dp_left-&gt;db_free -= len + INDEX_SIZE;</a>
<a name="ln2201">      dp_left-&gt;db_index[line_count_left] = dp_left-&gt;db_txt_start;</a>
<a name="ln2202">      if (mark)</a>
<a name="ln2203">        dp_left-&gt;db_index[line_count_left] |= DB_MARKED;</a>
<a name="ln2204">      memmove((char *)dp_left + dp_left-&gt;db_txt_start,</a>
<a name="ln2205">          line, (size_t)len);</a>
<a name="ln2206">      ++line_count_left;</a>
<a name="ln2207">    }</a>
<a name="ln2208"> </a>
<a name="ln2209">    if (db_idx &lt; 0) {           /* left block is new */</a>
<a name="ln2210">      lnum_left = lnum + 1;</a>
<a name="ln2211">      lnum_right = 0;</a>
<a name="ln2212">    } else {                  /* right block is new */</a>
<a name="ln2213">      lnum_left = 0;</a>
<a name="ln2214">      if (in_left)</a>
<a name="ln2215">        lnum_right = lnum + 2;</a>
<a name="ln2216">      else</a>
<a name="ln2217">        lnum_right = lnum + 1;</a>
<a name="ln2218">    }</a>
<a name="ln2219">    dp_left-&gt;db_line_count = line_count_left;</a>
<a name="ln2220">    dp_right-&gt;db_line_count = line_count_right;</a>
<a name="ln2221"> </a>
<a name="ln2222">    /*</a>
<a name="ln2223">     * release the two data blocks</a>
<a name="ln2224">     * The new one (hp_new) already has a correct blocknumber.</a>
<a name="ln2225">     * The old one (hp, in ml_locked) gets a positive blocknumber if</a>
<a name="ln2226">     * we changed it and we are not editing a new file.</a>
<a name="ln2227">     */</a>
<a name="ln2228">    if (lines_moved || in_left)</a>
<a name="ln2229">      buf-&gt;b_ml.ml_flags |= ML_LOCKED_DIRTY;</a>
<a name="ln2230">    if (!newfile &amp;&amp; db_idx &gt;= 0 &amp;&amp; in_left)</a>
<a name="ln2231">      buf-&gt;b_ml.ml_flags |= ML_LOCKED_POS;</a>
<a name="ln2232">    mf_put(mfp, hp_new, true, false);</a>
<a name="ln2233"> </a>
<a name="ln2234">    /*</a>
<a name="ln2235">     * flush the old data block</a>
<a name="ln2236">     * set ml_locked_lineadd to 0, because the updating of the</a>
<a name="ln2237">     * pointer blocks is done below</a>
<a name="ln2238">     */</a>
<a name="ln2239">    lineadd = buf-&gt;b_ml.ml_locked_lineadd;</a>
<a name="ln2240">    buf-&gt;b_ml.ml_locked_lineadd = 0;</a>
<a name="ln2241">    ml_find_line(buf, (linenr_T)0, ML_FLUSH);       /* flush data block */</a>
<a name="ln2242"> </a>
<a name="ln2243">    /*</a>
<a name="ln2244">     * update pointer blocks for the new data block</a>
<a name="ln2245">     */</a>
<a name="ln2246">    for (stack_idx = buf-&gt;b_ml.ml_stack_top - 1; stack_idx &gt;= 0;</a>
<a name="ln2247">         --stack_idx) {</a>
<a name="ln2248">      ip = &amp;(buf-&gt;b_ml.ml_stack[stack_idx]);</a>
<a name="ln2249">      pb_idx = ip-&gt;ip_index;</a>
<a name="ln2250">      if ((hp = mf_get(mfp, ip-&gt;ip_bnum, 1)) == NULL)</a>
<a name="ln2251">        return FAIL;</a>
<a name="ln2252">      pp = hp-&gt;bh_data;         /* must be pointer block */</a>
<a name="ln2253">      if (pp-&gt;pb_id != PTR_ID) {</a>
<a name="ln2254">        IEMSG(_(&quot;E317: pointer block id wrong 3&quot;));</a>
<a name="ln2255">        mf_put(mfp, hp, false, false);</a>
<a name="ln2256">        return FAIL;</a>
<a name="ln2257">      }</a>
<a name="ln2258">      /*</a>
<a name="ln2259">       * TODO: If the pointer block is full and we are adding at the end</a>
<a name="ln2260">       * try to insert in front of the next block</a>
<a name="ln2261">       */</a>
<a name="ln2262">      /* block not full, add one entry */</a>
<a name="ln2263">      if (pp-&gt;pb_count &lt; pp-&gt;pb_count_max) {</a>
<a name="ln2264">        if (pb_idx + 1 &lt; (int)pp-&gt;pb_count)</a>
<a name="ln2265">          memmove(&amp;pp-&gt;pb_pointer[pb_idx + 2],</a>
<a name="ln2266">              &amp;pp-&gt;pb_pointer[pb_idx + 1],</a>
<a name="ln2267">              (size_t)(pp-&gt;pb_count - pb_idx - 1) * sizeof(PTR_EN));</a>
<a name="ln2268">        ++pp-&gt;pb_count;</a>
<a name="ln2269">        pp-&gt;pb_pointer[pb_idx].pe_line_count = line_count_left;</a>
<a name="ln2270">        pp-&gt;pb_pointer[pb_idx].pe_bnum = bnum_left;</a>
<a name="ln2271">        pp-&gt;pb_pointer[pb_idx].pe_page_count = page_count_left;</a>
<a name="ln2272">        pp-&gt;pb_pointer[pb_idx + 1].pe_line_count = line_count_right;</a>
<a name="ln2273">        pp-&gt;pb_pointer[pb_idx + 1].pe_bnum = bnum_right;</a>
<a name="ln2274">        pp-&gt;pb_pointer[pb_idx + 1].pe_page_count = page_count_right;</a>
<a name="ln2275"> </a>
<a name="ln2276">        if (lnum_left != 0)</a>
<a name="ln2277">          pp-&gt;pb_pointer[pb_idx].pe_old_lnum = lnum_left;</a>
<a name="ln2278">        if (lnum_right != 0)</a>
<a name="ln2279">          pp-&gt;pb_pointer[pb_idx + 1].pe_old_lnum = lnum_right;</a>
<a name="ln2280"> </a>
<a name="ln2281">        mf_put(mfp, hp, true, false);</a>
<a name="ln2282">        buf-&gt;b_ml.ml_stack_top = stack_idx + 1;             /* truncate stack */</a>
<a name="ln2283"> </a>
<a name="ln2284">        if (lineadd) {</a>
<a name="ln2285">          --(buf-&gt;b_ml.ml_stack_top);</a>
<a name="ln2286">          /* fix line count for rest of blocks in the stack */</a>
<a name="ln2287">          ml_lineadd(buf, lineadd);</a>
<a name="ln2288">          /* fix stack itself */</a>
<a name="ln2289">          buf-&gt;b_ml.ml_stack[buf-&gt;b_ml.ml_stack_top].ip_high +=</a>
<a name="ln2290">            lineadd;</a>
<a name="ln2291">          ++(buf-&gt;b_ml.ml_stack_top);</a>
<a name="ln2292">        }</a>
<a name="ln2293"> </a>
<a name="ln2294">        /*</a>
<a name="ln2295">         * We are finished, break the loop here.</a>
<a name="ln2296">         */</a>
<a name="ln2297">        break;</a>
<a name="ln2298">      } else {                        /* pointer block full */</a>
<a name="ln2299">        /*</a>
<a name="ln2300">         * split the pointer block</a>
<a name="ln2301">         * allocate a new pointer block</a>
<a name="ln2302">         * move some of the pointer into the new block</a>
<a name="ln2303">         * prepare for updating the parent block</a>
<a name="ln2304">         */</a>
<a name="ln2305">        for (;; ) {             /* do this twice when splitting block 1 */</a>
<a name="ln2306">          hp_new = ml_new_ptr(mfp);</a>
<a name="ln2307">          if (hp_new == NULL)               /* TODO: try to fix tree */</a>
<a name="ln2308">            return FAIL;</a>
<a name="ln2309">          pp_new = hp_new-&gt;bh_data;</a>
<a name="ln2310"> </a>
<a name="ln2311">          if (hp-&gt;bh_bnum != 1)</a>
<a name="ln2312">            break;</a>
<a name="ln2313"> </a>
<a name="ln2314">          /*</a>
<a name="ln2315">           * if block 1 becomes full the tree is given an extra level</a>
<a name="ln2316">           * The pointers from block 1 are moved into the new block.</a>
<a name="ln2317">           * block 1 is updated to point to the new block</a>
<a name="ln2318">           * then continue to split the new block</a>
<a name="ln2319">           */</a>
<a name="ln2320">          memmove(pp_new, pp, (size_t)page_size);</a>
<a name="ln2321">          pp-&gt;pb_count = 1;</a>
<a name="ln2322">          pp-&gt;pb_pointer[0].pe_bnum = hp_new-&gt;bh_bnum;</a>
<a name="ln2323">          pp-&gt;pb_pointer[0].pe_line_count = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2324">          pp-&gt;pb_pointer[0].pe_old_lnum = 1;</a>
<a name="ln2325">          pp-&gt;pb_pointer[0].pe_page_count = 1;</a>
<a name="ln2326">          mf_put(mfp, hp, true, false);             /* release block 1 */</a>
<a name="ln2327">          hp = hp_new;                          /* new block is to be split */</a>
<a name="ln2328">          pp = pp_new;</a>
<a name="ln2329">          CHECK(stack_idx != 0, _(&quot;stack_idx should be 0&quot;));</a>
<a name="ln2330">          ip-&gt;ip_index = 0;</a>
<a name="ln2331">          ++stack_idx;                  /* do block 1 again later */</a>
<a name="ln2332">        }</a>
<a name="ln2333">        /*</a>
<a name="ln2334">         * move the pointers after the current one to the new block</a>
<a name="ln2335">         * If there are none, the new entry will be in the new block.</a>
<a name="ln2336">         */</a>
<a name="ln2337">        total_moved = pp-&gt;pb_count - pb_idx - 1;</a>
<a name="ln2338">        if (total_moved) {</a>
<a name="ln2339">          memmove(&amp;pp_new-&gt;pb_pointer[0],</a>
<a name="ln2340">              &amp;pp-&gt;pb_pointer[pb_idx + 1],</a>
<a name="ln2341">              (size_t)(total_moved) * sizeof(PTR_EN));</a>
<a name="ln2342">          pp_new-&gt;pb_count = total_moved;</a>
<a name="ln2343">          pp-&gt;pb_count -= total_moved - 1;</a>
<a name="ln2344">          pp-&gt;pb_pointer[pb_idx + 1].pe_bnum = bnum_right;</a>
<a name="ln2345">          pp-&gt;pb_pointer[pb_idx + 1].pe_line_count = line_count_right;</a>
<a name="ln2346">          pp-&gt;pb_pointer[pb_idx + 1].pe_page_count = page_count_right;</a>
<a name="ln2347">          if (lnum_right)</a>
<a name="ln2348">            pp-&gt;pb_pointer[pb_idx + 1].pe_old_lnum = lnum_right;</a>
<a name="ln2349">        } else {</a>
<a name="ln2350">          pp_new-&gt;pb_count = 1;</a>
<a name="ln2351">          pp_new-&gt;pb_pointer[0].pe_bnum = bnum_right;</a>
<a name="ln2352">          pp_new-&gt;pb_pointer[0].pe_line_count = line_count_right;</a>
<a name="ln2353">          pp_new-&gt;pb_pointer[0].pe_page_count = page_count_right;</a>
<a name="ln2354">          pp_new-&gt;pb_pointer[0].pe_old_lnum = lnum_right;</a>
<a name="ln2355">        }</a>
<a name="ln2356">        pp-&gt;pb_pointer[pb_idx].pe_bnum = bnum_left;</a>
<a name="ln2357">        pp-&gt;pb_pointer[pb_idx].pe_line_count = line_count_left;</a>
<a name="ln2358">        pp-&gt;pb_pointer[pb_idx].pe_page_count = page_count_left;</a>
<a name="ln2359">        if (lnum_left)</a>
<a name="ln2360">          pp-&gt;pb_pointer[pb_idx].pe_old_lnum = lnum_left;</a>
<a name="ln2361">        lnum_left = 0;</a>
<a name="ln2362">        lnum_right = 0;</a>
<a name="ln2363"> </a>
<a name="ln2364">        /*</a>
<a name="ln2365">         * recompute line counts</a>
<a name="ln2366">         */</a>
<a name="ln2367">        line_count_right = 0;</a>
<a name="ln2368">        for (i = 0; i &lt; (int)pp_new-&gt;pb_count; ++i)</a>
<a name="ln2369">          line_count_right += pp_new-&gt;pb_pointer[i].pe_line_count;</a>
<a name="ln2370">        line_count_left = 0;</a>
<a name="ln2371">        for (i = 0; i &lt; (int)pp-&gt;pb_count; ++i)</a>
<a name="ln2372">          line_count_left += pp-&gt;pb_pointer[i].pe_line_count;</a>
<a name="ln2373"> </a>
<a name="ln2374">        bnum_left = hp-&gt;bh_bnum;</a>
<a name="ln2375">        bnum_right = hp_new-&gt;bh_bnum;</a>
<a name="ln2376">        page_count_left = 1;</a>
<a name="ln2377">        page_count_right = 1;</a>
<a name="ln2378">        mf_put(mfp, hp, true, false);</a>
<a name="ln2379">        mf_put(mfp, hp_new, true, false);</a>
<a name="ln2380">      }</a>
<a name="ln2381">    }</a>
<a name="ln2382"> </a>
<a name="ln2383">    /*</a>
<a name="ln2384">     * Safety check: fallen out of for loop?</a>
<a name="ln2385">     */</a>
<a name="ln2386">    if (stack_idx &lt; 0) {</a>
<a name="ln2387">      IEMSG(_(&quot;E318: Updated too many blocks?&quot;));</a>
<a name="ln2388">      buf-&gt;b_ml.ml_stack_top = 0;       // invalidate stack</a>
<a name="ln2389">    }</a>
<a name="ln2390">  }</a>
<a name="ln2391"> </a>
<a name="ln2392">  /* The line was inserted below 'lnum' */</a>
<a name="ln2393">  ml_updatechunk(buf, lnum + 1, (long)len, ML_CHNK_ADDLINE);</a>
<a name="ln2394">  return OK;</a>
<a name="ln2395">}</a>
<a name="ln2396"> </a>
<a name="ln2397">void ml_add_deleted_len(char_u *ptr, ssize_t len)</a>
<a name="ln2398">{</a>
<a name="ln2399">  ml_add_deleted_len_buf(curbuf, ptr, len);</a>
<a name="ln2400">}</a>
<a name="ln2401"> </a>
<a name="ln2402">void ml_add_deleted_len_buf(buf_T *buf, char_u *ptr, ssize_t len)</a>
<a name="ln2403">{</a>
<a name="ln2404">  if (inhibit_delete_count) {</a>
<a name="ln2405">    return;</a>
<a name="ln2406">  }</a>
<a name="ln2407">  if (len == -1) {</a>
<a name="ln2408">    len = STRLEN(ptr);</a>
<a name="ln2409">  }</a>
<a name="ln2410">  curbuf-&gt;deleted_bytes += len+1;</a>
<a name="ln2411">  curbuf-&gt;deleted_bytes2 += len+1;</a>
<a name="ln2412">  if (curbuf-&gt;update_need_codepoints) {</a>
<a name="ln2413">    mb_utflen(ptr, len, &amp;curbuf-&gt;deleted_codepoints,</a>
<a name="ln2414">              &amp;curbuf-&gt;deleted_codeunits);</a>
<a name="ln2415">    curbuf-&gt;deleted_codepoints++;  // NL char</a>
<a name="ln2416">    curbuf-&gt;deleted_codeunits++;</a>
<a name="ln2417">  }</a>
<a name="ln2418">}</a>
<a name="ln2419"> </a>
<a name="ln2420"> </a>
<a name="ln2421">int ml_replace(linenr_T lnum, char_u *line, bool copy)</a>
<a name="ln2422">{</a>
<a name="ln2423">  return ml_replace_buf(curbuf, lnum, line, copy);</a>
<a name="ln2424">}</a>
<a name="ln2425"> </a>
<a name="ln2426">// Replace line &quot;lnum&quot;, with buffering, in current buffer.</a>
<a name="ln2427">//</a>
<a name="ln2428">// If &quot;copy&quot; is true, make a copy of the line, otherwise the line has been</a>
<a name="ln2429">// copied to allocated memory already.</a>
<a name="ln2430">// If &quot;copy&quot; is false the &quot;line&quot; may be freed to add text properties!</a>
<a name="ln2431">// Do not use it after calling ml_replace().</a>
<a name="ln2432">//</a>
<a name="ln2433">// Check: The caller of this function should probably also call</a>
<a name="ln2434">// changed_lines(), unless update_screen(NOT_VALID) is used.</a>
<a name="ln2435">//</a>
<a name="ln2436">// return FAIL for failure, OK otherwise</a>
<a name="ln2437">int ml_replace_buf(buf_T *buf, linenr_T lnum, char_u *line, bool copy)</a>
<a name="ln2438">{</a>
<a name="ln2439">  if (line == NULL)             /* just checking... */</a>
<a name="ln2440">    return FAIL;</a>
<a name="ln2441"> </a>
<a name="ln2442">  // When starting up, we might still need to create the memfile</a>
<a name="ln2443">  if (buf-&gt;b_ml.ml_mfp == NULL &amp;&amp; open_buffer(false, NULL, 0) == FAIL) {</a>
<a name="ln2444">    return FAIL;</a>
<a name="ln2445">  }</a>
<a name="ln2446"> </a>
<a name="ln2447">  bool readlen = true;</a>
<a name="ln2448"> </a>
<a name="ln2449">  if (copy) {</a>
<a name="ln2450">    line = vim_strsave(line);</a>
<a name="ln2451">  }</a>
<a name="ln2452">  if (buf-&gt;b_ml.ml_line_lnum != lnum) {  // other line buffered</a>
<a name="ln2453">    ml_flush_line(buf);  // flush it</a>
<a name="ln2454">  } else if (buf-&gt;b_ml.ml_flags &amp; ML_LINE_DIRTY) {  // same line allocated</a>
<a name="ln2455">    ml_add_deleted_len_buf(buf, buf-&gt;b_ml.ml_line_ptr, -1);</a>
<a name="ln2456">    readlen = false;  // already added the length</a>
<a name="ln2457"> </a>
<a name="ln2458">    xfree(buf-&gt;b_ml.ml_line_ptr);  // free it</a>
<a name="ln2459">  }</a>
<a name="ln2460"> </a>
<a name="ln2461">  if (readlen &amp;&amp; kv_size(buf-&gt;update_callbacks)) {</a>
<a name="ln2462">    ml_add_deleted_len_buf(buf, ml_get_buf(buf, lnum, false), -1);</a>
<a name="ln2463">  }</a>
<a name="ln2464"> </a>
<a name="ln2465">  buf-&gt;b_ml.ml_line_ptr = line;</a>
<a name="ln2466">  buf-&gt;b_ml.ml_line_lnum = lnum;</a>
<a name="ln2467">  buf-&gt;b_ml.ml_flags = (buf-&gt;b_ml.ml_flags | ML_LINE_DIRTY) &amp; ~ML_EMPTY;</a>
<a name="ln2468"> </a>
<a name="ln2469">  return OK;</a>
<a name="ln2470">}</a>
<a name="ln2471"> </a>
<a name="ln2472">/// Delete line `lnum` in the current buffer.</a>
<a name="ln2473">///</a>
<a name="ln2474">/// @note The caller of this function should probably also call</a>
<a name="ln2475">/// deleted_lines() after this.</a>
<a name="ln2476">///</a>
<a name="ln2477">/// @param message  Show &quot;--No lines in buffer--&quot; message.</a>
<a name="ln2478">/// @return FAIL for failure, OK otherwise</a>
<a name="ln2479">int ml_delete(linenr_T lnum, bool message)</a>
<a name="ln2480">{</a>
<a name="ln2481">  ml_flush_line(curbuf);</a>
<a name="ln2482">  return ml_delete_int(curbuf, lnum, message);</a>
<a name="ln2483">}</a>
<a name="ln2484"> </a>
<a name="ln2485">static int ml_delete_int(buf_T *buf, linenr_T lnum, bool message)</a>
<a name="ln2486">{</a>
<a name="ln2487">  bhdr_T      *hp;</a>
<a name="ln2488">  memfile_T   *mfp;</a>
<a name="ln2489">  DATA_BL     *dp;</a>
<a name="ln2490">  PTR_BL      *pp;</a>
<a name="ln2491">  infoptr_T   *ip;</a>
<a name="ln2492">  int count;                /* number of entries in block */</a>
<a name="ln2493">  int idx;</a>
<a name="ln2494">  int stack_idx;</a>
<a name="ln2495">  int text_start;</a>
<a name="ln2496">  int line_start;</a>
<a name="ln2497">  long line_size;</a>
<a name="ln2498">  int i;</a>
<a name="ln2499"> </a>
<a name="ln2500">  if (lnum &lt; 1 || lnum &gt; buf-&gt;b_ml.ml_line_count)</a>
<a name="ln2501">    return FAIL;</a>
<a name="ln2502"> </a>
<a name="ln2503">  if (lowest_marked &amp;&amp; lowest_marked &gt; lnum)</a>
<a name="ln2504">    lowest_marked--;</a>
<a name="ln2505"> </a>
<a name="ln2506">  /*</a>
<a name="ln2507">   * If the file becomes empty the last line is replaced by an empty line.</a>
<a name="ln2508">   */</a>
<a name="ln2509">  if (buf-&gt;b_ml.ml_line_count == 1) {       /* file becomes empty */</a>
<a name="ln2510">    if (message</a>
<a name="ln2511">        )</a>
<a name="ln2512">      set_keep_msg((char_u *)_(no_lines_msg), 0);</a>
<a name="ln2513"> </a>
<a name="ln2514">    i = ml_replace((linenr_T)1, (char_u *)&quot;&quot;, true);</a>
<a name="ln2515">    buf-&gt;b_ml.ml_flags |= ML_EMPTY;</a>
<a name="ln2516"> </a>
<a name="ln2517">    return i;</a>
<a name="ln2518">  }</a>
<a name="ln2519"> </a>
<a name="ln2520">  /*</a>
<a name="ln2521">   * find the data block containing the line</a>
<a name="ln2522">   * This also fills the stack with the blocks from the root to the data block</a>
<a name="ln2523">   * This also releases any locked block.</a>
<a name="ln2524">   */</a>
<a name="ln2525">  mfp = buf-&gt;b_ml.ml_mfp;</a>
<a name="ln2526">  if (mfp == NULL)</a>
<a name="ln2527">    return FAIL;</a>
<a name="ln2528"> </a>
<a name="ln2529">  if ((hp = ml_find_line(buf, lnum, ML_DELETE)) == NULL)</a>
<a name="ln2530">    return FAIL;</a>
<a name="ln2531"> </a>
<a name="ln2532">  dp = hp-&gt;bh_data;</a>
<a name="ln2533">  /* compute line count before the delete */</a>
<a name="ln2534">  count = (long)(buf-&gt;b_ml.ml_locked_high)</a>
<a name="ln2535">          - (long)(buf-&gt;b_ml.ml_locked_low) + 2;</a>
<a name="ln2536">  idx = lnum - buf-&gt;b_ml.ml_locked_low;</a>
<a name="ln2537"> </a>
<a name="ln2538">  --buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2539"> </a>
<a name="ln2540">  line_start = ((dp-&gt;db_index[idx]) &amp; DB_INDEX_MASK);</a>
<a name="ln2541">  if (idx == 0)                 /* first line in block, text at the end */</a>
<a name="ln2542">    line_size = dp-&gt;db_txt_end - line_start;</a>
<a name="ln2543">  else</a>
<a name="ln2544">    line_size = ((dp-&gt;db_index[idx - 1]) &amp; DB_INDEX_MASK) - line_start;</a>
<a name="ln2545"> </a>
<a name="ln2546">  // Line should always have an NL char internally (represented as NUL),</a>
<a name="ln2547">  // even if 'noeol' is set.</a>
<a name="ln2548">  assert(line_size &gt;= 1);</a>
<a name="ln2549">  ml_add_deleted_len_buf(buf, (char_u *)dp + line_start, line_size-1);</a>
<a name="ln2550"> </a>
<a name="ln2551">  /*</a>
<a name="ln2552">   * special case: If there is only one line in the data block it becomes empty.</a>
<a name="ln2553">   * Then we have to remove the entry, pointing to this data block, from the</a>
<a name="ln2554">   * pointer block. If this pointer block also becomes empty, we go up another</a>
<a name="ln2555">   * block, and so on, up to the root if necessary.</a>
<a name="ln2556">   * The line counts in the pointer blocks have already been adjusted by</a>
<a name="ln2557">   * ml_find_line().</a>
<a name="ln2558">   */</a>
<a name="ln2559">  if (count == 1) {</a>
<a name="ln2560">    mf_free(mfp, hp);           /* free the data block */</a>
<a name="ln2561">    buf-&gt;b_ml.ml_locked = NULL;</a>
<a name="ln2562"> </a>
<a name="ln2563">    for (stack_idx = buf-&gt;b_ml.ml_stack_top - 1; stack_idx &gt;= 0;</a>
<a name="ln2564">         --stack_idx) {</a>
<a name="ln2565">      buf-&gt;b_ml.ml_stack_top = 0;           /* stack is invalid when failing */</a>
<a name="ln2566">      ip = &amp;(buf-&gt;b_ml.ml_stack[stack_idx]);</a>
<a name="ln2567">      idx = ip-&gt;ip_index;</a>
<a name="ln2568">      if ((hp = mf_get(mfp, ip-&gt;ip_bnum, 1)) == NULL)</a>
<a name="ln2569">        return FAIL;</a>
<a name="ln2570">      pp = hp-&gt;bh_data;         /* must be pointer block */</a>
<a name="ln2571">      if (pp-&gt;pb_id != PTR_ID) {</a>
<a name="ln2572">        IEMSG(_(&quot;E317: pointer block id wrong 4&quot;));</a>
<a name="ln2573">        mf_put(mfp, hp, false, false);</a>
<a name="ln2574">        return FAIL;</a>
<a name="ln2575">      }</a>
<a name="ln2576">      count = --(pp-&gt;pb_count);</a>
<a name="ln2577">      if (count == 0)               /* the pointer block becomes empty! */</a>
<a name="ln2578">        mf_free(mfp, hp);</a>
<a name="ln2579">      else {</a>
<a name="ln2580">        if (count != idx)               /* move entries after the deleted one */</a>
<a name="ln2581">          memmove(&amp;pp-&gt;pb_pointer[idx], &amp;pp-&gt;pb_pointer[idx + 1],</a>
<a name="ln2582">              (size_t)(count - idx) * sizeof(PTR_EN));</a>
<a name="ln2583">        mf_put(mfp, hp, true, false);</a>
<a name="ln2584"> </a>
<a name="ln2585">        buf-&gt;b_ml.ml_stack_top = stack_idx;             /* truncate stack */</a>
<a name="ln2586">        /* fix line count for rest of blocks in the stack */</a>
<a name="ln2587">        if (buf-&gt;b_ml.ml_locked_lineadd != 0) {</a>
<a name="ln2588">          ml_lineadd(buf, buf-&gt;b_ml.ml_locked_lineadd);</a>
<a name="ln2589">          buf-&gt;b_ml.ml_stack[buf-&gt;b_ml.ml_stack_top].ip_high +=</a>
<a name="ln2590">            buf-&gt;b_ml.ml_locked_lineadd;</a>
<a name="ln2591">        }</a>
<a name="ln2592">        ++(buf-&gt;b_ml.ml_stack_top);</a>
<a name="ln2593"> </a>
<a name="ln2594">        break;</a>
<a name="ln2595">      }</a>
<a name="ln2596">    }</a>
<a name="ln2597">    CHECK(stack_idx &lt; 0, _(&quot;deleted block 1?&quot;));</a>
<a name="ln2598">  } else {</a>
<a name="ln2599">    /*</a>
<a name="ln2600">     * delete the text by moving the next lines forwards</a>
<a name="ln2601">     */</a>
<a name="ln2602">    text_start = dp-&gt;db_txt_start;</a>
<a name="ln2603">    memmove((char *)dp + text_start + line_size,</a>
<a name="ln2604">        (char *)dp + text_start, (size_t)(line_start - text_start));</a>
<a name="ln2605"> </a>
<a name="ln2606">    /*</a>
<a name="ln2607">     * delete the index by moving the next indexes backwards</a>
<a name="ln2608">     * Adjust the indexes for the text movement.</a>
<a name="ln2609">     */</a>
<a name="ln2610">    for (i = idx; i &lt; count - 1; ++i)</a>
<a name="ln2611">      dp-&gt;db_index[i] = dp-&gt;db_index[i + 1] + line_size;</a>
<a name="ln2612"> </a>
<a name="ln2613">    dp-&gt;db_free += line_size + INDEX_SIZE;</a>
<a name="ln2614">    dp-&gt;db_txt_start += line_size;</a>
<a name="ln2615">    --(dp-&gt;db_line_count);</a>
<a name="ln2616"> </a>
<a name="ln2617">    /*</a>
<a name="ln2618">     * mark the block dirty and make sure it is in the file (for recovery)</a>
<a name="ln2619">     */</a>
<a name="ln2620">    buf-&gt;b_ml.ml_flags |= (ML_LOCKED_DIRTY | ML_LOCKED_POS);</a>
<a name="ln2621">  }</a>
<a name="ln2622"> </a>
<a name="ln2623">  ml_updatechunk(buf, lnum, line_size, ML_CHNK_DELLINE);</a>
<a name="ln2624">  return OK;</a>
<a name="ln2625">}</a>
<a name="ln2626"> </a>
<a name="ln2627">/*</a>
<a name="ln2628"> * set the B_MARKED flag for line 'lnum'</a>
<a name="ln2629"> */</a>
<a name="ln2630">void ml_setmarked(linenr_T lnum)</a>
<a name="ln2631">{</a>
<a name="ln2632">  bhdr_T    *hp;</a>
<a name="ln2633">  DATA_BL *dp;</a>
<a name="ln2634">  /* invalid line number */</a>
<a name="ln2635">  if (lnum &lt; 1 || lnum &gt; curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln2636">      || curbuf-&gt;b_ml.ml_mfp == NULL)</a>
<a name="ln2637">    return;                         /* give error message? */</a>
<a name="ln2638"> </a>
<a name="ln2639">  if (lowest_marked == 0 || lowest_marked &gt; lnum)</a>
<a name="ln2640">    lowest_marked = lnum;</a>
<a name="ln2641"> </a>
<a name="ln2642">  /*</a>
<a name="ln2643">   * find the data block containing the line</a>
<a name="ln2644">   * This also fills the stack with the blocks from the root to the data block</a>
<a name="ln2645">   * This also releases any locked block.</a>
<a name="ln2646">   */</a>
<a name="ln2647">  if ((hp = ml_find_line(curbuf, lnum, ML_FIND)) == NULL)</a>
<a name="ln2648">    return;                 /* give error message? */</a>
<a name="ln2649"> </a>
<a name="ln2650">  dp = hp-&gt;bh_data;</a>
<a name="ln2651">  dp-&gt;db_index[lnum - curbuf-&gt;b_ml.ml_locked_low] |= DB_MARKED;</a>
<a name="ln2652">  curbuf-&gt;b_ml.ml_flags |= ML_LOCKED_DIRTY;</a>
<a name="ln2653">}</a>
<a name="ln2654"> </a>
<a name="ln2655">/*</a>
<a name="ln2656"> * find the first line with its B_MARKED flag set</a>
<a name="ln2657"> */</a>
<a name="ln2658">linenr_T ml_firstmarked(void)</a>
<a name="ln2659">{</a>
<a name="ln2660">  bhdr_T      *hp;</a>
<a name="ln2661">  DATA_BL     *dp;</a>
<a name="ln2662">  linenr_T lnum;</a>
<a name="ln2663">  int i;</a>
<a name="ln2664"> </a>
<a name="ln2665">  if (curbuf-&gt;b_ml.ml_mfp == NULL)</a>
<a name="ln2666">    return (linenr_T) 0;</a>
<a name="ln2667"> </a>
<a name="ln2668">  /*</a>
<a name="ln2669">   * The search starts with lowest_marked line. This is the last line where</a>
<a name="ln2670">   * a mark was found, adjusted by inserting/deleting lines.</a>
<a name="ln2671">   */</a>
<a name="ln2672">  for (lnum = lowest_marked; lnum &lt;= curbuf-&gt;b_ml.ml_line_count; ) {</a>
<a name="ln2673">    /*</a>
<a name="ln2674">     * Find the data block containing the line.</a>
<a name="ln2675">     * This also fills the stack with the blocks from the root to the data</a>
<a name="ln2676">     * block This also releases any locked block.</a>
<a name="ln2677">     */</a>
<a name="ln2678">    if ((hp = ml_find_line(curbuf, lnum, ML_FIND)) == NULL)</a>
<a name="ln2679">      return (linenr_T)0;                   /* give error message? */</a>
<a name="ln2680"> </a>
<a name="ln2681">    dp = hp-&gt;bh_data;</a>
<a name="ln2682"> </a>
<a name="ln2683">    for (i = lnum - curbuf-&gt;b_ml.ml_locked_low;</a>
<a name="ln2684">         lnum &lt;= curbuf-&gt;b_ml.ml_locked_high; ++i, ++lnum)</a>
<a name="ln2685">      if ((dp-&gt;db_index[i]) &amp; DB_MARKED) {</a>
<a name="ln2686">        (dp-&gt;db_index[i]) &amp;= DB_INDEX_MASK;</a>
<a name="ln2687">        curbuf-&gt;b_ml.ml_flags |= ML_LOCKED_DIRTY;</a>
<a name="ln2688">        lowest_marked = lnum + 1;</a>
<a name="ln2689">        return lnum;</a>
<a name="ln2690">      }</a>
<a name="ln2691">  }</a>
<a name="ln2692"> </a>
<a name="ln2693">  return (linenr_T) 0;</a>
<a name="ln2694">}</a>
<a name="ln2695"> </a>
<a name="ln2696">/*</a>
<a name="ln2697"> * clear all DB_MARKED flags</a>
<a name="ln2698"> */</a>
<a name="ln2699">void ml_clearmarked(void)</a>
<a name="ln2700">{</a>
<a name="ln2701">  bhdr_T      *hp;</a>
<a name="ln2702">  DATA_BL     *dp;</a>
<a name="ln2703">  linenr_T lnum;</a>
<a name="ln2704">  int i;</a>
<a name="ln2705"> </a>
<a name="ln2706">  if (curbuf-&gt;b_ml.ml_mfp == NULL)          /* nothing to do */</a>
<a name="ln2707">    return;</a>
<a name="ln2708"> </a>
<a name="ln2709">  /*</a>
<a name="ln2710">   * The search starts with line lowest_marked.</a>
<a name="ln2711">   */</a>
<a name="ln2712">  for (lnum = lowest_marked; lnum &lt;= curbuf-&gt;b_ml.ml_line_count; ) {</a>
<a name="ln2713">    /*</a>
<a name="ln2714">     * Find the data block containing the line.</a>
<a name="ln2715">     * This also fills the stack with the blocks from the root to the data</a>
<a name="ln2716">     * block and releases any locked block.</a>
<a name="ln2717">     */</a>
<a name="ln2718">    if ((hp = ml_find_line(curbuf, lnum, ML_FIND)) == NULL)</a>
<a name="ln2719">      return;                   /* give error message? */</a>
<a name="ln2720"> </a>
<a name="ln2721">    dp = hp-&gt;bh_data;</a>
<a name="ln2722"> </a>
<a name="ln2723">    for (i = lnum - curbuf-&gt;b_ml.ml_locked_low;</a>
<a name="ln2724">         lnum &lt;= curbuf-&gt;b_ml.ml_locked_high; ++i, ++lnum)</a>
<a name="ln2725">      if ((dp-&gt;db_index[i]) &amp; DB_MARKED) {</a>
<a name="ln2726">        (dp-&gt;db_index[i]) &amp;= DB_INDEX_MASK;</a>
<a name="ln2727">        curbuf-&gt;b_ml.ml_flags |= ML_LOCKED_DIRTY;</a>
<a name="ln2728">      }</a>
<a name="ln2729">  }</a>
<a name="ln2730"> </a>
<a name="ln2731">  lowest_marked = 0;</a>
<a name="ln2732">  return;</a>
<a name="ln2733">}</a>
<a name="ln2734"> </a>
<a name="ln2735">size_t ml_flush_deleted_bytes(buf_T *buf, size_t *codepoints, size_t *codeunits)</a>
<a name="ln2736">{</a>
<a name="ln2737">  size_t ret = buf-&gt;deleted_bytes;</a>
<a name="ln2738">  *codepoints = buf-&gt;deleted_codepoints;</a>
<a name="ln2739">  *codeunits = buf-&gt;deleted_codeunits;</a>
<a name="ln2740">  buf-&gt;deleted_bytes = 0;</a>
<a name="ln2741">  buf-&gt;deleted_codepoints = 0;</a>
<a name="ln2742">  buf-&gt;deleted_codeunits = 0;</a>
<a name="ln2743">  return ret;</a>
<a name="ln2744">}</a>
<a name="ln2745"> </a>
<a name="ln2746">/*</a>
<a name="ln2747"> * flush ml_line if necessary</a>
<a name="ln2748"> */</a>
<a name="ln2749">static void ml_flush_line(buf_T *buf)</a>
<a name="ln2750">{</a>
<a name="ln2751">  bhdr_T      *hp;</a>
<a name="ln2752">  DATA_BL     *dp;</a>
<a name="ln2753">  linenr_T lnum;</a>
<a name="ln2754">  char_u      *new_line;</a>
<a name="ln2755">  char_u      *old_line;</a>
<a name="ln2756">  colnr_T new_len;</a>
<a name="ln2757">  int old_len;</a>
<a name="ln2758">  int extra;</a>
<a name="ln2759">  int idx;</a>
<a name="ln2760">  int start;</a>
<a name="ln2761">  int count;</a>
<a name="ln2762">  int i;</a>
<a name="ln2763">  static int entered = FALSE;</a>
<a name="ln2764"> </a>
<a name="ln2765">  if (buf-&gt;b_ml.ml_line_lnum == 0 || buf-&gt;b_ml.ml_mfp == NULL)</a>
<a name="ln2766">    return;             /* nothing to do */</a>
<a name="ln2767"> </a>
<a name="ln2768">  if (buf-&gt;b_ml.ml_flags &amp; ML_LINE_DIRTY) {</a>
<a name="ln2769">    /* This code doesn't work recursively. */</a>
<a name="ln2770">    if (entered)</a>
<a name="ln2771">      return;</a>
<a name="ln2772">    entered = TRUE;</a>
<a name="ln2773"> </a>
<a name="ln2774">    buf-&gt;flush_count++;</a>
<a name="ln2775"> </a>
<a name="ln2776">    lnum = buf-&gt;b_ml.ml_line_lnum;</a>
<a name="ln2777">    new_line = buf-&gt;b_ml.ml_line_ptr;</a>
<a name="ln2778"> </a>
<a name="ln2779">    hp = ml_find_line(buf, lnum, ML_FIND);</a>
<a name="ln2780">    if (hp == NULL) {</a>
<a name="ln2781">      IEMSGN(_(&quot;E320: Cannot find line %&quot; PRId64), lnum);</a>
<a name="ln2782">    } else {</a>
<a name="ln2783">      dp = hp-&gt;bh_data;</a>
<a name="ln2784">      idx = lnum - buf-&gt;b_ml.ml_locked_low;</a>
<a name="ln2785">      start = ((dp-&gt;db_index[idx]) &amp; DB_INDEX_MASK);</a>
<a name="ln2786">      old_line = (char_u *)dp + start;</a>
<a name="ln2787">      if (idx == 0)             /* line is last in block */</a>
<a name="ln2788">        old_len = dp-&gt;db_txt_end - start;</a>
<a name="ln2789">      else                      /* text of previous line follows */</a>
<a name="ln2790">        old_len = (dp-&gt;db_index[idx - 1] &amp; DB_INDEX_MASK) - start;</a>
<a name="ln2791">      new_len = (colnr_T)STRLEN(new_line) + 1;</a>
<a name="ln2792">      extra = new_len - old_len;            /* negative if lines gets smaller */</a>
<a name="ln2793"> </a>
<a name="ln2794">      /*</a>
<a name="ln2795">       * if new line fits in data block, replace directly</a>
<a name="ln2796">       */</a>
<a name="ln2797">      if ((int)dp-&gt;db_free &gt;= extra) {</a>
<a name="ln2798">        /* if the length changes and there are following lines */</a>
<a name="ln2799">        count = buf-&gt;b_ml.ml_locked_high - buf-&gt;b_ml.ml_locked_low + 1;</a>
<a name="ln2800">        if (extra != 0 &amp;&amp; idx &lt; count - 1) {</a>
<a name="ln2801">          /* move text of following lines */</a>
<a name="ln2802">          memmove((char *)dp + dp-&gt;db_txt_start - extra,</a>
<a name="ln2803">              (char *)dp + dp-&gt;db_txt_start,</a>
<a name="ln2804">              (size_t)(start - dp-&gt;db_txt_start));</a>
<a name="ln2805"> </a>
<a name="ln2806">          /* adjust pointers of this and following lines */</a>
<a name="ln2807">          for (i = idx + 1; i &lt; count; ++i)</a>
<a name="ln2808">            dp-&gt;db_index[i] -= extra;</a>
<a name="ln2809">        }</a>
<a name="ln2810">        dp-&gt;db_index[idx] -= extra;</a>
<a name="ln2811"> </a>
<a name="ln2812">        /* adjust free space */</a>
<a name="ln2813">        dp-&gt;db_free -= extra;</a>
<a name="ln2814">        dp-&gt;db_txt_start -= extra;</a>
<a name="ln2815"> </a>
<a name="ln2816">        /* copy new line into the data block */</a>
<a name="ln2817">        memmove(old_line - extra, new_line, (size_t)new_len);</a>
<a name="ln2818">        buf-&gt;b_ml.ml_flags |= (ML_LOCKED_DIRTY | ML_LOCKED_POS);</a>
<a name="ln2819">        /* The else case is already covered by the insert and delete */</a>
<a name="ln2820">        ml_updatechunk(buf, lnum, (long)extra, ML_CHNK_UPDLINE);</a>
<a name="ln2821">      } else {</a>
<a name="ln2822">        // Cannot do it in one data block: Delete and append.</a>
<a name="ln2823">        // Append first, because ml_delete_int() cannot delete the</a>
<a name="ln2824">        // last line in a buffer, which causes trouble for a buffer</a>
<a name="ln2825">        // that has only one line.</a>
<a name="ln2826">        // Don't forget to copy the mark!</a>
<a name="ln2827">        // How about handling errors???</a>
<a name="ln2828">        (void)ml_append_int(buf, lnum, new_line, new_len, false,</a>
<a name="ln2829">                            (dp-&gt;db_index[idx] &amp; DB_MARKED));</a>
<a name="ln2830">        (void)ml_delete_int(buf, lnum, false);</a>
<a name="ln2831">      }</a>
<a name="ln2832">    }</a>
<a name="ln2833">    xfree(new_line);</a>
<a name="ln2834"> </a>
<a name="ln2835">    entered = FALSE;</a>
<a name="ln2836">  }</a>
<a name="ln2837"> </a>
<a name="ln2838">  buf-&gt;b_ml.ml_line_lnum = 0;</a>
<a name="ln2839">  buf-&gt;b_ml.ml_line_offset = 0;</a>
<a name="ln2840">}</a>
<a name="ln2841"> </a>
<a name="ln2842">/*</a>
<a name="ln2843"> * create a new, empty, data block</a>
<a name="ln2844"> */</a>
<a name="ln2845">static bhdr_T *ml_new_data(memfile_T *mfp, bool negative, int page_count)</a>
<a name="ln2846">{</a>
<a name="ln2847">  assert(page_count &gt;= 0);</a>
<a name="ln2848">  bhdr_T *hp = mf_new(mfp, negative, (unsigned)page_count);</a>
<a name="ln2849">  DATA_BL *dp = hp-&gt;bh_data;</a>
<a name="ln2850">  dp-&gt;db_id = DATA_ID;</a>
<a name="ln2851">  dp-&gt;db_txt_start = dp-&gt;db_txt_end = page_count * mfp-&gt;mf_page_size;</a>
<a name="ln2852">  dp-&gt;db_free = dp-&gt;db_txt_start - HEADER_SIZE;</a>
<a name="ln2853">  dp-&gt;db_line_count = 0;</a>
<a name="ln2854"> </a>
<a name="ln2855">  return hp;</a>
<a name="ln2856">}</a>
<a name="ln2857"> </a>
<a name="ln2858">/*</a>
<a name="ln2859"> * create a new, empty, pointer block</a>
<a name="ln2860"> */</a>
<a name="ln2861">static bhdr_T *ml_new_ptr(memfile_T *mfp)</a>
<a name="ln2862">{</a>
<a name="ln2863">  bhdr_T *hp = mf_new(mfp, false, 1);</a>
<a name="ln2864">  PTR_BL *pp = hp-&gt;bh_data;</a>
<a name="ln2865">  pp-&gt;pb_id = PTR_ID;</a>
<a name="ln2866">  pp-&gt;pb_count = 0;</a>
<a name="ln2867">  pp-&gt;pb_count_max = (mfp-&gt;mf_page_size - sizeof(PTR_BL)) / sizeof(PTR_EN) + 1;</a>
<a name="ln2868"> </a>
<a name="ln2869">  return hp;</a>
<a name="ln2870">}</a>
<a name="ln2871"> </a>
<a name="ln2872">/*</a>
<a name="ln2873"> * lookup line 'lnum' in a memline</a>
<a name="ln2874"> *</a>
<a name="ln2875"> *   action: if ML_DELETE or ML_INSERT the line count is updated while searching</a>
<a name="ln2876"> *	     if ML_FLUSH only flush a locked block</a>
<a name="ln2877"> *	     if ML_FIND just find the line</a>
<a name="ln2878"> *</a>
<a name="ln2879"> * If the block was found it is locked and put in ml_locked.</a>
<a name="ln2880"> * The stack is updated to lead to the locked block. The ip_high field in</a>
<a name="ln2881"> * the stack is updated to reflect the last line in the block AFTER the</a>
<a name="ln2882"> * insert or delete, also if the pointer block has not been updated yet. But</a>
<a name="ln2883"> * if ml_locked != NULL ml_locked_lineadd must be added to ip_high.</a>
<a name="ln2884"> *</a>
<a name="ln2885"> * return: NULL for failure, pointer to block header otherwise</a>
<a name="ln2886"> */</a>
<a name="ln2887">static bhdr_T *ml_find_line(buf_T *buf, linenr_T lnum, int action)</a>
<a name="ln2888">{</a>
<a name="ln2889">  DATA_BL     *dp;</a>
<a name="ln2890">  PTR_BL      *pp;</a>
<a name="ln2891">  infoptr_T   *ip;</a>
<a name="ln2892">  bhdr_T      *hp;</a>
<a name="ln2893">  memfile_T   *mfp;</a>
<a name="ln2894">  linenr_T t;</a>
<a name="ln2895">  blocknr_T bnum, bnum2;</a>
<a name="ln2896">  int dirty;</a>
<a name="ln2897">  linenr_T low, high;</a>
<a name="ln2898">  int top;</a>
<a name="ln2899">  int page_count;</a>
<a name="ln2900">  int idx;</a>
<a name="ln2901"> </a>
<a name="ln2902">  mfp = buf-&gt;b_ml.ml_mfp;</a>
<a name="ln2903"> </a>
<a name="ln2904">  /*</a>
<a name="ln2905">   * If there is a locked block check if the wanted line is in it.</a>
<a name="ln2906">   * If not, flush and release the locked block.</a>
<a name="ln2907">   * Don't do this for ML_INSERT_SAME, because the stack need to be updated.</a>
<a name="ln2908">   * Don't do this for ML_FLUSH, because we want to flush the locked block.</a>
<a name="ln2909">   * Don't do this when 'swapfile' is reset, we want to load all the blocks.</a>
<a name="ln2910">   */</a>
<a name="ln2911">  if (buf-&gt;b_ml.ml_locked) {</a>
<a name="ln2912">    if (ML_SIMPLE(action)</a>
<a name="ln2913">        &amp;&amp; buf-&gt;b_ml.ml_locked_low &lt;= lnum</a>
<a name="ln2914">        &amp;&amp; buf-&gt;b_ml.ml_locked_high &gt;= lnum) {</a>
<a name="ln2915">      // remember to update pointer blocks and stack later</a>
<a name="ln2916">      if (action == ML_INSERT) {</a>
<a name="ln2917">        ++(buf-&gt;b_ml.ml_locked_lineadd);</a>
<a name="ln2918">        ++(buf-&gt;b_ml.ml_locked_high);</a>
<a name="ln2919">      } else if (action == ML_DELETE) {</a>
<a name="ln2920">        --(buf-&gt;b_ml.ml_locked_lineadd);</a>
<a name="ln2921">        --(buf-&gt;b_ml.ml_locked_high);</a>
<a name="ln2922">      }</a>
<a name="ln2923">      return buf-&gt;b_ml.ml_locked;</a>
<a name="ln2924">    }</a>
<a name="ln2925"> </a>
<a name="ln2926">    mf_put(mfp, buf-&gt;b_ml.ml_locked, buf-&gt;b_ml.ml_flags &amp; ML_LOCKED_DIRTY,</a>
<a name="ln2927">        buf-&gt;b_ml.ml_flags &amp; ML_LOCKED_POS);</a>
<a name="ln2928">    buf-&gt;b_ml.ml_locked = NULL;</a>
<a name="ln2929"> </a>
<a name="ln2930">    /*</a>
<a name="ln2931">     * If lines have been added or deleted in the locked block, need to</a>
<a name="ln2932">     * update the line count in pointer blocks.</a>
<a name="ln2933">     */</a>
<a name="ln2934">    if (buf-&gt;b_ml.ml_locked_lineadd != 0)</a>
<a name="ln2935">      ml_lineadd(buf, buf-&gt;b_ml.ml_locked_lineadd);</a>
<a name="ln2936">  }</a>
<a name="ln2937"> </a>
<a name="ln2938">  if (action == ML_FLUSH)           /* nothing else to do */</a>
<a name="ln2939">    return NULL;</a>
<a name="ln2940"> </a>
<a name="ln2941">  bnum = 1;                         /* start at the root of the tree */</a>
<a name="ln2942">  page_count = 1;</a>
<a name="ln2943">  low = 1;</a>
<a name="ln2944">  high = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2945"> </a>
<a name="ln2946">  if (action == ML_FIND) {      /* first try stack entries */</a>
<a name="ln2947">    for (top = buf-&gt;b_ml.ml_stack_top - 1; top &gt;= 0; --top) {</a>
<a name="ln2948">      ip = &amp;(buf-&gt;b_ml.ml_stack[top]);</a>
<a name="ln2949">      if (ip-&gt;ip_low &lt;= lnum &amp;&amp; ip-&gt;ip_high &gt;= lnum) {</a>
<a name="ln2950">        bnum = ip-&gt;ip_bnum;</a>
<a name="ln2951">        low = ip-&gt;ip_low;</a>
<a name="ln2952">        high = ip-&gt;ip_high;</a>
<a name="ln2953">        buf-&gt;b_ml.ml_stack_top = top;           /* truncate stack at prev entry */</a>
<a name="ln2954">        break;</a>
<a name="ln2955">      }</a>
<a name="ln2956">    }</a>
<a name="ln2957">    if (top &lt; 0)</a>
<a name="ln2958">      buf-&gt;b_ml.ml_stack_top = 0;               /* not found, start at the root */</a>
<a name="ln2959">  } else        /* ML_DELETE or ML_INSERT */</a>
<a name="ln2960">    buf-&gt;b_ml.ml_stack_top = 0;         /* start at the root */</a>
<a name="ln2961"> </a>
<a name="ln2962">  /*</a>
<a name="ln2963">   * search downwards in the tree until a data block is found</a>
<a name="ln2964">   */</a>
<a name="ln2965">  for (;; ) {</a>
<a name="ln2966">    if ((hp = mf_get(mfp, bnum, page_count)) == NULL)</a>
<a name="ln2967">      goto error_noblock;</a>
<a name="ln2968"> </a>
<a name="ln2969">    /*</a>
<a name="ln2970">     * update high for insert/delete</a>
<a name="ln2971">     */</a>
<a name="ln2972">    if (action == ML_INSERT)</a>
<a name="ln2973">      ++high;</a>
<a name="ln2974">    else if (action == ML_DELETE)</a>
<a name="ln2975">      --high;</a>
<a name="ln2976"> </a>
<a name="ln2977">    dp = hp-&gt;bh_data;</a>
<a name="ln2978">    if (dp-&gt;db_id == DATA_ID) {         /* data block */</a>
<a name="ln2979">      buf-&gt;b_ml.ml_locked = hp;</a>
<a name="ln2980">      buf-&gt;b_ml.ml_locked_low = low;</a>
<a name="ln2981">      buf-&gt;b_ml.ml_locked_high = high;</a>
<a name="ln2982">      buf-&gt;b_ml.ml_locked_lineadd = 0;</a>
<a name="ln2983">      buf-&gt;b_ml.ml_flags &amp;= ~(ML_LOCKED_DIRTY | ML_LOCKED_POS);</a>
<a name="ln2984">      return hp;</a>
<a name="ln2985">    }</a>
<a name="ln2986"> </a>
<a name="ln2987">    pp = (PTR_BL *)(dp);                /* must be pointer block */</a>
<a name="ln2988">    if (pp-&gt;pb_id != PTR_ID) {</a>
<a name="ln2989">      IEMSG(_(&quot;E317: pointer block id wrong&quot;));</a>
<a name="ln2990">      goto error_block;</a>
<a name="ln2991">    }</a>
<a name="ln2992"> </a>
<a name="ln2993">    top = ml_add_stack(buf);  // add new entry to stack</a>
<a name="ln2994">    ip = &amp;(buf-&gt;b_ml.ml_stack[top]);</a>
<a name="ln2995">    ip-&gt;ip_bnum = bnum;</a>
<a name="ln2996">    ip-&gt;ip_low = low;</a>
<a name="ln2997">    ip-&gt;ip_high = high;</a>
<a name="ln2998">    ip-&gt;ip_index = -1;                  /* index not known yet */</a>
<a name="ln2999"> </a>
<a name="ln3000">    dirty = FALSE;</a>
<a name="ln3001">    for (idx = 0; idx &lt; (int)pp-&gt;pb_count; ++idx) {</a>
<a name="ln3002">      t = pp-&gt;pb_pointer[idx].pe_line_count;</a>
<a name="ln3003">      CHECK(t == 0, _(&quot;pe_line_count is zero&quot;));</a>
<a name="ln3004">      if ((low += t) &gt; lnum) {</a>
<a name="ln3005">        ip-&gt;ip_index = idx;</a>
<a name="ln3006">        bnum = pp-&gt;pb_pointer[idx].pe_bnum;</a>
<a name="ln3007">        page_count = pp-&gt;pb_pointer[idx].pe_page_count;</a>
<a name="ln3008">        high = low - 1;</a>
<a name="ln3009">        low -= t;</a>
<a name="ln3010"> </a>
<a name="ln3011">        /*</a>
<a name="ln3012">         * a negative block number may have been changed</a>
<a name="ln3013">         */</a>
<a name="ln3014">        if (bnum &lt; 0) {</a>
<a name="ln3015">          bnum2 = mf_trans_del(mfp, bnum);</a>
<a name="ln3016">          if (bnum != bnum2) {</a>
<a name="ln3017">            bnum = bnum2;</a>
<a name="ln3018">            pp-&gt;pb_pointer[idx].pe_bnum = bnum;</a>
<a name="ln3019">            dirty = TRUE;</a>
<a name="ln3020">          }</a>
<a name="ln3021">        }</a>
<a name="ln3022"> </a>
<a name="ln3023">        break;</a>
<a name="ln3024">      }</a>
<a name="ln3025">    }</a>
<a name="ln3026">    if (idx &gt;= (int)pp-&gt;pb_count) {         // past the end: something wrong!</a>
<a name="ln3027">      if (lnum &gt; buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3028">        IEMSGN(_(&quot;E322: line number out of range: %&quot; PRId64 &quot; past the end&quot;),</a>
<a name="ln3029">               lnum - buf-&gt;b_ml.ml_line_count);</a>
<a name="ln3030"> </a>
<a name="ln3031">      } else {</a>
<a name="ln3032">        IEMSGN(_(&quot;E323: line count wrong in block %&quot; PRId64), bnum);</a>
<a name="ln3033">      }</a>
<a name="ln3034">      goto error_block;</a>
<a name="ln3035">    }</a>
<a name="ln3036">    if (action == ML_DELETE) {</a>
<a name="ln3037">      pp-&gt;pb_pointer[idx].pe_line_count--;</a>
<a name="ln3038">      dirty = TRUE;</a>
<a name="ln3039">    } else if (action == ML_INSERT) {</a>
<a name="ln3040">      pp-&gt;pb_pointer[idx].pe_line_count++;</a>
<a name="ln3041">      dirty = TRUE;</a>
<a name="ln3042">    }</a>
<a name="ln3043">    mf_put(mfp, hp, dirty, false);</a>
<a name="ln3044">  }</a>
<a name="ln3045"> </a>
<a name="ln3046">error_block:</a>
<a name="ln3047">  mf_put(mfp, hp, false, false);</a>
<a name="ln3048">error_noblock:</a>
<a name="ln3049">  /*</a>
<a name="ln3050">   * If action is ML_DELETE or ML_INSERT we have to correct the tree for</a>
<a name="ln3051">   * the incremented/decremented line counts, because there won't be a line</a>
<a name="ln3052">   * inserted/deleted after all.</a>
<a name="ln3053">   */</a>
<a name="ln3054">  if (action == ML_DELETE)</a>
<a name="ln3055">    ml_lineadd(buf, 1);</a>
<a name="ln3056">  else if (action == ML_INSERT)</a>
<a name="ln3057">    ml_lineadd(buf, -1);</a>
<a name="ln3058">  buf-&gt;b_ml.ml_stack_top = 0;</a>
<a name="ln3059">  return NULL;</a>
<a name="ln3060">}</a>
<a name="ln3061"> </a>
<a name="ln3062">/*</a>
<a name="ln3063"> * add an entry to the info pointer stack</a>
<a name="ln3064"> *</a>
<a name="ln3065"> * return number of the new entry</a>
<a name="ln3066"> */</a>
<a name="ln3067">static int ml_add_stack(buf_T *buf)</a>
<a name="ln3068">{</a>
<a name="ln3069">  int top = buf-&gt;b_ml.ml_stack_top;</a>
<a name="ln3070"> </a>
<a name="ln3071">  /* may have to increase the stack size */</a>
<a name="ln3072">  if (top == buf-&gt;b_ml.ml_stack_size) {</a>
<a name="ln3073">    CHECK(top &gt; 0, _(&quot;Stack size increases&quot;));     /* more than 5 levels??? */</a>
<a name="ln3074"> </a>
<a name="ln3075">    buf-&gt;b_ml.ml_stack_size += STACK_INCR;</a>
<a name="ln3076">    size_t new_size = sizeof(infoptr_T) * buf-&gt;b_ml.ml_stack_size;</a>
<a name="ln3077">    buf-&gt;b_ml.ml_stack = xrealloc(buf-&gt;b_ml.ml_stack, new_size);</a>
<a name="ln3078">  }</a>
<a name="ln3079"> </a>
<a name="ln3080">  buf-&gt;b_ml.ml_stack_top++;</a>
<a name="ln3081">  return top;</a>
<a name="ln3082">}</a>
<a name="ln3083"> </a>
<a name="ln3084">/*</a>
<a name="ln3085"> * Update the pointer blocks on the stack for inserted/deleted lines.</a>
<a name="ln3086"> * The stack itself is also updated.</a>
<a name="ln3087"> *</a>
<a name="ln3088"> * When an insert/delete line action fails, the line is not inserted/deleted,</a>
<a name="ln3089"> * but the pointer blocks have already been updated. That is fixed here by</a>
<a name="ln3090"> * walking through the stack.</a>
<a name="ln3091"> *</a>
<a name="ln3092"> * Count is the number of lines added, negative if lines have been deleted.</a>
<a name="ln3093"> */</a>
<a name="ln3094">static void ml_lineadd(buf_T *buf, int count)</a>
<a name="ln3095">{</a>
<a name="ln3096">  int idx;</a>
<a name="ln3097">  infoptr_T   *ip;</a>
<a name="ln3098">  PTR_BL      *pp;</a>
<a name="ln3099">  memfile_T   *mfp = buf-&gt;b_ml.ml_mfp;</a>
<a name="ln3100">  bhdr_T      *hp;</a>
<a name="ln3101"> </a>
<a name="ln3102">  for (idx = buf-&gt;b_ml.ml_stack_top - 1; idx &gt;= 0; --idx) {</a>
<a name="ln3103">    ip = &amp;(buf-&gt;b_ml.ml_stack[idx]);</a>
<a name="ln3104">    if ((hp = mf_get(mfp, ip-&gt;ip_bnum, 1)) == NULL)</a>
<a name="ln3105">      break;</a>
<a name="ln3106">    pp = hp-&gt;bh_data;       /* must be pointer block */</a>
<a name="ln3107">    if (pp-&gt;pb_id != PTR_ID) {</a>
<a name="ln3108">      mf_put(mfp, hp, false, false);</a>
<a name="ln3109">      IEMSG(_(&quot;E317: pointer block id wrong 2&quot;));</a>
<a name="ln3110">      break;</a>
<a name="ln3111">    }</a>
<a name="ln3112">    pp-&gt;pb_pointer[ip-&gt;ip_index].pe_line_count += count;</a>
<a name="ln3113">    ip-&gt;ip_high += count;</a>
<a name="ln3114">    mf_put(mfp, hp, true, false);</a>
<a name="ln3115">  }</a>
<a name="ln3116">}</a>
<a name="ln3117"> </a>
<a name="ln3118">#if defined(HAVE_READLINK)</a>
<a name="ln3119">/*</a>
<a name="ln3120"> * Resolve a symlink in the last component of a file name.</a>
<a name="ln3121"> * Note that f_resolve() does it for every part of the path, we don't do that</a>
<a name="ln3122"> * here.</a>
<a name="ln3123"> * If it worked returns OK and the resolved link in &quot;buf[MAXPATHL]&quot;.</a>
<a name="ln3124"> * Otherwise returns FAIL.</a>
<a name="ln3125"> */</a>
<a name="ln3126">int resolve_symlink(const char_u *fname, char_u *buf)</a>
<a name="ln3127">{</a>
<a name="ln3128">  char_u tmp[MAXPATHL];</a>
<a name="ln3129">  int ret;</a>
<a name="ln3130">  int depth = 0;</a>
<a name="ln3131"> </a>
<a name="ln3132">  if (fname == NULL)</a>
<a name="ln3133">    return FAIL;</a>
<a name="ln3134"> </a>
<a name="ln3135">  /* Put the result so far in tmp[], starting with the original name. */</a>
<a name="ln3136">  STRLCPY(tmp, fname, MAXPATHL);</a>
<a name="ln3137"> </a>
<a name="ln3138">  for (;; ) {</a>
<a name="ln3139">    /* Limit symlink depth to 100, catch recursive loops. */</a>
<a name="ln3140">    if (++depth == 100) {</a>
<a name="ln3141">      EMSG2(_(&quot;E773: Symlink loop for \&quot;%s\&quot;&quot;), fname);</a>
<a name="ln3142">      return FAIL;</a>
<a name="ln3143">    }</a>
<a name="ln3144"> </a>
<a name="ln3145">    ret = readlink((char *)tmp, (char *)buf, MAXPATHL - 1);</a>
<a name="ln3146">    if (ret &lt;= 0) {</a>
<a name="ln3147">      if (errno == EINVAL || errno == ENOENT) {</a>
<a name="ln3148">        /* Found non-symlink or not existing file, stop here.</a>
<a name="ln3149">         * When at the first level use the unmodified name, skip the</a>
<a name="ln3150">         * call to vim_FullName(). */</a>
<a name="ln3151">        if (depth == 1)</a>
<a name="ln3152">          return FAIL;</a>
<a name="ln3153"> </a>
<a name="ln3154">        /* Use the resolved name in tmp[]. */</a>
<a name="ln3155">        break;</a>
<a name="ln3156">      }</a>
<a name="ln3157"> </a>
<a name="ln3158">      /* There must be some error reading links, use original name. */</a>
<a name="ln3159">      return FAIL;</a>
<a name="ln3160">    }</a>
<a name="ln3161">    buf[ret] = NUL;</a>
<a name="ln3162"> </a>
<a name="ln3163">    // Check whether the symlink is relative or absolute.</a>
<a name="ln3164">    // If it's relative, build a new path based on the directory</a>
<a name="ln3165">    // portion of the filename (if any) and the path the symlink</a>
<a name="ln3166">    // points to.</a>
<a name="ln3167">    if (path_is_absolute(buf)) {</a>
<a name="ln3168">      STRCPY(tmp, buf);</a>
<a name="ln3169">    } else {</a>
<a name="ln3170">      char_u *tail = path_tail(tmp);</a>
<a name="ln3171">      if (STRLEN(tail) + STRLEN(buf) &gt;= MAXPATHL) {</a>
<a name="ln3172">        return FAIL;</a>
<a name="ln3173">      }</a>
<a name="ln3174">      STRCPY(tail, buf);</a>
<a name="ln3175">    }</a>
<a name="ln3176">  }</a>
<a name="ln3177"> </a>
<a name="ln3178">  /*</a>
<a name="ln3179">   * Try to resolve the full name of the file so that the swapfile name will</a>
<a name="ln3180">   * be consistent even when opening a relative symlink from different</a>
<a name="ln3181">   * working directories.</a>
<a name="ln3182">   */</a>
<a name="ln3183">  return vim_FullName((char *)tmp, (char *)buf, MAXPATHL, TRUE);</a>
<a name="ln3184">}</a>
<a name="ln3185">#endif</a>
<a name="ln3186"> </a>
<a name="ln3187">/*</a>
<a name="ln3188"> * Make swap file name out of the file name and a directory name.</a>
<a name="ln3189"> * Returns pointer to allocated memory or NULL.</a>
<a name="ln3190"> */</a>
<a name="ln3191">char_u *makeswapname(char_u *fname, char_u *ffname, buf_T *buf, char_u *dir_name)</a>
<a name="ln3192">{</a>
<a name="ln3193">  char_u      *r, *s;</a>
<a name="ln3194">  char_u      *fname_res = fname;</a>
<a name="ln3195">#ifdef HAVE_READLINK</a>
<a name="ln3196">  char_u fname_buf[MAXPATHL];</a>
<a name="ln3197"> </a>
<a name="ln3198">  // Expand symlink in the file name, so that we put the swap file with the</a>
<a name="ln3199">  // actual file instead of with the symlink.</a>
<a name="ln3200">  if (resolve_symlink(fname, fname_buf) == OK) {</a>
<a name="ln3201">    fname_res = fname_buf;</a>
<a name="ln3202">  }</a>
<a name="ln3203">#endif</a>
<a name="ln3204">  int len = (int)STRLEN(dir_name);</a>
<a name="ln3205"> </a>
<a name="ln3206">  s = dir_name + len;</a>
<a name="ln3207">  if (after_pathsep((char *)dir_name, (char *)s)</a>
<a name="ln3208">      &amp;&amp; len &gt; 1</a>
<a name="ln3209">      &amp;&amp; s[-1] == s[-2]) {  // Ends with '//', Use Full path</a>
<a name="ln3210">    r = NULL;</a>
<a name="ln3211">    s = (char_u *)make_percent_swname((char *)dir_name, (char *)fname_res);</a>
<a name="ln3212">    if (s != NULL) {</a>
<a name="ln3213">      r = (char_u *)modname((char *)s, &quot;.swp&quot;, false);</a>
<a name="ln3214">      xfree(s);</a>
<a name="ln3215">    }</a>
<a name="ln3216">    return r;</a>
<a name="ln3217">  }</a>
<a name="ln3218"> </a>
<a name="ln3219">  // Prepend a '.' to the swap file name for the current directory.</a>
<a name="ln3220">  r = (char_u *)modname((char *)fname_res, &quot;.swp&quot;,</a>
<a name="ln3221">              dir_name[0] == '.' &amp;&amp; dir_name[1] == NUL);</a>
<a name="ln3222">  if (r == NULL)            /* out of memory */</a>
<a name="ln3223">    return NULL;</a>
<a name="ln3224"> </a>
<a name="ln3225">  s = get_file_in_dir(r, dir_name);</a>
<a name="ln3226">  xfree(r);</a>
<a name="ln3227">  return s;</a>
<a name="ln3228">}</a>
<a name="ln3229"> </a>
<a name="ln3230">/*</a>
<a name="ln3231"> * Get file name to use for swap file or backup file.</a>
<a name="ln3232"> * Use the name of the edited file &quot;fname&quot; and an entry in the 'dir' or 'bdir'</a>
<a name="ln3233"> * option &quot;dname&quot;.</a>
<a name="ln3234"> * - If &quot;dname&quot; is &quot;.&quot;, return &quot;fname&quot; (swap file in dir of file).</a>
<a name="ln3235"> * - If &quot;dname&quot; starts with &quot;./&quot;, insert &quot;dname&quot; in &quot;fname&quot; (swap file</a>
<a name="ln3236"> *   relative to dir of file).</a>
<a name="ln3237"> * - Otherwise, prepend &quot;dname&quot; to the tail of &quot;fname&quot; (swap file in specific</a>
<a name="ln3238"> *   dir).</a>
<a name="ln3239"> *</a>
<a name="ln3240"> * The return value is an allocated string and can be NULL.</a>
<a name="ln3241"> */</a>
<a name="ln3242">char_u *</a>
<a name="ln3243">get_file_in_dir (</a>
<a name="ln3244">    char_u *fname,</a>
<a name="ln3245">    char_u *dname         /* don't use &quot;dirname&quot;, it is a global for Alpha */</a>
<a name="ln3246">)</a>
<a name="ln3247">{</a>
<a name="ln3248">  char_u      *t;</a>
<a name="ln3249">  char_u      *tail;</a>
<a name="ln3250">  char_u      *retval;</a>
<a name="ln3251">  int save_char;</a>
<a name="ln3252"> </a>
<a name="ln3253">  tail = path_tail(fname);</a>
<a name="ln3254"> </a>
<a name="ln3255">  if (dname[0] == '.' &amp;&amp; dname[1] == NUL)</a>
<a name="ln3256">    retval = vim_strsave(fname);</a>
<a name="ln3257">  else if (dname[0] == '.' &amp;&amp; vim_ispathsep(dname[1])) {</a>
<a name="ln3258">    if (tail == fname)              /* no path before file name */</a>
<a name="ln3259">      retval = (char_u *)concat_fnames((char *)dname + 2, (char *)tail, TRUE);</a>
<a name="ln3260">    else {</a>
<a name="ln3261">      save_char = *tail;</a>
<a name="ln3262">      *tail = NUL;</a>
<a name="ln3263">      t = (char_u *)concat_fnames((char *)fname, (char *)dname + 2, TRUE);</a>
<a name="ln3264">      *tail = save_char;</a>
<a name="ln3265">      retval = (char_u *)concat_fnames((char *)t, (char *)tail, TRUE);</a>
<a name="ln3266">      xfree(t);</a>
<a name="ln3267">    }</a>
<a name="ln3268">  } else {</a>
<a name="ln3269">    retval = (char_u *)concat_fnames((char *)dname, (char *)tail, TRUE);</a>
<a name="ln3270">  }</a>
<a name="ln3271"> </a>
<a name="ln3272">  return retval;</a>
<a name="ln3273">}</a>
<a name="ln3274"> </a>
<a name="ln3275"> </a>
<a name="ln3276">/*</a>
<a name="ln3277"> * Print the ATTENTION message: info about an existing swap file.</a>
<a name="ln3278"> */</a>
<a name="ln3279">static void </a>
<a name="ln3280">attention_message (</a>
<a name="ln3281">    buf_T *buf,           /* buffer being edited */</a>
<a name="ln3282">    char_u *fname         /* swap file name */</a>
<a name="ln3283">)</a>
<a name="ln3284">{</a>
<a name="ln3285">  assert(buf-&gt;b_fname != NULL);</a>
<a name="ln3286"> </a>
<a name="ln3287">  ++no_wait_return;</a>
<a name="ln3288">  (void)EMSG(_(&quot;E325: ATTENTION&quot;));</a>
<a name="ln3289">  MSG_PUTS(_(&quot;\nFound a swap file by the name \&quot;&quot;));</a>
<a name="ln3290">  msg_home_replace(fname);</a>
<a name="ln3291">  MSG_PUTS(&quot;\&quot;\n&quot;);</a>
<a name="ln3292">  const time_t swap_mtime = swapfile_info(fname);</a>
<a name="ln3293">  MSG_PUTS(_(&quot;While opening file \&quot;&quot;));</a>
<a name="ln3294">  msg_outtrans(buf-&gt;b_fname);</a>
<a name="ln3295">  MSG_PUTS(&quot;\&quot;\n&quot;);</a>
<a name="ln3296">  FileInfo file_info;</a>
<a name="ln3297">  if (!os_fileinfo((char *)buf-&gt;b_fname, &amp;file_info)) {</a>
<a name="ln3298">    MSG_PUTS(_(&quot;      CANNOT BE FOUND&quot;));</a>
<a name="ln3299">  } else {</a>
<a name="ln3300">    MSG_PUTS(_(&quot;             dated: &quot;));</a>
<a name="ln3301">    time_t x = file_info.stat.st_mtim.tv_sec;</a>
<a name="ln3302">    char ctime_buf[50];</a>
<a name="ln3303">    MSG_PUTS(os_ctime_r(&amp;x, ctime_buf, sizeof(ctime_buf)));</a>
<a name="ln3304">    if (swap_mtime != 0 &amp;&amp; x &gt; swap_mtime) {</a>
<a name="ln3305">      MSG_PUTS(_(&quot;      NEWER than swap file!\n&quot;));</a>
<a name="ln3306">    }</a>
<a name="ln3307">  }</a>
<a name="ln3308">  /* Some of these messages are long to allow translation to</a>
<a name="ln3309">   * other languages. */</a>
<a name="ln3310">  MSG_PUTS(_(&quot;\n(1) Another program may be editing the same file.  If this is&quot;</a>
<a name="ln3311">             &quot; the case,\n    be careful not to end up with two different&quot;</a>
<a name="ln3312">             &quot; instances of the same\n    file when making changes.&quot;</a>
<a name="ln3313">             &quot;  Quit, or continue with caution.\n&quot;));</a>
<a name="ln3314">  MSG_PUTS(_(&quot;(2) An edit session for this file crashed.\n&quot;));</a>
<a name="ln3315">  MSG_PUTS(_(&quot;    If this is the case, use \&quot;:recover\&quot; or \&quot;vim -r &quot;));</a>
<a name="ln3316">  msg_outtrans(buf-&gt;b_fname);</a>
<a name="ln3317">  MSG_PUTS(_(&quot;\&quot;\n    to recover the changes (see \&quot;:help recovery\&quot;).\n&quot;));</a>
<a name="ln3318">  MSG_PUTS(_(&quot;    If you did this already, delete the swap file \&quot;&quot;));</a>
<a name="ln3319">  msg_outtrans(fname);</a>
<a name="ln3320">  MSG_PUTS(_(&quot;\&quot;\n    to avoid this message.\n&quot;));</a>
<a name="ln3321">  cmdline_row = msg_row;</a>
<a name="ln3322">  --no_wait_return;</a>
<a name="ln3323">}</a>
<a name="ln3324"> </a>
<a name="ln3325"> </a>
<a name="ln3326">/*</a>
<a name="ln3327"> * Trigger the SwapExists autocommands.</a>
<a name="ln3328"> * Returns a value for equivalent to do_dialog() (see below):</a>
<a name="ln3329"> * 0: still need to ask for a choice</a>
<a name="ln3330"> * 1: open read-only</a>
<a name="ln3331"> * 2: edit anyway</a>
<a name="ln3332"> * 3: recover</a>
<a name="ln3333"> * 4: delete it</a>
<a name="ln3334"> * 5: quit</a>
<a name="ln3335"> * 6: abort</a>
<a name="ln3336"> */</a>
<a name="ln3337">static int do_swapexists(buf_T *buf, char_u *fname)</a>
<a name="ln3338">{</a>
<a name="ln3339">  set_vim_var_string(VV_SWAPNAME, (char *) fname, -1);</a>
<a name="ln3340">  set_vim_var_string(VV_SWAPCHOICE, NULL, -1);</a>
<a name="ln3341"> </a>
<a name="ln3342">  /* Trigger SwapExists autocommands with &lt;afile&gt; set to the file being</a>
<a name="ln3343">   * edited.  Disallow changing directory here. */</a>
<a name="ln3344">  ++allbuf_lock;</a>
<a name="ln3345">  apply_autocmds(EVENT_SWAPEXISTS, buf-&gt;b_fname, NULL, FALSE, NULL);</a>
<a name="ln3346">  --allbuf_lock;</a>
<a name="ln3347"> </a>
<a name="ln3348">  set_vim_var_string(VV_SWAPNAME, NULL, -1);</a>
<a name="ln3349"> </a>
<a name="ln3350">  switch (*get_vim_var_str(VV_SWAPCHOICE)) {</a>
<a name="ln3351">  case 'o': return 1;</a>
<a name="ln3352">  case 'e': return 2;</a>
<a name="ln3353">  case 'r': return 3;</a>
<a name="ln3354">  case 'd': return 4;</a>
<a name="ln3355">  case 'q': return 5;</a>
<a name="ln3356">  case 'a': return 6;</a>
<a name="ln3357">  }</a>
<a name="ln3358"> </a>
<a name="ln3359">  return 0;</a>
<a name="ln3360">}</a>
<a name="ln3361"> </a>
<a name="ln3362">/// Find out what name to use for the swap file for buffer 'buf'.</a>
<a name="ln3363">///</a>
<a name="ln3364">/// Several names are tried to find one that does not exist. Last directory in</a>
<a name="ln3365">/// option is automatically created.</a>
<a name="ln3366">///</a>
<a name="ln3367">/// @note If BASENAMELEN is not correct, you will get error messages for</a>
<a name="ln3368">///   not being able to open the swap or undo file.</a>
<a name="ln3369">/// @note May trigger SwapExists autocmd, pointers may change!</a>
<a name="ln3370">///</a>
<a name="ln3371">/// @param[in]  buf  Buffer for which swap file names needs to be found.</a>
<a name="ln3372">/// @param[in,out]  dirp  Pointer to a list of directories. When out of memory,</a>
<a name="ln3373">///                       is set to NULL. Is advanced to the next directory in</a>
<a name="ln3374">///                       the list otherwise.</a>
<a name="ln3375">/// @param[in]  old_fname  Allowed existing swap file name. Except for this</a>
<a name="ln3376">///                        case, name of the non-existing file is used.</a>
<a name="ln3377">/// @param[in,out]  found_existing_dir  If points to true, then new directory</a>
<a name="ln3378">///                                     for swap file is not created. At first</a>
<a name="ln3379">///                                     findswapname() call this argument must</a>
<a name="ln3380">///                                     point to false. This parameter may only</a>
<a name="ln3381">///                                     be set to true by this function, it is</a>
<a name="ln3382">///                                     never set to false.</a>
<a name="ln3383">///</a>
<a name="ln3384">/// @return [allocated] Name of the swap file.</a>
<a name="ln3385">static char *findswapname(buf_T *buf, char **dirp, char *old_fname,</a>
<a name="ln3386">                          bool *found_existing_dir)</a>
<a name="ln3387">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ARG(1, 2, 4)</a>
<a name="ln3388">{</a>
<a name="ln3389">  char *fname;</a>
<a name="ln3390">  size_t n;</a>
<a name="ln3391">  char *dir_name;</a>
<a name="ln3392">  char *buf_fname = (char *) buf-&gt;b_fname;</a>
<a name="ln3393"> </a>
<a name="ln3394">  /*</a>
<a name="ln3395">   * Isolate a directory name from *dirp and put it in dir_name.</a>
<a name="ln3396">   * First allocate some memory to put the directory name in.</a>
<a name="ln3397">   */</a>
<a name="ln3398">  const size_t dir_len = strlen(*dirp) + 1;</a>
<a name="ln3399">  dir_name = xmalloc(dir_len);</a>
<a name="ln3400">  (void)copy_option_part((char_u **) dirp, (char_u *) dir_name, dir_len, &quot;,&quot;);</a>
<a name="ln3401"> </a>
<a name="ln3402">  /*</a>
<a name="ln3403">   * we try different names until we find one that does not exist yet</a>
<a name="ln3404">   */</a>
<a name="ln3405">  fname = (char *)makeswapname((char_u *)buf_fname, buf-&gt;b_ffname, buf,</a>
<a name="ln3406">                               (char_u *)dir_name);</a>
<a name="ln3407"> </a>
<a name="ln3408">  for (;; ) {</a>
<a name="ln3409">    if (fname == NULL) {        // must be out of memory</a>
<a name="ln3410">      break;</a>
<a name="ln3411">    }</a>
<a name="ln3412">    if ((n = strlen(fname)) == 0) {        // safety check</a>
<a name="ln3413">      XFREE_CLEAR(fname);</a>
<a name="ln3414">      break;</a>
<a name="ln3415">    }</a>
<a name="ln3416">    // check if the swapfile already exists</a>
<a name="ln3417">    // Extra security check: When a swap file is a symbolic link, this</a>
<a name="ln3418">    // is most likely a symlink attack.</a>
<a name="ln3419">    FileInfo file_info;</a>
<a name="ln3420">    bool file_or_link_found = os_fileinfo_link(fname, &amp;file_info);</a>
<a name="ln3421">    if (!file_or_link_found) {</a>
<a name="ln3422">      break;</a>
<a name="ln3423">    }</a>
<a name="ln3424"> </a>
<a name="ln3425">    // A file name equal to old_fname is OK to use.</a>
<a name="ln3426">    if (old_fname != NULL &amp;&amp; fnamecmp(fname, old_fname) == 0) {</a>
<a name="ln3427">      break;</a>
<a name="ln3428">    }</a>
<a name="ln3429"> </a>
<a name="ln3430">    // get here when file already exists</a>
<a name="ln3431">    if (fname[n - 2] == 'w' &amp;&amp; fname[n - 1] == 'p') {   // first try</a>
<a name="ln3432">      // If we get here the &quot;.swp&quot; file really exists.</a>
<a name="ln3433">      // Give an error message, unless recovering, no file name, we are</a>
<a name="ln3434">      // viewing a help file or when the path of the file is different</a>
<a name="ln3435">      // (happens when all .swp files are in one directory).</a>
<a name="ln3436">      if (!recoverymode &amp;&amp; buf_fname != NULL</a>
<a name="ln3437">          &amp;&amp; !buf-&gt;b_help &amp;&amp; !(buf-&gt;b_flags &amp; BF_DUMMY)) {</a>
<a name="ln3438">        int fd;</a>
<a name="ln3439">        struct block0 b0;</a>
<a name="ln3440">        int differ = FALSE;</a>
<a name="ln3441"> </a>
<a name="ln3442">        // Try to read block 0 from the swap file to get the original</a>
<a name="ln3443">        // file name (and inode number).</a>
<a name="ln3444">        fd = os_open(fname, O_RDONLY, 0);</a>
<a name="ln3445">        if (fd &gt;= 0) {</a>
<a name="ln3446">          if (read_eintr(fd, &amp;b0, sizeof(b0)) == sizeof(b0)) {</a>
<a name="ln3447">            // If the swapfile has the same directory as the</a>
<a name="ln3448">            // buffer don't compare the directory names, they can</a>
<a name="ln3449">            // have a different mountpoint.</a>
<a name="ln3450">            if (b0.b0_flags &amp; B0_SAME_DIR) {</a>
<a name="ln3451">              if (fnamecmp(path_tail(buf-&gt;b_ffname),</a>
<a name="ln3452">                           path_tail(b0.b0_fname)) != 0</a>
<a name="ln3453">                  || !same_directory((char_u *)fname, buf-&gt;b_ffname)) {</a>
<a name="ln3454">                // Symlinks may point to the same file even</a>
<a name="ln3455">                // when the name differs, need to check the</a>
<a name="ln3456">                // inode too.</a>
<a name="ln3457">                expand_env(b0.b0_fname, NameBuff, MAXPATHL);</a>
<a name="ln3458">                if (fnamecmp_ino(buf-&gt;b_ffname, NameBuff,</a>
<a name="ln3459">                    char_to_long(b0.b0_ino))) {</a>
<a name="ln3460">                  differ = TRUE;</a>
<a name="ln3461">                }</a>
<a name="ln3462">              }</a>
<a name="ln3463">            } else {</a>
<a name="ln3464">              // The name in the swap file may be</a>
<a name="ln3465">              // &quot;~user/path/file&quot;.  Expand it first.</a>
<a name="ln3466">              expand_env(b0.b0_fname, NameBuff, MAXPATHL);</a>
<a name="ln3467">              if (fnamecmp_ino(buf-&gt;b_ffname, NameBuff,</a>
<a name="ln3468">                  char_to_long(b0.b0_ino))) {</a>
<a name="ln3469">                differ = TRUE;</a>
<a name="ln3470">              }</a>
<a name="ln3471">            }</a>
<a name="ln3472">          }</a>
<a name="ln3473">          close(fd);</a>
<a name="ln3474">        }</a>
<a name="ln3475"> </a>
<a name="ln3476">        // give the ATTENTION message when there is an old swap file</a>
<a name="ln3477">        // for the current file, and the buffer was not recovered. */</a>
<a name="ln3478">        if (differ == false &amp;&amp; !(curbuf-&gt;b_flags &amp; BF_RECOVERED)</a>
<a name="ln3479">            &amp;&amp; vim_strchr(p_shm, SHM_ATTENTION) == NULL) {</a>
<a name="ln3480">          int choice = 0;</a>
<a name="ln3481"> </a>
<a name="ln3482">          process_still_running = false;</a>
<a name="ln3483">          // It's safe to delete the swap file if all these are true:</a>
<a name="ln3484">          // - the edited file exists</a>
<a name="ln3485">          // - the swap file has no changes and looks OK</a>
<a name="ln3486">          if (os_path_exists(buf-&gt;b_fname) &amp;&amp; swapfile_unchanged(fname)) {</a>
<a name="ln3487">            choice = 4;</a>
<a name="ln3488">            if (p_verbose &gt; 0) {</a>
<a name="ln3489">              verb_msg(_(&quot;Found a swap file that is not useful, deleting it&quot;));</a>
<a name="ln3490">            }</a>
<a name="ln3491">          }</a>
<a name="ln3492"> </a>
<a name="ln3493">          // If there is a SwapExists autocommand and we can handle the</a>
<a name="ln3494">          // response, trigger it.  It may return 0 to ask the user anyway.</a>
<a name="ln3495">          if (choice == 0</a>
<a name="ln3496">              &amp;&amp; swap_exists_action != SEA_NONE</a>
<a name="ln3497">              &amp;&amp; has_autocmd(EVENT_SWAPEXISTS, (char_u *)buf_fname, buf)) {</a>
<a name="ln3498">            choice = do_swapexists(buf, (char_u *)fname);</a>
<a name="ln3499">          }</a>
<a name="ln3500"> </a>
<a name="ln3501">          if (choice == 0) {</a>
<a name="ln3502">            // Show info about the existing swap file.</a>
<a name="ln3503">            attention_message(buf, (char_u *)fname);</a>
<a name="ln3504"> </a>
<a name="ln3505">            // We don't want a 'q' typed at the more-prompt</a>
<a name="ln3506">            // interrupt loading a file.</a>
<a name="ln3507">            got_int = false;</a>
<a name="ln3508"> </a>
<a name="ln3509">            // If vimrc has &quot;simalt ~x&quot; we don't want it to</a>
<a name="ln3510">            // interfere with the prompt here.</a>
<a name="ln3511">            flush_buffers(FLUSH_TYPEAHEAD);</a>
<a name="ln3512">          }</a>
<a name="ln3513"> </a>
<a name="ln3514">          if (swap_exists_action != SEA_NONE &amp;&amp; choice == 0) {</a>
<a name="ln3515">            const char *const sw_msg_1 = _(&quot;Swap file \&quot;&quot;);</a>
<a name="ln3516">            const char *const sw_msg_2 = _(&quot;\&quot; already exists!&quot;);</a>
<a name="ln3517"> </a>
<a name="ln3518">            const size_t fname_len = strlen(fname);</a>
<a name="ln3519">            const size_t sw_msg_1_len = strlen(sw_msg_1);</a>
<a name="ln3520">            const size_t sw_msg_2_len = strlen(sw_msg_2);</a>
<a name="ln3521"> </a>
<a name="ln3522">            const size_t name_len = sw_msg_1_len + fname_len + sw_msg_2_len + 5;</a>
<a name="ln3523"> </a>
<a name="ln3524">            char *const name = xmalloc(name_len);</a>
<a name="ln3525">            memcpy(name, sw_msg_1, sw_msg_1_len + 1);</a>
<a name="ln3526">            home_replace(NULL, (char_u *)fname, (char_u *)&amp;name[sw_msg_1_len],</a>
<a name="ln3527">                         fname_len, true);</a>
<a name="ln3528">            xstrlcat(name, sw_msg_2, name_len);</a>
<a name="ln3529">            choice = do_dialog(VIM_WARNING, (char_u *)_(&quot;VIM - ATTENTION&quot;),</a>
<a name="ln3530">                               (char_u *)name,</a>
<a name="ln3531">                               process_still_running</a>
<a name="ln3532">                               ? (char_u *)_(</a>
<a name="ln3533">                                   &quot;&amp;Open Read-Only\n&amp;Edit anyway\n&amp;Recover&quot;</a>
<a name="ln3534">                                   &quot;\n&amp;Quit\n&amp;Abort&quot;) :</a>
<a name="ln3535">                               (char_u *)_(</a>
<a name="ln3536">                                   &quot;&amp;Open Read-Only\n&amp;Edit anyway\n&amp;Recover&quot;</a>
<a name="ln3537">                                   &quot;\n&amp;Delete it\n&amp;Quit\n&amp;Abort&quot;),</a>
<a name="ln3538">                               1, NULL, false);</a>
<a name="ln3539"> </a>
<a name="ln3540">            if (process_still_running &amp;&amp; choice &gt;= 4) {</a>
<a name="ln3541">              choice++;                 // Skip missing &quot;Delete it&quot; button.</a>
<a name="ln3542">            }</a>
<a name="ln3543">            xfree(name);</a>
<a name="ln3544"> </a>
<a name="ln3545">            // pretend screen didn't scroll, need redraw anyway</a>
<a name="ln3546">            msg_reset_scroll();</a>
<a name="ln3547">          }</a>
<a name="ln3548"> </a>
<a name="ln3549">          if (choice &gt; 0) {</a>
<a name="ln3550">            switch (choice) {</a>
<a name="ln3551">            case 1:</a>
<a name="ln3552">              buf-&gt;b_p_ro = TRUE;</a>
<a name="ln3553">              break;</a>
<a name="ln3554">            case 2:</a>
<a name="ln3555">              break;</a>
<a name="ln3556">            case 3:</a>
<a name="ln3557">              swap_exists_action = SEA_RECOVER;</a>
<a name="ln3558">              break;</a>
<a name="ln3559">            case 4:</a>
<a name="ln3560">              os_remove(fname);</a>
<a name="ln3561">              break;</a>
<a name="ln3562">            case 5:</a>
<a name="ln3563">              swap_exists_action = SEA_QUIT;</a>
<a name="ln3564">              break;</a>
<a name="ln3565">            case 6:</a>
<a name="ln3566">              swap_exists_action = SEA_QUIT;</a>
<a name="ln3567">              got_int = TRUE;</a>
<a name="ln3568">              break;</a>
<a name="ln3569">            }</a>
<a name="ln3570"> </a>
<a name="ln3571">            // If the file was deleted this fname can be used.</a>
<a name="ln3572">            if (!os_path_exists((char_u *)fname)) {</a>
<a name="ln3573">              break;</a>
<a name="ln3574">            }</a>
<a name="ln3575">          } else {</a>
<a name="ln3576">            MSG_PUTS(&quot;\n&quot;);</a>
<a name="ln3577">            if (msg_silent == 0)</a>
<a name="ln3578">              /* call wait_return() later */</a>
<a name="ln3579">              need_wait_return = TRUE;</a>
<a name="ln3580">          }</a>
<a name="ln3581"> </a>
<a name="ln3582">        }</a>
<a name="ln3583">      }</a>
<a name="ln3584">    }</a>
<a name="ln3585"> </a>
<a name="ln3586">    /*</a>
<a name="ln3587">     * Change the &quot;.swp&quot; extension to find another file that can be used.</a>
<a name="ln3588">     * First decrement the last char: &quot;.swo&quot;, &quot;.swn&quot;, etc.</a>
<a name="ln3589">     * If that still isn't enough decrement the last but one char: &quot;.svz&quot;</a>
<a name="ln3590">     * Can happen when editing many &quot;No Name&quot; buffers.</a>
<a name="ln3591">     */</a>
<a name="ln3592">    if (fname[n - 1] == 'a') {          /* &quot;.s?a&quot; */</a>
<a name="ln3593">      if (fname[n - 2] == 'a') {        /* &quot;.saa&quot;: tried enough, give up */</a>
<a name="ln3594">        EMSG(_(&quot;E326: Too many swap files found&quot;));</a>
<a name="ln3595">        XFREE_CLEAR(fname);</a>
<a name="ln3596">        break;</a>
<a name="ln3597">      }</a>
<a name="ln3598">      --fname[n - 2];                   /* &quot;.svz&quot;, &quot;.suz&quot;, etc. */</a>
<a name="ln3599">      fname[n - 1] = 'z' + 1;</a>
<a name="ln3600">    }</a>
<a name="ln3601">    --fname[n - 1];                     /* &quot;.swo&quot;, &quot;.swn&quot;, etc. */</a>
<a name="ln3602">  }</a>
<a name="ln3603"> </a>
<a name="ln3604">  if (os_isdir((char_u *) dir_name)) {</a>
<a name="ln3605">    *found_existing_dir = true;</a>
<a name="ln3606">  } else if (!*found_existing_dir &amp;&amp; **dirp == NUL) {</a>
<a name="ln3607">    int ret;</a>
<a name="ln3608">    char *failed_dir;</a>
<a name="ln3609">    if ((ret = os_mkdir_recurse(dir_name, 0755, &amp;failed_dir)) != 0) {</a>
<a name="ln3610">      EMSG3(_(&quot;E303: Unable to create directory \&quot;%s\&quot; for swap file, &quot;</a>
<a name="ln3611">              &quot;recovery impossible: %s&quot;),</a>
<a name="ln3612">            failed_dir, os_strerror(ret));</a>
<a name="ln3613">      xfree(failed_dir);</a>
<a name="ln3614">    }</a>
<a name="ln3615">  }</a>
<a name="ln3616"> </a>
<a name="ln3617">  xfree(dir_name);</a>
<a name="ln3618">  return fname;</a>
<a name="ln3619">}</a>
<a name="ln3620"> </a>
<a name="ln3621">static int b0_magic_wrong(ZERO_BL *b0p)</a>
<a name="ln3622">{</a>
<a name="ln3623">  return b0p-&gt;b0_magic_long != (long)B0_MAGIC_LONG</a>
<a name="ln3624">         || b0p-&gt;b0_magic_int != (int)B0_MAGIC_INT</a>
<a name="ln3625">         || b0p-&gt;b0_magic_short != (short)B0_MAGIC_SHORT</a>
<a name="ln3626">         || b0p-&gt;b0_magic_char != B0_MAGIC_CHAR;</a>
<a name="ln3627">}</a>
<a name="ln3628"> </a>
<a name="ln3629">/*</a>
<a name="ln3630"> * Compare current file name with file name from swap file.</a>
<a name="ln3631"> * Try to use inode numbers when possible.</a>
<a name="ln3632"> * Return non-zero when files are different.</a>
<a name="ln3633"> *</a>
<a name="ln3634"> * When comparing file names a few things have to be taken into consideration:</a>
<a name="ln3635"> * - When working over a network the full path of a file depends on the host.</a>
<a name="ln3636"> *   We check the inode number if possible.  It is not 100% reliable though,</a>
<a name="ln3637"> *   because the device number cannot be used over a network.</a>
<a name="ln3638"> * - When a file does not exist yet (editing a new file) there is no inode</a>
<a name="ln3639"> *   number.</a>
<a name="ln3640"> * - The file name in a swap file may not be valid on the current host.  The</a>
<a name="ln3641"> *   &quot;~user&quot; form is used whenever possible to avoid this.</a>
<a name="ln3642"> *</a>
<a name="ln3643"> * This is getting complicated, let's make a table:</a>
<a name="ln3644"> *</a>
<a name="ln3645"> *		ino_c  ino_s  fname_c  fname_s	differ =</a>
<a name="ln3646"> *</a>
<a name="ln3647"> * both files exist -&gt; compare inode numbers:</a>
<a name="ln3648"> *		!= 0   != 0	X	 X	ino_c != ino_s</a>
<a name="ln3649"> *</a>
<a name="ln3650"> * inode number(s) unknown, file names available -&gt; compare file names</a>
<a name="ln3651"> *		== 0	X	OK	 OK	fname_c != fname_s</a>
<a name="ln3652"> *		 X     == 0	OK	 OK	fname_c != fname_s</a>
<a name="ln3653"> *</a>
<a name="ln3654"> * current file doesn't exist, file for swap file exist, file name(s) not</a>
<a name="ln3655"> * available -&gt; probably different</a>
<a name="ln3656"> *		== 0   != 0    FAIL	 X	TRUE</a>
<a name="ln3657"> *		== 0   != 0	X	FAIL	TRUE</a>
<a name="ln3658"> *</a>
<a name="ln3659"> * current file exists, inode for swap unknown, file name(s) not</a>
<a name="ln3660"> * available -&gt; probably different</a>
<a name="ln3661"> *		!= 0   == 0    FAIL	 X	TRUE</a>
<a name="ln3662"> *		!= 0   == 0	X	FAIL	TRUE</a>
<a name="ln3663"> *</a>
<a name="ln3664"> * current file doesn't exist, inode for swap unknown, one file name not</a>
<a name="ln3665"> * available -&gt; probably different</a>
<a name="ln3666"> *		== 0   == 0    FAIL	 OK	TRUE</a>
<a name="ln3667"> *		== 0   == 0	OK	FAIL	TRUE</a>
<a name="ln3668"> *</a>
<a name="ln3669"> * current file doesn't exist, inode for swap unknown, both file names not</a>
<a name="ln3670"> * available -&gt; compare file names</a>
<a name="ln3671"> *		== 0   == 0    FAIL	FAIL	fname_c != fname_s</a>
<a name="ln3672"> *</a>
<a name="ln3673"> * Only the last 32 bits of the inode will be used. This can't be changed</a>
<a name="ln3674"> * without making the block 0 incompatible with 32 bit versions.</a>
<a name="ln3675"> */</a>
<a name="ln3676"> </a>
<a name="ln3677">static bool fnamecmp_ino(</a>
<a name="ln3678">    char_u *fname_c,              // current file name</a>
<a name="ln3679">    char_u *fname_s,              // file name from swap file</a>
<a name="ln3680">    long ino_block0</a>
<a name="ln3681">)</a>
<a name="ln3682">{</a>
<a name="ln3683">  uint64_t ino_c = 0;               /* ino of current file */</a>
<a name="ln3684">  uint64_t ino_s;                   /* ino of file from swap file */</a>
<a name="ln3685">  char_u buf_c[MAXPATHL];           /* full path of fname_c */</a>
<a name="ln3686">  char_u buf_s[MAXPATHL];           /* full path of fname_s */</a>
<a name="ln3687">  int retval_c;                     /* flag: buf_c valid */</a>
<a name="ln3688">  int retval_s;                     /* flag: buf_s valid */</a>
<a name="ln3689"> </a>
<a name="ln3690">  FileInfo file_info;</a>
<a name="ln3691">  if (os_fileinfo((char *)fname_c, &amp;file_info)) {</a>
<a name="ln3692">    ino_c = os_fileinfo_inode(&amp;file_info);</a>
<a name="ln3693">  }</a>
<a name="ln3694"> </a>
<a name="ln3695">  /*</a>
<a name="ln3696">   * First we try to get the inode from the file name, because the inode in</a>
<a name="ln3697">   * the swap file may be outdated.  If that fails (e.g. this path is not</a>
<a name="ln3698">   * valid on this machine), use the inode from block 0.</a>
<a name="ln3699">   */</a>
<a name="ln3700">  if (os_fileinfo((char *)fname_s, &amp;file_info)) {</a>
<a name="ln3701">    ino_s = os_fileinfo_inode(&amp;file_info);</a>
<a name="ln3702">  } else {</a>
<a name="ln3703">    ino_s = (uint64_t)ino_block0;</a>
<a name="ln3704">  }</a>
<a name="ln3705"> </a>
<a name="ln3706">  if (ino_c &amp;&amp; ino_s)</a>
<a name="ln3707">    return ino_c != ino_s;</a>
<a name="ln3708"> </a>
<a name="ln3709">  /*</a>
<a name="ln3710">   * One of the inode numbers is unknown, try a forced vim_FullName() and</a>
<a name="ln3711">   * compare the file names.</a>
<a name="ln3712">   */</a>
<a name="ln3713">  retval_c = vim_FullName((char *)fname_c, (char *)buf_c, MAXPATHL, TRUE);</a>
<a name="ln3714">  retval_s = vim_FullName((char *)fname_s, (char *)buf_s, MAXPATHL, TRUE);</a>
<a name="ln3715">  if (retval_c == OK &amp;&amp; retval_s == OK)</a>
<a name="ln3716">    return STRCMP(buf_c, buf_s) != 0;</a>
<a name="ln3717"> </a>
<a name="ln3718">  /*</a>
<a name="ln3719">   * Can't compare inodes or file names, guess that the files are different,</a>
<a name="ln3720">   * unless both appear not to exist at all, then compare with the file name</a>
<a name="ln3721">   * in the swap file.</a>
<a name="ln3722">   */</a>
<a name="ln3723">  if (ino_s == 0 &amp;&amp; ino_c == 0 &amp;&amp; retval_c == FAIL &amp;&amp; retval_s == FAIL) {</a>
<a name="ln3724">    return STRCMP(fname_c, fname_s) != 0;</a>
<a name="ln3725">  }</a>
<a name="ln3726">  return true;</a>
<a name="ln3727">}</a>
<a name="ln3728"> </a>
<a name="ln3729">/*</a>
<a name="ln3730"> * Move a long integer into a four byte character array.</a>
<a name="ln3731"> * Used for machine independency in block zero.</a>
<a name="ln3732"> */</a>
<a name="ln3733">static void long_to_char(long n, char_u *s)</a>
<a name="ln3734">{</a>
<a name="ln3735">  s[0] = (char_u)(n &amp; 0xff);</a>
<a name="ln3736">  n = (unsigned)n &gt;&gt; 8;</a>
<a name="ln3737">  s[1] = (char_u)(n &amp; 0xff);</a>
<a name="ln3738">  n = (unsigned)n &gt;&gt; 8;</a>
<a name="ln3739">  s[2] = (char_u)(n &amp; 0xff);</a>
<a name="ln3740">  n = (unsigned)n &gt;&gt; 8;</a>
<a name="ln3741">  s[3] = (char_u)(n &amp; 0xff);</a>
<a name="ln3742">}</a>
<a name="ln3743"> </a>
<a name="ln3744">static long char_to_long(char_u *s)</a>
<a name="ln3745">{</a>
<a name="ln3746">  long retval;</a>
<a name="ln3747"> </a>
<a name="ln3748">  retval = s[3];</a>
<a name="ln3749">  retval &lt;&lt;= 8;</a>
<a name="ln3750">  retval |= s[2];</a>
<a name="ln3751">  retval &lt;&lt;= 8;</a>
<a name="ln3752">  retval |= s[1];</a>
<a name="ln3753">  retval &lt;&lt;= 8;</a>
<a name="ln3754">  retval |= s[0];</a>
<a name="ln3755"> </a>
<a name="ln3756">  return retval;</a>
<a name="ln3757">}</a>
<a name="ln3758"> </a>
<a name="ln3759">/*</a>
<a name="ln3760"> * Set the flags in the first block of the swap file:</a>
<a name="ln3761"> * - file is modified or not: buf-&gt;b_changed</a>
<a name="ln3762"> * - 'fileformat'</a>
<a name="ln3763"> * - 'fileencoding'</a>
<a name="ln3764"> */</a>
<a name="ln3765">void ml_setflags(buf_T *buf)</a>
<a name="ln3766">{</a>
<a name="ln3767">  bhdr_T      *hp;</a>
<a name="ln3768">  ZERO_BL     *b0p;</a>
<a name="ln3769"> </a>
<a name="ln3770">  if (!buf-&gt;b_ml.ml_mfp)</a>
<a name="ln3771">    return;</a>
<a name="ln3772">  for (hp = buf-&gt;b_ml.ml_mfp-&gt;mf_used_last; hp != NULL; hp = hp-&gt;bh_prev) {</a>
<a name="ln3773">    if (hp-&gt;bh_bnum == 0) {</a>
<a name="ln3774">      b0p = hp-&gt;bh_data;</a>
<a name="ln3775">      b0p-&gt;b0_dirty = buf-&gt;b_changed ? B0_DIRTY : 0;</a>
<a name="ln3776">      b0p-&gt;b0_flags = (b0p-&gt;b0_flags &amp; ~B0_FF_MASK)</a>
<a name="ln3777">                      | (get_fileformat(buf) + 1);</a>
<a name="ln3778">      add_b0_fenc(b0p, buf);</a>
<a name="ln3779">      hp-&gt;bh_flags |= BH_DIRTY;</a>
<a name="ln3780">      mf_sync(buf-&gt;b_ml.ml_mfp, MFS_ZERO);</a>
<a name="ln3781">      break;</a>
<a name="ln3782">    }</a>
<a name="ln3783">  }</a>
<a name="ln3784">}</a>
<a name="ln3785"> </a>
<a name="ln3786">#define MLCS_MAXL 800   /* max no of lines in chunk */</a>
<a name="ln3787">#define MLCS_MINL 400   /* should be half of MLCS_MAXL */</a>
<a name="ln3788"> </a>
<a name="ln3789">/*</a>
<a name="ln3790"> * Keep information for finding byte offset of a line, updtype may be one of:</a>
<a name="ln3791"> * ML_CHNK_ADDLINE: Add len to parent chunk, possibly splitting it</a>
<a name="ln3792"> *	   Careful: ML_CHNK_ADDLINE may cause ml_find_line() to be called.</a>
<a name="ln3793"> * ML_CHNK_DELLINE: Subtract len from parent chunk, possibly deleting it</a>
<a name="ln3794"> * ML_CHNK_UPDLINE: Add len to parent chunk, as a signed entity.</a>
<a name="ln3795"> */</a>
<a name="ln3796">static void ml_updatechunk(buf_T *buf, linenr_T line, long len, int updtype)</a>
<a name="ln3797">{</a>
<a name="ln3798">  static buf_T        *ml_upd_lastbuf = NULL;</a>
<a name="ln3799">  static linenr_T ml_upd_lastline;</a>
<a name="ln3800">  static linenr_T ml_upd_lastcurline;</a>
<a name="ln3801">  static int ml_upd_lastcurix;</a>
<a name="ln3802"> </a>
<a name="ln3803">  linenr_T curline = ml_upd_lastcurline;</a>
<a name="ln3804">  int curix = ml_upd_lastcurix;</a>
<a name="ln3805">  long size;</a>
<a name="ln3806">  chunksize_T         *curchnk;</a>
<a name="ln3807">  int rest;</a>
<a name="ln3808">  bhdr_T              *hp;</a>
<a name="ln3809">  DATA_BL             *dp;</a>
<a name="ln3810"> </a>
<a name="ln3811">  if (buf-&gt;b_ml.ml_usedchunks == -1 || len == 0)</a>
<a name="ln3812">    return;</a>
<a name="ln3813">  if (buf-&gt;b_ml.ml_chunksize == NULL) {</a>
<a name="ln3814">    buf-&gt;b_ml.ml_chunksize = xmalloc(sizeof(chunksize_T) * 100);</a>
<a name="ln3815">    buf-&gt;b_ml.ml_numchunks = 100;</a>
<a name="ln3816">    buf-&gt;b_ml.ml_usedchunks = 1;</a>
<a name="ln3817">    buf-&gt;b_ml.ml_chunksize[0].mlcs_numlines = 1;</a>
<a name="ln3818">    buf-&gt;b_ml.ml_chunksize[0].mlcs_totalsize = 1;</a>
<a name="ln3819">  }</a>
<a name="ln3820"> </a>
<a name="ln3821">  if (updtype == ML_CHNK_UPDLINE &amp;&amp; buf-&gt;b_ml.ml_line_count == 1) {</a>
<a name="ln3822">    /*</a>
<a name="ln3823">     * First line in empty buffer from ml_flush_line() -- reset</a>
<a name="ln3824">     */</a>
<a name="ln3825">    buf-&gt;b_ml.ml_usedchunks = 1;</a>
<a name="ln3826">    buf-&gt;b_ml.ml_chunksize[0].mlcs_numlines = 1;</a>
<a name="ln3827">    buf-&gt;b_ml.ml_chunksize[0].mlcs_totalsize =</a>
<a name="ln3828">      (long)STRLEN(buf-&gt;b_ml.ml_line_ptr) + 1;</a>
<a name="ln3829">    return;</a>
<a name="ln3830">  }</a>
<a name="ln3831"> </a>
<a name="ln3832">  /*</a>
<a name="ln3833">   * Find chunk that our line belongs to, curline will be at start of the</a>
<a name="ln3834">   * chunk.</a>
<a name="ln3835">   */</a>
<a name="ln3836">  if (buf != ml_upd_lastbuf || line != ml_upd_lastline + 1</a>
<a name="ln3837">      || updtype != ML_CHNK_ADDLINE) {</a>
<a name="ln3838">    for (curline = 1, curix = 0;</a>
<a name="ln3839">         curix &lt; buf-&gt;b_ml.ml_usedchunks - 1</a>
<a name="ln3840">                 &amp;&amp; line &gt;= curline +</a>
<a name="ln3841">                             buf-&gt;b_ml.ml_chunksize[curix].mlcs_numlines;</a>
<a name="ln3842">         curix++) {</a>
<a name="ln3843">      curline += buf-&gt;b_ml.ml_chunksize[curix].mlcs_numlines;</a>
<a name="ln3844">    }</a>
<a name="ln3845">  } else if (curix &lt; buf-&gt;b_ml.ml_usedchunks - 1</a>
<a name="ln3846">             &amp;&amp; line &gt;= curline + buf-&gt;b_ml.ml_chunksize[curix].mlcs_numlines) {</a>
<a name="ln3847">    // Adjust cached curix &amp; curline</a>
<a name="ln3848">    curline += buf-&gt;b_ml.ml_chunksize[curix].mlcs_numlines;</a>
<a name="ln3849">    curix++;</a>
<a name="ln3850">  }</a>
<a name="ln3851">  curchnk = buf-&gt;b_ml.ml_chunksize + curix;</a>
<a name="ln3852"> </a>
<a name="ln3853">  if (updtype == ML_CHNK_DELLINE)</a>
<a name="ln3854">    len = -len;</a>
<a name="ln3855">  curchnk-&gt;mlcs_totalsize += len;</a>
<a name="ln3856">  if (updtype == ML_CHNK_ADDLINE) {</a>
<a name="ln3857">    curchnk-&gt;mlcs_numlines++;</a>
<a name="ln3858"> </a>
<a name="ln3859">    /* May resize here so we don't have to do it in both cases below */</a>
<a name="ln3860">    if (buf-&gt;b_ml.ml_usedchunks + 1 &gt;= buf-&gt;b_ml.ml_numchunks) {</a>
<a name="ln3861">      buf-&gt;b_ml.ml_numchunks = buf-&gt;b_ml.ml_numchunks * 3 / 2;</a>
<a name="ln3862">      buf-&gt;b_ml.ml_chunksize = xrealloc(</a>
<a name="ln3863">          buf-&gt;b_ml.ml_chunksize,</a>
<a name="ln3864">          sizeof(chunksize_T) * buf-&gt;b_ml.ml_numchunks);</a>
<a name="ln3865">    }</a>
<a name="ln3866"> </a>
<a name="ln3867">    if (buf-&gt;b_ml.ml_chunksize[curix].mlcs_numlines &gt;= MLCS_MAXL) {</a>
<a name="ln3868">      int count;                    /* number of entries in block */</a>
<a name="ln3869">      int idx;</a>
<a name="ln3870">      int text_end;</a>
<a name="ln3871">      int linecnt;</a>
<a name="ln3872"> </a>
<a name="ln3873">      memmove(buf-&gt;b_ml.ml_chunksize + curix + 1,</a>
<a name="ln3874">          buf-&gt;b_ml.ml_chunksize + curix,</a>
<a name="ln3875">          (buf-&gt;b_ml.ml_usedchunks - curix) *</a>
<a name="ln3876">          sizeof(chunksize_T));</a>
<a name="ln3877">      /* Compute length of first half of lines in the split chunk */</a>
<a name="ln3878">      size = 0;</a>
<a name="ln3879">      linecnt = 0;</a>
<a name="ln3880">      while (curline &lt; buf-&gt;b_ml.ml_line_count</a>
<a name="ln3881">             &amp;&amp; linecnt &lt; MLCS_MINL) {</a>
<a name="ln3882">        if ((hp = ml_find_line(buf, curline, ML_FIND)) == NULL) {</a>
<a name="ln3883">          buf-&gt;b_ml.ml_usedchunks = -1;</a>
<a name="ln3884">          return;</a>
<a name="ln3885">        }</a>
<a name="ln3886">        dp = hp-&gt;bh_data;</a>
<a name="ln3887">        count = (long)(buf-&gt;b_ml.ml_locked_high) -</a>
<a name="ln3888">                (long)(buf-&gt;b_ml.ml_locked_low) + 1;</a>
<a name="ln3889">        idx = curline - buf-&gt;b_ml.ml_locked_low;</a>
<a name="ln3890">        curline = buf-&gt;b_ml.ml_locked_high + 1;</a>
<a name="ln3891">        if (idx == 0)        /* first line in block, text at the end */</a>
<a name="ln3892">          text_end = dp-&gt;db_txt_end;</a>
<a name="ln3893">        else</a>
<a name="ln3894">          text_end = ((dp-&gt;db_index[idx - 1]) &amp; DB_INDEX_MASK);</a>
<a name="ln3895">        /* Compute index of last line to use in this MEMLINE */</a>
<a name="ln3896">        rest = count - idx;</a>
<a name="ln3897">        if (linecnt + rest &gt; MLCS_MINL) {</a>
<a name="ln3898">          idx += MLCS_MINL - linecnt - 1;</a>
<a name="ln3899">          linecnt = MLCS_MINL;</a>
<a name="ln3900">        } else {</a>
<a name="ln3901">          idx = count - 1;</a>
<a name="ln3902">          linecnt += rest;</a>
<a name="ln3903">        }</a>
<a name="ln3904">        size += text_end - ((dp-&gt;db_index[idx]) &amp; DB_INDEX_MASK);</a>
<a name="ln3905">      }</a>
<a name="ln3906">      buf-&gt;b_ml.ml_chunksize[curix].mlcs_numlines = linecnt;</a>
<a name="ln3907">      buf-&gt;b_ml.ml_chunksize[curix + 1].mlcs_numlines -= linecnt;</a>
<a name="ln3908">      buf-&gt;b_ml.ml_chunksize[curix].mlcs_totalsize = size;</a>
<a name="ln3909">      buf-&gt;b_ml.ml_chunksize[curix + 1].mlcs_totalsize -= size;</a>
<a name="ln3910">      buf-&gt;b_ml.ml_usedchunks++;</a>
<a name="ln3911">      ml_upd_lastbuf = NULL;         /* Force recalc of curix &amp; curline */</a>
<a name="ln3912">      return;</a>
<a name="ln3913">    } else if (buf-&gt;b_ml.ml_chunksize[curix].mlcs_numlines &gt;= MLCS_MINL</a>
<a name="ln3914">               &amp;&amp; curix == buf-&gt;b_ml.ml_usedchunks - 1</a>
<a name="ln3915">               &amp;&amp; buf-&gt;b_ml.ml_line_count - line &lt;= 1) {</a>
<a name="ln3916">      /*</a>
<a name="ln3917">       * We are in the last chunk and it is cheap to crate a new one</a>
<a name="ln3918">       * after this. Do it now to avoid the loop above later on</a>
<a name="ln3919">       */</a>
<a name="ln3920">      curchnk = buf-&gt;b_ml.ml_chunksize + curix + 1;</a>
<a name="ln3921">      buf-&gt;b_ml.ml_usedchunks++;</a>
<a name="ln3922">      if (line == buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3923">        curchnk-&gt;mlcs_numlines = 0;</a>
<a name="ln3924">        curchnk-&gt;mlcs_totalsize = 0;</a>
<a name="ln3925">      } else {</a>
<a name="ln3926">        /*</a>
<a name="ln3927">         * Line is just prior to last, move count for last</a>
<a name="ln3928">         * This is the common case  when loading a new file</a>
<a name="ln3929">         */</a>
<a name="ln3930">        hp = ml_find_line(buf, buf-&gt;b_ml.ml_line_count, ML_FIND);</a>
<a name="ln3931">        if (hp == NULL) {</a>
<a name="ln3932">          buf-&gt;b_ml.ml_usedchunks = -1;</a>
<a name="ln3933">          return;</a>
<a name="ln3934">        }</a>
<a name="ln3935">        dp = hp-&gt;bh_data;</a>
<a name="ln3936">        if (dp-&gt;db_line_count == 1)</a>
<a name="ln3937">          rest = dp-&gt;db_txt_end - dp-&gt;db_txt_start;</a>
<a name="ln3938">        else</a>
<a name="ln3939">          rest =</a>
<a name="ln3940">            ((dp-&gt;db_index[dp-&gt;db_line_count - 2]) &amp; DB_INDEX_MASK)</a>
<a name="ln3941">            - dp-&gt;db_txt_start;</a>
<a name="ln3942">        curchnk-&gt;mlcs_totalsize = rest;</a>
<a name="ln3943">        curchnk-&gt;mlcs_numlines = 1;</a>
<a name="ln3944">        curchnk[-1].mlcs_totalsize -= rest;</a>
<a name="ln3945">        curchnk[-1].mlcs_numlines -= 1;</a>
<a name="ln3946">      }</a>
<a name="ln3947">    }</a>
<a name="ln3948">  } else if (updtype == ML_CHNK_DELLINE) {</a>
<a name="ln3949">    curchnk-&gt;mlcs_numlines--;</a>
<a name="ln3950">    ml_upd_lastbuf = NULL;       /* Force recalc of curix &amp; curline */</a>
<a name="ln3951">    if (curix &lt; (buf-&gt;b_ml.ml_usedchunks - 1)</a>
<a name="ln3952">        &amp;&amp; (curchnk-&gt;mlcs_numlines + curchnk[1].mlcs_numlines)</a>
<a name="ln3953">        &lt;= MLCS_MINL) {</a>
<a name="ln3954">      curix++;</a>
<a name="ln3955">      curchnk = buf-&gt;b_ml.ml_chunksize + curix;</a>
<a name="ln3956">    } else if (curix == 0 &amp;&amp; curchnk-&gt;mlcs_numlines &lt;= 0) {</a>
<a name="ln3957">      buf-&gt;b_ml.ml_usedchunks--;</a>
<a name="ln3958">      memmove(buf-&gt;b_ml.ml_chunksize, buf-&gt;b_ml.ml_chunksize + 1,</a>
<a name="ln3959">          buf-&gt;b_ml.ml_usedchunks * sizeof(chunksize_T));</a>
<a name="ln3960">      return;</a>
<a name="ln3961">    } else if (curix == 0 || (curchnk-&gt;mlcs_numlines &gt; 10</a>
<a name="ln3962">                              &amp;&amp; (curchnk-&gt;mlcs_numlines +</a>
<a name="ln3963">                                  curchnk[-1].mlcs_numlines)</a>
<a name="ln3964">                              &gt; MLCS_MINL)) {</a>
<a name="ln3965">      return;</a>
<a name="ln3966">    }</a>
<a name="ln3967"> </a>
<a name="ln3968">    /* Collapse chunks */</a>
<a name="ln3969">    curchnk[-1].mlcs_numlines += curchnk-&gt;mlcs_numlines;</a>
<a name="ln3970">    curchnk[-1].mlcs_totalsize += curchnk-&gt;mlcs_totalsize;</a>
<a name="ln3971">    buf-&gt;b_ml.ml_usedchunks--;</a>
<a name="ln3972">    if (curix &lt; buf-&gt;b_ml.ml_usedchunks) {</a>
<a name="ln3973">      memmove(buf-&gt;b_ml.ml_chunksize + curix,</a>
<a name="ln3974">          buf-&gt;b_ml.ml_chunksize + curix + 1,</a>
<a name="ln3975">          (buf-&gt;b_ml.ml_usedchunks - curix) *</a>
<a name="ln3976">          sizeof(chunksize_T));</a>
<a name="ln3977">    }</a>
<a name="ln3978">    return;</a>
<a name="ln3979">  }</a>
<a name="ln3980">  ml_upd_lastbuf = buf;</a>
<a name="ln3981">  ml_upd_lastline = line;</a>
<a name="ln3982">  ml_upd_lastcurline = curline;</a>
<a name="ln3983">  ml_upd_lastcurix = curix;</a>
<a name="ln3984">}</a>
<a name="ln3985"> </a>
<a name="ln3986">/// Find offset for line or line with offset.</a>
<a name="ln3987">///</a>
<a name="ln3988">/// @param buf buffer to use</a>
<a name="ln3989">/// @param lnum if &gt; 0, find offset of lnum, return offset</a>
<a name="ln3990">///             if == 0, return line with offset *offp</a>
<a name="ln3991">/// @param offp offset to use to find line, store remaining column offset</a>
<a name="ln3992">///             Should be NULL when getting offset of line</a>
<a name="ln3993">/// @param no_ff ignore 'fileformat' option, always use one byte for NL.</a>
<a name="ln3994">///</a>
<a name="ln3995">/// @return -1 if information is not available</a>
<a name="ln3996">long ml_find_line_or_offset(buf_T *buf, linenr_T lnum, long *offp, bool no_ff)</a>
<a name="ln3997">{</a>
<a name="ln3998">  linenr_T curline;</a>
<a name="ln3999">  int curix;</a>
<a name="ln4000">  long size;</a>
<a name="ln4001">  bhdr_T      *hp;</a>
<a name="ln4002">  DATA_BL     *dp;</a>
<a name="ln4003">  int count;                    /* number of entries in block */</a>
<a name="ln4004">  int idx;</a>
<a name="ln4005">  int start_idx;</a>
<a name="ln4006">  int text_end;</a>
<a name="ln4007">  long offset;</a>
<a name="ln4008">  int len;</a>
<a name="ln4009">  int ffdos = !no_ff &amp;&amp; (get_fileformat(buf) == EOL_DOS);</a>
<a name="ln4010">  int extra = 0;</a>
<a name="ln4011"> </a>
<a name="ln4012">  // take care of cached line first. Only needed if the cached line is before</a>
<a name="ln4013">  // the requested line. Additionally cache the value for the cached line.</a>
<a name="ln4014">  // This is used by the extmark code which needs the byte offset of the edited</a>
<a name="ln4015">  // line. So when doing multiple small edits on the same line the value is</a>
<a name="ln4016">  // only calculated once.</a>
<a name="ln4017">  //</a>
<a name="ln4018">  // NB: caching doesn't work with 'fileformat'. This is not a problem for</a>
<a name="ln4019">  // bytetracking, as bytetracking ignores 'fileformat' option. But calling</a>
<a name="ln4020">  // line2byte() will invalidate the cache for the time being (this function</a>
<a name="ln4021">  // was never cached to start with anyway).</a>
<a name="ln4022">  bool can_cache = (lnum != 0 &amp;&amp; !ffdos &amp;&amp; buf-&gt;b_ml.ml_line_lnum == lnum);</a>
<a name="ln4023">  if (lnum == 0 || buf-&gt;b_ml.ml_line_lnum &lt; lnum || !no_ff) {</a>
<a name="ln4024">    ml_flush_line(curbuf);</a>
<a name="ln4025">  } else if (can_cache &amp;&amp; buf-&gt;b_ml.ml_line_offset &gt; 0) {</a>
<a name="ln4026">    return buf-&gt;b_ml.ml_line_offset;</a>
<a name="ln4027">  }</a>
<a name="ln4028"> </a>
<a name="ln4029">  if (buf-&gt;b_ml.ml_usedchunks == -1</a>
<a name="ln4030">      || buf-&gt;b_ml.ml_chunksize == NULL</a>
<a name="ln4031">      || lnum &lt; 0)</a>
<a name="ln4032">    return -1;</a>
<a name="ln4033"> </a>
<a name="ln4034">  if (offp == NULL)</a>
<a name="ln4035">    offset = 0;</a>
<a name="ln4036">  else</a>
<a name="ln4037">    offset = *offp;</a>
<a name="ln4038">  if (lnum == 0 &amp;&amp; offset &lt;= 0)</a>
<a name="ln4039">    return 1;       /* Not a &quot;find offset&quot; and offset 0 _must_ be in line 1 */</a>
<a name="ln4040">  /*</a>
<a name="ln4041">   * Find the last chunk before the one containing our line. Last chunk is</a>
<a name="ln4042">   * special because it will never qualify</a>
<a name="ln4043">   */</a>
<a name="ln4044">  curline = 1;</a>
<a name="ln4045">  curix = size = 0;</a>
<a name="ln4046">  while (curix &lt; buf-&gt;b_ml.ml_usedchunks - 1</a>
<a name="ln4047">         &amp;&amp; ((lnum != 0</a>
<a name="ln4048">              &amp;&amp; lnum &gt;= curline + buf-&gt;b_ml.ml_chunksize[curix].mlcs_numlines)</a>
<a name="ln4049">             || (offset != 0</a>
<a name="ln4050">                 &amp;&amp; offset &gt; size +</a>
<a name="ln4051">                 buf-&gt;b_ml.ml_chunksize[curix].mlcs_totalsize</a>
<a name="ln4052">                 + ffdos * buf-&gt;b_ml.ml_chunksize[curix].mlcs_numlines))) {</a>
<a name="ln4053">    curline += buf-&gt;b_ml.ml_chunksize[curix].mlcs_numlines;</a>
<a name="ln4054">    size += buf-&gt;b_ml.ml_chunksize[curix].mlcs_totalsize;</a>
<a name="ln4055">    if (offset &amp;&amp; ffdos)</a>
<a name="ln4056">      size += buf-&gt;b_ml.ml_chunksize[curix].mlcs_numlines;</a>
<a name="ln4057">    curix++;</a>
<a name="ln4058">  }</a>
<a name="ln4059"> </a>
<a name="ln4060">  while ((lnum != 0 &amp;&amp; curline &lt; lnum) || (offset != 0 &amp;&amp; size &lt; offset)) {</a>
<a name="ln4061">    if (curline &gt; buf-&gt;b_ml.ml_line_count</a>
<a name="ln4062">        || (hp = ml_find_line(buf, curline, ML_FIND)) == NULL)</a>
<a name="ln4063">      return -1;</a>
<a name="ln4064">    dp = hp-&gt;bh_data;</a>
<a name="ln4065">    count = (long)(buf-&gt;b_ml.ml_locked_high) -</a>
<a name="ln4066">            (long)(buf-&gt;b_ml.ml_locked_low) + 1;</a>
<a name="ln4067">    start_idx = idx = curline - buf-&gt;b_ml.ml_locked_low;</a>
<a name="ln4068">    if (idx == 0)    /* first line in block, text at the end */</a>
<a name="ln4069">      text_end = dp-&gt;db_txt_end;</a>
<a name="ln4070">    else</a>
<a name="ln4071">      text_end = ((dp-&gt;db_index[idx - 1]) &amp; DB_INDEX_MASK);</a>
<a name="ln4072">    /* Compute index of last line to use in this MEMLINE */</a>
<a name="ln4073">    if (lnum != 0) {</a>
<a name="ln4074">      if (curline + (count - idx) &gt;= lnum)</a>
<a name="ln4075">        idx += lnum - curline - 1;</a>
<a name="ln4076">      else</a>
<a name="ln4077">        idx = count - 1;</a>
<a name="ln4078">    } else {</a>
<a name="ln4079">      extra = 0;</a>
<a name="ln4080">      while (offset &gt;= size</a>
<a name="ln4081">             + text_end - (int)((dp-&gt;db_index[idx]) &amp; DB_INDEX_MASK)</a>
<a name="ln4082">             + ffdos) {</a>
<a name="ln4083">        if (ffdos)</a>
<a name="ln4084">          size++;</a>
<a name="ln4085">        if (idx == count - 1) {</a>
<a name="ln4086">          extra = 1;</a>
<a name="ln4087">          break;</a>
<a name="ln4088">        }</a>
<a name="ln4089">        idx++;</a>
<a name="ln4090">      }</a>
<a name="ln4091">    }</a>
<a name="ln4092">    len = text_end - ((dp-&gt;db_index[idx]) &amp; DB_INDEX_MASK);</a>
<a name="ln4093">    size += len;</a>
<a name="ln4094">    if (offset != 0 &amp;&amp; size &gt;= offset) {</a>
<a name="ln4095">      if (size + ffdos == offset)</a>
<a name="ln4096">        *offp = 0;</a>
<a name="ln4097">      else if (idx == start_idx)</a>
<a name="ln4098">        *offp = offset - size + len;</a>
<a name="ln4099">      else</a>
<a name="ln4100">        *offp = offset - size + len</a>
<a name="ln4101">                - (text_end - ((dp-&gt;db_index[idx - 1]) &amp; DB_INDEX_MASK));</a>
<a name="ln4102">      curline += idx - start_idx + extra;</a>
<a name="ln4103">      if (curline &gt; buf-&gt;b_ml.ml_line_count)</a>
<a name="ln4104">        return -1;              /* exactly one byte beyond the end */</a>
<a name="ln4105">      return curline;</a>
<a name="ln4106">    }</a>
<a name="ln4107">    curline = buf-&gt;b_ml.ml_locked_high + 1;</a>
<a name="ln4108">  }</a>
<a name="ln4109"> </a>
<a name="ln4110">  if (lnum != 0) {</a>
<a name="ln4111">    /* Count extra CR characters. */</a>
<a name="ln4112">    if (ffdos)</a>
<a name="ln4113">      size += lnum - 1;</a>
<a name="ln4114"> </a>
<a name="ln4115">    /* Don't count the last line break if 'noeol' and ('bin' or</a>
<a name="ln4116">     * 'nofixeol'). */</a>
<a name="ln4117">    if ((!buf-&gt;b_p_fixeol || buf-&gt;b_p_bin) &amp;&amp; !buf-&gt;b_p_eol</a>
<a name="ln4118">        &amp;&amp; lnum &gt; buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln4119">      size -= ffdos + 1;</a>
<a name="ln4120">    }</a>
<a name="ln4121">  }</a>
<a name="ln4122"> </a>
<a name="ln4123">  if (can_cache &amp;&amp; size &gt; 0) {</a>
<a name="ln4124">    buf-&gt;b_ml.ml_line_offset = size;</a>
<a name="ln4125">  }</a>
<a name="ln4126"> </a>
<a name="ln4127">  return size;</a>
<a name="ln4128">}</a>
<a name="ln4129"> </a>
<a name="ln4130">/// Goto byte in buffer with offset 'cnt'.</a>
<a name="ln4131">void goto_byte(long cnt)</a>
<a name="ln4132">{</a>
<a name="ln4133">  long boff = cnt;</a>
<a name="ln4134">  linenr_T lnum;</a>
<a name="ln4135"> </a>
<a name="ln4136">  ml_flush_line(curbuf);  // cached line may be dirty</a>
<a name="ln4137">  setpcmark();</a>
<a name="ln4138">  if (boff) {</a>
<a name="ln4139">    boff--;</a>
<a name="ln4140">  }</a>
<a name="ln4141">  lnum = ml_find_line_or_offset(curbuf, (linenr_T)0, &amp;boff, false);</a>
<a name="ln4142">  if (lnum &lt; 1) {         // past the end</a>
<a name="ln4143">    curwin-&gt;w_cursor.lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln4144">    curwin-&gt;w_curswant = MAXCOL;</a>
<a name="ln4145">    coladvance(MAXCOL);</a>
<a name="ln4146">  } else {</a>
<a name="ln4147">    curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln4148">    curwin-&gt;w_cursor.col = (colnr_T)boff;</a>
<a name="ln4149">    curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln4150">    curwin-&gt;w_set_curswant = TRUE;</a>
<a name="ln4151">  }</a>
<a name="ln4152">  check_cursor();</a>
<a name="ln4153"> </a>
<a name="ln4154">  // Make sure the cursor is on the first byte of a multi-byte char.</a>
<a name="ln4155">  mb_adjust_cursor();</a>
<a name="ln4156">}</a>
<a name="ln4157"> </a>
<a name="ln4158">/// Increment the line pointer &quot;lp&quot; crossing line boundaries as necessary.</a>
<a name="ln4159">/// Return 1 when going to the next line.</a>
<a name="ln4160">/// Return 2 when moving forward onto a NUL at the end of the line).</a>
<a name="ln4161">/// Return -1 when at the end of file.</a>
<a name="ln4162">/// Return 0 otherwise.</a>
<a name="ln4163">int inc(pos_T *lp)</a>
<a name="ln4164">{</a>
<a name="ln4165">  // when searching position may be set to end of a line</a>
<a name="ln4166">  if (lp-&gt;col != MAXCOL) {</a>
<a name="ln4167">    const char_u *const p = ml_get_pos(lp);</a>
<a name="ln4168">    if (*p != NUL) {  // still within line, move to next char (may be NUL)</a>
<a name="ln4169">      const int l = utfc_ptr2len(p);</a>
<a name="ln4170"> </a>
<a name="ln4171">      lp-&gt;col += l;</a>
<a name="ln4172">      return ((p[l] != NUL) ? 0 : 2);</a>
<a name="ln4173">    }</a>
<a name="ln4174">  }</a>
<a name="ln4175">  if (lp-&gt;lnum != curbuf-&gt;b_ml.ml_line_count) {     // there is a next line</a>
<a name="ln4176">    lp-&gt;col = 0;</a>
<a name="ln4177">    lp-&gt;lnum++;</a>
<a name="ln4178">    lp-&gt;coladd = 0;</a>
<a name="ln4179">    return 1;</a>
<a name="ln4180">  }</a>
<a name="ln4181">  return -1;</a>
<a name="ln4182">}</a>
<a name="ln4183"> </a>
<a name="ln4184">/// Same as inc(), but skip NUL at the end of non-empty lines.</a>
<a name="ln4185">int incl(pos_T *lp)</a>
<a name="ln4186">{</a>
<a name="ln4187">  int r;</a>
<a name="ln4188"> </a>
<a name="ln4189">  if ((r = inc(lp)) &gt;= 1 &amp;&amp; lp-&gt;col) {</a>
<a name="ln4190">    r = inc(lp);</a>
<a name="ln4191">  }</a>
<a name="ln4192">  return r;</a>
<a name="ln4193">}</a>
<a name="ln4194"> </a>
<a name="ln4195">int dec(pos_T *lp)</a>
<a name="ln4196">{</a>
<a name="ln4197">  lp-&gt;coladd = 0;</a>
<a name="ln4198">  if (lp-&gt;col == MAXCOL) {</a>
<a name="ln4199">    // past end of line</a>
<a name="ln4200">    char_u *p = ml_get(lp-&gt;lnum);</a>
<a name="ln4201">    lp-&gt;col = (colnr_T)STRLEN(p);</a>
<a name="ln4202">    lp-&gt;col -= utf_head_off(p, p + lp-&gt;col);</a>
<a name="ln4203">    return 0;</a>
<a name="ln4204">  }</a>
<a name="ln4205"> </a>
<a name="ln4206">  if (lp-&gt;col &gt; 0) {</a>
<a name="ln4207">    // still within line</a>
<a name="ln4208">    lp-&gt;col--;</a>
<a name="ln4209">    char_u *p = ml_get(lp-&gt;lnum);</a>
<a name="ln4210">    lp-&gt;col -= utf_head_off(p, p + lp-&gt;col);</a>
<a name="ln4211">    return 0;</a>
<a name="ln4212">  }</a>
<a name="ln4213">  if (lp-&gt;lnum &gt; 1) {</a>
<a name="ln4214">    // there is a prior line</a>
<a name="ln4215">    lp-&gt;lnum--;</a>
<a name="ln4216">    char_u *p = ml_get(lp-&gt;lnum);</a>
<a name="ln4217">    lp-&gt;col = (colnr_T)STRLEN(p);</a>
<a name="ln4218">    lp-&gt;col -= utf_head_off(p, p + lp-&gt;col);</a>
<a name="ln4219">    return 1;</a>
<a name="ln4220">  }</a>
<a name="ln4221"> </a>
<a name="ln4222">  // at start of file</a>
<a name="ln4223">  return -1;</a>
<a name="ln4224">}</a>
<a name="ln4225"> </a>
<a name="ln4226">/// Same as dec(), but skip NUL at the end of non-empty lines.</a>
<a name="ln4227">int decl(pos_T *lp)</a>
<a name="ln4228">{</a>
<a name="ln4229">  int r;</a>
<a name="ln4230"> </a>
<a name="ln4231">  if ((r = dec(lp)) == 1 &amp;&amp; lp-&gt;col) {</a>
<a name="ln4232">    r = dec(lp);</a>
<a name="ln4233">  }</a>
<a name="ln4234">  return r;</a>
<a name="ln4235">}</a>

</code></pre>
<div class="balloon" rel="1017"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'buf->b_ml.ml_stack_top' variable was assigned the same value.</p></div>
<div class="balloon" rel="1019"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'buf->b_ml.ml_stack_size' variable was assigned the same value.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
