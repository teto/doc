
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>sign.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">//</a>
<a name="ln5">// sign.c: functions for managing with signs</a>
<a name="ln6">//</a>
<a name="ln7"> </a>
<a name="ln8"> </a>
<a name="ln9">#include &quot;nvim/vim.h&quot;</a>
<a name="ln10">#include &quot;nvim/sign.h&quot;</a>
<a name="ln11">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln12">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln13">#include &quot;nvim/charset.h&quot;</a>
<a name="ln14">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln15">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln16">#include &quot;nvim/edit.h&quot;</a>
<a name="ln17">#include &quot;nvim/fold.h&quot;</a>
<a name="ln18">#include &quot;nvim/move.h&quot;</a>
<a name="ln19">#include &quot;nvim/screen.h&quot;</a>
<a name="ln20">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln21">#include &quot;nvim/option.h&quot;</a>
<a name="ln22"> </a>
<a name="ln23">/// Struct to hold the sign properties.</a>
<a name="ln24">typedef struct sign sign_T;</a>
<a name="ln25"> </a>
<a name="ln26">struct sign</a>
<a name="ln27">{</a>
<a name="ln28">    sign_T      *sn_next;       // next sign in list</a>
<a name="ln29">    int         sn_typenr;      // type number of sign</a>
<a name="ln30">    char_u      *sn_name;       // name of sign</a>
<a name="ln31">    char_u      *sn_icon;       // name of pixmap</a>
<a name="ln32">    char_u      *sn_text;       // text used instead of pixmap</a>
<a name="ln33">    int         sn_line_hl;     // highlight ID for line</a>
<a name="ln34">    int         sn_text_hl;     // highlight ID for text</a>
<a name="ln35">    int         sn_num_hl;      // highlight ID for line number</a>
<a name="ln36">};</a>
<a name="ln37"> </a>
<a name="ln38">static sign_T *first_sign = NULL;</a>
<a name="ln39">static int next_sign_typenr = 1;</a>
<a name="ln40"> </a>
<a name="ln41">static void sign_list_defined(sign_T *sp);</a>
<a name="ln42">static void sign_undefine(sign_T *sp, sign_T *sp_prev);</a>
<a name="ln43"> </a>
<a name="ln44">static char *cmds[] = {</a>
<a name="ln45">                        &quot;define&quot;,</a>
<a name="ln46">#define SIGNCMD_DEFINE  0</a>
<a name="ln47">                        &quot;undefine&quot;,</a>
<a name="ln48">#define SIGNCMD_UNDEFINE 1</a>
<a name="ln49">                        &quot;list&quot;,</a>
<a name="ln50">#define SIGNCMD_LIST    2</a>
<a name="ln51">                        &quot;place&quot;,</a>
<a name="ln52">#define SIGNCMD_PLACE   3</a>
<a name="ln53">                        &quot;unplace&quot;,</a>
<a name="ln54">#define SIGNCMD_UNPLACE 4</a>
<a name="ln55">                        &quot;jump&quot;,</a>
<a name="ln56">#define SIGNCMD_JUMP    5</a>
<a name="ln57">                        NULL</a>
<a name="ln58">#define SIGNCMD_LAST    6</a>
<a name="ln59">};</a>
<a name="ln60"> </a>
<a name="ln61"> </a>
<a name="ln62">static hashtab_T sg_table;  // sign group (signgroup_T) hashtable</a>
<a name="ln63">static int next_sign_id = 1;  // next sign id in the global group</a>
<a name="ln64"> </a>
<a name="ln65">/// Initialize data needed for managing signs</a>
<a name="ln66">void init_signs(void)</a>
<a name="ln67">{</a>
<a name="ln68">    hash_init(&amp;sg_table);  // sign group hash table</a>
<a name="ln69">}</a>
<a name="ln70"> </a>
<a name="ln71">/// A new sign in group 'groupname' is added. If the group is not present,</a>
<a name="ln72">/// create it. Otherwise reference the group.</a>
<a name="ln73">///</a>
<a name="ln74">static signgroup_T * sign_group_ref(const char_u *groupname)</a>
<a name="ln75">{</a>
<a name="ln76">  hash_T        hash;</a>
<a name="ln77">  hashitem_T    *hi;</a>
<a name="ln78">  signgroup_T   *group;</a>
<a name="ln79"> </a>
<a name="ln80">  hash = hash_hash(groupname);</a>
<a name="ln81">  hi = hash_lookup(&amp;sg_table, (char *)groupname, STRLEN(groupname), hash);</a>
<a name="ln82">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln83">    // new group</a>
<a name="ln84">    group = xmalloc((unsigned)(sizeof(signgroup_T) + STRLEN(groupname)));</a>
<a name="ln85"> </a>
<a name="ln86">    STRCPY(group-&gt;sg_name, groupname);</a>
<a name="ln87">    group-&gt;sg_refcount = 1;</a>
<a name="ln88">    group-&gt;sg_next_sign_id = 1;</a>
<a name="ln89">    hash_add_item(&amp;sg_table, hi, group-&gt;sg_name, hash);</a>
<a name="ln90">  } else {</a>
<a name="ln91">    // existing group</a>
<a name="ln92">    group = HI2SG(hi);</a>
<a name="ln93">    group-&gt;sg_refcount++;</a>
<a name="ln94">  }</a>
<a name="ln95"> </a>
<a name="ln96">  return group;</a>
<a name="ln97">}</a>
<a name="ln98"> </a>
<a name="ln99">/// A sign in group 'groupname' is removed. If all the signs in this group are</a>
<a name="ln100">/// removed, then remove the group.</a>
<a name="ln101">static void sign_group_unref(char_u *groupname)</a>
<a name="ln102">{</a>
<a name="ln103">  hashitem_T  *hi;</a>
<a name="ln104">  signgroup_T *group;</a>
<a name="ln105"> </a>
<a name="ln106">  hi = hash_find(&amp;sg_table, groupname);</a>
<a name="ln107">  if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln108">    group = HI2SG(hi);</a>
<a name="ln109">    group-&gt;sg_refcount--;</a>
<a name="ln110">    if (group-&gt;sg_refcount == 0) {</a>
<a name="ln111">      // All the signs in this group are removed</a>
<a name="ln112">      hash_remove(&amp;sg_table, hi);</a>
<a name="ln113">      xfree(group);</a>
<a name="ln114">    }</a>
<a name="ln115">  }</a>
<a name="ln116">}</a>
<a name="ln117"> </a>
<a name="ln118">/// Returns TRUE if 'sign' is in 'group'.</a>
<a name="ln119">/// A sign can either be in the global group (sign-&gt;group == NULL)</a>
<a name="ln120">/// or in a named group. If 'group' is '*', then the sign is part of the group.</a>
<a name="ln121">int sign_in_group(sign_entry_T *sign, const char_u *group)</a>
<a name="ln122">{</a>
<a name="ln123">    return ((group != NULL &amp;&amp; STRCMP(group, &quot;*&quot;) == 0)</a>
<a name="ln124">            || (group == NULL &amp;&amp; sign-&gt;se_group == NULL)</a>
<a name="ln125">            || (group != NULL &amp;&amp; sign-&gt;se_group != NULL</a>
<a name="ln126">                &amp;&amp; STRCMP(group, sign-&gt;se_group-&gt;sg_name) == 0));</a>
<a name="ln127">}</a>
<a name="ln128"> </a>
<a name="ln129">/// Get the next free sign identifier in the specified group</a>
<a name="ln130">int sign_group_get_next_signid(buf_T *buf, const char_u *groupname)</a>
<a name="ln131">{</a>
<a name="ln132">  int id = 1;</a>
<a name="ln133">  signgroup_T *group = NULL;</a>
<a name="ln134">  sign_entry_T *sign;</a>
<a name="ln135">  hashitem_T *hi;</a>
<a name="ln136">  int found = false;</a>
<a name="ln137"> </a>
<a name="ln138">  if (groupname != NULL) {</a>
<a name="ln139">    hi = hash_find(&amp;sg_table, groupname);</a>
<a name="ln140">    if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln141">      return id;</a>
<a name="ln142">    }</a>
<a name="ln143">    group = HI2SG(hi);</a>
<a name="ln144">  }</a>
<a name="ln145"> </a>
<a name="ln146">  // Search for the next usuable sign identifier</a>
<a name="ln147">  while (!found) {</a>
<a name="ln148">    if (group == NULL) {</a>
<a name="ln149">      id = next_sign_id++;    // global group</a>
<a name="ln150">    } else {</a>
<a name="ln151">      id = group-&gt;sg_next_sign_id++;</a>
<a name="ln152">    }</a>
<a name="ln153"> </a>
<a name="ln154">    // Check whether this sign is already placed in the buffer</a>
<a name="ln155">    found = true;</a>
<a name="ln156">    FOR_ALL_SIGNS_IN_BUF(buf, sign) {</a>
<a name="ln157">      if (id == sign-&gt;se_id &amp;&amp; sign_in_group(sign, groupname)) {</a>
<a name="ln158">        found = false;    // sign identifier is in use</a>
<a name="ln159">        break;</a>
<a name="ln160">      }</a>
<a name="ln161">    }</a>
<a name="ln162">  }</a>
<a name="ln163"> </a>
<a name="ln164">  return id;</a>
<a name="ln165">}</a>
<a name="ln166"> </a>
<a name="ln167">/// Insert a new sign into the signlist for buffer 'buf' between the 'prev' and</a>
<a name="ln168">/// 'next' signs.</a>
<a name="ln169">static void insert_sign(</a>
<a name="ln170">    buf_T *buf,             // buffer to store sign in</a>
<a name="ln171">    sign_entry_T *prev,       // previous sign entry</a>
<a name="ln172">    sign_entry_T *next,       // next sign entry</a>
<a name="ln173">    int id,                 // sign ID</a>
<a name="ln174">    const char_u *group,    // sign group; NULL for global group</a>
<a name="ln175">    int prio,               // sign priority</a>
<a name="ln176">    linenr_T lnum,          // line number which gets the mark</a>
<a name="ln177">    int typenr,             // typenr of sign we are adding</a>
<a name="ln178">    bool has_text_or_icon   // sign has text or icon</a>
<a name="ln179">)</a>
<a name="ln180">{</a>
<a name="ln181">  sign_entry_T *newsign = xmalloc(sizeof(sign_entry_T));</a>
<a name="ln182">  newsign-&gt;se_id = id;</a>
<a name="ln183">  newsign-&gt;se_lnum = lnum;</a>
<a name="ln184">  newsign-&gt;se_typenr = typenr;</a>
<a name="ln185">  newsign-&gt;se_has_text_or_icon = has_text_or_icon;</a>
<a name="ln186">  if (group != NULL) {</a>
<a name="ln187">    newsign-&gt;se_group = sign_group_ref(group);</a>
<a name="ln188">  } else {</a>
<a name="ln189">    newsign-&gt;se_group = NULL;</a>
<a name="ln190">  }</a>
<a name="ln191">  newsign-&gt;se_priority = prio;</a>
<a name="ln192">  newsign-&gt;se_next = next;</a>
<a name="ln193">  newsign-&gt;se_prev = prev;</a>
<a name="ln194">  if (next != NULL) {</a>
<a name="ln195">    next-&gt;se_prev = newsign;</a>
<a name="ln196">  }</a>
<a name="ln197">  buf-&gt;b_signcols_max = -1;</a>
<a name="ln198"> </a>
<a name="ln199">  if (prev == NULL) {</a>
<a name="ln200">    // When adding first sign need to redraw the windows to create the</a>
<a name="ln201">    // column for signs.</a>
<a name="ln202">    if (buf-&gt;b_signlist == NULL) {</a>
<a name="ln203">      redraw_buf_later(buf, NOT_VALID);</a>
<a name="ln204">      changed_line_abv_curs();</a>
<a name="ln205">    }</a>
<a name="ln206"> </a>
<a name="ln207">    // first sign in signlist</a>
<a name="ln208">    buf-&gt;b_signlist = newsign;</a>
<a name="ln209">  } else {</a>
<a name="ln210">    prev-&gt;se_next = newsign;</a>
<a name="ln211">  }</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">/// Insert a new sign sorted by line number and sign priority.</a>
<a name="ln215">static void insert_sign_by_lnum_prio(</a>
<a name="ln216">    buf_T *buf,            // buffer to store sign in</a>
<a name="ln217">    sign_entry_T *prev,      // previous sign entry</a>
<a name="ln218">    int id,                // sign ID</a>
<a name="ln219">    const char_u *group,   // sign group; NULL for global group</a>
<a name="ln220">    int prio,              // sign priority</a>
<a name="ln221">    linenr_T lnum,         // line number which gets the mark</a>
<a name="ln222">    int typenr,            // typenr of sign we are adding</a>
<a name="ln223">    bool has_text_or_icon  // sign has text or icon</a>
<a name="ln224">)</a>
<a name="ln225">{</a>
<a name="ln226">  sign_entry_T  *sign;</a>
<a name="ln227"> </a>
<a name="ln228">  // keep signs sorted by lnum, priority and id: insert new sign at</a>
<a name="ln229">  // the proper position in the list for this lnum.</a>
<a name="ln230">  while (prev != NULL &amp;&amp; prev-&gt;se_lnum == lnum</a>
<a name="ln231">         &amp;&amp; (prev-&gt;se_priority &lt; prio</a>
<a name="ln232">             || (prev-&gt;se_priority == prio &amp;&amp; prev-&gt;se_id &lt;= id))) {</a>
<a name="ln233">    prev = prev-&gt;se_prev;</a>
<a name="ln234">  }</a>
<a name="ln235">  if (prev == NULL) {</a>
<a name="ln236">    sign = buf-&gt;b_signlist;</a>
<a name="ln237">  } else {</a>
<a name="ln238">    sign = prev-&gt;se_next;</a>
<a name="ln239">  }</a>
<a name="ln240"> </a>
<a name="ln241">  insert_sign(buf, prev, sign, id, group, prio, lnum, typenr, has_text_or_icon);</a>
<a name="ln242">}</a>
<a name="ln243"> </a>
<a name="ln244">/// Get the name of a sign by its typenr.</a>
<a name="ln245">char_u * sign_typenr2name(int typenr)</a>
<a name="ln246">{</a>
<a name="ln247">  sign_T  *sp;</a>
<a name="ln248"> </a>
<a name="ln249">  for (sp = first_sign; sp != NULL; sp = sp-&gt;sn_next) {</a>
<a name="ln250">    if (sp-&gt;sn_typenr == typenr) {</a>
<a name="ln251">      return sp-&gt;sn_name;</a>
<a name="ln252">    }</a>
<a name="ln253">  }</a>
<a name="ln254">  return (char_u *)_(&quot;[Deleted]&quot;);</a>
<a name="ln255">}</a>
<a name="ln256"> </a>
<a name="ln257">/// Return information about a sign in a Dict</a>
<a name="ln258">dict_T * sign_get_info(sign_entry_T *sign)</a>
<a name="ln259">{</a>
<a name="ln260">  dict_T  *d = tv_dict_alloc();</a>
<a name="ln261">  tv_dict_add_nr(d,  S_LEN(&quot;id&quot;), sign-&gt;se_id);</a>
<a name="ln262">  tv_dict_add_str(d, S_LEN(&quot;group&quot;), ((sign-&gt;se_group == NULL)</a>
<a name="ln263">                                      ? (char *)&quot;&quot;</a>
<a name="ln264">                                      : (char *)sign-&gt;se_group-&gt;sg_name));</a>
<a name="ln265">  tv_dict_add_nr(d,  S_LEN(&quot;lnum&quot;), sign-&gt;se_lnum);</a>
<a name="ln266">  tv_dict_add_str(d, S_LEN(&quot;name&quot;), (char *)sign_typenr2name(sign-&gt;se_typenr));</a>
<a name="ln267">  tv_dict_add_nr(d,  S_LEN(&quot;priority&quot;), sign-&gt;se_priority);</a>
<a name="ln268"> </a>
<a name="ln269">  return d;</a>
<a name="ln270">}</a>
<a name="ln271"> </a>
<a name="ln272">// Sort the signs placed on the same line as &quot;sign&quot; by priority.  Invoked after</a>
<a name="ln273">// changing the priority of an already placed sign.  Assumes the signs in the</a>
<a name="ln274">// buffer are sorted by line number and priority.</a>
<a name="ln275">static void sign_sort_by_prio_on_line(buf_T *buf, sign_entry_T *sign)</a>
<a name="ln276">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln277">{</a>
<a name="ln278">  // If there is only one sign in the buffer or only one sign on the line or</a>
<a name="ln279">  // the sign is already sorted by priority, then return.</a>
<a name="ln280">  if ((sign-&gt;se_prev == NULL</a>
<a name="ln281">       || sign-&gt;se_prev-&gt;se_lnum != sign-&gt;se_lnum</a>
<a name="ln282">       || sign-&gt;se_prev-&gt;se_priority &gt; sign-&gt;se_priority)</a>
<a name="ln283">      &amp;&amp; (sign-&gt;se_next == NULL</a>
<a name="ln284">          || sign-&gt;se_next-&gt;se_lnum != sign-&gt;se_lnum</a>
<a name="ln285">          || sign-&gt;se_next-&gt;se_priority &lt; sign-&gt;se_priority)) {</a>
<a name="ln286">    return;</a>
<a name="ln287">  }</a>
<a name="ln288"> </a>
<a name="ln289">  // One or more signs on the same line as 'sign'</a>
<a name="ln290">  // Find a sign after which 'sign' should be inserted</a>
<a name="ln291"> </a>
<a name="ln292">  // First search backward for a sign with higher priority on the same line</a>
<a name="ln293">  sign_entry_T *p = sign;</a>
<a name="ln294">  while (p-&gt;se_prev != NULL</a>
<a name="ln295">         &amp;&amp; p-&gt;se_prev-&gt;se_lnum == sign-&gt;se_lnum</a>
<a name="ln296">         &amp;&amp; p-&gt;se_prev-&gt;se_priority &lt;= sign-&gt;se_priority) {</a>
<a name="ln297">    p = p-&gt;se_prev;</a>
<a name="ln298">  }</a>
<a name="ln299">  if (p == sign) {</a>
<a name="ln300">    // Sign not found. Search forward for a sign with priority just before</a>
<a name="ln301">    // 'sign'.</a>
<a name="ln302">    p = sign-&gt;se_next;</a>
<a name="ln303">    while (p-&gt;se_next != NULL</a>
<a name="ln304">           &amp;&amp; p-&gt;se_next-&gt;se_lnum == sign-&gt;se_lnum</a>
<a name="ln305">           &amp;&amp; p-&gt;se_next-&gt;se_priority &gt; sign-&gt;se_priority) {</a>
<a name="ln306">      p = p-&gt;se_next;</a>
<a name="ln307">    }</a>
<a name="ln308">  }</a>
<a name="ln309"> </a>
<a name="ln310">  // Remove 'sign' from the list</a>
<a name="ln311">  if (buf-&gt;b_signlist == sign) {</a>
<a name="ln312">    buf-&gt;b_signlist = sign-&gt;se_next;</a>
<a name="ln313">  }</a>
<a name="ln314">  if (sign-&gt;se_prev != NULL) {</a>
<a name="ln315">    sign-&gt;se_prev-&gt;se_next = sign-&gt;se_next;</a>
<a name="ln316">  }</a>
<a name="ln317">  if (sign-&gt;se_next != NULL) {</a>
<a name="ln318">    sign-&gt;se_next-&gt;se_prev = sign-&gt;se_prev;</a>
<a name="ln319">  }</a>
<a name="ln320">  sign-&gt;se_prev = NULL;</a>
<a name="ln321">  sign-&gt;se_next = NULL;</a>
<a name="ln322"> </a>
<a name="ln323">  // Re-insert 'sign' at the right place</a>
<a name="ln324">  if (p-&gt;se_priority &lt;= sign-&gt;se_priority) {</a>
<a name="ln325">    // 'sign' has a higher priority and should be inserted before 'p'</a>
<a name="ln326">    sign-&gt;se_prev = p-&gt;se_prev;</a>
<a name="ln327">    sign-&gt;se_next = p;</a>
<a name="ln328">    p-&gt;se_prev = sign;</a>
<a name="ln329">    if (sign-&gt;se_prev != NULL) {</a>
<a name="ln330">      sign-&gt;se_prev-&gt;se_next = sign;</a>
<a name="ln331">    }</a>
<a name="ln332">    if (buf-&gt;b_signlist == p) {</a>
<a name="ln333">      buf-&gt;b_signlist = sign;</a>
<a name="ln334">    }</a>
<a name="ln335">  } else {</a>
<a name="ln336">    // 'sign' has a lower priority and should be inserted after 'p'</a>
<a name="ln337">    sign-&gt;se_prev = p;</a>
<a name="ln338">    sign-&gt;se_next = p-&gt;se_next;</a>
<a name="ln339">    p-&gt;se_next = sign;</a>
<a name="ln340">    if (sign-&gt;se_next != NULL) {</a>
<a name="ln341">      sign-&gt;se_next-&gt;se_prev = sign;</a>
<a name="ln342">    }</a>
<a name="ln343">  }</a>
<a name="ln344">}</a>
<a name="ln345"> </a>
<a name="ln346"> </a>
<a name="ln347">/// Add the sign into the signlist. Find the right spot to do it though.</a>
<a name="ln348">void buf_addsign(</a>
<a name="ln349">    buf_T *buf,               // buffer to store sign in</a>
<a name="ln350">    int id,                   // sign ID</a>
<a name="ln351">    const char_u *groupname,  // sign group</a>
<a name="ln352">    int prio,                 // sign priority</a>
<a name="ln353">    linenr_T lnum,            // line number which gets the mark</a>
<a name="ln354">    int typenr,               // typenr of sign we are adding</a>
<a name="ln355">    bool has_text_or_icon     // sign has text or icon</a>
<a name="ln356">)</a>
<a name="ln357">{</a>
<a name="ln358">  sign_entry_T *sign;    // a sign in the signlist</a>
<a name="ln359">  sign_entry_T *prev;    // the previous sign</a>
<a name="ln360"> </a>
<a name="ln361">  prev = NULL;</a>
<a name="ln362">  FOR_ALL_SIGNS_IN_BUF(buf, sign) {</a>
<a name="ln363">    if (lnum == sign-&gt;se_lnum &amp;&amp; id == sign-&gt;se_id</a>
<a name="ln364">        &amp;&amp; sign_in_group(sign, groupname)) {</a>
<a name="ln365">      // Update an existing sign</a>
<a name="ln366">      sign-&gt;se_typenr = typenr;</a>
<a name="ln367">      sign-&gt;se_priority = prio;</a>
<a name="ln368">      sign_sort_by_prio_on_line(buf, sign);</a>
<a name="ln369">      return;</a>
<a name="ln370">    } else if (lnum &lt; sign-&gt;se_lnum) {</a>
<a name="ln371">      insert_sign_by_lnum_prio(</a>
<a name="ln372">          buf,</a>
<a name="ln373">          prev,</a>
<a name="ln374">          id,</a>
<a name="ln375">          groupname,</a>
<a name="ln376">          prio,</a>
<a name="ln377">          lnum,</a>
<a name="ln378">          typenr,</a>
<a name="ln379">          has_text_or_icon);</a>
<a name="ln380">      return;</a>
<a name="ln381">    }</a>
<a name="ln382">    prev = sign;</a>
<a name="ln383">  }</a>
<a name="ln384"> </a>
<a name="ln385">  insert_sign_by_lnum_prio(</a>
<a name="ln386">      buf,</a>
<a name="ln387">      prev,</a>
<a name="ln388">      id,</a>
<a name="ln389">      groupname,</a>
<a name="ln390">      prio,</a>
<a name="ln391">      lnum,</a>
<a name="ln392">      typenr,</a>
<a name="ln393">      has_text_or_icon);</a>
<a name="ln394">}</a>
<a name="ln395"> </a>
<a name="ln396">// For an existing, placed sign &quot;markId&quot; change the type to &quot;typenr&quot;.</a>
<a name="ln397">// Returns the line number of the sign, or zero if the sign is not found.</a>
<a name="ln398">linenr_T buf_change_sign_type(</a>
<a name="ln399">    buf_T *buf,         // buffer to store sign in</a>
<a name="ln400">    int markId,         // sign ID</a>
<a name="ln401">    const char_u *group,      // sign group</a>
<a name="ln402">    int typenr,         // typenr of sign we are adding</a>
<a name="ln403">    int prio            // sign priority</a>
<a name="ln404">)</a>
<a name="ln405">{</a>
<a name="ln406">    sign_entry_T *sign;  // a sign in the signlist</a>
<a name="ln407"> </a>
<a name="ln408">    FOR_ALL_SIGNS_IN_BUF(buf, sign) {</a>
<a name="ln409">        if (sign-&gt;se_id == markId &amp;&amp; sign_in_group(sign, group)) {</a>
<a name="ln410">            sign-&gt;se_typenr = typenr;</a>
<a name="ln411">            sign-&gt;se_priority = prio;</a>
<a name="ln412">            sign_sort_by_prio_on_line(buf, sign);</a>
<a name="ln413">            return sign-&gt;se_lnum;</a>
<a name="ln414">        }</a>
<a name="ln415">    }</a>
<a name="ln416"> </a>
<a name="ln417">    return (linenr_T)0;</a>
<a name="ln418">}</a>
<a name="ln419"> </a>
<a name="ln420">/// Return the sign attrs which has the attribute specified by 'type'. Returns</a>
<a name="ln421">/// NULL if a sign is not found with the specified attribute.</a>
<a name="ln422">/// @param type Type of sign to look for</a>
<a name="ln423">/// @param sattrs Sign attrs to search through</a>
<a name="ln424">/// @param idx if there multiple signs, this index will pick the n-th</a>
<a name="ln425">///        out of the most `max_signs` sorted ascending by Id.</a>
<a name="ln426">/// @param max_signs the number of signs, with priority for the ones</a>
<a name="ln427">///        with the highest Ids.</a>
<a name="ln428">/// @return Attrs of the matching sign, or NULL</a>
<a name="ln429">sign_attrs_T * sign_get_attr(SignType type, sign_attrs_T sattrs[],</a>
<a name="ln430">                             int idx, int max_signs)</a>
<a name="ln431">{</a>
<a name="ln432">    sign_attrs_T *matches[SIGN_SHOW_MAX];</a>
<a name="ln433">    int nr_matches = 0;</a>
<a name="ln434"> </a>
<a name="ln435">    for (int i = 0; i &lt; SIGN_SHOW_MAX; i++) {</a>
<a name="ln436">        if (   (type == SIGN_TEXT   &amp;&amp; sattrs[i].sat_text   != NULL)</a>
<a name="ln437">            || (type == SIGN_LINEHL &amp;&amp; sattrs[i].sat_linehl != 0)</a>
<a name="ln438">            || (type == SIGN_NUMHL  &amp;&amp; sattrs[i].sat_numhl  != 0)) {</a>
<a name="ln439">            matches[nr_matches] = &amp;sattrs[i];</a>
<a name="ln440">            nr_matches++;</a>
<a name="ln441">            // attr list is sorted with most important (priority, id), thus we</a>
<a name="ln442">            // may stop as soon as we have max_signs matches</a>
<a name="ln443">            if (nr_matches &gt;= max_signs) {</a>
<a name="ln444">                break;</a>
<a name="ln445">            }</a>
<a name="ln446">        }</a>
<a name="ln447">    }</a>
<a name="ln448"> </a>
<a name="ln449">    if (nr_matches &gt; idx) {</a>
<a name="ln450">        return matches[nr_matches - idx - 1];</a>
<a name="ln451">    }</a>
<a name="ln452"> </a>
<a name="ln453">    return NULL;</a>
<a name="ln454">}</a>
<a name="ln455"> </a>
<a name="ln456">/// Lookup a sign by typenr. Returns NULL if sign is not found.</a>
<a name="ln457">static sign_T * find_sign_by_typenr(int typenr)</a>
<a name="ln458">{</a>
<a name="ln459">    sign_T *sp;</a>
<a name="ln460"> </a>
<a name="ln461">    for (sp = first_sign; sp != NULL; sp = sp-&gt;sn_next) {</a>
<a name="ln462">        if (sp-&gt;sn_typenr == typenr) {</a>
<a name="ln463">            return sp;</a>
<a name="ln464">        }</a>
<a name="ln465">    }</a>
<a name="ln466">    return NULL;</a>
<a name="ln467">}</a>
<a name="ln468"> </a>
<a name="ln469">/// Return the attributes of all the signs placed on line 'lnum' in buffer</a>
<a name="ln470">/// 'buf'. Used when refreshing the screen. Returns the number of signs.</a>
<a name="ln471">/// @param buf Buffer in which to search</a>
<a name="ln472">/// @param lnum Line in which to search</a>
<a name="ln473">/// @param sattrs Output array for attrs</a>
<a name="ln474">/// @return Number of signs of which attrs were found</a>
<a name="ln475">int buf_get_signattrs(buf_T *buf, linenr_T lnum, sign_attrs_T sattrs[])</a>
<a name="ln476">{</a>
<a name="ln477">    sign_entry_T *sign;</a>
<a name="ln478">    sign_T       *sp;</a>
<a name="ln479"> </a>
<a name="ln480">    int nr_matches = 0;</a>
<a name="ln481"> </a>
<a name="ln482">    FOR_ALL_SIGNS_IN_BUF(buf, sign) {</a>
<a name="ln483">        if (sign-&gt;se_lnum &gt; lnum) {</a>
<a name="ln484">            // Signs are sorted by line number in the buffer. No need to check</a>
<a name="ln485">            // for signs after the specified line number 'lnum'.</a>
<a name="ln486">            break;</a>
<a name="ln487">        }</a>
<a name="ln488"> </a>
<a name="ln489">        if (sign-&gt;se_lnum == lnum) {</a>
<a name="ln490">            sign_attrs_T sattr;</a>
<a name="ln491">            memset(&amp;sattr, 0, sizeof(sattr));</a>
<a name="ln492">            sattr.sat_typenr = sign-&gt;se_typenr;</a>
<a name="ln493">            sp = find_sign_by_typenr(sign-&gt;se_typenr);</a>
<a name="ln494">            if (sp != NULL) {</a>
<a name="ln495">                sattr.sat_text = sp-&gt;sn_text;</a>
<a name="ln496">                if (sattr.sat_text != NULL &amp;&amp; sp-&gt;sn_text_hl != 0) {</a>
<a name="ln497">                    sattr.sat_texthl = syn_id2attr(sp-&gt;sn_text_hl);</a>
<a name="ln498">                }</a>
<a name="ln499">                if (sp-&gt;sn_line_hl != 0) {</a>
<a name="ln500">                    sattr.sat_linehl = syn_id2attr(sp-&gt;sn_line_hl);</a>
<a name="ln501">                }</a>
<a name="ln502">                if (sp-&gt;sn_num_hl != 0) {</a>
<a name="ln503">                    sattr.sat_numhl = syn_id2attr(sp-&gt;sn_num_hl);</a>
<a name="ln504">                }</a>
<a name="ln505">            }</a>
<a name="ln506"> </a>
<a name="ln507">            sattrs[nr_matches] = sattr;</a>
<a name="ln508">            nr_matches++;</a>
<a name="ln509">            if (nr_matches == SIGN_SHOW_MAX) {</a>
<a name="ln510">                break;</a>
<a name="ln511">            }</a>
<a name="ln512">        }</a>
<a name="ln513">    }</a>
<a name="ln514">    return nr_matches;</a>
<a name="ln515">}</a>
<a name="ln516"> </a>
<a name="ln517">/// Delete sign 'id' in group 'group' from buffer 'buf'.</a>
<a name="ln518">/// If 'id' is zero, then delete all the signs in group 'group'. Otherwise</a>
<a name="ln519">/// delete only the specified sign.</a>
<a name="ln520">/// If 'group' is '*', then delete the sign in all the groups. If 'group' is</a>
<a name="ln521">/// NULL, then delete the sign in the global group. Otherwise delete the sign in</a>
<a name="ln522">/// the specified group.</a>
<a name="ln523">/// Returns the line number of the deleted sign. If multiple signs are deleted,</a>
<a name="ln524">/// then returns the line number of the last sign deleted.</a>
<a name="ln525">linenr_T buf_delsign(</a>
<a name="ln526">    buf_T *buf,         // buffer sign is stored in</a>
<a name="ln527">    linenr_T  atlnum,   // sign at this line, 0 - at any line</a>
<a name="ln528">    int id,             // sign id</a>
<a name="ln529">    char_u *group       // sign group</a>
<a name="ln530">)</a>
<a name="ln531">{</a>
<a name="ln532">  sign_entry_T **lastp;  // pointer to pointer to current sign</a>
<a name="ln533">  sign_entry_T *sign;    // a sign in a b_signlist</a>
<a name="ln534">  sign_entry_T *next;    // the next sign in a b_signlist</a>
<a name="ln535">  linenr_T lnum;       // line number whose sign was deleted</a>
<a name="ln536"> </a>
<a name="ln537">  buf-&gt;b_signcols_max = -1;</a>
<a name="ln538">  lastp = &amp;buf-&gt;b_signlist;</a>
<a name="ln539">  lnum = 0;</a>
<a name="ln540">  for (sign = buf-&gt;b_signlist; sign != NULL; sign = next) {</a>
<a name="ln541">    next = sign-&gt;se_next;</a>
<a name="ln542">    if ((id == 0 || sign-&gt;se_id == id)</a>
<a name="ln543">        &amp;&amp; (atlnum == 0 || sign-&gt;se_lnum == atlnum)</a>
<a name="ln544">        &amp;&amp; sign_in_group(sign, group)) {</a>
<a name="ln545">      *lastp = next;</a>
<a name="ln546">      if (next != NULL) {</a>
<a name="ln547">        next-&gt;se_prev = sign-&gt;se_prev;</a>
<a name="ln548">      }</a>
<a name="ln549">      lnum = sign-&gt;se_lnum;</a>
<a name="ln550">      if (sign-&gt;se_group != NULL) {</a>
<a name="ln551">        sign_group_unref(sign-&gt;se_group-&gt;sg_name);</a>
<a name="ln552">      }</a>
<a name="ln553">      xfree(sign);</a>
<a name="ln554">      redraw_buf_line_later(buf, lnum);</a>
<a name="ln555">      // Check whether only one sign needs to be deleted</a>
<a name="ln556">      // If deleting a sign with a specific identifier in a particular</a>
<a name="ln557">      // group or deleting any sign at a particular line number, delete</a>
<a name="ln558">      // only one sign.</a>
<a name="ln559">      if (group == NULL</a>
<a name="ln560">          || (*group != '*' &amp;&amp; id != 0)</a>
<a name="ln561">          || (*group == '*' &amp;&amp; atlnum != 0)) {</a>
<a name="ln562">        break;</a>
<a name="ln563">      }</a>
<a name="ln564">    } else {</a>
<a name="ln565">      lastp = &amp;sign-&gt;se_next;</a>
<a name="ln566">    }</a>
<a name="ln567">  }</a>
<a name="ln568"> </a>
<a name="ln569">  // When deleting the last sign the cursor position may change, because the</a>
<a name="ln570">  // sign columns no longer shows.  And the 'signcolumn' may be hidden.</a>
<a name="ln571">  if (buf-&gt;b_signlist == NULL) {</a>
<a name="ln572">    redraw_buf_later(buf, NOT_VALID);</a>
<a name="ln573">    changed_line_abv_curs();</a>
<a name="ln574">  }</a>
<a name="ln575"> </a>
<a name="ln576">  return lnum;</a>
<a name="ln577">}</a>
<a name="ln578"> </a>
<a name="ln579"> </a>
<a name="ln580">/// Find the line number of the sign with the requested id in group 'group'. If</a>
<a name="ln581">/// the sign does not exist, return 0 as the line number. This will still let</a>
<a name="ln582">/// the correct file get loaded.</a>
<a name="ln583">int buf_findsign(</a>
<a name="ln584">    buf_T *buf,     // buffer to store sign in</a>
<a name="ln585">    int id,         // sign ID</a>
<a name="ln586">    char_u *group   // sign group</a>
<a name="ln587">)</a>
<a name="ln588">{</a>
<a name="ln589">    sign_entry_T *sign;  // a sign in the signlist</a>
<a name="ln590"> </a>
<a name="ln591">    FOR_ALL_SIGNS_IN_BUF(buf, sign) {</a>
<a name="ln592">        if (sign-&gt;se_id == id &amp;&amp; sign_in_group(sign, group)) {</a>
<a name="ln593">            return (int)sign-&gt;se_lnum;</a>
<a name="ln594">        }</a>
<a name="ln595">    }</a>
<a name="ln596"> </a>
<a name="ln597">    return 0;</a>
<a name="ln598">}</a>
<a name="ln599"> </a>
<a name="ln600">/// Return the sign at line 'lnum' in buffer 'buf'. Returns NULL if a sign is</a>
<a name="ln601">/// not found at the line. If 'groupname' is NULL, searches in the global group.</a>
<a name="ln602">static sign_entry_T * buf_getsign_at_line(</a>
<a name="ln603">    buf_T *buf,        // buffer whose sign we are searching for</a>
<a name="ln604">    linenr_T lnum,     // line number of sign</a>
<a name="ln605">    char_u *groupname  // sign group name</a>
<a name="ln606">)</a>
<a name="ln607">{</a>
<a name="ln608">  sign_entry_T *sign;    // a sign in the signlist</a>
<a name="ln609"> </a>
<a name="ln610">  FOR_ALL_SIGNS_IN_BUF(buf, sign) {</a>
<a name="ln611">    if (sign-&gt;se_lnum &gt; lnum) {</a>
<a name="ln612">      // Signs are sorted by line number in the buffer. No need to check</a>
<a name="ln613">      // for signs after the specified line number 'lnum'.</a>
<a name="ln614">      break;</a>
<a name="ln615">    }</a>
<a name="ln616"> </a>
<a name="ln617">    if (sign-&gt;se_lnum == lnum &amp;&amp; sign_in_group(sign, groupname)) {</a>
<a name="ln618">      return sign;</a>
<a name="ln619">    }</a>
<a name="ln620">  }</a>
<a name="ln621"> </a>
<a name="ln622">  return NULL;</a>
<a name="ln623">}</a>
<a name="ln624"> </a>
<a name="ln625">/// Return the identifier of the sign at line number 'lnum' in buffer 'buf'.</a>
<a name="ln626">int buf_findsign_id(</a>
<a name="ln627">    buf_T *buf,         // buffer whose sign we are searching for</a>
<a name="ln628">    linenr_T lnum,      // line number of sign</a>
<a name="ln629">    char_u *groupname   // sign group name</a>
<a name="ln630">)</a>
<a name="ln631">{</a>
<a name="ln632">    sign_entry_T *sign;   // a sign in the signlist</a>
<a name="ln633"> </a>
<a name="ln634">    sign = buf_getsign_at_line(buf, lnum, groupname);</a>
<a name="ln635">    if (sign != NULL) {</a>
<a name="ln636">      return sign-&gt;se_id;</a>
<a name="ln637">    }</a>
<a name="ln638"> </a>
<a name="ln639">    return 0;</a>
<a name="ln640">}</a>
<a name="ln641"> </a>
<a name="ln642">/// Delete signs in buffer &quot;buf&quot;.</a>
<a name="ln643">void buf_delete_signs(buf_T *buf, char_u *group)</a>
<a name="ln644">{</a>
<a name="ln645">    sign_entry_T  *sign;</a>
<a name="ln646">    sign_entry_T **lastp;  // pointer to pointer to current sign</a>
<a name="ln647">    sign_entry_T  *next;</a>
<a name="ln648"> </a>
<a name="ln649">    // When deleting the last sign need to redraw the windows to remove the</a>
<a name="ln650">    // sign column. Not when curwin is NULL (this means we're exiting).</a>
<a name="ln651">    if (buf-&gt;b_signlist != NULL &amp;&amp; curwin != NULL) {</a>
<a name="ln652">      changed_line_abv_curs();</a>
<a name="ln653">    }</a>
<a name="ln654"> </a>
<a name="ln655">    lastp = &amp;buf-&gt;b_signlist;</a>
<a name="ln656">    for (sign = buf-&gt;b_signlist; sign != NULL; sign = next) {</a>
<a name="ln657">      next = sign-&gt;se_next;</a>
<a name="ln658">      if (sign_in_group(sign, group)) {</a>
<a name="ln659">        *lastp = next;</a>
<a name="ln660">        if (next != NULL) {</a>
<a name="ln661">          next-&gt;se_prev = sign-&gt;se_prev;</a>
<a name="ln662">        }</a>
<a name="ln663">        if (sign-&gt;se_group != NULL) {</a>
<a name="ln664">          sign_group_unref(sign-&gt;se_group-&gt;sg_name);</a>
<a name="ln665">        }</a>
<a name="ln666">        xfree(sign);</a>
<a name="ln667">      } else {</a>
<a name="ln668">        lastp = &amp;sign-&gt;se_next;</a>
<a name="ln669">      }</a>
<a name="ln670">    }</a>
<a name="ln671">    buf-&gt;b_signcols_max = -1;</a>
<a name="ln672">}</a>
<a name="ln673"> </a>
<a name="ln674">/// List placed signs for &quot;rbuf&quot;.  If &quot;rbuf&quot; is NULL do it for all buffers.</a>
<a name="ln675">void sign_list_placed(buf_T *rbuf, char_u *sign_group)</a>
<a name="ln676">{</a>
<a name="ln677">  buf_T *buf;</a>
<a name="ln678">  sign_entry_T  *sign;</a>
<a name="ln679">  char  lbuf[MSG_BUF_LEN];</a>
<a name="ln680">  char  group[MSG_BUF_LEN];</a>
<a name="ln681"> </a>
<a name="ln682">  MSG_PUTS_TITLE(_(&quot;\n--- Signs ---&quot;));</a>
<a name="ln683">  msg_putchar('\n');</a>
<a name="ln684">  if (rbuf == NULL) {</a>
<a name="ln685">    buf = firstbuf;</a>
<a name="ln686">  } else {</a>
<a name="ln687">    buf = rbuf;</a>
<a name="ln688">  }</a>
<a name="ln689">  while (buf != NULL &amp;&amp; !got_int) {</a>
<a name="ln690">    if (buf-&gt;b_signlist != NULL) {</a>
<a name="ln691">      vim_snprintf(lbuf, MSG_BUF_LEN, _(&quot;Signs for %s:&quot;), buf-&gt;b_fname);</a>
<a name="ln692">      MSG_PUTS_ATTR(lbuf, HL_ATTR(HLF_D));</a>
<a name="ln693">      msg_putchar('\n');</a>
<a name="ln694">    }</a>
<a name="ln695">    FOR_ALL_SIGNS_IN_BUF(buf, sign) {</a>
<a name="ln696">      if (got_int) {</a>
<a name="ln697">        break;</a>
<a name="ln698">      }</a>
<a name="ln699">      if (!sign_in_group(sign, sign_group)) {</a>
<a name="ln700">        continue;</a>
<a name="ln701">      }</a>
<a name="ln702">      if (sign-&gt;se_group != NULL) {</a>
<a name="ln703">        vim_snprintf(group, MSG_BUF_LEN, _(&quot;  group=%s&quot;),</a>
<a name="ln704">                     sign-&gt;se_group-&gt;sg_name);</a>
<a name="ln705">      } else {</a>
<a name="ln706">        group[0] = '\0';</a>
<a name="ln707">      }</a>
<a name="ln708">      vim_snprintf(lbuf, MSG_BUF_LEN,</a>
<a name="ln709">                   _(&quot;    line=%ld  id=%d%s  name=%s  priority=%d&quot;),</a>
<a name="ln710">                   (long)sign-&gt;se_lnum, sign-&gt;se_id, group,</a>
<a name="ln711">                   sign_typenr2name(sign-&gt;se_typenr), sign-&gt;se_priority);</a>
<a name="ln712">      MSG_PUTS(lbuf);</a>
<a name="ln713">      msg_putchar('\n');</a>
<a name="ln714">    }</a>
<a name="ln715">    if (rbuf != NULL) {</a>
<a name="ln716">      break;</a>
<a name="ln717">    }</a>
<a name="ln718">    buf = buf-&gt;b_next;</a>
<a name="ln719">  }</a>
<a name="ln720">}</a>
<a name="ln721"> </a>
<a name="ln722">/// Adjust a placed sign for inserted/deleted lines.</a>
<a name="ln723">void sign_mark_adjust(</a>
<a name="ln724">    linenr_T line1,</a>
<a name="ln725">    linenr_T line2,</a>
<a name="ln726">    long amount,</a>
<a name="ln727">    long amount_after</a>
<a name="ln728">)</a>
<a name="ln729">{</a>
<a name="ln730">  sign_entry_T *sign;           // a sign in a b_signlist</a>
<a name="ln731">  sign_entry_T *next;           // the next sign in a b_signlist</a>
<a name="ln732">  sign_entry_T *last = NULL;    // pointer to pointer to current sign</a>
<a name="ln733">  sign_entry_T **lastp = NULL;  // pointer to pointer to current sign</a>
<a name="ln734">  linenr_T new_lnum;            // new line number to assign to sign</a>
<a name="ln735">  int is_fixed = 0;</a>
<a name="ln736">  int signcol = win_signcol_configured(curwin, &amp;is_fixed);</a>
<a name="ln737"> </a>
<a name="ln738">  curbuf-&gt;b_signcols_max = -1;</a>
<a name="ln739">  lastp = &amp;curbuf-&gt;b_signlist;</a>
<a name="ln740"> </a>
<a name="ln741">  for (sign = curbuf-&gt;b_signlist; sign != NULL; sign = next) {</a>
<a name="ln742">    next = sign-&gt;se_next;</a>
<a name="ln743">    new_lnum = sign-&gt;se_lnum;</a>
<a name="ln744">    if (sign-&gt;se_lnum &gt;= line1 &amp;&amp; sign-&gt;se_lnum &lt;= line2) {</a>
<a name="ln745">      if (amount != MAXLNUM) {</a>
<a name="ln746">        new_lnum += amount;</a>
<a name="ln747">      } else if (!is_fixed || signcol &gt;= 2) {</a>
<a name="ln748">        *lastp = next;</a>
<a name="ln749">        if (next) {</a>
<a name="ln750">          next-&gt;se_prev = last;</a>
<a name="ln751">        }</a>
<a name="ln752">        xfree(sign);</a>
<a name="ln753">        continue;</a>
<a name="ln754">      }</a>
<a name="ln755">    } else if (sign-&gt;se_lnum &gt; line2) {</a>
<a name="ln756">      new_lnum += amount_after;</a>
<a name="ln757">    }</a>
<a name="ln758">    // If the new sign line number is past the last line in the buffer,</a>
<a name="ln759">    // then don't adjust the line number. Otherwise, it will always be past</a>
<a name="ln760">    // the last line and will not be visible.</a>
<a name="ln761">    if (sign-&gt;se_lnum &gt;= line1 &amp;&amp; new_lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln762">      sign-&gt;se_lnum = new_lnum;</a>
<a name="ln763">    }</a>
<a name="ln764"> </a>
<a name="ln765">    last = sign;</a>
<a name="ln766">    lastp = &amp;sign-&gt;se_next;</a>
<a name="ln767">  }</a>
<a name="ln768">}</a>
<a name="ln769"> </a>
<a name="ln770">/// Find index of a &quot;:sign&quot; subcmd from its name.</a>
<a name="ln771">/// &quot;*end_cmd&quot; must be writable.</a>
<a name="ln772">static int sign_cmd_idx(</a>
<a name="ln773">    char_u      *begin_cmd,     // begin of sign subcmd</a>
<a name="ln774">    char_u      *end_cmd        // just after sign subcmd</a>
<a name="ln775">)</a>
<a name="ln776">{</a>
<a name="ln777">    int  idx;</a>
<a name="ln778">    char_u save = *end_cmd;</a>
<a name="ln779"> </a>
<a name="ln780">    *end_cmd = (char_u)NUL;</a>
<a name="ln781">    for (idx = 0; ; idx++) {</a>
<a name="ln782">        if (cmds[idx] == NULL || STRCMP(begin_cmd, cmds[idx]) == 0) {</a>
<a name="ln783">            break;</a>
<a name="ln784">        }</a>
<a name="ln785">    }</a>
<a name="ln786">    *end_cmd = save;</a>
<a name="ln787">    return idx;</a>
<a name="ln788">}</a>
<a name="ln789"> </a>
<a name="ln790">/// Find a sign by name. Also returns pointer to the previous sign.</a>
<a name="ln791">static sign_T * sign_find(const char_u *name, sign_T **sp_prev)</a>
<a name="ln792">{</a>
<a name="ln793">  sign_T *sp;</a>
<a name="ln794"> </a>
<a name="ln795">  if (sp_prev != NULL) {</a>
<a name="ln796">    *sp_prev = NULL;</a>
<a name="ln797">  }</a>
<a name="ln798">  for (sp = first_sign; sp != NULL; sp = sp-&gt;sn_next) {</a>
<a name="ln799">    if (STRCMP(sp-&gt;sn_name, name) == 0) {</a>
<a name="ln800">      break;</a>
<a name="ln801">    }</a>
<a name="ln802">    if (sp_prev != NULL) {</a>
<a name="ln803">      *sp_prev = sp;</a>
<a name="ln804">    }</a>
<a name="ln805">  }</a>
<a name="ln806"> </a>
<a name="ln807">  return sp;</a>
<a name="ln808">}</a>
<a name="ln809"> </a>
<a name="ln810">/// Allocate a new sign</a>
<a name="ln811">static sign_T * alloc_new_sign(char_u *name)</a>
<a name="ln812">{</a>
<a name="ln813">  sign_T  *sp;</a>
<a name="ln814">  sign_T  *lp;</a>
<a name="ln815">  int start = next_sign_typenr;</a>
<a name="ln816"> </a>
<a name="ln817">  // Allocate a new sign.</a>
<a name="ln818">  sp = xcalloc(1, sizeof(sign_T));</a>
<a name="ln819"> </a>
<a name="ln820">  // Check that next_sign_typenr is not already being used.</a>
<a name="ln821">  // This only happens after wrapping around.  Hopefully</a>
<a name="ln822">  // another one got deleted and we can use its number.</a>
<a name="ln823">  for (lp = first_sign; lp != NULL; ) {</a>
<a name="ln824">    if (lp-&gt;sn_typenr == next_sign_typenr) {</a>
<a name="ln825">      next_sign_typenr++;</a>
<a name="ln826">      if (next_sign_typenr == MAX_TYPENR) {</a>
<a name="ln827">        next_sign_typenr = 1;</a>
<a name="ln828">      }</a>
<a name="ln829">      if (next_sign_typenr == start) {</a>
<a name="ln830">        xfree(sp);</a>
<a name="ln831">        EMSG(_(&quot;E612: Too many signs defined&quot;));</a>
<a name="ln832">        return NULL;</a>
<a name="ln833">      }</a>
<a name="ln834">      lp = first_sign;  // start all over</a>
<a name="ln835">      continue;</a>
<a name="ln836">    }</a>
<a name="ln837">    lp = lp-&gt;sn_next;</a>
<a name="ln838">  }</a>
<a name="ln839"> </a>
<a name="ln840">  sp-&gt;sn_typenr = next_sign_typenr;</a>
<a name="ln841">  if (++next_sign_typenr == MAX_TYPENR) {</a>
<a name="ln842">    next_sign_typenr = 1;  // wrap around</a>
<a name="ln843">  }</a>
<a name="ln844"> </a>
<a name="ln845">  sp-&gt;sn_name = vim_strsave(name);</a>
<a name="ln846"> </a>
<a name="ln847">  return sp;</a>
<a name="ln848">}</a>
<a name="ln849"> </a>
<a name="ln850">/// Initialize the icon information for a new sign</a>
<a name="ln851">static void sign_define_init_icon(sign_T *sp, char_u *icon)</a>
<a name="ln852">{</a>
<a name="ln853">  xfree(sp-&gt;sn_icon);</a>
<a name="ln854">  sp-&gt;sn_icon = vim_strsave(icon);</a>
<a name="ln855">  backslash_halve(sp-&gt;sn_icon);</a>
<a name="ln856">}</a>
<a name="ln857"> </a>
<a name="ln858">/// Initialize the text for a new sign</a>
<a name="ln859">static int sign_define_init_text(sign_T *sp, char_u *text)</a>
<a name="ln860">{</a>
<a name="ln861">  char_u  *s;</a>
<a name="ln862">  char_u  *endp;</a>
<a name="ln863">  int cells;</a>
<a name="ln864">  size_t len;</a>
<a name="ln865"> </a>
<a name="ln866">  endp = text + (int)STRLEN(text);</a>
<a name="ln867">  for (s = text; s + 1 &lt; endp; s++) {</a>
<a name="ln868">    if (*s == '\\') {</a>
<a name="ln869">      // Remove a backslash, so that it is possible</a>
<a name="ln870">      // to use a space.</a>
<a name="ln871">      STRMOVE(s, s + 1);</a>
<a name="ln872">      endp--;</a>
<a name="ln873">    }</a>
<a name="ln874">  }</a>
<a name="ln875">  // Count cells and check for non-printable chars</a>
<a name="ln876">  cells = 0;</a>
<a name="ln877">  for (s = text; s &lt; endp; s += (*mb_ptr2len)(s)) {</a>
<a name="ln878">    if (!vim_isprintc(utf_ptr2char(s))) {</a>
<a name="ln879">      break;</a>
<a name="ln880">    }</a>
<a name="ln881">    cells += utf_ptr2cells(s);</a>
<a name="ln882">  }</a>
<a name="ln883">  // Currently must be empty, one or two display cells</a>
<a name="ln884">  if (s != endp || cells &gt; 2) {</a>
<a name="ln885">    EMSG2(_(&quot;E239: Invalid sign text: %s&quot;), text);</a>
<a name="ln886">    return FAIL;</a>
<a name="ln887">  }</a>
<a name="ln888">  if (cells &lt; 1) {</a>
<a name="ln889">    sp-&gt;sn_text = NULL;</a>
<a name="ln890">    return OK;</a>
<a name="ln891">  }</a>
<a name="ln892"> </a>
<a name="ln893">  xfree(sp-&gt;sn_text);</a>
<a name="ln894">  // Allocate one byte more if we need to pad up</a>
<a name="ln895">  // with a space.</a>
<a name="ln896">  len = (size_t)(endp - text + ((cells == 1) ? 1 : 0));</a>
<a name="ln897">  sp-&gt;sn_text = vim_strnsave(text, len);</a>
<a name="ln898"> </a>
<a name="ln899">  if (cells == 1) {</a>
<a name="ln900">    STRCPY(sp-&gt;sn_text + len - 1, &quot; &quot;);</a>
<a name="ln901">  }</a>
<a name="ln902"> </a>
<a name="ln903">  return OK;</a>
<a name="ln904">}</a>
<a name="ln905"> </a>
<a name="ln906">/// Define a new sign or update an existing sign</a>
<a name="ln907">int sign_define_by_name(</a>
<a name="ln908">    char_u *name,</a>
<a name="ln909">    char_u *icon,</a>
<a name="ln910">    char_u *linehl,</a>
<a name="ln911">    char_u *text,</a>
<a name="ln912">    char_u *texthl,</a>
<a name="ln913">    char_u *numhl</a>
<a name="ln914">)</a>
<a name="ln915">{</a>
<a name="ln916">  sign_T  *sp_prev;</a>
<a name="ln917">  sign_T  *sp;</a>
<a name="ln918"> </a>
<a name="ln919">  sp = sign_find(name, &amp;sp_prev);</a>
<a name="ln920">  if (sp == NULL) {</a>
<a name="ln921">    sp = alloc_new_sign(name);</a>
<a name="ln922">    if (sp == NULL) {</a>
<a name="ln923">      return FAIL;</a>
<a name="ln924">    }</a>
<a name="ln925"> </a>
<a name="ln926">    // add the new sign to the list of signs</a>
<a name="ln927">    if (sp_prev == NULL) {</a>
<a name="ln928">      first_sign = sp;</a>
<a name="ln929">    } else {</a>
<a name="ln930">      sp_prev-&gt;sn_next = sp;</a>
<a name="ln931">    }</a>
<a name="ln932">  } else {</a>
<a name="ln933">    // Signs may already exist, a redraw is needed in windows with a</a>
<a name="ln934">    // non-empty sign list.</a>
<a name="ln935">    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln936">      if (wp-&gt;w_buffer-&gt;b_signlist != NULL) {</a>
<a name="ln937">        redraw_buf_later(wp-&gt;w_buffer, NOT_VALID);</a>
<a name="ln938">      }</a>
<a name="ln939">    }</a>
<a name="ln940">  }</a>
<a name="ln941"> </a>
<a name="ln942">  // set values for a defined sign.</a>
<a name="ln943">  if (icon != NULL) {</a>
<a name="ln944">    sign_define_init_icon(sp, icon);</a>
<a name="ln945">  }</a>
<a name="ln946"> </a>
<a name="ln947">  if (text != NULL &amp;&amp; (sign_define_init_text(sp, text) == FAIL)) {</a>
<a name="ln948">    return FAIL;</a>
<a name="ln949">  }</a>
<a name="ln950"> </a>
<a name="ln951">  if (linehl != NULL) {</a>
<a name="ln952">    sp-&gt;sn_line_hl = syn_check_group(linehl, (int)STRLEN(linehl));</a>
<a name="ln953">  }</a>
<a name="ln954"> </a>
<a name="ln955">  if (texthl != NULL) {</a>
<a name="ln956">    sp-&gt;sn_text_hl = syn_check_group(texthl, (int)STRLEN(texthl));</a>
<a name="ln957">  }</a>
<a name="ln958"> </a>
<a name="ln959">  if (numhl != NULL) {</a>
<a name="ln960">    sp-&gt;sn_num_hl = syn_check_group(numhl, (int)STRLEN(numhl));</a>
<a name="ln961">  }</a>
<a name="ln962"> </a>
<a name="ln963">  return OK;</a>
<a name="ln964">}</a>
<a name="ln965"> </a>
<a name="ln966">/// Free the sign specified by 'name'.</a>
<a name="ln967">int sign_undefine_by_name(const char_u *name)</a>
<a name="ln968">{</a>
<a name="ln969">  sign_T  *sp_prev;</a>
<a name="ln970">  sign_T  *sp;</a>
<a name="ln971"> </a>
<a name="ln972">  sp = sign_find(name, &amp;sp_prev);</a>
<a name="ln973">  if (sp == NULL) {</a>
<a name="ln974">    EMSG2(_(&quot;E155: Unknown sign: %s&quot;), name);</a>
<a name="ln975">    return FAIL;</a>
<a name="ln976">  }</a>
<a name="ln977">  sign_undefine(sp, sp_prev);</a>
<a name="ln978"> </a>
<a name="ln979">  return OK;</a>
<a name="ln980">}</a>
<a name="ln981"> </a>
<a name="ln982">static void may_force_numberwidth_recompute(buf_T *buf, int unplace)</a>
<a name="ln983">{</a>
<a name="ln984">  FOR_ALL_TAB_WINDOWS(tp, wp)</a>
<a name="ln985">    if (wp-&gt;w_buffer == buf</a>
<a name="ln986">        &amp;&amp; (wp-&gt;w_p_nu || wp-&gt;w_p_rnu)</a>
<a name="ln987">        &amp;&amp; (unplace || wp-&gt;w_nrwidth_width &lt; 2)</a>
<a name="ln988">        &amp;&amp; (*wp-&gt;w_p_scl == 'n' &amp;&amp; *(wp-&gt;w_p_scl + 1) == 'u')) {</a>
<a name="ln989">      wp-&gt;w_nrwidth_line_count = 0;</a>
<a name="ln990">    }</a>
<a name="ln991">}</a>
<a name="ln992"> </a>
<a name="ln993">/// List the signs matching 'name'</a>
<a name="ln994">static void sign_list_by_name(char_u *name)</a>
<a name="ln995">{</a>
<a name="ln996">  sign_T  *sp;</a>
<a name="ln997"> </a>
<a name="ln998">  sp = sign_find(name, NULL);</a>
<a name="ln999">  if (sp != NULL) {</a>
<a name="ln1000">    sign_list_defined(sp);</a>
<a name="ln1001">  } else {</a>
<a name="ln1002">    EMSG2(_(&quot;E155: Unknown sign: %s&quot;), name);</a>
<a name="ln1003">  }</a>
<a name="ln1004">}</a>
<a name="ln1005"> </a>
<a name="ln1006"> </a>
<a name="ln1007">/// Place a sign at the specified file location or update a sign.</a>
<a name="ln1008">int sign_place(</a>
<a name="ln1009">    int *sign_id,</a>
<a name="ln1010">    const char_u *sign_group,</a>
<a name="ln1011">    const char_u *sign_name,</a>
<a name="ln1012">    buf_T *buf,</a>
<a name="ln1013">    linenr_T lnum,</a>
<a name="ln1014">    int prio</a>
<a name="ln1015">)</a>
<a name="ln1016">{</a>
<a name="ln1017">  sign_T *sp;</a>
<a name="ln1018"> </a>
<a name="ln1019">  // Check for reserved character '*' in group name</a>
<a name="ln1020">  if (sign_group != NULL &amp;&amp; (*sign_group == '*' || *sign_group == '\0')) {</a>
<a name="ln1021">    return FAIL;</a>
<a name="ln1022">  }</a>
<a name="ln1023"> </a>
<a name="ln1024">  for (sp = first_sign; sp != NULL; sp = sp-&gt;sn_next) {</a>
<a name="ln1025">    if (STRCMP(sp-&gt;sn_name, sign_name) == 0) {</a>
<a name="ln1026">      break;</a>
<a name="ln1027">    }</a>
<a name="ln1028">  }</a>
<a name="ln1029">  if (sp == NULL) {</a>
<a name="ln1030">    EMSG2(_(&quot;E155: Unknown sign: %s&quot;), sign_name);</a>
<a name="ln1031">    return FAIL;</a>
<a name="ln1032">  }</a>
<a name="ln1033">  if (*sign_id == 0) {</a>
<a name="ln1034">    *sign_id = sign_group_get_next_signid(buf, sign_group);</a>
<a name="ln1035">  }</a>
<a name="ln1036"> </a>
<a name="ln1037">  if (lnum &gt; 0) {</a>
<a name="ln1038">    // &quot;:sign place {id} line={lnum} name={name} file={fname}&quot;:</a>
<a name="ln1039">    // place a sign</a>
<a name="ln1040">    bool has_text_or_icon = sp-&gt;sn_text != NULL || sp-&gt;sn_icon != NULL;</a>
<a name="ln1041">    buf_addsign(</a>
<a name="ln1042">        buf,</a>
<a name="ln1043">        *sign_id,</a>
<a name="ln1044">        sign_group,</a>
<a name="ln1045">        prio,</a>
<a name="ln1046">        lnum,</a>
<a name="ln1047">        sp-&gt;sn_typenr,</a>
<a name="ln1048">        has_text_or_icon);</a>
<a name="ln1049">  } else {</a>
<a name="ln1050">    // &quot;:sign place {id} file={fname}&quot;: change sign type and/or priority</a>
<a name="ln1051">    lnum = buf_change_sign_type(buf, *sign_id, sign_group, sp-&gt;sn_typenr, prio);</a>
<a name="ln1052">  }</a>
<a name="ln1053">  if (lnum &gt; 0) {</a>
<a name="ln1054">    redraw_buf_line_later(buf, lnum);</a>
<a name="ln1055"> </a>
<a name="ln1056">    // When displaying signs in the 'number' column, if the width of the</a>
<a name="ln1057">    // number column is less than 2, then force recomputing the width.</a>
<a name="ln1058">    may_force_numberwidth_recompute(buf, false);</a>
<a name="ln1059">  } else {</a>
<a name="ln1060">    EMSG2(_(&quot;E885: Not possible to change sign %s&quot;), sign_name);</a>
<a name="ln1061">    return FAIL;</a>
<a name="ln1062">  }</a>
<a name="ln1063"> </a>
<a name="ln1064">  return OK;</a>
<a name="ln1065">}</a>
<a name="ln1066"> </a>
<a name="ln1067">/// Unplace the specified sign</a>
<a name="ln1068">int sign_unplace(int sign_id, char_u *sign_group, buf_T *buf, linenr_T atlnum)</a>
<a name="ln1069">{</a>
<a name="ln1070">  if (buf-&gt;b_signlist == NULL) {  // No signs in the buffer</a>
<a name="ln1071">    return OK;</a>
<a name="ln1072">  }</a>
<a name="ln1073">  if (sign_id == 0) {</a>
<a name="ln1074">    // Delete all the signs in the specified buffer</a>
<a name="ln1075">    redraw_buf_later(buf, NOT_VALID);</a>
<a name="ln1076">    buf_delete_signs(buf, sign_group);</a>
<a name="ln1077">  } else {</a>
<a name="ln1078">    linenr_T  lnum;</a>
<a name="ln1079"> </a>
<a name="ln1080">    // Delete only the specified signs</a>
<a name="ln1081">    lnum = buf_delsign(buf, atlnum, sign_id, sign_group);</a>
<a name="ln1082">    if (lnum == 0) {</a>
<a name="ln1083">      return FAIL;</a>
<a name="ln1084">    }</a>
<a name="ln1085">    redraw_buf_line_later(buf, lnum);</a>
<a name="ln1086">  }</a>
<a name="ln1087"> </a>
<a name="ln1088">  // When all the signs in a buffer are removed, force recomputing the</a>
<a name="ln1089">  // number column width (if enabled) in all the windows displaying the</a>
<a name="ln1090">  // buffer if 'signcolumn' is set to 'number' in that window.</a>
<a name="ln1091">  if (buf-&gt;b_signlist == NULL) {</a>
<a name="ln1092">    may_force_numberwidth_recompute(buf, true);</a>
<a name="ln1093">  }</a>
<a name="ln1094"> </a>
<a name="ln1095">  return OK;</a>
<a name="ln1096">}</a>
<a name="ln1097"> </a>
<a name="ln1098">/// Unplace the sign at the current cursor line.</a>
<a name="ln1099">static void sign_unplace_at_cursor(char_u *groupname)</a>
<a name="ln1100">{</a>
<a name="ln1101">  int   id = -1;</a>
<a name="ln1102"> </a>
<a name="ln1103">  id = buf_findsign_id(curwin-&gt;w_buffer, curwin-&gt;w_cursor.lnum, groupname);</a>
<a name="ln1104">  if (id &gt; 0) {</a>
<a name="ln1105">    sign_unplace(id, groupname, curwin-&gt;w_buffer, curwin-&gt;w_cursor.lnum);</a>
<a name="ln1106">  } else {</a>
<a name="ln1107">    EMSG(_(&quot;E159: Missing sign number&quot;));</a>
<a name="ln1108">  }</a>
<a name="ln1109">}</a>
<a name="ln1110"> </a>
<a name="ln1111">/// Jump to a sign.</a>
<a name="ln1112">linenr_T sign_jump(int sign_id, char_u *sign_group, buf_T *buf)</a>
<a name="ln1113">{</a>
<a name="ln1114">  linenr_T lnum;</a>
<a name="ln1115"> </a>
<a name="ln1116">  if ((lnum = buf_findsign(buf, sign_id, sign_group)) &lt;= 0) {</a>
<a name="ln1117">    EMSGN(_(&quot;E157: Invalid sign ID: %&quot; PRId64), sign_id);</a>
<a name="ln1118">    return -1;</a>
<a name="ln1119">  }</a>
<a name="ln1120"> </a>
<a name="ln1121">  // goto a sign ...</a>
<a name="ln1122">  if (buf_jump_open_win(buf) != NULL) {     // ... in a current window</a>
<a name="ln1123">    curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln1124">    check_cursor_lnum();</a>
<a name="ln1125">    beginline(BL_WHITE);</a>
<a name="ln1126">  } else {      // ... not currently in a window</a>
<a name="ln1127">    if (buf-&gt;b_fname == NULL) {</a>
<a name="ln1128">      EMSG(_(&quot;E934: Cannot jump to a buffer that does not have a name&quot;));</a>
<a name="ln1129">      return -1;</a>
<a name="ln1130">    }</a>
<a name="ln1131">    size_t cmdlen = STRLEN(buf-&gt;b_fname) + 24;</a>
<a name="ln1132">    char *cmd = xmallocz(cmdlen);</a>
<a name="ln1133">    snprintf(cmd, cmdlen, &quot;e +%&quot; PRId64 &quot; %s&quot;,</a>
<a name="ln1134">             (int64_t)lnum, buf-&gt;b_fname);</a>
<a name="ln1135">    do_cmdline_cmd(cmd);</a>
<a name="ln1136">    xfree(cmd);</a>
<a name="ln1137">  }</a>
<a name="ln1138"> </a>
<a name="ln1139">  foldOpenCursor();</a>
<a name="ln1140"> </a>
<a name="ln1141">  return lnum;</a>
<a name="ln1142">}</a>
<a name="ln1143"> </a>
<a name="ln1144">/// &quot;:sign define {name} ...&quot; command</a>
<a name="ln1145">static void sign_define_cmd(char_u *sign_name, char_u *cmdline)</a>
<a name="ln1146">{</a>
<a name="ln1147">  char_u  *arg;</a>
<a name="ln1148">  char_u  *p = cmdline;</a>
<a name="ln1149">  char_u  *icon = NULL;</a>
<a name="ln1150">  char_u  *text = NULL;</a>
<a name="ln1151">  char_u  *linehl = NULL;</a>
<a name="ln1152">  char_u  *texthl = NULL;</a>
<a name="ln1153">  char_u  *numhl = NULL;</a>
<a name="ln1154">  int failed = false;</a>
<a name="ln1155"> </a>
<a name="ln1156">  // set values for a defined sign.</a>
<a name="ln1157">  for (;;) {</a>
<a name="ln1158">    arg = skipwhite(p);</a>
<a name="ln1159">    if (*arg == NUL) {</a>
<a name="ln1160">      break;</a>
<a name="ln1161">    }</a>
<a name="ln1162">    p = skiptowhite_esc(arg);</a>
<a name="ln1163">    if (STRNCMP(arg, &quot;icon=&quot;, 5) == 0) {</a>
<a name="ln1164">      arg += 5;</a>
<a name="ln1165">      icon = vim_strnsave(arg, (size_t)(p - arg));</a>
<a name="ln1166">    } else if (STRNCMP(arg, &quot;text=&quot;, 5) == 0) {</a>
<a name="ln1167">      arg += 5;</a>
<a name="ln1168">      text = vim_strnsave(arg, (size_t)(p - arg));</a>
<a name="ln1169">    } else if (STRNCMP(arg, &quot;linehl=&quot;, 7) == 0) {</a>
<a name="ln1170">      arg += 7;</a>
<a name="ln1171">      linehl = vim_strnsave(arg, (size_t)(p - arg));</a>
<a name="ln1172">    } else if (STRNCMP(arg, &quot;texthl=&quot;, 7) == 0) {</a>
<a name="ln1173">      arg += 7;</a>
<a name="ln1174">      texthl = vim_strnsave(arg, (size_t)(p - arg));</a>
<a name="ln1175">    } else if (STRNCMP(arg, &quot;numhl=&quot;, 6) == 0) {</a>
<a name="ln1176">      arg += 6;</a>
<a name="ln1177">      numhl = vim_strnsave(arg, (size_t)(p - arg));</a>
<a name="ln1178">    } else {</a>
<a name="ln1179">      EMSG2(_(e_invarg2), arg);</a>
<a name="ln1180">      failed = true;</a>
<a name="ln1181">      break;</a>
<a name="ln1182">    }</a>
<a name="ln1183">  }</a>
<a name="ln1184"> </a>
<a name="ln1185">  if (!failed) {</a>
<a name="ln1186">    sign_define_by_name(sign_name, icon, linehl, text, texthl, numhl);</a>
<a name="ln1187">  }</a>
<a name="ln1188"> </a>
<a name="ln1189">  xfree(icon);</a>
<a name="ln1190">  xfree(text);</a>
<a name="ln1191">  xfree(linehl);</a>
<a name="ln1192">  xfree(texthl);</a>
<a name="ln1193">  xfree(numhl);</a>
<a name="ln1194">}</a>
<a name="ln1195"> </a>
<a name="ln1196">/// &quot;:sign place&quot; command</a>
<a name="ln1197">static void sign_place_cmd(</a>
<a name="ln1198">    buf_T   *buf,</a>
<a name="ln1199">    linenr_T  lnum,</a>
<a name="ln1200">    char_u    *sign_name,</a>
<a name="ln1201">    int   id,</a>
<a name="ln1202">    char_u    *group,</a>
<a name="ln1203">    int   prio</a>
<a name="ln1204">)</a>
<a name="ln1205">{</a>
<a name="ln1206">  if (id &lt;= 0) {</a>
<a name="ln1207">    // List signs placed in a file/buffer</a>
<a name="ln1208">    //   :sign place file={fname}</a>
<a name="ln1209">    //   :sign place group={group} file={fname}</a>
<a name="ln1210">    //   :sign place group=* file={fname}</a>
<a name="ln1211">    //   :sign place buffer={nr}</a>
<a name="ln1212">    //   :sign place group={group} buffer={nr}</a>
<a name="ln1213">    //   :sign place group=* buffer={nr}</a>
<a name="ln1214">    //   :sign place</a>
<a name="ln1215">    //   :sign place group={group}</a>
<a name="ln1216">    //   :sign place group=*</a>
<a name="ln1217">    if (lnum &gt;= 0 || sign_name != NULL</a>
<a name="ln1218">        || (group != NULL &amp;&amp; *group == '\0')) {</a>
<a name="ln1219">      EMSG(_(e_invarg));</a>
<a name="ln1220">    } else {</a>
<a name="ln1221">      sign_list_placed(buf, group);</a>
<a name="ln1222">    }</a>
<a name="ln1223">  } else {</a>
<a name="ln1224">    // Place a new sign</a>
<a name="ln1225">    if (sign_name == NULL || buf == NULL</a>
<a name="ln1226">        || (group != NULL &amp;&amp; *group == '\0')) {</a>
<a name="ln1227">      EMSG(_(e_invarg));</a>
<a name="ln1228">      return;</a>
<a name="ln1229">    }</a>
<a name="ln1230"> </a>
<a name="ln1231">    sign_place(&amp;id, group, sign_name, buf, lnum, prio);</a>
<a name="ln1232">  }</a>
<a name="ln1233">}</a>
<a name="ln1234"> </a>
<a name="ln1235">/// &quot;:sign unplace&quot; command</a>
<a name="ln1236">static void sign_unplace_cmd(</a>
<a name="ln1237">    buf_T   *buf,</a>
<a name="ln1238">    linenr_T  lnum,</a>
<a name="ln1239">    char_u    *sign_name,</a>
<a name="ln1240">    int   id,</a>
<a name="ln1241">    char_u    *group</a>
<a name="ln1242">)</a>
<a name="ln1243">{</a>
<a name="ln1244">    if (lnum &gt;= 0 || sign_name != NULL || (group != NULL &amp;&amp; *group == '\0')) {</a>
<a name="ln1245">      EMSG(_(e_invarg));</a>
<a name="ln1246">      return;</a>
<a name="ln1247">    }</a>
<a name="ln1248"> </a>
<a name="ln1249">    if (id == -2) {</a>
<a name="ln1250">      if (buf != NULL) {</a>
<a name="ln1251">        // :sign unplace * file={fname}</a>
<a name="ln1252">        // :sign unplace * group={group} file={fname}</a>
<a name="ln1253">        // :sign unplace * group=* file={fname}</a>
<a name="ln1254">        // :sign unplace * buffer={nr}</a>
<a name="ln1255">        // :sign unplace * group={group} buffer={nr}</a>
<a name="ln1256">        // :sign unplace * group=* buffer={nr}</a>
<a name="ln1257">        sign_unplace(0, group, buf, 0);</a>
<a name="ln1258">      } else {</a>
<a name="ln1259">        // :sign unplace *</a>
<a name="ln1260">        // :sign unplace * group={group}</a>
<a name="ln1261">        // :sign unplace * group=*</a>
<a name="ln1262">        FOR_ALL_BUFFERS(cbuf) {</a>
<a name="ln1263">          if (cbuf-&gt;b_signlist != NULL) {</a>
<a name="ln1264">            buf_delete_signs(cbuf, group);</a>
<a name="ln1265">          }</a>
<a name="ln1266">        }</a>
<a name="ln1267">      }</a>
<a name="ln1268">    } else {</a>
<a name="ln1269">      if (buf != NULL) {</a>
<a name="ln1270">        // :sign unplace {id} file={fname}</a>
<a name="ln1271">        // :sign unplace {id} group={group} file={fname}</a>
<a name="ln1272">        // :sign unplace {id} group=* file={fname}</a>
<a name="ln1273">        // :sign unplace {id} buffer={nr}</a>
<a name="ln1274">        // :sign unplace {id} group={group} buffer={nr}</a>
<a name="ln1275">        // :sign unplace {id} group=* buffer={nr}</a>
<a name="ln1276">        sign_unplace(id, group, buf, 0);</a>
<a name="ln1277">      } else {</a>
<a name="ln1278">        if (id == -1) {</a>
<a name="ln1279">          // :sign unplace group={group}</a>
<a name="ln1280">          // :sign unplace group=*</a>
<a name="ln1281">          sign_unplace_at_cursor(group);</a>
<a name="ln1282">        } else {</a>
<a name="ln1283">          // :sign unplace {id}</a>
<a name="ln1284">          // :sign unplace {id} group={group}</a>
<a name="ln1285">          // :sign unplace {id} group=*</a>
<a name="ln1286">          FOR_ALL_BUFFERS(cbuf) {</a>
<a name="ln1287">            sign_unplace(id, group, cbuf, 0);</a>
<a name="ln1288">          }</a>
<a name="ln1289">        }</a>
<a name="ln1290">      }</a>
<a name="ln1291">    }</a>
<a name="ln1292">}</a>
<a name="ln1293"> </a>
<a name="ln1294">/// Jump to a placed sign commands:</a>
<a name="ln1295">///   :sign jump {id} file={fname}</a>
<a name="ln1296">///   :sign jump {id} buffer={nr}</a>
<a name="ln1297">///   :sign jump {id} group={group} file={fname}</a>
<a name="ln1298">///   :sign jump {id} group={group} buffer={nr}</a>
<a name="ln1299">static void sign_jump_cmd(</a>
<a name="ln1300">    buf_T   *buf,</a>
<a name="ln1301">    linenr_T  lnum,</a>
<a name="ln1302">    char_u    *sign_name,</a>
<a name="ln1303">    int   id,</a>
<a name="ln1304">    char_u    *group</a>
<a name="ln1305">)</a>
<a name="ln1306">{</a>
<a name="ln1307">  if (sign_name == NULL &amp;&amp; group == NULL &amp;&amp; id == -1) {</a>
<a name="ln1308">    EMSG(_(e_argreq));</a>
<a name="ln1309">    return;</a>
<a name="ln1310">  }</a>
<a name="ln1311"> </a>
<a name="ln1312">  if (buf == NULL || (group != NULL &amp;&amp; *group == '\0')</a>
<a name="ln1313">      || lnum &gt;= 0 || sign_name != NULL) {</a>
<a name="ln1314">    // File or buffer is not specified or an empty group is used</a>
<a name="ln1315">    // or a line number or a sign name is specified.</a>
<a name="ln1316">    EMSG(_(e_invarg));</a>
<a name="ln1317">    return;</a>
<a name="ln1318">  }</a>
<a name="ln1319"> </a>
<a name="ln1320">  (void)sign_jump(id, group, buf);</a>
<a name="ln1321">}</a>
<a name="ln1322"> </a>
<a name="ln1323">/// Parse the command line arguments for the &quot;:sign place&quot;, &quot;:sign unplace&quot; and</a>
<a name="ln1324">/// &quot;:sign jump&quot; commands.</a>
<a name="ln1325">/// The supported arguments are: line={lnum} name={name} group={group}</a>
<a name="ln1326">/// priority={prio} and file={fname} or buffer={nr}.</a>
<a name="ln1327">static int parse_sign_cmd_args(</a>
<a name="ln1328">    int     cmd,</a>
<a name="ln1329">    char_u      *arg,</a>
<a name="ln1330">    char_u      **sign_name,</a>
<a name="ln1331">    int     *signid,</a>
<a name="ln1332">    char_u      **group,</a>
<a name="ln1333">    int     *prio,</a>
<a name="ln1334">    buf_T     **buf,</a>
<a name="ln1335">    linenr_T    *lnum</a>
<a name="ln1336">)</a>
<a name="ln1337">{</a>
<a name="ln1338">  char_u  *arg1;</a>
<a name="ln1339">  char_u  *name;</a>
<a name="ln1340">  char_u  *filename = NULL;</a>
<a name="ln1341">  int   lnum_arg = false;</a>
<a name="ln1342"> </a>
<a name="ln1343">  // first arg could be placed sign id</a>
<a name="ln1344">  arg1 = arg;</a>
<a name="ln1345">  if (ascii_isdigit(*arg)) {</a>
<a name="ln1346">    *signid = getdigits_int(&amp;arg, true, 0);</a>
<a name="ln1347">    if (!ascii_iswhite(*arg) &amp;&amp; *arg != NUL) {</a>
<a name="ln1348">      *signid = -1;</a>
<a name="ln1349">      arg = arg1;</a>
<a name="ln1350">    } else {</a>
<a name="ln1351">      arg = skipwhite(arg);</a>
<a name="ln1352">    }</a>
<a name="ln1353">  }</a>
<a name="ln1354"> </a>
<a name="ln1355">  while (*arg != NUL) {</a>
<a name="ln1356">    if (STRNCMP(arg, &quot;line=&quot;, 5) == 0) {</a>
<a name="ln1357">      arg += 5;</a>
<a name="ln1358">      *lnum = atoi((char *)arg);</a>
<a name="ln1359">      arg = skiptowhite(arg);</a>
<a name="ln1360">      lnum_arg = true;</a>
<a name="ln1361">    } else if (STRNCMP(arg, &quot;*&quot;, 1) == 0 &amp;&amp; cmd == SIGNCMD_UNPLACE) {</a>
<a name="ln1362">      if (*signid != -1) {</a>
<a name="ln1363">        EMSG(_(e_invarg));</a>
<a name="ln1364">        return FAIL;</a>
<a name="ln1365">      }</a>
<a name="ln1366">      *signid = -2;</a>
<a name="ln1367">      arg = skiptowhite(arg + 1);</a>
<a name="ln1368">    } else if (STRNCMP(arg, &quot;name=&quot;, 5) == 0) {</a>
<a name="ln1369">      arg += 5;</a>
<a name="ln1370">      name = arg;</a>
<a name="ln1371">      arg = skiptowhite(arg);</a>
<a name="ln1372">      if (*arg != NUL) {</a>
<a name="ln1373">        *arg++ = NUL;</a>
<a name="ln1374">      }</a>
<a name="ln1375">      while (name[0] == '0' &amp;&amp; name[1] != NUL) {</a>
<a name="ln1376">        name++;</a>
<a name="ln1377">      }</a>
<a name="ln1378">      *sign_name = name;</a>
<a name="ln1379">    } else if (STRNCMP(arg, &quot;group=&quot;, 6) == 0) {</a>
<a name="ln1380">      arg += 6;</a>
<a name="ln1381">      *group = arg;</a>
<a name="ln1382">      arg = skiptowhite(arg);</a>
<a name="ln1383">      if (*arg != NUL) {</a>
<a name="ln1384">        *arg++ = NUL;</a>
<a name="ln1385">      }</a>
<a name="ln1386">    } else if (STRNCMP(arg, &quot;priority=&quot;, 9) == 0) {</a>
<a name="ln1387">      arg += 9;</a>
<a name="ln1388">      *prio = atoi((char *)arg);</a>
<a name="ln1389">      arg = skiptowhite(arg);</a>
<a name="ln1390">    } else if (STRNCMP(arg, &quot;file=&quot;, 5) == 0) {</a>
<a name="ln1391">      arg += 5;</a>
<a name="ln1392">      filename = arg;</a>
<a name="ln1393">      *buf = buflist_findname_exp(arg);</a>
<a name="ln1394">      break;</a>
<a name="ln1395">    } else if (STRNCMP(arg, &quot;buffer=&quot;, 7) == 0) {</a>
<a name="ln1396">      arg += 7;</a>
<a name="ln1397">      filename = arg;</a>
<a name="ln1398">      *buf = buflist_findnr(getdigits_int(&amp;arg, true, 0));</a>
<a name="ln1399">      if (*skipwhite(arg) != NUL) {</a>
<a name="ln1400">        EMSG(_(e_trailing));</a>
<a name="ln1401">      }</a>
<a name="ln1402">      break;</a>
<a name="ln1403">    } else {</a>
<a name="ln1404">      EMSG(_(e_invarg));</a>
<a name="ln1405">      return FAIL;</a>
<a name="ln1406">    }</a>
<a name="ln1407">    arg = skipwhite(arg);</a>
<a name="ln1408">  }</a>
<a name="ln1409"> </a>
<a name="ln1410">  if (filename != NULL &amp;&amp; *buf == NULL) {</a>
<a name="ln1411">    EMSG2(_(&quot;E158: Invalid buffer name: %s&quot;), filename);</a>
<a name="ln1412">    return FAIL;</a>
<a name="ln1413">  }</a>
<a name="ln1414"> </a>
<a name="ln1415">  // If the filename is not supplied for the sign place or the sign jump</a>
<a name="ln1416">  // command, then use the current buffer.</a>
<a name="ln1417">  if (filename == NULL &amp;&amp; ((cmd == SIGNCMD_PLACE &amp;&amp; lnum_arg)</a>
<a name="ln1418">                           || cmd == SIGNCMD_JUMP)) {</a>
<a name="ln1419">    *buf = curwin-&gt;w_buffer;</a>
<a name="ln1420">  }</a>
<a name="ln1421">  return OK;</a>
<a name="ln1422">}</a>
<a name="ln1423"> </a>
<a name="ln1424">/// &quot;:sign&quot; command</a>
<a name="ln1425">void ex_sign(exarg_T *eap)</a>
<a name="ln1426">{</a>
<a name="ln1427">  char_u *arg = eap-&gt;arg;</a>
<a name="ln1428">  char_u *p;</a>
<a name="ln1429">  int idx;</a>
<a name="ln1430">  sign_T *sp;</a>
<a name="ln1431"> </a>
<a name="ln1432">  // Parse the subcommand.</a>
<a name="ln1433">  p = skiptowhite(arg);</a>
<a name="ln1434">  idx = sign_cmd_idx(arg, p);</a>
<a name="ln1435">  if (idx == SIGNCMD_LAST) {</a>
<a name="ln1436">    EMSG2(_(&quot;E160: Unknown sign command: %s&quot;), arg);</a>
<a name="ln1437">    return;</a>
<a name="ln1438">  }</a>
<a name="ln1439">  arg = skipwhite(p);</a>
<a name="ln1440"> </a>
<a name="ln1441">  if (idx &lt;= SIGNCMD_LIST) {</a>
<a name="ln1442">    // Define, undefine or list signs.</a>
<a name="ln1443">    if (idx == SIGNCMD_LIST &amp;&amp; *arg == NUL) {</a>
<a name="ln1444">      // &quot;:sign list&quot;: list all defined signs</a>
<a name="ln1445">      for (sp = first_sign; sp != NULL &amp;&amp; !got_int; sp = sp-&gt;sn_next) {</a>
<a name="ln1446">        sign_list_defined(sp);</a>
<a name="ln1447">      }</a>
<a name="ln1448">    } else if (*arg == NUL) {</a>
<a name="ln1449">      EMSG(_(&quot;E156: Missing sign name&quot;));</a>
<a name="ln1450">    } else {</a>
<a name="ln1451">      char_u  *name;</a>
<a name="ln1452"> </a>
<a name="ln1453">      // Isolate the sign name.  If it's a number skip leading zeroes,</a>
<a name="ln1454">      // so that &quot;099&quot; and &quot;99&quot; are the same sign.  But keep &quot;0&quot;.</a>
<a name="ln1455">      p = skiptowhite(arg);</a>
<a name="ln1456">      if (*p != NUL) {</a>
<a name="ln1457">        *p++ = NUL;</a>
<a name="ln1458">      }</a>
<a name="ln1459">      while (arg[0] == '0' &amp;&amp; arg[1] != NUL) {</a>
<a name="ln1460">        arg++;</a>
<a name="ln1461">      }</a>
<a name="ln1462">      name = vim_strsave(arg);</a>
<a name="ln1463"> </a>
<a name="ln1464">      if (idx == SIGNCMD_DEFINE) {</a>
<a name="ln1465">        sign_define_cmd(name, p);</a>
<a name="ln1466">      } else if (idx == SIGNCMD_LIST) {</a>
<a name="ln1467">        // &quot;:sign list {name}&quot;</a>
<a name="ln1468">        sign_list_by_name(name);</a>
<a name="ln1469">      } else {</a>
<a name="ln1470">        // &quot;:sign undefine {name}&quot;</a>
<a name="ln1471">        sign_undefine_by_name(name);</a>
<a name="ln1472">      }</a>
<a name="ln1473"> </a>
<a name="ln1474">      xfree(name);</a>
<a name="ln1475">      return;</a>
<a name="ln1476">    }</a>
<a name="ln1477">  } else {</a>
<a name="ln1478">    int id = -1;</a>
<a name="ln1479">    linenr_T lnum = -1;</a>
<a name="ln1480">    char_u *sign_name = NULL;</a>
<a name="ln1481">    char_u *group = NULL;</a>
<a name="ln1482">    int prio = SIGN_DEF_PRIO;</a>
<a name="ln1483">    buf_T *buf = NULL;</a>
<a name="ln1484"> </a>
<a name="ln1485">    // Parse command line arguments</a>
<a name="ln1486">    if (parse_sign_cmd_args(idx, arg, &amp;sign_name, &amp;id, &amp;group, &amp;prio,</a>
<a name="ln1487">                            &amp;buf, &amp;lnum) == FAIL) {</a>
<a name="ln1488">      return;</a>
<a name="ln1489">    }</a>
<a name="ln1490"> </a>
<a name="ln1491">    if (idx == SIGNCMD_PLACE) {</a>
<a name="ln1492">      sign_place_cmd(buf, lnum, sign_name, id, group, prio);</a>
<a name="ln1493">    } else if (idx == SIGNCMD_UNPLACE) {</a>
<a name="ln1494">      sign_unplace_cmd(buf, lnum, sign_name, id, group);</a>
<a name="ln1495">    } else if (idx == SIGNCMD_JUMP) {</a>
<a name="ln1496">      sign_jump_cmd(buf, lnum, sign_name, id, group);</a>
<a name="ln1497">    }</a>
<a name="ln1498">  }</a>
<a name="ln1499">}</a>
<a name="ln1500"> </a>
<a name="ln1501">/// Return information about a specified sign</a>
<a name="ln1502">static void sign_getinfo(sign_T *sp, dict_T *retdict)</a>
<a name="ln1503">{</a>
<a name="ln1504">  const char *p;</a>
<a name="ln1505"> </a>
<a name="ln1506">  tv_dict_add_str(retdict, S_LEN(&quot;name&quot;), (char *)sp-&gt;sn_name);</a>
<a name="ln1507">  if (sp-&gt;sn_icon != NULL) {</a>
<a name="ln1508">    tv_dict_add_str(retdict, S_LEN(&quot;icon&quot;), (char *)sp-&gt;sn_icon);</a>
<a name="ln1509">  }</a>
<a name="ln1510">  if (sp-&gt;sn_text != NULL) {</a>
<a name="ln1511">    tv_dict_add_str(retdict, S_LEN(&quot;text&quot;), (char *)sp-&gt;sn_text);</a>
<a name="ln1512">  }</a>
<a name="ln1513">  if (sp-&gt;sn_line_hl &gt; 0) {</a>
<a name="ln1514">    p = get_highlight_name_ext(NULL, sp-&gt;sn_line_hl - 1, false);</a>
<a name="ln1515">    if (p == NULL) {</a>
<a name="ln1516">      p = &quot;NONE&quot;;</a>
<a name="ln1517">    }</a>
<a name="ln1518">    tv_dict_add_str(retdict, S_LEN(&quot;linehl&quot;), (char *)p);</a>
<a name="ln1519">  }</a>
<a name="ln1520">  if (sp-&gt;sn_text_hl &gt; 0) {</a>
<a name="ln1521">    p = get_highlight_name_ext(NULL, sp-&gt;sn_text_hl - 1, false);</a>
<a name="ln1522">    if (p == NULL) {</a>
<a name="ln1523">      p = &quot;NONE&quot;;</a>
<a name="ln1524">    }</a>
<a name="ln1525">    tv_dict_add_str(retdict, S_LEN(&quot;texthl&quot;), (char *)p);</a>
<a name="ln1526">  }</a>
<a name="ln1527">  if (sp-&gt;sn_num_hl &gt; 0) {</a>
<a name="ln1528">    p = get_highlight_name_ext(NULL, sp-&gt;sn_num_hl - 1, false);</a>
<a name="ln1529">    if (p == NULL) {</a>
<a name="ln1530">      p = &quot;NONE&quot;;</a>
<a name="ln1531">    }</a>
<a name="ln1532">    tv_dict_add_str(retdict, S_LEN(&quot;numhl&quot;), (char *)p);</a>
<a name="ln1533">  }</a>
<a name="ln1534">}</a>
<a name="ln1535"> </a>
<a name="ln1536">/// If 'name' is NULL, return a list of all the defined signs.</a>
<a name="ln1537">/// Otherwise, return information about the specified sign.</a>
<a name="ln1538">void sign_getlist(const char_u *name, list_T *retlist)</a>
<a name="ln1539">{</a>
<a name="ln1540">  sign_T *sp = first_sign;</a>
<a name="ln1541">  dict_T *dict;</a>
<a name="ln1542"> </a>
<a name="ln1543">  if (name != NULL) {</a>
<a name="ln1544">    sp = sign_find(name, NULL);</a>
<a name="ln1545">    if (sp == NULL) {</a>
<a name="ln1546">      return;</a>
<a name="ln1547">    }</a>
<a name="ln1548">  }</a>
<a name="ln1549"> </a>
<a name="ln1550">  for (; sp != NULL &amp;&amp; !got_int; sp = sp-&gt;sn_next) {</a>
<a name="ln1551">    dict = tv_dict_alloc();</a>
<a name="ln1552">    tv_list_append_dict(retlist, dict);</a>
<a name="ln1553">    sign_getinfo(sp, dict);</a>
<a name="ln1554"> </a>
<a name="ln1555">    if (name != NULL) {     // handle only the specified sign</a>
<a name="ln1556">      break;</a>
<a name="ln1557">    }</a>
<a name="ln1558">  }</a>
<a name="ln1559">}</a>
<a name="ln1560"> </a>
<a name="ln1561">/// Returns information about signs placed in a buffer as list of dicts.</a>
<a name="ln1562">list_T *get_buffer_signs(buf_T *buf)</a>
<a name="ln1563">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1564">{</a>
<a name="ln1565">  sign_entry_T *sign;</a>
<a name="ln1566">  dict_T *d;</a>
<a name="ln1567">  list_T *const l = tv_list_alloc(kListLenMayKnow);</a>
<a name="ln1568"> </a>
<a name="ln1569">  FOR_ALL_SIGNS_IN_BUF(buf, sign) {</a>
<a name="ln1570">    d = sign_get_info(sign);</a>
<a name="ln1571">    tv_list_append_dict(l, d);</a>
<a name="ln1572">  }</a>
<a name="ln1573">  return l;</a>
<a name="ln1574">}</a>
<a name="ln1575"> </a>
<a name="ln1576">/// Return information about all the signs placed in a buffer</a>
<a name="ln1577">static void sign_get_placed_in_buf(</a>
<a name="ln1578">    buf_T *buf,</a>
<a name="ln1579">    linenr_T lnum,</a>
<a name="ln1580">    int sign_id,</a>
<a name="ln1581">    const char_u *sign_group,</a>
<a name="ln1582">    list_T *retlist)</a>
<a name="ln1583">{</a>
<a name="ln1584">  dict_T *d;</a>
<a name="ln1585">  list_T *l;</a>
<a name="ln1586">  sign_entry_T *sign;</a>
<a name="ln1587"> </a>
<a name="ln1588">  d = tv_dict_alloc();</a>
<a name="ln1589">  tv_list_append_dict(retlist, d);</a>
<a name="ln1590"> </a>
<a name="ln1591">  tv_dict_add_nr(d, S_LEN(&quot;bufnr&quot;), (long)buf-&gt;b_fnum);</a>
<a name="ln1592"> </a>
<a name="ln1593">  l = tv_list_alloc(kListLenMayKnow);</a>
<a name="ln1594">  tv_dict_add_list(d, S_LEN(&quot;signs&quot;), l);</a>
<a name="ln1595"> </a>
<a name="ln1596">  FOR_ALL_SIGNS_IN_BUF(buf, sign) {</a>
<a name="ln1597">    if (!sign_in_group(sign, sign_group)) {</a>
<a name="ln1598">      continue;</a>
<a name="ln1599">    }</a>
<a name="ln1600">    if ((lnum == 0 &amp;&amp; sign_id == 0)</a>
<a name="ln1601">        || (sign_id == 0 &amp;&amp; lnum == sign-&gt;se_lnum)</a>
<a name="ln1602">        || (lnum == 0 &amp;&amp; sign_id == sign-&gt;se_id)</a>
<a name="ln1603">        || (lnum == sign-&gt;se_lnum &amp;&amp; sign_id == sign-&gt;se_id)) {</a>
<a name="ln1604">      tv_list_append_dict(l, sign_get_info(sign));</a>
<a name="ln1605">    }</a>
<a name="ln1606">  }</a>
<a name="ln1607">}</a>
<a name="ln1608"> </a>
<a name="ln1609">/// Get a list of signs placed in buffer 'buf'. If 'num' is non-zero, return the</a>
<a name="ln1610">/// sign placed at the line number. If 'lnum' is zero, return all the signs</a>
<a name="ln1611">/// placed in 'buf'. If 'buf' is NULL, return signs placed in all the buffers.</a>
<a name="ln1612">void sign_get_placed(</a>
<a name="ln1613">    buf_T *buf,</a>
<a name="ln1614">    linenr_T lnum,</a>
<a name="ln1615">    int sign_id,</a>
<a name="ln1616">    const char_u *sign_group,</a>
<a name="ln1617">    list_T *retlist</a>
<a name="ln1618">)</a>
<a name="ln1619">{</a>
<a name="ln1620">  if (buf != NULL) {</a>
<a name="ln1621">    sign_get_placed_in_buf(buf, lnum, sign_id, sign_group, retlist);</a>
<a name="ln1622">  } else {</a>
<a name="ln1623">    FOR_ALL_BUFFERS(cbuf) {</a>
<a name="ln1624">      if (cbuf-&gt;b_signlist != NULL) {</a>
<a name="ln1625">        sign_get_placed_in_buf(cbuf, 0, sign_id, sign_group, retlist);</a>
<a name="ln1626">      }</a>
<a name="ln1627">    }</a>
<a name="ln1628">  }</a>
<a name="ln1629">}</a>
<a name="ln1630"> </a>
<a name="ln1631">/// List one sign.</a>
<a name="ln1632">static void sign_list_defined(sign_T *sp)</a>
<a name="ln1633">{</a>
<a name="ln1634">  smsg(&quot;sign %s&quot;, sp-&gt;sn_name);</a>
<a name="ln1635">  if (sp-&gt;sn_icon != NULL) {</a>
<a name="ln1636">    msg_puts(&quot; icon=&quot;);</a>
<a name="ln1637">    msg_outtrans(sp-&gt;sn_icon);</a>
<a name="ln1638">    msg_puts(_(&quot; (not supported)&quot;));</a>
<a name="ln1639">  }</a>
<a name="ln1640">  if (sp-&gt;sn_text != NULL) {</a>
<a name="ln1641">    msg_puts(&quot; text=&quot;);</a>
<a name="ln1642">    msg_outtrans(sp-&gt;sn_text);</a>
<a name="ln1643">  }</a>
<a name="ln1644">  if (sp-&gt;sn_line_hl &gt; 0) {</a>
<a name="ln1645">    msg_puts(&quot; linehl=&quot;);</a>
<a name="ln1646">    const char *const p = get_highlight_name_ext(NULL,</a>
<a name="ln1647">                                                 sp-&gt;sn_line_hl - 1, false);</a>
<a name="ln1648">    if (p == NULL) {</a>
<a name="ln1649">      msg_puts(&quot;NONE&quot;);</a>
<a name="ln1650">    } else {</a>
<a name="ln1651">      msg_puts(p);</a>
<a name="ln1652">    }</a>
<a name="ln1653">  }</a>
<a name="ln1654">  if (sp-&gt;sn_text_hl &gt; 0) {</a>
<a name="ln1655">    msg_puts(&quot; texthl=&quot;);</a>
<a name="ln1656">    const char *const p = get_highlight_name_ext(NULL,</a>
<a name="ln1657">                                                 sp-&gt;sn_text_hl - 1, false);</a>
<a name="ln1658">    if (p == NULL) {</a>
<a name="ln1659">      msg_puts(&quot;NONE&quot;);</a>
<a name="ln1660">    } else {</a>
<a name="ln1661">      msg_puts(p);</a>
<a name="ln1662">    }</a>
<a name="ln1663">  }</a>
<a name="ln1664">  if (sp-&gt;sn_num_hl &gt; 0) {</a>
<a name="ln1665">    msg_puts(&quot; numhl=&quot;);</a>
<a name="ln1666">    const char *const p = get_highlight_name_ext(NULL,</a>
<a name="ln1667">                                                 sp-&gt;sn_num_hl - 1, false);</a>
<a name="ln1668">    if (p == NULL) {</a>
<a name="ln1669">      msg_puts(&quot;NONE&quot;);</a>
<a name="ln1670">    } else {</a>
<a name="ln1671">      msg_puts(p);</a>
<a name="ln1672">    }</a>
<a name="ln1673">  }</a>
<a name="ln1674">}</a>
<a name="ln1675"> </a>
<a name="ln1676">/// Undefine a sign and free its memory.</a>
<a name="ln1677">static void sign_undefine(sign_T *sp, sign_T *sp_prev)</a>
<a name="ln1678">{</a>
<a name="ln1679">  xfree(sp-&gt;sn_name);</a>
<a name="ln1680">  xfree(sp-&gt;sn_icon);</a>
<a name="ln1681">  xfree(sp-&gt;sn_text);</a>
<a name="ln1682">  if (sp_prev == NULL) {</a>
<a name="ln1683">    first_sign = sp-&gt;sn_next;</a>
<a name="ln1684">  } else {</a>
<a name="ln1685">    sp_prev-&gt;sn_next = sp-&gt;sn_next;</a>
<a name="ln1686">  }</a>
<a name="ln1687">  xfree(sp);</a>
<a name="ln1688">}</a>
<a name="ln1689"> </a>
<a name="ln1690">/// Undefine/free all signs.</a>
<a name="ln1691">void free_signs(void)</a>
<a name="ln1692">{</a>
<a name="ln1693">  while (first_sign != NULL) {</a>
<a name="ln1694">    sign_undefine(first_sign, NULL);</a>
<a name="ln1695">  }</a>
<a name="ln1696">}</a>
<a name="ln1697"> </a>
<a name="ln1698">static enum</a>
<a name="ln1699">{</a>
<a name="ln1700">    EXP_SUBCMD,   // expand :sign sub-commands</a>
<a name="ln1701">    EXP_DEFINE,   // expand :sign define {name} args</a>
<a name="ln1702">    EXP_PLACE,    // expand :sign place {id} args</a>
<a name="ln1703">    EXP_LIST,     // expand :sign place args</a>
<a name="ln1704">    EXP_UNPLACE,  // expand :sign unplace&quot;</a>
<a name="ln1705">    EXP_SIGN_NAMES,   // expand with name of placed signs</a>
<a name="ln1706">    EXP_SIGN_GROUPS,  // expand with name of placed sign groups</a>
<a name="ln1707">} expand_what;</a>
<a name="ln1708"> </a>
<a name="ln1709">// Return the n'th sign name (used for command line completion)</a>
<a name="ln1710">static char_u *get_nth_sign_name(int idx)</a>
<a name="ln1711">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1712">{</a>
<a name="ln1713">  // Complete with name of signs already defined</a>
<a name="ln1714">  int current_idx = 0;</a>
<a name="ln1715">  for (sign_T *sp = first_sign; sp != NULL; sp = sp-&gt;sn_next) {</a>
<a name="ln1716">    if (current_idx++ == idx) {</a>
<a name="ln1717">      return sp-&gt;sn_name;</a>
<a name="ln1718">    }</a>
<a name="ln1719">  }</a>
<a name="ln1720">  return NULL;</a>
<a name="ln1721">}</a>
<a name="ln1722"> </a>
<a name="ln1723">// Return the n'th sign group name (used for command line completion)</a>
<a name="ln1724">static char_u *get_nth_sign_group_name(int idx)</a>
<a name="ln1725">{</a>
<a name="ln1726">  // Complete with name of sign groups already defined</a>
<a name="ln1727">  int current_idx = 0;</a>
<a name="ln1728">  int todo = (int)sg_table.ht_used;</a>
<a name="ln1729">  for (hashitem_T *hi = sg_table.ht_array; todo &gt; 0; hi++) {</a>
<a name="ln1730">    if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln1731">      todo--;</a>
<a name="ln1732">      if (current_idx++ == idx) {</a>
<a name="ln1733">        signgroup_T *const group = HI2SG(hi);</a>
<a name="ln1734">        return group-&gt;sg_name;</a>
<a name="ln1735">      }</a>
<a name="ln1736">    }</a>
<a name="ln1737">  }</a>
<a name="ln1738">  return NULL;</a>
<a name="ln1739">}</a>
<a name="ln1740"> </a>
<a name="ln1741">/// Function given to ExpandGeneric() to obtain the sign command</a>
<a name="ln1742">/// expansion.</a>
<a name="ln1743">char_u * get_sign_name(expand_T *xp, int idx)</a>
<a name="ln1744">{</a>
<a name="ln1745">  switch (expand_what) {</a>
<a name="ln1746">    case EXP_SUBCMD:</a>
<a name="ln1747">      return (char_u *)cmds[idx];</a>
<a name="ln1748">    case EXP_DEFINE: {</a>
<a name="ln1749">        char *define_arg[] = { &quot;icon=&quot;, &quot;linehl=&quot;, &quot;text=&quot;, &quot;texthl=&quot;, &quot;numhl=&quot;,</a>
<a name="ln1750">                               NULL };</a>
<a name="ln1751">        return (char_u *)define_arg[idx];</a>
<a name="ln1752">      }</a>
<a name="ln1753">    case EXP_PLACE: {</a>
<a name="ln1754">        char *place_arg[] = { &quot;line=&quot;, &quot;name=&quot;, &quot;group=&quot;, &quot;priority=&quot;, &quot;file=&quot;,</a>
<a name="ln1755">                              &quot;buffer=&quot;, NULL };</a>
<a name="ln1756">        return (char_u *)place_arg[idx];</a>
<a name="ln1757">      }</a>
<a name="ln1758">    case EXP_LIST: {</a>
<a name="ln1759">      char *list_arg[] = { &quot;group=&quot;, &quot;file=&quot;, &quot;buffer=&quot;, NULL };</a>
<a name="ln1760">      return (char_u *)list_arg[idx];</a>
<a name="ln1761">    }</a>
<a name="ln1762">    case EXP_UNPLACE: {</a>
<a name="ln1763">        char *unplace_arg[] = { &quot;group=&quot;, &quot;file=&quot;, &quot;buffer=&quot;, NULL };</a>
<a name="ln1764">        return (char_u *)unplace_arg[idx];</a>
<a name="ln1765">      }</a>
<a name="ln1766">    case EXP_SIGN_NAMES:</a>
<a name="ln1767">      return get_nth_sign_name(idx);</a>
<a name="ln1768">    case EXP_SIGN_GROUPS:</a>
<a name="ln1769">      return get_nth_sign_group_name(idx);</a>
<a name="ln1770">    default:</a>
<a name="ln1771">      return NULL;</a>
<a name="ln1772">  }</a>
<a name="ln1773">}</a>
<a name="ln1774"> </a>
<a name="ln1775">/// Handle command line completion for :sign command.</a>
<a name="ln1776">void set_context_in_sign_cmd(expand_T *xp, char_u *arg)</a>
<a name="ln1777">{</a>
<a name="ln1778">  char_u  *end_subcmd;</a>
<a name="ln1779">  char_u  *last;</a>
<a name="ln1780">  int    cmd_idx;</a>
<a name="ln1781">  char_u  *begin_subcmd_args;</a>
<a name="ln1782"> </a>
<a name="ln1783">  // Default: expand subcommands.</a>
<a name="ln1784">  xp-&gt;xp_context = EXPAND_SIGN;</a>
<a name="ln1785">  expand_what = EXP_SUBCMD;</a>
<a name="ln1786">  xp-&gt;xp_pattern = arg;</a>
<a name="ln1787"> </a>
<a name="ln1788">  end_subcmd = skiptowhite(arg);</a>
<a name="ln1789">  if (*end_subcmd == NUL) {</a>
<a name="ln1790">    // expand subcmd name</a>
<a name="ln1791">    // :sign {subcmd}&lt;CTRL-D&gt;</a>
<a name="ln1792">    return;</a>
<a name="ln1793">  }</a>
<a name="ln1794"> </a>
<a name="ln1795">  cmd_idx = sign_cmd_idx(arg, end_subcmd);</a>
<a name="ln1796"> </a>
<a name="ln1797">  // :sign {subcmd} {subcmd_args}</a>
<a name="ln1798">  //                |</a>
<a name="ln1799">  //                begin_subcmd_args</a>
<a name="ln1800">  begin_subcmd_args = skipwhite(end_subcmd);</a>
<a name="ln1801"> </a>
<a name="ln1802">  // Expand last argument of subcmd.</a>
<a name="ln1803">  //</a>
<a name="ln1804">  // :sign define {name} {args}...</a>
<a name="ln1805">  //              |</a>
<a name="ln1806">  //              p</a>
<a name="ln1807"> </a>
<a name="ln1808">  // Loop until reaching last argument.</a>
<a name="ln1809">  char_u *p = begin_subcmd_args;</a>
<a name="ln1810">  do {</a>
<a name="ln1811">    p = skipwhite(p);</a>
<a name="ln1812">    last = p;</a>
<a name="ln1813">    p = skiptowhite(p);</a>
<a name="ln1814">  } while (*p != NUL);</a>
<a name="ln1815"> </a>
<a name="ln1816">  p = vim_strchr(last, '=');</a>
<a name="ln1817"> </a>
<a name="ln1818">  // :sign define {name} {args}... {last}=</a>
<a name="ln1819">  //                               |     |</a>
<a name="ln1820">  //                            last     p</a>
<a name="ln1821">  if (p == NULL) {</a>
<a name="ln1822">    // Expand last argument name (before equal sign).</a>
<a name="ln1823">    xp-&gt;xp_pattern = last;</a>
<a name="ln1824">    switch (cmd_idx) {</a>
<a name="ln1825">      case SIGNCMD_DEFINE:</a>
<a name="ln1826">        expand_what = EXP_DEFINE;</a>
<a name="ln1827">        break;</a>
<a name="ln1828">      case SIGNCMD_PLACE:</a>
<a name="ln1829">        // List placed signs</a>
<a name="ln1830">        if (ascii_isdigit(*begin_subcmd_args)) {</a>
<a name="ln1831">          //   :sign place {id} {args}...</a>
<a name="ln1832">          expand_what = EXP_PLACE;</a>
<a name="ln1833">        } else {</a>
<a name="ln1834">          //   :sign place {args}...</a>
<a name="ln1835">          expand_what = EXP_LIST;</a>
<a name="ln1836">        }</a>
<a name="ln1837">        break;</a>
<a name="ln1838">      case SIGNCMD_LIST:</a>
<a name="ln1839">      case SIGNCMD_UNDEFINE:</a>
<a name="ln1840">        // :sign list &lt;CTRL-D&gt;</a>
<a name="ln1841">        // :sign undefine &lt;CTRL-D&gt;</a>
<a name="ln1842">        expand_what = EXP_SIGN_NAMES;</a>
<a name="ln1843">        break;</a>
<a name="ln1844">      case SIGNCMD_JUMP:</a>
<a name="ln1845">      case SIGNCMD_UNPLACE:</a>
<a name="ln1846">        expand_what = EXP_UNPLACE;</a>
<a name="ln1847">        break;</a>
<a name="ln1848">      default:</a>
<a name="ln1849">        xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln1850">    }</a>
<a name="ln1851">  } else {</a>
<a name="ln1852">  // Expand last argument value (after equal sign).</a>
<a name="ln1853">    xp-&gt;xp_pattern = p + 1;</a>
<a name="ln1854">    switch (cmd_idx) {</a>
<a name="ln1855">      case SIGNCMD_DEFINE:</a>
<a name="ln1856">        if (STRNCMP(last, &quot;texthl&quot;, 6) == 0</a>
<a name="ln1857">            || STRNCMP(last, &quot;linehl&quot;, 6) == 0</a>
<a name="ln1858">            || STRNCMP(last, &quot;numhl&quot;, 5) == 0) {</a>
<a name="ln1859">          xp-&gt;xp_context = EXPAND_HIGHLIGHT;</a>
<a name="ln1860">        } else if (STRNCMP(last, &quot;icon&quot;, 4) == 0) {</a>
<a name="ln1861">          xp-&gt;xp_context = EXPAND_FILES;</a>
<a name="ln1862">        } else {</a>
<a name="ln1863">          xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln1864">        }</a>
<a name="ln1865">        break;</a>
<a name="ln1866">      case SIGNCMD_PLACE:</a>
<a name="ln1867">        if (STRNCMP(last, &quot;name&quot;, 4) == 0) {</a>
<a name="ln1868">          expand_what = EXP_SIGN_NAMES;</a>
<a name="ln1869">        } else if (STRNCMP(last, &quot;group&quot;, 5) == 0) {</a>
<a name="ln1870">          expand_what = EXP_SIGN_GROUPS;</a>
<a name="ln1871">        } else if (STRNCMP(last, &quot;file&quot;, 4) == 0) {</a>
<a name="ln1872">          xp-&gt;xp_context = EXPAND_BUFFERS;</a>
<a name="ln1873">        } else {</a>
<a name="ln1874">          xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln1875">        }</a>
<a name="ln1876">        break;</a>
<a name="ln1877">      case SIGNCMD_UNPLACE:</a>
<a name="ln1878">      case SIGNCMD_JUMP:</a>
<a name="ln1879">        if (STRNCMP(last, &quot;group&quot;, 5) == 0) {</a>
<a name="ln1880">          expand_what = EXP_SIGN_GROUPS;</a>
<a name="ln1881">        } else if (STRNCMP(last, &quot;file&quot;, 4) == 0) {</a>
<a name="ln1882">          xp-&gt;xp_context = EXPAND_BUFFERS;</a>
<a name="ln1883">        } else {</a>
<a name="ln1884">          xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln1885">        }</a>
<a name="ln1886">        break;</a>
<a name="ln1887">      default:</a>
<a name="ln1888">        xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln1889">    }</a>
<a name="ln1890">  }</a>
<a name="ln1891">}</a>
<a name="ln1892"> </a>
<a name="ln1893">/// Define a sign using the attributes in 'dict'. Returns 0 on success and -1 on</a>
<a name="ln1894">/// failure.</a>
<a name="ln1895">int sign_define_from_dict(const char *name_arg, dict_T *dict)</a>
<a name="ln1896">{</a>
<a name="ln1897">  char *name = NULL;</a>
<a name="ln1898">  char *icon = NULL;</a>
<a name="ln1899">  char *linehl = NULL;</a>
<a name="ln1900">  char *text = NULL;</a>
<a name="ln1901">  char *texthl = NULL;</a>
<a name="ln1902">  char *numhl = NULL;</a>
<a name="ln1903">  int retval = -1;</a>
<a name="ln1904"> </a>
<a name="ln1905">  if (name_arg == NULL) {</a>
<a name="ln1906">    if (dict == NULL) {</a>
<a name="ln1907">      return -1;</a>
<a name="ln1908">    }</a>
<a name="ln1909">    name = tv_dict_get_string(dict, &quot;name&quot;, true);</a>
<a name="ln1910">  } else {</a>
<a name="ln1911">    name = xstrdup(name_arg);</a>
<a name="ln1912">  }</a>
<a name="ln1913">  if (name == NULL || name[0] == NUL) {</a>
<a name="ln1914">    goto cleanup;</a>
<a name="ln1915">  }</a>
<a name="ln1916">  if (dict != NULL) {</a>
<a name="ln1917">    icon   = tv_dict_get_string(dict, &quot;icon&quot;  , true);</a>
<a name="ln1918">    linehl = tv_dict_get_string(dict, &quot;linehl&quot;, true);</a>
<a name="ln1919">    text   = tv_dict_get_string(dict, &quot;text&quot;  , true);</a>
<a name="ln1920">    texthl = tv_dict_get_string(dict, &quot;texthl&quot;, true);</a>
<a name="ln1921">    numhl  = tv_dict_get_string(dict, &quot;numhl&quot; , true);</a>
<a name="ln1922">  }</a>
<a name="ln1923"> </a>
<a name="ln1924">  if (sign_define_by_name((char_u *)name, (char_u *)icon, (char_u *)linehl,</a>
<a name="ln1925">                          (char_u *)text, (char_u *)texthl, (char_u *)numhl)</a>
<a name="ln1926">      == OK) {</a>
<a name="ln1927">    retval = 0;</a>
<a name="ln1928">  }</a>
<a name="ln1929"> </a>
<a name="ln1930">cleanup:</a>
<a name="ln1931">  xfree(name);</a>
<a name="ln1932">  xfree(icon);</a>
<a name="ln1933">  xfree(linehl);</a>
<a name="ln1934">  xfree(text);</a>
<a name="ln1935">  xfree(texthl);</a>
<a name="ln1936">  xfree(numhl);</a>
<a name="ln1937"> </a>
<a name="ln1938">  return retval;</a>
<a name="ln1939">}</a>
<a name="ln1940"> </a>
<a name="ln1941">/// Define multiple signs using attributes from list 'l' and store the return</a>
<a name="ln1942">/// values in 'retlist'.</a>
<a name="ln1943">void sign_define_multiple(list_T *l, list_T *retlist)</a>
<a name="ln1944">{</a>
<a name="ln1945">    int retval;</a>
<a name="ln1946"> </a>
<a name="ln1947">    TV_LIST_ITER_CONST(l, li, {</a>
<a name="ln1948">      retval = -1;</a>
<a name="ln1949">      if (TV_LIST_ITEM_TV(li)-&gt;v_type == VAR_DICT) {</a>
<a name="ln1950">        retval = sign_define_from_dict(NULL, TV_LIST_ITEM_TV(li)-&gt;vval.v_dict);</a>
<a name="ln1951">      } else {</a>
<a name="ln1952">        EMSG(_(e_dictreq));</a>
<a name="ln1953">      }</a>
<a name="ln1954">      tv_list_append_number(retlist, retval);</a>
<a name="ln1955">    });</a>
<a name="ln1956">}</a>
<a name="ln1957"> </a>
<a name="ln1958">/// Place a new sign using the values specified in dict 'dict'. Returns the sign</a>
<a name="ln1959">/// identifier if successfully placed, otherwise returns 0.</a>
<a name="ln1960">int sign_place_from_dict(</a>
<a name="ln1961">    typval_T *id_tv,</a>
<a name="ln1962">    typval_T *group_tv,</a>
<a name="ln1963">    typval_T *name_tv,</a>
<a name="ln1964">    typval_T *buf_tv,</a>
<a name="ln1965">    dict_T *dict)</a>
<a name="ln1966">{</a>
<a name="ln1967">  int sign_id = 0;</a>
<a name="ln1968">  char_u *group = NULL;</a>
<a name="ln1969">  char_u *sign_name = NULL;</a>
<a name="ln1970">  buf_T *buf = NULL;</a>
<a name="ln1971">  dictitem_T *di;</a>
<a name="ln1972">  linenr_T lnum = 0;</a>
<a name="ln1973">  int prio = SIGN_DEF_PRIO;</a>
<a name="ln1974">  bool notanum = false;</a>
<a name="ln1975">  int ret_sign_id = -1;</a>
<a name="ln1976"> </a>
<a name="ln1977">  // sign identifier</a>
<a name="ln1978">  if (id_tv == NULL) {</a>
<a name="ln1979">    di = tv_dict_find(dict, &quot;id&quot;, -1);</a>
<a name="ln1980">    if (di != NULL) {</a>
<a name="ln1981">      id_tv = &amp;di-&gt;di_tv;</a>
<a name="ln1982">    }</a>
<a name="ln1983">  }</a>
<a name="ln1984">  if (id_tv == NULL) {</a>
<a name="ln1985">    sign_id = 0;</a>
<a name="ln1986">  } else {</a>
<a name="ln1987">    sign_id = (int)tv_get_number_chk(id_tv, &amp;notanum);</a>
<a name="ln1988">    if (notanum) {</a>
<a name="ln1989">      return -1;</a>
<a name="ln1990">    }</a>
<a name="ln1991">    if (sign_id &lt; 0) {</a>
<a name="ln1992">      EMSG(_(e_invarg));</a>
<a name="ln1993">      return -1;</a>
<a name="ln1994">    }</a>
<a name="ln1995">  }</a>
<a name="ln1996"> </a>
<a name="ln1997">  // sign group</a>
<a name="ln1998">  if (group_tv == NULL) {</a>
<a name="ln1999">    di = tv_dict_find(dict, &quot;group&quot;, -1);</a>
<a name="ln2000">    if (di != NULL) {</a>
<a name="ln2001">      group_tv = &amp;di-&gt;di_tv;</a>
<a name="ln2002">    }</a>
<a name="ln2003">  }</a>
<a name="ln2004">  if (group_tv == NULL) {</a>
<a name="ln2005">    group = NULL;  // global group</a>
<a name="ln2006">  } else {</a>
<a name="ln2007">    group = (char_u *)tv_get_string_chk(group_tv);</a>
<a name="ln2008">    if (group == NULL) {</a>
<a name="ln2009">      goto cleanup;</a>
<a name="ln2010">    }</a>
<a name="ln2011">    if (group[0] == '\0') {  // global sign group</a>
<a name="ln2012">      group = NULL;</a>
<a name="ln2013">    } else {</a>
<a name="ln2014">      group = vim_strsave(group);</a>
<a name="ln2015">      if (group == NULL) {</a>
<a name="ln2016">        return -1;</a>
<a name="ln2017">      }</a>
<a name="ln2018">    }</a>
<a name="ln2019">  }</a>
<a name="ln2020"> </a>
<a name="ln2021">  // sign name</a>
<a name="ln2022">  if (name_tv == NULL) {</a>
<a name="ln2023">    di = tv_dict_find(dict, &quot;name&quot;, -1);</a>
<a name="ln2024">    if (di != NULL) {</a>
<a name="ln2025">      name_tv = &amp;di-&gt;di_tv;</a>
<a name="ln2026">    }</a>
<a name="ln2027">  }</a>
<a name="ln2028">  if (name_tv == NULL) {</a>
<a name="ln2029">    goto cleanup;</a>
<a name="ln2030">  }</a>
<a name="ln2031">  sign_name = (char_u *)tv_get_string_chk(name_tv);</a>
<a name="ln2032">  if (sign_name == NULL) {</a>
<a name="ln2033">    goto cleanup;</a>
<a name="ln2034">  }</a>
<a name="ln2035"> </a>
<a name="ln2036">  // buffer to place the sign</a>
<a name="ln2037">  if (buf_tv == NULL) {</a>
<a name="ln2038">    di = tv_dict_find(dict, &quot;buffer&quot;, -1);</a>
<a name="ln2039">    if (di != NULL) {</a>
<a name="ln2040">      buf_tv = &amp;di-&gt;di_tv;</a>
<a name="ln2041">    }</a>
<a name="ln2042">  }</a>
<a name="ln2043">  if (buf_tv == NULL) {</a>
<a name="ln2044">    goto cleanup;</a>
<a name="ln2045">  }</a>
<a name="ln2046">  buf = get_buf_arg(buf_tv);</a>
<a name="ln2047">  if (buf == NULL) {</a>
<a name="ln2048">    goto cleanup;</a>
<a name="ln2049">  }</a>
<a name="ln2050"> </a>
<a name="ln2051">  // line number of the sign</a>
<a name="ln2052">  di = tv_dict_find(dict, &quot;lnum&quot;, -1);</a>
<a name="ln2053">  if (di != NULL) {</a>
<a name="ln2054">    lnum = tv_get_lnum(&amp;di-&gt;di_tv);</a>
<a name="ln2055">    if (lnum &lt;= 0) {</a>
<a name="ln2056">      EMSG(_(e_invarg));</a>
<a name="ln2057">      goto cleanup;</a>
<a name="ln2058">    }</a>
<a name="ln2059">  }</a>
<a name="ln2060"> </a>
<a name="ln2061">  // sign priority</a>
<a name="ln2062">  di = tv_dict_find(dict, &quot;priority&quot;, -1);</a>
<a name="ln2063">  if (di != NULL) {</a>
<a name="ln2064">    prio = (int)tv_get_number_chk(&amp;di-&gt;di_tv, &amp;notanum);</a>
<a name="ln2065">    if (notanum) {</a>
<a name="ln2066">      goto cleanup;</a>
<a name="ln2067">    }</a>
<a name="ln2068">  }</a>
<a name="ln2069"> </a>
<a name="ln2070">  if (sign_place(&amp;sign_id, group, sign_name, buf, lnum, prio) == OK) {</a>
<a name="ln2071">    ret_sign_id = sign_id;</a>
<a name="ln2072">  }</a>
<a name="ln2073"> </a>
<a name="ln2074">cleanup:</a>
<a name="ln2075">  xfree(group);</a>
<a name="ln2076"> </a>
<a name="ln2077">  return ret_sign_id;</a>
<a name="ln2078">}</a>
<a name="ln2079"> </a>
<a name="ln2080">/// Undefine multiple signs</a>
<a name="ln2081">void sign_undefine_multiple(list_T *l, list_T *retlist)</a>
<a name="ln2082">{</a>
<a name="ln2083">  char_u *name;</a>
<a name="ln2084">  int retval;</a>
<a name="ln2085"> </a>
<a name="ln2086">  TV_LIST_ITER_CONST(l, li, {</a>
<a name="ln2087">    retval = -1;</a>
<a name="ln2088">    name = (char_u *)tv_get_string_chk(TV_LIST_ITEM_TV(li));</a>
<a name="ln2089">    if (name != NULL &amp;&amp; (sign_undefine_by_name(name) == OK)) {</a>
<a name="ln2090">      retval = 0;</a>
<a name="ln2091">    }</a>
<a name="ln2092">    tv_list_append_number(retlist, retval);</a>
<a name="ln2093">  });</a>
<a name="ln2094">}</a>
<a name="ln2095"> </a>
<a name="ln2096">/// Unplace the sign with attributes specified in 'dict'. Returns 0 on success</a>
<a name="ln2097">/// and -1 on failure.</a>
<a name="ln2098">int sign_unplace_from_dict(typval_T *group_tv, dict_T *dict)</a>
<a name="ln2099">{</a>
<a name="ln2100">  dictitem_T *di;</a>
<a name="ln2101">  int sign_id = 0;</a>
<a name="ln2102">  buf_T *buf = NULL;</a>
<a name="ln2103">  char_u *group = NULL;</a>
<a name="ln2104">  int retval = -1;</a>
<a name="ln2105"> </a>
<a name="ln2106">  // sign group</a>
<a name="ln2107">  if (group_tv != NULL) {</a>
<a name="ln2108">    group = (char_u *)tv_get_string(group_tv);</a>
<a name="ln2109">  } else {</a>
<a name="ln2110">    group = (char_u *)tv_dict_get_string(dict, &quot;group&quot;, false);</a>
<a name="ln2111">  }</a>
<a name="ln2112">  if (group != NULL) {</a>
<a name="ln2113">    if (group[0] == '\0') {  // global sign group</a>
<a name="ln2114">      group = NULL;</a>
<a name="ln2115">    } else {</a>
<a name="ln2116">      group = vim_strsave(group);</a>
<a name="ln2117">      if (group == NULL) {</a>
<a name="ln2118">        return -1;</a>
<a name="ln2119">      }</a>
<a name="ln2120">    }</a>
<a name="ln2121">  }</a>
<a name="ln2122"> </a>
<a name="ln2123">  if (dict != NULL) {</a>
<a name="ln2124">    if ((di = tv_dict_find(dict, &quot;buffer&quot;, -1)) != NULL) {</a>
<a name="ln2125">      buf = get_buf_arg(&amp;di-&gt;di_tv);</a>
<a name="ln2126">      if (buf == NULL) {</a>
<a name="ln2127">        goto cleanup;</a>
<a name="ln2128">      }</a>
<a name="ln2129">    }</a>
<a name="ln2130">    if (tv_dict_find(dict, &quot;id&quot;, -1) != NULL) {</a>
<a name="ln2131">      sign_id = (int)tv_dict_get_number(dict, &quot;id&quot;);</a>
<a name="ln2132">      if (sign_id &lt;= 0) {</a>
<a name="ln2133">        EMSG(_(e_invarg));</a>
<a name="ln2134">        goto cleanup;</a>
<a name="ln2135">      }</a>
<a name="ln2136">    }</a>
<a name="ln2137">  }</a>
<a name="ln2138"> </a>
<a name="ln2139">  if (buf == NULL) {</a>
<a name="ln2140">    // Delete the sign in all the buffers</a>
<a name="ln2141">    retval = 0;</a>
<a name="ln2142">    FOR_ALL_BUFFERS(buf2) {</a>
<a name="ln2143">      if (sign_unplace(sign_id, group, buf2, 0) != OK) {</a>
<a name="ln2144">        retval = -1;</a>
<a name="ln2145">      }</a>
<a name="ln2146">    }</a>
<a name="ln2147">  } else if (sign_unplace(sign_id, group, buf, 0) == OK) {</a>
<a name="ln2148">    retval = 0;</a>
<a name="ln2149">  }</a>
<a name="ln2150"> </a>
<a name="ln2151">cleanup:</a>
<a name="ln2152">  xfree(group);</a>
<a name="ln2153"> </a>
<a name="ln2154">  return retval;</a>
<a name="ln2155">}</a>
<a name="ln2156"> </a>

</code></pre>
<div class="balloon" rel="2015"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'group == NULL' is always false.</p></div>
<div class="balloon" rel="2117"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'group == NULL' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
