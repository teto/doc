
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>input.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4"> </a>
<a name="ln5">#include &quot;nvim/tui/input.h&quot;</a>
<a name="ln6">#include &quot;nvim/vim.h&quot;</a>
<a name="ln7">#include &quot;nvim/api/vim.h&quot;</a>
<a name="ln8">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln9">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln10">#include &quot;nvim/charset.h&quot;</a>
<a name="ln11">#include &quot;nvim/main.h&quot;</a>
<a name="ln12">#include &quot;nvim/macros.h&quot;</a>
<a name="ln13">#include &quot;nvim/aucmd.h&quot;</a>
<a name="ln14">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln15">#include &quot;nvim/option.h&quot;</a>
<a name="ln16">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln17">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln18">#ifdef WIN32</a>
<a name="ln19"># include &quot;nvim/os/os_win_console.h&quot;</a>
<a name="ln20">#endif</a>
<a name="ln21">#include &quot;nvim/event/rstream.h&quot;</a>
<a name="ln22"> </a>
<a name="ln23">#define KEY_BUFFER_SIZE 0xfff</a>
<a name="ln24"> </a>
<a name="ln25">#ifndef UNIT_TESTING</a>
<a name="ln26">typedef enum {</a>
<a name="ln27">  kIncomplete = -1,</a>
<a name="ln28">  kNotApplicable = 0,</a>
<a name="ln29">  kComplete = 1,</a>
<a name="ln30">} HandleState;</a>
<a name="ln31">#endif</a>
<a name="ln32"> </a>
<a name="ln33">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln34"># include &quot;tui/input.c.generated.h&quot;</a>
<a name="ln35">#endif</a>
<a name="ln36"> </a>
<a name="ln37">void tinput_init(TermInput *input, Loop *loop)</a>
<a name="ln38">{</a>
<a name="ln39">  input-&gt;loop = loop;</a>
<a name="ln40">  input-&gt;paste = 0;</a>
<a name="ln41">  input-&gt;in_fd = STDIN_FILENO;</a>
<a name="ln42">  input-&gt;waiting_for_bg_response = 0;</a>
<a name="ln43">  // The main thread is waiting for the UI thread to call CONTINUE, so it can</a>
<a name="ln44">  // safely access global variables.</a>
<a name="ln45">  input-&gt;ttimeout = (bool)p_ttimeout;</a>
<a name="ln46">  input-&gt;ttimeoutlen = p_ttm;</a>
<a name="ln47">  input-&gt;key_buffer = rbuffer_new(KEY_BUFFER_SIZE);</a>
<a name="ln48">  uv_mutex_init(&amp;input-&gt;key_buffer_mutex);</a>
<a name="ln49">  uv_cond_init(&amp;input-&gt;key_buffer_cond);</a>
<a name="ln50"> </a>
<a name="ln51">  // If stdin is not a pty, switch to stderr. For cases like:</a>
<a name="ln52">  //    echo q | nvim -es</a>
<a name="ln53">  //    ls *.md | xargs nvim</a>
<a name="ln54">#ifdef WIN32</a>
<a name="ln55">  if (!os_isatty(input-&gt;in_fd)) {</a>
<a name="ln56">      input-&gt;in_fd = os_get_conin_fd();</a>
<a name="ln57">  }</a>
<a name="ln58">#else</a>
<a name="ln59">  if (!os_isatty(input-&gt;in_fd) &amp;&amp; os_isatty(STDERR_FILENO)) {</a>
<a name="ln60">    input-&gt;in_fd = STDERR_FILENO;</a>
<a name="ln61">  }</a>
<a name="ln62">#endif</a>
<a name="ln63">  input_global_fd_init(input-&gt;in_fd);</a>
<a name="ln64"> </a>
<a name="ln65">  const char *term = os_getenv(&quot;TERM&quot;);</a>
<a name="ln66">  if (!term) {</a>
<a name="ln67">    term = &quot;&quot;;  // termkey_new_abstract assumes non-null (#2745)</a>
<a name="ln68">  }</a>
<a name="ln69"> </a>
<a name="ln70">#if TERMKEY_VERSION_MAJOR &gt; 0 || TERMKEY_VERSION_MINOR &gt; 18</a>
<a name="ln71">  input-&gt;tk = termkey_new_abstract(term,</a>
<a name="ln72">                                   TERMKEY_FLAG_UTF8 | TERMKEY_FLAG_NOSTART);</a>
<a name="ln73">  termkey_hook_terminfo_getstr(input-&gt;tk, input-&gt;tk_ti_hook_fn, NULL);</a>
<a name="ln74">  termkey_start(input-&gt;tk);</a>
<a name="ln75">#else</a>
<a name="ln76">  input-&gt;tk = termkey_new_abstract(term, TERMKEY_FLAG_UTF8);</a>
<a name="ln77">#endif</a>
<a name="ln78"> </a>
<a name="ln79">  int curflags = termkey_get_canonflags(input-&gt;tk);</a>
<a name="ln80">  termkey_set_canonflags(input-&gt;tk, curflags | TERMKEY_CANON_DELBS);</a>
<a name="ln81"> </a>
<a name="ln82">  // setup input handle</a>
<a name="ln83">  rstream_init_fd(loop, &amp;input-&gt;read_stream, input-&gt;in_fd, 0xfff);</a>
<a name="ln84">  // initialize a timer handle for handling ESC with libtermkey</a>
<a name="ln85">  time_watcher_init(loop, &amp;input-&gt;timer_handle, input);</a>
<a name="ln86">}</a>
<a name="ln87"> </a>
<a name="ln88">void tinput_destroy(TermInput *input)</a>
<a name="ln89">{</a>
<a name="ln90">  rbuffer_free(input-&gt;key_buffer);</a>
<a name="ln91">  uv_mutex_destroy(&amp;input-&gt;key_buffer_mutex);</a>
<a name="ln92">  uv_cond_destroy(&amp;input-&gt;key_buffer_cond);</a>
<a name="ln93">  time_watcher_close(&amp;input-&gt;timer_handle, NULL);</a>
<a name="ln94">  stream_close(&amp;input-&gt;read_stream, NULL, NULL);</a>
<a name="ln95">  termkey_destroy(input-&gt;tk);</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98">void tinput_start(TermInput *input)</a>
<a name="ln99">{</a>
<a name="ln100">  rstream_start(&amp;input-&gt;read_stream, tinput_read_cb, input);</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">void tinput_stop(TermInput *input)</a>
<a name="ln104">{</a>
<a name="ln105">  rstream_stop(&amp;input-&gt;read_stream);</a>
<a name="ln106">  time_watcher_stop(&amp;input-&gt;timer_handle);</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109">static void tinput_done_event(void **argv)</a>
<a name="ln110">{</a>
<a name="ln111">  input_done();</a>
<a name="ln112">}</a>
<a name="ln113"> </a>
<a name="ln114">static void tinput_wait_enqueue(void **argv)</a>
<a name="ln115">{</a>
<a name="ln116">  TermInput *input = argv[0];</a>
<a name="ln117">  RBUFFER_UNTIL_EMPTY(input-&gt;key_buffer, buf, len) {</a>
<a name="ln118">    const String keys = { .data = buf, .size = len };</a>
<a name="ln119">    if (input-&gt;paste) {</a>
<a name="ln120">      String copy = copy_string(keys);</a>
<a name="ln121">      multiqueue_put(main_loop.events, tinput_paste_event, 3,</a>
<a name="ln122">                     copy.data, copy.size, (intptr_t)input-&gt;paste);</a>
<a name="ln123">      if (input-&gt;paste == 1) {</a>
<a name="ln124">        // Paste phase: &quot;continue&quot;</a>
<a name="ln125">        input-&gt;paste = 2;</a>
<a name="ln126">      }</a>
<a name="ln127">      rbuffer_consumed(input-&gt;key_buffer, len);</a>
<a name="ln128">      rbuffer_reset(input-&gt;key_buffer);</a>
<a name="ln129">    } else {</a>
<a name="ln130">      const size_t consumed = input_enqueue(keys);</a>
<a name="ln131">      if (consumed) {</a>
<a name="ln132">        rbuffer_consumed(input-&gt;key_buffer, consumed);</a>
<a name="ln133">      }</a>
<a name="ln134">      rbuffer_reset(input-&gt;key_buffer);</a>
<a name="ln135">      if (consumed &lt; len) {</a>
<a name="ln136">        break;</a>
<a name="ln137">      }</a>
<a name="ln138">    }</a>
<a name="ln139">  }</a>
<a name="ln140">  uv_mutex_lock(&amp;input-&gt;key_buffer_mutex);</a>
<a name="ln141">  input-&gt;waiting = false;</a>
<a name="ln142">  uv_cond_signal(&amp;input-&gt;key_buffer_cond);</a>
<a name="ln143">  uv_mutex_unlock(&amp;input-&gt;key_buffer_mutex);</a>
<a name="ln144">}</a>
<a name="ln145"> </a>
<a name="ln146">static void tinput_paste_event(void **argv)</a>
<a name="ln147">{</a>
<a name="ln148">  String keys = { .data = argv[0], .size = (size_t)argv[1] };</a>
<a name="ln149">  intptr_t phase = (intptr_t)argv[2];</a>
<a name="ln150"> </a>
<a name="ln151">  Error err = ERROR_INIT;</a>
<a name="ln152">  nvim_paste(keys, true, phase, &amp;err);</a>
<a name="ln153">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln154">    emsgf(&quot;paste: %s&quot;, err.msg);</a>
<a name="ln155">    api_clear_error(&amp;err);</a>
<a name="ln156">  }</a>
<a name="ln157"> </a>
<a name="ln158">  api_free_string(keys);</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161">static void tinput_flush(TermInput *input, bool wait_until_empty)</a>
<a name="ln162">{</a>
<a name="ln163">  size_t drain_boundary = wait_until_empty ? 0 : 0xff;</a>
<a name="ln164">  do {</a>
<a name="ln165">    uv_mutex_lock(&amp;input-&gt;key_buffer_mutex);</a>
<a name="ln166">    loop_schedule_fast(&amp;main_loop, event_create(tinput_wait_enqueue, 1, input));</a>
<a name="ln167">    input-&gt;waiting = true;</a>
<a name="ln168">    while (input-&gt;waiting) {</a>
<a name="ln169">      uv_cond_wait(&amp;input-&gt;key_buffer_cond, &amp;input-&gt;key_buffer_mutex);</a>
<a name="ln170">    }</a>
<a name="ln171">    uv_mutex_unlock(&amp;input-&gt;key_buffer_mutex);</a>
<a name="ln172">  } while (rbuffer_size(input-&gt;key_buffer) &gt; drain_boundary);</a>
<a name="ln173">}</a>
<a name="ln174"> </a>
<a name="ln175">static void tinput_enqueue(TermInput *input, char *buf, size_t size)</a>
<a name="ln176">{</a>
<a name="ln177">  if (rbuffer_size(input-&gt;key_buffer) &gt;</a>
<a name="ln178">      rbuffer_capacity(input-&gt;key_buffer) - 0xff) {</a>
<a name="ln179">    // don't ever let the buffer get too full or we risk putting incomplete keys</a>
<a name="ln180">    // into it</a>
<a name="ln181">    tinput_flush(input, false);</a>
<a name="ln182">  }</a>
<a name="ln183">  rbuffer_write(input-&gt;key_buffer, buf, size);</a>
<a name="ln184">}</a>
<a name="ln185"> </a>
<a name="ln186">static void forward_simple_utf8(TermInput *input, TermKeyKey *key)</a>
<a name="ln187">{</a>
<a name="ln188">  size_t len = 0;</a>
<a name="ln189">  char buf[64];</a>
<a name="ln190">  char *ptr = key-&gt;utf8;</a>
<a name="ln191"> </a>
<a name="ln192">  while (*ptr) {</a>
<a name="ln193">    if (*ptr == '&lt;') {</a>
<a name="ln194">      len += (size_t)snprintf(buf + len, sizeof(buf) - len, &quot;&lt;lt&gt;&quot;);</a>
<a name="ln195">    } else {</a>
<a name="ln196">      buf[len++] = *ptr;</a>
<a name="ln197">    }</a>
<a name="ln198">    ptr++;</a>
<a name="ln199">  }</a>
<a name="ln200"> </a>
<a name="ln201">  tinput_enqueue(input, buf, len);</a>
<a name="ln202">}</a>
<a name="ln203"> </a>
<a name="ln204">static void forward_modified_utf8(TermInput *input, TermKeyKey *key)</a>
<a name="ln205">{</a>
<a name="ln206">  size_t len;</a>
<a name="ln207">  char buf[64];</a>
<a name="ln208"> </a>
<a name="ln209">  if (key-&gt;type == TERMKEY_TYPE_KEYSYM</a>
<a name="ln210">      &amp;&amp; key-&gt;code.sym == TERMKEY_SYM_SUSPEND) {</a>
<a name="ln211">    len = (size_t)snprintf(buf, sizeof(buf), &quot;&lt;C-Z&gt;&quot;);</a>
<a name="ln212">  } else if (key-&gt;type != TERMKEY_TYPE_UNICODE) {</a>
<a name="ln213">    len = termkey_strfkey(input-&gt;tk, buf, sizeof(buf), key, TERMKEY_FORMAT_VIM);</a>
<a name="ln214">  } else {</a>
<a name="ln215">    assert(key-&gt;modifiers);</a>
<a name="ln216">    // Termkey doesn't include the S- modifier for ASCII characters (e.g.,</a>
<a name="ln217">    // ctrl-shift-l is &lt;C-L&gt; instead of &lt;C-S-L&gt;.  Vim, on the other hand,</a>
<a name="ln218">    // treats &lt;C-L&gt; and &lt;C-l&gt; the same, requiring the S- modifier.</a>
<a name="ln219">    len = termkey_strfkey(input-&gt;tk, buf, sizeof(buf), key, TERMKEY_FORMAT_VIM);</a>
<a name="ln220">    if ((key-&gt;modifiers &amp; TERMKEY_KEYMOD_CTRL)</a>
<a name="ln221">        &amp;&amp; !(key-&gt;modifiers &amp; TERMKEY_KEYMOD_SHIFT)</a>
<a name="ln222">        &amp;&amp; ASCII_ISUPPER(key-&gt;code.codepoint)) {</a>
<a name="ln223">      assert(len &lt;= 62);</a>
<a name="ln224">      // Make remove for the S-</a>
<a name="ln225">      memmove(buf + 3, buf + 1, len - 1);</a>
<a name="ln226">      buf[1] = 'S';</a>
<a name="ln227">      buf[2] = '-';</a>
<a name="ln228">      len += 2;</a>
<a name="ln229">    }</a>
<a name="ln230">  }</a>
<a name="ln231"> </a>
<a name="ln232">  tinput_enqueue(input, buf, len);</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235">static void forward_mouse_event(TermInput *input, TermKeyKey *key)</a>
<a name="ln236">{</a>
<a name="ln237">  char buf[64];</a>
<a name="ln238">  size_t len = 0;</a>
<a name="ln239">  int button, row, col;</a>
<a name="ln240">  static int last_pressed_button = 0;</a>
<a name="ln241">  TermKeyMouseEvent ev;</a>
<a name="ln242">  termkey_interpret_mouse(input-&gt;tk, key, &amp;ev, &amp;button, &amp;row, &amp;col);</a>
<a name="ln243"> </a>
<a name="ln244">  if ((ev == TERMKEY_MOUSE_RELEASE || ev == TERMKEY_MOUSE_DRAG)</a>
<a name="ln245">      &amp;&amp; button == 0) {</a>
<a name="ln246">    // Some terminals (like urxvt) don't report which button was released.</a>
<a name="ln247">    // libtermkey reports button 0 in this case.</a>
<a name="ln248">    // For drag and release, we can reasonably infer the button to be the last</a>
<a name="ln249">    // pressed one.</a>
<a name="ln250">    button = last_pressed_button;</a>
<a name="ln251">  }</a>
<a name="ln252"> </a>
<a name="ln253">  if (button == 0 || (ev != TERMKEY_MOUSE_PRESS &amp;&amp; ev != TERMKEY_MOUSE_DRAG</a>
<a name="ln254">                      &amp;&amp; ev != TERMKEY_MOUSE_RELEASE)) {</a>
<a name="ln255">    return;</a>
<a name="ln256">  }</a>
<a name="ln257"> </a>
<a name="ln258">  row--; col--;  // Termkey uses 1-based coordinates</a>
<a name="ln259">  buf[len++] = '&lt;';</a>
<a name="ln260"> </a>
<a name="ln261">  if (key-&gt;modifiers &amp; TERMKEY_KEYMOD_SHIFT) {</a>
<a name="ln262">    len += (size_t)snprintf(buf + len, sizeof(buf) - len, &quot;S-&quot;);</a>
<a name="ln263">  }</a>
<a name="ln264"> </a>
<a name="ln265">  if (key-&gt;modifiers &amp; TERMKEY_KEYMOD_CTRL) {</a>
<a name="ln266">    len += (size_t)snprintf(buf + len, sizeof(buf) - len, &quot;C-&quot;);</a>
<a name="ln267">  }</a>
<a name="ln268"> </a>
<a name="ln269">  if (key-&gt;modifiers &amp; TERMKEY_KEYMOD_ALT) {</a>
<a name="ln270">    len += (size_t)snprintf(buf + len, sizeof(buf) - len, &quot;A-&quot;);</a>
<a name="ln271">  }</a>
<a name="ln272"> </a>
<a name="ln273">  if (button == 1) {</a>
<a name="ln274">    len += (size_t)snprintf(buf + len, sizeof(buf) - len, &quot;Left&quot;);</a>
<a name="ln275">  } else if (button == 2) {</a>
<a name="ln276">    len += (size_t)snprintf(buf + len, sizeof(buf) - len, &quot;Middle&quot;);</a>
<a name="ln277">  } else if (button == 3) {</a>
<a name="ln278">    len += (size_t)snprintf(buf + len, sizeof(buf) - len, &quot;Right&quot;);</a>
<a name="ln279">  }</a>
<a name="ln280"> </a>
<a name="ln281">  switch (ev) {</a>
<a name="ln282">    case TERMKEY_MOUSE_PRESS:</a>
<a name="ln283">      if (button == 4) {</a>
<a name="ln284">        len += (size_t)snprintf(buf + len, sizeof(buf) - len, &quot;ScrollWheelUp&quot;);</a>
<a name="ln285">      } else if (button == 5) {</a>
<a name="ln286">        len += (size_t)snprintf(buf + len, sizeof(buf) - len,</a>
<a name="ln287">                                &quot;ScrollWheelDown&quot;);</a>
<a name="ln288">      } else {</a>
<a name="ln289">        len += (size_t)snprintf(buf + len, sizeof(buf) - len, &quot;Mouse&quot;);</a>
<a name="ln290">        last_pressed_button = button;</a>
<a name="ln291">      }</a>
<a name="ln292">      break;</a>
<a name="ln293">    case TERMKEY_MOUSE_DRAG:</a>
<a name="ln294">      len += (size_t)snprintf(buf + len, sizeof(buf) - len, &quot;Drag&quot;);</a>
<a name="ln295">      break;</a>
<a name="ln296">    case TERMKEY_MOUSE_RELEASE:</a>
<a name="ln297">      len += (size_t)snprintf(buf + len, sizeof(buf) - len, &quot;Release&quot;);</a>
<a name="ln298">      break;</a>
<a name="ln299">    case TERMKEY_MOUSE_UNKNOWN:</a>
<a name="ln300">      abort();</a>
<a name="ln301">  }</a>
<a name="ln302"> </a>
<a name="ln303">  len += (size_t)snprintf(buf + len, sizeof(buf) - len, &quot;&gt;&lt;%d,%d&gt;&quot;, col, row);</a>
<a name="ln304">  tinput_enqueue(input, buf, len);</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">static TermKeyResult tk_getkey(TermKey *tk, TermKeyKey *key, bool force)</a>
<a name="ln308">{</a>
<a name="ln309">  return force ? termkey_getkey_force(tk, key) : termkey_getkey(tk, key);</a>
<a name="ln310">}</a>
<a name="ln311"> </a>
<a name="ln312">static void tinput_timer_cb(TimeWatcher *watcher, void *data);</a>
<a name="ln313"> </a>
<a name="ln314">static void tk_getkeys(TermInput *input, bool force)</a>
<a name="ln315">{</a>
<a name="ln316">  TermKeyKey key;</a>
<a name="ln317">  TermKeyResult result;</a>
<a name="ln318"> </a>
<a name="ln319">  while ((result = tk_getkey(input-&gt;tk, &amp;key, force)) == TERMKEY_RES_KEY) {</a>
<a name="ln320">    if (key.type == TERMKEY_TYPE_UNICODE &amp;&amp; !key.modifiers) {</a>
<a name="ln321">      forward_simple_utf8(input, &amp;key);</a>
<a name="ln322">    } else if (key.type == TERMKEY_TYPE_UNICODE</a>
<a name="ln323">               || key.type == TERMKEY_TYPE_FUNCTION</a>
<a name="ln324">               || key.type == TERMKEY_TYPE_KEYSYM) {</a>
<a name="ln325">      forward_modified_utf8(input, &amp;key);</a>
<a name="ln326">    } else if (key.type == TERMKEY_TYPE_MOUSE) {</a>
<a name="ln327">      forward_mouse_event(input, &amp;key);</a>
<a name="ln328">    }</a>
<a name="ln329">  }</a>
<a name="ln330"> </a>
<a name="ln331">  if (result != TERMKEY_RES_AGAIN) {</a>
<a name="ln332">    return;</a>
<a name="ln333">  }</a>
<a name="ln334">  // else: Partial keypress event was found in the buffer, but it does not</a>
<a name="ln335">  // yet contain all the bytes required. `key` structure indicates what</a>
<a name="ln336">  // termkey_getkey_force() would return.</a>
<a name="ln337"> </a>
<a name="ln338">  if (input-&gt;ttimeout &amp;&amp; input-&gt;ttimeoutlen &gt;= 0) {</a>
<a name="ln339">    // Stop the current timer if already running</a>
<a name="ln340">    time_watcher_stop(&amp;input-&gt;timer_handle);</a>
<a name="ln341">    time_watcher_start(&amp;input-&gt;timer_handle, tinput_timer_cb,</a>
<a name="ln342">                       (uint64_t)input-&gt;ttimeoutlen, 0);</a>
<a name="ln343">  } else {</a>
<a name="ln344">    tk_getkeys(input, true);</a>
<a name="ln345">  }</a>
<a name="ln346">}</a>
<a name="ln347"> </a>
<a name="ln348">static void tinput_timer_cb(TimeWatcher *watcher, void *data)</a>
<a name="ln349">{</a>
<a name="ln350">  TermInput *input = (TermInput *)data;</a>
<a name="ln351">  // If the raw buffer is not empty, process the raw buffer first because it is</a>
<a name="ln352">  // processing an incomplete bracketed paster sequence.</a>
<a name="ln353">  if (rbuffer_size(input-&gt;read_stream.buffer)) {</a>
<a name="ln354">    handle_raw_buffer(input, true);</a>
<a name="ln355">  }</a>
<a name="ln356">  tk_getkeys(input, true);</a>
<a name="ln357">  tinput_flush(input, true);</a>
<a name="ln358">}</a>
<a name="ln359"> </a>
<a name="ln360">/// Handle focus events.</a>
<a name="ln361">///</a>
<a name="ln362">/// If the upcoming sequence of bytes in the input stream matches the termcode</a>
<a name="ln363">/// for &quot;focus gained&quot; or &quot;focus lost&quot;, consume that sequence and schedule an</a>
<a name="ln364">/// event on the main loop.</a>
<a name="ln365">///</a>
<a name="ln366">/// @param input the input stream</a>
<a name="ln367">/// @return true iff handle_focus_event consumed some input</a>
<a name="ln368">static bool handle_focus_event(TermInput *input)</a>
<a name="ln369">{</a>
<a name="ln370">  if (rbuffer_size(input-&gt;read_stream.buffer) &gt; 2</a>
<a name="ln371">      &amp;&amp; (!rbuffer_cmp(input-&gt;read_stream.buffer, &quot;\x1b[I&quot;, 3)</a>
<a name="ln372">          || !rbuffer_cmp(input-&gt;read_stream.buffer, &quot;\x1b[O&quot;, 3))) {</a>
<a name="ln373">    bool focus_gained = *rbuffer_get(input-&gt;read_stream.buffer, 2) == 'I';</a>
<a name="ln374">    // Advance past the sequence</a>
<a name="ln375">    rbuffer_consumed(input-&gt;read_stream.buffer, 3);</a>
<a name="ln376">    aucmd_schedule_focusgained(focus_gained);</a>
<a name="ln377">    return true;</a>
<a name="ln378">  }</a>
<a name="ln379">  return false;</a>
<a name="ln380">}</a>
<a name="ln381"> </a>
<a name="ln382">#define START_PASTE &quot;\x1b[200~&quot;</a>
<a name="ln383">#define END_PASTE   &quot;\x1b[201~&quot;</a>
<a name="ln384">static HandleState handle_bracketed_paste(TermInput *input)</a>
<a name="ln385">{</a>
<a name="ln386">  size_t buf_size = rbuffer_size(input-&gt;read_stream.buffer);</a>
<a name="ln387">  if (buf_size &gt; 5</a>
<a name="ln388">      &amp;&amp; (!rbuffer_cmp(input-&gt;read_stream.buffer, START_PASTE, 6)</a>
<a name="ln389">          || !rbuffer_cmp(input-&gt;read_stream.buffer, END_PASTE, 6))) {</a>
<a name="ln390">    bool enable = *rbuffer_get(input-&gt;read_stream.buffer, 4) == '0';</a>
<a name="ln391">    if (input-&gt;paste &amp;&amp; enable) {</a>
<a name="ln392">      return kNotApplicable;  // Pasting &quot;start paste&quot; code literally.</a>
<a name="ln393">    }</a>
<a name="ln394">    // Advance past the sequence</a>
<a name="ln395">    rbuffer_consumed(input-&gt;read_stream.buffer, 6);</a>
<a name="ln396">    if (!!input-&gt;paste == enable) {</a>
<a name="ln397">      return kComplete;  // Spurious &quot;disable paste&quot; code.</a>
<a name="ln398">    }</a>
<a name="ln399"> </a>
<a name="ln400">    if (enable) {</a>
<a name="ln401">      // Flush before starting paste.</a>
<a name="ln402">      tinput_flush(input, true);</a>
<a name="ln403">      // Paste phase: &quot;first-chunk&quot;.</a>
<a name="ln404">      input-&gt;paste = 1;</a>
<a name="ln405">    } else if (input-&gt;paste) {</a>
<a name="ln406">      // Paste phase: &quot;last-chunk&quot;.</a>
<a name="ln407">      input-&gt;paste = input-&gt;paste == 2 ? 3 : -1;</a>
<a name="ln408">      tinput_flush(input, true);</a>
<a name="ln409">      // Paste phase: &quot;disabled&quot;.</a>
<a name="ln410">      input-&gt;paste = 0;</a>
<a name="ln411">    }</a>
<a name="ln412">    return kComplete;</a>
<a name="ln413">  } else if (buf_size &lt; 6</a>
<a name="ln414">             &amp;&amp; (!rbuffer_cmp(input-&gt;read_stream.buffer, START_PASTE, buf_size)</a>
<a name="ln415">                 || !rbuffer_cmp(input-&gt;read_stream.buffer,</a>
<a name="ln416">                                 END_PASTE, buf_size))) {</a>
<a name="ln417">    // Wait for further input, as the sequence may be split.</a>
<a name="ln418">    return kIncomplete;</a>
<a name="ln419">  }</a>
<a name="ln420">  return kNotApplicable;</a>
<a name="ln421">}</a>
<a name="ln422"> </a>
<a name="ln423">// ESC NUL =&gt; &lt;Esc&gt;</a>
<a name="ln424">static bool handle_forced_escape(TermInput *input)</a>
<a name="ln425">{</a>
<a name="ln426">  if (rbuffer_size(input-&gt;read_stream.buffer) &gt; 1</a>
<a name="ln427">      &amp;&amp; !rbuffer_cmp(input-&gt;read_stream.buffer, &quot;\x1b\x00&quot;, 2)) {</a>
<a name="ln428">    // skip the ESC and NUL and push one &lt;esc&gt; to the input buffer</a>
<a name="ln429">    size_t rcnt;</a>
<a name="ln430">    termkey_push_bytes(input-&gt;tk, rbuffer_read_ptr(input-&gt;read_stream.buffer,</a>
<a name="ln431">          &amp;rcnt), 1);</a>
<a name="ln432">    rbuffer_consumed(input-&gt;read_stream.buffer, 2);</a>
<a name="ln433">    tk_getkeys(input, true);</a>
<a name="ln434">    return true;</a>
<a name="ln435">  }</a>
<a name="ln436">  return false;</a>
<a name="ln437">}</a>
<a name="ln438"> </a>
<a name="ln439">static void set_bg_deferred(void **argv)</a>
<a name="ln440">{</a>
<a name="ln441">  char *bgvalue = argv[0];</a>
<a name="ln442">  if (!option_was_set(&quot;bg&quot;) &amp;&amp; !strequal((char *)p_bg, bgvalue)) {</a>
<a name="ln443">    // Value differs, apply it.</a>
<a name="ln444">    if (starting) {</a>
<a name="ln445">      // Wait until after startup, so OptionSet is triggered.</a>
<a name="ln446">      do_cmdline_cmd((bgvalue[0] == 'l')</a>
<a name="ln447">                     ? &quot;autocmd VimEnter * ++once ++nested set bg=light&quot;</a>
<a name="ln448">                     : &quot;autocmd VimEnter * ++once ++nested set bg=dark&quot;);</a>
<a name="ln449">    } else {</a>
<a name="ln450">      set_option_value(&quot;bg&quot;, 0L, bgvalue, 0);</a>
<a name="ln451">      reset_option_was_set(&quot;bg&quot;);</a>
<a name="ln452">    }</a>
<a name="ln453">  }</a>
<a name="ln454">}</a>
<a name="ln455"> </a>
<a name="ln456">// During startup, tui.c requests the background color (see `ext.get_bg`).</a>
<a name="ln457">//</a>
<a name="ln458">// Here in input.c, we watch for the terminal response `\e]11;COLOR\a`.  If</a>
<a name="ln459">// COLOR matches `rgb:RRRR/GGGG/BBBB/AAAA` where R, G, B, and A are hex digits,</a>
<a name="ln460">// then compute the luminance[1] of the RGB color and classify it as light/dark</a>
<a name="ln461">// accordingly. Note that the color components may have anywhere from one to</a>
<a name="ln462">// four hex digits, and require scaling accordingly as values out of 4, 8, 12,</a>
<a name="ln463">// or 16 bits. Also note the A(lpha) component is optional, and is parsed but</a>
<a name="ln464">// ignored in the calculations.</a>
<a name="ln465">//</a>
<a name="ln466">// [1] https://en.wikipedia.org/wiki/Luma_%28video%29</a>
<a name="ln467">static HandleState handle_background_color(TermInput *input)</a>
<a name="ln468">{</a>
<a name="ln469">  if (input-&gt;waiting_for_bg_response &lt;= 0) {</a>
<a name="ln470">    return kNotApplicable;</a>
<a name="ln471">  }</a>
<a name="ln472">  size_t count = 0;</a>
<a name="ln473">  size_t component = 0;</a>
<a name="ln474">  size_t header_size = 0;</a>
<a name="ln475">  size_t num_components = 0;</a>
<a name="ln476">  size_t buf_size = rbuffer_size(input-&gt;read_stream.buffer);</a>
<a name="ln477">  uint16_t rgb[] = { 0, 0, 0 };</a>
<a name="ln478">  uint16_t rgb_max[] = { 0, 0, 0 };</a>
<a name="ln479">  bool eat_backslash = false;</a>
<a name="ln480">  bool done = false;</a>
<a name="ln481">  bool bad = false;</a>
<a name="ln482">  if (buf_size &gt;= 9</a>
<a name="ln483">      &amp;&amp; !rbuffer_cmp(input-&gt;read_stream.buffer, &quot;\x1b]11;rgb:&quot;, 9)) {</a>
<a name="ln484">    header_size = 9;</a>
<a name="ln485">    num_components = 3;</a>
<a name="ln486">  } else if (buf_size &gt;= 10</a>
<a name="ln487">             &amp;&amp; !rbuffer_cmp(input-&gt;read_stream.buffer, &quot;\x1b]11;rgba:&quot;, 10)) {</a>
<a name="ln488">    header_size = 10;</a>
<a name="ln489">    num_components = 4;</a>
<a name="ln490">  } else if (buf_size &lt; 10</a>
<a name="ln491">             &amp;&amp; !rbuffer_cmp(input-&gt;read_stream.buffer,</a>
<a name="ln492">                             &quot;\x1b]11;rgba&quot;, buf_size)) {</a>
<a name="ln493">    // An incomplete sequence was found, waiting for the next input.</a>
<a name="ln494">    return kIncomplete;</a>
<a name="ln495">  } else {</a>
<a name="ln496">    input-&gt;waiting_for_bg_response--;</a>
<a name="ln497">    if (input-&gt;waiting_for_bg_response == 0) {</a>
<a name="ln498">      DLOG(&quot;did not get a response for terminal background query&quot;);</a>
<a name="ln499">    }</a>
<a name="ln500">    return kNotApplicable;</a>
<a name="ln501">  }</a>
<a name="ln502">  RBUFFER_EACH(input-&gt;read_stream.buffer, c, i) {</a>
<a name="ln503">    count = i + 1;</a>
<a name="ln504">    // Skip the header.</a>
<a name="ln505">    if (i &lt; header_size) {</a>
<a name="ln506">      continue;</a>
<a name="ln507">    }</a>
<a name="ln508">    if (eat_backslash) {</a>
<a name="ln509">      done = true;</a>
<a name="ln510">      break;</a>
<a name="ln511">    } else if (c == '\x07') {</a>
<a name="ln512">      done = true;</a>
<a name="ln513">      break;</a>
<a name="ln514">    } else if (c == '\x1b') {</a>
<a name="ln515">      eat_backslash = true;</a>
<a name="ln516">    } else if (bad) {</a>
<a name="ln517">      // ignore</a>
<a name="ln518">    } else if ((c == '/') &amp;&amp; (++component &lt; num_components)) {</a>
<a name="ln519">      // work done in condition</a>
<a name="ln520">    } else if (ascii_isxdigit(c)) {</a>
<a name="ln521">      if (component &lt; 3 &amp;&amp; rgb_max[component] != 0xffff) {</a>
<a name="ln522">        rgb_max[component] = (uint16_t)((rgb_max[component] &lt;&lt; 4) | 0xf);</a>
<a name="ln523">        rgb[component] = (uint16_t)((rgb[component] &lt;&lt; 4) | hex2nr(c));</a>
<a name="ln524">      }</a>
<a name="ln525">    } else {</a>
<a name="ln526">      bad = true;</a>
<a name="ln527">    }</a>
<a name="ln528">  }</a>
<a name="ln529">  if (done &amp;&amp; !bad &amp;&amp; rgb_max[0] &amp;&amp; rgb_max[1] &amp;&amp; rgb_max[2]) {</a>
<a name="ln530">    rbuffer_consumed(input-&gt;read_stream.buffer, count);</a>
<a name="ln531">    double r = (double)rgb[0] / (double)rgb_max[0];</a>
<a name="ln532">    double g = (double)rgb[1] / (double)rgb_max[1];</a>
<a name="ln533">    double b = (double)rgb[2] / (double)rgb_max[2];</a>
<a name="ln534">    double luminance = (0.299 * r) + (0.587 * g) + (0.114 * b);  // CCIR 601</a>
<a name="ln535">    char *bgvalue = luminance &lt; 0.5 ? &quot;dark&quot; : &quot;light&quot;;</a>
<a name="ln536">    DLOG(&quot;bg response: %s&quot;, bgvalue);</a>
<a name="ln537">    loop_schedule_deferred(&amp;main_loop,</a>
<a name="ln538">                           event_create(set_bg_deferred, 1, bgvalue));</a>
<a name="ln539">    input-&gt;waiting_for_bg_response = 0;</a>
<a name="ln540">  } else if (!done &amp;&amp; !bad) {</a>
<a name="ln541">    // An incomplete sequence was found, waiting for the next input.</a>
<a name="ln542">    return kIncomplete;</a>
<a name="ln543">  } else {</a>
<a name="ln544">    input-&gt;waiting_for_bg_response = 0;</a>
<a name="ln545">    rbuffer_consumed(input-&gt;read_stream.buffer, count);</a>
<a name="ln546">    DLOG(&quot;failed to parse bg response&quot;);</a>
<a name="ln547">    return kNotApplicable;</a>
<a name="ln548">  }</a>
<a name="ln549">  return kComplete;</a>
<a name="ln550">}</a>
<a name="ln551">#ifdef UNIT_TESTING</a>
<a name="ln552">HandleState ut_handle_background_color(TermInput *input)</a>
<a name="ln553">{</a>
<a name="ln554">  return handle_background_color(input);</a>
<a name="ln555">}</a>
<a name="ln556">#endif</a>
<a name="ln557"> </a>
<a name="ln558">static void handle_raw_buffer(TermInput *input, bool force)</a>
<a name="ln559">{</a>
<a name="ln560">  HandleState is_paste = kNotApplicable;</a>
<a name="ln561">  HandleState is_bc = kNotApplicable;</a>
<a name="ln562"> </a>
<a name="ln563">  do {</a>
<a name="ln564">    if (!force</a>
<a name="ln565">        &amp;&amp; (handle_focus_event(input)</a>
<a name="ln566">            || (is_paste = handle_bracketed_paste(input)) != kNotApplicable</a>
<a name="ln567">            || handle_forced_escape(input)</a>
<a name="ln568">            || (is_bc = handle_background_color(input)) != kNotApplicable)) {</a>
<a name="ln569">      if (is_paste == kIncomplete || is_bc == kIncomplete) {</a>
<a name="ln570">        // Wait for the next input, leaving it in the raw buffer due to an</a>
<a name="ln571">        // incomplete sequence.</a>
<a name="ln572">        return;</a>
<a name="ln573">      }</a>
<a name="ln574">      continue;</a>
<a name="ln575">    }</a>
<a name="ln576"> </a>
<a name="ln577">    //</a>
<a name="ln578">    // Find the next ESC and push everything up to it (excluding), so it will</a>
<a name="ln579">    // be the first thing encountered on the next iteration. The `handle_*`</a>
<a name="ln580">    // calls (above) depend on this.</a>
<a name="ln581">    //</a>
<a name="ln582">    size_t count = 0;</a>
<a name="ln583">    RBUFFER_EACH(input-&gt;read_stream.buffer, c, i) {</a>
<a name="ln584">      count = i + 1;</a>
<a name="ln585">      if (c == '\x1b' &amp;&amp; count &gt; 1) {</a>
<a name="ln586">        count--;</a>
<a name="ln587">        break;</a>
<a name="ln588">      }</a>
<a name="ln589">    }</a>
<a name="ln590">    // Push bytes directly (paste).</a>
<a name="ln591">    if (input-&gt;paste) {</a>
<a name="ln592">      RBUFFER_UNTIL_EMPTY(input-&gt;read_stream.buffer, ptr, len) {</a>
<a name="ln593">        size_t consumed = MIN(count, len);</a>
<a name="ln594">        assert(consumed &lt;= input-&gt;read_stream.buffer-&gt;size);</a>
<a name="ln595">        tinput_enqueue(input, ptr, consumed);</a>
<a name="ln596">        rbuffer_consumed(input-&gt;read_stream.buffer, consumed);</a>
<a name="ln597">        if (!(count -= consumed)) {</a>
<a name="ln598">          break;</a>
<a name="ln599">        }</a>
<a name="ln600">      }</a>
<a name="ln601">      continue;</a>
<a name="ln602">    }</a>
<a name="ln603">    // Push through libtermkey (translates to &quot;&lt;keycode&gt;&quot; strings, etc.).</a>
<a name="ln604">    RBUFFER_UNTIL_EMPTY(input-&gt;read_stream.buffer, ptr, len) {</a>
<a name="ln605">      size_t consumed = termkey_push_bytes(input-&gt;tk, ptr, MIN(count, len));</a>
<a name="ln606">      // termkey_push_bytes can return (size_t)-1, so it is possible that</a>
<a name="ln607">      // `consumed &gt; input-&gt;read_stream.buffer-&gt;size`, but since tk_getkeys is</a>
<a name="ln608">      // called soon, it shouldn't happen.</a>
<a name="ln609">      assert(consumed &lt;= input-&gt;read_stream.buffer-&gt;size);</a>
<a name="ln610">      rbuffer_consumed(input-&gt;read_stream.buffer, consumed);</a>
<a name="ln611">      // Process the keys now: there is no guarantee `count` will</a>
<a name="ln612">      // fit into libtermkey's input buffer.</a>
<a name="ln613">      tk_getkeys(input, false);</a>
<a name="ln614">      if (!(count -= consumed)) {</a>
<a name="ln615">        break;</a>
<a name="ln616">      }</a>
<a name="ln617">    }</a>
<a name="ln618">  } while (rbuffer_size(input-&gt;read_stream.buffer));</a>
<a name="ln619">}</a>
<a name="ln620"> </a>
<a name="ln621">static void tinput_read_cb(Stream *stream, RBuffer *buf, size_t count_,</a>
<a name="ln622">                           void *data, bool eof)</a>
<a name="ln623">{</a>
<a name="ln624">  TermInput *input = data;</a>
<a name="ln625"> </a>
<a name="ln626">  if (eof) {</a>
<a name="ln627">    loop_schedule_fast(&amp;main_loop, event_create(tinput_done_event, 0));</a>
<a name="ln628">    return;</a>
<a name="ln629">  }</a>
<a name="ln630"> </a>
<a name="ln631">  handle_raw_buffer(input, false);</a>
<a name="ln632">  tinput_flush(input, true);</a>
<a name="ln633"> </a>
<a name="ln634">  // An incomplete sequence was found. Leave it in the raw buffer and wait for</a>
<a name="ln635">  // the next input.</a>
<a name="ln636">  if (rbuffer_size(input-&gt;read_stream.buffer)) {</a>
<a name="ln637">    // If 'ttimeout' is not set, start the timer with a timeout of 0 to process</a>
<a name="ln638">    // the next input.</a>
<a name="ln639">    long ms = input-&gt;ttimeout ?</a>
<a name="ln640">      (input-&gt;ttimeoutlen &gt;= 0 ? input-&gt;ttimeoutlen : 0) : 0;</a>
<a name="ln641">    // Stop the current timer if already running</a>
<a name="ln642">    time_watcher_stop(&amp;input-&gt;timer_handle);</a>
<a name="ln643">    time_watcher_start(&amp;input-&gt;timer_handle, tinput_timer_cb, (uint32_t)ms, 0);</a>
<a name="ln644">    return;</a>
<a name="ln645">  }</a>
<a name="ln646"> </a>
<a name="ln647">  // Make sure the next input escape sequence fits into the ring buffer without</a>
<a name="ln648">  // wraparound, else it could be misinterpreted (because rbuffer_read_ptr()</a>
<a name="ln649">  // exposes the underlying buffer to callers unaware of the wraparound).</a>
<a name="ln650">  rbuffer_reset(input-&gt;read_stream.buffer);</a>
<a name="ln651">}</a>

</code></pre>
<div class="balloon" rel="592"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1044/" target="_blank">V1044</a> Loop break conditions do not depend on the number of iterations.</p></div>
<div class="balloon" rel="604"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1044/" target="_blank">V1044</a> Loop break conditions do not depend on the number of iterations.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
